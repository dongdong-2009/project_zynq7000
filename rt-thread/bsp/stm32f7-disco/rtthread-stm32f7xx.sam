
rtthread-stm32f7xx.axf:     file format elf32-littlearm


Disassembly of section .text:

08000000 <_stext>:
 8000000:	200107b4 	.word	0x200107b4
 8000004:	08010395 	.word	0x08010395
 8000008:	08014cf9 	.word	0x08014cf9
 800000c:	080002a7 	.word	0x080002a7
 8000010:	080103e5 	.word	0x080103e5
 8000014:	08014d05 	.word	0x08014d05
 8000018:	08014d0d 	.word	0x08014d0d
	...
 800002c:	080103e5 	.word	0x080103e5
 8000030:	08014d15 	.word	0x08014d15
 8000034:	00000000 	.word	0x00000000
 8000038:	080001f5 	.word	0x080001f5
 800003c:	08012a1d 	.word	0x08012a1d
 8000040:	080103e5 	.word	0x080103e5
 8000044:	080103e5 	.word	0x080103e5
 8000048:	080103e5 	.word	0x080103e5
 800004c:	080103e5 	.word	0x080103e5
 8000050:	080103e5 	.word	0x080103e5
 8000054:	080103e5 	.word	0x080103e5
 8000058:	080103e5 	.word	0x080103e5
 800005c:	080103e5 	.word	0x080103e5
 8000060:	080103e5 	.word	0x080103e5
 8000064:	080103e5 	.word	0x080103e5
 8000068:	080103e5 	.word	0x080103e5
 800006c:	080103e5 	.word	0x080103e5
 8000070:	08014a2d 	.word	0x08014a2d
 8000074:	080103e5 	.word	0x080103e5
 8000078:	080103e5 	.word	0x080103e5
 800007c:	080103e5 	.word	0x080103e5
 8000080:	080103e5 	.word	0x080103e5
 8000084:	080103e5 	.word	0x080103e5
 8000088:	0801336d 	.word	0x0801336d
 800008c:	080120ed 	.word	0x080120ed
 8000090:	08012125 	.word	0x08012125
 8000094:	08012149 	.word	0x08012149
 8000098:	08012241 	.word	0x08012241
 800009c:	080103e5 	.word	0x080103e5
 80000a0:	080103e5 	.word	0x080103e5
 80000a4:	080103e5 	.word	0x080103e5
 80000a8:	080103e5 	.word	0x080103e5
 80000ac:	080103e5 	.word	0x080103e5
 80000b0:	080103e5 	.word	0x080103e5
 80000b4:	080103e5 	.word	0x080103e5
 80000b8:	080103e5 	.word	0x080103e5
 80000bc:	080103e5 	.word	0x080103e5
 80000c0:	080103e5 	.word	0x080103e5
 80000c4:	080103e5 	.word	0x080103e5
 80000c8:	080103e5 	.word	0x080103e5
 80000cc:	080103e5 	.word	0x080103e5
 80000d0:	080103e5 	.word	0x080103e5
 80000d4:	08014985 	.word	0x08014985
 80000d8:	080103e5 	.word	0x080103e5
 80000dc:	080149d9 	.word	0x080149d9
 80000e0:	080103e5 	.word	0x080103e5
 80000e4:	080103e5 	.word	0x080103e5
 80000e8:	080103e5 	.word	0x080103e5
 80000ec:	08014045 	.word	0x08014045
 80000f0:	08014069 	.word	0x08014069
 80000f4:	080103e5 	.word	0x080103e5
 80000f8:	080103e5 	.word	0x080103e5
 80000fc:	080103e5 	.word	0x080103e5
 8000100:	080103e5 	.word	0x080103e5
 8000104:	080103e5 	.word	0x080103e5
 8000108:	0801397d 	.word	0x0801397d
 800010c:	080103e5 	.word	0x080103e5
 8000110:	080103e5 	.word	0x080103e5
 8000114:	080103e5 	.word	0x080103e5
 8000118:	080103e5 	.word	0x080103e5
 800011c:	080103e5 	.word	0x080103e5
 8000120:	08013fe5 	.word	0x08013fe5
 8000124:	080103e5 	.word	0x080103e5
 8000128:	080103e5 	.word	0x080103e5
 800012c:	080103e5 	.word	0x080103e5
 8000130:	080103e5 	.word	0x080103e5
 8000134:	080103e5 	.word	0x080103e5
 8000138:	080103e5 	.word	0x080103e5
 800013c:	080103e5 	.word	0x080103e5
 8000140:	080103e5 	.word	0x080103e5
 8000144:	080103e5 	.word	0x080103e5
 8000148:	080103e5 	.word	0x080103e5
 800014c:	080103e5 	.word	0x080103e5
 8000150:	080103e5 	.word	0x080103e5
 8000154:	080103e5 	.word	0x080103e5
 8000158:	080103e5 	.word	0x080103e5
 800015c:	080103e5 	.word	0x080103e5
 8000160:	080103e5 	.word	0x080103e5
 8000164:	080103e5 	.word	0x080103e5
 8000168:	080103e5 	.word	0x080103e5
 800016c:	080103e5 	.word	0x080103e5
 8000170:	080103e5 	.word	0x080103e5
 8000174:	080103e5 	.word	0x080103e5
 8000178:	080103e5 	.word	0x080103e5
 800017c:	00000000 	.word	0x00000000
 8000180:	080103e5 	.word	0x080103e5
 8000184:	080103e5 	.word	0x080103e5
 8000188:	080103e5 	.word	0x080103e5
 800018c:	080103e5 	.word	0x080103e5
 8000190:	080103e5 	.word	0x080103e5
 8000194:	080103e5 	.word	0x080103e5
 8000198:	080103e5 	.word	0x080103e5
 800019c:	080103e5 	.word	0x080103e5
 80001a0:	080103e5 	.word	0x080103e5
 80001a4:	080103e5 	.word	0x080103e5
 80001a8:	080103e5 	.word	0x080103e5
 80001ac:	080103e5 	.word	0x080103e5
 80001b0:	080103e5 	.word	0x080103e5
 80001b4:	080103e5 	.word	0x080103e5
 80001b8:	080103e5 	.word	0x080103e5
 80001bc:	080103e5 	.word	0x080103e5
 80001c0:	080103e5 	.word	0x080103e5
 80001c4:	080103e5 	.word	0x080103e5

080001c8 <rt_hw_interrupt_disable>:
 * rt_base_t rt_hw_interrupt_disable();
 */
.global rt_hw_interrupt_disable
.type rt_hw_interrupt_disable, %function
rt_hw_interrupt_disable:
    MRS     r0, PRIMASK
 80001c8:	f3ef 8010 	mrs	r0, PRIMASK
    CPSID   I
 80001cc:	b672      	cpsid	i
    BX      LR
 80001ce:	4770      	bx	lr

080001d0 <rt_hw_interrupt_enable>:
 * void rt_hw_interrupt_enable(rt_base_t level);
 */
.global rt_hw_interrupt_enable
.type rt_hw_interrupt_enable, %function
rt_hw_interrupt_enable:
    MSR     PRIMASK, r0
 80001d0:	f380 8810 	msr	PRIMASK, r0
    BX      LR
 80001d4:	4770      	bx	lr

080001d6 <rt_hw_context_switch>:
.type rt_hw_context_switch, %function

rt_hw_context_switch_interrupt:
rt_hw_context_switch:
    /* set rt_thread_switch_interrupt_flag to 1 */
    LDR     r2, =rt_thread_switch_interrupt_flag
 80001d6:	4a39      	ldr	r2, [pc, #228]	; (80002bc <HardFault_Handler+0x16>)
    LDR     r3, [r2]
 80001d8:	6813      	ldr	r3, [r2, #0]
    CMP     r3, #1
 80001da:	2b01      	cmp	r3, #1
    BEQ     _reswitch
 80001dc:	d004      	beq.n	80001e8 <_reswitch>
    MOV     r3, #1
 80001de:	f04f 0301 	mov.w	r3, #1
    STR     r3, [r2]
 80001e2:	6013      	str	r3, [r2, #0]

    LDR     r2, =rt_interrupt_from_thread   /* set rt_interrupt_from_thread */
 80001e4:	4a36      	ldr	r2, [pc, #216]	; (80002c0 <HardFault_Handler+0x1a>)
    STR     r0, [r2]
 80001e6:	6010      	str	r0, [r2, #0]

080001e8 <_reswitch>:

_reswitch:
    LDR     r2, =rt_interrupt_to_thread     /* set rt_interrupt_to_thread */
 80001e8:	4a36      	ldr	r2, [pc, #216]	; (80002c4 <HardFault_Handler+0x1e>)
    STR     r1, [r2]
 80001ea:	6011      	str	r1, [r2, #0]

    LDR r0, =NVIC_INT_CTRL              /* trigger the PendSV exception (causes context switch) */
 80001ec:	4836      	ldr	r0, [pc, #216]	; (80002c8 <HardFault_Handler+0x22>)
    LDR r1, =NVIC_PENDSVSET
 80001ee:	4937      	ldr	r1, [pc, #220]	; (80002cc <HardFault_Handler+0x26>)
    STR r1, [r0]
 80001f0:	6001      	str	r1, [r0, #0]
    BX  LR
 80001f2:	4770      	bx	lr

080001f4 <PendSV_Handler>:
 */
.global PendSV_Handler
.type PendSV_Handler, %function
PendSV_Handler:
    /* disable interrupt to protect context switch */
    MRS r2, PRIMASK
 80001f4:	f3ef 8210 	mrs	r2, PRIMASK
    CPSID   I
 80001f8:	b672      	cpsid	i

    /* get rt_thread_switch_interrupt_flag */
    LDR r0, =rt_thread_switch_interrupt_flag
 80001fa:	4830      	ldr	r0, [pc, #192]	; (80002bc <HardFault_Handler+0x16>)
    LDR r1, [r0]
 80001fc:	6801      	ldr	r1, [r0, #0]
    CBZ r1, pendsv_exit         /* pendsv already handled */
 80001fe:	b321      	cbz	r1, 800024a <pendsv_exit>

    /* clear rt_thread_switch_interrupt_flag to 0 */
    MOV r1, #0x00
 8000200:	f04f 0100 	mov.w	r1, #0
    STR r1, [r0]
 8000204:	6001      	str	r1, [r0, #0]

    LDR r0, =rt_interrupt_from_thread
 8000206:	482e      	ldr	r0, [pc, #184]	; (80002c0 <HardFault_Handler+0x1a>)
    LDR r1, [r0]
 8000208:	6801      	ldr	r1, [r0, #0]
    CBZ r1, switch_to_thread    /* skip register save at the first time */
 800020a:	b191      	cbz	r1, 8000232 <switch_to_thread>

    MRS r1, psp                 /* get from thread stack pointer */
 800020c:	f3ef 8109 	mrs	r1, PSP
    
#if defined (__VFP_FP__) && !defined(__SOFTFP__)
    TST     lr, #0x10           /* if(!EXC_RETURN[4]) */
 8000210:	f01e 0f10 	tst.w	lr, #16
    VSTMDBEQ r1!, {d8 - d15}    /* push FPU register s16~s31 */
 8000214:	bf08      	it	eq
 8000216:	ed21 8b10 	vstmdbeq	r1!, {d8-d15}
#endif
    
    STMFD   r1!, {r4 - r11}     /* push r4 - r11 register */
 800021a:	e921 0ff0 	stmdb	r1!, {r4, r5, r6, r7, r8, r9, sl, fp}

#if defined (__VFP_FP__) && !defined(__SOFTFP__)
    MOV     r4, #0x00           /* flag = 0 */
 800021e:	f04f 0400 	mov.w	r4, #0

    TST     lr, #0x10           /* if(!EXC_RETURN[4]) */
 8000222:	f01e 0f10 	tst.w	lr, #16
    MOVEQ   r4, #0x01           /* flag = 1 */
 8000226:	bf08      	it	eq
 8000228:	2401      	moveq	r4, #1

    STMFD   r1!, {r4}           /* push flag */
 800022a:	f841 4d04 	str.w	r4, [r1, #-4]!
#endif

    LDR r0, [r0]
 800022e:	6800      	ldr	r0, [r0, #0]
    STR r1, [r0]                /* update from thread stack pointer */
 8000230:	6001      	str	r1, [r0, #0]

08000232 <switch_to_thread>:

switch_to_thread:
    LDR r1, =rt_interrupt_to_thread
 8000232:	4924      	ldr	r1, [pc, #144]	; (80002c4 <HardFault_Handler+0x1e>)
    LDR r1, [r1]
 8000234:	6809      	ldr	r1, [r1, #0]
    LDR r1, [r1]                /* load thread stack pointer */
 8000236:	6809      	ldr	r1, [r1, #0]

#if defined (__VFP_FP__) && !defined(__SOFTFP__)
    LDMFD   r1!, {r3}           /* pop flag */
 8000238:	c908      	ldmia	r1!, {r3}
#endif

    LDMFD   r1!, {r4 - r11}     /* pop r4 - r11 register */
 800023a:	e8b1 0ff0 	ldmia.w	r1!, {r4, r5, r6, r7, r8, r9, sl, fp}

#if defined (__VFP_FP__) && !defined(__SOFTFP__)
    CMP     r3,  #0             /* if(flag_r3 != 0) */
 800023e:	2b00      	cmp	r3, #0
    VLDMIANE  r1!, {d8 - d15}   /* pop FPU register s16~s31 */
 8000240:	bf18      	it	ne
 8000242:	ecb1 8b10 	vldmiane	r1!, {d8-d15}
#endif

    MSR psp, r1                 /* update stack pointer */
 8000246:	f381 8809 	msr	PSP, r1

0800024a <pendsv_exit>:

pendsv_exit:
    /* restore interrupt */
    MSR PRIMASK, r2
 800024a:	f382 8810 	msr	PRIMASK, r2

#if defined (__VFP_FP__) && !defined(__SOFTFP__)
    ORR     lr, lr, #0x10       /* lr |=  (1 << 4), clean FPCA. */
 800024e:	f04e 0e10 	orr.w	lr, lr, #16
    CMP     r3,  #0             /* if(flag_r3 != 0) */
 8000252:	2b00      	cmp	r3, #0
    BICNE   lr, lr, #0x10       /* lr &= ~(1 << 4), set FPCA. */
 8000254:	bf18      	it	ne
 8000256:	f02e 0e10 	bicne.w	lr, lr, #16
#endif

    ORR lr, lr, #0x04
 800025a:	f04e 0e04 	orr.w	lr, lr, #4
    BX  lr
 800025e:	4770      	bx	lr

08000260 <rt_hw_context_switch_to>:
 * r0 --> to
 */
.global rt_hw_context_switch_to
.type rt_hw_context_switch_to, %function
rt_hw_context_switch_to:
    LDR r1, =rt_interrupt_to_thread
 8000260:	4918      	ldr	r1, [pc, #96]	; (80002c4 <HardFault_Handler+0x1e>)
    STR r0, [r1]
 8000262:	6008      	str	r0, [r1, #0]

#if defined (__VFP_FP__) && !defined(__SOFTFP__)
    /* CLEAR CONTROL.FPCA */
    MRS     r2, CONTROL         /* read */
 8000264:	f3ef 8214 	mrs	r2, CONTROL
    BIC     r2, #0x04           /* modify */
 8000268:	f022 0204 	bic.w	r2, r2, #4
    MSR     CONTROL, r2         /* write-back */
 800026c:	f382 8814 	msr	CONTROL, r2
#endif

    /* set from thread to 0 */
    LDR r1, =rt_interrupt_from_thread
 8000270:	4913      	ldr	r1, [pc, #76]	; (80002c0 <HardFault_Handler+0x1a>)
    MOV r0, #0x0
 8000272:	f04f 0000 	mov.w	r0, #0
    STR r0, [r1]
 8000276:	6008      	str	r0, [r1, #0]

    /* set interrupt flag to 1 */
    LDR     r1, =rt_thread_switch_interrupt_flag
 8000278:	4910      	ldr	r1, [pc, #64]	; (80002bc <HardFault_Handler+0x16>)
    MOV     r0, #1
 800027a:	f04f 0001 	mov.w	r0, #1
    STR     r0, [r1]
 800027e:	6008      	str	r0, [r1, #0]

    /* set the PendSV exception priority */
    LDR r0, =NVIC_SYSPRI2
 8000280:	4813      	ldr	r0, [pc, #76]	; (80002d0 <HardFault_Handler+0x2a>)
    LDR r1, =NVIC_PENDSV_PRI
 8000282:	4914      	ldr	r1, [pc, #80]	; (80002d4 <HardFault_Handler+0x2e>)
    LDR.W   r2, [r0,#0x00]       /* read       */
 8000284:	f8d0 2000 	ldr.w	r2, [r0]
    ORR     r1,r1,r2             /* modify     */
 8000288:	ea41 0102 	orr.w	r1, r1, r2
    STR     r1, [r0]             /* write-back */
 800028c:	6001      	str	r1, [r0, #0]

    LDR r0, =NVIC_INT_CTRL      /* trigger the PendSV exception (causes context switch) */
 800028e:	480e      	ldr	r0, [pc, #56]	; (80002c8 <HardFault_Handler+0x22>)
    LDR r1, =NVIC_PENDSVSET
 8000290:	490e      	ldr	r1, [pc, #56]	; (80002cc <HardFault_Handler+0x26>)
    STR r1, [r0]
 8000292:	6001      	str	r1, [r0, #0]

    /* restore MSP */
    LDR     r0, =SCB_VTOR
 8000294:	4810      	ldr	r0, [pc, #64]	; (80002d8 <HardFault_Handler+0x32>)
    LDR     r0, [r0]
 8000296:	6800      	ldr	r0, [r0, #0]
    LDR     r0, [r0]
 8000298:	6800      	ldr	r0, [r0, #0]
    NOP
 800029a:	bf00      	nop
    MSR     msp, r0
 800029c:	f380 8808 	msr	MSP, r0

    CPSIE   I                       /* enable interrupts at processor level */
 80002a0:	b662      	cpsie	i

080002a2 <rt_hw_interrupt_thread_switch>:

/* compatible with old version */
.global rt_hw_interrupt_thread_switch
.type rt_hw_interrupt_thread_switch, %function
rt_hw_interrupt_thread_switch:
    BX  lr
 80002a2:	4770      	bx	lr
    NOP
 80002a4:	bf00      	nop

080002a6 <HardFault_Handler>:

.global HardFault_Handler
.type HardFault_Handler, %function
HardFault_Handler:
    /* get current context */
    MRS     r0, psp                 /* get fault thread stack pointer */
 80002a6:	f3ef 8009 	mrs	r0, PSP
    PUSH    {lr}
 80002aa:	b500      	push	{lr}
    BL      rt_hw_hard_fault_exception
 80002ac:	f019 facc 	bl	8019848 <rt_hw_hard_fault_exception>
    POP     {lr}
 80002b0:	f85d eb04 	ldr.w	lr, [sp], #4

    ORR     lr, lr, #0x04
 80002b4:	f04e 0e04 	orr.w	lr, lr, #4
    BX      lr
 80002b8:	4770      	bx	lr
 80002ba:	0000      	.short	0x0000
.type rt_hw_context_switch, %function

rt_hw_context_switch_interrupt:
rt_hw_context_switch:
    /* set rt_thread_switch_interrupt_flag to 1 */
    LDR     r2, =rt_thread_switch_interrupt_flag
 80002bc:	20012b68 	.word	0x20012b68
    CMP     r3, #1
    BEQ     _reswitch
    MOV     r3, #1
    STR     r3, [r2]

    LDR     r2, =rt_interrupt_from_thread   /* set rt_interrupt_from_thread */
 80002c0:	20012b64 	.word	0x20012b64
    STR     r0, [r2]

_reswitch:
    LDR     r2, =rt_interrupt_to_thread     /* set rt_interrupt_to_thread */
 80002c4:	20012b60 	.word	0x20012b60
    STR     r1, [r2]

    LDR r0, =NVIC_INT_CTRL              /* trigger the PendSV exception (causes context switch) */
 80002c8:	e000ed04 	.word	0xe000ed04
    LDR r1, =NVIC_PENDSVSET
 80002cc:	10000000 	.word	0x10000000
    LDR     r1, =rt_thread_switch_interrupt_flag
    MOV     r0, #1
    STR     r0, [r1]

    /* set the PendSV exception priority */
    LDR r0, =NVIC_SYSPRI2
 80002d0:	e000ed20 	.word	0xe000ed20
    LDR r1, =NVIC_PENDSV_PRI
 80002d4:	00ff0000 	.word	0x00ff0000
    LDR r0, =NVIC_INT_CTRL      /* trigger the PendSV exception (causes context switch) */
    LDR r1, =NVIC_PENDSVSET
    STR r1, [r0]

    /* restore MSP */
    LDR     r0, =SCB_VTOR
 80002d8:	e000ed08 	.word	0xe000ed08

080002dc <memcpy>:
 80002dc:	4684      	mov	ip, r0
 80002de:	ea41 0300 	orr.w	r3, r1, r0
 80002e2:	f013 0303 	ands.w	r3, r3, #3
 80002e6:	d16d      	bne.n	80003c4 <memcpy+0xe8>
 80002e8:	3a40      	subs	r2, #64	; 0x40
 80002ea:	d341      	bcc.n	8000370 <memcpy+0x94>
 80002ec:	f851 3b04 	ldr.w	r3, [r1], #4
 80002f0:	f840 3b04 	str.w	r3, [r0], #4
 80002f4:	f851 3b04 	ldr.w	r3, [r1], #4
 80002f8:	f840 3b04 	str.w	r3, [r0], #4
 80002fc:	f851 3b04 	ldr.w	r3, [r1], #4
 8000300:	f840 3b04 	str.w	r3, [r0], #4
 8000304:	f851 3b04 	ldr.w	r3, [r1], #4
 8000308:	f840 3b04 	str.w	r3, [r0], #4
 800030c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000310:	f840 3b04 	str.w	r3, [r0], #4
 8000314:	f851 3b04 	ldr.w	r3, [r1], #4
 8000318:	f840 3b04 	str.w	r3, [r0], #4
 800031c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000320:	f840 3b04 	str.w	r3, [r0], #4
 8000324:	f851 3b04 	ldr.w	r3, [r1], #4
 8000328:	f840 3b04 	str.w	r3, [r0], #4
 800032c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000330:	f840 3b04 	str.w	r3, [r0], #4
 8000334:	f851 3b04 	ldr.w	r3, [r1], #4
 8000338:	f840 3b04 	str.w	r3, [r0], #4
 800033c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000340:	f840 3b04 	str.w	r3, [r0], #4
 8000344:	f851 3b04 	ldr.w	r3, [r1], #4
 8000348:	f840 3b04 	str.w	r3, [r0], #4
 800034c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000350:	f840 3b04 	str.w	r3, [r0], #4
 8000354:	f851 3b04 	ldr.w	r3, [r1], #4
 8000358:	f840 3b04 	str.w	r3, [r0], #4
 800035c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000360:	f840 3b04 	str.w	r3, [r0], #4
 8000364:	f851 3b04 	ldr.w	r3, [r1], #4
 8000368:	f840 3b04 	str.w	r3, [r0], #4
 800036c:	3a40      	subs	r2, #64	; 0x40
 800036e:	d2bd      	bcs.n	80002ec <memcpy+0x10>
 8000370:	3230      	adds	r2, #48	; 0x30
 8000372:	d311      	bcc.n	8000398 <memcpy+0xbc>
 8000374:	f851 3b04 	ldr.w	r3, [r1], #4
 8000378:	f840 3b04 	str.w	r3, [r0], #4
 800037c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000380:	f840 3b04 	str.w	r3, [r0], #4
 8000384:	f851 3b04 	ldr.w	r3, [r1], #4
 8000388:	f840 3b04 	str.w	r3, [r0], #4
 800038c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000390:	f840 3b04 	str.w	r3, [r0], #4
 8000394:	3a10      	subs	r2, #16
 8000396:	d2ed      	bcs.n	8000374 <memcpy+0x98>
 8000398:	320c      	adds	r2, #12
 800039a:	d305      	bcc.n	80003a8 <memcpy+0xcc>
 800039c:	f851 3b04 	ldr.w	r3, [r1], #4
 80003a0:	f840 3b04 	str.w	r3, [r0], #4
 80003a4:	3a04      	subs	r2, #4
 80003a6:	d2f9      	bcs.n	800039c <memcpy+0xc0>
 80003a8:	3204      	adds	r2, #4
 80003aa:	d008      	beq.n	80003be <memcpy+0xe2>
 80003ac:	07d2      	lsls	r2, r2, #31
 80003ae:	bf1c      	itt	ne
 80003b0:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003b4:	f800 3b01 	strbne.w	r3, [r0], #1
 80003b8:	d301      	bcc.n	80003be <memcpy+0xe2>
 80003ba:	880b      	ldrh	r3, [r1, #0]
 80003bc:	8003      	strh	r3, [r0, #0]
 80003be:	4660      	mov	r0, ip
 80003c0:	4770      	bx	lr
 80003c2:	bf00      	nop
 80003c4:	2a08      	cmp	r2, #8
 80003c6:	d313      	bcc.n	80003f0 <memcpy+0x114>
 80003c8:	078b      	lsls	r3, r1, #30
 80003ca:	d08d      	beq.n	80002e8 <memcpy+0xc>
 80003cc:	f010 0303 	ands.w	r3, r0, #3
 80003d0:	d08a      	beq.n	80002e8 <memcpy+0xc>
 80003d2:	f1c3 0304 	rsb	r3, r3, #4
 80003d6:	1ad2      	subs	r2, r2, r3
 80003d8:	07db      	lsls	r3, r3, #31
 80003da:	bf1c      	itt	ne
 80003dc:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003e0:	f800 3b01 	strbne.w	r3, [r0], #1
 80003e4:	d380      	bcc.n	80002e8 <memcpy+0xc>
 80003e6:	f831 3b02 	ldrh.w	r3, [r1], #2
 80003ea:	f820 3b02 	strh.w	r3, [r0], #2
 80003ee:	e77b      	b.n	80002e8 <memcpy+0xc>
 80003f0:	3a04      	subs	r2, #4
 80003f2:	d3d9      	bcc.n	80003a8 <memcpy+0xcc>
 80003f4:	3a01      	subs	r2, #1
 80003f6:	f811 3b01 	ldrb.w	r3, [r1], #1
 80003fa:	f800 3b01 	strb.w	r3, [r0], #1
 80003fe:	d2f9      	bcs.n	80003f4 <memcpy+0x118>
 8000400:	780b      	ldrb	r3, [r1, #0]
 8000402:	7003      	strb	r3, [r0, #0]
 8000404:	784b      	ldrb	r3, [r1, #1]
 8000406:	7043      	strb	r3, [r0, #1]
 8000408:	788b      	ldrb	r3, [r1, #2]
 800040a:	7083      	strb	r3, [r0, #2]
 800040c:	4660      	mov	r0, ip
 800040e:	4770      	bx	lr
	...
 8000420:	eba2 0003 	sub.w	r0, r2, r3
 8000424:	4770      	bx	lr
 8000426:	bf00      	nop

08000428 <strcmp>:
 8000428:	7802      	ldrb	r2, [r0, #0]
 800042a:	780b      	ldrb	r3, [r1, #0]
 800042c:	2a01      	cmp	r2, #1
 800042e:	bf28      	it	cs
 8000430:	429a      	cmpcs	r2, r3
 8000432:	d1f5      	bne.n	8000420 <memcpy+0x144>
 8000434:	e96d 4504 	strd	r4, r5, [sp, #-16]!
 8000438:	ea40 0401 	orr.w	r4, r0, r1
 800043c:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8000440:	f06f 0c00 	mvn.w	ip, #0
 8000444:	ea4f 7244 	mov.w	r2, r4, lsl #29
 8000448:	b312      	cbz	r2, 8000490 <strcmp+0x68>
 800044a:	ea80 0401 	eor.w	r4, r0, r1
 800044e:	f014 0f07 	tst.w	r4, #7
 8000452:	d16a      	bne.n	800052a <strcmp+0x102>
 8000454:	f000 0407 	and.w	r4, r0, #7
 8000458:	f020 0007 	bic.w	r0, r0, #7
 800045c:	f004 0503 	and.w	r5, r4, #3
 8000460:	f021 0107 	bic.w	r1, r1, #7
 8000464:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 8000468:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 800046c:	f014 0f04 	tst.w	r4, #4
 8000470:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8000474:	fa0c f405 	lsl.w	r4, ip, r5
 8000478:	ea62 0204 	orn	r2, r2, r4
 800047c:	ea66 0604 	orn	r6, r6, r4
 8000480:	d00a      	beq.n	8000498 <strcmp+0x70>
 8000482:	ea63 0304 	orn	r3, r3, r4
 8000486:	4662      	mov	r2, ip
 8000488:	ea67 0704 	orn	r7, r7, r4
 800048c:	4666      	mov	r6, ip
 800048e:	e003      	b.n	8000498 <strcmp+0x70>
 8000490:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 8000494:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8000498:	fa82 f54c 	uadd8	r5, r2, ip
 800049c:	ea82 0406 	eor.w	r4, r2, r6
 80004a0:	faa4 f48c 	sel	r4, r4, ip
 80004a4:	bb6c      	cbnz	r4, 8000502 <strcmp+0xda>
 80004a6:	fa83 f54c 	uadd8	r5, r3, ip
 80004aa:	ea83 0507 	eor.w	r5, r3, r7
 80004ae:	faa5 f58c 	sel	r5, r5, ip
 80004b2:	b995      	cbnz	r5, 80004da <strcmp+0xb2>
 80004b4:	e950 2302 	ldrd	r2, r3, [r0, #-8]
 80004b8:	e951 6702 	ldrd	r6, r7, [r1, #-8]
 80004bc:	fa82 f54c 	uadd8	r5, r2, ip
 80004c0:	ea82 0406 	eor.w	r4, r2, r6
 80004c4:	faa4 f48c 	sel	r4, r4, ip
 80004c8:	fa83 f54c 	uadd8	r5, r3, ip
 80004cc:	ea83 0507 	eor.w	r5, r3, r7
 80004d0:	faa5 f58c 	sel	r5, r5, ip
 80004d4:	4325      	orrs	r5, r4
 80004d6:	d0db      	beq.n	8000490 <strcmp+0x68>
 80004d8:	b99c      	cbnz	r4, 8000502 <strcmp+0xda>
 80004da:	ba2d      	rev	r5, r5
 80004dc:	fab5 f485 	clz	r4, r5
 80004e0:	f024 0407 	bic.w	r4, r4, #7
 80004e4:	fa27 f104 	lsr.w	r1, r7, r4
 80004e8:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 80004ec:	fa23 f304 	lsr.w	r3, r3, r4
 80004f0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 80004f4:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80004f8:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80004fc:	eba0 0001 	sub.w	r0, r0, r1
 8000500:	4770      	bx	lr
 8000502:	ba24      	rev	r4, r4
 8000504:	fab4 f484 	clz	r4, r4
 8000508:	f024 0407 	bic.w	r4, r4, #7
 800050c:	fa26 f104 	lsr.w	r1, r6, r4
 8000510:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8000514:	fa22 f204 	lsr.w	r2, r2, r4
 8000518:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800051c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000520:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000524:	eba0 0001 	sub.w	r0, r0, r1
 8000528:	4770      	bx	lr
 800052a:	f014 0f03 	tst.w	r4, #3
 800052e:	d13c      	bne.n	80005aa <strcmp+0x182>
 8000530:	f010 0403 	ands.w	r4, r0, #3
 8000534:	d128      	bne.n	8000588 <strcmp+0x160>
 8000536:	f850 2b08 	ldr.w	r2, [r0], #8
 800053a:	f851 3b08 	ldr.w	r3, [r1], #8
 800053e:	fa82 f54c 	uadd8	r5, r2, ip
 8000542:	ea82 0503 	eor.w	r5, r2, r3
 8000546:	faa5 f58c 	sel	r5, r5, ip
 800054a:	b95d      	cbnz	r5, 8000564 <strcmp+0x13c>
 800054c:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8000550:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8000554:	fa82 f54c 	uadd8	r5, r2, ip
 8000558:	ea82 0503 	eor.w	r5, r2, r3
 800055c:	faa5 f58c 	sel	r5, r5, ip
 8000560:	2d00      	cmp	r5, #0
 8000562:	d0e8      	beq.n	8000536 <strcmp+0x10e>
 8000564:	ba2d      	rev	r5, r5
 8000566:	fab5 f485 	clz	r4, r5
 800056a:	f024 0407 	bic.w	r4, r4, #7
 800056e:	fa23 f104 	lsr.w	r1, r3, r4
 8000572:	fa22 f204 	lsr.w	r2, r2, r4
 8000576:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800057a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800057e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000582:	eba0 0001 	sub.w	r0, r0, r1
 8000586:	4770      	bx	lr
 8000588:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 800058c:	f020 0003 	bic.w	r0, r0, #3
 8000590:	f850 2b08 	ldr.w	r2, [r0], #8
 8000594:	f021 0103 	bic.w	r1, r1, #3
 8000598:	f851 3b08 	ldr.w	r3, [r1], #8
 800059c:	fa0c f404 	lsl.w	r4, ip, r4
 80005a0:	ea62 0204 	orn	r2, r2, r4
 80005a4:	ea63 0304 	orn	r3, r3, r4
 80005a8:	e7c9      	b.n	800053e <strcmp+0x116>
 80005aa:	f010 0403 	ands.w	r4, r0, #3
 80005ae:	d01a      	beq.n	80005e6 <strcmp+0x1be>
 80005b0:	eba1 0104 	sub.w	r1, r1, r4
 80005b4:	f020 0003 	bic.w	r0, r0, #3
 80005b8:	07e4      	lsls	r4, r4, #31
 80005ba:	f850 2b04 	ldr.w	r2, [r0], #4
 80005be:	d006      	beq.n	80005ce <strcmp+0x1a6>
 80005c0:	d20f      	bcs.n	80005e2 <strcmp+0x1ba>
 80005c2:	788b      	ldrb	r3, [r1, #2]
 80005c4:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
 80005c8:	1ae4      	subs	r4, r4, r3
 80005ca:	d106      	bne.n	80005da <strcmp+0x1b2>
 80005cc:	b12b      	cbz	r3, 80005da <strcmp+0x1b2>
 80005ce:	78cb      	ldrb	r3, [r1, #3]
 80005d0:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
 80005d4:	1ae4      	subs	r4, r4, r3
 80005d6:	d100      	bne.n	80005da <strcmp+0x1b2>
 80005d8:	b91b      	cbnz	r3, 80005e2 <strcmp+0x1ba>
 80005da:	4620      	mov	r0, r4
 80005dc:	f85d 4b10 	ldr.w	r4, [sp], #16
 80005e0:	4770      	bx	lr
 80005e2:	f101 0104 	add.w	r1, r1, #4
 80005e6:	f850 2b04 	ldr.w	r2, [r0], #4
 80005ea:	07cc      	lsls	r4, r1, #31
 80005ec:	f021 0103 	bic.w	r1, r1, #3
 80005f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80005f4:	d848      	bhi.n	8000688 <strcmp+0x260>
 80005f6:	d224      	bcs.n	8000642 <strcmp+0x21a>
 80005f8:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
 80005fc:	fa82 f54c 	uadd8	r5, r2, ip
 8000600:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
 8000604:	faa5 f58c 	sel	r5, r5, ip
 8000608:	d10a      	bne.n	8000620 <strcmp+0x1f8>
 800060a:	b965      	cbnz	r5, 8000626 <strcmp+0x1fe>
 800060c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000610:	ea84 0402 	eor.w	r4, r4, r2
 8000614:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
 8000618:	d10e      	bne.n	8000638 <strcmp+0x210>
 800061a:	f850 2b04 	ldr.w	r2, [r0], #4
 800061e:	e7eb      	b.n	80005f8 <strcmp+0x1d0>
 8000620:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8000624:	e055      	b.n	80006d2 <strcmp+0x2aa>
 8000626:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
 800062a:	d14d      	bne.n	80006c8 <strcmp+0x2a0>
 800062c:	7808      	ldrb	r0, [r1, #0]
 800062e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000632:	f1c0 0000 	rsb	r0, r0, #0
 8000636:	4770      	bx	lr
 8000638:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800063c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8000640:	e047      	b.n	80006d2 <strcmp+0x2aa>
 8000642:	ea02 441c 	and.w	r4, r2, ip, lsr #16
 8000646:	fa82 f54c 	uadd8	r5, r2, ip
 800064a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
 800064e:	faa5 f58c 	sel	r5, r5, ip
 8000652:	d10a      	bne.n	800066a <strcmp+0x242>
 8000654:	b965      	cbnz	r5, 8000670 <strcmp+0x248>
 8000656:	f851 3b04 	ldr.w	r3, [r1], #4
 800065a:	ea84 0402 	eor.w	r4, r4, r2
 800065e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
 8000662:	d10c      	bne.n	800067e <strcmp+0x256>
 8000664:	f850 2b04 	ldr.w	r2, [r0], #4
 8000668:	e7eb      	b.n	8000642 <strcmp+0x21a>
 800066a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800066e:	e030      	b.n	80006d2 <strcmp+0x2aa>
 8000670:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
 8000674:	d128      	bne.n	80006c8 <strcmp+0x2a0>
 8000676:	880b      	ldrh	r3, [r1, #0]
 8000678:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800067c:	e029      	b.n	80006d2 <strcmp+0x2aa>
 800067e:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8000682:	ea03 431c 	and.w	r3, r3, ip, lsr #16
 8000686:	e024      	b.n	80006d2 <strcmp+0x2aa>
 8000688:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 800068c:	fa82 f54c 	uadd8	r5, r2, ip
 8000690:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
 8000694:	faa5 f58c 	sel	r5, r5, ip
 8000698:	d10a      	bne.n	80006b0 <strcmp+0x288>
 800069a:	b965      	cbnz	r5, 80006b6 <strcmp+0x28e>
 800069c:	f851 3b04 	ldr.w	r3, [r1], #4
 80006a0:	ea84 0402 	eor.w	r4, r4, r2
 80006a4:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
 80006a8:	d109      	bne.n	80006be <strcmp+0x296>
 80006aa:	f850 2b04 	ldr.w	r2, [r0], #4
 80006ae:	e7eb      	b.n	8000688 <strcmp+0x260>
 80006b0:	ea4f 6313 	mov.w	r3, r3, lsr #24
 80006b4:	e00d      	b.n	80006d2 <strcmp+0x2aa>
 80006b6:	f015 0fff 	tst.w	r5, #255	; 0xff
 80006ba:	d105      	bne.n	80006c8 <strcmp+0x2a0>
 80006bc:	680b      	ldr	r3, [r1, #0]
 80006be:	ea4f 2212 	mov.w	r2, r2, lsr #8
 80006c2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80006c6:	e004      	b.n	80006d2 <strcmp+0x2aa>
 80006c8:	f04f 0000 	mov.w	r0, #0
 80006cc:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80006d0:	4770      	bx	lr
 80006d2:	ba12      	rev	r2, r2
 80006d4:	ba1b      	rev	r3, r3
 80006d6:	fa82 f44c 	uadd8	r4, r2, ip
 80006da:	ea82 0403 	eor.w	r4, r2, r3
 80006de:	faa4 f58c 	sel	r5, r4, ip
 80006e2:	fab5 f485 	clz	r4, r5
 80006e6:	fa02 f204 	lsl.w	r2, r2, r4
 80006ea:	fa03 f304 	lsl.w	r3, r3, r4
 80006ee:	ea4f 6012 	mov.w	r0, r2, lsr #24
 80006f2:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80006f6:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
 80006fa:	4770      	bx	lr
 80006fc:	f3af 8000 	nop.w

08000700 <__aeabi_drsub>:
 8000700:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000704:	e002      	b.n	800070c <__adddf3>
 8000706:	bf00      	nop

08000708 <__aeabi_dsub>:
 8000708:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800070c <__adddf3>:
 800070c:	b530      	push	{r4, r5, lr}
 800070e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8000712:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000716:	ea94 0f05 	teq	r4, r5
 800071a:	bf08      	it	eq
 800071c:	ea90 0f02 	teqeq	r0, r2
 8000720:	bf1f      	itttt	ne
 8000722:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000726:	ea55 0c02 	orrsne.w	ip, r5, r2
 800072a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800072e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000732:	f000 80e2 	beq.w	80008fa <__adddf3+0x1ee>
 8000736:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800073a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800073e:	bfb8      	it	lt
 8000740:	426d      	neglt	r5, r5
 8000742:	dd0c      	ble.n	800075e <__adddf3+0x52>
 8000744:	442c      	add	r4, r5
 8000746:	ea80 0202 	eor.w	r2, r0, r2
 800074a:	ea81 0303 	eor.w	r3, r1, r3
 800074e:	ea82 0000 	eor.w	r0, r2, r0
 8000752:	ea83 0101 	eor.w	r1, r3, r1
 8000756:	ea80 0202 	eor.w	r2, r0, r2
 800075a:	ea81 0303 	eor.w	r3, r1, r3
 800075e:	2d36      	cmp	r5, #54	; 0x36
 8000760:	bf88      	it	hi
 8000762:	bd30      	pophi	{r4, r5, pc}
 8000764:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000768:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800076c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000770:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000774:	d002      	beq.n	800077c <__adddf3+0x70>
 8000776:	4240      	negs	r0, r0
 8000778:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800077c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000780:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000784:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000788:	d002      	beq.n	8000790 <__adddf3+0x84>
 800078a:	4252      	negs	r2, r2
 800078c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000790:	ea94 0f05 	teq	r4, r5
 8000794:	f000 80a7 	beq.w	80008e6 <__adddf3+0x1da>
 8000798:	f1a4 0401 	sub.w	r4, r4, #1
 800079c:	f1d5 0e20 	rsbs	lr, r5, #32
 80007a0:	db0d      	blt.n	80007be <__adddf3+0xb2>
 80007a2:	fa02 fc0e 	lsl.w	ip, r2, lr
 80007a6:	fa22 f205 	lsr.w	r2, r2, r5
 80007aa:	1880      	adds	r0, r0, r2
 80007ac:	f141 0100 	adc.w	r1, r1, #0
 80007b0:	fa03 f20e 	lsl.w	r2, r3, lr
 80007b4:	1880      	adds	r0, r0, r2
 80007b6:	fa43 f305 	asr.w	r3, r3, r5
 80007ba:	4159      	adcs	r1, r3
 80007bc:	e00e      	b.n	80007dc <__adddf3+0xd0>
 80007be:	f1a5 0520 	sub.w	r5, r5, #32
 80007c2:	f10e 0e20 	add.w	lr, lr, #32
 80007c6:	2a01      	cmp	r2, #1
 80007c8:	fa03 fc0e 	lsl.w	ip, r3, lr
 80007cc:	bf28      	it	cs
 80007ce:	f04c 0c02 	orrcs.w	ip, ip, #2
 80007d2:	fa43 f305 	asr.w	r3, r3, r5
 80007d6:	18c0      	adds	r0, r0, r3
 80007d8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80007dc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80007e0:	d507      	bpl.n	80007f2 <__adddf3+0xe6>
 80007e2:	f04f 0e00 	mov.w	lr, #0
 80007e6:	f1dc 0c00 	rsbs	ip, ip, #0
 80007ea:	eb7e 0000 	sbcs.w	r0, lr, r0
 80007ee:	eb6e 0101 	sbc.w	r1, lr, r1
 80007f2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80007f6:	d31b      	bcc.n	8000830 <__adddf3+0x124>
 80007f8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80007fc:	d30c      	bcc.n	8000818 <__adddf3+0x10c>
 80007fe:	0849      	lsrs	r1, r1, #1
 8000800:	ea5f 0030 	movs.w	r0, r0, rrx
 8000804:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000808:	f104 0401 	add.w	r4, r4, #1
 800080c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000810:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000814:	f080 809a 	bcs.w	800094c <__adddf3+0x240>
 8000818:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800081c:	bf08      	it	eq
 800081e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000822:	f150 0000 	adcs.w	r0, r0, #0
 8000826:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800082a:	ea41 0105 	orr.w	r1, r1, r5
 800082e:	bd30      	pop	{r4, r5, pc}
 8000830:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000834:	4140      	adcs	r0, r0
 8000836:	eb41 0101 	adc.w	r1, r1, r1
 800083a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800083e:	f1a4 0401 	sub.w	r4, r4, #1
 8000842:	d1e9      	bne.n	8000818 <__adddf3+0x10c>
 8000844:	f091 0f00 	teq	r1, #0
 8000848:	bf04      	itt	eq
 800084a:	4601      	moveq	r1, r0
 800084c:	2000      	moveq	r0, #0
 800084e:	fab1 f381 	clz	r3, r1
 8000852:	bf08      	it	eq
 8000854:	3320      	addeq	r3, #32
 8000856:	f1a3 030b 	sub.w	r3, r3, #11
 800085a:	f1b3 0220 	subs.w	r2, r3, #32
 800085e:	da0c      	bge.n	800087a <__adddf3+0x16e>
 8000860:	320c      	adds	r2, #12
 8000862:	dd08      	ble.n	8000876 <__adddf3+0x16a>
 8000864:	f102 0c14 	add.w	ip, r2, #20
 8000868:	f1c2 020c 	rsb	r2, r2, #12
 800086c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000870:	fa21 f102 	lsr.w	r1, r1, r2
 8000874:	e00c      	b.n	8000890 <__adddf3+0x184>
 8000876:	f102 0214 	add.w	r2, r2, #20
 800087a:	bfd8      	it	le
 800087c:	f1c2 0c20 	rsble	ip, r2, #32
 8000880:	fa01 f102 	lsl.w	r1, r1, r2
 8000884:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000888:	bfdc      	itt	le
 800088a:	ea41 010c 	orrle.w	r1, r1, ip
 800088e:	4090      	lslle	r0, r2
 8000890:	1ae4      	subs	r4, r4, r3
 8000892:	bfa2      	ittt	ge
 8000894:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000898:	4329      	orrge	r1, r5
 800089a:	bd30      	popge	{r4, r5, pc}
 800089c:	ea6f 0404 	mvn.w	r4, r4
 80008a0:	3c1f      	subs	r4, #31
 80008a2:	da1c      	bge.n	80008de <__adddf3+0x1d2>
 80008a4:	340c      	adds	r4, #12
 80008a6:	dc0e      	bgt.n	80008c6 <__adddf3+0x1ba>
 80008a8:	f104 0414 	add.w	r4, r4, #20
 80008ac:	f1c4 0220 	rsb	r2, r4, #32
 80008b0:	fa20 f004 	lsr.w	r0, r0, r4
 80008b4:	fa01 f302 	lsl.w	r3, r1, r2
 80008b8:	ea40 0003 	orr.w	r0, r0, r3
 80008bc:	fa21 f304 	lsr.w	r3, r1, r4
 80008c0:	ea45 0103 	orr.w	r1, r5, r3
 80008c4:	bd30      	pop	{r4, r5, pc}
 80008c6:	f1c4 040c 	rsb	r4, r4, #12
 80008ca:	f1c4 0220 	rsb	r2, r4, #32
 80008ce:	fa20 f002 	lsr.w	r0, r0, r2
 80008d2:	fa01 f304 	lsl.w	r3, r1, r4
 80008d6:	ea40 0003 	orr.w	r0, r0, r3
 80008da:	4629      	mov	r1, r5
 80008dc:	bd30      	pop	{r4, r5, pc}
 80008de:	fa21 f004 	lsr.w	r0, r1, r4
 80008e2:	4629      	mov	r1, r5
 80008e4:	bd30      	pop	{r4, r5, pc}
 80008e6:	f094 0f00 	teq	r4, #0
 80008ea:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80008ee:	bf06      	itte	eq
 80008f0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80008f4:	3401      	addeq	r4, #1
 80008f6:	3d01      	subne	r5, #1
 80008f8:	e74e      	b.n	8000798 <__adddf3+0x8c>
 80008fa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80008fe:	bf18      	it	ne
 8000900:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000904:	d029      	beq.n	800095a <__adddf3+0x24e>
 8000906:	ea94 0f05 	teq	r4, r5
 800090a:	bf08      	it	eq
 800090c:	ea90 0f02 	teqeq	r0, r2
 8000910:	d005      	beq.n	800091e <__adddf3+0x212>
 8000912:	ea54 0c00 	orrs.w	ip, r4, r0
 8000916:	bf04      	itt	eq
 8000918:	4619      	moveq	r1, r3
 800091a:	4610      	moveq	r0, r2
 800091c:	bd30      	pop	{r4, r5, pc}
 800091e:	ea91 0f03 	teq	r1, r3
 8000922:	bf1e      	ittt	ne
 8000924:	2100      	movne	r1, #0
 8000926:	2000      	movne	r0, #0
 8000928:	bd30      	popne	{r4, r5, pc}
 800092a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800092e:	d105      	bne.n	800093c <__adddf3+0x230>
 8000930:	0040      	lsls	r0, r0, #1
 8000932:	4149      	adcs	r1, r1
 8000934:	bf28      	it	cs
 8000936:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800093a:	bd30      	pop	{r4, r5, pc}
 800093c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000940:	bf3c      	itt	cc
 8000942:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8000946:	bd30      	popcc	{r4, r5, pc}
 8000948:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800094c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000950:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000954:	f04f 0000 	mov.w	r0, #0
 8000958:	bd30      	pop	{r4, r5, pc}
 800095a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800095e:	bf1a      	itte	ne
 8000960:	4619      	movne	r1, r3
 8000962:	4610      	movne	r0, r2
 8000964:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000968:	bf1c      	itt	ne
 800096a:	460b      	movne	r3, r1
 800096c:	4602      	movne	r2, r0
 800096e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000972:	bf06      	itte	eq
 8000974:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000978:	ea91 0f03 	teqeq	r1, r3
 800097c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000980:	bd30      	pop	{r4, r5, pc}
 8000982:	bf00      	nop

08000984 <__aeabi_ui2d>:
 8000984:	f090 0f00 	teq	r0, #0
 8000988:	bf04      	itt	eq
 800098a:	2100      	moveq	r1, #0
 800098c:	4770      	bxeq	lr
 800098e:	b530      	push	{r4, r5, lr}
 8000990:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000994:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000998:	f04f 0500 	mov.w	r5, #0
 800099c:	f04f 0100 	mov.w	r1, #0
 80009a0:	e750      	b.n	8000844 <__adddf3+0x138>
 80009a2:	bf00      	nop

080009a4 <__aeabi_i2d>:
 80009a4:	f090 0f00 	teq	r0, #0
 80009a8:	bf04      	itt	eq
 80009aa:	2100      	moveq	r1, #0
 80009ac:	4770      	bxeq	lr
 80009ae:	b530      	push	{r4, r5, lr}
 80009b0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80009b4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80009b8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80009bc:	bf48      	it	mi
 80009be:	4240      	negmi	r0, r0
 80009c0:	f04f 0100 	mov.w	r1, #0
 80009c4:	e73e      	b.n	8000844 <__adddf3+0x138>
 80009c6:	bf00      	nop

080009c8 <__aeabi_f2d>:
 80009c8:	0042      	lsls	r2, r0, #1
 80009ca:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80009ce:	ea4f 0131 	mov.w	r1, r1, rrx
 80009d2:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80009d6:	bf1f      	itttt	ne
 80009d8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80009dc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80009e0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80009e4:	4770      	bxne	lr
 80009e6:	f092 0f00 	teq	r2, #0
 80009ea:	bf14      	ite	ne
 80009ec:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80009f0:	4770      	bxeq	lr
 80009f2:	b530      	push	{r4, r5, lr}
 80009f4:	f44f 7460 	mov.w	r4, #896	; 0x380
 80009f8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80009fc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000a00:	e720      	b.n	8000844 <__adddf3+0x138>
 8000a02:	bf00      	nop

08000a04 <__aeabi_ul2d>:
 8000a04:	ea50 0201 	orrs.w	r2, r0, r1
 8000a08:	bf08      	it	eq
 8000a0a:	4770      	bxeq	lr
 8000a0c:	b530      	push	{r4, r5, lr}
 8000a0e:	f04f 0500 	mov.w	r5, #0
 8000a12:	e00a      	b.n	8000a2a <__aeabi_l2d+0x16>

08000a14 <__aeabi_l2d>:
 8000a14:	ea50 0201 	orrs.w	r2, r0, r1
 8000a18:	bf08      	it	eq
 8000a1a:	4770      	bxeq	lr
 8000a1c:	b530      	push	{r4, r5, lr}
 8000a1e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8000a22:	d502      	bpl.n	8000a2a <__aeabi_l2d+0x16>
 8000a24:	4240      	negs	r0, r0
 8000a26:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000a2a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000a2e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000a32:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000a36:	f43f aedc 	beq.w	80007f2 <__adddf3+0xe6>
 8000a3a:	f04f 0203 	mov.w	r2, #3
 8000a3e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000a42:	bf18      	it	ne
 8000a44:	3203      	addne	r2, #3
 8000a46:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000a4a:	bf18      	it	ne
 8000a4c:	3203      	addne	r2, #3
 8000a4e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000a52:	f1c2 0320 	rsb	r3, r2, #32
 8000a56:	fa00 fc03 	lsl.w	ip, r0, r3
 8000a5a:	fa20 f002 	lsr.w	r0, r0, r2
 8000a5e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000a62:	ea40 000e 	orr.w	r0, r0, lr
 8000a66:	fa21 f102 	lsr.w	r1, r1, r2
 8000a6a:	4414      	add	r4, r2
 8000a6c:	e6c1      	b.n	80007f2 <__adddf3+0xe6>
 8000a6e:	bf00      	nop

08000a70 <__aeabi_dmul>:
 8000a70:	b570      	push	{r4, r5, r6, lr}
 8000a72:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000a76:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000a7a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000a7e:	bf1d      	ittte	ne
 8000a80:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000a84:	ea94 0f0c 	teqne	r4, ip
 8000a88:	ea95 0f0c 	teqne	r5, ip
 8000a8c:	f000 f8de 	bleq	8000c4c <__aeabi_dmul+0x1dc>
 8000a90:	442c      	add	r4, r5
 8000a92:	ea81 0603 	eor.w	r6, r1, r3
 8000a96:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000a9a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000a9e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000aa2:	bf18      	it	ne
 8000aa4:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000aa8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000aac:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000ab0:	d038      	beq.n	8000b24 <__aeabi_dmul+0xb4>
 8000ab2:	fba0 ce02 	umull	ip, lr, r0, r2
 8000ab6:	f04f 0500 	mov.w	r5, #0
 8000aba:	fbe1 e502 	umlal	lr, r5, r1, r2
 8000abe:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8000ac2:	fbe0 e503 	umlal	lr, r5, r0, r3
 8000ac6:	f04f 0600 	mov.w	r6, #0
 8000aca:	fbe1 5603 	umlal	r5, r6, r1, r3
 8000ace:	f09c 0f00 	teq	ip, #0
 8000ad2:	bf18      	it	ne
 8000ad4:	f04e 0e01 	orrne.w	lr, lr, #1
 8000ad8:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8000adc:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000ae0:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8000ae4:	d204      	bcs.n	8000af0 <__aeabi_dmul+0x80>
 8000ae6:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8000aea:	416d      	adcs	r5, r5
 8000aec:	eb46 0606 	adc.w	r6, r6, r6
 8000af0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8000af4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000af8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8000afc:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000b00:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8000b04:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000b08:	bf88      	it	hi
 8000b0a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8000b0e:	d81e      	bhi.n	8000b4e <__aeabi_dmul+0xde>
 8000b10:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8000b14:	bf08      	it	eq
 8000b16:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8000b1a:	f150 0000 	adcs.w	r0, r0, #0
 8000b1e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000b22:	bd70      	pop	{r4, r5, r6, pc}
 8000b24:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000b28:	ea46 0101 	orr.w	r1, r6, r1
 8000b2c:	ea40 0002 	orr.w	r0, r0, r2
 8000b30:	ea81 0103 	eor.w	r1, r1, r3
 8000b34:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000b38:	bfc2      	ittt	gt
 8000b3a:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000b3e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000b42:	bd70      	popgt	{r4, r5, r6, pc}
 8000b44:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000b48:	f04f 0e00 	mov.w	lr, #0
 8000b4c:	3c01      	subs	r4, #1
 8000b4e:	f300 80ab 	bgt.w	8000ca8 <__aeabi_dmul+0x238>
 8000b52:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8000b56:	bfde      	ittt	le
 8000b58:	2000      	movle	r0, #0
 8000b5a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8000b5e:	bd70      	pople	{r4, r5, r6, pc}
 8000b60:	f1c4 0400 	rsb	r4, r4, #0
 8000b64:	3c20      	subs	r4, #32
 8000b66:	da35      	bge.n	8000bd4 <__aeabi_dmul+0x164>
 8000b68:	340c      	adds	r4, #12
 8000b6a:	dc1b      	bgt.n	8000ba4 <__aeabi_dmul+0x134>
 8000b6c:	f104 0414 	add.w	r4, r4, #20
 8000b70:	f1c4 0520 	rsb	r5, r4, #32
 8000b74:	fa00 f305 	lsl.w	r3, r0, r5
 8000b78:	fa20 f004 	lsr.w	r0, r0, r4
 8000b7c:	fa01 f205 	lsl.w	r2, r1, r5
 8000b80:	ea40 0002 	orr.w	r0, r0, r2
 8000b84:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000b88:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000b8c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000b90:	fa21 f604 	lsr.w	r6, r1, r4
 8000b94:	eb42 0106 	adc.w	r1, r2, r6
 8000b98:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000b9c:	bf08      	it	eq
 8000b9e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000ba2:	bd70      	pop	{r4, r5, r6, pc}
 8000ba4:	f1c4 040c 	rsb	r4, r4, #12
 8000ba8:	f1c4 0520 	rsb	r5, r4, #32
 8000bac:	fa00 f304 	lsl.w	r3, r0, r4
 8000bb0:	fa20 f005 	lsr.w	r0, r0, r5
 8000bb4:	fa01 f204 	lsl.w	r2, r1, r4
 8000bb8:	ea40 0002 	orr.w	r0, r0, r2
 8000bbc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000bc0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000bc4:	f141 0100 	adc.w	r1, r1, #0
 8000bc8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000bcc:	bf08      	it	eq
 8000bce:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000bd2:	bd70      	pop	{r4, r5, r6, pc}
 8000bd4:	f1c4 0520 	rsb	r5, r4, #32
 8000bd8:	fa00 f205 	lsl.w	r2, r0, r5
 8000bdc:	ea4e 0e02 	orr.w	lr, lr, r2
 8000be0:	fa20 f304 	lsr.w	r3, r0, r4
 8000be4:	fa01 f205 	lsl.w	r2, r1, r5
 8000be8:	ea43 0302 	orr.w	r3, r3, r2
 8000bec:	fa21 f004 	lsr.w	r0, r1, r4
 8000bf0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000bf4:	fa21 f204 	lsr.w	r2, r1, r4
 8000bf8:	ea20 0002 	bic.w	r0, r0, r2
 8000bfc:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000c00:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000c04:	bf08      	it	eq
 8000c06:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000c0a:	bd70      	pop	{r4, r5, r6, pc}
 8000c0c:	f094 0f00 	teq	r4, #0
 8000c10:	d10f      	bne.n	8000c32 <__aeabi_dmul+0x1c2>
 8000c12:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8000c16:	0040      	lsls	r0, r0, #1
 8000c18:	eb41 0101 	adc.w	r1, r1, r1
 8000c1c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000c20:	bf08      	it	eq
 8000c22:	3c01      	subeq	r4, #1
 8000c24:	d0f7      	beq.n	8000c16 <__aeabi_dmul+0x1a6>
 8000c26:	ea41 0106 	orr.w	r1, r1, r6
 8000c2a:	f095 0f00 	teq	r5, #0
 8000c2e:	bf18      	it	ne
 8000c30:	4770      	bxne	lr
 8000c32:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8000c36:	0052      	lsls	r2, r2, #1
 8000c38:	eb43 0303 	adc.w	r3, r3, r3
 8000c3c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8000c40:	bf08      	it	eq
 8000c42:	3d01      	subeq	r5, #1
 8000c44:	d0f7      	beq.n	8000c36 <__aeabi_dmul+0x1c6>
 8000c46:	ea43 0306 	orr.w	r3, r3, r6
 8000c4a:	4770      	bx	lr
 8000c4c:	ea94 0f0c 	teq	r4, ip
 8000c50:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000c54:	bf18      	it	ne
 8000c56:	ea95 0f0c 	teqne	r5, ip
 8000c5a:	d00c      	beq.n	8000c76 <__aeabi_dmul+0x206>
 8000c5c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000c60:	bf18      	it	ne
 8000c62:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000c66:	d1d1      	bne.n	8000c0c <__aeabi_dmul+0x19c>
 8000c68:	ea81 0103 	eor.w	r1, r1, r3
 8000c6c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000c70:	f04f 0000 	mov.w	r0, #0
 8000c74:	bd70      	pop	{r4, r5, r6, pc}
 8000c76:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000c7a:	bf06      	itte	eq
 8000c7c:	4610      	moveq	r0, r2
 8000c7e:	4619      	moveq	r1, r3
 8000c80:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000c84:	d019      	beq.n	8000cba <__aeabi_dmul+0x24a>
 8000c86:	ea94 0f0c 	teq	r4, ip
 8000c8a:	d102      	bne.n	8000c92 <__aeabi_dmul+0x222>
 8000c8c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000c90:	d113      	bne.n	8000cba <__aeabi_dmul+0x24a>
 8000c92:	ea95 0f0c 	teq	r5, ip
 8000c96:	d105      	bne.n	8000ca4 <__aeabi_dmul+0x234>
 8000c98:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000c9c:	bf1c      	itt	ne
 8000c9e:	4610      	movne	r0, r2
 8000ca0:	4619      	movne	r1, r3
 8000ca2:	d10a      	bne.n	8000cba <__aeabi_dmul+0x24a>
 8000ca4:	ea81 0103 	eor.w	r1, r1, r3
 8000ca8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000cac:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000cb0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000cb4:	f04f 0000 	mov.w	r0, #0
 8000cb8:	bd70      	pop	{r4, r5, r6, pc}
 8000cba:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000cbe:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8000cc2:	bd70      	pop	{r4, r5, r6, pc}

08000cc4 <__aeabi_ddiv>:
 8000cc4:	b570      	push	{r4, r5, r6, lr}
 8000cc6:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000cca:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000cce:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000cd2:	bf1d      	ittte	ne
 8000cd4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000cd8:	ea94 0f0c 	teqne	r4, ip
 8000cdc:	ea95 0f0c 	teqne	r5, ip
 8000ce0:	f000 f8a7 	bleq	8000e32 <__aeabi_ddiv+0x16e>
 8000ce4:	eba4 0405 	sub.w	r4, r4, r5
 8000ce8:	ea81 0e03 	eor.w	lr, r1, r3
 8000cec:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000cf0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000cf4:	f000 8088 	beq.w	8000e08 <__aeabi_ddiv+0x144>
 8000cf8:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000cfc:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8000d00:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8000d04:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000d08:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8000d0c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8000d10:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8000d14:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000d18:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8000d1c:	429d      	cmp	r5, r3
 8000d1e:	bf08      	it	eq
 8000d20:	4296      	cmpeq	r6, r2
 8000d22:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8000d26:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8000d2a:	d202      	bcs.n	8000d32 <__aeabi_ddiv+0x6e>
 8000d2c:	085b      	lsrs	r3, r3, #1
 8000d2e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000d32:	1ab6      	subs	r6, r6, r2
 8000d34:	eb65 0503 	sbc.w	r5, r5, r3
 8000d38:	085b      	lsrs	r3, r3, #1
 8000d3a:	ea4f 0232 	mov.w	r2, r2, rrx
 8000d3e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8000d42:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8000d46:	ebb6 0e02 	subs.w	lr, r6, r2
 8000d4a:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000d4e:	bf22      	ittt	cs
 8000d50:	1ab6      	subcs	r6, r6, r2
 8000d52:	4675      	movcs	r5, lr
 8000d54:	ea40 000c 	orrcs.w	r0, r0, ip
 8000d58:	085b      	lsrs	r3, r3, #1
 8000d5a:	ea4f 0232 	mov.w	r2, r2, rrx
 8000d5e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000d62:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000d66:	bf22      	ittt	cs
 8000d68:	1ab6      	subcs	r6, r6, r2
 8000d6a:	4675      	movcs	r5, lr
 8000d6c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000d70:	085b      	lsrs	r3, r3, #1
 8000d72:	ea4f 0232 	mov.w	r2, r2, rrx
 8000d76:	ebb6 0e02 	subs.w	lr, r6, r2
 8000d7a:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000d7e:	bf22      	ittt	cs
 8000d80:	1ab6      	subcs	r6, r6, r2
 8000d82:	4675      	movcs	r5, lr
 8000d84:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000d88:	085b      	lsrs	r3, r3, #1
 8000d8a:	ea4f 0232 	mov.w	r2, r2, rrx
 8000d8e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000d92:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000d96:	bf22      	ittt	cs
 8000d98:	1ab6      	subcs	r6, r6, r2
 8000d9a:	4675      	movcs	r5, lr
 8000d9c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000da0:	ea55 0e06 	orrs.w	lr, r5, r6
 8000da4:	d018      	beq.n	8000dd8 <__aeabi_ddiv+0x114>
 8000da6:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000daa:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000dae:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000db2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000db6:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8000dba:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000dbe:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8000dc2:	d1c0      	bne.n	8000d46 <__aeabi_ddiv+0x82>
 8000dc4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000dc8:	d10b      	bne.n	8000de2 <__aeabi_ddiv+0x11e>
 8000dca:	ea41 0100 	orr.w	r1, r1, r0
 8000dce:	f04f 0000 	mov.w	r0, #0
 8000dd2:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8000dd6:	e7b6      	b.n	8000d46 <__aeabi_ddiv+0x82>
 8000dd8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000ddc:	bf04      	itt	eq
 8000dde:	4301      	orreq	r1, r0
 8000de0:	2000      	moveq	r0, #0
 8000de2:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000de6:	bf88      	it	hi
 8000de8:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8000dec:	f63f aeaf 	bhi.w	8000b4e <__aeabi_dmul+0xde>
 8000df0:	ebb5 0c03 	subs.w	ip, r5, r3
 8000df4:	bf04      	itt	eq
 8000df6:	ebb6 0c02 	subseq.w	ip, r6, r2
 8000dfa:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000dfe:	f150 0000 	adcs.w	r0, r0, #0
 8000e02:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000e06:	bd70      	pop	{r4, r5, r6, pc}
 8000e08:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8000e0c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000e10:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8000e14:	bfc2      	ittt	gt
 8000e16:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000e1a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000e1e:	bd70      	popgt	{r4, r5, r6, pc}
 8000e20:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000e24:	f04f 0e00 	mov.w	lr, #0
 8000e28:	3c01      	subs	r4, #1
 8000e2a:	e690      	b.n	8000b4e <__aeabi_dmul+0xde>
 8000e2c:	ea45 0e06 	orr.w	lr, r5, r6
 8000e30:	e68d      	b.n	8000b4e <__aeabi_dmul+0xde>
 8000e32:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000e36:	ea94 0f0c 	teq	r4, ip
 8000e3a:	bf08      	it	eq
 8000e3c:	ea95 0f0c 	teqeq	r5, ip
 8000e40:	f43f af3b 	beq.w	8000cba <__aeabi_dmul+0x24a>
 8000e44:	ea94 0f0c 	teq	r4, ip
 8000e48:	d10a      	bne.n	8000e60 <__aeabi_ddiv+0x19c>
 8000e4a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000e4e:	f47f af34 	bne.w	8000cba <__aeabi_dmul+0x24a>
 8000e52:	ea95 0f0c 	teq	r5, ip
 8000e56:	f47f af25 	bne.w	8000ca4 <__aeabi_dmul+0x234>
 8000e5a:	4610      	mov	r0, r2
 8000e5c:	4619      	mov	r1, r3
 8000e5e:	e72c      	b.n	8000cba <__aeabi_dmul+0x24a>
 8000e60:	ea95 0f0c 	teq	r5, ip
 8000e64:	d106      	bne.n	8000e74 <__aeabi_ddiv+0x1b0>
 8000e66:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000e6a:	f43f aefd 	beq.w	8000c68 <__aeabi_dmul+0x1f8>
 8000e6e:	4610      	mov	r0, r2
 8000e70:	4619      	mov	r1, r3
 8000e72:	e722      	b.n	8000cba <__aeabi_dmul+0x24a>
 8000e74:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000e78:	bf18      	it	ne
 8000e7a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000e7e:	f47f aec5 	bne.w	8000c0c <__aeabi_dmul+0x19c>
 8000e82:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000e86:	f47f af0d 	bne.w	8000ca4 <__aeabi_dmul+0x234>
 8000e8a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000e8e:	f47f aeeb 	bne.w	8000c68 <__aeabi_dmul+0x1f8>
 8000e92:	e712      	b.n	8000cba <__aeabi_dmul+0x24a>

08000e94 <__gedf2>:
 8000e94:	f04f 3cff 	mov.w	ip, #4294967295
 8000e98:	e006      	b.n	8000ea8 <__cmpdf2+0x4>
 8000e9a:	bf00      	nop

08000e9c <__ledf2>:
 8000e9c:	f04f 0c01 	mov.w	ip, #1
 8000ea0:	e002      	b.n	8000ea8 <__cmpdf2+0x4>
 8000ea2:	bf00      	nop

08000ea4 <__cmpdf2>:
 8000ea4:	f04f 0c01 	mov.w	ip, #1
 8000ea8:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000eac:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000eb0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000eb4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000eb8:	bf18      	it	ne
 8000eba:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000ebe:	d01b      	beq.n	8000ef8 <__cmpdf2+0x54>
 8000ec0:	b001      	add	sp, #4
 8000ec2:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000ec6:	bf0c      	ite	eq
 8000ec8:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000ecc:	ea91 0f03 	teqne	r1, r3
 8000ed0:	bf02      	ittt	eq
 8000ed2:	ea90 0f02 	teqeq	r0, r2
 8000ed6:	2000      	moveq	r0, #0
 8000ed8:	4770      	bxeq	lr
 8000eda:	f110 0f00 	cmn.w	r0, #0
 8000ede:	ea91 0f03 	teq	r1, r3
 8000ee2:	bf58      	it	pl
 8000ee4:	4299      	cmppl	r1, r3
 8000ee6:	bf08      	it	eq
 8000ee8:	4290      	cmpeq	r0, r2
 8000eea:	bf2c      	ite	cs
 8000eec:	17d8      	asrcs	r0, r3, #31
 8000eee:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000ef2:	f040 0001 	orr.w	r0, r0, #1
 8000ef6:	4770      	bx	lr
 8000ef8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000efc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000f00:	d102      	bne.n	8000f08 <__cmpdf2+0x64>
 8000f02:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000f06:	d107      	bne.n	8000f18 <__cmpdf2+0x74>
 8000f08:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000f0c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000f10:	d1d6      	bne.n	8000ec0 <__cmpdf2+0x1c>
 8000f12:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000f16:	d0d3      	beq.n	8000ec0 <__cmpdf2+0x1c>
 8000f18:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000f1c:	4770      	bx	lr
 8000f1e:	bf00      	nop

08000f20 <__aeabi_cdrcmple>:
 8000f20:	4684      	mov	ip, r0
 8000f22:	4610      	mov	r0, r2
 8000f24:	4662      	mov	r2, ip
 8000f26:	468c      	mov	ip, r1
 8000f28:	4619      	mov	r1, r3
 8000f2a:	4663      	mov	r3, ip
 8000f2c:	e000      	b.n	8000f30 <__aeabi_cdcmpeq>
 8000f2e:	bf00      	nop

08000f30 <__aeabi_cdcmpeq>:
 8000f30:	b501      	push	{r0, lr}
 8000f32:	f7ff ffb7 	bl	8000ea4 <__cmpdf2>
 8000f36:	2800      	cmp	r0, #0
 8000f38:	bf48      	it	mi
 8000f3a:	f110 0f00 	cmnmi.w	r0, #0
 8000f3e:	bd01      	pop	{r0, pc}

08000f40 <__aeabi_dcmpeq>:
 8000f40:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000f44:	f7ff fff4 	bl	8000f30 <__aeabi_cdcmpeq>
 8000f48:	bf0c      	ite	eq
 8000f4a:	2001      	moveq	r0, #1
 8000f4c:	2000      	movne	r0, #0
 8000f4e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000f52:	bf00      	nop

08000f54 <__aeabi_dcmplt>:
 8000f54:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000f58:	f7ff ffea 	bl	8000f30 <__aeabi_cdcmpeq>
 8000f5c:	bf34      	ite	cc
 8000f5e:	2001      	movcc	r0, #1
 8000f60:	2000      	movcs	r0, #0
 8000f62:	f85d fb08 	ldr.w	pc, [sp], #8
 8000f66:	bf00      	nop

08000f68 <__aeabi_dcmple>:
 8000f68:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000f6c:	f7ff ffe0 	bl	8000f30 <__aeabi_cdcmpeq>
 8000f70:	bf94      	ite	ls
 8000f72:	2001      	movls	r0, #1
 8000f74:	2000      	movhi	r0, #0
 8000f76:	f85d fb08 	ldr.w	pc, [sp], #8
 8000f7a:	bf00      	nop

08000f7c <__aeabi_dcmpge>:
 8000f7c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000f80:	f7ff ffce 	bl	8000f20 <__aeabi_cdrcmple>
 8000f84:	bf94      	ite	ls
 8000f86:	2001      	movls	r0, #1
 8000f88:	2000      	movhi	r0, #0
 8000f8a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000f8e:	bf00      	nop

08000f90 <__aeabi_dcmpgt>:
 8000f90:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000f94:	f7ff ffc4 	bl	8000f20 <__aeabi_cdrcmple>
 8000f98:	bf34      	ite	cc
 8000f9a:	2001      	movcc	r0, #1
 8000f9c:	2000      	movcs	r0, #0
 8000f9e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000fa2:	bf00      	nop

08000fa4 <__aeabi_d2uiz>:
 8000fa4:	004a      	lsls	r2, r1, #1
 8000fa6:	d211      	bcs.n	8000fcc <__aeabi_d2uiz+0x28>
 8000fa8:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000fac:	d211      	bcs.n	8000fd2 <__aeabi_d2uiz+0x2e>
 8000fae:	d50d      	bpl.n	8000fcc <__aeabi_d2uiz+0x28>
 8000fb0:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000fb4:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000fb8:	d40e      	bmi.n	8000fd8 <__aeabi_d2uiz+0x34>
 8000fba:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000fbe:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000fc2:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000fc6:	fa23 f002 	lsr.w	r0, r3, r2
 8000fca:	4770      	bx	lr
 8000fcc:	f04f 0000 	mov.w	r0, #0
 8000fd0:	4770      	bx	lr
 8000fd2:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000fd6:	d102      	bne.n	8000fde <__aeabi_d2uiz+0x3a>
 8000fd8:	f04f 30ff 	mov.w	r0, #4294967295
 8000fdc:	4770      	bx	lr
 8000fde:	f04f 0000 	mov.w	r0, #0
 8000fe2:	4770      	bx	lr

08000fe4 <__aeabi_d2f>:
 8000fe4:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000fe8:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000fec:	bf24      	itt	cs
 8000fee:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000ff2:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000ff6:	d90d      	bls.n	8001014 <__aeabi_d2f+0x30>
 8000ff8:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000ffc:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8001000:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8001004:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8001008:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 800100c:	bf08      	it	eq
 800100e:	f020 0001 	biceq.w	r0, r0, #1
 8001012:	4770      	bx	lr
 8001014:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8001018:	d121      	bne.n	800105e <__aeabi_d2f+0x7a>
 800101a:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 800101e:	bfbc      	itt	lt
 8001020:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8001024:	4770      	bxlt	lr
 8001026:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800102a:	ea4f 5252 	mov.w	r2, r2, lsr #21
 800102e:	f1c2 0218 	rsb	r2, r2, #24
 8001032:	f1c2 0c20 	rsb	ip, r2, #32
 8001036:	fa10 f30c 	lsls.w	r3, r0, ip
 800103a:	fa20 f002 	lsr.w	r0, r0, r2
 800103e:	bf18      	it	ne
 8001040:	f040 0001 	orrne.w	r0, r0, #1
 8001044:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8001048:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 800104c:	fa03 fc0c 	lsl.w	ip, r3, ip
 8001050:	ea40 000c 	orr.w	r0, r0, ip
 8001054:	fa23 f302 	lsr.w	r3, r3, r2
 8001058:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800105c:	e7cc      	b.n	8000ff8 <__aeabi_d2f+0x14>
 800105e:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8001062:	d107      	bne.n	8001074 <__aeabi_d2f+0x90>
 8001064:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8001068:	bf1e      	ittt	ne
 800106a:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 800106e:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8001072:	4770      	bxne	lr
 8001074:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8001078:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 800107c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8001080:	4770      	bx	lr
 8001082:	bf00      	nop

08001084 <__aeabi_uldivmod>:
 8001084:	b94b      	cbnz	r3, 800109a <__aeabi_uldivmod+0x16>
 8001086:	b942      	cbnz	r2, 800109a <__aeabi_uldivmod+0x16>
 8001088:	2900      	cmp	r1, #0
 800108a:	bf08      	it	eq
 800108c:	2800      	cmpeq	r0, #0
 800108e:	d002      	beq.n	8001096 <__aeabi_uldivmod+0x12>
 8001090:	f04f 31ff 	mov.w	r1, #4294967295
 8001094:	4608      	mov	r0, r1
 8001096:	f000 b83b 	b.w	8001110 <__aeabi_idiv0>
 800109a:	b082      	sub	sp, #8
 800109c:	46ec      	mov	ip, sp
 800109e:	e92d 5000 	stmdb	sp!, {ip, lr}
 80010a2:	f000 f81d 	bl	80010e0 <__gnu_uldivmod_helper>
 80010a6:	f8dd e004 	ldr.w	lr, [sp, #4]
 80010aa:	b002      	add	sp, #8
 80010ac:	bc0c      	pop	{r2, r3}
 80010ae:	4770      	bx	lr

080010b0 <__gnu_ldivmod_helper>:
 80010b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80010b4:	9c06      	ldr	r4, [sp, #24]
 80010b6:	4615      	mov	r5, r2
 80010b8:	4606      	mov	r6, r0
 80010ba:	460f      	mov	r7, r1
 80010bc:	4698      	mov	r8, r3
 80010be:	f000 f829 	bl	8001114 <__divdi3>
 80010c2:	fb05 f301 	mul.w	r3, r5, r1
 80010c6:	fb00 3808 	mla	r8, r0, r8, r3
 80010ca:	fba5 2300 	umull	r2, r3, r5, r0
 80010ce:	1ab2      	subs	r2, r6, r2
 80010d0:	4443      	add	r3, r8
 80010d2:	eb67 0303 	sbc.w	r3, r7, r3
 80010d6:	e9c4 2300 	strd	r2, r3, [r4]
 80010da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80010de:	bf00      	nop

080010e0 <__gnu_uldivmod_helper>:
 80010e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80010e4:	9c06      	ldr	r4, [sp, #24]
 80010e6:	4690      	mov	r8, r2
 80010e8:	4606      	mov	r6, r0
 80010ea:	460f      	mov	r7, r1
 80010ec:	461d      	mov	r5, r3
 80010ee:	f000 f95f 	bl	80013b0 <__udivdi3>
 80010f2:	fb00 f505 	mul.w	r5, r0, r5
 80010f6:	fba0 2308 	umull	r2, r3, r0, r8
 80010fa:	fb08 5501 	mla	r5, r8, r1, r5
 80010fe:	1ab2      	subs	r2, r6, r2
 8001100:	442b      	add	r3, r5
 8001102:	eb67 0303 	sbc.w	r3, r7, r3
 8001106:	e9c4 2300 	strd	r2, r3, [r4]
 800110a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800110e:	bf00      	nop

08001110 <__aeabi_idiv0>:
 8001110:	4770      	bx	lr
 8001112:	bf00      	nop

08001114 <__divdi3>:
 8001114:	2900      	cmp	r1, #0
 8001116:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800111a:	f2c0 80a6 	blt.w	800126a <__divdi3+0x156>
 800111e:	2600      	movs	r6, #0
 8001120:	2b00      	cmp	r3, #0
 8001122:	f2c0 809c 	blt.w	800125e <__divdi3+0x14a>
 8001126:	4688      	mov	r8, r1
 8001128:	4694      	mov	ip, r2
 800112a:	469e      	mov	lr, r3
 800112c:	4615      	mov	r5, r2
 800112e:	4604      	mov	r4, r0
 8001130:	460f      	mov	r7, r1
 8001132:	2b00      	cmp	r3, #0
 8001134:	d13d      	bne.n	80011b2 <__divdi3+0x9e>
 8001136:	428a      	cmp	r2, r1
 8001138:	d959      	bls.n	80011ee <__divdi3+0xda>
 800113a:	fab2 f382 	clz	r3, r2
 800113e:	b13b      	cbz	r3, 8001150 <__divdi3+0x3c>
 8001140:	f1c3 0220 	rsb	r2, r3, #32
 8001144:	409f      	lsls	r7, r3
 8001146:	fa20 f202 	lsr.w	r2, r0, r2
 800114a:	409d      	lsls	r5, r3
 800114c:	4317      	orrs	r7, r2
 800114e:	409c      	lsls	r4, r3
 8001150:	0c29      	lsrs	r1, r5, #16
 8001152:	0c22      	lsrs	r2, r4, #16
 8001154:	fbb7 fef1 	udiv	lr, r7, r1
 8001158:	b2a8      	uxth	r0, r5
 800115a:	fb01 771e 	mls	r7, r1, lr, r7
 800115e:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
 8001162:	fb00 f30e 	mul.w	r3, r0, lr
 8001166:	42bb      	cmp	r3, r7
 8001168:	d90a      	bls.n	8001180 <__divdi3+0x6c>
 800116a:	197f      	adds	r7, r7, r5
 800116c:	f10e 32ff 	add.w	r2, lr, #4294967295
 8001170:	f080 8105 	bcs.w	800137e <__divdi3+0x26a>
 8001174:	42bb      	cmp	r3, r7
 8001176:	f240 8102 	bls.w	800137e <__divdi3+0x26a>
 800117a:	f1ae 0e02 	sub.w	lr, lr, #2
 800117e:	442f      	add	r7, r5
 8001180:	1aff      	subs	r7, r7, r3
 8001182:	b2a4      	uxth	r4, r4
 8001184:	fbb7 f3f1 	udiv	r3, r7, r1
 8001188:	fb01 7713 	mls	r7, r1, r3, r7
 800118c:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 8001190:	fb00 f003 	mul.w	r0, r0, r3
 8001194:	42b8      	cmp	r0, r7
 8001196:	d908      	bls.n	80011aa <__divdi3+0x96>
 8001198:	197f      	adds	r7, r7, r5
 800119a:	f103 32ff 	add.w	r2, r3, #4294967295
 800119e:	f080 80f0 	bcs.w	8001382 <__divdi3+0x26e>
 80011a2:	42b8      	cmp	r0, r7
 80011a4:	f240 80ed 	bls.w	8001382 <__divdi3+0x26e>
 80011a8:	3b02      	subs	r3, #2
 80011aa:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 80011ae:	2200      	movs	r2, #0
 80011b0:	e003      	b.n	80011ba <__divdi3+0xa6>
 80011b2:	428b      	cmp	r3, r1
 80011b4:	d90f      	bls.n	80011d6 <__divdi3+0xc2>
 80011b6:	2200      	movs	r2, #0
 80011b8:	4613      	mov	r3, r2
 80011ba:	1c34      	adds	r4, r6, #0
 80011bc:	bf18      	it	ne
 80011be:	2401      	movne	r4, #1
 80011c0:	4260      	negs	r0, r4
 80011c2:	f04f 0500 	mov.w	r5, #0
 80011c6:	eb65 0145 	sbc.w	r1, r5, r5, lsl #1
 80011ca:	4058      	eors	r0, r3
 80011cc:	4051      	eors	r1, r2
 80011ce:	1900      	adds	r0, r0, r4
 80011d0:	4169      	adcs	r1, r5
 80011d2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80011d6:	fab3 f283 	clz	r2, r3
 80011da:	2a00      	cmp	r2, #0
 80011dc:	f040 8086 	bne.w	80012ec <__divdi3+0x1d8>
 80011e0:	428b      	cmp	r3, r1
 80011e2:	d302      	bcc.n	80011ea <__divdi3+0xd6>
 80011e4:	4584      	cmp	ip, r0
 80011e6:	f200 80db 	bhi.w	80013a0 <__divdi3+0x28c>
 80011ea:	2301      	movs	r3, #1
 80011ec:	e7e5      	b.n	80011ba <__divdi3+0xa6>
 80011ee:	b912      	cbnz	r2, 80011f6 <__divdi3+0xe2>
 80011f0:	2301      	movs	r3, #1
 80011f2:	fbb3 f5f2 	udiv	r5, r3, r2
 80011f6:	fab5 f085 	clz	r0, r5
 80011fa:	2800      	cmp	r0, #0
 80011fc:	d13b      	bne.n	8001276 <__divdi3+0x162>
 80011fe:	1b78      	subs	r0, r7, r5
 8001200:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8001204:	fa1f fc85 	uxth.w	ip, r5
 8001208:	2201      	movs	r2, #1
 800120a:	fbb0 f8fe 	udiv	r8, r0, lr
 800120e:	0c21      	lsrs	r1, r4, #16
 8001210:	fb0e 0718 	mls	r7, lr, r8, r0
 8001214:	ea41 4707 	orr.w	r7, r1, r7, lsl #16
 8001218:	fb0c f308 	mul.w	r3, ip, r8
 800121c:	42bb      	cmp	r3, r7
 800121e:	d907      	bls.n	8001230 <__divdi3+0x11c>
 8001220:	197f      	adds	r7, r7, r5
 8001222:	f108 31ff 	add.w	r1, r8, #4294967295
 8001226:	d202      	bcs.n	800122e <__divdi3+0x11a>
 8001228:	42bb      	cmp	r3, r7
 800122a:	f200 80bd 	bhi.w	80013a8 <__divdi3+0x294>
 800122e:	4688      	mov	r8, r1
 8001230:	1aff      	subs	r7, r7, r3
 8001232:	b2a4      	uxth	r4, r4
 8001234:	fbb7 f3fe 	udiv	r3, r7, lr
 8001238:	fb0e 7713 	mls	r7, lr, r3, r7
 800123c:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 8001240:	fb0c fc03 	mul.w	ip, ip, r3
 8001244:	45bc      	cmp	ip, r7
 8001246:	d907      	bls.n	8001258 <__divdi3+0x144>
 8001248:	197f      	adds	r7, r7, r5
 800124a:	f103 31ff 	add.w	r1, r3, #4294967295
 800124e:	d202      	bcs.n	8001256 <__divdi3+0x142>
 8001250:	45bc      	cmp	ip, r7
 8001252:	f200 80a7 	bhi.w	80013a4 <__divdi3+0x290>
 8001256:	460b      	mov	r3, r1
 8001258:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 800125c:	e7ad      	b.n	80011ba <__divdi3+0xa6>
 800125e:	4252      	negs	r2, r2
 8001260:	ea6f 0606 	mvn.w	r6, r6
 8001264:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8001268:	e75d      	b.n	8001126 <__divdi3+0x12>
 800126a:	4240      	negs	r0, r0
 800126c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8001270:	f04f 36ff 	mov.w	r6, #4294967295
 8001274:	e754      	b.n	8001120 <__divdi3+0xc>
 8001276:	f1c0 0220 	rsb	r2, r0, #32
 800127a:	fa24 f102 	lsr.w	r1, r4, r2
 800127e:	fa07 f300 	lsl.w	r3, r7, r0
 8001282:	4085      	lsls	r5, r0
 8001284:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8001288:	40d7      	lsrs	r7, r2
 800128a:	4319      	orrs	r1, r3
 800128c:	fbb7 f2fe 	udiv	r2, r7, lr
 8001290:	0c0b      	lsrs	r3, r1, #16
 8001292:	fb0e 7712 	mls	r7, lr, r2, r7
 8001296:	fa1f fc85 	uxth.w	ip, r5
 800129a:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 800129e:	fb0c f702 	mul.w	r7, ip, r2
 80012a2:	429f      	cmp	r7, r3
 80012a4:	fa04 f400 	lsl.w	r4, r4, r0
 80012a8:	d907      	bls.n	80012ba <__divdi3+0x1a6>
 80012aa:	195b      	adds	r3, r3, r5
 80012ac:	f102 30ff 	add.w	r0, r2, #4294967295
 80012b0:	d274      	bcs.n	800139c <__divdi3+0x288>
 80012b2:	429f      	cmp	r7, r3
 80012b4:	d972      	bls.n	800139c <__divdi3+0x288>
 80012b6:	3a02      	subs	r2, #2
 80012b8:	442b      	add	r3, r5
 80012ba:	1bdf      	subs	r7, r3, r7
 80012bc:	b289      	uxth	r1, r1
 80012be:	fbb7 f8fe 	udiv	r8, r7, lr
 80012c2:	fb0e 7318 	mls	r3, lr, r8, r7
 80012c6:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 80012ca:	fb0c f708 	mul.w	r7, ip, r8
 80012ce:	429f      	cmp	r7, r3
 80012d0:	d908      	bls.n	80012e4 <__divdi3+0x1d0>
 80012d2:	195b      	adds	r3, r3, r5
 80012d4:	f108 31ff 	add.w	r1, r8, #4294967295
 80012d8:	d25c      	bcs.n	8001394 <__divdi3+0x280>
 80012da:	429f      	cmp	r7, r3
 80012dc:	d95a      	bls.n	8001394 <__divdi3+0x280>
 80012de:	f1a8 0802 	sub.w	r8, r8, #2
 80012e2:	442b      	add	r3, r5
 80012e4:	1bd8      	subs	r0, r3, r7
 80012e6:	ea48 4202 	orr.w	r2, r8, r2, lsl #16
 80012ea:	e78e      	b.n	800120a <__divdi3+0xf6>
 80012ec:	f1c2 0320 	rsb	r3, r2, #32
 80012f0:	fa2c f103 	lsr.w	r1, ip, r3
 80012f4:	fa0e fe02 	lsl.w	lr, lr, r2
 80012f8:	fa20 f703 	lsr.w	r7, r0, r3
 80012fc:	ea41 0e0e 	orr.w	lr, r1, lr
 8001300:	fa08 f002 	lsl.w	r0, r8, r2
 8001304:	fa28 f103 	lsr.w	r1, r8, r3
 8001308:	ea4f 451e 	mov.w	r5, lr, lsr #16
 800130c:	4338      	orrs	r0, r7
 800130e:	fbb1 f8f5 	udiv	r8, r1, r5
 8001312:	0c03      	lsrs	r3, r0, #16
 8001314:	fb05 1118 	mls	r1, r5, r8, r1
 8001318:	fa1f f78e 	uxth.w	r7, lr
 800131c:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8001320:	fb07 f308 	mul.w	r3, r7, r8
 8001324:	428b      	cmp	r3, r1
 8001326:	fa0c fc02 	lsl.w	ip, ip, r2
 800132a:	d909      	bls.n	8001340 <__divdi3+0x22c>
 800132c:	eb11 010e 	adds.w	r1, r1, lr
 8001330:	f108 39ff 	add.w	r9, r8, #4294967295
 8001334:	d230      	bcs.n	8001398 <__divdi3+0x284>
 8001336:	428b      	cmp	r3, r1
 8001338:	d92e      	bls.n	8001398 <__divdi3+0x284>
 800133a:	f1a8 0802 	sub.w	r8, r8, #2
 800133e:	4471      	add	r1, lr
 8001340:	1ac9      	subs	r1, r1, r3
 8001342:	b280      	uxth	r0, r0
 8001344:	fbb1 f3f5 	udiv	r3, r1, r5
 8001348:	fb05 1113 	mls	r1, r5, r3, r1
 800134c:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 8001350:	fb07 f703 	mul.w	r7, r7, r3
 8001354:	428f      	cmp	r7, r1
 8001356:	d908      	bls.n	800136a <__divdi3+0x256>
 8001358:	eb11 010e 	adds.w	r1, r1, lr
 800135c:	f103 30ff 	add.w	r0, r3, #4294967295
 8001360:	d216      	bcs.n	8001390 <__divdi3+0x27c>
 8001362:	428f      	cmp	r7, r1
 8001364:	d914      	bls.n	8001390 <__divdi3+0x27c>
 8001366:	3b02      	subs	r3, #2
 8001368:	4471      	add	r1, lr
 800136a:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 800136e:	1bc9      	subs	r1, r1, r7
 8001370:	fba3 890c 	umull	r8, r9, r3, ip
 8001374:	4549      	cmp	r1, r9
 8001376:	d309      	bcc.n	800138c <__divdi3+0x278>
 8001378:	d005      	beq.n	8001386 <__divdi3+0x272>
 800137a:	2200      	movs	r2, #0
 800137c:	e71d      	b.n	80011ba <__divdi3+0xa6>
 800137e:	4696      	mov	lr, r2
 8001380:	e6fe      	b.n	8001180 <__divdi3+0x6c>
 8001382:	4613      	mov	r3, r2
 8001384:	e711      	b.n	80011aa <__divdi3+0x96>
 8001386:	4094      	lsls	r4, r2
 8001388:	4544      	cmp	r4, r8
 800138a:	d2f6      	bcs.n	800137a <__divdi3+0x266>
 800138c:	3b01      	subs	r3, #1
 800138e:	e7f4      	b.n	800137a <__divdi3+0x266>
 8001390:	4603      	mov	r3, r0
 8001392:	e7ea      	b.n	800136a <__divdi3+0x256>
 8001394:	4688      	mov	r8, r1
 8001396:	e7a5      	b.n	80012e4 <__divdi3+0x1d0>
 8001398:	46c8      	mov	r8, r9
 800139a:	e7d1      	b.n	8001340 <__divdi3+0x22c>
 800139c:	4602      	mov	r2, r0
 800139e:	e78c      	b.n	80012ba <__divdi3+0x1a6>
 80013a0:	4613      	mov	r3, r2
 80013a2:	e70a      	b.n	80011ba <__divdi3+0xa6>
 80013a4:	3b02      	subs	r3, #2
 80013a6:	e757      	b.n	8001258 <__divdi3+0x144>
 80013a8:	f1a8 0802 	sub.w	r8, r8, #2
 80013ac:	442f      	add	r7, r5
 80013ae:	e73f      	b.n	8001230 <__divdi3+0x11c>

080013b0 <__udivdi3>:
 80013b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80013b4:	2b00      	cmp	r3, #0
 80013b6:	d144      	bne.n	8001442 <__udivdi3+0x92>
 80013b8:	428a      	cmp	r2, r1
 80013ba:	4615      	mov	r5, r2
 80013bc:	4604      	mov	r4, r0
 80013be:	d94f      	bls.n	8001460 <__udivdi3+0xb0>
 80013c0:	fab2 f782 	clz	r7, r2
 80013c4:	460e      	mov	r6, r1
 80013c6:	b14f      	cbz	r7, 80013dc <__udivdi3+0x2c>
 80013c8:	f1c7 0320 	rsb	r3, r7, #32
 80013cc:	40b9      	lsls	r1, r7
 80013ce:	fa20 f603 	lsr.w	r6, r0, r3
 80013d2:	fa02 f507 	lsl.w	r5, r2, r7
 80013d6:	430e      	orrs	r6, r1
 80013d8:	fa00 f407 	lsl.w	r4, r0, r7
 80013dc:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80013e0:	0c23      	lsrs	r3, r4, #16
 80013e2:	fbb6 f0fe 	udiv	r0, r6, lr
 80013e6:	b2af      	uxth	r7, r5
 80013e8:	fb0e 6110 	mls	r1, lr, r0, r6
 80013ec:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80013f0:	fb07 f100 	mul.w	r1, r7, r0
 80013f4:	4299      	cmp	r1, r3
 80013f6:	d909      	bls.n	800140c <__udivdi3+0x5c>
 80013f8:	195b      	adds	r3, r3, r5
 80013fa:	f100 32ff 	add.w	r2, r0, #4294967295
 80013fe:	f080 80ec 	bcs.w	80015da <__udivdi3+0x22a>
 8001402:	4299      	cmp	r1, r3
 8001404:	f240 80e9 	bls.w	80015da <__udivdi3+0x22a>
 8001408:	3802      	subs	r0, #2
 800140a:	442b      	add	r3, r5
 800140c:	1a5a      	subs	r2, r3, r1
 800140e:	b2a4      	uxth	r4, r4
 8001410:	fbb2 f3fe 	udiv	r3, r2, lr
 8001414:	fb0e 2213 	mls	r2, lr, r3, r2
 8001418:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
 800141c:	fb07 f703 	mul.w	r7, r7, r3
 8001420:	4297      	cmp	r7, r2
 8001422:	d908      	bls.n	8001436 <__udivdi3+0x86>
 8001424:	1952      	adds	r2, r2, r5
 8001426:	f103 31ff 	add.w	r1, r3, #4294967295
 800142a:	f080 80d8 	bcs.w	80015de <__udivdi3+0x22e>
 800142e:	4297      	cmp	r7, r2
 8001430:	f240 80d5 	bls.w	80015de <__udivdi3+0x22e>
 8001434:	3b02      	subs	r3, #2
 8001436:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 800143a:	2600      	movs	r6, #0
 800143c:	4631      	mov	r1, r6
 800143e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001442:	428b      	cmp	r3, r1
 8001444:	d847      	bhi.n	80014d6 <__udivdi3+0x126>
 8001446:	fab3 f683 	clz	r6, r3
 800144a:	2e00      	cmp	r6, #0
 800144c:	d148      	bne.n	80014e0 <__udivdi3+0x130>
 800144e:	428b      	cmp	r3, r1
 8001450:	d302      	bcc.n	8001458 <__udivdi3+0xa8>
 8001452:	4282      	cmp	r2, r0
 8001454:	f200 80cd 	bhi.w	80015f2 <__udivdi3+0x242>
 8001458:	2001      	movs	r0, #1
 800145a:	4631      	mov	r1, r6
 800145c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001460:	b912      	cbnz	r2, 8001468 <__udivdi3+0xb8>
 8001462:	2501      	movs	r5, #1
 8001464:	fbb5 f5f2 	udiv	r5, r5, r2
 8001468:	fab5 f885 	clz	r8, r5
 800146c:	f1b8 0f00 	cmp.w	r8, #0
 8001470:	d177      	bne.n	8001562 <__udivdi3+0x1b2>
 8001472:	1b4a      	subs	r2, r1, r5
 8001474:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8001478:	b2af      	uxth	r7, r5
 800147a:	2601      	movs	r6, #1
 800147c:	fbb2 f0fe 	udiv	r0, r2, lr
 8001480:	0c23      	lsrs	r3, r4, #16
 8001482:	fb0e 2110 	mls	r1, lr, r0, r2
 8001486:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 800148a:	fb07 f300 	mul.w	r3, r7, r0
 800148e:	428b      	cmp	r3, r1
 8001490:	d907      	bls.n	80014a2 <__udivdi3+0xf2>
 8001492:	1949      	adds	r1, r1, r5
 8001494:	f100 32ff 	add.w	r2, r0, #4294967295
 8001498:	d202      	bcs.n	80014a0 <__udivdi3+0xf0>
 800149a:	428b      	cmp	r3, r1
 800149c:	f200 80ba 	bhi.w	8001614 <__udivdi3+0x264>
 80014a0:	4610      	mov	r0, r2
 80014a2:	1ac9      	subs	r1, r1, r3
 80014a4:	b2a4      	uxth	r4, r4
 80014a6:	fbb1 f3fe 	udiv	r3, r1, lr
 80014aa:	fb0e 1113 	mls	r1, lr, r3, r1
 80014ae:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 80014b2:	fb07 f703 	mul.w	r7, r7, r3
 80014b6:	42a7      	cmp	r7, r4
 80014b8:	d908      	bls.n	80014cc <__udivdi3+0x11c>
 80014ba:	1964      	adds	r4, r4, r5
 80014bc:	f103 32ff 	add.w	r2, r3, #4294967295
 80014c0:	f080 808f 	bcs.w	80015e2 <__udivdi3+0x232>
 80014c4:	42a7      	cmp	r7, r4
 80014c6:	f240 808c 	bls.w	80015e2 <__udivdi3+0x232>
 80014ca:	3b02      	subs	r3, #2
 80014cc:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80014d0:	4631      	mov	r1, r6
 80014d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80014d6:	2600      	movs	r6, #0
 80014d8:	4630      	mov	r0, r6
 80014da:	4631      	mov	r1, r6
 80014dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80014e0:	f1c6 0420 	rsb	r4, r6, #32
 80014e4:	fa22 f504 	lsr.w	r5, r2, r4
 80014e8:	40b3      	lsls	r3, r6
 80014ea:	432b      	orrs	r3, r5
 80014ec:	fa20 fc04 	lsr.w	ip, r0, r4
 80014f0:	fa01 f706 	lsl.w	r7, r1, r6
 80014f4:	fa21 f504 	lsr.w	r5, r1, r4
 80014f8:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 80014fc:	ea4c 0707 	orr.w	r7, ip, r7
 8001500:	fbb5 f8fe 	udiv	r8, r5, lr
 8001504:	0c39      	lsrs	r1, r7, #16
 8001506:	fb0e 5518 	mls	r5, lr, r8, r5
 800150a:	fa1f fc83 	uxth.w	ip, r3
 800150e:	ea41 4505 	orr.w	r5, r1, r5, lsl #16
 8001512:	fb0c f108 	mul.w	r1, ip, r8
 8001516:	42a9      	cmp	r1, r5
 8001518:	fa02 f206 	lsl.w	r2, r2, r6
 800151c:	d904      	bls.n	8001528 <__udivdi3+0x178>
 800151e:	18ed      	adds	r5, r5, r3
 8001520:	f108 34ff 	add.w	r4, r8, #4294967295
 8001524:	d367      	bcc.n	80015f6 <__udivdi3+0x246>
 8001526:	46a0      	mov	r8, r4
 8001528:	1a6d      	subs	r5, r5, r1
 800152a:	b2bf      	uxth	r7, r7
 800152c:	fbb5 f4fe 	udiv	r4, r5, lr
 8001530:	fb0e 5514 	mls	r5, lr, r4, r5
 8001534:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
 8001538:	fb0c fc04 	mul.w	ip, ip, r4
 800153c:	458c      	cmp	ip, r1
 800153e:	d904      	bls.n	800154a <__udivdi3+0x19a>
 8001540:	18c9      	adds	r1, r1, r3
 8001542:	f104 35ff 	add.w	r5, r4, #4294967295
 8001546:	d35c      	bcc.n	8001602 <__udivdi3+0x252>
 8001548:	462c      	mov	r4, r5
 800154a:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
 800154e:	ebcc 0101 	rsb	r1, ip, r1
 8001552:	fba4 2302 	umull	r2, r3, r4, r2
 8001556:	4299      	cmp	r1, r3
 8001558:	d348      	bcc.n	80015ec <__udivdi3+0x23c>
 800155a:	d044      	beq.n	80015e6 <__udivdi3+0x236>
 800155c:	4620      	mov	r0, r4
 800155e:	2600      	movs	r6, #0
 8001560:	e76c      	b.n	800143c <__udivdi3+0x8c>
 8001562:	f1c8 0420 	rsb	r4, r8, #32
 8001566:	fa01 f308 	lsl.w	r3, r1, r8
 800156a:	fa05 f508 	lsl.w	r5, r5, r8
 800156e:	fa20 f704 	lsr.w	r7, r0, r4
 8001572:	40e1      	lsrs	r1, r4
 8001574:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8001578:	431f      	orrs	r7, r3
 800157a:	fbb1 f6fe 	udiv	r6, r1, lr
 800157e:	0c3a      	lsrs	r2, r7, #16
 8001580:	fb0e 1116 	mls	r1, lr, r6, r1
 8001584:	fa1f fc85 	uxth.w	ip, r5
 8001588:	ea42 4301 	orr.w	r3, r2, r1, lsl #16
 800158c:	fb0c f206 	mul.w	r2, ip, r6
 8001590:	429a      	cmp	r2, r3
 8001592:	fa00 f408 	lsl.w	r4, r0, r8
 8001596:	d907      	bls.n	80015a8 <__udivdi3+0x1f8>
 8001598:	195b      	adds	r3, r3, r5
 800159a:	f106 31ff 	add.w	r1, r6, #4294967295
 800159e:	d237      	bcs.n	8001610 <__udivdi3+0x260>
 80015a0:	429a      	cmp	r2, r3
 80015a2:	d935      	bls.n	8001610 <__udivdi3+0x260>
 80015a4:	3e02      	subs	r6, #2
 80015a6:	442b      	add	r3, r5
 80015a8:	1a9b      	subs	r3, r3, r2
 80015aa:	b2bf      	uxth	r7, r7
 80015ac:	fbb3 f0fe 	udiv	r0, r3, lr
 80015b0:	fb0e 3310 	mls	r3, lr, r0, r3
 80015b4:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
 80015b8:	fb0c f100 	mul.w	r1, ip, r0
 80015bc:	4299      	cmp	r1, r3
 80015be:	d907      	bls.n	80015d0 <__udivdi3+0x220>
 80015c0:	195b      	adds	r3, r3, r5
 80015c2:	f100 32ff 	add.w	r2, r0, #4294967295
 80015c6:	d221      	bcs.n	800160c <__udivdi3+0x25c>
 80015c8:	4299      	cmp	r1, r3
 80015ca:	d91f      	bls.n	800160c <__udivdi3+0x25c>
 80015cc:	3802      	subs	r0, #2
 80015ce:	442b      	add	r3, r5
 80015d0:	1a5a      	subs	r2, r3, r1
 80015d2:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 80015d6:	4667      	mov	r7, ip
 80015d8:	e750      	b.n	800147c <__udivdi3+0xcc>
 80015da:	4610      	mov	r0, r2
 80015dc:	e716      	b.n	800140c <__udivdi3+0x5c>
 80015de:	460b      	mov	r3, r1
 80015e0:	e729      	b.n	8001436 <__udivdi3+0x86>
 80015e2:	4613      	mov	r3, r2
 80015e4:	e772      	b.n	80014cc <__udivdi3+0x11c>
 80015e6:	40b0      	lsls	r0, r6
 80015e8:	4290      	cmp	r0, r2
 80015ea:	d2b7      	bcs.n	800155c <__udivdi3+0x1ac>
 80015ec:	1e60      	subs	r0, r4, #1
 80015ee:	2600      	movs	r6, #0
 80015f0:	e724      	b.n	800143c <__udivdi3+0x8c>
 80015f2:	4630      	mov	r0, r6
 80015f4:	e722      	b.n	800143c <__udivdi3+0x8c>
 80015f6:	42a9      	cmp	r1, r5
 80015f8:	d995      	bls.n	8001526 <__udivdi3+0x176>
 80015fa:	f1a8 0802 	sub.w	r8, r8, #2
 80015fe:	441d      	add	r5, r3
 8001600:	e792      	b.n	8001528 <__udivdi3+0x178>
 8001602:	458c      	cmp	ip, r1
 8001604:	d9a0      	bls.n	8001548 <__udivdi3+0x198>
 8001606:	3c02      	subs	r4, #2
 8001608:	4419      	add	r1, r3
 800160a:	e79e      	b.n	800154a <__udivdi3+0x19a>
 800160c:	4610      	mov	r0, r2
 800160e:	e7df      	b.n	80015d0 <__udivdi3+0x220>
 8001610:	460e      	mov	r6, r1
 8001612:	e7c9      	b.n	80015a8 <__udivdi3+0x1f8>
 8001614:	3802      	subs	r0, #2
 8001616:	4429      	add	r1, r5
 8001618:	e743      	b.n	80014a2 <__udivdi3+0xf2>
 800161a:	bf00      	nop

0800161c <MATH_abs>:

//! \brief     Finds the absolute value 
//! \param[in] in   The input value
//! \return    The absolute value
static inline float_t MATH_abs(const float_t in)
{
 800161c:	b480      	push	{r7}
 800161e:	b085      	sub	sp, #20
 8001620:	af00      	add	r7, sp, #0
 8001622:	ed87 0a01 	vstr	s0, [r7, #4]
  float_t out = in;
 8001626:	687b      	ldr	r3, [r7, #4]
 8001628:	60fb      	str	r3, [r7, #12]


  if(in < 0.0f)
 800162a:	edd7 7a01 	vldr	s15, [r7, #4]
 800162e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8001632:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001636:	d505      	bpl.n	8001644 <MATH_abs+0x28>
    {
      out = -in;
 8001638:	edd7 7a01 	vldr	s15, [r7, #4]
 800163c:	eef1 7a67 	vneg.f32	s15, s15
 8001640:	edc7 7a03 	vstr	s15, [r7, #12]
    }

  return(out);
 8001644:	68fb      	ldr	r3, [r7, #12]
 8001646:	ee07 3a90 	vmov	s15, r3
} // end of MATH_abs() function
 800164a:	eeb0 0a67 	vmov.f32	s0, s15
 800164e:	3714      	adds	r7, #20
 8001650:	46bd      	mov	sp, r7
 8001652:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001656:	4770      	bx	lr

08001658 <INITPOSDET_Init>:

#include "modules/InitPosDet/InitPosDet.h"


INITPOSDET_Handle INITPOSDET_Init(void *pMemory, const size_t numBytes)//! \Mod By Dl.K
{
 8001658:	b480      	push	{r7}
 800165a:	b085      	sub	sp, #20
 800165c:	af00      	add	r7, sp, #0
 800165e:	6078      	str	r0, [r7, #4]
 8001660:	6039      	str	r1, [r7, #0]
	INITPOSDET_Handle handle;
	uint16_t i;

	if (numBytes < sizeof(INITPOSDET_Obj))
 8001662:	683b      	ldr	r3, [r7, #0]
 8001664:	2b5f      	cmp	r3, #95	; 0x5f
 8001666:	d801      	bhi.n	800166c <INITPOSDET_Init+0x14>
		return((INITPOSDET_Handle)NULL);
 8001668:	2300      	movs	r3, #0
 800166a:	e046      	b.n	80016fa <INITPOSDET_Init+0xa2>

	// assign the handle
	handle = (INITPOSDET_Handle)pMemory;
 800166c:	687b      	ldr	r3, [r7, #4]
 800166e:	60bb      	str	r3, [r7, #8]

	handle->InitPosDetFlag = true;
 8001670:	68bb      	ldr	r3, [r7, #8]
 8001672:	2201      	movs	r2, #1
 8001674:	801a      	strh	r2, [r3, #0]
	handle->InitPosAngleCount = 0;
 8001676:	68bb      	ldr	r3, [r7, #8]
 8001678:	2200      	movs	r2, #0
 800167a:	805a      	strh	r2, [r3, #2]
	handle->InitPosAngle = (0.0);
 800167c:	68bb      	ldr	r3, [r7, #8]
 800167e:	f04f 0200 	mov.w	r2, #0
 8001682:	605a      	str	r2, [r3, #4]
	handle->SubdivideAngle = (SUBDIVIDE_ANGLE_PU);
 8001684:	68bb      	ldr	r3, [r7, #8]
 8001686:	4a20      	ldr	r2, [pc, #128]	; (8001708 <INITPOSDET_Init+0xb0>)
 8001688:	609a      	str	r2, [r3, #8]
	handle->VolVecAngleFlag = false;
 800168a:	68bb      	ldr	r3, [r7, #8]
 800168c:	2200      	movs	r2, #0
 800168e:	819a      	strh	r2, [r3, #12]
	handle->VolVecAngleCount = 0;
 8001690:	68bb      	ldr	r3, [r7, #8]
 8001692:	2200      	movs	r2, #0
 8001694:	81da      	strh	r2, [r3, #14]
	handle->VolVecAngle = (0.0);
 8001696:	68bb      	ldr	r3, [r7, #8]
 8001698:	f04f 0200 	mov.w	r2, #0
 800169c:	611a      	str	r2, [r3, #16]
	handle->VolVecAngleOffset = (-0.5);//-0.1666667
 800169e:	68bb      	ldr	r3, [r7, #8]
 80016a0:	f04f 423f 	mov.w	r2, #3204448256	; 0xbf000000
 80016a4:	615a      	str	r2, [r3, #20]
	handle->VolVecAngleIntervalTime = VOL_VEC_ANGLE_INTERVAL_TIME_SCLAR;
 80016a6:	68bb      	ldr	r3, [r7, #8]
 80016a8:	220a      	movs	r2, #10
 80016aa:	831a      	strh	r2, [r3, #24]
	handle->IdSampAngleFlag = false;
 80016ac:	68bb      	ldr	r3, [r7, #8]
 80016ae:	2200      	movs	r2, #0
 80016b0:	835a      	strh	r2, [r3, #26]
	handle->IdSampAngle = (0.0);
 80016b2:	68bb      	ldr	r3, [r7, #8]
 80016b4:	f04f 0200 	mov.w	r2, #0
 80016b8:	61da      	str	r2, [r3, #28]
	handle->IdSampAngleCount = 0;
 80016ba:	68bb      	ldr	r3, [r7, #8]
 80016bc:	2200      	movs	r2, #0
 80016be:	841a      	strh	r2, [r3, #32]
	for (i = 0; i<VOL_VEC_ANGLE_SCLAR / 2; i++)
 80016c0:	2300      	movs	r3, #0
 80016c2:	81fb      	strh	r3, [r7, #14]
 80016c4:	e00a      	b.n	80016dc <INITPOSDET_Init+0x84>
	{
		handle->IdEvg[i] = (0.0);
 80016c6:	89fb      	ldrh	r3, [r7, #14]
 80016c8:	68ba      	ldr	r2, [r7, #8]
 80016ca:	3308      	adds	r3, #8
 80016cc:	009b      	lsls	r3, r3, #2
 80016ce:	4413      	add	r3, r2
 80016d0:	f04f 0200 	mov.w	r2, #0
 80016d4:	605a      	str	r2, [r3, #4]
	handle->VolVecAngleOffset = (-0.5);//-0.1666667
	handle->VolVecAngleIntervalTime = VOL_VEC_ANGLE_INTERVAL_TIME_SCLAR;
	handle->IdSampAngleFlag = false;
	handle->IdSampAngle = (0.0);
	handle->IdSampAngleCount = 0;
	for (i = 0; i<VOL_VEC_ANGLE_SCLAR / 2; i++)
 80016d6:	89fb      	ldrh	r3, [r7, #14]
 80016d8:	3301      	adds	r3, #1
 80016da:	81fb      	strh	r3, [r7, #14]
 80016dc:	89fb      	ldrh	r3, [r7, #14]
 80016de:	2b0b      	cmp	r3, #11
 80016e0:	d9f1      	bls.n	80016c6 <INITPOSDET_Init+0x6e>
	{
		handle->IdEvg[i] = (0.0);
	}
	handle->IdEvgCoeff = (1.0 / ID_EVG_SCLAR1);
 80016e2:	68bb      	ldr	r3, [r7, #8]
 80016e4:	4a09      	ldr	r2, [pc, #36]	; (800170c <INITPOSDET_Init+0xb4>)
 80016e6:	655a      	str	r2, [r3, #84]	; 0x54
	handle->IdEvgCount = 0;
 80016e8:	68bb      	ldr	r3, [r7, #8]
 80016ea:	2200      	movs	r2, #0
 80016ec:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58

	handle->IdEvgTmp = (0.0);
 80016f0:	68bb      	ldr	r3, [r7, #8]
 80016f2:	f04f 0200 	mov.w	r2, #0
 80016f6:	65da      	str	r2, [r3, #92]	; 0x5c

	return(handle);
 80016f8:	68bb      	ldr	r3, [r7, #8]
}
 80016fa:	4618      	mov	r0, r3
 80016fc:	3714      	adds	r7, #20
 80016fe:	46bd      	mov	sp, r7
 8001700:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001704:	4770      	bx	lr
 8001706:	bf00      	nop
 8001708:	3daaaaa6 	.word	0x3daaaaa6
 800170c:	3ca3d70a 	.word	0x3ca3d70a

08001710 <BubbleSort>:


void BubbleSort(float_t a[], uint16_t b[],uint16_t size)
{
 8001710:	b480      	push	{r7}
 8001712:	b089      	sub	sp, #36	; 0x24
 8001714:	af00      	add	r7, sp, #0
 8001716:	60f8      	str	r0, [r7, #12]
 8001718:	60b9      	str	r1, [r7, #8]
 800171a:	4613      	mov	r3, r2
 800171c:	80fb      	strh	r3, [r7, #6]
	uint16_t lastSwapPos = 0,lastSwapPosTemp = 0;
 800171e:	2300      	movs	r3, #0
 8001720:	833b      	strh	r3, [r7, #24]
 8001722:	2300      	movs	r3, #0
 8001724:	83fb      	strh	r3, [r7, #30]
	uint16_t i,j;
	float_t temp;
	uint16_t temp1;
    for (i = 0; i < size - 1; i++)
 8001726:	2300      	movs	r3, #0
 8001728:	83bb      	strh	r3, [r7, #28]
 800172a:	e062      	b.n	80017f2 <BubbleSort+0xe2>
    {
        lastSwapPos = lastSwapPosTemp;
 800172c:	8bfb      	ldrh	r3, [r7, #30]
 800172e:	833b      	strh	r3, [r7, #24]
        for (j = size - 1; j >lastSwapPos; j--)
 8001730:	88fb      	ldrh	r3, [r7, #6]
 8001732:	3b01      	subs	r3, #1
 8001734:	837b      	strh	r3, [r7, #26]
 8001736:	e050      	b.n	80017da <BubbleSort+0xca>
        {
            if (a[j - 1] < a[j])
 8001738:	8b7a      	ldrh	r2, [r7, #26]
 800173a:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
 800173e:	4413      	add	r3, r2
 8001740:	009b      	lsls	r3, r3, #2
 8001742:	68fa      	ldr	r2, [r7, #12]
 8001744:	4413      	add	r3, r2
 8001746:	ed93 7a00 	vldr	s14, [r3]
 800174a:	8b7b      	ldrh	r3, [r7, #26]
 800174c:	009b      	lsls	r3, r3, #2
 800174e:	68fa      	ldr	r2, [r7, #12]
 8001750:	4413      	add	r3, r2
 8001752:	edd3 7a00 	vldr	s15, [r3]
 8001756:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800175a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800175e:	d539      	bpl.n	80017d4 <BubbleSort+0xc4>
            {
            	temp = a[j - 1];
 8001760:	8b7a      	ldrh	r2, [r7, #26]
 8001762:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
 8001766:	4413      	add	r3, r2
 8001768:	009b      	lsls	r3, r3, #2
 800176a:	68fa      	ldr	r2, [r7, #12]
 800176c:	4413      	add	r3, r2
 800176e:	681b      	ldr	r3, [r3, #0]
 8001770:	617b      	str	r3, [r7, #20]
                a[j - 1] = a[j];
 8001772:	8b7a      	ldrh	r2, [r7, #26]
 8001774:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
 8001778:	4413      	add	r3, r2
 800177a:	009b      	lsls	r3, r3, #2
 800177c:	68fa      	ldr	r2, [r7, #12]
 800177e:	4413      	add	r3, r2
 8001780:	8b7a      	ldrh	r2, [r7, #26]
 8001782:	0092      	lsls	r2, r2, #2
 8001784:	68f9      	ldr	r1, [r7, #12]
 8001786:	440a      	add	r2, r1
 8001788:	6812      	ldr	r2, [r2, #0]
 800178a:	601a      	str	r2, [r3, #0]
                a[j] = temp;
 800178c:	8b7b      	ldrh	r3, [r7, #26]
 800178e:	009b      	lsls	r3, r3, #2
 8001790:	68fa      	ldr	r2, [r7, #12]
 8001792:	4413      	add	r3, r2
 8001794:	697a      	ldr	r2, [r7, #20]
 8001796:	601a      	str	r2, [r3, #0]

                temp1 = b[j - 1];
 8001798:	8b7a      	ldrh	r2, [r7, #26]
 800179a:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 800179e:	4413      	add	r3, r2
 80017a0:	005b      	lsls	r3, r3, #1
 80017a2:	68ba      	ldr	r2, [r7, #8]
 80017a4:	4413      	add	r3, r2
 80017a6:	881b      	ldrh	r3, [r3, #0]
 80017a8:	827b      	strh	r3, [r7, #18]
                b[j - 1] = b[j];
 80017aa:	8b7a      	ldrh	r2, [r7, #26]
 80017ac:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 80017b0:	4413      	add	r3, r2
 80017b2:	005b      	lsls	r3, r3, #1
 80017b4:	68ba      	ldr	r2, [r7, #8]
 80017b6:	4413      	add	r3, r2
 80017b8:	8b7a      	ldrh	r2, [r7, #26]
 80017ba:	0052      	lsls	r2, r2, #1
 80017bc:	68b9      	ldr	r1, [r7, #8]
 80017be:	440a      	add	r2, r1
 80017c0:	8812      	ldrh	r2, [r2, #0]
 80017c2:	801a      	strh	r2, [r3, #0]
                b[j] = temp1;
 80017c4:	8b7b      	ldrh	r3, [r7, #26]
 80017c6:	005b      	lsls	r3, r3, #1
 80017c8:	68ba      	ldr	r2, [r7, #8]
 80017ca:	4413      	add	r3, r2
 80017cc:	8a7a      	ldrh	r2, [r7, #18]
 80017ce:	801a      	strh	r2, [r3, #0]

                lastSwapPosTemp = j;
 80017d0:	8b7b      	ldrh	r3, [r7, #26]
 80017d2:	83fb      	strh	r3, [r7, #30]
	float_t temp;
	uint16_t temp1;
    for (i = 0; i < size - 1; i++)
    {
        lastSwapPos = lastSwapPosTemp;
        for (j = size - 1; j >lastSwapPos; j--)
 80017d4:	8b7b      	ldrh	r3, [r7, #26]
 80017d6:	3b01      	subs	r3, #1
 80017d8:	837b      	strh	r3, [r7, #26]
 80017da:	8b7a      	ldrh	r2, [r7, #26]
 80017dc:	8b3b      	ldrh	r3, [r7, #24]
 80017de:	429a      	cmp	r2, r3
 80017e0:	d8aa      	bhi.n	8001738 <BubbleSort+0x28>
                b[j] = temp1;

                lastSwapPosTemp = j;
            }
        }
        if (lastSwapPos == lastSwapPosTemp)break;
 80017e2:	8b3a      	ldrh	r2, [r7, #24]
 80017e4:	8bfb      	ldrh	r3, [r7, #30]
 80017e6:	429a      	cmp	r2, r3
 80017e8:	d100      	bne.n	80017ec <BubbleSort+0xdc>
 80017ea:	e007      	b.n	80017fc <BubbleSort+0xec>
{
	uint16_t lastSwapPos = 0,lastSwapPosTemp = 0;
	uint16_t i,j;
	float_t temp;
	uint16_t temp1;
    for (i = 0; i < size - 1; i++)
 80017ec:	8bbb      	ldrh	r3, [r7, #28]
 80017ee:	3301      	adds	r3, #1
 80017f0:	83bb      	strh	r3, [r7, #28]
 80017f2:	8bba      	ldrh	r2, [r7, #28]
 80017f4:	88fb      	ldrh	r3, [r7, #6]
 80017f6:	3b01      	subs	r3, #1
 80017f8:	429a      	cmp	r2, r3
 80017fa:	db97      	blt.n	800172c <BubbleSort+0x1c>
                lastSwapPosTemp = j;
            }
        }
        if (lastSwapPos == lastSwapPosTemp)break;
    }
}
 80017fc:	3724      	adds	r7, #36	; 0x24
 80017fe:	46bd      	mov	sp, r7
 8001800:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001804:	4770      	bx	lr
 8001806:	bf00      	nop

08001808 <MATH_UINT16_T_ABS>:

uint16_t MATH_UINT16_T_ABS(uint16_t a, uint16_t b)
{
 8001808:	b480      	push	{r7}
 800180a:	b083      	sub	sp, #12
 800180c:	af00      	add	r7, sp, #0
 800180e:	4603      	mov	r3, r0
 8001810:	460a      	mov	r2, r1
 8001812:	80fb      	strh	r3, [r7, #6]
 8001814:	4613      	mov	r3, r2
 8001816:	80bb      	strh	r3, [r7, #4]
	if(a>b)
 8001818:	88fa      	ldrh	r2, [r7, #6]
 800181a:	88bb      	ldrh	r3, [r7, #4]
 800181c:	429a      	cmp	r2, r3
 800181e:	d904      	bls.n	800182a <MATH_UINT16_T_ABS+0x22>
		return a-b;
 8001820:	88fa      	ldrh	r2, [r7, #6]
 8001822:	88bb      	ldrh	r3, [r7, #4]
 8001824:	1ad3      	subs	r3, r2, r3
 8001826:	b29b      	uxth	r3, r3
 8001828:	e003      	b.n	8001832 <MATH_UINT16_T_ABS+0x2a>
	else
		return b-a;
 800182a:	88ba      	ldrh	r2, [r7, #4]
 800182c:	88fb      	ldrh	r3, [r7, #6]
 800182e:	1ad3      	subs	r3, r2, r3
 8001830:	b29b      	uxth	r3, r3
}
 8001832:	4618      	mov	r0, r3
 8001834:	370c      	adds	r7, #12
 8001836:	46bd      	mov	sp, r7
 8001838:	f85d 7b04 	ldr.w	r7, [sp], #4
 800183c:	4770      	bx	lr
 800183e:	bf00      	nop

08001840 <INITPOSDET_Run>:

void INITPOSDET_Run(INITPOSDET_Handle handle, float_t value)
{
 8001840:	b580      	push	{r7, lr}
 8001842:	b08e      	sub	sp, #56	; 0x38
 8001844:	af00      	add	r7, sp, #0
 8001846:	6078      	str	r0, [r7, #4]
 8001848:	ed87 0a00 	vstr	s0, [r7]
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
 800184c:	687b      	ldr	r3, [r7, #4]
 800184e:	633b      	str	r3, [r7, #48]	; 0x30
	uint16_t i,InitPosAngleCount_Evg,InitPosAngleCount_Min,InitPosAngleCount_Mid,InitPosAngleCount_Max,b[VOL_VEC_ANGLE_SCLAR/2]={0};
 8001850:	f107 030c 	add.w	r3, r7, #12
 8001854:	2200      	movs	r2, #0
 8001856:	601a      	str	r2, [r3, #0]
 8001858:	3304      	adds	r3, #4
 800185a:	2200      	movs	r2, #0
 800185c:	601a      	str	r2, [r3, #0]
 800185e:	3304      	adds	r3, #4
 8001860:	2200      	movs	r2, #0
 8001862:	601a      	str	r2, [r3, #0]
 8001864:	3304      	adds	r3, #4
 8001866:	2200      	movs	r2, #0
 8001868:	601a      	str	r2, [r3, #0]
 800186a:	3304      	adds	r3, #4
 800186c:	2200      	movs	r2, #0
 800186e:	601a      	str	r2, [r3, #0]
 8001870:	3304      	adds	r3, #4
 8001872:	2200      	movs	r2, #0
 8001874:	601a      	str	r2, [r3, #0]
 8001876:	3304      	adds	r3, #4

	if(obj->IdSampAngleFlag)
 8001878:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800187a:	8b5b      	ldrh	r3, [r3, #26]
 800187c:	2b00      	cmp	r3, #0
 800187e:	f000 81be 	beq.w	8001bfe <INITPOSDET_Run+0x3be>
	{
		if( obj->IdEvgCount<ID_EVG_SCLAR1*VOL_VEC_ANGLE_SCLAR/2 )
 8001882:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001884:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 8001888:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
 800188c:	f080 81b7 	bcs.w	8001bfe <INITPOSDET_Run+0x3be>
		{
			if(obj->IdEvgCount>=ID_EVG_SCLAR2*VOL_VEC_ANGLE_SCLAR/2)// Need Improve
 8001890:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001892:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 8001896:	2b3b      	cmp	r3, #59	; 0x3b
 8001898:	d966      	bls.n	8001968 <INITPOSDET_Run+0x128>
			{
				float_t value_tmp = obj->IdEvg[obj->IdSampAngleCount]/(obj->IdEvgCount/(VOL_VEC_ANGLE_SCLAR/2));
 800189a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800189c:	8c1b      	ldrh	r3, [r3, #32]
 800189e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80018a0:	3308      	adds	r3, #8
 80018a2:	009b      	lsls	r3, r3, #2
 80018a4:	4413      	add	r3, r2
 80018a6:	ed93 7a01 	vldr	s14, [r3, #4]
 80018aa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80018ac:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 80018b0:	4aa6      	ldr	r2, [pc, #664]	; (8001b4c <INITPOSDET_Run+0x30c>)
 80018b2:	fba2 2303 	umull	r2, r3, r2, r3
 80018b6:	08db      	lsrs	r3, r3, #3
 80018b8:	b29b      	uxth	r3, r3
 80018ba:	ee07 3a90 	vmov	s15, r3
 80018be:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80018c2:	eec7 7a27 	vdiv.f32	s15, s14, s15
 80018c6:	edc7 7a0b 	vstr	s15, [r7, #44]	; 0x2c
				if( MATH_abs( value_tmp - (obj->IdEvgCoeff * value) )
 80018ca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80018cc:	ed93 7a15 	vldr	s14, [r3, #84]	; 0x54
 80018d0:	edd7 7a00 	vldr	s15, [r7]
 80018d4:	ee67 7a27 	vmul.f32	s15, s14, s15
 80018d8:	ed97 7a0b 	vldr	s14, [r7, #44]	; 0x2c
 80018dc:	ee77 7a67 	vsub.f32	s15, s14, s15
 80018e0:	eeb0 0a67 	vmov.f32	s0, s15
 80018e4:	f7ff fe9a 	bl	800161c <MATH_abs>
 80018e8:	eef0 6a40 	vmov.f32	s13, s0
						> ((0.2f) * value_tmp) )
 80018ec:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
 80018f0:	ed9f 7a97 	vldr	s14, [pc, #604]	; 8001b50 <INITPOSDET_Run+0x310>
 80018f4:	ee67 7a87 	vmul.f32	s15, s15, s14
		if( obj->IdEvgCount<ID_EVG_SCLAR1*VOL_VEC_ANGLE_SCLAR/2 )
		{
			if(obj->IdEvgCount>=ID_EVG_SCLAR2*VOL_VEC_ANGLE_SCLAR/2)// Need Improve
			{
				float_t value_tmp = obj->IdEvg[obj->IdSampAngleCount]/(obj->IdEvgCount/(VOL_VEC_ANGLE_SCLAR/2));
				if( MATH_abs( value_tmp - (obj->IdEvgCoeff * value) )
 80018f8:	eef4 6ae7 	vcmpe.f32	s13, s15
 80018fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001900:	dd16      	ble.n	8001930 <INITPOSDET_Run+0xf0>
						> ((0.2f) * value_tmp) )
				{
					obj->IdEvg[obj->IdSampAngleCount] += value_tmp;
 8001902:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001904:	8c1b      	ldrh	r3, [r3, #32]
 8001906:	4619      	mov	r1, r3
 8001908:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800190a:	8c1b      	ldrh	r3, [r3, #32]
 800190c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800190e:	3308      	adds	r3, #8
 8001910:	009b      	lsls	r3, r3, #2
 8001912:	4413      	add	r3, r2
 8001914:	ed93 7a01 	vldr	s14, [r3, #4]
 8001918:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
 800191c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8001920:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8001922:	f101 0308 	add.w	r3, r1, #8
 8001926:	009b      	lsls	r3, r3, #2
 8001928:	4413      	add	r3, r2
 800192a:	edc3 7a01 	vstr	s15, [r3, #4]
 800192e:	e036      	b.n	800199e <INITPOSDET_Run+0x15e>
				}
				else
				{
					obj->IdEvg[obj->IdSampAngleCount] += (obj->IdEvgCoeff * value);
 8001930:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001932:	8c1b      	ldrh	r3, [r3, #32]
 8001934:	4619      	mov	r1, r3
 8001936:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001938:	8c1b      	ldrh	r3, [r3, #32]
 800193a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800193c:	3308      	adds	r3, #8
 800193e:	009b      	lsls	r3, r3, #2
 8001940:	4413      	add	r3, r2
 8001942:	ed93 7a01 	vldr	s14, [r3, #4]
 8001946:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001948:	edd3 6a15 	vldr	s13, [r3, #84]	; 0x54
 800194c:	edd7 7a00 	vldr	s15, [r7]
 8001950:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8001954:	ee77 7a27 	vadd.f32	s15, s14, s15
 8001958:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800195a:	f101 0308 	add.w	r3, r1, #8
 800195e:	009b      	lsls	r3, r3, #2
 8001960:	4413      	add	r3, r2
 8001962:	edc3 7a01 	vstr	s15, [r3, #4]
 8001966:	e01a      	b.n	800199e <INITPOSDET_Run+0x15e>
				}
			}
			else
			{
				obj->IdEvg[obj->IdSampAngleCount] += (obj->IdEvgCoeff * value);
 8001968:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800196a:	8c1b      	ldrh	r3, [r3, #32]
 800196c:	4619      	mov	r1, r3
 800196e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001970:	8c1b      	ldrh	r3, [r3, #32]
 8001972:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8001974:	3308      	adds	r3, #8
 8001976:	009b      	lsls	r3, r3, #2
 8001978:	4413      	add	r3, r2
 800197a:	ed93 7a01 	vldr	s14, [r3, #4]
 800197e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001980:	edd3 6a15 	vldr	s13, [r3, #84]	; 0x54
 8001984:	edd7 7a00 	vldr	s15, [r7]
 8001988:	ee66 7aa7 	vmul.f32	s15, s13, s15
 800198c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8001990:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8001992:	f101 0308 	add.w	r3, r1, #8
 8001996:	009b      	lsls	r3, r3, #2
 8001998:	4413      	add	r3, r2
 800199a:	edc3 7a01 	vstr	s15, [r3, #4]
			}

			obj->IdEvgCount++;
 800199e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80019a0:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 80019a4:	3301      	adds	r3, #1
 80019a6:	b29a      	uxth	r2, r3
 80019a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80019aa:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58

			if( obj->IdEvgCount>=ID_EVG_SCLAR1*VOL_VEC_ANGLE_SCLAR/2 )
 80019ae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80019b0:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 80019b4:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
 80019b8:	f0c0 8121 	bcc.w	8001bfe <INITPOSDET_Run+0x3be>
//						Id_max = obj->IdEvg[i];
//						obj->InitPosAngleCount = i;
//					}
//				}

				for(i=0;i<VOL_VEC_ANGLE_SCLAR/2;i++)
 80019bc:	2300      	movs	r3, #0
 80019be:	86fb      	strh	r3, [r7, #54]	; 0x36
 80019c0:	e00a      	b.n	80019d8 <INITPOSDET_Run+0x198>
				{
					b[i]=i;
 80019c2:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 80019c4:	005b      	lsls	r3, r3, #1
 80019c6:	f107 0238 	add.w	r2, r7, #56	; 0x38
 80019ca:	4413      	add	r3, r2
 80019cc:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 80019ce:	f823 2c2c 	strh.w	r2, [r3, #-44]
//						Id_max = obj->IdEvg[i];
//						obj->InitPosAngleCount = i;
//					}
//				}

				for(i=0;i<VOL_VEC_ANGLE_SCLAR/2;i++)
 80019d2:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 80019d4:	3301      	adds	r3, #1
 80019d6:	86fb      	strh	r3, [r7, #54]	; 0x36
 80019d8:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 80019da:	2b0b      	cmp	r3, #11
 80019dc:	d9f1      	bls.n	80019c2 <INITPOSDET_Run+0x182>
				{
					b[i]=i;
					//obj->IdEvgArray[obj->ArrayCount][i]=obj->IdEvg[i];
				}

				obj->IdEvg[0]=0;obj->IdEvg[1]=2;obj->IdEvg[2]=4;obj->IdEvg[3]=6;obj->IdEvg[4]=8;obj->IdEvg[5]=10;
 80019de:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80019e0:	f04f 0200 	mov.w	r2, #0
 80019e4:	625a      	str	r2, [r3, #36]	; 0x24
 80019e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80019e8:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80019ec:	629a      	str	r2, [r3, #40]	; 0x28
 80019ee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80019f0:	f04f 4281 	mov.w	r2, #1082130432	; 0x40800000
 80019f4:	62da      	str	r2, [r3, #44]	; 0x2c
 80019f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80019f8:	4a56      	ldr	r2, [pc, #344]	; (8001b54 <INITPOSDET_Run+0x314>)
 80019fa:	631a      	str	r2, [r3, #48]	; 0x30
 80019fc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80019fe:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
 8001a02:	635a      	str	r2, [r3, #52]	; 0x34
 8001a04:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001a06:	4a54      	ldr	r2, [pc, #336]	; (8001b58 <INITPOSDET_Run+0x318>)
 8001a08:	639a      	str	r2, [r3, #56]	; 0x38
				obj->IdEvg[6]=1;obj->IdEvg[7]=3;obj->IdEvg[8]=5;obj->IdEvg[9]=7;obj->IdEvg[10]=9;obj->IdEvg[11]=11;
 8001a0a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001a0c:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8001a10:	63da      	str	r2, [r3, #60]	; 0x3c
 8001a12:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001a14:	4a51      	ldr	r2, [pc, #324]	; (8001b5c <INITPOSDET_Run+0x31c>)
 8001a16:	641a      	str	r2, [r3, #64]	; 0x40
 8001a18:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001a1a:	4a51      	ldr	r2, [pc, #324]	; (8001b60 <INITPOSDET_Run+0x320>)
 8001a1c:	645a      	str	r2, [r3, #68]	; 0x44
 8001a1e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001a20:	4a50      	ldr	r2, [pc, #320]	; (8001b64 <INITPOSDET_Run+0x324>)
 8001a22:	649a      	str	r2, [r3, #72]	; 0x48
 8001a24:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001a26:	4a50      	ldr	r2, [pc, #320]	; (8001b68 <INITPOSDET_Run+0x328>)
 8001a28:	64da      	str	r2, [r3, #76]	; 0x4c
 8001a2a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001a2c:	4a4f      	ldr	r2, [pc, #316]	; (8001b6c <INITPOSDET_Run+0x32c>)
 8001a2e:	651a      	str	r2, [r3, #80]	; 0x50
				BubbleSort(obj->IdEvg,b,VOL_VEC_ANGLE_SCLAR/2);
 8001a30:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001a32:	f103 0224 	add.w	r2, r3, #36	; 0x24
 8001a36:	f107 030c 	add.w	r3, r7, #12
 8001a3a:	4610      	mov	r0, r2
 8001a3c:	4619      	mov	r1, r3
 8001a3e:	220c      	movs	r2, #12
 8001a40:	f7ff fe66 	bl	8001710 <BubbleSort>

				InitPosAngleCount_Evg = (b[0] + b[1] + b[2] + b[3] + b[4])/5;
 8001a44:	89bb      	ldrh	r3, [r7, #12]
 8001a46:	461a      	mov	r2, r3
 8001a48:	89fb      	ldrh	r3, [r7, #14]
 8001a4a:	4413      	add	r3, r2
 8001a4c:	8a3a      	ldrh	r2, [r7, #16]
 8001a4e:	4413      	add	r3, r2
 8001a50:	8a7a      	ldrh	r2, [r7, #18]
 8001a52:	4413      	add	r3, r2
 8001a54:	8aba      	ldrh	r2, [r7, #20]
 8001a56:	4413      	add	r3, r2
 8001a58:	4a45      	ldr	r2, [pc, #276]	; (8001b70 <INITPOSDET_Run+0x330>)
 8001a5a:	fb82 1203 	smull	r1, r2, r2, r3
 8001a5e:	1052      	asrs	r2, r2, #1
 8001a60:	17db      	asrs	r3, r3, #31
 8001a62:	1ad3      	subs	r3, r2, r3
 8001a64:	857b      	strh	r3, [r7, #42]	; 0x2a
				InitPosAngleCount_Min = MATH_UINT16_T_ABS(b[0],InitPosAngleCount_Evg);
 8001a66:	89ba      	ldrh	r2, [r7, #12]
 8001a68:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8001a6a:	4610      	mov	r0, r2
 8001a6c:	4619      	mov	r1, r3
 8001a6e:	f7ff fecb 	bl	8001808 <MATH_UINT16_T_ABS>
 8001a72:	4603      	mov	r3, r0
 8001a74:	853b      	strh	r3, [r7, #40]	; 0x28
				InitPosAngleCount_Mid = MATH_UINT16_T_ABS(b[1],InitPosAngleCount_Evg);
 8001a76:	89fa      	ldrh	r2, [r7, #14]
 8001a78:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8001a7a:	4610      	mov	r0, r2
 8001a7c:	4619      	mov	r1, r3
 8001a7e:	f7ff fec3 	bl	8001808 <MATH_UINT16_T_ABS>
 8001a82:	4603      	mov	r3, r0
 8001a84:	84fb      	strh	r3, [r7, #38]	; 0x26
				InitPosAngleCount_Max = MATH_UINT16_T_ABS(b[2],InitPosAngleCount_Evg);
 8001a86:	8a3a      	ldrh	r2, [r7, #16]
 8001a88:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8001a8a:	4610      	mov	r0, r2
 8001a8c:	4619      	mov	r1, r3
 8001a8e:	f7ff febb 	bl	8001808 <MATH_UINT16_T_ABS>
 8001a92:	4603      	mov	r3, r0
 8001a94:	84bb      	strh	r3, [r7, #36]	; 0x24
				if( InitPosAngleCount_Min < InitPosAngleCount_Mid && InitPosAngleCount_Min < InitPosAngleCount_Max )
 8001a96:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 8001a98:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8001a9a:	429a      	cmp	r2, r3
 8001a9c:	d207      	bcs.n	8001aae <INITPOSDET_Run+0x26e>
 8001a9e:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 8001aa0:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8001aa2:	429a      	cmp	r2, r3
 8001aa4:	d203      	bcs.n	8001aae <INITPOSDET_Run+0x26e>
				{
					obj->InitPosAngleCount = b[0];
 8001aa6:	89ba      	ldrh	r2, [r7, #12]
 8001aa8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001aaa:	805a      	strh	r2, [r3, #2]
 8001aac:	e016      	b.n	8001adc <INITPOSDET_Run+0x29c>
				}
				else if( InitPosAngleCount_Mid < InitPosAngleCount_Min && InitPosAngleCount_Mid < InitPosAngleCount_Max )
 8001aae:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8001ab0:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8001ab2:	429a      	cmp	r2, r3
 8001ab4:	d207      	bcs.n	8001ac6 <INITPOSDET_Run+0x286>
 8001ab6:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8001ab8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8001aba:	429a      	cmp	r2, r3
 8001abc:	d203      	bcs.n	8001ac6 <INITPOSDET_Run+0x286>
				{
					obj->InitPosAngleCount = b[1];
 8001abe:	89fa      	ldrh	r2, [r7, #14]
 8001ac0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001ac2:	805a      	strh	r2, [r3, #2]
 8001ac4:	e00a      	b.n	8001adc <INITPOSDET_Run+0x29c>
				}
				else if( InitPosAngleCount_Max < InitPosAngleCount_Min && InitPosAngleCount_Max < InitPosAngleCount_Mid )
 8001ac6:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8001ac8:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8001aca:	429a      	cmp	r2, r3
 8001acc:	d206      	bcs.n	8001adc <INITPOSDET_Run+0x29c>
 8001ace:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8001ad0:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8001ad2:	429a      	cmp	r2, r3
 8001ad4:	d202      	bcs.n	8001adc <INITPOSDET_Run+0x29c>
				{
					obj->InitPosAngleCount = b[2];
 8001ad6:	8a3a      	ldrh	r2, [r7, #16]
 8001ad8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001ada:	805a      	strh	r2, [r3, #2]
				}
				
				obj->InitPosAngle = obj->InitPosAngleCount*obj->SubdivideAngle + obj->VolVecAngleOffset;
 8001adc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001ade:	885b      	ldrh	r3, [r3, #2]
 8001ae0:	ee07 3a90 	vmov	s15, r3
 8001ae4:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8001ae8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001aea:	edd3 7a02 	vldr	s15, [r3, #8]
 8001aee:	ee27 7a27 	vmul.f32	s14, s14, s15
 8001af2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001af4:	edd3 7a05 	vldr	s15, [r3, #20]
 8001af8:	ee77 7a27 	vadd.f32	s15, s14, s15
 8001afc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001afe:	edc3 7a01 	vstr	s15, [r3, #4]
				obj->VolVecAngleOffset = obj->InitPosAngle - obj->SubdivideAngle - obj->SubdivideAngle;
 8001b02:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b04:	ed93 7a01 	vldr	s14, [r3, #4]
 8001b08:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b0a:	edd3 7a02 	vldr	s15, [r3, #8]
 8001b0e:	ee37 7a67 	vsub.f32	s14, s14, s15
 8001b12:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b14:	edd3 7a02 	vldr	s15, [r3, #8]
 8001b18:	ee77 7a67 	vsub.f32	s15, s14, s15
 8001b1c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b1e:	edc3 7a05 	vstr	s15, [r3, #20]
				if( obj->VolVecAngleOffset > (1.0f) )
 8001b22:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b24:	edd3 7a05 	vldr	s15, [r3, #20]
 8001b28:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8001b2c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001b30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001b34:	dd22      	ble.n	8001b7c <INITPOSDET_Run+0x33c>
					obj->VolVecAngleOffset -= (1.0f);
 8001b36:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b38:	edd3 7a05 	vldr	s15, [r3, #20]
 8001b3c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8001b40:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8001b44:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b46:	edc3 7a05 	vstr	s15, [r3, #20]
 8001b4a:	e02b      	b.n	8001ba4 <INITPOSDET_Run+0x364>
 8001b4c:	aaaaaaab 	.word	0xaaaaaaab
 8001b50:	3e4ccccd 	.word	0x3e4ccccd
 8001b54:	40c00000 	.word	0x40c00000
 8001b58:	41200000 	.word	0x41200000
 8001b5c:	40400000 	.word	0x40400000
 8001b60:	40a00000 	.word	0x40a00000
 8001b64:	40e00000 	.word	0x40e00000
 8001b68:	41100000 	.word	0x41100000
 8001b6c:	41300000 	.word	0x41300000
 8001b70:	66666667 	.word	0x66666667
 8001b74:	3eaaaa9f 	.word	0x3eaaaa9f
 8001b78:	3c23d70a 	.word	0x3c23d70a
				else if( obj->VolVecAngleOffset < (-1.0f) )
 8001b7c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b7e:	edd3 7a05 	vldr	s15, [r3, #20]
 8001b82:	eebf 7a00 	vmov.f32	s14, #240	; 0xf0
 8001b86:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001b8a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001b8e:	d509      	bpl.n	8001ba4 <INITPOSDET_Run+0x364>
					obj->VolVecAngleOffset += (1.0f);
 8001b90:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b92:	edd3 7a05 	vldr	s15, [r3, #20]
 8001b96:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8001b9a:	ee77 7a87 	vadd.f32	s15, s15, s14
 8001b9e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001ba0:	edc3 7a05 	vstr	s15, [r3, #20]
				obj->SubdivideAngle = (obj->SubdivideAngle * (0.333333f));//(0.5f) Test:(1.0f)
 8001ba4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001ba6:	edd3 7a02 	vldr	s15, [r3, #8]
 8001baa:	ed1f 7a0e 	vldr	s14, [pc, #-56]	; 8001b74 <INITPOSDET_Run+0x334>
 8001bae:	ee67 7a87 	vmul.f32	s15, s15, s14
 8001bb2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001bb4:	edc3 7a02 	vstr	s15, [r3, #8]
				if( obj->SubdivideAngle < (0.01f) )// 0.005f Test: 0.01f
 8001bb8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001bba:	edd3 7a02 	vldr	s15, [r3, #8]
 8001bbe:	ed1f 7a12 	vldr	s14, [pc, #-72]	; 8001b78 <INITPOSDET_Run+0x338>
 8001bc2:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001bc6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001bca:	d503      	bpl.n	8001bd4 <INITPOSDET_Run+0x394>
				{
					obj->InitPosDetFlag = false;
 8001bcc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001bce:	2200      	movs	r2, #0
 8001bd0:	801a      	strh	r2, [r3, #0]
 8001bd2:	e014      	b.n	8001bfe <INITPOSDET_Run+0x3be>
				}
				else
				{
					obj->IdEvgCount = 0;
 8001bd4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001bd6:	2200      	movs	r2, #0
 8001bd8:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
					for(i=0;i<VOL_VEC_ANGLE_SCLAR/2;i++)
 8001bdc:	2300      	movs	r3, #0
 8001bde:	86fb      	strh	r3, [r7, #54]	; 0x36
 8001be0:	e00a      	b.n	8001bf8 <INITPOSDET_Run+0x3b8>
					{
						obj->IdEvg[i] = (0.0f);
 8001be2:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8001be4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8001be6:	3308      	adds	r3, #8
 8001be8:	009b      	lsls	r3, r3, #2
 8001bea:	4413      	add	r3, r2
 8001bec:	f04f 0200 	mov.w	r2, #0
 8001bf0:	605a      	str	r2, [r3, #4]
					obj->InitPosDetFlag = false;
				}
				else
				{
					obj->IdEvgCount = 0;
					for(i=0;i<VOL_VEC_ANGLE_SCLAR/2;i++)
 8001bf2:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8001bf4:	3301      	adds	r3, #1
 8001bf6:	86fb      	strh	r3, [r7, #54]	; 0x36
 8001bf8:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8001bfa:	2b0b      	cmp	r3, #11
 8001bfc:	d9f1      	bls.n	8001be2 <INITPOSDET_Run+0x3a2>
//				obj->IdEvgCount = 0;
			}
		}
	}

	return;
 8001bfe:	bf00      	nop
}
 8001c00:	3738      	adds	r7, #56	; 0x38
 8001c02:	46bd      	mov	sp, r7
 8001c04:	bd80      	pop	{r7, pc}
 8001c06:	bf00      	nop

08001c08 <INITPOSDET_VolVecAngleRun>:


void INITPOSDET_VolVecAngleRun(INITPOSDET_Handle handle)
{
 8001c08:	b480      	push	{r7}
 8001c0a:	b085      	sub	sp, #20
 8001c0c:	af00      	add	r7, sp, #0
 8001c0e:	6078      	str	r0, [r7, #4]
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
 8001c10:	687b      	ldr	r3, [r7, #4]
 8001c12:	60fb      	str	r3, [r7, #12]
	uint16_t count_temp = 0;
 8001c14:	2300      	movs	r3, #0
 8001c16:	817b      	strh	r3, [r7, #10]

	if(obj->InitPosDetFlag)
 8001c18:	68fb      	ldr	r3, [r7, #12]
 8001c1a:	881b      	ldrh	r3, [r3, #0]
 8001c1c:	2b00      	cmp	r3, #0
 8001c1e:	f000 8087 	beq.w	8001d30 <INITPOSDET_VolVecAngleRun+0x128>
	{
		if( obj->VolVecAngleIntervalTime >= VOL_VEC_ANGLE_INTERVAL_TIME_SCLAR )
 8001c22:	68fb      	ldr	r3, [r7, #12]
 8001c24:	8b1b      	ldrh	r3, [r3, #24]
 8001c26:	2b09      	cmp	r3, #9
 8001c28:	d975      	bls.n	8001d16 <INITPOSDET_VolVecAngleRun+0x10e>
		{
			if( obj->VolVecAngleCount < VOL_VEC_ANGLE_SCLAR )
 8001c2a:	68fb      	ldr	r3, [r7, #12]
 8001c2c:	89db      	ldrh	r3, [r3, #14]
 8001c2e:	2b17      	cmp	r3, #23
 8001c30:	f200 8084 	bhi.w	8001d3c <INITPOSDET_VolVecAngleRun+0x134>
			{
				count_temp = obj->VolVecAngleCount / 2;
 8001c34:	68fb      	ldr	r3, [r7, #12]
 8001c36:	89db      	ldrh	r3, [r3, #14]
 8001c38:	085b      	lsrs	r3, r3, #1
 8001c3a:	817b      	strh	r3, [r7, #10]
				obj->VolVecAngle = count_temp * obj->SubdivideAngle + obj->VolVecAngleOffset;
 8001c3c:	897b      	ldrh	r3, [r7, #10]
 8001c3e:	ee07 3a90 	vmov	s15, r3
 8001c42:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8001c46:	68fb      	ldr	r3, [r7, #12]
 8001c48:	edd3 7a02 	vldr	s15, [r3, #8]
 8001c4c:	ee27 7a27 	vmul.f32	s14, s14, s15
 8001c50:	68fb      	ldr	r3, [r7, #12]
 8001c52:	edd3 7a05 	vldr	s15, [r3, #20]
 8001c56:	ee77 7a27 	vadd.f32	s15, s14, s15
 8001c5a:	68fb      	ldr	r3, [r7, #12]
 8001c5c:	edc3 7a04 	vstr	s15, [r3, #16]
				obj->IdSampAngle = obj->VolVecAngle;
 8001c60:	68fb      	ldr	r3, [r7, #12]
 8001c62:	691a      	ldr	r2, [r3, #16]
 8001c64:	68fb      	ldr	r3, [r7, #12]
 8001c66:	61da      	str	r2, [r3, #28]
				obj->IdSampAngleFlag = false;
 8001c68:	68fb      	ldr	r3, [r7, #12]
 8001c6a:	2200      	movs	r2, #0
 8001c6c:	835a      	strh	r2, [r3, #26]
				obj->IdSampAngleCount = count_temp;
 8001c6e:	68fb      	ldr	r3, [r7, #12]
 8001c70:	897a      	ldrh	r2, [r7, #10]
 8001c72:	841a      	strh	r2, [r3, #32]
				if( obj->VolVecAngleCount %2 == 1 )
 8001c74:	68fb      	ldr	r3, [r7, #12]
 8001c76:	89db      	ldrh	r3, [r3, #14]
 8001c78:	f003 0301 	and.w	r3, r3, #1
 8001c7c:	b29b      	uxth	r3, r3
 8001c7e:	2b00      	cmp	r3, #0
 8001c80:	d00f      	beq.n	8001ca2 <INITPOSDET_VolVecAngleRun+0x9a>
				{
					obj->VolVecAngle += (0.5f);
 8001c82:	68fb      	ldr	r3, [r7, #12]
 8001c84:	edd3 7a04 	vldr	s15, [r3, #16]
 8001c88:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 8001c8c:	ee77 7a87 	vadd.f32	s15, s15, s14
 8001c90:	68fb      	ldr	r3, [r7, #12]
 8001c92:	edc3 7a04 	vstr	s15, [r3, #16]
					obj->VolVecAngleIntervalTime = 1;
 8001c96:	68fb      	ldr	r3, [r7, #12]
 8001c98:	2201      	movs	r2, #1
 8001c9a:	831a      	strh	r2, [r3, #24]
					obj->IdSampAngleFlag = true;
 8001c9c:	68fb      	ldr	r3, [r7, #12]
 8001c9e:	2201      	movs	r2, #1
 8001ca0:	835a      	strh	r2, [r3, #26]
				}
				if( obj->VolVecAngle > (1.0f) )
 8001ca2:	68fb      	ldr	r3, [r7, #12]
 8001ca4:	edd3 7a04 	vldr	s15, [r3, #16]
 8001ca8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8001cac:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001cb0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001cb4:	dd0a      	ble.n	8001ccc <INITPOSDET_VolVecAngleRun+0xc4>
					obj->VolVecAngle -= (1.0f);
 8001cb6:	68fb      	ldr	r3, [r7, #12]
 8001cb8:	edd3 7a04 	vldr	s15, [r3, #16]
 8001cbc:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8001cc0:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8001cc4:	68fb      	ldr	r3, [r7, #12]
 8001cc6:	edc3 7a04 	vstr	s15, [r3, #16]
 8001cca:	e013      	b.n	8001cf4 <INITPOSDET_VolVecAngleRun+0xec>
				else if( obj->VolVecAngle < (-1.0f) )
 8001ccc:	68fb      	ldr	r3, [r7, #12]
 8001cce:	edd3 7a04 	vldr	s15, [r3, #16]
 8001cd2:	eebf 7a00 	vmov.f32	s14, #240	; 0xf0
 8001cd6:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001cda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001cde:	d509      	bpl.n	8001cf4 <INITPOSDET_VolVecAngleRun+0xec>
					obj->VolVecAngle += (1.0f);
 8001ce0:	68fb      	ldr	r3, [r7, #12]
 8001ce2:	edd3 7a04 	vldr	s15, [r3, #16]
 8001ce6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8001cea:	ee77 7a87 	vadd.f32	s15, s15, s14
 8001cee:	68fb      	ldr	r3, [r7, #12]
 8001cf0:	edc3 7a04 	vstr	s15, [r3, #16]

				obj->VolVecAngleCount++;
 8001cf4:	68fb      	ldr	r3, [r7, #12]
 8001cf6:	89db      	ldrh	r3, [r3, #14]
 8001cf8:	3301      	adds	r3, #1
 8001cfa:	b29a      	uxth	r2, r3
 8001cfc:	68fb      	ldr	r3, [r7, #12]
 8001cfe:	81da      	strh	r2, [r3, #14]

				obj->VolVecAngleFlag = true;
 8001d00:	68fb      	ldr	r3, [r7, #12]
 8001d02:	2201      	movs	r2, #1
 8001d04:	819a      	strh	r2, [r3, #12]

				if( obj->VolVecAngleCount >= VOL_VEC_ANGLE_SCLAR )
 8001d06:	68fb      	ldr	r3, [r7, #12]
 8001d08:	89db      	ldrh	r3, [r3, #14]
 8001d0a:	2b17      	cmp	r3, #23
 8001d0c:	d916      	bls.n	8001d3c <INITPOSDET_VolVecAngleRun+0x134>
				{
					obj->VolVecAngleCount=0;
 8001d0e:	68fb      	ldr	r3, [r7, #12]
 8001d10:	2200      	movs	r2, #0
 8001d12:	81da      	strh	r2, [r3, #14]
 8001d14:	e012      	b.n	8001d3c <INITPOSDET_VolVecAngleRun+0x134>
				}
			}
		}
		else
		{
			obj->VolVecAngleIntervalTime++;
 8001d16:	68fb      	ldr	r3, [r7, #12]
 8001d18:	8b1b      	ldrh	r3, [r3, #24]
 8001d1a:	3301      	adds	r3, #1
 8001d1c:	b29a      	uxth	r2, r3
 8001d1e:	68fb      	ldr	r3, [r7, #12]
 8001d20:	831a      	strh	r2, [r3, #24]
			obj->VolVecAngleFlag = false;
 8001d22:	68fb      	ldr	r3, [r7, #12]
 8001d24:	2200      	movs	r2, #0
 8001d26:	819a      	strh	r2, [r3, #12]
			obj->IdSampAngleFlag = false;
 8001d28:	68fb      	ldr	r3, [r7, #12]
 8001d2a:	2200      	movs	r2, #0
 8001d2c:	835a      	strh	r2, [r3, #26]
	else
	{
		obj->VolVecAngleFlag = false;
		obj->IdSampAngleFlag = false;
	}
	return;
 8001d2e:	e006      	b.n	8001d3e <INITPOSDET_VolVecAngleRun+0x136>
			obj->IdSampAngleFlag = false;
		}
	}
	else
	{
		obj->VolVecAngleFlag = false;
 8001d30:	68fb      	ldr	r3, [r7, #12]
 8001d32:	2200      	movs	r2, #0
 8001d34:	819a      	strh	r2, [r3, #12]
		obj->IdSampAngleFlag = false;
 8001d36:	68fb      	ldr	r3, [r7, #12]
 8001d38:	2200      	movs	r2, #0
 8001d3a:	835a      	strh	r2, [r3, #26]
	}
	return;
 8001d3c:	bf00      	nop
}
 8001d3e:	3714      	adds	r7, #20
 8001d40:	46bd      	mov	sp, r7
 8001d42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d46:	4770      	bx	lr

08001d48 <MATH_sat>:
//! \param[in] in   The input value
//! \param[in] max  The maximum value allowed
//! \param[in] min  The minimum value allowed
//! \return    The saturated value
static inline float_t MATH_sat(const float_t in,const float_t max,const float_t min)
{
 8001d48:	b480      	push	{r7}
 8001d4a:	b087      	sub	sp, #28
 8001d4c:	af00      	add	r7, sp, #0
 8001d4e:	ed87 0a03 	vstr	s0, [r7, #12]
 8001d52:	edc7 0a02 	vstr	s1, [r7, #8]
 8001d56:	ed87 1a01 	vstr	s2, [r7, #4]
  float_t out = in;
 8001d5a:	68fb      	ldr	r3, [r7, #12]
 8001d5c:	617b      	str	r3, [r7, #20]


  if(in < min)
 8001d5e:	ed97 7a03 	vldr	s14, [r7, #12]
 8001d62:	edd7 7a01 	vldr	s15, [r7, #4]
 8001d66:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8001d6a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001d6e:	d502      	bpl.n	8001d76 <MATH_sat+0x2e>
    {
      out = min;
 8001d70:	687b      	ldr	r3, [r7, #4]
 8001d72:	617b      	str	r3, [r7, #20]
 8001d74:	e00a      	b.n	8001d8c <MATH_sat+0x44>
    }
  else if(in > max)
 8001d76:	ed97 7a03 	vldr	s14, [r7, #12]
 8001d7a:	edd7 7a02 	vldr	s15, [r7, #8]
 8001d7e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8001d82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001d86:	dd01      	ble.n	8001d8c <MATH_sat+0x44>
    {
      out = max;
 8001d88:	68bb      	ldr	r3, [r7, #8]
 8001d8a:	617b      	str	r3, [r7, #20]
    }

  return(out);
 8001d8c:	697b      	ldr	r3, [r7, #20]
 8001d8e:	ee07 3a90 	vmov	s15, r3
} // end of MATH_sat() function
 8001d92:	eeb0 0a67 	vmov.f32	s0, s15
 8001d96:	371c      	adds	r7, #28
 8001d98:	46bd      	mov	sp, r7
 8001d9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d9e:	4770      	bx	lr

08001da0 <OFFSET_getOffset>:

//! \brief     Gets the offset value
//! \param[in] handle  The offset handle
//! \return    The offset value
static inline float_t OFFSET_getOffset(OFFSET_Handle handle)
{
 8001da0:	b480      	push	{r7}
 8001da2:	b085      	sub	sp, #20
 8001da4:	af00      	add	r7, sp, #0
 8001da6:	6078      	str	r0, [r7, #4]
	OFFSET_Obj *obj = (OFFSET_Obj *)handle;
 8001da8:	687b      	ldr	r3, [r7, #4]
 8001daa:	60fb      	str	r3, [r7, #12]

	return(obj->value);
 8001dac:	68fb      	ldr	r3, [r7, #12]
 8001dae:	681b      	ldr	r3, [r3, #0]
 8001db0:	ee07 3a90 	vmov	s15, r3
} // end of OFFSET_getOffset() function
 8001db4:	eeb0 0a67 	vmov.f32	s0, s15
 8001db8:	3714      	adds	r7, #20
 8001dba:	46bd      	mov	sp, r7
 8001dbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001dc0:	4770      	bx	lr
 8001dc2:	bf00      	nop

08001dc4 <PID_setFbackValue>:

//! \brief     Sets the feedback value in the PID controller
//! \param[in] handle      The PID controller handle
//! \param[in] fbackValue  The feedback value
static inline void PID_setFbackValue(PID_Handle handle,const float_t fbackValue)//! \Mod By Dl.K
{
 8001dc4:	b480      	push	{r7}
 8001dc6:	b085      	sub	sp, #20
 8001dc8:	af00      	add	r7, sp, #0
 8001dca:	6078      	str	r0, [r7, #4]
 8001dcc:	ed87 0a00 	vstr	s0, [r7]
  PID_Obj *obj = (PID_Obj *)handle;
 8001dd0:	687b      	ldr	r3, [r7, #4]
 8001dd2:	60fb      	str	r3, [r7, #12]

  obj->fbackValue = fbackValue;
 8001dd4:	68fb      	ldr	r3, [r7, #12]
 8001dd6:	683a      	ldr	r2, [r7, #0]
 8001dd8:	615a      	str	r2, [r3, #20]

  return;
 8001dda:	bf00      	nop
} // end of PID_setFbackValue() function
 8001ddc:	3714      	adds	r7, #20
 8001dde:	46bd      	mov	sp, r7
 8001de0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001de4:	4770      	bx	lr
 8001de6:	bf00      	nop

08001de8 <PID_setRefValue>:

//! \brief     Sets the reference value in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] refValue   The reference value
static inline void PID_setRefValue(PID_Handle handle,const float_t refValue)//! \Mod By Dl.K
{
 8001de8:	b480      	push	{r7}
 8001dea:	b085      	sub	sp, #20
 8001dec:	af00      	add	r7, sp, #0
 8001dee:	6078      	str	r0, [r7, #4]
 8001df0:	ed87 0a00 	vstr	s0, [r7]
  PID_Obj *obj = (PID_Obj *)handle;
 8001df4:	687b      	ldr	r3, [r7, #4]
 8001df6:	60fb      	str	r3, [r7, #12]

  obj->refValue = refValue;
 8001df8:	68fb      	ldr	r3, [r7, #12]
 8001dfa:	683a      	ldr	r2, [r7, #0]
 8001dfc:	611a      	str	r2, [r3, #16]

  return;
 8001dfe:	bf00      	nop
} // end of PID_setRefValue() function
 8001e00:	3714      	adds	r7, #20
 8001e02:	46bd      	mov	sp, r7
 8001e04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e08:	4770      	bx	lr
 8001e0a:	bf00      	nop

08001e0c <PID_setUi>:

//! \brief     Sets the integrator start value in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] Ui         The integral start value for the PID controller
static inline void PID_setUi(PID_Handle handle,const float_t Ui)//! \Mod By Dl.K
{
 8001e0c:	b480      	push	{r7}
 8001e0e:	b085      	sub	sp, #20
 8001e10:	af00      	add	r7, sp, #0
 8001e12:	6078      	str	r0, [r7, #4]
 8001e14:	ed87 0a00 	vstr	s0, [r7]
  PID_Obj *obj = (PID_Obj *)handle;
 8001e18:	687b      	ldr	r3, [r7, #4]
 8001e1a:	60fb      	str	r3, [r7, #12]

  obj->Ui = Ui;
 8001e1c:	68fb      	ldr	r3, [r7, #12]
 8001e1e:	683a      	ldr	r2, [r7, #0]
 8001e20:	60da      	str	r2, [r3, #12]

  return;
 8001e22:	bf00      	nop
} // end of PID_setUi() function
 8001e24:	3714      	adds	r7, #20
 8001e26:	46bd      	mov	sp, r7
 8001e28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e2c:	4770      	bx	lr
 8001e2e:	bf00      	nop

08001e30 <RMP_CNTL_InitPara>:

	return (obj->SetpointValue);
}

static inline void RMP_CNTL_InitPara(RMPCNTL_Handle handle)//! \Mod By Dl.K
{
 8001e30:	b480      	push	{r7}
 8001e32:	b085      	sub	sp, #20
 8001e34:	af00      	add	r7, sp, #0
 8001e36:	6078      	str	r0, [r7, #4]
	RMPCNTL_Obj *obj = (RMPCNTL_Obj *)handle;
 8001e38:	687b      	ldr	r3, [r7, #4]
 8001e3a:	60fb      	str	r3, [r7, #12]

	obj->RampDelayCount = 0;
 8001e3c:	68fb      	ldr	r3, [r7, #12]
 8001e3e:	2200      	movs	r2, #0
 8001e40:	611a      	str	r2, [r3, #16]
	obj->SetpointValue = (0.0f);
 8001e42:	68fb      	ldr	r3, [r7, #12]
 8001e44:	f04f 0200 	mov.w	r2, #0
 8001e48:	615a      	str	r2, [r3, #20]
	obj->EqualFlag = 0;
 8001e4a:	68fb      	ldr	r3, [r7, #12]
 8001e4c:	2200      	movs	r2, #0
 8001e4e:	619a      	str	r2, [r3, #24]
	
	return ;
 8001e50:	bf00      	nop
}
 8001e52:	3714      	adds	r7, #20
 8001e54:	46bd      	mov	sp, r7
 8001e56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e5a:	4770      	bx	lr

08001e5c <DATA_RXD_Status>:
	
	return;
}

static inline uint8_t DATA_RXD_Status(DATA_RTXD_Handle handle)
{
 8001e5c:	b480      	push	{r7}
 8001e5e:	b085      	sub	sp, #20
 8001e60:	af00      	add	r7, sp, #0
 8001e62:	6078      	str	r0, [r7, #4]
	DATA_RTXD_Obj *obj = (DATA_RTXD_Obj *)handle;
 8001e64:	687b      	ldr	r3, [r7, #4]
 8001e66:	60fb      	str	r3, [r7, #12]

	if( obj->data_rxd_num == DATA_RXD_SIZE )
 8001e68:	68fb      	ldr	r3, [r7, #12]
 8001e6a:	781b      	ldrb	r3, [r3, #0]
 8001e6c:	2b0d      	cmp	r3, #13
 8001e6e:	d101      	bne.n	8001e74 <DATA_RXD_Status+0x18>
	{
		return false;
 8001e70:	2300      	movs	r3, #0
 8001e72:	e000      	b.n	8001e76 <DATA_RXD_Status+0x1a>
	}
	else return true;
 8001e74:	2301      	movs	r3, #1
}
 8001e76:	4618      	mov	r0, r3
 8001e78:	3714      	adds	r7, #20
 8001e7a:	46bd      	mov	sp, r7
 8001e7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e80:	4770      	bx	lr
 8001e82:	bf00      	nop

08001e84 <DATA_TXD_Status>:

static inline uint8_t DATA_TXD_Status(DATA_RTXD_Handle handle)
{
 8001e84:	b480      	push	{r7}
 8001e86:	b085      	sub	sp, #20
 8001e88:	af00      	add	r7, sp, #0
 8001e8a:	6078      	str	r0, [r7, #4]
	DATA_RTXD_Obj *obj = (DATA_RTXD_Obj *)handle;
 8001e8c:	687b      	ldr	r3, [r7, #4]
 8001e8e:	60fb      	str	r3, [r7, #12]

	if( obj->data_txd_num == DATA_TXD_SIZE )
 8001e90:	68fb      	ldr	r3, [r7, #12]
 8001e92:	7b9b      	ldrb	r3, [r3, #14]
 8001e94:	2b0d      	cmp	r3, #13
 8001e96:	d101      	bne.n	8001e9c <DATA_TXD_Status+0x18>
	{
		return false;
 8001e98:	2300      	movs	r3, #0
 8001e9a:	e000      	b.n	8001e9e <DATA_TXD_Status+0x1a>
	}
	else return true;
 8001e9c:	2301      	movs	r3, #1
}
 8001e9e:	4618      	mov	r0, r3
 8001ea0:	3714      	adds	r7, #20
 8001ea2:	46bd      	mov	sp, r7
 8001ea4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001ea8:	4770      	bx	lr
 8001eaa:	bf00      	nop

08001eac <DATA_RXD_Run>:

static inline void DATA_RXD_Run(DATA_RTXD_Handle handle, uint8_t value)
{
 8001eac:	b480      	push	{r7}
 8001eae:	b085      	sub	sp, #20
 8001eb0:	af00      	add	r7, sp, #0
 8001eb2:	6078      	str	r0, [r7, #4]
 8001eb4:	460b      	mov	r3, r1
 8001eb6:	70fb      	strb	r3, [r7, #3]
	DATA_RTXD_Obj *obj = (DATA_RTXD_Obj *)handle;
 8001eb8:	687b      	ldr	r3, [r7, #4]
 8001eba:	60fb      	str	r3, [r7, #12]

	if( obj->data_rxd_num < DATA_RXD_SIZE )
 8001ebc:	68fb      	ldr	r3, [r7, #12]
 8001ebe:	781b      	ldrb	r3, [r3, #0]
 8001ec0:	2b0c      	cmp	r3, #12
 8001ec2:	d80c      	bhi.n	8001ede <DATA_RXD_Run+0x32>
	{
		obj->data_rxd[obj->data_rxd_num] =  value;
 8001ec4:	68fb      	ldr	r3, [r7, #12]
 8001ec6:	781b      	ldrb	r3, [r3, #0]
 8001ec8:	461a      	mov	r2, r3
 8001eca:	68fb      	ldr	r3, [r7, #12]
 8001ecc:	4413      	add	r3, r2
 8001ece:	78fa      	ldrb	r2, [r7, #3]
 8001ed0:	705a      	strb	r2, [r3, #1]
		obj->data_rxd_num++;
 8001ed2:	68fb      	ldr	r3, [r7, #12]
 8001ed4:	781b      	ldrb	r3, [r3, #0]
 8001ed6:	3301      	adds	r3, #1
 8001ed8:	b2da      	uxtb	r2, r3
 8001eda:	68fb      	ldr	r3, [r7, #12]
 8001edc:	701a      	strb	r2, [r3, #0]
	}
	//else obj->data_rxd_num = 0;
	return;
 8001ede:	bf00      	nop
}
 8001ee0:	3714      	adds	r7, #20
 8001ee2:	46bd      	mov	sp, r7
 8001ee4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001ee8:	4770      	bx	lr
 8001eea:	bf00      	nop

08001eec <Get_DATA_TXD_Ptr>:

	return value;
}

static inline uint8_t* Get_DATA_TXD_Ptr(DATA_RTXD_Handle handle)
{
 8001eec:	b480      	push	{r7}
 8001eee:	b085      	sub	sp, #20
 8001ef0:	af00      	add	r7, sp, #0
 8001ef2:	6078      	str	r0, [r7, #4]
	DATA_RTXD_Obj *obj = (DATA_RTXD_Obj *)handle;
 8001ef4:	687b      	ldr	r3, [r7, #4]
 8001ef6:	60fb      	str	r3, [r7, #12]
	
	obj->data_txd_num = DATA_TXD_SIZE;
 8001ef8:	68fb      	ldr	r3, [r7, #12]
 8001efa:	220d      	movs	r2, #13
 8001efc:	739a      	strb	r2, [r3, #14]

	return obj->data_txd;
 8001efe:	68fb      	ldr	r3, [r7, #12]
 8001f00:	330f      	adds	r3, #15
}
 8001f02:	4618      	mov	r0, r3
 8001f04:	3714      	adds	r7, #20
 8001f06:	46bd      	mov	sp, r7
 8001f08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f0c:	4770      	bx	lr
 8001f0e:	bf00      	nop

08001f10 <HAL_getBias>:
//! \param[in]  sensorNumber  The sensor number
//! \return     The ADC bias value
static inline float_t HAL_getBias(HAL_Handle handle,
                              const HAL_SensorType_e sensorType,
                              uint_least8_t sensorNumber)//! \Mod By Dl.K
{
 8001f10:	b480      	push	{r7}
 8001f12:	b085      	sub	sp, #20
 8001f14:	af00      	add	r7, sp, #0
 8001f16:	6078      	str	r0, [r7, #4]
 8001f18:	460b      	mov	r3, r1
 8001f1a:	70fb      	strb	r3, [r7, #3]
 8001f1c:	4613      	mov	r3, r2
 8001f1e:	70bb      	strb	r3, [r7, #2]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8001f20:	687b      	ldr	r3, [r7, #4]
 8001f22:	60bb      	str	r3, [r7, #8]
//  _iq bias = _IQ(0.0);
  float_t bias = (0.0);//! \Mod By Dl.K
 8001f24:	f04f 0300 	mov.w	r3, #0
 8001f28:	60fb      	str	r3, [r7, #12]
	
  if(sensorType == HAL_SensorType_Current)
 8001f2a:	78fb      	ldrb	r3, [r7, #3]
 8001f2c:	2b00      	cmp	r3, #0
 8001f2e:	d107      	bne.n	8001f40 <HAL_getBias+0x30>
    {
      bias = obj->adcBias.I.value[sensorNumber];
 8001f30:	78bb      	ldrb	r3, [r7, #2]
 8001f32:	68ba      	ldr	r2, [r7, #8]
 8001f34:	3336      	adds	r3, #54	; 0x36
 8001f36:	009b      	lsls	r3, r3, #2
 8001f38:	4413      	add	r3, r2
 8001f3a:	681b      	ldr	r3, [r3, #0]
 8001f3c:	60fb      	str	r3, [r7, #12]
 8001f3e:	e009      	b.n	8001f54 <HAL_getBias+0x44>
    }
  else if(sensorType == HAL_SensorType_Voltage)
 8001f40:	78fb      	ldrb	r3, [r7, #3]
 8001f42:	2b01      	cmp	r3, #1
 8001f44:	d106      	bne.n	8001f54 <HAL_getBias+0x44>
    {
      bias = obj->adcBias.V.value[sensorNumber];
 8001f46:	78bb      	ldrb	r3, [r7, #2]
 8001f48:	68ba      	ldr	r2, [r7, #8]
 8001f4a:	3338      	adds	r3, #56	; 0x38
 8001f4c:	009b      	lsls	r3, r3, #2
 8001f4e:	4413      	add	r3, r2
 8001f50:	685b      	ldr	r3, [r3, #4]
 8001f52:	60fb      	str	r3, [r7, #12]
    }

  return(bias);
 8001f54:	68fb      	ldr	r3, [r7, #12]
 8001f56:	ee07 3a90 	vmov	s15, r3
} // end of HAL_getBias() function
 8001f5a:	eeb0 0a67 	vmov.f32	s0, s15
 8001f5e:	3714      	adds	r7, #20
 8001f60:	46bd      	mov	sp, r7
 8001f62:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f66:	4770      	bx	lr

08001f68 <HAL_getCurrentScaleFactor>:
//!             This scale factor is not used when converting between PU amps
//!             and real amps.
//! \param[in]  handle  The hardware abstraction layer (HAL) handle
//! \return     The current scale factor
static inline float_t HAL_getCurrentScaleFactor(HAL_Handle handle)//! \Mod By Dl.K
{
 8001f68:	b480      	push	{r7}
 8001f6a:	b085      	sub	sp, #20
 8001f6c:	af00      	add	r7, sp, #0
 8001f6e:	6078      	str	r0, [r7, #4]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8001f70:	687b      	ldr	r3, [r7, #4]
 8001f72:	60fb      	str	r3, [r7, #12]

  return(obj->current_sf);
 8001f74:	68fb      	ldr	r3, [r7, #12]
 8001f76:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 8001f7a:	ee07 3a90 	vmov	s15, r3
} // end of HAL_getCurrentScaleFactor() function
 8001f7e:	eeb0 0a67 	vmov.f32	s0, s15
 8001f82:	3714      	adds	r7, #20
 8001f84:	46bd      	mov	sp, r7
 8001f86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f8a:	4770      	bx	lr

08001f8c <HAL_getNumCurrentSensors>:

//! \brief     Gets the number of current sensors
//! \param[in] handle  The hardware abstraction layer (HAL) handle
//! \return    The number of current sensors
static inline uint_least8_t HAL_getNumCurrentSensors(HAL_Handle handle)
{
 8001f8c:	b480      	push	{r7}
 8001f8e:	b085      	sub	sp, #20
 8001f90:	af00      	add	r7, sp, #0
 8001f92:	6078      	str	r0, [r7, #4]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8001f94:	687b      	ldr	r3, [r7, #4]
 8001f96:	60fb      	str	r3, [r7, #12]
  

  return(obj->numCurrentSensors);
 8001f98:	68fb      	ldr	r3, [r7, #12]
 8001f9a:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
} // end of HAL_getNumCurrentSensors() function
 8001f9e:	4618      	mov	r0, r3
 8001fa0:	3714      	adds	r7, #20
 8001fa2:	46bd      	mov	sp, r7
 8001fa4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001fa8:	4770      	bx	lr
 8001faa:	bf00      	nop

08001fac <HAL_getNumVoltageSensors>:

//! \brief     Gets the number of voltage sensors
//! \param[in] handle  The hardware abstraction layer (HAL) handle
//! \return    The number of voltage sensors
static inline uint_least8_t HAL_getNumVoltageSensors(HAL_Handle handle)
{
 8001fac:	b480      	push	{r7}
 8001fae:	b085      	sub	sp, #20
 8001fb0:	af00      	add	r7, sp, #0
 8001fb2:	6078      	str	r0, [r7, #4]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8001fb4:	687b      	ldr	r3, [r7, #4]
 8001fb6:	60fb      	str	r3, [r7, #12]
  

  return(obj->numVoltageSensors);
 8001fb8:	68fb      	ldr	r3, [r7, #12]
 8001fba:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
} // end of HAL_getNumVoltageSensors() function
 8001fbe:	4618      	mov	r0, r3
 8001fc0:	3714      	adds	r7, #20
 8001fc2:	46bd      	mov	sp, r7
 8001fc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001fc8:	4770      	bx	lr
 8001fca:	bf00      	nop

08001fcc <HAL_getVoltageScaleFactor>:
//!             This scale factor is not used when converting between PU volts
//!             and real volts.
//! \param[in]  handle  The hardware abstraction layer (HAL) handle
//! \return     The voltage scale factor
static inline float_t HAL_getVoltageScaleFactor(HAL_Handle handle)//! \Mod By Dl.K
{
 8001fcc:	b480      	push	{r7}
 8001fce:	b085      	sub	sp, #20
 8001fd0:	af00      	add	r7, sp, #0
 8001fd2:	6078      	str	r0, [r7, #4]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8001fd4:	687b      	ldr	r3, [r7, #4]
 8001fd6:	60fb      	str	r3, [r7, #12]

  return(obj->voltage_sf);
 8001fd8:	68fb      	ldr	r3, [r7, #12]
 8001fda:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 8001fde:	ee07 3a90 	vmov	s15, r3
} // end of HAL_getVoltageScaleFactor() function
 8001fe2:	eeb0 0a67 	vmov.f32	s0, s15
 8001fe6:	3714      	adds	r7, #20
 8001fe8:	46bd      	mov	sp, r7
 8001fea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001fee:	4770      	bx	lr

08001ff0 <HAL_readAdcData>:
//!             structure gAdcData holds three phase voltages, three line
//!             currents, and one DC bus voltage.
//! \param[in]  handle    The hardware abstraction layer (HAL) handle
//! \param[in]  pAdcData  A pointer to the ADC data buffer
static inline void HAL_readAdcData(HAL_Handle handle,HAL_AdcData_t *pAdcData)
{
 8001ff0:	b580      	push	{r7, lr}
 8001ff2:	b086      	sub	sp, #24
 8001ff4:	af00      	add	r7, sp, #0
 8001ff6:	6078      	str	r0, [r7, #4]
 8001ff8:	6039      	str	r1, [r7, #0]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8001ffa:	687b      	ldr	r3, [r7, #4]
 8001ffc:	617b      	str	r3, [r7, #20]

  float_t value;
  float_t current_sf = HAL_getCurrentScaleFactor(handle);
 8001ffe:	6878      	ldr	r0, [r7, #4]
 8002000:	f7ff ffb2 	bl	8001f68 <HAL_getCurrentScaleFactor>
 8002004:	ed87 0a04 	vstr	s0, [r7, #16]
  float_t voltage_sf = HAL_getVoltageScaleFactor(handle);
 8002008:	6878      	ldr	r0, [r7, #4]
 800200a:	f7ff ffdf 	bl	8001fcc <HAL_getVoltageScaleFactor>
 800200e:	ed87 0a03 	vstr	s0, [r7, #12]
	//! \Mod By Dl.K

  // convert current A
  // sample the first sample twice due to errata sprz342f, ignore the first sample
	value = pAdcData->I.value[0] * AD_CONV_RATIO;
 8002012:	683b      	ldr	r3, [r7, #0]
 8002014:	edd3 7a00 	vldr	s15, [r3]
 8002018:	ed9f 7a63 	vldr	s14, [pc, #396]	; 80021a8 <HAL_readAdcData+0x1b8>
 800201c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8002020:	edc7 7a02 	vstr	s15, [r7, #8]
  value = (value*current_sf) - obj->adcBias.I.value[0];      // divide by 2^numAdcBits = 2^12
 8002024:	ed97 7a02 	vldr	s14, [r7, #8]
 8002028:	edd7 7a04 	vldr	s15, [r7, #16]
 800202c:	ee27 7a27 	vmul.f32	s14, s14, s15
 8002030:	697b      	ldr	r3, [r7, #20]
 8002032:	edd3 7a36 	vldr	s15, [r3, #216]	; 0xd8
 8002036:	ee77 7a67 	vsub.f32	s15, s14, s15
 800203a:	edc7 7a02 	vstr	s15, [r7, #8]
  pAdcData->I.value[0] = value;//! \Mod By Dl.K Del'-'
 800203e:	683b      	ldr	r3, [r7, #0]
 8002040:	68ba      	ldr	r2, [r7, #8]
 8002042:	601a      	str	r2, [r3, #0]

  // convert current B
	value = pAdcData->I.value[1] * AD_CONV_RATIO;
 8002044:	683b      	ldr	r3, [r7, #0]
 8002046:	edd3 7a01 	vldr	s15, [r3, #4]
 800204a:	ed9f 7a57 	vldr	s14, [pc, #348]	; 80021a8 <HAL_readAdcData+0x1b8>
 800204e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8002052:	edc7 7a02 	vstr	s15, [r7, #8]
  value = (value*current_sf) - obj->adcBias.I.value[1];      // divide by 2^numAdcBits = 2^12
 8002056:	ed97 7a02 	vldr	s14, [r7, #8]
 800205a:	edd7 7a04 	vldr	s15, [r7, #16]
 800205e:	ee27 7a27 	vmul.f32	s14, s14, s15
 8002062:	697b      	ldr	r3, [r7, #20]
 8002064:	edd3 7a37 	vldr	s15, [r3, #220]	; 0xdc
 8002068:	ee77 7a67 	vsub.f32	s15, s14, s15
 800206c:	edc7 7a02 	vstr	s15, [r7, #8]
  pAdcData->I.value[1] = value;//! \Mod By Dl.K Del'-'
 8002070:	683b      	ldr	r3, [r7, #0]
 8002072:	68ba      	ldr	r2, [r7, #8]
 8002074:	605a      	str	r2, [r3, #4]

  // convert current C
	value = pAdcData->I.value[2] * AD_CONV_RATIO;
 8002076:	683b      	ldr	r3, [r7, #0]
 8002078:	edd3 7a02 	vldr	s15, [r3, #8]
 800207c:	ed9f 7a4a 	vldr	s14, [pc, #296]	; 80021a8 <HAL_readAdcData+0x1b8>
 8002080:	ee67 7a87 	vmul.f32	s15, s15, s14
 8002084:	edc7 7a02 	vstr	s15, [r7, #8]
  value = (value*current_sf) - obj->adcBias.I.value[2];      // divide by 2^numAdcBits = 2^12
 8002088:	ed97 7a02 	vldr	s14, [r7, #8]
 800208c:	edd7 7a04 	vldr	s15, [r7, #16]
 8002090:	ee27 7a27 	vmul.f32	s14, s14, s15
 8002094:	697b      	ldr	r3, [r7, #20]
 8002096:	edd3 7a38 	vldr	s15, [r3, #224]	; 0xe0
 800209a:	ee77 7a67 	vsub.f32	s15, s14, s15
 800209e:	edc7 7a02 	vstr	s15, [r7, #8]
  pAdcData->I.value[2] = value;//! \Mod By Dl.K Del'-'
 80020a2:	683b      	ldr	r3, [r7, #0]
 80020a4:	68ba      	ldr	r2, [r7, #8]
 80020a6:	609a      	str	r2, [r3, #8]

  // convert voltage A
	value = pAdcData->V.value[0] * AD_CONV_RATIO;
 80020a8:	683b      	ldr	r3, [r7, #0]
 80020aa:	edd3 7a03 	vldr	s15, [r3, #12]
 80020ae:	ed9f 7a3e 	vldr	s14, [pc, #248]	; 80021a8 <HAL_readAdcData+0x1b8>
 80020b2:	ee67 7a87 	vmul.f32	s15, s15, s14
 80020b6:	edc7 7a02 	vstr	s15, [r7, #8]
  value = (value*voltage_sf) - obj->adcBias.V.value[0];      // divide by 2^numAdcBits = 2^12
 80020ba:	ed97 7a02 	vldr	s14, [r7, #8]
 80020be:	edd7 7a03 	vldr	s15, [r7, #12]
 80020c2:	ee27 7a27 	vmul.f32	s14, s14, s15
 80020c6:	697b      	ldr	r3, [r7, #20]
 80020c8:	edd3 7a39 	vldr	s15, [r3, #228]	; 0xe4
 80020cc:	ee77 7a67 	vsub.f32	s15, s14, s15
 80020d0:	edc7 7a02 	vstr	s15, [r7, #8]
  pAdcData->V.value[0] = value;
 80020d4:	683b      	ldr	r3, [r7, #0]
 80020d6:	68ba      	ldr	r2, [r7, #8]
 80020d8:	60da      	str	r2, [r3, #12]

  // convert voltage B
	value = pAdcData->V.value[1] * AD_CONV_RATIO;
 80020da:	683b      	ldr	r3, [r7, #0]
 80020dc:	edd3 7a04 	vldr	s15, [r3, #16]
 80020e0:	ed9f 7a31 	vldr	s14, [pc, #196]	; 80021a8 <HAL_readAdcData+0x1b8>
 80020e4:	ee67 7a87 	vmul.f32	s15, s15, s14
 80020e8:	edc7 7a02 	vstr	s15, [r7, #8]
  value = (value*voltage_sf) - obj->adcBias.V.value[1];      // divide by 2^numAdcBits = 2^12
 80020ec:	ed97 7a02 	vldr	s14, [r7, #8]
 80020f0:	edd7 7a03 	vldr	s15, [r7, #12]
 80020f4:	ee27 7a27 	vmul.f32	s14, s14, s15
 80020f8:	697b      	ldr	r3, [r7, #20]
 80020fa:	edd3 7a3a 	vldr	s15, [r3, #232]	; 0xe8
 80020fe:	ee77 7a67 	vsub.f32	s15, s14, s15
 8002102:	edc7 7a02 	vstr	s15, [r7, #8]
  pAdcData->V.value[1] = value;
 8002106:	683b      	ldr	r3, [r7, #0]
 8002108:	68ba      	ldr	r2, [r7, #8]
 800210a:	611a      	str	r2, [r3, #16]

  // convert voltage C
	value = pAdcData->I.value[2] * AD_CONV_RATIO;
 800210c:	683b      	ldr	r3, [r7, #0]
 800210e:	edd3 7a02 	vldr	s15, [r3, #8]
 8002112:	ed9f 7a25 	vldr	s14, [pc, #148]	; 80021a8 <HAL_readAdcData+0x1b8>
 8002116:	ee67 7a87 	vmul.f32	s15, s15, s14
 800211a:	edc7 7a02 	vstr	s15, [r7, #8]
  value = (value*voltage_sf) - obj->adcBias.V.value[2];      // divide by 2^numAdcBits = 2^12
 800211e:	ed97 7a02 	vldr	s14, [r7, #8]
 8002122:	edd7 7a03 	vldr	s15, [r7, #12]
 8002126:	ee27 7a27 	vmul.f32	s14, s14, s15
 800212a:	697b      	ldr	r3, [r7, #20]
 800212c:	edd3 7a3b 	vldr	s15, [r3, #236]	; 0xec
 8002130:	ee77 7a67 	vsub.f32	s15, s14, s15
 8002134:	edc7 7a02 	vstr	s15, [r7, #8]
  pAdcData->V.value[2] = value;
 8002138:	683b      	ldr	r3, [r7, #0]
 800213a:	68ba      	ldr	r2, [r7, #8]
 800213c:	615a      	str	r2, [r3, #20]

  // read the dcBus voltage value //! \Mod By Dl.K
	value = pAdcData->VdcBus * AD_CONV_RATIO;
 800213e:	683b      	ldr	r3, [r7, #0]
 8002140:	edd3 7a06 	vldr	s15, [r3, #24]
 8002144:	ed9f 7a18 	vldr	s14, [pc, #96]	; 80021a8 <HAL_readAdcData+0x1b8>
 8002148:	ee67 7a87 	vmul.f32	s15, s15, s14
 800214c:	edc7 7a02 	vstr	s15, [r7, #8]
  value = (value*voltage_sf) - (V_DC_offset)*USER_VOLTAGE_SF;
 8002150:	ed97 7a02 	vldr	s14, [r7, #8]
 8002154:	edd7 7a03 	vldr	s15, [r7, #12]
 8002158:	ee67 7a27 	vmul.f32	s15, s14, s15
 800215c:	ed9f 7a13 	vldr	s14, [pc, #76]	; 80021ac <HAL_readAdcData+0x1bc>
 8002160:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8002164:	edc7 7a02 	vstr	s15, [r7, #8]
  pAdcData->VdcBus = value;
 8002168:	683b      	ldr	r3, [r7, #0]
 800216a:	68ba      	ldr	r2, [r7, #8]
 800216c:	619a      	str	r2, [r3, #24]

  // read the dcBus current value //! \Mod By Dl.K
	value = pAdcData->IdcBus * AD_CONV_RATIO;
 800216e:	683b      	ldr	r3, [r7, #0]
 8002170:	edd3 7a07 	vldr	s15, [r3, #28]
 8002174:	ed9f 7a0c 	vldr	s14, [pc, #48]	; 80021a8 <HAL_readAdcData+0x1b8>
 8002178:	ee67 7a87 	vmul.f32	s15, s15, s14
 800217c:	edc7 7a02 	vstr	s15, [r7, #8]
  value = (value*current_sf) - (I_DC_offset)*USER_CURRENT_SF;
 8002180:	ed97 7a02 	vldr	s14, [r7, #8]
 8002184:	edd7 7a04 	vldr	s15, [r7, #16]
 8002188:	ee67 7a27 	vmul.f32	s15, s14, s15
 800218c:	ed9f 7a08 	vldr	s14, [pc, #32]	; 80021b0 <HAL_readAdcData+0x1c0>
 8002190:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8002194:	edc7 7a02 	vstr	s15, [r7, #8]
  pAdcData->IdcBus = value;
 8002198:	683b      	ldr	r3, [r7, #0]
 800219a:	68ba      	ldr	r2, [r7, #8]
 800219c:	61da      	str	r2, [r3, #28]

  return;
 800219e:	bf00      	nop
} // end of HAL_readAdcData() function
 80021a0:	3718      	adds	r7, #24
 80021a2:	46bd      	mov	sp, r7
 80021a4:	bd80      	pop	{r7, pc}
 80021a6:	bf00      	nop
 80021a8:	39800000 	.word	0x39800000
 80021ac:	3f05f57f 	.word	0x3f05f57f
 80021b0:	3f47fff2 	.word	0x3f47fff2

080021b4 <HAL_setBias>:
//! \param[in] bias          The ADC bias value
static inline void HAL_setBias(HAL_Handle handle,
                               const HAL_SensorType_e sensorType,
                               uint_least8_t sensorNumber,
                               const float_t bias)//! \Mod By Dl.K
{
 80021b4:	b480      	push	{r7}
 80021b6:	b087      	sub	sp, #28
 80021b8:	af00      	add	r7, sp, #0
 80021ba:	60f8      	str	r0, [r7, #12]
 80021bc:	460b      	mov	r3, r1
 80021be:	ed87 0a01 	vstr	s0, [r7, #4]
 80021c2:	72fb      	strb	r3, [r7, #11]
 80021c4:	4613      	mov	r3, r2
 80021c6:	72bb      	strb	r3, [r7, #10]
  HAL_Obj *obj = (HAL_Obj *)handle;
 80021c8:	68fb      	ldr	r3, [r7, #12]
 80021ca:	617b      	str	r3, [r7, #20]


  if(sensorType == HAL_SensorType_Current)
 80021cc:	7afb      	ldrb	r3, [r7, #11]
 80021ce:	2b00      	cmp	r3, #0
 80021d0:	d107      	bne.n	80021e2 <HAL_setBias+0x2e>
    {
      obj->adcBias.I.value[sensorNumber] = bias;
 80021d2:	7abb      	ldrb	r3, [r7, #10]
 80021d4:	697a      	ldr	r2, [r7, #20]
 80021d6:	3336      	adds	r3, #54	; 0x36
 80021d8:	009b      	lsls	r3, r3, #2
 80021da:	4413      	add	r3, r2
 80021dc:	687a      	ldr	r2, [r7, #4]
 80021de:	601a      	str	r2, [r3, #0]
 80021e0:	e009      	b.n	80021f6 <HAL_setBias+0x42>
    }
  else if(sensorType == HAL_SensorType_Voltage)
 80021e2:	7afb      	ldrb	r3, [r7, #11]
 80021e4:	2b01      	cmp	r3, #1
 80021e6:	d106      	bne.n	80021f6 <HAL_setBias+0x42>
    {
      obj->adcBias.V.value[sensorNumber] = bias;
 80021e8:	7abb      	ldrb	r3, [r7, #10]
 80021ea:	697a      	ldr	r2, [r7, #20]
 80021ec:	3338      	adds	r3, #56	; 0x38
 80021ee:	009b      	lsls	r3, r3, #2
 80021f0:	4413      	add	r3, r2
 80021f2:	687a      	ldr	r2, [r7, #4]
 80021f4:	605a      	str	r2, [r3, #4]
    }

  return;
 80021f6:	bf00      	nop
} // end of HAL_setBias() function
 80021f8:	371c      	adds	r7, #28
 80021fa:	46bd      	mov	sp, r7
 80021fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002200:	4770      	bx	lr
 8002202:	bf00      	nop

08002204 <HAL_updateAdcBias>:
//! \brief      Updates the ADC bias values
//! \details    This function is called before the motor is started.  It sets the voltage
//!             and current measurement offsets.
//! \param[in]  handle  The hardware abstraction layer (HAL) handle
static inline void HAL_updateAdcBias(HAL_Handle handle)
{
 8002204:	b580      	push	{r7, lr}
 8002206:	b086      	sub	sp, #24
 8002208:	af00      	add	r7, sp, #0
 800220a:	6078      	str	r0, [r7, #4]
  uint_least8_t cnt;
  HAL_Obj *obj = (HAL_Obj *)handle;
 800220c:	687b      	ldr	r3, [r7, #4]
 800220e:	613b      	str	r3, [r7, #16]
  float_t bias;//! \Mod By Dl.K


  // update the current bias
  for(cnt=0;cnt<HAL_getNumCurrentSensors(handle);cnt++)
 8002210:	2300      	movs	r3, #0
 8002212:	75fb      	strb	r3, [r7, #23]
 8002214:	e021      	b.n	800225a <HAL_updateAdcBias+0x56>
    {
      bias = HAL_getBias(handle,HAL_SensorType_Current,cnt);
 8002216:	7dfb      	ldrb	r3, [r7, #23]
 8002218:	6878      	ldr	r0, [r7, #4]
 800221a:	2100      	movs	r1, #0
 800221c:	461a      	mov	r2, r3
 800221e:	f7ff fe77 	bl	8001f10 <HAL_getBias>
 8002222:	ed87 0a03 	vstr	s0, [r7, #12]
      
      bias += OFFSET_getOffset(obj->offsetHandle_I[cnt]);//! \Mod By Dl.K Very Important: bias -= to bias +=
 8002226:	7dfa      	ldrb	r2, [r7, #23]
 8002228:	693b      	ldr	r3, [r7, #16]
 800222a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800222e:	4618      	mov	r0, r3
 8002230:	f7ff fdb6 	bl	8001da0 <OFFSET_getOffset>
 8002234:	eeb0 7a40 	vmov.f32	s14, s0
 8002238:	edd7 7a03 	vldr	s15, [r7, #12]
 800223c:	ee77 7a87 	vadd.f32	s15, s15, s14
 8002240:	edc7 7a03 	vstr	s15, [r7, #12]

      HAL_setBias(handle,HAL_SensorType_Current,cnt,bias);
 8002244:	7dfb      	ldrb	r3, [r7, #23]
 8002246:	6878      	ldr	r0, [r7, #4]
 8002248:	2100      	movs	r1, #0
 800224a:	461a      	mov	r2, r3
 800224c:	ed97 0a03 	vldr	s0, [r7, #12]
 8002250:	f7ff ffb0 	bl	80021b4 <HAL_setBias>
  HAL_Obj *obj = (HAL_Obj *)handle;
  float_t bias;//! \Mod By Dl.K


  // update the current bias
  for(cnt=0;cnt<HAL_getNumCurrentSensors(handle);cnt++)
 8002254:	7dfb      	ldrb	r3, [r7, #23]
 8002256:	3301      	adds	r3, #1
 8002258:	75fb      	strb	r3, [r7, #23]
 800225a:	6878      	ldr	r0, [r7, #4]
 800225c:	f7ff fe96 	bl	8001f8c <HAL_getNumCurrentSensors>
 8002260:	4603      	mov	r3, r0
 8002262:	461a      	mov	r2, r3
 8002264:	7dfb      	ldrb	r3, [r7, #23]
 8002266:	4293      	cmp	r3, r2
 8002268:	d3d5      	bcc.n	8002216 <HAL_updateAdcBias+0x12>
      HAL_setBias(handle,HAL_SensorType_Current,cnt,bias);
    }


  // update the voltage bias
  for(cnt=0;cnt<HAL_getNumVoltageSensors(handle);cnt++)
 800226a:	2300      	movs	r3, #0
 800226c:	75fb      	strb	r3, [r7, #23]
 800226e:	e023      	b.n	80022b8 <HAL_updateAdcBias+0xb4>
    {
      bias = HAL_getBias(handle,HAL_SensorType_Voltage,cnt);
 8002270:	7dfb      	ldrb	r3, [r7, #23]
 8002272:	6878      	ldr	r0, [r7, #4]
 8002274:	2101      	movs	r1, #1
 8002276:	461a      	mov	r2, r3
 8002278:	f7ff fe4a 	bl	8001f10 <HAL_getBias>
 800227c:	ed87 0a03 	vstr	s0, [r7, #12]

      bias += OFFSET_getOffset(obj->offsetHandle_V[cnt]);
 8002280:	7dfb      	ldrb	r3, [r7, #23]
 8002282:	693a      	ldr	r2, [r7, #16]
 8002284:	331a      	adds	r3, #26
 8002286:	009b      	lsls	r3, r3, #2
 8002288:	4413      	add	r3, r2
 800228a:	685b      	ldr	r3, [r3, #4]
 800228c:	4618      	mov	r0, r3
 800228e:	f7ff fd87 	bl	8001da0 <OFFSET_getOffset>
 8002292:	eeb0 7a40 	vmov.f32	s14, s0
 8002296:	edd7 7a03 	vldr	s15, [r7, #12]
 800229a:	ee77 7a87 	vadd.f32	s15, s15, s14
 800229e:	edc7 7a03 	vstr	s15, [r7, #12]

      HAL_setBias(handle,HAL_SensorType_Voltage,cnt,bias);
 80022a2:	7dfb      	ldrb	r3, [r7, #23]
 80022a4:	6878      	ldr	r0, [r7, #4]
 80022a6:	2101      	movs	r1, #1
 80022a8:	461a      	mov	r2, r3
 80022aa:	ed97 0a03 	vldr	s0, [r7, #12]
 80022ae:	f7ff ff81 	bl	80021b4 <HAL_setBias>
      HAL_setBias(handle,HAL_SensorType_Current,cnt,bias);
    }


  // update the voltage bias
  for(cnt=0;cnt<HAL_getNumVoltageSensors(handle);cnt++)
 80022b2:	7dfb      	ldrb	r3, [r7, #23]
 80022b4:	3301      	adds	r3, #1
 80022b6:	75fb      	strb	r3, [r7, #23]
 80022b8:	6878      	ldr	r0, [r7, #4]
 80022ba:	f7ff fe77 	bl	8001fac <HAL_getNumVoltageSensors>
 80022be:	4603      	mov	r3, r0
 80022c0:	461a      	mov	r2, r3
 80022c2:	7dfb      	ldrb	r3, [r7, #23]
 80022c4:	4293      	cmp	r3, r2
 80022c6:	d3d3      	bcc.n	8002270 <HAL_updateAdcBias+0x6c>
      bias += OFFSET_getOffset(obj->offsetHandle_V[cnt]);

      HAL_setBias(handle,HAL_SensorType_Voltage,cnt,bias);
    }

  return;
 80022c8:	bf00      	nop
} // end of HAL_updateAdcBias() function
 80022ca:	3718      	adds	r7, #24
 80022cc:	46bd      	mov	sp, r7
 80022ce:	bd80      	pop	{r7, pc}

080022d0 <HAL_writePwmData>:

//! \brief     Writes PWM data to the PWM comparators for motor control
//! \param[in] handle    The hardware abstraction layer (HAL) handle
//! \param[in] pPwmData  The pointer to the PWM data
static inline void HAL_writePwmData(HAL_Handle handle,HAL_PwmData_t *pPwmData)
{
 80022d0:	b580      	push	{r7, lr}
 80022d2:	b086      	sub	sp, #24
 80022d4:	af00      	add	r7, sp, #0
 80022d6:	6078      	str	r0, [r7, #4]
 80022d8:	6039      	str	r1, [r7, #0]
  uint_least8_t cnt;
  float_t pwmData_neg;
  float_t pwmData_sat;
  float_t pwmData_sat_dc;

  for(cnt=0;cnt<3;cnt++)
 80022da:	2300      	movs	r3, #0
 80022dc:	75fb      	strb	r3, [r7, #23]
 80022de:	e024      	b.n	800232a <HAL_writePwmData+0x5a>
    {
      pwmData_neg = (pPwmData->Tabc.value[cnt]*(1.0f));//! \Attention : Dl.K
 80022e0:	7dfb      	ldrb	r3, [r7, #23]
 80022e2:	683a      	ldr	r2, [r7, #0]
 80022e4:	009b      	lsls	r3, r3, #2
 80022e6:	4413      	add	r3, r2
 80022e8:	681b      	ldr	r3, [r3, #0]
 80022ea:	613b      	str	r3, [r7, #16]
      pwmData_sat = MATH_sat(pwmData_neg,(1.0f),(-1.0f));
 80022ec:	ed97 0a04 	vldr	s0, [r7, #16]
 80022f0:	eef7 0a00 	vmov.f32	s1, #112	; 0x70
 80022f4:	eebf 1a00 	vmov.f32	s2, #240	; 0xf0
 80022f8:	f7ff fd26 	bl	8001d48 <MATH_sat>
 80022fc:	ed87 0a03 	vstr	s0, [r7, #12]
      pwmData_sat_dc = ( (pwmData_sat + (1.0f)) * (0.5f) );
 8002300:	edd7 7a03 	vldr	s15, [r7, #12]
 8002304:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8002308:	ee77 7a87 	vadd.f32	s15, s15, s14
 800230c:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 8002310:	ee67 7a87 	vmul.f32	s15, s15, s14
 8002314:	edc7 7a02 	vstr	s15, [r7, #8]
			pPwmData->Tabc.value[cnt] = pwmData_sat_dc;
 8002318:	7dfb      	ldrb	r3, [r7, #23]
 800231a:	683a      	ldr	r2, [r7, #0]
 800231c:	009b      	lsls	r3, r3, #2
 800231e:	4413      	add	r3, r2
 8002320:	68ba      	ldr	r2, [r7, #8]
 8002322:	601a      	str	r2, [r3, #0]
  uint_least8_t cnt;
  float_t pwmData_neg;
  float_t pwmData_sat;
  float_t pwmData_sat_dc;

  for(cnt=0;cnt<3;cnt++)
 8002324:	7dfb      	ldrb	r3, [r7, #23]
 8002326:	3301      	adds	r3, #1
 8002328:	75fb      	strb	r3, [r7, #23]
 800232a:	7dfb      	ldrb	r3, [r7, #23]
 800232c:	2b02      	cmp	r3, #2
 800232e:	d9d7      	bls.n	80022e0 <HAL_writePwmData+0x10>
      pwmData_sat = MATH_sat(pwmData_neg,(1.0f),(-1.0f));
      pwmData_sat_dc = ( (pwmData_sat + (1.0f)) * (0.5f) );
			pPwmData->Tabc.value[cnt] = pwmData_sat_dc;
    }

  return;
 8002330:	bf00      	nop
} // end of HAL_writePwmData() function
 8002332:	3718      	adds	r7, #24
 8002334:	46bd      	mov	sp, r7
 8002336:	bd80      	pop	{r7, pc}

08002338 <CTRL_getState>:

//! \brief     Gets the controller state
//! \param[in] handle  The controller (CTRL) handle
//! \return    The controller state
static inline CTRL_State_e CTRL_getState(CTRL_Handle handle)//! \Mod By Dl.K
{
 8002338:	b480      	push	{r7}
 800233a:	b085      	sub	sp, #20
 800233c:	af00      	add	r7, sp, #0
 800233e:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8002340:	687b      	ldr	r3, [r7, #4]
 8002342:	60fb      	str	r3, [r7, #12]

  return(obj->state);
 8002344:	68fb      	ldr	r3, [r7, #12]
 8002346:	7a1b      	ldrb	r3, [r3, #8]
} // end of CTRL_getState() function
 8002348:	4618      	mov	r0, r3
 800234a:	3714      	adds	r7, #20
 800234c:	46bd      	mov	sp, r7
 800234e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002352:	4770      	bx	lr

08002354 <CTRL_isError>:

//! \brief     Determines if there is a controller error
//! \param[in] handle  The controller (CTRL) handle
//! \return    A boolean value denoting if there is a controller error (true) or not (false)
static inline bool CTRL_isError(CTRL_Handle handle)//! \Mod By Dl.K
{
 8002354:	b580      	push	{r7, lr}
 8002356:	b084      	sub	sp, #16
 8002358:	af00      	add	r7, sp, #0
 800235a:	6078      	str	r0, [r7, #4]
  CTRL_State_e ctrlState = CTRL_getState(handle);
 800235c:	6878      	ldr	r0, [r7, #4]
 800235e:	f7ff ffeb 	bl	8002338 <CTRL_getState>
 8002362:	4603      	mov	r3, r0
 8002364:	73bb      	strb	r3, [r7, #14]
  bool state = false;
 8002366:	2300      	movs	r3, #0
 8002368:	73fb      	strb	r3, [r7, #15]


  // check for controller errors
  if(ctrlState == CTRL_State_Error)
 800236a:	7bbb      	ldrb	r3, [r7, #14]
 800236c:	2b00      	cmp	r3, #0
 800236e:	d101      	bne.n	8002374 <CTRL_isError+0x20>
    {
      state = true;
 8002370:	2301      	movs	r3, #1
 8002372:	73fb      	strb	r3, [r7, #15]
    }

  return(state);
 8002374:	7bfb      	ldrb	r3, [r7, #15]
} // end of CTRL_isError() function
 8002376:	4618      	mov	r0, r3
 8002378:	3710      	adds	r7, #16
 800237a:	46bd      	mov	sp, r7
 800237c:	bd80      	pop	{r7, pc}
 800237e:	bf00      	nop

08002380 <CTRL_setFlag_enableCtrl>:
//!             motor commissioning is performed and then subsequent times it is called the
//!             motor starts to run.
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  state   The desired state
static inline void CTRL_setFlag_enableCtrl(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
 8002380:	b480      	push	{r7}
 8002382:	b085      	sub	sp, #20
 8002384:	af00      	add	r7, sp, #0
 8002386:	6078      	str	r0, [r7, #4]
 8002388:	460b      	mov	r3, r1
 800238a:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 800238c:	687b      	ldr	r3, [r7, #4]
 800238e:	60fb      	str	r3, [r7, #12]

  obj->flag_enableCtrl = state;
 8002390:	68fb      	ldr	r3, [r7, #12]
 8002392:	78fa      	ldrb	r2, [r7, #3]
 8002394:	f883 21f4 	strb.w	r2, [r3, #500]	; 0x1f4

  return;
 8002398:	bf00      	nop
} // end of CTRL_setFlag_enableCtrl() function
 800239a:	3714      	adds	r7, #20
 800239c:	46bd      	mov	sp, r7
 800239e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80023a2:	4770      	bx	lr

080023a4 <CTRL_setState>:

//! \brief     Sets the controller state
//! \param[in] handle  The controller (CTRL) handle
//! \param[in] state       The new state
static inline void CTRL_setState(CTRL_Handle handle,const CTRL_State_e state)//! \Mod By Dl.K
{
 80023a4:	b480      	push	{r7}
 80023a6:	b085      	sub	sp, #20
 80023a8:	af00      	add	r7, sp, #0
 80023aa:	6078      	str	r0, [r7, #4]
 80023ac:	460b      	mov	r3, r1
 80023ae:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80023b0:	687b      	ldr	r3, [r7, #4]
 80023b2:	60fb      	str	r3, [r7, #12]

  obj->prevState = obj->state;
 80023b4:	68fb      	ldr	r3, [r7, #12]
 80023b6:	7a1a      	ldrb	r2, [r3, #8]
 80023b8:	68fb      	ldr	r3, [r7, #12]
 80023ba:	725a      	strb	r2, [r3, #9]
  obj->state = state;
 80023bc:	68fb      	ldr	r3, [r7, #12]
 80023be:	78fa      	ldrb	r2, [r7, #3]
 80023c0:	721a      	strb	r2, [r3, #8]

  return;
 80023c2:	bf00      	nop
} // end of CTRL_setState() function
 80023c4:	3714      	adds	r7, #20
 80023c6:	46bd      	mov	sp, r7
 80023c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80023cc:	4770      	bx	lr
 80023ce:	bf00      	nop

080023d0 <Motor_Ctrl_Init>:
CTRL_Obj gCtrl;
CTRL_Handle gCtrlHandle;


void Motor_Ctrl_Init(void)
{
 80023d0:	b580      	push	{r7, lr}
 80023d2:	af00      	add	r7, sp, #0
	gHalHandle = HAL_init(&gHal, sizeof(gHal));
 80023d4:	480f      	ldr	r0, [pc, #60]	; (8002414 <Motor_Ctrl_Init+0x44>)
 80023d6:	f44f 7182 	mov.w	r1, #260	; 0x104
 80023da:	f003 feb3 	bl	8006144 <HAL_init>
 80023de:	4602      	mov	r2, r0
 80023e0:	4b0d      	ldr	r3, [pc, #52]	; (8002418 <Motor_Ctrl_Init+0x48>)
 80023e2:	601a      	str	r2, [r3, #0]
	
	gCtrlHandle = CTRL_init(&gCtrl, sizeof(gCtrl));
 80023e4:	480d      	ldr	r0, [pc, #52]	; (800241c <Motor_Ctrl_Init+0x4c>)
 80023e6:	f44f 714b 	mov.w	r1, #812	; 0x32c
 80023ea:	f002 fd03 	bl	8004df4 <CTRL_init>
 80023ee:	4602      	mov	r2, r0
 80023f0:	4b0b      	ldr	r3, [pc, #44]	; (8002420 <Motor_Ctrl_Init+0x50>)
 80023f2:	601a      	str	r2, [r3, #0]
	
	USER_setParams(&gUserParams);
 80023f4:	480b      	ldr	r0, [pc, #44]	; (8002424 <Motor_Ctrl_Init+0x54>)
 80023f6:	f004 f937 	bl	8006668 <USER_setParams>
	
	HAL_setParams(gHalHandle, &gUserParams);
 80023fa:	4b07      	ldr	r3, [pc, #28]	; (8002418 <Motor_Ctrl_Init+0x48>)
 80023fc:	681b      	ldr	r3, [r3, #0]
 80023fe:	4618      	mov	r0, r3
 8002400:	4908      	ldr	r1, [pc, #32]	; (8002424 <Motor_Ctrl_Init+0x54>)
 8002402:	f003 fee5 	bl	80061d0 <HAL_setParams>
	
	CTRL_setParams(gCtrlHandle, &gUserParams);
 8002406:	4b06      	ldr	r3, [pc, #24]	; (8002420 <Motor_Ctrl_Init+0x50>)
 8002408:	681b      	ldr	r3, [r3, #0]
 800240a:	4618      	mov	r0, r3
 800240c:	4905      	ldr	r1, [pc, #20]	; (8002424 <Motor_Ctrl_Init+0x54>)
 800240e:	f002 fda5 	bl	8004f5c <CTRL_setParams>
	
}
 8002412:	bd80      	pop	{r7, pc}
 8002414:	20012508 	.word	0x20012508
 8002418:	200121d8 	.word	0x200121d8
 800241c:	200121dc 	.word	0x200121dc
 8002420:	2001260c 	.word	0x2001260c
 8002424:	20012610 	.word	0x20012610

08002428 <Motor_Ctrl_State>:

uint8_t Motor_Ctrl_State(int8_t *cha_pt, int8_t *flag_pt)
{
 8002428:	b580      	push	{r7, lr}
 800242a:	b084      	sub	sp, #16
 800242c:	af00      	add	r7, sp, #0
 800242e:	6078      	str	r0, [r7, #4]
 8002430:	6039      	str	r1, [r7, #0]
//			if(value!=0x00 || value!=0xF0)
//			{
//				gCtrlHandle->data_rtxd_handle->data_rxd[i] = value;
//			}
//		}
		if(DATA_RXD_Status(gCtrlHandle->data_rtxd_handle)&&*flag_pt==1)
 8002432:	4b94      	ldr	r3, [pc, #592]	; (8002684 <Motor_Ctrl_State+0x25c>)
 8002434:	681b      	ldr	r3, [r3, #0]
 8002436:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
 800243a:	4618      	mov	r0, r3
 800243c:	f7ff fd0e 	bl	8001e5c <DATA_RXD_Status>
 8002440:	4603      	mov	r3, r0
 8002442:	2b00      	cmp	r3, #0
 8002444:	d021      	beq.n	800248a <Motor_Ctrl_State+0x62>
 8002446:	683b      	ldr	r3, [r7, #0]
 8002448:	781b      	ldrb	r3, [r3, #0]
 800244a:	b25b      	sxtb	r3, r3
 800244c:	2b01      	cmp	r3, #1
 800244e:	d11c      	bne.n	800248a <Motor_Ctrl_State+0x62>
		{
			int8_t i;
			for(i=0;i<DATA_RXD_SIZE;i++)
 8002450:	2300      	movs	r3, #0
 8002452:	73fb      	strb	r3, [r7, #15]
 8002454:	e012      	b.n	800247c <Motor_Ctrl_State+0x54>
			{
				DATA_RXD_Run(gCtrlHandle->data_rtxd_handle,*cha_pt);
 8002456:	4b8b      	ldr	r3, [pc, #556]	; (8002684 <Motor_Ctrl_State+0x25c>)
 8002458:	681b      	ldr	r3, [r3, #0]
 800245a:	f8d3 2260 	ldr.w	r2, [r3, #608]	; 0x260
 800245e:	687b      	ldr	r3, [r7, #4]
 8002460:	781b      	ldrb	r3, [r3, #0]
 8002462:	b2db      	uxtb	r3, r3
 8002464:	4610      	mov	r0, r2
 8002466:	4619      	mov	r1, r3
 8002468:	f7ff fd20 	bl	8001eac <DATA_RXD_Run>
				cha_pt++;
 800246c:	687b      	ldr	r3, [r7, #4]
 800246e:	3301      	adds	r3, #1
 8002470:	607b      	str	r3, [r7, #4]
//			}
//		}
		if(DATA_RXD_Status(gCtrlHandle->data_rtxd_handle)&&*flag_pt==1)
		{
			int8_t i;
			for(i=0;i<DATA_RXD_SIZE;i++)
 8002472:	7bfb      	ldrb	r3, [r7, #15]
 8002474:	b2db      	uxtb	r3, r3
 8002476:	3301      	adds	r3, #1
 8002478:	b2db      	uxtb	r3, r3
 800247a:	73fb      	strb	r3, [r7, #15]
 800247c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8002480:	2b0c      	cmp	r3, #12
 8002482:	dde8      	ble.n	8002456 <Motor_Ctrl_State+0x2e>
			{
				DATA_RXD_Run(gCtrlHandle->data_rtxd_handle,*cha_pt);
				cha_pt++;
			}
			*flag_pt=0;
 8002484:	683b      	ldr	r3, [r7, #0]
 8002486:	2200      	movs	r2, #0
 8002488:	701a      	strb	r2, [r3, #0]
		}

		if(CTRL_isError(gCtrlHandle))
 800248a:	4b7e      	ldr	r3, [pc, #504]	; (8002684 <Motor_Ctrl_State+0x25c>)
 800248c:	681b      	ldr	r3, [r3, #0]
 800248e:	4618      	mov	r0, r3
 8002490:	f7ff ff60 	bl	8002354 <CTRL_isError>
 8002494:	4603      	mov	r3, r0
 8002496:	2b00      	cmp	r3, #0
 8002498:	d00a      	beq.n	80024b0 <Motor_Ctrl_State+0x88>
		  {
			// set the enable controller flag to false
			CTRL_setFlag_enableCtrl(gCtrlHandle,false);
 800249a:	4b7a      	ldr	r3, [pc, #488]	; (8002684 <Motor_Ctrl_State+0x25c>)
 800249c:	681b      	ldr	r3, [r3, #0]
 800249e:	4618      	mov	r0, r3
 80024a0:	2100      	movs	r1, #0
 80024a2:	f7ff ff6d 	bl	8002380 <CTRL_setFlag_enableCtrl>
			rt_kprintf("ctrl is error\r\n");
 80024a6:	4878      	ldr	r0, [pc, #480]	; (8002688 <Motor_Ctrl_State+0x260>)
 80024a8:	f015 fa08 	bl	80178bc <rt_kprintf>
			// disable the PWM
				return false;
 80024ac:	2300      	movs	r3, #0
 80024ae:	e153      	b.n	8002758 <Motor_Ctrl_State+0x330>
		  }
		else
		  {
			CTRL_State_e ctrlState = CTRL_getState(gCtrlHandle);
 80024b0:	4b74      	ldr	r3, [pc, #464]	; (8002684 <Motor_Ctrl_State+0x25c>)
 80024b2:	681b      	ldr	r3, [r3, #0]
 80024b4:	4618      	mov	r0, r3
 80024b6:	f7ff ff3f 	bl	8002338 <CTRL_getState>
 80024ba:	4603      	mov	r3, r0
 80024bc:	73bb      	strb	r3, [r7, #14]
			CTRL_State_e ctrlprevState = gCtrlHandle->prevState;
 80024be:	4b71      	ldr	r3, [pc, #452]	; (8002684 <Motor_Ctrl_State+0x25c>)
 80024c0:	681b      	ldr	r3, [r3, #0]
 80024c2:	7a5b      	ldrb	r3, [r3, #9]
 80024c4:	737b      	strb	r3, [r7, #13]
			if(ctrlState == CTRL_State_Idle)
 80024c6:	7bbb      	ldrb	r3, [r7, #14]
 80024c8:	2b01      	cmp	r3, #1
 80024ca:	f040 8098 	bne.w	80025fe <Motor_Ctrl_State+0x1d6>
			{
				// disable the PWM
				if( ctrlprevState == CTRL_State_OpenLoop )
 80024ce:	7b7b      	ldrb	r3, [r7, #13]
 80024d0:	2b06      	cmp	r3, #6
 80024d2:	d10a      	bne.n	80024ea <Motor_Ctrl_State+0xc2>
				{
					
					rt_kprintf("CTRL_State_OpenLoop\r\n");
 80024d4:	486d      	ldr	r0, [pc, #436]	; (800268c <Motor_Ctrl_State+0x264>)
 80024d6:	f015 f9f1 	bl	80178bc <rt_kprintf>
					RMP_CNTL_InitPara( gCtrlHandle->rmpcntl_handle );
 80024da:	4b6a      	ldr	r3, [pc, #424]	; (8002684 <Motor_Ctrl_State+0x25c>)
 80024dc:	681b      	ldr	r3, [r3, #0]
 80024de:	f8d3 3224 	ldr.w	r3, [r3, #548]	; 0x224
 80024e2:	4618      	mov	r0, r3
 80024e4:	f7ff fca4 	bl	8001e30 <RMP_CNTL_InitPara>
 80024e8:	e087      	b.n	80025fa <Motor_Ctrl_State+0x1d2>
				}
				else if( ctrlprevState == CTRL_State_CurrentCloseLoop )
 80024ea:	7b7b      	ldrb	r3, [r7, #13]
 80024ec:	2b08      	cmp	r3, #8
 80024ee:	d133      	bne.n	8002558 <Motor_Ctrl_State+0x130>
				{
					rt_kprintf("CTRL_State_CurrentCloseLoop\r\n");
 80024f0:	4867      	ldr	r0, [pc, #412]	; (8002690 <Motor_Ctrl_State+0x268>)
 80024f2:	f015 f9e3 	bl	80178bc <rt_kprintf>
					PID_setUi(gCtrlHandle->pidHandle_Id,(0.0f));
 80024f6:	4b63      	ldr	r3, [pc, #396]	; (8002684 <Motor_Ctrl_State+0x25c>)
 80024f8:	681b      	ldr	r3, [r3, #0]
 80024fa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80024fc:	4618      	mov	r0, r3
 80024fe:	ed9f 0a65 	vldr	s0, [pc, #404]	; 8002694 <Motor_Ctrl_State+0x26c>
 8002502:	f7ff fc83 	bl	8001e0c <PID_setUi>
					PID_setRefValue(gCtrlHandle->pidHandle_Id,(0.0f));
 8002506:	4b5f      	ldr	r3, [pc, #380]	; (8002684 <Motor_Ctrl_State+0x25c>)
 8002508:	681b      	ldr	r3, [r3, #0]
 800250a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800250c:	4618      	mov	r0, r3
 800250e:	ed9f 0a61 	vldr	s0, [pc, #388]	; 8002694 <Motor_Ctrl_State+0x26c>
 8002512:	f7ff fc69 	bl	8001de8 <PID_setRefValue>
					PID_setFbackValue(gCtrlHandle->pidHandle_Id,(0.0f));
 8002516:	4b5b      	ldr	r3, [pc, #364]	; (8002684 <Motor_Ctrl_State+0x25c>)
 8002518:	681b      	ldr	r3, [r3, #0]
 800251a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800251c:	4618      	mov	r0, r3
 800251e:	ed9f 0a5d 	vldr	s0, [pc, #372]	; 8002694 <Motor_Ctrl_State+0x26c>
 8002522:	f7ff fc4f 	bl	8001dc4 <PID_setFbackValue>
					PID_setUi(gCtrlHandle->pidHandle_Iq,(0.0f));
 8002526:	4b57      	ldr	r3, [pc, #348]	; (8002684 <Motor_Ctrl_State+0x25c>)
 8002528:	681b      	ldr	r3, [r3, #0]
 800252a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800252c:	4618      	mov	r0, r3
 800252e:	ed9f 0a59 	vldr	s0, [pc, #356]	; 8002694 <Motor_Ctrl_State+0x26c>
 8002532:	f7ff fc6b 	bl	8001e0c <PID_setUi>
					PID_setRefValue(gCtrlHandle->pidHandle_Iq,(0.0f));
 8002536:	4b53      	ldr	r3, [pc, #332]	; (8002684 <Motor_Ctrl_State+0x25c>)
 8002538:	681b      	ldr	r3, [r3, #0]
 800253a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800253c:	4618      	mov	r0, r3
 800253e:	ed9f 0a55 	vldr	s0, [pc, #340]	; 8002694 <Motor_Ctrl_State+0x26c>
 8002542:	f7ff fc51 	bl	8001de8 <PID_setRefValue>
					PID_setFbackValue(gCtrlHandle->pidHandle_Iq,(0.0f));
 8002546:	4b4f      	ldr	r3, [pc, #316]	; (8002684 <Motor_Ctrl_State+0x25c>)
 8002548:	681b      	ldr	r3, [r3, #0]
 800254a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800254c:	4618      	mov	r0, r3
 800254e:	ed9f 0a51 	vldr	s0, [pc, #324]	; 8002694 <Motor_Ctrl_State+0x26c>
 8002552:	f7ff fc37 	bl	8001dc4 <PID_setFbackValue>
 8002556:	e050      	b.n	80025fa <Motor_Ctrl_State+0x1d2>
				}
				else if( ctrlprevState == CTRL_State_SpeedCloseLoop )
 8002558:	7b7b      	ldrb	r3, [r7, #13]
 800255a:	2b09      	cmp	r3, #9
 800255c:	d14d      	bne.n	80025fa <Motor_Ctrl_State+0x1d2>
				{
					rt_kprintf("CTRL_State_SpeedCloseLoop\r\n");
 800255e:	484e      	ldr	r0, [pc, #312]	; (8002698 <Motor_Ctrl_State+0x270>)
 8002560:	f015 f9ac 	bl	80178bc <rt_kprintf>
					PID_setUi(gCtrlHandle->pidHandle_spd,(0.0f));
 8002564:	4b47      	ldr	r3, [pc, #284]	; (8002684 <Motor_Ctrl_State+0x25c>)
 8002566:	681b      	ldr	r3, [r3, #0]
 8002568:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800256c:	4618      	mov	r0, r3
 800256e:	ed9f 0a49 	vldr	s0, [pc, #292]	; 8002694 <Motor_Ctrl_State+0x26c>
 8002572:	f7ff fc4b 	bl	8001e0c <PID_setUi>
					PID_setRefValue(gCtrlHandle->pidHandle_spd,(0.0f));
 8002576:	4b43      	ldr	r3, [pc, #268]	; (8002684 <Motor_Ctrl_State+0x25c>)
 8002578:	681b      	ldr	r3, [r3, #0]
 800257a:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800257e:	4618      	mov	r0, r3
 8002580:	ed9f 0a44 	vldr	s0, [pc, #272]	; 8002694 <Motor_Ctrl_State+0x26c>
 8002584:	f7ff fc30 	bl	8001de8 <PID_setRefValue>
					PID_setFbackValue(gCtrlHandle->pidHandle_spd,(0.0f));
 8002588:	4b3e      	ldr	r3, [pc, #248]	; (8002684 <Motor_Ctrl_State+0x25c>)
 800258a:	681b      	ldr	r3, [r3, #0]
 800258c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8002590:	4618      	mov	r0, r3
 8002592:	ed9f 0a40 	vldr	s0, [pc, #256]	; 8002694 <Motor_Ctrl_State+0x26c>
 8002596:	f7ff fc15 	bl	8001dc4 <PID_setFbackValue>
					PID_setUi(gCtrlHandle->pidHandle_Id,(0.0f));
 800259a:	4b3a      	ldr	r3, [pc, #232]	; (8002684 <Motor_Ctrl_State+0x25c>)
 800259c:	681b      	ldr	r3, [r3, #0]
 800259e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80025a0:	4618      	mov	r0, r3
 80025a2:	ed9f 0a3c 	vldr	s0, [pc, #240]	; 8002694 <Motor_Ctrl_State+0x26c>
 80025a6:	f7ff fc31 	bl	8001e0c <PID_setUi>
					PID_setRefValue(gCtrlHandle->pidHandle_Id,(0.0f));
 80025aa:	4b36      	ldr	r3, [pc, #216]	; (8002684 <Motor_Ctrl_State+0x25c>)
 80025ac:	681b      	ldr	r3, [r3, #0]
 80025ae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80025b0:	4618      	mov	r0, r3
 80025b2:	ed9f 0a38 	vldr	s0, [pc, #224]	; 8002694 <Motor_Ctrl_State+0x26c>
 80025b6:	f7ff fc17 	bl	8001de8 <PID_setRefValue>
					PID_setFbackValue(gCtrlHandle->pidHandle_Id,(0.0f));
 80025ba:	4b32      	ldr	r3, [pc, #200]	; (8002684 <Motor_Ctrl_State+0x25c>)
 80025bc:	681b      	ldr	r3, [r3, #0]
 80025be:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80025c0:	4618      	mov	r0, r3
 80025c2:	ed9f 0a34 	vldr	s0, [pc, #208]	; 8002694 <Motor_Ctrl_State+0x26c>
 80025c6:	f7ff fbfd 	bl	8001dc4 <PID_setFbackValue>
					PID_setUi(gCtrlHandle->pidHandle_Iq,(0.0f));
 80025ca:	4b2e      	ldr	r3, [pc, #184]	; (8002684 <Motor_Ctrl_State+0x25c>)
 80025cc:	681b      	ldr	r3, [r3, #0]
 80025ce:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80025d0:	4618      	mov	r0, r3
 80025d2:	ed9f 0a30 	vldr	s0, [pc, #192]	; 8002694 <Motor_Ctrl_State+0x26c>
 80025d6:	f7ff fc19 	bl	8001e0c <PID_setUi>
					PID_setRefValue(gCtrlHandle->pidHandle_Iq,(0.0f));
 80025da:	4b2a      	ldr	r3, [pc, #168]	; (8002684 <Motor_Ctrl_State+0x25c>)
 80025dc:	681b      	ldr	r3, [r3, #0]
 80025de:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80025e0:	4618      	mov	r0, r3
 80025e2:	ed9f 0a2c 	vldr	s0, [pc, #176]	; 8002694 <Motor_Ctrl_State+0x26c>
 80025e6:	f7ff fbff 	bl	8001de8 <PID_setRefValue>
					PID_setFbackValue(gCtrlHandle->pidHandle_Iq,(0.0f));
 80025ea:	4b26      	ldr	r3, [pc, #152]	; (8002684 <Motor_Ctrl_State+0x25c>)
 80025ec:	681b      	ldr	r3, [r3, #0]
 80025ee:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80025f0:	4618      	mov	r0, r3
 80025f2:	ed9f 0a28 	vldr	s0, [pc, #160]	; 8002694 <Motor_Ctrl_State+0x26c>
 80025f6:	f7ff fbe5 	bl	8001dc4 <PID_setFbackValue>
				}
				return false;
 80025fa:	2300      	movs	r3, #0
 80025fc:	e0ac      	b.n	8002758 <Motor_Ctrl_State+0x330>
			}
			else if(ctrlState == CTRL_State_OffLine)
 80025fe:	7bbb      	ldrb	r3, [r7, #14]
 8002600:	2b02      	cmp	r3, #2
 8002602:	f040 809a 	bne.w	800273a <Motor_Ctrl_State+0x312>
			{
				// enable the PWM
				if( ctrlprevState == CTRL_State_OpenLoop )
 8002606:	7b7b      	ldrb	r3, [r7, #13]
 8002608:	2b06      	cmp	r3, #6
 800260a:	d107      	bne.n	800261c <Motor_Ctrl_State+0x1f4>
				{
					RMP_CNTL_InitPara( gCtrlHandle->rmpcntl_handle );
 800260c:	4b1d      	ldr	r3, [pc, #116]	; (8002684 <Motor_Ctrl_State+0x25c>)
 800260e:	681b      	ldr	r3, [r3, #0]
 8002610:	f8d3 3224 	ldr.w	r3, [r3, #548]	; 0x224
 8002614:	4618      	mov	r0, r3
 8002616:	f7ff fc0b 	bl	8001e30 <RMP_CNTL_InitPara>
 800261a:	e09c      	b.n	8002756 <Motor_Ctrl_State+0x32e>
				}
				else if( ctrlprevState == CTRL_State_CurrentCloseLoop )
 800261c:	7b7b      	ldrb	r3, [r7, #13]
 800261e:	2b08      	cmp	r3, #8
 8002620:	d13c      	bne.n	800269c <Motor_Ctrl_State+0x274>
				{
					PID_setUi(gCtrlHandle->pidHandle_Id,(0.0f));
 8002622:	4b18      	ldr	r3, [pc, #96]	; (8002684 <Motor_Ctrl_State+0x25c>)
 8002624:	681b      	ldr	r3, [r3, #0]
 8002626:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002628:	4618      	mov	r0, r3
 800262a:	ed9f 0a1a 	vldr	s0, [pc, #104]	; 8002694 <Motor_Ctrl_State+0x26c>
 800262e:	f7ff fbed 	bl	8001e0c <PID_setUi>
					PID_setRefValue(gCtrlHandle->pidHandle_Id,(0.0f));
 8002632:	4b14      	ldr	r3, [pc, #80]	; (8002684 <Motor_Ctrl_State+0x25c>)
 8002634:	681b      	ldr	r3, [r3, #0]
 8002636:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002638:	4618      	mov	r0, r3
 800263a:	ed9f 0a16 	vldr	s0, [pc, #88]	; 8002694 <Motor_Ctrl_State+0x26c>
 800263e:	f7ff fbd3 	bl	8001de8 <PID_setRefValue>
					PID_setFbackValue(gCtrlHandle->pidHandle_Id,(0.0f));
 8002642:	4b10      	ldr	r3, [pc, #64]	; (8002684 <Motor_Ctrl_State+0x25c>)
 8002644:	681b      	ldr	r3, [r3, #0]
 8002646:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002648:	4618      	mov	r0, r3
 800264a:	ed9f 0a12 	vldr	s0, [pc, #72]	; 8002694 <Motor_Ctrl_State+0x26c>
 800264e:	f7ff fbb9 	bl	8001dc4 <PID_setFbackValue>
					PID_setUi(gCtrlHandle->pidHandle_Iq,(0.0f));
 8002652:	4b0c      	ldr	r3, [pc, #48]	; (8002684 <Motor_Ctrl_State+0x25c>)
 8002654:	681b      	ldr	r3, [r3, #0]
 8002656:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8002658:	4618      	mov	r0, r3
 800265a:	ed9f 0a0e 	vldr	s0, [pc, #56]	; 8002694 <Motor_Ctrl_State+0x26c>
 800265e:	f7ff fbd5 	bl	8001e0c <PID_setUi>
					PID_setRefValue(gCtrlHandle->pidHandle_Iq,(0.0f));
 8002662:	4b08      	ldr	r3, [pc, #32]	; (8002684 <Motor_Ctrl_State+0x25c>)
 8002664:	681b      	ldr	r3, [r3, #0]
 8002666:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8002668:	4618      	mov	r0, r3
 800266a:	ed9f 0a0a 	vldr	s0, [pc, #40]	; 8002694 <Motor_Ctrl_State+0x26c>
 800266e:	f7ff fbbb 	bl	8001de8 <PID_setRefValue>
					PID_setFbackValue(gCtrlHandle->pidHandle_Iq,(0.0f));
 8002672:	4b04      	ldr	r3, [pc, #16]	; (8002684 <Motor_Ctrl_State+0x25c>)
 8002674:	681b      	ldr	r3, [r3, #0]
 8002676:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8002678:	4618      	mov	r0, r3
 800267a:	ed9f 0a06 	vldr	s0, [pc, #24]	; 8002694 <Motor_Ctrl_State+0x26c>
 800267e:	f7ff fba1 	bl	8001dc4 <PID_setFbackValue>
 8002682:	e068      	b.n	8002756 <Motor_Ctrl_State+0x32e>
 8002684:	2001260c 	.word	0x2001260c
 8002688:	08026e7c 	.word	0x08026e7c
 800268c:	08026e8c 	.word	0x08026e8c
 8002690:	08026ea4 	.word	0x08026ea4
 8002694:	00000000 	.word	0x00000000
 8002698:	08026ec4 	.word	0x08026ec4
				}
				else if( ctrlprevState == CTRL_State_SpeedCloseLoop )
 800269c:	7b7b      	ldrb	r3, [r7, #13]
 800269e:	2b09      	cmp	r3, #9
 80026a0:	d159      	bne.n	8002756 <Motor_Ctrl_State+0x32e>
				{
					PID_setUi(gCtrlHandle->pidHandle_spd,(0.0f));
 80026a2:	4b2f      	ldr	r3, [pc, #188]	; (8002760 <Motor_Ctrl_State+0x338>)
 80026a4:	681b      	ldr	r3, [r3, #0]
 80026a6:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80026aa:	4618      	mov	r0, r3
 80026ac:	ed9f 0a2d 	vldr	s0, [pc, #180]	; 8002764 <Motor_Ctrl_State+0x33c>
 80026b0:	f7ff fbac 	bl	8001e0c <PID_setUi>
					PID_setRefValue(gCtrlHandle->pidHandle_spd,(0.0f));
 80026b4:	4b2a      	ldr	r3, [pc, #168]	; (8002760 <Motor_Ctrl_State+0x338>)
 80026b6:	681b      	ldr	r3, [r3, #0]
 80026b8:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80026bc:	4618      	mov	r0, r3
 80026be:	ed9f 0a29 	vldr	s0, [pc, #164]	; 8002764 <Motor_Ctrl_State+0x33c>
 80026c2:	f7ff fb91 	bl	8001de8 <PID_setRefValue>
					PID_setFbackValue(gCtrlHandle->pidHandle_spd,(0.0f));
 80026c6:	4b26      	ldr	r3, [pc, #152]	; (8002760 <Motor_Ctrl_State+0x338>)
 80026c8:	681b      	ldr	r3, [r3, #0]
 80026ca:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80026ce:	4618      	mov	r0, r3
 80026d0:	ed9f 0a24 	vldr	s0, [pc, #144]	; 8002764 <Motor_Ctrl_State+0x33c>
 80026d4:	f7ff fb76 	bl	8001dc4 <PID_setFbackValue>
					PID_setUi(gCtrlHandle->pidHandle_Id,(0.0f));
 80026d8:	4b21      	ldr	r3, [pc, #132]	; (8002760 <Motor_Ctrl_State+0x338>)
 80026da:	681b      	ldr	r3, [r3, #0]
 80026dc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80026de:	4618      	mov	r0, r3
 80026e0:	ed9f 0a20 	vldr	s0, [pc, #128]	; 8002764 <Motor_Ctrl_State+0x33c>
 80026e4:	f7ff fb92 	bl	8001e0c <PID_setUi>
					PID_setRefValue(gCtrlHandle->pidHandle_Id,(0.0f));
 80026e8:	4b1d      	ldr	r3, [pc, #116]	; (8002760 <Motor_Ctrl_State+0x338>)
 80026ea:	681b      	ldr	r3, [r3, #0]
 80026ec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80026ee:	4618      	mov	r0, r3
 80026f0:	ed9f 0a1c 	vldr	s0, [pc, #112]	; 8002764 <Motor_Ctrl_State+0x33c>
 80026f4:	f7ff fb78 	bl	8001de8 <PID_setRefValue>
					PID_setFbackValue(gCtrlHandle->pidHandle_Id,(0.0f));
 80026f8:	4b19      	ldr	r3, [pc, #100]	; (8002760 <Motor_Ctrl_State+0x338>)
 80026fa:	681b      	ldr	r3, [r3, #0]
 80026fc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80026fe:	4618      	mov	r0, r3
 8002700:	ed9f 0a18 	vldr	s0, [pc, #96]	; 8002764 <Motor_Ctrl_State+0x33c>
 8002704:	f7ff fb5e 	bl	8001dc4 <PID_setFbackValue>
					PID_setUi(gCtrlHandle->pidHandle_Iq,(0.0f));
 8002708:	4b15      	ldr	r3, [pc, #84]	; (8002760 <Motor_Ctrl_State+0x338>)
 800270a:	681b      	ldr	r3, [r3, #0]
 800270c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800270e:	4618      	mov	r0, r3
 8002710:	ed9f 0a14 	vldr	s0, [pc, #80]	; 8002764 <Motor_Ctrl_State+0x33c>
 8002714:	f7ff fb7a 	bl	8001e0c <PID_setUi>
					PID_setRefValue(gCtrlHandle->pidHandle_Iq,(0.0f));
 8002718:	4b11      	ldr	r3, [pc, #68]	; (8002760 <Motor_Ctrl_State+0x338>)
 800271a:	681b      	ldr	r3, [r3, #0]
 800271c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800271e:	4618      	mov	r0, r3
 8002720:	ed9f 0a10 	vldr	s0, [pc, #64]	; 8002764 <Motor_Ctrl_State+0x33c>
 8002724:	f7ff fb60 	bl	8001de8 <PID_setRefValue>
					PID_setFbackValue(gCtrlHandle->pidHandle_Iq,(0.0f));
 8002728:	4b0d      	ldr	r3, [pc, #52]	; (8002760 <Motor_Ctrl_State+0x338>)
 800272a:	681b      	ldr	r3, [r3, #0]
 800272c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800272e:	4618      	mov	r0, r3
 8002730:	ed9f 0a0c 	vldr	s0, [pc, #48]	; 8002764 <Motor_Ctrl_State+0x33c>
 8002734:	f7ff fb46 	bl	8001dc4 <PID_setFbackValue>
 8002738:	e00d      	b.n	8002756 <Motor_Ctrl_State+0x32e>
				}
			}
			else if(ctrlState == CTRL_State_OffLineOffsetComp)
 800273a:	7bbb      	ldrb	r3, [r7, #14]
 800273c:	2b03      	cmp	r3, #3
 800273e:	d10a      	bne.n	8002756 <Motor_Ctrl_State+0x32e>
			{
				// update the ADC bias values
				HAL_updateAdcBias(gHalHandle);
 8002740:	4b09      	ldr	r3, [pc, #36]	; (8002768 <Motor_Ctrl_State+0x340>)
 8002742:	681b      	ldr	r3, [r3, #0]
 8002744:	4618      	mov	r0, r3
 8002746:	f7ff fd5d 	bl	8002204 <HAL_updateAdcBias>

				CTRL_setState(gCtrlHandle, CTRL_State_OffLine);
 800274a:	4b05      	ldr	r3, [pc, #20]	; (8002760 <Motor_Ctrl_State+0x338>)
 800274c:	681b      	ldr	r3, [r3, #0]
 800274e:	4618      	mov	r0, r3
 8002750:	2102      	movs	r1, #2
 8002752:	f7ff fe27 	bl	80023a4 <CTRL_setState>
//				// set the speed acceleration
//				CTRL_setMaxAccel_pu(ctrlHandle,_IQmpy(MAX_ACCEL_KRPMPS_SF,gMotorVars.MaxAccel_krpmps));
			}

		  }
			return true;
 8002756:	2301      	movs	r3, #1
		}
}
 8002758:	4618      	mov	r0, r3
 800275a:	3710      	adds	r7, #16
 800275c:	46bd      	mov	sp, r7
 800275e:	bd80      	pop	{r7, pc}
 8002760:	2001260c 	.word	0x2001260c
 8002764:	00000000 	.word	0x00000000
 8002768:	200121d8 	.word	0x200121d8

0800276c <Motor_Ctrl_Run>:

void Motor_Ctrl_Run(HAL_AdcData_t *pAdcData, HAL_PwmData_t *pPwmData, HAL_QepData_t *pQepData)
{
 800276c:	b580      	push	{r7, lr}
 800276e:	b086      	sub	sp, #24
 8002770:	af02      	add	r7, sp, #8
 8002772:	60f8      	str	r0, [r7, #12]
 8002774:	60b9      	str	r1, [r7, #8]
 8002776:	607a      	str	r2, [r7, #4]
	static uint_least16_t count_sci=50,numSciTick=50;

  // convert the ADC data
  HAL_readAdcData(gHalHandle,pAdcData);
 8002778:	4b29      	ldr	r3, [pc, #164]	; (8002820 <Motor_Ctrl_Run+0xb4>)
 800277a:	681b      	ldr	r3, [r3, #0]
 800277c:	4618      	mov	r0, r3
 800277e:	68f9      	ldr	r1, [r7, #12]
 8002780:	f7ff fc36 	bl	8001ff0 <HAL_readAdcData>

  // run the controller
  
#if 1
  CTRL_run(gCtrlHandle,gHalHandle,pAdcData,pPwmData,pQepData);
 8002784:	4b27      	ldr	r3, [pc, #156]	; (8002824 <Motor_Ctrl_Run+0xb8>)
 8002786:	6819      	ldr	r1, [r3, #0]
 8002788:	4b25      	ldr	r3, [pc, #148]	; (8002820 <Motor_Ctrl_Run+0xb4>)
 800278a:	681a      	ldr	r2, [r3, #0]
 800278c:	687b      	ldr	r3, [r7, #4]
 800278e:	9300      	str	r3, [sp, #0]
 8002790:	4608      	mov	r0, r1
 8002792:	4611      	mov	r1, r2
 8002794:	68fa      	ldr	r2, [r7, #12]
 8002796:	68bb      	ldr	r3, [r7, #8]
 8002798:	f002 fa6c 	bl	8004c74 <CTRL_run>
//	pPwmData->Tabc.value[0] = -0.1f;
//	pPwmData->Tabc.value[1] = -0.0f;
//	pPwmData->Tabc.value[2] = 0.1f;
  // write the PWM compare values
  
  HAL_writePwmData(gHalHandle,pPwmData);
 800279c:	4b20      	ldr	r3, [pc, #128]	; (8002820 <Motor_Ctrl_Run+0xb4>)
 800279e:	681b      	ldr	r3, [r3, #0]
 80027a0:	4618      	mov	r0, r3
 80027a2:	68b9      	ldr	r1, [r7, #8]
 80027a4:	f7ff fd94 	bl	80022d0 <HAL_writePwmData>

//  // setup the controller
//  CTRL_setup(gCtrlHandle);
#if 1
	if(count_sci>=numSciTick)
 80027a8:	4b1f      	ldr	r3, [pc, #124]	; (8002828 <Motor_Ctrl_Run+0xbc>)
 80027aa:	881a      	ldrh	r2, [r3, #0]
 80027ac:	4b1f      	ldr	r3, [pc, #124]	; (800282c <Motor_Ctrl_Run+0xc0>)
 80027ae:	881b      	ldrh	r3, [r3, #0]
 80027b0:	429a      	cmp	r2, r3
 80027b2:	d32c      	bcc.n	800280e <Motor_Ctrl_Run+0xa2>
	{
		count_sci = 1;
 80027b4:	4b1c      	ldr	r3, [pc, #112]	; (8002828 <Motor_Ctrl_Run+0xbc>)
 80027b6:	2201      	movs	r2, #1
 80027b8:	801a      	strh	r2, [r3, #0]
		DATA_RTXD_Decode(gCtrlHandle,gHalHandle);
 80027ba:	4b1a      	ldr	r3, [pc, #104]	; (8002824 <Motor_Ctrl_Run+0xb8>)
 80027bc:	681a      	ldr	r2, [r3, #0]
 80027be:	4b18      	ldr	r3, [pc, #96]	; (8002820 <Motor_Ctrl_Run+0xb4>)
 80027c0:	681b      	ldr	r3, [r3, #0]
 80027c2:	4610      	mov	r0, r2
 80027c4:	4619      	mov	r1, r3
 80027c6:	f003 fa51 	bl	8005c6c <DATA_RTXD_Decode>
		DATA_RTXD_Run(gCtrlHandle,gHalHandle,pAdcData,pQepData);
 80027ca:	4b16      	ldr	r3, [pc, #88]	; (8002824 <Motor_Ctrl_Run+0xb8>)
 80027cc:	681a      	ldr	r2, [r3, #0]
 80027ce:	4b14      	ldr	r3, [pc, #80]	; (8002820 <Motor_Ctrl_Run+0xb4>)
 80027d0:	681b      	ldr	r3, [r3, #0]
 80027d2:	4610      	mov	r0, r2
 80027d4:	4619      	mov	r1, r3
 80027d6:	68fa      	ldr	r2, [r7, #12]
 80027d8:	687b      	ldr	r3, [r7, #4]
 80027da:	f003 f9c3 	bl	8005b64 <DATA_RTXD_Run>
		while( DATA_TXD_Status(gCtrlHandle->data_rtxd_handle))
 80027de:	e00b      	b.n	80027f8 <Motor_Ctrl_Run+0x8c>
		{
			//rt_kprintf("%c",DATA_TXD_Run(handle->data_rtxd_handle));
			myprintf((char*)Get_DATA_TXD_Ptr(gCtrlHandle->data_rtxd_handle), 13);
 80027e0:	4b10      	ldr	r3, [pc, #64]	; (8002824 <Motor_Ctrl_Run+0xb8>)
 80027e2:	681b      	ldr	r3, [r3, #0]
 80027e4:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
 80027e8:	4618      	mov	r0, r3
 80027ea:	f7ff fb7f 	bl	8001eec <Get_DATA_TXD_Ptr>
 80027ee:	4603      	mov	r3, r0
 80027f0:	4618      	mov	r0, r3
 80027f2:	210d      	movs	r1, #13
 80027f4:	f012 ff3e 	bl	8015674 <myprintf>
	if(count_sci>=numSciTick)
	{
		count_sci = 1;
		DATA_RTXD_Decode(gCtrlHandle,gHalHandle);
		DATA_RTXD_Run(gCtrlHandle,gHalHandle,pAdcData,pQepData);
		while( DATA_TXD_Status(gCtrlHandle->data_rtxd_handle))
 80027f8:	4b0a      	ldr	r3, [pc, #40]	; (8002824 <Motor_Ctrl_Run+0xb8>)
 80027fa:	681b      	ldr	r3, [r3, #0]
 80027fc:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
 8002800:	4618      	mov	r0, r3
 8002802:	f7ff fb3f 	bl	8001e84 <DATA_TXD_Status>
 8002806:	4603      	mov	r3, r0
 8002808:	2b00      	cmp	r3, #0
 800280a:	d1e9      	bne.n	80027e0 <Motor_Ctrl_Run+0x74>
 800280c:	e005      	b.n	800281a <Motor_Ctrl_Run+0xae>
		{
			//rt_kprintf("%c",DATA_TXD_Run(handle->data_rtxd_handle));
			myprintf((char*)Get_DATA_TXD_Ptr(gCtrlHandle->data_rtxd_handle), 13);
		}		
	}
	else count_sci++;//! \Mod By Dl.K
 800280e:	4b06      	ldr	r3, [pc, #24]	; (8002828 <Motor_Ctrl_Run+0xbc>)
 8002810:	881b      	ldrh	r3, [r3, #0]
 8002812:	3301      	adds	r3, #1
 8002814:	b29a      	uxth	r2, r3
 8002816:	4b04      	ldr	r3, [pc, #16]	; (8002828 <Motor_Ctrl_Run+0xbc>)
 8002818:	801a      	strh	r2, [r3, #0]
	#endif
}
 800281a:	3710      	adds	r7, #16
 800281c:	46bd      	mov	sp, r7
 800281e:	bd80      	pop	{r7, pc}
 8002820:	200121d8 	.word	0x200121d8
 8002824:	2001260c 	.word	0x2001260c
 8002828:	20010000 	.word	0x20010000
 800282c:	20010002 	.word	0x20010002

08002830 <MATH_abs>:

//! \brief     Finds the absolute value 
//! \param[in] in   The input value
//! \return    The absolute value
static inline float_t MATH_abs(const float_t in)
{
 8002830:	b480      	push	{r7}
 8002832:	b085      	sub	sp, #20
 8002834:	af00      	add	r7, sp, #0
 8002836:	ed87 0a01 	vstr	s0, [r7, #4]
  float_t out = in;
 800283a:	687b      	ldr	r3, [r7, #4]
 800283c:	60fb      	str	r3, [r7, #12]


  if(in < 0.0f)
 800283e:	edd7 7a01 	vldr	s15, [r7, #4]
 8002842:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8002846:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800284a:	d505      	bpl.n	8002858 <MATH_abs+0x28>
    {
      out = -in;
 800284c:	edd7 7a01 	vldr	s15, [r7, #4]
 8002850:	eef1 7a67 	vneg.f32	s15, s15
 8002854:	edc7 7a03 	vstr	s15, [r7, #12]
    }

  return(out);
 8002858:	68fb      	ldr	r3, [r7, #12]
 800285a:	ee07 3a90 	vmov	s15, r3
} // end of MATH_abs() function
 800285e:	eeb0 0a67 	vmov.f32	s0, s15
 8002862:	3714      	adds	r7, #20
 8002864:	46bd      	mov	sp, r7
 8002866:	f85d 7b04 	ldr.w	r7, [sp], #4
 800286a:	4770      	bx	lr

0800286c <Speed_UpdateElecTheta>:

	return;
}

static inline void Speed_UpdateElecTheta(SPEED_Handle handle)//! \Mod By Dl.K
{
 800286c:	b480      	push	{r7}
 800286e:	b085      	sub	sp, #20
 8002870:	af00      	add	r7, sp, #0
 8002872:	6078      	str	r0, [r7, #4]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
 8002874:	687b      	ldr	r3, [r7, #4]
 8002876:	60fb      	str	r3, [r7, #12]

	obj->OldElecTheta = obj->ElecTheta;
 8002878:	68fb      	ldr	r3, [r7, #12]
 800287a:	681a      	ldr	r2, [r3, #0]
 800287c:	68fb      	ldr	r3, [r7, #12]
 800287e:	605a      	str	r2, [r3, #4]

	return;
 8002880:	bf00      	nop
}
 8002882:	3714      	adds	r7, #20
 8002884:	46bd      	mov	sp, r7
 8002886:	f85d 7b04 	ldr.w	r7, [sp], #4
 800288a:	4770      	bx	lr

0800288c <Speed_UpdateElecSpeed>:

static inline void Speed_UpdateElecSpeed(SPEED_Handle handle)//! \Mod By Dl.K
{
 800288c:	b480      	push	{r7}
 800288e:	b085      	sub	sp, #20
 8002890:	af00      	add	r7, sp, #0
 8002892:	6078      	str	r0, [r7, #4]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
 8002894:	687b      	ldr	r3, [r7, #4]
 8002896:	60fb      	str	r3, [r7, #12]

	obj->OldElecSpeed = obj->ElecSpeed;
 8002898:	68fb      	ldr	r3, [r7, #12]
 800289a:	68da      	ldr	r2, [r3, #12]
 800289c:	68fb      	ldr	r3, [r7, #12]
 800289e:	611a      	str	r2, [r3, #16]

	return;
 80028a0:	bf00      	nop
}
 80028a2:	3714      	adds	r7, #20
 80028a4:	46bd      	mov	sp, r7
 80028a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80028aa:	4770      	bx	lr

080028ac <Speed_Init>:
-------------------------------------------------------------------------------------*/

#include "modules/Speed/Speed.h"

SPEED_Handle Speed_Init(void *pMemory, const size_t numBytes)//! \Mod By Dl.K
{
 80028ac:	b480      	push	{r7}
 80028ae:	b085      	sub	sp, #20
 80028b0:	af00      	add	r7, sp, #0
 80028b2:	6078      	str	r0, [r7, #4]
 80028b4:	6039      	str	r1, [r7, #0]
	SPEED_Handle handle;

	if (numBytes < sizeof(SPEED_Obj))
 80028b6:	683b      	ldr	r3, [r7, #0]
 80028b8:	2b1b      	cmp	r3, #27
 80028ba:	d801      	bhi.n	80028c0 <Speed_Init+0x14>
		return((SPEED_Handle)NULL);
 80028bc:	2300      	movs	r3, #0
 80028be:	e01e      	b.n	80028fe <Speed_Init+0x52>

	// assign the handle
	handle = (SPEED_Handle)pMemory;
 80028c0:	687b      	ldr	r3, [r7, #4]
 80028c2:	60fb      	str	r3, [r7, #12]

	handle->ElecTheta = (0.0f);
 80028c4:	68fb      	ldr	r3, [r7, #12]
 80028c6:	f04f 0200 	mov.w	r2, #0
 80028ca:	601a      	str	r2, [r3, #0]
	handle->OldElecTheta = (0.0f);
 80028cc:	68fb      	ldr	r3, [r7, #12]
 80028ce:	f04f 0200 	mov.w	r2, #0
 80028d2:	605a      	str	r2, [r3, #4]
	handle->ElecThetaChagTimeRatio = (0.0f);// Real:1/(T) PU:1/(T)/SpeedBaseFreq
 80028d4:	68fb      	ldr	r3, [r7, #12]
 80028d6:	f04f 0200 	mov.w	r2, #0
 80028da:	609a      	str	r2, [r3, #8]
	handle->ElecSpeed = (0.0f);
 80028dc:	68fb      	ldr	r3, [r7, #12]
 80028de:	f04f 0200 	mov.w	r2, #0
 80028e2:	60da      	str	r2, [r3, #12]
	handle->OldElecSpeed = (0.0f);
 80028e4:	68fb      	ldr	r3, [r7, #12]
 80028e6:	f04f 0200 	mov.w	r2, #0
 80028ea:	611a      	str	r2, [r3, #16]
	handle->ElecFilterSpeed = (0.0f);
 80028ec:	68fb      	ldr	r3, [r7, #12]
 80028ee:	f04f 0200 	mov.w	r2, #0
 80028f2:	619a      	str	r2, [r3, #24]
	handle->ElecFilterSpeedRatio = (0.0f);// 1/(1+2*pi*Fc*Ts)
 80028f4:	68fb      	ldr	r3, [r7, #12]
 80028f6:	f04f 0200 	mov.w	r2, #0
 80028fa:	615a      	str	r2, [r3, #20]

	return(handle);
 80028fc:	68fb      	ldr	r3, [r7, #12]
}
 80028fe:	4618      	mov	r0, r3
 8002900:	3714      	adds	r7, #20
 8002902:	46bd      	mov	sp, r7
 8002904:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002908:	4770      	bx	lr
 800290a:	bf00      	nop

0800290c <Speed_Run>:

void Speed_Run(SPEED_Handle handle)
{
 800290c:	b580      	push	{r7, lr}
 800290e:	b084      	sub	sp, #16
 8002910:	af00      	add	r7, sp, #0
 8002912:	6078      	str	r0, [r7, #4]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
 8002914:	687b      	ldr	r3, [r7, #4]
 8002916:	60fb      	str	r3, [r7, #12]

	Speed_UpdateElecSpeed( obj );
 8002918:	68f8      	ldr	r0, [r7, #12]
 800291a:	f7ff ffb7 	bl	800288c <Speed_UpdateElecSpeed>
	// Need to Change the Time between Elec And OldElec According to Speed
	// 1kHz:1ms ElecSpeed:500Hz RealSpeed:125Hz@4poles, 2kHz:0.5ms ElecSpeed:500Hz RealSpeed:125Hz@4poles,
	if( MATH_abs(obj->ElecTheta - obj->OldElecTheta) > (0.5f) )
 800291e:	68fb      	ldr	r3, [r7, #12]
 8002920:	ed93 7a00 	vldr	s14, [r3]
 8002924:	68fb      	ldr	r3, [r7, #12]
 8002926:	edd3 7a01 	vldr	s15, [r3, #4]
 800292a:	ee77 7a67 	vsub.f32	s15, s14, s15
 800292e:	eeb0 0a67 	vmov.f32	s0, s15
 8002932:	f7ff ff7d 	bl	8002830 <MATH_abs>
 8002936:	eeb0 7a40 	vmov.f32	s14, s0
 800293a:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 800293e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8002942:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002946:	dd50      	ble.n	80029ea <Speed_Run+0xde>
	{
		if( (obj->ElecTheta + (1.0f)- obj->OldElecTheta)<(0.5f) )
 8002948:	68fb      	ldr	r3, [r7, #12]
 800294a:	edd3 7a00 	vldr	s15, [r3]
 800294e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8002952:	ee37 7a87 	vadd.f32	s14, s15, s14
 8002956:	68fb      	ldr	r3, [r7, #12]
 8002958:	edd3 7a01 	vldr	s15, [r3, #4]
 800295c:	ee77 7a67 	vsub.f32	s15, s14, s15
 8002960:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 8002964:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002968:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800296c:	d514      	bpl.n	8002998 <Speed_Run+0x8c>
		{
			obj->ElecSpeed = ( obj->ElecThetaChagTimeRatio * (obj->ElecTheta +(1.0f)- obj->OldElecTheta) );
 800296e:	68fb      	ldr	r3, [r7, #12]
 8002970:	ed93 7a02 	vldr	s14, [r3, #8]
 8002974:	68fb      	ldr	r3, [r7, #12]
 8002976:	edd3 7a00 	vldr	s15, [r3]
 800297a:	eef7 6a00 	vmov.f32	s13, #112	; 0x70
 800297e:	ee77 6aa6 	vadd.f32	s13, s15, s13
 8002982:	68fb      	ldr	r3, [r7, #12]
 8002984:	edd3 7a01 	vldr	s15, [r3, #4]
 8002988:	ee76 7ae7 	vsub.f32	s15, s13, s15
 800298c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8002990:	68fb      	ldr	r3, [r7, #12]
 8002992:	edc3 7a03 	vstr	s15, [r3, #12]
 8002996:	e038      	b.n	8002a0a <Speed_Run+0xfe>
		}
		else if( (obj->ElecTheta - (1.0f) - obj->OldElecTheta)>(-0.5f) )
 8002998:	68fb      	ldr	r3, [r7, #12]
 800299a:	edd3 7a00 	vldr	s15, [r3]
 800299e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 80029a2:	ee37 7ac7 	vsub.f32	s14, s15, s14
 80029a6:	68fb      	ldr	r3, [r7, #12]
 80029a8:	edd3 7a01 	vldr	s15, [r3, #4]
 80029ac:	ee77 7a67 	vsub.f32	s15, s14, s15
 80029b0:	eebe 7a00 	vmov.f32	s14, #224	; 0xe0
 80029b4:	eef4 7ac7 	vcmpe.f32	s15, s14
 80029b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80029bc:	dc00      	bgt.n	80029c0 <Speed_Run+0xb4>
 80029be:	e024      	b.n	8002a0a <Speed_Run+0xfe>
		{
			obj->ElecSpeed = ( obj->ElecThetaChagTimeRatio * (obj->ElecTheta -(1.0f)- obj->OldElecTheta) );
 80029c0:	68fb      	ldr	r3, [r7, #12]
 80029c2:	ed93 7a02 	vldr	s14, [r3, #8]
 80029c6:	68fb      	ldr	r3, [r7, #12]
 80029c8:	edd3 7a00 	vldr	s15, [r3]
 80029cc:	eef7 6a00 	vmov.f32	s13, #112	; 0x70
 80029d0:	ee77 6ae6 	vsub.f32	s13, s15, s13
 80029d4:	68fb      	ldr	r3, [r7, #12]
 80029d6:	edd3 7a01 	vldr	s15, [r3, #4]
 80029da:	ee76 7ae7 	vsub.f32	s15, s13, s15
 80029de:	ee67 7a27 	vmul.f32	s15, s14, s15
 80029e2:	68fb      	ldr	r3, [r7, #12]
 80029e4:	edc3 7a03 	vstr	s15, [r3, #12]
 80029e8:	e00f      	b.n	8002a0a <Speed_Run+0xfe>
		}
	}
	else
	{
		obj->ElecSpeed = ( obj->ElecThetaChagTimeRatio * (obj->ElecTheta - obj->OldElecTheta) );
 80029ea:	68fb      	ldr	r3, [r7, #12]
 80029ec:	ed93 7a02 	vldr	s14, [r3, #8]
 80029f0:	68fb      	ldr	r3, [r7, #12]
 80029f2:	edd3 6a00 	vldr	s13, [r3]
 80029f6:	68fb      	ldr	r3, [r7, #12]
 80029f8:	edd3 7a01 	vldr	s15, [r3, #4]
 80029fc:	ee76 7ae7 	vsub.f32	s15, s13, s15
 8002a00:	ee67 7a27 	vmul.f32	s15, s14, s15
 8002a04:	68fb      	ldr	r3, [r7, #12]
 8002a06:	edc3 7a03 	vstr	s15, [r3, #12]
	}
	obj->OldElecSpeed = obj->ElecFilterSpeed;
 8002a0a:	68fb      	ldr	r3, [r7, #12]
 8002a0c:	699a      	ldr	r2, [r3, #24]
 8002a0e:	68fb      	ldr	r3, [r7, #12]
 8002a10:	611a      	str	r2, [r3, #16]
	obj->ElecFilterSpeed = obj->ElecSpeed;
 8002a12:	68fb      	ldr	r3, [r7, #12]
 8002a14:	68da      	ldr	r2, [r3, #12]
 8002a16:	68fb      	ldr	r3, [r7, #12]
 8002a18:	619a      	str	r2, [r3, #24]
	// Need to Change the Time between ElecSpeed And OldElecSpeed According to Acceleration
	// 1.0f@10ms:0.1f@1ms=>FreqRespose100HzORTimeRespose10ms:0~1.0f(800Hz) And the FilterFreq must 10x;
	if( MATH_abs(obj->ElecFilterSpeed - obj->OldElecSpeed) > (0.1f) )
 8002a1a:	68fb      	ldr	r3, [r7, #12]
 8002a1c:	ed93 7a06 	vldr	s14, [r3, #24]
 8002a20:	68fb      	ldr	r3, [r7, #12]
 8002a22:	edd3 7a04 	vldr	s15, [r3, #16]
 8002a26:	ee77 7a67 	vsub.f32	s15, s14, s15
 8002a2a:	eeb0 0a67 	vmov.f32	s0, s15
 8002a2e:	f7ff feff 	bl	8002830 <MATH_abs>
 8002a32:	eeb0 7a40 	vmov.f32	s14, s0
 8002a36:	eddf 7a09 	vldr	s15, [pc, #36]	; 8002a5c <Speed_Run+0x150>
 8002a3a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8002a3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002a42:	dd03      	ble.n	8002a4c <Speed_Run+0x140>
	{
		obj->ElecFilterSpeed = obj->OldElecSpeed;
 8002a44:	68fb      	ldr	r3, [r7, #12]
 8002a46:	691a      	ldr	r2, [r3, #16]
 8002a48:	68fb      	ldr	r3, [r7, #12]
 8002a4a:	619a      	str	r2, [r3, #24]
	}
//	else
//	{
		Speed_UpdateElecTheta(obj);
 8002a4c:	68f8      	ldr	r0, [r7, #12]
 8002a4e:	f7ff ff0d 	bl	800286c <Speed_UpdateElecTheta>

//	obj->ElecFilterSpeed = (obj->ElecSpeed * ((1.0f)-obj->ElecFilterSpeedRatio)) + (obj->ElecFilterSpeed * obj->ElecFilterSpeedRatio);

//	obj->ElecFilterSpeed = MATH_sat(obj->ElecFilterSpeed, (2.0f), (-2.0f));

	return;
 8002a52:	bf00      	nop
}
 8002a54:	3710      	adds	r7, #16
 8002a56:	46bd      	mov	sp, r7
 8002a58:	bd80      	pop	{r7, pc}
 8002a5a:	bf00      	nop
 8002a5c:	3dcccccd 	.word	0x3dcccccd

08002a60 <CLARKE_init>:

// **************************************************************************
// the functions

CLARKE_Handle CLARKE_init(void *pMemory,const size_t numBytes)
{
 8002a60:	b480      	push	{r7}
 8002a62:	b085      	sub	sp, #20
 8002a64:	af00      	add	r7, sp, #0
 8002a66:	6078      	str	r0, [r7, #4]
 8002a68:	6039      	str	r1, [r7, #0]
  CLARKE_Handle handle;

  if(numBytes < sizeof(CLARKE_Obj))
 8002a6a:	683b      	ldr	r3, [r7, #0]
 8002a6c:	2b0b      	cmp	r3, #11
 8002a6e:	d801      	bhi.n	8002a74 <CLARKE_init+0x14>
    return((CLARKE_Handle)NULL);
 8002a70:	2300      	movs	r3, #0
 8002a72:	e002      	b.n	8002a7a <CLARKE_init+0x1a>

  // assign the handle
  handle = (CLARKE_Handle)pMemory;
 8002a74:	687b      	ldr	r3, [r7, #4]
 8002a76:	60fb      	str	r3, [r7, #12]

  return(handle);
 8002a78:	68fb      	ldr	r3, [r7, #12]
} // end of CLARKE_init() function
 8002a7a:	4618      	mov	r0, r3
 8002a7c:	3714      	adds	r7, #20
 8002a7e:	46bd      	mov	sp, r7
 8002a80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002a84:	4770      	bx	lr
 8002a86:	bf00      	nop

08002a88 <MATH_abs>:

//! \brief     Finds the absolute value 
//! \param[in] in   The input value
//! \return    The absolute value
static inline float_t MATH_abs(const float_t in)
{
 8002a88:	b480      	push	{r7}
 8002a8a:	b085      	sub	sp, #20
 8002a8c:	af00      	add	r7, sp, #0
 8002a8e:	ed87 0a01 	vstr	s0, [r7, #4]
  float_t out = in;
 8002a92:	687b      	ldr	r3, [r7, #4]
 8002a94:	60fb      	str	r3, [r7, #12]


  if(in < 0.0f)
 8002a96:	edd7 7a01 	vldr	s15, [r7, #4]
 8002a9a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8002a9e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002aa2:	d505      	bpl.n	8002ab0 <MATH_abs+0x28>
    {
      out = -in;
 8002aa4:	edd7 7a01 	vldr	s15, [r7, #4]
 8002aa8:	eef1 7a67 	vneg.f32	s15, s15
 8002aac:	edc7 7a03 	vstr	s15, [r7, #12]
    }

  return(out);
 8002ab0:	68fb      	ldr	r3, [r7, #12]
 8002ab2:	ee07 3a90 	vmov	s15, r3
} // end of MATH_abs() function
 8002ab6:	eeb0 0a67 	vmov.f32	s0, s15
 8002aba:	3714      	adds	r7, #20
 8002abc:	46bd      	mov	sp, r7
 8002abe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002ac2:	4770      	bx	lr

08002ac4 <MATH_sat>:
//! \param[in] in   The input value
//! \param[in] max  The maximum value allowed
//! \param[in] min  The minimum value allowed
//! \return    The saturated value
static inline float_t MATH_sat(const float_t in,const float_t max,const float_t min)
{
 8002ac4:	b480      	push	{r7}
 8002ac6:	b087      	sub	sp, #28
 8002ac8:	af00      	add	r7, sp, #0
 8002aca:	ed87 0a03 	vstr	s0, [r7, #12]
 8002ace:	edc7 0a02 	vstr	s1, [r7, #8]
 8002ad2:	ed87 1a01 	vstr	s2, [r7, #4]
  float_t out = in;
 8002ad6:	68fb      	ldr	r3, [r7, #12]
 8002ad8:	617b      	str	r3, [r7, #20]


  if(in < min)
 8002ada:	ed97 7a03 	vldr	s14, [r7, #12]
 8002ade:	edd7 7a01 	vldr	s15, [r7, #4]
 8002ae2:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8002ae6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002aea:	d502      	bpl.n	8002af2 <MATH_sat+0x2e>
    {
      out = min;
 8002aec:	687b      	ldr	r3, [r7, #4]
 8002aee:	617b      	str	r3, [r7, #20]
 8002af0:	e00a      	b.n	8002b08 <MATH_sat+0x44>
    }
  else if(in > max)
 8002af2:	ed97 7a03 	vldr	s14, [r7, #12]
 8002af6:	edd7 7a02 	vldr	s15, [r7, #8]
 8002afa:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8002afe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002b02:	dd01      	ble.n	8002b08 <MATH_sat+0x44>
    {
      out = max;
 8002b04:	68bb      	ldr	r3, [r7, #8]
 8002b06:	617b      	str	r3, [r7, #20]
    }

  return(out);
 8002b08:	697b      	ldr	r3, [r7, #20]
 8002b0a:	ee07 3a90 	vmov	s15, r3
} // end of MATH_sat() function
 8002b0e:	eeb0 0a67 	vmov.f32	s0, s15
 8002b12:	371c      	adds	r7, #28
 8002b14:	46bd      	mov	sp, r7
 8002b16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002b1a:	4770      	bx	lr

08002b1c <CLARKE_run>:
//! \brief     Runs the Clarke transform module for three inputs
//! \param[in] handle  The Clarke transform handle
//! \param[in] pInVec        The pointer to the input vector
//! \param[in] pOutVec       The pointer to the output vector
static inline void CLARKE_run(CLARKE_Handle handle,const MATH_vec3 *pInVec,MATH_vec2 *pOutVec)//! \Mod By Dl.K
{
 8002b1c:	b480      	push	{r7}
 8002b1e:	b089      	sub	sp, #36	; 0x24
 8002b20:	af00      	add	r7, sp, #0
 8002b22:	60f8      	str	r0, [r7, #12]
 8002b24:	60b9      	str	r1, [r7, #8]
 8002b26:	607a      	str	r2, [r7, #4]
  CLARKE_Obj *obj = (CLARKE_Obj *)handle;
 8002b28:	68fb      	ldr	r3, [r7, #12]
 8002b2a:	61fb      	str	r3, [r7, #28]

  uint_least8_t numSensors = obj->numSensors;
 8002b2c:	69fb      	ldr	r3, [r7, #28]
 8002b2e:	7a1b      	ldrb	r3, [r3, #8]
 8002b30:	76fb      	strb	r3, [r7, #27]

  float_t alpha_sf = obj->alpha_sf;
 8002b32:	69fb      	ldr	r3, [r7, #28]
 8002b34:	681b      	ldr	r3, [r3, #0]
 8002b36:	617b      	str	r3, [r7, #20]
  float_t beta_sf = obj->beta_sf;
 8002b38:	69fb      	ldr	r3, [r7, #28]
 8002b3a:	685b      	ldr	r3, [r3, #4]
 8002b3c:	613b      	str	r3, [r7, #16]


  if(numSensors == 3)
 8002b3e:	7efb      	ldrb	r3, [r7, #27]
 8002b40:	2b03      	cmp	r3, #3
 8002b42:	d125      	bne.n	8002b90 <CLARKE_run+0x74>
    {
      pOutVec->value[0] = ( (2.0f*(pInVec->value[0]) - (pInVec->value[1] + pInVec->value[2])) * alpha_sf );
 8002b44:	68bb      	ldr	r3, [r7, #8]
 8002b46:	edd3 7a00 	vldr	s15, [r3]
 8002b4a:	ee37 7aa7 	vadd.f32	s14, s15, s15
 8002b4e:	68bb      	ldr	r3, [r7, #8]
 8002b50:	edd3 6a01 	vldr	s13, [r3, #4]
 8002b54:	68bb      	ldr	r3, [r7, #8]
 8002b56:	edd3 7a02 	vldr	s15, [r3, #8]
 8002b5a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8002b5e:	ee37 7a67 	vsub.f32	s14, s14, s15
 8002b62:	edd7 7a05 	vldr	s15, [r7, #20]
 8002b66:	ee67 7a27 	vmul.f32	s15, s14, s15
 8002b6a:	687b      	ldr	r3, [r7, #4]
 8002b6c:	edc3 7a00 	vstr	s15, [r3]
      pOutVec->value[1] = (pInVec->value[1] - pInVec->value[2] * beta_sf);
 8002b70:	68bb      	ldr	r3, [r7, #8]
 8002b72:	ed93 7a01 	vldr	s14, [r3, #4]
 8002b76:	68bb      	ldr	r3, [r7, #8]
 8002b78:	edd3 6a02 	vldr	s13, [r3, #8]
 8002b7c:	edd7 7a04 	vldr	s15, [r7, #16]
 8002b80:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8002b84:	ee77 7a67 	vsub.f32	s15, s14, s15
 8002b88:	687b      	ldr	r3, [r7, #4]
 8002b8a:	edc3 7a01 	vstr	s15, [r3, #4]
 8002b8e:	e01d      	b.n	8002bcc <CLARKE_run+0xb0>
    }
  else if(numSensors == 2)
 8002b90:	7efb      	ldrb	r3, [r7, #27]
 8002b92:	2b02      	cmp	r3, #2
 8002b94:	d11a      	bne.n	8002bcc <CLARKE_run+0xb0>
    {
      pOutVec->value[0] = (pInVec->value[0] * alpha_sf);
 8002b96:	68bb      	ldr	r3, [r7, #8]
 8002b98:	ed93 7a00 	vldr	s14, [r3]
 8002b9c:	edd7 7a05 	vldr	s15, [r7, #20]
 8002ba0:	ee67 7a27 	vmul.f32	s15, s14, s15
 8002ba4:	687b      	ldr	r3, [r7, #4]
 8002ba6:	edc3 7a00 	vstr	s15, [r3]
      pOutVec->value[1] = ( (pInVec->value[0] + 2.0f*(pInVec->value[1])) * beta_sf );
 8002baa:	68bb      	ldr	r3, [r7, #8]
 8002bac:	ed93 7a00 	vldr	s14, [r3]
 8002bb0:	68bb      	ldr	r3, [r7, #8]
 8002bb2:	edd3 7a01 	vldr	s15, [r3, #4]
 8002bb6:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8002bba:	ee37 7a27 	vadd.f32	s14, s14, s15
 8002bbe:	edd7 7a04 	vldr	s15, [r7, #16]
 8002bc2:	ee67 7a27 	vmul.f32	s15, s14, s15
 8002bc6:	687b      	ldr	r3, [r7, #4]
 8002bc8:	edc3 7a01 	vstr	s15, [r3, #4]
    }

  return;
 8002bcc:	bf00      	nop
} // end of CLARKE_run() function
 8002bce:	3724      	adds	r7, #36	; 0x24
 8002bd0:	46bd      	mov	sp, r7
 8002bd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002bd6:	4770      	bx	lr

08002bd8 <CLARKE_setNumSensors>:

//! \brief     Sets the number of sensors
//! \param[in] handle  The Clarke transform handle
//! \param[in] numSensors    The number of sensors
static inline void CLARKE_setNumSensors(CLARKE_Handle handle,const uint_least8_t numSensors)//! \Mod By Dl.K
{
 8002bd8:	b480      	push	{r7}
 8002bda:	b085      	sub	sp, #20
 8002bdc:	af00      	add	r7, sp, #0
 8002bde:	6078      	str	r0, [r7, #4]
 8002be0:	460b      	mov	r3, r1
 8002be2:	70fb      	strb	r3, [r7, #3]
  CLARKE_Obj *obj = (CLARKE_Obj *)handle;
 8002be4:	687b      	ldr	r3, [r7, #4]
 8002be6:	60fb      	str	r3, [r7, #12]

  obj->numSensors = numSensors;
 8002be8:	68fb      	ldr	r3, [r7, #12]
 8002bea:	78fa      	ldrb	r2, [r7, #3]
 8002bec:	721a      	strb	r2, [r3, #8]

  return;
 8002bee:	bf00      	nop
} // end of CLARKE_setNumSensors() function
 8002bf0:	3714      	adds	r7, #20
 8002bf2:	46bd      	mov	sp, r7
 8002bf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002bf8:	4770      	bx	lr
 8002bfa:	bf00      	nop

08002bfc <CLARKE_setScaleFactors>:
//! \brief     Sets the scale factors
//! \param[in] handle  The Clarke transform handle
//! \param[in] alpha_sf      The scale factor for the alpha voltage
//! \param[in] beta_sf       The scale factor for the beta voltage
static inline void CLARKE_setScaleFactors(CLARKE_Handle handle,const float_t alpha_sf,const float_t beta_sf)//! \Mod By Dl.K
{
 8002bfc:	b480      	push	{r7}
 8002bfe:	b087      	sub	sp, #28
 8002c00:	af00      	add	r7, sp, #0
 8002c02:	60f8      	str	r0, [r7, #12]
 8002c04:	ed87 0a02 	vstr	s0, [r7, #8]
 8002c08:	edc7 0a01 	vstr	s1, [r7, #4]
  CLARKE_Obj *obj = (CLARKE_Obj *)handle;
 8002c0c:	68fb      	ldr	r3, [r7, #12]
 8002c0e:	617b      	str	r3, [r7, #20]


  obj->alpha_sf = alpha_sf;
 8002c10:	697b      	ldr	r3, [r7, #20]
 8002c12:	68ba      	ldr	r2, [r7, #8]
 8002c14:	601a      	str	r2, [r3, #0]
  obj->beta_sf = beta_sf;
 8002c16:	697b      	ldr	r3, [r7, #20]
 8002c18:	687a      	ldr	r2, [r7, #4]
 8002c1a:	605a      	str	r2, [r3, #4]

  return;
 8002c1c:	bf00      	nop
} // end of CLARKE_setScaleFactors() function
 8002c1e:	371c      	adds	r7, #28
 8002c20:	46bd      	mov	sp, r7
 8002c22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c26:	4770      	bx	lr

08002c28 <PARK_run>:
//! \brief     Runs the Park transform module
//! \param[in] handle  The Park transform handle
//! \param[in] pInVec      The pointer to the input vector
//! \param[in] pOutVec     The pointer to the output vector
static inline void PARK_run(PARK_Handle handle,const MATH_vec2 *pInVec,MATH_vec2 *pOutVec)//! \Mod By Dl.K
{
 8002c28:	b480      	push	{r7}
 8002c2a:	b08b      	sub	sp, #44	; 0x2c
 8002c2c:	af00      	add	r7, sp, #0
 8002c2e:	60f8      	str	r0, [r7, #12]
 8002c30:	60b9      	str	r1, [r7, #8]
 8002c32:	607a      	str	r2, [r7, #4]
  PARK_Obj *obj = (PARK_Obj *)handle;
 8002c34:	68fb      	ldr	r3, [r7, #12]
 8002c36:	627b      	str	r3, [r7, #36]	; 0x24

  float_t sinTh = obj->sinTh;
 8002c38:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002c3a:	681b      	ldr	r3, [r3, #0]
 8002c3c:	623b      	str	r3, [r7, #32]
  float_t cosTh = obj->cosTh;
 8002c3e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002c40:	685b      	ldr	r3, [r3, #4]
 8002c42:	61fb      	str	r3, [r7, #28]

  float_t value_0 = pInVec->value[0];
 8002c44:	68bb      	ldr	r3, [r7, #8]
 8002c46:	681b      	ldr	r3, [r3, #0]
 8002c48:	61bb      	str	r3, [r7, #24]
  float_t value_1 = pInVec->value[1];
 8002c4a:	68bb      	ldr	r3, [r7, #8]
 8002c4c:	685b      	ldr	r3, [r3, #4]
 8002c4e:	617b      	str	r3, [r7, #20]


  pOutVec->value[0] = (value_0*cosTh) + (value_1*sinTh);
 8002c50:	ed97 7a06 	vldr	s14, [r7, #24]
 8002c54:	edd7 7a07 	vldr	s15, [r7, #28]
 8002c58:	ee27 7a27 	vmul.f32	s14, s14, s15
 8002c5c:	edd7 6a05 	vldr	s13, [r7, #20]
 8002c60:	edd7 7a08 	vldr	s15, [r7, #32]
 8002c64:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8002c68:	ee77 7a27 	vadd.f32	s15, s14, s15
 8002c6c:	687b      	ldr	r3, [r7, #4]
 8002c6e:	edc3 7a00 	vstr	s15, [r3]
  pOutVec->value[1] = (value_1*cosTh) - (value_0*sinTh);
 8002c72:	ed97 7a05 	vldr	s14, [r7, #20]
 8002c76:	edd7 7a07 	vldr	s15, [r7, #28]
 8002c7a:	ee27 7a27 	vmul.f32	s14, s14, s15
 8002c7e:	edd7 6a06 	vldr	s13, [r7, #24]
 8002c82:	edd7 7a08 	vldr	s15, [r7, #32]
 8002c86:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8002c8a:	ee77 7a67 	vsub.f32	s15, s14, s15
 8002c8e:	687b      	ldr	r3, [r7, #4]
 8002c90:	edc3 7a01 	vstr	s15, [r3, #4]

  return;
 8002c94:	bf00      	nop
} // end of PARK_run() function
 8002c96:	372c      	adds	r7, #44	; 0x2c
 8002c98:	46bd      	mov	sp, r7
 8002c9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c9e:	4770      	bx	lr

08002ca0 <PARK_setPhasor>:

//! \brief     Sets the cosine/sine phasor for the inverse Park transform
//! \param[in] handle   The Park transform handle
//! \param[in] pPhasor      The pointer to the cosine/sine phasor, pu
static inline void PARK_setPhasor(PARK_Handle handle,const MATH_vec2 *pPhasor)//! \Mod By Dl.K
{
 8002ca0:	b480      	push	{r7}
 8002ca2:	b085      	sub	sp, #20
 8002ca4:	af00      	add	r7, sp, #0
 8002ca6:	6078      	str	r0, [r7, #4]
 8002ca8:	6039      	str	r1, [r7, #0]
  PARK_Obj *obj = (PARK_Obj *)handle;
 8002caa:	687b      	ldr	r3, [r7, #4]
 8002cac:	60fb      	str	r3, [r7, #12]

  obj->cosTh = pPhasor->value[0];
 8002cae:	683b      	ldr	r3, [r7, #0]
 8002cb0:	681a      	ldr	r2, [r3, #0]
 8002cb2:	68fb      	ldr	r3, [r7, #12]
 8002cb4:	605a      	str	r2, [r3, #4]
  obj->sinTh = pPhasor->value[1];
 8002cb6:	683b      	ldr	r3, [r7, #0]
 8002cb8:	685a      	ldr	r2, [r3, #4]
 8002cba:	68fb      	ldr	r3, [r7, #12]
 8002cbc:	601a      	str	r2, [r3, #0]

  return;
 8002cbe:	bf00      	nop
} // end of PARK_setPhasor() function
 8002cc0:	3714      	adds	r7, #20
 8002cc2:	46bd      	mov	sp, r7
 8002cc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002cc8:	4770      	bx	lr
 8002cca:	bf00      	nop

08002ccc <IPARK_run>:
//! \brief     Runs the inverse Park transform module
//! \param[in] handle  The inverse Park transform handle
//! \param[in] pInVec       The pointer to the input vector
//! \param[in] pOutVec      The pointer to the output vector
static inline void IPARK_run(IPARK_Handle handle,const MATH_vec2 *pInVec,MATH_vec2 *pOutVec)//! \Mod By Dl.K
{
 8002ccc:	b480      	push	{r7}
 8002cce:	b08b      	sub	sp, #44	; 0x2c
 8002cd0:	af00      	add	r7, sp, #0
 8002cd2:	60f8      	str	r0, [r7, #12]
 8002cd4:	60b9      	str	r1, [r7, #8]
 8002cd6:	607a      	str	r2, [r7, #4]
  IPARK_Obj *obj = (IPARK_Obj *)handle;
 8002cd8:	68fb      	ldr	r3, [r7, #12]
 8002cda:	627b      	str	r3, [r7, #36]	; 0x24

  float_t sinTh = obj->sinTh;
 8002cdc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002cde:	681b      	ldr	r3, [r3, #0]
 8002ce0:	623b      	str	r3, [r7, #32]
  float_t cosTh = obj->cosTh;
 8002ce2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002ce4:	685b      	ldr	r3, [r3, #4]
 8002ce6:	61fb      	str	r3, [r7, #28]

  float_t value_0 = pInVec->value[0];
 8002ce8:	68bb      	ldr	r3, [r7, #8]
 8002cea:	681b      	ldr	r3, [r3, #0]
 8002cec:	61bb      	str	r3, [r7, #24]
  float_t value_1 = pInVec->value[1];
 8002cee:	68bb      	ldr	r3, [r7, #8]
 8002cf0:	685b      	ldr	r3, [r3, #4]
 8002cf2:	617b      	str	r3, [r7, #20]


  pOutVec->value[0] = (value_0*cosTh) - (value_1*sinTh);
 8002cf4:	ed97 7a06 	vldr	s14, [r7, #24]
 8002cf8:	edd7 7a07 	vldr	s15, [r7, #28]
 8002cfc:	ee27 7a27 	vmul.f32	s14, s14, s15
 8002d00:	edd7 6a05 	vldr	s13, [r7, #20]
 8002d04:	edd7 7a08 	vldr	s15, [r7, #32]
 8002d08:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8002d0c:	ee77 7a67 	vsub.f32	s15, s14, s15
 8002d10:	687b      	ldr	r3, [r7, #4]
 8002d12:	edc3 7a00 	vstr	s15, [r3]
  pOutVec->value[1] = (value_1*cosTh) + (value_0*sinTh);
 8002d16:	ed97 7a05 	vldr	s14, [r7, #20]
 8002d1a:	edd7 7a07 	vldr	s15, [r7, #28]
 8002d1e:	ee27 7a27 	vmul.f32	s14, s14, s15
 8002d22:	edd7 6a06 	vldr	s13, [r7, #24]
 8002d26:	edd7 7a08 	vldr	s15, [r7, #32]
 8002d2a:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8002d2e:	ee77 7a27 	vadd.f32	s15, s14, s15
 8002d32:	687b      	ldr	r3, [r7, #4]
 8002d34:	edc3 7a01 	vstr	s15, [r3, #4]

  return;
 8002d38:	bf00      	nop
} // end of IPARK_run() function
 8002d3a:	372c      	adds	r7, #44	; 0x2c
 8002d3c:	46bd      	mov	sp, r7
 8002d3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002d42:	4770      	bx	lr

08002d44 <IPARK_setPhasor>:

//! \brief     Sets the cosine/sine phasor for the inverse Park transform
//! \param[in] handle   The inverse Park transform handle
//! \param[in] pPhasor  The pointer to the cosine/sine phasor, pu
static inline void IPARK_setPhasor(IPARK_Handle handle,const MATH_vec2 *pPhasor)//! \Mod By Dl.K
{
 8002d44:	b480      	push	{r7}
 8002d46:	b085      	sub	sp, #20
 8002d48:	af00      	add	r7, sp, #0
 8002d4a:	6078      	str	r0, [r7, #4]
 8002d4c:	6039      	str	r1, [r7, #0]
  IPARK_Obj *obj = (IPARK_Obj *)handle;
 8002d4e:	687b      	ldr	r3, [r7, #4]
 8002d50:	60fb      	str	r3, [r7, #12]

  obj->cosTh = pPhasor->value[0];
 8002d52:	683b      	ldr	r3, [r7, #0]
 8002d54:	681a      	ldr	r2, [r3, #0]
 8002d56:	68fb      	ldr	r3, [r7, #12]
 8002d58:	605a      	str	r2, [r3, #4]
  obj->sinTh = pPhasor->value[1];
 8002d5a:	683b      	ldr	r3, [r7, #0]
 8002d5c:	685a      	ldr	r2, [r3, #4]
 8002d5e:	68fb      	ldr	r3, [r7, #12]
 8002d60:	601a      	str	r2, [r3, #0]

  return;
 8002d62:	bf00      	nop
} // end of IPARK_setPhasor() function
 8002d64:	3714      	adds	r7, #20
 8002d66:	46bd      	mov	sp, r7
 8002d68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002d6c:	4770      	bx	lr
 8002d6e:	bf00      	nop

08002d70 <FILTER_FO_run>:
//!
//! \param[in] handle      The filter handle
//! \param[in] inputValue  The input value to filter
//! \return    The output value from the filter
static inline float_t FILTER_FO_run(FILTER_FO_Handle handle,const float_t inputValue)
{
 8002d70:	b5b0      	push	{r4, r5, r7, lr}
 8002d72:	b090      	sub	sp, #64	; 0x40
 8002d74:	af00      	add	r7, sp, #0
 8002d76:	6078      	str	r0, [r7, #4]
 8002d78:	ed87 0a00 	vstr	s0, [r7]
  FILTER_FO_Obj *obj = (FILTER_FO_Obj *)handle;
 8002d7c:	687b      	ldr	r3, [r7, #4]
 8002d7e:	63fb      	str	r3, [r7, #60]	; 0x3c

  double a1 = obj->a1;
 8002d80:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8002d82:	681b      	ldr	r3, [r3, #0]
 8002d84:	4618      	mov	r0, r3
 8002d86:	f7fd fe1f 	bl	80009c8 <__aeabi_f2d>
 8002d8a:	4602      	mov	r2, r0
 8002d8c:	460b      	mov	r3, r1
 8002d8e:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
  double b0 = obj->b0;
 8002d92:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8002d94:	685b      	ldr	r3, [r3, #4]
 8002d96:	4618      	mov	r0, r3
 8002d98:	f7fd fe16 	bl	80009c8 <__aeabi_f2d>
 8002d9c:	4602      	mov	r2, r0
 8002d9e:	460b      	mov	r3, r1
 8002da0:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
  double b1 = obj->b1;
 8002da4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8002da6:	689b      	ldr	r3, [r3, #8]
 8002da8:	4618      	mov	r0, r3
 8002daa:	f7fd fe0d 	bl	80009c8 <__aeabi_f2d>
 8002dae:	4602      	mov	r2, r0
 8002db0:	460b      	mov	r3, r1
 8002db2:	e9c7 2308 	strd	r2, r3, [r7, #32]
  double x1 = obj->x1;
 8002db6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8002db8:	68db      	ldr	r3, [r3, #12]
 8002dba:	4618      	mov	r0, r3
 8002dbc:	f7fd fe04 	bl	80009c8 <__aeabi_f2d>
 8002dc0:	4602      	mov	r2, r0
 8002dc2:	460b      	mov	r3, r1
 8002dc4:	e9c7 2306 	strd	r2, r3, [r7, #24]
  double y1 = obj->y1;
 8002dc8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8002dca:	691b      	ldr	r3, [r3, #16]
 8002dcc:	4618      	mov	r0, r3
 8002dce:	f7fd fdfb 	bl	80009c8 <__aeabi_f2d>
 8002dd2:	4602      	mov	r2, r0
 8002dd4:	460b      	mov	r3, r1
 8002dd6:	e9c7 2304 	strd	r2, r3, [r7, #16]


  // compute the output
  settestpin();
 8002dda:	f010 fab3 	bl	8013344 <settestpin>
  double y0 = (b0 * inputValue) + (b1 * x1) - (a1 * y1);
 8002dde:	6838      	ldr	r0, [r7, #0]
 8002de0:	f7fd fdf2 	bl	80009c8 <__aeabi_f2d>
 8002de4:	4602      	mov	r2, r0
 8002de6:	460b      	mov	r3, r1
 8002de8:	4610      	mov	r0, r2
 8002dea:	4619      	mov	r1, r3
 8002dec:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 8002df0:	f7fd fe3e 	bl	8000a70 <__aeabi_dmul>
 8002df4:	4602      	mov	r2, r0
 8002df6:	460b      	mov	r3, r1
 8002df8:	4614      	mov	r4, r2
 8002dfa:	461d      	mov	r5, r3
 8002dfc:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8002e00:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8002e04:	f7fd fe34 	bl	8000a70 <__aeabi_dmul>
 8002e08:	4602      	mov	r2, r0
 8002e0a:	460b      	mov	r3, r1
 8002e0c:	4620      	mov	r0, r4
 8002e0e:	4629      	mov	r1, r5
 8002e10:	f7fd fc7c 	bl	800070c <__adddf3>
 8002e14:	4602      	mov	r2, r0
 8002e16:	460b      	mov	r3, r1
 8002e18:	4614      	mov	r4, r2
 8002e1a:	461d      	mov	r5, r3
 8002e1c:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8002e20:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8002e24:	f7fd fe24 	bl	8000a70 <__aeabi_dmul>
 8002e28:	4602      	mov	r2, r0
 8002e2a:	460b      	mov	r3, r1
 8002e2c:	4620      	mov	r0, r4
 8002e2e:	4629      	mov	r1, r5
 8002e30:	f7fd fc6a 	bl	8000708 <__aeabi_dsub>
 8002e34:	4602      	mov	r2, r0
 8002e36:	460b      	mov	r3, r1
 8002e38:	e9c7 2302 	strd	r2, r3, [r7, #8]
  //double y0 = 0;
  cleartestpin();
 8002e3c:	f010 fa8c 	bl	8013358 <cleartestpin>


  // store values for next time
  obj->x1 = inputValue;
 8002e40:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8002e42:	683a      	ldr	r2, [r7, #0]
 8002e44:	60da      	str	r2, [r3, #12]
  obj->y1 = (float_t)y0;
 8002e46:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 8002e4a:	f7fe f8cb 	bl	8000fe4 <__aeabi_d2f>
 8002e4e:	4602      	mov	r2, r0
 8002e50:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8002e52:	611a      	str	r2, [r3, #16]

  return((float_t)y0);
 8002e54:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 8002e58:	f7fe f8c4 	bl	8000fe4 <__aeabi_d2f>
 8002e5c:	4603      	mov	r3, r0
 8002e5e:	ee07 3a90 	vmov	s15, r3
} // end of FILTER_FO_run() function
 8002e62:	eeb0 0a67 	vmov.f32	s0, s15
 8002e66:	3740      	adds	r7, #64	; 0x40
 8002e68:	46bd      	mov	sp, r7
 8002e6a:	bdb0      	pop	{r4, r5, r7, pc}

08002e6c <OFFSET_run>:
//!            x -> The ADC measurement
//!
//! \param[in] handle  The offset handle
//! \param[in] inputValue    The input value to offset filter
static inline void OFFSET_run(OFFSET_Handle handle,const float_t inputValue)
{
 8002e6c:	b580      	push	{r7, lr}
 8002e6e:	b084      	sub	sp, #16
 8002e70:	af00      	add	r7, sp, #0
 8002e72:	6078      	str	r0, [r7, #4]
 8002e74:	ed87 0a00 	vstr	s0, [r7]
  OFFSET_Obj *obj = (OFFSET_Obj *)handle;
 8002e78:	687b      	ldr	r3, [r7, #4]
 8002e7a:	60fb      	str	r3, [r7, #12]

  obj->value = FILTER_FO_run(obj->filterHandle,inputValue);
 8002e7c:	68fb      	ldr	r3, [r7, #12]
 8002e7e:	69db      	ldr	r3, [r3, #28]
 8002e80:	4618      	mov	r0, r3
 8002e82:	ed97 0a00 	vldr	s0, [r7]
 8002e86:	f7ff ff73 	bl	8002d70 <FILTER_FO_run>
 8002e8a:	eef0 7a40 	vmov.f32	s15, s0
 8002e8e:	68fb      	ldr	r3, [r7, #12]
 8002e90:	edc3 7a00 	vstr	s15, [r3]

  return;
 8002e94:	bf00      	nop
} // end of OFFSET_run() function
 8002e96:	3710      	adds	r7, #16
 8002e98:	46bd      	mov	sp, r7
 8002e9a:	bd80      	pop	{r7, pc}

08002e9c <PID_run>:
//! \param[in] handle      The PID controller handle
//! \param[in] refValue    The reference value to the controller
//! \param[in] fbackValue  The feedback value to the controller
//! \param[in] pOutValue   The pointer to the controller output value
static inline void PID_run(PID_Handle handle,const float_t refValue,const float_t fbackValue,float_t *pOutValue)//! \Mod By Dl.K
{
 8002e9c:	b580      	push	{r7, lr}
 8002e9e:	b088      	sub	sp, #32
 8002ea0:	af00      	add	r7, sp, #0
 8002ea2:	60f8      	str	r0, [r7, #12]
 8002ea4:	ed87 0a02 	vstr	s0, [r7, #8]
 8002ea8:	edc7 0a01 	vstr	s1, [r7, #4]
 8002eac:	6039      	str	r1, [r7, #0]
  PID_Obj *obj = (PID_Obj *)handle;
 8002eae:	68fb      	ldr	r3, [r7, #12]
 8002eb0:	61fb      	str	r3, [r7, #28]

  float_t Error;
  float_t Up,Ui;


  Error = refValue - fbackValue;
 8002eb2:	ed97 7a02 	vldr	s14, [r7, #8]
 8002eb6:	edd7 7a01 	vldr	s15, [r7, #4]
 8002eba:	ee77 7a67 	vsub.f32	s15, s14, s15
 8002ebe:	edc7 7a06 	vstr	s15, [r7, #24]

  Ui = obj->Ui;                                                  // load the previous integral output
 8002ec2:	69fb      	ldr	r3, [r7, #28]
 8002ec4:	68db      	ldr	r3, [r3, #12]
 8002ec6:	617b      	str	r3, [r7, #20]
  Up = (obj->Kp * Error);                                    // Compute the proportional output
 8002ec8:	69fb      	ldr	r3, [r7, #28]
 8002eca:	ed93 7a00 	vldr	s14, [r3]
 8002ece:	edd7 7a06 	vldr	s15, [r7, #24]
 8002ed2:	ee67 7a27 	vmul.f32	s15, s14, s15
 8002ed6:	edc7 7a04 	vstr	s15, [r7, #16]
  Ui = MATH_sat(Ui + (obj->Ki * Up), obj->outMax, obj->outMin);  // Compute the integral output
 8002eda:	69fb      	ldr	r3, [r7, #28]
 8002edc:	ed93 7a01 	vldr	s14, [r3, #4]
 8002ee0:	edd7 7a04 	vldr	s15, [r7, #16]
 8002ee4:	ee27 7a27 	vmul.f32	s14, s14, s15
 8002ee8:	edd7 7a05 	vldr	s15, [r7, #20]
 8002eec:	ee77 6a27 	vadd.f32	s13, s14, s15
 8002ef0:	69fb      	ldr	r3, [r7, #28]
 8002ef2:	ed93 7a07 	vldr	s14, [r3, #28]
 8002ef6:	69fb      	ldr	r3, [r7, #28]
 8002ef8:	edd3 7a06 	vldr	s15, [r3, #24]
 8002efc:	eeb0 0a66 	vmov.f32	s0, s13
 8002f00:	eef0 0a47 	vmov.f32	s1, s14
 8002f04:	eeb0 1a67 	vmov.f32	s2, s15
 8002f08:	f7ff fddc 	bl	8002ac4 <MATH_sat>
 8002f0c:	ed87 0a05 	vstr	s0, [r7, #20]

  obj->Ui = Ui;                                                  // store the intetral output
 8002f10:	69fb      	ldr	r3, [r7, #28]
 8002f12:	697a      	ldr	r2, [r7, #20]
 8002f14:	60da      	str	r2, [r3, #12]
  obj->refValue = refValue;
 8002f16:	69fb      	ldr	r3, [r7, #28]
 8002f18:	68ba      	ldr	r2, [r7, #8]
 8002f1a:	611a      	str	r2, [r3, #16]
  obj->fbackValue = fbackValue;
 8002f1c:	69fb      	ldr	r3, [r7, #28]
 8002f1e:	687a      	ldr	r2, [r7, #4]
 8002f20:	615a      	str	r2, [r3, #20]

  *pOutValue = MATH_sat(Up + Ui, obj->outMax, obj->outMin);          // Saturate the output
 8002f22:	ed97 7a04 	vldr	s14, [r7, #16]
 8002f26:	edd7 7a05 	vldr	s15, [r7, #20]
 8002f2a:	ee77 6a27 	vadd.f32	s13, s14, s15
 8002f2e:	69fb      	ldr	r3, [r7, #28]
 8002f30:	ed93 7a07 	vldr	s14, [r3, #28]
 8002f34:	69fb      	ldr	r3, [r7, #28]
 8002f36:	edd3 7a06 	vldr	s15, [r3, #24]
 8002f3a:	eeb0 0a66 	vmov.f32	s0, s13
 8002f3e:	eef0 0a47 	vmov.f32	s1, s14
 8002f42:	eeb0 1a67 	vmov.f32	s2, s15
 8002f46:	f7ff fdbd 	bl	8002ac4 <MATH_sat>
 8002f4a:	eef0 7a40 	vmov.f32	s15, s0
 8002f4e:	683b      	ldr	r3, [r7, #0]
 8002f50:	edc3 7a00 	vstr	s15, [r3]

  return;
 8002f54:	bf00      	nop
} // end of PID_run() function
 8002f56:	3720      	adds	r7, #32
 8002f58:	46bd      	mov	sp, r7
 8002f5a:	bd80      	pop	{r7, pc}

08002f5c <PID_run_spd>:
//! \param[in] handle      The PID controller handle
//! \param[in] refValue    The reference value to the controller
//! \param[in] fbackValue  The feedback value to the controller
//! \param[in] pOutValue   The pointer to the controller output value
static inline void PID_run_spd(PID_Handle handle,const float_t refValue,const float_t fbackValue,float_t *pOutValue)//! \Mod By Dl.K
{
 8002f5c:	b580      	push	{r7, lr}
 8002f5e:	b088      	sub	sp, #32
 8002f60:	af00      	add	r7, sp, #0
 8002f62:	60f8      	str	r0, [r7, #12]
 8002f64:	ed87 0a02 	vstr	s0, [r7, #8]
 8002f68:	edc7 0a01 	vstr	s1, [r7, #4]
 8002f6c:	6039      	str	r1, [r7, #0]
  PID_Obj *obj = (PID_Obj *)handle;
 8002f6e:	68fb      	ldr	r3, [r7, #12]
 8002f70:	61fb      	str	r3, [r7, #28]

  float_t Error;
  float_t Up,Ui;

  Error = refValue - fbackValue;
 8002f72:	ed97 7a02 	vldr	s14, [r7, #8]
 8002f76:	edd7 7a01 	vldr	s15, [r7, #4]
 8002f7a:	ee77 7a67 	vsub.f32	s15, s14, s15
 8002f7e:	edc7 7a06 	vstr	s15, [r7, #24]

  Ui = obj->Ui;                                                     // load the previous integral output
 8002f82:	69fb      	ldr	r3, [r7, #28]
 8002f84:	68db      	ldr	r3, [r3, #12]
 8002f86:	617b      	str	r3, [r7, #20]
  Up = (obj->Kp * Error);                                       // Compute the proportional output
 8002f88:	69fb      	ldr	r3, [r7, #28]
 8002f8a:	ed93 7a00 	vldr	s14, [r3]
 8002f8e:	edd7 7a06 	vldr	s15, [r7, #24]
 8002f92:	ee67 7a27 	vmul.f32	s15, s14, s15
 8002f96:	edc7 7a04 	vstr	s15, [r7, #16]
  Ui = MATH_sat(Ui + (obj->Ki * Error), obj->outMax, obj->outMin);  // Compute the integral output
 8002f9a:	69fb      	ldr	r3, [r7, #28]
 8002f9c:	ed93 7a01 	vldr	s14, [r3, #4]
 8002fa0:	edd7 7a06 	vldr	s15, [r7, #24]
 8002fa4:	ee27 7a27 	vmul.f32	s14, s14, s15
 8002fa8:	edd7 7a05 	vldr	s15, [r7, #20]
 8002fac:	ee77 6a27 	vadd.f32	s13, s14, s15
 8002fb0:	69fb      	ldr	r3, [r7, #28]
 8002fb2:	ed93 7a07 	vldr	s14, [r3, #28]
 8002fb6:	69fb      	ldr	r3, [r7, #28]
 8002fb8:	edd3 7a06 	vldr	s15, [r3, #24]
 8002fbc:	eeb0 0a66 	vmov.f32	s0, s13
 8002fc0:	eef0 0a47 	vmov.f32	s1, s14
 8002fc4:	eeb0 1a67 	vmov.f32	s2, s15
 8002fc8:	f7ff fd7c 	bl	8002ac4 <MATH_sat>
 8002fcc:	ed87 0a05 	vstr	s0, [r7, #20]

  obj->Ui = Ui;                                                     // store the intetral output
 8002fd0:	69fb      	ldr	r3, [r7, #28]
 8002fd2:	697a      	ldr	r2, [r7, #20]
 8002fd4:	60da      	str	r2, [r3, #12]
  obj->refValue = refValue;
 8002fd6:	69fb      	ldr	r3, [r7, #28]
 8002fd8:	68ba      	ldr	r2, [r7, #8]
 8002fda:	611a      	str	r2, [r3, #16]
  obj->fbackValue = fbackValue;
 8002fdc:	69fb      	ldr	r3, [r7, #28]
 8002fde:	687a      	ldr	r2, [r7, #4]
 8002fe0:	615a      	str	r2, [r3, #20]

  *pOutValue = MATH_sat(Up + Ui, obj->outMax, obj->outMin);             // Saturate the output
 8002fe2:	ed97 7a04 	vldr	s14, [r7, #16]
 8002fe6:	edd7 7a05 	vldr	s15, [r7, #20]
 8002fea:	ee77 6a27 	vadd.f32	s13, s14, s15
 8002fee:	69fb      	ldr	r3, [r7, #28]
 8002ff0:	ed93 7a07 	vldr	s14, [r3, #28]
 8002ff4:	69fb      	ldr	r3, [r7, #28]
 8002ff6:	edd3 7a06 	vldr	s15, [r3, #24]
 8002ffa:	eeb0 0a66 	vmov.f32	s0, s13
 8002ffe:	eef0 0a47 	vmov.f32	s1, s14
 8003002:	eeb0 1a67 	vmov.f32	s2, s15
 8003006:	f7ff fd5d 	bl	8002ac4 <MATH_sat>
 800300a:	eef0 7a40 	vmov.f32	s15, s0
 800300e:	683b      	ldr	r3, [r7, #0]
 8003010:	edc3 7a00 	vstr	s15, [r3]

  return;
 8003014:	bf00      	nop
} // end of PID_run_spd() function
 8003016:	3720      	adds	r7, #32
 8003018:	46bd      	mov	sp, r7
 800301a:	bd80      	pop	{r7, pc}

0800301c <PID_setGains>:
//! \param[in] handle  The PID controller handle
//! \param[in] Kp      The proportional gain for the PID controller
//! \param[in] Ki      The integrator gain for the PID controller
//! \param[in] Kd      The derivative gain for the PID controller
static inline void PID_setGains(PID_Handle handle,const float_t Kp,const float_t Ki,const float_t Kd)//! \Mod By Dl.K
{
 800301c:	b480      	push	{r7}
 800301e:	b087      	sub	sp, #28
 8003020:	af00      	add	r7, sp, #0
 8003022:	60f8      	str	r0, [r7, #12]
 8003024:	ed87 0a02 	vstr	s0, [r7, #8]
 8003028:	edc7 0a01 	vstr	s1, [r7, #4]
 800302c:	ed87 1a00 	vstr	s2, [r7]
  PID_Obj *obj = (PID_Obj *)handle;
 8003030:	68fb      	ldr	r3, [r7, #12]
 8003032:	617b      	str	r3, [r7, #20]

  obj->Kp = Kp;
 8003034:	697b      	ldr	r3, [r7, #20]
 8003036:	68ba      	ldr	r2, [r7, #8]
 8003038:	601a      	str	r2, [r3, #0]
  obj->Ki = Ki;
 800303a:	697b      	ldr	r3, [r7, #20]
 800303c:	687a      	ldr	r2, [r7, #4]
 800303e:	605a      	str	r2, [r3, #4]
  obj->Kd = Kd;
 8003040:	697b      	ldr	r3, [r7, #20]
 8003042:	683a      	ldr	r2, [r7, #0]
 8003044:	609a      	str	r2, [r3, #8]

  return;
 8003046:	bf00      	nop
} // end of PID_setGains() function
 8003048:	371c      	adds	r7, #28
 800304a:	46bd      	mov	sp, r7
 800304c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003050:	4770      	bx	lr
 8003052:	bf00      	nop

08003054 <PID_setKi>:

//! \brief     Sets the integral gain in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] Ki      The integral gain for the PID controller
static inline void PID_setKi(PID_Handle handle,const float_t Ki)//! \Mod By Dl.K
{
 8003054:	b480      	push	{r7}
 8003056:	b085      	sub	sp, #20
 8003058:	af00      	add	r7, sp, #0
 800305a:	6078      	str	r0, [r7, #4]
 800305c:	ed87 0a00 	vstr	s0, [r7]
  PID_Obj *obj = (PID_Obj *)handle;
 8003060:	687b      	ldr	r3, [r7, #4]
 8003062:	60fb      	str	r3, [r7, #12]

  obj->Ki = Ki;
 8003064:	68fb      	ldr	r3, [r7, #12]
 8003066:	683a      	ldr	r2, [r7, #0]
 8003068:	605a      	str	r2, [r3, #4]

  return;
 800306a:	bf00      	nop
} // end of PID_setKi() function
 800306c:	3714      	adds	r7, #20
 800306e:	46bd      	mov	sp, r7
 8003070:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003074:	4770      	bx	lr
 8003076:	bf00      	nop

08003078 <PID_setKp>:

//! \brief     Sets the proportional gain in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] Kp      The proportional gain for the PID controller
static inline void PID_setKp(PID_Handle handle,const float_t Kp)//! \Mod By Dl.K
{
 8003078:	b480      	push	{r7}
 800307a:	b085      	sub	sp, #20
 800307c:	af00      	add	r7, sp, #0
 800307e:	6078      	str	r0, [r7, #4]
 8003080:	ed87 0a00 	vstr	s0, [r7]
  PID_Obj *obj = (PID_Obj *)handle;
 8003084:	687b      	ldr	r3, [r7, #4]
 8003086:	60fb      	str	r3, [r7, #12]

  obj->Kp = Kp;
 8003088:	68fb      	ldr	r3, [r7, #12]
 800308a:	683a      	ldr	r2, [r7, #0]
 800308c:	601a      	str	r2, [r3, #0]

  return;
 800308e:	bf00      	nop
} // end of PID_setKp() function
 8003090:	3714      	adds	r7, #20
 8003092:	46bd      	mov	sp, r7
 8003094:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003098:	4770      	bx	lr
 800309a:	bf00      	nop

0800309c <PID_setMinMax>:
//! \brief     Sets the minimum and maximum output value allowed in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] outMin  The minimum output value allowed
//! \param[in] outMax  The maximum output value allowed
static inline void PID_setMinMax(PID_Handle handle,const float_t outMin,const float_t outMax)//! \Mod By Dl.K
{
 800309c:	b480      	push	{r7}
 800309e:	b087      	sub	sp, #28
 80030a0:	af00      	add	r7, sp, #0
 80030a2:	60f8      	str	r0, [r7, #12]
 80030a4:	ed87 0a02 	vstr	s0, [r7, #8]
 80030a8:	edc7 0a01 	vstr	s1, [r7, #4]
  PID_Obj *obj = (PID_Obj *)handle;
 80030ac:	68fb      	ldr	r3, [r7, #12]
 80030ae:	617b      	str	r3, [r7, #20]

  obj->outMin = outMin;
 80030b0:	697b      	ldr	r3, [r7, #20]
 80030b2:	68ba      	ldr	r2, [r7, #8]
 80030b4:	619a      	str	r2, [r3, #24]
  obj->outMax = outMax;
 80030b6:	697b      	ldr	r3, [r7, #20]
 80030b8:	687a      	ldr	r2, [r7, #4]
 80030ba:	61da      	str	r2, [r3, #28]

  return;
 80030bc:	bf00      	nop
} // end of PID_setMinMax() function
 80030be:	371c      	adds	r7, #28
 80030c0:	46bd      	mov	sp, r7
 80030c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80030c6:	4770      	bx	lr

080030c8 <PID_setUi>:

//! \brief     Sets the integrator start value in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] Ui         The integral start value for the PID controller
static inline void PID_setUi(PID_Handle handle,const float_t Ui)//! \Mod By Dl.K
{
 80030c8:	b480      	push	{r7}
 80030ca:	b085      	sub	sp, #20
 80030cc:	af00      	add	r7, sp, #0
 80030ce:	6078      	str	r0, [r7, #4]
 80030d0:	ed87 0a00 	vstr	s0, [r7]
  PID_Obj *obj = (PID_Obj *)handle;
 80030d4:	687b      	ldr	r3, [r7, #4]
 80030d6:	60fb      	str	r3, [r7, #12]

  obj->Ui = Ui;
 80030d8:	68fb      	ldr	r3, [r7, #12]
 80030da:	683a      	ldr	r2, [r7, #0]
 80030dc:	60da      	str	r2, [r3, #12]

  return;
 80030de:	bf00      	nop
} // end of PID_setUi() function
 80030e0:	3714      	adds	r7, #20
 80030e2:	46bd      	mov	sp, r7
 80030e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80030e8:	4770      	bx	lr
 80030ea:	bf00      	nop

080030ec <SVGEN_run>:
//! \brief	Implements a SVM that saturates at the level of MaxModulation.
//! \param[in] handle  The space vector generator (SVGEN) handle
//! \param[in] pVab    The pointer to the a/b voltages
//! \param[in] pT      The pointer to the pwm duty cycle time durations
static inline void SVGEN_run(SVGEN_Handle handle,const MATH_vec2 *pVab,MATH_vec3 *pT)//! \Mod By Dl.K
{
 80030ec:	b480      	push	{r7}
 80030ee:	b08d      	sub	sp, #52	; 0x34
 80030f0:	af00      	add	r7, sp, #0
 80030f2:	60f8      	str	r0, [r7, #12]
 80030f4:	60b9      	str	r1, [r7, #8]
 80030f6:	607a      	str	r2, [r7, #4]

  float_t Vmax,Vmin,Vcom;
  float_t Va,Vb,Vc;
  float_t Va_tmp = -(pVab->value[0]*0.5f);
 80030f8:	68bb      	ldr	r3, [r7, #8]
 80030fa:	edd3 7a00 	vldr	s15, [r3]
 80030fe:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 8003102:	ee67 7a87 	vmul.f32	s15, s15, s14
 8003106:	eef1 7a67 	vneg.f32	s15, s15
 800310a:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
  float_t Vb_tmp = (SVGEN_SQRT3_OVER_2 * pVab->value[1]);
 800310e:	68bb      	ldr	r3, [r7, #8]
 8003110:	edd3 7a01 	vldr	s15, [r3, #4]
 8003114:	ed9f 7a3a 	vldr	s14, [pc, #232]	; 8003200 <SVGEN_run+0x114>
 8003118:	ee67 7a87 	vmul.f32	s15, s15, s14
 800311c:	edc7 7a08 	vstr	s15, [r7, #32]
  
  Va = pVab->value[0];  //alpha
 8003120:	68bb      	ldr	r3, [r7, #8]
 8003122:	681b      	ldr	r3, [r3, #0]
 8003124:	61fb      	str	r3, [r7, #28]
  Vb = Va_tmp + Vb_tmp; //-0.5*alpha + sqrt(3)/2 * beta;
 8003126:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 800312a:	edd7 7a08 	vldr	s15, [r7, #32]
 800312e:	ee77 7a27 	vadd.f32	s15, s14, s15
 8003132:	edc7 7a06 	vstr	s15, [r7, #24]
  Vc = Va_tmp - Vb_tmp; //-0.5*alpha - sqrt(3)/2 * beta;
 8003136:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 800313a:	edd7 7a08 	vldr	s15, [r7, #32]
 800313e:	ee77 7a67 	vsub.f32	s15, s14, s15
 8003142:	edc7 7a05 	vstr	s15, [r7, #20]
	
  Vmax=0;
 8003146:	f04f 0300 	mov.w	r3, #0
 800314a:	62fb      	str	r3, [r7, #44]	; 0x2c
  Vmin=0;
 800314c:	f04f 0300 	mov.w	r3, #0
 8003150:	62bb      	str	r3, [r7, #40]	; 0x28

  // find order Vmin,Vmid,Vmax
  if (Va > Vb)			
 8003152:	ed97 7a07 	vldr	s14, [r7, #28]
 8003156:	edd7 7a06 	vldr	s15, [r7, #24]
 800315a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800315e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003162:	dd04      	ble.n	800316e <SVGEN_run+0x82>
  {
    Vmax = Va;
 8003164:	69fb      	ldr	r3, [r7, #28]
 8003166:	62fb      	str	r3, [r7, #44]	; 0x2c
    Vmin = Vb;
 8003168:	69bb      	ldr	r3, [r7, #24]
 800316a:	62bb      	str	r3, [r7, #40]	; 0x28
 800316c:	e003      	b.n	8003176 <SVGEN_run+0x8a>
  }
  else
  {
    Vmax = Vb;
 800316e:	69bb      	ldr	r3, [r7, #24]
 8003170:	62fb      	str	r3, [r7, #44]	; 0x2c
    Vmin = Va;
 8003172:	69fb      	ldr	r3, [r7, #28]
 8003174:	62bb      	str	r3, [r7, #40]	; 0x28
  }

  if (Vc > Vmax)
 8003176:	ed97 7a05 	vldr	s14, [r7, #20]
 800317a:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
 800317e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8003182:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003186:	dd02      	ble.n	800318e <SVGEN_run+0xa2>
  {
    Vmax = Vc;
 8003188:	697b      	ldr	r3, [r7, #20]
 800318a:	62fb      	str	r3, [r7, #44]	; 0x2c
 800318c:	e00a      	b.n	80031a4 <SVGEN_run+0xb8>
  }
  else if (Vc < Vmin)
 800318e:	ed97 7a05 	vldr	s14, [r7, #20]
 8003192:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
 8003196:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800319a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800319e:	d501      	bpl.n	80031a4 <SVGEN_run+0xb8>
  {
    Vmin = Vc;
 80031a0:	697b      	ldr	r3, [r7, #20]
 80031a2:	62bb      	str	r3, [r7, #40]	; 0x28
  }
		
  Vcom = ( (Vmax+Vmin) * (0.5f));
 80031a4:	ed97 7a0b 	vldr	s14, [r7, #44]	; 0x2c
 80031a8:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
 80031ac:	ee77 7a27 	vadd.f32	s15, s14, s15
 80031b0:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 80031b4:	ee67 7a87 	vmul.f32	s15, s15, s14
 80031b8:	edc7 7a04 	vstr	s15, [r7, #16]

  // Subtract common-mode term to achieve SV modulation
  pT->value[0] = (Va - Vcom);
 80031bc:	ed97 7a07 	vldr	s14, [r7, #28]
 80031c0:	edd7 7a04 	vldr	s15, [r7, #16]
 80031c4:	ee77 7a67 	vsub.f32	s15, s14, s15
 80031c8:	687b      	ldr	r3, [r7, #4]
 80031ca:	edc3 7a00 	vstr	s15, [r3]
  pT->value[1] = (Vb - Vcom);
 80031ce:	ed97 7a06 	vldr	s14, [r7, #24]
 80031d2:	edd7 7a04 	vldr	s15, [r7, #16]
 80031d6:	ee77 7a67 	vsub.f32	s15, s14, s15
 80031da:	687b      	ldr	r3, [r7, #4]
 80031dc:	edc3 7a01 	vstr	s15, [r3, #4]
  pT->value[2] = (Vc - Vcom);
 80031e0:	ed97 7a05 	vldr	s14, [r7, #20]
 80031e4:	edd7 7a04 	vldr	s15, [r7, #16]
 80031e8:	ee77 7a67 	vsub.f32	s15, s14, s15
 80031ec:	687b      	ldr	r3, [r7, #4]
 80031ee:	edc3 7a02 	vstr	s15, [r3, #8]
  
  return;
 80031f2:	bf00      	nop
} // end of SVGEN_run() function
 80031f4:	3734      	adds	r7, #52	; 0x34
 80031f6:	46bd      	mov	sp, r7
 80031f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80031fc:	4770      	bx	lr
 80031fe:	bf00      	nop
 8003200:	3f5db3d7 	.word	0x3f5db3d7

08003204 <SVGEN_setMaxModulation>:

//! \brief     Sets the maximum modulation in the space vector generator module
//! \param[in] handle         The space vector generator (SVGEN) handle
//! \param[in] maxModulation  The maximum modulation
static inline void SVGEN_setMaxModulation(SVGEN_Handle handle,const float_t maxModulation)
{
 8003204:	b480      	push	{r7}
 8003206:	b085      	sub	sp, #20
 8003208:	af00      	add	r7, sp, #0
 800320a:	6078      	str	r0, [r7, #4]
 800320c:	ed87 0a00 	vstr	s0, [r7]
  SVGEN_Obj *obj = (SVGEN_Obj *)handle;
 8003210:	687b      	ldr	r3, [r7, #4]
 8003212:	60bb      	str	r3, [r7, #8]
  float_t maxMod = maxModulation;
 8003214:	683b      	ldr	r3, [r7, #0]
 8003216:	60fb      	str	r3, [r7, #12]

  if(maxMod > SVGEN_4_OVER_3)
 8003218:	edd7 7a03 	vldr	s15, [r7, #12]
 800321c:	ed9f 7a0e 	vldr	s14, [pc, #56]	; 8003258 <SVGEN_setMaxModulation+0x54>
 8003220:	eef4 7ac7 	vcmpe.f32	s15, s14
 8003224:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003228:	dd02      	ble.n	8003230 <SVGEN_setMaxModulation+0x2c>
      maxMod = SVGEN_4_OVER_3;
 800322a:	4b0c      	ldr	r3, [pc, #48]	; (800325c <SVGEN_setMaxModulation+0x58>)
 800322c:	60fb      	str	r3, [r7, #12]
 800322e:	e009      	b.n	8003244 <SVGEN_setMaxModulation+0x40>
  else if(maxMod < (0.0f))
 8003230:	edd7 7a03 	vldr	s15, [r7, #12]
 8003234:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8003238:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800323c:	d502      	bpl.n	8003244 <SVGEN_setMaxModulation+0x40>
      maxMod = (0.0f);
 800323e:	f04f 0300 	mov.w	r3, #0
 8003242:	60fb      	str	r3, [r7, #12]

  obj->maxModulation = maxMod;
 8003244:	68bb      	ldr	r3, [r7, #8]
 8003246:	68fa      	ldr	r2, [r7, #12]
 8003248:	601a      	str	r2, [r3, #0]

  return;
 800324a:	bf00      	nop
} // end of SVGEN_setMaxModulation() function
 800324c:	3714      	adds	r7, #20
 800324e:	46bd      	mov	sp, r7
 8003250:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003254:	4770      	bx	lr
 8003256:	bf00      	nop
 8003258:	3faaaaab 	.word	0x3faaaaab
 800325c:	3faaaaab 	.word	0x3faaaaab

08003260 <TRAJ_setIntValue>:

//! \brief     Sets the intermediate value for the trajectory
//! \param[in] handle    The trajectory (TRAJ) handle
//! \param[in] intValue  The intermediate value
static inline void TRAJ_setIntValue(TRAJ_Handle handle,const float_t intValue)
{
 8003260:	b480      	push	{r7}
 8003262:	b085      	sub	sp, #20
 8003264:	af00      	add	r7, sp, #0
 8003266:	6078      	str	r0, [r7, #4]
 8003268:	ed87 0a00 	vstr	s0, [r7]
  TRAJ_Obj *obj = (TRAJ_Obj *)handle;
 800326c:	687b      	ldr	r3, [r7, #4]
 800326e:	60fb      	str	r3, [r7, #12]

  obj->intValue = intValue;
 8003270:	68fb      	ldr	r3, [r7, #12]
 8003272:	683a      	ldr	r2, [r7, #0]
 8003274:	605a      	str	r2, [r3, #4]

  return;
 8003276:	bf00      	nop
} // end of TRAJ_setIntValue() function
 8003278:	3714      	adds	r7, #20
 800327a:	46bd      	mov	sp, r7
 800327c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003280:	4770      	bx	lr
 8003282:	bf00      	nop

08003284 <TRAJ_setMaxDelta>:

//! \brief     Sets the maximum delta value for the trajectory
//! \param[in] handle    The trajectory (TRAJ) handle
//! \param[in] maxDelta  The maximum delta value
static inline void TRAJ_setMaxDelta(TRAJ_Handle handle,const float_t maxDelta)
{
 8003284:	b480      	push	{r7}
 8003286:	b085      	sub	sp, #20
 8003288:	af00      	add	r7, sp, #0
 800328a:	6078      	str	r0, [r7, #4]
 800328c:	ed87 0a00 	vstr	s0, [r7]
  TRAJ_Obj *obj = (TRAJ_Obj *)handle;
 8003290:	687b      	ldr	r3, [r7, #4]
 8003292:	60fb      	str	r3, [r7, #12]

  obj->maxDelta = maxDelta;
 8003294:	68fb      	ldr	r3, [r7, #12]
 8003296:	683a      	ldr	r2, [r7, #0]
 8003298:	611a      	str	r2, [r3, #16]

  return;
 800329a:	bf00      	nop
} // end of TRAJ_setMaxDelta() function
 800329c:	3714      	adds	r7, #20
 800329e:	46bd      	mov	sp, r7
 80032a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80032a4:	4770      	bx	lr
 80032a6:	bf00      	nop

080032a8 <TRAJ_setMaxValue>:

//! \brief     Sets the maximum value for the trajectory
//! \param[in] handle    The trajectory (TRAJ) handle
//! \param[in] maxValue  The maximum value
static inline void TRAJ_setMaxValue(TRAJ_Handle handle,const float_t maxValue)
{
 80032a8:	b480      	push	{r7}
 80032aa:	b085      	sub	sp, #20
 80032ac:	af00      	add	r7, sp, #0
 80032ae:	6078      	str	r0, [r7, #4]
 80032b0:	ed87 0a00 	vstr	s0, [r7]
  TRAJ_Obj *obj = (TRAJ_Obj *)handle;
 80032b4:	687b      	ldr	r3, [r7, #4]
 80032b6:	60fb      	str	r3, [r7, #12]

  obj->maxValue = maxValue;
 80032b8:	68fb      	ldr	r3, [r7, #12]
 80032ba:	683a      	ldr	r2, [r7, #0]
 80032bc:	60da      	str	r2, [r3, #12]

  return;
 80032be:	bf00      	nop
} // end of TRAJ_setMaxValue() function
 80032c0:	3714      	adds	r7, #20
 80032c2:	46bd      	mov	sp, r7
 80032c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80032c8:	4770      	bx	lr
 80032ca:	bf00      	nop

080032cc <TRAJ_setMinValue>:

//! \brief     Sets the minimum value for the trajectory
//! \param[in] handle    The trajectory (TRAJ) handle
//! \param[in] minValue  The minimum value
static inline void TRAJ_setMinValue(TRAJ_Handle handle,const float_t minValue)
{
 80032cc:	b480      	push	{r7}
 80032ce:	b085      	sub	sp, #20
 80032d0:	af00      	add	r7, sp, #0
 80032d2:	6078      	str	r0, [r7, #4]
 80032d4:	ed87 0a00 	vstr	s0, [r7]
  TRAJ_Obj *obj = (TRAJ_Obj *)handle;
 80032d8:	687b      	ldr	r3, [r7, #4]
 80032da:	60fb      	str	r3, [r7, #12]

  obj->minValue = minValue;
 80032dc:	68fb      	ldr	r3, [r7, #12]
 80032de:	683a      	ldr	r2, [r7, #0]
 80032e0:	609a      	str	r2, [r3, #8]

  return;
 80032e2:	bf00      	nop
} // end of TRAJ_setMinValue() function
 80032e4:	3714      	adds	r7, #20
 80032e6:	46bd      	mov	sp, r7
 80032e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80032ec:	4770      	bx	lr
 80032ee:	bf00      	nop

080032f0 <TRAJ_setTargetValue>:

//! \brief     Sets the target value for the trajectory
//! \param[in] handle       The trajectory (TRAJ) handle
//! \param[in] targetValue  The target value
static inline void TRAJ_setTargetValue(TRAJ_Handle handle,const float_t targetValue)
{
 80032f0:	b480      	push	{r7}
 80032f2:	b085      	sub	sp, #20
 80032f4:	af00      	add	r7, sp, #0
 80032f6:	6078      	str	r0, [r7, #4]
 80032f8:	ed87 0a00 	vstr	s0, [r7]
  TRAJ_Obj *obj = (TRAJ_Obj *)handle;
 80032fc:	687b      	ldr	r3, [r7, #4]
 80032fe:	60fb      	str	r3, [r7, #12]

  obj->targetValue = targetValue;
 8003300:	68fb      	ldr	r3, [r7, #12]
 8003302:	683a      	ldr	r2, [r7, #0]
 8003304:	601a      	str	r2, [r3, #0]

  return;
 8003306:	bf00      	nop
} // end of TRAJ_setTargetValue() function
 8003308:	3714      	adds	r7, #20
 800330a:	46bd      	mov	sp, r7
 800330c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003310:	4770      	bx	lr
 8003312:	bf00      	nop

08003314 <RMP_CNTL_SetRampDelayMax>:
// the functions

extern RMPCNTL_Handle RMP_CNTL_Init(void *pMemory, const size_t numBytes);//! \Mod By Dl.K

static inline void RMP_CNTL_SetRampDelayMax(RMPCNTL_Handle handle, const uint_least32_t value)//! \Mod By Dl.K
{
 8003314:	b480      	push	{r7}
 8003316:	b085      	sub	sp, #20
 8003318:	af00      	add	r7, sp, #0
 800331a:	6078      	str	r0, [r7, #4]
 800331c:	6039      	str	r1, [r7, #0]
	RMPCNTL_Obj *obj = (RMPCNTL_Obj *)handle;
 800331e:	687b      	ldr	r3, [r7, #4]
 8003320:	60fb      	str	r3, [r7, #12]

	obj->RampDelayMax = value;
 8003322:	68fb      	ldr	r3, [r7, #12]
 8003324:	683a      	ldr	r2, [r7, #0]
 8003326:	605a      	str	r2, [r3, #4]

	return;
 8003328:	bf00      	nop
}
 800332a:	3714      	adds	r7, #20
 800332c:	46bd      	mov	sp, r7
 800332e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003332:	4770      	bx	lr

08003334 <RMP_CNTL_SetTargetValue>:

static inline void RMP_CNTL_SetTargetValue(RMPCNTL_Handle handle, const float_t target_value)//! \Mod By Dl.K
{
 8003334:	b480      	push	{r7}
 8003336:	b085      	sub	sp, #20
 8003338:	af00      	add	r7, sp, #0
 800333a:	6078      	str	r0, [r7, #4]
 800333c:	ed87 0a00 	vstr	s0, [r7]
	RMPCNTL_Obj *obj = (RMPCNTL_Obj *)handle;
 8003340:	687b      	ldr	r3, [r7, #4]
 8003342:	60fb      	str	r3, [r7, #12]

	obj->TargetValue = target_value;
 8003344:	68fb      	ldr	r3, [r7, #12]
 8003346:	683a      	ldr	r2, [r7, #0]
 8003348:	601a      	str	r2, [r3, #0]

	return;
 800334a:	bf00      	nop
}
 800334c:	3714      	adds	r7, #20
 800334e:	46bd      	mov	sp, r7
 8003350:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003354:	4770      	bx	lr
 8003356:	bf00      	nop

08003358 <RMP_CNTL_GetFreq>:

static inline float_t RMP_CNTL_GetFreq(RMPCNTL_Handle handle)//! \Mod By Dl.K
{
 8003358:	b480      	push	{r7}
 800335a:	b085      	sub	sp, #20
 800335c:	af00      	add	r7, sp, #0
 800335e:	6078      	str	r0, [r7, #4]
	RMPCNTL_Obj *obj = (RMPCNTL_Obj *)handle;
 8003360:	687b      	ldr	r3, [r7, #4]
 8003362:	60fb      	str	r3, [r7, #12]

	return (obj->SetpointValue);
 8003364:	68fb      	ldr	r3, [r7, #12]
 8003366:	695b      	ldr	r3, [r3, #20]
 8003368:	ee07 3a90 	vmov	s15, r3
}
 800336c:	eeb0 0a67 	vmov.f32	s0, s15
 8003370:	3714      	adds	r7, #20
 8003372:	46bd      	mov	sp, r7
 8003374:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003378:	4770      	bx	lr
 800337a:	bf00      	nop

0800337c <RMP_CNTL_Run>:
	
	return ;
}

static inline void RMP_CNTL_Run(RMPCNTL_Handle handle)//! \Mod By Dl.K
{
 800337c:	b580      	push	{r7, lr}
 800337e:	b084      	sub	sp, #16
 8003380:	af00      	add	r7, sp, #0
 8003382:	6078      	str	r0, [r7, #4]
	RMPCNTL_Obj *obj = (RMPCNTL_Obj *)handle;
 8003384:	687b      	ldr	r3, [r7, #4]
 8003386:	60fb      	str	r3, [r7, #12]

	float_t tmp;

	tmp = obj->TargetValue - obj->SetpointValue;
 8003388:	68fb      	ldr	r3, [r7, #12]
 800338a:	ed93 7a00 	vldr	s14, [r3]
 800338e:	68fb      	ldr	r3, [r7, #12]
 8003390:	edd3 7a05 	vldr	s15, [r3, #20]
 8003394:	ee77 7a67 	vsub.f32	s15, s14, s15
 8003398:	edc7 7a02 	vstr	s15, [r7, #8]

	if (MATH_abs(tmp) > (0.0000305f))
 800339c:	ed97 0a02 	vldr	s0, [r7, #8]
 80033a0:	f7ff fb72 	bl	8002a88 <MATH_abs>
 80033a4:	eeb0 7a40 	vmov.f32	s14, s0
 80033a8:	eddf 7a2f 	vldr	s15, [pc, #188]	; 8003468 <RMP_CNTL_Run+0xec>
 80033ac:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80033b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80033b4:	dd4f      	ble.n	8003456 <RMP_CNTL_Run+0xda>
	{
		obj->RampDelayCount += 1;
 80033b6:	68fb      	ldr	r3, [r7, #12]
 80033b8:	691b      	ldr	r3, [r3, #16]
 80033ba:	1c5a      	adds	r2, r3, #1
 80033bc:	68fb      	ldr	r3, [r7, #12]
 80033be:	611a      	str	r2, [r3, #16]
		if (obj->RampDelayCount >= obj->RampDelayMax)
 80033c0:	68fb      	ldr	r3, [r7, #12]
 80033c2:	691a      	ldr	r2, [r3, #16]
 80033c4:	68fb      	ldr	r3, [r7, #12]
 80033c6:	685b      	ldr	r3, [r3, #4]
 80033c8:	429a      	cmp	r2, r3
 80033ca:	d348      	bcc.n	800345e <RMP_CNTL_Run+0xe2>
		{
			if (obj->TargetValue >= obj->SetpointValue)
 80033cc:	68fb      	ldr	r3, [r7, #12]
 80033ce:	ed93 7a00 	vldr	s14, [r3]
 80033d2:	68fb      	ldr	r3, [r7, #12]
 80033d4:	edd3 7a05 	vldr	s15, [r3, #20]
 80033d8:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80033dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80033e0:	db1c      	blt.n	800341c <RMP_CNTL_Run+0xa0>
			{
				obj->SetpointValue += (0.0000305f);        // 0.0000305 is resolution(1/2^15) of Q15
 80033e2:	68fb      	ldr	r3, [r7, #12]
 80033e4:	edd3 7a05 	vldr	s15, [r3, #20]
 80033e8:	ed9f 7a1f 	vldr	s14, [pc, #124]	; 8003468 <RMP_CNTL_Run+0xec>
 80033ec:	ee77 7a87 	vadd.f32	s15, s15, s14
 80033f0:	68fb      	ldr	r3, [r7, #12]
 80033f2:	edc3 7a05 	vstr	s15, [r3, #20]
				if (obj->SetpointValue > obj->RampHighLimit)
 80033f6:	68fb      	ldr	r3, [r7, #12]
 80033f8:	ed93 7a05 	vldr	s14, [r3, #20]
 80033fc:	68fb      	ldr	r3, [r7, #12]
 80033fe:	edd3 7a03 	vldr	s15, [r3, #12]
 8003402:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8003406:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800340a:	dd03      	ble.n	8003414 <RMP_CNTL_Run+0x98>
					obj->SetpointValue = obj->RampHighLimit;
 800340c:	68fb      	ldr	r3, [r7, #12]
 800340e:	68da      	ldr	r2, [r3, #12]
 8003410:	68fb      	ldr	r3, [r7, #12]
 8003412:	615a      	str	r2, [r3, #20]
				obj->RampDelayCount = 0;
 8003414:	68fb      	ldr	r3, [r7, #12]
 8003416:	2200      	movs	r2, #0
 8003418:	611a      	str	r2, [r3, #16]
 800341a:	e020      	b.n	800345e <RMP_CNTL_Run+0xe2>
			}
			else
			{
				obj->SetpointValue -= (0.0000305f);        // 0.0000305 is resolution of Q15
 800341c:	68fb      	ldr	r3, [r7, #12]
 800341e:	edd3 7a05 	vldr	s15, [r3, #20]
 8003422:	ed9f 7a11 	vldr	s14, [pc, #68]	; 8003468 <RMP_CNTL_Run+0xec>
 8003426:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800342a:	68fb      	ldr	r3, [r7, #12]
 800342c:	edc3 7a05 	vstr	s15, [r3, #20]
				if (obj->SetpointValue < obj->RampLowLimit)
 8003430:	68fb      	ldr	r3, [r7, #12]
 8003432:	ed93 7a05 	vldr	s14, [r3, #20]
 8003436:	68fb      	ldr	r3, [r7, #12]
 8003438:	edd3 7a02 	vldr	s15, [r3, #8]
 800343c:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8003440:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003444:	d503      	bpl.n	800344e <RMP_CNTL_Run+0xd2>
					obj->SetpointValue = obj->RampLowLimit;
 8003446:	68fb      	ldr	r3, [r7, #12]
 8003448:	689a      	ldr	r2, [r3, #8]
 800344a:	68fb      	ldr	r3, [r7, #12]
 800344c:	615a      	str	r2, [r3, #20]
				obj->RampDelayCount = 0;
 800344e:	68fb      	ldr	r3, [r7, #12]
 8003450:	2200      	movs	r2, #0
 8003452:	611a      	str	r2, [r3, #16]
			}
		}
	}
	else  obj->EqualFlag = 0x7FFFFFFF;
	return;
 8003454:	e004      	b.n	8003460 <RMP_CNTL_Run+0xe4>
					obj->SetpointValue = obj->RampLowLimit;
				obj->RampDelayCount = 0;
			}
		}
	}
	else  obj->EqualFlag = 0x7FFFFFFF;
 8003456:	68fb      	ldr	r3, [r7, #12]
 8003458:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
 800345c:	619a      	str	r2, [r3, #24]
	return;
 800345e:	bf00      	nop
}
 8003460:	3710      	adds	r7, #16
 8003462:	46bd      	mov	sp, r7
 8003464:	bd80      	pop	{r7, pc}
 8003466:	bf00      	nop
 8003468:	37ffda40 	.word	0x37ffda40

0800346c <RAMPGEN_GetAngleOut>:
// the functions

extern RAMPGEN_Handle RAMPGEN_Init(void *pMemory, const size_t numBytes);

static inline float_t RAMPGEN_GetAngleOut(RAMPGEN_Handle handle)//! \Mod By Dl.K
{
 800346c:	b480      	push	{r7}
 800346e:	b085      	sub	sp, #20
 8003470:	af00      	add	r7, sp, #0
 8003472:	6078      	str	r0, [r7, #4]
	RAMPGEN_Obj *obj = (RAMPGEN_Obj *)handle;
 8003474:	687b      	ldr	r3, [r7, #4]
 8003476:	60fb      	str	r3, [r7, #12]

	return (obj->Out);
 8003478:	68fb      	ldr	r3, [r7, #12]
 800347a:	691b      	ldr	r3, [r3, #16]
 800347c:	ee07 3a90 	vmov	s15, r3
}
 8003480:	eeb0 0a67 	vmov.f32	s0, s15
 8003484:	3714      	adds	r7, #20
 8003486:	46bd      	mov	sp, r7
 8003488:	f85d 7b04 	ldr.w	r7, [sp], #4
 800348c:	4770      	bx	lr
 800348e:	bf00      	nop

08003490 <RAMPGEN_SetFreq>:

static inline void RAMPGEN_SetFreq(RAMPGEN_Handle handle, const float_t freq)//! \Mod By Dl.K
{
 8003490:	b480      	push	{r7}
 8003492:	b085      	sub	sp, #20
 8003494:	af00      	add	r7, sp, #0
 8003496:	6078      	str	r0, [r7, #4]
 8003498:	ed87 0a00 	vstr	s0, [r7]
	RAMPGEN_Obj *obj = (RAMPGEN_Obj *)handle;
 800349c:	687b      	ldr	r3, [r7, #4]
 800349e:	60fb      	str	r3, [r7, #12]

	obj->Freq = freq;
 80034a0:	68fb      	ldr	r3, [r7, #12]
 80034a2:	683a      	ldr	r2, [r7, #0]
 80034a4:	601a      	str	r2, [r3, #0]

	return;
 80034a6:	bf00      	nop
}
 80034a8:	3714      	adds	r7, #20
 80034aa:	46bd      	mov	sp, r7
 80034ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80034b0:	4770      	bx	lr
 80034b2:	bf00      	nop

080034b4 <RAMPGEN_SetStepAngleMax>:

static inline void RAMPGEN_SetStepAngleMax(RAMPGEN_Handle handle, const float_t step_angle_max)//! \Mod By Dl.K
{
 80034b4:	b480      	push	{r7}
 80034b6:	b085      	sub	sp, #20
 80034b8:	af00      	add	r7, sp, #0
 80034ba:	6078      	str	r0, [r7, #4]
 80034bc:	ed87 0a00 	vstr	s0, [r7]
	RAMPGEN_Obj *obj = (RAMPGEN_Obj *)handle;
 80034c0:	687b      	ldr	r3, [r7, #4]
 80034c2:	60fb      	str	r3, [r7, #12]

	obj->StepAngleMax = step_angle_max;
 80034c4:	68fb      	ldr	r3, [r7, #12]
 80034c6:	683a      	ldr	r2, [r7, #0]
 80034c8:	605a      	str	r2, [r3, #4]

	return;
 80034ca:	bf00      	nop
}
 80034cc:	3714      	adds	r7, #20
 80034ce:	46bd      	mov	sp, r7
 80034d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80034d4:	4770      	bx	lr
 80034d6:	bf00      	nop

080034d8 <RAMPGEN_SetAngleOffset>:

static inline void RAMPGEN_SetAngleOffset(RAMPGEN_Handle handle, const float_t offset)//! \Mod By Dl.K
{
 80034d8:	b480      	push	{r7}
 80034da:	b085      	sub	sp, #20
 80034dc:	af00      	add	r7, sp, #0
 80034de:	6078      	str	r0, [r7, #4]
 80034e0:	ed87 0a00 	vstr	s0, [r7]
	RAMPGEN_Obj *obj = (RAMPGEN_Obj *)handle;
 80034e4:	687b      	ldr	r3, [r7, #4]
 80034e6:	60fb      	str	r3, [r7, #12]

	obj->Offset = offset;
 80034e8:	68fb      	ldr	r3, [r7, #12]
 80034ea:	683a      	ldr	r2, [r7, #0]
 80034ec:	615a      	str	r2, [r3, #20]

	return;
 80034ee:	bf00      	nop
}
 80034f0:	3714      	adds	r7, #20
 80034f2:	46bd      	mov	sp, r7
 80034f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80034f8:	4770      	bx	lr
 80034fa:	bf00      	nop

080034fc <RAMPGEN_Run>:

static inline void RAMPGEN_Run(RAMPGEN_Handle handle)//! \Mod By Dl.K
{
 80034fc:	b480      	push	{r7}
 80034fe:	b085      	sub	sp, #20
 8003500:	af00      	add	r7, sp, #0
 8003502:	6078      	str	r0, [r7, #4]
	RAMPGEN_Obj *obj = (RAMPGEN_Obj *)handle;
 8003504:	687b      	ldr	r3, [r7, #4]
 8003506:	60fb      	str	r3, [r7, #12]

	// Compute the angle rate
	obj->Angle += (obj->StepAngleMax * obj->Freq);
 8003508:	68fb      	ldr	r3, [r7, #12]
 800350a:	ed93 7a02 	vldr	s14, [r3, #8]
 800350e:	68fb      	ldr	r3, [r7, #12]
 8003510:	edd3 6a01 	vldr	s13, [r3, #4]
 8003514:	68fb      	ldr	r3, [r7, #12]
 8003516:	edd3 7a00 	vldr	s15, [r3]
 800351a:	ee66 7aa7 	vmul.f32	s15, s13, s15
 800351e:	ee77 7a27 	vadd.f32	s15, s14, s15
 8003522:	68fb      	ldr	r3, [r7, #12]
 8003524:	edc3 7a02 	vstr	s15, [r3, #8]

	// Saturate the angle rate within (-1,1)        
	if (obj->Angle>(1.0f))
 8003528:	68fb      	ldr	r3, [r7, #12]
 800352a:	edd3 7a02 	vldr	s15, [r3, #8]
 800352e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8003532:	eef4 7ac7 	vcmpe.f32	s15, s14
 8003536:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800353a:	dd0a      	ble.n	8003552 <RAMPGEN_Run+0x56>
		obj->Angle -= (1.0f);
 800353c:	68fb      	ldr	r3, [r7, #12]
 800353e:	edd3 7a02 	vldr	s15, [r3, #8]
 8003542:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8003546:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800354a:	68fb      	ldr	r3, [r7, #12]
 800354c:	edc3 7a02 	vstr	s15, [r3, #8]
 8003550:	e013      	b.n	800357a <RAMPGEN_Run+0x7e>
	else if (obj->Angle<(-1.0f))
 8003552:	68fb      	ldr	r3, [r7, #12]
 8003554:	edd3 7a02 	vldr	s15, [r3, #8]
 8003558:	eebf 7a00 	vmov.f32	s14, #240	; 0xf0
 800355c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8003560:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003564:	d509      	bpl.n	800357a <RAMPGEN_Run+0x7e>
		obj->Angle += (1.0f);
 8003566:	68fb      	ldr	r3, [r7, #12]
 8003568:	edd3 7a02 	vldr	s15, [r3, #8]
 800356c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8003570:	ee77 7a87 	vadd.f32	s15, s15, s14
 8003574:	68fb      	ldr	r3, [r7, #12]
 8003576:	edc3 7a02 	vstr	s15, [r3, #8]

	// Compute the ramp output
	obj->Out = (obj->Angle * obj->Gain) + obj->Offset;
 800357a:	68fb      	ldr	r3, [r7, #12]
 800357c:	ed93 7a02 	vldr	s14, [r3, #8]
 8003580:	68fb      	ldr	r3, [r7, #12]
 8003582:	edd3 7a03 	vldr	s15, [r3, #12]
 8003586:	ee27 7a27 	vmul.f32	s14, s14, s15
 800358a:	68fb      	ldr	r3, [r7, #12]
 800358c:	edd3 7a05 	vldr	s15, [r3, #20]
 8003590:	ee77 7a27 	vadd.f32	s15, s14, s15
 8003594:	68fb      	ldr	r3, [r7, #12]
 8003596:	edc3 7a04 	vstr	s15, [r3, #16]

	// Saturate the ramp output within (-1,1)     
	if (obj->Out>(1.0f))
 800359a:	68fb      	ldr	r3, [r7, #12]
 800359c:	edd3 7a04 	vldr	s15, [r3, #16]
 80035a0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 80035a4:	eef4 7ac7 	vcmpe.f32	s15, s14
 80035a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80035ac:	dd0a      	ble.n	80035c4 <RAMPGEN_Run+0xc8>
		obj->Out -= (1.0f);
 80035ae:	68fb      	ldr	r3, [r7, #12]
 80035b0:	edd3 7a04 	vldr	s15, [r3, #16]
 80035b4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 80035b8:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80035bc:	68fb      	ldr	r3, [r7, #12]
 80035be:	edc3 7a04 	vstr	s15, [r3, #16]
 80035c2:	e014      	b.n	80035ee <RAMPGEN_Run+0xf2>
	else if (obj->Out<(-1.0f))
 80035c4:	68fb      	ldr	r3, [r7, #12]
 80035c6:	edd3 7a04 	vldr	s15, [r3, #16]
 80035ca:	eebf 7a00 	vmov.f32	s14, #240	; 0xf0
 80035ce:	eef4 7ac7 	vcmpe.f32	s15, s14
 80035d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80035d6:	d400      	bmi.n	80035da <RAMPGEN_Run+0xde>
		obj->Out += (1.0f);

	return;
 80035d8:	e00a      	b.n	80035f0 <RAMPGEN_Run+0xf4>

	// Saturate the ramp output within (-1,1)     
	if (obj->Out>(1.0f))
		obj->Out -= (1.0f);
	else if (obj->Out<(-1.0f))
		obj->Out += (1.0f);
 80035da:	68fb      	ldr	r3, [r7, #12]
 80035dc:	edd3 7a04 	vldr	s15, [r3, #16]
 80035e0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 80035e4:	ee77 7a87 	vadd.f32	s15, s15, s14
 80035e8:	68fb      	ldr	r3, [r7, #12]
 80035ea:	edc3 7a04 	vstr	s15, [r3, #16]

	return;
 80035ee:	bf00      	nop
}
 80035f0:	3714      	adds	r7, #20
 80035f2:	46bd      	mov	sp, r7
 80035f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80035f8:	4770      	bx	lr
 80035fa:	bf00      	nop

080035fc <INITPOSDET_GetInitPosAngle>:
// the functions

extern INITPOSDET_Handle INITPOSDET_Init(void *pMemory, const size_t numBytes);//! \Mod By Dl.K

static inline float_t INITPOSDET_GetInitPosAngle(INITPOSDET_Handle handle)//! \Mod By Dl.K
{
 80035fc:	b480      	push	{r7}
 80035fe:	b085      	sub	sp, #20
 8003600:	af00      	add	r7, sp, #0
 8003602:	6078      	str	r0, [r7, #4]
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
 8003604:	687b      	ldr	r3, [r7, #4]
 8003606:	60fb      	str	r3, [r7, #12]

	return (obj->InitPosAngle);
 8003608:	68fb      	ldr	r3, [r7, #12]
 800360a:	685b      	ldr	r3, [r3, #4]
 800360c:	ee07 3a90 	vmov	s15, r3
}
 8003610:	eeb0 0a67 	vmov.f32	s0, s15
 8003614:	3714      	adds	r7, #20
 8003616:	46bd      	mov	sp, r7
 8003618:	f85d 7b04 	ldr.w	r7, [sp], #4
 800361c:	4770      	bx	lr
 800361e:	bf00      	nop

08003620 <INITPOSDET_GetVolVecAngleFlag>:

static inline uint16_t INITPOSDET_GetVolVecAngleFlag(INITPOSDET_Handle handle)//! \Mod By Dl.K
{
 8003620:	b480      	push	{r7}
 8003622:	b085      	sub	sp, #20
 8003624:	af00      	add	r7, sp, #0
 8003626:	6078      	str	r0, [r7, #4]
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
 8003628:	687b      	ldr	r3, [r7, #4]
 800362a:	60fb      	str	r3, [r7, #12]

	return (obj->VolVecAngleFlag);
 800362c:	68fb      	ldr	r3, [r7, #12]
 800362e:	899b      	ldrh	r3, [r3, #12]
}
 8003630:	4618      	mov	r0, r3
 8003632:	3714      	adds	r7, #20
 8003634:	46bd      	mov	sp, r7
 8003636:	f85d 7b04 	ldr.w	r7, [sp], #4
 800363a:	4770      	bx	lr

0800363c <INITPOSDET_GetVolVecAngle>:

static inline float_t INITPOSDET_GetVolVecAngle(INITPOSDET_Handle handle)//! \Mod By Dl.K
{
 800363c:	b480      	push	{r7}
 800363e:	b085      	sub	sp, #20
 8003640:	af00      	add	r7, sp, #0
 8003642:	6078      	str	r0, [r7, #4]
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
 8003644:	687b      	ldr	r3, [r7, #4]
 8003646:	60fb      	str	r3, [r7, #12]

	return (obj->VolVecAngle);
 8003648:	68fb      	ldr	r3, [r7, #12]
 800364a:	691b      	ldr	r3, [r3, #16]
 800364c:	ee07 3a90 	vmov	s15, r3
}
 8003650:	eeb0 0a67 	vmov.f32	s0, s15
 8003654:	3714      	adds	r7, #20
 8003656:	46bd      	mov	sp, r7
 8003658:	f85d 7b04 	ldr.w	r7, [sp], #4
 800365c:	4770      	bx	lr
 800365e:	bf00      	nop

08003660 <INITPOSDET_GetIdSampAngle>:

static inline float_t INITPOSDET_GetIdSampAngle(INITPOSDET_Handle handle)//! \Mod By Dl.K
{
 8003660:	b480      	push	{r7}
 8003662:	b085      	sub	sp, #20
 8003664:	af00      	add	r7, sp, #0
 8003666:	6078      	str	r0, [r7, #4]
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
 8003668:	687b      	ldr	r3, [r7, #4]
 800366a:	60fb      	str	r3, [r7, #12]

	return (obj->IdSampAngle);
 800366c:	68fb      	ldr	r3, [r7, #12]
 800366e:	69db      	ldr	r3, [r3, #28]
 8003670:	ee07 3a90 	vmov	s15, r3
}
 8003674:	eeb0 0a67 	vmov.f32	s0, s15
 8003678:	3714      	adds	r7, #20
 800367a:	46bd      	mov	sp, r7
 800367c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003680:	4770      	bx	lr
 8003682:	bf00      	nop

08003684 <INITPOSDET_GetIdSampAngleFlag>:

static inline uint16_t INITPOSDET_GetIdSampAngleFlag(INITPOSDET_Handle handle)//! \Mod By Dl.K
{
 8003684:	b480      	push	{r7}
 8003686:	b085      	sub	sp, #20
 8003688:	af00      	add	r7, sp, #0
 800368a:	6078      	str	r0, [r7, #4]
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
 800368c:	687b      	ldr	r3, [r7, #4]
 800368e:	60fb      	str	r3, [r7, #12]

	return (obj->IdSampAngleFlag);
 8003690:	68fb      	ldr	r3, [r7, #12]
 8003692:	8b5b      	ldrh	r3, [r3, #26]
}
 8003694:	4618      	mov	r0, r3
 8003696:	3714      	adds	r7, #20
 8003698:	46bd      	mov	sp, r7
 800369a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800369e:	4770      	bx	lr

080036a0 <Speed_SetElecTheta>:
// the functions
extern SPEED_Handle Speed_Init(void *pMemory, const size_t numBytes);//! \Mod By Dl.K


static inline void Speed_SetElecTheta(SPEED_Handle handle, float_t theta)//! \Mod By Dl.K
{
 80036a0:	b480      	push	{r7}
 80036a2:	b085      	sub	sp, #20
 80036a4:	af00      	add	r7, sp, #0
 80036a6:	6078      	str	r0, [r7, #4]
 80036a8:	ed87 0a00 	vstr	s0, [r7]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
 80036ac:	687b      	ldr	r3, [r7, #4]
 80036ae:	60fb      	str	r3, [r7, #12]

	obj->ElecTheta = theta;
 80036b0:	68fb      	ldr	r3, [r7, #12]
 80036b2:	683a      	ldr	r2, [r7, #0]
 80036b4:	601a      	str	r2, [r3, #0]

	return;
 80036b6:	bf00      	nop
}
 80036b8:	3714      	adds	r7, #20
 80036ba:	46bd      	mov	sp, r7
 80036bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80036c0:	4770      	bx	lr
 80036c2:	bf00      	nop

080036c4 <Speed_SetElecFilterSpeedRatio>:

static inline void Speed_SetElecFilterSpeedRatio(SPEED_Handle handle, float_t ratio)//! \Mod By Dl.K
{
 80036c4:	b480      	push	{r7}
 80036c6:	b085      	sub	sp, #20
 80036c8:	af00      	add	r7, sp, #0
 80036ca:	6078      	str	r0, [r7, #4]
 80036cc:	ed87 0a00 	vstr	s0, [r7]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
 80036d0:	687b      	ldr	r3, [r7, #4]
 80036d2:	60fb      	str	r3, [r7, #12]

	obj->ElecFilterSpeedRatio = ratio;
 80036d4:	68fb      	ldr	r3, [r7, #12]
 80036d6:	683a      	ldr	r2, [r7, #0]
 80036d8:	615a      	str	r2, [r3, #20]

	return;
 80036da:	bf00      	nop
}
 80036dc:	3714      	adds	r7, #20
 80036de:	46bd      	mov	sp, r7
 80036e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80036e4:	4770      	bx	lr
 80036e6:	bf00      	nop

080036e8 <Speed_SetElecThetaChagTimeRatio>:

static inline void Speed_SetElecThetaChagTimeRatio(SPEED_Handle handle, float_t ratio)//! \Mod By Dl.K
{
 80036e8:	b480      	push	{r7}
 80036ea:	b085      	sub	sp, #20
 80036ec:	af00      	add	r7, sp, #0
 80036ee:	6078      	str	r0, [r7, #4]
 80036f0:	ed87 0a00 	vstr	s0, [r7]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
 80036f4:	687b      	ldr	r3, [r7, #4]
 80036f6:	60fb      	str	r3, [r7, #12]

	obj->ElecThetaChagTimeRatio = ratio;
 80036f8:	68fb      	ldr	r3, [r7, #12]
 80036fa:	683a      	ldr	r2, [r7, #0]
 80036fc:	609a      	str	r2, [r3, #8]

	return;
 80036fe:	bf00      	nop
}
 8003700:	3714      	adds	r7, #20
 8003702:	46bd      	mov	sp, r7
 8003704:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003708:	4770      	bx	lr
 800370a:	bf00      	nop

0800370c <Speed_UpdateElecTheta>:

static inline void Speed_UpdateElecTheta(SPEED_Handle handle)//! \Mod By Dl.K
{
 800370c:	b480      	push	{r7}
 800370e:	b085      	sub	sp, #20
 8003710:	af00      	add	r7, sp, #0
 8003712:	6078      	str	r0, [r7, #4]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
 8003714:	687b      	ldr	r3, [r7, #4]
 8003716:	60fb      	str	r3, [r7, #12]

	obj->OldElecTheta = obj->ElecTheta;
 8003718:	68fb      	ldr	r3, [r7, #12]
 800371a:	681a      	ldr	r2, [r3, #0]
 800371c:	68fb      	ldr	r3, [r7, #12]
 800371e:	605a      	str	r2, [r3, #4]

	return;
 8003720:	bf00      	nop
}
 8003722:	3714      	adds	r7, #20
 8003724:	46bd      	mov	sp, r7
 8003726:	f85d 7b04 	ldr.w	r7, [sp], #4
 800372a:	4770      	bx	lr

0800372c <Speed_GetElecSpeed>:

	return;
}

static inline float_t Speed_GetElecSpeed(SPEED_Handle handle)//! \Mod By Dl.K
{
 800372c:	b480      	push	{r7}
 800372e:	b085      	sub	sp, #20
 8003730:	af00      	add	r7, sp, #0
 8003732:	6078      	str	r0, [r7, #4]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
 8003734:	687b      	ldr	r3, [r7, #4]
 8003736:	60fb      	str	r3, [r7, #12]

	return( obj->ElecSpeed );
 8003738:	68fb      	ldr	r3, [r7, #12]
 800373a:	68db      	ldr	r3, [r3, #12]
 800373c:	ee07 3a90 	vmov	s15, r3
}
 8003740:	eeb0 0a67 	vmov.f32	s0, s15
 8003744:	3714      	adds	r7, #20
 8003746:	46bd      	mov	sp, r7
 8003748:	f85d 7b04 	ldr.w	r7, [sp], #4
 800374c:	4770      	bx	lr
 800374e:	bf00      	nop

08003750 <HAL_runOffsetEst>:
//!             speed performance of the motor drive.
//! \param[in]  handle    The hardware abstraction layer (HAL) handle
//! \param[in]  pAdcData  The pointer to the ADC data

static inline void HAL_runOffsetEst(HAL_Handle handle,const HAL_AdcData_t *pAdcData)
{
 8003750:	b580      	push	{r7, lr}
 8003752:	b084      	sub	sp, #16
 8003754:	af00      	add	r7, sp, #0
 8003756:	6078      	str	r0, [r7, #4]
 8003758:	6039      	str	r1, [r7, #0]
  	uint_least8_t cnt;
  	HAL_Obj *obj = (HAL_Obj *)handle;
 800375a:	687b      	ldr	r3, [r7, #4]
 800375c:	60bb      	str	r3, [r7, #8]


  // estimate the current offsets
  	for(cnt=0;cnt<obj->numCurrentSensors;cnt++)
 800375e:	2300      	movs	r3, #0
 8003760:	73fb      	strb	r3, [r7, #15]
 8003762:	e011      	b.n	8003788 <HAL_runOffsetEst+0x38>
    {
      	OFFSET_run(obj->offsetHandle_I[cnt],pAdcData->I.value[cnt]);
 8003764:	7bfa      	ldrb	r2, [r7, #15]
 8003766:	68bb      	ldr	r3, [r7, #8]
 8003768:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800376c:	7bfb      	ldrb	r3, [r7, #15]
 800376e:	683a      	ldr	r2, [r7, #0]
 8003770:	009b      	lsls	r3, r3, #2
 8003772:	4413      	add	r3, r2
 8003774:	edd3 7a00 	vldr	s15, [r3]
 8003778:	4608      	mov	r0, r1
 800377a:	eeb0 0a67 	vmov.f32	s0, s15
 800377e:	f7ff fb75 	bl	8002e6c <OFFSET_run>
  	uint_least8_t cnt;
  	HAL_Obj *obj = (HAL_Obj *)handle;


  // estimate the current offsets
  	for(cnt=0;cnt<obj->numCurrentSensors;cnt++)
 8003782:	7bfb      	ldrb	r3, [r7, #15]
 8003784:	3301      	adds	r3, #1
 8003786:	73fb      	strb	r3, [r7, #15]
 8003788:	68bb      	ldr	r3, [r7, #8]
 800378a:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
 800378e:	7bfa      	ldrb	r2, [r7, #15]
 8003790:	429a      	cmp	r2, r3
 8003792:	d3e7      	bcc.n	8003764 <HAL_runOffsetEst+0x14>
      	OFFSET_run(obj->offsetHandle_I[cnt],pAdcData->I.value[cnt]);
    }


  // estimate the voltage offsets
  	for(cnt=0;cnt<obj->numVoltageSensors;cnt++)
 8003794:	2300      	movs	r3, #0
 8003796:	73fb      	strb	r3, [r7, #15]
 8003798:	e014      	b.n	80037c4 <HAL_runOffsetEst+0x74>
    {
    	OFFSET_run(obj->offsetHandle_V[cnt],pAdcData->V.value[cnt]);
 800379a:	7bfb      	ldrb	r3, [r7, #15]
 800379c:	68ba      	ldr	r2, [r7, #8]
 800379e:	331a      	adds	r3, #26
 80037a0:	009b      	lsls	r3, r3, #2
 80037a2:	4413      	add	r3, r2
 80037a4:	6859      	ldr	r1, [r3, #4]
 80037a6:	7bfb      	ldrb	r3, [r7, #15]
 80037a8:	683a      	ldr	r2, [r7, #0]
 80037aa:	3302      	adds	r3, #2
 80037ac:	009b      	lsls	r3, r3, #2
 80037ae:	4413      	add	r3, r2
 80037b0:	edd3 7a01 	vldr	s15, [r3, #4]
 80037b4:	4608      	mov	r0, r1
 80037b6:	eeb0 0a67 	vmov.f32	s0, s15
 80037ba:	f7ff fb57 	bl	8002e6c <OFFSET_run>
      	OFFSET_run(obj->offsetHandle_I[cnt],pAdcData->I.value[cnt]);
    }


  // estimate the voltage offsets
  	for(cnt=0;cnt<obj->numVoltageSensors;cnt++)
 80037be:	7bfb      	ldrb	r3, [r7, #15]
 80037c0:	3301      	adds	r3, #1
 80037c2:	73fb      	strb	r3, [r7, #15]
 80037c4:	68bb      	ldr	r3, [r7, #8]
 80037c6:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 80037ca:	7bfa      	ldrb	r2, [r7, #15]
 80037cc:	429a      	cmp	r2, r3
 80037ce:	d3e4      	bcc.n	800379a <HAL_runOffsetEst+0x4a>
    {
    	OFFSET_run(obj->offsetHandle_V[cnt],pAdcData->V.value[cnt]);
    }

  	return;
 80037d0:	bf00      	nop
} // end of HAL_runOffsetEst() function
 80037d2:	3710      	adds	r7, #16
 80037d4:	46bd      	mov	sp, r7
 80037d6:	bd80      	pop	{r7, pc}

080037d8 <CTRL_getCount_isr>:

//! \brief      Gets the isr count
//! \param[in]  handle  The controller (CTRL) handle
//! \return    The isr count
static inline uint_least16_t CTRL_getCount_isr(CTRL_Handle handle)//! \Mod By Dl.K
{
 80037d8:	b480      	push	{r7}
 80037da:	b085      	sub	sp, #20
 80037dc:	af00      	add	r7, sp, #0
 80037de:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80037e0:	687b      	ldr	r3, [r7, #4]
 80037e2:	60fb      	str	r3, [r7, #12]

  return(obj->counter_isr);
 80037e4:	68fb      	ldr	r3, [r7, #12]
 80037e6:	f8b3 31ee 	ldrh.w	r3, [r3, #494]	; 0x1ee
} // end of CTRL_getCount_isr() function
 80037ea:	4618      	mov	r0, r3
 80037ec:	3714      	adds	r7, #20
 80037ee:	46bd      	mov	sp, r7
 80037f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80037f4:	4770      	bx	lr
 80037f6:	bf00      	nop

080037f8 <CTRL_getFlag_enableCurrentCtrl>:

//! \brief     Gets the enable current controllers flag value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The enable current controller flag value
static inline bool CTRL_getFlag_enableCurrentCtrl(CTRL_Handle handle)//! \Mod By Dl.K
{
 80037f8:	b480      	push	{r7}
 80037fa:	b085      	sub	sp, #20
 80037fc:	af00      	add	r7, sp, #0
 80037fe:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003800:	687b      	ldr	r3, [r7, #4]
 8003802:	60fb      	str	r3, [r7, #12]

  return(obj->flag_enableCurrentCtrl);
 8003804:	68fb      	ldr	r3, [r7, #12]
 8003806:	f893 3220 	ldrb.w	r3, [r3, #544]	; 0x220
} // end of CTRL_getFlag_enableCurrentCtrl() function
 800380a:	4618      	mov	r0, r3
 800380c:	3714      	adds	r7, #20
 800380e:	46bd      	mov	sp, r7
 8003810:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003814:	4770      	bx	lr
 8003816:	bf00      	nop

08003818 <CTRL_getFlag_enableSpeedCtrl>:

//! \brief     Gets the enable speed control flag value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The enable speed control flag value
static inline bool CTRL_getFlag_enableSpeedCtrl(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003818:	b480      	push	{r7}
 800381a:	b085      	sub	sp, #20
 800381c:	af00      	add	r7, sp, #0
 800381e:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003820:	687b      	ldr	r3, [r7, #4]
 8003822:	60fb      	str	r3, [r7, #12]

  return(obj->flag_enableSpeedCtrl);
 8003824:	68fb      	ldr	r3, [r7, #12]
 8003826:	f893 31f8 	ldrb.w	r3, [r3, #504]	; 0x1f8
} // end of CTRL_getFlag_enableSpeedCtrl() function
 800382a:	4618      	mov	r0, r3
 800382c:	3714      	adds	r7, #20
 800382e:	46bd      	mov	sp, r7
 8003830:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003834:	4770      	bx	lr
 8003836:	bf00      	nop

08003838 <CTRL_getIab_in_addr>:

//! \brief     Gets the alpha/beta current input vector memory address from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The alpha/beta current input vector memory address
static inline MATH_vec2 *CTRL_getIab_in_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003838:	b480      	push	{r7}
 800383a:	b085      	sub	sp, #20
 800383c:	af00      	add	r7, sp, #0
 800383e:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003840:	687b      	ldr	r3, [r7, #4]
 8003842:	60fb      	str	r3, [r7, #12]

  return(&(obj->Iab_in));
 8003844:	68fb      	ldr	r3, [r7, #12]
 8003846:	f503 73b4 	add.w	r3, r3, #360	; 0x168
} // end of CTRL_getIab_in_addr() function
 800384a:	4618      	mov	r0, r3
 800384c:	3714      	adds	r7, #20
 800384e:	46bd      	mov	sp, r7
 8003850:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003854:	4770      	bx	lr
 8003856:	bf00      	nop

08003858 <CTRL_getId_in_pu>:

//! \brief     Gets the direct current input value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The direct current input value, pu
static inline float_t CTRL_getId_in_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003858:	b480      	push	{r7}
 800385a:	b085      	sub	sp, #20
 800385c:	af00      	add	r7, sp, #0
 800385e:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003860:	687b      	ldr	r3, [r7, #4]
 8003862:	60fb      	str	r3, [r7, #12]

  return(obj->Idq_in.value[0]);
 8003864:	68fb      	ldr	r3, [r7, #12]
 8003866:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 800386a:	ee07 3a90 	vmov	s15, r3
} // end of CTRL_getId_in_pu() function
 800386e:	eeb0 0a67 	vmov.f32	s0, s15
 8003872:	3714      	adds	r7, #20
 8003874:	46bd      	mov	sp, r7
 8003876:	f85d 7b04 	ldr.w	r7, [sp], #4
 800387a:	4770      	bx	lr

0800387c <CTRL_getId_ref_pu>:

//! \brief     Gets the direct current (Id) reference value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The direct current reference value, pu
static inline float_t CTRL_getId_ref_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
 800387c:	b480      	push	{r7}
 800387e:	b085      	sub	sp, #20
 8003880:	af00      	add	r7, sp, #0
 8003882:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003884:	687b      	ldr	r3, [r7, #4]
 8003886:	60fb      	str	r3, [r7, #12]

  return(obj->Idq_ref.value[0]);
 8003888:	68fb      	ldr	r3, [r7, #12]
 800388a:	f8d3 31d8 	ldr.w	r3, [r3, #472]	; 0x1d8
 800388e:	ee07 3a90 	vmov	s15, r3
} // end of CTRL_getId_ref_pu() function
 8003892:	eeb0 0a67 	vmov.f32	s0, s15
 8003896:	3714      	adds	r7, #20
 8003898:	46bd      	mov	sp, r7
 800389a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800389e:	4770      	bx	lr

080038a0 <CTRL_getIdq_in_addr>:

//! \brief     Gets the direct/quadrature current input vector memory address from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The direct/quadrature current input vector memory address
static inline MATH_vec2 *CTRL_getIdq_in_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
 80038a0:	b480      	push	{r7}
 80038a2:	b085      	sub	sp, #20
 80038a4:	af00      	add	r7, sp, #0
 80038a6:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80038a8:	687b      	ldr	r3, [r7, #4]
 80038aa:	60fb      	str	r3, [r7, #12]

  return(&(obj->Idq_in));
 80038ac:	68fb      	ldr	r3, [r7, #12]
 80038ae:	f503 73bc 	add.w	r3, r3, #376	; 0x178
} // end of CTRL_getIdq_in_addr() function
 80038b2:	4618      	mov	r0, r3
 80038b4:	3714      	adds	r7, #20
 80038b6:	46bd      	mov	sp, r7
 80038b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80038bc:	4770      	bx	lr
 80038be:	bf00      	nop

080038c0 <CTRL_getIq_in_pu>:

//! \brief     Gets the quadrature current input value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The quadrature current input value, pu
static inline float_t CTRL_getIq_in_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
 80038c0:	b480      	push	{r7}
 80038c2:	b085      	sub	sp, #20
 80038c4:	af00      	add	r7, sp, #0
 80038c6:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80038c8:	687b      	ldr	r3, [r7, #4]
 80038ca:	60fb      	str	r3, [r7, #12]

  return(obj->Idq_in.value[1]);
 80038cc:	68fb      	ldr	r3, [r7, #12]
 80038ce:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
 80038d2:	ee07 3a90 	vmov	s15, r3
} // end of CTRL_getIq_in_pu() function
 80038d6:	eeb0 0a67 	vmov.f32	s0, s15
 80038da:	3714      	adds	r7, #20
 80038dc:	46bd      	mov	sp, r7
 80038de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80038e2:	4770      	bx	lr

080038e4 <CTRL_getIq_ref_pu>:

//! \brief     Gets the quadrature current (Iq) reference value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The quadrature current reference value, pu
static inline float_t CTRL_getIq_ref_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
 80038e4:	b480      	push	{r7}
 80038e6:	b085      	sub	sp, #20
 80038e8:	af00      	add	r7, sp, #0
 80038ea:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80038ec:	687b      	ldr	r3, [r7, #4]
 80038ee:	60fb      	str	r3, [r7, #12]

  return(obj->Idq_ref.value[1]);
 80038f0:	68fb      	ldr	r3, [r7, #12]
 80038f2:	f8d3 31dc 	ldr.w	r3, [r3, #476]	; 0x1dc
 80038f6:	ee07 3a90 	vmov	s15, r3
} // end of CTRL_getIq_ref_pu() function
 80038fa:	eeb0 0a67 	vmov.f32	s0, s15
 80038fe:	3714      	adds	r7, #20
 8003900:	46bd      	mov	sp, r7
 8003902:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003906:	4770      	bx	lr

08003908 <CTRL_getKi>:
//! \brief     Gets the integral gain (Ki) value from the specified controller
//! \param[in] handle    The controller (CTRL) handle
//! \param[in] ctrlType  The controller type
//! \return    The Ki value
static inline float_t CTRL_getKi(CTRL_Handle handle,const CTRL_Type_e ctrlType)//! \Mod By Dl.K
{
 8003908:	b480      	push	{r7}
 800390a:	b085      	sub	sp, #20
 800390c:	af00      	add	r7, sp, #0
 800390e:	6078      	str	r0, [r7, #4]
 8003910:	460b      	mov	r3, r1
 8003912:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003914:	687b      	ldr	r3, [r7, #4]
 8003916:	60bb      	str	r3, [r7, #8]
  float_t Ki = (0.0f);
 8003918:	f04f 0300 	mov.w	r3, #0
 800391c:	60fb      	str	r3, [r7, #12]

  if(ctrlType == CTRL_Type_PID_spd)
 800391e:	78fb      	ldrb	r3, [r7, #3]
 8003920:	2b00      	cmp	r3, #0
 8003922:	d104      	bne.n	800392e <CTRL_getKi+0x26>
    {
      Ki = obj->Ki_spd;
 8003924:	68bb      	ldr	r3, [r7, #8]
 8003926:	f8d3 31bc 	ldr.w	r3, [r3, #444]	; 0x1bc
 800392a:	60fb      	str	r3, [r7, #12]
 800392c:	e00e      	b.n	800394c <CTRL_getKi+0x44>
    }
  else if(ctrlType == CTRL_Type_PID_Id)
 800392e:	78fb      	ldrb	r3, [r7, #3]
 8003930:	2b01      	cmp	r3, #1
 8003932:	d104      	bne.n	800393e <CTRL_getKi+0x36>
    {
      Ki = obj->Ki_Id;
 8003934:	68bb      	ldr	r3, [r7, #8]
 8003936:	f8d3 31b4 	ldr.w	r3, [r3, #436]	; 0x1b4
 800393a:	60fb      	str	r3, [r7, #12]
 800393c:	e006      	b.n	800394c <CTRL_getKi+0x44>
    }
  else if(ctrlType == CTRL_Type_PID_Iq)
 800393e:	78fb      	ldrb	r3, [r7, #3]
 8003940:	2b02      	cmp	r3, #2
 8003942:	d103      	bne.n	800394c <CTRL_getKi+0x44>
    {
      Ki = obj->Ki_Iq;
 8003944:	68bb      	ldr	r3, [r7, #8]
 8003946:	f8d3 31b8 	ldr.w	r3, [r3, #440]	; 0x1b8
 800394a:	60fb      	str	r3, [r7, #12]
    }

  return(Ki);
 800394c:	68fb      	ldr	r3, [r7, #12]
 800394e:	ee07 3a90 	vmov	s15, r3
} // end of CTRL_getKi() function
 8003952:	eeb0 0a67 	vmov.f32	s0, s15
 8003956:	3714      	adds	r7, #20
 8003958:	46bd      	mov	sp, r7
 800395a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800395e:	4770      	bx	lr

08003960 <CTRL_getKp>:
//! \brief     Gets the proportional gain (Kp) value from the specified controller
//! \param[in] handle    The controller (CTRL) handle
//! \param[in] ctrlType  The controller type
//! \return    The Kp value
static inline float_t CTRL_getKp(CTRL_Handle handle,const CTRL_Type_e ctrlType)//! \Mod By Dl.K
{
 8003960:	b480      	push	{r7}
 8003962:	b085      	sub	sp, #20
 8003964:	af00      	add	r7, sp, #0
 8003966:	6078      	str	r0, [r7, #4]
 8003968:	460b      	mov	r3, r1
 800396a:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 800396c:	687b      	ldr	r3, [r7, #4]
 800396e:	60bb      	str	r3, [r7, #8]
  float_t Kp = (0.0f);
 8003970:	f04f 0300 	mov.w	r3, #0
 8003974:	60fb      	str	r3, [r7, #12]

  if(ctrlType == CTRL_Type_PID_spd)
 8003976:	78fb      	ldrb	r3, [r7, #3]
 8003978:	2b00      	cmp	r3, #0
 800397a:	d104      	bne.n	8003986 <CTRL_getKp+0x26>
    {
      Kp = obj->Kp_spd;
 800397c:	68bb      	ldr	r3, [r7, #8]
 800397e:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 8003982:	60fb      	str	r3, [r7, #12]
 8003984:	e00e      	b.n	80039a4 <CTRL_getKp+0x44>
    }
  else if(ctrlType == CTRL_Type_PID_Id)
 8003986:	78fb      	ldrb	r3, [r7, #3]
 8003988:	2b01      	cmp	r3, #1
 800398a:	d104      	bne.n	8003996 <CTRL_getKp+0x36>
    {
      Kp = obj->Kp_Id;
 800398c:	68bb      	ldr	r3, [r7, #8]
 800398e:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8003992:	60fb      	str	r3, [r7, #12]
 8003994:	e006      	b.n	80039a4 <CTRL_getKp+0x44>
    }
  else if(ctrlType == CTRL_Type_PID_Iq)
 8003996:	78fb      	ldrb	r3, [r7, #3]
 8003998:	2b02      	cmp	r3, #2
 800399a:	d103      	bne.n	80039a4 <CTRL_getKp+0x44>
    {
      Kp = obj->Kp_Iq;
 800399c:	68bb      	ldr	r3, [r7, #8]
 800399e:	f8d3 31ac 	ldr.w	r3, [r3, #428]	; 0x1ac
 80039a2:	60fb      	str	r3, [r7, #12]
    }

  return(Kp);
 80039a4:	68fb      	ldr	r3, [r7, #12]
 80039a6:	ee07 3a90 	vmov	s15, r3
} // end of CTRL_getKp() function
 80039aa:	eeb0 0a67 	vmov.f32	s0, s15
 80039ae:	3714      	adds	r7, #20
 80039b0:	46bd      	mov	sp, r7
 80039b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80039b6:	4770      	bx	lr

080039b8 <CTRL_getNumIsrTicksPerCtrlTick>:

//! \brief     Gets the number of Interrupt Service Routine (ISR) clock ticks per controller clock tick
//! \param[in] handle  The controller (CTRL) handle
//! \return    The number of Interrupt Service Routine (ISR) clock ticks per controller clock tick
static inline uint_least16_t CTRL_getNumIsrTicksPerCtrlTick(CTRL_Handle handle)//! \Mod By Dl.K
{
 80039b8:	b480      	push	{r7}
 80039ba:	b085      	sub	sp, #20
 80039bc:	af00      	add	r7, sp, #0
 80039be:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80039c0:	687b      	ldr	r3, [r7, #4]
 80039c2:	60fb      	str	r3, [r7, #12]
  
  return(obj->numIsrTicksPerCtrlTick);
 80039c4:	68fb      	ldr	r3, [r7, #12]
 80039c6:	f8b3 314c 	ldrh.w	r3, [r3, #332]	; 0x14c
} // end of CTRL_getNumIsrTicksPerCtrlTick() function
 80039ca:	4618      	mov	r0, r3
 80039cc:	3714      	adds	r7, #20
 80039ce:	46bd      	mov	sp, r7
 80039d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80039d4:	4770      	bx	lr
 80039d6:	bf00      	nop

080039d8 <CTRL_getSpd_out_addr>:

//! \brief     Gets the output speed memory address from the controller
//! \param[in] handle    The controller (CTRL) handle
//! \return    The output speed memory address
static inline float_t *CTRL_getSpd_out_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
 80039d8:	b480      	push	{r7}
 80039da:	b085      	sub	sp, #20
 80039dc:	af00      	add	r7, sp, #0
 80039de:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80039e0:	687b      	ldr	r3, [r7, #4]
 80039e2:	60fb      	str	r3, [r7, #12]

  return(&(obj->spd_out));
 80039e4:	68fb      	ldr	r3, [r7, #12]
 80039e6:	f503 73c4 	add.w	r3, r3, #392	; 0x188
} // end of CTRL_getSpd_out_addr() function
 80039ea:	4618      	mov	r0, r3
 80039ec:	3714      	adds	r7, #20
 80039ee:	46bd      	mov	sp, r7
 80039f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80039f4:	4770      	bx	lr
 80039f6:	bf00      	nop

080039f8 <CTRL_getSpd_out_pu>:

//! \brief     Gets the output speed value from the controller
//! \param[in] handle    The controller (CTRL) handle
//! \return    The output speed value, pu
static inline float_t CTRL_getSpd_out_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
 80039f8:	b480      	push	{r7}
 80039fa:	b085      	sub	sp, #20
 80039fc:	af00      	add	r7, sp, #0
 80039fe:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003a00:	687b      	ldr	r3, [r7, #4]
 8003a02:	60fb      	str	r3, [r7, #12]

  return(obj->spd_out);
 8003a04:	68fb      	ldr	r3, [r7, #12]
 8003a06:	f8d3 3188 	ldr.w	r3, [r3, #392]	; 0x188
 8003a0a:	ee07 3a90 	vmov	s15, r3
} // end of CTRL_getSpd_out_pu() function
 8003a0e:	eeb0 0a67 	vmov.f32	s0, s15
 8003a12:	3714      	adds	r7, #20
 8003a14:	46bd      	mov	sp, r7
 8003a16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003a1a:	4770      	bx	lr

08003a1c <CTRL_getSpd_ref_pu>:

//! \brief     Gets the output speed reference value from the controller
//! \param[in] handle    The controller (CTRL) handle
//! \return    The output speed reference value, pu
static inline float_t CTRL_getSpd_ref_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003a1c:	b480      	push	{r7}
 8003a1e:	b085      	sub	sp, #20
 8003a20:	af00      	add	r7, sp, #0
 8003a22:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003a24:	687b      	ldr	r3, [r7, #4]
 8003a26:	60fb      	str	r3, [r7, #12]

  return(obj->spd_ref);
 8003a28:	68fb      	ldr	r3, [r7, #12]
 8003a2a:	f8d3 31e4 	ldr.w	r3, [r3, #484]	; 0x1e4
 8003a2e:	ee07 3a90 	vmov	s15, r3
} // end of CTRL_getSpd_ref_pu() function
 8003a32:	eeb0 0a67 	vmov.f32	s0, s15
 8003a36:	3714      	adds	r7, #20
 8003a38:	46bd      	mov	sp, r7
 8003a3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003a3e:	4770      	bx	lr

08003a40 <CTRL_getState>:

//! \brief     Gets the controller state
//! \param[in] handle  The controller (CTRL) handle
//! \return    The controller state
static inline CTRL_State_e CTRL_getState(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003a40:	b480      	push	{r7}
 8003a42:	b085      	sub	sp, #20
 8003a44:	af00      	add	r7, sp, #0
 8003a46:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003a48:	687b      	ldr	r3, [r7, #4]
 8003a4a:	60fb      	str	r3, [r7, #12]

  return(obj->state);
 8003a4c:	68fb      	ldr	r3, [r7, #12]
 8003a4e:	7a1b      	ldrb	r3, [r3, #8]
} // end of CTRL_getState() function
 8003a50:	4618      	mov	r0, r3
 8003a52:	3714      	adds	r7, #20
 8003a54:	46bd      	mov	sp, r7
 8003a56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003a5a:	4770      	bx	lr

08003a5c <CTRL_getVab_out_addr>:

//! \brief     Gets the alpha/beta voltage output vector memory address from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The alpha/beta voltage output vector memory address
static inline MATH_vec2 *CTRL_getVab_out_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003a5c:	b480      	push	{r7}
 8003a5e:	b085      	sub	sp, #20
 8003a60:	af00      	add	r7, sp, #0
 8003a62:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003a64:	687b      	ldr	r3, [r7, #4]
 8003a66:	60fb      	str	r3, [r7, #12]

  return(&(obj->Vab_out));
 8003a68:	68fb      	ldr	r3, [r7, #12]
 8003a6a:	f503 73c6 	add.w	r3, r3, #396	; 0x18c
} // end of CTRL_getVab_out_addr() function
 8003a6e:	4618      	mov	r0, r3
 8003a70:	3714      	adds	r7, #20
 8003a72:	46bd      	mov	sp, r7
 8003a74:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003a78:	4770      	bx	lr
 8003a7a:	bf00      	nop

08003a7c <CTRL_getVd_out_addr>:

//! \brief     Gets the direct voltage output value memory address from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The direct voltage output value memory address
static inline float_t *CTRL_getVd_out_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003a7c:	b480      	push	{r7}
 8003a7e:	b085      	sub	sp, #20
 8003a80:	af00      	add	r7, sp, #0
 8003a82:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003a84:	687b      	ldr	r3, [r7, #4]
 8003a86:	60fb      	str	r3, [r7, #12]

  return(&(obj->Vdq_out.value[0]));
 8003a88:	68fb      	ldr	r3, [r7, #12]
 8003a8a:	f503 73ca 	add.w	r3, r3, #404	; 0x194
} // end of CTRL_getVd_out_addr() function
 8003a8e:	4618      	mov	r0, r3
 8003a90:	3714      	adds	r7, #20
 8003a92:	46bd      	mov	sp, r7
 8003a94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003a98:	4770      	bx	lr
 8003a9a:	bf00      	nop

08003a9c <CTRL_getVdq_out_addr>:

//! \brief     Gets the direct/quadrature voltage output vector memory address from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The direct/quadrature voltage output vector memory address
static inline MATH_vec2 *CTRL_getVdq_out_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003a9c:	b480      	push	{r7}
 8003a9e:	b085      	sub	sp, #20
 8003aa0:	af00      	add	r7, sp, #0
 8003aa2:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003aa4:	687b      	ldr	r3, [r7, #4]
 8003aa6:	60fb      	str	r3, [r7, #12]

  return(&(obj->Vdq_out));
 8003aa8:	68fb      	ldr	r3, [r7, #12]
 8003aaa:	f503 73ca 	add.w	r3, r3, #404	; 0x194
} // end of CTRL_getVdq_out_pu() function
 8003aae:	4618      	mov	r0, r3
 8003ab0:	3714      	adds	r7, #20
 8003ab2:	46bd      	mov	sp, r7
 8003ab4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003ab8:	4770      	bx	lr
 8003aba:	bf00      	nop

08003abc <CTRL_getVq_out_addr>:

//! \brief     Gets the quadrature voltage output value memory address from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The quadrature voltage output value memory address
static inline float_t *CTRL_getVq_out_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003abc:	b480      	push	{r7}
 8003abe:	b085      	sub	sp, #20
 8003ac0:	af00      	add	r7, sp, #0
 8003ac2:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003ac4:	687b      	ldr	r3, [r7, #4]
 8003ac6:	60fb      	str	r3, [r7, #12]

  return(&(obj->Vdq_out.value[1]));
 8003ac8:	68fb      	ldr	r3, [r7, #12]
 8003aca:	f503 73cc 	add.w	r3, r3, #408	; 0x198
} // end of CTRL_getVq_out_addr() function
 8003ace:	4618      	mov	r0, r3
 8003ad0:	3714      	adds	r7, #20
 8003ad2:	46bd      	mov	sp, r7
 8003ad4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003ad8:	4770      	bx	lr
 8003ada:	bf00      	nop

08003adc <CTRL_getVq_out_pu>:

//! \brief     Gets the quadrature voltage output value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The quadrature voltage output value, pu
static inline float_t CTRL_getVq_out_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003adc:	b480      	push	{r7}
 8003ade:	b085      	sub	sp, #20
 8003ae0:	af00      	add	r7, sp, #0
 8003ae2:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003ae4:	687b      	ldr	r3, [r7, #4]
 8003ae6:	60fb      	str	r3, [r7, #12]

  return(obj->Vdq_out.value[1]);
 8003ae8:	68fb      	ldr	r3, [r7, #12]
 8003aea:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 8003aee:	ee07 3a90 	vmov	s15, r3
} // end of CTRL_getVq_out_pu() function
 8003af2:	eeb0 0a67 	vmov.f32	s0, s15
 8003af6:	3714      	adds	r7, #20
 8003af8:	46bd      	mov	sp, r7
 8003afa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003afe:	4770      	bx	lr

08003b00 <CTRL_incrCounter_current>:


//! \brief     Increments the current counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_incrCounter_current(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003b00:	b480      	push	{r7}
 8003b02:	b085      	sub	sp, #20
 8003b04:	af00      	add	r7, sp, #0
 8003b06:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003b08:	687b      	ldr	r3, [r7, #4]
 8003b0a:	60fb      	str	r3, [r7, #12]

  uint_least16_t count = obj->counter_current;
 8003b0c:	68fb      	ldr	r3, [r7, #12]
 8003b0e:	f8b3 31ec 	ldrh.w	r3, [r3, #492]	; 0x1ec
 8003b12:	817b      	strh	r3, [r7, #10]

  // increment the count
  count++;
 8003b14:	897b      	ldrh	r3, [r7, #10]
 8003b16:	3301      	adds	r3, #1
 8003b18:	817b      	strh	r3, [r7, #10]

  // save the count value
  obj->counter_current = count;
 8003b1a:	68fb      	ldr	r3, [r7, #12]
 8003b1c:	897a      	ldrh	r2, [r7, #10]
 8003b1e:	f8a3 21ec 	strh.w	r2, [r3, #492]	; 0x1ec

  return;
 8003b22:	bf00      	nop
} // end of CTRL_incrCounter_current() function
 8003b24:	3714      	adds	r7, #20
 8003b26:	46bd      	mov	sp, r7
 8003b28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003b2c:	4770      	bx	lr
 8003b2e:	bf00      	nop

08003b30 <CTRL_incrCounter_isr>:


//! \brief     Increments the isr counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_incrCounter_isr(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003b30:	b480      	push	{r7}
 8003b32:	b085      	sub	sp, #20
 8003b34:	af00      	add	r7, sp, #0
 8003b36:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003b38:	687b      	ldr	r3, [r7, #4]
 8003b3a:	60fb      	str	r3, [r7, #12]

  uint_least16_t count = obj->counter_isr;
 8003b3c:	68fb      	ldr	r3, [r7, #12]
 8003b3e:	f8b3 31ee 	ldrh.w	r3, [r3, #494]	; 0x1ee
 8003b42:	817b      	strh	r3, [r7, #10]

  // increment the count
  count++;
 8003b44:	897b      	ldrh	r3, [r7, #10]
 8003b46:	3301      	adds	r3, #1
 8003b48:	817b      	strh	r3, [r7, #10]

  // save the count value
  obj->counter_isr = count;
 8003b4a:	68fb      	ldr	r3, [r7, #12]
 8003b4c:	897a      	ldrh	r2, [r7, #10]
 8003b4e:	f8a3 21ee 	strh.w	r2, [r3, #494]	; 0x1ee

  return;
 8003b52:	bf00      	nop
} // end of CTRL_incrCounter_isr() function
 8003b54:	3714      	adds	r7, #20
 8003b56:	46bd      	mov	sp, r7
 8003b58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003b5c:	4770      	bx	lr
 8003b5e:	bf00      	nop

08003b60 <CTRL_incrCounter_speed>:


//! \brief     Increments the speed counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_incrCounter_speed(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003b60:	b480      	push	{r7}
 8003b62:	b085      	sub	sp, #20
 8003b64:	af00      	add	r7, sp, #0
 8003b66:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003b68:	687b      	ldr	r3, [r7, #4]
 8003b6a:	60fb      	str	r3, [r7, #12]

  uint_least16_t count = obj->counter_speed;
 8003b6c:	68fb      	ldr	r3, [r7, #12]
 8003b6e:	f8b3 31f0 	ldrh.w	r3, [r3, #496]	; 0x1f0
 8003b72:	817b      	strh	r3, [r7, #10]

  // increment the count
  count++;
 8003b74:	897b      	ldrh	r3, [r7, #10]
 8003b76:	3301      	adds	r3, #1
 8003b78:	817b      	strh	r3, [r7, #10]

  // save the count value
  obj->counter_speed = count;
 8003b7a:	68fb      	ldr	r3, [r7, #12]
 8003b7c:	897a      	ldrh	r2, [r7, #10]
 8003b7e:	f8a3 21f0 	strh.w	r2, [r3, #496]	; 0x1f0

  return;
 8003b82:	bf00      	nop
} // end of CTRL_incrCounter_speed() function
 8003b84:	3714      	adds	r7, #20
 8003b86:	46bd      	mov	sp, r7
 8003b88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003b8c:	4770      	bx	lr
 8003b8e:	bf00      	nop

08003b90 <CTRL_incrCounter_traj>:


//! \brief     Increments the trajectory counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_incrCounter_traj(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003b90:	b480      	push	{r7}
 8003b92:	b085      	sub	sp, #20
 8003b94:	af00      	add	r7, sp, #0
 8003b96:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003b98:	687b      	ldr	r3, [r7, #4]
 8003b9a:	60fb      	str	r3, [r7, #12]

  uint_least16_t count = obj->counter_traj;
 8003b9c:	68fb      	ldr	r3, [r7, #12]
 8003b9e:	f8b3 31f2 	ldrh.w	r3, [r3, #498]	; 0x1f2
 8003ba2:	817b      	strh	r3, [r7, #10]

  // increment the count
  count++;
 8003ba4:	897b      	ldrh	r3, [r7, #10]
 8003ba6:	3301      	adds	r3, #1
 8003ba8:	817b      	strh	r3, [r7, #10]

  // save the count value
  obj->counter_traj = count;
 8003baa:	68fb      	ldr	r3, [r7, #12]
 8003bac:	897a      	ldrh	r2, [r7, #10]
 8003bae:	f8a3 21f2 	strh.w	r2, [r3, #498]	; 0x1f2

  return;
 8003bb2:	bf00      	nop
} // end of CTRL_incrCounter_traj() function
 8003bb4:	3714      	adds	r7, #20
 8003bb6:	46bd      	mov	sp, r7
 8003bb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003bbc:	4770      	bx	lr
 8003bbe:	bf00      	nop

08003bc0 <CTRL_resetCounter_current>:


//! \brief     Resets the current counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_resetCounter_current(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003bc0:	b480      	push	{r7}
 8003bc2:	b085      	sub	sp, #20
 8003bc4:	af00      	add	r7, sp, #0
 8003bc6:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003bc8:	687b      	ldr	r3, [r7, #4]
 8003bca:	60fb      	str	r3, [r7, #12]

  obj->counter_current = 0;
 8003bcc:	68fb      	ldr	r3, [r7, #12]
 8003bce:	2200      	movs	r2, #0
 8003bd0:	f8a3 21ec 	strh.w	r2, [r3, #492]	; 0x1ec

  return;
 8003bd4:	bf00      	nop
} // end of CTRL_resetCounter_current() function
 8003bd6:	3714      	adds	r7, #20
 8003bd8:	46bd      	mov	sp, r7
 8003bda:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003bde:	4770      	bx	lr

08003be0 <CTRL_resetCounter_isr>:


//! \brief     Resets the isr counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_resetCounter_isr(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003be0:	b480      	push	{r7}
 8003be2:	b085      	sub	sp, #20
 8003be4:	af00      	add	r7, sp, #0
 8003be6:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003be8:	687b      	ldr	r3, [r7, #4]
 8003bea:	60fb      	str	r3, [r7, #12]

  obj->counter_isr = 1;
 8003bec:	68fb      	ldr	r3, [r7, #12]
 8003bee:	2201      	movs	r2, #1
 8003bf0:	f8a3 21ee 	strh.w	r2, [r3, #494]	; 0x1ee

  return;
 8003bf4:	bf00      	nop
} // end of CTRL_resetCounter_isr() function
 8003bf6:	3714      	adds	r7, #20
 8003bf8:	46bd      	mov	sp, r7
 8003bfa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003bfe:	4770      	bx	lr

08003c00 <CTRL_resetCounter_speed>:


//! \brief     Resets the speed counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_resetCounter_speed(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003c00:	b480      	push	{r7}
 8003c02:	b085      	sub	sp, #20
 8003c04:	af00      	add	r7, sp, #0
 8003c06:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003c08:	687b      	ldr	r3, [r7, #4]
 8003c0a:	60fb      	str	r3, [r7, #12]

  obj->counter_speed = 0;
 8003c0c:	68fb      	ldr	r3, [r7, #12]
 8003c0e:	2200      	movs	r2, #0
 8003c10:	f8a3 21f0 	strh.w	r2, [r3, #496]	; 0x1f0

  return;
 8003c14:	bf00      	nop
} // end of CTRL_resetCounter_speed() function
 8003c16:	3714      	adds	r7, #20
 8003c18:	46bd      	mov	sp, r7
 8003c1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003c1e:	4770      	bx	lr

08003c20 <CTRL_resetCounter_state>:


//! \brief     Resets the state counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_resetCounter_state(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003c20:	b480      	push	{r7}
 8003c22:	b085      	sub	sp, #20
 8003c24:	af00      	add	r7, sp, #0
 8003c26:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003c28:	687b      	ldr	r3, [r7, #4]
 8003c2a:	60fb      	str	r3, [r7, #12]

  obj->counter_state = 0;
 8003c2c:	68fb      	ldr	r3, [r7, #12]
 8003c2e:	2200      	movs	r2, #0
 8003c30:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148

  return;
 8003c34:	bf00      	nop
} // end of CTRL_resetCounter_state() function
 8003c36:	3714      	adds	r7, #20
 8003c38:	46bd      	mov	sp, r7
 8003c3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003c3e:	4770      	bx	lr

08003c40 <CTRL_resetCounter_traj>:


//! \brief     Resets the trajectory counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_resetCounter_traj(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003c40:	b480      	push	{r7}
 8003c42:	b085      	sub	sp, #20
 8003c44:	af00      	add	r7, sp, #0
 8003c46:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003c48:	687b      	ldr	r3, [r7, #4]
 8003c4a:	60fb      	str	r3, [r7, #12]

  obj->counter_traj = 0;
 8003c4c:	68fb      	ldr	r3, [r7, #12]
 8003c4e:	2200      	movs	r2, #0
 8003c50:	f8a3 21f2 	strh.w	r2, [r3, #498]	; 0x1f2

  return;
 8003c54:	bf00      	nop
} // end of CTRL_resetCounter_traj() function
 8003c56:	3714      	adds	r7, #20
 8003c58:	46bd      	mov	sp, r7
 8003c5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003c5e:	4770      	bx	lr

08003c60 <CTRL_setCtrlFreq_Hz>:

//! \brief      Sets the controller frequency
//! \param[in]  handle       The controller (CTRL) handle
//! \param[in]  ctrlFreq_Hz  The controller frequency, Hz
static inline void CTRL_setCtrlFreq_Hz(CTRL_Handle handle,const uint_least32_t ctrlFreq_Hz)//! \Mod By Dl.K
{
 8003c60:	b480      	push	{r7}
 8003c62:	b085      	sub	sp, #20
 8003c64:	af00      	add	r7, sp, #0
 8003c66:	6078      	str	r0, [r7, #4]
 8003c68:	6039      	str	r1, [r7, #0]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003c6a:	687b      	ldr	r3, [r7, #4]
 8003c6c:	60fb      	str	r3, [r7, #12]

  obj->ctrlFreq_Hz = ctrlFreq_Hz;
 8003c6e:	68fb      	ldr	r3, [r7, #12]
 8003c70:	683a      	ldr	r2, [r7, #0]
 8003c72:	f8c3 2154 	str.w	r2, [r3, #340]	; 0x154

  return;
 8003c76:	bf00      	nop
} // end of CTRL_setCtrlFreq_Hz() function
 8003c78:	3714      	adds	r7, #20
 8003c7a:	46bd      	mov	sp, r7
 8003c7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003c80:	4770      	bx	lr
 8003c82:	bf00      	nop

08003c84 <CTRL_setCtrlPeriod_sec>:

//! \brief      Sets the controller execution period
//! \param[in]  handle          The controller (CTRL) handle
//! \param[in]  ctrlPeriod_sec  The controller execution period, sec
static inline void CTRL_setCtrlPeriod_sec(CTRL_Handle handle,const float_t ctrlPeriod_sec)//! \Mod By Dl.K
{
 8003c84:	b480      	push	{r7}
 8003c86:	b085      	sub	sp, #20
 8003c88:	af00      	add	r7, sp, #0
 8003c8a:	6078      	str	r0, [r7, #4]
 8003c8c:	ed87 0a00 	vstr	s0, [r7]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003c90:	687b      	ldr	r3, [r7, #4]
 8003c92:	60fb      	str	r3, [r7, #12]

  obj->ctrlPeriod_sec = ctrlPeriod_sec;
 8003c94:	68fb      	ldr	r3, [r7, #12]
 8003c96:	683a      	ldr	r2, [r7, #0]
 8003c98:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160

  return;
 8003c9c:	bf00      	nop
} // end of CTRL_setCtrlPeriod_sec() function
 8003c9e:	3714      	adds	r7, #20
 8003ca0:	46bd      	mov	sp, r7
 8003ca2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003ca6:	4770      	bx	lr

08003ca8 <CTRL_setErrorCode>:

//! \brief      Sets the error code in the controller
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  errorCode   The error code
static inline void CTRL_setErrorCode(CTRL_Handle handle,const CTRL_ErrorCode_e errorCode)//! \Mod By Dl.K
{
 8003ca8:	b480      	push	{r7}
 8003caa:	b085      	sub	sp, #20
 8003cac:	af00      	add	r7, sp, #0
 8003cae:	6078      	str	r0, [r7, #4]
 8003cb0:	460b      	mov	r3, r1
 8003cb2:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003cb4:	687b      	ldr	r3, [r7, #4]
 8003cb6:	60fb      	str	r3, [r7, #12]

  obj->errorCode = errorCode;
 8003cb8:	68fb      	ldr	r3, [r7, #12]
 8003cba:	78fa      	ldrb	r2, [r7, #3]
 8003cbc:	729a      	strb	r2, [r3, #10]

  return;
 8003cbe:	bf00      	nop
} // end of CTRL_setErrorCode() function
 8003cc0:	3714      	adds	r7, #20
 8003cc2:	46bd      	mov	sp, r7
 8003cc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003cc8:	4770      	bx	lr
 8003cca:	bf00      	nop

08003ccc <CTRL_setEstParams>:
//! \details    Copies all scale factors that are defined in the file user.h and used
//!             by CTRL into the CTRL object.
//! \param[in]  estHandle    The estimator (EST) handle
//! \param[in]  pUserParams  The pointer to the user parameters
static inline void CTRL_setEstParams(EST_Handle estHandle,USER_Params *pUserParams)
{
 8003ccc:	b480      	push	{r7}
 8003cce:	b083      	sub	sp, #12
 8003cd0:	af00      	add	r7, sp, #0
 8003cd2:	6078      	str	r0, [r7, #4]
 8003cd4:	6039      	str	r1, [r7, #0]
}
 8003cd6:	370c      	adds	r7, #12
 8003cd8:	46bd      	mov	sp, r7
 8003cda:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003cde:	4770      	bx	lr

08003ce0 <CTRL_setFlag_enableCtrl>:
//!             motor commissioning is performed and then subsequent times it is called the
//!             motor starts to run.
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  state   The desired state
static inline void CTRL_setFlag_enableCtrl(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
 8003ce0:	b480      	push	{r7}
 8003ce2:	b085      	sub	sp, #20
 8003ce4:	af00      	add	r7, sp, #0
 8003ce6:	6078      	str	r0, [r7, #4]
 8003ce8:	460b      	mov	r3, r1
 8003cea:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003cec:	687b      	ldr	r3, [r7, #4]
 8003cee:	60fb      	str	r3, [r7, #12]

  obj->flag_enableCtrl = state;
 8003cf0:	68fb      	ldr	r3, [r7, #12]
 8003cf2:	78fa      	ldrb	r2, [r7, #3]
 8003cf4:	f883 21f4 	strb.w	r2, [r3, #500]	; 0x1f4

  return;
 8003cf8:	bf00      	nop
} // end of CTRL_setFlag_enableCtrl() function
 8003cfa:	3714      	adds	r7, #20
 8003cfc:	46bd      	mov	sp, r7
 8003cfe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003d02:	4770      	bx	lr

08003d04 <CTRL_setFlag_enableCurrentCtrl>:

//! \brief     Sets the enable current controllers flag value in the controller
//! \param[in] handle  The controller (CTRL) handle
//! \param[in] state   The desired state
static inline void CTRL_setFlag_enableCurrentCtrl(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
 8003d04:	b480      	push	{r7}
 8003d06:	b085      	sub	sp, #20
 8003d08:	af00      	add	r7, sp, #0
 8003d0a:	6078      	str	r0, [r7, #4]
 8003d0c:	460b      	mov	r3, r1
 8003d0e:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003d10:	687b      	ldr	r3, [r7, #4]
 8003d12:	60fb      	str	r3, [r7, #12]

  obj->flag_enableCurrentCtrl = state;
 8003d14:	68fb      	ldr	r3, [r7, #12]
 8003d16:	78fa      	ldrb	r2, [r7, #3]
 8003d18:	f883 2220 	strb.w	r2, [r3, #544]	; 0x220

  return;
 8003d1c:	bf00      	nop
} // end of CTRL_setFlag_enableCurrentCtrl() function
 8003d1e:	3714      	adds	r7, #20
 8003d20:	46bd      	mov	sp, r7
 8003d22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003d26:	4770      	bx	lr

08003d28 <CTRL_setFlag_enableDcBusComp>:
//! \details    The DC bus compensation algorithm will compensate the Iq and Id PI controller's
//!             proportional gains for DC bus variations.
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  state   The desired state
static inline void CTRL_setFlag_enableDcBusComp(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
 8003d28:	b480      	push	{r7}
 8003d2a:	b085      	sub	sp, #20
 8003d2c:	af00      	add	r7, sp, #0
 8003d2e:	6078      	str	r0, [r7, #4]
 8003d30:	460b      	mov	r3, r1
 8003d32:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003d34:	687b      	ldr	r3, [r7, #4]
 8003d36:	60fb      	str	r3, [r7, #12]

  obj->flag_enableDcBusComp = state;
 8003d38:	68fb      	ldr	r3, [r7, #12]
 8003d3a:	78fa      	ldrb	r2, [r7, #3]
 8003d3c:	f883 21f5 	strb.w	r2, [r3, #501]	; 0x1f5

  return;
 8003d40:	bf00      	nop
} // end of CTRL_setFlag_enableDcBusComp() function
 8003d42:	3714      	adds	r7, #20
 8003d44:	46bd      	mov	sp, r7
 8003d46:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003d4a:	4770      	bx	lr

08003d4c <CTRL_setFlag_enablePowerWarp>:
//!             levels so that the least amount of power is used according to the load on
//!             the motor.
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  state   The desired state
static inline void CTRL_setFlag_enablePowerWarp(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
 8003d4c:	b480      	push	{r7}
 8003d4e:	b085      	sub	sp, #20
 8003d50:	af00      	add	r7, sp, #0
 8003d52:	6078      	str	r0, [r7, #4]
 8003d54:	460b      	mov	r3, r1
 8003d56:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003d58:	687b      	ldr	r3, [r7, #4]
 8003d5a:	60fb      	str	r3, [r7, #12]

  obj->flag_enablePowerWarp = state;
 8003d5c:	68fb      	ldr	r3, [r7, #12]
 8003d5e:	78fa      	ldrb	r2, [r7, #3]
 8003d60:	f883 21f6 	strb.w	r2, [r3, #502]	; 0x1f6

  return;
 8003d64:	bf00      	nop
} // end of CTRL_setFlag_enablePowerWarp() function
 8003d66:	3714      	adds	r7, #20
 8003d68:	46bd      	mov	sp, r7
 8003d6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003d6e:	4770      	bx	lr

08003d70 <CTRL_setFlag_enableOffset>:

//! \brief      Sets the enable offset flag value in the estimator
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  state   The desired state
static inline void CTRL_setFlag_enableOffset(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
 8003d70:	b480      	push	{r7}
 8003d72:	b085      	sub	sp, #20
 8003d74:	af00      	add	r7, sp, #0
 8003d76:	6078      	str	r0, [r7, #4]
 8003d78:	460b      	mov	r3, r1
 8003d7a:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003d7c:	687b      	ldr	r3, [r7, #4]
 8003d7e:	60fb      	str	r3, [r7, #12]

  obj->flag_enableOffset = state;
 8003d80:	68fb      	ldr	r3, [r7, #12]
 8003d82:	78fa      	ldrb	r2, [r7, #3]
 8003d84:	f883 21f7 	strb.w	r2, [r3, #503]	; 0x1f7

  return;
 8003d88:	bf00      	nop
} // end of CTRL_setFlag_enableOffset() function
 8003d8a:	3714      	adds	r7, #20
 8003d8c:	46bd      	mov	sp, r7
 8003d8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003d92:	4770      	bx	lr

08003d94 <CTRL_setFlag_enableSpeedCtrl>:

//! \brief      Sets the enable speed control value in the estimator
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  state   The desired state
static inline void CTRL_setFlag_enableSpeedCtrl(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
 8003d94:	b480      	push	{r7}
 8003d96:	b085      	sub	sp, #20
 8003d98:	af00      	add	r7, sp, #0
 8003d9a:	6078      	str	r0, [r7, #4]
 8003d9c:	460b      	mov	r3, r1
 8003d9e:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003da0:	687b      	ldr	r3, [r7, #4]
 8003da2:	60fb      	str	r3, [r7, #12]

  obj->flag_enableSpeedCtrl = state;
 8003da4:	68fb      	ldr	r3, [r7, #12]
 8003da6:	78fa      	ldrb	r2, [r7, #3]
 8003da8:	f883 21f8 	strb.w	r2, [r3, #504]	; 0x1f8

  return;
 8003dac:	bf00      	nop
} // end of CTRL_setFlag_enableSpeedCtrl() function
 8003dae:	3714      	adds	r7, #20
 8003db0:	46bd      	mov	sp, r7
 8003db2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003db6:	4770      	bx	lr

08003db8 <CTRL_setFlag_enableUserMotorParams>:
//!             in user.h are used instead of performing a motor commissioning at
//!             startup.
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  state   The desired state
static inline void CTRL_setFlag_enableUserMotorParams(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
 8003db8:	b480      	push	{r7}
 8003dba:	b085      	sub	sp, #20
 8003dbc:	af00      	add	r7, sp, #0
 8003dbe:	6078      	str	r0, [r7, #4]
 8003dc0:	460b      	mov	r3, r1
 8003dc2:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003dc4:	687b      	ldr	r3, [r7, #4]
 8003dc6:	60fb      	str	r3, [r7, #12]

  obj->flag_enableUserMotorParams = state;
 8003dc8:	68fb      	ldr	r3, [r7, #12]
 8003dca:	78fa      	ldrb	r2, [r7, #3]
 8003dcc:	f883 21f9 	strb.w	r2, [r3, #505]	; 0x1f9

  return;
 8003dd0:	bf00      	nop
} // end of CTRL_setFlag_enableUserMotorParams() function
 8003dd2:	3714      	adds	r7, #20
 8003dd4:	46bd      	mov	sp, r7
 8003dd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003dda:	4770      	bx	lr

08003ddc <CTRL_setIab_in_pu>:

//! \brief      Sets the alpha/beta current (Iab) input vector values in the controller
//! \param[in]  handle      The controller (CTRL) handle
//! \param[in]  pIab_in_pu  The vector of the alpha/beta current input vector values, pu
static inline void CTRL_setIab_in_pu(CTRL_Handle handle,const MATH_vec2 *pIab_in_pu)//! \Mod By Dl.K
{
 8003ddc:	b480      	push	{r7}
 8003dde:	b085      	sub	sp, #20
 8003de0:	af00      	add	r7, sp, #0
 8003de2:	6078      	str	r0, [r7, #4]
 8003de4:	6039      	str	r1, [r7, #0]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003de6:	687b      	ldr	r3, [r7, #4]
 8003de8:	60fb      	str	r3, [r7, #12]

  obj->Iab_in.value[0] = pIab_in_pu->value[0];
 8003dea:	683b      	ldr	r3, [r7, #0]
 8003dec:	681a      	ldr	r2, [r3, #0]
 8003dee:	68fb      	ldr	r3, [r7, #12]
 8003df0:	f8c3 2168 	str.w	r2, [r3, #360]	; 0x168
  obj->Iab_in.value[1] = pIab_in_pu->value[1];
 8003df4:	683b      	ldr	r3, [r7, #0]
 8003df6:	685a      	ldr	r2, [r3, #4]
 8003df8:	68fb      	ldr	r3, [r7, #12]
 8003dfa:	f8c3 216c 	str.w	r2, [r3, #364]	; 0x16c

  return;
 8003dfe:	bf00      	nop
} // end of CTRL_setIab_in_pu() function
 8003e00:	3714      	adds	r7, #20
 8003e02:	46bd      	mov	sp, r7
 8003e04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003e08:	4770      	bx	lr
 8003e0a:	bf00      	nop

08003e0c <CTRL_setIdq_in_pu>:

//! \brief      Sets the direct/quadrature current (Idq) input vector values in the controller
//! \param[in]  handle      The controller (CTRL) handle
//! \param[in]  pIdq_in_pu  The vector of the direct/quadrature current input vector values, pu
static inline void CTRL_setIdq_in_pu(CTRL_Handle handle,const MATH_vec2 *pIdq_in_pu)//! \Mod By Dl.K
{
 8003e0c:	b480      	push	{r7}
 8003e0e:	b085      	sub	sp, #20
 8003e10:	af00      	add	r7, sp, #0
 8003e12:	6078      	str	r0, [r7, #4]
 8003e14:	6039      	str	r1, [r7, #0]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003e16:	687b      	ldr	r3, [r7, #4]
 8003e18:	60fb      	str	r3, [r7, #12]

  obj->Idq_in.value[0] = pIdq_in_pu->value[0];
 8003e1a:	683b      	ldr	r3, [r7, #0]
 8003e1c:	681a      	ldr	r2, [r3, #0]
 8003e1e:	68fb      	ldr	r3, [r7, #12]
 8003e20:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
  obj->Idq_in.value[1] = pIdq_in_pu->value[1];
 8003e24:	683b      	ldr	r3, [r7, #0]
 8003e26:	685a      	ldr	r2, [r3, #4]
 8003e28:	68fb      	ldr	r3, [r7, #12]
 8003e2a:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c

  return;
 8003e2e:	bf00      	nop
} // end of CTRL_setIdq_in_pu() function
 8003e30:	3714      	adds	r7, #20
 8003e32:	46bd      	mov	sp, r7
 8003e34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003e38:	4770      	bx	lr
 8003e3a:	bf00      	nop

08003e3c <CTRL_setIdq_ref_pu>:

//! \brief      Sets the direct/quadrature current (Idq) reference vector values in the controller
//! \param[in]  handle       The controller (CTRL) handle
//! \param[in]  pIdq_ref_pu  The vector of the direct/quadrature current reference vector values, pu
static inline void CTRL_setIdq_ref_pu(CTRL_Handle handle,const MATH_vec2 *pIdq_ref_pu)//! \Mod By Dl.K
{
 8003e3c:	b480      	push	{r7}
 8003e3e:	b085      	sub	sp, #20
 8003e40:	af00      	add	r7, sp, #0
 8003e42:	6078      	str	r0, [r7, #4]
 8003e44:	6039      	str	r1, [r7, #0]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003e46:	687b      	ldr	r3, [r7, #4]
 8003e48:	60fb      	str	r3, [r7, #12]

  obj->Idq_ref.value[0] = pIdq_ref_pu->value[0];
 8003e4a:	683b      	ldr	r3, [r7, #0]
 8003e4c:	681a      	ldr	r2, [r3, #0]
 8003e4e:	68fb      	ldr	r3, [r7, #12]
 8003e50:	f8c3 21d8 	str.w	r2, [r3, #472]	; 0x1d8
  obj->Idq_ref.value[1] = pIdq_ref_pu->value[1];
 8003e54:	683b      	ldr	r3, [r7, #0]
 8003e56:	685a      	ldr	r2, [r3, #4]
 8003e58:	68fb      	ldr	r3, [r7, #12]
 8003e5a:	f8c3 21dc 	str.w	r2, [r3, #476]	; 0x1dc

  return;
 8003e5e:	bf00      	nop
} // end of CTRL_setIdq_ref_pu() function
 8003e60:	3714      	adds	r7, #20
 8003e62:	46bd      	mov	sp, r7
 8003e64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003e68:	4770      	bx	lr
 8003e6a:	bf00      	nop

08003e6c <CTRL_setIdRated_pu>:

//! \brief      Sets the Id rated current value in the controller
//! \param[in]  handle      The controller (CTRL) handle
//! \param[in]  IdRated_pu  The Id rated current value, pu
static inline void CTRL_setIdRated_pu(CTRL_Handle handle,const float_t IdRated_pu)//! \Mod By Dl.K
{
 8003e6c:	b480      	push	{r7}
 8003e6e:	b085      	sub	sp, #20
 8003e70:	af00      	add	r7, sp, #0
 8003e72:	6078      	str	r0, [r7, #4]
 8003e74:	ed87 0a00 	vstr	s0, [r7]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003e78:	687b      	ldr	r3, [r7, #4]
 8003e7a:	60fb      	str	r3, [r7, #12]

  obj->IdRated = IdRated_pu;
 8003e7c:	68fb      	ldr	r3, [r7, #12]
 8003e7e:	683a      	ldr	r2, [r7, #0]
 8003e80:	f8c3 21e0 	str.w	r2, [r3, #480]	; 0x1e0

  return;
 8003e84:	bf00      	nop
} // end of CTRL_setIdRated_pu() function
 8003e86:	3714      	adds	r7, #20
 8003e88:	46bd      	mov	sp, r7
 8003e8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003e8e:	4770      	bx	lr

08003e90 <CTRL_setKd>:
//! \brief      Sets the derivative gain (Kd) value for the specified controller
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  ctrlType  The controller type
//! \param[in]  Kd        The Kd value
static inline void CTRL_setKd(CTRL_Handle handle,const CTRL_Type_e ctrlType,const float_t Kd)//! \Mod By Dl.K
{
 8003e90:	b480      	push	{r7}
 8003e92:	b087      	sub	sp, #28
 8003e94:	af00      	add	r7, sp, #0
 8003e96:	60f8      	str	r0, [r7, #12]
 8003e98:	460b      	mov	r3, r1
 8003e9a:	ed87 0a01 	vstr	s0, [r7, #4]
 8003e9e:	72fb      	strb	r3, [r7, #11]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003ea0:	68fb      	ldr	r3, [r7, #12]
 8003ea2:	617b      	str	r3, [r7, #20]

  if(ctrlType == CTRL_Type_PID_spd)
 8003ea4:	7afb      	ldrb	r3, [r7, #11]
 8003ea6:	2b00      	cmp	r3, #0
 8003ea8:	d104      	bne.n	8003eb4 <CTRL_setKd+0x24>
    {
      obj->Kd_spd = Kd;
 8003eaa:	697b      	ldr	r3, [r7, #20]
 8003eac:	687a      	ldr	r2, [r7, #4]
 8003eae:	f8c3 21c8 	str.w	r2, [r3, #456]	; 0x1c8
 8003eb2:	e00e      	b.n	8003ed2 <CTRL_setKd+0x42>
    }
  else if(ctrlType == CTRL_Type_PID_Id)
 8003eb4:	7afb      	ldrb	r3, [r7, #11]
 8003eb6:	2b01      	cmp	r3, #1
 8003eb8:	d104      	bne.n	8003ec4 <CTRL_setKd+0x34>
    {
      obj->Kd_Id = Kd;
 8003eba:	697b      	ldr	r3, [r7, #20]
 8003ebc:	687a      	ldr	r2, [r7, #4]
 8003ebe:	f8c3 21c0 	str.w	r2, [r3, #448]	; 0x1c0
 8003ec2:	e006      	b.n	8003ed2 <CTRL_setKd+0x42>
    }
  else if(ctrlType == CTRL_Type_PID_Iq)
 8003ec4:	7afb      	ldrb	r3, [r7, #11]
 8003ec6:	2b02      	cmp	r3, #2
 8003ec8:	d103      	bne.n	8003ed2 <CTRL_setKd+0x42>
    {
      obj->Kd_Iq = Kd;
 8003eca:	697b      	ldr	r3, [r7, #20]
 8003ecc:	687a      	ldr	r2, [r7, #4]
 8003ece:	f8c3 21c4 	str.w	r2, [r3, #452]	; 0x1c4
    }

  return;
 8003ed2:	bf00      	nop
} // end of CTRL_setKd() function
 8003ed4:	371c      	adds	r7, #28
 8003ed6:	46bd      	mov	sp, r7
 8003ed8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003edc:	4770      	bx	lr
 8003ede:	bf00      	nop

08003ee0 <CTRL_setKi>:
//! \brief      Sets the integral gain (Ki) value for the specified controller
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  ctrlType  The controller type
//! \param[in]  Ki        The Ki value
static inline void CTRL_setKi(CTRL_Handle handle,const CTRL_Type_e ctrlType,const float_t Ki)//! \Mod By Dl.K
{
 8003ee0:	b480      	push	{r7}
 8003ee2:	b087      	sub	sp, #28
 8003ee4:	af00      	add	r7, sp, #0
 8003ee6:	60f8      	str	r0, [r7, #12]
 8003ee8:	460b      	mov	r3, r1
 8003eea:	ed87 0a01 	vstr	s0, [r7, #4]
 8003eee:	72fb      	strb	r3, [r7, #11]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003ef0:	68fb      	ldr	r3, [r7, #12]
 8003ef2:	617b      	str	r3, [r7, #20]

  if(ctrlType == CTRL_Type_PID_spd)
 8003ef4:	7afb      	ldrb	r3, [r7, #11]
 8003ef6:	2b00      	cmp	r3, #0
 8003ef8:	d104      	bne.n	8003f04 <CTRL_setKi+0x24>
    {
      obj->Ki_spd = Ki;
 8003efa:	697b      	ldr	r3, [r7, #20]
 8003efc:	687a      	ldr	r2, [r7, #4]
 8003efe:	f8c3 21bc 	str.w	r2, [r3, #444]	; 0x1bc
 8003f02:	e00e      	b.n	8003f22 <CTRL_setKi+0x42>
    }
  else if(ctrlType == CTRL_Type_PID_Id)
 8003f04:	7afb      	ldrb	r3, [r7, #11]
 8003f06:	2b01      	cmp	r3, #1
 8003f08:	d104      	bne.n	8003f14 <CTRL_setKi+0x34>
    {
      obj->Ki_Id = Ki;
 8003f0a:	697b      	ldr	r3, [r7, #20]
 8003f0c:	687a      	ldr	r2, [r7, #4]
 8003f0e:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
 8003f12:	e006      	b.n	8003f22 <CTRL_setKi+0x42>
    }
  else if(ctrlType == CTRL_Type_PID_Iq)
 8003f14:	7afb      	ldrb	r3, [r7, #11]
 8003f16:	2b02      	cmp	r3, #2
 8003f18:	d103      	bne.n	8003f22 <CTRL_setKi+0x42>
    {
      obj->Ki_Iq = Ki;
 8003f1a:	697b      	ldr	r3, [r7, #20]
 8003f1c:	687a      	ldr	r2, [r7, #4]
 8003f1e:	f8c3 21b8 	str.w	r2, [r3, #440]	; 0x1b8
    }

  return;
 8003f22:	bf00      	nop
} // end of CTRL_setKi() function
 8003f24:	371c      	adds	r7, #28
 8003f26:	46bd      	mov	sp, r7
 8003f28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003f2c:	4770      	bx	lr
 8003f2e:	bf00      	nop

08003f30 <CTRL_setKp>:
//! \brief      Sets the proportional gain (Kp) value for the specified controller
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  ctrlType  The controller type
//! \param[in]  Kp        The Kp value
static inline void CTRL_setKp(CTRL_Handle handle,const CTRL_Type_e ctrlType,const float_t Kp)//! \Mod By Dl.K
{
 8003f30:	b480      	push	{r7}
 8003f32:	b087      	sub	sp, #28
 8003f34:	af00      	add	r7, sp, #0
 8003f36:	60f8      	str	r0, [r7, #12]
 8003f38:	460b      	mov	r3, r1
 8003f3a:	ed87 0a01 	vstr	s0, [r7, #4]
 8003f3e:	72fb      	strb	r3, [r7, #11]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003f40:	68fb      	ldr	r3, [r7, #12]
 8003f42:	617b      	str	r3, [r7, #20]

  if(ctrlType == CTRL_Type_PID_spd)
 8003f44:	7afb      	ldrb	r3, [r7, #11]
 8003f46:	2b00      	cmp	r3, #0
 8003f48:	d104      	bne.n	8003f54 <CTRL_setKp+0x24>
    {
      obj->Kp_spd = Kp;
 8003f4a:	697b      	ldr	r3, [r7, #20]
 8003f4c:	687a      	ldr	r2, [r7, #4]
 8003f4e:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
 8003f52:	e00e      	b.n	8003f72 <CTRL_setKp+0x42>
    }
  else if(ctrlType == CTRL_Type_PID_Id)
 8003f54:	7afb      	ldrb	r3, [r7, #11]
 8003f56:	2b01      	cmp	r3, #1
 8003f58:	d104      	bne.n	8003f64 <CTRL_setKp+0x34>
    {
      obj->Kp_Id = Kp;
 8003f5a:	697b      	ldr	r3, [r7, #20]
 8003f5c:	687a      	ldr	r2, [r7, #4]
 8003f5e:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
 8003f62:	e006      	b.n	8003f72 <CTRL_setKp+0x42>
    }
  else if(ctrlType == CTRL_Type_PID_Iq)
 8003f64:	7afb      	ldrb	r3, [r7, #11]
 8003f66:	2b02      	cmp	r3, #2
 8003f68:	d103      	bne.n	8003f72 <CTRL_setKp+0x42>
    {
      obj->Kp_Iq = Kp;
 8003f6a:	697b      	ldr	r3, [r7, #20]
 8003f6c:	687a      	ldr	r2, [r7, #4]
 8003f6e:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
    }

  return;
 8003f72:	bf00      	nop
} // end of CTRL_setKp() function
 8003f74:	371c      	adds	r7, #28
 8003f76:	46bd      	mov	sp, r7
 8003f78:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003f7c:	4770      	bx	lr
 8003f7e:	bf00      	nop

08003f80 <CTRL_setLhf>:

//! \brief      Sets the high frequency inductance (Lhf) value in the controller
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  Lhf     The Lhf value
static inline void CTRL_setLhf(CTRL_Handle handle,const float_t Lhf)//! \Mod By Dl.K
{
 8003f80:	b480      	push	{r7}
 8003f82:	b085      	sub	sp, #20
 8003f84:	af00      	add	r7, sp, #0
 8003f86:	6078      	str	r0, [r7, #4]
 8003f88:	ed87 0a00 	vstr	s0, [r7]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003f8c:	687b      	ldr	r3, [r7, #4]
 8003f8e:	60fb      	str	r3, [r7, #12]

  obj->Lhf = Lhf;
 8003f90:	68fb      	ldr	r3, [r7, #12]
 8003f92:	683a      	ldr	r2, [r7, #0]
 8003f94:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0

  return;
 8003f98:	bf00      	nop
} // end of CTRL_setLhf() function
 8003f9a:	3714      	adds	r7, #20
 8003f9c:	46bd      	mov	sp, r7
 8003f9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003fa2:	4770      	bx	lr

08003fa4 <CTRL_setMaxVsMag_pu>:

//! \brief      Sets the maximum voltage vector in the controller
//! \param[in]  handle        The controller (CTRL) handle
//! \param[in]  maxVsMag      The maximum voltage vector (value betwen 0 and 4/3)
static inline void CTRL_setMaxVsMag_pu(CTRL_Handle handle,const float_t maxVsMag)//! \Mod By Dl.K
{
 8003fa4:	b480      	push	{r7}
 8003fa6:	b085      	sub	sp, #20
 8003fa8:	af00      	add	r7, sp, #0
 8003faa:	6078      	str	r0, [r7, #4]
 8003fac:	ed87 0a00 	vstr	s0, [r7]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003fb0:	687b      	ldr	r3, [r7, #4]
 8003fb2:	60fb      	str	r3, [r7, #12]

  obj->maxVsMag_pu = maxVsMag;
 8003fb4:	68fb      	ldr	r3, [r7, #12]
 8003fb6:	683a      	ldr	r2, [r7, #0]
 8003fb8:	f8c3 2164 	str.w	r2, [r3, #356]	; 0x164

  return;
 8003fbc:	bf00      	nop
} // end of CTRL_setmaxVsMag_pu() function
 8003fbe:	3714      	adds	r7, #20
 8003fc0:	46bd      	mov	sp, r7
 8003fc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003fc6:	4770      	bx	lr

08003fc8 <CTRL_setMotorParams>:
                                const float_t ratedFlux,
                                const float_t Ls_d,
                                const float_t Ls_q,
                                const float_t Rr,
                                const float_t Rs)//! \Mod By Dl.K
{
 8003fc8:	b480      	push	{r7}
 8003fca:	b08b      	sub	sp, #44	; 0x2c
 8003fcc:	af00      	add	r7, sp, #0
 8003fce:	61f8      	str	r0, [r7, #28]
 8003fd0:	460b      	mov	r3, r1
 8003fd2:	ed87 0a05 	vstr	s0, [r7, #20]
 8003fd6:	edc7 0a04 	vstr	s1, [r7, #16]
 8003fda:	ed87 1a03 	vstr	s2, [r7, #12]
 8003fde:	edc7 1a02 	vstr	s3, [r7, #8]
 8003fe2:	ed87 2a01 	vstr	s4, [r7, #4]
 8003fe6:	76fb      	strb	r3, [r7, #27]
 8003fe8:	4613      	mov	r3, r2
 8003fea:	833b      	strh	r3, [r7, #24]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003fec:	69fb      	ldr	r3, [r7, #28]
 8003fee:	627b      	str	r3, [r7, #36]	; 0x24

  obj->motorParams.type = motorType;
 8003ff0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003ff2:	7efa      	ldrb	r2, [r7, #27]
 8003ff4:	f883 2104 	strb.w	r2, [r3, #260]	; 0x104
  obj->motorParams.numPolePairs = numPolePairs;
 8003ff8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003ffa:	8b3a      	ldrh	r2, [r7, #24]
 8003ffc:	f8a3 2106 	strh.w	r2, [r3, #262]	; 0x106
  obj->motorParams.ratedFlux_VpHz = ratedFlux;
 8004000:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004002:	697a      	ldr	r2, [r7, #20]
 8004004:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
  obj->motorParams.Ls_d_H = Ls_d;
 8004008:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800400a:	693a      	ldr	r2, [r7, #16]
 800400c:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
  obj->motorParams.Ls_q_H = Ls_q;
 8004010:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004012:	68fa      	ldr	r2, [r7, #12]
 8004014:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
  obj->motorParams.Rr_Ohm = Rr;
 8004018:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800401a:	68ba      	ldr	r2, [r7, #8]
 800401c:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
  obj->motorParams.Rs_Ohm = Rs;
 8004020:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004022:	687a      	ldr	r2, [r7, #4]
 8004024:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118

  return;
 8004028:	bf00      	nop
} // end of CTRL_setMotorParams() function
 800402a:	372c      	adds	r7, #44	; 0x2c
 800402c:	46bd      	mov	sp, r7
 800402e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004032:	4770      	bx	lr

08004034 <CTRL_setNumCtrlTicksPerCurrentTick>:
//! \brief     Sets the number of controller clock ticks per current controller clock tick
//! \param[in] handle                      The controller (CTRL) handle
//! \param[in] numCtrlTicksPerCurrentTick  The number of controller clock ticks per estimator clock tick
static inline void CTRL_setNumCtrlTicksPerCurrentTick(CTRL_Handle handle,
                                               const uint_least16_t numCtrlTicksPerCurrentTick)//! \Mod By Dl.K
{
 8004034:	b480      	push	{r7}
 8004036:	b085      	sub	sp, #20
 8004038:	af00      	add	r7, sp, #0
 800403a:	6078      	str	r0, [r7, #4]
 800403c:	460b      	mov	r3, r1
 800403e:	807b      	strh	r3, [r7, #2]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8004040:	687b      	ldr	r3, [r7, #4]
 8004042:	60fb      	str	r3, [r7, #12]

  obj->numCtrlTicksPerCurrentTick = numCtrlTicksPerCurrentTick;
 8004044:	68fb      	ldr	r3, [r7, #12]
 8004046:	887a      	ldrh	r2, [r7, #2]
 8004048:	f8a3 214e 	strh.w	r2, [r3, #334]	; 0x14e

  return;
 800404c:	bf00      	nop
} // end of CTRL_setNumCtrlTicksPerCurrentTick() function
 800404e:	3714      	adds	r7, #20
 8004050:	46bd      	mov	sp, r7
 8004052:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004056:	4770      	bx	lr

08004058 <CTRL_setNumCtrlTicksPerSpeedTick>:
//! \brief     Sets the number of controller clock ticks per speed controller clock tick
//! \param[in] handle                    The controller (CTRL) handle
//! \param[in] numCtrlTicksPerSpeedTick  The number of controller clock ticks per speed clock tick
static inline void CTRL_setNumCtrlTicksPerSpeedTick(CTRL_Handle handle,
                                               const uint_least16_t numCtrlTicksPerSpeedTick)//! \Mod By Dl.K
{
 8004058:	b480      	push	{r7}
 800405a:	b085      	sub	sp, #20
 800405c:	af00      	add	r7, sp, #0
 800405e:	6078      	str	r0, [r7, #4]
 8004060:	460b      	mov	r3, r1
 8004062:	807b      	strh	r3, [r7, #2]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8004064:	687b      	ldr	r3, [r7, #4]
 8004066:	60fb      	str	r3, [r7, #12]

  obj->numCtrlTicksPerSpeedTick = numCtrlTicksPerSpeedTick;
 8004068:	68fb      	ldr	r3, [r7, #12]
 800406a:	887a      	ldrh	r2, [r7, #2]
 800406c:	f8a3 2150 	strh.w	r2, [r3, #336]	; 0x150

  return;
 8004070:	bf00      	nop
} // end of CTRL_setNumCtrlTicksPerSpeedTick() function
 8004072:	3714      	adds	r7, #20
 8004074:	46bd      	mov	sp, r7
 8004076:	f85d 7b04 	ldr.w	r7, [sp], #4
 800407a:	4770      	bx	lr

0800407c <CTRL_setNumCtrlTicksPerTrajTick>:
//! \brief     Sets the number of controller clock ticks per trajectory clock tick
//! \param[in] handle                   The controller (CTRL) handle
//! \param[in] numCtrlTicksPerTrajTick  The number of controller clock ticks per trajectory clock tick
static inline void CTRL_setNumCtrlTicksPerTrajTick(CTRL_Handle handle,
                                               const uint_least16_t numCtrlTicksPerTrajTick)//! \Mod By Dl.K
{
 800407c:	b480      	push	{r7}
 800407e:	b085      	sub	sp, #20
 8004080:	af00      	add	r7, sp, #0
 8004082:	6078      	str	r0, [r7, #4]
 8004084:	460b      	mov	r3, r1
 8004086:	807b      	strh	r3, [r7, #2]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8004088:	687b      	ldr	r3, [r7, #4]
 800408a:	60fb      	str	r3, [r7, #12]

  obj->numCtrlTicksPerTrajTick = numCtrlTicksPerTrajTick;
 800408c:	68fb      	ldr	r3, [r7, #12]
 800408e:	887a      	ldrh	r2, [r7, #2]
 8004090:	f8a3 2152 	strh.w	r2, [r3, #338]	; 0x152

  return;
 8004094:	bf00      	nop
} // end of CTRL_setNumCtrlTicksPerTrajTick() function
 8004096:	3714      	adds	r7, #20
 8004098:	46bd      	mov	sp, r7
 800409a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800409e:	4770      	bx	lr

080040a0 <CTRL_setNumIsrTicksPerCtrlTick>:
//! \brief     Sets the number of Interrupt Service Routine (ISR) clock ticks per controller clock tick
//! \param[in] handle                  The controller (CTRL) handle
//! \param[in] numIsrTicksPerCtrlTick  The number of Interrupt Service Routine (ISR) clock ticks per controller clock tick
static inline void CTRL_setNumIsrTicksPerCtrlTick(CTRL_Handle handle,
                                           const uint_least16_t numIsrTicksPerCtrlTick)//! \Mod By Dl.K
{
 80040a0:	b480      	push	{r7}
 80040a2:	b085      	sub	sp, #20
 80040a4:	af00      	add	r7, sp, #0
 80040a6:	6078      	str	r0, [r7, #4]
 80040a8:	460b      	mov	r3, r1
 80040aa:	807b      	strh	r3, [r7, #2]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80040ac:	687b      	ldr	r3, [r7, #4]
 80040ae:	60fb      	str	r3, [r7, #12]

  obj->numIsrTicksPerCtrlTick = numIsrTicksPerCtrlTick;
 80040b0:	68fb      	ldr	r3, [r7, #12]
 80040b2:	887a      	ldrh	r2, [r7, #2]
 80040b4:	f8a3 214c 	strh.w	r2, [r3, #332]	; 0x14c

  return;
 80040b8:	bf00      	nop
} // end of CTRL_setNumIsrTicksPerCtrlTick() function
 80040ba:	3714      	adds	r7, #20
 80040bc:	46bd      	mov	sp, r7
 80040be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80040c2:	4770      	bx	lr

080040c4 <CTRL_setRhf>:

//! \brief     Sets the high frequency resistance (Rhf) value in the controller
//! \param[in] handle  The controller (CTRL) handle
//! \param[in] Rhf     The Rhf value
static inline void CTRL_setRhf(CTRL_Handle handle,const float_t Rhf)//! \Mod By Dl.K
{
 80040c4:	b480      	push	{r7}
 80040c6:	b085      	sub	sp, #20
 80040c8:	af00      	add	r7, sp, #0
 80040ca:	6078      	str	r0, [r7, #4]
 80040cc:	ed87 0a00 	vstr	s0, [r7]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80040d0:	687b      	ldr	r3, [r7, #4]
 80040d2:	60fb      	str	r3, [r7, #12]

  obj->Rhf = Rhf;
 80040d4:	68fb      	ldr	r3, [r7, #12]
 80040d6:	683a      	ldr	r2, [r7, #0]
 80040d8:	f8c3 219c 	str.w	r2, [r3, #412]	; 0x19c

  return;
 80040dc:	bf00      	nop
} // end of CTRL_setRhf() function
 80040de:	3714      	adds	r7, #20
 80040e0:	46bd      	mov	sp, r7
 80040e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80040e6:	4770      	bx	lr

080040e8 <CTRL_setRoverL>:

//! \brief     Sets the R/L value in the controller
//! \param[in] handle  The controller (CTRL) handle
//! \param[in] RoverL  The R/L value
static inline void CTRL_setRoverL(CTRL_Handle handle,const float_t RoverL)//! \Mod By Dl.K
{
 80040e8:	b480      	push	{r7}
 80040ea:	b085      	sub	sp, #20
 80040ec:	af00      	add	r7, sp, #0
 80040ee:	6078      	str	r0, [r7, #4]
 80040f0:	ed87 0a00 	vstr	s0, [r7]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80040f4:	687b      	ldr	r3, [r7, #4]
 80040f6:	60fb      	str	r3, [r7, #12]

  obj->RoverL = RoverL;
 80040f8:	68fb      	ldr	r3, [r7, #12]
 80040fa:	683a      	ldr	r2, [r7, #0]
 80040fc:	f8c3 21a4 	str.w	r2, [r3, #420]	; 0x1a4

  return;
 8004100:	bf00      	nop
} // end of CTRL_setRoverL() function
 8004102:	3714      	adds	r7, #20
 8004104:	46bd      	mov	sp, r7
 8004106:	f85d 7b04 	ldr.w	r7, [sp], #4
 800410a:	4770      	bx	lr

0800410c <CTRL_setSpd_out_pu>:

//! \brief     Sets the output speed value in the controller
//! \param[in] handle      The controller (CTRL) handle
//! \param[in] spd_out_pu  The output speed value, pu
static inline void CTRL_setSpd_out_pu(CTRL_Handle handle,const float_t spd_out_pu)//! \Mod By Dl.K
{
 800410c:	b480      	push	{r7}
 800410e:	b085      	sub	sp, #20
 8004110:	af00      	add	r7, sp, #0
 8004112:	6078      	str	r0, [r7, #4]
 8004114:	ed87 0a00 	vstr	s0, [r7]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8004118:	687b      	ldr	r3, [r7, #4]
 800411a:	60fb      	str	r3, [r7, #12]

  obj->spd_out = spd_out_pu;
 800411c:	68fb      	ldr	r3, [r7, #12]
 800411e:	683a      	ldr	r2, [r7, #0]
 8004120:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188

  return;
 8004124:	bf00      	nop
} // end of CTRL_setSpd_out_pu() function
 8004126:	3714      	adds	r7, #20
 8004128:	46bd      	mov	sp, r7
 800412a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800412e:	4770      	bx	lr

08004130 <CTRL_setState>:

//! \brief     Sets the controller state
//! \param[in] handle  The controller (CTRL) handle
//! \param[in] state       The new state
static inline void CTRL_setState(CTRL_Handle handle,const CTRL_State_e state)//! \Mod By Dl.K
{
 8004130:	b480      	push	{r7}
 8004132:	b085      	sub	sp, #20
 8004134:	af00      	add	r7, sp, #0
 8004136:	6078      	str	r0, [r7, #4]
 8004138:	460b      	mov	r3, r1
 800413a:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 800413c:	687b      	ldr	r3, [r7, #4]
 800413e:	60fb      	str	r3, [r7, #12]

  obj->prevState = obj->state;
 8004140:	68fb      	ldr	r3, [r7, #12]
 8004142:	7a1a      	ldrb	r2, [r3, #8]
 8004144:	68fb      	ldr	r3, [r7, #12]
 8004146:	725a      	strb	r2, [r3, #9]
  obj->state = state;
 8004148:	68fb      	ldr	r3, [r7, #12]
 800414a:	78fa      	ldrb	r2, [r7, #3]
 800414c:	721a      	strb	r2, [r3, #8]

  return;
 800414e:	bf00      	nop
} // end of CTRL_setState() function
 8004150:	3714      	adds	r7, #20
 8004152:	46bd      	mov	sp, r7
 8004154:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004158:	4770      	bx	lr
 800415a:	bf00      	nop

0800415c <CTRL_setTrajFreq_Hz>:

//! \brief      Sets the trajectory execution frequency
//! \param[in]  handle       The controller (CTRL) handle
//! \param[in]  trajFreq_Hz  The trajectory execution frequency, Hz
static inline void CTRL_setTrajFreq_Hz(CTRL_Handle handle,const uint_least32_t trajFreq_Hz)//! \Mod By Dl.K
{
 800415c:	b480      	push	{r7}
 800415e:	b085      	sub	sp, #20
 8004160:	af00      	add	r7, sp, #0
 8004162:	6078      	str	r0, [r7, #4]
 8004164:	6039      	str	r1, [r7, #0]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8004166:	687b      	ldr	r3, [r7, #4]
 8004168:	60fb      	str	r3, [r7, #12]

  obj->trajFreq_Hz = trajFreq_Hz;
 800416a:	68fb      	ldr	r3, [r7, #12]
 800416c:	683a      	ldr	r2, [r7, #0]
 800416e:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158

  return;
 8004172:	bf00      	nop
} // end of CTRL_setTrajFreq_Hz() function
 8004174:	3714      	adds	r7, #20
 8004176:	46bd      	mov	sp, r7
 8004178:	f85d 7b04 	ldr.w	r7, [sp], #4
 800417c:	4770      	bx	lr
 800417e:	bf00      	nop

08004180 <CTRL_setTrajPeriod_sec>:

//! \brief      Sets the trajectory execution period
//! \param[in]  handle          The controller (CTRL) handle
//! \param[in]  trajPeriod_sec  The trajectory execution period, sec
static inline void CTRL_setTrajPeriod_sec(CTRL_Handle handle,const float_t trajPeriod_sec)//! \Mod By Dl.K
{
 8004180:	b480      	push	{r7}
 8004182:	b085      	sub	sp, #20
 8004184:	af00      	add	r7, sp, #0
 8004186:	6078      	str	r0, [r7, #4]
 8004188:	ed87 0a00 	vstr	s0, [r7]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 800418c:	687b      	ldr	r3, [r7, #4]
 800418e:	60fb      	str	r3, [r7, #12]

  obj->trajPeriod_sec = trajPeriod_sec;
 8004190:	68fb      	ldr	r3, [r7, #12]
 8004192:	683a      	ldr	r2, [r7, #0]
 8004194:	f8c3 215c 	str.w	r2, [r3, #348]	; 0x15c

  return;
 8004198:	bf00      	nop
} // end of CTRL_setTrajPeriod_sec() function
 800419a:	3714      	adds	r7, #20
 800419c:	46bd      	mov	sp, r7
 800419e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80041a2:	4770      	bx	lr

080041a4 <CTRL_setVab_in_pu>:

//! \brief     Sets the alpha/beta voltage input vector values in the controller
//! \param[in] handle      The controller (CTRL) handle
//! \param[in] pVab_in_pu  The vector of alpha/beta voltage input vector values, pu
static inline void CTRL_setVab_in_pu(CTRL_Handle handle,const MATH_vec2 *pVab_in_pu)//! \Mod By Dl.K
{
 80041a4:	b480      	push	{r7}
 80041a6:	b085      	sub	sp, #20
 80041a8:	af00      	add	r7, sp, #0
 80041aa:	6078      	str	r0, [r7, #4]
 80041ac:	6039      	str	r1, [r7, #0]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80041ae:	687b      	ldr	r3, [r7, #4]
 80041b0:	60fb      	str	r3, [r7, #12]

  obj->Vab_in.value[0] = pVab_in_pu->value[0];
 80041b2:	683b      	ldr	r3, [r7, #0]
 80041b4:	681a      	ldr	r2, [r3, #0]
 80041b6:	68fb      	ldr	r3, [r7, #12]
 80041b8:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  obj->Vab_in.value[1] = pVab_in_pu->value[1];
 80041bc:	683b      	ldr	r3, [r7, #0]
 80041be:	685a      	ldr	r2, [r3, #4]
 80041c0:	68fb      	ldr	r3, [r7, #12]
 80041c2:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184

  return;
 80041c6:	bf00      	nop
} // end of CTRL_setVab_in_pu() function
 80041c8:	3714      	adds	r7, #20
 80041ca:	46bd      	mov	sp, r7
 80041cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80041d0:	4770      	bx	lr
 80041d2:	bf00      	nop

080041d4 <CTRL_setVab_out_pu>:

//! \brief     Sets the alpha/beta current output vector values in the controller
//! \param[in] handle       The controller (CTRL) handle
//! \param[in] pVab_out_pu  The vector of alpha/beta current output vector values, pu
static inline void CTRL_setVab_out_pu(CTRL_Handle handle,const MATH_vec2 *pVab_out_pu)//! \Mod By Dl.K
{
 80041d4:	b480      	push	{r7}
 80041d6:	b085      	sub	sp, #20
 80041d8:	af00      	add	r7, sp, #0
 80041da:	6078      	str	r0, [r7, #4]
 80041dc:	6039      	str	r1, [r7, #0]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80041de:	687b      	ldr	r3, [r7, #4]
 80041e0:	60fb      	str	r3, [r7, #12]

  obj->Vab_out.value[0] = pVab_out_pu->value[0];
 80041e2:	683b      	ldr	r3, [r7, #0]
 80041e4:	681a      	ldr	r2, [r3, #0]
 80041e6:	68fb      	ldr	r3, [r7, #12]
 80041e8:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
  obj->Vab_out.value[1] = pVab_out_pu->value[1];
 80041ec:	683b      	ldr	r3, [r7, #0]
 80041ee:	685a      	ldr	r2, [r3, #4]
 80041f0:	68fb      	ldr	r3, [r7, #12]
 80041f2:	f8c3 2190 	str.w	r2, [r3, #400]	; 0x190

  return;
 80041f6:	bf00      	nop
} // end of CTRL_setVab_out_pu() function
 80041f8:	3714      	adds	r7, #20
 80041fa:	46bd      	mov	sp, r7
 80041fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004200:	4770      	bx	lr
 8004202:	bf00      	nop

08004204 <CTRL_setVdq_out_pu>:

//! \brief     Sets the direct/quadrature voltage output vector values in the controller
//! \param[in] handle       The controller (CTRL) handle
//! \param[in] pVdq_out_pu  The vector of direct/quadrature voltage output vector values, pu
static inline void CTRL_setVdq_out_pu(CTRL_Handle handle,const MATH_vec2 *pVdq_out_pu)//! \Mod By Dl.K
{
 8004204:	b480      	push	{r7}
 8004206:	b085      	sub	sp, #20
 8004208:	af00      	add	r7, sp, #0
 800420a:	6078      	str	r0, [r7, #4]
 800420c:	6039      	str	r1, [r7, #0]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 800420e:	687b      	ldr	r3, [r7, #4]
 8004210:	60fb      	str	r3, [r7, #12]

  obj->Vdq_out.value[0] = pVdq_out_pu->value[0];
 8004212:	683b      	ldr	r3, [r7, #0]
 8004214:	681a      	ldr	r2, [r3, #0]
 8004216:	68fb      	ldr	r3, [r7, #12]
 8004218:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194
  obj->Vdq_out.value[1] = pVdq_out_pu->value[1];
 800421c:	683b      	ldr	r3, [r7, #0]
 800421e:	685a      	ldr	r2, [r3, #4]
 8004220:	68fb      	ldr	r3, [r7, #12]
 8004222:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198

  return;
 8004226:	bf00      	nop
} // end of CTRL_setVdq_out_pu() function
 8004228:	3714      	adds	r7, #20
 800422a:	46bd      	mov	sp, r7
 800422c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004230:	4770      	bx	lr
 8004232:	bf00      	nop

08004234 <CTRL_computePhasor>:

//! \brief      Computes a phasor for a given angle
//! \param[in]  angle_pu  The angle, pu
//! \param[out] pPhasor   The pointer to the phasor vector values
static inline void CTRL_computePhasor(const float_t angle_pu,MATH_vec2 *pPhasor)//! \Mod By Dl.K
{
 8004234:	b580      	push	{r7, lr}
 8004236:	b082      	sub	sp, #8
 8004238:	af00      	add	r7, sp, #0
 800423a:	ed87 0a01 	vstr	s0, [r7, #4]
 800423e:	6038      	str	r0, [r7, #0]

  pPhasor->value[0] = cosf(angle_pu);
 8004240:	ed97 0a01 	vldr	s0, [r7, #4]
 8004244:	f021 ffd8 	bl	80261f8 <cosf>
 8004248:	eef0 7a40 	vmov.f32	s15, s0
 800424c:	683b      	ldr	r3, [r7, #0]
 800424e:	edc3 7a00 	vstr	s15, [r3]
  pPhasor->value[1] = sinf(angle_pu);
 8004252:	ed97 0a01 	vldr	s0, [r7, #4]
 8004256:	f022 f80b 	bl	8026270 <sinf>
 800425a:	eef0 7a40 	vmov.f32	s15, s0
 800425e:	683b      	ldr	r3, [r7, #0]
 8004260:	edc3 7a01 	vstr	s15, [r3, #4]

  return;
 8004264:	bf00      	nop
} // end of CTRL_computePhasor() function
 8004266:	3708      	adds	r7, #8
 8004268:	46bd      	mov	sp, r7
 800426a:	bd80      	pop	{r7, pc}

0800426c <CTRL_doCurrentCtrl>:

//! \brief      Determines if the current controllers should be run
//! \param[in]  handle  The controller (CTRL) handle
//! \return     The value denoting that the current controllers should be run (true) or not (false)
static inline bool CTRL_doCurrentCtrl(CTRL_Handle handle)//! \Mod By Dl.K
{
 800426c:	b580      	push	{r7, lr}
 800426e:	b084      	sub	sp, #16
 8004270:	af00      	add	r7, sp, #0
 8004272:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8004274:	687b      	ldr	r3, [r7, #4]
 8004276:	60bb      	str	r3, [r7, #8]
  bool result = false;
 8004278:	2300      	movs	r3, #0
 800427a:	73fb      	strb	r3, [r7, #15]

  if(CTRL_getFlag_enableCurrentCtrl(handle) && (obj->counter_current >= obj->numCtrlTicksPerCurrentTick))
 800427c:	6878      	ldr	r0, [r7, #4]
 800427e:	f7ff fabb 	bl	80037f8 <CTRL_getFlag_enableCurrentCtrl>
 8004282:	4603      	mov	r3, r0
 8004284:	2b00      	cmp	r3, #0
 8004286:	d009      	beq.n	800429c <CTRL_doCurrentCtrl+0x30>
 8004288:	68bb      	ldr	r3, [r7, #8]
 800428a:	f8b3 21ec 	ldrh.w	r2, [r3, #492]	; 0x1ec
 800428e:	68bb      	ldr	r3, [r7, #8]
 8004290:	f8b3 314e 	ldrh.w	r3, [r3, #334]	; 0x14e
 8004294:	429a      	cmp	r2, r3
 8004296:	d301      	bcc.n	800429c <CTRL_doCurrentCtrl+0x30>
  {
    result = true;
 8004298:	2301      	movs	r3, #1
 800429a:	73fb      	strb	r3, [r7, #15]
  }

  return(result);
 800429c:	7bfb      	ldrb	r3, [r7, #15]
} // end of CTRL_doCurrentCtrl() function
 800429e:	4618      	mov	r0, r3
 80042a0:	3710      	adds	r7, #16
 80042a2:	46bd      	mov	sp, r7
 80042a4:	bd80      	pop	{r7, pc}
 80042a6:	bf00      	nop

080042a8 <CTRL_doSpeedCtrl>:

//! \brief     Determines if the speed controller should be executed
//! \param[in] handle  The controller (CTRL) handle
//! \return    A boolean value denoting if the speed controller should be executed (true) or not (false)
static inline bool CTRL_doSpeedCtrl(CTRL_Handle handle)//! \Mod By Dl.K
{
 80042a8:	b480      	push	{r7}
 80042aa:	b085      	sub	sp, #20
 80042ac:	af00      	add	r7, sp, #0
 80042ae:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80042b0:	687b      	ldr	r3, [r7, #4]
 80042b2:	60bb      	str	r3, [r7, #8]
  bool result = false;
 80042b4:	2300      	movs	r3, #0
 80042b6:	73fb      	strb	r3, [r7, #15]

  if((obj->counter_speed >= obj->numCtrlTicksPerSpeedTick))
 80042b8:	68bb      	ldr	r3, [r7, #8]
 80042ba:	f8b3 21f0 	ldrh.w	r2, [r3, #496]	; 0x1f0
 80042be:	68bb      	ldr	r3, [r7, #8]
 80042c0:	f8b3 3150 	ldrh.w	r3, [r3, #336]	; 0x150
 80042c4:	429a      	cmp	r2, r3
 80042c6:	d301      	bcc.n	80042cc <CTRL_doSpeedCtrl+0x24>
  {
    result = true;
 80042c8:	2301      	movs	r3, #1
 80042ca:	73fb      	strb	r3, [r7, #15]
  }

  return(result);
 80042cc:	7bfb      	ldrb	r3, [r7, #15]
} // end of CTRL_doSpeedCtrl() function
 80042ce:	4618      	mov	r0, r3
 80042d0:	3714      	adds	r7, #20
 80042d2:	46bd      	mov	sp, r7
 80042d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80042d8:	4770      	bx	lr
 80042da:	bf00      	nop

080042dc <CTRL_runOffLine>:
//! \param[in]  pAdcData   The pointer to the ADC data
//! \param[out] pPwmData   The pointer to the PWM data

static inline void CTRL_runOffLine(CTRL_Handle handle,HAL_Handle halHandle,
                            const HAL_AdcData_t *pAdcData,HAL_PwmData_t *pPwmData, HAL_QepData_t *pQepData)//! \Mod By Dl.K
{
 80042dc:	b580      	push	{r7, lr}
 80042de:	b084      	sub	sp, #16
 80042e0:	af00      	add	r7, sp, #0
 80042e2:	60f8      	str	r0, [r7, #12]
 80042e4:	60b9      	str	r1, [r7, #8]
 80042e6:	607a      	str	r2, [r7, #4]
 80042e8:	603b      	str	r3, [r7, #0]

  // run offset estimation
  //settestpin();
  HAL_runOffsetEst(halHandle,pAdcData);
 80042ea:	68b8      	ldr	r0, [r7, #8]
 80042ec:	6879      	ldr	r1, [r7, #4]
 80042ee:	f7ff fa2f 	bl	8003750 <HAL_runOffsetEst>
  //cleartestpin();
  
	Speed_SetElecTheta(handle->Speed_handle,0.0f);
 80042f2:	68fb      	ldr	r3, [r7, #12]
 80042f4:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 80042f8:	4618      	mov	r0, r3
 80042fa:	ed9f 0a14 	vldr	s0, [pc, #80]	; 800434c <CTRL_runOffLine+0x70>
 80042fe:	f7ff f9cf 	bl	80036a0 <Speed_SetElecTheta>
	Speed_UpdateElecTheta(handle->Speed_handle);
 8004302:	68fb      	ldr	r3, [r7, #12]
 8004304:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 8004308:	4618      	mov	r0, r3
 800430a:	f7ff f9ff 	bl	800370c <Speed_UpdateElecTheta>
	
	// create PWM data
	pPwmData->Tabc.value[0] = (0.0f);
 800430e:	683b      	ldr	r3, [r7, #0]
 8004310:	f04f 0200 	mov.w	r2, #0
 8004314:	601a      	str	r2, [r3, #0]
	pPwmData->Tabc.value[1] = (0.0f);
 8004316:	683b      	ldr	r3, [r7, #0]
 8004318:	f04f 0200 	mov.w	r2, #0
 800431c:	605a      	str	r2, [r3, #4]
	pPwmData->Tabc.value[2] = (0.0f);
 800431e:	683b      	ldr	r3, [r7, #0]
 8004320:	f04f 0200 	mov.w	r2, #0
 8004324:	609a      	str	r2, [r3, #8]

	handle->MntValue.value[0] = halHandle->offset_I[0].value;
 8004326:	68bb      	ldr	r3, [r7, #8]
 8004328:	68da      	ldr	r2, [r3, #12]
 800432a:	68fb      	ldr	r3, [r7, #12]
 800432c:	f8c3 2320 	str.w	r2, [r3, #800]	; 0x320
	handle->MntValue.value[1] = halHandle->offset_I[1].value;
 8004330:	68bb      	ldr	r3, [r7, #8]
 8004332:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8004334:	68fb      	ldr	r3, [r7, #12]
 8004336:	f8c3 2324 	str.w	r2, [r3, #804]	; 0x324
	handle->MntValue.value[2] = halHandle->offset_I[2].value;
 800433a:	68bb      	ldr	r3, [r7, #8]
 800433c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800433e:	68fb      	ldr	r3, [r7, #12]
 8004340:	f8c3 2328 	str.w	r2, [r3, #808]	; 0x328
  return;
 8004344:	bf00      	nop
} // end of CTRL_runOffLine() function
 8004346:	3710      	adds	r7, #16
 8004348:	46bd      	mov	sp, r7
 800434a:	bd80      	pop	{r7, pc}
 800434c:	00000000 	.word	0x00000000

08004350 <CTRL_runInitDete_User>:
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  pAdcData  The pointer to the ADC data
//! \param[out] pPwmData  The pointer to the PWM data
static inline void CTRL_runInitDete_User(CTRL_Handle handle,HAL_Handle halHandle,
                           const HAL_AdcData_t *pAdcData,HAL_PwmData_t *pPwmData, HAL_QepData_t *pQepData)//! \Mod By Dl.K
{
 8004350:	b5b0      	push	{r4, r5, r7, lr}
 8004352:	b08c      	sub	sp, #48	; 0x30
 8004354:	af00      	add	r7, sp, #0
 8004356:	6178      	str	r0, [r7, #20]
 8004358:	6139      	str	r1, [r7, #16]
 800435a:	60fa      	str	r2, [r7, #12]
 800435c:	60bb      	str	r3, [r7, #8]
	//! \Mod By Dl.K Dynamic Stator Initial Position Detection
	CTRL_Obj *obj = (CTRL_Obj *)handle;
 800435e:	697b      	ldr	r3, [r7, #20]
 8004360:	62fb      	str	r3, [r7, #44]	; 0x2c
	static uint16_t flag=true;
	MATH_vec2 phasor;
	MATH_vec2 vdq = {0.0f,0.0f};
 8004362:	f04f 0300 	mov.w	r3, #0
 8004366:	61bb      	str	r3, [r7, #24]
 8004368:	f04f 0300 	mov.w	r3, #0
 800436c:	61fb      	str	r3, [r7, #28]
	int16_t angle_temp_pu;

	// run Clarke transform on current
	CLARKE_run(obj->clarkeHandle_I,&pAdcData->I,CTRL_getIab_in_addr(handle));
 800436e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004370:	68dd      	ldr	r5, [r3, #12]
 8004372:	68fc      	ldr	r4, [r7, #12]
 8004374:	6978      	ldr	r0, [r7, #20]
 8004376:	f7ff fa5f 	bl	8003838 <CTRL_getIab_in_addr>
 800437a:	4603      	mov	r3, r0
 800437c:	4628      	mov	r0, r5
 800437e:	4621      	mov	r1, r4
 8004380:	461a      	mov	r2, r3
 8004382:	f7fe fbcb 	bl	8002b1c <CLARKE_run>

	// clear the position counter
//	QEP_clear_posn_counter(halHandle->qepHandle[0]);
	
	angle_temp_pu = 32768.0f*pQepData->qep_cnt*USER_MOTOR_NUM_POLE_PAIRS;
 8004386:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8004388:	edd3 7a00 	vldr	s15, [r3]
 800438c:	ed9f 7a44 	vldr	s14, [pc, #272]	; 80044a0 <CTRL_runInitDete_User+0x150>
 8004390:	ee67 7a87 	vmul.f32	s15, s15, s14
 8004394:	eeb1 7a00 	vmov.f32	s14, #16
 8004398:	ee67 7a87 	vmul.f32	s15, s15, s14
 800439c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80043a0:	edc7 7a01 	vstr	s15, [r7, #4]
 80043a4:	88bb      	ldrh	r3, [r7, #4]
 80043a6:	857b      	strh	r3, [r7, #42]	; 0x2a
	angle_temp_pu &= 0x7FFF;
 80043a8:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 80043aa:	f3c3 030e 	ubfx	r3, r3, #0, #15
 80043ae:	857b      	strh	r3, [r7, #42]	; 0x2a
	obj->angle_offset_pu = angle_temp_pu *0.0000305f;
 80043b0:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 80043b4:	ee07 3a90 	vmov	s15, r3
 80043b8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80043bc:	ed9f 7a39 	vldr	s14, [pc, #228]	; 80044a4 <CTRL_runInitDete_User+0x154>
 80043c0:	ee67 7a87 	vmul.f32	s15, s15, s14
 80043c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80043c6:	edc3 7a83 	vstr	s15, [r3, #524]	; 0x20c

	Speed_SetElecTheta(obj->Speed_handle,0.0f);
 80043ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80043cc:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 80043d0:	4618      	mov	r0, r3
 80043d2:	ed9f 0a35 	vldr	s0, [pc, #212]	; 80044a8 <CTRL_runInitDete_User+0x158>
 80043d6:	f7ff f963 	bl	80036a0 <Speed_SetElecTheta>
	Speed_UpdateElecTheta(obj->Speed_handle);
 80043da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80043dc:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 80043e0:	4618      	mov	r0, r3
 80043e2:	f7ff f993 	bl	800370c <Speed_UpdateElecTheta>
	
	// compute the sin/cos phasor
	CTRL_computePhasor(obj->AngleRef * MATH_TWO_PI,&phasor);//-0.25
 80043e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80043e8:	edd3 7ac7 	vldr	s15, [r3, #796]	; 0x31c
 80043ec:	ed9f 7a2f 	vldr	s14, [pc, #188]	; 80044ac <CTRL_runInitDete_User+0x15c>
 80043f0:	ee67 7a87 	vmul.f32	s15, s15, s14
 80043f4:	f107 0320 	add.w	r3, r7, #32
 80043f8:	eeb0 0a67 	vmov.f32	s0, s15
 80043fc:	4618      	mov	r0, r3
 80043fe:	f7ff ff19 	bl	8004234 <CTRL_computePhasor>

	// set
	if( flag==true )
 8004402:	4b2b      	ldr	r3, [pc, #172]	; (80044b0 <CTRL_runInitDete_User+0x160>)
 8004404:	881b      	ldrh	r3, [r3, #0]
 8004406:	2b01      	cmp	r3, #1
 8004408:	d105      	bne.n	8004416 <CTRL_runInitDete_User+0xc6>
	{
		vdq.value[0] = (0.0f);
 800440a:	f04f 0300 	mov.w	r3, #0
 800440e:	61bb      	str	r3, [r7, #24]
		vdq.value[1] = (0.1f);
 8004410:	4b28      	ldr	r3, [pc, #160]	; (80044b4 <CTRL_runInitDete_User+0x164>)
 8004412:	61fb      	str	r3, [r7, #28]
 8004414:	e005      	b.n	8004422 <CTRL_runInitDete_User+0xd2>
	}
	else
	{
		vdq.value[0] = (0.0f);
 8004416:	f04f 0300 	mov.w	r3, #0
 800441a:	61bb      	str	r3, [r7, #24]
		vdq.value[1] = (0.0f);
 800441c:	f04f 0300 	mov.w	r3, #0
 8004420:	61fb      	str	r3, [r7, #28]
	}
	CTRL_setVdq_out_pu(obj,&vdq);
 8004422:	f107 0318 	add.w	r3, r7, #24
 8004426:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8004428:	4619      	mov	r1, r3
 800442a:	f7ff feeb 	bl	8004204 <CTRL_setVdq_out_pu>

	// set the phasor in the inverse Park transform
	IPARK_setPhasor(obj->iparkHandle,&phasor);
 800442e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004430:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
 8004434:	f107 0320 	add.w	r3, r7, #32
 8004438:	4610      	mov	r0, r2
 800443a:	4619      	mov	r1, r3
 800443c:	f7fe fc82 	bl	8002d44 <IPARK_setPhasor>

	// run the inverse Park module
	IPARK_run(obj->iparkHandle,CTRL_getVdq_out_addr(obj),CTRL_getVab_out_addr(obj));
 8004440:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004442:	f8d3 40a8 	ldr.w	r4, [r3, #168]	; 0xa8
 8004446:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8004448:	f7ff fb28 	bl	8003a9c <CTRL_getVdq_out_addr>
 800444c:	4605      	mov	r5, r0
 800444e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8004450:	f7ff fb04 	bl	8003a5c <CTRL_getVab_out_addr>
 8004454:	4603      	mov	r3, r0
 8004456:	4620      	mov	r0, r4
 8004458:	4629      	mov	r1, r5
 800445a:	461a      	mov	r2, r3
 800445c:	f7fe fc36 	bl	8002ccc <IPARK_run>

	// run the space Vector Generator (SVGEN) module
	SVGEN_run(obj->svgenHandle,CTRL_getVab_out_addr(handle),&(pPwmData->Tabc));
 8004460:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004462:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8004466:	6978      	ldr	r0, [r7, #20]
 8004468:	f7ff faf8 	bl	8003a5c <CTRL_getVab_out_addr>
 800446c:	4602      	mov	r2, r0
 800446e:	68bb      	ldr	r3, [r7, #8]
 8004470:	4620      	mov	r0, r4
 8004472:	4611      	mov	r1, r2
 8004474:	461a      	mov	r2, r3
 8004476:	f7fe fe39 	bl	80030ec <SVGEN_run>

	obj->Tabc.value[0]=pPwmData->Tabc.value[0];
 800447a:	68bb      	ldr	r3, [r7, #8]
 800447c:	681a      	ldr	r2, [r3, #0]
 800447e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004480:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
	obj->Tabc.value[1]=pPwmData->Tabc.value[1];
 8004484:	68bb      	ldr	r3, [r7, #8]
 8004486:	685a      	ldr	r2, [r3, #4]
 8004488:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800448a:	f8c3 230c 	str.w	r2, [r3, #780]	; 0x30c
	obj->Tabc.value[2]=pPwmData->Tabc.value[2];
 800448e:	68bb      	ldr	r3, [r7, #8]
 8004490:	689a      	ldr	r2, [r3, #8]
 8004492:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004494:	f8c3 2310 	str.w	r2, [r3, #784]	; 0x310
}
 8004498:	3730      	adds	r7, #48	; 0x30
 800449a:	46bd      	mov	sp, r7
 800449c:	bdb0      	pop	{r4, r5, r7, pc}
 800449e:	bf00      	nop
 80044a0:	47000000 	.word	0x47000000
 80044a4:	37ffda40 	.word	0x37ffda40
 80044a8:	00000000 	.word	0x00000000
 80044ac:	40c90fdb 	.word	0x40c90fdb
 80044b0:	20010004 	.word	0x20010004
 80044b4:	3dcccccd 	.word	0x3dcccccd

080044b8 <CTRL_runStaticStatorInitDete_User>:
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  pAdcData  The pointer to the ADC data
//! \param[out] pPwmData  The pointer to the PWM data
static inline void CTRL_runStaticStatorInitDete_User(CTRL_Handle handle,HAL_Handle halHandle,
                           const HAL_AdcData_t *pAdcData,HAL_PwmData_t *pPwmData, HAL_QepData_t *pQepData)//! \Mod By Dl.K
{
 80044b8:	b5b0      	push	{r4, r5, r7, lr}
 80044ba:	b08a      	sub	sp, #40	; 0x28
 80044bc:	af00      	add	r7, sp, #0
 80044be:	60f8      	str	r0, [r7, #12]
 80044c0:	60b9      	str	r1, [r7, #8]
 80044c2:	607a      	str	r2, [r7, #4]
 80044c4:	603b      	str	r3, [r7, #0]
	//! \Mod By Dl.K Static Stator Initial Position Detection
	CTRL_Obj *obj = (CTRL_Obj *)handle;
 80044c6:	68fb      	ldr	r3, [r7, #12]
 80044c8:	627b      	str	r3, [r7, #36]	; 0x24
	float_t angle_pu;
	MATH_vec2 phasor;
	MATH_vec2 vdq = {0.0f,0.0f};
 80044ca:	f04f 0300 	mov.w	r3, #0
 80044ce:	613b      	str	r3, [r7, #16]
 80044d0:	f04f 0300 	mov.w	r3, #0
 80044d4:	617b      	str	r3, [r7, #20]
	static uint16_t sInitPosDetTick = 5,sInitPosDetSclar = 5;

	//GPIO_setHigh(halHandle->gpioHandle,GPIO_Number_32);

	if( INITPOSDET_GetIdSampAngleFlag(obj->InitPosDet_handle) &&
 80044d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80044d8:	f8d3 3284 	ldr.w	r3, [r3, #644]	; 0x284
 80044dc:	4618      	mov	r0, r3
 80044de:	f7ff f8d1 	bl	8003684 <INITPOSDET_GetIdSampAngleFlag>
 80044e2:	4603      	mov	r3, r0
 80044e4:	2b00      	cmp	r3, #0
 80044e6:	d077      	beq.n	80045d8 <CTRL_runStaticStatorInitDete_User+0x120>
			sInitPosDetTick==4 )
 80044e8:	4b83      	ldr	r3, [pc, #524]	; (80046f8 <CTRL_runStaticStatorInitDete_User+0x240>)
 80044ea:	881b      	ldrh	r3, [r3, #0]
	MATH_vec2 vdq = {0.0f,0.0f};
	static uint16_t sInitPosDetTick = 5,sInitPosDetSclar = 5;

	//GPIO_setHigh(halHandle->gpioHandle,GPIO_Number_32);

	if( INITPOSDET_GetIdSampAngleFlag(obj->InitPosDet_handle) &&
 80044ec:	2b04      	cmp	r3, #4
 80044ee:	d173      	bne.n	80045d8 <CTRL_runStaticStatorInitDete_User+0x120>
			sInitPosDetTick==4 )
	{
//		GPIO_setHigh(halHandle->gpioHandle,GPIO_Number_43);

		obj->MntValue.value[0] = pAdcData->I.value[0];
 80044f0:	687b      	ldr	r3, [r7, #4]
 80044f2:	681a      	ldr	r2, [r3, #0]
 80044f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80044f6:	f8c3 2320 	str.w	r2, [r3, #800]	; 0x320
		obj->MntValue.value[1] = pAdcData->I.value[1];
 80044fa:	687b      	ldr	r3, [r7, #4]
 80044fc:	685a      	ldr	r2, [r3, #4]
 80044fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004500:	f8c3 2324 	str.w	r2, [r3, #804]	; 0x324
		obj->MntValue.value[2] = pAdcData->I.value[2];
 8004504:	687b      	ldr	r3, [r7, #4]
 8004506:	689a      	ldr	r2, [r3, #8]
 8004508:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800450a:	f8c3 2328 	str.w	r2, [r3, #808]	; 0x328

		// run Clarke transform on current
		CLARKE_run(obj->clarkeHandle_I,&pAdcData->I,CTRL_getIab_in_addr(obj));
 800450e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004510:	68dd      	ldr	r5, [r3, #12]
 8004512:	687c      	ldr	r4, [r7, #4]
 8004514:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8004516:	f7ff f98f 	bl	8003838 <CTRL_getIab_in_addr>
 800451a:	4603      	mov	r3, r0
 800451c:	4628      	mov	r0, r5
 800451e:	4621      	mov	r1, r4
 8004520:	461a      	mov	r2, r3
 8004522:	f7fe fafb 	bl	8002b1c <CLARKE_run>

		// generate the motor electrical angle
		angle_pu = INITPOSDET_GetIdSampAngle(obj->InitPosDet_handle);
 8004526:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004528:	f8d3 3284 	ldr.w	r3, [r3, #644]	; 0x284
 800452c:	4618      	mov	r0, r3
 800452e:	f7ff f897 	bl	8003660 <INITPOSDET_GetIdSampAngle>
 8004532:	ed87 0a08 	vstr	s0, [r7, #32]

		// compute the sin/cos phasor
		CTRL_computePhasor(angle_pu * MATH_TWO_PI,&phasor);
 8004536:	edd7 7a08 	vldr	s15, [r7, #32]
 800453a:	ed9f 7a70 	vldr	s14, [pc, #448]	; 80046fc <CTRL_runStaticStatorInitDete_User+0x244>
 800453e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8004542:	f107 0318 	add.w	r3, r7, #24
 8004546:	eeb0 0a67 	vmov.f32	s0, s15
 800454a:	4618      	mov	r0, r3
 800454c:	f7ff fe72 	bl	8004234 <CTRL_computePhasor>

		// set the phasor in the Park transform
		PARK_setPhasor(obj->parkHandle,&phasor);
 8004550:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004552:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004554:	f107 0318 	add.w	r3, r7, #24
 8004558:	4610      	mov	r0, r2
 800455a:	4619      	mov	r1, r3
 800455c:	f7fe fba0 	bl	8002ca0 <PARK_setPhasor>

		// run the Park transform
		PARK_run(obj->parkHandle,CTRL_getIab_in_addr(obj),CTRL_getIdq_in_addr(obj));
 8004560:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004562:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 8004564:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8004566:	f7ff f967 	bl	8003838 <CTRL_getIab_in_addr>
 800456a:	4605      	mov	r5, r0
 800456c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800456e:	f7ff f997 	bl	80038a0 <CTRL_getIdq_in_addr>
 8004572:	4603      	mov	r3, r0
 8004574:	4620      	mov	r0, r4
 8004576:	4629      	mov	r1, r5
 8004578:	461a      	mov	r2, r3
 800457a:	f7fe fb55 	bl	8002c28 <PARK_run>

		INITPOSDET_Run(obj->InitPosDet_handle,CTRL_getId_in_pu(obj));
 800457e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004580:	f8d3 4284 	ldr.w	r4, [r3, #644]	; 0x284
 8004584:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8004586:	f7ff f967 	bl	8003858 <CTRL_getId_in_pu>
 800458a:	eef0 7a40 	vmov.f32	s15, s0
 800458e:	4620      	mov	r0, r4
 8004590:	eeb0 0a67 	vmov.f32	s0, s15
 8004594:	f7fd f954 	bl	8001840 <INITPOSDET_Run>

		obj->angle_offset_pu = - INITPOSDET_GetInitPosAngle(obj->InitPosDet_handle);
 8004598:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800459a:	f8d3 3284 	ldr.w	r3, [r3, #644]	; 0x284
 800459e:	4618      	mov	r0, r3
 80045a0:	f7ff f82c 	bl	80035fc <INITPOSDET_GetInitPosAngle>
 80045a4:	eef0 7a40 	vmov.f32	s15, s0
 80045a8:	eef1 7a67 	vneg.f32	s15, s15
 80045ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80045ae:	edc3 7a83 	vstr	s15, [r3, #524]	; 0x20c
		
		Speed_SetElecTheta(obj->Speed_handle,-obj->angle_offset_pu);
 80045b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80045b4:	f8d3 22e8 	ldr.w	r2, [r3, #744]	; 0x2e8
 80045b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80045ba:	edd3 7a83 	vldr	s15, [r3, #524]	; 0x20c
 80045be:	eef1 7a67 	vneg.f32	s15, s15
 80045c2:	4610      	mov	r0, r2
 80045c4:	eeb0 0a67 	vmov.f32	s0, s15
 80045c8:	f7ff f86a 	bl	80036a0 <Speed_SetElecTheta>
		Speed_UpdateElecTheta(obj->Speed_handle);
 80045cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80045ce:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 80045d2:	4618      	mov	r0, r3
 80045d4:	f7ff f89a 	bl	800370c <Speed_UpdateElecTheta>
//		GPIO_setLow(halHandle->gpioHandle,GPIO_Number_43);
	}

	if(sInitPosDetTick>=sInitPosDetSclar)
 80045d8:	4b47      	ldr	r3, [pc, #284]	; (80046f8 <CTRL_runStaticStatorInitDete_User+0x240>)
 80045da:	881a      	ldrh	r2, [r3, #0]
 80045dc:	4b48      	ldr	r3, [pc, #288]	; (8004700 <CTRL_runStaticStatorInitDete_User+0x248>)
 80045de:	881b      	ldrh	r3, [r3, #0]
 80045e0:	429a      	cmp	r2, r3
 80045e2:	d309      	bcc.n	80045f8 <CTRL_runStaticStatorInitDete_User+0x140>
	{
		sInitPosDetTick=1;
 80045e4:	4b44      	ldr	r3, [pc, #272]	; (80046f8 <CTRL_runStaticStatorInitDete_User+0x240>)
 80045e6:	2201      	movs	r2, #1
 80045e8:	801a      	strh	r2, [r3, #0]
		INITPOSDET_VolVecAngleRun(obj->InitPosDet_handle);
 80045ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80045ec:	f8d3 3284 	ldr.w	r3, [r3, #644]	; 0x284
 80045f0:	4618      	mov	r0, r3
 80045f2:	f7fd fb09 	bl	8001c08 <INITPOSDET_VolVecAngleRun>
 80045f6:	e005      	b.n	8004604 <CTRL_runStaticStatorInitDete_User+0x14c>
	}
	else sInitPosDetTick++;
 80045f8:	4b3f      	ldr	r3, [pc, #252]	; (80046f8 <CTRL_runStaticStatorInitDete_User+0x240>)
 80045fa:	881b      	ldrh	r3, [r3, #0]
 80045fc:	3301      	adds	r3, #1
 80045fe:	b29a      	uxth	r2, r3
 8004600:	4b3d      	ldr	r3, [pc, #244]	; (80046f8 <CTRL_runStaticStatorInitDete_User+0x240>)
 8004602:	801a      	strh	r2, [r3, #0]

	// set
	if( INITPOSDET_GetVolVecAngleFlag(obj->InitPosDet_handle) )
 8004604:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004606:	f8d3 3284 	ldr.w	r3, [r3, #644]	; 0x284
 800460a:	4618      	mov	r0, r3
 800460c:	f7ff f808 	bl	8003620 <INITPOSDET_GetVolVecAngleFlag>
 8004610:	4603      	mov	r3, r0
 8004612:	2b00      	cmp	r3, #0
 8004614:	d01c      	beq.n	8004650 <CTRL_runStaticStatorInitDete_User+0x198>
	{
		vdq.value[0] = obj->VdqRef.value[0];
 8004616:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004618:	f8d3 3314 	ldr.w	r3, [r3, #788]	; 0x314
 800461c:	613b      	str	r3, [r7, #16]
		vdq.value[1] = (0.0f);
 800461e:	f04f 0300 	mov.w	r3, #0
 8004622:	617b      	str	r3, [r7, #20]

		// generate the motor electrical angle
		angle_pu = INITPOSDET_GetVolVecAngle(obj->InitPosDet_handle);
 8004624:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004626:	f8d3 3284 	ldr.w	r3, [r3, #644]	; 0x284
 800462a:	4618      	mov	r0, r3
 800462c:	f7ff f806 	bl	800363c <INITPOSDET_GetVolVecAngle>
 8004630:	ed87 0a08 	vstr	s0, [r7, #32]

		// compute the sin/cos phasor
		CTRL_computePhasor(angle_pu * MATH_TWO_PI,&phasor);
 8004634:	edd7 7a08 	vldr	s15, [r7, #32]
 8004638:	ed9f 7a30 	vldr	s14, [pc, #192]	; 80046fc <CTRL_runStaticStatorInitDete_User+0x244>
 800463c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8004640:	f107 0318 	add.w	r3, r7, #24
 8004644:	eeb0 0a67 	vmov.f32	s0, s15
 8004648:	4618      	mov	r0, r3
 800464a:	f7ff fdf3 	bl	8004234 <CTRL_computePhasor>
 800464e:	e015      	b.n	800467c <CTRL_runStaticStatorInitDete_User+0x1c4>
	}
	else
	{
		vdq.value[0] = (0.0f);
 8004650:	f04f 0300 	mov.w	r3, #0
 8004654:	613b      	str	r3, [r7, #16]
		vdq.value[1] = (0.0f);
 8004656:	f04f 0300 	mov.w	r3, #0
 800465a:	617b      	str	r3, [r7, #20]

		// generate the motor electrical angle
		angle_pu = (0.0f);
 800465c:	f04f 0300 	mov.w	r3, #0
 8004660:	623b      	str	r3, [r7, #32]

		// compute the sin/cos phasor
		CTRL_computePhasor(angle_pu * MATH_TWO_PI,&phasor);
 8004662:	edd7 7a08 	vldr	s15, [r7, #32]
 8004666:	ed9f 7a25 	vldr	s14, [pc, #148]	; 80046fc <CTRL_runStaticStatorInitDete_User+0x244>
 800466a:	ee67 7a87 	vmul.f32	s15, s15, s14
 800466e:	f107 0318 	add.w	r3, r7, #24
 8004672:	eeb0 0a67 	vmov.f32	s0, s15
 8004676:	4618      	mov	r0, r3
 8004678:	f7ff fddc 	bl	8004234 <CTRL_computePhasor>
	}
	CTRL_setVdq_out_pu(obj,&vdq);
 800467c:	f107 0310 	add.w	r3, r7, #16
 8004680:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8004682:	4619      	mov	r1, r3
 8004684:	f7ff fdbe 	bl	8004204 <CTRL_setVdq_out_pu>

	// set the phasor in the inverse Park transform
	IPARK_setPhasor(obj->iparkHandle,&phasor);
 8004688:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800468a:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
 800468e:	f107 0318 	add.w	r3, r7, #24
 8004692:	4610      	mov	r0, r2
 8004694:	4619      	mov	r1, r3
 8004696:	f7fe fb55 	bl	8002d44 <IPARK_setPhasor>

	// run the inverse Park module
	IPARK_run(obj->iparkHandle,CTRL_getVdq_out_addr(obj),CTRL_getVab_out_addr(obj));
 800469a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800469c:	f8d3 40a8 	ldr.w	r4, [r3, #168]	; 0xa8
 80046a0:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80046a2:	f7ff f9fb 	bl	8003a9c <CTRL_getVdq_out_addr>
 80046a6:	4605      	mov	r5, r0
 80046a8:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80046aa:	f7ff f9d7 	bl	8003a5c <CTRL_getVab_out_addr>
 80046ae:	4603      	mov	r3, r0
 80046b0:	4620      	mov	r0, r4
 80046b2:	4629      	mov	r1, r5
 80046b4:	461a      	mov	r2, r3
 80046b6:	f7fe fb09 	bl	8002ccc <IPARK_run>

	// run the space Vector Generator (SVGEN) module
	SVGEN_run(obj->svgenHandle,CTRL_getVab_out_addr(obj),&(pPwmData->Tabc));
 80046ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80046bc:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 80046c0:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80046c2:	f7ff f9cb 	bl	8003a5c <CTRL_getVab_out_addr>
 80046c6:	4602      	mov	r2, r0
 80046c8:	683b      	ldr	r3, [r7, #0]
 80046ca:	4620      	mov	r0, r4
 80046cc:	4611      	mov	r1, r2
 80046ce:	461a      	mov	r2, r3
 80046d0:	f7fe fd0c 	bl	80030ec <SVGEN_run>

	obj->Tabc.value[0]=pPwmData->Tabc.value[0];
 80046d4:	683b      	ldr	r3, [r7, #0]
 80046d6:	681a      	ldr	r2, [r3, #0]
 80046d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80046da:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
	obj->Tabc.value[1]=pPwmData->Tabc.value[1];
 80046de:	683b      	ldr	r3, [r7, #0]
 80046e0:	685a      	ldr	r2, [r3, #4]
 80046e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80046e4:	f8c3 230c 	str.w	r2, [r3, #780]	; 0x30c
	obj->Tabc.value[2]=pPwmData->Tabc.value[2];
 80046e8:	683b      	ldr	r3, [r7, #0]
 80046ea:	689a      	ldr	r2, [r3, #8]
 80046ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80046ee:	f8c3 2310 	str.w	r2, [r3, #784]	; 0x310

	//GPIO_setLow(halHandle->gpioHandle,GPIO_Number_32);
}
 80046f2:	3728      	adds	r7, #40	; 0x28
 80046f4:	46bd      	mov	sp, r7
 80046f6:	bdb0      	pop	{r4, r5, r7, pc}
 80046f8:	20010006 	.word	0x20010006
 80046fc:	40c90fdb 	.word	0x40c90fdb
 8004700:	20010008 	.word	0x20010008

08004704 <CTRL_runOpenLoop_User>:
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  pAdcData  The pointer to the ADC data
//! \param[out] pPwmData  The pointer to the PWM data
static inline void CTRL_runOpenLoop_User(CTRL_Handle handle,HAL_Handle halHandle,
                           const HAL_AdcData_t *pAdcData,HAL_PwmData_t *pPwmData, HAL_QepData_t *pQepData)//! \Mod By Dl.K
{
 8004704:	b5b0      	push	{r4, r5, r7, lr}
 8004706:	b08e      	sub	sp, #56	; 0x38
 8004708:	af00      	add	r7, sp, #0
 800470a:	6178      	str	r0, [r7, #20]
 800470c:	6139      	str	r1, [r7, #16]
 800470e:	60fa      	str	r2, [r7, #12]
 8004710:	60bb      	str	r3, [r7, #8]
	//! \Mod By Dl.K OpenLoop Control
	CTRL_Obj *obj = (CTRL_Obj *)handle;
 8004712:	697b      	ldr	r3, [r7, #20]
 8004714:	637b      	str	r3, [r7, #52]	; 0x34
	int16_t angle_temp_pu;
	float_t angle_pu;
	MATH_vec2 phasor;
	MATH_vec2 vdq = {0,0};
 8004716:	f04f 0300 	mov.w	r3, #0
 800471a:	61fb      	str	r3, [r7, #28]
 800471c:	f04f 0300 	mov.w	r3, #0
 8004720:	623b      	str	r3, [r7, #32]

	// run Clarke transform on current
	CLARKE_run(obj->clarkeHandle_I,&pAdcData->I,CTRL_getIab_in_addr(handle));
 8004722:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004724:	68dd      	ldr	r5, [r3, #12]
 8004726:	68fc      	ldr	r4, [r7, #12]
 8004728:	6978      	ldr	r0, [r7, #20]
 800472a:	f7ff f885 	bl	8003838 <CTRL_getIab_in_addr>
 800472e:	4603      	mov	r3, r0
 8004730:	4628      	mov	r0, r5
 8004732:	4621      	mov	r1, r4
 8004734:	461a      	mov	r2, r3
 8004736:	f7fe f9f1 	bl	8002b1c <CLARKE_run>

	RMP_CNTL_SetTargetValue(obj->rmpcntl_handle,CTRL_getSpd_ref_pu(obj));
 800473a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800473c:	f8d3 4224 	ldr.w	r4, [r3, #548]	; 0x224
 8004740:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8004742:	f7ff f96b 	bl	8003a1c <CTRL_getSpd_ref_pu>
 8004746:	eef0 7a40 	vmov.f32	s15, s0
 800474a:	4620      	mov	r0, r4
 800474c:	eeb0 0a67 	vmov.f32	s0, s15
 8004750:	f7fe fdf0 	bl	8003334 <RMP_CNTL_SetTargetValue>
	RMP_CNTL_Run(obj->rmpcntl_handle);
 8004754:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004756:	f8d3 3224 	ldr.w	r3, [r3, #548]	; 0x224
 800475a:	4618      	mov	r0, r3
 800475c:	f7fe fe0e 	bl	800337c <RMP_CNTL_Run>

	RAMPGEN_SetFreq(obj->rampgen_handle,RMP_CNTL_GetFreq(obj->rmpcntl_handle));
 8004760:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004762:	f8d3 4244 	ldr.w	r4, [r3, #580]	; 0x244
 8004766:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004768:	f8d3 3224 	ldr.w	r3, [r3, #548]	; 0x224
 800476c:	4618      	mov	r0, r3
 800476e:	f7fe fdf3 	bl	8003358 <RMP_CNTL_GetFreq>
 8004772:	eef0 7a40 	vmov.f32	s15, s0
 8004776:	4620      	mov	r0, r4
 8004778:	eeb0 0a67 	vmov.f32	s0, s15
 800477c:	f7fe fe88 	bl	8003490 <RAMPGEN_SetFreq>
	RAMPGEN_Run(obj->rampgen_handle);
 8004780:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004782:	f8d3 3244 	ldr.w	r3, [r3, #580]	; 0x244
 8004786:	4618      	mov	r0, r3
 8004788:	f7fe feb8 	bl	80034fc <RAMPGEN_Run>

	// generate the motor electrical angle
	angle_pu = RAMPGEN_GetAngleOut(obj->rampgen_handle);
 800478c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800478e:	f8d3 3244 	ldr.w	r3, [r3, #580]	; 0x244
 8004792:	4618      	mov	r0, r3
 8004794:	f7fe fe6a 	bl	800346c <RAMPGEN_GetAngleOut>
 8004798:	ed87 0a0c 	vstr	s0, [r7, #48]	; 0x30

	// compute the sin/cos phasor
	CTRL_computePhasor(angle_pu * MATH_TWO_PI,&phasor);
 800479c:	edd7 7a0c 	vldr	s15, [r7, #48]	; 0x30
 80047a0:	ed9f 7a50 	vldr	s14, [pc, #320]	; 80048e4 <CTRL_runOpenLoop_User+0x1e0>
 80047a4:	ee67 7a87 	vmul.f32	s15, s15, s14
 80047a8:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80047ac:	eeb0 0a67 	vmov.f32	s0, s15
 80047b0:	4618      	mov	r0, r3
 80047b2:	f7ff fd3f 	bl	8004234 <CTRL_computePhasor>

	if(CTRL_doSpeedCtrl(handle))
 80047b6:	6978      	ldr	r0, [r7, #20]
 80047b8:	f7ff fd76 	bl	80042a8 <CTRL_doSpeedCtrl>
 80047bc:	4603      	mov	r3, r0
 80047be:	2b00      	cmp	r3, #0
 80047c0:	d034      	beq.n	800482c <CTRL_runOpenLoop_User+0x128>
	{
		angle_temp_pu = 32768.0f*pQepData->qep_cnt*USER_MOTOR_NUM_POLE_PAIRS;
 80047c2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80047c4:	edd3 7a00 	vldr	s15, [r3]
 80047c8:	ed9f 7a47 	vldr	s14, [pc, #284]	; 80048e8 <CTRL_runOpenLoop_User+0x1e4>
 80047cc:	ee67 7a87 	vmul.f32	s15, s15, s14
 80047d0:	eeb1 7a00 	vmov.f32	s14, #16
 80047d4:	ee67 7a87 	vmul.f32	s15, s15, s14
 80047d8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80047dc:	edc7 7a01 	vstr	s15, [r7, #4]
 80047e0:	88bb      	ldrh	r3, [r7, #4]
 80047e2:	85fb      	strh	r3, [r7, #46]	; 0x2e
		angle_temp_pu &= 0x7FFF;
 80047e4:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 80047e6:	f3c3 030e 	ubfx	r3, r3, #0, #15
 80047ea:	85fb      	strh	r3, [r7, #46]	; 0x2e
		angle_pu = angle_temp_pu *0.0000305f;
 80047ec:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 80047f0:	ee07 3a90 	vmov	s15, r3
 80047f4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80047f8:	ed9f 7a3c 	vldr	s14, [pc, #240]	; 80048ec <CTRL_runOpenLoop_User+0x1e8>
 80047fc:	ee67 7a87 	vmul.f32	s15, s15, s14
 8004800:	edc7 7a0c 	vstr	s15, [r7, #48]	; 0x30
		Speed_SetElecTheta(obj->Speed_handle, angle_pu * MATH_TWO_PI);
 8004804:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004806:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 800480a:	edd7 7a0c 	vldr	s15, [r7, #48]	; 0x30
 800480e:	ed9f 7a35 	vldr	s14, [pc, #212]	; 80048e4 <CTRL_runOpenLoop_User+0x1e0>
 8004812:	ee67 7a87 	vmul.f32	s15, s15, s14
 8004816:	4618      	mov	r0, r3
 8004818:	eeb0 0a67 	vmov.f32	s0, s15
 800481c:	f7fe ff40 	bl	80036a0 <Speed_SetElecTheta>
		Speed_Run(obj->Speed_handle);
 8004820:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004822:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 8004826:	4618      	mov	r0, r3
 8004828:	f7fe f870 	bl	800290c <Speed_Run>
	}

	// set
	vdq.value[0] = (0.0f);
 800482c:	f04f 0300 	mov.w	r3, #0
 8004830:	61fb      	str	r3, [r7, #28]
	vdq.value[1] = ((15.0f)*RMP_CNTL_GetFreq(obj->rmpcntl_handle));//ESTUN: (10.0), PHASE: (15.0)
 8004832:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004834:	f8d3 3224 	ldr.w	r3, [r3, #548]	; 0x224
 8004838:	4618      	mov	r0, r3
 800483a:	f7fe fd8d 	bl	8003358 <RMP_CNTL_GetFreq>
 800483e:	eeb0 7a40 	vmov.f32	s14, s0
 8004842:	eef2 7a0e 	vmov.f32	s15, #46	; 0x2e
 8004846:	ee67 7a27 	vmul.f32	s15, s14, s15
 800484a:	edc7 7a08 	vstr	s15, [r7, #32]
	if( vdq.value[1] > (0.2f) )
 800484e:	edd7 7a08 	vldr	s15, [r7, #32]
 8004852:	ed9f 7a27 	vldr	s14, [pc, #156]	; 80048f0 <CTRL_runOpenLoop_User+0x1ec>
 8004856:	eef4 7ac7 	vcmpe.f32	s15, s14
 800485a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800485e:	dd01      	ble.n	8004864 <CTRL_runOpenLoop_User+0x160>
	{
		vdq.value[1] = (0.2f);
 8004860:	4b24      	ldr	r3, [pc, #144]	; (80048f4 <CTRL_runOpenLoop_User+0x1f0>)
 8004862:	623b      	str	r3, [r7, #32]
	}
	CTRL_setVdq_out_pu(obj,&vdq);
 8004864:	f107 031c 	add.w	r3, r7, #28
 8004868:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800486a:	4619      	mov	r1, r3
 800486c:	f7ff fcca 	bl	8004204 <CTRL_setVdq_out_pu>

	// set the phasor in the inverse Park transform
	IPARK_setPhasor(obj->iparkHandle,&phasor);
 8004870:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004872:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
 8004876:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800487a:	4610      	mov	r0, r2
 800487c:	4619      	mov	r1, r3
 800487e:	f7fe fa61 	bl	8002d44 <IPARK_setPhasor>

	// run the inverse Park module
	IPARK_run(obj->iparkHandle,CTRL_getVdq_out_addr(obj),CTRL_getVab_out_addr(obj));
 8004882:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004884:	f8d3 40a8 	ldr.w	r4, [r3, #168]	; 0xa8
 8004888:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800488a:	f7ff f907 	bl	8003a9c <CTRL_getVdq_out_addr>
 800488e:	4605      	mov	r5, r0
 8004890:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8004892:	f7ff f8e3 	bl	8003a5c <CTRL_getVab_out_addr>
 8004896:	4603      	mov	r3, r0
 8004898:	4620      	mov	r0, r4
 800489a:	4629      	mov	r1, r5
 800489c:	461a      	mov	r2, r3
 800489e:	f7fe fa15 	bl	8002ccc <IPARK_run>

	// run the space Vector Generator (SVGEN) module
	SVGEN_run(obj->svgenHandle,CTRL_getVab_out_addr(obj),&(pPwmData->Tabc));
 80048a2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80048a4:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 80048a8:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80048aa:	f7ff f8d7 	bl	8003a5c <CTRL_getVab_out_addr>
 80048ae:	4602      	mov	r2, r0
 80048b0:	68bb      	ldr	r3, [r7, #8]
 80048b2:	4620      	mov	r0, r4
 80048b4:	4611      	mov	r1, r2
 80048b6:	461a      	mov	r2, r3
 80048b8:	f7fe fc18 	bl	80030ec <SVGEN_run>

	obj->Tabc.value[0]=pPwmData->Tabc.value[0];
 80048bc:	68bb      	ldr	r3, [r7, #8]
 80048be:	681a      	ldr	r2, [r3, #0]
 80048c0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80048c2:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
	obj->Tabc.value[1]=pPwmData->Tabc.value[1];
 80048c6:	68bb      	ldr	r3, [r7, #8]
 80048c8:	685a      	ldr	r2, [r3, #4]
 80048ca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80048cc:	f8c3 230c 	str.w	r2, [r3, #780]	; 0x30c
	obj->Tabc.value[2]=pPwmData->Tabc.value[2];
 80048d0:	68bb      	ldr	r3, [r7, #8]
 80048d2:	689a      	ldr	r2, [r3, #8]
 80048d4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80048d6:	f8c3 2310 	str.w	r2, [r3, #784]	; 0x310

 return;
 80048da:	bf00      	nop
} // end of CTRL_runOnLine_User() function
 80048dc:	3738      	adds	r7, #56	; 0x38
 80048de:	46bd      	mov	sp, r7
 80048e0:	bdb0      	pop	{r4, r5, r7, pc}
 80048e2:	bf00      	nop
 80048e4:	40c90fdb 	.word	0x40c90fdb
 80048e8:	47000000 	.word	0x47000000
 80048ec:	37ffda40 	.word	0x37ffda40
 80048f0:	3e4ccccd 	.word	0x3e4ccccd
 80048f4:	3e4ccccd 	.word	0x3e4ccccd

080048f8 <CTRL_runOnLine_User>:
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  pAdcData  The pointer to the ADC data
//! \param[out] pPwmData  The pointer to the PWM data
static inline void CTRL_runOnLine_User(CTRL_Handle handle,HAL_Handle halHandle,
                           const HAL_AdcData_t *pAdcData,HAL_PwmData_t *pPwmData, HAL_QepData_t *pQepData)//! \Mod By Dl.K
{
 80048f8:	b5b0      	push	{r4, r5, r7, lr}
 80048fa:	b09a      	sub	sp, #104	; 0x68
 80048fc:	af00      	add	r7, sp, #0
 80048fe:	6178      	str	r0, [r7, #20]
 8004900:	6139      	str	r1, [r7, #16]
 8004902:	60fa      	str	r2, [r7, #12]
 8004904:	60bb      	str	r3, [r7, #8]

 // run the space Vector Generator (SVGEN) module
 SVGEN_run(obj->svgenHandle,CTRL_getVab_out_addr(handle),&(pPwmData->Tabc));
*/

	CTRL_Obj *obj = (CTRL_Obj *)handle;
 8004906:	697b      	ldr	r3, [r7, #20]
 8004908:	663b      	str	r3, [r7, #96]	; 0x60

	MATH_vec2 phasor;


	// run Clarke transform on current
	CLARKE_run(obj->clarkeHandle_I,&pAdcData->I,CTRL_getIab_in_addr(handle));
 800490a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800490c:	68dd      	ldr	r5, [r3, #12]
 800490e:	68fc      	ldr	r4, [r7, #12]
 8004910:	6978      	ldr	r0, [r7, #20]
 8004912:	f7fe ff91 	bl	8003838 <CTRL_getIab_in_addr>
 8004916:	4603      	mov	r3, r0
 8004918:	4628      	mov	r0, r5
 800491a:	4621      	mov	r1, r4
 800491c:	461a      	mov	r2, r3
 800491e:	f7fe f8fd 	bl	8002b1c <CLARKE_run>

//	// generate the motor electrical angle
//	angle_pu = EST_getAngle_pu(obj->estHandle);
//	angle_pu = _IQ13toIQ(QEP_read_posn_count(halHandle->qepHandle[0]))*USER_MOTOR_NUM_POLE_PAIRS;
//	angle_pu &= 0xFFFFFF;
	angle_temp_pu = 32768.0f*pQepData->qep_cnt*USER_MOTOR_NUM_POLE_PAIRS;
 8004922:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8004924:	edd3 7a00 	vldr	s15, [r3]
 8004928:	ed9f 7acd 	vldr	s14, [pc, #820]	; 8004c60 <CTRL_runOnLine_User+0x368>
 800492c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8004930:	eeb1 7a00 	vmov.f32	s14, #16
 8004934:	ee67 7a87 	vmul.f32	s15, s15, s14
 8004938:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800493c:	edc7 7a01 	vstr	s15, [r7, #4]
 8004940:	88bb      	ldrh	r3, [r7, #4]
 8004942:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
	angle_temp_pu &= 0x7FFF;
 8004946:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 800494a:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800494e:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
	angle_pu = angle_temp_pu *0.0000305f - obj->angle_offset_pu;
 8004952:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 8004956:	ee07 3a90 	vmov	s15, r3
 800495a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800495e:	ed9f 7ac1 	vldr	s14, [pc, #772]	; 8004c64 <CTRL_runOnLine_User+0x36c>
 8004962:	ee27 7a87 	vmul.f32	s14, s15, s14
 8004966:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004968:	edd3 7a83 	vldr	s15, [r3, #524]	; 0x20c
 800496c:	ee77 7a67 	vsub.f32	s15, s14, s15
 8004970:	edc7 7a16 	vstr	s15, [r7, #88]	; 0x58

//	obj->angle_pu = angle_pu;

	// compute the sin/cos phasor
	CTRL_computePhasor(angle_pu * MATH_TWO_PI,&phasor);
 8004974:	edd7 7a16 	vldr	s15, [r7, #88]	; 0x58
 8004978:	ed9f 7abb 	vldr	s14, [pc, #748]	; 8004c68 <CTRL_runOnLine_User+0x370>
 800497c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8004980:	f107 0318 	add.w	r3, r7, #24
 8004984:	eeb0 0a67 	vmov.f32	s0, s15
 8004988:	4618      	mov	r0, r3
 800498a:	f7ff fc53 	bl	8004234 <CTRL_computePhasor>


	// set the phasor in the Park transform
	PARK_setPhasor(obj->parkHandle,&phasor);
 800498e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004990:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004992:	f107 0318 	add.w	r3, r7, #24
 8004996:	4610      	mov	r0, r2
 8004998:	4619      	mov	r1, r3
 800499a:	f7fe f981 	bl	8002ca0 <PARK_setPhasor>


	// run the Park transform
	PARK_run(obj->parkHandle,CTRL_getIab_in_addr(handle),CTRL_getIdq_in_addr(handle));
 800499e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80049a0:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 80049a2:	6978      	ldr	r0, [r7, #20]
 80049a4:	f7fe ff48 	bl	8003838 <CTRL_getIab_in_addr>
 80049a8:	4605      	mov	r5, r0
 80049aa:	6978      	ldr	r0, [r7, #20]
 80049ac:	f7fe ff78 	bl	80038a0 <CTRL_getIdq_in_addr>
 80049b0:	4603      	mov	r3, r0
 80049b2:	4620      	mov	r0, r4
 80049b4:	4629      	mov	r1, r5
 80049b6:	461a      	mov	r2, r3
 80049b8:	f7fe f936 	bl	8002c28 <PARK_run>


	// when appropriate, run the PID speed controller
	if(CTRL_doSpeedCtrl(handle))
 80049bc:	6978      	ldr	r0, [r7, #20]
 80049be:	f7ff fc73 	bl	80042a8 <CTRL_doSpeedCtrl>
 80049c2:	4603      	mov	r3, r0
 80049c4:	2b00      	cmp	r3, #0
 80049c6:	d05d      	beq.n	8004a84 <CTRL_runOnLine_User+0x18c>
	{
//		float_t refValue = TRAJ_getIntValue(obj->trajHandle_spd);
//		float_t fbackValue = EST_getFm_pu(obj->estHandle);
//		float_t outMax = TRAJ_getIntValue(obj->trajHandle_spdMax);
//		float_t outMin = -outMax;
		float_t refValue = CTRL_getSpd_ref_pu(obj);
 80049c8:	6e38      	ldr	r0, [r7, #96]	; 0x60
 80049ca:	f7ff f827 	bl	8003a1c <CTRL_getSpd_ref_pu>
 80049ce:	ed87 0a15 	vstr	s0, [r7, #84]	; 0x54
		float_t fbackValue = (0.0f);
 80049d2:	f04f 0300 	mov.w	r3, #0
 80049d6:	653b      	str	r3, [r7, #80]	; 0x50
		float_t outMax = (0.04f);
 80049d8:	4ba4      	ldr	r3, [pc, #656]	; (8004c6c <CTRL_runOnLine_User+0x374>)
 80049da:	64fb      	str	r3, [r7, #76]	; 0x4c
		float_t outMin = -outMax;
 80049dc:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
 80049e0:	eef1 7a67 	vneg.f32	s15, s15
 80049e4:	edc7 7a12 	vstr	s15, [r7, #72]	; 0x48
		float_t Kp_Spd = CTRL_getKp(handle,CTRL_Type_PID_spd);
 80049e8:	6978      	ldr	r0, [r7, #20]
 80049ea:	2100      	movs	r1, #0
 80049ec:	f7fe ffb8 	bl	8003960 <CTRL_getKp>
 80049f0:	ed87 0a11 	vstr	s0, [r7, #68]	; 0x44
		float_t Ki_Spd = CTRL_getKi(handle,CTRL_Type_PID_spd);
 80049f4:	6978      	ldr	r0, [r7, #20]
 80049f6:	2100      	movs	r1, #0
 80049f8:	f7fe ff86 	bl	8003908 <CTRL_getKi>
 80049fc:	ed87 0a10 	vstr	s0, [r7, #64]	; 0x40

		// reset the speed count
		CTRL_resetCounter_speed(handle);
 8004a00:	6978      	ldr	r0, [r7, #20]
 8004a02:	f7ff f8fd 	bl	8003c00 <CTRL_resetCounter_speed>

		Speed_SetElecTheta(obj->Speed_handle, angle_pu);
 8004a06:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004a08:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 8004a0c:	4618      	mov	r0, r3
 8004a0e:	ed97 0a16 	vldr	s0, [r7, #88]	; 0x58
 8004a12:	f7fe fe45 	bl	80036a0 <Speed_SetElecTheta>
		Speed_Run(obj->Speed_handle);
 8004a16:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004a18:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 8004a1c:	4618      	mov	r0, r3
 8004a1e:	f7fd ff75 	bl	800290c <Speed_Run>
		fbackValue = Speed_GetElecSpeed(obj->Speed_handle);
 8004a22:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004a24:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 8004a28:	4618      	mov	r0, r3
 8004a2a:	f7fe fe7f 	bl	800372c <Speed_GetElecSpeed>
 8004a2e:	ed87 0a14 	vstr	s0, [r7, #80]	; 0x50

		PID_setKp(obj->pidHandle_spd,Kp_Spd);
 8004a32:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004a34:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8004a38:	4618      	mov	r0, r3
 8004a3a:	ed97 0a11 	vldr	s0, [r7, #68]	; 0x44
 8004a3e:	f7fe fb1b 	bl	8003078 <PID_setKp>
		PID_setKi(obj->pidHandle_spd,Ki_Spd);
 8004a42:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004a44:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8004a48:	4618      	mov	r0, r3
 8004a4a:	ed97 0a10 	vldr	s0, [r7, #64]	; 0x40
 8004a4e:	f7fe fb01 	bl	8003054 <PID_setKi>

		PID_setMinMax(obj->pidHandle_spd,outMin,outMax);
 8004a52:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004a54:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8004a58:	4618      	mov	r0, r3
 8004a5a:	ed97 0a12 	vldr	s0, [r7, #72]	; 0x48
 8004a5e:	edd7 0a13 	vldr	s1, [r7, #76]	; 0x4c
 8004a62:	f7fe fb1b 	bl	800309c <PID_setMinMax>

		PID_run_spd(obj->pidHandle_spd,refValue,fbackValue,CTRL_getSpd_out_addr(handle));
 8004a66:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004a68:	f8d3 4084 	ldr.w	r4, [r3, #132]	; 0x84
 8004a6c:	6978      	ldr	r0, [r7, #20]
 8004a6e:	f7fe ffb3 	bl	80039d8 <CTRL_getSpd_out_addr>
 8004a72:	4603      	mov	r3, r0
 8004a74:	4620      	mov	r0, r4
 8004a76:	ed97 0a15 	vldr	s0, [r7, #84]	; 0x54
 8004a7a:	edd7 0a14 	vldr	s1, [r7, #80]	; 0x50
 8004a7e:	4619      	mov	r1, r3
 8004a80:	f7fe fa6c 	bl	8002f5c <PID_run_spd>
	}


	// when appropriate, run the PID Id and Iq controllers
	if(CTRL_doCurrentCtrl(handle))
 8004a84:	6978      	ldr	r0, [r7, #20]
 8004a86:	f7ff fbf1 	bl	800426c <CTRL_doCurrentCtrl>
 8004a8a:	4603      	mov	r3, r0
 8004a8c:	2b00      	cmp	r3, #0
 8004a8e:	f000 8097 	beq.w	8004bc0 <CTRL_runOnLine_User+0x2c8>
	{
		float_t Kp_Id = CTRL_getKp(handle,CTRL_Type_PID_Id);
 8004a92:	6978      	ldr	r0, [r7, #20]
 8004a94:	2101      	movs	r1, #1
 8004a96:	f7fe ff63 	bl	8003960 <CTRL_getKp>
 8004a9a:	ed87 0a0f 	vstr	s0, [r7, #60]	; 0x3c
		float_t Kp_Iq = CTRL_getKp(handle,CTRL_Type_PID_Iq);
 8004a9e:	6978      	ldr	r0, [r7, #20]
 8004aa0:	2102      	movs	r1, #2
 8004aa2:	f7fe ff5d 	bl	8003960 <CTRL_getKp>
 8004aa6:	ed87 0a0e 	vstr	s0, [r7, #56]	; 0x38
		float_t Ki_Id = CTRL_getKi(handle,CTRL_Type_PID_Id);
 8004aaa:	6978      	ldr	r0, [r7, #20]
 8004aac:	2101      	movs	r1, #1
 8004aae:	f7fe ff2b 	bl	8003908 <CTRL_getKi>
 8004ab2:	ed87 0a0d 	vstr	s0, [r7, #52]	; 0x34
		float_t Ki_Iq = CTRL_getKi(handle,CTRL_Type_PID_Iq);
 8004ab6:	6978      	ldr	r0, [r7, #20]
 8004ab8:	2102      	movs	r1, #2
 8004aba:	f7fe ff25 	bl	8003908 <CTRL_getKi>
 8004abe:	ed87 0a0c 	vstr	s0, [r7, #48]	; 0x30
		float_t outMin,outMax;


//		// read max voltage vector to set proper limits to current controllers
//		float_t maxVsMag = CTRL_getMaxVsMag_pu(handle);
		float_t maxVsMag = (0.2f);
 8004ac2:	4b6b      	ldr	r3, [pc, #428]	; (8004c70 <CTRL_runOnLine_User+0x378>)
 8004ac4:	62fb      	str	r3, [r7, #44]	; 0x2c


		// reset the current count
		CTRL_resetCounter_current(handle);
 8004ac6:	6978      	ldr	r0, [r7, #20]
 8004ac8:	f7ff f87a 	bl	8003bc0 <CTRL_resetCounter_current>
//		if(CTRL_getFlag_enableDcBusComp(handle))
//		{
//			Kp_Id = (Kp_Id*EST_getOneOverDcBus_pu(obj->estHandle));
//		}

		PID_setKp(obj->pidHandle_Id,Kp_Id);
 8004acc:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004ace:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004ad0:	4618      	mov	r0, r3
 8004ad2:	ed97 0a0f 	vldr	s0, [r7, #60]	; 0x3c
 8004ad6:	f7fe facf 	bl	8003078 <PID_setKp>
		PID_setKi(obj->pidHandle_Id,Ki_Id);
 8004ada:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004adc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004ade:	4618      	mov	r0, r3
 8004ae0:	ed97 0a0d 	vldr	s0, [r7, #52]	; 0x34
 8004ae4:	f7fe fab6 	bl	8003054 <PID_setKi>

//		// compute the reference value
//		refValue = TRAJ_getIntValue(obj->trajHandle_Id) + CTRL_getId_ref_pu(handle);
		refValue = CTRL_getId_ref_pu(handle);
 8004ae8:	6978      	ldr	r0, [r7, #20]
 8004aea:	f7fe fec7 	bl	800387c <CTRL_getId_ref_pu>
 8004aee:	ed87 0a19 	vstr	s0, [r7, #100]	; 0x64

//		// update the Id reference value
//		EST_updateId_ref_pu(obj->estHandle,&refValue);

		// get the feedback value
		fbackValue = CTRL_getId_in_pu(handle);
 8004af2:	6978      	ldr	r0, [r7, #20]
 8004af4:	f7fe feb0 	bl	8003858 <CTRL_getId_in_pu>
 8004af8:	ed87 0a0a 	vstr	s0, [r7, #40]	; 0x28

		// set minimum and maximum for Id controller output
		outMax = maxVsMag;
 8004afc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004afe:	627b      	str	r3, [r7, #36]	; 0x24
		outMin = -outMax;
 8004b00:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8004b04:	eef1 7a67 	vneg.f32	s15, s15
 8004b08:	edc7 7a08 	vstr	s15, [r7, #32]

		// set the minimum and maximum values
		PID_setMinMax(obj->pidHandle_Id,outMin,outMax);
 8004b0c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004b0e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004b10:	4618      	mov	r0, r3
 8004b12:	ed97 0a08 	vldr	s0, [r7, #32]
 8004b16:	edd7 0a09 	vldr	s1, [r7, #36]	; 0x24
 8004b1a:	f7fe fabf 	bl	800309c <PID_setMinMax>

		// run the Id PID controller
		PID_run(obj->pidHandle_Id,refValue,fbackValue,CTRL_getVd_out_addr(handle));
 8004b1e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004b20:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 8004b22:	6978      	ldr	r0, [r7, #20]
 8004b24:	f7fe ffaa 	bl	8003a7c <CTRL_getVd_out_addr>
 8004b28:	4603      	mov	r3, r0
 8004b2a:	4620      	mov	r0, r4
 8004b2c:	ed97 0a19 	vldr	s0, [r7, #100]	; 0x64
 8004b30:	edd7 0a0a 	vldr	s1, [r7, #40]	; 0x28
 8004b34:	4619      	mov	r1, r3
 8004b36:	f7fe f9b1 	bl	8002e9c <PID_run>
//		if(CTRL_getFlag_enableDcBusComp(handle))
//		{
//			Kp_Iq = (Kp_Iq*EST_getOneOverDcBus_pu(obj->estHandle));
//		}

		PID_setKp(obj->pidHandle_Iq,Kp_Iq);
 8004b3a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004b3c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004b3e:	4618      	mov	r0, r3
 8004b40:	ed97 0a0e 	vldr	s0, [r7, #56]	; 0x38
 8004b44:	f7fe fa98 	bl	8003078 <PID_setKp>
		PID_setKi(obj->pidHandle_Iq,Ki_Iq);
 8004b48:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004b4a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004b4c:	4618      	mov	r0, r3
 8004b4e:	ed97 0a0c 	vldr	s0, [r7, #48]	; 0x30
 8004b52:	f7fe fa7f 	bl	8003054 <PID_setKi>

		// get the reference value
		if(CTRL_getFlag_enableSpeedCtrl(handle))
 8004b56:	6978      	ldr	r0, [r7, #20]
 8004b58:	f7fe fe5e 	bl	8003818 <CTRL_getFlag_enableSpeedCtrl>
 8004b5c:	4603      	mov	r3, r0
 8004b5e:	2b00      	cmp	r3, #0
 8004b60:	d005      	beq.n	8004b6e <CTRL_runOnLine_User+0x276>
		{
			refValue = CTRL_getSpd_out_pu(handle);
 8004b62:	6978      	ldr	r0, [r7, #20]
 8004b64:	f7fe ff48 	bl	80039f8 <CTRL_getSpd_out_pu>
 8004b68:	ed87 0a19 	vstr	s0, [r7, #100]	; 0x64
 8004b6c:	e004      	b.n	8004b78 <CTRL_runOnLine_User+0x280>
		}
		else
		{
		// get the Iq reference value
			refValue = CTRL_getIq_ref_pu(handle);
 8004b6e:	6978      	ldr	r0, [r7, #20]
 8004b70:	f7fe feb8 	bl	80038e4 <CTRL_getIq_ref_pu>
 8004b74:	ed87 0a19 	vstr	s0, [r7, #100]	; 0x64
		}

		// get the feedback value
		fbackValue = CTRL_getIq_in_pu(handle);
 8004b78:	6978      	ldr	r0, [r7, #20]
 8004b7a:	f7fe fea1 	bl	80038c0 <CTRL_getIq_in_pu>
 8004b7e:	ed87 0a0a 	vstr	s0, [r7, #40]	; 0x28

//		// set minimum and maximum for Id controller output
//		outMax = sqrtf((maxVsMag*maxVsMag) - (CTRL_getVd_out_pu(handle)*CTRL_getVd_out_pu(handle)));
//		outMin = -outMax;
		outMax = (0.2f);
 8004b82:	4b3b      	ldr	r3, [pc, #236]	; (8004c70 <CTRL_runOnLine_User+0x378>)
 8004b84:	627b      	str	r3, [r7, #36]	; 0x24
		outMin = -outMax;
 8004b86:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8004b8a:	eef1 7a67 	vneg.f32	s15, s15
 8004b8e:	edc7 7a08 	vstr	s15, [r7, #32]

		// set the minimum and maximum values
		PID_setMinMax(obj->pidHandle_Iq,outMin,outMax);
 8004b92:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004b94:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004b96:	4618      	mov	r0, r3
 8004b98:	ed97 0a08 	vldr	s0, [r7, #32]
 8004b9c:	edd7 0a09 	vldr	s1, [r7, #36]	; 0x24
 8004ba0:	f7fe fa7c 	bl	800309c <PID_setMinMax>

		// run the Iq PID controller
		PID_run(obj->pidHandle_Iq,refValue,fbackValue,CTRL_getVq_out_addr(handle));
 8004ba4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004ba6:	6e1c      	ldr	r4, [r3, #96]	; 0x60
 8004ba8:	6978      	ldr	r0, [r7, #20]
 8004baa:	f7fe ff87 	bl	8003abc <CTRL_getVq_out_addr>
 8004bae:	4603      	mov	r3, r0
 8004bb0:	4620      	mov	r0, r4
 8004bb2:	ed97 0a19 	vldr	s0, [r7, #100]	; 0x64
 8004bb6:	edd7 0a0a 	vldr	s1, [r7, #40]	; 0x28
 8004bba:	4619      	mov	r1, r3
 8004bbc:	f7fe f96e 	bl	8002e9c <PID_run>
//		CTRL_computePhasor(angleComp_pu * MATH_TWO_PI,&phasor);
//	}


	// set the phasor in the inverse Park transform
	IPARK_setPhasor(obj->iparkHandle,&phasor);
 8004bc0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004bc2:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
 8004bc6:	f107 0318 	add.w	r3, r7, #24
 8004bca:	4610      	mov	r0, r2
 8004bcc:	4619      	mov	r1, r3
 8004bce:	f7fe f8b9 	bl	8002d44 <IPARK_setPhasor>


	// run the inverse Park module
	IPARK_run(obj->iparkHandle,CTRL_getVdq_out_addr(handle),CTRL_getVab_out_addr(handle));
 8004bd2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004bd4:	f8d3 40a8 	ldr.w	r4, [r3, #168]	; 0xa8
 8004bd8:	6978      	ldr	r0, [r7, #20]
 8004bda:	f7fe ff5f 	bl	8003a9c <CTRL_getVdq_out_addr>
 8004bde:	4605      	mov	r5, r0
 8004be0:	6978      	ldr	r0, [r7, #20]
 8004be2:	f7fe ff3b 	bl	8003a5c <CTRL_getVab_out_addr>
 8004be6:	4603      	mov	r3, r0
 8004be8:	4620      	mov	r0, r4
 8004bea:	4629      	mov	r1, r5
 8004bec:	461a      	mov	r2, r3
 8004bee:	f7fe f86d 	bl	8002ccc <IPARK_run>


	// run the space Vector Generator (SVGEN) module
	SVGEN_run(obj->svgenHandle,CTRL_getVab_out_addr(handle),&(pPwmData->Tabc));
 8004bf2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004bf4:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8004bf8:	6978      	ldr	r0, [r7, #20]
 8004bfa:	f7fe ff2f 	bl	8003a5c <CTRL_getVab_out_addr>
 8004bfe:	4602      	mov	r2, r0
 8004c00:	68bb      	ldr	r3, [r7, #8]
 8004c02:	4620      	mov	r0, r4
 8004c04:	4611      	mov	r1, r2
 8004c06:	461a      	mov	r2, r3
 8004c08:	f7fe fa70 	bl	80030ec <SVGEN_run>


	obj->Tabc.value[0]=pPwmData->Tabc.value[0];
 8004c0c:	68bb      	ldr	r3, [r7, #8]
 8004c0e:	681a      	ldr	r2, [r3, #0]
 8004c10:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004c12:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
	obj->Tabc.value[1]=pPwmData->Tabc.value[1];
 8004c16:	68bb      	ldr	r3, [r7, #8]
 8004c18:	685a      	ldr	r2, [r3, #4]
 8004c1a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004c1c:	f8c3 230c 	str.w	r2, [r3, #780]	; 0x30c
	obj->Tabc.value[2]=pPwmData->Tabc.value[2];
 8004c20:	68bb      	ldr	r3, [r7, #8]
 8004c22:	689a      	ldr	r2, [r3, #8]
 8004c24:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004c26:	f8c3 2310 	str.w	r2, [r3, #784]	; 0x310
	//	DATA_LOG_Run(obj->datalog_handle);

	obj->MntValue.value[0] = Speed_GetElecSpeed(obj->Speed_handle);
 8004c2a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004c2c:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 8004c30:	4618      	mov	r0, r3
 8004c32:	f7fe fd7b 	bl	800372c <Speed_GetElecSpeed>
 8004c36:	eef0 7a40 	vmov.f32	s15, s0
 8004c3a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004c3c:	edc3 7ac8 	vstr	s15, [r3, #800]	; 0x320
	obj->MntValue.value[1] = angle_pu;
 8004c40:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004c42:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8004c44:	f8c3 2324 	str.w	r2, [r3, #804]	; 0x324
	obj->MntValue.value[2] = CTRL_getVq_out_pu(handle);
 8004c48:	6978      	ldr	r0, [r7, #20]
 8004c4a:	f7fe ff47 	bl	8003adc <CTRL_getVq_out_pu>
 8004c4e:	eef0 7a40 	vmov.f32	s15, s0
 8004c52:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004c54:	edc3 7aca 	vstr	s15, [r3, #808]	; 0x328

return;
 8004c58:	bf00      	nop
} // end of CTRL_runOnLine_User() function
 8004c5a:	3768      	adds	r7, #104	; 0x68
 8004c5c:	46bd      	mov	sp, r7
 8004c5e:	bdb0      	pop	{r4, r5, r7, pc}
 8004c60:	47000000 	.word	0x47000000
 8004c64:	37ffda40 	.word	0x37ffda40
 8004c68:	40c90fdb 	.word	0x40c90fdb
 8004c6c:	3d23d70a 	.word	0x3d23d70a
 8004c70:	3e4ccccd 	.word	0x3e4ccccd

08004c74 <CTRL_run>:

void CTRL_run(CTRL_Handle handle,HAL_Handle halHandle,
              const HAL_AdcData_t *pAdcData,
              HAL_PwmData_t *pPwmData,
							HAL_QepData_t *pQepData)
{
 8004c74:	b580      	push	{r7, lr}
 8004c76:	b088      	sub	sp, #32
 8004c78:	af02      	add	r7, sp, #8
 8004c7a:	60f8      	str	r0, [r7, #12]
 8004c7c:	60b9      	str	r1, [r7, #8]
 8004c7e:	607a      	str	r2, [r7, #4]
 8004c80:	603b      	str	r3, [r7, #0]
      CTRL_incrCounter_isr(handle);
    }
*/

	//! \Mod By Dl.K
	uint_least16_t count_isr = CTRL_getCount_isr(handle);
 8004c82:	68f8      	ldr	r0, [r7, #12]
 8004c84:	f7fe fda8 	bl	80037d8 <CTRL_getCount_isr>
 8004c88:	4603      	mov	r3, r0
 8004c8a:	82fb      	strh	r3, [r7, #22]
	uint_least16_t numIsrTicksPerCtrlTick = CTRL_getNumIsrTicksPerCtrlTick(handle);
 8004c8c:	68f8      	ldr	r0, [r7, #12]
 8004c8e:	f7fe fe93 	bl	80039b8 <CTRL_getNumIsrTicksPerCtrlTick>
 8004c92:	4603      	mov	r3, r0
 8004c94:	82bb      	strh	r3, [r7, #20]

	// if needed, run the controller
	if(count_isr >= numIsrTicksPerCtrlTick)
 8004c96:	8afa      	ldrh	r2, [r7, #22]
 8004c98:	8abb      	ldrh	r3, [r7, #20]
 8004c9a:	429a      	cmp	r2, r3
 8004c9c:	d37c      	bcc.n	8004d98 <CTRL_run+0x124>
	{
		CTRL_State_e ctrlState = CTRL_getState(handle);
 8004c9e:	68f8      	ldr	r0, [r7, #12]
 8004ca0:	f7fe fece 	bl	8003a40 <CTRL_getState>
 8004ca4:	4603      	mov	r3, r0
 8004ca6:	74fb      	strb	r3, [r7, #19]

		// reset the isr count
		CTRL_resetCounter_isr(handle);
 8004ca8:	68f8      	ldr	r0, [r7, #12]
 8004caa:	f7fe ff99 	bl	8003be0 <CTRL_resetCounter_isr>

		// increment the state counter
		//CTRL_incrCounter_state(handle);

		// increment the trajectory count
		CTRL_incrCounter_traj(handle);
 8004cae:	68f8      	ldr	r0, [r7, #12]
 8004cb0:	f7fe ff6e 	bl	8003b90 <CTRL_incrCounter_traj>
		// run the appropriate controller
		if(ctrlState == CTRL_State_Error)
 8004cb4:	7cfb      	ldrb	r3, [r7, #19]
 8004cb6:	2b00      	cmp	r3, #0
 8004cb8:	d06d      	beq.n	8004d96 <CTRL_run+0x122>
		{
			// run the Error controller
			
		}
		else if(ctrlState == CTRL_State_Idle)
 8004cba:	7cfb      	ldrb	r3, [r7, #19]
 8004cbc:	2b01      	cmp	r3, #1
 8004cbe:	d108      	bne.n	8004cd2 <CTRL_run+0x5e>
		{
			// run the Idle controller
			CTRL_runOffLine(handle,halHandle,pAdcData,pPwmData,pQepData);
 8004cc0:	6a3b      	ldr	r3, [r7, #32]
 8004cc2:	9300      	str	r3, [sp, #0]
 8004cc4:	68f8      	ldr	r0, [r7, #12]
 8004cc6:	68b9      	ldr	r1, [r7, #8]
 8004cc8:	687a      	ldr	r2, [r7, #4]
 8004cca:	683b      	ldr	r3, [r7, #0]
 8004ccc:	f7ff fb06 	bl	80042dc <CTRL_runOffLine>
 8004cd0:	e061      	b.n	8004d96 <CTRL_run+0x122>
		}
		else if(ctrlState == CTRL_State_OffLine)
 8004cd2:	7cfb      	ldrb	r3, [r7, #19]
 8004cd4:	2b02      	cmp	r3, #2
 8004cd6:	d108      	bne.n	8004cea <CTRL_run+0x76>
		{
			// run the offline controller
			CTRL_runOffLine(handle,halHandle,pAdcData,pPwmData,pQepData);
 8004cd8:	6a3b      	ldr	r3, [r7, #32]
 8004cda:	9300      	str	r3, [sp, #0]
 8004cdc:	68f8      	ldr	r0, [r7, #12]
 8004cde:	68b9      	ldr	r1, [r7, #8]
 8004ce0:	687a      	ldr	r2, [r7, #4]
 8004ce2:	683b      	ldr	r3, [r7, #0]
 8004ce4:	f7ff fafa 	bl	80042dc <CTRL_runOffLine>
 8004ce8:	e055      	b.n	8004d96 <CTRL_run+0x122>
		}
		else if(ctrlState == CTRL_State_InitDete)
 8004cea:	7cfb      	ldrb	r3, [r7, #19]
 8004cec:	2b04      	cmp	r3, #4
 8004cee:	d108      	bne.n	8004d02 <CTRL_run+0x8e>
		{
			// run the InitDete controller
			CTRL_runInitDete_User(handle,halHandle,pAdcData,pPwmData,pQepData);
 8004cf0:	6a3b      	ldr	r3, [r7, #32]
 8004cf2:	9300      	str	r3, [sp, #0]
 8004cf4:	68f8      	ldr	r0, [r7, #12]
 8004cf6:	68b9      	ldr	r1, [r7, #8]
 8004cf8:	687a      	ldr	r2, [r7, #4]
 8004cfa:	683b      	ldr	r3, [r7, #0]
 8004cfc:	f7ff fb28 	bl	8004350 <CTRL_runInitDete_User>
 8004d00:	e049      	b.n	8004d96 <CTRL_run+0x122>
		}
		else if(ctrlState == CTRL_State_StaticStatorInitDete)
 8004d02:	7cfb      	ldrb	r3, [r7, #19]
 8004d04:	2b05      	cmp	r3, #5
 8004d06:	d108      	bne.n	8004d1a <CTRL_run+0xa6>
		{
			// run the StaticStatorInitDete controller
			CTRL_runStaticStatorInitDete_User(handle,halHandle,pAdcData,pPwmData,pQepData);
 8004d08:	6a3b      	ldr	r3, [r7, #32]
 8004d0a:	9300      	str	r3, [sp, #0]
 8004d0c:	68f8      	ldr	r0, [r7, #12]
 8004d0e:	68b9      	ldr	r1, [r7, #8]
 8004d10:	687a      	ldr	r2, [r7, #4]
 8004d12:	683b      	ldr	r3, [r7, #0]
 8004d14:	f7ff fbd0 	bl	80044b8 <CTRL_runStaticStatorInitDete_User>
 8004d18:	e03d      	b.n	8004d96 <CTRL_run+0x122>
		}
		else if(ctrlState == CTRL_State_OpenLoop)
 8004d1a:	7cfb      	ldrb	r3, [r7, #19]
 8004d1c:	2b06      	cmp	r3, #6
 8004d1e:	d10b      	bne.n	8004d38 <CTRL_run+0xc4>
		{
			// increment the speed count
			CTRL_incrCounter_speed(handle);
 8004d20:	68f8      	ldr	r0, [r7, #12]
 8004d22:	f7fe ff1d 	bl	8003b60 <CTRL_incrCounter_speed>

			CTRL_runOpenLoop_User(handle,halHandle,pAdcData,pPwmData,pQepData);
 8004d26:	6a3b      	ldr	r3, [r7, #32]
 8004d28:	9300      	str	r3, [sp, #0]
 8004d2a:	68f8      	ldr	r0, [r7, #12]
 8004d2c:	68b9      	ldr	r1, [r7, #8]
 8004d2e:	687a      	ldr	r2, [r7, #4]
 8004d30:	683b      	ldr	r3, [r7, #0]
 8004d32:	f7ff fce7 	bl	8004704 <CTRL_runOpenLoop_User>
 8004d36:	e02e      	b.n	8004d96 <CTRL_run+0x122>
		}
		else if(ctrlState == CTRL_State_OnLine || ctrlState == CTRL_State_CurrentCloseLoop || ctrlState == CTRL_State_SpeedCloseLoop )
 8004d38:	7cfb      	ldrb	r3, [r7, #19]
 8004d3a:	2b07      	cmp	r3, #7
 8004d3c:	d005      	beq.n	8004d4a <CTRL_run+0xd6>
 8004d3e:	7cfb      	ldrb	r3, [r7, #19]
 8004d40:	2b08      	cmp	r3, #8
 8004d42:	d002      	beq.n	8004d4a <CTRL_run+0xd6>
 8004d44:	7cfb      	ldrb	r3, [r7, #19]
 8004d46:	2b09      	cmp	r3, #9
 8004d48:	d125      	bne.n	8004d96 <CTRL_run+0x122>
		{
			//CTRL_Obj *obj = (CTRL_Obj *)handle;

			// increment the current count
			CTRL_incrCounter_current(handle);
 8004d4a:	68f8      	ldr	r0, [r7, #12]
 8004d4c:	f7fe fed8 	bl	8003b00 <CTRL_incrCounter_current>

			// increment the speed count
			CTRL_incrCounter_speed(handle);
 8004d50:	68f8      	ldr	r0, [r7, #12]
 8004d52:	f7fe ff05 	bl	8003b60 <CTRL_incrCounter_speed>

			if( ctrlState == CTRL_State_CurrentCloseLoop )
 8004d56:	7cfb      	ldrb	r3, [r7, #19]
 8004d58:	2b08      	cmp	r3, #8
 8004d5a:	d108      	bne.n	8004d6e <CTRL_run+0xfa>
			{
				CTRL_setFlag_enableCurrentCtrl(handle,true);
 8004d5c:	68f8      	ldr	r0, [r7, #12]
 8004d5e:	2101      	movs	r1, #1
 8004d60:	f7fe ffd0 	bl	8003d04 <CTRL_setFlag_enableCurrentCtrl>
				CTRL_setFlag_enableSpeedCtrl(handle,false);
 8004d64:	68f8      	ldr	r0, [r7, #12]
 8004d66:	2100      	movs	r1, #0
 8004d68:	f7ff f814 	bl	8003d94 <CTRL_setFlag_enableSpeedCtrl>
 8004d6c:	e00a      	b.n	8004d84 <CTRL_run+0x110>
			}
			else if( ctrlState == CTRL_State_SpeedCloseLoop )
 8004d6e:	7cfb      	ldrb	r3, [r7, #19]
 8004d70:	2b09      	cmp	r3, #9
 8004d72:	d107      	bne.n	8004d84 <CTRL_run+0x110>
			{
				CTRL_setFlag_enableCurrentCtrl(handle,true);
 8004d74:	68f8      	ldr	r0, [r7, #12]
 8004d76:	2101      	movs	r1, #1
 8004d78:	f7fe ffc4 	bl	8003d04 <CTRL_setFlag_enableCurrentCtrl>
				CTRL_setFlag_enableSpeedCtrl(handle,true);
 8004d7c:	68f8      	ldr	r0, [r7, #12]
 8004d7e:	2101      	movs	r1, #1
 8004d80:	f7ff f808 	bl	8003d94 <CTRL_setFlag_enableSpeedCtrl>
			}
			//if(EST_getState(obj->estHandle) >= EST_State_MotorIdentified)
			//{
				// run the online controller
				CTRL_runOnLine_User(handle,halHandle,pAdcData,pPwmData,pQepData);
 8004d84:	6a3b      	ldr	r3, [r7, #32]
 8004d86:	9300      	str	r3, [sp, #0]
 8004d88:	68f8      	ldr	r0, [r7, #12]
 8004d8a:	68b9      	ldr	r1, [r7, #8]
 8004d8c:	687a      	ldr	r2, [r7, #4]
 8004d8e:	683b      	ldr	r3, [r7, #0]
 8004d90:	f7ff fdb2 	bl	80048f8 <CTRL_runOnLine_User>
 8004d94:	e003      	b.n	8004d9e <CTRL_run+0x12a>
 8004d96:	e002      	b.n	8004d9e <CTRL_run+0x12a>

	}
	else
	{
		// increment the isr count
		CTRL_incrCounter_isr(handle);
 8004d98:	68f8      	ldr	r0, [r7, #12]
 8004d9a:	f7fe fec9 	bl	8003b30 <CTRL_incrCounter_isr>
	}

  return;
 8004d9e:	bf00      	nop
} // end of CTRL_run() function
 8004da0:	3718      	adds	r7, #24
 8004da2:	46bd      	mov	sp, r7
 8004da4:	bd80      	pop	{r7, pc}
 8004da6:	bf00      	nop

08004da8 <CTRL_setGains>:


void CTRL_setGains(CTRL_Handle handle,const CTRL_Type_e ctrlType,
                   const float_t Kp,const float_t Ki,const float_t Kd)
{
 8004da8:	b580      	push	{r7, lr}
 8004daa:	b086      	sub	sp, #24
 8004dac:	af00      	add	r7, sp, #0
 8004dae:	6178      	str	r0, [r7, #20]
 8004db0:	460b      	mov	r3, r1
 8004db2:	ed87 0a03 	vstr	s0, [r7, #12]
 8004db6:	edc7 0a02 	vstr	s1, [r7, #8]
 8004dba:	ed87 1a01 	vstr	s2, [r7, #4]
 8004dbe:	74fb      	strb	r3, [r7, #19]

  CTRL_setKp(handle,ctrlType,Kp);
 8004dc0:	7cfb      	ldrb	r3, [r7, #19]
 8004dc2:	6978      	ldr	r0, [r7, #20]
 8004dc4:	4619      	mov	r1, r3
 8004dc6:	ed97 0a03 	vldr	s0, [r7, #12]
 8004dca:	f7ff f8b1 	bl	8003f30 <CTRL_setKp>
  CTRL_setKi(handle,ctrlType,Ki);
 8004dce:	7cfb      	ldrb	r3, [r7, #19]
 8004dd0:	6978      	ldr	r0, [r7, #20]
 8004dd2:	4619      	mov	r1, r3
 8004dd4:	ed97 0a02 	vldr	s0, [r7, #8]
 8004dd8:	f7ff f882 	bl	8003ee0 <CTRL_setKi>
  CTRL_setKd(handle,ctrlType,Kd);
 8004ddc:	7cfb      	ldrb	r3, [r7, #19]
 8004dde:	6978      	ldr	r0, [r7, #20]
 8004de0:	4619      	mov	r1, r3
 8004de2:	ed97 0a01 	vldr	s0, [r7, #4]
 8004de6:	f7ff f853 	bl	8003e90 <CTRL_setKd>

  return;    
 8004dea:	bf00      	nop
} // end of CTRL_setGains() function
 8004dec:	3718      	adds	r7, #24
 8004dee:	46bd      	mov	sp, r7
 8004df0:	bd80      	pop	{r7, pc}
 8004df2:	bf00      	nop

08004df4 <CTRL_init>:
  return;    
} // end of CTRL_setMaximumSpeed_pu() function


CTRL_Handle CTRL_init(void *pMemory, const size_t numBytes)
{
 8004df4:	b580      	push	{r7, lr}
 8004df6:	b084      	sub	sp, #16
 8004df8:	af00      	add	r7, sp, #0
 8004dfa:	6078      	str	r0, [r7, #4]
 8004dfc:	6039      	str	r1, [r7, #0]
	CTRL_Handle handle;
	CTRL_Obj *obj;


	if (numBytes < sizeof(CTRL_Obj))
 8004dfe:	683b      	ldr	r3, [r7, #0]
 8004e00:	f5b3 7f4b 	cmp.w	r3, #812	; 0x32c
 8004e04:	d201      	bcs.n	8004e0a <CTRL_init+0x16>
		return((CTRL_Handle)NULL);
 8004e06:	2300      	movs	r3, #0
 8004e08:	e0a4      	b.n	8004f54 <CTRL_init+0x160>


	// assign the handle
	handle = (CTRL_Handle)pMemory;
 8004e0a:	687b      	ldr	r3, [r7, #4]
 8004e0c:	60fb      	str	r3, [r7, #12]


	// assign the object
	obj = (CTRL_Obj *)handle;
 8004e0e:	68fb      	ldr	r3, [r7, #12]
 8004e10:	60bb      	str	r3, [r7, #8]


	obj->clarkeHandle_I = CLARKE_init(&obj->clarke_I, sizeof(obj->clarke_I));
 8004e12:	68bb      	ldr	r3, [r7, #8]
 8004e14:	3310      	adds	r3, #16
 8004e16:	4618      	mov	r0, r3
 8004e18:	210c      	movs	r1, #12
 8004e1a:	f7fd fe21 	bl	8002a60 <CLARKE_init>
 8004e1e:	4602      	mov	r2, r0
 8004e20:	68bb      	ldr	r3, [r7, #8]
 8004e22:	60da      	str	r2, [r3, #12]
	obj->clarkeHandle_V = CLARKE_init(&obj->clarke_V, sizeof(obj->clarke_V));
 8004e24:	68bb      	ldr	r3, [r7, #8]
 8004e26:	3320      	adds	r3, #32
 8004e28:	4618      	mov	r0, r3
 8004e2a:	210c      	movs	r1, #12
 8004e2c:	f7fd fe18 	bl	8002a60 <CLARKE_init>
 8004e30:	4602      	mov	r2, r0
 8004e32:	68bb      	ldr	r3, [r7, #8]
 8004e34:	61da      	str	r2, [r3, #28]


	obj->parkHandle = PARK_init(&obj->park, sizeof(obj->park));
 8004e36:	68bb      	ldr	r3, [r7, #8]
 8004e38:	3334      	adds	r3, #52	; 0x34
 8004e3a:	4618      	mov	r0, r3
 8004e3c:	2108      	movs	r1, #8
 8004e3e:	f001 fb25 	bl	800648c <PARK_init>
 8004e42:	4602      	mov	r2, r0
 8004e44:	68bb      	ldr	r3, [r7, #8]
 8004e46:	631a      	str	r2, [r3, #48]	; 0x30


	// initialize the Id PI controller module
	obj->pidHandle_Id = PID_init(&obj->pid_Id, sizeof(obj->pid_Id));
 8004e48:	68bb      	ldr	r3, [r7, #8]
 8004e4a:	3340      	adds	r3, #64	; 0x40
 8004e4c:	4618      	mov	r0, r3
 8004e4e:	2120      	movs	r1, #32
 8004e50:	f001 fb66 	bl	8006520 <PID_init>
 8004e54:	4602      	mov	r2, r0
 8004e56:	68bb      	ldr	r3, [r7, #8]
 8004e58:	63da      	str	r2, [r3, #60]	; 0x3c


	// initialize the Iq PI controller module
	obj->pidHandle_Iq = PID_init(&obj->pid_Iq, sizeof(obj->pid_Iq));
 8004e5a:	68bb      	ldr	r3, [r7, #8]
 8004e5c:	3364      	adds	r3, #100	; 0x64
 8004e5e:	4618      	mov	r0, r3
 8004e60:	2120      	movs	r1, #32
 8004e62:	f001 fb5d 	bl	8006520 <PID_init>
 8004e66:	4602      	mov	r2, r0
 8004e68:	68bb      	ldr	r3, [r7, #8]
 8004e6a:	661a      	str	r2, [r3, #96]	; 0x60


	// initialize the speed PI controller module
	obj->pidHandle_spd = PID_init(&obj->pid_spd, sizeof(obj->pid_spd));
 8004e6c:	68bb      	ldr	r3, [r7, #8]
 8004e6e:	3388      	adds	r3, #136	; 0x88
 8004e70:	4618      	mov	r0, r3
 8004e72:	2120      	movs	r1, #32
 8004e74:	f001 fb54 	bl	8006520 <PID_init>
 8004e78:	4602      	mov	r2, r0
 8004e7a:	68bb      	ldr	r3, [r7, #8]
 8004e7c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

	
	obj->iparkHandle = IPARK_init(&obj->ipark, sizeof(obj->ipark));
 8004e80:	68bb      	ldr	r3, [r7, #8]
 8004e82:	33ac      	adds	r3, #172	; 0xac
 8004e84:	4618      	mov	r0, r3
 8004e86:	2108      	movs	r1, #8
 8004e88:	f001 fa7c 	bl	8006384 <IPARK_init>
 8004e8c:	4602      	mov	r2, r0
 8004e8e:	68bb      	ldr	r3, [r7, #8]
 8004e90:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8


	obj->svgenHandle = SVGEN_init(&obj->svgen, sizeof(obj->svgen)); 
 8004e94:	68bb      	ldr	r3, [r7, #8]
 8004e96:	33b8      	adds	r3, #184	; 0xb8
 8004e98:	4618      	mov	r0, r3
 8004e9a:	2104      	movs	r1, #4
 8004e9c:	f001 fbbc 	bl	8006618 <SVGEN_init>
 8004ea0:	4602      	mov	r2, r0
 8004ea2:	68bb      	ldr	r3, [r7, #8]
 8004ea4:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4


	obj->trajHandle_Id = TRAJ_init(&obj->traj_Id, sizeof(obj->traj_Id));
 8004ea8:	68bb      	ldr	r3, [r7, #8]
 8004eaa:	33c0      	adds	r3, #192	; 0xc0
 8004eac:	4618      	mov	r0, r3
 8004eae:	2114      	movs	r1, #20
 8004eb0:	f001 fbc6 	bl	8006640 <TRAJ_init>
 8004eb4:	4602      	mov	r2, r0
 8004eb6:	68bb      	ldr	r3, [r7, #8]
 8004eb8:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc


	obj->trajHandle_spd = TRAJ_init(&obj->traj_spd, sizeof(obj->traj_spd));
 8004ebc:	68bb      	ldr	r3, [r7, #8]
 8004ebe:	33d8      	adds	r3, #216	; 0xd8
 8004ec0:	4618      	mov	r0, r3
 8004ec2:	2114      	movs	r1, #20
 8004ec4:	f001 fbbc 	bl	8006640 <TRAJ_init>
 8004ec8:	4602      	mov	r2, r0
 8004eca:	68bb      	ldr	r3, [r7, #8]
 8004ecc:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4


	obj->trajHandle_spdMax = TRAJ_init(&obj->traj_spdMax, sizeof(obj->traj_spdMax));
 8004ed0:	68bb      	ldr	r3, [r7, #8]
 8004ed2:	33f0      	adds	r3, #240	; 0xf0
 8004ed4:	4618      	mov	r0, r3
 8004ed6:	2114      	movs	r1, #20
 8004ed8:	f001 fbb2 	bl	8006640 <TRAJ_init>
 8004edc:	4602      	mov	r2, r0
 8004ede:	68bb      	ldr	r3, [r7, #8]
 8004ee0:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec


	obj->rmpcntl_handle = RMP_CNTL_Init(&obj->rmpcntl, sizeof(obj->rmpcntl));
 8004ee4:	68bb      	ldr	r3, [r7, #8]
 8004ee6:	f503 730a 	add.w	r3, r3, #552	; 0x228
 8004eea:	4618      	mov	r0, r3
 8004eec:	211c      	movs	r1, #28
 8004eee:	f001 fb65 	bl	80065bc <RMP_CNTL_Init>
 8004ef2:	4602      	mov	r2, r0
 8004ef4:	68bb      	ldr	r3, [r7, #8]
 8004ef6:	f8c3 2224 	str.w	r2, [r3, #548]	; 0x224


	obj->rampgen_handle = RAMPGEN_Init(&obj->rampgen, sizeof(obj->rampgen));
 8004efa:	68bb      	ldr	r3, [r7, #8]
 8004efc:	f503 7312 	add.w	r3, r3, #584	; 0x248
 8004f00:	4618      	mov	r0, r3
 8004f02:	2118      	movs	r1, #24
 8004f04:	f001 fb2e 	bl	8006564 <RAMPGEN_Init>
 8004f08:	4602      	mov	r2, r0
 8004f0a:	68bb      	ldr	r3, [r7, #8]
 8004f0c:	f8c3 2244 	str.w	r2, [r3, #580]	; 0x244


	obj->data_rtxd_handle = DATA_RTXD_Init(&obj->data_rtxd, sizeof(obj->data_rtxd));
 8004f10:	68bb      	ldr	r3, [r7, #8]
 8004f12:	f503 7319 	add.w	r3, r3, #612	; 0x264
 8004f16:	4618      	mov	r0, r3
 8004f18:	211e      	movs	r1, #30
 8004f1a:	f000 fbab 	bl	8005674 <DATA_RTXD_Init>
 8004f1e:	4602      	mov	r2, r0
 8004f20:	68bb      	ldr	r3, [r7, #8]
 8004f22:	f8c3 2260 	str.w	r2, [r3, #608]	; 0x260


	obj->InitPosDet_handle = INITPOSDET_Init(&obj->InitPosDet, sizeof(obj->InitPosDet));
 8004f26:	68bb      	ldr	r3, [r7, #8]
 8004f28:	f503 7322 	add.w	r3, r3, #648	; 0x288
 8004f2c:	4618      	mov	r0, r3
 8004f2e:	2160      	movs	r1, #96	; 0x60
 8004f30:	f7fc fb92 	bl	8001658 <INITPOSDET_Init>
 8004f34:	4602      	mov	r2, r0
 8004f36:	68bb      	ldr	r3, [r7, #8]
 8004f38:	f8c3 2284 	str.w	r2, [r3, #644]	; 0x284


	obj->Speed_handle = Speed_Init(&obj->Speed, sizeof(obj->Speed));
 8004f3c:	68bb      	ldr	r3, [r7, #8]
 8004f3e:	f503 733b 	add.w	r3, r3, #748	; 0x2ec
 8004f42:	4618      	mov	r0, r3
 8004f44:	211c      	movs	r1, #28
 8004f46:	f7fd fcb1 	bl	80028ac <Speed_Init>
 8004f4a:	4602      	mov	r2, r0
 8004f4c:	68bb      	ldr	r3, [r7, #8]
 8004f4e:	f8c3 22e8 	str.w	r2, [r3, #744]	; 0x2e8


	return(handle);
 8004f52:	68fb      	ldr	r3, [r7, #12]
} // end of CTRL_init() function
 8004f54:	4618      	mov	r0, r3
 8004f56:	3710      	adds	r7, #16
 8004f58:	46bd      	mov	sp, r7
 8004f5a:	bd80      	pop	{r7, pc}

08004f5c <CTRL_setParams>:


void CTRL_setParams(CTRL_Handle handle,USER_Params *pUserParams)
{
 8004f5c:	b580      	push	{r7, lr}
 8004f5e:	b096      	sub	sp, #88	; 0x58
 8004f60:	af00      	add	r7, sp, #0
 8004f62:	6078      	str	r0, [r7, #4]
 8004f64:	6039      	str	r1, [r7, #0]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8004f66:	687b      	ldr	r3, [r7, #4]
 8004f68:	657b      	str	r3, [r7, #84]	; 0x54

  float_t Kp,Ki,Kd;
  float_t outMin,outMax;
  float_t maxModulation;

  MATH_vec2 Iab_out_pu = {(0.0f),(0.0f)};
 8004f6a:	f04f 0300 	mov.w	r3, #0
 8004f6e:	637b      	str	r3, [r7, #52]	; 0x34
 8004f70:	f04f 0300 	mov.w	r3, #0
 8004f74:	63bb      	str	r3, [r7, #56]	; 0x38
  MATH_vec2 Idq_out_pu = {(0.0f),(0.0f)};
 8004f76:	f04f 0300 	mov.w	r3, #0
 8004f7a:	62fb      	str	r3, [r7, #44]	; 0x2c
 8004f7c:	f04f 0300 	mov.w	r3, #0
 8004f80:	633b      	str	r3, [r7, #48]	; 0x30
  MATH_vec2 Idq_ref_pu = {(0.0f),(0.0f)};
 8004f82:	f04f 0300 	mov.w	r3, #0
 8004f86:	627b      	str	r3, [r7, #36]	; 0x24
 8004f88:	f04f 0300 	mov.w	r3, #0
 8004f8c:	62bb      	str	r3, [r7, #40]	; 0x28
  MATH_vec2 Vab_in_pu  = {(0.0f),(0.0f)};
 8004f8e:	f04f 0300 	mov.w	r3, #0
 8004f92:	61fb      	str	r3, [r7, #28]
 8004f94:	f04f 0300 	mov.w	r3, #0
 8004f98:	623b      	str	r3, [r7, #32]
  MATH_vec2 Vab_out_pu = {(0.0f),(0.0f)};
 8004f9a:	f04f 0300 	mov.w	r3, #0
 8004f9e:	617b      	str	r3, [r7, #20]
 8004fa0:	f04f 0300 	mov.w	r3, #0
 8004fa4:	61bb      	str	r3, [r7, #24]
  MATH_vec2 Vdq_out_pu = {(0.0f),(0.0f)};
 8004fa6:	f04f 0300 	mov.w	r3, #0
 8004faa:	60fb      	str	r3, [r7, #12]
 8004fac:	f04f 0300 	mov.w	r3, #0
 8004fb0:	613b      	str	r3, [r7, #16]


  // assign the motor type
  CTRL_setMotorParams(handle,pUserParams->motor_type,
 8004fb2:	683b      	ldr	r3, [r7, #0]
 8004fb4:	f893 1064 	ldrb.w	r1, [r3, #100]	; 0x64
 8004fb8:	683b      	ldr	r3, [r7, #0]
 8004fba:	f8b3 2066 	ldrh.w	r2, [r3, #102]	; 0x66
 8004fbe:	683b      	ldr	r3, [r7, #0]
 8004fc0:	edd3 5a1a 	vldr	s11, [r3, #104]	; 0x68
 8004fc4:	683b      	ldr	r3, [r7, #0]
 8004fc6:	ed93 6a1d 	vldr	s12, [r3, #116]	; 0x74
 8004fca:	683b      	ldr	r3, [r7, #0]
 8004fcc:	edd3 6a1e 	vldr	s13, [r3, #120]	; 0x78
 8004fd0:	683b      	ldr	r3, [r7, #0]
 8004fd2:	ed93 7a1b 	vldr	s14, [r3, #108]	; 0x6c
 8004fd6:	683b      	ldr	r3, [r7, #0]
 8004fd8:	edd3 7a1c 	vldr	s15, [r3, #112]	; 0x70
 8004fdc:	6878      	ldr	r0, [r7, #4]
 8004fde:	eeb0 0a65 	vmov.f32	s0, s11
 8004fe2:	eef0 0a46 	vmov.f32	s1, s12
 8004fe6:	eeb0 1a66 	vmov.f32	s2, s13
 8004fea:	eef0 1a47 	vmov.f32	s3, s14
 8004fee:	eeb0 2a67 	vmov.f32	s4, s15
 8004ff2:	f7fe ffe9 	bl	8003fc8 <CTRL_setMotorParams>
                      pUserParams->motor_Rr,
                      pUserParams->motor_Rs);


  // assign other controller parameters
  CTRL_setNumIsrTicksPerCtrlTick(handle,pUserParams->numIsrTicksPerCtrlTick);
 8004ff6:	683b      	ldr	r3, [r7, #0]
 8004ff8:	899b      	ldrh	r3, [r3, #12]
 8004ffa:	6878      	ldr	r0, [r7, #4]
 8004ffc:	4619      	mov	r1, r3
 8004ffe:	f7ff f84f 	bl	80040a0 <CTRL_setNumIsrTicksPerCtrlTick>
  CTRL_setNumCtrlTicksPerCurrentTick(handle,pUserParams->numCtrlTicksPerCurrentTick);
 8005002:	683b      	ldr	r3, [r7, #0]
 8005004:	89db      	ldrh	r3, [r3, #14]
 8005006:	6878      	ldr	r0, [r7, #4]
 8005008:	4619      	mov	r1, r3
 800500a:	f7ff f813 	bl	8004034 <CTRL_setNumCtrlTicksPerCurrentTick>
  CTRL_setNumCtrlTicksPerSpeedTick(handle,pUserParams->numCtrlTicksPerSpeedTick);
 800500e:	683b      	ldr	r3, [r7, #0]
 8005010:	8a5b      	ldrh	r3, [r3, #18]
 8005012:	6878      	ldr	r0, [r7, #4]
 8005014:	4619      	mov	r1, r3
 8005016:	f7ff f81f 	bl	8004058 <CTRL_setNumCtrlTicksPerSpeedTick>
  CTRL_setNumCtrlTicksPerTrajTick(handle,pUserParams->numCtrlTicksPerTrajTick);
 800501a:	683b      	ldr	r3, [r7, #0]
 800501c:	8a9b      	ldrh	r3, [r3, #20]
 800501e:	6878      	ldr	r0, [r7, #4]
 8005020:	4619      	mov	r1, r3
 8005022:	f7ff f82b 	bl	800407c <CTRL_setNumCtrlTicksPerTrajTick>

  CTRL_setCtrlFreq_Hz(handle,pUserParams->ctrlFreq_Hz);
 8005026:	683b      	ldr	r3, [r7, #0]
 8005028:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 800502c:	6878      	ldr	r0, [r7, #4]
 800502e:	4619      	mov	r1, r3
 8005030:	f7fe fe16 	bl	8003c60 <CTRL_setCtrlFreq_Hz>
  CTRL_setTrajFreq_Hz(handle,pUserParams->trajFreq_Hz);
 8005034:	683b      	ldr	r3, [r7, #0]
 8005036:	f8d3 315c 	ldr.w	r3, [r3, #348]	; 0x15c
 800503a:	6878      	ldr	r0, [r7, #4]
 800503c:	4619      	mov	r1, r3
 800503e:	f7ff f88d 	bl	800415c <CTRL_setTrajFreq_Hz>
  CTRL_setTrajPeriod_sec(handle,(1.0/pUserParams->trajFreq_Hz));
 8005042:	683b      	ldr	r3, [r7, #0]
 8005044:	f8d3 315c 	ldr.w	r3, [r3, #348]	; 0x15c
 8005048:	4618      	mov	r0, r3
 800504a:	f7fb fc9b 	bl	8000984 <__aeabi_ui2d>
 800504e:	4602      	mov	r2, r0
 8005050:	460b      	mov	r3, r1
 8005052:	f04f 0000 	mov.w	r0, #0
 8005056:	49cf      	ldr	r1, [pc, #828]	; (8005394 <CTRL_setParams+0x438>)
 8005058:	f7fb fe34 	bl	8000cc4 <__aeabi_ddiv>
 800505c:	4602      	mov	r2, r0
 800505e:	460b      	mov	r3, r1
 8005060:	4610      	mov	r0, r2
 8005062:	4619      	mov	r1, r3
 8005064:	f7fb ffbe 	bl	8000fe4 <__aeabi_d2f>
 8005068:	4603      	mov	r3, r0
 800506a:	6878      	ldr	r0, [r7, #4]
 800506c:	ee00 3a10 	vmov	s0, r3
 8005070:	f7ff f886 	bl	8004180 <CTRL_setTrajPeriod_sec>

  CTRL_setCtrlPeriod_sec(handle,pUserParams->ctrlPeriod_sec);
 8005074:	683b      	ldr	r3, [r7, #0]
 8005076:	edd3 7a58 	vldr	s15, [r3, #352]	; 0x160
 800507a:	6878      	ldr	r0, [r7, #4]
 800507c:	eeb0 0a67 	vmov.f32	s0, s15
 8005080:	f7fe fe00 	bl	8003c84 <CTRL_setCtrlPeriod_sec>

  CTRL_setMaxVsMag_pu(handle,(pUserParams->maxVsMag_pu));
 8005084:	683b      	ldr	r3, [r7, #0]
 8005086:	edd3 7a17 	vldr	s15, [r3, #92]	; 0x5c
 800508a:	6878      	ldr	r0, [r7, #4]
 800508c:	eeb0 0a67 	vmov.f32	s0, s15
 8005090:	f7fe ff88 	bl	8003fa4 <CTRL_setMaxVsMag_pu>

  CTRL_setIab_in_pu(handle,&Iab_out_pu);
 8005094:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8005098:	6878      	ldr	r0, [r7, #4]
 800509a:	4619      	mov	r1, r3
 800509c:	f7fe fe9e 	bl	8003ddc <CTRL_setIab_in_pu>
  CTRL_setIdq_in_pu(handle,&Idq_out_pu);
 80050a0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80050a4:	6878      	ldr	r0, [r7, #4]
 80050a6:	4619      	mov	r1, r3
 80050a8:	f7fe feb0 	bl	8003e0c <CTRL_setIdq_in_pu>
  CTRL_setIdq_ref_pu(handle,&Idq_ref_pu);
 80050ac:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80050b0:	6878      	ldr	r0, [r7, #4]
 80050b2:	4619      	mov	r1, r3
 80050b4:	f7fe fec2 	bl	8003e3c <CTRL_setIdq_ref_pu>

  CTRL_setIdRated_pu(handle,(pUserParams->IdRated/pUserParams->iqFullScaleCurrent_A));
 80050b8:	683b      	ldr	r3, [r7, #0]
 80050ba:	ed93 7a24 	vldr	s14, [r3, #144]	; 0x90
 80050be:	683b      	ldr	r3, [r7, #0]
 80050c0:	edd3 7a00 	vldr	s15, [r3]
 80050c4:	eec7 7a27 	vdiv.f32	s15, s14, s15
 80050c8:	6878      	ldr	r0, [r7, #4]
 80050ca:	eeb0 0a67 	vmov.f32	s0, s15
 80050ce:	f7fe fecd 	bl	8003e6c <CTRL_setIdRated_pu>

  CTRL_setVab_in_pu(handle,&Vab_in_pu);
 80050d2:	f107 031c 	add.w	r3, r7, #28
 80050d6:	6878      	ldr	r0, [r7, #4]
 80050d8:	4619      	mov	r1, r3
 80050da:	f7ff f863 	bl	80041a4 <CTRL_setVab_in_pu>
  CTRL_setVab_out_pu(handle,&Vab_out_pu);
 80050de:	f107 0314 	add.w	r3, r7, #20
 80050e2:	6878      	ldr	r0, [r7, #4]
 80050e4:	4619      	mov	r1, r3
 80050e6:	f7ff f875 	bl	80041d4 <CTRL_setVab_out_pu>
  CTRL_setVdq_out_pu(handle,&Vdq_out_pu);
 80050ea:	f107 030c 	add.w	r3, r7, #12
 80050ee:	6878      	ldr	r0, [r7, #4]
 80050f0:	4619      	mov	r1, r3
 80050f2:	f7ff f887 	bl	8004204 <CTRL_setVdq_out_pu>

  CTRL_setSpd_out_pu(handle,(0.0f));
 80050f6:	6878      	ldr	r0, [r7, #4]
 80050f8:	ed9f 0aac 	vldr	s0, [pc, #688]	; 80053ac <CTRL_setParams+0x450>
 80050fc:	f7ff f806 	bl	800410c <CTRL_setSpd_out_pu>

  CTRL_setRhf(handle,0.0f);
 8005100:	6878      	ldr	r0, [r7, #4]
 8005102:	ed9f 0aaa 	vldr	s0, [pc, #680]	; 80053ac <CTRL_setParams+0x450>
 8005106:	f7fe ffdd 	bl	80040c4 <CTRL_setRhf>
  CTRL_setLhf(handle,0.0f);
 800510a:	6878      	ldr	r0, [r7, #4]
 800510c:	ed9f 0aa7 	vldr	s0, [pc, #668]	; 80053ac <CTRL_setParams+0x450>
 8005110:	f7fe ff36 	bl	8003f80 <CTRL_setLhf>
  CTRL_setRoverL(handle,0.0f);
 8005114:	6878      	ldr	r0, [r7, #4]
 8005116:	ed9f 0aa5 	vldr	s0, [pc, #660]	; 80053ac <CTRL_setParams+0x450>
 800511a:	f7fe ffe5 	bl	80040e8 <CTRL_setRoverL>


  // reset the counters
  CTRL_resetCounter_current(handle);
 800511e:	6878      	ldr	r0, [r7, #4]
 8005120:	f7fe fd4e 	bl	8003bc0 <CTRL_resetCounter_current>
  CTRL_resetCounter_isr(handle);
 8005124:	6878      	ldr	r0, [r7, #4]
 8005126:	f7fe fd5b 	bl	8003be0 <CTRL_resetCounter_isr>
  CTRL_resetCounter_speed(handle);
 800512a:	6878      	ldr	r0, [r7, #4]
 800512c:	f7fe fd68 	bl	8003c00 <CTRL_resetCounter_speed>
  CTRL_resetCounter_state(handle);
 8005130:	6878      	ldr	r0, [r7, #4]
 8005132:	f7fe fd75 	bl	8003c20 <CTRL_resetCounter_state>
  CTRL_resetCounter_traj(handle);
 8005136:	6878      	ldr	r0, [r7, #4]
 8005138:	f7fe fd82 	bl	8003c40 <CTRL_resetCounter_traj>


  // set the wait times for each state
  CTRL_setWaitTimes(handle,&pUserParams->ctrlWaitTime[0]);
 800513c:	683b      	ldr	r3, [r7, #0]
 800513e:	33a4      	adds	r3, #164	; 0xa4
 8005140:	6878      	ldr	r0, [r7, #4]
 8005142:	4619      	mov	r1, r3
 8005144:	f000 fa76 	bl	8005634 <CTRL_setWaitTimes>


  // set flags
  CTRL_setFlag_enablePowerWarp(handle,false);
 8005148:	6878      	ldr	r0, [r7, #4]
 800514a:	2100      	movs	r1, #0
 800514c:	f7fe fdfe 	bl	8003d4c <CTRL_setFlag_enablePowerWarp>
  CTRL_setFlag_enableCtrl(handle,false);
 8005150:	6878      	ldr	r0, [r7, #4]
 8005152:	2100      	movs	r1, #0
 8005154:	f7fe fdc4 	bl	8003ce0 <CTRL_setFlag_enableCtrl>
  CTRL_setFlag_enableOffset(handle,true);
 8005158:	6878      	ldr	r0, [r7, #4]
 800515a:	2101      	movs	r1, #1
 800515c:	f7fe fe08 	bl	8003d70 <CTRL_setFlag_enableOffset>
  CTRL_setFlag_enableSpeedCtrl(handle,false);
 8005160:	6878      	ldr	r0, [r7, #4]
 8005162:	2100      	movs	r1, #0
 8005164:	f7fe fe16 	bl	8003d94 <CTRL_setFlag_enableSpeedCtrl>
  CTRL_setFlag_enableCurrentCtrl(handle,false);
 8005168:	6878      	ldr	r0, [r7, #4]
 800516a:	2100      	movs	r1, #0
 800516c:	f7fe fdca 	bl	8003d04 <CTRL_setFlag_enableCurrentCtrl>
  CTRL_setFlag_enableUserMotorParams(handle,false);
 8005170:	6878      	ldr	r0, [r7, #4]
 8005172:	2100      	movs	r1, #0
 8005174:	f7fe fe20 	bl	8003db8 <CTRL_setFlag_enableUserMotorParams>
  CTRL_setFlag_enableDcBusComp(handle,true);
 8005178:	6878      	ldr	r0, [r7, #4]
 800517a:	2101      	movs	r1, #1
 800517c:	f7fe fdd4 	bl	8003d28 <CTRL_setFlag_enableDcBusComp>


  // initialize the controller error code
  CTRL_setErrorCode(handle,CTRL_ErrorCode_NoError);
 8005180:	6878      	ldr	r0, [r7, #4]
 8005182:	2100      	movs	r1, #0
 8005184:	f7fe fd90 	bl	8003ca8 <CTRL_setErrorCode>


  // set the default controller state
  CTRL_setState(handle,CTRL_State_Idle);
 8005188:	6878      	ldr	r0, [r7, #4]
 800518a:	2101      	movs	r1, #1
 800518c:	f7fe ffd0 	bl	8004130 <CTRL_setState>


  // set the number of current sensors
  CTRL_setupClarke_I(handle,pUserParams->numCurrentSensors);
 8005190:	683b      	ldr	r3, [r7, #0]
 8005192:	7d9b      	ldrb	r3, [r3, #22]
 8005194:	6878      	ldr	r0, [r7, #4]
 8005196:	4619      	mov	r1, r3
 8005198:	f000 f9e6 	bl	8005568 <CTRL_setupClarke_I>


  // set the number of voltage sensors
  CTRL_setupClarke_V(handle,pUserParams->numVoltageSensors);
 800519c:	683b      	ldr	r3, [r7, #0]
 800519e:	7ddb      	ldrb	r3, [r3, #23]
 80051a0:	6878      	ldr	r0, [r7, #4]
 80051a2:	4619      	mov	r1, r3
 80051a4:	f000 fa18 	bl	80055d8 <CTRL_setupClarke_V>


  // set the default Id PID controller parameters
  Kp = 1.0f;//(0.1f);
 80051a8:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 80051ac:	653b      	str	r3, [r7, #80]	; 0x50
  Ki = 0.2f;//(pUserParams->ctrlPeriod_sec/0.004f);
 80051ae:	4b7a      	ldr	r3, [pc, #488]	; (8005398 <CTRL_setParams+0x43c>)
 80051b0:	64fb      	str	r3, [r7, #76]	; 0x4c
  Kd = (0.0f);
 80051b2:	f04f 0300 	mov.w	r3, #0
 80051b6:	64bb      	str	r3, [r7, #72]	; 0x48
  outMin = (-0.95f);
 80051b8:	4b78      	ldr	r3, [pc, #480]	; (800539c <CTRL_setParams+0x440>)
 80051ba:	647b      	str	r3, [r7, #68]	; 0x44
  outMax = (0.95f);
 80051bc:	4b78      	ldr	r3, [pc, #480]	; (80053a0 <CTRL_setParams+0x444>)
 80051be:	643b      	str	r3, [r7, #64]	; 0x40

  PID_setGains(obj->pidHandle_Id,Kp,Ki,Kd);
 80051c0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80051c2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80051c4:	4618      	mov	r0, r3
 80051c6:	ed97 0a14 	vldr	s0, [r7, #80]	; 0x50
 80051ca:	edd7 0a13 	vldr	s1, [r7, #76]	; 0x4c
 80051ce:	ed97 1a12 	vldr	s2, [r7, #72]	; 0x48
 80051d2:	f7fd ff23 	bl	800301c <PID_setGains>
  PID_setUi(obj->pidHandle_Id,(0.0f));
 80051d6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80051d8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80051da:	4618      	mov	r0, r3
 80051dc:	ed9f 0a73 	vldr	s0, [pc, #460]	; 80053ac <CTRL_setParams+0x450>
 80051e0:	f7fd ff72 	bl	80030c8 <PID_setUi>
  PID_setMinMax(obj->pidHandle_Id,outMin,outMax);
 80051e4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80051e6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80051e8:	4618      	mov	r0, r3
 80051ea:	ed97 0a11 	vldr	s0, [r7, #68]	; 0x44
 80051ee:	edd7 0a10 	vldr	s1, [r7, #64]	; 0x40
 80051f2:	f7fd ff53 	bl	800309c <PID_setMinMax>
  CTRL_setGains(handle,CTRL_Type_PID_Id,Kp,Ki,Kd);
 80051f6:	6878      	ldr	r0, [r7, #4]
 80051f8:	2101      	movs	r1, #1
 80051fa:	ed97 0a14 	vldr	s0, [r7, #80]	; 0x50
 80051fe:	edd7 0a13 	vldr	s1, [r7, #76]	; 0x4c
 8005202:	ed97 1a12 	vldr	s2, [r7, #72]	; 0x48
 8005206:	f7ff fdcf 	bl	8004da8 <CTRL_setGains>


  // set the default the Iq PID controller parameters
  Kp = 1.0f;//(0.1f);
 800520a:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800520e:	653b      	str	r3, [r7, #80]	; 0x50
  Ki = 0.2f;//(pUserParams->ctrlPeriod_sec/0.004f);
 8005210:	4b61      	ldr	r3, [pc, #388]	; (8005398 <CTRL_setParams+0x43c>)
 8005212:	64fb      	str	r3, [r7, #76]	; 0x4c
  Kd = (0.0f);
 8005214:	f04f 0300 	mov.w	r3, #0
 8005218:	64bb      	str	r3, [r7, #72]	; 0x48
  outMin = (-0.95f);
 800521a:	4b60      	ldr	r3, [pc, #384]	; (800539c <CTRL_setParams+0x440>)
 800521c:	647b      	str	r3, [r7, #68]	; 0x44
  outMax = (0.95f);
 800521e:	4b60      	ldr	r3, [pc, #384]	; (80053a0 <CTRL_setParams+0x444>)
 8005220:	643b      	str	r3, [r7, #64]	; 0x40

  PID_setGains(obj->pidHandle_Iq,Kp,Ki,Kd);
 8005222:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8005224:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8005226:	4618      	mov	r0, r3
 8005228:	ed97 0a14 	vldr	s0, [r7, #80]	; 0x50
 800522c:	edd7 0a13 	vldr	s1, [r7, #76]	; 0x4c
 8005230:	ed97 1a12 	vldr	s2, [r7, #72]	; 0x48
 8005234:	f7fd fef2 	bl	800301c <PID_setGains>
  PID_setUi(obj->pidHandle_Iq,(0.0f));
 8005238:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800523a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800523c:	4618      	mov	r0, r3
 800523e:	ed9f 0a5b 	vldr	s0, [pc, #364]	; 80053ac <CTRL_setParams+0x450>
 8005242:	f7fd ff41 	bl	80030c8 <PID_setUi>
  PID_setMinMax(obj->pidHandle_Iq,outMin,outMax);
 8005246:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8005248:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800524a:	4618      	mov	r0, r3
 800524c:	ed97 0a11 	vldr	s0, [r7, #68]	; 0x44
 8005250:	edd7 0a10 	vldr	s1, [r7, #64]	; 0x40
 8005254:	f7fd ff22 	bl	800309c <PID_setMinMax>
  CTRL_setGains(handle,CTRL_Type_PID_Iq,Kp,Ki,Kd);
 8005258:	6878      	ldr	r0, [r7, #4]
 800525a:	2102      	movs	r1, #2
 800525c:	ed97 0a14 	vldr	s0, [r7, #80]	; 0x50
 8005260:	edd7 0a13 	vldr	s1, [r7, #76]	; 0x4c
 8005264:	ed97 1a12 	vldr	s2, [r7, #72]	; 0x48
 8005268:	f7ff fd9e 	bl	8004da8 <CTRL_setGains>


  // set the default speed PID controller parameters
  Kp = 2.0f;//(0.02f*pUserParams->maxCurrent*pUserParams->iqFullScaleFreq_Hz/pUserParams->iqFullScaleCurrent_A);
 800526c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005270:	653b      	str	r3, [r7, #80]	; 0x50
  Ki = 0.00001f;//(2.0f*pUserParams->maxCurrent*pUserParams->iqFullScaleFreq_Hz*pUserParams->ctrlPeriod_sec/pUserParams->iqFullScaleCurrent_A);
 8005272:	4b4c      	ldr	r3, [pc, #304]	; (80053a4 <CTRL_setParams+0x448>)
 8005274:	64fb      	str	r3, [r7, #76]	; 0x4c
  Kd = (0.0f);
 8005276:	f04f 0300 	mov.w	r3, #0
 800527a:	64bb      	str	r3, [r7, #72]	; 0x48
  outMin = (-1.0f);
 800527c:	4b4a      	ldr	r3, [pc, #296]	; (80053a8 <CTRL_setParams+0x44c>)
 800527e:	647b      	str	r3, [r7, #68]	; 0x44
  outMax = (1.0f);
 8005280:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8005284:	643b      	str	r3, [r7, #64]	; 0x40

  PID_setGains(obj->pidHandle_spd,Kp,Ki,Kd);
 8005286:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8005288:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800528c:	4618      	mov	r0, r3
 800528e:	ed97 0a14 	vldr	s0, [r7, #80]	; 0x50
 8005292:	edd7 0a13 	vldr	s1, [r7, #76]	; 0x4c
 8005296:	ed97 1a12 	vldr	s2, [r7, #72]	; 0x48
 800529a:	f7fd febf 	bl	800301c <PID_setGains>
  PID_setUi(obj->pidHandle_spd,(0.0f));
 800529e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80052a0:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80052a4:	4618      	mov	r0, r3
 80052a6:	ed9f 0a41 	vldr	s0, [pc, #260]	; 80053ac <CTRL_setParams+0x450>
 80052aa:	f7fd ff0d 	bl	80030c8 <PID_setUi>
  PID_setMinMax(obj->pidHandle_spd,outMin,outMax);
 80052ae:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80052b0:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80052b4:	4618      	mov	r0, r3
 80052b6:	ed97 0a11 	vldr	s0, [r7, #68]	; 0x44
 80052ba:	edd7 0a10 	vldr	s1, [r7, #64]	; 0x40
 80052be:	f7fd feed 	bl	800309c <PID_setMinMax>
  CTRL_setGains(handle,CTRL_Type_PID_spd,Kp,Ki,Kd);
 80052c2:	6878      	ldr	r0, [r7, #4]
 80052c4:	2100      	movs	r1, #0
 80052c6:	ed97 0a14 	vldr	s0, [r7, #80]	; 0x50
 80052ca:	edd7 0a13 	vldr	s1, [r7, #76]	; 0x4c
 80052ce:	ed97 1a12 	vldr	s2, [r7, #72]	; 0x48
 80052d2:	f7ff fd69 	bl	8004da8 <CTRL_setGains>


  // set the speed reference
  CTRL_setSpd_ref_pu(handle,(0.00f));
 80052d6:	6878      	ldr	r0, [r7, #4]
 80052d8:	ed9f 0a34 	vldr	s0, [pc, #208]	; 80053ac <CTRL_setParams+0x450>
 80052dc:	f000 f932 	bl	8005544 <CTRL_setSpd_ref_pu>


  // set the default Id current trajectory module parameters
  TRAJ_setIntValue(obj->trajHandle_Id,(0.0f));
 80052e0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80052e2:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 80052e6:	4618      	mov	r0, r3
 80052e8:	ed9f 0a30 	vldr	s0, [pc, #192]	; 80053ac <CTRL_setParams+0x450>
 80052ec:	f7fd ffb8 	bl	8003260 <TRAJ_setIntValue>
  TRAJ_setTargetValue(obj->trajHandle_Id,(0.0f));
 80052f0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80052f2:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 80052f6:	4618      	mov	r0, r3
 80052f8:	ed9f 0a2c 	vldr	s0, [pc, #176]	; 80053ac <CTRL_setParams+0x450>
 80052fc:	f7fd fff8 	bl	80032f0 <TRAJ_setTargetValue>
  TRAJ_setMinValue(obj->trajHandle_Id,(0.0f));
 8005300:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8005302:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8005306:	4618      	mov	r0, r3
 8005308:	ed9f 0a28 	vldr	s0, [pc, #160]	; 80053ac <CTRL_setParams+0x450>
 800530c:	f7fd ffde 	bl	80032cc <TRAJ_setMinValue>
  TRAJ_setMaxValue(obj->trajHandle_Id,(0.0f));
 8005310:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8005312:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8005316:	4618      	mov	r0, r3
 8005318:	ed9f 0a24 	vldr	s0, [pc, #144]	; 80053ac <CTRL_setParams+0x450>
 800531c:	f7fd ffc4 	bl	80032a8 <TRAJ_setMaxValue>
  TRAJ_setMaxDelta(obj->trajHandle_Id,(0.0f));
 8005320:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8005322:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8005326:	4618      	mov	r0, r3
 8005328:	ed9f 0a20 	vldr	s0, [pc, #128]	; 80053ac <CTRL_setParams+0x450>
 800532c:	f7fd ffaa 	bl	8003284 <TRAJ_setMaxDelta>


  // set the default the speed trajectory module parameters
  TRAJ_setIntValue(obj->trajHandle_spd,(0.0f));
 8005330:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8005332:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8005336:	4618      	mov	r0, r3
 8005338:	ed9f 0a1c 	vldr	s0, [pc, #112]	; 80053ac <CTRL_setParams+0x450>
 800533c:	f7fd ff90 	bl	8003260 <TRAJ_setIntValue>
  TRAJ_setTargetValue(obj->trajHandle_spd,(0.0f));
 8005340:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8005342:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8005346:	4618      	mov	r0, r3
 8005348:	ed9f 0a18 	vldr	s0, [pc, #96]	; 80053ac <CTRL_setParams+0x450>
 800534c:	f7fd ffd0 	bl	80032f0 <TRAJ_setTargetValue>
  TRAJ_setMinValue(obj->trajHandle_spd,(0.0f));
 8005350:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8005352:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8005356:	4618      	mov	r0, r3
 8005358:	ed9f 0a14 	vldr	s0, [pc, #80]	; 80053ac <CTRL_setParams+0x450>
 800535c:	f7fd ffb6 	bl	80032cc <TRAJ_setMinValue>
  TRAJ_setMaxValue(obj->trajHandle_spd,(0.0f));
 8005360:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8005362:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8005366:	4618      	mov	r0, r3
 8005368:	ed9f 0a10 	vldr	s0, [pc, #64]	; 80053ac <CTRL_setParams+0x450>
 800536c:	f7fd ff9c 	bl	80032a8 <TRAJ_setMaxValue>
  TRAJ_setMaxDelta(obj->trajHandle_spd,(0.0f));
 8005370:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8005372:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8005376:	4618      	mov	r0, r3
 8005378:	ed9f 0a0c 	vldr	s0, [pc, #48]	; 80053ac <CTRL_setParams+0x450>
 800537c:	f7fd ff82 	bl	8003284 <TRAJ_setMaxDelta>


  // set the default maximum speed trajectory module parameters
  TRAJ_setIntValue(obj->trajHandle_spdMax,(0.0f));
 8005380:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8005382:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 8005386:	4618      	mov	r0, r3
 8005388:	ed9f 0a08 	vldr	s0, [pc, #32]	; 80053ac <CTRL_setParams+0x450>
 800538c:	f7fd ff68 	bl	8003260 <TRAJ_setIntValue>
 8005390:	e00e      	b.n	80053b0 <CTRL_setParams+0x454>
 8005392:	bf00      	nop
 8005394:	3ff00000 	.word	0x3ff00000
 8005398:	3e4ccccd 	.word	0x3e4ccccd
 800539c:	bf733333 	.word	0xbf733333
 80053a0:	3f733333 	.word	0x3f733333
 80053a4:	3727c5ac 	.word	0x3727c5ac
 80053a8:	bf800000 	.word	0xbf800000
 80053ac:	00000000 	.word	0x00000000
  TRAJ_setTargetValue(obj->trajHandle_spdMax,(0.0f));
 80053b0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80053b2:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 80053b6:	4618      	mov	r0, r3
 80053b8:	ed1f 0a04 	vldr	s0, [pc, #-16]	; 80053ac <CTRL_setParams+0x450>
 80053bc:	f7fd ff98 	bl	80032f0 <TRAJ_setTargetValue>
  TRAJ_setMinValue(obj->trajHandle_spdMax,(0.0f)); // not used
 80053c0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80053c2:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 80053c6:	4618      	mov	r0, r3
 80053c8:	ed1f 0a08 	vldr	s0, [pc, #-32]	; 80053ac <CTRL_setParams+0x450>
 80053cc:	f7fd ff7e 	bl	80032cc <TRAJ_setMinValue>
  TRAJ_setMaxValue(obj->trajHandle_spdMax,(0.0f)); // not used
 80053d0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80053d2:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 80053d6:	4618      	mov	r0, r3
 80053d8:	ed1f 0a0c 	vldr	s0, [pc, #-48]	; 80053ac <CTRL_setParams+0x450>
 80053dc:	f7fd ff64 	bl	80032a8 <TRAJ_setMaxValue>
  TRAJ_setMaxDelta(obj->trajHandle_spdMax,(0.0f)); // not used
 80053e0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80053e2:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 80053e6:	4618      	mov	r0, r3
 80053e8:	ed1f 0a10 	vldr	s0, [pc, #-64]	; 80053ac <CTRL_setParams+0x450>
 80053ec:	f7fd ff4a 	bl	8003284 <TRAJ_setMaxDelta>

  
  // set the default estimator parameters
  CTRL_setEstParams(obj->estHandle,pUserParams);
 80053f0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80053f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80053f4:	4618      	mov	r0, r3
 80053f6:	6839      	ldr	r1, [r7, #0]
 80053f8:	f7fe fc68 	bl	8003ccc <CTRL_setEstParams>


  // set the maximum modulation for the SVGEN module
  maxModulation = SVGEN_4_OVER_3;
 80053fc:	4b4e      	ldr	r3, [pc, #312]	; (8005538 <CTRL_setParams+0x5dc>)
 80053fe:	63fb      	str	r3, [r7, #60]	; 0x3c
  SVGEN_setMaxModulation(obj->svgenHandle,maxModulation);
 8005400:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8005402:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8005406:	4618      	mov	r0, r3
 8005408:	ed97 0a0f 	vldr	s0, [r7, #60]	; 0x3c
 800540c:	f7fd fefa 	bl	8003204 <SVGEN_setMaxModulation>

	obj->angle_offset_pu = 0.0f;
 8005410:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8005412:	f04f 0200 	mov.w	r2, #0
 8005416:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c

  //! \Mod By Dl.K
  RMP_CNTL_SetRampDelayMax(obj->rmpcntl_handle, 600);
 800541a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800541c:	f8d3 3224 	ldr.w	r3, [r3, #548]	; 0x224
 8005420:	4618      	mov	r0, r3
 8005422:	f44f 7116 	mov.w	r1, #600	; 0x258
 8005426:	f7fd ff75 	bl	8003314 <RMP_CNTL_SetRampDelayMax>

  RAMPGEN_SetStepAngleMax(obj->rampgen_handle,(pUserParams->ctrlPeriod_sec*pUserParams->iqFullScaleFreq_Hz));
 800542a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800542c:	f8d3 2244 	ldr.w	r2, [r3, #580]	; 0x244
 8005430:	683b      	ldr	r3, [r7, #0]
 8005432:	ed93 7a58 	vldr	s14, [r3, #352]	; 0x160
 8005436:	683b      	ldr	r3, [r7, #0]
 8005438:	edd3 7a02 	vldr	s15, [r3, #8]
 800543c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8005440:	4610      	mov	r0, r2
 8005442:	eeb0 0a67 	vmov.f32	s0, s15
 8005446:	f7fe f835 	bl	80034b4 <RAMPGEN_SetStepAngleMax>
  RAMPGEN_SetAngleOffset(obj->rampgen_handle,(0.75f));
 800544a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800544c:	f8d3 3244 	ldr.w	r3, [r3, #580]	; 0x244
 8005450:	4618      	mov	r0, r3
 8005452:	eeb6 0a08 	vmov.f32	s0, #104	; 0x68
 8005456:	f7fe f83f 	bl	80034d8 <RAMPGEN_SetAngleOffset>

	// fc100Hz=>Need:FreqRespose10HzORTimeRespose100ms:0~1.0f(800Hz)
  Speed_SetElecFilterSpeedRatio(obj->Speed_handle, ( 1.0f/(1.0f+2.0f*3.14f*100.0f*pUserParams->numCtrlTicksPerSpeedTick/pUserParams->ctrlFreq_Hz) ) );
 800545a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800545c:	f8d3 22e8 	ldr.w	r2, [r3, #744]	; 0x2e8
 8005460:	683b      	ldr	r3, [r7, #0]
 8005462:	8a5b      	ldrh	r3, [r3, #18]
 8005464:	ee07 3a90 	vmov	s15, r3
 8005468:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800546c:	ed9f 7a33 	vldr	s14, [pc, #204]	; 800553c <CTRL_setParams+0x5e0>
 8005470:	ee27 7a87 	vmul.f32	s14, s15, s14
 8005474:	683b      	ldr	r3, [r7, #0]
 8005476:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 800547a:	ee07 3a90 	vmov	s15, r3
 800547e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005482:	eec7 7a27 	vdiv.f32	s15, s14, s15
 8005486:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 800548a:	ee77 7a87 	vadd.f32	s15, s15, s14
 800548e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8005492:	eec7 7a27 	vdiv.f32	s15, s14, s15
 8005496:	4610      	mov	r0, r2
 8005498:	eeb0 0a67 	vmov.f32	s0, s15
 800549c:	f7fe f912 	bl	80036c4 <Speed_SetElecFilterSpeedRatio>
  Speed_SetElecThetaChagTimeRatio( obj->Speed_handle, ( pUserParams->ctrlFreq_Hz/( pUserParams->iqFullScaleFreq_Hz*pUserParams->numCtrlTicksPerSpeedTick) ) );
 80054a0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80054a2:	f8d3 22e8 	ldr.w	r2, [r3, #744]	; 0x2e8
 80054a6:	683b      	ldr	r3, [r7, #0]
 80054a8:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 80054ac:	ee07 3a90 	vmov	s15, r3
 80054b0:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 80054b4:	683b      	ldr	r3, [r7, #0]
 80054b6:	edd3 6a02 	vldr	s13, [r3, #8]
 80054ba:	683b      	ldr	r3, [r7, #0]
 80054bc:	8a5b      	ldrh	r3, [r3, #18]
 80054be:	ee07 3a90 	vmov	s15, r3
 80054c2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80054c6:	ee66 7aa7 	vmul.f32	s15, s13, s15
 80054ca:	eec7 7a27 	vdiv.f32	s15, s14, s15
 80054ce:	4610      	mov	r0, r2
 80054d0:	eeb0 0a67 	vmov.f32	s0, s15
 80054d4:	f7fe f908 	bl	80036e8 <Speed_SetElecThetaChagTimeRatio>

  obj->Tabc.value[0]=(0.0f);
 80054d8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80054da:	f04f 0200 	mov.w	r2, #0
 80054de:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
  obj->Tabc.value[1]=(0.0f);
 80054e2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80054e4:	f04f 0200 	mov.w	r2, #0
 80054e8:	f8c3 230c 	str.w	r2, [r3, #780]	; 0x30c
  obj->Tabc.value[2]=(0.0f);
 80054ec:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80054ee:	f04f 0200 	mov.w	r2, #0
 80054f2:	f8c3 2310 	str.w	r2, [r3, #784]	; 0x310

  obj->VdqRef.value[0]=(0.0f);
 80054f6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80054f8:	f04f 0200 	mov.w	r2, #0
 80054fc:	f8c3 2314 	str.w	r2, [r3, #788]	; 0x314
  obj->VdqRef.value[1]=(0.0f);
 8005500:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8005502:	f04f 0200 	mov.w	r2, #0
 8005506:	f8c3 2318 	str.w	r2, [r3, #792]	; 0x318

  obj->AngleRef=(-0.25f);
 800550a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800550c:	4a0c      	ldr	r2, [pc, #48]	; (8005540 <CTRL_setParams+0x5e4>)
 800550e:	f8c3 231c 	str.w	r2, [r3, #796]	; 0x31c

  obj->MntValue.value[0]=(0.0f);
 8005512:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8005514:	f04f 0200 	mov.w	r2, #0
 8005518:	f8c3 2320 	str.w	r2, [r3, #800]	; 0x320
  obj->MntValue.value[1]=(0.0f);
 800551c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800551e:	f04f 0200 	mov.w	r2, #0
 8005522:	f8c3 2324 	str.w	r2, [r3, #804]	; 0x324
  obj->MntValue.value[2]=(0.0f);
 8005526:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8005528:	f04f 0200 	mov.w	r2, #0
 800552c:	f8c3 2328 	str.w	r2, [r3, #808]	; 0x328
  //! \Mod By Dl.K

  return;
 8005530:	bf00      	nop
} // end of CTRL_setParams() function
 8005532:	3758      	adds	r7, #88	; 0x58
 8005534:	46bd      	mov	sp, r7
 8005536:	bd80      	pop	{r7, pc}
 8005538:	3faaaaab 	.word	0x3faaaaab
 800553c:	441d0000 	.word	0x441d0000
 8005540:	be800000 	.word	0xbe800000

08005544 <CTRL_setSpd_ref_pu>:


void CTRL_setSpd_ref_pu(CTRL_Handle handle,const float_t spd_ref_pu)
{
 8005544:	b480      	push	{r7}
 8005546:	b085      	sub	sp, #20
 8005548:	af00      	add	r7, sp, #0
 800554a:	6078      	str	r0, [r7, #4]
 800554c:	ed87 0a00 	vstr	s0, [r7]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8005550:	687b      	ldr	r3, [r7, #4]
 8005552:	60fb      	str	r3, [r7, #12]

  obj->spd_ref = spd_ref_pu;
 8005554:	68fb      	ldr	r3, [r7, #12]
 8005556:	683a      	ldr	r2, [r7, #0]
 8005558:	f8c3 21e4 	str.w	r2, [r3, #484]	; 0x1e4

  return;
 800555c:	bf00      	nop
} // end of CTRL_setSpd_ref_pu() function
 800555e:	3714      	adds	r7, #20
 8005560:	46bd      	mov	sp, r7
 8005562:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005566:	4770      	bx	lr

08005568 <CTRL_setupClarke_I>:
  return;
} // end of CTRL_setup() function


void CTRL_setupClarke_I(CTRL_Handle handle,uint_least8_t numCurrentSensors)
{
 8005568:	b580      	push	{r7, lr}
 800556a:	b086      	sub	sp, #24
 800556c:	af00      	add	r7, sp, #0
 800556e:	6078      	str	r0, [r7, #4]
 8005570:	460b      	mov	r3, r1
 8005572:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8005574:	687b      	ldr	r3, [r7, #4]
 8005576:	60fb      	str	r3, [r7, #12]
  float_t alpha_sf,beta_sf;
  

  // initialize the Clarke transform module for current
  if(numCurrentSensors == 3)
 8005578:	78fb      	ldrb	r3, [r7, #3]
 800557a:	2b03      	cmp	r3, #3
 800557c:	d104      	bne.n	8005588 <CTRL_setupClarke_I+0x20>
    {
      alpha_sf = (MATH_ONE_OVER_THREE);
 800557e:	4b14      	ldr	r3, [pc, #80]	; (80055d0 <CTRL_setupClarke_I+0x68>)
 8005580:	617b      	str	r3, [r7, #20]
      beta_sf = (MATH_ONE_OVER_SQRT_THREE);
 8005582:	4b14      	ldr	r3, [pc, #80]	; (80055d4 <CTRL_setupClarke_I+0x6c>)
 8005584:	613b      	str	r3, [r7, #16]
 8005586:	e00e      	b.n	80055a6 <CTRL_setupClarke_I+0x3e>
    }
  else if(numCurrentSensors == 2)
 8005588:	78fb      	ldrb	r3, [r7, #3]
 800558a:	2b02      	cmp	r3, #2
 800558c:	d105      	bne.n	800559a <CTRL_setupClarke_I+0x32>
    {
      alpha_sf = (1.0);
 800558e:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8005592:	617b      	str	r3, [r7, #20]
      beta_sf = (MATH_ONE_OVER_SQRT_THREE);
 8005594:	4b0f      	ldr	r3, [pc, #60]	; (80055d4 <CTRL_setupClarke_I+0x6c>)
 8005596:	613b      	str	r3, [r7, #16]
 8005598:	e005      	b.n	80055a6 <CTRL_setupClarke_I+0x3e>
    }
  else 
    {
      alpha_sf = (0.0);
 800559a:	f04f 0300 	mov.w	r3, #0
 800559e:	617b      	str	r3, [r7, #20]
      beta_sf = (0.0);
 80055a0:	f04f 0300 	mov.w	r3, #0
 80055a4:	613b      	str	r3, [r7, #16]
    }

  // set the parameters
  CLARKE_setScaleFactors(obj->clarkeHandle_I,alpha_sf,beta_sf);
 80055a6:	68fb      	ldr	r3, [r7, #12]
 80055a8:	68db      	ldr	r3, [r3, #12]
 80055aa:	4618      	mov	r0, r3
 80055ac:	ed97 0a05 	vldr	s0, [r7, #20]
 80055b0:	edd7 0a04 	vldr	s1, [r7, #16]
 80055b4:	f7fd fb22 	bl	8002bfc <CLARKE_setScaleFactors>
  CLARKE_setNumSensors(obj->clarkeHandle_I,numCurrentSensors);
 80055b8:	68fb      	ldr	r3, [r7, #12]
 80055ba:	68da      	ldr	r2, [r3, #12]
 80055bc:	78fb      	ldrb	r3, [r7, #3]
 80055be:	4610      	mov	r0, r2
 80055c0:	4619      	mov	r1, r3
 80055c2:	f7fd fb09 	bl	8002bd8 <CLARKE_setNumSensors>

  return;
 80055c6:	bf00      	nop
} // end of CTRL_setupClarke_I() function
 80055c8:	3718      	adds	r7, #24
 80055ca:	46bd      	mov	sp, r7
 80055cc:	bd80      	pop	{r7, pc}
 80055ce:	bf00      	nop
 80055d0:	3eaaaaab 	.word	0x3eaaaaab
 80055d4:	3f13cd3a 	.word	0x3f13cd3a

080055d8 <CTRL_setupClarke_V>:


void CTRL_setupClarke_V(CTRL_Handle handle,uint_least8_t numVoltageSensors)
{
 80055d8:	b580      	push	{r7, lr}
 80055da:	b086      	sub	sp, #24
 80055dc:	af00      	add	r7, sp, #0
 80055de:	6078      	str	r0, [r7, #4]
 80055e0:	460b      	mov	r3, r1
 80055e2:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80055e4:	687b      	ldr	r3, [r7, #4]
 80055e6:	60fb      	str	r3, [r7, #12]
  float_t alpha_sf,beta_sf;
  

  // initialize the Clarke transform module for current
  if(numVoltageSensors == 3)
 80055e8:	78fb      	ldrb	r3, [r7, #3]
 80055ea:	2b03      	cmp	r3, #3
 80055ec:	d104      	bne.n	80055f8 <CTRL_setupClarke_V+0x20>
    {
      alpha_sf = (MATH_ONE_OVER_THREE);
 80055ee:	4b0f      	ldr	r3, [pc, #60]	; (800562c <CTRL_setupClarke_V+0x54>)
 80055f0:	617b      	str	r3, [r7, #20]
      beta_sf = (MATH_ONE_OVER_SQRT_THREE);
 80055f2:	4b0f      	ldr	r3, [pc, #60]	; (8005630 <CTRL_setupClarke_V+0x58>)
 80055f4:	613b      	str	r3, [r7, #16]
 80055f6:	e005      	b.n	8005604 <CTRL_setupClarke_V+0x2c>
    }
 else 
    {
      alpha_sf = (0.0);
 80055f8:	f04f 0300 	mov.w	r3, #0
 80055fc:	617b      	str	r3, [r7, #20]
      beta_sf = (0.0);
 80055fe:	f04f 0300 	mov.w	r3, #0
 8005602:	613b      	str	r3, [r7, #16]
    }

  // set the parameters
  CLARKE_setScaleFactors(obj->clarkeHandle_V,alpha_sf,beta_sf);
 8005604:	68fb      	ldr	r3, [r7, #12]
 8005606:	69db      	ldr	r3, [r3, #28]
 8005608:	4618      	mov	r0, r3
 800560a:	ed97 0a05 	vldr	s0, [r7, #20]
 800560e:	edd7 0a04 	vldr	s1, [r7, #16]
 8005612:	f7fd faf3 	bl	8002bfc <CLARKE_setScaleFactors>
  CLARKE_setNumSensors(obj->clarkeHandle_V,numVoltageSensors);
 8005616:	68fb      	ldr	r3, [r7, #12]
 8005618:	69da      	ldr	r2, [r3, #28]
 800561a:	78fb      	ldrb	r3, [r7, #3]
 800561c:	4610      	mov	r0, r2
 800561e:	4619      	mov	r1, r3
 8005620:	f7fd fada 	bl	8002bd8 <CLARKE_setNumSensors>

  return;
 8005624:	bf00      	nop
} // end of CTRL_setupClarke_V() function
 8005626:	3718      	adds	r7, #24
 8005628:	46bd      	mov	sp, r7
 800562a:	bd80      	pop	{r7, pc}
 800562c:	3eaaaaab 	.word	0x3eaaaaab
 8005630:	3f13cd3a 	.word	0x3f13cd3a

08005634 <CTRL_setWaitTimes>:
  return;
} // end of CTRL_setup_user() function


void CTRL_setWaitTimes(CTRL_Handle handle,const uint_least32_t *pWaitTimes)
{
 8005634:	b480      	push	{r7}
 8005636:	b085      	sub	sp, #20
 8005638:	af00      	add	r7, sp, #0
 800563a:	6078      	str	r0, [r7, #4]
 800563c:	6039      	str	r1, [r7, #0]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 800563e:	687b      	ldr	r3, [r7, #4]
 8005640:	60bb      	str	r3, [r7, #8]
  uint_least16_t stateCnt;

  for(stateCnt=0;stateCnt<CTRL_numStates;stateCnt++)
 8005642:	2300      	movs	r3, #0
 8005644:	81fb      	strh	r3, [r7, #14]
 8005646:	e00c      	b.n	8005662 <CTRL_setWaitTimes+0x2e>
    {
      obj->waitTimes[stateCnt] = pWaitTimes[stateCnt];
 8005648:	89fa      	ldrh	r2, [r7, #14]
 800564a:	89fb      	ldrh	r3, [r7, #14]
 800564c:	009b      	lsls	r3, r3, #2
 800564e:	6839      	ldr	r1, [r7, #0]
 8005650:	440b      	add	r3, r1
 8005652:	6819      	ldr	r1, [r3, #0]
 8005654:	68bb      	ldr	r3, [r7, #8]
 8005656:	3248      	adds	r2, #72	; 0x48
 8005658:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
void CTRL_setWaitTimes(CTRL_Handle handle,const uint_least32_t *pWaitTimes)
{
  CTRL_Obj *obj = (CTRL_Obj *)handle;
  uint_least16_t stateCnt;

  for(stateCnt=0;stateCnt<CTRL_numStates;stateCnt++)
 800565c:	89fb      	ldrh	r3, [r7, #14]
 800565e:	3301      	adds	r3, #1
 8005660:	81fb      	strh	r3, [r7, #14]
 8005662:	89fb      	ldrh	r3, [r7, #14]
 8005664:	2b09      	cmp	r3, #9
 8005666:	d9ef      	bls.n	8005648 <CTRL_setWaitTimes+0x14>
    {
      obj->waitTimes[stateCnt] = pWaitTimes[stateCnt];
    }

  return;
 8005668:	bf00      	nop
} // end of CTRL_setWaitTimes() function
 800566a:	3714      	adds	r7, #20
 800566c:	46bd      	mov	sp, r7
 800566e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005672:	4770      	bx	lr

08005674 <DATA_RTXD_Init>:
-------------------------------------------------------------------------------------*/

#include "modules/data_rtxd/data_rtxd.h"

DATA_RTXD_Handle DATA_RTXD_Init(void *pMemory, const size_t numBytes)
{
 8005674:	b480      	push	{r7}
 8005676:	b085      	sub	sp, #20
 8005678:	af00      	add	r7, sp, #0
 800567a:	6078      	str	r0, [r7, #4]
 800567c:	6039      	str	r1, [r7, #0]
	DATA_RTXD_Handle handle;
	uint8_t i;

	if (numBytes < sizeof(DATA_RTXD_Obj))
 800567e:	683b      	ldr	r3, [r7, #0]
 8005680:	2b1d      	cmp	r3, #29
 8005682:	d801      	bhi.n	8005688 <DATA_RTXD_Init+0x14>
		return((DATA_RTXD_Handle)NULL);
 8005684:	2300      	movs	r3, #0
 8005686:	e027      	b.n	80056d8 <DATA_RTXD_Init+0x64>

	// assign the handle
	handle = (DATA_RTXD_Handle)pMemory;
 8005688:	687b      	ldr	r3, [r7, #4]
 800568a:	60bb      	str	r3, [r7, #8]

	handle->data_rxd_num = 0;
 800568c:	68bb      	ldr	r3, [r7, #8]
 800568e:	2200      	movs	r2, #0
 8005690:	701a      	strb	r2, [r3, #0]
	for (i = 0; i<DATA_RXD_SIZE; i++)
 8005692:	2300      	movs	r3, #0
 8005694:	73fb      	strb	r3, [r7, #15]
 8005696:	e007      	b.n	80056a8 <DATA_RTXD_Init+0x34>
	{
		handle->data_rxd[i] = 0;
 8005698:	7bfb      	ldrb	r3, [r7, #15]
 800569a:	68ba      	ldr	r2, [r7, #8]
 800569c:	4413      	add	r3, r2
 800569e:	2200      	movs	r2, #0
 80056a0:	705a      	strb	r2, [r3, #1]

	// assign the handle
	handle = (DATA_RTXD_Handle)pMemory;

	handle->data_rxd_num = 0;
	for (i = 0; i<DATA_RXD_SIZE; i++)
 80056a2:	7bfb      	ldrb	r3, [r7, #15]
 80056a4:	3301      	adds	r3, #1
 80056a6:	73fb      	strb	r3, [r7, #15]
 80056a8:	7bfb      	ldrb	r3, [r7, #15]
 80056aa:	2b0c      	cmp	r3, #12
 80056ac:	d9f4      	bls.n	8005698 <DATA_RTXD_Init+0x24>
	{
		handle->data_rxd[i] = 0;
	}

	handle->data_txd_num = DATA_TXD_SIZE;
 80056ae:	68bb      	ldr	r3, [r7, #8]
 80056b0:	220d      	movs	r2, #13
 80056b2:	739a      	strb	r2, [r3, #14]
	for (i = 0; i<DATA_TXD_SIZE; i++)
 80056b4:	2300      	movs	r3, #0
 80056b6:	73fb      	strb	r3, [r7, #15]
 80056b8:	e007      	b.n	80056ca <DATA_RTXD_Init+0x56>
	{
		handle->data_txd[i] = 0;
 80056ba:	7bfb      	ldrb	r3, [r7, #15]
 80056bc:	68ba      	ldr	r2, [r7, #8]
 80056be:	4413      	add	r3, r2
 80056c0:	2200      	movs	r2, #0
 80056c2:	73da      	strb	r2, [r3, #15]
	{
		handle->data_rxd[i] = 0;
	}

	handle->data_txd_num = DATA_TXD_SIZE;
	for (i = 0; i<DATA_TXD_SIZE; i++)
 80056c4:	7bfb      	ldrb	r3, [r7, #15]
 80056c6:	3301      	adds	r3, #1
 80056c8:	73fb      	strb	r3, [r7, #15]
 80056ca:	7bfb      	ldrb	r3, [r7, #15]
 80056cc:	2b0c      	cmp	r3, #12
 80056ce:	d9f4      	bls.n	80056ba <DATA_RTXD_Init+0x46>
	{
		handle->data_txd[i] = 0;
	}

	handle->time = 0;
 80056d0:	68bb      	ldr	r3, [r7, #8]
 80056d2:	2200      	movs	r2, #0
 80056d4:	839a      	strh	r2, [r3, #28]

	return(handle);
 80056d6:	68bb      	ldr	r3, [r7, #8]

}
 80056d8:	4618      	mov	r0, r3
 80056da:	3714      	adds	r7, #20
 80056dc:	46bd      	mov	sp, r7
 80056de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80056e2:	4770      	bx	lr

080056e4 <Reset_DATA_RXD>:
// the functions

extern DATA_RTXD_Handle DATA_RTXD_Init(void *pMemory, const size_t numBytes);

static inline void Reset_DATA_RXD(DATA_RTXD_Handle handle)
{
 80056e4:	b480      	push	{r7}
 80056e6:	b085      	sub	sp, #20
 80056e8:	af00      	add	r7, sp, #0
 80056ea:	6078      	str	r0, [r7, #4]
	DATA_RTXD_Obj *obj = (DATA_RTXD_Obj *)handle;
 80056ec:	687b      	ldr	r3, [r7, #4]
 80056ee:	60fb      	str	r3, [r7, #12]

	obj->data_rxd_num = 0;
 80056f0:	68fb      	ldr	r3, [r7, #12]
 80056f2:	2200      	movs	r2, #0
 80056f4:	701a      	strb	r2, [r3, #0]
	
	return;
 80056f6:	bf00      	nop
}
 80056f8:	3714      	adds	r7, #20
 80056fa:	46bd      	mov	sp, r7
 80056fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005700:	4770      	bx	lr
 8005702:	bf00      	nop

08005704 <Reset_DATA_TXD>:

static inline void Reset_DATA_TXD(DATA_RTXD_Handle handle)
{
 8005704:	b480      	push	{r7}
 8005706:	b085      	sub	sp, #20
 8005708:	af00      	add	r7, sp, #0
 800570a:	6078      	str	r0, [r7, #4]
	DATA_RTXD_Obj *obj = (DATA_RTXD_Obj *)handle;
 800570c:	687b      	ldr	r3, [r7, #4]
 800570e:	60fb      	str	r3, [r7, #12]

	obj->data_txd_num = 0;
 8005710:	68fb      	ldr	r3, [r7, #12]
 8005712:	2200      	movs	r2, #0
 8005714:	739a      	strb	r2, [r3, #14]
	
	return;
 8005716:	bf00      	nop
}
 8005718:	3714      	adds	r7, #20
 800571a:	46bd      	mov	sp, r7
 800571c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005720:	4770      	bx	lr
 8005722:	bf00      	nop

08005724 <DATA_RXD_Status>:

static inline uint8_t DATA_RXD_Status(DATA_RTXD_Handle handle)
{
 8005724:	b480      	push	{r7}
 8005726:	b085      	sub	sp, #20
 8005728:	af00      	add	r7, sp, #0
 800572a:	6078      	str	r0, [r7, #4]
	DATA_RTXD_Obj *obj = (DATA_RTXD_Obj *)handle;
 800572c:	687b      	ldr	r3, [r7, #4]
 800572e:	60fb      	str	r3, [r7, #12]

	if( obj->data_rxd_num == DATA_RXD_SIZE )
 8005730:	68fb      	ldr	r3, [r7, #12]
 8005732:	781b      	ldrb	r3, [r3, #0]
 8005734:	2b0d      	cmp	r3, #13
 8005736:	d101      	bne.n	800573c <DATA_RXD_Status+0x18>
	{
		return false;
 8005738:	2300      	movs	r3, #0
 800573a:	e000      	b.n	800573e <DATA_RXD_Status+0x1a>
	}
	else return true;
 800573c:	2301      	movs	r3, #1
}
 800573e:	4618      	mov	r0, r3
 8005740:	3714      	adds	r7, #20
 8005742:	46bd      	mov	sp, r7
 8005744:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005748:	4770      	bx	lr
 800574a:	bf00      	nop

0800574c <DATA_Select>:
}DATA_e;

// **************************************************************************
// the functions
static inline int16_t DATA_Select(CTRL_Handle handle, HAL_Handle halHandle, const HAL_AdcData_t *pAdcData, const HAL_QepData_t *pQepData, DATA_e data_e)
{
 800574c:	b480      	push	{r7}
 800574e:	b08b      	sub	sp, #44	; 0x2c
 8005750:	af00      	add	r7, sp, #0
 8005752:	6178      	str	r0, [r7, #20]
 8005754:	6139      	str	r1, [r7, #16]
 8005756:	60fa      	str	r2, [r7, #12]
 8005758:	60bb      	str	r3, [r7, #8]
	CTRL_Obj *obj = (CTRL_Obj *)handle;
 800575a:	697b      	ldr	r3, [r7, #20]
 800575c:	623b      	str	r3, [r7, #32]
	OFFSET_Obj *offset_obj = (OFFSET_Obj *)(halHandle->offsetHandle_I[0]);
 800575e:	693b      	ldr	r3, [r7, #16]
 8005760:	681b      	ldr	r3, [r3, #0]
 8005762:	61fb      	str	r3, [r7, #28]
	int16_t value;

	switch(data_e)
 8005764:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8005768:	3b01      	subs	r3, #1
 800576a:	2b35      	cmp	r3, #53	; 0x35
 800576c:	f200 81ee 	bhi.w	8005b4c <DATA_Select+0x400>
 8005770:	a201      	add	r2, pc, #4	; (adr r2, 8005778 <DATA_Select+0x2c>)
 8005772:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005776:	bf00      	nop
 8005778:	08005851 	.word	0x08005851
 800577c:	0800586d 	.word	0x0800586d
 8005780:	08005889 	.word	0x08005889
 8005784:	080058a5 	.word	0x080058a5
 8005788:	080058c1 	.word	0x080058c1
 800578c:	080058dd 	.word	0x080058dd
 8005790:	080058f9 	.word	0x080058f9
 8005794:	08005915 	.word	0x08005915
 8005798:	08005b4d 	.word	0x08005b4d
 800579c:	08005b4d 	.word	0x08005b4d
 80057a0:	08005931 	.word	0x08005931
 80057a4:	0800594d 	.word	0x0800594d
 80057a8:	08005969 	.word	0x08005969
 80057ac:	08005985 	.word	0x08005985
 80057b0:	080059a1 	.word	0x080059a1
 80057b4:	080059bd 	.word	0x080059bd
 80057b8:	080059c3 	.word	0x080059c3
 80057bc:	080059c9 	.word	0x080059c9
 80057c0:	08005b4d 	.word	0x08005b4d
 80057c4:	08005b4d 	.word	0x08005b4d
 80057c8:	080059e5 	.word	0x080059e5
 80057cc:	08005a01 	.word	0x08005a01
 80057d0:	08005a2d 	.word	0x08005a2d
 80057d4:	08005a4d 	.word	0x08005a4d
 80057d8:	08005b4d 	.word	0x08005b4d
 80057dc:	08005b4d 	.word	0x08005b4d
 80057e0:	08005b4d 	.word	0x08005b4d
 80057e4:	08005b4d 	.word	0x08005b4d
 80057e8:	08005b4d 	.word	0x08005b4d
 80057ec:	08005b4d 	.word	0x08005b4d
 80057f0:	08005a6d 	.word	0x08005a6d
 80057f4:	08005b4d 	.word	0x08005b4d
 80057f8:	08005b4d 	.word	0x08005b4d
 80057fc:	08005b4d 	.word	0x08005b4d
 8005800:	08005b4d 	.word	0x08005b4d
 8005804:	08005b4d 	.word	0x08005b4d
 8005808:	08005b4d 	.word	0x08005b4d
 800580c:	08005b4d 	.word	0x08005b4d
 8005810:	08005b4d 	.word	0x08005b4d
 8005814:	08005b4d 	.word	0x08005b4d
 8005818:	08005a89 	.word	0x08005a89
 800581c:	08005aa5 	.word	0x08005aa5
 8005820:	08005ac1 	.word	0x08005ac1
 8005824:	08005b4d 	.word	0x08005b4d
 8005828:	08005b4d 	.word	0x08005b4d
 800582c:	08005b4d 	.word	0x08005b4d
 8005830:	08005b4d 	.word	0x08005b4d
 8005834:	08005b4d 	.word	0x08005b4d
 8005838:	08005b4d 	.word	0x08005b4d
 800583c:	08005b4d 	.word	0x08005b4d
 8005840:	08005add 	.word	0x08005add
 8005844:	08005af9 	.word	0x08005af9
 8005848:	08005b15 	.word	0x08005b15
 800584c:	08005b31 	.word	0x08005b31
	{
		case IA_DATA:
			value = 32768.0f*(pAdcData->I.value[0]);
 8005850:	68fb      	ldr	r3, [r7, #12]
 8005852:	edd3 7a00 	vldr	s15, [r3]
 8005856:	ed9f 7ac2 	vldr	s14, [pc, #776]	; 8005b60 <DATA_Select+0x414>
 800585a:	ee67 7a87 	vmul.f32	s15, s15, s14
 800585e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005862:	edc7 7a01 	vstr	s15, [r7, #4]
 8005866:	88bb      	ldrh	r3, [r7, #4]
 8005868:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 800586a:	e170      	b.n	8005b4e <DATA_Select+0x402>
		case IB_DATA:
			value = 32768.0f*(pAdcData->I.value[1]);
 800586c:	68fb      	ldr	r3, [r7, #12]
 800586e:	edd3 7a01 	vldr	s15, [r3, #4]
 8005872:	ed9f 7abb 	vldr	s14, [pc, #748]	; 8005b60 <DATA_Select+0x414>
 8005876:	ee67 7a87 	vmul.f32	s15, s15, s14
 800587a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800587e:	edc7 7a01 	vstr	s15, [r7, #4]
 8005882:	88bb      	ldrh	r3, [r7, #4]
 8005884:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005886:	e162      	b.n	8005b4e <DATA_Select+0x402>
		case IC_DATA:
			value = 32768.0f*(pAdcData->I.value[2]);
 8005888:	68fb      	ldr	r3, [r7, #12]
 800588a:	edd3 7a02 	vldr	s15, [r3, #8]
 800588e:	ed9f 7ab4 	vldr	s14, [pc, #720]	; 8005b60 <DATA_Select+0x414>
 8005892:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005896:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800589a:	edc7 7a01 	vstr	s15, [r7, #4]
 800589e:	88bb      	ldrh	r3, [r7, #4]
 80058a0:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 80058a2:	e154      	b.n	8005b4e <DATA_Select+0x402>
		case IALPHA_DATA:
			value = 32768.0f*(obj->Iab_in.value[0]);
 80058a4:	6a3b      	ldr	r3, [r7, #32]
 80058a6:	edd3 7a5a 	vldr	s15, [r3, #360]	; 0x168
 80058aa:	ed9f 7aad 	vldr	s14, [pc, #692]	; 8005b60 <DATA_Select+0x414>
 80058ae:	ee67 7a87 	vmul.f32	s15, s15, s14
 80058b2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80058b6:	edc7 7a01 	vstr	s15, [r7, #4]
 80058ba:	88bb      	ldrh	r3, [r7, #4]
 80058bc:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 80058be:	e146      	b.n	8005b4e <DATA_Select+0x402>
		case IBETA_DATA:
			value = 32768.0f*(obj->Iab_in.value[1]);
 80058c0:	6a3b      	ldr	r3, [r7, #32]
 80058c2:	edd3 7a5b 	vldr	s15, [r3, #364]	; 0x16c
 80058c6:	ed9f 7aa6 	vldr	s14, [pc, #664]	; 8005b60 <DATA_Select+0x414>
 80058ca:	ee67 7a87 	vmul.f32	s15, s15, s14
 80058ce:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80058d2:	edc7 7a01 	vstr	s15, [r7, #4]
 80058d6:	88bb      	ldrh	r3, [r7, #4]
 80058d8:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 80058da:	e138      	b.n	8005b4e <DATA_Select+0x402>
		case ID_DATA:
			value = 32768.0f*(obj->Idq_in.value[0]);
 80058dc:	6a3b      	ldr	r3, [r7, #32]
 80058de:	edd3 7a5e 	vldr	s15, [r3, #376]	; 0x178
 80058e2:	ed9f 7a9f 	vldr	s14, [pc, #636]	; 8005b60 <DATA_Select+0x414>
 80058e6:	ee67 7a87 	vmul.f32	s15, s15, s14
 80058ea:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80058ee:	edc7 7a01 	vstr	s15, [r7, #4]
 80058f2:	88bb      	ldrh	r3, [r7, #4]
 80058f4:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 80058f6:	e12a      	b.n	8005b4e <DATA_Select+0x402>
		case IQ_DATA:
			value = 32768.0f*(obj->Idq_in.value[1]);
 80058f8:	6a3b      	ldr	r3, [r7, #32]
 80058fa:	edd3 7a5f 	vldr	s15, [r3, #380]	; 0x17c
 80058fe:	ed9f 7a98 	vldr	s14, [pc, #608]	; 8005b60 <DATA_Select+0x414>
 8005902:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005906:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800590a:	edc7 7a01 	vstr	s15, [r7, #4]
 800590e:	88bb      	ldrh	r3, [r7, #4]
 8005910:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005912:	e11c      	b.n	8005b4e <DATA_Select+0x402>
		case IDC_DATA:
			value = 32768.0f*(pAdcData->IdcBus);
 8005914:	68fb      	ldr	r3, [r7, #12]
 8005916:	edd3 7a07 	vldr	s15, [r3, #28]
 800591a:	ed9f 7a91 	vldr	s14, [pc, #580]	; 8005b60 <DATA_Select+0x414>
 800591e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005922:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005926:	edc7 7a01 	vstr	s15, [r7, #4]
 800592a:	88bb      	ldrh	r3, [r7, #4]
 800592c:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 800592e:	e10e      	b.n	8005b4e <DATA_Select+0x402>

		case VA_DATA:
			value = 32768.0f*(pAdcData->V.value[0]);
 8005930:	68fb      	ldr	r3, [r7, #12]
 8005932:	edd3 7a03 	vldr	s15, [r3, #12]
 8005936:	ed9f 7a8a 	vldr	s14, [pc, #552]	; 8005b60 <DATA_Select+0x414>
 800593a:	ee67 7a87 	vmul.f32	s15, s15, s14
 800593e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005942:	edc7 7a01 	vstr	s15, [r7, #4]
 8005946:	88bb      	ldrh	r3, [r7, #4]
 8005948:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 800594a:	e100      	b.n	8005b4e <DATA_Select+0x402>
		case VB_DATA:
			value = 32768.0f*(pAdcData->V.value[1]);
 800594c:	68fb      	ldr	r3, [r7, #12]
 800594e:	edd3 7a04 	vldr	s15, [r3, #16]
 8005952:	ed9f 7a83 	vldr	s14, [pc, #524]	; 8005b60 <DATA_Select+0x414>
 8005956:	ee67 7a87 	vmul.f32	s15, s15, s14
 800595a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800595e:	edc7 7a01 	vstr	s15, [r7, #4]
 8005962:	88bb      	ldrh	r3, [r7, #4]
 8005964:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005966:	e0f2      	b.n	8005b4e <DATA_Select+0x402>
		case VC_DATA:
			value = 32768.0f*(pAdcData->V.value[2]);
 8005968:	68fb      	ldr	r3, [r7, #12]
 800596a:	edd3 7a05 	vldr	s15, [r3, #20]
 800596e:	ed9f 7a7c 	vldr	s14, [pc, #496]	; 8005b60 <DATA_Select+0x414>
 8005972:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005976:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800597a:	edc7 7a01 	vstr	s15, [r7, #4]
 800597e:	88bb      	ldrh	r3, [r7, #4]
 8005980:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005982:	e0e4      	b.n	8005b4e <DATA_Select+0x402>
		case VALPHA_DATA:
			value = 32768.0f*(obj->Vab_in.value[0]);
 8005984:	6a3b      	ldr	r3, [r7, #32]
 8005986:	edd3 7a60 	vldr	s15, [r3, #384]	; 0x180
 800598a:	ed9f 7a75 	vldr	s14, [pc, #468]	; 8005b60 <DATA_Select+0x414>
 800598e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005992:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005996:	edc7 7a01 	vstr	s15, [r7, #4]
 800599a:	88bb      	ldrh	r3, [r7, #4]
 800599c:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 800599e:	e0d6      	b.n	8005b4e <DATA_Select+0x402>
		case VBETA_DATA:
			value = 32768.0f*(obj->Vab_in.value[1]);
 80059a0:	6a3b      	ldr	r3, [r7, #32]
 80059a2:	edd3 7a61 	vldr	s15, [r3, #388]	; 0x184
 80059a6:	ed9f 7a6e 	vldr	s14, [pc, #440]	; 8005b60 <DATA_Select+0x414>
 80059aa:	ee67 7a87 	vmul.f32	s15, s15, s14
 80059ae:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80059b2:	edc7 7a01 	vstr	s15, [r7, #4]
 80059b6:	88bb      	ldrh	r3, [r7, #4]
 80059b8:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 80059ba:	e0c8      	b.n	8005b4e <DATA_Select+0x402>
		case VD_DATA:
			value = 4;
 80059bc:	2304      	movs	r3, #4
 80059be:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 80059c0:	e0c5      	b.n	8005b4e <DATA_Select+0x402>
		case VQ_DATA:
			value = 5;
 80059c2:	2305      	movs	r3, #5
 80059c4:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 80059c6:	e0c2      	b.n	8005b4e <DATA_Select+0x402>
		case VDC_DATA:
			value = 32768.0f*(pAdcData->VdcBus);
 80059c8:	68fb      	ldr	r3, [r7, #12]
 80059ca:	edd3 7a06 	vldr	s15, [r3, #24]
 80059ce:	ed9f 7a64 	vldr	s14, [pc, #400]	; 8005b60 <DATA_Select+0x414>
 80059d2:	ee67 7a87 	vmul.f32	s15, s15, s14
 80059d6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80059da:	edc7 7a01 	vstr	s15, [r7, #4]
 80059de:	88bb      	ldrh	r3, [r7, #4]
 80059e0:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 80059e2:	e0b4      	b.n	8005b4e <DATA_Select+0x402>

		case QEP_DATA:
			value = 32768.0f*pQepData->qep_cnt;
 80059e4:	68bb      	ldr	r3, [r7, #8]
 80059e6:	edd3 7a00 	vldr	s15, [r3]
 80059ea:	ed9f 7a5d 	vldr	s14, [pc, #372]	; 8005b60 <DATA_Select+0x414>
 80059ee:	ee67 7a87 	vmul.f32	s15, s15, s14
 80059f2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80059f6:	edc7 7a01 	vstr	s15, [r7, #4]
 80059fa:	88bb      	ldrh	r3, [r7, #4]
 80059fc:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 80059fe:	e0a6      	b.n	8005b4e <DATA_Select+0x402>

		case ANGLE_DATA:
			value = 32768.0f*pQepData->qep_cnt*USER_MOTOR_NUM_POLE_PAIRS;
 8005a00:	68bb      	ldr	r3, [r7, #8]
 8005a02:	edd3 7a00 	vldr	s15, [r3]
 8005a06:	ed9f 7a56 	vldr	s14, [pc, #344]	; 8005b60 <DATA_Select+0x414>
 8005a0a:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005a0e:	eeb1 7a00 	vmov.f32	s14, #16
 8005a12:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005a16:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005a1a:	edc7 7a01 	vstr	s15, [r7, #4]
 8005a1e:	88bb      	ldrh	r3, [r7, #4]
 8005a20:	84fb      	strh	r3, [r7, #38]	; 0x26
			value &= 0x7FFF;
 8005a22:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8005a24:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8005a28:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005a2a:	e090      	b.n	8005b4e <DATA_Select+0x402>

		case SPEED_DATA:
			value = 32768.0f*(obj->Speed_handle->ElecSpeed);;
 8005a2c:	6a3b      	ldr	r3, [r7, #32]
 8005a2e:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 8005a32:	edd3 7a03 	vldr	s15, [r3, #12]
 8005a36:	ed9f 7a4a 	vldr	s14, [pc, #296]	; 8005b60 <DATA_Select+0x414>
 8005a3a:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005a3e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005a42:	edc7 7a01 	vstr	s15, [r7, #4]
 8005a46:	88bb      	ldrh	r3, [r7, #4]
 8005a48:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005a4a:	e080      	b.n	8005b4e <DATA_Select+0x402>

		case FILTER_SPEED_DATA:
			value = 32768.0f*(obj->Speed_handle->ElecFilterSpeed);;
 8005a4c:	6a3b      	ldr	r3, [r7, #32]
 8005a4e:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 8005a52:	edd3 7a06 	vldr	s15, [r3, #24]
 8005a56:	ed9f 7a42 	vldr	s14, [pc, #264]	; 8005b60 <DATA_Select+0x414>
 8005a5a:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005a5e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005a62:	edc7 7a01 	vstr	s15, [r7, #4]
 8005a66:	88bb      	ldrh	r3, [r7, #4]
 8005a68:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005a6a:	e070      	b.n	8005b4e <DATA_Select+0x402>

		case IA_OFFSET_DATA:
			value = 32768.0f*(offset_obj->value);
 8005a6c:	69fb      	ldr	r3, [r7, #28]
 8005a6e:	edd3 7a00 	vldr	s15, [r3]
 8005a72:	ed9f 7a3b 	vldr	s14, [pc, #236]	; 8005b60 <DATA_Select+0x414>
 8005a76:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005a7a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005a7e:	edc7 7a01 	vstr	s15, [r7, #4]
 8005a82:	88bb      	ldrh	r3, [r7, #4]
 8005a84:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005a86:	e062      	b.n	8005b4e <DATA_Select+0x402>

		case TA_DATA:
			value = 32768.0f*(obj->Tabc.value[0]);
 8005a88:	6a3b      	ldr	r3, [r7, #32]
 8005a8a:	edd3 7ac2 	vldr	s15, [r3, #776]	; 0x308
 8005a8e:	ed9f 7a34 	vldr	s14, [pc, #208]	; 8005b60 <DATA_Select+0x414>
 8005a92:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005a96:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005a9a:	edc7 7a01 	vstr	s15, [r7, #4]
 8005a9e:	88bb      	ldrh	r3, [r7, #4]
 8005aa0:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005aa2:	e054      	b.n	8005b4e <DATA_Select+0x402>

		case TB_DATA:
			value = 32768.0f*(obj->Tabc.value[1]);
 8005aa4:	6a3b      	ldr	r3, [r7, #32]
 8005aa6:	edd3 7ac3 	vldr	s15, [r3, #780]	; 0x30c
 8005aaa:	ed9f 7a2d 	vldr	s14, [pc, #180]	; 8005b60 <DATA_Select+0x414>
 8005aae:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005ab2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005ab6:	edc7 7a01 	vstr	s15, [r7, #4]
 8005aba:	88bb      	ldrh	r3, [r7, #4]
 8005abc:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005abe:	e046      	b.n	8005b4e <DATA_Select+0x402>

		case TC_DATA:
			value = 32768.0f*(obj->Tabc.value[2]);
 8005ac0:	6a3b      	ldr	r3, [r7, #32]
 8005ac2:	edd3 7ac4 	vldr	s15, [r3, #784]	; 0x310
 8005ac6:	ed9f 7a26 	vldr	s14, [pc, #152]	; 8005b60 <DATA_Select+0x414>
 8005aca:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005ace:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005ad2:	edc7 7a01 	vstr	s15, [r7, #4]
 8005ad6:	88bb      	ldrh	r3, [r7, #4]
 8005ad8:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005ada:	e038      	b.n	8005b4e <DATA_Select+0x402>

		case MNT_VALUE_1_DATA:
			value = 32768.0f*(obj->MntValue.value[0]);
 8005adc:	6a3b      	ldr	r3, [r7, #32]
 8005ade:	edd3 7ac8 	vldr	s15, [r3, #800]	; 0x320
 8005ae2:	ed9f 7a1f 	vldr	s14, [pc, #124]	; 8005b60 <DATA_Select+0x414>
 8005ae6:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005aea:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005aee:	edc7 7a01 	vstr	s15, [r7, #4]
 8005af2:	88bb      	ldrh	r3, [r7, #4]
 8005af4:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005af6:	e02a      	b.n	8005b4e <DATA_Select+0x402>

		case MNT_VALUE_2_DATA:
			value = 32768.0f*(obj->MntValue.value[1]);
 8005af8:	6a3b      	ldr	r3, [r7, #32]
 8005afa:	edd3 7ac9 	vldr	s15, [r3, #804]	; 0x324
 8005afe:	ed9f 7a18 	vldr	s14, [pc, #96]	; 8005b60 <DATA_Select+0x414>
 8005b02:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005b06:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005b0a:	edc7 7a01 	vstr	s15, [r7, #4]
 8005b0e:	88bb      	ldrh	r3, [r7, #4]
 8005b10:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005b12:	e01c      	b.n	8005b4e <DATA_Select+0x402>

		case MNT_VALUE_3_DATA:
			value = 32768.0f*(obj->MntValue.value[2]);
 8005b14:	6a3b      	ldr	r3, [r7, #32]
 8005b16:	edd3 7aca 	vldr	s15, [r3, #808]	; 0x328
 8005b1a:	ed9f 7a11 	vldr	s14, [pc, #68]	; 8005b60 <DATA_Select+0x414>
 8005b1e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005b22:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005b26:	edc7 7a01 	vstr	s15, [r7, #4]
 8005b2a:	88bb      	ldrh	r3, [r7, #4]
 8005b2c:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005b2e:	e00e      	b.n	8005b4e <DATA_Select+0x402>

		case MNT_VALUE_4_DATA:
			value = 32768.0f*(obj->InitPosDet.IdEvgTmp);
 8005b30:	6a3b      	ldr	r3, [r7, #32]
 8005b32:	edd3 7ab9 	vldr	s15, [r3, #740]	; 0x2e4
 8005b36:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 8005b60 <DATA_Select+0x414>
 8005b3a:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005b3e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005b42:	edc7 7a01 	vstr	s15, [r7, #4]
 8005b46:	88bb      	ldrh	r3, [r7, #4]
 8005b48:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005b4a:	e000      	b.n	8005b4e <DATA_Select+0x402>

		default:
			break;
 8005b4c:	bf00      	nop
	}

	return value;
 8005b4e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8005b50:	b21b      	sxth	r3, r3
}
 8005b52:	4618      	mov	r0, r3
 8005b54:	372c      	adds	r7, #44	; 0x2c
 8005b56:	46bd      	mov	sp, r7
 8005b58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005b5c:	4770      	bx	lr
 8005b5e:	bf00      	nop
 8005b60:	47000000 	.word	0x47000000

08005b64 <DATA_RTXD_Run>:
#include "modules/data_select/data_select.h"

DATA_e gData_e[DATA_TXD_SIZE/2-1]={STA_DATA,IA_DATA,IA_DATA,IA_DATA,IA_DATA};

void DATA_RTXD_Run(CTRL_Handle handle, HAL_Handle halHandle, const HAL_AdcData_t *pAdcData, const HAL_QepData_t *pQepData)
{
 8005b64:	b580      	push	{r7, lr}
 8005b66:	b08a      	sub	sp, #40	; 0x28
 8005b68:	af02      	add	r7, sp, #8
 8005b6a:	60f8      	str	r0, [r7, #12]
 8005b6c:	60b9      	str	r1, [r7, #8]
 8005b6e:	607a      	str	r2, [r7, #4]
 8005b70:	603b      	str	r3, [r7, #0]
	DATA_RTXD_Obj *obj = (DATA_RTXD_Obj *)(handle->data_rtxd_handle);
 8005b72:	68fb      	ldr	r3, [r7, #12]
 8005b74:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
 8005b78:	61bb      	str	r3, [r7, #24]
	uint8_t i;
	int16_t value;
	obj->data_txd[0] = 0x11;
 8005b7a:	69bb      	ldr	r3, [r7, #24]
 8005b7c:	2211      	movs	r2, #17
 8005b7e:	73da      	strb	r2, [r3, #15]
	obj->data_txd[1] = 0xEB;
 8005b80:	69bb      	ldr	r3, [r7, #24]
 8005b82:	22eb      	movs	r2, #235	; 0xeb
 8005b84:	741a      	strb	r2, [r3, #16]

	obj->data_txd[2] = (uint8_t)( obj->time & (uint16_t)0x00FF );
 8005b86:	69bb      	ldr	r3, [r7, #24]
 8005b88:	8b9b      	ldrh	r3, [r3, #28]
 8005b8a:	b2da      	uxtb	r2, r3
 8005b8c:	69bb      	ldr	r3, [r7, #24]
 8005b8e:	745a      	strb	r2, [r3, #17]
	obj->data_txd[3] = (uint8_t)( ((obj->time)>>8) & (uint16_t)0x00FF );
 8005b90:	69bb      	ldr	r3, [r7, #24]
 8005b92:	8b9b      	ldrh	r3, [r3, #28]
 8005b94:	0a1b      	lsrs	r3, r3, #8
 8005b96:	b29b      	uxth	r3, r3
 8005b98:	b2da      	uxtb	r2, r3
 8005b9a:	69bb      	ldr	r3, [r7, #24]
 8005b9c:	749a      	strb	r2, [r3, #18]
	obj->time++;
 8005b9e:	69bb      	ldr	r3, [r7, #24]
 8005ba0:	8b9b      	ldrh	r3, [r3, #28]
 8005ba2:	3301      	adds	r3, #1
 8005ba4:	b29a      	uxth	r2, r3
 8005ba6:	69bb      	ldr	r3, [r7, #24]
 8005ba8:	839a      	strh	r2, [r3, #28]

	obj->data_txd[DATA_TXD_SIZE-1] = 0;
 8005baa:	69bb      	ldr	r3, [r7, #24]
 8005bac:	2200      	movs	r2, #0
 8005bae:	76da      	strb	r2, [r3, #27]
	obj->data_txd[DATA_TXD_SIZE-1] += obj->data_txd[0] + obj->data_txd[1] + obj->data_txd[2] + obj->data_txd[3];
 8005bb0:	69bb      	ldr	r3, [r7, #24]
 8005bb2:	7eda      	ldrb	r2, [r3, #27]
 8005bb4:	69bb      	ldr	r3, [r7, #24]
 8005bb6:	7bd9      	ldrb	r1, [r3, #15]
 8005bb8:	69bb      	ldr	r3, [r7, #24]
 8005bba:	7c1b      	ldrb	r3, [r3, #16]
 8005bbc:	440b      	add	r3, r1
 8005bbe:	b2d9      	uxtb	r1, r3
 8005bc0:	69bb      	ldr	r3, [r7, #24]
 8005bc2:	7c5b      	ldrb	r3, [r3, #17]
 8005bc4:	440b      	add	r3, r1
 8005bc6:	b2d9      	uxtb	r1, r3
 8005bc8:	69bb      	ldr	r3, [r7, #24]
 8005bca:	7c9b      	ldrb	r3, [r3, #18]
 8005bcc:	440b      	add	r3, r1
 8005bce:	b2db      	uxtb	r3, r3
 8005bd0:	4413      	add	r3, r2
 8005bd2:	b2da      	uxtb	r2, r3
 8005bd4:	69bb      	ldr	r3, [r7, #24]
 8005bd6:	76da      	strb	r2, [r3, #27]

	for(i=2;i<DATA_TXD_SIZE/2;i++)
 8005bd8:	2302      	movs	r3, #2
 8005bda:	77fb      	strb	r3, [r7, #31]
 8005bdc:	e03a      	b.n	8005c54 <DATA_RTXD_Run+0xf0>
	{
		value = DATA_Select(handle, halHandle, pAdcData, pQepData, gData_e[i-1]);
 8005bde:	7ffb      	ldrb	r3, [r7, #31]
 8005be0:	3b01      	subs	r3, #1
 8005be2:	4a21      	ldr	r2, [pc, #132]	; (8005c68 <DATA_RTXD_Run+0x104>)
 8005be4:	5cd3      	ldrb	r3, [r2, r3]
 8005be6:	9300      	str	r3, [sp, #0]
 8005be8:	68f8      	ldr	r0, [r7, #12]
 8005bea:	68b9      	ldr	r1, [r7, #8]
 8005bec:	687a      	ldr	r2, [r7, #4]
 8005bee:	683b      	ldr	r3, [r7, #0]
 8005bf0:	f7ff fdac 	bl	800574c <DATA_Select>
 8005bf4:	4603      	mov	r3, r0
 8005bf6:	82fb      	strh	r3, [r7, #22]
		obj->data_txd[i+i] = (uint8_t)( value & (uint16_t)0x00FF );
 8005bf8:	7ffa      	ldrb	r2, [r7, #31]
 8005bfa:	7ffb      	ldrb	r3, [r7, #31]
 8005bfc:	4413      	add	r3, r2
 8005bfe:	8afa      	ldrh	r2, [r7, #22]
 8005c00:	b2d1      	uxtb	r1, r2
 8005c02:	69ba      	ldr	r2, [r7, #24]
 8005c04:	4413      	add	r3, r2
 8005c06:	460a      	mov	r2, r1
 8005c08:	73da      	strb	r2, [r3, #15]
		obj->data_txd[i+i+1] = (uint8_t)( (value>>8) & (uint16_t)0x00FF );
 8005c0a:	7ffa      	ldrb	r2, [r7, #31]
 8005c0c:	7ffb      	ldrb	r3, [r7, #31]
 8005c0e:	4413      	add	r3, r2
 8005c10:	3301      	adds	r3, #1
 8005c12:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8005c16:	1212      	asrs	r2, r2, #8
 8005c18:	b292      	uxth	r2, r2
 8005c1a:	b2d1      	uxtb	r1, r2
 8005c1c:	69ba      	ldr	r2, [r7, #24]
 8005c1e:	4413      	add	r3, r2
 8005c20:	460a      	mov	r2, r1
 8005c22:	73da      	strb	r2, [r3, #15]
		obj->data_txd[DATA_TXD_SIZE-1] += obj->data_txd[i+i] + obj->data_txd[i+i+1];
 8005c24:	69bb      	ldr	r3, [r7, #24]
 8005c26:	7eda      	ldrb	r2, [r3, #27]
 8005c28:	7ff9      	ldrb	r1, [r7, #31]
 8005c2a:	7ffb      	ldrb	r3, [r7, #31]
 8005c2c:	440b      	add	r3, r1
 8005c2e:	69b9      	ldr	r1, [r7, #24]
 8005c30:	440b      	add	r3, r1
 8005c32:	7bd9      	ldrb	r1, [r3, #15]
 8005c34:	7ff8      	ldrb	r0, [r7, #31]
 8005c36:	7ffb      	ldrb	r3, [r7, #31]
 8005c38:	4403      	add	r3, r0
 8005c3a:	3301      	adds	r3, #1
 8005c3c:	69b8      	ldr	r0, [r7, #24]
 8005c3e:	4403      	add	r3, r0
 8005c40:	7bdb      	ldrb	r3, [r3, #15]
 8005c42:	440b      	add	r3, r1
 8005c44:	b2db      	uxtb	r3, r3
 8005c46:	4413      	add	r3, r2
 8005c48:	b2da      	uxtb	r2, r3
 8005c4a:	69bb      	ldr	r3, [r7, #24]
 8005c4c:	76da      	strb	r2, [r3, #27]
	obj->time++;

	obj->data_txd[DATA_TXD_SIZE-1] = 0;
	obj->data_txd[DATA_TXD_SIZE-1] += obj->data_txd[0] + obj->data_txd[1] + obj->data_txd[2] + obj->data_txd[3];

	for(i=2;i<DATA_TXD_SIZE/2;i++)
 8005c4e:	7ffb      	ldrb	r3, [r7, #31]
 8005c50:	3301      	adds	r3, #1
 8005c52:	77fb      	strb	r3, [r7, #31]
 8005c54:	7ffb      	ldrb	r3, [r7, #31]
 8005c56:	2b05      	cmp	r3, #5
 8005c58:	d9c1      	bls.n	8005bde <DATA_RTXD_Run+0x7a>
//	for(i=0;i<DATA_TXD_SIZE;i++)
//	{
//		obj->data_txd[i]=i;
//	}
	
	Reset_DATA_TXD(obj);
 8005c5a:	69b8      	ldr	r0, [r7, #24]
 8005c5c:	f7ff fd52 	bl	8005704 <Reset_DATA_TXD>

}
 8005c60:	3720      	adds	r7, #32
 8005c62:	46bd      	mov	sp, r7
 8005c64:	bd80      	pop	{r7, pc}
 8005c66:	bf00      	nop
 8005c68:	2001000c 	.word	0x2001000c

08005c6c <DATA_RTXD_Decode>:

void DATA_RTXD_Decode(CTRL_Handle handle, HAL_Handle halHandle)
{
 8005c6c:	b580      	push	{r7, lr}
 8005c6e:	b086      	sub	sp, #24
 8005c70:	af00      	add	r7, sp, #0
 8005c72:	6078      	str	r0, [r7, #4]
 8005c74:	6039      	str	r1, [r7, #0]
	DATA_RTXD_Obj *obj = (DATA_RTXD_Obj *)(handle->data_rtxd_handle);
 8005c76:	687b      	ldr	r3, [r7, #4]
 8005c78:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
 8005c7c:	60fb      	str	r3, [r7, #12]
	uint8_t i,value=0;
 8005c7e:	2300      	movs	r3, #0
 8005c80:	75bb      	strb	r3, [r7, #22]
	float_t value1=0.0f;
 8005c82:	f04f 0300 	mov.w	r3, #0
 8005c86:	613b      	str	r3, [r7, #16]

	if(!(DATA_RXD_Status(handle->data_rtxd_handle)))
 8005c88:	687b      	ldr	r3, [r7, #4]
 8005c8a:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
 8005c8e:	4618      	mov	r0, r3
 8005c90:	f7ff fd48 	bl	8005724 <DATA_RXD_Status>
 8005c94:	4603      	mov	r3, r0
 8005c96:	2b00      	cmp	r3, #0
 8005c98:	f040 80df 	bne.w	8005e5a <DATA_RTXD_Decode+0x1ee>
	{
		for(i=0;i<DATA_RXD_SIZE-1;i++)
 8005c9c:	2300      	movs	r3, #0
 8005c9e:	75fb      	strb	r3, [r7, #23]
 8005ca0:	e009      	b.n	8005cb6 <DATA_RTXD_Decode+0x4a>
		{
//			if(obj->data_rxd[i]>=32)
//			{
//				obj->data_rxd[i] -= 32;//0x20:32
				value += obj->data_rxd[i];
 8005ca2:	7dfb      	ldrb	r3, [r7, #23]
 8005ca4:	68fa      	ldr	r2, [r7, #12]
 8005ca6:	4413      	add	r3, r2
 8005ca8:	785a      	ldrb	r2, [r3, #1]
 8005caa:	7dbb      	ldrb	r3, [r7, #22]
 8005cac:	4413      	add	r3, r2
 8005cae:	75bb      	strb	r3, [r7, #22]
	uint8_t i,value=0;
	float_t value1=0.0f;

	if(!(DATA_RXD_Status(handle->data_rtxd_handle)))
	{
		for(i=0;i<DATA_RXD_SIZE-1;i++)
 8005cb0:	7dfb      	ldrb	r3, [r7, #23]
 8005cb2:	3301      	adds	r3, #1
 8005cb4:	75fb      	strb	r3, [r7, #23]
 8005cb6:	7dfb      	ldrb	r3, [r7, #23]
 8005cb8:	2b0b      	cmp	r3, #11
 8005cba:	d9f2      	bls.n	8005ca2 <DATA_RTXD_Decode+0x36>
//				obj->data_rxd[i] -= 32;//0x20:32
				value += obj->data_rxd[i];
//			}
		}
//		obj->data_rxd[DATA_RXD_SIZE-1] -= 32;//0x20:32
		if( obj->data_rxd[0]==0x01 && obj->data_rxd[1]==0x0E && value== obj->data_rxd[DATA_RXD_SIZE-1] )
 8005cbc:	68fb      	ldr	r3, [r7, #12]
 8005cbe:	785b      	ldrb	r3, [r3, #1]
 8005cc0:	2b01      	cmp	r3, #1
 8005cc2:	f040 80c7 	bne.w	8005e54 <DATA_RTXD_Decode+0x1e8>
 8005cc6:	68fb      	ldr	r3, [r7, #12]
 8005cc8:	789b      	ldrb	r3, [r3, #2]
 8005cca:	2b0e      	cmp	r3, #14
 8005ccc:	f040 80c2 	bne.w	8005e54 <DATA_RTXD_Decode+0x1e8>
 8005cd0:	68fb      	ldr	r3, [r7, #12]
 8005cd2:	7b5b      	ldrb	r3, [r3, #13]
 8005cd4:	7dba      	ldrb	r2, [r7, #22]
 8005cd6:	429a      	cmp	r2, r3
 8005cd8:	f040 80bc 	bne.w	8005e54 <DATA_RTXD_Decode+0x1e8>
		{
			for(i=2;i<DATA_RXD_SIZE-1;i++)
 8005cdc:	2302      	movs	r3, #2
 8005cde:	75fb      	strb	r3, [r7, #23]
 8005ce0:	e0b4      	b.n	8005e4c <DATA_RTXD_Decode+0x1e0>
			{
				if( i<DATA_RXD_SIZE/2 && obj->data_rxd[i]>STA_DATA && obj->data_rxd[i]<END_DATA )
 8005ce2:	7dfb      	ldrb	r3, [r7, #23]
 8005ce4:	2b05      	cmp	r3, #5
 8005ce6:	d814      	bhi.n	8005d12 <DATA_RTXD_Decode+0xa6>
 8005ce8:	7dfb      	ldrb	r3, [r7, #23]
 8005cea:	68fa      	ldr	r2, [r7, #12]
 8005cec:	4413      	add	r3, r2
 8005cee:	785b      	ldrb	r3, [r3, #1]
 8005cf0:	2b00      	cmp	r3, #0
 8005cf2:	d00e      	beq.n	8005d12 <DATA_RTXD_Decode+0xa6>
 8005cf4:	7dfb      	ldrb	r3, [r7, #23]
 8005cf6:	68fa      	ldr	r2, [r7, #12]
 8005cf8:	4413      	add	r3, r2
 8005cfa:	785b      	ldrb	r3, [r3, #1]
 8005cfc:	2b36      	cmp	r3, #54	; 0x36
 8005cfe:	d808      	bhi.n	8005d12 <DATA_RTXD_Decode+0xa6>
				{
					gData_e[i-1] = (DATA_e)obj->data_rxd[i];
 8005d00:	7dfb      	ldrb	r3, [r7, #23]
 8005d02:	3b01      	subs	r3, #1
 8005d04:	7dfa      	ldrb	r2, [r7, #23]
 8005d06:	68f9      	ldr	r1, [r7, #12]
 8005d08:	440a      	add	r2, r1
 8005d0a:	7851      	ldrb	r1, [r2, #1]
 8005d0c:	4a55      	ldr	r2, [pc, #340]	; (8005e64 <DATA_RTXD_Decode+0x1f8>)
 8005d0e:	54d1      	strb	r1, [r2, r3]
 8005d10:	e099      	b.n	8005e46 <DATA_RTXD_Decode+0x1da>
				}
				else if( i<DATA_RXD_SIZE/2+1 && obj->data_rxd[i]>CTRL_State_Error && obj->data_rxd[i]<CTRL_numStates)
 8005d12:	7dfb      	ldrb	r3, [r7, #23]
 8005d14:	2b06      	cmp	r3, #6
 8005d16:	d816      	bhi.n	8005d46 <DATA_RTXD_Decode+0xda>
 8005d18:	7dfb      	ldrb	r3, [r7, #23]
 8005d1a:	68fa      	ldr	r2, [r7, #12]
 8005d1c:	4413      	add	r3, r2
 8005d1e:	785b      	ldrb	r3, [r3, #1]
 8005d20:	2b00      	cmp	r3, #0
 8005d22:	d010      	beq.n	8005d46 <DATA_RTXD_Decode+0xda>
 8005d24:	7dfb      	ldrb	r3, [r7, #23]
 8005d26:	68fa      	ldr	r2, [r7, #12]
 8005d28:	4413      	add	r3, r2
 8005d2a:	785b      	ldrb	r3, [r3, #1]
 8005d2c:	2b09      	cmp	r3, #9
 8005d2e:	d80a      	bhi.n	8005d46 <DATA_RTXD_Decode+0xda>
				{
					handle->prevState = handle->state;
 8005d30:	687b      	ldr	r3, [r7, #4]
 8005d32:	7a1a      	ldrb	r2, [r3, #8]
 8005d34:	687b      	ldr	r3, [r7, #4]
 8005d36:	725a      	strb	r2, [r3, #9]
					handle->state = (CTRL_State_e)obj->data_rxd[i];
 8005d38:	7dfb      	ldrb	r3, [r7, #23]
 8005d3a:	68fa      	ldr	r2, [r7, #12]
 8005d3c:	4413      	add	r3, r2
 8005d3e:	785a      	ldrb	r2, [r3, #1]
 8005d40:	687b      	ldr	r3, [r7, #4]
 8005d42:	721a      	strb	r2, [r3, #8]
 8005d44:	e07f      	b.n	8005e46 <DATA_RTXD_Decode+0x1da>
				}
				else if(  i<DATA_RXD_SIZE/2+2 && obj->data_rxd[i]>USER_Motor_Cmd_Err && obj->data_rxd[i]<USER_Motor_Cmd_Num )
 8005d46:	7dfb      	ldrb	r3, [r7, #23]
 8005d48:	2b07      	cmp	r3, #7
 8005d4a:	d87c      	bhi.n	8005e46 <DATA_RTXD_Decode+0x1da>
 8005d4c:	7dfb      	ldrb	r3, [r7, #23]
 8005d4e:	68fa      	ldr	r2, [r7, #12]
 8005d50:	4413      	add	r3, r2
 8005d52:	785b      	ldrb	r3, [r3, #1]
 8005d54:	2b00      	cmp	r3, #0
 8005d56:	d076      	beq.n	8005e46 <DATA_RTXD_Decode+0x1da>
 8005d58:	7dfb      	ldrb	r3, [r7, #23]
 8005d5a:	68fa      	ldr	r2, [r7, #12]
 8005d5c:	4413      	add	r3, r2
 8005d5e:	785b      	ldrb	r3, [r3, #1]
 8005d60:	2b06      	cmp	r3, #6
 8005d62:	d870      	bhi.n	8005e46 <DATA_RTXD_Decode+0x1da>
				{
					value1 = obj->data_rxd[i+1] + obj->data_rxd[i+2]*256.0f;
 8005d64:	7dfb      	ldrb	r3, [r7, #23]
 8005d66:	3301      	adds	r3, #1
 8005d68:	68fa      	ldr	r2, [r7, #12]
 8005d6a:	4413      	add	r3, r2
 8005d6c:	785b      	ldrb	r3, [r3, #1]
 8005d6e:	ee07 3a90 	vmov	s15, r3
 8005d72:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8005d76:	7dfb      	ldrb	r3, [r7, #23]
 8005d78:	3302      	adds	r3, #2
 8005d7a:	68fa      	ldr	r2, [r7, #12]
 8005d7c:	4413      	add	r3, r2
 8005d7e:	785b      	ldrb	r3, [r3, #1]
 8005d80:	ee07 3a90 	vmov	s15, r3
 8005d84:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8005d88:	eddf 6a37 	vldr	s13, [pc, #220]	; 8005e68 <DATA_RTXD_Decode+0x1fc>
 8005d8c:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8005d90:	ee77 7a27 	vadd.f32	s15, s14, s15
 8005d94:	edc7 7a04 	vstr	s15, [r7, #16]
					if( value1 > 32767.0f )
 8005d98:	edd7 7a04 	vldr	s15, [r7, #16]
 8005d9c:	ed9f 7a33 	vldr	s14, [pc, #204]	; 8005e6c <DATA_RTXD_Decode+0x200>
 8005da0:	eef4 7ac7 	vcmpe.f32	s15, s14
 8005da4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005da8:	dd07      	ble.n	8005dba <DATA_RTXD_Decode+0x14e>
					{
						value1 -= 65536.0f;
 8005daa:	edd7 7a04 	vldr	s15, [r7, #16]
 8005dae:	ed9f 7a30 	vldr	s14, [pc, #192]	; 8005e70 <DATA_RTXD_Decode+0x204>
 8005db2:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8005db6:	edc7 7a04 	vstr	s15, [r7, #16]
					}
					value1 *= 0.00004f;
 8005dba:	edd7 7a04 	vldr	s15, [r7, #16]
 8005dbe:	ed9f 7a2d 	vldr	s14, [pc, #180]	; 8005e74 <DATA_RTXD_Decode+0x208>
 8005dc2:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005dc6:	edc7 7a04 	vstr	s15, [r7, #16]
					switch(obj->data_rxd[i])
 8005dca:	7dfb      	ldrb	r3, [r7, #23]
 8005dcc:	68fa      	ldr	r2, [r7, #12]
 8005dce:	4413      	add	r3, r2
 8005dd0:	785b      	ldrb	r3, [r3, #1]
 8005dd2:	3b01      	subs	r3, #1
 8005dd4:	2b05      	cmp	r3, #5
 8005dd6:	d835      	bhi.n	8005e44 <DATA_RTXD_Decode+0x1d8>
 8005dd8:	a201      	add	r2, pc, #4	; (adr r2, 8005de0 <DATA_RTXD_Decode+0x174>)
 8005dda:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005dde:	bf00      	nop
 8005de0:	08005df9 	.word	0x08005df9
 8005de4:	08005e03 	.word	0x08005e03
 8005de8:	08005e0d 	.word	0x08005e0d
 8005dec:	08005e17 	.word	0x08005e17
 8005df0:	08005e21 	.word	0x08005e21
 8005df4:	08005e33 	.word	0x08005e33
					{
						case USER_Motor_Speed_Ref:
							handle->spd_ref = value1;
 8005df8:	687b      	ldr	r3, [r7, #4]
 8005dfa:	693a      	ldr	r2, [r7, #16]
 8005dfc:	f8c3 21e4 	str.w	r2, [r3, #484]	; 0x1e4
							break;
 8005e00:	e021      	b.n	8005e46 <DATA_RTXD_Decode+0x1da>
						case USER_Motor_Speed_P:
							handle->Kp_spd = value1;
 8005e02:	687b      	ldr	r3, [r7, #4]
 8005e04:	693a      	ldr	r2, [r7, #16]
 8005e06:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
							break;
 8005e0a:	e01c      	b.n	8005e46 <DATA_RTXD_Decode+0x1da>
						case USER_Motor_Speed_I:
							handle->Ki_spd = value1;
 8005e0c:	687b      	ldr	r3, [r7, #4]
 8005e0e:	693a      	ldr	r2, [r7, #16]
 8005e10:	f8c3 21bc 	str.w	r2, [r3, #444]	; 0x1bc
							break;
 8005e14:	e017      	b.n	8005e46 <DATA_RTXD_Decode+0x1da>
						case USER_Motor_Iq_Ref:
							handle->Idq_ref.value[1] = value1;
 8005e16:	687b      	ldr	r3, [r7, #4]
 8005e18:	693a      	ldr	r2, [r7, #16]
 8005e1a:	f8c3 21dc 	str.w	r2, [r3, #476]	; 0x1dc
							break;
 8005e1e:	e012      	b.n	8005e46 <DATA_RTXD_Decode+0x1da>
						case USER_Motor_Iq_P:
							handle->Kp_Id = value1;
 8005e20:	687b      	ldr	r3, [r7, #4]
 8005e22:	693a      	ldr	r2, [r7, #16]
 8005e24:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
							handle->Kp_Iq = value1;
 8005e28:	687b      	ldr	r3, [r7, #4]
 8005e2a:	693a      	ldr	r2, [r7, #16]
 8005e2c:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
							break;
 8005e30:	e009      	b.n	8005e46 <DATA_RTXD_Decode+0x1da>
						case USER_Motor_Iq_I:
							handle->Ki_Id = value1;
 8005e32:	687b      	ldr	r3, [r7, #4]
 8005e34:	693a      	ldr	r2, [r7, #16]
 8005e36:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
							handle->Ki_Iq = value1;
 8005e3a:	687b      	ldr	r3, [r7, #4]
 8005e3c:	693a      	ldr	r2, [r7, #16]
 8005e3e:	f8c3 21b8 	str.w	r2, [r3, #440]	; 0x1b8
							break;
 8005e42:	e000      	b.n	8005e46 <DATA_RTXD_Decode+0x1da>
						default:
							break;
 8005e44:	bf00      	nop
//			}
		}
//		obj->data_rxd[DATA_RXD_SIZE-1] -= 32;//0x20:32
		if( obj->data_rxd[0]==0x01 && obj->data_rxd[1]==0x0E && value== obj->data_rxd[DATA_RXD_SIZE-1] )
		{
			for(i=2;i<DATA_RXD_SIZE-1;i++)
 8005e46:	7dfb      	ldrb	r3, [r7, #23]
 8005e48:	3301      	adds	r3, #1
 8005e4a:	75fb      	strb	r3, [r7, #23]
 8005e4c:	7dfb      	ldrb	r3, [r7, #23]
 8005e4e:	2b0b      	cmp	r3, #11
 8005e50:	f67f af47 	bls.w	8005ce2 <DATA_RTXD_Decode+0x76>
							break;
					}
				}
			}
		}
		Reset_DATA_RXD(obj);
 8005e54:	68f8      	ldr	r0, [r7, #12]
 8005e56:	f7ff fc45 	bl	80056e4 <Reset_DATA_RXD>
	}

	return;
 8005e5a:	bf00      	nop
}
 8005e5c:	3718      	adds	r7, #24
 8005e5e:	46bd      	mov	sp, r7
 8005e60:	bd80      	pop	{r7, pc}
 8005e62:	bf00      	nop
 8005e64:	2001000c 	.word	0x2001000c
 8005e68:	43800000 	.word	0x43800000
 8005e6c:	46fffe00 	.word	0x46fffe00
 8005e70:	47800000 	.word	0x47800000
 8005e74:	3827c5ac 	.word	0x3827c5ac

08005e78 <FILTER_FO_init>:
  return;
} // end of FILTER_FO_getNumCoeffs() function


FILTER_FO_Handle FILTER_FO_init(void *pMemory,const size_t numBytes)
{
 8005e78:	b480      	push	{r7}
 8005e7a:	b085      	sub	sp, #20
 8005e7c:	af00      	add	r7, sp, #0
 8005e7e:	6078      	str	r0, [r7, #4]
 8005e80:	6039      	str	r1, [r7, #0]
  FILTER_FO_Handle handle;


  if(numBytes < sizeof(FILTER_FO_Obj))
 8005e82:	683b      	ldr	r3, [r7, #0]
 8005e84:	2b13      	cmp	r3, #19
 8005e86:	d801      	bhi.n	8005e8c <FILTER_FO_init+0x14>
    return((FILTER_FO_Handle)NULL);
 8005e88:	2300      	movs	r3, #0
 8005e8a:	e002      	b.n	8005e92 <FILTER_FO_init+0x1a>

  // assign the handle
  handle = (FILTER_FO_Handle)pMemory;
 8005e8c:	687b      	ldr	r3, [r7, #4]
 8005e8e:	60fb      	str	r3, [r7, #12]

  return(handle);
 8005e90:	68fb      	ldr	r3, [r7, #12]
} // end of FILTER_FO_init() function
 8005e92:	4618      	mov	r0, r3
 8005e94:	3714      	adds	r7, #20
 8005e96:	46bd      	mov	sp, r7
 8005e98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005e9c:	4770      	bx	lr
 8005e9e:	bf00      	nop

08005ea0 <FILTER_FO_setDenCoeffs>:


void FILTER_FO_setDenCoeffs(FILTER_FO_Handle handle,const float_t a1)
{
 8005ea0:	b480      	push	{r7}
 8005ea2:	b085      	sub	sp, #20
 8005ea4:	af00      	add	r7, sp, #0
 8005ea6:	6078      	str	r0, [r7, #4]
 8005ea8:	ed87 0a00 	vstr	s0, [r7]
  FILTER_FO_Obj *obj = (FILTER_FO_Obj *)handle;
 8005eac:	687b      	ldr	r3, [r7, #4]
 8005eae:	60fb      	str	r3, [r7, #12]


  obj->a1 = a1;
 8005eb0:	68fb      	ldr	r3, [r7, #12]
 8005eb2:	683a      	ldr	r2, [r7, #0]
 8005eb4:	601a      	str	r2, [r3, #0]

  return;
 8005eb6:	bf00      	nop
} // end of FILTER_FO_setDenCoeffs() function
 8005eb8:	3714      	adds	r7, #20
 8005eba:	46bd      	mov	sp, r7
 8005ebc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005ec0:	4770      	bx	lr
 8005ec2:	bf00      	nop

08005ec4 <FILTER_FO_setInitialConditions>:


void FILTER_FO_setInitialConditions(FILTER_FO_Handle handle,const float_t x1,const float_t y1)
{
 8005ec4:	b480      	push	{r7}
 8005ec6:	b087      	sub	sp, #28
 8005ec8:	af00      	add	r7, sp, #0
 8005eca:	60f8      	str	r0, [r7, #12]
 8005ecc:	ed87 0a02 	vstr	s0, [r7, #8]
 8005ed0:	edc7 0a01 	vstr	s1, [r7, #4]
  FILTER_FO_Obj *obj = (FILTER_FO_Obj *)handle;
 8005ed4:	68fb      	ldr	r3, [r7, #12]
 8005ed6:	617b      	str	r3, [r7, #20]


  obj->x1 = x1;
 8005ed8:	697b      	ldr	r3, [r7, #20]
 8005eda:	68ba      	ldr	r2, [r7, #8]
 8005edc:	60da      	str	r2, [r3, #12]

  obj->y1 = y1;
 8005ede:	697b      	ldr	r3, [r7, #20]
 8005ee0:	687a      	ldr	r2, [r7, #4]
 8005ee2:	611a      	str	r2, [r3, #16]

  return;
 8005ee4:	bf00      	nop
} // end of FILTER_FO_setInitialConditions() function
 8005ee6:	371c      	adds	r7, #28
 8005ee8:	46bd      	mov	sp, r7
 8005eea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005eee:	4770      	bx	lr

08005ef0 <FILTER_FO_setNumCoeffs>:


void FILTER_FO_setNumCoeffs(FILTER_FO_Handle handle,const float_t b0,const float_t b1)
{
 8005ef0:	b480      	push	{r7}
 8005ef2:	b087      	sub	sp, #28
 8005ef4:	af00      	add	r7, sp, #0
 8005ef6:	60f8      	str	r0, [r7, #12]
 8005ef8:	ed87 0a02 	vstr	s0, [r7, #8]
 8005efc:	edc7 0a01 	vstr	s1, [r7, #4]
  FILTER_FO_Obj *obj = (FILTER_FO_Obj *)handle;
 8005f00:	68fb      	ldr	r3, [r7, #12]
 8005f02:	617b      	str	r3, [r7, #20]


  obj->b0 = b0;
 8005f04:	697b      	ldr	r3, [r7, #20]
 8005f06:	68ba      	ldr	r2, [r7, #8]
 8005f08:	605a      	str	r2, [r3, #4]
  obj->b1 = b1;
 8005f0a:	697b      	ldr	r3, [r7, #20]
 8005f0c:	687a      	ldr	r2, [r7, #4]
 8005f0e:	609a      	str	r2, [r3, #8]

  return;
 8005f10:	bf00      	nop
} // end of FILTER_FO_setNumCoeffs() function
 8005f12:	371c      	adds	r7, #28
 8005f14:	46bd      	mov	sp, r7
 8005f16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005f1a:	4770      	bx	lr

08005f1c <HAL_getNumCurrentSensors>:

//! \brief     Gets the number of current sensors
//! \param[in] handle  The hardware abstraction layer (HAL) handle
//! \return    The number of current sensors
static inline uint_least8_t HAL_getNumCurrentSensors(HAL_Handle handle)
{
 8005f1c:	b480      	push	{r7}
 8005f1e:	b085      	sub	sp, #20
 8005f20:	af00      	add	r7, sp, #0
 8005f22:	6078      	str	r0, [r7, #4]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8005f24:	687b      	ldr	r3, [r7, #4]
 8005f26:	60fb      	str	r3, [r7, #12]
  

  return(obj->numCurrentSensors);
 8005f28:	68fb      	ldr	r3, [r7, #12]
 8005f2a:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
} // end of HAL_getNumCurrentSensors() function
 8005f2e:	4618      	mov	r0, r3
 8005f30:	3714      	adds	r7, #20
 8005f32:	46bd      	mov	sp, r7
 8005f34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005f38:	4770      	bx	lr
 8005f3a:	bf00      	nop

08005f3c <HAL_getNumVoltageSensors>:

//! \brief     Gets the number of voltage sensors
//! \param[in] handle  The hardware abstraction layer (HAL) handle
//! \return    The number of voltage sensors
static inline uint_least8_t HAL_getNumVoltageSensors(HAL_Handle handle)
{
 8005f3c:	b480      	push	{r7}
 8005f3e:	b085      	sub	sp, #20
 8005f40:	af00      	add	r7, sp, #0
 8005f42:	6078      	str	r0, [r7, #4]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8005f44:	687b      	ldr	r3, [r7, #4]
 8005f46:	60fb      	str	r3, [r7, #12]
  

  return(obj->numVoltageSensors);
 8005f48:	68fb      	ldr	r3, [r7, #12]
 8005f4a:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
} // end of HAL_getNumVoltageSensors() function
 8005f4e:	4618      	mov	r0, r3
 8005f50:	3714      	adds	r7, #20
 8005f52:	46bd      	mov	sp, r7
 8005f54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005f58:	4770      	bx	lr
 8005f5a:	bf00      	nop

08005f5c <HAL_setBias>:
//! \param[in] bias          The ADC bias value
static inline void HAL_setBias(HAL_Handle handle,
                               const HAL_SensorType_e sensorType,
                               uint_least8_t sensorNumber,
                               const float_t bias)//! \Mod By Dl.K
{
 8005f5c:	b480      	push	{r7}
 8005f5e:	b087      	sub	sp, #28
 8005f60:	af00      	add	r7, sp, #0
 8005f62:	60f8      	str	r0, [r7, #12]
 8005f64:	460b      	mov	r3, r1
 8005f66:	ed87 0a01 	vstr	s0, [r7, #4]
 8005f6a:	72fb      	strb	r3, [r7, #11]
 8005f6c:	4613      	mov	r3, r2
 8005f6e:	72bb      	strb	r3, [r7, #10]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8005f70:	68fb      	ldr	r3, [r7, #12]
 8005f72:	617b      	str	r3, [r7, #20]


  if(sensorType == HAL_SensorType_Current)
 8005f74:	7afb      	ldrb	r3, [r7, #11]
 8005f76:	2b00      	cmp	r3, #0
 8005f78:	d107      	bne.n	8005f8a <HAL_setBias+0x2e>
    {
      obj->adcBias.I.value[sensorNumber] = bias;
 8005f7a:	7abb      	ldrb	r3, [r7, #10]
 8005f7c:	697a      	ldr	r2, [r7, #20]
 8005f7e:	3336      	adds	r3, #54	; 0x36
 8005f80:	009b      	lsls	r3, r3, #2
 8005f82:	4413      	add	r3, r2
 8005f84:	687a      	ldr	r2, [r7, #4]
 8005f86:	601a      	str	r2, [r3, #0]
 8005f88:	e009      	b.n	8005f9e <HAL_setBias+0x42>
    }
  else if(sensorType == HAL_SensorType_Voltage)
 8005f8a:	7afb      	ldrb	r3, [r7, #11]
 8005f8c:	2b01      	cmp	r3, #1
 8005f8e:	d106      	bne.n	8005f9e <HAL_setBias+0x42>
    {
      obj->adcBias.V.value[sensorNumber] = bias;
 8005f90:	7abb      	ldrb	r3, [r7, #10]
 8005f92:	697a      	ldr	r2, [r7, #20]
 8005f94:	3338      	adds	r3, #56	; 0x38
 8005f96:	009b      	lsls	r3, r3, #2
 8005f98:	4413      	add	r3, r2
 8005f9a:	687a      	ldr	r2, [r7, #4]
 8005f9c:	605a      	str	r2, [r3, #4]
    }

  return;
 8005f9e:	bf00      	nop
} // end of HAL_setBias() function
 8005fa0:	371c      	adds	r7, #28
 8005fa2:	46bd      	mov	sp, r7
 8005fa4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005fa8:	4770      	bx	lr
 8005faa:	bf00      	nop

08005fac <HAL_setCurrentScaleFactor>:

//! \brief     Sets the current scale factor in the hardware abstraction layer
//! \param[in] handle      The hardware abstraction layer (HAL) handle
//! \param[in] current_sf  The current scale factor
static inline void HAL_setCurrentScaleFactor(HAL_Handle handle,const float_t current_sf)//! \Mod By Dl.K
{
 8005fac:	b480      	push	{r7}
 8005fae:	b085      	sub	sp, #20
 8005fb0:	af00      	add	r7, sp, #0
 8005fb2:	6078      	str	r0, [r7, #4]
 8005fb4:	ed87 0a00 	vstr	s0, [r7]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8005fb8:	687b      	ldr	r3, [r7, #4]
 8005fba:	60fb      	str	r3, [r7, #12]
  

  obj->current_sf = current_sf;
 8005fbc:	68fb      	ldr	r3, [r7, #12]
 8005fbe:	683a      	ldr	r2, [r7, #0]
 8005fc0:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8

  return;
 8005fc4:	bf00      	nop
} // end of HAL_setCurrentScaleFactor() function
 8005fc6:	3714      	adds	r7, #20
 8005fc8:	46bd      	mov	sp, r7
 8005fca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005fce:	4770      	bx	lr

08005fd0 <HAL_setNumCurrentSensors>:

//! \brief     Sets the number of current sensors
//! \param[in] handle             The hardware abstraction layer (HAL) handle
//! \param[in] numCurrentSensors  The number of current sensors
static inline void HAL_setNumCurrentSensors(HAL_Handle handle,const uint_least8_t numCurrentSensors)
{
 8005fd0:	b480      	push	{r7}
 8005fd2:	b085      	sub	sp, #20
 8005fd4:	af00      	add	r7, sp, #0
 8005fd6:	6078      	str	r0, [r7, #4]
 8005fd8:	460b      	mov	r3, r1
 8005fda:	70fb      	strb	r3, [r7, #3]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8005fdc:	687b      	ldr	r3, [r7, #4]
 8005fde:	60fb      	str	r3, [r7, #12]
  

  obj->numCurrentSensors = numCurrentSensors;
 8005fe0:	68fb      	ldr	r3, [r7, #12]
 8005fe2:	78fa      	ldrb	r2, [r7, #3]
 8005fe4:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100

  return;
 8005fe8:	bf00      	nop
} // end of HAL_setNumCurrentSensors() function
 8005fea:	3714      	adds	r7, #20
 8005fec:	46bd      	mov	sp, r7
 8005fee:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005ff2:	4770      	bx	lr

08005ff4 <HAL_setNumVoltageSensors>:

//! \brief     Sets the number of voltage sensors
//! \param[in] handle             The hardware abstraction layer (HAL) handle
//! \param[in] numVoltageSensors  The number of voltage sensors
static inline void HAL_setNumVoltageSensors(HAL_Handle handle,const uint_least8_t numVoltageSensors)
{
 8005ff4:	b480      	push	{r7}
 8005ff6:	b085      	sub	sp, #20
 8005ff8:	af00      	add	r7, sp, #0
 8005ffa:	6078      	str	r0, [r7, #4]
 8005ffc:	460b      	mov	r3, r1
 8005ffe:	70fb      	strb	r3, [r7, #3]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8006000:	687b      	ldr	r3, [r7, #4]
 8006002:	60fb      	str	r3, [r7, #12]
  

  obj->numVoltageSensors = numVoltageSensors;
 8006004:	68fb      	ldr	r3, [r7, #12]
 8006006:	78fa      	ldrb	r2, [r7, #3]
 8006008:	f883 2101 	strb.w	r2, [r3, #257]	; 0x101

  return;
 800600c:	bf00      	nop
} // end of HAL_setNumVoltageSensors() function
 800600e:	3714      	adds	r7, #20
 8006010:	46bd      	mov	sp, r7
 8006012:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006016:	4770      	bx	lr

08006018 <HAL_setOffsetBeta_lp_pu>:
//! \param[in] beta_lp_pu    The value used to set the low pass filter pole, pu
static inline void HAL_setOffsetBeta_lp_pu(HAL_Handle handle,
                                           const HAL_SensorType_e sensorType,
                                           const uint_least8_t sensorNumber,
                                           const float_t beta_lp_pu)//! \Mod By Dl.K
{
 8006018:	b580      	push	{r7, lr}
 800601a:	b086      	sub	sp, #24
 800601c:	af00      	add	r7, sp, #0
 800601e:	60f8      	str	r0, [r7, #12]
 8006020:	460b      	mov	r3, r1
 8006022:	ed87 0a01 	vstr	s0, [r7, #4]
 8006026:	72fb      	strb	r3, [r7, #11]
 8006028:	4613      	mov	r3, r2
 800602a:	72bb      	strb	r3, [r7, #10]
  HAL_Obj *obj = (HAL_Obj *)handle;
 800602c:	68fb      	ldr	r3, [r7, #12]
 800602e:	617b      	str	r3, [r7, #20]

  if(sensorType == HAL_SensorType_Current)
 8006030:	7afb      	ldrb	r3, [r7, #11]
 8006032:	2b00      	cmp	r3, #0
 8006034:	d109      	bne.n	800604a <HAL_setOffsetBeta_lp_pu+0x32>
    {
      OFFSET_setBeta(obj->offsetHandle_I[sensorNumber],beta_lp_pu);
 8006036:	7aba      	ldrb	r2, [r7, #10]
 8006038:	697b      	ldr	r3, [r7, #20]
 800603a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800603e:	4618      	mov	r0, r3
 8006040:	ed97 0a01 	vldr	s0, [r7, #4]
 8006044:	f000 f9ce 	bl	80063e4 <OFFSET_setBeta>
 8006048:	e00d      	b.n	8006066 <HAL_setOffsetBeta_lp_pu+0x4e>
    }
  else if(sensorType == HAL_SensorType_Voltage)
 800604a:	7afb      	ldrb	r3, [r7, #11]
 800604c:	2b01      	cmp	r3, #1
 800604e:	d10a      	bne.n	8006066 <HAL_setOffsetBeta_lp_pu+0x4e>
    {
      OFFSET_setBeta(obj->offsetHandle_V[sensorNumber],beta_lp_pu);
 8006050:	7abb      	ldrb	r3, [r7, #10]
 8006052:	697a      	ldr	r2, [r7, #20]
 8006054:	331a      	adds	r3, #26
 8006056:	009b      	lsls	r3, r3, #2
 8006058:	4413      	add	r3, r2
 800605a:	685b      	ldr	r3, [r3, #4]
 800605c:	4618      	mov	r0, r3
 800605e:	ed97 0a01 	vldr	s0, [r7, #4]
 8006062:	f000 f9bf 	bl	80063e4 <OFFSET_setBeta>
    }

  return;
 8006066:	bf00      	nop
} // end of HAL_setOffsetBeta_lp_pu() function
 8006068:	3718      	adds	r7, #24
 800606a:	46bd      	mov	sp, r7
 800606c:	bd80      	pop	{r7, pc}
 800606e:	bf00      	nop

08006070 <HAL_setOffsetInitCond>:
//! \param[in] initCond      The initial condition value
static inline void HAL_setOffsetInitCond(HAL_Handle handle,
                                         const HAL_SensorType_e sensorType,
                                         const uint_least8_t sensorNumber,
                                         const float_t initCond)//! \Mod By Dl.K
{
 8006070:	b580      	push	{r7, lr}
 8006072:	b086      	sub	sp, #24
 8006074:	af00      	add	r7, sp, #0
 8006076:	60f8      	str	r0, [r7, #12]
 8006078:	460b      	mov	r3, r1
 800607a:	ed87 0a01 	vstr	s0, [r7, #4]
 800607e:	72fb      	strb	r3, [r7, #11]
 8006080:	4613      	mov	r3, r2
 8006082:	72bb      	strb	r3, [r7, #10]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8006084:	68fb      	ldr	r3, [r7, #12]
 8006086:	617b      	str	r3, [r7, #20]

  if(sensorType == HAL_SensorType_Current)
 8006088:	7afb      	ldrb	r3, [r7, #11]
 800608a:	2b00      	cmp	r3, #0
 800608c:	d109      	bne.n	80060a2 <HAL_setOffsetInitCond+0x32>
    {
      OFFSET_setInitCond(obj->offsetHandle_I[sensorNumber],initCond);
 800608e:	7aba      	ldrb	r2, [r7, #10]
 8006090:	697b      	ldr	r3, [r7, #20]
 8006092:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006096:	4618      	mov	r0, r3
 8006098:	ed97 0a01 	vldr	s0, [r7, #4]
 800609c:	f000 f9cc 	bl	8006438 <OFFSET_setInitCond>
 80060a0:	e00d      	b.n	80060be <HAL_setOffsetInitCond+0x4e>
    }
  else if(sensorType == HAL_SensorType_Voltage)
 80060a2:	7afb      	ldrb	r3, [r7, #11]
 80060a4:	2b01      	cmp	r3, #1
 80060a6:	d10a      	bne.n	80060be <HAL_setOffsetInitCond+0x4e>
    {
      OFFSET_setInitCond(obj->offsetHandle_V[sensorNumber],initCond);
 80060a8:	7abb      	ldrb	r3, [r7, #10]
 80060aa:	697a      	ldr	r2, [r7, #20]
 80060ac:	331a      	adds	r3, #26
 80060ae:	009b      	lsls	r3, r3, #2
 80060b0:	4413      	add	r3, r2
 80060b2:	685b      	ldr	r3, [r3, #4]
 80060b4:	4618      	mov	r0, r3
 80060b6:	ed97 0a01 	vldr	s0, [r7, #4]
 80060ba:	f000 f9bd 	bl	8006438 <OFFSET_setInitCond>
    }

  return;
 80060be:	bf00      	nop
} // end of HAL_setOffsetInitCond() function
 80060c0:	3718      	adds	r7, #24
 80060c2:	46bd      	mov	sp, r7
 80060c4:	bd80      	pop	{r7, pc}
 80060c6:	bf00      	nop

080060c8 <HAL_setOffsetValue>:
//! \param[in] value         The initial offset value
static inline void HAL_setOffsetValue(HAL_Handle handle,
                                      const HAL_SensorType_e sensorType,
                                      const uint_least8_t sensorNumber,
                                      const float_t value)//! \Mod By Dl.K
{
 80060c8:	b580      	push	{r7, lr}
 80060ca:	b086      	sub	sp, #24
 80060cc:	af00      	add	r7, sp, #0
 80060ce:	60f8      	str	r0, [r7, #12]
 80060d0:	460b      	mov	r3, r1
 80060d2:	ed87 0a01 	vstr	s0, [r7, #4]
 80060d6:	72fb      	strb	r3, [r7, #11]
 80060d8:	4613      	mov	r3, r2
 80060da:	72bb      	strb	r3, [r7, #10]
  HAL_Obj *obj = (HAL_Obj *)handle;
 80060dc:	68fb      	ldr	r3, [r7, #12]
 80060de:	617b      	str	r3, [r7, #20]

  if(sensorType == HAL_SensorType_Current)
 80060e0:	7afb      	ldrb	r3, [r7, #11]
 80060e2:	2b00      	cmp	r3, #0
 80060e4:	d109      	bne.n	80060fa <HAL_setOffsetValue+0x32>
    {
      OFFSET_setOffset(obj->offsetHandle_I[sensorNumber],value);
 80060e6:	7aba      	ldrb	r2, [r7, #10]
 80060e8:	697b      	ldr	r3, [r7, #20]
 80060ea:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80060ee:	4618      	mov	r0, r3
 80060f0:	ed97 0a01 	vldr	s0, [r7, #4]
 80060f4:	f000 f9b8 	bl	8006468 <OFFSET_setOffset>
 80060f8:	e00d      	b.n	8006116 <HAL_setOffsetValue+0x4e>
    }
  else if(sensorType == HAL_SensorType_Voltage)
 80060fa:	7afb      	ldrb	r3, [r7, #11]
 80060fc:	2b01      	cmp	r3, #1
 80060fe:	d10a      	bne.n	8006116 <HAL_setOffsetValue+0x4e>
    {
      OFFSET_setOffset(obj->offsetHandle_V[sensorNumber],value);
 8006100:	7abb      	ldrb	r3, [r7, #10]
 8006102:	697a      	ldr	r2, [r7, #20]
 8006104:	331a      	adds	r3, #26
 8006106:	009b      	lsls	r3, r3, #2
 8006108:	4413      	add	r3, r2
 800610a:	685b      	ldr	r3, [r3, #4]
 800610c:	4618      	mov	r0, r3
 800610e:	ed97 0a01 	vldr	s0, [r7, #4]
 8006112:	f000 f9a9 	bl	8006468 <OFFSET_setOffset>
    }

  return;
 8006116:	bf00      	nop
} // end of HAL_setOffsetValue() function
 8006118:	3718      	adds	r7, #24
 800611a:	46bd      	mov	sp, r7
 800611c:	bd80      	pop	{r7, pc}
 800611e:	bf00      	nop

08006120 <HAL_setVoltageScaleFactor>:

//! \brief     Sets the voltage scale factor in the hardware abstraction layer
//! \param[in] handle      The hardware abstraction layer (HAL) handle
//! \param[in] voltage_sf  The voltage scale factor
static inline void HAL_setVoltageScaleFactor(HAL_Handle handle,const float_t voltage_sf)//! \Mod By Dl.K
{
 8006120:	b480      	push	{r7}
 8006122:	b085      	sub	sp, #20
 8006124:	af00      	add	r7, sp, #0
 8006126:	6078      	str	r0, [r7, #4]
 8006128:	ed87 0a00 	vstr	s0, [r7]
  HAL_Obj *obj = (HAL_Obj *)handle;
 800612c:	687b      	ldr	r3, [r7, #4]
 800612e:	60fb      	str	r3, [r7, #12]
  
  obj->voltage_sf = voltage_sf;
 8006130:	68fb      	ldr	r3, [r7, #12]
 8006132:	683a      	ldr	r2, [r7, #0]
 8006134:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc

  return;
 8006138:	bf00      	nop
} // end of HAL_setVoltageScaleFactor() function
 800613a:	3714      	adds	r7, #20
 800613c:	46bd      	mov	sp, r7
 800613e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006142:	4770      	bx	lr

08006144 <HAL_init>:

// **************************************************************************
// the functions

HAL_Handle HAL_init(void *pMemory,const size_t numBytes)
{
 8006144:	b590      	push	{r4, r7, lr}
 8006146:	b087      	sub	sp, #28
 8006148:	af00      	add	r7, sp, #0
 800614a:	6078      	str	r0, [r7, #4]
 800614c:	6039      	str	r1, [r7, #0]
  uint_least8_t cnt;
  HAL_Handle handle;
  HAL_Obj *obj;


  if(numBytes < sizeof(HAL_Obj))
 800614e:	683b      	ldr	r3, [r7, #0]
 8006150:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8006154:	d201      	bcs.n	800615a <HAL_init+0x16>
    return((HAL_Handle)NULL);
 8006156:	2300      	movs	r3, #0
 8006158:	e036      	b.n	80061c8 <HAL_init+0x84>


  // assign the handle
  handle = (HAL_Handle)pMemory;
 800615a:	687b      	ldr	r3, [r7, #4]
 800615c:	613b      	str	r3, [r7, #16]


  // assign the object
  obj = (HAL_Obj *)handle;
 800615e:	693b      	ldr	r3, [r7, #16]
 8006160:	60fb      	str	r3, [r7, #12]

  // initialize the current offset estimator handles
  for(cnt=0;cnt<USER_NUM_CURRENT_SENSORS;cnt++)
 8006162:	2300      	movs	r3, #0
 8006164:	75fb      	strb	r3, [r7, #23]
 8006166:	e011      	b.n	800618c <HAL_init+0x48>
    {
      obj->offsetHandle_I[cnt] = OFFSET_init(&obj->offset_I[cnt],sizeof(obj->offset_I[cnt]));
 8006168:	7dfc      	ldrb	r4, [r7, #23]
 800616a:	7dfb      	ldrb	r3, [r7, #23]
 800616c:	015b      	lsls	r3, r3, #5
 800616e:	3308      	adds	r3, #8
 8006170:	68fa      	ldr	r2, [r7, #12]
 8006172:	4413      	add	r3, r2
 8006174:	3304      	adds	r3, #4
 8006176:	4618      	mov	r0, r3
 8006178:	2120      	movs	r1, #32
 800617a:	f000 f917 	bl	80063ac <OFFSET_init>
 800617e:	4602      	mov	r2, r0
 8006180:	68fb      	ldr	r3, [r7, #12]
 8006182:	f843 2024 	str.w	r2, [r3, r4, lsl #2]

  // assign the object
  obj = (HAL_Obj *)handle;

  // initialize the current offset estimator handles
  for(cnt=0;cnt<USER_NUM_CURRENT_SENSORS;cnt++)
 8006186:	7dfb      	ldrb	r3, [r7, #23]
 8006188:	3301      	adds	r3, #1
 800618a:	75fb      	strb	r3, [r7, #23]
 800618c:	7dfb      	ldrb	r3, [r7, #23]
 800618e:	2b02      	cmp	r3, #2
 8006190:	d9ea      	bls.n	8006168 <HAL_init+0x24>
      obj->offsetHandle_I[cnt] = OFFSET_init(&obj->offset_I[cnt],sizeof(obj->offset_I[cnt]));
    }


  // initialize the voltage offset estimator handles
  for(cnt=0;cnt<USER_NUM_VOLTAGE_SENSORS;cnt++)
 8006192:	2300      	movs	r3, #0
 8006194:	75fb      	strb	r3, [r7, #23]
 8006196:	e013      	b.n	80061c0 <HAL_init+0x7c>
    {
      obj->offsetHandle_V[cnt] = OFFSET_init(&obj->offset_V[cnt],sizeof(obj->offset_V[cnt]));
 8006198:	7dfc      	ldrb	r4, [r7, #23]
 800619a:	7dfb      	ldrb	r3, [r7, #23]
 800619c:	015b      	lsls	r3, r3, #5
 800619e:	3378      	adds	r3, #120	; 0x78
 80061a0:	68fa      	ldr	r2, [r7, #12]
 80061a2:	4413      	add	r3, r2
 80061a4:	4618      	mov	r0, r3
 80061a6:	2120      	movs	r1, #32
 80061a8:	f000 f900 	bl	80063ac <OFFSET_init>
 80061ac:	4601      	mov	r1, r0
 80061ae:	68fa      	ldr	r2, [r7, #12]
 80061b0:	f104 031a 	add.w	r3, r4, #26
 80061b4:	009b      	lsls	r3, r3, #2
 80061b6:	4413      	add	r3, r2
 80061b8:	6059      	str	r1, [r3, #4]
      obj->offsetHandle_I[cnt] = OFFSET_init(&obj->offset_I[cnt],sizeof(obj->offset_I[cnt]));
    }


  // initialize the voltage offset estimator handles
  for(cnt=0;cnt<USER_NUM_VOLTAGE_SENSORS;cnt++)
 80061ba:	7dfb      	ldrb	r3, [r7, #23]
 80061bc:	3301      	adds	r3, #1
 80061be:	75fb      	strb	r3, [r7, #23]
 80061c0:	7dfb      	ldrb	r3, [r7, #23]
 80061c2:	2b02      	cmp	r3, #2
 80061c4:	d9e8      	bls.n	8006198 <HAL_init+0x54>
    {
      obj->offsetHandle_V[cnt] = OFFSET_init(&obj->offset_V[cnt],sizeof(obj->offset_V[cnt]));
    }


  return(handle);
 80061c6:	693b      	ldr	r3, [r7, #16]
} // end of HAL_init() function
 80061c8:	4618      	mov	r0, r3
 80061ca:	371c      	adds	r7, #28
 80061cc:	46bd      	mov	sp, r7
 80061ce:	bd90      	pop	{r4, r7, pc}

080061d0 <HAL_setParams>:


void HAL_setParams(HAL_Handle handle,const USER_Params *pUserParams)
{
 80061d0:	b580      	push	{r7, lr}
 80061d2:	b086      	sub	sp, #24
 80061d4:	af00      	add	r7, sp, #0
 80061d6:	6078      	str	r0, [r7, #4]
 80061d8:	6039      	str	r1, [r7, #0]
  uint_least8_t cnt;
//  HAL_Obj *obj = (HAL_Obj *)handle;
	float_t beta_lp_pu = (pUserParams->offsetPole_rps/(float_t)pUserParams->ctrlFreq_Hz);//! \Mod By Dl.K
 80061da:	683b      	ldr	r3, [r7, #0]
 80061dc:	ed93 7a06 	vldr	s14, [r3, #24]
 80061e0:	683b      	ldr	r3, [r7, #0]
 80061e2:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 80061e6:	ee07 3a90 	vmov	s15, r3
 80061ea:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80061ee:	eec7 7a27 	vdiv.f32	s15, s14, s15
 80061f2:	edc7 7a04 	vstr	s15, [r7, #16]

  HAL_setNumCurrentSensors(handle,pUserParams->numCurrentSensors);
 80061f6:	683b      	ldr	r3, [r7, #0]
 80061f8:	7d9b      	ldrb	r3, [r3, #22]
 80061fa:	6878      	ldr	r0, [r7, #4]
 80061fc:	4619      	mov	r1, r3
 80061fe:	f7ff fee7 	bl	8005fd0 <HAL_setNumCurrentSensors>
  HAL_setNumVoltageSensors(handle,pUserParams->numVoltageSensors);
 8006202:	683b      	ldr	r3, [r7, #0]
 8006204:	7ddb      	ldrb	r3, [r3, #23]
 8006206:	6878      	ldr	r0, [r7, #4]
 8006208:	4619      	mov	r1, r3
 800620a:	f7ff fef3 	bl	8005ff4 <HAL_setNumVoltageSensors>


  for(cnt=0;cnt<HAL_getNumCurrentSensors(handle);cnt++)
 800620e:	2300      	movs	r3, #0
 8006210:	75fb      	strb	r3, [r7, #23]
 8006212:	e01a      	b.n	800624a <HAL_setParams+0x7a>
	{
	  HAL_setOffsetBeta_lp_pu(handle,HAL_SensorType_Current,cnt,beta_lp_pu);
 8006214:	7dfb      	ldrb	r3, [r7, #23]
 8006216:	6878      	ldr	r0, [r7, #4]
 8006218:	2100      	movs	r1, #0
 800621a:	461a      	mov	r2, r3
 800621c:	ed97 0a04 	vldr	s0, [r7, #16]
 8006220:	f7ff fefa 	bl	8006018 <HAL_setOffsetBeta_lp_pu>
	  HAL_setOffsetInitCond(handle,HAL_SensorType_Current,cnt,(0.0f));
 8006224:	7dfb      	ldrb	r3, [r7, #23]
 8006226:	6878      	ldr	r0, [r7, #4]
 8006228:	2100      	movs	r1, #0
 800622a:	461a      	mov	r2, r3
 800622c:	ed9f 0a52 	vldr	s0, [pc, #328]	; 8006378 <HAL_setParams+0x1a8>
 8006230:	f7ff ff1e 	bl	8006070 <HAL_setOffsetInitCond>
	  HAL_setOffsetValue(handle,HAL_SensorType_Current,cnt,(0.0f));
 8006234:	7dfb      	ldrb	r3, [r7, #23]
 8006236:	6878      	ldr	r0, [r7, #4]
 8006238:	2100      	movs	r1, #0
 800623a:	461a      	mov	r2, r3
 800623c:	ed9f 0a4e 	vldr	s0, [pc, #312]	; 8006378 <HAL_setParams+0x1a8>
 8006240:	f7ff ff42 	bl	80060c8 <HAL_setOffsetValue>

  HAL_setNumCurrentSensors(handle,pUserParams->numCurrentSensors);
  HAL_setNumVoltageSensors(handle,pUserParams->numVoltageSensors);


  for(cnt=0;cnt<HAL_getNumCurrentSensors(handle);cnt++)
 8006244:	7dfb      	ldrb	r3, [r7, #23]
 8006246:	3301      	adds	r3, #1
 8006248:	75fb      	strb	r3, [r7, #23]
 800624a:	6878      	ldr	r0, [r7, #4]
 800624c:	f7ff fe66 	bl	8005f1c <HAL_getNumCurrentSensors>
 8006250:	4603      	mov	r3, r0
 8006252:	461a      	mov	r2, r3
 8006254:	7dfb      	ldrb	r3, [r7, #23]
 8006256:	4293      	cmp	r3, r2
 8006258:	d3dc      	bcc.n	8006214 <HAL_setParams+0x44>
	  HAL_setOffsetInitCond(handle,HAL_SensorType_Current,cnt,(0.0f));
	  HAL_setOffsetValue(handle,HAL_SensorType_Current,cnt,(0.0f));
	}//! \Mod By Dl.K


  for(cnt=0;cnt<HAL_getNumVoltageSensors(handle);cnt++)
 800625a:	2300      	movs	r3, #0
 800625c:	75fb      	strb	r3, [r7, #23]
 800625e:	e01a      	b.n	8006296 <HAL_setParams+0xc6>
    {
      HAL_setOffsetBeta_lp_pu(handle,HAL_SensorType_Voltage,cnt,beta_lp_pu);
 8006260:	7dfb      	ldrb	r3, [r7, #23]
 8006262:	6878      	ldr	r0, [r7, #4]
 8006264:	2101      	movs	r1, #1
 8006266:	461a      	mov	r2, r3
 8006268:	ed97 0a04 	vldr	s0, [r7, #16]
 800626c:	f7ff fed4 	bl	8006018 <HAL_setOffsetBeta_lp_pu>
      HAL_setOffsetInitCond(handle,HAL_SensorType_Voltage,cnt,(0.0f));
 8006270:	7dfb      	ldrb	r3, [r7, #23]
 8006272:	6878      	ldr	r0, [r7, #4]
 8006274:	2101      	movs	r1, #1
 8006276:	461a      	mov	r2, r3
 8006278:	ed9f 0a3f 	vldr	s0, [pc, #252]	; 8006378 <HAL_setParams+0x1a8>
 800627c:	f7ff fef8 	bl	8006070 <HAL_setOffsetInitCond>
      HAL_setOffsetValue(handle,HAL_SensorType_Voltage,cnt,(0.0f));
 8006280:	7dfb      	ldrb	r3, [r7, #23]
 8006282:	6878      	ldr	r0, [r7, #4]
 8006284:	2101      	movs	r1, #1
 8006286:	461a      	mov	r2, r3
 8006288:	ed9f 0a3b 	vldr	s0, [pc, #236]	; 8006378 <HAL_setParams+0x1a8>
 800628c:	f7ff ff1c 	bl	80060c8 <HAL_setOffsetValue>
	  HAL_setOffsetInitCond(handle,HAL_SensorType_Current,cnt,(0.0f));
	  HAL_setOffsetValue(handle,HAL_SensorType_Current,cnt,(0.0f));
	}//! \Mod By Dl.K


  for(cnt=0;cnt<HAL_getNumVoltageSensors(handle);cnt++)
 8006290:	7dfb      	ldrb	r3, [r7, #23]
 8006292:	3301      	adds	r3, #1
 8006294:	75fb      	strb	r3, [r7, #23]
 8006296:	6878      	ldr	r0, [r7, #4]
 8006298:	f7ff fe50 	bl	8005f3c <HAL_getNumVoltageSensors>
 800629c:	4603      	mov	r3, r0
 800629e:	461a      	mov	r2, r3
 80062a0:	7dfb      	ldrb	r3, [r7, #23]
 80062a2:	4293      	cmp	r3, r2
 80062a4:	d3dc      	bcc.n	8006260 <HAL_setParams+0x90>
      HAL_setOffsetBeta_lp_pu(handle,HAL_SensorType_Voltage,cnt,beta_lp_pu);
      HAL_setOffsetInitCond(handle,HAL_SensorType_Voltage,cnt,(0.0f));
      HAL_setOffsetValue(handle,HAL_SensorType_Voltage,cnt,(0.0f));
    }//! \Mod By Dl.K

	  HAL_setBias(handle,HAL_SensorType_Current,0,((I_A_offset)*(pUserParams->current_sf)));
 80062a6:	683b      	ldr	r3, [r7, #0]
 80062a8:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 80062ac:	ed9f 7a33 	vldr	s14, [pc, #204]	; 800637c <HAL_setParams+0x1ac>
 80062b0:	ee67 7a87 	vmul.f32	s15, s15, s14
 80062b4:	6878      	ldr	r0, [r7, #4]
 80062b6:	2100      	movs	r1, #0
 80062b8:	2200      	movs	r2, #0
 80062ba:	eeb0 0a67 	vmov.f32	s0, s15
 80062be:	f7ff fe4d 	bl	8005f5c <HAL_setBias>
	  HAL_setBias(handle,HAL_SensorType_Current,1,((I_B_offset)*(pUserParams->current_sf)));
 80062c2:	683b      	ldr	r3, [r7, #0]
 80062c4:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 80062c8:	ed9f 7a2c 	vldr	s14, [pc, #176]	; 800637c <HAL_setParams+0x1ac>
 80062cc:	ee67 7a87 	vmul.f32	s15, s15, s14
 80062d0:	6878      	ldr	r0, [r7, #4]
 80062d2:	2100      	movs	r1, #0
 80062d4:	2201      	movs	r2, #1
 80062d6:	eeb0 0a67 	vmov.f32	s0, s15
 80062da:	f7ff fe3f 	bl	8005f5c <HAL_setBias>
	  HAL_setBias(handle,HAL_SensorType_Current,2,((I_C_offset)*(pUserParams->current_sf)));
 80062de:	683b      	ldr	r3, [r7, #0]
 80062e0:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 80062e4:	ed9f 7a25 	vldr	s14, [pc, #148]	; 800637c <HAL_setParams+0x1ac>
 80062e8:	ee67 7a87 	vmul.f32	s15, s15, s14
 80062ec:	6878      	ldr	r0, [r7, #4]
 80062ee:	2100      	movs	r1, #0
 80062f0:	2202      	movs	r2, #2
 80062f2:	eeb0 0a67 	vmov.f32	s0, s15
 80062f6:	f7ff fe31 	bl	8005f5c <HAL_setBias>


   float_t current_sf = (pUserParams->current_sf);//! \Mod By Dl.K
 80062fa:	683b      	ldr	r3, [r7, #0]
 80062fc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80062fe:	60fb      	str	r3, [r7, #12]
  HAL_setCurrentScaleFactor(handle,current_sf);
 8006300:	6878      	ldr	r0, [r7, #4]
 8006302:	ed97 0a03 	vldr	s0, [r7, #12]
 8006306:	f7ff fe51 	bl	8005fac <HAL_setCurrentScaleFactor>
 

	  HAL_setBias(handle,HAL_SensorType_Voltage,0,((V_A_offset)*(pUserParams->voltage_sf)));
 800630a:	683b      	ldr	r3, [r7, #0]
 800630c:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 8006310:	ed9f 7a1b 	vldr	s14, [pc, #108]	; 8006380 <HAL_setParams+0x1b0>
 8006314:	ee67 7a87 	vmul.f32	s15, s15, s14
 8006318:	6878      	ldr	r0, [r7, #4]
 800631a:	2101      	movs	r1, #1
 800631c:	2200      	movs	r2, #0
 800631e:	eeb0 0a67 	vmov.f32	s0, s15
 8006322:	f7ff fe1b 	bl	8005f5c <HAL_setBias>
	  HAL_setBias(handle,HAL_SensorType_Voltage,1,((V_B_offset)*(pUserParams->voltage_sf)));
 8006326:	683b      	ldr	r3, [r7, #0]
 8006328:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 800632c:	ed9f 7a14 	vldr	s14, [pc, #80]	; 8006380 <HAL_setParams+0x1b0>
 8006330:	ee67 7a87 	vmul.f32	s15, s15, s14
 8006334:	6878      	ldr	r0, [r7, #4]
 8006336:	2101      	movs	r1, #1
 8006338:	2201      	movs	r2, #1
 800633a:	eeb0 0a67 	vmov.f32	s0, s15
 800633e:	f7ff fe0d 	bl	8005f5c <HAL_setBias>
	  HAL_setBias(handle,HAL_SensorType_Voltage,2,((V_C_offset)*(pUserParams->voltage_sf)));
 8006342:	683b      	ldr	r3, [r7, #0]
 8006344:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 8006348:	ed9f 7a0d 	vldr	s14, [pc, #52]	; 8006380 <HAL_setParams+0x1b0>
 800634c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8006350:	6878      	ldr	r0, [r7, #4]
 8006352:	2101      	movs	r1, #1
 8006354:	2202      	movs	r2, #2
 8006356:	eeb0 0a67 	vmov.f32	s0, s15
 800635a:	f7ff fdff 	bl	8005f5c <HAL_setBias>


	float_t voltage_sf = (pUserParams->voltage_sf);//! \Mod By Dl.K
 800635e:	683b      	ldr	r3, [r7, #0]
 8006360:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8006362:	60bb      	str	r3, [r7, #8]
  HAL_setVoltageScaleFactor(handle,voltage_sf);
 8006364:	6878      	ldr	r0, [r7, #4]
 8006366:	ed97 0a02 	vldr	s0, [r7, #8]
 800636a:	f7ff fed9 	bl	8006120 <HAL_setVoltageScaleFactor>
 
 return;
 800636e:	bf00      	nop
} // end of HAL_setParams() function
 8006370:	3718      	adds	r7, #24
 8006372:	46bd      	mov	sp, r7
 8006374:	bd80      	pop	{r7, pc}
 8006376:	bf00      	nop
 8006378:	00000000 	.word	0x00000000
 800637c:	3f41f06f 	.word	0x3f41f06f
 8006380:	3f14f206 	.word	0x3f14f206

08006384 <IPARK_init>:

// **************************************************************************
// the functions

IPARK_Handle IPARK_init(void *pMemory,const size_t numBytes)
{
 8006384:	b480      	push	{r7}
 8006386:	b085      	sub	sp, #20
 8006388:	af00      	add	r7, sp, #0
 800638a:	6078      	str	r0, [r7, #4]
 800638c:	6039      	str	r1, [r7, #0]
  IPARK_Handle handle;

  if(numBytes < sizeof(IPARK_Obj))
 800638e:	683b      	ldr	r3, [r7, #0]
 8006390:	2b07      	cmp	r3, #7
 8006392:	d801      	bhi.n	8006398 <IPARK_init+0x14>
    return((IPARK_Handle)NULL);
 8006394:	2300      	movs	r3, #0
 8006396:	e002      	b.n	800639e <IPARK_init+0x1a>

  // assign the handle
  handle = (IPARK_Handle)pMemory;
 8006398:	687b      	ldr	r3, [r7, #4]
 800639a:	60fb      	str	r3, [r7, #12]

  return(handle);
 800639c:	68fb      	ldr	r3, [r7, #12]
} // end of IPARK_init() function
 800639e:	4618      	mov	r0, r3
 80063a0:	3714      	adds	r7, #20
 80063a2:	46bd      	mov	sp, r7
 80063a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80063a8:	4770      	bx	lr
 80063aa:	bf00      	nop

080063ac <OFFSET_init>:
  return(b0);
} // end of OFFSET_getBeta() function


OFFSET_Handle OFFSET_init(void *pMemory,const size_t numBytes)
{
 80063ac:	b580      	push	{r7, lr}
 80063ae:	b084      	sub	sp, #16
 80063b0:	af00      	add	r7, sp, #0
 80063b2:	6078      	str	r0, [r7, #4]
 80063b4:	6039      	str	r1, [r7, #0]
  OFFSET_Handle handle;
  OFFSET_Obj *obj;

  if(numBytes < sizeof(OFFSET_Obj))
 80063b6:	683b      	ldr	r3, [r7, #0]
 80063b8:	2b1f      	cmp	r3, #31
 80063ba:	d801      	bhi.n	80063c0 <OFFSET_init+0x14>
    return((OFFSET_Handle)NULL);
 80063bc:	2300      	movs	r3, #0
 80063be:	e00d      	b.n	80063dc <OFFSET_init+0x30>

  // assign the handle
  handle = (OFFSET_Handle)pMemory;
 80063c0:	687b      	ldr	r3, [r7, #4]
 80063c2:	60fb      	str	r3, [r7, #12]
  obj = (OFFSET_Obj *)handle;
 80063c4:	68fb      	ldr	r3, [r7, #12]
 80063c6:	60bb      	str	r3, [r7, #8]

  obj->filterHandle = FILTER_FO_init(&(obj->filter),sizeof(obj->filter));
 80063c8:	68bb      	ldr	r3, [r7, #8]
 80063ca:	3308      	adds	r3, #8
 80063cc:	4618      	mov	r0, r3
 80063ce:	2114      	movs	r1, #20
 80063d0:	f7ff fd52 	bl	8005e78 <FILTER_FO_init>
 80063d4:	4602      	mov	r2, r0
 80063d6:	68bb      	ldr	r3, [r7, #8]
 80063d8:	61da      	str	r2, [r3, #28]

  return(handle);
 80063da:	68fb      	ldr	r3, [r7, #12]
} // end of OFFSET_init() function
 80063dc:	4618      	mov	r0, r3
 80063de:	3710      	adds	r7, #16
 80063e0:	46bd      	mov	sp, r7
 80063e2:	bd80      	pop	{r7, pc}

080063e4 <OFFSET_setBeta>:


void OFFSET_setBeta(OFFSET_Handle handle,const float_t beta)
{
 80063e4:	b580      	push	{r7, lr}
 80063e6:	b086      	sub	sp, #24
 80063e8:	af00      	add	r7, sp, #0
 80063ea:	6078      	str	r0, [r7, #4]
 80063ec:	ed87 0a00 	vstr	s0, [r7]
  OFFSET_Obj *obj = (OFFSET_Obj *)handle;
 80063f0:	687b      	ldr	r3, [r7, #4]
 80063f2:	617b      	str	r3, [r7, #20]
  float_t a1 = (beta - (1.0f));
 80063f4:	edd7 7a00 	vldr	s15, [r7]
 80063f8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 80063fc:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8006400:	edc7 7a04 	vstr	s15, [r7, #16]
  float_t b0 = beta;
 8006404:	683b      	ldr	r3, [r7, #0]
 8006406:	60fb      	str	r3, [r7, #12]
  float_t b1 = 0;
 8006408:	f04f 0300 	mov.w	r3, #0
 800640c:	60bb      	str	r3, [r7, #8]

  FILTER_FO_setDenCoeffs(obj->filterHandle,a1);
 800640e:	697b      	ldr	r3, [r7, #20]
 8006410:	69db      	ldr	r3, [r3, #28]
 8006412:	4618      	mov	r0, r3
 8006414:	ed97 0a04 	vldr	s0, [r7, #16]
 8006418:	f7ff fd42 	bl	8005ea0 <FILTER_FO_setDenCoeffs>
  FILTER_FO_setNumCoeffs(obj->filterHandle,b0,b1);
 800641c:	697b      	ldr	r3, [r7, #20]
 800641e:	69db      	ldr	r3, [r3, #28]
 8006420:	4618      	mov	r0, r3
 8006422:	ed97 0a03 	vldr	s0, [r7, #12]
 8006426:	edd7 0a02 	vldr	s1, [r7, #8]
 800642a:	f7ff fd61 	bl	8005ef0 <FILTER_FO_setNumCoeffs>

  return;
 800642e:	bf00      	nop
} // end of OFFSET_setBeta() function
 8006430:	3718      	adds	r7, #24
 8006432:	46bd      	mov	sp, r7
 8006434:	bd80      	pop	{r7, pc}
 8006436:	bf00      	nop

08006438 <OFFSET_setInitCond>:


void OFFSET_setInitCond(OFFSET_Handle handle,const float_t initCond)
{
 8006438:	b580      	push	{r7, lr}
 800643a:	b084      	sub	sp, #16
 800643c:	af00      	add	r7, sp, #0
 800643e:	6078      	str	r0, [r7, #4]
 8006440:	ed87 0a00 	vstr	s0, [r7]
  OFFSET_Obj *obj = (OFFSET_Obj *)handle;
 8006444:	687b      	ldr	r3, [r7, #4]
 8006446:	60fb      	str	r3, [r7, #12]

  FILTER_FO_setInitialConditions(obj->filterHandle,initCond,initCond);
 8006448:	68fb      	ldr	r3, [r7, #12]
 800644a:	69db      	ldr	r3, [r3, #28]
 800644c:	4618      	mov	r0, r3
 800644e:	ed97 0a00 	vldr	s0, [r7]
 8006452:	edd7 0a00 	vldr	s1, [r7]
 8006456:	f7ff fd35 	bl	8005ec4 <FILTER_FO_setInitialConditions>
  obj->value = initCond;
 800645a:	68fb      	ldr	r3, [r7, #12]
 800645c:	683a      	ldr	r2, [r7, #0]
 800645e:	601a      	str	r2, [r3, #0]

  return;
 8006460:	bf00      	nop
} // end of OFFSET_setInitCond() function
 8006462:	3710      	adds	r7, #16
 8006464:	46bd      	mov	sp, r7
 8006466:	bd80      	pop	{r7, pc}

08006468 <OFFSET_setOffset>:


void OFFSET_setOffset(OFFSET_Handle handle, float_t offsetValue)
{
 8006468:	b480      	push	{r7}
 800646a:	b085      	sub	sp, #20
 800646c:	af00      	add	r7, sp, #0
 800646e:	6078      	str	r0, [r7, #4]
 8006470:	ed87 0a00 	vstr	s0, [r7]
  OFFSET_Obj *obj = (OFFSET_Obj *)handle;
 8006474:	687b      	ldr	r3, [r7, #4]
 8006476:	60fb      	str	r3, [r7, #12]

  obj->value = offsetValue;
 8006478:	68fb      	ldr	r3, [r7, #12]
 800647a:	683a      	ldr	r2, [r7, #0]
 800647c:	601a      	str	r2, [r3, #0]

  return;
 800647e:	bf00      	nop
} // end of OFFSET_setOffset() function
 8006480:	3714      	adds	r7, #20
 8006482:	46bd      	mov	sp, r7
 8006484:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006488:	4770      	bx	lr
 800648a:	bf00      	nop

0800648c <PARK_init>:

// **************************************************************************
// the functions

PARK_Handle PARK_init(void *pMemory,const size_t numBytes)
{
 800648c:	b480      	push	{r7}
 800648e:	b085      	sub	sp, #20
 8006490:	af00      	add	r7, sp, #0
 8006492:	6078      	str	r0, [r7, #4]
 8006494:	6039      	str	r1, [r7, #0]
  PARK_Handle handle;

  if(numBytes < sizeof(PARK_Obj))
 8006496:	683b      	ldr	r3, [r7, #0]
 8006498:	2b07      	cmp	r3, #7
 800649a:	d801      	bhi.n	80064a0 <PARK_init+0x14>
    return((PARK_Handle)NULL);
 800649c:	2300      	movs	r3, #0
 800649e:	e002      	b.n	80064a6 <PARK_init+0x1a>

  // assign the handle
  handle = (PARK_Handle)pMemory;
 80064a0:	687b      	ldr	r3, [r7, #4]
 80064a2:	60fb      	str	r3, [r7, #12]

  return(handle);
 80064a4:	68fb      	ldr	r3, [r7, #12]
} // end of PARK_init() function
 80064a6:	4618      	mov	r0, r3
 80064a8:	3714      	adds	r7, #20
 80064aa:	46bd      	mov	sp, r7
 80064ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80064b0:	4770      	bx	lr
 80064b2:	bf00      	nop

080064b4 <PID_setFbackValue>:

//! \brief     Sets the feedback value in the PID controller
//! \param[in] handle      The PID controller handle
//! \param[in] fbackValue  The feedback value
static inline void PID_setFbackValue(PID_Handle handle,const float_t fbackValue)//! \Mod By Dl.K
{
 80064b4:	b480      	push	{r7}
 80064b6:	b085      	sub	sp, #20
 80064b8:	af00      	add	r7, sp, #0
 80064ba:	6078      	str	r0, [r7, #4]
 80064bc:	ed87 0a00 	vstr	s0, [r7]
  PID_Obj *obj = (PID_Obj *)handle;
 80064c0:	687b      	ldr	r3, [r7, #4]
 80064c2:	60fb      	str	r3, [r7, #12]

  obj->fbackValue = fbackValue;
 80064c4:	68fb      	ldr	r3, [r7, #12]
 80064c6:	683a      	ldr	r2, [r7, #0]
 80064c8:	615a      	str	r2, [r3, #20]

  return;
 80064ca:	bf00      	nop
} // end of PID_setFbackValue() function
 80064cc:	3714      	adds	r7, #20
 80064ce:	46bd      	mov	sp, r7
 80064d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80064d4:	4770      	bx	lr
 80064d6:	bf00      	nop

080064d8 <PID_setRefValue>:

//! \brief     Sets the reference value in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] refValue   The reference value
static inline void PID_setRefValue(PID_Handle handle,const float_t refValue)//! \Mod By Dl.K
{
 80064d8:	b480      	push	{r7}
 80064da:	b085      	sub	sp, #20
 80064dc:	af00      	add	r7, sp, #0
 80064de:	6078      	str	r0, [r7, #4]
 80064e0:	ed87 0a00 	vstr	s0, [r7]
  PID_Obj *obj = (PID_Obj *)handle;
 80064e4:	687b      	ldr	r3, [r7, #4]
 80064e6:	60fb      	str	r3, [r7, #12]

  obj->refValue = refValue;
 80064e8:	68fb      	ldr	r3, [r7, #12]
 80064ea:	683a      	ldr	r2, [r7, #0]
 80064ec:	611a      	str	r2, [r3, #16]

  return;
 80064ee:	bf00      	nop
} // end of PID_setRefValue() function
 80064f0:	3714      	adds	r7, #20
 80064f2:	46bd      	mov	sp, r7
 80064f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80064f8:	4770      	bx	lr
 80064fa:	bf00      	nop

080064fc <PID_setUi>:

//! \brief     Sets the integrator start value in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] Ui         The integral start value for the PID controller
static inline void PID_setUi(PID_Handle handle,const float_t Ui)//! \Mod By Dl.K
{
 80064fc:	b480      	push	{r7}
 80064fe:	b085      	sub	sp, #20
 8006500:	af00      	add	r7, sp, #0
 8006502:	6078      	str	r0, [r7, #4]
 8006504:	ed87 0a00 	vstr	s0, [r7]
  PID_Obj *obj = (PID_Obj *)handle;
 8006508:	687b      	ldr	r3, [r7, #4]
 800650a:	60fb      	str	r3, [r7, #12]

  obj->Ui = Ui;
 800650c:	68fb      	ldr	r3, [r7, #12]
 800650e:	683a      	ldr	r2, [r7, #0]
 8006510:	60da      	str	r2, [r3, #12]

  return;
 8006512:	bf00      	nop
} // end of PID_setUi() function
 8006514:	3714      	adds	r7, #20
 8006516:	46bd      	mov	sp, r7
 8006518:	f85d 7b04 	ldr.w	r7, [sp], #4
 800651c:	4770      	bx	lr
 800651e:	bf00      	nop

08006520 <PID_init>:

// **************************************************************************
// the functions

PID_Handle PID_init(void *pMemory,const size_t numBytes)
{
 8006520:	b580      	push	{r7, lr}
 8006522:	b084      	sub	sp, #16
 8006524:	af00      	add	r7, sp, #0
 8006526:	6078      	str	r0, [r7, #4]
 8006528:	6039      	str	r1, [r7, #0]
  PID_Handle handle;


  if(numBytes < sizeof(PID_Obj))
 800652a:	683b      	ldr	r3, [r7, #0]
 800652c:	2b1f      	cmp	r3, #31
 800652e:	d801      	bhi.n	8006534 <PID_init+0x14>
    return((PID_Handle)NULL);
 8006530:	2300      	movs	r3, #0
 8006532:	e011      	b.n	8006558 <PID_init+0x38>

  // assign the handle
  handle = (PID_Handle)pMemory;
 8006534:	687b      	ldr	r3, [r7, #4]
 8006536:	60fb      	str	r3, [r7, #12]

  // set some defaults
  PID_setUi(handle,(0.0f));
 8006538:	68f8      	ldr	r0, [r7, #12]
 800653a:	ed9f 0a09 	vldr	s0, [pc, #36]	; 8006560 <PID_init+0x40>
 800653e:	f7ff ffdd 	bl	80064fc <PID_setUi>
  PID_setRefValue(handle,(0.0f));
 8006542:	68f8      	ldr	r0, [r7, #12]
 8006544:	ed9f 0a06 	vldr	s0, [pc, #24]	; 8006560 <PID_init+0x40>
 8006548:	f7ff ffc6 	bl	80064d8 <PID_setRefValue>
  PID_setFbackValue(handle,(0.0f));
 800654c:	68f8      	ldr	r0, [r7, #12]
 800654e:	ed9f 0a04 	vldr	s0, [pc, #16]	; 8006560 <PID_init+0x40>
 8006552:	f7ff ffaf 	bl	80064b4 <PID_setFbackValue>

  return(handle);
 8006556:	68fb      	ldr	r3, [r7, #12]
} // end of PID_init() function
 8006558:	4618      	mov	r0, r3
 800655a:	3710      	adds	r7, #16
 800655c:	46bd      	mov	sp, r7
 800655e:	bd80      	pop	{r7, pc}
 8006560:	00000000 	.word	0x00000000

08006564 <RAMPGEN_Init>:
-------------------------------------------------------------------------------------*/

#include "modules/rampgen/rampgen.h"

RAMPGEN_Handle RAMPGEN_Init(void *pMemory, const size_t numBytes)//! \Mod By Dl.K
{
 8006564:	b480      	push	{r7}
 8006566:	b085      	sub	sp, #20
 8006568:	af00      	add	r7, sp, #0
 800656a:	6078      	str	r0, [r7, #4]
 800656c:	6039      	str	r1, [r7, #0]
	RAMPGEN_Handle handle;

	if (numBytes < sizeof(RAMPGEN_Obj))
 800656e:	683b      	ldr	r3, [r7, #0]
 8006570:	2b17      	cmp	r3, #23
 8006572:	d801      	bhi.n	8006578 <RAMPGEN_Init+0x14>
		return((RAMPGEN_Handle)NULL);
 8006574:	2300      	movs	r3, #0
 8006576:	e01a      	b.n	80065ae <RAMPGEN_Init+0x4a>

	// assign the handle
	handle = (RAMPGEN_Handle)pMemory;
 8006578:	687b      	ldr	r3, [r7, #4]
 800657a:	60fb      	str	r3, [r7, #12]

	handle->Freq = (0.0);
 800657c:	68fb      	ldr	r3, [r7, #12]
 800657e:	f04f 0200 	mov.w	r2, #0
 8006582:	601a      	str	r2, [r3, #0]
	handle->StepAngleMax = (0.0);
 8006584:	68fb      	ldr	r3, [r7, #12]
 8006586:	f04f 0200 	mov.w	r2, #0
 800658a:	605a      	str	r2, [r3, #4]
	handle->Angle = (0.0);
 800658c:	68fb      	ldr	r3, [r7, #12]
 800658e:	f04f 0200 	mov.w	r2, #0
 8006592:	609a      	str	r2, [r3, #8]
	handle->Gain = (1.0);
 8006594:	68fb      	ldr	r3, [r7, #12]
 8006596:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 800659a:	60da      	str	r2, [r3, #12]
	handle->Out = (0.0);
 800659c:	68fb      	ldr	r3, [r7, #12]
 800659e:	f04f 0200 	mov.w	r2, #0
 80065a2:	611a      	str	r2, [r3, #16]
	handle->Offset = (0.75);
 80065a4:	68fb      	ldr	r3, [r7, #12]
 80065a6:	f04f 527d 	mov.w	r2, #1061158912	; 0x3f400000
 80065aa:	615a      	str	r2, [r3, #20]

	return(handle);
 80065ac:	68fb      	ldr	r3, [r7, #12]
}
 80065ae:	4618      	mov	r0, r3
 80065b0:	3714      	adds	r7, #20
 80065b2:	46bd      	mov	sp, r7
 80065b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80065b8:	4770      	bx	lr
 80065ba:	bf00      	nop

080065bc <RMP_CNTL_Init>:
-------------------------------------------------------------------------------------*/

#include "modules/rmp_cntl/rmp_cntl.h"

RMPCNTL_Handle RMP_CNTL_Init(void *pMemory, const size_t numBytes)//! \Mod By Dl.K
{
 80065bc:	b480      	push	{r7}
 80065be:	b085      	sub	sp, #20
 80065c0:	af00      	add	r7, sp, #0
 80065c2:	6078      	str	r0, [r7, #4]
 80065c4:	6039      	str	r1, [r7, #0]
	RMPCNTL_Handle handle;

	if (numBytes < sizeof(RMPCNTL_Obj))
 80065c6:	683b      	ldr	r3, [r7, #0]
 80065c8:	2b1b      	cmp	r3, #27
 80065ca:	d801      	bhi.n	80065d0 <RMP_CNTL_Init+0x14>
		return((RMPCNTL_Handle)NULL);
 80065cc:	2300      	movs	r3, #0
 80065ce:	e01a      	b.n	8006606 <RMP_CNTL_Init+0x4a>

	// assign the handle
	handle = (RMPCNTL_Handle)pMemory;
 80065d0:	687b      	ldr	r3, [r7, #4]
 80065d2:	60fb      	str	r3, [r7, #12]

	handle->TargetValue = (0.0f);
 80065d4:	68fb      	ldr	r3, [r7, #12]
 80065d6:	f04f 0200 	mov.w	r2, #0
 80065da:	601a      	str	r2, [r3, #0]
	handle->RampDelayMax = 150;
 80065dc:	68fb      	ldr	r3, [r7, #12]
 80065de:	2296      	movs	r2, #150	; 0x96
 80065e0:	605a      	str	r2, [r3, #4]
	handle->RampLowLimit = (-1.0f);
 80065e2:	68fb      	ldr	r3, [r7, #12]
 80065e4:	4a0b      	ldr	r2, [pc, #44]	; (8006614 <RMP_CNTL_Init+0x58>)
 80065e6:	609a      	str	r2, [r3, #8]
	handle->RampHighLimit = (1.0f);
 80065e8:	68fb      	ldr	r3, [r7, #12]
 80065ea:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 80065ee:	60da      	str	r2, [r3, #12]
	handle->RampDelayCount = 0;
 80065f0:	68fb      	ldr	r3, [r7, #12]
 80065f2:	2200      	movs	r2, #0
 80065f4:	611a      	str	r2, [r3, #16]
	handle->SetpointValue = (0.0f);
 80065f6:	68fb      	ldr	r3, [r7, #12]
 80065f8:	f04f 0200 	mov.w	r2, #0
 80065fc:	615a      	str	r2, [r3, #20]
	handle->EqualFlag = 0;
 80065fe:	68fb      	ldr	r3, [r7, #12]
 8006600:	2200      	movs	r2, #0
 8006602:	619a      	str	r2, [r3, #24]

	return(handle);
 8006604:	68fb      	ldr	r3, [r7, #12]
}
 8006606:	4618      	mov	r0, r3
 8006608:	3714      	adds	r7, #20
 800660a:	46bd      	mov	sp, r7
 800660c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006610:	4770      	bx	lr
 8006612:	bf00      	nop
 8006614:	bf800000 	.word	0xbf800000

08006618 <SVGEN_init>:

// **************************************************************************
// the functions

SVGEN_Handle SVGEN_init(void *pMemory,const size_t numBytes)
{
 8006618:	b480      	push	{r7}
 800661a:	b085      	sub	sp, #20
 800661c:	af00      	add	r7, sp, #0
 800661e:	6078      	str	r0, [r7, #4]
 8006620:	6039      	str	r1, [r7, #0]
  SVGEN_Handle svgenHandle;


  if(numBytes < sizeof(SVGEN_Obj))
 8006622:	683b      	ldr	r3, [r7, #0]
 8006624:	2b03      	cmp	r3, #3
 8006626:	d801      	bhi.n	800662c <SVGEN_init+0x14>
    return((SVGEN_Handle)NULL);
 8006628:	2300      	movs	r3, #0
 800662a:	e002      	b.n	8006632 <SVGEN_init+0x1a>

  // assign the handle
  svgenHandle = (SVGEN_Handle)pMemory;
 800662c:	687b      	ldr	r3, [r7, #4]
 800662e:	60fb      	str	r3, [r7, #12]

  return(svgenHandle);
 8006630:	68fb      	ldr	r3, [r7, #12]
} // end of SVGEN_init() function
 8006632:	4618      	mov	r0, r3
 8006634:	3714      	adds	r7, #20
 8006636:	46bd      	mov	sp, r7
 8006638:	f85d 7b04 	ldr.w	r7, [sp], #4
 800663c:	4770      	bx	lr
 800663e:	bf00      	nop

08006640 <TRAJ_init>:

// **************************************************************************
// the functions

TRAJ_Handle TRAJ_init(void *pMemory,const size_t numBytes)
{
 8006640:	b480      	push	{r7}
 8006642:	b085      	sub	sp, #20
 8006644:	af00      	add	r7, sp, #0
 8006646:	6078      	str	r0, [r7, #4]
 8006648:	6039      	str	r1, [r7, #0]
  TRAJ_Handle handle;


  if(numBytes < sizeof(TRAJ_Obj))
 800664a:	683b      	ldr	r3, [r7, #0]
 800664c:	2b13      	cmp	r3, #19
 800664e:	d801      	bhi.n	8006654 <TRAJ_init+0x14>
    return((TRAJ_Handle)NULL);
 8006650:	2300      	movs	r3, #0
 8006652:	e002      	b.n	800665a <TRAJ_init+0x1a>

  // assign the handle
  handle = (TRAJ_Handle)pMemory;
 8006654:	687b      	ldr	r3, [r7, #4]
 8006656:	60fb      	str	r3, [r7, #12]

  return(handle);
 8006658:	68fb      	ldr	r3, [r7, #12]
} // end of TRAJ_init() function
 800665a:	4618      	mov	r0, r3
 800665c:	3714      	adds	r7, #20
 800665e:	46bd      	mov	sp, r7
 8006660:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006664:	4770      	bx	lr
 8006666:	bf00      	nop

08006668 <USER_setParams>:
// **************************************************************************
// the functions


void USER_setParams(USER_Params *pUserParams)
{
 8006668:	b480      	push	{r7}
 800666a:	b083      	sub	sp, #12
 800666c:	af00      	add	r7, sp, #0
 800666e:	6078      	str	r0, [r7, #4]
  pUserParams->iqFullScaleCurrent_A = USER_IQ_FULL_SCALE_CURRENT_A;
 8006670:	687b      	ldr	r3, [r7, #4]
 8006672:	4aaf      	ldr	r2, [pc, #700]	; (8006930 <USER_setParams+0x2c8>)
 8006674:	601a      	str	r2, [r3, #0]
  pUserParams->iqFullScaleVoltage_V = USER_IQ_FULL_SCALE_VOLTAGE_V;
 8006676:	687b      	ldr	r3, [r7, #4]
 8006678:	4aae      	ldr	r2, [pc, #696]	; (8006934 <USER_setParams+0x2cc>)
 800667a:	605a      	str	r2, [r3, #4]

  pUserParams->iqFullScaleFreq_Hz = USER_IQ_FULL_SCALE_FREQ_Hz;
 800667c:	687b      	ldr	r3, [r7, #4]
 800667e:	4aae      	ldr	r2, [pc, #696]	; (8006938 <USER_setParams+0x2d0>)
 8006680:	609a      	str	r2, [r3, #8]

  pUserParams->numIsrTicksPerCtrlTick = USER_NUM_ISR_TICKS_PER_CTRL_TICK;
 8006682:	687b      	ldr	r3, [r7, #4]
 8006684:	2201      	movs	r2, #1
 8006686:	819a      	strh	r2, [r3, #12]
  pUserParams->numCtrlTicksPerCurrentTick = USER_NUM_CTRL_TICKS_PER_CURRENT_TICK;
 8006688:	687b      	ldr	r3, [r7, #4]
 800668a:	2201      	movs	r2, #1
 800668c:	81da      	strh	r2, [r3, #14]
  pUserParams->numCtrlTicksPerEstTick = USER_NUM_CTRL_TICKS_PER_EST_TICK;
 800668e:	687b      	ldr	r3, [r7, #4]
 8006690:	2201      	movs	r2, #1
 8006692:	821a      	strh	r2, [r3, #16]
  pUserParams->numCtrlTicksPerSpeedTick = USER_NUM_CTRL_TICKS_PER_SPEED_TICK;
 8006694:	687b      	ldr	r3, [r7, #4]
 8006696:	2232      	movs	r2, #50	; 0x32
 8006698:	825a      	strh	r2, [r3, #18]
  pUserParams->numCtrlTicksPerTrajTick = USER_NUM_CTRL_TICKS_PER_TRAJ_TICK;
 800669a:	687b      	ldr	r3, [r7, #4]
 800669c:	220a      	movs	r2, #10
 800669e:	829a      	strh	r2, [r3, #20]

  pUserParams->numCurrentSensors = USER_NUM_CURRENT_SENSORS;
 80066a0:	687b      	ldr	r3, [r7, #4]
 80066a2:	2203      	movs	r2, #3
 80066a4:	759a      	strb	r2, [r3, #22]
  pUserParams->numVoltageSensors = USER_NUM_VOLTAGE_SENSORS;
 80066a6:	687b      	ldr	r3, [r7, #4]
 80066a8:	2203      	movs	r2, #3
 80066aa:	75da      	strb	r2, [r3, #23]

  pUserParams->offsetPole_rps = USER_OFFSET_POLE_rps;
 80066ac:	687b      	ldr	r3, [r7, #4]
 80066ae:	4aa3      	ldr	r2, [pc, #652]	; (800693c <USER_setParams+0x2d4>)
 80066b0:	619a      	str	r2, [r3, #24]
  pUserParams->fluxPole_rps = USER_FLUX_POLE_rps;
 80066b2:	687b      	ldr	r3, [r7, #4]
 80066b4:	4aa2      	ldr	r2, [pc, #648]	; (8006940 <USER_setParams+0x2d8>)
 80066b6:	61da      	str	r2, [r3, #28]

  pUserParams->zeroSpeedLimit = USER_ZEROSPEEDLIMIT;
 80066b8:	687b      	ldr	r3, [r7, #4]
 80066ba:	4aa2      	ldr	r2, [pc, #648]	; (8006944 <USER_setParams+0x2dc>)
 80066bc:	621a      	str	r2, [r3, #32]

  pUserParams->forceAngleFreq_Hz = USER_FORCE_ANGLE_FREQ_Hz;
 80066be:	687b      	ldr	r3, [r7, #4]
 80066c0:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 80066c4:	625a      	str	r2, [r3, #36]	; 0x24

  pUserParams->maxAccel_Hzps = USER_MAX_ACCEL_Hzps;
 80066c6:	687b      	ldr	r3, [r7, #4]
 80066c8:	4a9c      	ldr	r2, [pc, #624]	; (800693c <USER_setParams+0x2d4>)
 80066ca:	629a      	str	r2, [r3, #40]	; 0x28

  pUserParams->maxAccel_est_Hzps = USER_MAX_ACCEL_EST_Hzps;
 80066cc:	687b      	ldr	r3, [r7, #4]
 80066ce:	4a9e      	ldr	r2, [pc, #632]	; (8006948 <USER_setParams+0x2e0>)
 80066d0:	62da      	str	r2, [r3, #44]	; 0x2c

  pUserParams->directionPole_rps = USER_DIRECTION_POLE_rps;
 80066d2:	687b      	ldr	r3, [r7, #4]
 80066d4:	4a9d      	ldr	r2, [pc, #628]	; (800694c <USER_setParams+0x2e4>)
 80066d6:	631a      	str	r2, [r3, #48]	; 0x30

  pUserParams->speedPole_rps = USER_SPEED_POLE_rps;
 80066d8:	687b      	ldr	r3, [r7, #4]
 80066da:	4a99      	ldr	r2, [pc, #612]	; (8006940 <USER_setParams+0x2d8>)
 80066dc:	635a      	str	r2, [r3, #52]	; 0x34

  pUserParams->dcBusPole_rps = USER_DCBUS_POLE_rps;
 80066de:	687b      	ldr	r3, [r7, #4]
 80066e0:	4a97      	ldr	r2, [pc, #604]	; (8006940 <USER_setParams+0x2d8>)
 80066e2:	639a      	str	r2, [r3, #56]	; 0x38

  pUserParams->fluxFraction = USER_FLUX_FRACTION;
 80066e4:	687b      	ldr	r3, [r7, #4]
 80066e6:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 80066ea:	63da      	str	r2, [r3, #60]	; 0x3c

  pUserParams->indEst_speedMaxFraction = USER_SPEEDMAX_FRACTION_FOR_L_IDENT;
 80066ec:	687b      	ldr	r3, [r7, #4]
 80066ee:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 80066f2:	641a      	str	r2, [r3, #64]	; 0x40

  pUserParams->powerWarpGain = USER_POWERWARP_GAIN;
 80066f4:	687b      	ldr	r3, [r7, #4]
 80066f6:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 80066fa:	645a      	str	r2, [r3, #68]	; 0x44

  pUserParams->systemFreq_MHz = USER_SYSTEM_FREQ_MHz;
 80066fc:	687b      	ldr	r3, [r7, #4]
 80066fe:	225a      	movs	r2, #90	; 0x5a
 8006700:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48

  pUserParams->pwmPeriod_usec = USER_PWM_PERIOD_usec;
 8006704:	687b      	ldr	r3, [r7, #4]
 8006706:	4a92      	ldr	r2, [pc, #584]	; (8006950 <USER_setParams+0x2e8>)
 8006708:	64da      	str	r2, [r3, #76]	; 0x4c

  pUserParams->voltage_sf = USER_VOLTAGE_SF;
 800670a:	687b      	ldr	r3, [r7, #4]
 800670c:	4a91      	ldr	r2, [pc, #580]	; (8006954 <USER_setParams+0x2ec>)
 800670e:	651a      	str	r2, [r3, #80]	; 0x50

  pUserParams->current_sf = USER_CURRENT_SF;
 8006710:	687b      	ldr	r3, [r7, #4]
 8006712:	4a91      	ldr	r2, [pc, #580]	; (8006958 <USER_setParams+0x2f0>)
 8006714:	655a      	str	r2, [r3, #84]	; 0x54

  pUserParams->voltageFilterPole_rps = USER_VOLTAGE_FILTER_POLE_rps;
 8006716:	687b      	ldr	r3, [r7, #4]
 8006718:	4a90      	ldr	r2, [pc, #576]	; (800695c <USER_setParams+0x2f4>)
 800671a:	659a      	str	r2, [r3, #88]	; 0x58

  pUserParams->maxVsMag_pu = USER_MAX_VS_MAG_PU;
 800671c:	687b      	ldr	r3, [r7, #4]
 800671e:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8006722:	65da      	str	r2, [r3, #92]	; 0x5c

  pUserParams->estKappa = USER_EST_KAPPAQ;
 8006724:	687b      	ldr	r3, [r7, #4]
 8006726:	f04f 527f 	mov.w	r2, #1069547520	; 0x3fc00000
 800672a:	661a      	str	r2, [r3, #96]	; 0x60

  pUserParams->motor_type = USER_MOTOR_TYPE;
 800672c:	687b      	ldr	r3, [r7, #4]
 800672e:	2201      	movs	r2, #1
 8006730:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
  pUserParams->motor_numPolePairs = USER_MOTOR_NUM_POLE_PAIRS;
 8006734:	687b      	ldr	r3, [r7, #4]
 8006736:	2204      	movs	r2, #4
 8006738:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
  pUserParams->motor_ratedFlux = USER_MOTOR_RATED_FLUX;
 800673c:	687b      	ldr	r3, [r7, #4]
 800673e:	4a88      	ldr	r2, [pc, #544]	; (8006960 <USER_setParams+0x2f8>)
 8006740:	669a      	str	r2, [r3, #104]	; 0x68
  pUserParams->motor_Rr = USER_MOTOR_Rr;
 8006742:	687b      	ldr	r3, [r7, #4]
 8006744:	f04f 0200 	mov.w	r2, #0
 8006748:	66da      	str	r2, [r3, #108]	; 0x6c
  pUserParams->motor_Rs = USER_MOTOR_Rs;
 800674a:	687b      	ldr	r3, [r7, #4]
 800674c:	4a85      	ldr	r2, [pc, #532]	; (8006964 <USER_setParams+0x2fc>)
 800674e:	671a      	str	r2, [r3, #112]	; 0x70
  pUserParams->motor_Ls_d = USER_MOTOR_Ls_d;
 8006750:	687b      	ldr	r3, [r7, #4]
 8006752:	4a85      	ldr	r2, [pc, #532]	; (8006968 <USER_setParams+0x300>)
 8006754:	675a      	str	r2, [r3, #116]	; 0x74
  pUserParams->motor_Ls_q = USER_MOTOR_Ls_q;
 8006756:	687b      	ldr	r3, [r7, #4]
 8006758:	4a84      	ldr	r2, [pc, #528]	; (800696c <USER_setParams+0x304>)
 800675a:	679a      	str	r2, [r3, #120]	; 0x78

  pUserParams->maxCurrent_resEst = USER_MOTOR_RES_EST_CURRENT;
 800675c:	687b      	ldr	r3, [r7, #4]
 800675e:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8006762:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  pUserParams->maxCurrent_indEst = USER_MOTOR_IND_EST_CURRENT;
 8006766:	687b      	ldr	r3, [r7, #4]
 8006768:	4a81      	ldr	r2, [pc, #516]	; (8006970 <USER_setParams+0x308>)
 800676a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  pUserParams->maxCurrent = USER_MOTOR_MAX_CURRENT;
 800676e:	687b      	ldr	r3, [r7, #4]
 8006770:	4a72      	ldr	r2, [pc, #456]	; (800693c <USER_setParams+0x2d4>)
 8006772:	67da      	str	r2, [r3, #124]	; 0x7c

  pUserParams->maxCurrentSlope = USER_MAX_CURRENT_SLOPE;
 8006774:	687b      	ldr	r3, [r7, #4]
 8006776:	4a7f      	ldr	r2, [pc, #508]	; (8006974 <USER_setParams+0x30c>)
 8006778:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  pUserParams->maxCurrentSlope_powerWarp = USER_MAX_CURRENT_SLOPE_POWERWARP;
 800677c:	687b      	ldr	r3, [r7, #4]
 800677e:	4a7e      	ldr	r2, [pc, #504]	; (8006978 <USER_setParams+0x310>)
 8006780:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

  pUserParams->IdRated = USER_MOTOR_MAGNETIZING_CURRENT;
 8006784:	687b      	ldr	r3, [r7, #4]
 8006786:	f04f 0200 	mov.w	r2, #0
 800678a:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  pUserParams->IdRatedFraction_ratedFlux = USER_IDRATED_FRACTION_FOR_RATED_FLUX;
 800678e:	687b      	ldr	r3, [r7, #4]
 8006790:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8006794:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  pUserParams->IdRatedFraction_indEst = USER_IDRATED_FRACTION_FOR_L_IDENT;
 8006798:	687b      	ldr	r3, [r7, #4]
 800679a:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 800679e:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  pUserParams->IdRated_delta = USER_IDRATED_DELTA;
 80067a2:	687b      	ldr	r3, [r7, #4]
 80067a4:	4a75      	ldr	r2, [pc, #468]	; (800697c <USER_setParams+0x314>)
 80067a6:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c

  pUserParams->fluxEstFreq_Hz = USER_MOTOR_FLUX_EST_FREQ_Hz;
 80067aa:	687b      	ldr	r3, [r7, #4]
 80067ac:	4a63      	ldr	r2, [pc, #396]	; (800693c <USER_setParams+0x2d4>)
 80067ae:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

  pUserParams->ctrlWaitTime[CTRL_State_Error]         = 0;
 80067b2:	687b      	ldr	r3, [r7, #4]
 80067b4:	2200      	movs	r2, #0
 80067b6:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
  pUserParams->ctrlWaitTime[CTRL_State_Idle]          = 0;
 80067ba:	687b      	ldr	r3, [r7, #4]
 80067bc:	2200      	movs	r2, #0
 80067be:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
  pUserParams->ctrlWaitTime[CTRL_State_OffLine]       = (uint_least32_t)( 5.0f * USER_CTRL_FREQ_Hz);
 80067c2:	687b      	ldr	r3, [r7, #4]
 80067c4:	4a6e      	ldr	r2, [pc, #440]	; (8006980 <USER_setParams+0x318>)
 80067c6:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
  pUserParams->ctrlWaitTime[CTRL_State_OnLine]        = 0;
 80067ca:	687b      	ldr	r3, [r7, #4]
 80067cc:	2200      	movs	r2, #0
 80067ce:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0

  pUserParams->estWaitTime[EST_State_Error]           = 0;
 80067d2:	687b      	ldr	r3, [r7, #4]
 80067d4:	2200      	movs	r2, #0
 80067d6:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
  pUserParams->estWaitTime[EST_State_Idle]            = 0;
 80067da:	687b      	ldr	r3, [r7, #4]
 80067dc:	2200      	movs	r2, #0
 80067de:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
  pUserParams->estWaitTime[EST_State_RoverL]          = (uint_least32_t)( 8.0f * USER_EST_FREQ_Hz);
 80067e2:	687b      	ldr	r3, [r7, #4]
 80067e4:	4a67      	ldr	r2, [pc, #412]	; (8006984 <USER_setParams+0x31c>)
 80067e6:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  pUserParams->estWaitTime[EST_State_Rs]              = 0;
 80067ea:	687b      	ldr	r3, [r7, #4]
 80067ec:	2200      	movs	r2, #0
 80067ee:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
  pUserParams->estWaitTime[EST_State_RampUp]          = (uint_least32_t)((5.0f + USER_MOTOR_FLUX_EST_FREQ_Hz / USER_MAX_ACCEL_EST_Hzps) * USER_EST_FREQ_Hz);
 80067f2:	687b      	ldr	r3, [r7, #4]
 80067f4:	4a64      	ldr	r2, [pc, #400]	; (8006988 <USER_setParams+0x320>)
 80067f6:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
  pUserParams->estWaitTime[EST_State_IdRated]         = (uint_least32_t)(30.0f * USER_EST_FREQ_Hz);
 80067fa:	687b      	ldr	r3, [r7, #4]
 80067fc:	4a63      	ldr	r2, [pc, #396]	; (800698c <USER_setParams+0x324>)
 80067fe:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
  pUserParams->estWaitTime[EST_State_RatedFlux_OL]    = (uint_least32_t)( 0.2f * USER_EST_FREQ_Hz);
 8006802:	687b      	ldr	r3, [r7, #4]
 8006804:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
 8006808:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
  pUserParams->estWaitTime[EST_State_RatedFlux]       = 0;
 800680c:	687b      	ldr	r3, [r7, #4]
 800680e:	2200      	movs	r2, #0
 8006810:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
  pUserParams->estWaitTime[EST_State_RampDown]        = (uint_least32_t)( 2.0f * USER_EST_FREQ_Hz);
 8006814:	687b      	ldr	r3, [r7, #4]
 8006816:	f649 4240 	movw	r2, #40000	; 0x9c40
 800681a:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
  pUserParams->estWaitTime[EST_State_LockRotor]       = 0;
 800681e:	687b      	ldr	r3, [r7, #4]
 8006820:	2200      	movs	r2, #0
 8006822:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
  pUserParams->estWaitTime[EST_State_Ls]              = 0;
 8006826:	687b      	ldr	r3, [r7, #4]
 8006828:	2200      	movs	r2, #0
 800682a:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
  pUserParams->estWaitTime[EST_State_Rr]              = (uint_least32_t)(20.0f * USER_EST_FREQ_Hz);
 800682e:	687b      	ldr	r3, [r7, #4]
 8006830:	4a57      	ldr	r2, [pc, #348]	; (8006990 <USER_setParams+0x328>)
 8006832:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
  pUserParams->estWaitTime[EST_State_MotorIdentified] = 0;
 8006836:	687b      	ldr	r3, [r7, #4]
 8006838:	2200      	movs	r2, #0
 800683a:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
  pUserParams->estWaitTime[EST_State_OnLine]          = 0;
 800683e:	687b      	ldr	r3, [r7, #4]
 8006840:	2200      	movs	r2, #0
 8006842:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100

  pUserParams->FluxWaitTime[EST_Flux_State_Error]     = 0;
 8006846:	687b      	ldr	r3, [r7, #4]
 8006848:	2200      	movs	r2, #0
 800684a:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  pUserParams->FluxWaitTime[EST_Flux_State_Idle]      = 0;
 800684e:	687b      	ldr	r3, [r7, #4]
 8006850:	2200      	movs	r2, #0
 8006852:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
  pUserParams->FluxWaitTime[EST_Flux_State_CL1]       = (uint_least32_t)(10.0f * USER_EST_FREQ_Hz);
 8006856:	687b      	ldr	r3, [r7, #4]
 8006858:	4a4e      	ldr	r2, [pc, #312]	; (8006994 <USER_setParams+0x32c>)
 800685a:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
  pUserParams->FluxWaitTime[EST_Flux_State_CL2]       = (uint_least32_t)( 0.2f * USER_EST_FREQ_Hz);
 800685e:	687b      	ldr	r3, [r7, #4]
 8006860:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
 8006864:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
  pUserParams->FluxWaitTime[EST_Flux_State_Fine]      = (uint_least32_t)( 4.0f * USER_EST_FREQ_Hz);
 8006868:	687b      	ldr	r3, [r7, #4]
 800686a:	4a4b      	ldr	r2, [pc, #300]	; (8006998 <USER_setParams+0x330>)
 800686c:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
  pUserParams->FluxWaitTime[EST_Flux_State_Done]      = 0;
 8006870:	687b      	ldr	r3, [r7, #4]
 8006872:	2200      	movs	r2, #0
 8006874:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118

  pUserParams->LsWaitTime[EST_Ls_State_Error]        = 0;
 8006878:	687b      	ldr	r3, [r7, #4]
 800687a:	2200      	movs	r2, #0
 800687c:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
  pUserParams->LsWaitTime[EST_Ls_State_Idle]         = 0;
 8006880:	687b      	ldr	r3, [r7, #4]
 8006882:	2200      	movs	r2, #0
 8006884:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
  pUserParams->LsWaitTime[EST_Ls_State_RampUp]       = (uint_least32_t)( 3.0f * USER_EST_FREQ_Hz);
 8006888:	687b      	ldr	r3, [r7, #4]
 800688a:	f64e 2260 	movw	r2, #60000	; 0xea60
 800688e:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
  pUserParams->LsWaitTime[EST_Ls_State_Init]         = (uint_least32_t)( 3.0f * USER_EST_FREQ_Hz);
 8006892:	687b      	ldr	r3, [r7, #4]
 8006894:	f64e 2260 	movw	r2, #60000	; 0xea60
 8006898:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
  pUserParams->LsWaitTime[EST_Ls_State_Coarse]       = (uint_least32_t)( 0.2f * USER_EST_FREQ_Hz);
 800689c:	687b      	ldr	r3, [r7, #4]
 800689e:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
 80068a2:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c
  pUserParams->LsWaitTime[EST_Ls_State_Fine]         = (uint_least32_t)(30.0f * USER_EST_FREQ_Hz);
 80068a6:	687b      	ldr	r3, [r7, #4]
 80068a8:	4a38      	ldr	r2, [pc, #224]	; (800698c <USER_setParams+0x324>)
 80068aa:	f8c3 2130 	str.w	r2, [r3, #304]	; 0x130
  pUserParams->LsWaitTime[EST_Ls_State_Done]         = 0;
 80068ae:	687b      	ldr	r3, [r7, #4]
 80068b0:	2200      	movs	r2, #0
 80068b2:	f8c3 2134 	str.w	r2, [r3, #308]	; 0x134

  pUserParams->RsWaitTime[EST_Rs_State_Error]        = 0;
 80068b6:	687b      	ldr	r3, [r7, #4]
 80068b8:	2200      	movs	r2, #0
 80068ba:	f8c3 2138 	str.w	r2, [r3, #312]	; 0x138
  pUserParams->RsWaitTime[EST_Rs_State_Idle]         = 0;
 80068be:	687b      	ldr	r3, [r7, #4]
 80068c0:	2200      	movs	r2, #0
 80068c2:	f8c3 213c 	str.w	r2, [r3, #316]	; 0x13c
  pUserParams->RsWaitTime[EST_Rs_State_RampUp]       = (uint_least32_t)( 1.0f * USER_EST_FREQ_Hz);
 80068c6:	687b      	ldr	r3, [r7, #4]
 80068c8:	f644 6220 	movw	r2, #20000	; 0x4e20
 80068cc:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
  pUserParams->RsWaitTime[EST_Rs_State_Coarse]       = (uint_least32_t)( 2.0f * USER_EST_FREQ_Hz);
 80068d0:	687b      	ldr	r3, [r7, #4]
 80068d2:	f649 4240 	movw	r2, #40000	; 0x9c40
 80068d6:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
  pUserParams->RsWaitTime[EST_Rs_State_Fine]         = (uint_least32_t)( 7.0f * USER_EST_FREQ_Hz);
 80068da:	687b      	ldr	r3, [r7, #4]
 80068dc:	4a2f      	ldr	r2, [pc, #188]	; (800699c <USER_setParams+0x334>)
 80068de:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
  pUserParams->RsWaitTime[EST_Rs_State_Done]         = 0;
 80068e2:	687b      	ldr	r3, [r7, #4]
 80068e4:	2200      	movs	r2, #0
 80068e6:	f8c3 214c 	str.w	r2, [r3, #332]	; 0x14c

  pUserParams->ctrlFreq_Hz = USER_CTRL_FREQ_Hz;
 80068ea:	687b      	ldr	r3, [r7, #4]
 80068ec:	f644 6220 	movw	r2, #20000	; 0x4e20
 80068f0:	f8c3 2150 	str.w	r2, [r3, #336]	; 0x150

  pUserParams->estFreq_Hz = USER_EST_FREQ_Hz;
 80068f4:	687b      	ldr	r3, [r7, #4]
 80068f6:	f644 6220 	movw	r2, #20000	; 0x4e20
 80068fa:	f8c3 2154 	str.w	r2, [r3, #340]	; 0x154

  pUserParams->RoverL_estFreq_Hz = USER_R_OVER_L_EST_FREQ_Hz;
 80068fe:	687b      	ldr	r3, [r7, #4]
 8006900:	f44f 7296 	mov.w	r2, #300	; 0x12c
 8006904:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158

  pUserParams->trajFreq_Hz = USER_TRAJ_FREQ_Hz;
 8006908:	687b      	ldr	r3, [r7, #4]
 800690a:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 800690e:	f8c3 215c 	str.w	r2, [r3, #348]	; 0x15c

  pUserParams->ctrlPeriod_sec = USER_CTRL_PERIOD_sec;
 8006912:	687b      	ldr	r3, [r7, #4]
 8006914:	4a22      	ldr	r2, [pc, #136]	; (80069a0 <USER_setParams+0x338>)
 8006916:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160

  pUserParams->maxNegativeIdCurrent_a = USER_MAX_NEGATIVE_ID_REF_CURRENT_A;
 800691a:	687b      	ldr	r3, [r7, #4]
 800691c:	4a21      	ldr	r2, [pc, #132]	; (80069a4 <USER_setParams+0x33c>)
 800691e:	f8c3 2164 	str.w	r2, [r3, #356]	; 0x164

  return;
 8006922:	bf00      	nop
} // end of USER_setParams() function
 8006924:	370c      	adds	r7, #12
 8006926:	46bd      	mov	sp, r7
 8006928:	f85d 7b04 	ldr.w	r7, [sp], #4
 800692c:	4770      	bx	lr
 800692e:	bf00      	nop
 8006930:	43480000 	.word	0x43480000
 8006934:	44c80000 	.word	0x44c80000
 8006938:	44480000 	.word	0x44480000
 800693c:	41a00000 	.word	0x41a00000
 8006940:	42c80000 	.word	0x42c80000
 8006944:	3aa3d70a 	.word	0x3aa3d70a
 8006948:	40a00000 	.word	0x40a00000
 800694c:	40c00000 	.word	0x40c00000
 8006950:	42480000 	.word	0x42480000
 8006954:	3facae6f 	.word	0x3facae6f
 8006958:	3f840000 	.word	0x3f840000
 800695c:	458e1e15 	.word	0x458e1e15
 8006960:	3dc0ebee 	.word	0x3dc0ebee
 8006964:	3c5b02f0 	.word	0x3c5b02f0
 8006968:	391eeec3 	.word	0x391eeec3
 800696c:	3a16d3c2 	.word	0x3a16d3c2
 8006970:	bf800000 	.word	0xbf800000
 8006974:	3627c5ac 	.word	0x3627c5ac
 8006978:	3549539c 	.word	0x3549539c
 800697c:	37a7c5ac 	.word	0x37a7c5ac
 8006980:	000186a0 	.word	0x000186a0
 8006984:	00027100 	.word	0x00027100
 8006988:	0002bf20 	.word	0x0002bf20
 800698c:	000927c0 	.word	0x000927c0
 8006990:	00061a80 	.word	0x00061a80
 8006994:	00030d40 	.word	0x00030d40
 8006998:	00013880 	.word	0x00013880
 800699c:	000222e0 	.word	0x000222e0
 80069a0:	3851b717 	.word	0x3851b717
 80069a4:	c1200000 	.word	0xc1200000

080069a8 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80069a8:	b580      	push	{r7, lr}
 80069aa:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch and Instruction cache through ART accelerator */ 
#if (ART_ACCLERATOR_ENABLE != 0)
   __HAL_FLASH_ART_ENABLE();
 80069ac:	4a08      	ldr	r2, [pc, #32]	; (80069d0 <HAL_Init+0x28>)
 80069ae:	4b08      	ldr	r3, [pc, #32]	; (80069d0 <HAL_Init+0x28>)
 80069b0:	681b      	ldr	r3, [r3, #0]
 80069b2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80069b6:	6013      	str	r3, [r2, #0]
#endif /* ART_ACCLERATOR_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP);
 80069b8:	2003      	movs	r0, #3
 80069ba:	f002 f821 	bl	8008a00 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(SYSTICK_IRQ_PREEMPT);
 80069be:	200f      	movs	r0, #15
 80069c0:	f00c f838 	bl	8012a34 <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 80069c4:	f006 ffd2 	bl	800d96c <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
 80069c8:	2300      	movs	r3, #0
}
 80069ca:	4618      	mov	r0, r3
 80069cc:	bd80      	pop	{r7, pc}
 80069ce:	bf00      	nop
 80069d0:	40023c00 	.word	0x40023c00

080069d4 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 80069d4:	b480      	push	{r7}
 80069d6:	af00      	add	r7, sp, #0
  uwTick++;
 80069d8:	4b04      	ldr	r3, [pc, #16]	; (80069ec <HAL_IncTick+0x18>)
 80069da:	681b      	ldr	r3, [r3, #0]
 80069dc:	3301      	adds	r3, #1
 80069de:	4a03      	ldr	r2, [pc, #12]	; (80069ec <HAL_IncTick+0x18>)
 80069e0:	6013      	str	r3, [r2, #0]
}
 80069e2:	46bd      	mov	sp, r7
 80069e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80069e8:	4770      	bx	lr
 80069ea:	bf00      	nop
 80069ec:	200107b4 	.word	0x200107b4

080069f0 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 80069f0:	b480      	push	{r7}
 80069f2:	af00      	add	r7, sp, #0
  return uwTick;
 80069f4:	4b03      	ldr	r3, [pc, #12]	; (8006a04 <HAL_GetTick+0x14>)
 80069f6:	681b      	ldr	r3, [r3, #0]
}
 80069f8:	4618      	mov	r0, r3
 80069fa:	46bd      	mov	sp, r7
 80069fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006a00:	4770      	bx	lr
 8006a02:	bf00      	nop
 8006a04:	200107b4 	.word	0x200107b4

08006a08 <HAL_ADC_Init>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
 8006a08:	b580      	push	{r7, lr}
 8006a0a:	b082      	sub	sp, #8
 8006a0c:	af00      	add	r7, sp, #0
 8006a0e:	6078      	str	r0, [r7, #4]
  /* Check ADC handle */
  if(hadc == NULL)
 8006a10:	687b      	ldr	r3, [r7, #4]
 8006a12:	2b00      	cmp	r3, #0
 8006a14:	d101      	bne.n	8006a1a <HAL_ADC_Init+0x12>
  {
     return HAL_ERROR;
 8006a16:	2301      	movs	r3, #1
 8006a18:	e01f      	b.n	8006a5a <HAL_ADC_Init+0x52>
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
  {
    assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
  }

  if(hadc->State == HAL_ADC_STATE_RESET)
 8006a1a:	687b      	ldr	r3, [r7, #4]
 8006a1c:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8006a20:	b2db      	uxtb	r3, r3
 8006a22:	2b00      	cmp	r3, #0
 8006a24:	d106      	bne.n	8006a34 <HAL_ADC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hadc->Lock = HAL_UNLOCKED;
 8006a26:	687b      	ldr	r3, [r7, #4]
 8006a28:	2200      	movs	r2, #0
 8006a2a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 8006a2e:	6878      	ldr	r0, [r7, #4]
 8006a30:	f00c fcae 	bl	8013390 <HAL_ADC_MspInit>
  }

  /* Initialize the ADC state */
  hadc->State = HAL_ADC_STATE_BUSY;
 8006a34:	687b      	ldr	r3, [r7, #4]
 8006a36:	2202      	movs	r2, #2
 8006a38:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Set ADC parameters */
  ADC_Init(hadc);
 8006a3c:	6878      	ldr	r0, [r7, #4]
 8006a3e:	f000 fb41 	bl	80070c4 <ADC_Init>
  
  /* Set ADC error code to none */
  hadc->ErrorCode = HAL_ADC_ERROR_NONE;
 8006a42:	687b      	ldr	r3, [r7, #4]
 8006a44:	2200      	movs	r2, #0
 8006a46:	641a      	str	r2, [r3, #64]	; 0x40
  
  /* Initialize the ADC state */
  hadc->State = HAL_ADC_STATE_READY;
 8006a48:	687b      	ldr	r3, [r7, #4]
 8006a4a:	2201      	movs	r2, #1
 8006a4c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(hadc);
 8006a50:	687b      	ldr	r3, [r7, #4]
 8006a52:	2200      	movs	r2, #0
 8006a54:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Return function status */
  return HAL_OK;
 8006a58:	2300      	movs	r3, #0
}
 8006a5a:	4618      	mov	r0, r3
 8006a5c:	3708      	adds	r7, #8
 8006a5e:	46bd      	mov	sp, r7
 8006a60:	bd80      	pop	{r7, pc}
 8006a62:	bf00      	nop

08006a64 <HAL_ADC_DeInit>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_DeInit(ADC_HandleTypeDef* hadc)
{
 8006a64:	b580      	push	{r7, lr}
 8006a66:	b082      	sub	sp, #8
 8006a68:	af00      	add	r7, sp, #0
 8006a6a:	6078      	str	r0, [r7, #4]
  /* Check ADC handle */
  if(hadc == NULL)
 8006a6c:	687b      	ldr	r3, [r7, #4]
 8006a6e:	2b00      	cmp	r3, #0
 8006a70:	d101      	bne.n	8006a76 <HAL_ADC_DeInit+0x12>
  {
     return HAL_ERROR;
 8006a72:	2301      	movs	r3, #1
 8006a74:	e00e      	b.n	8006a94 <HAL_ADC_DeInit+0x30>
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_BUSY;
 8006a76:	687b      	ldr	r3, [r7, #4]
 8006a78:	2202      	movs	r2, #2
 8006a7a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* DeInit the low level hardware */
  HAL_ADC_MspDeInit(hadc);
 8006a7e:	6878      	ldr	r0, [r7, #4]
 8006a80:	f00c fece 	bl	8013820 <HAL_ADC_MspDeInit>
  
  /* Set ADC error code to none */
  hadc->ErrorCode = HAL_ADC_ERROR_NONE;
 8006a84:	687b      	ldr	r3, [r7, #4]
 8006a86:	2200      	movs	r2, #0
 8006a88:	641a      	str	r2, [r3, #64]	; 0x40
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_RESET;
 8006a8a:	687b      	ldr	r3, [r7, #4]
 8006a8c:	2200      	movs	r2, #0
 8006a8e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Return function status */
  return HAL_OK;
 8006a92:	2300      	movs	r3, #0
}
 8006a94:	4618      	mov	r0, r3
 8006a96:	3708      	adds	r7, #8
 8006a98:	46bd      	mov	sp, r7
 8006a9a:	bd80      	pop	{r7, pc}

08006a9c <HAL_ADC_Start>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc)
{
 8006a9c:	b480      	push	{r7}
 8006a9e:	b085      	sub	sp, #20
 8006aa0:	af00      	add	r7, sp, #0
 8006aa2:	6078      	str	r0, [r7, #4]
  __IO uint32_t counter = 0;
 8006aa4:	2300      	movs	r3, #0
 8006aa6:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
  assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge)); 
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8006aa8:	687b      	ldr	r3, [r7, #4]
 8006aaa:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8006aae:	2b01      	cmp	r3, #1
 8006ab0:	d101      	bne.n	8006ab6 <HAL_ADC_Start+0x1a>
 8006ab2:	2302      	movs	r3, #2
 8006ab4:	e061      	b.n	8006b7a <HAL_ADC_Start+0xde>
 8006ab6:	687b      	ldr	r3, [r7, #4]
 8006ab8:	2201      	movs	r2, #1
 8006aba:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Check if an injected conversion is ongoing */
  if(hadc->State == HAL_ADC_STATE_BUSY_INJ)
 8006abe:	687b      	ldr	r3, [r7, #4]
 8006ac0:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8006ac4:	b2db      	uxtb	r3, r3
 8006ac6:	2b22      	cmp	r3, #34	; 0x22
 8006ac8:	d104      	bne.n	8006ad4 <HAL_ADC_Start+0x38>
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_INJ_REG;  
 8006aca:	687b      	ldr	r3, [r7, #4]
 8006acc:	2232      	movs	r2, #50	; 0x32
 8006ace:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8006ad2:	e003      	b.n	8006adc <HAL_ADC_Start+0x40>
  }
  else
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_REG;
 8006ad4:	687b      	ldr	r3, [r7, #4]
 8006ad6:	2212      	movs	r2, #18
 8006ad8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  } 
    
  /* Check if ADC peripheral is disabled in order to enable it and wait during 
  Tstab time the ADC's stabilization */
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 8006adc:	687b      	ldr	r3, [r7, #4]
 8006ade:	681b      	ldr	r3, [r3, #0]
 8006ae0:	689b      	ldr	r3, [r3, #8]
 8006ae2:	f003 0301 	and.w	r3, r3, #1
 8006ae6:	2b00      	cmp	r3, #0
 8006ae8:	d118      	bne.n	8006b1c <HAL_ADC_Start+0x80>
  {  
    /* Enable the Peripheral */
    __HAL_ADC_ENABLE(hadc);
 8006aea:	687b      	ldr	r3, [r7, #4]
 8006aec:	681b      	ldr	r3, [r3, #0]
 8006aee:	687a      	ldr	r2, [r7, #4]
 8006af0:	6812      	ldr	r2, [r2, #0]
 8006af2:	6892      	ldr	r2, [r2, #8]
 8006af4:	f042 0201 	orr.w	r2, r2, #1
 8006af8:	609a      	str	r2, [r3, #8]
    
    /* Delay for ADC stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 8006afa:	4b23      	ldr	r3, [pc, #140]	; (8006b88 <HAL_ADC_Start+0xec>)
 8006afc:	681b      	ldr	r3, [r3, #0]
 8006afe:	4a23      	ldr	r2, [pc, #140]	; (8006b8c <HAL_ADC_Start+0xf0>)
 8006b00:	fba2 2303 	umull	r2, r3, r2, r3
 8006b04:	0c9a      	lsrs	r2, r3, #18
 8006b06:	4613      	mov	r3, r2
 8006b08:	005b      	lsls	r3, r3, #1
 8006b0a:	4413      	add	r3, r2
 8006b0c:	60fb      	str	r3, [r7, #12]
    while(counter != 0)
 8006b0e:	e002      	b.n	8006b16 <HAL_ADC_Start+0x7a>
    {
      counter--;
 8006b10:	68fb      	ldr	r3, [r7, #12]
 8006b12:	3b01      	subs	r3, #1
 8006b14:	60fb      	str	r3, [r7, #12]
    __HAL_ADC_ENABLE(hadc);
    
    /* Delay for ADC stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
    while(counter != 0)
 8006b16:	68fb      	ldr	r3, [r7, #12]
 8006b18:	2b00      	cmp	r3, #0
 8006b1a:	d1f9      	bne.n	8006b10 <HAL_ADC_Start+0x74>
      counter--;
    }
  }
	
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8006b1c:	687b      	ldr	r3, [r7, #4]
 8006b1e:	2200      	movs	r2, #0
 8006b20:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Check if Multimode enabled */
  if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
 8006b24:	4b1a      	ldr	r3, [pc, #104]	; (8006b90 <HAL_ADC_Start+0xf4>)
 8006b26:	685b      	ldr	r3, [r3, #4]
 8006b28:	f003 031f 	and.w	r3, r3, #31
 8006b2c:	2b00      	cmp	r3, #0
 8006b2e:	d10f      	bne.n	8006b50 <HAL_ADC_Start+0xb4>
  {
    /* if no external trigger present enable software conversion of regular channels */
    if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET)
 8006b30:	687b      	ldr	r3, [r7, #4]
 8006b32:	681b      	ldr	r3, [r3, #0]
 8006b34:	689b      	ldr	r3, [r3, #8]
 8006b36:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 8006b3a:	2b00      	cmp	r3, #0
 8006b3c:	d11c      	bne.n	8006b78 <HAL_ADC_Start+0xdc>
    {
      /* Enable the selected ADC software conversion for regular group */
      hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 8006b3e:	687b      	ldr	r3, [r7, #4]
 8006b40:	681b      	ldr	r3, [r3, #0]
 8006b42:	687a      	ldr	r2, [r7, #4]
 8006b44:	6812      	ldr	r2, [r2, #0]
 8006b46:	6892      	ldr	r2, [r2, #8]
 8006b48:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8006b4c:	609a      	str	r2, [r3, #8]
 8006b4e:	e013      	b.n	8006b78 <HAL_ADC_Start+0xdc>
    }
  }
  else
  {
    /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
    if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 8006b50:	687b      	ldr	r3, [r7, #4]
 8006b52:	681b      	ldr	r3, [r3, #0]
 8006b54:	4a0f      	ldr	r2, [pc, #60]	; (8006b94 <HAL_ADC_Start+0xf8>)
 8006b56:	4293      	cmp	r3, r2
 8006b58:	d10e      	bne.n	8006b78 <HAL_ADC_Start+0xdc>
 8006b5a:	687b      	ldr	r3, [r7, #4]
 8006b5c:	681b      	ldr	r3, [r3, #0]
 8006b5e:	689b      	ldr	r3, [r3, #8]
 8006b60:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 8006b64:	2b00      	cmp	r3, #0
 8006b66:	d107      	bne.n	8006b78 <HAL_ADC_Start+0xdc>
    {
      /* Enable the selected ADC software conversion for regular group */
        hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 8006b68:	687b      	ldr	r3, [r7, #4]
 8006b6a:	681b      	ldr	r3, [r3, #0]
 8006b6c:	687a      	ldr	r2, [r7, #4]
 8006b6e:	6812      	ldr	r2, [r2, #0]
 8006b70:	6892      	ldr	r2, [r2, #8]
 8006b72:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8006b76:	609a      	str	r2, [r3, #8]
    }
  }
  
  /* Return function status */
  return HAL_OK;
 8006b78:	2300      	movs	r3, #0
}
 8006b7a:	4618      	mov	r0, r3
 8006b7c:	3714      	adds	r7, #20
 8006b7e:	46bd      	mov	sp, r7
 8006b80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006b84:	4770      	bx	lr
 8006b86:	bf00      	nop
 8006b88:	20010014 	.word	0x20010014
 8006b8c:	431bde83 	.word	0x431bde83
 8006b90:	40012300 	.word	0x40012300
 8006b94:	40012000 	.word	0x40012000

08006b98 <HAL_ADC_Stop>:
  *         the configuration information for the specified ADC.
  *
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc)
{
 8006b98:	b480      	push	{r7}
 8006b9a:	b083      	sub	sp, #12
 8006b9c:	af00      	add	r7, sp, #0
 8006b9e:	6078      	str	r0, [r7, #4]
  /* Disable the Peripheral */
  __HAL_ADC_DISABLE(hadc);
 8006ba0:	687b      	ldr	r3, [r7, #4]
 8006ba2:	681b      	ldr	r3, [r3, #0]
 8006ba4:	687a      	ldr	r2, [r7, #4]
 8006ba6:	6812      	ldr	r2, [r2, #0]
 8006ba8:	6892      	ldr	r2, [r2, #8]
 8006baa:	f022 0201 	bic.w	r2, r2, #1
 8006bae:	609a      	str	r2, [r3, #8]
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_READY;
 8006bb0:	687b      	ldr	r3, [r7, #4]
 8006bb2:	2201      	movs	r2, #1
 8006bb4:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Return function status */
  return HAL_OK;
 8006bb8:	2300      	movs	r3, #0
}
 8006bba:	4618      	mov	r0, r3
 8006bbc:	370c      	adds	r7, #12
 8006bbe:	46bd      	mov	sp, r7
 8006bc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006bc4:	4770      	bx	lr
 8006bc6:	bf00      	nop

08006bc8 <HAL_ADC_IRQHandler>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */
void HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc)
{
 8006bc8:	b580      	push	{r7, lr}
 8006bca:	b084      	sub	sp, #16
 8006bcc:	af00      	add	r7, sp, #0
 8006bce:	6078      	str	r0, [r7, #4]
  uint32_t tmp1 = 0, tmp2 = 0;
 8006bd0:	2300      	movs	r3, #0
 8006bd2:	60fb      	str	r3, [r7, #12]
 8006bd4:	2300      	movs	r3, #0
 8006bd6:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
  assert_param(IS_ADC_REGULAR_LENGTH(hadc->Init.NbrOfConversion));
  assert_param(IS_ADC_EOCSelection(hadc->Init.EOCSelection));
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC);
 8006bd8:	687b      	ldr	r3, [r7, #4]
 8006bda:	681b      	ldr	r3, [r3, #0]
 8006bdc:	681b      	ldr	r3, [r3, #0]
 8006bde:	f003 0302 	and.w	r3, r3, #2
 8006be2:	2b00      	cmp	r3, #0
 8006be4:	bf14      	ite	ne
 8006be6:	2301      	movne	r3, #1
 8006be8:	2300      	moveq	r3, #0
 8006bea:	b2db      	uxtb	r3, r3
 8006bec:	60fb      	str	r3, [r7, #12]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC);
 8006bee:	687b      	ldr	r3, [r7, #4]
 8006bf0:	681b      	ldr	r3, [r3, #0]
 8006bf2:	685b      	ldr	r3, [r3, #4]
 8006bf4:	f003 0320 	and.w	r3, r3, #32
 8006bf8:	2b00      	cmp	r3, #0
 8006bfa:	bf14      	ite	ne
 8006bfc:	2301      	movne	r3, #1
 8006bfe:	2300      	moveq	r3, #0
 8006c00:	b2db      	uxtb	r3, r3
 8006c02:	60bb      	str	r3, [r7, #8]
  /* Check End of conversion flag for regular channels */
  if(tmp1 && tmp2)
 8006c04:	68fb      	ldr	r3, [r7, #12]
 8006c06:	2b00      	cmp	r3, #0
 8006c08:	d05a      	beq.n	8006cc0 <HAL_ADC_IRQHandler+0xf8>
 8006c0a:	68bb      	ldr	r3, [r7, #8]
 8006c0c:	2b00      	cmp	r3, #0
 8006c0e:	d057      	beq.n	8006cc0 <HAL_ADC_IRQHandler+0xf8>
  {
    /* Check if an injected conversion is ready */
    if(hadc->State == HAL_ADC_STATE_EOC_INJ)
 8006c10:	687b      	ldr	r3, [r7, #4]
 8006c12:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8006c16:	b2db      	uxtb	r3, r3
 8006c18:	2b25      	cmp	r3, #37	; 0x25
 8006c1a:	d104      	bne.n	8006c26 <HAL_ADC_IRQHandler+0x5e>
    {
      /* Change ADC state */
      hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
 8006c1c:	687b      	ldr	r3, [r7, #4]
 8006c1e:	2235      	movs	r2, #53	; 0x35
 8006c20:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8006c24:	e003      	b.n	8006c2e <HAL_ADC_IRQHandler+0x66>
    }
    else
    {
      /* Change ADC state */
      hadc->State = HAL_ADC_STATE_EOC_REG;
 8006c26:	687b      	ldr	r3, [r7, #4]
 8006c28:	2215      	movs	r2, #21
 8006c2a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    }

    if((hadc->Init.ContinuousConvMode == DISABLE) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 8006c2e:	687b      	ldr	r3, [r7, #4]
 8006c30:	699b      	ldr	r3, [r3, #24]
 8006c32:	2b00      	cmp	r3, #0
 8006c34:	d13c      	bne.n	8006cb0 <HAL_ADC_IRQHandler+0xe8>
 8006c36:	687b      	ldr	r3, [r7, #4]
 8006c38:	681b      	ldr	r3, [r3, #0]
 8006c3a:	689b      	ldr	r3, [r3, #8]
 8006c3c:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 8006c40:	2b00      	cmp	r3, #0
 8006c42:	d135      	bne.n	8006cb0 <HAL_ADC_IRQHandler+0xe8>
    {
      if(hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 8006c44:	687b      	ldr	r3, [r7, #4]
 8006c46:	695b      	ldr	r3, [r3, #20]
 8006c48:	2b00      	cmp	r3, #0
 8006c4a:	d110      	bne.n	8006c6e <HAL_ADC_IRQHandler+0xa6>
      { 
        /* DISABLE the ADC end of conversion interrupt for regular group */
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 8006c4c:	687b      	ldr	r3, [r7, #4]
 8006c4e:	681b      	ldr	r3, [r3, #0]
 8006c50:	687a      	ldr	r2, [r7, #4]
 8006c52:	6812      	ldr	r2, [r2, #0]
 8006c54:	6852      	ldr	r2, [r2, #4]
 8006c56:	f022 0220 	bic.w	r2, r2, #32
 8006c5a:	605a      	str	r2, [r3, #4]
        
        /* DISABLE the ADC overrun interrupt */
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
 8006c5c:	687b      	ldr	r3, [r7, #4]
 8006c5e:	681b      	ldr	r3, [r3, #0]
 8006c60:	687a      	ldr	r2, [r7, #4]
 8006c62:	6812      	ldr	r2, [r2, #0]
 8006c64:	6852      	ldr	r2, [r2, #4]
 8006c66:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8006c6a:	605a      	str	r2, [r3, #4]
 8006c6c:	e020      	b.n	8006cb0 <HAL_ADC_IRQHandler+0xe8>
      }
      else
      {
        if (hadc->NbrOfCurrentConversionRank == 0)
 8006c6e:	687b      	ldr	r3, [r7, #4]
 8006c70:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006c72:	2b00      	cmp	r3, #0
 8006c74:	d103      	bne.n	8006c7e <HAL_ADC_IRQHandler+0xb6>
        {
          hadc->NbrOfCurrentConversionRank = hadc->Init.NbrOfConversion;
 8006c76:	687b      	ldr	r3, [r7, #4]
 8006c78:	6a1a      	ldr	r2, [r3, #32]
 8006c7a:	687b      	ldr	r3, [r7, #4]
 8006c7c:	635a      	str	r2, [r3, #52]	; 0x34
        }
        
        /* Decrement the number of conversion when an interrupt occurs */
        hadc->NbrOfCurrentConversionRank--;
 8006c7e:	687b      	ldr	r3, [r7, #4]
 8006c80:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006c82:	1e5a      	subs	r2, r3, #1
 8006c84:	687b      	ldr	r3, [r7, #4]
 8006c86:	635a      	str	r2, [r3, #52]	; 0x34
        
        /* Check if all conversions are finished */
        if(hadc->NbrOfCurrentConversionRank == 0)
 8006c88:	687b      	ldr	r3, [r7, #4]
 8006c8a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006c8c:	2b00      	cmp	r3, #0
 8006c8e:	d10f      	bne.n	8006cb0 <HAL_ADC_IRQHandler+0xe8>
        {
          /* DISABLE the ADC end of conversion interrupt for regular group */
          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 8006c90:	687b      	ldr	r3, [r7, #4]
 8006c92:	681b      	ldr	r3, [r3, #0]
 8006c94:	687a      	ldr	r2, [r7, #4]
 8006c96:	6812      	ldr	r2, [r2, #0]
 8006c98:	6852      	ldr	r2, [r2, #4]
 8006c9a:	f022 0220 	bic.w	r2, r2, #32
 8006c9e:	605a      	str	r2, [r3, #4]
          
          /* DISABLE the ADC overrun interrupt */
          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
 8006ca0:	687b      	ldr	r3, [r7, #4]
 8006ca2:	681b      	ldr	r3, [r3, #0]
 8006ca4:	687a      	ldr	r2, [r7, #4]
 8006ca6:	6812      	ldr	r2, [r2, #0]
 8006ca8:	6852      	ldr	r2, [r2, #4]
 8006caa:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8006cae:	605a      	str	r2, [r3, #4]
        }
      }
    }
    
    /* Conversion complete callback */ 
    HAL_ADC_ConvCpltCallback(hadc);
 8006cb0:	6878      	ldr	r0, [r7, #4]
 8006cb2:	f000 f8c7 	bl	8006e44 <HAL_ADC_ConvCpltCallback>
    
   /* Clear the ADCx flag for regular end of conversion */
    __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 8006cb6:	687b      	ldr	r3, [r7, #4]
 8006cb8:	681b      	ldr	r3, [r3, #0]
 8006cba:	f06f 0202 	mvn.w	r2, #2
 8006cbe:	601a      	str	r2, [r3, #0]
  }
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC);
 8006cc0:	687b      	ldr	r3, [r7, #4]
 8006cc2:	681b      	ldr	r3, [r3, #0]
 8006cc4:	681b      	ldr	r3, [r3, #0]
 8006cc6:	f003 0304 	and.w	r3, r3, #4
 8006cca:	2b00      	cmp	r3, #0
 8006ccc:	bf14      	ite	ne
 8006cce:	2301      	movne	r3, #1
 8006cd0:	2300      	moveq	r3, #0
 8006cd2:	b2db      	uxtb	r3, r3
 8006cd4:	60fb      	str	r3, [r7, #12]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC);                               
 8006cd6:	687b      	ldr	r3, [r7, #4]
 8006cd8:	681b      	ldr	r3, [r3, #0]
 8006cda:	685b      	ldr	r3, [r3, #4]
 8006cdc:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006ce0:	2b00      	cmp	r3, #0
 8006ce2:	bf14      	ite	ne
 8006ce4:	2301      	movne	r3, #1
 8006ce6:	2300      	moveq	r3, #0
 8006ce8:	b2db      	uxtb	r3, r3
 8006cea:	60bb      	str	r3, [r7, #8]
  /* Check End of conversion flag for injected channels */
  if(tmp1 && tmp2)
 8006cec:	68fb      	ldr	r3, [r7, #12]
 8006cee:	2b00      	cmp	r3, #0
 8006cf0:	d041      	beq.n	8006d76 <HAL_ADC_IRQHandler+0x1ae>
 8006cf2:	68bb      	ldr	r3, [r7, #8]
 8006cf4:	2b00      	cmp	r3, #0
 8006cf6:	d03e      	beq.n	8006d76 <HAL_ADC_IRQHandler+0x1ae>
  {
    /* Check if a regular conversion is ready */
    if(hadc->State == HAL_ADC_STATE_EOC_REG)
 8006cf8:	687b      	ldr	r3, [r7, #4]
 8006cfa:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8006cfe:	b2db      	uxtb	r3, r3
 8006d00:	2b15      	cmp	r3, #21
 8006d02:	d104      	bne.n	8006d0e <HAL_ADC_IRQHandler+0x146>
    {
      /* Change ADC state */
      hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
 8006d04:	687b      	ldr	r3, [r7, #4]
 8006d06:	2235      	movs	r2, #53	; 0x35
 8006d08:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8006d0c:	e003      	b.n	8006d16 <HAL_ADC_IRQHandler+0x14e>
    }
    else
    {
      /* Change ADC state */
      hadc->State = HAL_ADC_STATE_EOC_INJ;
 8006d0e:	687b      	ldr	r3, [r7, #4]
 8006d10:	2225      	movs	r2, #37	; 0x25
 8006d12:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    }
    
    tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
 8006d16:	687b      	ldr	r3, [r7, #4]
 8006d18:	681b      	ldr	r3, [r3, #0]
 8006d1a:	685b      	ldr	r3, [r3, #4]
 8006d1c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8006d20:	2b00      	cmp	r3, #0
 8006d22:	bf0c      	ite	eq
 8006d24:	2301      	moveq	r3, #1
 8006d26:	2300      	movne	r3, #0
 8006d28:	b2db      	uxtb	r3, r3
 8006d2a:	60fb      	str	r3, [r7, #12]
    tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
 8006d2c:	687b      	ldr	r3, [r7, #4]
 8006d2e:	681b      	ldr	r3, [r3, #0]
 8006d30:	689b      	ldr	r3, [r3, #8]
 8006d32:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 8006d36:	2b00      	cmp	r3, #0
 8006d38:	bf0c      	ite	eq
 8006d3a:	2301      	moveq	r3, #1
 8006d3c:	2300      	movne	r3, #0
 8006d3e:	b2db      	uxtb	r3, r3
 8006d40:	60bb      	str	r3, [r7, #8]
    if(((hadc->Init.ContinuousConvMode == DISABLE) || tmp1) && tmp2)
 8006d42:	687b      	ldr	r3, [r7, #4]
 8006d44:	699b      	ldr	r3, [r3, #24]
 8006d46:	2b00      	cmp	r3, #0
 8006d48:	d002      	beq.n	8006d50 <HAL_ADC_IRQHandler+0x188>
 8006d4a:	68fb      	ldr	r3, [r7, #12]
 8006d4c:	2b00      	cmp	r3, #0
 8006d4e:	d00a      	beq.n	8006d66 <HAL_ADC_IRQHandler+0x19e>
 8006d50:	68bb      	ldr	r3, [r7, #8]
 8006d52:	2b00      	cmp	r3, #0
 8006d54:	d007      	beq.n	8006d66 <HAL_ADC_IRQHandler+0x19e>
    {
      /* DISABLE the ADC end of conversion interrupt for injected group */
      __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
 8006d56:	687b      	ldr	r3, [r7, #4]
 8006d58:	681b      	ldr	r3, [r3, #0]
 8006d5a:	687a      	ldr	r2, [r7, #4]
 8006d5c:	6812      	ldr	r2, [r2, #0]
 8006d5e:	6852      	ldr	r2, [r2, #4]
 8006d60:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8006d64:	605a      	str	r2, [r3, #4]
    }
    
    /* Conversion complete callback */ 
    HAL_ADCEx_InjectedConvCpltCallback(hadc);
 8006d66:	6878      	ldr	r0, [r7, #4]
 8006d68:	f00c f9b2 	bl	80130d0 <HAL_ADCEx_InjectedConvCpltCallback>
    
   /* Clear the ADCx flag for injected end of conversion */
    __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_JEOC);
 8006d6c:	687b      	ldr	r3, [r7, #4]
 8006d6e:	681b      	ldr	r3, [r3, #0]
 8006d70:	f06f 0204 	mvn.w	r2, #4
 8006d74:	601a      	str	r2, [r3, #0]
  }
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD);
 8006d76:	687b      	ldr	r3, [r7, #4]
 8006d78:	681b      	ldr	r3, [r3, #0]
 8006d7a:	681b      	ldr	r3, [r3, #0]
 8006d7c:	f003 0301 	and.w	r3, r3, #1
 8006d80:	2b00      	cmp	r3, #0
 8006d82:	bf14      	ite	ne
 8006d84:	2301      	movne	r3, #1
 8006d86:	2300      	moveq	r3, #0
 8006d88:	b2db      	uxtb	r3, r3
 8006d8a:	60fb      	str	r3, [r7, #12]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD);                          
 8006d8c:	687b      	ldr	r3, [r7, #4]
 8006d8e:	681b      	ldr	r3, [r3, #0]
 8006d90:	685b      	ldr	r3, [r3, #4]
 8006d92:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006d96:	2b00      	cmp	r3, #0
 8006d98:	bf14      	ite	ne
 8006d9a:	2301      	movne	r3, #1
 8006d9c:	2300      	moveq	r3, #0
 8006d9e:	b2db      	uxtb	r3, r3
 8006da0:	60bb      	str	r3, [r7, #8]
  /* Check Analog watchdog flag */
  if(tmp1 && tmp2)
 8006da2:	68fb      	ldr	r3, [r7, #12]
 8006da4:	2b00      	cmp	r3, #0
 8006da6:	d00e      	beq.n	8006dc6 <HAL_ADC_IRQHandler+0x1fe>
 8006da8:	68bb      	ldr	r3, [r7, #8]
 8006daa:	2b00      	cmp	r3, #0
 8006dac:	d00b      	beq.n	8006dc6 <HAL_ADC_IRQHandler+0x1fe>
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_AWD;
 8006dae:	687b      	ldr	r3, [r7, #4]
 8006db0:	2206      	movs	r2, #6
 8006db2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
      
    /* Clear the ADCx's Analog watchdog flag */
    __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_AWD);
 8006db6:	687b      	ldr	r3, [r7, #4]
 8006db8:	681b      	ldr	r3, [r3, #0]
 8006dba:	f06f 0201 	mvn.w	r2, #1
 8006dbe:	601a      	str	r2, [r3, #0]
    
    /* Level out of window callback */ 
    HAL_ADC_LevelOutOfWindowCallback(hadc);
 8006dc0:	6878      	ldr	r0, [r7, #4]
 8006dc2:	f000 f849 	bl	8006e58 <HAL_ADC_LevelOutOfWindowCallback>
  }
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_OVR);
 8006dc6:	687b      	ldr	r3, [r7, #4]
 8006dc8:	681b      	ldr	r3, [r3, #0]
 8006dca:	681b      	ldr	r3, [r3, #0]
 8006dcc:	f003 0320 	and.w	r3, r3, #32
 8006dd0:	2b00      	cmp	r3, #0
 8006dd2:	bf14      	ite	ne
 8006dd4:	2301      	movne	r3, #1
 8006dd6:	2300      	moveq	r3, #0
 8006dd8:	b2db      	uxtb	r3, r3
 8006dda:	60fb      	str	r3, [r7, #12]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_OVR);
 8006ddc:	687b      	ldr	r3, [r7, #4]
 8006dde:	681b      	ldr	r3, [r3, #0]
 8006de0:	685b      	ldr	r3, [r3, #4]
 8006de2:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8006de6:	2b00      	cmp	r3, #0
 8006de8:	bf14      	ite	ne
 8006dea:	2301      	movne	r3, #1
 8006dec:	2300      	moveq	r3, #0
 8006dee:	b2db      	uxtb	r3, r3
 8006df0:	60bb      	str	r3, [r7, #8]
  /* Check Overrun flag */
  if(tmp1 && tmp2)
 8006df2:	68fb      	ldr	r3, [r7, #12]
 8006df4:	2b00      	cmp	r3, #0
 8006df6:	d014      	beq.n	8006e22 <HAL_ADC_IRQHandler+0x25a>
 8006df8:	68bb      	ldr	r3, [r7, #8]
 8006dfa:	2b00      	cmp	r3, #0
 8006dfc:	d011      	beq.n	8006e22 <HAL_ADC_IRQHandler+0x25a>
  {
    /* Change ADC state to overrun state */
    hadc->State = HAL_ADC_STATE_ERROR;
 8006dfe:	687b      	ldr	r3, [r7, #4]
 8006e00:	2204      	movs	r2, #4
 8006e02:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    
    /* Set ADC error code to overrun */
    hadc->ErrorCode |= HAL_ADC_ERROR_OVR;
 8006e06:	687b      	ldr	r3, [r7, #4]
 8006e08:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006e0a:	f043 0201 	orr.w	r2, r3, #1
 8006e0e:	687b      	ldr	r3, [r7, #4]
 8006e10:	641a      	str	r2, [r3, #64]	; 0x40
    
    /* Clear the Overrun flag */
    __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_OVR);
 8006e12:	687b      	ldr	r3, [r7, #4]
 8006e14:	681b      	ldr	r3, [r3, #0]
 8006e16:	f06f 0220 	mvn.w	r2, #32
 8006e1a:	601a      	str	r2, [r3, #0]
    
    /* Error callback */ 
    HAL_ADC_ErrorCallback(hadc);
 8006e1c:	6878      	ldr	r0, [r7, #4]
 8006e1e:	f000 f825 	bl	8006e6c <HAL_ADC_ErrorCallback>
  }
}
 8006e22:	3710      	adds	r7, #16
 8006e24:	46bd      	mov	sp, r7
 8006e26:	bd80      	pop	{r7, pc}

08006e28 <HAL_ADC_GetValue>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval Converted value
  */
uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc)
{       
 8006e28:	b480      	push	{r7}
 8006e2a:	b083      	sub	sp, #12
 8006e2c:	af00      	add	r7, sp, #0
 8006e2e:	6078      	str	r0, [r7, #4]
  /* Return the selected ADC converted value */ 
  return hadc->Instance->DR;
 8006e30:	687b      	ldr	r3, [r7, #4]
 8006e32:	681b      	ldr	r3, [r3, #0]
 8006e34:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
 8006e36:	4618      	mov	r0, r3
 8006e38:	370c      	adds	r7, #12
 8006e3a:	46bd      	mov	sp, r7
 8006e3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e40:	4770      	bx	lr
 8006e42:	bf00      	nop

08006e44 <HAL_ADC_ConvCpltCallback>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */
__weak void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
{
 8006e44:	b480      	push	{r7}
 8006e46:	b083      	sub	sp, #12
 8006e48:	af00      	add	r7, sp, #0
 8006e4a:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_ConvCpltCallback could be implemented in the user file
   */
}
 8006e4c:	370c      	adds	r7, #12
 8006e4e:	46bd      	mov	sp, r7
 8006e50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e54:	4770      	bx	lr
 8006e56:	bf00      	nop

08006e58 <HAL_ADC_LevelOutOfWindowCallback>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */
__weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc)
{
 8006e58:	b480      	push	{r7}
 8006e5a:	b083      	sub	sp, #12
 8006e5c:	af00      	add	r7, sp, #0
 8006e5e:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_LevelOoutOfWindowCallback could be implemented in the user file
   */
}
 8006e60:	370c      	adds	r7, #12
 8006e62:	46bd      	mov	sp, r7
 8006e64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e68:	4770      	bx	lr
 8006e6a:	bf00      	nop

08006e6c <HAL_ADC_ErrorCallback>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */
__weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
{
 8006e6c:	b480      	push	{r7}
 8006e6e:	b083      	sub	sp, #12
 8006e70:	af00      	add	r7, sp, #0
 8006e72:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_ErrorCallback could be implemented in the user file
   */
}
 8006e74:	370c      	adds	r7, #12
 8006e76:	46bd      	mov	sp, r7
 8006e78:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e7c:	4770      	bx	lr
 8006e7e:	bf00      	nop

08006e80 <HAL_ADC_ConfigChannel>:
  *         the configuration information for the specified ADC.
  * @param  sConfig: ADC configuration structure. 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{
 8006e80:	b490      	push	{r4, r7}
 8006e82:	b084      	sub	sp, #16
 8006e84:	af00      	add	r7, sp, #0
 8006e86:	6078      	str	r0, [r7, #4]
 8006e88:	6039      	str	r1, [r7, #0]
  __IO uint32_t counter = 0;
 8006e8a:	2300      	movs	r3, #0
 8006e8c:	60fb      	str	r3, [r7, #12]
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8006e8e:	687b      	ldr	r3, [r7, #4]
 8006e90:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8006e94:	2b01      	cmp	r3, #1
 8006e96:	d101      	bne.n	8006e9c <HAL_ADC_ConfigChannel+0x1c>
 8006e98:	2302      	movs	r3, #2
 8006e9a:	e105      	b.n	80070a8 <HAL_ADC_ConfigChannel+0x228>
 8006e9c:	687b      	ldr	r3, [r7, #4]
 8006e9e:	2201      	movs	r2, #1
 8006ea0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (sConfig->Channel > ADC_CHANNEL_9)
 8006ea4:	683b      	ldr	r3, [r7, #0]
 8006ea6:	681b      	ldr	r3, [r3, #0]
 8006ea8:	2b09      	cmp	r3, #9
 8006eaa:	d926      	bls.n	8006efa <HAL_ADC_ConfigChannel+0x7a>
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 8006eac:	687b      	ldr	r3, [r7, #4]
 8006eae:	681a      	ldr	r2, [r3, #0]
 8006eb0:	687b      	ldr	r3, [r7, #4]
 8006eb2:	681b      	ldr	r3, [r3, #0]
 8006eb4:	68d9      	ldr	r1, [r3, #12]
 8006eb6:	683b      	ldr	r3, [r7, #0]
 8006eb8:	681b      	ldr	r3, [r3, #0]
 8006eba:	b29b      	uxth	r3, r3
 8006ebc:	4618      	mov	r0, r3
 8006ebe:	4603      	mov	r3, r0
 8006ec0:	005b      	lsls	r3, r3, #1
 8006ec2:	4403      	add	r3, r0
 8006ec4:	3b1e      	subs	r3, #30
 8006ec6:	4618      	mov	r0, r3
 8006ec8:	2307      	movs	r3, #7
 8006eca:	4083      	lsls	r3, r0
 8006ecc:	43db      	mvns	r3, r3
 8006ece:	400b      	ands	r3, r1
 8006ed0:	60d3      	str	r3, [r2, #12]
    
    /* Set the new sample time */
    hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
 8006ed2:	687b      	ldr	r3, [r7, #4]
 8006ed4:	681a      	ldr	r2, [r3, #0]
 8006ed6:	687b      	ldr	r3, [r7, #4]
 8006ed8:	681b      	ldr	r3, [r3, #0]
 8006eda:	68d9      	ldr	r1, [r3, #12]
 8006edc:	683b      	ldr	r3, [r7, #0]
 8006ede:	6898      	ldr	r0, [r3, #8]
 8006ee0:	683b      	ldr	r3, [r7, #0]
 8006ee2:	681b      	ldr	r3, [r3, #0]
 8006ee4:	b29b      	uxth	r3, r3
 8006ee6:	461c      	mov	r4, r3
 8006ee8:	4623      	mov	r3, r4
 8006eea:	005b      	lsls	r3, r3, #1
 8006eec:	4423      	add	r3, r4
 8006eee:	3b1e      	subs	r3, #30
 8006ef0:	fa00 f303 	lsl.w	r3, r0, r3
 8006ef4:	430b      	orrs	r3, r1
 8006ef6:	60d3      	str	r3, [r2, #12]
 8006ef8:	e023      	b.n	8006f42 <HAL_ADC_ConfigChannel+0xc2>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
 8006efa:	687b      	ldr	r3, [r7, #4]
 8006efc:	681a      	ldr	r2, [r3, #0]
 8006efe:	687b      	ldr	r3, [r7, #4]
 8006f00:	681b      	ldr	r3, [r3, #0]
 8006f02:	6919      	ldr	r1, [r3, #16]
 8006f04:	683b      	ldr	r3, [r7, #0]
 8006f06:	681b      	ldr	r3, [r3, #0]
 8006f08:	b29b      	uxth	r3, r3
 8006f0a:	4618      	mov	r0, r3
 8006f0c:	4603      	mov	r3, r0
 8006f0e:	005b      	lsls	r3, r3, #1
 8006f10:	4403      	add	r3, r0
 8006f12:	4618      	mov	r0, r3
 8006f14:	2307      	movs	r3, #7
 8006f16:	4083      	lsls	r3, r0
 8006f18:	43db      	mvns	r3, r3
 8006f1a:	400b      	ands	r3, r1
 8006f1c:	6113      	str	r3, [r2, #16]
    
    /* Set the new sample time */
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
 8006f1e:	687b      	ldr	r3, [r7, #4]
 8006f20:	681a      	ldr	r2, [r3, #0]
 8006f22:	687b      	ldr	r3, [r7, #4]
 8006f24:	681b      	ldr	r3, [r3, #0]
 8006f26:	6919      	ldr	r1, [r3, #16]
 8006f28:	683b      	ldr	r3, [r7, #0]
 8006f2a:	6898      	ldr	r0, [r3, #8]
 8006f2c:	683b      	ldr	r3, [r7, #0]
 8006f2e:	681b      	ldr	r3, [r3, #0]
 8006f30:	b29b      	uxth	r3, r3
 8006f32:	461c      	mov	r4, r3
 8006f34:	4623      	mov	r3, r4
 8006f36:	005b      	lsls	r3, r3, #1
 8006f38:	4423      	add	r3, r4
 8006f3a:	fa00 f303 	lsl.w	r3, r0, r3
 8006f3e:	430b      	orrs	r3, r1
 8006f40:	6113      	str	r3, [r2, #16]
  }
  
  /* For Rank 1 to 6 */
  if (sConfig->Rank < 7)
 8006f42:	683b      	ldr	r3, [r7, #0]
 8006f44:	685b      	ldr	r3, [r3, #4]
 8006f46:	2b06      	cmp	r3, #6
 8006f48:	d824      	bhi.n	8006f94 <HAL_ADC_ConfigChannel+0x114>
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 8006f4a:	687b      	ldr	r3, [r7, #4]
 8006f4c:	6819      	ldr	r1, [r3, #0]
 8006f4e:	687b      	ldr	r3, [r7, #4]
 8006f50:	681b      	ldr	r3, [r3, #0]
 8006f52:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8006f54:	683b      	ldr	r3, [r7, #0]
 8006f56:	685a      	ldr	r2, [r3, #4]
 8006f58:	4613      	mov	r3, r2
 8006f5a:	009b      	lsls	r3, r3, #2
 8006f5c:	4413      	add	r3, r2
 8006f5e:	3b05      	subs	r3, #5
 8006f60:	461a      	mov	r2, r3
 8006f62:	231f      	movs	r3, #31
 8006f64:	4093      	lsls	r3, r2
 8006f66:	43db      	mvns	r3, r3
 8006f68:	4003      	ands	r3, r0
 8006f6a:	634b      	str	r3, [r1, #52]	; 0x34
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
 8006f6c:	687b      	ldr	r3, [r7, #4]
 8006f6e:	6819      	ldr	r1, [r3, #0]
 8006f70:	687b      	ldr	r3, [r7, #4]
 8006f72:	681b      	ldr	r3, [r3, #0]
 8006f74:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8006f76:	683b      	ldr	r3, [r7, #0]
 8006f78:	681b      	ldr	r3, [r3, #0]
 8006f7a:	b29b      	uxth	r3, r3
 8006f7c:	461c      	mov	r4, r3
 8006f7e:	683b      	ldr	r3, [r7, #0]
 8006f80:	685a      	ldr	r2, [r3, #4]
 8006f82:	4613      	mov	r3, r2
 8006f84:	009b      	lsls	r3, r3, #2
 8006f86:	4413      	add	r3, r2
 8006f88:	3b05      	subs	r3, #5
 8006f8a:	fa04 f303 	lsl.w	r3, r4, r3
 8006f8e:	4303      	orrs	r3, r0
 8006f90:	634b      	str	r3, [r1, #52]	; 0x34
 8006f92:	e04c      	b.n	800702e <HAL_ADC_ConfigChannel+0x1ae>
  }
  /* For Rank 7 to 12 */
  else if (sConfig->Rank < 13)
 8006f94:	683b      	ldr	r3, [r7, #0]
 8006f96:	685b      	ldr	r3, [r3, #4]
 8006f98:	2b0c      	cmp	r3, #12
 8006f9a:	d824      	bhi.n	8006fe6 <HAL_ADC_ConfigChannel+0x166>
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
 8006f9c:	687b      	ldr	r3, [r7, #4]
 8006f9e:	6819      	ldr	r1, [r3, #0]
 8006fa0:	687b      	ldr	r3, [r7, #4]
 8006fa2:	681b      	ldr	r3, [r3, #0]
 8006fa4:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8006fa6:	683b      	ldr	r3, [r7, #0]
 8006fa8:	685a      	ldr	r2, [r3, #4]
 8006faa:	4613      	mov	r3, r2
 8006fac:	009b      	lsls	r3, r3, #2
 8006fae:	4413      	add	r3, r2
 8006fb0:	3b23      	subs	r3, #35	; 0x23
 8006fb2:	461a      	mov	r2, r3
 8006fb4:	231f      	movs	r3, #31
 8006fb6:	4093      	lsls	r3, r2
 8006fb8:	43db      	mvns	r3, r3
 8006fba:	4003      	ands	r3, r0
 8006fbc:	630b      	str	r3, [r1, #48]	; 0x30
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 8006fbe:	687b      	ldr	r3, [r7, #4]
 8006fc0:	6819      	ldr	r1, [r3, #0]
 8006fc2:	687b      	ldr	r3, [r7, #4]
 8006fc4:	681b      	ldr	r3, [r3, #0]
 8006fc6:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8006fc8:	683b      	ldr	r3, [r7, #0]
 8006fca:	681b      	ldr	r3, [r3, #0]
 8006fcc:	b29b      	uxth	r3, r3
 8006fce:	461c      	mov	r4, r3
 8006fd0:	683b      	ldr	r3, [r7, #0]
 8006fd2:	685a      	ldr	r2, [r3, #4]
 8006fd4:	4613      	mov	r3, r2
 8006fd6:	009b      	lsls	r3, r3, #2
 8006fd8:	4413      	add	r3, r2
 8006fda:	3b23      	subs	r3, #35	; 0x23
 8006fdc:	fa04 f303 	lsl.w	r3, r4, r3
 8006fe0:	4303      	orrs	r3, r0
 8006fe2:	630b      	str	r3, [r1, #48]	; 0x30
 8006fe4:	e023      	b.n	800702e <HAL_ADC_ConfigChannel+0x1ae>
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
 8006fe6:	687b      	ldr	r3, [r7, #4]
 8006fe8:	6819      	ldr	r1, [r3, #0]
 8006fea:	687b      	ldr	r3, [r7, #4]
 8006fec:	681b      	ldr	r3, [r3, #0]
 8006fee:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8006ff0:	683b      	ldr	r3, [r7, #0]
 8006ff2:	685a      	ldr	r2, [r3, #4]
 8006ff4:	4613      	mov	r3, r2
 8006ff6:	009b      	lsls	r3, r3, #2
 8006ff8:	4413      	add	r3, r2
 8006ffa:	3b41      	subs	r3, #65	; 0x41
 8006ffc:	461a      	mov	r2, r3
 8006ffe:	231f      	movs	r3, #31
 8007000:	4093      	lsls	r3, r2
 8007002:	43db      	mvns	r3, r3
 8007004:	4003      	ands	r3, r0
 8007006:	62cb      	str	r3, [r1, #44]	; 0x2c
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
 8007008:	687b      	ldr	r3, [r7, #4]
 800700a:	6819      	ldr	r1, [r3, #0]
 800700c:	687b      	ldr	r3, [r7, #4]
 800700e:	681b      	ldr	r3, [r3, #0]
 8007010:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8007012:	683b      	ldr	r3, [r7, #0]
 8007014:	681b      	ldr	r3, [r3, #0]
 8007016:	b29b      	uxth	r3, r3
 8007018:	461c      	mov	r4, r3
 800701a:	683b      	ldr	r3, [r7, #0]
 800701c:	685a      	ldr	r2, [r3, #4]
 800701e:	4613      	mov	r3, r2
 8007020:	009b      	lsls	r3, r3, #2
 8007022:	4413      	add	r3, r2
 8007024:	3b41      	subs	r3, #65	; 0x41
 8007026:	fa04 f303 	lsl.w	r3, r4, r3
 800702a:	4303      	orrs	r3, r0
 800702c:	62cb      	str	r3, [r1, #44]	; 0x2c
  }
  
  /* if ADC1 Channel_18 is selected enable VBAT Channel */
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 800702e:	687b      	ldr	r3, [r7, #4]
 8007030:	681b      	ldr	r3, [r3, #0]
 8007032:	4a20      	ldr	r2, [pc, #128]	; (80070b4 <HAL_ADC_ConfigChannel+0x234>)
 8007034:	4293      	cmp	r3, r2
 8007036:	d109      	bne.n	800704c <HAL_ADC_ConfigChannel+0x1cc>
 8007038:	683b      	ldr	r3, [r7, #0]
 800703a:	681b      	ldr	r3, [r3, #0]
 800703c:	2b12      	cmp	r3, #18
 800703e:	d105      	bne.n	800704c <HAL_ADC_ConfigChannel+0x1cc>
  {
    /* Enable the VBAT channel*/
    ADC->CCR |= ADC_CCR_VBATE;
 8007040:	4a1d      	ldr	r2, [pc, #116]	; (80070b8 <HAL_ADC_ConfigChannel+0x238>)
 8007042:	4b1d      	ldr	r3, [pc, #116]	; (80070b8 <HAL_ADC_ConfigChannel+0x238>)
 8007044:	685b      	ldr	r3, [r3, #4]
 8007046:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800704a:	6053      	str	r3, [r2, #4]
  }
  
  /* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
 800704c:	687b      	ldr	r3, [r7, #4]
 800704e:	681b      	ldr	r3, [r3, #0]
 8007050:	4a18      	ldr	r2, [pc, #96]	; (80070b4 <HAL_ADC_ConfigChannel+0x234>)
 8007052:	4293      	cmp	r3, r2
 8007054:	d123      	bne.n	800709e <HAL_ADC_ConfigChannel+0x21e>
 8007056:	683b      	ldr	r3, [r7, #0]
 8007058:	681b      	ldr	r3, [r3, #0]
 800705a:	2b10      	cmp	r3, #16
 800705c:	d003      	beq.n	8007066 <HAL_ADC_ConfigChannel+0x1e6>
 800705e:	683b      	ldr	r3, [r7, #0]
 8007060:	681b      	ldr	r3, [r3, #0]
 8007062:	2b11      	cmp	r3, #17
 8007064:	d11b      	bne.n	800709e <HAL_ADC_ConfigChannel+0x21e>
  {
    /* Enable the TSVREFE channel*/
    ADC->CCR |= ADC_CCR_TSVREFE;
 8007066:	4a14      	ldr	r2, [pc, #80]	; (80070b8 <HAL_ADC_ConfigChannel+0x238>)
 8007068:	4b13      	ldr	r3, [pc, #76]	; (80070b8 <HAL_ADC_ConfigChannel+0x238>)
 800706a:	685b      	ldr	r3, [r3, #4]
 800706c:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8007070:	6053      	str	r3, [r2, #4]

    if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
 8007072:	683b      	ldr	r3, [r7, #0]
 8007074:	681b      	ldr	r3, [r3, #0]
 8007076:	2b10      	cmp	r3, #16
 8007078:	d111      	bne.n	800709e <HAL_ADC_ConfigChannel+0x21e>
    {
      /* Delay for temperature sensor stabilization time */
      /* Compute number of CPU cycles to wait for */
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
 800707a:	4b10      	ldr	r3, [pc, #64]	; (80070bc <HAL_ADC_ConfigChannel+0x23c>)
 800707c:	681b      	ldr	r3, [r3, #0]
 800707e:	4a10      	ldr	r2, [pc, #64]	; (80070c0 <HAL_ADC_ConfigChannel+0x240>)
 8007080:	fba2 2303 	umull	r2, r3, r2, r3
 8007084:	0c9a      	lsrs	r2, r3, #18
 8007086:	4613      	mov	r3, r2
 8007088:	009b      	lsls	r3, r3, #2
 800708a:	4413      	add	r3, r2
 800708c:	005b      	lsls	r3, r3, #1
 800708e:	60fb      	str	r3, [r7, #12]
      while(counter != 0)
 8007090:	e002      	b.n	8007098 <HAL_ADC_ConfigChannel+0x218>
      {
        counter--;
 8007092:	68fb      	ldr	r3, [r7, #12]
 8007094:	3b01      	subs	r3, #1
 8007096:	60fb      	str	r3, [r7, #12]
    if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
    {
      /* Delay for temperature sensor stabilization time */
      /* Compute number of CPU cycles to wait for */
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
      while(counter != 0)
 8007098:	68fb      	ldr	r3, [r7, #12]
 800709a:	2b00      	cmp	r3, #0
 800709c:	d1f9      	bne.n	8007092 <HAL_ADC_ConfigChannel+0x212>
      }
    }
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 800709e:	687b      	ldr	r3, [r7, #4]
 80070a0:	2200      	movs	r2, #0
 80070a2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 80070a6:	2300      	movs	r3, #0
}
 80070a8:	4618      	mov	r0, r3
 80070aa:	3710      	adds	r7, #16
 80070ac:	46bd      	mov	sp, r7
 80070ae:	bc90      	pop	{r4, r7}
 80070b0:	4770      	bx	lr
 80070b2:	bf00      	nop
 80070b4:	40012000 	.word	0x40012000
 80070b8:	40012300 	.word	0x40012300
 80070bc:	20010014 	.word	0x20010014
 80070c0:	431bde83 	.word	0x431bde83

080070c4 <ADC_Init>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval None
  */
static void ADC_Init(ADC_HandleTypeDef* hadc)
{
 80070c4:	b480      	push	{r7}
 80070c6:	b085      	sub	sp, #20
 80070c8:	af00      	add	r7, sp, #0
 80070ca:	6078      	str	r0, [r7, #4]
  /* Set ADC parameters */
  /* Set the ADC clock prescaler */
  ADC->CCR &= ~(ADC_CCR_ADCPRE);
 80070cc:	4a7c      	ldr	r2, [pc, #496]	; (80072c0 <ADC_Init+0x1fc>)
 80070ce:	4b7c      	ldr	r3, [pc, #496]	; (80072c0 <ADC_Init+0x1fc>)
 80070d0:	685b      	ldr	r3, [r3, #4]
 80070d2:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 80070d6:	6053      	str	r3, [r2, #4]
  ADC->CCR |=  hadc->Init.ClockPrescaler;
 80070d8:	4979      	ldr	r1, [pc, #484]	; (80072c0 <ADC_Init+0x1fc>)
 80070da:	4b79      	ldr	r3, [pc, #484]	; (80072c0 <ADC_Init+0x1fc>)
 80070dc:	685a      	ldr	r2, [r3, #4]
 80070de:	687b      	ldr	r3, [r7, #4]
 80070e0:	685b      	ldr	r3, [r3, #4]
 80070e2:	4313      	orrs	r3, r2
 80070e4:	604b      	str	r3, [r1, #4]
  
  /* Set ADC scan mode */
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 80070e6:	687b      	ldr	r3, [r7, #4]
 80070e8:	681b      	ldr	r3, [r3, #0]
 80070ea:	687a      	ldr	r2, [r7, #4]
 80070ec:	6812      	ldr	r2, [r2, #0]
 80070ee:	6852      	ldr	r2, [r2, #4]
 80070f0:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80070f4:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 80070f6:	687b      	ldr	r3, [r7, #4]
 80070f8:	681b      	ldr	r3, [r3, #0]
 80070fa:	687a      	ldr	r2, [r7, #4]
 80070fc:	6812      	ldr	r2, [r2, #0]
 80070fe:	6851      	ldr	r1, [r2, #4]
 8007100:	687a      	ldr	r2, [r7, #4]
 8007102:	6912      	ldr	r2, [r2, #16]
 8007104:	0212      	lsls	r2, r2, #8
 8007106:	430a      	orrs	r2, r1
 8007108:	605a      	str	r2, [r3, #4]
  
  /* Set ADC resolution */
  hadc->Instance->CR1 &= ~(ADC_CR1_RES);
 800710a:	687b      	ldr	r3, [r7, #4]
 800710c:	681b      	ldr	r3, [r3, #0]
 800710e:	687a      	ldr	r2, [r7, #4]
 8007110:	6812      	ldr	r2, [r2, #0]
 8007112:	6852      	ldr	r2, [r2, #4]
 8007114:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 8007118:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 800711a:	687b      	ldr	r3, [r7, #4]
 800711c:	681b      	ldr	r3, [r3, #0]
 800711e:	687a      	ldr	r2, [r7, #4]
 8007120:	6812      	ldr	r2, [r2, #0]
 8007122:	6851      	ldr	r1, [r2, #4]
 8007124:	687a      	ldr	r2, [r7, #4]
 8007126:	6892      	ldr	r2, [r2, #8]
 8007128:	430a      	orrs	r2, r1
 800712a:	605a      	str	r2, [r3, #4]
  
  /* Set ADC data alignment */
  hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
 800712c:	687b      	ldr	r3, [r7, #4]
 800712e:	681b      	ldr	r3, [r3, #0]
 8007130:	687a      	ldr	r2, [r7, #4]
 8007132:	6812      	ldr	r2, [r2, #0]
 8007134:	6892      	ldr	r2, [r2, #8]
 8007136:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 800713a:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 800713c:	687b      	ldr	r3, [r7, #4]
 800713e:	681b      	ldr	r3, [r3, #0]
 8007140:	687a      	ldr	r2, [r7, #4]
 8007142:	6812      	ldr	r2, [r2, #0]
 8007144:	6891      	ldr	r1, [r2, #8]
 8007146:	687a      	ldr	r2, [r7, #4]
 8007148:	68d2      	ldr	r2, [r2, #12]
 800714a:	430a      	orrs	r2, r1
 800714c:	609a      	str	r2, [r3, #8]
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 800714e:	687b      	ldr	r3, [r7, #4]
 8007150:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007152:	4a5c      	ldr	r2, [pc, #368]	; (80072c4 <ADC_Init+0x200>)
 8007154:	4293      	cmp	r3, r2
 8007156:	d022      	beq.n	800719e <ADC_Init+0xda>
  {
    /* Select external trigger to start conversion */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 8007158:	687b      	ldr	r3, [r7, #4]
 800715a:	681b      	ldr	r3, [r3, #0]
 800715c:	687a      	ldr	r2, [r7, #4]
 800715e:	6812      	ldr	r2, [r2, #0]
 8007160:	6892      	ldr	r2, [r2, #8]
 8007162:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 8007166:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
 8007168:	687b      	ldr	r3, [r7, #4]
 800716a:	681b      	ldr	r3, [r3, #0]
 800716c:	687a      	ldr	r2, [r7, #4]
 800716e:	6812      	ldr	r2, [r2, #0]
 8007170:	6891      	ldr	r1, [r2, #8]
 8007172:	687a      	ldr	r2, [r7, #4]
 8007174:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8007176:	430a      	orrs	r2, r1
 8007178:	609a      	str	r2, [r3, #8]
    
    /* Select external trigger polarity */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 800717a:	687b      	ldr	r3, [r7, #4]
 800717c:	681b      	ldr	r3, [r3, #0]
 800717e:	687a      	ldr	r2, [r7, #4]
 8007180:	6812      	ldr	r2, [r2, #0]
 8007182:	6892      	ldr	r2, [r2, #8]
 8007184:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 8007188:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
 800718a:	687b      	ldr	r3, [r7, #4]
 800718c:	681b      	ldr	r3, [r3, #0]
 800718e:	687a      	ldr	r2, [r7, #4]
 8007190:	6812      	ldr	r2, [r2, #0]
 8007192:	6891      	ldr	r1, [r2, #8]
 8007194:	687a      	ldr	r2, [r7, #4]
 8007196:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8007198:	430a      	orrs	r2, r1
 800719a:	609a      	str	r2, [r3, #8]
 800719c:	e00f      	b.n	80071be <ADC_Init+0xfa>
  }
  else
  {
    /* Reset the external trigger */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 800719e:	687b      	ldr	r3, [r7, #4]
 80071a0:	681b      	ldr	r3, [r3, #0]
 80071a2:	687a      	ldr	r2, [r7, #4]
 80071a4:	6812      	ldr	r2, [r2, #0]
 80071a6:	6892      	ldr	r2, [r2, #8]
 80071a8:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 80071ac:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 80071ae:	687b      	ldr	r3, [r7, #4]
 80071b0:	681b      	ldr	r3, [r3, #0]
 80071b2:	687a      	ldr	r2, [r7, #4]
 80071b4:	6812      	ldr	r2, [r2, #0]
 80071b6:	6892      	ldr	r2, [r2, #8]
 80071b8:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 80071bc:	609a      	str	r2, [r3, #8]
  }
  
  /* Enable or disable ADC continuous conversion mode */
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 80071be:	687b      	ldr	r3, [r7, #4]
 80071c0:	681b      	ldr	r3, [r3, #0]
 80071c2:	687a      	ldr	r2, [r7, #4]
 80071c4:	6812      	ldr	r2, [r2, #0]
 80071c6:	6892      	ldr	r2, [r2, #8]
 80071c8:	f022 0202 	bic.w	r2, r2, #2
 80071cc:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode);
 80071ce:	687b      	ldr	r3, [r7, #4]
 80071d0:	681b      	ldr	r3, [r3, #0]
 80071d2:	687a      	ldr	r2, [r7, #4]
 80071d4:	6812      	ldr	r2, [r2, #0]
 80071d6:	6891      	ldr	r1, [r2, #8]
 80071d8:	687a      	ldr	r2, [r7, #4]
 80071da:	6992      	ldr	r2, [r2, #24]
 80071dc:	0052      	lsls	r2, r2, #1
 80071de:	430a      	orrs	r2, r1
 80071e0:	609a      	str	r2, [r3, #8]
  
  if(hadc->Init.DiscontinuousConvMode != DISABLE)
 80071e2:	687b      	ldr	r3, [r7, #4]
 80071e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80071e6:	2b00      	cmp	r3, #0
 80071e8:	d025      	beq.n	8007236 <ADC_Init+0x172>
  {
    assert_param(IS_ADC_REGULAR_DISC_NUMBER(hadc->Init.NbrOfDiscConversion));
  
    /* Enable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 80071ea:	687b      	ldr	r3, [r7, #4]
 80071ec:	681b      	ldr	r3, [r3, #0]
 80071ee:	687a      	ldr	r2, [r7, #4]
 80071f0:	6812      	ldr	r2, [r2, #0]
 80071f2:	6852      	ldr	r2, [r2, #4]
 80071f4:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80071f8:	605a      	str	r2, [r3, #4]
    
    /* Set the number of channels to be converted in discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
 80071fa:	687b      	ldr	r3, [r7, #4]
 80071fc:	681b      	ldr	r3, [r3, #0]
 80071fe:	687a      	ldr	r2, [r7, #4]
 8007200:	6812      	ldr	r2, [r2, #0]
 8007202:	6852      	ldr	r2, [r2, #4]
 8007204:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 8007208:	605a      	str	r2, [r3, #4]
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 800720a:	687b      	ldr	r3, [r7, #4]
 800720c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800720e:	1e5a      	subs	r2, r3, #1
 8007210:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 8007214:	60fb      	str	r3, [r7, #12]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8007216:	68fb      	ldr	r3, [r7, #12]
 8007218:	fa93 f3a3 	rbit	r3, r3
 800721c:	60bb      	str	r3, [r7, #8]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800721e:	68bb      	ldr	r3, [r7, #8]
 8007220:	fab3 f383 	clz	r3, r3
 8007224:	409a      	lsls	r2, r3
 8007226:	687b      	ldr	r3, [r7, #4]
 8007228:	681b      	ldr	r3, [r3, #0]
 800722a:	6879      	ldr	r1, [r7, #4]
 800722c:	6809      	ldr	r1, [r1, #0]
 800722e:	6849      	ldr	r1, [r1, #4]
 8007230:	430a      	orrs	r2, r1
 8007232:	605a      	str	r2, [r3, #4]
 8007234:	e007      	b.n	8007246 <ADC_Init+0x182>
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
 8007236:	687b      	ldr	r3, [r7, #4]
 8007238:	681b      	ldr	r3, [r3, #0]
 800723a:	687a      	ldr	r2, [r7, #4]
 800723c:	6812      	ldr	r2, [r2, #0]
 800723e:	6852      	ldr	r2, [r2, #4]
 8007240:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8007244:	605a      	str	r2, [r3, #4]
  }
  
  /* Set ADC number of conversion */
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 8007246:	687b      	ldr	r3, [r7, #4]
 8007248:	681b      	ldr	r3, [r3, #0]
 800724a:	687a      	ldr	r2, [r7, #4]
 800724c:	6812      	ldr	r2, [r2, #0]
 800724e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8007250:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
 8007254:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 8007256:	687b      	ldr	r3, [r7, #4]
 8007258:	681b      	ldr	r3, [r3, #0]
 800725a:	687a      	ldr	r2, [r7, #4]
 800725c:	6812      	ldr	r2, [r2, #0]
 800725e:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8007260:	687a      	ldr	r2, [r7, #4]
 8007262:	6a12      	ldr	r2, [r2, #32]
 8007264:	3a01      	subs	r2, #1
 8007266:	0512      	lsls	r2, r2, #20
 8007268:	430a      	orrs	r2, r1
 800726a:	62da      	str	r2, [r3, #44]	; 0x2c
  
  /* Enable or disable ADC DMA continuous request */
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
 800726c:	687b      	ldr	r3, [r7, #4]
 800726e:	681b      	ldr	r3, [r3, #0]
 8007270:	687a      	ldr	r2, [r7, #4]
 8007272:	6812      	ldr	r2, [r2, #0]
 8007274:	6892      	ldr	r2, [r2, #8]
 8007276:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 800727a:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq(hadc->Init.DMAContinuousRequests);
 800727c:	687b      	ldr	r3, [r7, #4]
 800727e:	681b      	ldr	r3, [r3, #0]
 8007280:	687a      	ldr	r2, [r7, #4]
 8007282:	6812      	ldr	r2, [r2, #0]
 8007284:	6891      	ldr	r1, [r2, #8]
 8007286:	687a      	ldr	r2, [r7, #4]
 8007288:	69d2      	ldr	r2, [r2, #28]
 800728a:	0252      	lsls	r2, r2, #9
 800728c:	430a      	orrs	r2, r1
 800728e:	609a      	str	r2, [r3, #8]
  
  /* Enable or disable ADC end of conversion selection */
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
 8007290:	687b      	ldr	r3, [r7, #4]
 8007292:	681b      	ldr	r3, [r3, #0]
 8007294:	687a      	ldr	r2, [r7, #4]
 8007296:	6812      	ldr	r2, [r2, #0]
 8007298:	6892      	ldr	r2, [r2, #8]
 800729a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800729e:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 80072a0:	687b      	ldr	r3, [r7, #4]
 80072a2:	681b      	ldr	r3, [r3, #0]
 80072a4:	687a      	ldr	r2, [r7, #4]
 80072a6:	6812      	ldr	r2, [r2, #0]
 80072a8:	6891      	ldr	r1, [r2, #8]
 80072aa:	687a      	ldr	r2, [r7, #4]
 80072ac:	6952      	ldr	r2, [r2, #20]
 80072ae:	0292      	lsls	r2, r2, #10
 80072b0:	430a      	orrs	r2, r1
 80072b2:	609a      	str	r2, [r3, #8]
}
 80072b4:	3714      	adds	r7, #20
 80072b6:	46bd      	mov	sp, r7
 80072b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80072bc:	4770      	bx	lr
 80072be:	bf00      	nop
 80072c0:	40012300 	.word	0x40012300
 80072c4:	0f000001 	.word	0x0f000001

080072c8 <HAL_ADCEx_InjectedStart_IT>:
  *         the configuration information for the specified ADC.
  *
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedStart_IT(ADC_HandleTypeDef* hadc)
{
 80072c8:	b480      	push	{r7}
 80072ca:	b087      	sub	sp, #28
 80072cc:	af00      	add	r7, sp, #0
 80072ce:	6078      	str	r0, [r7, #4]
  __IO uint32_t counter = 0;
 80072d0:	2300      	movs	r3, #0
 80072d2:	60fb      	str	r3, [r7, #12]
  uint32_t tmp1 = 0, tmp2 =0;
 80072d4:	2300      	movs	r3, #0
 80072d6:	617b      	str	r3, [r7, #20]
 80072d8:	2300      	movs	r3, #0
 80072da:	613b      	str	r3, [r7, #16]
  
  /* Process locked */
  __HAL_LOCK(hadc);
 80072dc:	687b      	ldr	r3, [r7, #4]
 80072de:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80072e2:	2b01      	cmp	r3, #1
 80072e4:	d101      	bne.n	80072ea <HAL_ADCEx_InjectedStart_IT+0x22>
 80072e6:	2302      	movs	r3, #2
 80072e8:	e09e      	b.n	8007428 <HAL_ADCEx_InjectedStart_IT+0x160>
 80072ea:	687b      	ldr	r3, [r7, #4]
 80072ec:	2201      	movs	r2, #1
 80072ee:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Check if a regular conversion is ongoing */
  if(hadc->State == HAL_ADC_STATE_BUSY_REG)
 80072f2:	687b      	ldr	r3, [r7, #4]
 80072f4:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80072f8:	b2db      	uxtb	r3, r3
 80072fa:	2b12      	cmp	r3, #18
 80072fc:	d104      	bne.n	8007308 <HAL_ADCEx_InjectedStart_IT+0x40>
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_INJ_REG;  
 80072fe:	687b      	ldr	r3, [r7, #4]
 8007300:	2232      	movs	r2, #50	; 0x32
 8007302:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8007306:	e003      	b.n	8007310 <HAL_ADCEx_InjectedStart_IT+0x48>
  }
  else
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_INJ;
 8007308:	687b      	ldr	r3, [r7, #4]
 800730a:	2222      	movs	r2, #34	; 0x22
 800730c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  }
  
  /* Set ADC error code to none */
  hadc->ErrorCode = HAL_ADC_ERROR_NONE;
 8007310:	687b      	ldr	r3, [r7, #4]
 8007312:	2200      	movs	r2, #0
 8007314:	641a      	str	r2, [r3, #64]	; 0x40
  
  /* Check if ADC peripheral is disabled in order to enable it and wait during 
     Tstab time the ADC's stabilization */
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 8007316:	687b      	ldr	r3, [r7, #4]
 8007318:	681b      	ldr	r3, [r3, #0]
 800731a:	689b      	ldr	r3, [r3, #8]
 800731c:	f003 0301 	and.w	r3, r3, #1
 8007320:	2b00      	cmp	r3, #0
 8007322:	d118      	bne.n	8007356 <HAL_ADCEx_InjectedStart_IT+0x8e>
  {  
    /* Enable the Peripheral */
    __HAL_ADC_ENABLE(hadc);
 8007324:	687b      	ldr	r3, [r7, #4]
 8007326:	681b      	ldr	r3, [r3, #0]
 8007328:	687a      	ldr	r2, [r7, #4]
 800732a:	6812      	ldr	r2, [r2, #0]
 800732c:	6892      	ldr	r2, [r2, #8]
 800732e:	f042 0201 	orr.w	r2, r2, #1
 8007332:	609a      	str	r2, [r3, #8]
    
    /* Delay for temperature sensor stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 8007334:	4b3f      	ldr	r3, [pc, #252]	; (8007434 <HAL_ADCEx_InjectedStart_IT+0x16c>)
 8007336:	681b      	ldr	r3, [r3, #0]
 8007338:	4a3f      	ldr	r2, [pc, #252]	; (8007438 <HAL_ADCEx_InjectedStart_IT+0x170>)
 800733a:	fba2 2303 	umull	r2, r3, r2, r3
 800733e:	0c9a      	lsrs	r2, r3, #18
 8007340:	4613      	mov	r3, r2
 8007342:	005b      	lsls	r3, r3, #1
 8007344:	4413      	add	r3, r2
 8007346:	60fb      	str	r3, [r7, #12]
    while(counter != 0)
 8007348:	e002      	b.n	8007350 <HAL_ADCEx_InjectedStart_IT+0x88>
    {
      counter--;
 800734a:	68fb      	ldr	r3, [r7, #12]
 800734c:	3b01      	subs	r3, #1
 800734e:	60fb      	str	r3, [r7, #12]
    __HAL_ADC_ENABLE(hadc);
    
    /* Delay for temperature sensor stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
    while(counter != 0)
 8007350:	68fb      	ldr	r3, [r7, #12]
 8007352:	2b00      	cmp	r3, #0
 8007354:	d1f9      	bne.n	800734a <HAL_ADCEx_InjectedStart_IT+0x82>
      counter--;
    }
  }
  
  /* Enable the ADC end of conversion interrupt for injected group */
  __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
 8007356:	687b      	ldr	r3, [r7, #4]
 8007358:	681b      	ldr	r3, [r3, #0]
 800735a:	687a      	ldr	r2, [r7, #4]
 800735c:	6812      	ldr	r2, [r2, #0]
 800735e:	6852      	ldr	r2, [r2, #4]
 8007360:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8007364:	605a      	str	r2, [r3, #4]
  
  /* Enable the ADC overrun interrupt */
  __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 8007366:	687b      	ldr	r3, [r7, #4]
 8007368:	681b      	ldr	r3, [r3, #0]
 800736a:	687a      	ldr	r2, [r7, #4]
 800736c:	6812      	ldr	r2, [r2, #0]
 800736e:	6852      	ldr	r2, [r2, #4]
 8007370:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8007374:	605a      	str	r2, [r3, #4]
  
  /* Check if Multimode enabled */
  if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
 8007376:	4b31      	ldr	r3, [pc, #196]	; (800743c <HAL_ADCEx_InjectedStart_IT+0x174>)
 8007378:	685b      	ldr	r3, [r3, #4]
 800737a:	f003 031f 	and.w	r3, r3, #31
 800737e:	2b00      	cmp	r3, #0
 8007380:	d124      	bne.n	80073cc <HAL_ADCEx_InjectedStart_IT+0x104>
  {
    tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
 8007382:	687b      	ldr	r3, [r7, #4]
 8007384:	681b      	ldr	r3, [r3, #0]
 8007386:	689b      	ldr	r3, [r3, #8]
 8007388:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 800738c:	2b00      	cmp	r3, #0
 800738e:	bf0c      	ite	eq
 8007390:	2301      	moveq	r3, #1
 8007392:	2300      	movne	r3, #0
 8007394:	b2db      	uxtb	r3, r3
 8007396:	617b      	str	r3, [r7, #20]
    tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
 8007398:	687b      	ldr	r3, [r7, #4]
 800739a:	681b      	ldr	r3, [r3, #0]
 800739c:	685b      	ldr	r3, [r3, #4]
 800739e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80073a2:	2b00      	cmp	r3, #0
 80073a4:	bf0c      	ite	eq
 80073a6:	2301      	moveq	r3, #1
 80073a8:	2300      	movne	r3, #0
 80073aa:	b2db      	uxtb	r3, r3
 80073ac:	613b      	str	r3, [r7, #16]
    if(tmp1 && tmp2)
 80073ae:	697b      	ldr	r3, [r7, #20]
 80073b0:	2b00      	cmp	r3, #0
 80073b2:	d034      	beq.n	800741e <HAL_ADCEx_InjectedStart_IT+0x156>
 80073b4:	693b      	ldr	r3, [r7, #16]
 80073b6:	2b00      	cmp	r3, #0
 80073b8:	d031      	beq.n	800741e <HAL_ADCEx_InjectedStart_IT+0x156>
    {
      /* Enable the selected ADC software conversion for injected group */
      hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
 80073ba:	687b      	ldr	r3, [r7, #4]
 80073bc:	681b      	ldr	r3, [r3, #0]
 80073be:	687a      	ldr	r2, [r7, #4]
 80073c0:	6812      	ldr	r2, [r2, #0]
 80073c2:	6892      	ldr	r2, [r2, #8]
 80073c4:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 80073c8:	609a      	str	r2, [r3, #8]
 80073ca:	e028      	b.n	800741e <HAL_ADCEx_InjectedStart_IT+0x156>
    }
  }
  else
  {
    tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
 80073cc:	687b      	ldr	r3, [r7, #4]
 80073ce:	681b      	ldr	r3, [r3, #0]
 80073d0:	689b      	ldr	r3, [r3, #8]
 80073d2:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 80073d6:	2b00      	cmp	r3, #0
 80073d8:	bf0c      	ite	eq
 80073da:	2301      	moveq	r3, #1
 80073dc:	2300      	movne	r3, #0
 80073de:	b2db      	uxtb	r3, r3
 80073e0:	617b      	str	r3, [r7, #20]
    tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
 80073e2:	687b      	ldr	r3, [r7, #4]
 80073e4:	681b      	ldr	r3, [r3, #0]
 80073e6:	685b      	ldr	r3, [r3, #4]
 80073e8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80073ec:	2b00      	cmp	r3, #0
 80073ee:	bf0c      	ite	eq
 80073f0:	2301      	moveq	r3, #1
 80073f2:	2300      	movne	r3, #0
 80073f4:	b2db      	uxtb	r3, r3
 80073f6:	613b      	str	r3, [r7, #16]
    if((hadc->Instance == ADC1) && tmp1 && tmp2)  
 80073f8:	687b      	ldr	r3, [r7, #4]
 80073fa:	681b      	ldr	r3, [r3, #0]
 80073fc:	4a10      	ldr	r2, [pc, #64]	; (8007440 <HAL_ADCEx_InjectedStart_IT+0x178>)
 80073fe:	4293      	cmp	r3, r2
 8007400:	d10d      	bne.n	800741e <HAL_ADCEx_InjectedStart_IT+0x156>
 8007402:	697b      	ldr	r3, [r7, #20]
 8007404:	2b00      	cmp	r3, #0
 8007406:	d00a      	beq.n	800741e <HAL_ADCEx_InjectedStart_IT+0x156>
 8007408:	693b      	ldr	r3, [r7, #16]
 800740a:	2b00      	cmp	r3, #0
 800740c:	d007      	beq.n	800741e <HAL_ADCEx_InjectedStart_IT+0x156>
    {
      /* Enable the selected ADC software conversion for injected group */
      hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
 800740e:	687b      	ldr	r3, [r7, #4]
 8007410:	681b      	ldr	r3, [r3, #0]
 8007412:	687a      	ldr	r2, [r7, #4]
 8007414:	6812      	ldr	r2, [r2, #0]
 8007416:	6892      	ldr	r2, [r2, #8]
 8007418:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 800741c:	609a      	str	r2, [r3, #8]
    }
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 800741e:	687b      	ldr	r3, [r7, #4]
 8007420:	2200      	movs	r2, #0
 8007422:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 8007426:	2300      	movs	r3, #0
}
 8007428:	4618      	mov	r0, r3
 800742a:	371c      	adds	r7, #28
 800742c:	46bd      	mov	sp, r7
 800742e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007432:	4770      	bx	lr
 8007434:	20010014 	.word	0x20010014
 8007438:	431bde83 	.word	0x431bde83
 800743c:	40012300 	.word	0x40012300
 8007440:	40012000 	.word	0x40012000

08007444 <HAL_ADCEx_InjectedStop_IT>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedStop_IT(ADC_HandleTypeDef* hadc)
{
 8007444:	b480      	push	{r7}
 8007446:	b083      	sub	sp, #12
 8007448:	af00      	add	r7, sp, #0
 800744a:	6078      	str	r0, [r7, #4]
  /* Disable the ADC end of conversion interrupt for regular group */
  __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 800744c:	687b      	ldr	r3, [r7, #4]
 800744e:	681b      	ldr	r3, [r3, #0]
 8007450:	687a      	ldr	r2, [r7, #4]
 8007452:	6812      	ldr	r2, [r2, #0]
 8007454:	6852      	ldr	r2, [r2, #4]
 8007456:	f022 0220 	bic.w	r2, r2, #32
 800745a:	605a      	str	r2, [r3, #4]
  
  /* Disable the ADC end of conversion interrupt for injected group */
  __HAL_ADC_DISABLE_IT(hadc, ADC_CR1_JEOCIE);
 800745c:	687b      	ldr	r3, [r7, #4]
 800745e:	681b      	ldr	r3, [r3, #0]
 8007460:	687a      	ldr	r2, [r7, #4]
 8007462:	6812      	ldr	r2, [r2, #0]
 8007464:	6852      	ldr	r2, [r2, #4]
 8007466:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800746a:	605a      	str	r2, [r3, #4]
  
  /* Enable the Peripheral */
  __HAL_ADC_DISABLE(hadc);
 800746c:	687b      	ldr	r3, [r7, #4]
 800746e:	681b      	ldr	r3, [r3, #0]
 8007470:	687a      	ldr	r2, [r7, #4]
 8007472:	6812      	ldr	r2, [r2, #0]
 8007474:	6892      	ldr	r2, [r2, #8]
 8007476:	f022 0201 	bic.w	r2, r2, #1
 800747a:	609a      	str	r2, [r3, #8]
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_READY;
 800747c:	687b      	ldr	r3, [r7, #4]
 800747e:	2201      	movs	r2, #1
 8007480:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Return function status */
  return HAL_OK;
 8007484:	2300      	movs	r3, #0
}
 8007486:	4618      	mov	r0, r3
 8007488:	370c      	adds	r7, #12
 800748a:	46bd      	mov	sp, r7
 800748c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007490:	4770      	bx	lr
 8007492:	bf00      	nop

08007494 <HAL_ADCEx_InjectedGetValue>:
  *            @arg ADC_INJECTED_RANK_3: Injected Channel3 selected
  *            @arg ADC_INJECTED_RANK_4: Injected Channel4 selected
  * @retval None
  */
uint32_t HAL_ADCEx_InjectedGetValue(ADC_HandleTypeDef* hadc, uint32_t InjectedRank)
{
 8007494:	b480      	push	{r7}
 8007496:	b085      	sub	sp, #20
 8007498:	af00      	add	r7, sp, #0
 800749a:	6078      	str	r0, [r7, #4]
 800749c:	6039      	str	r1, [r7, #0]
  __IO uint32_t tmp = 0;
 800749e:	2300      	movs	r3, #0
 80074a0:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_ADC_INJECTED_RANK(InjectedRank));
  
   /* Clear the ADCx's flag for injected end of conversion */
   __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_JEOC);
 80074a2:	687b      	ldr	r3, [r7, #4]
 80074a4:	681b      	ldr	r3, [r3, #0]
 80074a6:	f06f 0204 	mvn.w	r2, #4
 80074aa:	601a      	str	r2, [r3, #0]
  
  /* Return the selected ADC converted value */ 
  switch(InjectedRank)
 80074ac:	683b      	ldr	r3, [r7, #0]
 80074ae:	3b01      	subs	r3, #1
 80074b0:	2b03      	cmp	r3, #3
 80074b2:	d81f      	bhi.n	80074f4 <HAL_ADCEx_InjectedGetValue+0x60>
 80074b4:	a201      	add	r2, pc, #4	; (adr r2, 80074bc <HAL_ADCEx_InjectedGetValue+0x28>)
 80074b6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80074ba:	bf00      	nop
 80074bc:	080074eb 	.word	0x080074eb
 80074c0:	080074e1 	.word	0x080074e1
 80074c4:	080074d7 	.word	0x080074d7
 80074c8:	080074cd 	.word	0x080074cd
  {  
    case ADC_INJECTED_RANK_4:
    {
      tmp =  hadc->Instance->JDR4;
 80074cc:	687b      	ldr	r3, [r7, #4]
 80074ce:	681b      	ldr	r3, [r3, #0]
 80074d0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80074d2:	60fb      	str	r3, [r7, #12]
    }  
    break;
 80074d4:	e00f      	b.n	80074f6 <HAL_ADCEx_InjectedGetValue+0x62>
    case ADC_INJECTED_RANK_3: 
    {  
      tmp =  hadc->Instance->JDR3;
 80074d6:	687b      	ldr	r3, [r7, #4]
 80074d8:	681b      	ldr	r3, [r3, #0]
 80074da:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80074dc:	60fb      	str	r3, [r7, #12]
    }  
    break;
 80074de:	e00a      	b.n	80074f6 <HAL_ADCEx_InjectedGetValue+0x62>
    case ADC_INJECTED_RANK_2: 
    {  
      tmp =  hadc->Instance->JDR2;
 80074e0:	687b      	ldr	r3, [r7, #4]
 80074e2:	681b      	ldr	r3, [r3, #0]
 80074e4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80074e6:	60fb      	str	r3, [r7, #12]
    }
    break;
 80074e8:	e005      	b.n	80074f6 <HAL_ADCEx_InjectedGetValue+0x62>
    case ADC_INJECTED_RANK_1:
    {
      tmp =  hadc->Instance->JDR1;
 80074ea:	687b      	ldr	r3, [r7, #4]
 80074ec:	681b      	ldr	r3, [r3, #0]
 80074ee:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80074f0:	60fb      	str	r3, [r7, #12]
    }
    break;
 80074f2:	e000      	b.n	80074f6 <HAL_ADCEx_InjectedGetValue+0x62>
    default:
    break;  
 80074f4:	bf00      	nop
  }
  return tmp;
 80074f6:	68fb      	ldr	r3, [r7, #12]
}
 80074f8:	4618      	mov	r0, r3
 80074fa:	3714      	adds	r7, #20
 80074fc:	46bd      	mov	sp, r7
 80074fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007502:	4770      	bx	lr

08007504 <HAL_ADCEx_InjectedConfigChannel>:
  *         the configuration information for the specified ADC.
  * @param  sConfigInjected: ADC configuration structure for injected channel. 
  * @retval None
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef* hadc, ADC_InjectionConfTypeDef* sConfigInjected)
{
 8007504:	b490      	push	{r4, r7}
 8007506:	b082      	sub	sp, #8
 8007508:	af00      	add	r7, sp, #0
 800750a:	6078      	str	r0, [r7, #4]
 800750c:	6039      	str	r1, [r7, #0]
  tmp = ADC_GET_RESOLUTION(hadc);
  assert_param(IS_ADC_RANGE(tmp, sConfigInjected->InjectedOffset));
#endif /* USE_FULL_ASSERT  */

  /* Process locked */
  __HAL_LOCK(hadc);
 800750e:	687b      	ldr	r3, [r7, #4]
 8007510:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8007514:	2b01      	cmp	r3, #1
 8007516:	d101      	bne.n	800751c <HAL_ADCEx_InjectedConfigChannel+0x18>
 8007518:	2302      	movs	r3, #2
 800751a:	e15c      	b.n	80077d6 <HAL_ADCEx_InjectedConfigChannel+0x2d2>
 800751c:	687b      	ldr	r3, [r7, #4]
 800751e:	2201      	movs	r2, #1
 8007520:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (sConfigInjected->InjectedChannel > ADC_CHANNEL_9)
 8007524:	683b      	ldr	r3, [r7, #0]
 8007526:	681b      	ldr	r3, [r3, #0]
 8007528:	2b09      	cmp	r3, #9
 800752a:	d926      	bls.n	800757a <HAL_ADCEx_InjectedConfigChannel+0x76>
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfigInjected->InjectedChannel);
 800752c:	687b      	ldr	r3, [r7, #4]
 800752e:	681a      	ldr	r2, [r3, #0]
 8007530:	687b      	ldr	r3, [r7, #4]
 8007532:	681b      	ldr	r3, [r3, #0]
 8007534:	68d9      	ldr	r1, [r3, #12]
 8007536:	683b      	ldr	r3, [r7, #0]
 8007538:	681b      	ldr	r3, [r3, #0]
 800753a:	b29b      	uxth	r3, r3
 800753c:	4618      	mov	r0, r3
 800753e:	4603      	mov	r3, r0
 8007540:	005b      	lsls	r3, r3, #1
 8007542:	4403      	add	r3, r0
 8007544:	3b1e      	subs	r3, #30
 8007546:	4618      	mov	r0, r3
 8007548:	2307      	movs	r3, #7
 800754a:	4083      	lsls	r3, r0
 800754c:	43db      	mvns	r3, r3
 800754e:	400b      	ands	r3, r1
 8007550:	60d3      	str	r3, [r2, #12]
    
    /* Set the new sample time */
    hadc->Instance->SMPR1 |= ADC_SMPR1(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel);
 8007552:	687b      	ldr	r3, [r7, #4]
 8007554:	681a      	ldr	r2, [r3, #0]
 8007556:	687b      	ldr	r3, [r7, #4]
 8007558:	681b      	ldr	r3, [r3, #0]
 800755a:	68d9      	ldr	r1, [r3, #12]
 800755c:	683b      	ldr	r3, [r7, #0]
 800755e:	6898      	ldr	r0, [r3, #8]
 8007560:	683b      	ldr	r3, [r7, #0]
 8007562:	681b      	ldr	r3, [r3, #0]
 8007564:	b29b      	uxth	r3, r3
 8007566:	461c      	mov	r4, r3
 8007568:	4623      	mov	r3, r4
 800756a:	005b      	lsls	r3, r3, #1
 800756c:	4423      	add	r3, r4
 800756e:	3b1e      	subs	r3, #30
 8007570:	fa00 f303 	lsl.w	r3, r0, r3
 8007574:	430b      	orrs	r3, r1
 8007576:	60d3      	str	r3, [r2, #12]
 8007578:	e023      	b.n	80075c2 <HAL_ADCEx_InjectedConfigChannel+0xbe>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfigInjected->InjectedChannel);
 800757a:	687b      	ldr	r3, [r7, #4]
 800757c:	681a      	ldr	r2, [r3, #0]
 800757e:	687b      	ldr	r3, [r7, #4]
 8007580:	681b      	ldr	r3, [r3, #0]
 8007582:	6919      	ldr	r1, [r3, #16]
 8007584:	683b      	ldr	r3, [r7, #0]
 8007586:	681b      	ldr	r3, [r3, #0]
 8007588:	b29b      	uxth	r3, r3
 800758a:	4618      	mov	r0, r3
 800758c:	4603      	mov	r3, r0
 800758e:	005b      	lsls	r3, r3, #1
 8007590:	4403      	add	r3, r0
 8007592:	4618      	mov	r0, r3
 8007594:	2307      	movs	r3, #7
 8007596:	4083      	lsls	r3, r0
 8007598:	43db      	mvns	r3, r3
 800759a:	400b      	ands	r3, r1
 800759c:	6113      	str	r3, [r2, #16]
    
    /* Set the new sample time */
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel);
 800759e:	687b      	ldr	r3, [r7, #4]
 80075a0:	681a      	ldr	r2, [r3, #0]
 80075a2:	687b      	ldr	r3, [r7, #4]
 80075a4:	681b      	ldr	r3, [r3, #0]
 80075a6:	6919      	ldr	r1, [r3, #16]
 80075a8:	683b      	ldr	r3, [r7, #0]
 80075aa:	6898      	ldr	r0, [r3, #8]
 80075ac:	683b      	ldr	r3, [r7, #0]
 80075ae:	681b      	ldr	r3, [r3, #0]
 80075b0:	b29b      	uxth	r3, r3
 80075b2:	461c      	mov	r4, r3
 80075b4:	4623      	mov	r3, r4
 80075b6:	005b      	lsls	r3, r3, #1
 80075b8:	4423      	add	r3, r4
 80075ba:	fa00 f303 	lsl.w	r3, r0, r3
 80075be:	430b      	orrs	r3, r1
 80075c0:	6113      	str	r3, [r2, #16]
  }
  
  /*---------------------------- ADCx JSQR Configuration -----------------*/
  hadc->Instance->JSQR &= ~(ADC_JSQR_JL);
 80075c2:	687b      	ldr	r3, [r7, #4]
 80075c4:	681b      	ldr	r3, [r3, #0]
 80075c6:	687a      	ldr	r2, [r7, #4]
 80075c8:	6812      	ldr	r2, [r2, #0]
 80075ca:	6b92      	ldr	r2, [r2, #56]	; 0x38
 80075cc:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 80075d0:	639a      	str	r2, [r3, #56]	; 0x38
  hadc->Instance->JSQR |=  ADC_SQR1(sConfigInjected->InjectedNbrOfConversion);
 80075d2:	687b      	ldr	r3, [r7, #4]
 80075d4:	681b      	ldr	r3, [r3, #0]
 80075d6:	687a      	ldr	r2, [r7, #4]
 80075d8:	6812      	ldr	r2, [r2, #0]
 80075da:	6b91      	ldr	r1, [r2, #56]	; 0x38
 80075dc:	683a      	ldr	r2, [r7, #0]
 80075de:	6912      	ldr	r2, [r2, #16]
 80075e0:	3a01      	subs	r2, #1
 80075e2:	0512      	lsls	r2, r2, #20
 80075e4:	430a      	orrs	r2, r1
 80075e6:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* Rank configuration */
  
  /* Clear the old SQx bits for the selected rank */
  hadc->Instance->JSQR &= ~ADC_JSQR(ADC_JSQR_JSQ1, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
 80075e8:	687b      	ldr	r3, [r7, #4]
 80075ea:	681a      	ldr	r2, [r3, #0]
 80075ec:	687b      	ldr	r3, [r7, #4]
 80075ee:	681b      	ldr	r3, [r3, #0]
 80075f0:	6b99      	ldr	r1, [r3, #56]	; 0x38
 80075f2:	683b      	ldr	r3, [r7, #0]
 80075f4:	685b      	ldr	r3, [r3, #4]
 80075f6:	b2d8      	uxtb	r0, r3
 80075f8:	683b      	ldr	r3, [r7, #0]
 80075fa:	691b      	ldr	r3, [r3, #16]
 80075fc:	b2db      	uxtb	r3, r3
 80075fe:	1ac3      	subs	r3, r0, r3
 8007600:	b2db      	uxtb	r3, r3
 8007602:	3303      	adds	r3, #3
 8007604:	b2db      	uxtb	r3, r3
 8007606:	4618      	mov	r0, r3
 8007608:	4603      	mov	r3, r0
 800760a:	009b      	lsls	r3, r3, #2
 800760c:	4403      	add	r3, r0
 800760e:	201f      	movs	r0, #31
 8007610:	fa00 f303 	lsl.w	r3, r0, r3
 8007614:	43db      	mvns	r3, r3
 8007616:	400b      	ands	r3, r1
 8007618:	6393      	str	r3, [r2, #56]	; 0x38
   
  /* Set the SQx bits for the selected rank */
  hadc->Instance->JSQR |= ADC_JSQR(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
 800761a:	687b      	ldr	r3, [r7, #4]
 800761c:	681a      	ldr	r2, [r3, #0]
 800761e:	687b      	ldr	r3, [r7, #4]
 8007620:	681b      	ldr	r3, [r3, #0]
 8007622:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8007624:	683b      	ldr	r3, [r7, #0]
 8007626:	681b      	ldr	r3, [r3, #0]
 8007628:	b29b      	uxth	r3, r3
 800762a:	461c      	mov	r4, r3
 800762c:	683b      	ldr	r3, [r7, #0]
 800762e:	685b      	ldr	r3, [r3, #4]
 8007630:	b2d8      	uxtb	r0, r3
 8007632:	683b      	ldr	r3, [r7, #0]
 8007634:	691b      	ldr	r3, [r3, #16]
 8007636:	b2db      	uxtb	r3, r3
 8007638:	1ac3      	subs	r3, r0, r3
 800763a:	b2db      	uxtb	r3, r3
 800763c:	3303      	adds	r3, #3
 800763e:	b2db      	uxtb	r3, r3
 8007640:	4618      	mov	r0, r3
 8007642:	4603      	mov	r3, r0
 8007644:	009b      	lsls	r3, r3, #2
 8007646:	4403      	add	r3, r0
 8007648:	fa04 f303 	lsl.w	r3, r4, r3
 800764c:	430b      	orrs	r3, r1
 800764e:	6393      	str	r3, [r2, #56]	; 0x38

  /* Select external trigger to start conversion */
  hadc->Instance->CR2 &= ~(ADC_CR2_JEXTSEL);
 8007650:	687b      	ldr	r3, [r7, #4]
 8007652:	681b      	ldr	r3, [r3, #0]
 8007654:	687a      	ldr	r2, [r7, #4]
 8007656:	6812      	ldr	r2, [r2, #0]
 8007658:	6892      	ldr	r2, [r2, #8]
 800765a:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
 800765e:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |=  sConfigInjected->ExternalTrigInjecConv;
 8007660:	687b      	ldr	r3, [r7, #4]
 8007662:	681b      	ldr	r3, [r3, #0]
 8007664:	687a      	ldr	r2, [r7, #4]
 8007666:	6812      	ldr	r2, [r2, #0]
 8007668:	6891      	ldr	r1, [r2, #8]
 800766a:	683a      	ldr	r2, [r7, #0]
 800766c:	6a12      	ldr	r2, [r2, #32]
 800766e:	430a      	orrs	r2, r1
 8007670:	609a      	str	r2, [r3, #8]
  
  /* Select external trigger polarity */
  hadc->Instance->CR2 &= ~(ADC_CR2_JEXTEN);
 8007672:	687b      	ldr	r3, [r7, #4]
 8007674:	681b      	ldr	r3, [r3, #0]
 8007676:	687a      	ldr	r2, [r7, #4]
 8007678:	6812      	ldr	r2, [r2, #0]
 800767a:	6892      	ldr	r2, [r2, #8]
 800767c:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8007680:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= sConfigInjected->ExternalTrigInjecConvEdge;
 8007682:	687b      	ldr	r3, [r7, #4]
 8007684:	681b      	ldr	r3, [r3, #0]
 8007686:	687a      	ldr	r2, [r7, #4]
 8007688:	6812      	ldr	r2, [r2, #0]
 800768a:	6891      	ldr	r1, [r2, #8]
 800768c:	683a      	ldr	r2, [r7, #0]
 800768e:	69d2      	ldr	r2, [r2, #28]
 8007690:	430a      	orrs	r2, r1
 8007692:	609a      	str	r2, [r3, #8]
  
  if (sConfigInjected->AutoInjectedConv != DISABLE)
 8007694:	683b      	ldr	r3, [r7, #0]
 8007696:	695b      	ldr	r3, [r3, #20]
 8007698:	2b00      	cmp	r3, #0
 800769a:	d008      	beq.n	80076ae <HAL_ADCEx_InjectedConfigChannel+0x1aa>
  {
    /* Enable the selected ADC automatic injected group conversion */
    hadc->Instance->CR1 |= ADC_CR1_JAUTO;
 800769c:	687b      	ldr	r3, [r7, #4]
 800769e:	681b      	ldr	r3, [r3, #0]
 80076a0:	687a      	ldr	r2, [r7, #4]
 80076a2:	6812      	ldr	r2, [r2, #0]
 80076a4:	6852      	ldr	r2, [r2, #4]
 80076a6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80076aa:	605a      	str	r2, [r3, #4]
 80076ac:	e007      	b.n	80076be <HAL_ADCEx_InjectedConfigChannel+0x1ba>
  }
  else
  {
    /* Disable the selected ADC automatic injected group conversion */
    hadc->Instance->CR1 &= ~(ADC_CR1_JAUTO);
 80076ae:	687b      	ldr	r3, [r7, #4]
 80076b0:	681b      	ldr	r3, [r3, #0]
 80076b2:	687a      	ldr	r2, [r7, #4]
 80076b4:	6812      	ldr	r2, [r2, #0]
 80076b6:	6852      	ldr	r2, [r2, #4]
 80076b8:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80076bc:	605a      	str	r2, [r3, #4]
  }
  
  if (sConfigInjected->InjectedDiscontinuousConvMode != DISABLE)
 80076be:	683b      	ldr	r3, [r7, #0]
 80076c0:	699b      	ldr	r3, [r3, #24]
 80076c2:	2b00      	cmp	r3, #0
 80076c4:	d008      	beq.n	80076d8 <HAL_ADCEx_InjectedConfigChannel+0x1d4>
  {
    /* Enable the selected ADC injected discontinuous mode */
    hadc->Instance->CR1 |= ADC_CR1_JDISCEN;
 80076c6:	687b      	ldr	r3, [r7, #4]
 80076c8:	681b      	ldr	r3, [r3, #0]
 80076ca:	687a      	ldr	r2, [r7, #4]
 80076cc:	6812      	ldr	r2, [r2, #0]
 80076ce:	6852      	ldr	r2, [r2, #4]
 80076d0:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80076d4:	605a      	str	r2, [r3, #4]
 80076d6:	e007      	b.n	80076e8 <HAL_ADCEx_InjectedConfigChannel+0x1e4>
  }
  else
  {
    /* Disable the selected ADC injected discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_JDISCEN);
 80076d8:	687b      	ldr	r3, [r7, #4]
 80076da:	681b      	ldr	r3, [r3, #0]
 80076dc:	687a      	ldr	r2, [r7, #4]
 80076de:	6812      	ldr	r2, [r2, #0]
 80076e0:	6852      	ldr	r2, [r2, #4]
 80076e2:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 80076e6:	605a      	str	r2, [r3, #4]
  }
  
  switch(sConfigInjected->InjectedRank)
 80076e8:	683b      	ldr	r3, [r7, #0]
 80076ea:	685b      	ldr	r3, [r3, #4]
 80076ec:	2b02      	cmp	r3, #2
 80076ee:	d015      	beq.n	800771c <HAL_ADCEx_InjectedConfigChannel+0x218>
 80076f0:	2b03      	cmp	r3, #3
 80076f2:	d025      	beq.n	8007740 <HAL_ADCEx_InjectedConfigChannel+0x23c>
 80076f4:	2b01      	cmp	r3, #1
 80076f6:	d135      	bne.n	8007764 <HAL_ADCEx_InjectedConfigChannel+0x260>
  {
    case 1:
      /* Set injected channel 1 offset */
      hadc->Instance->JOFR1 &= ~(ADC_JOFR1_JOFFSET1);
 80076f8:	687b      	ldr	r3, [r7, #4]
 80076fa:	681a      	ldr	r2, [r3, #0]
 80076fc:	687b      	ldr	r3, [r7, #4]
 80076fe:	681b      	ldr	r3, [r3, #0]
 8007700:	6959      	ldr	r1, [r3, #20]
 8007702:	4b37      	ldr	r3, [pc, #220]	; (80077e0 <HAL_ADCEx_InjectedConfigChannel+0x2dc>)
 8007704:	400b      	ands	r3, r1
 8007706:	6153      	str	r3, [r2, #20]
      hadc->Instance->JOFR1 |= sConfigInjected->InjectedOffset;
 8007708:	687b      	ldr	r3, [r7, #4]
 800770a:	681b      	ldr	r3, [r3, #0]
 800770c:	687a      	ldr	r2, [r7, #4]
 800770e:	6812      	ldr	r2, [r2, #0]
 8007710:	6951      	ldr	r1, [r2, #20]
 8007712:	683a      	ldr	r2, [r7, #0]
 8007714:	68d2      	ldr	r2, [r2, #12]
 8007716:	430a      	orrs	r2, r1
 8007718:	615a      	str	r2, [r3, #20]
      break;
 800771a:	e035      	b.n	8007788 <HAL_ADCEx_InjectedConfigChannel+0x284>
    case 2:
      /* Set injected channel 2 offset */
      hadc->Instance->JOFR2 &= ~(ADC_JOFR2_JOFFSET2);
 800771c:	687b      	ldr	r3, [r7, #4]
 800771e:	681a      	ldr	r2, [r3, #0]
 8007720:	687b      	ldr	r3, [r7, #4]
 8007722:	681b      	ldr	r3, [r3, #0]
 8007724:	6999      	ldr	r1, [r3, #24]
 8007726:	4b2e      	ldr	r3, [pc, #184]	; (80077e0 <HAL_ADCEx_InjectedConfigChannel+0x2dc>)
 8007728:	400b      	ands	r3, r1
 800772a:	6193      	str	r3, [r2, #24]
      hadc->Instance->JOFR2 |= sConfigInjected->InjectedOffset;
 800772c:	687b      	ldr	r3, [r7, #4]
 800772e:	681b      	ldr	r3, [r3, #0]
 8007730:	687a      	ldr	r2, [r7, #4]
 8007732:	6812      	ldr	r2, [r2, #0]
 8007734:	6991      	ldr	r1, [r2, #24]
 8007736:	683a      	ldr	r2, [r7, #0]
 8007738:	68d2      	ldr	r2, [r2, #12]
 800773a:	430a      	orrs	r2, r1
 800773c:	619a      	str	r2, [r3, #24]
      break;
 800773e:	e023      	b.n	8007788 <HAL_ADCEx_InjectedConfigChannel+0x284>
    case 3:
      /* Set injected channel 3 offset */
      hadc->Instance->JOFR3 &= ~(ADC_JOFR3_JOFFSET3);
 8007740:	687b      	ldr	r3, [r7, #4]
 8007742:	681a      	ldr	r2, [r3, #0]
 8007744:	687b      	ldr	r3, [r7, #4]
 8007746:	681b      	ldr	r3, [r3, #0]
 8007748:	69d9      	ldr	r1, [r3, #28]
 800774a:	4b25      	ldr	r3, [pc, #148]	; (80077e0 <HAL_ADCEx_InjectedConfigChannel+0x2dc>)
 800774c:	400b      	ands	r3, r1
 800774e:	61d3      	str	r3, [r2, #28]
      hadc->Instance->JOFR3 |= sConfigInjected->InjectedOffset;
 8007750:	687b      	ldr	r3, [r7, #4]
 8007752:	681b      	ldr	r3, [r3, #0]
 8007754:	687a      	ldr	r2, [r7, #4]
 8007756:	6812      	ldr	r2, [r2, #0]
 8007758:	69d1      	ldr	r1, [r2, #28]
 800775a:	683a      	ldr	r2, [r7, #0]
 800775c:	68d2      	ldr	r2, [r2, #12]
 800775e:	430a      	orrs	r2, r1
 8007760:	61da      	str	r2, [r3, #28]
      break;
 8007762:	e011      	b.n	8007788 <HAL_ADCEx_InjectedConfigChannel+0x284>
    default:
      /* Set injected channel 4 offset */
      hadc->Instance->JOFR4 &= ~(ADC_JOFR4_JOFFSET4);
 8007764:	687b      	ldr	r3, [r7, #4]
 8007766:	681a      	ldr	r2, [r3, #0]
 8007768:	687b      	ldr	r3, [r7, #4]
 800776a:	681b      	ldr	r3, [r3, #0]
 800776c:	6a19      	ldr	r1, [r3, #32]
 800776e:	4b1c      	ldr	r3, [pc, #112]	; (80077e0 <HAL_ADCEx_InjectedConfigChannel+0x2dc>)
 8007770:	400b      	ands	r3, r1
 8007772:	6213      	str	r3, [r2, #32]
      hadc->Instance->JOFR4 |= sConfigInjected->InjectedOffset;
 8007774:	687b      	ldr	r3, [r7, #4]
 8007776:	681b      	ldr	r3, [r3, #0]
 8007778:	687a      	ldr	r2, [r7, #4]
 800777a:	6812      	ldr	r2, [r2, #0]
 800777c:	6a11      	ldr	r1, [r2, #32]
 800777e:	683a      	ldr	r2, [r7, #0]
 8007780:	68d2      	ldr	r2, [r2, #12]
 8007782:	430a      	orrs	r2, r1
 8007784:	621a      	str	r2, [r3, #32]
      break;
 8007786:	bf00      	nop
  }
  
  /* if ADC1 Channel_18 is selected enable VBAT Channel */
  if ((hadc->Instance == ADC1) && (sConfigInjected->InjectedChannel == ADC_CHANNEL_VBAT))
 8007788:	687b      	ldr	r3, [r7, #4]
 800778a:	681b      	ldr	r3, [r3, #0]
 800778c:	4a15      	ldr	r2, [pc, #84]	; (80077e4 <HAL_ADCEx_InjectedConfigChannel+0x2e0>)
 800778e:	4293      	cmp	r3, r2
 8007790:	d109      	bne.n	80077a6 <HAL_ADCEx_InjectedConfigChannel+0x2a2>
 8007792:	683b      	ldr	r3, [r7, #0]
 8007794:	681b      	ldr	r3, [r3, #0]
 8007796:	2b12      	cmp	r3, #18
 8007798:	d105      	bne.n	80077a6 <HAL_ADCEx_InjectedConfigChannel+0x2a2>
  {
    /* Enable the VBAT channel*/
    ADC->CCR |= ADC_CCR_VBATE;
 800779a:	4a13      	ldr	r2, [pc, #76]	; (80077e8 <HAL_ADCEx_InjectedConfigChannel+0x2e4>)
 800779c:	4b12      	ldr	r3, [pc, #72]	; (80077e8 <HAL_ADCEx_InjectedConfigChannel+0x2e4>)
 800779e:	685b      	ldr	r3, [r3, #4]
 80077a0:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80077a4:	6053      	str	r3, [r2, #4]
  }
  
  /* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
  if ((hadc->Instance == ADC1) && ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR) || (sConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT)))
 80077a6:	687b      	ldr	r3, [r7, #4]
 80077a8:	681b      	ldr	r3, [r3, #0]
 80077aa:	4a0e      	ldr	r2, [pc, #56]	; (80077e4 <HAL_ADCEx_InjectedConfigChannel+0x2e0>)
 80077ac:	4293      	cmp	r3, r2
 80077ae:	d10d      	bne.n	80077cc <HAL_ADCEx_InjectedConfigChannel+0x2c8>
 80077b0:	683b      	ldr	r3, [r7, #0]
 80077b2:	681b      	ldr	r3, [r3, #0]
 80077b4:	2b10      	cmp	r3, #16
 80077b6:	d003      	beq.n	80077c0 <HAL_ADCEx_InjectedConfigChannel+0x2bc>
 80077b8:	683b      	ldr	r3, [r7, #0]
 80077ba:	681b      	ldr	r3, [r3, #0]
 80077bc:	2b11      	cmp	r3, #17
 80077be:	d105      	bne.n	80077cc <HAL_ADCEx_InjectedConfigChannel+0x2c8>
  {
    /* Enable the TSVREFE channel*/
    ADC->CCR |= ADC_CCR_TSVREFE;
 80077c0:	4a09      	ldr	r2, [pc, #36]	; (80077e8 <HAL_ADCEx_InjectedConfigChannel+0x2e4>)
 80077c2:	4b09      	ldr	r3, [pc, #36]	; (80077e8 <HAL_ADCEx_InjectedConfigChannel+0x2e4>)
 80077c4:	685b      	ldr	r3, [r3, #4]
 80077c6:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80077ca:	6053      	str	r3, [r2, #4]
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80077cc:	687b      	ldr	r3, [r7, #4]
 80077ce:	2200      	movs	r2, #0
 80077d0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 80077d4:	2300      	movs	r3, #0
}
 80077d6:	4618      	mov	r0, r3
 80077d8:	3708      	adds	r7, #8
 80077da:	46bd      	mov	sp, r7
 80077dc:	bc90      	pop	{r4, r7}
 80077de:	4770      	bx	lr
 80077e0:	fffff000 	.word	0xfffff000
 80077e4:	40012000 	.word	0x40012000
 80077e8:	40012300 	.word	0x40012300

080077ec <HAL_ADCEx_MultiModeConfigChannel>:
  * @param  multimode : pointer to an ADC_MultiModeTypeDef structure that contains 
  *                     the configuration information for  multimode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef* hadc, ADC_MultiModeTypeDef* multimode)
{
 80077ec:	b480      	push	{r7}
 80077ee:	b083      	sub	sp, #12
 80077f0:	af00      	add	r7, sp, #0
 80077f2:	6078      	str	r0, [r7, #4]
 80077f4:	6039      	str	r1, [r7, #0]
  assert_param(IS_ADC_MODE(multimode->Mode));
  assert_param(IS_ADC_DMA_ACCESS_MODE(multimode->DMAAccessMode));
  assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 80077f6:	687b      	ldr	r3, [r7, #4]
 80077f8:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80077fc:	2b01      	cmp	r3, #1
 80077fe:	d101      	bne.n	8007804 <HAL_ADCEx_MultiModeConfigChannel+0x18>
 8007800:	2302      	movs	r3, #2
 8007802:	e02f      	b.n	8007864 <HAL_ADCEx_MultiModeConfigChannel+0x78>
 8007804:	687b      	ldr	r3, [r7, #4]
 8007806:	2201      	movs	r2, #1
 8007808:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Set ADC mode */
  ADC->CCR &= ~(ADC_CCR_MULTI);
 800780c:	4a18      	ldr	r2, [pc, #96]	; (8007870 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 800780e:	4b18      	ldr	r3, [pc, #96]	; (8007870 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 8007810:	685b      	ldr	r3, [r3, #4]
 8007812:	f023 031f 	bic.w	r3, r3, #31
 8007816:	6053      	str	r3, [r2, #4]
  ADC->CCR |= multimode->Mode;
 8007818:	4915      	ldr	r1, [pc, #84]	; (8007870 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 800781a:	4b15      	ldr	r3, [pc, #84]	; (8007870 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 800781c:	685a      	ldr	r2, [r3, #4]
 800781e:	683b      	ldr	r3, [r7, #0]
 8007820:	681b      	ldr	r3, [r3, #0]
 8007822:	4313      	orrs	r3, r2
 8007824:	604b      	str	r3, [r1, #4]
  
  /* Set the ADC DMA access mode */
  ADC->CCR &= ~(ADC_CCR_DMA);
 8007826:	4a12      	ldr	r2, [pc, #72]	; (8007870 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 8007828:	4b11      	ldr	r3, [pc, #68]	; (8007870 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 800782a:	685b      	ldr	r3, [r3, #4]
 800782c:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8007830:	6053      	str	r3, [r2, #4]
  ADC->CCR |= multimode->DMAAccessMode;
 8007832:	490f      	ldr	r1, [pc, #60]	; (8007870 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 8007834:	4b0e      	ldr	r3, [pc, #56]	; (8007870 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 8007836:	685a      	ldr	r2, [r3, #4]
 8007838:	683b      	ldr	r3, [r7, #0]
 800783a:	685b      	ldr	r3, [r3, #4]
 800783c:	4313      	orrs	r3, r2
 800783e:	604b      	str	r3, [r1, #4]
  
  /* Set delay between two sampling phases */
  ADC->CCR &= ~(ADC_CCR_DELAY);
 8007840:	4a0b      	ldr	r2, [pc, #44]	; (8007870 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 8007842:	4b0b      	ldr	r3, [pc, #44]	; (8007870 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 8007844:	685b      	ldr	r3, [r3, #4]
 8007846:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 800784a:	6053      	str	r3, [r2, #4]
  ADC->CCR |= multimode->TwoSamplingDelay;
 800784c:	4908      	ldr	r1, [pc, #32]	; (8007870 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 800784e:	4b08      	ldr	r3, [pc, #32]	; (8007870 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 8007850:	685a      	ldr	r2, [r3, #4]
 8007852:	683b      	ldr	r3, [r7, #0]
 8007854:	689b      	ldr	r3, [r3, #8]
 8007856:	4313      	orrs	r3, r2
 8007858:	604b      	str	r3, [r1, #4]
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 800785a:	687b      	ldr	r3, [r7, #4]
 800785c:	2200      	movs	r2, #0
 800785e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 8007862:	2300      	movs	r3, #0
}
 8007864:	4618      	mov	r0, r3
 8007866:	370c      	adds	r7, #12
 8007868:	46bd      	mov	sp, r7
 800786a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800786e:	4770      	bx	lr
 8007870:	40012300 	.word	0x40012300

08007874 <HAL_CAN_Init>:
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Init(CAN_HandleTypeDef* hcan)
{
 8007874:	b580      	push	{r7, lr}
 8007876:	b084      	sub	sp, #16
 8007878:	af00      	add	r7, sp, #0
 800787a:	6078      	str	r0, [r7, #4]
  uint32_t InitStatus = 3;
 800787c:	2303      	movs	r3, #3
 800787e:	60fb      	str	r3, [r7, #12]
  uint32_t tickstart = 0;
 8007880:	2300      	movs	r3, #0
 8007882:	60bb      	str	r3, [r7, #8]
  
  /* Check CAN handle */
  if(hcan == NULL)
 8007884:	687b      	ldr	r3, [r7, #4]
 8007886:	2b00      	cmp	r3, #0
 8007888:	d101      	bne.n	800788e <HAL_CAN_Init+0x1a>
  {
     return HAL_ERROR;
 800788a:	2301      	movs	r3, #1
 800788c:	e117      	b.n	8007abe <HAL_CAN_Init+0x24a>
  assert_param(IS_CAN_BS1(hcan->Init.BS1));
  assert_param(IS_CAN_BS2(hcan->Init.BS2));
  assert_param(IS_CAN_PRESCALER(hcan->Init.Prescaler));
  

  if(hcan->State == HAL_CAN_STATE_RESET)
 800788e:	687b      	ldr	r3, [r7, #4]
 8007890:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8007894:	b2db      	uxtb	r3, r3
 8007896:	2b00      	cmp	r3, #0
 8007898:	d106      	bne.n	80078a8 <HAL_CAN_Init+0x34>
  {
    /* Allocate lock resource and initialize it */
    hcan->Lock = HAL_UNLOCKED;
 800789a:	687b      	ldr	r3, [r7, #4]
 800789c:	2200      	movs	r2, #0
 800789e:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    /* Init the low level hardware */
    HAL_CAN_MspInit(hcan);
 80078a2:	6878      	ldr	r0, [r7, #4]
 80078a4:	f00a fcda 	bl	801225c <HAL_CAN_MspInit>
  }
  
  /* Initialize the CAN state*/
  hcan->State = HAL_CAN_STATE_BUSY;
 80078a8:	687b      	ldr	r3, [r7, #4]
 80078aa:	2202      	movs	r2, #2
 80078ac:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  /* Exit from sleep mode */
  hcan->Instance->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
 80078b0:	687b      	ldr	r3, [r7, #4]
 80078b2:	681b      	ldr	r3, [r3, #0]
 80078b4:	687a      	ldr	r2, [r7, #4]
 80078b6:	6812      	ldr	r2, [r2, #0]
 80078b8:	6812      	ldr	r2, [r2, #0]
 80078ba:	f022 0202 	bic.w	r2, r2, #2
 80078be:	601a      	str	r2, [r3, #0]

  /* Request initialisation */
  hcan->Instance->MCR |= CAN_MCR_INRQ ;
 80078c0:	687b      	ldr	r3, [r7, #4]
 80078c2:	681b      	ldr	r3, [r3, #0]
 80078c4:	687a      	ldr	r2, [r7, #4]
 80078c6:	6812      	ldr	r2, [r2, #0]
 80078c8:	6812      	ldr	r2, [r2, #0]
 80078ca:	f042 0201 	orr.w	r2, r2, #1
 80078ce:	601a      	str	r2, [r3, #0]
  
  /* Get tick */
  tickstart = HAL_GetTick();
 80078d0:	f7ff f88e 	bl	80069f0 <HAL_GetTick>
 80078d4:	60b8      	str	r0, [r7, #8]

  /* Wait the acknowledge */
  while((hcan->Instance->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
 80078d6:	e010      	b.n	80078fa <HAL_CAN_Init+0x86>
  {
    if((HAL_GetTick() - tickstart ) > CAN_TIMEOUT_VALUE)
 80078d8:	f7ff f88a 	bl	80069f0 <HAL_GetTick>
 80078dc:	4602      	mov	r2, r0
 80078de:	68bb      	ldr	r3, [r7, #8]
 80078e0:	1ad3      	subs	r3, r2, r3
 80078e2:	2b0a      	cmp	r3, #10
 80078e4:	d909      	bls.n	80078fa <HAL_CAN_Init+0x86>
    {
      hcan->State= HAL_CAN_STATE_TIMEOUT;
 80078e6:	687b      	ldr	r3, [r7, #4]
 80078e8:	2203      	movs	r2, #3
 80078ea:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
      /* Process unlocked */
      __HAL_UNLOCK(hcan);
 80078ee:	687b      	ldr	r3, [r7, #4]
 80078f0:	2200      	movs	r2, #0
 80078f2:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
      return HAL_TIMEOUT;
 80078f6:	2303      	movs	r3, #3
 80078f8:	e0e1      	b.n	8007abe <HAL_CAN_Init+0x24a>
  
  /* Get tick */
  tickstart = HAL_GetTick();

  /* Wait the acknowledge */
  while((hcan->Instance->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
 80078fa:	687b      	ldr	r3, [r7, #4]
 80078fc:	681b      	ldr	r3, [r3, #0]
 80078fe:	685b      	ldr	r3, [r3, #4]
 8007900:	f003 0301 	and.w	r3, r3, #1
 8007904:	2b00      	cmp	r3, #0
 8007906:	d0e7      	beq.n	80078d8 <HAL_CAN_Init+0x64>
      return HAL_TIMEOUT;
    }
  }

  /* Check acknowledge */
  if ((hcan->Instance->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
 8007908:	687b      	ldr	r3, [r7, #4]
 800790a:	681b      	ldr	r3, [r3, #0]
 800790c:	685b      	ldr	r3, [r3, #4]
 800790e:	f003 0301 	and.w	r3, r3, #1
 8007912:	2b00      	cmp	r3, #0
 8007914:	d102      	bne.n	800791c <HAL_CAN_Init+0xa8>
  {
    InitStatus = CAN_INITSTATUS_FAILED;
 8007916:	2300      	movs	r3, #0
 8007918:	60fb      	str	r3, [r7, #12]
 800791a:	e0bf      	b.n	8007a9c <HAL_CAN_Init+0x228>
  }
  else 
  {
    /* Set the time triggered communication mode */
    if (hcan->Init.TTCM == ENABLE)
 800791c:	687b      	ldr	r3, [r7, #4]
 800791e:	699b      	ldr	r3, [r3, #24]
 8007920:	2b01      	cmp	r3, #1
 8007922:	d108      	bne.n	8007936 <HAL_CAN_Init+0xc2>
    {
      hcan->Instance->MCR |= CAN_MCR_TTCM;
 8007924:	687b      	ldr	r3, [r7, #4]
 8007926:	681b      	ldr	r3, [r3, #0]
 8007928:	687a      	ldr	r2, [r7, #4]
 800792a:	6812      	ldr	r2, [r2, #0]
 800792c:	6812      	ldr	r2, [r2, #0]
 800792e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8007932:	601a      	str	r2, [r3, #0]
 8007934:	e007      	b.n	8007946 <HAL_CAN_Init+0xd2>
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TTCM;
 8007936:	687b      	ldr	r3, [r7, #4]
 8007938:	681b      	ldr	r3, [r3, #0]
 800793a:	687a      	ldr	r2, [r7, #4]
 800793c:	6812      	ldr	r2, [r2, #0]
 800793e:	6812      	ldr	r2, [r2, #0]
 8007940:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8007944:	601a      	str	r2, [r3, #0]
    }

    /* Set the automatic bus-off management */
    if (hcan->Init.ABOM == ENABLE)
 8007946:	687b      	ldr	r3, [r7, #4]
 8007948:	69db      	ldr	r3, [r3, #28]
 800794a:	2b01      	cmp	r3, #1
 800794c:	d108      	bne.n	8007960 <HAL_CAN_Init+0xec>
    {
      hcan->Instance->MCR |= CAN_MCR_ABOM;
 800794e:	687b      	ldr	r3, [r7, #4]
 8007950:	681b      	ldr	r3, [r3, #0]
 8007952:	687a      	ldr	r2, [r7, #4]
 8007954:	6812      	ldr	r2, [r2, #0]
 8007956:	6812      	ldr	r2, [r2, #0]
 8007958:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800795c:	601a      	str	r2, [r3, #0]
 800795e:	e007      	b.n	8007970 <HAL_CAN_Init+0xfc>
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_ABOM;
 8007960:	687b      	ldr	r3, [r7, #4]
 8007962:	681b      	ldr	r3, [r3, #0]
 8007964:	687a      	ldr	r2, [r7, #4]
 8007966:	6812      	ldr	r2, [r2, #0]
 8007968:	6812      	ldr	r2, [r2, #0]
 800796a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800796e:	601a      	str	r2, [r3, #0]
    }

    /* Set the automatic wake-up mode */
    if (hcan->Init.AWUM == ENABLE)
 8007970:	687b      	ldr	r3, [r7, #4]
 8007972:	6a1b      	ldr	r3, [r3, #32]
 8007974:	2b01      	cmp	r3, #1
 8007976:	d108      	bne.n	800798a <HAL_CAN_Init+0x116>
    {
      hcan->Instance->MCR |= CAN_MCR_AWUM;
 8007978:	687b      	ldr	r3, [r7, #4]
 800797a:	681b      	ldr	r3, [r3, #0]
 800797c:	687a      	ldr	r2, [r7, #4]
 800797e:	6812      	ldr	r2, [r2, #0]
 8007980:	6812      	ldr	r2, [r2, #0]
 8007982:	f042 0220 	orr.w	r2, r2, #32
 8007986:	601a      	str	r2, [r3, #0]
 8007988:	e007      	b.n	800799a <HAL_CAN_Init+0x126>
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_AWUM;
 800798a:	687b      	ldr	r3, [r7, #4]
 800798c:	681b      	ldr	r3, [r3, #0]
 800798e:	687a      	ldr	r2, [r7, #4]
 8007990:	6812      	ldr	r2, [r2, #0]
 8007992:	6812      	ldr	r2, [r2, #0]
 8007994:	f022 0220 	bic.w	r2, r2, #32
 8007998:	601a      	str	r2, [r3, #0]
    }

    /* Set the no automatic retransmission */
    if (hcan->Init.NART == ENABLE)
 800799a:	687b      	ldr	r3, [r7, #4]
 800799c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800799e:	2b01      	cmp	r3, #1
 80079a0:	d108      	bne.n	80079b4 <HAL_CAN_Init+0x140>
    {
      hcan->Instance->MCR |= CAN_MCR_NART;
 80079a2:	687b      	ldr	r3, [r7, #4]
 80079a4:	681b      	ldr	r3, [r3, #0]
 80079a6:	687a      	ldr	r2, [r7, #4]
 80079a8:	6812      	ldr	r2, [r2, #0]
 80079aa:	6812      	ldr	r2, [r2, #0]
 80079ac:	f042 0210 	orr.w	r2, r2, #16
 80079b0:	601a      	str	r2, [r3, #0]
 80079b2:	e007      	b.n	80079c4 <HAL_CAN_Init+0x150>
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_NART;
 80079b4:	687b      	ldr	r3, [r7, #4]
 80079b6:	681b      	ldr	r3, [r3, #0]
 80079b8:	687a      	ldr	r2, [r7, #4]
 80079ba:	6812      	ldr	r2, [r2, #0]
 80079bc:	6812      	ldr	r2, [r2, #0]
 80079be:	f022 0210 	bic.w	r2, r2, #16
 80079c2:	601a      	str	r2, [r3, #0]
    }

    /* Set the receive FIFO locked mode */
    if (hcan->Init.RFLM == ENABLE)
 80079c4:	687b      	ldr	r3, [r7, #4]
 80079c6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80079c8:	2b01      	cmp	r3, #1
 80079ca:	d108      	bne.n	80079de <HAL_CAN_Init+0x16a>
    {
      hcan->Instance->MCR |= CAN_MCR_RFLM;
 80079cc:	687b      	ldr	r3, [r7, #4]
 80079ce:	681b      	ldr	r3, [r3, #0]
 80079d0:	687a      	ldr	r2, [r7, #4]
 80079d2:	6812      	ldr	r2, [r2, #0]
 80079d4:	6812      	ldr	r2, [r2, #0]
 80079d6:	f042 0208 	orr.w	r2, r2, #8
 80079da:	601a      	str	r2, [r3, #0]
 80079dc:	e007      	b.n	80079ee <HAL_CAN_Init+0x17a>
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_RFLM;
 80079de:	687b      	ldr	r3, [r7, #4]
 80079e0:	681b      	ldr	r3, [r3, #0]
 80079e2:	687a      	ldr	r2, [r7, #4]
 80079e4:	6812      	ldr	r2, [r2, #0]
 80079e6:	6812      	ldr	r2, [r2, #0]
 80079e8:	f022 0208 	bic.w	r2, r2, #8
 80079ec:	601a      	str	r2, [r3, #0]
    }

    /* Set the transmit FIFO priority */
    if (hcan->Init.TXFP == ENABLE)
 80079ee:	687b      	ldr	r3, [r7, #4]
 80079f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80079f2:	2b01      	cmp	r3, #1
 80079f4:	d108      	bne.n	8007a08 <HAL_CAN_Init+0x194>
    {
      hcan->Instance->MCR |= CAN_MCR_TXFP;
 80079f6:	687b      	ldr	r3, [r7, #4]
 80079f8:	681b      	ldr	r3, [r3, #0]
 80079fa:	687a      	ldr	r2, [r7, #4]
 80079fc:	6812      	ldr	r2, [r2, #0]
 80079fe:	6812      	ldr	r2, [r2, #0]
 8007a00:	f042 0204 	orr.w	r2, r2, #4
 8007a04:	601a      	str	r2, [r3, #0]
 8007a06:	e007      	b.n	8007a18 <HAL_CAN_Init+0x1a4>
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TXFP;
 8007a08:	687b      	ldr	r3, [r7, #4]
 8007a0a:	681b      	ldr	r3, [r3, #0]
 8007a0c:	687a      	ldr	r2, [r7, #4]
 8007a0e:	6812      	ldr	r2, [r2, #0]
 8007a10:	6812      	ldr	r2, [r2, #0]
 8007a12:	f022 0204 	bic.w	r2, r2, #4
 8007a16:	601a      	str	r2, [r3, #0]
    }

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
 8007a18:	687b      	ldr	r3, [r7, #4]
 8007a1a:	681b      	ldr	r3, [r3, #0]
 8007a1c:	687a      	ldr	r2, [r7, #4]
 8007a1e:	6891      	ldr	r1, [r2, #8]
                ((uint32_t)hcan->Init.SJW) | \
 8007a20:	687a      	ldr	r2, [r7, #4]
 8007a22:	68d2      	ldr	r2, [r2, #12]
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    }

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
 8007a24:	4311      	orrs	r1, r2
                ((uint32_t)hcan->Init.SJW) | \
                ((uint32_t)hcan->Init.BS1) | \
 8007a26:	687a      	ldr	r2, [r7, #4]
 8007a28:	6912      	ldr	r2, [r2, #16]
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    }

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
                ((uint32_t)hcan->Init.SJW) | \
 8007a2a:	4311      	orrs	r1, r2
                ((uint32_t)hcan->Init.BS1) | \
                ((uint32_t)hcan->Init.BS2) | \
 8007a2c:	687a      	ldr	r2, [r7, #4]
 8007a2e:	6952      	ldr	r2, [r2, #20]
    }

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
                ((uint32_t)hcan->Init.SJW) | \
                ((uint32_t)hcan->Init.BS1) | \
 8007a30:	4311      	orrs	r1, r2
                ((uint32_t)hcan->Init.BS2) | \
               ((uint32_t)hcan->Init.Prescaler - 1);
 8007a32:	687a      	ldr	r2, [r7, #4]
 8007a34:	6852      	ldr	r2, [r2, #4]
 8007a36:	3a01      	subs	r2, #1

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
                ((uint32_t)hcan->Init.SJW) | \
                ((uint32_t)hcan->Init.BS1) | \
                ((uint32_t)hcan->Init.BS2) | \
 8007a38:	430a      	orrs	r2, r1
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    }

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
 8007a3a:	61da      	str	r2, [r3, #28]
                ((uint32_t)hcan->Init.BS1) | \
                ((uint32_t)hcan->Init.BS2) | \
               ((uint32_t)hcan->Init.Prescaler - 1);

    /* Request leave initialisation */
    hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_INRQ;
 8007a3c:	687b      	ldr	r3, [r7, #4]
 8007a3e:	681b      	ldr	r3, [r3, #0]
 8007a40:	687a      	ldr	r2, [r7, #4]
 8007a42:	6812      	ldr	r2, [r2, #0]
 8007a44:	6812      	ldr	r2, [r2, #0]
 8007a46:	f022 0201 	bic.w	r2, r2, #1
 8007a4a:	601a      	str	r2, [r3, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8007a4c:	f7fe ffd0 	bl	80069f0 <HAL_GetTick>
 8007a50:	60b8      	str	r0, [r7, #8]

   /* Wait the acknowledge */
   while((hcan->Instance->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
 8007a52:	e010      	b.n	8007a76 <HAL_CAN_Init+0x202>
   {
    if((HAL_GetTick() - tickstart ) > CAN_TIMEOUT_VALUE)
 8007a54:	f7fe ffcc 	bl	80069f0 <HAL_GetTick>
 8007a58:	4602      	mov	r2, r0
 8007a5a:	68bb      	ldr	r3, [r7, #8]
 8007a5c:	1ad3      	subs	r3, r2, r3
 8007a5e:	2b0a      	cmp	r3, #10
 8007a60:	d909      	bls.n	8007a76 <HAL_CAN_Init+0x202>
     {
       hcan->State= HAL_CAN_STATE_TIMEOUT;
 8007a62:	687b      	ldr	r3, [r7, #4]
 8007a64:	2203      	movs	r2, #3
 8007a66:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
       /* Process unlocked */
       __HAL_UNLOCK(hcan);
 8007a6a:	687b      	ldr	r3, [r7, #4]
 8007a6c:	2200      	movs	r2, #0
 8007a6e:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
       return HAL_TIMEOUT;
 8007a72:	2303      	movs	r3, #3
 8007a74:	e023      	b.n	8007abe <HAL_CAN_Init+0x24a>

  /* Get tick */
  tickstart = HAL_GetTick();

   /* Wait the acknowledge */
   while((hcan->Instance->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
 8007a76:	687b      	ldr	r3, [r7, #4]
 8007a78:	681b      	ldr	r3, [r3, #0]
 8007a7a:	685b      	ldr	r3, [r3, #4]
 8007a7c:	f003 0301 	and.w	r3, r3, #1
 8007a80:	2b00      	cmp	r3, #0
 8007a82:	d1e7      	bne.n	8007a54 <HAL_CAN_Init+0x1e0>
       return HAL_TIMEOUT;
     }
   }

    /* Check acknowledged */
    if ((hcan->Instance->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
 8007a84:	687b      	ldr	r3, [r7, #4]
 8007a86:	681b      	ldr	r3, [r3, #0]
 8007a88:	685b      	ldr	r3, [r3, #4]
 8007a8a:	f003 0301 	and.w	r3, r3, #1
 8007a8e:	2b00      	cmp	r3, #0
 8007a90:	d002      	beq.n	8007a98 <HAL_CAN_Init+0x224>
    {
      InitStatus = CAN_INITSTATUS_FAILED;
 8007a92:	2300      	movs	r3, #0
 8007a94:	60fb      	str	r3, [r7, #12]
 8007a96:	e001      	b.n	8007a9c <HAL_CAN_Init+0x228>
    }
    else
    {
      InitStatus = CAN_INITSTATUS_SUCCESS;
 8007a98:	2301      	movs	r3, #1
 8007a9a:	60fb      	str	r3, [r7, #12]
    }
  }
 
  if(InitStatus == CAN_INITSTATUS_SUCCESS)
 8007a9c:	68fb      	ldr	r3, [r7, #12]
 8007a9e:	2b01      	cmp	r3, #1
 8007aa0:	d108      	bne.n	8007ab4 <HAL_CAN_Init+0x240>
  {
    /* Set CAN error code to none */
    hcan->ErrorCode = HAL_CAN_ERROR_NONE;
 8007aa2:	687b      	ldr	r3, [r7, #4]
 8007aa4:	2200      	movs	r2, #0
 8007aa6:	63da      	str	r2, [r3, #60]	; 0x3c
    
    /* Initialize the CAN state */
    hcan->State = HAL_CAN_STATE_READY;
 8007aa8:	687b      	ldr	r3, [r7, #4]
 8007aaa:	2201      	movs	r2, #1
 8007aac:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
    /* Return function status */
    return HAL_OK;
 8007ab0:	2300      	movs	r3, #0
 8007ab2:	e004      	b.n	8007abe <HAL_CAN_Init+0x24a>
  }
  else
  {
    /* Initialize the CAN state */
    hcan->State = HAL_CAN_STATE_ERROR;
 8007ab4:	687b      	ldr	r3, [r7, #4]
 8007ab6:	2204      	movs	r2, #4
 8007ab8:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    
    /* Return function status */
    return HAL_ERROR;
 8007abc:	2301      	movs	r3, #1
  }
}
 8007abe:	4618      	mov	r0, r3
 8007ac0:	3710      	adds	r7, #16
 8007ac2:	46bd      	mov	sp, r7
 8007ac4:	bd80      	pop	{r7, pc}
 8007ac6:	bf00      	nop

08007ac8 <HAL_CAN_ConfigFilter>:
  * @param  sFilterConfig: pointer to a CAN_FilterConfTypeDef structure that
  *         contains the filter configuration information.
  * @retval None
  */
HAL_StatusTypeDef HAL_CAN_ConfigFilter(CAN_HandleTypeDef* hcan, CAN_FilterConfTypeDef* sFilterConfig)
{
 8007ac8:	b480      	push	{r7}
 8007aca:	b085      	sub	sp, #20
 8007acc:	af00      	add	r7, sp, #0
 8007ace:	6078      	str	r0, [r7, #4]
 8007ad0:	6039      	str	r1, [r7, #0]
  uint32_t filternbrbitpos = 0;
 8007ad2:	2300      	movs	r3, #0
 8007ad4:	60fb      	str	r3, [r7, #12]
  assert_param(IS_CAN_FILTER_SCALE(sFilterConfig->FilterScale));
  assert_param(IS_CAN_FILTER_FIFO(sFilterConfig->FilterFIFOAssignment));
  assert_param(IS_FUNCTIONAL_STATE(sFilterConfig->FilterActivation));
  assert_param(IS_CAN_BANKNUMBER(sFilterConfig->BankNumber));
  
  filternbrbitpos = ((uint32_t)1) << sFilterConfig->FilterNumber;
 8007ad6:	683b      	ldr	r3, [r7, #0]
 8007ad8:	695b      	ldr	r3, [r3, #20]
 8007ada:	461a      	mov	r2, r3
 8007adc:	2301      	movs	r3, #1
 8007ade:	4093      	lsls	r3, r2
 8007ae0:	60fb      	str	r3, [r7, #12]

  /* Initialisation mode for the filter */
  CAN1->FMR |= (uint32_t)CAN_FMR_FINIT;
 8007ae2:	4a5e      	ldr	r2, [pc, #376]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007ae4:	4b5d      	ldr	r3, [pc, #372]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007ae6:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8007aea:	f043 0301 	orr.w	r3, r3, #1
 8007aee:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
  
  /* Select the start slave bank */
  CAN1->FMR &= ~((uint32_t)CAN_FMR_CAN2SB);
 8007af2:	4a5a      	ldr	r2, [pc, #360]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007af4:	4b59      	ldr	r3, [pc, #356]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007af6:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8007afa:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
 8007afe:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
  CAN1->FMR |= (uint32_t)(sFilterConfig->BankNumber << 8);
 8007b02:	4956      	ldr	r1, [pc, #344]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007b04:	4b55      	ldr	r3, [pc, #340]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007b06:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 8007b0a:	683b      	ldr	r3, [r7, #0]
 8007b0c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007b0e:	021b      	lsls	r3, r3, #8
 8007b10:	4313      	orrs	r3, r2
 8007b12:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
     
  /* Filter Deactivation */
  CAN1->FA1R &= ~(uint32_t)filternbrbitpos;
 8007b16:	4951      	ldr	r1, [pc, #324]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007b18:	4b50      	ldr	r3, [pc, #320]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007b1a:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 8007b1e:	68fb      	ldr	r3, [r7, #12]
 8007b20:	43db      	mvns	r3, r3
 8007b22:	4013      	ands	r3, r2
 8007b24:	f8c1 321c 	str.w	r3, [r1, #540]	; 0x21c

  /* Filter Scale */
  if (sFilterConfig->FilterScale == CAN_FILTERSCALE_16BIT)
 8007b28:	683b      	ldr	r3, [r7, #0]
 8007b2a:	69db      	ldr	r3, [r3, #28]
 8007b2c:	2b00      	cmp	r3, #0
 8007b2e:	d123      	bne.n	8007b78 <HAL_CAN_ConfigFilter+0xb0>
  {
    /* 16-bit scale for the filter */
    CAN1->FS1R &= ~(uint32_t)filternbrbitpos;
 8007b30:	494a      	ldr	r1, [pc, #296]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007b32:	4b4a      	ldr	r3, [pc, #296]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007b34:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 8007b38:	68fb      	ldr	r3, [r7, #12]
 8007b3a:	43db      	mvns	r3, r3
 8007b3c:	4013      	ands	r3, r2
 8007b3e:	f8c1 320c 	str.w	r3, [r1, #524]	; 0x20c

    /* First 16-bit identifier and First 16-bit mask */
    /* Or First 16-bit identifier and Second 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
 8007b42:	4846      	ldr	r0, [pc, #280]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007b44:	683b      	ldr	r3, [r7, #0]
 8007b46:	695b      	ldr	r3, [r3, #20]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16) |
 8007b48:	683a      	ldr	r2, [r7, #0]
 8007b4a:	68d2      	ldr	r2, [r2, #12]
 8007b4c:	0411      	lsls	r1, r2, #16
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
 8007b4e:	683a      	ldr	r2, [r7, #0]
 8007b50:	6852      	ldr	r2, [r2, #4]
 8007b52:	b292      	uxth	r2, r2
    CAN1->FS1R &= ~(uint32_t)filternbrbitpos;

    /* First 16-bit identifier and First 16-bit mask */
    /* Or First 16-bit identifier and Second 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16) |
 8007b54:	430a      	orrs	r2, r1
    /* 16-bit scale for the filter */
    CAN1->FS1R &= ~(uint32_t)filternbrbitpos;

    /* First 16-bit identifier and First 16-bit mask */
    /* Or First 16-bit identifier and Second 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
 8007b56:	3348      	adds	r3, #72	; 0x48
 8007b58:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);

    /* Second 16-bit identifier and Second 16-bit mask */
    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
 8007b5c:	483f      	ldr	r0, [pc, #252]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007b5e:	683b      	ldr	r3, [r7, #0]
 8007b60:	695b      	ldr	r3, [r3, #20]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
 8007b62:	683a      	ldr	r2, [r7, #0]
 8007b64:	6892      	ldr	r2, [r2, #8]
 8007b66:	0411      	lsls	r1, r2, #16
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh);
 8007b68:	683a      	ldr	r2, [r7, #0]
 8007b6a:	6812      	ldr	r2, [r2, #0]
 8007b6c:	b292      	uxth	r2, r2
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);

    /* Second 16-bit identifier and Second 16-bit mask */
    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
 8007b6e:	430a      	orrs	r2, r1
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);

    /* Second 16-bit identifier and Second 16-bit mask */
    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
 8007b70:	3348      	adds	r3, #72	; 0x48
 8007b72:	00db      	lsls	r3, r3, #3
 8007b74:	4403      	add	r3, r0
 8007b76:	605a      	str	r2, [r3, #4]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh);
  }

  if (sFilterConfig->FilterScale == CAN_FILTERSCALE_32BIT)
 8007b78:	683b      	ldr	r3, [r7, #0]
 8007b7a:	69db      	ldr	r3, [r3, #28]
 8007b7c:	2b01      	cmp	r3, #1
 8007b7e:	d122      	bne.n	8007bc6 <HAL_CAN_ConfigFilter+0xfe>
  {
    /* 32-bit scale for the filter */
    CAN1->FS1R |= filternbrbitpos;
 8007b80:	4936      	ldr	r1, [pc, #216]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007b82:	4b36      	ldr	r3, [pc, #216]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007b84:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 8007b88:	68fb      	ldr	r3, [r7, #12]
 8007b8a:	4313      	orrs	r3, r2
 8007b8c:	f8c1 320c 	str.w	r3, [r1, #524]	; 0x20c
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
 8007b90:	4832      	ldr	r0, [pc, #200]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007b92:	683b      	ldr	r3, [r7, #0]
 8007b94:	695b      	ldr	r3, [r3, #20]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
 8007b96:	683a      	ldr	r2, [r7, #0]
 8007b98:	6812      	ldr	r2, [r2, #0]
 8007b9a:	0411      	lsls	r1, r2, #16
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
 8007b9c:	683a      	ldr	r2, [r7, #0]
 8007b9e:	6852      	ldr	r2, [r2, #4]
 8007ba0:	b292      	uxth	r2, r2
  {
    /* 32-bit scale for the filter */
    CAN1->FS1R |= filternbrbitpos;
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
 8007ba2:	430a      	orrs	r2, r1
  if (sFilterConfig->FilterScale == CAN_FILTERSCALE_32BIT)
  {
    /* 32-bit scale for the filter */
    CAN1->FS1R |= filternbrbitpos;
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
 8007ba4:	3348      	adds	r3, #72	; 0x48
 8007ba6:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
    /* 32-bit mask or Second 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
 8007baa:	482c      	ldr	r0, [pc, #176]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007bac:	683b      	ldr	r3, [r7, #0]
 8007bae:	695b      	ldr	r3, [r3, #20]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
 8007bb0:	683a      	ldr	r2, [r7, #0]
 8007bb2:	6892      	ldr	r2, [r2, #8]
 8007bb4:	0411      	lsls	r1, r2, #16
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow);
 8007bb6:	683a      	ldr	r2, [r7, #0]
 8007bb8:	68d2      	ldr	r2, [r2, #12]
 8007bba:	b292      	uxth	r2, r2
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
    /* 32-bit mask or Second 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
 8007bbc:	430a      	orrs	r2, r1
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
    /* 32-bit mask or Second 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
 8007bbe:	3348      	adds	r3, #72	; 0x48
 8007bc0:	00db      	lsls	r3, r3, #3
 8007bc2:	4403      	add	r3, r0
 8007bc4:	605a      	str	r2, [r3, #4]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow);
  }

  /* Filter Mode */
  if (sFilterConfig->FilterMode == CAN_FILTERMODE_IDMASK)
 8007bc6:	683b      	ldr	r3, [r7, #0]
 8007bc8:	699b      	ldr	r3, [r3, #24]
 8007bca:	2b00      	cmp	r3, #0
 8007bcc:	d109      	bne.n	8007be2 <HAL_CAN_ConfigFilter+0x11a>
  {
    /*Id/Mask mode for the filter*/
    CAN1->FM1R &= ~(uint32_t)filternbrbitpos;
 8007bce:	4923      	ldr	r1, [pc, #140]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007bd0:	4b22      	ldr	r3, [pc, #136]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007bd2:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 8007bd6:	68fb      	ldr	r3, [r7, #12]
 8007bd8:	43db      	mvns	r3, r3
 8007bda:	4013      	ands	r3, r2
 8007bdc:	f8c1 3204 	str.w	r3, [r1, #516]	; 0x204
 8007be0:	e007      	b.n	8007bf2 <HAL_CAN_ConfigFilter+0x12a>
  }
  else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
  {
    /*Identifier list mode for the filter*/
    CAN1->FM1R |= (uint32_t)filternbrbitpos;
 8007be2:	491e      	ldr	r1, [pc, #120]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007be4:	4b1d      	ldr	r3, [pc, #116]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007be6:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 8007bea:	68fb      	ldr	r3, [r7, #12]
 8007bec:	4313      	orrs	r3, r2
 8007bee:	f8c1 3204 	str.w	r3, [r1, #516]	; 0x204
  }

  /* Filter FIFO assignment */
  if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO0)
 8007bf2:	683b      	ldr	r3, [r7, #0]
 8007bf4:	691b      	ldr	r3, [r3, #16]
 8007bf6:	2b00      	cmp	r3, #0
 8007bf8:	d108      	bne.n	8007c0c <HAL_CAN_ConfigFilter+0x144>
  {
    /* FIFO 0 assignation for the filter */
    CAN1->FFA1R &= ~(uint32_t)filternbrbitpos;
 8007bfa:	4918      	ldr	r1, [pc, #96]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007bfc:	4b17      	ldr	r3, [pc, #92]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007bfe:	f8d3 2214 	ldr.w	r2, [r3, #532]	; 0x214
 8007c02:	68fb      	ldr	r3, [r7, #12]
 8007c04:	43db      	mvns	r3, r3
 8007c06:	4013      	ands	r3, r2
 8007c08:	f8c1 3214 	str.w	r3, [r1, #532]	; 0x214
  }

  if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO1)
 8007c0c:	683b      	ldr	r3, [r7, #0]
 8007c0e:	691b      	ldr	r3, [r3, #16]
 8007c10:	2b01      	cmp	r3, #1
 8007c12:	d107      	bne.n	8007c24 <HAL_CAN_ConfigFilter+0x15c>
  {
    /* FIFO 1 assignation for the filter */
    CAN1->FFA1R |= (uint32_t)filternbrbitpos;
 8007c14:	4911      	ldr	r1, [pc, #68]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007c16:	4b11      	ldr	r3, [pc, #68]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007c18:	f8d3 2214 	ldr.w	r2, [r3, #532]	; 0x214
 8007c1c:	68fb      	ldr	r3, [r7, #12]
 8007c1e:	4313      	orrs	r3, r2
 8007c20:	f8c1 3214 	str.w	r3, [r1, #532]	; 0x214
  }
  
  /* Filter activation */
  if (sFilterConfig->FilterActivation == ENABLE)
 8007c24:	683b      	ldr	r3, [r7, #0]
 8007c26:	6a1b      	ldr	r3, [r3, #32]
 8007c28:	2b01      	cmp	r3, #1
 8007c2a:	d107      	bne.n	8007c3c <HAL_CAN_ConfigFilter+0x174>
  {
    CAN1->FA1R |= filternbrbitpos;
 8007c2c:	490b      	ldr	r1, [pc, #44]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007c2e:	4b0b      	ldr	r3, [pc, #44]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007c30:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 8007c34:	68fb      	ldr	r3, [r7, #12]
 8007c36:	4313      	orrs	r3, r2
 8007c38:	f8c1 321c 	str.w	r3, [r1, #540]	; 0x21c
  }

  /* Leave the initialisation mode for the filter */
  CAN1->FMR &= ~((uint32_t)CAN_FMR_FINIT);
 8007c3c:	4a07      	ldr	r2, [pc, #28]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007c3e:	4b07      	ldr	r3, [pc, #28]	; (8007c5c <HAL_CAN_ConfigFilter+0x194>)
 8007c40:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8007c44:	f023 0301 	bic.w	r3, r3, #1
 8007c48:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
  
  /* Return function status */
  return HAL_OK;
 8007c4c:	2300      	movs	r3, #0
}
 8007c4e:	4618      	mov	r0, r3
 8007c50:	3714      	adds	r7, #20
 8007c52:	46bd      	mov	sp, r7
 8007c54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007c58:	4770      	bx	lr
 8007c5a:	bf00      	nop
 8007c5c:	40006400 	.word	0x40006400

08007c60 <HAL_CAN_DeInit>:
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_DeInit(CAN_HandleTypeDef* hcan)
{
 8007c60:	b580      	push	{r7, lr}
 8007c62:	b082      	sub	sp, #8
 8007c64:	af00      	add	r7, sp, #0
 8007c66:	6078      	str	r0, [r7, #4]
  /* Check CAN handle */
  if(hcan == NULL)
 8007c68:	687b      	ldr	r3, [r7, #4]
 8007c6a:	2b00      	cmp	r3, #0
 8007c6c:	d101      	bne.n	8007c72 <HAL_CAN_DeInit+0x12>
  {
     return HAL_ERROR;
 8007c6e:	2301      	movs	r3, #1
 8007c70:	e00f      	b.n	8007c92 <HAL_CAN_DeInit+0x32>
  
  /* Check the parameters */
  assert_param(IS_CAN_ALL_INSTANCE(hcan->Instance));
  
  /* Change CAN state */
  hcan->State = HAL_CAN_STATE_BUSY;
 8007c72:	687b      	ldr	r3, [r7, #4]
 8007c74:	2202      	movs	r2, #2
 8007c76:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  /* DeInit the low level hardware */
  HAL_CAN_MspDeInit(hcan);
 8007c7a:	6878      	ldr	r0, [r7, #4]
 8007c7c:	f000 f80e 	bl	8007c9c <HAL_CAN_MspDeInit>
  
  /* Change CAN state */
  hcan->State = HAL_CAN_STATE_RESET;
 8007c80:	687b      	ldr	r3, [r7, #4]
 8007c82:	2200      	movs	r2, #0
 8007c84:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  /* Release Lock */
  __HAL_UNLOCK(hcan);
 8007c88:	687b      	ldr	r3, [r7, #4]
 8007c8a:	2200      	movs	r2, #0
 8007c8c:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  /* Return function status */
  return HAL_OK;
 8007c90:	2300      	movs	r3, #0
}
 8007c92:	4618      	mov	r0, r3
 8007c94:	3708      	adds	r7, #8
 8007c96:	46bd      	mov	sp, r7
 8007c98:	bd80      	pop	{r7, pc}
 8007c9a:	bf00      	nop

08007c9c <HAL_CAN_MspDeInit>:
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.  
  * @retval None
  */
__weak void HAL_CAN_MspDeInit(CAN_HandleTypeDef* hcan)
{
 8007c9c:	b480      	push	{r7}
 8007c9e:	b083      	sub	sp, #12
 8007ca0:	af00      	add	r7, sp, #0
 8007ca2:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_MspDeInit could be implemented in the user file
   */ 
}
 8007ca4:	370c      	adds	r7, #12
 8007ca6:	46bd      	mov	sp, r7
 8007ca8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007cac:	4770      	bx	lr
 8007cae:	bf00      	nop

08007cb0 <HAL_CAN_Transmit>:
  *         the configuration information for the specified CAN.  
  * @param  Timeout: Specify Timeout value   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Transmit(CAN_HandleTypeDef* hcan, uint32_t Timeout)
{
 8007cb0:	b580      	push	{r7, lr}
 8007cb2:	b084      	sub	sp, #16
 8007cb4:	af00      	add	r7, sp, #0
 8007cb6:	6078      	str	r0, [r7, #4]
 8007cb8:	6039      	str	r1, [r7, #0]
  uint32_t  transmitmailbox = 5;
 8007cba:	2305      	movs	r3, #5
 8007cbc:	60fb      	str	r3, [r7, #12]
  uint32_t tickstart = 0;
 8007cbe:	2300      	movs	r3, #0
 8007cc0:	60bb      	str	r3, [r7, #8]
  assert_param(IS_CAN_IDTYPE(hcan->pTxMsg->IDE));
  assert_param(IS_CAN_RTR(hcan->pTxMsg->RTR));
  assert_param(IS_CAN_DLC(hcan->pTxMsg->DLC));
  
  /* Process locked */
  __HAL_LOCK(hcan);
 8007cc2:	687b      	ldr	r3, [r7, #4]
 8007cc4:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 8007cc8:	2b01      	cmp	r3, #1
 8007cca:	d101      	bne.n	8007cd0 <HAL_CAN_Transmit+0x20>
 8007ccc:	2302      	movs	r3, #2
 8007cce:	e156      	b.n	8007f7e <HAL_CAN_Transmit+0x2ce>
 8007cd0:	687b      	ldr	r3, [r7, #4]
 8007cd2:	2201      	movs	r2, #1
 8007cd4:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  if(hcan->State == HAL_CAN_STATE_BUSY_RX) 
 8007cd8:	687b      	ldr	r3, [r7, #4]
 8007cda:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8007cde:	b2db      	uxtb	r3, r3
 8007ce0:	2b22      	cmp	r3, #34	; 0x22
 8007ce2:	d104      	bne.n	8007cee <HAL_CAN_Transmit+0x3e>
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_TX_RX;
 8007ce4:	687b      	ldr	r3, [r7, #4]
 8007ce6:	2232      	movs	r2, #50	; 0x32
 8007ce8:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
 8007cec:	e003      	b.n	8007cf6 <HAL_CAN_Transmit+0x46>
  }
  else
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_TX;
 8007cee:	687b      	ldr	r3, [r7, #4]
 8007cf0:	2212      	movs	r2, #18
 8007cf2:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  }
  
  /* Select one empty transmit mailbox */
  if ((hcan->Instance->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
 8007cf6:	687b      	ldr	r3, [r7, #4]
 8007cf8:	681b      	ldr	r3, [r3, #0]
 8007cfa:	689b      	ldr	r3, [r3, #8]
 8007cfc:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8007d00:	2b00      	cmp	r3, #0
 8007d02:	d002      	beq.n	8007d0a <HAL_CAN_Transmit+0x5a>
  {
    transmitmailbox = 0;
 8007d04:	2300      	movs	r3, #0
 8007d06:	60fb      	str	r3, [r7, #12]
 8007d08:	e015      	b.n	8007d36 <HAL_CAN_Transmit+0x86>
  }
  else if ((hcan->Instance->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
 8007d0a:	687b      	ldr	r3, [r7, #4]
 8007d0c:	681b      	ldr	r3, [r3, #0]
 8007d0e:	689b      	ldr	r3, [r3, #8]
 8007d10:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8007d14:	2b00      	cmp	r3, #0
 8007d16:	d002      	beq.n	8007d1e <HAL_CAN_Transmit+0x6e>
  {
    transmitmailbox = 1;
 8007d18:	2301      	movs	r3, #1
 8007d1a:	60fb      	str	r3, [r7, #12]
 8007d1c:	e00b      	b.n	8007d36 <HAL_CAN_Transmit+0x86>
  }
  else if ((hcan->Instance->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
 8007d1e:	687b      	ldr	r3, [r7, #4]
 8007d20:	681b      	ldr	r3, [r3, #0]
 8007d22:	689b      	ldr	r3, [r3, #8]
 8007d24:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8007d28:	2b00      	cmp	r3, #0
 8007d2a:	d002      	beq.n	8007d32 <HAL_CAN_Transmit+0x82>
  {
    transmitmailbox = 2;
 8007d2c:	2302      	movs	r3, #2
 8007d2e:	60fb      	str	r3, [r7, #12]
 8007d30:	e001      	b.n	8007d36 <HAL_CAN_Transmit+0x86>
  }
  else
  {
    transmitmailbox = CAN_TXSTATUS_NOMAILBOX;
 8007d32:	2304      	movs	r3, #4
 8007d34:	60fb      	str	r3, [r7, #12]
  }

  if (transmitmailbox != CAN_TXSTATUS_NOMAILBOX)
 8007d36:	68fb      	ldr	r3, [r7, #12]
 8007d38:	2b04      	cmp	r3, #4
 8007d3a:	f000 8117 	beq.w	8007f6c <HAL_CAN_Transmit+0x2bc>
  {
    /* Set up the Id */
    hcan->Instance->sTxMailBox[transmitmailbox].TIR &= CAN_TI0R_TXRQ;
 8007d3e:	687b      	ldr	r3, [r7, #4]
 8007d40:	6819      	ldr	r1, [r3, #0]
 8007d42:	687b      	ldr	r3, [r7, #4]
 8007d44:	681a      	ldr	r2, [r3, #0]
 8007d46:	68fb      	ldr	r3, [r7, #12]
 8007d48:	3318      	adds	r3, #24
 8007d4a:	011b      	lsls	r3, r3, #4
 8007d4c:	4413      	add	r3, r2
 8007d4e:	681b      	ldr	r3, [r3, #0]
 8007d50:	f003 0201 	and.w	r2, r3, #1
 8007d54:	68fb      	ldr	r3, [r7, #12]
 8007d56:	3318      	adds	r3, #24
 8007d58:	011b      	lsls	r3, r3, #4
 8007d5a:	440b      	add	r3, r1
 8007d5c:	601a      	str	r2, [r3, #0]
    if (hcan->pTxMsg->IDE == CAN_ID_STD)
 8007d5e:	687b      	ldr	r3, [r7, #4]
 8007d60:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007d62:	689b      	ldr	r3, [r3, #8]
 8007d64:	2b00      	cmp	r3, #0
 8007d66:	d117      	bne.n	8007d98 <HAL_CAN_Transmit+0xe8>
    {
      assert_param(IS_CAN_STDID(hcan->pTxMsg->StdId));  
      hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->StdId << 21) | \
 8007d68:	687b      	ldr	r3, [r7, #4]
 8007d6a:	6819      	ldr	r1, [r3, #0]
 8007d6c:	687b      	ldr	r3, [r7, #4]
 8007d6e:	681a      	ldr	r2, [r3, #0]
 8007d70:	68fb      	ldr	r3, [r7, #12]
 8007d72:	3318      	adds	r3, #24
 8007d74:	011b      	lsls	r3, r3, #4
 8007d76:	4413      	add	r3, r2
 8007d78:	681a      	ldr	r2, [r3, #0]
 8007d7a:	687b      	ldr	r3, [r7, #4]
 8007d7c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007d7e:	681b      	ldr	r3, [r3, #0]
 8007d80:	0558      	lsls	r0, r3, #21
                                                  hcan->pTxMsg->RTR);
 8007d82:	687b      	ldr	r3, [r7, #4]
 8007d84:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007d86:	68db      	ldr	r3, [r3, #12]
    /* Set up the Id */
    hcan->Instance->sTxMailBox[transmitmailbox].TIR &= CAN_TI0R_TXRQ;
    if (hcan->pTxMsg->IDE == CAN_ID_STD)
    {
      assert_param(IS_CAN_STDID(hcan->pTxMsg->StdId));  
      hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->StdId << 21) | \
 8007d88:	4303      	orrs	r3, r0
 8007d8a:	431a      	orrs	r2, r3
 8007d8c:	68fb      	ldr	r3, [r7, #12]
 8007d8e:	3318      	adds	r3, #24
 8007d90:	011b      	lsls	r3, r3, #4
 8007d92:	440b      	add	r3, r1
 8007d94:	601a      	str	r2, [r3, #0]
 8007d96:	e01a      	b.n	8007dce <HAL_CAN_Transmit+0x11e>
                                                  hcan->pTxMsg->RTR);
    }
    else
    {
      assert_param(IS_CAN_EXTID(hcan->pTxMsg->ExtId));
      hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->ExtId << 3) | \
 8007d98:	687b      	ldr	r3, [r7, #4]
 8007d9a:	6819      	ldr	r1, [r3, #0]
 8007d9c:	687b      	ldr	r3, [r7, #4]
 8007d9e:	681a      	ldr	r2, [r3, #0]
 8007da0:	68fb      	ldr	r3, [r7, #12]
 8007da2:	3318      	adds	r3, #24
 8007da4:	011b      	lsls	r3, r3, #4
 8007da6:	4413      	add	r3, r2
 8007da8:	681a      	ldr	r2, [r3, #0]
 8007daa:	687b      	ldr	r3, [r7, #4]
 8007dac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007dae:	685b      	ldr	r3, [r3, #4]
 8007db0:	00d8      	lsls	r0, r3, #3
                                                  hcan->pTxMsg->IDE | \
 8007db2:	687b      	ldr	r3, [r7, #4]
 8007db4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007db6:	689b      	ldr	r3, [r3, #8]
                                                  hcan->pTxMsg->RTR);
    }
    else
    {
      assert_param(IS_CAN_EXTID(hcan->pTxMsg->ExtId));
      hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->ExtId << 3) | \
 8007db8:	4318      	orrs	r0, r3
                                                  hcan->pTxMsg->IDE | \
                                                  hcan->pTxMsg->RTR);
 8007dba:	687b      	ldr	r3, [r7, #4]
 8007dbc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007dbe:	68db      	ldr	r3, [r3, #12]
    }
    else
    {
      assert_param(IS_CAN_EXTID(hcan->pTxMsg->ExtId));
      hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->ExtId << 3) | \
                                                  hcan->pTxMsg->IDE | \
 8007dc0:	4303      	orrs	r3, r0
                                                  hcan->pTxMsg->RTR);
    }
    else
    {
      assert_param(IS_CAN_EXTID(hcan->pTxMsg->ExtId));
      hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->ExtId << 3) | \
 8007dc2:	431a      	orrs	r2, r3
 8007dc4:	68fb      	ldr	r3, [r7, #12]
 8007dc6:	3318      	adds	r3, #24
 8007dc8:	011b      	lsls	r3, r3, #4
 8007dca:	440b      	add	r3, r1
 8007dcc:	601a      	str	r2, [r3, #0]
                                                  hcan->pTxMsg->IDE | \
                                                  hcan->pTxMsg->RTR);
    }
    
    /* Set up the DLC */
    hcan->pTxMsg->DLC &= (uint8_t)0x0000000F;
 8007dce:	687b      	ldr	r3, [r7, #4]
 8007dd0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007dd2:	687a      	ldr	r2, [r7, #4]
 8007dd4:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8007dd6:	6912      	ldr	r2, [r2, #16]
 8007dd8:	f002 020f 	and.w	r2, r2, #15
 8007ddc:	611a      	str	r2, [r3, #16]
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR &= (uint32_t)0xFFFFFFF0;
 8007dde:	687b      	ldr	r3, [r7, #4]
 8007de0:	6819      	ldr	r1, [r3, #0]
 8007de2:	687b      	ldr	r3, [r7, #4]
 8007de4:	681a      	ldr	r2, [r3, #0]
 8007de6:	68fb      	ldr	r3, [r7, #12]
 8007de8:	3318      	adds	r3, #24
 8007dea:	011b      	lsls	r3, r3, #4
 8007dec:	4413      	add	r3, r2
 8007dee:	685b      	ldr	r3, [r3, #4]
 8007df0:	f023 020f 	bic.w	r2, r3, #15
 8007df4:	68fb      	ldr	r3, [r7, #12]
 8007df6:	3318      	adds	r3, #24
 8007df8:	011b      	lsls	r3, r3, #4
 8007dfa:	440b      	add	r3, r1
 8007dfc:	605a      	str	r2, [r3, #4]
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR |= hcan->pTxMsg->DLC;
 8007dfe:	687b      	ldr	r3, [r7, #4]
 8007e00:	6819      	ldr	r1, [r3, #0]
 8007e02:	687b      	ldr	r3, [r7, #4]
 8007e04:	681a      	ldr	r2, [r3, #0]
 8007e06:	68fb      	ldr	r3, [r7, #12]
 8007e08:	3318      	adds	r3, #24
 8007e0a:	011b      	lsls	r3, r3, #4
 8007e0c:	4413      	add	r3, r2
 8007e0e:	685a      	ldr	r2, [r3, #4]
 8007e10:	687b      	ldr	r3, [r7, #4]
 8007e12:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007e14:	691b      	ldr	r3, [r3, #16]
 8007e16:	431a      	orrs	r2, r3
 8007e18:	68fb      	ldr	r3, [r7, #12]
 8007e1a:	3318      	adds	r3, #24
 8007e1c:	011b      	lsls	r3, r3, #4
 8007e1e:	440b      	add	r3, r1
 8007e20:	605a      	str	r2, [r3, #4]

    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
 8007e22:	687b      	ldr	r3, [r7, #4]
 8007e24:	6819      	ldr	r1, [r3, #0]
 8007e26:	687b      	ldr	r3, [r7, #4]
 8007e28:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007e2a:	7ddb      	ldrb	r3, [r3, #23]
 8007e2c:	061a      	lsls	r2, r3, #24
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
 8007e2e:	687b      	ldr	r3, [r7, #4]
 8007e30:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007e32:	7d9b      	ldrb	r3, [r3, #22]
 8007e34:	041b      	lsls	r3, r3, #16
    hcan->pTxMsg->DLC &= (uint8_t)0x0000000F;
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR &= (uint32_t)0xFFFFFFF0;
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR |= hcan->pTxMsg->DLC;

    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
 8007e36:	431a      	orrs	r2, r3
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
 8007e38:	687b      	ldr	r3, [r7, #4]
 8007e3a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007e3c:	7d5b      	ldrb	r3, [r3, #21]
 8007e3e:	021b      	lsls	r3, r3, #8
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR &= (uint32_t)0xFFFFFFF0;
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR |= hcan->pTxMsg->DLC;

    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
 8007e40:	4313      	orrs	r3, r2
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
                                             ((uint32_t)hcan->pTxMsg->Data[0]));
 8007e42:	687a      	ldr	r2, [r7, #4]
 8007e44:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8007e46:	7d12      	ldrb	r2, [r2, #20]
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR |= hcan->pTxMsg->DLC;

    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
 8007e48:	431a      	orrs	r2, r3
    hcan->pTxMsg->DLC &= (uint8_t)0x0000000F;
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR &= (uint32_t)0xFFFFFFF0;
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR |= hcan->pTxMsg->DLC;

    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
 8007e4a:	68fb      	ldr	r3, [r7, #12]
 8007e4c:	011b      	lsls	r3, r3, #4
 8007e4e:	440b      	add	r3, r1
 8007e50:	f503 73c4 	add.w	r3, r3, #392	; 0x188
 8007e54:	601a      	str	r2, [r3, #0]
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
                                             ((uint32_t)hcan->pTxMsg->Data[0]));
    hcan->Instance->sTxMailBox[transmitmailbox].TDHR = (((uint32_t)hcan->pTxMsg->Data[7] << 24) | 
 8007e56:	687b      	ldr	r3, [r7, #4]
 8007e58:	6819      	ldr	r1, [r3, #0]
 8007e5a:	687b      	ldr	r3, [r7, #4]
 8007e5c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007e5e:	7edb      	ldrb	r3, [r3, #27]
 8007e60:	061a      	lsls	r2, r3, #24
                                             ((uint32_t)hcan->pTxMsg->Data[6] << 16) |
 8007e62:	687b      	ldr	r3, [r7, #4]
 8007e64:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007e66:	7e9b      	ldrb	r3, [r3, #26]
 8007e68:	041b      	lsls	r3, r3, #16
    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
                                             ((uint32_t)hcan->pTxMsg->Data[0]));
    hcan->Instance->sTxMailBox[transmitmailbox].TDHR = (((uint32_t)hcan->pTxMsg->Data[7] << 24) | 
 8007e6a:	431a      	orrs	r2, r3
                                             ((uint32_t)hcan->pTxMsg->Data[6] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[5] << 8) |
 8007e6c:	687b      	ldr	r3, [r7, #4]
 8007e6e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007e70:	7e5b      	ldrb	r3, [r3, #25]
 8007e72:	021b      	lsls	r3, r3, #8
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
                                             ((uint32_t)hcan->pTxMsg->Data[0]));
    hcan->Instance->sTxMailBox[transmitmailbox].TDHR = (((uint32_t)hcan->pTxMsg->Data[7] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[6] << 16) |
 8007e74:	4313      	orrs	r3, r2
                                             ((uint32_t)hcan->pTxMsg->Data[5] << 8) |
                                             ((uint32_t)hcan->pTxMsg->Data[4]));
 8007e76:	687a      	ldr	r2, [r7, #4]
 8007e78:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8007e7a:	7e12      	ldrb	r2, [r2, #24]
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
                                             ((uint32_t)hcan->pTxMsg->Data[0]));
    hcan->Instance->sTxMailBox[transmitmailbox].TDHR = (((uint32_t)hcan->pTxMsg->Data[7] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[6] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[5] << 8) |
 8007e7c:	431a      	orrs	r2, r3
    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
                                             ((uint32_t)hcan->pTxMsg->Data[0]));
    hcan->Instance->sTxMailBox[transmitmailbox].TDHR = (((uint32_t)hcan->pTxMsg->Data[7] << 24) | 
 8007e7e:	68fb      	ldr	r3, [r7, #12]
 8007e80:	011b      	lsls	r3, r3, #4
 8007e82:	440b      	add	r3, r1
 8007e84:	f503 73c4 	add.w	r3, r3, #392	; 0x188
 8007e88:	605a      	str	r2, [r3, #4]
                                             ((uint32_t)hcan->pTxMsg->Data[6] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[5] << 8) |
                                             ((uint32_t)hcan->pTxMsg->Data[4]));
    /* Request transmission */
    hcan->Instance->sTxMailBox[transmitmailbox].TIR |= CAN_TI0R_TXRQ;
 8007e8a:	687b      	ldr	r3, [r7, #4]
 8007e8c:	6819      	ldr	r1, [r3, #0]
 8007e8e:	687b      	ldr	r3, [r7, #4]
 8007e90:	681a      	ldr	r2, [r3, #0]
 8007e92:	68fb      	ldr	r3, [r7, #12]
 8007e94:	3318      	adds	r3, #24
 8007e96:	011b      	lsls	r3, r3, #4
 8007e98:	4413      	add	r3, r2
 8007e9a:	681b      	ldr	r3, [r3, #0]
 8007e9c:	f043 0201 	orr.w	r2, r3, #1
 8007ea0:	68fb      	ldr	r3, [r7, #12]
 8007ea2:	3318      	adds	r3, #24
 8007ea4:	011b      	lsls	r3, r3, #4
 8007ea6:	440b      	add	r3, r1
 8007ea8:	601a      	str	r2, [r3, #0]
  
  /* Get tick */ 
  tickstart = HAL_GetTick();
 8007eaa:	f7fe fda1 	bl	80069f0 <HAL_GetTick>
 8007eae:	60b8      	str	r0, [r7, #8]
  
    /* Check End of transmission flag */
    while(!(__HAL_CAN_TRANSMIT_STATUS(hcan, transmitmailbox)))
 8007eb0:	e018      	b.n	8007ee4 <HAL_CAN_Transmit+0x234>
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 8007eb2:	683b      	ldr	r3, [r7, #0]
 8007eb4:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007eb8:	d014      	beq.n	8007ee4 <HAL_CAN_Transmit+0x234>
      {
       if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8007eba:	683b      	ldr	r3, [r7, #0]
 8007ebc:	2b00      	cmp	r3, #0
 8007ebe:	d007      	beq.n	8007ed0 <HAL_CAN_Transmit+0x220>
 8007ec0:	f7fe fd96 	bl	80069f0 <HAL_GetTick>
 8007ec4:	4602      	mov	r2, r0
 8007ec6:	68bb      	ldr	r3, [r7, #8]
 8007ec8:	1ad2      	subs	r2, r2, r3
 8007eca:	683b      	ldr	r3, [r7, #0]
 8007ecc:	429a      	cmp	r2, r3
 8007ece:	d909      	bls.n	8007ee4 <HAL_CAN_Transmit+0x234>
       {
         hcan->State = HAL_CAN_STATE_TIMEOUT;
 8007ed0:	687b      	ldr	r3, [r7, #4]
 8007ed2:	2203      	movs	r2, #3
 8007ed4:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
         /* Process unlocked */
         __HAL_UNLOCK(hcan);
 8007ed8:	687b      	ldr	r3, [r7, #4]
 8007eda:	2200      	movs	r2, #0
 8007edc:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
         return HAL_TIMEOUT;
 8007ee0:	2303      	movs	r3, #3
 8007ee2:	e04c      	b.n	8007f7e <HAL_CAN_Transmit+0x2ce>
  
  /* Get tick */ 
  tickstart = HAL_GetTick();
  
    /* Check End of transmission flag */
    while(!(__HAL_CAN_TRANSMIT_STATUS(hcan, transmitmailbox)))
 8007ee4:	68fb      	ldr	r3, [r7, #12]
 8007ee6:	2b00      	cmp	r3, #0
 8007ee8:	d10b      	bne.n	8007f02 <HAL_CAN_Transmit+0x252>
 8007eea:	687b      	ldr	r3, [r7, #4]
 8007eec:	681b      	ldr	r3, [r3, #0]
 8007eee:	689a      	ldr	r2, [r3, #8]
 8007ef0:	4b25      	ldr	r3, [pc, #148]	; (8007f88 <HAL_CAN_Transmit+0x2d8>)
 8007ef2:	4013      	ands	r3, r2
 8007ef4:	4a24      	ldr	r2, [pc, #144]	; (8007f88 <HAL_CAN_Transmit+0x2d8>)
 8007ef6:	4293      	cmp	r3, r2
 8007ef8:	bf14      	ite	ne
 8007efa:	2301      	movne	r3, #1
 8007efc:	2300      	moveq	r3, #0
 8007efe:	b2db      	uxtb	r3, r3
 8007f00:	e019      	b.n	8007f36 <HAL_CAN_Transmit+0x286>
 8007f02:	68fb      	ldr	r3, [r7, #12]
 8007f04:	2b01      	cmp	r3, #1
 8007f06:	d10b      	bne.n	8007f20 <HAL_CAN_Transmit+0x270>
 8007f08:	687b      	ldr	r3, [r7, #4]
 8007f0a:	681b      	ldr	r3, [r3, #0]
 8007f0c:	689a      	ldr	r2, [r3, #8]
 8007f0e:	4b1f      	ldr	r3, [pc, #124]	; (8007f8c <HAL_CAN_Transmit+0x2dc>)
 8007f10:	4013      	ands	r3, r2
 8007f12:	4a1e      	ldr	r2, [pc, #120]	; (8007f8c <HAL_CAN_Transmit+0x2dc>)
 8007f14:	4293      	cmp	r3, r2
 8007f16:	bf14      	ite	ne
 8007f18:	2301      	movne	r3, #1
 8007f1a:	2300      	moveq	r3, #0
 8007f1c:	b2db      	uxtb	r3, r3
 8007f1e:	e00a      	b.n	8007f36 <HAL_CAN_Transmit+0x286>
 8007f20:	687b      	ldr	r3, [r7, #4]
 8007f22:	681b      	ldr	r3, [r3, #0]
 8007f24:	689a      	ldr	r2, [r3, #8]
 8007f26:	4b1a      	ldr	r3, [pc, #104]	; (8007f90 <HAL_CAN_Transmit+0x2e0>)
 8007f28:	4013      	ands	r3, r2
 8007f2a:	4a19      	ldr	r2, [pc, #100]	; (8007f90 <HAL_CAN_Transmit+0x2e0>)
 8007f2c:	4293      	cmp	r3, r2
 8007f2e:	bf14      	ite	ne
 8007f30:	2301      	movne	r3, #1
 8007f32:	2300      	moveq	r3, #0
 8007f34:	b2db      	uxtb	r3, r3
 8007f36:	2b00      	cmp	r3, #0
 8007f38:	d1bb      	bne.n	8007eb2 <HAL_CAN_Transmit+0x202>
         __HAL_UNLOCK(hcan);
         return HAL_TIMEOUT;
        }
      }
    }
    if(hcan->State == HAL_CAN_STATE_BUSY_TX_RX) 
 8007f3a:	687b      	ldr	r3, [r7, #4]
 8007f3c:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8007f40:	b2db      	uxtb	r3, r3
 8007f42:	2b32      	cmp	r3, #50	; 0x32
 8007f44:	d108      	bne.n	8007f58 <HAL_CAN_Transmit+0x2a8>
    {
      /* Change CAN state */
      hcan->State = HAL_CAN_STATE_BUSY_RX;
 8007f46:	687b      	ldr	r3, [r7, #4]
 8007f48:	2222      	movs	r2, #34	; 0x22
 8007f4a:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
      
      /* Process unlocked */
      __HAL_UNLOCK(hcan);
 8007f4e:	687b      	ldr	r3, [r7, #4]
 8007f50:	2200      	movs	r2, #0
 8007f52:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
 8007f56:	e007      	b.n	8007f68 <HAL_CAN_Transmit+0x2b8>
    }
    else
    {
      /* Change CAN state */
      hcan->State = HAL_CAN_STATE_READY;
 8007f58:	687b      	ldr	r3, [r7, #4]
 8007f5a:	2201      	movs	r2, #1
 8007f5c:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
      
      /* Process unlocked */
      __HAL_UNLOCK(hcan);
 8007f60:	687b      	ldr	r3, [r7, #4]
 8007f62:	2200      	movs	r2, #0
 8007f64:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    }
    
    /* Return function status */
    return HAL_OK;
 8007f68:	2300      	movs	r3, #0
 8007f6a:	e008      	b.n	8007f7e <HAL_CAN_Transmit+0x2ce>
  }
  else
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_ERROR;
 8007f6c:	687b      	ldr	r3, [r7, #4]
 8007f6e:	2204      	movs	r2, #4
 8007f70:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

    /* Process unlocked */
    __HAL_UNLOCK(hcan);
 8007f74:	687b      	ldr	r3, [r7, #4]
 8007f76:	2200      	movs	r2, #0
 8007f78:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

    /* Return function status */
    return HAL_ERROR;
 8007f7c:	2301      	movs	r3, #1
  }
}
 8007f7e:	4618      	mov	r0, r3
 8007f80:	3710      	adds	r7, #16
 8007f82:	46bd      	mov	sp, r7
 8007f84:	bd80      	pop	{r7, pc}
 8007f86:	bf00      	nop
 8007f88:	04000003 	.word	0x04000003
 8007f8c:	08000300 	.word	0x08000300
 8007f90:	10030000 	.word	0x10030000

08007f94 <HAL_CAN_Receive>:
  * @param  FIFONumber: FIFO Number value
  * @param  Timeout: Specify Timeout value 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Receive(CAN_HandleTypeDef* hcan, uint8_t FIFONumber, uint32_t Timeout)
{
 8007f94:	b580      	push	{r7, lr}
 8007f96:	b086      	sub	sp, #24
 8007f98:	af00      	add	r7, sp, #0
 8007f9a:	60f8      	str	r0, [r7, #12]
 8007f9c:	460b      	mov	r3, r1
 8007f9e:	607a      	str	r2, [r7, #4]
 8007fa0:	72fb      	strb	r3, [r7, #11]
  uint32_t tickstart = 0;
 8007fa2:	2300      	movs	r3, #0
 8007fa4:	617b      	str	r3, [r7, #20]
   
  /* Check the parameters */
  assert_param(IS_CAN_FIFO(FIFONumber));
  
  /* Process locked */
  __HAL_LOCK(hcan);
 8007fa6:	68fb      	ldr	r3, [r7, #12]
 8007fa8:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 8007fac:	2b01      	cmp	r3, #1
 8007fae:	d101      	bne.n	8007fb4 <HAL_CAN_Receive+0x20>
 8007fb0:	2302      	movs	r3, #2
 8007fb2:	e129      	b.n	8008208 <HAL_CAN_Receive+0x274>
 8007fb4:	68fb      	ldr	r3, [r7, #12]
 8007fb6:	2201      	movs	r2, #1
 8007fb8:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  if(hcan->State == HAL_CAN_STATE_BUSY_TX) 
 8007fbc:	68fb      	ldr	r3, [r7, #12]
 8007fbe:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8007fc2:	b2db      	uxtb	r3, r3
 8007fc4:	2b12      	cmp	r3, #18
 8007fc6:	d104      	bne.n	8007fd2 <HAL_CAN_Receive+0x3e>
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_TX_RX;
 8007fc8:	68fb      	ldr	r3, [r7, #12]
 8007fca:	2232      	movs	r2, #50	; 0x32
 8007fcc:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
 8007fd0:	e003      	b.n	8007fda <HAL_CAN_Receive+0x46>
  }
  else
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_RX;
 8007fd2:	68fb      	ldr	r3, [r7, #12]
 8007fd4:	2222      	movs	r2, #34	; 0x22
 8007fd6:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  }
    
  /* Get tick */ 
  tickstart = HAL_GetTick();
 8007fda:	f7fe fd09 	bl	80069f0 <HAL_GetTick>
 8007fde:	6178      	str	r0, [r7, #20]
  
  /* Check pending message */
  while(__HAL_CAN_MSG_PENDING(hcan, FIFONumber) == 0)
 8007fe0:	e018      	b.n	8008014 <HAL_CAN_Receive+0x80>
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 8007fe2:	687b      	ldr	r3, [r7, #4]
 8007fe4:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007fe8:	d014      	beq.n	8008014 <HAL_CAN_Receive+0x80>
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8007fea:	687b      	ldr	r3, [r7, #4]
 8007fec:	2b00      	cmp	r3, #0
 8007fee:	d007      	beq.n	8008000 <HAL_CAN_Receive+0x6c>
 8007ff0:	f7fe fcfe 	bl	80069f0 <HAL_GetTick>
 8007ff4:	4602      	mov	r2, r0
 8007ff6:	697b      	ldr	r3, [r7, #20]
 8007ff8:	1ad2      	subs	r2, r2, r3
 8007ffa:	687b      	ldr	r3, [r7, #4]
 8007ffc:	429a      	cmp	r2, r3
 8007ffe:	d909      	bls.n	8008014 <HAL_CAN_Receive+0x80>
      {
        hcan->State = HAL_CAN_STATE_TIMEOUT;
 8008000:	68fb      	ldr	r3, [r7, #12]
 8008002:	2203      	movs	r2, #3
 8008004:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
        /* Process unlocked */
        __HAL_UNLOCK(hcan);
 8008008:	68fb      	ldr	r3, [r7, #12]
 800800a:	2200      	movs	r2, #0
 800800c:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
        return HAL_TIMEOUT;
 8008010:	2303      	movs	r3, #3
 8008012:	e0f9      	b.n	8008208 <HAL_CAN_Receive+0x274>
    
  /* Get tick */ 
  tickstart = HAL_GetTick();
  
  /* Check pending message */
  while(__HAL_CAN_MSG_PENDING(hcan, FIFONumber) == 0)
 8008014:	7afb      	ldrb	r3, [r7, #11]
 8008016:	2b00      	cmp	r3, #0
 8008018:	d10b      	bne.n	8008032 <HAL_CAN_Receive+0x9e>
 800801a:	68fb      	ldr	r3, [r7, #12]
 800801c:	681b      	ldr	r3, [r3, #0]
 800801e:	68db      	ldr	r3, [r3, #12]
 8008020:	b2db      	uxtb	r3, r3
 8008022:	f003 0303 	and.w	r3, r3, #3
 8008026:	2b00      	cmp	r3, #0
 8008028:	bf0c      	ite	eq
 800802a:	2301      	moveq	r3, #1
 800802c:	2300      	movne	r3, #0
 800802e:	b2db      	uxtb	r3, r3
 8008030:	e00a      	b.n	8008048 <HAL_CAN_Receive+0xb4>
 8008032:	68fb      	ldr	r3, [r7, #12]
 8008034:	681b      	ldr	r3, [r3, #0]
 8008036:	691b      	ldr	r3, [r3, #16]
 8008038:	b2db      	uxtb	r3, r3
 800803a:	f003 0303 	and.w	r3, r3, #3
 800803e:	2b00      	cmp	r3, #0
 8008040:	bf0c      	ite	eq
 8008042:	2301      	moveq	r3, #1
 8008044:	2300      	movne	r3, #0
 8008046:	b2db      	uxtb	r3, r3
 8008048:	2b00      	cmp	r3, #0
 800804a:	d1ca      	bne.n	8007fe2 <HAL_CAN_Receive+0x4e>
      }
    }
  }
  
  /* Get the Id */
  hcan->pRxMsg->IDE = (uint8_t)0x04 & hcan->Instance->sFIFOMailBox[FIFONumber].RIR;
 800804c:	68fb      	ldr	r3, [r7, #12]
 800804e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008050:	68fa      	ldr	r2, [r7, #12]
 8008052:	6811      	ldr	r1, [r2, #0]
 8008054:	7afa      	ldrb	r2, [r7, #11]
 8008056:	321b      	adds	r2, #27
 8008058:	0112      	lsls	r2, r2, #4
 800805a:	440a      	add	r2, r1
 800805c:	6812      	ldr	r2, [r2, #0]
 800805e:	f002 0204 	and.w	r2, r2, #4
 8008062:	609a      	str	r2, [r3, #8]
  if (hcan->pRxMsg->IDE == CAN_ID_STD)
 8008064:	68fb      	ldr	r3, [r7, #12]
 8008066:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008068:	689b      	ldr	r3, [r3, #8]
 800806a:	2b00      	cmp	r3, #0
 800806c:	d10b      	bne.n	8008086 <HAL_CAN_Receive+0xf2>
  {
    hcan->pRxMsg->StdId = (uint32_t)0x000007FF & (hcan->Instance->sFIFOMailBox[FIFONumber].RIR >> 21);
 800806e:	68fb      	ldr	r3, [r7, #12]
 8008070:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008072:	68fa      	ldr	r2, [r7, #12]
 8008074:	6811      	ldr	r1, [r2, #0]
 8008076:	7afa      	ldrb	r2, [r7, #11]
 8008078:	321b      	adds	r2, #27
 800807a:	0112      	lsls	r2, r2, #4
 800807c:	440a      	add	r2, r1
 800807e:	6812      	ldr	r2, [r2, #0]
 8008080:	0d52      	lsrs	r2, r2, #21
 8008082:	601a      	str	r2, [r3, #0]
 8008084:	e00a      	b.n	800809c <HAL_CAN_Receive+0x108>
  }
  else
  {
    hcan->pRxMsg->ExtId = (uint32_t)0x1FFFFFFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RIR >> 3);
 8008086:	68fb      	ldr	r3, [r7, #12]
 8008088:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800808a:	68fa      	ldr	r2, [r7, #12]
 800808c:	6811      	ldr	r1, [r2, #0]
 800808e:	7afa      	ldrb	r2, [r7, #11]
 8008090:	321b      	adds	r2, #27
 8008092:	0112      	lsls	r2, r2, #4
 8008094:	440a      	add	r2, r1
 8008096:	6812      	ldr	r2, [r2, #0]
 8008098:	08d2      	lsrs	r2, r2, #3
 800809a:	605a      	str	r2, [r3, #4]
  }
  
  hcan->pRxMsg->RTR = (uint8_t)0x02 & hcan->Instance->sFIFOMailBox[FIFONumber].RIR;
 800809c:	68fb      	ldr	r3, [r7, #12]
 800809e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80080a0:	68fa      	ldr	r2, [r7, #12]
 80080a2:	6811      	ldr	r1, [r2, #0]
 80080a4:	7afa      	ldrb	r2, [r7, #11]
 80080a6:	321b      	adds	r2, #27
 80080a8:	0112      	lsls	r2, r2, #4
 80080aa:	440a      	add	r2, r1
 80080ac:	6812      	ldr	r2, [r2, #0]
 80080ae:	f002 0202 	and.w	r2, r2, #2
 80080b2:	60da      	str	r2, [r3, #12]
  /* Get the DLC */
  hcan->pRxMsg->DLC = (uint8_t)0x0F & hcan->Instance->sFIFOMailBox[FIFONumber].RDTR;
 80080b4:	68fb      	ldr	r3, [r7, #12]
 80080b6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80080b8:	68fa      	ldr	r2, [r7, #12]
 80080ba:	6811      	ldr	r1, [r2, #0]
 80080bc:	7afa      	ldrb	r2, [r7, #11]
 80080be:	321b      	adds	r2, #27
 80080c0:	0112      	lsls	r2, r2, #4
 80080c2:	440a      	add	r2, r1
 80080c4:	6852      	ldr	r2, [r2, #4]
 80080c6:	f002 020f 	and.w	r2, r2, #15
 80080ca:	611a      	str	r2, [r3, #16]
  /* Get the FMI */
  hcan->pRxMsg->FMI = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDTR >> 8);
 80080cc:	68fb      	ldr	r3, [r7, #12]
 80080ce:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80080d0:	68fa      	ldr	r2, [r7, #12]
 80080d2:	6811      	ldr	r1, [r2, #0]
 80080d4:	7afa      	ldrb	r2, [r7, #11]
 80080d6:	321b      	adds	r2, #27
 80080d8:	0112      	lsls	r2, r2, #4
 80080da:	440a      	add	r2, r1
 80080dc:	6852      	ldr	r2, [r2, #4]
 80080de:	0a12      	lsrs	r2, r2, #8
 80080e0:	b2d2      	uxtb	r2, r2
 80080e2:	61da      	str	r2, [r3, #28]
  /* Get the data field */
  hcan->pRxMsg->Data[0] = (uint8_t)0xFF & hcan->Instance->sFIFOMailBox[FIFONumber].RDLR;
 80080e4:	68fb      	ldr	r3, [r7, #12]
 80080e6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80080e8:	68fa      	ldr	r2, [r7, #12]
 80080ea:	6811      	ldr	r1, [r2, #0]
 80080ec:	7afa      	ldrb	r2, [r7, #11]
 80080ee:	0112      	lsls	r2, r2, #4
 80080f0:	440a      	add	r2, r1
 80080f2:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 80080f6:	6812      	ldr	r2, [r2, #0]
 80080f8:	b2d2      	uxtb	r2, r2
 80080fa:	751a      	strb	r2, [r3, #20]
  hcan->pRxMsg->Data[1] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 8);
 80080fc:	68fb      	ldr	r3, [r7, #12]
 80080fe:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008100:	68fa      	ldr	r2, [r7, #12]
 8008102:	6811      	ldr	r1, [r2, #0]
 8008104:	7afa      	ldrb	r2, [r7, #11]
 8008106:	0112      	lsls	r2, r2, #4
 8008108:	440a      	add	r2, r1
 800810a:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 800810e:	6812      	ldr	r2, [r2, #0]
 8008110:	0a12      	lsrs	r2, r2, #8
 8008112:	b2d2      	uxtb	r2, r2
 8008114:	755a      	strb	r2, [r3, #21]
  hcan->pRxMsg->Data[2] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 16);
 8008116:	68fb      	ldr	r3, [r7, #12]
 8008118:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800811a:	68fa      	ldr	r2, [r7, #12]
 800811c:	6811      	ldr	r1, [r2, #0]
 800811e:	7afa      	ldrb	r2, [r7, #11]
 8008120:	0112      	lsls	r2, r2, #4
 8008122:	440a      	add	r2, r1
 8008124:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8008128:	6812      	ldr	r2, [r2, #0]
 800812a:	0c12      	lsrs	r2, r2, #16
 800812c:	b2d2      	uxtb	r2, r2
 800812e:	759a      	strb	r2, [r3, #22]
  hcan->pRxMsg->Data[3] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 24);
 8008130:	68fb      	ldr	r3, [r7, #12]
 8008132:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008134:	68fa      	ldr	r2, [r7, #12]
 8008136:	6811      	ldr	r1, [r2, #0]
 8008138:	7afa      	ldrb	r2, [r7, #11]
 800813a:	0112      	lsls	r2, r2, #4
 800813c:	440a      	add	r2, r1
 800813e:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8008142:	6812      	ldr	r2, [r2, #0]
 8008144:	0e12      	lsrs	r2, r2, #24
 8008146:	b2d2      	uxtb	r2, r2
 8008148:	75da      	strb	r2, [r3, #23]
  hcan->pRxMsg->Data[4] = (uint8_t)0xFF & hcan->Instance->sFIFOMailBox[FIFONumber].RDHR;
 800814a:	68fb      	ldr	r3, [r7, #12]
 800814c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800814e:	68fa      	ldr	r2, [r7, #12]
 8008150:	6811      	ldr	r1, [r2, #0]
 8008152:	7afa      	ldrb	r2, [r7, #11]
 8008154:	0112      	lsls	r2, r2, #4
 8008156:	440a      	add	r2, r1
 8008158:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 800815c:	6852      	ldr	r2, [r2, #4]
 800815e:	b2d2      	uxtb	r2, r2
 8008160:	761a      	strb	r2, [r3, #24]
  hcan->pRxMsg->Data[5] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 8);
 8008162:	68fb      	ldr	r3, [r7, #12]
 8008164:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008166:	68fa      	ldr	r2, [r7, #12]
 8008168:	6811      	ldr	r1, [r2, #0]
 800816a:	7afa      	ldrb	r2, [r7, #11]
 800816c:	0112      	lsls	r2, r2, #4
 800816e:	440a      	add	r2, r1
 8008170:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8008174:	6852      	ldr	r2, [r2, #4]
 8008176:	0a12      	lsrs	r2, r2, #8
 8008178:	b2d2      	uxtb	r2, r2
 800817a:	765a      	strb	r2, [r3, #25]
  hcan->pRxMsg->Data[6] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 16);
 800817c:	68fb      	ldr	r3, [r7, #12]
 800817e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008180:	68fa      	ldr	r2, [r7, #12]
 8008182:	6811      	ldr	r1, [r2, #0]
 8008184:	7afa      	ldrb	r2, [r7, #11]
 8008186:	0112      	lsls	r2, r2, #4
 8008188:	440a      	add	r2, r1
 800818a:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 800818e:	6852      	ldr	r2, [r2, #4]
 8008190:	0c12      	lsrs	r2, r2, #16
 8008192:	b2d2      	uxtb	r2, r2
 8008194:	769a      	strb	r2, [r3, #26]
  hcan->pRxMsg->Data[7] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 24);
 8008196:	68fb      	ldr	r3, [r7, #12]
 8008198:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800819a:	68fa      	ldr	r2, [r7, #12]
 800819c:	6811      	ldr	r1, [r2, #0]
 800819e:	7afa      	ldrb	r2, [r7, #11]
 80081a0:	0112      	lsls	r2, r2, #4
 80081a2:	440a      	add	r2, r1
 80081a4:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 80081a8:	6852      	ldr	r2, [r2, #4]
 80081aa:	0e12      	lsrs	r2, r2, #24
 80081ac:	b2d2      	uxtb	r2, r2
 80081ae:	76da      	strb	r2, [r3, #27]
  
  /* Release the FIFO */
  if(FIFONumber == CAN_FIFO0)
 80081b0:	7afb      	ldrb	r3, [r7, #11]
 80081b2:	2b00      	cmp	r3, #0
 80081b4:	d108      	bne.n	80081c8 <HAL_CAN_Receive+0x234>
  {
    /* Release FIFO0 */
    __HAL_CAN_FIFO_RELEASE(hcan, CAN_FIFO0);
 80081b6:	68fb      	ldr	r3, [r7, #12]
 80081b8:	681b      	ldr	r3, [r3, #0]
 80081ba:	68fa      	ldr	r2, [r7, #12]
 80081bc:	6812      	ldr	r2, [r2, #0]
 80081be:	68d2      	ldr	r2, [r2, #12]
 80081c0:	f042 0220 	orr.w	r2, r2, #32
 80081c4:	60da      	str	r2, [r3, #12]
 80081c6:	e007      	b.n	80081d8 <HAL_CAN_Receive+0x244>
  }
  else /* FIFONumber == CAN_FIFO1 */
  {
    /* Release FIFO1 */
    __HAL_CAN_FIFO_RELEASE(hcan, CAN_FIFO1);
 80081c8:	68fb      	ldr	r3, [r7, #12]
 80081ca:	681b      	ldr	r3, [r3, #0]
 80081cc:	68fa      	ldr	r2, [r7, #12]
 80081ce:	6812      	ldr	r2, [r2, #0]
 80081d0:	6912      	ldr	r2, [r2, #16]
 80081d2:	f042 0220 	orr.w	r2, r2, #32
 80081d6:	611a      	str	r2, [r3, #16]
  }
  
  if(hcan->State == HAL_CAN_STATE_BUSY_TX_RX) 
 80081d8:	68fb      	ldr	r3, [r7, #12]
 80081da:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 80081de:	b2db      	uxtb	r3, r3
 80081e0:	2b32      	cmp	r3, #50	; 0x32
 80081e2:	d108      	bne.n	80081f6 <HAL_CAN_Receive+0x262>
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_TX;
 80081e4:	68fb      	ldr	r3, [r7, #12]
 80081e6:	2212      	movs	r2, #18
 80081e8:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    
    /* Process unlocked */
    __HAL_UNLOCK(hcan);
 80081ec:	68fb      	ldr	r3, [r7, #12]
 80081ee:	2200      	movs	r2, #0
 80081f0:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
 80081f4:	e007      	b.n	8008206 <HAL_CAN_Receive+0x272>
  }
  else
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_READY;
 80081f6:	68fb      	ldr	r3, [r7, #12]
 80081f8:	2201      	movs	r2, #1
 80081fa:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    
    /* Process unlocked */
    __HAL_UNLOCK(hcan);
 80081fe:	68fb      	ldr	r3, [r7, #12]
 8008200:	2200      	movs	r2, #0
 8008202:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  }
  
  /* Return function status */
  return HAL_OK;
 8008206:	2300      	movs	r3, #0
}
 8008208:	4618      	mov	r0, r3
 800820a:	3718      	adds	r7, #24
 800820c:	46bd      	mov	sp, r7
 800820e:	bd80      	pop	{r7, pc}

08008210 <HAL_CAN_IRQHandler>:
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
void HAL_CAN_IRQHandler(CAN_HandleTypeDef* hcan)
{
 8008210:	b580      	push	{r7, lr}
 8008212:	b086      	sub	sp, #24
 8008214:	af00      	add	r7, sp, #0
 8008216:	6078      	str	r0, [r7, #4]
  uint32_t tmp1 = 0, tmp2 = 0, tmp3 = 0;
 8008218:	2300      	movs	r3, #0
 800821a:	617b      	str	r3, [r7, #20]
 800821c:	2300      	movs	r3, #0
 800821e:	613b      	str	r3, [r7, #16]
 8008220:	2300      	movs	r3, #0
 8008222:	60fb      	str	r3, [r7, #12]
  
  /* Check End of transmission flag */
  if(__HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_TME))
 8008224:	687b      	ldr	r3, [r7, #4]
 8008226:	681b      	ldr	r3, [r3, #0]
 8008228:	695b      	ldr	r3, [r3, #20]
 800822a:	f003 0301 	and.w	r3, r3, #1
 800822e:	2b00      	cmp	r3, #0
 8008230:	d037      	beq.n	80082a2 <HAL_CAN_IRQHandler+0x92>
  {
    tmp1 = __HAL_CAN_TRANSMIT_STATUS(hcan, CAN_TXMAILBOX_0);
 8008232:	687b      	ldr	r3, [r7, #4]
 8008234:	681b      	ldr	r3, [r3, #0]
 8008236:	689a      	ldr	r2, [r3, #8]
 8008238:	4b15      	ldr	r3, [pc, #84]	; (8008290 <HAL_CAN_IRQHandler+0x80>)
 800823a:	4013      	ands	r3, r2
 800823c:	4a14      	ldr	r2, [pc, #80]	; (8008290 <HAL_CAN_IRQHandler+0x80>)
 800823e:	4293      	cmp	r3, r2
 8008240:	bf0c      	ite	eq
 8008242:	2301      	moveq	r3, #1
 8008244:	2300      	movne	r3, #0
 8008246:	b2db      	uxtb	r3, r3
 8008248:	617b      	str	r3, [r7, #20]
    tmp2 = __HAL_CAN_TRANSMIT_STATUS(hcan, CAN_TXMAILBOX_1);
 800824a:	687b      	ldr	r3, [r7, #4]
 800824c:	681b      	ldr	r3, [r3, #0]
 800824e:	689a      	ldr	r2, [r3, #8]
 8008250:	4b10      	ldr	r3, [pc, #64]	; (8008294 <HAL_CAN_IRQHandler+0x84>)
 8008252:	4013      	ands	r3, r2
 8008254:	4a0f      	ldr	r2, [pc, #60]	; (8008294 <HAL_CAN_IRQHandler+0x84>)
 8008256:	4293      	cmp	r3, r2
 8008258:	bf0c      	ite	eq
 800825a:	2301      	moveq	r3, #1
 800825c:	2300      	movne	r3, #0
 800825e:	b2db      	uxtb	r3, r3
 8008260:	613b      	str	r3, [r7, #16]
    tmp3 = __HAL_CAN_TRANSMIT_STATUS(hcan, CAN_TXMAILBOX_2);
 8008262:	687b      	ldr	r3, [r7, #4]
 8008264:	681b      	ldr	r3, [r3, #0]
 8008266:	689a      	ldr	r2, [r3, #8]
 8008268:	4b0b      	ldr	r3, [pc, #44]	; (8008298 <HAL_CAN_IRQHandler+0x88>)
 800826a:	4013      	ands	r3, r2
 800826c:	4a0a      	ldr	r2, [pc, #40]	; (8008298 <HAL_CAN_IRQHandler+0x88>)
 800826e:	4293      	cmp	r3, r2
 8008270:	bf0c      	ite	eq
 8008272:	2301      	moveq	r3, #1
 8008274:	2300      	movne	r3, #0
 8008276:	b2db      	uxtb	r3, r3
 8008278:	60fb      	str	r3, [r7, #12]
    if(tmp1 || tmp2 || tmp3)  
 800827a:	697b      	ldr	r3, [r7, #20]
 800827c:	2b00      	cmp	r3, #0
 800827e:	d10d      	bne.n	800829c <HAL_CAN_IRQHandler+0x8c>
 8008280:	693b      	ldr	r3, [r7, #16]
 8008282:	2b00      	cmp	r3, #0
 8008284:	d10a      	bne.n	800829c <HAL_CAN_IRQHandler+0x8c>
 8008286:	68fb      	ldr	r3, [r7, #12]
 8008288:	2b00      	cmp	r3, #0
 800828a:	d00a      	beq.n	80082a2 <HAL_CAN_IRQHandler+0x92>
 800828c:	e006      	b.n	800829c <HAL_CAN_IRQHandler+0x8c>
 800828e:	bf00      	nop
 8008290:	04000003 	.word	0x04000003
 8008294:	08000300 	.word	0x08000300
 8008298:	10030000 	.word	0x10030000
    {
      /* Call transmit function */
      CAN_Transmit_IT(hcan);
 800829c:	6878      	ldr	r0, [r7, #4]
 800829e:	f000 f959 	bl	8008554 <CAN_Transmit_IT>
    }
  }
  tmp1 = __HAL_CAN_MSG_PENDING(hcan, CAN_FIFO0);
 80082a2:	687b      	ldr	r3, [r7, #4]
 80082a4:	681b      	ldr	r3, [r3, #0]
 80082a6:	68db      	ldr	r3, [r3, #12]
 80082a8:	b2db      	uxtb	r3, r3
 80082aa:	f003 0303 	and.w	r3, r3, #3
 80082ae:	617b      	str	r3, [r7, #20]
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_FMP0);
 80082b0:	687b      	ldr	r3, [r7, #4]
 80082b2:	681b      	ldr	r3, [r3, #0]
 80082b4:	695b      	ldr	r3, [r3, #20]
 80082b6:	f003 0302 	and.w	r3, r3, #2
 80082ba:	2b00      	cmp	r3, #0
 80082bc:	bf14      	ite	ne
 80082be:	2301      	movne	r3, #1
 80082c0:	2300      	moveq	r3, #0
 80082c2:	b2db      	uxtb	r3, r3
 80082c4:	613b      	str	r3, [r7, #16]
  /* Check End of reception flag for FIFO0 */
  if((tmp1 != 0) && tmp2)
 80082c6:	697b      	ldr	r3, [r7, #20]
 80082c8:	2b00      	cmp	r3, #0
 80082ca:	d006      	beq.n	80082da <HAL_CAN_IRQHandler+0xca>
 80082cc:	693b      	ldr	r3, [r7, #16]
 80082ce:	2b00      	cmp	r3, #0
 80082d0:	d003      	beq.n	80082da <HAL_CAN_IRQHandler+0xca>
  {
    /* Call receive function */
    CAN_Receive_IT(hcan, CAN_FIFO0);
 80082d2:	6878      	ldr	r0, [r7, #4]
 80082d4:	2100      	movs	r1, #0
 80082d6:	f000 f98f 	bl	80085f8 <CAN_Receive_IT>
  }
  
  tmp1 = __HAL_CAN_MSG_PENDING(hcan, CAN_FIFO1);
 80082da:	687b      	ldr	r3, [r7, #4]
 80082dc:	681b      	ldr	r3, [r3, #0]
 80082de:	691b      	ldr	r3, [r3, #16]
 80082e0:	b2db      	uxtb	r3, r3
 80082e2:	f003 0303 	and.w	r3, r3, #3
 80082e6:	617b      	str	r3, [r7, #20]
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_FMP1);
 80082e8:	687b      	ldr	r3, [r7, #4]
 80082ea:	681b      	ldr	r3, [r3, #0]
 80082ec:	695b      	ldr	r3, [r3, #20]
 80082ee:	f003 0310 	and.w	r3, r3, #16
 80082f2:	2b00      	cmp	r3, #0
 80082f4:	bf14      	ite	ne
 80082f6:	2301      	movne	r3, #1
 80082f8:	2300      	moveq	r3, #0
 80082fa:	b2db      	uxtb	r3, r3
 80082fc:	613b      	str	r3, [r7, #16]
  /* Check End of reception flag for FIFO1 */
  if((tmp1 != 0) && tmp2)
 80082fe:	697b      	ldr	r3, [r7, #20]
 8008300:	2b00      	cmp	r3, #0
 8008302:	d006      	beq.n	8008312 <HAL_CAN_IRQHandler+0x102>
 8008304:	693b      	ldr	r3, [r7, #16]
 8008306:	2b00      	cmp	r3, #0
 8008308:	d003      	beq.n	8008312 <HAL_CAN_IRQHandler+0x102>
  {
    /* Call receive function */
    CAN_Receive_IT(hcan, CAN_FIFO1);
 800830a:	6878      	ldr	r0, [r7, #4]
 800830c:	2101      	movs	r1, #1
 800830e:	f000 f973 	bl	80085f8 <CAN_Receive_IT>
  }
  
  tmp1 = __HAL_CAN_GET_FLAG(hcan, CAN_FLAG_EWG);
 8008312:	687b      	ldr	r3, [r7, #4]
 8008314:	681b      	ldr	r3, [r3, #0]
 8008316:	699b      	ldr	r3, [r3, #24]
 8008318:	f003 0301 	and.w	r3, r3, #1
 800831c:	2b00      	cmp	r3, #0
 800831e:	bf14      	ite	ne
 8008320:	2301      	movne	r3, #1
 8008322:	2300      	moveq	r3, #0
 8008324:	b2db      	uxtb	r3, r3
 8008326:	617b      	str	r3, [r7, #20]
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_EWG);
 8008328:	687b      	ldr	r3, [r7, #4]
 800832a:	681b      	ldr	r3, [r3, #0]
 800832c:	695b      	ldr	r3, [r3, #20]
 800832e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8008332:	2b00      	cmp	r3, #0
 8008334:	bf14      	ite	ne
 8008336:	2301      	movne	r3, #1
 8008338:	2300      	moveq	r3, #0
 800833a:	b2db      	uxtb	r3, r3
 800833c:	613b      	str	r3, [r7, #16]
  tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR);
 800833e:	687b      	ldr	r3, [r7, #4]
 8008340:	681b      	ldr	r3, [r3, #0]
 8008342:	695b      	ldr	r3, [r3, #20]
 8008344:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8008348:	2b00      	cmp	r3, #0
 800834a:	bf14      	ite	ne
 800834c:	2301      	movne	r3, #1
 800834e:	2300      	moveq	r3, #0
 8008350:	b2db      	uxtb	r3, r3
 8008352:	60fb      	str	r3, [r7, #12]
  /* Check Error Warning Flag */
  if(tmp1 && tmp2 && tmp3)
 8008354:	697b      	ldr	r3, [r7, #20]
 8008356:	2b00      	cmp	r3, #0
 8008358:	d010      	beq.n	800837c <HAL_CAN_IRQHandler+0x16c>
 800835a:	693b      	ldr	r3, [r7, #16]
 800835c:	2b00      	cmp	r3, #0
 800835e:	d00d      	beq.n	800837c <HAL_CAN_IRQHandler+0x16c>
 8008360:	68fb      	ldr	r3, [r7, #12]
 8008362:	2b00      	cmp	r3, #0
 8008364:	d00a      	beq.n	800837c <HAL_CAN_IRQHandler+0x16c>
  {
    /* Set CAN error code to EWG error */
    hcan->ErrorCode |= HAL_CAN_ERROR_EWG;
 8008366:	687b      	ldr	r3, [r7, #4]
 8008368:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800836a:	f043 0201 	orr.w	r2, r3, #1
 800836e:	687b      	ldr	r3, [r7, #4]
 8008370:	63da      	str	r2, [r3, #60]	; 0x3c
    /* Clear Error Warning Flag */ 
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_EWG);
 8008372:	687b      	ldr	r3, [r7, #4]
 8008374:	681b      	ldr	r3, [r3, #0]
 8008376:	f06f 0201 	mvn.w	r2, #1
 800837a:	619a      	str	r2, [r3, #24]
  }
  
  tmp1 = __HAL_CAN_GET_FLAG(hcan, CAN_FLAG_EPV);
 800837c:	687b      	ldr	r3, [r7, #4]
 800837e:	681b      	ldr	r3, [r3, #0]
 8008380:	699b      	ldr	r3, [r3, #24]
 8008382:	f003 0302 	and.w	r3, r3, #2
 8008386:	2b00      	cmp	r3, #0
 8008388:	bf14      	ite	ne
 800838a:	2301      	movne	r3, #1
 800838c:	2300      	moveq	r3, #0
 800838e:	b2db      	uxtb	r3, r3
 8008390:	617b      	str	r3, [r7, #20]
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_EPV);
 8008392:	687b      	ldr	r3, [r7, #4]
 8008394:	681b      	ldr	r3, [r3, #0]
 8008396:	695b      	ldr	r3, [r3, #20]
 8008398:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800839c:	2b00      	cmp	r3, #0
 800839e:	bf14      	ite	ne
 80083a0:	2301      	movne	r3, #1
 80083a2:	2300      	moveq	r3, #0
 80083a4:	b2db      	uxtb	r3, r3
 80083a6:	613b      	str	r3, [r7, #16]
  tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR); 
 80083a8:	687b      	ldr	r3, [r7, #4]
 80083aa:	681b      	ldr	r3, [r3, #0]
 80083ac:	695b      	ldr	r3, [r3, #20]
 80083ae:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80083b2:	2b00      	cmp	r3, #0
 80083b4:	bf14      	ite	ne
 80083b6:	2301      	movne	r3, #1
 80083b8:	2300      	moveq	r3, #0
 80083ba:	b2db      	uxtb	r3, r3
 80083bc:	60fb      	str	r3, [r7, #12]
  /* Check Error Passive Flag */
  if(tmp1 && tmp2 && tmp3)
 80083be:	697b      	ldr	r3, [r7, #20]
 80083c0:	2b00      	cmp	r3, #0
 80083c2:	d010      	beq.n	80083e6 <HAL_CAN_IRQHandler+0x1d6>
 80083c4:	693b      	ldr	r3, [r7, #16]
 80083c6:	2b00      	cmp	r3, #0
 80083c8:	d00d      	beq.n	80083e6 <HAL_CAN_IRQHandler+0x1d6>
 80083ca:	68fb      	ldr	r3, [r7, #12]
 80083cc:	2b00      	cmp	r3, #0
 80083ce:	d00a      	beq.n	80083e6 <HAL_CAN_IRQHandler+0x1d6>
  {
    /* Set CAN error code to EPV error */
    hcan->ErrorCode |= HAL_CAN_ERROR_EPV;
 80083d0:	687b      	ldr	r3, [r7, #4]
 80083d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80083d4:	f043 0202 	orr.w	r2, r3, #2
 80083d8:	687b      	ldr	r3, [r7, #4]
 80083da:	63da      	str	r2, [r3, #60]	; 0x3c
    /* Clear Error Passive Flag */ 
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_EPV);
 80083dc:	687b      	ldr	r3, [r7, #4]
 80083de:	681b      	ldr	r3, [r3, #0]
 80083e0:	f06f 0202 	mvn.w	r2, #2
 80083e4:	619a      	str	r2, [r3, #24]
  }
  
  tmp1 = __HAL_CAN_GET_FLAG(hcan, CAN_FLAG_BOF);
 80083e6:	687b      	ldr	r3, [r7, #4]
 80083e8:	681b      	ldr	r3, [r3, #0]
 80083ea:	699b      	ldr	r3, [r3, #24]
 80083ec:	f003 0304 	and.w	r3, r3, #4
 80083f0:	2b00      	cmp	r3, #0
 80083f2:	bf14      	ite	ne
 80083f4:	2301      	movne	r3, #1
 80083f6:	2300      	moveq	r3, #0
 80083f8:	b2db      	uxtb	r3, r3
 80083fa:	617b      	str	r3, [r7, #20]
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_BOF);
 80083fc:	687b      	ldr	r3, [r7, #4]
 80083fe:	681b      	ldr	r3, [r3, #0]
 8008400:	695b      	ldr	r3, [r3, #20]
 8008402:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8008406:	2b00      	cmp	r3, #0
 8008408:	bf14      	ite	ne
 800840a:	2301      	movne	r3, #1
 800840c:	2300      	moveq	r3, #0
 800840e:	b2db      	uxtb	r3, r3
 8008410:	613b      	str	r3, [r7, #16]
  tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR);  
 8008412:	687b      	ldr	r3, [r7, #4]
 8008414:	681b      	ldr	r3, [r3, #0]
 8008416:	695b      	ldr	r3, [r3, #20]
 8008418:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800841c:	2b00      	cmp	r3, #0
 800841e:	bf14      	ite	ne
 8008420:	2301      	movne	r3, #1
 8008422:	2300      	moveq	r3, #0
 8008424:	b2db      	uxtb	r3, r3
 8008426:	60fb      	str	r3, [r7, #12]
  /* Check Bus-Off Flag */
  if(tmp1 && tmp2 && tmp3)
 8008428:	697b      	ldr	r3, [r7, #20]
 800842a:	2b00      	cmp	r3, #0
 800842c:	d010      	beq.n	8008450 <HAL_CAN_IRQHandler+0x240>
 800842e:	693b      	ldr	r3, [r7, #16]
 8008430:	2b00      	cmp	r3, #0
 8008432:	d00d      	beq.n	8008450 <HAL_CAN_IRQHandler+0x240>
 8008434:	68fb      	ldr	r3, [r7, #12]
 8008436:	2b00      	cmp	r3, #0
 8008438:	d00a      	beq.n	8008450 <HAL_CAN_IRQHandler+0x240>
  {
    /* Set CAN error code to BOF error */
    hcan->ErrorCode |= HAL_CAN_ERROR_BOF;
 800843a:	687b      	ldr	r3, [r7, #4]
 800843c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800843e:	f043 0204 	orr.w	r2, r3, #4
 8008442:	687b      	ldr	r3, [r7, #4]
 8008444:	63da      	str	r2, [r3, #60]	; 0x3c
    /* Clear Bus-Off Flag */ 
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_BOF);
 8008446:	687b      	ldr	r3, [r7, #4]
 8008448:	681b      	ldr	r3, [r3, #0]
 800844a:	f06f 0204 	mvn.w	r2, #4
 800844e:	619a      	str	r2, [r3, #24]
  }
  
  tmp1 = HAL_IS_BIT_CLR(hcan->Instance->ESR, CAN_ESR_LEC);
 8008450:	687b      	ldr	r3, [r7, #4]
 8008452:	681b      	ldr	r3, [r3, #0]
 8008454:	699b      	ldr	r3, [r3, #24]
 8008456:	f003 0370 	and.w	r3, r3, #112	; 0x70
 800845a:	2b00      	cmp	r3, #0
 800845c:	bf0c      	ite	eq
 800845e:	2301      	moveq	r3, #1
 8008460:	2300      	movne	r3, #0
 8008462:	b2db      	uxtb	r3, r3
 8008464:	617b      	str	r3, [r7, #20]
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_LEC);
 8008466:	687b      	ldr	r3, [r7, #4]
 8008468:	681b      	ldr	r3, [r3, #0]
 800846a:	695b      	ldr	r3, [r3, #20]
 800846c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8008470:	2b00      	cmp	r3, #0
 8008472:	bf14      	ite	ne
 8008474:	2301      	movne	r3, #1
 8008476:	2300      	moveq	r3, #0
 8008478:	b2db      	uxtb	r3, r3
 800847a:	613b      	str	r3, [r7, #16]
  tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR);
 800847c:	687b      	ldr	r3, [r7, #4]
 800847e:	681b      	ldr	r3, [r3, #0]
 8008480:	695b      	ldr	r3, [r3, #20]
 8008482:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8008486:	2b00      	cmp	r3, #0
 8008488:	bf14      	ite	ne
 800848a:	2301      	movne	r3, #1
 800848c:	2300      	moveq	r3, #0
 800848e:	b2db      	uxtb	r3, r3
 8008490:	60fb      	str	r3, [r7, #12]
  /* Check Last error code Flag */
  if((!tmp1) && tmp2 && tmp3)
 8008492:	697b      	ldr	r3, [r7, #20]
 8008494:	2b00      	cmp	r3, #0
 8008496:	d14e      	bne.n	8008536 <HAL_CAN_IRQHandler+0x326>
 8008498:	693b      	ldr	r3, [r7, #16]
 800849a:	2b00      	cmp	r3, #0
 800849c:	d04b      	beq.n	8008536 <HAL_CAN_IRQHandler+0x326>
 800849e:	68fb      	ldr	r3, [r7, #12]
 80084a0:	2b00      	cmp	r3, #0
 80084a2:	d048      	beq.n	8008536 <HAL_CAN_IRQHandler+0x326>
  {
    tmp1 = (hcan->Instance->ESR) & CAN_ESR_LEC;
 80084a4:	687b      	ldr	r3, [r7, #4]
 80084a6:	681b      	ldr	r3, [r3, #0]
 80084a8:	699b      	ldr	r3, [r3, #24]
 80084aa:	f003 0370 	and.w	r3, r3, #112	; 0x70
 80084ae:	617b      	str	r3, [r7, #20]
    switch(tmp1)
 80084b0:	697b      	ldr	r3, [r7, #20]
 80084b2:	2b30      	cmp	r3, #48	; 0x30
 80084b4:	d01b      	beq.n	80084ee <HAL_CAN_IRQHandler+0x2de>
 80084b6:	2b30      	cmp	r3, #48	; 0x30
 80084b8:	d804      	bhi.n	80084c4 <HAL_CAN_IRQHandler+0x2b4>
 80084ba:	2b10      	cmp	r3, #16
 80084bc:	d009      	beq.n	80084d2 <HAL_CAN_IRQHandler+0x2c2>
 80084be:	2b20      	cmp	r3, #32
 80084c0:	d00e      	beq.n	80084e0 <HAL_CAN_IRQHandler+0x2d0>
      case(CAN_ESR_LEC_2 | CAN_ESR_LEC_1):
          /* Set CAN error code to CRC error */
          hcan->ErrorCode |= HAL_CAN_ERROR_CRC;
          break;
      default:
          break;
 80084c2:	e030      	b.n	8008526 <HAL_CAN_IRQHandler+0x316>
  tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR);
  /* Check Last error code Flag */
  if((!tmp1) && tmp2 && tmp3)
  {
    tmp1 = (hcan->Instance->ESR) & CAN_ESR_LEC;
    switch(tmp1)
 80084c4:	2b50      	cmp	r3, #80	; 0x50
 80084c6:	d020      	beq.n	800850a <HAL_CAN_IRQHandler+0x2fa>
 80084c8:	2b60      	cmp	r3, #96	; 0x60
 80084ca:	d025      	beq.n	8008518 <HAL_CAN_IRQHandler+0x308>
 80084cc:	2b40      	cmp	r3, #64	; 0x40
 80084ce:	d015      	beq.n	80084fc <HAL_CAN_IRQHandler+0x2ec>
      case(CAN_ESR_LEC_2 | CAN_ESR_LEC_1):
          /* Set CAN error code to CRC error */
          hcan->ErrorCode |= HAL_CAN_ERROR_CRC;
          break;
      default:
          break;
 80084d0:	e029      	b.n	8008526 <HAL_CAN_IRQHandler+0x316>
    tmp1 = (hcan->Instance->ESR) & CAN_ESR_LEC;
    switch(tmp1)
    {
      case(CAN_ESR_LEC_0):
          /* Set CAN error code to STF error */
          hcan->ErrorCode |= HAL_CAN_ERROR_STF;
 80084d2:	687b      	ldr	r3, [r7, #4]
 80084d4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80084d6:	f043 0208 	orr.w	r2, r3, #8
 80084da:	687b      	ldr	r3, [r7, #4]
 80084dc:	63da      	str	r2, [r3, #60]	; 0x3c
          break;
 80084de:	e022      	b.n	8008526 <HAL_CAN_IRQHandler+0x316>
      case(CAN_ESR_LEC_1):
          /* Set CAN error code to FOR error */
          hcan->ErrorCode |= HAL_CAN_ERROR_FOR;
 80084e0:	687b      	ldr	r3, [r7, #4]
 80084e2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80084e4:	f043 0210 	orr.w	r2, r3, #16
 80084e8:	687b      	ldr	r3, [r7, #4]
 80084ea:	63da      	str	r2, [r3, #60]	; 0x3c
          break;
 80084ec:	e01b      	b.n	8008526 <HAL_CAN_IRQHandler+0x316>
      case(CAN_ESR_LEC_1 | CAN_ESR_LEC_0):
          /* Set CAN error code to ACK error */
          hcan->ErrorCode |= HAL_CAN_ERROR_ACK;
 80084ee:	687b      	ldr	r3, [r7, #4]
 80084f0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80084f2:	f043 0220 	orr.w	r2, r3, #32
 80084f6:	687b      	ldr	r3, [r7, #4]
 80084f8:	63da      	str	r2, [r3, #60]	; 0x3c
          break;
 80084fa:	e014      	b.n	8008526 <HAL_CAN_IRQHandler+0x316>
      case(CAN_ESR_LEC_2):
          /* Set CAN error code to BR error */
          hcan->ErrorCode |= HAL_CAN_ERROR_BR;
 80084fc:	687b      	ldr	r3, [r7, #4]
 80084fe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8008500:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8008504:	687b      	ldr	r3, [r7, #4]
 8008506:	63da      	str	r2, [r3, #60]	; 0x3c
          break;
 8008508:	e00d      	b.n	8008526 <HAL_CAN_IRQHandler+0x316>
      case(CAN_ESR_LEC_2 | CAN_ESR_LEC_0):
          /* Set CAN error code to BD error */
          hcan->ErrorCode |= HAL_CAN_ERROR_BD;
 800850a:	687b      	ldr	r3, [r7, #4]
 800850c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800850e:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 8008512:	687b      	ldr	r3, [r7, #4]
 8008514:	63da      	str	r2, [r3, #60]	; 0x3c
          break;
 8008516:	e006      	b.n	8008526 <HAL_CAN_IRQHandler+0x316>
      case(CAN_ESR_LEC_2 | CAN_ESR_LEC_1):
          /* Set CAN error code to CRC error */
          hcan->ErrorCode |= HAL_CAN_ERROR_CRC;
 8008518:	687b      	ldr	r3, [r7, #4]
 800851a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800851c:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 8008520:	687b      	ldr	r3, [r7, #4]
 8008522:	63da      	str	r2, [r3, #60]	; 0x3c
          break;
 8008524:	bf00      	nop
      default:
          break;
    }

    /* Clear Last error code Flag */ 
    hcan->Instance->ESR &= ~(CAN_ESR_LEC);
 8008526:	687b      	ldr	r3, [r7, #4]
 8008528:	681b      	ldr	r3, [r3, #0]
 800852a:	687a      	ldr	r2, [r7, #4]
 800852c:	6812      	ldr	r2, [r2, #0]
 800852e:	6992      	ldr	r2, [r2, #24]
 8008530:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8008534:	619a      	str	r2, [r3, #24]
  }

  /* Call the Error call Back in case of Errors */
  if(hcan->ErrorCode != HAL_CAN_ERROR_NONE)
 8008536:	687b      	ldr	r3, [r7, #4]
 8008538:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800853a:	2b00      	cmp	r3, #0
 800853c:	d006      	beq.n	800854c <HAL_CAN_IRQHandler+0x33c>
  {
    /* Set the CAN state ready to be able to start again the process */
    hcan->State = HAL_CAN_STATE_READY;
 800853e:	687b      	ldr	r3, [r7, #4]
 8008540:	2201      	movs	r2, #1
 8008542:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    /* Call Error callback function */
    HAL_CAN_ErrorCallback(hcan);
 8008546:	6878      	ldr	r0, [r7, #4]
 8008548:	f009 fe10 	bl	801216c <HAL_CAN_ErrorCallback>
  }  
}
 800854c:	3718      	adds	r7, #24
 800854e:	46bd      	mov	sp, r7
 8008550:	bd80      	pop	{r7, pc}
 8008552:	bf00      	nop

08008554 <CAN_Transmit_IT>:
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.  
  * @retval HAL status
  */
static HAL_StatusTypeDef CAN_Transmit_IT(CAN_HandleTypeDef* hcan)
{
 8008554:	b580      	push	{r7, lr}
 8008556:	b082      	sub	sp, #8
 8008558:	af00      	add	r7, sp, #0
 800855a:	6078      	str	r0, [r7, #4]
  /* Disable Transmit mailbox empty Interrupt */
  __HAL_CAN_DISABLE_IT(hcan, CAN_IT_TME);
 800855c:	687b      	ldr	r3, [r7, #4]
 800855e:	681b      	ldr	r3, [r3, #0]
 8008560:	687a      	ldr	r2, [r7, #4]
 8008562:	6812      	ldr	r2, [r2, #0]
 8008564:	6952      	ldr	r2, [r2, #20]
 8008566:	f022 0201 	bic.w	r2, r2, #1
 800856a:	615a      	str	r2, [r3, #20]
  
  if(hcan->State == HAL_CAN_STATE_BUSY_TX)
 800856c:	687b      	ldr	r3, [r7, #4]
 800856e:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8008572:	b2db      	uxtb	r3, r3
 8008574:	2b12      	cmp	r3, #18
 8008576:	d127      	bne.n	80085c8 <CAN_Transmit_IT+0x74>
  {   
    /* Disable Error warning Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_EWG);
 8008578:	687b      	ldr	r3, [r7, #4]
 800857a:	681b      	ldr	r3, [r3, #0]
 800857c:	687a      	ldr	r2, [r7, #4]
 800857e:	6812      	ldr	r2, [r2, #0]
 8008580:	6952      	ldr	r2, [r2, #20]
 8008582:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8008586:	615a      	str	r2, [r3, #20]
    
    /* Disable Error passive Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_EPV);
 8008588:	687b      	ldr	r3, [r7, #4]
 800858a:	681b      	ldr	r3, [r3, #0]
 800858c:	687a      	ldr	r2, [r7, #4]
 800858e:	6812      	ldr	r2, [r2, #0]
 8008590:	6952      	ldr	r2, [r2, #20]
 8008592:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8008596:	615a      	str	r2, [r3, #20]
    
    /* Disable Bus-off Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_BOF);
 8008598:	687b      	ldr	r3, [r7, #4]
 800859a:	681b      	ldr	r3, [r3, #0]
 800859c:	687a      	ldr	r2, [r7, #4]
 800859e:	6812      	ldr	r2, [r2, #0]
 80085a0:	6952      	ldr	r2, [r2, #20]
 80085a2:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80085a6:	615a      	str	r2, [r3, #20]
    
    /* Disable Last error code Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_LEC);
 80085a8:	687b      	ldr	r3, [r7, #4]
 80085aa:	681b      	ldr	r3, [r3, #0]
 80085ac:	687a      	ldr	r2, [r7, #4]
 80085ae:	6812      	ldr	r2, [r2, #0]
 80085b0:	6952      	ldr	r2, [r2, #20]
 80085b2:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80085b6:	615a      	str	r2, [r3, #20]
    
    /* Disable Error Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_ERR);
 80085b8:	687b      	ldr	r3, [r7, #4]
 80085ba:	681b      	ldr	r3, [r3, #0]
 80085bc:	687a      	ldr	r2, [r7, #4]
 80085be:	6812      	ldr	r2, [r2, #0]
 80085c0:	6952      	ldr	r2, [r2, #20]
 80085c2:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80085c6:	615a      	str	r2, [r3, #20]
  }
  
  if(hcan->State == HAL_CAN_STATE_BUSY_TX_RX) 
 80085c8:	687b      	ldr	r3, [r7, #4]
 80085ca:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 80085ce:	b2db      	uxtb	r3, r3
 80085d0:	2b32      	cmp	r3, #50	; 0x32
 80085d2:	d104      	bne.n	80085de <CAN_Transmit_IT+0x8a>
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_RX;
 80085d4:	687b      	ldr	r3, [r7, #4]
 80085d6:	2222      	movs	r2, #34	; 0x22
 80085d8:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
 80085dc:	e003      	b.n	80085e6 <CAN_Transmit_IT+0x92>
  }
  else
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_READY;
 80085de:	687b      	ldr	r3, [r7, #4]
 80085e0:	2201      	movs	r2, #1
 80085e2:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  }
  
  /* Transmission complete callback */ 
  HAL_CAN_TxCpltCallback(hcan);
 80085e6:	6878      	ldr	r0, [r7, #4]
 80085e8:	f009 fd76 	bl	80120d8 <HAL_CAN_TxCpltCallback>
  
  return HAL_OK;
 80085ec:	2300      	movs	r3, #0
}
 80085ee:	4618      	mov	r0, r3
 80085f0:	3708      	adds	r7, #8
 80085f2:	46bd      	mov	sp, r7
 80085f4:	bd80      	pop	{r7, pc}
 80085f6:	bf00      	nop

080085f8 <CAN_Receive_IT>:
  * @param  FIFONumber: Specify the FIFO number    
  * @retval HAL status
  * @retval None
  */
static HAL_StatusTypeDef CAN_Receive_IT(CAN_HandleTypeDef* hcan, uint8_t FIFONumber)
{
 80085f8:	b580      	push	{r7, lr}
 80085fa:	b082      	sub	sp, #8
 80085fc:	af00      	add	r7, sp, #0
 80085fe:	6078      	str	r0, [r7, #4]
 8008600:	460b      	mov	r3, r1
 8008602:	70fb      	strb	r3, [r7, #3]
  /* Get the Id */
  hcan->pRxMsg->IDE = (uint8_t)0x04 & hcan->Instance->sFIFOMailBox[FIFONumber].RIR;
 8008604:	687b      	ldr	r3, [r7, #4]
 8008606:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008608:	687a      	ldr	r2, [r7, #4]
 800860a:	6811      	ldr	r1, [r2, #0]
 800860c:	78fa      	ldrb	r2, [r7, #3]
 800860e:	321b      	adds	r2, #27
 8008610:	0112      	lsls	r2, r2, #4
 8008612:	440a      	add	r2, r1
 8008614:	6812      	ldr	r2, [r2, #0]
 8008616:	f002 0204 	and.w	r2, r2, #4
 800861a:	609a      	str	r2, [r3, #8]
  if (hcan->pRxMsg->IDE == CAN_ID_STD)
 800861c:	687b      	ldr	r3, [r7, #4]
 800861e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008620:	689b      	ldr	r3, [r3, #8]
 8008622:	2b00      	cmp	r3, #0
 8008624:	d10b      	bne.n	800863e <CAN_Receive_IT+0x46>
  {
    hcan->pRxMsg->StdId = (uint32_t)0x000007FF & (hcan->Instance->sFIFOMailBox[FIFONumber].RIR >> 21);
 8008626:	687b      	ldr	r3, [r7, #4]
 8008628:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800862a:	687a      	ldr	r2, [r7, #4]
 800862c:	6811      	ldr	r1, [r2, #0]
 800862e:	78fa      	ldrb	r2, [r7, #3]
 8008630:	321b      	adds	r2, #27
 8008632:	0112      	lsls	r2, r2, #4
 8008634:	440a      	add	r2, r1
 8008636:	6812      	ldr	r2, [r2, #0]
 8008638:	0d52      	lsrs	r2, r2, #21
 800863a:	601a      	str	r2, [r3, #0]
 800863c:	e00a      	b.n	8008654 <CAN_Receive_IT+0x5c>
  }
  else
  {
    hcan->pRxMsg->ExtId = (uint32_t)0x1FFFFFFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RIR >> 3);
 800863e:	687b      	ldr	r3, [r7, #4]
 8008640:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008642:	687a      	ldr	r2, [r7, #4]
 8008644:	6811      	ldr	r1, [r2, #0]
 8008646:	78fa      	ldrb	r2, [r7, #3]
 8008648:	321b      	adds	r2, #27
 800864a:	0112      	lsls	r2, r2, #4
 800864c:	440a      	add	r2, r1
 800864e:	6812      	ldr	r2, [r2, #0]
 8008650:	08d2      	lsrs	r2, r2, #3
 8008652:	605a      	str	r2, [r3, #4]
  }
  
  hcan->pRxMsg->RTR = (uint8_t)0x02 & hcan->Instance->sFIFOMailBox[FIFONumber].RIR;
 8008654:	687b      	ldr	r3, [r7, #4]
 8008656:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008658:	687a      	ldr	r2, [r7, #4]
 800865a:	6811      	ldr	r1, [r2, #0]
 800865c:	78fa      	ldrb	r2, [r7, #3]
 800865e:	321b      	adds	r2, #27
 8008660:	0112      	lsls	r2, r2, #4
 8008662:	440a      	add	r2, r1
 8008664:	6812      	ldr	r2, [r2, #0]
 8008666:	f002 0202 	and.w	r2, r2, #2
 800866a:	60da      	str	r2, [r3, #12]
  /* Get the DLC */
  hcan->pRxMsg->DLC = (uint8_t)0x0F & hcan->Instance->sFIFOMailBox[FIFONumber].RDTR;
 800866c:	687b      	ldr	r3, [r7, #4]
 800866e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008670:	687a      	ldr	r2, [r7, #4]
 8008672:	6811      	ldr	r1, [r2, #0]
 8008674:	78fa      	ldrb	r2, [r7, #3]
 8008676:	321b      	adds	r2, #27
 8008678:	0112      	lsls	r2, r2, #4
 800867a:	440a      	add	r2, r1
 800867c:	6852      	ldr	r2, [r2, #4]
 800867e:	f002 020f 	and.w	r2, r2, #15
 8008682:	611a      	str	r2, [r3, #16]
  /* Get the FMI */
  hcan->pRxMsg->FMI = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDTR >> 8);
 8008684:	687b      	ldr	r3, [r7, #4]
 8008686:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008688:	687a      	ldr	r2, [r7, #4]
 800868a:	6811      	ldr	r1, [r2, #0]
 800868c:	78fa      	ldrb	r2, [r7, #3]
 800868e:	321b      	adds	r2, #27
 8008690:	0112      	lsls	r2, r2, #4
 8008692:	440a      	add	r2, r1
 8008694:	6852      	ldr	r2, [r2, #4]
 8008696:	0a12      	lsrs	r2, r2, #8
 8008698:	b2d2      	uxtb	r2, r2
 800869a:	61da      	str	r2, [r3, #28]
  /* Get the data field */
  hcan->pRxMsg->Data[0] = (uint8_t)0xFF & hcan->Instance->sFIFOMailBox[FIFONumber].RDLR;
 800869c:	687b      	ldr	r3, [r7, #4]
 800869e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80086a0:	687a      	ldr	r2, [r7, #4]
 80086a2:	6811      	ldr	r1, [r2, #0]
 80086a4:	78fa      	ldrb	r2, [r7, #3]
 80086a6:	0112      	lsls	r2, r2, #4
 80086a8:	440a      	add	r2, r1
 80086aa:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 80086ae:	6812      	ldr	r2, [r2, #0]
 80086b0:	b2d2      	uxtb	r2, r2
 80086b2:	751a      	strb	r2, [r3, #20]
  hcan->pRxMsg->Data[1] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 8);
 80086b4:	687b      	ldr	r3, [r7, #4]
 80086b6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80086b8:	687a      	ldr	r2, [r7, #4]
 80086ba:	6811      	ldr	r1, [r2, #0]
 80086bc:	78fa      	ldrb	r2, [r7, #3]
 80086be:	0112      	lsls	r2, r2, #4
 80086c0:	440a      	add	r2, r1
 80086c2:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 80086c6:	6812      	ldr	r2, [r2, #0]
 80086c8:	0a12      	lsrs	r2, r2, #8
 80086ca:	b2d2      	uxtb	r2, r2
 80086cc:	755a      	strb	r2, [r3, #21]
  hcan->pRxMsg->Data[2] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 16);
 80086ce:	687b      	ldr	r3, [r7, #4]
 80086d0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80086d2:	687a      	ldr	r2, [r7, #4]
 80086d4:	6811      	ldr	r1, [r2, #0]
 80086d6:	78fa      	ldrb	r2, [r7, #3]
 80086d8:	0112      	lsls	r2, r2, #4
 80086da:	440a      	add	r2, r1
 80086dc:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 80086e0:	6812      	ldr	r2, [r2, #0]
 80086e2:	0c12      	lsrs	r2, r2, #16
 80086e4:	b2d2      	uxtb	r2, r2
 80086e6:	759a      	strb	r2, [r3, #22]
  hcan->pRxMsg->Data[3] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 24);
 80086e8:	687b      	ldr	r3, [r7, #4]
 80086ea:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80086ec:	687a      	ldr	r2, [r7, #4]
 80086ee:	6811      	ldr	r1, [r2, #0]
 80086f0:	78fa      	ldrb	r2, [r7, #3]
 80086f2:	0112      	lsls	r2, r2, #4
 80086f4:	440a      	add	r2, r1
 80086f6:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 80086fa:	6812      	ldr	r2, [r2, #0]
 80086fc:	0e12      	lsrs	r2, r2, #24
 80086fe:	b2d2      	uxtb	r2, r2
 8008700:	75da      	strb	r2, [r3, #23]
  hcan->pRxMsg->Data[4] = (uint8_t)0xFF & hcan->Instance->sFIFOMailBox[FIFONumber].RDHR;
 8008702:	687b      	ldr	r3, [r7, #4]
 8008704:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008706:	687a      	ldr	r2, [r7, #4]
 8008708:	6811      	ldr	r1, [r2, #0]
 800870a:	78fa      	ldrb	r2, [r7, #3]
 800870c:	0112      	lsls	r2, r2, #4
 800870e:	440a      	add	r2, r1
 8008710:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8008714:	6852      	ldr	r2, [r2, #4]
 8008716:	b2d2      	uxtb	r2, r2
 8008718:	761a      	strb	r2, [r3, #24]
  hcan->pRxMsg->Data[5] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 8);
 800871a:	687b      	ldr	r3, [r7, #4]
 800871c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800871e:	687a      	ldr	r2, [r7, #4]
 8008720:	6811      	ldr	r1, [r2, #0]
 8008722:	78fa      	ldrb	r2, [r7, #3]
 8008724:	0112      	lsls	r2, r2, #4
 8008726:	440a      	add	r2, r1
 8008728:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 800872c:	6852      	ldr	r2, [r2, #4]
 800872e:	0a12      	lsrs	r2, r2, #8
 8008730:	b2d2      	uxtb	r2, r2
 8008732:	765a      	strb	r2, [r3, #25]
  hcan->pRxMsg->Data[6] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 16);
 8008734:	687b      	ldr	r3, [r7, #4]
 8008736:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008738:	687a      	ldr	r2, [r7, #4]
 800873a:	6811      	ldr	r1, [r2, #0]
 800873c:	78fa      	ldrb	r2, [r7, #3]
 800873e:	0112      	lsls	r2, r2, #4
 8008740:	440a      	add	r2, r1
 8008742:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8008746:	6852      	ldr	r2, [r2, #4]
 8008748:	0c12      	lsrs	r2, r2, #16
 800874a:	b2d2      	uxtb	r2, r2
 800874c:	769a      	strb	r2, [r3, #26]
  hcan->pRxMsg->Data[7] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 24);
 800874e:	687b      	ldr	r3, [r7, #4]
 8008750:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008752:	687a      	ldr	r2, [r7, #4]
 8008754:	6811      	ldr	r1, [r2, #0]
 8008756:	78fa      	ldrb	r2, [r7, #3]
 8008758:	0112      	lsls	r2, r2, #4
 800875a:	440a      	add	r2, r1
 800875c:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8008760:	6852      	ldr	r2, [r2, #4]
 8008762:	0e12      	lsrs	r2, r2, #24
 8008764:	b2d2      	uxtb	r2, r2
 8008766:	76da      	strb	r2, [r3, #27]
  /* Release the FIFO */
  /* Release FIFO0 */
  if (FIFONumber == CAN_FIFO0)
 8008768:	78fb      	ldrb	r3, [r7, #3]
 800876a:	2b00      	cmp	r3, #0
 800876c:	d110      	bne.n	8008790 <CAN_Receive_IT+0x198>
  {
    __HAL_CAN_FIFO_RELEASE(hcan, CAN_FIFO0);
 800876e:	687b      	ldr	r3, [r7, #4]
 8008770:	681b      	ldr	r3, [r3, #0]
 8008772:	687a      	ldr	r2, [r7, #4]
 8008774:	6812      	ldr	r2, [r2, #0]
 8008776:	68d2      	ldr	r2, [r2, #12]
 8008778:	f042 0220 	orr.w	r2, r2, #32
 800877c:	60da      	str	r2, [r3, #12]
    
    /* Disable FIFO 0 message pending Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_FMP0);
 800877e:	687b      	ldr	r3, [r7, #4]
 8008780:	681b      	ldr	r3, [r3, #0]
 8008782:	687a      	ldr	r2, [r7, #4]
 8008784:	6812      	ldr	r2, [r2, #0]
 8008786:	6952      	ldr	r2, [r2, #20]
 8008788:	f022 0202 	bic.w	r2, r2, #2
 800878c:	615a      	str	r2, [r3, #20]
 800878e:	e00f      	b.n	80087b0 <CAN_Receive_IT+0x1b8>
  }
  /* Release FIFO1 */
  else /* FIFONumber == CAN_FIFO1 */
  {
    __HAL_CAN_FIFO_RELEASE(hcan, CAN_FIFO1);
 8008790:	687b      	ldr	r3, [r7, #4]
 8008792:	681b      	ldr	r3, [r3, #0]
 8008794:	687a      	ldr	r2, [r7, #4]
 8008796:	6812      	ldr	r2, [r2, #0]
 8008798:	6912      	ldr	r2, [r2, #16]
 800879a:	f042 0220 	orr.w	r2, r2, #32
 800879e:	611a      	str	r2, [r3, #16]
    
    /* Disable FIFO 1 message pending Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_FMP1);
 80087a0:	687b      	ldr	r3, [r7, #4]
 80087a2:	681b      	ldr	r3, [r3, #0]
 80087a4:	687a      	ldr	r2, [r7, #4]
 80087a6:	6812      	ldr	r2, [r2, #0]
 80087a8:	6952      	ldr	r2, [r2, #20]
 80087aa:	f022 0210 	bic.w	r2, r2, #16
 80087ae:	615a      	str	r2, [r3, #20]
  }
  
  if(hcan->State == HAL_CAN_STATE_BUSY_RX)
 80087b0:	687b      	ldr	r3, [r7, #4]
 80087b2:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 80087b6:	b2db      	uxtb	r3, r3
 80087b8:	2b22      	cmp	r3, #34	; 0x22
 80087ba:	d127      	bne.n	800880c <CAN_Receive_IT+0x214>
  {   
    /* Disable Error warning Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_EWG);
 80087bc:	687b      	ldr	r3, [r7, #4]
 80087be:	681b      	ldr	r3, [r3, #0]
 80087c0:	687a      	ldr	r2, [r7, #4]
 80087c2:	6812      	ldr	r2, [r2, #0]
 80087c4:	6952      	ldr	r2, [r2, #20]
 80087c6:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80087ca:	615a      	str	r2, [r3, #20]
    
    /* Disable Error passive Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_EPV);
 80087cc:	687b      	ldr	r3, [r7, #4]
 80087ce:	681b      	ldr	r3, [r3, #0]
 80087d0:	687a      	ldr	r2, [r7, #4]
 80087d2:	6812      	ldr	r2, [r2, #0]
 80087d4:	6952      	ldr	r2, [r2, #20]
 80087d6:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 80087da:	615a      	str	r2, [r3, #20]
    
    /* Disable Bus-off Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_BOF);
 80087dc:	687b      	ldr	r3, [r7, #4]
 80087de:	681b      	ldr	r3, [r3, #0]
 80087e0:	687a      	ldr	r2, [r7, #4]
 80087e2:	6812      	ldr	r2, [r2, #0]
 80087e4:	6952      	ldr	r2, [r2, #20]
 80087e6:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80087ea:	615a      	str	r2, [r3, #20]
    
    /* Disable Last error code Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_LEC);
 80087ec:	687b      	ldr	r3, [r7, #4]
 80087ee:	681b      	ldr	r3, [r3, #0]
 80087f0:	687a      	ldr	r2, [r7, #4]
 80087f2:	6812      	ldr	r2, [r2, #0]
 80087f4:	6952      	ldr	r2, [r2, #20]
 80087f6:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80087fa:	615a      	str	r2, [r3, #20]
    
    /* Disable Error Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_ERR);
 80087fc:	687b      	ldr	r3, [r7, #4]
 80087fe:	681b      	ldr	r3, [r3, #0]
 8008800:	687a      	ldr	r2, [r7, #4]
 8008802:	6812      	ldr	r2, [r2, #0]
 8008804:	6952      	ldr	r2, [r2, #20]
 8008806:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800880a:	615a      	str	r2, [r3, #20]
  }
  
  if(hcan->State == HAL_CAN_STATE_BUSY_TX_RX) 
 800880c:	687b      	ldr	r3, [r7, #4]
 800880e:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8008812:	b2db      	uxtb	r3, r3
 8008814:	2b32      	cmp	r3, #50	; 0x32
 8008816:	d104      	bne.n	8008822 <CAN_Receive_IT+0x22a>
  {
    /* Disable CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_TX;
 8008818:	687b      	ldr	r3, [r7, #4]
 800881a:	2212      	movs	r2, #18
 800881c:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
 8008820:	e003      	b.n	800882a <CAN_Receive_IT+0x232>
  }
  else
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_READY;
 8008822:	687b      	ldr	r3, [r7, #4]
 8008824:	2201      	movs	r2, #1
 8008826:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  }

  /* Receive complete callback */ 
  HAL_CAN_RxCpltCallback(hcan);
 800882a:	6878      	ldr	r0, [r7, #4]
 800882c:	f009 fc70 	bl	8012110 <HAL_CAN_RxCpltCallback>

  /* Return function status */
  return HAL_OK;
 8008830:	2300      	movs	r3, #0
}
 8008832:	4618      	mov	r0, r3
 8008834:	3708      	adds	r7, #8
 8008836:	46bd      	mov	sp, r7
 8008838:	bd80      	pop	{r7, pc}
 800883a:	bf00      	nop

0800883c <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800883c:	b480      	push	{r7}
 800883e:	b085      	sub	sp, #20
 8008840:	af00      	add	r7, sp, #0
 8008842:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8008844:	687b      	ldr	r3, [r7, #4]
 8008846:	f003 0307 	and.w	r3, r3, #7
 800884a:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800884c:	4b0b      	ldr	r3, [pc, #44]	; (800887c <NVIC_SetPriorityGrouping+0x40>)
 800884e:	68db      	ldr	r3, [r3, #12]
 8008850:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 8008852:	68ba      	ldr	r2, [r7, #8]
 8008854:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8008858:	4013      	ands	r3, r2
 800885a:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
 800885c:	68fb      	ldr	r3, [r7, #12]
 800885e:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8008860:	68bb      	ldr	r3, [r7, #8]
 8008862:	431a      	orrs	r2, r3
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8008864:	4b06      	ldr	r3, [pc, #24]	; (8008880 <NVIC_SetPriorityGrouping+0x44>)
 8008866:	4313      	orrs	r3, r2
 8008868:	60bb      	str	r3, [r7, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 800886a:	4a04      	ldr	r2, [pc, #16]	; (800887c <NVIC_SetPriorityGrouping+0x40>)
 800886c:	68bb      	ldr	r3, [r7, #8]
 800886e:	60d3      	str	r3, [r2, #12]
}
 8008870:	3714      	adds	r7, #20
 8008872:	46bd      	mov	sp, r7
 8008874:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008878:	4770      	bx	lr
 800887a:	bf00      	nop
 800887c:	e000ed00 	.word	0xe000ed00
 8008880:	05fa0000 	.word	0x05fa0000

08008884 <NVIC_GetPriorityGrouping>:
  The function reads the priority grouping field from the NVIC Interrupt Controller.

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
 8008884:	b480      	push	{r7}
 8008886:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8008888:	4b04      	ldr	r3, [pc, #16]	; (800889c <NVIC_GetPriorityGrouping+0x18>)
 800888a:	68db      	ldr	r3, [r3, #12]
 800888c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8008890:	0a1b      	lsrs	r3, r3, #8
}
 8008892:	4618      	mov	r0, r3
 8008894:	46bd      	mov	sp, r7
 8008896:	f85d 7b04 	ldr.w	r7, [sp], #4
 800889a:	4770      	bx	lr
 800889c:	e000ed00 	.word	0xe000ed00

080088a0 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80088a0:	b480      	push	{r7}
 80088a2:	b083      	sub	sp, #12
 80088a4:	af00      	add	r7, sp, #0
 80088a6:	4603      	mov	r3, r0
 80088a8:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80088aa:	4908      	ldr	r1, [pc, #32]	; (80088cc <NVIC_EnableIRQ+0x2c>)
 80088ac:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80088b0:	095b      	lsrs	r3, r3, #5
 80088b2:	79fa      	ldrb	r2, [r7, #7]
 80088b4:	f002 021f 	and.w	r2, r2, #31
 80088b8:	2001      	movs	r0, #1
 80088ba:	fa00 f202 	lsl.w	r2, r0, r2
 80088be:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80088c2:	370c      	adds	r7, #12
 80088c4:	46bd      	mov	sp, r7
 80088c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80088ca:	4770      	bx	lr
 80088cc:	e000e100 	.word	0xe000e100

080088d0 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
 80088d0:	b480      	push	{r7}
 80088d2:	b083      	sub	sp, #12
 80088d4:	af00      	add	r7, sp, #0
 80088d6:	4603      	mov	r3, r0
 80088d8:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80088da:	4909      	ldr	r1, [pc, #36]	; (8008900 <NVIC_DisableIRQ+0x30>)
 80088dc:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80088e0:	095b      	lsrs	r3, r3, #5
 80088e2:	79fa      	ldrb	r2, [r7, #7]
 80088e4:	f002 021f 	and.w	r2, r2, #31
 80088e8:	2001      	movs	r0, #1
 80088ea:	fa00 f202 	lsl.w	r2, r0, r2
 80088ee:	3320      	adds	r3, #32
 80088f0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80088f4:	370c      	adds	r7, #12
 80088f6:	46bd      	mov	sp, r7
 80088f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80088fc:	4770      	bx	lr
 80088fe:	bf00      	nop
 8008900:	e000e100 	.word	0xe000e100

08008904 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8008904:	b480      	push	{r7}
 8008906:	b083      	sub	sp, #12
 8008908:	af00      	add	r7, sp, #0
 800890a:	4603      	mov	r3, r0
 800890c:	6039      	str	r1, [r7, #0]
 800890e:	71fb      	strb	r3, [r7, #7]
  if((int32_t)IRQn < 0) {
 8008910:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8008914:	2b00      	cmp	r3, #0
 8008916:	da0b      	bge.n	8008930 <NVIC_SetPriority+0x2c>
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8008918:	490d      	ldr	r1, [pc, #52]	; (8008950 <NVIC_SetPriority+0x4c>)
 800891a:	79fb      	ldrb	r3, [r7, #7]
 800891c:	f003 030f 	and.w	r3, r3, #15
 8008920:	3b04      	subs	r3, #4
 8008922:	683a      	ldr	r2, [r7, #0]
 8008924:	b2d2      	uxtb	r2, r2
 8008926:	0112      	lsls	r2, r2, #4
 8008928:	b2d2      	uxtb	r2, r2
 800892a:	440b      	add	r3, r1
 800892c:	761a      	strb	r2, [r3, #24]
 800892e:	e009      	b.n	8008944 <NVIC_SetPriority+0x40>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]                = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8008930:	4908      	ldr	r1, [pc, #32]	; (8008954 <NVIC_SetPriority+0x50>)
 8008932:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8008936:	683a      	ldr	r2, [r7, #0]
 8008938:	b2d2      	uxtb	r2, r2
 800893a:	0112      	lsls	r2, r2, #4
 800893c:	b2d2      	uxtb	r2, r2
 800893e:	440b      	add	r3, r1
 8008940:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 8008944:	370c      	adds	r7, #12
 8008946:	46bd      	mov	sp, r7
 8008948:	f85d 7b04 	ldr.w	r7, [sp], #4
 800894c:	4770      	bx	lr
 800894e:	bf00      	nop
 8008950:	e000ed00 	.word	0xe000ed00
 8008954:	e000e100 	.word	0xe000e100

08008958 <NVIC_EncodePriority>:
    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
    \param [in]       SubPriority  Subpriority value (starting from 0).
    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8008958:	b480      	push	{r7}
 800895a:	b089      	sub	sp, #36	; 0x24
 800895c:	af00      	add	r7, sp, #0
 800895e:	60f8      	str	r0, [r7, #12]
 8008960:	60b9      	str	r1, [r7, #8]
 8008962:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8008964:	68fb      	ldr	r3, [r7, #12]
 8008966:	f003 0307 	and.w	r3, r3, #7
 800896a:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800896c:	69fb      	ldr	r3, [r7, #28]
 800896e:	f1c3 0307 	rsb	r3, r3, #7
 8008972:	2b04      	cmp	r3, #4
 8008974:	bf28      	it	cs
 8008976:	2304      	movcs	r3, #4
 8008978:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800897a:	69fb      	ldr	r3, [r7, #28]
 800897c:	3304      	adds	r3, #4
 800897e:	2b06      	cmp	r3, #6
 8008980:	d902      	bls.n	8008988 <NVIC_EncodePriority+0x30>
 8008982:	69fb      	ldr	r3, [r7, #28]
 8008984:	3b03      	subs	r3, #3
 8008986:	e000      	b.n	800898a <NVIC_EncodePriority+0x32>
 8008988:	2300      	movs	r3, #0
 800898a:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800898c:	69bb      	ldr	r3, [r7, #24]
 800898e:	2201      	movs	r2, #1
 8008990:	fa02 f303 	lsl.w	r3, r2, r3
 8008994:	1e5a      	subs	r2, r3, #1
 8008996:	68bb      	ldr	r3, [r7, #8]
 8008998:	401a      	ands	r2, r3
 800899a:	697b      	ldr	r3, [r7, #20]
 800899c:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800899e:	697b      	ldr	r3, [r7, #20]
 80089a0:	2101      	movs	r1, #1
 80089a2:	fa01 f303 	lsl.w	r3, r1, r3
 80089a6:	1e59      	subs	r1, r3, #1
 80089a8:	687b      	ldr	r3, [r7, #4]
 80089aa:	400b      	ands	r3, r1
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 80089ac:	4313      	orrs	r3, r2
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
         );
}
 80089ae:	4618      	mov	r0, r3
 80089b0:	3724      	adds	r7, #36	; 0x24
 80089b2:	46bd      	mov	sp, r7
 80089b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80089b8:	4770      	bx	lr
 80089ba:	bf00      	nop

080089bc <SysTick_Config>:
    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 80089bc:	b580      	push	{r7, lr}
 80089be:	b082      	sub	sp, #8
 80089c0:	af00      	add	r7, sp, #0
 80089c2:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
 80089c4:	687b      	ldr	r3, [r7, #4]
 80089c6:	3b01      	subs	r3, #1
 80089c8:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80089cc:	d301      	bcc.n	80089d2 <SysTick_Config+0x16>
 80089ce:	2301      	movs	r3, #1
 80089d0:	e00f      	b.n	80089f2 <SysTick_Config+0x36>

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80089d2:	4a0a      	ldr	r2, [pc, #40]	; (80089fc <SysTick_Config+0x40>)
 80089d4:	687b      	ldr	r3, [r7, #4]
 80089d6:	3b01      	subs	r3, #1
 80089d8:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 80089da:	f04f 30ff 	mov.w	r0, #4294967295
 80089de:	210f      	movs	r1, #15
 80089e0:	f7ff ff90 	bl	8008904 <NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80089e4:	4b05      	ldr	r3, [pc, #20]	; (80089fc <SysTick_Config+0x40>)
 80089e6:	2200      	movs	r2, #0
 80089e8:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80089ea:	4b04      	ldr	r3, [pc, #16]	; (80089fc <SysTick_Config+0x40>)
 80089ec:	2207      	movs	r2, #7
 80089ee:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80089f0:	2300      	movs	r3, #0
}
 80089f2:	4618      	mov	r0, r3
 80089f4:	3708      	adds	r7, #8
 80089f6:	46bd      	mov	sp, r7
 80089f8:	bd80      	pop	{r7, pc}
 80089fa:	bf00      	nop
 80089fc:	e000e010 	.word	0xe000e010

08008a00 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8008a00:	b580      	push	{r7, lr}
 8008a02:	b082      	sub	sp, #8
 8008a04:	af00      	add	r7, sp, #0
 8008a06:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8008a08:	6878      	ldr	r0, [r7, #4]
 8008a0a:	f7ff ff17 	bl	800883c <NVIC_SetPriorityGrouping>
}
 8008a0e:	3708      	adds	r7, #8
 8008a10:	46bd      	mov	sp, r7
 8008a12:	bd80      	pop	{r7, pc}

08008a14 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8008a14:	b580      	push	{r7, lr}
 8008a16:	b086      	sub	sp, #24
 8008a18:	af00      	add	r7, sp, #0
 8008a1a:	4603      	mov	r3, r0
 8008a1c:	60b9      	str	r1, [r7, #8]
 8008a1e:	607a      	str	r2, [r7, #4]
 8008a20:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00;
 8008a22:	2300      	movs	r3, #0
 8008a24:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 8008a26:	f7ff ff2d 	bl	8008884 <NVIC_GetPriorityGrouping>
 8008a2a:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8008a2c:	6978      	ldr	r0, [r7, #20]
 8008a2e:	68b9      	ldr	r1, [r7, #8]
 8008a30:	687a      	ldr	r2, [r7, #4]
 8008a32:	f7ff ff91 	bl	8008958 <NVIC_EncodePriority>
 8008a36:	4602      	mov	r2, r0
 8008a38:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8008a3c:	4618      	mov	r0, r3
 8008a3e:	4611      	mov	r1, r2
 8008a40:	f7ff ff60 	bl	8008904 <NVIC_SetPriority>
}
 8008a44:	3718      	adds	r7, #24
 8008a46:	46bd      	mov	sp, r7
 8008a48:	bd80      	pop	{r7, pc}
 8008a4a:	bf00      	nop

08008a4c <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8008a4c:	b580      	push	{r7, lr}
 8008a4e:	b082      	sub	sp, #8
 8008a50:	af00      	add	r7, sp, #0
 8008a52:	4603      	mov	r3, r0
 8008a54:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8008a56:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8008a5a:	4618      	mov	r0, r3
 8008a5c:	f7ff ff20 	bl	80088a0 <NVIC_EnableIRQ>
}
 8008a60:	3708      	adds	r7, #8
 8008a62:	46bd      	mov	sp, r7
 8008a64:	bd80      	pop	{r7, pc}
 8008a66:	bf00      	nop

08008a68 <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
 8008a68:	b580      	push	{r7, lr}
 8008a6a:	b082      	sub	sp, #8
 8008a6c:	af00      	add	r7, sp, #0
 8008a6e:	4603      	mov	r3, r0
 8008a70:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
 8008a72:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8008a76:	4618      	mov	r0, r3
 8008a78:	f7ff ff2a 	bl	80088d0 <NVIC_DisableIRQ>
}
 8008a7c:	3708      	adds	r7, #8
 8008a7e:	46bd      	mov	sp, r7
 8008a80:	bd80      	pop	{r7, pc}
 8008a82:	bf00      	nop

08008a84 <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8008a84:	b580      	push	{r7, lr}
 8008a86:	b082      	sub	sp, #8
 8008a88:	af00      	add	r7, sp, #0
 8008a8a:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8008a8c:	6878      	ldr	r0, [r7, #4]
 8008a8e:	f7ff ff95 	bl	80089bc <SysTick_Config>
 8008a92:	4603      	mov	r3, r0
}
 8008a94:	4618      	mov	r0, r3
 8008a96:	3708      	adds	r7, #8
 8008a98:	46bd      	mov	sp, r7
 8008a9a:	bd80      	pop	{r7, pc}

08008a9c <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init: Pointer to a MPU_Region_InitTypeDef structure that contains
  *                the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
 8008a9c:	b480      	push	{r7}
 8008a9e:	b083      	sub	sp, #12
 8008aa0:	af00      	add	r7, sp, #0
 8008aa2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
 8008aa4:	4a1d      	ldr	r2, [pc, #116]	; (8008b1c <HAL_MPU_ConfigRegion+0x80>)
 8008aa6:	687b      	ldr	r3, [r7, #4]
 8008aa8:	785b      	ldrb	r3, [r3, #1]
 8008aaa:	6093      	str	r3, [r2, #8]

  if ((MPU_Init->Enable) != RESET)
 8008aac:	687b      	ldr	r3, [r7, #4]
 8008aae:	781b      	ldrb	r3, [r3, #0]
 8008ab0:	2b00      	cmp	r3, #0
 8008ab2:	d028      	beq.n	8008b06 <HAL_MPU_ConfigRegion+0x6a>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
 8008ab4:	4a19      	ldr	r2, [pc, #100]	; (8008b1c <HAL_MPU_ConfigRegion+0x80>)
 8008ab6:	687b      	ldr	r3, [r7, #4]
 8008ab8:	685b      	ldr	r3, [r3, #4]
 8008aba:	60d3      	str	r3, [r2, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8008abc:	4917      	ldr	r1, [pc, #92]	; (8008b1c <HAL_MPU_ConfigRegion+0x80>)
 8008abe:	687b      	ldr	r3, [r7, #4]
 8008ac0:	7b1b      	ldrb	r3, [r3, #12]
 8008ac2:	071a      	lsls	r2, r3, #28
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 8008ac4:	687b      	ldr	r3, [r7, #4]
 8008ac6:	7adb      	ldrb	r3, [r3, #11]
 8008ac8:	061b      	lsls	r3, r3, #24
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8008aca:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 8008acc:	687b      	ldr	r3, [r7, #4]
 8008ace:	7a9b      	ldrb	r3, [r3, #10]
 8008ad0:	04db      	lsls	r3, r3, #19
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 8008ad2:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 8008ad4:	687b      	ldr	r3, [r7, #4]
 8008ad6:	7b5b      	ldrb	r3, [r3, #13]
 8008ad8:	049b      	lsls	r3, r3, #18
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 8008ada:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 8008adc:	687b      	ldr	r3, [r7, #4]
 8008ade:	7b9b      	ldrb	r3, [r3, #14]
 8008ae0:	045b      	lsls	r3, r3, #17
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 8008ae2:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 8008ae4:	687b      	ldr	r3, [r7, #4]
 8008ae6:	7bdb      	ldrb	r3, [r3, #15]
 8008ae8:	041b      	lsls	r3, r3, #16
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 8008aea:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 8008aec:	687b      	ldr	r3, [r7, #4]
 8008aee:	7a5b      	ldrb	r3, [r3, #9]
 8008af0:	021b      	lsls	r3, r3, #8
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 8008af2:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8008af4:	687b      	ldr	r3, [r7, #4]
 8008af6:	7a1b      	ldrb	r3, [r3, #8]
 8008af8:	005b      	lsls	r3, r3, #1
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 8008afa:	4313      	orrs	r3, r2
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
 8008afc:	687a      	ldr	r2, [r7, #4]
 8008afe:	7812      	ldrb	r2, [r2, #0]
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8008b00:	4313      	orrs	r3, r2
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8008b02:	610b      	str	r3, [r1, #16]
 8008b04:	e005      	b.n	8008b12 <HAL_MPU_ConfigRegion+0x76>
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
  }
  else
  {
    MPU->RBAR = 0x00;
 8008b06:	4b05      	ldr	r3, [pc, #20]	; (8008b1c <HAL_MPU_ConfigRegion+0x80>)
 8008b08:	2200      	movs	r2, #0
 8008b0a:	60da      	str	r2, [r3, #12]
    MPU->RASR = 0x00;
 8008b0c:	4b03      	ldr	r3, [pc, #12]	; (8008b1c <HAL_MPU_ConfigRegion+0x80>)
 8008b0e:	2200      	movs	r2, #0
 8008b10:	611a      	str	r2, [r3, #16]
  }
}
 8008b12:	370c      	adds	r7, #12
 8008b14:	46bd      	mov	sp, r7
 8008b16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008b1a:	4770      	bx	lr
 8008b1c:	e000ed90 	.word	0xe000ed90

08008b20 <DMA_SetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8008b20:	b480      	push	{r7}
 8008b22:	b085      	sub	sp, #20
 8008b24:	af00      	add	r7, sp, #0
 8008b26:	60f8      	str	r0, [r7, #12]
 8008b28:	60b9      	str	r1, [r7, #8]
 8008b2a:	607a      	str	r2, [r7, #4]
 8008b2c:	603b      	str	r3, [r7, #0]
  /* Clear DBM bit */
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8008b2e:	68fb      	ldr	r3, [r7, #12]
 8008b30:	681b      	ldr	r3, [r3, #0]
 8008b32:	68fa      	ldr	r2, [r7, #12]
 8008b34:	6812      	ldr	r2, [r2, #0]
 8008b36:	6812      	ldr	r2, [r2, #0]
 8008b38:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8008b3c:	601a      	str	r2, [r3, #0]
	
  /* Configure DMA Stream data length */
  hdma->Instance->NDTR = DataLength;
 8008b3e:	68fb      	ldr	r3, [r7, #12]
 8008b40:	681b      	ldr	r3, [r3, #0]
 8008b42:	683a      	ldr	r2, [r7, #0]
 8008b44:	605a      	str	r2, [r3, #4]

  /* Peripheral to Memory */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8008b46:	68fb      	ldr	r3, [r7, #12]
 8008b48:	689b      	ldr	r3, [r3, #8]
 8008b4a:	2b40      	cmp	r3, #64	; 0x40
 8008b4c:	d108      	bne.n	8008b60 <DMA_SetConfig+0x40>
  {
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;
 8008b4e:	68fb      	ldr	r3, [r7, #12]
 8008b50:	681b      	ldr	r3, [r3, #0]
 8008b52:	687a      	ldr	r2, [r7, #4]
 8008b54:	609a      	str	r2, [r3, #8]

    /* Configure DMA Stream source address */
    hdma->Instance->M0AR = SrcAddress;
 8008b56:	68fb      	ldr	r3, [r7, #12]
 8008b58:	681b      	ldr	r3, [r3, #0]
 8008b5a:	68ba      	ldr	r2, [r7, #8]
 8008b5c:	60da      	str	r2, [r3, #12]
 8008b5e:	e007      	b.n	8008b70 <DMA_SetConfig+0x50>
  }
  /* Memory to Peripheral */
  else
  {
    /* Configure DMA Stream source address */
    hdma->Instance->PAR = SrcAddress;
 8008b60:	68fb      	ldr	r3, [r7, #12]
 8008b62:	681b      	ldr	r3, [r3, #0]
 8008b64:	68ba      	ldr	r2, [r7, #8]
 8008b66:	609a      	str	r2, [r3, #8]
    
    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
 8008b68:	68fb      	ldr	r3, [r7, #12]
 8008b6a:	681b      	ldr	r3, [r3, #0]
 8008b6c:	687a      	ldr	r2, [r7, #4]
 8008b6e:	60da      	str	r2, [r3, #12]
  }
}
 8008b70:	3714      	adds	r7, #20
 8008b72:	46bd      	mov	sp, r7
 8008b74:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008b78:	4770      	bx	lr
 8008b7a:	bf00      	nop

08008b7c <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{ 
 8008b7c:	b480      	push	{r7}
 8008b7e:	b085      	sub	sp, #20
 8008b80:	af00      	add	r7, sp, #0
 8008b82:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0;
 8008b84:	2300      	movs	r3, #0
 8008b86:	60fb      	str	r3, [r7, #12]
  
  /* Check the DMA peripheral state */
  if(hdma == NULL)
 8008b88:	687b      	ldr	r3, [r7, #4]
 8008b8a:	2b00      	cmp	r3, #0
 8008b8c:	d101      	bne.n	8008b92 <HAL_DMA_Init+0x16>
  {
    return HAL_ERROR;
 8008b8e:	2301      	movs	r3, #1
 8008b90:	e057      	b.n	8008c42 <HAL_DMA_Init+0xc6>
    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
  }

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8008b92:	687b      	ldr	r3, [r7, #4]
 8008b94:	2202      	movs	r2, #2
 8008b96:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  /* Get the CR register value */
  tmp = hdma->Instance->CR;
 8008b9a:	687b      	ldr	r3, [r7, #4]
 8008b9c:	681b      	ldr	r3, [r3, #0]
 8008b9e:	681b      	ldr	r3, [r3, #0]
 8008ba0:	60fb      	str	r3, [r7, #12]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8008ba2:	68fa      	ldr	r2, [r7, #12]
 8008ba4:	4b2a      	ldr	r3, [pc, #168]	; (8008c50 <HAL_DMA_Init+0xd4>)
 8008ba6:	4013      	ands	r3, r2
 8008ba8:	60fb      	str	r3, [r7, #12]
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8008baa:	687b      	ldr	r3, [r7, #4]
 8008bac:	685a      	ldr	r2, [r3, #4]
 8008bae:	687b      	ldr	r3, [r7, #4]
 8008bb0:	689b      	ldr	r3, [r3, #8]
 8008bb2:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8008bb4:	687b      	ldr	r3, [r7, #4]
 8008bb6:	68db      	ldr	r3, [r3, #12]
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8008bb8:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8008bba:	687b      	ldr	r3, [r7, #4]
 8008bbc:	691b      	ldr	r3, [r3, #16]
 8008bbe:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8008bc0:	687b      	ldr	r3, [r7, #4]
 8008bc2:	695b      	ldr	r3, [r3, #20]
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8008bc4:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8008bc6:	687b      	ldr	r3, [r7, #4]
 8008bc8:	699b      	ldr	r3, [r3, #24]
 8008bca:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 8008bcc:	687b      	ldr	r3, [r7, #4]
 8008bce:	69db      	ldr	r3, [r3, #28]
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8008bd0:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 8008bd2:	687b      	ldr	r3, [r7, #4]
 8008bd4:	6a1b      	ldr	r3, [r3, #32]
 8008bd6:	4313      	orrs	r3, r2
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8008bd8:	68fa      	ldr	r2, [r7, #12]
 8008bda:	4313      	orrs	r3, r2
 8008bdc:	60fb      	str	r3, [r7, #12]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
          hdma->Init.Mode                | hdma->Init.Priority;

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8008bde:	687b      	ldr	r3, [r7, #4]
 8008be0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8008be2:	2b04      	cmp	r3, #4
 8008be4:	d107      	bne.n	8008bf6 <HAL_DMA_Init+0x7a>
  {
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8008be6:	687b      	ldr	r3, [r7, #4]
 8008be8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8008bea:	687b      	ldr	r3, [r7, #4]
 8008bec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008bee:	4313      	orrs	r3, r2
 8008bf0:	68fa      	ldr	r2, [r7, #12]
 8008bf2:	4313      	orrs	r3, r2
 8008bf4:	60fb      	str	r3, [r7, #12]
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 8008bf6:	687b      	ldr	r3, [r7, #4]
 8008bf8:	681b      	ldr	r3, [r3, #0]
 8008bfa:	68fa      	ldr	r2, [r7, #12]
 8008bfc:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 8008bfe:	687b      	ldr	r3, [r7, #4]
 8008c00:	681b      	ldr	r3, [r3, #0]
 8008c02:	695b      	ldr	r3, [r3, #20]
 8008c04:	60fb      	str	r3, [r7, #12]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8008c06:	68fb      	ldr	r3, [r7, #12]
 8008c08:	f023 0307 	bic.w	r3, r3, #7
 8008c0c:	60fb      	str	r3, [r7, #12]

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 8008c0e:	687b      	ldr	r3, [r7, #4]
 8008c10:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8008c12:	68fa      	ldr	r2, [r7, #12]
 8008c14:	4313      	orrs	r3, r2
 8008c16:	60fb      	str	r3, [r7, #12]

  /* the FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8008c18:	687b      	ldr	r3, [r7, #4]
 8008c1a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8008c1c:	2b04      	cmp	r3, #4
 8008c1e:	d104      	bne.n	8008c2a <HAL_DMA_Init+0xae>
  {
    /* Get the FIFO threshold */
    tmp |= hdma->Init.FIFOThreshold;
 8008c20:	687b      	ldr	r3, [r7, #4]
 8008c22:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008c24:	68fa      	ldr	r2, [r7, #12]
 8008c26:	4313      	orrs	r3, r2
 8008c28:	60fb      	str	r3, [r7, #12]
  }
  
  /* Write to DMA Stream FCR */
  hdma->Instance->FCR = tmp;
 8008c2a:	687b      	ldr	r3, [r7, #4]
 8008c2c:	681b      	ldr	r3, [r3, #0]
 8008c2e:	68fa      	ldr	r2, [r7, #12]
 8008c30:	615a      	str	r2, [r3, #20]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8008c32:	687b      	ldr	r3, [r7, #4]
 8008c34:	2200      	movs	r2, #0
 8008c36:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 8008c38:	687b      	ldr	r3, [r7, #4]
 8008c3a:	2201      	movs	r2, #1
 8008c3c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
 8008c40:	2300      	movs	r3, #0
}
 8008c42:	4618      	mov	r0, r3
 8008c44:	3714      	adds	r7, #20
 8008c46:	46bd      	mov	sp, r7
 8008c48:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008c4c:	4770      	bx	lr
 8008c4e:	bf00      	nop
 8008c50:	f010803f 	.word	0xf010803f

08008c54 <HAL_DMA_DeInit>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
 8008c54:	b480      	push	{r7}
 8008c56:	b083      	sub	sp, #12
 8008c58:	af00      	add	r7, sp, #0
 8008c5a:	6078      	str	r0, [r7, #4]
  /* Check the DMA peripheral state */
  if(hdma == NULL)
 8008c5c:	687b      	ldr	r3, [r7, #4]
 8008c5e:	2b00      	cmp	r3, #0
 8008c60:	d102      	bne.n	8008c68 <HAL_DMA_DeInit+0x14>
  {
    return HAL_ERROR;
 8008c62:	2301      	movs	r3, #1
 8008c64:	f001 b9f5 	b.w	800a052 <HAL_DMA_DeInit+0x13fe>
  }
  
  /* Check the DMA peripheral state */
  if(hdma->State == HAL_DMA_STATE_BUSY)
 8008c68:	687b      	ldr	r3, [r7, #4]
 8008c6a:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8008c6e:	b2db      	uxtb	r3, r3
 8008c70:	2b02      	cmp	r3, #2
 8008c72:	d102      	bne.n	8008c7a <HAL_DMA_DeInit+0x26>
  {
     return HAL_ERROR;
 8008c74:	2301      	movs	r3, #1
 8008c76:	f001 b9ec 	b.w	800a052 <HAL_DMA_DeInit+0x13fe>
  }

  /* Disable the selected DMA Streamx */
  __HAL_DMA_DISABLE(hdma);
 8008c7a:	687b      	ldr	r3, [r7, #4]
 8008c7c:	681b      	ldr	r3, [r3, #0]
 8008c7e:	687a      	ldr	r2, [r7, #4]
 8008c80:	6812      	ldr	r2, [r2, #0]
 8008c82:	6812      	ldr	r2, [r2, #0]
 8008c84:	f022 0201 	bic.w	r2, r2, #1
 8008c88:	601a      	str	r2, [r3, #0]

  /* Reset DMA Streamx control register */
  hdma->Instance->CR   = 0;
 8008c8a:	687b      	ldr	r3, [r7, #4]
 8008c8c:	681b      	ldr	r3, [r3, #0]
 8008c8e:	2200      	movs	r2, #0
 8008c90:	601a      	str	r2, [r3, #0]

  /* Reset DMA Streamx number of data to transfer register */
  hdma->Instance->NDTR = 0;
 8008c92:	687b      	ldr	r3, [r7, #4]
 8008c94:	681b      	ldr	r3, [r3, #0]
 8008c96:	2200      	movs	r2, #0
 8008c98:	605a      	str	r2, [r3, #4]

  /* Reset DMA Streamx peripheral address register */
  hdma->Instance->PAR  = 0;
 8008c9a:	687b      	ldr	r3, [r7, #4]
 8008c9c:	681b      	ldr	r3, [r3, #0]
 8008c9e:	2200      	movs	r2, #0
 8008ca0:	609a      	str	r2, [r3, #8]

  /* Reset DMA Streamx memory 0 address register */
  hdma->Instance->M0AR = 0;
 8008ca2:	687b      	ldr	r3, [r7, #4]
 8008ca4:	681b      	ldr	r3, [r3, #0]
 8008ca6:	2200      	movs	r2, #0
 8008ca8:	60da      	str	r2, [r3, #12]

  /* Reset DMA Streamx memory 1 address register */
  hdma->Instance->M1AR = 0;
 8008caa:	687b      	ldr	r3, [r7, #4]
 8008cac:	681b      	ldr	r3, [r3, #0]
 8008cae:	2200      	movs	r2, #0
 8008cb0:	611a      	str	r2, [r3, #16]

  /* Reset DMA Streamx FIFO control register */
  hdma->Instance->FCR  = (uint32_t)0x00000021;
 8008cb2:	687b      	ldr	r3, [r7, #4]
 8008cb4:	681b      	ldr	r3, [r3, #0]
 8008cb6:	2221      	movs	r2, #33	; 0x21
 8008cb8:	615a      	str	r2, [r3, #20]

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8008cba:	687b      	ldr	r3, [r7, #4]
 8008cbc:	681b      	ldr	r3, [r3, #0]
 8008cbe:	461a      	mov	r2, r3
 8008cc0:	4b9c      	ldr	r3, [pc, #624]	; (8008f34 <HAL_DMA_DeInit+0x2e0>)
 8008cc2:	429a      	cmp	r2, r3
 8008cc4:	d96c      	bls.n	8008da0 <HAL_DMA_DeInit+0x14c>
 8008cc6:	4a9c      	ldr	r2, [pc, #624]	; (8008f38 <HAL_DMA_DeInit+0x2e4>)
 8008cc8:	687b      	ldr	r3, [r7, #4]
 8008cca:	681b      	ldr	r3, [r3, #0]
 8008ccc:	4619      	mov	r1, r3
 8008cce:	4b9b      	ldr	r3, [pc, #620]	; (8008f3c <HAL_DMA_DeInit+0x2e8>)
 8008cd0:	4299      	cmp	r1, r3
 8008cd2:	d062      	beq.n	8008d9a <HAL_DMA_DeInit+0x146>
 8008cd4:	687b      	ldr	r3, [r7, #4]
 8008cd6:	681b      	ldr	r3, [r3, #0]
 8008cd8:	4619      	mov	r1, r3
 8008cda:	4b99      	ldr	r3, [pc, #612]	; (8008f40 <HAL_DMA_DeInit+0x2ec>)
 8008cdc:	4299      	cmp	r1, r3
 8008cde:	d05a      	beq.n	8008d96 <HAL_DMA_DeInit+0x142>
 8008ce0:	687b      	ldr	r3, [r7, #4]
 8008ce2:	681b      	ldr	r3, [r3, #0]
 8008ce4:	4619      	mov	r1, r3
 8008ce6:	4b97      	ldr	r3, [pc, #604]	; (8008f44 <HAL_DMA_DeInit+0x2f0>)
 8008ce8:	4299      	cmp	r1, r3
 8008cea:	d052      	beq.n	8008d92 <HAL_DMA_DeInit+0x13e>
 8008cec:	687b      	ldr	r3, [r7, #4]
 8008cee:	681b      	ldr	r3, [r3, #0]
 8008cf0:	4619      	mov	r1, r3
 8008cf2:	4b95      	ldr	r3, [pc, #596]	; (8008f48 <HAL_DMA_DeInit+0x2f4>)
 8008cf4:	4299      	cmp	r1, r3
 8008cf6:	d04a      	beq.n	8008d8e <HAL_DMA_DeInit+0x13a>
 8008cf8:	687b      	ldr	r3, [r7, #4]
 8008cfa:	681b      	ldr	r3, [r3, #0]
 8008cfc:	4619      	mov	r1, r3
 8008cfe:	4b93      	ldr	r3, [pc, #588]	; (8008f4c <HAL_DMA_DeInit+0x2f8>)
 8008d00:	4299      	cmp	r1, r3
 8008d02:	d041      	beq.n	8008d88 <HAL_DMA_DeInit+0x134>
 8008d04:	687b      	ldr	r3, [r7, #4]
 8008d06:	681b      	ldr	r3, [r3, #0]
 8008d08:	4619      	mov	r1, r3
 8008d0a:	4b91      	ldr	r3, [pc, #580]	; (8008f50 <HAL_DMA_DeInit+0x2fc>)
 8008d0c:	4299      	cmp	r1, r3
 8008d0e:	d038      	beq.n	8008d82 <HAL_DMA_DeInit+0x12e>
 8008d10:	687b      	ldr	r3, [r7, #4]
 8008d12:	681b      	ldr	r3, [r3, #0]
 8008d14:	4619      	mov	r1, r3
 8008d16:	4b8f      	ldr	r3, [pc, #572]	; (8008f54 <HAL_DMA_DeInit+0x300>)
 8008d18:	4299      	cmp	r1, r3
 8008d1a:	d02f      	beq.n	8008d7c <HAL_DMA_DeInit+0x128>
 8008d1c:	687b      	ldr	r3, [r7, #4]
 8008d1e:	681b      	ldr	r3, [r3, #0]
 8008d20:	4619      	mov	r1, r3
 8008d22:	4b8d      	ldr	r3, [pc, #564]	; (8008f58 <HAL_DMA_DeInit+0x304>)
 8008d24:	4299      	cmp	r1, r3
 8008d26:	d026      	beq.n	8008d76 <HAL_DMA_DeInit+0x122>
 8008d28:	687b      	ldr	r3, [r7, #4]
 8008d2a:	681b      	ldr	r3, [r3, #0]
 8008d2c:	4619      	mov	r1, r3
 8008d2e:	4b8b      	ldr	r3, [pc, #556]	; (8008f5c <HAL_DMA_DeInit+0x308>)
 8008d30:	4299      	cmp	r1, r3
 8008d32:	d01d      	beq.n	8008d70 <HAL_DMA_DeInit+0x11c>
 8008d34:	687b      	ldr	r3, [r7, #4]
 8008d36:	681b      	ldr	r3, [r3, #0]
 8008d38:	4619      	mov	r1, r3
 8008d3a:	4b89      	ldr	r3, [pc, #548]	; (8008f60 <HAL_DMA_DeInit+0x30c>)
 8008d3c:	4299      	cmp	r1, r3
 8008d3e:	d014      	beq.n	8008d6a <HAL_DMA_DeInit+0x116>
 8008d40:	687b      	ldr	r3, [r7, #4]
 8008d42:	681b      	ldr	r3, [r3, #0]
 8008d44:	4619      	mov	r1, r3
 8008d46:	4b87      	ldr	r3, [pc, #540]	; (8008f64 <HAL_DMA_DeInit+0x310>)
 8008d48:	4299      	cmp	r1, r3
 8008d4a:	d00b      	beq.n	8008d64 <HAL_DMA_DeInit+0x110>
 8008d4c:	687b      	ldr	r3, [r7, #4]
 8008d4e:	681b      	ldr	r3, [r3, #0]
 8008d50:	4619      	mov	r1, r3
 8008d52:	4b85      	ldr	r3, [pc, #532]	; (8008f68 <HAL_DMA_DeInit+0x314>)
 8008d54:	4299      	cmp	r1, r3
 8008d56:	d102      	bne.n	8008d5e <HAL_DMA_DeInit+0x10a>
 8008d58:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8008d5c:	e01e      	b.n	8008d9c <HAL_DMA_DeInit+0x148>
 8008d5e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8008d62:	e01b      	b.n	8008d9c <HAL_DMA_DeInit+0x148>
 8008d64:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8008d68:	e018      	b.n	8008d9c <HAL_DMA_DeInit+0x148>
 8008d6a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8008d6e:	e015      	b.n	8008d9c <HAL_DMA_DeInit+0x148>
 8008d70:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8008d74:	e012      	b.n	8008d9c <HAL_DMA_DeInit+0x148>
 8008d76:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008d7a:	e00f      	b.n	8008d9c <HAL_DMA_DeInit+0x148>
 8008d7c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008d80:	e00c      	b.n	8008d9c <HAL_DMA_DeInit+0x148>
 8008d82:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008d86:	e009      	b.n	8008d9c <HAL_DMA_DeInit+0x148>
 8008d88:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008d8c:	e006      	b.n	8008d9c <HAL_DMA_DeInit+0x148>
 8008d8e:	4b77      	ldr	r3, [pc, #476]	; (8008f6c <HAL_DMA_DeInit+0x318>)
 8008d90:	e004      	b.n	8008d9c <HAL_DMA_DeInit+0x148>
 8008d92:	4b76      	ldr	r3, [pc, #472]	; (8008f6c <HAL_DMA_DeInit+0x318>)
 8008d94:	e002      	b.n	8008d9c <HAL_DMA_DeInit+0x148>
 8008d96:	4b75      	ldr	r3, [pc, #468]	; (8008f6c <HAL_DMA_DeInit+0x318>)
 8008d98:	e000      	b.n	8008d9c <HAL_DMA_DeInit+0x148>
 8008d9a:	4b74      	ldr	r3, [pc, #464]	; (8008f6c <HAL_DMA_DeInit+0x318>)
 8008d9c:	60d3      	str	r3, [r2, #12]
 8008d9e:	e177      	b.n	8009090 <HAL_DMA_DeInit+0x43c>
 8008da0:	687b      	ldr	r3, [r7, #4]
 8008da2:	681b      	ldr	r3, [r3, #0]
 8008da4:	461a      	mov	r2, r3
 8008da6:	4b72      	ldr	r3, [pc, #456]	; (8008f70 <HAL_DMA_DeInit+0x31c>)
 8008da8:	429a      	cmp	r2, r3
 8008daa:	d96c      	bls.n	8008e86 <HAL_DMA_DeInit+0x232>
 8008dac:	4a62      	ldr	r2, [pc, #392]	; (8008f38 <HAL_DMA_DeInit+0x2e4>)
 8008dae:	687b      	ldr	r3, [r7, #4]
 8008db0:	681b      	ldr	r3, [r3, #0]
 8008db2:	4619      	mov	r1, r3
 8008db4:	4b61      	ldr	r3, [pc, #388]	; (8008f3c <HAL_DMA_DeInit+0x2e8>)
 8008db6:	4299      	cmp	r1, r3
 8008db8:	d062      	beq.n	8008e80 <HAL_DMA_DeInit+0x22c>
 8008dba:	687b      	ldr	r3, [r7, #4]
 8008dbc:	681b      	ldr	r3, [r3, #0]
 8008dbe:	4619      	mov	r1, r3
 8008dc0:	4b5f      	ldr	r3, [pc, #380]	; (8008f40 <HAL_DMA_DeInit+0x2ec>)
 8008dc2:	4299      	cmp	r1, r3
 8008dc4:	d05a      	beq.n	8008e7c <HAL_DMA_DeInit+0x228>
 8008dc6:	687b      	ldr	r3, [r7, #4]
 8008dc8:	681b      	ldr	r3, [r3, #0]
 8008dca:	4619      	mov	r1, r3
 8008dcc:	4b5d      	ldr	r3, [pc, #372]	; (8008f44 <HAL_DMA_DeInit+0x2f0>)
 8008dce:	4299      	cmp	r1, r3
 8008dd0:	d052      	beq.n	8008e78 <HAL_DMA_DeInit+0x224>
 8008dd2:	687b      	ldr	r3, [r7, #4]
 8008dd4:	681b      	ldr	r3, [r3, #0]
 8008dd6:	4619      	mov	r1, r3
 8008dd8:	4b5b      	ldr	r3, [pc, #364]	; (8008f48 <HAL_DMA_DeInit+0x2f4>)
 8008dda:	4299      	cmp	r1, r3
 8008ddc:	d04a      	beq.n	8008e74 <HAL_DMA_DeInit+0x220>
 8008dde:	687b      	ldr	r3, [r7, #4]
 8008de0:	681b      	ldr	r3, [r3, #0]
 8008de2:	4619      	mov	r1, r3
 8008de4:	4b59      	ldr	r3, [pc, #356]	; (8008f4c <HAL_DMA_DeInit+0x2f8>)
 8008de6:	4299      	cmp	r1, r3
 8008de8:	d041      	beq.n	8008e6e <HAL_DMA_DeInit+0x21a>
 8008dea:	687b      	ldr	r3, [r7, #4]
 8008dec:	681b      	ldr	r3, [r3, #0]
 8008dee:	4619      	mov	r1, r3
 8008df0:	4b57      	ldr	r3, [pc, #348]	; (8008f50 <HAL_DMA_DeInit+0x2fc>)
 8008df2:	4299      	cmp	r1, r3
 8008df4:	d038      	beq.n	8008e68 <HAL_DMA_DeInit+0x214>
 8008df6:	687b      	ldr	r3, [r7, #4]
 8008df8:	681b      	ldr	r3, [r3, #0]
 8008dfa:	4619      	mov	r1, r3
 8008dfc:	4b55      	ldr	r3, [pc, #340]	; (8008f54 <HAL_DMA_DeInit+0x300>)
 8008dfe:	4299      	cmp	r1, r3
 8008e00:	d02f      	beq.n	8008e62 <HAL_DMA_DeInit+0x20e>
 8008e02:	687b      	ldr	r3, [r7, #4]
 8008e04:	681b      	ldr	r3, [r3, #0]
 8008e06:	4619      	mov	r1, r3
 8008e08:	4b53      	ldr	r3, [pc, #332]	; (8008f58 <HAL_DMA_DeInit+0x304>)
 8008e0a:	4299      	cmp	r1, r3
 8008e0c:	d026      	beq.n	8008e5c <HAL_DMA_DeInit+0x208>
 8008e0e:	687b      	ldr	r3, [r7, #4]
 8008e10:	681b      	ldr	r3, [r3, #0]
 8008e12:	4619      	mov	r1, r3
 8008e14:	4b51      	ldr	r3, [pc, #324]	; (8008f5c <HAL_DMA_DeInit+0x308>)
 8008e16:	4299      	cmp	r1, r3
 8008e18:	d01d      	beq.n	8008e56 <HAL_DMA_DeInit+0x202>
 8008e1a:	687b      	ldr	r3, [r7, #4]
 8008e1c:	681b      	ldr	r3, [r3, #0]
 8008e1e:	4619      	mov	r1, r3
 8008e20:	4b4f      	ldr	r3, [pc, #316]	; (8008f60 <HAL_DMA_DeInit+0x30c>)
 8008e22:	4299      	cmp	r1, r3
 8008e24:	d014      	beq.n	8008e50 <HAL_DMA_DeInit+0x1fc>
 8008e26:	687b      	ldr	r3, [r7, #4]
 8008e28:	681b      	ldr	r3, [r3, #0]
 8008e2a:	4619      	mov	r1, r3
 8008e2c:	4b4d      	ldr	r3, [pc, #308]	; (8008f64 <HAL_DMA_DeInit+0x310>)
 8008e2e:	4299      	cmp	r1, r3
 8008e30:	d00b      	beq.n	8008e4a <HAL_DMA_DeInit+0x1f6>
 8008e32:	687b      	ldr	r3, [r7, #4]
 8008e34:	681b      	ldr	r3, [r3, #0]
 8008e36:	4619      	mov	r1, r3
 8008e38:	4b4b      	ldr	r3, [pc, #300]	; (8008f68 <HAL_DMA_DeInit+0x314>)
 8008e3a:	4299      	cmp	r1, r3
 8008e3c:	d102      	bne.n	8008e44 <HAL_DMA_DeInit+0x1f0>
 8008e3e:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8008e42:	e01e      	b.n	8008e82 <HAL_DMA_DeInit+0x22e>
 8008e44:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8008e48:	e01b      	b.n	8008e82 <HAL_DMA_DeInit+0x22e>
 8008e4a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8008e4e:	e018      	b.n	8008e82 <HAL_DMA_DeInit+0x22e>
 8008e50:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8008e54:	e015      	b.n	8008e82 <HAL_DMA_DeInit+0x22e>
 8008e56:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8008e5a:	e012      	b.n	8008e82 <HAL_DMA_DeInit+0x22e>
 8008e5c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008e60:	e00f      	b.n	8008e82 <HAL_DMA_DeInit+0x22e>
 8008e62:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008e66:	e00c      	b.n	8008e82 <HAL_DMA_DeInit+0x22e>
 8008e68:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008e6c:	e009      	b.n	8008e82 <HAL_DMA_DeInit+0x22e>
 8008e6e:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008e72:	e006      	b.n	8008e82 <HAL_DMA_DeInit+0x22e>
 8008e74:	4b3d      	ldr	r3, [pc, #244]	; (8008f6c <HAL_DMA_DeInit+0x318>)
 8008e76:	e004      	b.n	8008e82 <HAL_DMA_DeInit+0x22e>
 8008e78:	4b3c      	ldr	r3, [pc, #240]	; (8008f6c <HAL_DMA_DeInit+0x318>)
 8008e7a:	e002      	b.n	8008e82 <HAL_DMA_DeInit+0x22e>
 8008e7c:	4b3b      	ldr	r3, [pc, #236]	; (8008f6c <HAL_DMA_DeInit+0x318>)
 8008e7e:	e000      	b.n	8008e82 <HAL_DMA_DeInit+0x22e>
 8008e80:	4b3a      	ldr	r3, [pc, #232]	; (8008f6c <HAL_DMA_DeInit+0x318>)
 8008e82:	6093      	str	r3, [r2, #8]
 8008e84:	e104      	b.n	8009090 <HAL_DMA_DeInit+0x43c>
 8008e86:	687b      	ldr	r3, [r7, #4]
 8008e88:	681b      	ldr	r3, [r3, #0]
 8008e8a:	461a      	mov	r2, r3
 8008e8c:	4b39      	ldr	r3, [pc, #228]	; (8008f74 <HAL_DMA_DeInit+0x320>)
 8008e8e:	429a      	cmp	r2, r3
 8008e90:	f240 8092 	bls.w	8008fb8 <HAL_DMA_DeInit+0x364>
 8008e94:	4a38      	ldr	r2, [pc, #224]	; (8008f78 <HAL_DMA_DeInit+0x324>)
 8008e96:	687b      	ldr	r3, [r7, #4]
 8008e98:	681b      	ldr	r3, [r3, #0]
 8008e9a:	4619      	mov	r1, r3
 8008e9c:	4b27      	ldr	r3, [pc, #156]	; (8008f3c <HAL_DMA_DeInit+0x2e8>)
 8008e9e:	4299      	cmp	r1, r3
 8008ea0:	f000 8087 	beq.w	8008fb2 <HAL_DMA_DeInit+0x35e>
 8008ea4:	687b      	ldr	r3, [r7, #4]
 8008ea6:	681b      	ldr	r3, [r3, #0]
 8008ea8:	4619      	mov	r1, r3
 8008eaa:	4b25      	ldr	r3, [pc, #148]	; (8008f40 <HAL_DMA_DeInit+0x2ec>)
 8008eac:	4299      	cmp	r1, r3
 8008eae:	d07e      	beq.n	8008fae <HAL_DMA_DeInit+0x35a>
 8008eb0:	687b      	ldr	r3, [r7, #4]
 8008eb2:	681b      	ldr	r3, [r3, #0]
 8008eb4:	4619      	mov	r1, r3
 8008eb6:	4b23      	ldr	r3, [pc, #140]	; (8008f44 <HAL_DMA_DeInit+0x2f0>)
 8008eb8:	4299      	cmp	r1, r3
 8008eba:	d076      	beq.n	8008faa <HAL_DMA_DeInit+0x356>
 8008ebc:	687b      	ldr	r3, [r7, #4]
 8008ebe:	681b      	ldr	r3, [r3, #0]
 8008ec0:	4619      	mov	r1, r3
 8008ec2:	4b21      	ldr	r3, [pc, #132]	; (8008f48 <HAL_DMA_DeInit+0x2f4>)
 8008ec4:	4299      	cmp	r1, r3
 8008ec6:	d06e      	beq.n	8008fa6 <HAL_DMA_DeInit+0x352>
 8008ec8:	687b      	ldr	r3, [r7, #4]
 8008eca:	681b      	ldr	r3, [r3, #0]
 8008ecc:	4619      	mov	r1, r3
 8008ece:	4b1f      	ldr	r3, [pc, #124]	; (8008f4c <HAL_DMA_DeInit+0x2f8>)
 8008ed0:	4299      	cmp	r1, r3
 8008ed2:	d065      	beq.n	8008fa0 <HAL_DMA_DeInit+0x34c>
 8008ed4:	687b      	ldr	r3, [r7, #4]
 8008ed6:	681b      	ldr	r3, [r3, #0]
 8008ed8:	4619      	mov	r1, r3
 8008eda:	4b1d      	ldr	r3, [pc, #116]	; (8008f50 <HAL_DMA_DeInit+0x2fc>)
 8008edc:	4299      	cmp	r1, r3
 8008ede:	d05c      	beq.n	8008f9a <HAL_DMA_DeInit+0x346>
 8008ee0:	687b      	ldr	r3, [r7, #4]
 8008ee2:	681b      	ldr	r3, [r3, #0]
 8008ee4:	4619      	mov	r1, r3
 8008ee6:	4b1b      	ldr	r3, [pc, #108]	; (8008f54 <HAL_DMA_DeInit+0x300>)
 8008ee8:	4299      	cmp	r1, r3
 8008eea:	d053      	beq.n	8008f94 <HAL_DMA_DeInit+0x340>
 8008eec:	687b      	ldr	r3, [r7, #4]
 8008eee:	681b      	ldr	r3, [r3, #0]
 8008ef0:	4619      	mov	r1, r3
 8008ef2:	4b19      	ldr	r3, [pc, #100]	; (8008f58 <HAL_DMA_DeInit+0x304>)
 8008ef4:	4299      	cmp	r1, r3
 8008ef6:	d04a      	beq.n	8008f8e <HAL_DMA_DeInit+0x33a>
 8008ef8:	687b      	ldr	r3, [r7, #4]
 8008efa:	681b      	ldr	r3, [r3, #0]
 8008efc:	4619      	mov	r1, r3
 8008efe:	4b17      	ldr	r3, [pc, #92]	; (8008f5c <HAL_DMA_DeInit+0x308>)
 8008f00:	4299      	cmp	r1, r3
 8008f02:	d041      	beq.n	8008f88 <HAL_DMA_DeInit+0x334>
 8008f04:	687b      	ldr	r3, [r7, #4]
 8008f06:	681b      	ldr	r3, [r3, #0]
 8008f08:	4619      	mov	r1, r3
 8008f0a:	4b15      	ldr	r3, [pc, #84]	; (8008f60 <HAL_DMA_DeInit+0x30c>)
 8008f0c:	4299      	cmp	r1, r3
 8008f0e:	d038      	beq.n	8008f82 <HAL_DMA_DeInit+0x32e>
 8008f10:	687b      	ldr	r3, [r7, #4]
 8008f12:	681b      	ldr	r3, [r3, #0]
 8008f14:	4619      	mov	r1, r3
 8008f16:	4b13      	ldr	r3, [pc, #76]	; (8008f64 <HAL_DMA_DeInit+0x310>)
 8008f18:	4299      	cmp	r1, r3
 8008f1a:	d02f      	beq.n	8008f7c <HAL_DMA_DeInit+0x328>
 8008f1c:	687b      	ldr	r3, [r7, #4]
 8008f1e:	681b      	ldr	r3, [r3, #0]
 8008f20:	4619      	mov	r1, r3
 8008f22:	4b11      	ldr	r3, [pc, #68]	; (8008f68 <HAL_DMA_DeInit+0x314>)
 8008f24:	4299      	cmp	r1, r3
 8008f26:	d102      	bne.n	8008f2e <HAL_DMA_DeInit+0x2da>
 8008f28:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8008f2c:	e042      	b.n	8008fb4 <HAL_DMA_DeInit+0x360>
 8008f2e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8008f32:	e03f      	b.n	8008fb4 <HAL_DMA_DeInit+0x360>
 8008f34:	40026458 	.word	0x40026458
 8008f38:	40026400 	.word	0x40026400
 8008f3c:	40026010 	.word	0x40026010
 8008f40:	40026410 	.word	0x40026410
 8008f44:	40026070 	.word	0x40026070
 8008f48:	40026470 	.word	0x40026470
 8008f4c:	40026028 	.word	0x40026028
 8008f50:	40026428 	.word	0x40026428
 8008f54:	40026088 	.word	0x40026088
 8008f58:	40026488 	.word	0x40026488
 8008f5c:	40026040 	.word	0x40026040
 8008f60:	40026440 	.word	0x40026440
 8008f64:	400260a0 	.word	0x400260a0
 8008f68:	400264a0 	.word	0x400264a0
 8008f6c:	00800004 	.word	0x00800004
 8008f70:	400260b8 	.word	0x400260b8
 8008f74:	40026058 	.word	0x40026058
 8008f78:	40026000 	.word	0x40026000
 8008f7c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8008f80:	e018      	b.n	8008fb4 <HAL_DMA_DeInit+0x360>
 8008f82:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8008f86:	e015      	b.n	8008fb4 <HAL_DMA_DeInit+0x360>
 8008f88:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8008f8c:	e012      	b.n	8008fb4 <HAL_DMA_DeInit+0x360>
 8008f8e:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008f92:	e00f      	b.n	8008fb4 <HAL_DMA_DeInit+0x360>
 8008f94:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008f98:	e00c      	b.n	8008fb4 <HAL_DMA_DeInit+0x360>
 8008f9a:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008f9e:	e009      	b.n	8008fb4 <HAL_DMA_DeInit+0x360>
 8008fa0:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008fa4:	e006      	b.n	8008fb4 <HAL_DMA_DeInit+0x360>
 8008fa6:	4b74      	ldr	r3, [pc, #464]	; (8009178 <HAL_DMA_DeInit+0x524>)
 8008fa8:	e004      	b.n	8008fb4 <HAL_DMA_DeInit+0x360>
 8008faa:	4b73      	ldr	r3, [pc, #460]	; (8009178 <HAL_DMA_DeInit+0x524>)
 8008fac:	e002      	b.n	8008fb4 <HAL_DMA_DeInit+0x360>
 8008fae:	4b72      	ldr	r3, [pc, #456]	; (8009178 <HAL_DMA_DeInit+0x524>)
 8008fb0:	e000      	b.n	8008fb4 <HAL_DMA_DeInit+0x360>
 8008fb2:	4b71      	ldr	r3, [pc, #452]	; (8009178 <HAL_DMA_DeInit+0x524>)
 8008fb4:	60d3      	str	r3, [r2, #12]
 8008fb6:	e06b      	b.n	8009090 <HAL_DMA_DeInit+0x43c>
 8008fb8:	4a70      	ldr	r2, [pc, #448]	; (800917c <HAL_DMA_DeInit+0x528>)
 8008fba:	687b      	ldr	r3, [r7, #4]
 8008fbc:	681b      	ldr	r3, [r3, #0]
 8008fbe:	4619      	mov	r1, r3
 8008fc0:	4b6f      	ldr	r3, [pc, #444]	; (8009180 <HAL_DMA_DeInit+0x52c>)
 8008fc2:	4299      	cmp	r1, r3
 8008fc4:	d062      	beq.n	800908c <HAL_DMA_DeInit+0x438>
 8008fc6:	687b      	ldr	r3, [r7, #4]
 8008fc8:	681b      	ldr	r3, [r3, #0]
 8008fca:	4619      	mov	r1, r3
 8008fcc:	4b6d      	ldr	r3, [pc, #436]	; (8009184 <HAL_DMA_DeInit+0x530>)
 8008fce:	4299      	cmp	r1, r3
 8008fd0:	d05a      	beq.n	8009088 <HAL_DMA_DeInit+0x434>
 8008fd2:	687b      	ldr	r3, [r7, #4]
 8008fd4:	681b      	ldr	r3, [r3, #0]
 8008fd6:	4619      	mov	r1, r3
 8008fd8:	4b6b      	ldr	r3, [pc, #428]	; (8009188 <HAL_DMA_DeInit+0x534>)
 8008fda:	4299      	cmp	r1, r3
 8008fdc:	d052      	beq.n	8009084 <HAL_DMA_DeInit+0x430>
 8008fde:	687b      	ldr	r3, [r7, #4]
 8008fe0:	681b      	ldr	r3, [r3, #0]
 8008fe2:	4619      	mov	r1, r3
 8008fe4:	4b69      	ldr	r3, [pc, #420]	; (800918c <HAL_DMA_DeInit+0x538>)
 8008fe6:	4299      	cmp	r1, r3
 8008fe8:	d04a      	beq.n	8009080 <HAL_DMA_DeInit+0x42c>
 8008fea:	687b      	ldr	r3, [r7, #4]
 8008fec:	681b      	ldr	r3, [r3, #0]
 8008fee:	4619      	mov	r1, r3
 8008ff0:	4b67      	ldr	r3, [pc, #412]	; (8009190 <HAL_DMA_DeInit+0x53c>)
 8008ff2:	4299      	cmp	r1, r3
 8008ff4:	d041      	beq.n	800907a <HAL_DMA_DeInit+0x426>
 8008ff6:	687b      	ldr	r3, [r7, #4]
 8008ff8:	681b      	ldr	r3, [r3, #0]
 8008ffa:	4619      	mov	r1, r3
 8008ffc:	4b65      	ldr	r3, [pc, #404]	; (8009194 <HAL_DMA_DeInit+0x540>)
 8008ffe:	4299      	cmp	r1, r3
 8009000:	d038      	beq.n	8009074 <HAL_DMA_DeInit+0x420>
 8009002:	687b      	ldr	r3, [r7, #4]
 8009004:	681b      	ldr	r3, [r3, #0]
 8009006:	4619      	mov	r1, r3
 8009008:	4b63      	ldr	r3, [pc, #396]	; (8009198 <HAL_DMA_DeInit+0x544>)
 800900a:	4299      	cmp	r1, r3
 800900c:	d02f      	beq.n	800906e <HAL_DMA_DeInit+0x41a>
 800900e:	687b      	ldr	r3, [r7, #4]
 8009010:	681b      	ldr	r3, [r3, #0]
 8009012:	4619      	mov	r1, r3
 8009014:	4b61      	ldr	r3, [pc, #388]	; (800919c <HAL_DMA_DeInit+0x548>)
 8009016:	4299      	cmp	r1, r3
 8009018:	d026      	beq.n	8009068 <HAL_DMA_DeInit+0x414>
 800901a:	687b      	ldr	r3, [r7, #4]
 800901c:	681b      	ldr	r3, [r3, #0]
 800901e:	4619      	mov	r1, r3
 8009020:	4b5f      	ldr	r3, [pc, #380]	; (80091a0 <HAL_DMA_DeInit+0x54c>)
 8009022:	4299      	cmp	r1, r3
 8009024:	d01d      	beq.n	8009062 <HAL_DMA_DeInit+0x40e>
 8009026:	687b      	ldr	r3, [r7, #4]
 8009028:	681b      	ldr	r3, [r3, #0]
 800902a:	4619      	mov	r1, r3
 800902c:	4b5d      	ldr	r3, [pc, #372]	; (80091a4 <HAL_DMA_DeInit+0x550>)
 800902e:	4299      	cmp	r1, r3
 8009030:	d014      	beq.n	800905c <HAL_DMA_DeInit+0x408>
 8009032:	687b      	ldr	r3, [r7, #4]
 8009034:	681b      	ldr	r3, [r3, #0]
 8009036:	4619      	mov	r1, r3
 8009038:	4b5b      	ldr	r3, [pc, #364]	; (80091a8 <HAL_DMA_DeInit+0x554>)
 800903a:	4299      	cmp	r1, r3
 800903c:	d00b      	beq.n	8009056 <HAL_DMA_DeInit+0x402>
 800903e:	687b      	ldr	r3, [r7, #4]
 8009040:	681b      	ldr	r3, [r3, #0]
 8009042:	4619      	mov	r1, r3
 8009044:	4b59      	ldr	r3, [pc, #356]	; (80091ac <HAL_DMA_DeInit+0x558>)
 8009046:	4299      	cmp	r1, r3
 8009048:	d102      	bne.n	8009050 <HAL_DMA_DeInit+0x3fc>
 800904a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800904e:	e01e      	b.n	800908e <HAL_DMA_DeInit+0x43a>
 8009050:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8009054:	e01b      	b.n	800908e <HAL_DMA_DeInit+0x43a>
 8009056:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800905a:	e018      	b.n	800908e <HAL_DMA_DeInit+0x43a>
 800905c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8009060:	e015      	b.n	800908e <HAL_DMA_DeInit+0x43a>
 8009062:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8009066:	e012      	b.n	800908e <HAL_DMA_DeInit+0x43a>
 8009068:	f44f 7380 	mov.w	r3, #256	; 0x100
 800906c:	e00f      	b.n	800908e <HAL_DMA_DeInit+0x43a>
 800906e:	f44f 7380 	mov.w	r3, #256	; 0x100
 8009072:	e00c      	b.n	800908e <HAL_DMA_DeInit+0x43a>
 8009074:	f44f 7380 	mov.w	r3, #256	; 0x100
 8009078:	e009      	b.n	800908e <HAL_DMA_DeInit+0x43a>
 800907a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800907e:	e006      	b.n	800908e <HAL_DMA_DeInit+0x43a>
 8009080:	4b3d      	ldr	r3, [pc, #244]	; (8009178 <HAL_DMA_DeInit+0x524>)
 8009082:	e004      	b.n	800908e <HAL_DMA_DeInit+0x43a>
 8009084:	4b3c      	ldr	r3, [pc, #240]	; (8009178 <HAL_DMA_DeInit+0x524>)
 8009086:	e002      	b.n	800908e <HAL_DMA_DeInit+0x43a>
 8009088:	4b3b      	ldr	r3, [pc, #236]	; (8009178 <HAL_DMA_DeInit+0x524>)
 800908a:	e000      	b.n	800908e <HAL_DMA_DeInit+0x43a>
 800908c:	4b3a      	ldr	r3, [pc, #232]	; (8009178 <HAL_DMA_DeInit+0x524>)
 800908e:	6093      	str	r3, [r2, #8]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8009090:	687b      	ldr	r3, [r7, #4]
 8009092:	681b      	ldr	r3, [r3, #0]
 8009094:	461a      	mov	r2, r3
 8009096:	4b46      	ldr	r3, [pc, #280]	; (80091b0 <HAL_DMA_DeInit+0x55c>)
 8009098:	429a      	cmp	r2, r3
 800909a:	f240 808d 	bls.w	80091b8 <HAL_DMA_DeInit+0x564>
 800909e:	4a45      	ldr	r2, [pc, #276]	; (80091b4 <HAL_DMA_DeInit+0x560>)
 80090a0:	687b      	ldr	r3, [r7, #4]
 80090a2:	681b      	ldr	r3, [r3, #0]
 80090a4:	4619      	mov	r1, r3
 80090a6:	4b36      	ldr	r3, [pc, #216]	; (8009180 <HAL_DMA_DeInit+0x52c>)
 80090a8:	4299      	cmp	r1, r3
 80090aa:	d062      	beq.n	8009172 <HAL_DMA_DeInit+0x51e>
 80090ac:	687b      	ldr	r3, [r7, #4]
 80090ae:	681b      	ldr	r3, [r3, #0]
 80090b0:	4619      	mov	r1, r3
 80090b2:	4b34      	ldr	r3, [pc, #208]	; (8009184 <HAL_DMA_DeInit+0x530>)
 80090b4:	4299      	cmp	r1, r3
 80090b6:	d05a      	beq.n	800916e <HAL_DMA_DeInit+0x51a>
 80090b8:	687b      	ldr	r3, [r7, #4]
 80090ba:	681b      	ldr	r3, [r3, #0]
 80090bc:	4619      	mov	r1, r3
 80090be:	4b32      	ldr	r3, [pc, #200]	; (8009188 <HAL_DMA_DeInit+0x534>)
 80090c0:	4299      	cmp	r1, r3
 80090c2:	d052      	beq.n	800916a <HAL_DMA_DeInit+0x516>
 80090c4:	687b      	ldr	r3, [r7, #4]
 80090c6:	681b      	ldr	r3, [r3, #0]
 80090c8:	4619      	mov	r1, r3
 80090ca:	4b30      	ldr	r3, [pc, #192]	; (800918c <HAL_DMA_DeInit+0x538>)
 80090cc:	4299      	cmp	r1, r3
 80090ce:	d04a      	beq.n	8009166 <HAL_DMA_DeInit+0x512>
 80090d0:	687b      	ldr	r3, [r7, #4]
 80090d2:	681b      	ldr	r3, [r3, #0]
 80090d4:	4619      	mov	r1, r3
 80090d6:	4b2e      	ldr	r3, [pc, #184]	; (8009190 <HAL_DMA_DeInit+0x53c>)
 80090d8:	4299      	cmp	r1, r3
 80090da:	d041      	beq.n	8009160 <HAL_DMA_DeInit+0x50c>
 80090dc:	687b      	ldr	r3, [r7, #4]
 80090de:	681b      	ldr	r3, [r3, #0]
 80090e0:	4619      	mov	r1, r3
 80090e2:	4b2c      	ldr	r3, [pc, #176]	; (8009194 <HAL_DMA_DeInit+0x540>)
 80090e4:	4299      	cmp	r1, r3
 80090e6:	d038      	beq.n	800915a <HAL_DMA_DeInit+0x506>
 80090e8:	687b      	ldr	r3, [r7, #4]
 80090ea:	681b      	ldr	r3, [r3, #0]
 80090ec:	4619      	mov	r1, r3
 80090ee:	4b2a      	ldr	r3, [pc, #168]	; (8009198 <HAL_DMA_DeInit+0x544>)
 80090f0:	4299      	cmp	r1, r3
 80090f2:	d02f      	beq.n	8009154 <HAL_DMA_DeInit+0x500>
 80090f4:	687b      	ldr	r3, [r7, #4]
 80090f6:	681b      	ldr	r3, [r3, #0]
 80090f8:	4619      	mov	r1, r3
 80090fa:	4b28      	ldr	r3, [pc, #160]	; (800919c <HAL_DMA_DeInit+0x548>)
 80090fc:	4299      	cmp	r1, r3
 80090fe:	d026      	beq.n	800914e <HAL_DMA_DeInit+0x4fa>
 8009100:	687b      	ldr	r3, [r7, #4]
 8009102:	681b      	ldr	r3, [r3, #0]
 8009104:	4619      	mov	r1, r3
 8009106:	4b26      	ldr	r3, [pc, #152]	; (80091a0 <HAL_DMA_DeInit+0x54c>)
 8009108:	4299      	cmp	r1, r3
 800910a:	d01d      	beq.n	8009148 <HAL_DMA_DeInit+0x4f4>
 800910c:	687b      	ldr	r3, [r7, #4]
 800910e:	681b      	ldr	r3, [r3, #0]
 8009110:	4619      	mov	r1, r3
 8009112:	4b24      	ldr	r3, [pc, #144]	; (80091a4 <HAL_DMA_DeInit+0x550>)
 8009114:	4299      	cmp	r1, r3
 8009116:	d014      	beq.n	8009142 <HAL_DMA_DeInit+0x4ee>
 8009118:	687b      	ldr	r3, [r7, #4]
 800911a:	681b      	ldr	r3, [r3, #0]
 800911c:	4619      	mov	r1, r3
 800911e:	4b22      	ldr	r3, [pc, #136]	; (80091a8 <HAL_DMA_DeInit+0x554>)
 8009120:	4299      	cmp	r1, r3
 8009122:	d00b      	beq.n	800913c <HAL_DMA_DeInit+0x4e8>
 8009124:	687b      	ldr	r3, [r7, #4]
 8009126:	681b      	ldr	r3, [r3, #0]
 8009128:	4619      	mov	r1, r3
 800912a:	4b20      	ldr	r3, [pc, #128]	; (80091ac <HAL_DMA_DeInit+0x558>)
 800912c:	4299      	cmp	r1, r3
 800912e:	d102      	bne.n	8009136 <HAL_DMA_DeInit+0x4e2>
 8009130:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8009134:	e01e      	b.n	8009174 <HAL_DMA_DeInit+0x520>
 8009136:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800913a:	e01b      	b.n	8009174 <HAL_DMA_DeInit+0x520>
 800913c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8009140:	e018      	b.n	8009174 <HAL_DMA_DeInit+0x520>
 8009142:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8009146:	e015      	b.n	8009174 <HAL_DMA_DeInit+0x520>
 8009148:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800914c:	e012      	b.n	8009174 <HAL_DMA_DeInit+0x520>
 800914e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8009152:	e00f      	b.n	8009174 <HAL_DMA_DeInit+0x520>
 8009154:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8009158:	e00c      	b.n	8009174 <HAL_DMA_DeInit+0x520>
 800915a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800915e:	e009      	b.n	8009174 <HAL_DMA_DeInit+0x520>
 8009160:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8009164:	e006      	b.n	8009174 <HAL_DMA_DeInit+0x520>
 8009166:	2320      	movs	r3, #32
 8009168:	e004      	b.n	8009174 <HAL_DMA_DeInit+0x520>
 800916a:	2320      	movs	r3, #32
 800916c:	e002      	b.n	8009174 <HAL_DMA_DeInit+0x520>
 800916e:	2320      	movs	r3, #32
 8009170:	e000      	b.n	8009174 <HAL_DMA_DeInit+0x520>
 8009172:	2320      	movs	r3, #32
 8009174:	60d3      	str	r3, [r2, #12]
 8009176:	e192      	b.n	800949e <HAL_DMA_DeInit+0x84a>
 8009178:	00800004 	.word	0x00800004
 800917c:	40026000 	.word	0x40026000
 8009180:	40026010 	.word	0x40026010
 8009184:	40026410 	.word	0x40026410
 8009188:	40026070 	.word	0x40026070
 800918c:	40026470 	.word	0x40026470
 8009190:	40026028 	.word	0x40026028
 8009194:	40026428 	.word	0x40026428
 8009198:	40026088 	.word	0x40026088
 800919c:	40026488 	.word	0x40026488
 80091a0:	40026040 	.word	0x40026040
 80091a4:	40026440 	.word	0x40026440
 80091a8:	400260a0 	.word	0x400260a0
 80091ac:	400264a0 	.word	0x400264a0
 80091b0:	40026458 	.word	0x40026458
 80091b4:	40026400 	.word	0x40026400
 80091b8:	687b      	ldr	r3, [r7, #4]
 80091ba:	681b      	ldr	r3, [r3, #0]
 80091bc:	461a      	mov	r2, r3
 80091be:	4b9f      	ldr	r3, [pc, #636]	; (800943c <HAL_DMA_DeInit+0x7e8>)
 80091c0:	429a      	cmp	r2, r3
 80091c2:	d96c      	bls.n	800929e <HAL_DMA_DeInit+0x64a>
 80091c4:	4a9e      	ldr	r2, [pc, #632]	; (8009440 <HAL_DMA_DeInit+0x7ec>)
 80091c6:	687b      	ldr	r3, [r7, #4]
 80091c8:	681b      	ldr	r3, [r3, #0]
 80091ca:	4619      	mov	r1, r3
 80091cc:	4b9d      	ldr	r3, [pc, #628]	; (8009444 <HAL_DMA_DeInit+0x7f0>)
 80091ce:	4299      	cmp	r1, r3
 80091d0:	d062      	beq.n	8009298 <HAL_DMA_DeInit+0x644>
 80091d2:	687b      	ldr	r3, [r7, #4]
 80091d4:	681b      	ldr	r3, [r3, #0]
 80091d6:	4619      	mov	r1, r3
 80091d8:	4b9b      	ldr	r3, [pc, #620]	; (8009448 <HAL_DMA_DeInit+0x7f4>)
 80091da:	4299      	cmp	r1, r3
 80091dc:	d05a      	beq.n	8009294 <HAL_DMA_DeInit+0x640>
 80091de:	687b      	ldr	r3, [r7, #4]
 80091e0:	681b      	ldr	r3, [r3, #0]
 80091e2:	4619      	mov	r1, r3
 80091e4:	4b99      	ldr	r3, [pc, #612]	; (800944c <HAL_DMA_DeInit+0x7f8>)
 80091e6:	4299      	cmp	r1, r3
 80091e8:	d052      	beq.n	8009290 <HAL_DMA_DeInit+0x63c>
 80091ea:	687b      	ldr	r3, [r7, #4]
 80091ec:	681b      	ldr	r3, [r3, #0]
 80091ee:	4619      	mov	r1, r3
 80091f0:	4b97      	ldr	r3, [pc, #604]	; (8009450 <HAL_DMA_DeInit+0x7fc>)
 80091f2:	4299      	cmp	r1, r3
 80091f4:	d04a      	beq.n	800928c <HAL_DMA_DeInit+0x638>
 80091f6:	687b      	ldr	r3, [r7, #4]
 80091f8:	681b      	ldr	r3, [r3, #0]
 80091fa:	4619      	mov	r1, r3
 80091fc:	4b95      	ldr	r3, [pc, #596]	; (8009454 <HAL_DMA_DeInit+0x800>)
 80091fe:	4299      	cmp	r1, r3
 8009200:	d041      	beq.n	8009286 <HAL_DMA_DeInit+0x632>
 8009202:	687b      	ldr	r3, [r7, #4]
 8009204:	681b      	ldr	r3, [r3, #0]
 8009206:	4619      	mov	r1, r3
 8009208:	4b93      	ldr	r3, [pc, #588]	; (8009458 <HAL_DMA_DeInit+0x804>)
 800920a:	4299      	cmp	r1, r3
 800920c:	d038      	beq.n	8009280 <HAL_DMA_DeInit+0x62c>
 800920e:	687b      	ldr	r3, [r7, #4]
 8009210:	681b      	ldr	r3, [r3, #0]
 8009212:	4619      	mov	r1, r3
 8009214:	4b91      	ldr	r3, [pc, #580]	; (800945c <HAL_DMA_DeInit+0x808>)
 8009216:	4299      	cmp	r1, r3
 8009218:	d02f      	beq.n	800927a <HAL_DMA_DeInit+0x626>
 800921a:	687b      	ldr	r3, [r7, #4]
 800921c:	681b      	ldr	r3, [r3, #0]
 800921e:	4619      	mov	r1, r3
 8009220:	4b8f      	ldr	r3, [pc, #572]	; (8009460 <HAL_DMA_DeInit+0x80c>)
 8009222:	4299      	cmp	r1, r3
 8009224:	d026      	beq.n	8009274 <HAL_DMA_DeInit+0x620>
 8009226:	687b      	ldr	r3, [r7, #4]
 8009228:	681b      	ldr	r3, [r3, #0]
 800922a:	4619      	mov	r1, r3
 800922c:	4b8d      	ldr	r3, [pc, #564]	; (8009464 <HAL_DMA_DeInit+0x810>)
 800922e:	4299      	cmp	r1, r3
 8009230:	d01d      	beq.n	800926e <HAL_DMA_DeInit+0x61a>
 8009232:	687b      	ldr	r3, [r7, #4]
 8009234:	681b      	ldr	r3, [r3, #0]
 8009236:	4619      	mov	r1, r3
 8009238:	4b8b      	ldr	r3, [pc, #556]	; (8009468 <HAL_DMA_DeInit+0x814>)
 800923a:	4299      	cmp	r1, r3
 800923c:	d014      	beq.n	8009268 <HAL_DMA_DeInit+0x614>
 800923e:	687b      	ldr	r3, [r7, #4]
 8009240:	681b      	ldr	r3, [r3, #0]
 8009242:	4619      	mov	r1, r3
 8009244:	4b89      	ldr	r3, [pc, #548]	; (800946c <HAL_DMA_DeInit+0x818>)
 8009246:	4299      	cmp	r1, r3
 8009248:	d00b      	beq.n	8009262 <HAL_DMA_DeInit+0x60e>
 800924a:	687b      	ldr	r3, [r7, #4]
 800924c:	681b      	ldr	r3, [r3, #0]
 800924e:	4619      	mov	r1, r3
 8009250:	4b87      	ldr	r3, [pc, #540]	; (8009470 <HAL_DMA_DeInit+0x81c>)
 8009252:	4299      	cmp	r1, r3
 8009254:	d102      	bne.n	800925c <HAL_DMA_DeInit+0x608>
 8009256:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800925a:	e01e      	b.n	800929a <HAL_DMA_DeInit+0x646>
 800925c:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8009260:	e01b      	b.n	800929a <HAL_DMA_DeInit+0x646>
 8009262:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8009266:	e018      	b.n	800929a <HAL_DMA_DeInit+0x646>
 8009268:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800926c:	e015      	b.n	800929a <HAL_DMA_DeInit+0x646>
 800926e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8009272:	e012      	b.n	800929a <HAL_DMA_DeInit+0x646>
 8009274:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8009278:	e00f      	b.n	800929a <HAL_DMA_DeInit+0x646>
 800927a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800927e:	e00c      	b.n	800929a <HAL_DMA_DeInit+0x646>
 8009280:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8009284:	e009      	b.n	800929a <HAL_DMA_DeInit+0x646>
 8009286:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800928a:	e006      	b.n	800929a <HAL_DMA_DeInit+0x646>
 800928c:	2320      	movs	r3, #32
 800928e:	e004      	b.n	800929a <HAL_DMA_DeInit+0x646>
 8009290:	2320      	movs	r3, #32
 8009292:	e002      	b.n	800929a <HAL_DMA_DeInit+0x646>
 8009294:	2320      	movs	r3, #32
 8009296:	e000      	b.n	800929a <HAL_DMA_DeInit+0x646>
 8009298:	2320      	movs	r3, #32
 800929a:	6093      	str	r3, [r2, #8]
 800929c:	e0ff      	b.n	800949e <HAL_DMA_DeInit+0x84a>
 800929e:	687b      	ldr	r3, [r7, #4]
 80092a0:	681b      	ldr	r3, [r3, #0]
 80092a2:	461a      	mov	r2, r3
 80092a4:	4b73      	ldr	r3, [pc, #460]	; (8009474 <HAL_DMA_DeInit+0x820>)
 80092a6:	429a      	cmp	r2, r3
 80092a8:	d96c      	bls.n	8009384 <HAL_DMA_DeInit+0x730>
 80092aa:	4a73      	ldr	r2, [pc, #460]	; (8009478 <HAL_DMA_DeInit+0x824>)
 80092ac:	687b      	ldr	r3, [r7, #4]
 80092ae:	681b      	ldr	r3, [r3, #0]
 80092b0:	4619      	mov	r1, r3
 80092b2:	4b64      	ldr	r3, [pc, #400]	; (8009444 <HAL_DMA_DeInit+0x7f0>)
 80092b4:	4299      	cmp	r1, r3
 80092b6:	d062      	beq.n	800937e <HAL_DMA_DeInit+0x72a>
 80092b8:	687b      	ldr	r3, [r7, #4]
 80092ba:	681b      	ldr	r3, [r3, #0]
 80092bc:	4619      	mov	r1, r3
 80092be:	4b62      	ldr	r3, [pc, #392]	; (8009448 <HAL_DMA_DeInit+0x7f4>)
 80092c0:	4299      	cmp	r1, r3
 80092c2:	d05a      	beq.n	800937a <HAL_DMA_DeInit+0x726>
 80092c4:	687b      	ldr	r3, [r7, #4]
 80092c6:	681b      	ldr	r3, [r3, #0]
 80092c8:	4619      	mov	r1, r3
 80092ca:	4b60      	ldr	r3, [pc, #384]	; (800944c <HAL_DMA_DeInit+0x7f8>)
 80092cc:	4299      	cmp	r1, r3
 80092ce:	d052      	beq.n	8009376 <HAL_DMA_DeInit+0x722>
 80092d0:	687b      	ldr	r3, [r7, #4]
 80092d2:	681b      	ldr	r3, [r3, #0]
 80092d4:	4619      	mov	r1, r3
 80092d6:	4b5e      	ldr	r3, [pc, #376]	; (8009450 <HAL_DMA_DeInit+0x7fc>)
 80092d8:	4299      	cmp	r1, r3
 80092da:	d04a      	beq.n	8009372 <HAL_DMA_DeInit+0x71e>
 80092dc:	687b      	ldr	r3, [r7, #4]
 80092de:	681b      	ldr	r3, [r3, #0]
 80092e0:	4619      	mov	r1, r3
 80092e2:	4b5c      	ldr	r3, [pc, #368]	; (8009454 <HAL_DMA_DeInit+0x800>)
 80092e4:	4299      	cmp	r1, r3
 80092e6:	d041      	beq.n	800936c <HAL_DMA_DeInit+0x718>
 80092e8:	687b      	ldr	r3, [r7, #4]
 80092ea:	681b      	ldr	r3, [r3, #0]
 80092ec:	4619      	mov	r1, r3
 80092ee:	4b5a      	ldr	r3, [pc, #360]	; (8009458 <HAL_DMA_DeInit+0x804>)
 80092f0:	4299      	cmp	r1, r3
 80092f2:	d038      	beq.n	8009366 <HAL_DMA_DeInit+0x712>
 80092f4:	687b      	ldr	r3, [r7, #4]
 80092f6:	681b      	ldr	r3, [r3, #0]
 80092f8:	4619      	mov	r1, r3
 80092fa:	4b58      	ldr	r3, [pc, #352]	; (800945c <HAL_DMA_DeInit+0x808>)
 80092fc:	4299      	cmp	r1, r3
 80092fe:	d02f      	beq.n	8009360 <HAL_DMA_DeInit+0x70c>
 8009300:	687b      	ldr	r3, [r7, #4]
 8009302:	681b      	ldr	r3, [r3, #0]
 8009304:	4619      	mov	r1, r3
 8009306:	4b56      	ldr	r3, [pc, #344]	; (8009460 <HAL_DMA_DeInit+0x80c>)
 8009308:	4299      	cmp	r1, r3
 800930a:	d026      	beq.n	800935a <HAL_DMA_DeInit+0x706>
 800930c:	687b      	ldr	r3, [r7, #4]
 800930e:	681b      	ldr	r3, [r3, #0]
 8009310:	4619      	mov	r1, r3
 8009312:	4b54      	ldr	r3, [pc, #336]	; (8009464 <HAL_DMA_DeInit+0x810>)
 8009314:	4299      	cmp	r1, r3
 8009316:	d01d      	beq.n	8009354 <HAL_DMA_DeInit+0x700>
 8009318:	687b      	ldr	r3, [r7, #4]
 800931a:	681b      	ldr	r3, [r3, #0]
 800931c:	4619      	mov	r1, r3
 800931e:	4b52      	ldr	r3, [pc, #328]	; (8009468 <HAL_DMA_DeInit+0x814>)
 8009320:	4299      	cmp	r1, r3
 8009322:	d014      	beq.n	800934e <HAL_DMA_DeInit+0x6fa>
 8009324:	687b      	ldr	r3, [r7, #4]
 8009326:	681b      	ldr	r3, [r3, #0]
 8009328:	4619      	mov	r1, r3
 800932a:	4b50      	ldr	r3, [pc, #320]	; (800946c <HAL_DMA_DeInit+0x818>)
 800932c:	4299      	cmp	r1, r3
 800932e:	d00b      	beq.n	8009348 <HAL_DMA_DeInit+0x6f4>
 8009330:	687b      	ldr	r3, [r7, #4]
 8009332:	681b      	ldr	r3, [r3, #0]
 8009334:	4619      	mov	r1, r3
 8009336:	4b4e      	ldr	r3, [pc, #312]	; (8009470 <HAL_DMA_DeInit+0x81c>)
 8009338:	4299      	cmp	r1, r3
 800933a:	d102      	bne.n	8009342 <HAL_DMA_DeInit+0x6ee>
 800933c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8009340:	e01e      	b.n	8009380 <HAL_DMA_DeInit+0x72c>
 8009342:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8009346:	e01b      	b.n	8009380 <HAL_DMA_DeInit+0x72c>
 8009348:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800934c:	e018      	b.n	8009380 <HAL_DMA_DeInit+0x72c>
 800934e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8009352:	e015      	b.n	8009380 <HAL_DMA_DeInit+0x72c>
 8009354:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8009358:	e012      	b.n	8009380 <HAL_DMA_DeInit+0x72c>
 800935a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800935e:	e00f      	b.n	8009380 <HAL_DMA_DeInit+0x72c>
 8009360:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8009364:	e00c      	b.n	8009380 <HAL_DMA_DeInit+0x72c>
 8009366:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800936a:	e009      	b.n	8009380 <HAL_DMA_DeInit+0x72c>
 800936c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8009370:	e006      	b.n	8009380 <HAL_DMA_DeInit+0x72c>
 8009372:	2320      	movs	r3, #32
 8009374:	e004      	b.n	8009380 <HAL_DMA_DeInit+0x72c>
 8009376:	2320      	movs	r3, #32
 8009378:	e002      	b.n	8009380 <HAL_DMA_DeInit+0x72c>
 800937a:	2320      	movs	r3, #32
 800937c:	e000      	b.n	8009380 <HAL_DMA_DeInit+0x72c>
 800937e:	2320      	movs	r3, #32
 8009380:	60d3      	str	r3, [r2, #12]
 8009382:	e08c      	b.n	800949e <HAL_DMA_DeInit+0x84a>
 8009384:	4a3c      	ldr	r2, [pc, #240]	; (8009478 <HAL_DMA_DeInit+0x824>)
 8009386:	687b      	ldr	r3, [r7, #4]
 8009388:	681b      	ldr	r3, [r3, #0]
 800938a:	4619      	mov	r1, r3
 800938c:	4b2d      	ldr	r3, [pc, #180]	; (8009444 <HAL_DMA_DeInit+0x7f0>)
 800938e:	4299      	cmp	r1, r3
 8009390:	f000 8083 	beq.w	800949a <HAL_DMA_DeInit+0x846>
 8009394:	687b      	ldr	r3, [r7, #4]
 8009396:	681b      	ldr	r3, [r3, #0]
 8009398:	4619      	mov	r1, r3
 800939a:	4b2b      	ldr	r3, [pc, #172]	; (8009448 <HAL_DMA_DeInit+0x7f4>)
 800939c:	4299      	cmp	r1, r3
 800939e:	d07a      	beq.n	8009496 <HAL_DMA_DeInit+0x842>
 80093a0:	687b      	ldr	r3, [r7, #4]
 80093a2:	681b      	ldr	r3, [r3, #0]
 80093a4:	4619      	mov	r1, r3
 80093a6:	4b29      	ldr	r3, [pc, #164]	; (800944c <HAL_DMA_DeInit+0x7f8>)
 80093a8:	4299      	cmp	r1, r3
 80093aa:	d072      	beq.n	8009492 <HAL_DMA_DeInit+0x83e>
 80093ac:	687b      	ldr	r3, [r7, #4]
 80093ae:	681b      	ldr	r3, [r3, #0]
 80093b0:	4619      	mov	r1, r3
 80093b2:	4b27      	ldr	r3, [pc, #156]	; (8009450 <HAL_DMA_DeInit+0x7fc>)
 80093b4:	4299      	cmp	r1, r3
 80093b6:	d06a      	beq.n	800948e <HAL_DMA_DeInit+0x83a>
 80093b8:	687b      	ldr	r3, [r7, #4]
 80093ba:	681b      	ldr	r3, [r3, #0]
 80093bc:	4619      	mov	r1, r3
 80093be:	4b25      	ldr	r3, [pc, #148]	; (8009454 <HAL_DMA_DeInit+0x800>)
 80093c0:	4299      	cmp	r1, r3
 80093c2:	d061      	beq.n	8009488 <HAL_DMA_DeInit+0x834>
 80093c4:	687b      	ldr	r3, [r7, #4]
 80093c6:	681b      	ldr	r3, [r3, #0]
 80093c8:	4619      	mov	r1, r3
 80093ca:	4b23      	ldr	r3, [pc, #140]	; (8009458 <HAL_DMA_DeInit+0x804>)
 80093cc:	4299      	cmp	r1, r3
 80093ce:	d058      	beq.n	8009482 <HAL_DMA_DeInit+0x82e>
 80093d0:	687b      	ldr	r3, [r7, #4]
 80093d2:	681b      	ldr	r3, [r3, #0]
 80093d4:	4619      	mov	r1, r3
 80093d6:	4b21      	ldr	r3, [pc, #132]	; (800945c <HAL_DMA_DeInit+0x808>)
 80093d8:	4299      	cmp	r1, r3
 80093da:	d04f      	beq.n	800947c <HAL_DMA_DeInit+0x828>
 80093dc:	687b      	ldr	r3, [r7, #4]
 80093de:	681b      	ldr	r3, [r3, #0]
 80093e0:	4619      	mov	r1, r3
 80093e2:	4b1f      	ldr	r3, [pc, #124]	; (8009460 <HAL_DMA_DeInit+0x80c>)
 80093e4:	4299      	cmp	r1, r3
 80093e6:	d026      	beq.n	8009436 <HAL_DMA_DeInit+0x7e2>
 80093e8:	687b      	ldr	r3, [r7, #4]
 80093ea:	681b      	ldr	r3, [r3, #0]
 80093ec:	4619      	mov	r1, r3
 80093ee:	4b1d      	ldr	r3, [pc, #116]	; (8009464 <HAL_DMA_DeInit+0x810>)
 80093f0:	4299      	cmp	r1, r3
 80093f2:	d01d      	beq.n	8009430 <HAL_DMA_DeInit+0x7dc>
 80093f4:	687b      	ldr	r3, [r7, #4]
 80093f6:	681b      	ldr	r3, [r3, #0]
 80093f8:	4619      	mov	r1, r3
 80093fa:	4b1b      	ldr	r3, [pc, #108]	; (8009468 <HAL_DMA_DeInit+0x814>)
 80093fc:	4299      	cmp	r1, r3
 80093fe:	d014      	beq.n	800942a <HAL_DMA_DeInit+0x7d6>
 8009400:	687b      	ldr	r3, [r7, #4]
 8009402:	681b      	ldr	r3, [r3, #0]
 8009404:	4619      	mov	r1, r3
 8009406:	4b19      	ldr	r3, [pc, #100]	; (800946c <HAL_DMA_DeInit+0x818>)
 8009408:	4299      	cmp	r1, r3
 800940a:	d00b      	beq.n	8009424 <HAL_DMA_DeInit+0x7d0>
 800940c:	687b      	ldr	r3, [r7, #4]
 800940e:	681b      	ldr	r3, [r3, #0]
 8009410:	4619      	mov	r1, r3
 8009412:	4b17      	ldr	r3, [pc, #92]	; (8009470 <HAL_DMA_DeInit+0x81c>)
 8009414:	4299      	cmp	r1, r3
 8009416:	d102      	bne.n	800941e <HAL_DMA_DeInit+0x7ca>
 8009418:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800941c:	e03e      	b.n	800949c <HAL_DMA_DeInit+0x848>
 800941e:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8009422:	e03b      	b.n	800949c <HAL_DMA_DeInit+0x848>
 8009424:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8009428:	e038      	b.n	800949c <HAL_DMA_DeInit+0x848>
 800942a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800942e:	e035      	b.n	800949c <HAL_DMA_DeInit+0x848>
 8009430:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8009434:	e032      	b.n	800949c <HAL_DMA_DeInit+0x848>
 8009436:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800943a:	e02f      	b.n	800949c <HAL_DMA_DeInit+0x848>
 800943c:	400260b8 	.word	0x400260b8
 8009440:	40026400 	.word	0x40026400
 8009444:	40026010 	.word	0x40026010
 8009448:	40026410 	.word	0x40026410
 800944c:	40026070 	.word	0x40026070
 8009450:	40026470 	.word	0x40026470
 8009454:	40026028 	.word	0x40026028
 8009458:	40026428 	.word	0x40026428
 800945c:	40026088 	.word	0x40026088
 8009460:	40026488 	.word	0x40026488
 8009464:	40026040 	.word	0x40026040
 8009468:	40026440 	.word	0x40026440
 800946c:	400260a0 	.word	0x400260a0
 8009470:	400264a0 	.word	0x400264a0
 8009474:	40026058 	.word	0x40026058
 8009478:	40026000 	.word	0x40026000
 800947c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8009480:	e00c      	b.n	800949c <HAL_DMA_DeInit+0x848>
 8009482:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8009486:	e009      	b.n	800949c <HAL_DMA_DeInit+0x848>
 8009488:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800948c:	e006      	b.n	800949c <HAL_DMA_DeInit+0x848>
 800948e:	2320      	movs	r3, #32
 8009490:	e004      	b.n	800949c <HAL_DMA_DeInit+0x848>
 8009492:	2320      	movs	r3, #32
 8009494:	e002      	b.n	800949c <HAL_DMA_DeInit+0x848>
 8009496:	2320      	movs	r3, #32
 8009498:	e000      	b.n	800949c <HAL_DMA_DeInit+0x848>
 800949a:	2320      	movs	r3, #32
 800949c:	6093      	str	r3, [r2, #8]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 800949e:	687b      	ldr	r3, [r7, #4]
 80094a0:	681b      	ldr	r3, [r3, #0]
 80094a2:	461a      	mov	r2, r3
 80094a4:	4b9f      	ldr	r3, [pc, #636]	; (8009724 <HAL_DMA_DeInit+0xad0>)
 80094a6:	429a      	cmp	r2, r3
 80094a8:	d96c      	bls.n	8009584 <HAL_DMA_DeInit+0x930>
 80094aa:	4a9f      	ldr	r2, [pc, #636]	; (8009728 <HAL_DMA_DeInit+0xad4>)
 80094ac:	687b      	ldr	r3, [r7, #4]
 80094ae:	681b      	ldr	r3, [r3, #0]
 80094b0:	4619      	mov	r1, r3
 80094b2:	4b9e      	ldr	r3, [pc, #632]	; (800972c <HAL_DMA_DeInit+0xad8>)
 80094b4:	4299      	cmp	r1, r3
 80094b6:	d062      	beq.n	800957e <HAL_DMA_DeInit+0x92a>
 80094b8:	687b      	ldr	r3, [r7, #4]
 80094ba:	681b      	ldr	r3, [r3, #0]
 80094bc:	4619      	mov	r1, r3
 80094be:	4b9c      	ldr	r3, [pc, #624]	; (8009730 <HAL_DMA_DeInit+0xadc>)
 80094c0:	4299      	cmp	r1, r3
 80094c2:	d05a      	beq.n	800957a <HAL_DMA_DeInit+0x926>
 80094c4:	687b      	ldr	r3, [r7, #4]
 80094c6:	681b      	ldr	r3, [r3, #0]
 80094c8:	4619      	mov	r1, r3
 80094ca:	4b9a      	ldr	r3, [pc, #616]	; (8009734 <HAL_DMA_DeInit+0xae0>)
 80094cc:	4299      	cmp	r1, r3
 80094ce:	d052      	beq.n	8009576 <HAL_DMA_DeInit+0x922>
 80094d0:	687b      	ldr	r3, [r7, #4]
 80094d2:	681b      	ldr	r3, [r3, #0]
 80094d4:	4619      	mov	r1, r3
 80094d6:	4b98      	ldr	r3, [pc, #608]	; (8009738 <HAL_DMA_DeInit+0xae4>)
 80094d8:	4299      	cmp	r1, r3
 80094da:	d04a      	beq.n	8009572 <HAL_DMA_DeInit+0x91e>
 80094dc:	687b      	ldr	r3, [r7, #4]
 80094de:	681b      	ldr	r3, [r3, #0]
 80094e0:	4619      	mov	r1, r3
 80094e2:	4b96      	ldr	r3, [pc, #600]	; (800973c <HAL_DMA_DeInit+0xae8>)
 80094e4:	4299      	cmp	r1, r3
 80094e6:	d041      	beq.n	800956c <HAL_DMA_DeInit+0x918>
 80094e8:	687b      	ldr	r3, [r7, #4]
 80094ea:	681b      	ldr	r3, [r3, #0]
 80094ec:	4619      	mov	r1, r3
 80094ee:	4b94      	ldr	r3, [pc, #592]	; (8009740 <HAL_DMA_DeInit+0xaec>)
 80094f0:	4299      	cmp	r1, r3
 80094f2:	d038      	beq.n	8009566 <HAL_DMA_DeInit+0x912>
 80094f4:	687b      	ldr	r3, [r7, #4]
 80094f6:	681b      	ldr	r3, [r3, #0]
 80094f8:	4619      	mov	r1, r3
 80094fa:	4b92      	ldr	r3, [pc, #584]	; (8009744 <HAL_DMA_DeInit+0xaf0>)
 80094fc:	4299      	cmp	r1, r3
 80094fe:	d02f      	beq.n	8009560 <HAL_DMA_DeInit+0x90c>
 8009500:	687b      	ldr	r3, [r7, #4]
 8009502:	681b      	ldr	r3, [r3, #0]
 8009504:	4619      	mov	r1, r3
 8009506:	4b90      	ldr	r3, [pc, #576]	; (8009748 <HAL_DMA_DeInit+0xaf4>)
 8009508:	4299      	cmp	r1, r3
 800950a:	d026      	beq.n	800955a <HAL_DMA_DeInit+0x906>
 800950c:	687b      	ldr	r3, [r7, #4]
 800950e:	681b      	ldr	r3, [r3, #0]
 8009510:	4619      	mov	r1, r3
 8009512:	4b8e      	ldr	r3, [pc, #568]	; (800974c <HAL_DMA_DeInit+0xaf8>)
 8009514:	4299      	cmp	r1, r3
 8009516:	d01d      	beq.n	8009554 <HAL_DMA_DeInit+0x900>
 8009518:	687b      	ldr	r3, [r7, #4]
 800951a:	681b      	ldr	r3, [r3, #0]
 800951c:	4619      	mov	r1, r3
 800951e:	4b8c      	ldr	r3, [pc, #560]	; (8009750 <HAL_DMA_DeInit+0xafc>)
 8009520:	4299      	cmp	r1, r3
 8009522:	d014      	beq.n	800954e <HAL_DMA_DeInit+0x8fa>
 8009524:	687b      	ldr	r3, [r7, #4]
 8009526:	681b      	ldr	r3, [r3, #0]
 8009528:	4619      	mov	r1, r3
 800952a:	4b8a      	ldr	r3, [pc, #552]	; (8009754 <HAL_DMA_DeInit+0xb00>)
 800952c:	4299      	cmp	r1, r3
 800952e:	d00b      	beq.n	8009548 <HAL_DMA_DeInit+0x8f4>
 8009530:	687b      	ldr	r3, [r7, #4]
 8009532:	681b      	ldr	r3, [r3, #0]
 8009534:	4619      	mov	r1, r3
 8009536:	4b88      	ldr	r3, [pc, #544]	; (8009758 <HAL_DMA_DeInit+0xb04>)
 8009538:	4299      	cmp	r1, r3
 800953a:	d102      	bne.n	8009542 <HAL_DMA_DeInit+0x8ee>
 800953c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009540:	e01e      	b.n	8009580 <HAL_DMA_DeInit+0x92c>
 8009542:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8009546:	e01b      	b.n	8009580 <HAL_DMA_DeInit+0x92c>
 8009548:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800954c:	e018      	b.n	8009580 <HAL_DMA_DeInit+0x92c>
 800954e:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009552:	e015      	b.n	8009580 <HAL_DMA_DeInit+0x92c>
 8009554:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009558:	e012      	b.n	8009580 <HAL_DMA_DeInit+0x92c>
 800955a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800955e:	e00f      	b.n	8009580 <HAL_DMA_DeInit+0x92c>
 8009560:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009564:	e00c      	b.n	8009580 <HAL_DMA_DeInit+0x92c>
 8009566:	f44f 7300 	mov.w	r3, #512	; 0x200
 800956a:	e009      	b.n	8009580 <HAL_DMA_DeInit+0x92c>
 800956c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009570:	e006      	b.n	8009580 <HAL_DMA_DeInit+0x92c>
 8009572:	2308      	movs	r3, #8
 8009574:	e004      	b.n	8009580 <HAL_DMA_DeInit+0x92c>
 8009576:	2308      	movs	r3, #8
 8009578:	e002      	b.n	8009580 <HAL_DMA_DeInit+0x92c>
 800957a:	2308      	movs	r3, #8
 800957c:	e000      	b.n	8009580 <HAL_DMA_DeInit+0x92c>
 800957e:	2308      	movs	r3, #8
 8009580:	60d3      	str	r3, [r2, #12]
 8009582:	e175      	b.n	8009870 <HAL_DMA_DeInit+0xc1c>
 8009584:	687b      	ldr	r3, [r7, #4]
 8009586:	681b      	ldr	r3, [r3, #0]
 8009588:	461a      	mov	r2, r3
 800958a:	4b74      	ldr	r3, [pc, #464]	; (800975c <HAL_DMA_DeInit+0xb08>)
 800958c:	429a      	cmp	r2, r3
 800958e:	d96c      	bls.n	800966a <HAL_DMA_DeInit+0xa16>
 8009590:	4a65      	ldr	r2, [pc, #404]	; (8009728 <HAL_DMA_DeInit+0xad4>)
 8009592:	687b      	ldr	r3, [r7, #4]
 8009594:	681b      	ldr	r3, [r3, #0]
 8009596:	4619      	mov	r1, r3
 8009598:	4b64      	ldr	r3, [pc, #400]	; (800972c <HAL_DMA_DeInit+0xad8>)
 800959a:	4299      	cmp	r1, r3
 800959c:	d062      	beq.n	8009664 <HAL_DMA_DeInit+0xa10>
 800959e:	687b      	ldr	r3, [r7, #4]
 80095a0:	681b      	ldr	r3, [r3, #0]
 80095a2:	4619      	mov	r1, r3
 80095a4:	4b62      	ldr	r3, [pc, #392]	; (8009730 <HAL_DMA_DeInit+0xadc>)
 80095a6:	4299      	cmp	r1, r3
 80095a8:	d05a      	beq.n	8009660 <HAL_DMA_DeInit+0xa0c>
 80095aa:	687b      	ldr	r3, [r7, #4]
 80095ac:	681b      	ldr	r3, [r3, #0]
 80095ae:	4619      	mov	r1, r3
 80095b0:	4b60      	ldr	r3, [pc, #384]	; (8009734 <HAL_DMA_DeInit+0xae0>)
 80095b2:	4299      	cmp	r1, r3
 80095b4:	d052      	beq.n	800965c <HAL_DMA_DeInit+0xa08>
 80095b6:	687b      	ldr	r3, [r7, #4]
 80095b8:	681b      	ldr	r3, [r3, #0]
 80095ba:	4619      	mov	r1, r3
 80095bc:	4b5e      	ldr	r3, [pc, #376]	; (8009738 <HAL_DMA_DeInit+0xae4>)
 80095be:	4299      	cmp	r1, r3
 80095c0:	d04a      	beq.n	8009658 <HAL_DMA_DeInit+0xa04>
 80095c2:	687b      	ldr	r3, [r7, #4]
 80095c4:	681b      	ldr	r3, [r3, #0]
 80095c6:	4619      	mov	r1, r3
 80095c8:	4b5c      	ldr	r3, [pc, #368]	; (800973c <HAL_DMA_DeInit+0xae8>)
 80095ca:	4299      	cmp	r1, r3
 80095cc:	d041      	beq.n	8009652 <HAL_DMA_DeInit+0x9fe>
 80095ce:	687b      	ldr	r3, [r7, #4]
 80095d0:	681b      	ldr	r3, [r3, #0]
 80095d2:	4619      	mov	r1, r3
 80095d4:	4b5a      	ldr	r3, [pc, #360]	; (8009740 <HAL_DMA_DeInit+0xaec>)
 80095d6:	4299      	cmp	r1, r3
 80095d8:	d038      	beq.n	800964c <HAL_DMA_DeInit+0x9f8>
 80095da:	687b      	ldr	r3, [r7, #4]
 80095dc:	681b      	ldr	r3, [r3, #0]
 80095de:	4619      	mov	r1, r3
 80095e0:	4b58      	ldr	r3, [pc, #352]	; (8009744 <HAL_DMA_DeInit+0xaf0>)
 80095e2:	4299      	cmp	r1, r3
 80095e4:	d02f      	beq.n	8009646 <HAL_DMA_DeInit+0x9f2>
 80095e6:	687b      	ldr	r3, [r7, #4]
 80095e8:	681b      	ldr	r3, [r3, #0]
 80095ea:	4619      	mov	r1, r3
 80095ec:	4b56      	ldr	r3, [pc, #344]	; (8009748 <HAL_DMA_DeInit+0xaf4>)
 80095ee:	4299      	cmp	r1, r3
 80095f0:	d026      	beq.n	8009640 <HAL_DMA_DeInit+0x9ec>
 80095f2:	687b      	ldr	r3, [r7, #4]
 80095f4:	681b      	ldr	r3, [r3, #0]
 80095f6:	4619      	mov	r1, r3
 80095f8:	4b54      	ldr	r3, [pc, #336]	; (800974c <HAL_DMA_DeInit+0xaf8>)
 80095fa:	4299      	cmp	r1, r3
 80095fc:	d01d      	beq.n	800963a <HAL_DMA_DeInit+0x9e6>
 80095fe:	687b      	ldr	r3, [r7, #4]
 8009600:	681b      	ldr	r3, [r3, #0]
 8009602:	4619      	mov	r1, r3
 8009604:	4b52      	ldr	r3, [pc, #328]	; (8009750 <HAL_DMA_DeInit+0xafc>)
 8009606:	4299      	cmp	r1, r3
 8009608:	d014      	beq.n	8009634 <HAL_DMA_DeInit+0x9e0>
 800960a:	687b      	ldr	r3, [r7, #4]
 800960c:	681b      	ldr	r3, [r3, #0]
 800960e:	4619      	mov	r1, r3
 8009610:	4b50      	ldr	r3, [pc, #320]	; (8009754 <HAL_DMA_DeInit+0xb00>)
 8009612:	4299      	cmp	r1, r3
 8009614:	d00b      	beq.n	800962e <HAL_DMA_DeInit+0x9da>
 8009616:	687b      	ldr	r3, [r7, #4]
 8009618:	681b      	ldr	r3, [r3, #0]
 800961a:	4619      	mov	r1, r3
 800961c:	4b4e      	ldr	r3, [pc, #312]	; (8009758 <HAL_DMA_DeInit+0xb04>)
 800961e:	4299      	cmp	r1, r3
 8009620:	d102      	bne.n	8009628 <HAL_DMA_DeInit+0x9d4>
 8009622:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009626:	e01e      	b.n	8009666 <HAL_DMA_DeInit+0xa12>
 8009628:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800962c:	e01b      	b.n	8009666 <HAL_DMA_DeInit+0xa12>
 800962e:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009632:	e018      	b.n	8009666 <HAL_DMA_DeInit+0xa12>
 8009634:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009638:	e015      	b.n	8009666 <HAL_DMA_DeInit+0xa12>
 800963a:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800963e:	e012      	b.n	8009666 <HAL_DMA_DeInit+0xa12>
 8009640:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009644:	e00f      	b.n	8009666 <HAL_DMA_DeInit+0xa12>
 8009646:	f44f 7300 	mov.w	r3, #512	; 0x200
 800964a:	e00c      	b.n	8009666 <HAL_DMA_DeInit+0xa12>
 800964c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009650:	e009      	b.n	8009666 <HAL_DMA_DeInit+0xa12>
 8009652:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009656:	e006      	b.n	8009666 <HAL_DMA_DeInit+0xa12>
 8009658:	2308      	movs	r3, #8
 800965a:	e004      	b.n	8009666 <HAL_DMA_DeInit+0xa12>
 800965c:	2308      	movs	r3, #8
 800965e:	e002      	b.n	8009666 <HAL_DMA_DeInit+0xa12>
 8009660:	2308      	movs	r3, #8
 8009662:	e000      	b.n	8009666 <HAL_DMA_DeInit+0xa12>
 8009664:	2308      	movs	r3, #8
 8009666:	6093      	str	r3, [r2, #8]
 8009668:	e102      	b.n	8009870 <HAL_DMA_DeInit+0xc1c>
 800966a:	687b      	ldr	r3, [r7, #4]
 800966c:	681b      	ldr	r3, [r3, #0]
 800966e:	461a      	mov	r2, r3
 8009670:	4b3b      	ldr	r3, [pc, #236]	; (8009760 <HAL_DMA_DeInit+0xb0c>)
 8009672:	429a      	cmp	r2, r3
 8009674:	f240 8090 	bls.w	8009798 <HAL_DMA_DeInit+0xb44>
 8009678:	4a3a      	ldr	r2, [pc, #232]	; (8009764 <HAL_DMA_DeInit+0xb10>)
 800967a:	687b      	ldr	r3, [r7, #4]
 800967c:	681b      	ldr	r3, [r3, #0]
 800967e:	4619      	mov	r1, r3
 8009680:	4b2a      	ldr	r3, [pc, #168]	; (800972c <HAL_DMA_DeInit+0xad8>)
 8009682:	4299      	cmp	r1, r3
 8009684:	f000 8085 	beq.w	8009792 <HAL_DMA_DeInit+0xb3e>
 8009688:	687b      	ldr	r3, [r7, #4]
 800968a:	681b      	ldr	r3, [r3, #0]
 800968c:	4619      	mov	r1, r3
 800968e:	4b28      	ldr	r3, [pc, #160]	; (8009730 <HAL_DMA_DeInit+0xadc>)
 8009690:	4299      	cmp	r1, r3
 8009692:	d07c      	beq.n	800978e <HAL_DMA_DeInit+0xb3a>
 8009694:	687b      	ldr	r3, [r7, #4]
 8009696:	681b      	ldr	r3, [r3, #0]
 8009698:	4619      	mov	r1, r3
 800969a:	4b26      	ldr	r3, [pc, #152]	; (8009734 <HAL_DMA_DeInit+0xae0>)
 800969c:	4299      	cmp	r1, r3
 800969e:	d074      	beq.n	800978a <HAL_DMA_DeInit+0xb36>
 80096a0:	687b      	ldr	r3, [r7, #4]
 80096a2:	681b      	ldr	r3, [r3, #0]
 80096a4:	4619      	mov	r1, r3
 80096a6:	4b24      	ldr	r3, [pc, #144]	; (8009738 <HAL_DMA_DeInit+0xae4>)
 80096a8:	4299      	cmp	r1, r3
 80096aa:	d06c      	beq.n	8009786 <HAL_DMA_DeInit+0xb32>
 80096ac:	687b      	ldr	r3, [r7, #4]
 80096ae:	681b      	ldr	r3, [r3, #0]
 80096b0:	4619      	mov	r1, r3
 80096b2:	4b22      	ldr	r3, [pc, #136]	; (800973c <HAL_DMA_DeInit+0xae8>)
 80096b4:	4299      	cmp	r1, r3
 80096b6:	d063      	beq.n	8009780 <HAL_DMA_DeInit+0xb2c>
 80096b8:	687b      	ldr	r3, [r7, #4]
 80096ba:	681b      	ldr	r3, [r3, #0]
 80096bc:	4619      	mov	r1, r3
 80096be:	4b20      	ldr	r3, [pc, #128]	; (8009740 <HAL_DMA_DeInit+0xaec>)
 80096c0:	4299      	cmp	r1, r3
 80096c2:	d05a      	beq.n	800977a <HAL_DMA_DeInit+0xb26>
 80096c4:	687b      	ldr	r3, [r7, #4]
 80096c6:	681b      	ldr	r3, [r3, #0]
 80096c8:	4619      	mov	r1, r3
 80096ca:	4b1e      	ldr	r3, [pc, #120]	; (8009744 <HAL_DMA_DeInit+0xaf0>)
 80096cc:	4299      	cmp	r1, r3
 80096ce:	d051      	beq.n	8009774 <HAL_DMA_DeInit+0xb20>
 80096d0:	687b      	ldr	r3, [r7, #4]
 80096d2:	681b      	ldr	r3, [r3, #0]
 80096d4:	4619      	mov	r1, r3
 80096d6:	4b1c      	ldr	r3, [pc, #112]	; (8009748 <HAL_DMA_DeInit+0xaf4>)
 80096d8:	4299      	cmp	r1, r3
 80096da:	d048      	beq.n	800976e <HAL_DMA_DeInit+0xb1a>
 80096dc:	687b      	ldr	r3, [r7, #4]
 80096de:	681b      	ldr	r3, [r3, #0]
 80096e0:	4619      	mov	r1, r3
 80096e2:	4b1a      	ldr	r3, [pc, #104]	; (800974c <HAL_DMA_DeInit+0xaf8>)
 80096e4:	4299      	cmp	r1, r3
 80096e6:	d03f      	beq.n	8009768 <HAL_DMA_DeInit+0xb14>
 80096e8:	687b      	ldr	r3, [r7, #4]
 80096ea:	681b      	ldr	r3, [r3, #0]
 80096ec:	4619      	mov	r1, r3
 80096ee:	4b18      	ldr	r3, [pc, #96]	; (8009750 <HAL_DMA_DeInit+0xafc>)
 80096f0:	4299      	cmp	r1, r3
 80096f2:	d014      	beq.n	800971e <HAL_DMA_DeInit+0xaca>
 80096f4:	687b      	ldr	r3, [r7, #4]
 80096f6:	681b      	ldr	r3, [r3, #0]
 80096f8:	4619      	mov	r1, r3
 80096fa:	4b16      	ldr	r3, [pc, #88]	; (8009754 <HAL_DMA_DeInit+0xb00>)
 80096fc:	4299      	cmp	r1, r3
 80096fe:	d00b      	beq.n	8009718 <HAL_DMA_DeInit+0xac4>
 8009700:	687b      	ldr	r3, [r7, #4]
 8009702:	681b      	ldr	r3, [r3, #0]
 8009704:	4619      	mov	r1, r3
 8009706:	4b14      	ldr	r3, [pc, #80]	; (8009758 <HAL_DMA_DeInit+0xb04>)
 8009708:	4299      	cmp	r1, r3
 800970a:	d102      	bne.n	8009712 <HAL_DMA_DeInit+0xabe>
 800970c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009710:	e040      	b.n	8009794 <HAL_DMA_DeInit+0xb40>
 8009712:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8009716:	e03d      	b.n	8009794 <HAL_DMA_DeInit+0xb40>
 8009718:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800971c:	e03a      	b.n	8009794 <HAL_DMA_DeInit+0xb40>
 800971e:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009722:	e037      	b.n	8009794 <HAL_DMA_DeInit+0xb40>
 8009724:	40026458 	.word	0x40026458
 8009728:	40026400 	.word	0x40026400
 800972c:	40026010 	.word	0x40026010
 8009730:	40026410 	.word	0x40026410
 8009734:	40026070 	.word	0x40026070
 8009738:	40026470 	.word	0x40026470
 800973c:	40026028 	.word	0x40026028
 8009740:	40026428 	.word	0x40026428
 8009744:	40026088 	.word	0x40026088
 8009748:	40026488 	.word	0x40026488
 800974c:	40026040 	.word	0x40026040
 8009750:	40026440 	.word	0x40026440
 8009754:	400260a0 	.word	0x400260a0
 8009758:	400264a0 	.word	0x400264a0
 800975c:	400260b8 	.word	0x400260b8
 8009760:	40026058 	.word	0x40026058
 8009764:	40026000 	.word	0x40026000
 8009768:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800976c:	e012      	b.n	8009794 <HAL_DMA_DeInit+0xb40>
 800976e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009772:	e00f      	b.n	8009794 <HAL_DMA_DeInit+0xb40>
 8009774:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009778:	e00c      	b.n	8009794 <HAL_DMA_DeInit+0xb40>
 800977a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800977e:	e009      	b.n	8009794 <HAL_DMA_DeInit+0xb40>
 8009780:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009784:	e006      	b.n	8009794 <HAL_DMA_DeInit+0xb40>
 8009786:	2308      	movs	r3, #8
 8009788:	e004      	b.n	8009794 <HAL_DMA_DeInit+0xb40>
 800978a:	2308      	movs	r3, #8
 800978c:	e002      	b.n	8009794 <HAL_DMA_DeInit+0xb40>
 800978e:	2308      	movs	r3, #8
 8009790:	e000      	b.n	8009794 <HAL_DMA_DeInit+0xb40>
 8009792:	2308      	movs	r3, #8
 8009794:	60d3      	str	r3, [r2, #12]
 8009796:	e06b      	b.n	8009870 <HAL_DMA_DeInit+0xc1c>
 8009798:	4a9e      	ldr	r2, [pc, #632]	; (8009a14 <HAL_DMA_DeInit+0xdc0>)
 800979a:	687b      	ldr	r3, [r7, #4]
 800979c:	681b      	ldr	r3, [r3, #0]
 800979e:	4619      	mov	r1, r3
 80097a0:	4b9d      	ldr	r3, [pc, #628]	; (8009a18 <HAL_DMA_DeInit+0xdc4>)
 80097a2:	4299      	cmp	r1, r3
 80097a4:	d062      	beq.n	800986c <HAL_DMA_DeInit+0xc18>
 80097a6:	687b      	ldr	r3, [r7, #4]
 80097a8:	681b      	ldr	r3, [r3, #0]
 80097aa:	4619      	mov	r1, r3
 80097ac:	4b9b      	ldr	r3, [pc, #620]	; (8009a1c <HAL_DMA_DeInit+0xdc8>)
 80097ae:	4299      	cmp	r1, r3
 80097b0:	d05a      	beq.n	8009868 <HAL_DMA_DeInit+0xc14>
 80097b2:	687b      	ldr	r3, [r7, #4]
 80097b4:	681b      	ldr	r3, [r3, #0]
 80097b6:	4619      	mov	r1, r3
 80097b8:	4b99      	ldr	r3, [pc, #612]	; (8009a20 <HAL_DMA_DeInit+0xdcc>)
 80097ba:	4299      	cmp	r1, r3
 80097bc:	d052      	beq.n	8009864 <HAL_DMA_DeInit+0xc10>
 80097be:	687b      	ldr	r3, [r7, #4]
 80097c0:	681b      	ldr	r3, [r3, #0]
 80097c2:	4619      	mov	r1, r3
 80097c4:	4b97      	ldr	r3, [pc, #604]	; (8009a24 <HAL_DMA_DeInit+0xdd0>)
 80097c6:	4299      	cmp	r1, r3
 80097c8:	d04a      	beq.n	8009860 <HAL_DMA_DeInit+0xc0c>
 80097ca:	687b      	ldr	r3, [r7, #4]
 80097cc:	681b      	ldr	r3, [r3, #0]
 80097ce:	4619      	mov	r1, r3
 80097d0:	4b95      	ldr	r3, [pc, #596]	; (8009a28 <HAL_DMA_DeInit+0xdd4>)
 80097d2:	4299      	cmp	r1, r3
 80097d4:	d041      	beq.n	800985a <HAL_DMA_DeInit+0xc06>
 80097d6:	687b      	ldr	r3, [r7, #4]
 80097d8:	681b      	ldr	r3, [r3, #0]
 80097da:	4619      	mov	r1, r3
 80097dc:	4b93      	ldr	r3, [pc, #588]	; (8009a2c <HAL_DMA_DeInit+0xdd8>)
 80097de:	4299      	cmp	r1, r3
 80097e0:	d038      	beq.n	8009854 <HAL_DMA_DeInit+0xc00>
 80097e2:	687b      	ldr	r3, [r7, #4]
 80097e4:	681b      	ldr	r3, [r3, #0]
 80097e6:	4619      	mov	r1, r3
 80097e8:	4b91      	ldr	r3, [pc, #580]	; (8009a30 <HAL_DMA_DeInit+0xddc>)
 80097ea:	4299      	cmp	r1, r3
 80097ec:	d02f      	beq.n	800984e <HAL_DMA_DeInit+0xbfa>
 80097ee:	687b      	ldr	r3, [r7, #4]
 80097f0:	681b      	ldr	r3, [r3, #0]
 80097f2:	4619      	mov	r1, r3
 80097f4:	4b8f      	ldr	r3, [pc, #572]	; (8009a34 <HAL_DMA_DeInit+0xde0>)
 80097f6:	4299      	cmp	r1, r3
 80097f8:	d026      	beq.n	8009848 <HAL_DMA_DeInit+0xbf4>
 80097fa:	687b      	ldr	r3, [r7, #4]
 80097fc:	681b      	ldr	r3, [r3, #0]
 80097fe:	4619      	mov	r1, r3
 8009800:	4b8d      	ldr	r3, [pc, #564]	; (8009a38 <HAL_DMA_DeInit+0xde4>)
 8009802:	4299      	cmp	r1, r3
 8009804:	d01d      	beq.n	8009842 <HAL_DMA_DeInit+0xbee>
 8009806:	687b      	ldr	r3, [r7, #4]
 8009808:	681b      	ldr	r3, [r3, #0]
 800980a:	4619      	mov	r1, r3
 800980c:	4b8b      	ldr	r3, [pc, #556]	; (8009a3c <HAL_DMA_DeInit+0xde8>)
 800980e:	4299      	cmp	r1, r3
 8009810:	d014      	beq.n	800983c <HAL_DMA_DeInit+0xbe8>
 8009812:	687b      	ldr	r3, [r7, #4]
 8009814:	681b      	ldr	r3, [r3, #0]
 8009816:	4619      	mov	r1, r3
 8009818:	4b89      	ldr	r3, [pc, #548]	; (8009a40 <HAL_DMA_DeInit+0xdec>)
 800981a:	4299      	cmp	r1, r3
 800981c:	d00b      	beq.n	8009836 <HAL_DMA_DeInit+0xbe2>
 800981e:	687b      	ldr	r3, [r7, #4]
 8009820:	681b      	ldr	r3, [r3, #0]
 8009822:	4619      	mov	r1, r3
 8009824:	4b87      	ldr	r3, [pc, #540]	; (8009a44 <HAL_DMA_DeInit+0xdf0>)
 8009826:	4299      	cmp	r1, r3
 8009828:	d102      	bne.n	8009830 <HAL_DMA_DeInit+0xbdc>
 800982a:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800982e:	e01e      	b.n	800986e <HAL_DMA_DeInit+0xc1a>
 8009830:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8009834:	e01b      	b.n	800986e <HAL_DMA_DeInit+0xc1a>
 8009836:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800983a:	e018      	b.n	800986e <HAL_DMA_DeInit+0xc1a>
 800983c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009840:	e015      	b.n	800986e <HAL_DMA_DeInit+0xc1a>
 8009842:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009846:	e012      	b.n	800986e <HAL_DMA_DeInit+0xc1a>
 8009848:	f44f 7300 	mov.w	r3, #512	; 0x200
 800984c:	e00f      	b.n	800986e <HAL_DMA_DeInit+0xc1a>
 800984e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009852:	e00c      	b.n	800986e <HAL_DMA_DeInit+0xc1a>
 8009854:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009858:	e009      	b.n	800986e <HAL_DMA_DeInit+0xc1a>
 800985a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800985e:	e006      	b.n	800986e <HAL_DMA_DeInit+0xc1a>
 8009860:	2308      	movs	r3, #8
 8009862:	e004      	b.n	800986e <HAL_DMA_DeInit+0xc1a>
 8009864:	2308      	movs	r3, #8
 8009866:	e002      	b.n	800986e <HAL_DMA_DeInit+0xc1a>
 8009868:	2308      	movs	r3, #8
 800986a:	e000      	b.n	800986e <HAL_DMA_DeInit+0xc1a>
 800986c:	2308      	movs	r3, #8
 800986e:	6093      	str	r3, [r2, #8]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8009870:	687b      	ldr	r3, [r7, #4]
 8009872:	681b      	ldr	r3, [r3, #0]
 8009874:	461a      	mov	r2, r3
 8009876:	4b74      	ldr	r3, [pc, #464]	; (8009a48 <HAL_DMA_DeInit+0xdf4>)
 8009878:	429a      	cmp	r2, r3
 800987a:	d968      	bls.n	800994e <HAL_DMA_DeInit+0xcfa>
 800987c:	4a73      	ldr	r2, [pc, #460]	; (8009a4c <HAL_DMA_DeInit+0xdf8>)
 800987e:	687b      	ldr	r3, [r7, #4]
 8009880:	681b      	ldr	r3, [r3, #0]
 8009882:	4619      	mov	r1, r3
 8009884:	4b64      	ldr	r3, [pc, #400]	; (8009a18 <HAL_DMA_DeInit+0xdc4>)
 8009886:	4299      	cmp	r1, r3
 8009888:	d05e      	beq.n	8009948 <HAL_DMA_DeInit+0xcf4>
 800988a:	687b      	ldr	r3, [r7, #4]
 800988c:	681b      	ldr	r3, [r3, #0]
 800988e:	4619      	mov	r1, r3
 8009890:	4b62      	ldr	r3, [pc, #392]	; (8009a1c <HAL_DMA_DeInit+0xdc8>)
 8009892:	4299      	cmp	r1, r3
 8009894:	d056      	beq.n	8009944 <HAL_DMA_DeInit+0xcf0>
 8009896:	687b      	ldr	r3, [r7, #4]
 8009898:	681b      	ldr	r3, [r3, #0]
 800989a:	4619      	mov	r1, r3
 800989c:	4b60      	ldr	r3, [pc, #384]	; (8009a20 <HAL_DMA_DeInit+0xdcc>)
 800989e:	4299      	cmp	r1, r3
 80098a0:	d04e      	beq.n	8009940 <HAL_DMA_DeInit+0xcec>
 80098a2:	687b      	ldr	r3, [r7, #4]
 80098a4:	681b      	ldr	r3, [r3, #0]
 80098a6:	4619      	mov	r1, r3
 80098a8:	4b5e      	ldr	r3, [pc, #376]	; (8009a24 <HAL_DMA_DeInit+0xdd0>)
 80098aa:	4299      	cmp	r1, r3
 80098ac:	d046      	beq.n	800993c <HAL_DMA_DeInit+0xce8>
 80098ae:	687b      	ldr	r3, [r7, #4]
 80098b0:	681b      	ldr	r3, [r3, #0]
 80098b2:	4619      	mov	r1, r3
 80098b4:	4b5c      	ldr	r3, [pc, #368]	; (8009a28 <HAL_DMA_DeInit+0xdd4>)
 80098b6:	4299      	cmp	r1, r3
 80098b8:	d03e      	beq.n	8009938 <HAL_DMA_DeInit+0xce4>
 80098ba:	687b      	ldr	r3, [r7, #4]
 80098bc:	681b      	ldr	r3, [r3, #0]
 80098be:	4619      	mov	r1, r3
 80098c0:	4b5a      	ldr	r3, [pc, #360]	; (8009a2c <HAL_DMA_DeInit+0xdd8>)
 80098c2:	4299      	cmp	r1, r3
 80098c4:	d036      	beq.n	8009934 <HAL_DMA_DeInit+0xce0>
 80098c6:	687b      	ldr	r3, [r7, #4]
 80098c8:	681b      	ldr	r3, [r3, #0]
 80098ca:	4619      	mov	r1, r3
 80098cc:	4b58      	ldr	r3, [pc, #352]	; (8009a30 <HAL_DMA_DeInit+0xddc>)
 80098ce:	4299      	cmp	r1, r3
 80098d0:	d02e      	beq.n	8009930 <HAL_DMA_DeInit+0xcdc>
 80098d2:	687b      	ldr	r3, [r7, #4]
 80098d4:	681b      	ldr	r3, [r3, #0]
 80098d6:	4619      	mov	r1, r3
 80098d8:	4b56      	ldr	r3, [pc, #344]	; (8009a34 <HAL_DMA_DeInit+0xde0>)
 80098da:	4299      	cmp	r1, r3
 80098dc:	d026      	beq.n	800992c <HAL_DMA_DeInit+0xcd8>
 80098de:	687b      	ldr	r3, [r7, #4]
 80098e0:	681b      	ldr	r3, [r3, #0]
 80098e2:	4619      	mov	r1, r3
 80098e4:	4b54      	ldr	r3, [pc, #336]	; (8009a38 <HAL_DMA_DeInit+0xde4>)
 80098e6:	4299      	cmp	r1, r3
 80098e8:	d01d      	beq.n	8009926 <HAL_DMA_DeInit+0xcd2>
 80098ea:	687b      	ldr	r3, [r7, #4]
 80098ec:	681b      	ldr	r3, [r3, #0]
 80098ee:	4619      	mov	r1, r3
 80098f0:	4b52      	ldr	r3, [pc, #328]	; (8009a3c <HAL_DMA_DeInit+0xde8>)
 80098f2:	4299      	cmp	r1, r3
 80098f4:	d014      	beq.n	8009920 <HAL_DMA_DeInit+0xccc>
 80098f6:	687b      	ldr	r3, [r7, #4]
 80098f8:	681b      	ldr	r3, [r3, #0]
 80098fa:	4619      	mov	r1, r3
 80098fc:	4b50      	ldr	r3, [pc, #320]	; (8009a40 <HAL_DMA_DeInit+0xdec>)
 80098fe:	4299      	cmp	r1, r3
 8009900:	d00b      	beq.n	800991a <HAL_DMA_DeInit+0xcc6>
 8009902:	687b      	ldr	r3, [r7, #4]
 8009904:	681b      	ldr	r3, [r3, #0]
 8009906:	4619      	mov	r1, r3
 8009908:	4b4e      	ldr	r3, [pc, #312]	; (8009a44 <HAL_DMA_DeInit+0xdf0>)
 800990a:	4299      	cmp	r1, r3
 800990c:	d102      	bne.n	8009914 <HAL_DMA_DeInit+0xcc0>
 800990e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009912:	e01a      	b.n	800994a <HAL_DMA_DeInit+0xcf6>
 8009914:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8009918:	e017      	b.n	800994a <HAL_DMA_DeInit+0xcf6>
 800991a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800991e:	e014      	b.n	800994a <HAL_DMA_DeInit+0xcf6>
 8009920:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009924:	e011      	b.n	800994a <HAL_DMA_DeInit+0xcf6>
 8009926:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800992a:	e00e      	b.n	800994a <HAL_DMA_DeInit+0xcf6>
 800992c:	2340      	movs	r3, #64	; 0x40
 800992e:	e00c      	b.n	800994a <HAL_DMA_DeInit+0xcf6>
 8009930:	2340      	movs	r3, #64	; 0x40
 8009932:	e00a      	b.n	800994a <HAL_DMA_DeInit+0xcf6>
 8009934:	2340      	movs	r3, #64	; 0x40
 8009936:	e008      	b.n	800994a <HAL_DMA_DeInit+0xcf6>
 8009938:	2340      	movs	r3, #64	; 0x40
 800993a:	e006      	b.n	800994a <HAL_DMA_DeInit+0xcf6>
 800993c:	4b44      	ldr	r3, [pc, #272]	; (8009a50 <HAL_DMA_DeInit+0xdfc>)
 800993e:	e004      	b.n	800994a <HAL_DMA_DeInit+0xcf6>
 8009940:	4b43      	ldr	r3, [pc, #268]	; (8009a50 <HAL_DMA_DeInit+0xdfc>)
 8009942:	e002      	b.n	800994a <HAL_DMA_DeInit+0xcf6>
 8009944:	4b42      	ldr	r3, [pc, #264]	; (8009a50 <HAL_DMA_DeInit+0xdfc>)
 8009946:	e000      	b.n	800994a <HAL_DMA_DeInit+0xcf6>
 8009948:	4b41      	ldr	r3, [pc, #260]	; (8009a50 <HAL_DMA_DeInit+0xdfc>)
 800994a:	60d3      	str	r3, [r2, #12]
 800994c:	e16a      	b.n	8009c24 <HAL_DMA_DeInit+0xfd0>
 800994e:	687b      	ldr	r3, [r7, #4]
 8009950:	681b      	ldr	r3, [r3, #0]
 8009952:	461a      	mov	r2, r3
 8009954:	4b3f      	ldr	r3, [pc, #252]	; (8009a54 <HAL_DMA_DeInit+0xe00>)
 8009956:	429a      	cmp	r2, r3
 8009958:	f240 808d 	bls.w	8009a76 <HAL_DMA_DeInit+0xe22>
 800995c:	4a3b      	ldr	r2, [pc, #236]	; (8009a4c <HAL_DMA_DeInit+0xdf8>)
 800995e:	687b      	ldr	r3, [r7, #4]
 8009960:	681b      	ldr	r3, [r3, #0]
 8009962:	4619      	mov	r1, r3
 8009964:	4b2c      	ldr	r3, [pc, #176]	; (8009a18 <HAL_DMA_DeInit+0xdc4>)
 8009966:	4299      	cmp	r1, r3
 8009968:	f000 8082 	beq.w	8009a70 <HAL_DMA_DeInit+0xe1c>
 800996c:	687b      	ldr	r3, [r7, #4]
 800996e:	681b      	ldr	r3, [r3, #0]
 8009970:	4619      	mov	r1, r3
 8009972:	4b2a      	ldr	r3, [pc, #168]	; (8009a1c <HAL_DMA_DeInit+0xdc8>)
 8009974:	4299      	cmp	r1, r3
 8009976:	d079      	beq.n	8009a6c <HAL_DMA_DeInit+0xe18>
 8009978:	687b      	ldr	r3, [r7, #4]
 800997a:	681b      	ldr	r3, [r3, #0]
 800997c:	4619      	mov	r1, r3
 800997e:	4b28      	ldr	r3, [pc, #160]	; (8009a20 <HAL_DMA_DeInit+0xdcc>)
 8009980:	4299      	cmp	r1, r3
 8009982:	d071      	beq.n	8009a68 <HAL_DMA_DeInit+0xe14>
 8009984:	687b      	ldr	r3, [r7, #4]
 8009986:	681b      	ldr	r3, [r3, #0]
 8009988:	4619      	mov	r1, r3
 800998a:	4b26      	ldr	r3, [pc, #152]	; (8009a24 <HAL_DMA_DeInit+0xdd0>)
 800998c:	4299      	cmp	r1, r3
 800998e:	d069      	beq.n	8009a64 <HAL_DMA_DeInit+0xe10>
 8009990:	687b      	ldr	r3, [r7, #4]
 8009992:	681b      	ldr	r3, [r3, #0]
 8009994:	4619      	mov	r1, r3
 8009996:	4b24      	ldr	r3, [pc, #144]	; (8009a28 <HAL_DMA_DeInit+0xdd4>)
 8009998:	4299      	cmp	r1, r3
 800999a:	d061      	beq.n	8009a60 <HAL_DMA_DeInit+0xe0c>
 800999c:	687b      	ldr	r3, [r7, #4]
 800999e:	681b      	ldr	r3, [r3, #0]
 80099a0:	4619      	mov	r1, r3
 80099a2:	4b22      	ldr	r3, [pc, #136]	; (8009a2c <HAL_DMA_DeInit+0xdd8>)
 80099a4:	4299      	cmp	r1, r3
 80099a6:	d059      	beq.n	8009a5c <HAL_DMA_DeInit+0xe08>
 80099a8:	687b      	ldr	r3, [r7, #4]
 80099aa:	681b      	ldr	r3, [r3, #0]
 80099ac:	4619      	mov	r1, r3
 80099ae:	4b20      	ldr	r3, [pc, #128]	; (8009a30 <HAL_DMA_DeInit+0xddc>)
 80099b0:	4299      	cmp	r1, r3
 80099b2:	d051      	beq.n	8009a58 <HAL_DMA_DeInit+0xe04>
 80099b4:	687b      	ldr	r3, [r7, #4]
 80099b6:	681b      	ldr	r3, [r3, #0]
 80099b8:	4619      	mov	r1, r3
 80099ba:	4b1e      	ldr	r3, [pc, #120]	; (8009a34 <HAL_DMA_DeInit+0xde0>)
 80099bc:	4299      	cmp	r1, r3
 80099be:	d026      	beq.n	8009a0e <HAL_DMA_DeInit+0xdba>
 80099c0:	687b      	ldr	r3, [r7, #4]
 80099c2:	681b      	ldr	r3, [r3, #0]
 80099c4:	4619      	mov	r1, r3
 80099c6:	4b1c      	ldr	r3, [pc, #112]	; (8009a38 <HAL_DMA_DeInit+0xde4>)
 80099c8:	4299      	cmp	r1, r3
 80099ca:	d01d      	beq.n	8009a08 <HAL_DMA_DeInit+0xdb4>
 80099cc:	687b      	ldr	r3, [r7, #4]
 80099ce:	681b      	ldr	r3, [r3, #0]
 80099d0:	4619      	mov	r1, r3
 80099d2:	4b1a      	ldr	r3, [pc, #104]	; (8009a3c <HAL_DMA_DeInit+0xde8>)
 80099d4:	4299      	cmp	r1, r3
 80099d6:	d014      	beq.n	8009a02 <HAL_DMA_DeInit+0xdae>
 80099d8:	687b      	ldr	r3, [r7, #4]
 80099da:	681b      	ldr	r3, [r3, #0]
 80099dc:	4619      	mov	r1, r3
 80099de:	4b18      	ldr	r3, [pc, #96]	; (8009a40 <HAL_DMA_DeInit+0xdec>)
 80099e0:	4299      	cmp	r1, r3
 80099e2:	d00b      	beq.n	80099fc <HAL_DMA_DeInit+0xda8>
 80099e4:	687b      	ldr	r3, [r7, #4]
 80099e6:	681b      	ldr	r3, [r3, #0]
 80099e8:	4619      	mov	r1, r3
 80099ea:	4b16      	ldr	r3, [pc, #88]	; (8009a44 <HAL_DMA_DeInit+0xdf0>)
 80099ec:	4299      	cmp	r1, r3
 80099ee:	d102      	bne.n	80099f6 <HAL_DMA_DeInit+0xda2>
 80099f0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80099f4:	e03d      	b.n	8009a72 <HAL_DMA_DeInit+0xe1e>
 80099f6:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 80099fa:	e03a      	b.n	8009a72 <HAL_DMA_DeInit+0xe1e>
 80099fc:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009a00:	e037      	b.n	8009a72 <HAL_DMA_DeInit+0xe1e>
 8009a02:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009a06:	e034      	b.n	8009a72 <HAL_DMA_DeInit+0xe1e>
 8009a08:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009a0c:	e031      	b.n	8009a72 <HAL_DMA_DeInit+0xe1e>
 8009a0e:	2340      	movs	r3, #64	; 0x40
 8009a10:	e02f      	b.n	8009a72 <HAL_DMA_DeInit+0xe1e>
 8009a12:	bf00      	nop
 8009a14:	40026000 	.word	0x40026000
 8009a18:	40026010 	.word	0x40026010
 8009a1c:	40026410 	.word	0x40026410
 8009a20:	40026070 	.word	0x40026070
 8009a24:	40026470 	.word	0x40026470
 8009a28:	40026028 	.word	0x40026028
 8009a2c:	40026428 	.word	0x40026428
 8009a30:	40026088 	.word	0x40026088
 8009a34:	40026488 	.word	0x40026488
 8009a38:	40026040 	.word	0x40026040
 8009a3c:	40026440 	.word	0x40026440
 8009a40:	400260a0 	.word	0x400260a0
 8009a44:	400264a0 	.word	0x400264a0
 8009a48:	40026458 	.word	0x40026458
 8009a4c:	40026400 	.word	0x40026400
 8009a50:	00800001 	.word	0x00800001
 8009a54:	400260b8 	.word	0x400260b8
 8009a58:	2340      	movs	r3, #64	; 0x40
 8009a5a:	e00a      	b.n	8009a72 <HAL_DMA_DeInit+0xe1e>
 8009a5c:	2340      	movs	r3, #64	; 0x40
 8009a5e:	e008      	b.n	8009a72 <HAL_DMA_DeInit+0xe1e>
 8009a60:	2340      	movs	r3, #64	; 0x40
 8009a62:	e006      	b.n	8009a72 <HAL_DMA_DeInit+0xe1e>
 8009a64:	4b99      	ldr	r3, [pc, #612]	; (8009ccc <HAL_DMA_DeInit+0x1078>)
 8009a66:	e004      	b.n	8009a72 <HAL_DMA_DeInit+0xe1e>
 8009a68:	4b98      	ldr	r3, [pc, #608]	; (8009ccc <HAL_DMA_DeInit+0x1078>)
 8009a6a:	e002      	b.n	8009a72 <HAL_DMA_DeInit+0xe1e>
 8009a6c:	4b97      	ldr	r3, [pc, #604]	; (8009ccc <HAL_DMA_DeInit+0x1078>)
 8009a6e:	e000      	b.n	8009a72 <HAL_DMA_DeInit+0xe1e>
 8009a70:	4b96      	ldr	r3, [pc, #600]	; (8009ccc <HAL_DMA_DeInit+0x1078>)
 8009a72:	6093      	str	r3, [r2, #8]
 8009a74:	e0d6      	b.n	8009c24 <HAL_DMA_DeInit+0xfd0>
 8009a76:	687b      	ldr	r3, [r7, #4]
 8009a78:	681b      	ldr	r3, [r3, #0]
 8009a7a:	461a      	mov	r2, r3
 8009a7c:	4b94      	ldr	r3, [pc, #592]	; (8009cd0 <HAL_DMA_DeInit+0x107c>)
 8009a7e:	429a      	cmp	r2, r3
 8009a80:	d968      	bls.n	8009b54 <HAL_DMA_DeInit+0xf00>
 8009a82:	4a94      	ldr	r2, [pc, #592]	; (8009cd4 <HAL_DMA_DeInit+0x1080>)
 8009a84:	687b      	ldr	r3, [r7, #4]
 8009a86:	681b      	ldr	r3, [r3, #0]
 8009a88:	4619      	mov	r1, r3
 8009a8a:	4b93      	ldr	r3, [pc, #588]	; (8009cd8 <HAL_DMA_DeInit+0x1084>)
 8009a8c:	4299      	cmp	r1, r3
 8009a8e:	d05e      	beq.n	8009b4e <HAL_DMA_DeInit+0xefa>
 8009a90:	687b      	ldr	r3, [r7, #4]
 8009a92:	681b      	ldr	r3, [r3, #0]
 8009a94:	4619      	mov	r1, r3
 8009a96:	4b91      	ldr	r3, [pc, #580]	; (8009cdc <HAL_DMA_DeInit+0x1088>)
 8009a98:	4299      	cmp	r1, r3
 8009a9a:	d056      	beq.n	8009b4a <HAL_DMA_DeInit+0xef6>
 8009a9c:	687b      	ldr	r3, [r7, #4]
 8009a9e:	681b      	ldr	r3, [r3, #0]
 8009aa0:	4619      	mov	r1, r3
 8009aa2:	4b8f      	ldr	r3, [pc, #572]	; (8009ce0 <HAL_DMA_DeInit+0x108c>)
 8009aa4:	4299      	cmp	r1, r3
 8009aa6:	d04e      	beq.n	8009b46 <HAL_DMA_DeInit+0xef2>
 8009aa8:	687b      	ldr	r3, [r7, #4]
 8009aaa:	681b      	ldr	r3, [r3, #0]
 8009aac:	4619      	mov	r1, r3
 8009aae:	4b8d      	ldr	r3, [pc, #564]	; (8009ce4 <HAL_DMA_DeInit+0x1090>)
 8009ab0:	4299      	cmp	r1, r3
 8009ab2:	d046      	beq.n	8009b42 <HAL_DMA_DeInit+0xeee>
 8009ab4:	687b      	ldr	r3, [r7, #4]
 8009ab6:	681b      	ldr	r3, [r3, #0]
 8009ab8:	4619      	mov	r1, r3
 8009aba:	4b8b      	ldr	r3, [pc, #556]	; (8009ce8 <HAL_DMA_DeInit+0x1094>)
 8009abc:	4299      	cmp	r1, r3
 8009abe:	d03e      	beq.n	8009b3e <HAL_DMA_DeInit+0xeea>
 8009ac0:	687b      	ldr	r3, [r7, #4]
 8009ac2:	681b      	ldr	r3, [r3, #0]
 8009ac4:	4619      	mov	r1, r3
 8009ac6:	4b89      	ldr	r3, [pc, #548]	; (8009cec <HAL_DMA_DeInit+0x1098>)
 8009ac8:	4299      	cmp	r1, r3
 8009aca:	d036      	beq.n	8009b3a <HAL_DMA_DeInit+0xee6>
 8009acc:	687b      	ldr	r3, [r7, #4]
 8009ace:	681b      	ldr	r3, [r3, #0]
 8009ad0:	4619      	mov	r1, r3
 8009ad2:	4b87      	ldr	r3, [pc, #540]	; (8009cf0 <HAL_DMA_DeInit+0x109c>)
 8009ad4:	4299      	cmp	r1, r3
 8009ad6:	d02e      	beq.n	8009b36 <HAL_DMA_DeInit+0xee2>
 8009ad8:	687b      	ldr	r3, [r7, #4]
 8009ada:	681b      	ldr	r3, [r3, #0]
 8009adc:	4619      	mov	r1, r3
 8009ade:	4b85      	ldr	r3, [pc, #532]	; (8009cf4 <HAL_DMA_DeInit+0x10a0>)
 8009ae0:	4299      	cmp	r1, r3
 8009ae2:	d026      	beq.n	8009b32 <HAL_DMA_DeInit+0xede>
 8009ae4:	687b      	ldr	r3, [r7, #4]
 8009ae6:	681b      	ldr	r3, [r3, #0]
 8009ae8:	4619      	mov	r1, r3
 8009aea:	4b83      	ldr	r3, [pc, #524]	; (8009cf8 <HAL_DMA_DeInit+0x10a4>)
 8009aec:	4299      	cmp	r1, r3
 8009aee:	d01d      	beq.n	8009b2c <HAL_DMA_DeInit+0xed8>
 8009af0:	687b      	ldr	r3, [r7, #4]
 8009af2:	681b      	ldr	r3, [r3, #0]
 8009af4:	4619      	mov	r1, r3
 8009af6:	4b81      	ldr	r3, [pc, #516]	; (8009cfc <HAL_DMA_DeInit+0x10a8>)
 8009af8:	4299      	cmp	r1, r3
 8009afa:	d014      	beq.n	8009b26 <HAL_DMA_DeInit+0xed2>
 8009afc:	687b      	ldr	r3, [r7, #4]
 8009afe:	681b      	ldr	r3, [r3, #0]
 8009b00:	4619      	mov	r1, r3
 8009b02:	4b7f      	ldr	r3, [pc, #508]	; (8009d00 <HAL_DMA_DeInit+0x10ac>)
 8009b04:	4299      	cmp	r1, r3
 8009b06:	d00b      	beq.n	8009b20 <HAL_DMA_DeInit+0xecc>
 8009b08:	687b      	ldr	r3, [r7, #4]
 8009b0a:	681b      	ldr	r3, [r3, #0]
 8009b0c:	4619      	mov	r1, r3
 8009b0e:	4b7d      	ldr	r3, [pc, #500]	; (8009d04 <HAL_DMA_DeInit+0x10b0>)
 8009b10:	4299      	cmp	r1, r3
 8009b12:	d102      	bne.n	8009b1a <HAL_DMA_DeInit+0xec6>
 8009b14:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009b18:	e01a      	b.n	8009b50 <HAL_DMA_DeInit+0xefc>
 8009b1a:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8009b1e:	e017      	b.n	8009b50 <HAL_DMA_DeInit+0xefc>
 8009b20:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009b24:	e014      	b.n	8009b50 <HAL_DMA_DeInit+0xefc>
 8009b26:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009b2a:	e011      	b.n	8009b50 <HAL_DMA_DeInit+0xefc>
 8009b2c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009b30:	e00e      	b.n	8009b50 <HAL_DMA_DeInit+0xefc>
 8009b32:	2340      	movs	r3, #64	; 0x40
 8009b34:	e00c      	b.n	8009b50 <HAL_DMA_DeInit+0xefc>
 8009b36:	2340      	movs	r3, #64	; 0x40
 8009b38:	e00a      	b.n	8009b50 <HAL_DMA_DeInit+0xefc>
 8009b3a:	2340      	movs	r3, #64	; 0x40
 8009b3c:	e008      	b.n	8009b50 <HAL_DMA_DeInit+0xefc>
 8009b3e:	2340      	movs	r3, #64	; 0x40
 8009b40:	e006      	b.n	8009b50 <HAL_DMA_DeInit+0xefc>
 8009b42:	4b62      	ldr	r3, [pc, #392]	; (8009ccc <HAL_DMA_DeInit+0x1078>)
 8009b44:	e004      	b.n	8009b50 <HAL_DMA_DeInit+0xefc>
 8009b46:	4b61      	ldr	r3, [pc, #388]	; (8009ccc <HAL_DMA_DeInit+0x1078>)
 8009b48:	e002      	b.n	8009b50 <HAL_DMA_DeInit+0xefc>
 8009b4a:	4b60      	ldr	r3, [pc, #384]	; (8009ccc <HAL_DMA_DeInit+0x1078>)
 8009b4c:	e000      	b.n	8009b50 <HAL_DMA_DeInit+0xefc>
 8009b4e:	4b5f      	ldr	r3, [pc, #380]	; (8009ccc <HAL_DMA_DeInit+0x1078>)
 8009b50:	60d3      	str	r3, [r2, #12]
 8009b52:	e067      	b.n	8009c24 <HAL_DMA_DeInit+0xfd0>
 8009b54:	4a5f      	ldr	r2, [pc, #380]	; (8009cd4 <HAL_DMA_DeInit+0x1080>)
 8009b56:	687b      	ldr	r3, [r7, #4]
 8009b58:	681b      	ldr	r3, [r3, #0]
 8009b5a:	4619      	mov	r1, r3
 8009b5c:	4b5e      	ldr	r3, [pc, #376]	; (8009cd8 <HAL_DMA_DeInit+0x1084>)
 8009b5e:	4299      	cmp	r1, r3
 8009b60:	d05e      	beq.n	8009c20 <HAL_DMA_DeInit+0xfcc>
 8009b62:	687b      	ldr	r3, [r7, #4]
 8009b64:	681b      	ldr	r3, [r3, #0]
 8009b66:	4619      	mov	r1, r3
 8009b68:	4b5c      	ldr	r3, [pc, #368]	; (8009cdc <HAL_DMA_DeInit+0x1088>)
 8009b6a:	4299      	cmp	r1, r3
 8009b6c:	d056      	beq.n	8009c1c <HAL_DMA_DeInit+0xfc8>
 8009b6e:	687b      	ldr	r3, [r7, #4]
 8009b70:	681b      	ldr	r3, [r3, #0]
 8009b72:	4619      	mov	r1, r3
 8009b74:	4b5a      	ldr	r3, [pc, #360]	; (8009ce0 <HAL_DMA_DeInit+0x108c>)
 8009b76:	4299      	cmp	r1, r3
 8009b78:	d04e      	beq.n	8009c18 <HAL_DMA_DeInit+0xfc4>
 8009b7a:	687b      	ldr	r3, [r7, #4]
 8009b7c:	681b      	ldr	r3, [r3, #0]
 8009b7e:	4619      	mov	r1, r3
 8009b80:	4b58      	ldr	r3, [pc, #352]	; (8009ce4 <HAL_DMA_DeInit+0x1090>)
 8009b82:	4299      	cmp	r1, r3
 8009b84:	d046      	beq.n	8009c14 <HAL_DMA_DeInit+0xfc0>
 8009b86:	687b      	ldr	r3, [r7, #4]
 8009b88:	681b      	ldr	r3, [r3, #0]
 8009b8a:	4619      	mov	r1, r3
 8009b8c:	4b56      	ldr	r3, [pc, #344]	; (8009ce8 <HAL_DMA_DeInit+0x1094>)
 8009b8e:	4299      	cmp	r1, r3
 8009b90:	d03e      	beq.n	8009c10 <HAL_DMA_DeInit+0xfbc>
 8009b92:	687b      	ldr	r3, [r7, #4]
 8009b94:	681b      	ldr	r3, [r3, #0]
 8009b96:	4619      	mov	r1, r3
 8009b98:	4b54      	ldr	r3, [pc, #336]	; (8009cec <HAL_DMA_DeInit+0x1098>)
 8009b9a:	4299      	cmp	r1, r3
 8009b9c:	d036      	beq.n	8009c0c <HAL_DMA_DeInit+0xfb8>
 8009b9e:	687b      	ldr	r3, [r7, #4]
 8009ba0:	681b      	ldr	r3, [r3, #0]
 8009ba2:	4619      	mov	r1, r3
 8009ba4:	4b52      	ldr	r3, [pc, #328]	; (8009cf0 <HAL_DMA_DeInit+0x109c>)
 8009ba6:	4299      	cmp	r1, r3
 8009ba8:	d02e      	beq.n	8009c08 <HAL_DMA_DeInit+0xfb4>
 8009baa:	687b      	ldr	r3, [r7, #4]
 8009bac:	681b      	ldr	r3, [r3, #0]
 8009bae:	4619      	mov	r1, r3
 8009bb0:	4b50      	ldr	r3, [pc, #320]	; (8009cf4 <HAL_DMA_DeInit+0x10a0>)
 8009bb2:	4299      	cmp	r1, r3
 8009bb4:	d026      	beq.n	8009c04 <HAL_DMA_DeInit+0xfb0>
 8009bb6:	687b      	ldr	r3, [r7, #4]
 8009bb8:	681b      	ldr	r3, [r3, #0]
 8009bba:	4619      	mov	r1, r3
 8009bbc:	4b4e      	ldr	r3, [pc, #312]	; (8009cf8 <HAL_DMA_DeInit+0x10a4>)
 8009bbe:	4299      	cmp	r1, r3
 8009bc0:	d01d      	beq.n	8009bfe <HAL_DMA_DeInit+0xfaa>
 8009bc2:	687b      	ldr	r3, [r7, #4]
 8009bc4:	681b      	ldr	r3, [r3, #0]
 8009bc6:	4619      	mov	r1, r3
 8009bc8:	4b4c      	ldr	r3, [pc, #304]	; (8009cfc <HAL_DMA_DeInit+0x10a8>)
 8009bca:	4299      	cmp	r1, r3
 8009bcc:	d014      	beq.n	8009bf8 <HAL_DMA_DeInit+0xfa4>
 8009bce:	687b      	ldr	r3, [r7, #4]
 8009bd0:	681b      	ldr	r3, [r3, #0]
 8009bd2:	4619      	mov	r1, r3
 8009bd4:	4b4a      	ldr	r3, [pc, #296]	; (8009d00 <HAL_DMA_DeInit+0x10ac>)
 8009bd6:	4299      	cmp	r1, r3
 8009bd8:	d00b      	beq.n	8009bf2 <HAL_DMA_DeInit+0xf9e>
 8009bda:	687b      	ldr	r3, [r7, #4]
 8009bdc:	681b      	ldr	r3, [r3, #0]
 8009bde:	4619      	mov	r1, r3
 8009be0:	4b48      	ldr	r3, [pc, #288]	; (8009d04 <HAL_DMA_DeInit+0x10b0>)
 8009be2:	4299      	cmp	r1, r3
 8009be4:	d102      	bne.n	8009bec <HAL_DMA_DeInit+0xf98>
 8009be6:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009bea:	e01a      	b.n	8009c22 <HAL_DMA_DeInit+0xfce>
 8009bec:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8009bf0:	e017      	b.n	8009c22 <HAL_DMA_DeInit+0xfce>
 8009bf2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009bf6:	e014      	b.n	8009c22 <HAL_DMA_DeInit+0xfce>
 8009bf8:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009bfc:	e011      	b.n	8009c22 <HAL_DMA_DeInit+0xfce>
 8009bfe:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009c02:	e00e      	b.n	8009c22 <HAL_DMA_DeInit+0xfce>
 8009c04:	2340      	movs	r3, #64	; 0x40
 8009c06:	e00c      	b.n	8009c22 <HAL_DMA_DeInit+0xfce>
 8009c08:	2340      	movs	r3, #64	; 0x40
 8009c0a:	e00a      	b.n	8009c22 <HAL_DMA_DeInit+0xfce>
 8009c0c:	2340      	movs	r3, #64	; 0x40
 8009c0e:	e008      	b.n	8009c22 <HAL_DMA_DeInit+0xfce>
 8009c10:	2340      	movs	r3, #64	; 0x40
 8009c12:	e006      	b.n	8009c22 <HAL_DMA_DeInit+0xfce>
 8009c14:	4b2d      	ldr	r3, [pc, #180]	; (8009ccc <HAL_DMA_DeInit+0x1078>)
 8009c16:	e004      	b.n	8009c22 <HAL_DMA_DeInit+0xfce>
 8009c18:	4b2c      	ldr	r3, [pc, #176]	; (8009ccc <HAL_DMA_DeInit+0x1078>)
 8009c1a:	e002      	b.n	8009c22 <HAL_DMA_DeInit+0xfce>
 8009c1c:	4b2b      	ldr	r3, [pc, #172]	; (8009ccc <HAL_DMA_DeInit+0x1078>)
 8009c1e:	e000      	b.n	8009c22 <HAL_DMA_DeInit+0xfce>
 8009c20:	4b2a      	ldr	r3, [pc, #168]	; (8009ccc <HAL_DMA_DeInit+0x1078>)
 8009c22:	6093      	str	r3, [r2, #8]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8009c24:	687b      	ldr	r3, [r7, #4]
 8009c26:	681b      	ldr	r3, [r3, #0]
 8009c28:	461a      	mov	r2, r3
 8009c2a:	4b37      	ldr	r3, [pc, #220]	; (8009d08 <HAL_DMA_DeInit+0x10b4>)
 8009c2c:	429a      	cmp	r2, r3
 8009c2e:	f240 8090 	bls.w	8009d52 <HAL_DMA_DeInit+0x10fe>
 8009c32:	4a36      	ldr	r2, [pc, #216]	; (8009d0c <HAL_DMA_DeInit+0x10b8>)
 8009c34:	687b      	ldr	r3, [r7, #4]
 8009c36:	681b      	ldr	r3, [r3, #0]
 8009c38:	4619      	mov	r1, r3
 8009c3a:	4b27      	ldr	r3, [pc, #156]	; (8009cd8 <HAL_DMA_DeInit+0x1084>)
 8009c3c:	4299      	cmp	r1, r3
 8009c3e:	f000 8085 	beq.w	8009d4c <HAL_DMA_DeInit+0x10f8>
 8009c42:	687b      	ldr	r3, [r7, #4]
 8009c44:	681b      	ldr	r3, [r3, #0]
 8009c46:	4619      	mov	r1, r3
 8009c48:	4b24      	ldr	r3, [pc, #144]	; (8009cdc <HAL_DMA_DeInit+0x1088>)
 8009c4a:	4299      	cmp	r1, r3
 8009c4c:	d07c      	beq.n	8009d48 <HAL_DMA_DeInit+0x10f4>
 8009c4e:	687b      	ldr	r3, [r7, #4]
 8009c50:	681b      	ldr	r3, [r3, #0]
 8009c52:	4619      	mov	r1, r3
 8009c54:	4b22      	ldr	r3, [pc, #136]	; (8009ce0 <HAL_DMA_DeInit+0x108c>)
 8009c56:	4299      	cmp	r1, r3
 8009c58:	d074      	beq.n	8009d44 <HAL_DMA_DeInit+0x10f0>
 8009c5a:	687b      	ldr	r3, [r7, #4]
 8009c5c:	681b      	ldr	r3, [r3, #0]
 8009c5e:	4619      	mov	r1, r3
 8009c60:	4b20      	ldr	r3, [pc, #128]	; (8009ce4 <HAL_DMA_DeInit+0x1090>)
 8009c62:	4299      	cmp	r1, r3
 8009c64:	d06c      	beq.n	8009d40 <HAL_DMA_DeInit+0x10ec>
 8009c66:	687b      	ldr	r3, [r7, #4]
 8009c68:	681b      	ldr	r3, [r3, #0]
 8009c6a:	4619      	mov	r1, r3
 8009c6c:	4b1e      	ldr	r3, [pc, #120]	; (8009ce8 <HAL_DMA_DeInit+0x1094>)
 8009c6e:	4299      	cmp	r1, r3
 8009c70:	d063      	beq.n	8009d3a <HAL_DMA_DeInit+0x10e6>
 8009c72:	687b      	ldr	r3, [r7, #4]
 8009c74:	681b      	ldr	r3, [r3, #0]
 8009c76:	4619      	mov	r1, r3
 8009c78:	4b1c      	ldr	r3, [pc, #112]	; (8009cec <HAL_DMA_DeInit+0x1098>)
 8009c7a:	4299      	cmp	r1, r3
 8009c7c:	d05a      	beq.n	8009d34 <HAL_DMA_DeInit+0x10e0>
 8009c7e:	687b      	ldr	r3, [r7, #4]
 8009c80:	681b      	ldr	r3, [r3, #0]
 8009c82:	4619      	mov	r1, r3
 8009c84:	4b1a      	ldr	r3, [pc, #104]	; (8009cf0 <HAL_DMA_DeInit+0x109c>)
 8009c86:	4299      	cmp	r1, r3
 8009c88:	d051      	beq.n	8009d2e <HAL_DMA_DeInit+0x10da>
 8009c8a:	687b      	ldr	r3, [r7, #4]
 8009c8c:	681b      	ldr	r3, [r3, #0]
 8009c8e:	4619      	mov	r1, r3
 8009c90:	4b18      	ldr	r3, [pc, #96]	; (8009cf4 <HAL_DMA_DeInit+0x10a0>)
 8009c92:	4299      	cmp	r1, r3
 8009c94:	d048      	beq.n	8009d28 <HAL_DMA_DeInit+0x10d4>
 8009c96:	687b      	ldr	r3, [r7, #4]
 8009c98:	681b      	ldr	r3, [r3, #0]
 8009c9a:	4619      	mov	r1, r3
 8009c9c:	4b16      	ldr	r3, [pc, #88]	; (8009cf8 <HAL_DMA_DeInit+0x10a4>)
 8009c9e:	4299      	cmp	r1, r3
 8009ca0:	d03f      	beq.n	8009d22 <HAL_DMA_DeInit+0x10ce>
 8009ca2:	687b      	ldr	r3, [r7, #4]
 8009ca4:	681b      	ldr	r3, [r3, #0]
 8009ca6:	4619      	mov	r1, r3
 8009ca8:	4b14      	ldr	r3, [pc, #80]	; (8009cfc <HAL_DMA_DeInit+0x10a8>)
 8009caa:	4299      	cmp	r1, r3
 8009cac:	d036      	beq.n	8009d1c <HAL_DMA_DeInit+0x10c8>
 8009cae:	687b      	ldr	r3, [r7, #4]
 8009cb0:	681b      	ldr	r3, [r3, #0]
 8009cb2:	4619      	mov	r1, r3
 8009cb4:	4b12      	ldr	r3, [pc, #72]	; (8009d00 <HAL_DMA_DeInit+0x10ac>)
 8009cb6:	4299      	cmp	r1, r3
 8009cb8:	d02d      	beq.n	8009d16 <HAL_DMA_DeInit+0x10c2>
 8009cba:	687b      	ldr	r3, [r7, #4]
 8009cbc:	681b      	ldr	r3, [r3, #0]
 8009cbe:	4619      	mov	r1, r3
 8009cc0:	4b10      	ldr	r3, [pc, #64]	; (8009d04 <HAL_DMA_DeInit+0x10b0>)
 8009cc2:	4299      	cmp	r1, r3
 8009cc4:	d124      	bne.n	8009d10 <HAL_DMA_DeInit+0x10bc>
 8009cc6:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009cca:	e040      	b.n	8009d4e <HAL_DMA_DeInit+0x10fa>
 8009ccc:	00800001 	.word	0x00800001
 8009cd0:	40026058 	.word	0x40026058
 8009cd4:	40026000 	.word	0x40026000
 8009cd8:	40026010 	.word	0x40026010
 8009cdc:	40026410 	.word	0x40026410
 8009ce0:	40026070 	.word	0x40026070
 8009ce4:	40026470 	.word	0x40026470
 8009ce8:	40026028 	.word	0x40026028
 8009cec:	40026428 	.word	0x40026428
 8009cf0:	40026088 	.word	0x40026088
 8009cf4:	40026488 	.word	0x40026488
 8009cf8:	40026040 	.word	0x40026040
 8009cfc:	40026440 	.word	0x40026440
 8009d00:	400260a0 	.word	0x400260a0
 8009d04:	400264a0 	.word	0x400264a0
 8009d08:	40026458 	.word	0x40026458
 8009d0c:	40026400 	.word	0x40026400
 8009d10:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8009d14:	e01b      	b.n	8009d4e <HAL_DMA_DeInit+0x10fa>
 8009d16:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009d1a:	e018      	b.n	8009d4e <HAL_DMA_DeInit+0x10fa>
 8009d1c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009d20:	e015      	b.n	8009d4e <HAL_DMA_DeInit+0x10fa>
 8009d22:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009d26:	e012      	b.n	8009d4e <HAL_DMA_DeInit+0x10fa>
 8009d28:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009d2c:	e00f      	b.n	8009d4e <HAL_DMA_DeInit+0x10fa>
 8009d2e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009d32:	e00c      	b.n	8009d4e <HAL_DMA_DeInit+0x10fa>
 8009d34:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009d38:	e009      	b.n	8009d4e <HAL_DMA_DeInit+0x10fa>
 8009d3a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009d3e:	e006      	b.n	8009d4e <HAL_DMA_DeInit+0x10fa>
 8009d40:	2310      	movs	r3, #16
 8009d42:	e004      	b.n	8009d4e <HAL_DMA_DeInit+0x10fa>
 8009d44:	2310      	movs	r3, #16
 8009d46:	e002      	b.n	8009d4e <HAL_DMA_DeInit+0x10fa>
 8009d48:	2310      	movs	r3, #16
 8009d4a:	e000      	b.n	8009d4e <HAL_DMA_DeInit+0x10fa>
 8009d4c:	2310      	movs	r3, #16
 8009d4e:	60d3      	str	r3, [r2, #12]
 8009d50:	e173      	b.n	800a03a <HAL_DMA_DeInit+0x13e6>
 8009d52:	687b      	ldr	r3, [r7, #4]
 8009d54:	681b      	ldr	r3, [r3, #0]
 8009d56:	461a      	mov	r2, r3
 8009d58:	4b9f      	ldr	r3, [pc, #636]	; (8009fd8 <HAL_DMA_DeInit+0x1384>)
 8009d5a:	429a      	cmp	r2, r3
 8009d5c:	d96c      	bls.n	8009e38 <HAL_DMA_DeInit+0x11e4>
 8009d5e:	4a9f      	ldr	r2, [pc, #636]	; (8009fdc <HAL_DMA_DeInit+0x1388>)
 8009d60:	687b      	ldr	r3, [r7, #4]
 8009d62:	681b      	ldr	r3, [r3, #0]
 8009d64:	4619      	mov	r1, r3
 8009d66:	4b9e      	ldr	r3, [pc, #632]	; (8009fe0 <HAL_DMA_DeInit+0x138c>)
 8009d68:	4299      	cmp	r1, r3
 8009d6a:	d062      	beq.n	8009e32 <HAL_DMA_DeInit+0x11de>
 8009d6c:	687b      	ldr	r3, [r7, #4]
 8009d6e:	681b      	ldr	r3, [r3, #0]
 8009d70:	4619      	mov	r1, r3
 8009d72:	4b9c      	ldr	r3, [pc, #624]	; (8009fe4 <HAL_DMA_DeInit+0x1390>)
 8009d74:	4299      	cmp	r1, r3
 8009d76:	d05a      	beq.n	8009e2e <HAL_DMA_DeInit+0x11da>
 8009d78:	687b      	ldr	r3, [r7, #4]
 8009d7a:	681b      	ldr	r3, [r3, #0]
 8009d7c:	4619      	mov	r1, r3
 8009d7e:	4b9a      	ldr	r3, [pc, #616]	; (8009fe8 <HAL_DMA_DeInit+0x1394>)
 8009d80:	4299      	cmp	r1, r3
 8009d82:	d052      	beq.n	8009e2a <HAL_DMA_DeInit+0x11d6>
 8009d84:	687b      	ldr	r3, [r7, #4]
 8009d86:	681b      	ldr	r3, [r3, #0]
 8009d88:	4619      	mov	r1, r3
 8009d8a:	4b98      	ldr	r3, [pc, #608]	; (8009fec <HAL_DMA_DeInit+0x1398>)
 8009d8c:	4299      	cmp	r1, r3
 8009d8e:	d04a      	beq.n	8009e26 <HAL_DMA_DeInit+0x11d2>
 8009d90:	687b      	ldr	r3, [r7, #4]
 8009d92:	681b      	ldr	r3, [r3, #0]
 8009d94:	4619      	mov	r1, r3
 8009d96:	4b96      	ldr	r3, [pc, #600]	; (8009ff0 <HAL_DMA_DeInit+0x139c>)
 8009d98:	4299      	cmp	r1, r3
 8009d9a:	d041      	beq.n	8009e20 <HAL_DMA_DeInit+0x11cc>
 8009d9c:	687b      	ldr	r3, [r7, #4]
 8009d9e:	681b      	ldr	r3, [r3, #0]
 8009da0:	4619      	mov	r1, r3
 8009da2:	4b94      	ldr	r3, [pc, #592]	; (8009ff4 <HAL_DMA_DeInit+0x13a0>)
 8009da4:	4299      	cmp	r1, r3
 8009da6:	d038      	beq.n	8009e1a <HAL_DMA_DeInit+0x11c6>
 8009da8:	687b      	ldr	r3, [r7, #4]
 8009daa:	681b      	ldr	r3, [r3, #0]
 8009dac:	4619      	mov	r1, r3
 8009dae:	4b92      	ldr	r3, [pc, #584]	; (8009ff8 <HAL_DMA_DeInit+0x13a4>)
 8009db0:	4299      	cmp	r1, r3
 8009db2:	d02f      	beq.n	8009e14 <HAL_DMA_DeInit+0x11c0>
 8009db4:	687b      	ldr	r3, [r7, #4]
 8009db6:	681b      	ldr	r3, [r3, #0]
 8009db8:	4619      	mov	r1, r3
 8009dba:	4b90      	ldr	r3, [pc, #576]	; (8009ffc <HAL_DMA_DeInit+0x13a8>)
 8009dbc:	4299      	cmp	r1, r3
 8009dbe:	d026      	beq.n	8009e0e <HAL_DMA_DeInit+0x11ba>
 8009dc0:	687b      	ldr	r3, [r7, #4]
 8009dc2:	681b      	ldr	r3, [r3, #0]
 8009dc4:	4619      	mov	r1, r3
 8009dc6:	4b8e      	ldr	r3, [pc, #568]	; (800a000 <HAL_DMA_DeInit+0x13ac>)
 8009dc8:	4299      	cmp	r1, r3
 8009dca:	d01d      	beq.n	8009e08 <HAL_DMA_DeInit+0x11b4>
 8009dcc:	687b      	ldr	r3, [r7, #4]
 8009dce:	681b      	ldr	r3, [r3, #0]
 8009dd0:	4619      	mov	r1, r3
 8009dd2:	4b8c      	ldr	r3, [pc, #560]	; (800a004 <HAL_DMA_DeInit+0x13b0>)
 8009dd4:	4299      	cmp	r1, r3
 8009dd6:	d014      	beq.n	8009e02 <HAL_DMA_DeInit+0x11ae>
 8009dd8:	687b      	ldr	r3, [r7, #4]
 8009dda:	681b      	ldr	r3, [r3, #0]
 8009ddc:	4619      	mov	r1, r3
 8009dde:	4b8a      	ldr	r3, [pc, #552]	; (800a008 <HAL_DMA_DeInit+0x13b4>)
 8009de0:	4299      	cmp	r1, r3
 8009de2:	d00b      	beq.n	8009dfc <HAL_DMA_DeInit+0x11a8>
 8009de4:	687b      	ldr	r3, [r7, #4]
 8009de6:	681b      	ldr	r3, [r3, #0]
 8009de8:	4619      	mov	r1, r3
 8009dea:	4b88      	ldr	r3, [pc, #544]	; (800a00c <HAL_DMA_DeInit+0x13b8>)
 8009dec:	4299      	cmp	r1, r3
 8009dee:	d102      	bne.n	8009df6 <HAL_DMA_DeInit+0x11a2>
 8009df0:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009df4:	e01e      	b.n	8009e34 <HAL_DMA_DeInit+0x11e0>
 8009df6:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8009dfa:	e01b      	b.n	8009e34 <HAL_DMA_DeInit+0x11e0>
 8009dfc:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009e00:	e018      	b.n	8009e34 <HAL_DMA_DeInit+0x11e0>
 8009e02:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009e06:	e015      	b.n	8009e34 <HAL_DMA_DeInit+0x11e0>
 8009e08:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009e0c:	e012      	b.n	8009e34 <HAL_DMA_DeInit+0x11e0>
 8009e0e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009e12:	e00f      	b.n	8009e34 <HAL_DMA_DeInit+0x11e0>
 8009e14:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009e18:	e00c      	b.n	8009e34 <HAL_DMA_DeInit+0x11e0>
 8009e1a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009e1e:	e009      	b.n	8009e34 <HAL_DMA_DeInit+0x11e0>
 8009e20:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009e24:	e006      	b.n	8009e34 <HAL_DMA_DeInit+0x11e0>
 8009e26:	2310      	movs	r3, #16
 8009e28:	e004      	b.n	8009e34 <HAL_DMA_DeInit+0x11e0>
 8009e2a:	2310      	movs	r3, #16
 8009e2c:	e002      	b.n	8009e34 <HAL_DMA_DeInit+0x11e0>
 8009e2e:	2310      	movs	r3, #16
 8009e30:	e000      	b.n	8009e34 <HAL_DMA_DeInit+0x11e0>
 8009e32:	2310      	movs	r3, #16
 8009e34:	6093      	str	r3, [r2, #8]
 8009e36:	e100      	b.n	800a03a <HAL_DMA_DeInit+0x13e6>
 8009e38:	687b      	ldr	r3, [r7, #4]
 8009e3a:	681b      	ldr	r3, [r3, #0]
 8009e3c:	461a      	mov	r2, r3
 8009e3e:	4b74      	ldr	r3, [pc, #464]	; (800a010 <HAL_DMA_DeInit+0x13bc>)
 8009e40:	429a      	cmp	r2, r3
 8009e42:	d96c      	bls.n	8009f1e <HAL_DMA_DeInit+0x12ca>
 8009e44:	4a73      	ldr	r2, [pc, #460]	; (800a014 <HAL_DMA_DeInit+0x13c0>)
 8009e46:	687b      	ldr	r3, [r7, #4]
 8009e48:	681b      	ldr	r3, [r3, #0]
 8009e4a:	4619      	mov	r1, r3
 8009e4c:	4b64      	ldr	r3, [pc, #400]	; (8009fe0 <HAL_DMA_DeInit+0x138c>)
 8009e4e:	4299      	cmp	r1, r3
 8009e50:	d062      	beq.n	8009f18 <HAL_DMA_DeInit+0x12c4>
 8009e52:	687b      	ldr	r3, [r7, #4]
 8009e54:	681b      	ldr	r3, [r3, #0]
 8009e56:	4619      	mov	r1, r3
 8009e58:	4b62      	ldr	r3, [pc, #392]	; (8009fe4 <HAL_DMA_DeInit+0x1390>)
 8009e5a:	4299      	cmp	r1, r3
 8009e5c:	d05a      	beq.n	8009f14 <HAL_DMA_DeInit+0x12c0>
 8009e5e:	687b      	ldr	r3, [r7, #4]
 8009e60:	681b      	ldr	r3, [r3, #0]
 8009e62:	4619      	mov	r1, r3
 8009e64:	4b60      	ldr	r3, [pc, #384]	; (8009fe8 <HAL_DMA_DeInit+0x1394>)
 8009e66:	4299      	cmp	r1, r3
 8009e68:	d052      	beq.n	8009f10 <HAL_DMA_DeInit+0x12bc>
 8009e6a:	687b      	ldr	r3, [r7, #4]
 8009e6c:	681b      	ldr	r3, [r3, #0]
 8009e6e:	4619      	mov	r1, r3
 8009e70:	4b5e      	ldr	r3, [pc, #376]	; (8009fec <HAL_DMA_DeInit+0x1398>)
 8009e72:	4299      	cmp	r1, r3
 8009e74:	d04a      	beq.n	8009f0c <HAL_DMA_DeInit+0x12b8>
 8009e76:	687b      	ldr	r3, [r7, #4]
 8009e78:	681b      	ldr	r3, [r3, #0]
 8009e7a:	4619      	mov	r1, r3
 8009e7c:	4b5c      	ldr	r3, [pc, #368]	; (8009ff0 <HAL_DMA_DeInit+0x139c>)
 8009e7e:	4299      	cmp	r1, r3
 8009e80:	d041      	beq.n	8009f06 <HAL_DMA_DeInit+0x12b2>
 8009e82:	687b      	ldr	r3, [r7, #4]
 8009e84:	681b      	ldr	r3, [r3, #0]
 8009e86:	4619      	mov	r1, r3
 8009e88:	4b5a      	ldr	r3, [pc, #360]	; (8009ff4 <HAL_DMA_DeInit+0x13a0>)
 8009e8a:	4299      	cmp	r1, r3
 8009e8c:	d038      	beq.n	8009f00 <HAL_DMA_DeInit+0x12ac>
 8009e8e:	687b      	ldr	r3, [r7, #4]
 8009e90:	681b      	ldr	r3, [r3, #0]
 8009e92:	4619      	mov	r1, r3
 8009e94:	4b58      	ldr	r3, [pc, #352]	; (8009ff8 <HAL_DMA_DeInit+0x13a4>)
 8009e96:	4299      	cmp	r1, r3
 8009e98:	d02f      	beq.n	8009efa <HAL_DMA_DeInit+0x12a6>
 8009e9a:	687b      	ldr	r3, [r7, #4]
 8009e9c:	681b      	ldr	r3, [r3, #0]
 8009e9e:	4619      	mov	r1, r3
 8009ea0:	4b56      	ldr	r3, [pc, #344]	; (8009ffc <HAL_DMA_DeInit+0x13a8>)
 8009ea2:	4299      	cmp	r1, r3
 8009ea4:	d026      	beq.n	8009ef4 <HAL_DMA_DeInit+0x12a0>
 8009ea6:	687b      	ldr	r3, [r7, #4]
 8009ea8:	681b      	ldr	r3, [r3, #0]
 8009eaa:	4619      	mov	r1, r3
 8009eac:	4b54      	ldr	r3, [pc, #336]	; (800a000 <HAL_DMA_DeInit+0x13ac>)
 8009eae:	4299      	cmp	r1, r3
 8009eb0:	d01d      	beq.n	8009eee <HAL_DMA_DeInit+0x129a>
 8009eb2:	687b      	ldr	r3, [r7, #4]
 8009eb4:	681b      	ldr	r3, [r3, #0]
 8009eb6:	4619      	mov	r1, r3
 8009eb8:	4b52      	ldr	r3, [pc, #328]	; (800a004 <HAL_DMA_DeInit+0x13b0>)
 8009eba:	4299      	cmp	r1, r3
 8009ebc:	d014      	beq.n	8009ee8 <HAL_DMA_DeInit+0x1294>
 8009ebe:	687b      	ldr	r3, [r7, #4]
 8009ec0:	681b      	ldr	r3, [r3, #0]
 8009ec2:	4619      	mov	r1, r3
 8009ec4:	4b50      	ldr	r3, [pc, #320]	; (800a008 <HAL_DMA_DeInit+0x13b4>)
 8009ec6:	4299      	cmp	r1, r3
 8009ec8:	d00b      	beq.n	8009ee2 <HAL_DMA_DeInit+0x128e>
 8009eca:	687b      	ldr	r3, [r7, #4]
 8009ecc:	681b      	ldr	r3, [r3, #0]
 8009ece:	4619      	mov	r1, r3
 8009ed0:	4b4e      	ldr	r3, [pc, #312]	; (800a00c <HAL_DMA_DeInit+0x13b8>)
 8009ed2:	4299      	cmp	r1, r3
 8009ed4:	d102      	bne.n	8009edc <HAL_DMA_DeInit+0x1288>
 8009ed6:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009eda:	e01e      	b.n	8009f1a <HAL_DMA_DeInit+0x12c6>
 8009edc:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8009ee0:	e01b      	b.n	8009f1a <HAL_DMA_DeInit+0x12c6>
 8009ee2:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009ee6:	e018      	b.n	8009f1a <HAL_DMA_DeInit+0x12c6>
 8009ee8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009eec:	e015      	b.n	8009f1a <HAL_DMA_DeInit+0x12c6>
 8009eee:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009ef2:	e012      	b.n	8009f1a <HAL_DMA_DeInit+0x12c6>
 8009ef4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009ef8:	e00f      	b.n	8009f1a <HAL_DMA_DeInit+0x12c6>
 8009efa:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009efe:	e00c      	b.n	8009f1a <HAL_DMA_DeInit+0x12c6>
 8009f00:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009f04:	e009      	b.n	8009f1a <HAL_DMA_DeInit+0x12c6>
 8009f06:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009f0a:	e006      	b.n	8009f1a <HAL_DMA_DeInit+0x12c6>
 8009f0c:	2310      	movs	r3, #16
 8009f0e:	e004      	b.n	8009f1a <HAL_DMA_DeInit+0x12c6>
 8009f10:	2310      	movs	r3, #16
 8009f12:	e002      	b.n	8009f1a <HAL_DMA_DeInit+0x12c6>
 8009f14:	2310      	movs	r3, #16
 8009f16:	e000      	b.n	8009f1a <HAL_DMA_DeInit+0x12c6>
 8009f18:	2310      	movs	r3, #16
 8009f1a:	60d3      	str	r3, [r2, #12]
 8009f1c:	e08d      	b.n	800a03a <HAL_DMA_DeInit+0x13e6>
 8009f1e:	4a3d      	ldr	r2, [pc, #244]	; (800a014 <HAL_DMA_DeInit+0x13c0>)
 8009f20:	687b      	ldr	r3, [r7, #4]
 8009f22:	681b      	ldr	r3, [r3, #0]
 8009f24:	4619      	mov	r1, r3
 8009f26:	4b2e      	ldr	r3, [pc, #184]	; (8009fe0 <HAL_DMA_DeInit+0x138c>)
 8009f28:	4299      	cmp	r1, r3
 8009f2a:	f000 8084 	beq.w	800a036 <HAL_DMA_DeInit+0x13e2>
 8009f2e:	687b      	ldr	r3, [r7, #4]
 8009f30:	681b      	ldr	r3, [r3, #0]
 8009f32:	4619      	mov	r1, r3
 8009f34:	4b2b      	ldr	r3, [pc, #172]	; (8009fe4 <HAL_DMA_DeInit+0x1390>)
 8009f36:	4299      	cmp	r1, r3
 8009f38:	d07b      	beq.n	800a032 <HAL_DMA_DeInit+0x13de>
 8009f3a:	687b      	ldr	r3, [r7, #4]
 8009f3c:	681b      	ldr	r3, [r3, #0]
 8009f3e:	4619      	mov	r1, r3
 8009f40:	4b29      	ldr	r3, [pc, #164]	; (8009fe8 <HAL_DMA_DeInit+0x1394>)
 8009f42:	4299      	cmp	r1, r3
 8009f44:	d073      	beq.n	800a02e <HAL_DMA_DeInit+0x13da>
 8009f46:	687b      	ldr	r3, [r7, #4]
 8009f48:	681b      	ldr	r3, [r3, #0]
 8009f4a:	4619      	mov	r1, r3
 8009f4c:	4b27      	ldr	r3, [pc, #156]	; (8009fec <HAL_DMA_DeInit+0x1398>)
 8009f4e:	4299      	cmp	r1, r3
 8009f50:	d06b      	beq.n	800a02a <HAL_DMA_DeInit+0x13d6>
 8009f52:	687b      	ldr	r3, [r7, #4]
 8009f54:	681b      	ldr	r3, [r3, #0]
 8009f56:	4619      	mov	r1, r3
 8009f58:	4b25      	ldr	r3, [pc, #148]	; (8009ff0 <HAL_DMA_DeInit+0x139c>)
 8009f5a:	4299      	cmp	r1, r3
 8009f5c:	d062      	beq.n	800a024 <HAL_DMA_DeInit+0x13d0>
 8009f5e:	687b      	ldr	r3, [r7, #4]
 8009f60:	681b      	ldr	r3, [r3, #0]
 8009f62:	4619      	mov	r1, r3
 8009f64:	4b23      	ldr	r3, [pc, #140]	; (8009ff4 <HAL_DMA_DeInit+0x13a0>)
 8009f66:	4299      	cmp	r1, r3
 8009f68:	d059      	beq.n	800a01e <HAL_DMA_DeInit+0x13ca>
 8009f6a:	687b      	ldr	r3, [r7, #4]
 8009f6c:	681b      	ldr	r3, [r3, #0]
 8009f6e:	4619      	mov	r1, r3
 8009f70:	4b21      	ldr	r3, [pc, #132]	; (8009ff8 <HAL_DMA_DeInit+0x13a4>)
 8009f72:	4299      	cmp	r1, r3
 8009f74:	d050      	beq.n	800a018 <HAL_DMA_DeInit+0x13c4>
 8009f76:	687b      	ldr	r3, [r7, #4]
 8009f78:	681b      	ldr	r3, [r3, #0]
 8009f7a:	4619      	mov	r1, r3
 8009f7c:	4b1f      	ldr	r3, [pc, #124]	; (8009ffc <HAL_DMA_DeInit+0x13a8>)
 8009f7e:	4299      	cmp	r1, r3
 8009f80:	d026      	beq.n	8009fd0 <HAL_DMA_DeInit+0x137c>
 8009f82:	687b      	ldr	r3, [r7, #4]
 8009f84:	681b      	ldr	r3, [r3, #0]
 8009f86:	4619      	mov	r1, r3
 8009f88:	4b1d      	ldr	r3, [pc, #116]	; (800a000 <HAL_DMA_DeInit+0x13ac>)
 8009f8a:	4299      	cmp	r1, r3
 8009f8c:	d01d      	beq.n	8009fca <HAL_DMA_DeInit+0x1376>
 8009f8e:	687b      	ldr	r3, [r7, #4]
 8009f90:	681b      	ldr	r3, [r3, #0]
 8009f92:	4619      	mov	r1, r3
 8009f94:	4b1b      	ldr	r3, [pc, #108]	; (800a004 <HAL_DMA_DeInit+0x13b0>)
 8009f96:	4299      	cmp	r1, r3
 8009f98:	d014      	beq.n	8009fc4 <HAL_DMA_DeInit+0x1370>
 8009f9a:	687b      	ldr	r3, [r7, #4]
 8009f9c:	681b      	ldr	r3, [r3, #0]
 8009f9e:	4619      	mov	r1, r3
 8009fa0:	4b19      	ldr	r3, [pc, #100]	; (800a008 <HAL_DMA_DeInit+0x13b4>)
 8009fa2:	4299      	cmp	r1, r3
 8009fa4:	d00b      	beq.n	8009fbe <HAL_DMA_DeInit+0x136a>
 8009fa6:	687b      	ldr	r3, [r7, #4]
 8009fa8:	681b      	ldr	r3, [r3, #0]
 8009faa:	4619      	mov	r1, r3
 8009fac:	4b17      	ldr	r3, [pc, #92]	; (800a00c <HAL_DMA_DeInit+0x13b8>)
 8009fae:	4299      	cmp	r1, r3
 8009fb0:	d102      	bne.n	8009fb8 <HAL_DMA_DeInit+0x1364>
 8009fb2:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009fb6:	e03f      	b.n	800a038 <HAL_DMA_DeInit+0x13e4>
 8009fb8:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8009fbc:	e03c      	b.n	800a038 <HAL_DMA_DeInit+0x13e4>
 8009fbe:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009fc2:	e039      	b.n	800a038 <HAL_DMA_DeInit+0x13e4>
 8009fc4:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009fc8:	e036      	b.n	800a038 <HAL_DMA_DeInit+0x13e4>
 8009fca:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009fce:	e033      	b.n	800a038 <HAL_DMA_DeInit+0x13e4>
 8009fd0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009fd4:	e030      	b.n	800a038 <HAL_DMA_DeInit+0x13e4>
 8009fd6:	bf00      	nop
 8009fd8:	400260b8 	.word	0x400260b8
 8009fdc:	40026400 	.word	0x40026400
 8009fe0:	40026010 	.word	0x40026010
 8009fe4:	40026410 	.word	0x40026410
 8009fe8:	40026070 	.word	0x40026070
 8009fec:	40026470 	.word	0x40026470
 8009ff0:	40026028 	.word	0x40026028
 8009ff4:	40026428 	.word	0x40026428
 8009ff8:	40026088 	.word	0x40026088
 8009ffc:	40026488 	.word	0x40026488
 800a000:	40026040 	.word	0x40026040
 800a004:	40026440 	.word	0x40026440
 800a008:	400260a0 	.word	0x400260a0
 800a00c:	400264a0 	.word	0x400264a0
 800a010:	40026058 	.word	0x40026058
 800a014:	40026000 	.word	0x40026000
 800a018:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800a01c:	e00c      	b.n	800a038 <HAL_DMA_DeInit+0x13e4>
 800a01e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800a022:	e009      	b.n	800a038 <HAL_DMA_DeInit+0x13e4>
 800a024:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800a028:	e006      	b.n	800a038 <HAL_DMA_DeInit+0x13e4>
 800a02a:	2310      	movs	r3, #16
 800a02c:	e004      	b.n	800a038 <HAL_DMA_DeInit+0x13e4>
 800a02e:	2310      	movs	r3, #16
 800a030:	e002      	b.n	800a038 <HAL_DMA_DeInit+0x13e4>
 800a032:	2310      	movs	r3, #16
 800a034:	e000      	b.n	800a038 <HAL_DMA_DeInit+0x13e4>
 800a036:	2310      	movs	r3, #16
 800a038:	6093      	str	r3, [r2, #8]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800a03a:	687b      	ldr	r3, [r7, #4]
 800a03c:	2200      	movs	r2, #0
 800a03e:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;
 800a040:	687b      	ldr	r3, [r7, #4]
 800a042:	2200      	movs	r2, #0
 800a044:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  /* Release Lock */
  __HAL_UNLOCK(hdma);
 800a048:	687b      	ldr	r3, [r7, #4]
 800a04a:	2200      	movs	r2, #0
 800a04c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return HAL_OK;
 800a050:	2300      	movs	r3, #0
}
 800a052:	4618      	mov	r0, r3
 800a054:	370c      	adds	r7, #12
 800a056:	46bd      	mov	sp, r7
 800a058:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a05c:	4770      	bx	lr
 800a05e:	bf00      	nop

0800a060 <HAL_DMA_Start_IT>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 800a060:	b580      	push	{r7, lr}
 800a062:	b084      	sub	sp, #16
 800a064:	af00      	add	r7, sp, #0
 800a066:	60f8      	str	r0, [r7, #12]
 800a068:	60b9      	str	r1, [r7, #8]
 800a06a:	607a      	str	r2, [r7, #4]
 800a06c:	603b      	str	r3, [r7, #0]
  /* Process locked */
  __HAL_LOCK(hdma);
 800a06e:	68fb      	ldr	r3, [r7, #12]
 800a070:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 800a074:	2b01      	cmp	r3, #1
 800a076:	d101      	bne.n	800a07c <HAL_DMA_Start_IT+0x1c>
 800a078:	2302      	movs	r3, #2
 800a07a:	e046      	b.n	800a10a <HAL_DMA_Start_IT+0xaa>
 800a07c:	68fb      	ldr	r3, [r7, #12]
 800a07e:	2201      	movs	r2, #1
 800a080:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 800a084:	68fb      	ldr	r3, [r7, #12]
 800a086:	2202      	movs	r2, #2
 800a088:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

   /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 800a08c:	68fb      	ldr	r3, [r7, #12]
 800a08e:	681b      	ldr	r3, [r3, #0]
 800a090:	68fa      	ldr	r2, [r7, #12]
 800a092:	6812      	ldr	r2, [r2, #0]
 800a094:	6812      	ldr	r2, [r2, #0]
 800a096:	f022 0201 	bic.w	r2, r2, #1
 800a09a:	601a      	str	r2, [r3, #0]

  /* Configure the source, destination address and the data length */
  DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 800a09c:	68f8      	ldr	r0, [r7, #12]
 800a09e:	68b9      	ldr	r1, [r7, #8]
 800a0a0:	687a      	ldr	r2, [r7, #4]
 800a0a2:	683b      	ldr	r3, [r7, #0]
 800a0a4:	f7fe fd3c 	bl	8008b20 <DMA_SetConfig>

  /* Enable the transfer complete interrupt */
  __HAL_DMA_ENABLE_IT(hdma, DMA_IT_TC);
 800a0a8:	68fb      	ldr	r3, [r7, #12]
 800a0aa:	681b      	ldr	r3, [r3, #0]
 800a0ac:	68fa      	ldr	r2, [r7, #12]
 800a0ae:	6812      	ldr	r2, [r2, #0]
 800a0b0:	6812      	ldr	r2, [r2, #0]
 800a0b2:	f042 0210 	orr.w	r2, r2, #16
 800a0b6:	601a      	str	r2, [r3, #0]

  /* Enable the Half transfer complete interrupt */
  __HAL_DMA_ENABLE_IT(hdma, DMA_IT_HT);  
 800a0b8:	68fb      	ldr	r3, [r7, #12]
 800a0ba:	681b      	ldr	r3, [r3, #0]
 800a0bc:	68fa      	ldr	r2, [r7, #12]
 800a0be:	6812      	ldr	r2, [r2, #0]
 800a0c0:	6812      	ldr	r2, [r2, #0]
 800a0c2:	f042 0208 	orr.w	r2, r2, #8
 800a0c6:	601a      	str	r2, [r3, #0]

  /* Enable the transfer Error interrupt */
  __HAL_DMA_ENABLE_IT(hdma, DMA_IT_TE);
 800a0c8:	68fb      	ldr	r3, [r7, #12]
 800a0ca:	681b      	ldr	r3, [r3, #0]
 800a0cc:	68fa      	ldr	r2, [r7, #12]
 800a0ce:	6812      	ldr	r2, [r2, #0]
 800a0d0:	6812      	ldr	r2, [r2, #0]
 800a0d2:	f042 0204 	orr.w	r2, r2, #4
 800a0d6:	601a      	str	r2, [r3, #0]

  /* Enable the FIFO Error interrupt */
  __HAL_DMA_ENABLE_IT(hdma, DMA_IT_FE);
 800a0d8:	68fb      	ldr	r3, [r7, #12]
 800a0da:	681b      	ldr	r3, [r3, #0]
 800a0dc:	68fa      	ldr	r2, [r7, #12]
 800a0de:	6812      	ldr	r2, [r2, #0]
 800a0e0:	6952      	ldr	r2, [r2, #20]
 800a0e2:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800a0e6:	615a      	str	r2, [r3, #20]

  /* Enable the direct mode Error interrupt */
  __HAL_DMA_ENABLE_IT(hdma, DMA_IT_DME);
 800a0e8:	68fb      	ldr	r3, [r7, #12]
 800a0ea:	681b      	ldr	r3, [r3, #0]
 800a0ec:	68fa      	ldr	r2, [r7, #12]
 800a0ee:	6812      	ldr	r2, [r2, #0]
 800a0f0:	6812      	ldr	r2, [r2, #0]
 800a0f2:	f042 0202 	orr.w	r2, r2, #2
 800a0f6:	601a      	str	r2, [r3, #0]

   /* Enable the Peripheral */
  __HAL_DMA_ENABLE(hdma);
 800a0f8:	68fb      	ldr	r3, [r7, #12]
 800a0fa:	681b      	ldr	r3, [r3, #0]
 800a0fc:	68fa      	ldr	r2, [r7, #12]
 800a0fe:	6812      	ldr	r2, [r2, #0]
 800a100:	6812      	ldr	r2, [r2, #0]
 800a102:	f042 0201 	orr.w	r2, r2, #1
 800a106:	601a      	str	r2, [r3, #0]

  return HAL_OK;
 800a108:	2300      	movs	r3, #0
} 
 800a10a:	4618      	mov	r0, r3
 800a10c:	3710      	adds	r7, #16
 800a10e:	46bd      	mov	sp, r7
 800a110:	bd80      	pop	{r7, pc}
 800a112:	bf00      	nop

0800a114 <HAL_DMA_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 800a114:	b580      	push	{r7, lr}
 800a116:	b082      	sub	sp, #8
 800a118:	af00      	add	r7, sp, #0
 800a11a:	6078      	str	r0, [r7, #4]
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 800a11c:	687b      	ldr	r3, [r7, #4]
 800a11e:	681b      	ldr	r3, [r3, #0]
 800a120:	461a      	mov	r2, r3
 800a122:	4b78      	ldr	r3, [pc, #480]	; (800a304 <HAL_DMA_IRQHandler+0x1f0>)
 800a124:	429a      	cmp	r2, r3
 800a126:	d972      	bls.n	800a20e <HAL_DMA_IRQHandler+0xfa>
 800a128:	4b77      	ldr	r3, [pc, #476]	; (800a308 <HAL_DMA_IRQHandler+0x1f4>)
 800a12a:	685a      	ldr	r2, [r3, #4]
 800a12c:	687b      	ldr	r3, [r7, #4]
 800a12e:	681b      	ldr	r3, [r3, #0]
 800a130:	4619      	mov	r1, r3
 800a132:	4b76      	ldr	r3, [pc, #472]	; (800a30c <HAL_DMA_IRQHandler+0x1f8>)
 800a134:	4299      	cmp	r1, r3
 800a136:	d062      	beq.n	800a1fe <HAL_DMA_IRQHandler+0xea>
 800a138:	687b      	ldr	r3, [r7, #4]
 800a13a:	681b      	ldr	r3, [r3, #0]
 800a13c:	4619      	mov	r1, r3
 800a13e:	4b74      	ldr	r3, [pc, #464]	; (800a310 <HAL_DMA_IRQHandler+0x1fc>)
 800a140:	4299      	cmp	r1, r3
 800a142:	d05a      	beq.n	800a1fa <HAL_DMA_IRQHandler+0xe6>
 800a144:	687b      	ldr	r3, [r7, #4]
 800a146:	681b      	ldr	r3, [r3, #0]
 800a148:	4619      	mov	r1, r3
 800a14a:	4b72      	ldr	r3, [pc, #456]	; (800a314 <HAL_DMA_IRQHandler+0x200>)
 800a14c:	4299      	cmp	r1, r3
 800a14e:	d052      	beq.n	800a1f6 <HAL_DMA_IRQHandler+0xe2>
 800a150:	687b      	ldr	r3, [r7, #4]
 800a152:	681b      	ldr	r3, [r3, #0]
 800a154:	4619      	mov	r1, r3
 800a156:	4b70      	ldr	r3, [pc, #448]	; (800a318 <HAL_DMA_IRQHandler+0x204>)
 800a158:	4299      	cmp	r1, r3
 800a15a:	d04a      	beq.n	800a1f2 <HAL_DMA_IRQHandler+0xde>
 800a15c:	687b      	ldr	r3, [r7, #4]
 800a15e:	681b      	ldr	r3, [r3, #0]
 800a160:	4619      	mov	r1, r3
 800a162:	4b6e      	ldr	r3, [pc, #440]	; (800a31c <HAL_DMA_IRQHandler+0x208>)
 800a164:	4299      	cmp	r1, r3
 800a166:	d041      	beq.n	800a1ec <HAL_DMA_IRQHandler+0xd8>
 800a168:	687b      	ldr	r3, [r7, #4]
 800a16a:	681b      	ldr	r3, [r3, #0]
 800a16c:	4619      	mov	r1, r3
 800a16e:	4b6c      	ldr	r3, [pc, #432]	; (800a320 <HAL_DMA_IRQHandler+0x20c>)
 800a170:	4299      	cmp	r1, r3
 800a172:	d038      	beq.n	800a1e6 <HAL_DMA_IRQHandler+0xd2>
 800a174:	687b      	ldr	r3, [r7, #4]
 800a176:	681b      	ldr	r3, [r3, #0]
 800a178:	4619      	mov	r1, r3
 800a17a:	4b6a      	ldr	r3, [pc, #424]	; (800a324 <HAL_DMA_IRQHandler+0x210>)
 800a17c:	4299      	cmp	r1, r3
 800a17e:	d02f      	beq.n	800a1e0 <HAL_DMA_IRQHandler+0xcc>
 800a180:	687b      	ldr	r3, [r7, #4]
 800a182:	681b      	ldr	r3, [r3, #0]
 800a184:	4619      	mov	r1, r3
 800a186:	4b68      	ldr	r3, [pc, #416]	; (800a328 <HAL_DMA_IRQHandler+0x214>)
 800a188:	4299      	cmp	r1, r3
 800a18a:	d026      	beq.n	800a1da <HAL_DMA_IRQHandler+0xc6>
 800a18c:	687b      	ldr	r3, [r7, #4]
 800a18e:	681b      	ldr	r3, [r3, #0]
 800a190:	4619      	mov	r1, r3
 800a192:	4b66      	ldr	r3, [pc, #408]	; (800a32c <HAL_DMA_IRQHandler+0x218>)
 800a194:	4299      	cmp	r1, r3
 800a196:	d01d      	beq.n	800a1d4 <HAL_DMA_IRQHandler+0xc0>
 800a198:	687b      	ldr	r3, [r7, #4]
 800a19a:	681b      	ldr	r3, [r3, #0]
 800a19c:	4619      	mov	r1, r3
 800a19e:	4b64      	ldr	r3, [pc, #400]	; (800a330 <HAL_DMA_IRQHandler+0x21c>)
 800a1a0:	4299      	cmp	r1, r3
 800a1a2:	d014      	beq.n	800a1ce <HAL_DMA_IRQHandler+0xba>
 800a1a4:	687b      	ldr	r3, [r7, #4]
 800a1a6:	681b      	ldr	r3, [r3, #0]
 800a1a8:	4619      	mov	r1, r3
 800a1aa:	4b62      	ldr	r3, [pc, #392]	; (800a334 <HAL_DMA_IRQHandler+0x220>)
 800a1ac:	4299      	cmp	r1, r3
 800a1ae:	d00b      	beq.n	800a1c8 <HAL_DMA_IRQHandler+0xb4>
 800a1b0:	687b      	ldr	r3, [r7, #4]
 800a1b2:	681b      	ldr	r3, [r3, #0]
 800a1b4:	4619      	mov	r1, r3
 800a1b6:	4b60      	ldr	r3, [pc, #384]	; (800a338 <HAL_DMA_IRQHandler+0x224>)
 800a1b8:	4299      	cmp	r1, r3
 800a1ba:	d102      	bne.n	800a1c2 <HAL_DMA_IRQHandler+0xae>
 800a1bc:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a1c0:	e01e      	b.n	800a200 <HAL_DMA_IRQHandler+0xec>
 800a1c2:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800a1c6:	e01b      	b.n	800a200 <HAL_DMA_IRQHandler+0xec>
 800a1c8:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a1cc:	e018      	b.n	800a200 <HAL_DMA_IRQHandler+0xec>
 800a1ce:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a1d2:	e015      	b.n	800a200 <HAL_DMA_IRQHandler+0xec>
 800a1d4:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a1d8:	e012      	b.n	800a200 <HAL_DMA_IRQHandler+0xec>
 800a1da:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a1de:	e00f      	b.n	800a200 <HAL_DMA_IRQHandler+0xec>
 800a1e0:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a1e4:	e00c      	b.n	800a200 <HAL_DMA_IRQHandler+0xec>
 800a1e6:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a1ea:	e009      	b.n	800a200 <HAL_DMA_IRQHandler+0xec>
 800a1ec:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a1f0:	e006      	b.n	800a200 <HAL_DMA_IRQHandler+0xec>
 800a1f2:	2308      	movs	r3, #8
 800a1f4:	e004      	b.n	800a200 <HAL_DMA_IRQHandler+0xec>
 800a1f6:	2308      	movs	r3, #8
 800a1f8:	e002      	b.n	800a200 <HAL_DMA_IRQHandler+0xec>
 800a1fa:	2308      	movs	r3, #8
 800a1fc:	e000      	b.n	800a200 <HAL_DMA_IRQHandler+0xec>
 800a1fe:	2308      	movs	r3, #8
 800a200:	4013      	ands	r3, r2
 800a202:	2b00      	cmp	r3, #0
 800a204:	bf14      	ite	ne
 800a206:	2301      	movne	r3, #1
 800a208:	2300      	moveq	r3, #0
 800a20a:	b2db      	uxtb	r3, r3
 800a20c:	e19f      	b.n	800a54e <HAL_DMA_IRQHandler+0x43a>
 800a20e:	687b      	ldr	r3, [r7, #4]
 800a210:	681b      	ldr	r3, [r3, #0]
 800a212:	461a      	mov	r2, r3
 800a214:	4b49      	ldr	r3, [pc, #292]	; (800a33c <HAL_DMA_IRQHandler+0x228>)
 800a216:	429a      	cmp	r2, r3
 800a218:	f240 8092 	bls.w	800a340 <HAL_DMA_IRQHandler+0x22c>
 800a21c:	4b3a      	ldr	r3, [pc, #232]	; (800a308 <HAL_DMA_IRQHandler+0x1f4>)
 800a21e:	681a      	ldr	r2, [r3, #0]
 800a220:	687b      	ldr	r3, [r7, #4]
 800a222:	681b      	ldr	r3, [r3, #0]
 800a224:	4619      	mov	r1, r3
 800a226:	4b39      	ldr	r3, [pc, #228]	; (800a30c <HAL_DMA_IRQHandler+0x1f8>)
 800a228:	4299      	cmp	r1, r3
 800a22a:	d062      	beq.n	800a2f2 <HAL_DMA_IRQHandler+0x1de>
 800a22c:	687b      	ldr	r3, [r7, #4]
 800a22e:	681b      	ldr	r3, [r3, #0]
 800a230:	4619      	mov	r1, r3
 800a232:	4b37      	ldr	r3, [pc, #220]	; (800a310 <HAL_DMA_IRQHandler+0x1fc>)
 800a234:	4299      	cmp	r1, r3
 800a236:	d05a      	beq.n	800a2ee <HAL_DMA_IRQHandler+0x1da>
 800a238:	687b      	ldr	r3, [r7, #4]
 800a23a:	681b      	ldr	r3, [r3, #0]
 800a23c:	4619      	mov	r1, r3
 800a23e:	4b35      	ldr	r3, [pc, #212]	; (800a314 <HAL_DMA_IRQHandler+0x200>)
 800a240:	4299      	cmp	r1, r3
 800a242:	d052      	beq.n	800a2ea <HAL_DMA_IRQHandler+0x1d6>
 800a244:	687b      	ldr	r3, [r7, #4]
 800a246:	681b      	ldr	r3, [r3, #0]
 800a248:	4619      	mov	r1, r3
 800a24a:	4b33      	ldr	r3, [pc, #204]	; (800a318 <HAL_DMA_IRQHandler+0x204>)
 800a24c:	4299      	cmp	r1, r3
 800a24e:	d04a      	beq.n	800a2e6 <HAL_DMA_IRQHandler+0x1d2>
 800a250:	687b      	ldr	r3, [r7, #4]
 800a252:	681b      	ldr	r3, [r3, #0]
 800a254:	4619      	mov	r1, r3
 800a256:	4b31      	ldr	r3, [pc, #196]	; (800a31c <HAL_DMA_IRQHandler+0x208>)
 800a258:	4299      	cmp	r1, r3
 800a25a:	d041      	beq.n	800a2e0 <HAL_DMA_IRQHandler+0x1cc>
 800a25c:	687b      	ldr	r3, [r7, #4]
 800a25e:	681b      	ldr	r3, [r3, #0]
 800a260:	4619      	mov	r1, r3
 800a262:	4b2f      	ldr	r3, [pc, #188]	; (800a320 <HAL_DMA_IRQHandler+0x20c>)
 800a264:	4299      	cmp	r1, r3
 800a266:	d038      	beq.n	800a2da <HAL_DMA_IRQHandler+0x1c6>
 800a268:	687b      	ldr	r3, [r7, #4]
 800a26a:	681b      	ldr	r3, [r3, #0]
 800a26c:	4619      	mov	r1, r3
 800a26e:	4b2d      	ldr	r3, [pc, #180]	; (800a324 <HAL_DMA_IRQHandler+0x210>)
 800a270:	4299      	cmp	r1, r3
 800a272:	d02f      	beq.n	800a2d4 <HAL_DMA_IRQHandler+0x1c0>
 800a274:	687b      	ldr	r3, [r7, #4]
 800a276:	681b      	ldr	r3, [r3, #0]
 800a278:	4619      	mov	r1, r3
 800a27a:	4b2b      	ldr	r3, [pc, #172]	; (800a328 <HAL_DMA_IRQHandler+0x214>)
 800a27c:	4299      	cmp	r1, r3
 800a27e:	d026      	beq.n	800a2ce <HAL_DMA_IRQHandler+0x1ba>
 800a280:	687b      	ldr	r3, [r7, #4]
 800a282:	681b      	ldr	r3, [r3, #0]
 800a284:	4619      	mov	r1, r3
 800a286:	4b29      	ldr	r3, [pc, #164]	; (800a32c <HAL_DMA_IRQHandler+0x218>)
 800a288:	4299      	cmp	r1, r3
 800a28a:	d01d      	beq.n	800a2c8 <HAL_DMA_IRQHandler+0x1b4>
 800a28c:	687b      	ldr	r3, [r7, #4]
 800a28e:	681b      	ldr	r3, [r3, #0]
 800a290:	4619      	mov	r1, r3
 800a292:	4b27      	ldr	r3, [pc, #156]	; (800a330 <HAL_DMA_IRQHandler+0x21c>)
 800a294:	4299      	cmp	r1, r3
 800a296:	d014      	beq.n	800a2c2 <HAL_DMA_IRQHandler+0x1ae>
 800a298:	687b      	ldr	r3, [r7, #4]
 800a29a:	681b      	ldr	r3, [r3, #0]
 800a29c:	4619      	mov	r1, r3
 800a29e:	4b25      	ldr	r3, [pc, #148]	; (800a334 <HAL_DMA_IRQHandler+0x220>)
 800a2a0:	4299      	cmp	r1, r3
 800a2a2:	d00b      	beq.n	800a2bc <HAL_DMA_IRQHandler+0x1a8>
 800a2a4:	687b      	ldr	r3, [r7, #4]
 800a2a6:	681b      	ldr	r3, [r3, #0]
 800a2a8:	4619      	mov	r1, r3
 800a2aa:	4b23      	ldr	r3, [pc, #140]	; (800a338 <HAL_DMA_IRQHandler+0x224>)
 800a2ac:	4299      	cmp	r1, r3
 800a2ae:	d102      	bne.n	800a2b6 <HAL_DMA_IRQHandler+0x1a2>
 800a2b0:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a2b4:	e01e      	b.n	800a2f4 <HAL_DMA_IRQHandler+0x1e0>
 800a2b6:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800a2ba:	e01b      	b.n	800a2f4 <HAL_DMA_IRQHandler+0x1e0>
 800a2bc:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a2c0:	e018      	b.n	800a2f4 <HAL_DMA_IRQHandler+0x1e0>
 800a2c2:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a2c6:	e015      	b.n	800a2f4 <HAL_DMA_IRQHandler+0x1e0>
 800a2c8:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a2cc:	e012      	b.n	800a2f4 <HAL_DMA_IRQHandler+0x1e0>
 800a2ce:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a2d2:	e00f      	b.n	800a2f4 <HAL_DMA_IRQHandler+0x1e0>
 800a2d4:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a2d8:	e00c      	b.n	800a2f4 <HAL_DMA_IRQHandler+0x1e0>
 800a2da:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a2de:	e009      	b.n	800a2f4 <HAL_DMA_IRQHandler+0x1e0>
 800a2e0:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a2e4:	e006      	b.n	800a2f4 <HAL_DMA_IRQHandler+0x1e0>
 800a2e6:	2308      	movs	r3, #8
 800a2e8:	e004      	b.n	800a2f4 <HAL_DMA_IRQHandler+0x1e0>
 800a2ea:	2308      	movs	r3, #8
 800a2ec:	e002      	b.n	800a2f4 <HAL_DMA_IRQHandler+0x1e0>
 800a2ee:	2308      	movs	r3, #8
 800a2f0:	e000      	b.n	800a2f4 <HAL_DMA_IRQHandler+0x1e0>
 800a2f2:	2308      	movs	r3, #8
 800a2f4:	4013      	ands	r3, r2
 800a2f6:	2b00      	cmp	r3, #0
 800a2f8:	bf14      	ite	ne
 800a2fa:	2301      	movne	r3, #1
 800a2fc:	2300      	moveq	r3, #0
 800a2fe:	b2db      	uxtb	r3, r3
 800a300:	e125      	b.n	800a54e <HAL_DMA_IRQHandler+0x43a>
 800a302:	bf00      	nop
 800a304:	40026458 	.word	0x40026458
 800a308:	40026400 	.word	0x40026400
 800a30c:	40026010 	.word	0x40026010
 800a310:	40026410 	.word	0x40026410
 800a314:	40026070 	.word	0x40026070
 800a318:	40026470 	.word	0x40026470
 800a31c:	40026028 	.word	0x40026028
 800a320:	40026428 	.word	0x40026428
 800a324:	40026088 	.word	0x40026088
 800a328:	40026488 	.word	0x40026488
 800a32c:	40026040 	.word	0x40026040
 800a330:	40026440 	.word	0x40026440
 800a334:	400260a0 	.word	0x400260a0
 800a338:	400264a0 	.word	0x400264a0
 800a33c:	400260b8 	.word	0x400260b8
 800a340:	687b      	ldr	r3, [r7, #4]
 800a342:	681b      	ldr	r3, [r3, #0]
 800a344:	461a      	mov	r2, r3
 800a346:	4b70      	ldr	r3, [pc, #448]	; (800a508 <HAL_DMA_IRQHandler+0x3f4>)
 800a348:	429a      	cmp	r2, r3
 800a34a:	d972      	bls.n	800a432 <HAL_DMA_IRQHandler+0x31e>
 800a34c:	4b6f      	ldr	r3, [pc, #444]	; (800a50c <HAL_DMA_IRQHandler+0x3f8>)
 800a34e:	685a      	ldr	r2, [r3, #4]
 800a350:	687b      	ldr	r3, [r7, #4]
 800a352:	681b      	ldr	r3, [r3, #0]
 800a354:	4619      	mov	r1, r3
 800a356:	4b6e      	ldr	r3, [pc, #440]	; (800a510 <HAL_DMA_IRQHandler+0x3fc>)
 800a358:	4299      	cmp	r1, r3
 800a35a:	d062      	beq.n	800a422 <HAL_DMA_IRQHandler+0x30e>
 800a35c:	687b      	ldr	r3, [r7, #4]
 800a35e:	681b      	ldr	r3, [r3, #0]
 800a360:	4619      	mov	r1, r3
 800a362:	4b6c      	ldr	r3, [pc, #432]	; (800a514 <HAL_DMA_IRQHandler+0x400>)
 800a364:	4299      	cmp	r1, r3
 800a366:	d05a      	beq.n	800a41e <HAL_DMA_IRQHandler+0x30a>
 800a368:	687b      	ldr	r3, [r7, #4]
 800a36a:	681b      	ldr	r3, [r3, #0]
 800a36c:	4619      	mov	r1, r3
 800a36e:	4b6a      	ldr	r3, [pc, #424]	; (800a518 <HAL_DMA_IRQHandler+0x404>)
 800a370:	4299      	cmp	r1, r3
 800a372:	d052      	beq.n	800a41a <HAL_DMA_IRQHandler+0x306>
 800a374:	687b      	ldr	r3, [r7, #4]
 800a376:	681b      	ldr	r3, [r3, #0]
 800a378:	4619      	mov	r1, r3
 800a37a:	4b68      	ldr	r3, [pc, #416]	; (800a51c <HAL_DMA_IRQHandler+0x408>)
 800a37c:	4299      	cmp	r1, r3
 800a37e:	d04a      	beq.n	800a416 <HAL_DMA_IRQHandler+0x302>
 800a380:	687b      	ldr	r3, [r7, #4]
 800a382:	681b      	ldr	r3, [r3, #0]
 800a384:	4619      	mov	r1, r3
 800a386:	4b66      	ldr	r3, [pc, #408]	; (800a520 <HAL_DMA_IRQHandler+0x40c>)
 800a388:	4299      	cmp	r1, r3
 800a38a:	d041      	beq.n	800a410 <HAL_DMA_IRQHandler+0x2fc>
 800a38c:	687b      	ldr	r3, [r7, #4]
 800a38e:	681b      	ldr	r3, [r3, #0]
 800a390:	4619      	mov	r1, r3
 800a392:	4b64      	ldr	r3, [pc, #400]	; (800a524 <HAL_DMA_IRQHandler+0x410>)
 800a394:	4299      	cmp	r1, r3
 800a396:	d038      	beq.n	800a40a <HAL_DMA_IRQHandler+0x2f6>
 800a398:	687b      	ldr	r3, [r7, #4]
 800a39a:	681b      	ldr	r3, [r3, #0]
 800a39c:	4619      	mov	r1, r3
 800a39e:	4b62      	ldr	r3, [pc, #392]	; (800a528 <HAL_DMA_IRQHandler+0x414>)
 800a3a0:	4299      	cmp	r1, r3
 800a3a2:	d02f      	beq.n	800a404 <HAL_DMA_IRQHandler+0x2f0>
 800a3a4:	687b      	ldr	r3, [r7, #4]
 800a3a6:	681b      	ldr	r3, [r3, #0]
 800a3a8:	4619      	mov	r1, r3
 800a3aa:	4b60      	ldr	r3, [pc, #384]	; (800a52c <HAL_DMA_IRQHandler+0x418>)
 800a3ac:	4299      	cmp	r1, r3
 800a3ae:	d026      	beq.n	800a3fe <HAL_DMA_IRQHandler+0x2ea>
 800a3b0:	687b      	ldr	r3, [r7, #4]
 800a3b2:	681b      	ldr	r3, [r3, #0]
 800a3b4:	4619      	mov	r1, r3
 800a3b6:	4b5e      	ldr	r3, [pc, #376]	; (800a530 <HAL_DMA_IRQHandler+0x41c>)
 800a3b8:	4299      	cmp	r1, r3
 800a3ba:	d01d      	beq.n	800a3f8 <HAL_DMA_IRQHandler+0x2e4>
 800a3bc:	687b      	ldr	r3, [r7, #4]
 800a3be:	681b      	ldr	r3, [r3, #0]
 800a3c0:	4619      	mov	r1, r3
 800a3c2:	4b5c      	ldr	r3, [pc, #368]	; (800a534 <HAL_DMA_IRQHandler+0x420>)
 800a3c4:	4299      	cmp	r1, r3
 800a3c6:	d014      	beq.n	800a3f2 <HAL_DMA_IRQHandler+0x2de>
 800a3c8:	687b      	ldr	r3, [r7, #4]
 800a3ca:	681b      	ldr	r3, [r3, #0]
 800a3cc:	4619      	mov	r1, r3
 800a3ce:	4b5a      	ldr	r3, [pc, #360]	; (800a538 <HAL_DMA_IRQHandler+0x424>)
 800a3d0:	4299      	cmp	r1, r3
 800a3d2:	d00b      	beq.n	800a3ec <HAL_DMA_IRQHandler+0x2d8>
 800a3d4:	687b      	ldr	r3, [r7, #4]
 800a3d6:	681b      	ldr	r3, [r3, #0]
 800a3d8:	4619      	mov	r1, r3
 800a3da:	4b58      	ldr	r3, [pc, #352]	; (800a53c <HAL_DMA_IRQHandler+0x428>)
 800a3dc:	4299      	cmp	r1, r3
 800a3de:	d102      	bne.n	800a3e6 <HAL_DMA_IRQHandler+0x2d2>
 800a3e0:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a3e4:	e01e      	b.n	800a424 <HAL_DMA_IRQHandler+0x310>
 800a3e6:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800a3ea:	e01b      	b.n	800a424 <HAL_DMA_IRQHandler+0x310>
 800a3ec:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a3f0:	e018      	b.n	800a424 <HAL_DMA_IRQHandler+0x310>
 800a3f2:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a3f6:	e015      	b.n	800a424 <HAL_DMA_IRQHandler+0x310>
 800a3f8:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a3fc:	e012      	b.n	800a424 <HAL_DMA_IRQHandler+0x310>
 800a3fe:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a402:	e00f      	b.n	800a424 <HAL_DMA_IRQHandler+0x310>
 800a404:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a408:	e00c      	b.n	800a424 <HAL_DMA_IRQHandler+0x310>
 800a40a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a40e:	e009      	b.n	800a424 <HAL_DMA_IRQHandler+0x310>
 800a410:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a414:	e006      	b.n	800a424 <HAL_DMA_IRQHandler+0x310>
 800a416:	2308      	movs	r3, #8
 800a418:	e004      	b.n	800a424 <HAL_DMA_IRQHandler+0x310>
 800a41a:	2308      	movs	r3, #8
 800a41c:	e002      	b.n	800a424 <HAL_DMA_IRQHandler+0x310>
 800a41e:	2308      	movs	r3, #8
 800a420:	e000      	b.n	800a424 <HAL_DMA_IRQHandler+0x310>
 800a422:	2308      	movs	r3, #8
 800a424:	4013      	ands	r3, r2
 800a426:	2b00      	cmp	r3, #0
 800a428:	bf14      	ite	ne
 800a42a:	2301      	movne	r3, #1
 800a42c:	2300      	moveq	r3, #0
 800a42e:	b2db      	uxtb	r3, r3
 800a430:	e08d      	b.n	800a54e <HAL_DMA_IRQHandler+0x43a>
 800a432:	4b36      	ldr	r3, [pc, #216]	; (800a50c <HAL_DMA_IRQHandler+0x3f8>)
 800a434:	681a      	ldr	r2, [r3, #0]
 800a436:	687b      	ldr	r3, [r7, #4]
 800a438:	681b      	ldr	r3, [r3, #0]
 800a43a:	4619      	mov	r1, r3
 800a43c:	4b34      	ldr	r3, [pc, #208]	; (800a510 <HAL_DMA_IRQHandler+0x3fc>)
 800a43e:	4299      	cmp	r1, r3
 800a440:	d07e      	beq.n	800a540 <HAL_DMA_IRQHandler+0x42c>
 800a442:	687b      	ldr	r3, [r7, #4]
 800a444:	681b      	ldr	r3, [r3, #0]
 800a446:	4619      	mov	r1, r3
 800a448:	4b32      	ldr	r3, [pc, #200]	; (800a514 <HAL_DMA_IRQHandler+0x400>)
 800a44a:	4299      	cmp	r1, r3
 800a44c:	d05a      	beq.n	800a504 <HAL_DMA_IRQHandler+0x3f0>
 800a44e:	687b      	ldr	r3, [r7, #4]
 800a450:	681b      	ldr	r3, [r3, #0]
 800a452:	4619      	mov	r1, r3
 800a454:	4b30      	ldr	r3, [pc, #192]	; (800a518 <HAL_DMA_IRQHandler+0x404>)
 800a456:	4299      	cmp	r1, r3
 800a458:	d052      	beq.n	800a500 <HAL_DMA_IRQHandler+0x3ec>
 800a45a:	687b      	ldr	r3, [r7, #4]
 800a45c:	681b      	ldr	r3, [r3, #0]
 800a45e:	4619      	mov	r1, r3
 800a460:	4b2e      	ldr	r3, [pc, #184]	; (800a51c <HAL_DMA_IRQHandler+0x408>)
 800a462:	4299      	cmp	r1, r3
 800a464:	d04a      	beq.n	800a4fc <HAL_DMA_IRQHandler+0x3e8>
 800a466:	687b      	ldr	r3, [r7, #4]
 800a468:	681b      	ldr	r3, [r3, #0]
 800a46a:	4619      	mov	r1, r3
 800a46c:	4b2c      	ldr	r3, [pc, #176]	; (800a520 <HAL_DMA_IRQHandler+0x40c>)
 800a46e:	4299      	cmp	r1, r3
 800a470:	d041      	beq.n	800a4f6 <HAL_DMA_IRQHandler+0x3e2>
 800a472:	687b      	ldr	r3, [r7, #4]
 800a474:	681b      	ldr	r3, [r3, #0]
 800a476:	4619      	mov	r1, r3
 800a478:	4b2a      	ldr	r3, [pc, #168]	; (800a524 <HAL_DMA_IRQHandler+0x410>)
 800a47a:	4299      	cmp	r1, r3
 800a47c:	d038      	beq.n	800a4f0 <HAL_DMA_IRQHandler+0x3dc>
 800a47e:	687b      	ldr	r3, [r7, #4]
 800a480:	681b      	ldr	r3, [r3, #0]
 800a482:	4619      	mov	r1, r3
 800a484:	4b28      	ldr	r3, [pc, #160]	; (800a528 <HAL_DMA_IRQHandler+0x414>)
 800a486:	4299      	cmp	r1, r3
 800a488:	d02f      	beq.n	800a4ea <HAL_DMA_IRQHandler+0x3d6>
 800a48a:	687b      	ldr	r3, [r7, #4]
 800a48c:	681b      	ldr	r3, [r3, #0]
 800a48e:	4619      	mov	r1, r3
 800a490:	4b26      	ldr	r3, [pc, #152]	; (800a52c <HAL_DMA_IRQHandler+0x418>)
 800a492:	4299      	cmp	r1, r3
 800a494:	d026      	beq.n	800a4e4 <HAL_DMA_IRQHandler+0x3d0>
 800a496:	687b      	ldr	r3, [r7, #4]
 800a498:	681b      	ldr	r3, [r3, #0]
 800a49a:	4619      	mov	r1, r3
 800a49c:	4b24      	ldr	r3, [pc, #144]	; (800a530 <HAL_DMA_IRQHandler+0x41c>)
 800a49e:	4299      	cmp	r1, r3
 800a4a0:	d01d      	beq.n	800a4de <HAL_DMA_IRQHandler+0x3ca>
 800a4a2:	687b      	ldr	r3, [r7, #4]
 800a4a4:	681b      	ldr	r3, [r3, #0]
 800a4a6:	4619      	mov	r1, r3
 800a4a8:	4b22      	ldr	r3, [pc, #136]	; (800a534 <HAL_DMA_IRQHandler+0x420>)
 800a4aa:	4299      	cmp	r1, r3
 800a4ac:	d014      	beq.n	800a4d8 <HAL_DMA_IRQHandler+0x3c4>
 800a4ae:	687b      	ldr	r3, [r7, #4]
 800a4b0:	681b      	ldr	r3, [r3, #0]
 800a4b2:	4619      	mov	r1, r3
 800a4b4:	4b20      	ldr	r3, [pc, #128]	; (800a538 <HAL_DMA_IRQHandler+0x424>)
 800a4b6:	4299      	cmp	r1, r3
 800a4b8:	d00b      	beq.n	800a4d2 <HAL_DMA_IRQHandler+0x3be>
 800a4ba:	687b      	ldr	r3, [r7, #4]
 800a4bc:	681b      	ldr	r3, [r3, #0]
 800a4be:	4619      	mov	r1, r3
 800a4c0:	4b1e      	ldr	r3, [pc, #120]	; (800a53c <HAL_DMA_IRQHandler+0x428>)
 800a4c2:	4299      	cmp	r1, r3
 800a4c4:	d102      	bne.n	800a4cc <HAL_DMA_IRQHandler+0x3b8>
 800a4c6:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a4ca:	e03a      	b.n	800a542 <HAL_DMA_IRQHandler+0x42e>
 800a4cc:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800a4d0:	e037      	b.n	800a542 <HAL_DMA_IRQHandler+0x42e>
 800a4d2:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a4d6:	e034      	b.n	800a542 <HAL_DMA_IRQHandler+0x42e>
 800a4d8:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a4dc:	e031      	b.n	800a542 <HAL_DMA_IRQHandler+0x42e>
 800a4de:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a4e2:	e02e      	b.n	800a542 <HAL_DMA_IRQHandler+0x42e>
 800a4e4:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a4e8:	e02b      	b.n	800a542 <HAL_DMA_IRQHandler+0x42e>
 800a4ea:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a4ee:	e028      	b.n	800a542 <HAL_DMA_IRQHandler+0x42e>
 800a4f0:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a4f4:	e025      	b.n	800a542 <HAL_DMA_IRQHandler+0x42e>
 800a4f6:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a4fa:	e022      	b.n	800a542 <HAL_DMA_IRQHandler+0x42e>
 800a4fc:	2308      	movs	r3, #8
 800a4fe:	e020      	b.n	800a542 <HAL_DMA_IRQHandler+0x42e>
 800a500:	2308      	movs	r3, #8
 800a502:	e01e      	b.n	800a542 <HAL_DMA_IRQHandler+0x42e>
 800a504:	2308      	movs	r3, #8
 800a506:	e01c      	b.n	800a542 <HAL_DMA_IRQHandler+0x42e>
 800a508:	40026058 	.word	0x40026058
 800a50c:	40026000 	.word	0x40026000
 800a510:	40026010 	.word	0x40026010
 800a514:	40026410 	.word	0x40026410
 800a518:	40026070 	.word	0x40026070
 800a51c:	40026470 	.word	0x40026470
 800a520:	40026028 	.word	0x40026028
 800a524:	40026428 	.word	0x40026428
 800a528:	40026088 	.word	0x40026088
 800a52c:	40026488 	.word	0x40026488
 800a530:	40026040 	.word	0x40026040
 800a534:	40026440 	.word	0x40026440
 800a538:	400260a0 	.word	0x400260a0
 800a53c:	400264a0 	.word	0x400264a0
 800a540:	2308      	movs	r3, #8
 800a542:	4013      	ands	r3, r2
 800a544:	2b00      	cmp	r3, #0
 800a546:	bf14      	ite	ne
 800a548:	2301      	movne	r3, #1
 800a54a:	2300      	moveq	r3, #0
 800a54c:	b2db      	uxtb	r3, r3
 800a54e:	2b00      	cmp	r3, #0
 800a550:	f000 8210 	beq.w	800a974 <HAL_DMA_IRQHandler+0x860>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 800a554:	687b      	ldr	r3, [r7, #4]
 800a556:	681b      	ldr	r3, [r3, #0]
 800a558:	681b      	ldr	r3, [r3, #0]
 800a55a:	f003 0304 	and.w	r3, r3, #4
 800a55e:	2b00      	cmp	r3, #0
 800a560:	f000 8208 	beq.w	800a974 <HAL_DMA_IRQHandler+0x860>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
 800a564:	687b      	ldr	r3, [r7, #4]
 800a566:	681b      	ldr	r3, [r3, #0]
 800a568:	687a      	ldr	r2, [r7, #4]
 800a56a:	6812      	ldr	r2, [r2, #0]
 800a56c:	6812      	ldr	r2, [r2, #0]
 800a56e:	f022 0204 	bic.w	r2, r2, #4
 800a572:	601a      	str	r2, [r3, #0]

      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 800a574:	687b      	ldr	r3, [r7, #4]
 800a576:	681b      	ldr	r3, [r3, #0]
 800a578:	461a      	mov	r2, r3
 800a57a:	4ba0      	ldr	r3, [pc, #640]	; (800a7fc <HAL_DMA_IRQHandler+0x6e8>)
 800a57c:	429a      	cmp	r2, r3
 800a57e:	d96c      	bls.n	800a65a <HAL_DMA_IRQHandler+0x546>
 800a580:	4a9f      	ldr	r2, [pc, #636]	; (800a800 <HAL_DMA_IRQHandler+0x6ec>)
 800a582:	687b      	ldr	r3, [r7, #4]
 800a584:	681b      	ldr	r3, [r3, #0]
 800a586:	4619      	mov	r1, r3
 800a588:	4b9e      	ldr	r3, [pc, #632]	; (800a804 <HAL_DMA_IRQHandler+0x6f0>)
 800a58a:	4299      	cmp	r1, r3
 800a58c:	d062      	beq.n	800a654 <HAL_DMA_IRQHandler+0x540>
 800a58e:	687b      	ldr	r3, [r7, #4]
 800a590:	681b      	ldr	r3, [r3, #0]
 800a592:	4619      	mov	r1, r3
 800a594:	4b9c      	ldr	r3, [pc, #624]	; (800a808 <HAL_DMA_IRQHandler+0x6f4>)
 800a596:	4299      	cmp	r1, r3
 800a598:	d05a      	beq.n	800a650 <HAL_DMA_IRQHandler+0x53c>
 800a59a:	687b      	ldr	r3, [r7, #4]
 800a59c:	681b      	ldr	r3, [r3, #0]
 800a59e:	4619      	mov	r1, r3
 800a5a0:	4b9a      	ldr	r3, [pc, #616]	; (800a80c <HAL_DMA_IRQHandler+0x6f8>)
 800a5a2:	4299      	cmp	r1, r3
 800a5a4:	d052      	beq.n	800a64c <HAL_DMA_IRQHandler+0x538>
 800a5a6:	687b      	ldr	r3, [r7, #4]
 800a5a8:	681b      	ldr	r3, [r3, #0]
 800a5aa:	4619      	mov	r1, r3
 800a5ac:	4b98      	ldr	r3, [pc, #608]	; (800a810 <HAL_DMA_IRQHandler+0x6fc>)
 800a5ae:	4299      	cmp	r1, r3
 800a5b0:	d04a      	beq.n	800a648 <HAL_DMA_IRQHandler+0x534>
 800a5b2:	687b      	ldr	r3, [r7, #4]
 800a5b4:	681b      	ldr	r3, [r3, #0]
 800a5b6:	4619      	mov	r1, r3
 800a5b8:	4b96      	ldr	r3, [pc, #600]	; (800a814 <HAL_DMA_IRQHandler+0x700>)
 800a5ba:	4299      	cmp	r1, r3
 800a5bc:	d041      	beq.n	800a642 <HAL_DMA_IRQHandler+0x52e>
 800a5be:	687b      	ldr	r3, [r7, #4]
 800a5c0:	681b      	ldr	r3, [r3, #0]
 800a5c2:	4619      	mov	r1, r3
 800a5c4:	4b94      	ldr	r3, [pc, #592]	; (800a818 <HAL_DMA_IRQHandler+0x704>)
 800a5c6:	4299      	cmp	r1, r3
 800a5c8:	d038      	beq.n	800a63c <HAL_DMA_IRQHandler+0x528>
 800a5ca:	687b      	ldr	r3, [r7, #4]
 800a5cc:	681b      	ldr	r3, [r3, #0]
 800a5ce:	4619      	mov	r1, r3
 800a5d0:	4b92      	ldr	r3, [pc, #584]	; (800a81c <HAL_DMA_IRQHandler+0x708>)
 800a5d2:	4299      	cmp	r1, r3
 800a5d4:	d02f      	beq.n	800a636 <HAL_DMA_IRQHandler+0x522>
 800a5d6:	687b      	ldr	r3, [r7, #4]
 800a5d8:	681b      	ldr	r3, [r3, #0]
 800a5da:	4619      	mov	r1, r3
 800a5dc:	4b90      	ldr	r3, [pc, #576]	; (800a820 <HAL_DMA_IRQHandler+0x70c>)
 800a5de:	4299      	cmp	r1, r3
 800a5e0:	d026      	beq.n	800a630 <HAL_DMA_IRQHandler+0x51c>
 800a5e2:	687b      	ldr	r3, [r7, #4]
 800a5e4:	681b      	ldr	r3, [r3, #0]
 800a5e6:	4619      	mov	r1, r3
 800a5e8:	4b8e      	ldr	r3, [pc, #568]	; (800a824 <HAL_DMA_IRQHandler+0x710>)
 800a5ea:	4299      	cmp	r1, r3
 800a5ec:	d01d      	beq.n	800a62a <HAL_DMA_IRQHandler+0x516>
 800a5ee:	687b      	ldr	r3, [r7, #4]
 800a5f0:	681b      	ldr	r3, [r3, #0]
 800a5f2:	4619      	mov	r1, r3
 800a5f4:	4b8c      	ldr	r3, [pc, #560]	; (800a828 <HAL_DMA_IRQHandler+0x714>)
 800a5f6:	4299      	cmp	r1, r3
 800a5f8:	d014      	beq.n	800a624 <HAL_DMA_IRQHandler+0x510>
 800a5fa:	687b      	ldr	r3, [r7, #4]
 800a5fc:	681b      	ldr	r3, [r3, #0]
 800a5fe:	4619      	mov	r1, r3
 800a600:	4b8a      	ldr	r3, [pc, #552]	; (800a82c <HAL_DMA_IRQHandler+0x718>)
 800a602:	4299      	cmp	r1, r3
 800a604:	d00b      	beq.n	800a61e <HAL_DMA_IRQHandler+0x50a>
 800a606:	687b      	ldr	r3, [r7, #4]
 800a608:	681b      	ldr	r3, [r3, #0]
 800a60a:	4619      	mov	r1, r3
 800a60c:	4b88      	ldr	r3, [pc, #544]	; (800a830 <HAL_DMA_IRQHandler+0x71c>)
 800a60e:	4299      	cmp	r1, r3
 800a610:	d102      	bne.n	800a618 <HAL_DMA_IRQHandler+0x504>
 800a612:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a616:	e01e      	b.n	800a656 <HAL_DMA_IRQHandler+0x542>
 800a618:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800a61c:	e01b      	b.n	800a656 <HAL_DMA_IRQHandler+0x542>
 800a61e:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a622:	e018      	b.n	800a656 <HAL_DMA_IRQHandler+0x542>
 800a624:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a628:	e015      	b.n	800a656 <HAL_DMA_IRQHandler+0x542>
 800a62a:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a62e:	e012      	b.n	800a656 <HAL_DMA_IRQHandler+0x542>
 800a630:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a634:	e00f      	b.n	800a656 <HAL_DMA_IRQHandler+0x542>
 800a636:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a63a:	e00c      	b.n	800a656 <HAL_DMA_IRQHandler+0x542>
 800a63c:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a640:	e009      	b.n	800a656 <HAL_DMA_IRQHandler+0x542>
 800a642:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a646:	e006      	b.n	800a656 <HAL_DMA_IRQHandler+0x542>
 800a648:	2308      	movs	r3, #8
 800a64a:	e004      	b.n	800a656 <HAL_DMA_IRQHandler+0x542>
 800a64c:	2308      	movs	r3, #8
 800a64e:	e002      	b.n	800a656 <HAL_DMA_IRQHandler+0x542>
 800a650:	2308      	movs	r3, #8
 800a652:	e000      	b.n	800a656 <HAL_DMA_IRQHandler+0x542>
 800a654:	2308      	movs	r3, #8
 800a656:	60d3      	str	r3, [r2, #12]
 800a658:	e176      	b.n	800a948 <HAL_DMA_IRQHandler+0x834>
 800a65a:	687b      	ldr	r3, [r7, #4]
 800a65c:	681b      	ldr	r3, [r3, #0]
 800a65e:	461a      	mov	r2, r3
 800a660:	4b74      	ldr	r3, [pc, #464]	; (800a834 <HAL_DMA_IRQHandler+0x720>)
 800a662:	429a      	cmp	r2, r3
 800a664:	d96c      	bls.n	800a740 <HAL_DMA_IRQHandler+0x62c>
 800a666:	4a66      	ldr	r2, [pc, #408]	; (800a800 <HAL_DMA_IRQHandler+0x6ec>)
 800a668:	687b      	ldr	r3, [r7, #4]
 800a66a:	681b      	ldr	r3, [r3, #0]
 800a66c:	4619      	mov	r1, r3
 800a66e:	4b65      	ldr	r3, [pc, #404]	; (800a804 <HAL_DMA_IRQHandler+0x6f0>)
 800a670:	4299      	cmp	r1, r3
 800a672:	d062      	beq.n	800a73a <HAL_DMA_IRQHandler+0x626>
 800a674:	687b      	ldr	r3, [r7, #4]
 800a676:	681b      	ldr	r3, [r3, #0]
 800a678:	4619      	mov	r1, r3
 800a67a:	4b63      	ldr	r3, [pc, #396]	; (800a808 <HAL_DMA_IRQHandler+0x6f4>)
 800a67c:	4299      	cmp	r1, r3
 800a67e:	d05a      	beq.n	800a736 <HAL_DMA_IRQHandler+0x622>
 800a680:	687b      	ldr	r3, [r7, #4]
 800a682:	681b      	ldr	r3, [r3, #0]
 800a684:	4619      	mov	r1, r3
 800a686:	4b61      	ldr	r3, [pc, #388]	; (800a80c <HAL_DMA_IRQHandler+0x6f8>)
 800a688:	4299      	cmp	r1, r3
 800a68a:	d052      	beq.n	800a732 <HAL_DMA_IRQHandler+0x61e>
 800a68c:	687b      	ldr	r3, [r7, #4]
 800a68e:	681b      	ldr	r3, [r3, #0]
 800a690:	4619      	mov	r1, r3
 800a692:	4b5f      	ldr	r3, [pc, #380]	; (800a810 <HAL_DMA_IRQHandler+0x6fc>)
 800a694:	4299      	cmp	r1, r3
 800a696:	d04a      	beq.n	800a72e <HAL_DMA_IRQHandler+0x61a>
 800a698:	687b      	ldr	r3, [r7, #4]
 800a69a:	681b      	ldr	r3, [r3, #0]
 800a69c:	4619      	mov	r1, r3
 800a69e:	4b5d      	ldr	r3, [pc, #372]	; (800a814 <HAL_DMA_IRQHandler+0x700>)
 800a6a0:	4299      	cmp	r1, r3
 800a6a2:	d041      	beq.n	800a728 <HAL_DMA_IRQHandler+0x614>
 800a6a4:	687b      	ldr	r3, [r7, #4]
 800a6a6:	681b      	ldr	r3, [r3, #0]
 800a6a8:	4619      	mov	r1, r3
 800a6aa:	4b5b      	ldr	r3, [pc, #364]	; (800a818 <HAL_DMA_IRQHandler+0x704>)
 800a6ac:	4299      	cmp	r1, r3
 800a6ae:	d038      	beq.n	800a722 <HAL_DMA_IRQHandler+0x60e>
 800a6b0:	687b      	ldr	r3, [r7, #4]
 800a6b2:	681b      	ldr	r3, [r3, #0]
 800a6b4:	4619      	mov	r1, r3
 800a6b6:	4b59      	ldr	r3, [pc, #356]	; (800a81c <HAL_DMA_IRQHandler+0x708>)
 800a6b8:	4299      	cmp	r1, r3
 800a6ba:	d02f      	beq.n	800a71c <HAL_DMA_IRQHandler+0x608>
 800a6bc:	687b      	ldr	r3, [r7, #4]
 800a6be:	681b      	ldr	r3, [r3, #0]
 800a6c0:	4619      	mov	r1, r3
 800a6c2:	4b57      	ldr	r3, [pc, #348]	; (800a820 <HAL_DMA_IRQHandler+0x70c>)
 800a6c4:	4299      	cmp	r1, r3
 800a6c6:	d026      	beq.n	800a716 <HAL_DMA_IRQHandler+0x602>
 800a6c8:	687b      	ldr	r3, [r7, #4]
 800a6ca:	681b      	ldr	r3, [r3, #0]
 800a6cc:	4619      	mov	r1, r3
 800a6ce:	4b55      	ldr	r3, [pc, #340]	; (800a824 <HAL_DMA_IRQHandler+0x710>)
 800a6d0:	4299      	cmp	r1, r3
 800a6d2:	d01d      	beq.n	800a710 <HAL_DMA_IRQHandler+0x5fc>
 800a6d4:	687b      	ldr	r3, [r7, #4]
 800a6d6:	681b      	ldr	r3, [r3, #0]
 800a6d8:	4619      	mov	r1, r3
 800a6da:	4b53      	ldr	r3, [pc, #332]	; (800a828 <HAL_DMA_IRQHandler+0x714>)
 800a6dc:	4299      	cmp	r1, r3
 800a6de:	d014      	beq.n	800a70a <HAL_DMA_IRQHandler+0x5f6>
 800a6e0:	687b      	ldr	r3, [r7, #4]
 800a6e2:	681b      	ldr	r3, [r3, #0]
 800a6e4:	4619      	mov	r1, r3
 800a6e6:	4b51      	ldr	r3, [pc, #324]	; (800a82c <HAL_DMA_IRQHandler+0x718>)
 800a6e8:	4299      	cmp	r1, r3
 800a6ea:	d00b      	beq.n	800a704 <HAL_DMA_IRQHandler+0x5f0>
 800a6ec:	687b      	ldr	r3, [r7, #4]
 800a6ee:	681b      	ldr	r3, [r3, #0]
 800a6f0:	4619      	mov	r1, r3
 800a6f2:	4b4f      	ldr	r3, [pc, #316]	; (800a830 <HAL_DMA_IRQHandler+0x71c>)
 800a6f4:	4299      	cmp	r1, r3
 800a6f6:	d102      	bne.n	800a6fe <HAL_DMA_IRQHandler+0x5ea>
 800a6f8:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a6fc:	e01e      	b.n	800a73c <HAL_DMA_IRQHandler+0x628>
 800a6fe:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800a702:	e01b      	b.n	800a73c <HAL_DMA_IRQHandler+0x628>
 800a704:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a708:	e018      	b.n	800a73c <HAL_DMA_IRQHandler+0x628>
 800a70a:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a70e:	e015      	b.n	800a73c <HAL_DMA_IRQHandler+0x628>
 800a710:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a714:	e012      	b.n	800a73c <HAL_DMA_IRQHandler+0x628>
 800a716:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a71a:	e00f      	b.n	800a73c <HAL_DMA_IRQHandler+0x628>
 800a71c:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a720:	e00c      	b.n	800a73c <HAL_DMA_IRQHandler+0x628>
 800a722:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a726:	e009      	b.n	800a73c <HAL_DMA_IRQHandler+0x628>
 800a728:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a72c:	e006      	b.n	800a73c <HAL_DMA_IRQHandler+0x628>
 800a72e:	2308      	movs	r3, #8
 800a730:	e004      	b.n	800a73c <HAL_DMA_IRQHandler+0x628>
 800a732:	2308      	movs	r3, #8
 800a734:	e002      	b.n	800a73c <HAL_DMA_IRQHandler+0x628>
 800a736:	2308      	movs	r3, #8
 800a738:	e000      	b.n	800a73c <HAL_DMA_IRQHandler+0x628>
 800a73a:	2308      	movs	r3, #8
 800a73c:	6093      	str	r3, [r2, #8]
 800a73e:	e103      	b.n	800a948 <HAL_DMA_IRQHandler+0x834>
 800a740:	687b      	ldr	r3, [r7, #4]
 800a742:	681b      	ldr	r3, [r3, #0]
 800a744:	461a      	mov	r2, r3
 800a746:	4b3c      	ldr	r3, [pc, #240]	; (800a838 <HAL_DMA_IRQHandler+0x724>)
 800a748:	429a      	cmp	r2, r3
 800a74a:	f240 8091 	bls.w	800a870 <HAL_DMA_IRQHandler+0x75c>
 800a74e:	4a3b      	ldr	r2, [pc, #236]	; (800a83c <HAL_DMA_IRQHandler+0x728>)
 800a750:	687b      	ldr	r3, [r7, #4]
 800a752:	681b      	ldr	r3, [r3, #0]
 800a754:	4619      	mov	r1, r3
 800a756:	4b2b      	ldr	r3, [pc, #172]	; (800a804 <HAL_DMA_IRQHandler+0x6f0>)
 800a758:	4299      	cmp	r1, r3
 800a75a:	f000 8086 	beq.w	800a86a <HAL_DMA_IRQHandler+0x756>
 800a75e:	687b      	ldr	r3, [r7, #4]
 800a760:	681b      	ldr	r3, [r3, #0]
 800a762:	4619      	mov	r1, r3
 800a764:	4b28      	ldr	r3, [pc, #160]	; (800a808 <HAL_DMA_IRQHandler+0x6f4>)
 800a766:	4299      	cmp	r1, r3
 800a768:	d07d      	beq.n	800a866 <HAL_DMA_IRQHandler+0x752>
 800a76a:	687b      	ldr	r3, [r7, #4]
 800a76c:	681b      	ldr	r3, [r3, #0]
 800a76e:	4619      	mov	r1, r3
 800a770:	4b26      	ldr	r3, [pc, #152]	; (800a80c <HAL_DMA_IRQHandler+0x6f8>)
 800a772:	4299      	cmp	r1, r3
 800a774:	d075      	beq.n	800a862 <HAL_DMA_IRQHandler+0x74e>
 800a776:	687b      	ldr	r3, [r7, #4]
 800a778:	681b      	ldr	r3, [r3, #0]
 800a77a:	4619      	mov	r1, r3
 800a77c:	4b24      	ldr	r3, [pc, #144]	; (800a810 <HAL_DMA_IRQHandler+0x6fc>)
 800a77e:	4299      	cmp	r1, r3
 800a780:	d06d      	beq.n	800a85e <HAL_DMA_IRQHandler+0x74a>
 800a782:	687b      	ldr	r3, [r7, #4]
 800a784:	681b      	ldr	r3, [r3, #0]
 800a786:	4619      	mov	r1, r3
 800a788:	4b22      	ldr	r3, [pc, #136]	; (800a814 <HAL_DMA_IRQHandler+0x700>)
 800a78a:	4299      	cmp	r1, r3
 800a78c:	d064      	beq.n	800a858 <HAL_DMA_IRQHandler+0x744>
 800a78e:	687b      	ldr	r3, [r7, #4]
 800a790:	681b      	ldr	r3, [r3, #0]
 800a792:	4619      	mov	r1, r3
 800a794:	4b20      	ldr	r3, [pc, #128]	; (800a818 <HAL_DMA_IRQHandler+0x704>)
 800a796:	4299      	cmp	r1, r3
 800a798:	d05b      	beq.n	800a852 <HAL_DMA_IRQHandler+0x73e>
 800a79a:	687b      	ldr	r3, [r7, #4]
 800a79c:	681b      	ldr	r3, [r3, #0]
 800a79e:	4619      	mov	r1, r3
 800a7a0:	4b1e      	ldr	r3, [pc, #120]	; (800a81c <HAL_DMA_IRQHandler+0x708>)
 800a7a2:	4299      	cmp	r1, r3
 800a7a4:	d052      	beq.n	800a84c <HAL_DMA_IRQHandler+0x738>
 800a7a6:	687b      	ldr	r3, [r7, #4]
 800a7a8:	681b      	ldr	r3, [r3, #0]
 800a7aa:	4619      	mov	r1, r3
 800a7ac:	4b1c      	ldr	r3, [pc, #112]	; (800a820 <HAL_DMA_IRQHandler+0x70c>)
 800a7ae:	4299      	cmp	r1, r3
 800a7b0:	d049      	beq.n	800a846 <HAL_DMA_IRQHandler+0x732>
 800a7b2:	687b      	ldr	r3, [r7, #4]
 800a7b4:	681b      	ldr	r3, [r3, #0]
 800a7b6:	4619      	mov	r1, r3
 800a7b8:	4b1a      	ldr	r3, [pc, #104]	; (800a824 <HAL_DMA_IRQHandler+0x710>)
 800a7ba:	4299      	cmp	r1, r3
 800a7bc:	d040      	beq.n	800a840 <HAL_DMA_IRQHandler+0x72c>
 800a7be:	687b      	ldr	r3, [r7, #4]
 800a7c0:	681b      	ldr	r3, [r3, #0]
 800a7c2:	4619      	mov	r1, r3
 800a7c4:	4b18      	ldr	r3, [pc, #96]	; (800a828 <HAL_DMA_IRQHandler+0x714>)
 800a7c6:	4299      	cmp	r1, r3
 800a7c8:	d014      	beq.n	800a7f4 <HAL_DMA_IRQHandler+0x6e0>
 800a7ca:	687b      	ldr	r3, [r7, #4]
 800a7cc:	681b      	ldr	r3, [r3, #0]
 800a7ce:	4619      	mov	r1, r3
 800a7d0:	4b16      	ldr	r3, [pc, #88]	; (800a82c <HAL_DMA_IRQHandler+0x718>)
 800a7d2:	4299      	cmp	r1, r3
 800a7d4:	d00b      	beq.n	800a7ee <HAL_DMA_IRQHandler+0x6da>
 800a7d6:	687b      	ldr	r3, [r7, #4]
 800a7d8:	681b      	ldr	r3, [r3, #0]
 800a7da:	4619      	mov	r1, r3
 800a7dc:	4b14      	ldr	r3, [pc, #80]	; (800a830 <HAL_DMA_IRQHandler+0x71c>)
 800a7de:	4299      	cmp	r1, r3
 800a7e0:	d102      	bne.n	800a7e8 <HAL_DMA_IRQHandler+0x6d4>
 800a7e2:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a7e6:	e041      	b.n	800a86c <HAL_DMA_IRQHandler+0x758>
 800a7e8:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800a7ec:	e03e      	b.n	800a86c <HAL_DMA_IRQHandler+0x758>
 800a7ee:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a7f2:	e03b      	b.n	800a86c <HAL_DMA_IRQHandler+0x758>
 800a7f4:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a7f8:	e038      	b.n	800a86c <HAL_DMA_IRQHandler+0x758>
 800a7fa:	bf00      	nop
 800a7fc:	40026458 	.word	0x40026458
 800a800:	40026400 	.word	0x40026400
 800a804:	40026010 	.word	0x40026010
 800a808:	40026410 	.word	0x40026410
 800a80c:	40026070 	.word	0x40026070
 800a810:	40026470 	.word	0x40026470
 800a814:	40026028 	.word	0x40026028
 800a818:	40026428 	.word	0x40026428
 800a81c:	40026088 	.word	0x40026088
 800a820:	40026488 	.word	0x40026488
 800a824:	40026040 	.word	0x40026040
 800a828:	40026440 	.word	0x40026440
 800a82c:	400260a0 	.word	0x400260a0
 800a830:	400264a0 	.word	0x400264a0
 800a834:	400260b8 	.word	0x400260b8
 800a838:	40026058 	.word	0x40026058
 800a83c:	40026000 	.word	0x40026000
 800a840:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a844:	e012      	b.n	800a86c <HAL_DMA_IRQHandler+0x758>
 800a846:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a84a:	e00f      	b.n	800a86c <HAL_DMA_IRQHandler+0x758>
 800a84c:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a850:	e00c      	b.n	800a86c <HAL_DMA_IRQHandler+0x758>
 800a852:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a856:	e009      	b.n	800a86c <HAL_DMA_IRQHandler+0x758>
 800a858:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a85c:	e006      	b.n	800a86c <HAL_DMA_IRQHandler+0x758>
 800a85e:	2308      	movs	r3, #8
 800a860:	e004      	b.n	800a86c <HAL_DMA_IRQHandler+0x758>
 800a862:	2308      	movs	r3, #8
 800a864:	e002      	b.n	800a86c <HAL_DMA_IRQHandler+0x758>
 800a866:	2308      	movs	r3, #8
 800a868:	e000      	b.n	800a86c <HAL_DMA_IRQHandler+0x758>
 800a86a:	2308      	movs	r3, #8
 800a86c:	60d3      	str	r3, [r2, #12]
 800a86e:	e06b      	b.n	800a948 <HAL_DMA_IRQHandler+0x834>
 800a870:	4a7b      	ldr	r2, [pc, #492]	; (800aa60 <HAL_DMA_IRQHandler+0x94c>)
 800a872:	687b      	ldr	r3, [r7, #4]
 800a874:	681b      	ldr	r3, [r3, #0]
 800a876:	4619      	mov	r1, r3
 800a878:	4b7a      	ldr	r3, [pc, #488]	; (800aa64 <HAL_DMA_IRQHandler+0x950>)
 800a87a:	4299      	cmp	r1, r3
 800a87c:	d062      	beq.n	800a944 <HAL_DMA_IRQHandler+0x830>
 800a87e:	687b      	ldr	r3, [r7, #4]
 800a880:	681b      	ldr	r3, [r3, #0]
 800a882:	4619      	mov	r1, r3
 800a884:	4b78      	ldr	r3, [pc, #480]	; (800aa68 <HAL_DMA_IRQHandler+0x954>)
 800a886:	4299      	cmp	r1, r3
 800a888:	d05a      	beq.n	800a940 <HAL_DMA_IRQHandler+0x82c>
 800a88a:	687b      	ldr	r3, [r7, #4]
 800a88c:	681b      	ldr	r3, [r3, #0]
 800a88e:	4619      	mov	r1, r3
 800a890:	4b76      	ldr	r3, [pc, #472]	; (800aa6c <HAL_DMA_IRQHandler+0x958>)
 800a892:	4299      	cmp	r1, r3
 800a894:	d052      	beq.n	800a93c <HAL_DMA_IRQHandler+0x828>
 800a896:	687b      	ldr	r3, [r7, #4]
 800a898:	681b      	ldr	r3, [r3, #0]
 800a89a:	4619      	mov	r1, r3
 800a89c:	4b74      	ldr	r3, [pc, #464]	; (800aa70 <HAL_DMA_IRQHandler+0x95c>)
 800a89e:	4299      	cmp	r1, r3
 800a8a0:	d04a      	beq.n	800a938 <HAL_DMA_IRQHandler+0x824>
 800a8a2:	687b      	ldr	r3, [r7, #4]
 800a8a4:	681b      	ldr	r3, [r3, #0]
 800a8a6:	4619      	mov	r1, r3
 800a8a8:	4b72      	ldr	r3, [pc, #456]	; (800aa74 <HAL_DMA_IRQHandler+0x960>)
 800a8aa:	4299      	cmp	r1, r3
 800a8ac:	d041      	beq.n	800a932 <HAL_DMA_IRQHandler+0x81e>
 800a8ae:	687b      	ldr	r3, [r7, #4]
 800a8b0:	681b      	ldr	r3, [r3, #0]
 800a8b2:	4619      	mov	r1, r3
 800a8b4:	4b70      	ldr	r3, [pc, #448]	; (800aa78 <HAL_DMA_IRQHandler+0x964>)
 800a8b6:	4299      	cmp	r1, r3
 800a8b8:	d038      	beq.n	800a92c <HAL_DMA_IRQHandler+0x818>
 800a8ba:	687b      	ldr	r3, [r7, #4]
 800a8bc:	681b      	ldr	r3, [r3, #0]
 800a8be:	4619      	mov	r1, r3
 800a8c0:	4b6e      	ldr	r3, [pc, #440]	; (800aa7c <HAL_DMA_IRQHandler+0x968>)
 800a8c2:	4299      	cmp	r1, r3
 800a8c4:	d02f      	beq.n	800a926 <HAL_DMA_IRQHandler+0x812>
 800a8c6:	687b      	ldr	r3, [r7, #4]
 800a8c8:	681b      	ldr	r3, [r3, #0]
 800a8ca:	4619      	mov	r1, r3
 800a8cc:	4b6c      	ldr	r3, [pc, #432]	; (800aa80 <HAL_DMA_IRQHandler+0x96c>)
 800a8ce:	4299      	cmp	r1, r3
 800a8d0:	d026      	beq.n	800a920 <HAL_DMA_IRQHandler+0x80c>
 800a8d2:	687b      	ldr	r3, [r7, #4]
 800a8d4:	681b      	ldr	r3, [r3, #0]
 800a8d6:	4619      	mov	r1, r3
 800a8d8:	4b6a      	ldr	r3, [pc, #424]	; (800aa84 <HAL_DMA_IRQHandler+0x970>)
 800a8da:	4299      	cmp	r1, r3
 800a8dc:	d01d      	beq.n	800a91a <HAL_DMA_IRQHandler+0x806>
 800a8de:	687b      	ldr	r3, [r7, #4]
 800a8e0:	681b      	ldr	r3, [r3, #0]
 800a8e2:	4619      	mov	r1, r3
 800a8e4:	4b68      	ldr	r3, [pc, #416]	; (800aa88 <HAL_DMA_IRQHandler+0x974>)
 800a8e6:	4299      	cmp	r1, r3
 800a8e8:	d014      	beq.n	800a914 <HAL_DMA_IRQHandler+0x800>
 800a8ea:	687b      	ldr	r3, [r7, #4]
 800a8ec:	681b      	ldr	r3, [r3, #0]
 800a8ee:	4619      	mov	r1, r3
 800a8f0:	4b66      	ldr	r3, [pc, #408]	; (800aa8c <HAL_DMA_IRQHandler+0x978>)
 800a8f2:	4299      	cmp	r1, r3
 800a8f4:	d00b      	beq.n	800a90e <HAL_DMA_IRQHandler+0x7fa>
 800a8f6:	687b      	ldr	r3, [r7, #4]
 800a8f8:	681b      	ldr	r3, [r3, #0]
 800a8fa:	4619      	mov	r1, r3
 800a8fc:	4b64      	ldr	r3, [pc, #400]	; (800aa90 <HAL_DMA_IRQHandler+0x97c>)
 800a8fe:	4299      	cmp	r1, r3
 800a900:	d102      	bne.n	800a908 <HAL_DMA_IRQHandler+0x7f4>
 800a902:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a906:	e01e      	b.n	800a946 <HAL_DMA_IRQHandler+0x832>
 800a908:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800a90c:	e01b      	b.n	800a946 <HAL_DMA_IRQHandler+0x832>
 800a90e:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a912:	e018      	b.n	800a946 <HAL_DMA_IRQHandler+0x832>
 800a914:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a918:	e015      	b.n	800a946 <HAL_DMA_IRQHandler+0x832>
 800a91a:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a91e:	e012      	b.n	800a946 <HAL_DMA_IRQHandler+0x832>
 800a920:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a924:	e00f      	b.n	800a946 <HAL_DMA_IRQHandler+0x832>
 800a926:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a92a:	e00c      	b.n	800a946 <HAL_DMA_IRQHandler+0x832>
 800a92c:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a930:	e009      	b.n	800a946 <HAL_DMA_IRQHandler+0x832>
 800a932:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a936:	e006      	b.n	800a946 <HAL_DMA_IRQHandler+0x832>
 800a938:	2308      	movs	r3, #8
 800a93a:	e004      	b.n	800a946 <HAL_DMA_IRQHandler+0x832>
 800a93c:	2308      	movs	r3, #8
 800a93e:	e002      	b.n	800a946 <HAL_DMA_IRQHandler+0x832>
 800a940:	2308      	movs	r3, #8
 800a942:	e000      	b.n	800a946 <HAL_DMA_IRQHandler+0x832>
 800a944:	2308      	movs	r3, #8
 800a946:	6093      	str	r3, [r2, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 800a948:	687b      	ldr	r3, [r7, #4]
 800a94a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800a94c:	f043 0201 	orr.w	r2, r3, #1
 800a950:	687b      	ldr	r3, [r7, #4]
 800a952:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
 800a954:	687b      	ldr	r3, [r7, #4]
 800a956:	2204      	movs	r2, #4
 800a958:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma); 
 800a95c:	687b      	ldr	r3, [r7, #4]
 800a95e:	2200      	movs	r2, #0
 800a960:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      if(hdma->XferErrorCallback != NULL)
 800a964:	687b      	ldr	r3, [r7, #4]
 800a966:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a968:	2b00      	cmp	r3, #0
 800a96a:	d003      	beq.n	800a974 <HAL_DMA_IRQHandler+0x860>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 800a96c:	687b      	ldr	r3, [r7, #4]
 800a96e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a970:	6878      	ldr	r0, [r7, #4]
 800a972:	4798      	blx	r3
      }
    }
  }
  /* FIFO Error Interrupt management ******************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 800a974:	687b      	ldr	r3, [r7, #4]
 800a976:	681b      	ldr	r3, [r3, #0]
 800a978:	461a      	mov	r2, r3
 800a97a:	4b46      	ldr	r3, [pc, #280]	; (800aa94 <HAL_DMA_IRQHandler+0x980>)
 800a97c:	429a      	cmp	r2, r3
 800a97e:	f240 808f 	bls.w	800aaa0 <HAL_DMA_IRQHandler+0x98c>
 800a982:	4b45      	ldr	r3, [pc, #276]	; (800aa98 <HAL_DMA_IRQHandler+0x984>)
 800a984:	685a      	ldr	r2, [r3, #4]
 800a986:	687b      	ldr	r3, [r7, #4]
 800a988:	681b      	ldr	r3, [r3, #0]
 800a98a:	4619      	mov	r1, r3
 800a98c:	4b35      	ldr	r3, [pc, #212]	; (800aa64 <HAL_DMA_IRQHandler+0x950>)
 800a98e:	4299      	cmp	r1, r3
 800a990:	d05e      	beq.n	800aa50 <HAL_DMA_IRQHandler+0x93c>
 800a992:	687b      	ldr	r3, [r7, #4]
 800a994:	681b      	ldr	r3, [r3, #0]
 800a996:	4619      	mov	r1, r3
 800a998:	4b33      	ldr	r3, [pc, #204]	; (800aa68 <HAL_DMA_IRQHandler+0x954>)
 800a99a:	4299      	cmp	r1, r3
 800a99c:	d056      	beq.n	800aa4c <HAL_DMA_IRQHandler+0x938>
 800a99e:	687b      	ldr	r3, [r7, #4]
 800a9a0:	681b      	ldr	r3, [r3, #0]
 800a9a2:	4619      	mov	r1, r3
 800a9a4:	4b31      	ldr	r3, [pc, #196]	; (800aa6c <HAL_DMA_IRQHandler+0x958>)
 800a9a6:	4299      	cmp	r1, r3
 800a9a8:	d04e      	beq.n	800aa48 <HAL_DMA_IRQHandler+0x934>
 800a9aa:	687b      	ldr	r3, [r7, #4]
 800a9ac:	681b      	ldr	r3, [r3, #0]
 800a9ae:	4619      	mov	r1, r3
 800a9b0:	4b2f      	ldr	r3, [pc, #188]	; (800aa70 <HAL_DMA_IRQHandler+0x95c>)
 800a9b2:	4299      	cmp	r1, r3
 800a9b4:	d046      	beq.n	800aa44 <HAL_DMA_IRQHandler+0x930>
 800a9b6:	687b      	ldr	r3, [r7, #4]
 800a9b8:	681b      	ldr	r3, [r3, #0]
 800a9ba:	4619      	mov	r1, r3
 800a9bc:	4b2d      	ldr	r3, [pc, #180]	; (800aa74 <HAL_DMA_IRQHandler+0x960>)
 800a9be:	4299      	cmp	r1, r3
 800a9c0:	d03e      	beq.n	800aa40 <HAL_DMA_IRQHandler+0x92c>
 800a9c2:	687b      	ldr	r3, [r7, #4]
 800a9c4:	681b      	ldr	r3, [r3, #0]
 800a9c6:	4619      	mov	r1, r3
 800a9c8:	4b2b      	ldr	r3, [pc, #172]	; (800aa78 <HAL_DMA_IRQHandler+0x964>)
 800a9ca:	4299      	cmp	r1, r3
 800a9cc:	d036      	beq.n	800aa3c <HAL_DMA_IRQHandler+0x928>
 800a9ce:	687b      	ldr	r3, [r7, #4]
 800a9d0:	681b      	ldr	r3, [r3, #0]
 800a9d2:	4619      	mov	r1, r3
 800a9d4:	4b29      	ldr	r3, [pc, #164]	; (800aa7c <HAL_DMA_IRQHandler+0x968>)
 800a9d6:	4299      	cmp	r1, r3
 800a9d8:	d02e      	beq.n	800aa38 <HAL_DMA_IRQHandler+0x924>
 800a9da:	687b      	ldr	r3, [r7, #4]
 800a9dc:	681b      	ldr	r3, [r3, #0]
 800a9de:	4619      	mov	r1, r3
 800a9e0:	4b27      	ldr	r3, [pc, #156]	; (800aa80 <HAL_DMA_IRQHandler+0x96c>)
 800a9e2:	4299      	cmp	r1, r3
 800a9e4:	d026      	beq.n	800aa34 <HAL_DMA_IRQHandler+0x920>
 800a9e6:	687b      	ldr	r3, [r7, #4]
 800a9e8:	681b      	ldr	r3, [r3, #0]
 800a9ea:	4619      	mov	r1, r3
 800a9ec:	4b25      	ldr	r3, [pc, #148]	; (800aa84 <HAL_DMA_IRQHandler+0x970>)
 800a9ee:	4299      	cmp	r1, r3
 800a9f0:	d01d      	beq.n	800aa2e <HAL_DMA_IRQHandler+0x91a>
 800a9f2:	687b      	ldr	r3, [r7, #4]
 800a9f4:	681b      	ldr	r3, [r3, #0]
 800a9f6:	4619      	mov	r1, r3
 800a9f8:	4b23      	ldr	r3, [pc, #140]	; (800aa88 <HAL_DMA_IRQHandler+0x974>)
 800a9fa:	4299      	cmp	r1, r3
 800a9fc:	d014      	beq.n	800aa28 <HAL_DMA_IRQHandler+0x914>
 800a9fe:	687b      	ldr	r3, [r7, #4]
 800aa00:	681b      	ldr	r3, [r3, #0]
 800aa02:	4619      	mov	r1, r3
 800aa04:	4b21      	ldr	r3, [pc, #132]	; (800aa8c <HAL_DMA_IRQHandler+0x978>)
 800aa06:	4299      	cmp	r1, r3
 800aa08:	d00b      	beq.n	800aa22 <HAL_DMA_IRQHandler+0x90e>
 800aa0a:	687b      	ldr	r3, [r7, #4]
 800aa0c:	681b      	ldr	r3, [r3, #0]
 800aa0e:	4619      	mov	r1, r3
 800aa10:	4b1f      	ldr	r3, [pc, #124]	; (800aa90 <HAL_DMA_IRQHandler+0x97c>)
 800aa12:	4299      	cmp	r1, r3
 800aa14:	d102      	bne.n	800aa1c <HAL_DMA_IRQHandler+0x908>
 800aa16:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800aa1a:	e01a      	b.n	800aa52 <HAL_DMA_IRQHandler+0x93e>
 800aa1c:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800aa20:	e017      	b.n	800aa52 <HAL_DMA_IRQHandler+0x93e>
 800aa22:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800aa26:	e014      	b.n	800aa52 <HAL_DMA_IRQHandler+0x93e>
 800aa28:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800aa2c:	e011      	b.n	800aa52 <HAL_DMA_IRQHandler+0x93e>
 800aa2e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800aa32:	e00e      	b.n	800aa52 <HAL_DMA_IRQHandler+0x93e>
 800aa34:	2340      	movs	r3, #64	; 0x40
 800aa36:	e00c      	b.n	800aa52 <HAL_DMA_IRQHandler+0x93e>
 800aa38:	2340      	movs	r3, #64	; 0x40
 800aa3a:	e00a      	b.n	800aa52 <HAL_DMA_IRQHandler+0x93e>
 800aa3c:	2340      	movs	r3, #64	; 0x40
 800aa3e:	e008      	b.n	800aa52 <HAL_DMA_IRQHandler+0x93e>
 800aa40:	2340      	movs	r3, #64	; 0x40
 800aa42:	e006      	b.n	800aa52 <HAL_DMA_IRQHandler+0x93e>
 800aa44:	4b15      	ldr	r3, [pc, #84]	; (800aa9c <HAL_DMA_IRQHandler+0x988>)
 800aa46:	e004      	b.n	800aa52 <HAL_DMA_IRQHandler+0x93e>
 800aa48:	4b14      	ldr	r3, [pc, #80]	; (800aa9c <HAL_DMA_IRQHandler+0x988>)
 800aa4a:	e002      	b.n	800aa52 <HAL_DMA_IRQHandler+0x93e>
 800aa4c:	4b13      	ldr	r3, [pc, #76]	; (800aa9c <HAL_DMA_IRQHandler+0x988>)
 800aa4e:	e000      	b.n	800aa52 <HAL_DMA_IRQHandler+0x93e>
 800aa50:	4b12      	ldr	r3, [pc, #72]	; (800aa9c <HAL_DMA_IRQHandler+0x988>)
 800aa52:	4013      	ands	r3, r2
 800aa54:	2b00      	cmp	r3, #0
 800aa56:	bf14      	ite	ne
 800aa58:	2301      	movne	r3, #1
 800aa5a:	2300      	moveq	r3, #0
 800aa5c:	b2db      	uxtb	r3, r3
 800aa5e:	e19a      	b.n	800ad96 <HAL_DMA_IRQHandler+0xc82>
 800aa60:	40026000 	.word	0x40026000
 800aa64:	40026010 	.word	0x40026010
 800aa68:	40026410 	.word	0x40026410
 800aa6c:	40026070 	.word	0x40026070
 800aa70:	40026470 	.word	0x40026470
 800aa74:	40026028 	.word	0x40026028
 800aa78:	40026428 	.word	0x40026428
 800aa7c:	40026088 	.word	0x40026088
 800aa80:	40026488 	.word	0x40026488
 800aa84:	40026040 	.word	0x40026040
 800aa88:	40026440 	.word	0x40026440
 800aa8c:	400260a0 	.word	0x400260a0
 800aa90:	400264a0 	.word	0x400264a0
 800aa94:	40026458 	.word	0x40026458
 800aa98:	40026400 	.word	0x40026400
 800aa9c:	00800001 	.word	0x00800001
 800aaa0:	687b      	ldr	r3, [r7, #4]
 800aaa2:	681b      	ldr	r3, [r3, #0]
 800aaa4:	461a      	mov	r2, r3
 800aaa6:	4b9a      	ldr	r3, [pc, #616]	; (800ad10 <HAL_DMA_IRQHandler+0xbfc>)
 800aaa8:	429a      	cmp	r2, r3
 800aaaa:	d96e      	bls.n	800ab8a <HAL_DMA_IRQHandler+0xa76>
 800aaac:	4b99      	ldr	r3, [pc, #612]	; (800ad14 <HAL_DMA_IRQHandler+0xc00>)
 800aaae:	681a      	ldr	r2, [r3, #0]
 800aab0:	687b      	ldr	r3, [r7, #4]
 800aab2:	681b      	ldr	r3, [r3, #0]
 800aab4:	4619      	mov	r1, r3
 800aab6:	4b98      	ldr	r3, [pc, #608]	; (800ad18 <HAL_DMA_IRQHandler+0xc04>)
 800aab8:	4299      	cmp	r1, r3
 800aaba:	d05e      	beq.n	800ab7a <HAL_DMA_IRQHandler+0xa66>
 800aabc:	687b      	ldr	r3, [r7, #4]
 800aabe:	681b      	ldr	r3, [r3, #0]
 800aac0:	4619      	mov	r1, r3
 800aac2:	4b96      	ldr	r3, [pc, #600]	; (800ad1c <HAL_DMA_IRQHandler+0xc08>)
 800aac4:	4299      	cmp	r1, r3
 800aac6:	d056      	beq.n	800ab76 <HAL_DMA_IRQHandler+0xa62>
 800aac8:	687b      	ldr	r3, [r7, #4]
 800aaca:	681b      	ldr	r3, [r3, #0]
 800aacc:	4619      	mov	r1, r3
 800aace:	4b94      	ldr	r3, [pc, #592]	; (800ad20 <HAL_DMA_IRQHandler+0xc0c>)
 800aad0:	4299      	cmp	r1, r3
 800aad2:	d04e      	beq.n	800ab72 <HAL_DMA_IRQHandler+0xa5e>
 800aad4:	687b      	ldr	r3, [r7, #4]
 800aad6:	681b      	ldr	r3, [r3, #0]
 800aad8:	4619      	mov	r1, r3
 800aada:	4b92      	ldr	r3, [pc, #584]	; (800ad24 <HAL_DMA_IRQHandler+0xc10>)
 800aadc:	4299      	cmp	r1, r3
 800aade:	d046      	beq.n	800ab6e <HAL_DMA_IRQHandler+0xa5a>
 800aae0:	687b      	ldr	r3, [r7, #4]
 800aae2:	681b      	ldr	r3, [r3, #0]
 800aae4:	4619      	mov	r1, r3
 800aae6:	4b90      	ldr	r3, [pc, #576]	; (800ad28 <HAL_DMA_IRQHandler+0xc14>)
 800aae8:	4299      	cmp	r1, r3
 800aaea:	d03e      	beq.n	800ab6a <HAL_DMA_IRQHandler+0xa56>
 800aaec:	687b      	ldr	r3, [r7, #4]
 800aaee:	681b      	ldr	r3, [r3, #0]
 800aaf0:	4619      	mov	r1, r3
 800aaf2:	4b8e      	ldr	r3, [pc, #568]	; (800ad2c <HAL_DMA_IRQHandler+0xc18>)
 800aaf4:	4299      	cmp	r1, r3
 800aaf6:	d036      	beq.n	800ab66 <HAL_DMA_IRQHandler+0xa52>
 800aaf8:	687b      	ldr	r3, [r7, #4]
 800aafa:	681b      	ldr	r3, [r3, #0]
 800aafc:	4619      	mov	r1, r3
 800aafe:	4b8c      	ldr	r3, [pc, #560]	; (800ad30 <HAL_DMA_IRQHandler+0xc1c>)
 800ab00:	4299      	cmp	r1, r3
 800ab02:	d02e      	beq.n	800ab62 <HAL_DMA_IRQHandler+0xa4e>
 800ab04:	687b      	ldr	r3, [r7, #4]
 800ab06:	681b      	ldr	r3, [r3, #0]
 800ab08:	4619      	mov	r1, r3
 800ab0a:	4b8a      	ldr	r3, [pc, #552]	; (800ad34 <HAL_DMA_IRQHandler+0xc20>)
 800ab0c:	4299      	cmp	r1, r3
 800ab0e:	d026      	beq.n	800ab5e <HAL_DMA_IRQHandler+0xa4a>
 800ab10:	687b      	ldr	r3, [r7, #4]
 800ab12:	681b      	ldr	r3, [r3, #0]
 800ab14:	4619      	mov	r1, r3
 800ab16:	4b88      	ldr	r3, [pc, #544]	; (800ad38 <HAL_DMA_IRQHandler+0xc24>)
 800ab18:	4299      	cmp	r1, r3
 800ab1a:	d01d      	beq.n	800ab58 <HAL_DMA_IRQHandler+0xa44>
 800ab1c:	687b      	ldr	r3, [r7, #4]
 800ab1e:	681b      	ldr	r3, [r3, #0]
 800ab20:	4619      	mov	r1, r3
 800ab22:	4b86      	ldr	r3, [pc, #536]	; (800ad3c <HAL_DMA_IRQHandler+0xc28>)
 800ab24:	4299      	cmp	r1, r3
 800ab26:	d014      	beq.n	800ab52 <HAL_DMA_IRQHandler+0xa3e>
 800ab28:	687b      	ldr	r3, [r7, #4]
 800ab2a:	681b      	ldr	r3, [r3, #0]
 800ab2c:	4619      	mov	r1, r3
 800ab2e:	4b84      	ldr	r3, [pc, #528]	; (800ad40 <HAL_DMA_IRQHandler+0xc2c>)
 800ab30:	4299      	cmp	r1, r3
 800ab32:	d00b      	beq.n	800ab4c <HAL_DMA_IRQHandler+0xa38>
 800ab34:	687b      	ldr	r3, [r7, #4]
 800ab36:	681b      	ldr	r3, [r3, #0]
 800ab38:	4619      	mov	r1, r3
 800ab3a:	4b82      	ldr	r3, [pc, #520]	; (800ad44 <HAL_DMA_IRQHandler+0xc30>)
 800ab3c:	4299      	cmp	r1, r3
 800ab3e:	d102      	bne.n	800ab46 <HAL_DMA_IRQHandler+0xa32>
 800ab40:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800ab44:	e01a      	b.n	800ab7c <HAL_DMA_IRQHandler+0xa68>
 800ab46:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800ab4a:	e017      	b.n	800ab7c <HAL_DMA_IRQHandler+0xa68>
 800ab4c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800ab50:	e014      	b.n	800ab7c <HAL_DMA_IRQHandler+0xa68>
 800ab52:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800ab56:	e011      	b.n	800ab7c <HAL_DMA_IRQHandler+0xa68>
 800ab58:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800ab5c:	e00e      	b.n	800ab7c <HAL_DMA_IRQHandler+0xa68>
 800ab5e:	2340      	movs	r3, #64	; 0x40
 800ab60:	e00c      	b.n	800ab7c <HAL_DMA_IRQHandler+0xa68>
 800ab62:	2340      	movs	r3, #64	; 0x40
 800ab64:	e00a      	b.n	800ab7c <HAL_DMA_IRQHandler+0xa68>
 800ab66:	2340      	movs	r3, #64	; 0x40
 800ab68:	e008      	b.n	800ab7c <HAL_DMA_IRQHandler+0xa68>
 800ab6a:	2340      	movs	r3, #64	; 0x40
 800ab6c:	e006      	b.n	800ab7c <HAL_DMA_IRQHandler+0xa68>
 800ab6e:	4b76      	ldr	r3, [pc, #472]	; (800ad48 <HAL_DMA_IRQHandler+0xc34>)
 800ab70:	e004      	b.n	800ab7c <HAL_DMA_IRQHandler+0xa68>
 800ab72:	4b75      	ldr	r3, [pc, #468]	; (800ad48 <HAL_DMA_IRQHandler+0xc34>)
 800ab74:	e002      	b.n	800ab7c <HAL_DMA_IRQHandler+0xa68>
 800ab76:	4b74      	ldr	r3, [pc, #464]	; (800ad48 <HAL_DMA_IRQHandler+0xc34>)
 800ab78:	e000      	b.n	800ab7c <HAL_DMA_IRQHandler+0xa68>
 800ab7a:	4b73      	ldr	r3, [pc, #460]	; (800ad48 <HAL_DMA_IRQHandler+0xc34>)
 800ab7c:	4013      	ands	r3, r2
 800ab7e:	2b00      	cmp	r3, #0
 800ab80:	bf14      	ite	ne
 800ab82:	2301      	movne	r3, #1
 800ab84:	2300      	moveq	r3, #0
 800ab86:	b2db      	uxtb	r3, r3
 800ab88:	e105      	b.n	800ad96 <HAL_DMA_IRQHandler+0xc82>
 800ab8a:	687b      	ldr	r3, [r7, #4]
 800ab8c:	681b      	ldr	r3, [r3, #0]
 800ab8e:	461a      	mov	r2, r3
 800ab90:	4b6e      	ldr	r3, [pc, #440]	; (800ad4c <HAL_DMA_IRQHandler+0xc38>)
 800ab92:	429a      	cmp	r2, r3
 800ab94:	d96e      	bls.n	800ac74 <HAL_DMA_IRQHandler+0xb60>
 800ab96:	4b6e      	ldr	r3, [pc, #440]	; (800ad50 <HAL_DMA_IRQHandler+0xc3c>)
 800ab98:	685a      	ldr	r2, [r3, #4]
 800ab9a:	687b      	ldr	r3, [r7, #4]
 800ab9c:	681b      	ldr	r3, [r3, #0]
 800ab9e:	4619      	mov	r1, r3
 800aba0:	4b5d      	ldr	r3, [pc, #372]	; (800ad18 <HAL_DMA_IRQHandler+0xc04>)
 800aba2:	4299      	cmp	r1, r3
 800aba4:	d05e      	beq.n	800ac64 <HAL_DMA_IRQHandler+0xb50>
 800aba6:	687b      	ldr	r3, [r7, #4]
 800aba8:	681b      	ldr	r3, [r3, #0]
 800abaa:	4619      	mov	r1, r3
 800abac:	4b5b      	ldr	r3, [pc, #364]	; (800ad1c <HAL_DMA_IRQHandler+0xc08>)
 800abae:	4299      	cmp	r1, r3
 800abb0:	d056      	beq.n	800ac60 <HAL_DMA_IRQHandler+0xb4c>
 800abb2:	687b      	ldr	r3, [r7, #4]
 800abb4:	681b      	ldr	r3, [r3, #0]
 800abb6:	4619      	mov	r1, r3
 800abb8:	4b59      	ldr	r3, [pc, #356]	; (800ad20 <HAL_DMA_IRQHandler+0xc0c>)
 800abba:	4299      	cmp	r1, r3
 800abbc:	d04e      	beq.n	800ac5c <HAL_DMA_IRQHandler+0xb48>
 800abbe:	687b      	ldr	r3, [r7, #4]
 800abc0:	681b      	ldr	r3, [r3, #0]
 800abc2:	4619      	mov	r1, r3
 800abc4:	4b57      	ldr	r3, [pc, #348]	; (800ad24 <HAL_DMA_IRQHandler+0xc10>)
 800abc6:	4299      	cmp	r1, r3
 800abc8:	d046      	beq.n	800ac58 <HAL_DMA_IRQHandler+0xb44>
 800abca:	687b      	ldr	r3, [r7, #4]
 800abcc:	681b      	ldr	r3, [r3, #0]
 800abce:	4619      	mov	r1, r3
 800abd0:	4b55      	ldr	r3, [pc, #340]	; (800ad28 <HAL_DMA_IRQHandler+0xc14>)
 800abd2:	4299      	cmp	r1, r3
 800abd4:	d03e      	beq.n	800ac54 <HAL_DMA_IRQHandler+0xb40>
 800abd6:	687b      	ldr	r3, [r7, #4]
 800abd8:	681b      	ldr	r3, [r3, #0]
 800abda:	4619      	mov	r1, r3
 800abdc:	4b53      	ldr	r3, [pc, #332]	; (800ad2c <HAL_DMA_IRQHandler+0xc18>)
 800abde:	4299      	cmp	r1, r3
 800abe0:	d036      	beq.n	800ac50 <HAL_DMA_IRQHandler+0xb3c>
 800abe2:	687b      	ldr	r3, [r7, #4]
 800abe4:	681b      	ldr	r3, [r3, #0]
 800abe6:	4619      	mov	r1, r3
 800abe8:	4b51      	ldr	r3, [pc, #324]	; (800ad30 <HAL_DMA_IRQHandler+0xc1c>)
 800abea:	4299      	cmp	r1, r3
 800abec:	d02e      	beq.n	800ac4c <HAL_DMA_IRQHandler+0xb38>
 800abee:	687b      	ldr	r3, [r7, #4]
 800abf0:	681b      	ldr	r3, [r3, #0]
 800abf2:	4619      	mov	r1, r3
 800abf4:	4b4f      	ldr	r3, [pc, #316]	; (800ad34 <HAL_DMA_IRQHandler+0xc20>)
 800abf6:	4299      	cmp	r1, r3
 800abf8:	d026      	beq.n	800ac48 <HAL_DMA_IRQHandler+0xb34>
 800abfa:	687b      	ldr	r3, [r7, #4]
 800abfc:	681b      	ldr	r3, [r3, #0]
 800abfe:	4619      	mov	r1, r3
 800ac00:	4b4d      	ldr	r3, [pc, #308]	; (800ad38 <HAL_DMA_IRQHandler+0xc24>)
 800ac02:	4299      	cmp	r1, r3
 800ac04:	d01d      	beq.n	800ac42 <HAL_DMA_IRQHandler+0xb2e>
 800ac06:	687b      	ldr	r3, [r7, #4]
 800ac08:	681b      	ldr	r3, [r3, #0]
 800ac0a:	4619      	mov	r1, r3
 800ac0c:	4b4b      	ldr	r3, [pc, #300]	; (800ad3c <HAL_DMA_IRQHandler+0xc28>)
 800ac0e:	4299      	cmp	r1, r3
 800ac10:	d014      	beq.n	800ac3c <HAL_DMA_IRQHandler+0xb28>
 800ac12:	687b      	ldr	r3, [r7, #4]
 800ac14:	681b      	ldr	r3, [r3, #0]
 800ac16:	4619      	mov	r1, r3
 800ac18:	4b49      	ldr	r3, [pc, #292]	; (800ad40 <HAL_DMA_IRQHandler+0xc2c>)
 800ac1a:	4299      	cmp	r1, r3
 800ac1c:	d00b      	beq.n	800ac36 <HAL_DMA_IRQHandler+0xb22>
 800ac1e:	687b      	ldr	r3, [r7, #4]
 800ac20:	681b      	ldr	r3, [r3, #0]
 800ac22:	4619      	mov	r1, r3
 800ac24:	4b47      	ldr	r3, [pc, #284]	; (800ad44 <HAL_DMA_IRQHandler+0xc30>)
 800ac26:	4299      	cmp	r1, r3
 800ac28:	d102      	bne.n	800ac30 <HAL_DMA_IRQHandler+0xb1c>
 800ac2a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800ac2e:	e01a      	b.n	800ac66 <HAL_DMA_IRQHandler+0xb52>
 800ac30:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800ac34:	e017      	b.n	800ac66 <HAL_DMA_IRQHandler+0xb52>
 800ac36:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800ac3a:	e014      	b.n	800ac66 <HAL_DMA_IRQHandler+0xb52>
 800ac3c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800ac40:	e011      	b.n	800ac66 <HAL_DMA_IRQHandler+0xb52>
 800ac42:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800ac46:	e00e      	b.n	800ac66 <HAL_DMA_IRQHandler+0xb52>
 800ac48:	2340      	movs	r3, #64	; 0x40
 800ac4a:	e00c      	b.n	800ac66 <HAL_DMA_IRQHandler+0xb52>
 800ac4c:	2340      	movs	r3, #64	; 0x40
 800ac4e:	e00a      	b.n	800ac66 <HAL_DMA_IRQHandler+0xb52>
 800ac50:	2340      	movs	r3, #64	; 0x40
 800ac52:	e008      	b.n	800ac66 <HAL_DMA_IRQHandler+0xb52>
 800ac54:	2340      	movs	r3, #64	; 0x40
 800ac56:	e006      	b.n	800ac66 <HAL_DMA_IRQHandler+0xb52>
 800ac58:	4b3b      	ldr	r3, [pc, #236]	; (800ad48 <HAL_DMA_IRQHandler+0xc34>)
 800ac5a:	e004      	b.n	800ac66 <HAL_DMA_IRQHandler+0xb52>
 800ac5c:	4b3a      	ldr	r3, [pc, #232]	; (800ad48 <HAL_DMA_IRQHandler+0xc34>)
 800ac5e:	e002      	b.n	800ac66 <HAL_DMA_IRQHandler+0xb52>
 800ac60:	4b39      	ldr	r3, [pc, #228]	; (800ad48 <HAL_DMA_IRQHandler+0xc34>)
 800ac62:	e000      	b.n	800ac66 <HAL_DMA_IRQHandler+0xb52>
 800ac64:	4b38      	ldr	r3, [pc, #224]	; (800ad48 <HAL_DMA_IRQHandler+0xc34>)
 800ac66:	4013      	ands	r3, r2
 800ac68:	2b00      	cmp	r3, #0
 800ac6a:	bf14      	ite	ne
 800ac6c:	2301      	movne	r3, #1
 800ac6e:	2300      	moveq	r3, #0
 800ac70:	b2db      	uxtb	r3, r3
 800ac72:	e090      	b.n	800ad96 <HAL_DMA_IRQHandler+0xc82>
 800ac74:	4b36      	ldr	r3, [pc, #216]	; (800ad50 <HAL_DMA_IRQHandler+0xc3c>)
 800ac76:	681a      	ldr	r2, [r3, #0]
 800ac78:	687b      	ldr	r3, [r7, #4]
 800ac7a:	681b      	ldr	r3, [r3, #0]
 800ac7c:	4619      	mov	r1, r3
 800ac7e:	4b26      	ldr	r3, [pc, #152]	; (800ad18 <HAL_DMA_IRQHandler+0xc04>)
 800ac80:	4299      	cmp	r1, r3
 800ac82:	f000 8081 	beq.w	800ad88 <HAL_DMA_IRQHandler+0xc74>
 800ac86:	687b      	ldr	r3, [r7, #4]
 800ac88:	681b      	ldr	r3, [r3, #0]
 800ac8a:	4619      	mov	r1, r3
 800ac8c:	4b23      	ldr	r3, [pc, #140]	; (800ad1c <HAL_DMA_IRQHandler+0xc08>)
 800ac8e:	4299      	cmp	r1, r3
 800ac90:	d078      	beq.n	800ad84 <HAL_DMA_IRQHandler+0xc70>
 800ac92:	687b      	ldr	r3, [r7, #4]
 800ac94:	681b      	ldr	r3, [r3, #0]
 800ac96:	4619      	mov	r1, r3
 800ac98:	4b21      	ldr	r3, [pc, #132]	; (800ad20 <HAL_DMA_IRQHandler+0xc0c>)
 800ac9a:	4299      	cmp	r1, r3
 800ac9c:	d070      	beq.n	800ad80 <HAL_DMA_IRQHandler+0xc6c>
 800ac9e:	687b      	ldr	r3, [r7, #4]
 800aca0:	681b      	ldr	r3, [r3, #0]
 800aca2:	4619      	mov	r1, r3
 800aca4:	4b1f      	ldr	r3, [pc, #124]	; (800ad24 <HAL_DMA_IRQHandler+0xc10>)
 800aca6:	4299      	cmp	r1, r3
 800aca8:	d068      	beq.n	800ad7c <HAL_DMA_IRQHandler+0xc68>
 800acaa:	687b      	ldr	r3, [r7, #4]
 800acac:	681b      	ldr	r3, [r3, #0]
 800acae:	4619      	mov	r1, r3
 800acb0:	4b1d      	ldr	r3, [pc, #116]	; (800ad28 <HAL_DMA_IRQHandler+0xc14>)
 800acb2:	4299      	cmp	r1, r3
 800acb4:	d060      	beq.n	800ad78 <HAL_DMA_IRQHandler+0xc64>
 800acb6:	687b      	ldr	r3, [r7, #4]
 800acb8:	681b      	ldr	r3, [r3, #0]
 800acba:	4619      	mov	r1, r3
 800acbc:	4b1b      	ldr	r3, [pc, #108]	; (800ad2c <HAL_DMA_IRQHandler+0xc18>)
 800acbe:	4299      	cmp	r1, r3
 800acc0:	d058      	beq.n	800ad74 <HAL_DMA_IRQHandler+0xc60>
 800acc2:	687b      	ldr	r3, [r7, #4]
 800acc4:	681b      	ldr	r3, [r3, #0]
 800acc6:	4619      	mov	r1, r3
 800acc8:	4b19      	ldr	r3, [pc, #100]	; (800ad30 <HAL_DMA_IRQHandler+0xc1c>)
 800acca:	4299      	cmp	r1, r3
 800accc:	d050      	beq.n	800ad70 <HAL_DMA_IRQHandler+0xc5c>
 800acce:	687b      	ldr	r3, [r7, #4]
 800acd0:	681b      	ldr	r3, [r3, #0]
 800acd2:	4619      	mov	r1, r3
 800acd4:	4b17      	ldr	r3, [pc, #92]	; (800ad34 <HAL_DMA_IRQHandler+0xc20>)
 800acd6:	4299      	cmp	r1, r3
 800acd8:	d048      	beq.n	800ad6c <HAL_DMA_IRQHandler+0xc58>
 800acda:	687b      	ldr	r3, [r7, #4]
 800acdc:	681b      	ldr	r3, [r3, #0]
 800acde:	4619      	mov	r1, r3
 800ace0:	4b15      	ldr	r3, [pc, #84]	; (800ad38 <HAL_DMA_IRQHandler+0xc24>)
 800ace2:	4299      	cmp	r1, r3
 800ace4:	d03f      	beq.n	800ad66 <HAL_DMA_IRQHandler+0xc52>
 800ace6:	687b      	ldr	r3, [r7, #4]
 800ace8:	681b      	ldr	r3, [r3, #0]
 800acea:	4619      	mov	r1, r3
 800acec:	4b13      	ldr	r3, [pc, #76]	; (800ad3c <HAL_DMA_IRQHandler+0xc28>)
 800acee:	4299      	cmp	r1, r3
 800acf0:	d036      	beq.n	800ad60 <HAL_DMA_IRQHandler+0xc4c>
 800acf2:	687b      	ldr	r3, [r7, #4]
 800acf4:	681b      	ldr	r3, [r3, #0]
 800acf6:	4619      	mov	r1, r3
 800acf8:	4b11      	ldr	r3, [pc, #68]	; (800ad40 <HAL_DMA_IRQHandler+0xc2c>)
 800acfa:	4299      	cmp	r1, r3
 800acfc:	d02d      	beq.n	800ad5a <HAL_DMA_IRQHandler+0xc46>
 800acfe:	687b      	ldr	r3, [r7, #4]
 800ad00:	681b      	ldr	r3, [r3, #0]
 800ad02:	4619      	mov	r1, r3
 800ad04:	4b0f      	ldr	r3, [pc, #60]	; (800ad44 <HAL_DMA_IRQHandler+0xc30>)
 800ad06:	4299      	cmp	r1, r3
 800ad08:	d124      	bne.n	800ad54 <HAL_DMA_IRQHandler+0xc40>
 800ad0a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800ad0e:	e03c      	b.n	800ad8a <HAL_DMA_IRQHandler+0xc76>
 800ad10:	400260b8 	.word	0x400260b8
 800ad14:	40026400 	.word	0x40026400
 800ad18:	40026010 	.word	0x40026010
 800ad1c:	40026410 	.word	0x40026410
 800ad20:	40026070 	.word	0x40026070
 800ad24:	40026470 	.word	0x40026470
 800ad28:	40026028 	.word	0x40026028
 800ad2c:	40026428 	.word	0x40026428
 800ad30:	40026088 	.word	0x40026088
 800ad34:	40026488 	.word	0x40026488
 800ad38:	40026040 	.word	0x40026040
 800ad3c:	40026440 	.word	0x40026440
 800ad40:	400260a0 	.word	0x400260a0
 800ad44:	400264a0 	.word	0x400264a0
 800ad48:	00800001 	.word	0x00800001
 800ad4c:	40026058 	.word	0x40026058
 800ad50:	40026000 	.word	0x40026000
 800ad54:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800ad58:	e017      	b.n	800ad8a <HAL_DMA_IRQHandler+0xc76>
 800ad5a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800ad5e:	e014      	b.n	800ad8a <HAL_DMA_IRQHandler+0xc76>
 800ad60:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800ad64:	e011      	b.n	800ad8a <HAL_DMA_IRQHandler+0xc76>
 800ad66:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800ad6a:	e00e      	b.n	800ad8a <HAL_DMA_IRQHandler+0xc76>
 800ad6c:	2340      	movs	r3, #64	; 0x40
 800ad6e:	e00c      	b.n	800ad8a <HAL_DMA_IRQHandler+0xc76>
 800ad70:	2340      	movs	r3, #64	; 0x40
 800ad72:	e00a      	b.n	800ad8a <HAL_DMA_IRQHandler+0xc76>
 800ad74:	2340      	movs	r3, #64	; 0x40
 800ad76:	e008      	b.n	800ad8a <HAL_DMA_IRQHandler+0xc76>
 800ad78:	2340      	movs	r3, #64	; 0x40
 800ad7a:	e006      	b.n	800ad8a <HAL_DMA_IRQHandler+0xc76>
 800ad7c:	4b7f      	ldr	r3, [pc, #508]	; (800af7c <HAL_DMA_IRQHandler+0xe68>)
 800ad7e:	e004      	b.n	800ad8a <HAL_DMA_IRQHandler+0xc76>
 800ad80:	4b7e      	ldr	r3, [pc, #504]	; (800af7c <HAL_DMA_IRQHandler+0xe68>)
 800ad82:	e002      	b.n	800ad8a <HAL_DMA_IRQHandler+0xc76>
 800ad84:	4b7d      	ldr	r3, [pc, #500]	; (800af7c <HAL_DMA_IRQHandler+0xe68>)
 800ad86:	e000      	b.n	800ad8a <HAL_DMA_IRQHandler+0xc76>
 800ad88:	4b7c      	ldr	r3, [pc, #496]	; (800af7c <HAL_DMA_IRQHandler+0xe68>)
 800ad8a:	4013      	ands	r3, r2
 800ad8c:	2b00      	cmp	r3, #0
 800ad8e:	bf14      	ite	ne
 800ad90:	2301      	movne	r3, #1
 800ad92:	2300      	moveq	r3, #0
 800ad94:	b2db      	uxtb	r3, r3
 800ad96:	2b00      	cmp	r3, #0
 800ad98:	f000 821c 	beq.w	800b1d4 <HAL_DMA_IRQHandler+0x10c0>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 800ad9c:	687b      	ldr	r3, [r7, #4]
 800ad9e:	681b      	ldr	r3, [r3, #0]
 800ada0:	695b      	ldr	r3, [r3, #20]
 800ada2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800ada6:	2b00      	cmp	r3, #0
 800ada8:	f000 8214 	beq.w	800b1d4 <HAL_DMA_IRQHandler+0x10c0>
    {
      /* Disable the FIFO Error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_FE);
 800adac:	687b      	ldr	r3, [r7, #4]
 800adae:	681b      	ldr	r3, [r3, #0]
 800adb0:	687a      	ldr	r2, [r7, #4]
 800adb2:	6812      	ldr	r2, [r2, #0]
 800adb4:	6952      	ldr	r2, [r2, #20]
 800adb6:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800adba:	615a      	str	r2, [r3, #20]

      /* Clear the FIFO error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 800adbc:	687b      	ldr	r3, [r7, #4]
 800adbe:	681b      	ldr	r3, [r3, #0]
 800adc0:	461a      	mov	r2, r3
 800adc2:	4b6f      	ldr	r3, [pc, #444]	; (800af80 <HAL_DMA_IRQHandler+0xe6c>)
 800adc4:	429a      	cmp	r2, r3
 800adc6:	d968      	bls.n	800ae9a <HAL_DMA_IRQHandler+0xd86>
 800adc8:	4a6e      	ldr	r2, [pc, #440]	; (800af84 <HAL_DMA_IRQHandler+0xe70>)
 800adca:	687b      	ldr	r3, [r7, #4]
 800adcc:	681b      	ldr	r3, [r3, #0]
 800adce:	4619      	mov	r1, r3
 800add0:	4b6d      	ldr	r3, [pc, #436]	; (800af88 <HAL_DMA_IRQHandler+0xe74>)
 800add2:	4299      	cmp	r1, r3
 800add4:	d05e      	beq.n	800ae94 <HAL_DMA_IRQHandler+0xd80>
 800add6:	687b      	ldr	r3, [r7, #4]
 800add8:	681b      	ldr	r3, [r3, #0]
 800adda:	4619      	mov	r1, r3
 800addc:	4b6b      	ldr	r3, [pc, #428]	; (800af8c <HAL_DMA_IRQHandler+0xe78>)
 800adde:	4299      	cmp	r1, r3
 800ade0:	d056      	beq.n	800ae90 <HAL_DMA_IRQHandler+0xd7c>
 800ade2:	687b      	ldr	r3, [r7, #4]
 800ade4:	681b      	ldr	r3, [r3, #0]
 800ade6:	4619      	mov	r1, r3
 800ade8:	4b69      	ldr	r3, [pc, #420]	; (800af90 <HAL_DMA_IRQHandler+0xe7c>)
 800adea:	4299      	cmp	r1, r3
 800adec:	d04e      	beq.n	800ae8c <HAL_DMA_IRQHandler+0xd78>
 800adee:	687b      	ldr	r3, [r7, #4]
 800adf0:	681b      	ldr	r3, [r3, #0]
 800adf2:	4619      	mov	r1, r3
 800adf4:	4b67      	ldr	r3, [pc, #412]	; (800af94 <HAL_DMA_IRQHandler+0xe80>)
 800adf6:	4299      	cmp	r1, r3
 800adf8:	d046      	beq.n	800ae88 <HAL_DMA_IRQHandler+0xd74>
 800adfa:	687b      	ldr	r3, [r7, #4]
 800adfc:	681b      	ldr	r3, [r3, #0]
 800adfe:	4619      	mov	r1, r3
 800ae00:	4b65      	ldr	r3, [pc, #404]	; (800af98 <HAL_DMA_IRQHandler+0xe84>)
 800ae02:	4299      	cmp	r1, r3
 800ae04:	d03e      	beq.n	800ae84 <HAL_DMA_IRQHandler+0xd70>
 800ae06:	687b      	ldr	r3, [r7, #4]
 800ae08:	681b      	ldr	r3, [r3, #0]
 800ae0a:	4619      	mov	r1, r3
 800ae0c:	4b63      	ldr	r3, [pc, #396]	; (800af9c <HAL_DMA_IRQHandler+0xe88>)
 800ae0e:	4299      	cmp	r1, r3
 800ae10:	d036      	beq.n	800ae80 <HAL_DMA_IRQHandler+0xd6c>
 800ae12:	687b      	ldr	r3, [r7, #4]
 800ae14:	681b      	ldr	r3, [r3, #0]
 800ae16:	4619      	mov	r1, r3
 800ae18:	4b61      	ldr	r3, [pc, #388]	; (800afa0 <HAL_DMA_IRQHandler+0xe8c>)
 800ae1a:	4299      	cmp	r1, r3
 800ae1c:	d02e      	beq.n	800ae7c <HAL_DMA_IRQHandler+0xd68>
 800ae1e:	687b      	ldr	r3, [r7, #4]
 800ae20:	681b      	ldr	r3, [r3, #0]
 800ae22:	4619      	mov	r1, r3
 800ae24:	4b5f      	ldr	r3, [pc, #380]	; (800afa4 <HAL_DMA_IRQHandler+0xe90>)
 800ae26:	4299      	cmp	r1, r3
 800ae28:	d026      	beq.n	800ae78 <HAL_DMA_IRQHandler+0xd64>
 800ae2a:	687b      	ldr	r3, [r7, #4]
 800ae2c:	681b      	ldr	r3, [r3, #0]
 800ae2e:	4619      	mov	r1, r3
 800ae30:	4b5d      	ldr	r3, [pc, #372]	; (800afa8 <HAL_DMA_IRQHandler+0xe94>)
 800ae32:	4299      	cmp	r1, r3
 800ae34:	d01d      	beq.n	800ae72 <HAL_DMA_IRQHandler+0xd5e>
 800ae36:	687b      	ldr	r3, [r7, #4]
 800ae38:	681b      	ldr	r3, [r3, #0]
 800ae3a:	4619      	mov	r1, r3
 800ae3c:	4b5b      	ldr	r3, [pc, #364]	; (800afac <HAL_DMA_IRQHandler+0xe98>)
 800ae3e:	4299      	cmp	r1, r3
 800ae40:	d014      	beq.n	800ae6c <HAL_DMA_IRQHandler+0xd58>
 800ae42:	687b      	ldr	r3, [r7, #4]
 800ae44:	681b      	ldr	r3, [r3, #0]
 800ae46:	4619      	mov	r1, r3
 800ae48:	4b59      	ldr	r3, [pc, #356]	; (800afb0 <HAL_DMA_IRQHandler+0xe9c>)
 800ae4a:	4299      	cmp	r1, r3
 800ae4c:	d00b      	beq.n	800ae66 <HAL_DMA_IRQHandler+0xd52>
 800ae4e:	687b      	ldr	r3, [r7, #4]
 800ae50:	681b      	ldr	r3, [r3, #0]
 800ae52:	4619      	mov	r1, r3
 800ae54:	4b57      	ldr	r3, [pc, #348]	; (800afb4 <HAL_DMA_IRQHandler+0xea0>)
 800ae56:	4299      	cmp	r1, r3
 800ae58:	d102      	bne.n	800ae60 <HAL_DMA_IRQHandler+0xd4c>
 800ae5a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800ae5e:	e01a      	b.n	800ae96 <HAL_DMA_IRQHandler+0xd82>
 800ae60:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800ae64:	e017      	b.n	800ae96 <HAL_DMA_IRQHandler+0xd82>
 800ae66:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800ae6a:	e014      	b.n	800ae96 <HAL_DMA_IRQHandler+0xd82>
 800ae6c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800ae70:	e011      	b.n	800ae96 <HAL_DMA_IRQHandler+0xd82>
 800ae72:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800ae76:	e00e      	b.n	800ae96 <HAL_DMA_IRQHandler+0xd82>
 800ae78:	2340      	movs	r3, #64	; 0x40
 800ae7a:	e00c      	b.n	800ae96 <HAL_DMA_IRQHandler+0xd82>
 800ae7c:	2340      	movs	r3, #64	; 0x40
 800ae7e:	e00a      	b.n	800ae96 <HAL_DMA_IRQHandler+0xd82>
 800ae80:	2340      	movs	r3, #64	; 0x40
 800ae82:	e008      	b.n	800ae96 <HAL_DMA_IRQHandler+0xd82>
 800ae84:	2340      	movs	r3, #64	; 0x40
 800ae86:	e006      	b.n	800ae96 <HAL_DMA_IRQHandler+0xd82>
 800ae88:	4b3c      	ldr	r3, [pc, #240]	; (800af7c <HAL_DMA_IRQHandler+0xe68>)
 800ae8a:	e004      	b.n	800ae96 <HAL_DMA_IRQHandler+0xd82>
 800ae8c:	4b3b      	ldr	r3, [pc, #236]	; (800af7c <HAL_DMA_IRQHandler+0xe68>)
 800ae8e:	e002      	b.n	800ae96 <HAL_DMA_IRQHandler+0xd82>
 800ae90:	4b3a      	ldr	r3, [pc, #232]	; (800af7c <HAL_DMA_IRQHandler+0xe68>)
 800ae92:	e000      	b.n	800ae96 <HAL_DMA_IRQHandler+0xd82>
 800ae94:	4b39      	ldr	r3, [pc, #228]	; (800af7c <HAL_DMA_IRQHandler+0xe68>)
 800ae96:	60d3      	str	r3, [r2, #12]
 800ae98:	e186      	b.n	800b1a8 <HAL_DMA_IRQHandler+0x1094>
 800ae9a:	687b      	ldr	r3, [r7, #4]
 800ae9c:	681b      	ldr	r3, [r3, #0]
 800ae9e:	461a      	mov	r2, r3
 800aea0:	4b45      	ldr	r3, [pc, #276]	; (800afb8 <HAL_DMA_IRQHandler+0xea4>)
 800aea2:	429a      	cmp	r2, r3
 800aea4:	f240 808a 	bls.w	800afbc <HAL_DMA_IRQHandler+0xea8>
 800aea8:	4a36      	ldr	r2, [pc, #216]	; (800af84 <HAL_DMA_IRQHandler+0xe70>)
 800aeaa:	687b      	ldr	r3, [r7, #4]
 800aeac:	681b      	ldr	r3, [r3, #0]
 800aeae:	4619      	mov	r1, r3
 800aeb0:	4b35      	ldr	r3, [pc, #212]	; (800af88 <HAL_DMA_IRQHandler+0xe74>)
 800aeb2:	4299      	cmp	r1, r3
 800aeb4:	d05e      	beq.n	800af74 <HAL_DMA_IRQHandler+0xe60>
 800aeb6:	687b      	ldr	r3, [r7, #4]
 800aeb8:	681b      	ldr	r3, [r3, #0]
 800aeba:	4619      	mov	r1, r3
 800aebc:	4b33      	ldr	r3, [pc, #204]	; (800af8c <HAL_DMA_IRQHandler+0xe78>)
 800aebe:	4299      	cmp	r1, r3
 800aec0:	d056      	beq.n	800af70 <HAL_DMA_IRQHandler+0xe5c>
 800aec2:	687b      	ldr	r3, [r7, #4]
 800aec4:	681b      	ldr	r3, [r3, #0]
 800aec6:	4619      	mov	r1, r3
 800aec8:	4b31      	ldr	r3, [pc, #196]	; (800af90 <HAL_DMA_IRQHandler+0xe7c>)
 800aeca:	4299      	cmp	r1, r3
 800aecc:	d04e      	beq.n	800af6c <HAL_DMA_IRQHandler+0xe58>
 800aece:	687b      	ldr	r3, [r7, #4]
 800aed0:	681b      	ldr	r3, [r3, #0]
 800aed2:	4619      	mov	r1, r3
 800aed4:	4b2f      	ldr	r3, [pc, #188]	; (800af94 <HAL_DMA_IRQHandler+0xe80>)
 800aed6:	4299      	cmp	r1, r3
 800aed8:	d046      	beq.n	800af68 <HAL_DMA_IRQHandler+0xe54>
 800aeda:	687b      	ldr	r3, [r7, #4]
 800aedc:	681b      	ldr	r3, [r3, #0]
 800aede:	4619      	mov	r1, r3
 800aee0:	4b2d      	ldr	r3, [pc, #180]	; (800af98 <HAL_DMA_IRQHandler+0xe84>)
 800aee2:	4299      	cmp	r1, r3
 800aee4:	d03e      	beq.n	800af64 <HAL_DMA_IRQHandler+0xe50>
 800aee6:	687b      	ldr	r3, [r7, #4]
 800aee8:	681b      	ldr	r3, [r3, #0]
 800aeea:	4619      	mov	r1, r3
 800aeec:	4b2b      	ldr	r3, [pc, #172]	; (800af9c <HAL_DMA_IRQHandler+0xe88>)
 800aeee:	4299      	cmp	r1, r3
 800aef0:	d036      	beq.n	800af60 <HAL_DMA_IRQHandler+0xe4c>
 800aef2:	687b      	ldr	r3, [r7, #4]
 800aef4:	681b      	ldr	r3, [r3, #0]
 800aef6:	4619      	mov	r1, r3
 800aef8:	4b29      	ldr	r3, [pc, #164]	; (800afa0 <HAL_DMA_IRQHandler+0xe8c>)
 800aefa:	4299      	cmp	r1, r3
 800aefc:	d02e      	beq.n	800af5c <HAL_DMA_IRQHandler+0xe48>
 800aefe:	687b      	ldr	r3, [r7, #4]
 800af00:	681b      	ldr	r3, [r3, #0]
 800af02:	4619      	mov	r1, r3
 800af04:	4b27      	ldr	r3, [pc, #156]	; (800afa4 <HAL_DMA_IRQHandler+0xe90>)
 800af06:	4299      	cmp	r1, r3
 800af08:	d026      	beq.n	800af58 <HAL_DMA_IRQHandler+0xe44>
 800af0a:	687b      	ldr	r3, [r7, #4]
 800af0c:	681b      	ldr	r3, [r3, #0]
 800af0e:	4619      	mov	r1, r3
 800af10:	4b25      	ldr	r3, [pc, #148]	; (800afa8 <HAL_DMA_IRQHandler+0xe94>)
 800af12:	4299      	cmp	r1, r3
 800af14:	d01d      	beq.n	800af52 <HAL_DMA_IRQHandler+0xe3e>
 800af16:	687b      	ldr	r3, [r7, #4]
 800af18:	681b      	ldr	r3, [r3, #0]
 800af1a:	4619      	mov	r1, r3
 800af1c:	4b23      	ldr	r3, [pc, #140]	; (800afac <HAL_DMA_IRQHandler+0xe98>)
 800af1e:	4299      	cmp	r1, r3
 800af20:	d014      	beq.n	800af4c <HAL_DMA_IRQHandler+0xe38>
 800af22:	687b      	ldr	r3, [r7, #4]
 800af24:	681b      	ldr	r3, [r3, #0]
 800af26:	4619      	mov	r1, r3
 800af28:	4b21      	ldr	r3, [pc, #132]	; (800afb0 <HAL_DMA_IRQHandler+0xe9c>)
 800af2a:	4299      	cmp	r1, r3
 800af2c:	d00b      	beq.n	800af46 <HAL_DMA_IRQHandler+0xe32>
 800af2e:	687b      	ldr	r3, [r7, #4]
 800af30:	681b      	ldr	r3, [r3, #0]
 800af32:	4619      	mov	r1, r3
 800af34:	4b1f      	ldr	r3, [pc, #124]	; (800afb4 <HAL_DMA_IRQHandler+0xea0>)
 800af36:	4299      	cmp	r1, r3
 800af38:	d102      	bne.n	800af40 <HAL_DMA_IRQHandler+0xe2c>
 800af3a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800af3e:	e01a      	b.n	800af76 <HAL_DMA_IRQHandler+0xe62>
 800af40:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800af44:	e017      	b.n	800af76 <HAL_DMA_IRQHandler+0xe62>
 800af46:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800af4a:	e014      	b.n	800af76 <HAL_DMA_IRQHandler+0xe62>
 800af4c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800af50:	e011      	b.n	800af76 <HAL_DMA_IRQHandler+0xe62>
 800af52:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800af56:	e00e      	b.n	800af76 <HAL_DMA_IRQHandler+0xe62>
 800af58:	2340      	movs	r3, #64	; 0x40
 800af5a:	e00c      	b.n	800af76 <HAL_DMA_IRQHandler+0xe62>
 800af5c:	2340      	movs	r3, #64	; 0x40
 800af5e:	e00a      	b.n	800af76 <HAL_DMA_IRQHandler+0xe62>
 800af60:	2340      	movs	r3, #64	; 0x40
 800af62:	e008      	b.n	800af76 <HAL_DMA_IRQHandler+0xe62>
 800af64:	2340      	movs	r3, #64	; 0x40
 800af66:	e006      	b.n	800af76 <HAL_DMA_IRQHandler+0xe62>
 800af68:	4b04      	ldr	r3, [pc, #16]	; (800af7c <HAL_DMA_IRQHandler+0xe68>)
 800af6a:	e004      	b.n	800af76 <HAL_DMA_IRQHandler+0xe62>
 800af6c:	4b03      	ldr	r3, [pc, #12]	; (800af7c <HAL_DMA_IRQHandler+0xe68>)
 800af6e:	e002      	b.n	800af76 <HAL_DMA_IRQHandler+0xe62>
 800af70:	4b02      	ldr	r3, [pc, #8]	; (800af7c <HAL_DMA_IRQHandler+0xe68>)
 800af72:	e000      	b.n	800af76 <HAL_DMA_IRQHandler+0xe62>
 800af74:	4b01      	ldr	r3, [pc, #4]	; (800af7c <HAL_DMA_IRQHandler+0xe68>)
 800af76:	6093      	str	r3, [r2, #8]
 800af78:	e116      	b.n	800b1a8 <HAL_DMA_IRQHandler+0x1094>
 800af7a:	bf00      	nop
 800af7c:	00800001 	.word	0x00800001
 800af80:	40026458 	.word	0x40026458
 800af84:	40026400 	.word	0x40026400
 800af88:	40026010 	.word	0x40026010
 800af8c:	40026410 	.word	0x40026410
 800af90:	40026070 	.word	0x40026070
 800af94:	40026470 	.word	0x40026470
 800af98:	40026028 	.word	0x40026028
 800af9c:	40026428 	.word	0x40026428
 800afa0:	40026088 	.word	0x40026088
 800afa4:	40026488 	.word	0x40026488
 800afa8:	40026040 	.word	0x40026040
 800afac:	40026440 	.word	0x40026440
 800afb0:	400260a0 	.word	0x400260a0
 800afb4:	400264a0 	.word	0x400264a0
 800afb8:	400260b8 	.word	0x400260b8
 800afbc:	687b      	ldr	r3, [r7, #4]
 800afbe:	681b      	ldr	r3, [r3, #0]
 800afc0:	461a      	mov	r2, r3
 800afc2:	4b69      	ldr	r3, [pc, #420]	; (800b168 <HAL_DMA_IRQHandler+0x1054>)
 800afc4:	429a      	cmp	r2, r3
 800afc6:	d968      	bls.n	800b09a <HAL_DMA_IRQHandler+0xf86>
 800afc8:	4a68      	ldr	r2, [pc, #416]	; (800b16c <HAL_DMA_IRQHandler+0x1058>)
 800afca:	687b      	ldr	r3, [r7, #4]
 800afcc:	681b      	ldr	r3, [r3, #0]
 800afce:	4619      	mov	r1, r3
 800afd0:	4b67      	ldr	r3, [pc, #412]	; (800b170 <HAL_DMA_IRQHandler+0x105c>)
 800afd2:	4299      	cmp	r1, r3
 800afd4:	d05e      	beq.n	800b094 <HAL_DMA_IRQHandler+0xf80>
 800afd6:	687b      	ldr	r3, [r7, #4]
 800afd8:	681b      	ldr	r3, [r3, #0]
 800afda:	4619      	mov	r1, r3
 800afdc:	4b65      	ldr	r3, [pc, #404]	; (800b174 <HAL_DMA_IRQHandler+0x1060>)
 800afde:	4299      	cmp	r1, r3
 800afe0:	d056      	beq.n	800b090 <HAL_DMA_IRQHandler+0xf7c>
 800afe2:	687b      	ldr	r3, [r7, #4]
 800afe4:	681b      	ldr	r3, [r3, #0]
 800afe6:	4619      	mov	r1, r3
 800afe8:	4b63      	ldr	r3, [pc, #396]	; (800b178 <HAL_DMA_IRQHandler+0x1064>)
 800afea:	4299      	cmp	r1, r3
 800afec:	d04e      	beq.n	800b08c <HAL_DMA_IRQHandler+0xf78>
 800afee:	687b      	ldr	r3, [r7, #4]
 800aff0:	681b      	ldr	r3, [r3, #0]
 800aff2:	4619      	mov	r1, r3
 800aff4:	4b61      	ldr	r3, [pc, #388]	; (800b17c <HAL_DMA_IRQHandler+0x1068>)
 800aff6:	4299      	cmp	r1, r3
 800aff8:	d046      	beq.n	800b088 <HAL_DMA_IRQHandler+0xf74>
 800affa:	687b      	ldr	r3, [r7, #4]
 800affc:	681b      	ldr	r3, [r3, #0]
 800affe:	4619      	mov	r1, r3
 800b000:	4b5f      	ldr	r3, [pc, #380]	; (800b180 <HAL_DMA_IRQHandler+0x106c>)
 800b002:	4299      	cmp	r1, r3
 800b004:	d03e      	beq.n	800b084 <HAL_DMA_IRQHandler+0xf70>
 800b006:	687b      	ldr	r3, [r7, #4]
 800b008:	681b      	ldr	r3, [r3, #0]
 800b00a:	4619      	mov	r1, r3
 800b00c:	4b5d      	ldr	r3, [pc, #372]	; (800b184 <HAL_DMA_IRQHandler+0x1070>)
 800b00e:	4299      	cmp	r1, r3
 800b010:	d036      	beq.n	800b080 <HAL_DMA_IRQHandler+0xf6c>
 800b012:	687b      	ldr	r3, [r7, #4]
 800b014:	681b      	ldr	r3, [r3, #0]
 800b016:	4619      	mov	r1, r3
 800b018:	4b5b      	ldr	r3, [pc, #364]	; (800b188 <HAL_DMA_IRQHandler+0x1074>)
 800b01a:	4299      	cmp	r1, r3
 800b01c:	d02e      	beq.n	800b07c <HAL_DMA_IRQHandler+0xf68>
 800b01e:	687b      	ldr	r3, [r7, #4]
 800b020:	681b      	ldr	r3, [r3, #0]
 800b022:	4619      	mov	r1, r3
 800b024:	4b59      	ldr	r3, [pc, #356]	; (800b18c <HAL_DMA_IRQHandler+0x1078>)
 800b026:	4299      	cmp	r1, r3
 800b028:	d026      	beq.n	800b078 <HAL_DMA_IRQHandler+0xf64>
 800b02a:	687b      	ldr	r3, [r7, #4]
 800b02c:	681b      	ldr	r3, [r3, #0]
 800b02e:	4619      	mov	r1, r3
 800b030:	4b57      	ldr	r3, [pc, #348]	; (800b190 <HAL_DMA_IRQHandler+0x107c>)
 800b032:	4299      	cmp	r1, r3
 800b034:	d01d      	beq.n	800b072 <HAL_DMA_IRQHandler+0xf5e>
 800b036:	687b      	ldr	r3, [r7, #4]
 800b038:	681b      	ldr	r3, [r3, #0]
 800b03a:	4619      	mov	r1, r3
 800b03c:	4b55      	ldr	r3, [pc, #340]	; (800b194 <HAL_DMA_IRQHandler+0x1080>)
 800b03e:	4299      	cmp	r1, r3
 800b040:	d014      	beq.n	800b06c <HAL_DMA_IRQHandler+0xf58>
 800b042:	687b      	ldr	r3, [r7, #4]
 800b044:	681b      	ldr	r3, [r3, #0]
 800b046:	4619      	mov	r1, r3
 800b048:	4b53      	ldr	r3, [pc, #332]	; (800b198 <HAL_DMA_IRQHandler+0x1084>)
 800b04a:	4299      	cmp	r1, r3
 800b04c:	d00b      	beq.n	800b066 <HAL_DMA_IRQHandler+0xf52>
 800b04e:	687b      	ldr	r3, [r7, #4]
 800b050:	681b      	ldr	r3, [r3, #0]
 800b052:	4619      	mov	r1, r3
 800b054:	4b51      	ldr	r3, [pc, #324]	; (800b19c <HAL_DMA_IRQHandler+0x1088>)
 800b056:	4299      	cmp	r1, r3
 800b058:	d102      	bne.n	800b060 <HAL_DMA_IRQHandler+0xf4c>
 800b05a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800b05e:	e01a      	b.n	800b096 <HAL_DMA_IRQHandler+0xf82>
 800b060:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800b064:	e017      	b.n	800b096 <HAL_DMA_IRQHandler+0xf82>
 800b066:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800b06a:	e014      	b.n	800b096 <HAL_DMA_IRQHandler+0xf82>
 800b06c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800b070:	e011      	b.n	800b096 <HAL_DMA_IRQHandler+0xf82>
 800b072:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800b076:	e00e      	b.n	800b096 <HAL_DMA_IRQHandler+0xf82>
 800b078:	2340      	movs	r3, #64	; 0x40
 800b07a:	e00c      	b.n	800b096 <HAL_DMA_IRQHandler+0xf82>
 800b07c:	2340      	movs	r3, #64	; 0x40
 800b07e:	e00a      	b.n	800b096 <HAL_DMA_IRQHandler+0xf82>
 800b080:	2340      	movs	r3, #64	; 0x40
 800b082:	e008      	b.n	800b096 <HAL_DMA_IRQHandler+0xf82>
 800b084:	2340      	movs	r3, #64	; 0x40
 800b086:	e006      	b.n	800b096 <HAL_DMA_IRQHandler+0xf82>
 800b088:	4b45      	ldr	r3, [pc, #276]	; (800b1a0 <HAL_DMA_IRQHandler+0x108c>)
 800b08a:	e004      	b.n	800b096 <HAL_DMA_IRQHandler+0xf82>
 800b08c:	4b44      	ldr	r3, [pc, #272]	; (800b1a0 <HAL_DMA_IRQHandler+0x108c>)
 800b08e:	e002      	b.n	800b096 <HAL_DMA_IRQHandler+0xf82>
 800b090:	4b43      	ldr	r3, [pc, #268]	; (800b1a0 <HAL_DMA_IRQHandler+0x108c>)
 800b092:	e000      	b.n	800b096 <HAL_DMA_IRQHandler+0xf82>
 800b094:	4b42      	ldr	r3, [pc, #264]	; (800b1a0 <HAL_DMA_IRQHandler+0x108c>)
 800b096:	60d3      	str	r3, [r2, #12]
 800b098:	e086      	b.n	800b1a8 <HAL_DMA_IRQHandler+0x1094>
 800b09a:	4a34      	ldr	r2, [pc, #208]	; (800b16c <HAL_DMA_IRQHandler+0x1058>)
 800b09c:	687b      	ldr	r3, [r7, #4]
 800b09e:	681b      	ldr	r3, [r3, #0]
 800b0a0:	4619      	mov	r1, r3
 800b0a2:	4b33      	ldr	r3, [pc, #204]	; (800b170 <HAL_DMA_IRQHandler+0x105c>)
 800b0a4:	4299      	cmp	r1, r3
 800b0a6:	d07d      	beq.n	800b1a4 <HAL_DMA_IRQHandler+0x1090>
 800b0a8:	687b      	ldr	r3, [r7, #4]
 800b0aa:	681b      	ldr	r3, [r3, #0]
 800b0ac:	4619      	mov	r1, r3
 800b0ae:	4b31      	ldr	r3, [pc, #196]	; (800b174 <HAL_DMA_IRQHandler+0x1060>)
 800b0b0:	4299      	cmp	r1, r3
 800b0b2:	d056      	beq.n	800b162 <HAL_DMA_IRQHandler+0x104e>
 800b0b4:	687b      	ldr	r3, [r7, #4]
 800b0b6:	681b      	ldr	r3, [r3, #0]
 800b0b8:	4619      	mov	r1, r3
 800b0ba:	4b2f      	ldr	r3, [pc, #188]	; (800b178 <HAL_DMA_IRQHandler+0x1064>)
 800b0bc:	4299      	cmp	r1, r3
 800b0be:	d04e      	beq.n	800b15e <HAL_DMA_IRQHandler+0x104a>
 800b0c0:	687b      	ldr	r3, [r7, #4]
 800b0c2:	681b      	ldr	r3, [r3, #0]
 800b0c4:	4619      	mov	r1, r3
 800b0c6:	4b2d      	ldr	r3, [pc, #180]	; (800b17c <HAL_DMA_IRQHandler+0x1068>)
 800b0c8:	4299      	cmp	r1, r3
 800b0ca:	d046      	beq.n	800b15a <HAL_DMA_IRQHandler+0x1046>
 800b0cc:	687b      	ldr	r3, [r7, #4]
 800b0ce:	681b      	ldr	r3, [r3, #0]
 800b0d0:	4619      	mov	r1, r3
 800b0d2:	4b2b      	ldr	r3, [pc, #172]	; (800b180 <HAL_DMA_IRQHandler+0x106c>)
 800b0d4:	4299      	cmp	r1, r3
 800b0d6:	d03e      	beq.n	800b156 <HAL_DMA_IRQHandler+0x1042>
 800b0d8:	687b      	ldr	r3, [r7, #4]
 800b0da:	681b      	ldr	r3, [r3, #0]
 800b0dc:	4619      	mov	r1, r3
 800b0de:	4b29      	ldr	r3, [pc, #164]	; (800b184 <HAL_DMA_IRQHandler+0x1070>)
 800b0e0:	4299      	cmp	r1, r3
 800b0e2:	d036      	beq.n	800b152 <HAL_DMA_IRQHandler+0x103e>
 800b0e4:	687b      	ldr	r3, [r7, #4]
 800b0e6:	681b      	ldr	r3, [r3, #0]
 800b0e8:	4619      	mov	r1, r3
 800b0ea:	4b27      	ldr	r3, [pc, #156]	; (800b188 <HAL_DMA_IRQHandler+0x1074>)
 800b0ec:	4299      	cmp	r1, r3
 800b0ee:	d02e      	beq.n	800b14e <HAL_DMA_IRQHandler+0x103a>
 800b0f0:	687b      	ldr	r3, [r7, #4]
 800b0f2:	681b      	ldr	r3, [r3, #0]
 800b0f4:	4619      	mov	r1, r3
 800b0f6:	4b25      	ldr	r3, [pc, #148]	; (800b18c <HAL_DMA_IRQHandler+0x1078>)
 800b0f8:	4299      	cmp	r1, r3
 800b0fa:	d026      	beq.n	800b14a <HAL_DMA_IRQHandler+0x1036>
 800b0fc:	687b      	ldr	r3, [r7, #4]
 800b0fe:	681b      	ldr	r3, [r3, #0]
 800b100:	4619      	mov	r1, r3
 800b102:	4b23      	ldr	r3, [pc, #140]	; (800b190 <HAL_DMA_IRQHandler+0x107c>)
 800b104:	4299      	cmp	r1, r3
 800b106:	d01d      	beq.n	800b144 <HAL_DMA_IRQHandler+0x1030>
 800b108:	687b      	ldr	r3, [r7, #4]
 800b10a:	681b      	ldr	r3, [r3, #0]
 800b10c:	4619      	mov	r1, r3
 800b10e:	4b21      	ldr	r3, [pc, #132]	; (800b194 <HAL_DMA_IRQHandler+0x1080>)
 800b110:	4299      	cmp	r1, r3
 800b112:	d014      	beq.n	800b13e <HAL_DMA_IRQHandler+0x102a>
 800b114:	687b      	ldr	r3, [r7, #4]
 800b116:	681b      	ldr	r3, [r3, #0]
 800b118:	4619      	mov	r1, r3
 800b11a:	4b1f      	ldr	r3, [pc, #124]	; (800b198 <HAL_DMA_IRQHandler+0x1084>)
 800b11c:	4299      	cmp	r1, r3
 800b11e:	d00b      	beq.n	800b138 <HAL_DMA_IRQHandler+0x1024>
 800b120:	687b      	ldr	r3, [r7, #4]
 800b122:	681b      	ldr	r3, [r3, #0]
 800b124:	4619      	mov	r1, r3
 800b126:	4b1d      	ldr	r3, [pc, #116]	; (800b19c <HAL_DMA_IRQHandler+0x1088>)
 800b128:	4299      	cmp	r1, r3
 800b12a:	d102      	bne.n	800b132 <HAL_DMA_IRQHandler+0x101e>
 800b12c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800b130:	e039      	b.n	800b1a6 <HAL_DMA_IRQHandler+0x1092>
 800b132:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800b136:	e036      	b.n	800b1a6 <HAL_DMA_IRQHandler+0x1092>
 800b138:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800b13c:	e033      	b.n	800b1a6 <HAL_DMA_IRQHandler+0x1092>
 800b13e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800b142:	e030      	b.n	800b1a6 <HAL_DMA_IRQHandler+0x1092>
 800b144:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800b148:	e02d      	b.n	800b1a6 <HAL_DMA_IRQHandler+0x1092>
 800b14a:	2340      	movs	r3, #64	; 0x40
 800b14c:	e02b      	b.n	800b1a6 <HAL_DMA_IRQHandler+0x1092>
 800b14e:	2340      	movs	r3, #64	; 0x40
 800b150:	e029      	b.n	800b1a6 <HAL_DMA_IRQHandler+0x1092>
 800b152:	2340      	movs	r3, #64	; 0x40
 800b154:	e027      	b.n	800b1a6 <HAL_DMA_IRQHandler+0x1092>
 800b156:	2340      	movs	r3, #64	; 0x40
 800b158:	e025      	b.n	800b1a6 <HAL_DMA_IRQHandler+0x1092>
 800b15a:	4b11      	ldr	r3, [pc, #68]	; (800b1a0 <HAL_DMA_IRQHandler+0x108c>)
 800b15c:	e023      	b.n	800b1a6 <HAL_DMA_IRQHandler+0x1092>
 800b15e:	4b10      	ldr	r3, [pc, #64]	; (800b1a0 <HAL_DMA_IRQHandler+0x108c>)
 800b160:	e021      	b.n	800b1a6 <HAL_DMA_IRQHandler+0x1092>
 800b162:	4b0f      	ldr	r3, [pc, #60]	; (800b1a0 <HAL_DMA_IRQHandler+0x108c>)
 800b164:	e01f      	b.n	800b1a6 <HAL_DMA_IRQHandler+0x1092>
 800b166:	bf00      	nop
 800b168:	40026058 	.word	0x40026058
 800b16c:	40026000 	.word	0x40026000
 800b170:	40026010 	.word	0x40026010
 800b174:	40026410 	.word	0x40026410
 800b178:	40026070 	.word	0x40026070
 800b17c:	40026470 	.word	0x40026470
 800b180:	40026028 	.word	0x40026028
 800b184:	40026428 	.word	0x40026428
 800b188:	40026088 	.word	0x40026088
 800b18c:	40026488 	.word	0x40026488
 800b190:	40026040 	.word	0x40026040
 800b194:	40026440 	.word	0x40026440
 800b198:	400260a0 	.word	0x400260a0
 800b19c:	400264a0 	.word	0x400264a0
 800b1a0:	00800001 	.word	0x00800001
 800b1a4:	4b85      	ldr	r3, [pc, #532]	; (800b3bc <HAL_DMA_IRQHandler+0x12a8>)
 800b1a6:	6093      	str	r3, [r2, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 800b1a8:	687b      	ldr	r3, [r7, #4]
 800b1aa:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800b1ac:	f043 0202 	orr.w	r2, r3, #2
 800b1b0:	687b      	ldr	r3, [r7, #4]
 800b1b2:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
 800b1b4:	687b      	ldr	r3, [r7, #4]
 800b1b6:	2204      	movs	r2, #4
 800b1b8:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 800b1bc:	687b      	ldr	r3, [r7, #4]
 800b1be:	2200      	movs	r2, #0
 800b1c0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      if(hdma->XferErrorCallback != NULL)
 800b1c4:	687b      	ldr	r3, [r7, #4]
 800b1c6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800b1c8:	2b00      	cmp	r3, #0
 800b1ca:	d003      	beq.n	800b1d4 <HAL_DMA_IRQHandler+0x10c0>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 800b1cc:	687b      	ldr	r3, [r7, #4]
 800b1ce:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800b1d0:	6878      	ldr	r0, [r7, #4]
 800b1d2:	4798      	blx	r3
      }
    }
  }
  /* Direct Mode Error Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 800b1d4:	687b      	ldr	r3, [r7, #4]
 800b1d6:	681b      	ldr	r3, [r3, #0]
 800b1d8:	461a      	mov	r2, r3
 800b1da:	4b79      	ldr	r3, [pc, #484]	; (800b3c0 <HAL_DMA_IRQHandler+0x12ac>)
 800b1dc:	429a      	cmp	r2, r3
 800b1de:	d972      	bls.n	800b2c6 <HAL_DMA_IRQHandler+0x11b2>
 800b1e0:	4b78      	ldr	r3, [pc, #480]	; (800b3c4 <HAL_DMA_IRQHandler+0x12b0>)
 800b1e2:	685a      	ldr	r2, [r3, #4]
 800b1e4:	687b      	ldr	r3, [r7, #4]
 800b1e6:	681b      	ldr	r3, [r3, #0]
 800b1e8:	4619      	mov	r1, r3
 800b1ea:	4b77      	ldr	r3, [pc, #476]	; (800b3c8 <HAL_DMA_IRQHandler+0x12b4>)
 800b1ec:	4299      	cmp	r1, r3
 800b1ee:	d062      	beq.n	800b2b6 <HAL_DMA_IRQHandler+0x11a2>
 800b1f0:	687b      	ldr	r3, [r7, #4]
 800b1f2:	681b      	ldr	r3, [r3, #0]
 800b1f4:	4619      	mov	r1, r3
 800b1f6:	4b75      	ldr	r3, [pc, #468]	; (800b3cc <HAL_DMA_IRQHandler+0x12b8>)
 800b1f8:	4299      	cmp	r1, r3
 800b1fa:	d05a      	beq.n	800b2b2 <HAL_DMA_IRQHandler+0x119e>
 800b1fc:	687b      	ldr	r3, [r7, #4]
 800b1fe:	681b      	ldr	r3, [r3, #0]
 800b200:	4619      	mov	r1, r3
 800b202:	4b73      	ldr	r3, [pc, #460]	; (800b3d0 <HAL_DMA_IRQHandler+0x12bc>)
 800b204:	4299      	cmp	r1, r3
 800b206:	d052      	beq.n	800b2ae <HAL_DMA_IRQHandler+0x119a>
 800b208:	687b      	ldr	r3, [r7, #4]
 800b20a:	681b      	ldr	r3, [r3, #0]
 800b20c:	4619      	mov	r1, r3
 800b20e:	4b71      	ldr	r3, [pc, #452]	; (800b3d4 <HAL_DMA_IRQHandler+0x12c0>)
 800b210:	4299      	cmp	r1, r3
 800b212:	d04a      	beq.n	800b2aa <HAL_DMA_IRQHandler+0x1196>
 800b214:	687b      	ldr	r3, [r7, #4]
 800b216:	681b      	ldr	r3, [r3, #0]
 800b218:	4619      	mov	r1, r3
 800b21a:	4b6f      	ldr	r3, [pc, #444]	; (800b3d8 <HAL_DMA_IRQHandler+0x12c4>)
 800b21c:	4299      	cmp	r1, r3
 800b21e:	d041      	beq.n	800b2a4 <HAL_DMA_IRQHandler+0x1190>
 800b220:	687b      	ldr	r3, [r7, #4]
 800b222:	681b      	ldr	r3, [r3, #0]
 800b224:	4619      	mov	r1, r3
 800b226:	4b6d      	ldr	r3, [pc, #436]	; (800b3dc <HAL_DMA_IRQHandler+0x12c8>)
 800b228:	4299      	cmp	r1, r3
 800b22a:	d038      	beq.n	800b29e <HAL_DMA_IRQHandler+0x118a>
 800b22c:	687b      	ldr	r3, [r7, #4]
 800b22e:	681b      	ldr	r3, [r3, #0]
 800b230:	4619      	mov	r1, r3
 800b232:	4b6b      	ldr	r3, [pc, #428]	; (800b3e0 <HAL_DMA_IRQHandler+0x12cc>)
 800b234:	4299      	cmp	r1, r3
 800b236:	d02f      	beq.n	800b298 <HAL_DMA_IRQHandler+0x1184>
 800b238:	687b      	ldr	r3, [r7, #4]
 800b23a:	681b      	ldr	r3, [r3, #0]
 800b23c:	4619      	mov	r1, r3
 800b23e:	4b69      	ldr	r3, [pc, #420]	; (800b3e4 <HAL_DMA_IRQHandler+0x12d0>)
 800b240:	4299      	cmp	r1, r3
 800b242:	d026      	beq.n	800b292 <HAL_DMA_IRQHandler+0x117e>
 800b244:	687b      	ldr	r3, [r7, #4]
 800b246:	681b      	ldr	r3, [r3, #0]
 800b248:	4619      	mov	r1, r3
 800b24a:	4b67      	ldr	r3, [pc, #412]	; (800b3e8 <HAL_DMA_IRQHandler+0x12d4>)
 800b24c:	4299      	cmp	r1, r3
 800b24e:	d01d      	beq.n	800b28c <HAL_DMA_IRQHandler+0x1178>
 800b250:	687b      	ldr	r3, [r7, #4]
 800b252:	681b      	ldr	r3, [r3, #0]
 800b254:	4619      	mov	r1, r3
 800b256:	4b65      	ldr	r3, [pc, #404]	; (800b3ec <HAL_DMA_IRQHandler+0x12d8>)
 800b258:	4299      	cmp	r1, r3
 800b25a:	d014      	beq.n	800b286 <HAL_DMA_IRQHandler+0x1172>
 800b25c:	687b      	ldr	r3, [r7, #4]
 800b25e:	681b      	ldr	r3, [r3, #0]
 800b260:	4619      	mov	r1, r3
 800b262:	4b63      	ldr	r3, [pc, #396]	; (800b3f0 <HAL_DMA_IRQHandler+0x12dc>)
 800b264:	4299      	cmp	r1, r3
 800b266:	d00b      	beq.n	800b280 <HAL_DMA_IRQHandler+0x116c>
 800b268:	687b      	ldr	r3, [r7, #4]
 800b26a:	681b      	ldr	r3, [r3, #0]
 800b26c:	4619      	mov	r1, r3
 800b26e:	4b61      	ldr	r3, [pc, #388]	; (800b3f4 <HAL_DMA_IRQHandler+0x12e0>)
 800b270:	4299      	cmp	r1, r3
 800b272:	d102      	bne.n	800b27a <HAL_DMA_IRQHandler+0x1166>
 800b274:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b278:	e01e      	b.n	800b2b8 <HAL_DMA_IRQHandler+0x11a4>
 800b27a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800b27e:	e01b      	b.n	800b2b8 <HAL_DMA_IRQHandler+0x11a4>
 800b280:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b284:	e018      	b.n	800b2b8 <HAL_DMA_IRQHandler+0x11a4>
 800b286:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b28a:	e015      	b.n	800b2b8 <HAL_DMA_IRQHandler+0x11a4>
 800b28c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b290:	e012      	b.n	800b2b8 <HAL_DMA_IRQHandler+0x11a4>
 800b292:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b296:	e00f      	b.n	800b2b8 <HAL_DMA_IRQHandler+0x11a4>
 800b298:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b29c:	e00c      	b.n	800b2b8 <HAL_DMA_IRQHandler+0x11a4>
 800b29e:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b2a2:	e009      	b.n	800b2b8 <HAL_DMA_IRQHandler+0x11a4>
 800b2a4:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b2a8:	e006      	b.n	800b2b8 <HAL_DMA_IRQHandler+0x11a4>
 800b2aa:	4b53      	ldr	r3, [pc, #332]	; (800b3f8 <HAL_DMA_IRQHandler+0x12e4>)
 800b2ac:	e004      	b.n	800b2b8 <HAL_DMA_IRQHandler+0x11a4>
 800b2ae:	4b52      	ldr	r3, [pc, #328]	; (800b3f8 <HAL_DMA_IRQHandler+0x12e4>)
 800b2b0:	e002      	b.n	800b2b8 <HAL_DMA_IRQHandler+0x11a4>
 800b2b2:	4b51      	ldr	r3, [pc, #324]	; (800b3f8 <HAL_DMA_IRQHandler+0x12e4>)
 800b2b4:	e000      	b.n	800b2b8 <HAL_DMA_IRQHandler+0x11a4>
 800b2b6:	4b50      	ldr	r3, [pc, #320]	; (800b3f8 <HAL_DMA_IRQHandler+0x12e4>)
 800b2b8:	4013      	ands	r3, r2
 800b2ba:	2b00      	cmp	r3, #0
 800b2bc:	bf14      	ite	ne
 800b2be:	2301      	movne	r3, #1
 800b2c0:	2300      	moveq	r3, #0
 800b2c2:	b2db      	uxtb	r3, r3
 800b2c4:	e1a7      	b.n	800b616 <HAL_DMA_IRQHandler+0x1502>
 800b2c6:	687b      	ldr	r3, [r7, #4]
 800b2c8:	681b      	ldr	r3, [r3, #0]
 800b2ca:	461a      	mov	r2, r3
 800b2cc:	4b4b      	ldr	r3, [pc, #300]	; (800b3fc <HAL_DMA_IRQHandler+0x12e8>)
 800b2ce:	429a      	cmp	r2, r3
 800b2d0:	f240 8096 	bls.w	800b400 <HAL_DMA_IRQHandler+0x12ec>
 800b2d4:	4b3b      	ldr	r3, [pc, #236]	; (800b3c4 <HAL_DMA_IRQHandler+0x12b0>)
 800b2d6:	681a      	ldr	r2, [r3, #0]
 800b2d8:	687b      	ldr	r3, [r7, #4]
 800b2da:	681b      	ldr	r3, [r3, #0]
 800b2dc:	4619      	mov	r1, r3
 800b2de:	4b3a      	ldr	r3, [pc, #232]	; (800b3c8 <HAL_DMA_IRQHandler+0x12b4>)
 800b2e0:	4299      	cmp	r1, r3
 800b2e2:	d062      	beq.n	800b3aa <HAL_DMA_IRQHandler+0x1296>
 800b2e4:	687b      	ldr	r3, [r7, #4]
 800b2e6:	681b      	ldr	r3, [r3, #0]
 800b2e8:	4619      	mov	r1, r3
 800b2ea:	4b38      	ldr	r3, [pc, #224]	; (800b3cc <HAL_DMA_IRQHandler+0x12b8>)
 800b2ec:	4299      	cmp	r1, r3
 800b2ee:	d05a      	beq.n	800b3a6 <HAL_DMA_IRQHandler+0x1292>
 800b2f0:	687b      	ldr	r3, [r7, #4]
 800b2f2:	681b      	ldr	r3, [r3, #0]
 800b2f4:	4619      	mov	r1, r3
 800b2f6:	4b36      	ldr	r3, [pc, #216]	; (800b3d0 <HAL_DMA_IRQHandler+0x12bc>)
 800b2f8:	4299      	cmp	r1, r3
 800b2fa:	d052      	beq.n	800b3a2 <HAL_DMA_IRQHandler+0x128e>
 800b2fc:	687b      	ldr	r3, [r7, #4]
 800b2fe:	681b      	ldr	r3, [r3, #0]
 800b300:	4619      	mov	r1, r3
 800b302:	4b34      	ldr	r3, [pc, #208]	; (800b3d4 <HAL_DMA_IRQHandler+0x12c0>)
 800b304:	4299      	cmp	r1, r3
 800b306:	d04a      	beq.n	800b39e <HAL_DMA_IRQHandler+0x128a>
 800b308:	687b      	ldr	r3, [r7, #4]
 800b30a:	681b      	ldr	r3, [r3, #0]
 800b30c:	4619      	mov	r1, r3
 800b30e:	4b32      	ldr	r3, [pc, #200]	; (800b3d8 <HAL_DMA_IRQHandler+0x12c4>)
 800b310:	4299      	cmp	r1, r3
 800b312:	d041      	beq.n	800b398 <HAL_DMA_IRQHandler+0x1284>
 800b314:	687b      	ldr	r3, [r7, #4]
 800b316:	681b      	ldr	r3, [r3, #0]
 800b318:	4619      	mov	r1, r3
 800b31a:	4b30      	ldr	r3, [pc, #192]	; (800b3dc <HAL_DMA_IRQHandler+0x12c8>)
 800b31c:	4299      	cmp	r1, r3
 800b31e:	d038      	beq.n	800b392 <HAL_DMA_IRQHandler+0x127e>
 800b320:	687b      	ldr	r3, [r7, #4]
 800b322:	681b      	ldr	r3, [r3, #0]
 800b324:	4619      	mov	r1, r3
 800b326:	4b2e      	ldr	r3, [pc, #184]	; (800b3e0 <HAL_DMA_IRQHandler+0x12cc>)
 800b328:	4299      	cmp	r1, r3
 800b32a:	d02f      	beq.n	800b38c <HAL_DMA_IRQHandler+0x1278>
 800b32c:	687b      	ldr	r3, [r7, #4]
 800b32e:	681b      	ldr	r3, [r3, #0]
 800b330:	4619      	mov	r1, r3
 800b332:	4b2c      	ldr	r3, [pc, #176]	; (800b3e4 <HAL_DMA_IRQHandler+0x12d0>)
 800b334:	4299      	cmp	r1, r3
 800b336:	d026      	beq.n	800b386 <HAL_DMA_IRQHandler+0x1272>
 800b338:	687b      	ldr	r3, [r7, #4]
 800b33a:	681b      	ldr	r3, [r3, #0]
 800b33c:	4619      	mov	r1, r3
 800b33e:	4b2a      	ldr	r3, [pc, #168]	; (800b3e8 <HAL_DMA_IRQHandler+0x12d4>)
 800b340:	4299      	cmp	r1, r3
 800b342:	d01d      	beq.n	800b380 <HAL_DMA_IRQHandler+0x126c>
 800b344:	687b      	ldr	r3, [r7, #4]
 800b346:	681b      	ldr	r3, [r3, #0]
 800b348:	4619      	mov	r1, r3
 800b34a:	4b28      	ldr	r3, [pc, #160]	; (800b3ec <HAL_DMA_IRQHandler+0x12d8>)
 800b34c:	4299      	cmp	r1, r3
 800b34e:	d014      	beq.n	800b37a <HAL_DMA_IRQHandler+0x1266>
 800b350:	687b      	ldr	r3, [r7, #4]
 800b352:	681b      	ldr	r3, [r3, #0]
 800b354:	4619      	mov	r1, r3
 800b356:	4b26      	ldr	r3, [pc, #152]	; (800b3f0 <HAL_DMA_IRQHandler+0x12dc>)
 800b358:	4299      	cmp	r1, r3
 800b35a:	d00b      	beq.n	800b374 <HAL_DMA_IRQHandler+0x1260>
 800b35c:	687b      	ldr	r3, [r7, #4]
 800b35e:	681b      	ldr	r3, [r3, #0]
 800b360:	4619      	mov	r1, r3
 800b362:	4b24      	ldr	r3, [pc, #144]	; (800b3f4 <HAL_DMA_IRQHandler+0x12e0>)
 800b364:	4299      	cmp	r1, r3
 800b366:	d102      	bne.n	800b36e <HAL_DMA_IRQHandler+0x125a>
 800b368:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b36c:	e01e      	b.n	800b3ac <HAL_DMA_IRQHandler+0x1298>
 800b36e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800b372:	e01b      	b.n	800b3ac <HAL_DMA_IRQHandler+0x1298>
 800b374:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b378:	e018      	b.n	800b3ac <HAL_DMA_IRQHandler+0x1298>
 800b37a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b37e:	e015      	b.n	800b3ac <HAL_DMA_IRQHandler+0x1298>
 800b380:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b384:	e012      	b.n	800b3ac <HAL_DMA_IRQHandler+0x1298>
 800b386:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b38a:	e00f      	b.n	800b3ac <HAL_DMA_IRQHandler+0x1298>
 800b38c:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b390:	e00c      	b.n	800b3ac <HAL_DMA_IRQHandler+0x1298>
 800b392:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b396:	e009      	b.n	800b3ac <HAL_DMA_IRQHandler+0x1298>
 800b398:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b39c:	e006      	b.n	800b3ac <HAL_DMA_IRQHandler+0x1298>
 800b39e:	4b16      	ldr	r3, [pc, #88]	; (800b3f8 <HAL_DMA_IRQHandler+0x12e4>)
 800b3a0:	e004      	b.n	800b3ac <HAL_DMA_IRQHandler+0x1298>
 800b3a2:	4b15      	ldr	r3, [pc, #84]	; (800b3f8 <HAL_DMA_IRQHandler+0x12e4>)
 800b3a4:	e002      	b.n	800b3ac <HAL_DMA_IRQHandler+0x1298>
 800b3a6:	4b14      	ldr	r3, [pc, #80]	; (800b3f8 <HAL_DMA_IRQHandler+0x12e4>)
 800b3a8:	e000      	b.n	800b3ac <HAL_DMA_IRQHandler+0x1298>
 800b3aa:	4b13      	ldr	r3, [pc, #76]	; (800b3f8 <HAL_DMA_IRQHandler+0x12e4>)
 800b3ac:	4013      	ands	r3, r2
 800b3ae:	2b00      	cmp	r3, #0
 800b3b0:	bf14      	ite	ne
 800b3b2:	2301      	movne	r3, #1
 800b3b4:	2300      	moveq	r3, #0
 800b3b6:	b2db      	uxtb	r3, r3
 800b3b8:	e12d      	b.n	800b616 <HAL_DMA_IRQHandler+0x1502>
 800b3ba:	bf00      	nop
 800b3bc:	00800001 	.word	0x00800001
 800b3c0:	40026458 	.word	0x40026458
 800b3c4:	40026400 	.word	0x40026400
 800b3c8:	40026010 	.word	0x40026010
 800b3cc:	40026410 	.word	0x40026410
 800b3d0:	40026070 	.word	0x40026070
 800b3d4:	40026470 	.word	0x40026470
 800b3d8:	40026028 	.word	0x40026028
 800b3dc:	40026428 	.word	0x40026428
 800b3e0:	40026088 	.word	0x40026088
 800b3e4:	40026488 	.word	0x40026488
 800b3e8:	40026040 	.word	0x40026040
 800b3ec:	40026440 	.word	0x40026440
 800b3f0:	400260a0 	.word	0x400260a0
 800b3f4:	400264a0 	.word	0x400264a0
 800b3f8:	00800004 	.word	0x00800004
 800b3fc:	400260b8 	.word	0x400260b8
 800b400:	687b      	ldr	r3, [r7, #4]
 800b402:	681b      	ldr	r3, [r3, #0]
 800b404:	461a      	mov	r2, r3
 800b406:	4b71      	ldr	r3, [pc, #452]	; (800b5cc <HAL_DMA_IRQHandler+0x14b8>)
 800b408:	429a      	cmp	r2, r3
 800b40a:	d972      	bls.n	800b4f2 <HAL_DMA_IRQHandler+0x13de>
 800b40c:	4b70      	ldr	r3, [pc, #448]	; (800b5d0 <HAL_DMA_IRQHandler+0x14bc>)
 800b40e:	685a      	ldr	r2, [r3, #4]
 800b410:	687b      	ldr	r3, [r7, #4]
 800b412:	681b      	ldr	r3, [r3, #0]
 800b414:	4619      	mov	r1, r3
 800b416:	4b6f      	ldr	r3, [pc, #444]	; (800b5d4 <HAL_DMA_IRQHandler+0x14c0>)
 800b418:	4299      	cmp	r1, r3
 800b41a:	d062      	beq.n	800b4e2 <HAL_DMA_IRQHandler+0x13ce>
 800b41c:	687b      	ldr	r3, [r7, #4]
 800b41e:	681b      	ldr	r3, [r3, #0]
 800b420:	4619      	mov	r1, r3
 800b422:	4b6d      	ldr	r3, [pc, #436]	; (800b5d8 <HAL_DMA_IRQHandler+0x14c4>)
 800b424:	4299      	cmp	r1, r3
 800b426:	d05a      	beq.n	800b4de <HAL_DMA_IRQHandler+0x13ca>
 800b428:	687b      	ldr	r3, [r7, #4]
 800b42a:	681b      	ldr	r3, [r3, #0]
 800b42c:	4619      	mov	r1, r3
 800b42e:	4b6b      	ldr	r3, [pc, #428]	; (800b5dc <HAL_DMA_IRQHandler+0x14c8>)
 800b430:	4299      	cmp	r1, r3
 800b432:	d052      	beq.n	800b4da <HAL_DMA_IRQHandler+0x13c6>
 800b434:	687b      	ldr	r3, [r7, #4]
 800b436:	681b      	ldr	r3, [r3, #0]
 800b438:	4619      	mov	r1, r3
 800b43a:	4b69      	ldr	r3, [pc, #420]	; (800b5e0 <HAL_DMA_IRQHandler+0x14cc>)
 800b43c:	4299      	cmp	r1, r3
 800b43e:	d04a      	beq.n	800b4d6 <HAL_DMA_IRQHandler+0x13c2>
 800b440:	687b      	ldr	r3, [r7, #4]
 800b442:	681b      	ldr	r3, [r3, #0]
 800b444:	4619      	mov	r1, r3
 800b446:	4b67      	ldr	r3, [pc, #412]	; (800b5e4 <HAL_DMA_IRQHandler+0x14d0>)
 800b448:	4299      	cmp	r1, r3
 800b44a:	d041      	beq.n	800b4d0 <HAL_DMA_IRQHandler+0x13bc>
 800b44c:	687b      	ldr	r3, [r7, #4]
 800b44e:	681b      	ldr	r3, [r3, #0]
 800b450:	4619      	mov	r1, r3
 800b452:	4b65      	ldr	r3, [pc, #404]	; (800b5e8 <HAL_DMA_IRQHandler+0x14d4>)
 800b454:	4299      	cmp	r1, r3
 800b456:	d038      	beq.n	800b4ca <HAL_DMA_IRQHandler+0x13b6>
 800b458:	687b      	ldr	r3, [r7, #4]
 800b45a:	681b      	ldr	r3, [r3, #0]
 800b45c:	4619      	mov	r1, r3
 800b45e:	4b63      	ldr	r3, [pc, #396]	; (800b5ec <HAL_DMA_IRQHandler+0x14d8>)
 800b460:	4299      	cmp	r1, r3
 800b462:	d02f      	beq.n	800b4c4 <HAL_DMA_IRQHandler+0x13b0>
 800b464:	687b      	ldr	r3, [r7, #4]
 800b466:	681b      	ldr	r3, [r3, #0]
 800b468:	4619      	mov	r1, r3
 800b46a:	4b61      	ldr	r3, [pc, #388]	; (800b5f0 <HAL_DMA_IRQHandler+0x14dc>)
 800b46c:	4299      	cmp	r1, r3
 800b46e:	d026      	beq.n	800b4be <HAL_DMA_IRQHandler+0x13aa>
 800b470:	687b      	ldr	r3, [r7, #4]
 800b472:	681b      	ldr	r3, [r3, #0]
 800b474:	4619      	mov	r1, r3
 800b476:	4b5f      	ldr	r3, [pc, #380]	; (800b5f4 <HAL_DMA_IRQHandler+0x14e0>)
 800b478:	4299      	cmp	r1, r3
 800b47a:	d01d      	beq.n	800b4b8 <HAL_DMA_IRQHandler+0x13a4>
 800b47c:	687b      	ldr	r3, [r7, #4]
 800b47e:	681b      	ldr	r3, [r3, #0]
 800b480:	4619      	mov	r1, r3
 800b482:	4b5d      	ldr	r3, [pc, #372]	; (800b5f8 <HAL_DMA_IRQHandler+0x14e4>)
 800b484:	4299      	cmp	r1, r3
 800b486:	d014      	beq.n	800b4b2 <HAL_DMA_IRQHandler+0x139e>
 800b488:	687b      	ldr	r3, [r7, #4]
 800b48a:	681b      	ldr	r3, [r3, #0]
 800b48c:	4619      	mov	r1, r3
 800b48e:	4b5b      	ldr	r3, [pc, #364]	; (800b5fc <HAL_DMA_IRQHandler+0x14e8>)
 800b490:	4299      	cmp	r1, r3
 800b492:	d00b      	beq.n	800b4ac <HAL_DMA_IRQHandler+0x1398>
 800b494:	687b      	ldr	r3, [r7, #4]
 800b496:	681b      	ldr	r3, [r3, #0]
 800b498:	4619      	mov	r1, r3
 800b49a:	4b59      	ldr	r3, [pc, #356]	; (800b600 <HAL_DMA_IRQHandler+0x14ec>)
 800b49c:	4299      	cmp	r1, r3
 800b49e:	d102      	bne.n	800b4a6 <HAL_DMA_IRQHandler+0x1392>
 800b4a0:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b4a4:	e01e      	b.n	800b4e4 <HAL_DMA_IRQHandler+0x13d0>
 800b4a6:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800b4aa:	e01b      	b.n	800b4e4 <HAL_DMA_IRQHandler+0x13d0>
 800b4ac:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b4b0:	e018      	b.n	800b4e4 <HAL_DMA_IRQHandler+0x13d0>
 800b4b2:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b4b6:	e015      	b.n	800b4e4 <HAL_DMA_IRQHandler+0x13d0>
 800b4b8:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b4bc:	e012      	b.n	800b4e4 <HAL_DMA_IRQHandler+0x13d0>
 800b4be:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b4c2:	e00f      	b.n	800b4e4 <HAL_DMA_IRQHandler+0x13d0>
 800b4c4:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b4c8:	e00c      	b.n	800b4e4 <HAL_DMA_IRQHandler+0x13d0>
 800b4ca:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b4ce:	e009      	b.n	800b4e4 <HAL_DMA_IRQHandler+0x13d0>
 800b4d0:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b4d4:	e006      	b.n	800b4e4 <HAL_DMA_IRQHandler+0x13d0>
 800b4d6:	4b4b      	ldr	r3, [pc, #300]	; (800b604 <HAL_DMA_IRQHandler+0x14f0>)
 800b4d8:	e004      	b.n	800b4e4 <HAL_DMA_IRQHandler+0x13d0>
 800b4da:	4b4a      	ldr	r3, [pc, #296]	; (800b604 <HAL_DMA_IRQHandler+0x14f0>)
 800b4dc:	e002      	b.n	800b4e4 <HAL_DMA_IRQHandler+0x13d0>
 800b4de:	4b49      	ldr	r3, [pc, #292]	; (800b604 <HAL_DMA_IRQHandler+0x14f0>)
 800b4e0:	e000      	b.n	800b4e4 <HAL_DMA_IRQHandler+0x13d0>
 800b4e2:	4b48      	ldr	r3, [pc, #288]	; (800b604 <HAL_DMA_IRQHandler+0x14f0>)
 800b4e4:	4013      	ands	r3, r2
 800b4e6:	2b00      	cmp	r3, #0
 800b4e8:	bf14      	ite	ne
 800b4ea:	2301      	movne	r3, #1
 800b4ec:	2300      	moveq	r3, #0
 800b4ee:	b2db      	uxtb	r3, r3
 800b4f0:	e091      	b.n	800b616 <HAL_DMA_IRQHandler+0x1502>
 800b4f2:	4b37      	ldr	r3, [pc, #220]	; (800b5d0 <HAL_DMA_IRQHandler+0x14bc>)
 800b4f4:	681a      	ldr	r2, [r3, #0]
 800b4f6:	687b      	ldr	r3, [r7, #4]
 800b4f8:	681b      	ldr	r3, [r3, #0]
 800b4fa:	4619      	mov	r1, r3
 800b4fc:	4b35      	ldr	r3, [pc, #212]	; (800b5d4 <HAL_DMA_IRQHandler+0x14c0>)
 800b4fe:	4299      	cmp	r1, r3
 800b500:	f000 8082 	beq.w	800b608 <HAL_DMA_IRQHandler+0x14f4>
 800b504:	687b      	ldr	r3, [r7, #4]
 800b506:	681b      	ldr	r3, [r3, #0]
 800b508:	4619      	mov	r1, r3
 800b50a:	4b33      	ldr	r3, [pc, #204]	; (800b5d8 <HAL_DMA_IRQHandler+0x14c4>)
 800b50c:	4299      	cmp	r1, r3
 800b50e:	d05a      	beq.n	800b5c6 <HAL_DMA_IRQHandler+0x14b2>
 800b510:	687b      	ldr	r3, [r7, #4]
 800b512:	681b      	ldr	r3, [r3, #0]
 800b514:	4619      	mov	r1, r3
 800b516:	4b31      	ldr	r3, [pc, #196]	; (800b5dc <HAL_DMA_IRQHandler+0x14c8>)
 800b518:	4299      	cmp	r1, r3
 800b51a:	d052      	beq.n	800b5c2 <HAL_DMA_IRQHandler+0x14ae>
 800b51c:	687b      	ldr	r3, [r7, #4]
 800b51e:	681b      	ldr	r3, [r3, #0]
 800b520:	4619      	mov	r1, r3
 800b522:	4b2f      	ldr	r3, [pc, #188]	; (800b5e0 <HAL_DMA_IRQHandler+0x14cc>)
 800b524:	4299      	cmp	r1, r3
 800b526:	d04a      	beq.n	800b5be <HAL_DMA_IRQHandler+0x14aa>
 800b528:	687b      	ldr	r3, [r7, #4]
 800b52a:	681b      	ldr	r3, [r3, #0]
 800b52c:	4619      	mov	r1, r3
 800b52e:	4b2d      	ldr	r3, [pc, #180]	; (800b5e4 <HAL_DMA_IRQHandler+0x14d0>)
 800b530:	4299      	cmp	r1, r3
 800b532:	d041      	beq.n	800b5b8 <HAL_DMA_IRQHandler+0x14a4>
 800b534:	687b      	ldr	r3, [r7, #4]
 800b536:	681b      	ldr	r3, [r3, #0]
 800b538:	4619      	mov	r1, r3
 800b53a:	4b2b      	ldr	r3, [pc, #172]	; (800b5e8 <HAL_DMA_IRQHandler+0x14d4>)
 800b53c:	4299      	cmp	r1, r3
 800b53e:	d038      	beq.n	800b5b2 <HAL_DMA_IRQHandler+0x149e>
 800b540:	687b      	ldr	r3, [r7, #4]
 800b542:	681b      	ldr	r3, [r3, #0]
 800b544:	4619      	mov	r1, r3
 800b546:	4b29      	ldr	r3, [pc, #164]	; (800b5ec <HAL_DMA_IRQHandler+0x14d8>)
 800b548:	4299      	cmp	r1, r3
 800b54a:	d02f      	beq.n	800b5ac <HAL_DMA_IRQHandler+0x1498>
 800b54c:	687b      	ldr	r3, [r7, #4]
 800b54e:	681b      	ldr	r3, [r3, #0]
 800b550:	4619      	mov	r1, r3
 800b552:	4b27      	ldr	r3, [pc, #156]	; (800b5f0 <HAL_DMA_IRQHandler+0x14dc>)
 800b554:	4299      	cmp	r1, r3
 800b556:	d026      	beq.n	800b5a6 <HAL_DMA_IRQHandler+0x1492>
 800b558:	687b      	ldr	r3, [r7, #4]
 800b55a:	681b      	ldr	r3, [r3, #0]
 800b55c:	4619      	mov	r1, r3
 800b55e:	4b25      	ldr	r3, [pc, #148]	; (800b5f4 <HAL_DMA_IRQHandler+0x14e0>)
 800b560:	4299      	cmp	r1, r3
 800b562:	d01d      	beq.n	800b5a0 <HAL_DMA_IRQHandler+0x148c>
 800b564:	687b      	ldr	r3, [r7, #4]
 800b566:	681b      	ldr	r3, [r3, #0]
 800b568:	4619      	mov	r1, r3
 800b56a:	4b23      	ldr	r3, [pc, #140]	; (800b5f8 <HAL_DMA_IRQHandler+0x14e4>)
 800b56c:	4299      	cmp	r1, r3
 800b56e:	d014      	beq.n	800b59a <HAL_DMA_IRQHandler+0x1486>
 800b570:	687b      	ldr	r3, [r7, #4]
 800b572:	681b      	ldr	r3, [r3, #0]
 800b574:	4619      	mov	r1, r3
 800b576:	4b21      	ldr	r3, [pc, #132]	; (800b5fc <HAL_DMA_IRQHandler+0x14e8>)
 800b578:	4299      	cmp	r1, r3
 800b57a:	d00b      	beq.n	800b594 <HAL_DMA_IRQHandler+0x1480>
 800b57c:	687b      	ldr	r3, [r7, #4]
 800b57e:	681b      	ldr	r3, [r3, #0]
 800b580:	4619      	mov	r1, r3
 800b582:	4b1f      	ldr	r3, [pc, #124]	; (800b600 <HAL_DMA_IRQHandler+0x14ec>)
 800b584:	4299      	cmp	r1, r3
 800b586:	d102      	bne.n	800b58e <HAL_DMA_IRQHandler+0x147a>
 800b588:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b58c:	e03d      	b.n	800b60a <HAL_DMA_IRQHandler+0x14f6>
 800b58e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800b592:	e03a      	b.n	800b60a <HAL_DMA_IRQHandler+0x14f6>
 800b594:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b598:	e037      	b.n	800b60a <HAL_DMA_IRQHandler+0x14f6>
 800b59a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b59e:	e034      	b.n	800b60a <HAL_DMA_IRQHandler+0x14f6>
 800b5a0:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b5a4:	e031      	b.n	800b60a <HAL_DMA_IRQHandler+0x14f6>
 800b5a6:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b5aa:	e02e      	b.n	800b60a <HAL_DMA_IRQHandler+0x14f6>
 800b5ac:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b5b0:	e02b      	b.n	800b60a <HAL_DMA_IRQHandler+0x14f6>
 800b5b2:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b5b6:	e028      	b.n	800b60a <HAL_DMA_IRQHandler+0x14f6>
 800b5b8:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b5bc:	e025      	b.n	800b60a <HAL_DMA_IRQHandler+0x14f6>
 800b5be:	4b11      	ldr	r3, [pc, #68]	; (800b604 <HAL_DMA_IRQHandler+0x14f0>)
 800b5c0:	e023      	b.n	800b60a <HAL_DMA_IRQHandler+0x14f6>
 800b5c2:	4b10      	ldr	r3, [pc, #64]	; (800b604 <HAL_DMA_IRQHandler+0x14f0>)
 800b5c4:	e021      	b.n	800b60a <HAL_DMA_IRQHandler+0x14f6>
 800b5c6:	4b0f      	ldr	r3, [pc, #60]	; (800b604 <HAL_DMA_IRQHandler+0x14f0>)
 800b5c8:	e01f      	b.n	800b60a <HAL_DMA_IRQHandler+0x14f6>
 800b5ca:	bf00      	nop
 800b5cc:	40026058 	.word	0x40026058
 800b5d0:	40026000 	.word	0x40026000
 800b5d4:	40026010 	.word	0x40026010
 800b5d8:	40026410 	.word	0x40026410
 800b5dc:	40026070 	.word	0x40026070
 800b5e0:	40026470 	.word	0x40026470
 800b5e4:	40026028 	.word	0x40026028
 800b5e8:	40026428 	.word	0x40026428
 800b5ec:	40026088 	.word	0x40026088
 800b5f0:	40026488 	.word	0x40026488
 800b5f4:	40026040 	.word	0x40026040
 800b5f8:	40026440 	.word	0x40026440
 800b5fc:	400260a0 	.word	0x400260a0
 800b600:	400264a0 	.word	0x400264a0
 800b604:	00800004 	.word	0x00800004
 800b608:	4b80      	ldr	r3, [pc, #512]	; (800b80c <HAL_DMA_IRQHandler+0x16f8>)
 800b60a:	4013      	ands	r3, r2
 800b60c:	2b00      	cmp	r3, #0
 800b60e:	bf14      	ite	ne
 800b610:	2301      	movne	r3, #1
 800b612:	2300      	moveq	r3, #0
 800b614:	b2db      	uxtb	r3, r3
 800b616:	2b00      	cmp	r3, #0
 800b618:	f000 822c 	beq.w	800ba74 <HAL_DMA_IRQHandler+0x1960>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 800b61c:	687b      	ldr	r3, [r7, #4]
 800b61e:	681b      	ldr	r3, [r3, #0]
 800b620:	681b      	ldr	r3, [r3, #0]
 800b622:	f003 0302 	and.w	r3, r3, #2
 800b626:	2b00      	cmp	r3, #0
 800b628:	f000 8224 	beq.w	800ba74 <HAL_DMA_IRQHandler+0x1960>
    {
      /* Disable the direct mode Error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_DME);
 800b62c:	687b      	ldr	r3, [r7, #4]
 800b62e:	681b      	ldr	r3, [r3, #0]
 800b630:	687a      	ldr	r2, [r7, #4]
 800b632:	6812      	ldr	r2, [r2, #0]
 800b634:	6812      	ldr	r2, [r2, #0]
 800b636:	f022 0202 	bic.w	r2, r2, #2
 800b63a:	601a      	str	r2, [r3, #0]

      /* Clear the direct mode error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 800b63c:	687b      	ldr	r3, [r7, #4]
 800b63e:	681b      	ldr	r3, [r3, #0]
 800b640:	461a      	mov	r2, r3
 800b642:	4b73      	ldr	r3, [pc, #460]	; (800b810 <HAL_DMA_IRQHandler+0x16fc>)
 800b644:	429a      	cmp	r2, r3
 800b646:	d96c      	bls.n	800b722 <HAL_DMA_IRQHandler+0x160e>
 800b648:	4a72      	ldr	r2, [pc, #456]	; (800b814 <HAL_DMA_IRQHandler+0x1700>)
 800b64a:	687b      	ldr	r3, [r7, #4]
 800b64c:	681b      	ldr	r3, [r3, #0]
 800b64e:	4619      	mov	r1, r3
 800b650:	4b71      	ldr	r3, [pc, #452]	; (800b818 <HAL_DMA_IRQHandler+0x1704>)
 800b652:	4299      	cmp	r1, r3
 800b654:	d062      	beq.n	800b71c <HAL_DMA_IRQHandler+0x1608>
 800b656:	687b      	ldr	r3, [r7, #4]
 800b658:	681b      	ldr	r3, [r3, #0]
 800b65a:	4619      	mov	r1, r3
 800b65c:	4b6f      	ldr	r3, [pc, #444]	; (800b81c <HAL_DMA_IRQHandler+0x1708>)
 800b65e:	4299      	cmp	r1, r3
 800b660:	d05a      	beq.n	800b718 <HAL_DMA_IRQHandler+0x1604>
 800b662:	687b      	ldr	r3, [r7, #4]
 800b664:	681b      	ldr	r3, [r3, #0]
 800b666:	4619      	mov	r1, r3
 800b668:	4b6d      	ldr	r3, [pc, #436]	; (800b820 <HAL_DMA_IRQHandler+0x170c>)
 800b66a:	4299      	cmp	r1, r3
 800b66c:	d052      	beq.n	800b714 <HAL_DMA_IRQHandler+0x1600>
 800b66e:	687b      	ldr	r3, [r7, #4]
 800b670:	681b      	ldr	r3, [r3, #0]
 800b672:	4619      	mov	r1, r3
 800b674:	4b6b      	ldr	r3, [pc, #428]	; (800b824 <HAL_DMA_IRQHandler+0x1710>)
 800b676:	4299      	cmp	r1, r3
 800b678:	d04a      	beq.n	800b710 <HAL_DMA_IRQHandler+0x15fc>
 800b67a:	687b      	ldr	r3, [r7, #4]
 800b67c:	681b      	ldr	r3, [r3, #0]
 800b67e:	4619      	mov	r1, r3
 800b680:	4b69      	ldr	r3, [pc, #420]	; (800b828 <HAL_DMA_IRQHandler+0x1714>)
 800b682:	4299      	cmp	r1, r3
 800b684:	d041      	beq.n	800b70a <HAL_DMA_IRQHandler+0x15f6>
 800b686:	687b      	ldr	r3, [r7, #4]
 800b688:	681b      	ldr	r3, [r3, #0]
 800b68a:	4619      	mov	r1, r3
 800b68c:	4b67      	ldr	r3, [pc, #412]	; (800b82c <HAL_DMA_IRQHandler+0x1718>)
 800b68e:	4299      	cmp	r1, r3
 800b690:	d038      	beq.n	800b704 <HAL_DMA_IRQHandler+0x15f0>
 800b692:	687b      	ldr	r3, [r7, #4]
 800b694:	681b      	ldr	r3, [r3, #0]
 800b696:	4619      	mov	r1, r3
 800b698:	4b65      	ldr	r3, [pc, #404]	; (800b830 <HAL_DMA_IRQHandler+0x171c>)
 800b69a:	4299      	cmp	r1, r3
 800b69c:	d02f      	beq.n	800b6fe <HAL_DMA_IRQHandler+0x15ea>
 800b69e:	687b      	ldr	r3, [r7, #4]
 800b6a0:	681b      	ldr	r3, [r3, #0]
 800b6a2:	4619      	mov	r1, r3
 800b6a4:	4b63      	ldr	r3, [pc, #396]	; (800b834 <HAL_DMA_IRQHandler+0x1720>)
 800b6a6:	4299      	cmp	r1, r3
 800b6a8:	d026      	beq.n	800b6f8 <HAL_DMA_IRQHandler+0x15e4>
 800b6aa:	687b      	ldr	r3, [r7, #4]
 800b6ac:	681b      	ldr	r3, [r3, #0]
 800b6ae:	4619      	mov	r1, r3
 800b6b0:	4b61      	ldr	r3, [pc, #388]	; (800b838 <HAL_DMA_IRQHandler+0x1724>)
 800b6b2:	4299      	cmp	r1, r3
 800b6b4:	d01d      	beq.n	800b6f2 <HAL_DMA_IRQHandler+0x15de>
 800b6b6:	687b      	ldr	r3, [r7, #4]
 800b6b8:	681b      	ldr	r3, [r3, #0]
 800b6ba:	4619      	mov	r1, r3
 800b6bc:	4b5f      	ldr	r3, [pc, #380]	; (800b83c <HAL_DMA_IRQHandler+0x1728>)
 800b6be:	4299      	cmp	r1, r3
 800b6c0:	d014      	beq.n	800b6ec <HAL_DMA_IRQHandler+0x15d8>
 800b6c2:	687b      	ldr	r3, [r7, #4]
 800b6c4:	681b      	ldr	r3, [r3, #0]
 800b6c6:	4619      	mov	r1, r3
 800b6c8:	4b5d      	ldr	r3, [pc, #372]	; (800b840 <HAL_DMA_IRQHandler+0x172c>)
 800b6ca:	4299      	cmp	r1, r3
 800b6cc:	d00b      	beq.n	800b6e6 <HAL_DMA_IRQHandler+0x15d2>
 800b6ce:	687b      	ldr	r3, [r7, #4]
 800b6d0:	681b      	ldr	r3, [r3, #0]
 800b6d2:	4619      	mov	r1, r3
 800b6d4:	4b5b      	ldr	r3, [pc, #364]	; (800b844 <HAL_DMA_IRQHandler+0x1730>)
 800b6d6:	4299      	cmp	r1, r3
 800b6d8:	d102      	bne.n	800b6e0 <HAL_DMA_IRQHandler+0x15cc>
 800b6da:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b6de:	e01e      	b.n	800b71e <HAL_DMA_IRQHandler+0x160a>
 800b6e0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800b6e4:	e01b      	b.n	800b71e <HAL_DMA_IRQHandler+0x160a>
 800b6e6:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b6ea:	e018      	b.n	800b71e <HAL_DMA_IRQHandler+0x160a>
 800b6ec:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b6f0:	e015      	b.n	800b71e <HAL_DMA_IRQHandler+0x160a>
 800b6f2:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b6f6:	e012      	b.n	800b71e <HAL_DMA_IRQHandler+0x160a>
 800b6f8:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b6fc:	e00f      	b.n	800b71e <HAL_DMA_IRQHandler+0x160a>
 800b6fe:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b702:	e00c      	b.n	800b71e <HAL_DMA_IRQHandler+0x160a>
 800b704:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b708:	e009      	b.n	800b71e <HAL_DMA_IRQHandler+0x160a>
 800b70a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b70e:	e006      	b.n	800b71e <HAL_DMA_IRQHandler+0x160a>
 800b710:	4b3e      	ldr	r3, [pc, #248]	; (800b80c <HAL_DMA_IRQHandler+0x16f8>)
 800b712:	e004      	b.n	800b71e <HAL_DMA_IRQHandler+0x160a>
 800b714:	4b3d      	ldr	r3, [pc, #244]	; (800b80c <HAL_DMA_IRQHandler+0x16f8>)
 800b716:	e002      	b.n	800b71e <HAL_DMA_IRQHandler+0x160a>
 800b718:	4b3c      	ldr	r3, [pc, #240]	; (800b80c <HAL_DMA_IRQHandler+0x16f8>)
 800b71a:	e000      	b.n	800b71e <HAL_DMA_IRQHandler+0x160a>
 800b71c:	4b3b      	ldr	r3, [pc, #236]	; (800b80c <HAL_DMA_IRQHandler+0x16f8>)
 800b71e:	60d3      	str	r3, [r2, #12]
 800b720:	e192      	b.n	800ba48 <HAL_DMA_IRQHandler+0x1934>
 800b722:	687b      	ldr	r3, [r7, #4]
 800b724:	681b      	ldr	r3, [r3, #0]
 800b726:	461a      	mov	r2, r3
 800b728:	4b47      	ldr	r3, [pc, #284]	; (800b848 <HAL_DMA_IRQHandler+0x1734>)
 800b72a:	429a      	cmp	r2, r3
 800b72c:	f240 808e 	bls.w	800b84c <HAL_DMA_IRQHandler+0x1738>
 800b730:	4a38      	ldr	r2, [pc, #224]	; (800b814 <HAL_DMA_IRQHandler+0x1700>)
 800b732:	687b      	ldr	r3, [r7, #4]
 800b734:	681b      	ldr	r3, [r3, #0]
 800b736:	4619      	mov	r1, r3
 800b738:	4b37      	ldr	r3, [pc, #220]	; (800b818 <HAL_DMA_IRQHandler+0x1704>)
 800b73a:	4299      	cmp	r1, r3
 800b73c:	d062      	beq.n	800b804 <HAL_DMA_IRQHandler+0x16f0>
 800b73e:	687b      	ldr	r3, [r7, #4]
 800b740:	681b      	ldr	r3, [r3, #0]
 800b742:	4619      	mov	r1, r3
 800b744:	4b35      	ldr	r3, [pc, #212]	; (800b81c <HAL_DMA_IRQHandler+0x1708>)
 800b746:	4299      	cmp	r1, r3
 800b748:	d05a      	beq.n	800b800 <HAL_DMA_IRQHandler+0x16ec>
 800b74a:	687b      	ldr	r3, [r7, #4]
 800b74c:	681b      	ldr	r3, [r3, #0]
 800b74e:	4619      	mov	r1, r3
 800b750:	4b33      	ldr	r3, [pc, #204]	; (800b820 <HAL_DMA_IRQHandler+0x170c>)
 800b752:	4299      	cmp	r1, r3
 800b754:	d052      	beq.n	800b7fc <HAL_DMA_IRQHandler+0x16e8>
 800b756:	687b      	ldr	r3, [r7, #4]
 800b758:	681b      	ldr	r3, [r3, #0]
 800b75a:	4619      	mov	r1, r3
 800b75c:	4b31      	ldr	r3, [pc, #196]	; (800b824 <HAL_DMA_IRQHandler+0x1710>)
 800b75e:	4299      	cmp	r1, r3
 800b760:	d04a      	beq.n	800b7f8 <HAL_DMA_IRQHandler+0x16e4>
 800b762:	687b      	ldr	r3, [r7, #4]
 800b764:	681b      	ldr	r3, [r3, #0]
 800b766:	4619      	mov	r1, r3
 800b768:	4b2f      	ldr	r3, [pc, #188]	; (800b828 <HAL_DMA_IRQHandler+0x1714>)
 800b76a:	4299      	cmp	r1, r3
 800b76c:	d041      	beq.n	800b7f2 <HAL_DMA_IRQHandler+0x16de>
 800b76e:	687b      	ldr	r3, [r7, #4]
 800b770:	681b      	ldr	r3, [r3, #0]
 800b772:	4619      	mov	r1, r3
 800b774:	4b2d      	ldr	r3, [pc, #180]	; (800b82c <HAL_DMA_IRQHandler+0x1718>)
 800b776:	4299      	cmp	r1, r3
 800b778:	d038      	beq.n	800b7ec <HAL_DMA_IRQHandler+0x16d8>
 800b77a:	687b      	ldr	r3, [r7, #4]
 800b77c:	681b      	ldr	r3, [r3, #0]
 800b77e:	4619      	mov	r1, r3
 800b780:	4b2b      	ldr	r3, [pc, #172]	; (800b830 <HAL_DMA_IRQHandler+0x171c>)
 800b782:	4299      	cmp	r1, r3
 800b784:	d02f      	beq.n	800b7e6 <HAL_DMA_IRQHandler+0x16d2>
 800b786:	687b      	ldr	r3, [r7, #4]
 800b788:	681b      	ldr	r3, [r3, #0]
 800b78a:	4619      	mov	r1, r3
 800b78c:	4b29      	ldr	r3, [pc, #164]	; (800b834 <HAL_DMA_IRQHandler+0x1720>)
 800b78e:	4299      	cmp	r1, r3
 800b790:	d026      	beq.n	800b7e0 <HAL_DMA_IRQHandler+0x16cc>
 800b792:	687b      	ldr	r3, [r7, #4]
 800b794:	681b      	ldr	r3, [r3, #0]
 800b796:	4619      	mov	r1, r3
 800b798:	4b27      	ldr	r3, [pc, #156]	; (800b838 <HAL_DMA_IRQHandler+0x1724>)
 800b79a:	4299      	cmp	r1, r3
 800b79c:	d01d      	beq.n	800b7da <HAL_DMA_IRQHandler+0x16c6>
 800b79e:	687b      	ldr	r3, [r7, #4]
 800b7a0:	681b      	ldr	r3, [r3, #0]
 800b7a2:	4619      	mov	r1, r3
 800b7a4:	4b25      	ldr	r3, [pc, #148]	; (800b83c <HAL_DMA_IRQHandler+0x1728>)
 800b7a6:	4299      	cmp	r1, r3
 800b7a8:	d014      	beq.n	800b7d4 <HAL_DMA_IRQHandler+0x16c0>
 800b7aa:	687b      	ldr	r3, [r7, #4]
 800b7ac:	681b      	ldr	r3, [r3, #0]
 800b7ae:	4619      	mov	r1, r3
 800b7b0:	4b23      	ldr	r3, [pc, #140]	; (800b840 <HAL_DMA_IRQHandler+0x172c>)
 800b7b2:	4299      	cmp	r1, r3
 800b7b4:	d00b      	beq.n	800b7ce <HAL_DMA_IRQHandler+0x16ba>
 800b7b6:	687b      	ldr	r3, [r7, #4]
 800b7b8:	681b      	ldr	r3, [r3, #0]
 800b7ba:	4619      	mov	r1, r3
 800b7bc:	4b21      	ldr	r3, [pc, #132]	; (800b844 <HAL_DMA_IRQHandler+0x1730>)
 800b7be:	4299      	cmp	r1, r3
 800b7c0:	d102      	bne.n	800b7c8 <HAL_DMA_IRQHandler+0x16b4>
 800b7c2:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b7c6:	e01e      	b.n	800b806 <HAL_DMA_IRQHandler+0x16f2>
 800b7c8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800b7cc:	e01b      	b.n	800b806 <HAL_DMA_IRQHandler+0x16f2>
 800b7ce:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b7d2:	e018      	b.n	800b806 <HAL_DMA_IRQHandler+0x16f2>
 800b7d4:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b7d8:	e015      	b.n	800b806 <HAL_DMA_IRQHandler+0x16f2>
 800b7da:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b7de:	e012      	b.n	800b806 <HAL_DMA_IRQHandler+0x16f2>
 800b7e0:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b7e4:	e00f      	b.n	800b806 <HAL_DMA_IRQHandler+0x16f2>
 800b7e6:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b7ea:	e00c      	b.n	800b806 <HAL_DMA_IRQHandler+0x16f2>
 800b7ec:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b7f0:	e009      	b.n	800b806 <HAL_DMA_IRQHandler+0x16f2>
 800b7f2:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b7f6:	e006      	b.n	800b806 <HAL_DMA_IRQHandler+0x16f2>
 800b7f8:	4b04      	ldr	r3, [pc, #16]	; (800b80c <HAL_DMA_IRQHandler+0x16f8>)
 800b7fa:	e004      	b.n	800b806 <HAL_DMA_IRQHandler+0x16f2>
 800b7fc:	4b03      	ldr	r3, [pc, #12]	; (800b80c <HAL_DMA_IRQHandler+0x16f8>)
 800b7fe:	e002      	b.n	800b806 <HAL_DMA_IRQHandler+0x16f2>
 800b800:	4b02      	ldr	r3, [pc, #8]	; (800b80c <HAL_DMA_IRQHandler+0x16f8>)
 800b802:	e000      	b.n	800b806 <HAL_DMA_IRQHandler+0x16f2>
 800b804:	4b01      	ldr	r3, [pc, #4]	; (800b80c <HAL_DMA_IRQHandler+0x16f8>)
 800b806:	6093      	str	r3, [r2, #8]
 800b808:	e11e      	b.n	800ba48 <HAL_DMA_IRQHandler+0x1934>
 800b80a:	bf00      	nop
 800b80c:	00800004 	.word	0x00800004
 800b810:	40026458 	.word	0x40026458
 800b814:	40026400 	.word	0x40026400
 800b818:	40026010 	.word	0x40026010
 800b81c:	40026410 	.word	0x40026410
 800b820:	40026070 	.word	0x40026070
 800b824:	40026470 	.word	0x40026470
 800b828:	40026028 	.word	0x40026028
 800b82c:	40026428 	.word	0x40026428
 800b830:	40026088 	.word	0x40026088
 800b834:	40026488 	.word	0x40026488
 800b838:	40026040 	.word	0x40026040
 800b83c:	40026440 	.word	0x40026440
 800b840:	400260a0 	.word	0x400260a0
 800b844:	400264a0 	.word	0x400264a0
 800b848:	400260b8 	.word	0x400260b8
 800b84c:	687b      	ldr	r3, [r7, #4]
 800b84e:	681b      	ldr	r3, [r3, #0]
 800b850:	461a      	mov	r2, r3
 800b852:	4b6d      	ldr	r3, [pc, #436]	; (800ba08 <HAL_DMA_IRQHandler+0x18f4>)
 800b854:	429a      	cmp	r2, r3
 800b856:	d96c      	bls.n	800b932 <HAL_DMA_IRQHandler+0x181e>
 800b858:	4a6c      	ldr	r2, [pc, #432]	; (800ba0c <HAL_DMA_IRQHandler+0x18f8>)
 800b85a:	687b      	ldr	r3, [r7, #4]
 800b85c:	681b      	ldr	r3, [r3, #0]
 800b85e:	4619      	mov	r1, r3
 800b860:	4b6b      	ldr	r3, [pc, #428]	; (800ba10 <HAL_DMA_IRQHandler+0x18fc>)
 800b862:	4299      	cmp	r1, r3
 800b864:	d062      	beq.n	800b92c <HAL_DMA_IRQHandler+0x1818>
 800b866:	687b      	ldr	r3, [r7, #4]
 800b868:	681b      	ldr	r3, [r3, #0]
 800b86a:	4619      	mov	r1, r3
 800b86c:	4b69      	ldr	r3, [pc, #420]	; (800ba14 <HAL_DMA_IRQHandler+0x1900>)
 800b86e:	4299      	cmp	r1, r3
 800b870:	d05a      	beq.n	800b928 <HAL_DMA_IRQHandler+0x1814>
 800b872:	687b      	ldr	r3, [r7, #4]
 800b874:	681b      	ldr	r3, [r3, #0]
 800b876:	4619      	mov	r1, r3
 800b878:	4b67      	ldr	r3, [pc, #412]	; (800ba18 <HAL_DMA_IRQHandler+0x1904>)
 800b87a:	4299      	cmp	r1, r3
 800b87c:	d052      	beq.n	800b924 <HAL_DMA_IRQHandler+0x1810>
 800b87e:	687b      	ldr	r3, [r7, #4]
 800b880:	681b      	ldr	r3, [r3, #0]
 800b882:	4619      	mov	r1, r3
 800b884:	4b65      	ldr	r3, [pc, #404]	; (800ba1c <HAL_DMA_IRQHandler+0x1908>)
 800b886:	4299      	cmp	r1, r3
 800b888:	d04a      	beq.n	800b920 <HAL_DMA_IRQHandler+0x180c>
 800b88a:	687b      	ldr	r3, [r7, #4]
 800b88c:	681b      	ldr	r3, [r3, #0]
 800b88e:	4619      	mov	r1, r3
 800b890:	4b63      	ldr	r3, [pc, #396]	; (800ba20 <HAL_DMA_IRQHandler+0x190c>)
 800b892:	4299      	cmp	r1, r3
 800b894:	d041      	beq.n	800b91a <HAL_DMA_IRQHandler+0x1806>
 800b896:	687b      	ldr	r3, [r7, #4]
 800b898:	681b      	ldr	r3, [r3, #0]
 800b89a:	4619      	mov	r1, r3
 800b89c:	4b61      	ldr	r3, [pc, #388]	; (800ba24 <HAL_DMA_IRQHandler+0x1910>)
 800b89e:	4299      	cmp	r1, r3
 800b8a0:	d038      	beq.n	800b914 <HAL_DMA_IRQHandler+0x1800>
 800b8a2:	687b      	ldr	r3, [r7, #4]
 800b8a4:	681b      	ldr	r3, [r3, #0]
 800b8a6:	4619      	mov	r1, r3
 800b8a8:	4b5f      	ldr	r3, [pc, #380]	; (800ba28 <HAL_DMA_IRQHandler+0x1914>)
 800b8aa:	4299      	cmp	r1, r3
 800b8ac:	d02f      	beq.n	800b90e <HAL_DMA_IRQHandler+0x17fa>
 800b8ae:	687b      	ldr	r3, [r7, #4]
 800b8b0:	681b      	ldr	r3, [r3, #0]
 800b8b2:	4619      	mov	r1, r3
 800b8b4:	4b5d      	ldr	r3, [pc, #372]	; (800ba2c <HAL_DMA_IRQHandler+0x1918>)
 800b8b6:	4299      	cmp	r1, r3
 800b8b8:	d026      	beq.n	800b908 <HAL_DMA_IRQHandler+0x17f4>
 800b8ba:	687b      	ldr	r3, [r7, #4]
 800b8bc:	681b      	ldr	r3, [r3, #0]
 800b8be:	4619      	mov	r1, r3
 800b8c0:	4b5b      	ldr	r3, [pc, #364]	; (800ba30 <HAL_DMA_IRQHandler+0x191c>)
 800b8c2:	4299      	cmp	r1, r3
 800b8c4:	d01d      	beq.n	800b902 <HAL_DMA_IRQHandler+0x17ee>
 800b8c6:	687b      	ldr	r3, [r7, #4]
 800b8c8:	681b      	ldr	r3, [r3, #0]
 800b8ca:	4619      	mov	r1, r3
 800b8cc:	4b59      	ldr	r3, [pc, #356]	; (800ba34 <HAL_DMA_IRQHandler+0x1920>)
 800b8ce:	4299      	cmp	r1, r3
 800b8d0:	d014      	beq.n	800b8fc <HAL_DMA_IRQHandler+0x17e8>
 800b8d2:	687b      	ldr	r3, [r7, #4]
 800b8d4:	681b      	ldr	r3, [r3, #0]
 800b8d6:	4619      	mov	r1, r3
 800b8d8:	4b57      	ldr	r3, [pc, #348]	; (800ba38 <HAL_DMA_IRQHandler+0x1924>)
 800b8da:	4299      	cmp	r1, r3
 800b8dc:	d00b      	beq.n	800b8f6 <HAL_DMA_IRQHandler+0x17e2>
 800b8de:	687b      	ldr	r3, [r7, #4]
 800b8e0:	681b      	ldr	r3, [r3, #0]
 800b8e2:	4619      	mov	r1, r3
 800b8e4:	4b55      	ldr	r3, [pc, #340]	; (800ba3c <HAL_DMA_IRQHandler+0x1928>)
 800b8e6:	4299      	cmp	r1, r3
 800b8e8:	d102      	bne.n	800b8f0 <HAL_DMA_IRQHandler+0x17dc>
 800b8ea:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b8ee:	e01e      	b.n	800b92e <HAL_DMA_IRQHandler+0x181a>
 800b8f0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800b8f4:	e01b      	b.n	800b92e <HAL_DMA_IRQHandler+0x181a>
 800b8f6:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b8fa:	e018      	b.n	800b92e <HAL_DMA_IRQHandler+0x181a>
 800b8fc:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b900:	e015      	b.n	800b92e <HAL_DMA_IRQHandler+0x181a>
 800b902:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b906:	e012      	b.n	800b92e <HAL_DMA_IRQHandler+0x181a>
 800b908:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b90c:	e00f      	b.n	800b92e <HAL_DMA_IRQHandler+0x181a>
 800b90e:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b912:	e00c      	b.n	800b92e <HAL_DMA_IRQHandler+0x181a>
 800b914:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b918:	e009      	b.n	800b92e <HAL_DMA_IRQHandler+0x181a>
 800b91a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b91e:	e006      	b.n	800b92e <HAL_DMA_IRQHandler+0x181a>
 800b920:	4b47      	ldr	r3, [pc, #284]	; (800ba40 <HAL_DMA_IRQHandler+0x192c>)
 800b922:	e004      	b.n	800b92e <HAL_DMA_IRQHandler+0x181a>
 800b924:	4b46      	ldr	r3, [pc, #280]	; (800ba40 <HAL_DMA_IRQHandler+0x192c>)
 800b926:	e002      	b.n	800b92e <HAL_DMA_IRQHandler+0x181a>
 800b928:	4b45      	ldr	r3, [pc, #276]	; (800ba40 <HAL_DMA_IRQHandler+0x192c>)
 800b92a:	e000      	b.n	800b92e <HAL_DMA_IRQHandler+0x181a>
 800b92c:	4b44      	ldr	r3, [pc, #272]	; (800ba40 <HAL_DMA_IRQHandler+0x192c>)
 800b92e:	60d3      	str	r3, [r2, #12]
 800b930:	e08a      	b.n	800ba48 <HAL_DMA_IRQHandler+0x1934>
 800b932:	4a36      	ldr	r2, [pc, #216]	; (800ba0c <HAL_DMA_IRQHandler+0x18f8>)
 800b934:	687b      	ldr	r3, [r7, #4]
 800b936:	681b      	ldr	r3, [r3, #0]
 800b938:	4619      	mov	r1, r3
 800b93a:	4b35      	ldr	r3, [pc, #212]	; (800ba10 <HAL_DMA_IRQHandler+0x18fc>)
 800b93c:	4299      	cmp	r1, r3
 800b93e:	f000 8081 	beq.w	800ba44 <HAL_DMA_IRQHandler+0x1930>
 800b942:	687b      	ldr	r3, [r7, #4]
 800b944:	681b      	ldr	r3, [r3, #0]
 800b946:	4619      	mov	r1, r3
 800b948:	4b32      	ldr	r3, [pc, #200]	; (800ba14 <HAL_DMA_IRQHandler+0x1900>)
 800b94a:	4299      	cmp	r1, r3
 800b94c:	d05a      	beq.n	800ba04 <HAL_DMA_IRQHandler+0x18f0>
 800b94e:	687b      	ldr	r3, [r7, #4]
 800b950:	681b      	ldr	r3, [r3, #0]
 800b952:	4619      	mov	r1, r3
 800b954:	4b30      	ldr	r3, [pc, #192]	; (800ba18 <HAL_DMA_IRQHandler+0x1904>)
 800b956:	4299      	cmp	r1, r3
 800b958:	d052      	beq.n	800ba00 <HAL_DMA_IRQHandler+0x18ec>
 800b95a:	687b      	ldr	r3, [r7, #4]
 800b95c:	681b      	ldr	r3, [r3, #0]
 800b95e:	4619      	mov	r1, r3
 800b960:	4b2e      	ldr	r3, [pc, #184]	; (800ba1c <HAL_DMA_IRQHandler+0x1908>)
 800b962:	4299      	cmp	r1, r3
 800b964:	d04a      	beq.n	800b9fc <HAL_DMA_IRQHandler+0x18e8>
 800b966:	687b      	ldr	r3, [r7, #4]
 800b968:	681b      	ldr	r3, [r3, #0]
 800b96a:	4619      	mov	r1, r3
 800b96c:	4b2c      	ldr	r3, [pc, #176]	; (800ba20 <HAL_DMA_IRQHandler+0x190c>)
 800b96e:	4299      	cmp	r1, r3
 800b970:	d041      	beq.n	800b9f6 <HAL_DMA_IRQHandler+0x18e2>
 800b972:	687b      	ldr	r3, [r7, #4]
 800b974:	681b      	ldr	r3, [r3, #0]
 800b976:	4619      	mov	r1, r3
 800b978:	4b2a      	ldr	r3, [pc, #168]	; (800ba24 <HAL_DMA_IRQHandler+0x1910>)
 800b97a:	4299      	cmp	r1, r3
 800b97c:	d038      	beq.n	800b9f0 <HAL_DMA_IRQHandler+0x18dc>
 800b97e:	687b      	ldr	r3, [r7, #4]
 800b980:	681b      	ldr	r3, [r3, #0]
 800b982:	4619      	mov	r1, r3
 800b984:	4b28      	ldr	r3, [pc, #160]	; (800ba28 <HAL_DMA_IRQHandler+0x1914>)
 800b986:	4299      	cmp	r1, r3
 800b988:	d02f      	beq.n	800b9ea <HAL_DMA_IRQHandler+0x18d6>
 800b98a:	687b      	ldr	r3, [r7, #4]
 800b98c:	681b      	ldr	r3, [r3, #0]
 800b98e:	4619      	mov	r1, r3
 800b990:	4b26      	ldr	r3, [pc, #152]	; (800ba2c <HAL_DMA_IRQHandler+0x1918>)
 800b992:	4299      	cmp	r1, r3
 800b994:	d026      	beq.n	800b9e4 <HAL_DMA_IRQHandler+0x18d0>
 800b996:	687b      	ldr	r3, [r7, #4]
 800b998:	681b      	ldr	r3, [r3, #0]
 800b99a:	4619      	mov	r1, r3
 800b99c:	4b24      	ldr	r3, [pc, #144]	; (800ba30 <HAL_DMA_IRQHandler+0x191c>)
 800b99e:	4299      	cmp	r1, r3
 800b9a0:	d01d      	beq.n	800b9de <HAL_DMA_IRQHandler+0x18ca>
 800b9a2:	687b      	ldr	r3, [r7, #4]
 800b9a4:	681b      	ldr	r3, [r3, #0]
 800b9a6:	4619      	mov	r1, r3
 800b9a8:	4b22      	ldr	r3, [pc, #136]	; (800ba34 <HAL_DMA_IRQHandler+0x1920>)
 800b9aa:	4299      	cmp	r1, r3
 800b9ac:	d014      	beq.n	800b9d8 <HAL_DMA_IRQHandler+0x18c4>
 800b9ae:	687b      	ldr	r3, [r7, #4]
 800b9b0:	681b      	ldr	r3, [r3, #0]
 800b9b2:	4619      	mov	r1, r3
 800b9b4:	4b20      	ldr	r3, [pc, #128]	; (800ba38 <HAL_DMA_IRQHandler+0x1924>)
 800b9b6:	4299      	cmp	r1, r3
 800b9b8:	d00b      	beq.n	800b9d2 <HAL_DMA_IRQHandler+0x18be>
 800b9ba:	687b      	ldr	r3, [r7, #4]
 800b9bc:	681b      	ldr	r3, [r3, #0]
 800b9be:	4619      	mov	r1, r3
 800b9c0:	4b1e      	ldr	r3, [pc, #120]	; (800ba3c <HAL_DMA_IRQHandler+0x1928>)
 800b9c2:	4299      	cmp	r1, r3
 800b9c4:	d102      	bne.n	800b9cc <HAL_DMA_IRQHandler+0x18b8>
 800b9c6:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b9ca:	e03c      	b.n	800ba46 <HAL_DMA_IRQHandler+0x1932>
 800b9cc:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800b9d0:	e039      	b.n	800ba46 <HAL_DMA_IRQHandler+0x1932>
 800b9d2:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b9d6:	e036      	b.n	800ba46 <HAL_DMA_IRQHandler+0x1932>
 800b9d8:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b9dc:	e033      	b.n	800ba46 <HAL_DMA_IRQHandler+0x1932>
 800b9de:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b9e2:	e030      	b.n	800ba46 <HAL_DMA_IRQHandler+0x1932>
 800b9e4:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b9e8:	e02d      	b.n	800ba46 <HAL_DMA_IRQHandler+0x1932>
 800b9ea:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b9ee:	e02a      	b.n	800ba46 <HAL_DMA_IRQHandler+0x1932>
 800b9f0:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b9f4:	e027      	b.n	800ba46 <HAL_DMA_IRQHandler+0x1932>
 800b9f6:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b9fa:	e024      	b.n	800ba46 <HAL_DMA_IRQHandler+0x1932>
 800b9fc:	4b10      	ldr	r3, [pc, #64]	; (800ba40 <HAL_DMA_IRQHandler+0x192c>)
 800b9fe:	e022      	b.n	800ba46 <HAL_DMA_IRQHandler+0x1932>
 800ba00:	4b0f      	ldr	r3, [pc, #60]	; (800ba40 <HAL_DMA_IRQHandler+0x192c>)
 800ba02:	e020      	b.n	800ba46 <HAL_DMA_IRQHandler+0x1932>
 800ba04:	4b0e      	ldr	r3, [pc, #56]	; (800ba40 <HAL_DMA_IRQHandler+0x192c>)
 800ba06:	e01e      	b.n	800ba46 <HAL_DMA_IRQHandler+0x1932>
 800ba08:	40026058 	.word	0x40026058
 800ba0c:	40026000 	.word	0x40026000
 800ba10:	40026010 	.word	0x40026010
 800ba14:	40026410 	.word	0x40026410
 800ba18:	40026070 	.word	0x40026070
 800ba1c:	40026470 	.word	0x40026470
 800ba20:	40026028 	.word	0x40026028
 800ba24:	40026428 	.word	0x40026428
 800ba28:	40026088 	.word	0x40026088
 800ba2c:	40026488 	.word	0x40026488
 800ba30:	40026040 	.word	0x40026040
 800ba34:	40026440 	.word	0x40026440
 800ba38:	400260a0 	.word	0x400260a0
 800ba3c:	400264a0 	.word	0x400264a0
 800ba40:	00800004 	.word	0x00800004
 800ba44:	4b85      	ldr	r3, [pc, #532]	; (800bc5c <HAL_DMA_IRQHandler+0x1b48>)
 800ba46:	6093      	str	r3, [r2, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 800ba48:	687b      	ldr	r3, [r7, #4]
 800ba4a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800ba4c:	f043 0204 	orr.w	r2, r3, #4
 800ba50:	687b      	ldr	r3, [r7, #4]
 800ba52:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
 800ba54:	687b      	ldr	r3, [r7, #4]
 800ba56:	2204      	movs	r2, #4
 800ba58:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 800ba5c:	687b      	ldr	r3, [r7, #4]
 800ba5e:	2200      	movs	r2, #0
 800ba60:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      if(hdma->XferErrorCallback != NULL)
 800ba64:	687b      	ldr	r3, [r7, #4]
 800ba66:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ba68:	2b00      	cmp	r3, #0
 800ba6a:	d003      	beq.n	800ba74 <HAL_DMA_IRQHandler+0x1960>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 800ba6c:	687b      	ldr	r3, [r7, #4]
 800ba6e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ba70:	6878      	ldr	r0, [r7, #4]
 800ba72:	4798      	blx	r3
      }
    }
  }
  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 800ba74:	687b      	ldr	r3, [r7, #4]
 800ba76:	681b      	ldr	r3, [r3, #0]
 800ba78:	461a      	mov	r2, r3
 800ba7a:	4b79      	ldr	r3, [pc, #484]	; (800bc60 <HAL_DMA_IRQHandler+0x1b4c>)
 800ba7c:	429a      	cmp	r2, r3
 800ba7e:	d972      	bls.n	800bb66 <HAL_DMA_IRQHandler+0x1a52>
 800ba80:	4b78      	ldr	r3, [pc, #480]	; (800bc64 <HAL_DMA_IRQHandler+0x1b50>)
 800ba82:	685a      	ldr	r2, [r3, #4]
 800ba84:	687b      	ldr	r3, [r7, #4]
 800ba86:	681b      	ldr	r3, [r3, #0]
 800ba88:	4619      	mov	r1, r3
 800ba8a:	4b77      	ldr	r3, [pc, #476]	; (800bc68 <HAL_DMA_IRQHandler+0x1b54>)
 800ba8c:	4299      	cmp	r1, r3
 800ba8e:	d062      	beq.n	800bb56 <HAL_DMA_IRQHandler+0x1a42>
 800ba90:	687b      	ldr	r3, [r7, #4]
 800ba92:	681b      	ldr	r3, [r3, #0]
 800ba94:	4619      	mov	r1, r3
 800ba96:	4b75      	ldr	r3, [pc, #468]	; (800bc6c <HAL_DMA_IRQHandler+0x1b58>)
 800ba98:	4299      	cmp	r1, r3
 800ba9a:	d05a      	beq.n	800bb52 <HAL_DMA_IRQHandler+0x1a3e>
 800ba9c:	687b      	ldr	r3, [r7, #4]
 800ba9e:	681b      	ldr	r3, [r3, #0]
 800baa0:	4619      	mov	r1, r3
 800baa2:	4b73      	ldr	r3, [pc, #460]	; (800bc70 <HAL_DMA_IRQHandler+0x1b5c>)
 800baa4:	4299      	cmp	r1, r3
 800baa6:	d052      	beq.n	800bb4e <HAL_DMA_IRQHandler+0x1a3a>
 800baa8:	687b      	ldr	r3, [r7, #4]
 800baaa:	681b      	ldr	r3, [r3, #0]
 800baac:	4619      	mov	r1, r3
 800baae:	4b71      	ldr	r3, [pc, #452]	; (800bc74 <HAL_DMA_IRQHandler+0x1b60>)
 800bab0:	4299      	cmp	r1, r3
 800bab2:	d04a      	beq.n	800bb4a <HAL_DMA_IRQHandler+0x1a36>
 800bab4:	687b      	ldr	r3, [r7, #4]
 800bab6:	681b      	ldr	r3, [r3, #0]
 800bab8:	4619      	mov	r1, r3
 800baba:	4b6f      	ldr	r3, [pc, #444]	; (800bc78 <HAL_DMA_IRQHandler+0x1b64>)
 800babc:	4299      	cmp	r1, r3
 800babe:	d041      	beq.n	800bb44 <HAL_DMA_IRQHandler+0x1a30>
 800bac0:	687b      	ldr	r3, [r7, #4]
 800bac2:	681b      	ldr	r3, [r3, #0]
 800bac4:	4619      	mov	r1, r3
 800bac6:	4b6d      	ldr	r3, [pc, #436]	; (800bc7c <HAL_DMA_IRQHandler+0x1b68>)
 800bac8:	4299      	cmp	r1, r3
 800baca:	d038      	beq.n	800bb3e <HAL_DMA_IRQHandler+0x1a2a>
 800bacc:	687b      	ldr	r3, [r7, #4]
 800bace:	681b      	ldr	r3, [r3, #0]
 800bad0:	4619      	mov	r1, r3
 800bad2:	4b6b      	ldr	r3, [pc, #428]	; (800bc80 <HAL_DMA_IRQHandler+0x1b6c>)
 800bad4:	4299      	cmp	r1, r3
 800bad6:	d02f      	beq.n	800bb38 <HAL_DMA_IRQHandler+0x1a24>
 800bad8:	687b      	ldr	r3, [r7, #4]
 800bada:	681b      	ldr	r3, [r3, #0]
 800badc:	4619      	mov	r1, r3
 800bade:	4b69      	ldr	r3, [pc, #420]	; (800bc84 <HAL_DMA_IRQHandler+0x1b70>)
 800bae0:	4299      	cmp	r1, r3
 800bae2:	d026      	beq.n	800bb32 <HAL_DMA_IRQHandler+0x1a1e>
 800bae4:	687b      	ldr	r3, [r7, #4]
 800bae6:	681b      	ldr	r3, [r3, #0]
 800bae8:	4619      	mov	r1, r3
 800baea:	4b67      	ldr	r3, [pc, #412]	; (800bc88 <HAL_DMA_IRQHandler+0x1b74>)
 800baec:	4299      	cmp	r1, r3
 800baee:	d01d      	beq.n	800bb2c <HAL_DMA_IRQHandler+0x1a18>
 800baf0:	687b      	ldr	r3, [r7, #4]
 800baf2:	681b      	ldr	r3, [r3, #0]
 800baf4:	4619      	mov	r1, r3
 800baf6:	4b65      	ldr	r3, [pc, #404]	; (800bc8c <HAL_DMA_IRQHandler+0x1b78>)
 800baf8:	4299      	cmp	r1, r3
 800bafa:	d014      	beq.n	800bb26 <HAL_DMA_IRQHandler+0x1a12>
 800bafc:	687b      	ldr	r3, [r7, #4]
 800bafe:	681b      	ldr	r3, [r3, #0]
 800bb00:	4619      	mov	r1, r3
 800bb02:	4b63      	ldr	r3, [pc, #396]	; (800bc90 <HAL_DMA_IRQHandler+0x1b7c>)
 800bb04:	4299      	cmp	r1, r3
 800bb06:	d00b      	beq.n	800bb20 <HAL_DMA_IRQHandler+0x1a0c>
 800bb08:	687b      	ldr	r3, [r7, #4]
 800bb0a:	681b      	ldr	r3, [r3, #0]
 800bb0c:	4619      	mov	r1, r3
 800bb0e:	4b61      	ldr	r3, [pc, #388]	; (800bc94 <HAL_DMA_IRQHandler+0x1b80>)
 800bb10:	4299      	cmp	r1, r3
 800bb12:	d102      	bne.n	800bb1a <HAL_DMA_IRQHandler+0x1a06>
 800bb14:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bb18:	e01e      	b.n	800bb58 <HAL_DMA_IRQHandler+0x1a44>
 800bb1a:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800bb1e:	e01b      	b.n	800bb58 <HAL_DMA_IRQHandler+0x1a44>
 800bb20:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bb24:	e018      	b.n	800bb58 <HAL_DMA_IRQHandler+0x1a44>
 800bb26:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bb2a:	e015      	b.n	800bb58 <HAL_DMA_IRQHandler+0x1a44>
 800bb2c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bb30:	e012      	b.n	800bb58 <HAL_DMA_IRQHandler+0x1a44>
 800bb32:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bb36:	e00f      	b.n	800bb58 <HAL_DMA_IRQHandler+0x1a44>
 800bb38:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bb3c:	e00c      	b.n	800bb58 <HAL_DMA_IRQHandler+0x1a44>
 800bb3e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bb42:	e009      	b.n	800bb58 <HAL_DMA_IRQHandler+0x1a44>
 800bb44:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bb48:	e006      	b.n	800bb58 <HAL_DMA_IRQHandler+0x1a44>
 800bb4a:	2310      	movs	r3, #16
 800bb4c:	e004      	b.n	800bb58 <HAL_DMA_IRQHandler+0x1a44>
 800bb4e:	2310      	movs	r3, #16
 800bb50:	e002      	b.n	800bb58 <HAL_DMA_IRQHandler+0x1a44>
 800bb52:	2310      	movs	r3, #16
 800bb54:	e000      	b.n	800bb58 <HAL_DMA_IRQHandler+0x1a44>
 800bb56:	2310      	movs	r3, #16
 800bb58:	4013      	ands	r3, r2
 800bb5a:	2b00      	cmp	r3, #0
 800bb5c:	bf14      	ite	ne
 800bb5e:	2301      	movne	r3, #1
 800bb60:	2300      	moveq	r3, #0
 800bb62:	b2db      	uxtb	r3, r3
 800bb64:	e1a1      	b.n	800beaa <HAL_DMA_IRQHandler+0x1d96>
 800bb66:	687b      	ldr	r3, [r7, #4]
 800bb68:	681b      	ldr	r3, [r3, #0]
 800bb6a:	461a      	mov	r2, r3
 800bb6c:	4b4a      	ldr	r3, [pc, #296]	; (800bc98 <HAL_DMA_IRQHandler+0x1b84>)
 800bb6e:	429a      	cmp	r2, r3
 800bb70:	f240 8094 	bls.w	800bc9c <HAL_DMA_IRQHandler+0x1b88>
 800bb74:	4b3b      	ldr	r3, [pc, #236]	; (800bc64 <HAL_DMA_IRQHandler+0x1b50>)
 800bb76:	681a      	ldr	r2, [r3, #0]
 800bb78:	687b      	ldr	r3, [r7, #4]
 800bb7a:	681b      	ldr	r3, [r3, #0]
 800bb7c:	4619      	mov	r1, r3
 800bb7e:	4b3a      	ldr	r3, [pc, #232]	; (800bc68 <HAL_DMA_IRQHandler+0x1b54>)
 800bb80:	4299      	cmp	r1, r3
 800bb82:	d062      	beq.n	800bc4a <HAL_DMA_IRQHandler+0x1b36>
 800bb84:	687b      	ldr	r3, [r7, #4]
 800bb86:	681b      	ldr	r3, [r3, #0]
 800bb88:	4619      	mov	r1, r3
 800bb8a:	4b38      	ldr	r3, [pc, #224]	; (800bc6c <HAL_DMA_IRQHandler+0x1b58>)
 800bb8c:	4299      	cmp	r1, r3
 800bb8e:	d05a      	beq.n	800bc46 <HAL_DMA_IRQHandler+0x1b32>
 800bb90:	687b      	ldr	r3, [r7, #4]
 800bb92:	681b      	ldr	r3, [r3, #0]
 800bb94:	4619      	mov	r1, r3
 800bb96:	4b36      	ldr	r3, [pc, #216]	; (800bc70 <HAL_DMA_IRQHandler+0x1b5c>)
 800bb98:	4299      	cmp	r1, r3
 800bb9a:	d052      	beq.n	800bc42 <HAL_DMA_IRQHandler+0x1b2e>
 800bb9c:	687b      	ldr	r3, [r7, #4]
 800bb9e:	681b      	ldr	r3, [r3, #0]
 800bba0:	4619      	mov	r1, r3
 800bba2:	4b34      	ldr	r3, [pc, #208]	; (800bc74 <HAL_DMA_IRQHandler+0x1b60>)
 800bba4:	4299      	cmp	r1, r3
 800bba6:	d04a      	beq.n	800bc3e <HAL_DMA_IRQHandler+0x1b2a>
 800bba8:	687b      	ldr	r3, [r7, #4]
 800bbaa:	681b      	ldr	r3, [r3, #0]
 800bbac:	4619      	mov	r1, r3
 800bbae:	4b32      	ldr	r3, [pc, #200]	; (800bc78 <HAL_DMA_IRQHandler+0x1b64>)
 800bbb0:	4299      	cmp	r1, r3
 800bbb2:	d041      	beq.n	800bc38 <HAL_DMA_IRQHandler+0x1b24>
 800bbb4:	687b      	ldr	r3, [r7, #4]
 800bbb6:	681b      	ldr	r3, [r3, #0]
 800bbb8:	4619      	mov	r1, r3
 800bbba:	4b30      	ldr	r3, [pc, #192]	; (800bc7c <HAL_DMA_IRQHandler+0x1b68>)
 800bbbc:	4299      	cmp	r1, r3
 800bbbe:	d038      	beq.n	800bc32 <HAL_DMA_IRQHandler+0x1b1e>
 800bbc0:	687b      	ldr	r3, [r7, #4]
 800bbc2:	681b      	ldr	r3, [r3, #0]
 800bbc4:	4619      	mov	r1, r3
 800bbc6:	4b2e      	ldr	r3, [pc, #184]	; (800bc80 <HAL_DMA_IRQHandler+0x1b6c>)
 800bbc8:	4299      	cmp	r1, r3
 800bbca:	d02f      	beq.n	800bc2c <HAL_DMA_IRQHandler+0x1b18>
 800bbcc:	687b      	ldr	r3, [r7, #4]
 800bbce:	681b      	ldr	r3, [r3, #0]
 800bbd0:	4619      	mov	r1, r3
 800bbd2:	4b2c      	ldr	r3, [pc, #176]	; (800bc84 <HAL_DMA_IRQHandler+0x1b70>)
 800bbd4:	4299      	cmp	r1, r3
 800bbd6:	d026      	beq.n	800bc26 <HAL_DMA_IRQHandler+0x1b12>
 800bbd8:	687b      	ldr	r3, [r7, #4]
 800bbda:	681b      	ldr	r3, [r3, #0]
 800bbdc:	4619      	mov	r1, r3
 800bbde:	4b2a      	ldr	r3, [pc, #168]	; (800bc88 <HAL_DMA_IRQHandler+0x1b74>)
 800bbe0:	4299      	cmp	r1, r3
 800bbe2:	d01d      	beq.n	800bc20 <HAL_DMA_IRQHandler+0x1b0c>
 800bbe4:	687b      	ldr	r3, [r7, #4]
 800bbe6:	681b      	ldr	r3, [r3, #0]
 800bbe8:	4619      	mov	r1, r3
 800bbea:	4b28      	ldr	r3, [pc, #160]	; (800bc8c <HAL_DMA_IRQHandler+0x1b78>)
 800bbec:	4299      	cmp	r1, r3
 800bbee:	d014      	beq.n	800bc1a <HAL_DMA_IRQHandler+0x1b06>
 800bbf0:	687b      	ldr	r3, [r7, #4]
 800bbf2:	681b      	ldr	r3, [r3, #0]
 800bbf4:	4619      	mov	r1, r3
 800bbf6:	4b26      	ldr	r3, [pc, #152]	; (800bc90 <HAL_DMA_IRQHandler+0x1b7c>)
 800bbf8:	4299      	cmp	r1, r3
 800bbfa:	d00b      	beq.n	800bc14 <HAL_DMA_IRQHandler+0x1b00>
 800bbfc:	687b      	ldr	r3, [r7, #4]
 800bbfe:	681b      	ldr	r3, [r3, #0]
 800bc00:	4619      	mov	r1, r3
 800bc02:	4b24      	ldr	r3, [pc, #144]	; (800bc94 <HAL_DMA_IRQHandler+0x1b80>)
 800bc04:	4299      	cmp	r1, r3
 800bc06:	d102      	bne.n	800bc0e <HAL_DMA_IRQHandler+0x1afa>
 800bc08:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bc0c:	e01e      	b.n	800bc4c <HAL_DMA_IRQHandler+0x1b38>
 800bc0e:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800bc12:	e01b      	b.n	800bc4c <HAL_DMA_IRQHandler+0x1b38>
 800bc14:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bc18:	e018      	b.n	800bc4c <HAL_DMA_IRQHandler+0x1b38>
 800bc1a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bc1e:	e015      	b.n	800bc4c <HAL_DMA_IRQHandler+0x1b38>
 800bc20:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bc24:	e012      	b.n	800bc4c <HAL_DMA_IRQHandler+0x1b38>
 800bc26:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bc2a:	e00f      	b.n	800bc4c <HAL_DMA_IRQHandler+0x1b38>
 800bc2c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bc30:	e00c      	b.n	800bc4c <HAL_DMA_IRQHandler+0x1b38>
 800bc32:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bc36:	e009      	b.n	800bc4c <HAL_DMA_IRQHandler+0x1b38>
 800bc38:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bc3c:	e006      	b.n	800bc4c <HAL_DMA_IRQHandler+0x1b38>
 800bc3e:	2310      	movs	r3, #16
 800bc40:	e004      	b.n	800bc4c <HAL_DMA_IRQHandler+0x1b38>
 800bc42:	2310      	movs	r3, #16
 800bc44:	e002      	b.n	800bc4c <HAL_DMA_IRQHandler+0x1b38>
 800bc46:	2310      	movs	r3, #16
 800bc48:	e000      	b.n	800bc4c <HAL_DMA_IRQHandler+0x1b38>
 800bc4a:	2310      	movs	r3, #16
 800bc4c:	4013      	ands	r3, r2
 800bc4e:	2b00      	cmp	r3, #0
 800bc50:	bf14      	ite	ne
 800bc52:	2301      	movne	r3, #1
 800bc54:	2300      	moveq	r3, #0
 800bc56:	b2db      	uxtb	r3, r3
 800bc58:	e127      	b.n	800beaa <HAL_DMA_IRQHandler+0x1d96>
 800bc5a:	bf00      	nop
 800bc5c:	00800004 	.word	0x00800004
 800bc60:	40026458 	.word	0x40026458
 800bc64:	40026400 	.word	0x40026400
 800bc68:	40026010 	.word	0x40026010
 800bc6c:	40026410 	.word	0x40026410
 800bc70:	40026070 	.word	0x40026070
 800bc74:	40026470 	.word	0x40026470
 800bc78:	40026028 	.word	0x40026028
 800bc7c:	40026428 	.word	0x40026428
 800bc80:	40026088 	.word	0x40026088
 800bc84:	40026488 	.word	0x40026488
 800bc88:	40026040 	.word	0x40026040
 800bc8c:	40026440 	.word	0x40026440
 800bc90:	400260a0 	.word	0x400260a0
 800bc94:	400264a0 	.word	0x400264a0
 800bc98:	400260b8 	.word	0x400260b8
 800bc9c:	687b      	ldr	r3, [r7, #4]
 800bc9e:	681b      	ldr	r3, [r3, #0]
 800bca0:	461a      	mov	r2, r3
 800bca2:	4b70      	ldr	r3, [pc, #448]	; (800be64 <HAL_DMA_IRQHandler+0x1d50>)
 800bca4:	429a      	cmp	r2, r3
 800bca6:	d972      	bls.n	800bd8e <HAL_DMA_IRQHandler+0x1c7a>
 800bca8:	4b6f      	ldr	r3, [pc, #444]	; (800be68 <HAL_DMA_IRQHandler+0x1d54>)
 800bcaa:	685a      	ldr	r2, [r3, #4]
 800bcac:	687b      	ldr	r3, [r7, #4]
 800bcae:	681b      	ldr	r3, [r3, #0]
 800bcb0:	4619      	mov	r1, r3
 800bcb2:	4b6e      	ldr	r3, [pc, #440]	; (800be6c <HAL_DMA_IRQHandler+0x1d58>)
 800bcb4:	4299      	cmp	r1, r3
 800bcb6:	d062      	beq.n	800bd7e <HAL_DMA_IRQHandler+0x1c6a>
 800bcb8:	687b      	ldr	r3, [r7, #4]
 800bcba:	681b      	ldr	r3, [r3, #0]
 800bcbc:	4619      	mov	r1, r3
 800bcbe:	4b6c      	ldr	r3, [pc, #432]	; (800be70 <HAL_DMA_IRQHandler+0x1d5c>)
 800bcc0:	4299      	cmp	r1, r3
 800bcc2:	d05a      	beq.n	800bd7a <HAL_DMA_IRQHandler+0x1c66>
 800bcc4:	687b      	ldr	r3, [r7, #4]
 800bcc6:	681b      	ldr	r3, [r3, #0]
 800bcc8:	4619      	mov	r1, r3
 800bcca:	4b6a      	ldr	r3, [pc, #424]	; (800be74 <HAL_DMA_IRQHandler+0x1d60>)
 800bccc:	4299      	cmp	r1, r3
 800bcce:	d052      	beq.n	800bd76 <HAL_DMA_IRQHandler+0x1c62>
 800bcd0:	687b      	ldr	r3, [r7, #4]
 800bcd2:	681b      	ldr	r3, [r3, #0]
 800bcd4:	4619      	mov	r1, r3
 800bcd6:	4b68      	ldr	r3, [pc, #416]	; (800be78 <HAL_DMA_IRQHandler+0x1d64>)
 800bcd8:	4299      	cmp	r1, r3
 800bcda:	d04a      	beq.n	800bd72 <HAL_DMA_IRQHandler+0x1c5e>
 800bcdc:	687b      	ldr	r3, [r7, #4]
 800bcde:	681b      	ldr	r3, [r3, #0]
 800bce0:	4619      	mov	r1, r3
 800bce2:	4b66      	ldr	r3, [pc, #408]	; (800be7c <HAL_DMA_IRQHandler+0x1d68>)
 800bce4:	4299      	cmp	r1, r3
 800bce6:	d041      	beq.n	800bd6c <HAL_DMA_IRQHandler+0x1c58>
 800bce8:	687b      	ldr	r3, [r7, #4]
 800bcea:	681b      	ldr	r3, [r3, #0]
 800bcec:	4619      	mov	r1, r3
 800bcee:	4b64      	ldr	r3, [pc, #400]	; (800be80 <HAL_DMA_IRQHandler+0x1d6c>)
 800bcf0:	4299      	cmp	r1, r3
 800bcf2:	d038      	beq.n	800bd66 <HAL_DMA_IRQHandler+0x1c52>
 800bcf4:	687b      	ldr	r3, [r7, #4]
 800bcf6:	681b      	ldr	r3, [r3, #0]
 800bcf8:	4619      	mov	r1, r3
 800bcfa:	4b62      	ldr	r3, [pc, #392]	; (800be84 <HAL_DMA_IRQHandler+0x1d70>)
 800bcfc:	4299      	cmp	r1, r3
 800bcfe:	d02f      	beq.n	800bd60 <HAL_DMA_IRQHandler+0x1c4c>
 800bd00:	687b      	ldr	r3, [r7, #4]
 800bd02:	681b      	ldr	r3, [r3, #0]
 800bd04:	4619      	mov	r1, r3
 800bd06:	4b60      	ldr	r3, [pc, #384]	; (800be88 <HAL_DMA_IRQHandler+0x1d74>)
 800bd08:	4299      	cmp	r1, r3
 800bd0a:	d026      	beq.n	800bd5a <HAL_DMA_IRQHandler+0x1c46>
 800bd0c:	687b      	ldr	r3, [r7, #4]
 800bd0e:	681b      	ldr	r3, [r3, #0]
 800bd10:	4619      	mov	r1, r3
 800bd12:	4b5e      	ldr	r3, [pc, #376]	; (800be8c <HAL_DMA_IRQHandler+0x1d78>)
 800bd14:	4299      	cmp	r1, r3
 800bd16:	d01d      	beq.n	800bd54 <HAL_DMA_IRQHandler+0x1c40>
 800bd18:	687b      	ldr	r3, [r7, #4]
 800bd1a:	681b      	ldr	r3, [r3, #0]
 800bd1c:	4619      	mov	r1, r3
 800bd1e:	4b5c      	ldr	r3, [pc, #368]	; (800be90 <HAL_DMA_IRQHandler+0x1d7c>)
 800bd20:	4299      	cmp	r1, r3
 800bd22:	d014      	beq.n	800bd4e <HAL_DMA_IRQHandler+0x1c3a>
 800bd24:	687b      	ldr	r3, [r7, #4]
 800bd26:	681b      	ldr	r3, [r3, #0]
 800bd28:	4619      	mov	r1, r3
 800bd2a:	4b5a      	ldr	r3, [pc, #360]	; (800be94 <HAL_DMA_IRQHandler+0x1d80>)
 800bd2c:	4299      	cmp	r1, r3
 800bd2e:	d00b      	beq.n	800bd48 <HAL_DMA_IRQHandler+0x1c34>
 800bd30:	687b      	ldr	r3, [r7, #4]
 800bd32:	681b      	ldr	r3, [r3, #0]
 800bd34:	4619      	mov	r1, r3
 800bd36:	4b58      	ldr	r3, [pc, #352]	; (800be98 <HAL_DMA_IRQHandler+0x1d84>)
 800bd38:	4299      	cmp	r1, r3
 800bd3a:	d102      	bne.n	800bd42 <HAL_DMA_IRQHandler+0x1c2e>
 800bd3c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bd40:	e01e      	b.n	800bd80 <HAL_DMA_IRQHandler+0x1c6c>
 800bd42:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800bd46:	e01b      	b.n	800bd80 <HAL_DMA_IRQHandler+0x1c6c>
 800bd48:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bd4c:	e018      	b.n	800bd80 <HAL_DMA_IRQHandler+0x1c6c>
 800bd4e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bd52:	e015      	b.n	800bd80 <HAL_DMA_IRQHandler+0x1c6c>
 800bd54:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bd58:	e012      	b.n	800bd80 <HAL_DMA_IRQHandler+0x1c6c>
 800bd5a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bd5e:	e00f      	b.n	800bd80 <HAL_DMA_IRQHandler+0x1c6c>
 800bd60:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bd64:	e00c      	b.n	800bd80 <HAL_DMA_IRQHandler+0x1c6c>
 800bd66:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bd6a:	e009      	b.n	800bd80 <HAL_DMA_IRQHandler+0x1c6c>
 800bd6c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bd70:	e006      	b.n	800bd80 <HAL_DMA_IRQHandler+0x1c6c>
 800bd72:	2310      	movs	r3, #16
 800bd74:	e004      	b.n	800bd80 <HAL_DMA_IRQHandler+0x1c6c>
 800bd76:	2310      	movs	r3, #16
 800bd78:	e002      	b.n	800bd80 <HAL_DMA_IRQHandler+0x1c6c>
 800bd7a:	2310      	movs	r3, #16
 800bd7c:	e000      	b.n	800bd80 <HAL_DMA_IRQHandler+0x1c6c>
 800bd7e:	2310      	movs	r3, #16
 800bd80:	4013      	ands	r3, r2
 800bd82:	2b00      	cmp	r3, #0
 800bd84:	bf14      	ite	ne
 800bd86:	2301      	movne	r3, #1
 800bd88:	2300      	moveq	r3, #0
 800bd8a:	b2db      	uxtb	r3, r3
 800bd8c:	e08d      	b.n	800beaa <HAL_DMA_IRQHandler+0x1d96>
 800bd8e:	4b36      	ldr	r3, [pc, #216]	; (800be68 <HAL_DMA_IRQHandler+0x1d54>)
 800bd90:	681a      	ldr	r2, [r3, #0]
 800bd92:	687b      	ldr	r3, [r7, #4]
 800bd94:	681b      	ldr	r3, [r3, #0]
 800bd96:	4619      	mov	r1, r3
 800bd98:	4b34      	ldr	r3, [pc, #208]	; (800be6c <HAL_DMA_IRQHandler+0x1d58>)
 800bd9a:	4299      	cmp	r1, r3
 800bd9c:	d07e      	beq.n	800be9c <HAL_DMA_IRQHandler+0x1d88>
 800bd9e:	687b      	ldr	r3, [r7, #4]
 800bda0:	681b      	ldr	r3, [r3, #0]
 800bda2:	4619      	mov	r1, r3
 800bda4:	4b32      	ldr	r3, [pc, #200]	; (800be70 <HAL_DMA_IRQHandler+0x1d5c>)
 800bda6:	4299      	cmp	r1, r3
 800bda8:	d05a      	beq.n	800be60 <HAL_DMA_IRQHandler+0x1d4c>
 800bdaa:	687b      	ldr	r3, [r7, #4]
 800bdac:	681b      	ldr	r3, [r3, #0]
 800bdae:	4619      	mov	r1, r3
 800bdb0:	4b30      	ldr	r3, [pc, #192]	; (800be74 <HAL_DMA_IRQHandler+0x1d60>)
 800bdb2:	4299      	cmp	r1, r3
 800bdb4:	d052      	beq.n	800be5c <HAL_DMA_IRQHandler+0x1d48>
 800bdb6:	687b      	ldr	r3, [r7, #4]
 800bdb8:	681b      	ldr	r3, [r3, #0]
 800bdba:	4619      	mov	r1, r3
 800bdbc:	4b2e      	ldr	r3, [pc, #184]	; (800be78 <HAL_DMA_IRQHandler+0x1d64>)
 800bdbe:	4299      	cmp	r1, r3
 800bdc0:	d04a      	beq.n	800be58 <HAL_DMA_IRQHandler+0x1d44>
 800bdc2:	687b      	ldr	r3, [r7, #4]
 800bdc4:	681b      	ldr	r3, [r3, #0]
 800bdc6:	4619      	mov	r1, r3
 800bdc8:	4b2c      	ldr	r3, [pc, #176]	; (800be7c <HAL_DMA_IRQHandler+0x1d68>)
 800bdca:	4299      	cmp	r1, r3
 800bdcc:	d041      	beq.n	800be52 <HAL_DMA_IRQHandler+0x1d3e>
 800bdce:	687b      	ldr	r3, [r7, #4]
 800bdd0:	681b      	ldr	r3, [r3, #0]
 800bdd2:	4619      	mov	r1, r3
 800bdd4:	4b2a      	ldr	r3, [pc, #168]	; (800be80 <HAL_DMA_IRQHandler+0x1d6c>)
 800bdd6:	4299      	cmp	r1, r3
 800bdd8:	d038      	beq.n	800be4c <HAL_DMA_IRQHandler+0x1d38>
 800bdda:	687b      	ldr	r3, [r7, #4]
 800bddc:	681b      	ldr	r3, [r3, #0]
 800bdde:	4619      	mov	r1, r3
 800bde0:	4b28      	ldr	r3, [pc, #160]	; (800be84 <HAL_DMA_IRQHandler+0x1d70>)
 800bde2:	4299      	cmp	r1, r3
 800bde4:	d02f      	beq.n	800be46 <HAL_DMA_IRQHandler+0x1d32>
 800bde6:	687b      	ldr	r3, [r7, #4]
 800bde8:	681b      	ldr	r3, [r3, #0]
 800bdea:	4619      	mov	r1, r3
 800bdec:	4b26      	ldr	r3, [pc, #152]	; (800be88 <HAL_DMA_IRQHandler+0x1d74>)
 800bdee:	4299      	cmp	r1, r3
 800bdf0:	d026      	beq.n	800be40 <HAL_DMA_IRQHandler+0x1d2c>
 800bdf2:	687b      	ldr	r3, [r7, #4]
 800bdf4:	681b      	ldr	r3, [r3, #0]
 800bdf6:	4619      	mov	r1, r3
 800bdf8:	4b24      	ldr	r3, [pc, #144]	; (800be8c <HAL_DMA_IRQHandler+0x1d78>)
 800bdfa:	4299      	cmp	r1, r3
 800bdfc:	d01d      	beq.n	800be3a <HAL_DMA_IRQHandler+0x1d26>
 800bdfe:	687b      	ldr	r3, [r7, #4]
 800be00:	681b      	ldr	r3, [r3, #0]
 800be02:	4619      	mov	r1, r3
 800be04:	4b22      	ldr	r3, [pc, #136]	; (800be90 <HAL_DMA_IRQHandler+0x1d7c>)
 800be06:	4299      	cmp	r1, r3
 800be08:	d014      	beq.n	800be34 <HAL_DMA_IRQHandler+0x1d20>
 800be0a:	687b      	ldr	r3, [r7, #4]
 800be0c:	681b      	ldr	r3, [r3, #0]
 800be0e:	4619      	mov	r1, r3
 800be10:	4b20      	ldr	r3, [pc, #128]	; (800be94 <HAL_DMA_IRQHandler+0x1d80>)
 800be12:	4299      	cmp	r1, r3
 800be14:	d00b      	beq.n	800be2e <HAL_DMA_IRQHandler+0x1d1a>
 800be16:	687b      	ldr	r3, [r7, #4]
 800be18:	681b      	ldr	r3, [r3, #0]
 800be1a:	4619      	mov	r1, r3
 800be1c:	4b1e      	ldr	r3, [pc, #120]	; (800be98 <HAL_DMA_IRQHandler+0x1d84>)
 800be1e:	4299      	cmp	r1, r3
 800be20:	d102      	bne.n	800be28 <HAL_DMA_IRQHandler+0x1d14>
 800be22:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800be26:	e03a      	b.n	800be9e <HAL_DMA_IRQHandler+0x1d8a>
 800be28:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800be2c:	e037      	b.n	800be9e <HAL_DMA_IRQHandler+0x1d8a>
 800be2e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800be32:	e034      	b.n	800be9e <HAL_DMA_IRQHandler+0x1d8a>
 800be34:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800be38:	e031      	b.n	800be9e <HAL_DMA_IRQHandler+0x1d8a>
 800be3a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800be3e:	e02e      	b.n	800be9e <HAL_DMA_IRQHandler+0x1d8a>
 800be40:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800be44:	e02b      	b.n	800be9e <HAL_DMA_IRQHandler+0x1d8a>
 800be46:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800be4a:	e028      	b.n	800be9e <HAL_DMA_IRQHandler+0x1d8a>
 800be4c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800be50:	e025      	b.n	800be9e <HAL_DMA_IRQHandler+0x1d8a>
 800be52:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800be56:	e022      	b.n	800be9e <HAL_DMA_IRQHandler+0x1d8a>
 800be58:	2310      	movs	r3, #16
 800be5a:	e020      	b.n	800be9e <HAL_DMA_IRQHandler+0x1d8a>
 800be5c:	2310      	movs	r3, #16
 800be5e:	e01e      	b.n	800be9e <HAL_DMA_IRQHandler+0x1d8a>
 800be60:	2310      	movs	r3, #16
 800be62:	e01c      	b.n	800be9e <HAL_DMA_IRQHandler+0x1d8a>
 800be64:	40026058 	.word	0x40026058
 800be68:	40026000 	.word	0x40026000
 800be6c:	40026010 	.word	0x40026010
 800be70:	40026410 	.word	0x40026410
 800be74:	40026070 	.word	0x40026070
 800be78:	40026470 	.word	0x40026470
 800be7c:	40026028 	.word	0x40026028
 800be80:	40026428 	.word	0x40026428
 800be84:	40026088 	.word	0x40026088
 800be88:	40026488 	.word	0x40026488
 800be8c:	40026040 	.word	0x40026040
 800be90:	40026440 	.word	0x40026440
 800be94:	400260a0 	.word	0x400260a0
 800be98:	400264a0 	.word	0x400264a0
 800be9c:	2310      	movs	r3, #16
 800be9e:	4013      	ands	r3, r2
 800bea0:	2b00      	cmp	r3, #0
 800bea2:	bf14      	ite	ne
 800bea4:	2301      	movne	r3, #1
 800bea6:	2300      	moveq	r3, #0
 800bea8:	b2db      	uxtb	r3, r3
 800beaa:	2b00      	cmp	r3, #0
 800beac:	f000 8433 	beq.w	800c716 <HAL_DMA_IRQHandler+0x2602>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 800beb0:	687b      	ldr	r3, [r7, #4]
 800beb2:	681b      	ldr	r3, [r3, #0]
 800beb4:	681b      	ldr	r3, [r3, #0]
 800beb6:	f003 0308 	and.w	r3, r3, #8
 800beba:	2b00      	cmp	r3, #0
 800bebc:	f000 842b 	beq.w	800c716 <HAL_DMA_IRQHandler+0x2602>
    { 
      /* Multi_Buffering mode enabled */
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
 800bec0:	687b      	ldr	r3, [r7, #4]
 800bec2:	681b      	ldr	r3, [r3, #0]
 800bec4:	681b      	ldr	r3, [r3, #0]
 800bec6:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800beca:	2b00      	cmp	r3, #0
 800becc:	f000 8203 	beq.w	800c2d6 <HAL_DMA_IRQHandler+0x21c2>
      {
        /* Clear the half transfer complete flag */
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 800bed0:	687b      	ldr	r3, [r7, #4]
 800bed2:	681b      	ldr	r3, [r3, #0]
 800bed4:	461a      	mov	r2, r3
 800bed6:	4ba0      	ldr	r3, [pc, #640]	; (800c158 <HAL_DMA_IRQHandler+0x2044>)
 800bed8:	429a      	cmp	r2, r3
 800beda:	d96c      	bls.n	800bfb6 <HAL_DMA_IRQHandler+0x1ea2>
 800bedc:	4a9f      	ldr	r2, [pc, #636]	; (800c15c <HAL_DMA_IRQHandler+0x2048>)
 800bede:	687b      	ldr	r3, [r7, #4]
 800bee0:	681b      	ldr	r3, [r3, #0]
 800bee2:	4619      	mov	r1, r3
 800bee4:	4b9e      	ldr	r3, [pc, #632]	; (800c160 <HAL_DMA_IRQHandler+0x204c>)
 800bee6:	4299      	cmp	r1, r3
 800bee8:	d062      	beq.n	800bfb0 <HAL_DMA_IRQHandler+0x1e9c>
 800beea:	687b      	ldr	r3, [r7, #4]
 800beec:	681b      	ldr	r3, [r3, #0]
 800beee:	4619      	mov	r1, r3
 800bef0:	4b9c      	ldr	r3, [pc, #624]	; (800c164 <HAL_DMA_IRQHandler+0x2050>)
 800bef2:	4299      	cmp	r1, r3
 800bef4:	d05a      	beq.n	800bfac <HAL_DMA_IRQHandler+0x1e98>
 800bef6:	687b      	ldr	r3, [r7, #4]
 800bef8:	681b      	ldr	r3, [r3, #0]
 800befa:	4619      	mov	r1, r3
 800befc:	4b9a      	ldr	r3, [pc, #616]	; (800c168 <HAL_DMA_IRQHandler+0x2054>)
 800befe:	4299      	cmp	r1, r3
 800bf00:	d052      	beq.n	800bfa8 <HAL_DMA_IRQHandler+0x1e94>
 800bf02:	687b      	ldr	r3, [r7, #4]
 800bf04:	681b      	ldr	r3, [r3, #0]
 800bf06:	4619      	mov	r1, r3
 800bf08:	4b98      	ldr	r3, [pc, #608]	; (800c16c <HAL_DMA_IRQHandler+0x2058>)
 800bf0a:	4299      	cmp	r1, r3
 800bf0c:	d04a      	beq.n	800bfa4 <HAL_DMA_IRQHandler+0x1e90>
 800bf0e:	687b      	ldr	r3, [r7, #4]
 800bf10:	681b      	ldr	r3, [r3, #0]
 800bf12:	4619      	mov	r1, r3
 800bf14:	4b96      	ldr	r3, [pc, #600]	; (800c170 <HAL_DMA_IRQHandler+0x205c>)
 800bf16:	4299      	cmp	r1, r3
 800bf18:	d041      	beq.n	800bf9e <HAL_DMA_IRQHandler+0x1e8a>
 800bf1a:	687b      	ldr	r3, [r7, #4]
 800bf1c:	681b      	ldr	r3, [r3, #0]
 800bf1e:	4619      	mov	r1, r3
 800bf20:	4b94      	ldr	r3, [pc, #592]	; (800c174 <HAL_DMA_IRQHandler+0x2060>)
 800bf22:	4299      	cmp	r1, r3
 800bf24:	d038      	beq.n	800bf98 <HAL_DMA_IRQHandler+0x1e84>
 800bf26:	687b      	ldr	r3, [r7, #4]
 800bf28:	681b      	ldr	r3, [r3, #0]
 800bf2a:	4619      	mov	r1, r3
 800bf2c:	4b92      	ldr	r3, [pc, #584]	; (800c178 <HAL_DMA_IRQHandler+0x2064>)
 800bf2e:	4299      	cmp	r1, r3
 800bf30:	d02f      	beq.n	800bf92 <HAL_DMA_IRQHandler+0x1e7e>
 800bf32:	687b      	ldr	r3, [r7, #4]
 800bf34:	681b      	ldr	r3, [r3, #0]
 800bf36:	4619      	mov	r1, r3
 800bf38:	4b90      	ldr	r3, [pc, #576]	; (800c17c <HAL_DMA_IRQHandler+0x2068>)
 800bf3a:	4299      	cmp	r1, r3
 800bf3c:	d026      	beq.n	800bf8c <HAL_DMA_IRQHandler+0x1e78>
 800bf3e:	687b      	ldr	r3, [r7, #4]
 800bf40:	681b      	ldr	r3, [r3, #0]
 800bf42:	4619      	mov	r1, r3
 800bf44:	4b8e      	ldr	r3, [pc, #568]	; (800c180 <HAL_DMA_IRQHandler+0x206c>)
 800bf46:	4299      	cmp	r1, r3
 800bf48:	d01d      	beq.n	800bf86 <HAL_DMA_IRQHandler+0x1e72>
 800bf4a:	687b      	ldr	r3, [r7, #4]
 800bf4c:	681b      	ldr	r3, [r3, #0]
 800bf4e:	4619      	mov	r1, r3
 800bf50:	4b8c      	ldr	r3, [pc, #560]	; (800c184 <HAL_DMA_IRQHandler+0x2070>)
 800bf52:	4299      	cmp	r1, r3
 800bf54:	d014      	beq.n	800bf80 <HAL_DMA_IRQHandler+0x1e6c>
 800bf56:	687b      	ldr	r3, [r7, #4]
 800bf58:	681b      	ldr	r3, [r3, #0]
 800bf5a:	4619      	mov	r1, r3
 800bf5c:	4b8a      	ldr	r3, [pc, #552]	; (800c188 <HAL_DMA_IRQHandler+0x2074>)
 800bf5e:	4299      	cmp	r1, r3
 800bf60:	d00b      	beq.n	800bf7a <HAL_DMA_IRQHandler+0x1e66>
 800bf62:	687b      	ldr	r3, [r7, #4]
 800bf64:	681b      	ldr	r3, [r3, #0]
 800bf66:	4619      	mov	r1, r3
 800bf68:	4b88      	ldr	r3, [pc, #544]	; (800c18c <HAL_DMA_IRQHandler+0x2078>)
 800bf6a:	4299      	cmp	r1, r3
 800bf6c:	d102      	bne.n	800bf74 <HAL_DMA_IRQHandler+0x1e60>
 800bf6e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bf72:	e01e      	b.n	800bfb2 <HAL_DMA_IRQHandler+0x1e9e>
 800bf74:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800bf78:	e01b      	b.n	800bfb2 <HAL_DMA_IRQHandler+0x1e9e>
 800bf7a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bf7e:	e018      	b.n	800bfb2 <HAL_DMA_IRQHandler+0x1e9e>
 800bf80:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bf84:	e015      	b.n	800bfb2 <HAL_DMA_IRQHandler+0x1e9e>
 800bf86:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bf8a:	e012      	b.n	800bfb2 <HAL_DMA_IRQHandler+0x1e9e>
 800bf8c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bf90:	e00f      	b.n	800bfb2 <HAL_DMA_IRQHandler+0x1e9e>
 800bf92:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bf96:	e00c      	b.n	800bfb2 <HAL_DMA_IRQHandler+0x1e9e>
 800bf98:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bf9c:	e009      	b.n	800bfb2 <HAL_DMA_IRQHandler+0x1e9e>
 800bf9e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bfa2:	e006      	b.n	800bfb2 <HAL_DMA_IRQHandler+0x1e9e>
 800bfa4:	2310      	movs	r3, #16
 800bfa6:	e004      	b.n	800bfb2 <HAL_DMA_IRQHandler+0x1e9e>
 800bfa8:	2310      	movs	r3, #16
 800bfaa:	e002      	b.n	800bfb2 <HAL_DMA_IRQHandler+0x1e9e>
 800bfac:	2310      	movs	r3, #16
 800bfae:	e000      	b.n	800bfb2 <HAL_DMA_IRQHandler+0x1e9e>
 800bfb0:	2310      	movs	r3, #16
 800bfb2:	60d3      	str	r3, [r2, #12]
 800bfb4:	e176      	b.n	800c2a4 <HAL_DMA_IRQHandler+0x2190>
 800bfb6:	687b      	ldr	r3, [r7, #4]
 800bfb8:	681b      	ldr	r3, [r3, #0]
 800bfba:	461a      	mov	r2, r3
 800bfbc:	4b74      	ldr	r3, [pc, #464]	; (800c190 <HAL_DMA_IRQHandler+0x207c>)
 800bfbe:	429a      	cmp	r2, r3
 800bfc0:	d96c      	bls.n	800c09c <HAL_DMA_IRQHandler+0x1f88>
 800bfc2:	4a66      	ldr	r2, [pc, #408]	; (800c15c <HAL_DMA_IRQHandler+0x2048>)
 800bfc4:	687b      	ldr	r3, [r7, #4]
 800bfc6:	681b      	ldr	r3, [r3, #0]
 800bfc8:	4619      	mov	r1, r3
 800bfca:	4b65      	ldr	r3, [pc, #404]	; (800c160 <HAL_DMA_IRQHandler+0x204c>)
 800bfcc:	4299      	cmp	r1, r3
 800bfce:	d062      	beq.n	800c096 <HAL_DMA_IRQHandler+0x1f82>
 800bfd0:	687b      	ldr	r3, [r7, #4]
 800bfd2:	681b      	ldr	r3, [r3, #0]
 800bfd4:	4619      	mov	r1, r3
 800bfd6:	4b63      	ldr	r3, [pc, #396]	; (800c164 <HAL_DMA_IRQHandler+0x2050>)
 800bfd8:	4299      	cmp	r1, r3
 800bfda:	d05a      	beq.n	800c092 <HAL_DMA_IRQHandler+0x1f7e>
 800bfdc:	687b      	ldr	r3, [r7, #4]
 800bfde:	681b      	ldr	r3, [r3, #0]
 800bfe0:	4619      	mov	r1, r3
 800bfe2:	4b61      	ldr	r3, [pc, #388]	; (800c168 <HAL_DMA_IRQHandler+0x2054>)
 800bfe4:	4299      	cmp	r1, r3
 800bfe6:	d052      	beq.n	800c08e <HAL_DMA_IRQHandler+0x1f7a>
 800bfe8:	687b      	ldr	r3, [r7, #4]
 800bfea:	681b      	ldr	r3, [r3, #0]
 800bfec:	4619      	mov	r1, r3
 800bfee:	4b5f      	ldr	r3, [pc, #380]	; (800c16c <HAL_DMA_IRQHandler+0x2058>)
 800bff0:	4299      	cmp	r1, r3
 800bff2:	d04a      	beq.n	800c08a <HAL_DMA_IRQHandler+0x1f76>
 800bff4:	687b      	ldr	r3, [r7, #4]
 800bff6:	681b      	ldr	r3, [r3, #0]
 800bff8:	4619      	mov	r1, r3
 800bffa:	4b5d      	ldr	r3, [pc, #372]	; (800c170 <HAL_DMA_IRQHandler+0x205c>)
 800bffc:	4299      	cmp	r1, r3
 800bffe:	d041      	beq.n	800c084 <HAL_DMA_IRQHandler+0x1f70>
 800c000:	687b      	ldr	r3, [r7, #4]
 800c002:	681b      	ldr	r3, [r3, #0]
 800c004:	4619      	mov	r1, r3
 800c006:	4b5b      	ldr	r3, [pc, #364]	; (800c174 <HAL_DMA_IRQHandler+0x2060>)
 800c008:	4299      	cmp	r1, r3
 800c00a:	d038      	beq.n	800c07e <HAL_DMA_IRQHandler+0x1f6a>
 800c00c:	687b      	ldr	r3, [r7, #4]
 800c00e:	681b      	ldr	r3, [r3, #0]
 800c010:	4619      	mov	r1, r3
 800c012:	4b59      	ldr	r3, [pc, #356]	; (800c178 <HAL_DMA_IRQHandler+0x2064>)
 800c014:	4299      	cmp	r1, r3
 800c016:	d02f      	beq.n	800c078 <HAL_DMA_IRQHandler+0x1f64>
 800c018:	687b      	ldr	r3, [r7, #4]
 800c01a:	681b      	ldr	r3, [r3, #0]
 800c01c:	4619      	mov	r1, r3
 800c01e:	4b57      	ldr	r3, [pc, #348]	; (800c17c <HAL_DMA_IRQHandler+0x2068>)
 800c020:	4299      	cmp	r1, r3
 800c022:	d026      	beq.n	800c072 <HAL_DMA_IRQHandler+0x1f5e>
 800c024:	687b      	ldr	r3, [r7, #4]
 800c026:	681b      	ldr	r3, [r3, #0]
 800c028:	4619      	mov	r1, r3
 800c02a:	4b55      	ldr	r3, [pc, #340]	; (800c180 <HAL_DMA_IRQHandler+0x206c>)
 800c02c:	4299      	cmp	r1, r3
 800c02e:	d01d      	beq.n	800c06c <HAL_DMA_IRQHandler+0x1f58>
 800c030:	687b      	ldr	r3, [r7, #4]
 800c032:	681b      	ldr	r3, [r3, #0]
 800c034:	4619      	mov	r1, r3
 800c036:	4b53      	ldr	r3, [pc, #332]	; (800c184 <HAL_DMA_IRQHandler+0x2070>)
 800c038:	4299      	cmp	r1, r3
 800c03a:	d014      	beq.n	800c066 <HAL_DMA_IRQHandler+0x1f52>
 800c03c:	687b      	ldr	r3, [r7, #4]
 800c03e:	681b      	ldr	r3, [r3, #0]
 800c040:	4619      	mov	r1, r3
 800c042:	4b51      	ldr	r3, [pc, #324]	; (800c188 <HAL_DMA_IRQHandler+0x2074>)
 800c044:	4299      	cmp	r1, r3
 800c046:	d00b      	beq.n	800c060 <HAL_DMA_IRQHandler+0x1f4c>
 800c048:	687b      	ldr	r3, [r7, #4]
 800c04a:	681b      	ldr	r3, [r3, #0]
 800c04c:	4619      	mov	r1, r3
 800c04e:	4b4f      	ldr	r3, [pc, #316]	; (800c18c <HAL_DMA_IRQHandler+0x2078>)
 800c050:	4299      	cmp	r1, r3
 800c052:	d102      	bne.n	800c05a <HAL_DMA_IRQHandler+0x1f46>
 800c054:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c058:	e01e      	b.n	800c098 <HAL_DMA_IRQHandler+0x1f84>
 800c05a:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800c05e:	e01b      	b.n	800c098 <HAL_DMA_IRQHandler+0x1f84>
 800c060:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c064:	e018      	b.n	800c098 <HAL_DMA_IRQHandler+0x1f84>
 800c066:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c06a:	e015      	b.n	800c098 <HAL_DMA_IRQHandler+0x1f84>
 800c06c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c070:	e012      	b.n	800c098 <HAL_DMA_IRQHandler+0x1f84>
 800c072:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c076:	e00f      	b.n	800c098 <HAL_DMA_IRQHandler+0x1f84>
 800c078:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c07c:	e00c      	b.n	800c098 <HAL_DMA_IRQHandler+0x1f84>
 800c07e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c082:	e009      	b.n	800c098 <HAL_DMA_IRQHandler+0x1f84>
 800c084:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c088:	e006      	b.n	800c098 <HAL_DMA_IRQHandler+0x1f84>
 800c08a:	2310      	movs	r3, #16
 800c08c:	e004      	b.n	800c098 <HAL_DMA_IRQHandler+0x1f84>
 800c08e:	2310      	movs	r3, #16
 800c090:	e002      	b.n	800c098 <HAL_DMA_IRQHandler+0x1f84>
 800c092:	2310      	movs	r3, #16
 800c094:	e000      	b.n	800c098 <HAL_DMA_IRQHandler+0x1f84>
 800c096:	2310      	movs	r3, #16
 800c098:	6093      	str	r3, [r2, #8]
 800c09a:	e103      	b.n	800c2a4 <HAL_DMA_IRQHandler+0x2190>
 800c09c:	687b      	ldr	r3, [r7, #4]
 800c09e:	681b      	ldr	r3, [r3, #0]
 800c0a0:	461a      	mov	r2, r3
 800c0a2:	4b3c      	ldr	r3, [pc, #240]	; (800c194 <HAL_DMA_IRQHandler+0x2080>)
 800c0a4:	429a      	cmp	r2, r3
 800c0a6:	f240 8091 	bls.w	800c1cc <HAL_DMA_IRQHandler+0x20b8>
 800c0aa:	4a3b      	ldr	r2, [pc, #236]	; (800c198 <HAL_DMA_IRQHandler+0x2084>)
 800c0ac:	687b      	ldr	r3, [r7, #4]
 800c0ae:	681b      	ldr	r3, [r3, #0]
 800c0b0:	4619      	mov	r1, r3
 800c0b2:	4b2b      	ldr	r3, [pc, #172]	; (800c160 <HAL_DMA_IRQHandler+0x204c>)
 800c0b4:	4299      	cmp	r1, r3
 800c0b6:	f000 8086 	beq.w	800c1c6 <HAL_DMA_IRQHandler+0x20b2>
 800c0ba:	687b      	ldr	r3, [r7, #4]
 800c0bc:	681b      	ldr	r3, [r3, #0]
 800c0be:	4619      	mov	r1, r3
 800c0c0:	4b28      	ldr	r3, [pc, #160]	; (800c164 <HAL_DMA_IRQHandler+0x2050>)
 800c0c2:	4299      	cmp	r1, r3
 800c0c4:	d07d      	beq.n	800c1c2 <HAL_DMA_IRQHandler+0x20ae>
 800c0c6:	687b      	ldr	r3, [r7, #4]
 800c0c8:	681b      	ldr	r3, [r3, #0]
 800c0ca:	4619      	mov	r1, r3
 800c0cc:	4b26      	ldr	r3, [pc, #152]	; (800c168 <HAL_DMA_IRQHandler+0x2054>)
 800c0ce:	4299      	cmp	r1, r3
 800c0d0:	d075      	beq.n	800c1be <HAL_DMA_IRQHandler+0x20aa>
 800c0d2:	687b      	ldr	r3, [r7, #4]
 800c0d4:	681b      	ldr	r3, [r3, #0]
 800c0d6:	4619      	mov	r1, r3
 800c0d8:	4b24      	ldr	r3, [pc, #144]	; (800c16c <HAL_DMA_IRQHandler+0x2058>)
 800c0da:	4299      	cmp	r1, r3
 800c0dc:	d06d      	beq.n	800c1ba <HAL_DMA_IRQHandler+0x20a6>
 800c0de:	687b      	ldr	r3, [r7, #4]
 800c0e0:	681b      	ldr	r3, [r3, #0]
 800c0e2:	4619      	mov	r1, r3
 800c0e4:	4b22      	ldr	r3, [pc, #136]	; (800c170 <HAL_DMA_IRQHandler+0x205c>)
 800c0e6:	4299      	cmp	r1, r3
 800c0e8:	d064      	beq.n	800c1b4 <HAL_DMA_IRQHandler+0x20a0>
 800c0ea:	687b      	ldr	r3, [r7, #4]
 800c0ec:	681b      	ldr	r3, [r3, #0]
 800c0ee:	4619      	mov	r1, r3
 800c0f0:	4b20      	ldr	r3, [pc, #128]	; (800c174 <HAL_DMA_IRQHandler+0x2060>)
 800c0f2:	4299      	cmp	r1, r3
 800c0f4:	d05b      	beq.n	800c1ae <HAL_DMA_IRQHandler+0x209a>
 800c0f6:	687b      	ldr	r3, [r7, #4]
 800c0f8:	681b      	ldr	r3, [r3, #0]
 800c0fa:	4619      	mov	r1, r3
 800c0fc:	4b1e      	ldr	r3, [pc, #120]	; (800c178 <HAL_DMA_IRQHandler+0x2064>)
 800c0fe:	4299      	cmp	r1, r3
 800c100:	d052      	beq.n	800c1a8 <HAL_DMA_IRQHandler+0x2094>
 800c102:	687b      	ldr	r3, [r7, #4]
 800c104:	681b      	ldr	r3, [r3, #0]
 800c106:	4619      	mov	r1, r3
 800c108:	4b1c      	ldr	r3, [pc, #112]	; (800c17c <HAL_DMA_IRQHandler+0x2068>)
 800c10a:	4299      	cmp	r1, r3
 800c10c:	d049      	beq.n	800c1a2 <HAL_DMA_IRQHandler+0x208e>
 800c10e:	687b      	ldr	r3, [r7, #4]
 800c110:	681b      	ldr	r3, [r3, #0]
 800c112:	4619      	mov	r1, r3
 800c114:	4b1a      	ldr	r3, [pc, #104]	; (800c180 <HAL_DMA_IRQHandler+0x206c>)
 800c116:	4299      	cmp	r1, r3
 800c118:	d040      	beq.n	800c19c <HAL_DMA_IRQHandler+0x2088>
 800c11a:	687b      	ldr	r3, [r7, #4]
 800c11c:	681b      	ldr	r3, [r3, #0]
 800c11e:	4619      	mov	r1, r3
 800c120:	4b18      	ldr	r3, [pc, #96]	; (800c184 <HAL_DMA_IRQHandler+0x2070>)
 800c122:	4299      	cmp	r1, r3
 800c124:	d014      	beq.n	800c150 <HAL_DMA_IRQHandler+0x203c>
 800c126:	687b      	ldr	r3, [r7, #4]
 800c128:	681b      	ldr	r3, [r3, #0]
 800c12a:	4619      	mov	r1, r3
 800c12c:	4b16      	ldr	r3, [pc, #88]	; (800c188 <HAL_DMA_IRQHandler+0x2074>)
 800c12e:	4299      	cmp	r1, r3
 800c130:	d00b      	beq.n	800c14a <HAL_DMA_IRQHandler+0x2036>
 800c132:	687b      	ldr	r3, [r7, #4]
 800c134:	681b      	ldr	r3, [r3, #0]
 800c136:	4619      	mov	r1, r3
 800c138:	4b14      	ldr	r3, [pc, #80]	; (800c18c <HAL_DMA_IRQHandler+0x2078>)
 800c13a:	4299      	cmp	r1, r3
 800c13c:	d102      	bne.n	800c144 <HAL_DMA_IRQHandler+0x2030>
 800c13e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c142:	e041      	b.n	800c1c8 <HAL_DMA_IRQHandler+0x20b4>
 800c144:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800c148:	e03e      	b.n	800c1c8 <HAL_DMA_IRQHandler+0x20b4>
 800c14a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c14e:	e03b      	b.n	800c1c8 <HAL_DMA_IRQHandler+0x20b4>
 800c150:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c154:	e038      	b.n	800c1c8 <HAL_DMA_IRQHandler+0x20b4>
 800c156:	bf00      	nop
 800c158:	40026458 	.word	0x40026458
 800c15c:	40026400 	.word	0x40026400
 800c160:	40026010 	.word	0x40026010
 800c164:	40026410 	.word	0x40026410
 800c168:	40026070 	.word	0x40026070
 800c16c:	40026470 	.word	0x40026470
 800c170:	40026028 	.word	0x40026028
 800c174:	40026428 	.word	0x40026428
 800c178:	40026088 	.word	0x40026088
 800c17c:	40026488 	.word	0x40026488
 800c180:	40026040 	.word	0x40026040
 800c184:	40026440 	.word	0x40026440
 800c188:	400260a0 	.word	0x400260a0
 800c18c:	400264a0 	.word	0x400264a0
 800c190:	400260b8 	.word	0x400260b8
 800c194:	40026058 	.word	0x40026058
 800c198:	40026000 	.word	0x40026000
 800c19c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c1a0:	e012      	b.n	800c1c8 <HAL_DMA_IRQHandler+0x20b4>
 800c1a2:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c1a6:	e00f      	b.n	800c1c8 <HAL_DMA_IRQHandler+0x20b4>
 800c1a8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c1ac:	e00c      	b.n	800c1c8 <HAL_DMA_IRQHandler+0x20b4>
 800c1ae:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c1b2:	e009      	b.n	800c1c8 <HAL_DMA_IRQHandler+0x20b4>
 800c1b4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c1b8:	e006      	b.n	800c1c8 <HAL_DMA_IRQHandler+0x20b4>
 800c1ba:	2310      	movs	r3, #16
 800c1bc:	e004      	b.n	800c1c8 <HAL_DMA_IRQHandler+0x20b4>
 800c1be:	2310      	movs	r3, #16
 800c1c0:	e002      	b.n	800c1c8 <HAL_DMA_IRQHandler+0x20b4>
 800c1c2:	2310      	movs	r3, #16
 800c1c4:	e000      	b.n	800c1c8 <HAL_DMA_IRQHandler+0x20b4>
 800c1c6:	2310      	movs	r3, #16
 800c1c8:	60d3      	str	r3, [r2, #12]
 800c1ca:	e06b      	b.n	800c2a4 <HAL_DMA_IRQHandler+0x2190>
 800c1cc:	4a83      	ldr	r2, [pc, #524]	; (800c3dc <HAL_DMA_IRQHandler+0x22c8>)
 800c1ce:	687b      	ldr	r3, [r7, #4]
 800c1d0:	681b      	ldr	r3, [r3, #0]
 800c1d2:	4619      	mov	r1, r3
 800c1d4:	4b82      	ldr	r3, [pc, #520]	; (800c3e0 <HAL_DMA_IRQHandler+0x22cc>)
 800c1d6:	4299      	cmp	r1, r3
 800c1d8:	d062      	beq.n	800c2a0 <HAL_DMA_IRQHandler+0x218c>
 800c1da:	687b      	ldr	r3, [r7, #4]
 800c1dc:	681b      	ldr	r3, [r3, #0]
 800c1de:	4619      	mov	r1, r3
 800c1e0:	4b80      	ldr	r3, [pc, #512]	; (800c3e4 <HAL_DMA_IRQHandler+0x22d0>)
 800c1e2:	4299      	cmp	r1, r3
 800c1e4:	d05a      	beq.n	800c29c <HAL_DMA_IRQHandler+0x2188>
 800c1e6:	687b      	ldr	r3, [r7, #4]
 800c1e8:	681b      	ldr	r3, [r3, #0]
 800c1ea:	4619      	mov	r1, r3
 800c1ec:	4b7e      	ldr	r3, [pc, #504]	; (800c3e8 <HAL_DMA_IRQHandler+0x22d4>)
 800c1ee:	4299      	cmp	r1, r3
 800c1f0:	d052      	beq.n	800c298 <HAL_DMA_IRQHandler+0x2184>
 800c1f2:	687b      	ldr	r3, [r7, #4]
 800c1f4:	681b      	ldr	r3, [r3, #0]
 800c1f6:	4619      	mov	r1, r3
 800c1f8:	4b7c      	ldr	r3, [pc, #496]	; (800c3ec <HAL_DMA_IRQHandler+0x22d8>)
 800c1fa:	4299      	cmp	r1, r3
 800c1fc:	d04a      	beq.n	800c294 <HAL_DMA_IRQHandler+0x2180>
 800c1fe:	687b      	ldr	r3, [r7, #4]
 800c200:	681b      	ldr	r3, [r3, #0]
 800c202:	4619      	mov	r1, r3
 800c204:	4b7a      	ldr	r3, [pc, #488]	; (800c3f0 <HAL_DMA_IRQHandler+0x22dc>)
 800c206:	4299      	cmp	r1, r3
 800c208:	d041      	beq.n	800c28e <HAL_DMA_IRQHandler+0x217a>
 800c20a:	687b      	ldr	r3, [r7, #4]
 800c20c:	681b      	ldr	r3, [r3, #0]
 800c20e:	4619      	mov	r1, r3
 800c210:	4b78      	ldr	r3, [pc, #480]	; (800c3f4 <HAL_DMA_IRQHandler+0x22e0>)
 800c212:	4299      	cmp	r1, r3
 800c214:	d038      	beq.n	800c288 <HAL_DMA_IRQHandler+0x2174>
 800c216:	687b      	ldr	r3, [r7, #4]
 800c218:	681b      	ldr	r3, [r3, #0]
 800c21a:	4619      	mov	r1, r3
 800c21c:	4b76      	ldr	r3, [pc, #472]	; (800c3f8 <HAL_DMA_IRQHandler+0x22e4>)
 800c21e:	4299      	cmp	r1, r3
 800c220:	d02f      	beq.n	800c282 <HAL_DMA_IRQHandler+0x216e>
 800c222:	687b      	ldr	r3, [r7, #4]
 800c224:	681b      	ldr	r3, [r3, #0]
 800c226:	4619      	mov	r1, r3
 800c228:	4b74      	ldr	r3, [pc, #464]	; (800c3fc <HAL_DMA_IRQHandler+0x22e8>)
 800c22a:	4299      	cmp	r1, r3
 800c22c:	d026      	beq.n	800c27c <HAL_DMA_IRQHandler+0x2168>
 800c22e:	687b      	ldr	r3, [r7, #4]
 800c230:	681b      	ldr	r3, [r3, #0]
 800c232:	4619      	mov	r1, r3
 800c234:	4b72      	ldr	r3, [pc, #456]	; (800c400 <HAL_DMA_IRQHandler+0x22ec>)
 800c236:	4299      	cmp	r1, r3
 800c238:	d01d      	beq.n	800c276 <HAL_DMA_IRQHandler+0x2162>
 800c23a:	687b      	ldr	r3, [r7, #4]
 800c23c:	681b      	ldr	r3, [r3, #0]
 800c23e:	4619      	mov	r1, r3
 800c240:	4b70      	ldr	r3, [pc, #448]	; (800c404 <HAL_DMA_IRQHandler+0x22f0>)
 800c242:	4299      	cmp	r1, r3
 800c244:	d014      	beq.n	800c270 <HAL_DMA_IRQHandler+0x215c>
 800c246:	687b      	ldr	r3, [r7, #4]
 800c248:	681b      	ldr	r3, [r3, #0]
 800c24a:	4619      	mov	r1, r3
 800c24c:	4b6e      	ldr	r3, [pc, #440]	; (800c408 <HAL_DMA_IRQHandler+0x22f4>)
 800c24e:	4299      	cmp	r1, r3
 800c250:	d00b      	beq.n	800c26a <HAL_DMA_IRQHandler+0x2156>
 800c252:	687b      	ldr	r3, [r7, #4]
 800c254:	681b      	ldr	r3, [r3, #0]
 800c256:	4619      	mov	r1, r3
 800c258:	4b6c      	ldr	r3, [pc, #432]	; (800c40c <HAL_DMA_IRQHandler+0x22f8>)
 800c25a:	4299      	cmp	r1, r3
 800c25c:	d102      	bne.n	800c264 <HAL_DMA_IRQHandler+0x2150>
 800c25e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c262:	e01e      	b.n	800c2a2 <HAL_DMA_IRQHandler+0x218e>
 800c264:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800c268:	e01b      	b.n	800c2a2 <HAL_DMA_IRQHandler+0x218e>
 800c26a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c26e:	e018      	b.n	800c2a2 <HAL_DMA_IRQHandler+0x218e>
 800c270:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c274:	e015      	b.n	800c2a2 <HAL_DMA_IRQHandler+0x218e>
 800c276:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c27a:	e012      	b.n	800c2a2 <HAL_DMA_IRQHandler+0x218e>
 800c27c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c280:	e00f      	b.n	800c2a2 <HAL_DMA_IRQHandler+0x218e>
 800c282:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c286:	e00c      	b.n	800c2a2 <HAL_DMA_IRQHandler+0x218e>
 800c288:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c28c:	e009      	b.n	800c2a2 <HAL_DMA_IRQHandler+0x218e>
 800c28e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c292:	e006      	b.n	800c2a2 <HAL_DMA_IRQHandler+0x218e>
 800c294:	2310      	movs	r3, #16
 800c296:	e004      	b.n	800c2a2 <HAL_DMA_IRQHandler+0x218e>
 800c298:	2310      	movs	r3, #16
 800c29a:	e002      	b.n	800c2a2 <HAL_DMA_IRQHandler+0x218e>
 800c29c:	2310      	movs	r3, #16
 800c29e:	e000      	b.n	800c2a2 <HAL_DMA_IRQHandler+0x218e>
 800c2a0:	2310      	movs	r3, #16
 800c2a2:	6093      	str	r3, [r2, #8]

        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
 800c2a4:	687b      	ldr	r3, [r7, #4]
 800c2a6:	681b      	ldr	r3, [r3, #0]
 800c2a8:	681b      	ldr	r3, [r3, #0]
 800c2aa:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800c2ae:	2b00      	cmp	r3, #0
 800c2b0:	d104      	bne.n	800c2bc <HAL_DMA_IRQHandler+0x21a8>
        {
          /* Change DMA peripheral state */
          hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
 800c2b2:	687b      	ldr	r3, [r7, #4]
 800c2b4:	2231      	movs	r2, #49	; 0x31
 800c2b6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 800c2ba:	e224      	b.n	800c706 <HAL_DMA_IRQHandler+0x25f2>
        }
        /* Current memory buffer used is Memory 1 */
        else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
 800c2bc:	687b      	ldr	r3, [r7, #4]
 800c2be:	681b      	ldr	r3, [r3, #0]
 800c2c0:	681b      	ldr	r3, [r3, #0]
 800c2c2:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800c2c6:	2b00      	cmp	r3, #0
 800c2c8:	f000 821d 	beq.w	800c706 <HAL_DMA_IRQHandler+0x25f2>
        {
          /* Change DMA peripheral state */
          hdma->State = HAL_DMA_STATE_READY_HALF_MEM1;
 800c2cc:	687b      	ldr	r3, [r7, #4]
 800c2ce:	2241      	movs	r2, #65	; 0x41
 800c2d0:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 800c2d4:	e217      	b.n	800c706 <HAL_DMA_IRQHandler+0x25f2>
        }
      }
      else
      {
        /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 800c2d6:	687b      	ldr	r3, [r7, #4]
 800c2d8:	681b      	ldr	r3, [r3, #0]
 800c2da:	681b      	ldr	r3, [r3, #0]
 800c2dc:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800c2e0:	2b00      	cmp	r3, #0
 800c2e2:	d107      	bne.n	800c2f4 <HAL_DMA_IRQHandler+0x21e0>
        {
          /* Disable the half transfer interrupt */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 800c2e4:	687b      	ldr	r3, [r7, #4]
 800c2e6:	681b      	ldr	r3, [r3, #0]
 800c2e8:	687a      	ldr	r2, [r7, #4]
 800c2ea:	6812      	ldr	r2, [r2, #0]
 800c2ec:	6812      	ldr	r2, [r2, #0]
 800c2ee:	f022 0208 	bic.w	r2, r2, #8
 800c2f2:	601a      	str	r2, [r3, #0]
        }
        /* Clear the half transfer complete flag */
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 800c2f4:	687b      	ldr	r3, [r7, #4]
 800c2f6:	681b      	ldr	r3, [r3, #0]
 800c2f8:	461a      	mov	r2, r3
 800c2fa:	4b45      	ldr	r3, [pc, #276]	; (800c410 <HAL_DMA_IRQHandler+0x22fc>)
 800c2fc:	429a      	cmp	r2, r3
 800c2fe:	f240 808b 	bls.w	800c418 <HAL_DMA_IRQHandler+0x2304>
 800c302:	4a44      	ldr	r2, [pc, #272]	; (800c414 <HAL_DMA_IRQHandler+0x2300>)
 800c304:	687b      	ldr	r3, [r7, #4]
 800c306:	681b      	ldr	r3, [r3, #0]
 800c308:	4619      	mov	r1, r3
 800c30a:	4b35      	ldr	r3, [pc, #212]	; (800c3e0 <HAL_DMA_IRQHandler+0x22cc>)
 800c30c:	4299      	cmp	r1, r3
 800c30e:	d062      	beq.n	800c3d6 <HAL_DMA_IRQHandler+0x22c2>
 800c310:	687b      	ldr	r3, [r7, #4]
 800c312:	681b      	ldr	r3, [r3, #0]
 800c314:	4619      	mov	r1, r3
 800c316:	4b33      	ldr	r3, [pc, #204]	; (800c3e4 <HAL_DMA_IRQHandler+0x22d0>)
 800c318:	4299      	cmp	r1, r3
 800c31a:	d05a      	beq.n	800c3d2 <HAL_DMA_IRQHandler+0x22be>
 800c31c:	687b      	ldr	r3, [r7, #4]
 800c31e:	681b      	ldr	r3, [r3, #0]
 800c320:	4619      	mov	r1, r3
 800c322:	4b31      	ldr	r3, [pc, #196]	; (800c3e8 <HAL_DMA_IRQHandler+0x22d4>)
 800c324:	4299      	cmp	r1, r3
 800c326:	d052      	beq.n	800c3ce <HAL_DMA_IRQHandler+0x22ba>
 800c328:	687b      	ldr	r3, [r7, #4]
 800c32a:	681b      	ldr	r3, [r3, #0]
 800c32c:	4619      	mov	r1, r3
 800c32e:	4b2f      	ldr	r3, [pc, #188]	; (800c3ec <HAL_DMA_IRQHandler+0x22d8>)
 800c330:	4299      	cmp	r1, r3
 800c332:	d04a      	beq.n	800c3ca <HAL_DMA_IRQHandler+0x22b6>
 800c334:	687b      	ldr	r3, [r7, #4]
 800c336:	681b      	ldr	r3, [r3, #0]
 800c338:	4619      	mov	r1, r3
 800c33a:	4b2d      	ldr	r3, [pc, #180]	; (800c3f0 <HAL_DMA_IRQHandler+0x22dc>)
 800c33c:	4299      	cmp	r1, r3
 800c33e:	d041      	beq.n	800c3c4 <HAL_DMA_IRQHandler+0x22b0>
 800c340:	687b      	ldr	r3, [r7, #4]
 800c342:	681b      	ldr	r3, [r3, #0]
 800c344:	4619      	mov	r1, r3
 800c346:	4b2b      	ldr	r3, [pc, #172]	; (800c3f4 <HAL_DMA_IRQHandler+0x22e0>)
 800c348:	4299      	cmp	r1, r3
 800c34a:	d038      	beq.n	800c3be <HAL_DMA_IRQHandler+0x22aa>
 800c34c:	687b      	ldr	r3, [r7, #4]
 800c34e:	681b      	ldr	r3, [r3, #0]
 800c350:	4619      	mov	r1, r3
 800c352:	4b29      	ldr	r3, [pc, #164]	; (800c3f8 <HAL_DMA_IRQHandler+0x22e4>)
 800c354:	4299      	cmp	r1, r3
 800c356:	d02f      	beq.n	800c3b8 <HAL_DMA_IRQHandler+0x22a4>
 800c358:	687b      	ldr	r3, [r7, #4]
 800c35a:	681b      	ldr	r3, [r3, #0]
 800c35c:	4619      	mov	r1, r3
 800c35e:	4b27      	ldr	r3, [pc, #156]	; (800c3fc <HAL_DMA_IRQHandler+0x22e8>)
 800c360:	4299      	cmp	r1, r3
 800c362:	d026      	beq.n	800c3b2 <HAL_DMA_IRQHandler+0x229e>
 800c364:	687b      	ldr	r3, [r7, #4]
 800c366:	681b      	ldr	r3, [r3, #0]
 800c368:	4619      	mov	r1, r3
 800c36a:	4b25      	ldr	r3, [pc, #148]	; (800c400 <HAL_DMA_IRQHandler+0x22ec>)
 800c36c:	4299      	cmp	r1, r3
 800c36e:	d01d      	beq.n	800c3ac <HAL_DMA_IRQHandler+0x2298>
 800c370:	687b      	ldr	r3, [r7, #4]
 800c372:	681b      	ldr	r3, [r3, #0]
 800c374:	4619      	mov	r1, r3
 800c376:	4b23      	ldr	r3, [pc, #140]	; (800c404 <HAL_DMA_IRQHandler+0x22f0>)
 800c378:	4299      	cmp	r1, r3
 800c37a:	d014      	beq.n	800c3a6 <HAL_DMA_IRQHandler+0x2292>
 800c37c:	687b      	ldr	r3, [r7, #4]
 800c37e:	681b      	ldr	r3, [r3, #0]
 800c380:	4619      	mov	r1, r3
 800c382:	4b21      	ldr	r3, [pc, #132]	; (800c408 <HAL_DMA_IRQHandler+0x22f4>)
 800c384:	4299      	cmp	r1, r3
 800c386:	d00b      	beq.n	800c3a0 <HAL_DMA_IRQHandler+0x228c>
 800c388:	687b      	ldr	r3, [r7, #4]
 800c38a:	681b      	ldr	r3, [r3, #0]
 800c38c:	4619      	mov	r1, r3
 800c38e:	4b1f      	ldr	r3, [pc, #124]	; (800c40c <HAL_DMA_IRQHandler+0x22f8>)
 800c390:	4299      	cmp	r1, r3
 800c392:	d102      	bne.n	800c39a <HAL_DMA_IRQHandler+0x2286>
 800c394:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c398:	e01e      	b.n	800c3d8 <HAL_DMA_IRQHandler+0x22c4>
 800c39a:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800c39e:	e01b      	b.n	800c3d8 <HAL_DMA_IRQHandler+0x22c4>
 800c3a0:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c3a4:	e018      	b.n	800c3d8 <HAL_DMA_IRQHandler+0x22c4>
 800c3a6:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c3aa:	e015      	b.n	800c3d8 <HAL_DMA_IRQHandler+0x22c4>
 800c3ac:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c3b0:	e012      	b.n	800c3d8 <HAL_DMA_IRQHandler+0x22c4>
 800c3b2:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c3b6:	e00f      	b.n	800c3d8 <HAL_DMA_IRQHandler+0x22c4>
 800c3b8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c3bc:	e00c      	b.n	800c3d8 <HAL_DMA_IRQHandler+0x22c4>
 800c3be:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c3c2:	e009      	b.n	800c3d8 <HAL_DMA_IRQHandler+0x22c4>
 800c3c4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c3c8:	e006      	b.n	800c3d8 <HAL_DMA_IRQHandler+0x22c4>
 800c3ca:	2310      	movs	r3, #16
 800c3cc:	e004      	b.n	800c3d8 <HAL_DMA_IRQHandler+0x22c4>
 800c3ce:	2310      	movs	r3, #16
 800c3d0:	e002      	b.n	800c3d8 <HAL_DMA_IRQHandler+0x22c4>
 800c3d2:	2310      	movs	r3, #16
 800c3d4:	e000      	b.n	800c3d8 <HAL_DMA_IRQHandler+0x22c4>
 800c3d6:	2310      	movs	r3, #16
 800c3d8:	60d3      	str	r3, [r2, #12]
 800c3da:	e190      	b.n	800c6fe <HAL_DMA_IRQHandler+0x25ea>
 800c3dc:	40026000 	.word	0x40026000
 800c3e0:	40026010 	.word	0x40026010
 800c3e4:	40026410 	.word	0x40026410
 800c3e8:	40026070 	.word	0x40026070
 800c3ec:	40026470 	.word	0x40026470
 800c3f0:	40026028 	.word	0x40026028
 800c3f4:	40026428 	.word	0x40026428
 800c3f8:	40026088 	.word	0x40026088
 800c3fc:	40026488 	.word	0x40026488
 800c400:	40026040 	.word	0x40026040
 800c404:	40026440 	.word	0x40026440
 800c408:	400260a0 	.word	0x400260a0
 800c40c:	400264a0 	.word	0x400264a0
 800c410:	40026458 	.word	0x40026458
 800c414:	40026400 	.word	0x40026400
 800c418:	687b      	ldr	r3, [r7, #4]
 800c41a:	681b      	ldr	r3, [r3, #0]
 800c41c:	461a      	mov	r2, r3
 800c41e:	4b9f      	ldr	r3, [pc, #636]	; (800c69c <HAL_DMA_IRQHandler+0x2588>)
 800c420:	429a      	cmp	r2, r3
 800c422:	d96c      	bls.n	800c4fe <HAL_DMA_IRQHandler+0x23ea>
 800c424:	4a9e      	ldr	r2, [pc, #632]	; (800c6a0 <HAL_DMA_IRQHandler+0x258c>)
 800c426:	687b      	ldr	r3, [r7, #4]
 800c428:	681b      	ldr	r3, [r3, #0]
 800c42a:	4619      	mov	r1, r3
 800c42c:	4b9d      	ldr	r3, [pc, #628]	; (800c6a4 <HAL_DMA_IRQHandler+0x2590>)
 800c42e:	4299      	cmp	r1, r3
 800c430:	d062      	beq.n	800c4f8 <HAL_DMA_IRQHandler+0x23e4>
 800c432:	687b      	ldr	r3, [r7, #4]
 800c434:	681b      	ldr	r3, [r3, #0]
 800c436:	4619      	mov	r1, r3
 800c438:	4b9b      	ldr	r3, [pc, #620]	; (800c6a8 <HAL_DMA_IRQHandler+0x2594>)
 800c43a:	4299      	cmp	r1, r3
 800c43c:	d05a      	beq.n	800c4f4 <HAL_DMA_IRQHandler+0x23e0>
 800c43e:	687b      	ldr	r3, [r7, #4]
 800c440:	681b      	ldr	r3, [r3, #0]
 800c442:	4619      	mov	r1, r3
 800c444:	4b99      	ldr	r3, [pc, #612]	; (800c6ac <HAL_DMA_IRQHandler+0x2598>)
 800c446:	4299      	cmp	r1, r3
 800c448:	d052      	beq.n	800c4f0 <HAL_DMA_IRQHandler+0x23dc>
 800c44a:	687b      	ldr	r3, [r7, #4]
 800c44c:	681b      	ldr	r3, [r3, #0]
 800c44e:	4619      	mov	r1, r3
 800c450:	4b97      	ldr	r3, [pc, #604]	; (800c6b0 <HAL_DMA_IRQHandler+0x259c>)
 800c452:	4299      	cmp	r1, r3
 800c454:	d04a      	beq.n	800c4ec <HAL_DMA_IRQHandler+0x23d8>
 800c456:	687b      	ldr	r3, [r7, #4]
 800c458:	681b      	ldr	r3, [r3, #0]
 800c45a:	4619      	mov	r1, r3
 800c45c:	4b95      	ldr	r3, [pc, #596]	; (800c6b4 <HAL_DMA_IRQHandler+0x25a0>)
 800c45e:	4299      	cmp	r1, r3
 800c460:	d041      	beq.n	800c4e6 <HAL_DMA_IRQHandler+0x23d2>
 800c462:	687b      	ldr	r3, [r7, #4]
 800c464:	681b      	ldr	r3, [r3, #0]
 800c466:	4619      	mov	r1, r3
 800c468:	4b93      	ldr	r3, [pc, #588]	; (800c6b8 <HAL_DMA_IRQHandler+0x25a4>)
 800c46a:	4299      	cmp	r1, r3
 800c46c:	d038      	beq.n	800c4e0 <HAL_DMA_IRQHandler+0x23cc>
 800c46e:	687b      	ldr	r3, [r7, #4]
 800c470:	681b      	ldr	r3, [r3, #0]
 800c472:	4619      	mov	r1, r3
 800c474:	4b91      	ldr	r3, [pc, #580]	; (800c6bc <HAL_DMA_IRQHandler+0x25a8>)
 800c476:	4299      	cmp	r1, r3
 800c478:	d02f      	beq.n	800c4da <HAL_DMA_IRQHandler+0x23c6>
 800c47a:	687b      	ldr	r3, [r7, #4]
 800c47c:	681b      	ldr	r3, [r3, #0]
 800c47e:	4619      	mov	r1, r3
 800c480:	4b8f      	ldr	r3, [pc, #572]	; (800c6c0 <HAL_DMA_IRQHandler+0x25ac>)
 800c482:	4299      	cmp	r1, r3
 800c484:	d026      	beq.n	800c4d4 <HAL_DMA_IRQHandler+0x23c0>
 800c486:	687b      	ldr	r3, [r7, #4]
 800c488:	681b      	ldr	r3, [r3, #0]
 800c48a:	4619      	mov	r1, r3
 800c48c:	4b8d      	ldr	r3, [pc, #564]	; (800c6c4 <HAL_DMA_IRQHandler+0x25b0>)
 800c48e:	4299      	cmp	r1, r3
 800c490:	d01d      	beq.n	800c4ce <HAL_DMA_IRQHandler+0x23ba>
 800c492:	687b      	ldr	r3, [r7, #4]
 800c494:	681b      	ldr	r3, [r3, #0]
 800c496:	4619      	mov	r1, r3
 800c498:	4b8b      	ldr	r3, [pc, #556]	; (800c6c8 <HAL_DMA_IRQHandler+0x25b4>)
 800c49a:	4299      	cmp	r1, r3
 800c49c:	d014      	beq.n	800c4c8 <HAL_DMA_IRQHandler+0x23b4>
 800c49e:	687b      	ldr	r3, [r7, #4]
 800c4a0:	681b      	ldr	r3, [r3, #0]
 800c4a2:	4619      	mov	r1, r3
 800c4a4:	4b89      	ldr	r3, [pc, #548]	; (800c6cc <HAL_DMA_IRQHandler+0x25b8>)
 800c4a6:	4299      	cmp	r1, r3
 800c4a8:	d00b      	beq.n	800c4c2 <HAL_DMA_IRQHandler+0x23ae>
 800c4aa:	687b      	ldr	r3, [r7, #4]
 800c4ac:	681b      	ldr	r3, [r3, #0]
 800c4ae:	4619      	mov	r1, r3
 800c4b0:	4b87      	ldr	r3, [pc, #540]	; (800c6d0 <HAL_DMA_IRQHandler+0x25bc>)
 800c4b2:	4299      	cmp	r1, r3
 800c4b4:	d102      	bne.n	800c4bc <HAL_DMA_IRQHandler+0x23a8>
 800c4b6:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c4ba:	e01e      	b.n	800c4fa <HAL_DMA_IRQHandler+0x23e6>
 800c4bc:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800c4c0:	e01b      	b.n	800c4fa <HAL_DMA_IRQHandler+0x23e6>
 800c4c2:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c4c6:	e018      	b.n	800c4fa <HAL_DMA_IRQHandler+0x23e6>
 800c4c8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c4cc:	e015      	b.n	800c4fa <HAL_DMA_IRQHandler+0x23e6>
 800c4ce:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c4d2:	e012      	b.n	800c4fa <HAL_DMA_IRQHandler+0x23e6>
 800c4d4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c4d8:	e00f      	b.n	800c4fa <HAL_DMA_IRQHandler+0x23e6>
 800c4da:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c4de:	e00c      	b.n	800c4fa <HAL_DMA_IRQHandler+0x23e6>
 800c4e0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c4e4:	e009      	b.n	800c4fa <HAL_DMA_IRQHandler+0x23e6>
 800c4e6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c4ea:	e006      	b.n	800c4fa <HAL_DMA_IRQHandler+0x23e6>
 800c4ec:	2310      	movs	r3, #16
 800c4ee:	e004      	b.n	800c4fa <HAL_DMA_IRQHandler+0x23e6>
 800c4f0:	2310      	movs	r3, #16
 800c4f2:	e002      	b.n	800c4fa <HAL_DMA_IRQHandler+0x23e6>
 800c4f4:	2310      	movs	r3, #16
 800c4f6:	e000      	b.n	800c4fa <HAL_DMA_IRQHandler+0x23e6>
 800c4f8:	2310      	movs	r3, #16
 800c4fa:	6093      	str	r3, [r2, #8]
 800c4fc:	e0ff      	b.n	800c6fe <HAL_DMA_IRQHandler+0x25ea>
 800c4fe:	687b      	ldr	r3, [r7, #4]
 800c500:	681b      	ldr	r3, [r3, #0]
 800c502:	461a      	mov	r2, r3
 800c504:	4b73      	ldr	r3, [pc, #460]	; (800c6d4 <HAL_DMA_IRQHandler+0x25c0>)
 800c506:	429a      	cmp	r2, r3
 800c508:	d96c      	bls.n	800c5e4 <HAL_DMA_IRQHandler+0x24d0>
 800c50a:	4a73      	ldr	r2, [pc, #460]	; (800c6d8 <HAL_DMA_IRQHandler+0x25c4>)
 800c50c:	687b      	ldr	r3, [r7, #4]
 800c50e:	681b      	ldr	r3, [r3, #0]
 800c510:	4619      	mov	r1, r3
 800c512:	4b64      	ldr	r3, [pc, #400]	; (800c6a4 <HAL_DMA_IRQHandler+0x2590>)
 800c514:	4299      	cmp	r1, r3
 800c516:	d062      	beq.n	800c5de <HAL_DMA_IRQHandler+0x24ca>
 800c518:	687b      	ldr	r3, [r7, #4]
 800c51a:	681b      	ldr	r3, [r3, #0]
 800c51c:	4619      	mov	r1, r3
 800c51e:	4b62      	ldr	r3, [pc, #392]	; (800c6a8 <HAL_DMA_IRQHandler+0x2594>)
 800c520:	4299      	cmp	r1, r3
 800c522:	d05a      	beq.n	800c5da <HAL_DMA_IRQHandler+0x24c6>
 800c524:	687b      	ldr	r3, [r7, #4]
 800c526:	681b      	ldr	r3, [r3, #0]
 800c528:	4619      	mov	r1, r3
 800c52a:	4b60      	ldr	r3, [pc, #384]	; (800c6ac <HAL_DMA_IRQHandler+0x2598>)
 800c52c:	4299      	cmp	r1, r3
 800c52e:	d052      	beq.n	800c5d6 <HAL_DMA_IRQHandler+0x24c2>
 800c530:	687b      	ldr	r3, [r7, #4]
 800c532:	681b      	ldr	r3, [r3, #0]
 800c534:	4619      	mov	r1, r3
 800c536:	4b5e      	ldr	r3, [pc, #376]	; (800c6b0 <HAL_DMA_IRQHandler+0x259c>)
 800c538:	4299      	cmp	r1, r3
 800c53a:	d04a      	beq.n	800c5d2 <HAL_DMA_IRQHandler+0x24be>
 800c53c:	687b      	ldr	r3, [r7, #4]
 800c53e:	681b      	ldr	r3, [r3, #0]
 800c540:	4619      	mov	r1, r3
 800c542:	4b5c      	ldr	r3, [pc, #368]	; (800c6b4 <HAL_DMA_IRQHandler+0x25a0>)
 800c544:	4299      	cmp	r1, r3
 800c546:	d041      	beq.n	800c5cc <HAL_DMA_IRQHandler+0x24b8>
 800c548:	687b      	ldr	r3, [r7, #4]
 800c54a:	681b      	ldr	r3, [r3, #0]
 800c54c:	4619      	mov	r1, r3
 800c54e:	4b5a      	ldr	r3, [pc, #360]	; (800c6b8 <HAL_DMA_IRQHandler+0x25a4>)
 800c550:	4299      	cmp	r1, r3
 800c552:	d038      	beq.n	800c5c6 <HAL_DMA_IRQHandler+0x24b2>
 800c554:	687b      	ldr	r3, [r7, #4]
 800c556:	681b      	ldr	r3, [r3, #0]
 800c558:	4619      	mov	r1, r3
 800c55a:	4b58      	ldr	r3, [pc, #352]	; (800c6bc <HAL_DMA_IRQHandler+0x25a8>)
 800c55c:	4299      	cmp	r1, r3
 800c55e:	d02f      	beq.n	800c5c0 <HAL_DMA_IRQHandler+0x24ac>
 800c560:	687b      	ldr	r3, [r7, #4]
 800c562:	681b      	ldr	r3, [r3, #0]
 800c564:	4619      	mov	r1, r3
 800c566:	4b56      	ldr	r3, [pc, #344]	; (800c6c0 <HAL_DMA_IRQHandler+0x25ac>)
 800c568:	4299      	cmp	r1, r3
 800c56a:	d026      	beq.n	800c5ba <HAL_DMA_IRQHandler+0x24a6>
 800c56c:	687b      	ldr	r3, [r7, #4]
 800c56e:	681b      	ldr	r3, [r3, #0]
 800c570:	4619      	mov	r1, r3
 800c572:	4b54      	ldr	r3, [pc, #336]	; (800c6c4 <HAL_DMA_IRQHandler+0x25b0>)
 800c574:	4299      	cmp	r1, r3
 800c576:	d01d      	beq.n	800c5b4 <HAL_DMA_IRQHandler+0x24a0>
 800c578:	687b      	ldr	r3, [r7, #4]
 800c57a:	681b      	ldr	r3, [r3, #0]
 800c57c:	4619      	mov	r1, r3
 800c57e:	4b52      	ldr	r3, [pc, #328]	; (800c6c8 <HAL_DMA_IRQHandler+0x25b4>)
 800c580:	4299      	cmp	r1, r3
 800c582:	d014      	beq.n	800c5ae <HAL_DMA_IRQHandler+0x249a>
 800c584:	687b      	ldr	r3, [r7, #4]
 800c586:	681b      	ldr	r3, [r3, #0]
 800c588:	4619      	mov	r1, r3
 800c58a:	4b50      	ldr	r3, [pc, #320]	; (800c6cc <HAL_DMA_IRQHandler+0x25b8>)
 800c58c:	4299      	cmp	r1, r3
 800c58e:	d00b      	beq.n	800c5a8 <HAL_DMA_IRQHandler+0x2494>
 800c590:	687b      	ldr	r3, [r7, #4]
 800c592:	681b      	ldr	r3, [r3, #0]
 800c594:	4619      	mov	r1, r3
 800c596:	4b4e      	ldr	r3, [pc, #312]	; (800c6d0 <HAL_DMA_IRQHandler+0x25bc>)
 800c598:	4299      	cmp	r1, r3
 800c59a:	d102      	bne.n	800c5a2 <HAL_DMA_IRQHandler+0x248e>
 800c59c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c5a0:	e01e      	b.n	800c5e0 <HAL_DMA_IRQHandler+0x24cc>
 800c5a2:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800c5a6:	e01b      	b.n	800c5e0 <HAL_DMA_IRQHandler+0x24cc>
 800c5a8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c5ac:	e018      	b.n	800c5e0 <HAL_DMA_IRQHandler+0x24cc>
 800c5ae:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c5b2:	e015      	b.n	800c5e0 <HAL_DMA_IRQHandler+0x24cc>
 800c5b4:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c5b8:	e012      	b.n	800c5e0 <HAL_DMA_IRQHandler+0x24cc>
 800c5ba:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c5be:	e00f      	b.n	800c5e0 <HAL_DMA_IRQHandler+0x24cc>
 800c5c0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c5c4:	e00c      	b.n	800c5e0 <HAL_DMA_IRQHandler+0x24cc>
 800c5c6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c5ca:	e009      	b.n	800c5e0 <HAL_DMA_IRQHandler+0x24cc>
 800c5cc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c5d0:	e006      	b.n	800c5e0 <HAL_DMA_IRQHandler+0x24cc>
 800c5d2:	2310      	movs	r3, #16
 800c5d4:	e004      	b.n	800c5e0 <HAL_DMA_IRQHandler+0x24cc>
 800c5d6:	2310      	movs	r3, #16
 800c5d8:	e002      	b.n	800c5e0 <HAL_DMA_IRQHandler+0x24cc>
 800c5da:	2310      	movs	r3, #16
 800c5dc:	e000      	b.n	800c5e0 <HAL_DMA_IRQHandler+0x24cc>
 800c5de:	2310      	movs	r3, #16
 800c5e0:	60d3      	str	r3, [r2, #12]
 800c5e2:	e08c      	b.n	800c6fe <HAL_DMA_IRQHandler+0x25ea>
 800c5e4:	4a3c      	ldr	r2, [pc, #240]	; (800c6d8 <HAL_DMA_IRQHandler+0x25c4>)
 800c5e6:	687b      	ldr	r3, [r7, #4]
 800c5e8:	681b      	ldr	r3, [r3, #0]
 800c5ea:	4619      	mov	r1, r3
 800c5ec:	4b2d      	ldr	r3, [pc, #180]	; (800c6a4 <HAL_DMA_IRQHandler+0x2590>)
 800c5ee:	4299      	cmp	r1, r3
 800c5f0:	f000 8083 	beq.w	800c6fa <HAL_DMA_IRQHandler+0x25e6>
 800c5f4:	687b      	ldr	r3, [r7, #4]
 800c5f6:	681b      	ldr	r3, [r3, #0]
 800c5f8:	4619      	mov	r1, r3
 800c5fa:	4b2b      	ldr	r3, [pc, #172]	; (800c6a8 <HAL_DMA_IRQHandler+0x2594>)
 800c5fc:	4299      	cmp	r1, r3
 800c5fe:	d07a      	beq.n	800c6f6 <HAL_DMA_IRQHandler+0x25e2>
 800c600:	687b      	ldr	r3, [r7, #4]
 800c602:	681b      	ldr	r3, [r3, #0]
 800c604:	4619      	mov	r1, r3
 800c606:	4b29      	ldr	r3, [pc, #164]	; (800c6ac <HAL_DMA_IRQHandler+0x2598>)
 800c608:	4299      	cmp	r1, r3
 800c60a:	d072      	beq.n	800c6f2 <HAL_DMA_IRQHandler+0x25de>
 800c60c:	687b      	ldr	r3, [r7, #4]
 800c60e:	681b      	ldr	r3, [r3, #0]
 800c610:	4619      	mov	r1, r3
 800c612:	4b27      	ldr	r3, [pc, #156]	; (800c6b0 <HAL_DMA_IRQHandler+0x259c>)
 800c614:	4299      	cmp	r1, r3
 800c616:	d06a      	beq.n	800c6ee <HAL_DMA_IRQHandler+0x25da>
 800c618:	687b      	ldr	r3, [r7, #4]
 800c61a:	681b      	ldr	r3, [r3, #0]
 800c61c:	4619      	mov	r1, r3
 800c61e:	4b25      	ldr	r3, [pc, #148]	; (800c6b4 <HAL_DMA_IRQHandler+0x25a0>)
 800c620:	4299      	cmp	r1, r3
 800c622:	d061      	beq.n	800c6e8 <HAL_DMA_IRQHandler+0x25d4>
 800c624:	687b      	ldr	r3, [r7, #4]
 800c626:	681b      	ldr	r3, [r3, #0]
 800c628:	4619      	mov	r1, r3
 800c62a:	4b23      	ldr	r3, [pc, #140]	; (800c6b8 <HAL_DMA_IRQHandler+0x25a4>)
 800c62c:	4299      	cmp	r1, r3
 800c62e:	d058      	beq.n	800c6e2 <HAL_DMA_IRQHandler+0x25ce>
 800c630:	687b      	ldr	r3, [r7, #4]
 800c632:	681b      	ldr	r3, [r3, #0]
 800c634:	4619      	mov	r1, r3
 800c636:	4b21      	ldr	r3, [pc, #132]	; (800c6bc <HAL_DMA_IRQHandler+0x25a8>)
 800c638:	4299      	cmp	r1, r3
 800c63a:	d04f      	beq.n	800c6dc <HAL_DMA_IRQHandler+0x25c8>
 800c63c:	687b      	ldr	r3, [r7, #4]
 800c63e:	681b      	ldr	r3, [r3, #0]
 800c640:	4619      	mov	r1, r3
 800c642:	4b1f      	ldr	r3, [pc, #124]	; (800c6c0 <HAL_DMA_IRQHandler+0x25ac>)
 800c644:	4299      	cmp	r1, r3
 800c646:	d026      	beq.n	800c696 <HAL_DMA_IRQHandler+0x2582>
 800c648:	687b      	ldr	r3, [r7, #4]
 800c64a:	681b      	ldr	r3, [r3, #0]
 800c64c:	4619      	mov	r1, r3
 800c64e:	4b1d      	ldr	r3, [pc, #116]	; (800c6c4 <HAL_DMA_IRQHandler+0x25b0>)
 800c650:	4299      	cmp	r1, r3
 800c652:	d01d      	beq.n	800c690 <HAL_DMA_IRQHandler+0x257c>
 800c654:	687b      	ldr	r3, [r7, #4]
 800c656:	681b      	ldr	r3, [r3, #0]
 800c658:	4619      	mov	r1, r3
 800c65a:	4b1b      	ldr	r3, [pc, #108]	; (800c6c8 <HAL_DMA_IRQHandler+0x25b4>)
 800c65c:	4299      	cmp	r1, r3
 800c65e:	d014      	beq.n	800c68a <HAL_DMA_IRQHandler+0x2576>
 800c660:	687b      	ldr	r3, [r7, #4]
 800c662:	681b      	ldr	r3, [r3, #0]
 800c664:	4619      	mov	r1, r3
 800c666:	4b19      	ldr	r3, [pc, #100]	; (800c6cc <HAL_DMA_IRQHandler+0x25b8>)
 800c668:	4299      	cmp	r1, r3
 800c66a:	d00b      	beq.n	800c684 <HAL_DMA_IRQHandler+0x2570>
 800c66c:	687b      	ldr	r3, [r7, #4]
 800c66e:	681b      	ldr	r3, [r3, #0]
 800c670:	4619      	mov	r1, r3
 800c672:	4b17      	ldr	r3, [pc, #92]	; (800c6d0 <HAL_DMA_IRQHandler+0x25bc>)
 800c674:	4299      	cmp	r1, r3
 800c676:	d102      	bne.n	800c67e <HAL_DMA_IRQHandler+0x256a>
 800c678:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c67c:	e03e      	b.n	800c6fc <HAL_DMA_IRQHandler+0x25e8>
 800c67e:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800c682:	e03b      	b.n	800c6fc <HAL_DMA_IRQHandler+0x25e8>
 800c684:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c688:	e038      	b.n	800c6fc <HAL_DMA_IRQHandler+0x25e8>
 800c68a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c68e:	e035      	b.n	800c6fc <HAL_DMA_IRQHandler+0x25e8>
 800c690:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c694:	e032      	b.n	800c6fc <HAL_DMA_IRQHandler+0x25e8>
 800c696:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c69a:	e02f      	b.n	800c6fc <HAL_DMA_IRQHandler+0x25e8>
 800c69c:	400260b8 	.word	0x400260b8
 800c6a0:	40026400 	.word	0x40026400
 800c6a4:	40026010 	.word	0x40026010
 800c6a8:	40026410 	.word	0x40026410
 800c6ac:	40026070 	.word	0x40026070
 800c6b0:	40026470 	.word	0x40026470
 800c6b4:	40026028 	.word	0x40026028
 800c6b8:	40026428 	.word	0x40026428
 800c6bc:	40026088 	.word	0x40026088
 800c6c0:	40026488 	.word	0x40026488
 800c6c4:	40026040 	.word	0x40026040
 800c6c8:	40026440 	.word	0x40026440
 800c6cc:	400260a0 	.word	0x400260a0
 800c6d0:	400264a0 	.word	0x400264a0
 800c6d4:	40026058 	.word	0x40026058
 800c6d8:	40026000 	.word	0x40026000
 800c6dc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c6e0:	e00c      	b.n	800c6fc <HAL_DMA_IRQHandler+0x25e8>
 800c6e2:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c6e6:	e009      	b.n	800c6fc <HAL_DMA_IRQHandler+0x25e8>
 800c6e8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c6ec:	e006      	b.n	800c6fc <HAL_DMA_IRQHandler+0x25e8>
 800c6ee:	2310      	movs	r3, #16
 800c6f0:	e004      	b.n	800c6fc <HAL_DMA_IRQHandler+0x25e8>
 800c6f2:	2310      	movs	r3, #16
 800c6f4:	e002      	b.n	800c6fc <HAL_DMA_IRQHandler+0x25e8>
 800c6f6:	2310      	movs	r3, #16
 800c6f8:	e000      	b.n	800c6fc <HAL_DMA_IRQHandler+0x25e8>
 800c6fa:	2310      	movs	r3, #16
 800c6fc:	6093      	str	r3, [r2, #8]

        /* Change DMA peripheral state */
        hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
 800c6fe:	687b      	ldr	r3, [r7, #4]
 800c700:	2231      	movs	r2, #49	; 0x31
 800c702:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
      }

      if(hdma->XferHalfCpltCallback != NULL)
 800c706:	687b      	ldr	r3, [r7, #4]
 800c708:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c70a:	2b00      	cmp	r3, #0
 800c70c:	d003      	beq.n	800c716 <HAL_DMA_IRQHandler+0x2602>
      {
        /* Half transfer callback */
        hdma->XferHalfCpltCallback(hdma);
 800c70e:	687b      	ldr	r3, [r7, #4]
 800c710:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c712:	6878      	ldr	r0, [r7, #4]
 800c714:	4798      	blx	r3
      }
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 800c716:	687b      	ldr	r3, [r7, #4]
 800c718:	681b      	ldr	r3, [r3, #0]
 800c71a:	461a      	mov	r2, r3
 800c71c:	4b77      	ldr	r3, [pc, #476]	; (800c8fc <HAL_DMA_IRQHandler+0x27e8>)
 800c71e:	429a      	cmp	r2, r3
 800c720:	d972      	bls.n	800c808 <HAL_DMA_IRQHandler+0x26f4>
 800c722:	4b77      	ldr	r3, [pc, #476]	; (800c900 <HAL_DMA_IRQHandler+0x27ec>)
 800c724:	685a      	ldr	r2, [r3, #4]
 800c726:	687b      	ldr	r3, [r7, #4]
 800c728:	681b      	ldr	r3, [r3, #0]
 800c72a:	4619      	mov	r1, r3
 800c72c:	4b75      	ldr	r3, [pc, #468]	; (800c904 <HAL_DMA_IRQHandler+0x27f0>)
 800c72e:	4299      	cmp	r1, r3
 800c730:	d062      	beq.n	800c7f8 <HAL_DMA_IRQHandler+0x26e4>
 800c732:	687b      	ldr	r3, [r7, #4]
 800c734:	681b      	ldr	r3, [r3, #0]
 800c736:	4619      	mov	r1, r3
 800c738:	4b73      	ldr	r3, [pc, #460]	; (800c908 <HAL_DMA_IRQHandler+0x27f4>)
 800c73a:	4299      	cmp	r1, r3
 800c73c:	d05a      	beq.n	800c7f4 <HAL_DMA_IRQHandler+0x26e0>
 800c73e:	687b      	ldr	r3, [r7, #4]
 800c740:	681b      	ldr	r3, [r3, #0]
 800c742:	4619      	mov	r1, r3
 800c744:	4b71      	ldr	r3, [pc, #452]	; (800c90c <HAL_DMA_IRQHandler+0x27f8>)
 800c746:	4299      	cmp	r1, r3
 800c748:	d052      	beq.n	800c7f0 <HAL_DMA_IRQHandler+0x26dc>
 800c74a:	687b      	ldr	r3, [r7, #4]
 800c74c:	681b      	ldr	r3, [r3, #0]
 800c74e:	4619      	mov	r1, r3
 800c750:	4b6f      	ldr	r3, [pc, #444]	; (800c910 <HAL_DMA_IRQHandler+0x27fc>)
 800c752:	4299      	cmp	r1, r3
 800c754:	d04a      	beq.n	800c7ec <HAL_DMA_IRQHandler+0x26d8>
 800c756:	687b      	ldr	r3, [r7, #4]
 800c758:	681b      	ldr	r3, [r3, #0]
 800c75a:	4619      	mov	r1, r3
 800c75c:	4b6d      	ldr	r3, [pc, #436]	; (800c914 <HAL_DMA_IRQHandler+0x2800>)
 800c75e:	4299      	cmp	r1, r3
 800c760:	d041      	beq.n	800c7e6 <HAL_DMA_IRQHandler+0x26d2>
 800c762:	687b      	ldr	r3, [r7, #4]
 800c764:	681b      	ldr	r3, [r3, #0]
 800c766:	4619      	mov	r1, r3
 800c768:	4b6b      	ldr	r3, [pc, #428]	; (800c918 <HAL_DMA_IRQHandler+0x2804>)
 800c76a:	4299      	cmp	r1, r3
 800c76c:	d038      	beq.n	800c7e0 <HAL_DMA_IRQHandler+0x26cc>
 800c76e:	687b      	ldr	r3, [r7, #4]
 800c770:	681b      	ldr	r3, [r3, #0]
 800c772:	4619      	mov	r1, r3
 800c774:	4b69      	ldr	r3, [pc, #420]	; (800c91c <HAL_DMA_IRQHandler+0x2808>)
 800c776:	4299      	cmp	r1, r3
 800c778:	d02f      	beq.n	800c7da <HAL_DMA_IRQHandler+0x26c6>
 800c77a:	687b      	ldr	r3, [r7, #4]
 800c77c:	681b      	ldr	r3, [r3, #0]
 800c77e:	4619      	mov	r1, r3
 800c780:	4b67      	ldr	r3, [pc, #412]	; (800c920 <HAL_DMA_IRQHandler+0x280c>)
 800c782:	4299      	cmp	r1, r3
 800c784:	d026      	beq.n	800c7d4 <HAL_DMA_IRQHandler+0x26c0>
 800c786:	687b      	ldr	r3, [r7, #4]
 800c788:	681b      	ldr	r3, [r3, #0]
 800c78a:	4619      	mov	r1, r3
 800c78c:	4b65      	ldr	r3, [pc, #404]	; (800c924 <HAL_DMA_IRQHandler+0x2810>)
 800c78e:	4299      	cmp	r1, r3
 800c790:	d01d      	beq.n	800c7ce <HAL_DMA_IRQHandler+0x26ba>
 800c792:	687b      	ldr	r3, [r7, #4]
 800c794:	681b      	ldr	r3, [r3, #0]
 800c796:	4619      	mov	r1, r3
 800c798:	4b63      	ldr	r3, [pc, #396]	; (800c928 <HAL_DMA_IRQHandler+0x2814>)
 800c79a:	4299      	cmp	r1, r3
 800c79c:	d014      	beq.n	800c7c8 <HAL_DMA_IRQHandler+0x26b4>
 800c79e:	687b      	ldr	r3, [r7, #4]
 800c7a0:	681b      	ldr	r3, [r3, #0]
 800c7a2:	4619      	mov	r1, r3
 800c7a4:	4b61      	ldr	r3, [pc, #388]	; (800c92c <HAL_DMA_IRQHandler+0x2818>)
 800c7a6:	4299      	cmp	r1, r3
 800c7a8:	d00b      	beq.n	800c7c2 <HAL_DMA_IRQHandler+0x26ae>
 800c7aa:	687b      	ldr	r3, [r7, #4]
 800c7ac:	681b      	ldr	r3, [r3, #0]
 800c7ae:	4619      	mov	r1, r3
 800c7b0:	4b5f      	ldr	r3, [pc, #380]	; (800c930 <HAL_DMA_IRQHandler+0x281c>)
 800c7b2:	4299      	cmp	r1, r3
 800c7b4:	d102      	bne.n	800c7bc <HAL_DMA_IRQHandler+0x26a8>
 800c7b6:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c7ba:	e01e      	b.n	800c7fa <HAL_DMA_IRQHandler+0x26e6>
 800c7bc:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800c7c0:	e01b      	b.n	800c7fa <HAL_DMA_IRQHandler+0x26e6>
 800c7c2:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c7c6:	e018      	b.n	800c7fa <HAL_DMA_IRQHandler+0x26e6>
 800c7c8:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c7cc:	e015      	b.n	800c7fa <HAL_DMA_IRQHandler+0x26e6>
 800c7ce:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c7d2:	e012      	b.n	800c7fa <HAL_DMA_IRQHandler+0x26e6>
 800c7d4:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c7d8:	e00f      	b.n	800c7fa <HAL_DMA_IRQHandler+0x26e6>
 800c7da:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c7de:	e00c      	b.n	800c7fa <HAL_DMA_IRQHandler+0x26e6>
 800c7e0:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c7e4:	e009      	b.n	800c7fa <HAL_DMA_IRQHandler+0x26e6>
 800c7e6:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c7ea:	e006      	b.n	800c7fa <HAL_DMA_IRQHandler+0x26e6>
 800c7ec:	2320      	movs	r3, #32
 800c7ee:	e004      	b.n	800c7fa <HAL_DMA_IRQHandler+0x26e6>
 800c7f0:	2320      	movs	r3, #32
 800c7f2:	e002      	b.n	800c7fa <HAL_DMA_IRQHandler+0x26e6>
 800c7f4:	2320      	movs	r3, #32
 800c7f6:	e000      	b.n	800c7fa <HAL_DMA_IRQHandler+0x26e6>
 800c7f8:	2320      	movs	r3, #32
 800c7fa:	4013      	ands	r3, r2
 800c7fc:	2b00      	cmp	r3, #0
 800c7fe:	bf14      	ite	ne
 800c800:	2301      	movne	r3, #1
 800c802:	2300      	moveq	r3, #0
 800c804:	b2db      	uxtb	r3, r3
 800c806:	e19e      	b.n	800cb46 <HAL_DMA_IRQHandler+0x2a32>
 800c808:	687b      	ldr	r3, [r7, #4]
 800c80a:	681b      	ldr	r3, [r3, #0]
 800c80c:	461a      	mov	r2, r3
 800c80e:	4b49      	ldr	r3, [pc, #292]	; (800c934 <HAL_DMA_IRQHandler+0x2820>)
 800c810:	429a      	cmp	r2, r3
 800c812:	f240 8091 	bls.w	800c938 <HAL_DMA_IRQHandler+0x2824>
 800c816:	4b3a      	ldr	r3, [pc, #232]	; (800c900 <HAL_DMA_IRQHandler+0x27ec>)
 800c818:	681a      	ldr	r2, [r3, #0]
 800c81a:	687b      	ldr	r3, [r7, #4]
 800c81c:	681b      	ldr	r3, [r3, #0]
 800c81e:	4619      	mov	r1, r3
 800c820:	4b38      	ldr	r3, [pc, #224]	; (800c904 <HAL_DMA_IRQHandler+0x27f0>)
 800c822:	4299      	cmp	r1, r3
 800c824:	d062      	beq.n	800c8ec <HAL_DMA_IRQHandler+0x27d8>
 800c826:	687b      	ldr	r3, [r7, #4]
 800c828:	681b      	ldr	r3, [r3, #0]
 800c82a:	4619      	mov	r1, r3
 800c82c:	4b36      	ldr	r3, [pc, #216]	; (800c908 <HAL_DMA_IRQHandler+0x27f4>)
 800c82e:	4299      	cmp	r1, r3
 800c830:	d05a      	beq.n	800c8e8 <HAL_DMA_IRQHandler+0x27d4>
 800c832:	687b      	ldr	r3, [r7, #4]
 800c834:	681b      	ldr	r3, [r3, #0]
 800c836:	4619      	mov	r1, r3
 800c838:	4b34      	ldr	r3, [pc, #208]	; (800c90c <HAL_DMA_IRQHandler+0x27f8>)
 800c83a:	4299      	cmp	r1, r3
 800c83c:	d052      	beq.n	800c8e4 <HAL_DMA_IRQHandler+0x27d0>
 800c83e:	687b      	ldr	r3, [r7, #4]
 800c840:	681b      	ldr	r3, [r3, #0]
 800c842:	4619      	mov	r1, r3
 800c844:	4b32      	ldr	r3, [pc, #200]	; (800c910 <HAL_DMA_IRQHandler+0x27fc>)
 800c846:	4299      	cmp	r1, r3
 800c848:	d04a      	beq.n	800c8e0 <HAL_DMA_IRQHandler+0x27cc>
 800c84a:	687b      	ldr	r3, [r7, #4]
 800c84c:	681b      	ldr	r3, [r3, #0]
 800c84e:	4619      	mov	r1, r3
 800c850:	4b30      	ldr	r3, [pc, #192]	; (800c914 <HAL_DMA_IRQHandler+0x2800>)
 800c852:	4299      	cmp	r1, r3
 800c854:	d041      	beq.n	800c8da <HAL_DMA_IRQHandler+0x27c6>
 800c856:	687b      	ldr	r3, [r7, #4]
 800c858:	681b      	ldr	r3, [r3, #0]
 800c85a:	4619      	mov	r1, r3
 800c85c:	4b2e      	ldr	r3, [pc, #184]	; (800c918 <HAL_DMA_IRQHandler+0x2804>)
 800c85e:	4299      	cmp	r1, r3
 800c860:	d038      	beq.n	800c8d4 <HAL_DMA_IRQHandler+0x27c0>
 800c862:	687b      	ldr	r3, [r7, #4]
 800c864:	681b      	ldr	r3, [r3, #0]
 800c866:	4619      	mov	r1, r3
 800c868:	4b2c      	ldr	r3, [pc, #176]	; (800c91c <HAL_DMA_IRQHandler+0x2808>)
 800c86a:	4299      	cmp	r1, r3
 800c86c:	d02f      	beq.n	800c8ce <HAL_DMA_IRQHandler+0x27ba>
 800c86e:	687b      	ldr	r3, [r7, #4]
 800c870:	681b      	ldr	r3, [r3, #0]
 800c872:	4619      	mov	r1, r3
 800c874:	4b2a      	ldr	r3, [pc, #168]	; (800c920 <HAL_DMA_IRQHandler+0x280c>)
 800c876:	4299      	cmp	r1, r3
 800c878:	d026      	beq.n	800c8c8 <HAL_DMA_IRQHandler+0x27b4>
 800c87a:	687b      	ldr	r3, [r7, #4]
 800c87c:	681b      	ldr	r3, [r3, #0]
 800c87e:	4619      	mov	r1, r3
 800c880:	4b28      	ldr	r3, [pc, #160]	; (800c924 <HAL_DMA_IRQHandler+0x2810>)
 800c882:	4299      	cmp	r1, r3
 800c884:	d01d      	beq.n	800c8c2 <HAL_DMA_IRQHandler+0x27ae>
 800c886:	687b      	ldr	r3, [r7, #4]
 800c888:	681b      	ldr	r3, [r3, #0]
 800c88a:	4619      	mov	r1, r3
 800c88c:	4b26      	ldr	r3, [pc, #152]	; (800c928 <HAL_DMA_IRQHandler+0x2814>)
 800c88e:	4299      	cmp	r1, r3
 800c890:	d014      	beq.n	800c8bc <HAL_DMA_IRQHandler+0x27a8>
 800c892:	687b      	ldr	r3, [r7, #4]
 800c894:	681b      	ldr	r3, [r3, #0]
 800c896:	4619      	mov	r1, r3
 800c898:	4b24      	ldr	r3, [pc, #144]	; (800c92c <HAL_DMA_IRQHandler+0x2818>)
 800c89a:	4299      	cmp	r1, r3
 800c89c:	d00b      	beq.n	800c8b6 <HAL_DMA_IRQHandler+0x27a2>
 800c89e:	687b      	ldr	r3, [r7, #4]
 800c8a0:	681b      	ldr	r3, [r3, #0]
 800c8a2:	4619      	mov	r1, r3
 800c8a4:	4b22      	ldr	r3, [pc, #136]	; (800c930 <HAL_DMA_IRQHandler+0x281c>)
 800c8a6:	4299      	cmp	r1, r3
 800c8a8:	d102      	bne.n	800c8b0 <HAL_DMA_IRQHandler+0x279c>
 800c8aa:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c8ae:	e01e      	b.n	800c8ee <HAL_DMA_IRQHandler+0x27da>
 800c8b0:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800c8b4:	e01b      	b.n	800c8ee <HAL_DMA_IRQHandler+0x27da>
 800c8b6:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c8ba:	e018      	b.n	800c8ee <HAL_DMA_IRQHandler+0x27da>
 800c8bc:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c8c0:	e015      	b.n	800c8ee <HAL_DMA_IRQHandler+0x27da>
 800c8c2:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c8c6:	e012      	b.n	800c8ee <HAL_DMA_IRQHandler+0x27da>
 800c8c8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c8cc:	e00f      	b.n	800c8ee <HAL_DMA_IRQHandler+0x27da>
 800c8ce:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c8d2:	e00c      	b.n	800c8ee <HAL_DMA_IRQHandler+0x27da>
 800c8d4:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c8d8:	e009      	b.n	800c8ee <HAL_DMA_IRQHandler+0x27da>
 800c8da:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c8de:	e006      	b.n	800c8ee <HAL_DMA_IRQHandler+0x27da>
 800c8e0:	2320      	movs	r3, #32
 800c8e2:	e004      	b.n	800c8ee <HAL_DMA_IRQHandler+0x27da>
 800c8e4:	2320      	movs	r3, #32
 800c8e6:	e002      	b.n	800c8ee <HAL_DMA_IRQHandler+0x27da>
 800c8e8:	2320      	movs	r3, #32
 800c8ea:	e000      	b.n	800c8ee <HAL_DMA_IRQHandler+0x27da>
 800c8ec:	2320      	movs	r3, #32
 800c8ee:	4013      	ands	r3, r2
 800c8f0:	2b00      	cmp	r3, #0
 800c8f2:	bf14      	ite	ne
 800c8f4:	2301      	movne	r3, #1
 800c8f6:	2300      	moveq	r3, #0
 800c8f8:	b2db      	uxtb	r3, r3
 800c8fa:	e124      	b.n	800cb46 <HAL_DMA_IRQHandler+0x2a32>
 800c8fc:	40026458 	.word	0x40026458
 800c900:	40026400 	.word	0x40026400
 800c904:	40026010 	.word	0x40026010
 800c908:	40026410 	.word	0x40026410
 800c90c:	40026070 	.word	0x40026070
 800c910:	40026470 	.word	0x40026470
 800c914:	40026028 	.word	0x40026028
 800c918:	40026428 	.word	0x40026428
 800c91c:	40026088 	.word	0x40026088
 800c920:	40026488 	.word	0x40026488
 800c924:	40026040 	.word	0x40026040
 800c928:	40026440 	.word	0x40026440
 800c92c:	400260a0 	.word	0x400260a0
 800c930:	400264a0 	.word	0x400264a0
 800c934:	400260b8 	.word	0x400260b8
 800c938:	687b      	ldr	r3, [r7, #4]
 800c93a:	681b      	ldr	r3, [r3, #0]
 800c93c:	461a      	mov	r2, r3
 800c93e:	4b70      	ldr	r3, [pc, #448]	; (800cb00 <HAL_DMA_IRQHandler+0x29ec>)
 800c940:	429a      	cmp	r2, r3
 800c942:	d972      	bls.n	800ca2a <HAL_DMA_IRQHandler+0x2916>
 800c944:	4b6f      	ldr	r3, [pc, #444]	; (800cb04 <HAL_DMA_IRQHandler+0x29f0>)
 800c946:	685a      	ldr	r2, [r3, #4]
 800c948:	687b      	ldr	r3, [r7, #4]
 800c94a:	681b      	ldr	r3, [r3, #0]
 800c94c:	4619      	mov	r1, r3
 800c94e:	4b6e      	ldr	r3, [pc, #440]	; (800cb08 <HAL_DMA_IRQHandler+0x29f4>)
 800c950:	4299      	cmp	r1, r3
 800c952:	d062      	beq.n	800ca1a <HAL_DMA_IRQHandler+0x2906>
 800c954:	687b      	ldr	r3, [r7, #4]
 800c956:	681b      	ldr	r3, [r3, #0]
 800c958:	4619      	mov	r1, r3
 800c95a:	4b6c      	ldr	r3, [pc, #432]	; (800cb0c <HAL_DMA_IRQHandler+0x29f8>)
 800c95c:	4299      	cmp	r1, r3
 800c95e:	d05a      	beq.n	800ca16 <HAL_DMA_IRQHandler+0x2902>
 800c960:	687b      	ldr	r3, [r7, #4]
 800c962:	681b      	ldr	r3, [r3, #0]
 800c964:	4619      	mov	r1, r3
 800c966:	4b6a      	ldr	r3, [pc, #424]	; (800cb10 <HAL_DMA_IRQHandler+0x29fc>)
 800c968:	4299      	cmp	r1, r3
 800c96a:	d052      	beq.n	800ca12 <HAL_DMA_IRQHandler+0x28fe>
 800c96c:	687b      	ldr	r3, [r7, #4]
 800c96e:	681b      	ldr	r3, [r3, #0]
 800c970:	4619      	mov	r1, r3
 800c972:	4b68      	ldr	r3, [pc, #416]	; (800cb14 <HAL_DMA_IRQHandler+0x2a00>)
 800c974:	4299      	cmp	r1, r3
 800c976:	d04a      	beq.n	800ca0e <HAL_DMA_IRQHandler+0x28fa>
 800c978:	687b      	ldr	r3, [r7, #4]
 800c97a:	681b      	ldr	r3, [r3, #0]
 800c97c:	4619      	mov	r1, r3
 800c97e:	4b66      	ldr	r3, [pc, #408]	; (800cb18 <HAL_DMA_IRQHandler+0x2a04>)
 800c980:	4299      	cmp	r1, r3
 800c982:	d041      	beq.n	800ca08 <HAL_DMA_IRQHandler+0x28f4>
 800c984:	687b      	ldr	r3, [r7, #4]
 800c986:	681b      	ldr	r3, [r3, #0]
 800c988:	4619      	mov	r1, r3
 800c98a:	4b64      	ldr	r3, [pc, #400]	; (800cb1c <HAL_DMA_IRQHandler+0x2a08>)
 800c98c:	4299      	cmp	r1, r3
 800c98e:	d038      	beq.n	800ca02 <HAL_DMA_IRQHandler+0x28ee>
 800c990:	687b      	ldr	r3, [r7, #4]
 800c992:	681b      	ldr	r3, [r3, #0]
 800c994:	4619      	mov	r1, r3
 800c996:	4b62      	ldr	r3, [pc, #392]	; (800cb20 <HAL_DMA_IRQHandler+0x2a0c>)
 800c998:	4299      	cmp	r1, r3
 800c99a:	d02f      	beq.n	800c9fc <HAL_DMA_IRQHandler+0x28e8>
 800c99c:	687b      	ldr	r3, [r7, #4]
 800c99e:	681b      	ldr	r3, [r3, #0]
 800c9a0:	4619      	mov	r1, r3
 800c9a2:	4b60      	ldr	r3, [pc, #384]	; (800cb24 <HAL_DMA_IRQHandler+0x2a10>)
 800c9a4:	4299      	cmp	r1, r3
 800c9a6:	d026      	beq.n	800c9f6 <HAL_DMA_IRQHandler+0x28e2>
 800c9a8:	687b      	ldr	r3, [r7, #4]
 800c9aa:	681b      	ldr	r3, [r3, #0]
 800c9ac:	4619      	mov	r1, r3
 800c9ae:	4b5e      	ldr	r3, [pc, #376]	; (800cb28 <HAL_DMA_IRQHandler+0x2a14>)
 800c9b0:	4299      	cmp	r1, r3
 800c9b2:	d01d      	beq.n	800c9f0 <HAL_DMA_IRQHandler+0x28dc>
 800c9b4:	687b      	ldr	r3, [r7, #4]
 800c9b6:	681b      	ldr	r3, [r3, #0]
 800c9b8:	4619      	mov	r1, r3
 800c9ba:	4b5c      	ldr	r3, [pc, #368]	; (800cb2c <HAL_DMA_IRQHandler+0x2a18>)
 800c9bc:	4299      	cmp	r1, r3
 800c9be:	d014      	beq.n	800c9ea <HAL_DMA_IRQHandler+0x28d6>
 800c9c0:	687b      	ldr	r3, [r7, #4]
 800c9c2:	681b      	ldr	r3, [r3, #0]
 800c9c4:	4619      	mov	r1, r3
 800c9c6:	4b5a      	ldr	r3, [pc, #360]	; (800cb30 <HAL_DMA_IRQHandler+0x2a1c>)
 800c9c8:	4299      	cmp	r1, r3
 800c9ca:	d00b      	beq.n	800c9e4 <HAL_DMA_IRQHandler+0x28d0>
 800c9cc:	687b      	ldr	r3, [r7, #4]
 800c9ce:	681b      	ldr	r3, [r3, #0]
 800c9d0:	4619      	mov	r1, r3
 800c9d2:	4b58      	ldr	r3, [pc, #352]	; (800cb34 <HAL_DMA_IRQHandler+0x2a20>)
 800c9d4:	4299      	cmp	r1, r3
 800c9d6:	d102      	bne.n	800c9de <HAL_DMA_IRQHandler+0x28ca>
 800c9d8:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c9dc:	e01e      	b.n	800ca1c <HAL_DMA_IRQHandler+0x2908>
 800c9de:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800c9e2:	e01b      	b.n	800ca1c <HAL_DMA_IRQHandler+0x2908>
 800c9e4:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c9e8:	e018      	b.n	800ca1c <HAL_DMA_IRQHandler+0x2908>
 800c9ea:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c9ee:	e015      	b.n	800ca1c <HAL_DMA_IRQHandler+0x2908>
 800c9f0:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c9f4:	e012      	b.n	800ca1c <HAL_DMA_IRQHandler+0x2908>
 800c9f6:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c9fa:	e00f      	b.n	800ca1c <HAL_DMA_IRQHandler+0x2908>
 800c9fc:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800ca00:	e00c      	b.n	800ca1c <HAL_DMA_IRQHandler+0x2908>
 800ca02:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800ca06:	e009      	b.n	800ca1c <HAL_DMA_IRQHandler+0x2908>
 800ca08:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800ca0c:	e006      	b.n	800ca1c <HAL_DMA_IRQHandler+0x2908>
 800ca0e:	2320      	movs	r3, #32
 800ca10:	e004      	b.n	800ca1c <HAL_DMA_IRQHandler+0x2908>
 800ca12:	2320      	movs	r3, #32
 800ca14:	e002      	b.n	800ca1c <HAL_DMA_IRQHandler+0x2908>
 800ca16:	2320      	movs	r3, #32
 800ca18:	e000      	b.n	800ca1c <HAL_DMA_IRQHandler+0x2908>
 800ca1a:	2320      	movs	r3, #32
 800ca1c:	4013      	ands	r3, r2
 800ca1e:	2b00      	cmp	r3, #0
 800ca20:	bf14      	ite	ne
 800ca22:	2301      	movne	r3, #1
 800ca24:	2300      	moveq	r3, #0
 800ca26:	b2db      	uxtb	r3, r3
 800ca28:	e08d      	b.n	800cb46 <HAL_DMA_IRQHandler+0x2a32>
 800ca2a:	4b36      	ldr	r3, [pc, #216]	; (800cb04 <HAL_DMA_IRQHandler+0x29f0>)
 800ca2c:	681a      	ldr	r2, [r3, #0]
 800ca2e:	687b      	ldr	r3, [r7, #4]
 800ca30:	681b      	ldr	r3, [r3, #0]
 800ca32:	4619      	mov	r1, r3
 800ca34:	4b34      	ldr	r3, [pc, #208]	; (800cb08 <HAL_DMA_IRQHandler+0x29f4>)
 800ca36:	4299      	cmp	r1, r3
 800ca38:	d07e      	beq.n	800cb38 <HAL_DMA_IRQHandler+0x2a24>
 800ca3a:	687b      	ldr	r3, [r7, #4]
 800ca3c:	681b      	ldr	r3, [r3, #0]
 800ca3e:	4619      	mov	r1, r3
 800ca40:	4b32      	ldr	r3, [pc, #200]	; (800cb0c <HAL_DMA_IRQHandler+0x29f8>)
 800ca42:	4299      	cmp	r1, r3
 800ca44:	d05a      	beq.n	800cafc <HAL_DMA_IRQHandler+0x29e8>
 800ca46:	687b      	ldr	r3, [r7, #4]
 800ca48:	681b      	ldr	r3, [r3, #0]
 800ca4a:	4619      	mov	r1, r3
 800ca4c:	4b30      	ldr	r3, [pc, #192]	; (800cb10 <HAL_DMA_IRQHandler+0x29fc>)
 800ca4e:	4299      	cmp	r1, r3
 800ca50:	d052      	beq.n	800caf8 <HAL_DMA_IRQHandler+0x29e4>
 800ca52:	687b      	ldr	r3, [r7, #4]
 800ca54:	681b      	ldr	r3, [r3, #0]
 800ca56:	4619      	mov	r1, r3
 800ca58:	4b2e      	ldr	r3, [pc, #184]	; (800cb14 <HAL_DMA_IRQHandler+0x2a00>)
 800ca5a:	4299      	cmp	r1, r3
 800ca5c:	d04a      	beq.n	800caf4 <HAL_DMA_IRQHandler+0x29e0>
 800ca5e:	687b      	ldr	r3, [r7, #4]
 800ca60:	681b      	ldr	r3, [r3, #0]
 800ca62:	4619      	mov	r1, r3
 800ca64:	4b2c      	ldr	r3, [pc, #176]	; (800cb18 <HAL_DMA_IRQHandler+0x2a04>)
 800ca66:	4299      	cmp	r1, r3
 800ca68:	d041      	beq.n	800caee <HAL_DMA_IRQHandler+0x29da>
 800ca6a:	687b      	ldr	r3, [r7, #4]
 800ca6c:	681b      	ldr	r3, [r3, #0]
 800ca6e:	4619      	mov	r1, r3
 800ca70:	4b2a      	ldr	r3, [pc, #168]	; (800cb1c <HAL_DMA_IRQHandler+0x2a08>)
 800ca72:	4299      	cmp	r1, r3
 800ca74:	d038      	beq.n	800cae8 <HAL_DMA_IRQHandler+0x29d4>
 800ca76:	687b      	ldr	r3, [r7, #4]
 800ca78:	681b      	ldr	r3, [r3, #0]
 800ca7a:	4619      	mov	r1, r3
 800ca7c:	4b28      	ldr	r3, [pc, #160]	; (800cb20 <HAL_DMA_IRQHandler+0x2a0c>)
 800ca7e:	4299      	cmp	r1, r3
 800ca80:	d02f      	beq.n	800cae2 <HAL_DMA_IRQHandler+0x29ce>
 800ca82:	687b      	ldr	r3, [r7, #4]
 800ca84:	681b      	ldr	r3, [r3, #0]
 800ca86:	4619      	mov	r1, r3
 800ca88:	4b26      	ldr	r3, [pc, #152]	; (800cb24 <HAL_DMA_IRQHandler+0x2a10>)
 800ca8a:	4299      	cmp	r1, r3
 800ca8c:	d026      	beq.n	800cadc <HAL_DMA_IRQHandler+0x29c8>
 800ca8e:	687b      	ldr	r3, [r7, #4]
 800ca90:	681b      	ldr	r3, [r3, #0]
 800ca92:	4619      	mov	r1, r3
 800ca94:	4b24      	ldr	r3, [pc, #144]	; (800cb28 <HAL_DMA_IRQHandler+0x2a14>)
 800ca96:	4299      	cmp	r1, r3
 800ca98:	d01d      	beq.n	800cad6 <HAL_DMA_IRQHandler+0x29c2>
 800ca9a:	687b      	ldr	r3, [r7, #4]
 800ca9c:	681b      	ldr	r3, [r3, #0]
 800ca9e:	4619      	mov	r1, r3
 800caa0:	4b22      	ldr	r3, [pc, #136]	; (800cb2c <HAL_DMA_IRQHandler+0x2a18>)
 800caa2:	4299      	cmp	r1, r3
 800caa4:	d014      	beq.n	800cad0 <HAL_DMA_IRQHandler+0x29bc>
 800caa6:	687b      	ldr	r3, [r7, #4]
 800caa8:	681b      	ldr	r3, [r3, #0]
 800caaa:	4619      	mov	r1, r3
 800caac:	4b20      	ldr	r3, [pc, #128]	; (800cb30 <HAL_DMA_IRQHandler+0x2a1c>)
 800caae:	4299      	cmp	r1, r3
 800cab0:	d00b      	beq.n	800caca <HAL_DMA_IRQHandler+0x29b6>
 800cab2:	687b      	ldr	r3, [r7, #4]
 800cab4:	681b      	ldr	r3, [r3, #0]
 800cab6:	4619      	mov	r1, r3
 800cab8:	4b1e      	ldr	r3, [pc, #120]	; (800cb34 <HAL_DMA_IRQHandler+0x2a20>)
 800caba:	4299      	cmp	r1, r3
 800cabc:	d102      	bne.n	800cac4 <HAL_DMA_IRQHandler+0x29b0>
 800cabe:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cac2:	e03a      	b.n	800cb3a <HAL_DMA_IRQHandler+0x2a26>
 800cac4:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800cac8:	e037      	b.n	800cb3a <HAL_DMA_IRQHandler+0x2a26>
 800caca:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cace:	e034      	b.n	800cb3a <HAL_DMA_IRQHandler+0x2a26>
 800cad0:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cad4:	e031      	b.n	800cb3a <HAL_DMA_IRQHandler+0x2a26>
 800cad6:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cada:	e02e      	b.n	800cb3a <HAL_DMA_IRQHandler+0x2a26>
 800cadc:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cae0:	e02b      	b.n	800cb3a <HAL_DMA_IRQHandler+0x2a26>
 800cae2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cae6:	e028      	b.n	800cb3a <HAL_DMA_IRQHandler+0x2a26>
 800cae8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800caec:	e025      	b.n	800cb3a <HAL_DMA_IRQHandler+0x2a26>
 800caee:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800caf2:	e022      	b.n	800cb3a <HAL_DMA_IRQHandler+0x2a26>
 800caf4:	2320      	movs	r3, #32
 800caf6:	e020      	b.n	800cb3a <HAL_DMA_IRQHandler+0x2a26>
 800caf8:	2320      	movs	r3, #32
 800cafa:	e01e      	b.n	800cb3a <HAL_DMA_IRQHandler+0x2a26>
 800cafc:	2320      	movs	r3, #32
 800cafe:	e01c      	b.n	800cb3a <HAL_DMA_IRQHandler+0x2a26>
 800cb00:	40026058 	.word	0x40026058
 800cb04:	40026000 	.word	0x40026000
 800cb08:	40026010 	.word	0x40026010
 800cb0c:	40026410 	.word	0x40026410
 800cb10:	40026070 	.word	0x40026070
 800cb14:	40026470 	.word	0x40026470
 800cb18:	40026028 	.word	0x40026028
 800cb1c:	40026428 	.word	0x40026428
 800cb20:	40026088 	.word	0x40026088
 800cb24:	40026488 	.word	0x40026488
 800cb28:	40026040 	.word	0x40026040
 800cb2c:	40026440 	.word	0x40026440
 800cb30:	400260a0 	.word	0x400260a0
 800cb34:	400264a0 	.word	0x400264a0
 800cb38:	2320      	movs	r3, #32
 800cb3a:	4013      	ands	r3, r2
 800cb3c:	2b00      	cmp	r3, #0
 800cb3e:	bf14      	ite	ne
 800cb40:	2301      	movne	r3, #1
 800cb42:	2300      	moveq	r3, #0
 800cb44:	b2db      	uxtb	r3, r3
 800cb46:	2b00      	cmp	r3, #0
 800cb48:	f000 8445 	beq.w	800d3d6 <HAL_DMA_IRQHandler+0x32c2>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 800cb4c:	687b      	ldr	r3, [r7, #4]
 800cb4e:	681b      	ldr	r3, [r3, #0]
 800cb50:	681b      	ldr	r3, [r3, #0]
 800cb52:	f003 0310 	and.w	r3, r3, #16
 800cb56:	2b00      	cmp	r3, #0
 800cb58:	f000 843d 	beq.w	800d3d6 <HAL_DMA_IRQHandler+0x32c2>
    {
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
 800cb5c:	687b      	ldr	r3, [r7, #4]
 800cb5e:	681b      	ldr	r3, [r3, #0]
 800cb60:	681b      	ldr	r3, [r3, #0]
 800cb62:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800cb66:	2b00      	cmp	r3, #0
 800cb68:	f000 820d 	beq.w	800cf86 <HAL_DMA_IRQHandler+0x2e72>
      {
        /* Clear the transfer complete flag */
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 800cb6c:	687b      	ldr	r3, [r7, #4]
 800cb6e:	681b      	ldr	r3, [r3, #0]
 800cb70:	461a      	mov	r2, r3
 800cb72:	4ba0      	ldr	r3, [pc, #640]	; (800cdf4 <HAL_DMA_IRQHandler+0x2ce0>)
 800cb74:	429a      	cmp	r2, r3
 800cb76:	d96c      	bls.n	800cc52 <HAL_DMA_IRQHandler+0x2b3e>
 800cb78:	4a9f      	ldr	r2, [pc, #636]	; (800cdf8 <HAL_DMA_IRQHandler+0x2ce4>)
 800cb7a:	687b      	ldr	r3, [r7, #4]
 800cb7c:	681b      	ldr	r3, [r3, #0]
 800cb7e:	4619      	mov	r1, r3
 800cb80:	4b9e      	ldr	r3, [pc, #632]	; (800cdfc <HAL_DMA_IRQHandler+0x2ce8>)
 800cb82:	4299      	cmp	r1, r3
 800cb84:	d062      	beq.n	800cc4c <HAL_DMA_IRQHandler+0x2b38>
 800cb86:	687b      	ldr	r3, [r7, #4]
 800cb88:	681b      	ldr	r3, [r3, #0]
 800cb8a:	4619      	mov	r1, r3
 800cb8c:	4b9c      	ldr	r3, [pc, #624]	; (800ce00 <HAL_DMA_IRQHandler+0x2cec>)
 800cb8e:	4299      	cmp	r1, r3
 800cb90:	d05a      	beq.n	800cc48 <HAL_DMA_IRQHandler+0x2b34>
 800cb92:	687b      	ldr	r3, [r7, #4]
 800cb94:	681b      	ldr	r3, [r3, #0]
 800cb96:	4619      	mov	r1, r3
 800cb98:	4b9a      	ldr	r3, [pc, #616]	; (800ce04 <HAL_DMA_IRQHandler+0x2cf0>)
 800cb9a:	4299      	cmp	r1, r3
 800cb9c:	d052      	beq.n	800cc44 <HAL_DMA_IRQHandler+0x2b30>
 800cb9e:	687b      	ldr	r3, [r7, #4]
 800cba0:	681b      	ldr	r3, [r3, #0]
 800cba2:	4619      	mov	r1, r3
 800cba4:	4b98      	ldr	r3, [pc, #608]	; (800ce08 <HAL_DMA_IRQHandler+0x2cf4>)
 800cba6:	4299      	cmp	r1, r3
 800cba8:	d04a      	beq.n	800cc40 <HAL_DMA_IRQHandler+0x2b2c>
 800cbaa:	687b      	ldr	r3, [r7, #4]
 800cbac:	681b      	ldr	r3, [r3, #0]
 800cbae:	4619      	mov	r1, r3
 800cbb0:	4b96      	ldr	r3, [pc, #600]	; (800ce0c <HAL_DMA_IRQHandler+0x2cf8>)
 800cbb2:	4299      	cmp	r1, r3
 800cbb4:	d041      	beq.n	800cc3a <HAL_DMA_IRQHandler+0x2b26>
 800cbb6:	687b      	ldr	r3, [r7, #4]
 800cbb8:	681b      	ldr	r3, [r3, #0]
 800cbba:	4619      	mov	r1, r3
 800cbbc:	4b94      	ldr	r3, [pc, #592]	; (800ce10 <HAL_DMA_IRQHandler+0x2cfc>)
 800cbbe:	4299      	cmp	r1, r3
 800cbc0:	d038      	beq.n	800cc34 <HAL_DMA_IRQHandler+0x2b20>
 800cbc2:	687b      	ldr	r3, [r7, #4]
 800cbc4:	681b      	ldr	r3, [r3, #0]
 800cbc6:	4619      	mov	r1, r3
 800cbc8:	4b92      	ldr	r3, [pc, #584]	; (800ce14 <HAL_DMA_IRQHandler+0x2d00>)
 800cbca:	4299      	cmp	r1, r3
 800cbcc:	d02f      	beq.n	800cc2e <HAL_DMA_IRQHandler+0x2b1a>
 800cbce:	687b      	ldr	r3, [r7, #4]
 800cbd0:	681b      	ldr	r3, [r3, #0]
 800cbd2:	4619      	mov	r1, r3
 800cbd4:	4b90      	ldr	r3, [pc, #576]	; (800ce18 <HAL_DMA_IRQHandler+0x2d04>)
 800cbd6:	4299      	cmp	r1, r3
 800cbd8:	d026      	beq.n	800cc28 <HAL_DMA_IRQHandler+0x2b14>
 800cbda:	687b      	ldr	r3, [r7, #4]
 800cbdc:	681b      	ldr	r3, [r3, #0]
 800cbde:	4619      	mov	r1, r3
 800cbe0:	4b8e      	ldr	r3, [pc, #568]	; (800ce1c <HAL_DMA_IRQHandler+0x2d08>)
 800cbe2:	4299      	cmp	r1, r3
 800cbe4:	d01d      	beq.n	800cc22 <HAL_DMA_IRQHandler+0x2b0e>
 800cbe6:	687b      	ldr	r3, [r7, #4]
 800cbe8:	681b      	ldr	r3, [r3, #0]
 800cbea:	4619      	mov	r1, r3
 800cbec:	4b8c      	ldr	r3, [pc, #560]	; (800ce20 <HAL_DMA_IRQHandler+0x2d0c>)
 800cbee:	4299      	cmp	r1, r3
 800cbf0:	d014      	beq.n	800cc1c <HAL_DMA_IRQHandler+0x2b08>
 800cbf2:	687b      	ldr	r3, [r7, #4]
 800cbf4:	681b      	ldr	r3, [r3, #0]
 800cbf6:	4619      	mov	r1, r3
 800cbf8:	4b8a      	ldr	r3, [pc, #552]	; (800ce24 <HAL_DMA_IRQHandler+0x2d10>)
 800cbfa:	4299      	cmp	r1, r3
 800cbfc:	d00b      	beq.n	800cc16 <HAL_DMA_IRQHandler+0x2b02>
 800cbfe:	687b      	ldr	r3, [r7, #4]
 800cc00:	681b      	ldr	r3, [r3, #0]
 800cc02:	4619      	mov	r1, r3
 800cc04:	4b88      	ldr	r3, [pc, #544]	; (800ce28 <HAL_DMA_IRQHandler+0x2d14>)
 800cc06:	4299      	cmp	r1, r3
 800cc08:	d102      	bne.n	800cc10 <HAL_DMA_IRQHandler+0x2afc>
 800cc0a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cc0e:	e01e      	b.n	800cc4e <HAL_DMA_IRQHandler+0x2b3a>
 800cc10:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800cc14:	e01b      	b.n	800cc4e <HAL_DMA_IRQHandler+0x2b3a>
 800cc16:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cc1a:	e018      	b.n	800cc4e <HAL_DMA_IRQHandler+0x2b3a>
 800cc1c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cc20:	e015      	b.n	800cc4e <HAL_DMA_IRQHandler+0x2b3a>
 800cc22:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cc26:	e012      	b.n	800cc4e <HAL_DMA_IRQHandler+0x2b3a>
 800cc28:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cc2c:	e00f      	b.n	800cc4e <HAL_DMA_IRQHandler+0x2b3a>
 800cc2e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cc32:	e00c      	b.n	800cc4e <HAL_DMA_IRQHandler+0x2b3a>
 800cc34:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cc38:	e009      	b.n	800cc4e <HAL_DMA_IRQHandler+0x2b3a>
 800cc3a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cc3e:	e006      	b.n	800cc4e <HAL_DMA_IRQHandler+0x2b3a>
 800cc40:	2320      	movs	r3, #32
 800cc42:	e004      	b.n	800cc4e <HAL_DMA_IRQHandler+0x2b3a>
 800cc44:	2320      	movs	r3, #32
 800cc46:	e002      	b.n	800cc4e <HAL_DMA_IRQHandler+0x2b3a>
 800cc48:	2320      	movs	r3, #32
 800cc4a:	e000      	b.n	800cc4e <HAL_DMA_IRQHandler+0x2b3a>
 800cc4c:	2320      	movs	r3, #32
 800cc4e:	60d3      	str	r3, [r2, #12]
 800cc50:	e176      	b.n	800cf40 <HAL_DMA_IRQHandler+0x2e2c>
 800cc52:	687b      	ldr	r3, [r7, #4]
 800cc54:	681b      	ldr	r3, [r3, #0]
 800cc56:	461a      	mov	r2, r3
 800cc58:	4b74      	ldr	r3, [pc, #464]	; (800ce2c <HAL_DMA_IRQHandler+0x2d18>)
 800cc5a:	429a      	cmp	r2, r3
 800cc5c:	d96c      	bls.n	800cd38 <HAL_DMA_IRQHandler+0x2c24>
 800cc5e:	4a66      	ldr	r2, [pc, #408]	; (800cdf8 <HAL_DMA_IRQHandler+0x2ce4>)
 800cc60:	687b      	ldr	r3, [r7, #4]
 800cc62:	681b      	ldr	r3, [r3, #0]
 800cc64:	4619      	mov	r1, r3
 800cc66:	4b65      	ldr	r3, [pc, #404]	; (800cdfc <HAL_DMA_IRQHandler+0x2ce8>)
 800cc68:	4299      	cmp	r1, r3
 800cc6a:	d062      	beq.n	800cd32 <HAL_DMA_IRQHandler+0x2c1e>
 800cc6c:	687b      	ldr	r3, [r7, #4]
 800cc6e:	681b      	ldr	r3, [r3, #0]
 800cc70:	4619      	mov	r1, r3
 800cc72:	4b63      	ldr	r3, [pc, #396]	; (800ce00 <HAL_DMA_IRQHandler+0x2cec>)
 800cc74:	4299      	cmp	r1, r3
 800cc76:	d05a      	beq.n	800cd2e <HAL_DMA_IRQHandler+0x2c1a>
 800cc78:	687b      	ldr	r3, [r7, #4]
 800cc7a:	681b      	ldr	r3, [r3, #0]
 800cc7c:	4619      	mov	r1, r3
 800cc7e:	4b61      	ldr	r3, [pc, #388]	; (800ce04 <HAL_DMA_IRQHandler+0x2cf0>)
 800cc80:	4299      	cmp	r1, r3
 800cc82:	d052      	beq.n	800cd2a <HAL_DMA_IRQHandler+0x2c16>
 800cc84:	687b      	ldr	r3, [r7, #4]
 800cc86:	681b      	ldr	r3, [r3, #0]
 800cc88:	4619      	mov	r1, r3
 800cc8a:	4b5f      	ldr	r3, [pc, #380]	; (800ce08 <HAL_DMA_IRQHandler+0x2cf4>)
 800cc8c:	4299      	cmp	r1, r3
 800cc8e:	d04a      	beq.n	800cd26 <HAL_DMA_IRQHandler+0x2c12>
 800cc90:	687b      	ldr	r3, [r7, #4]
 800cc92:	681b      	ldr	r3, [r3, #0]
 800cc94:	4619      	mov	r1, r3
 800cc96:	4b5d      	ldr	r3, [pc, #372]	; (800ce0c <HAL_DMA_IRQHandler+0x2cf8>)
 800cc98:	4299      	cmp	r1, r3
 800cc9a:	d041      	beq.n	800cd20 <HAL_DMA_IRQHandler+0x2c0c>
 800cc9c:	687b      	ldr	r3, [r7, #4]
 800cc9e:	681b      	ldr	r3, [r3, #0]
 800cca0:	4619      	mov	r1, r3
 800cca2:	4b5b      	ldr	r3, [pc, #364]	; (800ce10 <HAL_DMA_IRQHandler+0x2cfc>)
 800cca4:	4299      	cmp	r1, r3
 800cca6:	d038      	beq.n	800cd1a <HAL_DMA_IRQHandler+0x2c06>
 800cca8:	687b      	ldr	r3, [r7, #4]
 800ccaa:	681b      	ldr	r3, [r3, #0]
 800ccac:	4619      	mov	r1, r3
 800ccae:	4b59      	ldr	r3, [pc, #356]	; (800ce14 <HAL_DMA_IRQHandler+0x2d00>)
 800ccb0:	4299      	cmp	r1, r3
 800ccb2:	d02f      	beq.n	800cd14 <HAL_DMA_IRQHandler+0x2c00>
 800ccb4:	687b      	ldr	r3, [r7, #4]
 800ccb6:	681b      	ldr	r3, [r3, #0]
 800ccb8:	4619      	mov	r1, r3
 800ccba:	4b57      	ldr	r3, [pc, #348]	; (800ce18 <HAL_DMA_IRQHandler+0x2d04>)
 800ccbc:	4299      	cmp	r1, r3
 800ccbe:	d026      	beq.n	800cd0e <HAL_DMA_IRQHandler+0x2bfa>
 800ccc0:	687b      	ldr	r3, [r7, #4]
 800ccc2:	681b      	ldr	r3, [r3, #0]
 800ccc4:	4619      	mov	r1, r3
 800ccc6:	4b55      	ldr	r3, [pc, #340]	; (800ce1c <HAL_DMA_IRQHandler+0x2d08>)
 800ccc8:	4299      	cmp	r1, r3
 800ccca:	d01d      	beq.n	800cd08 <HAL_DMA_IRQHandler+0x2bf4>
 800cccc:	687b      	ldr	r3, [r7, #4]
 800ccce:	681b      	ldr	r3, [r3, #0]
 800ccd0:	4619      	mov	r1, r3
 800ccd2:	4b53      	ldr	r3, [pc, #332]	; (800ce20 <HAL_DMA_IRQHandler+0x2d0c>)
 800ccd4:	4299      	cmp	r1, r3
 800ccd6:	d014      	beq.n	800cd02 <HAL_DMA_IRQHandler+0x2bee>
 800ccd8:	687b      	ldr	r3, [r7, #4]
 800ccda:	681b      	ldr	r3, [r3, #0]
 800ccdc:	4619      	mov	r1, r3
 800ccde:	4b51      	ldr	r3, [pc, #324]	; (800ce24 <HAL_DMA_IRQHandler+0x2d10>)
 800cce0:	4299      	cmp	r1, r3
 800cce2:	d00b      	beq.n	800ccfc <HAL_DMA_IRQHandler+0x2be8>
 800cce4:	687b      	ldr	r3, [r7, #4]
 800cce6:	681b      	ldr	r3, [r3, #0]
 800cce8:	4619      	mov	r1, r3
 800ccea:	4b4f      	ldr	r3, [pc, #316]	; (800ce28 <HAL_DMA_IRQHandler+0x2d14>)
 800ccec:	4299      	cmp	r1, r3
 800ccee:	d102      	bne.n	800ccf6 <HAL_DMA_IRQHandler+0x2be2>
 800ccf0:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800ccf4:	e01e      	b.n	800cd34 <HAL_DMA_IRQHandler+0x2c20>
 800ccf6:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800ccfa:	e01b      	b.n	800cd34 <HAL_DMA_IRQHandler+0x2c20>
 800ccfc:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cd00:	e018      	b.n	800cd34 <HAL_DMA_IRQHandler+0x2c20>
 800cd02:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cd06:	e015      	b.n	800cd34 <HAL_DMA_IRQHandler+0x2c20>
 800cd08:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cd0c:	e012      	b.n	800cd34 <HAL_DMA_IRQHandler+0x2c20>
 800cd0e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cd12:	e00f      	b.n	800cd34 <HAL_DMA_IRQHandler+0x2c20>
 800cd14:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cd18:	e00c      	b.n	800cd34 <HAL_DMA_IRQHandler+0x2c20>
 800cd1a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cd1e:	e009      	b.n	800cd34 <HAL_DMA_IRQHandler+0x2c20>
 800cd20:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cd24:	e006      	b.n	800cd34 <HAL_DMA_IRQHandler+0x2c20>
 800cd26:	2320      	movs	r3, #32
 800cd28:	e004      	b.n	800cd34 <HAL_DMA_IRQHandler+0x2c20>
 800cd2a:	2320      	movs	r3, #32
 800cd2c:	e002      	b.n	800cd34 <HAL_DMA_IRQHandler+0x2c20>
 800cd2e:	2320      	movs	r3, #32
 800cd30:	e000      	b.n	800cd34 <HAL_DMA_IRQHandler+0x2c20>
 800cd32:	2320      	movs	r3, #32
 800cd34:	6093      	str	r3, [r2, #8]
 800cd36:	e103      	b.n	800cf40 <HAL_DMA_IRQHandler+0x2e2c>
 800cd38:	687b      	ldr	r3, [r7, #4]
 800cd3a:	681b      	ldr	r3, [r3, #0]
 800cd3c:	461a      	mov	r2, r3
 800cd3e:	4b3c      	ldr	r3, [pc, #240]	; (800ce30 <HAL_DMA_IRQHandler+0x2d1c>)
 800cd40:	429a      	cmp	r2, r3
 800cd42:	f240 8091 	bls.w	800ce68 <HAL_DMA_IRQHandler+0x2d54>
 800cd46:	4a3b      	ldr	r2, [pc, #236]	; (800ce34 <HAL_DMA_IRQHandler+0x2d20>)
 800cd48:	687b      	ldr	r3, [r7, #4]
 800cd4a:	681b      	ldr	r3, [r3, #0]
 800cd4c:	4619      	mov	r1, r3
 800cd4e:	4b2b      	ldr	r3, [pc, #172]	; (800cdfc <HAL_DMA_IRQHandler+0x2ce8>)
 800cd50:	4299      	cmp	r1, r3
 800cd52:	f000 8086 	beq.w	800ce62 <HAL_DMA_IRQHandler+0x2d4e>
 800cd56:	687b      	ldr	r3, [r7, #4]
 800cd58:	681b      	ldr	r3, [r3, #0]
 800cd5a:	4619      	mov	r1, r3
 800cd5c:	4b28      	ldr	r3, [pc, #160]	; (800ce00 <HAL_DMA_IRQHandler+0x2cec>)
 800cd5e:	4299      	cmp	r1, r3
 800cd60:	d07d      	beq.n	800ce5e <HAL_DMA_IRQHandler+0x2d4a>
 800cd62:	687b      	ldr	r3, [r7, #4]
 800cd64:	681b      	ldr	r3, [r3, #0]
 800cd66:	4619      	mov	r1, r3
 800cd68:	4b26      	ldr	r3, [pc, #152]	; (800ce04 <HAL_DMA_IRQHandler+0x2cf0>)
 800cd6a:	4299      	cmp	r1, r3
 800cd6c:	d075      	beq.n	800ce5a <HAL_DMA_IRQHandler+0x2d46>
 800cd6e:	687b      	ldr	r3, [r7, #4]
 800cd70:	681b      	ldr	r3, [r3, #0]
 800cd72:	4619      	mov	r1, r3
 800cd74:	4b24      	ldr	r3, [pc, #144]	; (800ce08 <HAL_DMA_IRQHandler+0x2cf4>)
 800cd76:	4299      	cmp	r1, r3
 800cd78:	d06d      	beq.n	800ce56 <HAL_DMA_IRQHandler+0x2d42>
 800cd7a:	687b      	ldr	r3, [r7, #4]
 800cd7c:	681b      	ldr	r3, [r3, #0]
 800cd7e:	4619      	mov	r1, r3
 800cd80:	4b22      	ldr	r3, [pc, #136]	; (800ce0c <HAL_DMA_IRQHandler+0x2cf8>)
 800cd82:	4299      	cmp	r1, r3
 800cd84:	d064      	beq.n	800ce50 <HAL_DMA_IRQHandler+0x2d3c>
 800cd86:	687b      	ldr	r3, [r7, #4]
 800cd88:	681b      	ldr	r3, [r3, #0]
 800cd8a:	4619      	mov	r1, r3
 800cd8c:	4b20      	ldr	r3, [pc, #128]	; (800ce10 <HAL_DMA_IRQHandler+0x2cfc>)
 800cd8e:	4299      	cmp	r1, r3
 800cd90:	d05b      	beq.n	800ce4a <HAL_DMA_IRQHandler+0x2d36>
 800cd92:	687b      	ldr	r3, [r7, #4]
 800cd94:	681b      	ldr	r3, [r3, #0]
 800cd96:	4619      	mov	r1, r3
 800cd98:	4b1e      	ldr	r3, [pc, #120]	; (800ce14 <HAL_DMA_IRQHandler+0x2d00>)
 800cd9a:	4299      	cmp	r1, r3
 800cd9c:	d052      	beq.n	800ce44 <HAL_DMA_IRQHandler+0x2d30>
 800cd9e:	687b      	ldr	r3, [r7, #4]
 800cda0:	681b      	ldr	r3, [r3, #0]
 800cda2:	4619      	mov	r1, r3
 800cda4:	4b1c      	ldr	r3, [pc, #112]	; (800ce18 <HAL_DMA_IRQHandler+0x2d04>)
 800cda6:	4299      	cmp	r1, r3
 800cda8:	d049      	beq.n	800ce3e <HAL_DMA_IRQHandler+0x2d2a>
 800cdaa:	687b      	ldr	r3, [r7, #4]
 800cdac:	681b      	ldr	r3, [r3, #0]
 800cdae:	4619      	mov	r1, r3
 800cdb0:	4b1a      	ldr	r3, [pc, #104]	; (800ce1c <HAL_DMA_IRQHandler+0x2d08>)
 800cdb2:	4299      	cmp	r1, r3
 800cdb4:	d040      	beq.n	800ce38 <HAL_DMA_IRQHandler+0x2d24>
 800cdb6:	687b      	ldr	r3, [r7, #4]
 800cdb8:	681b      	ldr	r3, [r3, #0]
 800cdba:	4619      	mov	r1, r3
 800cdbc:	4b18      	ldr	r3, [pc, #96]	; (800ce20 <HAL_DMA_IRQHandler+0x2d0c>)
 800cdbe:	4299      	cmp	r1, r3
 800cdc0:	d014      	beq.n	800cdec <HAL_DMA_IRQHandler+0x2cd8>
 800cdc2:	687b      	ldr	r3, [r7, #4]
 800cdc4:	681b      	ldr	r3, [r3, #0]
 800cdc6:	4619      	mov	r1, r3
 800cdc8:	4b16      	ldr	r3, [pc, #88]	; (800ce24 <HAL_DMA_IRQHandler+0x2d10>)
 800cdca:	4299      	cmp	r1, r3
 800cdcc:	d00b      	beq.n	800cde6 <HAL_DMA_IRQHandler+0x2cd2>
 800cdce:	687b      	ldr	r3, [r7, #4]
 800cdd0:	681b      	ldr	r3, [r3, #0]
 800cdd2:	4619      	mov	r1, r3
 800cdd4:	4b14      	ldr	r3, [pc, #80]	; (800ce28 <HAL_DMA_IRQHandler+0x2d14>)
 800cdd6:	4299      	cmp	r1, r3
 800cdd8:	d102      	bne.n	800cde0 <HAL_DMA_IRQHandler+0x2ccc>
 800cdda:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cdde:	e041      	b.n	800ce64 <HAL_DMA_IRQHandler+0x2d50>
 800cde0:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800cde4:	e03e      	b.n	800ce64 <HAL_DMA_IRQHandler+0x2d50>
 800cde6:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cdea:	e03b      	b.n	800ce64 <HAL_DMA_IRQHandler+0x2d50>
 800cdec:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cdf0:	e038      	b.n	800ce64 <HAL_DMA_IRQHandler+0x2d50>
 800cdf2:	bf00      	nop
 800cdf4:	40026458 	.word	0x40026458
 800cdf8:	40026400 	.word	0x40026400
 800cdfc:	40026010 	.word	0x40026010
 800ce00:	40026410 	.word	0x40026410
 800ce04:	40026070 	.word	0x40026070
 800ce08:	40026470 	.word	0x40026470
 800ce0c:	40026028 	.word	0x40026028
 800ce10:	40026428 	.word	0x40026428
 800ce14:	40026088 	.word	0x40026088
 800ce18:	40026488 	.word	0x40026488
 800ce1c:	40026040 	.word	0x40026040
 800ce20:	40026440 	.word	0x40026440
 800ce24:	400260a0 	.word	0x400260a0
 800ce28:	400264a0 	.word	0x400264a0
 800ce2c:	400260b8 	.word	0x400260b8
 800ce30:	40026058 	.word	0x40026058
 800ce34:	40026000 	.word	0x40026000
 800ce38:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800ce3c:	e012      	b.n	800ce64 <HAL_DMA_IRQHandler+0x2d50>
 800ce3e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800ce42:	e00f      	b.n	800ce64 <HAL_DMA_IRQHandler+0x2d50>
 800ce44:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800ce48:	e00c      	b.n	800ce64 <HAL_DMA_IRQHandler+0x2d50>
 800ce4a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800ce4e:	e009      	b.n	800ce64 <HAL_DMA_IRQHandler+0x2d50>
 800ce50:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800ce54:	e006      	b.n	800ce64 <HAL_DMA_IRQHandler+0x2d50>
 800ce56:	2320      	movs	r3, #32
 800ce58:	e004      	b.n	800ce64 <HAL_DMA_IRQHandler+0x2d50>
 800ce5a:	2320      	movs	r3, #32
 800ce5c:	e002      	b.n	800ce64 <HAL_DMA_IRQHandler+0x2d50>
 800ce5e:	2320      	movs	r3, #32
 800ce60:	e000      	b.n	800ce64 <HAL_DMA_IRQHandler+0x2d50>
 800ce62:	2320      	movs	r3, #32
 800ce64:	60d3      	str	r3, [r2, #12]
 800ce66:	e06b      	b.n	800cf40 <HAL_DMA_IRQHandler+0x2e2c>
 800ce68:	4a88      	ldr	r2, [pc, #544]	; (800d08c <HAL_DMA_IRQHandler+0x2f78>)
 800ce6a:	687b      	ldr	r3, [r7, #4]
 800ce6c:	681b      	ldr	r3, [r3, #0]
 800ce6e:	4619      	mov	r1, r3
 800ce70:	4b87      	ldr	r3, [pc, #540]	; (800d090 <HAL_DMA_IRQHandler+0x2f7c>)
 800ce72:	4299      	cmp	r1, r3
 800ce74:	d062      	beq.n	800cf3c <HAL_DMA_IRQHandler+0x2e28>
 800ce76:	687b      	ldr	r3, [r7, #4]
 800ce78:	681b      	ldr	r3, [r3, #0]
 800ce7a:	4619      	mov	r1, r3
 800ce7c:	4b85      	ldr	r3, [pc, #532]	; (800d094 <HAL_DMA_IRQHandler+0x2f80>)
 800ce7e:	4299      	cmp	r1, r3
 800ce80:	d05a      	beq.n	800cf38 <HAL_DMA_IRQHandler+0x2e24>
 800ce82:	687b      	ldr	r3, [r7, #4]
 800ce84:	681b      	ldr	r3, [r3, #0]
 800ce86:	4619      	mov	r1, r3
 800ce88:	4b83      	ldr	r3, [pc, #524]	; (800d098 <HAL_DMA_IRQHandler+0x2f84>)
 800ce8a:	4299      	cmp	r1, r3
 800ce8c:	d052      	beq.n	800cf34 <HAL_DMA_IRQHandler+0x2e20>
 800ce8e:	687b      	ldr	r3, [r7, #4]
 800ce90:	681b      	ldr	r3, [r3, #0]
 800ce92:	4619      	mov	r1, r3
 800ce94:	4b81      	ldr	r3, [pc, #516]	; (800d09c <HAL_DMA_IRQHandler+0x2f88>)
 800ce96:	4299      	cmp	r1, r3
 800ce98:	d04a      	beq.n	800cf30 <HAL_DMA_IRQHandler+0x2e1c>
 800ce9a:	687b      	ldr	r3, [r7, #4]
 800ce9c:	681b      	ldr	r3, [r3, #0]
 800ce9e:	4619      	mov	r1, r3
 800cea0:	4b7f      	ldr	r3, [pc, #508]	; (800d0a0 <HAL_DMA_IRQHandler+0x2f8c>)
 800cea2:	4299      	cmp	r1, r3
 800cea4:	d041      	beq.n	800cf2a <HAL_DMA_IRQHandler+0x2e16>
 800cea6:	687b      	ldr	r3, [r7, #4]
 800cea8:	681b      	ldr	r3, [r3, #0]
 800ceaa:	4619      	mov	r1, r3
 800ceac:	4b7d      	ldr	r3, [pc, #500]	; (800d0a4 <HAL_DMA_IRQHandler+0x2f90>)
 800ceae:	4299      	cmp	r1, r3
 800ceb0:	d038      	beq.n	800cf24 <HAL_DMA_IRQHandler+0x2e10>
 800ceb2:	687b      	ldr	r3, [r7, #4]
 800ceb4:	681b      	ldr	r3, [r3, #0]
 800ceb6:	4619      	mov	r1, r3
 800ceb8:	4b7b      	ldr	r3, [pc, #492]	; (800d0a8 <HAL_DMA_IRQHandler+0x2f94>)
 800ceba:	4299      	cmp	r1, r3
 800cebc:	d02f      	beq.n	800cf1e <HAL_DMA_IRQHandler+0x2e0a>
 800cebe:	687b      	ldr	r3, [r7, #4]
 800cec0:	681b      	ldr	r3, [r3, #0]
 800cec2:	4619      	mov	r1, r3
 800cec4:	4b79      	ldr	r3, [pc, #484]	; (800d0ac <HAL_DMA_IRQHandler+0x2f98>)
 800cec6:	4299      	cmp	r1, r3
 800cec8:	d026      	beq.n	800cf18 <HAL_DMA_IRQHandler+0x2e04>
 800ceca:	687b      	ldr	r3, [r7, #4]
 800cecc:	681b      	ldr	r3, [r3, #0]
 800cece:	4619      	mov	r1, r3
 800ced0:	4b77      	ldr	r3, [pc, #476]	; (800d0b0 <HAL_DMA_IRQHandler+0x2f9c>)
 800ced2:	4299      	cmp	r1, r3
 800ced4:	d01d      	beq.n	800cf12 <HAL_DMA_IRQHandler+0x2dfe>
 800ced6:	687b      	ldr	r3, [r7, #4]
 800ced8:	681b      	ldr	r3, [r3, #0]
 800ceda:	4619      	mov	r1, r3
 800cedc:	4b75      	ldr	r3, [pc, #468]	; (800d0b4 <HAL_DMA_IRQHandler+0x2fa0>)
 800cede:	4299      	cmp	r1, r3
 800cee0:	d014      	beq.n	800cf0c <HAL_DMA_IRQHandler+0x2df8>
 800cee2:	687b      	ldr	r3, [r7, #4]
 800cee4:	681b      	ldr	r3, [r3, #0]
 800cee6:	4619      	mov	r1, r3
 800cee8:	4b73      	ldr	r3, [pc, #460]	; (800d0b8 <HAL_DMA_IRQHandler+0x2fa4>)
 800ceea:	4299      	cmp	r1, r3
 800ceec:	d00b      	beq.n	800cf06 <HAL_DMA_IRQHandler+0x2df2>
 800ceee:	687b      	ldr	r3, [r7, #4]
 800cef0:	681b      	ldr	r3, [r3, #0]
 800cef2:	4619      	mov	r1, r3
 800cef4:	4b71      	ldr	r3, [pc, #452]	; (800d0bc <HAL_DMA_IRQHandler+0x2fa8>)
 800cef6:	4299      	cmp	r1, r3
 800cef8:	d102      	bne.n	800cf00 <HAL_DMA_IRQHandler+0x2dec>
 800cefa:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cefe:	e01e      	b.n	800cf3e <HAL_DMA_IRQHandler+0x2e2a>
 800cf00:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800cf04:	e01b      	b.n	800cf3e <HAL_DMA_IRQHandler+0x2e2a>
 800cf06:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cf0a:	e018      	b.n	800cf3e <HAL_DMA_IRQHandler+0x2e2a>
 800cf0c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cf10:	e015      	b.n	800cf3e <HAL_DMA_IRQHandler+0x2e2a>
 800cf12:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cf16:	e012      	b.n	800cf3e <HAL_DMA_IRQHandler+0x2e2a>
 800cf18:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cf1c:	e00f      	b.n	800cf3e <HAL_DMA_IRQHandler+0x2e2a>
 800cf1e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cf22:	e00c      	b.n	800cf3e <HAL_DMA_IRQHandler+0x2e2a>
 800cf24:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cf28:	e009      	b.n	800cf3e <HAL_DMA_IRQHandler+0x2e2a>
 800cf2a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cf2e:	e006      	b.n	800cf3e <HAL_DMA_IRQHandler+0x2e2a>
 800cf30:	2320      	movs	r3, #32
 800cf32:	e004      	b.n	800cf3e <HAL_DMA_IRQHandler+0x2e2a>
 800cf34:	2320      	movs	r3, #32
 800cf36:	e002      	b.n	800cf3e <HAL_DMA_IRQHandler+0x2e2a>
 800cf38:	2320      	movs	r3, #32
 800cf3a:	e000      	b.n	800cf3e <HAL_DMA_IRQHandler+0x2e2a>
 800cf3c:	2320      	movs	r3, #32
 800cf3e:	6093      	str	r3, [r2, #8]

        /* Current memory buffer used is Memory 1 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
 800cf40:	687b      	ldr	r3, [r7, #4]
 800cf42:	681b      	ldr	r3, [r3, #0]
 800cf44:	681b      	ldr	r3, [r3, #0]
 800cf46:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800cf4a:	2b00      	cmp	r3, #0
 800cf4c:	d109      	bne.n	800cf62 <HAL_DMA_IRQHandler+0x2e4e>
        {
          if(hdma->XferM1CpltCallback != NULL)
 800cf4e:	687b      	ldr	r3, [r7, #4]
 800cf50:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800cf52:	2b00      	cmp	r3, #0
 800cf54:	f000 823f 	beq.w	800d3d6 <HAL_DMA_IRQHandler+0x32c2>
          {
            /* Transfer complete Callback for memory1 */
            hdma->XferM1CpltCallback(hdma);
 800cf58:	687b      	ldr	r3, [r7, #4]
 800cf5a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800cf5c:	6878      	ldr	r0, [r7, #4]
 800cf5e:	4798      	blx	r3
 800cf60:	e239      	b.n	800d3d6 <HAL_DMA_IRQHandler+0x32c2>
          }
        }
        /* Current memory buffer used is Memory 0 */
        else if((hdma->Instance->CR & DMA_SxCR_CT) != 0) 
 800cf62:	687b      	ldr	r3, [r7, #4]
 800cf64:	681b      	ldr	r3, [r3, #0]
 800cf66:	681b      	ldr	r3, [r3, #0]
 800cf68:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800cf6c:	2b00      	cmp	r3, #0
 800cf6e:	f000 8232 	beq.w	800d3d6 <HAL_DMA_IRQHandler+0x32c2>
        {
          if(hdma->XferCpltCallback != NULL)
 800cf72:	687b      	ldr	r3, [r7, #4]
 800cf74:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800cf76:	2b00      	cmp	r3, #0
 800cf78:	f000 822d 	beq.w	800d3d6 <HAL_DMA_IRQHandler+0x32c2>
          {
            /* Transfer complete Callback for memory0 */
            hdma->XferCpltCallback(hdma);
 800cf7c:	687b      	ldr	r3, [r7, #4]
 800cf7e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800cf80:	6878      	ldr	r0, [r7, #4]
 800cf82:	4798      	blx	r3
 800cf84:	e227      	b.n	800d3d6 <HAL_DMA_IRQHandler+0x32c2>
        }
      }
      /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
      else
      {
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 800cf86:	687b      	ldr	r3, [r7, #4]
 800cf88:	681b      	ldr	r3, [r3, #0]
 800cf8a:	681b      	ldr	r3, [r3, #0]
 800cf8c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800cf90:	2b00      	cmp	r3, #0
 800cf92:	d107      	bne.n	800cfa4 <HAL_DMA_IRQHandler+0x2e90>
        {
          /* Disable the transfer complete interrupt */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
 800cf94:	687b      	ldr	r3, [r7, #4]
 800cf96:	681b      	ldr	r3, [r3, #0]
 800cf98:	687a      	ldr	r2, [r7, #4]
 800cf9a:	6812      	ldr	r2, [r2, #0]
 800cf9c:	6812      	ldr	r2, [r2, #0]
 800cf9e:	f022 0210 	bic.w	r2, r2, #16
 800cfa2:	601a      	str	r2, [r3, #0]
        }
        /* Clear the transfer complete flag */
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 800cfa4:	687b      	ldr	r3, [r7, #4]
 800cfa6:	681b      	ldr	r3, [r3, #0]
 800cfa8:	461a      	mov	r2, r3
 800cfaa:	4b45      	ldr	r3, [pc, #276]	; (800d0c0 <HAL_DMA_IRQHandler+0x2fac>)
 800cfac:	429a      	cmp	r2, r3
 800cfae:	f240 808b 	bls.w	800d0c8 <HAL_DMA_IRQHandler+0x2fb4>
 800cfb2:	4a44      	ldr	r2, [pc, #272]	; (800d0c4 <HAL_DMA_IRQHandler+0x2fb0>)
 800cfb4:	687b      	ldr	r3, [r7, #4]
 800cfb6:	681b      	ldr	r3, [r3, #0]
 800cfb8:	4619      	mov	r1, r3
 800cfba:	4b35      	ldr	r3, [pc, #212]	; (800d090 <HAL_DMA_IRQHandler+0x2f7c>)
 800cfbc:	4299      	cmp	r1, r3
 800cfbe:	d062      	beq.n	800d086 <HAL_DMA_IRQHandler+0x2f72>
 800cfc0:	687b      	ldr	r3, [r7, #4]
 800cfc2:	681b      	ldr	r3, [r3, #0]
 800cfc4:	4619      	mov	r1, r3
 800cfc6:	4b33      	ldr	r3, [pc, #204]	; (800d094 <HAL_DMA_IRQHandler+0x2f80>)
 800cfc8:	4299      	cmp	r1, r3
 800cfca:	d05a      	beq.n	800d082 <HAL_DMA_IRQHandler+0x2f6e>
 800cfcc:	687b      	ldr	r3, [r7, #4]
 800cfce:	681b      	ldr	r3, [r3, #0]
 800cfd0:	4619      	mov	r1, r3
 800cfd2:	4b31      	ldr	r3, [pc, #196]	; (800d098 <HAL_DMA_IRQHandler+0x2f84>)
 800cfd4:	4299      	cmp	r1, r3
 800cfd6:	d052      	beq.n	800d07e <HAL_DMA_IRQHandler+0x2f6a>
 800cfd8:	687b      	ldr	r3, [r7, #4]
 800cfda:	681b      	ldr	r3, [r3, #0]
 800cfdc:	4619      	mov	r1, r3
 800cfde:	4b2f      	ldr	r3, [pc, #188]	; (800d09c <HAL_DMA_IRQHandler+0x2f88>)
 800cfe0:	4299      	cmp	r1, r3
 800cfe2:	d04a      	beq.n	800d07a <HAL_DMA_IRQHandler+0x2f66>
 800cfe4:	687b      	ldr	r3, [r7, #4]
 800cfe6:	681b      	ldr	r3, [r3, #0]
 800cfe8:	4619      	mov	r1, r3
 800cfea:	4b2d      	ldr	r3, [pc, #180]	; (800d0a0 <HAL_DMA_IRQHandler+0x2f8c>)
 800cfec:	4299      	cmp	r1, r3
 800cfee:	d041      	beq.n	800d074 <HAL_DMA_IRQHandler+0x2f60>
 800cff0:	687b      	ldr	r3, [r7, #4]
 800cff2:	681b      	ldr	r3, [r3, #0]
 800cff4:	4619      	mov	r1, r3
 800cff6:	4b2b      	ldr	r3, [pc, #172]	; (800d0a4 <HAL_DMA_IRQHandler+0x2f90>)
 800cff8:	4299      	cmp	r1, r3
 800cffa:	d038      	beq.n	800d06e <HAL_DMA_IRQHandler+0x2f5a>
 800cffc:	687b      	ldr	r3, [r7, #4]
 800cffe:	681b      	ldr	r3, [r3, #0]
 800d000:	4619      	mov	r1, r3
 800d002:	4b29      	ldr	r3, [pc, #164]	; (800d0a8 <HAL_DMA_IRQHandler+0x2f94>)
 800d004:	4299      	cmp	r1, r3
 800d006:	d02f      	beq.n	800d068 <HAL_DMA_IRQHandler+0x2f54>
 800d008:	687b      	ldr	r3, [r7, #4]
 800d00a:	681b      	ldr	r3, [r3, #0]
 800d00c:	4619      	mov	r1, r3
 800d00e:	4b27      	ldr	r3, [pc, #156]	; (800d0ac <HAL_DMA_IRQHandler+0x2f98>)
 800d010:	4299      	cmp	r1, r3
 800d012:	d026      	beq.n	800d062 <HAL_DMA_IRQHandler+0x2f4e>
 800d014:	687b      	ldr	r3, [r7, #4]
 800d016:	681b      	ldr	r3, [r3, #0]
 800d018:	4619      	mov	r1, r3
 800d01a:	4b25      	ldr	r3, [pc, #148]	; (800d0b0 <HAL_DMA_IRQHandler+0x2f9c>)
 800d01c:	4299      	cmp	r1, r3
 800d01e:	d01d      	beq.n	800d05c <HAL_DMA_IRQHandler+0x2f48>
 800d020:	687b      	ldr	r3, [r7, #4]
 800d022:	681b      	ldr	r3, [r3, #0]
 800d024:	4619      	mov	r1, r3
 800d026:	4b23      	ldr	r3, [pc, #140]	; (800d0b4 <HAL_DMA_IRQHandler+0x2fa0>)
 800d028:	4299      	cmp	r1, r3
 800d02a:	d014      	beq.n	800d056 <HAL_DMA_IRQHandler+0x2f42>
 800d02c:	687b      	ldr	r3, [r7, #4]
 800d02e:	681b      	ldr	r3, [r3, #0]
 800d030:	4619      	mov	r1, r3
 800d032:	4b21      	ldr	r3, [pc, #132]	; (800d0b8 <HAL_DMA_IRQHandler+0x2fa4>)
 800d034:	4299      	cmp	r1, r3
 800d036:	d00b      	beq.n	800d050 <HAL_DMA_IRQHandler+0x2f3c>
 800d038:	687b      	ldr	r3, [r7, #4]
 800d03a:	681b      	ldr	r3, [r3, #0]
 800d03c:	4619      	mov	r1, r3
 800d03e:	4b1f      	ldr	r3, [pc, #124]	; (800d0bc <HAL_DMA_IRQHandler+0x2fa8>)
 800d040:	4299      	cmp	r1, r3
 800d042:	d102      	bne.n	800d04a <HAL_DMA_IRQHandler+0x2f36>
 800d044:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800d048:	e01e      	b.n	800d088 <HAL_DMA_IRQHandler+0x2f74>
 800d04a:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800d04e:	e01b      	b.n	800d088 <HAL_DMA_IRQHandler+0x2f74>
 800d050:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800d054:	e018      	b.n	800d088 <HAL_DMA_IRQHandler+0x2f74>
 800d056:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800d05a:	e015      	b.n	800d088 <HAL_DMA_IRQHandler+0x2f74>
 800d05c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800d060:	e012      	b.n	800d088 <HAL_DMA_IRQHandler+0x2f74>
 800d062:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800d066:	e00f      	b.n	800d088 <HAL_DMA_IRQHandler+0x2f74>
 800d068:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800d06c:	e00c      	b.n	800d088 <HAL_DMA_IRQHandler+0x2f74>
 800d06e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800d072:	e009      	b.n	800d088 <HAL_DMA_IRQHandler+0x2f74>
 800d074:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800d078:	e006      	b.n	800d088 <HAL_DMA_IRQHandler+0x2f74>
 800d07a:	2320      	movs	r3, #32
 800d07c:	e004      	b.n	800d088 <HAL_DMA_IRQHandler+0x2f74>
 800d07e:	2320      	movs	r3, #32
 800d080:	e002      	b.n	800d088 <HAL_DMA_IRQHandler+0x2f74>
 800d082:	2320      	movs	r3, #32
 800d084:	e000      	b.n	800d088 <HAL_DMA_IRQHandler+0x2f74>
 800d086:	2320      	movs	r3, #32
 800d088:	60d3      	str	r3, [r2, #12]
 800d08a:	e190      	b.n	800d3ae <HAL_DMA_IRQHandler+0x329a>
 800d08c:	40026000 	.word	0x40026000
 800d090:	40026010 	.word	0x40026010
 800d094:	40026410 	.word	0x40026410
 800d098:	40026070 	.word	0x40026070
 800d09c:	40026470 	.word	0x40026470
 800d0a0:	40026028 	.word	0x40026028
 800d0a4:	40026428 	.word	0x40026428
 800d0a8:	40026088 	.word	0x40026088
 800d0ac:	40026488 	.word	0x40026488
 800d0b0:	40026040 	.word	0x40026040
 800d0b4:	40026440 	.word	0x40026440
 800d0b8:	400260a0 	.word	0x400260a0
 800d0bc:	400264a0 	.word	0x400264a0
 800d0c0:	40026458 	.word	0x40026458
 800d0c4:	40026400 	.word	0x40026400
 800d0c8:	687b      	ldr	r3, [r7, #4]
 800d0ca:	681b      	ldr	r3, [r3, #0]
 800d0cc:	461a      	mov	r2, r3
 800d0ce:	4b9f      	ldr	r3, [pc, #636]	; (800d34c <HAL_DMA_IRQHandler+0x3238>)
 800d0d0:	429a      	cmp	r2, r3
 800d0d2:	d96c      	bls.n	800d1ae <HAL_DMA_IRQHandler+0x309a>
 800d0d4:	4a9e      	ldr	r2, [pc, #632]	; (800d350 <HAL_DMA_IRQHandler+0x323c>)
 800d0d6:	687b      	ldr	r3, [r7, #4]
 800d0d8:	681b      	ldr	r3, [r3, #0]
 800d0da:	4619      	mov	r1, r3
 800d0dc:	4b9d      	ldr	r3, [pc, #628]	; (800d354 <HAL_DMA_IRQHandler+0x3240>)
 800d0de:	4299      	cmp	r1, r3
 800d0e0:	d062      	beq.n	800d1a8 <HAL_DMA_IRQHandler+0x3094>
 800d0e2:	687b      	ldr	r3, [r7, #4]
 800d0e4:	681b      	ldr	r3, [r3, #0]
 800d0e6:	4619      	mov	r1, r3
 800d0e8:	4b9b      	ldr	r3, [pc, #620]	; (800d358 <HAL_DMA_IRQHandler+0x3244>)
 800d0ea:	4299      	cmp	r1, r3
 800d0ec:	d05a      	beq.n	800d1a4 <HAL_DMA_IRQHandler+0x3090>
 800d0ee:	687b      	ldr	r3, [r7, #4]
 800d0f0:	681b      	ldr	r3, [r3, #0]
 800d0f2:	4619      	mov	r1, r3
 800d0f4:	4b99      	ldr	r3, [pc, #612]	; (800d35c <HAL_DMA_IRQHandler+0x3248>)
 800d0f6:	4299      	cmp	r1, r3
 800d0f8:	d052      	beq.n	800d1a0 <HAL_DMA_IRQHandler+0x308c>
 800d0fa:	687b      	ldr	r3, [r7, #4]
 800d0fc:	681b      	ldr	r3, [r3, #0]
 800d0fe:	4619      	mov	r1, r3
 800d100:	4b97      	ldr	r3, [pc, #604]	; (800d360 <HAL_DMA_IRQHandler+0x324c>)
 800d102:	4299      	cmp	r1, r3
 800d104:	d04a      	beq.n	800d19c <HAL_DMA_IRQHandler+0x3088>
 800d106:	687b      	ldr	r3, [r7, #4]
 800d108:	681b      	ldr	r3, [r3, #0]
 800d10a:	4619      	mov	r1, r3
 800d10c:	4b95      	ldr	r3, [pc, #596]	; (800d364 <HAL_DMA_IRQHandler+0x3250>)
 800d10e:	4299      	cmp	r1, r3
 800d110:	d041      	beq.n	800d196 <HAL_DMA_IRQHandler+0x3082>
 800d112:	687b      	ldr	r3, [r7, #4]
 800d114:	681b      	ldr	r3, [r3, #0]
 800d116:	4619      	mov	r1, r3
 800d118:	4b93      	ldr	r3, [pc, #588]	; (800d368 <HAL_DMA_IRQHandler+0x3254>)
 800d11a:	4299      	cmp	r1, r3
 800d11c:	d038      	beq.n	800d190 <HAL_DMA_IRQHandler+0x307c>
 800d11e:	687b      	ldr	r3, [r7, #4]
 800d120:	681b      	ldr	r3, [r3, #0]
 800d122:	4619      	mov	r1, r3
 800d124:	4b91      	ldr	r3, [pc, #580]	; (800d36c <HAL_DMA_IRQHandler+0x3258>)
 800d126:	4299      	cmp	r1, r3
 800d128:	d02f      	beq.n	800d18a <HAL_DMA_IRQHandler+0x3076>
 800d12a:	687b      	ldr	r3, [r7, #4]
 800d12c:	681b      	ldr	r3, [r3, #0]
 800d12e:	4619      	mov	r1, r3
 800d130:	4b8f      	ldr	r3, [pc, #572]	; (800d370 <HAL_DMA_IRQHandler+0x325c>)
 800d132:	4299      	cmp	r1, r3
 800d134:	d026      	beq.n	800d184 <HAL_DMA_IRQHandler+0x3070>
 800d136:	687b      	ldr	r3, [r7, #4]
 800d138:	681b      	ldr	r3, [r3, #0]
 800d13a:	4619      	mov	r1, r3
 800d13c:	4b8d      	ldr	r3, [pc, #564]	; (800d374 <HAL_DMA_IRQHandler+0x3260>)
 800d13e:	4299      	cmp	r1, r3
 800d140:	d01d      	beq.n	800d17e <HAL_DMA_IRQHandler+0x306a>
 800d142:	687b      	ldr	r3, [r7, #4]
 800d144:	681b      	ldr	r3, [r3, #0]
 800d146:	4619      	mov	r1, r3
 800d148:	4b8b      	ldr	r3, [pc, #556]	; (800d378 <HAL_DMA_IRQHandler+0x3264>)
 800d14a:	4299      	cmp	r1, r3
 800d14c:	d014      	beq.n	800d178 <HAL_DMA_IRQHandler+0x3064>
 800d14e:	687b      	ldr	r3, [r7, #4]
 800d150:	681b      	ldr	r3, [r3, #0]
 800d152:	4619      	mov	r1, r3
 800d154:	4b89      	ldr	r3, [pc, #548]	; (800d37c <HAL_DMA_IRQHandler+0x3268>)
 800d156:	4299      	cmp	r1, r3
 800d158:	d00b      	beq.n	800d172 <HAL_DMA_IRQHandler+0x305e>
 800d15a:	687b      	ldr	r3, [r7, #4]
 800d15c:	681b      	ldr	r3, [r3, #0]
 800d15e:	4619      	mov	r1, r3
 800d160:	4b87      	ldr	r3, [pc, #540]	; (800d380 <HAL_DMA_IRQHandler+0x326c>)
 800d162:	4299      	cmp	r1, r3
 800d164:	d102      	bne.n	800d16c <HAL_DMA_IRQHandler+0x3058>
 800d166:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800d16a:	e01e      	b.n	800d1aa <HAL_DMA_IRQHandler+0x3096>
 800d16c:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800d170:	e01b      	b.n	800d1aa <HAL_DMA_IRQHandler+0x3096>
 800d172:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800d176:	e018      	b.n	800d1aa <HAL_DMA_IRQHandler+0x3096>
 800d178:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800d17c:	e015      	b.n	800d1aa <HAL_DMA_IRQHandler+0x3096>
 800d17e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800d182:	e012      	b.n	800d1aa <HAL_DMA_IRQHandler+0x3096>
 800d184:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800d188:	e00f      	b.n	800d1aa <HAL_DMA_IRQHandler+0x3096>
 800d18a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800d18e:	e00c      	b.n	800d1aa <HAL_DMA_IRQHandler+0x3096>
 800d190:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800d194:	e009      	b.n	800d1aa <HAL_DMA_IRQHandler+0x3096>
 800d196:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800d19a:	e006      	b.n	800d1aa <HAL_DMA_IRQHandler+0x3096>
 800d19c:	2320      	movs	r3, #32
 800d19e:	e004      	b.n	800d1aa <HAL_DMA_IRQHandler+0x3096>
 800d1a0:	2320      	movs	r3, #32
 800d1a2:	e002      	b.n	800d1aa <HAL_DMA_IRQHandler+0x3096>
 800d1a4:	2320      	movs	r3, #32
 800d1a6:	e000      	b.n	800d1aa <HAL_DMA_IRQHandler+0x3096>
 800d1a8:	2320      	movs	r3, #32
 800d1aa:	6093      	str	r3, [r2, #8]
 800d1ac:	e0ff      	b.n	800d3ae <HAL_DMA_IRQHandler+0x329a>
 800d1ae:	687b      	ldr	r3, [r7, #4]
 800d1b0:	681b      	ldr	r3, [r3, #0]
 800d1b2:	461a      	mov	r2, r3
 800d1b4:	4b73      	ldr	r3, [pc, #460]	; (800d384 <HAL_DMA_IRQHandler+0x3270>)
 800d1b6:	429a      	cmp	r2, r3
 800d1b8:	d96c      	bls.n	800d294 <HAL_DMA_IRQHandler+0x3180>
 800d1ba:	4a73      	ldr	r2, [pc, #460]	; (800d388 <HAL_DMA_IRQHandler+0x3274>)
 800d1bc:	687b      	ldr	r3, [r7, #4]
 800d1be:	681b      	ldr	r3, [r3, #0]
 800d1c0:	4619      	mov	r1, r3
 800d1c2:	4b64      	ldr	r3, [pc, #400]	; (800d354 <HAL_DMA_IRQHandler+0x3240>)
 800d1c4:	4299      	cmp	r1, r3
 800d1c6:	d062      	beq.n	800d28e <HAL_DMA_IRQHandler+0x317a>
 800d1c8:	687b      	ldr	r3, [r7, #4]
 800d1ca:	681b      	ldr	r3, [r3, #0]
 800d1cc:	4619      	mov	r1, r3
 800d1ce:	4b62      	ldr	r3, [pc, #392]	; (800d358 <HAL_DMA_IRQHandler+0x3244>)
 800d1d0:	4299      	cmp	r1, r3
 800d1d2:	d05a      	beq.n	800d28a <HAL_DMA_IRQHandler+0x3176>
 800d1d4:	687b      	ldr	r3, [r7, #4]
 800d1d6:	681b      	ldr	r3, [r3, #0]
 800d1d8:	4619      	mov	r1, r3
 800d1da:	4b60      	ldr	r3, [pc, #384]	; (800d35c <HAL_DMA_IRQHandler+0x3248>)
 800d1dc:	4299      	cmp	r1, r3
 800d1de:	d052      	beq.n	800d286 <HAL_DMA_IRQHandler+0x3172>
 800d1e0:	687b      	ldr	r3, [r7, #4]
 800d1e2:	681b      	ldr	r3, [r3, #0]
 800d1e4:	4619      	mov	r1, r3
 800d1e6:	4b5e      	ldr	r3, [pc, #376]	; (800d360 <HAL_DMA_IRQHandler+0x324c>)
 800d1e8:	4299      	cmp	r1, r3
 800d1ea:	d04a      	beq.n	800d282 <HAL_DMA_IRQHandler+0x316e>
 800d1ec:	687b      	ldr	r3, [r7, #4]
 800d1ee:	681b      	ldr	r3, [r3, #0]
 800d1f0:	4619      	mov	r1, r3
 800d1f2:	4b5c      	ldr	r3, [pc, #368]	; (800d364 <HAL_DMA_IRQHandler+0x3250>)
 800d1f4:	4299      	cmp	r1, r3
 800d1f6:	d041      	beq.n	800d27c <HAL_DMA_IRQHandler+0x3168>
 800d1f8:	687b      	ldr	r3, [r7, #4]
 800d1fa:	681b      	ldr	r3, [r3, #0]
 800d1fc:	4619      	mov	r1, r3
 800d1fe:	4b5a      	ldr	r3, [pc, #360]	; (800d368 <HAL_DMA_IRQHandler+0x3254>)
 800d200:	4299      	cmp	r1, r3
 800d202:	d038      	beq.n	800d276 <HAL_DMA_IRQHandler+0x3162>
 800d204:	687b      	ldr	r3, [r7, #4]
 800d206:	681b      	ldr	r3, [r3, #0]
 800d208:	4619      	mov	r1, r3
 800d20a:	4b58      	ldr	r3, [pc, #352]	; (800d36c <HAL_DMA_IRQHandler+0x3258>)
 800d20c:	4299      	cmp	r1, r3
 800d20e:	d02f      	beq.n	800d270 <HAL_DMA_IRQHandler+0x315c>
 800d210:	687b      	ldr	r3, [r7, #4]
 800d212:	681b      	ldr	r3, [r3, #0]
 800d214:	4619      	mov	r1, r3
 800d216:	4b56      	ldr	r3, [pc, #344]	; (800d370 <HAL_DMA_IRQHandler+0x325c>)
 800d218:	4299      	cmp	r1, r3
 800d21a:	d026      	beq.n	800d26a <HAL_DMA_IRQHandler+0x3156>
 800d21c:	687b      	ldr	r3, [r7, #4]
 800d21e:	681b      	ldr	r3, [r3, #0]
 800d220:	4619      	mov	r1, r3
 800d222:	4b54      	ldr	r3, [pc, #336]	; (800d374 <HAL_DMA_IRQHandler+0x3260>)
 800d224:	4299      	cmp	r1, r3
 800d226:	d01d      	beq.n	800d264 <HAL_DMA_IRQHandler+0x3150>
 800d228:	687b      	ldr	r3, [r7, #4]
 800d22a:	681b      	ldr	r3, [r3, #0]
 800d22c:	4619      	mov	r1, r3
 800d22e:	4b52      	ldr	r3, [pc, #328]	; (800d378 <HAL_DMA_IRQHandler+0x3264>)
 800d230:	4299      	cmp	r1, r3
 800d232:	d014      	beq.n	800d25e <HAL_DMA_IRQHandler+0x314a>
 800d234:	687b      	ldr	r3, [r7, #4]
 800d236:	681b      	ldr	r3, [r3, #0]
 800d238:	4619      	mov	r1, r3
 800d23a:	4b50      	ldr	r3, [pc, #320]	; (800d37c <HAL_DMA_IRQHandler+0x3268>)
 800d23c:	4299      	cmp	r1, r3
 800d23e:	d00b      	beq.n	800d258 <HAL_DMA_IRQHandler+0x3144>
 800d240:	687b      	ldr	r3, [r7, #4]
 800d242:	681b      	ldr	r3, [r3, #0]
 800d244:	4619      	mov	r1, r3
 800d246:	4b4e      	ldr	r3, [pc, #312]	; (800d380 <HAL_DMA_IRQHandler+0x326c>)
 800d248:	4299      	cmp	r1, r3
 800d24a:	d102      	bne.n	800d252 <HAL_DMA_IRQHandler+0x313e>
 800d24c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800d250:	e01e      	b.n	800d290 <HAL_DMA_IRQHandler+0x317c>
 800d252:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800d256:	e01b      	b.n	800d290 <HAL_DMA_IRQHandler+0x317c>
 800d258:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800d25c:	e018      	b.n	800d290 <HAL_DMA_IRQHandler+0x317c>
 800d25e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800d262:	e015      	b.n	800d290 <HAL_DMA_IRQHandler+0x317c>
 800d264:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800d268:	e012      	b.n	800d290 <HAL_DMA_IRQHandler+0x317c>
 800d26a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800d26e:	e00f      	b.n	800d290 <HAL_DMA_IRQHandler+0x317c>
 800d270:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800d274:	e00c      	b.n	800d290 <HAL_DMA_IRQHandler+0x317c>
 800d276:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800d27a:	e009      	b.n	800d290 <HAL_DMA_IRQHandler+0x317c>
 800d27c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800d280:	e006      	b.n	800d290 <HAL_DMA_IRQHandler+0x317c>
 800d282:	2320      	movs	r3, #32
 800d284:	e004      	b.n	800d290 <HAL_DMA_IRQHandler+0x317c>
 800d286:	2320      	movs	r3, #32
 800d288:	e002      	b.n	800d290 <HAL_DMA_IRQHandler+0x317c>
 800d28a:	2320      	movs	r3, #32
 800d28c:	e000      	b.n	800d290 <HAL_DMA_IRQHandler+0x317c>
 800d28e:	2320      	movs	r3, #32
 800d290:	60d3      	str	r3, [r2, #12]
 800d292:	e08c      	b.n	800d3ae <HAL_DMA_IRQHandler+0x329a>
 800d294:	4a3c      	ldr	r2, [pc, #240]	; (800d388 <HAL_DMA_IRQHandler+0x3274>)
 800d296:	687b      	ldr	r3, [r7, #4]
 800d298:	681b      	ldr	r3, [r3, #0]
 800d29a:	4619      	mov	r1, r3
 800d29c:	4b2d      	ldr	r3, [pc, #180]	; (800d354 <HAL_DMA_IRQHandler+0x3240>)
 800d29e:	4299      	cmp	r1, r3
 800d2a0:	f000 8083 	beq.w	800d3aa <HAL_DMA_IRQHandler+0x3296>
 800d2a4:	687b      	ldr	r3, [r7, #4]
 800d2a6:	681b      	ldr	r3, [r3, #0]
 800d2a8:	4619      	mov	r1, r3
 800d2aa:	4b2b      	ldr	r3, [pc, #172]	; (800d358 <HAL_DMA_IRQHandler+0x3244>)
 800d2ac:	4299      	cmp	r1, r3
 800d2ae:	d07a      	beq.n	800d3a6 <HAL_DMA_IRQHandler+0x3292>
 800d2b0:	687b      	ldr	r3, [r7, #4]
 800d2b2:	681b      	ldr	r3, [r3, #0]
 800d2b4:	4619      	mov	r1, r3
 800d2b6:	4b29      	ldr	r3, [pc, #164]	; (800d35c <HAL_DMA_IRQHandler+0x3248>)
 800d2b8:	4299      	cmp	r1, r3
 800d2ba:	d072      	beq.n	800d3a2 <HAL_DMA_IRQHandler+0x328e>
 800d2bc:	687b      	ldr	r3, [r7, #4]
 800d2be:	681b      	ldr	r3, [r3, #0]
 800d2c0:	4619      	mov	r1, r3
 800d2c2:	4b27      	ldr	r3, [pc, #156]	; (800d360 <HAL_DMA_IRQHandler+0x324c>)
 800d2c4:	4299      	cmp	r1, r3
 800d2c6:	d06a      	beq.n	800d39e <HAL_DMA_IRQHandler+0x328a>
 800d2c8:	687b      	ldr	r3, [r7, #4]
 800d2ca:	681b      	ldr	r3, [r3, #0]
 800d2cc:	4619      	mov	r1, r3
 800d2ce:	4b25      	ldr	r3, [pc, #148]	; (800d364 <HAL_DMA_IRQHandler+0x3250>)
 800d2d0:	4299      	cmp	r1, r3
 800d2d2:	d061      	beq.n	800d398 <HAL_DMA_IRQHandler+0x3284>
 800d2d4:	687b      	ldr	r3, [r7, #4]
 800d2d6:	681b      	ldr	r3, [r3, #0]
 800d2d8:	4619      	mov	r1, r3
 800d2da:	4b23      	ldr	r3, [pc, #140]	; (800d368 <HAL_DMA_IRQHandler+0x3254>)
 800d2dc:	4299      	cmp	r1, r3
 800d2de:	d058      	beq.n	800d392 <HAL_DMA_IRQHandler+0x327e>
 800d2e0:	687b      	ldr	r3, [r7, #4]
 800d2e2:	681b      	ldr	r3, [r3, #0]
 800d2e4:	4619      	mov	r1, r3
 800d2e6:	4b21      	ldr	r3, [pc, #132]	; (800d36c <HAL_DMA_IRQHandler+0x3258>)
 800d2e8:	4299      	cmp	r1, r3
 800d2ea:	d04f      	beq.n	800d38c <HAL_DMA_IRQHandler+0x3278>
 800d2ec:	687b      	ldr	r3, [r7, #4]
 800d2ee:	681b      	ldr	r3, [r3, #0]
 800d2f0:	4619      	mov	r1, r3
 800d2f2:	4b1f      	ldr	r3, [pc, #124]	; (800d370 <HAL_DMA_IRQHandler+0x325c>)
 800d2f4:	4299      	cmp	r1, r3
 800d2f6:	d026      	beq.n	800d346 <HAL_DMA_IRQHandler+0x3232>
 800d2f8:	687b      	ldr	r3, [r7, #4]
 800d2fa:	681b      	ldr	r3, [r3, #0]
 800d2fc:	4619      	mov	r1, r3
 800d2fe:	4b1d      	ldr	r3, [pc, #116]	; (800d374 <HAL_DMA_IRQHandler+0x3260>)
 800d300:	4299      	cmp	r1, r3
 800d302:	d01d      	beq.n	800d340 <HAL_DMA_IRQHandler+0x322c>
 800d304:	687b      	ldr	r3, [r7, #4]
 800d306:	681b      	ldr	r3, [r3, #0]
 800d308:	4619      	mov	r1, r3
 800d30a:	4b1b      	ldr	r3, [pc, #108]	; (800d378 <HAL_DMA_IRQHandler+0x3264>)
 800d30c:	4299      	cmp	r1, r3
 800d30e:	d014      	beq.n	800d33a <HAL_DMA_IRQHandler+0x3226>
 800d310:	687b      	ldr	r3, [r7, #4]
 800d312:	681b      	ldr	r3, [r3, #0]
 800d314:	4619      	mov	r1, r3
 800d316:	4b19      	ldr	r3, [pc, #100]	; (800d37c <HAL_DMA_IRQHandler+0x3268>)
 800d318:	4299      	cmp	r1, r3
 800d31a:	d00b      	beq.n	800d334 <HAL_DMA_IRQHandler+0x3220>
 800d31c:	687b      	ldr	r3, [r7, #4]
 800d31e:	681b      	ldr	r3, [r3, #0]
 800d320:	4619      	mov	r1, r3
 800d322:	4b17      	ldr	r3, [pc, #92]	; (800d380 <HAL_DMA_IRQHandler+0x326c>)
 800d324:	4299      	cmp	r1, r3
 800d326:	d102      	bne.n	800d32e <HAL_DMA_IRQHandler+0x321a>
 800d328:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800d32c:	e03e      	b.n	800d3ac <HAL_DMA_IRQHandler+0x3298>
 800d32e:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800d332:	e03b      	b.n	800d3ac <HAL_DMA_IRQHandler+0x3298>
 800d334:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800d338:	e038      	b.n	800d3ac <HAL_DMA_IRQHandler+0x3298>
 800d33a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800d33e:	e035      	b.n	800d3ac <HAL_DMA_IRQHandler+0x3298>
 800d340:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800d344:	e032      	b.n	800d3ac <HAL_DMA_IRQHandler+0x3298>
 800d346:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800d34a:	e02f      	b.n	800d3ac <HAL_DMA_IRQHandler+0x3298>
 800d34c:	400260b8 	.word	0x400260b8
 800d350:	40026400 	.word	0x40026400
 800d354:	40026010 	.word	0x40026010
 800d358:	40026410 	.word	0x40026410
 800d35c:	40026070 	.word	0x40026070
 800d360:	40026470 	.word	0x40026470
 800d364:	40026028 	.word	0x40026028
 800d368:	40026428 	.word	0x40026428
 800d36c:	40026088 	.word	0x40026088
 800d370:	40026488 	.word	0x40026488
 800d374:	40026040 	.word	0x40026040
 800d378:	40026440 	.word	0x40026440
 800d37c:	400260a0 	.word	0x400260a0
 800d380:	400264a0 	.word	0x400264a0
 800d384:	40026058 	.word	0x40026058
 800d388:	40026000 	.word	0x40026000
 800d38c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800d390:	e00c      	b.n	800d3ac <HAL_DMA_IRQHandler+0x3298>
 800d392:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800d396:	e009      	b.n	800d3ac <HAL_DMA_IRQHandler+0x3298>
 800d398:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800d39c:	e006      	b.n	800d3ac <HAL_DMA_IRQHandler+0x3298>
 800d39e:	2320      	movs	r3, #32
 800d3a0:	e004      	b.n	800d3ac <HAL_DMA_IRQHandler+0x3298>
 800d3a2:	2320      	movs	r3, #32
 800d3a4:	e002      	b.n	800d3ac <HAL_DMA_IRQHandler+0x3298>
 800d3a6:	2320      	movs	r3, #32
 800d3a8:	e000      	b.n	800d3ac <HAL_DMA_IRQHandler+0x3298>
 800d3aa:	2320      	movs	r3, #32
 800d3ac:	6093      	str	r3, [r2, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_NONE;
 800d3ae:	687b      	ldr	r3, [r7, #4]
 800d3b0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800d3b2:	687b      	ldr	r3, [r7, #4]
 800d3b4:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY_MEM0;
 800d3b6:	687b      	ldr	r3, [r7, #4]
 800d3b8:	2211      	movs	r2, #17
 800d3ba:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);      
 800d3be:	687b      	ldr	r3, [r7, #4]
 800d3c0:	2200      	movs	r2, #0
 800d3c2:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        if(hdma->XferCpltCallback != NULL)
 800d3c6:	687b      	ldr	r3, [r7, #4]
 800d3c8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800d3ca:	2b00      	cmp	r3, #0
 800d3cc:	d003      	beq.n	800d3d6 <HAL_DMA_IRQHandler+0x32c2>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
 800d3ce:	687b      	ldr	r3, [r7, #4]
 800d3d0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800d3d2:	6878      	ldr	r0, [r7, #4]
 800d3d4:	4798      	blx	r3
        }
      }
    }
  }
}
 800d3d6:	3708      	adds	r7, #8
 800d3d8:	46bd      	mov	sp, r7
 800d3da:	bd80      	pop	{r7, pc}

0800d3dc <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800d3dc:	b480      	push	{r7}
 800d3de:	b089      	sub	sp, #36	; 0x24
 800d3e0:	af00      	add	r7, sp, #0
 800d3e2:	6078      	str	r0, [r7, #4]
 800d3e4:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00;
 800d3e6:	2300      	movs	r3, #0
 800d3e8:	61fb      	str	r3, [r7, #28]
  uint32_t ioposition = 0x00;
 800d3ea:	2300      	movs	r3, #0
 800d3ec:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00;
 800d3ee:	2300      	movs	r3, #0
 800d3f0:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00;
 800d3f2:	2300      	movs	r3, #0
 800d3f4:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 800d3f6:	2300      	movs	r3, #0
 800d3f8:	61fb      	str	r3, [r7, #28]
 800d3fa:	e171      	b.n	800d6e0 <HAL_GPIO_Init+0x304>
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 800d3fc:	69fb      	ldr	r3, [r7, #28]
 800d3fe:	2201      	movs	r2, #1
 800d400:	fa02 f303 	lsl.w	r3, r2, r3
 800d404:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 800d406:	683b      	ldr	r3, [r7, #0]
 800d408:	681a      	ldr	r2, [r3, #0]
 800d40a:	697b      	ldr	r3, [r7, #20]
 800d40c:	4013      	ands	r3, r2
 800d40e:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
 800d410:	693a      	ldr	r2, [r7, #16]
 800d412:	697b      	ldr	r3, [r7, #20]
 800d414:	429a      	cmp	r2, r3
 800d416:	f040 8160 	bne.w	800d6da <HAL_GPIO_Init+0x2fe>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800d41a:	683b      	ldr	r3, [r7, #0]
 800d41c:	685b      	ldr	r3, [r3, #4]
 800d41e:	2b02      	cmp	r3, #2
 800d420:	d003      	beq.n	800d42a <HAL_GPIO_Init+0x4e>
 800d422:	683b      	ldr	r3, [r7, #0]
 800d424:	685b      	ldr	r3, [r3, #4]
 800d426:	2b12      	cmp	r3, #18
 800d428:	d122      	bne.n	800d470 <HAL_GPIO_Init+0x94>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 800d42a:	69fb      	ldr	r3, [r7, #28]
 800d42c:	08da      	lsrs	r2, r3, #3
 800d42e:	687b      	ldr	r3, [r7, #4]
 800d430:	3208      	adds	r2, #8
 800d432:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800d436:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 800d438:	69fb      	ldr	r3, [r7, #28]
 800d43a:	f003 0307 	and.w	r3, r3, #7
 800d43e:	009b      	lsls	r3, r3, #2
 800d440:	461a      	mov	r2, r3
 800d442:	230f      	movs	r3, #15
 800d444:	4093      	lsls	r3, r2
 800d446:	43db      	mvns	r3, r3
 800d448:	69ba      	ldr	r2, [r7, #24]
 800d44a:	4013      	ands	r3, r2
 800d44c:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 800d44e:	683b      	ldr	r3, [r7, #0]
 800d450:	691b      	ldr	r3, [r3, #16]
 800d452:	69fa      	ldr	r2, [r7, #28]
 800d454:	f002 0207 	and.w	r2, r2, #7
 800d458:	0092      	lsls	r2, r2, #2
 800d45a:	4093      	lsls	r3, r2
 800d45c:	69ba      	ldr	r2, [r7, #24]
 800d45e:	4313      	orrs	r3, r2
 800d460:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3] = temp;
 800d462:	69fb      	ldr	r3, [r7, #28]
 800d464:	08da      	lsrs	r2, r3, #3
 800d466:	687b      	ldr	r3, [r7, #4]
 800d468:	3208      	adds	r2, #8
 800d46a:	69b9      	ldr	r1, [r7, #24]
 800d46c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800d470:	687b      	ldr	r3, [r7, #4]
 800d472:	681b      	ldr	r3, [r3, #0]
 800d474:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 800d476:	69fb      	ldr	r3, [r7, #28]
 800d478:	005b      	lsls	r3, r3, #1
 800d47a:	461a      	mov	r2, r3
 800d47c:	2303      	movs	r3, #3
 800d47e:	4093      	lsls	r3, r2
 800d480:	43db      	mvns	r3, r3
 800d482:	69ba      	ldr	r2, [r7, #24]
 800d484:	4013      	ands	r3, r2
 800d486:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 800d488:	683b      	ldr	r3, [r7, #0]
 800d48a:	685b      	ldr	r3, [r3, #4]
 800d48c:	f003 0303 	and.w	r3, r3, #3
 800d490:	69fa      	ldr	r2, [r7, #28]
 800d492:	0052      	lsls	r2, r2, #1
 800d494:	4093      	lsls	r3, r2
 800d496:	69ba      	ldr	r2, [r7, #24]
 800d498:	4313      	orrs	r3, r2
 800d49a:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 800d49c:	687b      	ldr	r3, [r7, #4]
 800d49e:	69ba      	ldr	r2, [r7, #24]
 800d4a0:	601a      	str	r2, [r3, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800d4a2:	683b      	ldr	r3, [r7, #0]
 800d4a4:	685b      	ldr	r3, [r3, #4]
 800d4a6:	2b01      	cmp	r3, #1
 800d4a8:	d00b      	beq.n	800d4c2 <HAL_GPIO_Init+0xe6>
 800d4aa:	683b      	ldr	r3, [r7, #0]
 800d4ac:	685b      	ldr	r3, [r3, #4]
 800d4ae:	2b02      	cmp	r3, #2
 800d4b0:	d007      	beq.n	800d4c2 <HAL_GPIO_Init+0xe6>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800d4b2:	683b      	ldr	r3, [r7, #0]
 800d4b4:	685b      	ldr	r3, [r3, #4]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800d4b6:	2b11      	cmp	r3, #17
 800d4b8:	d003      	beq.n	800d4c2 <HAL_GPIO_Init+0xe6>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800d4ba:	683b      	ldr	r3, [r7, #0]
 800d4bc:	685b      	ldr	r3, [r3, #4]
 800d4be:	2b12      	cmp	r3, #18
 800d4c0:	d12f      	bne.n	800d522 <HAL_GPIO_Init+0x146>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 800d4c2:	687b      	ldr	r3, [r7, #4]
 800d4c4:	689b      	ldr	r3, [r3, #8]
 800d4c6:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 800d4c8:	69fb      	ldr	r3, [r7, #28]
 800d4ca:	005b      	lsls	r3, r3, #1
 800d4cc:	461a      	mov	r2, r3
 800d4ce:	2303      	movs	r3, #3
 800d4d0:	4093      	lsls	r3, r2
 800d4d2:	43db      	mvns	r3, r3
 800d4d4:	69ba      	ldr	r2, [r7, #24]
 800d4d6:	4013      	ands	r3, r2
 800d4d8:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2));
 800d4da:	683b      	ldr	r3, [r7, #0]
 800d4dc:	68db      	ldr	r3, [r3, #12]
 800d4de:	69fa      	ldr	r2, [r7, #28]
 800d4e0:	0052      	lsls	r2, r2, #1
 800d4e2:	4093      	lsls	r3, r2
 800d4e4:	69ba      	ldr	r2, [r7, #24]
 800d4e6:	4313      	orrs	r3, r2
 800d4e8:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 800d4ea:	687b      	ldr	r3, [r7, #4]
 800d4ec:	69ba      	ldr	r2, [r7, #24]
 800d4ee:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 800d4f0:	687b      	ldr	r3, [r7, #4]
 800d4f2:	685b      	ldr	r3, [r3, #4]
 800d4f4:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 800d4f6:	69fb      	ldr	r3, [r7, #28]
 800d4f8:	2201      	movs	r2, #1
 800d4fa:	fa02 f303 	lsl.w	r3, r2, r3
 800d4fe:	43db      	mvns	r3, r3
 800d500:	69ba      	ldr	r2, [r7, #24]
 800d502:	4013      	ands	r3, r2
 800d504:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 800d506:	683b      	ldr	r3, [r7, #0]
 800d508:	685b      	ldr	r3, [r3, #4]
 800d50a:	f003 0310 	and.w	r3, r3, #16
 800d50e:	091a      	lsrs	r2, r3, #4
 800d510:	69fb      	ldr	r3, [r7, #28]
 800d512:	fa02 f303 	lsl.w	r3, r2, r3
 800d516:	69ba      	ldr	r2, [r7, #24]
 800d518:	4313      	orrs	r3, r2
 800d51a:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 800d51c:	687b      	ldr	r3, [r7, #4]
 800d51e:	69ba      	ldr	r2, [r7, #24]
 800d520:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 800d522:	687b      	ldr	r3, [r7, #4]
 800d524:	68db      	ldr	r3, [r3, #12]
 800d526:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 800d528:	69fb      	ldr	r3, [r7, #28]
 800d52a:	005b      	lsls	r3, r3, #1
 800d52c:	461a      	mov	r2, r3
 800d52e:	2303      	movs	r3, #3
 800d530:	4093      	lsls	r3, r2
 800d532:	43db      	mvns	r3, r3
 800d534:	69ba      	ldr	r2, [r7, #24]
 800d536:	4013      	ands	r3, r2
 800d538:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2));
 800d53a:	683b      	ldr	r3, [r7, #0]
 800d53c:	689b      	ldr	r3, [r3, #8]
 800d53e:	69fa      	ldr	r2, [r7, #28]
 800d540:	0052      	lsls	r2, r2, #1
 800d542:	4093      	lsls	r3, r2
 800d544:	69ba      	ldr	r2, [r7, #24]
 800d546:	4313      	orrs	r3, r2
 800d548:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
 800d54a:	687b      	ldr	r3, [r7, #4]
 800d54c:	69ba      	ldr	r2, [r7, #24]
 800d54e:	60da      	str	r2, [r3, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800d550:	683b      	ldr	r3, [r7, #0]
 800d552:	685b      	ldr	r3, [r3, #4]
 800d554:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800d558:	2b00      	cmp	r3, #0
 800d55a:	f000 80be 	beq.w	800d6da <HAL_GPIO_Init+0x2fe>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800d55e:	4a65      	ldr	r2, [pc, #404]	; (800d6f4 <HAL_GPIO_Init+0x318>)
 800d560:	4b64      	ldr	r3, [pc, #400]	; (800d6f4 <HAL_GPIO_Init+0x318>)
 800d562:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800d564:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800d568:	6453      	str	r3, [r2, #68]	; 0x44
 800d56a:	4b62      	ldr	r3, [pc, #392]	; (800d6f4 <HAL_GPIO_Init+0x318>)
 800d56c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800d56e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800d572:	60fb      	str	r3, [r7, #12]
 800d574:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2];
 800d576:	4a60      	ldr	r2, [pc, #384]	; (800d6f8 <HAL_GPIO_Init+0x31c>)
 800d578:	69fb      	ldr	r3, [r7, #28]
 800d57a:	089b      	lsrs	r3, r3, #2
 800d57c:	3302      	adds	r3, #2
 800d57e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800d582:	61bb      	str	r3, [r7, #24]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 800d584:	69fb      	ldr	r3, [r7, #28]
 800d586:	f003 0303 	and.w	r3, r3, #3
 800d58a:	009b      	lsls	r3, r3, #2
 800d58c:	461a      	mov	r2, r3
 800d58e:	230f      	movs	r3, #15
 800d590:	4093      	lsls	r3, r2
 800d592:	43db      	mvns	r3, r3
 800d594:	69ba      	ldr	r2, [r7, #24]
 800d596:	4013      	ands	r3, r2
 800d598:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 800d59a:	687b      	ldr	r3, [r7, #4]
 800d59c:	4a57      	ldr	r2, [pc, #348]	; (800d6fc <HAL_GPIO_Init+0x320>)
 800d59e:	4293      	cmp	r3, r2
 800d5a0:	d037      	beq.n	800d612 <HAL_GPIO_Init+0x236>
 800d5a2:	687b      	ldr	r3, [r7, #4]
 800d5a4:	4a56      	ldr	r2, [pc, #344]	; (800d700 <HAL_GPIO_Init+0x324>)
 800d5a6:	4293      	cmp	r3, r2
 800d5a8:	d031      	beq.n	800d60e <HAL_GPIO_Init+0x232>
 800d5aa:	687b      	ldr	r3, [r7, #4]
 800d5ac:	4a55      	ldr	r2, [pc, #340]	; (800d704 <HAL_GPIO_Init+0x328>)
 800d5ae:	4293      	cmp	r3, r2
 800d5b0:	d02b      	beq.n	800d60a <HAL_GPIO_Init+0x22e>
 800d5b2:	687b      	ldr	r3, [r7, #4]
 800d5b4:	4a54      	ldr	r2, [pc, #336]	; (800d708 <HAL_GPIO_Init+0x32c>)
 800d5b6:	4293      	cmp	r3, r2
 800d5b8:	d025      	beq.n	800d606 <HAL_GPIO_Init+0x22a>
 800d5ba:	687b      	ldr	r3, [r7, #4]
 800d5bc:	4a53      	ldr	r2, [pc, #332]	; (800d70c <HAL_GPIO_Init+0x330>)
 800d5be:	4293      	cmp	r3, r2
 800d5c0:	d01f      	beq.n	800d602 <HAL_GPIO_Init+0x226>
 800d5c2:	687b      	ldr	r3, [r7, #4]
 800d5c4:	4a52      	ldr	r2, [pc, #328]	; (800d710 <HAL_GPIO_Init+0x334>)
 800d5c6:	4293      	cmp	r3, r2
 800d5c8:	d019      	beq.n	800d5fe <HAL_GPIO_Init+0x222>
 800d5ca:	687b      	ldr	r3, [r7, #4]
 800d5cc:	4a51      	ldr	r2, [pc, #324]	; (800d714 <HAL_GPIO_Init+0x338>)
 800d5ce:	4293      	cmp	r3, r2
 800d5d0:	d013      	beq.n	800d5fa <HAL_GPIO_Init+0x21e>
 800d5d2:	687b      	ldr	r3, [r7, #4]
 800d5d4:	4a50      	ldr	r2, [pc, #320]	; (800d718 <HAL_GPIO_Init+0x33c>)
 800d5d6:	4293      	cmp	r3, r2
 800d5d8:	d00d      	beq.n	800d5f6 <HAL_GPIO_Init+0x21a>
 800d5da:	687b      	ldr	r3, [r7, #4]
 800d5dc:	4a4f      	ldr	r2, [pc, #316]	; (800d71c <HAL_GPIO_Init+0x340>)
 800d5de:	4293      	cmp	r3, r2
 800d5e0:	d007      	beq.n	800d5f2 <HAL_GPIO_Init+0x216>
 800d5e2:	687b      	ldr	r3, [r7, #4]
 800d5e4:	4a4e      	ldr	r2, [pc, #312]	; (800d720 <HAL_GPIO_Init+0x344>)
 800d5e6:	4293      	cmp	r3, r2
 800d5e8:	d101      	bne.n	800d5ee <HAL_GPIO_Init+0x212>
 800d5ea:	2309      	movs	r3, #9
 800d5ec:	e012      	b.n	800d614 <HAL_GPIO_Init+0x238>
 800d5ee:	230a      	movs	r3, #10
 800d5f0:	e010      	b.n	800d614 <HAL_GPIO_Init+0x238>
 800d5f2:	2308      	movs	r3, #8
 800d5f4:	e00e      	b.n	800d614 <HAL_GPIO_Init+0x238>
 800d5f6:	2307      	movs	r3, #7
 800d5f8:	e00c      	b.n	800d614 <HAL_GPIO_Init+0x238>
 800d5fa:	2306      	movs	r3, #6
 800d5fc:	e00a      	b.n	800d614 <HAL_GPIO_Init+0x238>
 800d5fe:	2305      	movs	r3, #5
 800d600:	e008      	b.n	800d614 <HAL_GPIO_Init+0x238>
 800d602:	2304      	movs	r3, #4
 800d604:	e006      	b.n	800d614 <HAL_GPIO_Init+0x238>
 800d606:	2303      	movs	r3, #3
 800d608:	e004      	b.n	800d614 <HAL_GPIO_Init+0x238>
 800d60a:	2302      	movs	r3, #2
 800d60c:	e002      	b.n	800d614 <HAL_GPIO_Init+0x238>
 800d60e:	2301      	movs	r3, #1
 800d610:	e000      	b.n	800d614 <HAL_GPIO_Init+0x238>
 800d612:	2300      	movs	r3, #0
 800d614:	69fa      	ldr	r2, [r7, #28]
 800d616:	f002 0203 	and.w	r2, r2, #3
 800d61a:	0092      	lsls	r2, r2, #2
 800d61c:	4093      	lsls	r3, r2
 800d61e:	69ba      	ldr	r2, [r7, #24]
 800d620:	4313      	orrs	r3, r2
 800d622:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2] = temp;
 800d624:	4934      	ldr	r1, [pc, #208]	; (800d6f8 <HAL_GPIO_Init+0x31c>)
 800d626:	69fb      	ldr	r3, [r7, #28]
 800d628:	089b      	lsrs	r3, r3, #2
 800d62a:	3302      	adds	r3, #2
 800d62c:	69ba      	ldr	r2, [r7, #24]
 800d62e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 800d632:	4b3c      	ldr	r3, [pc, #240]	; (800d724 <HAL_GPIO_Init+0x348>)
 800d634:	681b      	ldr	r3, [r3, #0]
 800d636:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800d638:	693b      	ldr	r3, [r7, #16]
 800d63a:	43db      	mvns	r3, r3
 800d63c:	69ba      	ldr	r2, [r7, #24]
 800d63e:	4013      	ands	r3, r2
 800d640:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800d642:	683b      	ldr	r3, [r7, #0]
 800d644:	685b      	ldr	r3, [r3, #4]
 800d646:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800d64a:	2b00      	cmp	r3, #0
 800d64c:	d003      	beq.n	800d656 <HAL_GPIO_Init+0x27a>
        {
          temp |= iocurrent;
 800d64e:	69ba      	ldr	r2, [r7, #24]
 800d650:	693b      	ldr	r3, [r7, #16]
 800d652:	4313      	orrs	r3, r2
 800d654:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
 800d656:	4a33      	ldr	r2, [pc, #204]	; (800d724 <HAL_GPIO_Init+0x348>)
 800d658:	69bb      	ldr	r3, [r7, #24]
 800d65a:	6013      	str	r3, [r2, #0]

        temp = EXTI->EMR;
 800d65c:	4b31      	ldr	r3, [pc, #196]	; (800d724 <HAL_GPIO_Init+0x348>)
 800d65e:	685b      	ldr	r3, [r3, #4]
 800d660:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800d662:	693b      	ldr	r3, [r7, #16]
 800d664:	43db      	mvns	r3, r3
 800d666:	69ba      	ldr	r2, [r7, #24]
 800d668:	4013      	ands	r3, r2
 800d66a:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800d66c:	683b      	ldr	r3, [r7, #0]
 800d66e:	685b      	ldr	r3, [r3, #4]
 800d670:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d674:	2b00      	cmp	r3, #0
 800d676:	d003      	beq.n	800d680 <HAL_GPIO_Init+0x2a4>
        {
          temp |= iocurrent;
 800d678:	69ba      	ldr	r2, [r7, #24]
 800d67a:	693b      	ldr	r3, [r7, #16]
 800d67c:	4313      	orrs	r3, r2
 800d67e:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
 800d680:	4a28      	ldr	r2, [pc, #160]	; (800d724 <HAL_GPIO_Init+0x348>)
 800d682:	69bb      	ldr	r3, [r7, #24]
 800d684:	6053      	str	r3, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800d686:	4b27      	ldr	r3, [pc, #156]	; (800d724 <HAL_GPIO_Init+0x348>)
 800d688:	689b      	ldr	r3, [r3, #8]
 800d68a:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800d68c:	693b      	ldr	r3, [r7, #16]
 800d68e:	43db      	mvns	r3, r3
 800d690:	69ba      	ldr	r2, [r7, #24]
 800d692:	4013      	ands	r3, r2
 800d694:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800d696:	683b      	ldr	r3, [r7, #0]
 800d698:	685b      	ldr	r3, [r3, #4]
 800d69a:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800d69e:	2b00      	cmp	r3, #0
 800d6a0:	d003      	beq.n	800d6aa <HAL_GPIO_Init+0x2ce>
        {
          temp |= iocurrent;
 800d6a2:	69ba      	ldr	r2, [r7, #24]
 800d6a4:	693b      	ldr	r3, [r7, #16]
 800d6a6:	4313      	orrs	r3, r2
 800d6a8:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
 800d6aa:	4a1e      	ldr	r2, [pc, #120]	; (800d724 <HAL_GPIO_Init+0x348>)
 800d6ac:	69bb      	ldr	r3, [r7, #24]
 800d6ae:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 800d6b0:	4b1c      	ldr	r3, [pc, #112]	; (800d724 <HAL_GPIO_Init+0x348>)
 800d6b2:	68db      	ldr	r3, [r3, #12]
 800d6b4:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800d6b6:	693b      	ldr	r3, [r7, #16]
 800d6b8:	43db      	mvns	r3, r3
 800d6ba:	69ba      	ldr	r2, [r7, #24]
 800d6bc:	4013      	ands	r3, r2
 800d6be:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800d6c0:	683b      	ldr	r3, [r7, #0]
 800d6c2:	685b      	ldr	r3, [r3, #4]
 800d6c4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800d6c8:	2b00      	cmp	r3, #0
 800d6ca:	d003      	beq.n	800d6d4 <HAL_GPIO_Init+0x2f8>
        {
          temp |= iocurrent;
 800d6cc:	69ba      	ldr	r2, [r7, #24]
 800d6ce:	693b      	ldr	r3, [r7, #16]
 800d6d0:	4313      	orrs	r3, r2
 800d6d2:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
 800d6d4:	4a13      	ldr	r2, [pc, #76]	; (800d724 <HAL_GPIO_Init+0x348>)
 800d6d6:	69bb      	ldr	r3, [r7, #24]
 800d6d8:	60d3      	str	r3, [r2, #12]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 800d6da:	69fb      	ldr	r3, [r7, #28]
 800d6dc:	3301      	adds	r3, #1
 800d6de:	61fb      	str	r3, [r7, #28]
 800d6e0:	69fb      	ldr	r3, [r7, #28]
 800d6e2:	2b0f      	cmp	r3, #15
 800d6e4:	f67f ae8a 	bls.w	800d3fc <HAL_GPIO_Init+0x20>
        }
        EXTI->FTSR = temp;
      }
    }
  }
}
 800d6e8:	3724      	adds	r7, #36	; 0x24
 800d6ea:	46bd      	mov	sp, r7
 800d6ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d6f0:	4770      	bx	lr
 800d6f2:	bf00      	nop
 800d6f4:	40023800 	.word	0x40023800
 800d6f8:	40013800 	.word	0x40013800
 800d6fc:	40020000 	.word	0x40020000
 800d700:	40020400 	.word	0x40020400
 800d704:	40020800 	.word	0x40020800
 800d708:	40020c00 	.word	0x40020c00
 800d70c:	40021000 	.word	0x40021000
 800d710:	40021400 	.word	0x40021400
 800d714:	40021800 	.word	0x40021800
 800d718:	40021c00 	.word	0x40021c00
 800d71c:	40022000 	.word	0x40022000
 800d720:	40022400 	.word	0x40022400
 800d724:	40013c00 	.word	0x40013c00

0800d728 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 800d728:	b480      	push	{r7}
 800d72a:	b087      	sub	sp, #28
 800d72c:	af00      	add	r7, sp, #0
 800d72e:	6078      	str	r0, [r7, #4]
 800d730:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00;
 800d732:	2300      	movs	r3, #0
 800d734:	613b      	str	r3, [r7, #16]
  uint32_t iocurrent = 0x00;
 800d736:	2300      	movs	r3, #0
 800d738:	60fb      	str	r3, [r7, #12]
  uint32_t tmp = 0x00;
 800d73a:	2300      	movs	r3, #0
 800d73c:	60bb      	str	r3, [r7, #8]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  
  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 800d73e:	2300      	movs	r3, #0
 800d740:	617b      	str	r3, [r7, #20]
 800d742:	e0da      	b.n	800d8fa <HAL_GPIO_DeInit+0x1d2>
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 800d744:	697b      	ldr	r3, [r7, #20]
 800d746:	2201      	movs	r2, #1
 800d748:	fa02 f303 	lsl.w	r3, r2, r3
 800d74c:	613b      	str	r3, [r7, #16]
    /* Get the current IO position */
    iocurrent = (GPIO_Pin) & ioposition;
 800d74e:	683a      	ldr	r2, [r7, #0]
 800d750:	693b      	ldr	r3, [r7, #16]
 800d752:	4013      	ands	r3, r2
 800d754:	60fb      	str	r3, [r7, #12]

    if(iocurrent == ioposition)
 800d756:	68fa      	ldr	r2, [r7, #12]
 800d758:	693b      	ldr	r3, [r7, #16]
 800d75a:	429a      	cmp	r2, r3
 800d75c:	f040 80ca 	bne.w	800d8f4 <HAL_GPIO_DeInit+0x1cc>
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO Direction in Input Floating Mode */
      GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2));
 800d760:	687b      	ldr	r3, [r7, #4]
 800d762:	681a      	ldr	r2, [r3, #0]
 800d764:	697b      	ldr	r3, [r7, #20]
 800d766:	005b      	lsls	r3, r3, #1
 800d768:	4619      	mov	r1, r3
 800d76a:	2303      	movs	r3, #3
 800d76c:	408b      	lsls	r3, r1
 800d76e:	43db      	mvns	r3, r3
 800d770:	401a      	ands	r2, r3
 800d772:	687b      	ldr	r3, [r7, #4]
 800d774:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 800d776:	697b      	ldr	r3, [r7, #20]
 800d778:	08da      	lsrs	r2, r3, #3
 800d77a:	697b      	ldr	r3, [r7, #20]
 800d77c:	08d9      	lsrs	r1, r3, #3
 800d77e:	687b      	ldr	r3, [r7, #4]
 800d780:	3108      	adds	r1, #8
 800d782:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 800d786:	697b      	ldr	r3, [r7, #20]
 800d788:	f003 0307 	and.w	r3, r3, #7
 800d78c:	009b      	lsls	r3, r3, #2
 800d78e:	4618      	mov	r0, r3
 800d790:	230f      	movs	r3, #15
 800d792:	4083      	lsls	r3, r0
 800d794:	43db      	mvns	r3, r3
 800d796:	4019      	ands	r1, r3
 800d798:	687b      	ldr	r3, [r7, #4]
 800d79a:	3208      	adds	r2, #8
 800d79c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 800d7a0:	687b      	ldr	r3, [r7, #4]
 800d7a2:	689a      	ldr	r2, [r3, #8]
 800d7a4:	697b      	ldr	r3, [r7, #20]
 800d7a6:	005b      	lsls	r3, r3, #1
 800d7a8:	4619      	mov	r1, r3
 800d7aa:	2303      	movs	r3, #3
 800d7ac:	408b      	lsls	r3, r1
 800d7ae:	43db      	mvns	r3, r3
 800d7b0:	401a      	ands	r2, r3
 800d7b2:	687b      	ldr	r3, [r7, #4]
 800d7b4:	609a      	str	r2, [r3, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
 800d7b6:	687b      	ldr	r3, [r7, #4]
 800d7b8:	685a      	ldr	r2, [r3, #4]
 800d7ba:	697b      	ldr	r3, [r7, #20]
 800d7bc:	2101      	movs	r1, #1
 800d7be:	fa01 f303 	lsl.w	r3, r1, r3
 800d7c2:	43db      	mvns	r3, r3
 800d7c4:	401a      	ands	r2, r3
 800d7c6:	687b      	ldr	r3, [r7, #4]
 800d7c8:	605a      	str	r2, [r3, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 800d7ca:	687b      	ldr	r3, [r7, #4]
 800d7cc:	68da      	ldr	r2, [r3, #12]
 800d7ce:	697b      	ldr	r3, [r7, #20]
 800d7d0:	005b      	lsls	r3, r3, #1
 800d7d2:	4619      	mov	r1, r3
 800d7d4:	2303      	movs	r3, #3
 800d7d6:	408b      	lsls	r3, r1
 800d7d8:	43db      	mvns	r3, r3
 800d7da:	401a      	ands	r2, r3
 800d7dc:	687b      	ldr	r3, [r7, #4]
 800d7de:	60da      	str	r2, [r3, #12]

      /*------------------------- EXTI Mode Configuration --------------------*/
      tmp = SYSCFG->EXTICR[position >> 2];
 800d7e0:	4a4a      	ldr	r2, [pc, #296]	; (800d90c <HAL_GPIO_DeInit+0x1e4>)
 800d7e2:	697b      	ldr	r3, [r7, #20]
 800d7e4:	089b      	lsrs	r3, r3, #2
 800d7e6:	3302      	adds	r3, #2
 800d7e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800d7ec:	60bb      	str	r3, [r7, #8]
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 800d7ee:	697b      	ldr	r3, [r7, #20]
 800d7f0:	f003 0303 	and.w	r3, r3, #3
 800d7f4:	009b      	lsls	r3, r3, #2
 800d7f6:	461a      	mov	r2, r3
 800d7f8:	230f      	movs	r3, #15
 800d7fa:	4093      	lsls	r3, r2
 800d7fc:	68ba      	ldr	r2, [r7, #8]
 800d7fe:	4013      	ands	r3, r2
 800d800:	60bb      	str	r3, [r7, #8]
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03))))
 800d802:	687b      	ldr	r3, [r7, #4]
 800d804:	4a42      	ldr	r2, [pc, #264]	; (800d910 <HAL_GPIO_DeInit+0x1e8>)
 800d806:	4293      	cmp	r3, r2
 800d808:	d037      	beq.n	800d87a <HAL_GPIO_DeInit+0x152>
 800d80a:	687b      	ldr	r3, [r7, #4]
 800d80c:	4a41      	ldr	r2, [pc, #260]	; (800d914 <HAL_GPIO_DeInit+0x1ec>)
 800d80e:	4293      	cmp	r3, r2
 800d810:	d031      	beq.n	800d876 <HAL_GPIO_DeInit+0x14e>
 800d812:	687b      	ldr	r3, [r7, #4]
 800d814:	4a40      	ldr	r2, [pc, #256]	; (800d918 <HAL_GPIO_DeInit+0x1f0>)
 800d816:	4293      	cmp	r3, r2
 800d818:	d02b      	beq.n	800d872 <HAL_GPIO_DeInit+0x14a>
 800d81a:	687b      	ldr	r3, [r7, #4]
 800d81c:	4a3f      	ldr	r2, [pc, #252]	; (800d91c <HAL_GPIO_DeInit+0x1f4>)
 800d81e:	4293      	cmp	r3, r2
 800d820:	d025      	beq.n	800d86e <HAL_GPIO_DeInit+0x146>
 800d822:	687b      	ldr	r3, [r7, #4]
 800d824:	4a3e      	ldr	r2, [pc, #248]	; (800d920 <HAL_GPIO_DeInit+0x1f8>)
 800d826:	4293      	cmp	r3, r2
 800d828:	d01f      	beq.n	800d86a <HAL_GPIO_DeInit+0x142>
 800d82a:	687b      	ldr	r3, [r7, #4]
 800d82c:	4a3d      	ldr	r2, [pc, #244]	; (800d924 <HAL_GPIO_DeInit+0x1fc>)
 800d82e:	4293      	cmp	r3, r2
 800d830:	d019      	beq.n	800d866 <HAL_GPIO_DeInit+0x13e>
 800d832:	687b      	ldr	r3, [r7, #4]
 800d834:	4a3c      	ldr	r2, [pc, #240]	; (800d928 <HAL_GPIO_DeInit+0x200>)
 800d836:	4293      	cmp	r3, r2
 800d838:	d013      	beq.n	800d862 <HAL_GPIO_DeInit+0x13a>
 800d83a:	687b      	ldr	r3, [r7, #4]
 800d83c:	4a3b      	ldr	r2, [pc, #236]	; (800d92c <HAL_GPIO_DeInit+0x204>)
 800d83e:	4293      	cmp	r3, r2
 800d840:	d00d      	beq.n	800d85e <HAL_GPIO_DeInit+0x136>
 800d842:	687b      	ldr	r3, [r7, #4]
 800d844:	4a3a      	ldr	r2, [pc, #232]	; (800d930 <HAL_GPIO_DeInit+0x208>)
 800d846:	4293      	cmp	r3, r2
 800d848:	d007      	beq.n	800d85a <HAL_GPIO_DeInit+0x132>
 800d84a:	687b      	ldr	r3, [r7, #4]
 800d84c:	4a39      	ldr	r2, [pc, #228]	; (800d934 <HAL_GPIO_DeInit+0x20c>)
 800d84e:	4293      	cmp	r3, r2
 800d850:	d101      	bne.n	800d856 <HAL_GPIO_DeInit+0x12e>
 800d852:	2309      	movs	r3, #9
 800d854:	e012      	b.n	800d87c <HAL_GPIO_DeInit+0x154>
 800d856:	230a      	movs	r3, #10
 800d858:	e010      	b.n	800d87c <HAL_GPIO_DeInit+0x154>
 800d85a:	2308      	movs	r3, #8
 800d85c:	e00e      	b.n	800d87c <HAL_GPIO_DeInit+0x154>
 800d85e:	2307      	movs	r3, #7
 800d860:	e00c      	b.n	800d87c <HAL_GPIO_DeInit+0x154>
 800d862:	2306      	movs	r3, #6
 800d864:	e00a      	b.n	800d87c <HAL_GPIO_DeInit+0x154>
 800d866:	2305      	movs	r3, #5
 800d868:	e008      	b.n	800d87c <HAL_GPIO_DeInit+0x154>
 800d86a:	2304      	movs	r3, #4
 800d86c:	e006      	b.n	800d87c <HAL_GPIO_DeInit+0x154>
 800d86e:	2303      	movs	r3, #3
 800d870:	e004      	b.n	800d87c <HAL_GPIO_DeInit+0x154>
 800d872:	2302      	movs	r3, #2
 800d874:	e002      	b.n	800d87c <HAL_GPIO_DeInit+0x154>
 800d876:	2301      	movs	r3, #1
 800d878:	e000      	b.n	800d87c <HAL_GPIO_DeInit+0x154>
 800d87a:	2300      	movs	r3, #0
 800d87c:	697a      	ldr	r2, [r7, #20]
 800d87e:	f002 0203 	and.w	r2, r2, #3
 800d882:	0092      	lsls	r2, r2, #2
 800d884:	fa03 f202 	lsl.w	r2, r3, r2
 800d888:	68bb      	ldr	r3, [r7, #8]
 800d88a:	429a      	cmp	r2, r3
 800d88c:	d132      	bne.n	800d8f4 <HAL_GPIO_DeInit+0x1cc>
      {
        /* Configure the External Interrupt or event for the current IO */
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
 800d88e:	697b      	ldr	r3, [r7, #20]
 800d890:	f003 0303 	and.w	r3, r3, #3
 800d894:	009b      	lsls	r3, r3, #2
 800d896:	461a      	mov	r2, r3
 800d898:	230f      	movs	r3, #15
 800d89a:	4093      	lsls	r3, r2
 800d89c:	60bb      	str	r3, [r7, #8]
        SYSCFG->EXTICR[position >> 2] &= ~tmp;
 800d89e:	481b      	ldr	r0, [pc, #108]	; (800d90c <HAL_GPIO_DeInit+0x1e4>)
 800d8a0:	697b      	ldr	r3, [r7, #20]
 800d8a2:	089b      	lsrs	r3, r3, #2
 800d8a4:	4919      	ldr	r1, [pc, #100]	; (800d90c <HAL_GPIO_DeInit+0x1e4>)
 800d8a6:	697a      	ldr	r2, [r7, #20]
 800d8a8:	0892      	lsrs	r2, r2, #2
 800d8aa:	3202      	adds	r2, #2
 800d8ac:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
 800d8b0:	68ba      	ldr	r2, [r7, #8]
 800d8b2:	43d2      	mvns	r2, r2
 800d8b4:	400a      	ands	r2, r1
 800d8b6:	3302      	adds	r3, #2
 800d8b8:	f840 2023 	str.w	r2, [r0, r3, lsl #2]

        /* Clear EXTI line configuration */
        EXTI->IMR &= ~((uint32_t)iocurrent);
 800d8bc:	491e      	ldr	r1, [pc, #120]	; (800d938 <HAL_GPIO_DeInit+0x210>)
 800d8be:	4b1e      	ldr	r3, [pc, #120]	; (800d938 <HAL_GPIO_DeInit+0x210>)
 800d8c0:	681a      	ldr	r2, [r3, #0]
 800d8c2:	68fb      	ldr	r3, [r7, #12]
 800d8c4:	43db      	mvns	r3, r3
 800d8c6:	4013      	ands	r3, r2
 800d8c8:	600b      	str	r3, [r1, #0]
        EXTI->EMR &= ~((uint32_t)iocurrent);
 800d8ca:	491b      	ldr	r1, [pc, #108]	; (800d938 <HAL_GPIO_DeInit+0x210>)
 800d8cc:	4b1a      	ldr	r3, [pc, #104]	; (800d938 <HAL_GPIO_DeInit+0x210>)
 800d8ce:	685a      	ldr	r2, [r3, #4]
 800d8d0:	68fb      	ldr	r3, [r7, #12]
 800d8d2:	43db      	mvns	r3, r3
 800d8d4:	4013      	ands	r3, r2
 800d8d6:	604b      	str	r3, [r1, #4]

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR &= ~((uint32_t)iocurrent);
 800d8d8:	4917      	ldr	r1, [pc, #92]	; (800d938 <HAL_GPIO_DeInit+0x210>)
 800d8da:	4b17      	ldr	r3, [pc, #92]	; (800d938 <HAL_GPIO_DeInit+0x210>)
 800d8dc:	689a      	ldr	r2, [r3, #8]
 800d8de:	68fb      	ldr	r3, [r7, #12]
 800d8e0:	43db      	mvns	r3, r3
 800d8e2:	4013      	ands	r3, r2
 800d8e4:	608b      	str	r3, [r1, #8]
        EXTI->FTSR &= ~((uint32_t)iocurrent);
 800d8e6:	4914      	ldr	r1, [pc, #80]	; (800d938 <HAL_GPIO_DeInit+0x210>)
 800d8e8:	4b13      	ldr	r3, [pc, #76]	; (800d938 <HAL_GPIO_DeInit+0x210>)
 800d8ea:	68da      	ldr	r2, [r3, #12]
 800d8ec:	68fb      	ldr	r3, [r7, #12]
 800d8ee:	43db      	mvns	r3, r3
 800d8f0:	4013      	ands	r3, r2
 800d8f2:	60cb      	str	r3, [r1, #12]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  
  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 800d8f4:	697b      	ldr	r3, [r7, #20]
 800d8f6:	3301      	adds	r3, #1
 800d8f8:	617b      	str	r3, [r7, #20]
 800d8fa:	697b      	ldr	r3, [r7, #20]
 800d8fc:	2b0f      	cmp	r3, #15
 800d8fe:	f67f af21 	bls.w	800d744 <HAL_GPIO_DeInit+0x1c>
        EXTI->RTSR &= ~((uint32_t)iocurrent);
        EXTI->FTSR &= ~((uint32_t)iocurrent);
	  }
    }
  }
}
 800d902:	371c      	adds	r7, #28
 800d904:	46bd      	mov	sp, r7
 800d906:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d90a:	4770      	bx	lr
 800d90c:	40013800 	.word	0x40013800
 800d910:	40020000 	.word	0x40020000
 800d914:	40020400 	.word	0x40020400
 800d918:	40020800 	.word	0x40020800
 800d91c:	40020c00 	.word	0x40020c00
 800d920:	40021000 	.word	0x40021000
 800d924:	40021400 	.word	0x40021400
 800d928:	40021800 	.word	0x40021800
 800d92c:	40021c00 	.word	0x40021c00
 800d930:	40022000 	.word	0x40022000
 800d934:	40022400 	.word	0x40022400
 800d938:	40013c00 	.word	0x40013c00

0800d93c <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 800d93c:	b480      	push	{r7}
 800d93e:	b083      	sub	sp, #12
 800d940:	af00      	add	r7, sp, #0
 800d942:	6078      	str	r0, [r7, #4]
 800d944:	460b      	mov	r3, r1
 800d946:	807b      	strh	r3, [r7, #2]
 800d948:	4613      	mov	r3, r2
 800d94a:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 800d94c:	787b      	ldrb	r3, [r7, #1]
 800d94e:	2b00      	cmp	r3, #0
 800d950:	d003      	beq.n	800d95a <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 800d952:	887a      	ldrh	r2, [r7, #2]
 800d954:	687b      	ldr	r3, [r7, #4]
 800d956:	619a      	str	r2, [r3, #24]
 800d958:	e003      	b.n	800d962 <HAL_GPIO_WritePin+0x26>
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 800d95a:	887b      	ldrh	r3, [r7, #2]
 800d95c:	041a      	lsls	r2, r3, #16
 800d95e:	687b      	ldr	r3, [r7, #4]
 800d960:	619a      	str	r2, [r3, #24]
  }
}
 800d962:	370c      	adds	r7, #12
 800d964:	46bd      	mov	sp, r7
 800d966:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d96a:	4770      	bx	lr

0800d96c <HAL_MspInit>:
/**
  * @brief  Initializes the Global MSP.
  * @retval None
  */
void HAL_MspInit(void)
{
 800d96c:	b480      	push	{r7}
 800d96e:	af00      	add	r7, sp, #0
  /* NOTE : This function is generated automatically by STM32CubeMX and eventually  
            modified by the user
   */ 
}
 800d970:	46bd      	mov	sp, r7
 800d972:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d976:	4770      	bx	lr

0800d978 <HAL_PWREx_EnableOverDrive>:
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
 800d978:	b580      	push	{r7, lr}
 800d97a:	b082      	sub	sp, #8
 800d97c:	af00      	add	r7, sp, #0
  uint32_t tickstart = 0;
 800d97e:	2300      	movs	r3, #0
 800d980:	607b      	str	r3, [r7, #4]

  __HAL_RCC_PWR_CLK_ENABLE();
 800d982:	4a22      	ldr	r2, [pc, #136]	; (800da0c <HAL_PWREx_EnableOverDrive+0x94>)
 800d984:	4b21      	ldr	r3, [pc, #132]	; (800da0c <HAL_PWREx_EnableOverDrive+0x94>)
 800d986:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d988:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800d98c:	6413      	str	r3, [r2, #64]	; 0x40
 800d98e:	4b1f      	ldr	r3, [pc, #124]	; (800da0c <HAL_PWREx_EnableOverDrive+0x94>)
 800d990:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d992:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800d996:	603b      	str	r3, [r7, #0]
 800d998:	683b      	ldr	r3, [r7, #0]
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 800d99a:	4a1d      	ldr	r2, [pc, #116]	; (800da10 <HAL_PWREx_EnableOverDrive+0x98>)
 800d99c:	4b1c      	ldr	r3, [pc, #112]	; (800da10 <HAL_PWREx_EnableOverDrive+0x98>)
 800d99e:	681b      	ldr	r3, [r3, #0]
 800d9a0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800d9a4:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 800d9a6:	f7f9 f823 	bl	80069f0 <HAL_GetTick>
 800d9aa:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 800d9ac:	e009      	b.n	800d9c2 <HAL_PWREx_EnableOverDrive+0x4a>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 800d9ae:	f7f9 f81f 	bl	80069f0 <HAL_GetTick>
 800d9b2:	4602      	mov	r2, r0
 800d9b4:	687b      	ldr	r3, [r7, #4]
 800d9b6:	1ad3      	subs	r3, r2, r3
 800d9b8:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800d9bc:	d901      	bls.n	800d9c2 <HAL_PWREx_EnableOverDrive+0x4a>
    {
      return HAL_TIMEOUT;
 800d9be:	2303      	movs	r3, #3
 800d9c0:	e020      	b.n	800da04 <HAL_PWREx_EnableOverDrive+0x8c>
  __HAL_PWR_OVERDRIVE_ENABLE();

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 800d9c2:	4b13      	ldr	r3, [pc, #76]	; (800da10 <HAL_PWREx_EnableOverDrive+0x98>)
 800d9c4:	685b      	ldr	r3, [r3, #4]
 800d9c6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800d9ca:	2b00      	cmp	r3, #0
 800d9cc:	d0ef      	beq.n	800d9ae <HAL_PWREx_EnableOverDrive+0x36>
      return HAL_TIMEOUT;
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 800d9ce:	4a10      	ldr	r2, [pc, #64]	; (800da10 <HAL_PWREx_EnableOverDrive+0x98>)
 800d9d0:	4b0f      	ldr	r3, [pc, #60]	; (800da10 <HAL_PWREx_EnableOverDrive+0x98>)
 800d9d2:	681b      	ldr	r3, [r3, #0]
 800d9d4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800d9d8:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 800d9da:	f7f9 f809 	bl	80069f0 <HAL_GetTick>
 800d9de:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 800d9e0:	e009      	b.n	800d9f6 <HAL_PWREx_EnableOverDrive+0x7e>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 800d9e2:	f7f9 f805 	bl	80069f0 <HAL_GetTick>
 800d9e6:	4602      	mov	r2, r0
 800d9e8:	687b      	ldr	r3, [r7, #4]
 800d9ea:	1ad3      	subs	r3, r2, r3
 800d9ec:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800d9f0:	d901      	bls.n	800d9f6 <HAL_PWREx_EnableOverDrive+0x7e>
    {
      return HAL_TIMEOUT;
 800d9f2:	2303      	movs	r3, #3
 800d9f4:	e006      	b.n	800da04 <HAL_PWREx_EnableOverDrive+0x8c>
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 800d9f6:	4b06      	ldr	r3, [pc, #24]	; (800da10 <HAL_PWREx_EnableOverDrive+0x98>)
 800d9f8:	685b      	ldr	r3, [r3, #4]
 800d9fa:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d9fe:	2b00      	cmp	r3, #0
 800da00:	d0ef      	beq.n	800d9e2 <HAL_PWREx_EnableOverDrive+0x6a>
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
 800da02:	2300      	movs	r3, #0
}
 800da04:	4618      	mov	r0, r3
 800da06:	3708      	adds	r7, #8
 800da08:	46bd      	mov	sp, r7
 800da0a:	bd80      	pop	{r7, pc}
 800da0c:	40023800 	.word	0x40023800
 800da10:	40007000 	.word	0x40007000

0800da14 <HAL_RCC_OscConfig>:
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800da14:	b580      	push	{r7, lr}
 800da16:	b08e      	sub	sp, #56	; 0x38
 800da18:	af00      	add	r7, sp, #0
 800da1a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0;  
 800da1c:	2300      	movs	r3, #0
 800da1e:	637b      	str	r3, [r7, #52]	; 0x34
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800da20:	687b      	ldr	r3, [r7, #4]
 800da22:	681b      	ldr	r3, [r3, #0]
 800da24:	f003 0301 	and.w	r3, r3, #1
 800da28:	2b00      	cmp	r3, #0
 800da2a:	f000 80ab 	beq.w	800db84 <HAL_RCC_OscConfig+0x170>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 800da2e:	4ba6      	ldr	r3, [pc, #664]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800da30:	689b      	ldr	r3, [r3, #8]
 800da32:	f003 030c 	and.w	r3, r3, #12
 800da36:	2b04      	cmp	r3, #4
 800da38:	d00b      	beq.n	800da52 <HAL_RCC_OscConfig+0x3e>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800da3a:	4ba3      	ldr	r3, [pc, #652]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800da3c:	689b      	ldr	r3, [r3, #8]
 800da3e:	f003 030c 	and.w	r3, r3, #12
 800da42:	2b08      	cmp	r3, #8
 800da44:	d112      	bne.n	800da6c <HAL_RCC_OscConfig+0x58>
 800da46:	4ba0      	ldr	r3, [pc, #640]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800da48:	685b      	ldr	r3, [r3, #4]
 800da4a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800da4e:	2b00      	cmp	r3, #0
 800da50:	d00c      	beq.n	800da6c <HAL_RCC_OscConfig+0x58>
    {
	  if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800da52:	4b9d      	ldr	r3, [pc, #628]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800da54:	681b      	ldr	r3, [r3, #0]
 800da56:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800da5a:	2b00      	cmp	r3, #0
 800da5c:	d005      	beq.n	800da6a <HAL_RCC_OscConfig+0x56>
 800da5e:	687b      	ldr	r3, [r7, #4]
 800da60:	685b      	ldr	r3, [r3, #4]
 800da62:	2b00      	cmp	r3, #0
 800da64:	d101      	bne.n	800da6a <HAL_RCC_OscConfig+0x56>
      {
        return HAL_ERROR;
 800da66:	2301      	movs	r3, #1
 800da68:	e2a3      	b.n	800dfb2 <HAL_RCC_OscConfig+0x59e>
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
    {
	  if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800da6a:	e08b      	b.n	800db84 <HAL_RCC_OscConfig+0x170>
      }
    }
    else
    {
      /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 800da6c:	4a96      	ldr	r2, [pc, #600]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800da6e:	4b96      	ldr	r3, [pc, #600]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800da70:	681b      	ldr	r3, [r3, #0]
 800da72:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800da76:	6013      	str	r3, [r2, #0]
 800da78:	4a93      	ldr	r2, [pc, #588]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800da7a:	4b93      	ldr	r3, [pc, #588]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800da7c:	681b      	ldr	r3, [r3, #0]
 800da7e:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800da82:	6013      	str	r3, [r2, #0]
 800da84:	4a90      	ldr	r2, [pc, #576]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800da86:	4b90      	ldr	r3, [pc, #576]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800da88:	681b      	ldr	r3, [r3, #0]
 800da8a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800da8e:	6013      	str	r3, [r2, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800da90:	f7f8 ffae 	bl	80069f0 <HAL_GetTick>
 800da94:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800da96:	e00a      	b.n	800daae <HAL_RCC_OscConfig+0x9a>
      {
        if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800da98:	f7f8 ffaa 	bl	80069f0 <HAL_GetTick>
 800da9c:	4602      	mov	r2, r0
 800da9e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800daa0:	1ad3      	subs	r3, r2, r3
 800daa2:	f241 3288 	movw	r2, #5000	; 0x1388
 800daa6:	4293      	cmp	r3, r2
 800daa8:	d901      	bls.n	800daae <HAL_RCC_OscConfig+0x9a>
        {
          return HAL_TIMEOUT;
 800daaa:	2303      	movs	r3, #3
 800daac:	e281      	b.n	800dfb2 <HAL_RCC_OscConfig+0x59e>
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800daae:	4b86      	ldr	r3, [pc, #536]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dab0:	681b      	ldr	r3, [r3, #0]
 800dab2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800dab6:	2b00      	cmp	r3, #0
 800dab8:	d1ee      	bne.n	800da98 <HAL_RCC_OscConfig+0x84>
          return HAL_TIMEOUT;
        }
      }
      
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800daba:	4a83      	ldr	r2, [pc, #524]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dabc:	4b82      	ldr	r3, [pc, #520]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dabe:	681b      	ldr	r3, [r3, #0]
 800dac0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800dac4:	6013      	str	r3, [r2, #0]
 800dac6:	687b      	ldr	r3, [r7, #4]
 800dac8:	685b      	ldr	r3, [r3, #4]
 800daca:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800dace:	d10c      	bne.n	800daea <HAL_RCC_OscConfig+0xd6>
 800dad0:	4a7d      	ldr	r2, [pc, #500]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dad2:	4b7d      	ldr	r3, [pc, #500]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dad4:	681b      	ldr	r3, [r3, #0]
 800dad6:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800dada:	6013      	str	r3, [r2, #0]
 800dadc:	4a7a      	ldr	r2, [pc, #488]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dade:	4b7a      	ldr	r3, [pc, #488]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dae0:	681b      	ldr	r3, [r3, #0]
 800dae2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800dae6:	6013      	str	r3, [r2, #0]
 800dae8:	e01d      	b.n	800db26 <HAL_RCC_OscConfig+0x112>
 800daea:	687b      	ldr	r3, [r7, #4]
 800daec:	685b      	ldr	r3, [r3, #4]
 800daee:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 800daf2:	d10c      	bne.n	800db0e <HAL_RCC_OscConfig+0xfa>
 800daf4:	4a74      	ldr	r2, [pc, #464]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800daf6:	4b74      	ldr	r3, [pc, #464]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800daf8:	681b      	ldr	r3, [r3, #0]
 800dafa:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800dafe:	6013      	str	r3, [r2, #0]
 800db00:	4a71      	ldr	r2, [pc, #452]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800db02:	4b71      	ldr	r3, [pc, #452]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800db04:	681b      	ldr	r3, [r3, #0]
 800db06:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800db0a:	6013      	str	r3, [r2, #0]
 800db0c:	e00b      	b.n	800db26 <HAL_RCC_OscConfig+0x112>
 800db0e:	4a6e      	ldr	r2, [pc, #440]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800db10:	4b6d      	ldr	r3, [pc, #436]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800db12:	681b      	ldr	r3, [r3, #0]
 800db14:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800db18:	6013      	str	r3, [r2, #0]
 800db1a:	4a6b      	ldr	r2, [pc, #428]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800db1c:	4b6a      	ldr	r3, [pc, #424]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800db1e:	681b      	ldr	r3, [r3, #0]
 800db20:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800db24:	6013      	str	r3, [r2, #0]
      
      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800db26:	687b      	ldr	r3, [r7, #4]
 800db28:	685b      	ldr	r3, [r3, #4]
 800db2a:	2b00      	cmp	r3, #0
 800db2c:	d015      	beq.n	800db5a <HAL_RCC_OscConfig+0x146>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800db2e:	f7f8 ff5f 	bl	80069f0 <HAL_GetTick>
 800db32:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800db34:	e00a      	b.n	800db4c <HAL_RCC_OscConfig+0x138>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800db36:	f7f8 ff5b 	bl	80069f0 <HAL_GetTick>
 800db3a:	4602      	mov	r2, r0
 800db3c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800db3e:	1ad3      	subs	r3, r2, r3
 800db40:	f241 3288 	movw	r2, #5000	; 0x1388
 800db44:	4293      	cmp	r3, r2
 800db46:	d901      	bls.n	800db4c <HAL_RCC_OscConfig+0x138>
          {
            return HAL_TIMEOUT;
 800db48:	2303      	movs	r3, #3
 800db4a:	e232      	b.n	800dfb2 <HAL_RCC_OscConfig+0x59e>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800db4c:	4b5e      	ldr	r3, [pc, #376]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800db4e:	681b      	ldr	r3, [r3, #0]
 800db50:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800db54:	2b00      	cmp	r3, #0
 800db56:	d0ee      	beq.n	800db36 <HAL_RCC_OscConfig+0x122>
 800db58:	e014      	b.n	800db84 <HAL_RCC_OscConfig+0x170>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800db5a:	f7f8 ff49 	bl	80069f0 <HAL_GetTick>
 800db5e:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800db60:	e00a      	b.n	800db78 <HAL_RCC_OscConfig+0x164>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800db62:	f7f8 ff45 	bl	80069f0 <HAL_GetTick>
 800db66:	4602      	mov	r2, r0
 800db68:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800db6a:	1ad3      	subs	r3, r2, r3
 800db6c:	f241 3288 	movw	r2, #5000	; 0x1388
 800db70:	4293      	cmp	r3, r2
 800db72:	d901      	bls.n	800db78 <HAL_RCC_OscConfig+0x164>
          {
            return HAL_TIMEOUT;
 800db74:	2303      	movs	r3, #3
 800db76:	e21c      	b.n	800dfb2 <HAL_RCC_OscConfig+0x59e>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800db78:	4b53      	ldr	r3, [pc, #332]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800db7a:	681b      	ldr	r3, [r3, #0]
 800db7c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800db80:	2b00      	cmp	r3, #0
 800db82:	d1ee      	bne.n	800db62 <HAL_RCC_OscConfig+0x14e>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800db84:	687b      	ldr	r3, [r7, #4]
 800db86:	681b      	ldr	r3, [r3, #0]
 800db88:	f003 0302 	and.w	r3, r3, #2
 800db8c:	2b00      	cmp	r3, #0
 800db8e:	d07d      	beq.n	800dc8c <HAL_RCC_OscConfig+0x278>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 800db90:	4b4d      	ldr	r3, [pc, #308]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800db92:	689b      	ldr	r3, [r3, #8]
 800db94:	f003 030c 	and.w	r3, r3, #12
 800db98:	2b00      	cmp	r3, #0
 800db9a:	d00b      	beq.n	800dbb4 <HAL_RCC_OscConfig+0x1a0>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800db9c:	4b4a      	ldr	r3, [pc, #296]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800db9e:	689b      	ldr	r3, [r3, #8]
 800dba0:	f003 030c 	and.w	r3, r3, #12
 800dba4:	2b08      	cmp	r3, #8
 800dba6:	d126      	bne.n	800dbf6 <HAL_RCC_OscConfig+0x1e2>
 800dba8:	4b47      	ldr	r3, [pc, #284]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dbaa:	685b      	ldr	r3, [r3, #4]
 800dbac:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800dbb0:	2b00      	cmp	r3, #0
 800dbb2:	d120      	bne.n	800dbf6 <HAL_RCC_OscConfig+0x1e2>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800dbb4:	4b44      	ldr	r3, [pc, #272]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dbb6:	681b      	ldr	r3, [r3, #0]
 800dbb8:	f003 0302 	and.w	r3, r3, #2
 800dbbc:	2b00      	cmp	r3, #0
 800dbbe:	d005      	beq.n	800dbcc <HAL_RCC_OscConfig+0x1b8>
 800dbc0:	687b      	ldr	r3, [r7, #4]
 800dbc2:	68db      	ldr	r3, [r3, #12]
 800dbc4:	2b01      	cmp	r3, #1
 800dbc6:	d001      	beq.n	800dbcc <HAL_RCC_OscConfig+0x1b8>
      {
        return HAL_ERROR;
 800dbc8:	2301      	movs	r3, #1
 800dbca:	e1f2      	b.n	800dfb2 <HAL_RCC_OscConfig+0x59e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800dbcc:	483e      	ldr	r0, [pc, #248]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dbce:	4b3e      	ldr	r3, [pc, #248]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dbd0:	681b      	ldr	r3, [r3, #0]
 800dbd2:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 800dbd6:	687b      	ldr	r3, [r7, #4]
 800dbd8:	6919      	ldr	r1, [r3, #16]
 800dbda:	23f8      	movs	r3, #248	; 0xf8
 800dbdc:	633b      	str	r3, [r7, #48]	; 0x30
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800dbde:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800dbe0:	fa93 f3a3 	rbit	r3, r3
 800dbe4:	62fb      	str	r3, [r7, #44]	; 0x2c
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800dbe6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800dbe8:	fab3 f383 	clz	r3, r3
 800dbec:	fa01 f303 	lsl.w	r3, r1, r3
 800dbf0:	4313      	orrs	r3, r2
 800dbf2:	6003      	str	r3, [r0, #0]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800dbf4:	e04a      	b.n	800dc8c <HAL_RCC_OscConfig+0x278>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 800dbf6:	687b      	ldr	r3, [r7, #4]
 800dbf8:	68db      	ldr	r3, [r3, #12]
 800dbfa:	2b00      	cmp	r3, #0
 800dbfc:	d02d      	beq.n	800dc5a <HAL_RCC_OscConfig+0x246>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800dbfe:	4a32      	ldr	r2, [pc, #200]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dc00:	4b31      	ldr	r3, [pc, #196]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dc02:	681b      	ldr	r3, [r3, #0]
 800dc04:	f043 0301 	orr.w	r3, r3, #1
 800dc08:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800dc0a:	f7f8 fef1 	bl	80069f0 <HAL_GetTick>
 800dc0e:	6378      	str	r0, [r7, #52]	; 0x34

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800dc10:	e008      	b.n	800dc24 <HAL_RCC_OscConfig+0x210>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800dc12:	f7f8 feed 	bl	80069f0 <HAL_GetTick>
 800dc16:	4602      	mov	r2, r0
 800dc18:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dc1a:	1ad3      	subs	r3, r2, r3
 800dc1c:	2b64      	cmp	r3, #100	; 0x64
 800dc1e:	d901      	bls.n	800dc24 <HAL_RCC_OscConfig+0x210>
          {
            return HAL_TIMEOUT;
 800dc20:	2303      	movs	r3, #3
 800dc22:	e1c6      	b.n	800dfb2 <HAL_RCC_OscConfig+0x59e>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800dc24:	4b28      	ldr	r3, [pc, #160]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dc26:	681b      	ldr	r3, [r3, #0]
 800dc28:	f003 0302 	and.w	r3, r3, #2
 800dc2c:	2b00      	cmp	r3, #0
 800dc2e:	d0f0      	beq.n	800dc12 <HAL_RCC_OscConfig+0x1fe>
            return HAL_TIMEOUT;
          }
        }
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800dc30:	4825      	ldr	r0, [pc, #148]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dc32:	4b25      	ldr	r3, [pc, #148]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dc34:	681b      	ldr	r3, [r3, #0]
 800dc36:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 800dc3a:	687b      	ldr	r3, [r7, #4]
 800dc3c:	6919      	ldr	r1, [r3, #16]
 800dc3e:	23f8      	movs	r3, #248	; 0xf8
 800dc40:	62bb      	str	r3, [r7, #40]	; 0x28
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800dc42:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800dc44:	fa93 f3a3 	rbit	r3, r3
 800dc48:	627b      	str	r3, [r7, #36]	; 0x24
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800dc4a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800dc4c:	fab3 f383 	clz	r3, r3
 800dc50:	fa01 f303 	lsl.w	r3, r1, r3
 800dc54:	4313      	orrs	r3, r2
 800dc56:	6003      	str	r3, [r0, #0]
 800dc58:	e018      	b.n	800dc8c <HAL_RCC_OscConfig+0x278>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800dc5a:	4a1b      	ldr	r2, [pc, #108]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dc5c:	4b1a      	ldr	r3, [pc, #104]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dc5e:	681b      	ldr	r3, [r3, #0]
 800dc60:	f023 0301 	bic.w	r3, r3, #1
 800dc64:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800dc66:	f7f8 fec3 	bl	80069f0 <HAL_GetTick>
 800dc6a:	6378      	str	r0, [r7, #52]	; 0x34
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800dc6c:	e008      	b.n	800dc80 <HAL_RCC_OscConfig+0x26c>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800dc6e:	f7f8 febf 	bl	80069f0 <HAL_GetTick>
 800dc72:	4602      	mov	r2, r0
 800dc74:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dc76:	1ad3      	subs	r3, r2, r3
 800dc78:	2b64      	cmp	r3, #100	; 0x64
 800dc7a:	d901      	bls.n	800dc80 <HAL_RCC_OscConfig+0x26c>
          {
            return HAL_TIMEOUT;
 800dc7c:	2303      	movs	r3, #3
 800dc7e:	e198      	b.n	800dfb2 <HAL_RCC_OscConfig+0x59e>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800dc80:	4b11      	ldr	r3, [pc, #68]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dc82:	681b      	ldr	r3, [r3, #0]
 800dc84:	f003 0302 	and.w	r3, r3, #2
 800dc88:	2b00      	cmp	r3, #0
 800dc8a:	d1f0      	bne.n	800dc6e <HAL_RCC_OscConfig+0x25a>
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800dc8c:	687b      	ldr	r3, [r7, #4]
 800dc8e:	681b      	ldr	r3, [r3, #0]
 800dc90:	f003 0308 	and.w	r3, r3, #8
 800dc94:	2b00      	cmp	r3, #0
 800dc96:	d039      	beq.n	800dd0c <HAL_RCC_OscConfig+0x2f8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 800dc98:	687b      	ldr	r3, [r7, #4]
 800dc9a:	695b      	ldr	r3, [r3, #20]
 800dc9c:	2b00      	cmp	r3, #0
 800dc9e:	d01c      	beq.n	800dcda <HAL_RCC_OscConfig+0x2c6>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800dca0:	4a09      	ldr	r2, [pc, #36]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dca2:	4b09      	ldr	r3, [pc, #36]	; (800dcc8 <HAL_RCC_OscConfig+0x2b4>)
 800dca4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800dca6:	f043 0301 	orr.w	r3, r3, #1
 800dcaa:	6753      	str	r3, [r2, #116]	; 0x74
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800dcac:	f7f8 fea0 	bl	80069f0 <HAL_GetTick>
 800dcb0:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800dcb2:	e00b      	b.n	800dccc <HAL_RCC_OscConfig+0x2b8>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800dcb4:	f7f8 fe9c 	bl	80069f0 <HAL_GetTick>
 800dcb8:	4602      	mov	r2, r0
 800dcba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dcbc:	1ad3      	subs	r3, r2, r3
 800dcbe:	2b64      	cmp	r3, #100	; 0x64
 800dcc0:	d904      	bls.n	800dccc <HAL_RCC_OscConfig+0x2b8>
        {
          return HAL_TIMEOUT;
 800dcc2:	2303      	movs	r3, #3
 800dcc4:	e175      	b.n	800dfb2 <HAL_RCC_OscConfig+0x59e>
 800dcc6:	bf00      	nop
 800dcc8:	40023800 	.word	0x40023800
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800dccc:	4ba8      	ldr	r3, [pc, #672]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800dcce:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800dcd0:	f003 0302 	and.w	r3, r3, #2
 800dcd4:	2b00      	cmp	r3, #0
 800dcd6:	d0ed      	beq.n	800dcb4 <HAL_RCC_OscConfig+0x2a0>
 800dcd8:	e018      	b.n	800dd0c <HAL_RCC_OscConfig+0x2f8>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 800dcda:	4aa5      	ldr	r2, [pc, #660]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800dcdc:	4ba4      	ldr	r3, [pc, #656]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800dcde:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800dce0:	f023 0301 	bic.w	r3, r3, #1
 800dce4:	6753      	str	r3, [r2, #116]	; 0x74
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800dce6:	f7f8 fe83 	bl	80069f0 <HAL_GetTick>
 800dcea:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800dcec:	e008      	b.n	800dd00 <HAL_RCC_OscConfig+0x2ec>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800dcee:	f7f8 fe7f 	bl	80069f0 <HAL_GetTick>
 800dcf2:	4602      	mov	r2, r0
 800dcf4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dcf6:	1ad3      	subs	r3, r2, r3
 800dcf8:	2b64      	cmp	r3, #100	; 0x64
 800dcfa:	d901      	bls.n	800dd00 <HAL_RCC_OscConfig+0x2ec>
        {
          return HAL_TIMEOUT;
 800dcfc:	2303      	movs	r3, #3
 800dcfe:	e158      	b.n	800dfb2 <HAL_RCC_OscConfig+0x59e>
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800dd00:	4b9b      	ldr	r3, [pc, #620]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800dd02:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800dd04:	f003 0302 	and.w	r3, r3, #2
 800dd08:	2b00      	cmp	r3, #0
 800dd0a:	d1f0      	bne.n	800dcee <HAL_RCC_OscConfig+0x2da>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800dd0c:	687b      	ldr	r3, [r7, #4]
 800dd0e:	681b      	ldr	r3, [r3, #0]
 800dd10:	f003 0304 	and.w	r3, r3, #4
 800dd14:	2b00      	cmp	r3, #0
 800dd16:	f000 80af 	beq.w	800de78 <HAL_RCC_OscConfig+0x464>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 800dd1a:	4a95      	ldr	r2, [pc, #596]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800dd1c:	4b94      	ldr	r3, [pc, #592]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800dd1e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800dd20:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800dd24:	6413      	str	r3, [r2, #64]	; 0x40
 800dd26:	4b92      	ldr	r3, [pc, #584]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800dd28:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800dd2a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800dd2e:	60bb      	str	r3, [r7, #8]
 800dd30:	68bb      	ldr	r3, [r7, #8]
    
    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 800dd32:	4a90      	ldr	r2, [pc, #576]	; (800df74 <HAL_RCC_OscConfig+0x560>)
 800dd34:	4b8f      	ldr	r3, [pc, #572]	; (800df74 <HAL_RCC_OscConfig+0x560>)
 800dd36:	681b      	ldr	r3, [r3, #0]
 800dd38:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800dd3c:	6013      	str	r3, [r2, #0]
    
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 800dd3e:	f7f8 fe57 	bl	80069f0 <HAL_GetTick>
 800dd42:	6378      	str	r0, [r7, #52]	; 0x34
    
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 800dd44:	e008      	b.n	800dd58 <HAL_RCC_OscConfig+0x344>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 800dd46:	f7f8 fe53 	bl	80069f0 <HAL_GetTick>
 800dd4a:	4602      	mov	r2, r0
 800dd4c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dd4e:	1ad3      	subs	r3, r2, r3
 800dd50:	2b64      	cmp	r3, #100	; 0x64
 800dd52:	d901      	bls.n	800dd58 <HAL_RCC_OscConfig+0x344>
      {
        return HAL_TIMEOUT;
 800dd54:	2303      	movs	r3, #3
 800dd56:	e12c      	b.n	800dfb2 <HAL_RCC_OscConfig+0x59e>
    PWR->CR1 |= PWR_CR1_DBP;
    
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 800dd58:	4b86      	ldr	r3, [pc, #536]	; (800df74 <HAL_RCC_OscConfig+0x560>)
 800dd5a:	681b      	ldr	r3, [r3, #0]
 800dd5c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800dd60:	2b00      	cmp	r3, #0
 800dd62:	d0f0      	beq.n	800dd46 <HAL_RCC_OscConfig+0x332>
        return HAL_TIMEOUT;
      }      
    }
    
    /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 800dd64:	4a82      	ldr	r2, [pc, #520]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800dd66:	4b82      	ldr	r3, [pc, #520]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800dd68:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800dd6a:	f023 0301 	bic.w	r3, r3, #1
 800dd6e:	6713      	str	r3, [r2, #112]	; 0x70
 800dd70:	4a7f      	ldr	r2, [pc, #508]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800dd72:	4b7f      	ldr	r3, [pc, #508]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800dd74:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800dd76:	f023 0304 	bic.w	r3, r3, #4
 800dd7a:	6713      	str	r3, [r2, #112]	; 0x70
 800dd7c:	4a7c      	ldr	r2, [pc, #496]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800dd7e:	4b7c      	ldr	r3, [pc, #496]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800dd80:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800dd82:	f023 0301 	bic.w	r3, r3, #1
 800dd86:	6713      	str	r3, [r2, #112]	; 0x70
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800dd88:	f7f8 fe32 	bl	80069f0 <HAL_GetTick>
 800dd8c:	6378      	str	r0, [r7, #52]	; 0x34
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800dd8e:	e00a      	b.n	800dda6 <HAL_RCC_OscConfig+0x392>
    {
      if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800dd90:	f7f8 fe2e 	bl	80069f0 <HAL_GetTick>
 800dd94:	4602      	mov	r2, r0
 800dd96:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dd98:	1ad3      	subs	r3, r2, r3
 800dd9a:	f241 3288 	movw	r2, #5000	; 0x1388
 800dd9e:	4293      	cmp	r3, r2
 800dda0:	d901      	bls.n	800dda6 <HAL_RCC_OscConfig+0x392>
      {
        return HAL_TIMEOUT;
 800dda2:	2303      	movs	r3, #3
 800dda4:	e105      	b.n	800dfb2 <HAL_RCC_OscConfig+0x59e>
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800dda6:	4b72      	ldr	r3, [pc, #456]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800dda8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800ddaa:	f003 0302 	and.w	r3, r3, #2
 800ddae:	2b00      	cmp	r3, #0
 800ddb0:	d1ee      	bne.n	800dd90 <HAL_RCC_OscConfig+0x37c>
        return HAL_TIMEOUT;
      }    
    } 
    
    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800ddb2:	4a6f      	ldr	r2, [pc, #444]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800ddb4:	4b6e      	ldr	r3, [pc, #440]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800ddb6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800ddb8:	f023 0301 	bic.w	r3, r3, #1
 800ddbc:	6713      	str	r3, [r2, #112]	; 0x70
 800ddbe:	687b      	ldr	r3, [r7, #4]
 800ddc0:	689b      	ldr	r3, [r3, #8]
 800ddc2:	2b01      	cmp	r3, #1
 800ddc4:	d10c      	bne.n	800dde0 <HAL_RCC_OscConfig+0x3cc>
 800ddc6:	4a6a      	ldr	r2, [pc, #424]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800ddc8:	4b69      	ldr	r3, [pc, #420]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800ddca:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800ddcc:	f023 0304 	bic.w	r3, r3, #4
 800ddd0:	6713      	str	r3, [r2, #112]	; 0x70
 800ddd2:	4a67      	ldr	r2, [pc, #412]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800ddd4:	4b66      	ldr	r3, [pc, #408]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800ddd6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800ddd8:	f043 0301 	orr.w	r3, r3, #1
 800dddc:	6713      	str	r3, [r2, #112]	; 0x70
 800ddde:	e01c      	b.n	800de1a <HAL_RCC_OscConfig+0x406>
 800dde0:	687b      	ldr	r3, [r7, #4]
 800dde2:	689b      	ldr	r3, [r3, #8]
 800dde4:	2b05      	cmp	r3, #5
 800dde6:	d10c      	bne.n	800de02 <HAL_RCC_OscConfig+0x3ee>
 800dde8:	4a61      	ldr	r2, [pc, #388]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800ddea:	4b61      	ldr	r3, [pc, #388]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800ddec:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800ddee:	f043 0304 	orr.w	r3, r3, #4
 800ddf2:	6713      	str	r3, [r2, #112]	; 0x70
 800ddf4:	4a5e      	ldr	r2, [pc, #376]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800ddf6:	4b5e      	ldr	r3, [pc, #376]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800ddf8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800ddfa:	f043 0301 	orr.w	r3, r3, #1
 800ddfe:	6713      	str	r3, [r2, #112]	; 0x70
 800de00:	e00b      	b.n	800de1a <HAL_RCC_OscConfig+0x406>
 800de02:	4a5b      	ldr	r2, [pc, #364]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800de04:	4b5a      	ldr	r3, [pc, #360]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800de06:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800de08:	f023 0304 	bic.w	r3, r3, #4
 800de0c:	6713      	str	r3, [r2, #112]	; 0x70
 800de0e:	4a58      	ldr	r2, [pc, #352]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800de10:	4b57      	ldr	r3, [pc, #348]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800de12:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800de14:	f023 0301 	bic.w	r3, r3, #1
 800de18:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 800de1a:	687b      	ldr	r3, [r7, #4]
 800de1c:	689b      	ldr	r3, [r3, #8]
 800de1e:	2b00      	cmp	r3, #0
 800de20:	d015      	beq.n	800de4e <HAL_RCC_OscConfig+0x43a>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800de22:	f7f8 fde5 	bl	80069f0 <HAL_GetTick>
 800de26:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800de28:	e00a      	b.n	800de40 <HAL_RCC_OscConfig+0x42c>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800de2a:	f7f8 fde1 	bl	80069f0 <HAL_GetTick>
 800de2e:	4602      	mov	r2, r0
 800de30:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800de32:	1ad3      	subs	r3, r2, r3
 800de34:	f241 3288 	movw	r2, #5000	; 0x1388
 800de38:	4293      	cmp	r3, r2
 800de3a:	d901      	bls.n	800de40 <HAL_RCC_OscConfig+0x42c>
        {
          return HAL_TIMEOUT;
 800de3c:	2303      	movs	r3, #3
 800de3e:	e0b8      	b.n	800dfb2 <HAL_RCC_OscConfig+0x59e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800de40:	4b4b      	ldr	r3, [pc, #300]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800de42:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800de44:	f003 0302 	and.w	r3, r3, #2
 800de48:	2b00      	cmp	r3, #0
 800de4a:	d0ee      	beq.n	800de2a <HAL_RCC_OscConfig+0x416>
 800de4c:	e014      	b.n	800de78 <HAL_RCC_OscConfig+0x464>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800de4e:	f7f8 fdcf 	bl	80069f0 <HAL_GetTick>
 800de52:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800de54:	e00a      	b.n	800de6c <HAL_RCC_OscConfig+0x458>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800de56:	f7f8 fdcb 	bl	80069f0 <HAL_GetTick>
 800de5a:	4602      	mov	r2, r0
 800de5c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800de5e:	1ad3      	subs	r3, r2, r3
 800de60:	f241 3288 	movw	r2, #5000	; 0x1388
 800de64:	4293      	cmp	r3, r2
 800de66:	d901      	bls.n	800de6c <HAL_RCC_OscConfig+0x458>
        {
          return HAL_TIMEOUT;
 800de68:	2303      	movs	r3, #3
 800de6a:	e0a2      	b.n	800dfb2 <HAL_RCC_OscConfig+0x59e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800de6c:	4b40      	ldr	r3, [pc, #256]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800de6e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800de70:	f003 0302 	and.w	r3, r3, #2
 800de74:	2b00      	cmp	r3, #0
 800de76:	d1ee      	bne.n	800de56 <HAL_RCC_OscConfig+0x442>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800de78:	687b      	ldr	r3, [r7, #4]
 800de7a:	699b      	ldr	r3, [r3, #24]
 800de7c:	2b00      	cmp	r3, #0
 800de7e:	f000 8097 	beq.w	800dfb0 <HAL_RCC_OscConfig+0x59c>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800de82:	4b3b      	ldr	r3, [pc, #236]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800de84:	689b      	ldr	r3, [r3, #8]
 800de86:	f003 030c 	and.w	r3, r3, #12
 800de8a:	2b08      	cmp	r3, #8
 800de8c:	f000 808e 	beq.w	800dfac <HAL_RCC_OscConfig+0x598>
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800de90:	687b      	ldr	r3, [r7, #4]
 800de92:	699b      	ldr	r3, [r3, #24]
 800de94:	2b02      	cmp	r3, #2
 800de96:	d16f      	bne.n	800df78 <HAL_RCC_OscConfig+0x564>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800de98:	4a35      	ldr	r2, [pc, #212]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800de9a:	4b35      	ldr	r3, [pc, #212]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800de9c:	681b      	ldr	r3, [r3, #0]
 800de9e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800dea2:	6013      	str	r3, [r2, #0]
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800dea4:	f7f8 fda4 	bl	80069f0 <HAL_GetTick>
 800dea8:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800deaa:	e008      	b.n	800debe <HAL_RCC_OscConfig+0x4aa>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800deac:	f7f8 fda0 	bl	80069f0 <HAL_GetTick>
 800deb0:	4602      	mov	r2, r0
 800deb2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800deb4:	1ad3      	subs	r3, r2, r3
 800deb6:	2b64      	cmp	r3, #100	; 0x64
 800deb8:	d901      	bls.n	800debe <HAL_RCC_OscConfig+0x4aa>
          {
            return HAL_TIMEOUT;
 800deba:	2303      	movs	r3, #3
 800debc:	e079      	b.n	800dfb2 <HAL_RCC_OscConfig+0x59e>
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800debe:	4b2c      	ldr	r3, [pc, #176]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800dec0:	681b      	ldr	r3, [r3, #0]
 800dec2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800dec6:	2b00      	cmp	r3, #0
 800dec8:	d1f0      	bne.n	800deac <HAL_RCC_OscConfig+0x498>
            return HAL_TIMEOUT;
          }
        }
        
        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800deca:	4829      	ldr	r0, [pc, #164]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800decc:	687b      	ldr	r3, [r7, #4]
 800dece:	6a1a      	ldr	r2, [r3, #32]
 800ded0:	687b      	ldr	r3, [r7, #4]
 800ded2:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800ded4:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800ded8:	623b      	str	r3, [r7, #32]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800deda:	6a3b      	ldr	r3, [r7, #32]
 800dedc:	fa93 f3a3 	rbit	r3, r3
 800dee0:	61fb      	str	r3, [r7, #28]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800dee2:	69fb      	ldr	r3, [r7, #28]
 800dee4:	fab3 f383 	clz	r3, r3
 800dee8:	fa01 f303 	lsl.w	r3, r1, r3
 800deec:	431a      	orrs	r2, r3
 800deee:	687b      	ldr	r3, [r7, #4]
 800def0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800def2:	085b      	lsrs	r3, r3, #1
 800def4:	1e59      	subs	r1, r3, #1
 800def6:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 800defa:	61bb      	str	r3, [r7, #24]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800defc:	69bb      	ldr	r3, [r7, #24]
 800defe:	fa93 f3a3 	rbit	r3, r3
 800df02:	617b      	str	r3, [r7, #20]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800df04:	697b      	ldr	r3, [r7, #20]
 800df06:	fab3 f383 	clz	r3, r3
 800df0a:	fa01 f303 	lsl.w	r3, r1, r3
 800df0e:	431a      	orrs	r2, r3
 800df10:	687b      	ldr	r3, [r7, #4]
 800df12:	69db      	ldr	r3, [r3, #28]
 800df14:	431a      	orrs	r2, r3
 800df16:	687b      	ldr	r3, [r7, #4]
 800df18:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 800df1a:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
 800df1e:	613b      	str	r3, [r7, #16]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800df20:	693b      	ldr	r3, [r7, #16]
 800df22:	fa93 f3a3 	rbit	r3, r3
 800df26:	60fb      	str	r3, [r7, #12]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800df28:	68fb      	ldr	r3, [r7, #12]
 800df2a:	fab3 f383 	clz	r3, r3
 800df2e:	fa01 f303 	lsl.w	r3, r1, r3
 800df32:	4313      	orrs	r3, r2
 800df34:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800df38:	6043      	str	r3, [r0, #4]
                             RCC_OscInitStruct->PLL.PLLM,
                             RCC_OscInitStruct->PLL.PLLN,
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800df3a:	4a0d      	ldr	r2, [pc, #52]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800df3c:	4b0c      	ldr	r3, [pc, #48]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800df3e:	681b      	ldr	r3, [r3, #0]
 800df40:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800df44:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800df46:	f7f8 fd53 	bl	80069f0 <HAL_GetTick>
 800df4a:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800df4c:	e008      	b.n	800df60 <HAL_RCC_OscConfig+0x54c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800df4e:	f7f8 fd4f 	bl	80069f0 <HAL_GetTick>
 800df52:	4602      	mov	r2, r0
 800df54:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800df56:	1ad3      	subs	r3, r2, r3
 800df58:	2b64      	cmp	r3, #100	; 0x64
 800df5a:	d901      	bls.n	800df60 <HAL_RCC_OscConfig+0x54c>
          {
            return HAL_TIMEOUT;
 800df5c:	2303      	movs	r3, #3
 800df5e:	e028      	b.n	800dfb2 <HAL_RCC_OscConfig+0x59e>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800df60:	4b03      	ldr	r3, [pc, #12]	; (800df70 <HAL_RCC_OscConfig+0x55c>)
 800df62:	681b      	ldr	r3, [r3, #0]
 800df64:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800df68:	2b00      	cmp	r3, #0
 800df6a:	d0f0      	beq.n	800df4e <HAL_RCC_OscConfig+0x53a>
 800df6c:	e020      	b.n	800dfb0 <HAL_RCC_OscConfig+0x59c>
 800df6e:	bf00      	nop
 800df70:	40023800 	.word	0x40023800
 800df74:	40007000 	.word	0x40007000
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800df78:	4a10      	ldr	r2, [pc, #64]	; (800dfbc <HAL_RCC_OscConfig+0x5a8>)
 800df7a:	4b10      	ldr	r3, [pc, #64]	; (800dfbc <HAL_RCC_OscConfig+0x5a8>)
 800df7c:	681b      	ldr	r3, [r3, #0]
 800df7e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800df82:	6013      	str	r3, [r2, #0]
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800df84:	f7f8 fd34 	bl	80069f0 <HAL_GetTick>
 800df88:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800df8a:	e008      	b.n	800df9e <HAL_RCC_OscConfig+0x58a>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800df8c:	f7f8 fd30 	bl	80069f0 <HAL_GetTick>
 800df90:	4602      	mov	r2, r0
 800df92:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800df94:	1ad3      	subs	r3, r2, r3
 800df96:	2b64      	cmp	r3, #100	; 0x64
 800df98:	d901      	bls.n	800df9e <HAL_RCC_OscConfig+0x58a>
          {
            return HAL_TIMEOUT;
 800df9a:	2303      	movs	r3, #3
 800df9c:	e009      	b.n	800dfb2 <HAL_RCC_OscConfig+0x59e>
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800df9e:	4b07      	ldr	r3, [pc, #28]	; (800dfbc <HAL_RCC_OscConfig+0x5a8>)
 800dfa0:	681b      	ldr	r3, [r3, #0]
 800dfa2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800dfa6:	2b00      	cmp	r3, #0
 800dfa8:	d1f0      	bne.n	800df8c <HAL_RCC_OscConfig+0x578>
 800dfaa:	e001      	b.n	800dfb0 <HAL_RCC_OscConfig+0x59c>
        }
      }
    }
    else
    {
      return HAL_ERROR;
 800dfac:	2301      	movs	r3, #1
 800dfae:	e000      	b.n	800dfb2 <HAL_RCC_OscConfig+0x59e>
    }
  }
  return HAL_OK;
 800dfb0:	2300      	movs	r3, #0
}
 800dfb2:	4618      	mov	r0, r3
 800dfb4:	3738      	adds	r7, #56	; 0x38
 800dfb6:	46bd      	mov	sp, r7
 800dfb8:	bd80      	pop	{r7, pc}
 800dfba:	bf00      	nop
 800dfbc:	40023800 	.word	0x40023800

0800dfc0 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800dfc0:	b580      	push	{r7, lr}
 800dfc2:	b084      	sub	sp, #16
 800dfc4:	af00      	add	r7, sp, #0
 800dfc6:	6078      	str	r0, [r7, #4]
 800dfc8:	6039      	str	r1, [r7, #0]
  uint32_t tickstart = 0;
 800dfca:	2300      	movs	r3, #0
 800dfcc:	60fb      	str	r3, [r7, #12]
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
     must be correctly programmed according to the frequency of the CPU clock 
     (HCLK) and the supply voltage of the device. */
  
  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 800dfce:	4b97      	ldr	r3, [pc, #604]	; (800e22c <HAL_RCC_ClockConfig+0x26c>)
 800dfd0:	681b      	ldr	r3, [r3, #0]
 800dfd2:	f003 020f 	and.w	r2, r3, #15
 800dfd6:	683b      	ldr	r3, [r7, #0]
 800dfd8:	429a      	cmp	r2, r3
 800dfda:	f080 8094 	bcs.w	800e106 <HAL_RCC_ClockConfig+0x146>
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800dfde:	4993      	ldr	r1, [pc, #588]	; (800e22c <HAL_RCC_ClockConfig+0x26c>)
 800dfe0:	4b92      	ldr	r3, [pc, #584]	; (800e22c <HAL_RCC_ClockConfig+0x26c>)
 800dfe2:	681b      	ldr	r3, [r3, #0]
 800dfe4:	f023 020f 	bic.w	r2, r3, #15
 800dfe8:	683b      	ldr	r3, [r7, #0]
 800dfea:	4313      	orrs	r3, r2
 800dfec:	600b      	str	r3, [r1, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 800dfee:	4b8f      	ldr	r3, [pc, #572]	; (800e22c <HAL_RCC_ClockConfig+0x26c>)
 800dff0:	681b      	ldr	r3, [r3, #0]
 800dff2:	f003 020f 	and.w	r2, r3, #15
 800dff6:	683b      	ldr	r3, [r7, #0]
 800dff8:	429a      	cmp	r2, r3
 800dffa:	d001      	beq.n	800e000 <HAL_RCC_ClockConfig+0x40>
    {
      return HAL_ERROR;
 800dffc:	2301      	movs	r3, #1
 800dffe:	e13c      	b.n	800e27a <HAL_RCC_ClockConfig+0x2ba>
    }

    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800e000:	687b      	ldr	r3, [r7, #4]
 800e002:	681b      	ldr	r3, [r3, #0]
 800e004:	f003 0302 	and.w	r3, r3, #2
 800e008:	2b00      	cmp	r3, #0
 800e00a:	d008      	beq.n	800e01e <HAL_RCC_ClockConfig+0x5e>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800e00c:	4988      	ldr	r1, [pc, #544]	; (800e230 <HAL_RCC_ClockConfig+0x270>)
 800e00e:	4b88      	ldr	r3, [pc, #544]	; (800e230 <HAL_RCC_ClockConfig+0x270>)
 800e010:	689b      	ldr	r3, [r3, #8]
 800e012:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 800e016:	687b      	ldr	r3, [r7, #4]
 800e018:	689b      	ldr	r3, [r3, #8]
 800e01a:	4313      	orrs	r3, r2
 800e01c:	608b      	str	r3, [r1, #8]
    }

    /*------------------------- SYSCLK Configuration ---------------------------*/ 
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800e01e:	687b      	ldr	r3, [r7, #4]
 800e020:	681b      	ldr	r3, [r3, #0]
 800e022:	f003 0301 	and.w	r3, r3, #1
 800e026:	2b00      	cmp	r3, #0
 800e028:	f000 8104 	beq.w	800e234 <HAL_RCC_ClockConfig+0x274>
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800e02c:	687b      	ldr	r3, [r7, #4]
 800e02e:	685b      	ldr	r3, [r3, #4]
 800e030:	2b01      	cmp	r3, #1
 800e032:	d107      	bne.n	800e044 <HAL_RCC_ClockConfig+0x84>
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800e034:	4b7e      	ldr	r3, [pc, #504]	; (800e230 <HAL_RCC_ClockConfig+0x270>)
 800e036:	681b      	ldr	r3, [r3, #0]
 800e038:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800e03c:	2b00      	cmp	r3, #0
 800e03e:	d115      	bne.n	800e06c <HAL_RCC_ClockConfig+0xac>
        {
          return HAL_ERROR;
 800e040:	2301      	movs	r3, #1
 800e042:	e11a      	b.n	800e27a <HAL_RCC_ClockConfig+0x2ba>
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800e044:	687b      	ldr	r3, [r7, #4]
 800e046:	685b      	ldr	r3, [r3, #4]
 800e048:	2b02      	cmp	r3, #2
 800e04a:	d107      	bne.n	800e05c <HAL_RCC_ClockConfig+0x9c>
      {
        /* Check the PLL ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800e04c:	4b78      	ldr	r3, [pc, #480]	; (800e230 <HAL_RCC_ClockConfig+0x270>)
 800e04e:	681b      	ldr	r3, [r3, #0]
 800e050:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800e054:	2b00      	cmp	r3, #0
 800e056:	d109      	bne.n	800e06c <HAL_RCC_ClockConfig+0xac>
        {
          return HAL_ERROR;
 800e058:	2301      	movs	r3, #1
 800e05a:	e10e      	b.n	800e27a <HAL_RCC_ClockConfig+0x2ba>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800e05c:	4b74      	ldr	r3, [pc, #464]	; (800e230 <HAL_RCC_ClockConfig+0x270>)
 800e05e:	681b      	ldr	r3, [r3, #0]
 800e060:	f003 0302 	and.w	r3, r3, #2
 800e064:	2b00      	cmp	r3, #0
 800e066:	d101      	bne.n	800e06c <HAL_RCC_ClockConfig+0xac>
        {
          return HAL_ERROR;
 800e068:	2301      	movs	r3, #1
 800e06a:	e106      	b.n	800e27a <HAL_RCC_ClockConfig+0x2ba>
        }
      }

      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800e06c:	4970      	ldr	r1, [pc, #448]	; (800e230 <HAL_RCC_ClockConfig+0x270>)
 800e06e:	4b70      	ldr	r3, [pc, #448]	; (800e230 <HAL_RCC_ClockConfig+0x270>)
 800e070:	689b      	ldr	r3, [r3, #8]
 800e072:	f023 0203 	bic.w	r2, r3, #3
 800e076:	687b      	ldr	r3, [r7, #4]
 800e078:	685b      	ldr	r3, [r3, #4]
 800e07a:	4313      	orrs	r3, r2
 800e07c:	608b      	str	r3, [r1, #8]
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800e07e:	f7f8 fcb7 	bl	80069f0 <HAL_GetTick>
 800e082:	60f8      	str	r0, [r7, #12]
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800e084:	687b      	ldr	r3, [r7, #4]
 800e086:	685b      	ldr	r3, [r3, #4]
 800e088:	2b01      	cmp	r3, #1
 800e08a:	d112      	bne.n	800e0b2 <HAL_RCC_ClockConfig+0xf2>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800e08c:	e00a      	b.n	800e0a4 <HAL_RCC_ClockConfig+0xe4>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800e08e:	f7f8 fcaf 	bl	80069f0 <HAL_GetTick>
 800e092:	4602      	mov	r2, r0
 800e094:	68fb      	ldr	r3, [r7, #12]
 800e096:	1ad3      	subs	r3, r2, r3
 800e098:	f241 3288 	movw	r2, #5000	; 0x1388
 800e09c:	4293      	cmp	r3, r2
 800e09e:	d901      	bls.n	800e0a4 <HAL_RCC_ClockConfig+0xe4>
          {
            return HAL_TIMEOUT;
 800e0a0:	2303      	movs	r3, #3
 800e0a2:	e0ea      	b.n	800e27a <HAL_RCC_ClockConfig+0x2ba>
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800e0a4:	4b62      	ldr	r3, [pc, #392]	; (800e230 <HAL_RCC_ClockConfig+0x270>)
 800e0a6:	689b      	ldr	r3, [r3, #8]
 800e0a8:	f003 030c 	and.w	r3, r3, #12
 800e0ac:	2b04      	cmp	r3, #4
 800e0ae:	d1ee      	bne.n	800e08e <HAL_RCC_ClockConfig+0xce>
 800e0b0:	e0c0      	b.n	800e234 <HAL_RCC_ClockConfig+0x274>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800e0b2:	687b      	ldr	r3, [r7, #4]
 800e0b4:	685b      	ldr	r3, [r3, #4]
 800e0b6:	2b02      	cmp	r3, #2
 800e0b8:	d112      	bne.n	800e0e0 <HAL_RCC_ClockConfig+0x120>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800e0ba:	e00a      	b.n	800e0d2 <HAL_RCC_ClockConfig+0x112>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800e0bc:	f7f8 fc98 	bl	80069f0 <HAL_GetTick>
 800e0c0:	4602      	mov	r2, r0
 800e0c2:	68fb      	ldr	r3, [r7, #12]
 800e0c4:	1ad3      	subs	r3, r2, r3
 800e0c6:	f241 3288 	movw	r2, #5000	; 0x1388
 800e0ca:	4293      	cmp	r3, r2
 800e0cc:	d901      	bls.n	800e0d2 <HAL_RCC_ClockConfig+0x112>
          {
            return HAL_TIMEOUT;
 800e0ce:	2303      	movs	r3, #3
 800e0d0:	e0d3      	b.n	800e27a <HAL_RCC_ClockConfig+0x2ba>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800e0d2:	4b57      	ldr	r3, [pc, #348]	; (800e230 <HAL_RCC_ClockConfig+0x270>)
 800e0d4:	689b      	ldr	r3, [r3, #8]
 800e0d6:	f003 030c 	and.w	r3, r3, #12
 800e0da:	2b08      	cmp	r3, #8
 800e0dc:	d1ee      	bne.n	800e0bc <HAL_RCC_ClockConfig+0xfc>
 800e0de:	e0a9      	b.n	800e234 <HAL_RCC_ClockConfig+0x274>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800e0e0:	e00a      	b.n	800e0f8 <HAL_RCC_ClockConfig+0x138>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800e0e2:	f7f8 fc85 	bl	80069f0 <HAL_GetTick>
 800e0e6:	4602      	mov	r2, r0
 800e0e8:	68fb      	ldr	r3, [r7, #12]
 800e0ea:	1ad3      	subs	r3, r2, r3
 800e0ec:	f241 3288 	movw	r2, #5000	; 0x1388
 800e0f0:	4293      	cmp	r3, r2
 800e0f2:	d901      	bls.n	800e0f8 <HAL_RCC_ClockConfig+0x138>
          {
            return HAL_TIMEOUT;
 800e0f4:	2303      	movs	r3, #3
 800e0f6:	e0c0      	b.n	800e27a <HAL_RCC_ClockConfig+0x2ba>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800e0f8:	4b4d      	ldr	r3, [pc, #308]	; (800e230 <HAL_RCC_ClockConfig+0x270>)
 800e0fa:	689b      	ldr	r3, [r3, #8]
 800e0fc:	f003 030c 	and.w	r3, r3, #12
 800e100:	2b00      	cmp	r3, #0
 800e102:	d1ee      	bne.n	800e0e2 <HAL_RCC_ClockConfig+0x122>
 800e104:	e096      	b.n	800e234 <HAL_RCC_ClockConfig+0x274>
  }
  /* Decreasing the CPU frequency */
  else
  {
    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800e106:	687b      	ldr	r3, [r7, #4]
 800e108:	681b      	ldr	r3, [r3, #0]
 800e10a:	f003 0302 	and.w	r3, r3, #2
 800e10e:	2b00      	cmp	r3, #0
 800e110:	d008      	beq.n	800e124 <HAL_RCC_ClockConfig+0x164>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800e112:	4947      	ldr	r1, [pc, #284]	; (800e230 <HAL_RCC_ClockConfig+0x270>)
 800e114:	4b46      	ldr	r3, [pc, #280]	; (800e230 <HAL_RCC_ClockConfig+0x270>)
 800e116:	689b      	ldr	r3, [r3, #8]
 800e118:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 800e11c:	687b      	ldr	r3, [r7, #4]
 800e11e:	689b      	ldr	r3, [r3, #8]
 800e120:	4313      	orrs	r3, r2
 800e122:	608b      	str	r3, [r1, #8]
    }

    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800e124:	687b      	ldr	r3, [r7, #4]
 800e126:	681b      	ldr	r3, [r3, #0]
 800e128:	f003 0301 	and.w	r3, r3, #1
 800e12c:	2b00      	cmp	r3, #0
 800e12e:	d06b      	beq.n	800e208 <HAL_RCC_ClockConfig+0x248>
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800e130:	687b      	ldr	r3, [r7, #4]
 800e132:	685b      	ldr	r3, [r3, #4]
 800e134:	2b01      	cmp	r3, #1
 800e136:	d107      	bne.n	800e148 <HAL_RCC_ClockConfig+0x188>
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800e138:	4b3d      	ldr	r3, [pc, #244]	; (800e230 <HAL_RCC_ClockConfig+0x270>)
 800e13a:	681b      	ldr	r3, [r3, #0]
 800e13c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800e140:	2b00      	cmp	r3, #0
 800e142:	d115      	bne.n	800e170 <HAL_RCC_ClockConfig+0x1b0>
        {
          return HAL_ERROR;
 800e144:	2301      	movs	r3, #1
 800e146:	e098      	b.n	800e27a <HAL_RCC_ClockConfig+0x2ba>
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800e148:	687b      	ldr	r3, [r7, #4]
 800e14a:	685b      	ldr	r3, [r3, #4]
 800e14c:	2b02      	cmp	r3, #2
 800e14e:	d107      	bne.n	800e160 <HAL_RCC_ClockConfig+0x1a0>
      {
        /* Check the PLL ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800e150:	4b37      	ldr	r3, [pc, #220]	; (800e230 <HAL_RCC_ClockConfig+0x270>)
 800e152:	681b      	ldr	r3, [r3, #0]
 800e154:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800e158:	2b00      	cmp	r3, #0
 800e15a:	d109      	bne.n	800e170 <HAL_RCC_ClockConfig+0x1b0>
        {
          return HAL_ERROR;
 800e15c:	2301      	movs	r3, #1
 800e15e:	e08c      	b.n	800e27a <HAL_RCC_ClockConfig+0x2ba>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800e160:	4b33      	ldr	r3, [pc, #204]	; (800e230 <HAL_RCC_ClockConfig+0x270>)
 800e162:	681b      	ldr	r3, [r3, #0]
 800e164:	f003 0302 	and.w	r3, r3, #2
 800e168:	2b00      	cmp	r3, #0
 800e16a:	d101      	bne.n	800e170 <HAL_RCC_ClockConfig+0x1b0>
        {
          return HAL_ERROR;
 800e16c:	2301      	movs	r3, #1
 800e16e:	e084      	b.n	800e27a <HAL_RCC_ClockConfig+0x2ba>
        }
      }
      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800e170:	492f      	ldr	r1, [pc, #188]	; (800e230 <HAL_RCC_ClockConfig+0x270>)
 800e172:	4b2f      	ldr	r3, [pc, #188]	; (800e230 <HAL_RCC_ClockConfig+0x270>)
 800e174:	689b      	ldr	r3, [r3, #8]
 800e176:	f023 0203 	bic.w	r2, r3, #3
 800e17a:	687b      	ldr	r3, [r7, #4]
 800e17c:	685b      	ldr	r3, [r3, #4]
 800e17e:	4313      	orrs	r3, r2
 800e180:	608b      	str	r3, [r1, #8]
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800e182:	f7f8 fc35 	bl	80069f0 <HAL_GetTick>
 800e186:	60f8      	str	r0, [r7, #12]
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800e188:	687b      	ldr	r3, [r7, #4]
 800e18a:	685b      	ldr	r3, [r3, #4]
 800e18c:	2b01      	cmp	r3, #1
 800e18e:	d112      	bne.n	800e1b6 <HAL_RCC_ClockConfig+0x1f6>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800e190:	e00a      	b.n	800e1a8 <HAL_RCC_ClockConfig+0x1e8>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800e192:	f7f8 fc2d 	bl	80069f0 <HAL_GetTick>
 800e196:	4602      	mov	r2, r0
 800e198:	68fb      	ldr	r3, [r7, #12]
 800e19a:	1ad3      	subs	r3, r2, r3
 800e19c:	f241 3288 	movw	r2, #5000	; 0x1388
 800e1a0:	4293      	cmp	r3, r2
 800e1a2:	d901      	bls.n	800e1a8 <HAL_RCC_ClockConfig+0x1e8>
          {
            return HAL_TIMEOUT;
 800e1a4:	2303      	movs	r3, #3
 800e1a6:	e068      	b.n	800e27a <HAL_RCC_ClockConfig+0x2ba>
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800e1a8:	4b21      	ldr	r3, [pc, #132]	; (800e230 <HAL_RCC_ClockConfig+0x270>)
 800e1aa:	689b      	ldr	r3, [r3, #8]
 800e1ac:	f003 030c 	and.w	r3, r3, #12
 800e1b0:	2b04      	cmp	r3, #4
 800e1b2:	d1ee      	bne.n	800e192 <HAL_RCC_ClockConfig+0x1d2>
 800e1b4:	e028      	b.n	800e208 <HAL_RCC_ClockConfig+0x248>
          {
            return HAL_TIMEOUT;
          } 
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800e1b6:	687b      	ldr	r3, [r7, #4]
 800e1b8:	685b      	ldr	r3, [r3, #4]
 800e1ba:	2b02      	cmp	r3, #2
 800e1bc:	d112      	bne.n	800e1e4 <HAL_RCC_ClockConfig+0x224>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800e1be:	e00a      	b.n	800e1d6 <HAL_RCC_ClockConfig+0x216>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800e1c0:	f7f8 fc16 	bl	80069f0 <HAL_GetTick>
 800e1c4:	4602      	mov	r2, r0
 800e1c6:	68fb      	ldr	r3, [r7, #12]
 800e1c8:	1ad3      	subs	r3, r2, r3
 800e1ca:	f241 3288 	movw	r2, #5000	; 0x1388
 800e1ce:	4293      	cmp	r3, r2
 800e1d0:	d901      	bls.n	800e1d6 <HAL_RCC_ClockConfig+0x216>
          {
            return HAL_TIMEOUT;
 800e1d2:	2303      	movs	r3, #3
 800e1d4:	e051      	b.n	800e27a <HAL_RCC_ClockConfig+0x2ba>
          } 
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800e1d6:	4b16      	ldr	r3, [pc, #88]	; (800e230 <HAL_RCC_ClockConfig+0x270>)
 800e1d8:	689b      	ldr	r3, [r3, #8]
 800e1da:	f003 030c 	and.w	r3, r3, #12
 800e1de:	2b08      	cmp	r3, #8
 800e1e0:	d1ee      	bne.n	800e1c0 <HAL_RCC_ClockConfig+0x200>
 800e1e2:	e011      	b.n	800e208 <HAL_RCC_ClockConfig+0x248>
          } 
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800e1e4:	e00a      	b.n	800e1fc <HAL_RCC_ClockConfig+0x23c>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800e1e6:	f7f8 fc03 	bl	80069f0 <HAL_GetTick>
 800e1ea:	4602      	mov	r2, r0
 800e1ec:	68fb      	ldr	r3, [r7, #12]
 800e1ee:	1ad3      	subs	r3, r2, r3
 800e1f0:	f241 3288 	movw	r2, #5000	; 0x1388
 800e1f4:	4293      	cmp	r3, r2
 800e1f6:	d901      	bls.n	800e1fc <HAL_RCC_ClockConfig+0x23c>
          {
            return HAL_TIMEOUT;
 800e1f8:	2303      	movs	r3, #3
 800e1fa:	e03e      	b.n	800e27a <HAL_RCC_ClockConfig+0x2ba>
          } 
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800e1fc:	4b0c      	ldr	r3, [pc, #48]	; (800e230 <HAL_RCC_ClockConfig+0x270>)
 800e1fe:	689b      	ldr	r3, [r3, #8]
 800e200:	f003 030c 	and.w	r3, r3, #12
 800e204:	2b00      	cmp	r3, #0
 800e206:	d1ee      	bne.n	800e1e6 <HAL_RCC_ClockConfig+0x226>
        }
      }
    }
    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800e208:	4908      	ldr	r1, [pc, #32]	; (800e22c <HAL_RCC_ClockConfig+0x26c>)
 800e20a:	4b08      	ldr	r3, [pc, #32]	; (800e22c <HAL_RCC_ClockConfig+0x26c>)
 800e20c:	681b      	ldr	r3, [r3, #0]
 800e20e:	f023 020f 	bic.w	r2, r3, #15
 800e212:	683b      	ldr	r3, [r7, #0]
 800e214:	4313      	orrs	r3, r2
 800e216:	600b      	str	r3, [r1, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 800e218:	4b04      	ldr	r3, [pc, #16]	; (800e22c <HAL_RCC_ClockConfig+0x26c>)
 800e21a:	681b      	ldr	r3, [r3, #0]
 800e21c:	f003 020f 	and.w	r2, r3, #15
 800e220:	683b      	ldr	r3, [r7, #0]
 800e222:	429a      	cmp	r2, r3
 800e224:	d006      	beq.n	800e234 <HAL_RCC_ClockConfig+0x274>
    {
      return HAL_ERROR;
 800e226:	2301      	movs	r3, #1
 800e228:	e027      	b.n	800e27a <HAL_RCC_ClockConfig+0x2ba>
 800e22a:	bf00      	nop
 800e22c:	40023c00 	.word	0x40023c00
 800e230:	40023800 	.word	0x40023800
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800e234:	687b      	ldr	r3, [r7, #4]
 800e236:	681b      	ldr	r3, [r3, #0]
 800e238:	f003 0304 	and.w	r3, r3, #4
 800e23c:	2b00      	cmp	r3, #0
 800e23e:	d008      	beq.n	800e252 <HAL_RCC_ClockConfig+0x292>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800e240:	4910      	ldr	r1, [pc, #64]	; (800e284 <HAL_RCC_ClockConfig+0x2c4>)
 800e242:	4b10      	ldr	r3, [pc, #64]	; (800e284 <HAL_RCC_ClockConfig+0x2c4>)
 800e244:	689b      	ldr	r3, [r3, #8]
 800e246:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 800e24a:	687b      	ldr	r3, [r7, #4]
 800e24c:	68db      	ldr	r3, [r3, #12]
 800e24e:	4313      	orrs	r3, r2
 800e250:	608b      	str	r3, [r1, #8]
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800e252:	687b      	ldr	r3, [r7, #4]
 800e254:	681b      	ldr	r3, [r3, #0]
 800e256:	f003 0308 	and.w	r3, r3, #8
 800e25a:	2b00      	cmp	r3, #0
 800e25c:	d009      	beq.n	800e272 <HAL_RCC_ClockConfig+0x2b2>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 800e25e:	4909      	ldr	r1, [pc, #36]	; (800e284 <HAL_RCC_ClockConfig+0x2c4>)
 800e260:	4b08      	ldr	r3, [pc, #32]	; (800e284 <HAL_RCC_ClockConfig+0x2c4>)
 800e262:	689b      	ldr	r3, [r3, #8]
 800e264:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 800e268:	687b      	ldr	r3, [r7, #4]
 800e26a:	691b      	ldr	r3, [r3, #16]
 800e26c:	00db      	lsls	r3, r3, #3
 800e26e:	4313      	orrs	r3, r2
 800e270:	608b      	str	r3, [r1, #8]
  }

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 800e272:	200f      	movs	r0, #15
 800e274:	f004 fbde 	bl	8012a34 <HAL_InitTick>
  
  return HAL_OK;
 800e278:	2300      	movs	r3, #0
}
 800e27a:	4618      	mov	r0, r3
 800e27c:	3710      	adds	r7, #16
 800e27e:	46bd      	mov	sp, r7
 800e280:	bd80      	pop	{r7, pc}
 800e282:	bf00      	nop
 800e284:	40023800 	.word	0x40023800

0800e288 <HAL_RCC_GetSysClockFreq>:
  *         
  *               
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800e288:	b480      	push	{r7}
 800e28a:	b08b      	sub	sp, #44	; 0x2c
 800e28c:	af00      	add	r7, sp, #0
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
 800e28e:	2300      	movs	r3, #0
 800e290:	61fb      	str	r3, [r7, #28]
 800e292:	2300      	movs	r3, #0
 800e294:	627b      	str	r3, [r7, #36]	; 0x24
 800e296:	2300      	movs	r3, #0
 800e298:	61bb      	str	r3, [r7, #24]
  uint32_t sysclockfreq = 0;
 800e29a:	2300      	movs	r3, #0
 800e29c:	623b      	str	r3, [r7, #32]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800e29e:	4b36      	ldr	r3, [pc, #216]	; (800e378 <HAL_RCC_GetSysClockFreq+0xf0>)
 800e2a0:	689b      	ldr	r3, [r3, #8]
 800e2a2:	f003 030c 	and.w	r3, r3, #12
 800e2a6:	2b04      	cmp	r3, #4
 800e2a8:	d006      	beq.n	800e2b8 <HAL_RCC_GetSysClockFreq+0x30>
 800e2aa:	2b08      	cmp	r3, #8
 800e2ac:	d007      	beq.n	800e2be <HAL_RCC_GetSysClockFreq+0x36>
 800e2ae:	2b00      	cmp	r3, #0
 800e2b0:	d158      	bne.n	800e364 <HAL_RCC_GetSysClockFreq+0xdc>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 800e2b2:	4b32      	ldr	r3, [pc, #200]	; (800e37c <HAL_RCC_GetSysClockFreq+0xf4>)
 800e2b4:	623b      	str	r3, [r7, #32]
       break;
 800e2b6:	e058      	b.n	800e36a <HAL_RCC_GetSysClockFreq+0xe2>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 800e2b8:	4b31      	ldr	r3, [pc, #196]	; (800e380 <HAL_RCC_GetSysClockFreq+0xf8>)
 800e2ba:	623b      	str	r3, [r7, #32]
      break;
 800e2bc:	e055      	b.n	800e36a <HAL_RCC_GetSysClockFreq+0xe2>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800e2be:	4b2e      	ldr	r3, [pc, #184]	; (800e378 <HAL_RCC_GetSysClockFreq+0xf0>)
 800e2c0:	685b      	ldr	r3, [r3, #4]
 800e2c2:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800e2c6:	61fb      	str	r3, [r7, #28]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 800e2c8:	4b2b      	ldr	r3, [pc, #172]	; (800e378 <HAL_RCC_GetSysClockFreq+0xf0>)
 800e2ca:	685b      	ldr	r3, [r3, #4]
 800e2cc:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800e2d0:	2b00      	cmp	r3, #0
 800e2d2:	d017      	beq.n	800e304 <HAL_RCC_GetSysClockFreq+0x7c>
      {
        /* HSE used as PLL clock source */
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 800e2d4:	4a2a      	ldr	r2, [pc, #168]	; (800e380 <HAL_RCC_GetSysClockFreq+0xf8>)
 800e2d6:	69fb      	ldr	r3, [r7, #28]
 800e2d8:	fbb2 f2f3 	udiv	r2, r2, r3
 800e2dc:	4b26      	ldr	r3, [pc, #152]	; (800e378 <HAL_RCC_GetSysClockFreq+0xf0>)
 800e2de:	6859      	ldr	r1, [r3, #4]
 800e2e0:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800e2e4:	400b      	ands	r3, r1
 800e2e6:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 800e2ea:	6179      	str	r1, [r7, #20]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800e2ec:	6979      	ldr	r1, [r7, #20]
 800e2ee:	fa91 f1a1 	rbit	r1, r1
 800e2f2:	6139      	str	r1, [r7, #16]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800e2f4:	6939      	ldr	r1, [r7, #16]
 800e2f6:	fab1 f181 	clz	r1, r1
 800e2fa:	40cb      	lsrs	r3, r1
 800e2fc:	fb03 f302 	mul.w	r3, r3, r2
 800e300:	627b      	str	r3, [r7, #36]	; 0x24
 800e302:	e016      	b.n	800e332 <HAL_RCC_GetSysClockFreq+0xaa>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 800e304:	4a1d      	ldr	r2, [pc, #116]	; (800e37c <HAL_RCC_GetSysClockFreq+0xf4>)
 800e306:	69fb      	ldr	r3, [r7, #28]
 800e308:	fbb2 f2f3 	udiv	r2, r2, r3
 800e30c:	4b1a      	ldr	r3, [pc, #104]	; (800e378 <HAL_RCC_GetSysClockFreq+0xf0>)
 800e30e:	6859      	ldr	r1, [r3, #4]
 800e310:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800e314:	400b      	ands	r3, r1
 800e316:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 800e31a:	60f9      	str	r1, [r7, #12]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800e31c:	68f9      	ldr	r1, [r7, #12]
 800e31e:	fa91 f1a1 	rbit	r1, r1
 800e322:	60b9      	str	r1, [r7, #8]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800e324:	68b9      	ldr	r1, [r7, #8]
 800e326:	fab1 f181 	clz	r1, r1
 800e32a:	40cb      	lsrs	r3, r1
 800e32c:	fb03 f302 	mul.w	r3, r3, r2
 800e330:	627b      	str	r3, [r7, #36]	; 0x24
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1 ) *2);
 800e332:	4b11      	ldr	r3, [pc, #68]	; (800e378 <HAL_RCC_GetSysClockFreq+0xf0>)
 800e334:	685b      	ldr	r3, [r3, #4]
 800e336:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 800e33a:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 800e33e:	607b      	str	r3, [r7, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800e340:	687b      	ldr	r3, [r7, #4]
 800e342:	fa93 f3a3 	rbit	r3, r3
 800e346:	603b      	str	r3, [r7, #0]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800e348:	683b      	ldr	r3, [r7, #0]
 800e34a:	fab3 f383 	clz	r3, r3
 800e34e:	fa22 f303 	lsr.w	r3, r2, r3
 800e352:	3301      	adds	r3, #1
 800e354:	005b      	lsls	r3, r3, #1
 800e356:	61bb      	str	r3, [r7, #24]
      
      sysclockfreq = pllvco/pllp;
 800e358:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800e35a:	69bb      	ldr	r3, [r7, #24]
 800e35c:	fbb2 f3f3 	udiv	r3, r2, r3
 800e360:	623b      	str	r3, [r7, #32]
      break;
 800e362:	e002      	b.n	800e36a <HAL_RCC_GetSysClockFreq+0xe2>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 800e364:	4b05      	ldr	r3, [pc, #20]	; (800e37c <HAL_RCC_GetSysClockFreq+0xf4>)
 800e366:	623b      	str	r3, [r7, #32]
      break;
 800e368:	bf00      	nop
    }
  }
  return sysclockfreq;
 800e36a:	6a3b      	ldr	r3, [r7, #32]
}
 800e36c:	4618      	mov	r0, r3
 800e36e:	372c      	adds	r7, #44	; 0x2c
 800e370:	46bd      	mov	sp, r7
 800e372:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e376:	4770      	bx	lr
 800e378:	40023800 	.word	0x40023800
 800e37c:	00f42400 	.word	0x00f42400
 800e380:	017d7840 	.word	0x017d7840

0800e384 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800e384:	b580      	push	{r7, lr}
 800e386:	b082      	sub	sp, #8
 800e388:	af00      	add	r7, sp, #0
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 800e38a:	f7ff ff7d 	bl	800e288 <HAL_RCC_GetSysClockFreq>
 800e38e:	4601      	mov	r1, r0
 800e390:	4b0d      	ldr	r3, [pc, #52]	; (800e3c8 <HAL_RCC_GetHCLKFreq+0x44>)
 800e392:	689b      	ldr	r3, [r3, #8]
 800e394:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 800e398:	23f0      	movs	r3, #240	; 0xf0
 800e39a:	607b      	str	r3, [r7, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800e39c:	687b      	ldr	r3, [r7, #4]
 800e39e:	fa93 f3a3 	rbit	r3, r3
 800e3a2:	603b      	str	r3, [r7, #0]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800e3a4:	683b      	ldr	r3, [r7, #0]
 800e3a6:	fab3 f383 	clz	r3, r3
 800e3aa:	fa22 f303 	lsr.w	r3, r2, r3
 800e3ae:	4a07      	ldr	r2, [pc, #28]	; (800e3cc <HAL_RCC_GetHCLKFreq+0x48>)
 800e3b0:	5cd3      	ldrb	r3, [r2, r3]
 800e3b2:	fa21 f303 	lsr.w	r3, r1, r3
 800e3b6:	4a06      	ldr	r2, [pc, #24]	; (800e3d0 <HAL_RCC_GetHCLKFreq+0x4c>)
 800e3b8:	6013      	str	r3, [r2, #0]
  return SystemCoreClock;
 800e3ba:	4b05      	ldr	r3, [pc, #20]	; (800e3d0 <HAL_RCC_GetHCLKFreq+0x4c>)
 800e3bc:	681b      	ldr	r3, [r3, #0]
}
 800e3be:	4618      	mov	r0, r3
 800e3c0:	3708      	adds	r7, #8
 800e3c2:	46bd      	mov	sp, r7
 800e3c4:	bd80      	pop	{r7, pc}
 800e3c6:	bf00      	nop
 800e3c8:	40023800 	.word	0x40023800
 800e3cc:	08028cb0 	.word	0x08028cb0
 800e3d0:	20010014 	.word	0x20010014

0800e3d4 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{  
 800e3d4:	b580      	push	{r7, lr}
 800e3d6:	b082      	sub	sp, #8
 800e3d8:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 800e3da:	f7ff ffd3 	bl	800e384 <HAL_RCC_GetHCLKFreq>
 800e3de:	4601      	mov	r1, r0
 800e3e0:	4b0b      	ldr	r3, [pc, #44]	; (800e410 <HAL_RCC_GetPCLK1Freq+0x3c>)
 800e3e2:	689b      	ldr	r3, [r3, #8]
 800e3e4:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
 800e3e8:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 800e3ec:	607b      	str	r3, [r7, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800e3ee:	687b      	ldr	r3, [r7, #4]
 800e3f0:	fa93 f3a3 	rbit	r3, r3
 800e3f4:	603b      	str	r3, [r7, #0]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800e3f6:	683b      	ldr	r3, [r7, #0]
 800e3f8:	fab3 f383 	clz	r3, r3
 800e3fc:	fa22 f303 	lsr.w	r3, r2, r3
 800e400:	4a04      	ldr	r2, [pc, #16]	; (800e414 <HAL_RCC_GetPCLK1Freq+0x40>)
 800e402:	5cd3      	ldrb	r3, [r2, r3]
 800e404:	fa21 f303 	lsr.w	r3, r1, r3
}
 800e408:	4618      	mov	r0, r3
 800e40a:	3708      	adds	r7, #8
 800e40c:	46bd      	mov	sp, r7
 800e40e:	bd80      	pop	{r7, pc}
 800e410:	40023800 	.word	0x40023800
 800e414:	08028cb0 	.word	0x08028cb0

0800e418 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800e418:	b580      	push	{r7, lr}
 800e41a:	b082      	sub	sp, #8
 800e41c:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
 800e41e:	f7ff ffb1 	bl	800e384 <HAL_RCC_GetHCLKFreq>
 800e422:	4601      	mov	r1, r0
 800e424:	4b0b      	ldr	r3, [pc, #44]	; (800e454 <HAL_RCC_GetPCLK2Freq+0x3c>)
 800e426:	689b      	ldr	r3, [r3, #8]
 800e428:	f403 4260 	and.w	r2, r3, #57344	; 0xe000
 800e42c:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 800e430:	607b      	str	r3, [r7, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800e432:	687b      	ldr	r3, [r7, #4]
 800e434:	fa93 f3a3 	rbit	r3, r3
 800e438:	603b      	str	r3, [r7, #0]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800e43a:	683b      	ldr	r3, [r7, #0]
 800e43c:	fab3 f383 	clz	r3, r3
 800e440:	fa22 f303 	lsr.w	r3, r2, r3
 800e444:	4a04      	ldr	r2, [pc, #16]	; (800e458 <HAL_RCC_GetPCLK2Freq+0x40>)
 800e446:	5cd3      	ldrb	r3, [r2, r3]
 800e448:	fa21 f303 	lsr.w	r3, r1, r3
} 
 800e44c:	4618      	mov	r0, r3
 800e44e:	3708      	adds	r7, #8
 800e450:	46bd      	mov	sp, r7
 800e452:	bd80      	pop	{r7, pc}
 800e454:	40023800 	.word	0x40023800
 800e458:	08028cb0 	.word	0x08028cb0

0800e45c <HAL_SDRAM_Init>:
  *                the configuration information for SDRAM module.
  * @param  Timing: Pointer to SDRAM control timing structure 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{   
 800e45c:	b580      	push	{r7, lr}
 800e45e:	b082      	sub	sp, #8
 800e460:	af00      	add	r7, sp, #0
 800e462:	6078      	str	r0, [r7, #4]
 800e464:	6039      	str	r1, [r7, #0]
  /* Check the SDRAM handle parameter */
  if(hsdram == NULL)
 800e466:	687b      	ldr	r3, [r7, #4]
 800e468:	2b00      	cmp	r3, #0
 800e46a:	d101      	bne.n	800e470 <HAL_SDRAM_Init+0x14>
  {
    return HAL_ERROR;
 800e46c:	2301      	movs	r3, #1
 800e46e:	e026      	b.n	800e4be <HAL_SDRAM_Init+0x62>
  }
  
  if(hsdram->State == HAL_SDRAM_STATE_RESET)
 800e470:	687b      	ldr	r3, [r7, #4]
 800e472:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800e476:	b2db      	uxtb	r3, r3
 800e478:	2b00      	cmp	r3, #0
 800e47a:	d106      	bne.n	800e48a <HAL_SDRAM_Init+0x2e>
  {  
    /* Allocate lock resource and initialize it */
    hsdram->Lock = HAL_UNLOCKED;
 800e47c:	687b      	ldr	r3, [r7, #4]
 800e47e:	2200      	movs	r2, #0
 800e480:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    /* Initialize the low level hardware (MSP) */
    HAL_SDRAM_MspInit(hsdram);
 800e484:	6878      	ldr	r0, [r7, #4]
 800e486:	f000 f81f 	bl	800e4c8 <HAL_SDRAM_MspInit>
  }
  
  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 800e48a:	687b      	ldr	r3, [r7, #4]
 800e48c:	2202      	movs	r2, #2
 800e48e:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Initialize SDRAM control Interface */
  FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 800e492:	687b      	ldr	r3, [r7, #4]
 800e494:	681a      	ldr	r2, [r3, #0]
 800e496:	687b      	ldr	r3, [r7, #4]
 800e498:	3304      	adds	r3, #4
 800e49a:	4610      	mov	r0, r2
 800e49c:	4619      	mov	r1, r3
 800e49e:	f001 fe01 	bl	80100a4 <FMC_SDRAM_Init>
  
  /* Initialize SDRAM timing Interface */
  FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank); 
 800e4a2:	687b      	ldr	r3, [r7, #4]
 800e4a4:	681a      	ldr	r2, [r3, #0]
 800e4a6:	687b      	ldr	r3, [r7, #4]
 800e4a8:	685b      	ldr	r3, [r3, #4]
 800e4aa:	4610      	mov	r0, r2
 800e4ac:	6839      	ldr	r1, [r7, #0]
 800e4ae:	461a      	mov	r2, r3
 800e4b0:	f001 fe6a 	bl	8010188 <FMC_SDRAM_Timing_Init>
  
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 800e4b4:	687b      	ldr	r3, [r7, #4]
 800e4b6:	2201      	movs	r2, #1
 800e4b8:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  return HAL_OK;
 800e4bc:	2300      	movs	r3, #0
}
 800e4be:	4618      	mov	r0, r3
 800e4c0:	3708      	adds	r7, #8
 800e4c2:	46bd      	mov	sp, r7
 800e4c4:	bd80      	pop	{r7, pc}
 800e4c6:	bf00      	nop

0800e4c8 <HAL_SDRAM_MspInit>:
  * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval None
  */
__weak void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef *hsdram)
{
 800e4c8:	b480      	push	{r7}
 800e4ca:	b083      	sub	sp, #12
 800e4cc:	af00      	add	r7, sp, #0
 800e4ce:	6078      	str	r0, [r7, #4]
  /* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_MspInit could be implemented in the user file
   */ 
}
 800e4d0:	370c      	adds	r7, #12
 800e4d2:	46bd      	mov	sp, r7
 800e4d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e4d8:	4770      	bx	lr
 800e4da:	bf00      	nop

0800e4dc <HAL_SDRAM_SendCommand>:
  * @param  Command: SDRAM command structure
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */  
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 800e4dc:	b580      	push	{r7, lr}
 800e4de:	b084      	sub	sp, #16
 800e4e0:	af00      	add	r7, sp, #0
 800e4e2:	60f8      	str	r0, [r7, #12]
 800e4e4:	60b9      	str	r1, [r7, #8]
 800e4e6:	607a      	str	r2, [r7, #4]
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 800e4e8:	68fb      	ldr	r3, [r7, #12]
 800e4ea:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800e4ee:	b2db      	uxtb	r3, r3
 800e4f0:	2b02      	cmp	r3, #2
 800e4f2:	d101      	bne.n	800e4f8 <HAL_SDRAM_SendCommand+0x1c>
  {
    return HAL_BUSY;
 800e4f4:	2302      	movs	r3, #2
 800e4f6:	e018      	b.n	800e52a <HAL_SDRAM_SendCommand+0x4e>
  }
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 800e4f8:	68fb      	ldr	r3, [r7, #12]
 800e4fa:	2202      	movs	r2, #2
 800e4fc:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Send SDRAM command */
  FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 800e500:	68fb      	ldr	r3, [r7, #12]
 800e502:	681b      	ldr	r3, [r3, #0]
 800e504:	4618      	mov	r0, r3
 800e506:	68b9      	ldr	r1, [r7, #8]
 800e508:	687a      	ldr	r2, [r7, #4]
 800e50a:	f001 febb 	bl	8010284 <FMC_SDRAM_SendCommand>
  
  /* Update the SDRAM controller state state */
  if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
 800e50e:	68bb      	ldr	r3, [r7, #8]
 800e510:	681b      	ldr	r3, [r3, #0]
 800e512:	2b02      	cmp	r3, #2
 800e514:	d104      	bne.n	800e520 <HAL_SDRAM_SendCommand+0x44>
  {
    hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
 800e516:	68fb      	ldr	r3, [r7, #12]
 800e518:	2205      	movs	r2, #5
 800e51a:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
 800e51e:	e003      	b.n	800e528 <HAL_SDRAM_SendCommand+0x4c>
  }
  else
  {
    hsdram->State = HAL_SDRAM_STATE_READY;
 800e520:	68fb      	ldr	r3, [r7, #12]
 800e522:	2201      	movs	r2, #1
 800e524:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  }
  
  return HAL_OK;  
 800e528:	2300      	movs	r3, #0
}
 800e52a:	4618      	mov	r0, r3
 800e52c:	3710      	adds	r7, #16
 800e52e:	46bd      	mov	sp, r7
 800e530:	bd80      	pop	{r7, pc}
 800e532:	bf00      	nop

0800e534 <HAL_SDRAM_ProgramRefreshRate>:
  *                the configuration information for SDRAM module.  
  * @param  RefreshRate: The SDRAM refresh rate value       
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
 800e534:	b580      	push	{r7, lr}
 800e536:	b082      	sub	sp, #8
 800e538:	af00      	add	r7, sp, #0
 800e53a:	6078      	str	r0, [r7, #4]
 800e53c:	6039      	str	r1, [r7, #0]
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 800e53e:	687b      	ldr	r3, [r7, #4]
 800e540:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800e544:	b2db      	uxtb	r3, r3
 800e546:	2b02      	cmp	r3, #2
 800e548:	d101      	bne.n	800e54e <HAL_SDRAM_ProgramRefreshRate+0x1a>
  {
    return HAL_BUSY;
 800e54a:	2302      	movs	r3, #2
 800e54c:	e00e      	b.n	800e56c <HAL_SDRAM_ProgramRefreshRate+0x38>
  } 
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 800e54e:	687b      	ldr	r3, [r7, #4]
 800e550:	2202      	movs	r2, #2
 800e552:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Program the refresh rate */
  FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
 800e556:	687b      	ldr	r3, [r7, #4]
 800e558:	681b      	ldr	r3, [r3, #0]
 800e55a:	4618      	mov	r0, r3
 800e55c:	6839      	ldr	r1, [r7, #0]
 800e55e:	f001 fecf 	bl	8010300 <FMC_SDRAM_ProgramRefreshRate>
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 800e562:	687b      	ldr	r3, [r7, #4]
 800e564:	2201      	movs	r2, #1
 800e566:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  return HAL_OK;   
 800e56a:	2300      	movs	r3, #0
}
 800e56c:	4618      	mov	r0, r3
 800e56e:	3708      	adds	r7, #8
 800e570:	46bd      	mov	sp, r7
 800e572:	bd80      	pop	{r7, pc}

0800e574 <HAL_TIM_Base_DeInit>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
{  
 800e574:	b580      	push	{r7, lr}
 800e576:	b082      	sub	sp, #8
 800e578:	af00      	add	r7, sp, #0
 800e57a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  htim->State = HAL_TIM_STATE_BUSY;
 800e57c:	687b      	ldr	r3, [r7, #4]
 800e57e:	2202      	movs	r2, #2
 800e580:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
   
  /* Disable the TIM Peripheral Clock */
  __HAL_TIM_DISABLE(htim);
 800e584:	687b      	ldr	r3, [r7, #4]
 800e586:	681b      	ldr	r3, [r3, #0]
 800e588:	6a1a      	ldr	r2, [r3, #32]
 800e58a:	f241 1311 	movw	r3, #4369	; 0x1111
 800e58e:	4013      	ands	r3, r2
 800e590:	2b00      	cmp	r3, #0
 800e592:	d10f      	bne.n	800e5b4 <HAL_TIM_Base_DeInit+0x40>
 800e594:	687b      	ldr	r3, [r7, #4]
 800e596:	681b      	ldr	r3, [r3, #0]
 800e598:	6a1a      	ldr	r2, [r3, #32]
 800e59a:	f240 4344 	movw	r3, #1092	; 0x444
 800e59e:	4013      	ands	r3, r2
 800e5a0:	2b00      	cmp	r3, #0
 800e5a2:	d107      	bne.n	800e5b4 <HAL_TIM_Base_DeInit+0x40>
 800e5a4:	687b      	ldr	r3, [r7, #4]
 800e5a6:	681b      	ldr	r3, [r3, #0]
 800e5a8:	687a      	ldr	r2, [r7, #4]
 800e5aa:	6812      	ldr	r2, [r2, #0]
 800e5ac:	6812      	ldr	r2, [r2, #0]
 800e5ae:	f022 0201 	bic.w	r2, r2, #1
 800e5b2:	601a      	str	r2, [r3, #0]
    
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_TIM_Base_MspDeInit(htim);
 800e5b4:	6878      	ldr	r0, [r7, #4]
 800e5b6:	f000 f80d 	bl	800e5d4 <HAL_TIM_Base_MspDeInit>
  
  /* Change TIM state */  
  htim->State = HAL_TIM_STATE_RESET; 
 800e5ba:	687b      	ldr	r3, [r7, #4]
 800e5bc:	2200      	movs	r2, #0
 800e5be:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  /* Release Lock */
  __HAL_UNLOCK(htim);
 800e5c2:	687b      	ldr	r3, [r7, #4]
 800e5c4:	2200      	movs	r2, #0
 800e5c6:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  return HAL_OK;
 800e5ca:	2300      	movs	r3, #0
}
 800e5cc:	4618      	mov	r0, r3
 800e5ce:	3708      	adds	r7, #8
 800e5d0:	46bd      	mov	sp, r7
 800e5d2:	bd80      	pop	{r7, pc}

0800e5d4 <HAL_TIM_Base_MspDeInit>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
{
 800e5d4:	b480      	push	{r7}
 800e5d6:	b083      	sub	sp, #12
 800e5d8:	af00      	add	r7, sp, #0
 800e5da:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspDeInit could be implemented in the user file
   */
}
 800e5dc:	370c      	adds	r7, #12
 800e5de:	46bd      	mov	sp, r7
 800e5e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e5e4:	4770      	bx	lr
 800e5e6:	bf00      	nop

0800e5e8 <HAL_TIM_PWM_Init>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
 800e5e8:	b580      	push	{r7, lr}
 800e5ea:	b082      	sub	sp, #8
 800e5ec:	af00      	add	r7, sp, #0
 800e5ee:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if(htim == NULL)
 800e5f0:	687b      	ldr	r3, [r7, #4]
 800e5f2:	2b00      	cmp	r3, #0
 800e5f4:	d101      	bne.n	800e5fa <HAL_TIM_PWM_Init+0x12>
  {
    return HAL_ERROR;
 800e5f6:	2301      	movs	r3, #1
 800e5f8:	e01d      	b.n	800e636 <HAL_TIM_PWM_Init+0x4e>
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));

  if(htim->State == HAL_TIM_STATE_RESET)
 800e5fa:	687b      	ldr	r3, [r7, #4]
 800e5fc:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 800e600:	b2db      	uxtb	r3, r3
 800e602:	2b00      	cmp	r3, #0
 800e604:	d106      	bne.n	800e614 <HAL_TIM_PWM_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;  
 800e606:	687b      	ldr	r3, [r7, #4]
 800e608:	2200      	movs	r2, #0
 800e60a:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_PWM_MspInit(htim);
 800e60e:	6878      	ldr	r0, [r7, #4]
 800e610:	f005 fd92 	bl	8014138 <HAL_TIM_PWM_MspInit>
  }

  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;  
 800e614:	687b      	ldr	r3, [r7, #4]
 800e616:	2202      	movs	r2, #2
 800e618:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  /* Init the base time for the PWM */  
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
 800e61c:	687b      	ldr	r3, [r7, #4]
 800e61e:	681a      	ldr	r2, [r3, #0]
 800e620:	687b      	ldr	r3, [r7, #4]
 800e622:	3304      	adds	r3, #4
 800e624:	4610      	mov	r0, r2
 800e626:	4619      	mov	r1, r3
 800e628:	f000 faea 	bl	800ec00 <TIM_Base_SetConfig>
   
  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 800e62c:	687b      	ldr	r3, [r7, #4]
 800e62e:	2201      	movs	r2, #1
 800e630:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  return HAL_OK;
 800e634:	2300      	movs	r3, #0
}  
 800e636:	4618      	mov	r0, r3
 800e638:	3708      	adds	r7, #8
 800e63a:	46bd      	mov	sp, r7
 800e63c:	bd80      	pop	{r7, pc}
 800e63e:	bf00      	nop

0800e640 <HAL_TIM_PWM_DeInit>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
{
 800e640:	b580      	push	{r7, lr}
 800e642:	b082      	sub	sp, #8
 800e644:	af00      	add	r7, sp, #0
 800e646:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  
  htim->State = HAL_TIM_STATE_BUSY;
 800e648:	687b      	ldr	r3, [r7, #4]
 800e64a:	2202      	movs	r2, #2
 800e64c:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  /* Disable the TIM Peripheral Clock */
  __HAL_TIM_DISABLE(htim);
 800e650:	687b      	ldr	r3, [r7, #4]
 800e652:	681b      	ldr	r3, [r3, #0]
 800e654:	6a1a      	ldr	r2, [r3, #32]
 800e656:	f241 1311 	movw	r3, #4369	; 0x1111
 800e65a:	4013      	ands	r3, r2
 800e65c:	2b00      	cmp	r3, #0
 800e65e:	d10f      	bne.n	800e680 <HAL_TIM_PWM_DeInit+0x40>
 800e660:	687b      	ldr	r3, [r7, #4]
 800e662:	681b      	ldr	r3, [r3, #0]
 800e664:	6a1a      	ldr	r2, [r3, #32]
 800e666:	f240 4344 	movw	r3, #1092	; 0x444
 800e66a:	4013      	ands	r3, r2
 800e66c:	2b00      	cmp	r3, #0
 800e66e:	d107      	bne.n	800e680 <HAL_TIM_PWM_DeInit+0x40>
 800e670:	687b      	ldr	r3, [r7, #4]
 800e672:	681b      	ldr	r3, [r3, #0]
 800e674:	687a      	ldr	r2, [r7, #4]
 800e676:	6812      	ldr	r2, [r2, #0]
 800e678:	6812      	ldr	r2, [r2, #0]
 800e67a:	f022 0201 	bic.w	r2, r2, #1
 800e67e:	601a      	str	r2, [r3, #0]
    
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
  HAL_TIM_PWM_MspDeInit(htim);
 800e680:	6878      	ldr	r0, [r7, #4]
 800e682:	f005 fdfb 	bl	801427c <HAL_TIM_PWM_MspDeInit>
    
  /* Change TIM state */  
  htim->State = HAL_TIM_STATE_RESET; 
 800e686:	687b      	ldr	r3, [r7, #4]
 800e688:	2200      	movs	r2, #0
 800e68a:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  /* Release Lock */
  __HAL_UNLOCK(htim);
 800e68e:	687b      	ldr	r3, [r7, #4]
 800e690:	2200      	movs	r2, #0
 800e692:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  return HAL_OK;
 800e696:	2300      	movs	r3, #0
}
 800e698:	4618      	mov	r0, r3
 800e69a:	3708      	adds	r7, #8
 800e69c:	46bd      	mov	sp, r7
 800e69e:	bd80      	pop	{r7, pc}

0800e6a0 <HAL_TIM_PWM_Start>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 800e6a0:	b580      	push	{r7, lr}
 800e6a2:	b082      	sub	sp, #8
 800e6a4:	af00      	add	r7, sp, #0
 800e6a6:	6078      	str	r0, [r7, #4]
 800e6a8:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Enable the Capture compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 800e6aa:	687b      	ldr	r3, [r7, #4]
 800e6ac:	681b      	ldr	r3, [r3, #0]
 800e6ae:	4618      	mov	r0, r3
 800e6b0:	6839      	ldr	r1, [r7, #0]
 800e6b2:	2201      	movs	r2, #1
 800e6b4:	f000 fd14 	bl	800f0e0 <TIM_CCxChannelCmd>
  
  if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
 800e6b8:	687b      	ldr	r3, [r7, #4]
 800e6ba:	681b      	ldr	r3, [r3, #0]
 800e6bc:	4a10      	ldr	r2, [pc, #64]	; (800e700 <HAL_TIM_PWM_Start+0x60>)
 800e6be:	4293      	cmp	r3, r2
 800e6c0:	d004      	beq.n	800e6cc <HAL_TIM_PWM_Start+0x2c>
 800e6c2:	687b      	ldr	r3, [r7, #4]
 800e6c4:	681b      	ldr	r3, [r3, #0]
 800e6c6:	4a0f      	ldr	r2, [pc, #60]	; (800e704 <HAL_TIM_PWM_Start+0x64>)
 800e6c8:	4293      	cmp	r3, r2
 800e6ca:	d101      	bne.n	800e6d0 <HAL_TIM_PWM_Start+0x30>
 800e6cc:	2301      	movs	r3, #1
 800e6ce:	e000      	b.n	800e6d2 <HAL_TIM_PWM_Start+0x32>
 800e6d0:	2300      	movs	r3, #0
 800e6d2:	2b00      	cmp	r3, #0
 800e6d4:	d007      	beq.n	800e6e6 <HAL_TIM_PWM_Start+0x46>
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
 800e6d6:	687b      	ldr	r3, [r7, #4]
 800e6d8:	681b      	ldr	r3, [r3, #0]
 800e6da:	687a      	ldr	r2, [r7, #4]
 800e6dc:	6812      	ldr	r2, [r2, #0]
 800e6de:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800e6e0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800e6e4:	645a      	str	r2, [r3, #68]	; 0x44
  }
    
  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 800e6e6:	687b      	ldr	r3, [r7, #4]
 800e6e8:	681b      	ldr	r3, [r3, #0]
 800e6ea:	687a      	ldr	r2, [r7, #4]
 800e6ec:	6812      	ldr	r2, [r2, #0]
 800e6ee:	6812      	ldr	r2, [r2, #0]
 800e6f0:	f042 0201 	orr.w	r2, r2, #1
 800e6f4:	601a      	str	r2, [r3, #0]
  
  /* Return function status */
  return HAL_OK;
 800e6f6:	2300      	movs	r3, #0
} 
 800e6f8:	4618      	mov	r0, r3
 800e6fa:	3708      	adds	r7, #8
 800e6fc:	46bd      	mov	sp, r7
 800e6fe:	bd80      	pop	{r7, pc}
 800e700:	40010000 	.word	0x40010000
 800e704:	40010400 	.word	0x40010400

0800e708 <HAL_TIM_IC_Init>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
{
 800e708:	b580      	push	{r7, lr}
 800e70a:	b082      	sub	sp, #8
 800e70c:	af00      	add	r7, sp, #0
 800e70e:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if(htim == NULL)
 800e710:	687b      	ldr	r3, [r7, #4]
 800e712:	2b00      	cmp	r3, #0
 800e714:	d101      	bne.n	800e71a <HAL_TIM_IC_Init+0x12>
  {
    return HAL_ERROR;
 800e716:	2301      	movs	r3, #1
 800e718:	e01d      	b.n	800e756 <HAL_TIM_IC_Init+0x4e>
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision)); 

  if(htim->State == HAL_TIM_STATE_RESET)
 800e71a:	687b      	ldr	r3, [r7, #4]
 800e71c:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 800e720:	b2db      	uxtb	r3, r3
 800e722:	2b00      	cmp	r3, #0
 800e724:	d106      	bne.n	800e734 <HAL_TIM_IC_Init+0x2c>
  { 
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;   
 800e726:	687b      	ldr	r3, [r7, #4]
 800e728:	2200      	movs	r2, #0
 800e72a:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_IC_MspInit(htim);
 800e72e:	6878      	ldr	r0, [r7, #4]
 800e730:	f000 f816 	bl	800e760 <HAL_TIM_IC_MspInit>
  }
  
  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;   
 800e734:	687b      	ldr	r3, [r7, #4]
 800e736:	2202      	movs	r2, #2
 800e738:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  /* Init the base time for the input capture */  
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
 800e73c:	687b      	ldr	r3, [r7, #4]
 800e73e:	681a      	ldr	r2, [r3, #0]
 800e740:	687b      	ldr	r3, [r7, #4]
 800e742:	3304      	adds	r3, #4
 800e744:	4610      	mov	r0, r2
 800e746:	4619      	mov	r1, r3
 800e748:	f000 fa5a 	bl	800ec00 <TIM_Base_SetConfig>
   
  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 800e74c:	687b      	ldr	r3, [r7, #4]
 800e74e:	2201      	movs	r2, #1
 800e750:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  return HAL_OK;
 800e754:	2300      	movs	r3, #0
}
 800e756:	4618      	mov	r0, r3
 800e758:	3708      	adds	r7, #8
 800e75a:	46bd      	mov	sp, r7
 800e75c:	bd80      	pop	{r7, pc}
 800e75e:	bf00      	nop

0800e760 <HAL_TIM_IC_MspInit>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
{
 800e760:	b480      	push	{r7}
 800e762:	b083      	sub	sp, #12
 800e764:	af00      	add	r7, sp, #0
 800e766:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIM_IC_MspInit could be implemented in the user file
   */
}
 800e768:	370c      	adds	r7, #12
 800e76a:	46bd      	mov	sp, r7
 800e76c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e770:	4770      	bx	lr
 800e772:	bf00      	nop

0800e774 <HAL_TIM_Encoder_Init>:
  *                the configuration information for TIM module.
  * @param  sConfig: TIM Encoder Interface configuration structure
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
{
 800e774:	b580      	push	{r7, lr}
 800e776:	b086      	sub	sp, #24
 800e778:	af00      	add	r7, sp, #0
 800e77a:	6078      	str	r0, [r7, #4]
 800e77c:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr = 0;
 800e77e:	2300      	movs	r3, #0
 800e780:	617b      	str	r3, [r7, #20]
  uint32_t tmpccmr1 = 0;
 800e782:	2300      	movs	r3, #0
 800e784:	613b      	str	r3, [r7, #16]
  uint32_t tmpccer = 0;
 800e786:	2300      	movs	r3, #0
 800e788:	60fb      	str	r3, [r7, #12]
  
  /* Check the TIM handle allocation */
  if(htim == NULL)
 800e78a:	687b      	ldr	r3, [r7, #4]
 800e78c:	2b00      	cmp	r3, #0
 800e78e:	d101      	bne.n	800e794 <HAL_TIM_Encoder_Init+0x20>
  {
    return HAL_ERROR;
 800e790:	2301      	movs	r3, #1
 800e792:	e07b      	b.n	800e88c <HAL_TIM_Encoder_Init+0x118>
  assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
  assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
  assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
  assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));

  if(htim->State == HAL_TIM_STATE_RESET)
 800e794:	687b      	ldr	r3, [r7, #4]
 800e796:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 800e79a:	b2db      	uxtb	r3, r3
 800e79c:	2b00      	cmp	r3, #0
 800e79e:	d106      	bne.n	800e7ae <HAL_TIM_Encoder_Init+0x3a>
  { 
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;  
 800e7a0:	687b      	ldr	r3, [r7, #4]
 800e7a2:	2200      	movs	r2, #0
 800e7a4:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_Encoder_MspInit(htim);
 800e7a8:	6878      	ldr	r0, [r7, #4]
 800e7aa:	f005 f907 	bl	80139bc <HAL_TIM_Encoder_MspInit>
  }
  
  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;   
 800e7ae:	687b      	ldr	r3, [r7, #4]
 800e7b0:	2202      	movs	r2, #2
 800e7b2:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    
  /* Reset the SMS bits */
  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
 800e7b6:	687b      	ldr	r3, [r7, #4]
 800e7b8:	681a      	ldr	r2, [r3, #0]
 800e7ba:	687b      	ldr	r3, [r7, #4]
 800e7bc:	681b      	ldr	r3, [r3, #0]
 800e7be:	6899      	ldr	r1, [r3, #8]
 800e7c0:	4b34      	ldr	r3, [pc, #208]	; (800e894 <HAL_TIM_Encoder_Init+0x120>)
 800e7c2:	400b      	ands	r3, r1
 800e7c4:	6093      	str	r3, [r2, #8]
  
  /* Configure the Time base in the Encoder Mode */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);  
 800e7c6:	687b      	ldr	r3, [r7, #4]
 800e7c8:	681a      	ldr	r2, [r3, #0]
 800e7ca:	687b      	ldr	r3, [r7, #4]
 800e7cc:	3304      	adds	r3, #4
 800e7ce:	4610      	mov	r0, r2
 800e7d0:	4619      	mov	r1, r3
 800e7d2:	f000 fa15 	bl	800ec00 <TIM_Base_SetConfig>
  
  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 800e7d6:	687b      	ldr	r3, [r7, #4]
 800e7d8:	681b      	ldr	r3, [r3, #0]
 800e7da:	689b      	ldr	r3, [r3, #8]
 800e7dc:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = htim->Instance->CCMR1;
 800e7de:	687b      	ldr	r3, [r7, #4]
 800e7e0:	681b      	ldr	r3, [r3, #0]
 800e7e2:	699b      	ldr	r3, [r3, #24]
 800e7e4:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCER register value */
  tmpccer = htim->Instance->CCER;
 800e7e6:	687b      	ldr	r3, [r7, #4]
 800e7e8:	681b      	ldr	r3, [r3, #0]
 800e7ea:	6a1b      	ldr	r3, [r3, #32]
 800e7ec:	60fb      	str	r3, [r7, #12]

  /* Set the encoder Mode */
  tmpsmcr |= sConfig->EncoderMode;
 800e7ee:	683b      	ldr	r3, [r7, #0]
 800e7f0:	681b      	ldr	r3, [r3, #0]
 800e7f2:	697a      	ldr	r2, [r7, #20]
 800e7f4:	4313      	orrs	r3, r2
 800e7f6:	617b      	str	r3, [r7, #20]

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
 800e7f8:	693a      	ldr	r2, [r7, #16]
 800e7fa:	4b27      	ldr	r3, [pc, #156]	; (800e898 <HAL_TIM_Encoder_Init+0x124>)
 800e7fc:	4013      	ands	r3, r2
 800e7fe:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
 800e800:	683b      	ldr	r3, [r7, #0]
 800e802:	689a      	ldr	r2, [r3, #8]
 800e804:	683b      	ldr	r3, [r7, #0]
 800e806:	699b      	ldr	r3, [r3, #24]
 800e808:	021b      	lsls	r3, r3, #8
 800e80a:	4313      	orrs	r3, r2
 800e80c:	693a      	ldr	r2, [r7, #16]
 800e80e:	4313      	orrs	r3, r2
 800e810:	613b      	str	r3, [r7, #16]
  
  /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
  tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
 800e812:	693a      	ldr	r2, [r7, #16]
 800e814:	4b21      	ldr	r3, [pc, #132]	; (800e89c <HAL_TIM_Encoder_Init+0x128>)
 800e816:	4013      	ands	r3, r2
 800e818:	613b      	str	r3, [r7, #16]
  tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
 800e81a:	693a      	ldr	r2, [r7, #16]
 800e81c:	4b20      	ldr	r3, [pc, #128]	; (800e8a0 <HAL_TIM_Encoder_Init+0x12c>)
 800e81e:	4013      	ands	r3, r2
 800e820:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8);
 800e822:	683b      	ldr	r3, [r7, #0]
 800e824:	68da      	ldr	r2, [r3, #12]
 800e826:	683b      	ldr	r3, [r7, #0]
 800e828:	69db      	ldr	r3, [r3, #28]
 800e82a:	021b      	lsls	r3, r3, #8
 800e82c:	4313      	orrs	r3, r2
 800e82e:	693a      	ldr	r2, [r7, #16]
 800e830:	4313      	orrs	r3, r2
 800e832:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
 800e834:	683b      	ldr	r3, [r7, #0]
 800e836:	691b      	ldr	r3, [r3, #16]
 800e838:	011a      	lsls	r2, r3, #4
 800e83a:	683b      	ldr	r3, [r7, #0]
 800e83c:	6a1b      	ldr	r3, [r3, #32]
 800e83e:	031b      	lsls	r3, r3, #12
 800e840:	4313      	orrs	r3, r2
 800e842:	693a      	ldr	r2, [r7, #16]
 800e844:	4313      	orrs	r3, r2
 800e846:	613b      	str	r3, [r7, #16]

  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
 800e848:	68fb      	ldr	r3, [r7, #12]
 800e84a:	f023 0322 	bic.w	r3, r3, #34	; 0x22
 800e84e:	60fb      	str	r3, [r7, #12]
  tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
 800e850:	68fb      	ldr	r3, [r7, #12]
 800e852:	f023 0388 	bic.w	r3, r3, #136	; 0x88
 800e856:	60fb      	str	r3, [r7, #12]
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
 800e858:	683b      	ldr	r3, [r7, #0]
 800e85a:	685a      	ldr	r2, [r3, #4]
 800e85c:	683b      	ldr	r3, [r7, #0]
 800e85e:	695b      	ldr	r3, [r3, #20]
 800e860:	011b      	lsls	r3, r3, #4
 800e862:	4313      	orrs	r3, r2
 800e864:	68fa      	ldr	r2, [r7, #12]
 800e866:	4313      	orrs	r3, r2
 800e868:	60fb      	str	r3, [r7, #12]
  
  /* Write to TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;
 800e86a:	687b      	ldr	r3, [r7, #4]
 800e86c:	681b      	ldr	r3, [r3, #0]
 800e86e:	697a      	ldr	r2, [r7, #20]
 800e870:	609a      	str	r2, [r3, #8]

  /* Write to TIMx CCMR1 */
  htim->Instance->CCMR1 = tmpccmr1;
 800e872:	687b      	ldr	r3, [r7, #4]
 800e874:	681b      	ldr	r3, [r3, #0]
 800e876:	693a      	ldr	r2, [r7, #16]
 800e878:	619a      	str	r2, [r3, #24]

  /* Write to TIMx CCER */
  htim->Instance->CCER = tmpccer;
 800e87a:	687b      	ldr	r3, [r7, #4]
 800e87c:	681b      	ldr	r3, [r3, #0]
 800e87e:	68fa      	ldr	r2, [r7, #12]
 800e880:	621a      	str	r2, [r3, #32]
  
  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 800e882:	687b      	ldr	r3, [r7, #4]
 800e884:	2201      	movs	r2, #1
 800e886:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  return HAL_OK;
 800e88a:	2300      	movs	r3, #0
}
 800e88c:	4618      	mov	r0, r3
 800e88e:	3718      	adds	r7, #24
 800e890:	46bd      	mov	sp, r7
 800e892:	bd80      	pop	{r7, pc}
 800e894:	fffefff8 	.word	0xfffefff8
 800e898:	fffffcfc 	.word	0xfffffcfc
 800e89c:	fffff3f3 	.word	0xfffff3f3
 800e8a0:	ffff0f0f 	.word	0xffff0f0f

0800e8a4 <HAL_TIM_Encoder_DeInit>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
{
 800e8a4:	b580      	push	{r7, lr}
 800e8a6:	b082      	sub	sp, #8
 800e8a8:	af00      	add	r7, sp, #0
 800e8aa:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  
  htim->State = HAL_TIM_STATE_BUSY;
 800e8ac:	687b      	ldr	r3, [r7, #4]
 800e8ae:	2202      	movs	r2, #2
 800e8b0:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  /* Disable the TIM Peripheral Clock */
  __HAL_TIM_DISABLE(htim);
 800e8b4:	687b      	ldr	r3, [r7, #4]
 800e8b6:	681b      	ldr	r3, [r3, #0]
 800e8b8:	6a1a      	ldr	r2, [r3, #32]
 800e8ba:	f241 1311 	movw	r3, #4369	; 0x1111
 800e8be:	4013      	ands	r3, r2
 800e8c0:	2b00      	cmp	r3, #0
 800e8c2:	d10f      	bne.n	800e8e4 <HAL_TIM_Encoder_DeInit+0x40>
 800e8c4:	687b      	ldr	r3, [r7, #4]
 800e8c6:	681b      	ldr	r3, [r3, #0]
 800e8c8:	6a1a      	ldr	r2, [r3, #32]
 800e8ca:	f240 4344 	movw	r3, #1092	; 0x444
 800e8ce:	4013      	ands	r3, r2
 800e8d0:	2b00      	cmp	r3, #0
 800e8d2:	d107      	bne.n	800e8e4 <HAL_TIM_Encoder_DeInit+0x40>
 800e8d4:	687b      	ldr	r3, [r7, #4]
 800e8d6:	681b      	ldr	r3, [r3, #0]
 800e8d8:	687a      	ldr	r2, [r7, #4]
 800e8da:	6812      	ldr	r2, [r2, #0]
 800e8dc:	6812      	ldr	r2, [r2, #0]
 800e8de:	f022 0201 	bic.w	r2, r2, #1
 800e8e2:	601a      	str	r2, [r3, #0]
  
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_TIM_Encoder_MspDeInit(htim);
 800e8e4:	6878      	ldr	r0, [r7, #4]
 800e8e6:	f005 f8a7 	bl	8013a38 <HAL_TIM_Encoder_MspDeInit>
    
  /* Change TIM state */  
  htim->State = HAL_TIM_STATE_RESET;
 800e8ea:	687b      	ldr	r3, [r7, #4]
 800e8ec:	2200      	movs	r2, #0
 800e8ee:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
 
  /* Release Lock */
  __HAL_UNLOCK(htim);
 800e8f2:	687b      	ldr	r3, [r7, #4]
 800e8f4:	2200      	movs	r2, #0
 800e8f6:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  return HAL_OK;
 800e8fa:	2300      	movs	r3, #0
}
 800e8fc:	4618      	mov	r0, r3
 800e8fe:	3708      	adds	r7, #8
 800e900:	46bd      	mov	sp, r7
 800e902:	bd80      	pop	{r7, pc}

0800e904 <HAL_TIM_Encoder_Start>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 800e904:	b580      	push	{r7, lr}
 800e906:	b082      	sub	sp, #8
 800e908:	af00      	add	r7, sp, #0
 800e90a:	6078      	str	r0, [r7, #4]
 800e90c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
  
  /* Enable the encoder interface channels */
  switch (Channel)
 800e90e:	683b      	ldr	r3, [r7, #0]
 800e910:	2b00      	cmp	r3, #0
 800e912:	d002      	beq.n	800e91a <HAL_TIM_Encoder_Start+0x16>
 800e914:	2b04      	cmp	r3, #4
 800e916:	d008      	beq.n	800e92a <HAL_TIM_Encoder_Start+0x26>
 800e918:	e00f      	b.n	800e93a <HAL_TIM_Encoder_Start+0x36>
  {
    case TIM_CHANNEL_1:
    {
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
 800e91a:	687b      	ldr	r3, [r7, #4]
 800e91c:	681b      	ldr	r3, [r3, #0]
 800e91e:	4618      	mov	r0, r3
 800e920:	2100      	movs	r1, #0
 800e922:	2201      	movs	r2, #1
 800e924:	f000 fbdc 	bl	800f0e0 <TIM_CCxChannelCmd>
      break; 
 800e928:	e016      	b.n	800e958 <HAL_TIM_Encoder_Start+0x54>
    }
    case TIM_CHANNEL_2:
    { 
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
 800e92a:	687b      	ldr	r3, [r7, #4]
 800e92c:	681b      	ldr	r3, [r3, #0]
 800e92e:	4618      	mov	r0, r3
 800e930:	2104      	movs	r1, #4
 800e932:	2201      	movs	r2, #1
 800e934:	f000 fbd4 	bl	800f0e0 <TIM_CCxChannelCmd>
      break;
 800e938:	e00e      	b.n	800e958 <HAL_TIM_Encoder_Start+0x54>
    }  
    default :
    {
     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
 800e93a:	687b      	ldr	r3, [r7, #4]
 800e93c:	681b      	ldr	r3, [r3, #0]
 800e93e:	4618      	mov	r0, r3
 800e940:	2100      	movs	r1, #0
 800e942:	2201      	movs	r2, #1
 800e944:	f000 fbcc 	bl	800f0e0 <TIM_CCxChannelCmd>
     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
 800e948:	687b      	ldr	r3, [r7, #4]
 800e94a:	681b      	ldr	r3, [r3, #0]
 800e94c:	4618      	mov	r0, r3
 800e94e:	2104      	movs	r1, #4
 800e950:	2201      	movs	r2, #1
 800e952:	f000 fbc5 	bl	800f0e0 <TIM_CCxChannelCmd>
     break; 
 800e956:	bf00      	nop
    }
  }  
  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 800e958:	687b      	ldr	r3, [r7, #4]
 800e95a:	681b      	ldr	r3, [r3, #0]
 800e95c:	687a      	ldr	r2, [r7, #4]
 800e95e:	6812      	ldr	r2, [r2, #0]
 800e960:	6812      	ldr	r2, [r2, #0]
 800e962:	f042 0201 	orr.w	r2, r2, #1
 800e966:	601a      	str	r2, [r3, #0]
  
  /* Return function status */
  return HAL_OK;
 800e968:	2300      	movs	r3, #0
}
 800e96a:	4618      	mov	r0, r3
 800e96c:	3708      	adds	r7, #8
 800e96e:	46bd      	mov	sp, r7
 800e970:	bd80      	pop	{r7, pc}
 800e972:	bf00      	nop

0800e974 <HAL_TIM_IRQHandler>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 800e974:	b580      	push	{r7, lr}
 800e976:	b082      	sub	sp, #8
 800e978:	af00      	add	r7, sp, #0
 800e97a:	6078      	str	r0, [r7, #4]
  /* Capture compare 1 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 800e97c:	687b      	ldr	r3, [r7, #4]
 800e97e:	681b      	ldr	r3, [r3, #0]
 800e980:	691b      	ldr	r3, [r3, #16]
 800e982:	f003 0302 	and.w	r3, r3, #2
 800e986:	2b00      	cmp	r3, #0
 800e988:	d022      	beq.n	800e9d0 <HAL_TIM_IRQHandler+0x5c>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
 800e98a:	687b      	ldr	r3, [r7, #4]
 800e98c:	681b      	ldr	r3, [r3, #0]
 800e98e:	68db      	ldr	r3, [r3, #12]
 800e990:	f003 0302 	and.w	r3, r3, #2
 800e994:	2b00      	cmp	r3, #0
 800e996:	d01b      	beq.n	800e9d0 <HAL_TIM_IRQHandler+0x5c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 800e998:	687b      	ldr	r3, [r7, #4]
 800e99a:	681b      	ldr	r3, [r3, #0]
 800e99c:	f06f 0202 	mvn.w	r2, #2
 800e9a0:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800e9a2:	687b      	ldr	r3, [r7, #4]
 800e9a4:	2201      	movs	r2, #1
 800e9a6:	761a      	strb	r2, [r3, #24]
        
        /* Input capture event */
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
 800e9a8:	687b      	ldr	r3, [r7, #4]
 800e9aa:	681b      	ldr	r3, [r3, #0]
 800e9ac:	699b      	ldr	r3, [r3, #24]
 800e9ae:	f003 0303 	and.w	r3, r3, #3
 800e9b2:	2b00      	cmp	r3, #0
 800e9b4:	d003      	beq.n	800e9be <HAL_TIM_IRQHandler+0x4a>
        {
          HAL_TIM_IC_CaptureCallback(htim);
 800e9b6:	6878      	ldr	r0, [r7, #4]
 800e9b8:	f000 f904 	bl	800ebc4 <HAL_TIM_IC_CaptureCallback>
 800e9bc:	e005      	b.n	800e9ca <HAL_TIM_IRQHandler+0x56>
        }
        /* Output compare event */
        else
        {
          HAL_TIM_OC_DelayElapsedCallback(htim);
 800e9be:	6878      	ldr	r0, [r7, #4]
 800e9c0:	f000 f8f6 	bl	800ebb0 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 800e9c4:	6878      	ldr	r0, [r7, #4]
 800e9c6:	f000 f907 	bl	800ebd8 <HAL_TIM_PWM_PulseFinishedCallback>
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800e9ca:	687b      	ldr	r3, [r7, #4]
 800e9cc:	2200      	movs	r2, #0
 800e9ce:	761a      	strb	r2, [r3, #24]
      }
    }
  }
  /* Capture compare 2 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 800e9d0:	687b      	ldr	r3, [r7, #4]
 800e9d2:	681b      	ldr	r3, [r3, #0]
 800e9d4:	691b      	ldr	r3, [r3, #16]
 800e9d6:	f003 0304 	and.w	r3, r3, #4
 800e9da:	2b00      	cmp	r3, #0
 800e9dc:	d022      	beq.n	800ea24 <HAL_TIM_IRQHandler+0xb0>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
 800e9de:	687b      	ldr	r3, [r7, #4]
 800e9e0:	681b      	ldr	r3, [r3, #0]
 800e9e2:	68db      	ldr	r3, [r3, #12]
 800e9e4:	f003 0304 	and.w	r3, r3, #4
 800e9e8:	2b00      	cmp	r3, #0
 800e9ea:	d01b      	beq.n	800ea24 <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 800e9ec:	687b      	ldr	r3, [r7, #4]
 800e9ee:	681b      	ldr	r3, [r3, #0]
 800e9f0:	f06f 0204 	mvn.w	r2, #4
 800e9f4:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800e9f6:	687b      	ldr	r3, [r7, #4]
 800e9f8:	2202      	movs	r2, #2
 800e9fa:	761a      	strb	r2, [r3, #24]
      /* Input capture event */
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
 800e9fc:	687b      	ldr	r3, [r7, #4]
 800e9fe:	681b      	ldr	r3, [r3, #0]
 800ea00:	699b      	ldr	r3, [r3, #24]
 800ea02:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800ea06:	2b00      	cmp	r3, #0
 800ea08:	d003      	beq.n	800ea12 <HAL_TIM_IRQHandler+0x9e>
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 800ea0a:	6878      	ldr	r0, [r7, #4]
 800ea0c:	f000 f8da 	bl	800ebc4 <HAL_TIM_IC_CaptureCallback>
 800ea10:	e005      	b.n	800ea1e <HAL_TIM_IRQHandler+0xaa>
      }
      /* Output compare event */
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800ea12:	6878      	ldr	r0, [r7, #4]
 800ea14:	f000 f8cc 	bl	800ebb0 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800ea18:	6878      	ldr	r0, [r7, #4]
 800ea1a:	f000 f8dd 	bl	800ebd8 <HAL_TIM_PWM_PulseFinishedCallback>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800ea1e:	687b      	ldr	r3, [r7, #4]
 800ea20:	2200      	movs	r2, #0
 800ea22:	761a      	strb	r2, [r3, #24]
    }
  }
  /* Capture compare 3 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 800ea24:	687b      	ldr	r3, [r7, #4]
 800ea26:	681b      	ldr	r3, [r3, #0]
 800ea28:	691b      	ldr	r3, [r3, #16]
 800ea2a:	f003 0308 	and.w	r3, r3, #8
 800ea2e:	2b00      	cmp	r3, #0
 800ea30:	d022      	beq.n	800ea78 <HAL_TIM_IRQHandler+0x104>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
 800ea32:	687b      	ldr	r3, [r7, #4]
 800ea34:	681b      	ldr	r3, [r3, #0]
 800ea36:	68db      	ldr	r3, [r3, #12]
 800ea38:	f003 0308 	and.w	r3, r3, #8
 800ea3c:	2b00      	cmp	r3, #0
 800ea3e:	d01b      	beq.n	800ea78 <HAL_TIM_IRQHandler+0x104>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 800ea40:	687b      	ldr	r3, [r7, #4]
 800ea42:	681b      	ldr	r3, [r3, #0]
 800ea44:	f06f 0208 	mvn.w	r2, #8
 800ea48:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800ea4a:	687b      	ldr	r3, [r7, #4]
 800ea4c:	2204      	movs	r2, #4
 800ea4e:	761a      	strb	r2, [r3, #24]
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
 800ea50:	687b      	ldr	r3, [r7, #4]
 800ea52:	681b      	ldr	r3, [r3, #0]
 800ea54:	69db      	ldr	r3, [r3, #28]
 800ea56:	f003 0303 	and.w	r3, r3, #3
 800ea5a:	2b00      	cmp	r3, #0
 800ea5c:	d003      	beq.n	800ea66 <HAL_TIM_IRQHandler+0xf2>
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 800ea5e:	6878      	ldr	r0, [r7, #4]
 800ea60:	f000 f8b0 	bl	800ebc4 <HAL_TIM_IC_CaptureCallback>
 800ea64:	e005      	b.n	800ea72 <HAL_TIM_IRQHandler+0xfe>
      }
      /* Output compare event */
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800ea66:	6878      	ldr	r0, [r7, #4]
 800ea68:	f000 f8a2 	bl	800ebb0 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim); 
 800ea6c:	6878      	ldr	r0, [r7, #4]
 800ea6e:	f000 f8b3 	bl	800ebd8 <HAL_TIM_PWM_PulseFinishedCallback>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800ea72:	687b      	ldr	r3, [r7, #4]
 800ea74:	2200      	movs	r2, #0
 800ea76:	761a      	strb	r2, [r3, #24]
    }
  }
  /* Capture compare 4 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 800ea78:	687b      	ldr	r3, [r7, #4]
 800ea7a:	681b      	ldr	r3, [r3, #0]
 800ea7c:	691b      	ldr	r3, [r3, #16]
 800ea7e:	f003 0310 	and.w	r3, r3, #16
 800ea82:	2b00      	cmp	r3, #0
 800ea84:	d022      	beq.n	800eacc <HAL_TIM_IRQHandler+0x158>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
 800ea86:	687b      	ldr	r3, [r7, #4]
 800ea88:	681b      	ldr	r3, [r3, #0]
 800ea8a:	68db      	ldr	r3, [r3, #12]
 800ea8c:	f003 0310 	and.w	r3, r3, #16
 800ea90:	2b00      	cmp	r3, #0
 800ea92:	d01b      	beq.n	800eacc <HAL_TIM_IRQHandler+0x158>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 800ea94:	687b      	ldr	r3, [r7, #4]
 800ea96:	681b      	ldr	r3, [r3, #0]
 800ea98:	f06f 0210 	mvn.w	r2, #16
 800ea9c:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800ea9e:	687b      	ldr	r3, [r7, #4]
 800eaa0:	2208      	movs	r2, #8
 800eaa2:	761a      	strb	r2, [r3, #24]
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
 800eaa4:	687b      	ldr	r3, [r7, #4]
 800eaa6:	681b      	ldr	r3, [r3, #0]
 800eaa8:	69db      	ldr	r3, [r3, #28]
 800eaaa:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800eaae:	2b00      	cmp	r3, #0
 800eab0:	d003      	beq.n	800eaba <HAL_TIM_IRQHandler+0x146>
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 800eab2:	6878      	ldr	r0, [r7, #4]
 800eab4:	f000 f886 	bl	800ebc4 <HAL_TIM_IC_CaptureCallback>
 800eab8:	e005      	b.n	800eac6 <HAL_TIM_IRQHandler+0x152>
      }
      /* Output compare event */
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800eaba:	6878      	ldr	r0, [r7, #4]
 800eabc:	f000 f878 	bl	800ebb0 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800eac0:	6878      	ldr	r0, [r7, #4]
 800eac2:	f000 f889 	bl	800ebd8 <HAL_TIM_PWM_PulseFinishedCallback>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800eac6:	687b      	ldr	r3, [r7, #4]
 800eac8:	2200      	movs	r2, #0
 800eaca:	761a      	strb	r2, [r3, #24]
    }
  }
  /* TIM Update event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 800eacc:	687b      	ldr	r3, [r7, #4]
 800eace:	681b      	ldr	r3, [r3, #0]
 800ead0:	691b      	ldr	r3, [r3, #16]
 800ead2:	f003 0301 	and.w	r3, r3, #1
 800ead6:	2b00      	cmp	r3, #0
 800ead8:	d00e      	beq.n	800eaf8 <HAL_TIM_IRQHandler+0x184>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
 800eada:	687b      	ldr	r3, [r7, #4]
 800eadc:	681b      	ldr	r3, [r3, #0]
 800eade:	68db      	ldr	r3, [r3, #12]
 800eae0:	f003 0301 	and.w	r3, r3, #1
 800eae4:	2b00      	cmp	r3, #0
 800eae6:	d007      	beq.n	800eaf8 <HAL_TIM_IRQHandler+0x184>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 800eae8:	687b      	ldr	r3, [r7, #4]
 800eaea:	681b      	ldr	r3, [r3, #0]
 800eaec:	f06f 0201 	mvn.w	r2, #1
 800eaf0:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 800eaf2:	6878      	ldr	r0, [r7, #4]
 800eaf4:	f004 ff28 	bl	8013948 <HAL_TIM_PeriodElapsedCallback>
    }
  }
  /* TIM Break input event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 800eaf8:	687b      	ldr	r3, [r7, #4]
 800eafa:	681b      	ldr	r3, [r3, #0]
 800eafc:	691b      	ldr	r3, [r3, #16]
 800eafe:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800eb02:	2b00      	cmp	r3, #0
 800eb04:	d00e      	beq.n	800eb24 <HAL_TIM_IRQHandler+0x1b0>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
 800eb06:	687b      	ldr	r3, [r7, #4]
 800eb08:	681b      	ldr	r3, [r3, #0]
 800eb0a:	68db      	ldr	r3, [r3, #12]
 800eb0c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800eb10:	2b00      	cmp	r3, #0
 800eb12:	d007      	beq.n	800eb24 <HAL_TIM_IRQHandler+0x1b0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 800eb14:	687b      	ldr	r3, [r7, #4]
 800eb16:	681b      	ldr	r3, [r3, #0]
 800eb18:	f06f 0280 	mvn.w	r2, #128	; 0x80
 800eb1c:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 800eb1e:	6878      	ldr	r0, [r7, #4]
 800eb20:	f005 fa6a 	bl	8013ff8 <HAL_TIMEx_BreakCallback>
    }
  }
  
    /* TIM Break input event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 800eb24:	687b      	ldr	r3, [r7, #4]
 800eb26:	681b      	ldr	r3, [r3, #0]
 800eb28:	691b      	ldr	r3, [r3, #16]
 800eb2a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800eb2e:	2b00      	cmp	r3, #0
 800eb30:	d00e      	beq.n	800eb50 <HAL_TIM_IRQHandler+0x1dc>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
 800eb32:	687b      	ldr	r3, [r7, #4]
 800eb34:	681b      	ldr	r3, [r3, #0]
 800eb36:	68db      	ldr	r3, [r3, #12]
 800eb38:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800eb3c:	2b00      	cmp	r3, #0
 800eb3e:	d007      	beq.n	800eb50 <HAL_TIM_IRQHandler+0x1dc>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 800eb40:	687b      	ldr	r3, [r7, #4]
 800eb42:	681b      	ldr	r3, [r3, #0]
 800eb44:	f06f 0280 	mvn.w	r2, #128	; 0x80
 800eb48:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 800eb4a:	6878      	ldr	r0, [r7, #4]
 800eb4c:	f005 fa54 	bl	8013ff8 <HAL_TIMEx_BreakCallback>
    }
  }

  /* TIM Trigger detection event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 800eb50:	687b      	ldr	r3, [r7, #4]
 800eb52:	681b      	ldr	r3, [r3, #0]
 800eb54:	691b      	ldr	r3, [r3, #16]
 800eb56:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800eb5a:	2b00      	cmp	r3, #0
 800eb5c:	d00e      	beq.n	800eb7c <HAL_TIM_IRQHandler+0x208>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
 800eb5e:	687b      	ldr	r3, [r7, #4]
 800eb60:	681b      	ldr	r3, [r3, #0]
 800eb62:	68db      	ldr	r3, [r3, #12]
 800eb64:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800eb68:	2b00      	cmp	r3, #0
 800eb6a:	d007      	beq.n	800eb7c <HAL_TIM_IRQHandler+0x208>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 800eb6c:	687b      	ldr	r3, [r7, #4]
 800eb6e:	681b      	ldr	r3, [r3, #0]
 800eb70:	f06f 0240 	mvn.w	r2, #64	; 0x40
 800eb74:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 800eb76:	6878      	ldr	r0, [r7, #4]
 800eb78:	f000 f838 	bl	800ebec <HAL_TIM_TriggerCallback>
    }
  }
  /* TIM commutation event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 800eb7c:	687b      	ldr	r3, [r7, #4]
 800eb7e:	681b      	ldr	r3, [r3, #0]
 800eb80:	691b      	ldr	r3, [r3, #16]
 800eb82:	f003 0320 	and.w	r3, r3, #32
 800eb86:	2b00      	cmp	r3, #0
 800eb88:	d00e      	beq.n	800eba8 <HAL_TIM_IRQHandler+0x234>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
 800eb8a:	687b      	ldr	r3, [r7, #4]
 800eb8c:	681b      	ldr	r3, [r3, #0]
 800eb8e:	68db      	ldr	r3, [r3, #12]
 800eb90:	f003 0320 	and.w	r3, r3, #32
 800eb94:	2b00      	cmp	r3, #0
 800eb96:	d007      	beq.n	800eba8 <HAL_TIM_IRQHandler+0x234>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 800eb98:	687b      	ldr	r3, [r7, #4]
 800eb9a:	681b      	ldr	r3, [r3, #0]
 800eb9c:	f06f 0220 	mvn.w	r2, #32
 800eba0:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutationCallback(htim);
 800eba2:	6878      	ldr	r0, [r7, #4]
 800eba4:	f000 fc8c 	bl	800f4c0 <HAL_TIMEx_CommutationCallback>
    }
  }
}
 800eba8:	3708      	adds	r7, #8
 800ebaa:	46bd      	mov	sp, r7
 800ebac:	bd80      	pop	{r7, pc}
 800ebae:	bf00      	nop

0800ebb0 <HAL_TIM_OC_DelayElapsedCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 800ebb0:	b480      	push	{r7}
 800ebb2:	b083      	sub	sp, #12
 800ebb4:	af00      	add	r7, sp, #0
 800ebb6:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 800ebb8:	370c      	adds	r7, #12
 800ebba:	46bd      	mov	sp, r7
 800ebbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ebc0:	4770      	bx	lr
 800ebc2:	bf00      	nop

0800ebc4 <HAL_TIM_IC_CaptureCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 800ebc4:	b480      	push	{r7}
 800ebc6:	b083      	sub	sp, #12
 800ebc8:	af00      	add	r7, sp, #0
 800ebca:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 800ebcc:	370c      	adds	r7, #12
 800ebce:	46bd      	mov	sp, r7
 800ebd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ebd4:	4770      	bx	lr
 800ebd6:	bf00      	nop

0800ebd8 <HAL_TIM_PWM_PulseFinishedCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 800ebd8:	b480      	push	{r7}
 800ebda:	b083      	sub	sp, #12
 800ebdc:	af00      	add	r7, sp, #0
 800ebde:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 800ebe0:	370c      	adds	r7, #12
 800ebe2:	46bd      	mov	sp, r7
 800ebe4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ebe8:	4770      	bx	lr
 800ebea:	bf00      	nop

0800ebec <HAL_TIM_TriggerCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 800ebec:	b480      	push	{r7}
 800ebee:	b083      	sub	sp, #12
 800ebf0:	af00      	add	r7, sp, #0
 800ebf2:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 800ebf4:	370c      	adds	r7, #12
 800ebf6:	46bd      	mov	sp, r7
 800ebf8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ebfc:	4770      	bx	lr
 800ebfe:	bf00      	nop

0800ec00 <TIM_Base_SetConfig>:
  * @param  TIMx: TIM peripheral
  * @param  Structure: pointer on TIM Time Base required parameters  
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 800ec00:	b480      	push	{r7}
 800ec02:	b085      	sub	sp, #20
 800ec04:	af00      	add	r7, sp, #0
 800ec06:	6078      	str	r0, [r7, #4]
 800ec08:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1 = 0;
 800ec0a:	2300      	movs	r3, #0
 800ec0c:	60fb      	str	r3, [r7, #12]
  tmpcr1 = TIMx->CR1;
 800ec0e:	687b      	ldr	r3, [r7, #4]
 800ec10:	681b      	ldr	r3, [r3, #0]
 800ec12:	60fb      	str	r3, [r7, #12]
  
  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
 800ec14:	687b      	ldr	r3, [r7, #4]
 800ec16:	4a43      	ldr	r2, [pc, #268]	; (800ed24 <TIM_Base_SetConfig+0x124>)
 800ec18:	4293      	cmp	r3, r2
 800ec1a:	d013      	beq.n	800ec44 <TIM_Base_SetConfig+0x44>
 800ec1c:	687b      	ldr	r3, [r7, #4]
 800ec1e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800ec22:	d00f      	beq.n	800ec44 <TIM_Base_SetConfig+0x44>
 800ec24:	687b      	ldr	r3, [r7, #4]
 800ec26:	4a40      	ldr	r2, [pc, #256]	; (800ed28 <TIM_Base_SetConfig+0x128>)
 800ec28:	4293      	cmp	r3, r2
 800ec2a:	d00b      	beq.n	800ec44 <TIM_Base_SetConfig+0x44>
 800ec2c:	687b      	ldr	r3, [r7, #4]
 800ec2e:	4a3f      	ldr	r2, [pc, #252]	; (800ed2c <TIM_Base_SetConfig+0x12c>)
 800ec30:	4293      	cmp	r3, r2
 800ec32:	d007      	beq.n	800ec44 <TIM_Base_SetConfig+0x44>
 800ec34:	687b      	ldr	r3, [r7, #4]
 800ec36:	4a3e      	ldr	r2, [pc, #248]	; (800ed30 <TIM_Base_SetConfig+0x130>)
 800ec38:	4293      	cmp	r3, r2
 800ec3a:	d003      	beq.n	800ec44 <TIM_Base_SetConfig+0x44>
 800ec3c:	687b      	ldr	r3, [r7, #4]
 800ec3e:	4a3d      	ldr	r2, [pc, #244]	; (800ed34 <TIM_Base_SetConfig+0x134>)
 800ec40:	4293      	cmp	r3, r2
 800ec42:	d101      	bne.n	800ec48 <TIM_Base_SetConfig+0x48>
 800ec44:	2301      	movs	r3, #1
 800ec46:	e000      	b.n	800ec4a <TIM_Base_SetConfig+0x4a>
 800ec48:	2300      	movs	r3, #0
 800ec4a:	2b00      	cmp	r3, #0
 800ec4c:	d008      	beq.n	800ec60 <TIM_Base_SetConfig+0x60>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800ec4e:	68fb      	ldr	r3, [r7, #12]
 800ec50:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800ec54:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 800ec56:	683b      	ldr	r3, [r7, #0]
 800ec58:	685b      	ldr	r3, [r3, #4]
 800ec5a:	68fa      	ldr	r2, [r7, #12]
 800ec5c:	4313      	orrs	r3, r2
 800ec5e:	60fb      	str	r3, [r7, #12]
  }
 
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
 800ec60:	687b      	ldr	r3, [r7, #4]
 800ec62:	4a30      	ldr	r2, [pc, #192]	; (800ed24 <TIM_Base_SetConfig+0x124>)
 800ec64:	4293      	cmp	r3, r2
 800ec66:	d02b      	beq.n	800ecc0 <TIM_Base_SetConfig+0xc0>
 800ec68:	687b      	ldr	r3, [r7, #4]
 800ec6a:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800ec6e:	d027      	beq.n	800ecc0 <TIM_Base_SetConfig+0xc0>
 800ec70:	687b      	ldr	r3, [r7, #4]
 800ec72:	4a2d      	ldr	r2, [pc, #180]	; (800ed28 <TIM_Base_SetConfig+0x128>)
 800ec74:	4293      	cmp	r3, r2
 800ec76:	d023      	beq.n	800ecc0 <TIM_Base_SetConfig+0xc0>
 800ec78:	687b      	ldr	r3, [r7, #4]
 800ec7a:	4a2c      	ldr	r2, [pc, #176]	; (800ed2c <TIM_Base_SetConfig+0x12c>)
 800ec7c:	4293      	cmp	r3, r2
 800ec7e:	d01f      	beq.n	800ecc0 <TIM_Base_SetConfig+0xc0>
 800ec80:	687b      	ldr	r3, [r7, #4]
 800ec82:	4a2b      	ldr	r2, [pc, #172]	; (800ed30 <TIM_Base_SetConfig+0x130>)
 800ec84:	4293      	cmp	r3, r2
 800ec86:	d01b      	beq.n	800ecc0 <TIM_Base_SetConfig+0xc0>
 800ec88:	687b      	ldr	r3, [r7, #4]
 800ec8a:	4a2a      	ldr	r2, [pc, #168]	; (800ed34 <TIM_Base_SetConfig+0x134>)
 800ec8c:	4293      	cmp	r3, r2
 800ec8e:	d017      	beq.n	800ecc0 <TIM_Base_SetConfig+0xc0>
 800ec90:	687b      	ldr	r3, [r7, #4]
 800ec92:	4a29      	ldr	r2, [pc, #164]	; (800ed38 <TIM_Base_SetConfig+0x138>)
 800ec94:	4293      	cmp	r3, r2
 800ec96:	d013      	beq.n	800ecc0 <TIM_Base_SetConfig+0xc0>
 800ec98:	687b      	ldr	r3, [r7, #4]
 800ec9a:	4a28      	ldr	r2, [pc, #160]	; (800ed3c <TIM_Base_SetConfig+0x13c>)
 800ec9c:	4293      	cmp	r3, r2
 800ec9e:	d00f      	beq.n	800ecc0 <TIM_Base_SetConfig+0xc0>
 800eca0:	687b      	ldr	r3, [r7, #4]
 800eca2:	4a27      	ldr	r2, [pc, #156]	; (800ed40 <TIM_Base_SetConfig+0x140>)
 800eca4:	4293      	cmp	r3, r2
 800eca6:	d00b      	beq.n	800ecc0 <TIM_Base_SetConfig+0xc0>
 800eca8:	687b      	ldr	r3, [r7, #4]
 800ecaa:	4a26      	ldr	r2, [pc, #152]	; (800ed44 <TIM_Base_SetConfig+0x144>)
 800ecac:	4293      	cmp	r3, r2
 800ecae:	d007      	beq.n	800ecc0 <TIM_Base_SetConfig+0xc0>
 800ecb0:	687b      	ldr	r3, [r7, #4]
 800ecb2:	4a25      	ldr	r2, [pc, #148]	; (800ed48 <TIM_Base_SetConfig+0x148>)
 800ecb4:	4293      	cmp	r3, r2
 800ecb6:	d003      	beq.n	800ecc0 <TIM_Base_SetConfig+0xc0>
 800ecb8:	687b      	ldr	r3, [r7, #4]
 800ecba:	4a24      	ldr	r2, [pc, #144]	; (800ed4c <TIM_Base_SetConfig+0x14c>)
 800ecbc:	4293      	cmp	r3, r2
 800ecbe:	d101      	bne.n	800ecc4 <TIM_Base_SetConfig+0xc4>
 800ecc0:	2301      	movs	r3, #1
 800ecc2:	e000      	b.n	800ecc6 <TIM_Base_SetConfig+0xc6>
 800ecc4:	2300      	movs	r3, #0
 800ecc6:	2b00      	cmp	r3, #0
 800ecc8:	d008      	beq.n	800ecdc <TIM_Base_SetConfig+0xdc>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 800ecca:	68fb      	ldr	r3, [r7, #12]
 800eccc:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800ecd0:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800ecd2:	683b      	ldr	r3, [r7, #0]
 800ecd4:	68db      	ldr	r3, [r3, #12]
 800ecd6:	68fa      	ldr	r2, [r7, #12]
 800ecd8:	4313      	orrs	r3, r2
 800ecda:	60fb      	str	r3, [r7, #12]
  }

  TIMx->CR1 = tmpcr1;
 800ecdc:	687b      	ldr	r3, [r7, #4]
 800ecde:	68fa      	ldr	r2, [r7, #12]
 800ece0:	601a      	str	r2, [r3, #0]

  /* Set the Auto-reload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 800ece2:	683b      	ldr	r3, [r7, #0]
 800ece4:	689a      	ldr	r2, [r3, #8]
 800ece6:	687b      	ldr	r3, [r7, #4]
 800ece8:	62da      	str	r2, [r3, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 800ecea:	683b      	ldr	r3, [r7, #0]
 800ecec:	681a      	ldr	r2, [r3, #0]
 800ecee:	687b      	ldr	r3, [r7, #4]
 800ecf0:	629a      	str	r2, [r3, #40]	; 0x28
    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
 800ecf2:	687b      	ldr	r3, [r7, #4]
 800ecf4:	4a0b      	ldr	r2, [pc, #44]	; (800ed24 <TIM_Base_SetConfig+0x124>)
 800ecf6:	4293      	cmp	r3, r2
 800ecf8:	d003      	beq.n	800ed02 <TIM_Base_SetConfig+0x102>
 800ecfa:	687b      	ldr	r3, [r7, #4]
 800ecfc:	4a0d      	ldr	r2, [pc, #52]	; (800ed34 <TIM_Base_SetConfig+0x134>)
 800ecfe:	4293      	cmp	r3, r2
 800ed00:	d101      	bne.n	800ed06 <TIM_Base_SetConfig+0x106>
 800ed02:	2301      	movs	r3, #1
 800ed04:	e000      	b.n	800ed08 <TIM_Base_SetConfig+0x108>
 800ed06:	2300      	movs	r3, #0
 800ed08:	2b00      	cmp	r3, #0
 800ed0a:	d003      	beq.n	800ed14 <TIM_Base_SetConfig+0x114>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 800ed0c:	683b      	ldr	r3, [r7, #0]
 800ed0e:	691a      	ldr	r2, [r3, #16]
 800ed10:	687b      	ldr	r3, [r7, #4]
 800ed12:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 800ed14:	687b      	ldr	r3, [r7, #4]
 800ed16:	2201      	movs	r2, #1
 800ed18:	615a      	str	r2, [r3, #20]
}
 800ed1a:	3714      	adds	r7, #20
 800ed1c:	46bd      	mov	sp, r7
 800ed1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ed22:	4770      	bx	lr
 800ed24:	40010000 	.word	0x40010000
 800ed28:	40000400 	.word	0x40000400
 800ed2c:	40000800 	.word	0x40000800
 800ed30:	40000c00 	.word	0x40000c00
 800ed34:	40010400 	.word	0x40010400
 800ed38:	40014000 	.word	0x40014000
 800ed3c:	40014400 	.word	0x40014400
 800ed40:	40014800 	.word	0x40014800
 800ed44:	40001800 	.word	0x40001800
 800ed48:	40001c00 	.word	0x40001c00
 800ed4c:	40002000 	.word	0x40002000

0800ed50 <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800ed50:	b480      	push	{r7}
 800ed52:	b087      	sub	sp, #28
 800ed54:	af00      	add	r7, sp, #0
 800ed56:	6078      	str	r0, [r7, #4]
 800ed58:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0;
 800ed5a:	2300      	movs	r3, #0
 800ed5c:	60fb      	str	r3, [r7, #12]
  uint32_t tmpccer = 0;
 800ed5e:	2300      	movs	r3, #0
 800ed60:	617b      	str	r3, [r7, #20]
  uint32_t tmpcr2 = 0;  
 800ed62:	2300      	movs	r3, #0
 800ed64:	613b      	str	r3, [r7, #16]

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800ed66:	687b      	ldr	r3, [r7, #4]
 800ed68:	6a1b      	ldr	r3, [r3, #32]
 800ed6a:	f023 0201 	bic.w	r2, r3, #1
 800ed6e:	687b      	ldr	r3, [r7, #4]
 800ed70:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800ed72:	687b      	ldr	r3, [r7, #4]
 800ed74:	6a1b      	ldr	r3, [r3, #32]
 800ed76:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 800ed78:	687b      	ldr	r3, [r7, #4]
 800ed7a:	685b      	ldr	r3, [r3, #4]
 800ed7c:	613b      	str	r3, [r7, #16]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800ed7e:	687b      	ldr	r3, [r7, #4]
 800ed80:	699b      	ldr	r3, [r3, #24]
 800ed82:	60fb      	str	r3, [r7, #12]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
 800ed84:	68fa      	ldr	r2, [r7, #12]
 800ed86:	4b29      	ldr	r3, [pc, #164]	; (800ee2c <TIM_OC1_SetConfig+0xdc>)
 800ed88:	4013      	ands	r3, r2
 800ed8a:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 800ed8c:	68fb      	ldr	r3, [r7, #12]
 800ed8e:	f023 0303 	bic.w	r3, r3, #3
 800ed92:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800ed94:	683b      	ldr	r3, [r7, #0]
 800ed96:	681b      	ldr	r3, [r3, #0]
 800ed98:	68fa      	ldr	r2, [r7, #12]
 800ed9a:	4313      	orrs	r3, r2
 800ed9c:	60fb      	str	r3, [r7, #12]
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 800ed9e:	697b      	ldr	r3, [r7, #20]
 800eda0:	f023 0302 	bic.w	r3, r3, #2
 800eda4:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 800eda6:	683b      	ldr	r3, [r7, #0]
 800eda8:	689b      	ldr	r3, [r3, #8]
 800edaa:	697a      	ldr	r2, [r7, #20]
 800edac:	4313      	orrs	r3, r2
 800edae:	617b      	str	r3, [r7, #20]

    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 800edb0:	687b      	ldr	r3, [r7, #4]
 800edb2:	4a1f      	ldr	r2, [pc, #124]	; (800ee30 <TIM_OC1_SetConfig+0xe0>)
 800edb4:	4293      	cmp	r3, r2
 800edb6:	d003      	beq.n	800edc0 <TIM_OC1_SetConfig+0x70>
 800edb8:	687b      	ldr	r3, [r7, #4]
 800edba:	4a1e      	ldr	r2, [pc, #120]	; (800ee34 <TIM_OC1_SetConfig+0xe4>)
 800edbc:	4293      	cmp	r3, r2
 800edbe:	d101      	bne.n	800edc4 <TIM_OC1_SetConfig+0x74>
 800edc0:	2301      	movs	r3, #1
 800edc2:	e000      	b.n	800edc6 <TIM_OC1_SetConfig+0x76>
 800edc4:	2300      	movs	r3, #0
 800edc6:	2b00      	cmp	r3, #0
 800edc8:	d01e      	beq.n	800ee08 <TIM_OC1_SetConfig+0xb8>
  {   
    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 800edca:	697b      	ldr	r3, [r7, #20]
 800edcc:	f023 0308 	bic.w	r3, r3, #8
 800edd0:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 800edd2:	683b      	ldr	r3, [r7, #0]
 800edd4:	68db      	ldr	r3, [r3, #12]
 800edd6:	697a      	ldr	r2, [r7, #20]
 800edd8:	4313      	orrs	r3, r2
 800edda:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 800eddc:	697b      	ldr	r3, [r7, #20]
 800edde:	f023 0304 	bic.w	r3, r3, #4
 800ede2:	617b      	str	r3, [r7, #20]
    
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
 800ede4:	693b      	ldr	r3, [r7, #16]
 800ede6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800edea:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 800edec:	693b      	ldr	r3, [r7, #16]
 800edee:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800edf2:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
 800edf4:	683b      	ldr	r3, [r7, #0]
 800edf6:	695b      	ldr	r3, [r3, #20]
 800edf8:	693a      	ldr	r2, [r7, #16]
 800edfa:	4313      	orrs	r3, r2
 800edfc:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 800edfe:	683b      	ldr	r3, [r7, #0]
 800ee00:	699b      	ldr	r3, [r3, #24]
 800ee02:	693a      	ldr	r2, [r7, #16]
 800ee04:	4313      	orrs	r3, r2
 800ee06:	613b      	str	r3, [r7, #16]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800ee08:	687b      	ldr	r3, [r7, #4]
 800ee0a:	693a      	ldr	r2, [r7, #16]
 800ee0c:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800ee0e:	687b      	ldr	r3, [r7, #4]
 800ee10:	68fa      	ldr	r2, [r7, #12]
 800ee12:	619a      	str	r2, [r3, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 800ee14:	683b      	ldr	r3, [r7, #0]
 800ee16:	685a      	ldr	r2, [r3, #4]
 800ee18:	687b      	ldr	r3, [r7, #4]
 800ee1a:	635a      	str	r2, [r3, #52]	; 0x34
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;  
 800ee1c:	687b      	ldr	r3, [r7, #4]
 800ee1e:	697a      	ldr	r2, [r7, #20]
 800ee20:	621a      	str	r2, [r3, #32]
} 
 800ee22:	371c      	adds	r7, #28
 800ee24:	46bd      	mov	sp, r7
 800ee26:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ee2a:	4770      	bx	lr
 800ee2c:	fffeff8f 	.word	0xfffeff8f
 800ee30:	40010000 	.word	0x40010000
 800ee34:	40010400 	.word	0x40010400

0800ee38 <TIM_OC2_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800ee38:	b480      	push	{r7}
 800ee3a:	b087      	sub	sp, #28
 800ee3c:	af00      	add	r7, sp, #0
 800ee3e:	6078      	str	r0, [r7, #4]
 800ee40:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0;
 800ee42:	2300      	movs	r3, #0
 800ee44:	60fb      	str	r3, [r7, #12]
  uint32_t tmpccer = 0;
 800ee46:	2300      	movs	r3, #0
 800ee48:	617b      	str	r3, [r7, #20]
  uint32_t tmpcr2 = 0;
 800ee4a:	2300      	movs	r3, #0
 800ee4c:	613b      	str	r3, [r7, #16]
   
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800ee4e:	687b      	ldr	r3, [r7, #4]
 800ee50:	6a1b      	ldr	r3, [r3, #32]
 800ee52:	f023 0210 	bic.w	r2, r3, #16
 800ee56:	687b      	ldr	r3, [r7, #4]
 800ee58:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
 800ee5a:	687b      	ldr	r3, [r7, #4]
 800ee5c:	6a1b      	ldr	r3, [r3, #32]
 800ee5e:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 800ee60:	687b      	ldr	r3, [r7, #4]
 800ee62:	685b      	ldr	r3, [r3, #4]
 800ee64:	613b      	str	r3, [r7, #16]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800ee66:	687b      	ldr	r3, [r7, #4]
 800ee68:	699b      	ldr	r3, [r3, #24]
 800ee6a:	60fb      	str	r3, [r7, #12]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
 800ee6c:	68fa      	ldr	r2, [r7, #12]
 800ee6e:	4b2c      	ldr	r3, [pc, #176]	; (800ef20 <TIM_OC2_SetConfig+0xe8>)
 800ee70:	4013      	ands	r3, r2
 800ee72:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 800ee74:	68fb      	ldr	r3, [r7, #12]
 800ee76:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800ee7a:	60fb      	str	r3, [r7, #12]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 800ee7c:	683b      	ldr	r3, [r7, #0]
 800ee7e:	681b      	ldr	r3, [r3, #0]
 800ee80:	021b      	lsls	r3, r3, #8
 800ee82:	68fa      	ldr	r2, [r7, #12]
 800ee84:	4313      	orrs	r3, r2
 800ee86:	60fb      	str	r3, [r7, #12]
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
 800ee88:	697b      	ldr	r3, [r7, #20]
 800ee8a:	f023 0320 	bic.w	r3, r3, #32
 800ee8e:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4);
 800ee90:	683b      	ldr	r3, [r7, #0]
 800ee92:	689b      	ldr	r3, [r3, #8]
 800ee94:	011b      	lsls	r3, r3, #4
 800ee96:	697a      	ldr	r2, [r7, #20]
 800ee98:	4313      	orrs	r3, r2
 800ee9a:	617b      	str	r3, [r7, #20]
    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 800ee9c:	687b      	ldr	r3, [r7, #4]
 800ee9e:	4a21      	ldr	r2, [pc, #132]	; (800ef24 <TIM_OC2_SetConfig+0xec>)
 800eea0:	4293      	cmp	r3, r2
 800eea2:	d003      	beq.n	800eeac <TIM_OC2_SetConfig+0x74>
 800eea4:	687b      	ldr	r3, [r7, #4]
 800eea6:	4a20      	ldr	r2, [pc, #128]	; (800ef28 <TIM_OC2_SetConfig+0xf0>)
 800eea8:	4293      	cmp	r3, r2
 800eeaa:	d101      	bne.n	800eeb0 <TIM_OC2_SetConfig+0x78>
 800eeac:	2301      	movs	r3, #1
 800eeae:	e000      	b.n	800eeb2 <TIM_OC2_SetConfig+0x7a>
 800eeb0:	2300      	movs	r3, #0
 800eeb2:	2b00      	cmp	r3, #0
 800eeb4:	d021      	beq.n	800eefa <TIM_OC2_SetConfig+0xc2>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
 800eeb6:	697b      	ldr	r3, [r7, #20]
 800eeb8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800eebc:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4);
 800eebe:	683b      	ldr	r3, [r7, #0]
 800eec0:	68db      	ldr	r3, [r3, #12]
 800eec2:	011b      	lsls	r3, r3, #4
 800eec4:	697a      	ldr	r2, [r7, #20]
 800eec6:	4313      	orrs	r3, r2
 800eec8:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC2NE;
 800eeca:	697b      	ldr	r3, [r7, #20]
 800eecc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800eed0:	617b      	str	r3, [r7, #20]
    
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
 800eed2:	693b      	ldr	r3, [r7, #16]
 800eed4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800eed8:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 800eeda:	693b      	ldr	r3, [r7, #16]
 800eedc:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800eee0:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2);
 800eee2:	683b      	ldr	r3, [r7, #0]
 800eee4:	695b      	ldr	r3, [r3, #20]
 800eee6:	009b      	lsls	r3, r3, #2
 800eee8:	693a      	ldr	r2, [r7, #16]
 800eeea:	4313      	orrs	r3, r2
 800eeec:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2);
 800eeee:	683b      	ldr	r3, [r7, #0]
 800eef0:	699b      	ldr	r3, [r3, #24]
 800eef2:	009b      	lsls	r3, r3, #2
 800eef4:	693a      	ldr	r2, [r7, #16]
 800eef6:	4313      	orrs	r3, r2
 800eef8:	613b      	str	r3, [r7, #16]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800eefa:	687b      	ldr	r3, [r7, #4]
 800eefc:	693a      	ldr	r2, [r7, #16]
 800eefe:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800ef00:	687b      	ldr	r3, [r7, #4]
 800ef02:	68fa      	ldr	r2, [r7, #12]
 800ef04:	619a      	str	r2, [r3, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 800ef06:	683b      	ldr	r3, [r7, #0]
 800ef08:	685a      	ldr	r2, [r3, #4]
 800ef0a:	687b      	ldr	r3, [r7, #4]
 800ef0c:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800ef0e:	687b      	ldr	r3, [r7, #4]
 800ef10:	697a      	ldr	r2, [r7, #20]
 800ef12:	621a      	str	r2, [r3, #32]
}
 800ef14:	371c      	adds	r7, #28
 800ef16:	46bd      	mov	sp, r7
 800ef18:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ef1c:	4770      	bx	lr
 800ef1e:	bf00      	nop
 800ef20:	feff8fff 	.word	0xfeff8fff
 800ef24:	40010000 	.word	0x40010000
 800ef28:	40010400 	.word	0x40010400

0800ef2c <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800ef2c:	b480      	push	{r7}
 800ef2e:	b087      	sub	sp, #28
 800ef30:	af00      	add	r7, sp, #0
 800ef32:	6078      	str	r0, [r7, #4]
 800ef34:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0;
 800ef36:	2300      	movs	r3, #0
 800ef38:	60fb      	str	r3, [r7, #12]
  uint32_t tmpccer = 0;
 800ef3a:	2300      	movs	r3, #0
 800ef3c:	617b      	str	r3, [r7, #20]
  uint32_t tmpcr2 = 0;   
 800ef3e:	2300      	movs	r3, #0
 800ef40:	613b      	str	r3, [r7, #16]

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 800ef42:	687b      	ldr	r3, [r7, #4]
 800ef44:	6a1b      	ldr	r3, [r3, #32]
 800ef46:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 800ef4a:	687b      	ldr	r3, [r7, #4]
 800ef4c:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800ef4e:	687b      	ldr	r3, [r7, #4]
 800ef50:	6a1b      	ldr	r3, [r3, #32]
 800ef52:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 800ef54:	687b      	ldr	r3, [r7, #4]
 800ef56:	685b      	ldr	r3, [r3, #4]
 800ef58:	613b      	str	r3, [r7, #16]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800ef5a:	687b      	ldr	r3, [r7, #4]
 800ef5c:	69db      	ldr	r3, [r3, #28]
 800ef5e:	60fb      	str	r3, [r7, #12]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
 800ef60:	68fa      	ldr	r2, [r7, #12]
 800ef62:	4b2b      	ldr	r3, [pc, #172]	; (800f010 <TIM_OC3_SetConfig+0xe4>)
 800ef64:	4013      	ands	r3, r2
 800ef66:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC3S;  
 800ef68:	68fb      	ldr	r3, [r7, #12]
 800ef6a:	f023 0303 	bic.w	r3, r3, #3
 800ef6e:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800ef70:	683b      	ldr	r3, [r7, #0]
 800ef72:	681b      	ldr	r3, [r3, #0]
 800ef74:	68fa      	ldr	r2, [r7, #12]
 800ef76:	4313      	orrs	r3, r2
 800ef78:	60fb      	str	r3, [r7, #12]
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 800ef7a:	697b      	ldr	r3, [r7, #20]
 800ef7c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800ef80:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8);
 800ef82:	683b      	ldr	r3, [r7, #0]
 800ef84:	689b      	ldr	r3, [r3, #8]
 800ef86:	021b      	lsls	r3, r3, #8
 800ef88:	697a      	ldr	r2, [r7, #20]
 800ef8a:	4313      	orrs	r3, r2
 800ef8c:	617b      	str	r3, [r7, #20]
    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 800ef8e:	687b      	ldr	r3, [r7, #4]
 800ef90:	4a20      	ldr	r2, [pc, #128]	; (800f014 <TIM_OC3_SetConfig+0xe8>)
 800ef92:	4293      	cmp	r3, r2
 800ef94:	d003      	beq.n	800ef9e <TIM_OC3_SetConfig+0x72>
 800ef96:	687b      	ldr	r3, [r7, #4]
 800ef98:	4a1f      	ldr	r2, [pc, #124]	; (800f018 <TIM_OC3_SetConfig+0xec>)
 800ef9a:	4293      	cmp	r3, r2
 800ef9c:	d101      	bne.n	800efa2 <TIM_OC3_SetConfig+0x76>
 800ef9e:	2301      	movs	r3, #1
 800efa0:	e000      	b.n	800efa4 <TIM_OC3_SetConfig+0x78>
 800efa2:	2300      	movs	r3, #0
 800efa4:	2b00      	cmp	r3, #0
 800efa6:	d021      	beq.n	800efec <TIM_OC3_SetConfig+0xc0>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 800efa8:	697b      	ldr	r3, [r7, #20]
 800efaa:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800efae:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8);
 800efb0:	683b      	ldr	r3, [r7, #0]
 800efb2:	68db      	ldr	r3, [r3, #12]
 800efb4:	021b      	lsls	r3, r3, #8
 800efb6:	697a      	ldr	r2, [r7, #20]
 800efb8:	4313      	orrs	r3, r2
 800efba:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 800efbc:	697b      	ldr	r3, [r7, #20]
 800efbe:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800efc2:	617b      	str	r3, [r7, #20]
    
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
 800efc4:	693b      	ldr	r3, [r7, #16]
 800efc6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800efca:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 800efcc:	693b      	ldr	r3, [r7, #16]
 800efce:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800efd2:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4);
 800efd4:	683b      	ldr	r3, [r7, #0]
 800efd6:	695b      	ldr	r3, [r3, #20]
 800efd8:	011b      	lsls	r3, r3, #4
 800efda:	693a      	ldr	r2, [r7, #16]
 800efdc:	4313      	orrs	r3, r2
 800efde:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4);
 800efe0:	683b      	ldr	r3, [r7, #0]
 800efe2:	699b      	ldr	r3, [r3, #24]
 800efe4:	011b      	lsls	r3, r3, #4
 800efe6:	693a      	ldr	r2, [r7, #16]
 800efe8:	4313      	orrs	r3, r2
 800efea:	613b      	str	r3, [r7, #16]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800efec:	687b      	ldr	r3, [r7, #4]
 800efee:	693a      	ldr	r2, [r7, #16]
 800eff0:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 800eff2:	687b      	ldr	r3, [r7, #4]
 800eff4:	68fa      	ldr	r2, [r7, #12]
 800eff6:	61da      	str	r2, [r3, #28]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 800eff8:	683b      	ldr	r3, [r7, #0]
 800effa:	685a      	ldr	r2, [r3, #4]
 800effc:	687b      	ldr	r3, [r7, #4]
 800effe:	63da      	str	r2, [r3, #60]	; 0x3c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800f000:	687b      	ldr	r3, [r7, #4]
 800f002:	697a      	ldr	r2, [r7, #20]
 800f004:	621a      	str	r2, [r3, #32]
}
 800f006:	371c      	adds	r7, #28
 800f008:	46bd      	mov	sp, r7
 800f00a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f00e:	4770      	bx	lr
 800f010:	fffeff8f 	.word	0xfffeff8f
 800f014:	40010000 	.word	0x40010000
 800f018:	40010400 	.word	0x40010400

0800f01c <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800f01c:	b480      	push	{r7}
 800f01e:	b087      	sub	sp, #28
 800f020:	af00      	add	r7, sp, #0
 800f022:	6078      	str	r0, [r7, #4]
 800f024:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0;
 800f026:	2300      	movs	r3, #0
 800f028:	613b      	str	r3, [r7, #16]
  uint32_t tmpccer = 0;
 800f02a:	2300      	movs	r3, #0
 800f02c:	60fb      	str	r3, [r7, #12]
  uint32_t tmpcr2 = 0;
 800f02e:	2300      	movs	r3, #0
 800f030:	617b      	str	r3, [r7, #20]

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 800f032:	687b      	ldr	r3, [r7, #4]
 800f034:	6a1b      	ldr	r3, [r3, #32]
 800f036:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 800f03a:	687b      	ldr	r3, [r7, #4]
 800f03c:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800f03e:	687b      	ldr	r3, [r7, #4]
 800f040:	6a1b      	ldr	r3, [r3, #32]
 800f042:	60fb      	str	r3, [r7, #12]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 800f044:	687b      	ldr	r3, [r7, #4]
 800f046:	685b      	ldr	r3, [r3, #4]
 800f048:	617b      	str	r3, [r7, #20]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800f04a:	687b      	ldr	r3, [r7, #4]
 800f04c:	69db      	ldr	r3, [r3, #28]
 800f04e:	613b      	str	r3, [r7, #16]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
 800f050:	693a      	ldr	r2, [r7, #16]
 800f052:	4b20      	ldr	r3, [pc, #128]	; (800f0d4 <TIM_OC4_SetConfig+0xb8>)
 800f054:	4013      	ands	r3, r2
 800f056:	613b      	str	r3, [r7, #16]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 800f058:	693b      	ldr	r3, [r7, #16]
 800f05a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800f05e:	613b      	str	r3, [r7, #16]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 800f060:	683b      	ldr	r3, [r7, #0]
 800f062:	681b      	ldr	r3, [r3, #0]
 800f064:	021b      	lsls	r3, r3, #8
 800f066:	693a      	ldr	r2, [r7, #16]
 800f068:	4313      	orrs	r3, r2
 800f06a:	613b      	str	r3, [r7, #16]
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 800f06c:	68fb      	ldr	r3, [r7, #12]
 800f06e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800f072:	60fb      	str	r3, [r7, #12]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12);
 800f074:	683b      	ldr	r3, [r7, #0]
 800f076:	689b      	ldr	r3, [r3, #8]
 800f078:	031b      	lsls	r3, r3, #12
 800f07a:	68fa      	ldr	r2, [r7, #12]
 800f07c:	4313      	orrs	r3, r2
 800f07e:	60fb      	str	r3, [r7, #12]
   
  /*if((TIMx == TIM1) || (TIMx == TIM8))*/
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 800f080:	687b      	ldr	r3, [r7, #4]
 800f082:	4a15      	ldr	r2, [pc, #84]	; (800f0d8 <TIM_OC4_SetConfig+0xbc>)
 800f084:	4293      	cmp	r3, r2
 800f086:	d003      	beq.n	800f090 <TIM_OC4_SetConfig+0x74>
 800f088:	687b      	ldr	r3, [r7, #4]
 800f08a:	4a14      	ldr	r2, [pc, #80]	; (800f0dc <TIM_OC4_SetConfig+0xc0>)
 800f08c:	4293      	cmp	r3, r2
 800f08e:	d101      	bne.n	800f094 <TIM_OC4_SetConfig+0x78>
 800f090:	2301      	movs	r3, #1
 800f092:	e000      	b.n	800f096 <TIM_OC4_SetConfig+0x7a>
 800f094:	2300      	movs	r3, #0
 800f096:	2b00      	cmp	r3, #0
 800f098:	d009      	beq.n	800f0ae <TIM_OC4_SetConfig+0x92>
  {
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 800f09a:	697b      	ldr	r3, [r7, #20]
 800f09c:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800f0a0:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6);
 800f0a2:	683b      	ldr	r3, [r7, #0]
 800f0a4:	695b      	ldr	r3, [r3, #20]
 800f0a6:	019b      	lsls	r3, r3, #6
 800f0a8:	697a      	ldr	r2, [r7, #20]
 800f0aa:	4313      	orrs	r3, r2
 800f0ac:	617b      	str	r3, [r7, #20]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800f0ae:	687b      	ldr	r3, [r7, #4]
 800f0b0:	697a      	ldr	r2, [r7, #20]
 800f0b2:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
 800f0b4:	687b      	ldr	r3, [r7, #4]
 800f0b6:	693a      	ldr	r2, [r7, #16]
 800f0b8:	61da      	str	r2, [r3, #28]
    
  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 800f0ba:	683b      	ldr	r3, [r7, #0]
 800f0bc:	685a      	ldr	r2, [r3, #4]
 800f0be:	687b      	ldr	r3, [r7, #4]
 800f0c0:	641a      	str	r2, [r3, #64]	; 0x40
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800f0c2:	687b      	ldr	r3, [r7, #4]
 800f0c4:	68fa      	ldr	r2, [r7, #12]
 800f0c6:	621a      	str	r2, [r3, #32]
}
 800f0c8:	371c      	adds	r7, #28
 800f0ca:	46bd      	mov	sp, r7
 800f0cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f0d0:	4770      	bx	lr
 800f0d2:	bf00      	nop
 800f0d4:	feff8fff 	.word	0xfeff8fff
 800f0d8:	40010000 	.word	0x40010000
 800f0dc:	40010400 	.word	0x40010400

0800f0e0 <TIM_CCxChannelCmd>:
  * @param  ChannelState: specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_Disable. 
  * @retval None
  */
void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
{
 800f0e0:	b480      	push	{r7}
 800f0e2:	b087      	sub	sp, #28
 800f0e4:	af00      	add	r7, sp, #0
 800f0e6:	60f8      	str	r0, [r7, #12]
 800f0e8:	60b9      	str	r1, [r7, #8]
 800f0ea:	607a      	str	r2, [r7, #4]
  uint32_t tmp = 0;
 800f0ec:	2300      	movs	r3, #0
 800f0ee:	617b      	str	r3, [r7, #20]

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx)); 
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << Channel;
 800f0f0:	68bb      	ldr	r3, [r7, #8]
 800f0f2:	2201      	movs	r2, #1
 800f0f4:	fa02 f303 	lsl.w	r3, r2, r3
 800f0f8:	617b      	str	r3, [r7, #20]

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 800f0fa:	68fb      	ldr	r3, [r7, #12]
 800f0fc:	6a1a      	ldr	r2, [r3, #32]
 800f0fe:	697b      	ldr	r3, [r7, #20]
 800f100:	43db      	mvns	r3, r3
 800f102:	401a      	ands	r2, r3
 800f104:	68fb      	ldr	r3, [r7, #12]
 800f106:	621a      	str	r2, [r3, #32]

  /* Set or reset the CCxE Bit */ 
  TIMx->CCER |= (uint32_t)(ChannelState << Channel);
 800f108:	68fb      	ldr	r3, [r7, #12]
 800f10a:	6a1a      	ldr	r2, [r3, #32]
 800f10c:	68bb      	ldr	r3, [r7, #8]
 800f10e:	6879      	ldr	r1, [r7, #4]
 800f110:	fa01 f303 	lsl.w	r3, r1, r3
 800f114:	431a      	orrs	r2, r3
 800f116:	68fb      	ldr	r3, [r7, #12]
 800f118:	621a      	str	r2, [r3, #32]
}
 800f11a:	371c      	adds	r7, #28
 800f11c:	46bd      	mov	sp, r7
 800f11e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f122:	4770      	bx	lr

0800f124 <HAL_TIM_PWM_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, 
                                            TIM_OC_InitTypeDef* sConfig, 
                                            uint32_t Channel)
{
 800f124:	b580      	push	{r7, lr}
 800f126:	b084      	sub	sp, #16
 800f128:	af00      	add	r7, sp, #0
 800f12a:	60f8      	str	r0, [r7, #12]
 800f12c:	60b9      	str	r1, [r7, #8]
 800f12e:	607a      	str	r2, [r7, #4]
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
  assert_param(IS_TIM_OCNIDLE_STATE(sConfig->OCNIdleState));
  assert_param(IS_TIM_OCIDLE_STATE(sConfig->OCIdleState));
  
  /* Check input state */
  __HAL_LOCK(htim);
 800f130:	68fb      	ldr	r3, [r7, #12]
 800f132:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 800f136:	2b01      	cmp	r3, #1
 800f138:	d101      	bne.n	800f13e <HAL_TIM_PWM_ConfigChannel+0x1a>
 800f13a:	2302      	movs	r3, #2
 800f13c:	e105      	b.n	800f34a <HAL_TIM_PWM_ConfigChannel+0x226>
 800f13e:	68fb      	ldr	r3, [r7, #12]
 800f140:	2201      	movs	r2, #1
 800f142:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  htim->State = HAL_TIM_STATE_BUSY;
 800f146:	68fb      	ldr	r3, [r7, #12]
 800f148:	2202      	movs	r2, #2
 800f14a:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    
  switch (Channel)
 800f14e:	687b      	ldr	r3, [r7, #4]
 800f150:	2b14      	cmp	r3, #20
 800f152:	f200 80f0 	bhi.w	800f336 <HAL_TIM_PWM_ConfigChannel+0x212>
 800f156:	a201      	add	r2, pc, #4	; (adr r2, 800f15c <HAL_TIM_PWM_ConfigChannel+0x38>)
 800f158:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800f15c:	0800f1b1 	.word	0x0800f1b1
 800f160:	0800f337 	.word	0x0800f337
 800f164:	0800f337 	.word	0x0800f337
 800f168:	0800f337 	.word	0x0800f337
 800f16c:	0800f1f1 	.word	0x0800f1f1
 800f170:	0800f337 	.word	0x0800f337
 800f174:	0800f337 	.word	0x0800f337
 800f178:	0800f337 	.word	0x0800f337
 800f17c:	0800f233 	.word	0x0800f233
 800f180:	0800f337 	.word	0x0800f337
 800f184:	0800f337 	.word	0x0800f337
 800f188:	0800f337 	.word	0x0800f337
 800f18c:	0800f273 	.word	0x0800f273
 800f190:	0800f337 	.word	0x0800f337
 800f194:	0800f337 	.word	0x0800f337
 800f198:	0800f337 	.word	0x0800f337
 800f19c:	0800f2b5 	.word	0x0800f2b5
 800f1a0:	0800f337 	.word	0x0800f337
 800f1a4:	0800f337 	.word	0x0800f337
 800f1a8:	0800f337 	.word	0x0800f337
 800f1ac:	0800f2f5 	.word	0x0800f2f5
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance)); 
      
      /* Configure the Channel 1 in PWM mode */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 800f1b0:	68fb      	ldr	r3, [r7, #12]
 800f1b2:	681b      	ldr	r3, [r3, #0]
 800f1b4:	4618      	mov	r0, r3
 800f1b6:	68b9      	ldr	r1, [r7, #8]
 800f1b8:	f7ff fdca 	bl	800ed50 <TIM_OC1_SetConfig>
      
      /* Set the Preload enable bit for channel1 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 800f1bc:	68fb      	ldr	r3, [r7, #12]
 800f1be:	681b      	ldr	r3, [r3, #0]
 800f1c0:	68fa      	ldr	r2, [r7, #12]
 800f1c2:	6812      	ldr	r2, [r2, #0]
 800f1c4:	6992      	ldr	r2, [r2, #24]
 800f1c6:	f042 0208 	orr.w	r2, r2, #8
 800f1ca:	619a      	str	r2, [r3, #24]
      
      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 800f1cc:	68fb      	ldr	r3, [r7, #12]
 800f1ce:	681b      	ldr	r3, [r3, #0]
 800f1d0:	68fa      	ldr	r2, [r7, #12]
 800f1d2:	6812      	ldr	r2, [r2, #0]
 800f1d4:	6992      	ldr	r2, [r2, #24]
 800f1d6:	f022 0204 	bic.w	r2, r2, #4
 800f1da:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 800f1dc:	68fb      	ldr	r3, [r7, #12]
 800f1de:	681b      	ldr	r3, [r3, #0]
 800f1e0:	68fa      	ldr	r2, [r7, #12]
 800f1e2:	6812      	ldr	r2, [r2, #0]
 800f1e4:	6991      	ldr	r1, [r2, #24]
 800f1e6:	68ba      	ldr	r2, [r7, #8]
 800f1e8:	6912      	ldr	r2, [r2, #16]
 800f1ea:	430a      	orrs	r2, r1
 800f1ec:	619a      	str	r2, [r3, #24]
    }
    break;
 800f1ee:	e0a3      	b.n	800f338 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
      
      /* Configure the Channel 2 in PWM mode */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 800f1f0:	68fb      	ldr	r3, [r7, #12]
 800f1f2:	681b      	ldr	r3, [r3, #0]
 800f1f4:	4618      	mov	r0, r3
 800f1f6:	68b9      	ldr	r1, [r7, #8]
 800f1f8:	f7ff fe1e 	bl	800ee38 <TIM_OC2_SetConfig>
      
      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 800f1fc:	68fb      	ldr	r3, [r7, #12]
 800f1fe:	681b      	ldr	r3, [r3, #0]
 800f200:	68fa      	ldr	r2, [r7, #12]
 800f202:	6812      	ldr	r2, [r2, #0]
 800f204:	6992      	ldr	r2, [r2, #24]
 800f206:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800f20a:	619a      	str	r2, [r3, #24]
      
      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 800f20c:	68fb      	ldr	r3, [r7, #12]
 800f20e:	681b      	ldr	r3, [r3, #0]
 800f210:	68fa      	ldr	r2, [r7, #12]
 800f212:	6812      	ldr	r2, [r2, #0]
 800f214:	6992      	ldr	r2, [r2, #24]
 800f216:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800f21a:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
 800f21c:	68fb      	ldr	r3, [r7, #12]
 800f21e:	681b      	ldr	r3, [r3, #0]
 800f220:	68fa      	ldr	r2, [r7, #12]
 800f222:	6812      	ldr	r2, [r2, #0]
 800f224:	6991      	ldr	r1, [r2, #24]
 800f226:	68ba      	ldr	r2, [r7, #8]
 800f228:	6912      	ldr	r2, [r2, #16]
 800f22a:	0212      	lsls	r2, r2, #8
 800f22c:	430a      	orrs	r2, r1
 800f22e:	619a      	str	r2, [r3, #24]
    }
    break;
 800f230:	e082      	b.n	800f338 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance)); 
      
      /* Configure the Channel 3 in PWM mode */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 800f232:	68fb      	ldr	r3, [r7, #12]
 800f234:	681b      	ldr	r3, [r3, #0]
 800f236:	4618      	mov	r0, r3
 800f238:	68b9      	ldr	r1, [r7, #8]
 800f23a:	f7ff fe77 	bl	800ef2c <TIM_OC3_SetConfig>
      
      /* Set the Preload enable bit for channel3 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 800f23e:	68fb      	ldr	r3, [r7, #12]
 800f240:	681b      	ldr	r3, [r3, #0]
 800f242:	68fa      	ldr	r2, [r7, #12]
 800f244:	6812      	ldr	r2, [r2, #0]
 800f246:	69d2      	ldr	r2, [r2, #28]
 800f248:	f042 0208 	orr.w	r2, r2, #8
 800f24c:	61da      	str	r2, [r3, #28]
      
     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 800f24e:	68fb      	ldr	r3, [r7, #12]
 800f250:	681b      	ldr	r3, [r3, #0]
 800f252:	68fa      	ldr	r2, [r7, #12]
 800f254:	6812      	ldr	r2, [r2, #0]
 800f256:	69d2      	ldr	r2, [r2, #28]
 800f258:	f022 0204 	bic.w	r2, r2, #4
 800f25c:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;  
 800f25e:	68fb      	ldr	r3, [r7, #12]
 800f260:	681b      	ldr	r3, [r3, #0]
 800f262:	68fa      	ldr	r2, [r7, #12]
 800f264:	6812      	ldr	r2, [r2, #0]
 800f266:	69d1      	ldr	r1, [r2, #28]
 800f268:	68ba      	ldr	r2, [r7, #8]
 800f26a:	6912      	ldr	r2, [r2, #16]
 800f26c:	430a      	orrs	r2, r1
 800f26e:	61da      	str	r2, [r3, #28]
    }
    break;
 800f270:	e062      	b.n	800f338 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance)); 
      
      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 800f272:	68fb      	ldr	r3, [r7, #12]
 800f274:	681b      	ldr	r3, [r3, #0]
 800f276:	4618      	mov	r0, r3
 800f278:	68b9      	ldr	r1, [r7, #8]
 800f27a:	f7ff fecf 	bl	800f01c <TIM_OC4_SetConfig>
      
      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 800f27e:	68fb      	ldr	r3, [r7, #12]
 800f280:	681b      	ldr	r3, [r3, #0]
 800f282:	68fa      	ldr	r2, [r7, #12]
 800f284:	6812      	ldr	r2, [r2, #0]
 800f286:	69d2      	ldr	r2, [r2, #28]
 800f288:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800f28c:	61da      	str	r2, [r3, #28]
      
     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 800f28e:	68fb      	ldr	r3, [r7, #12]
 800f290:	681b      	ldr	r3, [r3, #0]
 800f292:	68fa      	ldr	r2, [r7, #12]
 800f294:	6812      	ldr	r2, [r2, #0]
 800f296:	69d2      	ldr	r2, [r2, #28]
 800f298:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800f29c:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  
 800f29e:	68fb      	ldr	r3, [r7, #12]
 800f2a0:	681b      	ldr	r3, [r3, #0]
 800f2a2:	68fa      	ldr	r2, [r7, #12]
 800f2a4:	6812      	ldr	r2, [r2, #0]
 800f2a6:	69d1      	ldr	r1, [r2, #28]
 800f2a8:	68ba      	ldr	r2, [r7, #8]
 800f2aa:	6912      	ldr	r2, [r2, #16]
 800f2ac:	0212      	lsls	r2, r2, #8
 800f2ae:	430a      	orrs	r2, r1
 800f2b0:	61da      	str	r2, [r3, #28]
    }
    break;
 800f2b2:	e041      	b.n	800f338 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
       /* Check the parameters */
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance)); 
      
     /* Configure the Channel 5 in PWM mode */
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 800f2b4:	68fb      	ldr	r3, [r7, #12]
 800f2b6:	681b      	ldr	r3, [r3, #0]
 800f2b8:	4618      	mov	r0, r3
 800f2ba:	68b9      	ldr	r1, [r7, #8]
 800f2bc:	f000 f90a 	bl	800f4d4 <TIM_OC5_SetConfig>
      
      /* Set the Preload enable bit for channel5*/
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 800f2c0:	68fb      	ldr	r3, [r7, #12]
 800f2c2:	681b      	ldr	r3, [r3, #0]
 800f2c4:	68fa      	ldr	r2, [r7, #12]
 800f2c6:	6812      	ldr	r2, [r2, #0]
 800f2c8:	6d52      	ldr	r2, [r2, #84]	; 0x54
 800f2ca:	f042 0208 	orr.w	r2, r2, #8
 800f2ce:	655a      	str	r2, [r3, #84]	; 0x54
      
     /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 800f2d0:	68fb      	ldr	r3, [r7, #12]
 800f2d2:	681b      	ldr	r3, [r3, #0]
 800f2d4:	68fa      	ldr	r2, [r7, #12]
 800f2d6:	6812      	ldr	r2, [r2, #0]
 800f2d8:	6d52      	ldr	r2, [r2, #84]	; 0x54
 800f2da:	f022 0204 	bic.w	r2, r2, #4
 800f2de:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;  
 800f2e0:	68fb      	ldr	r3, [r7, #12]
 800f2e2:	681b      	ldr	r3, [r3, #0]
 800f2e4:	68fa      	ldr	r2, [r7, #12]
 800f2e6:	6812      	ldr	r2, [r2, #0]
 800f2e8:	6d51      	ldr	r1, [r2, #84]	; 0x54
 800f2ea:	68ba      	ldr	r2, [r7, #8]
 800f2ec:	6912      	ldr	r2, [r2, #16]
 800f2ee:	430a      	orrs	r2, r1
 800f2f0:	655a      	str	r2, [r3, #84]	; 0x54
    }
    break;
 800f2f2:	e021      	b.n	800f338 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
       /* Check the parameters */
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance)); 
      
     /* Configure the Channel 5 in PWM mode */
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 800f2f4:	68fb      	ldr	r3, [r7, #12]
 800f2f6:	681b      	ldr	r3, [r3, #0]
 800f2f8:	4618      	mov	r0, r3
 800f2fa:	68b9      	ldr	r1, [r7, #8]
 800f2fc:	f000 f942 	bl	800f584 <TIM_OC6_SetConfig>
      
      /* Set the Preload enable bit for channel6 */
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 800f300:	68fb      	ldr	r3, [r7, #12]
 800f302:	681b      	ldr	r3, [r3, #0]
 800f304:	68fa      	ldr	r2, [r7, #12]
 800f306:	6812      	ldr	r2, [r2, #0]
 800f308:	6d52      	ldr	r2, [r2, #84]	; 0x54
 800f30a:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800f30e:	655a      	str	r2, [r3, #84]	; 0x54
      
     /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 800f310:	68fb      	ldr	r3, [r7, #12]
 800f312:	681b      	ldr	r3, [r3, #0]
 800f314:	68fa      	ldr	r2, [r7, #12]
 800f316:	6812      	ldr	r2, [r2, #0]
 800f318:	6d52      	ldr	r2, [r2, #84]	; 0x54
 800f31a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800f31e:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8;  
 800f320:	68fb      	ldr	r3, [r7, #12]
 800f322:	681b      	ldr	r3, [r3, #0]
 800f324:	68fa      	ldr	r2, [r7, #12]
 800f326:	6812      	ldr	r2, [r2, #0]
 800f328:	6d51      	ldr	r1, [r2, #84]	; 0x54
 800f32a:	68ba      	ldr	r2, [r7, #8]
 800f32c:	6912      	ldr	r2, [r2, #16]
 800f32e:	0212      	lsls	r2, r2, #8
 800f330:	430a      	orrs	r2, r1
 800f332:	655a      	str	r2, [r3, #84]	; 0x54
    }
    break;
 800f334:	e000      	b.n	800f338 <HAL_TIM_PWM_ConfigChannel+0x214>
    
    default:
    break;    
 800f336:	bf00      	nop
  }
  
  htim->State = HAL_TIM_STATE_READY;
 800f338:	68fb      	ldr	r3, [r7, #12]
 800f33a:	2201      	movs	r2, #1
 800f33c:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    
  __HAL_UNLOCK(htim);
 800f340:	68fb      	ldr	r3, [r7, #12]
 800f342:	2200      	movs	r2, #0
 800f344:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  return HAL_OK;
 800f348:	2300      	movs	r3, #0
}
 800f34a:	4618      	mov	r0, r3
 800f34c:	3710      	adds	r7, #16
 800f34e:	46bd      	mov	sp, r7
 800f350:	bd80      	pop	{r7, pc}
 800f352:	bf00      	nop

0800f354 <HAL_TIMEx_MasterConfigSynchronization>:
  *         contains the selected trigger output (TRGO) and the Master/Slave 
  *         mode. 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef * sMasterConfig)
{
 800f354:	b480      	push	{r7}
 800f356:	b085      	sub	sp, #20
 800f358:	af00      	add	r7, sp, #0
 800f35a:	6078      	str	r0, [r7, #4]
 800f35c:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
  
  /* Check input state */
  __HAL_LOCK(htim);
 800f35e:	687b      	ldr	r3, [r7, #4]
 800f360:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 800f364:	2b01      	cmp	r3, #1
 800f366:	d101      	bne.n	800f36c <HAL_TIMEx_MasterConfigSynchronization+0x18>
 800f368:	2302      	movs	r3, #2
 800f36a:	e03d      	b.n	800f3e8 <HAL_TIMEx_MasterConfigSynchronization+0x94>
 800f36c:	687b      	ldr	r3, [r7, #4]
 800f36e:	2201      	movs	r2, #1
 800f370:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

 /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 800f374:	687b      	ldr	r3, [r7, #4]
 800f376:	681b      	ldr	r3, [r3, #0]
 800f378:	685b      	ldr	r3, [r3, #4]
 800f37a:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 800f37c:	687b      	ldr	r3, [r7, #4]
 800f37e:	681b      	ldr	r3, [r3, #0]
 800f380:	689b      	ldr	r3, [r3, #8]
 800f382:	60bb      	str	r3, [r7, #8]

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 800f384:	687b      	ldr	r3, [r7, #4]
 800f386:	681b      	ldr	r3, [r3, #0]
 800f388:	4a1a      	ldr	r2, [pc, #104]	; (800f3f4 <HAL_TIMEx_MasterConfigSynchronization+0xa0>)
 800f38a:	4293      	cmp	r3, r2
 800f38c:	d004      	beq.n	800f398 <HAL_TIMEx_MasterConfigSynchronization+0x44>
 800f38e:	687b      	ldr	r3, [r7, #4]
 800f390:	681b      	ldr	r3, [r3, #0]
 800f392:	4a19      	ldr	r2, [pc, #100]	; (800f3f8 <HAL_TIMEx_MasterConfigSynchronization+0xa4>)
 800f394:	4293      	cmp	r3, r2
 800f396:	d108      	bne.n	800f3aa <HAL_TIMEx_MasterConfigSynchronization+0x56>
  {
    /* Check the parameters */
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));
    
    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
 800f398:	68fb      	ldr	r3, [r7, #12]
 800f39a:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 800f39e:	60fb      	str	r3, [r7, #12]
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 800f3a0:	683b      	ldr	r3, [r7, #0]
 800f3a2:	685b      	ldr	r3, [r3, #4]
 800f3a4:	68fa      	ldr	r2, [r7, #12]
 800f3a6:	4313      	orrs	r3, r2
 800f3a8:	60fb      	str	r3, [r7, #12]
  }
  
  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 800f3aa:	68fb      	ldr	r3, [r7, #12]
 800f3ac:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f3b0:	60fb      	str	r3, [r7, #12]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800f3b2:	683b      	ldr	r3, [r7, #0]
 800f3b4:	681b      	ldr	r3, [r3, #0]
 800f3b6:	68fa      	ldr	r2, [r7, #12]
 800f3b8:	4313      	orrs	r3, r2
 800f3ba:	60fb      	str	r3, [r7, #12]

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
 800f3bc:	68bb      	ldr	r3, [r7, #8]
 800f3be:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800f3c2:	60bb      	str	r3, [r7, #8]
  /* Set master mode */
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 800f3c4:	683b      	ldr	r3, [r7, #0]
 800f3c6:	689b      	ldr	r3, [r3, #8]
 800f3c8:	68ba      	ldr	r2, [r7, #8]
 800f3ca:	4313      	orrs	r3, r2
 800f3cc:	60bb      	str	r3, [r7, #8]
  
  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 800f3ce:	687b      	ldr	r3, [r7, #4]
 800f3d0:	681b      	ldr	r3, [r3, #0]
 800f3d2:	68fa      	ldr	r2, [r7, #12]
 800f3d4:	605a      	str	r2, [r3, #4]
  
  /* Update TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;
 800f3d6:	687b      	ldr	r3, [r7, #4]
 800f3d8:	681b      	ldr	r3, [r3, #0]
 800f3da:	68ba      	ldr	r2, [r7, #8]
 800f3dc:	609a      	str	r2, [r3, #8]

  __HAL_UNLOCK(htim);
 800f3de:	687b      	ldr	r3, [r7, #4]
 800f3e0:	2200      	movs	r2, #0
 800f3e2:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  return HAL_OK;
 800f3e6:	2300      	movs	r3, #0
} 
 800f3e8:	4618      	mov	r0, r3
 800f3ea:	3714      	adds	r7, #20
 800f3ec:	46bd      	mov	sp, r7
 800f3ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f3f2:	4770      	bx	lr
 800f3f4:	40010000 	.word	0x40010000
 800f3f8:	40010400 	.word	0x40010400

0800f3fc <HAL_TIMEx_ConfigBreakDeadTime>:
  *         contains the BDTR Register configuration  information for the TIM peripheral. 
  * @retval HAL status
  */    
HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim, 
                                              TIM_BreakDeadTimeConfigTypeDef * sBreakDeadTimeConfig)
{
 800f3fc:	b480      	push	{r7}
 800f3fe:	b085      	sub	sp, #20
 800f400:	af00      	add	r7, sp, #0
 800f402:	6078      	str	r0, [r7, #4]
 800f404:	6039      	str	r1, [r7, #0]
  uint32_t tmpbdtr = 0;
 800f406:	2300      	movs	r3, #0
 800f408:	60fb      	str	r3, [r7, #12]
  assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig->Break2State));
  assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig->Break2Polarity));
  assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->Break2Filter));
  
  /* Check input state */
  __HAL_LOCK(htim);
 800f40a:	687b      	ldr	r3, [r7, #4]
 800f40c:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 800f410:	2b01      	cmp	r3, #1
 800f412:	d101      	bne.n	800f418 <HAL_TIMEx_ConfigBreakDeadTime+0x1c>
 800f414:	2302      	movs	r3, #2
 800f416:	e04d      	b.n	800f4b4 <HAL_TIMEx_ConfigBreakDeadTime+0xb8>
 800f418:	687b      	ldr	r3, [r7, #4]
 800f41a:	2201      	movs	r2, #1
 800f41c:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  htim->State = HAL_TIM_STATE_BUSY;
 800f420:	687b      	ldr	r3, [r7, #4]
 800f422:	2202      	movs	r2, #2
 800f424:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
    
  /* Clear the BDTR bits */
  tmpbdtr &= ~(TIM_BDTR_DTG | TIM_BDTR_LOCK |  TIM_BDTR_OSSI | 
 800f428:	68fb      	ldr	r3, [r7, #12]
 800f42a:	f003 437c 	and.w	r3, r3, #4227858432	; 0xfc000000
 800f42e:	60fb      	str	r3, [r7, #12]
               TIM_BDTR_OSSR | TIM_BDTR_BKE | TIM_BDTR_BKP | 
               TIM_BDTR_AOE | TIM_BDTR_MOE | TIM_BDTR_BKF |
               TIM_BDTR_BK2F | TIM_BDTR_BK2E | TIM_BDTR_BK2P);

  /* Set the BDTR bits */
  tmpbdtr |= sBreakDeadTimeConfig->DeadTime;
 800f430:	683b      	ldr	r3, [r7, #0]
 800f432:	68db      	ldr	r3, [r3, #12]
 800f434:	68fa      	ldr	r2, [r7, #12]
 800f436:	4313      	orrs	r3, r2
 800f438:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->LockLevel;
 800f43a:	683b      	ldr	r3, [r7, #0]
 800f43c:	689b      	ldr	r3, [r3, #8]
 800f43e:	68fa      	ldr	r2, [r7, #12]
 800f440:	4313      	orrs	r3, r2
 800f442:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->OffStateIDLEMode;
 800f444:	683b      	ldr	r3, [r7, #0]
 800f446:	685b      	ldr	r3, [r3, #4]
 800f448:	68fa      	ldr	r2, [r7, #12]
 800f44a:	4313      	orrs	r3, r2
 800f44c:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->OffStateRunMode;
 800f44e:	683b      	ldr	r3, [r7, #0]
 800f450:	681b      	ldr	r3, [r3, #0]
 800f452:	68fa      	ldr	r2, [r7, #12]
 800f454:	4313      	orrs	r3, r2
 800f456:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->BreakState;
 800f458:	683b      	ldr	r3, [r7, #0]
 800f45a:	691b      	ldr	r3, [r3, #16]
 800f45c:	68fa      	ldr	r2, [r7, #12]
 800f45e:	4313      	orrs	r3, r2
 800f460:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->BreakPolarity;
 800f462:	683b      	ldr	r3, [r7, #0]
 800f464:	695b      	ldr	r3, [r3, #20]
 800f466:	68fa      	ldr	r2, [r7, #12]
 800f468:	4313      	orrs	r3, r2
 800f46a:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->AutomaticOutput;
 800f46c:	683b      	ldr	r3, [r7, #0]
 800f46e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f470:	68fa      	ldr	r2, [r7, #12]
 800f472:	4313      	orrs	r3, r2
 800f474:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= (sBreakDeadTimeConfig->BreakFilter << BDTR_BKF_SHIFT);
 800f476:	683b      	ldr	r3, [r7, #0]
 800f478:	699b      	ldr	r3, [r3, #24]
 800f47a:	041b      	lsls	r3, r3, #16
 800f47c:	68fa      	ldr	r2, [r7, #12]
 800f47e:	4313      	orrs	r3, r2
 800f480:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= (sBreakDeadTimeConfig->Break2Filter << BDTR_BK2F_SHIFT);
 800f482:	683b      	ldr	r3, [r7, #0]
 800f484:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f486:	051b      	lsls	r3, r3, #20
 800f488:	68fa      	ldr	r2, [r7, #12]
 800f48a:	4313      	orrs	r3, r2
 800f48c:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->Break2State;
 800f48e:	683b      	ldr	r3, [r7, #0]
 800f490:	69db      	ldr	r3, [r3, #28]
 800f492:	68fa      	ldr	r2, [r7, #12]
 800f494:	4313      	orrs	r3, r2
 800f496:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->Break2Polarity;
 800f498:	683b      	ldr	r3, [r7, #0]
 800f49a:	6a1b      	ldr	r3, [r3, #32]
 800f49c:	68fa      	ldr	r2, [r7, #12]
 800f49e:	4313      	orrs	r3, r2
 800f4a0:	60fb      	str	r3, [r7, #12]
  
  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;
 800f4a2:	687b      	ldr	r3, [r7, #4]
 800f4a4:	681b      	ldr	r3, [r3, #0]
 800f4a6:	68fa      	ldr	r2, [r7, #12]
 800f4a8:	645a      	str	r2, [r3, #68]	; 0x44
  
  __HAL_UNLOCK(htim);
 800f4aa:	687b      	ldr	r3, [r7, #4]
 800f4ac:	2200      	movs	r2, #0
 800f4ae:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  return HAL_OK;
 800f4b2:	2300      	movs	r3, #0
}
 800f4b4:	4618      	mov	r0, r3
 800f4b6:	3714      	adds	r7, #20
 800f4b8:	46bd      	mov	sp, r7
 800f4ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f4be:	4770      	bx	lr

0800f4c0 <HAL_TIMEx_CommutationCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef *htim)
{
 800f4c0:	b480      	push	{r7}
 800f4c2:	b083      	sub	sp, #12
 800f4c4:	af00      	add	r7, sp, #0
 800f4c6:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutationCallback could be implemented in the user file
   */
}
 800f4c8:	370c      	adds	r7, #12
 800f4ca:	46bd      	mov	sp, r7
 800f4cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f4d0:	4770      	bx	lr
 800f4d2:	bf00      	nop

0800f4d4 <TIM_OC5_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800f4d4:	b480      	push	{r7}
 800f4d6:	b087      	sub	sp, #28
 800f4d8:	af00      	add	r7, sp, #0
 800f4da:	6078      	str	r0, [r7, #4]
 800f4dc:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0;
 800f4de:	2300      	movs	r3, #0
 800f4e0:	613b      	str	r3, [r7, #16]
  uint32_t tmpccer = 0;
 800f4e2:	2300      	movs	r3, #0
 800f4e4:	60fb      	str	r3, [r7, #12]
  uint32_t tmpcr2 = 0; 
 800f4e6:	2300      	movs	r3, #0
 800f4e8:	617b      	str	r3, [r7, #20]

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
 800f4ea:	687b      	ldr	r3, [r7, #4]
 800f4ec:	6a1b      	ldr	r3, [r3, #32]
 800f4ee:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 800f4f2:	687b      	ldr	r3, [r7, #4]
 800f4f4:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800f4f6:	687b      	ldr	r3, [r7, #4]
 800f4f8:	6a1b      	ldr	r3, [r3, #32]
 800f4fa:	60fb      	str	r3, [r7, #12]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2; 
 800f4fc:	687b      	ldr	r3, [r7, #4]
 800f4fe:	685b      	ldr	r3, [r3, #4]
 800f500:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 800f502:	687b      	ldr	r3, [r7, #4]
 800f504:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800f506:	613b      	str	r3, [r7, #16]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 800f508:	693a      	ldr	r2, [r7, #16]
 800f50a:	4b1b      	ldr	r3, [pc, #108]	; (800f578 <TIM_OC5_SetConfig+0xa4>)
 800f50c:	4013      	ands	r3, r2
 800f50e:	613b      	str	r3, [r7, #16]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800f510:	683b      	ldr	r3, [r7, #0]
 800f512:	681b      	ldr	r3, [r3, #0]
 800f514:	693a      	ldr	r2, [r7, #16]
 800f516:	4313      	orrs	r3, r2
 800f518:	613b      	str	r3, [r7, #16]
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
 800f51a:	68fb      	ldr	r3, [r7, #12]
 800f51c:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 800f520:	60fb      	str	r3, [r7, #12]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16);
 800f522:	683b      	ldr	r3, [r7, #0]
 800f524:	689b      	ldr	r3, [r3, #8]
 800f526:	041b      	lsls	r3, r3, #16
 800f528:	68fa      	ldr	r2, [r7, #12]
 800f52a:	4313      	orrs	r3, r2
 800f52c:	60fb      	str	r3, [r7, #12]

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 800f52e:	687b      	ldr	r3, [r7, #4]
 800f530:	4a12      	ldr	r2, [pc, #72]	; (800f57c <TIM_OC5_SetConfig+0xa8>)
 800f532:	4293      	cmp	r3, r2
 800f534:	d003      	beq.n	800f53e <TIM_OC5_SetConfig+0x6a>
 800f536:	687b      	ldr	r3, [r7, #4]
 800f538:	4a11      	ldr	r2, [pc, #68]	; (800f580 <TIM_OC5_SetConfig+0xac>)
 800f53a:	4293      	cmp	r3, r2
 800f53c:	d109      	bne.n	800f552 <TIM_OC5_SetConfig+0x7e>
  {   
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
 800f53e:	697b      	ldr	r3, [r7, #20]
 800f540:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800f544:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8);
 800f546:	683b      	ldr	r3, [r7, #0]
 800f548:	695b      	ldr	r3, [r3, #20]
 800f54a:	021b      	lsls	r3, r3, #8
 800f54c:	697a      	ldr	r2, [r7, #20]
 800f54e:	4313      	orrs	r3, r2
 800f550:	617b      	str	r3, [r7, #20]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800f552:	687b      	ldr	r3, [r7, #4]
 800f554:	697a      	ldr	r2, [r7, #20]
 800f556:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 800f558:	687b      	ldr	r3, [r7, #4]
 800f55a:	693a      	ldr	r2, [r7, #16]
 800f55c:	655a      	str	r2, [r3, #84]	; 0x54
  
  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
 800f55e:	683b      	ldr	r3, [r7, #0]
 800f560:	685a      	ldr	r2, [r3, #4]
 800f562:	687b      	ldr	r3, [r7, #4]
 800f564:	659a      	str	r2, [r3, #88]	; 0x58
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;  
 800f566:	687b      	ldr	r3, [r7, #4]
 800f568:	68fa      	ldr	r2, [r7, #12]
 800f56a:	621a      	str	r2, [r3, #32]
}
 800f56c:	371c      	adds	r7, #28
 800f56e:	46bd      	mov	sp, r7
 800f570:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f574:	4770      	bx	lr
 800f576:	bf00      	nop
 800f578:	fffeff8f 	.word	0xfffeff8f
 800f57c:	40010000 	.word	0x40010000
 800f580:	40010400 	.word	0x40010400

0800f584 <TIM_OC6_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800f584:	b480      	push	{r7}
 800f586:	b087      	sub	sp, #28
 800f588:	af00      	add	r7, sp, #0
 800f58a:	6078      	str	r0, [r7, #4]
 800f58c:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0;
 800f58e:	2300      	movs	r3, #0
 800f590:	613b      	str	r3, [r7, #16]
  uint32_t tmpccer = 0;
 800f592:	2300      	movs	r3, #0
 800f594:	60fb      	str	r3, [r7, #12]
  uint32_t tmpcr2 = 0; 
 800f596:	2300      	movs	r3, #0
 800f598:	617b      	str	r3, [r7, #20]

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
 800f59a:	687b      	ldr	r3, [r7, #4]
 800f59c:	6a1b      	ldr	r3, [r3, #32]
 800f59e:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
 800f5a2:	687b      	ldr	r3, [r7, #4]
 800f5a4:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800f5a6:	687b      	ldr	r3, [r7, #4]
 800f5a8:	6a1b      	ldr	r3, [r3, #32]
 800f5aa:	60fb      	str	r3, [r7, #12]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2; 
 800f5ac:	687b      	ldr	r3, [r7, #4]
 800f5ae:	685b      	ldr	r3, [r3, #4]
 800f5b0:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 800f5b2:	687b      	ldr	r3, [r7, #4]
 800f5b4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800f5b6:	613b      	str	r3, [r7, #16]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 800f5b8:	693a      	ldr	r2, [r7, #16]
 800f5ba:	4b1b      	ldr	r3, [pc, #108]	; (800f628 <TIM_OC6_SetConfig+0xa4>)
 800f5bc:	4013      	ands	r3, r2
 800f5be:	613b      	str	r3, [r7, #16]
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 800f5c0:	683b      	ldr	r3, [r7, #0]
 800f5c2:	681b      	ldr	r3, [r3, #0]
 800f5c4:	021b      	lsls	r3, r3, #8
 800f5c6:	693a      	ldr	r2, [r7, #16]
 800f5c8:	4313      	orrs	r3, r2
 800f5ca:	613b      	str	r3, [r7, #16]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 800f5cc:	68fb      	ldr	r3, [r7, #12]
 800f5ce:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800f5d2:	60fb      	str	r3, [r7, #12]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20);
 800f5d4:	683b      	ldr	r3, [r7, #0]
 800f5d6:	689b      	ldr	r3, [r3, #8]
 800f5d8:	051b      	lsls	r3, r3, #20
 800f5da:	68fa      	ldr	r2, [r7, #12]
 800f5dc:	4313      	orrs	r3, r2
 800f5de:	60fb      	str	r3, [r7, #12]

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 800f5e0:	687b      	ldr	r3, [r7, #4]
 800f5e2:	4a12      	ldr	r2, [pc, #72]	; (800f62c <TIM_OC6_SetConfig+0xa8>)
 800f5e4:	4293      	cmp	r3, r2
 800f5e6:	d003      	beq.n	800f5f0 <TIM_OC6_SetConfig+0x6c>
 800f5e8:	687b      	ldr	r3, [r7, #4]
 800f5ea:	4a11      	ldr	r2, [pc, #68]	; (800f630 <TIM_OC6_SetConfig+0xac>)
 800f5ec:	4293      	cmp	r3, r2
 800f5ee:	d109      	bne.n	800f604 <TIM_OC6_SetConfig+0x80>
  {   
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
 800f5f0:	697b      	ldr	r3, [r7, #20]
 800f5f2:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800f5f6:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10);
 800f5f8:	683b      	ldr	r3, [r7, #0]
 800f5fa:	695b      	ldr	r3, [r3, #20]
 800f5fc:	029b      	lsls	r3, r3, #10
 800f5fe:	697a      	ldr	r2, [r7, #20]
 800f600:	4313      	orrs	r3, r2
 800f602:	617b      	str	r3, [r7, #20]
  }
  
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800f604:	687b      	ldr	r3, [r7, #4]
 800f606:	697a      	ldr	r2, [r7, #20]
 800f608:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 800f60a:	687b      	ldr	r3, [r7, #4]
 800f60c:	693a      	ldr	r2, [r7, #16]
 800f60e:	655a      	str	r2, [r3, #84]	; 0x54
  
  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 800f610:	683b      	ldr	r3, [r7, #0]
 800f612:	685a      	ldr	r2, [r3, #4]
 800f614:	687b      	ldr	r3, [r7, #4]
 800f616:	65da      	str	r2, [r3, #92]	; 0x5c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;  
 800f618:	687b      	ldr	r3, [r7, #4]
 800f61a:	68fa      	ldr	r2, [r7, #12]
 800f61c:	621a      	str	r2, [r3, #32]
} 
 800f61e:	371c      	adds	r7, #28
 800f620:	46bd      	mov	sp, r7
 800f622:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f626:	4770      	bx	lr
 800f628:	feff8fff 	.word	0xfeff8fff
 800f62c:	40010000 	.word	0x40010000
 800f630:	40010400 	.word	0x40010400

0800f634 <HAL_UART_Init>:
  *         parameters in the UART_InitTypeDef and creates the associated handle .
  * @param huart: uart handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 800f634:	b580      	push	{r7, lr}
 800f636:	b082      	sub	sp, #8
 800f638:	af00      	add	r7, sp, #0
 800f63a:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if(huart == NULL)
 800f63c:	687b      	ldr	r3, [r7, #4]
 800f63e:	2b00      	cmp	r3, #0
 800f640:	d101      	bne.n	800f646 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 800f642:	2301      	movs	r3, #1
 800f644:	e043      	b.n	800f6ce <HAL_UART_Init+0x9a>
  {
    /* Check the parameters */
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }
  
  if(huart->State == HAL_UART_STATE_RESET)
 800f646:	687b      	ldr	r3, [r7, #4]
 800f648:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
 800f64c:	b2db      	uxtb	r3, r3
 800f64e:	2b00      	cmp	r3, #0
 800f650:	d106      	bne.n	800f660 <HAL_UART_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 800f652:	687b      	ldr	r3, [r7, #4]
 800f654:	2200      	movs	r2, #0
 800f656:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68

    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 800f65a:	6878      	ldr	r0, [r7, #4]
 800f65c:	f005 f9fa 	bl	8014a54 <HAL_UART_MspInit>
  }

  huart->State = HAL_UART_STATE_BUSY;
 800f660:	687b      	ldr	r3, [r7, #4]
 800f662:	2202      	movs	r2, #2
 800f664:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69

  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
 800f668:	687b      	ldr	r3, [r7, #4]
 800f66a:	681b      	ldr	r3, [r3, #0]
 800f66c:	687a      	ldr	r2, [r7, #4]
 800f66e:	6812      	ldr	r2, [r2, #0]
 800f670:	6812      	ldr	r2, [r2, #0]
 800f672:	f022 0201 	bic.w	r2, r2, #1
 800f676:	601a      	str	r2, [r3, #0]
  
  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 800f678:	6878      	ldr	r0, [r7, #4]
 800f67a:	f000 f9e9 	bl	800fa50 <UART_SetConfig>
 800f67e:	4603      	mov	r3, r0
 800f680:	2b01      	cmp	r3, #1
 800f682:	d101      	bne.n	800f688 <HAL_UART_Init+0x54>
  {
    return HAL_ERROR;
 800f684:	2301      	movs	r3, #1
 800f686:	e022      	b.n	800f6ce <HAL_UART_Init+0x9a>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800f688:	687b      	ldr	r3, [r7, #4]
 800f68a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f68c:	2b00      	cmp	r3, #0
 800f68e:	d002      	beq.n	800f696 <HAL_UART_Init+0x62>
  {
    UART_AdvFeatureConfig(huart);
 800f690:	6878      	ldr	r0, [r7, #4]
 800f692:	f000 fc29 	bl	800fee8 <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
 800f696:	687b      	ldr	r3, [r7, #4]
 800f698:	681b      	ldr	r3, [r3, #0]
 800f69a:	687a      	ldr	r2, [r7, #4]
 800f69c:	6812      	ldr	r2, [r2, #0]
 800f69e:	6852      	ldr	r2, [r2, #4]
 800f6a0:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 800f6a4:	605a      	str	r2, [r3, #4]
  huart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
 800f6a6:	687b      	ldr	r3, [r7, #4]
 800f6a8:	681b      	ldr	r3, [r3, #0]
 800f6aa:	687a      	ldr	r2, [r7, #4]
 800f6ac:	6812      	ldr	r2, [r2, #0]
 800f6ae:	6892      	ldr	r2, [r2, #8]
 800f6b0:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 800f6b4:	609a      	str	r2, [r3, #8]

  /* Enable the Peripheral */
  __HAL_UART_ENABLE(huart);
 800f6b6:	687b      	ldr	r3, [r7, #4]
 800f6b8:	681b      	ldr	r3, [r3, #0]
 800f6ba:	687a      	ldr	r2, [r7, #4]
 800f6bc:	6812      	ldr	r2, [r2, #0]
 800f6be:	6812      	ldr	r2, [r2, #0]
 800f6c0:	f042 0201 	orr.w	r2, r2, #1
 800f6c4:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->State to Ready */
  return (UART_CheckIdleState(huart));
 800f6c6:	6878      	ldr	r0, [r7, #4]
 800f6c8:	f000 fcb0 	bl	801002c <UART_CheckIdleState>
 800f6cc:	4603      	mov	r3, r0
}
 800f6ce:	4618      	mov	r0, r3
 800f6d0:	3708      	adds	r7, #8
 800f6d2:	46bd      	mov	sp, r7
 800f6d4:	bd80      	pop	{r7, pc}
 800f6d6:	bf00      	nop

0800f6d8 <HAL_UART_DeInit>:
  * @brief DeInitializes the UART peripheral 
  * @param huart: uart handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
{
 800f6d8:	b580      	push	{r7, lr}
 800f6da:	b082      	sub	sp, #8
 800f6dc:	af00      	add	r7, sp, #0
 800f6de:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if(huart == NULL)
 800f6e0:	687b      	ldr	r3, [r7, #4]
 800f6e2:	2b00      	cmp	r3, #0
 800f6e4:	d101      	bne.n	800f6ea <HAL_UART_DeInit+0x12>
  {
    return HAL_ERROR;
 800f6e6:	2301      	movs	r3, #1
 800f6e8:	e026      	b.n	800f738 <HAL_UART_DeInit+0x60>
  }
  
  /* Check the parameters */
  assert_param(IS_UART_INSTANCE(huart->Instance));

  huart->State = HAL_UART_STATE_BUSY;
 800f6ea:	687b      	ldr	r3, [r7, #4]
 800f6ec:	2202      	movs	r2, #2
 800f6ee:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
  
  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
 800f6f2:	687b      	ldr	r3, [r7, #4]
 800f6f4:	681b      	ldr	r3, [r3, #0]
 800f6f6:	687a      	ldr	r2, [r7, #4]
 800f6f8:	6812      	ldr	r2, [r2, #0]
 800f6fa:	6812      	ldr	r2, [r2, #0]
 800f6fc:	f022 0201 	bic.w	r2, r2, #1
 800f700:	601a      	str	r2, [r3, #0]
  
  huart->Instance->CR1 = 0x0;
 800f702:	687b      	ldr	r3, [r7, #4]
 800f704:	681b      	ldr	r3, [r3, #0]
 800f706:	2200      	movs	r2, #0
 800f708:	601a      	str	r2, [r3, #0]
  huart->Instance->CR2 = 0x0;
 800f70a:	687b      	ldr	r3, [r7, #4]
 800f70c:	681b      	ldr	r3, [r3, #0]
 800f70e:	2200      	movs	r2, #0
 800f710:	605a      	str	r2, [r3, #4]
  huart->Instance->CR3 = 0x0;
 800f712:	687b      	ldr	r3, [r7, #4]
 800f714:	681b      	ldr	r3, [r3, #0]
 800f716:	2200      	movs	r2, #0
 800f718:	609a      	str	r2, [r3, #8]
  
  /* DeInit the low level hardware */
  HAL_UART_MspDeInit(huart);
 800f71a:	6878      	ldr	r0, [r7, #4]
 800f71c:	f005 fa46 	bl	8014bac <HAL_UART_MspDeInit>

  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800f720:	687b      	ldr	r3, [r7, #4]
 800f722:	2200      	movs	r2, #0
 800f724:	66da      	str	r2, [r3, #108]	; 0x6c
  huart->State = HAL_UART_STATE_RESET;
 800f726:	687b      	ldr	r3, [r7, #4]
 800f728:	2200      	movs	r2, #0
 800f72a:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
  
  /* Process Unlock */
  __HAL_UNLOCK(huart);
 800f72e:	687b      	ldr	r3, [r7, #4]
 800f730:	2200      	movs	r2, #0
 800f732:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
  
  return HAL_OK;
 800f736:	2300      	movs	r3, #0
}
 800f738:	4618      	mov	r0, r3
 800f73a:	3708      	adds	r7, #8
 800f73c:	46bd      	mov	sp, r7
 800f73e:	bd80      	pop	{r7, pc}

0800f740 <HAL_UART_Receive_DMA>:
  * @note   When the UART parity is enabled (PCE = 1), the received data contain 
  *         the parity bit (MSB position)     
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 800f740:	b590      	push	{r4, r7, lr}
 800f742:	b087      	sub	sp, #28
 800f744:	af00      	add	r7, sp, #0
 800f746:	60f8      	str	r0, [r7, #12]
 800f748:	60b9      	str	r1, [r7, #8]
 800f74a:	4613      	mov	r3, r2
 800f74c:	80fb      	strh	r3, [r7, #6]
  uint32_t *tmp;
  
  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_TX))
 800f74e:	68fb      	ldr	r3, [r7, #12]
 800f750:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
 800f754:	b2db      	uxtb	r3, r3
 800f756:	2b01      	cmp	r3, #1
 800f758:	d005      	beq.n	800f766 <HAL_UART_Receive_DMA+0x26>
 800f75a:	68fb      	ldr	r3, [r7, #12]
 800f75c:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
 800f760:	b2db      	uxtb	r3, r3
 800f762:	2b12      	cmp	r3, #18
 800f764:	d155      	bne.n	800f812 <HAL_UART_Receive_DMA+0xd2>
  {
    if((pData == NULL ) || (Size == 0)) 
 800f766:	68bb      	ldr	r3, [r7, #8]
 800f768:	2b00      	cmp	r3, #0
 800f76a:	d002      	beq.n	800f772 <HAL_UART_Receive_DMA+0x32>
 800f76c:	88fb      	ldrh	r3, [r7, #6]
 800f76e:	2b00      	cmp	r3, #0
 800f770:	d101      	bne.n	800f776 <HAL_UART_Receive_DMA+0x36>
    {
      return HAL_ERROR;
 800f772:	2301      	movs	r3, #1
 800f774:	e04e      	b.n	800f814 <HAL_UART_Receive_DMA+0xd4>
    }
    
    /* Process Locked */
    __HAL_LOCK(huart);
 800f776:	68fb      	ldr	r3, [r7, #12]
 800f778:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
 800f77c:	2b01      	cmp	r3, #1
 800f77e:	d101      	bne.n	800f784 <HAL_UART_Receive_DMA+0x44>
 800f780:	2302      	movs	r3, #2
 800f782:	e047      	b.n	800f814 <HAL_UART_Receive_DMA+0xd4>
 800f784:	68fb      	ldr	r3, [r7, #12]
 800f786:	2201      	movs	r2, #1
 800f788:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
    
    huart->pRxBuffPtr = pData;
 800f78c:	68ba      	ldr	r2, [r7, #8]
 800f78e:	68fb      	ldr	r3, [r7, #12]
 800f790:	655a      	str	r2, [r3, #84]	; 0x54
    huart->RxXferSize = Size;
 800f792:	68fb      	ldr	r3, [r7, #12]
 800f794:	88fa      	ldrh	r2, [r7, #6]
 800f796:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
    
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800f79a:	68fb      	ldr	r3, [r7, #12]
 800f79c:	2200      	movs	r2, #0
 800f79e:	66da      	str	r2, [r3, #108]	; 0x6c
    /* Check if a transmit process is ongoing or not */
    if(huart->State == HAL_UART_STATE_BUSY_TX) 
 800f7a0:	68fb      	ldr	r3, [r7, #12]
 800f7a2:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
 800f7a6:	b2db      	uxtb	r3, r3
 800f7a8:	2b12      	cmp	r3, #18
 800f7aa:	d104      	bne.n	800f7b6 <HAL_UART_Receive_DMA+0x76>
    {
      huart->State = HAL_UART_STATE_BUSY_TX_RX;
 800f7ac:	68fb      	ldr	r3, [r7, #12]
 800f7ae:	2232      	movs	r2, #50	; 0x32
 800f7b0:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
 800f7b4:	e003      	b.n	800f7be <HAL_UART_Receive_DMA+0x7e>
    }
    else
    {
      huart->State = HAL_UART_STATE_BUSY_RX;
 800f7b6:	68fb      	ldr	r3, [r7, #12]
 800f7b8:	2222      	movs	r2, #34	; 0x22
 800f7ba:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
    }
    
    /* Set the UART DMA transfer complete callback */
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 800f7be:	68fb      	ldr	r3, [r7, #12]
 800f7c0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800f7c2:	4a16      	ldr	r2, [pc, #88]	; (800f81c <HAL_UART_Receive_DMA+0xdc>)
 800f7c4:	63da      	str	r2, [r3, #60]	; 0x3c
    
    /* Set the UART DMA Half transfer complete callback */
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 800f7c6:	68fb      	ldr	r3, [r7, #12]
 800f7c8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800f7ca:	4a15      	ldr	r2, [pc, #84]	; (800f820 <HAL_UART_Receive_DMA+0xe0>)
 800f7cc:	641a      	str	r2, [r3, #64]	; 0x40
    
    /* Set the DMA error callback */
    huart->hdmarx->XferErrorCallback = UART_DMAError;
 800f7ce:	68fb      	ldr	r3, [r7, #12]
 800f7d0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800f7d2:	4a14      	ldr	r2, [pc, #80]	; (800f824 <HAL_UART_Receive_DMA+0xe4>)
 800f7d4:	649a      	str	r2, [r3, #72]	; 0x48

    /* Enable the DMA channel */
    tmp = (uint32_t*)&pData;
 800f7d6:	f107 0308 	add.w	r3, r7, #8
 800f7da:	617b      	str	r3, [r7, #20]
    HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, *(uint32_t*)tmp, Size);
 800f7dc:	68fb      	ldr	r3, [r7, #12]
 800f7de:	6e59      	ldr	r1, [r3, #100]	; 0x64
 800f7e0:	68fb      	ldr	r3, [r7, #12]
 800f7e2:	681b      	ldr	r3, [r3, #0]
 800f7e4:	3324      	adds	r3, #36	; 0x24
 800f7e6:	461c      	mov	r4, r3
 800f7e8:	697b      	ldr	r3, [r7, #20]
 800f7ea:	681a      	ldr	r2, [r3, #0]
 800f7ec:	88fb      	ldrh	r3, [r7, #6]
 800f7ee:	4608      	mov	r0, r1
 800f7f0:	4621      	mov	r1, r4
 800f7f2:	f7fa fc35 	bl	800a060 <HAL_DMA_Start_IT>

    /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
       in the UART CR3 register */
     huart->Instance->CR3 |= USART_CR3_DMAR;
 800f7f6:	68fb      	ldr	r3, [r7, #12]
 800f7f8:	681b      	ldr	r3, [r3, #0]
 800f7fa:	68fa      	ldr	r2, [r7, #12]
 800f7fc:	6812      	ldr	r2, [r2, #0]
 800f7fe:	6892      	ldr	r2, [r2, #8]
 800f800:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800f804:	609a      	str	r2, [r3, #8]
    
     /* Process Unlocked */
     __HAL_UNLOCK(huart);
 800f806:	68fb      	ldr	r3, [r7, #12]
 800f808:	2200      	movs	r2, #0
 800f80a:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
     
    return HAL_OK;
 800f80e:	2300      	movs	r3, #0
 800f810:	e000      	b.n	800f814 <HAL_UART_Receive_DMA+0xd4>
  }
  else
  {
    return HAL_BUSY; 
 800f812:	2302      	movs	r3, #2
  }
}
 800f814:	4618      	mov	r0, r3
 800f816:	371c      	adds	r7, #28
 800f818:	46bd      	mov	sp, r7
 800f81a:	bd90      	pop	{r4, r7, pc}
 800f81c:	0800f959 	.word	0x0800f959
 800f820:	0800f9b9 	.word	0x0800f9b9
 800f824:	0800f9d5 	.word	0x0800f9d5

0800f828 <UART_WaitOnFlagUntilTimeout>:
  * @param  Status: The new Flag status (SET or RESET).
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
{
 800f828:	b580      	push	{r7, lr}
 800f82a:	b086      	sub	sp, #24
 800f82c:	af00      	add	r7, sp, #0
 800f82e:	60f8      	str	r0, [r7, #12]
 800f830:	60b9      	str	r1, [r7, #8]
 800f832:	603b      	str	r3, [r7, #0]
 800f834:	4613      	mov	r3, r2
 800f836:	71fb      	strb	r3, [r7, #7]
  uint32_t tickstart = HAL_GetTick();
 800f838:	f7f7 f8da 	bl	80069f0 <HAL_GetTick>
 800f83c:	6178      	str	r0, [r7, #20]
  
  /* Wait until flag is set */
  if(Status == RESET)
 800f83e:	79fb      	ldrb	r3, [r7, #7]
 800f840:	2b00      	cmp	r3, #0
 800f842:	d142      	bne.n	800f8ca <UART_WaitOnFlagUntilTimeout+0xa2>
  {    
    while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
 800f844:	e038      	b.n	800f8b8 <UART_WaitOnFlagUntilTimeout+0x90>
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 800f846:	683b      	ldr	r3, [r7, #0]
 800f848:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f84c:	d034      	beq.n	800f8b8 <UART_WaitOnFlagUntilTimeout+0x90>
      {
        if((Timeout == 0)||((HAL_GetTick()-tickstart) >=  Timeout))
 800f84e:	683b      	ldr	r3, [r7, #0]
 800f850:	2b00      	cmp	r3, #0
 800f852:	d007      	beq.n	800f864 <UART_WaitOnFlagUntilTimeout+0x3c>
 800f854:	f7f7 f8cc 	bl	80069f0 <HAL_GetTick>
 800f858:	4602      	mov	r2, r0
 800f85a:	697b      	ldr	r3, [r7, #20]
 800f85c:	1ad2      	subs	r2, r2, r3
 800f85e:	683b      	ldr	r3, [r7, #0]
 800f860:	429a      	cmp	r2, r3
 800f862:	d329      	bcc.n	800f8b8 <UART_WaitOnFlagUntilTimeout+0x90>
        {
          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
          __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 800f864:	68fb      	ldr	r3, [r7, #12]
 800f866:	681b      	ldr	r3, [r3, #0]
 800f868:	68fa      	ldr	r2, [r7, #12]
 800f86a:	6812      	ldr	r2, [r2, #0]
 800f86c:	6812      	ldr	r2, [r2, #0]
 800f86e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800f872:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 800f874:	68fb      	ldr	r3, [r7, #12]
 800f876:	681b      	ldr	r3, [r3, #0]
 800f878:	68fa      	ldr	r2, [r7, #12]
 800f87a:	6812      	ldr	r2, [r2, #0]
 800f87c:	6812      	ldr	r2, [r2, #0]
 800f87e:	f022 0220 	bic.w	r2, r2, #32
 800f882:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 800f884:	68fb      	ldr	r3, [r7, #12]
 800f886:	681b      	ldr	r3, [r3, #0]
 800f888:	68fa      	ldr	r2, [r7, #12]
 800f88a:	6812      	ldr	r2, [r2, #0]
 800f88c:	6812      	ldr	r2, [r2, #0]
 800f88e:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800f892:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 800f894:	68fb      	ldr	r3, [r7, #12]
 800f896:	681b      	ldr	r3, [r3, #0]
 800f898:	68fa      	ldr	r2, [r7, #12]
 800f89a:	6812      	ldr	r2, [r2, #0]
 800f89c:	6892      	ldr	r2, [r2, #8]
 800f89e:	f022 0201 	bic.w	r2, r2, #1
 800f8a2:	609a      	str	r2, [r3, #8]
          
          huart->State= HAL_UART_STATE_READY;
 800f8a4:	68fb      	ldr	r3, [r7, #12]
 800f8a6:	2201      	movs	r2, #1
 800f8a8:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
          
          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 800f8ac:	68fb      	ldr	r3, [r7, #12]
 800f8ae:	2200      	movs	r2, #0
 800f8b0:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
          
          return HAL_TIMEOUT;
 800f8b4:	2303      	movs	r3, #3
 800f8b6:	e04b      	b.n	800f950 <UART_WaitOnFlagUntilTimeout+0x128>
  uint32_t tickstart = HAL_GetTick();
  
  /* Wait until flag is set */
  if(Status == RESET)
  {    
    while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
 800f8b8:	68fb      	ldr	r3, [r7, #12]
 800f8ba:	681b      	ldr	r3, [r3, #0]
 800f8bc:	69da      	ldr	r2, [r3, #28]
 800f8be:	68bb      	ldr	r3, [r7, #8]
 800f8c0:	401a      	ands	r2, r3
 800f8c2:	68bb      	ldr	r3, [r7, #8]
 800f8c4:	429a      	cmp	r2, r3
 800f8c6:	d1be      	bne.n	800f846 <UART_WaitOnFlagUntilTimeout+0x1e>
 800f8c8:	e041      	b.n	800f94e <UART_WaitOnFlagUntilTimeout+0x126>
      }
    }
  }
  else
  {
    while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
 800f8ca:	e038      	b.n	800f93e <UART_WaitOnFlagUntilTimeout+0x116>
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 800f8cc:	683b      	ldr	r3, [r7, #0]
 800f8ce:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f8d2:	d034      	beq.n	800f93e <UART_WaitOnFlagUntilTimeout+0x116>
      {
        if((Timeout == 0)||((HAL_GetTick()-tickstart) >=  Timeout))
 800f8d4:	683b      	ldr	r3, [r7, #0]
 800f8d6:	2b00      	cmp	r3, #0
 800f8d8:	d007      	beq.n	800f8ea <UART_WaitOnFlagUntilTimeout+0xc2>
 800f8da:	f7f7 f889 	bl	80069f0 <HAL_GetTick>
 800f8de:	4602      	mov	r2, r0
 800f8e0:	697b      	ldr	r3, [r7, #20]
 800f8e2:	1ad2      	subs	r2, r2, r3
 800f8e4:	683b      	ldr	r3, [r7, #0]
 800f8e6:	429a      	cmp	r2, r3
 800f8e8:	d329      	bcc.n	800f93e <UART_WaitOnFlagUntilTimeout+0x116>
        {
          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
          __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 800f8ea:	68fb      	ldr	r3, [r7, #12]
 800f8ec:	681b      	ldr	r3, [r3, #0]
 800f8ee:	68fa      	ldr	r2, [r7, #12]
 800f8f0:	6812      	ldr	r2, [r2, #0]
 800f8f2:	6812      	ldr	r2, [r2, #0]
 800f8f4:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800f8f8:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 800f8fa:	68fb      	ldr	r3, [r7, #12]
 800f8fc:	681b      	ldr	r3, [r3, #0]
 800f8fe:	68fa      	ldr	r2, [r7, #12]
 800f900:	6812      	ldr	r2, [r2, #0]
 800f902:	6812      	ldr	r2, [r2, #0]
 800f904:	f022 0220 	bic.w	r2, r2, #32
 800f908:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 800f90a:	68fb      	ldr	r3, [r7, #12]
 800f90c:	681b      	ldr	r3, [r3, #0]
 800f90e:	68fa      	ldr	r2, [r7, #12]
 800f910:	6812      	ldr	r2, [r2, #0]
 800f912:	6812      	ldr	r2, [r2, #0]
 800f914:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800f918:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 800f91a:	68fb      	ldr	r3, [r7, #12]
 800f91c:	681b      	ldr	r3, [r3, #0]
 800f91e:	68fa      	ldr	r2, [r7, #12]
 800f920:	6812      	ldr	r2, [r2, #0]
 800f922:	6892      	ldr	r2, [r2, #8]
 800f924:	f022 0201 	bic.w	r2, r2, #1
 800f928:	609a      	str	r2, [r3, #8]
          
          huart->State= HAL_UART_STATE_READY;
 800f92a:	68fb      	ldr	r3, [r7, #12]
 800f92c:	2201      	movs	r2, #1
 800f92e:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
          
          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 800f932:	68fb      	ldr	r3, [r7, #12]
 800f934:	2200      	movs	r2, #0
 800f936:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
          
          return HAL_TIMEOUT;
 800f93a:	2303      	movs	r3, #3
 800f93c:	e008      	b.n	800f950 <UART_WaitOnFlagUntilTimeout+0x128>
      }
    }
  }
  else
  {
    while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
 800f93e:	68fb      	ldr	r3, [r7, #12]
 800f940:	681b      	ldr	r3, [r3, #0]
 800f942:	69da      	ldr	r2, [r3, #28]
 800f944:	68bb      	ldr	r3, [r7, #8]
 800f946:	401a      	ands	r2, r3
 800f948:	68bb      	ldr	r3, [r7, #8]
 800f94a:	429a      	cmp	r2, r3
 800f94c:	d0be      	beq.n	800f8cc <UART_WaitOnFlagUntilTimeout+0xa4>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;      
 800f94e:	2300      	movs	r3, #0
}
 800f950:	4618      	mov	r0, r3
 800f952:	3718      	adds	r7, #24
 800f954:	46bd      	mov	sp, r7
 800f956:	bd80      	pop	{r7, pc}

0800f958 <UART_DMAReceiveCplt>:
  * @brief DMA UART receive process complete callback 
  * @param hdma: DMA handle
  * @retval None
  */
static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)  
{
 800f958:	b580      	push	{r7, lr}
 800f95a:	b084      	sub	sp, #16
 800f95c:	af00      	add	r7, sp, #0
 800f95e:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800f960:	687b      	ldr	r3, [r7, #4]
 800f962:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800f964:	60fb      	str	r3, [r7, #12]
  
  /* DMA Normal mode */
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 800f966:	687b      	ldr	r3, [r7, #4]
 800f968:	681b      	ldr	r3, [r3, #0]
 800f96a:	681b      	ldr	r3, [r3, #0]
 800f96c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800f970:	2b00      	cmp	r3, #0
 800f972:	d11a      	bne.n	800f9aa <UART_DMAReceiveCplt+0x52>
  { 
    huart->RxXferCount = 0;
 800f974:	68fb      	ldr	r3, [r7, #12]
 800f976:	2200      	movs	r2, #0
 800f978:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a
    
    /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
    in the UART CR3 register */
    huart->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DMAR);
 800f97c:	68fb      	ldr	r3, [r7, #12]
 800f97e:	681b      	ldr	r3, [r3, #0]
 800f980:	68fa      	ldr	r2, [r7, #12]
 800f982:	6812      	ldr	r2, [r2, #0]
 800f984:	6892      	ldr	r2, [r2, #8]
 800f986:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800f98a:	609a      	str	r2, [r3, #8]
    
    /* Check if a transmit Process is ongoing or not */
    if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
 800f98c:	68fb      	ldr	r3, [r7, #12]
 800f98e:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
 800f992:	b2db      	uxtb	r3, r3
 800f994:	2b32      	cmp	r3, #50	; 0x32
 800f996:	d104      	bne.n	800f9a2 <UART_DMAReceiveCplt+0x4a>
    {
      huart->State = HAL_UART_STATE_BUSY_TX;
 800f998:	68fb      	ldr	r3, [r7, #12]
 800f99a:	2212      	movs	r2, #18
 800f99c:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
 800f9a0:	e003      	b.n	800f9aa <UART_DMAReceiveCplt+0x52>
    }
    else
    {
      huart->State = HAL_UART_STATE_READY;
 800f9a2:	68fb      	ldr	r3, [r7, #12]
 800f9a4:	2201      	movs	r2, #1
 800f9a6:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
    }
  }
  HAL_UART_RxCpltCallback(huart);
 800f9aa:	68f8      	ldr	r0, [r7, #12]
 800f9ac:	f000 f832 	bl	800fa14 <HAL_UART_RxCpltCallback>
}
 800f9b0:	3710      	adds	r7, #16
 800f9b2:	46bd      	mov	sp, r7
 800f9b4:	bd80      	pop	{r7, pc}
 800f9b6:	bf00      	nop

0800f9b8 <UART_DMARxHalfCplt>:
  * @brief DMA UART receive process half complete callback 
  * @param hdma : DMA handle
  * @retval None
  */
static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
 800f9b8:	b580      	push	{r7, lr}
 800f9ba:	b084      	sub	sp, #16
 800f9bc:	af00      	add	r7, sp, #0
 800f9be:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
 800f9c0:	687b      	ldr	r3, [r7, #4]
 800f9c2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800f9c4:	60fb      	str	r3, [r7, #12]

  HAL_UART_RxHalfCpltCallback(huart); 
 800f9c6:	68f8      	ldr	r0, [r7, #12]
 800f9c8:	f000 f82e 	bl	800fa28 <HAL_UART_RxHalfCpltCallback>
}
 800f9cc:	3710      	adds	r7, #16
 800f9ce:	46bd      	mov	sp, r7
 800f9d0:	bd80      	pop	{r7, pc}
 800f9d2:	bf00      	nop

0800f9d4 <UART_DMAError>:
  * @brief DMA UART communication error callback 
  * @param hdma: DMA handle
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)   
{
 800f9d4:	b580      	push	{r7, lr}
 800f9d6:	b084      	sub	sp, #16
 800f9d8:	af00      	add	r7, sp, #0
 800f9da:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800f9dc:	687b      	ldr	r3, [r7, #4]
 800f9de:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800f9e0:	60fb      	str	r3, [r7, #12]
  huart->RxXferCount = 0;
 800f9e2:	68fb      	ldr	r3, [r7, #12]
 800f9e4:	2200      	movs	r2, #0
 800f9e6:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a
  huart->TxXferCount = 0;
 800f9ea:	68fb      	ldr	r3, [r7, #12]
 800f9ec:	2200      	movs	r2, #0
 800f9ee:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
  huart->State= HAL_UART_STATE_READY;
 800f9f2:	68fb      	ldr	r3, [r7, #12]
 800f9f4:	2201      	movs	r2, #1
 800f9f6:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 800f9fa:	68fb      	ldr	r3, [r7, #12]
 800f9fc:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800f9fe:	f043 0210 	orr.w	r2, r3, #16
 800fa02:	68fb      	ldr	r3, [r7, #12]
 800fa04:	66da      	str	r2, [r3, #108]	; 0x6c
  HAL_UART_ErrorCallback(huart);
 800fa06:	68f8      	ldr	r0, [r7, #12]
 800fa08:	f000 f818 	bl	800fa3c <HAL_UART_ErrorCallback>
}
 800fa0c:	3710      	adds	r7, #16
 800fa0e:	46bd      	mov	sp, r7
 800fa10:	bd80      	pop	{r7, pc}
 800fa12:	bf00      	nop

0800fa14 <HAL_UART_RxCpltCallback>:
  * @brief Rx Transfer completed callbacks
  * @param huart: uart handle
  * @retval None
  */
__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
 800fa14:	b480      	push	{r7}
 800fa16:	b083      	sub	sp, #12
 800fa18:	af00      	add	r7, sp, #0
 800fa1a:	6078      	str	r0, [r7, #4]
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_RxCpltCallback can be implemented in the user file
   */
}
 800fa1c:	370c      	adds	r7, #12
 800fa1e:	46bd      	mov	sp, r7
 800fa20:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fa24:	4770      	bx	lr
 800fa26:	bf00      	nop

0800fa28 <HAL_UART_RxHalfCpltCallback>:
  * @brief  Rx Half Transfer completed callbacks.
  * @param  huart: UART handle
  * @retval None
  */
__weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
{
 800fa28:	b480      	push	{r7}
 800fa2a:	b083      	sub	sp, #12
 800fa2c:	af00      	add	r7, sp, #0
 800fa2e:	6078      	str	r0, [r7, #4]
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_RxHalfCpltCallback can be implemented in the user file
   */
}
 800fa30:	370c      	adds	r7, #12
 800fa32:	46bd      	mov	sp, r7
 800fa34:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fa38:	4770      	bx	lr
 800fa3a:	bf00      	nop

0800fa3c <HAL_UART_ErrorCallback>:
  * @brief UART error callbacks
  * @param huart: uart handle
  * @retval None
  */
 __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 800fa3c:	b480      	push	{r7}
 800fa3e:	b083      	sub	sp, #12
 800fa40:	af00      	add	r7, sp, #0
 800fa42:	6078      	str	r0, [r7, #4]
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_ErrorCallback can be implemented in the user file
   */ 
}
 800fa44:	370c      	adds	r7, #12
 800fa46:	46bd      	mov	sp, r7
 800fa48:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fa4c:	4770      	bx	lr
 800fa4e:	bf00      	nop

0800fa50 <UART_SetConfig>:
  * @brief Configure the UART peripheral 
  * @param huart: uart handle
  * @retval None
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 800fa50:	b590      	push	{r4, r7, lr}
 800fa52:	b087      	sub	sp, #28
 800fa54:	af00      	add	r7, sp, #0
 800fa56:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg                     = 0x00000000;
 800fa58:	2300      	movs	r3, #0
 800fa5a:	60fb      	str	r3, [r7, #12]
  UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
 800fa5c:	2310      	movs	r3, #16
 800fa5e:	75fb      	strb	r3, [r7, #23]
  uint16_t brrtemp                    = 0x0000;
 800fa60:	2300      	movs	r3, #0
 800fa62:	817b      	strh	r3, [r7, #10]
  uint16_t usartdiv                   = 0x0000;
 800fa64:	2300      	movs	r3, #0
 800fa66:	82bb      	strh	r3, [r7, #20]
  HAL_StatusTypeDef ret               = HAL_OK;  
 800fa68:	2300      	movs	r3, #0
 800fa6a:	74fb      	strb	r3, [r7, #19]
   *  the UART Word Length, Parity, Mode and oversampling: 
   *  set the M bits according to huart->Init.WordLength value 
   *  set PCE and PS bits according to huart->Init.Parity value
   *  set TE and RE bits according to huart->Init.Mode value
   *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800fa6c:	687b      	ldr	r3, [r7, #4]
 800fa6e:	689a      	ldr	r2, [r3, #8]
 800fa70:	687b      	ldr	r3, [r7, #4]
 800fa72:	691b      	ldr	r3, [r3, #16]
 800fa74:	431a      	orrs	r2, r3
 800fa76:	687b      	ldr	r3, [r7, #4]
 800fa78:	695b      	ldr	r3, [r3, #20]
 800fa7a:	431a      	orrs	r2, r3
 800fa7c:	687b      	ldr	r3, [r7, #4]
 800fa7e:	69db      	ldr	r3, [r3, #28]
 800fa80:	4313      	orrs	r3, r2
 800fa82:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 800fa84:	687b      	ldr	r3, [r7, #4]
 800fa86:	681a      	ldr	r2, [r3, #0]
 800fa88:	687b      	ldr	r3, [r7, #4]
 800fa8a:	681b      	ldr	r3, [r3, #0]
 800fa8c:	6819      	ldr	r1, [r3, #0]
 800fa8e:	4bac      	ldr	r3, [pc, #688]	; (800fd40 <UART_SetConfig+0x2f0>)
 800fa90:	400b      	ands	r3, r1
 800fa92:	68f9      	ldr	r1, [r7, #12]
 800fa94:	430b      	orrs	r3, r1
 800fa96:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
   * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800fa98:	687b      	ldr	r3, [r7, #4]
 800fa9a:	681b      	ldr	r3, [r3, #0]
 800fa9c:	687a      	ldr	r2, [r7, #4]
 800fa9e:	6812      	ldr	r2, [r2, #0]
 800faa0:	6852      	ldr	r2, [r2, #4]
 800faa2:	f422 5140 	bic.w	r1, r2, #12288	; 0x3000
 800faa6:	687a      	ldr	r2, [r7, #4]
 800faa8:	68d2      	ldr	r2, [r2, #12]
 800faaa:	430a      	orrs	r2, r1
 800faac:	605a      	str	r2, [r3, #4]
  /* Configure 
   * - UART HardWare Flow Control: set CTSE and RTSE bits according 
   *   to huart->Init.HwFlowCtl value 
   * - one-bit sampling method versus three samples' majority rule according
   *   to huart->Init.OneBitSampling */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 800faae:	687b      	ldr	r3, [r7, #4]
 800fab0:	699a      	ldr	r2, [r3, #24]
 800fab2:	687b      	ldr	r3, [r7, #4]
 800fab4:	6a1b      	ldr	r3, [r3, #32]
 800fab6:	4313      	orrs	r3, r2
 800fab8:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 800faba:	687b      	ldr	r3, [r7, #4]
 800fabc:	681b      	ldr	r3, [r3, #0]
 800fabe:	687a      	ldr	r2, [r7, #4]
 800fac0:	6812      	ldr	r2, [r2, #0]
 800fac2:	6892      	ldr	r2, [r2, #8]
 800fac4:	f422 6130 	bic.w	r1, r2, #2816	; 0xb00
 800fac8:	68fa      	ldr	r2, [r7, #12]
 800faca:	430a      	orrs	r2, r1
 800facc:	609a      	str	r2, [r3, #8]
  
  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 800face:	687b      	ldr	r3, [r7, #4]
 800fad0:	681b      	ldr	r3, [r3, #0]
 800fad2:	4a9c      	ldr	r2, [pc, #624]	; (800fd44 <UART_SetConfig+0x2f4>)
 800fad4:	4293      	cmp	r3, r2
 800fad6:	d11e      	bne.n	800fb16 <UART_SetConfig+0xc6>
 800fad8:	4b9b      	ldr	r3, [pc, #620]	; (800fd48 <UART_SetConfig+0x2f8>)
 800fada:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800fade:	f003 0303 	and.w	r3, r3, #3
 800fae2:	2b03      	cmp	r3, #3
 800fae4:	d815      	bhi.n	800fb12 <UART_SetConfig+0xc2>
 800fae6:	a201      	add	r2, pc, #4	; (adr r2, 800faec <UART_SetConfig+0x9c>)
 800fae8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800faec:	0800fafd 	.word	0x0800fafd
 800faf0:	0800fb09 	.word	0x0800fb09
 800faf4:	0800fb03 	.word	0x0800fb03
 800faf8:	0800fb0f 	.word	0x0800fb0f
 800fafc:	2301      	movs	r3, #1
 800fafe:	75fb      	strb	r3, [r7, #23]
 800fb00:	e007      	b.n	800fb12 <UART_SetConfig+0xc2>
 800fb02:	2302      	movs	r3, #2
 800fb04:	75fb      	strb	r3, [r7, #23]
 800fb06:	e004      	b.n	800fb12 <UART_SetConfig+0xc2>
 800fb08:	2304      	movs	r3, #4
 800fb0a:	75fb      	strb	r3, [r7, #23]
 800fb0c:	e001      	b.n	800fb12 <UART_SetConfig+0xc2>
 800fb0e:	2308      	movs	r3, #8
 800fb10:	75fb      	strb	r3, [r7, #23]
 800fb12:	bf00      	nop
 800fb14:	e12b      	b.n	800fd6e <UART_SetConfig+0x31e>
 800fb16:	687b      	ldr	r3, [r7, #4]
 800fb18:	681b      	ldr	r3, [r3, #0]
 800fb1a:	4a8c      	ldr	r2, [pc, #560]	; (800fd4c <UART_SetConfig+0x2fc>)
 800fb1c:	4293      	cmp	r3, r2
 800fb1e:	d130      	bne.n	800fb82 <UART_SetConfig+0x132>
 800fb20:	4b89      	ldr	r3, [pc, #548]	; (800fd48 <UART_SetConfig+0x2f8>)
 800fb22:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800fb26:	f003 030c 	and.w	r3, r3, #12
 800fb2a:	2b0c      	cmp	r3, #12
 800fb2c:	d827      	bhi.n	800fb7e <UART_SetConfig+0x12e>
 800fb2e:	a201      	add	r2, pc, #4	; (adr r2, 800fb34 <UART_SetConfig+0xe4>)
 800fb30:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800fb34:	0800fb69 	.word	0x0800fb69
 800fb38:	0800fb7f 	.word	0x0800fb7f
 800fb3c:	0800fb7f 	.word	0x0800fb7f
 800fb40:	0800fb7f 	.word	0x0800fb7f
 800fb44:	0800fb75 	.word	0x0800fb75
 800fb48:	0800fb7f 	.word	0x0800fb7f
 800fb4c:	0800fb7f 	.word	0x0800fb7f
 800fb50:	0800fb7f 	.word	0x0800fb7f
 800fb54:	0800fb6f 	.word	0x0800fb6f
 800fb58:	0800fb7f 	.word	0x0800fb7f
 800fb5c:	0800fb7f 	.word	0x0800fb7f
 800fb60:	0800fb7f 	.word	0x0800fb7f
 800fb64:	0800fb7b 	.word	0x0800fb7b
 800fb68:	2300      	movs	r3, #0
 800fb6a:	75fb      	strb	r3, [r7, #23]
 800fb6c:	e007      	b.n	800fb7e <UART_SetConfig+0x12e>
 800fb6e:	2302      	movs	r3, #2
 800fb70:	75fb      	strb	r3, [r7, #23]
 800fb72:	e004      	b.n	800fb7e <UART_SetConfig+0x12e>
 800fb74:	2304      	movs	r3, #4
 800fb76:	75fb      	strb	r3, [r7, #23]
 800fb78:	e001      	b.n	800fb7e <UART_SetConfig+0x12e>
 800fb7a:	2308      	movs	r3, #8
 800fb7c:	75fb      	strb	r3, [r7, #23]
 800fb7e:	bf00      	nop
 800fb80:	e0f5      	b.n	800fd6e <UART_SetConfig+0x31e>
 800fb82:	687b      	ldr	r3, [r7, #4]
 800fb84:	681b      	ldr	r3, [r3, #0]
 800fb86:	4a72      	ldr	r2, [pc, #456]	; (800fd50 <UART_SetConfig+0x300>)
 800fb88:	4293      	cmp	r3, r2
 800fb8a:	d11d      	bne.n	800fbc8 <UART_SetConfig+0x178>
 800fb8c:	4b6e      	ldr	r3, [pc, #440]	; (800fd48 <UART_SetConfig+0x2f8>)
 800fb8e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800fb92:	f003 0330 	and.w	r3, r3, #48	; 0x30
 800fb96:	2b10      	cmp	r3, #16
 800fb98:	d00f      	beq.n	800fbba <UART_SetConfig+0x16a>
 800fb9a:	2b10      	cmp	r3, #16
 800fb9c:	d802      	bhi.n	800fba4 <UART_SetConfig+0x154>
 800fb9e:	2b00      	cmp	r3, #0
 800fba0:	d005      	beq.n	800fbae <UART_SetConfig+0x15e>
 800fba2:	e00f      	b.n	800fbc4 <UART_SetConfig+0x174>
 800fba4:	2b20      	cmp	r3, #32
 800fba6:	d005      	beq.n	800fbb4 <UART_SetConfig+0x164>
 800fba8:	2b30      	cmp	r3, #48	; 0x30
 800fbaa:	d009      	beq.n	800fbc0 <UART_SetConfig+0x170>
 800fbac:	e00a      	b.n	800fbc4 <UART_SetConfig+0x174>
 800fbae:	2300      	movs	r3, #0
 800fbb0:	75fb      	strb	r3, [r7, #23]
 800fbb2:	e007      	b.n	800fbc4 <UART_SetConfig+0x174>
 800fbb4:	2302      	movs	r3, #2
 800fbb6:	75fb      	strb	r3, [r7, #23]
 800fbb8:	e004      	b.n	800fbc4 <UART_SetConfig+0x174>
 800fbba:	2304      	movs	r3, #4
 800fbbc:	75fb      	strb	r3, [r7, #23]
 800fbbe:	e001      	b.n	800fbc4 <UART_SetConfig+0x174>
 800fbc0:	2308      	movs	r3, #8
 800fbc2:	75fb      	strb	r3, [r7, #23]
 800fbc4:	bf00      	nop
 800fbc6:	e0d2      	b.n	800fd6e <UART_SetConfig+0x31e>
 800fbc8:	687b      	ldr	r3, [r7, #4]
 800fbca:	681b      	ldr	r3, [r3, #0]
 800fbcc:	4a61      	ldr	r2, [pc, #388]	; (800fd54 <UART_SetConfig+0x304>)
 800fbce:	4293      	cmp	r3, r2
 800fbd0:	d11d      	bne.n	800fc0e <UART_SetConfig+0x1be>
 800fbd2:	4b5d      	ldr	r3, [pc, #372]	; (800fd48 <UART_SetConfig+0x2f8>)
 800fbd4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800fbd8:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 800fbdc:	2b40      	cmp	r3, #64	; 0x40
 800fbde:	d00f      	beq.n	800fc00 <UART_SetConfig+0x1b0>
 800fbe0:	2b40      	cmp	r3, #64	; 0x40
 800fbe2:	d802      	bhi.n	800fbea <UART_SetConfig+0x19a>
 800fbe4:	2b00      	cmp	r3, #0
 800fbe6:	d005      	beq.n	800fbf4 <UART_SetConfig+0x1a4>
 800fbe8:	e00f      	b.n	800fc0a <UART_SetConfig+0x1ba>
 800fbea:	2b80      	cmp	r3, #128	; 0x80
 800fbec:	d005      	beq.n	800fbfa <UART_SetConfig+0x1aa>
 800fbee:	2bc0      	cmp	r3, #192	; 0xc0
 800fbf0:	d009      	beq.n	800fc06 <UART_SetConfig+0x1b6>
 800fbf2:	e00a      	b.n	800fc0a <UART_SetConfig+0x1ba>
 800fbf4:	2300      	movs	r3, #0
 800fbf6:	75fb      	strb	r3, [r7, #23]
 800fbf8:	e007      	b.n	800fc0a <UART_SetConfig+0x1ba>
 800fbfa:	2302      	movs	r3, #2
 800fbfc:	75fb      	strb	r3, [r7, #23]
 800fbfe:	e004      	b.n	800fc0a <UART_SetConfig+0x1ba>
 800fc00:	2304      	movs	r3, #4
 800fc02:	75fb      	strb	r3, [r7, #23]
 800fc04:	e001      	b.n	800fc0a <UART_SetConfig+0x1ba>
 800fc06:	2308      	movs	r3, #8
 800fc08:	75fb      	strb	r3, [r7, #23]
 800fc0a:	bf00      	nop
 800fc0c:	e0af      	b.n	800fd6e <UART_SetConfig+0x31e>
 800fc0e:	687b      	ldr	r3, [r7, #4]
 800fc10:	681b      	ldr	r3, [r3, #0]
 800fc12:	4a51      	ldr	r2, [pc, #324]	; (800fd58 <UART_SetConfig+0x308>)
 800fc14:	4293      	cmp	r3, r2
 800fc16:	d121      	bne.n	800fc5c <UART_SetConfig+0x20c>
 800fc18:	4b4b      	ldr	r3, [pc, #300]	; (800fd48 <UART_SetConfig+0x2f8>)
 800fc1a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800fc1e:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800fc22:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800fc26:	d012      	beq.n	800fc4e <UART_SetConfig+0x1fe>
 800fc28:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800fc2c:	d802      	bhi.n	800fc34 <UART_SetConfig+0x1e4>
 800fc2e:	2b00      	cmp	r3, #0
 800fc30:	d007      	beq.n	800fc42 <UART_SetConfig+0x1f2>
 800fc32:	e011      	b.n	800fc58 <UART_SetConfig+0x208>
 800fc34:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800fc38:	d006      	beq.n	800fc48 <UART_SetConfig+0x1f8>
 800fc3a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800fc3e:	d009      	beq.n	800fc54 <UART_SetConfig+0x204>
 800fc40:	e00a      	b.n	800fc58 <UART_SetConfig+0x208>
 800fc42:	2300      	movs	r3, #0
 800fc44:	75fb      	strb	r3, [r7, #23]
 800fc46:	e007      	b.n	800fc58 <UART_SetConfig+0x208>
 800fc48:	2302      	movs	r3, #2
 800fc4a:	75fb      	strb	r3, [r7, #23]
 800fc4c:	e004      	b.n	800fc58 <UART_SetConfig+0x208>
 800fc4e:	2304      	movs	r3, #4
 800fc50:	75fb      	strb	r3, [r7, #23]
 800fc52:	e001      	b.n	800fc58 <UART_SetConfig+0x208>
 800fc54:	2308      	movs	r3, #8
 800fc56:	75fb      	strb	r3, [r7, #23]
 800fc58:	bf00      	nop
 800fc5a:	e088      	b.n	800fd6e <UART_SetConfig+0x31e>
 800fc5c:	687b      	ldr	r3, [r7, #4]
 800fc5e:	681b      	ldr	r3, [r3, #0]
 800fc60:	4a3e      	ldr	r2, [pc, #248]	; (800fd5c <UART_SetConfig+0x30c>)
 800fc62:	4293      	cmp	r3, r2
 800fc64:	d121      	bne.n	800fcaa <UART_SetConfig+0x25a>
 800fc66:	4b38      	ldr	r3, [pc, #224]	; (800fd48 <UART_SetConfig+0x2f8>)
 800fc68:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800fc6c:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 800fc70:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800fc74:	d012      	beq.n	800fc9c <UART_SetConfig+0x24c>
 800fc76:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800fc7a:	d802      	bhi.n	800fc82 <UART_SetConfig+0x232>
 800fc7c:	2b00      	cmp	r3, #0
 800fc7e:	d007      	beq.n	800fc90 <UART_SetConfig+0x240>
 800fc80:	e011      	b.n	800fca6 <UART_SetConfig+0x256>
 800fc82:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800fc86:	d006      	beq.n	800fc96 <UART_SetConfig+0x246>
 800fc88:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800fc8c:	d009      	beq.n	800fca2 <UART_SetConfig+0x252>
 800fc8e:	e00a      	b.n	800fca6 <UART_SetConfig+0x256>
 800fc90:	2301      	movs	r3, #1
 800fc92:	75fb      	strb	r3, [r7, #23]
 800fc94:	e007      	b.n	800fca6 <UART_SetConfig+0x256>
 800fc96:	2302      	movs	r3, #2
 800fc98:	75fb      	strb	r3, [r7, #23]
 800fc9a:	e004      	b.n	800fca6 <UART_SetConfig+0x256>
 800fc9c:	2304      	movs	r3, #4
 800fc9e:	75fb      	strb	r3, [r7, #23]
 800fca0:	e001      	b.n	800fca6 <UART_SetConfig+0x256>
 800fca2:	2308      	movs	r3, #8
 800fca4:	75fb      	strb	r3, [r7, #23]
 800fca6:	bf00      	nop
 800fca8:	e061      	b.n	800fd6e <UART_SetConfig+0x31e>
 800fcaa:	687b      	ldr	r3, [r7, #4]
 800fcac:	681b      	ldr	r3, [r3, #0]
 800fcae:	4a2c      	ldr	r2, [pc, #176]	; (800fd60 <UART_SetConfig+0x310>)
 800fcb0:	4293      	cmp	r3, r2
 800fcb2:	d121      	bne.n	800fcf8 <UART_SetConfig+0x2a8>
 800fcb4:	4b24      	ldr	r3, [pc, #144]	; (800fd48 <UART_SetConfig+0x2f8>)
 800fcb6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800fcba:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 800fcbe:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800fcc2:	d012      	beq.n	800fcea <UART_SetConfig+0x29a>
 800fcc4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800fcc8:	d802      	bhi.n	800fcd0 <UART_SetConfig+0x280>
 800fcca:	2b00      	cmp	r3, #0
 800fccc:	d007      	beq.n	800fcde <UART_SetConfig+0x28e>
 800fcce:	e011      	b.n	800fcf4 <UART_SetConfig+0x2a4>
 800fcd0:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800fcd4:	d006      	beq.n	800fce4 <UART_SetConfig+0x294>
 800fcd6:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 800fcda:	d009      	beq.n	800fcf0 <UART_SetConfig+0x2a0>
 800fcdc:	e00a      	b.n	800fcf4 <UART_SetConfig+0x2a4>
 800fcde:	2300      	movs	r3, #0
 800fce0:	75fb      	strb	r3, [r7, #23]
 800fce2:	e007      	b.n	800fcf4 <UART_SetConfig+0x2a4>
 800fce4:	2302      	movs	r3, #2
 800fce6:	75fb      	strb	r3, [r7, #23]
 800fce8:	e004      	b.n	800fcf4 <UART_SetConfig+0x2a4>
 800fcea:	2304      	movs	r3, #4
 800fcec:	75fb      	strb	r3, [r7, #23]
 800fcee:	e001      	b.n	800fcf4 <UART_SetConfig+0x2a4>
 800fcf0:	2308      	movs	r3, #8
 800fcf2:	75fb      	strb	r3, [r7, #23]
 800fcf4:	bf00      	nop
 800fcf6:	e03a      	b.n	800fd6e <UART_SetConfig+0x31e>
 800fcf8:	687b      	ldr	r3, [r7, #4]
 800fcfa:	681b      	ldr	r3, [r3, #0]
 800fcfc:	4a19      	ldr	r2, [pc, #100]	; (800fd64 <UART_SetConfig+0x314>)
 800fcfe:	4293      	cmp	r3, r2
 800fd00:	d135      	bne.n	800fd6e <UART_SetConfig+0x31e>
 800fd02:	4b11      	ldr	r3, [pc, #68]	; (800fd48 <UART_SetConfig+0x2f8>)
 800fd04:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800fd08:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 800fd0c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800fd10:	d012      	beq.n	800fd38 <UART_SetConfig+0x2e8>
 800fd12:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800fd16:	d802      	bhi.n	800fd1e <UART_SetConfig+0x2ce>
 800fd18:	2b00      	cmp	r3, #0
 800fd1a:	d007      	beq.n	800fd2c <UART_SetConfig+0x2dc>
 800fd1c:	e026      	b.n	800fd6c <UART_SetConfig+0x31c>
 800fd1e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800fd22:	d006      	beq.n	800fd32 <UART_SetConfig+0x2e2>
 800fd24:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 800fd28:	d01e      	beq.n	800fd68 <UART_SetConfig+0x318>
 800fd2a:	e01f      	b.n	800fd6c <UART_SetConfig+0x31c>
 800fd2c:	2300      	movs	r3, #0
 800fd2e:	75fb      	strb	r3, [r7, #23]
 800fd30:	e01c      	b.n	800fd6c <UART_SetConfig+0x31c>
 800fd32:	2302      	movs	r3, #2
 800fd34:	75fb      	strb	r3, [r7, #23]
 800fd36:	e019      	b.n	800fd6c <UART_SetConfig+0x31c>
 800fd38:	2304      	movs	r3, #4
 800fd3a:	75fb      	strb	r3, [r7, #23]
 800fd3c:	e016      	b.n	800fd6c <UART_SetConfig+0x31c>
 800fd3e:	bf00      	nop
 800fd40:	efff69f3 	.word	0xefff69f3
 800fd44:	40011000 	.word	0x40011000
 800fd48:	40023800 	.word	0x40023800
 800fd4c:	40004400 	.word	0x40004400
 800fd50:	40004800 	.word	0x40004800
 800fd54:	40004c00 	.word	0x40004c00
 800fd58:	40005000 	.word	0x40005000
 800fd5c:	40011400 	.word	0x40011400
 800fd60:	40007800 	.word	0x40007800
 800fd64:	40007c00 	.word	0x40007c00
 800fd68:	2308      	movs	r3, #8
 800fd6a:	75fb      	strb	r3, [r7, #23]
 800fd6c:	bf00      	nop

  /* Check UART Over Sampling to set Baud Rate Register */
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800fd6e:	687b      	ldr	r3, [r7, #4]
 800fd70:	69db      	ldr	r3, [r3, #28]
 800fd72:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800fd76:	d158      	bne.n	800fe2a <UART_SetConfig+0x3da>
  { 
    switch (clocksource)
 800fd78:	7dfb      	ldrb	r3, [r7, #23]
 800fd7a:	2b08      	cmp	r3, #8
 800fd7c:	d841      	bhi.n	800fe02 <UART_SetConfig+0x3b2>
 800fd7e:	a201      	add	r2, pc, #4	; (adr r2, 800fd84 <UART_SetConfig+0x334>)
 800fd80:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800fd84:	0800fda9 	.word	0x0800fda9
 800fd88:	0800fdbd 	.word	0x0800fdbd
 800fd8c:	0800fdd1 	.word	0x0800fdd1
 800fd90:	0800fe03 	.word	0x0800fe03
 800fd94:	0800fddf 	.word	0x0800fddf
 800fd98:	0800fe03 	.word	0x0800fe03
 800fd9c:	0800fe03 	.word	0x0800fe03
 800fda0:	0800fe03 	.word	0x0800fe03
 800fda4:	0800fdf3 	.word	0x0800fdf3
    {
    case UART_CLOCKSOURCE_PCLK1:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 800fda8:	f7fe fb14 	bl	800e3d4 <HAL_RCC_GetPCLK1Freq>
 800fdac:	4603      	mov	r3, r0
 800fdae:	005a      	lsls	r2, r3, #1
 800fdb0:	687b      	ldr	r3, [r7, #4]
 800fdb2:	685b      	ldr	r3, [r3, #4]
 800fdb4:	fbb2 f3f3 	udiv	r3, r2, r3
 800fdb8:	82bb      	strh	r3, [r7, #20]
      break;
 800fdba:	e025      	b.n	800fe08 <UART_SetConfig+0x3b8>
    case UART_CLOCKSOURCE_PCLK2:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 800fdbc:	f7fe fb2c 	bl	800e418 <HAL_RCC_GetPCLK2Freq>
 800fdc0:	4603      	mov	r3, r0
 800fdc2:	005a      	lsls	r2, r3, #1
 800fdc4:	687b      	ldr	r3, [r7, #4]
 800fdc6:	685b      	ldr	r3, [r3, #4]
 800fdc8:	fbb2 f3f3 	udiv	r3, r2, r3
 800fdcc:	82bb      	strh	r3, [r7, #20]
      break;
 800fdce:	e01b      	b.n	800fe08 <UART_SetConfig+0x3b8>
    case UART_CLOCKSOURCE_HSI:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate)); 
 800fdd0:	687b      	ldr	r3, [r7, #4]
 800fdd2:	685b      	ldr	r3, [r3, #4]
 800fdd4:	4a42      	ldr	r2, [pc, #264]	; (800fee0 <UART_SetConfig+0x490>)
 800fdd6:	fbb2 f3f3 	udiv	r3, r2, r3
 800fdda:	82bb      	strh	r3, [r7, #20]
      break;
 800fddc:	e014      	b.n	800fe08 <UART_SetConfig+0x3b8>
    case UART_CLOCKSOURCE_SYSCLK:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800fdde:	f7fe fa53 	bl	800e288 <HAL_RCC_GetSysClockFreq>
 800fde2:	4603      	mov	r3, r0
 800fde4:	005a      	lsls	r2, r3, #1
 800fde6:	687b      	ldr	r3, [r7, #4]
 800fde8:	685b      	ldr	r3, [r3, #4]
 800fdea:	fbb2 f3f3 	udiv	r3, r2, r3
 800fdee:	82bb      	strh	r3, [r7, #20]
      break;
 800fdf0:	e00a      	b.n	800fe08 <UART_SetConfig+0x3b8>
    case UART_CLOCKSOURCE_LSE:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate)); 
 800fdf2:	687b      	ldr	r3, [r7, #4]
 800fdf4:	685b      	ldr	r3, [r3, #4]
 800fdf6:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800fdfa:	fbb2 f3f3 	udiv	r3, r2, r3
 800fdfe:	82bb      	strh	r3, [r7, #20]
      break;
 800fe00:	e002      	b.n	800fe08 <UART_SetConfig+0x3b8>
      case UART_CLOCKSOURCE_UNDEFINED:                
    default:
        ret = HAL_ERROR; 
 800fe02:	2301      	movs	r3, #1
 800fe04:	74fb      	strb	r3, [r7, #19]
      break;
 800fe06:	bf00      	nop
    }
    
    brrtemp = usartdiv & 0xFFF0;
 800fe08:	8abb      	ldrh	r3, [r7, #20]
 800fe0a:	f023 030f 	bic.w	r3, r3, #15
 800fe0e:	817b      	strh	r3, [r7, #10]
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000F) >> 1U);
 800fe10:	8abb      	ldrh	r3, [r7, #20]
 800fe12:	f003 030f 	and.w	r3, r3, #15
 800fe16:	105b      	asrs	r3, r3, #1
 800fe18:	b29a      	uxth	r2, r3
 800fe1a:	897b      	ldrh	r3, [r7, #10]
 800fe1c:	4313      	orrs	r3, r2
 800fe1e:	817b      	strh	r3, [r7, #10]
    huart->Instance->BRR = brrtemp;
 800fe20:	687b      	ldr	r3, [r7, #4]
 800fe22:	681b      	ldr	r3, [r3, #0]
 800fe24:	897a      	ldrh	r2, [r7, #10]
 800fe26:	60da      	str	r2, [r3, #12]
 800fe28:	e054      	b.n	800fed4 <UART_SetConfig+0x484>
  }
  else
  {
    switch (clocksource)
 800fe2a:	7dfb      	ldrb	r3, [r7, #23]
 800fe2c:	2b08      	cmp	r3, #8
 800fe2e:	d84e      	bhi.n	800fece <UART_SetConfig+0x47e>
 800fe30:	a201      	add	r2, pc, #4	; (adr r2, 800fe38 <UART_SetConfig+0x3e8>)
 800fe32:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800fe36:	bf00      	nop
 800fe38:	0800fe5d 	.word	0x0800fe5d
 800fe3c:	0800fe75 	.word	0x0800fe75
 800fe40:	0800fe8d 	.word	0x0800fe8d
 800fe44:	0800fecf 	.word	0x0800fecf
 800fe48:	0800fea1 	.word	0x0800fea1
 800fe4c:	0800fecf 	.word	0x0800fecf
 800fe50:	0800fecf 	.word	0x0800fecf
 800fe54:	0800fecf 	.word	0x0800fecf
 800fe58:	0800feb9 	.word	0x0800feb9
    {
    case UART_CLOCKSOURCE_PCLK1: 
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 800fe5c:	687b      	ldr	r3, [r7, #4]
 800fe5e:	681c      	ldr	r4, [r3, #0]
 800fe60:	f7fe fab8 	bl	800e3d4 <HAL_RCC_GetPCLK1Freq>
 800fe64:	4602      	mov	r2, r0
 800fe66:	687b      	ldr	r3, [r7, #4]
 800fe68:	685b      	ldr	r3, [r3, #4]
 800fe6a:	fbb2 f3f3 	udiv	r3, r2, r3
 800fe6e:	b29b      	uxth	r3, r3
 800fe70:	60e3      	str	r3, [r4, #12]
      break;
 800fe72:	e02f      	b.n	800fed4 <UART_SetConfig+0x484>
    case UART_CLOCKSOURCE_PCLK2: 
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 800fe74:	687b      	ldr	r3, [r7, #4]
 800fe76:	681c      	ldr	r4, [r3, #0]
 800fe78:	f7fe face 	bl	800e418 <HAL_RCC_GetPCLK2Freq>
 800fe7c:	4602      	mov	r2, r0
 800fe7e:	687b      	ldr	r3, [r7, #4]
 800fe80:	685b      	ldr	r3, [r3, #4]
 800fe82:	fbb2 f3f3 	udiv	r3, r2, r3
 800fe86:	b29b      	uxth	r3, r3
 800fe88:	60e3      	str	r3, [r4, #12]
      break;
 800fe8a:	e023      	b.n	800fed4 <UART_SetConfig+0x484>
    case UART_CLOCKSOURCE_HSI: 
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate)); 
 800fe8c:	687b      	ldr	r3, [r7, #4]
 800fe8e:	681b      	ldr	r3, [r3, #0]
 800fe90:	687a      	ldr	r2, [r7, #4]
 800fe92:	6852      	ldr	r2, [r2, #4]
 800fe94:	4913      	ldr	r1, [pc, #76]	; (800fee4 <UART_SetConfig+0x494>)
 800fe96:	fbb1 f2f2 	udiv	r2, r1, r2
 800fe9a:	b292      	uxth	r2, r2
 800fe9c:	60da      	str	r2, [r3, #12]
      break; 
 800fe9e:	e019      	b.n	800fed4 <UART_SetConfig+0x484>
    case UART_CLOCKSOURCE_SYSCLK:  
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800fea0:	687b      	ldr	r3, [r7, #4]
 800fea2:	681c      	ldr	r4, [r3, #0]
 800fea4:	f7fe f9f0 	bl	800e288 <HAL_RCC_GetSysClockFreq>
 800fea8:	4602      	mov	r2, r0
 800feaa:	687b      	ldr	r3, [r7, #4]
 800feac:	685b      	ldr	r3, [r3, #4]
 800feae:	fbb2 f3f3 	udiv	r3, r2, r3
 800feb2:	b29b      	uxth	r3, r3
 800feb4:	60e3      	str	r3, [r4, #12]
      break;  
 800feb6:	e00d      	b.n	800fed4 <UART_SetConfig+0x484>
    case UART_CLOCKSOURCE_LSE:
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate)); 
 800feb8:	687b      	ldr	r3, [r7, #4]
 800feba:	681b      	ldr	r3, [r3, #0]
 800febc:	687a      	ldr	r2, [r7, #4]
 800febe:	6852      	ldr	r2, [r2, #4]
 800fec0:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800fec4:	fbb1 f2f2 	udiv	r2, r1, r2
 800fec8:	b292      	uxth	r2, r2
 800feca:	60da      	str	r2, [r3, #12]
      break;
 800fecc:	e002      	b.n	800fed4 <UART_SetConfig+0x484>
      case UART_CLOCKSOURCE_UNDEFINED:                
    default:
        ret = HAL_ERROR; 
 800fece:	2301      	movs	r3, #1
 800fed0:	74fb      	strb	r3, [r7, #19]
      break;
 800fed2:	bf00      	nop
    }
  }

  return ret;   
 800fed4:	7cfb      	ldrb	r3, [r7, #19]

}
 800fed6:	4618      	mov	r0, r3
 800fed8:	371c      	adds	r7, #28
 800feda:	46bd      	mov	sp, r7
 800fedc:	bd90      	pop	{r4, r7, pc}
 800fede:	bf00      	nop
 800fee0:	01e84800 	.word	0x01e84800
 800fee4:	00f42400 	.word	0x00f42400

0800fee8 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features 
  * @param huart: uart handle  
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 800fee8:	b480      	push	{r7}
 800feea:	b083      	sub	sp, #12
 800feec:	af00      	add	r7, sp, #0
 800feee:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */ 
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
  
  /* if required, configure TX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800fef0:	687b      	ldr	r3, [r7, #4]
 800fef2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800fef4:	f003 0301 	and.w	r3, r3, #1
 800fef8:	2b00      	cmp	r3, #0
 800fefa:	d00a      	beq.n	800ff12 <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 800fefc:	687b      	ldr	r3, [r7, #4]
 800fefe:	681b      	ldr	r3, [r3, #0]
 800ff00:	687a      	ldr	r2, [r7, #4]
 800ff02:	6812      	ldr	r2, [r2, #0]
 800ff04:	6852      	ldr	r2, [r2, #4]
 800ff06:	f422 3100 	bic.w	r1, r2, #131072	; 0x20000
 800ff0a:	687a      	ldr	r2, [r7, #4]
 800ff0c:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800ff0e:	430a      	orrs	r2, r1
 800ff10:	605a      	str	r2, [r3, #4]
  }
  
  /* if required, configure RX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800ff12:	687b      	ldr	r3, [r7, #4]
 800ff14:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ff16:	f003 0302 	and.w	r3, r3, #2
 800ff1a:	2b00      	cmp	r3, #0
 800ff1c:	d00a      	beq.n	800ff34 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800ff1e:	687b      	ldr	r3, [r7, #4]
 800ff20:	681b      	ldr	r3, [r3, #0]
 800ff22:	687a      	ldr	r2, [r7, #4]
 800ff24:	6812      	ldr	r2, [r2, #0]
 800ff26:	6852      	ldr	r2, [r2, #4]
 800ff28:	f422 3180 	bic.w	r1, r2, #65536	; 0x10000
 800ff2c:	687a      	ldr	r2, [r7, #4]
 800ff2e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800ff30:	430a      	orrs	r2, r1
 800ff32:	605a      	str	r2, [r3, #4]
  }
  
  /* if required, configure data inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800ff34:	687b      	ldr	r3, [r7, #4]
 800ff36:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ff38:	f003 0304 	and.w	r3, r3, #4
 800ff3c:	2b00      	cmp	r3, #0
 800ff3e:	d00a      	beq.n	800ff56 <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800ff40:	687b      	ldr	r3, [r7, #4]
 800ff42:	681b      	ldr	r3, [r3, #0]
 800ff44:	687a      	ldr	r2, [r7, #4]
 800ff46:	6812      	ldr	r2, [r2, #0]
 800ff48:	6852      	ldr	r2, [r2, #4]
 800ff4a:	f422 2180 	bic.w	r1, r2, #262144	; 0x40000
 800ff4e:	687a      	ldr	r2, [r7, #4]
 800ff50:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800ff52:	430a      	orrs	r2, r1
 800ff54:	605a      	str	r2, [r3, #4]
  }
  
  /* if required, configure RX/TX pins swap */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800ff56:	687b      	ldr	r3, [r7, #4]
 800ff58:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ff5a:	f003 0308 	and.w	r3, r3, #8
 800ff5e:	2b00      	cmp	r3, #0
 800ff60:	d00a      	beq.n	800ff78 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800ff62:	687b      	ldr	r3, [r7, #4]
 800ff64:	681b      	ldr	r3, [r3, #0]
 800ff66:	687a      	ldr	r2, [r7, #4]
 800ff68:	6812      	ldr	r2, [r2, #0]
 800ff6a:	6852      	ldr	r2, [r2, #4]
 800ff6c:	f422 4100 	bic.w	r1, r2, #32768	; 0x8000
 800ff70:	687a      	ldr	r2, [r7, #4]
 800ff72:	6b52      	ldr	r2, [r2, #52]	; 0x34
 800ff74:	430a      	orrs	r2, r1
 800ff76:	605a      	str	r2, [r3, #4]
  }
  
  /* if required, configure RX overrun detection disabling */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800ff78:	687b      	ldr	r3, [r7, #4]
 800ff7a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ff7c:	f003 0310 	and.w	r3, r3, #16
 800ff80:	2b00      	cmp	r3, #0
 800ff82:	d00a      	beq.n	800ff9a <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));  
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800ff84:	687b      	ldr	r3, [r7, #4]
 800ff86:	681b      	ldr	r3, [r3, #0]
 800ff88:	687a      	ldr	r2, [r7, #4]
 800ff8a:	6812      	ldr	r2, [r2, #0]
 800ff8c:	6892      	ldr	r2, [r2, #8]
 800ff8e:	f422 5180 	bic.w	r1, r2, #4096	; 0x1000
 800ff92:	687a      	ldr	r2, [r7, #4]
 800ff94:	6b92      	ldr	r2, [r2, #56]	; 0x38
 800ff96:	430a      	orrs	r2, r1
 800ff98:	609a      	str	r2, [r3, #8]
  }
  
  /* if required, configure DMA disabling on reception error */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800ff9a:	687b      	ldr	r3, [r7, #4]
 800ff9c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ff9e:	f003 0320 	and.w	r3, r3, #32
 800ffa2:	2b00      	cmp	r3, #0
 800ffa4:	d00a      	beq.n	800ffbc <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));   
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800ffa6:	687b      	ldr	r3, [r7, #4]
 800ffa8:	681b      	ldr	r3, [r3, #0]
 800ffaa:	687a      	ldr	r2, [r7, #4]
 800ffac:	6812      	ldr	r2, [r2, #0]
 800ffae:	6892      	ldr	r2, [r2, #8]
 800ffb0:	f422 5100 	bic.w	r1, r2, #8192	; 0x2000
 800ffb4:	687a      	ldr	r2, [r7, #4]
 800ffb6:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 800ffb8:	430a      	orrs	r2, r1
 800ffba:	609a      	str	r2, [r3, #8]
  }
  
  /* if required, configure auto Baud rate detection scheme */              
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800ffbc:	687b      	ldr	r3, [r7, #4]
 800ffbe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ffc0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ffc4:	2b00      	cmp	r3, #0
 800ffc6:	d01a      	beq.n	800fffe <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800ffc8:	687b      	ldr	r3, [r7, #4]
 800ffca:	681b      	ldr	r3, [r3, #0]
 800ffcc:	687a      	ldr	r2, [r7, #4]
 800ffce:	6812      	ldr	r2, [r2, #0]
 800ffd0:	6852      	ldr	r2, [r2, #4]
 800ffd2:	f422 1180 	bic.w	r1, r2, #1048576	; 0x100000
 800ffd6:	687a      	ldr	r2, [r7, #4]
 800ffd8:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800ffda:	430a      	orrs	r2, r1
 800ffdc:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800ffde:	687b      	ldr	r3, [r7, #4]
 800ffe0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ffe2:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800ffe6:	d10a      	bne.n	800fffe <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800ffe8:	687b      	ldr	r3, [r7, #4]
 800ffea:	681b      	ldr	r3, [r3, #0]
 800ffec:	687a      	ldr	r2, [r7, #4]
 800ffee:	6812      	ldr	r2, [r2, #0]
 800fff0:	6852      	ldr	r2, [r2, #4]
 800fff2:	f422 01c0 	bic.w	r1, r2, #6291456	; 0x600000
 800fff6:	687a      	ldr	r2, [r7, #4]
 800fff8:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800fffa:	430a      	orrs	r2, r1
 800fffc:	605a      	str	r2, [r3, #4]
    }
  }
  
  /* if required, configure MSB first on communication line */  
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800fffe:	687b      	ldr	r3, [r7, #4]
 8010000:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010002:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8010006:	2b00      	cmp	r3, #0
 8010008:	d00a      	beq.n	8010020 <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));   
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 801000a:	687b      	ldr	r3, [r7, #4]
 801000c:	681b      	ldr	r3, [r3, #0]
 801000e:	687a      	ldr	r2, [r7, #4]
 8010010:	6812      	ldr	r2, [r2, #0]
 8010012:	6852      	ldr	r2, [r2, #4]
 8010014:	f422 2100 	bic.w	r1, r2, #524288	; 0x80000
 8010018:	687a      	ldr	r2, [r7, #4]
 801001a:	6c92      	ldr	r2, [r2, #72]	; 0x48
 801001c:	430a      	orrs	r2, r1
 801001e:	605a      	str	r2, [r3, #4]
  }
}
 8010020:	370c      	adds	r7, #12
 8010022:	46bd      	mov	sp, r7
 8010024:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010028:	4770      	bx	lr
 801002a:	bf00      	nop

0801002c <UART_CheckIdleState>:
  * @brief Check the UART Idle State
  * @param huart: uart handle
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 801002c:	b580      	push	{r7, lr}
 801002e:	b082      	sub	sp, #8
 8010030:	af00      	add	r7, sp, #0
 8010032:	6078      	str	r0, [r7, #4]
  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8010034:	687b      	ldr	r3, [r7, #4]
 8010036:	2200      	movs	r2, #0
 8010038:	66da      	str	r2, [r3, #108]	; 0x6c
  
  /* Check if the Transmitter is enabled */
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 801003a:	687b      	ldr	r3, [r7, #4]
 801003c:	681b      	ldr	r3, [r3, #0]
 801003e:	681b      	ldr	r3, [r3, #0]
 8010040:	f003 0308 	and.w	r3, r3, #8
 8010044:	2b00      	cmp	r3, #0
 8010046:	d00c      	beq.n	8010062 <UART_CheckIdleState+0x36>
  {
    /* Wait until TEACK flag is set */
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, HAL_UART_TIMEOUT_VALUE) != HAL_OK)  
 8010048:	6878      	ldr	r0, [r7, #4]
 801004a:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 801004e:	2200      	movs	r2, #0
 8010050:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8010054:	f7ff fbe8 	bl	800f828 <UART_WaitOnFlagUntilTimeout>
 8010058:	4603      	mov	r3, r0
 801005a:	2b00      	cmp	r3, #0
 801005c:	d001      	beq.n	8010062 <UART_CheckIdleState+0x36>
    {
      /* Timeout Occurred */
      return HAL_TIMEOUT;
 801005e:	2303      	movs	r3, #3
 8010060:	e01c      	b.n	801009c <UART_CheckIdleState+0x70>
    }
  }
  /* Check if the Receiver is enabled */
  if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8010062:	687b      	ldr	r3, [r7, #4]
 8010064:	681b      	ldr	r3, [r3, #0]
 8010066:	681b      	ldr	r3, [r3, #0]
 8010068:	f003 0304 	and.w	r3, r3, #4
 801006c:	2b00      	cmp	r3, #0
 801006e:	d00c      	beq.n	801008a <UART_CheckIdleState+0x5e>
  {
    /* Wait until REACK flag is set */
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET,  HAL_UART_TIMEOUT_VALUE) != HAL_OK)  
 8010070:	6878      	ldr	r0, [r7, #4]
 8010072:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8010076:	2200      	movs	r2, #0
 8010078:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 801007c:	f7ff fbd4 	bl	800f828 <UART_WaitOnFlagUntilTimeout>
 8010080:	4603      	mov	r3, r0
 8010082:	2b00      	cmp	r3, #0
 8010084:	d001      	beq.n	801008a <UART_CheckIdleState+0x5e>
    { 
      /* Timeout Occurred */
      return HAL_TIMEOUT;
 8010086:	2303      	movs	r3, #3
 8010088:	e008      	b.n	801009c <UART_CheckIdleState+0x70>
    }
  }
  
  /* Initialize the UART State */
  huart->State= HAL_UART_STATE_READY;
 801008a:	687b      	ldr	r3, [r7, #4]
 801008c:	2201      	movs	r2, #1
 801008e:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
    
  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8010092:	687b      	ldr	r3, [r7, #4]
 8010094:	2200      	movs	r2, #0
 8010096:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
  
  return HAL_OK;
 801009a:	2300      	movs	r3, #0
}
 801009c:	4618      	mov	r0, r3
 801009e:	3708      	adds	r7, #8
 80100a0:	46bd      	mov	sp, r7
 80100a2:	bd80      	pop	{r7, pc}

080100a4 <FMC_SDRAM_Init>:
  * @param  Device: Pointer to SDRAM device instance
  * @param  Init: Pointer to SDRAM Initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
 80100a4:	b480      	push	{r7}
 80100a6:	b085      	sub	sp, #20
 80100a8:	af00      	add	r7, sp, #0
 80100aa:	6078      	str	r0, [r7, #4]
 80100ac:	6039      	str	r1, [r7, #0]
  uint32_t tmpr1 = 0;
 80100ae:	2300      	movs	r3, #0
 80100b0:	60fb      	str	r3, [r7, #12]
  uint32_t tmpr2 = 0;
 80100b2:	2300      	movs	r3, #0
 80100b4:	60bb      	str	r3, [r7, #8]
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));   

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank != FMC_SDRAM_BANK2) 
 80100b6:	683b      	ldr	r3, [r7, #0]
 80100b8:	681b      	ldr	r3, [r3, #0]
 80100ba:	2b01      	cmp	r3, #1
 80100bc:	d027      	beq.n	801010e <FMC_SDRAM_Init+0x6a>
  { 
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
 80100be:	687b      	ldr	r3, [r7, #4]
 80100c0:	681b      	ldr	r3, [r3, #0]
 80100c2:	60fb      	str	r3, [r7, #12]
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 80100c4:	68fa      	ldr	r2, [r7, #12]
 80100c6:	4b2f      	ldr	r3, [pc, #188]	; (8010184 <FMC_SDRAM_Init+0xe0>)
 80100c8:	4013      	ands	r3, r2
 80100ca:	60fb      	str	r3, [r7, #12]
                         FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 80100cc:	683b      	ldr	r3, [r7, #0]
 80100ce:	685a      	ldr	r2, [r3, #4]
                        Init->RowBitsNumber      |\
 80100d0:	683b      	ldr	r3, [r7, #0]
 80100d2:	689b      	ldr	r3, [r3, #8]
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                         FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 80100d4:	431a      	orrs	r2, r3
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
 80100d6:	683b      	ldr	r3, [r7, #0]
 80100d8:	68db      	ldr	r3, [r3, #12]
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                         FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
                        Init->RowBitsNumber      |\
 80100da:	431a      	orrs	r2, r3
                        Init->MemoryDataWidth    |\
                        Init->InternalBankNumber |\
 80100dc:	683b      	ldr	r3, [r7, #0]
 80100de:	691b      	ldr	r3, [r3, #16]
                         FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
 80100e0:	431a      	orrs	r2, r3
                        Init->InternalBankNumber |\
                        Init->CASLatency         |\
 80100e2:	683b      	ldr	r3, [r7, #0]
 80100e4:	695b      	ldr	r3, [r3, #20]
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
                        Init->InternalBankNumber |\
 80100e6:	431a      	orrs	r2, r3
                        Init->CASLatency         |\
                        Init->WriteProtection    |\
 80100e8:	683b      	ldr	r3, [r7, #0]
 80100ea:	699b      	ldr	r3, [r3, #24]

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
                        Init->InternalBankNumber |\
                        Init->CASLatency         |\
 80100ec:	431a      	orrs	r2, r3
                        Init->WriteProtection    |\
                        Init->SDClockPeriod      |\
 80100ee:	683b      	ldr	r3, [r7, #0]
 80100f0:	69db      	ldr	r3, [r3, #28]
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
                        Init->InternalBankNumber |\
                        Init->CASLatency         |\
                        Init->WriteProtection    |\
 80100f2:	431a      	orrs	r2, r3
                        Init->SDClockPeriod      |\
                        Init->ReadBurst          |\
 80100f4:	683b      	ldr	r3, [r7, #0]
 80100f6:	6a1b      	ldr	r3, [r3, #32]
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
                        Init->InternalBankNumber |\
                        Init->CASLatency         |\
                        Init->WriteProtection    |\
                        Init->SDClockPeriod      |\
 80100f8:	431a      	orrs	r2, r3
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay
 80100fa:	683b      	ldr	r3, [r7, #0]
 80100fc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                         FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 80100fe:	4313      	orrs	r3, r2
 8010100:	68fa      	ldr	r2, [r7, #12]
 8010102:	4313      	orrs	r3, r2
 8010104:	60fb      	str	r3, [r7, #12]
                        Init->WriteProtection    |\
                        Init->SDClockPeriod      |\
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay
                        );                                      
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 8010106:	687b      	ldr	r3, [r7, #4]
 8010108:	68fa      	ldr	r2, [r7, #12]
 801010a:	601a      	str	r2, [r3, #0]
 801010c:	e032      	b.n	8010174 <FMC_SDRAM_Init+0xd0>
  }
  else /* FMC_Bank2_SDRAM */                      
  {
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
 801010e:	687b      	ldr	r3, [r7, #4]
 8010110:	681b      	ldr	r3, [r3, #0]
 8010112:	60fb      	str	r3, [r7, #12]
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 8010114:	68fa      	ldr	r2, [r7, #12]
 8010116:	4b1b      	ldr	r3, [pc, #108]	; (8010184 <FMC_SDRAM_Init+0xe0>)
 8010118:	4013      	ands	r3, r2
 801011a:	60fb      	str	r3, [r7, #12]
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
    
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 801011c:	683b      	ldr	r3, [r7, #0]
 801011e:	69da      	ldr	r2, [r3, #28]
                        Init->ReadBurst          |\
 8010120:	683b      	ldr	r3, [r7, #0]
 8010122:	6a1b      	ldr	r3, [r3, #32]
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
    
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 8010124:	431a      	orrs	r2, r3
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay);  
 8010126:	683b      	ldr	r3, [r7, #0]
 8010128:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
    
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 801012a:	4313      	orrs	r3, r2
 801012c:	68fa      	ldr	r2, [r7, #12]
 801012e:	4313      	orrs	r3, r2
 8010130:	60fb      	str	r3, [r7, #12]
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay);  
    
    tmpr2 = Device->SDCR[FMC_SDRAM_BANK2];
 8010132:	687b      	ldr	r3, [r7, #4]
 8010134:	685b      	ldr	r3, [r3, #4]
 8010136:	60bb      	str	r3, [r7, #8]
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 8010138:	68ba      	ldr	r2, [r7, #8]
 801013a:	4b12      	ldr	r3, [pc, #72]	; (8010184 <FMC_SDRAM_Init+0xe0>)
 801013c:	4013      	ands	r3, r2
 801013e:	60bb      	str	r3, [r7, #8]
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8010140:	683b      	ldr	r3, [r7, #0]
 8010142:	685a      	ldr	r2, [r3, #4]
                       Init->RowBitsNumber      |\
 8010144:	683b      	ldr	r3, [r7, #0]
 8010146:	689b      	ldr	r3, [r3, #8]
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8010148:	431a      	orrs	r2, r3
                       Init->RowBitsNumber      |\
                       Init->MemoryDataWidth    |\
 801014a:	683b      	ldr	r3, [r7, #0]
 801014c:	68db      	ldr	r3, [r3, #12]
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
                       Init->RowBitsNumber      |\
 801014e:	431a      	orrs	r2, r3
                       Init->MemoryDataWidth    |\
                       Init->InternalBankNumber |\
 8010150:	683b      	ldr	r3, [r7, #0]
 8010152:	691b      	ldr	r3, [r3, #16]
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
                       Init->RowBitsNumber      |\
                       Init->MemoryDataWidth    |\
 8010154:	431a      	orrs	r2, r3
                       Init->InternalBankNumber |\
                       Init->CASLatency         |\
 8010156:	683b      	ldr	r3, [r7, #0]
 8010158:	695b      	ldr	r3, [r3, #20]
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
                       Init->RowBitsNumber      |\
                       Init->MemoryDataWidth    |\
                       Init->InternalBankNumber |\
 801015a:	431a      	orrs	r2, r3
                       Init->CASLatency         |\
                       Init->WriteProtection);
 801015c:	683b      	ldr	r3, [r7, #0]
 801015e:	699b      	ldr	r3, [r3, #24]
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8010160:	4313      	orrs	r3, r2
 8010162:	68ba      	ldr	r2, [r7, #8]
 8010164:	4313      	orrs	r3, r2
 8010166:	60bb      	str	r3, [r7, #8]
                       Init->MemoryDataWidth    |\
                       Init->InternalBankNumber |\
                       Init->CASLatency         |\
                       Init->WriteProtection);

    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 8010168:	687b      	ldr	r3, [r7, #4]
 801016a:	68fa      	ldr	r2, [r7, #12]
 801016c:	601a      	str	r2, [r3, #0]
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
 801016e:	687b      	ldr	r3, [r7, #4]
 8010170:	68ba      	ldr	r2, [r7, #8]
 8010172:	605a      	str	r2, [r3, #4]
  }  
  
  return HAL_OK;
 8010174:	2300      	movs	r3, #0
}
 8010176:	4618      	mov	r0, r3
 8010178:	3714      	adds	r7, #20
 801017a:	46bd      	mov	sp, r7
 801017c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010180:	4770      	bx	lr
 8010182:	bf00      	nop
 8010184:	ffff8000 	.word	0xffff8000

08010188 <FMC_SDRAM_Timing_Init>:
  * @param  Timing: Pointer to SDRAM Timing structure
  * @param  Bank: SDRAM bank number   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
{
 8010188:	b480      	push	{r7}
 801018a:	b087      	sub	sp, #28
 801018c:	af00      	add	r7, sp, #0
 801018e:	60f8      	str	r0, [r7, #12]
 8010190:	60b9      	str	r1, [r7, #8]
 8010192:	607a      	str	r2, [r7, #4]
  uint32_t tmpr1 = 0;
 8010194:	2300      	movs	r3, #0
 8010196:	617b      	str	r3, [r7, #20]
  uint32_t tmpr2 = 0;
 8010198:	2300      	movs	r3, #0
 801019a:	613b      	str	r3, [r7, #16]
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
  assert_param(IS_FMC_SDRAM_BANK(Bank));
  
  /* Set SDRAM device timing parameters */ 
  if (Bank != FMC_SDRAM_BANK2) 
 801019c:	687b      	ldr	r3, [r7, #4]
 801019e:	2b01      	cmp	r3, #1
 80101a0:	d02e      	beq.n	8010200 <FMC_SDRAM_Timing_Init+0x78>
  { 
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
 80101a2:	68fb      	ldr	r3, [r7, #12]
 80101a4:	689b      	ldr	r3, [r3, #8]
 80101a6:	617b      	str	r3, [r7, #20]
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 80101a8:	697b      	ldr	r3, [r7, #20]
 80101aa:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 80101ae:	617b      	str	r3, [r7, #20]
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 80101b0:	68bb      	ldr	r3, [r7, #8]
 80101b2:	681b      	ldr	r3, [r3, #0]
 80101b4:	1e5a      	subs	r2, r3, #1
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 80101b6:	68bb      	ldr	r3, [r7, #8]
 80101b8:	685b      	ldr	r3, [r3, #4]
 80101ba:	3b01      	subs	r3, #1
 80101bc:	011b      	lsls	r3, r3, #4
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 80101be:	431a      	orrs	r2, r3
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 80101c0:	68bb      	ldr	r3, [r7, #8]
 80101c2:	689b      	ldr	r3, [r3, #8]
 80101c4:	3b01      	subs	r3, #1
 80101c6:	021b      	lsls	r3, r3, #8
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 80101c8:	431a      	orrs	r2, r3
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->RowCycleDelay)-1) << 12)       |\
 80101ca:	68bb      	ldr	r3, [r7, #8]
 80101cc:	68db      	ldr	r3, [r3, #12]
 80101ce:	3b01      	subs	r3, #1
 80101d0:	031b      	lsls	r3, r3, #12
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 80101d2:	431a      	orrs	r2, r3
                       (((Timing->RowCycleDelay)-1) << 12)       |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
 80101d4:	68bb      	ldr	r3, [r7, #8]
 80101d6:	691b      	ldr	r3, [r3, #16]
 80101d8:	3b01      	subs	r3, #1
 80101da:	041b      	lsls	r3, r3, #16
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->RowCycleDelay)-1) << 12)       |\
 80101dc:	431a      	orrs	r2, r3
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
                       (((Timing->RPDelay)-1) << 20)             |\
 80101de:	68bb      	ldr	r3, [r7, #8]
 80101e0:	695b      	ldr	r3, [r3, #20]
 80101e2:	3b01      	subs	r3, #1
 80101e4:	051b      	lsls	r3, r3, #20
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->RowCycleDelay)-1) << 12)       |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
 80101e6:	431a      	orrs	r2, r3
                       (((Timing->RPDelay)-1) << 20)             |\
                       (((Timing->RCDDelay)-1) << 24));
 80101e8:	68bb      	ldr	r3, [r7, #8]
 80101ea:	699b      	ldr	r3, [r3, #24]
 80101ec:	3b01      	subs	r3, #1
 80101ee:	061b      	lsls	r3, r3, #24
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 80101f0:	4313      	orrs	r3, r2
 80101f2:	697a      	ldr	r2, [r7, #20]
 80101f4:	4313      	orrs	r3, r2
 80101f6:	617b      	str	r3, [r7, #20]
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->RowCycleDelay)-1) << 12)       |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
                       (((Timing->RPDelay)-1) << 20)             |\
                       (((Timing->RCDDelay)-1) << 24));
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
 80101f8:	68fb      	ldr	r3, [r7, #12]
 80101fa:	697a      	ldr	r2, [r7, #20]
 80101fc:	609a      	str	r2, [r3, #8]
 80101fe:	e039      	b.n	8010274 <FMC_SDRAM_Timing_Init+0xec>
  }
  else /* FMC_Bank2_SDRAM */
  {  
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK2];
 8010200:	68fb      	ldr	r3, [r7, #12]
 8010202:	68db      	ldr	r3, [r3, #12]
 8010204:	617b      	str	r3, [r7, #20]
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 8010206:	697b      	ldr	r3, [r7, #20]
 8010208:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 801020c:	617b      	str	r3, [r7, #20]
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 801020e:	68bb      	ldr	r3, [r7, #8]
 8010210:	681b      	ldr	r3, [r3, #0]
 8010212:	1e5a      	subs	r2, r3, #1
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 8010214:	68bb      	ldr	r3, [r7, #8]
 8010216:	685b      	ldr	r3, [r3, #4]
 8010218:	3b01      	subs	r3, #1
 801021a:	011b      	lsls	r3, r3, #4
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 801021c:	431a      	orrs	r2, r3
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 801021e:	68bb      	ldr	r3, [r7, #8]
 8010220:	689b      	ldr	r3, [r3, #8]
 8010222:	3b01      	subs	r3, #1
 8010224:	021b      	lsls	r3, r3, #8
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 8010226:	431a      	orrs	r2, r3
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
 8010228:	68bb      	ldr	r3, [r7, #8]
 801022a:	691b      	ldr	r3, [r3, #16]
 801022c:	3b01      	subs	r3, #1
 801022e:	041b      	lsls	r3, r3, #16
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 8010230:	431a      	orrs	r2, r3
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
                       (((Timing->RCDDelay)-1) << 24));   
 8010232:	68bb      	ldr	r3, [r7, #8]
 8010234:	699b      	ldr	r3, [r3, #24]
 8010236:	3b01      	subs	r3, #1
 8010238:	061b      	lsls	r3, r3, #24
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 801023a:	4313      	orrs	r3, r2
 801023c:	697a      	ldr	r2, [r7, #20]
 801023e:	4313      	orrs	r3, r2
 8010240:	617b      	str	r3, [r7, #20]
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
                       (((Timing->RCDDelay)-1) << 24));   
    
    tmpr2 = Device->SDTR[FMC_SDRAM_BANK1];
 8010242:	68fb      	ldr	r3, [r7, #12]
 8010244:	689b      	ldr	r3, [r3, #8]
 8010246:	613b      	str	r3, [r7, #16]
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 8010248:	693b      	ldr	r3, [r7, #16]
 801024a:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 801024e:	613b      	str	r3, [r7, #16]
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    tmpr2 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 8010250:	68bb      	ldr	r3, [r7, #8]
 8010252:	68db      	ldr	r3, [r3, #12]
 8010254:	3b01      	subs	r3, #1
 8010256:	031a      	lsls	r2, r3, #12
                        (((Timing->RPDelay)-1) << 20)); 
 8010258:	68bb      	ldr	r3, [r7, #8]
 801025a:	695b      	ldr	r3, [r3, #20]
 801025c:	3b01      	subs	r3, #1
 801025e:	051b      	lsls	r3, r3, #20
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    tmpr2 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 8010260:	4313      	orrs	r3, r2
 8010262:	693a      	ldr	r2, [r7, #16]
 8010264:	4313      	orrs	r3, r2
 8010266:	613b      	str	r3, [r7, #16]
                        (((Timing->RPDelay)-1) << 20)); 

    Device->SDTR[FMC_SDRAM_BANK2] = tmpr1;
 8010268:	68fb      	ldr	r3, [r7, #12]
 801026a:	697a      	ldr	r2, [r7, #20]
 801026c:	60da      	str	r2, [r3, #12]
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr2;
 801026e:	68fb      	ldr	r3, [r7, #12]
 8010270:	693a      	ldr	r2, [r7, #16]
 8010272:	609a      	str	r2, [r3, #8]
  }   
  
  return HAL_OK;
 8010274:	2300      	movs	r3, #0
}
 8010276:	4618      	mov	r0, r3
 8010278:	371c      	adds	r7, #28
 801027a:	46bd      	mov	sp, r7
 801027c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010280:	4770      	bx	lr
 8010282:	bf00      	nop

08010284 <FMC_SDRAM_SendCommand>:
  * @param  Timing: Pointer to SDRAM Timing structure
  * @param  Timeout: Timeout wait value
  * @retval HAL state
  */  
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 8010284:	b580      	push	{r7, lr}
 8010286:	b086      	sub	sp, #24
 8010288:	af00      	add	r7, sp, #0
 801028a:	60f8      	str	r0, [r7, #12]
 801028c:	60b9      	str	r1, [r7, #8]
 801028e:	607a      	str	r2, [r7, #4]
  __IO uint32_t tmpr = 0;
 8010290:	2300      	movs	r3, #0
 8010292:	613b      	str	r3, [r7, #16]
  uint32_t tickstart = 0;
 8010294:	2300      	movs	r3, #0
 8010296:	617b      	str	r3, [r7, #20]
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 8010298:	68bb      	ldr	r3, [r7, #8]
 801029a:	681a      	ldr	r2, [r3, #0]
                    (Command->CommandTarget)                |\
 801029c:	68bb      	ldr	r3, [r7, #8]
 801029e:	685b      	ldr	r3, [r3, #4]
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 80102a0:	431a      	orrs	r2, r3
                    (Command->CommandTarget)                |\
                    (((Command->AutoRefreshNumber)-1) << 5) |\
 80102a2:	68bb      	ldr	r3, [r7, #8]
 80102a4:	689b      	ldr	r3, [r3, #8]
 80102a6:	3b01      	subs	r3, #1
 80102a8:	015b      	lsls	r3, r3, #5
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  tmpr = (uint32_t)((Command->CommandMode)                  |\
                    (Command->CommandTarget)                |\
 80102aa:	431a      	orrs	r2, r3
                    (((Command->AutoRefreshNumber)-1) << 5) |\
                    ((Command->ModeRegisterDefinition) << 9)
 80102ac:	68bb      	ldr	r3, [r7, #8]
 80102ae:	68db      	ldr	r3, [r3, #12]
 80102b0:	025b      	lsls	r3, r3, #9
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 80102b2:	4313      	orrs	r3, r2
 80102b4:	613b      	str	r3, [r7, #16]
                    (Command->CommandTarget)                |\
                    (((Command->AutoRefreshNumber)-1) << 5) |\
                    ((Command->ModeRegisterDefinition) << 9)
                    );
    
  Device->SDCMR = tmpr;
 80102b6:	693a      	ldr	r2, [r7, #16]
 80102b8:	68fb      	ldr	r3, [r7, #12]
 80102ba:	611a      	str	r2, [r3, #16]

  /* Get tick */ 
  tickstart = HAL_GetTick();
 80102bc:	f7f6 fb98 	bl	80069f0 <HAL_GetTick>
 80102c0:	6178      	str	r0, [r7, #20]

  /* wait until command is send */
  while(HAL_IS_BIT_SET(Device->SDSR, FMC_SDSR_BUSY))
 80102c2:	bf00      	nop
 80102c4:	68fb      	ldr	r3, [r7, #12]
 80102c6:	699b      	ldr	r3, [r3, #24]
 80102c8:	f003 0320 	and.w	r3, r3, #32
 80102cc:	2b00      	cmp	r3, #0
 80102ce:	d012      	beq.n	80102f6 <FMC_SDRAM_SendCommand+0x72>
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 80102d0:	687b      	ldr	r3, [r7, #4]
 80102d2:	f1b3 3fff 	cmp.w	r3, #4294967295
 80102d6:	d00c      	beq.n	80102f2 <FMC_SDRAM_SendCommand+0x6e>
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 80102d8:	687b      	ldr	r3, [r7, #4]
 80102da:	2b00      	cmp	r3, #0
 80102dc:	d007      	beq.n	80102ee <FMC_SDRAM_SendCommand+0x6a>
 80102de:	f7f6 fb87 	bl	80069f0 <HAL_GetTick>
 80102e2:	4602      	mov	r2, r0
 80102e4:	697b      	ldr	r3, [r7, #20]
 80102e6:	1ad2      	subs	r2, r2, r3
 80102e8:	687b      	ldr	r3, [r7, #4]
 80102ea:	429a      	cmp	r2, r3
 80102ec:	d901      	bls.n	80102f2 <FMC_SDRAM_SendCommand+0x6e>
      {
        return HAL_TIMEOUT;
 80102ee:	2303      	movs	r3, #3
 80102f0:	e002      	b.n	80102f8 <FMC_SDRAM_SendCommand+0x74>
      }
    }     
    
    return HAL_ERROR;
 80102f2:	2301      	movs	r3, #1
 80102f4:	e000      	b.n	80102f8 <FMC_SDRAM_SendCommand+0x74>
  }
  
  return HAL_OK;  
 80102f6:	2300      	movs	r3, #0
}
 80102f8:	4618      	mov	r0, r3
 80102fa:	3718      	adds	r7, #24
 80102fc:	46bd      	mov	sp, r7
 80102fe:	bd80      	pop	{r7, pc}

08010300 <FMC_SDRAM_ProgramRefreshRate>:
  * @param  Device: Pointer to SDRAM device instance  
  * @param  RefreshRate: The SDRAM refresh rate value.       
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
{
 8010300:	b480      	push	{r7}
 8010302:	b083      	sub	sp, #12
 8010304:	af00      	add	r7, sp, #0
 8010306:	6078      	str	r0, [r7, #4]
 8010308:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));
  
  /* Set the refresh rate in command register */
  Device->SDRTR |= (RefreshRate<<1);
 801030a:	687b      	ldr	r3, [r7, #4]
 801030c:	695a      	ldr	r2, [r3, #20]
 801030e:	683b      	ldr	r3, [r7, #0]
 8010310:	005b      	lsls	r3, r3, #1
 8010312:	431a      	orrs	r2, r3
 8010314:	687b      	ldr	r3, [r7, #4]
 8010316:	615a      	str	r2, [r3, #20]
  
  return HAL_OK;   
 8010318:	2300      	movs	r3, #0
}
 801031a:	4618      	mov	r0, r3
 801031c:	370c      	adds	r7, #12
 801031e:	46bd      	mov	sp, r7
 8010320:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010324:	4770      	bx	lr
 8010326:	bf00      	nop

08010328 <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8010328:	b480      	push	{r7}
 801032a:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 801032c:	4a15      	ldr	r2, [pc, #84]	; (8010384 <SystemInit+0x5c>)
 801032e:	4b15      	ldr	r3, [pc, #84]	; (8010384 <SystemInit+0x5c>)
 8010330:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8010334:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8010338:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 801033c:	4a12      	ldr	r2, [pc, #72]	; (8010388 <SystemInit+0x60>)
 801033e:	4b12      	ldr	r3, [pc, #72]	; (8010388 <SystemInit+0x60>)
 8010340:	681b      	ldr	r3, [r3, #0]
 8010342:	f043 0301 	orr.w	r3, r3, #1
 8010346:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8010348:	4b0f      	ldr	r3, [pc, #60]	; (8010388 <SystemInit+0x60>)
 801034a:	2200      	movs	r2, #0
 801034c:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 801034e:	490e      	ldr	r1, [pc, #56]	; (8010388 <SystemInit+0x60>)
 8010350:	4b0d      	ldr	r3, [pc, #52]	; (8010388 <SystemInit+0x60>)
 8010352:	681a      	ldr	r2, [r3, #0]
 8010354:	4b0d      	ldr	r3, [pc, #52]	; (801038c <SystemInit+0x64>)
 8010356:	4013      	ands	r3, r2
 8010358:	600b      	str	r3, [r1, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 801035a:	4b0b      	ldr	r3, [pc, #44]	; (8010388 <SystemInit+0x60>)
 801035c:	4a0c      	ldr	r2, [pc, #48]	; (8010390 <SystemInit+0x68>)
 801035e:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8010360:	4a09      	ldr	r2, [pc, #36]	; (8010388 <SystemInit+0x60>)
 8010362:	4b09      	ldr	r3, [pc, #36]	; (8010388 <SystemInit+0x60>)
 8010364:	681b      	ldr	r3, [r3, #0]
 8010366:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 801036a:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 801036c:	4b06      	ldr	r3, [pc, #24]	; (8010388 <SystemInit+0x60>)
 801036e:	2200      	movs	r2, #0
 8010370:	60da      	str	r2, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8010372:	4b04      	ldr	r3, [pc, #16]	; (8010384 <SystemInit+0x5c>)
 8010374:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8010378:	609a      	str	r2, [r3, #8]
#endif
}
 801037a:	46bd      	mov	sp, r7
 801037c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010380:	4770      	bx	lr
 8010382:	bf00      	nop
 8010384:	e000ed00 	.word	0xe000ed00
 8010388:	40023800 	.word	0x40023800
 801038c:	fef6ffff 	.word	0xfef6ffff
 8010390:	24003010 	.word	0x24003010

08010394 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 8010394:	f8df d034 	ldr.w	sp, [pc, #52]	; 80103cc <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8010398:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 801039a:	e003      	b.n	80103a4 <LoopCopyDataInit>

0801039c <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 801039c:	4b0c      	ldr	r3, [pc, #48]	; (80103d0 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 801039e:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 80103a0:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 80103a2:	3104      	adds	r1, #4

080103a4 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 80103a4:	480b      	ldr	r0, [pc, #44]	; (80103d4 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 80103a6:	4b0c      	ldr	r3, [pc, #48]	; (80103d8 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 80103a8:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 80103aa:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 80103ac:	d3f6      	bcc.n	801039c <CopyDataInit>
  ldr  r2, =_sbss
 80103ae:	4a0b      	ldr	r2, [pc, #44]	; (80103dc <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 80103b0:	e002      	b.n	80103b8 <LoopFillZerobss>

080103b2 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 80103b2:	2300      	movs	r3, #0
  str  r3, [r2], #4
 80103b4:	f842 3b04 	str.w	r3, [r2], #4

080103b8 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 80103b8:	4b09      	ldr	r3, [pc, #36]	; (80103e0 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 80103ba:	429a      	cmp	r2, r3
  bcc  FillZerobss
 80103bc:	d3f9      	bcc.n	80103b2 <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 80103be:	f7ff ffb3 	bl	8010328 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80103c2:	f009 fb5b 	bl	8019a7c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 80103c6:	f005 f94b 	bl	8015660 <main>
  bx  lr    
 80103ca:	4770      	bx	lr

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 80103cc:	200107b4 	.word	0x200107b4
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 80103d0:	0802a608 	.word	0x0802a608
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 80103d4:	20010000 	.word	0x20010000
  ldr  r3, =_edata
 80103d8:	200105b4 	.word	0x200105b4
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 80103dc:	200107b4 	.word	0x200107b4
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 80103e0:	20012fd0 	.word	0x20012fd0

080103e4 <CAN2_RX0_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 80103e4:	e7fe      	b.n	80103e4 <CAN2_RX0_IRQHandler>
	...

080103e8 <j1939_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
static __inline void j1939_list_insert_before(struct list_node *l, struct list_node *n)
{
 80103e8:	b480      	push	{r7}
 80103ea:	b083      	sub	sp, #12
 80103ec:	af00      	add	r7, sp, #0
 80103ee:	6078      	str	r0, [r7, #4]
 80103f0:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 80103f2:	687b      	ldr	r3, [r7, #4]
 80103f4:	685b      	ldr	r3, [r3, #4]
 80103f6:	683a      	ldr	r2, [r7, #0]
 80103f8:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 80103fa:	687b      	ldr	r3, [r7, #4]
 80103fc:	685a      	ldr	r2, [r3, #4]
 80103fe:	683b      	ldr	r3, [r7, #0]
 8010400:	605a      	str	r2, [r3, #4]

    l->prev = n;
 8010402:	687b      	ldr	r3, [r7, #4]
 8010404:	683a      	ldr	r2, [r7, #0]
 8010406:	605a      	str	r2, [r3, #4]
    n->next = l;
 8010408:	683b      	ldr	r3, [r7, #0]
 801040a:	687a      	ldr	r2, [r7, #4]
 801040c:	601a      	str	r2, [r3, #0]
}
 801040e:	370c      	adds	r7, #12
 8010410:	46bd      	mov	sp, r7
 8010412:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010416:	4770      	bx	lr

08010418 <list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
static __inline void list_init(struct list_node *l)
{
 8010418:	b480      	push	{r7}
 801041a:	b083      	sub	sp, #12
 801041c:	af00      	add	r7, sp, #0
 801041e:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 8010420:	687b      	ldr	r3, [r7, #4]
 8010422:	687a      	ldr	r2, [r7, #4]
 8010424:	605a      	str	r2, [r3, #4]
 8010426:	687b      	ldr	r3, [r7, #4]
 8010428:	685a      	ldr	r2, [r3, #4]
 801042a:	687b      	ldr	r3, [r7, #4]
 801042c:	601a      	str	r2, [r3, #0]
}
 801042e:	370c      	adds	r7, #12
 8010430:	46bd      	mov	sp, r7
 8010432:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010436:	4770      	bx	lr

08010438 <inttoch>:


#define Q_MAX_MSG 10;


char inttoch(int val) {
 8010438:	b480      	push	{r7}
 801043a:	b083      	sub	sp, #12
 801043c:	af00      	add	r7, sp, #0
 801043e:	6078      	str	r0, [r7, #4]
  if (val<10) return (char)('0'+val);
 8010440:	687b      	ldr	r3, [r7, #4]
 8010442:	2b09      	cmp	r3, #9
 8010444:	dc04      	bgt.n	8010450 <inttoch+0x18>
 8010446:	687b      	ldr	r3, [r7, #4]
 8010448:	b2db      	uxtb	r3, r3
 801044a:	3330      	adds	r3, #48	; 0x30
 801044c:	b2db      	uxtb	r3, r3
 801044e:	e003      	b.n	8010458 <inttoch+0x20>
  return (char)('A'+val-10);
 8010450:	687b      	ldr	r3, [r7, #4]
 8010452:	b2db      	uxtb	r3, r3
 8010454:	3337      	adds	r3, #55	; 0x37
 8010456:	b2db      	uxtb	r3, r3
}
 8010458:	4618      	mov	r0, r3
 801045a:	370c      	adds	r7, #12
 801045c:	46bd      	mov	sp, r7
 801045e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010462:	4770      	bx	lr

08010464 <inttostring>:

void inttostring(int vals,char *str,unsigned int base)
{
 8010464:	b590      	push	{r4, r7, lr}
 8010466:	b089      	sub	sp, #36	; 0x24
 8010468:	af00      	add	r7, sp, #0
 801046a:	60f8      	str	r0, [r7, #12]
 801046c:	60b9      	str	r1, [r7, #8]
 801046e:	607a      	str	r2, [r7, #4]
	unsigned int val;
	if (vals<0) {
 8010470:	68fb      	ldr	r3, [r7, #12]
 8010472:	2b00      	cmp	r3, #0
 8010474:	da08      	bge.n	8010488 <inttostring+0x24>
	  *(str++)='-';
 8010476:	68bb      	ldr	r3, [r7, #8]
 8010478:	1c5a      	adds	r2, r3, #1
 801047a:	60ba      	str	r2, [r7, #8]
 801047c:	222d      	movs	r2, #45	; 0x2d
 801047e:	701a      	strb	r2, [r3, #0]
	  val = (unsigned int)(-vals);
 8010480:	68fb      	ldr	r3, [r7, #12]
 8010482:	425b      	negs	r3, r3
 8010484:	61fb      	str	r3, [r7, #28]
 8010486:	e001      	b.n	801048c <inttostring+0x28>
	} else {
	  val = (unsigned int)vals;
 8010488:	68fb      	ldr	r3, [r7, #12]
 801048a:	61fb      	str	r3, [r7, #28]
	}
	unsigned int d = 1;
 801048c:	2301      	movs	r3, #1
 801048e:	61bb      	str	r3, [r7, #24]
	while (d*base <= val) d*=base;
 8010490:	e004      	b.n	801049c <inttostring+0x38>
 8010492:	69bb      	ldr	r3, [r7, #24]
 8010494:	687a      	ldr	r2, [r7, #4]
 8010496:	fb02 f303 	mul.w	r3, r2, r3
 801049a:	61bb      	str	r3, [r7, #24]
 801049c:	69bb      	ldr	r3, [r7, #24]
 801049e:	687a      	ldr	r2, [r7, #4]
 80104a0:	fb02 f203 	mul.w	r2, r2, r3
 80104a4:	69fb      	ldr	r3, [r7, #28]
 80104a6:	429a      	cmp	r2, r3
 80104a8:	d9f3      	bls.n	8010492 <inttostring+0x2e>
	while (d > 1) {
 80104aa:	e019      	b.n	80104e0 <inttostring+0x7c>
	  unsigned int v = (unsigned int)(val / d);
 80104ac:	69fa      	ldr	r2, [r7, #28]
 80104ae:	69bb      	ldr	r3, [r7, #24]
 80104b0:	fbb2 f3f3 	udiv	r3, r2, r3
 80104b4:	617b      	str	r3, [r7, #20]
	  val -= v*d;
 80104b6:	697b      	ldr	r3, [r7, #20]
 80104b8:	69ba      	ldr	r2, [r7, #24]
 80104ba:	fb02 f303 	mul.w	r3, r2, r3
 80104be:	69fa      	ldr	r2, [r7, #28]
 80104c0:	1ad3      	subs	r3, r2, r3
 80104c2:	61fb      	str	r3, [r7, #28]
	  *(str++) = inttoch((int)v);
 80104c4:	68bc      	ldr	r4, [r7, #8]
 80104c6:	1c63      	adds	r3, r4, #1
 80104c8:	60bb      	str	r3, [r7, #8]
 80104ca:	697b      	ldr	r3, [r7, #20]
 80104cc:	4618      	mov	r0, r3
 80104ce:	f7ff ffb3 	bl	8010438 <inttoch>
 80104d2:	4603      	mov	r3, r0
 80104d4:	7023      	strb	r3, [r4, #0]
	  d /= base;
 80104d6:	69ba      	ldr	r2, [r7, #24]
 80104d8:	687b      	ldr	r3, [r7, #4]
 80104da:	fbb2 f3f3 	udiv	r3, r2, r3
 80104de:	61bb      	str	r3, [r7, #24]
	} else {
	  val = (unsigned int)vals;
	}
	unsigned int d = 1;
	while (d*base <= val) d*=base;
	while (d > 1) {
 80104e0:	69bb      	ldr	r3, [r7, #24]
 80104e2:	2b01      	cmp	r3, #1
 80104e4:	d8e2      	bhi.n	80104ac <inttostring+0x48>
	  unsigned int v = (unsigned int)(val / d);
	  val -= v*d;
	  *(str++) = inttoch((int)v);
	  d /= base;
	}
	*(str++)=inttoch((int)val);
 80104e6:	68bc      	ldr	r4, [r7, #8]
 80104e8:	1c63      	adds	r3, r4, #1
 80104ea:	60bb      	str	r3, [r7, #8]
 80104ec:	69fb      	ldr	r3, [r7, #28]
 80104ee:	4618      	mov	r0, r3
 80104f0:	f7ff ffa2 	bl	8010438 <inttoch>
 80104f4:	4603      	mov	r3, r0
 80104f6:	7023      	strb	r3, [r4, #0]
	*(str++)=0;
 80104f8:	68bb      	ldr	r3, [r7, #8]
 80104fa:	1c5a      	adds	r2, r3, #1
 80104fc:	60ba      	str	r2, [r7, #8]
 80104fe:	2200      	movs	r2, #0
 8010500:	701a      	strb	r2, [r3, #0]

}
 8010502:	3724      	adds	r7, #36	; 0x24
 8010504:	46bd      	mov	sp, r7
 8010506:	bd90      	pop	{r4, r7, pc}

08010508 <J1939_CA_register>:

unsigned char J1939_CA_register(CA_Msg_t ca_msg)
{
 8010508:	b580      	push	{r7, lr}
 801050a:	b08a      	sub	sp, #40	; 0x28
 801050c:	af00      	add	r7, sp, #0
 801050e:	6078      	str	r0, [r7, #4]
	unsigned char result = RC_SUCCESS;
 8010510:	2300      	movs	r3, #0
 8010512:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	struct CA_node * canode;
	struct os_messageQ_def queue_def;
	char str1[5];
	
	if((CA_FindAddress(&calist,ca_msg)) != 254)
 8010516:	4841      	ldr	r0, [pc, #260]	; (801061c <J1939_CA_register+0x114>)
 8010518:	6879      	ldr	r1, [r7, #4]
 801051a:	f001 fae1 	bl	8011ae0 <CA_FindAddress>
 801051e:	4603      	mov	r3, r0
 8010520:	2bfe      	cmp	r3, #254	; 0xfe
 8010522:	d001      	beq.n	8010528 <J1939_CA_register+0x20>
		return RC_ERROR;
 8010524:	2301      	movs	r3, #1
 8010526:	e075      	b.n	8010614 <J1939_CA_register+0x10c>
	
	inttostring(ca_msg->CAname->FunInstance,str1,10);
 8010528:	687b      	ldr	r3, [r7, #4]
 801052a:	681b      	ldr	r3, [r3, #0]
 801052c:	791b      	ldrb	r3, [r3, #4]
 801052e:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8010532:	b2db      	uxtb	r3, r3
 8010534:	461a      	mov	r2, r3
 8010536:	f107 0308 	add.w	r3, r7, #8
 801053a:	4610      	mov	r0, r2
 801053c:	4619      	mov	r1, r3
 801053e:	220a      	movs	r2, #10
 8010540:	f7ff ff90 	bl	8010464 <inttostring>
	strcat(str1,"tx");
 8010544:	f107 0308 	add.w	r3, r7, #8
 8010548:	4618      	mov	r0, r3
 801054a:	f013 f8ab 	bl	80236a4 <strlen>
 801054e:	4603      	mov	r3, r0
 8010550:	461a      	mov	r2, r3
 8010552:	f107 0308 	add.w	r3, r7, #8
 8010556:	4413      	add	r3, r2
 8010558:	4a31      	ldr	r2, [pc, #196]	; (8010620 <J1939_CA_register+0x118>)
 801055a:	8811      	ldrh	r1, [r2, #0]
 801055c:	7892      	ldrb	r2, [r2, #2]
 801055e:	8019      	strh	r1, [r3, #0]
 8010560:	709a      	strb	r2, [r3, #2]
	queue_def.name = str1;
 8010562:	f107 0308 	add.w	r3, r7, #8
 8010566:	613b      	str	r3, [r7, #16]
	rt_kprintf("%s\r\n",queue_def.name );
 8010568:	693b      	ldr	r3, [r7, #16]
 801056a:	482e      	ldr	r0, [pc, #184]	; (8010624 <J1939_CA_register+0x11c>)
 801056c:	4619      	mov	r1, r3
 801056e:	f007 f9a5 	bl	80178bc <rt_kprintf>
	queue_def.msg_size = sizeof(struct q_Message);
 8010572:	2306      	movs	r3, #6
 8010574:	61bb      	str	r3, [r7, #24]
	queue_def.max_msgs = Q_MAX_MSG;
 8010576:	230a      	movs	r3, #10
 8010578:	617b      	str	r3, [r7, #20]
	queue_def.flag = IPC_FLAG_FIFO;
 801057a:	2300      	movs	r3, #0
 801057c:	773b      	strb	r3, [r7, #28]
	ca_msg->txq = osMessageCreate(&queue_def,NULL);
 801057e:	f107 0310 	add.w	r3, r7, #16
 8010582:	4618      	mov	r0, r3
 8010584:	2100      	movs	r1, #0
 8010586:	f009 fad9 	bl	8019b3c <osMessageCreate>
 801058a:	4602      	mov	r2, r0
 801058c:	687b      	ldr	r3, [r7, #4]
 801058e:	65da      	str	r2, [r3, #92]	; 0x5c
	
	inttostring(ca_msg->CAname->FunInstance,str1,10);
 8010590:	687b      	ldr	r3, [r7, #4]
 8010592:	681b      	ldr	r3, [r3, #0]
 8010594:	791b      	ldrb	r3, [r3, #4]
 8010596:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 801059a:	b2db      	uxtb	r3, r3
 801059c:	461a      	mov	r2, r3
 801059e:	f107 0308 	add.w	r3, r7, #8
 80105a2:	4610      	mov	r0, r2
 80105a4:	4619      	mov	r1, r3
 80105a6:	220a      	movs	r2, #10
 80105a8:	f7ff ff5c 	bl	8010464 <inttostring>
	strcat(str1,"rx");
 80105ac:	f107 0308 	add.w	r3, r7, #8
 80105b0:	4618      	mov	r0, r3
 80105b2:	f013 f877 	bl	80236a4 <strlen>
 80105b6:	4603      	mov	r3, r0
 80105b8:	461a      	mov	r2, r3
 80105ba:	f107 0308 	add.w	r3, r7, #8
 80105be:	4413      	add	r3, r2
 80105c0:	4a19      	ldr	r2, [pc, #100]	; (8010628 <J1939_CA_register+0x120>)
 80105c2:	8811      	ldrh	r1, [r2, #0]
 80105c4:	7892      	ldrb	r2, [r2, #2]
 80105c6:	8019      	strh	r1, [r3, #0]
 80105c8:	709a      	strb	r2, [r3, #2]
	queue_def.name = str1;
 80105ca:	f107 0308 	add.w	r3, r7, #8
 80105ce:	613b      	str	r3, [r7, #16]
	queue_def.msg_size = sizeof(struct rx_Message);
 80105d0:	230c      	movs	r3, #12
 80105d2:	61bb      	str	r3, [r7, #24]
	queue_def.max_msgs = Q_MAX_MSG;
 80105d4:	230a      	movs	r3, #10
 80105d6:	617b      	str	r3, [r7, #20]
	queue_def.flag = IPC_FLAG_FIFO;
 80105d8:	2300      	movs	r3, #0
 80105da:	773b      	strb	r3, [r7, #28]
	ca_msg->rxq = osMessageCreate(&queue_def,NULL);
 80105dc:	f107 0310 	add.w	r3, r7, #16
 80105e0:	4618      	mov	r0, r3
 80105e2:	2100      	movs	r1, #0
 80105e4:	f009 faaa 	bl	8019b3c <osMessageCreate>
 80105e8:	4602      	mov	r2, r0
 80105ea:	687b      	ldr	r3, [r7, #4]
 80105ec:	661a      	str	r2, [r3, #96]	; 0x60

	canode = (struct CA_node * )malloc(sizeof(struct CA_node));
 80105ee:	200c      	movs	r0, #12
 80105f0:	f012 fbb6 	bl	8022d60 <malloc>
 80105f4:	4603      	mov	r3, r0
 80105f6:	623b      	str	r3, [r7, #32]
	canode->ca_msg = ca_msg;
 80105f8:	6a3b      	ldr	r3, [r7, #32]
 80105fa:	687a      	ldr	r2, [r7, #4]
 80105fc:	601a      	str	r2, [r3, #0]
	j1939_list_insert_before(&(calist.head),&(canode->node));
 80105fe:	6a3b      	ldr	r3, [r7, #32]
 8010600:	3304      	adds	r3, #4
 8010602:	480a      	ldr	r0, [pc, #40]	; (801062c <J1939_CA_register+0x124>)
 8010604:	4619      	mov	r1, r3
 8010606:	f7ff feef 	bl	80103e8 <j1939_list_insert_before>

	initAddr(ca_msg);
 801060a:	6878      	ldr	r0, [r7, #4]
 801060c:	f001 fc1a 	bl	8011e44 <initAddr>
	return result;
 8010610:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
 8010614:	4618      	mov	r0, r3
 8010616:	3728      	adds	r7, #40	; 0x28
 8010618:	46bd      	mov	sp, r7
 801061a:	bd80      	pop	{r7, pc}
 801061c:	2001277c 	.word	0x2001277c
 8010620:	08026ee0 	.word	0x08026ee0
 8010624:	08026ee4 	.word	0x08026ee4
 8010628:	08026eec 	.word	0x08026eec
 801062c:	20012780 	.word	0x20012780

08010630 <sendData>:

unsigned char sendData(CA_Msg_t CA_msg, unsigned char *data)
{
 8010630:	b580      	push	{r7, lr}
 8010632:	b08e      	sub	sp, #56	; 0x38
 8010634:	af00      	add	r7, sp, #0
 8010636:	6078      	str	r0, [r7, #4]
 8010638:	6039      	str	r1, [r7, #0]
	unsigned char result = RC_SUCCESS;
 801063a:	2300      	movs	r3, #0
 801063c:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
	osEvent event;
	struct J1939_msg j1939_msg;
	unsigned short i;
	q_Message_t qmsg;

	j1939_msg.DataPage = 0;
 8010640:	7b3b      	ldrb	r3, [r7, #12]
 8010642:	f36f 03c3 	bfc	r3, #3, #1
 8010646:	733b      	strb	r3, [r7, #12]
	j1939_msg.edp = 0;
 8010648:	7b3b      	ldrb	r3, [r7, #12]
 801064a:	f36f 1304 	bfc	r3, #4, #1
 801064e:	733b      	strb	r3, [r7, #12]
	j1939_msg.PDUFormat = J1939_PF_DT;
 8010650:	23eb      	movs	r3, #235	; 0xeb
 8010652:	737b      	strb	r3, [r7, #13]
		j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
	else
		j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
	#endif
	
	j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
 8010654:	687b      	ldr	r3, [r7, #4]
 8010656:	799b      	ldrb	r3, [r3, #6]
 8010658:	73bb      	strb	r3, [r7, #14]
	j1939_msg.DataLength = 8;
 801065a:	7c3b      	ldrb	r3, [r7, #16]
 801065c:	2208      	movs	r2, #8
 801065e:	f362 0303 	bfi	r3, r2, #0, #4
 8010662:	743b      	strb	r3, [r7, #16]
	j1939_msg.Priority = 7;
 8010664:	7b3b      	ldrb	r3, [r7, #12]
 8010666:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 801066a:	733b      	strb	r3, [r7, #12]
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
 801066c:	687b      	ldr	r3, [r7, #4]
 801066e:	79db      	ldrb	r3, [r3, #7]
 8010670:	73fb      	strb	r3, [r7, #15]
sendmsg:
	for(i = CA_msg->cm.nextnum; i < (CA_msg->cm.sendnum + CA_msg->cm.nextnum);i++)
 8010672:	687b      	ldr	r3, [r7, #4]
 8010674:	8b1b      	ldrh	r3, [r3, #24]
 8010676:	86fb      	strh	r3, [r7, #54]	; 0x36
 8010678:	e040      	b.n	80106fc <sendData+0xcc>
	{
		unsigned short j;
		j1939_msg.Data[0] = i;
 801067a:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 801067c:	b2db      	uxtb	r3, r3
 801067e:	747b      	strb	r3, [r7, #17]
		for(j = 1; j<8;j++)
 8010680:	2301      	movs	r3, #1
 8010682:	86bb      	strh	r3, [r7, #52]	; 0x34
 8010684:	e026      	b.n	80106d4 <sendData+0xa4>
		{
			unsigned short k;
			k = (i-1)*7+j-1;
 8010686:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8010688:	3b01      	subs	r3, #1
 801068a:	b29b      	uxth	r3, r3
 801068c:	461a      	mov	r2, r3
 801068e:	00d2      	lsls	r2, r2, #3
 8010690:	1ad3      	subs	r3, r2, r3
 8010692:	b29a      	uxth	r2, r3
 8010694:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 8010696:	4413      	add	r3, r2
 8010698:	b29b      	uxth	r3, r3
 801069a:	3b01      	subs	r3, #1
 801069c:	857b      	strh	r3, [r7, #42]	; 0x2a
			if(k < (CA_msg->sendbytes+3))
 801069e:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
 80106a0:	687b      	ldr	r3, [r7, #4]
 80106a2:	8a9b      	ldrh	r3, [r3, #20]
 80106a4:	3303      	adds	r3, #3
 80106a6:	429a      	cmp	r2, r3
 80106a8:	da0a      	bge.n	80106c0 <sendData+0x90>
				j1939_msg.Data[j] = data[k];
 80106aa:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 80106ac:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
 80106ae:	6839      	ldr	r1, [r7, #0]
 80106b0:	440a      	add	r2, r1
 80106b2:	7812      	ldrb	r2, [r2, #0]
 80106b4:	f107 0138 	add.w	r1, r7, #56	; 0x38
 80106b8:	440b      	add	r3, r1
 80106ba:	f803 2c27 	strb.w	r2, [r3, #-39]
 80106be:	e006      	b.n	80106ce <sendData+0x9e>
			else
				j1939_msg.Data[j] = 0xff;
 80106c0:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 80106c2:	f107 0238 	add.w	r2, r7, #56	; 0x38
 80106c6:	4413      	add	r3, r2
 80106c8:	22ff      	movs	r2, #255	; 0xff
 80106ca:	f803 2c27 	strb.w	r2, [r3, #-39]
sendmsg:
	for(i = CA_msg->cm.nextnum; i < (CA_msg->cm.sendnum + CA_msg->cm.nextnum);i++)
	{
		unsigned short j;
		j1939_msg.Data[0] = i;
		for(j = 1; j<8;j++)
 80106ce:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 80106d0:	3301      	adds	r3, #1
 80106d2:	86bb      	strh	r3, [r7, #52]	; 0x34
 80106d4:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 80106d6:	2b07      	cmp	r3, #7
 80106d8:	d9d5      	bls.n	8010686 <sendData+0x56>
				j1939_msg.Data[j] = data[k];
			else
				j1939_msg.Data[j] = 0xff;
		}
		
		if(writeCan(&j1939_msg)!= RC_SUCCESS)
 80106da:	f107 030c 	add.w	r3, r7, #12
 80106de:	4618      	mov	r0, r3
 80106e0:	f001 fbc2 	bl	8011e68 <writeCan>
 80106e4:	4603      	mov	r3, r0
 80106e6:	2b00      	cmp	r3, #0
 80106e8:	d005      	beq.n	80106f6 <sendData+0xc6>
		{
			return result = RC_CANNOTTRANSMIT;
 80106ea:	230a      	movs	r3, #10
 80106ec:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80106f0:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 80106f4:	e049      	b.n	801078a <sendData+0x15a>
	j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
	j1939_msg.DataLength = 8;
	j1939_msg.Priority = 7;
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
sendmsg:
	for(i = CA_msg->cm.nextnum; i < (CA_msg->cm.sendnum + CA_msg->cm.nextnum);i++)
 80106f6:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 80106f8:	3301      	adds	r3, #1
 80106fa:	86fb      	strh	r3, [r7, #54]	; 0x36
 80106fc:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 80106fe:	687b      	ldr	r3, [r7, #4]
 8010700:	8b5b      	ldrh	r3, [r3, #26]
 8010702:	4619      	mov	r1, r3
 8010704:	687b      	ldr	r3, [r7, #4]
 8010706:	8b1b      	ldrh	r3, [r3, #24]
 8010708:	440b      	add	r3, r1
 801070a:	429a      	cmp	r2, r3
 801070c:	dbb5      	blt.n	801067a <sendData+0x4a>
		if(writeCan(&j1939_msg)!= RC_SUCCESS)
		{
			return result = RC_CANNOTTRANSMIT;
		}
	}
	if(i > CA_msg->cm.sendpackets)
 801070e:	687b      	ldr	r3, [r7, #4]
 8010710:	8adb      	ldrh	r3, [r3, #22]
 8010712:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 8010714:	429a      	cmp	r2, r3
 8010716:	d904      	bls.n	8010722 <sendData+0xf2>
	{
		CA_msg->cm.sendcomp = 1;
 8010718:	687b      	ldr	r3, [r7, #4]
 801071a:	2201      	movs	r2, #1
 801071c:	775a      	strb	r2, [r3, #29]
		//rt_kprintf("sendData success\r\n");
		return RC_SUCCESS;
 801071e:	2300      	movs	r3, #0
 8010720:	e033      	b.n	801078a <sendData+0x15a>
	}
	CA_msg->cm.t3.value = T3TIMEOUT;
 8010722:	687b      	ldr	r3, [r7, #4]
 8010724:	f240 42e2 	movw	r2, #1250	; 0x4e2
 8010728:	85da      	strh	r2, [r3, #46]	; 0x2e
	CA_msg->cm.t3.en = 1;
 801072a:	687b      	ldr	r3, [r7, #4]
 801072c:	2201      	movs	r2, #1
 801072e:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
	CA_msg->cm.t3.release = 0;
 8010732:	687b      	ldr	r3, [r7, #4]
 8010734:	2200      	movs	r2, #0
 8010736:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
	event = osMessageGet(CA_msg->txq,WAITFOREVER);
 801073a:	687b      	ldr	r3, [r7, #4]
 801073c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 801073e:	f107 021c 	add.w	r2, r7, #28
 8010742:	4610      	mov	r0, r2
 8010744:	4619      	mov	r1, r3
 8010746:	f04f 32ff 	mov.w	r2, #4294967295
 801074a:	f009 fa23 	bl	8019b94 <osMessageGet>
	qmsg = event.value.p;
 801074e:	6a3b      	ldr	r3, [r7, #32]
 8010750:	62fb      	str	r3, [r7, #44]	; 0x2c
	if(qmsg->timeout == 0)
 8010752:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010754:	889b      	ldrh	r3, [r3, #4]
 8010756:	2b00      	cmp	r3, #0
 8010758:	d112      	bne.n	8010780 <sendData+0x150>
	{
	
		CA_msg->cm.nextnum = qmsg->nextnum;
 801075a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801075c:	881a      	ldrh	r2, [r3, #0]
 801075e:	687b      	ldr	r3, [r7, #4]
 8010760:	831a      	strh	r2, [r3, #24]
		CA_msg->cm.sendnum = qmsg->sendnum;
 8010762:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010764:	885a      	ldrh	r2, [r3, #2]
 8010766:	687b      	ldr	r3, [r7, #4]
 8010768:	835a      	strh	r2, [r3, #26]
		if(CA_msg->cm.nextnum != 0)
 801076a:	687b      	ldr	r3, [r7, #4]
 801076c:	8b1b      	ldrh	r3, [r3, #24]
 801076e:	2b00      	cmp	r3, #0
 8010770:	d000      	beq.n	8010774 <sendData+0x144>
			goto sendmsg;
 8010772:	e77e      	b.n	8010672 <sendData+0x42>
		else
			return result = RC_SUCCESS;
 8010774:	2300      	movs	r3, #0
 8010776:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 801077a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 801077e:	e004      	b.n	801078a <sendData+0x15a>
	}
	else
		return result = RC_TIMEOUT;
 8010780:	230b      	movs	r3, #11
 8010782:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8010786:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
	
}
 801078a:	4618      	mov	r0, r3
 801078c:	3738      	adds	r7, #56	; 0x38
 801078e:	46bd      	mov	sp, r7
 8010790:	bd80      	pop	{r7, pc}
 8010792:	bf00      	nop

08010794 <sendBAM>:


unsigned char sendBAM(CA_Msg_t CA_msg, unsigned char *data)
{
 8010794:	b580      	push	{r7, lr}
 8010796:	b088      	sub	sp, #32
 8010798:	af00      	add	r7, sp, #0
 801079a:	6078      	str	r0, [r7, #4]
 801079c:	6039      	str	r1, [r7, #0]
	
	unsigned char result = RC_SUCCESS;
 801079e:	2300      	movs	r3, #0
 80107a0:	76fb      	strb	r3, [r7, #27]
	struct J1939_msg j1939_msg;
	unsigned char i;

	j1939_msg.Data[0] = J1939_BAM_CONTROL_BYTE;
 80107a2:	2320      	movs	r3, #32
 80107a4:	737b      	strb	r3, [r7, #13]
	j1939_msg.Data[1] = (CA_msg->sendbytes+3+CA_msg->cm.sendpackets)%256;
 80107a6:	687b      	ldr	r3, [r7, #4]
 80107a8:	8a9b      	ldrh	r3, [r3, #20]
 80107aa:	3303      	adds	r3, #3
 80107ac:	687a      	ldr	r2, [r7, #4]
 80107ae:	8ad2      	ldrh	r2, [r2, #22]
 80107b0:	441a      	add	r2, r3
 80107b2:	4b5b      	ldr	r3, [pc, #364]	; (8010920 <sendBAM+0x18c>)
 80107b4:	4013      	ands	r3, r2
 80107b6:	2b00      	cmp	r3, #0
 80107b8:	da03      	bge.n	80107c2 <sendBAM+0x2e>
 80107ba:	3b01      	subs	r3, #1
 80107bc:	f063 03ff 	orn	r3, r3, #255	; 0xff
 80107c0:	3301      	adds	r3, #1
 80107c2:	b2db      	uxtb	r3, r3
 80107c4:	73bb      	strb	r3, [r7, #14]
	j1939_msg.Data[2] = (CA_msg->sendbytes+3+CA_msg->cm.sendpackets)/256;
 80107c6:	687b      	ldr	r3, [r7, #4]
 80107c8:	8a9b      	ldrh	r3, [r3, #20]
 80107ca:	3303      	adds	r3, #3
 80107cc:	687a      	ldr	r2, [r7, #4]
 80107ce:	8ad2      	ldrh	r2, [r2, #22]
 80107d0:	4413      	add	r3, r2
 80107d2:	2b00      	cmp	r3, #0
 80107d4:	da00      	bge.n	80107d8 <sendBAM+0x44>
 80107d6:	33ff      	adds	r3, #255	; 0xff
 80107d8:	121b      	asrs	r3, r3, #8
 80107da:	b2db      	uxtb	r3, r3
 80107dc:	73fb      	strb	r3, [r7, #15]
	j1939_msg.Data[3] = CA_msg->cm.sendpackets;
 80107de:	687b      	ldr	r3, [r7, #4]
 80107e0:	8adb      	ldrh	r3, [r3, #22]
 80107e2:	b2db      	uxtb	r3, r3
 80107e4:	743b      	strb	r3, [r7, #16]
	j1939_msg.Data[4] = 0xff;     /*don't support maxium number of packets*/
 80107e6:	23ff      	movs	r3, #255	; 0xff
 80107e8:	747b      	strb	r3, [r7, #17]
	j1939_msg.Data[5] = CA_msg->msg.PDUSpecific;
 80107ea:	687b      	ldr	r3, [r7, #4]
 80107ec:	799b      	ldrb	r3, [r3, #6]
 80107ee:	74bb      	strb	r3, [r7, #18]
	j1939_msg.Data[6] = CA_msg->msg.PDUFormat;
 80107f0:	687b      	ldr	r3, [r7, #4]
 80107f2:	795b      	ldrb	r3, [r3, #5]
 80107f4:	74fb      	strb	r3, [r7, #19]
	j1939_msg.Data[7] = CA_msg->msg.DataPage;
 80107f6:	687b      	ldr	r3, [r7, #4]
 80107f8:	791b      	ldrb	r3, [r3, #4]
 80107fa:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 80107fe:	b2db      	uxtb	r3, r3
 8010800:	753b      	strb	r3, [r7, #20]
	j1939_msg.DataLength = 8;
 8010802:	7b3b      	ldrb	r3, [r7, #12]
 8010804:	2208      	movs	r2, #8
 8010806:	f362 0303 	bfi	r3, r2, #0, #4
 801080a:	733b      	strb	r3, [r7, #12]
	j1939_msg.DataPage = 0;
 801080c:	7a3b      	ldrb	r3, [r7, #8]
 801080e:	f36f 03c3 	bfc	r3, #3, #1
 8010812:	723b      	strb	r3, [r7, #8]
	j1939_msg.edp = 0;
 8010814:	7a3b      	ldrb	r3, [r7, #8]
 8010816:	f36f 1304 	bfc	r3, #4, #1
 801081a:	723b      	strb	r3, [r7, #8]
	j1939_msg.PDUFormat = J1939_PF_TP_CM;
 801081c:	23ec      	movs	r3, #236	; 0xec
 801081e:	727b      	strb	r3, [r7, #9]
	j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
 8010820:	23ff      	movs	r3, #255	; 0xff
 8010822:	72bb      	strb	r3, [r7, #10]
	j1939_msg.Priority = 7;
 8010824:	7a3b      	ldrb	r3, [r7, #8]
 8010826:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 801082a:	723b      	strb	r3, [r7, #8]
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
 801082c:	687b      	ldr	r3, [r7, #4]
 801082e:	79db      	ldrb	r3, [r3, #7]
 8010830:	72fb      	strb	r3, [r7, #11]
	if(writeCan(&j1939_msg)!= RC_SUCCESS)
 8010832:	f107 0308 	add.w	r3, r7, #8
 8010836:	4618      	mov	r0, r3
 8010838:	f001 fb16 	bl	8011e68 <writeCan>
 801083c:	4603      	mov	r3, r0
 801083e:	2b00      	cmp	r3, #0
 8010840:	d001      	beq.n	8010846 <sendBAM+0xb2>
		return RC_ERROR;
 8010842:	2301      	movs	r3, #1
 8010844:	e067      	b.n	8010916 <sendBAM+0x182>
	
	j1939_msg.DataPage = 0;
 8010846:	7a3b      	ldrb	r3, [r7, #8]
 8010848:	f36f 03c3 	bfc	r3, #3, #1
 801084c:	723b      	strb	r3, [r7, #8]
	j1939_msg.edp = 0;
 801084e:	7a3b      	ldrb	r3, [r7, #8]
 8010850:	f36f 1304 	bfc	r3, #4, #1
 8010854:	723b      	strb	r3, [r7, #8]
	j1939_msg.PDUFormat = J1939_PF_DT;
 8010856:	23eb      	movs	r3, #235	; 0xeb
 8010858:	727b      	strb	r3, [r7, #9]
		j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
	else
		j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
	#endif
	
	j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
 801085a:	23ff      	movs	r3, #255	; 0xff
 801085c:	72bb      	strb	r3, [r7, #10]
	j1939_msg.DataLength = 8;
 801085e:	7b3b      	ldrb	r3, [r7, #12]
 8010860:	2208      	movs	r2, #8
 8010862:	f362 0303 	bfi	r3, r2, #0, #4
 8010866:	733b      	strb	r3, [r7, #12]
	j1939_msg.Priority = 7;
 8010868:	7a3b      	ldrb	r3, [r7, #8]
 801086a:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 801086e:	723b      	strb	r3, [r7, #8]
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
 8010870:	687b      	ldr	r3, [r7, #4]
 8010872:	79db      	ldrb	r3, [r3, #7]
 8010874:	72fb      	strb	r3, [r7, #11]
	
	for(i = 1; (i <= CA_msg->cm.sendpackets) && (i != 0);i++)
 8010876:	2301      	movs	r3, #1
 8010878:	77fb      	strb	r3, [r7, #31]
 801087a:	e040      	b.n	80108fe <sendBAM+0x16a>
	{
		unsigned short j;
		j1939_msg.Data[0] = i;
 801087c:	7ffb      	ldrb	r3, [r7, #31]
 801087e:	737b      	strb	r3, [r7, #13]
		for(j = 1; j<8;j++)
 8010880:	2301      	movs	r3, #1
 8010882:	83bb      	strh	r3, [r7, #28]
 8010884:	e026      	b.n	80108d4 <sendBAM+0x140>
		{
			unsigned short k;
			k = (i-1)*7+j-1;
 8010886:	7ffb      	ldrb	r3, [r7, #31]
 8010888:	3b01      	subs	r3, #1
 801088a:	b29b      	uxth	r3, r3
 801088c:	461a      	mov	r2, r3
 801088e:	00d2      	lsls	r2, r2, #3
 8010890:	1ad3      	subs	r3, r2, r3
 8010892:	b29a      	uxth	r2, r3
 8010894:	8bbb      	ldrh	r3, [r7, #28]
 8010896:	4413      	add	r3, r2
 8010898:	b29b      	uxth	r3, r3
 801089a:	3b01      	subs	r3, #1
 801089c:	833b      	strh	r3, [r7, #24]
			if(k < (CA_msg->sendbytes+3))
 801089e:	8b3a      	ldrh	r2, [r7, #24]
 80108a0:	687b      	ldr	r3, [r7, #4]
 80108a2:	8a9b      	ldrh	r3, [r3, #20]
 80108a4:	3303      	adds	r3, #3
 80108a6:	429a      	cmp	r2, r3
 80108a8:	da0a      	bge.n	80108c0 <sendBAM+0x12c>
				j1939_msg.Data[j] = data[k];
 80108aa:	8bbb      	ldrh	r3, [r7, #28]
 80108ac:	8b3a      	ldrh	r2, [r7, #24]
 80108ae:	6839      	ldr	r1, [r7, #0]
 80108b0:	440a      	add	r2, r1
 80108b2:	7812      	ldrb	r2, [r2, #0]
 80108b4:	f107 0120 	add.w	r1, r7, #32
 80108b8:	440b      	add	r3, r1
 80108ba:	f803 2c13 	strb.w	r2, [r3, #-19]
 80108be:	e006      	b.n	80108ce <sendBAM+0x13a>
			else
				j1939_msg.Data[j] = 0xff;
 80108c0:	8bbb      	ldrh	r3, [r7, #28]
 80108c2:	f107 0220 	add.w	r2, r7, #32
 80108c6:	4413      	add	r3, r2
 80108c8:	22ff      	movs	r2, #255	; 0xff
 80108ca:	f803 2c13 	strb.w	r2, [r3, #-19]
	
	for(i = 1; (i <= CA_msg->cm.sendpackets) && (i != 0);i++)
	{
		unsigned short j;
		j1939_msg.Data[0] = i;
		for(j = 1; j<8;j++)
 80108ce:	8bbb      	ldrh	r3, [r7, #28]
 80108d0:	3301      	adds	r3, #1
 80108d2:	83bb      	strh	r3, [r7, #28]
 80108d4:	8bbb      	ldrh	r3, [r7, #28]
 80108d6:	2b07      	cmp	r3, #7
 80108d8:	d9d5      	bls.n	8010886 <sendBAM+0xf2>
			if(k < (CA_msg->sendbytes+3))
				j1939_msg.Data[j] = data[k];
			else
				j1939_msg.Data[j] = 0xff;
		}
		osDelay(BAMDTTIME);
 80108da:	2037      	movs	r0, #55	; 0x37
 80108dc:	f009 f8d4 	bl	8019a88 <osDelay>
		if(writeCan(&j1939_msg)!= RC_SUCCESS)
 80108e0:	f107 0308 	add.w	r3, r7, #8
 80108e4:	4618      	mov	r0, r3
 80108e6:	f001 fabf 	bl	8011e68 <writeCan>
 80108ea:	4603      	mov	r3, r0
 80108ec:	2b00      	cmp	r3, #0
 80108ee:	d003      	beq.n	80108f8 <sendBAM+0x164>
		{


			return result = RC_CANNOTTRANSMIT;
 80108f0:	230a      	movs	r3, #10
 80108f2:	76fb      	strb	r3, [r7, #27]
 80108f4:	7efb      	ldrb	r3, [r7, #27]
 80108f6:	e00e      	b.n	8010916 <sendBAM+0x182>
	j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
	j1939_msg.DataLength = 8;
	j1939_msg.Priority = 7;
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
	
	for(i = 1; (i <= CA_msg->cm.sendpackets) && (i != 0);i++)
 80108f8:	7ffb      	ldrb	r3, [r7, #31]
 80108fa:	3301      	adds	r3, #1
 80108fc:	77fb      	strb	r3, [r7, #31]
 80108fe:	7ffb      	ldrb	r3, [r7, #31]
 8010900:	b29a      	uxth	r2, r3
 8010902:	687b      	ldr	r3, [r7, #4]
 8010904:	8adb      	ldrh	r3, [r3, #22]
 8010906:	429a      	cmp	r2, r3
 8010908:	d802      	bhi.n	8010910 <sendBAM+0x17c>
 801090a:	7ffb      	ldrb	r3, [r7, #31]
 801090c:	2b00      	cmp	r3, #0
 801090e:	d1b5      	bne.n	801087c <sendBAM+0xe8>

			return result = RC_CANNOTTRANSMIT;
		}
	}
	
	return result = RC_SUCCESS;
 8010910:	2300      	movs	r3, #0
 8010912:	76fb      	strb	r3, [r7, #27]
 8010914:	7efb      	ldrb	r3, [r7, #27]
}
 8010916:	4618      	mov	r0, r3
 8010918:	3720      	adds	r7, #32
 801091a:	46bd      	mov	sp, r7
 801091c:	bd80      	pop	{r7, pc}
 801091e:	bf00      	nop
 8010920:	800000ff 	.word	0x800000ff

08010924 <sendRTS>:

unsigned char sendRTS(CA_Msg_t CA_msg)
{
 8010924:	b580      	push	{r7, lr}
 8010926:	b08c      	sub	sp, #48	; 0x30
 8010928:	af00      	add	r7, sp, #0
 801092a:	6078      	str	r0, [r7, #4]
	q_Message_t qmsg;
	unsigned char result = RC_SUCCESS;
 801092c:	2300      	movs	r3, #0
 801092e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	osEvent event;
	struct J1939_msg j1939_msg;
	j1939_msg.Data[0] = J1939_RTS_CONTROL_BYTE;
 8010932:	2310      	movs	r3, #16
 8010934:	747b      	strb	r3, [r7, #17]
	j1939_msg.Data[1] = (CA_msg->sendbytes+3+CA_msg->cm.sendpackets)%256;
 8010936:	687b      	ldr	r3, [r7, #4]
 8010938:	8a9b      	ldrh	r3, [r3, #20]
 801093a:	3303      	adds	r3, #3
 801093c:	687a      	ldr	r2, [r7, #4]
 801093e:	8ad2      	ldrh	r2, [r2, #22]
 8010940:	441a      	add	r2, r3
 8010942:	4b42      	ldr	r3, [pc, #264]	; (8010a4c <sendRTS+0x128>)
 8010944:	4013      	ands	r3, r2
 8010946:	2b00      	cmp	r3, #0
 8010948:	da03      	bge.n	8010952 <sendRTS+0x2e>
 801094a:	3b01      	subs	r3, #1
 801094c:	f063 03ff 	orn	r3, r3, #255	; 0xff
 8010950:	3301      	adds	r3, #1
 8010952:	b2db      	uxtb	r3, r3
 8010954:	74bb      	strb	r3, [r7, #18]
	j1939_msg.Data[2] = (CA_msg->sendbytes+3+CA_msg->cm.sendpackets)/256;
 8010956:	687b      	ldr	r3, [r7, #4]
 8010958:	8a9b      	ldrh	r3, [r3, #20]
 801095a:	3303      	adds	r3, #3
 801095c:	687a      	ldr	r2, [r7, #4]
 801095e:	8ad2      	ldrh	r2, [r2, #22]
 8010960:	4413      	add	r3, r2
 8010962:	2b00      	cmp	r3, #0
 8010964:	da00      	bge.n	8010968 <sendRTS+0x44>
 8010966:	33ff      	adds	r3, #255	; 0xff
 8010968:	121b      	asrs	r3, r3, #8
 801096a:	b2db      	uxtb	r3, r3
 801096c:	74fb      	strb	r3, [r7, #19]
	j1939_msg.Data[3] = CA_msg->cm.sendpackets;
 801096e:	687b      	ldr	r3, [r7, #4]
 8010970:	8adb      	ldrh	r3, [r3, #22]
 8010972:	b2db      	uxtb	r3, r3
 8010974:	753b      	strb	r3, [r7, #20]
	j1939_msg.Data[4] = 0xff;     /*don't support maxium number of packets*/
 8010976:	23ff      	movs	r3, #255	; 0xff
 8010978:	757b      	strb	r3, [r7, #21]
	j1939_msg.Data[5] = CA_msg->msg.PDUSpecific;
 801097a:	687b      	ldr	r3, [r7, #4]
 801097c:	799b      	ldrb	r3, [r3, #6]
 801097e:	75bb      	strb	r3, [r7, #22]
	j1939_msg.Data[6] = CA_msg->msg.PDUFormat;
 8010980:	687b      	ldr	r3, [r7, #4]
 8010982:	795b      	ldrb	r3, [r3, #5]
 8010984:	75fb      	strb	r3, [r7, #23]
	j1939_msg.Data[7] = CA_msg->msg.DataPage;
 8010986:	687b      	ldr	r3, [r7, #4]
 8010988:	791b      	ldrb	r3, [r3, #4]
 801098a:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 801098e:	b2db      	uxtb	r3, r3
 8010990:	763b      	strb	r3, [r7, #24]
	j1939_msg.DataLength = 8;
 8010992:	7c3b      	ldrb	r3, [r7, #16]
 8010994:	2208      	movs	r2, #8
 8010996:	f362 0303 	bfi	r3, r2, #0, #4
 801099a:	743b      	strb	r3, [r7, #16]
	j1939_msg.DataPage = 0;
 801099c:	7b3b      	ldrb	r3, [r7, #12]
 801099e:	f36f 03c3 	bfc	r3, #3, #1
 80109a2:	733b      	strb	r3, [r7, #12]
	j1939_msg.edp = 0;
 80109a4:	7b3b      	ldrb	r3, [r7, #12]
 80109a6:	f36f 1304 	bfc	r3, #4, #1
 80109aa:	733b      	strb	r3, [r7, #12]
	j1939_msg.PDUFormat = J1939_PF_TP_CM;
 80109ac:	23ec      	movs	r3, #236	; 0xec
 80109ae:	737b      	strb	r3, [r7, #13]
	j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
 80109b0:	687b      	ldr	r3, [r7, #4]
 80109b2:	799b      	ldrb	r3, [r3, #6]
 80109b4:	73bb      	strb	r3, [r7, #14]
	j1939_msg.Priority = 7;
 80109b6:	7b3b      	ldrb	r3, [r7, #12]
 80109b8:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 80109bc:	733b      	strb	r3, [r7, #12]
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
 80109be:	687b      	ldr	r3, [r7, #4]
 80109c0:	79db      	ldrb	r3, [r3, #7]
 80109c2:	73fb      	strb	r3, [r7, #15]
	if(writeCan(&j1939_msg)== RC_SUCCESS)
 80109c4:	f107 030c 	add.w	r3, r7, #12
 80109c8:	4618      	mov	r0, r3
 80109ca:	f001 fa4d 	bl	8011e68 <writeCan>
 80109ce:	4603      	mov	r3, r0
 80109d0:	2b00      	cmp	r3, #0
 80109d2:	d132      	bne.n	8010a3a <sendRTS+0x116>
	{

		CA_msg->cm.t3.value = T3TIMEOUT;
 80109d4:	687b      	ldr	r3, [r7, #4]
 80109d6:	f240 42e2 	movw	r2, #1250	; 0x4e2
 80109da:	85da      	strh	r2, [r3, #46]	; 0x2e
		CA_msg->cm.t3.en = 1;
 80109dc:	687b      	ldr	r3, [r7, #4]
 80109de:	2201      	movs	r2, #1
 80109e0:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
		CA_msg->cm.t3.release = 0;
 80109e4:	687b      	ldr	r3, [r7, #4]
 80109e6:	2200      	movs	r2, #0
 80109e8:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
		event = osMessageGet(CA_msg->txq,WAITFOREVER);
 80109ec:	687b      	ldr	r3, [r7, #4]
 80109ee:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80109f0:	f107 021c 	add.w	r2, r7, #28
 80109f4:	4610      	mov	r0, r2
 80109f6:	4619      	mov	r1, r3
 80109f8:	f04f 32ff 	mov.w	r2, #4294967295
 80109fc:	f009 f8ca 	bl	8019b94 <osMessageGet>
		qmsg = (q_Message_t)event.value.p;
 8010a00:	6a3b      	ldr	r3, [r7, #32]
 8010a02:	62bb      	str	r3, [r7, #40]	; 0x28
		if(qmsg->timeout == 0)
 8010a04:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010a06:	889b      	ldrh	r3, [r3, #4]
 8010a08:	2b00      	cmp	r3, #0
 8010a0a:	d110      	bne.n	8010a2e <sendRTS+0x10a>
		{
			CA_msg->cm.nextnum = qmsg->nextnum;
 8010a0c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010a0e:	881a      	ldrh	r2, [r3, #0]
 8010a10:	687b      	ldr	r3, [r7, #4]
 8010a12:	831a      	strh	r2, [r3, #24]
			CA_msg->cm.sendnum = qmsg->sendnum;
 8010a14:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010a16:	885a      	ldrh	r2, [r3, #2]
 8010a18:	687b      	ldr	r3, [r7, #4]
 8010a1a:	835a      	strh	r2, [r3, #26]
			CA_msg->cm.cm_lock = 1;
 8010a1c:	687b      	ldr	r3, [r7, #4]
 8010a1e:	2201      	movs	r2, #1
 8010a20:	771a      	strb	r2, [r3, #28]
			return result = RC_SUCCESS;
 8010a22:	2300      	movs	r3, #0
 8010a24:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8010a28:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8010a2c:	e00a      	b.n	8010a44 <sendRTS+0x120>
		}
		else
		{
			return result = RC_TIMEOUT;
 8010a2e:	230b      	movs	r3, #11
 8010a30:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8010a34:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8010a38:	e004      	b.n	8010a44 <sendRTS+0x120>
		}
	}
	else
		return result = RC_CANNOTTRANSMIT;
 8010a3a:	230a      	movs	r3, #10
 8010a3c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8010a40:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
}
 8010a44:	4618      	mov	r0, r3
 8010a46:	3730      	adds	r7, #48	; 0x30
 8010a48:	46bd      	mov	sp, r7
 8010a4a:	bd80      	pop	{r7, pc}
 8010a4c:	800000ff 	.word	0x800000ff

08010a50 <sendAbort>:

unsigned char sendAbort(CA_Msg_t CA_msg,unsigned char reason)
{
 8010a50:	b580      	push	{r7, lr}
 8010a52:	b088      	sub	sp, #32
 8010a54:	af00      	add	r7, sp, #0
 8010a56:	6078      	str	r0, [r7, #4]
 8010a58:	460b      	mov	r3, r1
 8010a5a:	70fb      	strb	r3, [r7, #3]
	unsigned char result = RC_SUCCESS;
 8010a5c:	2300      	movs	r3, #0
 8010a5e:	77fb      	strb	r3, [r7, #31]
	struct J1939_msg j1939_msg;
	struct J1939_CM *tempCm;

	
	j1939_msg.Data[0] = J1939_CONNABORT_CONTROL_BYTE;
 8010a60:	23ff      	movs	r3, #255	; 0xff
 8010a62:	737b      	strb	r3, [r7, #13]
	j1939_msg.Data[1] = reason;
 8010a64:	78fb      	ldrb	r3, [r7, #3]
 8010a66:	73bb      	strb	r3, [r7, #14]
	j1939_msg.Data[2] = 0xff;
 8010a68:	23ff      	movs	r3, #255	; 0xff
 8010a6a:	73fb      	strb	r3, [r7, #15]
	j1939_msg.Data[3] = 0xff;
 8010a6c:	23ff      	movs	r3, #255	; 0xff
 8010a6e:	743b      	strb	r3, [r7, #16]
	j1939_msg.Data[4] = 0xff;     /*don't support maxium number of packets*/
 8010a70:	23ff      	movs	r3, #255	; 0xff
 8010a72:	747b      	strb	r3, [r7, #17]
	j1939_msg.Data[5] = CA_msg->msg.PDUSpecific;
 8010a74:	687b      	ldr	r3, [r7, #4]
 8010a76:	799b      	ldrb	r3, [r3, #6]
 8010a78:	74bb      	strb	r3, [r7, #18]
	j1939_msg.Data[6] = CA_msg->msg.PDUFormat;
 8010a7a:	687b      	ldr	r3, [r7, #4]
 8010a7c:	795b      	ldrb	r3, [r3, #5]
 8010a7e:	74fb      	strb	r3, [r7, #19]
	j1939_msg.Data[7] = CA_msg->msg.DataPage;
 8010a80:	687b      	ldr	r3, [r7, #4]
 8010a82:	791b      	ldrb	r3, [r3, #4]
 8010a84:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8010a88:	b2db      	uxtb	r3, r3
 8010a8a:	753b      	strb	r3, [r7, #20]
	j1939_msg.DataLength = 8;
 8010a8c:	7b3b      	ldrb	r3, [r7, #12]
 8010a8e:	2208      	movs	r2, #8
 8010a90:	f362 0303 	bfi	r3, r2, #0, #4
 8010a94:	733b      	strb	r3, [r7, #12]
	j1939_msg.DataPage = 0;
 8010a96:	7a3b      	ldrb	r3, [r7, #8]
 8010a98:	f36f 03c3 	bfc	r3, #3, #1
 8010a9c:	723b      	strb	r3, [r7, #8]
	j1939_msg.edp = 0;
 8010a9e:	7a3b      	ldrb	r3, [r7, #8]
 8010aa0:	f36f 1304 	bfc	r3, #4, #1
 8010aa4:	723b      	strb	r3, [r7, #8]
	j1939_msg.PDUFormat = J1939_PF_TP_CM;
 8010aa6:	23ec      	movs	r3, #236	; 0xec
 8010aa8:	727b      	strb	r3, [r7, #9]
	j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
 8010aaa:	687b      	ldr	r3, [r7, #4]
 8010aac:	799b      	ldrb	r3, [r3, #6]
 8010aae:	72bb      	strb	r3, [r7, #10]
	j1939_msg.Priority = 7;
 8010ab0:	7a3b      	ldrb	r3, [r7, #8]
 8010ab2:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 8010ab6:	723b      	strb	r3, [r7, #8]
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
 8010ab8:	687b      	ldr	r3, [r7, #4]
 8010aba:	79db      	ldrb	r3, [r3, #7]
 8010abc:	72fb      	strb	r3, [r7, #11]
	CA_msg->cm.cm_lock = 0;
 8010abe:	687b      	ldr	r3, [r7, #4]
 8010ac0:	2200      	movs	r2, #0
 8010ac2:	771a      	strb	r2, [r3, #28]
	
	if(writeCan(&j1939_msg)!= RC_SUCCESS)
 8010ac4:	f107 0308 	add.w	r3, r7, #8
 8010ac8:	4618      	mov	r0, r3
 8010aca:	f001 f9cd 	bl	8011e68 <writeCan>
 8010ace:	4603      	mov	r3, r0
 8010ad0:	2b00      	cmp	r3, #0
 8010ad2:	d017      	beq.n	8010b04 <sendAbort+0xb4>
	{
		
		if(CA_msg->rcvdata != NULL)
 8010ad4:	687b      	ldr	r3, [r7, #4]
 8010ad6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010ad8:	2b00      	cmp	r3, #0
 8010ada:	d007      	beq.n	8010aec <sendAbort+0x9c>
		{
			free(CA_msg->rcvdata);
 8010adc:	687b      	ldr	r3, [r7, #4]
 8010ade:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010ae0:	4618      	mov	r0, r3
 8010ae2:	f012 f945 	bl	8022d70 <free>
			CA_msg -> rcvdata = NULL;
 8010ae6:	687b      	ldr	r3, [r7, #4]
 8010ae8:	2200      	movs	r2, #0
 8010aea:	655a      	str	r2, [r3, #84]	; 0x54
		}
		tempCm = &(CA_msg->cm);
 8010aec:	687b      	ldr	r3, [r7, #4]
 8010aee:	3316      	adds	r3, #22
 8010af0:	61bb      	str	r3, [r7, #24]
		memset(tempCm,0,sizeof(struct J1939_CM));
 8010af2:	69b8      	ldr	r0, [r7, #24]
 8010af4:	2100      	movs	r1, #0
 8010af6:	222a      	movs	r2, #42	; 0x2a
 8010af8:	f012 f942 	bl	8022d80 <memset>
		return result = RC_CANNOTTRANSMIT;
 8010afc:	230a      	movs	r3, #10
 8010afe:	77fb      	strb	r3, [r7, #31]
 8010b00:	7ffb      	ldrb	r3, [r7, #31]
 8010b02:	e016      	b.n	8010b32 <sendAbort+0xe2>
	}
	else 
	{
		if(CA_msg->rcvdata != NULL)
 8010b04:	687b      	ldr	r3, [r7, #4]
 8010b06:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010b08:	2b00      	cmp	r3, #0
 8010b0a:	d007      	beq.n	8010b1c <sendAbort+0xcc>
		{
			free(CA_msg->rcvdata);
 8010b0c:	687b      	ldr	r3, [r7, #4]
 8010b0e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010b10:	4618      	mov	r0, r3
 8010b12:	f012 f92d 	bl	8022d70 <free>
			CA_msg->rcvdata = NULL;
 8010b16:	687b      	ldr	r3, [r7, #4]
 8010b18:	2200      	movs	r2, #0
 8010b1a:	655a      	str	r2, [r3, #84]	; 0x54
		}
		tempCm = &(CA_msg->cm);
 8010b1c:	687b      	ldr	r3, [r7, #4]
 8010b1e:	3316      	adds	r3, #22
 8010b20:	61bb      	str	r3, [r7, #24]
		memset(tempCm,0,sizeof(struct J1939_CM));
 8010b22:	69b8      	ldr	r0, [r7, #24]
 8010b24:	2100      	movs	r1, #0
 8010b26:	222a      	movs	r2, #42	; 0x2a
 8010b28:	f012 f92a 	bl	8022d80 <memset>

		return result = RC_SUCCESS;
 8010b2c:	2300      	movs	r3, #0
 8010b2e:	77fb      	strb	r3, [r7, #31]
 8010b30:	7ffb      	ldrb	r3, [r7, #31]
	}
}
 8010b32:	4618      	mov	r0, r3
 8010b34:	3720      	adds	r7, #32
 8010b36:	46bd      	mov	sp, r7
 8010b38:	bd80      	pop	{r7, pc}
 8010b3a:	bf00      	nop

08010b3c <sendMessage>:

unsigned char sendMessage(CA_Msg_t CA_msg, unsigned char *data)
{
 8010b3c:	b580      	push	{r7, lr}
 8010b3e:	b08a      	sub	sp, #40	; 0x28
 8010b40:	af00      	add	r7, sp, #0
 8010b42:	6078      	str	r0, [r7, #4]
 8010b44:	6039      	str	r1, [r7, #0]
	unsigned char i;
	struct J1939_msg j1939_msg;
	unsigned char sa;
	unsigned char result;
	if((sa = CA_FindAddress(&calist,CA_msg)) == 254)
 8010b46:	4892      	ldr	r0, [pc, #584]	; (8010d90 <sendMessage+0x254>)
 8010b48:	6879      	ldr	r1, [r7, #4]
 8010b4a:	f000 ffc9 	bl	8011ae0 <CA_FindAddress>
 8010b4e:	4603      	mov	r3, r0
 8010b50:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 8010b54:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8010b58:	2bfe      	cmp	r3, #254	; 0xfe
 8010b5a:	d101      	bne.n	8010b60 <sendMessage+0x24>
		return RC_ERROR;
 8010b5c:	2301      	movs	r3, #1
 8010b5e:	e112      	b.n	8010d86 <sendMessage+0x24a>
	if (CA_msg->sendbytes <= 8)
 8010b60:	687b      	ldr	r3, [r7, #4]
 8010b62:	8a9b      	ldrh	r3, [r3, #20]
 8010b64:	2b08      	cmp	r3, #8
 8010b66:	d850      	bhi.n	8010c0a <sendMessage+0xce>
	{
		j1939_msg.DataLength = CA_msg->sendbytes;
 8010b68:	687b      	ldr	r3, [r7, #4]
 8010b6a:	8a9b      	ldrh	r3, [r3, #20]
 8010b6c:	b2db      	uxtb	r3, r3
 8010b6e:	f003 030f 	and.w	r3, r3, #15
 8010b72:	b2da      	uxtb	r2, r3
 8010b74:	7c3b      	ldrb	r3, [r7, #16]
 8010b76:	f362 0303 	bfi	r3, r2, #0, #4
 8010b7a:	743b      	strb	r3, [r7, #16]
		j1939_msg.DataPage = CA_msg->msg.DataPage;
 8010b7c:	687b      	ldr	r3, [r7, #4]
 8010b7e:	791b      	ldrb	r3, [r3, #4]
 8010b80:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8010b84:	b2da      	uxtb	r2, r3
 8010b86:	7b3b      	ldrb	r3, [r7, #12]
 8010b88:	f362 03c3 	bfi	r3, r2, #3, #1
 8010b8c:	733b      	strb	r3, [r7, #12]
		j1939_msg.edp = CA_msg->msg.edp;
 8010b8e:	687b      	ldr	r3, [r7, #4]
 8010b90:	791b      	ldrb	r3, [r3, #4]
 8010b92:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8010b96:	b2da      	uxtb	r2, r3
 8010b98:	7b3b      	ldrb	r3, [r7, #12]
 8010b9a:	f362 1304 	bfi	r3, r2, #4, #1
 8010b9e:	733b      	strb	r3, [r7, #12]
		j1939_msg.PDUFormat = CA_msg->msg.PDUFormat;
 8010ba0:	687b      	ldr	r3, [r7, #4]
 8010ba2:	795b      	ldrb	r3, [r3, #5]
 8010ba4:	737b      	strb	r3, [r7, #13]
		j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
 8010ba6:	687b      	ldr	r3, [r7, #4]
 8010ba8:	799b      	ldrb	r3, [r3, #6]
 8010baa:	73bb      	strb	r3, [r7, #14]
		j1939_msg.Priority = CA_msg->msg.Priority;
 8010bac:	687b      	ldr	r3, [r7, #4]
 8010bae:	791b      	ldrb	r3, [r3, #4]
 8010bb0:	f3c3 1342 	ubfx	r3, r3, #5, #3
 8010bb4:	b2da      	uxtb	r2, r3
 8010bb6:	7b3b      	ldrb	r3, [r7, #12]
 8010bb8:	f362 1347 	bfi	r3, r2, #5, #3
 8010bbc:	733b      	strb	r3, [r7, #12]
		j1939_msg.SourceAddress = sa;
 8010bbe:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8010bc2:	73fb      	strb	r3, [r7, #15]
		for (i = 0;i < CA_msg->sendbytes;i++)
 8010bc4:	2300      	movs	r3, #0
 8010bc6:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8010bca:	e010      	b.n	8010bee <sendMessage+0xb2>
			j1939_msg.Data[i] = data[i];
 8010bcc:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8010bd0:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 8010bd4:	6839      	ldr	r1, [r7, #0]
 8010bd6:	440a      	add	r2, r1
 8010bd8:	7812      	ldrb	r2, [r2, #0]
 8010bda:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8010bde:	440b      	add	r3, r1
 8010be0:	f803 2c17 	strb.w	r2, [r3, #-23]
		j1939_msg.edp = CA_msg->msg.edp;
		j1939_msg.PDUFormat = CA_msg->msg.PDUFormat;
		j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
		j1939_msg.Priority = CA_msg->msg.Priority;
		j1939_msg.SourceAddress = sa;
		for (i = 0;i < CA_msg->sendbytes;i++)
 8010be4:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8010be8:	3301      	adds	r3, #1
 8010bea:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8010bee:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8010bf2:	b29a      	uxth	r2, r3
 8010bf4:	687b      	ldr	r3, [r7, #4]
 8010bf6:	8a9b      	ldrh	r3, [r3, #20]
 8010bf8:	429a      	cmp	r2, r3
 8010bfa:	d3e7      	bcc.n	8010bcc <sendMessage+0x90>
			j1939_msg.Data[i] = data[i];
		return writeCan(&j1939_msg);
 8010bfc:	f107 030c 	add.w	r3, r7, #12
 8010c00:	4618      	mov	r0, r3
 8010c02:	f001 f931 	bl	8011e68 <writeCan>
 8010c06:	4603      	mov	r3, r0
 8010c08:	e0bd      	b.n	8010d86 <sendMessage+0x24a>
	else
	{
		unsigned char *tmp;
		unsigned short j,k;
		
		j = ceil(((double)CA_msg->sendbytes + 3)/7);
 8010c0a:	687b      	ldr	r3, [r7, #4]
 8010c0c:	8a9b      	ldrh	r3, [r3, #20]
 8010c0e:	4618      	mov	r0, r3
 8010c10:	f7ef feb8 	bl	8000984 <__aeabi_ui2d>
 8010c14:	4602      	mov	r2, r0
 8010c16:	460b      	mov	r3, r1
 8010c18:	4610      	mov	r0, r2
 8010c1a:	4619      	mov	r1, r3
 8010c1c:	f04f 0200 	mov.w	r2, #0
 8010c20:	4b5c      	ldr	r3, [pc, #368]	; (8010d94 <sendMessage+0x258>)
 8010c22:	f7ef fd73 	bl	800070c <__adddf3>
 8010c26:	4602      	mov	r2, r0
 8010c28:	460b      	mov	r3, r1
 8010c2a:	4610      	mov	r0, r2
 8010c2c:	4619      	mov	r1, r3
 8010c2e:	f04f 0200 	mov.w	r2, #0
 8010c32:	4b59      	ldr	r3, [pc, #356]	; (8010d98 <sendMessage+0x25c>)
 8010c34:	f7f0 f846 	bl	8000cc4 <__aeabi_ddiv>
 8010c38:	4602      	mov	r2, r0
 8010c3a:	460b      	mov	r3, r1
 8010c3c:	ec43 2b17 	vmov	d7, r2, r3
 8010c40:	eeb0 0a47 	vmov.f32	s0, s14
 8010c44:	eef0 0a67 	vmov.f32	s1, s15
 8010c48:	f015 fa4a 	bl	80260e0 <ceil>
 8010c4c:	ec53 2b10 	vmov	r2, r3, d0
 8010c50:	4610      	mov	r0, r2
 8010c52:	4619      	mov	r1, r3
 8010c54:	f7f0 f9a6 	bl	8000fa4 <__aeabi_d2uiz>
 8010c58:	4603      	mov	r3, r0
 8010c5a:	843b      	strh	r3, [r7, #32]
		CA_msg->cm.sendpackets = j;
 8010c5c:	687b      	ldr	r3, [r7, #4]
 8010c5e:	8c3a      	ldrh	r2, [r7, #32]
 8010c60:	82da      	strh	r2, [r3, #22]
		tmp = (unsigned char *)malloc((CA_msg->sendbytes+3) * sizeof(char));
 8010c62:	687b      	ldr	r3, [r7, #4]
 8010c64:	8a9b      	ldrh	r3, [r3, #20]
 8010c66:	3303      	adds	r3, #3
 8010c68:	4618      	mov	r0, r3
 8010c6a:	f012 f879 	bl	8022d60 <malloc>
 8010c6e:	4603      	mov	r3, r0
 8010c70:	61fb      	str	r3, [r7, #28]
		for(k=0;k < (CA_msg->sendbytes);k++)
 8010c72:	2300      	movs	r3, #0
 8010c74:	84bb      	strh	r3, [r7, #36]	; 0x24
 8010c76:	e00a      	b.n	8010c8e <sendMessage+0x152>
		{
				tmp[k] = data[k];
 8010c78:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8010c7a:	69fa      	ldr	r2, [r7, #28]
 8010c7c:	4413      	add	r3, r2
 8010c7e:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8010c80:	6839      	ldr	r1, [r7, #0]
 8010c82:	440a      	add	r2, r1
 8010c84:	7812      	ldrb	r2, [r2, #0]
 8010c86:	701a      	strb	r2, [r3, #0]
		unsigned short j,k;
		
		j = ceil(((double)CA_msg->sendbytes + 3)/7);
		CA_msg->cm.sendpackets = j;
		tmp = (unsigned char *)malloc((CA_msg->sendbytes+3) * sizeof(char));
		for(k=0;k < (CA_msg->sendbytes);k++)
 8010c88:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8010c8a:	3301      	adds	r3, #1
 8010c8c:	84bb      	strh	r3, [r7, #36]	; 0x24
 8010c8e:	687b      	ldr	r3, [r7, #4]
 8010c90:	8a9b      	ldrh	r3, [r3, #20]
 8010c92:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8010c94:	429a      	cmp	r2, r3
 8010c96:	d3ef      	bcc.n	8010c78 <sendMessage+0x13c>
		{
				tmp[k] = data[k];
		}
		tmp[k] = CA_msg->msg.PDUSpecific;
 8010c98:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8010c9a:	69fa      	ldr	r2, [r7, #28]
 8010c9c:	4413      	add	r3, r2
 8010c9e:	687a      	ldr	r2, [r7, #4]
 8010ca0:	7992      	ldrb	r2, [r2, #6]
 8010ca2:	701a      	strb	r2, [r3, #0]
		tmp[k+1] = CA_msg->msg.PDUFormat;
 8010ca4:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8010ca6:	3301      	adds	r3, #1
 8010ca8:	69fa      	ldr	r2, [r7, #28]
 8010caa:	4413      	add	r3, r2
 8010cac:	687a      	ldr	r2, [r7, #4]
 8010cae:	7952      	ldrb	r2, [r2, #5]
 8010cb0:	701a      	strb	r2, [r3, #0]
		tmp[k+2] = CA_msg->msg.DataPage;
 8010cb2:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8010cb4:	3302      	adds	r3, #2
 8010cb6:	69fa      	ldr	r2, [r7, #28]
 8010cb8:	4413      	add	r3, r2
 8010cba:	687a      	ldr	r2, [r7, #4]
 8010cbc:	7912      	ldrb	r2, [r2, #4]
 8010cbe:	f3c2 02c0 	ubfx	r2, r2, #3, #1
 8010cc2:	b2d2      	uxtb	r2, r2
 8010cc4:	701a      	strb	r2, [r3, #0]
		CA_msg->msg.SourceAddress = sa;
 8010cc6:	687b      	ldr	r3, [r7, #4]
 8010cc8:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 8010ccc:	71da      	strb	r2, [r3, #7]
		if(CA_msg->msg.PDUSpecific== J1939_GLOBAL_ADDRESS)
 8010cce:	687b      	ldr	r3, [r7, #4]
 8010cd0:	799b      	ldrb	r3, [r3, #6]
 8010cd2:	2bff      	cmp	r3, #255	; 0xff
 8010cd4:	d107      	bne.n	8010ce6 <sendMessage+0x1aa>
			result = sendBAM(CA_msg,tmp);
 8010cd6:	6878      	ldr	r0, [r7, #4]
 8010cd8:	69f9      	ldr	r1, [r7, #28]
 8010cda:	f7ff fd5b 	bl	8010794 <sendBAM>
 8010cde:	4603      	mov	r3, r0
 8010ce0:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
 8010ce4:	e045      	b.n	8010d72 <sendMessage+0x236>
		else
		{
			
			result = sendRTS(CA_msg);
 8010ce6:	6878      	ldr	r0, [r7, #4]
 8010ce8:	f7ff fe1c 	bl	8010924 <sendRTS>
 8010cec:	4603      	mov	r3, r0
 8010cee:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
			if(result == RC_SUCCESS)
 8010cf2:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8010cf6:	2b00      	cmp	r3, #0
 8010cf8:	d119      	bne.n	8010d2e <sendMessage+0x1f2>
			{
				result = sendData(CA_msg, tmp);
 8010cfa:	6878      	ldr	r0, [r7, #4]
 8010cfc:	69f9      	ldr	r1, [r7, #28]
 8010cfe:	f7ff fc97 	bl	8010630 <sendData>
 8010d02:	4603      	mov	r3, r0
 8010d04:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
				if(result != RC_SUCCESS )
 8010d08:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8010d0c:	2b00      	cmp	r3, #0
 8010d0e:	d003      	beq.n	8010d18 <sendMessage+0x1dc>
					sendAbort(CA_msg, 0);
 8010d10:	6878      	ldr	r0, [r7, #4]
 8010d12:	2100      	movs	r1, #0
 8010d14:	f7ff fe9c 	bl	8010a50 <sendAbort>
				if(tmp != NULL)
 8010d18:	69fb      	ldr	r3, [r7, #28]
 8010d1a:	2b00      	cmp	r3, #0
 8010d1c:	d004      	beq.n	8010d28 <sendMessage+0x1ec>
				{
					free(tmp);
 8010d1e:	69f8      	ldr	r0, [r7, #28]
 8010d20:	f012 f826 	bl	8022d70 <free>
					tmp = NULL;
 8010d24:	2300      	movs	r3, #0
 8010d26:	61fb      	str	r3, [r7, #28]
				}
				return result;
 8010d28:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8010d2c:	e02b      	b.n	8010d86 <sendMessage+0x24a>
			}
			else if(result == RC_TIMEOUT)
 8010d2e:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8010d32:	2b0b      	cmp	r3, #11
 8010d34:	d10e      	bne.n	8010d54 <sendMessage+0x218>
			{
				if(tmp != NULL)
 8010d36:	69fb      	ldr	r3, [r7, #28]
 8010d38:	2b00      	cmp	r3, #0
 8010d3a:	d004      	beq.n	8010d46 <sendMessage+0x20a>
				{
					free(tmp);
 8010d3c:	69f8      	ldr	r0, [r7, #28]
 8010d3e:	f012 f817 	bl	8022d70 <free>
					tmp = NULL;
 8010d42:	2300      	movs	r3, #0
 8010d44:	61fb      	str	r3, [r7, #28]
				}
				sendAbort(CA_msg,0);
 8010d46:	6878      	ldr	r0, [r7, #4]
 8010d48:	2100      	movs	r1, #0
 8010d4a:	f7ff fe81 	bl	8010a50 <sendAbort>
				return result;
 8010d4e:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8010d52:	e018      	b.n	8010d86 <sendMessage+0x24a>
			}
			else if(result == RC_CANNOTTRANSMIT)
 8010d54:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8010d58:	2b0a      	cmp	r3, #10
 8010d5a:	d10a      	bne.n	8010d72 <sendMessage+0x236>
			{
				if(tmp != NULL)
 8010d5c:	69fb      	ldr	r3, [r7, #28]
 8010d5e:	2b00      	cmp	r3, #0
 8010d60:	d004      	beq.n	8010d6c <sendMessage+0x230>
				{
					free(tmp);
 8010d62:	69f8      	ldr	r0, [r7, #28]
 8010d64:	f012 f804 	bl	8022d70 <free>
					tmp = NULL;
 8010d68:	2300      	movs	r3, #0
 8010d6a:	61fb      	str	r3, [r7, #28]
				}
				return result;
 8010d6c:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8010d70:	e009      	b.n	8010d86 <sendMessage+0x24a>
			}
		}

		if(tmp != NULL)
 8010d72:	69fb      	ldr	r3, [r7, #28]
 8010d74:	2b00      	cmp	r3, #0
 8010d76:	d004      	beq.n	8010d82 <sendMessage+0x246>
		{
			free(tmp);
 8010d78:	69f8      	ldr	r0, [r7, #28]
 8010d7a:	f011 fff9 	bl	8022d70 <free>
			tmp = NULL;
 8010d7e:	2300      	movs	r3, #0
 8010d80:	61fb      	str	r3, [r7, #28]
		}
	}
	return result;
 8010d82:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
}
 8010d86:	4618      	mov	r0, r3
 8010d88:	3728      	adds	r7, #40	; 0x28
 8010d8a:	46bd      	mov	sp, r7
 8010d8c:	bd80      	pop	{r7, pc}
 8010d8e:	bf00      	nop
 8010d90:	2001277c 	.word	0x2001277c
 8010d94:	40080000 	.word	0x40080000
 8010d98:	401c0000 	.word	0x401c0000

08010d9c <checkRes>:


unsigned char checkRes()
{
 8010d9c:	b480      	push	{r7}
 8010d9e:	af00      	add	r7, sp, #0
	return RC_SUCCESS;
 8010da0:	2300      	movs	r3, #0
}
 8010da2:	4618      	mov	r0, r3
 8010da4:	46bd      	mov	sp, r7
 8010da6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010daa:	4770      	bx	lr

08010dac <sendCTS>:

unsigned char sendCTS(J1939_msg_t j1939_msg,CA_Msg_t CA_msg,unsigned int startnum,unsigned int num)
{
 8010dac:	b580      	push	{r7, lr}
 8010dae:	b08a      	sub	sp, #40	; 0x28
 8010db0:	af00      	add	r7, sp, #0
 8010db2:	60f8      	str	r0, [r7, #12]
 8010db4:	60b9      	str	r1, [r7, #8]
 8010db6:	607a      	str	r2, [r7, #4]
 8010db8:	603b      	str	r3, [r7, #0]
	struct J1939_msg temp_msg;
	unsigned char result;
	temp_msg.DataLength = j1939_msg->DataLength;
 8010dba:	68fb      	ldr	r3, [r7, #12]
 8010dbc:	791b      	ldrb	r3, [r3, #4]
 8010dbe:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8010dc2:	b2da      	uxtb	r2, r3
 8010dc4:	7e3b      	ldrb	r3, [r7, #24]
 8010dc6:	f362 0303 	bfi	r3, r2, #0, #4
 8010dca:	763b      	strb	r3, [r7, #24]
	temp_msg.DataPage = j1939_msg->DataPage;
 8010dcc:	68fb      	ldr	r3, [r7, #12]
 8010dce:	781b      	ldrb	r3, [r3, #0]
 8010dd0:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8010dd4:	b2da      	uxtb	r2, r3
 8010dd6:	7d3b      	ldrb	r3, [r7, #20]
 8010dd8:	f362 03c3 	bfi	r3, r2, #3, #1
 8010ddc:	753b      	strb	r3, [r7, #20]
	temp_msg.edp = j1939_msg->edp;
 8010dde:	68fb      	ldr	r3, [r7, #12]
 8010de0:	781b      	ldrb	r3, [r3, #0]
 8010de2:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8010de6:	b2da      	uxtb	r2, r3
 8010de8:	7d3b      	ldrb	r3, [r7, #20]
 8010dea:	f362 1304 	bfi	r3, r2, #4, #1
 8010dee:	753b      	strb	r3, [r7, #20]
	temp_msg.PDUFormat = j1939_msg->PDUFormat;
 8010df0:	68fb      	ldr	r3, [r7, #12]
 8010df2:	785b      	ldrb	r3, [r3, #1]
 8010df4:	757b      	strb	r3, [r7, #21]
	temp_msg.PDUSpecific = j1939_msg->SourceAddress;
 8010df6:	68fb      	ldr	r3, [r7, #12]
 8010df8:	78db      	ldrb	r3, [r3, #3]
 8010dfa:	75bb      	strb	r3, [r7, #22]
	temp_msg.Priority = j1939_msg->Priority;
 8010dfc:	68fb      	ldr	r3, [r7, #12]
 8010dfe:	781b      	ldrb	r3, [r3, #0]
 8010e00:	f3c3 1342 	ubfx	r3, r3, #5, #3
 8010e04:	b2da      	uxtb	r2, r3
 8010e06:	7d3b      	ldrb	r3, [r7, #20]
 8010e08:	f362 1347 	bfi	r3, r2, #5, #3
 8010e0c:	753b      	strb	r3, [r7, #20]
	temp_msg.SourceAddress = j1939_msg->PDUSpecific;
 8010e0e:	68fb      	ldr	r3, [r7, #12]
 8010e10:	789b      	ldrb	r3, [r3, #2]
 8010e12:	75fb      	strb	r3, [r7, #23]
	temp_msg.Data[0] = J1939_CTS_CONTROL_BYTE;
 8010e14:	2311      	movs	r3, #17
 8010e16:	767b      	strb	r3, [r7, #25]
	if(j1939_msg->Data[4] < j1939_msg->Data[3])
		temp_msg.Data[1] = j1939_msg->Data[4];
	else
		temp_msg.Data[1] = j1939_msg->Data[3];
#endif
	temp_msg.Data[1] = num;
 8010e18:	683b      	ldr	r3, [r7, #0]
 8010e1a:	b2db      	uxtb	r3, r3
 8010e1c:	76bb      	strb	r3, [r7, #26]
	temp_msg.Data[2] = startnum;
 8010e1e:	687b      	ldr	r3, [r7, #4]
 8010e20:	b2db      	uxtb	r3, r3
 8010e22:	76fb      	strb	r3, [r7, #27]
	temp_msg.Data[3] = 0xff;
 8010e24:	23ff      	movs	r3, #255	; 0xff
 8010e26:	773b      	strb	r3, [r7, #28]
	temp_msg.Data[4] = 0xff;
 8010e28:	23ff      	movs	r3, #255	; 0xff
 8010e2a:	777b      	strb	r3, [r7, #29]
	temp_msg.Data[5] = CA_msg->cm.DTPS;
 8010e2c:	68bb      	ldr	r3, [r7, #8]
 8010e2e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8010e32:	77bb      	strb	r3, [r7, #30]
	temp_msg.Data[6] = CA_msg->cm.DTPF;
 8010e34:	68bb      	ldr	r3, [r7, #8]
 8010e36:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8010e3a:	77fb      	strb	r3, [r7, #31]
	temp_msg.Data[7] = CA_msg->cm.DTDP;
 8010e3c:	68bb      	ldr	r3, [r7, #8]
 8010e3e:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 8010e42:	f887 3020 	strb.w	r3, [r7, #32]
	
	if(writeCan(&temp_msg) == RC_SUCCESS)
 8010e46:	f107 0314 	add.w	r3, r7, #20
 8010e4a:	4618      	mov	r0, r3
 8010e4c:	f001 f80c 	bl	8011e68 <writeCan>
 8010e50:	4603      	mov	r3, r0
 8010e52:	2b00      	cmp	r3, #0
 8010e54:	d111      	bne.n	8010e7a <sendCTS+0xce>
	{
		CA_msg->cm.t2.en = 1;
 8010e56:	68bb      	ldr	r3, [r7, #8]
 8010e58:	2201      	movs	r2, #1
 8010e5a:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
		CA_msg->cm.t2.release = 0;
 8010e5e:	68bb      	ldr	r3, [r7, #8]
 8010e60:	2200      	movs	r2, #0
 8010e62:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
		CA_msg->cm.t2.value = T2TIMEOUT;
 8010e66:	68bb      	ldr	r3, [r7, #8]
 8010e68:	f240 42e2 	movw	r2, #1250	; 0x4e2
 8010e6c:	855a      	strh	r2, [r3, #42]	; 0x2a
		return result = RC_SUCCESS;
 8010e6e:	2300      	movs	r3, #0
 8010e70:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8010e74:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8010e78:	e004      	b.n	8010e84 <sendCTS+0xd8>
	}
	else
		return result = RC_CANNOTTRANSMIT;
 8010e7a:	230a      	movs	r3, #10
 8010e7c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8010e80:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
 8010e84:	4618      	mov	r0, r3
 8010e86:	3728      	adds	r7, #40	; 0x28
 8010e88:	46bd      	mov	sp, r7
 8010e8a:	bd80      	pop	{r7, pc}

08010e8c <response_RTS>:

unsigned char response_RTS(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 8010e8c:	b580      	push	{r7, lr}
 8010e8e:	b084      	sub	sp, #16
 8010e90:	af00      	add	r7, sp, #0
 8010e92:	6078      	str	r0, [r7, #4]
 8010e94:	6039      	str	r1, [r7, #0]
	unsigned char result = RC_SUCCESS;
 8010e96:	2300      	movs	r3, #0
 8010e98:	73fb      	strb	r3, [r7, #15]
	
	if(j1939_msg->PDUSpecific == J1939_GLOBAL_ADDRESS)
 8010e9a:	687b      	ldr	r3, [r7, #4]
 8010e9c:	789b      	ldrb	r3, [r3, #2]
 8010e9e:	2bff      	cmp	r3, #255	; 0xff
 8010ea0:	d103      	bne.n	8010eaa <response_RTS+0x1e>
		return result = RC_ERROR;
 8010ea2:	2301      	movs	r3, #1
 8010ea4:	73fb      	strb	r3, [r7, #15]
 8010ea6:	7bfb      	ldrb	r3, [r7, #15]
 8010ea8:	e04f      	b.n	8010f4a <response_RTS+0xbe>
	if(checkRes() == RC_SUCCESS && CA_msg->cm.cm_lock == 0)
 8010eaa:	f7ff ff77 	bl	8010d9c <checkRes>
 8010eae:	4603      	mov	r3, r0
 8010eb0:	2b00      	cmp	r3, #0
 8010eb2:	d147      	bne.n	8010f44 <response_RTS+0xb8>
 8010eb4:	683b      	ldr	r3, [r7, #0]
 8010eb6:	7f1b      	ldrb	r3, [r3, #28]
 8010eb8:	2b00      	cmp	r3, #0
 8010eba:	d143      	bne.n	8010f44 <response_RTS+0xb8>
	{
		rt_kprintf("receive rts packets = %d\r\n", j1939_msg->Data[3]);
 8010ebc:	687b      	ldr	r3, [r7, #4]
 8010ebe:	7a1b      	ldrb	r3, [r3, #8]
 8010ec0:	4824      	ldr	r0, [pc, #144]	; (8010f54 <response_RTS+0xc8>)
 8010ec2:	4619      	mov	r1, r3
 8010ec4:	f006 fcfa 	bl	80178bc <rt_kprintf>
		CA_msg->cm.rcvpackets = j1939_msg->Data[3];
 8010ec8:	687b      	ldr	r3, [r7, #4]
 8010eca:	7a1b      	ldrb	r3, [r3, #8]
 8010ecc:	b29a      	uxth	r2, r3
 8010ece:	683b      	ldr	r3, [r7, #0]
 8010ed0:	86da      	strh	r2, [r3, #54]	; 0x36
		CA_msg->cm.rcvbytes = j1939_msg->Data[2]*256+j1939_msg->Data[1];
 8010ed2:	687b      	ldr	r3, [r7, #4]
 8010ed4:	79db      	ldrb	r3, [r3, #7]
 8010ed6:	b29b      	uxth	r3, r3
 8010ed8:	021b      	lsls	r3, r3, #8
 8010eda:	b29a      	uxth	r2, r3
 8010edc:	687b      	ldr	r3, [r7, #4]
 8010ede:	799b      	ldrb	r3, [r3, #6]
 8010ee0:	b29b      	uxth	r3, r3
 8010ee2:	4413      	add	r3, r2
 8010ee4:	b29a      	uxth	r2, r3
 8010ee6:	683b      	ldr	r3, [r7, #0]
 8010ee8:	871a      	strh	r2, [r3, #56]	; 0x38
		CA_msg->rcvdata = (unsigned char *)malloc(7 * CA_msg->cm.rcvpackets);
 8010eea:	683b      	ldr	r3, [r7, #0]
 8010eec:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8010eee:	461a      	mov	r2, r3
 8010ef0:	4613      	mov	r3, r2
 8010ef2:	00db      	lsls	r3, r3, #3
 8010ef4:	1a9b      	subs	r3, r3, r2
 8010ef6:	4618      	mov	r0, r3
 8010ef8:	f011 ff32 	bl	8022d60 <malloc>
 8010efc:	4603      	mov	r3, r0
 8010efe:	461a      	mov	r2, r3
 8010f00:	683b      	ldr	r3, [r7, #0]
 8010f02:	655a      	str	r2, [r3, #84]	; 0x54
		CA_msg->cm.DTDP = j1939_msg->DataPage;
 8010f04:	687b      	ldr	r3, [r7, #4]
 8010f06:	781b      	ldrb	r3, [r3, #0]
 8010f08:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8010f0c:	b2db      	uxtb	r3, r3
 8010f0e:	461a      	mov	r2, r3
 8010f10:	683b      	ldr	r3, [r7, #0]
 8010f12:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
		CA_msg->cm.DTPF = j1939_msg->PDUFormat;
 8010f16:	687b      	ldr	r3, [r7, #4]
 8010f18:	785a      	ldrb	r2, [r3, #1]
 8010f1a:	683b      	ldr	r3, [r7, #0]
 8010f1c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
		CA_msg->cm.DTPS = j1939_msg->PDUSpecific;
 8010f20:	687b      	ldr	r3, [r7, #4]
 8010f22:	789a      	ldrb	r2, [r3, #2]
 8010f24:	683b      	ldr	r3, [r7, #0]
 8010f26:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
				sendCTS(j1939_msg,CA_msg,1,j1939_msg->Data[3] );
			else 
				sendCTS(j1939_msg,CA_msg,1,8);
		#endif 
		
		sendCTS(j1939_msg,CA_msg,1,1);
 8010f2a:	6878      	ldr	r0, [r7, #4]
 8010f2c:	6839      	ldr	r1, [r7, #0]
 8010f2e:	2201      	movs	r2, #1
 8010f30:	2301      	movs	r3, #1
 8010f32:	f7ff ff3b 	bl	8010dac <sendCTS>
		CA_msg->cm.cm_lock = 1;
 8010f36:	683b      	ldr	r3, [r7, #0]
 8010f38:	2201      	movs	r2, #1
 8010f3a:	771a      	strb	r2, [r3, #28]
		return result = RC_SUCCESS;
 8010f3c:	2300      	movs	r3, #0
 8010f3e:	73fb      	strb	r3, [r7, #15]
 8010f40:	7bfb      	ldrb	r3, [r7, #15]
 8010f42:	e002      	b.n	8010f4a <response_RTS+0xbe>
	}
	return result = RC_ERROR;
 8010f44:	2301      	movs	r3, #1
 8010f46:	73fb      	strb	r3, [r7, #15]
 8010f48:	7bfb      	ldrb	r3, [r7, #15]
}
 8010f4a:	4618      	mov	r0, r3
 8010f4c:	3710      	adds	r7, #16
 8010f4e:	46bd      	mov	sp, r7
 8010f50:	bd80      	pop	{r7, pc}
 8010f52:	bf00      	nop
 8010f54:	08026ef0 	.word	0x08026ef0

08010f58 <response_CTS>:


unsigned char response_CTS(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 8010f58:	b580      	push	{r7, lr}
 8010f5a:	b084      	sub	sp, #16
 8010f5c:	af00      	add	r7, sp, #0
 8010f5e:	6078      	str	r0, [r7, #4]
 8010f60:	6039      	str	r1, [r7, #0]
	unsigned char result = RC_SUCCESS;
 8010f62:	2300      	movs	r3, #0
 8010f64:	73fb      	strb	r3, [r7, #15]
	static struct q_Message q_msg;
	if(j1939_msg->PDUSpecific == J1939_GLOBAL_ADDRESS)
 8010f66:	687b      	ldr	r3, [r7, #4]
 8010f68:	789b      	ldrb	r3, [r3, #2]
 8010f6a:	2bff      	cmp	r3, #255	; 0xff
 8010f6c:	d103      	bne.n	8010f76 <response_CTS+0x1e>
		return result = RC_ERROR;
 8010f6e:	2301      	movs	r3, #1
 8010f70:	73fb      	strb	r3, [r7, #15]
 8010f72:	7bfb      	ldrb	r3, [r7, #15]
 8010f74:	e045      	b.n	8011002 <response_CTS+0xaa>
	if(CA_msg->cm.t3.en == 0 && CA_msg->cm.t4.en == 0)
 8010f76:	683b      	ldr	r3, [r7, #0]
 8010f78:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8010f7c:	2b00      	cmp	r3, #0
 8010f7e:	d108      	bne.n	8010f92 <response_CTS+0x3a>
 8010f80:	683b      	ldr	r3, [r7, #0]
 8010f82:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8010f86:	2b00      	cmp	r3, #0
 8010f88:	d103      	bne.n	8010f92 <response_CTS+0x3a>
		return result = RC_ERROR;
 8010f8a:	2301      	movs	r3, #1
 8010f8c:	73fb      	strb	r3, [r7, #15]
 8010f8e:	7bfb      	ldrb	r3, [r7, #15]
 8010f90:	e037      	b.n	8011002 <response_CTS+0xaa>
	CA_msg->cm.t3.release = 1;
 8010f92:	683b      	ldr	r3, [r7, #0]
 8010f94:	2201      	movs	r2, #1
 8010f96:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
	CA_msg->cm.t4.release = 1;
 8010f9a:	683b      	ldr	r3, [r7, #0]
 8010f9c:	2201      	movs	r2, #1
 8010f9e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
	if(j1939_msg->Data[1] == 0 && j1939_msg->Data[2] == 255)
 8010fa2:	687b      	ldr	r3, [r7, #4]
 8010fa4:	799b      	ldrb	r3, [r3, #6]
 8010fa6:	2b00      	cmp	r3, #0
 8010fa8:	d113      	bne.n	8010fd2 <response_CTS+0x7a>
 8010faa:	687b      	ldr	r3, [r7, #4]
 8010fac:	79db      	ldrb	r3, [r3, #7]
 8010fae:	2bff      	cmp	r3, #255	; 0xff
 8010fb0:	d10f      	bne.n	8010fd2 <response_CTS+0x7a>
	{
		CA_msg->cm.t4.en = 1;
 8010fb2:	683b      	ldr	r3, [r7, #0]
 8010fb4:	2201      	movs	r2, #1
 8010fb6:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
		CA_msg->cm.t4.release = 0;
 8010fba:	683b      	ldr	r3, [r7, #0]
 8010fbc:	2200      	movs	r2, #0
 8010fbe:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
		CA_msg->cm.t4.value = 1050;
 8010fc2:	683b      	ldr	r3, [r7, #0]
 8010fc4:	f240 421a 	movw	r2, #1050	; 0x41a
 8010fc8:	865a      	strh	r2, [r3, #50]	; 0x32
		return result = RC_ERROR;
 8010fca:	2301      	movs	r3, #1
 8010fcc:	73fb      	strb	r3, [r7, #15]
 8010fce:	7bfb      	ldrb	r3, [r7, #15]
 8010fd0:	e017      	b.n	8011002 <response_CTS+0xaa>
	}
	else
	{
		q_msg.nextnum = j1939_msg->Data[2];
 8010fd2:	687b      	ldr	r3, [r7, #4]
 8010fd4:	79db      	ldrb	r3, [r3, #7]
 8010fd6:	b29a      	uxth	r2, r3
 8010fd8:	4b0c      	ldr	r3, [pc, #48]	; (801100c <response_CTS+0xb4>)
 8010fda:	801a      	strh	r2, [r3, #0]
		q_msg.sendnum = j1939_msg->Data[1];
 8010fdc:	687b      	ldr	r3, [r7, #4]
 8010fde:	799b      	ldrb	r3, [r3, #6]
 8010fe0:	b29a      	uxth	r2, r3
 8010fe2:	4b0a      	ldr	r3, [pc, #40]	; (801100c <response_CTS+0xb4>)
 8010fe4:	805a      	strh	r2, [r3, #2]
		q_msg.timeout = 0;
 8010fe6:	4b09      	ldr	r3, [pc, #36]	; (801100c <response_CTS+0xb4>)
 8010fe8:	2200      	movs	r2, #0
 8010fea:	809a      	strh	r2, [r3, #4]
		osMessagePut(CA_msg->txq,(unsigned long)&q_msg, 0);
 8010fec:	683b      	ldr	r3, [r7, #0]
 8010fee:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8010ff0:	4a06      	ldr	r2, [pc, #24]	; (801100c <response_CTS+0xb4>)
 8010ff2:	4618      	mov	r0, r3
 8010ff4:	4611      	mov	r1, r2
 8010ff6:	2200      	movs	r2, #0
 8010ff8:	f008 fdb4 	bl	8019b64 <osMessagePut>
		return result = RC_SUCCESS;
 8010ffc:	2300      	movs	r3, #0
 8010ffe:	73fb      	strb	r3, [r7, #15]
 8011000:	7bfb      	ldrb	r3, [r7, #15]
	}
}
 8011002:	4618      	mov	r0, r3
 8011004:	3710      	adds	r7, #16
 8011006:	46bd      	mov	sp, r7
 8011008:	bd80      	pop	{r7, pc}
 801100a:	bf00      	nop
 801100c:	200107b8 	.word	0x200107b8

08011010 <sendEndofMsgACK>:
unsigned char sendEndofMsgACK(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 8011010:	b580      	push	{r7, lr}
 8011012:	b088      	sub	sp, #32
 8011014:	af00      	add	r7, sp, #0
 8011016:	6078      	str	r0, [r7, #4]
 8011018:	6039      	str	r1, [r7, #0]
	struct J1939_msg temp_j1939;
	struct J1939_CM *tempCm;
	
	temp_j1939.DataLength = 8;
 801101a:	7c3b      	ldrb	r3, [r7, #16]
 801101c:	2208      	movs	r2, #8
 801101e:	f362 0303 	bfi	r3, r2, #0, #4
 8011022:	743b      	strb	r3, [r7, #16]
	temp_j1939.DataPage = 0;
 8011024:	7b3b      	ldrb	r3, [r7, #12]
 8011026:	f36f 03c3 	bfc	r3, #3, #1
 801102a:	733b      	strb	r3, [r7, #12]
	temp_j1939.edp = 0;
 801102c:	7b3b      	ldrb	r3, [r7, #12]
 801102e:	f36f 1304 	bfc	r3, #4, #1
 8011032:	733b      	strb	r3, [r7, #12]
	temp_j1939.PDUFormat = J1939_PF_TP_CM;
 8011034:	23ec      	movs	r3, #236	; 0xec
 8011036:	737b      	strb	r3, [r7, #13]
	temp_j1939.PDUSpecific = j1939_msg->SourceAddress;
 8011038:	687b      	ldr	r3, [r7, #4]
 801103a:	78db      	ldrb	r3, [r3, #3]
 801103c:	73bb      	strb	r3, [r7, #14]
	temp_j1939.Priority = 7;
 801103e:	7b3b      	ldrb	r3, [r7, #12]
 8011040:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 8011044:	733b      	strb	r3, [r7, #12]
	temp_j1939.SourceAddress = j1939_msg->PDUSpecific;
 8011046:	687b      	ldr	r3, [r7, #4]
 8011048:	789b      	ldrb	r3, [r3, #2]
 801104a:	73fb      	strb	r3, [r7, #15]
	temp_j1939.Data[0] = J1939_EOMACK_CONTROL_BYTE;
 801104c:	2313      	movs	r3, #19
 801104e:	747b      	strb	r3, [r7, #17]
	temp_j1939.Data[1] = CA_msg->cm.rcvbytes % 256;
 8011050:	683b      	ldr	r3, [r7, #0]
 8011052:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8011054:	b2db      	uxtb	r3, r3
 8011056:	74bb      	strb	r3, [r7, #18]
	temp_j1939.Data[2] = CA_msg->cm.rcvbytes / 256;
 8011058:	683b      	ldr	r3, [r7, #0]
 801105a:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 801105c:	0a1b      	lsrs	r3, r3, #8
 801105e:	b29b      	uxth	r3, r3
 8011060:	b2db      	uxtb	r3, r3
 8011062:	74fb      	strb	r3, [r7, #19]
	temp_j1939.Data[3] = CA_msg->cm.rcvpackets;
 8011064:	683b      	ldr	r3, [r7, #0]
 8011066:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8011068:	b2db      	uxtb	r3, r3
 801106a:	753b      	strb	r3, [r7, #20]
	temp_j1939.Data[4] = 0xff;
 801106c:	23ff      	movs	r3, #255	; 0xff
 801106e:	757b      	strb	r3, [r7, #21]
	temp_j1939.Data[5] = j1939_msg->Data[5];
 8011070:	687b      	ldr	r3, [r7, #4]
 8011072:	7a9b      	ldrb	r3, [r3, #10]
 8011074:	75bb      	strb	r3, [r7, #22]
	temp_j1939.Data[6] = j1939_msg->Data[6];
 8011076:	687b      	ldr	r3, [r7, #4]
 8011078:	7adb      	ldrb	r3, [r3, #11]
 801107a:	75fb      	strb	r3, [r7, #23]
	temp_j1939.Data[7] = j1939_msg->Data[7];
 801107c:	687b      	ldr	r3, [r7, #4]
 801107e:	7b1b      	ldrb	r3, [r3, #12]
 8011080:	763b      	strb	r3, [r7, #24]
	CA_msg->cm.cm_lock = 0;
 8011082:	683b      	ldr	r3, [r7, #0]
 8011084:	2200      	movs	r2, #0
 8011086:	771a      	strb	r2, [r3, #28]
	if(CA_msg->rcvdata != NULL)
 8011088:	683b      	ldr	r3, [r7, #0]
 801108a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801108c:	2b00      	cmp	r3, #0
 801108e:	d007      	beq.n	80110a0 <sendEndofMsgACK+0x90>
	{
		free(CA_msg->rcvdata);
 8011090:	683b      	ldr	r3, [r7, #0]
 8011092:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8011094:	4618      	mov	r0, r3
 8011096:	f011 fe6b 	bl	8022d70 <free>
		CA_msg->rcvdata = NULL;
 801109a:	683b      	ldr	r3, [r7, #0]
 801109c:	2200      	movs	r2, #0
 801109e:	655a      	str	r2, [r3, #84]	; 0x54
	}
	tempCm = &(CA_msg->cm);
 80110a0:	683b      	ldr	r3, [r7, #0]
 80110a2:	3316      	adds	r3, #22
 80110a4:	61fb      	str	r3, [r7, #28]
	memset(tempCm,0,sizeof(struct J1939_CM));
 80110a6:	69f8      	ldr	r0, [r7, #28]
 80110a8:	2100      	movs	r1, #0
 80110aa:	222a      	movs	r2, #42	; 0x2a
 80110ac:	f011 fe68 	bl	8022d80 <memset>
	return writeCan(&temp_j1939);
 80110b0:	f107 030c 	add.w	r3, r7, #12
 80110b4:	4618      	mov	r0, r3
 80110b6:	f000 fed7 	bl	8011e68 <writeCan>
 80110ba:	4603      	mov	r3, r0
}
 80110bc:	4618      	mov	r0, r3
 80110be:	3720      	adds	r7, #32
 80110c0:	46bd      	mov	sp, r7
 80110c2:	bd80      	pop	{r7, pc}

080110c4 <receiveData>:

void receiveData(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 80110c4:	b580      	push	{r7, lr}
 80110c6:	b084      	sub	sp, #16
 80110c8:	af00      	add	r7, sp, #0
 80110ca:	6078      	str	r0, [r7, #4]
 80110cc:	6039      	str	r1, [r7, #0]
	unsigned char i;
	static struct rx_Message rxmsg,bamrxmsg;
	unsigned short j;
	if((j1939_msg->PDUSpecific == J1939_GLOBAL_ADDRESS) )
 80110ce:	687b      	ldr	r3, [r7, #4]
 80110d0:	789b      	ldrb	r3, [r3, #2]
 80110d2:	2bff      	cmp	r3, #255	; 0xff
 80110d4:	f040 8092 	bne.w	80111fc <receiveData+0x138>
	{
		if((CA_msg->bam.cm_lock == 1) && (CA_msg->bamrcvdata != NULL))
 80110d8:	683b      	ldr	r3, [r7, #0]
 80110da:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 80110de:	2b01      	cmp	r3, #1
 80110e0:	f040 8143 	bne.w	801136a <receiveData+0x2a6>
 80110e4:	683b      	ldr	r3, [r7, #0]
 80110e6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80110e8:	2b00      	cmp	r3, #0
 80110ea:	f000 813e 	beq.w	801136a <receiveData+0x2a6>
		{
			CA_msg->bam.t1.en = 1;
 80110ee:	683b      	ldr	r3, [r7, #0]
 80110f0:	2201      	movs	r2, #1
 80110f2:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
			CA_msg->bam.t1.release = 1;
 80110f6:	683b      	ldr	r3, [r7, #0]
 80110f8:	2201      	movs	r2, #1
 80110fa:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			CA_msg->bam.t1.value = 0;
 80110fe:	683b      	ldr	r3, [r7, #0]
 8011100:	2200      	movs	r2, #0
 8011102:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42

				
			for(i=1;i<j1939_msg->DataLength;i++)
 8011106:	2301      	movs	r3, #1
 8011108:	73fb      	strb	r3, [r7, #15]
 801110a:	e013      	b.n	8011134 <receiveData+0x70>
			{
				CA_msg->bamrcvdata[7*(j1939_msg->Data[0]-1)+i-1] = j1939_msg->Data[i];
 801110c:	683b      	ldr	r3, [r7, #0]
 801110e:	6d99      	ldr	r1, [r3, #88]	; 0x58
 8011110:	687b      	ldr	r3, [r7, #4]
 8011112:	795b      	ldrb	r3, [r3, #5]
 8011114:	1e5a      	subs	r2, r3, #1
 8011116:	4613      	mov	r3, r2
 8011118:	00db      	lsls	r3, r3, #3
 801111a:	1a9a      	subs	r2, r3, r2
 801111c:	7bfb      	ldrb	r3, [r7, #15]
 801111e:	4413      	add	r3, r2
 8011120:	3b01      	subs	r3, #1
 8011122:	440b      	add	r3, r1
 8011124:	7bfa      	ldrb	r2, [r7, #15]
 8011126:	6879      	ldr	r1, [r7, #4]
 8011128:	440a      	add	r2, r1
 801112a:	7952      	ldrb	r2, [r2, #5]
 801112c:	701a      	strb	r2, [r3, #0]
			CA_msg->bam.t1.en = 1;
			CA_msg->bam.t1.release = 1;
			CA_msg->bam.t1.value = 0;

				
			for(i=1;i<j1939_msg->DataLength;i++)
 801112e:	7bfb      	ldrb	r3, [r7, #15]
 8011130:	3301      	adds	r3, #1
 8011132:	73fb      	strb	r3, [r7, #15]
 8011134:	7bfb      	ldrb	r3, [r7, #15]
 8011136:	687a      	ldr	r2, [r7, #4]
 8011138:	7912      	ldrb	r2, [r2, #4]
 801113a:	f3c2 0203 	ubfx	r2, r2, #0, #4
 801113e:	b2d2      	uxtb	r2, r2
 8011140:	4293      	cmp	r3, r2
 8011142:	dbe3      	blt.n	801110c <receiveData+0x48>
			{
				CA_msg->bamrcvdata[7*(j1939_msg->Data[0]-1)+i-1] = j1939_msg->Data[i];
			}
			
			if(j1939_msg->Data[0] >= CA_msg->bam.rcvpackets)
 8011144:	687b      	ldr	r3, [r7, #4]
 8011146:	795b      	ldrb	r3, [r3, #5]
 8011148:	b29a      	uxth	r2, r3
 801114a:	683b      	ldr	r3, [r7, #0]
 801114c:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 8011150:	429a      	cmp	r2, r3
 8011152:	d345      	bcc.n	80111e0 <receiveData+0x11c>
			{
				bamrxmsg.data = CA_msg->bamrcvdata;
 8011154:	683b      	ldr	r3, [r7, #0]
 8011156:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8011158:	4a85      	ldr	r2, [pc, #532]	; (8011370 <receiveData+0x2ac>)
 801115a:	6013      	str	r3, [r2, #0]
				j = 7 * CA_msg->bam.rcvpackets - 1;
 801115c:	683b      	ldr	r3, [r7, #0]
 801115e:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 8011162:	461a      	mov	r2, r3
 8011164:	00d2      	lsls	r2, r2, #3
 8011166:	1ad3      	subs	r3, r2, r3
 8011168:	b29b      	uxth	r3, r3
 801116a:	3b01      	subs	r3, #1
 801116c:	81bb      	strh	r3, [r7, #12]
				while(bamrxmsg.data[j] == 0xff)
 801116e:	e002      	b.n	8011176 <receiveData+0xb2>
					j--;
 8011170:	89bb      	ldrh	r3, [r7, #12]
 8011172:	3b01      	subs	r3, #1
 8011174:	81bb      	strh	r3, [r7, #12]
			
			if(j1939_msg->Data[0] >= CA_msg->bam.rcvpackets)
			{
				bamrxmsg.data = CA_msg->bamrcvdata;
				j = 7 * CA_msg->bam.rcvpackets - 1;
				while(bamrxmsg.data[j] == 0xff)
 8011176:	4b7e      	ldr	r3, [pc, #504]	; (8011370 <receiveData+0x2ac>)
 8011178:	681a      	ldr	r2, [r3, #0]
 801117a:	89bb      	ldrh	r3, [r7, #12]
 801117c:	4413      	add	r3, r2
 801117e:	781b      	ldrb	r3, [r3, #0]
 8011180:	2bff      	cmp	r3, #255	; 0xff
 8011182:	d0f5      	beq.n	8011170 <receiveData+0xac>
					j--;
				bamrxmsg.dp = bamrxmsg.data[j];
 8011184:	4b7a      	ldr	r3, [pc, #488]	; (8011370 <receiveData+0x2ac>)
 8011186:	681a      	ldr	r2, [r3, #0]
 8011188:	89bb      	ldrh	r3, [r7, #12]
 801118a:	4413      	add	r3, r2
 801118c:	781a      	ldrb	r2, [r3, #0]
 801118e:	4b78      	ldr	r3, [pc, #480]	; (8011370 <receiveData+0x2ac>)
 8011190:	721a      	strb	r2, [r3, #8]
				bamrxmsg.PF = bamrxmsg.data[j-1];
 8011192:	4b77      	ldr	r3, [pc, #476]	; (8011370 <receiveData+0x2ac>)
 8011194:	681a      	ldr	r2, [r3, #0]
 8011196:	89bb      	ldrh	r3, [r7, #12]
 8011198:	3b01      	subs	r3, #1
 801119a:	4413      	add	r3, r2
 801119c:	781a      	ldrb	r2, [r3, #0]
 801119e:	4b74      	ldr	r3, [pc, #464]	; (8011370 <receiveData+0x2ac>)
 80111a0:	71da      	strb	r2, [r3, #7]
				bamrxmsg.PS = bamrxmsg.data[j-2];
 80111a2:	4b73      	ldr	r3, [pc, #460]	; (8011370 <receiveData+0x2ac>)
 80111a4:	681a      	ldr	r2, [r3, #0]
 80111a6:	89bb      	ldrh	r3, [r7, #12]
 80111a8:	3b02      	subs	r3, #2
 80111aa:	4413      	add	r3, r2
 80111ac:	781a      	ldrb	r2, [r3, #0]
 80111ae:	4b70      	ldr	r3, [pc, #448]	; (8011370 <receiveData+0x2ac>)
 80111b0:	719a      	strb	r2, [r3, #6]
				bamrxmsg.size = j-2;
 80111b2:	89bb      	ldrh	r3, [r7, #12]
 80111b4:	3b02      	subs	r3, #2
 80111b6:	b29a      	uxth	r2, r3
 80111b8:	4b6d      	ldr	r3, [pc, #436]	; (8011370 <receiveData+0x2ac>)
 80111ba:	809a      	strh	r2, [r3, #4]
				rt_kprintf("\nbam receive %d data:\r\n", bamrxmsg.size);
 80111bc:	4b6c      	ldr	r3, [pc, #432]	; (8011370 <receiveData+0x2ac>)
 80111be:	889b      	ldrh	r3, [r3, #4]
 80111c0:	486c      	ldr	r0, [pc, #432]	; (8011374 <receiveData+0x2b0>)
 80111c2:	4619      	mov	r1, r3
 80111c4:	f006 fb7a 	bl	80178bc <rt_kprintf>
				bamAbort(CA_msg);
 80111c8:	6838      	ldr	r0, [r7, #0]
 80111ca:	f000 fa37 	bl	801163c <bamAbort>
				osMessagePut(CA_msg->rxq, (unsigned long)&bamrxmsg, 0);
 80111ce:	683b      	ldr	r3, [r7, #0]
 80111d0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80111d2:	4a67      	ldr	r2, [pc, #412]	; (8011370 <receiveData+0x2ac>)
 80111d4:	4618      	mov	r0, r3
 80111d6:	4611      	mov	r1, r2
 80111d8:	2200      	movs	r2, #0
 80111da:	f008 fcc3 	bl	8019b64 <osMessagePut>
 80111de:	e0c4      	b.n	801136a <receiveData+0x2a6>
				*/

			}
			else
			{
					CA_msg->bam.t1.en = 1;
 80111e0:	683b      	ldr	r3, [r7, #0]
 80111e2:	2201      	movs	r2, #1
 80111e4:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
					CA_msg->bam.t1.release = 0;
 80111e8:	683b      	ldr	r3, [r7, #0]
 80111ea:	2200      	movs	r2, #0
 80111ec:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
					CA_msg->bam.t1.value = T1TIMEOUT;
 80111f0:	683b      	ldr	r3, [r7, #0]
 80111f2:	f240 22ee 	movw	r2, #750	; 0x2ee
 80111f6:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
 80111fa:	e0b6      	b.n	801136a <receiveData+0x2a6>
		}

	}
	else
	{
		if((CA_msg->cm.cm_lock == 1) &&  (CA_msg->rcvdata != NULL))
 80111fc:	683b      	ldr	r3, [r7, #0]
 80111fe:	7f1b      	ldrb	r3, [r3, #28]
 8011200:	2b01      	cmp	r3, #1
 8011202:	f040 80b2 	bne.w	801136a <receiveData+0x2a6>
 8011206:	683b      	ldr	r3, [r7, #0]
 8011208:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801120a:	2b00      	cmp	r3, #0
 801120c:	f000 80ad 	beq.w	801136a <receiveData+0x2a6>
		{
		
			CA_msg->cm.t1.en = 1;
 8011210:	683b      	ldr	r3, [r7, #0]
 8011212:	2201      	movs	r2, #1
 8011214:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
			CA_msg->cm.t1.release = 1;
 8011218:	683b      	ldr	r3, [r7, #0]
 801121a:	2201      	movs	r2, #1
 801121c:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
			CA_msg->cm.t1.value = 0;
 8011220:	683b      	ldr	r3, [r7, #0]
 8011222:	2200      	movs	r2, #0
 8011224:	84da      	strh	r2, [r3, #38]	; 0x26


			CA_msg->cm.t2.en = 1;
 8011226:	683b      	ldr	r3, [r7, #0]
 8011228:	2201      	movs	r2, #1
 801122a:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
			CA_msg->cm.t2.release = 1;
 801122e:	683b      	ldr	r3, [r7, #0]
 8011230:	2201      	movs	r2, #1
 8011232:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
			CA_msg->cm.t2.value = 0;
 8011236:	683b      	ldr	r3, [r7, #0]
 8011238:	2200      	movs	r2, #0
 801123a:	855a      	strh	r2, [r3, #42]	; 0x2a



			for(i=1;i<j1939_msg->DataLength;i++)
 801123c:	2301      	movs	r3, #1
 801123e:	73fb      	strb	r3, [r7, #15]
 8011240:	e013      	b.n	801126a <receiveData+0x1a6>
			{
				CA_msg->rcvdata[7*(j1939_msg->Data[0]-1)+i-1] = j1939_msg->Data[i];
 8011242:	683b      	ldr	r3, [r7, #0]
 8011244:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8011246:	687b      	ldr	r3, [r7, #4]
 8011248:	795b      	ldrb	r3, [r3, #5]
 801124a:	1e5a      	subs	r2, r3, #1
 801124c:	4613      	mov	r3, r2
 801124e:	00db      	lsls	r3, r3, #3
 8011250:	1a9a      	subs	r2, r3, r2
 8011252:	7bfb      	ldrb	r3, [r7, #15]
 8011254:	4413      	add	r3, r2
 8011256:	3b01      	subs	r3, #1
 8011258:	440b      	add	r3, r1
 801125a:	7bfa      	ldrb	r2, [r7, #15]
 801125c:	6879      	ldr	r1, [r7, #4]
 801125e:	440a      	add	r2, r1
 8011260:	7952      	ldrb	r2, [r2, #5]
 8011262:	701a      	strb	r2, [r3, #0]
			CA_msg->cm.t2.release = 1;
			CA_msg->cm.t2.value = 0;



			for(i=1;i<j1939_msg->DataLength;i++)
 8011264:	7bfb      	ldrb	r3, [r7, #15]
 8011266:	3301      	adds	r3, #1
 8011268:	73fb      	strb	r3, [r7, #15]
 801126a:	7bfb      	ldrb	r3, [r7, #15]
 801126c:	687a      	ldr	r2, [r7, #4]
 801126e:	7912      	ldrb	r2, [r2, #4]
 8011270:	f3c2 0203 	ubfx	r2, r2, #0, #4
 8011274:	b2d2      	uxtb	r2, r2
 8011276:	4293      	cmp	r3, r2
 8011278:	dbe3      	blt.n	8011242 <receiveData+0x17e>
			{
				CA_msg->rcvdata[7*(j1939_msg->Data[0]-1)+i-1] = j1939_msg->Data[i];
			}

			rt_kprintf("Data[0] = %d, rcvpackets = %d\r\n", j1939_msg->Data[0], CA_msg->cm.rcvpackets);
 801127a:	687b      	ldr	r3, [r7, #4]
 801127c:	795b      	ldrb	r3, [r3, #5]
 801127e:	461a      	mov	r2, r3
 8011280:	683b      	ldr	r3, [r7, #0]
 8011282:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8011284:	483c      	ldr	r0, [pc, #240]	; (8011378 <receiveData+0x2b4>)
 8011286:	4611      	mov	r1, r2
 8011288:	461a      	mov	r2, r3
 801128a:	f006 fb17 	bl	80178bc <rt_kprintf>


			if(j1939_msg->Data[0] >= CA_msg->cm.rcvpackets)
 801128e:	687b      	ldr	r3, [r7, #4]
 8011290:	795b      	ldrb	r3, [r3, #5]
 8011292:	b29a      	uxth	r2, r3
 8011294:	683b      	ldr	r3, [r7, #0]
 8011296:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8011298:	429a      	cmp	r2, r3
 801129a:	d345      	bcc.n	8011328 <receiveData+0x264>
			{
				rxmsg.data = CA_msg->rcvdata;
 801129c:	683b      	ldr	r3, [r7, #0]
 801129e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80112a0:	4a36      	ldr	r2, [pc, #216]	; (801137c <receiveData+0x2b8>)
 80112a2:	6013      	str	r3, [r2, #0]
				j = 7 * CA_msg->cm.rcvpackets - 1;
 80112a4:	683b      	ldr	r3, [r7, #0]
 80112a6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 80112a8:	461a      	mov	r2, r3
 80112aa:	00d2      	lsls	r2, r2, #3
 80112ac:	1ad3      	subs	r3, r2, r3
 80112ae:	b29b      	uxth	r3, r3
 80112b0:	3b01      	subs	r3, #1
 80112b2:	81bb      	strh	r3, [r7, #12]
				while(rxmsg.data[j] == 0xff)
 80112b4:	e002      	b.n	80112bc <receiveData+0x1f8>
					j--;
 80112b6:	89bb      	ldrh	r3, [r7, #12]
 80112b8:	3b01      	subs	r3, #1
 80112ba:	81bb      	strh	r3, [r7, #12]

			if(j1939_msg->Data[0] >= CA_msg->cm.rcvpackets)
			{
				rxmsg.data = CA_msg->rcvdata;
				j = 7 * CA_msg->cm.rcvpackets - 1;
				while(rxmsg.data[j] == 0xff)
 80112bc:	4b2f      	ldr	r3, [pc, #188]	; (801137c <receiveData+0x2b8>)
 80112be:	681a      	ldr	r2, [r3, #0]
 80112c0:	89bb      	ldrh	r3, [r7, #12]
 80112c2:	4413      	add	r3, r2
 80112c4:	781b      	ldrb	r3, [r3, #0]
 80112c6:	2bff      	cmp	r3, #255	; 0xff
 80112c8:	d0f5      	beq.n	80112b6 <receiveData+0x1f2>
					j--;
				rxmsg.dp = rxmsg.data[j];
 80112ca:	4b2c      	ldr	r3, [pc, #176]	; (801137c <receiveData+0x2b8>)
 80112cc:	681a      	ldr	r2, [r3, #0]
 80112ce:	89bb      	ldrh	r3, [r7, #12]
 80112d0:	4413      	add	r3, r2
 80112d2:	781a      	ldrb	r2, [r3, #0]
 80112d4:	4b29      	ldr	r3, [pc, #164]	; (801137c <receiveData+0x2b8>)
 80112d6:	721a      	strb	r2, [r3, #8]
				rxmsg.PF = rxmsg.data[j-1];
 80112d8:	4b28      	ldr	r3, [pc, #160]	; (801137c <receiveData+0x2b8>)
 80112da:	681a      	ldr	r2, [r3, #0]
 80112dc:	89bb      	ldrh	r3, [r7, #12]
 80112de:	3b01      	subs	r3, #1
 80112e0:	4413      	add	r3, r2
 80112e2:	781a      	ldrb	r2, [r3, #0]
 80112e4:	4b25      	ldr	r3, [pc, #148]	; (801137c <receiveData+0x2b8>)
 80112e6:	71da      	strb	r2, [r3, #7]
				rxmsg.PS = rxmsg.data[j-2];
 80112e8:	4b24      	ldr	r3, [pc, #144]	; (801137c <receiveData+0x2b8>)
 80112ea:	681a      	ldr	r2, [r3, #0]
 80112ec:	89bb      	ldrh	r3, [r7, #12]
 80112ee:	3b02      	subs	r3, #2
 80112f0:	4413      	add	r3, r2
 80112f2:	781a      	ldrb	r2, [r3, #0]
 80112f4:	4b21      	ldr	r3, [pc, #132]	; (801137c <receiveData+0x2b8>)
 80112f6:	719a      	strb	r2, [r3, #6]
				rxmsg.size = j-2;
 80112f8:	89bb      	ldrh	r3, [r7, #12]
 80112fa:	3b02      	subs	r3, #2
 80112fc:	b29a      	uxth	r2, r3
 80112fe:	4b1f      	ldr	r3, [pc, #124]	; (801137c <receiveData+0x2b8>)
 8011300:	809a      	strh	r2, [r3, #4]
				rt_kprintf("\nDT receive %d data:\r\n", rxmsg.size);
 8011302:	4b1e      	ldr	r3, [pc, #120]	; (801137c <receiveData+0x2b8>)
 8011304:	889b      	ldrh	r3, [r3, #4]
 8011306:	481e      	ldr	r0, [pc, #120]	; (8011380 <receiveData+0x2bc>)
 8011308:	4619      	mov	r1, r3
 801130a:	f006 fad7 	bl	80178bc <rt_kprintf>
				osMessagePut(CA_msg->rxq, (unsigned long)&rxmsg, 0);
 801130e:	683b      	ldr	r3, [r7, #0]
 8011310:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8011312:	4a1a      	ldr	r2, [pc, #104]	; (801137c <receiveData+0x2b8>)
 8011314:	4618      	mov	r0, r3
 8011316:	4611      	mov	r1, r2
 8011318:	2200      	movs	r2, #0
 801131a:	f008 fc23 	bl	8019b64 <osMessagePut>
				
				//if(j1939_msg->PDUSpecific != J1939_GLOBAL_ADDRESS)
				//{
				sendEndofMsgACK(j1939_msg ,CA_msg);
 801131e:	6878      	ldr	r0, [r7, #4]
 8011320:	6839      	ldr	r1, [r7, #0]
 8011322:	f7ff fe75 	bl	8011010 <sendEndofMsgACK>
 8011326:	e020      	b.n	801136a <receiveData+0x2a6>
				//}
			}
			else 
			{
				j1939_msg->PDUFormat = J1939_PF_TP_CM;
 8011328:	687b      	ldr	r3, [r7, #4]
 801132a:	22ec      	movs	r2, #236	; 0xec
 801132c:	705a      	strb	r2, [r3, #1]
				j1939_msg->Priority = 7;
 801132e:	687a      	ldr	r2, [r7, #4]
 8011330:	7813      	ldrb	r3, [r2, #0]
 8011332:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 8011336:	7013      	strb	r3, [r2, #0]
				j1939_msg->DataPage = 0;
 8011338:	687a      	ldr	r2, [r7, #4]
 801133a:	7813      	ldrb	r3, [r2, #0]
 801133c:	f36f 03c3 	bfc	r3, #3, #1
 8011340:	7013      	strb	r3, [r2, #0]
				j1939_msg->edp = 0;
 8011342:	687a      	ldr	r2, [r7, #4]
 8011344:	7813      	ldrb	r3, [r2, #0]
 8011346:	f36f 1304 	bfc	r3, #4, #1
 801134a:	7013      	strb	r3, [r2, #0]
				j1939_msg->DataLength = 8;
 801134c:	687a      	ldr	r2, [r7, #4]
 801134e:	7913      	ldrb	r3, [r2, #4]
 8011350:	2108      	movs	r1, #8
 8011352:	f361 0303 	bfi	r3, r1, #0, #4
 8011356:	7113      	strb	r3, [r2, #4]
		
				sendCTS(j1939_msg,CA_msg,j1939_msg->Data[0]+1,1);
 8011358:	687b      	ldr	r3, [r7, #4]
 801135a:	795b      	ldrb	r3, [r3, #5]
 801135c:	3301      	adds	r3, #1
 801135e:	6878      	ldr	r0, [r7, #4]
 8011360:	6839      	ldr	r1, [r7, #0]
 8011362:	461a      	mov	r2, r3
 8011364:	2301      	movs	r3, #1
 8011366:	f7ff fd21 	bl	8010dac <sendCTS>
			}
		}
		#endif
		}
	}
}
 801136a:	3710      	adds	r7, #16
 801136c:	46bd      	mov	sp, r7
 801136e:	bd80      	pop	{r7, pc}
 8011370:	200107c0 	.word	0x200107c0
 8011374:	08026f0c 	.word	0x08026f0c
 8011378:	08026f24 	.word	0x08026f24
 801137c:	200107cc 	.word	0x200107cc
 8011380:	08026f44 	.word	0x08026f44

08011384 <responseEndofMsgACK>:

void responseEndofMsgACK(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 8011384:	b580      	push	{r7, lr}
 8011386:	b082      	sub	sp, #8
 8011388:	af00      	add	r7, sp, #0
 801138a:	6078      	str	r0, [r7, #4]
 801138c:	6039      	str	r1, [r7, #0]
	//if(CA_msg->cm.sendcomp == 1)
	//{
		rt_kprintf("receive endOfMsgAck\r\n");
 801138e:	4810      	ldr	r0, [pc, #64]	; (80113d0 <responseEndofMsgACK+0x4c>)
 8011390:	f006 fa94 	bl	80178bc <rt_kprintf>
		//osEnter_critical();
		if(CA_msg->rcvdata != NULL)
 8011394:	683b      	ldr	r3, [r7, #0]
 8011396:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8011398:	2b00      	cmp	r3, #0
 801139a:	d007      	beq.n	80113ac <responseEndofMsgACK+0x28>
		{
			free(CA_msg->rcvdata);
 801139c:	683b      	ldr	r3, [r7, #0]
 801139e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80113a0:	4618      	mov	r0, r3
 80113a2:	f011 fce5 	bl	8022d70 <free>
			CA_msg->rcvdata = NULL;
 80113a6:	683b      	ldr	r3, [r7, #0]
 80113a8:	2200      	movs	r2, #0
 80113aa:	655a      	str	r2, [r3, #84]	; 0x54
		}
		//osExit_critical();
		CA_msg->cm.cm_lock = 0;
 80113ac:	683b      	ldr	r3, [r7, #0]
 80113ae:	2200      	movs	r2, #0
 80113b0:	771a      	strb	r2, [r3, #28]
		CA_msg->cm.nextnum = 0;
 80113b2:	683b      	ldr	r3, [r7, #0]
 80113b4:	2200      	movs	r2, #0
 80113b6:	831a      	strh	r2, [r3, #24]
		CA_msg->cm.sendcomp = 0;
 80113b8:	683b      	ldr	r3, [r7, #0]
 80113ba:	2200      	movs	r2, #0
 80113bc:	775a      	strb	r2, [r3, #29]
		CA_msg->cm.sendpackets = 0;
 80113be:	683b      	ldr	r3, [r7, #0]
 80113c0:	2200      	movs	r2, #0
 80113c2:	82da      	strh	r2, [r3, #22]
		CA_msg->sendbytes = 0;
 80113c4:	683b      	ldr	r3, [r7, #0]
 80113c6:	2200      	movs	r2, #0
 80113c8:	829a      	strh	r2, [r3, #20]
	//}
}
 80113ca:	3708      	adds	r7, #8
 80113cc:	46bd      	mov	sp, r7
 80113ce:	bd80      	pop	{r7, pc}
 80113d0:	08026f5c 	.word	0x08026f5c

080113d4 <responseBAM>:
void responseBAM(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 80113d4:	b580      	push	{r7, lr}
 80113d6:	b082      	sub	sp, #8
 80113d8:	af00      	add	r7, sp, #0
 80113da:	6078      	str	r0, [r7, #4]
 80113dc:	6039      	str	r1, [r7, #0]
	if(j1939_msg->PDUSpecific == J1939_GLOBAL_ADDRESS)
 80113de:	687b      	ldr	r3, [r7, #4]
 80113e0:	789b      	ldrb	r3, [r3, #2]
 80113e2:	2bff      	cmp	r3, #255	; 0xff
 80113e4:	d13e      	bne.n	8011464 <responseBAM+0x90>
	{
		rt_kprintf("receive bam\r\n");
 80113e6:	4821      	ldr	r0, [pc, #132]	; (801146c <responseBAM+0x98>)
 80113e8:	f006 fa68 	bl	80178bc <rt_kprintf>
		if(checkRes() == RC_SUCCESS && CA_msg->bam.cm_lock == 0)
 80113ec:	f7ff fcd6 	bl	8010d9c <checkRes>
 80113f0:	4603      	mov	r3, r0
 80113f2:	2b00      	cmp	r3, #0
 80113f4:	d136      	bne.n	8011464 <responseBAM+0x90>
 80113f6:	683b      	ldr	r3, [r7, #0]
 80113f8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 80113fc:	2b00      	cmp	r3, #0
 80113fe:	d131      	bne.n	8011464 <responseBAM+0x90>
		{
			CA_msg->bam.rcvpackets = j1939_msg->Data[3];
 8011400:	687b      	ldr	r3, [r7, #4]
 8011402:	7a1b      	ldrb	r3, [r3, #8]
 8011404:	b29a      	uxth	r2, r3
 8011406:	683b      	ldr	r3, [r7, #0]
 8011408:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
			CA_msg->bam.rcvbytes = j1939_msg->Data[2]*256+j1939_msg->Data[1];
 801140c:	687b      	ldr	r3, [r7, #4]
 801140e:	79db      	ldrb	r3, [r3, #7]
 8011410:	b29b      	uxth	r3, r3
 8011412:	021b      	lsls	r3, r3, #8
 8011414:	b29a      	uxth	r2, r3
 8011416:	687b      	ldr	r3, [r7, #4]
 8011418:	799b      	ldrb	r3, [r3, #6]
 801141a:	b29b      	uxth	r3, r3
 801141c:	4413      	add	r3, r2
 801141e:	b29a      	uxth	r2, r3
 8011420:	683b      	ldr	r3, [r7, #0]
 8011422:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
			CA_msg->bamrcvdata = (unsigned char *)malloc(7 * CA_msg->bam.rcvpackets );
 8011426:	683b      	ldr	r3, [r7, #0]
 8011428:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 801142c:	461a      	mov	r2, r3
 801142e:	4613      	mov	r3, r2
 8011430:	00db      	lsls	r3, r3, #3
 8011432:	1a9b      	subs	r3, r3, r2
 8011434:	4618      	mov	r0, r3
 8011436:	f011 fc93 	bl	8022d60 <malloc>
 801143a:	4603      	mov	r3, r0
 801143c:	461a      	mov	r2, r3
 801143e:	683b      	ldr	r3, [r7, #0]
 8011440:	659a      	str	r2, [r3, #88]	; 0x58
			CA_msg->bam.cm_lock = 1;
 8011442:	683b      	ldr	r3, [r7, #0]
 8011444:	2201      	movs	r2, #1
 8011446:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
			CA_msg->bam.t1.en = 1;
 801144a:	683b      	ldr	r3, [r7, #0]
 801144c:	2201      	movs	r2, #1
 801144e:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
			CA_msg->bam.t1.release = 0;
 8011452:	683b      	ldr	r3, [r7, #0]
 8011454:	2200      	movs	r2, #0
 8011456:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			CA_msg->bam.t1.value = T1TIMEOUT;
 801145a:	683b      	ldr	r3, [r7, #0]
 801145c:	f240 22ee 	movw	r2, #750	; 0x2ee
 8011460:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
		}
	}
}
 8011464:	3708      	adds	r7, #8
 8011466:	46bd      	mov	sp, r7
 8011468:	bd80      	pop	{r7, pc}
 801146a:	bf00      	nop
 801146c:	08026f74 	.word	0x08026f74

08011470 <responseAbort>:

unsigned char responseAbort(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 8011470:	b580      	push	{r7, lr}
 8011472:	b084      	sub	sp, #16
 8011474:	af00      	add	r7, sp, #0
 8011476:	6078      	str	r0, [r7, #4]
 8011478:	6039      	str	r1, [r7, #0]
	struct J1939_CM *tempCm;
	
	if(CA_msg->rcvdata != NULL)
 801147a:	683b      	ldr	r3, [r7, #0]
 801147c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801147e:	2b00      	cmp	r3, #0
 8011480:	d007      	beq.n	8011492 <responseAbort+0x22>
	{
		free(CA_msg->rcvdata);
 8011482:	683b      	ldr	r3, [r7, #0]
 8011484:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8011486:	4618      	mov	r0, r3
 8011488:	f011 fc72 	bl	8022d70 <free>
		CA_msg->rcvdata = NULL;
 801148c:	683b      	ldr	r3, [r7, #0]
 801148e:	2200      	movs	r2, #0
 8011490:	655a      	str	r2, [r3, #84]	; 0x54
	}
	tempCm = &(CA_msg->cm);
 8011492:	683b      	ldr	r3, [r7, #0]
 8011494:	3316      	adds	r3, #22
 8011496:	60fb      	str	r3, [r7, #12]
	memset(tempCm,0,sizeof(struct J1939_CM));
 8011498:	68f8      	ldr	r0, [r7, #12]
 801149a:	2100      	movs	r1, #0
 801149c:	222a      	movs	r2, #42	; 0x2a
 801149e:	f011 fc6f 	bl	8022d80 <memset>
	
	return RC_SUCCESS;
 80114a2:	2300      	movs	r3, #0
}
 80114a4:	4618      	mov	r0, r3
 80114a6:	3710      	adds	r7, #16
 80114a8:	46bd      	mov	sp, r7
 80114aa:	bd80      	pop	{r7, pc}

080114ac <receiveMessage>:
void receiveMessage()
{
 80114ac:	b580      	push	{r7, lr}
 80114ae:	b084      	sub	sp, #16
 80114b0:	af00      	add	r7, sp, #0
	static struct rx_Message rxmsg;
	struct CA_node *canode;
	list_node_t node;
	int i;

	while(readCan(&j1939_msg) == RC_SUCCESS)
 80114b2:	e0ae      	b.n	8011612 <receiveMessage+0x166>
	{
		if(j1939_msg.PDUFormat <240)
 80114b4:	4b5c      	ldr	r3, [pc, #368]	; (8011628 <receiveMessage+0x17c>)
 80114b6:	785b      	ldrb	r3, [r3, #1]
 80114b8:	2bef      	cmp	r3, #239	; 0xef
 80114ba:	f200 809b 	bhi.w	80115f4 <receiveMessage+0x148>
		{
			if (j1939_msg.PDUSpecific == J1939_GLOBAL_ADDRESS) 
 80114be:	4b5a      	ldr	r3, [pc, #360]	; (8011628 <receiveMessage+0x17c>)
 80114c0:	789b      	ldrb	r3, [r3, #2]
 80114c2:	2bff      	cmp	r3, #255	; 0xff
 80114c4:	d10e      	bne.n	80114e4 <receiveMessage+0x38>
			{
				node = calist.head.next;
 80114c6:	4b59      	ldr	r3, [pc, #356]	; (801162c <receiveMessage+0x180>)
 80114c8:	685b      	ldr	r3, [r3, #4]
 80114ca:	60bb      	str	r3, [r7, #8]
				if(node != &(calist.head))
 80114cc:	68bb      	ldr	r3, [r7, #8]
 80114ce:	4a58      	ldr	r2, [pc, #352]	; (8011630 <receiveMessage+0x184>)
 80114d0:	4293      	cmp	r3, r2
 80114d2:	d006      	beq.n	80114e2 <receiveMessage+0x36>
				{
					canode = rt_list_entry(node, struct CA_node, node);
 80114d4:	68bb      	ldr	r3, [r7, #8]
 80114d6:	3b04      	subs	r3, #4
 80114d8:	607b      	str	r3, [r7, #4]
					CA_msg = canode->ca_msg;
 80114da:	687b      	ldr	r3, [r7, #4]
 80114dc:	681b      	ldr	r3, [r3, #0]
 80114de:	60fb      	str	r3, [r7, #12]
 80114e0:	e00b      	b.n	80114fa <receiveMessage+0x4e>
				}
				else 
					break;
 80114e2:	e09d      	b.n	8011620 <receiveMessage+0x174>
			}
			else if ((CA_msg = Addr_FindCA(&calist,j1939_msg.PDUSpecific)) != NULL)
 80114e4:	4b50      	ldr	r3, [pc, #320]	; (8011628 <receiveMessage+0x17c>)
 80114e6:	789b      	ldrb	r3, [r3, #2]
 80114e8:	4850      	ldr	r0, [pc, #320]	; (801162c <receiveMessage+0x180>)
 80114ea:	4619      	mov	r1, r3
 80114ec:	f000 fb24 	bl	8011b38 <Addr_FindCA>
 80114f0:	60f8      	str	r0, [r7, #12]
 80114f2:	68fb      	ldr	r3, [r7, #12]
 80114f4:	2b00      	cmp	r3, #0
 80114f6:	d100      	bne.n	80114fa <receiveMessage+0x4e>
			{
			}
			else
				continue;
 80114f8:	e08b      	b.n	8011612 <receiveMessage+0x166>

			switch (j1939_msg.PDUFormat)
 80114fa:	4b4b      	ldr	r3, [pc, #300]	; (8011628 <receiveMessage+0x17c>)
 80114fc:	785b      	ldrb	r3, [r3, #1]
 80114fe:	3bea      	subs	r3, #234	; 0xea
 8011500:	2b04      	cmp	r3, #4
 8011502:	d852      	bhi.n	80115aa <receiveMessage+0xfe>
 8011504:	a201      	add	r2, pc, #4	; (adr r2, 801150c <receiveMessage+0x60>)
 8011506:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801150a:	bf00      	nop
 801150c:	0801157f 	.word	0x0801157f
 8011510:	08011575 	.word	0x08011575
 8011514:	08011521 	.word	0x08011521
 8011518:	080115ab 	.word	0x080115ab
 801151c:	080115a1 	.word	0x080115a1
			{
				case J1939_PF_TP_CM:
					switch (j1939_msg.Data[0])
 8011520:	4b41      	ldr	r3, [pc, #260]	; (8011628 <receiveMessage+0x17c>)
 8011522:	795b      	ldrb	r3, [r3, #5]
 8011524:	2b13      	cmp	r3, #19
 8011526:	d015      	beq.n	8011554 <receiveMessage+0xa8>
 8011528:	2b13      	cmp	r3, #19
 801152a:	dc04      	bgt.n	8011536 <receiveMessage+0x8a>
 801152c:	2b10      	cmp	r3, #16
 801152e:	d007      	beq.n	8011540 <receiveMessage+0x94>
 8011530:	2b11      	cmp	r3, #17
 8011532:	d00a      	beq.n	801154a <receiveMessage+0x9e>
							break;
						case J1939_CONNABORT_CONTROL_BYTE:
							responseAbort(&j1939_msg,CA_msg);
							break;
						default:
							goto sendmsg;
 8011534:	e039      	b.n	80115aa <receiveMessage+0xfe>
				continue;

			switch (j1939_msg.PDUFormat)
			{
				case J1939_PF_TP_CM:
					switch (j1939_msg.Data[0])
 8011536:	2b20      	cmp	r3, #32
 8011538:	d011      	beq.n	801155e <receiveMessage+0xb2>
 801153a:	2bff      	cmp	r3, #255	; 0xff
 801153c:	d014      	beq.n	8011568 <receiveMessage+0xbc>
							break;
						case J1939_CONNABORT_CONTROL_BYTE:
							responseAbort(&j1939_msg,CA_msg);
							break;
						default:
							goto sendmsg;
 801153e:	e034      	b.n	80115aa <receiveMessage+0xfe>
			{
				case J1939_PF_TP_CM:
					switch (j1939_msg.Data[0])
					{
						case J1939_RTS_CONTROL_BYTE:
							response_RTS(&j1939_msg,CA_msg);
 8011540:	4839      	ldr	r0, [pc, #228]	; (8011628 <receiveMessage+0x17c>)
 8011542:	68f9      	ldr	r1, [r7, #12]
 8011544:	f7ff fca2 	bl	8010e8c <response_RTS>
							break;
 8011548:	e013      	b.n	8011572 <receiveMessage+0xc6>
						case J1939_CTS_CONTROL_BYTE:
							response_CTS(&j1939_msg,CA_msg);
 801154a:	4837      	ldr	r0, [pc, #220]	; (8011628 <receiveMessage+0x17c>)
 801154c:	68f9      	ldr	r1, [r7, #12]
 801154e:	f7ff fd03 	bl	8010f58 <response_CTS>
							break;
 8011552:	e00e      	b.n	8011572 <receiveMessage+0xc6>
						case J1939_EOMACK_CONTROL_BYTE:
							responseEndofMsgACK(&j1939_msg,CA_msg);
 8011554:	4834      	ldr	r0, [pc, #208]	; (8011628 <receiveMessage+0x17c>)
 8011556:	68f9      	ldr	r1, [r7, #12]
 8011558:	f7ff ff14 	bl	8011384 <responseEndofMsgACK>
							break;
 801155c:	e009      	b.n	8011572 <receiveMessage+0xc6>
						case J1939_BAM_CONTROL_BYTE:
							responseBAM(&j1939_msg,CA_msg);
 801155e:	4832      	ldr	r0, [pc, #200]	; (8011628 <receiveMessage+0x17c>)
 8011560:	68f9      	ldr	r1, [r7, #12]
 8011562:	f7ff ff37 	bl	80113d4 <responseBAM>
							break;
 8011566:	e004      	b.n	8011572 <receiveMessage+0xc6>
						case J1939_CONNABORT_CONTROL_BYTE:
							responseAbort(&j1939_msg,CA_msg);
 8011568:	482f      	ldr	r0, [pc, #188]	; (8011628 <receiveMessage+0x17c>)
 801156a:	68f9      	ldr	r1, [r7, #12]
 801156c:	f7ff ff80 	bl	8011470 <responseAbort>
							break;
 8011570:	bf00      	nop
						default:
							goto sendmsg;
					}
					break;
 8011572:	e03e      	b.n	80115f2 <receiveMessage+0x146>
				case J1939_PF_DT:
					receiveData(&j1939_msg,CA_msg);
 8011574:	482c      	ldr	r0, [pc, #176]	; (8011628 <receiveMessage+0x17c>)
 8011576:	68f9      	ldr	r1, [r7, #12]
 8011578:	f7ff fda4 	bl	80110c4 <receiveData>
					break;
 801157c:	e039      	b.n	80115f2 <receiveMessage+0x146>
				case J1939_PF_REQUEST:
					if ((j1939_msg.Data[0] == J1939_PGN0_REQ_ADDRESS_CLAIM) &&
 801157e:	4b2a      	ldr	r3, [pc, #168]	; (8011628 <receiveMessage+0x17c>)
 8011580:	795b      	ldrb	r3, [r3, #5]
 8011582:	2b00      	cmp	r3, #0
 8011584:	d111      	bne.n	80115aa <receiveMessage+0xfe>
						(j1939_msg.Data[1] == J1939_PGN1_REQ_ADDRESS_CLAIM) &&
 8011586:	4b28      	ldr	r3, [pc, #160]	; (8011628 <receiveMessage+0x17c>)
 8011588:	799b      	ldrb	r3, [r3, #6]
					break;
				case J1939_PF_DT:
					receiveData(&j1939_msg,CA_msg);
					break;
				case J1939_PF_REQUEST:
					if ((j1939_msg.Data[0] == J1939_PGN0_REQ_ADDRESS_CLAIM) &&
 801158a:	2bee      	cmp	r3, #238	; 0xee
 801158c:	d10d      	bne.n	80115aa <receiveMessage+0xfe>
						(j1939_msg.Data[1] == J1939_PGN1_REQ_ADDRESS_CLAIM) &&
						(j1939_msg.Data[2] == J1939_PGN2_REQ_ADDRESS_CLAIM))
 801158e:	4b26      	ldr	r3, [pc, #152]	; (8011628 <receiveMessage+0x17c>)
 8011590:	79db      	ldrb	r3, [r3, #7]
				case J1939_PF_DT:
					receiveData(&j1939_msg,CA_msg);
					break;
				case J1939_PF_REQUEST:
					if ((j1939_msg.Data[0] == J1939_PGN0_REQ_ADDRESS_CLAIM) &&
						(j1939_msg.Data[1] == J1939_PGN1_REQ_ADDRESS_CLAIM) &&
 8011592:	2b00      	cmp	r3, #0
 8011594:	d109      	bne.n	80115aa <receiveMessage+0xfe>
						(j1939_msg.Data[2] == J1939_PGN2_REQ_ADDRESS_CLAIM))
						J1939_RequestForAddressClaimHandling(&j1939_msg,CA_msg);
 8011596:	4824      	ldr	r0, [pc, #144]	; (8011628 <receiveMessage+0x17c>)
 8011598:	68f9      	ldr	r1, [r7, #12]
 801159a:	f000 fafb 	bl	8011b94 <J1939_RequestForAddressClaimHandling>
					else 
						goto sendmsg;
					break;
 801159e:	e028      	b.n	80115f2 <receiveMessage+0x146>
				case J1939_PF_ADDRESS_CLAIMED:
					J1939_AddressClaimHandling( &j1939_msg,CA_msg );
 80115a0:	4821      	ldr	r0, [pc, #132]	; (8011628 <receiveMessage+0x17c>)
 80115a2:	68f9      	ldr	r1, [r7, #12]
 80115a4:	f000 fb6c 	bl	8011c80 <J1939_AddressClaimHandling>
					break;
 80115a8:	e023      	b.n	80115f2 <receiveMessage+0x146>

				default:
	sendmsg:
				
				rxmsg.data = &j1939_msg.Data;
 80115aa:	4b22      	ldr	r3, [pc, #136]	; (8011634 <receiveMessage+0x188>)
 80115ac:	4a22      	ldr	r2, [pc, #136]	; (8011638 <receiveMessage+0x18c>)
 80115ae:	601a      	str	r2, [r3, #0]
				rxmsg.size = j1939_msg.DataLength;
 80115b0:	4b1d      	ldr	r3, [pc, #116]	; (8011628 <receiveMessage+0x17c>)
 80115b2:	791b      	ldrb	r3, [r3, #4]
 80115b4:	f3c3 0303 	ubfx	r3, r3, #0, #4
 80115b8:	b2db      	uxtb	r3, r3
 80115ba:	b29a      	uxth	r2, r3
 80115bc:	4b1d      	ldr	r3, [pc, #116]	; (8011634 <receiveMessage+0x188>)
 80115be:	809a      	strh	r2, [r3, #4]
				rxmsg.dp = j1939_msg.DataPage;
 80115c0:	4b19      	ldr	r3, [pc, #100]	; (8011628 <receiveMessage+0x17c>)
 80115c2:	781b      	ldrb	r3, [r3, #0]
 80115c4:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 80115c8:	b2db      	uxtb	r3, r3
 80115ca:	461a      	mov	r2, r3
 80115cc:	4b19      	ldr	r3, [pc, #100]	; (8011634 <receiveMessage+0x188>)
 80115ce:	721a      	strb	r2, [r3, #8]
				rxmsg.PF = j1939_msg.PDUFormat;
 80115d0:	4b15      	ldr	r3, [pc, #84]	; (8011628 <receiveMessage+0x17c>)
 80115d2:	785a      	ldrb	r2, [r3, #1]
 80115d4:	4b17      	ldr	r3, [pc, #92]	; (8011634 <receiveMessage+0x188>)
 80115d6:	71da      	strb	r2, [r3, #7]
				rxmsg.PS = j1939_msg.PDUSpecific;
 80115d8:	4b13      	ldr	r3, [pc, #76]	; (8011628 <receiveMessage+0x17c>)
 80115da:	789a      	ldrb	r2, [r3, #2]
 80115dc:	4b15      	ldr	r3, [pc, #84]	; (8011634 <receiveMessage+0x188>)
 80115de:	719a      	strb	r2, [r3, #6]
				
				osMessagePut(CA_msg->rxq, (unsigned long)&rxmsg, 0);
 80115e0:	68fb      	ldr	r3, [r7, #12]
 80115e2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80115e4:	4a13      	ldr	r2, [pc, #76]	; (8011634 <receiveMessage+0x188>)
 80115e6:	4618      	mov	r0, r3
 80115e8:	4611      	mov	r1, r2
 80115ea:	2200      	movs	r2, #0
 80115ec:	f008 faba 	bl	8019b64 <osMessagePut>
				break;
 80115f0:	bf00      	nop
 80115f2:	e00e      	b.n	8011612 <receiveMessage+0x166>
			}
		}
		else 
		{
			
			node = calist.head.next;
 80115f4:	4b0d      	ldr	r3, [pc, #52]	; (801162c <receiveMessage+0x180>)
 80115f6:	685b      	ldr	r3, [r3, #4]
 80115f8:	60bb      	str	r3, [r7, #8]
			if(node != &(calist.head))
 80115fa:	68bb      	ldr	r3, [r7, #8]
 80115fc:	4a0c      	ldr	r2, [pc, #48]	; (8011630 <receiveMessage+0x184>)
 80115fe:	4293      	cmp	r3, r2
 8011600:	d006      	beq.n	8011610 <receiveMessage+0x164>
			{
				canode = rt_list_entry(node, struct CA_node, node);
 8011602:	68bb      	ldr	r3, [r7, #8]
 8011604:	3b04      	subs	r3, #4
 8011606:	607b      	str	r3, [r7, #4]
				CA_msg = canode->ca_msg;
 8011608:	687b      	ldr	r3, [r7, #4]
 801160a:	681b      	ldr	r3, [r3, #0]
 801160c:	60fb      	str	r3, [r7, #12]
			}
			else 
				break;
			
			goto sendmsg;
 801160e:	e7cc      	b.n	80115aa <receiveMessage+0xfe>
			{
				canode = rt_list_entry(node, struct CA_node, node);
				CA_msg = canode->ca_msg;
			}
			else 
				break;
 8011610:	e006      	b.n	8011620 <receiveMessage+0x174>
	static struct rx_Message rxmsg;
	struct CA_node *canode;
	list_node_t node;
	int i;

	while(readCan(&j1939_msg) == RC_SUCCESS)
 8011612:	4805      	ldr	r0, [pc, #20]	; (8011628 <receiveMessage+0x17c>)
 8011614:	f000 fc92 	bl	8011f3c <readCan>
 8011618:	4603      	mov	r3, r0
 801161a:	2b00      	cmp	r3, #0
 801161c:	f43f af4a 	beq.w	80114b4 <receiveMessage+0x8>
				break;
			
			goto sendmsg;
		}
	}
}
 8011620:	3710      	adds	r7, #16
 8011622:	46bd      	mov	sp, r7
 8011624:	bd80      	pop	{r7, pc}
 8011626:	bf00      	nop
 8011628:	200107d8 	.word	0x200107d8
 801162c:	2001277c 	.word	0x2001277c
 8011630:	20012780 	.word	0x20012780
 8011634:	200107e8 	.word	0x200107e8
 8011638:	200107dd 	.word	0x200107dd

0801163c <bamAbort>:

void bamAbort(CA_Msg_t CA_msg)
{
 801163c:	b580      	push	{r7, lr}
 801163e:	b084      	sub	sp, #16
 8011640:	af00      	add	r7, sp, #0
 8011642:	6078      	str	r0, [r7, #4]
	struct J1939_BAM *tempbam;
	
	if(CA_msg->bamrcvdata != NULL)
 8011644:	687b      	ldr	r3, [r7, #4]
 8011646:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8011648:	2b00      	cmp	r3, #0
 801164a:	d007      	beq.n	801165c <bamAbort+0x20>
	{
		free(CA_msg->bamrcvdata);
 801164c:	687b      	ldr	r3, [r7, #4]
 801164e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8011650:	4618      	mov	r0, r3
 8011652:	f011 fb8d 	bl	8022d70 <free>
		CA_msg->bamrcvdata = NULL;
 8011656:	687b      	ldr	r3, [r7, #4]
 8011658:	2200      	movs	r2, #0
 801165a:	659a      	str	r2, [r3, #88]	; 0x58
	}
	tempbam = &(CA_msg->bam);
 801165c:	687b      	ldr	r3, [r7, #4]
 801165e:	3340      	adds	r3, #64	; 0x40
 8011660:	60fb      	str	r3, [r7, #12]
	memset(tempbam,0,sizeof(struct J1939_BAM));
 8011662:	68f8      	ldr	r0, [r7, #12]
 8011664:	2100      	movs	r1, #0
 8011666:	220c      	movs	r2, #12
 8011668:	f011 fb8a 	bl	8022d80 <memset>
}
 801166c:	3710      	adds	r7, #16
 801166e:	46bd      	mov	sp, r7
 8011670:	bd80      	pop	{r7, pc}
 8011672:	bf00      	nop

08011674 <timerJ1939func>:

static void timerJ1939func(void* parameter)
{
 8011674:	b580      	push	{r7, lr}
 8011676:	b086      	sub	sp, #24
 8011678:	af00      	add	r7, sp, #0
 801167a:	6078      	str	r0, [r7, #4]
	CA_Msg_t tmp_ca_msg;
	struct list_node *node;
	static struct q_Message q_msg;
	struct CA_node *canode;
	for(node = calist.head.next; node != &(calist.head); node = node->next)
 801167c:	4b93      	ldr	r3, [pc, #588]	; (80118cc <timerJ1939func+0x258>)
 801167e:	685b      	ldr	r3, [r3, #4]
 8011680:	617b      	str	r3, [r7, #20]
 8011682:	e1c5      	b.n	8011a10 <timerJ1939func+0x39c>
	{
		canode = rt_list_entry(node, struct CA_node, node);
 8011684:	697b      	ldr	r3, [r7, #20]
 8011686:	3b04      	subs	r3, #4
 8011688:	613b      	str	r3, [r7, #16]
		tmp_ca_msg = canode->ca_msg;
 801168a:	693b      	ldr	r3, [r7, #16]
 801168c:	681b      	ldr	r3, [r3, #0]
 801168e:	60fb      	str	r3, [r7, #12]

		if((tmp_ca_msg->bam.t1.en) == 1)
 8011690:	68fb      	ldr	r3, [r7, #12]
 8011692:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8011696:	2b01      	cmp	r3, #1
 8011698:	d12a      	bne.n	80116f0 <timerJ1939func+0x7c>
		{
			if((tmp_ca_msg->bam.t1.release) == 1)
 801169a:	68fb      	ldr	r3, [r7, #12]
 801169c:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 80116a0:	2b01      	cmp	r3, #1
 80116a2:	d10c      	bne.n	80116be <timerJ1939func+0x4a>
			{
				tmp_ca_msg->bam.t1.en = 0;
 80116a4:	68fb      	ldr	r3, [r7, #12]
 80116a6:	2200      	movs	r2, #0
 80116a8:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
				tmp_ca_msg->bam.t1.value = 0;
 80116ac:	68fb      	ldr	r3, [r7, #12]
 80116ae:	2200      	movs	r2, #0
 80116b0:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
				tmp_ca_msg->bam.t1.release = 0;
 80116b4:	68fb      	ldr	r3, [r7, #12]
 80116b6:	2200      	movs	r2, #0
 80116b8:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 80116bc:	e018      	b.n	80116f0 <timerJ1939func+0x7c>
			}
			else
			{
				if((tmp_ca_msg->bam.t1.value)-- == 0)
 80116be:	68fb      	ldr	r3, [r7, #12]
 80116c0:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 80116c4:	1e5a      	subs	r2, r3, #1
 80116c6:	b291      	uxth	r1, r2
 80116c8:	68fa      	ldr	r2, [r7, #12]
 80116ca:	f8a2 1042 	strh.w	r1, [r2, #66]	; 0x42
 80116ce:	2b00      	cmp	r3, #0
 80116d0:	d10e      	bne.n	80116f0 <timerJ1939func+0x7c>
				{
					tmp_ca_msg->bam.t1.en = 0;
 80116d2:	68fb      	ldr	r3, [r7, #12]
 80116d4:	2200      	movs	r2, #0
 80116d6:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
					tmp_ca_msg->bam.t1.value = 0;
 80116da:	68fb      	ldr	r3, [r7, #12]
 80116dc:	2200      	movs	r2, #0
 80116de:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
					tmp_ca_msg->bam.t1.release = 0;
 80116e2:	68fb      	ldr	r3, [r7, #12]
 80116e4:	2200      	movs	r2, #0
 80116e6:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
				//	osMessagePut(tmp_ca_msg->cm.txq, &q_msg, NULL);
					//sendAbort(tmp_ca_msg,0);

			bamAbort(tmp_ca_msg);
 80116ea:	68f8      	ldr	r0, [r7, #12]
 80116ec:	f7ff ffa6 	bl	801163c <bamAbort>

				}
			}
		}

		if((tmp_ca_msg->cm.t1.en) == 1)
 80116f0:	68fb      	ldr	r3, [r7, #12]
 80116f2:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 80116f6:	2b01      	cmp	r3, #1
 80116f8:	d127      	bne.n	801174a <timerJ1939func+0xd6>
		{
			if((tmp_ca_msg->cm.t1.release) == 1)
 80116fa:	68fb      	ldr	r3, [r7, #12]
 80116fc:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8011700:	2b01      	cmp	r3, #1
 8011702:	d10b      	bne.n	801171c <timerJ1939func+0xa8>
			{
				tmp_ca_msg->cm.t1.en = 0;
 8011704:	68fb      	ldr	r3, [r7, #12]
 8011706:	2200      	movs	r2, #0
 8011708:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
				tmp_ca_msg->cm.t1.value = 0;
 801170c:	68fb      	ldr	r3, [r7, #12]
 801170e:	2200      	movs	r2, #0
 8011710:	84da      	strh	r2, [r3, #38]	; 0x26
				tmp_ca_msg->cm.t1.release = 0;
 8011712:	68fb      	ldr	r3, [r7, #12]
 8011714:	2200      	movs	r2, #0
 8011716:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
 801171a:	e016      	b.n	801174a <timerJ1939func+0xd6>
			}
			else
			{
				if((tmp_ca_msg->cm.t1.value)-- == 0)
 801171c:	68fb      	ldr	r3, [r7, #12]
 801171e:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 8011720:	1e5a      	subs	r2, r3, #1
 8011722:	b291      	uxth	r1, r2
 8011724:	68fa      	ldr	r2, [r7, #12]
 8011726:	84d1      	strh	r1, [r2, #38]	; 0x26
 8011728:	2b00      	cmp	r3, #0
 801172a:	d10e      	bne.n	801174a <timerJ1939func+0xd6>
				{
					tmp_ca_msg->cm.t1.en = 0;
 801172c:	68fb      	ldr	r3, [r7, #12]
 801172e:	2200      	movs	r2, #0
 8011730:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
					tmp_ca_msg->cm.t1.value = 0;
 8011734:	68fb      	ldr	r3, [r7, #12]
 8011736:	2200      	movs	r2, #0
 8011738:	84da      	strh	r2, [r3, #38]	; 0x26
					tmp_ca_msg->cm.t1.release = 0;
 801173a:	68fb      	ldr	r3, [r7, #12]
 801173c:	2200      	movs	r2, #0
 801173e:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
				//	osMessagePut(tmp_ca_msg->cm.txq, &q_msg, NULL);
					sendAbort(tmp_ca_msg,0);
 8011742:	68f8      	ldr	r0, [r7, #12]
 8011744:	2100      	movs	r1, #0
 8011746:	f7ff f983 	bl	8010a50 <sendAbort>
				}
			}
		}
		if((tmp_ca_msg->cm.t2.en) == 1)
 801174a:	68fb      	ldr	r3, [r7, #12]
 801174c:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8011750:	2b01      	cmp	r3, #1
 8011752:	d130      	bne.n	80117b6 <timerJ1939func+0x142>
		{
			if((tmp_ca_msg->cm.t2.release) == 1)
 8011754:	68fb      	ldr	r3, [r7, #12]
 8011756:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 801175a:	2b01      	cmp	r3, #1
 801175c:	d10b      	bne.n	8011776 <timerJ1939func+0x102>
			{
				tmp_ca_msg->cm.t2.en = 0;
 801175e:	68fb      	ldr	r3, [r7, #12]
 8011760:	2200      	movs	r2, #0
 8011762:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
				tmp_ca_msg->cm.t2.value = 0;
 8011766:	68fb      	ldr	r3, [r7, #12]
 8011768:	2200      	movs	r2, #0
 801176a:	855a      	strh	r2, [r3, #42]	; 0x2a
				tmp_ca_msg->cm.t2.release = 0;
 801176c:	68fb      	ldr	r3, [r7, #12]
 801176e:	2200      	movs	r2, #0
 8011770:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
 8011774:	e01f      	b.n	80117b6 <timerJ1939func+0x142>
			}
			else
			{
				if((tmp_ca_msg->cm.t2.value)-- == 0)
 8011776:	68fb      	ldr	r3, [r7, #12]
 8011778:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 801177a:	1e5a      	subs	r2, r3, #1
 801177c:	b291      	uxth	r1, r2
 801177e:	68fa      	ldr	r2, [r7, #12]
 8011780:	8551      	strh	r1, [r2, #42]	; 0x2a
 8011782:	2b00      	cmp	r3, #0
 8011784:	d117      	bne.n	80117b6 <timerJ1939func+0x142>
				{
					q_msg.timeout = 1;
 8011786:	4b52      	ldr	r3, [pc, #328]	; (80118d0 <timerJ1939func+0x25c>)
 8011788:	2201      	movs	r2, #1
 801178a:	809a      	strh	r2, [r3, #4]
					q_msg.nextnum = 0;
 801178c:	4b50      	ldr	r3, [pc, #320]	; (80118d0 <timerJ1939func+0x25c>)
 801178e:	2200      	movs	r2, #0
 8011790:	801a      	strh	r2, [r3, #0]
					q_msg.sendnum = 0;
 8011792:	4b4f      	ldr	r3, [pc, #316]	; (80118d0 <timerJ1939func+0x25c>)
 8011794:	2200      	movs	r2, #0
 8011796:	805a      	strh	r2, [r3, #2]
					tmp_ca_msg->cm.t2.en = 0;
 8011798:	68fb      	ldr	r3, [r7, #12]
 801179a:	2200      	movs	r2, #0
 801179c:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
					tmp_ca_msg->cm.t2.value = 0;
 80117a0:	68fb      	ldr	r3, [r7, #12]
 80117a2:	2200      	movs	r2, #0
 80117a4:	855a      	strh	r2, [r3, #42]	; 0x2a
					tmp_ca_msg->cm.t2.release = 0;
 80117a6:	68fb      	ldr	r3, [r7, #12]
 80117a8:	2200      	movs	r2, #0
 80117aa:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
				//	osMessagePut(tmp_ca_msg->cm.txq, &q_msg, NULL);
					sendAbort(tmp_ca_msg,0);
 80117ae:	68f8      	ldr	r0, [r7, #12]
 80117b0:	2100      	movs	r1, #0
 80117b2:	f7ff f94d 	bl	8010a50 <sendAbort>
				}
			}
		}
		if((tmp_ca_msg->cm.t3.en) == 1)
 80117b6:	68fb      	ldr	r3, [r7, #12]
 80117b8:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 80117bc:	2b01      	cmp	r3, #1
 80117be:	d134      	bne.n	801182a <timerJ1939func+0x1b6>
		{
			if((tmp_ca_msg->cm.t3.release) == 1)
 80117c0:	68fb      	ldr	r3, [r7, #12]
 80117c2:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 80117c6:	2b01      	cmp	r3, #1
 80117c8:	d10b      	bne.n	80117e2 <timerJ1939func+0x16e>
			{
				tmp_ca_msg->cm.t3.en = 0;
 80117ca:	68fb      	ldr	r3, [r7, #12]
 80117cc:	2200      	movs	r2, #0
 80117ce:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
				tmp_ca_msg->cm.t3.value = 0;
 80117d2:	68fb      	ldr	r3, [r7, #12]
 80117d4:	2200      	movs	r2, #0
 80117d6:	85da      	strh	r2, [r3, #46]	; 0x2e
				tmp_ca_msg->cm.t3.release = 0;
 80117d8:	68fb      	ldr	r3, [r7, #12]
 80117da:	2200      	movs	r2, #0
 80117dc:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
 80117e0:	e023      	b.n	801182a <timerJ1939func+0x1b6>
			}
			else
			{
				if((tmp_ca_msg->cm.t3.value)-- == 0)
 80117e2:	68fb      	ldr	r3, [r7, #12]
 80117e4:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 80117e6:	1e5a      	subs	r2, r3, #1
 80117e8:	b291      	uxth	r1, r2
 80117ea:	68fa      	ldr	r2, [r7, #12]
 80117ec:	85d1      	strh	r1, [r2, #46]	; 0x2e
 80117ee:	2b00      	cmp	r3, #0
 80117f0:	d11b      	bne.n	801182a <timerJ1939func+0x1b6>
				{
					q_msg.timeout = 1;
 80117f2:	4b37      	ldr	r3, [pc, #220]	; (80118d0 <timerJ1939func+0x25c>)
 80117f4:	2201      	movs	r2, #1
 80117f6:	809a      	strh	r2, [r3, #4]
					q_msg.nextnum = 0;
 80117f8:	4b35      	ldr	r3, [pc, #212]	; (80118d0 <timerJ1939func+0x25c>)
 80117fa:	2200      	movs	r2, #0
 80117fc:	801a      	strh	r2, [r3, #0]
					q_msg.sendnum = 0;
 80117fe:	4b34      	ldr	r3, [pc, #208]	; (80118d0 <timerJ1939func+0x25c>)
 8011800:	2200      	movs	r2, #0
 8011802:	805a      	strh	r2, [r3, #2]
					tmp_ca_msg->cm.t3.en = 0;
 8011804:	68fb      	ldr	r3, [r7, #12]
 8011806:	2200      	movs	r2, #0
 8011808:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
					tmp_ca_msg->cm.t3.value = 0;
 801180c:	68fb      	ldr	r3, [r7, #12]
 801180e:	2200      	movs	r2, #0
 8011810:	85da      	strh	r2, [r3, #46]	; 0x2e
					tmp_ca_msg->cm.t3.release = 0;
 8011812:	68fb      	ldr	r3, [r7, #12]
 8011814:	2200      	movs	r2, #0
 8011816:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
					osMessagePut(tmp_ca_msg->txq, (unsigned long)&q_msg, 0);
 801181a:	68fb      	ldr	r3, [r7, #12]
 801181c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 801181e:	4a2c      	ldr	r2, [pc, #176]	; (80118d0 <timerJ1939func+0x25c>)
 8011820:	4618      	mov	r0, r3
 8011822:	4611      	mov	r1, r2
 8011824:	2200      	movs	r2, #0
 8011826:	f008 f99d 	bl	8019b64 <osMessagePut>
				}
			}
		}
		if((tmp_ca_msg->cm.t4.en) == 1)
 801182a:	68fb      	ldr	r3, [r7, #12]
 801182c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8011830:	2b01      	cmp	r3, #1
 8011832:	d134      	bne.n	801189e <timerJ1939func+0x22a>
		{
			if((tmp_ca_msg->cm.t4.release) == 1)
 8011834:	68fb      	ldr	r3, [r7, #12]
 8011836:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 801183a:	2b01      	cmp	r3, #1
 801183c:	d10b      	bne.n	8011856 <timerJ1939func+0x1e2>
			{
				tmp_ca_msg->cm.t4.en = 0;
 801183e:	68fb      	ldr	r3, [r7, #12]
 8011840:	2200      	movs	r2, #0
 8011842:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
				tmp_ca_msg->cm.t4.value = 0;
 8011846:	68fb      	ldr	r3, [r7, #12]
 8011848:	2200      	movs	r2, #0
 801184a:	865a      	strh	r2, [r3, #50]	; 0x32
				tmp_ca_msg->cm.t4.release = 0;
 801184c:	68fb      	ldr	r3, [r7, #12]
 801184e:	2200      	movs	r2, #0
 8011850:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 8011854:	e023      	b.n	801189e <timerJ1939func+0x22a>
			}
			else
			{
				if((tmp_ca_msg->cm.t4.value)-- == 0)
 8011856:	68fb      	ldr	r3, [r7, #12]
 8011858:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 801185a:	1e5a      	subs	r2, r3, #1
 801185c:	b291      	uxth	r1, r2
 801185e:	68fa      	ldr	r2, [r7, #12]
 8011860:	8651      	strh	r1, [r2, #50]	; 0x32
 8011862:	2b00      	cmp	r3, #0
 8011864:	d11b      	bne.n	801189e <timerJ1939func+0x22a>
				{
					q_msg.timeout = 1;
 8011866:	4b1a      	ldr	r3, [pc, #104]	; (80118d0 <timerJ1939func+0x25c>)
 8011868:	2201      	movs	r2, #1
 801186a:	809a      	strh	r2, [r3, #4]
					q_msg.nextnum = 0;
 801186c:	4b18      	ldr	r3, [pc, #96]	; (80118d0 <timerJ1939func+0x25c>)
 801186e:	2200      	movs	r2, #0
 8011870:	801a      	strh	r2, [r3, #0]
					q_msg.sendnum = 0;
 8011872:	4b17      	ldr	r3, [pc, #92]	; (80118d0 <timerJ1939func+0x25c>)
 8011874:	2200      	movs	r2, #0
 8011876:	805a      	strh	r2, [r3, #2]
					tmp_ca_msg->cm.t4.en = 0;
 8011878:	68fb      	ldr	r3, [r7, #12]
 801187a:	2200      	movs	r2, #0
 801187c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
					tmp_ca_msg->cm.t4.value = 0;
 8011880:	68fb      	ldr	r3, [r7, #12]
 8011882:	2200      	movs	r2, #0
 8011884:	865a      	strh	r2, [r3, #50]	; 0x32
					tmp_ca_msg->cm.t4.release = 0;
 8011886:	68fb      	ldr	r3, [r7, #12]
 8011888:	2200      	movs	r2, #0
 801188a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
					osMessagePut(tmp_ca_msg->txq, (unsigned long)&q_msg, 0);
 801188e:	68fb      	ldr	r3, [r7, #12]
 8011890:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8011892:	4a0f      	ldr	r2, [pc, #60]	; (80118d0 <timerJ1939func+0x25c>)
 8011894:	4618      	mov	r0, r3
 8011896:	4611      	mov	r1, r2
 8011898:	2200      	movs	r2, #0
 801189a:	f008 f963 	bl	8019b64 <osMessagePut>
				}
			}
		}
		if((tmp_ca_msg->cm.tr.en) == 1)
 801189e:	68fb      	ldr	r3, [r7, #12]
 80118a0:	f893 3020 	ldrb.w	r3, [r3, #32]
 80118a4:	2b01      	cmp	r3, #1
 80118a6:	d139      	bne.n	801191c <timerJ1939func+0x2a8>
		{
			if((tmp_ca_msg->cm.tr.release) == 1)
 80118a8:	68fb      	ldr	r3, [r7, #12]
 80118aa:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 80118ae:	2b01      	cmp	r3, #1
 80118b0:	d110      	bne.n	80118d4 <timerJ1939func+0x260>
			{
				tmp_ca_msg->cm.tr.en = 0;
 80118b2:	68fb      	ldr	r3, [r7, #12]
 80118b4:	2200      	movs	r2, #0
 80118b6:	f883 2020 	strb.w	r2, [r3, #32]
				tmp_ca_msg->cm.tr.value = 0;
 80118ba:	68fb      	ldr	r3, [r7, #12]
 80118bc:	2200      	movs	r2, #0
 80118be:	83da      	strh	r2, [r3, #30]
				tmp_ca_msg->cm.tr.release = 0;
 80118c0:	68fb      	ldr	r3, [r7, #12]
 80118c2:	2200      	movs	r2, #0
 80118c4:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
 80118c8:	e028      	b.n	801191c <timerJ1939func+0x2a8>
 80118ca:	bf00      	nop
 80118cc:	2001277c 	.word	0x2001277c
 80118d0:	200107f4 	.word	0x200107f4
			}
			else
			{
				if((tmp_ca_msg->cm.tr.value)-- == 0)
 80118d4:	68fb      	ldr	r3, [r7, #12]
 80118d6:	8bdb      	ldrh	r3, [r3, #30]
 80118d8:	1e5a      	subs	r2, r3, #1
 80118da:	b291      	uxth	r1, r2
 80118dc:	68fa      	ldr	r2, [r7, #12]
 80118de:	83d1      	strh	r1, [r2, #30]
 80118e0:	2b00      	cmp	r3, #0
 80118e2:	d11b      	bne.n	801191c <timerJ1939func+0x2a8>
				{
					q_msg.timeout = 1;
 80118e4:	4b4e      	ldr	r3, [pc, #312]	; (8011a20 <timerJ1939func+0x3ac>)
 80118e6:	2201      	movs	r2, #1
 80118e8:	809a      	strh	r2, [r3, #4]
					q_msg.nextnum = 0;
 80118ea:	4b4d      	ldr	r3, [pc, #308]	; (8011a20 <timerJ1939func+0x3ac>)
 80118ec:	2200      	movs	r2, #0
 80118ee:	801a      	strh	r2, [r3, #0]
					q_msg.sendnum = 0;
 80118f0:	4b4b      	ldr	r3, [pc, #300]	; (8011a20 <timerJ1939func+0x3ac>)
 80118f2:	2200      	movs	r2, #0
 80118f4:	805a      	strh	r2, [r3, #2]
					tmp_ca_msg->cm.tr.en = 0;
 80118f6:	68fb      	ldr	r3, [r7, #12]
 80118f8:	2200      	movs	r2, #0
 80118fa:	f883 2020 	strb.w	r2, [r3, #32]
					tmp_ca_msg->cm.tr.value = 0;
 80118fe:	68fb      	ldr	r3, [r7, #12]
 8011900:	2200      	movs	r2, #0
 8011902:	83da      	strh	r2, [r3, #30]
					tmp_ca_msg->cm.tr.release = 0;
 8011904:	68fb      	ldr	r3, [r7, #12]
 8011906:	2200      	movs	r2, #0
 8011908:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
					osMessagePut(tmp_ca_msg->txq, (unsigned long)&q_msg,0);
 801190c:	68fb      	ldr	r3, [r7, #12]
 801190e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8011910:	4a43      	ldr	r2, [pc, #268]	; (8011a20 <timerJ1939func+0x3ac>)
 8011912:	4618      	mov	r0, r3
 8011914:	4611      	mov	r1, r2
 8011916:	2200      	movs	r2, #0
 8011918:	f008 f924 	bl	8019b64 <osMessagePut>
				}
			}
		}
		if((tmp_ca_msg->cm.th.en) == 1)
 801191c:	68fb      	ldr	r3, [r7, #12]
 801191e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8011922:	2b01      	cmp	r3, #1
 8011924:	d134      	bne.n	8011990 <timerJ1939func+0x31c>
		{
			if((tmp_ca_msg->cm.th.release) == 1)
 8011926:	68fb      	ldr	r3, [r7, #12]
 8011928:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 801192c:	2b01      	cmp	r3, #1
 801192e:	d10b      	bne.n	8011948 <timerJ1939func+0x2d4>
			{
				tmp_ca_msg->cm.th.en = 0;
 8011930:	68fb      	ldr	r3, [r7, #12]
 8011932:	2200      	movs	r2, #0
 8011934:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
				tmp_ca_msg->cm.th.value = 0;
 8011938:	68fb      	ldr	r3, [r7, #12]
 801193a:	2200      	movs	r2, #0
 801193c:	845a      	strh	r2, [r3, #34]	; 0x22
				tmp_ca_msg->cm.th.release = 0;
 801193e:	68fb      	ldr	r3, [r7, #12]
 8011940:	2200      	movs	r2, #0
 8011942:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
 8011946:	e023      	b.n	8011990 <timerJ1939func+0x31c>
			}
			else
			{
				if((tmp_ca_msg->cm.th.value)-- == 0)
 8011948:	68fb      	ldr	r3, [r7, #12]
 801194a:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 801194c:	1e5a      	subs	r2, r3, #1
 801194e:	b291      	uxth	r1, r2
 8011950:	68fa      	ldr	r2, [r7, #12]
 8011952:	8451      	strh	r1, [r2, #34]	; 0x22
 8011954:	2b00      	cmp	r3, #0
 8011956:	d11b      	bne.n	8011990 <timerJ1939func+0x31c>
				{
					q_msg.timeout = 1;
 8011958:	4b31      	ldr	r3, [pc, #196]	; (8011a20 <timerJ1939func+0x3ac>)
 801195a:	2201      	movs	r2, #1
 801195c:	809a      	strh	r2, [r3, #4]
					q_msg.nextnum = 0;
 801195e:	4b30      	ldr	r3, [pc, #192]	; (8011a20 <timerJ1939func+0x3ac>)
 8011960:	2200      	movs	r2, #0
 8011962:	801a      	strh	r2, [r3, #0]
					q_msg.sendnum = 0;
 8011964:	4b2e      	ldr	r3, [pc, #184]	; (8011a20 <timerJ1939func+0x3ac>)
 8011966:	2200      	movs	r2, #0
 8011968:	805a      	strh	r2, [r3, #2]
					tmp_ca_msg->cm.th.en = 0;
 801196a:	68fb      	ldr	r3, [r7, #12]
 801196c:	2200      	movs	r2, #0
 801196e:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
					tmp_ca_msg->cm.th.value = 0;
 8011972:	68fb      	ldr	r3, [r7, #12]
 8011974:	2200      	movs	r2, #0
 8011976:	845a      	strh	r2, [r3, #34]	; 0x22
					tmp_ca_msg->cm.th.release = 0;
 8011978:	68fb      	ldr	r3, [r7, #12]
 801197a:	2200      	movs	r2, #0
 801197c:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
					osMessagePut(tmp_ca_msg->txq, (unsigned long)&q_msg, 0);
 8011980:	68fb      	ldr	r3, [r7, #12]
 8011982:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8011984:	4a26      	ldr	r2, [pc, #152]	; (8011a20 <timerJ1939func+0x3ac>)
 8011986:	4618      	mov	r0, r3
 8011988:	4611      	mov	r1, r2
 801198a:	2200      	movs	r2, #0
 801198c:	f008 f8ea 	bl	8019b64 <osMessagePut>
				}
			}
		}
			#if 1
		if(tmp_ca_msg->nm.t250.en == 1)
 8011990:	68fb      	ldr	r3, [r7, #12]
 8011992:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 8011996:	2b01      	cmp	r3, #1
 8011998:	d137      	bne.n	8011a0a <timerJ1939func+0x396>
		{
			if(tmp_ca_msg->nm.t250.release == 1)
 801199a:	68fb      	ldr	r3, [r7, #12]
 801199c:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 80119a0:	2b01      	cmp	r3, #1
 80119a2:	d114      	bne.n	80119ce <timerJ1939func+0x35a>
			{
				tmp_ca_msg->nm.cannotClaimAddr = 1;
 80119a4:	68fb      	ldr	r3, [r7, #12]
 80119a6:	2201      	movs	r2, #1
 80119a8:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
				tmp_ca_msg->nm.WaitingForAddressClaimContention = 0;
 80119ac:	68fb      	ldr	r3, [r7, #12]
 80119ae:	2200      	movs	r2, #0
 80119b0:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
				tmp_ca_msg->nm.t250.en = 0;
 80119b4:	68fb      	ldr	r3, [r7, #12]
 80119b6:	2200      	movs	r2, #0
 80119b8:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
				tmp_ca_msg->nm.t250.value = 0;
 80119bc:	68fb      	ldr	r3, [r7, #12]
 80119be:	2200      	movs	r2, #0
 80119c0:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
				tmp_ca_msg->nm.t250.release = 0;
 80119c4:	68fb      	ldr	r3, [r7, #12]
 80119c6:	2200      	movs	r2, #0
 80119c8:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
 80119cc:	e01d      	b.n	8011a0a <timerJ1939func+0x396>
			}
			else
			{
				if(tmp_ca_msg->nm.t250.value-- == 0)
 80119ce:	68fb      	ldr	r3, [r7, #12]
 80119d0:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
 80119d4:	1e5a      	subs	r2, r3, #1
 80119d6:	b291      	uxth	r1, r2
 80119d8:	68fa      	ldr	r2, [r7, #12]
 80119da:	f8a2 104e 	strh.w	r1, [r2, #78]	; 0x4e
 80119de:	2b00      	cmp	r3, #0
 80119e0:	d113      	bne.n	8011a0a <timerJ1939func+0x396>
				{
					tmp_ca_msg->nm.cannotClaimAddr = 0;
 80119e2:	68fb      	ldr	r3, [r7, #12]
 80119e4:	2200      	movs	r2, #0
 80119e6:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
					tmp_ca_msg->nm.WaitingForAddressClaimContention = 0;
 80119ea:	68fb      	ldr	r3, [r7, #12]
 80119ec:	2200      	movs	r2, #0
 80119ee:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
					tmp_ca_msg->nm.t250.en = 0;
 80119f2:	68fb      	ldr	r3, [r7, #12]
 80119f4:	2200      	movs	r2, #0
 80119f6:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
					tmp_ca_msg->nm.t250.value = 0;
 80119fa:	68fb      	ldr	r3, [r7, #12]
 80119fc:	2200      	movs	r2, #0
 80119fe:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
					tmp_ca_msg->nm.t250.release = 0;
 8011a02:	68fb      	ldr	r3, [r7, #12]
 8011a04:	2200      	movs	r2, #0
 8011a06:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
{
	CA_Msg_t tmp_ca_msg;
	struct list_node *node;
	static struct q_Message q_msg;
	struct CA_node *canode;
	for(node = calist.head.next; node != &(calist.head); node = node->next)
 8011a0a:	697b      	ldr	r3, [r7, #20]
 8011a0c:	681b      	ldr	r3, [r3, #0]
 8011a0e:	617b      	str	r3, [r7, #20]
 8011a10:	697b      	ldr	r3, [r7, #20]
 8011a12:	4a04      	ldr	r2, [pc, #16]	; (8011a24 <timerJ1939func+0x3b0>)
 8011a14:	4293      	cmp	r3, r2
 8011a16:	f47f ae35 	bne.w	8011684 <timerJ1939func+0x10>
				}
			}
		}
			#endif
	}
}
 8011a1a:	3718      	adds	r7, #24
 8011a1c:	46bd      	mov	sp, r7
 8011a1e:	bd80      	pop	{r7, pc}
 8011a20:	200107f4 	.word	0x200107f4
 8011a24:	20012780 	.word	0x20012780

08011a28 <initJ1939>:


 unsigned char initJ1939()
{
 8011a28:	b580      	push	{r7, lr}
 8011a2a:	b088      	sub	sp, #32
 8011a2c:	af00      	add	r7, sp, #0
	unsigned char result = RC_SUCCESS;
 8011a2e:	2300      	movs	r3, #0
 8011a30:	77fb      	strb	r3, [r7, #31]
	osTimerId timerid;
	struct os_timer_def timer_def;
	
	list_init(&(calist.head));
 8011a32:	4810      	ldr	r0, [pc, #64]	; (8011a74 <initJ1939+0x4c>)
 8011a34:	f7fe fcf0 	bl	8010418 <list_init>

	timer_def.flag = osTimerPeriodic;
 8011a38:	2301      	movs	r3, #1
 8011a3a:	753b      	strb	r3, [r7, #20]
	timer_def.name = "J1939timer";
 8011a3c:	4b0e      	ldr	r3, [pc, #56]	; (8011a78 <initJ1939+0x50>)
 8011a3e:	607b      	str	r3, [r7, #4]
	timer_def.parameter = NULL;
 8011a40:	2300      	movs	r3, #0
 8011a42:	60fb      	str	r3, [r7, #12]
	timer_def.time = 1;
 8011a44:	2301      	movs	r3, #1
 8011a46:	613b      	str	r3, [r7, #16]
	timer_def.timeout = timerJ1939func;
 8011a48:	4b0c      	ldr	r3, [pc, #48]	; (8011a7c <initJ1939+0x54>)
 8011a4a:	60bb      	str	r3, [r7, #8]
	timerid = osTimerCreate(&timer_def, osTimerPeriodic, NULL);
 8011a4c:	1d3b      	adds	r3, r7, #4
 8011a4e:	4618      	mov	r0, r3
 8011a50:	2101      	movs	r1, #1
 8011a52:	2200      	movs	r2, #0
 8011a54:	f008 f82e 	bl	8019ab4 <osTimerCreate>
 8011a58:	61b8      	str	r0, [r7, #24]
	if(timerid != NULL) 
 8011a5a:	69bb      	ldr	r3, [r7, #24]
 8011a5c:	2b00      	cmp	r3, #0
 8011a5e:	d004      	beq.n	8011a6a <initJ1939+0x42>
		osTimerStart(timerid,timer_def.time);
 8011a60:	693b      	ldr	r3, [r7, #16]
 8011a62:	69b8      	ldr	r0, [r7, #24]
 8011a64:	4619      	mov	r1, r3
 8011a66:	f008 f849 	bl	8019afc <osTimerStart>
	return result;
 8011a6a:	7ffb      	ldrb	r3, [r7, #31]
}
 8011a6c:	4618      	mov	r0, r3
 8011a6e:	3720      	adds	r7, #32
 8011a70:	46bd      	mov	sp, r7
 8011a72:	bd80      	pop	{r7, pc}
 8011a74:	20012780 	.word	0x20012780
 8011a78:	08026f84 	.word	0x08026f84
 8011a7c:	08011675 	.word	0x08011675

08011a80 <j1939strncmp>:

#include "SAEJ1939.h"

static signed char j1939strncmp(const char *cs, const char *ct, unsigned long count)
{
 8011a80:	b480      	push	{r7}
 8011a82:	b087      	sub	sp, #28
 8011a84:	af00      	add	r7, sp, #0
 8011a86:	60f8      	str	r0, [r7, #12]
 8011a88:	60b9      	str	r1, [r7, #8]
 8011a8a:	607a      	str	r2, [r7, #4]
    signed char __res = 0;
 8011a8c:	2300      	movs	r3, #0
 8011a8e:	75fb      	strb	r3, [r7, #23]
	
	if((cs == NULL) || (ct == NULL))
 8011a90:	68fb      	ldr	r3, [r7, #12]
 8011a92:	2b00      	cmp	r3, #0
 8011a94:	d002      	beq.n	8011a9c <j1939strncmp+0x1c>
 8011a96:	68bb      	ldr	r3, [r7, #8]
 8011a98:	2b00      	cmp	r3, #0
 8011a9a:	d101      	bne.n	8011aa0 <j1939strncmp+0x20>
	{
		return 1;
 8011a9c:	2301      	movs	r3, #1
 8011a9e:	e017      	b.n	8011ad0 <j1939strncmp+0x50>
	}
    while (count)
 8011aa0:	e012      	b.n	8011ac8 <j1939strncmp+0x48>
    {
        if ((__res = *cs++ - *ct++) != 0 )
 8011aa2:	68fb      	ldr	r3, [r7, #12]
 8011aa4:	1c5a      	adds	r2, r3, #1
 8011aa6:	60fa      	str	r2, [r7, #12]
 8011aa8:	781a      	ldrb	r2, [r3, #0]
 8011aaa:	68bb      	ldr	r3, [r7, #8]
 8011aac:	1c59      	adds	r1, r3, #1
 8011aae:	60b9      	str	r1, [r7, #8]
 8011ab0:	781b      	ldrb	r3, [r3, #0]
 8011ab2:	1ad3      	subs	r3, r2, r3
 8011ab4:	b2db      	uxtb	r3, r3
 8011ab6:	75fb      	strb	r3, [r7, #23]
 8011ab8:	f997 3017 	ldrsb.w	r3, [r7, #23]
 8011abc:	2b00      	cmp	r3, #0
 8011abe:	d000      	beq.n	8011ac2 <j1939strncmp+0x42>
            break;
 8011ac0:	e005      	b.n	8011ace <j1939strncmp+0x4e>
        count --;
 8011ac2:	687b      	ldr	r3, [r7, #4]
 8011ac4:	3b01      	subs	r3, #1
 8011ac6:	607b      	str	r3, [r7, #4]
	
	if((cs == NULL) || (ct == NULL))
	{
		return 1;
	}
    while (count)
 8011ac8:	687b      	ldr	r3, [r7, #4]
 8011aca:	2b00      	cmp	r3, #0
 8011acc:	d1e9      	bne.n	8011aa2 <j1939strncmp+0x22>
        if ((__res = *cs++ - *ct++) != 0 )
            break;
        count --;
    }

    return __res;
 8011ace:	7dfb      	ldrb	r3, [r7, #23]
 8011ad0:	b25b      	sxtb	r3, r3
}
 8011ad2:	4618      	mov	r0, r3
 8011ad4:	371c      	adds	r7, #28
 8011ad6:	46bd      	mov	sp, r7
 8011ad8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011adc:	4770      	bx	lr
 8011ade:	bf00      	nop

08011ae0 <CA_FindAddress>:

unsigned char CA_FindAddress(CA_list_t calist,CA_Msg_t ca_msg)
{
 8011ae0:	b580      	push	{r7, lr}
 8011ae2:	b086      	sub	sp, #24
 8011ae4:	af00      	add	r7, sp, #0
 8011ae6:	6078      	str	r0, [r7, #4]
 8011ae8:	6039      	str	r1, [r7, #0]
	list_node_t node;
	struct CA_node *canode;
	J1939_CAname_t CAname = ca_msg->CAname;
 8011aea:	683b      	ldr	r3, [r7, #0]
 8011aec:	681b      	ldr	r3, [r3, #0]
 8011aee:	613b      	str	r3, [r7, #16]
	CA_Msg_t tmp_ca_msg;
	
	for(node = calist->head.next; node != &(calist->head); node = node->next)
 8011af0:	687b      	ldr	r3, [r7, #4]
 8011af2:	685b      	ldr	r3, [r3, #4]
 8011af4:	617b      	str	r3, [r7, #20]
 8011af6:	e015      	b.n	8011b24 <CA_FindAddress+0x44>
	{
		canode = rt_list_entry(node, struct CA_node, node);
 8011af8:	697b      	ldr	r3, [r7, #20]
 8011afa:	3b04      	subs	r3, #4
 8011afc:	60fb      	str	r3, [r7, #12]
		tmp_ca_msg = canode->ca_msg;
 8011afe:	68fb      	ldr	r3, [r7, #12]
 8011b00:	681b      	ldr	r3, [r3, #0]
 8011b02:	60bb      	str	r3, [r7, #8]
		if(j1939strncmp((char *)CAname,(char *)tmp_ca_msg->CAname,sizeof(struct J1939_CAname)) == 0)
 8011b04:	68bb      	ldr	r3, [r7, #8]
 8011b06:	681b      	ldr	r3, [r3, #0]
 8011b08:	6938      	ldr	r0, [r7, #16]
 8011b0a:	4619      	mov	r1, r3
 8011b0c:	2208      	movs	r2, #8
 8011b0e:	f7ff ffb7 	bl	8011a80 <j1939strncmp>
 8011b12:	4603      	mov	r3, r0
 8011b14:	2b00      	cmp	r3, #0
 8011b16:	d102      	bne.n	8011b1e <CA_FindAddress+0x3e>
		{
			return (tmp_ca_msg->msg.SourceAddress);
 8011b18:	68bb      	ldr	r3, [r7, #8]
 8011b1a:	79db      	ldrb	r3, [r3, #7]
 8011b1c:	e008      	b.n	8011b30 <CA_FindAddress+0x50>
	list_node_t node;
	struct CA_node *canode;
	J1939_CAname_t CAname = ca_msg->CAname;
	CA_Msg_t tmp_ca_msg;
	
	for(node = calist->head.next; node != &(calist->head); node = node->next)
 8011b1e:	697b      	ldr	r3, [r7, #20]
 8011b20:	681b      	ldr	r3, [r3, #0]
 8011b22:	617b      	str	r3, [r7, #20]
 8011b24:	687b      	ldr	r3, [r7, #4]
 8011b26:	1d1a      	adds	r2, r3, #4
 8011b28:	697b      	ldr	r3, [r7, #20]
 8011b2a:	429a      	cmp	r2, r3
 8011b2c:	d1e4      	bne.n	8011af8 <CA_FindAddress+0x18>
		{
			return (tmp_ca_msg->msg.SourceAddress);
		}
	}
	
	return 254;
 8011b2e:	23fe      	movs	r3, #254	; 0xfe
}
 8011b30:	4618      	mov	r0, r3
 8011b32:	3718      	adds	r7, #24
 8011b34:	46bd      	mov	sp, r7
 8011b36:	bd80      	pop	{r7, pc}

08011b38 <Addr_FindCA>:
CA_Msg_t Addr_FindCA(CA_list_t calist, unsigned char addr)
{
 8011b38:	b480      	push	{r7}
 8011b3a:	b087      	sub	sp, #28
 8011b3c:	af00      	add	r7, sp, #0
 8011b3e:	6078      	str	r0, [r7, #4]
 8011b40:	460b      	mov	r3, r1
 8011b42:	70fb      	strb	r3, [r7, #3]
	list_node_t node;
	struct CA_node *canode;
	CA_Msg_t tmp_ca_msg;

	for(node = calist->head.next; node != &(calist->head); node = node->next)
 8011b44:	687b      	ldr	r3, [r7, #4]
 8011b46:	685b      	ldr	r3, [r3, #4]
 8011b48:	617b      	str	r3, [r7, #20]
 8011b4a:	e010      	b.n	8011b6e <Addr_FindCA+0x36>
	{
		unsigned char i=0;
 8011b4c:	2300      	movs	r3, #0
 8011b4e:	73fb      	strb	r3, [r7, #15]
		canode = rt_list_entry(node, struct CA_node, node);
 8011b50:	697b      	ldr	r3, [r7, #20]
 8011b52:	3b04      	subs	r3, #4
 8011b54:	60bb      	str	r3, [r7, #8]
		tmp_ca_msg = canode->ca_msg;
 8011b56:	68bb      	ldr	r3, [r7, #8]
 8011b58:	681b      	ldr	r3, [r3, #0]
 8011b5a:	613b      	str	r3, [r7, #16]
		if(tmp_ca_msg->msg.SourceAddress == addr)
 8011b5c:	693b      	ldr	r3, [r7, #16]
 8011b5e:	79db      	ldrb	r3, [r3, #7]
 8011b60:	78fa      	ldrb	r2, [r7, #3]
 8011b62:	429a      	cmp	r2, r3
 8011b64:	d100      	bne.n	8011b68 <Addr_FindCA+0x30>
			break;
 8011b66:	e007      	b.n	8011b78 <Addr_FindCA+0x40>
{
	list_node_t node;
	struct CA_node *canode;
	CA_Msg_t tmp_ca_msg;

	for(node = calist->head.next; node != &(calist->head); node = node->next)
 8011b68:	697b      	ldr	r3, [r7, #20]
 8011b6a:	681b      	ldr	r3, [r3, #0]
 8011b6c:	617b      	str	r3, [r7, #20]
 8011b6e:	687b      	ldr	r3, [r7, #4]
 8011b70:	1d1a      	adds	r2, r3, #4
 8011b72:	697b      	ldr	r3, [r7, #20]
 8011b74:	429a      	cmp	r2, r3
 8011b76:	d1e9      	bne.n	8011b4c <Addr_FindCA+0x14>
		canode = rt_list_entry(node, struct CA_node, node);
		tmp_ca_msg = canode->ca_msg;
		if(tmp_ca_msg->msg.SourceAddress == addr)
			break;
	}
	if(node == &(calist->head) )
 8011b78:	687b      	ldr	r3, [r7, #4]
 8011b7a:	1d1a      	adds	r2, r3, #4
 8011b7c:	697b      	ldr	r3, [r7, #20]
 8011b7e:	429a      	cmp	r2, r3
 8011b80:	d101      	bne.n	8011b86 <Addr_FindCA+0x4e>
		return NULL;
 8011b82:	2300      	movs	r3, #0
 8011b84:	e000      	b.n	8011b88 <Addr_FindCA+0x50>
	else
		return tmp_ca_msg;
 8011b86:	693b      	ldr	r3, [r7, #16]

}
 8011b88:	4618      	mov	r0, r3
 8011b8a:	371c      	adds	r7, #28
 8011b8c:	46bd      	mov	sp, r7
 8011b8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011b92:	4770      	bx	lr

08011b94 <J1939_RequestForAddressClaimHandling>:

unsigned char J1939_RequestForAddressClaimHandling( J1939_msg_t j1939_msg ,CA_Msg_t CA_msg )
{
 8011b94:	b580      	push	{r7, lr}
 8011b96:	b084      	sub	sp, #16
 8011b98:	af00      	add	r7, sp, #0
 8011b9a:	6078      	str	r0, [r7, #4]
 8011b9c:	6039      	str	r1, [r7, #0]
	unsigned char i;
	unsigned char *CA_Name = (unsigned char *)(CA_msg->CAname);
 8011b9e:	683b      	ldr	r3, [r7, #0]
 8011ba0:	681b      	ldr	r3, [r3, #0]
 8011ba2:	60bb      	str	r3, [r7, #8]

	if (CA_msg->nm.cannotClaimAddr)
 8011ba4:	683b      	ldr	r3, [r7, #0]
 8011ba6:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 8011baa:	2b00      	cmp	r3, #0
 8011bac:	d003      	beq.n	8011bb6 <J1939_RequestForAddressClaimHandling+0x22>
		j1939_msg->SourceAddress = J1939_NULL_ADDRESS;	// Send Cannot Claim Address message
 8011bae:	687b      	ldr	r3, [r7, #4]
 8011bb0:	22fe      	movs	r2, #254	; 0xfe
 8011bb2:	70da      	strb	r2, [r3, #3]
 8011bb4:	e003      	b.n	8011bbe <J1939_RequestForAddressClaimHandling+0x2a>
	else
		j1939_msg->SourceAddress = CA_msg->msg.SourceAddress;		// Send Address Claim for current address
 8011bb6:	683b      	ldr	r3, [r7, #0]
 8011bb8:	79da      	ldrb	r2, [r3, #7]
 8011bba:	687b      	ldr	r3, [r7, #4]
 8011bbc:	70da      	strb	r2, [r3, #3]

	j1939_msg->Priority = 6;
 8011bbe:	687a      	ldr	r2, [r7, #4]
 8011bc0:	7813      	ldrb	r3, [r2, #0]
 8011bc2:	2106      	movs	r1, #6
 8011bc4:	f361 1347 	bfi	r3, r1, #5, #3
 8011bc8:	7013      	strb	r3, [r2, #0]
	j1939_msg->PDUFormat = J1939_PF_ADDRESS_CLAIMED;	// Same as J1939_PF_CANNOT_CLAIM_ADDRESS
 8011bca:	687b      	ldr	r3, [r7, #4]
 8011bcc:	22ee      	movs	r2, #238	; 0xee
 8011bce:	705a      	strb	r2, [r3, #1]
	j1939_msg->PDUSpecific = J1939_GLOBAL_ADDRESS;
 8011bd0:	687b      	ldr	r3, [r7, #4]
 8011bd2:	22ff      	movs	r2, #255	; 0xff
 8011bd4:	709a      	strb	r2, [r3, #2]
	j1939_msg->DataLength = J1939_DATA_LENGTH;
 8011bd6:	687a      	ldr	r2, [r7, #4]
 8011bd8:	7913      	ldrb	r3, [r2, #4]
 8011bda:	2108      	movs	r1, #8
 8011bdc:	f361 0303 	bfi	r3, r1, #0, #4
 8011be0:	7113      	strb	r3, [r2, #4]

	for (i=0; i<J1939_DATA_LENGTH; i++)
 8011be2:	2300      	movs	r3, #0
 8011be4:	73fb      	strb	r3, [r7, #15]
 8011be6:	e00b      	b.n	8011c00 <J1939_RequestForAddressClaimHandling+0x6c>
		j1939_msg->Data[i] = CA_Name[i];
 8011be8:	7bfb      	ldrb	r3, [r7, #15]
 8011bea:	7bfa      	ldrb	r2, [r7, #15]
 8011bec:	68b9      	ldr	r1, [r7, #8]
 8011bee:	440a      	add	r2, r1
 8011bf0:	7811      	ldrb	r1, [r2, #0]
 8011bf2:	687a      	ldr	r2, [r7, #4]
 8011bf4:	4413      	add	r3, r2
 8011bf6:	460a      	mov	r2, r1
 8011bf8:	715a      	strb	r2, [r3, #5]
	j1939_msg->Priority = 6;
	j1939_msg->PDUFormat = J1939_PF_ADDRESS_CLAIMED;	// Same as J1939_PF_CANNOT_CLAIM_ADDRESS
	j1939_msg->PDUSpecific = J1939_GLOBAL_ADDRESS;
	j1939_msg->DataLength = J1939_DATA_LENGTH;

	for (i=0; i<J1939_DATA_LENGTH; i++)
 8011bfa:	7bfb      	ldrb	r3, [r7, #15]
 8011bfc:	3301      	adds	r3, #1
 8011bfe:	73fb      	strb	r3, [r7, #15]
 8011c00:	7bfb      	ldrb	r3, [r7, #15]
 8011c02:	2b07      	cmp	r3, #7
 8011c04:	d9f0      	bls.n	8011be8 <J1939_RequestForAddressClaimHandling+0x54>
		j1939_msg->Data[i] = CA_Name[i];
	
	return writeCan(j1939_msg);
 8011c06:	6878      	ldr	r0, [r7, #4]
 8011c08:	f000 f92e 	bl	8011e68 <writeCan>
 8011c0c:	4603      	mov	r3, r0
}
 8011c0e:	4618      	mov	r0, r3
 8011c10:	3710      	adds	r7, #16
 8011c12:	46bd      	mov	sp, r7
 8011c14:	bd80      	pop	{r7, pc}
 8011c16:	bf00      	nop

08011c18 <CompareName>:

signed char CompareName( unsigned char *OtherName,CA_Msg_t CA_msg  )
{
 8011c18:	b480      	push	{r7}
 8011c1a:	b085      	sub	sp, #20
 8011c1c:	af00      	add	r7, sp, #0
 8011c1e:	6078      	str	r0, [r7, #4]
 8011c20:	6039      	str	r1, [r7, #0]
	unsigned char	i;
	unsigned char *CA_Name = (unsigned char *)(CA_msg->CAname);
 8011c22:	683b      	ldr	r3, [r7, #0]
 8011c24:	681b      	ldr	r3, [r3, #0]
 8011c26:	60bb      	str	r3, [r7, #8]
	
	for (i = 0; (i<J1939_DATA_LENGTH) && (OtherName[i] == CA_Name[i]); i++);
 8011c28:	2300      	movs	r3, #0
 8011c2a:	73fb      	strb	r3, [r7, #15]
 8011c2c:	e002      	b.n	8011c34 <CompareName+0x1c>
 8011c2e:	7bfb      	ldrb	r3, [r7, #15]
 8011c30:	3301      	adds	r3, #1
 8011c32:	73fb      	strb	r3, [r7, #15]
 8011c34:	7bfb      	ldrb	r3, [r7, #15]
 8011c36:	2b07      	cmp	r3, #7
 8011c38:	d809      	bhi.n	8011c4e <CompareName+0x36>
 8011c3a:	7bfb      	ldrb	r3, [r7, #15]
 8011c3c:	687a      	ldr	r2, [r7, #4]
 8011c3e:	4413      	add	r3, r2
 8011c40:	781a      	ldrb	r2, [r3, #0]
 8011c42:	7bfb      	ldrb	r3, [r7, #15]
 8011c44:	68b9      	ldr	r1, [r7, #8]
 8011c46:	440b      	add	r3, r1
 8011c48:	781b      	ldrb	r3, [r3, #0]
 8011c4a:	429a      	cmp	r2, r3
 8011c4c:	d0ef      	beq.n	8011c2e <CompareName+0x16>

	if (i == J1939_DATA_LENGTH)
 8011c4e:	7bfb      	ldrb	r3, [r7, #15]
 8011c50:	2b08      	cmp	r3, #8
 8011c52:	d101      	bne.n	8011c58 <CompareName+0x40>
		return 0;
 8011c54:	2300      	movs	r3, #0
 8011c56:	e00c      	b.n	8011c72 <CompareName+0x5a>
	else if (CA_Name[i] < OtherName[i] )
 8011c58:	7bfb      	ldrb	r3, [r7, #15]
 8011c5a:	68ba      	ldr	r2, [r7, #8]
 8011c5c:	4413      	add	r3, r2
 8011c5e:	781a      	ldrb	r2, [r3, #0]
 8011c60:	7bfb      	ldrb	r3, [r7, #15]
 8011c62:	6879      	ldr	r1, [r7, #4]
 8011c64:	440b      	add	r3, r1
 8011c66:	781b      	ldrb	r3, [r3, #0]
 8011c68:	429a      	cmp	r2, r3
 8011c6a:	d201      	bcs.n	8011c70 <CompareName+0x58>
		return -1;
 8011c6c:	23ff      	movs	r3, #255	; 0xff
 8011c6e:	e000      	b.n	8011c72 <CompareName+0x5a>
	else
		return 1;
 8011c70:	2301      	movs	r3, #1
 8011c72:	b25b      	sxtb	r3, r3
}
 8011c74:	4618      	mov	r0, r3
 8011c76:	3714      	adds	r7, #20
 8011c78:	46bd      	mov	sp, r7
 8011c7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011c7e:	4770      	bx	lr

08011c80 <J1939_AddressClaimHandling>:

unsigned char J1939_AddressClaimHandling(  J1939_msg_t j1939_msg ,CA_Msg_t CA_msg  )
{
 8011c80:	b580      	push	{r7, lr}
 8011c82:	b084      	sub	sp, #16
 8011c84:	af00      	add	r7, sp, #0
 8011c86:	6078      	str	r0, [r7, #4]
 8011c88:	6039      	str	r1, [r7, #0]

	unsigned char i;
	unsigned char *CA_Name = (unsigned char *)(CA_msg->CAname);
 8011c8a:	683b      	ldr	r3, [r7, #0]
 8011c8c:	681b      	ldr	r3, [r3, #0]
 8011c8e:	60bb      	str	r3, [r7, #8]
	
	j1939_msg->Priority = 6;
 8011c90:	687a      	ldr	r2, [r7, #4]
 8011c92:	7813      	ldrb	r3, [r2, #0]
 8011c94:	2106      	movs	r1, #6
 8011c96:	f361 1347 	bfi	r3, r1, #5, #3
 8011c9a:	7013      	strb	r3, [r2, #0]
	j1939_msg->PDUFormat = J1939_PF_ADDRESS_CLAIMED;
 8011c9c:	687b      	ldr	r3, [r7, #4]
 8011c9e:	22ee      	movs	r2, #238	; 0xee
 8011ca0:	705a      	strb	r2, [r3, #1]
	j1939_msg->PDUSpecific = J1939_GLOBAL_ADDRESS;
 8011ca2:	687b      	ldr	r3, [r7, #4]
 8011ca4:	22ff      	movs	r2, #255	; 0xff
 8011ca6:	709a      	strb	r2, [r3, #2]
	j1939_msg->DataLength = J1939_DATA_LENGTH;
 8011ca8:	687a      	ldr	r2, [r7, #4]
 8011caa:	7913      	ldrb	r3, [r2, #4]
 8011cac:	2108      	movs	r1, #8
 8011cae:	f361 0303 	bfi	r3, r1, #0, #4
 8011cb2:	7113      	strb	r3, [r2, #4]


	//if (j1939_msg->SourceAddress != CA_msg->msg.SourceAddress)
	//	return RC_ERROR;

	if (CompareName( j1939_msg->Data,CA_msg ) != -1) // Our CA_Name is not less
 8011cb4:	687b      	ldr	r3, [r7, #4]
 8011cb6:	3305      	adds	r3, #5
 8011cb8:	4618      	mov	r0, r3
 8011cba:	6839      	ldr	r1, [r7, #0]
 8011cbc:	f7ff ffac 	bl	8011c18 <CompareName>
 8011cc0:	4603      	mov	r3, r0
 8011cc2:	f1b3 3fff 	cmp.w	r3, #4294967295
 8011cc6:	d022      	beq.n	8011d0e <J1939_AddressClaimHandling+0x8e>
	{

		for (i=0; i<J1939_DATA_LENGTH; i++)
 8011cc8:	2300      	movs	r3, #0
 8011cca:	73fb      	strb	r3, [r7, #15]
 8011ccc:	e00b      	b.n	8011ce6 <J1939_AddressClaimHandling+0x66>
			j1939_msg->Data[i] = CA_Name[i];
 8011cce:	7bfb      	ldrb	r3, [r7, #15]
 8011cd0:	7bfa      	ldrb	r2, [r7, #15]
 8011cd2:	68b9      	ldr	r1, [r7, #8]
 8011cd4:	440a      	add	r2, r1
 8011cd6:	7811      	ldrb	r1, [r2, #0]
 8011cd8:	687a      	ldr	r2, [r7, #4]
 8011cda:	4413      	add	r3, r2
 8011cdc:	460a      	mov	r2, r1
 8011cde:	715a      	strb	r2, [r3, #5]
	//	return RC_ERROR;

	if (CompareName( j1939_msg->Data,CA_msg ) != -1) // Our CA_Name is not less
	{

		for (i=0; i<J1939_DATA_LENGTH; i++)
 8011ce0:	7bfb      	ldrb	r3, [r7, #15]
 8011ce2:	3301      	adds	r3, #1
 8011ce4:	73fb      	strb	r3, [r7, #15]
 8011ce6:	7bfb      	ldrb	r3, [r7, #15]
 8011ce8:	2b07      	cmp	r3, #7
 8011cea:	d9f0      	bls.n	8011cce <J1939_AddressClaimHandling+0x4e>
			j1939_msg->Data[i] = CA_Name[i];
		
		j1939_msg->SourceAddress = J1939_NULL_ADDRESS;
 8011cec:	687b      	ldr	r3, [r7, #4]
 8011cee:	22fe      	movs	r2, #254	; 0xfe
 8011cf0:	70da      	strb	r2, [r3, #3]
		if(writeCan(j1939_msg)== RC_SUCCESS)
 8011cf2:	6878      	ldr	r0, [r7, #4]
 8011cf4:	f000 f8b8 	bl	8011e68 <writeCan>
 8011cf8:	4603      	mov	r3, r0
 8011cfa:	2b00      	cmp	r3, #0
 8011cfc:	d105      	bne.n	8011d0a <J1939_AddressClaimHandling+0x8a>
		{
			CA_msg->nm.t250.release = 1;
 8011cfe:	683b      	ldr	r3, [r7, #0]
 8011d00:	2201      	movs	r2, #1
 8011d02:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
			return RC_SUCCESS;
 8011d06:	2300      	movs	r3, #0
 8011d08:	e042      	b.n	8011d90 <J1939_AddressClaimHandling+0x110>
		}
		else 
			return RC_CANNOTTRANSMIT;
 8011d0a:	230a      	movs	r3, #10
 8011d0c:	e040      	b.n	8011d90 <J1939_AddressClaimHandling+0x110>
	}
	
	for (i=0; i<J1939_DATA_LENGTH; i++)
 8011d0e:	2300      	movs	r3, #0
 8011d10:	73fb      	strb	r3, [r7, #15]
 8011d12:	e00b      	b.n	8011d2c <J1939_AddressClaimHandling+0xac>
		j1939_msg->Data[i] = CA_Name[i];
 8011d14:	7bfb      	ldrb	r3, [r7, #15]
 8011d16:	7bfa      	ldrb	r2, [r7, #15]
 8011d18:	68b9      	ldr	r1, [r7, #8]
 8011d1a:	440a      	add	r2, r1
 8011d1c:	7811      	ldrb	r1, [r2, #0]
 8011d1e:	687a      	ldr	r2, [r7, #4]
 8011d20:	4413      	add	r3, r2
 8011d22:	460a      	mov	r2, r1
 8011d24:	715a      	strb	r2, [r3, #5]
		}
		else 
			return RC_CANNOTTRANSMIT;
	}
	
	for (i=0; i<J1939_DATA_LENGTH; i++)
 8011d26:	7bfb      	ldrb	r3, [r7, #15]
 8011d28:	3301      	adds	r3, #1
 8011d2a:	73fb      	strb	r3, [r7, #15]
 8011d2c:	7bfb      	ldrb	r3, [r7, #15]
 8011d2e:	2b07      	cmp	r3, #7
 8011d30:	d9f0      	bls.n	8011d14 <J1939_AddressClaimHandling+0x94>
		j1939_msg->Data[i] = CA_Name[i];

	j1939_msg->SourceAddress = CA_msg->msg.SourceAddress;
 8011d32:	683b      	ldr	r3, [r7, #0]
 8011d34:	79da      	ldrb	r2, [r3, #7]
 8011d36:	687b      	ldr	r3, [r7, #4]
 8011d38:	70da      	strb	r2, [r3, #3]
	
	if (writeCan(j1939_msg ) == RC_SUCCESS)
 8011d3a:	6878      	ldr	r0, [r7, #4]
 8011d3c:	f000 f894 	bl	8011e68 <writeCan>
 8011d40:	4603      	mov	r3, r0
 8011d42:	2b00      	cmp	r3, #0
 8011d44:	d121      	bne.n	8011d8a <J1939_AddressClaimHandling+0x10a>
	{
		if ((( CA_msg->msg.SourceAddress & 0x80) == 0) ||			// Addresses 0-127
 8011d46:	683b      	ldr	r3, [r7, #0]
 8011d48:	79db      	ldrb	r3, [r3, #7]
 8011d4a:	b2db      	uxtb	r3, r3
 8011d4c:	b25b      	sxtb	r3, r3
 8011d4e:	2b00      	cmp	r3, #0
 8011d50:	da05      	bge.n	8011d5e <J1939_AddressClaimHandling+0xde>
			(( CA_msg->msg.SourceAddress & 0xF8) == 0xF8))		// Addresses 248-253 (254,255 illegal)
 8011d52:	683b      	ldr	r3, [r7, #0]
 8011d54:	79db      	ldrb	r3, [r3, #7]
 8011d56:	f003 03f8 	and.w	r3, r3, #248	; 0xf8

	j1939_msg->SourceAddress = CA_msg->msg.SourceAddress;
	
	if (writeCan(j1939_msg ) == RC_SUCCESS)
	{
		if ((( CA_msg->msg.SourceAddress & 0x80) == 0) ||			// Addresses 0-127
 8011d5a:	2bf8      	cmp	r3, #248	; 0xf8
 8011d5c:	d104      	bne.n	8011d68 <J1939_AddressClaimHandling+0xe8>
			(( CA_msg->msg.SourceAddress & 0xF8) == 0xF8))		// Addresses 248-253 (254,255 illegal)
		{
			CA_msg->nm.cannotClaimAddr = 0;
 8011d5e:	683b      	ldr	r3, [r7, #0]
 8011d60:	2200      	movs	r2, #0
 8011d62:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 8011d66:	e012      	b.n	8011d8e <J1939_AddressClaimHandling+0x10e>
		}
		else
		{
			// We don't have a proprietary address, so we need to wait.
	 		CA_msg->nm.WaitingForAddressClaimContention = 1;
 8011d68:	683b      	ldr	r3, [r7, #0]
 8011d6a:	2201      	movs	r2, #1
 8011d6c:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
	 		//if (CA_msg->nm.WaitingForAddressClaimContention == 0)
	 		//{
			//	CA_msg->nm.cannotClaimAddr = 0;
	 		//}
			#if 1
			CA_msg->nm.t250.value = 250;
 8011d70:	683b      	ldr	r3, [r7, #0]
 8011d72:	22fa      	movs	r2, #250	; 0xfa
 8011d74:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
			CA_msg->nm.t250.en = 1;
 8011d78:	683b      	ldr	r3, [r7, #0]
 8011d7a:	2201      	movs	r2, #1
 8011d7c:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
			CA_msg->nm.t250.release = 0;
 8011d80:	683b      	ldr	r3, [r7, #0]
 8011d82:	2200      	movs	r2, #0
 8011d84:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
 8011d88:	e001      	b.n	8011d8e <J1939_AddressClaimHandling+0x10e>
			#endif
		}
	}
	else 
		return RC_CANNOTTRANSMIT;
 8011d8a:	230a      	movs	r3, #10
 8011d8c:	e000      	b.n	8011d90 <J1939_AddressClaimHandling+0x110>
	return RC_SUCCESS;
 8011d8e:	2300      	movs	r3, #0
}
 8011d90:	4618      	mov	r0, r3
 8011d92:	3710      	adds	r7, #16
 8011d94:	46bd      	mov	sp, r7
 8011d96:	bd80      	pop	{r7, pc}

08011d98 <sendAddrClaimed>:

unsigned char sendAddrClaimed(CA_Msg_t CA_msg)
{
 8011d98:	b580      	push	{r7, lr}
 8011d9a:	b088      	sub	sp, #32
 8011d9c:	af00      	add	r7, sp, #0
 8011d9e:	6078      	str	r0, [r7, #4]
	struct J1939_msg j1939_msg;
	unsigned char *CA_Name = (unsigned char *)(CA_msg->CAname);
 8011da0:	687b      	ldr	r3, [r7, #4]
 8011da2:	681b      	ldr	r3, [r3, #0]
 8011da4:	61bb      	str	r3, [r7, #24]
	unsigned char i;
	
	CA_msg->nm.cannotClaimAddr = 1;
 8011da6:	687b      	ldr	r3, [r7, #4]
 8011da8:	2201      	movs	r2, #1
 8011daa:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
	
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;		// Send Address Claim for current address
 8011dae:	687b      	ldr	r3, [r7, #4]
 8011db0:	79db      	ldrb	r3, [r3, #7]
 8011db2:	72fb      	strb	r3, [r7, #11]
	j1939_msg.Priority = 6;
 8011db4:	7a3b      	ldrb	r3, [r7, #8]
 8011db6:	2206      	movs	r2, #6
 8011db8:	f362 1347 	bfi	r3, r2, #5, #3
 8011dbc:	723b      	strb	r3, [r7, #8]
	j1939_msg.edp = 0;
 8011dbe:	7a3b      	ldrb	r3, [r7, #8]
 8011dc0:	f36f 1304 	bfc	r3, #4, #1
 8011dc4:	723b      	strb	r3, [r7, #8]
	j1939_msg.DataPage = 0;
 8011dc6:	7a3b      	ldrb	r3, [r7, #8]
 8011dc8:	f36f 03c3 	bfc	r3, #3, #1
 8011dcc:	723b      	strb	r3, [r7, #8]
	j1939_msg.PDUFormat = J1939_PF_ADDRESS_CLAIMED;	// Same as J1939_PF_CANNOT_CLAIM_ADDRESS
 8011dce:	23ee      	movs	r3, #238	; 0xee
 8011dd0:	727b      	strb	r3, [r7, #9]
	j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
 8011dd2:	23ff      	movs	r3, #255	; 0xff
 8011dd4:	72bb      	strb	r3, [r7, #10]
	j1939_msg.DataLength = J1939_DATA_LENGTH;
 8011dd6:	7b3b      	ldrb	r3, [r7, #12]
 8011dd8:	2208      	movs	r2, #8
 8011dda:	f362 0303 	bfi	r3, r2, #0, #4
 8011dde:	733b      	strb	r3, [r7, #12]

	for (i=0; i<J1939_DATA_LENGTH; i++)
 8011de0:	2300      	movs	r3, #0
 8011de2:	77fb      	strb	r3, [r7, #31]
 8011de4:	e00c      	b.n	8011e00 <sendAddrClaimed+0x68>
		j1939_msg.Data[i] = CA_Name[i];
 8011de6:	7ffb      	ldrb	r3, [r7, #31]
 8011de8:	7ffa      	ldrb	r2, [r7, #31]
 8011dea:	69b9      	ldr	r1, [r7, #24]
 8011dec:	440a      	add	r2, r1
 8011dee:	7812      	ldrb	r2, [r2, #0]
 8011df0:	f107 0120 	add.w	r1, r7, #32
 8011df4:	440b      	add	r3, r1
 8011df6:	f803 2c13 	strb.w	r2, [r3, #-19]
	j1939_msg.DataPage = 0;
	j1939_msg.PDUFormat = J1939_PF_ADDRESS_CLAIMED;	// Same as J1939_PF_CANNOT_CLAIM_ADDRESS
	j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
	j1939_msg.DataLength = J1939_DATA_LENGTH;

	for (i=0; i<J1939_DATA_LENGTH; i++)
 8011dfa:	7ffb      	ldrb	r3, [r7, #31]
 8011dfc:	3301      	adds	r3, #1
 8011dfe:	77fb      	strb	r3, [r7, #31]
 8011e00:	7ffb      	ldrb	r3, [r7, #31]
 8011e02:	2b07      	cmp	r3, #7
 8011e04:	d9ef      	bls.n	8011de6 <sendAddrClaimed+0x4e>
		j1939_msg.Data[i] = CA_Name[i];
	
	if(writeCan(&j1939_msg)==RC_SUCCESS)
 8011e06:	f107 0308 	add.w	r3, r7, #8
 8011e0a:	4618      	mov	r0, r3
 8011e0c:	f000 f82c 	bl	8011e68 <writeCan>
 8011e10:	4603      	mov	r3, r0
 8011e12:	2b00      	cmp	r3, #0
 8011e14:	d111      	bne.n	8011e3a <sendAddrClaimed+0xa2>
	{
		// We don't have a proprietary address, so we need to wait.
		CA_msg->nm.WaitingForAddressClaimContention = 1;
 8011e16:	687b      	ldr	r3, [r7, #4]
 8011e18:	2201      	movs	r2, #1
 8011e1a:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
		//if (CA_msg->nm.WaitingForAddressClaimContention == 0)
		//{
		//	CA_msg->nm.cannotClaimAddr = 0;
		//}
		#if 1
		CA_msg->nm.t250.value = 250;
 8011e1e:	687b      	ldr	r3, [r7, #4]
 8011e20:	22fa      	movs	r2, #250	; 0xfa
 8011e22:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
		CA_msg->nm.t250.en = 1;
 8011e26:	687b      	ldr	r3, [r7, #4]
 8011e28:	2201      	movs	r2, #1
 8011e2a:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
		CA_msg->nm.t250.release = 0;
 8011e2e:	687b      	ldr	r3, [r7, #4]
 8011e30:	2200      	movs	r2, #0
 8011e32:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
		#endif

		return RC_SUCCESS;
 8011e36:	2300      	movs	r3, #0
 8011e38:	e000      	b.n	8011e3c <sendAddrClaimed+0xa4>
	}
	return RC_CANNOTTRANSMIT;
 8011e3a:	230a      	movs	r3, #10
}
 8011e3c:	4618      	mov	r0, r3
 8011e3e:	3720      	adds	r7, #32
 8011e40:	46bd      	mov	sp, r7
 8011e42:	bd80      	pop	{r7, pc}

08011e44 <initAddr>:


unsigned char initAddr(CA_Msg_t ca_msg)
{
 8011e44:	b580      	push	{r7, lr}
 8011e46:	b082      	sub	sp, #8
 8011e48:	af00      	add	r7, sp, #0
 8011e4a:	6078      	str	r0, [r7, #4]
	if(ca_msg->msg.SourceAddress != 254)
 8011e4c:	687b      	ldr	r3, [r7, #4]
 8011e4e:	79db      	ldrb	r3, [r3, #7]
 8011e50:	2bfe      	cmp	r3, #254	; 0xfe
 8011e52:	d004      	beq.n	8011e5e <initAddr+0x1a>
	{
		return sendAddrClaimed(ca_msg);
 8011e54:	6878      	ldr	r0, [r7, #4]
 8011e56:	f7ff ff9f 	bl	8011d98 <sendAddrClaimed>
 8011e5a:	4603      	mov	r3, r0
 8011e5c:	e000      	b.n	8011e60 <initAddr+0x1c>
	}
	return RC_ERROR;
 8011e5e:	2301      	movs	r3, #1
}
 8011e60:	4618      	mov	r0, r3
 8011e62:	3708      	adds	r7, #8
 8011e64:	46bd      	mov	sp, r7
 8011e66:	bd80      	pop	{r7, pc}

08011e68 <writeCan>:
#include "finsh.h"
#include <rtdevice.h>
#include "SAEJ1939.h"

unsigned char writeCan(J1939_msg_t j1939_msg)
{
 8011e68:	b580      	push	{r7, lr}
 8011e6a:	b088      	sub	sp, #32
 8011e6c:	af00      	add	r7, sp, #0
 8011e6e:	6078      	str	r0, [r7, #4]
	rt_device_t device;
	device = rt_device_find("can1");
 8011e70:	4831      	ldr	r0, [pc, #196]	; (8011f38 <writeCan+0xd0>)
 8011e72:	f003 fe95 	bl	8015ba0 <rt_device_find>
 8011e76:	61f8      	str	r0, [r7, #28]
	struct rt_can_msg tmpmsg;
	unsigned long tmp;
	
	if(device != NULL)
 8011e78:	69fb      	ldr	r3, [r7, #28]
 8011e7a:	2b00      	cmp	r3, #0
 8011e7c:	d057      	beq.n	8011f2e <writeCan+0xc6>
	{
		tmpmsg.data[7] = j1939_msg->Data[7];
 8011e7e:	687b      	ldr	r3, [r7, #4]
 8011e80:	7b1b      	ldrb	r3, [r3, #12]
 8011e82:	75fb      	strb	r3, [r7, #23]
		tmpmsg.data[6] = j1939_msg->Data[6];
 8011e84:	687b      	ldr	r3, [r7, #4]
 8011e86:	7adb      	ldrb	r3, [r3, #11]
 8011e88:	75bb      	strb	r3, [r7, #22]
		tmpmsg.data[5] = j1939_msg->Data[5];
 8011e8a:	687b      	ldr	r3, [r7, #4]
 8011e8c:	7a9b      	ldrb	r3, [r3, #10]
 8011e8e:	757b      	strb	r3, [r7, #21]
		tmpmsg.data[4] = j1939_msg->Data[4];
 8011e90:	687b      	ldr	r3, [r7, #4]
 8011e92:	7a5b      	ldrb	r3, [r3, #9]
 8011e94:	753b      	strb	r3, [r7, #20]
		tmpmsg.data[3] = j1939_msg->Data[3];
 8011e96:	687b      	ldr	r3, [r7, #4]
 8011e98:	7a1b      	ldrb	r3, [r3, #8]
 8011e9a:	74fb      	strb	r3, [r7, #19]
		tmpmsg.data[2] = j1939_msg->Data[2];
 8011e9c:	687b      	ldr	r3, [r7, #4]
 8011e9e:	79db      	ldrb	r3, [r3, #7]
 8011ea0:	74bb      	strb	r3, [r7, #18]
		tmpmsg.data[1] = j1939_msg->Data[1];
 8011ea2:	687b      	ldr	r3, [r7, #4]
 8011ea4:	799b      	ldrb	r3, [r3, #6]
 8011ea6:	747b      	strb	r3, [r7, #17]
		tmpmsg.data[0] = j1939_msg->Data[0];
 8011ea8:	687b      	ldr	r3, [r7, #4]
 8011eaa:	795b      	ldrb	r3, [r3, #5]
 8011eac:	743b      	strb	r3, [r7, #16]
		tmp = (unsigned long)(j1939_msg->Priority)<<26 			| 	\
 8011eae:	687b      	ldr	r3, [r7, #4]
 8011eb0:	781b      	ldrb	r3, [r3, #0]
 8011eb2:	f3c3 1342 	ubfx	r3, r3, #5, #3
 8011eb6:	b2db      	uxtb	r3, r3
 8011eb8:	069a      	lsls	r2, r3, #26
				(unsigned long)(j1939_msg->edp)<<25				|  	\
 8011eba:	687b      	ldr	r3, [r7, #4]
 8011ebc:	781b      	ldrb	r3, [r3, #0]
 8011ebe:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8011ec2:	b2db      	uxtb	r3, r3
 8011ec4:	065b      	lsls	r3, r3, #25
		tmpmsg.data[4] = j1939_msg->Data[4];
		tmpmsg.data[3] = j1939_msg->Data[3];
		tmpmsg.data[2] = j1939_msg->Data[2];
		tmpmsg.data[1] = j1939_msg->Data[1];
		tmpmsg.data[0] = j1939_msg->Data[0];
		tmp = (unsigned long)(j1939_msg->Priority)<<26 			| 	\
 8011ec6:	431a      	orrs	r2, r3
				(unsigned long)(j1939_msg->edp)<<25				|  	\
				(unsigned long)(j1939_msg->DataPage)<<24				|  	\
 8011ec8:	687b      	ldr	r3, [r7, #4]
 8011eca:	781b      	ldrb	r3, [r3, #0]
 8011ecc:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8011ed0:	b2db      	uxtb	r3, r3
 8011ed2:	061b      	lsls	r3, r3, #24
		tmpmsg.data[3] = j1939_msg->Data[3];
		tmpmsg.data[2] = j1939_msg->Data[2];
		tmpmsg.data[1] = j1939_msg->Data[1];
		tmpmsg.data[0] = j1939_msg->Data[0];
		tmp = (unsigned long)(j1939_msg->Priority)<<26 			| 	\
				(unsigned long)(j1939_msg->edp)<<25				|  	\
 8011ed4:	431a      	orrs	r2, r3
				(unsigned long)(j1939_msg->DataPage)<<24				|  	\
				(unsigned long)(j1939_msg->PDUFormat)<<16		|  	\
 8011ed6:	687b      	ldr	r3, [r7, #4]
 8011ed8:	785b      	ldrb	r3, [r3, #1]
 8011eda:	041b      	lsls	r3, r3, #16
		tmpmsg.data[2] = j1939_msg->Data[2];
		tmpmsg.data[1] = j1939_msg->Data[1];
		tmpmsg.data[0] = j1939_msg->Data[0];
		tmp = (unsigned long)(j1939_msg->Priority)<<26 			| 	\
				(unsigned long)(j1939_msg->edp)<<25				|  	\
				(unsigned long)(j1939_msg->DataPage)<<24				|  	\
 8011edc:	431a      	orrs	r2, r3
				(unsigned long)(j1939_msg->PDUFormat)<<16		|  	\
				(unsigned long)(j1939_msg->PDUSpecific)<<8		|	\
 8011ede:	687b      	ldr	r3, [r7, #4]
 8011ee0:	789b      	ldrb	r3, [r3, #2]
 8011ee2:	021b      	lsls	r3, r3, #8
		tmpmsg.data[1] = j1939_msg->Data[1];
		tmpmsg.data[0] = j1939_msg->Data[0];
		tmp = (unsigned long)(j1939_msg->Priority)<<26 			| 	\
				(unsigned long)(j1939_msg->edp)<<25				|  	\
				(unsigned long)(j1939_msg->DataPage)<<24				|  	\
				(unsigned long)(j1939_msg->PDUFormat)<<16		|  	\
 8011ee4:	4313      	orrs	r3, r2
				(unsigned long)(j1939_msg->PDUSpecific)<<8		|	\
				(unsigned long)(j1939_msg->SourceAddress);		
 8011ee6:	687a      	ldr	r2, [r7, #4]
 8011ee8:	78d2      	ldrb	r2, [r2, #3]
		tmpmsg.data[4] = j1939_msg->Data[4];
		tmpmsg.data[3] = j1939_msg->Data[3];
		tmpmsg.data[2] = j1939_msg->Data[2];
		tmpmsg.data[1] = j1939_msg->Data[1];
		tmpmsg.data[0] = j1939_msg->Data[0];
		tmp = (unsigned long)(j1939_msg->Priority)<<26 			| 	\
 8011eea:	4313      	orrs	r3, r2
 8011eec:	61bb      	str	r3, [r7, #24]
				(unsigned long)(j1939_msg->edp)<<25				|  	\
				(unsigned long)(j1939_msg->DataPage)<<24				|  	\
				(unsigned long)(j1939_msg->PDUFormat)<<16		|  	\
				(unsigned long)(j1939_msg->PDUSpecific)<<8		|	\
				(unsigned long)(j1939_msg->SourceAddress);		
		tmpmsg.id = tmp;
 8011eee:	69bb      	ldr	r3, [r7, #24]
 8011ef0:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
 8011ef4:	68bb      	ldr	r3, [r7, #8]
 8011ef6:	f362 031c 	bfi	r3, r2, #0, #29
 8011efa:	60bb      	str	r3, [r7, #8]
		tmpmsg.ide = 1;
 8011efc:	7afb      	ldrb	r3, [r7, #11]
 8011efe:	f043 0320 	orr.w	r3, r3, #32
 8011f02:	72fb      	strb	r3, [r7, #11]
		tmpmsg.len = j1939_msg->DataLength;
 8011f04:	687b      	ldr	r3, [r7, #4]
 8011f06:	791b      	ldrb	r3, [r3, #4]
 8011f08:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8011f0c:	b2db      	uxtb	r3, r3
 8011f0e:	733b      	strb	r3, [r7, #12]
		tmpmsg.rtr = 0;
 8011f10:	7afb      	ldrb	r3, [r7, #11]
 8011f12:	f36f 1386 	bfc	r3, #6, #1
 8011f16:	72fb      	strb	r3, [r7, #11]
		
		return rt_device_write(device, 0, &tmpmsg,1);
 8011f18:	f107 0308 	add.w	r3, r7, #8
 8011f1c:	69f8      	ldr	r0, [r7, #28]
 8011f1e:	2100      	movs	r1, #0
 8011f20:	461a      	mov	r2, r3
 8011f22:	2301      	movs	r3, #1
 8011f24:	f003 ff5e 	bl	8015de4 <rt_device_write>
 8011f28:	4603      	mov	r3, r0
 8011f2a:	b2db      	uxtb	r3, r3
 8011f2c:	e000      	b.n	8011f30 <writeCan+0xc8>
	}
	return RC_ERROR;
 8011f2e:	2301      	movs	r3, #1
}
 8011f30:	4618      	mov	r0, r3
 8011f32:	3720      	adds	r7, #32
 8011f34:	46bd      	mov	sp, r7
 8011f36:	bd80      	pop	{r7, pc}
 8011f38:	08026f90 	.word	0x08026f90

08011f3c <readCan>:

unsigned char readCan(J1939_msg_t j1939_msg)
{
 8011f3c:	b580      	push	{r7, lr}
 8011f3e:	b08a      	sub	sp, #40	; 0x28
 8011f40:	af00      	add	r7, sp, #0
 8011f42:	6078      	str	r0, [r7, #4]
	rt_device_t device;
	device = rt_device_find("can1");
 8011f44:	4841      	ldr	r0, [pc, #260]	; (801204c <readCan+0x110>)
 8011f46:	f003 fe2b 	bl	8015ba0 <rt_device_find>
 8011f4a:	6238      	str	r0, [r7, #32]
	struct rt_can_msg tmpmsg;
	unsigned char i,size;
	unsigned char result;
	
	if(device != NULL)
 8011f4c:	6a3b      	ldr	r3, [r7, #32]
 8011f4e:	2b00      	cmp	r3, #0
 8011f50:	d077      	beq.n	8012042 <readCan+0x106>
	{
		size = rt_device_read(device,0,&tmpmsg,sizeof(struct rt_can_msg));
 8011f52:	f107 030c 	add.w	r3, r7, #12
 8011f56:	6a38      	ldr	r0, [r7, #32]
 8011f58:	2100      	movs	r1, #0
 8011f5a:	461a      	mov	r2, r3
 8011f5c:	2310      	movs	r3, #16
 8011f5e:	f003 ff0d 	bl	8015d7c <rt_device_read>
 8011f62:	4603      	mov	r3, r0
 8011f64:	77fb      	strb	r3, [r7, #31]
		if (size != 0)
 8011f66:	7ffb      	ldrb	r3, [r7, #31]
 8011f68:	2b00      	cmp	r3, #0
 8011f6a:	d066      	beq.n	801203a <readCan+0xfe>
		{
			j1939_msg->Priority = tmpmsg.id >> 26;
 8011f6c:	68fb      	ldr	r3, [r7, #12]
 8011f6e:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8011f72:	169b      	asrs	r3, r3, #26
 8011f74:	b2db      	uxtb	r3, r3
 8011f76:	f003 0307 	and.w	r3, r3, #7
 8011f7a:	b2d9      	uxtb	r1, r3
 8011f7c:	687a      	ldr	r2, [r7, #4]
 8011f7e:	7813      	ldrb	r3, [r2, #0]
 8011f80:	f361 1347 	bfi	r3, r1, #5, #3
 8011f84:	7013      	strb	r3, [r2, #0]
			j1939_msg->edp = tmpmsg.id >> 25;
 8011f86:	68fb      	ldr	r3, [r7, #12]
 8011f88:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8011f8c:	165b      	asrs	r3, r3, #25
 8011f8e:	b2db      	uxtb	r3, r3
 8011f90:	f003 0301 	and.w	r3, r3, #1
 8011f94:	b2d9      	uxtb	r1, r3
 8011f96:	687a      	ldr	r2, [r7, #4]
 8011f98:	7813      	ldrb	r3, [r2, #0]
 8011f9a:	f361 1304 	bfi	r3, r1, #4, #1
 8011f9e:	7013      	strb	r3, [r2, #0]
			j1939_msg->DataPage = tmpmsg.id >> 24;
 8011fa0:	68fb      	ldr	r3, [r7, #12]
 8011fa2:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8011fa6:	161b      	asrs	r3, r3, #24
 8011fa8:	b2db      	uxtb	r3, r3
 8011faa:	f003 0301 	and.w	r3, r3, #1
 8011fae:	b2d9      	uxtb	r1, r3
 8011fb0:	687a      	ldr	r2, [r7, #4]
 8011fb2:	7813      	ldrb	r3, [r2, #0]
 8011fb4:	f361 03c3 	bfi	r3, r1, #3, #1
 8011fb8:	7013      	strb	r3, [r2, #0]
			j1939_msg->PDUFormat = tmpmsg.id >> 16;
 8011fba:	68fb      	ldr	r3, [r7, #12]
 8011fbc:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8011fc0:	141b      	asrs	r3, r3, #16
 8011fc2:	b2da      	uxtb	r2, r3
 8011fc4:	687b      	ldr	r3, [r7, #4]
 8011fc6:	705a      	strb	r2, [r3, #1]
			j1939_msg->PDUSpecific = tmpmsg.id >> 8;
 8011fc8:	68fb      	ldr	r3, [r7, #12]
 8011fca:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8011fce:	121b      	asrs	r3, r3, #8
 8011fd0:	b2da      	uxtb	r2, r3
 8011fd2:	687b      	ldr	r3, [r7, #4]
 8011fd4:	709a      	strb	r2, [r3, #2]
			j1939_msg->SourceAddress = tmpmsg.id;
 8011fd6:	68fb      	ldr	r3, [r7, #12]
 8011fd8:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8011fdc:	b2da      	uxtb	r2, r3
 8011fde:	687b      	ldr	r3, [r7, #4]
 8011fe0:	70da      	strb	r2, [r3, #3]
			j1939_msg->DataLength = tmpmsg.len;
 8011fe2:	7c3b      	ldrb	r3, [r7, #16]
 8011fe4:	f003 030f 	and.w	r3, r3, #15
 8011fe8:	b2d9      	uxtb	r1, r3
 8011fea:	687a      	ldr	r2, [r7, #4]
 8011fec:	7913      	ldrb	r3, [r2, #4]
 8011fee:	f361 0303 	bfi	r3, r1, #0, #4
 8011ff2:	7113      	strb	r3, [r2, #4]
			for(i=0;i<j1939_msg->DataLength;i++)
 8011ff4:	2300      	movs	r3, #0
 8011ff6:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8011ffa:	e011      	b.n	8012020 <readCan+0xe4>
			{
				j1939_msg->Data[i] = tmpmsg.data[i];
 8011ffc:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8012000:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 8012004:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8012008:	440a      	add	r2, r1
 801200a:	f812 1c14 	ldrb.w	r1, [r2, #-20]
 801200e:	687a      	ldr	r2, [r7, #4]
 8012010:	4413      	add	r3, r2
 8012012:	460a      	mov	r2, r1
 8012014:	715a      	strb	r2, [r3, #5]
			j1939_msg->DataPage = tmpmsg.id >> 24;
			j1939_msg->PDUFormat = tmpmsg.id >> 16;
			j1939_msg->PDUSpecific = tmpmsg.id >> 8;
			j1939_msg->SourceAddress = tmpmsg.id;
			j1939_msg->DataLength = tmpmsg.len;
			for(i=0;i<j1939_msg->DataLength;i++)
 8012016:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801201a:	3301      	adds	r3, #1
 801201c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8012020:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8012024:	687a      	ldr	r2, [r7, #4]
 8012026:	7912      	ldrb	r2, [r2, #4]
 8012028:	f3c2 0203 	ubfx	r2, r2, #0, #4
 801202c:	b2d2      	uxtb	r2, r2
 801202e:	4293      	cmp	r3, r2
 8012030:	dbe4      	blt.n	8011ffc <readCan+0xc0>
			{
				j1939_msg->Data[i] = tmpmsg.data[i];
			}
			return result = RC_SUCCESS;
 8012032:	2300      	movs	r3, #0
 8012034:	77bb      	strb	r3, [r7, #30]
 8012036:	7fbb      	ldrb	r3, [r7, #30]
 8012038:	e004      	b.n	8012044 <readCan+0x108>
		}
		else
			return result = RC_QUEUEEMPTY;
 801203a:	2309      	movs	r3, #9
 801203c:	77bb      	strb	r3, [r7, #30]
 801203e:	7fbb      	ldrb	r3, [r7, #30]
 8012040:	e000      	b.n	8012044 <readCan+0x108>
	}
	return RC_ERROR;
 8012042:	2301      	movs	r3, #1
}
 8012044:	4618      	mov	r0, r3
 8012046:	3728      	adds	r7, #40	; 0x28
 8012048:	46bd      	mov	sp, r7
 801204a:	bd80      	pop	{r7, pc}
 801204c:	08026f90 	.word	0x08026f90

08012050 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 8012050:	b480      	push	{r7}
 8012052:	b083      	sub	sp, #12
 8012054:	af00      	add	r7, sp, #0
 8012056:	6078      	str	r0, [r7, #4]
 8012058:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 801205a:	687b      	ldr	r3, [r7, #4]
 801205c:	685b      	ldr	r3, [r3, #4]
 801205e:	683a      	ldr	r2, [r7, #0]
 8012060:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 8012062:	687b      	ldr	r3, [r7, #4]
 8012064:	685a      	ldr	r2, [r3, #4]
 8012066:	683b      	ldr	r3, [r7, #0]
 8012068:	605a      	str	r2, [r3, #4]

    l->prev = n;
 801206a:	687b      	ldr	r3, [r7, #4]
 801206c:	683a      	ldr	r2, [r7, #0]
 801206e:	605a      	str	r2, [r3, #4]
    n->next = l;
 8012070:	683b      	ldr	r3, [r7, #0]
 8012072:	687a      	ldr	r2, [r7, #4]
 8012074:	601a      	str	r2, [r3, #0]
}
 8012076:	370c      	adds	r7, #12
 8012078:	46bd      	mov	sp, r7
 801207a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801207e:	4770      	bx	lr

08012080 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 8012080:	b480      	push	{r7}
 8012082:	b083      	sub	sp, #12
 8012084:	af00      	add	r7, sp, #0
 8012086:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 8012088:	687b      	ldr	r3, [r7, #4]
 801208a:	681b      	ldr	r3, [r3, #0]
 801208c:	687a      	ldr	r2, [r7, #4]
 801208e:	6852      	ldr	r2, [r2, #4]
 8012090:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 8012092:	687b      	ldr	r3, [r7, #4]
 8012094:	685b      	ldr	r3, [r3, #4]
 8012096:	687a      	ldr	r2, [r7, #4]
 8012098:	6812      	ldr	r2, [r2, #0]
 801209a:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 801209c:	687b      	ldr	r3, [r7, #4]
 801209e:	687a      	ldr	r2, [r7, #4]
 80120a0:	605a      	str	r2, [r3, #4]
 80120a2:	687b      	ldr	r3, [r7, #4]
 80120a4:	685a      	ldr	r2, [r3, #4]
 80120a6:	687b      	ldr	r3, [r7, #4]
 80120a8:	601a      	str	r2, [r3, #0]
}
 80120aa:	370c      	adds	r7, #12
 80120ac:	46bd      	mov	sp, r7
 80120ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80120b2:	4770      	bx	lr

080120b4 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 80120b4:	b480      	push	{r7}
 80120b6:	b083      	sub	sp, #12
 80120b8:	af00      	add	r7, sp, #0
 80120ba:	6078      	str	r0, [r7, #4]
    return l->next == l;
 80120bc:	687b      	ldr	r3, [r7, #4]
 80120be:	681a      	ldr	r2, [r3, #0]
 80120c0:	687b      	ldr	r3, [r7, #4]
 80120c2:	429a      	cmp	r2, r3
 80120c4:	bf0c      	ite	eq
 80120c6:	2301      	moveq	r3, #1
 80120c8:	2300      	movne	r3, #0
 80120ca:	b2db      	uxtb	r3, r3
}
 80120cc:	4618      	mov	r0, r3
 80120ce:	370c      	adds	r7, #12
 80120d0:	46bd      	mov	sp, r7
 80120d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80120d6:	4770      	bx	lr

080120d8 <HAL_CAN_TxCpltCallback>:

struct rt_can_device canDevice1;
stm32_canTypeDef can1;

void HAL_CAN_TxCpltCallback(CAN_HandleTypeDef* hcan)
{
 80120d8:	b480      	push	{r7}
 80120da:	b083      	sub	sp, #12
 80120dc:	af00      	add	r7, sp, #0
 80120de:	6078      	str	r0, [r7, #4]
	//rt_kprintf("tx complete\r\n");
}
 80120e0:	370c      	adds	r7, #12
 80120e2:	46bd      	mov	sp, r7
 80120e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80120e8:	4770      	bx	lr
 80120ea:	bf00      	nop

080120ec <CAN1_TX_IRQHandler>:

void CAN1_TX_IRQHandler(void)
{
 80120ec:	b580      	push	{r7, lr}
 80120ee:	b090      	sub	sp, #64	; 0x40
 80120f0:	af00      	add	r7, sp, #0
	CAN_HandleTypeDef hcan;
	/* enter interrupt */
    rt_interrupt_enter();
 80120f2:	f004 fdd3 	bl	8016c9c <rt_interrupt_enter>

	hcan.Instance = CAN1;
 80120f6:	4b05      	ldr	r3, [pc, #20]	; (801210c <CAN1_TX_IRQHandler+0x20>)
 80120f8:	603b      	str	r3, [r7, #0]
	HAL_CAN_IRQHandler(&hcan);
 80120fa:	463b      	mov	r3, r7
 80120fc:	4618      	mov	r0, r3
 80120fe:	f7f6 f887 	bl	8008210 <HAL_CAN_IRQHandler>

    /* leave interrupt */
    rt_interrupt_leave();
 8012102:	f004 fde1 	bl	8016cc8 <rt_interrupt_leave>

}
 8012106:	3740      	adds	r7, #64	; 0x40
 8012108:	46bd      	mov	sp, r7
 801210a:	bd80      	pop	{r7, pc}
 801210c:	40006400 	.word	0x40006400

08012110 <HAL_CAN_RxCpltCallback>:

void HAL_CAN_RxCpltCallback(CAN_HandleTypeDef* hcan)
{
 8012110:	b480      	push	{r7}
 8012112:	b083      	sub	sp, #12
 8012114:	af00      	add	r7, sp, #0
 8012116:	6078      	str	r0, [r7, #4]
	{
		rt_kprintf("0x%x ", hcan->pRxMsg->Data[i]);
	}
	rt_kprintf("\r\n");
	#endif
}
 8012118:	370c      	adds	r7, #12
 801211a:	46bd      	mov	sp, r7
 801211c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012120:	4770      	bx	lr
 8012122:	bf00      	nop

08012124 <CAN1_RX0_IRQHandler>:

void CAN1_RX0_IRQHandler(void)
{
 8012124:	b580      	push	{r7, lr}
 8012126:	b090      	sub	sp, #64	; 0x40
 8012128:	af00      	add	r7, sp, #0
	
	CAN_HandleTypeDef hcan;
	/* enter interrupt */
	
    rt_interrupt_enter();
 801212a:	f004 fdb7 	bl	8016c9c <rt_interrupt_enter>
	hcan.Instance = CAN1;
 801212e:	4b05      	ldr	r3, [pc, #20]	; (8012144 <CAN1_RX0_IRQHandler+0x20>)
 8012130:	603b      	str	r3, [r7, #0]
	
	HAL_CAN_IRQHandler(&hcan);
 8012132:	463b      	mov	r3, r7
 8012134:	4618      	mov	r0, r3
 8012136:	f7f6 f86b 	bl	8008210 <HAL_CAN_IRQHandler>

    /* leave interrupt */
    rt_interrupt_leave();
 801213a:	f004 fdc5 	bl	8016cc8 <rt_interrupt_leave>

}
 801213e:	3740      	adds	r7, #64	; 0x40
 8012140:	46bd      	mov	sp, r7
 8012142:	bd80      	pop	{r7, pc}
 8012144:	40006400 	.word	0x40006400

08012148 <CAN1_RX1_IRQHandler>:

void CAN1_RX1_IRQHandler(void)
{
 8012148:	b580      	push	{r7, lr}
 801214a:	b090      	sub	sp, #64	; 0x40
 801214c:	af00      	add	r7, sp, #0
	
	CAN_HandleTypeDef hcan;
	/* enter interrupt */
	rt_interrupt_enter();
 801214e:	f004 fda5 	bl	8016c9c <rt_interrupt_enter>

	hcan.Instance = CAN1;
 8012152:	4b05      	ldr	r3, [pc, #20]	; (8012168 <CAN1_RX1_IRQHandler+0x20>)
 8012154:	603b      	str	r3, [r7, #0]
	HAL_CAN_IRQHandler(&hcan);
 8012156:	463b      	mov	r3, r7
 8012158:	4618      	mov	r0, r3
 801215a:	f7f6 f859 	bl	8008210 <HAL_CAN_IRQHandler>

	/* leave interrupt */
	rt_interrupt_leave();
 801215e:	f004 fdb3 	bl	8016cc8 <rt_interrupt_leave>

}
 8012162:	3740      	adds	r7, #64	; 0x40
 8012164:	46bd      	mov	sp, r7
 8012166:	bd80      	pop	{r7, pc}
 8012168:	40006400 	.word	0x40006400

0801216c <HAL_CAN_ErrorCallback>:

void HAL_CAN_ErrorCallback(CAN_HandleTypeDef *hcan)
{
 801216c:	b580      	push	{r7, lr}
 801216e:	b082      	sub	sp, #8
 8012170:	af00      	add	r7, sp, #0
 8012172:	6078      	str	r0, [r7, #4]
	
	if((hcan->ErrorCode & HAL_CAN_ERROR_EWG) == HAL_CAN_ERROR_EWG)
 8012174:	687b      	ldr	r3, [r7, #4]
 8012176:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8012178:	f003 0301 	and.w	r3, r3, #1
 801217c:	2b00      	cmp	r3, #0
 801217e:	d002      	beq.n	8012186 <HAL_CAN_ErrorCallback+0x1a>
		rt_kprintf("ewg error\r\n");
 8012180:	4826      	ldr	r0, [pc, #152]	; (801221c <HAL_CAN_ErrorCallback+0xb0>)
 8012182:	f005 fb9b 	bl	80178bc <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_EPV) == HAL_CAN_ERROR_EPV)
 8012186:	687b      	ldr	r3, [r7, #4]
 8012188:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801218a:	f003 0302 	and.w	r3, r3, #2
 801218e:	2b00      	cmp	r3, #0
 8012190:	d002      	beq.n	8012198 <HAL_CAN_ErrorCallback+0x2c>
		rt_kprintf("epv error\r\n");
 8012192:	4823      	ldr	r0, [pc, #140]	; (8012220 <HAL_CAN_ErrorCallback+0xb4>)
 8012194:	f005 fb92 	bl	80178bc <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_BOF) == HAL_CAN_ERROR_BOF)
 8012198:	687b      	ldr	r3, [r7, #4]
 801219a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801219c:	f003 0304 	and.w	r3, r3, #4
 80121a0:	2b00      	cmp	r3, #0
 80121a2:	d002      	beq.n	80121aa <HAL_CAN_ErrorCallback+0x3e>
		rt_kprintf("bof error\r\n");
 80121a4:	481f      	ldr	r0, [pc, #124]	; (8012224 <HAL_CAN_ErrorCallback+0xb8>)
 80121a6:	f005 fb89 	bl	80178bc <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_STF) == HAL_CAN_ERROR_STF)
 80121aa:	687b      	ldr	r3, [r7, #4]
 80121ac:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80121ae:	f003 0308 	and.w	r3, r3, #8
 80121b2:	2b00      	cmp	r3, #0
 80121b4:	d002      	beq.n	80121bc <HAL_CAN_ErrorCallback+0x50>
		rt_kprintf("stf error\r\n");
 80121b6:	481c      	ldr	r0, [pc, #112]	; (8012228 <HAL_CAN_ErrorCallback+0xbc>)
 80121b8:	f005 fb80 	bl	80178bc <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_FOR) == HAL_CAN_ERROR_FOR)
 80121bc:	687b      	ldr	r3, [r7, #4]
 80121be:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80121c0:	f003 0310 	and.w	r3, r3, #16
 80121c4:	2b00      	cmp	r3, #0
 80121c6:	d002      	beq.n	80121ce <HAL_CAN_ErrorCallback+0x62>
		rt_kprintf("for error\r\n");
 80121c8:	4818      	ldr	r0, [pc, #96]	; (801222c <HAL_CAN_ErrorCallback+0xc0>)
 80121ca:	f005 fb77 	bl	80178bc <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_ACK) == HAL_CAN_ERROR_ACK)
 80121ce:	687b      	ldr	r3, [r7, #4]
 80121d0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80121d2:	f003 0320 	and.w	r3, r3, #32
 80121d6:	2b00      	cmp	r3, #0
 80121d8:	d002      	beq.n	80121e0 <HAL_CAN_ErrorCallback+0x74>
		rt_kprintf("ack error\r\n");
 80121da:	4815      	ldr	r0, [pc, #84]	; (8012230 <HAL_CAN_ErrorCallback+0xc4>)
 80121dc:	f005 fb6e 	bl	80178bc <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_BR) == HAL_CAN_ERROR_BR)
 80121e0:	687b      	ldr	r3, [r7, #4]
 80121e2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80121e4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80121e8:	2b00      	cmp	r3, #0
 80121ea:	d002      	beq.n	80121f2 <HAL_CAN_ErrorCallback+0x86>
		rt_kprintf("br error\r\n");
 80121ec:	4811      	ldr	r0, [pc, #68]	; (8012234 <HAL_CAN_ErrorCallback+0xc8>)
 80121ee:	f005 fb65 	bl	80178bc <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_BD) == HAL_CAN_ERROR_BD)
 80121f2:	687b      	ldr	r3, [r7, #4]
 80121f4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80121f6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80121fa:	2b00      	cmp	r3, #0
 80121fc:	d002      	beq.n	8012204 <HAL_CAN_ErrorCallback+0x98>
		rt_kprintf("bd error\r\n");
 80121fe:	480e      	ldr	r0, [pc, #56]	; (8012238 <HAL_CAN_ErrorCallback+0xcc>)
 8012200:	f005 fb5c 	bl	80178bc <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_CRC) == HAL_CAN_ERROR_CRC)
 8012204:	687b      	ldr	r3, [r7, #4]
 8012206:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8012208:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801220c:	2b00      	cmp	r3, #0
 801220e:	d002      	beq.n	8012216 <HAL_CAN_ErrorCallback+0xaa>
		rt_kprintf("crc error\r\n");
 8012210:	480a      	ldr	r0, [pc, #40]	; (801223c <HAL_CAN_ErrorCallback+0xd0>)
 8012212:	f005 fb53 	bl	80178bc <rt_kprintf>
	
	//HAL_NVIC_DisableIRQ(CAN1_SCE_IRQn);
}
 8012216:	3708      	adds	r7, #8
 8012218:	46bd      	mov	sp, r7
 801221a:	bd80      	pop	{r7, pc}
 801221c:	08026f98 	.word	0x08026f98
 8012220:	08026fa4 	.word	0x08026fa4
 8012224:	08026fb0 	.word	0x08026fb0
 8012228:	08026fbc 	.word	0x08026fbc
 801222c:	08026fc8 	.word	0x08026fc8
 8012230:	08026fd4 	.word	0x08026fd4
 8012234:	08026fe0 	.word	0x08026fe0
 8012238:	08026fec 	.word	0x08026fec
 801223c:	08026ff8 	.word	0x08026ff8

08012240 <CAN1_SCE_IRQHandler>:

void CAN1_SCE_IRQHandler(void)
{
 8012240:	b580      	push	{r7, lr}
 8012242:	b090      	sub	sp, #64	; 0x40
 8012244:	af00      	add	r7, sp, #0
	CAN_HandleTypeDef hcan;

	/* enter interrupt */
	rt_interrupt_enter();
 8012246:	f004 fd29 	bl	8016c9c <rt_interrupt_enter>

	HAL_CAN_IRQHandler(&hcan);
 801224a:	463b      	mov	r3, r7
 801224c:	4618      	mov	r0, r3
 801224e:	f7f5 ffdf 	bl	8008210 <HAL_CAN_IRQHandler>

	/* leave interrupt */
	rt_interrupt_leave();
 8012252:	f004 fd39 	bl	8016cc8 <rt_interrupt_leave>

}
 8012256:	3740      	adds	r7, #64	; 0x40
 8012258:	46bd      	mov	sp, r7
 801225a:	bd80      	pop	{r7, pc}

0801225c <HAL_CAN_MspInit>:



void HAL_CAN_MspInit(CAN_HandleTypeDef* hcan)
{
 801225c:	b580      	push	{r7, lr}
 801225e:	b08a      	sub	sp, #40	; 0x28
 8012260:	af00      	add	r7, sp, #0
 8012262:	6078      	str	r0, [r7, #4]
    GPIO_InitTypeDef  GPIO_InitStruct;
	
	CAN1_CLK_ENABLE();
 8012264:	4a2b      	ldr	r2, [pc, #172]	; (8012314 <HAL_CAN_MspInit+0xb8>)
 8012266:	4b2b      	ldr	r3, [pc, #172]	; (8012314 <HAL_CAN_MspInit+0xb8>)
 8012268:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801226a:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 801226e:	6413      	str	r3, [r2, #64]	; 0x40
 8012270:	4b28      	ldr	r3, [pc, #160]	; (8012314 <HAL_CAN_MspInit+0xb8>)
 8012272:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8012274:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8012278:	613b      	str	r3, [r7, #16]
 801227a:	693b      	ldr	r3, [r7, #16]
	CAN1_GPIOB_CLK_ENABLE();
 801227c:	4a25      	ldr	r2, [pc, #148]	; (8012314 <HAL_CAN_MspInit+0xb8>)
 801227e:	4b25      	ldr	r3, [pc, #148]	; (8012314 <HAL_CAN_MspInit+0xb8>)
 8012280:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012282:	f043 0302 	orr.w	r3, r3, #2
 8012286:	6313      	str	r3, [r2, #48]	; 0x30
 8012288:	4b22      	ldr	r3, [pc, #136]	; (8012314 <HAL_CAN_MspInit+0xb8>)
 801228a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801228c:	f003 0302 	and.w	r3, r3, #2
 8012290:	60fb      	str	r3, [r7, #12]
 8012292:	68fb      	ldr	r3, [r7, #12]

	GPIO_InitStruct.Alternate = GPIO_AF9_CAN1;
 8012294:	2309      	movs	r3, #9
 8012296:	627b      	str	r3, [r7, #36]	; 0x24
	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8012298:	2302      	movs	r3, #2
 801229a:	61bb      	str	r3, [r7, #24]
	GPIO_InitStruct.Pin = CAN1_TX_PIN;
 801229c:	f44f 7300 	mov.w	r3, #512	; 0x200
 80122a0:	617b      	str	r3, [r7, #20]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 80122a2:	2300      	movs	r3, #0
 80122a4:	61fb      	str	r3, [r7, #28]
	GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 80122a6:	2303      	movs	r3, #3
 80122a8:	623b      	str	r3, [r7, #32]
	HAL_GPIO_Init(CAN1_TX_PORT, &GPIO_InitStruct);	
 80122aa:	f107 0314 	add.w	r3, r7, #20
 80122ae:	481a      	ldr	r0, [pc, #104]	; (8012318 <HAL_CAN_MspInit+0xbc>)
 80122b0:	4619      	mov	r1, r3
 80122b2:	f7fb f893 	bl	800d3dc <HAL_GPIO_Init>
	
	GPIO_InitStruct.Pin = CAN1_RX_PIN;
 80122b6:	f44f 7380 	mov.w	r3, #256	; 0x100
 80122ba:	617b      	str	r3, [r7, #20]
	GPIO_InitStruct.Pull = GPIO_PULLUP;
 80122bc:	2301      	movs	r3, #1
 80122be:	61fb      	str	r3, [r7, #28]
	HAL_GPIO_Init(CAN1_RX_PORT, &GPIO_InitStruct);	
 80122c0:	f107 0314 	add.w	r3, r7, #20
 80122c4:	4814      	ldr	r0, [pc, #80]	; (8012318 <HAL_CAN_MspInit+0xbc>)
 80122c6:	4619      	mov	r1, r3
 80122c8:	f7fb f888 	bl	800d3dc <HAL_GPIO_Init>
	
	HAL_NVIC_SetPriority(CAN1_TX_IRQn,CAN1_TX_IRQ_PREEMPT,CAN1_TX_TRQ_SUB);
 80122cc:	2013      	movs	r0, #19
 80122ce:	210f      	movs	r1, #15
 80122d0:	2200      	movs	r2, #0
 80122d2:	f7f6 fb9f 	bl	8008a14 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(CAN1_TX_IRQn);
 80122d6:	2013      	movs	r0, #19
 80122d8:	f7f6 fbb8 	bl	8008a4c <HAL_NVIC_EnableIRQ>
	
	HAL_NVIC_SetPriority(CAN1_RX0_IRQn,CAN1_RX0_IRQ_PREEMPT,CAN1_RX0_TRQ_SUB);
 80122dc:	2014      	movs	r0, #20
 80122de:	210f      	movs	r1, #15
 80122e0:	2200      	movs	r2, #0
 80122e2:	f7f6 fb97 	bl	8008a14 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(CAN1_RX0_IRQn);
 80122e6:	2014      	movs	r0, #20
 80122e8:	f7f6 fbb0 	bl	8008a4c <HAL_NVIC_EnableIRQ>

	HAL_NVIC_SetPriority(CAN1_RX1_IRQn,CAN1_RX1_IRQ_PREEMPT,CAN1_RX1_TRQ_SUB);
 80122ec:	2015      	movs	r0, #21
 80122ee:	210f      	movs	r1, #15
 80122f0:	2200      	movs	r2, #0
 80122f2:	f7f6 fb8f 	bl	8008a14 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(CAN1_RX1_IRQn);
 80122f6:	2015      	movs	r0, #21
 80122f8:	f7f6 fba8 	bl	8008a4c <HAL_NVIC_EnableIRQ>

	HAL_NVIC_SetPriority(CAN1_SCE_IRQn,CAN1_SCE_IRQ_PREEMPT,CAN1_SCE_IRQ_SUB);
 80122fc:	2016      	movs	r0, #22
 80122fe:	210f      	movs	r1, #15
 8012300:	2200      	movs	r2, #0
 8012302:	f7f6 fb87 	bl	8008a14 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(CAN1_SCE_IRQn);
 8012306:	2016      	movs	r0, #22
 8012308:	f7f6 fba0 	bl	8008a4c <HAL_NVIC_EnableIRQ>
}
 801230c:	3728      	adds	r7, #40	; 0x28
 801230e:	46bd      	mov	sp, r7
 8012310:	bd80      	pop	{r7, pc}
 8012312:	bf00      	nop
 8012314:	40023800 	.word	0x40023800
 8012318:	40020400 	.word	0x40020400

0801231c <stm32_CANcontrol>:




rt_err_t stm32_CANcontrol(struct rt_can_device *can, int cmd, void *arg)
{
 801231c:	b480      	push	{r7}
 801231e:	b087      	sub	sp, #28
 8012320:	af00      	add	r7, sp, #0
 8012322:	60f8      	str	r0, [r7, #12]
 8012324:	60b9      	str	r1, [r7, #8]
 8012326:	607a      	str	r2, [r7, #4]
	stm32_canTypeDef *stcan;
	stcan = (stm32_canTypeDef *)can->parent.user_data;
 8012328:	68fb      	ldr	r3, [r7, #12]
 801232a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801232c:	617b      	str	r3, [r7, #20]
	rt_err_t result = RT_EOK;
 801232e:	2300      	movs	r3, #0
 8012330:	613b      	str	r3, [r7, #16]
	switch(cmd)
 8012332:	68bb      	ldr	r3, [r7, #8]
 8012334:	2b10      	cmp	r3, #16
 8012336:	d00b      	beq.n	8012350 <stm32_CANcontrol+0x34>
 8012338:	2b11      	cmp	r3, #17
 801233a:	d000      	beq.n	801233e <stm32_CANcontrol+0x22>
			break;
		case (RT_DEVICE_CTRL_SET_INT):
			__HAL_CAN_ENABLE_IT(&(stcan->hcan), CAN_IT_ERR);
			break;
		default:
			break;
 801233c:	e011      	b.n	8012362 <stm32_CANcontrol+0x46>
	stcan = (stm32_canTypeDef *)can->parent.user_data;
	rt_err_t result = RT_EOK;
	switch(cmd)
	{
		case (RT_DEVICE_CTRL_CLR_INT):
			__HAL_CAN_DISABLE_IT(&(stcan->hcan), CAN_IT_ERR);
 801233e:	697b      	ldr	r3, [r7, #20]
 8012340:	681b      	ldr	r3, [r3, #0]
 8012342:	697a      	ldr	r2, [r7, #20]
 8012344:	6812      	ldr	r2, [r2, #0]
 8012346:	6952      	ldr	r2, [r2, #20]
 8012348:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 801234c:	615a      	str	r2, [r3, #20]
			break;
 801234e:	e008      	b.n	8012362 <stm32_CANcontrol+0x46>
		case (RT_DEVICE_CTRL_SET_INT):
			__HAL_CAN_ENABLE_IT(&(stcan->hcan), CAN_IT_ERR);
 8012350:	697b      	ldr	r3, [r7, #20]
 8012352:	681b      	ldr	r3, [r3, #0]
 8012354:	697a      	ldr	r2, [r7, #20]
 8012356:	6812      	ldr	r2, [r2, #0]
 8012358:	6952      	ldr	r2, [r2, #20]
 801235a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 801235e:	615a      	str	r2, [r3, #20]
			break;
 8012360:	bf00      	nop
		default:
			break;
	}	
	return result;
 8012362:	693b      	ldr	r3, [r7, #16]
}
 8012364:	4618      	mov	r0, r3
 8012366:	371c      	adds	r7, #28
 8012368:	46bd      	mov	sp, r7
 801236a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801236e:	4770      	bx	lr

08012370 <stm32_CANsendmsg>:

int stm32_CANsendmsg(struct rt_can_device *can, const void *buf, rt_uint32_t boxno)
{
 8012370:	b580      	push	{r7, lr}
 8012372:	b08a      	sub	sp, #40	; 0x28
 8012374:	af00      	add	r7, sp, #0
 8012376:	60f8      	str	r0, [r7, #12]
 8012378:	60b9      	str	r1, [r7, #8]
 801237a:	607a      	str	r2, [r7, #4]
	stm32_canTypeDef *stcan;
	struct rt_can_msg *tmpmsg = (struct rt_can_msg *)buf;
 801237c:	68bb      	ldr	r3, [r7, #8]
 801237e:	623b      	str	r3, [r7, #32]
	stcan = (stm32_canTypeDef *)can->parent.user_data;
 8012380:	68fb      	ldr	r3, [r7, #12]
 8012382:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8012384:	61fb      	str	r3, [r7, #28]
	rt_err_t result = RT_EOK;
 8012386:	2300      	movs	r3, #0
 8012388:	61bb      	str	r3, [r7, #24]
	unsigned char i;
	unsigned char ecode;
	if((stcan->hcan.pTxMsg != NULL))
 801238a:	69fb      	ldr	r3, [r7, #28]
 801238c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801238e:	2b00      	cmp	r3, #0
 8012390:	d053      	beq.n	801243a <stm32_CANsendmsg+0xca>
	{
		//rt_kprintf(" TX malloc success\r\n");
		stcan->hcan.pTxMsg->ExtId =  tmpmsg->id;
 8012392:	69fb      	ldr	r3, [r7, #28]
 8012394:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012396:	6a3a      	ldr	r2, [r7, #32]
 8012398:	6812      	ldr	r2, [r2, #0]
 801239a:	f3c2 021c 	ubfx	r2, r2, #0, #29
 801239e:	605a      	str	r2, [r3, #4]
		if(tmpmsg->ide)
 80123a0:	6a3b      	ldr	r3, [r7, #32]
 80123a2:	78db      	ldrb	r3, [r3, #3]
 80123a4:	f003 0320 	and.w	r3, r3, #32
 80123a8:	b2db      	uxtb	r3, r3
 80123aa:	2b00      	cmp	r3, #0
 80123ac:	d004      	beq.n	80123b8 <stm32_CANsendmsg+0x48>
			stcan->hcan.pTxMsg->IDE = CAN_ID_EXT;
 80123ae:	69fb      	ldr	r3, [r7, #28]
 80123b0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80123b2:	2204      	movs	r2, #4
 80123b4:	609a      	str	r2, [r3, #8]
 80123b6:	e003      	b.n	80123c0 <stm32_CANsendmsg+0x50>
		else
			stcan->hcan.pTxMsg->IDE = CAN_ID_STD;
 80123b8:	69fb      	ldr	r3, [r7, #28]
 80123ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80123bc:	2200      	movs	r2, #0
 80123be:	609a      	str	r2, [r3, #8]
		if(tmpmsg->rtr)
 80123c0:	6a3b      	ldr	r3, [r7, #32]
 80123c2:	78db      	ldrb	r3, [r3, #3]
 80123c4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80123c8:	b2db      	uxtb	r3, r3
 80123ca:	2b00      	cmp	r3, #0
 80123cc:	d004      	beq.n	80123d8 <stm32_CANsendmsg+0x68>
			stcan->hcan.pTxMsg->RTR = CAN_RTR_REMOTE;
 80123ce:	69fb      	ldr	r3, [r7, #28]
 80123d0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80123d2:	2202      	movs	r2, #2
 80123d4:	60da      	str	r2, [r3, #12]
 80123d6:	e003      	b.n	80123e0 <stm32_CANsendmsg+0x70>
		else 
			stcan->hcan.pTxMsg->RTR = CAN_RTR_DATA;
 80123d8:	69fb      	ldr	r3, [r7, #28]
 80123da:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80123dc:	2200      	movs	r2, #0
 80123de:	60da      	str	r2, [r3, #12]
		stcan->hcan.pTxMsg->DLC = tmpmsg->len;
 80123e0:	69fb      	ldr	r3, [r7, #28]
 80123e2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80123e4:	6a3a      	ldr	r2, [r7, #32]
 80123e6:	7912      	ldrb	r2, [r2, #4]
 80123e8:	611a      	str	r2, [r3, #16]
		for(i=0;i<8;i++)
 80123ea:	2300      	movs	r3, #0
 80123ec:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 80123f0:	e010      	b.n	8012414 <stm32_CANsendmsg+0xa4>
		{
			stcan->hcan.pTxMsg->Data[i] = tmpmsg->data[i];
 80123f2:	69fb      	ldr	r3, [r7, #28]
 80123f4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80123f6:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80123fa:	f897 1027 	ldrb.w	r1, [r7, #39]	; 0x27
 80123fe:	6a38      	ldr	r0, [r7, #32]
 8012400:	4401      	add	r1, r0
 8012402:	7a09      	ldrb	r1, [r1, #8]
 8012404:	4413      	add	r3, r2
 8012406:	460a      	mov	r2, r1
 8012408:	751a      	strb	r2, [r3, #20]
		if(tmpmsg->rtr)
			stcan->hcan.pTxMsg->RTR = CAN_RTR_REMOTE;
		else 
			stcan->hcan.pTxMsg->RTR = CAN_RTR_DATA;
		stcan->hcan.pTxMsg->DLC = tmpmsg->len;
		for(i=0;i<8;i++)
 801240a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801240e:	3301      	adds	r3, #1
 8012410:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8012414:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8012418:	2b07      	cmp	r3, #7
 801241a:	d9ea      	bls.n	80123f2 <stm32_CANsendmsg+0x82>
		{
			stcan->hcan.pTxMsg->Data[i] = tmpmsg->data[i];
		}
		if ((ecode = HAL_CAN_Transmit(&(stcan->hcan),100)) == HAL_OK)
 801241c:	69fb      	ldr	r3, [r7, #28]
 801241e:	4618      	mov	r0, r3
 8012420:	2164      	movs	r1, #100	; 0x64
 8012422:	f7f5 fc45 	bl	8007cb0 <HAL_CAN_Transmit>
 8012426:	4603      	mov	r3, r0
 8012428:	75fb      	strb	r3, [r7, #23]
 801242a:	7dfb      	ldrb	r3, [r7, #23]
 801242c:	2b00      	cmp	r3, #0
 801242e:	d004      	beq.n	801243a <stm32_CANsendmsg+0xca>
		{
			//rt_kprintf("CAN tx success %x\r\n", stcan->hcan.Instance->ESR);
		}
		else
		{
			rt_kprintf("CAN tx fail! %x\r\n", ecode);
 8012430:	7dfb      	ldrb	r3, [r7, #23]
 8012432:	4804      	ldr	r0, [pc, #16]	; (8012444 <stm32_CANsendmsg+0xd4>)
 8012434:	4619      	mov	r1, r3
 8012436:	f005 fa41 	bl	80178bc <rt_kprintf>
		}
		//rt_free(hcan.pTxMsg);
	}
	return result;
 801243a:	69bb      	ldr	r3, [r7, #24]
}
 801243c:	4618      	mov	r0, r3
 801243e:	3728      	adds	r7, #40	; 0x28
 8012440:	46bd      	mov	sp, r7
 8012442:	bd80      	pop	{r7, pc}
 8012444:	08027004 	.word	0x08027004

08012448 <stm32_CANrecvmsg>:
int stm32_CANrecvmsg(struct rt_can_device *can, void *buf, rt_uint32_t boxno)
{
 8012448:	b580      	push	{r7, lr}
 801244a:	b08e      	sub	sp, #56	; 0x38
 801244c:	af00      	add	r7, sp, #0
 801244e:	60f8      	str	r0, [r7, #12]
 8012450:	60b9      	str	r1, [r7, #8]
 8012452:	607a      	str	r2, [r7, #4]
	stm32_canTypeDef *stcan;
	stcan = (stm32_canTypeDef *)can->parent.user_data;
 8012454:	68fb      	ldr	r3, [r7, #12]
 8012456:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8012458:	633b      	str	r3, [r7, #48]	; 0x30
	rt_err_t result = RT_EOK;
 801245a:	2300      	movs	r3, #0
 801245c:	62fb      	str	r3, [r7, #44]	; 0x2c

	while((uint8_t)(stcan->hcan.Instance->RF0R&(uint32_t)0x03))
 801245e:	e0cf      	b.n	8012600 <stm32_CANrecvmsg+0x1b8>
	{
		if (HAL_CAN_Receive(&(stcan->hcan),CAN_FIFO0,0) == HAL_OK)
 8012460:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012462:	4618      	mov	r0, r3
 8012464:	2100      	movs	r1, #0
 8012466:	2200      	movs	r2, #0
 8012468:	f7f5 fd94 	bl	8007f94 <HAL_CAN_Receive>
 801246c:	4603      	mov	r3, r0
 801246e:	2b00      	cmp	r3, #0
 8012470:	f040 80c6 	bne.w	8012600 <stm32_CANrecvmsg+0x1b8>
		{
			rt_kprintf("receive can\r\n");
 8012474:	4869      	ldr	r0, [pc, #420]	; (801261c <stm32_CANrecvmsg+0x1d4>)
 8012476:	f005 fa21 	bl	80178bc <rt_kprintf>
			struct rt_can_msg tmpmsg;
			struct rt_can_rx_fifo *rx_fifo;
			struct rt_can_msg_list *listmsg = RT_NULL;
 801247a:	2300      	movs	r3, #0
 801247c:	637b      	str	r3, [r7, #52]	; 0x34
					rt_kprintf("0x%x ", stcan->hcan.pRxMsg->Data[i]);
				}
				rt_kprintf("\r\n");
			}
			#endif
			rx_fifo = (struct rt_can_rx_fifo *)can->can_rx;
 801247e:	68fb      	ldr	r3, [r7, #12]
 8012480:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8012484:	62bb      	str	r3, [r7, #40]	; 0x28
			RT_ASSERT(rx_fifo != RT_NULL);
 8012486:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012488:	2b00      	cmp	r3, #0
 801248a:	d104      	bne.n	8012496 <stm32_CANrecvmsg+0x4e>
 801248c:	4864      	ldr	r0, [pc, #400]	; (8012620 <stm32_CANrecvmsg+0x1d8>)
 801248e:	4965      	ldr	r1, [pc, #404]	; (8012624 <stm32_CANrecvmsg+0x1dc>)
 8012490:	22f4      	movs	r2, #244	; 0xf4
 8012492:	f005 fa8d 	bl	80179b0 <rt_assert_handler>
	
			//no = event >> 8;
			//ch = can->ops->recvmsg(can, &tmpmsg, no);
			//if (ch == -1) break;
	
			tmpmsg.id = stcan->hcan.pRxMsg->ExtId;
 8012496:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012498:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801249a:	685b      	ldr	r3, [r3, #4]
 801249c:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
 80124a0:	693b      	ldr	r3, [r7, #16]
 80124a2:	f362 031c 	bfi	r3, r2, #0, #29
 80124a6:	613b      	str	r3, [r7, #16]
			tmpmsg.ide = stcan->hcan.pRxMsg->IDE;
 80124a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80124aa:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80124ac:	689b      	ldr	r3, [r3, #8]
 80124ae:	b2db      	uxtb	r3, r3
 80124b0:	f003 0301 	and.w	r3, r3, #1
 80124b4:	b2da      	uxtb	r2, r3
 80124b6:	7cfb      	ldrb	r3, [r7, #19]
 80124b8:	f362 1345 	bfi	r3, r2, #5, #1
 80124bc:	74fb      	strb	r3, [r7, #19]
			tmpmsg.rtr = stcan->hcan.pRxMsg->RTR;
 80124be:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80124c0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80124c2:	68db      	ldr	r3, [r3, #12]
 80124c4:	b2db      	uxtb	r3, r3
 80124c6:	f003 0301 	and.w	r3, r3, #1
 80124ca:	b2da      	uxtb	r2, r3
 80124cc:	7cfb      	ldrb	r3, [r7, #19]
 80124ce:	f362 1386 	bfi	r3, r2, #6, #1
 80124d2:	74fb      	strb	r3, [r7, #19]
			tmpmsg.len = stcan->hcan.pRxMsg->DLC;
 80124d4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80124d6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80124d8:	691b      	ldr	r3, [r3, #16]
 80124da:	b2db      	uxtb	r3, r3
 80124dc:	753b      	strb	r3, [r7, #20]
			tmpmsg.data[0] = stcan->hcan.pRxMsg->Data[0];
 80124de:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80124e0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80124e2:	7d1b      	ldrb	r3, [r3, #20]
 80124e4:	763b      	strb	r3, [r7, #24]
			tmpmsg.data[1] = stcan->hcan.pRxMsg->Data[1];
 80124e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80124e8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80124ea:	7d5b      	ldrb	r3, [r3, #21]
 80124ec:	767b      	strb	r3, [r7, #25]
			tmpmsg.data[2] = stcan->hcan.pRxMsg->Data[2];
 80124ee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80124f0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80124f2:	7d9b      	ldrb	r3, [r3, #22]
 80124f4:	76bb      	strb	r3, [r7, #26]
			tmpmsg.data[3] = stcan->hcan.pRxMsg->Data[3];
 80124f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80124f8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80124fa:	7ddb      	ldrb	r3, [r3, #23]
 80124fc:	76fb      	strb	r3, [r7, #27]
			tmpmsg.data[4] = stcan->hcan.pRxMsg->Data[4];
 80124fe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012500:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8012502:	7e1b      	ldrb	r3, [r3, #24]
 8012504:	773b      	strb	r3, [r7, #28]
			tmpmsg.data[5] = stcan->hcan.pRxMsg->Data[5];
 8012506:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012508:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801250a:	7e5b      	ldrb	r3, [r3, #25]
 801250c:	777b      	strb	r3, [r7, #29]
			tmpmsg.data[6] = stcan->hcan.pRxMsg->Data[6];
 801250e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012510:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8012512:	7e9b      	ldrb	r3, [r3, #26]
 8012514:	77bb      	strb	r3, [r7, #30]
			tmpmsg.data[7] = stcan->hcan.pRxMsg->Data[7];
 8012516:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012518:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801251a:	7edb      	ldrb	r3, [r3, #27]
 801251c:	77fb      	strb	r3, [r7, #31]

			/* disable interrupt */
			level = rt_hw_interrupt_disable();
 801251e:	f7ed fe53 	bl	80001c8 <rt_hw_interrupt_disable>
 8012522:	6278      	str	r0, [r7, #36]	; 0x24
			can->status.rcvpkg++;
 8012524:	68fb      	ldr	r3, [r7, #12]
 8012526:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8012528:	1c5a      	adds	r2, r3, #1
 801252a:	68fb      	ldr	r3, [r7, #12]
 801252c:	665a      	str	r2, [r3, #100]	; 0x64
			can->status.rcvchange = 1;
 801252e:	68fb      	ldr	r3, [r7, #12]
 8012530:	2201      	movs	r2, #1
 8012532:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
			if (!rt_list_isempty(&rx_fifo->freelist))
 8012536:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012538:	3308      	adds	r3, #8
 801253a:	4618      	mov	r0, r3
 801253c:	f7ff fdba 	bl	80120b4 <rt_list_isempty>
 8012540:	4603      	mov	r3, r0
 8012542:	2b00      	cmp	r3, #0
 8012544:	d116      	bne.n	8012574 <stm32_CANrecvmsg+0x12c>
			{
				listmsg = rt_list_entry(rx_fifo->freelist.next, struct rt_can_msg_list, list);
 8012546:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012548:	689b      	ldr	r3, [r3, #8]
 801254a:	637b      	str	r3, [r7, #52]	; 0x34
				rt_list_remove(&listmsg->list);
 801254c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801254e:	4618      	mov	r0, r3
 8012550:	f7ff fd96 	bl	8012080 <rt_list_remove>
				RT_ASSERT(rx_fifo->freenumbers > 0);
 8012554:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012556:	685b      	ldr	r3, [r3, #4]
 8012558:	2b00      	cmp	r3, #0
 801255a:	d105      	bne.n	8012568 <stm32_CANrecvmsg+0x120>
 801255c:	4832      	ldr	r0, [pc, #200]	; (8012628 <stm32_CANrecvmsg+0x1e0>)
 801255e:	4931      	ldr	r1, [pc, #196]	; (8012624 <stm32_CANrecvmsg+0x1dc>)
 8012560:	f240 1211 	movw	r2, #273	; 0x111
 8012564:	f005 fa24 	bl	80179b0 <rt_assert_handler>
				rx_fifo->freenumbers--;
 8012568:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801256a:	685b      	ldr	r3, [r3, #4]
 801256c:	1e5a      	subs	r2, r3, #1
 801256e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012570:	605a      	str	r2, [r3, #4]
 8012572:	e013      	b.n	801259c <stm32_CANrecvmsg+0x154>
			}
			else if (!rt_list_isempty(&rx_fifo->uselist))
 8012574:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012576:	3310      	adds	r3, #16
 8012578:	4618      	mov	r0, r3
 801257a:	f7ff fd9b 	bl	80120b4 <rt_list_isempty>
 801257e:	4603      	mov	r3, r0
 8012580:	2b00      	cmp	r3, #0
 8012582:	d10b      	bne.n	801259c <stm32_CANrecvmsg+0x154>
			{
				listmsg = rt_list_entry(rx_fifo->uselist.next, struct rt_can_msg_list, list);
 8012584:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012586:	691b      	ldr	r3, [r3, #16]
 8012588:	637b      	str	r3, [r7, #52]	; 0x34
				can->status.dropedrcvpkg++;
 801258a:	68fb      	ldr	r3, [r7, #12]
 801258c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801258e:	1c5a      	adds	r2, r3, #1
 8012590:	68fb      	ldr	r3, [r7, #12]
 8012592:	669a      	str	r2, [r3, #104]	; 0x68
				rt_list_remove(&listmsg->list);
 8012594:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012596:	4618      	mov	r0, r3
 8012598:	f7ff fd72 	bl	8012080 <rt_list_remove>
			}
			/* enable interrupt */
			rt_hw_interrupt_enable(level);
 801259c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801259e:	f7ed fe17 	bl	80001d0 <rt_hw_interrupt_enable>
	
			if (listmsg != RT_NULL)
 80125a2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80125a4:	2b00      	cmp	r3, #0
 80125a6:	d017      	beq.n	80125d8 <stm32_CANrecvmsg+0x190>
			{
				rt_memcpy(&listmsg->data, &tmpmsg, sizeof(struct rt_can_msg));
 80125a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80125aa:	f103 0208 	add.w	r2, r3, #8
 80125ae:	f107 0310 	add.w	r3, r7, #16
 80125b2:	4610      	mov	r0, r2
 80125b4:	4619      	mov	r1, r3
 80125b6:	2210      	movs	r2, #16
 80125b8:	f004 fc24 	bl	8016e04 <rt_memcpy>
				level = rt_hw_interrupt_disable();
 80125bc:	f7ed fe04 	bl	80001c8 <rt_hw_interrupt_disable>
 80125c0:	6278      	str	r0, [r7, #36]	; 0x24
				rt_list_insert_before(&rx_fifo->uselist, &listmsg->list);
 80125c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80125c4:	f103 0210 	add.w	r2, r3, #16
 80125c8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80125ca:	4610      	mov	r0, r2
 80125cc:	4619      	mov	r1, r3
 80125ce:	f7ff fd3f 	bl	8012050 <rt_list_insert_before>
				rt_hw_interrupt_enable(level);
 80125d2:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80125d4:	f7ed fdfc 	bl	80001d0 <rt_hw_interrupt_enable>
			}
			
			if (can->parent.rx_indicate != RT_NULL)
 80125d8:	68fb      	ldr	r3, [r7, #12]
 80125da:	69db      	ldr	r3, [r3, #28]
 80125dc:	2b00      	cmp	r3, #0
 80125de:	d00f      	beq.n	8012600 <stm32_CANrecvmsg+0x1b8>
            {
                rt_size_t rx_length;

                level = rt_hw_interrupt_disable();
 80125e0:	f7ed fdf2 	bl	80001c8 <rt_hw_interrupt_disable>
 80125e4:	6278      	str	r0, [r7, #36]	; 0x24
                /* get rx length */
                rx_length = rx_fifo->freenumbers * sizeof(struct rt_can_msg);
 80125e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80125e8:	685b      	ldr	r3, [r3, #4]
 80125ea:	011b      	lsls	r3, r3, #4
 80125ec:	623b      	str	r3, [r7, #32]
                rt_hw_interrupt_enable(level);
 80125ee:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80125f0:	f7ed fdee 	bl	80001d0 <rt_hw_interrupt_enable>

                can->parent.rx_indicate(&can->parent, rx_length);
 80125f4:	68fb      	ldr	r3, [r7, #12]
 80125f6:	69db      	ldr	r3, [r3, #28]
 80125f8:	68fa      	ldr	r2, [r7, #12]
 80125fa:	4610      	mov	r0, r2
 80125fc:	6a39      	ldr	r1, [r7, #32]
 80125fe:	4798      	blx	r3
{
	stm32_canTypeDef *stcan;
	stcan = (stm32_canTypeDef *)can->parent.user_data;
	rt_err_t result = RT_EOK;

	while((uint8_t)(stcan->hcan.Instance->RF0R&(uint32_t)0x03))
 8012600:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012602:	681b      	ldr	r3, [r3, #0]
 8012604:	68db      	ldr	r3, [r3, #12]
 8012606:	b2db      	uxtb	r3, r3
 8012608:	f003 0303 	and.w	r3, r3, #3
 801260c:	2b00      	cmp	r3, #0
 801260e:	f47f af27 	bne.w	8012460 <stm32_CANrecvmsg+0x18>
                can->parent.rx_indicate(&can->parent, rx_length);
            }

		}
	}
	return result;
 8012612:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 8012614:	4618      	mov	r0, r3
 8012616:	3738      	adds	r7, #56	; 0x38
 8012618:	46bd      	mov	sp, r7
 801261a:	bd80      	pop	{r7, pc}
 801261c:	08027018 	.word	0x08027018
 8012620:	08027028 	.word	0x08027028
 8012624:	08028cd0 	.word	0x08028cd0
 8012628:	0802703c 	.word	0x0802703c

0801262c <timerCanrxfunc>:

static void timerCanrxfunc(void* parameter)
{
 801262c:	b580      	push	{r7, lr}
 801262e:	b082      	sub	sp, #8
 8012630:	af00      	add	r7, sp, #0
 8012632:	6078      	str	r0, [r7, #4]
	stm32_CANrecvmsg(&canDevice1,NULL,0);
 8012634:	4803      	ldr	r0, [pc, #12]	; (8012644 <timerCanrxfunc+0x18>)
 8012636:	2100      	movs	r1, #0
 8012638:	2200      	movs	r2, #0
 801263a:	f7ff ff05 	bl	8012448 <stm32_CANrecvmsg>
}
 801263e:	3708      	adds	r7, #8
 8012640:	46bd      	mov	sp, r7
 8012642:	bd80      	pop	{r7, pc}
 8012644:	20012788 	.word	0x20012788

08012648 <stm32_CANconfigure>:



rt_err_t stm32_CANconfigure(struct rt_can_device *can, struct can_configure *cfg)
{
 8012648:	b580      	push	{r7, lr}
 801264a:	b090      	sub	sp, #64	; 0x40
 801264c:	af02      	add	r7, sp, #8
 801264e:	6078      	str	r0, [r7, #4]
 8012650:	6039      	str	r1, [r7, #0]
	stm32_canTypeDef *stcan;
	stcan = (stm32_canTypeDef *)can->parent.user_data;
 8012652:	687b      	ldr	r3, [r7, #4]
 8012654:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8012656:	637b      	str	r3, [r7, #52]	; 0x34
	rt_err_t result = RT_EOK;
 8012658:	2300      	movs	r3, #0
 801265a:	633b      	str	r3, [r7, #48]	; 0x30
	static rt_timer_t timerCanrx;
	
	switch (cfg->baud_rate)
 801265c:	683b      	ldr	r3, [r7, #0]
 801265e:	681b      	ldr	r3, [r3, #0]
 8012660:	2bfa      	cmp	r3, #250	; 0xfa
 8012662:	f040 8086 	bne.w	8012772 <stm32_CANconfigure+0x12a>
	{
		case (250) :
			if(HAL_CAN_DeInit(&(stcan->hcan))!= HAL_OK)
 8012666:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012668:	4618      	mov	r0, r3
 801266a:	f7f5 faf9 	bl	8007c60 <HAL_CAN_DeInit>
 801266e:	4603      	mov	r3, r0
 8012670:	2b00      	cmp	r3, #0
 8012672:	d004      	beq.n	801267e <stm32_CANconfigure+0x36>
			{
				rt_kprintf("error deinit can\r\n");
 8012674:	4841      	ldr	r0, [pc, #260]	; (801277c <stm32_CANconfigure+0x134>)
 8012676:	f005 f921 	bl	80178bc <rt_kprintf>
				return RT_ERROR;
 801267a:	2301      	movs	r3, #1
 801267c:	e07a      	b.n	8012774 <stm32_CANconfigure+0x12c>
			}
			stcan->hcan.Init.ABOM = DISABLE;
 801267e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012680:	2200      	movs	r2, #0
 8012682:	61da      	str	r2, [r3, #28]
			stcan->hcan.Init.AWUM = DISABLE;
 8012684:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012686:	2200      	movs	r2, #0
 8012688:	621a      	str	r2, [r3, #32]
			#if 1
			stcan->hcan.Init.BS1 = CAN_BS1_8TQ;
 801268a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801268c:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
 8012690:	611a      	str	r2, [r3, #16]
			stcan->hcan.Init.BS2 = CAN_BS2_3TQ;
 8012692:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012694:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 8012698:	615a      	str	r2, [r3, #20]
			stcan->hcan.Init.Prescaler = 16;
 801269a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801269c:	2210      	movs	r2, #16
 801269e:	605a      	str	r2, [r3, #4]
			#endif
			stcan->hcan.Init.Mode = CAN_MODE_NORMAL;
 80126a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80126a2:	2200      	movs	r2, #0
 80126a4:	609a      	str	r2, [r3, #8]
			stcan->hcan.Init.NART = DISABLE;
 80126a6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80126a8:	2200      	movs	r2, #0
 80126aa:	625a      	str	r2, [r3, #36]	; 0x24
			stcan->hcan.Init.RFLM = DISABLE;
 80126ac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80126ae:	2200      	movs	r2, #0
 80126b0:	629a      	str	r2, [r3, #40]	; 0x28
			stcan->hcan.Init.SJW = CAN_SJW_2TQ;
 80126b2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80126b4:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 80126b8:	60da      	str	r2, [r3, #12]
			stcan->hcan.Init.TTCM = DISABLE;
 80126ba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80126bc:	2200      	movs	r2, #0
 80126be:	619a      	str	r2, [r3, #24]
			stcan->hcan.Init.TXFP = DISABLE;
 80126c0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80126c2:	2200      	movs	r2, #0
 80126c4:	62da      	str	r2, [r3, #44]	; 0x2c
			
			if(HAL_CAN_Init(&(stcan->hcan))!= HAL_OK)
 80126c6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80126c8:	4618      	mov	r0, r3
 80126ca:	f7f5 f8d3 	bl	8007874 <HAL_CAN_Init>
 80126ce:	4603      	mov	r3, r0
 80126d0:	2b00      	cmp	r3, #0
 80126d2:	d004      	beq.n	80126de <stm32_CANconfigure+0x96>
			{
				rt_kprintf("error init can\r\n");
 80126d4:	482a      	ldr	r0, [pc, #168]	; (8012780 <stm32_CANconfigure+0x138>)
 80126d6:	f005 f8f1 	bl	80178bc <rt_kprintf>
				return RT_ERROR;
 80126da:	2301      	movs	r3, #1
 80126dc:	e04a      	b.n	8012774 <stm32_CANconfigure+0x12c>
			}	
			
			CAN_FilterConfTypeDef sFilterConfig;
			sFilterConfig.BankNumber = 0;
 80126de:	2300      	movs	r3, #0
 80126e0:	62fb      	str	r3, [r7, #44]	; 0x2c
			sFilterConfig.FilterActivation = ENABLE;
 80126e2:	2301      	movs	r3, #1
 80126e4:	62bb      	str	r3, [r7, #40]	; 0x28
			sFilterConfig.FilterFIFOAssignment = CAN_FILTER_FIFO0;
 80126e6:	2300      	movs	r3, #0
 80126e8:	61bb      	str	r3, [r7, #24]
			sFilterConfig.FilterIdHigh = 0x0000;
 80126ea:	2300      	movs	r3, #0
 80126ec:	60bb      	str	r3, [r7, #8]
			sFilterConfig.FilterIdLow = 0x0000;
 80126ee:	2300      	movs	r3, #0
 80126f0:	60fb      	str	r3, [r7, #12]
			sFilterConfig.FilterMaskIdHigh = 0x0000;
 80126f2:	2300      	movs	r3, #0
 80126f4:	613b      	str	r3, [r7, #16]
			sFilterConfig.FilterMaskIdLow = 0x0000;
 80126f6:	2300      	movs	r3, #0
 80126f8:	617b      	str	r3, [r7, #20]
			sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
 80126fa:	2300      	movs	r3, #0
 80126fc:	623b      	str	r3, [r7, #32]
			sFilterConfig.FilterNumber = 0;
 80126fe:	2300      	movs	r3, #0
 8012700:	61fb      	str	r3, [r7, #28]
			sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
 8012702:	2301      	movs	r3, #1
 8012704:	627b      	str	r3, [r7, #36]	; 0x24
			HAL_CAN_ConfigFilter(&(stcan->hcan),&sFilterConfig);
 8012706:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8012708:	f107 0308 	add.w	r3, r7, #8
 801270c:	4610      	mov	r0, r2
 801270e:	4619      	mov	r1, r3
 8012710:	f7f5 f9da 	bl	8007ac8 <HAL_CAN_ConfigFilter>
			stcan->hcan.pTxMsg = (CanTxMsgTypeDef*)rt_malloc(sizeof(CanTxMsgTypeDef));
 8012714:	201c      	movs	r0, #28
 8012716:	f005 fa7f 	bl	8017c18 <rt_malloc>
 801271a:	4602      	mov	r2, r0
 801271c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801271e:	631a      	str	r2, [r3, #48]	; 0x30
			stcan->hcan.pRxMsg = (CanRxMsgTypeDef*)rt_malloc(sizeof(CanRxMsgTypeDef));
 8012720:	2024      	movs	r0, #36	; 0x24
 8012722:	f005 fa79 	bl	8017c18 <rt_malloc>
 8012726:	4602      	mov	r2, r0
 8012728:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801272a:	635a      	str	r2, [r3, #52]	; 0x34
			if(stcan->hcan.pTxMsg == NULL || stcan->hcan.pRxMsg == NULL)
 801272c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801272e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012730:	2b00      	cmp	r3, #0
 8012732:	d003      	beq.n	801273c <stm32_CANconfigure+0xf4>
 8012734:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012736:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8012738:	2b00      	cmp	r3, #0
 801273a:	d104      	bne.n	8012746 <stm32_CANconfigure+0xfe>
			{
				rt_kprintf("malloc fail\r\n");
 801273c:	4811      	ldr	r0, [pc, #68]	; (8012784 <stm32_CANconfigure+0x13c>)
 801273e:	f005 f8bd 	bl	80178bc <rt_kprintf>
				return RT_ERROR;
 8012742:	2301      	movs	r3, #1
 8012744:	e016      	b.n	8012774 <stm32_CANconfigure+0x12c>
			}
			#if 1
			timerCanrx = rt_timer_create("timerCanrx",timerCanrxfunc,RT_NULL,20,RT_TIMER_FLAG_PERIODIC);
 8012746:	2302      	movs	r3, #2
 8012748:	9300      	str	r3, [sp, #0]
 801274a:	480f      	ldr	r0, [pc, #60]	; (8012788 <stm32_CANconfigure+0x140>)
 801274c:	490f      	ldr	r1, [pc, #60]	; (801278c <stm32_CANconfigure+0x144>)
 801274e:	2200      	movs	r2, #0
 8012750:	2314      	movs	r3, #20
 8012752:	f006 fd57 	bl	8019204 <rt_timer_create>
 8012756:	4602      	mov	r2, r0
 8012758:	4b0d      	ldr	r3, [pc, #52]	; (8012790 <stm32_CANconfigure+0x148>)
 801275a:	601a      	str	r2, [r3, #0]
			if (timerCanrx != RT_NULL) rt_timer_start(timerCanrx);
 801275c:	4b0c      	ldr	r3, [pc, #48]	; (8012790 <stm32_CANconfigure+0x148>)
 801275e:	681b      	ldr	r3, [r3, #0]
 8012760:	2b00      	cmp	r3, #0
 8012762:	d004      	beq.n	801276e <stm32_CANconfigure+0x126>
 8012764:	4b0a      	ldr	r3, [pc, #40]	; (8012790 <stm32_CANconfigure+0x148>)
 8012766:	681b      	ldr	r3, [r3, #0]
 8012768:	4618      	mov	r0, r3
 801276a:	f006 fd6b 	bl	8019244 <rt_timer_start>
			break;
		default:
			return RT_ERROR;
			break;
	}
	return result;
 801276e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012770:	e000      	b.n	8012774 <stm32_CANconfigure+0x12c>
			HAL_CAN_Receive_IT(&stcan->hcan,CAN_FIFO1);
			#endif
			/* Enable Error Interrupt */
			break;
		default:
			return RT_ERROR;
 8012772:	2301      	movs	r3, #1
			break;
	}
	return result;
}
 8012774:	4618      	mov	r0, r3
 8012776:	3738      	adds	r7, #56	; 0x38
 8012778:	46bd      	mov	sp, r7
 801277a:	bd80      	pop	{r7, pc}
 801277c:	08027058 	.word	0x08027058
 8012780:	0802706c 	.word	0x0802706c
 8012784:	08027080 	.word	0x08027080
 8012788:	08027090 	.word	0x08027090
 801278c:	0801262d 	.word	0x0801262d
 8012790:	200107fc 	.word	0x200107fc

08012794 <Can_hw_init>:
	stm32_CANsendmsg,    
	stm32_CANrecvmsg,    
};

int Can_hw_init(void)
{
 8012794:	b5b0      	push	{r4, r5, r7, lr}
 8012796:	b086      	sub	sp, #24
 8012798:	af00      	add	r7, sp, #0
	stm32_canTypeDef *can;
    struct can_configure config = CAN1_CONFIG;
 801279a:	4b0f      	ldr	r3, [pc, #60]	; (80127d8 <Can_hw_init+0x44>)
 801279c:	463c      	mov	r4, r7
 801279e:	461d      	mov	r5, r3
 80127a0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80127a2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80127a4:	682b      	ldr	r3, [r5, #0]
 80127a6:	6023      	str	r3, [r4, #0]
	
	canDevice1.config = config;
 80127a8:	4b0c      	ldr	r3, [pc, #48]	; (80127dc <Can_hw_init+0x48>)
 80127aa:	f103 0444 	add.w	r4, r3, #68	; 0x44
 80127ae:	463d      	mov	r5, r7
 80127b0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80127b2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80127b4:	682b      	ldr	r3, [r5, #0]
 80127b6:	6023      	str	r3, [r4, #0]

	can = &can1;
 80127b8:	4b09      	ldr	r3, [pc, #36]	; (80127e0 <Can_hw_init+0x4c>)
 80127ba:	617b      	str	r3, [r7, #20]
	can->hcan.Instance = CAN1;
 80127bc:	697b      	ldr	r3, [r7, #20]
 80127be:	4a09      	ldr	r2, [pc, #36]	; (80127e4 <Can_hw_init+0x50>)
 80127c0:	601a      	str	r2, [r3, #0]

	rt_hw_can_register(&canDevice1,"can1",&stm32_can_ops,can);
 80127c2:	4806      	ldr	r0, [pc, #24]	; (80127dc <Can_hw_init+0x48>)
 80127c4:	4908      	ldr	r1, [pc, #32]	; (80127e8 <Can_hw_init+0x54>)
 80127c6:	4a09      	ldr	r2, [pc, #36]	; (80127ec <Can_hw_init+0x58>)
 80127c8:	697b      	ldr	r3, [r7, #20]
 80127ca:	f009 fca7 	bl	801c11c <rt_hw_can_register>
	//HAL_CAN_Receive_IT(&hcan,CAN_FIFO1);
	
	/* Enable Error Interrupt */
	__HAL_CAN_ENABLE_IT(&hcan, CAN_IT_ERR);
	#endif
	return 0;
 80127ce:	2300      	movs	r3, #0
	
}
 80127d0:	4618      	mov	r0, r3
 80127d2:	3718      	adds	r7, #24
 80127d4:	46bd      	mov	sp, r7
 80127d6:	bdb0      	pop	{r4, r5, r7, pc}
 80127d8:	080270a4 	.word	0x080270a4
 80127dc:	20012788 	.word	0x20012788
 80127e0:	20012880 	.word	0x20012880
 80127e4:	40006400 	.word	0x40006400
 80127e8:	0802709c 	.word	0x0802709c
 80127ec:	08028cc0 	.word	0x08028cc0

080127f0 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80127f0:	b480      	push	{r7}
 80127f2:	b083      	sub	sp, #12
 80127f4:	af00      	add	r7, sp, #0
 80127f6:	4603      	mov	r3, r0
 80127f8:	6039      	str	r1, [r7, #0]
 80127fa:	71fb      	strb	r3, [r7, #7]
  if((int32_t)IRQn < 0) {
 80127fc:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8012800:	2b00      	cmp	r3, #0
 8012802:	da0b      	bge.n	801281c <NVIC_SetPriority+0x2c>
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8012804:	490d      	ldr	r1, [pc, #52]	; (801283c <NVIC_SetPriority+0x4c>)
 8012806:	79fb      	ldrb	r3, [r7, #7]
 8012808:	f003 030f 	and.w	r3, r3, #15
 801280c:	3b04      	subs	r3, #4
 801280e:	683a      	ldr	r2, [r7, #0]
 8012810:	b2d2      	uxtb	r2, r2
 8012812:	0112      	lsls	r2, r2, #4
 8012814:	b2d2      	uxtb	r2, r2
 8012816:	440b      	add	r3, r1
 8012818:	761a      	strb	r2, [r3, #24]
 801281a:	e009      	b.n	8012830 <NVIC_SetPriority+0x40>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]                = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 801281c:	4908      	ldr	r1, [pc, #32]	; (8012840 <NVIC_SetPriority+0x50>)
 801281e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8012822:	683a      	ldr	r2, [r7, #0]
 8012824:	b2d2      	uxtb	r2, r2
 8012826:	0112      	lsls	r2, r2, #4
 8012828:	b2d2      	uxtb	r2, r2
 801282a:	440b      	add	r3, r1
 801282c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 8012830:	370c      	adds	r7, #12
 8012832:	46bd      	mov	sp, r7
 8012834:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012838:	4770      	bx	lr
 801283a:	bf00      	nop
 801283c:	e000ed00 	.word	0xe000ed00
 8012840:	e000e100 	.word	0xe000e100

08012844 <SCB_EnableICache>:
/** \brief Enable I-Cache

    The function turns on I-Cache
  */
__STATIC_INLINE void SCB_EnableICache (void)
{
 8012844:	b480      	push	{r7}
 8012846:	af00      	add	r7, sp, #0
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8012848:	f3bf 8f4f 	dsb	sy
    so that all instructions following the ISB are fetched from cache or
    memory, after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 801284c:	f3bf 8f6f 	isb	sy
  #if (__ICACHE_PRESENT == 1)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     // invalidate I-Cache
 8012850:	4b08      	ldr	r3, [pc, #32]	; (8012874 <SCB_EnableICache+0x30>)
 8012852:	2200      	movs	r2, #0
 8012854:	f8c3 2250 	str.w	r2, [r3, #592]	; 0x250
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  // enable I-Cache
 8012858:	4a06      	ldr	r2, [pc, #24]	; (8012874 <SCB_EnableICache+0x30>)
 801285a:	4b06      	ldr	r3, [pc, #24]	; (8012874 <SCB_EnableICache+0x30>)
 801285c:	695b      	ldr	r3, [r3, #20]
 801285e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8012862:	6153      	str	r3, [r2, #20]
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8012864:	f3bf 8f4f 	dsb	sy
    so that all instructions following the ISB are fetched from cache or
    memory, after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 8012868:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
  #endif
}
 801286c:	46bd      	mov	sp, r7
 801286e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012872:	4770      	bx	lr
 8012874:	e000ed00 	.word	0xe000ed00

08012878 <SCB_EnableDCache>:
/** \brief Enable D-Cache

    The function turns on D-Cache
  */
__STATIC_INLINE void SCB_EnableDCache (void)
{
 8012878:	b480      	push	{r7}
 801287a:	b089      	sub	sp, #36	; 0x24
 801287c:	af00      	add	r7, sp, #0
  #if (__DCACHE_PRESENT == 1)
    uint32_t ccsidr, sshift, wshift, sw;
    uint32_t sets, ways;

    SCB->CSSELR = (0UL << 1) | 0UL;         // Level 1 data cache
 801287e:	4b25      	ldr	r3, [pc, #148]	; (8012914 <SCB_EnableDCache+0x9c>)
 8012880:	2200      	movs	r2, #0
 8012882:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    ccsidr  = SCB->CCSIDR;
 8012886:	4b23      	ldr	r3, [pc, #140]	; (8012914 <SCB_EnableDCache+0x9c>)
 8012888:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 801288c:	617b      	str	r3, [r7, #20]
    sets    = (uint32_t)(CCSIDR_SETS(ccsidr));
 801288e:	697a      	ldr	r2, [r7, #20]
 8012890:	4b21      	ldr	r3, [pc, #132]	; (8012918 <SCB_EnableDCache+0xa0>)
 8012892:	4013      	ands	r3, r2
 8012894:	0b5b      	lsrs	r3, r3, #13
 8012896:	61fb      	str	r3, [r7, #28]
    sshift  = (uint32_t)(CCSIDR_LSSHIFT(ccsidr) + 4UL);
 8012898:	697b      	ldr	r3, [r7, #20]
 801289a:	f003 0307 	and.w	r3, r3, #7
 801289e:	3304      	adds	r3, #4
 80128a0:	613b      	str	r3, [r7, #16]
    ways    = (uint32_t)(CCSIDR_WAYS(ccsidr));
 80128a2:	697a      	ldr	r2, [r7, #20]
 80128a4:	f641 73f8 	movw	r3, #8184	; 0x1ff8
 80128a8:	4013      	ands	r3, r2
 80128aa:	08db      	lsrs	r3, r3, #3
 80128ac:	60fb      	str	r3, [r7, #12]
    wshift  = (uint32_t)((uint32_t)__CLZ(ways) & 0x1FUL);
 80128ae:	68fb      	ldr	r3, [r7, #12]
 80128b0:	fab3 f383 	clz	r3, r3
 80128b4:	f003 031f 	and.w	r3, r3, #31
 80128b8:	60bb      	str	r3, [r7, #8]
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80128ba:	f3bf 8f4f 	dsb	sy

    __DSB();

    do {                                   // invalidate D-Cache
         uint32_t tmpways = ways;
 80128be:	68fb      	ldr	r3, [r7, #12]
 80128c0:	61bb      	str	r3, [r7, #24]
         do {
              sw = ((tmpways << wshift) | (sets << sshift));
 80128c2:	68bb      	ldr	r3, [r7, #8]
 80128c4:	69ba      	ldr	r2, [r7, #24]
 80128c6:	409a      	lsls	r2, r3
 80128c8:	693b      	ldr	r3, [r7, #16]
 80128ca:	69f9      	ldr	r1, [r7, #28]
 80128cc:	fa01 f303 	lsl.w	r3, r1, r3
 80128d0:	4313      	orrs	r3, r2
 80128d2:	607b      	str	r3, [r7, #4]
              SCB->DCISW = sw;
 80128d4:	4a0f      	ldr	r2, [pc, #60]	; (8012914 <SCB_EnableDCache+0x9c>)
 80128d6:	687b      	ldr	r3, [r7, #4]
 80128d8:	f8c2 3260 	str.w	r3, [r2, #608]	; 0x260
            } while(tmpways--);
 80128dc:	69bb      	ldr	r3, [r7, #24]
 80128de:	1e5a      	subs	r2, r3, #1
 80128e0:	61ba      	str	r2, [r7, #24]
 80128e2:	2b00      	cmp	r3, #0
 80128e4:	d1ed      	bne.n	80128c2 <SCB_EnableDCache+0x4a>
        } while(sets--);
 80128e6:	69fb      	ldr	r3, [r7, #28]
 80128e8:	1e5a      	subs	r2, r3, #1
 80128ea:	61fa      	str	r2, [r7, #28]
 80128ec:	2b00      	cmp	r3, #0
 80128ee:	d1e6      	bne.n	80128be <SCB_EnableDCache+0x46>
 80128f0:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;   // enable D-Cache
 80128f4:	4a07      	ldr	r2, [pc, #28]	; (8012914 <SCB_EnableDCache+0x9c>)
 80128f6:	4b07      	ldr	r3, [pc, #28]	; (8012914 <SCB_EnableDCache+0x9c>)
 80128f8:	695b      	ldr	r3, [r3, #20]
 80128fa:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80128fe:	6153      	str	r3, [r2, #20]
 8012900:	f3bf 8f4f 	dsb	sy
    so that all instructions following the ISB are fetched from cache or
    memory, after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 8012904:	f3bf 8f6f 	isb	sy

    __DSB();
    __ISB();
  #endif
}
 8012908:	3724      	adds	r7, #36	; 0x24
 801290a:	46bd      	mov	sp, r7
 801290c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012910:	4770      	bx	lr
 8012912:	bf00      	nop
 8012914:	e000ed00 	.word	0xe000ed00
 8012918:	0fffe000 	.word	0x0fffe000

0801291c <SysTick_Config>:
    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 801291c:	b580      	push	{r7, lr}
 801291e:	b082      	sub	sp, #8
 8012920:	af00      	add	r7, sp, #0
 8012922:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
 8012924:	687b      	ldr	r3, [r7, #4]
 8012926:	3b01      	subs	r3, #1
 8012928:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 801292c:	d301      	bcc.n	8012932 <SysTick_Config+0x16>
 801292e:	2301      	movs	r3, #1
 8012930:	e00f      	b.n	8012952 <SysTick_Config+0x36>

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8012932:	4a0a      	ldr	r2, [pc, #40]	; (801295c <SysTick_Config+0x40>)
 8012934:	687b      	ldr	r3, [r7, #4]
 8012936:	3b01      	subs	r3, #1
 8012938:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 801293a:	f04f 30ff 	mov.w	r0, #4294967295
 801293e:	210f      	movs	r1, #15
 8012940:	f7ff ff56 	bl	80127f0 <NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8012944:	4b05      	ldr	r3, [pc, #20]	; (801295c <SysTick_Config+0x40>)
 8012946:	2200      	movs	r2, #0
 8012948:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 801294a:	4b04      	ldr	r3, [pc, #16]	; (801295c <SysTick_Config+0x40>)
 801294c:	2207      	movs	r2, #7
 801294e:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8012950:	2300      	movs	r3, #0
}
 8012952:	4618      	mov	r0, r3
 8012954:	3708      	adds	r7, #8
 8012956:	46bd      	mov	sp, r7
 8012958:	bd80      	pop	{r7, pc}
 801295a:	bf00      	nop
 801295c:	e000e010 	.word	0xe000e010

08012960 <SystemClock_Config>:
  *            Flash Latency(WS)              = 6
  * @param  None
  * @retval None
  */
static void SystemClock_Config(void)
{
 8012960:	b580      	push	{r7, lr}
 8012962:	b092      	sub	sp, #72	; 0x48
 8012964:	af00      	add	r7, sp, #0
    RCC_ClkInitTypeDef RCC_ClkInitStruct;
    RCC_OscInitTypeDef RCC_OscInitStruct;
    HAL_StatusTypeDef ret = HAL_OK;
 8012966:	2300      	movs	r3, #0
 8012968:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47

    /* Enable HSE Oscillator and activate PLL with HSE as source 
	PLLCLK= (HSE*N)/(M*P) */
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 801296c:	2301      	movs	r3, #1
 801296e:	603b      	str	r3, [r7, #0]
    RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8012970:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8012974:	607b      	str	r3, [r7, #4]
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8012976:	2302      	movs	r3, #2
 8012978:	61bb      	str	r3, [r7, #24]
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 801297a:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 801297e:	61fb      	str	r3, [r7, #28]
    RCC_OscInitStruct.PLL.PLLM = 25;
 8012980:	2319      	movs	r3, #25
 8012982:	623b      	str	r3, [r7, #32]
    RCC_OscInitStruct.PLL.PLLN = 400;
 8012984:	f44f 73c8 	mov.w	r3, #400	; 0x190
 8012988:	627b      	str	r3, [r7, #36]	; 0x24
    RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 801298a:	2302      	movs	r3, #2
 801298c:	62bb      	str	r3, [r7, #40]	; 0x28
    RCC_OscInitStruct.PLL.PLLQ = 8;
 801298e:	2308      	movs	r3, #8
 8012990:	62fb      	str	r3, [r7, #44]	; 0x2c
    
    ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8012992:	463b      	mov	r3, r7
 8012994:	4618      	mov	r0, r3
 8012996:	f7fb f83d 	bl	800da14 <HAL_RCC_OscConfig>
 801299a:	4603      	mov	r3, r0
 801299c:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
    if(ret != HAL_OK)
 80129a0:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80129a4:	2b00      	cmp	r3, #0
 80129a6:	d000      	beq.n	80129aa <SystemClock_Config+0x4a>
    {
        while(1) { ; }
 80129a8:	e7fe      	b.n	80129a8 <SystemClock_Config+0x48>
    }

    ret = HAL_PWREx_EnableOverDrive();
 80129aa:	f7fa ffe5 	bl	800d978 <HAL_PWREx_EnableOverDrive>
 80129ae:	4603      	mov	r3, r0
 80129b0:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
    if (ret != HAL_OK)
 80129b4:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80129b8:	2b00      	cmp	r3, #0
 80129ba:	d000      	beq.n	80129be <SystemClock_Config+0x5e>
    {
        while (1) { ; }
 80129bc:	e7fe      	b.n	80129bc <SystemClock_Config+0x5c>
    /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
       clocks dividers 
       PCLK1  = 50MHz
       PCLK2 = 100MHz
       TIM1CLK = 100MHz */
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
 80129be:	230f      	movs	r3, #15
 80129c0:	633b      	str	r3, [r7, #48]	; 0x30
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80129c2:	2302      	movs	r3, #2
 80129c4:	637b      	str	r3, [r7, #52]	; 0x34
    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80129c6:	2300      	movs	r3, #0
 80129c8:	63bb      	str	r3, [r7, #56]	; 0x38
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 80129ca:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 80129ce:	63fb      	str	r3, [r7, #60]	; 0x3c
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80129d0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80129d4:	643b      	str	r3, [r7, #64]	; 0x40
    ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6);
 80129d6:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80129da:	4618      	mov	r0, r3
 80129dc:	2106      	movs	r1, #6
 80129de:	f7fb faef 	bl	800dfc0 <HAL_RCC_ClockConfig>
 80129e2:	4603      	mov	r3, r0
 80129e4:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
    if (ret != HAL_OK)
 80129e8:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80129ec:	2b00      	cmp	r3, #0
 80129ee:	d000      	beq.n	80129f2 <SystemClock_Config+0x92>
    {
        while (1) { ; }
 80129f0:	e7fe      	b.n	80129f0 <SystemClock_Config+0x90>
    }
}
 80129f2:	3748      	adds	r7, #72	; 0x48
 80129f4:	46bd      	mov	sp, r7
 80129f6:	bd80      	pop	{r7, pc}

080129f8 <CPU_CACHE_Enable>:
  * @brief  CPU L1-Cache enable.
  * @param  None
  * @retval None
  */
static void CPU_CACHE_Enable(void)
{
 80129f8:	b580      	push	{r7, lr}
 80129fa:	af00      	add	r7, sp, #0
    /* Enable branch prediction */
    SCB->CCR |= (1 << 18);
 80129fc:	4a06      	ldr	r2, [pc, #24]	; (8012a18 <CPU_CACHE_Enable+0x20>)
 80129fe:	4b06      	ldr	r3, [pc, #24]	; (8012a18 <CPU_CACHE_Enable+0x20>)
 8012a00:	695b      	ldr	r3, [r3, #20]
 8012a02:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8012a06:	6153      	str	r3, [r2, #20]
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8012a08:	f3bf 8f4f 	dsb	sy
    __DSB();

    /* Enable I-Cache */
    SCB_EnableICache();
 8012a0c:	f7ff ff1a 	bl	8012844 <SCB_EnableICache>

    /* Enable D-Cache */
    SCB_EnableDCache();
 8012a10:	f7ff ff32 	bl	8012878 <SCB_EnableDCache>
}
 8012a14:	bd80      	pop	{r7, pc}
 8012a16:	bf00      	nop
 8012a18:	e000ed00 	.word	0xe000ed00

08012a1c <SysTick_Handler>:
/**
 * This is the timer interrupt service routine.
 *
 */
void SysTick_Handler(void)
{
 8012a1c:	b580      	push	{r7, lr}
 8012a1e:	af00      	add	r7, sp, #0
    /* enter interrupt */
    rt_interrupt_enter();
 8012a20:	f004 f93c 	bl	8016c9c <rt_interrupt_enter>

    /* tick for HAL Library */
    HAL_IncTick();
 8012a24:	f7f3 ffd6 	bl	80069d4 <HAL_IncTick>
	#ifdef USER_USING_MOTORCONTROL
	MC_SysTickHandler();
	#endif
    rt_tick_increase();
 8012a28:	f003 f810 	bl	8015a4c <rt_tick_increase>
    /* leave interrupt */
    rt_interrupt_leave();
 8012a2c:	f004 f94c 	bl	8016cc8 <rt_interrupt_leave>
}
 8012a30:	bd80      	pop	{r7, pc}
 8012a32:	bf00      	nop

08012a34 <HAL_InitTick>:

/* re-implementat tick interface for STM32 HAL */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8012a34:	b580      	push	{r7, lr}
 8012a36:	b082      	sub	sp, #8
 8012a38:	af00      	add	r7, sp, #0
 8012a3a:	6078      	str	r0, [r7, #4]
    /*Configure the SysTick to have interrupt in 1ms time basis*/
    HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/RT_TICK_PER_SECOND);
 8012a3c:	f7fb fca2 	bl	800e384 <HAL_RCC_GetHCLKFreq>
 8012a40:	4602      	mov	r2, r0
 8012a42:	4b09      	ldr	r3, [pc, #36]	; (8012a68 <HAL_InitTick+0x34>)
 8012a44:	fba3 2302 	umull	r2, r3, r3, r2
 8012a48:	09db      	lsrs	r3, r3, #7
 8012a4a:	4618      	mov	r0, r3
 8012a4c:	f7f6 f81a 	bl	8008a84 <HAL_SYSTICK_Config>

    /*Configure the SysTick IRQ priority */
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 8012a50:	f04f 30ff 	mov.w	r0, #4294967295
 8012a54:	6879      	ldr	r1, [r7, #4]
 8012a56:	2200      	movs	r2, #0
 8012a58:	f7f5 ffdc 	bl	8008a14 <HAL_NVIC_SetPriority>

    /* Return function status */
    return HAL_OK;
 8012a5c:	2300      	movs	r3, #0
}
 8012a5e:	4618      	mov	r0, r3
 8012a60:	3708      	adds	r7, #8
 8012a62:	46bd      	mov	sp, r7
 8012a64:	bd80      	pop	{r7, pc}
 8012a66:	bf00      	nop
 8012a68:	10624dd3 	.word	0x10624dd3

08012a6c <rt_hw_board_init>:

/**
 * This function will initial STM32 board.
 */
void rt_hw_board_init()
{
 8012a6c:	b580      	push	{r7, lr}
 8012a6e:	af00      	add	r7, sp, #0
    /* Configure the MPU attributes as Write Through */
    mpu_init();
 8012a70:	f001 f89e 	bl	8013bb0 <mpu_init>

    /* Enable the CPU Cache */
    CPU_CACHE_Enable();
 8012a74:	f7ff ffc0 	bl	80129f8 <CPU_CACHE_Enable>
    - Configure the Flash ART accelerator on ITCM interface
    - Configure the Systick to generate an interrupt each 1 msec
    - Set NVIC Group Priority to 4
    - Global MSP (MCU Support Package) initialization
    */
    HAL_Init();
 8012a78:	f7f3 ff96 	bl	80069a8 <HAL_Init>
    /* Configure the system clock @ 200 Mhz */
    SystemClock_Config();
 8012a7c:	f7ff ff70 	bl	8012960 <SystemClock_Config>
    /* init systick */
    SysTick_Config(SystemCoreClock / RT_TICK_PER_SECOND);
 8012a80:	4b09      	ldr	r3, [pc, #36]	; (8012aa8 <rt_hw_board_init+0x3c>)
 8012a82:	681b      	ldr	r3, [r3, #0]
 8012a84:	4a09      	ldr	r2, [pc, #36]	; (8012aac <rt_hw_board_init+0x40>)
 8012a86:	fba2 2303 	umull	r2, r3, r2, r3
 8012a8a:	09db      	lsrs	r3, r3, #7
 8012a8c:	4618      	mov	r0, r3
 8012a8e:	f7ff ff45 	bl	801291c <SysTick_Config>
    /* set pend exception priority */
    NVIC_SetPriority(PendSV_IRQn, (1 << __NVIC_PRIO_BITS) - 1);
 8012a92:	f06f 0001 	mvn.w	r0, #1
 8012a96:	210f      	movs	r1, #15
 8012a98:	f7ff feaa 	bl	80127f0 <NVIC_SetPriority>

    rt_components_board_init();
 8012a9c:	f003 f828 	bl	8015af0 <rt_components_board_init>

#ifdef RT_USING_CONSOLE
    rt_console_set_device(RT_CONSOLE_DEVICE_NAME);
 8012aa0:	4803      	ldr	r0, [pc, #12]	; (8012ab0 <rt_hw_board_init+0x44>)
 8012aa2:	f004 fedb 	bl	801785c <rt_console_set_device>
#endif
}
 8012aa6:	bd80      	pop	{r7, pc}
 8012aa8:	20010014 	.word	0x20010014
 8012aac:	10624dd3 	.word	0x10624dd3
 8012ab0:	080270b8 	.word	0x080270b8

08012ab4 <QIEMW_ADC_init>:

QIEMW_ADC_HandleTypeDef Global_User_ADC;


void QIEMW_ADC_init(QIEMW_ADC_HandleTypeDef *QIEMW_ADC_Handle)
{
 8012ab4:	b480      	push	{r7}
 8012ab6:	b083      	sub	sp, #12
 8012ab8:	af00      	add	r7, sp, #0
 8012aba:	6078      	str	r0, [r7, #4]
	QIEMW_ADC_Handle->PhaseA.qI1_offset= 0;
 8012abc:	687b      	ldr	r3, [r7, #4]
 8012abe:	2200      	movs	r2, #0
 8012ac0:	809a      	strh	r2, [r3, #4]
	QIEMW_ADC_Handle->PhaseA.qI2_offset= 0;
 8012ac2:	687b      	ldr	r3, [r7, #4]
 8012ac4:	2200      	movs	r2, #0
 8012ac6:	811a      	strh	r2, [r3, #8]
	QIEMW_ADC_Handle->PhaseA.qV_offset= 0;
 8012ac8:	687b      	ldr	r3, [r7, #4]
 8012aca:	2200      	movs	r2, #0
 8012acc:	819a      	strh	r2, [r3, #12]
	QIEMW_ADC_Handle->PhaseB.qI1_offset = 0;
 8012ace:	687b      	ldr	r3, [r7, #4]
 8012ad0:	2200      	movs	r2, #0
 8012ad2:	825a      	strh	r2, [r3, #18]
	QIEMW_ADC_Handle->PhaseB.qI2_offset = 0;
 8012ad4:	687b      	ldr	r3, [r7, #4]
 8012ad6:	2200      	movs	r2, #0
 8012ad8:	82da      	strh	r2, [r3, #22]
	QIEMW_ADC_Handle->PhaseB.qV_offset = 0;
 8012ada:	687b      	ldr	r3, [r7, #4]
 8012adc:	2200      	movs	r2, #0
 8012ade:	835a      	strh	r2, [r3, #26]
	QIEMW_ADC_Handle->PhaseC.qI1_offset = 0;
 8012ae0:	687b      	ldr	r3, [r7, #4]
 8012ae2:	2200      	movs	r2, #0
 8012ae4:	841a      	strh	r2, [r3, #32]
	QIEMW_ADC_Handle->PhaseC.qI2_offset = 0;
 8012ae6:	687b      	ldr	r3, [r7, #4]
 8012ae8:	2200      	movs	r2, #0
 8012aea:	849a      	strh	r2, [r3, #36]	; 0x24
	QIEMW_ADC_Handle->PhaseC.qV_offset = 0;
 8012aec:	687b      	ldr	r3, [r7, #4]
 8012aee:	2200      	movs	r2, #0
 8012af0:	851a      	strh	r2, [r3, #40]	; 0x28
	QIEMW_ADC_Handle->BUS.qV_offset = 0;
 8012af2:	687b      	ldr	r3, [r7, #4]
 8012af4:	2200      	movs	r2, #0
 8012af6:	861a      	strh	r2, [r3, #48]	; 0x30
	QIEMW_ADC_Handle->BUS.qI_offset = 0;
 8012af8:	687b      	ldr	r3, [r7, #4]
 8012afa:	2200      	movs	r2, #0
 8012afc:	859a      	strh	r2, [r3, #44]	; 0x2c
	QIEMW_ADC_Handle->UR.qV_offset = 0;
 8012afe:	687b      	ldr	r3, [r7, #4]
 8012b00:	2200      	movs	r2, #0
 8012b02:	87da      	strh	r2, [r3, #62]	; 0x3e
	QIEMW_ADC_Handle->US.qV_offset = 0;
 8012b04:	687b      	ldr	r3, [r7, #4]
 8012b06:	2200      	movs	r2, #0
 8012b08:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
	QIEMW_ADC_Handle->UT.qV_offset = 0;
 8012b0c:	687b      	ldr	r3, [r7, #4]
 8012b0e:	2200      	movs	r2, #0
 8012b10:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a
	QIEMW_ADC_Handle->Temp.TEMP_offset = 0;
 8012b14:	687b      	ldr	r3, [r7, #4]
 8012b16:	2200      	movs	r2, #0
 8012b18:	f8a3 205e 	strh.w	r2, [r3, #94]	; 0x5e
	

	QIEMW_ADC_Handle->PhaseA.qI_value = 0;
 8012b1c:	687b      	ldr	r3, [r7, #4]
 8012b1e:	2200      	movs	r2, #0
 8012b20:	805a      	strh	r2, [r3, #2]
	QIEMW_ADC_Handle->PhaseA.qI1_value = 0;
 8012b22:	687b      	ldr	r3, [r7, #4]
 8012b24:	2200      	movs	r2, #0
 8012b26:	801a      	strh	r2, [r3, #0]
	QIEMW_ADC_Handle->PhaseA.qI2_value = 0;
 8012b28:	687b      	ldr	r3, [r7, #4]
 8012b2a:	2200      	movs	r2, #0
 8012b2c:	80da      	strh	r2, [r3, #6]
	QIEMW_ADC_Handle->PhaseA.qV_value = 0;
 8012b2e:	687b      	ldr	r3, [r7, #4]
 8012b30:	2200      	movs	r2, #0
 8012b32:	815a      	strh	r2, [r3, #10]
	QIEMW_ADC_Handle->PhaseB.qI_value = 0;
 8012b34:	687b      	ldr	r3, [r7, #4]
 8012b36:	2200      	movs	r2, #0
 8012b38:	821a      	strh	r2, [r3, #16]
	QIEMW_ADC_Handle->PhaseB.qI1_value = 0;
 8012b3a:	687b      	ldr	r3, [r7, #4]
 8012b3c:	2200      	movs	r2, #0
 8012b3e:	81da      	strh	r2, [r3, #14]
	QIEMW_ADC_Handle->PhaseB.qI2_value = 0;
 8012b40:	687b      	ldr	r3, [r7, #4]
 8012b42:	2200      	movs	r2, #0
 8012b44:	829a      	strh	r2, [r3, #20]
	QIEMW_ADC_Handle->PhaseB.qV_value = 0;
 8012b46:	687b      	ldr	r3, [r7, #4]
 8012b48:	2200      	movs	r2, #0
 8012b4a:	831a      	strh	r2, [r3, #24]
	QIEMW_ADC_Handle->PhaseC.qI1_value = 0;
 8012b4c:	687b      	ldr	r3, [r7, #4]
 8012b4e:	2200      	movs	r2, #0
 8012b50:	839a      	strh	r2, [r3, #28]
	QIEMW_ADC_Handle->PhaseC.qI2_value = 0;
 8012b52:	687b      	ldr	r3, [r7, #4]
 8012b54:	2200      	movs	r2, #0
 8012b56:	845a      	strh	r2, [r3, #34]	; 0x22
	QIEMW_ADC_Handle->PhaseC.qI_value = 0;
 8012b58:	687b      	ldr	r3, [r7, #4]
 8012b5a:	2200      	movs	r2, #0
 8012b5c:	83da      	strh	r2, [r3, #30]
	QIEMW_ADC_Handle->PhaseC.qV_value = 0;
 8012b5e:	687b      	ldr	r3, [r7, #4]
 8012b60:	2200      	movs	r2, #0
 8012b62:	84da      	strh	r2, [r3, #38]	; 0x26
	QIEMW_ADC_Handle->BUS.qV_value = 0;
 8012b64:	687b      	ldr	r3, [r7, #4]
 8012b66:	2200      	movs	r2, #0
 8012b68:	85da      	strh	r2, [r3, #46]	; 0x2e
	QIEMW_ADC_Handle->BUS.qI_value = 0;
 8012b6a:	687b      	ldr	r3, [r7, #4]
 8012b6c:	2200      	movs	r2, #0
 8012b6e:	855a      	strh	r2, [r3, #42]	; 0x2a
	QIEMW_ADC_Handle->UR.qV_value = 0;
 8012b70:	687b      	ldr	r3, [r7, #4]
 8012b72:	2200      	movs	r2, #0
 8012b74:	879a      	strh	r2, [r3, #60]	; 0x3c
	QIEMW_ADC_Handle->US.qV_value = 0;
 8012b76:	687b      	ldr	r3, [r7, #4]
 8012b78:	2200      	movs	r2, #0
 8012b7a:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
	QIEMW_ADC_Handle->UT.qV_value = 0;
 8012b7e:	687b      	ldr	r3, [r7, #4]
 8012b80:	2200      	movs	r2, #0
 8012b82:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
	QIEMW_ADC_Handle->Temp.TEMP_value = 0;
 8012b86:	687b      	ldr	r3, [r7, #4]
 8012b88:	2200      	movs	r2, #0
 8012b8a:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
}
 8012b8e:	370c      	adds	r7, #12
 8012b90:	46bd      	mov	sp, r7
 8012b92:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012b96:	4770      	bx	lr

08012b98 <ADC_Calibration>:

void ADC_Calibration(ADC_HandleTypeDef* hadc,QIEMW_ADC_HandleTypeDef *QIEMW_ADC_Handle)
{
 8012b98:	b580      	push	{r7, lr}
 8012b9a:	b088      	sub	sp, #32
 8012b9c:	af00      	add	r7, sp, #0
 8012b9e:	6078      	str	r0, [r7, #4]
 8012ba0:	6039      	str	r1, [r7, #0]
	u8 bIndex;
	
	ADC_ChannelConfTypeDef sConfig;
	HAL_NVIC_DisableIRQ(ADC_IRQn);
 8012ba2:	2012      	movs	r0, #18
 8012ba4:	f7f5 ff60 	bl	8008a68 <HAL_NVIC_DisableIRQ>
	HAL_ADCEx_InjectedStop_IT(hadc);
 8012ba8:	6878      	ldr	r0, [r7, #4]
 8012baa:	f7f4 fc4b 	bl	8007444 <HAL_ADCEx_InjectedStop_IT>
	
	if(hadc->Instance == ADC1)
 8012bae:	687b      	ldr	r3, [r7, #4]
 8012bb0:	681b      	ldr	r3, [r3, #0]
 8012bb2:	4aab      	ldr	r2, [pc, #684]	; (8012e60 <ADC_Calibration+0x2c8>)
 8012bb4:	4293      	cmp	r3, r2
 8012bb6:	f040 80d2 	bne.w	8012d5e <ADC_Calibration+0x1c6>
	{
		
		sConfig.Channel = PHASE_C1_CURRENT_CHANNEL;
 8012bba:	2306      	movs	r3, #6
 8012bbc:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 8012bbe:	2301      	movs	r3, #1
 8012bc0:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 8012bc2:	2302      	movs	r3, #2
 8012bc4:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 8012bc6:	f107 030c 	add.w	r3, r7, #12
 8012bca:	6878      	ldr	r0, [r7, #4]
 8012bcc:	4619      	mov	r1, r3
 8012bce:	f7f4 f957 	bl	8006e80 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012bd2:	2310      	movs	r3, #16
 8012bd4:	77fb      	strb	r3, [r7, #31]
 8012bd6:	e021      	b.n	8012c1c <ADC_Calibration+0x84>
		{
			HAL_ADC_Start(hadc);
 8012bd8:	6878      	ldr	r0, [r7, #4]
 8012bda:	f7f3 ff5f 	bl	8006a9c <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 8012bde:	bf00      	nop
 8012be0:	687b      	ldr	r3, [r7, #4]
 8012be2:	681b      	ldr	r3, [r3, #0]
 8012be4:	681b      	ldr	r3, [r3, #0]
 8012be6:	f003 0302 	and.w	r3, r3, #2
 8012bea:	2b00      	cmp	r3, #0
 8012bec:	d0f8      	beq.n	8012be0 <ADC_Calibration+0x48>
			QIEMW_ADC_Handle->PhaseC.qI1_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 8012bee:	6878      	ldr	r0, [r7, #4]
 8012bf0:	f7f4 f91a 	bl	8006e28 <HAL_ADC_GetValue>
 8012bf4:	4603      	mov	r3, r0
 8012bf6:	b29b      	uxth	r3, r3
 8012bf8:	091b      	lsrs	r3, r3, #4
 8012bfa:	b29b      	uxth	r3, r3
 8012bfc:	4619      	mov	r1, r3
 8012bfe:	683b      	ldr	r3, [r7, #0]
 8012c00:	8c1a      	ldrh	r2, [r3, #32]
 8012c02:	b28b      	uxth	r3, r1
 8012c04:	4413      	add	r3, r2
 8012c06:	b29a      	uxth	r2, r3
 8012c08:	683b      	ldr	r3, [r7, #0]
 8012c0a:	841a      	strh	r2, [r3, #32]
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 8012c0c:	687b      	ldr	r3, [r7, #4]
 8012c0e:	681b      	ldr	r3, [r3, #0]
 8012c10:	f06f 0202 	mvn.w	r2, #2
 8012c14:	601a      	str	r2, [r3, #0]
		
		sConfig.Channel = PHASE_C1_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012c16:	7ffb      	ldrb	r3, [r7, #31]
 8012c18:	3b01      	subs	r3, #1
 8012c1a:	77fb      	strb	r3, [r7, #31]
 8012c1c:	7ffb      	ldrb	r3, [r7, #31]
 8012c1e:	2b00      	cmp	r3, #0
 8012c20:	d1da      	bne.n	8012bd8 <ADC_Calibration+0x40>
			HAL_ADC_Start(hadc);
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
			QIEMW_ADC_Handle->PhaseC.qI1_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_C2_CURRENT_CHANNEL;
 8012c22:	2309      	movs	r3, #9
 8012c24:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 8012c26:	2301      	movs	r3, #1
 8012c28:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 8012c2a:	2302      	movs	r3, #2
 8012c2c:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 8012c2e:	f107 030c 	add.w	r3, r7, #12
 8012c32:	6878      	ldr	r0, [r7, #4]
 8012c34:	4619      	mov	r1, r3
 8012c36:	f7f4 f923 	bl	8006e80 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012c3a:	2310      	movs	r3, #16
 8012c3c:	77fb      	strb	r3, [r7, #31]
 8012c3e:	e021      	b.n	8012c84 <ADC_Calibration+0xec>
		{
			HAL_ADC_Start(hadc);
 8012c40:	6878      	ldr	r0, [r7, #4]
 8012c42:	f7f3 ff2b 	bl	8006a9c <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 8012c46:	bf00      	nop
 8012c48:	687b      	ldr	r3, [r7, #4]
 8012c4a:	681b      	ldr	r3, [r3, #0]
 8012c4c:	681b      	ldr	r3, [r3, #0]
 8012c4e:	f003 0302 	and.w	r3, r3, #2
 8012c52:	2b00      	cmp	r3, #0
 8012c54:	d0f8      	beq.n	8012c48 <ADC_Calibration+0xb0>
			QIEMW_ADC_Handle->PhaseC.qI2_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 8012c56:	6878      	ldr	r0, [r7, #4]
 8012c58:	f7f4 f8e6 	bl	8006e28 <HAL_ADC_GetValue>
 8012c5c:	4603      	mov	r3, r0
 8012c5e:	b29b      	uxth	r3, r3
 8012c60:	091b      	lsrs	r3, r3, #4
 8012c62:	b29b      	uxth	r3, r3
 8012c64:	4619      	mov	r1, r3
 8012c66:	683b      	ldr	r3, [r7, #0]
 8012c68:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 8012c6a:	b28b      	uxth	r3, r1
 8012c6c:	4413      	add	r3, r2
 8012c6e:	b29a      	uxth	r2, r3
 8012c70:	683b      	ldr	r3, [r7, #0]
 8012c72:	849a      	strh	r2, [r3, #36]	; 0x24
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 8012c74:	687b      	ldr	r3, [r7, #4]
 8012c76:	681b      	ldr	r3, [r3, #0]
 8012c78:	f06f 0202 	mvn.w	r2, #2
 8012c7c:	601a      	str	r2, [r3, #0]
		}
		sConfig.Channel = PHASE_C2_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012c7e:	7ffb      	ldrb	r3, [r7, #31]
 8012c80:	3b01      	subs	r3, #1
 8012c82:	77fb      	strb	r3, [r7, #31]
 8012c84:	7ffb      	ldrb	r3, [r7, #31]
 8012c86:	2b00      	cmp	r3, #0
 8012c88:	d1da      	bne.n	8012c40 <ADC_Calibration+0xa8>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
			QIEMW_ADC_Handle->PhaseC.qI2_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_C_VOLTAGE_CHANNEL;
 8012c8a:	2305      	movs	r3, #5
 8012c8c:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 8012c8e:	2301      	movs	r3, #1
 8012c90:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 8012c92:	2302      	movs	r3, #2
 8012c94:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 8012c96:	f107 030c 	add.w	r3, r7, #12
 8012c9a:	6878      	ldr	r0, [r7, #4]
 8012c9c:	4619      	mov	r1, r3
 8012c9e:	f7f4 f8ef 	bl	8006e80 <HAL_ADC_ConfigChannel>
		
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012ca2:	2310      	movs	r3, #16
 8012ca4:	77fb      	strb	r3, [r7, #31]
 8012ca6:	e021      	b.n	8012cec <ADC_Calibration+0x154>
		{
			HAL_ADC_Start(hadc);
 8012ca8:	6878      	ldr	r0, [r7, #4]
 8012caa:	f7f3 fef7 	bl	8006a9c <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 8012cae:	bf00      	nop
 8012cb0:	687b      	ldr	r3, [r7, #4]
 8012cb2:	681b      	ldr	r3, [r3, #0]
 8012cb4:	681b      	ldr	r3, [r3, #0]
 8012cb6:	f003 0302 	and.w	r3, r3, #2
 8012cba:	2b00      	cmp	r3, #0
 8012cbc:	d0f8      	beq.n	8012cb0 <ADC_Calibration+0x118>
			QIEMW_ADC_Handle->PhaseC.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 8012cbe:	6878      	ldr	r0, [r7, #4]
 8012cc0:	f7f4 f8b2 	bl	8006e28 <HAL_ADC_GetValue>
 8012cc4:	4603      	mov	r3, r0
 8012cc6:	b29b      	uxth	r3, r3
 8012cc8:	091b      	lsrs	r3, r3, #4
 8012cca:	b29b      	uxth	r3, r3
 8012ccc:	4619      	mov	r1, r3
 8012cce:	683b      	ldr	r3, [r7, #0]
 8012cd0:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8012cd2:	b28b      	uxth	r3, r1
 8012cd4:	4413      	add	r3, r2
 8012cd6:	b29a      	uxth	r2, r3
 8012cd8:	683b      	ldr	r3, [r7, #0]
 8012cda:	851a      	strh	r2, [r3, #40]	; 0x28
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 8012cdc:	687b      	ldr	r3, [r7, #4]
 8012cde:	681b      	ldr	r3, [r3, #0]
 8012ce0:	f06f 0202 	mvn.w	r2, #2
 8012ce4:	601a      	str	r2, [r3, #0]
		sConfig.Channel = PHASE_C_VOLTAGE_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012ce6:	7ffb      	ldrb	r3, [r7, #31]
 8012ce8:	3b01      	subs	r3, #1
 8012cea:	77fb      	strb	r3, [r7, #31]
 8012cec:	7ffb      	ldrb	r3, [r7, #31]
 8012cee:	2b00      	cmp	r3, #0
 8012cf0:	d1da      	bne.n	8012ca8 <ADC_Calibration+0x110>
			QIEMW_ADC_Handle->PhaseC.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}

		sConfig.Channel = PHASE_TEMP_CHANNEL;
 8012cf2:	2308      	movs	r3, #8
 8012cf4:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 8012cf6:	2301      	movs	r3, #1
 8012cf8:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 8012cfa:	2302      	movs	r3, #2
 8012cfc:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 8012cfe:	f107 030c 	add.w	r3, r7, #12
 8012d02:	6878      	ldr	r0, [r7, #4]
 8012d04:	4619      	mov	r1, r3
 8012d06:	f7f4 f8bb 	bl	8006e80 <HAL_ADC_ConfigChannel>
		
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012d0a:	2310      	movs	r3, #16
 8012d0c:	77fb      	strb	r3, [r7, #31]
 8012d0e:	e023      	b.n	8012d58 <ADC_Calibration+0x1c0>
		{
			HAL_ADC_Start(hadc);
 8012d10:	6878      	ldr	r0, [r7, #4]
 8012d12:	f7f3 fec3 	bl	8006a9c <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 8012d16:	bf00      	nop
 8012d18:	687b      	ldr	r3, [r7, #4]
 8012d1a:	681b      	ldr	r3, [r3, #0]
 8012d1c:	681b      	ldr	r3, [r3, #0]
 8012d1e:	f003 0302 	and.w	r3, r3, #2
 8012d22:	2b00      	cmp	r3, #0
 8012d24:	d0f8      	beq.n	8012d18 <ADC_Calibration+0x180>
			QIEMW_ADC_Handle->Temp.TEMP_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 8012d26:	6878      	ldr	r0, [r7, #4]
 8012d28:	f7f4 f87e 	bl	8006e28 <HAL_ADC_GetValue>
 8012d2c:	4603      	mov	r3, r0
 8012d2e:	b29b      	uxth	r3, r3
 8012d30:	091b      	lsrs	r3, r3, #4
 8012d32:	b29b      	uxth	r3, r3
 8012d34:	4619      	mov	r1, r3
 8012d36:	683b      	ldr	r3, [r7, #0]
 8012d38:	f8b3 205e 	ldrh.w	r2, [r3, #94]	; 0x5e
 8012d3c:	b28b      	uxth	r3, r1
 8012d3e:	4413      	add	r3, r2
 8012d40:	b29a      	uxth	r2, r3
 8012d42:	683b      	ldr	r3, [r7, #0]
 8012d44:	f8a3 205e 	strh.w	r2, [r3, #94]	; 0x5e
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 8012d48:	687b      	ldr	r3, [r7, #4]
 8012d4a:	681b      	ldr	r3, [r3, #0]
 8012d4c:	f06f 0202 	mvn.w	r2, #2
 8012d50:	601a      	str	r2, [r3, #0]
		sConfig.Channel = PHASE_TEMP_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012d52:	7ffb      	ldrb	r3, [r7, #31]
 8012d54:	3b01      	subs	r3, #1
 8012d56:	77fb      	strb	r3, [r7, #31]
 8012d58:	7ffb      	ldrb	r3, [r7, #31]
 8012d5a:	2b00      	cmp	r3, #0
 8012d5c:	d1d8      	bne.n	8012d10 <ADC_Calibration+0x178>
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
	}

	if(hadc->Instance == ADC2)
 8012d5e:	687b      	ldr	r3, [r7, #4]
 8012d60:	681b      	ldr	r3, [r3, #0]
 8012d62:	4a40      	ldr	r2, [pc, #256]	; (8012e64 <ADC_Calibration+0x2cc>)
 8012d64:	4293      	cmp	r3, r2
 8012d66:	f040 80d8 	bne.w	8012f1a <ADC_Calibration+0x382>
	{
		sConfig.Channel = PHASE_B1_CURRENT_CHANNEL;
 8012d6a:	2303      	movs	r3, #3
 8012d6c:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 8012d6e:	2301      	movs	r3, #1
 8012d70:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 8012d72:	2302      	movs	r3, #2
 8012d74:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 8012d76:	f107 030c 	add.w	r3, r7, #12
 8012d7a:	6878      	ldr	r0, [r7, #4]
 8012d7c:	4619      	mov	r1, r3
 8012d7e:	f7f4 f87f 	bl	8006e80 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012d82:	2310      	movs	r3, #16
 8012d84:	77fb      	strb	r3, [r7, #31]
 8012d86:	e021      	b.n	8012dcc <ADC_Calibration+0x234>
		{
			HAL_ADC_Start(hadc);
 8012d88:	6878      	ldr	r0, [r7, #4]
 8012d8a:	f7f3 fe87 	bl	8006a9c <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 8012d8e:	bf00      	nop
 8012d90:	687b      	ldr	r3, [r7, #4]
 8012d92:	681b      	ldr	r3, [r3, #0]
 8012d94:	681b      	ldr	r3, [r3, #0]
 8012d96:	f003 0302 	and.w	r3, r3, #2
 8012d9a:	2b00      	cmp	r3, #0
 8012d9c:	d0f8      	beq.n	8012d90 <ADC_Calibration+0x1f8>
			QIEMW_ADC_Handle->PhaseB.qI1_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 8012d9e:	6878      	ldr	r0, [r7, #4]
 8012da0:	f7f4 f842 	bl	8006e28 <HAL_ADC_GetValue>
 8012da4:	4603      	mov	r3, r0
 8012da6:	b29b      	uxth	r3, r3
 8012da8:	091b      	lsrs	r3, r3, #4
 8012daa:	b29b      	uxth	r3, r3
 8012dac:	4619      	mov	r1, r3
 8012dae:	683b      	ldr	r3, [r7, #0]
 8012db0:	8a5a      	ldrh	r2, [r3, #18]
 8012db2:	b28b      	uxth	r3, r1
 8012db4:	4413      	add	r3, r2
 8012db6:	b29a      	uxth	r2, r3
 8012db8:	683b      	ldr	r3, [r7, #0]
 8012dba:	825a      	strh	r2, [r3, #18]
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 8012dbc:	687b      	ldr	r3, [r7, #4]
 8012dbe:	681b      	ldr	r3, [r3, #0]
 8012dc0:	f06f 0202 	mvn.w	r2, #2
 8012dc4:	601a      	str	r2, [r3, #0]
	{
		sConfig.Channel = PHASE_B1_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012dc6:	7ffb      	ldrb	r3, [r7, #31]
 8012dc8:	3b01      	subs	r3, #1
 8012dca:	77fb      	strb	r3, [r7, #31]
 8012dcc:	7ffb      	ldrb	r3, [r7, #31]
 8012dce:	2b00      	cmp	r3, #0
 8012dd0:	d1da      	bne.n	8012d88 <ADC_Calibration+0x1f0>
			HAL_ADC_Start(hadc);
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
			QIEMW_ADC_Handle->PhaseB.qI1_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		HAL_ADC_Stop(hadc);
 8012dd2:	6878      	ldr	r0, [r7, #4]
 8012dd4:	f7f3 fee0 	bl	8006b98 <HAL_ADC_Stop>
		
		sConfig.Channel = PHASE_B2_CURRENT_CHANNEL;
 8012dd8:	230c      	movs	r3, #12
 8012dda:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 8012ddc:	2301      	movs	r3, #1
 8012dde:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 8012de0:	2302      	movs	r3, #2
 8012de2:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 8012de4:	f107 030c 	add.w	r3, r7, #12
 8012de8:	6878      	ldr	r0, [r7, #4]
 8012dea:	4619      	mov	r1, r3
 8012dec:	f7f4 f848 	bl	8006e80 <HAL_ADC_ConfigChannel>

		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012df0:	2310      	movs	r3, #16
 8012df2:	77fb      	strb	r3, [r7, #31]
 8012df4:	e021      	b.n	8012e3a <ADC_Calibration+0x2a2>
		{
			HAL_ADC_Start(hadc);
 8012df6:	6878      	ldr	r0, [r7, #4]
 8012df8:	f7f3 fe50 	bl	8006a9c <HAL_ADC_Start>
			
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 8012dfc:	bf00      	nop
 8012dfe:	687b      	ldr	r3, [r7, #4]
 8012e00:	681b      	ldr	r3, [r3, #0]
 8012e02:	681b      	ldr	r3, [r3, #0]
 8012e04:	f003 0302 	and.w	r3, r3, #2
 8012e08:	2b00      	cmp	r3, #0
 8012e0a:	d0f8      	beq.n	8012dfe <ADC_Calibration+0x266>
			
			QIEMW_ADC_Handle->PhaseB.qI2_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 8012e0c:	6878      	ldr	r0, [r7, #4]
 8012e0e:	f7f4 f80b 	bl	8006e28 <HAL_ADC_GetValue>
 8012e12:	4603      	mov	r3, r0
 8012e14:	b29b      	uxth	r3, r3
 8012e16:	091b      	lsrs	r3, r3, #4
 8012e18:	b29b      	uxth	r3, r3
 8012e1a:	4619      	mov	r1, r3
 8012e1c:	683b      	ldr	r3, [r7, #0]
 8012e1e:	8ada      	ldrh	r2, [r3, #22]
 8012e20:	b28b      	uxth	r3, r1
 8012e22:	4413      	add	r3, r2
 8012e24:	b29a      	uxth	r2, r3
 8012e26:	683b      	ldr	r3, [r7, #0]
 8012e28:	82da      	strh	r2, [r3, #22]
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 8012e2a:	687b      	ldr	r3, [r7, #4]
 8012e2c:	681b      	ldr	r3, [r3, #0]
 8012e2e:	f06f 0202 	mvn.w	r2, #2
 8012e32:	601a      	str	r2, [r3, #0]
		sConfig.Channel = PHASE_B2_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);

		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012e34:	7ffb      	ldrb	r3, [r7, #31]
 8012e36:	3b01      	subs	r3, #1
 8012e38:	77fb      	strb	r3, [r7, #31]
 8012e3a:	7ffb      	ldrb	r3, [r7, #31]
 8012e3c:	2b00      	cmp	r3, #0
 8012e3e:	d1da      	bne.n	8012df6 <ADC_Calibration+0x25e>
			
			QIEMW_ADC_Handle->PhaseB.qI2_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_B_VOLTAGE_CHANNEL;
 8012e40:	2304      	movs	r3, #4
 8012e42:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 8012e44:	2301      	movs	r3, #1
 8012e46:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 8012e48:	2302      	movs	r3, #2
 8012e4a:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 8012e4c:	f107 030c 	add.w	r3, r7, #12
 8012e50:	6878      	ldr	r0, [r7, #4]
 8012e52:	4619      	mov	r1, r3
 8012e54:	f7f4 f814 	bl	8006e80 <HAL_ADC_ConfigChannel>

		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012e58:	2310      	movs	r3, #16
 8012e5a:	77fb      	strb	r3, [r7, #31]
 8012e5c:	e026      	b.n	8012eac <ADC_Calibration+0x314>
 8012e5e:	bf00      	nop
 8012e60:	40012000 	.word	0x40012000
 8012e64:	40012100 	.word	0x40012100
		{
			HAL_ADC_Start(hadc);
 8012e68:	6878      	ldr	r0, [r7, #4]
 8012e6a:	f7f3 fe17 	bl	8006a9c <HAL_ADC_Start>
			
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 8012e6e:	bf00      	nop
 8012e70:	687b      	ldr	r3, [r7, #4]
 8012e72:	681b      	ldr	r3, [r3, #0]
 8012e74:	681b      	ldr	r3, [r3, #0]
 8012e76:	f003 0302 	and.w	r3, r3, #2
 8012e7a:	2b00      	cmp	r3, #0
 8012e7c:	d0f8      	beq.n	8012e70 <ADC_Calibration+0x2d8>
			
			QIEMW_ADC_Handle->PhaseB.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 8012e7e:	6878      	ldr	r0, [r7, #4]
 8012e80:	f7f3 ffd2 	bl	8006e28 <HAL_ADC_GetValue>
 8012e84:	4603      	mov	r3, r0
 8012e86:	b29b      	uxth	r3, r3
 8012e88:	091b      	lsrs	r3, r3, #4
 8012e8a:	b29b      	uxth	r3, r3
 8012e8c:	4619      	mov	r1, r3
 8012e8e:	683b      	ldr	r3, [r7, #0]
 8012e90:	8b5a      	ldrh	r2, [r3, #26]
 8012e92:	b28b      	uxth	r3, r1
 8012e94:	4413      	add	r3, r2
 8012e96:	b29a      	uxth	r2, r3
 8012e98:	683b      	ldr	r3, [r7, #0]
 8012e9a:	835a      	strh	r2, [r3, #26]
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 8012e9c:	687b      	ldr	r3, [r7, #4]
 8012e9e:	681b      	ldr	r3, [r3, #0]
 8012ea0:	f06f 0202 	mvn.w	r2, #2
 8012ea4:	601a      	str	r2, [r3, #0]
		sConfig.Channel = PHASE_B_VOLTAGE_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);

		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012ea6:	7ffb      	ldrb	r3, [r7, #31]
 8012ea8:	3b01      	subs	r3, #1
 8012eaa:	77fb      	strb	r3, [r7, #31]
 8012eac:	7ffb      	ldrb	r3, [r7, #31]
 8012eae:	2b00      	cmp	r3, #0
 8012eb0:	d1da      	bne.n	8012e68 <ADC_Calibration+0x2d0>
			
			QIEMW_ADC_Handle->PhaseB.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_BUS_CURRENT_CHANNEL;
 8012eb2:	230a      	movs	r3, #10
 8012eb4:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 8012eb6:	2301      	movs	r3, #1
 8012eb8:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 8012eba:	2302      	movs	r3, #2
 8012ebc:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 8012ebe:	f107 030c 	add.w	r3, r7, #12
 8012ec2:	6878      	ldr	r0, [r7, #4]
 8012ec4:	4619      	mov	r1, r3
 8012ec6:	f7f3 ffdb 	bl	8006e80 <HAL_ADC_ConfigChannel>

		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012eca:	2310      	movs	r3, #16
 8012ecc:	77fb      	strb	r3, [r7, #31]
 8012ece:	e021      	b.n	8012f14 <ADC_Calibration+0x37c>
		{
			HAL_ADC_Start(hadc);
 8012ed0:	6878      	ldr	r0, [r7, #4]
 8012ed2:	f7f3 fde3 	bl	8006a9c <HAL_ADC_Start>
			
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 8012ed6:	bf00      	nop
 8012ed8:	687b      	ldr	r3, [r7, #4]
 8012eda:	681b      	ldr	r3, [r3, #0]
 8012edc:	681b      	ldr	r3, [r3, #0]
 8012ede:	f003 0302 	and.w	r3, r3, #2
 8012ee2:	2b00      	cmp	r3, #0
 8012ee4:	d0f8      	beq.n	8012ed8 <ADC_Calibration+0x340>
			QIEMW_ADC_Handle->BUS.qI_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 8012ee6:	6878      	ldr	r0, [r7, #4]
 8012ee8:	f7f3 ff9e 	bl	8006e28 <HAL_ADC_GetValue>
 8012eec:	4603      	mov	r3, r0
 8012eee:	b29b      	uxth	r3, r3
 8012ef0:	091b      	lsrs	r3, r3, #4
 8012ef2:	b29b      	uxth	r3, r3
 8012ef4:	4619      	mov	r1, r3
 8012ef6:	683b      	ldr	r3, [r7, #0]
 8012ef8:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 8012efa:	b28b      	uxth	r3, r1
 8012efc:	4413      	add	r3, r2
 8012efe:	b29a      	uxth	r2, r3
 8012f00:	683b      	ldr	r3, [r7, #0]
 8012f02:	859a      	strh	r2, [r3, #44]	; 0x2c
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 8012f04:	687b      	ldr	r3, [r7, #4]
 8012f06:	681b      	ldr	r3, [r3, #0]
 8012f08:	f06f 0202 	mvn.w	r2, #2
 8012f0c:	601a      	str	r2, [r3, #0]
		sConfig.Channel = PHASE_BUS_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);

		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012f0e:	7ffb      	ldrb	r3, [r7, #31]
 8012f10:	3b01      	subs	r3, #1
 8012f12:	77fb      	strb	r3, [r7, #31]
 8012f14:	7ffb      	ldrb	r3, [r7, #31]
 8012f16:	2b00      	cmp	r3, #0
 8012f18:	d1da      	bne.n	8012ed0 <ADC_Calibration+0x338>
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
	}

	if(hadc->Instance == ADC3)
 8012f1a:	687b      	ldr	r3, [r7, #4]
 8012f1c:	681b      	ldr	r3, [r3, #0]
 8012f1e:	4a6b      	ldr	r2, [pc, #428]	; (80130cc <ADC_Calibration+0x534>)
 8012f20:	4293      	cmp	r3, r2
 8012f22:	f040 80d0 	bne.w	80130c6 <ADC_Calibration+0x52e>
	{
		sConfig.Channel = PHASE_A1_CURRENT_CHANNEL;
 8012f26:	2305      	movs	r3, #5
 8012f28:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 8012f2a:	2301      	movs	r3, #1
 8012f2c:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 8012f2e:	2302      	movs	r3, #2
 8012f30:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 8012f32:	f107 030c 	add.w	r3, r7, #12
 8012f36:	6878      	ldr	r0, [r7, #4]
 8012f38:	4619      	mov	r1, r3
 8012f3a:	f7f3 ffa1 	bl	8006e80 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012f3e:	2310      	movs	r3, #16
 8012f40:	77fb      	strb	r3, [r7, #31]
 8012f42:	e021      	b.n	8012f88 <ADC_Calibration+0x3f0>
		{
			HAL_ADC_Start(hadc);
 8012f44:	6878      	ldr	r0, [r7, #4]
 8012f46:	f7f3 fda9 	bl	8006a9c <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 8012f4a:	bf00      	nop
 8012f4c:	687b      	ldr	r3, [r7, #4]
 8012f4e:	681b      	ldr	r3, [r3, #0]
 8012f50:	681b      	ldr	r3, [r3, #0]
 8012f52:	f003 0302 	and.w	r3, r3, #2
 8012f56:	2b00      	cmp	r3, #0
 8012f58:	d0f8      	beq.n	8012f4c <ADC_Calibration+0x3b4>
			QIEMW_ADC_Handle->PhaseA.qI1_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 8012f5a:	6878      	ldr	r0, [r7, #4]
 8012f5c:	f7f3 ff64 	bl	8006e28 <HAL_ADC_GetValue>
 8012f60:	4603      	mov	r3, r0
 8012f62:	b29b      	uxth	r3, r3
 8012f64:	091b      	lsrs	r3, r3, #4
 8012f66:	b29b      	uxth	r3, r3
 8012f68:	4619      	mov	r1, r3
 8012f6a:	683b      	ldr	r3, [r7, #0]
 8012f6c:	889a      	ldrh	r2, [r3, #4]
 8012f6e:	b28b      	uxth	r3, r1
 8012f70:	4413      	add	r3, r2
 8012f72:	b29a      	uxth	r2, r3
 8012f74:	683b      	ldr	r3, [r7, #0]
 8012f76:	809a      	strh	r2, [r3, #4]
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 8012f78:	687b      	ldr	r3, [r7, #4]
 8012f7a:	681b      	ldr	r3, [r3, #0]
 8012f7c:	f06f 0202 	mvn.w	r2, #2
 8012f80:	601a      	str	r2, [r3, #0]
	{
		sConfig.Channel = PHASE_A1_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012f82:	7ffb      	ldrb	r3, [r7, #31]
 8012f84:	3b01      	subs	r3, #1
 8012f86:	77fb      	strb	r3, [r7, #31]
 8012f88:	7ffb      	ldrb	r3, [r7, #31]
 8012f8a:	2b00      	cmp	r3, #0
 8012f8c:	d1da      	bne.n	8012f44 <ADC_Calibration+0x3ac>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
			QIEMW_ADC_Handle->PhaseA.qI1_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_A2_CURRENT_CHANNEL;
 8012f8e:	2306      	movs	r3, #6
 8012f90:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 8012f92:	2301      	movs	r3, #1
 8012f94:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 8012f96:	2302      	movs	r3, #2
 8012f98:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 8012f9a:	f107 030c 	add.w	r3, r7, #12
 8012f9e:	6878      	ldr	r0, [r7, #4]
 8012fa0:	4619      	mov	r1, r3
 8012fa2:	f7f3 ff6d 	bl	8006e80 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012fa6:	2310      	movs	r3, #16
 8012fa8:	77fb      	strb	r3, [r7, #31]
 8012faa:	e021      	b.n	8012ff0 <ADC_Calibration+0x458>
		{
			HAL_ADC_Start(hadc);
 8012fac:	6878      	ldr	r0, [r7, #4]
 8012fae:	f7f3 fd75 	bl	8006a9c <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 8012fb2:	bf00      	nop
 8012fb4:	687b      	ldr	r3, [r7, #4]
 8012fb6:	681b      	ldr	r3, [r3, #0]
 8012fb8:	681b      	ldr	r3, [r3, #0]
 8012fba:	f003 0302 	and.w	r3, r3, #2
 8012fbe:	2b00      	cmp	r3, #0
 8012fc0:	d0f8      	beq.n	8012fb4 <ADC_Calibration+0x41c>
			QIEMW_ADC_Handle->PhaseA.qI2_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 8012fc2:	6878      	ldr	r0, [r7, #4]
 8012fc4:	f7f3 ff30 	bl	8006e28 <HAL_ADC_GetValue>
 8012fc8:	4603      	mov	r3, r0
 8012fca:	b29b      	uxth	r3, r3
 8012fcc:	091b      	lsrs	r3, r3, #4
 8012fce:	b29b      	uxth	r3, r3
 8012fd0:	4619      	mov	r1, r3
 8012fd2:	683b      	ldr	r3, [r7, #0]
 8012fd4:	891a      	ldrh	r2, [r3, #8]
 8012fd6:	b28b      	uxth	r3, r1
 8012fd8:	4413      	add	r3, r2
 8012fda:	b29a      	uxth	r2, r3
 8012fdc:	683b      	ldr	r3, [r7, #0]
 8012fde:	811a      	strh	r2, [r3, #8]
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 8012fe0:	687b      	ldr	r3, [r7, #4]
 8012fe2:	681b      	ldr	r3, [r3, #0]
 8012fe4:	f06f 0202 	mvn.w	r2, #2
 8012fe8:	601a      	str	r2, [r3, #0]
		}
		sConfig.Channel = PHASE_A2_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012fea:	7ffb      	ldrb	r3, [r7, #31]
 8012fec:	3b01      	subs	r3, #1
 8012fee:	77fb      	strb	r3, [r7, #31]
 8012ff0:	7ffb      	ldrb	r3, [r7, #31]
 8012ff2:	2b00      	cmp	r3, #0
 8012ff4:	d1da      	bne.n	8012fac <ADC_Calibration+0x414>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
			QIEMW_ADC_Handle->PhaseA.qI2_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_A_VOLTAGE_CHANNEL;
 8012ff6:	2307      	movs	r3, #7
 8012ff8:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 8012ffa:	2301      	movs	r3, #1
 8012ffc:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 8012ffe:	2302      	movs	r3, #2
 8013000:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 8013002:	f107 030c 	add.w	r3, r7, #12
 8013006:	6878      	ldr	r0, [r7, #4]
 8013008:	4619      	mov	r1, r3
 801300a:	f7f3 ff39 	bl	8006e80 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 801300e:	2310      	movs	r3, #16
 8013010:	77fb      	strb	r3, [r7, #31]
 8013012:	e021      	b.n	8013058 <ADC_Calibration+0x4c0>
		{
			HAL_ADC_Start(hadc);
 8013014:	6878      	ldr	r0, [r7, #4]
 8013016:	f7f3 fd41 	bl	8006a9c <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 801301a:	bf00      	nop
 801301c:	687b      	ldr	r3, [r7, #4]
 801301e:	681b      	ldr	r3, [r3, #0]
 8013020:	681b      	ldr	r3, [r3, #0]
 8013022:	f003 0302 	and.w	r3, r3, #2
 8013026:	2b00      	cmp	r3, #0
 8013028:	d0f8      	beq.n	801301c <ADC_Calibration+0x484>
			QIEMW_ADC_Handle->PhaseA.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 801302a:	6878      	ldr	r0, [r7, #4]
 801302c:	f7f3 fefc 	bl	8006e28 <HAL_ADC_GetValue>
 8013030:	4603      	mov	r3, r0
 8013032:	b29b      	uxth	r3, r3
 8013034:	091b      	lsrs	r3, r3, #4
 8013036:	b29b      	uxth	r3, r3
 8013038:	4619      	mov	r1, r3
 801303a:	683b      	ldr	r3, [r7, #0]
 801303c:	899a      	ldrh	r2, [r3, #12]
 801303e:	b28b      	uxth	r3, r1
 8013040:	4413      	add	r3, r2
 8013042:	b29a      	uxth	r2, r3
 8013044:	683b      	ldr	r3, [r7, #0]
 8013046:	819a      	strh	r2, [r3, #12]
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 8013048:	687b      	ldr	r3, [r7, #4]
 801304a:	681b      	ldr	r3, [r3, #0]
 801304c:	f06f 0202 	mvn.w	r2, #2
 8013050:	601a      	str	r2, [r3, #0]
		}
		sConfig.Channel = PHASE_A_VOLTAGE_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8013052:	7ffb      	ldrb	r3, [r7, #31]
 8013054:	3b01      	subs	r3, #1
 8013056:	77fb      	strb	r3, [r7, #31]
 8013058:	7ffb      	ldrb	r3, [r7, #31]
 801305a:	2b00      	cmp	r3, #0
 801305c:	d1da      	bne.n	8013014 <ADC_Calibration+0x47c>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
			QIEMW_ADC_Handle->PhaseA.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_BUS_VOLTAGE_CHANNEL;
 801305e:	2304      	movs	r3, #4
 8013060:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 8013062:	2301      	movs	r3, #1
 8013064:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 8013066:	2302      	movs	r3, #2
 8013068:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 801306a:	f107 030c 	add.w	r3, r7, #12
 801306e:	6878      	ldr	r0, [r7, #4]
 8013070:	4619      	mov	r1, r3
 8013072:	f7f3 ff05 	bl	8006e80 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8013076:	2310      	movs	r3, #16
 8013078:	77fb      	strb	r3, [r7, #31]
 801307a:	e021      	b.n	80130c0 <ADC_Calibration+0x528>
		{
			HAL_ADC_Start(hadc);
 801307c:	6878      	ldr	r0, [r7, #4]
 801307e:	f7f3 fd0d 	bl	8006a9c <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 8013082:	bf00      	nop
 8013084:	687b      	ldr	r3, [r7, #4]
 8013086:	681b      	ldr	r3, [r3, #0]
 8013088:	681b      	ldr	r3, [r3, #0]
 801308a:	f003 0302 	and.w	r3, r3, #2
 801308e:	2b00      	cmp	r3, #0
 8013090:	d0f8      	beq.n	8013084 <ADC_Calibration+0x4ec>
			QIEMW_ADC_Handle->BUS.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 8013092:	6878      	ldr	r0, [r7, #4]
 8013094:	f7f3 fec8 	bl	8006e28 <HAL_ADC_GetValue>
 8013098:	4603      	mov	r3, r0
 801309a:	b29b      	uxth	r3, r3
 801309c:	091b      	lsrs	r3, r3, #4
 801309e:	b29b      	uxth	r3, r3
 80130a0:	4619      	mov	r1, r3
 80130a2:	683b      	ldr	r3, [r7, #0]
 80130a4:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
 80130a6:	b28b      	uxth	r3, r1
 80130a8:	4413      	add	r3, r2
 80130aa:	b29a      	uxth	r2, r3
 80130ac:	683b      	ldr	r3, [r7, #0]
 80130ae:	861a      	strh	r2, [r3, #48]	; 0x30
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 80130b0:	687b      	ldr	r3, [r7, #4]
 80130b2:	681b      	ldr	r3, [r3, #0]
 80130b4:	f06f 0202 	mvn.w	r2, #2
 80130b8:	601a      	str	r2, [r3, #0]
		}
		sConfig.Channel = PHASE_BUS_VOLTAGE_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 80130ba:	7ffb      	ldrb	r3, [r7, #31]
 80130bc:	3b01      	subs	r3, #1
 80130be:	77fb      	strb	r3, [r7, #31]
 80130c0:	7ffb      	ldrb	r3, [r7, #31]
 80130c2:	2b00      	cmp	r3, #0
 80130c4:	d1da      	bne.n	801307c <ADC_Calibration+0x4e4>
			QIEMW_ADC_Handle->BUS.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
	}
}
 80130c6:	3720      	adds	r7, #32
 80130c8:	46bd      	mov	sp, r7
 80130ca:	bd80      	pop	{r7, pc}
 80130cc:	40012200 	.word	0x40012200

080130d0 <HAL_ADCEx_InjectedConvCpltCallback>:



void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef* hadc)
{
 80130d0:	b580      	push	{r7, lr}
 80130d2:	b082      	sub	sp, #8
 80130d4:	af00      	add	r7, sp, #0
 80130d6:	6078      	str	r0, [r7, #4]
	hadc->Instance = ADC1;
 80130d8:	687b      	ldr	r3, [r7, #4]
 80130da:	4a8f      	ldr	r2, [pc, #572]	; (8013318 <HAL_ADCEx_InjectedConvCpltCallback+0x248>)
 80130dc:	601a      	str	r2, [r3, #0]
	Global_User_ADC.PhaseC.qI1_value = (s16)(HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_1));
 80130de:	6878      	ldr	r0, [r7, #4]
 80130e0:	2101      	movs	r1, #1
 80130e2:	f7f4 f9d7 	bl	8007494 <HAL_ADCEx_InjectedGetValue>
 80130e6:	4603      	mov	r3, r0
 80130e8:	b29a      	uxth	r2, r3
 80130ea:	4b8c      	ldr	r3, [pc, #560]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 80130ec:	839a      	strh	r2, [r3, #28]
	Global_User_ADC.PhaseC.qI2_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_2);
 80130ee:	6878      	ldr	r0, [r7, #4]
 80130f0:	2102      	movs	r1, #2
 80130f2:	f7f4 f9cf 	bl	8007494 <HAL_ADCEx_InjectedGetValue>
 80130f6:	4603      	mov	r3, r0
 80130f8:	b29a      	uxth	r2, r3
 80130fa:	4b88      	ldr	r3, [pc, #544]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 80130fc:	845a      	strh	r2, [r3, #34]	; 0x22
	Global_User_ADC.PhaseC.qV_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_3);
 80130fe:	6878      	ldr	r0, [r7, #4]
 8013100:	2103      	movs	r1, #3
 8013102:	f7f4 f9c7 	bl	8007494 <HAL_ADCEx_InjectedGetValue>
 8013106:	4603      	mov	r3, r0
 8013108:	b29a      	uxth	r2, r3
 801310a:	4b84      	ldr	r3, [pc, #528]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 801310c:	84da      	strh	r2, [r3, #38]	; 0x26
	Global_User_ADC.Temp.TEMP_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_4);
 801310e:	6878      	ldr	r0, [r7, #4]
 8013110:	2104      	movs	r1, #4
 8013112:	f7f4 f9bf 	bl	8007494 <HAL_ADCEx_InjectedGetValue>
 8013116:	4603      	mov	r3, r0
 8013118:	b29a      	uxth	r2, r3
 801311a:	4b80      	ldr	r3, [pc, #512]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 801311c:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
	hadc->Instance = ADC2;
 8013120:	687b      	ldr	r3, [r7, #4]
 8013122:	4a7f      	ldr	r2, [pc, #508]	; (8013320 <HAL_ADCEx_InjectedConvCpltCallback+0x250>)
 8013124:	601a      	str	r2, [r3, #0]
	Global_User_ADC.PhaseB.qI1_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_1);
 8013126:	6878      	ldr	r0, [r7, #4]
 8013128:	2101      	movs	r1, #1
 801312a:	f7f4 f9b3 	bl	8007494 <HAL_ADCEx_InjectedGetValue>
 801312e:	4603      	mov	r3, r0
 8013130:	b29a      	uxth	r2, r3
 8013132:	4b7a      	ldr	r3, [pc, #488]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8013134:	81da      	strh	r2, [r3, #14]
	Global_User_ADC.PhaseB.qI2_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_2);
 8013136:	6878      	ldr	r0, [r7, #4]
 8013138:	2102      	movs	r1, #2
 801313a:	f7f4 f9ab 	bl	8007494 <HAL_ADCEx_InjectedGetValue>
 801313e:	4603      	mov	r3, r0
 8013140:	b29a      	uxth	r2, r3
 8013142:	4b76      	ldr	r3, [pc, #472]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8013144:	829a      	strh	r2, [r3, #20]
	Global_User_ADC.PhaseB.qV_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_3);
 8013146:	6878      	ldr	r0, [r7, #4]
 8013148:	2103      	movs	r1, #3
 801314a:	f7f4 f9a3 	bl	8007494 <HAL_ADCEx_InjectedGetValue>
 801314e:	4603      	mov	r3, r0
 8013150:	b29a      	uxth	r2, r3
 8013152:	4b72      	ldr	r3, [pc, #456]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8013154:	831a      	strh	r2, [r3, #24]
	Global_User_ADC.BUS.qI_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_4);
 8013156:	6878      	ldr	r0, [r7, #4]
 8013158:	2104      	movs	r1, #4
 801315a:	f7f4 f99b 	bl	8007494 <HAL_ADCEx_InjectedGetValue>
 801315e:	4603      	mov	r3, r0
 8013160:	b29a      	uxth	r2, r3
 8013162:	4b6e      	ldr	r3, [pc, #440]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8013164:	855a      	strh	r2, [r3, #42]	; 0x2a
	hadc->Instance = ADC3;
 8013166:	687b      	ldr	r3, [r7, #4]
 8013168:	4a6e      	ldr	r2, [pc, #440]	; (8013324 <HAL_ADCEx_InjectedConvCpltCallback+0x254>)
 801316a:	601a      	str	r2, [r3, #0]
	Global_User_ADC.PhaseA.qI1_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_1);
 801316c:	6878      	ldr	r0, [r7, #4]
 801316e:	2101      	movs	r1, #1
 8013170:	f7f4 f990 	bl	8007494 <HAL_ADCEx_InjectedGetValue>
 8013174:	4603      	mov	r3, r0
 8013176:	b29a      	uxth	r2, r3
 8013178:	4b68      	ldr	r3, [pc, #416]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 801317a:	801a      	strh	r2, [r3, #0]
	Global_User_ADC.PhaseA.qI2_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_2);
 801317c:	6878      	ldr	r0, [r7, #4]
 801317e:	2102      	movs	r1, #2
 8013180:	f7f4 f988 	bl	8007494 <HAL_ADCEx_InjectedGetValue>
 8013184:	4603      	mov	r3, r0
 8013186:	b29a      	uxth	r2, r3
 8013188:	4b64      	ldr	r3, [pc, #400]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 801318a:	80da      	strh	r2, [r3, #6]
	Global_User_ADC.PhaseA.qV_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_3);
 801318c:	6878      	ldr	r0, [r7, #4]
 801318e:	2103      	movs	r1, #3
 8013190:	f7f4 f980 	bl	8007494 <HAL_ADCEx_InjectedGetValue>
 8013194:	4603      	mov	r3, r0
 8013196:	b29a      	uxth	r2, r3
 8013198:	4b60      	ldr	r3, [pc, #384]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 801319a:	815a      	strh	r2, [r3, #10]
	Global_User_ADC.BUS.qV_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_4);
 801319c:	6878      	ldr	r0, [r7, #4]
 801319e:	2104      	movs	r1, #4
 80131a0:	f7f4 f978 	bl	8007494 <HAL_ADCEx_InjectedGetValue>
 80131a4:	4603      	mov	r3, r0
 80131a6:	b29a      	uxth	r2, r3
 80131a8:	4b5c      	ldr	r3, [pc, #368]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 80131aa:	85da      	strh	r2, [r3, #46]	; 0x2e

	Global_User_ADC.PhaseC.qI_value = (s16)(((s32)Global_User_ADC.PhaseC.qI1_value + (s32)Global_User_ADC.PhaseC.qI2_value) >> 1);
 80131ac:	4b5b      	ldr	r3, [pc, #364]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 80131ae:	8b9b      	ldrh	r3, [r3, #28]
 80131b0:	b21a      	sxth	r2, r3
 80131b2:	4b5a      	ldr	r3, [pc, #360]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 80131b4:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 80131b6:	b21b      	sxth	r3, r3
 80131b8:	4413      	add	r3, r2
 80131ba:	105b      	asrs	r3, r3, #1
 80131bc:	b29a      	uxth	r2, r3
 80131be:	4b57      	ldr	r3, [pc, #348]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 80131c0:	83da      	strh	r2, [r3, #30]
	Global_User_ADC.PhaseB.qI_value = (s16)(((s32)Global_User_ADC.PhaseB.qI1_value + (s32)Global_User_ADC.PhaseB.qI2_value) >> 1);
 80131c2:	4b56      	ldr	r3, [pc, #344]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 80131c4:	89db      	ldrh	r3, [r3, #14]
 80131c6:	b21a      	sxth	r2, r3
 80131c8:	4b54      	ldr	r3, [pc, #336]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 80131ca:	8a9b      	ldrh	r3, [r3, #20]
 80131cc:	b21b      	sxth	r3, r3
 80131ce:	4413      	add	r3, r2
 80131d0:	105b      	asrs	r3, r3, #1
 80131d2:	b29a      	uxth	r2, r3
 80131d4:	4b51      	ldr	r3, [pc, #324]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 80131d6:	821a      	strh	r2, [r3, #16]
	Global_User_ADC.PhaseA.qI_value = (s16)(((s32)Global_User_ADC.PhaseA.qI1_value + (s32)Global_User_ADC.PhaseA.qI2_value) >> 1);
 80131d8:	4b50      	ldr	r3, [pc, #320]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 80131da:	881b      	ldrh	r3, [r3, #0]
 80131dc:	b21a      	sxth	r2, r3
 80131de:	4b4f      	ldr	r3, [pc, #316]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 80131e0:	88db      	ldrh	r3, [r3, #6]
 80131e2:	b21b      	sxth	r3, r3
 80131e4:	4413      	add	r3, r2
 80131e6:	105b      	asrs	r3, r3, #1
 80131e8:	b29a      	uxth	r2, r3
 80131ea:	4b4c      	ldr	r3, [pc, #304]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 80131ec:	805a      	strh	r2, [r3, #2]
	
	//! \Add By Dl.K
	static HAL_AdcData_t sHal_AdcData;
	static HAL_PwmData_t sHal_PwmData;
	static HAL_QepData_t sHal_QepData;
	sHal_AdcData.I.value[0] = Global_User_ADC.PhaseA.qI_value;
 80131ee:	4b4b      	ldr	r3, [pc, #300]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 80131f0:	885b      	ldrh	r3, [r3, #2]
 80131f2:	b21b      	sxth	r3, r3
 80131f4:	ee07 3a90 	vmov	s15, r3
 80131f8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80131fc:	4b4a      	ldr	r3, [pc, #296]	; (8013328 <HAL_ADCEx_InjectedConvCpltCallback+0x258>)
 80131fe:	edc3 7a00 	vstr	s15, [r3]
	sHal_AdcData.I.value[1] = Global_User_ADC.PhaseB.qI_value;
 8013202:	4b46      	ldr	r3, [pc, #280]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8013204:	8a1b      	ldrh	r3, [r3, #16]
 8013206:	b21b      	sxth	r3, r3
 8013208:	ee07 3a90 	vmov	s15, r3
 801320c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013210:	4b45      	ldr	r3, [pc, #276]	; (8013328 <HAL_ADCEx_InjectedConvCpltCallback+0x258>)
 8013212:	edc3 7a01 	vstr	s15, [r3, #4]
	sHal_AdcData.I.value[2] = Global_User_ADC.PhaseC.qI_value;
 8013216:	4b41      	ldr	r3, [pc, #260]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8013218:	8bdb      	ldrh	r3, [r3, #30]
 801321a:	b21b      	sxth	r3, r3
 801321c:	ee07 3a90 	vmov	s15, r3
 8013220:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013224:	4b40      	ldr	r3, [pc, #256]	; (8013328 <HAL_ADCEx_InjectedConvCpltCallback+0x258>)
 8013226:	edc3 7a02 	vstr	s15, [r3, #8]
	sHal_AdcData.IdcBus = Global_User_ADC.BUS.qI_value;
 801322a:	4b3c      	ldr	r3, [pc, #240]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 801322c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 801322e:	b21b      	sxth	r3, r3
 8013230:	ee07 3a90 	vmov	s15, r3
 8013234:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013238:	4b3b      	ldr	r3, [pc, #236]	; (8013328 <HAL_ADCEx_InjectedConvCpltCallback+0x258>)
 801323a:	edc3 7a07 	vstr	s15, [r3, #28]
	sHal_AdcData.V.value[0] = Global_User_ADC.PhaseA.qV_value;
 801323e:	4b37      	ldr	r3, [pc, #220]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8013240:	895b      	ldrh	r3, [r3, #10]
 8013242:	b21b      	sxth	r3, r3
 8013244:	ee07 3a90 	vmov	s15, r3
 8013248:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801324c:	4b36      	ldr	r3, [pc, #216]	; (8013328 <HAL_ADCEx_InjectedConvCpltCallback+0x258>)
 801324e:	edc3 7a03 	vstr	s15, [r3, #12]
	sHal_AdcData.V.value[1] = Global_User_ADC.PhaseB.qV_value;
 8013252:	4b32      	ldr	r3, [pc, #200]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8013254:	8b1b      	ldrh	r3, [r3, #24]
 8013256:	b21b      	sxth	r3, r3
 8013258:	ee07 3a90 	vmov	s15, r3
 801325c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013260:	4b31      	ldr	r3, [pc, #196]	; (8013328 <HAL_ADCEx_InjectedConvCpltCallback+0x258>)
 8013262:	edc3 7a04 	vstr	s15, [r3, #16]
	sHal_AdcData.V.value[2] = Global_User_ADC.PhaseC.qV_value;
 8013266:	4b2d      	ldr	r3, [pc, #180]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8013268:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 801326a:	b21b      	sxth	r3, r3
 801326c:	ee07 3a90 	vmov	s15, r3
 8013270:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013274:	4b2c      	ldr	r3, [pc, #176]	; (8013328 <HAL_ADCEx_InjectedConvCpltCallback+0x258>)
 8013276:	edc3 7a05 	vstr	s15, [r3, #20]
	sHal_AdcData.VdcBus = Global_User_ADC.BUS.qV_value;
 801327a:	4b28      	ldr	r3, [pc, #160]	; (801331c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 801327c:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 801327e:	b21b      	sxth	r3, r3
 8013280:	ee07 3a90 	vmov	s15, r3
 8013284:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013288:	4b27      	ldr	r3, [pc, #156]	; (8013328 <HAL_ADCEx_InjectedConvCpltCallback+0x258>)
 801328a:	edc3 7a06 	vstr	s15, [r3, #24]
	sHal_QepData.qep_cnt = (float_t)(4*4*ENCODER_PPR-1-GetCounterValue(TIM5))/(4.0f*ENCODER_PPR*4.0f);
 801328e:	4827      	ldr	r0, [pc, #156]	; (801332c <HAL_ADCEx_InjectedConvCpltCallback+0x25c>)
 8013290:	f000 fb86 	bl	80139a0 <GetCounterValue>
 8013294:	4603      	mov	r3, r0
 8013296:	461a      	mov	r2, r3
 8013298:	f643 73ff 	movw	r3, #16383	; 0x3fff
 801329c:	1a9b      	subs	r3, r3, r2
 801329e:	ee07 3a90 	vmov	s15, r3
 80132a2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80132a6:	ed9f 7a22 	vldr	s14, [pc, #136]	; 8013330 <HAL_ADCEx_InjectedConvCpltCallback+0x260>
 80132aa:	eec7 7a87 	vdiv.f32	s15, s15, s14
 80132ae:	4b21      	ldr	r3, [pc, #132]	; (8013334 <HAL_ADCEx_InjectedConvCpltCallback+0x264>)
 80132b0:	edc3 7a00 	vstr	s15, [r3]
	Motor_Ctrl_Run(&sHal_AdcData, &sHal_PwmData, &sHal_QepData);
 80132b4:	481c      	ldr	r0, [pc, #112]	; (8013328 <HAL_ADCEx_InjectedConvCpltCallback+0x258>)
 80132b6:	4920      	ldr	r1, [pc, #128]	; (8013338 <HAL_ADCEx_InjectedConvCpltCallback+0x268>)
 80132b8:	4a1e      	ldr	r2, [pc, #120]	; (8013334 <HAL_ADCEx_InjectedConvCpltCallback+0x264>)
 80132ba:	f7ef fa57 	bl	800276c <Motor_Ctrl_Run>
	SetDutyCycles(TIM8, sHal_PwmData.Tabc.value[0]*(float)PWM_PERIOD, 
 80132be:	4b1e      	ldr	r3, [pc, #120]	; (8013338 <HAL_ADCEx_InjectedConvCpltCallback+0x268>)
 80132c0:	edd3 7a00 	vldr	s15, [r3]
 80132c4:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 801333c <HAL_ADCEx_InjectedConvCpltCallback+0x26c>
 80132c8:	ee67 7a87 	vmul.f32	s15, s15, s14
 80132cc:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80132d0:	edc7 7a00 	vstr	s15, [r7]
 80132d4:	883b      	ldrh	r3, [r7, #0]
 80132d6:	b299      	uxth	r1, r3
											sHal_PwmData.Tabc.value[1]*(float)PWM_PERIOD, 
 80132d8:	4b17      	ldr	r3, [pc, #92]	; (8013338 <HAL_ADCEx_InjectedConvCpltCallback+0x268>)
 80132da:	edd3 7a01 	vldr	s15, [r3, #4]
 80132de:	ed9f 7a17 	vldr	s14, [pc, #92]	; 801333c <HAL_ADCEx_InjectedConvCpltCallback+0x26c>
 80132e2:	ee67 7a87 	vmul.f32	s15, s15, s14
	sHal_AdcData.V.value[1] = Global_User_ADC.PhaseB.qV_value;
	sHal_AdcData.V.value[2] = Global_User_ADC.PhaseC.qV_value;
	sHal_AdcData.VdcBus = Global_User_ADC.BUS.qV_value;
	sHal_QepData.qep_cnt = (float_t)(4*4*ENCODER_PPR-1-GetCounterValue(TIM5))/(4.0f*ENCODER_PPR*4.0f);
	Motor_Ctrl_Run(&sHal_AdcData, &sHal_PwmData, &sHal_QepData);
	SetDutyCycles(TIM8, sHal_PwmData.Tabc.value[0]*(float)PWM_PERIOD, 
 80132e6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80132ea:	edc7 7a00 	vstr	s15, [r7]
 80132ee:	883b      	ldrh	r3, [r7, #0]
 80132f0:	b29a      	uxth	r2, r3
											sHal_PwmData.Tabc.value[1]*(float)PWM_PERIOD, 
											sHal_PwmData.Tabc.value[2]*(float)PWM_PERIOD);
 80132f2:	4b11      	ldr	r3, [pc, #68]	; (8013338 <HAL_ADCEx_InjectedConvCpltCallback+0x268>)
 80132f4:	edd3 7a02 	vldr	s15, [r3, #8]
 80132f8:	ed9f 7a10 	vldr	s14, [pc, #64]	; 801333c <HAL_ADCEx_InjectedConvCpltCallback+0x26c>
 80132fc:	ee67 7a87 	vmul.f32	s15, s15, s14
	sHal_AdcData.V.value[1] = Global_User_ADC.PhaseB.qV_value;
	sHal_AdcData.V.value[2] = Global_User_ADC.PhaseC.qV_value;
	sHal_AdcData.VdcBus = Global_User_ADC.BUS.qV_value;
	sHal_QepData.qep_cnt = (float_t)(4*4*ENCODER_PPR-1-GetCounterValue(TIM5))/(4.0f*ENCODER_PPR*4.0f);
	Motor_Ctrl_Run(&sHal_AdcData, &sHal_PwmData, &sHal_QepData);
	SetDutyCycles(TIM8, sHal_PwmData.Tabc.value[0]*(float)PWM_PERIOD, 
 8013300:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8013304:	edc7 7a00 	vstr	s15, [r7]
 8013308:	883b      	ldrh	r3, [r7, #0]
 801330a:	b29b      	uxth	r3, r3
 801330c:	480c      	ldr	r0, [pc, #48]	; (8013340 <HAL_ADCEx_InjectedConvCpltCallback+0x270>)
 801330e:	f000 fec9 	bl	80140a4 <SetDutyCycles>
	{
		i = 0;
		myprintf("123456789012\r\n", 15);
	}
	#endif
}
 8013312:	3708      	adds	r7, #8
 8013314:	46bd      	mov	sp, r7
 8013316:	bd80      	pop	{r7, pc}
 8013318:	40012000 	.word	0x40012000
 801331c:	200128c0 	.word	0x200128c0
 8013320:	40012100 	.word	0x40012100
 8013324:	40012200 	.word	0x40012200
 8013328:	20010800 	.word	0x20010800
 801332c:	40000c00 	.word	0x40000c00
 8013330:	46800000 	.word	0x46800000
 8013334:	20010820 	.word	0x20010820
 8013338:	20010824 	.word	0x20010824
 801333c:	45960000 	.word	0x45960000
 8013340:	40010400 	.word	0x40010400

08013344 <settestpin>:

void settestpin(void)
{
 8013344:	b580      	push	{r7, lr}
 8013346:	af00      	add	r7, sp, #0

	HAL_GPIO_WritePin(GPIOI,GPIO_PIN_3, GPIO_PIN_SET);
 8013348:	4802      	ldr	r0, [pc, #8]	; (8013354 <settestpin+0x10>)
 801334a:	2108      	movs	r1, #8
 801334c:	2201      	movs	r2, #1
 801334e:	f7fa faf5 	bl	800d93c <HAL_GPIO_WritePin>
}
 8013352:	bd80      	pop	{r7, pc}
 8013354:	40022000 	.word	0x40022000

08013358 <cleartestpin>:

void cleartestpin(void)
{
 8013358:	b580      	push	{r7, lr}
 801335a:	af00      	add	r7, sp, #0
	HAL_GPIO_WritePin(GPIOI,GPIO_PIN_3, GPIO_PIN_RESET);
 801335c:	4802      	ldr	r0, [pc, #8]	; (8013368 <cleartestpin+0x10>)
 801335e:	2108      	movs	r1, #8
 8013360:	2200      	movs	r2, #0
 8013362:	f7fa faeb 	bl	800d93c <HAL_GPIO_WritePin>
}
 8013366:	bd80      	pop	{r7, pc}
 8013368:	40022000 	.word	0x40022000

0801336c <ADC_IRQHandler>:

void ADC_IRQHandler(void)
{
 801336c:	b580      	push	{r7, lr}
 801336e:	b092      	sub	sp, #72	; 0x48
 8013370:	af00      	add	r7, sp, #0
	ADC_HandleTypeDef ADC_handle;

    /* enter interrupt */
    rt_interrupt_enter();
 8013372:	f003 fc93 	bl	8016c9c <rt_interrupt_enter>
	//HAL_GPIO_WritePin(GPIOI,GPIO_PIN_3, GPIO_PIN_SET);

	ADC_handle.Instance = ADC1;
 8013376:	4b05      	ldr	r3, [pc, #20]	; (801338c <ADC_IRQHandler+0x20>)
 8013378:	607b      	str	r3, [r7, #4]
	HAL_ADC_IRQHandler(&ADC_handle);
 801337a:	1d3b      	adds	r3, r7, #4
 801337c:	4618      	mov	r0, r3
 801337e:	f7f3 fc23 	bl	8006bc8 <HAL_ADC_IRQHandler>
	
	//HAL_GPIO_WritePin(GPIOI,GPIO_PIN_3, GPIO_PIN_RESET);

    /* leave interrupt */
    rt_interrupt_leave();
 8013382:	f003 fca1 	bl	8016cc8 <rt_interrupt_leave>
}
 8013386:	3748      	adds	r7, #72	; 0x48
 8013388:	46bd      	mov	sp, r7
 801338a:	bd80      	pop	{r7, pc}
 801338c:	40012000 	.word	0x40012000

08013390 <HAL_ADC_MspInit>:
  *           - NVIC configuration for UART interrupt request enable
  * @param huart: UART handle pointer
  * @retval None
  */
	void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 8013390:	b580      	push	{r7, lr}
 8013392:	b090      	sub	sp, #64	; 0x40
 8013394:	af00      	add	r7, sp, #0
 8013396:	6078      	str	r0, [r7, #4]
    GPIO_InitTypeDef  GPIO_InitStruct;
    if (hadc->Instance == ADC1)
 8013398:	687b      	ldr	r3, [r7, #4]
 801339a:	681b      	ldr	r3, [r3, #0]
 801339c:	4a90      	ldr	r2, [pc, #576]	; (80135e0 <HAL_ADC_MspInit+0x250>)
 801339e:	4293      	cmp	r3, r2
 80133a0:	d153      	bne.n	801344a <HAL_ADC_MspInit+0xba>
    {
 		ADC1_CLK_ENABLE();
 80133a2:	4a90      	ldr	r2, [pc, #576]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 80133a4:	4b8f      	ldr	r3, [pc, #572]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 80133a6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80133a8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80133ac:	6453      	str	r3, [r2, #68]	; 0x44
 80133ae:	4b8d      	ldr	r3, [pc, #564]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 80133b0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80133b2:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80133b6:	62bb      	str	r3, [r7, #40]	; 0x28
 80133b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
		ADC_GPIOA_CLK_ENABLE();
 80133ba:	4a8a      	ldr	r2, [pc, #552]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 80133bc:	4b89      	ldr	r3, [pc, #548]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 80133be:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80133c0:	f043 0301 	orr.w	r3, r3, #1
 80133c4:	6313      	str	r3, [r2, #48]	; 0x30
 80133c6:	4b87      	ldr	r3, [pc, #540]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 80133c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80133ca:	f003 0301 	and.w	r3, r3, #1
 80133ce:	627b      	str	r3, [r7, #36]	; 0x24
 80133d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
		ADC_GPIOC_CLK_ENABLE();
 80133d2:	4a84      	ldr	r2, [pc, #528]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 80133d4:	4b83      	ldr	r3, [pc, #524]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 80133d6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80133d8:	f043 0304 	orr.w	r3, r3, #4
 80133dc:	6313      	str	r3, [r2, #48]	; 0x30
 80133de:	4b81      	ldr	r3, [pc, #516]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 80133e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80133e2:	f003 0304 	and.w	r3, r3, #4
 80133e6:	623b      	str	r3, [r7, #32]
 80133e8:	6a3b      	ldr	r3, [r7, #32]

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80133ea:	2303      	movs	r3, #3
 80133ec:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_C1_CURRENT_PIN;
 80133ee:	2340      	movs	r3, #64	; 0x40
 80133f0:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 80133f2:	2300      	movs	r3, #0
 80133f4:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_C1_CURRENT_PORT, &GPIO_InitStruct);		
 80133f6:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80133fa:	487b      	ldr	r0, [pc, #492]	; (80135e8 <HAL_ADC_MspInit+0x258>)
 80133fc:	4619      	mov	r1, r3
 80133fe:	f7f9 ffed 	bl	800d3dc <HAL_GPIO_Init>

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8013402:	2303      	movs	r3, #3
 8013404:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_C2_CURRENT_PIN;
 8013406:	2302      	movs	r3, #2
 8013408:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 801340a:	2300      	movs	r3, #0
 801340c:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_C2_CURRENT_PORT, &GPIO_InitStruct);		
 801340e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8013412:	4876      	ldr	r0, [pc, #472]	; (80135ec <HAL_ADC_MspInit+0x25c>)
 8013414:	4619      	mov	r1, r3
 8013416:	f7f9 ffe1 	bl	800d3dc <HAL_GPIO_Init>
		
		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 801341a:	2303      	movs	r3, #3
 801341c:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_C_VOLTAGE_PIN;
 801341e:	2320      	movs	r3, #32
 8013420:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8013422:	2300      	movs	r3, #0
 8013424:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_C_VOLTAGE_PORT, &GPIO_InitStruct);		
 8013426:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801342a:	486f      	ldr	r0, [pc, #444]	; (80135e8 <HAL_ADC_MspInit+0x258>)
 801342c:	4619      	mov	r1, r3
 801342e:	f7f9 ffd5 	bl	800d3dc <HAL_GPIO_Init>
		
		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8013432:	2303      	movs	r3, #3
 8013434:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_TEMP_PIN;
 8013436:	2301      	movs	r3, #1
 8013438:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 801343a:	2300      	movs	r3, #0
 801343c:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_TEMP_PORT, &GPIO_InitStruct);		
 801343e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8013442:	486a      	ldr	r0, [pc, #424]	; (80135ec <HAL_ADC_MspInit+0x25c>)
 8013444:	4619      	mov	r1, r3
 8013446:	f7f9 ffc9 	bl	800d3dc <HAL_GPIO_Init>
    }

	if (hadc->Instance == ADC2)
 801344a:	687b      	ldr	r3, [r7, #4]
 801344c:	681b      	ldr	r3, [r3, #0]
 801344e:	4a68      	ldr	r2, [pc, #416]	; (80135f0 <HAL_ADC_MspInit+0x260>)
 8013450:	4293      	cmp	r3, r2
 8013452:	d153      	bne.n	80134fc <HAL_ADC_MspInit+0x16c>
    {
 		ADC2_CLK_ENABLE();
 8013454:	4a63      	ldr	r2, [pc, #396]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 8013456:	4b63      	ldr	r3, [pc, #396]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 8013458:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801345a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 801345e:	6453      	str	r3, [r2, #68]	; 0x44
 8013460:	4b60      	ldr	r3, [pc, #384]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 8013462:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8013464:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8013468:	61fb      	str	r3, [r7, #28]
 801346a:	69fb      	ldr	r3, [r7, #28]
		ADC_GPIOA_CLK_ENABLE();
 801346c:	4a5d      	ldr	r2, [pc, #372]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 801346e:	4b5d      	ldr	r3, [pc, #372]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 8013470:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013472:	f043 0301 	orr.w	r3, r3, #1
 8013476:	6313      	str	r3, [r2, #48]	; 0x30
 8013478:	4b5a      	ldr	r3, [pc, #360]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 801347a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801347c:	f003 0301 	and.w	r3, r3, #1
 8013480:	61bb      	str	r3, [r7, #24]
 8013482:	69bb      	ldr	r3, [r7, #24]
		ADC_GPIOC_CLK_ENABLE();
 8013484:	4a57      	ldr	r2, [pc, #348]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 8013486:	4b57      	ldr	r3, [pc, #348]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 8013488:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801348a:	f043 0304 	orr.w	r3, r3, #4
 801348e:	6313      	str	r3, [r2, #48]	; 0x30
 8013490:	4b54      	ldr	r3, [pc, #336]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 8013492:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013494:	f003 0304 	and.w	r3, r3, #4
 8013498:	617b      	str	r3, [r7, #20]
 801349a:	697b      	ldr	r3, [r7, #20]

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 801349c:	2303      	movs	r3, #3
 801349e:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_B1_CURRENT_PIN;
 80134a0:	2308      	movs	r3, #8
 80134a2:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 80134a4:	2300      	movs	r3, #0
 80134a6:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_B1_CURRENT_PORT, &GPIO_InitStruct);		
 80134a8:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80134ac:	484e      	ldr	r0, [pc, #312]	; (80135e8 <HAL_ADC_MspInit+0x258>)
 80134ae:	4619      	mov	r1, r3
 80134b0:	f7f9 ff94 	bl	800d3dc <HAL_GPIO_Init>

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80134b4:	2303      	movs	r3, #3
 80134b6:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_B2_CURRENT_PIN;
 80134b8:	2304      	movs	r3, #4
 80134ba:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 80134bc:	2300      	movs	r3, #0
 80134be:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_B2_CURRENT_PORT, &GPIO_InitStruct);		
 80134c0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80134c4:	484b      	ldr	r0, [pc, #300]	; (80135f4 <HAL_ADC_MspInit+0x264>)
 80134c6:	4619      	mov	r1, r3
 80134c8:	f7f9 ff88 	bl	800d3dc <HAL_GPIO_Init>

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80134cc:	2303      	movs	r3, #3
 80134ce:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_B_VOLTAGE_PIN;
 80134d0:	2310      	movs	r3, #16
 80134d2:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 80134d4:	2300      	movs	r3, #0
 80134d6:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_B_VOLTAGE_PORT, &GPIO_InitStruct);	
 80134d8:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80134dc:	4842      	ldr	r0, [pc, #264]	; (80135e8 <HAL_ADC_MspInit+0x258>)
 80134de:	4619      	mov	r1, r3
 80134e0:	f7f9 ff7c 	bl	800d3dc <HAL_GPIO_Init>
		
		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80134e4:	2303      	movs	r3, #3
 80134e6:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_BUS_CURRENT_PIN;
 80134e8:	2301      	movs	r3, #1
 80134ea:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 80134ec:	2300      	movs	r3, #0
 80134ee:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_BUS_CURRENT_PORT, &GPIO_InitStruct);		
 80134f0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80134f4:	483f      	ldr	r0, [pc, #252]	; (80135f4 <HAL_ADC_MspInit+0x264>)
 80134f6:	4619      	mov	r1, r3
 80134f8:	f7f9 ff70 	bl	800d3dc <HAL_GPIO_Init>
    }

	
	if (hadc->Instance == ADC3)
 80134fc:	687b      	ldr	r3, [r7, #4]
 80134fe:	681b      	ldr	r3, [r3, #0]
 8013500:	4a3d      	ldr	r2, [pc, #244]	; (80135f8 <HAL_ADC_MspInit+0x268>)
 8013502:	4293      	cmp	r3, r2
 8013504:	d155      	bne.n	80135b2 <HAL_ADC_MspInit+0x222>
    {
 		ADC3_CLK_ENABLE();
 8013506:	4a37      	ldr	r2, [pc, #220]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 8013508:	4b36      	ldr	r3, [pc, #216]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 801350a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801350c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8013510:	6453      	str	r3, [r2, #68]	; 0x44
 8013512:	4b34      	ldr	r3, [pc, #208]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 8013514:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8013516:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801351a:	613b      	str	r3, [r7, #16]
 801351c:	693b      	ldr	r3, [r7, #16]
		ADC_GPIOA_CLK_ENABLE();
 801351e:	4a31      	ldr	r2, [pc, #196]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 8013520:	4b30      	ldr	r3, [pc, #192]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 8013522:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013524:	f043 0301 	orr.w	r3, r3, #1
 8013528:	6313      	str	r3, [r2, #48]	; 0x30
 801352a:	4b2e      	ldr	r3, [pc, #184]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 801352c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801352e:	f003 0301 	and.w	r3, r3, #1
 8013532:	60fb      	str	r3, [r7, #12]
 8013534:	68fb      	ldr	r3, [r7, #12]
		ADC_GPIOF_CLK_ENABLE();
 8013536:	4a2b      	ldr	r2, [pc, #172]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 8013538:	4b2a      	ldr	r3, [pc, #168]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 801353a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801353c:	f043 0320 	orr.w	r3, r3, #32
 8013540:	6313      	str	r3, [r2, #48]	; 0x30
 8013542:	4b28      	ldr	r3, [pc, #160]	; (80135e4 <HAL_ADC_MspInit+0x254>)
 8013544:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013546:	f003 0320 	and.w	r3, r3, #32
 801354a:	60bb      	str	r3, [r7, #8]
 801354c:	68bb      	ldr	r3, [r7, #8]

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 801354e:	2303      	movs	r3, #3
 8013550:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_A1_CURRENT_PIN;
 8013552:	2380      	movs	r3, #128	; 0x80
 8013554:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8013556:	2300      	movs	r3, #0
 8013558:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_A1_CURRENT_PORT, &GPIO_InitStruct);		
 801355a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801355e:	4827      	ldr	r0, [pc, #156]	; (80135fc <HAL_ADC_MspInit+0x26c>)
 8013560:	4619      	mov	r1, r3
 8013562:	f7f9 ff3b 	bl	800d3dc <HAL_GPIO_Init>

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8013566:	2303      	movs	r3, #3
 8013568:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_A2_CURRENT_PIN;
 801356a:	f44f 7380 	mov.w	r3, #256	; 0x100
 801356e:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8013570:	2300      	movs	r3, #0
 8013572:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_A2_CURRENT_PORT, &GPIO_InitStruct);		
 8013574:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8013578:	4820      	ldr	r0, [pc, #128]	; (80135fc <HAL_ADC_MspInit+0x26c>)
 801357a:	4619      	mov	r1, r3
 801357c:	f7f9 ff2e 	bl	800d3dc <HAL_GPIO_Init>
		
		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8013580:	2303      	movs	r3, #3
 8013582:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_A_VOLTAGE_PIN;
 8013584:	f44f 7300 	mov.w	r3, #512	; 0x200
 8013588:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 801358a:	2300      	movs	r3, #0
 801358c:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_A_VOLTAGE_PORT, &GPIO_InitStruct);		
 801358e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8013592:	481a      	ldr	r0, [pc, #104]	; (80135fc <HAL_ADC_MspInit+0x26c>)
 8013594:	4619      	mov	r1, r3
 8013596:	f7f9 ff21 	bl	800d3dc <HAL_GPIO_Init>
		
		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 801359a:	2303      	movs	r3, #3
 801359c:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_BUS_VOLTAGE_PIN;
 801359e:	2340      	movs	r3, #64	; 0x40
 80135a0:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 80135a2:	2300      	movs	r3, #0
 80135a4:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_BUS_VOLTAGE_PORT, &GPIO_InitStruct);		
 80135a6:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80135aa:	4814      	ldr	r0, [pc, #80]	; (80135fc <HAL_ADC_MspInit+0x26c>)
 80135ac:	4619      	mov	r1, r3
 80135ae:	f7f9 ff15 	bl	800d3dc <HAL_GPIO_Init>
    }

	/*************************test pin************************/
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80135b2:	2301      	movs	r3, #1
 80135b4:	633b      	str	r3, [r7, #48]	; 0x30
	GPIO_InitStruct.Pin = GPIO_PIN_3;
 80135b6:	2308      	movs	r3, #8
 80135b8:	62fb      	str	r3, [r7, #44]	; 0x2c
	GPIO_InitStruct.Pull = GPIO_PULLUP;
 80135ba:	2301      	movs	r3, #1
 80135bc:	637b      	str	r3, [r7, #52]	; 0x34
	HAL_GPIO_Init(GPIOI, &GPIO_InitStruct); 	
 80135be:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80135c2:	480f      	ldr	r0, [pc, #60]	; (8013600 <HAL_ADC_MspInit+0x270>)
 80135c4:	4619      	mov	r1, r3
 80135c6:	f7f9 ff09 	bl	800d3dc <HAL_GPIO_Init>
	
	HAL_NVIC_SetPriority(ADC_IRQn,ADC_IRQ_PREEMPT,ADC_IRQ_SUB);
 80135ca:	2012      	movs	r0, #18
 80135cc:	2100      	movs	r1, #0
 80135ce:	2200      	movs	r2, #0
 80135d0:	f7f5 fa20 	bl	8008a14 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(ADC_IRQn);
 80135d4:	2012      	movs	r0, #18
 80135d6:	f7f5 fa39 	bl	8008a4c <HAL_NVIC_EnableIRQ>
}
 80135da:	3740      	adds	r7, #64	; 0x40
 80135dc:	46bd      	mov	sp, r7
 80135de:	bd80      	pop	{r7, pc}
 80135e0:	40012000 	.word	0x40012000
 80135e4:	40023800 	.word	0x40023800
 80135e8:	40020000 	.word	0x40020000
 80135ec:	40020400 	.word	0x40020400
 80135f0:	40012100 	.word	0x40012100
 80135f4:	40020800 	.word	0x40020800
 80135f8:	40012200 	.word	0x40012200
 80135fc:	40021400 	.word	0x40021400
 8013600:	40022000 	.word	0x40022000

08013604 <ADC_CalibrationAll>:



extern void ADC_CalibrationAll(void)
{
 8013604:	b580      	push	{r7, lr}
 8013606:	b0c0      	sub	sp, #256	; 0x100
 8013608:	af00      	add	r7, sp, #0
	ADC_HandleTypeDef ADC1_handle,ADC2_handle,ADC3_handle;
	ADC_InjectionConfTypeDef ADCConfigInjected;
	ADC_MultiModeTypeDef ADCMultiMode;

	QIEMW_ADC_init(&Global_User_ADC);
 801360a:	4881      	ldr	r0, [pc, #516]	; (8013810 <ADC_CalibrationAll+0x20c>)
 801360c:	f7ff fa52 	bl	8012ab4 <QIEMW_ADC_init>
	ADC1_handle.Instance = ADC1;
 8013610:	4b80      	ldr	r3, [pc, #512]	; (8013814 <ADC_CalibrationAll+0x210>)
 8013612:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
	ADC2_handle.Instance = ADC2;
 8013616:	4b80      	ldr	r3, [pc, #512]	; (8013818 <ADC_CalibrationAll+0x214>)
 8013618:	67bb      	str	r3, [r7, #120]	; 0x78
	ADC3_handle.Instance = ADC3;
 801361a:	4b80      	ldr	r3, [pc, #512]	; (801381c <ADC_CalibrationAll+0x218>)
 801361c:	637b      	str	r3, [r7, #52]	; 0x34
	#if 1
	ADC_Calibration(&ADC1_handle,&Global_User_ADC);
 801361e:	f107 03bc 	add.w	r3, r7, #188	; 0xbc
 8013622:	4618      	mov	r0, r3
 8013624:	497a      	ldr	r1, [pc, #488]	; (8013810 <ADC_CalibrationAll+0x20c>)
 8013626:	f7ff fab7 	bl	8012b98 <ADC_Calibration>
	ADC_Calibration(&ADC2_handle,&Global_User_ADC);
 801362a:	f107 0378 	add.w	r3, r7, #120	; 0x78
 801362e:	4618      	mov	r0, r3
 8013630:	4977      	ldr	r1, [pc, #476]	; (8013810 <ADC_CalibrationAll+0x20c>)
 8013632:	f7ff fab1 	bl	8012b98 <ADC_Calibration>
	ADC_Calibration(&ADC3_handle,&Global_User_ADC);
 8013636:	f107 0334 	add.w	r3, r7, #52	; 0x34
 801363a:	4618      	mov	r0, r3
 801363c:	4974      	ldr	r1, [pc, #464]	; (8013810 <ADC_CalibrationAll+0x20c>)
 801363e:	f7ff faab 	bl	8012b98 <ADC_Calibration>
	#endif
	ADCConfigInjected.AutoInjectedConv = DISABLE;
 8013642:	2300      	movs	r3, #0
 8013644:	627b      	str	r3, [r7, #36]	; 0x24
	ADCConfigInjected.ExternalTrigInjecConv = ADC_EXTERNALTRIGINJECCONV_T8_TRGO2;
 8013646:	f44f 2320 	mov.w	r3, #655360	; 0xa0000
 801364a:	633b      	str	r3, [r7, #48]	; 0x30
	ADCConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONVEDGE_RISINGFALLING;
 801364c:	f44f 1340 	mov.w	r3, #3145728	; 0x300000
 8013650:	62fb      	str	r3, [r7, #44]	; 0x2c
	ADCConfigInjected.InjectedChannel = PHASE_C1_CURRENT_CHANNEL;
 8013652:	2306      	movs	r3, #6
 8013654:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedDiscontinuousConvMode = DISABLE;
 8013656:	2300      	movs	r3, #0
 8013658:	62bb      	str	r3, [r7, #40]	; 0x28
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 801365a:	2304      	movs	r3, #4
 801365c:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 1;
 801365e:	2301      	movs	r3, #1
 8013660:	617b      	str	r3, [r7, #20]
	ADCConfigInjected.InjectedSamplingTime = ADC_SAMPLETIME_28CYCLES;
 8013662:	2302      	movs	r3, #2
 8013664:	61bb      	str	r3, [r7, #24]
	#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseC.qI1_offset>>4;
	#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseC.qI1_offset;
	ADCConfigInjected.InjectedOffset = 0;
 8013666:	2300      	movs	r3, #0
 8013668:	61fb      	str	r3, [r7, #28]
	#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC1_handle,&ADCConfigInjected);
 801366a:	f107 02bc 	add.w	r2, r7, #188	; 0xbc
 801366e:	f107 0310 	add.w	r3, r7, #16
 8013672:	4610      	mov	r0, r2
 8013674:	4619      	mov	r1, r3
 8013676:	f7f3 ff45 	bl	8007504 <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_C2_CURRENT_CHANNEL;
 801367a:	2309      	movs	r3, #9
 801367c:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 801367e:	2304      	movs	r3, #4
 8013680:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 2;
 8013682:	2302      	movs	r3, #2
 8013684:	617b      	str	r3, [r7, #20]
	
	#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseC.qI2_offset>>4;
	#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseC.qI2_offset;
	ADCConfigInjected.InjectedOffset = 0;
 8013686:	2300      	movs	r3, #0
 8013688:	61fb      	str	r3, [r7, #28]
	#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC1_handle,&ADCConfigInjected);
 801368a:	f107 02bc 	add.w	r2, r7, #188	; 0xbc
 801368e:	f107 0310 	add.w	r3, r7, #16
 8013692:	4610      	mov	r0, r2
 8013694:	4619      	mov	r1, r3
 8013696:	f7f3 ff35 	bl	8007504 <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_C_VOLTAGE_CHANNEL;
 801369a:	2305      	movs	r3, #5
 801369c:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 801369e:	2304      	movs	r3, #4
 80136a0:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 3;
 80136a2:	2303      	movs	r3, #3
 80136a4:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseC.qV_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseC.qV_offset;
	ADCConfigInjected.InjectedOffset = 0;
 80136a6:	2300      	movs	r3, #0
 80136a8:	61fb      	str	r3, [r7, #28]

#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC1_handle,&ADCConfigInjected);
 80136aa:	f107 02bc 	add.w	r2, r7, #188	; 0xbc
 80136ae:	f107 0310 	add.w	r3, r7, #16
 80136b2:	4610      	mov	r0, r2
 80136b4:	4619      	mov	r1, r3
 80136b6:	f7f3 ff25 	bl	8007504 <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_TEMP_CHANNEL;
 80136ba:	2308      	movs	r3, #8
 80136bc:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 80136be:	2304      	movs	r3, #4
 80136c0:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 4;
 80136c2:	2304      	movs	r3, #4
 80136c4:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.Temp.TEMP_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.Temp.TEMP_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 80136c6:	2300      	movs	r3, #0
 80136c8:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC1_handle,&ADCConfigInjected);
 80136ca:	f107 02bc 	add.w	r2, r7, #188	; 0xbc
 80136ce:	f107 0310 	add.w	r3, r7, #16
 80136d2:	4610      	mov	r0, r2
 80136d4:	4619      	mov	r1, r3
 80136d6:	f7f3 ff15 	bl	8007504 <HAL_ADCEx_InjectedConfigChannel>
	
	
	ADCConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONVEDGE_NONE;
 80136da:	2300      	movs	r3, #0
 80136dc:	62fb      	str	r3, [r7, #44]	; 0x2c
	ADCConfigInjected.InjectedChannel = PHASE_B1_CURRENT_CHANNEL;
 80136de:	2303      	movs	r3, #3
 80136e0:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 80136e2:	2304      	movs	r3, #4
 80136e4:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 1;
 80136e6:	2301      	movs	r3, #1
 80136e8:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseB.qI1_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseB.qI1_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 80136ea:	2300      	movs	r3, #0
 80136ec:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC2_handle,&ADCConfigInjected);
 80136ee:	f107 0278 	add.w	r2, r7, #120	; 0x78
 80136f2:	f107 0310 	add.w	r3, r7, #16
 80136f6:	4610      	mov	r0, r2
 80136f8:	4619      	mov	r1, r3
 80136fa:	f7f3 ff03 	bl	8007504 <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_B2_CURRENT_CHANNEL;
 80136fe:	230c      	movs	r3, #12
 8013700:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 8013702:	2304      	movs	r3, #4
 8013704:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 2;
 8013706:	2302      	movs	r3, #2
 8013708:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseB.qI2_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseB.qI2_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 801370a:	2300      	movs	r3, #0
 801370c:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC2_handle,&ADCConfigInjected);
 801370e:	f107 0278 	add.w	r2, r7, #120	; 0x78
 8013712:	f107 0310 	add.w	r3, r7, #16
 8013716:	4610      	mov	r0, r2
 8013718:	4619      	mov	r1, r3
 801371a:	f7f3 fef3 	bl	8007504 <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_B_VOLTAGE_CHANNEL;
 801371e:	2304      	movs	r3, #4
 8013720:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 8013722:	2304      	movs	r3, #4
 8013724:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 3;
 8013726:	2303      	movs	r3, #3
 8013728:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseB.qV_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseB.qV_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 801372a:	2300      	movs	r3, #0
 801372c:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC2_handle,&ADCConfigInjected);
 801372e:	f107 0278 	add.w	r2, r7, #120	; 0x78
 8013732:	f107 0310 	add.w	r3, r7, #16
 8013736:	4610      	mov	r0, r2
 8013738:	4619      	mov	r1, r3
 801373a:	f7f3 fee3 	bl	8007504 <HAL_ADCEx_InjectedConfigChannel>
	
	ADCConfigInjected.InjectedChannel = PHASE_BUS_CURRENT_CHANNEL;
 801373e:	230a      	movs	r3, #10
 8013740:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 8013742:	2304      	movs	r3, #4
 8013744:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 4;
 8013746:	2304      	movs	r3, #4
 8013748:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.BUS.qI_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.BUS.qI_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 801374a:	2300      	movs	r3, #0
 801374c:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC2_handle,&ADCConfigInjected);
 801374e:	f107 0278 	add.w	r2, r7, #120	; 0x78
 8013752:	f107 0310 	add.w	r3, r7, #16
 8013756:	4610      	mov	r0, r2
 8013758:	4619      	mov	r1, r3
 801375a:	f7f3 fed3 	bl	8007504 <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_A1_CURRENT_CHANNEL;
 801375e:	2305      	movs	r3, #5
 8013760:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 8013762:	2304      	movs	r3, #4
 8013764:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 1;
 8013766:	2301      	movs	r3, #1
 8013768:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseA.qI1_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseA.qI1_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 801376a:	2300      	movs	r3, #0
 801376c:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC3_handle,&ADCConfigInjected);
 801376e:	f107 0234 	add.w	r2, r7, #52	; 0x34
 8013772:	f107 0310 	add.w	r3, r7, #16
 8013776:	4610      	mov	r0, r2
 8013778:	4619      	mov	r1, r3
 801377a:	f7f3 fec3 	bl	8007504 <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_A2_CURRENT_CHANNEL;
 801377e:	2306      	movs	r3, #6
 8013780:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 8013782:	2304      	movs	r3, #4
 8013784:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 2;
 8013786:	2302      	movs	r3, #2
 8013788:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseA.qI2_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseA.qI2_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 801378a:	2300      	movs	r3, #0
 801378c:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC3_handle,&ADCConfigInjected);
 801378e:	f107 0234 	add.w	r2, r7, #52	; 0x34
 8013792:	f107 0310 	add.w	r3, r7, #16
 8013796:	4610      	mov	r0, r2
 8013798:	4619      	mov	r1, r3
 801379a:	f7f3 feb3 	bl	8007504 <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_A_VOLTAGE_CHANNEL;
 801379e:	2307      	movs	r3, #7
 80137a0:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 80137a2:	2304      	movs	r3, #4
 80137a4:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 3;
 80137a6:	2303      	movs	r3, #3
 80137a8:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseA.qV_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseA.qV_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 80137aa:	2300      	movs	r3, #0
 80137ac:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC3_handle,&ADCConfigInjected);
 80137ae:	f107 0234 	add.w	r2, r7, #52	; 0x34
 80137b2:	f107 0310 	add.w	r3, r7, #16
 80137b6:	4610      	mov	r0, r2
 80137b8:	4619      	mov	r1, r3
 80137ba:	f7f3 fea3 	bl	8007504 <HAL_ADCEx_InjectedConfigChannel>
	
	ADCConfigInjected.InjectedChannel = PHASE_BUS_VOLTAGE_CHANNEL;
 80137be:	2304      	movs	r3, #4
 80137c0:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 80137c2:	2304      	movs	r3, #4
 80137c4:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 4;
 80137c6:	2304      	movs	r3, #4
 80137c8:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.BUS.qV_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.BUS.qV_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 80137ca:	2300      	movs	r3, #0
 80137cc:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC3_handle,&ADCConfigInjected);
 80137ce:	f107 0234 	add.w	r2, r7, #52	; 0x34
 80137d2:	f107 0310 	add.w	r3, r7, #16
 80137d6:	4610      	mov	r0, r2
 80137d8:	4619      	mov	r1, r3
 80137da:	f7f3 fe93 	bl	8007504 <HAL_ADCEx_InjectedConfigChannel>

	ADCMultiMode.DMAAccessMode = ADC_DMAACCESSMODE_DISABLED;
 80137de:	2300      	movs	r3, #0
 80137e0:	60bb      	str	r3, [r7, #8]
	ADCMultiMode.Mode = ADC_TRIPLEMODE_INJECSIMULT;
 80137e2:	2315      	movs	r3, #21
 80137e4:	607b      	str	r3, [r7, #4]
	ADCMultiMode.TwoSamplingDelay = ADC_TWOSAMPLINGDELAY_5CYCLES;
 80137e6:	2300      	movs	r3, #0
 80137e8:	60fb      	str	r3, [r7, #12]
	HAL_ADCEx_MultiModeConfigChannel(&ADC1_handle, &ADCMultiMode);
 80137ea:	f107 02bc 	add.w	r2, r7, #188	; 0xbc
 80137ee:	1d3b      	adds	r3, r7, #4
 80137f0:	4610      	mov	r0, r2
 80137f2:	4619      	mov	r1, r3
 80137f4:	f7f3 fffa 	bl	80077ec <HAL_ADCEx_MultiModeConfigChannel>
	HAL_NVIC_EnableIRQ(ADC_IRQn);
 80137f8:	2012      	movs	r0, #18
 80137fa:	f7f5 f927 	bl	8008a4c <HAL_NVIC_EnableIRQ>
	HAL_ADCEx_InjectedStart_IT(&ADC1_handle);
 80137fe:	f107 03bc 	add.w	r3, r7, #188	; 0xbc
 8013802:	4618      	mov	r0, r3
 8013804:	f7f3 fd60 	bl	80072c8 <HAL_ADCEx_InjectedStart_IT>
}
 8013808:	f507 7780 	add.w	r7, r7, #256	; 0x100
 801380c:	46bd      	mov	sp, r7
 801380e:	bd80      	pop	{r7, pc}
 8013810:	200128c0 	.word	0x200128c0
 8013814:	40012000 	.word	0x40012000
 8013818:	40012100 	.word	0x40012100
 801381c:	40012200 	.word	0x40012200

08013820 <HAL_ADC_MspDeInit>:
  *          - Revert GPIO and NVIC configuration to their default state
  * @param huart: UART handle pointer
  * @retval None
  */
	void HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc)
{
 8013820:	b480      	push	{r7}
 8013822:	b083      	sub	sp, #12
 8013824:	af00      	add	r7, sp, #0
 8013826:	6078      	str	r0, [r7, #4]
   
}
 8013828:	370c      	adds	r7, #12
 801382a:	46bd      	mov	sp, r7
 801382c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013830:	4770      	bx	lr
 8013832:	bf00      	nop

08013834 <stm32_hw_ADC_init>:

extern int stm32_hw_ADC_init(void)
{
 8013834:	b580      	push	{r7, lr}
 8013836:	b0b4      	sub	sp, #208	; 0xd0
 8013838:	af00      	add	r7, sp, #0
	ADC_HandleTypeDef ADC1_handle,ADC2_handle,ADC3_handle;

	QIEMW_ADC_init(&Global_User_ADC);
 801383a:	483e      	ldr	r0, [pc, #248]	; (8013934 <stm32_hw_ADC_init+0x100>)
 801383c:	f7ff f93a 	bl	8012ab4 <QIEMW_ADC_init>
	ADC1_handle.Instance = ADC1;
 8013840:	4b3d      	ldr	r3, [pc, #244]	; (8013938 <stm32_hw_ADC_init+0x104>)
 8013842:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
	HAL_ADC_DeInit(&ADC1_handle);
 8013846:	f107 038c 	add.w	r3, r7, #140	; 0x8c
 801384a:	4618      	mov	r0, r3
 801384c:	f7f3 f90a 	bl	8006a64 <HAL_ADC_DeInit>
	ADC1_handle.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8; /* 96M/8 */
 8013850:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 8013854:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
	ADC1_handle.Init.ContinuousConvMode = DISABLE;
 8013858:	2300      	movs	r3, #0
 801385a:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
	#ifdef DATAALIGN_LEFT
	ADC1_handle.Init.DataAlign = ADC_DATAALIGN_LEFT;
	#else
	ADC1_handle.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 801385e:	2300      	movs	r3, #0
 8013860:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
	#endif
	#if 1
	ADC1_handle.Init.DiscontinuousConvMode = DISABLE;
 8013864:	2300      	movs	r3, #0
 8013866:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
	ADC1_handle.Init.DMAContinuousRequests = DISABLE;
 801386a:	2300      	movs	r3, #0
 801386c:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
	ADC1_handle.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 8013870:	2300      	movs	r3, #0
 8013872:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
	ADC1_handle.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8013876:	4b31      	ldr	r3, [pc, #196]	; (801393c <stm32_hw_ADC_init+0x108>)
 8013878:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
	ADC1_handle.Init.NbrOfConversion = 1;
 801387c:	2301      	movs	r3, #1
 801387e:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
	ADC1_handle.Init.NbrOfDiscConversion = 0;
 8013882:	2300      	movs	r3, #0
 8013884:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
	#endif
	ADC1_handle.Init.Resolution = ADC_RESOLUTION_12B;
 8013888:	2300      	movs	r3, #0
 801388a:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
	ADC1_handle.Init.ScanConvMode = ENABLE;
 801388e:	2301      	movs	r3, #1
 8013890:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
	HAL_ADC_Init(&ADC1_handle);
 8013894:	f107 038c 	add.w	r3, r7, #140	; 0x8c
 8013898:	4618      	mov	r0, r3
 801389a:	f7f3 f8b5 	bl	8006a08 <HAL_ADC_Init>
	
	ADC2_handle.Instance = ADC2;
 801389e:	4b28      	ldr	r3, [pc, #160]	; (8013940 <stm32_hw_ADC_init+0x10c>)
 80138a0:	64bb      	str	r3, [r7, #72]	; 0x48
	HAL_ADC_DeInit(&ADC2_handle);
 80138a2:	f107 0348 	add.w	r3, r7, #72	; 0x48
 80138a6:	4618      	mov	r0, r3
 80138a8:	f7f3 f8dc 	bl	8006a64 <HAL_ADC_DeInit>

	
	ADC2_handle.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8; /* 96M/8 */
 80138ac:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 80138b0:	64fb      	str	r3, [r7, #76]	; 0x4c
	ADC2_handle.Init.ContinuousConvMode = DISABLE;
 80138b2:	2300      	movs	r3, #0
 80138b4:	663b      	str	r3, [r7, #96]	; 0x60
	
#ifdef DATAALIGN_LEFT
	ADC2_handle.Init.DataAlign = ADC_DATAALIGN_LEFT;
#else
	ADC2_handle.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 80138b6:	2300      	movs	r3, #0
 80138b8:	657b      	str	r3, [r7, #84]	; 0x54
#endif
#if 1
	ADC2_handle.Init.DiscontinuousConvMode = DISABLE;
 80138ba:	2300      	movs	r3, #0
 80138bc:	66fb      	str	r3, [r7, #108]	; 0x6c
	ADC2_handle.Init.DMAContinuousRequests = DISABLE;
 80138be:	2300      	movs	r3, #0
 80138c0:	667b      	str	r3, [r7, #100]	; 0x64
	ADC2_handle.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 80138c2:	2300      	movs	r3, #0
 80138c4:	65fb      	str	r3, [r7, #92]	; 0x5c
	ADC2_handle.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 80138c6:	4b1d      	ldr	r3, [pc, #116]	; (801393c <stm32_hw_ADC_init+0x108>)
 80138c8:	677b      	str	r3, [r7, #116]	; 0x74
	ADC2_handle.Init.NbrOfConversion = 1;
 80138ca:	2301      	movs	r3, #1
 80138cc:	66bb      	str	r3, [r7, #104]	; 0x68
	ADC2_handle.Init.NbrOfDiscConversion = 0;
 80138ce:	2300      	movs	r3, #0
 80138d0:	673b      	str	r3, [r7, #112]	; 0x70
	#endif
	ADC2_handle.Init.Resolution = ADC_RESOLUTION_12B;
 80138d2:	2300      	movs	r3, #0
 80138d4:	653b      	str	r3, [r7, #80]	; 0x50
	ADC2_handle.Init.ScanConvMode = ENABLE;
 80138d6:	2301      	movs	r3, #1
 80138d8:	65bb      	str	r3, [r7, #88]	; 0x58
	HAL_ADC_Init(&ADC2_handle);
 80138da:	f107 0348 	add.w	r3, r7, #72	; 0x48
 80138de:	4618      	mov	r0, r3
 80138e0:	f7f3 f892 	bl	8006a08 <HAL_ADC_Init>
	
	ADC3_handle.Instance = ADC3;
 80138e4:	4b17      	ldr	r3, [pc, #92]	; (8013944 <stm32_hw_ADC_init+0x110>)
 80138e6:	607b      	str	r3, [r7, #4]
	HAL_ADC_DeInit(&ADC3_handle);
 80138e8:	1d3b      	adds	r3, r7, #4
 80138ea:	4618      	mov	r0, r3
 80138ec:	f7f3 f8ba 	bl	8006a64 <HAL_ADC_DeInit>
	ADC3_handle.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8; /* 96M/8 */
 80138f0:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 80138f4:	60bb      	str	r3, [r7, #8]
	ADC3_handle.Init.ContinuousConvMode = DISABLE;
 80138f6:	2300      	movs	r3, #0
 80138f8:	61fb      	str	r3, [r7, #28]
	
#ifdef DATAALIGN_LEFT
	ADC3_handle.Init.DataAlign = ADC_DATAALIGN_LEFT;
#else
	ADC3_handle.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 80138fa:	2300      	movs	r3, #0
 80138fc:	613b      	str	r3, [r7, #16]
#endif
#if 1
	ADC3_handle.Init.DiscontinuousConvMode = DISABLE;
 80138fe:	2300      	movs	r3, #0
 8013900:	62bb      	str	r3, [r7, #40]	; 0x28
	ADC3_handle.Init.DMAContinuousRequests = DISABLE;
 8013902:	2300      	movs	r3, #0
 8013904:	623b      	str	r3, [r7, #32]
	ADC3_handle.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 8013906:	2300      	movs	r3, #0
 8013908:	61bb      	str	r3, [r7, #24]
	ADC3_handle.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 801390a:	4b0c      	ldr	r3, [pc, #48]	; (801393c <stm32_hw_ADC_init+0x108>)
 801390c:	633b      	str	r3, [r7, #48]	; 0x30
	ADC3_handle.Init.NbrOfConversion = 1;
 801390e:	2301      	movs	r3, #1
 8013910:	627b      	str	r3, [r7, #36]	; 0x24
	ADC3_handle.Init.NbrOfDiscConversion = 0;
 8013912:	2300      	movs	r3, #0
 8013914:	62fb      	str	r3, [r7, #44]	; 0x2c
	#endif
	ADC3_handle.Init.Resolution = ADC_RESOLUTION_12B;
 8013916:	2300      	movs	r3, #0
 8013918:	60fb      	str	r3, [r7, #12]
	ADC3_handle.Init.ScanConvMode = ENABLE;
 801391a:	2301      	movs	r3, #1
 801391c:	617b      	str	r3, [r7, #20]
	HAL_ADC_Init(&ADC3_handle);
 801391e:	1d3b      	adds	r3, r7, #4
 8013920:	4618      	mov	r0, r3
 8013922:	f7f3 f871 	bl	8006a08 <HAL_ADC_Init>

	ADC_CalibrationAll();
 8013926:	f7ff fe6d 	bl	8013604 <ADC_CalibrationAll>
}
 801392a:	4618      	mov	r0, r3
 801392c:	37d0      	adds	r7, #208	; 0xd0
 801392e:	46bd      	mov	sp, r7
 8013930:	bd80      	pop	{r7, pc}
 8013932:	bf00      	nop
 8013934:	200128c0 	.word	0x200128c0
 8013938:	40012000 	.word	0x40012000
 801393c:	0f000001 	.word	0x0f000001
 8013940:	40012100 	.word	0x40012100
 8013944:	40012200 	.word	0x40012200

08013948 <HAL_TIM_PeriodElapsedCallback>:


#elif defined(TIMER5_HANDLES_ENCODER)

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 8013948:	b480      	push	{r7}
 801394a:	b083      	sub	sp, #12
 801394c:	af00      	add	r7, sp, #0
 801394e:	6078      	str	r0, [r7, #4]
	if (hEncoder_Timer_Overflow != U16_MAX)	
 8013950:	4b09      	ldr	r3, [pc, #36]	; (8013978 <HAL_TIM_PeriodElapsedCallback+0x30>)
 8013952:	881b      	ldrh	r3, [r3, #0]
 8013954:	b29b      	uxth	r3, r3
 8013956:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801395a:	4293      	cmp	r3, r2
 801395c:	d006      	beq.n	801396c <HAL_TIM_PeriodElapsedCallback+0x24>
	{
	   hEncoder_Timer_Overflow++;
 801395e:	4b06      	ldr	r3, [pc, #24]	; (8013978 <HAL_TIM_PeriodElapsedCallback+0x30>)
 8013960:	881b      	ldrh	r3, [r3, #0]
 8013962:	b29b      	uxth	r3, r3
 8013964:	3301      	adds	r3, #1
 8013966:	b29a      	uxth	r2, r3
 8013968:	4b03      	ldr	r3, [pc, #12]	; (8013978 <HAL_TIM_PeriodElapsedCallback+0x30>)
 801396a:	801a      	strh	r2, [r3, #0]
	}
}
 801396c:	370c      	adds	r7, #12
 801396e:	46bd      	mov	sp, r7
 8013970:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013974:	4770      	bx	lr
 8013976:	bf00      	nop
 8013978:	20010830 	.word	0x20010830

0801397c <TIM5_IRQHandler>:

void TIM5_IRQHandler(void)
{
 801397c:	b580      	push	{r7, lr}
 801397e:	b090      	sub	sp, #64	; 0x40
 8013980:	af00      	add	r7, sp, #0
	TIM_HandleTypeDef htim; 
	
	rt_interrupt_enter();
 8013982:	f003 f98b 	bl	8016c9c <rt_interrupt_enter>
	htim.Instance = TIM5;
 8013986:	4b05      	ldr	r3, [pc, #20]	; (801399c <TIM5_IRQHandler+0x20>)
 8013988:	607b      	str	r3, [r7, #4]
	HAL_TIM_IRQHandler(&htim);
 801398a:	1d3b      	adds	r3, r7, #4
 801398c:	4618      	mov	r0, r3
 801398e:	f7fa fff1 	bl	800e974 <HAL_TIM_IRQHandler>
	rt_interrupt_leave();
 8013992:	f003 f999 	bl	8016cc8 <rt_interrupt_leave>
}
 8013996:	3740      	adds	r7, #64	; 0x40
 8013998:	46bd      	mov	sp, r7
 801399a:	bd80      	pop	{r7, pc}
 801399c:	40000c00 	.word	0x40000c00

080139a0 <GetCounterValue>:




extern u16 GetCounterValue(TIM_TypeDef *TIMx)
{
 80139a0:	b480      	push	{r7}
 80139a2:	b083      	sub	sp, #12
 80139a4:	af00      	add	r7, sp, #0
 80139a6:	6078      	str	r0, [r7, #4]
	return(TIMx->CNT);
 80139a8:	687b      	ldr	r3, [r7, #4]
 80139aa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80139ac:	b29b      	uxth	r3, r3
}
 80139ae:	4618      	mov	r0, r3
 80139b0:	370c      	adds	r7, #12
 80139b2:	46bd      	mov	sp, r7
 80139b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80139b8:	4770      	bx	lr
 80139ba:	bf00      	nop

080139bc <HAL_TIM_Encoder_MspInit>:
  *           - NVIC configuration for UART interrupt request enable
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
{
 80139bc:	b580      	push	{r7, lr}
 80139be:	b08a      	sub	sp, #40	; 0x28
 80139c0:	af00      	add	r7, sp, #0
 80139c2:	6078      	str	r0, [r7, #4]
	GPIO_InitTypeDef GPIO_Init;

    /* Enable GPIO clock */
	TIM5_GPIOH_CLK_ENABLE();
 80139c4:	4a19      	ldr	r2, [pc, #100]	; (8013a2c <HAL_TIM_Encoder_MspInit+0x70>)
 80139c6:	4b19      	ldr	r3, [pc, #100]	; (8013a2c <HAL_TIM_Encoder_MspInit+0x70>)
 80139c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80139ca:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80139ce:	6313      	str	r3, [r2, #48]	; 0x30
 80139d0:	4b16      	ldr	r3, [pc, #88]	; (8013a2c <HAL_TIM_Encoder_MspInit+0x70>)
 80139d2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80139d4:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80139d8:	613b      	str	r3, [r7, #16]
 80139da:	693b      	ldr	r3, [r7, #16]
    /* Enable TIMx clock */
    TIM5_CLK_ENABLE();
 80139dc:	4a13      	ldr	r2, [pc, #76]	; (8013a2c <HAL_TIM_Encoder_MspInit+0x70>)
 80139de:	4b13      	ldr	r3, [pc, #76]	; (8013a2c <HAL_TIM_Encoder_MspInit+0x70>)
 80139e0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80139e2:	f043 0308 	orr.w	r3, r3, #8
 80139e6:	6413      	str	r3, [r2, #64]	; 0x40
 80139e8:	4b10      	ldr	r3, [pc, #64]	; (8013a2c <HAL_TIM_Encoder_MspInit+0x70>)
 80139ea:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80139ec:	f003 0308 	and.w	r3, r3, #8
 80139f0:	60fb      	str	r3, [r7, #12]
 80139f2:	68fb      	ldr	r3, [r7, #12]

    /* GPIO pin configuration  */
 	GPIO_Init.Pin = QEP1_PIN;
 80139f4:	2301      	movs	r3, #1
 80139f6:	617b      	str	r3, [r7, #20]
	GPIO_Init.Mode = GPIO_MODE_AF_PP;
 80139f8:	2302      	movs	r3, #2
 80139fa:	61bb      	str	r3, [r7, #24]
	GPIO_Init.Pull = GPIO_PULLUP;
 80139fc:	2301      	movs	r3, #1
 80139fe:	61fb      	str	r3, [r7, #28]
	GPIO_Init.Speed = GPIO_SPEED_HIGH;
 8013a00:	2303      	movs	r3, #3
 8013a02:	623b      	str	r3, [r7, #32]
	GPIO_Init.Alternate = QEP1_AF;
 8013a04:	2302      	movs	r3, #2
 8013a06:	627b      	str	r3, [r7, #36]	; 0x24
	HAL_GPIO_Init(QEP1_GPIO_PORT,&GPIO_Init);
 8013a08:	f107 0314 	add.w	r3, r7, #20
 8013a0c:	4808      	ldr	r0, [pc, #32]	; (8013a30 <HAL_TIM_Encoder_MspInit+0x74>)
 8013a0e:	4619      	mov	r1, r3
 8013a10:	f7f9 fce4 	bl	800d3dc <HAL_GPIO_Init>

	GPIO_Init.Pin = QEP2_PIN;
 8013a14:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8013a18:	617b      	str	r3, [r7, #20]
	HAL_GPIO_Init(QEP2_GPIO_PORT,&GPIO_Init);
 8013a1a:	f107 0314 	add.w	r3, r7, #20
 8013a1e:	4805      	ldr	r0, [pc, #20]	; (8013a34 <HAL_TIM_Encoder_MspInit+0x78>)
 8013a20:	4619      	mov	r1, r3
 8013a22:	f7f9 fcdb 	bl	800d3dc <HAL_GPIO_Init>
}
 8013a26:	3728      	adds	r7, #40	; 0x28
 8013a28:	46bd      	mov	sp, r7
 8013a2a:	bd80      	pop	{r7, pc}
 8013a2c:	40023800 	.word	0x40023800
 8013a30:	40020000 	.word	0x40020000
 8013a34:	40021c00 	.word	0x40021c00

08013a38 <HAL_TIM_Encoder_MspDeInit>:
  *          - Revert GPIO and NVIC configuration to their default state
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
{
 8013a38:	b580      	push	{r7, lr}
 8013a3a:	b082      	sub	sp, #8
 8013a3c:	af00      	add	r7, sp, #0
 8013a3e:	6078      	str	r0, [r7, #4]
    /* Reset peripherals */
    TIM5_FORCE_RESET();
 8013a40:	4a0f      	ldr	r2, [pc, #60]	; (8013a80 <HAL_TIM_Encoder_MspDeInit+0x48>)
 8013a42:	4b0f      	ldr	r3, [pc, #60]	; (8013a80 <HAL_TIM_Encoder_MspDeInit+0x48>)
 8013a44:	6a1b      	ldr	r3, [r3, #32]
 8013a46:	f043 0308 	orr.w	r3, r3, #8
 8013a4a:	6213      	str	r3, [r2, #32]
    TIM5_RELEASE_RESET();
 8013a4c:	4a0c      	ldr	r2, [pc, #48]	; (8013a80 <HAL_TIM_Encoder_MspDeInit+0x48>)
 8013a4e:	4b0c      	ldr	r3, [pc, #48]	; (8013a80 <HAL_TIM_Encoder_MspDeInit+0x48>)
 8013a50:	6a1b      	ldr	r3, [r3, #32]
 8013a52:	f023 0308 	bic.w	r3, r3, #8
 8013a56:	6213      	str	r3, [r2, #32]

    /* Disable peripherals and GPIO Clocks */
    HAL_GPIO_DeInit(QEP1_GPIO_PORT, QEP1_PIN);
 8013a58:	480a      	ldr	r0, [pc, #40]	; (8013a84 <HAL_TIM_Encoder_MspDeInit+0x4c>)
 8013a5a:	2101      	movs	r1, #1
 8013a5c:	f7f9 fe64 	bl	800d728 <HAL_GPIO_DeInit>
    HAL_GPIO_DeInit(QEP2_GPIO_PORT, QEP2_PIN);
 8013a60:	4809      	ldr	r0, [pc, #36]	; (8013a88 <HAL_TIM_Encoder_MspDeInit+0x50>)
 8013a62:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8013a66:	f7f9 fe5f 	bl	800d728 <HAL_GPIO_DeInit>
	
	HAL_NVIC_SetPriority(TIM5_IRQn, TIM5_IRQ_PREEMPT,TIM5_IRQ_SUB);
 8013a6a:	2032      	movs	r0, #50	; 0x32
 8013a6c:	2101      	movs	r1, #1
 8013a6e:	2200      	movs	r2, #0
 8013a70:	f7f4 ffd0 	bl	8008a14 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(TIM5_IRQn);
 8013a74:	2032      	movs	r0, #50	; 0x32
 8013a76:	f7f4 ffe9 	bl	8008a4c <HAL_NVIC_EnableIRQ>
}
 8013a7a:	3708      	adds	r7, #8
 8013a7c:	46bd      	mov	sp, r7
 8013a7e:	bd80      	pop	{r7, pc}
 8013a80:	40023800 	.word	0x40023800
 8013a84:	40020000 	.word	0x40020000
 8013a88:	40021c00 	.word	0x40021c00

08013a8c <stm32_hw_QEP_init>:


#define POLENUM (5)
extern int stm32_hw_QEP_init(void)
{
 8013a8c:	b580      	push	{r7, lr}
 8013a8e:	b09a      	sub	sp, #104	; 0x68
 8013a90:	af00      	add	r7, sp, #0
	TIM_HandleTypeDef htim;  
	TIM_Encoder_InitTypeDef sConfig;
	
	htim.Instance = TIM5;
 8013a92:	4b2e      	ldr	r3, [pc, #184]	; (8013b4c <stm32_hw_QEP_init+0xc0>)
 8013a94:	62fb      	str	r3, [r7, #44]	; 0x2c
	HAL_TIM_Base_DeInit(&htim);
 8013a96:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8013a9a:	4618      	mov	r0, r3
 8013a9c:	f7fa fd6a 	bl	800e574 <HAL_TIM_Base_DeInit>
	HAL_TIM_Encoder_DeInit(&htim);
 8013aa0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8013aa4:	4618      	mov	r0, r3
 8013aa6:	f7fa fefd 	bl	800e8a4 <HAL_TIM_Encoder_DeInit>
    TIM5_CLK_ENABLE();
 8013aaa:	4a29      	ldr	r2, [pc, #164]	; (8013b50 <stm32_hw_QEP_init+0xc4>)
 8013aac:	4b28      	ldr	r3, [pc, #160]	; (8013b50 <stm32_hw_QEP_init+0xc4>)
 8013aae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8013ab0:	f043 0308 	orr.w	r3, r3, #8
 8013ab4:	6413      	str	r3, [r2, #64]	; 0x40
 8013ab6:	4b26      	ldr	r3, [pc, #152]	; (8013b50 <stm32_hw_QEP_init+0xc4>)
 8013ab8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8013aba:	f003 0308 	and.w	r3, r3, #8
 8013abe:	607b      	str	r3, [r7, #4]
 8013ac0:	687b      	ldr	r3, [r7, #4]
	HAL_TIM_Encoder_MspInit(&htim);
 8013ac2:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8013ac6:	4618      	mov	r0, r3
 8013ac8:	f7ff ff78 	bl	80139bc <HAL_TIM_Encoder_MspInit>
	#if 1
	htim.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8013acc:	2300      	movs	r3, #0
 8013ace:	63fb      	str	r3, [r7, #60]	; 0x3c
	htim.Init.CounterMode = TIM_COUNTERMODE_UP;
 8013ad0:	2300      	movs	r3, #0
 8013ad2:	637b      	str	r3, [r7, #52]	; 0x34
	htim.Init.Period = (POLENUM*(4*ENCODER_PPR))-1;
 8013ad4:	f644 73ff 	movw	r3, #20479	; 0x4fff
 8013ad8:	63bb      	str	r3, [r7, #56]	; 0x38
	htim.Init.Prescaler = 0x0;
 8013ada:	2300      	movs	r3, #0
 8013adc:	633b      	str	r3, [r7, #48]	; 0x30
	HAL_TIM_IC_Init(&htim);	
 8013ade:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8013ae2:	4618      	mov	r0, r3
 8013ae4:	f7fa fe10 	bl	800e708 <HAL_TIM_IC_Init>
	
	sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
 8013ae8:	2303      	movs	r3, #3
 8013aea:	60bb      	str	r3, [r7, #8]
	sConfig.IC1Filter = ICx_FILTER;
 8013aec:	2308      	movs	r3, #8
 8013aee:	61bb      	str	r3, [r7, #24]
	sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
 8013af0:	2300      	movs	r3, #0
 8013af2:	60fb      	str	r3, [r7, #12]
	sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
 8013af4:	2300      	movs	r3, #0
 8013af6:	617b      	str	r3, [r7, #20]
	sConfig.IC1Selection = TIM_CCMR1_CC1S_0;//????
 8013af8:	2301      	movs	r3, #1
 8013afa:	613b      	str	r3, [r7, #16]
	sConfig.IC2Filter = ICx_FILTER;
 8013afc:	2308      	movs	r3, #8
 8013afe:	62bb      	str	r3, [r7, #40]	; 0x28
	sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
 8013b00:	2300      	movs	r3, #0
 8013b02:	61fb      	str	r3, [r7, #28]
	sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
 8013b04:	2300      	movs	r3, #0
 8013b06:	627b      	str	r3, [r7, #36]	; 0x24
	sConfig.IC2Selection = TIM_CCMR1_CC1S_0;
 8013b08:	2301      	movs	r3, #1
 8013b0a:	623b      	str	r3, [r7, #32]
	HAL_TIM_Encoder_Init(&htim,  &sConfig);
 8013b0c:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 8013b10:	f107 0308 	add.w	r3, r7, #8
 8013b14:	4610      	mov	r0, r2
 8013b16:	4619      	mov	r1, r3
 8013b18:	f7fa fe2c 	bl	800e774 <HAL_TIM_Encoder_Init>
	#endif
	__HAL_TIM_ENABLE_IT(&htim, TIM_IT_UPDATE);
 8013b1c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013b1e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8013b20:	68d2      	ldr	r2, [r2, #12]
 8013b22:	f042 0201 	orr.w	r2, r2, #1
 8013b26:	60da      	str	r2, [r3, #12]
	
	HAL_TIM_Encoder_Start(&htim, TIM_CHANNEL_1);
 8013b28:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8013b2c:	4618      	mov	r0, r3
 8013b2e:	2100      	movs	r1, #0
 8013b30:	f7fa fee8 	bl	800e904 <HAL_TIM_Encoder_Start>
	HAL_TIM_Encoder_Start(&htim, TIM_CHANNEL_2);
 8013b34:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8013b38:	4618      	mov	r0, r3
 8013b3a:	2104      	movs	r1, #4
 8013b3c:	f7fa fee2 	bl	800e904 <HAL_TIM_Encoder_Start>
	
    return 0;
 8013b40:	2300      	movs	r3, #0
}
 8013b42:	4618      	mov	r0, r3
 8013b44:	3768      	adds	r7, #104	; 0x68
 8013b46:	46bd      	mov	sp, r7
 8013b48:	bd80      	pop	{r7, pc}
 8013b4a:	bf00      	nop
 8013b4c:	40000c00 	.word	0x40000c00
 8013b50:	40023800 	.word	0x40023800

08013b54 <HAL_MPU_Disable>:
/**
  * @brief  Disables the MPU
  * @retval None
  */
__STATIC_INLINE void HAL_MPU_Disable(void)
{
 8013b54:	b480      	push	{r7}
 8013b56:	af00      	add	r7, sp, #0
  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 8013b58:	4a07      	ldr	r2, [pc, #28]	; (8013b78 <HAL_MPU_Disable+0x24>)
 8013b5a:	4b07      	ldr	r3, [pc, #28]	; (8013b78 <HAL_MPU_Disable+0x24>)
 8013b5c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013b5e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8013b62:	6253      	str	r3, [r2, #36]	; 0x24
  
  /* Disable the MPU */
  MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;
 8013b64:	4a05      	ldr	r2, [pc, #20]	; (8013b7c <HAL_MPU_Disable+0x28>)
 8013b66:	4b05      	ldr	r3, [pc, #20]	; (8013b7c <HAL_MPU_Disable+0x28>)
 8013b68:	685b      	ldr	r3, [r3, #4]
 8013b6a:	f023 0301 	bic.w	r3, r3, #1
 8013b6e:	6053      	str	r3, [r2, #4]
}
 8013b70:	46bd      	mov	sp, r7
 8013b72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013b76:	4770      	bx	lr
 8013b78:	e000ed00 	.word	0xe000ed00
 8013b7c:	e000ed90 	.word	0xe000ed90

08013b80 <HAL_MPU_Enable>:
  *            @arg MPU_PRIVILEGED_DEFAULT
  *            @arg MPU_HFNMI_PRIVDEF
  * @retval None
  */
__STATIC_INLINE void HAL_MPU_Enable(uint32_t MPU_Control)
{
 8013b80:	b480      	push	{r7}
 8013b82:	b083      	sub	sp, #12
 8013b84:	af00      	add	r7, sp, #0
 8013b86:	6078      	str	r0, [r7, #4]
  /* Enable the MPU */
  MPU->CTRL   = MPU_Control | MPU_CTRL_ENABLE_Msk;
 8013b88:	4a07      	ldr	r2, [pc, #28]	; (8013ba8 <HAL_MPU_Enable+0x28>)
 8013b8a:	687b      	ldr	r3, [r7, #4]
 8013b8c:	f043 0301 	orr.w	r3, r3, #1
 8013b90:	6053      	str	r3, [r2, #4]
  
  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 8013b92:	4a06      	ldr	r2, [pc, #24]	; (8013bac <HAL_MPU_Enable+0x2c>)
 8013b94:	4b05      	ldr	r3, [pc, #20]	; (8013bac <HAL_MPU_Enable+0x2c>)
 8013b96:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013b98:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8013b9c:	6253      	str	r3, [r2, #36]	; 0x24
}
 8013b9e:	370c      	adds	r7, #12
 8013ba0:	46bd      	mov	sp, r7
 8013ba2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013ba6:	4770      	bx	lr
 8013ba8:	e000ed90 	.word	0xe000ed90
 8013bac:	e000ed00 	.word	0xe000ed00

08013bb0 <mpu_init>:

#include "drv_mpu.h"


void mpu_init(void)
{
 8013bb0:	b580      	push	{r7, lr}
 8013bb2:	b084      	sub	sp, #16
 8013bb4:	af00      	add	r7, sp, #0
  MPU_Region_InitTypeDef MPU_InitStruct;
  
  /* Disable the MPU */
  HAL_MPU_Disable();
 8013bb6:	f7ff ffcd 	bl	8013b54 <HAL_MPU_Disable>

  /* Configure the MPU attributes as WT for SRAM */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 8013bba:	2301      	movs	r3, #1
 8013bbc:	703b      	strb	r3, [r7, #0]
  MPU_InitStruct.BaseAddress = 0x20010000;
 8013bbe:	4b29      	ldr	r3, [pc, #164]	; (8013c64 <mpu_init+0xb4>)
 8013bc0:	607b      	str	r3, [r7, #4]
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
 8013bc2:	2311      	movs	r3, #17
 8013bc4:	723b      	strb	r3, [r7, #8]
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
 8013bc6:	2303      	movs	r3, #3
 8013bc8:	72fb      	strb	r3, [r7, #11]
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
 8013bca:	2300      	movs	r3, #0
 8013bcc:	73fb      	strb	r3, [r7, #15]
  MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
 8013bce:	2301      	movs	r3, #1
 8013bd0:	73bb      	strb	r3, [r7, #14]
  MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
 8013bd2:	2300      	movs	r3, #0
 8013bd4:	737b      	strb	r3, [r7, #13]
  MPU_InitStruct.Number = MPU_REGION_NUMBER0;
 8013bd6:	2300      	movs	r3, #0
 8013bd8:	707b      	strb	r3, [r7, #1]
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 8013bda:	2300      	movs	r3, #0
 8013bdc:	72bb      	strb	r3, [r7, #10]
  MPU_InitStruct.SubRegionDisable = 0x00;
 8013bde:	2300      	movs	r3, #0
 8013be0:	727b      	strb	r3, [r7, #9]
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
 8013be2:	2300      	movs	r3, #0
 8013be4:	733b      	strb	r3, [r7, #12]

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 8013be6:	463b      	mov	r3, r7
 8013be8:	4618      	mov	r0, r3
 8013bea:	f7f4 ff57 	bl	8008a9c <HAL_MPU_ConfigRegion>

  /* Configure the MPU attributes as WB for SDRAM */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 8013bee:	2301      	movs	r3, #1
 8013bf0:	703b      	strb	r3, [r7, #0]
  MPU_InitStruct.BaseAddress = 0xC0000000;
 8013bf2:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
 8013bf6:	607b      	str	r3, [r7, #4]
  MPU_InitStruct.Size = MPU_REGION_SIZE_8MB;
 8013bf8:	2316      	movs	r3, #22
 8013bfa:	723b      	strb	r3, [r7, #8]
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
 8013bfc:	2303      	movs	r3, #3
 8013bfe:	72fb      	strb	r3, [r7, #11]
  MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
 8013c00:	2301      	movs	r3, #1
 8013c02:	73fb      	strb	r3, [r7, #15]
  MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
 8013c04:	2301      	movs	r3, #1
 8013c06:	73bb      	strb	r3, [r7, #14]
  MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
 8013c08:	2300      	movs	r3, #0
 8013c0a:	737b      	strb	r3, [r7, #13]
  MPU_InitStruct.Number = MPU_REGION_NUMBER1;
 8013c0c:	2301      	movs	r3, #1
 8013c0e:	707b      	strb	r3, [r7, #1]
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 8013c10:	2300      	movs	r3, #0
 8013c12:	72bb      	strb	r3, [r7, #10]
  MPU_InitStruct.SubRegionDisable = 0x00;
 8013c14:	2300      	movs	r3, #0
 8013c16:	727b      	strb	r3, [r7, #9]
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
 8013c18:	2300      	movs	r3, #0
 8013c1a:	733b      	strb	r3, [r7, #12]

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 8013c1c:	463b      	mov	r3, r7
 8013c1e:	4618      	mov	r0, r3
 8013c20:	f7f4 ff3c 	bl	8008a9c <HAL_MPU_ConfigRegion>

  /* Configure the MPU attributes as none-cache for 1MB SDRAM */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 8013c24:	2301      	movs	r3, #1
 8013c26:	703b      	strb	r3, [r7, #0]
  MPU_InitStruct.BaseAddress = 0xC0100000;
 8013c28:	4b0f      	ldr	r3, [pc, #60]	; (8013c68 <mpu_init+0xb8>)
 8013c2a:	607b      	str	r3, [r7, #4]
  MPU_InitStruct.Size = MPU_REGION_SIZE_1MB;
 8013c2c:	2313      	movs	r3, #19
 8013c2e:	723b      	strb	r3, [r7, #8]
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
 8013c30:	2303      	movs	r3, #3
 8013c32:	72fb      	strb	r3, [r7, #11]
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
 8013c34:	2300      	movs	r3, #0
 8013c36:	73fb      	strb	r3, [r7, #15]
  MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
 8013c38:	2300      	movs	r3, #0
 8013c3a:	73bb      	strb	r3, [r7, #14]
  MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
 8013c3c:	2300      	movs	r3, #0
 8013c3e:	737b      	strb	r3, [r7, #13]
  MPU_InitStruct.Number = MPU_REGION_NUMBER2;
 8013c40:	2302      	movs	r3, #2
 8013c42:	707b      	strb	r3, [r7, #1]
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 8013c44:	2300      	movs	r3, #0
 8013c46:	72bb      	strb	r3, [r7, #10]
  MPU_InitStruct.SubRegionDisable = 0x00;
 8013c48:	2300      	movs	r3, #0
 8013c4a:	727b      	strb	r3, [r7, #9]
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
 8013c4c:	2300      	movs	r3, #0
 8013c4e:	733b      	strb	r3, [r7, #12]

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 8013c50:	463b      	mov	r3, r7
 8013c52:	4618      	mov	r0, r3
 8013c54:	f7f4 ff22 	bl	8008a9c <HAL_MPU_ConfigRegion>
    
  /* Enable the MPU */
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
 8013c58:	2004      	movs	r0, #4
 8013c5a:	f7ff ff91 	bl	8013b80 <HAL_MPU_Enable>
}
 8013c5e:	3710      	adds	r7, #16
 8013c60:	46bd      	mov	sp, r7
 8013c62:	bd80      	pop	{r7, pc}
 8013c64:	20010000 	.word	0x20010000
 8013c68:	c0100000 	.word	0xc0100000

08013c6c <SDRAM_MspInit>:
  * @param  hsdram: SDRAM handle
  * @param  Params
  * @retval None
  */
static void SDRAM_MspInit(SDRAM_HandleTypeDef  *hsdram, void *Params)
{  
 8013c6c:	b580      	push	{r7, lr}
 8013c6e:	b090      	sub	sp, #64	; 0x40
 8013c70:	af00      	add	r7, sp, #0
 8013c72:	6078      	str	r0, [r7, #4]
 8013c74:	6039      	str	r1, [r7, #0]
  static DMA_HandleTypeDef dma_handle;
  GPIO_InitTypeDef gpio_init_structure;
  
  /* Enable FMC clock */
  __HAL_RCC_FMC_CLK_ENABLE();
 8013c76:	4a6f      	ldr	r2, [pc, #444]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013c78:	4b6e      	ldr	r3, [pc, #440]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013c7a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8013c7c:	f043 0301 	orr.w	r3, r3, #1
 8013c80:	6393      	str	r3, [r2, #56]	; 0x38
 8013c82:	4b6c      	ldr	r3, [pc, #432]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013c84:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8013c86:	f003 0301 	and.w	r3, r3, #1
 8013c8a:	62bb      	str	r3, [r7, #40]	; 0x28
 8013c8c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  
  /* Enable chosen DMAx clock */
  SDRAM_DMA_CLK_ENABLE();
 8013c8e:	4a69      	ldr	r2, [pc, #420]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013c90:	4b68      	ldr	r3, [pc, #416]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013c92:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013c94:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8013c98:	6313      	str	r3, [r2, #48]	; 0x30
 8013c9a:	4b66      	ldr	r3, [pc, #408]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013c9c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013c9e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8013ca2:	627b      	str	r3, [r7, #36]	; 0x24
 8013ca4:	6a7b      	ldr	r3, [r7, #36]	; 0x24

  /* Enable GPIOs clock */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8013ca6:	4a63      	ldr	r2, [pc, #396]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013ca8:	4b62      	ldr	r3, [pc, #392]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013caa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013cac:	f043 0304 	orr.w	r3, r3, #4
 8013cb0:	6313      	str	r3, [r2, #48]	; 0x30
 8013cb2:	4b60      	ldr	r3, [pc, #384]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013cb4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013cb6:	f003 0304 	and.w	r3, r3, #4
 8013cba:	623b      	str	r3, [r7, #32]
 8013cbc:	6a3b      	ldr	r3, [r7, #32]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8013cbe:	4a5d      	ldr	r2, [pc, #372]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013cc0:	4b5c      	ldr	r3, [pc, #368]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013cc2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013cc4:	f043 0308 	orr.w	r3, r3, #8
 8013cc8:	6313      	str	r3, [r2, #48]	; 0x30
 8013cca:	4b5a      	ldr	r3, [pc, #360]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013ccc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013cce:	f003 0308 	and.w	r3, r3, #8
 8013cd2:	61fb      	str	r3, [r7, #28]
 8013cd4:	69fb      	ldr	r3, [r7, #28]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8013cd6:	4a57      	ldr	r2, [pc, #348]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013cd8:	4b56      	ldr	r3, [pc, #344]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013cda:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013cdc:	f043 0310 	orr.w	r3, r3, #16
 8013ce0:	6313      	str	r3, [r2, #48]	; 0x30
 8013ce2:	4b54      	ldr	r3, [pc, #336]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013ce4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013ce6:	f003 0310 	and.w	r3, r3, #16
 8013cea:	61bb      	str	r3, [r7, #24]
 8013cec:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8013cee:	4a51      	ldr	r2, [pc, #324]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013cf0:	4b50      	ldr	r3, [pc, #320]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013cf2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013cf4:	f043 0320 	orr.w	r3, r3, #32
 8013cf8:	6313      	str	r3, [r2, #48]	; 0x30
 8013cfa:	4b4e      	ldr	r3, [pc, #312]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013cfc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013cfe:	f003 0320 	and.w	r3, r3, #32
 8013d02:	617b      	str	r3, [r7, #20]
 8013d04:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 8013d06:	4a4b      	ldr	r2, [pc, #300]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013d08:	4b4a      	ldr	r3, [pc, #296]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013d0a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013d0c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8013d10:	6313      	str	r3, [r2, #48]	; 0x30
 8013d12:	4b48      	ldr	r3, [pc, #288]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013d14:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013d16:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013d1a:	613b      	str	r3, [r7, #16]
 8013d1c:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8013d1e:	4a45      	ldr	r2, [pc, #276]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013d20:	4b44      	ldr	r3, [pc, #272]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013d22:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013d24:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8013d28:	6313      	str	r3, [r2, #48]	; 0x30
 8013d2a:	4b42      	ldr	r3, [pc, #264]	; (8013e34 <SDRAM_MspInit+0x1c8>)
 8013d2c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013d2e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8013d32:	60fb      	str	r3, [r7, #12]
 8013d34:	68fb      	ldr	r3, [r7, #12]
  
  /* Common GPIO configuration */
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 8013d36:	2302      	movs	r3, #2
 8013d38:	633b      	str	r3, [r7, #48]	; 0x30
  gpio_init_structure.Pull      = GPIO_PULLUP;
 8013d3a:	2301      	movs	r3, #1
 8013d3c:	637b      	str	r3, [r7, #52]	; 0x34
  gpio_init_structure.Speed     = GPIO_SPEED_FAST;
 8013d3e:	2302      	movs	r3, #2
 8013d40:	63bb      	str	r3, [r7, #56]	; 0x38
  gpio_init_structure.Alternate = GPIO_AF12_FMC;
 8013d42:	230c      	movs	r3, #12
 8013d44:	63fb      	str	r3, [r7, #60]	; 0x3c
  
  /* GPIOC configuration */
  gpio_init_structure.Pin   = GPIO_PIN_3;
 8013d46:	2308      	movs	r3, #8
 8013d48:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_GPIO_Init(GPIOC, &gpio_init_structure);
 8013d4a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8013d4e:	483a      	ldr	r0, [pc, #232]	; (8013e38 <SDRAM_MspInit+0x1cc>)
 8013d50:	4619      	mov	r1, r3
 8013d52:	f7f9 fb43 	bl	800d3dc <HAL_GPIO_Init>

  /* GPIOD configuration */
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_3 | GPIO_PIN_8 | GPIO_PIN_9 |
 8013d56:	f24c 730b 	movw	r3, #50955	; 0xc70b
 8013d5a:	62fb      	str	r3, [r7, #44]	; 0x2c
                              GPIO_PIN_10 | GPIO_PIN_14 | GPIO_PIN_15;
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
 8013d5c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8013d60:	4836      	ldr	r0, [pc, #216]	; (8013e3c <SDRAM_MspInit+0x1d0>)
 8013d62:	4619      	mov	r1, r3
 8013d64:	f7f9 fb3a 	bl	800d3dc <HAL_GPIO_Init>

  /* GPIOE configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_7| GPIO_PIN_8 | GPIO_PIN_9 |\
 8013d68:	f64f 7383 	movw	r3, #65411	; 0xff83
 8013d6c:	62fb      	str	r3, [r7, #44]	; 0x2c
                              GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 |\
                              GPIO_PIN_15;
  HAL_GPIO_Init(GPIOE, &gpio_init_structure);
 8013d6e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8013d72:	4833      	ldr	r0, [pc, #204]	; (8013e40 <SDRAM_MspInit+0x1d4>)
 8013d74:	4619      	mov	r1, r3
 8013d76:	f7f9 fb31 	bl	800d3dc <HAL_GPIO_Init>
  
  /* GPIOF configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2| GPIO_PIN_3 | GPIO_PIN_4 |\
 8013d7a:	f64f 033f 	movw	r3, #63551	; 0xf83f
 8013d7e:	62fb      	str	r3, [r7, #44]	; 0x2c
                              GPIO_PIN_5 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 |\
                              GPIO_PIN_15;
  HAL_GPIO_Init(GPIOF, &gpio_init_structure);
 8013d80:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8013d84:	482f      	ldr	r0, [pc, #188]	; (8013e44 <SDRAM_MspInit+0x1d8>)
 8013d86:	4619      	mov	r1, r3
 8013d88:	f7f9 fb28 	bl	800d3dc <HAL_GPIO_Init>
  
  /* GPIOG configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4| GPIO_PIN_5 | GPIO_PIN_8 |\
 8013d8c:	f248 1333 	movw	r3, #33075	; 0x8133
 8013d90:	62fb      	str	r3, [r7, #44]	; 0x2c
                              GPIO_PIN_15;
  HAL_GPIO_Init(GPIOG, &gpio_init_structure);
 8013d92:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8013d96:	482c      	ldr	r0, [pc, #176]	; (8013e48 <SDRAM_MspInit+0x1dc>)
 8013d98:	4619      	mov	r1, r3
 8013d9a:	f7f9 fb1f 	bl	800d3dc <HAL_GPIO_Init>

  /* GPIOH configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_3 | GPIO_PIN_5;
 8013d9e:	2328      	movs	r3, #40	; 0x28
 8013da0:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_GPIO_Init(GPIOH, &gpio_init_structure); 
 8013da2:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8013da6:	4829      	ldr	r0, [pc, #164]	; (8013e4c <SDRAM_MspInit+0x1e0>)
 8013da8:	4619      	mov	r1, r3
 8013daa:	f7f9 fb17 	bl	800d3dc <HAL_GPIO_Init>
  
  /* Configure common DMA parameters */
  dma_handle.Init.Channel             = SDRAM_DMA_CHANNEL;
 8013dae:	4b28      	ldr	r3, [pc, #160]	; (8013e50 <SDRAM_MspInit+0x1e4>)
 8013db0:	2200      	movs	r2, #0
 8013db2:	605a      	str	r2, [r3, #4]
  dma_handle.Init.Direction           = DMA_MEMORY_TO_MEMORY;
 8013db4:	4b26      	ldr	r3, [pc, #152]	; (8013e50 <SDRAM_MspInit+0x1e4>)
 8013db6:	2280      	movs	r2, #128	; 0x80
 8013db8:	609a      	str	r2, [r3, #8]
  dma_handle.Init.PeriphInc           = DMA_PINC_ENABLE;
 8013dba:	4b25      	ldr	r3, [pc, #148]	; (8013e50 <SDRAM_MspInit+0x1e4>)
 8013dbc:	f44f 7200 	mov.w	r2, #512	; 0x200
 8013dc0:	60da      	str	r2, [r3, #12]
  dma_handle.Init.MemInc              = DMA_MINC_ENABLE;
 8013dc2:	4b23      	ldr	r3, [pc, #140]	; (8013e50 <SDRAM_MspInit+0x1e4>)
 8013dc4:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8013dc8:	611a      	str	r2, [r3, #16]
  dma_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8013dca:	4b21      	ldr	r3, [pc, #132]	; (8013e50 <SDRAM_MspInit+0x1e4>)
 8013dcc:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8013dd0:	615a      	str	r2, [r3, #20]
  dma_handle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
 8013dd2:	4b1f      	ldr	r3, [pc, #124]	; (8013e50 <SDRAM_MspInit+0x1e4>)
 8013dd4:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8013dd8:	619a      	str	r2, [r3, #24]
  dma_handle.Init.Mode                = DMA_NORMAL;
 8013dda:	4b1d      	ldr	r3, [pc, #116]	; (8013e50 <SDRAM_MspInit+0x1e4>)
 8013ddc:	2200      	movs	r2, #0
 8013dde:	61da      	str	r2, [r3, #28]
  dma_handle.Init.Priority            = DMA_PRIORITY_HIGH;
 8013de0:	4b1b      	ldr	r3, [pc, #108]	; (8013e50 <SDRAM_MspInit+0x1e4>)
 8013de2:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8013de6:	621a      	str	r2, [r3, #32]
  dma_handle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;         
 8013de8:	4b19      	ldr	r3, [pc, #100]	; (8013e50 <SDRAM_MspInit+0x1e4>)
 8013dea:	2200      	movs	r2, #0
 8013dec:	625a      	str	r2, [r3, #36]	; 0x24
  dma_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
 8013dee:	4b18      	ldr	r3, [pc, #96]	; (8013e50 <SDRAM_MspInit+0x1e4>)
 8013df0:	2203      	movs	r2, #3
 8013df2:	629a      	str	r2, [r3, #40]	; 0x28
  dma_handle.Init.MemBurst            = DMA_MBURST_SINGLE;
 8013df4:	4b16      	ldr	r3, [pc, #88]	; (8013e50 <SDRAM_MspInit+0x1e4>)
 8013df6:	2200      	movs	r2, #0
 8013df8:	62da      	str	r2, [r3, #44]	; 0x2c
  dma_handle.Init.PeriphBurst         = DMA_PBURST_SINGLE; 
 8013dfa:	4b15      	ldr	r3, [pc, #84]	; (8013e50 <SDRAM_MspInit+0x1e4>)
 8013dfc:	2200      	movs	r2, #0
 8013dfe:	631a      	str	r2, [r3, #48]	; 0x30
  
  dma_handle.Instance = SDRAM_DMA_STREAM;
 8013e00:	4b13      	ldr	r3, [pc, #76]	; (8013e50 <SDRAM_MspInit+0x1e4>)
 8013e02:	4a14      	ldr	r2, [pc, #80]	; (8013e54 <SDRAM_MspInit+0x1e8>)
 8013e04:	601a      	str	r2, [r3, #0]
  
   /* Associate the DMA handle */
  __HAL_LINKDMA(hsdram, hdma, dma_handle);
 8013e06:	687b      	ldr	r3, [r7, #4]
 8013e08:	4a11      	ldr	r2, [pc, #68]	; (8013e50 <SDRAM_MspInit+0x1e4>)
 8013e0a:	631a      	str	r2, [r3, #48]	; 0x30
 8013e0c:	4a10      	ldr	r2, [pc, #64]	; (8013e50 <SDRAM_MspInit+0x1e4>)
 8013e0e:	687b      	ldr	r3, [r7, #4]
 8013e10:	6393      	str	r3, [r2, #56]	; 0x38
  
  /* Deinitialize the stream for new transfer */
  HAL_DMA_DeInit(&dma_handle);
 8013e12:	480f      	ldr	r0, [pc, #60]	; (8013e50 <SDRAM_MspInit+0x1e4>)
 8013e14:	f7f4 ff1e 	bl	8008c54 <HAL_DMA_DeInit>
  
  /* Configure the DMA stream */
  HAL_DMA_Init(&dma_handle); 
 8013e18:	480d      	ldr	r0, [pc, #52]	; (8013e50 <SDRAM_MspInit+0x1e4>)
 8013e1a:	f7f4 feaf 	bl	8008b7c <HAL_DMA_Init>
  
  /* NVIC configuration for DMA transfer complete interrupt */
  HAL_NVIC_SetPriority(SDRAM_DMA_IRQn, SDRAM_DMA_IRQ_PREEMPT, SDRAM_DMA_IRQ_SUB);
 8013e1e:	2038      	movs	r0, #56	; 0x38
 8013e20:	2105      	movs	r1, #5
 8013e22:	2200      	movs	r2, #0
 8013e24:	f7f4 fdf6 	bl	8008a14 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SDRAM_DMA_IRQn);
 8013e28:	2038      	movs	r0, #56	; 0x38
 8013e2a:	f7f4 fe0f 	bl	8008a4c <HAL_NVIC_EnableIRQ>
}
 8013e2e:	3740      	adds	r7, #64	; 0x40
 8013e30:	46bd      	mov	sp, r7
 8013e32:	bd80      	pop	{r7, pc}
 8013e34:	40023800 	.word	0x40023800
 8013e38:	40020800 	.word	0x40020800
 8013e3c:	40020c00 	.word	0x40020c00
 8013e40:	40021000 	.word	0x40021000
 8013e44:	40021400 	.word	0x40021400
 8013e48:	40021800 	.word	0x40021800
 8013e4c:	40021c00 	.word	0x40021c00
 8013e50:	20010894 	.word	0x20010894
 8013e54:	40026410 	.word	0x40026410

08013e58 <SDRAM_InitializationSequence>:
  * @brief  Programs the SDRAM device.
  * @param  RefreshCount: SDRAM refresh counter value 
  * @retval None
  */
static void SDRAM_InitializationSequence(uint32_t RefreshCount)
{
 8013e58:	b580      	push	{r7, lr}
 8013e5a:	b084      	sub	sp, #16
 8013e5c:	af00      	add	r7, sp, #0
 8013e5e:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpmrd = 0;
 8013e60:	2300      	movs	r3, #0
 8013e62:	60fb      	str	r3, [r7, #12]
  
  /* Step 1: Configure a clock configuration enable command */
  Command.CommandMode            = FMC_SDRAM_CMD_CLK_ENABLE;
 8013e64:	4b2d      	ldr	r3, [pc, #180]	; (8013f1c <SDRAM_InitializationSequence+0xc4>)
 8013e66:	2201      	movs	r2, #1
 8013e68:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 8013e6a:	4b2c      	ldr	r3, [pc, #176]	; (8013f1c <SDRAM_InitializationSequence+0xc4>)
 8013e6c:	2210      	movs	r2, #16
 8013e6e:	605a      	str	r2, [r3, #4]
  Command.AutoRefreshNumber      = 1;
 8013e70:	4b2a      	ldr	r3, [pc, #168]	; (8013f1c <SDRAM_InitializationSequence+0xc4>)
 8013e72:	2201      	movs	r2, #1
 8013e74:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = 0;
 8013e76:	4b29      	ldr	r3, [pc, #164]	; (8013f1c <SDRAM_InitializationSequence+0xc4>)
 8013e78:	2200      	movs	r2, #0
 8013e7a:	60da      	str	r2, [r3, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 8013e7c:	4828      	ldr	r0, [pc, #160]	; (8013f20 <SDRAM_InitializationSequence+0xc8>)
 8013e7e:	4927      	ldr	r1, [pc, #156]	; (8013f1c <SDRAM_InitializationSequence+0xc4>)
 8013e80:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8013e84:	f7fa fb2a 	bl	800e4dc <HAL_SDRAM_SendCommand>

  /* Step 2: Insert 100 us minimum delay */ 
  /* Inserted delay is equal to 1 ms due to systick time base unit (ms) */
  // HAL_Delay(1);
	/* interrupt is not enable, just to delay some time. */
	for (tmpmrd = 0; tmpmrd < 0xfffff; tmpmrd ++)
 8013e88:	2300      	movs	r3, #0
 8013e8a:	60fb      	str	r3, [r7, #12]
 8013e8c:	e002      	b.n	8013e94 <SDRAM_InitializationSequence+0x3c>
 8013e8e:	68fb      	ldr	r3, [r7, #12]
 8013e90:	3301      	adds	r3, #1
 8013e92:	60fb      	str	r3, [r7, #12]
 8013e94:	68fb      	ldr	r3, [r7, #12]
 8013e96:	4a23      	ldr	r2, [pc, #140]	; (8013f24 <SDRAM_InitializationSequence+0xcc>)
 8013e98:	4293      	cmp	r3, r2
 8013e9a:	d9f8      	bls.n	8013e8e <SDRAM_InitializationSequence+0x36>
		;

  /* Step 3: Configure a PALL (precharge all) command */ 
  Command.CommandMode            = FMC_SDRAM_CMD_PALL;
 8013e9c:	4b1f      	ldr	r3, [pc, #124]	; (8013f1c <SDRAM_InitializationSequence+0xc4>)
 8013e9e:	2202      	movs	r2, #2
 8013ea0:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 8013ea2:	4b1e      	ldr	r3, [pc, #120]	; (8013f1c <SDRAM_InitializationSequence+0xc4>)
 8013ea4:	2210      	movs	r2, #16
 8013ea6:	605a      	str	r2, [r3, #4]
  Command.AutoRefreshNumber      = 1;
 8013ea8:	4b1c      	ldr	r3, [pc, #112]	; (8013f1c <SDRAM_InitializationSequence+0xc4>)
 8013eaa:	2201      	movs	r2, #1
 8013eac:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = 0;
 8013eae:	4b1b      	ldr	r3, [pc, #108]	; (8013f1c <SDRAM_InitializationSequence+0xc4>)
 8013eb0:	2200      	movs	r2, #0
 8013eb2:	60da      	str	r2, [r3, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);  
 8013eb4:	481a      	ldr	r0, [pc, #104]	; (8013f20 <SDRAM_InitializationSequence+0xc8>)
 8013eb6:	4919      	ldr	r1, [pc, #100]	; (8013f1c <SDRAM_InitializationSequence+0xc4>)
 8013eb8:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8013ebc:	f7fa fb0e 	bl	800e4dc <HAL_SDRAM_SendCommand>
  
  /* Step 4: Configure an Auto Refresh command */ 
  Command.CommandMode            = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 8013ec0:	4b16      	ldr	r3, [pc, #88]	; (8013f1c <SDRAM_InitializationSequence+0xc4>)
 8013ec2:	2203      	movs	r2, #3
 8013ec4:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 8013ec6:	4b15      	ldr	r3, [pc, #84]	; (8013f1c <SDRAM_InitializationSequence+0xc4>)
 8013ec8:	2210      	movs	r2, #16
 8013eca:	605a      	str	r2, [r3, #4]
  Command.AutoRefreshNumber      = 8;
 8013ecc:	4b13      	ldr	r3, [pc, #76]	; (8013f1c <SDRAM_InitializationSequence+0xc4>)
 8013ece:	2208      	movs	r2, #8
 8013ed0:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = 0;
 8013ed2:	4b12      	ldr	r3, [pc, #72]	; (8013f1c <SDRAM_InitializationSequence+0xc4>)
 8013ed4:	2200      	movs	r2, #0
 8013ed6:	60da      	str	r2, [r3, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 8013ed8:	4811      	ldr	r0, [pc, #68]	; (8013f20 <SDRAM_InitializationSequence+0xc8>)
 8013eda:	4910      	ldr	r1, [pc, #64]	; (8013f1c <SDRAM_InitializationSequence+0xc4>)
 8013edc:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8013ee0:	f7fa fafc 	bl	800e4dc <HAL_SDRAM_SendCommand>
  
  /* Step 5: Program the external memory mode register */
  tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1          |\
 8013ee4:	f44f 7308 	mov.w	r3, #544	; 0x220
 8013ee8:	60fb      	str	r3, [r7, #12]
                     SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL   |\
                     SDRAM_MODEREG_CAS_LATENCY_2           |\
                     SDRAM_MODEREG_OPERATING_MODE_STANDARD |\
                     SDRAM_MODEREG_WRITEBURST_MODE_SINGLE;
  
  Command.CommandMode            = FMC_SDRAM_CMD_LOAD_MODE;
 8013eea:	4b0c      	ldr	r3, [pc, #48]	; (8013f1c <SDRAM_InitializationSequence+0xc4>)
 8013eec:	2204      	movs	r2, #4
 8013eee:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 8013ef0:	4b0a      	ldr	r3, [pc, #40]	; (8013f1c <SDRAM_InitializationSequence+0xc4>)
 8013ef2:	2210      	movs	r2, #16
 8013ef4:	605a      	str	r2, [r3, #4]
  Command.AutoRefreshNumber      = 1;
 8013ef6:	4b09      	ldr	r3, [pc, #36]	; (8013f1c <SDRAM_InitializationSequence+0xc4>)
 8013ef8:	2201      	movs	r2, #1
 8013efa:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = tmpmrd;
 8013efc:	68fb      	ldr	r3, [r7, #12]
 8013efe:	4a07      	ldr	r2, [pc, #28]	; (8013f1c <SDRAM_InitializationSequence+0xc4>)
 8013f00:	60d3      	str	r3, [r2, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 8013f02:	4807      	ldr	r0, [pc, #28]	; (8013f20 <SDRAM_InitializationSequence+0xc8>)
 8013f04:	4905      	ldr	r1, [pc, #20]	; (8013f1c <SDRAM_InitializationSequence+0xc4>)
 8013f06:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8013f0a:	f7fa fae7 	bl	800e4dc <HAL_SDRAM_SendCommand>
  
  /* Step 6: Set the refresh rate counter */
  /* Set the device refresh rate */
  HAL_SDRAM_ProgramRefreshRate(&sdramHandle, RefreshCount); 
 8013f0e:	4804      	ldr	r0, [pc, #16]	; (8013f20 <SDRAM_InitializationSequence+0xc8>)
 8013f10:	6879      	ldr	r1, [r7, #4]
 8013f12:	f7fa fb0f 	bl	800e534 <HAL_SDRAM_ProgramRefreshRate>
}
 8013f16:	3710      	adds	r7, #16
 8013f18:	46bd      	mov	sp, r7
 8013f1a:	bd80      	pop	{r7, pc}
 8013f1c:	20010884 	.word	0x20010884
 8013f20:	20010834 	.word	0x20010834
 8013f24:	000ffffe 	.word	0x000ffffe

08013f28 <sdram_hw_init>:
/**
  * @brief  Initializes the SDRAM device.
  * @retval SDRAM status
  */
rt_err_t sdram_hw_init(void)
{ 
 8013f28:	b580      	push	{r7, lr}
 8013f2a:	af00      	add	r7, sp, #0
  static uint8_t sdramstatus = RT_ERROR;
  /* SDRAM device configuration */
  sdramHandle.Instance = FMC_SDRAM_DEVICE;
 8013f2c:	4b29      	ldr	r3, [pc, #164]	; (8013fd4 <sdram_hw_init+0xac>)
 8013f2e:	4a2a      	ldr	r2, [pc, #168]	; (8013fd8 <sdram_hw_init+0xb0>)
 8013f30:	601a      	str	r2, [r3, #0]
    
  /* Timing configuration for 100Mhz as SD clock frequency (System clock is up to 200Mhz) */
  Timing.LoadToActiveDelay    = 2;
 8013f32:	4b2a      	ldr	r3, [pc, #168]	; (8013fdc <sdram_hw_init+0xb4>)
 8013f34:	2202      	movs	r2, #2
 8013f36:	601a      	str	r2, [r3, #0]
  Timing.ExitSelfRefreshDelay = 7;
 8013f38:	4b28      	ldr	r3, [pc, #160]	; (8013fdc <sdram_hw_init+0xb4>)
 8013f3a:	2207      	movs	r2, #7
 8013f3c:	605a      	str	r2, [r3, #4]
  Timing.SelfRefreshTime      = 4;
 8013f3e:	4b27      	ldr	r3, [pc, #156]	; (8013fdc <sdram_hw_init+0xb4>)
 8013f40:	2204      	movs	r2, #4
 8013f42:	609a      	str	r2, [r3, #8]
  Timing.RowCycleDelay        = 7;
 8013f44:	4b25      	ldr	r3, [pc, #148]	; (8013fdc <sdram_hw_init+0xb4>)
 8013f46:	2207      	movs	r2, #7
 8013f48:	60da      	str	r2, [r3, #12]
  Timing.WriteRecoveryTime    = 2;
 8013f4a:	4b24      	ldr	r3, [pc, #144]	; (8013fdc <sdram_hw_init+0xb4>)
 8013f4c:	2202      	movs	r2, #2
 8013f4e:	611a      	str	r2, [r3, #16]
  Timing.RPDelay              = 2;
 8013f50:	4b22      	ldr	r3, [pc, #136]	; (8013fdc <sdram_hw_init+0xb4>)
 8013f52:	2202      	movs	r2, #2
 8013f54:	615a      	str	r2, [r3, #20]
  Timing.RCDDelay             = 2;
 8013f56:	4b21      	ldr	r3, [pc, #132]	; (8013fdc <sdram_hw_init+0xb4>)
 8013f58:	2202      	movs	r2, #2
 8013f5a:	619a      	str	r2, [r3, #24]
  
  sdramHandle.Init.SDBank             = FMC_SDRAM_BANK1;
 8013f5c:	4b1d      	ldr	r3, [pc, #116]	; (8013fd4 <sdram_hw_init+0xac>)
 8013f5e:	2200      	movs	r2, #0
 8013f60:	605a      	str	r2, [r3, #4]
  sdramHandle.Init.ColumnBitsNumber   = FMC_SDRAM_COLUMN_BITS_NUM_8;
 8013f62:	4b1c      	ldr	r3, [pc, #112]	; (8013fd4 <sdram_hw_init+0xac>)
 8013f64:	2200      	movs	r2, #0
 8013f66:	609a      	str	r2, [r3, #8]
  sdramHandle.Init.RowBitsNumber      = FMC_SDRAM_ROW_BITS_NUM_12;
 8013f68:	4b1a      	ldr	r3, [pc, #104]	; (8013fd4 <sdram_hw_init+0xac>)
 8013f6a:	2204      	movs	r2, #4
 8013f6c:	60da      	str	r2, [r3, #12]
  sdramHandle.Init.MemoryDataWidth    = SDRAM_MEMORY_WIDTH;
 8013f6e:	4b19      	ldr	r3, [pc, #100]	; (8013fd4 <sdram_hw_init+0xac>)
 8013f70:	2210      	movs	r2, #16
 8013f72:	611a      	str	r2, [r3, #16]
  sdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 8013f74:	4b17      	ldr	r3, [pc, #92]	; (8013fd4 <sdram_hw_init+0xac>)
 8013f76:	2240      	movs	r2, #64	; 0x40
 8013f78:	615a      	str	r2, [r3, #20]
  sdramHandle.Init.CASLatency         = FMC_SDRAM_CAS_LATENCY_2;
 8013f7a:	4b16      	ldr	r3, [pc, #88]	; (8013fd4 <sdram_hw_init+0xac>)
 8013f7c:	f44f 7280 	mov.w	r2, #256	; 0x100
 8013f80:	619a      	str	r2, [r3, #24]
  sdramHandle.Init.WriteProtection    = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
 8013f82:	4b14      	ldr	r3, [pc, #80]	; (8013fd4 <sdram_hw_init+0xac>)
 8013f84:	2200      	movs	r2, #0
 8013f86:	61da      	str	r2, [r3, #28]
  sdramHandle.Init.SDClockPeriod      = SDCLOCK_PERIOD;
 8013f88:	4b12      	ldr	r3, [pc, #72]	; (8013fd4 <sdram_hw_init+0xac>)
 8013f8a:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8013f8e:	621a      	str	r2, [r3, #32]
  sdramHandle.Init.ReadBurst          = FMC_SDRAM_RBURST_ENABLE;
 8013f90:	4b10      	ldr	r3, [pc, #64]	; (8013fd4 <sdram_hw_init+0xac>)
 8013f92:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8013f96:	625a      	str	r2, [r3, #36]	; 0x24
  sdramHandle.Init.ReadPipeDelay      = FMC_SDRAM_RPIPE_DELAY_0;
 8013f98:	4b0e      	ldr	r3, [pc, #56]	; (8013fd4 <sdram_hw_init+0xac>)
 8013f9a:	2200      	movs	r2, #0
 8013f9c:	629a      	str	r2, [r3, #40]	; 0x28
  
  /* SDRAM controller initialization */

  SDRAM_MspInit(&sdramHandle, NULL); /* __weak function can be rewritten by the application */
 8013f9e:	480d      	ldr	r0, [pc, #52]	; (8013fd4 <sdram_hw_init+0xac>)
 8013fa0:	2100      	movs	r1, #0
 8013fa2:	f7ff fe63 	bl	8013c6c <SDRAM_MspInit>

  if(HAL_SDRAM_Init(&sdramHandle, &Timing) != HAL_OK)
 8013fa6:	480b      	ldr	r0, [pc, #44]	; (8013fd4 <sdram_hw_init+0xac>)
 8013fa8:	490c      	ldr	r1, [pc, #48]	; (8013fdc <sdram_hw_init+0xb4>)
 8013faa:	f7fa fa57 	bl	800e45c <HAL_SDRAM_Init>
 8013fae:	4603      	mov	r3, r0
 8013fb0:	2b00      	cmp	r3, #0
 8013fb2:	d003      	beq.n	8013fbc <sdram_hw_init+0x94>
  {
    sdramstatus = RT_ERROR;
 8013fb4:	4b0a      	ldr	r3, [pc, #40]	; (8013fe0 <sdram_hw_init+0xb8>)
 8013fb6:	2201      	movs	r2, #1
 8013fb8:	701a      	strb	r2, [r3, #0]
 8013fba:	e002      	b.n	8013fc2 <sdram_hw_init+0x9a>
  }
  else
  {
    sdramstatus = RT_EOK;
 8013fbc:	4b08      	ldr	r3, [pc, #32]	; (8013fe0 <sdram_hw_init+0xb8>)
 8013fbe:	2200      	movs	r2, #0
 8013fc0:	701a      	strb	r2, [r3, #0]
  }
  
  /* SDRAM initialization sequence */
  SDRAM_InitializationSequence(REFRESH_COUNT);
 8013fc2:	f240 6003 	movw	r0, #1539	; 0x603
 8013fc6:	f7ff ff47 	bl	8013e58 <SDRAM_InitializationSequence>
  
  return sdramstatus;
 8013fca:	4b05      	ldr	r3, [pc, #20]	; (8013fe0 <sdram_hw_init+0xb8>)
 8013fcc:	781b      	ldrb	r3, [r3, #0]
}
 8013fce:	4618      	mov	r0, r3
 8013fd0:	bd80      	pop	{r7, pc}
 8013fd2:	bf00      	nop
 8013fd4:	20010834 	.word	0x20010834
 8013fd8:	a0000140 	.word	0xa0000140
 8013fdc:	20010868 	.word	0x20010868
 8013fe0:	20010018 	.word	0x20010018

08013fe4 <DMA2_Stream0_IRQHandler>:
/**
  * @brief  Handles SDRAM DMA transfer interrupt request.
  * @retval None
  */
void SDRAM_DMA_IRQHandler(void)
{
 8013fe4:	b580      	push	{r7, lr}
 8013fe6:	af00      	add	r7, sp, #0
  HAL_DMA_IRQHandler(sdramHandle.hdma); 
 8013fe8:	4b02      	ldr	r3, [pc, #8]	; (8013ff4 <DMA2_Stream0_IRQHandler+0x10>)
 8013fea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013fec:	4618      	mov	r0, r3
 8013fee:	f7f6 f891 	bl	800a114 <HAL_DMA_IRQHandler>
}
 8013ff2:	bd80      	pop	{r7, pc}
 8013ff4:	20010834 	.word	0x20010834

08013ff8 <HAL_TIMEx_BreakCallback>:
#include "MC_Globals.h"

#define ENC_COUNTER_RESET   (u8) 0

void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 8013ff8:	b580      	push	{r7, lr}
 8013ffa:	b082      	sub	sp, #8
 8013ffc:	af00      	add	r7, sp, #0
 8013ffe:	6078      	str	r0, [r7, #4]
	if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8014000:	687b      	ldr	r3, [r7, #4]
 8014002:	681b      	ldr	r3, [r3, #0]
 8014004:	691b      	ldr	r3, [r3, #16]
 8014006:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801400a:	2b00      	cmp	r3, #0
 801400c:	d003      	beq.n	8014016 <HAL_TIMEx_BreakCallback+0x1e>
	{
		rt_kprintf(" BREAK1 is triggered\r\n");
 801400e:	480a      	ldr	r0, [pc, #40]	; (8014038 <HAL_TIMEx_BreakCallback+0x40>)
 8014010:	f003 fc54 	bl	80178bc <rt_kprintf>
 8014014:	e00d      	b.n	8014032 <HAL_TIMEx_BreakCallback+0x3a>
		  //MCL_SetFault(OVER_CURRENT);
	}
	else if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8014016:	687b      	ldr	r3, [r7, #4]
 8014018:	681b      	ldr	r3, [r3, #0]
 801401a:	691b      	ldr	r3, [r3, #16]
 801401c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8014020:	2b00      	cmp	r3, #0
 8014022:	d003      	beq.n	801402c <HAL_TIMEx_BreakCallback+0x34>
	{
		rt_kprintf(" BREAK2 is triggered\r\n");
 8014024:	4805      	ldr	r0, [pc, #20]	; (801403c <HAL_TIMEx_BreakCallback+0x44>)
 8014026:	f003 fc49 	bl	80178bc <rt_kprintf>
 801402a:	e002      	b.n	8014032 <HAL_TIMEx_BreakCallback+0x3a>
		  //MCL_SetFault(OVER_CURRENT);
	}
	else 
	{
		rt_kprintf("TIM8 is triggered\r\n");
 801402c:	4804      	ldr	r0, [pc, #16]	; (8014040 <HAL_TIMEx_BreakCallback+0x48>)
 801402e:	f003 fc45 	bl	80178bc <rt_kprintf>
	}

}
 8014032:	3708      	adds	r7, #8
 8014034:	46bd      	mov	sp, r7
 8014036:	bd80      	pop	{r7, pc}
 8014038:	080270c0 	.word	0x080270c0
 801403c:	080270d8 	.word	0x080270d8
 8014040:	080270f0 	.word	0x080270f0

08014044 <TIM8_BRK_TIM12_IRQHandler>:


void TIM8_BRK_TIM12_IRQHandler(void)
{
 8014044:	b580      	push	{r7, lr}
 8014046:	b090      	sub	sp, #64	; 0x40
 8014048:	af00      	add	r7, sp, #0
	TIM_HandleTypeDef	 TimHandle;
	
	/* Set TIMx instance */
	
	/*enter interrupt */
	rt_interrupt_enter();
 801404a:	f002 fe27 	bl	8016c9c <rt_interrupt_enter>
	
	TimHandle.Instance = TIM8;
 801404e:	4b05      	ldr	r3, [pc, #20]	; (8014064 <TIM8_BRK_TIM12_IRQHandler+0x20>)
 8014050:	607b      	str	r3, [r7, #4]
	HAL_TIM_IRQHandler(&TimHandle);
 8014052:	1d3b      	adds	r3, r7, #4
 8014054:	4618      	mov	r0, r3
 8014056:	f7fa fc8d 	bl	800e974 <HAL_TIM_IRQHandler>
		
    /* leave interrupt */
    rt_interrupt_leave();
 801405a:	f002 fe35 	bl	8016cc8 <rt_interrupt_leave>

}
 801405e:	3740      	adds	r7, #64	; 0x40
 8014060:	46bd      	mov	sp, r7
 8014062:	bd80      	pop	{r7, pc}
 8014064:	40010400 	.word	0x40010400

08014068 <TIM8_UP_TIM13_IRQHandler>:

void TIM8_UP_TIM13_IRQHandler(void)
{
 8014068:	b580      	push	{r7, lr}
 801406a:	b090      	sub	sp, #64	; 0x40
 801406c:	af00      	add	r7, sp, #0
	TIM_HandleTypeDef	 TimHandle;
	rt_interrupt_enter();
 801406e:	f002 fe15 	bl	8016c9c <rt_interrupt_enter>
	HAL_GPIO_WritePin(GPIOI,GPIO_PIN_3, GPIO_PIN_SET);
 8014072:	480a      	ldr	r0, [pc, #40]	; (801409c <TIM8_UP_TIM13_IRQHandler+0x34>)
 8014074:	2108      	movs	r1, #8
 8014076:	2201      	movs	r2, #1
 8014078:	f7f9 fc60 	bl	800d93c <HAL_GPIO_WritePin>
	TimHandle.Instance = TIM8;
 801407c:	4b08      	ldr	r3, [pc, #32]	; (80140a0 <TIM8_UP_TIM13_IRQHandler+0x38>)
 801407e:	607b      	str	r3, [r7, #4]
	HAL_TIM_IRQHandler(&TimHandle);
 8014080:	1d3b      	adds	r3, r7, #4
 8014082:	4618      	mov	r0, r3
 8014084:	f7fa fc76 	bl	800e974 <HAL_TIM_IRQHandler>
	HAL_GPIO_WritePin(GPIOI,GPIO_PIN_3, GPIO_PIN_RESET);
 8014088:	4804      	ldr	r0, [pc, #16]	; (801409c <TIM8_UP_TIM13_IRQHandler+0x34>)
 801408a:	2108      	movs	r1, #8
 801408c:	2200      	movs	r2, #0
 801408e:	f7f9 fc55 	bl	800d93c <HAL_GPIO_WritePin>
    /* leave interrupt */
    rt_interrupt_leave();
 8014092:	f002 fe19 	bl	8016cc8 <rt_interrupt_leave>
}
 8014096:	3740      	adds	r7, #64	; 0x40
 8014098:	46bd      	mov	sp, r7
 801409a:	bd80      	pop	{r7, pc}
 801409c:	40022000 	.word	0x40022000
 80140a0:	40010400 	.word	0x40010400

080140a4 <SetDutyCycles>:
	TIMx->CNT = ENC_COUNTER_RESET;

}

extern void SetDutyCycles(TIM_TypeDef *TIMx, u16 hTimePhA, u16 hTimePhB, u16 hTimePhC)
{
 80140a4:	b480      	push	{r7}
 80140a6:	b085      	sub	sp, #20
 80140a8:	af00      	add	r7, sp, #0
 80140aa:	60f8      	str	r0, [r7, #12]
 80140ac:	4608      	mov	r0, r1
 80140ae:	4611      	mov	r1, r2
 80140b0:	461a      	mov	r2, r3
 80140b2:	4603      	mov	r3, r0
 80140b4:	817b      	strh	r3, [r7, #10]
 80140b6:	460b      	mov	r3, r1
 80140b8:	813b      	strh	r3, [r7, #8]
 80140ba:	4613      	mov	r3, r2
 80140bc:	80fb      	strh	r3, [r7, #6]
	TIMx->CCR1 = hTimePhA;
 80140be:	897a      	ldrh	r2, [r7, #10]
 80140c0:	68fb      	ldr	r3, [r7, #12]
 80140c2:	635a      	str	r2, [r3, #52]	; 0x34
	TIMx->CCR2 = hTimePhB;
 80140c4:	893a      	ldrh	r2, [r7, #8]
 80140c6:	68fb      	ldr	r3, [r7, #12]
 80140c8:	639a      	str	r2, [r3, #56]	; 0x38
	TIMx->CCR3 = hTimePhC;
 80140ca:	88fa      	ldrh	r2, [r7, #6]
 80140cc:	68fb      	ldr	r3, [r7, #12]
 80140ce:	63da      	str	r2, [r3, #60]	; 0x3c
}
 80140d0:	3714      	adds	r7, #20
 80140d2:	46bd      	mov	sp, r7
 80140d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80140d8:	4770      	bx	lr
 80140da:	bf00      	nop

080140dc <PWMOutputsEnable>:


extern void PWMOutputsEnable(TIM_TypeDef *TIMx)
{
 80140dc:	b580      	push	{r7, lr}
 80140de:	b082      	sub	sp, #8
 80140e0:	af00      	add	r7, sp, #0
 80140e2:	6078      	str	r0, [r7, #4]
	TIMx->BDTR |= TIM_BDTR_MOE;
 80140e4:	687b      	ldr	r3, [r7, #4]
 80140e6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80140e8:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
 80140ec:	687b      	ldr	r3, [r7, #4]
 80140ee:	645a      	str	r2, [r3, #68]	; 0x44
	HAL_GPIO_WritePin(OCDRELEASE_PORT,OCDRELEASE_PIN,GPIO_PIN_SET);
 80140f0:	4808      	ldr	r0, [pc, #32]	; (8014114 <PWMOutputsEnable+0x38>)
 80140f2:	f44f 7180 	mov.w	r1, #256	; 0x100
 80140f6:	2201      	movs	r2, #1
 80140f8:	f7f9 fc20 	bl	800d93c <HAL_GPIO_WritePin>
	rt_thread_delay(20);
 80140fc:	2014      	movs	r0, #20
 80140fe:	f004 fe87 	bl	8018e10 <rt_thread_delay>
	HAL_GPIO_WritePin(OCDRELEASE_PORT,OCDRELEASE_PIN,GPIO_PIN_RESET);
 8014102:	4804      	ldr	r0, [pc, #16]	; (8014114 <PWMOutputsEnable+0x38>)
 8014104:	f44f 7180 	mov.w	r1, #256	; 0x100
 8014108:	2200      	movs	r2, #0
 801410a:	f7f9 fc17 	bl	800d93c <HAL_GPIO_WritePin>
}
 801410e:	3708      	adds	r7, #8
 8014110:	46bd      	mov	sp, r7
 8014112:	bd80      	pop	{r7, pc}
 8014114:	40020000 	.word	0x40020000

08014118 <PWMOutputsDisable>:


extern void PWMOutputsDisable(TIM_TypeDef *TIMx)
{
 8014118:	b480      	push	{r7}
 801411a:	b083      	sub	sp, #12
 801411c:	af00      	add	r7, sp, #0
 801411e:	6078      	str	r0, [r7, #4]
	TIMx->BDTR &= (~TIM_BDTR_MOE);
 8014120:	687b      	ldr	r3, [r7, #4]
 8014122:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8014124:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
 8014128:	687b      	ldr	r3, [r7, #4]
 801412a:	645a      	str	r2, [r3, #68]	; 0x44
}
 801412c:	370c      	adds	r7, #12
 801412e:	46bd      	mov	sp, r7
 8014130:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014134:	4770      	bx	lr
 8014136:	bf00      	nop

08014138 <HAL_TIM_PWM_MspInit>:
  *           - NVIC configuration for UART interrupt request enable
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
{
 8014138:	b580      	push	{r7, lr}
 801413a:	b08e      	sub	sp, #56	; 0x38
 801413c:	af00      	add	r7, sp, #0
 801413e:	6078      	str	r0, [r7, #4]
	GPIO_InitTypeDef GPIO_Init;
    if (htim->Instance == TIM8)
 8014140:	687b      	ldr	r3, [r7, #4]
 8014142:	681b      	ldr	r3, [r3, #0]
 8014144:	4a47      	ldr	r2, [pc, #284]	; (8014264 <HAL_TIM_PWM_MspInit+0x12c>)
 8014146:	4293      	cmp	r3, r2
 8014148:	f040 8089 	bne.w	801425e <HAL_TIM_PWM_MspInit+0x126>
    {
        /* Enable GPIO clock */
        TIM8_GPIOA_CLK_ENABLE();
 801414c:	4a46      	ldr	r2, [pc, #280]	; (8014268 <HAL_TIM_PWM_MspInit+0x130>)
 801414e:	4b46      	ldr	r3, [pc, #280]	; (8014268 <HAL_TIM_PWM_MspInit+0x130>)
 8014150:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014152:	f043 0301 	orr.w	r3, r3, #1
 8014156:	6313      	str	r3, [r2, #48]	; 0x30
 8014158:	4b43      	ldr	r3, [pc, #268]	; (8014268 <HAL_TIM_PWM_MspInit+0x130>)
 801415a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801415c:	f003 0301 	and.w	r3, r3, #1
 8014160:	623b      	str	r3, [r7, #32]
 8014162:	6a3b      	ldr	r3, [r7, #32]
        TIM8_GPIOB_CLK_ENABLE();
 8014164:	4a40      	ldr	r2, [pc, #256]	; (8014268 <HAL_TIM_PWM_MspInit+0x130>)
 8014166:	4b40      	ldr	r3, [pc, #256]	; (8014268 <HAL_TIM_PWM_MspInit+0x130>)
 8014168:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801416a:	f043 0302 	orr.w	r3, r3, #2
 801416e:	6313      	str	r3, [r2, #48]	; 0x30
 8014170:	4b3d      	ldr	r3, [pc, #244]	; (8014268 <HAL_TIM_PWM_MspInit+0x130>)
 8014172:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014174:	f003 0302 	and.w	r3, r3, #2
 8014178:	61fb      	str	r3, [r7, #28]
 801417a:	69fb      	ldr	r3, [r7, #28]
		TIM8_GPIOC_CLK_ENABLE();
 801417c:	4a3a      	ldr	r2, [pc, #232]	; (8014268 <HAL_TIM_PWM_MspInit+0x130>)
 801417e:	4b3a      	ldr	r3, [pc, #232]	; (8014268 <HAL_TIM_PWM_MspInit+0x130>)
 8014180:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014182:	f043 0304 	orr.w	r3, r3, #4
 8014186:	6313      	str	r3, [r2, #48]	; 0x30
 8014188:	4b37      	ldr	r3, [pc, #220]	; (8014268 <HAL_TIM_PWM_MspInit+0x130>)
 801418a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801418c:	f003 0304 	and.w	r3, r3, #4
 8014190:	61bb      	str	r3, [r7, #24]
 8014192:	69bb      	ldr	r3, [r7, #24]
        TIM8_GPIOH_CLK_ENABLE();
 8014194:	4a34      	ldr	r2, [pc, #208]	; (8014268 <HAL_TIM_PWM_MspInit+0x130>)
 8014196:	4b34      	ldr	r3, [pc, #208]	; (8014268 <HAL_TIM_PWM_MspInit+0x130>)
 8014198:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801419a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 801419e:	6313      	str	r3, [r2, #48]	; 0x30
 80141a0:	4b31      	ldr	r3, [pc, #196]	; (8014268 <HAL_TIM_PWM_MspInit+0x130>)
 80141a2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80141a4:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80141a8:	617b      	str	r3, [r7, #20]
 80141aa:	697b      	ldr	r3, [r7, #20]
		TIM8_GPIOI_CLK_ENABLE();
 80141ac:	4a2e      	ldr	r2, [pc, #184]	; (8014268 <HAL_TIM_PWM_MspInit+0x130>)
 80141ae:	4b2e      	ldr	r3, [pc, #184]	; (8014268 <HAL_TIM_PWM_MspInit+0x130>)
 80141b0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80141b2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80141b6:	6313      	str	r3, [r2, #48]	; 0x30
 80141b8:	4b2b      	ldr	r3, [pc, #172]	; (8014268 <HAL_TIM_PWM_MspInit+0x130>)
 80141ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80141bc:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80141c0:	613b      	str	r3, [r7, #16]
 80141c2:	693b      	ldr	r3, [r7, #16]

        /* Enable TIMx clock */
        TIM8_CLK_ENABLE();
 80141c4:	4a28      	ldr	r2, [pc, #160]	; (8014268 <HAL_TIM_PWM_MspInit+0x130>)
 80141c6:	4b28      	ldr	r3, [pc, #160]	; (8014268 <HAL_TIM_PWM_MspInit+0x130>)
 80141c8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80141ca:	f043 0302 	orr.w	r3, r3, #2
 80141ce:	6453      	str	r3, [r2, #68]	; 0x44
 80141d0:	4b25      	ldr	r3, [pc, #148]	; (8014268 <HAL_TIM_PWM_MspInit+0x130>)
 80141d2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80141d4:	f003 0302 	and.w	r3, r3, #2
 80141d8:	60fb      	str	r3, [r7, #12]
 80141da:	68fb      	ldr	r3, [r7, #12]

        /* GPIO pin configuration  */
	 	GPIO_Init.Pin = PWMWP_PIN | PWMVP_PIN | PWMBREAK_PIN;
 80141dc:	f44f 7330 	mov.w	r3, #704	; 0x2c0
 80141e0:	627b      	str	r3, [r7, #36]	; 0x24
		GPIO_Init.Mode = GPIO_MODE_AF_PP;
 80141e2:	2302      	movs	r3, #2
 80141e4:	62bb      	str	r3, [r7, #40]	; 0x28
		GPIO_Init.Pull = GPIO_PULLUP;
 80141e6:	2301      	movs	r3, #1
 80141e8:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_Init.Speed = GPIO_SPEED_LOW;
 80141ea:	2300      	movs	r3, #0
 80141ec:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_Init.Alternate = PWMWP_AF;
 80141ee:	2303      	movs	r3, #3
 80141f0:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PWMWP_GPIO_PORT,&GPIO_Init);
 80141f2:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80141f6:	481d      	ldr	r0, [pc, #116]	; (801426c <HAL_TIM_PWM_MspInit+0x134>)
 80141f8:	4619      	mov	r1, r3
 80141fa:	f7f9 f8ef 	bl	800d3dc <HAL_GPIO_Init>
		
	 	GPIO_Init.Pin = PWMUP_PIN;
 80141fe:	2380      	movs	r3, #128	; 0x80
 8014200:	627b      	str	r3, [r7, #36]	; 0x24
		HAL_GPIO_Init(PWMUP_GPIO_PORT,&GPIO_Init);
 8014202:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8014206:	481a      	ldr	r0, [pc, #104]	; (8014270 <HAL_TIM_PWM_MspInit+0x138>)
 8014208:	4619      	mov	r1, r3
 801420a:	f7f9 f8e7 	bl	800d3dc <HAL_GPIO_Init>

		GPIO_Init.Pin = PWMWN_PIN | PWMVN_PIN | PWMUN_PIN;
 801420e:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 8014212:	627b      	str	r3, [r7, #36]	; 0x24
		HAL_GPIO_Init(PWMWN_GPIO_PORT,&GPIO_Init);
 8014214:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8014218:	4816      	ldr	r0, [pc, #88]	; (8014274 <HAL_TIM_PWM_MspInit+0x13c>)
 801421a:	4619      	mov	r1, r3
 801421c:	f7f9 f8de 	bl	800d3dc <HAL_GPIO_Init>

		GPIO_Init.Pin = FAULT1_PIN | FAULT2_PIN;
 8014220:	2312      	movs	r3, #18
 8014222:	627b      	str	r3, [r7, #36]	; 0x24
		HAL_GPIO_Init(FAULT1_GPIO_PORT,&GPIO_Init);
 8014224:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8014228:	4811      	ldr	r0, [pc, #68]	; (8014270 <HAL_TIM_PWM_MspInit+0x138>)
 801422a:	4619      	mov	r1, r3
 801422c:	f7f9 f8d6 	bl	800d3dc <HAL_GPIO_Init>

		GPIO_Init.Pin = OCDRELEASE_PIN;
 8014230:	f44f 7380 	mov.w	r3, #256	; 0x100
 8014234:	627b      	str	r3, [r7, #36]	; 0x24
		GPIO_Init.Mode = GPIO_MODE_OUTPUT_PP;
 8014236:	2301      	movs	r3, #1
 8014238:	62bb      	str	r3, [r7, #40]	; 0x28
		GPIO_Init.Pull = GPIO_PULLUP;
 801423a:	2301      	movs	r3, #1
 801423c:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_Init.Speed = GPIO_SPEED_LOW;
 801423e:	2300      	movs	r3, #0
 8014240:	633b      	str	r3, [r7, #48]	; 0x30
		HAL_GPIO_Init(OCDRELEASE_PORT,&GPIO_Init);
 8014242:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8014246:	480c      	ldr	r0, [pc, #48]	; (8014278 <HAL_TIM_PWM_MspInit+0x140>)
 8014248:	4619      	mov	r1, r3
 801424a:	f7f9 f8c7 	bl	800d3dc <HAL_GPIO_Init>
        /* NVIC for BRK */
        HAL_NVIC_SetPriority(TIM8_BRK_TIM12_IRQn, TIM8_BRK_TIM12_IRQ_PREEMPT, TIM8_BRK_TIM12_IRQ_SUB );
 801424e:	202b      	movs	r0, #43	; 0x2b
 8014250:	2100      	movs	r1, #0
 8014252:	2200      	movs	r2, #0
 8014254:	f7f4 fbde 	bl	8008a14 <HAL_NVIC_SetPriority>
        HAL_NVIC_EnableIRQ(TIM8_BRK_TIM12_IRQn);
 8014258:	202b      	movs	r0, #43	; 0x2b
 801425a:	f7f4 fbf7 	bl	8008a4c <HAL_NVIC_EnableIRQ>
		#ifdef TIM8UPDATEITENABLE
		HAL_NVIC_SetPriority(TIM8_UP_TIM13_IRQn, TIM8_BRK_TIM12_IRQ_PREEMPT, TIM8_BRK_TIM12_IRQ_SUB );
        HAL_NVIC_EnableIRQ(TIM8_UP_TIM13_IRQn);
		#endif
    }
}
 801425e:	3738      	adds	r7, #56	; 0x38
 8014260:	46bd      	mov	sp, r7
 8014262:	bd80      	pop	{r7, pc}
 8014264:	40010400 	.word	0x40010400
 8014268:	40023800 	.word	0x40023800
 801426c:	40020800 	.word	0x40020800
 8014270:	40022000 	.word	0x40022000
 8014274:	40021c00 	.word	0x40021c00
 8014278:	40020000 	.word	0x40020000

0801427c <HAL_TIM_PWM_MspDeInit>:
  *          - Revert GPIO and NVIC configuration to their default state
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
{
 801427c:	b580      	push	{r7, lr}
 801427e:	b082      	sub	sp, #8
 8014280:	af00      	add	r7, sp, #0
 8014282:	6078      	str	r0, [r7, #4]
    if (htim->Instance == TIM8)
 8014284:	687b      	ldr	r3, [r7, #4]
 8014286:	681b      	ldr	r3, [r3, #0]
 8014288:	4a11      	ldr	r2, [pc, #68]	; (80142d0 <HAL_TIM_PWM_MspDeInit+0x54>)
 801428a:	4293      	cmp	r3, r2
 801428c:	d11c      	bne.n	80142c8 <HAL_TIM_PWM_MspDeInit+0x4c>
    {
        /* Reset peripherals */
        TIM8_FORCE_RESET();
 801428e:	4a11      	ldr	r2, [pc, #68]	; (80142d4 <HAL_TIM_PWM_MspDeInit+0x58>)
 8014290:	4b10      	ldr	r3, [pc, #64]	; (80142d4 <HAL_TIM_PWM_MspDeInit+0x58>)
 8014292:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014294:	f043 0302 	orr.w	r3, r3, #2
 8014298:	6253      	str	r3, [r2, #36]	; 0x24
        TIM8_RELEASE_RESET();
 801429a:	4a0e      	ldr	r2, [pc, #56]	; (80142d4 <HAL_TIM_PWM_MspDeInit+0x58>)
 801429c:	4b0d      	ldr	r3, [pc, #52]	; (80142d4 <HAL_TIM_PWM_MspDeInit+0x58>)
 801429e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80142a0:	f023 0302 	bic.w	r3, r3, #2
 80142a4:	6253      	str	r3, [r2, #36]	; 0x24

        /* Disable peripherals and GPIO Clocks */
        HAL_GPIO_DeInit(PWMWP_GPIO_PORT, PWMWP_PIN | PWMVP_PIN | PWMUP_PIN | PWMBREAK_PIN);
 80142a6:	480c      	ldr	r0, [pc, #48]	; (80142d8 <HAL_TIM_PWM_MspDeInit+0x5c>)
 80142a8:	f44f 7130 	mov.w	r1, #704	; 0x2c0
 80142ac:	f7f9 fa3c 	bl	800d728 <HAL_GPIO_DeInit>
        HAL_GPIO_DeInit(PWMWN_GPIO_PORT, PWMWN_PIN | PWMVN_PIN | PWMUN_PIN);
 80142b0:	480a      	ldr	r0, [pc, #40]	; (80142dc <HAL_TIM_PWM_MspDeInit+0x60>)
 80142b2:	f44f 4160 	mov.w	r1, #57344	; 0xe000
 80142b6:	f7f9 fa37 	bl	800d728 <HAL_GPIO_DeInit>
        HAL_GPIO_DeInit(FAULT1_GPIO_PORT, FAULT1_PIN | FAULT2_PIN);
 80142ba:	4809      	ldr	r0, [pc, #36]	; (80142e0 <HAL_TIM_PWM_MspDeInit+0x64>)
 80142bc:	2112      	movs	r1, #18
 80142be:	f7f9 fa33 	bl	800d728 <HAL_GPIO_DeInit>
		
        HAL_NVIC_DisableIRQ(TIM8_BRK_TIM12_IRQn);
 80142c2:	202b      	movs	r0, #43	; 0x2b
 80142c4:	f7f4 fbd0 	bl	8008a68 <HAL_NVIC_DisableIRQ>
		
		#ifdef TIM8UPDATEITENABLE
        HAL_NVIC_DisableIRQ(TIM8_UP_TIM13_IRQn);
		#endif
    }
}
 80142c8:	3708      	adds	r7, #8
 80142ca:	46bd      	mov	sp, r7
 80142cc:	bd80      	pop	{r7, pc}
 80142ce:	bf00      	nop
 80142d0:	40010400 	.word	0x40010400
 80142d4:	40023800 	.word	0x40023800
 80142d8:	40020800 	.word	0x40020800
 80142dc:	40021c00 	.word	0x40021c00
 80142e0:	40022000 	.word	0x40022000

080142e4 <stm32_hw_tim8_init>:


extern int stm32_hw_tim8_init(void)
{
 80142e4:	b580      	push	{r7, lr}
 80142e6:	b0a6      	sub	sp, #152	; 0x98
 80142e8:	af00      	add	r7, sp, #0
	TIM_OC_InitTypeDef PwmConfig;
	TIM_BreakDeadTimeConfigTypeDef PwmBDTRconfig;
	TIM_MasterConfigTypeDef TIM8MasterConfig;
	char deadtime;
	/* Set TIMx instance */
	TimHandle.Instance = TIM8;
 80142ea:	4b65      	ldr	r3, [pc, #404]	; (8014480 <stm32_hw_tim8_init+0x19c>)
 80142ec:	65bb      	str	r3, [r7, #88]	; 0x58

	HAL_TIM_PWM_DeInit(&TimHandle);
 80142ee:	f107 0358 	add.w	r3, r7, #88	; 0x58
 80142f2:	4618      	mov	r0, r3
 80142f4:	f7fa f9a4 	bl	800e640 <HAL_TIM_PWM_DeInit>

	/* Initialize TIMx peripheral	*/
	TimHandle.Init.Period            = PWM_PERIOD;
 80142f8:	f44f 5396 	mov.w	r3, #4800	; 0x12c0
 80142fc:	667b      	str	r3, [r7, #100]	; 0x64
	TimHandle.Init.Prescaler         = PWM_PRSC;
 80142fe:	2300      	movs	r3, #0
 8014300:	65fb      	str	r3, [r7, #92]	; 0x5c
	TimHandle.Init.ClockDivision     = TIM_CLOCKDIVISION_DIV2;
 8014302:	f44f 7380 	mov.w	r3, #256	; 0x100
 8014306:	66bb      	str	r3, [r7, #104]	; 0x68
	TimHandle.Init.CounterMode       = TIM_COUNTERMODE_CENTERALIGNED1;
 8014308:	2320      	movs	r3, #32
 801430a:	663b      	str	r3, [r7, #96]	; 0x60
	TimHandle.Init.RepetitionCounter = REP_RATE;
 801430c:	2301      	movs	r3, #1
 801430e:	66fb      	str	r3, [r7, #108]	; 0x6c
	if (HAL_TIM_PWM_Init(&TimHandle) != HAL_OK)
 8014310:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8014314:	4618      	mov	r0, r3
 8014316:	f7fa f967 	bl	800e5e8 <HAL_TIM_PWM_Init>
	{
	  /* Initialization Error */
	  /*Error_Handler(); */
	}
	PwmConfig.OCMode = TIM_OCMODE_PWM1;
 801431a:	2360      	movs	r3, #96	; 0x60
 801431c:	63fb      	str	r3, [r7, #60]	; 0x3c
	PwmConfig.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 801431e:	2300      	movs	r3, #0
 8014320:	64bb      	str	r3, [r7, #72]	; 0x48
	PwmConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
 8014322:	2300      	movs	r3, #0
 8014324:	647b      	str	r3, [r7, #68]	; 0x44
	PwmConfig.OCIdleState = TIM_OCIDLESTATE_RESET;
 8014326:	2300      	movs	r3, #0
 8014328:	653b      	str	r3, [r7, #80]	; 0x50
	PwmConfig.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 801432a:	2300      	movs	r3, #0
 801432c:	657b      	str	r3, [r7, #84]	; 0x54
	PwmConfig.Pulse = PWM_PERIOD/2;
 801432e:	f44f 6316 	mov.w	r3, #2400	; 0x960
 8014332:	643b      	str	r3, [r7, #64]	; 0x40
	PwmConfig.OCFastMode = TIM_OCFAST_DISABLE;
 8014334:	2300      	movs	r3, #0
 8014336:	64fb      	str	r3, [r7, #76]	; 0x4c
	HAL_TIM_PWM_ConfigChannel(&TimHandle,&PwmConfig, TIM_CHANNEL_1);
 8014338:	f107 0258 	add.w	r2, r7, #88	; 0x58
 801433c:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 8014340:	4610      	mov	r0, r2
 8014342:	4619      	mov	r1, r3
 8014344:	2200      	movs	r2, #0
 8014346:	f7fa feed 	bl	800f124 <HAL_TIM_PWM_ConfigChannel>
	HAL_TIM_PWM_ConfigChannel(&TimHandle,&PwmConfig, TIM_CHANNEL_2);
 801434a:	f107 0258 	add.w	r2, r7, #88	; 0x58
 801434e:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 8014352:	4610      	mov	r0, r2
 8014354:	4619      	mov	r1, r3
 8014356:	2204      	movs	r2, #4
 8014358:	f7fa fee4 	bl	800f124 <HAL_TIM_PWM_ConfigChannel>
	HAL_TIM_PWM_ConfigChannel(&TimHandle,&PwmConfig, TIM_CHANNEL_3);
 801435c:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8014360:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 8014364:	4610      	mov	r0, r2
 8014366:	4619      	mov	r1, r3
 8014368:	2208      	movs	r2, #8
 801436a:	f7fa fedb 	bl	800f124 <HAL_TIM_PWM_ConfigChannel>
	HAL_TIM_PWM_ConfigChannel(&TimHandle,&PwmConfig, TIM_CHANNEL_3);
 801436e:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8014372:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 8014376:	4610      	mov	r0, r2
 8014378:	4619      	mov	r1, r3
 801437a:	2208      	movs	r2, #8
 801437c:	f7fa fed2 	bl	800f124 <HAL_TIM_PWM_ConfigChannel>

	TIM_OC1_SetConfig(TIM8,&PwmConfig);
 8014380:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 8014384:	483e      	ldr	r0, [pc, #248]	; (8014480 <stm32_hw_tim8_init+0x19c>)
 8014386:	4619      	mov	r1, r3
 8014388:	f7fa fce2 	bl	800ed50 <TIM_OC1_SetConfig>
	TIM_OC2_SetConfig(TIM8,&PwmConfig);
 801438c:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 8014390:	483b      	ldr	r0, [pc, #236]	; (8014480 <stm32_hw_tim8_init+0x19c>)
 8014392:	4619      	mov	r1, r3
 8014394:	f7fa fd50 	bl	800ee38 <TIM_OC2_SetConfig>
	TIM_OC3_SetConfig(TIM8,&PwmConfig);
 8014398:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801439c:	4838      	ldr	r0, [pc, #224]	; (8014480 <stm32_hw_tim8_init+0x19c>)
 801439e:	4619      	mov	r1, r3
 80143a0:	f7fa fdc4 	bl	800ef2c <TIM_OC3_SetConfig>
	TIM_OC4_SetConfig(TIM8,&PwmConfig);
 80143a4:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 80143a8:	4835      	ldr	r0, [pc, #212]	; (8014480 <stm32_hw_tim8_init+0x19c>)
 80143aa:	4619      	mov	r1, r3
 80143ac:	f7fa fe36 	bl	800f01c <TIM_OC4_SetConfig>

	if (DEADTIME1 < 128)
		deadtime = DEADTIME1;
	else if( DEADTIME2 <64)
		deadtime  = DEADTIME2 | 0x80;
 80143b0:	238c      	movs	r3, #140	; 0x8c
 80143b2:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
	else if( DEADTIME3 < 32)
		deadtime = DEADTIME3 | 0xC0;
	else
		deadtime = DEADTIME4 | 0xE0;
	PwmBDTRconfig.DeadTime  = deadtime;
 80143b6:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 80143ba:	61fb      	str	r3, [r7, #28]
	PwmBDTRconfig.LockLevel = TIM_LOCKLEVEL_1;
 80143bc:	f44f 7380 	mov.w	r3, #256	; 0x100
 80143c0:	61bb      	str	r3, [r7, #24]
	PwmBDTRconfig.OffStateRunMode = TIM_OSSR_ENABLE;
 80143c2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80143c6:	613b      	str	r3, [r7, #16]
	PwmBDTRconfig.OffStateIDLEMode = TIM_OSSI_ENABLE;
 80143c8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80143cc:	617b      	str	r3, [r7, #20]
	PwmBDTRconfig.Break2State = TIM_BREAK2_ENABLE;
 80143ce:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80143d2:	62fb      	str	r3, [r7, #44]	; 0x2c
	PwmBDTRconfig.Break2Polarity = TIM_BREAK2POLARITY_LOW;
 80143d4:	2300      	movs	r3, #0
 80143d6:	633b      	str	r3, [r7, #48]	; 0x30
	PwmBDTRconfig.Break2Filter = 0x0;
 80143d8:	2300      	movs	r3, #0
 80143da:	637b      	str	r3, [r7, #52]	; 0x34
	PwmBDTRconfig.BreakState = TIM_BREAK_ENABLE;
 80143dc:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80143e0:	623b      	str	r3, [r7, #32]
	PwmBDTRconfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 80143e2:	2300      	movs	r3, #0
 80143e4:	63bb      	str	r3, [r7, #56]	; 0x38
	PwmBDTRconfig.BreakPolarity = TIM_BREAKPOLARITY_LOW;
 80143e6:	2300      	movs	r3, #0
 80143e8:	627b      	str	r3, [r7, #36]	; 0x24
	PwmBDTRconfig.BreakFilter = 0x0;
 80143ea:	2300      	movs	r3, #0
 80143ec:	62bb      	str	r3, [r7, #40]	; 0x28
	HAL_TIMEx_ConfigBreakDeadTime(&TimHandle,&PwmBDTRconfig);
 80143ee:	f107 0258 	add.w	r2, r7, #88	; 0x58
 80143f2:	f107 0310 	add.w	r3, r7, #16
 80143f6:	4610      	mov	r0, r2
 80143f8:	4619      	mov	r1, r3
 80143fa:	f7fa ffff 	bl	800f3fc <HAL_TIMEx_ConfigBreakDeadTime>

	TIM8MasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 80143fe:	2300      	movs	r3, #0
 8014400:	607b      	str	r3, [r7, #4]
	TIM8MasterConfig.MasterOutputTrigger2 = TIM_TRGO2_UPDATE;
 8014402:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8014406:	60bb      	str	r3, [r7, #8]
	TIM8MasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_ENABLE;
 8014408:	2380      	movs	r3, #128	; 0x80
 801440a:	60fb      	str	r3, [r7, #12]
	HAL_TIMEx_MasterConfigSynchronization(&TimHandle,&TIM8MasterConfig);
 801440c:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8014410:	1d3b      	adds	r3, r7, #4
 8014412:	4610      	mov	r0, r2
 8014414:	4619      	mov	r1, r3
 8014416:	f7fa ff9d 	bl	800f354 <HAL_TIMEx_MasterConfigSynchronization>
	
	TIM8->CCER |= TIM_CCER_CC3E | TIM_CCER_CC3NE | TIM_CCER_CC2E | \
 801441a:	4919      	ldr	r1, [pc, #100]	; (8014480 <stm32_hw_tim8_init+0x19c>)
 801441c:	4b18      	ldr	r3, [pc, #96]	; (8014480 <stm32_hw_tim8_init+0x19c>)
 801441e:	6a1a      	ldr	r2, [r3, #32]
 8014420:	f241 5355 	movw	r3, #5461	; 0x1555
 8014424:	4313      	orrs	r3, r2
 8014426:	620b      	str	r3, [r1, #32]
					TIM_CCER_CC2NE | TIM_CCER_CC1E | TIM_CCER_CC1NE | TIM_CCER_CC4E;
	TIM8->BDTR |= TIM_BDTR_OSSI | TIM_BDTR_OSSR;
 8014428:	4a15      	ldr	r2, [pc, #84]	; (8014480 <stm32_hw_tim8_init+0x19c>)
 801442a:	4b15      	ldr	r3, [pc, #84]	; (8014480 <stm32_hw_tim8_init+0x19c>)
 801442c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801442e:	f443 6340 	orr.w	r3, r3, #3072	; 0xc00
 8014432:	6453      	str	r3, [r2, #68]	; 0x44

	
	HAL_TIM_PWM_Start(&TimHandle,TIM_CHANNEL_1);
 8014434:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8014438:	4618      	mov	r0, r3
 801443a:	2100      	movs	r1, #0
 801443c:	f7fa f930 	bl	800e6a0 <HAL_TIM_PWM_Start>
	HAL_TIM_PWM_Start(&TimHandle,TIM_CHANNEL_2);
 8014440:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8014444:	4618      	mov	r0, r3
 8014446:	2104      	movs	r1, #4
 8014448:	f7fa f92a 	bl	800e6a0 <HAL_TIM_PWM_Start>
	HAL_TIM_PWM_Start(&TimHandle,TIM_CHANNEL_3);
 801444c:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8014450:	4618      	mov	r0, r3
 8014452:	2108      	movs	r1, #8
 8014454:	f7fa f924 	bl	800e6a0 <HAL_TIM_PWM_Start>
	HAL_TIM_PWM_Start(&TimHandle,TIM_CHANNEL_4);
 8014458:	f107 0358 	add.w	r3, r7, #88	; 0x58
 801445c:	4618      	mov	r0, r3
 801445e:	210c      	movs	r1, #12
 8014460:	f7fa f91e 	bl	800e6a0 <HAL_TIM_PWM_Start>
	
	__HAL_TIM_ENABLE_IT(&TimHandle, TIM_IT_BREAK);
 8014464:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014466:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8014468:	68d2      	ldr	r2, [r2, #12]
 801446a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 801446e:	60da      	str	r2, [r3, #12]
	#ifdef TIM8UPDATEITENABLE
	__HAL_TIM_ENABLE_IT(&TimHandle, TIM_IT_UPDATE);
	#endif
	PWMOutputsDisable(TIM8);
 8014470:	4803      	ldr	r0, [pc, #12]	; (8014480 <stm32_hw_tim8_init+0x19c>)
 8014472:	f7ff fe51 	bl	8014118 <PWMOutputsDisable>
    return 0;
 8014476:	2300      	movs	r3, #0
}
 8014478:	4618      	mov	r0, r3
 801447a:	3798      	adds	r7, #152	; 0x98
 801447c:	46bd      	mov	sp, r7
 801447e:	bd80      	pop	{r7, pc}
 8014480:	40010400 	.word	0x40010400

08014484 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8014484:	b480      	push	{r7}
 8014486:	b083      	sub	sp, #12
 8014488:	af00      	add	r7, sp, #0
 801448a:	4603      	mov	r3, r0
 801448c:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 801448e:	4908      	ldr	r1, [pc, #32]	; (80144b0 <NVIC_EnableIRQ+0x2c>)
 8014490:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8014494:	095b      	lsrs	r3, r3, #5
 8014496:	79fa      	ldrb	r2, [r7, #7]
 8014498:	f002 021f 	and.w	r2, r2, #31
 801449c:	2001      	movs	r0, #1
 801449e:	fa00 f202 	lsl.w	r2, r0, r2
 80144a2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80144a6:	370c      	adds	r7, #12
 80144a8:	46bd      	mov	sp, r7
 80144aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80144ae:	4770      	bx	lr
 80144b0:	e000e100 	.word	0xe000e100

080144b4 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
 80144b4:	b480      	push	{r7}
 80144b6:	b083      	sub	sp, #12
 80144b8:	af00      	add	r7, sp, #0
 80144ba:	4603      	mov	r3, r0
 80144bc:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80144be:	4909      	ldr	r1, [pc, #36]	; (80144e4 <NVIC_DisableIRQ+0x30>)
 80144c0:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80144c4:	095b      	lsrs	r3, r3, #5
 80144c6:	79fa      	ldrb	r2, [r7, #7]
 80144c8:	f002 021f 	and.w	r2, r2, #31
 80144cc:	2001      	movs	r0, #1
 80144ce:	fa00 f202 	lsl.w	r2, r0, r2
 80144d2:	3320      	adds	r3, #32
 80144d4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80144d8:	370c      	adds	r7, #12
 80144da:	46bd      	mov	sp, r7
 80144dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80144e0:	4770      	bx	lr
 80144e2:	bf00      	nop
 80144e4:	e000e100 	.word	0xe000e100

080144e8 <stm32_configure>:
    UART_HandleTypeDef UartHandle;
    IRQn_Type irq;
};

static rt_err_t stm32_configure(struct rt_serial_device *serial, struct serial_configure *cfg)
{
 80144e8:	b580      	push	{r7, lr}
 80144ea:	b084      	sub	sp, #16
 80144ec:	af00      	add	r7, sp, #0
 80144ee:	6078      	str	r0, [r7, #4]
 80144f0:	6039      	str	r1, [r7, #0]
    struct stm32_uart *uart;

    RT_ASSERT(serial != RT_NULL);
 80144f2:	687b      	ldr	r3, [r7, #4]
 80144f4:	2b00      	cmp	r3, #0
 80144f6:	d104      	bne.n	8014502 <stm32_configure+0x1a>
 80144f8:	487f      	ldr	r0, [pc, #508]	; (80146f8 <stm32_configure+0x210>)
 80144fa:	4980      	ldr	r1, [pc, #512]	; (80146fc <stm32_configure+0x214>)
 80144fc:	224c      	movs	r2, #76	; 0x4c
 80144fe:	f003 fa57 	bl	80179b0 <rt_assert_handler>
    RT_ASSERT(cfg != RT_NULL);
 8014502:	683b      	ldr	r3, [r7, #0]
 8014504:	2b00      	cmp	r3, #0
 8014506:	d104      	bne.n	8014512 <stm32_configure+0x2a>
 8014508:	487d      	ldr	r0, [pc, #500]	; (8014700 <stm32_configure+0x218>)
 801450a:	497c      	ldr	r1, [pc, #496]	; (80146fc <stm32_configure+0x214>)
 801450c:	224d      	movs	r2, #77	; 0x4d
 801450e:	f003 fa4f 	bl	80179b0 <rt_assert_handler>

    uart = (struct stm32_uart *)serial->parent.user_data;
 8014512:	687b      	ldr	r3, [r7, #4]
 8014514:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8014516:	60fb      	str	r3, [r7, #12]
	if(uart->UartHandle.Instance == USART1)
 8014518:	68fb      	ldr	r3, [r7, #12]
 801451a:	681b      	ldr	r3, [r3, #0]
 801451c:	4a79      	ldr	r2, [pc, #484]	; (8014704 <stm32_configure+0x21c>)
 801451e:	4293      	cmp	r3, r2
 8014520:	d16f      	bne.n	8014602 <stm32_configure+0x11a>
	{
	    uart->UartHandle.Init.BaudRate   = cfg->baud_rate;
 8014522:	683b      	ldr	r3, [r7, #0]
 8014524:	681a      	ldr	r2, [r3, #0]
 8014526:	68fb      	ldr	r3, [r7, #12]
 8014528:	605a      	str	r2, [r3, #4]
	    uart->UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
 801452a:	68fb      	ldr	r3, [r7, #12]
 801452c:	2200      	movs	r2, #0
 801452e:	619a      	str	r2, [r3, #24]
	    uart->UartHandle.Init.Mode       = UART_MODE_TX_RX;
 8014530:	68fb      	ldr	r3, [r7, #12]
 8014532:	220c      	movs	r2, #12
 8014534:	615a      	str	r2, [r3, #20]
	    uart->UartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8014536:	68fb      	ldr	r3, [r7, #12]
 8014538:	2200      	movs	r2, #0
 801453a:	625a      	str	r2, [r3, #36]	; 0x24

	    switch (cfg->data_bits)
 801453c:	683b      	ldr	r3, [r7, #0]
 801453e:	791b      	ldrb	r3, [r3, #4]
 8014540:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8014544:	b2db      	uxtb	r3, r3
 8014546:	2b08      	cmp	r3, #8
 8014548:	d008      	beq.n	801455c <stm32_configure+0x74>
 801454a:	2b09      	cmp	r3, #9
 801454c:	d00a      	beq.n	8014564 <stm32_configure+0x7c>
 801454e:	2b07      	cmp	r3, #7
 8014550:	d10d      	bne.n	801456e <stm32_configure+0x86>
	    {
	    case DATA_BITS_7:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_7B;
 8014552:	68fb      	ldr	r3, [r7, #12]
 8014554:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8014558:	609a      	str	r2, [r3, #8]
	        break;
 801455a:	e00c      	b.n	8014576 <stm32_configure+0x8e>
	    case DATA_BITS_8:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 801455c:	68fb      	ldr	r3, [r7, #12]
 801455e:	2200      	movs	r2, #0
 8014560:	609a      	str	r2, [r3, #8]
	        break;
 8014562:	e008      	b.n	8014576 <stm32_configure+0x8e>
	    case DATA_BITS_9:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_9B;
 8014564:	68fb      	ldr	r3, [r7, #12]
 8014566:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801456a:	609a      	str	r2, [r3, #8]
	        break;
 801456c:	e003      	b.n	8014576 <stm32_configure+0x8e>
	    default:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 801456e:	68fb      	ldr	r3, [r7, #12]
 8014570:	2200      	movs	r2, #0
 8014572:	609a      	str	r2, [r3, #8]
	        break;
 8014574:	bf00      	nop
	    }
	    switch (cfg->stop_bits)
 8014576:	683b      	ldr	r3, [r7, #0]
 8014578:	791b      	ldrb	r3, [r3, #4]
 801457a:	f3c3 1301 	ubfx	r3, r3, #4, #2
 801457e:	b2db      	uxtb	r3, r3
 8014580:	2b00      	cmp	r3, #0
 8014582:	d002      	beq.n	801458a <stm32_configure+0xa2>
 8014584:	2b01      	cmp	r3, #1
 8014586:	d004      	beq.n	8014592 <stm32_configure+0xaa>
 8014588:	e008      	b.n	801459c <stm32_configure+0xb4>
	    {
	    case STOP_BITS_1:
	        uart->UartHandle.Init.StopBits   = UART_STOPBITS_1;
 801458a:	68fb      	ldr	r3, [r7, #12]
 801458c:	2200      	movs	r2, #0
 801458e:	60da      	str	r2, [r3, #12]
	        break;
 8014590:	e008      	b.n	80145a4 <stm32_configure+0xbc>
	    case STOP_BITS_2:
	        uart->UartHandle.Init.StopBits   = UART_STOPBITS_2;
 8014592:	68fb      	ldr	r3, [r7, #12]
 8014594:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8014598:	60da      	str	r2, [r3, #12]
	        break;
 801459a:	e003      	b.n	80145a4 <stm32_configure+0xbc>
	    default:
	        uart->UartHandle.Init.StopBits   = UART_STOPBITS_1;
 801459c:	68fb      	ldr	r3, [r7, #12]
 801459e:	2200      	movs	r2, #0
 80145a0:	60da      	str	r2, [r3, #12]
	        break;
 80145a2:	bf00      	nop
	    }
	    switch (cfg->parity)
 80145a4:	683b      	ldr	r3, [r7, #0]
 80145a6:	791b      	ldrb	r3, [r3, #4]
 80145a8:	f3c3 1381 	ubfx	r3, r3, #6, #2
 80145ac:	b2db      	uxtb	r3, r3
 80145ae:	2b01      	cmp	r3, #1
 80145b0:	d007      	beq.n	80145c2 <stm32_configure+0xda>
 80145b2:	2b02      	cmp	r3, #2
 80145b4:	d00a      	beq.n	80145cc <stm32_configure+0xe4>
 80145b6:	2b00      	cmp	r3, #0
 80145b8:	d10d      	bne.n	80145d6 <stm32_configure+0xee>
	    {
	    case PARITY_NONE:
	        uart->UartHandle.Init.Parity     = UART_PARITY_NONE;
 80145ba:	68fb      	ldr	r3, [r7, #12]
 80145bc:	2200      	movs	r2, #0
 80145be:	611a      	str	r2, [r3, #16]
	        break;
 80145c0:	e00d      	b.n	80145de <stm32_configure+0xf6>
	    case PARITY_ODD:
	        uart->UartHandle.Init.Parity     = UART_PARITY_ODD;
 80145c2:	68fb      	ldr	r3, [r7, #12]
 80145c4:	f44f 62c0 	mov.w	r2, #1536	; 0x600
 80145c8:	611a      	str	r2, [r3, #16]
	        break;
 80145ca:	e008      	b.n	80145de <stm32_configure+0xf6>
	    case PARITY_EVEN:
	        uart->UartHandle.Init.Parity     = UART_PARITY_EVEN;
 80145cc:	68fb      	ldr	r3, [r7, #12]
 80145ce:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80145d2:	611a      	str	r2, [r3, #16]
	        break;
 80145d4:	e003      	b.n	80145de <stm32_configure+0xf6>
	    default:
	        uart->UartHandle.Init.Parity     = UART_PARITY_NONE;
 80145d6:	68fb      	ldr	r3, [r7, #12]
 80145d8:	2200      	movs	r2, #0
 80145da:	611a      	str	r2, [r3, #16]
	        break;
 80145dc:	bf00      	nop
	    }
	    if (HAL_UART_DeInit(&uart->UartHandle) != HAL_OK)
 80145de:	68fb      	ldr	r3, [r7, #12]
 80145e0:	4618      	mov	r0, r3
 80145e2:	f7fb f879 	bl	800f6d8 <HAL_UART_DeInit>
 80145e6:	4603      	mov	r3, r0
 80145e8:	2b00      	cmp	r3, #0
 80145ea:	d001      	beq.n	80145f0 <stm32_configure+0x108>
	    {
	        return RT_ERROR;
 80145ec:	2301      	movs	r3, #1
 80145ee:	e07e      	b.n	80146ee <stm32_configure+0x206>
	    }
	    if (HAL_UART_Init(&uart->UartHandle) != HAL_OK)
 80145f0:	68fb      	ldr	r3, [r7, #12]
 80145f2:	4618      	mov	r0, r3
 80145f4:	f7fb f81e 	bl	800f634 <HAL_UART_Init>
 80145f8:	4603      	mov	r3, r0
 80145fa:	2b00      	cmp	r3, #0
 80145fc:	d001      	beq.n	8014602 <stm32_configure+0x11a>
	    {
	        return RT_ERROR;
 80145fe:	2301      	movs	r3, #1
 8014600:	e075      	b.n	80146ee <stm32_configure+0x206>
	    }
	}

	if(uart->UartHandle.Instance == USART3)
 8014602:	68fb      	ldr	r3, [r7, #12]
 8014604:	681b      	ldr	r3, [r3, #0]
 8014606:	4a40      	ldr	r2, [pc, #256]	; (8014708 <stm32_configure+0x220>)
 8014608:	4293      	cmp	r3, r2
 801460a:	d16f      	bne.n	80146ec <stm32_configure+0x204>
	{
	    uart->UartHandle.Init.BaudRate   = cfg->baud_rate;
 801460c:	683b      	ldr	r3, [r7, #0]
 801460e:	681a      	ldr	r2, [r3, #0]
 8014610:	68fb      	ldr	r3, [r7, #12]
 8014612:	605a      	str	r2, [r3, #4]
	    uart->UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
 8014614:	68fb      	ldr	r3, [r7, #12]
 8014616:	2200      	movs	r2, #0
 8014618:	619a      	str	r2, [r3, #24]
	    uart->UartHandle.Init.Mode       = UART_MODE_TX_RX;
 801461a:	68fb      	ldr	r3, [r7, #12]
 801461c:	220c      	movs	r2, #12
 801461e:	615a      	str	r2, [r3, #20]
	    uart->UartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8014620:	68fb      	ldr	r3, [r7, #12]
 8014622:	2200      	movs	r2, #0
 8014624:	625a      	str	r2, [r3, #36]	; 0x24

	    switch (cfg->data_bits)
 8014626:	683b      	ldr	r3, [r7, #0]
 8014628:	791b      	ldrb	r3, [r3, #4]
 801462a:	f3c3 0303 	ubfx	r3, r3, #0, #4
 801462e:	b2db      	uxtb	r3, r3
 8014630:	2b08      	cmp	r3, #8
 8014632:	d008      	beq.n	8014646 <stm32_configure+0x15e>
 8014634:	2b09      	cmp	r3, #9
 8014636:	d00a      	beq.n	801464e <stm32_configure+0x166>
 8014638:	2b07      	cmp	r3, #7
 801463a:	d10d      	bne.n	8014658 <stm32_configure+0x170>
	    {
	    case DATA_BITS_7:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_7B;
 801463c:	68fb      	ldr	r3, [r7, #12]
 801463e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8014642:	609a      	str	r2, [r3, #8]
	        break;
 8014644:	e00c      	b.n	8014660 <stm32_configure+0x178>
	    case DATA_BITS_8:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 8014646:	68fb      	ldr	r3, [r7, #12]
 8014648:	2200      	movs	r2, #0
 801464a:	609a      	str	r2, [r3, #8]
	        break;
 801464c:	e008      	b.n	8014660 <stm32_configure+0x178>
	    case DATA_BITS_9:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_9B;
 801464e:	68fb      	ldr	r3, [r7, #12]
 8014650:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8014654:	609a      	str	r2, [r3, #8]
	        break;
 8014656:	e003      	b.n	8014660 <stm32_configure+0x178>
	    default:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 8014658:	68fb      	ldr	r3, [r7, #12]
 801465a:	2200      	movs	r2, #0
 801465c:	609a      	str	r2, [r3, #8]
	        break;
 801465e:	bf00      	nop
	    }
	    switch (cfg->stop_bits)
 8014660:	683b      	ldr	r3, [r7, #0]
 8014662:	791b      	ldrb	r3, [r3, #4]
 8014664:	f3c3 1301 	ubfx	r3, r3, #4, #2
 8014668:	b2db      	uxtb	r3, r3
 801466a:	2b00      	cmp	r3, #0
 801466c:	d002      	beq.n	8014674 <stm32_configure+0x18c>
 801466e:	2b01      	cmp	r3, #1
 8014670:	d004      	beq.n	801467c <stm32_configure+0x194>
 8014672:	e008      	b.n	8014686 <stm32_configure+0x19e>
	    {
	    case STOP_BITS_1:
	        uart->UartHandle.Init.StopBits   = UART_STOPBITS_1;
 8014674:	68fb      	ldr	r3, [r7, #12]
 8014676:	2200      	movs	r2, #0
 8014678:	60da      	str	r2, [r3, #12]
	        break;
 801467a:	e008      	b.n	801468e <stm32_configure+0x1a6>
	    case STOP_BITS_2:
	        uart->UartHandle.Init.StopBits   = UART_STOPBITS_2;
 801467c:	68fb      	ldr	r3, [r7, #12]
 801467e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8014682:	60da      	str	r2, [r3, #12]
	        break;
 8014684:	e003      	b.n	801468e <stm32_configure+0x1a6>
	    default:
	        uart->UartHandle.Init.StopBits   = UART_STOPBITS_1;
 8014686:	68fb      	ldr	r3, [r7, #12]
 8014688:	2200      	movs	r2, #0
 801468a:	60da      	str	r2, [r3, #12]
	        break;
 801468c:	bf00      	nop
	    }
	    switch (cfg->parity)
 801468e:	683b      	ldr	r3, [r7, #0]
 8014690:	791b      	ldrb	r3, [r3, #4]
 8014692:	f3c3 1381 	ubfx	r3, r3, #6, #2
 8014696:	b2db      	uxtb	r3, r3
 8014698:	2b01      	cmp	r3, #1
 801469a:	d007      	beq.n	80146ac <stm32_configure+0x1c4>
 801469c:	2b02      	cmp	r3, #2
 801469e:	d00a      	beq.n	80146b6 <stm32_configure+0x1ce>
 80146a0:	2b00      	cmp	r3, #0
 80146a2:	d10d      	bne.n	80146c0 <stm32_configure+0x1d8>
	    {
	    case PARITY_NONE:
	        uart->UartHandle.Init.Parity     = UART_PARITY_NONE;
 80146a4:	68fb      	ldr	r3, [r7, #12]
 80146a6:	2200      	movs	r2, #0
 80146a8:	611a      	str	r2, [r3, #16]
	        break;
 80146aa:	e00d      	b.n	80146c8 <stm32_configure+0x1e0>
	    case PARITY_ODD:
	        uart->UartHandle.Init.Parity     = UART_PARITY_ODD;
 80146ac:	68fb      	ldr	r3, [r7, #12]
 80146ae:	f44f 62c0 	mov.w	r2, #1536	; 0x600
 80146b2:	611a      	str	r2, [r3, #16]
	        break;
 80146b4:	e008      	b.n	80146c8 <stm32_configure+0x1e0>
	    case PARITY_EVEN:
	        uart->UartHandle.Init.Parity     = UART_PARITY_EVEN;
 80146b6:	68fb      	ldr	r3, [r7, #12]
 80146b8:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80146bc:	611a      	str	r2, [r3, #16]
	        break;
 80146be:	e003      	b.n	80146c8 <stm32_configure+0x1e0>
	    default:
	        uart->UartHandle.Init.Parity     = UART_PARITY_NONE;
 80146c0:	68fb      	ldr	r3, [r7, #12]
 80146c2:	2200      	movs	r2, #0
 80146c4:	611a      	str	r2, [r3, #16]
	        break;
 80146c6:	bf00      	nop
	    }
	    if (HAL_UART_DeInit(&uart->UartHandle) != HAL_OK)
 80146c8:	68fb      	ldr	r3, [r7, #12]
 80146ca:	4618      	mov	r0, r3
 80146cc:	f7fb f804 	bl	800f6d8 <HAL_UART_DeInit>
 80146d0:	4603      	mov	r3, r0
 80146d2:	2b00      	cmp	r3, #0
 80146d4:	d001      	beq.n	80146da <stm32_configure+0x1f2>
	    {
	        return RT_ERROR;
 80146d6:	2301      	movs	r3, #1
 80146d8:	e009      	b.n	80146ee <stm32_configure+0x206>
	    }
	    if (HAL_UART_Init(&uart->UartHandle) != HAL_OK)
 80146da:	68fb      	ldr	r3, [r7, #12]
 80146dc:	4618      	mov	r0, r3
 80146de:	f7fa ffa9 	bl	800f634 <HAL_UART_Init>
 80146e2:	4603      	mov	r3, r0
 80146e4:	2b00      	cmp	r3, #0
 80146e6:	d001      	beq.n	80146ec <stm32_configure+0x204>
	    {
	        return RT_ERROR;
 80146e8:	2301      	movs	r3, #1
 80146ea:	e000      	b.n	80146ee <stm32_configure+0x206>
	    }

	}
    return RT_EOK;
 80146ec:	2300      	movs	r3, #0
}
 80146ee:	4618      	mov	r0, r3
 80146f0:	3710      	adds	r7, #16
 80146f2:	46bd      	mov	sp, r7
 80146f4:	bd80      	pop	{r7, pc}
 80146f6:	bf00      	nop
 80146f8:	08027104 	.word	0x08027104
 80146fc:	08028cf8 	.word	0x08028cf8
 8014700:	08027118 	.word	0x08027118
 8014704:	40011000 	.word	0x40011000
 8014708:	40004800 	.word	0x40004800

0801470c <stm32_control>:
{
	rt_hw_serial_isr(&serial3, RT_SERIAL_EVENT_RX_DMADONE | 0x100);
}

static rt_err_t stm32_control(struct rt_serial_device *serial, int cmd, void *arg)
{
 801470c:	b580      	push	{r7, lr}
 801470e:	b086      	sub	sp, #24
 8014710:	af00      	add	r7, sp, #0
 8014712:	60f8      	str	r0, [r7, #12]
 8014714:	60b9      	str	r1, [r7, #8]
 8014716:	607a      	str	r2, [r7, #4]
    struct stm32_uart *uart;
	static DMA_HandleTypeDef hdma_rx;

    RT_ASSERT(serial != RT_NULL);
 8014718:	68fb      	ldr	r3, [r7, #12]
 801471a:	2b00      	cmp	r3, #0
 801471c:	d104      	bne.n	8014728 <stm32_control+0x1c>
 801471e:	4856      	ldr	r0, [pc, #344]	; (8014878 <stm32_control+0x16c>)
 8014720:	4956      	ldr	r1, [pc, #344]	; (801487c <stm32_control+0x170>)
 8014722:	22d8      	movs	r2, #216	; 0xd8
 8014724:	f003 f944 	bl	80179b0 <rt_assert_handler>
    uart = (struct stm32_uart *)serial->parent.user_data;
 8014728:	68fb      	ldr	r3, [r7, #12]
 801472a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801472c:	617b      	str	r3, [r7, #20]

    switch (cmd)
 801472e:	68bb      	ldr	r3, [r7, #8]
 8014730:	2b11      	cmp	r3, #17
 8014732:	d004      	beq.n	801473e <stm32_control+0x32>
 8014734:	2b14      	cmp	r3, #20
 8014736:	d022      	beq.n	801477e <stm32_control+0x72>
 8014738:	2b10      	cmp	r3, #16
 801473a:	d010      	beq.n	801475e <stm32_control+0x52>
 801473c:	e097      	b.n	801486e <stm32_control+0x162>
    {
    case RT_DEVICE_CTRL_CLR_INT:
        /* disable rx irq */
        UART_DISABLE_IRQ(uart->irq);
 801473e:	697b      	ldr	r3, [r7, #20]
 8014740:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
 8014744:	b25b      	sxtb	r3, r3
 8014746:	4618      	mov	r0, r3
 8014748:	f7ff feb4 	bl	80144b4 <NVIC_DisableIRQ>
        /* disable interrupt */
        __HAL_UART_DISABLE_IT(&uart->UartHandle, UART_IT_RXNE);
 801474c:	697b      	ldr	r3, [r7, #20]
 801474e:	681b      	ldr	r3, [r3, #0]
 8014750:	697a      	ldr	r2, [r7, #20]
 8014752:	6812      	ldr	r2, [r2, #0]
 8014754:	6812      	ldr	r2, [r2, #0]
 8014756:	f022 0220 	bic.w	r2, r2, #32
 801475a:	601a      	str	r2, [r3, #0]
        break;
 801475c:	e087      	b.n	801486e <stm32_control+0x162>
    case RT_DEVICE_CTRL_SET_INT:
        /* enable rx irq */
        UART_ENABLE_IRQ(uart->irq);
 801475e:	697b      	ldr	r3, [r7, #20]
 8014760:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
 8014764:	b25b      	sxtb	r3, r3
 8014766:	4618      	mov	r0, r3
 8014768:	f7ff fe8c 	bl	8014484 <NVIC_EnableIRQ>
        /* enable interrupt */
        __HAL_UART_ENABLE_IT(&uart->UartHandle, UART_IT_RXNE);
 801476c:	697b      	ldr	r3, [r7, #20]
 801476e:	681b      	ldr	r3, [r3, #0]
 8014770:	697a      	ldr	r2, [r7, #20]
 8014772:	6812      	ldr	r2, [r2, #0]
 8014774:	6812      	ldr	r2, [r2, #0]
 8014776:	f042 0220 	orr.w	r2, r2, #32
 801477a:	601a      	str	r2, [r3, #0]
        break;
 801477c:	e077      	b.n	801486e <stm32_control+0x162>
    case RT_DEVICE_CTRL_SET_DMARX:

#if 1
		rt_kprintf("in the control\r\n");
 801477e:	4840      	ldr	r0, [pc, #256]	; (8014880 <stm32_control+0x174>)
 8014780:	f003 f89c 	bl	80178bc <rt_kprintf>
		__HAL_RCC_DMA1_CLK_ENABLE();
 8014784:	4a3f      	ldr	r2, [pc, #252]	; (8014884 <stm32_control+0x178>)
 8014786:	4b3f      	ldr	r3, [pc, #252]	; (8014884 <stm32_control+0x178>)
 8014788:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801478a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 801478e:	6313      	str	r3, [r2, #48]	; 0x30
 8014790:	4b3c      	ldr	r3, [pc, #240]	; (8014884 <stm32_control+0x178>)
 8014792:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014794:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8014798:	613b      	str	r3, [r7, #16]
 801479a:	693b      	ldr	r3, [r7, #16]
		
		hdma_rx.Instance = DMA1_Stream1;
 801479c:	4b3a      	ldr	r3, [pc, #232]	; (8014888 <stm32_control+0x17c>)
 801479e:	4a3b      	ldr	r2, [pc, #236]	; (801488c <stm32_control+0x180>)
 80147a0:	601a      	str	r2, [r3, #0]
		uart->UartHandle.RxXferSize = 1;
 80147a2:	697b      	ldr	r3, [r7, #20]
 80147a4:	2201      	movs	r2, #1
 80147a6:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
		uart->UartHandle.Instance->CR3 |= USART_CR3_DMAR;
 80147aa:	697b      	ldr	r3, [r7, #20]
 80147ac:	681b      	ldr	r3, [r3, #0]
 80147ae:	697a      	ldr	r2, [r7, #20]
 80147b0:	6812      	ldr	r2, [r2, #0]
 80147b2:	6892      	ldr	r2, [r2, #8]
 80147b4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80147b8:	609a      	str	r2, [r3, #8]
		
		hdma_rx.Init.Channel = DMA_CHANNEL_4;
 80147ba:	4b33      	ldr	r3, [pc, #204]	; (8014888 <stm32_control+0x17c>)
 80147bc:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80147c0:	605a      	str	r2, [r3, #4]
		hdma_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 80147c2:	4b31      	ldr	r3, [pc, #196]	; (8014888 <stm32_control+0x17c>)
 80147c4:	2200      	movs	r2, #0
 80147c6:	609a      	str	r2, [r3, #8]
		hdma_rx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 80147c8:	4b2f      	ldr	r3, [pc, #188]	; (8014888 <stm32_control+0x17c>)
 80147ca:	2204      	movs	r2, #4
 80147cc:	625a      	str	r2, [r3, #36]	; 0x24
		hdma_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_HALFFULL;
 80147ce:	4b2e      	ldr	r3, [pc, #184]	; (8014888 <stm32_control+0x17c>)
 80147d0:	2201      	movs	r2, #1
 80147d2:	629a      	str	r2, [r3, #40]	; 0x28
		hdma_rx.Init.MemBurst = DMA_MBURST_SINGLE;
 80147d4:	4b2c      	ldr	r3, [pc, #176]	; (8014888 <stm32_control+0x17c>)
 80147d6:	2200      	movs	r2, #0
 80147d8:	62da      	str	r2, [r3, #44]	; 0x2c
		hdma_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 80147da:	4b2b      	ldr	r3, [pc, #172]	; (8014888 <stm32_control+0x17c>)
 80147dc:	2200      	movs	r2, #0
 80147de:	619a      	str	r2, [r3, #24]
		hdma_rx.Init.MemInc = DMA_MINC_ENABLE;
 80147e0:	4b29      	ldr	r3, [pc, #164]	; (8014888 <stm32_control+0x17c>)
 80147e2:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80147e6:	611a      	str	r2, [r3, #16]
		hdma_rx.Init.Mode = DMA_NORMAL;
 80147e8:	4b27      	ldr	r3, [pc, #156]	; (8014888 <stm32_control+0x17c>)
 80147ea:	2200      	movs	r2, #0
 80147ec:	61da      	str	r2, [r3, #28]
		hdma_rx.Init.PeriphBurst = DMA_PBURST_SINGLE;
 80147ee:	4b26      	ldr	r3, [pc, #152]	; (8014888 <stm32_control+0x17c>)
 80147f0:	2200      	movs	r2, #0
 80147f2:	631a      	str	r2, [r3, #48]	; 0x30
		hdma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 80147f4:	4b24      	ldr	r3, [pc, #144]	; (8014888 <stm32_control+0x17c>)
 80147f6:	2200      	movs	r2, #0
 80147f8:	615a      	str	r2, [r3, #20]
		hdma_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 80147fa:	4b23      	ldr	r3, [pc, #140]	; (8014888 <stm32_control+0x17c>)
 80147fc:	2200      	movs	r2, #0
 80147fe:	60da      	str	r2, [r3, #12]
		hdma_rx.Init.Priority = DMA_PRIORITY_MEDIUM;
 8014800:	4b21      	ldr	r3, [pc, #132]	; (8014888 <stm32_control+0x17c>)
 8014802:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8014806:	621a      	str	r2, [r3, #32]
		
		
		if (HAL_DMA_DeInit(&hdma_rx) != HAL_OK)
 8014808:	481f      	ldr	r0, [pc, #124]	; (8014888 <stm32_control+0x17c>)
 801480a:	f7f4 fa23 	bl	8008c54 <HAL_DMA_DeInit>
 801480e:	4603      	mov	r3, r0
 8014810:	2b00      	cmp	r3, #0
 8014812:	d001      	beq.n	8014818 <stm32_control+0x10c>
		{
			return RT_ERROR;
 8014814:	2301      	movs	r3, #1
 8014816:	e02b      	b.n	8014870 <stm32_control+0x164>
		}
		if (HAL_DMA_Init(&hdma_rx) != HAL_OK)
 8014818:	481b      	ldr	r0, [pc, #108]	; (8014888 <stm32_control+0x17c>)
 801481a:	f7f4 f9af 	bl	8008b7c <HAL_DMA_Init>
 801481e:	4603      	mov	r3, r0
 8014820:	2b00      	cmp	r3, #0
 8014822:	d001      	beq.n	8014828 <stm32_control+0x11c>
		{
			return RT_ERROR;
 8014824:	2301      	movs	r3, #1
 8014826:	e023      	b.n	8014870 <stm32_control+0x164>
		}
		__HAL_LINKDMA(&uart->UartHandle, hdmarx, hdma_rx);
 8014828:	697b      	ldr	r3, [r7, #20]
 801482a:	4a17      	ldr	r2, [pc, #92]	; (8014888 <stm32_control+0x17c>)
 801482c:	665a      	str	r2, [r3, #100]	; 0x64
 801482e:	697b      	ldr	r3, [r7, #20]
 8014830:	4a15      	ldr	r2, [pc, #84]	; (8014888 <stm32_control+0x17c>)
 8014832:	6393      	str	r3, [r2, #56]	; 0x38
		uart->UartHandle.pRxBuffPtr = (uint8_t *)rt_malloc((uart->UartHandle.RxXferSize)*sizeof(uint8_t));
 8014834:	697b      	ldr	r3, [r7, #20]
 8014836:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 801483a:	4618      	mov	r0, r3
 801483c:	f003 f9ec 	bl	8017c18 <rt_malloc>
 8014840:	4602      	mov	r2, r0
 8014842:	697b      	ldr	r3, [r7, #20]
 8014844:	655a      	str	r2, [r3, #84]	; 0x54
		  /* NVIC configuration for DMA transfer complete interrupt (USART6_RX) */
 		HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, DMA1STREAM1_IRQ_PREEMPT, DMA1STREAM1_IRQ_SUB);
 8014846:	200c      	movs	r0, #12
 8014848:	210f      	movs	r1, #15
 801484a:	2200      	movs	r2, #0
 801484c:	f7f4 f8e2 	bl	8008a14 <HAL_NVIC_SetPriority>
 		HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
 8014850:	200c      	movs	r0, #12
 8014852:	f7f4 f8fb 	bl	8008a4c <HAL_NVIC_EnableIRQ>
		HAL_UART_Receive_DMA(&uart->UartHandle,(uint8_t *)uart->UartHandle.pRxBuffPtr, uart->UartHandle.RxXferSize);
 8014856:	6979      	ldr	r1, [r7, #20]
 8014858:	697b      	ldr	r3, [r7, #20]
 801485a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801485c:	697b      	ldr	r3, [r7, #20]
 801485e:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 8014862:	4608      	mov	r0, r1
 8014864:	4611      	mov	r1, r2
 8014866:	461a      	mov	r2, r3
 8014868:	f7fa ff6a 	bl	800f740 <HAL_UART_Receive_DMA>
#endif
		
	    break;
 801486c:	bf00      	nop
    }

    return RT_EOK;
 801486e:	2300      	movs	r3, #0
}
 8014870:	4618      	mov	r0, r3
 8014872:	3718      	adds	r7, #24
 8014874:	46bd      	mov	sp, r7
 8014876:	bd80      	pop	{r7, pc}
 8014878:	08027104 	.word	0x08027104
 801487c:	08028d08 	.word	0x08028d08
 8014880:	08027128 	.word	0x08027128
 8014884:	40023800 	.word	0x40023800
 8014888:	200109cc 	.word	0x200109cc
 801488c:	40026028 	.word	0x40026028

08014890 <stm32_putc>:

static int stm32_putc(struct rt_serial_device *serial, char c)
{
 8014890:	b580      	push	{r7, lr}
 8014892:	b084      	sub	sp, #16
 8014894:	af00      	add	r7, sp, #0
 8014896:	6078      	str	r0, [r7, #4]
 8014898:	460b      	mov	r3, r1
 801489a:	70fb      	strb	r3, [r7, #3]
    struct stm32_uart *uart;

    RT_ASSERT(serial != RT_NULL);
 801489c:	687b      	ldr	r3, [r7, #4]
 801489e:	2b00      	cmp	r3, #0
 80148a0:	d105      	bne.n	80148ae <stm32_putc+0x1e>
 80148a2:	480d      	ldr	r0, [pc, #52]	; (80148d8 <stm32_putc+0x48>)
 80148a4:	490d      	ldr	r1, [pc, #52]	; (80148dc <stm32_putc+0x4c>)
 80148a6:	f240 121b 	movw	r2, #283	; 0x11b
 80148aa:	f003 f881 	bl	80179b0 <rt_assert_handler>
    uart = (struct stm32_uart *)serial->parent.user_data;
 80148ae:	687b      	ldr	r3, [r7, #4]
 80148b0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80148b2:	60fb      	str	r3, [r7, #12]

    while (!(uart->UartHandle.Instance->ISR & UART_FLAG_TXE));
 80148b4:	bf00      	nop
 80148b6:	68fb      	ldr	r3, [r7, #12]
 80148b8:	681b      	ldr	r3, [r3, #0]
 80148ba:	69db      	ldr	r3, [r3, #28]
 80148bc:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80148c0:	2b00      	cmp	r3, #0
 80148c2:	d0f8      	beq.n	80148b6 <stm32_putc+0x26>
    uart->UartHandle.Instance->TDR = c;
 80148c4:	68fb      	ldr	r3, [r7, #12]
 80148c6:	681b      	ldr	r3, [r3, #0]
 80148c8:	78fa      	ldrb	r2, [r7, #3]
 80148ca:	629a      	str	r2, [r3, #40]	; 0x28

    return 1;
 80148cc:	2301      	movs	r3, #1
}
 80148ce:	4618      	mov	r0, r3
 80148d0:	3710      	adds	r7, #16
 80148d2:	46bd      	mov	sp, r7
 80148d4:	bd80      	pop	{r7, pc}
 80148d6:	bf00      	nop
 80148d8:	08027104 	.word	0x08027104
 80148dc:	08028d18 	.word	0x08028d18

080148e0 <stm32_getc>:
/*test code by he*/


static int stm32_getc(struct rt_serial_device *serial)
{
 80148e0:	b580      	push	{r7, lr}
 80148e2:	b084      	sub	sp, #16
 80148e4:	af00      	add	r7, sp, #0
 80148e6:	6078      	str	r0, [r7, #4]
    int ch;
    struct stm32_uart *uart;

    RT_ASSERT(serial != RT_NULL);
 80148e8:	687b      	ldr	r3, [r7, #4]
 80148ea:	2b00      	cmp	r3, #0
 80148ec:	d105      	bne.n	80148fa <stm32_getc+0x1a>
 80148ee:	480e      	ldr	r0, [pc, #56]	; (8014928 <stm32_getc+0x48>)
 80148f0:	490e      	ldr	r1, [pc, #56]	; (801492c <stm32_getc+0x4c>)
 80148f2:	f240 122b 	movw	r2, #299	; 0x12b
 80148f6:	f003 f85b 	bl	80179b0 <rt_assert_handler>
    uart = (struct stm32_uart *)serial->parent.user_data;
 80148fa:	687b      	ldr	r3, [r7, #4]
 80148fc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80148fe:	60bb      	str	r3, [r7, #8]

    ch = -1;
 8014900:	f04f 33ff 	mov.w	r3, #4294967295
 8014904:	60fb      	str	r3, [r7, #12]
    if (uart->UartHandle.Instance->ISR & UART_FLAG_RXNE)
 8014906:	68bb      	ldr	r3, [r7, #8]
 8014908:	681b      	ldr	r3, [r3, #0]
 801490a:	69db      	ldr	r3, [r3, #28]
 801490c:	f003 0320 	and.w	r3, r3, #32
 8014910:	2b00      	cmp	r3, #0
 8014912:	d004      	beq.n	801491e <stm32_getc+0x3e>
    {
        ch = uart->UartHandle.Instance->RDR & 0xff;
 8014914:	68bb      	ldr	r3, [r7, #8]
 8014916:	681b      	ldr	r3, [r3, #0]
 8014918:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801491a:	b2db      	uxtb	r3, r3
 801491c:	60fb      	str	r3, [r7, #12]
    }
	/*test code by he*/
    return ch;
 801491e:	68fb      	ldr	r3, [r7, #12]
}
 8014920:	4618      	mov	r0, r3
 8014922:	3710      	adds	r7, #16
 8014924:	46bd      	mov	sp, r7
 8014926:	bd80      	pop	{r7, pc}
 8014928:	08027104 	.word	0x08027104
 801492c:	08028d24 	.word	0x08028d24

08014930 <stm32_dma_transmit>:

static rt_size_t stm32_dma_transmit(struct rt_serial_device *serial, const rt_uint8_t *buf, rt_size_t size, int direction)
{
 8014930:	b580      	push	{r7, lr}
 8014932:	b088      	sub	sp, #32
 8014934:	af00      	add	r7, sp, #0
 8014936:	60f8      	str	r0, [r7, #12]
 8014938:	60b9      	str	r1, [r7, #8]
 801493a:	607a      	str	r2, [r7, #4]
 801493c:	603b      	str	r3, [r7, #0]
	uint8_t                  *pRxPtr, *data;
	struct stm32_uart *uart;
	
    RT_ASSERT(serial != RT_NULL);
 801493e:	68fb      	ldr	r3, [r7, #12]
 8014940:	2b00      	cmp	r3, #0
 8014942:	d105      	bne.n	8014950 <stm32_dma_transmit+0x20>
 8014944:	480d      	ldr	r0, [pc, #52]	; (801497c <stm32_dma_transmit+0x4c>)
 8014946:	490e      	ldr	r1, [pc, #56]	; (8014980 <stm32_dma_transmit+0x50>)
 8014948:	f44f 729e 	mov.w	r2, #316	; 0x13c
 801494c:	f003 f830 	bl	80179b0 <rt_assert_handler>
    uart = (struct stm32_uart *)serial->parent.user_data;
 8014950:	68fb      	ldr	r3, [r7, #12]
 8014952:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8014954:	61fb      	str	r3, [r7, #28]
	if (direction == RT_SERIAL_DMA_RX)
 8014956:	683b      	ldr	r3, [r7, #0]
 8014958:	2b01      	cmp	r3, #1
 801495a:	d10b      	bne.n	8014974 <stm32_dma_transmit+0x44>
	{
		pRxPtr = uart->UartHandle.pRxBuffPtr;
 801495c:	69fb      	ldr	r3, [r7, #28]
 801495e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8014960:	61bb      	str	r3, [r7, #24]
		data = buf;
 8014962:	68bb      	ldr	r3, [r7, #8]
 8014964:	617b      	str	r3, [r7, #20]
		*data = 0;
 8014966:	697b      	ldr	r3, [r7, #20]
 8014968:	2200      	movs	r2, #0
 801496a:	701a      	strb	r2, [r3, #0]
			size--;
			if (i>=uart->UartHandle.RxXferSize)
			i = 0;
		}
		#endif
		*data = *pRxPtr;
 801496c:	69bb      	ldr	r3, [r7, #24]
 801496e:	781a      	ldrb	r2, [r3, #0]
 8014970:	697b      	ldr	r3, [r7, #20]
 8014972:	701a      	strb	r2, [r3, #0]
	}
}
 8014974:	4618      	mov	r0, r3
 8014976:	3720      	adds	r7, #32
 8014978:	46bd      	mov	sp, r7
 801497a:	bd80      	pop	{r7, pc}
 801497c:	08027104 	.word	0x08027104
 8014980:	08028d30 	.word	0x08028d30

08014984 <USART1_IRQHandler>:




void USART1_IRQHandler(void)
{
 8014984:	b580      	push	{r7, lr}
 8014986:	b082      	sub	sp, #8
 8014988:	af00      	add	r7, sp, #0
    struct stm32_uart *uart;

    uart = &uart1;
 801498a:	4b11      	ldr	r3, [pc, #68]	; (80149d0 <USART1_IRQHandler+0x4c>)
 801498c:	607b      	str	r3, [r7, #4]

    /* enter interrupt */
    rt_interrupt_enter();
 801498e:	f002 f985 	bl	8016c9c <rt_interrupt_enter>

    /* UART in mode Receiver ---------------------------------------------------*/
    if ((__HAL_UART_GET_IT(&uart->UartHandle, UART_IT_RXNE) != RESET) && (__HAL_UART_GET_IT_SOURCE(&uart->UartHandle, UART_IT_RXNE) != RESET))
 8014992:	687b      	ldr	r3, [r7, #4]
 8014994:	681b      	ldr	r3, [r3, #0]
 8014996:	69db      	ldr	r3, [r3, #28]
 8014998:	f003 0320 	and.w	r3, r3, #32
 801499c:	2b00      	cmp	r3, #0
 801499e:	d012      	beq.n	80149c6 <USART1_IRQHandler+0x42>
 80149a0:	687b      	ldr	r3, [r7, #4]
 80149a2:	681b      	ldr	r3, [r3, #0]
 80149a4:	681b      	ldr	r3, [r3, #0]
 80149a6:	f003 0320 	and.w	r3, r3, #32
 80149aa:	2b00      	cmp	r3, #0
 80149ac:	d00b      	beq.n	80149c6 <USART1_IRQHandler+0x42>
    {
        rt_hw_serial_isr(&serial1, RT_SERIAL_EVENT_RX_IND);
 80149ae:	4809      	ldr	r0, [pc, #36]	; (80149d4 <USART1_IRQHandler+0x50>)
 80149b0:	2101      	movs	r1, #1
 80149b2:	f006 fcb7 	bl	801b324 <rt_hw_serial_isr>
        /* Clear RXNE interrupt flag */
        __HAL_UART_SEND_REQ(&uart->UartHandle, UART_RXDATA_FLUSH_REQUEST);
 80149b6:	687b      	ldr	r3, [r7, #4]
 80149b8:	681b      	ldr	r3, [r3, #0]
 80149ba:	687a      	ldr	r2, [r7, #4]
 80149bc:	6812      	ldr	r2, [r2, #0]
 80149be:	6992      	ldr	r2, [r2, #24]
 80149c0:	f042 0208 	orr.w	r2, r2, #8
 80149c4:	619a      	str	r2, [r3, #24]
    }
    /* leave interrupt */
    rt_interrupt_leave();
 80149c6:	f002 f97f 	bl	8016cc8 <rt_interrupt_leave>
}
 80149ca:	3708      	adds	r7, #8
 80149cc:	46bd      	mov	sp, r7
 80149ce:	bd80      	pop	{r7, pc}
 80149d0:	200108e4 	.word	0x200108e4
 80149d4:	20012920 	.word	0x20012920

080149d8 <USART3_IRQHandler>:
#if defined(RT_USING_UART3)
/* UART1 device driver structure */


void USART3_IRQHandler(void)
{
 80149d8:	b580      	push	{r7, lr}
 80149da:	b082      	sub	sp, #8
 80149dc:	af00      	add	r7, sp, #0
    struct stm32_uart *uart;
    uart = &uart3;
 80149de:	4b11      	ldr	r3, [pc, #68]	; (8014a24 <USART3_IRQHandler+0x4c>)
 80149e0:	607b      	str	r3, [r7, #4]

    /* enter interrupt */
    rt_interrupt_enter();
 80149e2:	f002 f95b 	bl	8016c9c <rt_interrupt_enter>
	
    /* UART in mode Receiver ---------------------------------------------------*/
    if ((__HAL_UART_GET_IT(&uart->UartHandle, UART_IT_RXNE) != RESET) && (__HAL_UART_GET_IT_SOURCE(&uart->UartHandle, UART_IT_RXNE) != RESET))
 80149e6:	687b      	ldr	r3, [r7, #4]
 80149e8:	681b      	ldr	r3, [r3, #0]
 80149ea:	69db      	ldr	r3, [r3, #28]
 80149ec:	f003 0320 	and.w	r3, r3, #32
 80149f0:	2b00      	cmp	r3, #0
 80149f2:	d012      	beq.n	8014a1a <USART3_IRQHandler+0x42>
 80149f4:	687b      	ldr	r3, [r7, #4]
 80149f6:	681b      	ldr	r3, [r3, #0]
 80149f8:	681b      	ldr	r3, [r3, #0]
 80149fa:	f003 0320 	and.w	r3, r3, #32
 80149fe:	2b00      	cmp	r3, #0
 8014a00:	d00b      	beq.n	8014a1a <USART3_IRQHandler+0x42>
    {
        rt_hw_serial_isr(&serial3, RT_SERIAL_EVENT_RX_IND);
 8014a02:	4809      	ldr	r0, [pc, #36]	; (8014a28 <USART3_IRQHandler+0x50>)
 8014a04:	2101      	movs	r1, #1
 8014a06:	f006 fc8d 	bl	801b324 <rt_hw_serial_isr>
        /* Clear RXNE interrupt flag */
        __HAL_UART_SEND_REQ(&uart->UartHandle, UART_RXDATA_FLUSH_REQUEST);
 8014a0a:	687b      	ldr	r3, [r7, #4]
 8014a0c:	681b      	ldr	r3, [r3, #0]
 8014a0e:	687a      	ldr	r2, [r7, #4]
 8014a10:	6812      	ldr	r2, [r2, #0]
 8014a12:	6992      	ldr	r2, [r2, #24]
 8014a14:	f042 0208 	orr.w	r2, r2, #8
 8014a18:	619a      	str	r2, [r3, #24]
    }
	
    /* leave interrupt */
    rt_interrupt_leave();
 8014a1a:	f002 f955 	bl	8016cc8 <rt_interrupt_leave>
}
 8014a1e:	3708      	adds	r7, #8
 8014a20:	46bd      	mov	sp, r7
 8014a22:	bd80      	pop	{r7, pc}
 8014a24:	20010958 	.word	0x20010958
 8014a28:	20012974 	.word	0x20012974

08014a2c <DMA1_Stream1_IRQHandler>:
#endif /* RT_USING_UART3 */

void DMA1_Stream1_IRQHandler(void)
{
 8014a2c:	b580      	push	{r7, lr}
 8014a2e:	b082      	sub	sp, #8
 8014a30:	af00      	add	r7, sp, #0
	
    struct stm32_uart *uart;
	
	/* enter interrupt */
    rt_interrupt_enter();
 8014a32:	f002 f933 	bl	8016c9c <rt_interrupt_enter>
    uart = &uart3;
 8014a36:	4b06      	ldr	r3, [pc, #24]	; (8014a50 <DMA1_Stream1_IRQHandler+0x24>)
 8014a38:	607b      	str	r3, [r7, #4]
	
	HAL_DMA_IRQHandler((uart->UartHandle.hdmarx));
 8014a3a:	687b      	ldr	r3, [r7, #4]
 8014a3c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8014a3e:	4618      	mov	r0, r3
 8014a40:	f7f5 fb68 	bl	800a114 <HAL_DMA_IRQHandler>
		
	/* leave interrupt */
	rt_interrupt_leave();
 8014a44:	f002 f940 	bl	8016cc8 <rt_interrupt_leave>
}
 8014a48:	3708      	adds	r7, #8
 8014a4a:	46bd      	mov	sp, r7
 8014a4c:	bd80      	pop	{r7, pc}
 8014a4e:	bf00      	nop
 8014a50:	20010958 	.word	0x20010958

08014a54 <HAL_UART_MspInit>:
  *           - NVIC configuration for UART interrupt request enable
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
 8014a54:	b580      	push	{r7, lr}
 8014a56:	b08e      	sub	sp, #56	; 0x38
 8014a58:	af00      	add	r7, sp, #0
 8014a5a:	6078      	str	r0, [r7, #4]
    GPIO_InitTypeDef  GPIO_InitStruct;
    if (huart->Instance == USART1)
 8014a5c:	687b      	ldr	r3, [r7, #4]
 8014a5e:	681b      	ldr	r3, [r3, #0]
 8014a60:	4a4d      	ldr	r2, [pc, #308]	; (8014b98 <HAL_UART_MspInit+0x144>)
 8014a62:	4293      	cmp	r3, r2
 8014a64:	d147      	bne.n	8014af6 <HAL_UART_MspInit+0xa2>
    {
		/* Enable GPIO TX/RX clock */
        USART1_TX_GPIO_CLK_ENABLE();
 8014a66:	4a4d      	ldr	r2, [pc, #308]	; (8014b9c <HAL_UART_MspInit+0x148>)
 8014a68:	4b4c      	ldr	r3, [pc, #304]	; (8014b9c <HAL_UART_MspInit+0x148>)
 8014a6a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014a6c:	f043 0301 	orr.w	r3, r3, #1
 8014a70:	6313      	str	r3, [r2, #48]	; 0x30
 8014a72:	4b4a      	ldr	r3, [pc, #296]	; (8014b9c <HAL_UART_MspInit+0x148>)
 8014a74:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014a76:	f003 0301 	and.w	r3, r3, #1
 8014a7a:	623b      	str	r3, [r7, #32]
 8014a7c:	6a3b      	ldr	r3, [r7, #32]
        USART1_RX_GPIO_CLK_ENABLE();
 8014a7e:	4a47      	ldr	r2, [pc, #284]	; (8014b9c <HAL_UART_MspInit+0x148>)
 8014a80:	4b46      	ldr	r3, [pc, #280]	; (8014b9c <HAL_UART_MspInit+0x148>)
 8014a82:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014a84:	f043 0302 	orr.w	r3, r3, #2
 8014a88:	6313      	str	r3, [r2, #48]	; 0x30
 8014a8a:	4b44      	ldr	r3, [pc, #272]	; (8014b9c <HAL_UART_MspInit+0x148>)
 8014a8c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014a8e:	f003 0302 	and.w	r3, r3, #2
 8014a92:	61fb      	str	r3, [r7, #28]
 8014a94:	69fb      	ldr	r3, [r7, #28]
        /* Enable USARTx clock */
        USART1_CLK_ENABLE();
 8014a96:	4a41      	ldr	r2, [pc, #260]	; (8014b9c <HAL_UART_MspInit+0x148>)
 8014a98:	4b40      	ldr	r3, [pc, #256]	; (8014b9c <HAL_UART_MspInit+0x148>)
 8014a9a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8014a9c:	f043 0310 	orr.w	r3, r3, #16
 8014aa0:	6453      	str	r3, [r2, #68]	; 0x44
 8014aa2:	4b3e      	ldr	r3, [pc, #248]	; (8014b9c <HAL_UART_MspInit+0x148>)
 8014aa4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8014aa6:	f003 0310 	and.w	r3, r3, #16
 8014aaa:	61bb      	str	r3, [r7, #24]
 8014aac:	69bb      	ldr	r3, [r7, #24]

        /* UART TX GPIO pin configuration  */
        GPIO_InitStruct.Pin       = USART1_TX_PIN;
 8014aae:	f44f 7300 	mov.w	r3, #512	; 0x200
 8014ab2:	627b      	str	r3, [r7, #36]	; 0x24
        GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 8014ab4:	2302      	movs	r3, #2
 8014ab6:	62bb      	str	r3, [r7, #40]	; 0x28
        GPIO_InitStruct.Pull      = GPIO_PULLUP;
 8014ab8:	2301      	movs	r3, #1
 8014aba:	62fb      	str	r3, [r7, #44]	; 0x2c
        GPIO_InitStruct.Speed     = GPIO_SPEED_HIGH;
 8014abc:	2303      	movs	r3, #3
 8014abe:	633b      	str	r3, [r7, #48]	; 0x30
        GPIO_InitStruct.Alternate = USART1_TX_AF;
 8014ac0:	2307      	movs	r3, #7
 8014ac2:	637b      	str	r3, [r7, #52]	; 0x34
        HAL_GPIO_Init(USART1_TX_GPIO_PORT, &GPIO_InitStruct);
 8014ac4:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8014ac8:	4835      	ldr	r0, [pc, #212]	; (8014ba0 <HAL_UART_MspInit+0x14c>)
 8014aca:	4619      	mov	r1, r3
 8014acc:	f7f8 fc86 	bl	800d3dc <HAL_GPIO_Init>

        /* UART RX GPIO pin configuration  */
        GPIO_InitStruct.Pin = USART1_RX_PIN;
 8014ad0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8014ad4:	627b      	str	r3, [r7, #36]	; 0x24
        GPIO_InitStruct.Alternate = USART1_RX_AF;
 8014ad6:	2307      	movs	r3, #7
 8014ad8:	637b      	str	r3, [r7, #52]	; 0x34
        HAL_GPIO_Init(USART1_RX_GPIO_PORT, &GPIO_InitStruct);
 8014ada:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8014ade:	4830      	ldr	r0, [pc, #192]	; (8014ba0 <HAL_UART_MspInit+0x14c>)
 8014ae0:	4619      	mov	r1, r3
 8014ae2:	f7f8 fc7b 	bl	800d3dc <HAL_GPIO_Init>

        /* NVIC for USART */
        HAL_NVIC_SetPriority(USART1_IRQn, USART1_IRQ_PREEMPT ,USART1_TRQ_SUB);
 8014ae6:	2025      	movs	r0, #37	; 0x25
 8014ae8:	210f      	movs	r1, #15
 8014aea:	2200      	movs	r2, #0
 8014aec:	f7f3 ff92 	bl	8008a14 <HAL_NVIC_SetPriority>
       HAL_NVIC_EnableIRQ(USART1_IRQn);
 8014af0:	2025      	movs	r0, #37	; 0x25
 8014af2:	f7f3 ffab 	bl	8008a4c <HAL_NVIC_EnableIRQ>
	   //HAL_UART3_MspInit(huart);
    }
	
    if (huart->Instance == USART3)
 8014af6:	687b      	ldr	r3, [r7, #4]
 8014af8:	681b      	ldr	r3, [r3, #0]
 8014afa:	4a2a      	ldr	r2, [pc, #168]	; (8014ba4 <HAL_UART_MspInit+0x150>)
 8014afc:	4293      	cmp	r3, r2
 8014afe:	d147      	bne.n	8014b90 <HAL_UART_MspInit+0x13c>
    {
		/* Enable GPIO TX/RX clock */
        USART3_TX_GPIO_CLK_ENABLE();
 8014b00:	4a26      	ldr	r2, [pc, #152]	; (8014b9c <HAL_UART_MspInit+0x148>)
 8014b02:	4b26      	ldr	r3, [pc, #152]	; (8014b9c <HAL_UART_MspInit+0x148>)
 8014b04:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014b06:	f043 0304 	orr.w	r3, r3, #4
 8014b0a:	6313      	str	r3, [r2, #48]	; 0x30
 8014b0c:	4b23      	ldr	r3, [pc, #140]	; (8014b9c <HAL_UART_MspInit+0x148>)
 8014b0e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014b10:	f003 0304 	and.w	r3, r3, #4
 8014b14:	617b      	str	r3, [r7, #20]
 8014b16:	697b      	ldr	r3, [r7, #20]
        USART3_RX_GPIO_CLK_ENABLE();
 8014b18:	4a20      	ldr	r2, [pc, #128]	; (8014b9c <HAL_UART_MspInit+0x148>)
 8014b1a:	4b20      	ldr	r3, [pc, #128]	; (8014b9c <HAL_UART_MspInit+0x148>)
 8014b1c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014b1e:	f043 0304 	orr.w	r3, r3, #4
 8014b22:	6313      	str	r3, [r2, #48]	; 0x30
 8014b24:	4b1d      	ldr	r3, [pc, #116]	; (8014b9c <HAL_UART_MspInit+0x148>)
 8014b26:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014b28:	f003 0304 	and.w	r3, r3, #4
 8014b2c:	613b      	str	r3, [r7, #16]
 8014b2e:	693b      	ldr	r3, [r7, #16]
        /* Enable USARTx clock */
        USART3_CLK_ENABLE();
 8014b30:	4a1a      	ldr	r2, [pc, #104]	; (8014b9c <HAL_UART_MspInit+0x148>)
 8014b32:	4b1a      	ldr	r3, [pc, #104]	; (8014b9c <HAL_UART_MspInit+0x148>)
 8014b34:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8014b36:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8014b3a:	6413      	str	r3, [r2, #64]	; 0x40
 8014b3c:	4b17      	ldr	r3, [pc, #92]	; (8014b9c <HAL_UART_MspInit+0x148>)
 8014b3e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8014b40:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8014b44:	60fb      	str	r3, [r7, #12]
 8014b46:	68fb      	ldr	r3, [r7, #12]

        /* UART TX GPIO pin configuration  */
        GPIO_InitStruct.Pin       = USART3_TX_PIN;
 8014b48:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8014b4c:	627b      	str	r3, [r7, #36]	; 0x24
        GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 8014b4e:	2302      	movs	r3, #2
 8014b50:	62bb      	str	r3, [r7, #40]	; 0x28
        GPIO_InitStruct.Pull      = GPIO_PULLUP;
 8014b52:	2301      	movs	r3, #1
 8014b54:	62fb      	str	r3, [r7, #44]	; 0x2c
        GPIO_InitStruct.Speed     = GPIO_SPEED_HIGH;
 8014b56:	2303      	movs	r3, #3
 8014b58:	633b      	str	r3, [r7, #48]	; 0x30
        GPIO_InitStruct.Alternate = USART3_TX_AF;
 8014b5a:	2307      	movs	r3, #7
 8014b5c:	637b      	str	r3, [r7, #52]	; 0x34
        HAL_GPIO_Init(USART3_TX_GPIO_PORT, &GPIO_InitStruct);
 8014b5e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8014b62:	4811      	ldr	r0, [pc, #68]	; (8014ba8 <HAL_UART_MspInit+0x154>)
 8014b64:	4619      	mov	r1, r3
 8014b66:	f7f8 fc39 	bl	800d3dc <HAL_GPIO_Init>

        /* UART RX GPIO pin configuration  */
        GPIO_InitStruct.Pin = USART3_RX_PIN;
 8014b6a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8014b6e:	627b      	str	r3, [r7, #36]	; 0x24
        GPIO_InitStruct.Alternate = USART3_RX_AF;
 8014b70:	2307      	movs	r3, #7
 8014b72:	637b      	str	r3, [r7, #52]	; 0x34
        HAL_GPIO_Init(USART3_RX_GPIO_PORT, &GPIO_InitStruct);
 8014b74:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8014b78:	480b      	ldr	r0, [pc, #44]	; (8014ba8 <HAL_UART_MspInit+0x154>)
 8014b7a:	4619      	mov	r1, r3
 8014b7c:	f7f8 fc2e 	bl	800d3dc <HAL_GPIO_Init>

        /* NVIC for USART */
        HAL_NVIC_SetPriority(USART3_IRQn, USART3_IRQ_PREEMPT ,USART3_TRQ_SUB);
 8014b80:	2027      	movs	r0, #39	; 0x27
 8014b82:	210f      	movs	r1, #15
 8014b84:	2200      	movs	r2, #0
 8014b86:	f7f3 ff45 	bl	8008a14 <HAL_NVIC_SetPriority>
      	HAL_NVIC_EnableIRQ(USART3_IRQn);
 8014b8a:	2027      	movs	r0, #39	; 0x27
 8014b8c:	f7f3 ff5e 	bl	8008a4c <HAL_NVIC_EnableIRQ>
    }
}
 8014b90:	3738      	adds	r7, #56	; 0x38
 8014b92:	46bd      	mov	sp, r7
 8014b94:	bd80      	pop	{r7, pc}
 8014b96:	bf00      	nop
 8014b98:	40011000 	.word	0x40011000
 8014b9c:	40023800 	.word	0x40023800
 8014ba0:	40020000 	.word	0x40020000
 8014ba4:	40004800 	.word	0x40004800
 8014ba8:	40020800 	.word	0x40020800

08014bac <HAL_UART_MspDeInit>:
  *          - Revert GPIO and NVIC configuration to their default state
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
{
 8014bac:	b580      	push	{r7, lr}
 8014bae:	b082      	sub	sp, #8
 8014bb0:	af00      	add	r7, sp, #0
 8014bb2:	6078      	str	r0, [r7, #4]
    if (huart->Instance == USART1)
 8014bb4:	687b      	ldr	r3, [r7, #4]
 8014bb6:	681b      	ldr	r3, [r3, #0]
 8014bb8:	4a1e      	ldr	r2, [pc, #120]	; (8014c34 <HAL_UART_MspDeInit+0x88>)
 8014bba:	4293      	cmp	r3, r2
 8014bbc:	d118      	bne.n	8014bf0 <HAL_UART_MspDeInit+0x44>
    {
        /* Reset peripherals */
        USART1_FORCE_RESET();
 8014bbe:	4a1e      	ldr	r2, [pc, #120]	; (8014c38 <HAL_UART_MspDeInit+0x8c>)
 8014bc0:	4b1d      	ldr	r3, [pc, #116]	; (8014c38 <HAL_UART_MspDeInit+0x8c>)
 8014bc2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014bc4:	f043 0310 	orr.w	r3, r3, #16
 8014bc8:	6253      	str	r3, [r2, #36]	; 0x24
        USART1_RELEASE_RESET();
 8014bca:	4a1b      	ldr	r2, [pc, #108]	; (8014c38 <HAL_UART_MspDeInit+0x8c>)
 8014bcc:	4b1a      	ldr	r3, [pc, #104]	; (8014c38 <HAL_UART_MspDeInit+0x8c>)
 8014bce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014bd0:	f023 0310 	bic.w	r3, r3, #16
 8014bd4:	6253      	str	r3, [r2, #36]	; 0x24

        /* Disable peripherals and GPIO Clocks */
        /* Configure UART Tx as alternate function  */
        HAL_GPIO_DeInit(USART1_TX_GPIO_PORT, USART1_TX_PIN);
 8014bd6:	4819      	ldr	r0, [pc, #100]	; (8014c3c <HAL_UART_MspDeInit+0x90>)
 8014bd8:	f44f 7100 	mov.w	r1, #512	; 0x200
 8014bdc:	f7f8 fda4 	bl	800d728 <HAL_GPIO_DeInit>
        /* Configure UART Rx as alternate function  */
        HAL_GPIO_DeInit(USART1_RX_GPIO_PORT, USART1_RX_PIN);
 8014be0:	4816      	ldr	r0, [pc, #88]	; (8014c3c <HAL_UART_MspDeInit+0x90>)
 8014be2:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8014be6:	f7f8 fd9f 	bl	800d728 <HAL_GPIO_DeInit>

        /* Disable the NVIC for UART */
        HAL_NVIC_DisableIRQ(USART1_IRQn);
 8014bea:	2025      	movs	r0, #37	; 0x25
 8014bec:	f7f3 ff3c 	bl	8008a68 <HAL_NVIC_DisableIRQ>
    }
	//HAL_UART3_MspDeInit(huart);
	
    if (huart->Instance == USART3)
 8014bf0:	687b      	ldr	r3, [r7, #4]
 8014bf2:	681b      	ldr	r3, [r3, #0]
 8014bf4:	4a12      	ldr	r2, [pc, #72]	; (8014c40 <HAL_UART_MspDeInit+0x94>)
 8014bf6:	4293      	cmp	r3, r2
 8014bf8:	d118      	bne.n	8014c2c <HAL_UART_MspDeInit+0x80>
    {
        /* Reset peripherals */
        USART3_FORCE_RESET();
 8014bfa:	4a0f      	ldr	r2, [pc, #60]	; (8014c38 <HAL_UART_MspDeInit+0x8c>)
 8014bfc:	4b0e      	ldr	r3, [pc, #56]	; (8014c38 <HAL_UART_MspDeInit+0x8c>)
 8014bfe:	6a1b      	ldr	r3, [r3, #32]
 8014c00:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8014c04:	6213      	str	r3, [r2, #32]
        USART3_RELEASE_RESET();
 8014c06:	4a0c      	ldr	r2, [pc, #48]	; (8014c38 <HAL_UART_MspDeInit+0x8c>)
 8014c08:	4b0b      	ldr	r3, [pc, #44]	; (8014c38 <HAL_UART_MspDeInit+0x8c>)
 8014c0a:	6a1b      	ldr	r3, [r3, #32]
 8014c0c:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8014c10:	6213      	str	r3, [r2, #32]

        /* Disable peripherals and GPIO Clocks */
        /* Configure UART Tx as alternate function  */
        HAL_GPIO_DeInit(USART3_TX_GPIO_PORT, USART3_TX_PIN);
 8014c12:	480c      	ldr	r0, [pc, #48]	; (8014c44 <HAL_UART_MspDeInit+0x98>)
 8014c14:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8014c18:	f7f8 fd86 	bl	800d728 <HAL_GPIO_DeInit>
        /* Configure UART Rx as alternate function  */
        HAL_GPIO_DeInit(USART3_RX_GPIO_PORT, USART3_RX_PIN);
 8014c1c:	4809      	ldr	r0, [pc, #36]	; (8014c44 <HAL_UART_MspDeInit+0x98>)
 8014c1e:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8014c22:	f7f8 fd81 	bl	800d728 <HAL_GPIO_DeInit>

        /* Disable the NVIC for UART */
        HAL_NVIC_DisableIRQ(USART3_IRQn);
 8014c26:	2027      	movs	r0, #39	; 0x27
 8014c28:	f7f3 ff1e 	bl	8008a68 <HAL_NVIC_DisableIRQ>
    }
}
 8014c2c:	3708      	adds	r7, #8
 8014c2e:	46bd      	mov	sp, r7
 8014c30:	bd80      	pop	{r7, pc}
 8014c32:	bf00      	nop
 8014c34:	40011000 	.word	0x40011000
 8014c38:	40023800 	.word	0x40023800
 8014c3c:	40020000 	.word	0x40020000
 8014c40:	40004800 	.word	0x40004800
 8014c44:	40020800 	.word	0x40020800

08014c48 <stm32_hw_usart_init>:

int stm32_hw_usart_init(void)
{
 8014c48:	b580      	push	{r7, lr}
 8014c4a:	b086      	sub	sp, #24
 8014c4c:	af00      	add	r7, sp, #0
    struct stm32_uart *uart;
    struct serial_configure config = RT_SERIAL_CONFIG_DEFAULT;
 8014c4e:	4a1f      	ldr	r2, [pc, #124]	; (8014ccc <stm32_hw_usart_init+0x84>)
 8014c50:	f107 030c 	add.w	r3, r7, #12
 8014c54:	e892 0003 	ldmia.w	r2, {r0, r1}
 8014c58:	e883 0003 	stmia.w	r3, {r0, r1}

#ifdef RT_USING_UART1
    uart = &uart1;
 8014c5c:	4b1c      	ldr	r3, [pc, #112]	; (8014cd0 <stm32_hw_usart_init+0x88>)
 8014c5e:	617b      	str	r3, [r7, #20]
    uart->UartHandle.Instance = USART1;
 8014c60:	697b      	ldr	r3, [r7, #20]
 8014c62:	4a1c      	ldr	r2, [pc, #112]	; (8014cd4 <stm32_hw_usart_init+0x8c>)
 8014c64:	601a      	str	r2, [r3, #0]

    serial1.ops    = &stm32_uart_ops;
 8014c66:	4b1c      	ldr	r3, [pc, #112]	; (8014cd8 <stm32_hw_usart_init+0x90>)
 8014c68:	4a1c      	ldr	r2, [pc, #112]	; (8014cdc <stm32_hw_usart_init+0x94>)
 8014c6a:	641a      	str	r2, [r3, #64]	; 0x40
    serial1.config = config;
 8014c6c:	4b1a      	ldr	r3, [pc, #104]	; (8014cd8 <stm32_hw_usart_init+0x90>)
 8014c6e:	3344      	adds	r3, #68	; 0x44
 8014c70:	f107 020c 	add.w	r2, r7, #12
 8014c74:	e892 0003 	ldmia.w	r2, {r0, r1}
 8014c78:	e883 0003 	stmia.w	r3, {r0, r1}

    /* register UART1 device */
    rt_hw_serial_register(&serial1, "uart1",
 8014c7c:	4816      	ldr	r0, [pc, #88]	; (8014cd8 <stm32_hw_usart_init+0x90>)
 8014c7e:	4918      	ldr	r1, [pc, #96]	; (8014ce0 <stm32_hw_usart_init+0x98>)
 8014c80:	f240 1203 	movw	r2, #259	; 0x103
 8014c84:	697b      	ldr	r3, [r7, #20]
 8014c86:	f006 fb01 	bl	801b28c <rt_hw_serial_register>
                          RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX,
                          uart);
#endif /* RT_USING_UART1 */

#ifdef RT_USING_UART3
		uart = &uart3;
 8014c8a:	4b16      	ldr	r3, [pc, #88]	; (8014ce4 <stm32_hw_usart_init+0x9c>)
 8014c8c:	617b      	str	r3, [r7, #20]
		uart->UartHandle.Instance = USART3;
 8014c8e:	697b      	ldr	r3, [r7, #20]
 8014c90:	4a15      	ldr	r2, [pc, #84]	; (8014ce8 <stm32_hw_usart_init+0xa0>)
 8014c92:	601a      	str	r2, [r3, #0]
		struct serial_configure config_uart3 = RT_SERIAL_CONFIG_UART3;
 8014c94:	4a15      	ldr	r2, [pc, #84]	; (8014cec <stm32_hw_usart_init+0xa4>)
 8014c96:	1d3b      	adds	r3, r7, #4
 8014c98:	e892 0003 	ldmia.w	r2, {r0, r1}
 8014c9c:	e883 0003 	stmia.w	r3, {r0, r1}
		
		serial3.ops    = &stm32_uart_ops;
 8014ca0:	4b13      	ldr	r3, [pc, #76]	; (8014cf0 <stm32_hw_usart_init+0xa8>)
 8014ca2:	4a0e      	ldr	r2, [pc, #56]	; (8014cdc <stm32_hw_usart_init+0x94>)
 8014ca4:	641a      	str	r2, [r3, #64]	; 0x40
		serial3.config = config_uart3;
 8014ca6:	4b12      	ldr	r3, [pc, #72]	; (8014cf0 <stm32_hw_usart_init+0xa8>)
 8014ca8:	3344      	adds	r3, #68	; 0x44
 8014caa:	1d3a      	adds	r2, r7, #4
 8014cac:	e892 0003 	ldmia.w	r2, {r0, r1}
 8014cb0:	e883 0003 	stmia.w	r3, {r0, r1}
	
		/* register UART1 device */
		rt_hw_serial_register(&serial3, "uart3",
 8014cb4:	480e      	ldr	r0, [pc, #56]	; (8014cf0 <stm32_hw_usart_init+0xa8>)
 8014cb6:	490f      	ldr	r1, [pc, #60]	; (8014cf4 <stm32_hw_usart_init+0xac>)
 8014cb8:	f240 1203 	movw	r2, #259	; 0x103
 8014cbc:	697b      	ldr	r3, [r7, #20]
 8014cbe:	f006 fae5 	bl	801b28c <rt_hw_serial_register>
							  RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX,
							  uart);
#endif /* RT_USING_UART3 */


    return 0;
 8014cc2:	2300      	movs	r3, #0
}
 8014cc4:	4618      	mov	r0, r3
 8014cc6:	3718      	adds	r7, #24
 8014cc8:	46bd      	mov	sp, r7
 8014cca:	bd80      	pop	{r7, pc}
 8014ccc:	0802714c 	.word	0x0802714c
 8014cd0:	200108e4 	.word	0x200108e4
 8014cd4:	40011000 	.word	0x40011000
 8014cd8:	20012920 	.word	0x20012920
 8014cdc:	08028ce4 	.word	0x08028ce4
 8014ce0:	0802713c 	.word	0x0802713c
 8014ce4:	20010958 	.word	0x20010958
 8014ce8:	40004800 	.word	0x40004800
 8014cec:	08027154 	.word	0x08027154
 8014cf0:	20012974 	.word	0x20012974
 8014cf4:	08027144 	.word	0x08027144

08014cf8 <NMI_Handler>:
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 8014cf8:	b480      	push	{r7}
 8014cfa:	af00      	add	r7, sp, #0
}
 8014cfc:	46bd      	mov	sp, r7
 8014cfe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014d02:	4770      	bx	lr

08014d04 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 8014d04:	b480      	push	{r7}
 8014d06:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
  {
  }
 8014d08:	e7fe      	b.n	8014d08 <BusFault_Handler+0x4>
 8014d0a:	bf00      	nop

08014d0c <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8014d0c:	b480      	push	{r7}
 8014d0e:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
  {
  }
 8014d10:	e7fe      	b.n	8014d10 <UsageFault_Handler+0x4>
 8014d12:	bf00      	nop

08014d14 <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 8014d14:	b480      	push	{r7}
 8014d16:	af00      	add	r7, sp, #0
}
 8014d18:	46bd      	mov	sp, r7
 8014d1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014d1e:	4770      	bx	lr

08014d20 <J1939_TxdTask_entry>:
unsigned char *data;

#if 1

void J1939_TxdTask_entry(void *parameter)
{
 8014d20:	b580      	push	{r7, lr}
 8014d22:	b084      	sub	sp, #16
 8014d24:	af00      	add	r7, sp, #0
 8014d26:	6078      	str	r0, [r7, #4]
    rt_thread_t tid;
	
	//ca_msg.CAname = &caname;
	//ca_msg.msg.SourceAddress = DEFAULTADDRCA1;
	
	if(ca_msg != NULL)
 8014d28:	4b0d      	ldr	r3, [pc, #52]	; (8014d60 <J1939_TxdTask_entry+0x40>)
 8014d2a:	681b      	ldr	r3, [r3, #0]
 8014d2c:	2b00      	cmp	r3, #0
 8014d2e:	d00d      	beq.n	8014d4c <J1939_TxdTask_entry+0x2c>
	{
		if (sendMessage(ca_msg,data)== RC_ERROR)
 8014d30:	4b0b      	ldr	r3, [pc, #44]	; (8014d60 <J1939_TxdTask_entry+0x40>)
 8014d32:	681a      	ldr	r2, [r3, #0]
 8014d34:	4b0b      	ldr	r3, [pc, #44]	; (8014d64 <J1939_TxdTask_entry+0x44>)
 8014d36:	681b      	ldr	r3, [r3, #0]
 8014d38:	4610      	mov	r0, r2
 8014d3a:	4619      	mov	r1, r3
 8014d3c:	f7fb fefe 	bl	8010b3c <sendMessage>
 8014d40:	4603      	mov	r3, r0
 8014d42:	2b01      	cmp	r3, #1
 8014d44:	d102      	bne.n	8014d4c <J1939_TxdTask_entry+0x2c>
			rt_kprintf("rc_error\r\n");
 8014d46:	4808      	ldr	r0, [pc, #32]	; (8014d68 <J1939_TxdTask_entry+0x48>)
 8014d48:	f002 fdb8 	bl	80178bc <rt_kprintf>
	}
	tid = rt_thread_self();
 8014d4c:	f003 ff40 	bl	8018bd0 <rt_thread_self>
 8014d50:	60f8      	str	r0, [r7, #12]
	rt_thread_delete(tid);
 8014d52:	68f8      	ldr	r0, [r7, #12]
 8014d54:	f003 ffb8 	bl	8018cc8 <rt_thread_delete>

}
 8014d58:	3710      	adds	r7, #16
 8014d5a:	46bd      	mov	sp, r7
 8014d5c:	bd80      	pop	{r7, pc}
 8014d5e:	bf00      	nop
 8014d60:	200129cc 	.word	0x200129cc
 8014d64:	200129c8 	.word	0x200129c8
 8014d68:	0802715c 	.word	0x0802715c

08014d6c <CANtx>:

void CANtx(int argc,char**argv)
{
 8014d6c:	b590      	push	{r4, r7, lr}
 8014d6e:	b089      	sub	sp, #36	; 0x24
 8014d70:	af02      	add	r7, sp, #8
 8014d72:	6078      	str	r0, [r7, #4]
 8014d74:	6039      	str	r1, [r7, #0]
		data[i] = 0x55;
	}
	sendMessage(&CA_msg,data);
	#endif
    rt_thread_t tid;
	unsigned int sendsize = atoi(argv[1]);
 8014d76:	683b      	ldr	r3, [r7, #0]
 8014d78:	3304      	adds	r3, #4
 8014d7a:	681b      	ldr	r3, [r3, #0]
 8014d7c:	4618      	mov	r0, r3
 8014d7e:	f00d feb1 	bl	8022ae4 <atoi>
 8014d82:	4603      	mov	r3, r0
 8014d84:	613b      	str	r3, [r7, #16]
	unsigned int i;
	if(data != NULL)
 8014d86:	4b36      	ldr	r3, [pc, #216]	; (8014e60 <CANtx+0xf4>)
 8014d88:	681b      	ldr	r3, [r3, #0]
 8014d8a:	2b00      	cmp	r3, #0
 8014d8c:	d006      	beq.n	8014d9c <CANtx+0x30>
		data = (unsigned char *)malloc(sendsize * sizeof(char));
 8014d8e:	6938      	ldr	r0, [r7, #16]
 8014d90:	f00d ffe6 	bl	8022d60 <malloc>
 8014d94:	4603      	mov	r3, r0
 8014d96:	461a      	mov	r2, r3
 8014d98:	4b31      	ldr	r3, [pc, #196]	; (8014e60 <CANtx+0xf4>)
 8014d9a:	601a      	str	r2, [r3, #0]

	ca_msg->sendbytes = sendsize;
 8014d9c:	4b31      	ldr	r3, [pc, #196]	; (8014e64 <CANtx+0xf8>)
 8014d9e:	681b      	ldr	r3, [r3, #0]
 8014da0:	693a      	ldr	r2, [r7, #16]
 8014da2:	b292      	uxth	r2, r2
 8014da4:	829a      	strh	r2, [r3, #20]
	ca_msg->msg.DataPage = 0;
 8014da6:	4b2f      	ldr	r3, [pc, #188]	; (8014e64 <CANtx+0xf8>)
 8014da8:	681a      	ldr	r2, [r3, #0]
 8014daa:	7913      	ldrb	r3, [r2, #4]
 8014dac:	f36f 03c3 	bfc	r3, #3, #1
 8014db0:	7113      	strb	r3, [r2, #4]
	ca_msg->msg.edp =0;
 8014db2:	4b2c      	ldr	r3, [pc, #176]	; (8014e64 <CANtx+0xf8>)
 8014db4:	681a      	ldr	r2, [r3, #0]
 8014db6:	7913      	ldrb	r3, [r2, #4]
 8014db8:	f36f 1304 	bfc	r3, #4, #1
 8014dbc:	7113      	strb	r3, [r2, #4]
	ca_msg->msg.PDUFormat = atoi(argv[2]);
 8014dbe:	4b29      	ldr	r3, [pc, #164]	; (8014e64 <CANtx+0xf8>)
 8014dc0:	681c      	ldr	r4, [r3, #0]
 8014dc2:	683b      	ldr	r3, [r7, #0]
 8014dc4:	3308      	adds	r3, #8
 8014dc6:	681b      	ldr	r3, [r3, #0]
 8014dc8:	4618      	mov	r0, r3
 8014dca:	f00d fe8b 	bl	8022ae4 <atoi>
 8014dce:	4603      	mov	r3, r0
 8014dd0:	b2db      	uxtb	r3, r3
 8014dd2:	7163      	strb	r3, [r4, #5]
	ca_msg->msg.PDUSpecific = atoi(argv[3]);
 8014dd4:	4b23      	ldr	r3, [pc, #140]	; (8014e64 <CANtx+0xf8>)
 8014dd6:	681c      	ldr	r4, [r3, #0]
 8014dd8:	683b      	ldr	r3, [r7, #0]
 8014dda:	330c      	adds	r3, #12
 8014ddc:	681b      	ldr	r3, [r3, #0]
 8014dde:	4618      	mov	r0, r3
 8014de0:	f00d fe80 	bl	8022ae4 <atoi>
 8014de4:	4603      	mov	r3, r0
 8014de6:	b2db      	uxtb	r3, r3
 8014de8:	71a3      	strb	r3, [r4, #6]
	ca_msg->msg.Priority = 6;
 8014dea:	4b1e      	ldr	r3, [pc, #120]	; (8014e64 <CANtx+0xf8>)
 8014dec:	681a      	ldr	r2, [r3, #0]
 8014dee:	7913      	ldrb	r3, [r2, #4]
 8014df0:	2106      	movs	r1, #6
 8014df2:	f361 1347 	bfi	r3, r1, #5, #3
 8014df6:	7113      	strb	r3, [r2, #4]
	
	for(i=0;i<sendsize;i++)
 8014df8:	2300      	movs	r3, #0
 8014dfa:	617b      	str	r3, [r7, #20]
 8014dfc:	e00b      	b.n	8014e16 <CANtx+0xaa>
		data[i] = i+1;
 8014dfe:	4b18      	ldr	r3, [pc, #96]	; (8014e60 <CANtx+0xf4>)
 8014e00:	681a      	ldr	r2, [r3, #0]
 8014e02:	697b      	ldr	r3, [r7, #20]
 8014e04:	4413      	add	r3, r2
 8014e06:	697a      	ldr	r2, [r7, #20]
 8014e08:	b2d2      	uxtb	r2, r2
 8014e0a:	3201      	adds	r2, #1
 8014e0c:	b2d2      	uxtb	r2, r2
 8014e0e:	701a      	strb	r2, [r3, #0]
	ca_msg->msg.edp =0;
	ca_msg->msg.PDUFormat = atoi(argv[2]);
	ca_msg->msg.PDUSpecific = atoi(argv[3]);
	ca_msg->msg.Priority = 6;
	
	for(i=0;i<sendsize;i++)
 8014e10:	697b      	ldr	r3, [r7, #20]
 8014e12:	3301      	adds	r3, #1
 8014e14:	617b      	str	r3, [r7, #20]
 8014e16:	697a      	ldr	r2, [r7, #20]
 8014e18:	693b      	ldr	r3, [r7, #16]
 8014e1a:	429a      	cmp	r2, r3
 8014e1c:	d3ef      	bcc.n	8014dfe <CANtx+0x92>
		data[i] = i+1;

	tid = rt_thread_create("J1939txd",						
 8014e1e:	230a      	movs	r3, #10
 8014e20:	9300      	str	r3, [sp, #0]
 8014e22:	2314      	movs	r3, #20
 8014e24:	9301      	str	r3, [sp, #4]
 8014e26:	4810      	ldr	r0, [pc, #64]	; (8014e68 <CANtx+0xfc>)
 8014e28:	4910      	ldr	r1, [pc, #64]	; (8014e6c <CANtx+0x100>)
 8014e2a:	2200      	movs	r2, #0
 8014e2c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8014e30:	f003 ff18 	bl	8018c64 <rt_thread_create>
 8014e34:	60f8      	str	r0, [r7, #12]
                          J1939_TxdTask_entry, RT_NULL,
                           1024, J1939_TXDTASK_PRIORITY, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 8014e36:	68fb      	ldr	r3, [r7, #12]
 8014e38:	2b00      	cmp	r3, #0
 8014e3a:	d002      	beq.n	8014e42 <CANtx+0xd6>
 8014e3c:	68f8      	ldr	r0, [r7, #12]
 8014e3e:	f003 fed3 	bl	8018be8 <rt_thread_startup>
	if(data != NULL)
 8014e42:	4b07      	ldr	r3, [pc, #28]	; (8014e60 <CANtx+0xf4>)
 8014e44:	681b      	ldr	r3, [r3, #0]
 8014e46:	2b00      	cmp	r3, #0
 8014e48:	d007      	beq.n	8014e5a <CANtx+0xee>
	{
		free(data);
 8014e4a:	4b05      	ldr	r3, [pc, #20]	; (8014e60 <CANtx+0xf4>)
 8014e4c:	681b      	ldr	r3, [r3, #0]
 8014e4e:	4618      	mov	r0, r3
 8014e50:	f00d ff8e 	bl	8022d70 <free>
		data = NULL;
 8014e54:	4b02      	ldr	r3, [pc, #8]	; (8014e60 <CANtx+0xf4>)
 8014e56:	2200      	movs	r2, #0
 8014e58:	601a      	str	r2, [r3, #0]
	}
}
 8014e5a:	371c      	adds	r7, #28
 8014e5c:	46bd      	mov	sp, r7
 8014e5e:	bd90      	pop	{r4, r7, pc}
 8014e60:	200129c8 	.word	0x200129c8
 8014e64:	200129cc 	.word	0x200129cc
 8014e68:	08027168 	.word	0x08027168
 8014e6c:	08014d21 	.word	0x08014d21

08014e70 <USER_CanTask_entry>:
#endif



void USER_CanTask_entry(void *parameter)
{
 8014e70:	b580      	push	{r7, lr}
 8014e72:	b08a      	sub	sp, #40	; 0x28
 8014e74:	af00      	add	r7, sp, #0
 8014e76:	6078      	str	r0, [r7, #4]
			rt_kprintf("\r\n");
		}
		rt_thread_delay(20);
	}
	#endif
	struct J1939_CAname caname = CA1;
 8014e78:	4a3e      	ldr	r2, [pc, #248]	; (8014f74 <USER_CanTask_entry+0x104>)
 8014e7a:	f107 0314 	add.w	r3, r7, #20
 8014e7e:	e892 0003 	ldmia.w	r2, {r0, r1}
 8014e82:	e883 0003 	stmia.w	r3, {r0, r1}
	rt_size_t size;
	
    osEvent event;
	struct rx_Message *rxmsg;
	
	device = rt_device_find("can1");
 8014e86:	483c      	ldr	r0, [pc, #240]	; (8014f78 <USER_CanTask_entry+0x108>)
 8014e88:	f000 fe8a 	bl	8015ba0 <rt_device_find>
 8014e8c:	6238      	str	r0, [r7, #32]
	
	if(device != RT_NULL)
 8014e8e:	6a3b      	ldr	r3, [r7, #32]
 8014e90:	2b00      	cmp	r3, #0
 8014e92:	d00a      	beq.n	8014eaa <USER_CanTask_entry+0x3a>
		if (rt_device_open (device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_INT_RX) != RT_EOK)
 8014e94:	6a38      	ldr	r0, [r7, #32]
 8014e96:	f240 1103 	movw	r1, #259	; 0x103
 8014e9a:	f000 febd 	bl	8015c18 <rt_device_open>
 8014e9e:	4603      	mov	r3, r0
 8014ea0:	2b00      	cmp	r3, #0
 8014ea2:	d002      	beq.n	8014eaa <USER_CanTask_entry+0x3a>
		{
			rt_kprintf("open error\r\n");
 8014ea4:	4835      	ldr	r0, [pc, #212]	; (8014f7c <USER_CanTask_entry+0x10c>)
 8014ea6:	f002 fd09 	bl	80178bc <rt_kprintf>
		}
	
	initJ1939();
 8014eaa:	f7fc fdbd 	bl	8011a28 <initJ1939>
	ca_msg = (CA_Msg_t)malloc(sizeof(struct CA_Msg));
 8014eae:	2064      	movs	r0, #100	; 0x64
 8014eb0:	f00d ff56 	bl	8022d60 <malloc>
 8014eb4:	4603      	mov	r3, r0
 8014eb6:	461a      	mov	r2, r3
 8014eb8:	4b31      	ldr	r3, [pc, #196]	; (8014f80 <USER_CanTask_entry+0x110>)
 8014eba:	601a      	str	r2, [r3, #0]
	if(ca_msg != NULL)
 8014ebc:	4b30      	ldr	r3, [pc, #192]	; (8014f80 <USER_CanTask_entry+0x110>)
 8014ebe:	681b      	ldr	r3, [r3, #0]
 8014ec0:	2b00      	cmp	r3, #0
 8014ec2:	d014      	beq.n	8014eee <USER_CanTask_entry+0x7e>
	{
		
		memset(ca_msg,0,sizeof(struct CA_Msg));
 8014ec4:	4b2e      	ldr	r3, [pc, #184]	; (8014f80 <USER_CanTask_entry+0x110>)
 8014ec6:	681b      	ldr	r3, [r3, #0]
 8014ec8:	4618      	mov	r0, r3
 8014eca:	2100      	movs	r1, #0
 8014ecc:	2264      	movs	r2, #100	; 0x64
 8014ece:	f00d ff57 	bl	8022d80 <memset>
		ca_msg->CAname = &caname;
 8014ed2:	4b2b      	ldr	r3, [pc, #172]	; (8014f80 <USER_CanTask_entry+0x110>)
 8014ed4:	681b      	ldr	r3, [r3, #0]
 8014ed6:	f107 0214 	add.w	r2, r7, #20
 8014eda:	601a      	str	r2, [r3, #0]
		ca_msg->msg.SourceAddress = DEFAULTADDRCA1;
 8014edc:	4b28      	ldr	r3, [pc, #160]	; (8014f80 <USER_CanTask_entry+0x110>)
 8014ede:	681b      	ldr	r3, [r3, #0]
 8014ee0:	2223      	movs	r2, #35	; 0x23
 8014ee2:	71da      	strb	r2, [r3, #7]

		J1939_CA_register(ca_msg);
 8014ee4:	4b26      	ldr	r3, [pc, #152]	; (8014f80 <USER_CanTask_entry+0x110>)
 8014ee6:	681b      	ldr	r3, [r3, #0]
 8014ee8:	4618      	mov	r0, r3
 8014eea:	f7fb fb0d 	bl	8010508 <J1939_CA_register>
		ca_msg->msg.PDUSpecific = 0x23;
		ca_msg->msg.Priority = 6;
		if (sendMessage(ca_msg,data)== RC_ERROR)
			rt_kprintf("rc_error\r\n");
		#endif
		event = osMessageGet(ca_msg->rxq, 20);
 8014eee:	4b24      	ldr	r3, [pc, #144]	; (8014f80 <USER_CanTask_entry+0x110>)
 8014ef0:	681b      	ldr	r3, [r3, #0]
 8014ef2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8014ef4:	f107 0208 	add.w	r2, r7, #8
 8014ef8:	4610      	mov	r0, r2
 8014efa:	4619      	mov	r1, r3
 8014efc:	2214      	movs	r2, #20
 8014efe:	f004 fe49 	bl	8019b94 <osMessageGet>
		if(event.status == osEventMessage)
 8014f02:	68bb      	ldr	r3, [r7, #8]
 8014f04:	2b10      	cmp	r3, #16
 8014f06:	d134      	bne.n	8014f72 <USER_CanTask_entry+0x102>
		{
			unsigned short i;

			rxmsg = event.value.p;
 8014f08:	68fb      	ldr	r3, [r7, #12]
 8014f0a:	61fb      	str	r3, [r7, #28]
			if(rxmsg == NULL)
 8014f0c:	69fb      	ldr	r3, [r7, #28]
 8014f0e:	2b00      	cmp	r3, #0
 8014f10:	d103      	bne.n	8014f1a <USER_CanTask_entry+0xaa>
			{
				rt_kprintf("val null\r\n");
 8014f12:	481c      	ldr	r0, [pc, #112]	; (8014f84 <USER_CanTask_entry+0x114>)
 8014f14:	f002 fcd2 	bl	80178bc <rt_kprintf>
 8014f18:	e02b      	b.n	8014f72 <USER_CanTask_entry+0x102>
			}
			else
			{
				rt_kprintf(" dp: %x\r\n", rxmsg->dp);
 8014f1a:	69fb      	ldr	r3, [r7, #28]
 8014f1c:	7a1b      	ldrb	r3, [r3, #8]
 8014f1e:	481a      	ldr	r0, [pc, #104]	; (8014f88 <USER_CanTask_entry+0x118>)
 8014f20:	4619      	mov	r1, r3
 8014f22:	f002 fccb 	bl	80178bc <rt_kprintf>
				rt_kprintf("pf: %x \r\n", rxmsg->PF);
 8014f26:	69fb      	ldr	r3, [r7, #28]
 8014f28:	79db      	ldrb	r3, [r3, #7]
 8014f2a:	4818      	ldr	r0, [pc, #96]	; (8014f8c <USER_CanTask_entry+0x11c>)
 8014f2c:	4619      	mov	r1, r3
 8014f2e:	f002 fcc5 	bl	80178bc <rt_kprintf>
				rt_kprintf("ps: %x \r\n", rxmsg->PS);
 8014f32:	69fb      	ldr	r3, [r7, #28]
 8014f34:	799b      	ldrb	r3, [r3, #6]
 8014f36:	4816      	ldr	r0, [pc, #88]	; (8014f90 <USER_CanTask_entry+0x120>)
 8014f38:	4619      	mov	r1, r3
 8014f3a:	f002 fcbf 	bl	80178bc <rt_kprintf>
				rt_kprintf("rcv data: ");
 8014f3e:	4815      	ldr	r0, [pc, #84]	; (8014f94 <USER_CanTask_entry+0x124>)
 8014f40:	f002 fcbc 	bl	80178bc <rt_kprintf>
				for(i = 0;i<rxmsg->size;i++)
 8014f44:	2300      	movs	r3, #0
 8014f46:	84fb      	strh	r3, [r7, #38]	; 0x26
 8014f48:	e00b      	b.n	8014f62 <USER_CanTask_entry+0xf2>
				{
					rt_kprintf("%x ", rxmsg->data[i]);
 8014f4a:	69fb      	ldr	r3, [r7, #28]
 8014f4c:	681a      	ldr	r2, [r3, #0]
 8014f4e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8014f50:	4413      	add	r3, r2
 8014f52:	781b      	ldrb	r3, [r3, #0]
 8014f54:	4810      	ldr	r0, [pc, #64]	; (8014f98 <USER_CanTask_entry+0x128>)
 8014f56:	4619      	mov	r1, r3
 8014f58:	f002 fcb0 	bl	80178bc <rt_kprintf>
			{
				rt_kprintf(" dp: %x\r\n", rxmsg->dp);
				rt_kprintf("pf: %x \r\n", rxmsg->PF);
				rt_kprintf("ps: %x \r\n", rxmsg->PS);
				rt_kprintf("rcv data: ");
				for(i = 0;i<rxmsg->size;i++)
 8014f5c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8014f5e:	3301      	adds	r3, #1
 8014f60:	84fb      	strh	r3, [r7, #38]	; 0x26
 8014f62:	69fb      	ldr	r3, [r7, #28]
 8014f64:	889b      	ldrh	r3, [r3, #4]
 8014f66:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8014f68:	429a      	cmp	r2, r3
 8014f6a:	d3ee      	bcc.n	8014f4a <USER_CanTask_entry+0xda>
				{
					rt_kprintf("%x ", rxmsg->data[i]);
				}
				rt_kprintf("\r\n");
 8014f6c:	480b      	ldr	r0, [pc, #44]	; (8014f9c <USER_CanTask_entry+0x12c>)
 8014f6e:	f002 fca5 	bl	80178bc <rt_kprintf>
			}
		}
		//rt_thread_delay(20);
	}
 8014f72:	e7bc      	b.n	8014eee <USER_CanTask_entry+0x7e>
 8014f74:	080271d0 	.word	0x080271d0
 8014f78:	08027174 	.word	0x08027174
 8014f7c:	0802717c 	.word	0x0802717c
 8014f80:	200129cc 	.word	0x200129cc
 8014f84:	0802718c 	.word	0x0802718c
 8014f88:	08027198 	.word	0x08027198
 8014f8c:	080271a4 	.word	0x080271a4
 8014f90:	080271b0 	.word	0x080271b0
 8014f94:	080271bc 	.word	0x080271bc
 8014f98:	080271c8 	.word	0x080271c8
 8014f9c:	080271cc 	.word	0x080271cc

08014fa0 <USER_CanTask_init>:
}


int USER_CanTask_init()
{
 8014fa0:	b580      	push	{r7, lr}
 8014fa2:	b084      	sub	sp, #16
 8014fa4:	af02      	add	r7, sp, #8
    rt_thread_t tid;
	
	tid = rt_thread_create("Can",						
 8014fa6:	2309      	movs	r3, #9
 8014fa8:	9300      	str	r3, [sp, #0]
 8014faa:	2314      	movs	r3, #20
 8014fac:	9301      	str	r3, [sp, #4]
 8014fae:	4809      	ldr	r0, [pc, #36]	; (8014fd4 <USER_CanTask_init+0x34>)
 8014fb0:	4909      	ldr	r1, [pc, #36]	; (8014fd8 <USER_CanTask_init+0x38>)
 8014fb2:	2200      	movs	r2, #0
 8014fb4:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8014fb8:	f003 fe54 	bl	8018c64 <rt_thread_create>
 8014fbc:	6078      	str	r0, [r7, #4]
                           USER_CanTask_entry, RT_NULL,
                           2048, USER_CANTASK_PRIORITY, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 8014fbe:	687b      	ldr	r3, [r7, #4]
 8014fc0:	2b00      	cmp	r3, #0
 8014fc2:	d002      	beq.n	8014fca <USER_CanTask_init+0x2a>
 8014fc4:	6878      	ldr	r0, [r7, #4]
 8014fc6:	f003 fe0f 	bl	8018be8 <rt_thread_startup>

    return 0;
 8014fca:	2300      	movs	r3, #0
}
 8014fcc:	4618      	mov	r0, r3
 8014fce:	3708      	adds	r7, #8
 8014fd0:	46bd      	mov	sp, r7
 8014fd2:	bd80      	pop	{r7, pc}
 8014fd4:	080271d8 	.word	0x080271d8
 8014fd8:	08014e71 	.word	0x08014e71

08014fdc <can_input>:
INIT_APP_EXPORT(USER_CanTask_init);

static rt_sem_t can_rx_sem;

static rt_err_t can_input(rt_device_t dev, rt_size_t size)
{
 8014fdc:	b580      	push	{r7, lr}
 8014fde:	b082      	sub	sp, #8
 8014fe0:	af00      	add	r7, sp, #0
 8014fe2:	6078      	str	r0, [r7, #4]
 8014fe4:	6039      	str	r1, [r7, #0]
	rt_sem_release(can_rx_sem);
 8014fe6:	4b05      	ldr	r3, [pc, #20]	; (8014ffc <can_input+0x20>)
 8014fe8:	681b      	ldr	r3, [r3, #0]
 8014fea:	4618      	mov	r0, r3
 8014fec:	f001 f9f6 	bl	80163dc <rt_sem_release>
	return RT_EOK;
 8014ff0:	2300      	movs	r3, #0
}
 8014ff2:	4618      	mov	r0, r3
 8014ff4:	3708      	adds	r7, #8
 8014ff6:	46bd      	mov	sp, r7
 8014ff8:	bd80      	pop	{r7, pc}
 8014ffa:	bf00      	nop
 8014ffc:	20010a1c 	.word	0x20010a1c

08015000 <J1939_RcvTask_entry>:


void J1939_RcvTask_entry(void *parameter)
{
 8015000:	b580      	push	{r7, lr}
 8015002:	b084      	sub	sp, #16
 8015004:	af00      	add	r7, sp, #0
 8015006:	6078      	str	r0, [r7, #4]
	rt_device_t device;
	rt_err_t result;
	device = rt_device_find("can1");
 8015008:	480c      	ldr	r0, [pc, #48]	; (801503c <J1939_RcvTask_entry+0x3c>)
 801500a:	f000 fdc9 	bl	8015ba0 <rt_device_find>
 801500e:	60f8      	str	r0, [r7, #12]
	
	if ( device != RT_NULL )
 8015010:	68fb      	ldr	r3, [r7, #12]
 8015012:	2b00      	cmp	r3, #0
 8015014:	d003      	beq.n	801501e <J1939_RcvTask_entry+0x1e>
	{
		rt_device_set_rx_indicate(device, can_input);
 8015016:	68f8      	ldr	r0, [r7, #12]
 8015018:	4909      	ldr	r1, [pc, #36]	; (8015040 <J1939_RcvTask_entry+0x40>)
 801501a:	f000 ff3d 	bl	8015e98 <rt_device_set_rx_indicate>
		#endif
	}

	while(1)
	{
		result = rt_sem_take(can_rx_sem, RT_WAITING_FOREVER);
 801501e:	4b09      	ldr	r3, [pc, #36]	; (8015044 <J1939_RcvTask_entry+0x44>)
 8015020:	681b      	ldr	r3, [r3, #0]
 8015022:	4618      	mov	r0, r3
 8015024:	f04f 31ff 	mov.w	r1, #4294967295
 8015028:	f001 f934 	bl	8016294 <rt_sem_take>
 801502c:	60b8      	str	r0, [r7, #8]
		if (result == RT_EOK)
 801502e:	68bb      	ldr	r3, [r7, #8]
 8015030:	2b00      	cmp	r3, #0
 8015032:	d101      	bne.n	8015038 <J1939_RcvTask_entry+0x38>
		{
			receiveMessage();
 8015034:	f7fc fa3a 	bl	80114ac <receiveMessage>
		}
	}
 8015038:	e7f1      	b.n	801501e <J1939_RcvTask_entry+0x1e>
 801503a:	bf00      	nop
 801503c:	08027174 	.word	0x08027174
 8015040:	08014fdd 	.word	0x08014fdd
 8015044:	20010a1c 	.word	0x20010a1c

08015048 <J1939_RcvTask_init>:
}

int J1939_RcvTask_init()
{
 8015048:	b580      	push	{r7, lr}
 801504a:	b084      	sub	sp, #16
 801504c:	af02      	add	r7, sp, #8
    rt_thread_t tid;

	
	if ((can_rx_sem = rt_sem_create("J1939rcv", 0, RT_IPC_FLAG_FIFO)) == RT_NULL)
 801504e:	4813      	ldr	r0, [pc, #76]	; (801509c <J1939_RcvTask_init+0x54>)
 8015050:	2100      	movs	r1, #0
 8015052:	2200      	movs	r2, #0
 8015054:	f001 f8e2 	bl	801621c <rt_sem_create>
 8015058:	4602      	mov	r2, r0
 801505a:	4b11      	ldr	r3, [pc, #68]	; (80150a0 <J1939_RcvTask_init+0x58>)
 801505c:	601a      	str	r2, [r3, #0]
 801505e:	4b10      	ldr	r3, [pc, #64]	; (80150a0 <J1939_RcvTask_init+0x58>)
 8015060:	681b      	ldr	r3, [r3, #0]
 8015062:	2b00      	cmp	r3, #0
 8015064:	d102      	bne.n	801506c <J1939_RcvTask_init+0x24>
	{
		rt_kprintf("can_rx_sem create error\r\n");
 8015066:	480f      	ldr	r0, [pc, #60]	; (80150a4 <J1939_RcvTask_init+0x5c>)
 8015068:	f002 fc28 	bl	80178bc <rt_kprintf>
	}
	
	tid = rt_thread_create("J1939Rcv",						
 801506c:	230a      	movs	r3, #10
 801506e:	9300      	str	r3, [sp, #0]
 8015070:	2314      	movs	r3, #20
 8015072:	9301      	str	r3, [sp, #4]
 8015074:	480c      	ldr	r0, [pc, #48]	; (80150a8 <J1939_RcvTask_init+0x60>)
 8015076:	490d      	ldr	r1, [pc, #52]	; (80150ac <J1939_RcvTask_init+0x64>)
 8015078:	2200      	movs	r2, #0
 801507a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 801507e:	f003 fdf1 	bl	8018c64 <rt_thread_create>
 8015082:	6078      	str	r0, [r7, #4]
                          J1939_RcvTask_entry, RT_NULL,
                           1024, J1939_RCVTASK_PRIORITY, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 8015084:	687b      	ldr	r3, [r7, #4]
 8015086:	2b00      	cmp	r3, #0
 8015088:	d002      	beq.n	8015090 <J1939_RcvTask_init+0x48>
 801508a:	6878      	ldr	r0, [r7, #4]
 801508c:	f003 fdac 	bl	8018be8 <rt_thread_startup>

    return 0;
 8015090:	2300      	movs	r3, #0
}
 8015092:	4618      	mov	r0, r3
 8015094:	3708      	adds	r7, #8
 8015096:	46bd      	mov	sp, r7
 8015098:	bd80      	pop	{r7, pc}
 801509a:	bf00      	nop
 801509c:	080271dc 	.word	0x080271dc
 80150a0:	20010a1c 	.word	0x20010a1c
 80150a4:	080271e8 	.word	0x080271e8
 80150a8:	08027204 	.word	0x08027204
 80150ac:	08015001 	.word	0x08015001

080150b0 <USER_MotorTask_entry>:
//	//rt_kprintf("a=%s\r\n", a);
//}
//MSH_CMD_EXPORT(Set,Set parameter);

void USER_MotorTask_entry(void *parameter)
{
 80150b0:	b580      	push	{r7, lr}
 80150b2:	b082      	sub	sp, #8
 80150b4:	af00      	add	r7, sp, #0
 80150b6:	6078      	str	r0, [r7, #4]
//	
//	 rt_thread_delay(SLEEPTIME(500));
//  }

	//! \Add By Dl.K
	Motor_Ctrl_Init();
 80150b8:	f7ed f98a 	bl	80023d0 <Motor_Ctrl_Init>
 	stm32_hw_tim8_init();
 80150bc:	f7ff f912 	bl	80142e4 <stm32_hw_tim8_init>
	stm32_hw_ADC_init();
 80150c0:	f7fe fbb8 	bl	8013834 <stm32_hw_ADC_init>
	stm32_hw_QEP_init();
 80150c4:	f7fe fce2 	bl	8013a8c <stm32_hw_QEP_init>
	//PWMOutputsEnable(TIM8);
	while(1)
	{
		if(Motor_Ctrl_State(a,&gFlag))
 80150c8:	480b      	ldr	r0, [pc, #44]	; (80150f8 <USER_MotorTask_entry+0x48>)
 80150ca:	490c      	ldr	r1, [pc, #48]	; (80150fc <USER_MotorTask_entry+0x4c>)
 80150cc:	f7ed f9ac 	bl	8002428 <Motor_Ctrl_State>
 80150d0:	4603      	mov	r3, r0
 80150d2:	2b00      	cmp	r3, #0
 80150d4:	d003      	beq.n	80150de <USER_MotorTask_entry+0x2e>
		{
			PWMOutputsEnable(TIM8);
 80150d6:	480a      	ldr	r0, [pc, #40]	; (8015100 <USER_MotorTask_entry+0x50>)
 80150d8:	f7ff f800 	bl	80140dc <PWMOutputsEnable>
 80150dc:	e002      	b.n	80150e4 <USER_MotorTask_entry+0x34>
		}
		else
		{
			PWMOutputsDisable(TIM8);
 80150de:	4808      	ldr	r0, [pc, #32]	; (8015100 <USER_MotorTask_entry+0x50>)
 80150e0:	f7ff f81a 	bl	8014118 <PWMOutputsDisable>
		}
		if(myscanf((char *)a) == RT_EOK)
 80150e4:	4804      	ldr	r0, [pc, #16]	; (80150f8 <USER_MotorTask_entry+0x48>)
 80150e6:	f000 fb99 	bl	801581c <myscanf>
 80150ea:	4603      	mov	r3, r0
 80150ec:	2b00      	cmp	r3, #0
 80150ee:	d102      	bne.n	80150f6 <USER_MotorTask_entry+0x46>
		{
			gFlag = 1;
 80150f0:	4b02      	ldr	r3, [pc, #8]	; (80150fc <USER_MotorTask_entry+0x4c>)
 80150f2:	2201      	movs	r2, #1
 80150f4:	701a      	strb	r2, [r3, #0]
		//rt_thread_delay(SLEEPTIME(20));
//		rt_kprintf("temp= 0x%x \r\n", Global_User_ADC.Temp.TEMP_value);
//		rt_kprintf("Ia= 0x%x \r\n", Global_User_ADC.PhaseA.qI_value);
//		rt_kprintf("Ib= 0x%x \r\n", Global_User_ADC.PhaseB.qI_value);
//		rt_kprintf("Ic= 0x%x \r\n", Global_User_ADC.PhaseC.qI_value);
	}
 80150f6:	e7e7      	b.n	80150c8 <USER_MotorTask_entry+0x18>
 80150f8:	20010a20 	.word	0x20010a20
 80150fc:	20010a30 	.word	0x20010a30
 8015100:	40010400 	.word	0x40010400

08015104 <USER_Motor_Mspinit>:
}


void USER_Motor_Mspinit(void)
{
 8015104:	b580      	push	{r7, lr}
 8015106:	b088      	sub	sp, #32
 8015108:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_Init;
    /* Enable GPIO clock */
	FAN_GPIOE_CLK_ENABLE();
 801510a:	4a30      	ldr	r2, [pc, #192]	; (80151cc <USER_Motor_Mspinit+0xc8>)
 801510c:	4b2f      	ldr	r3, [pc, #188]	; (80151cc <USER_Motor_Mspinit+0xc8>)
 801510e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015110:	f043 0310 	orr.w	r3, r3, #16
 8015114:	6313      	str	r3, [r2, #48]	; 0x30
 8015116:	4b2d      	ldr	r3, [pc, #180]	; (80151cc <USER_Motor_Mspinit+0xc8>)
 8015118:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801511a:	f003 0310 	and.w	r3, r3, #16
 801511e:	60bb      	str	r3, [r7, #8]
 8015120:	68bb      	ldr	r3, [r7, #8]

    /* GPIO pin configuration  */
 	GPIO_Init.Pin = FAN_PIN;
 8015122:	2340      	movs	r3, #64	; 0x40
 8015124:	60fb      	str	r3, [r7, #12]
	GPIO_Init.Mode = FAN_MODE;
 8015126:	2301      	movs	r3, #1
 8015128:	613b      	str	r3, [r7, #16]
	GPIO_Init.Pull = GPIO_PULLUP;
 801512a:	2301      	movs	r3, #1
 801512c:	617b      	str	r3, [r7, #20]
	GPIO_Init.Speed = GPIO_SPEED_LOW;
 801512e:	2300      	movs	r3, #0
 8015130:	61bb      	str	r3, [r7, #24]
	HAL_GPIO_Init(FAN_GPIO_PORT,&GPIO_Init);	
 8015132:	f107 030c 	add.w	r3, r7, #12
 8015136:	4826      	ldr	r0, [pc, #152]	; (80151d0 <USER_Motor_Mspinit+0xcc>)
 8015138:	4619      	mov	r1, r3
 801513a:	f7f8 f94f 	bl	800d3dc <HAL_GPIO_Init>
	
	HAL_GPIO_WritePin(FAN_GPIO_PORT,FAN_PIN, GPIO_PIN_SET);
 801513e:	4824      	ldr	r0, [pc, #144]	; (80151d0 <USER_Motor_Mspinit+0xcc>)
 8015140:	2140      	movs	r1, #64	; 0x40
 8015142:	2201      	movs	r2, #1
 8015144:	f7f8 fbfa 	bl	800d93c <HAL_GPIO_WritePin>

    /* Enable GPIO clock */
	TS0_GPIOE_CLK_ENABLE();
 8015148:	4a20      	ldr	r2, [pc, #128]	; (80151cc <USER_Motor_Mspinit+0xc8>)
 801514a:	4b20      	ldr	r3, [pc, #128]	; (80151cc <USER_Motor_Mspinit+0xc8>)
 801514c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801514e:	f043 0310 	orr.w	r3, r3, #16
 8015152:	6313      	str	r3, [r2, #48]	; 0x30
 8015154:	4b1d      	ldr	r3, [pc, #116]	; (80151cc <USER_Motor_Mspinit+0xc8>)
 8015156:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015158:	f003 0310 	and.w	r3, r3, #16
 801515c:	607b      	str	r3, [r7, #4]
 801515e:	687b      	ldr	r3, [r7, #4]
	TS1_GPIOE_CLK_ENABLE();
 8015160:	4a1a      	ldr	r2, [pc, #104]	; (80151cc <USER_Motor_Mspinit+0xc8>)
 8015162:	4b1a      	ldr	r3, [pc, #104]	; (80151cc <USER_Motor_Mspinit+0xc8>)
 8015164:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015166:	f043 0310 	orr.w	r3, r3, #16
 801516a:	6313      	str	r3, [r2, #48]	; 0x30
 801516c:	4b17      	ldr	r3, [pc, #92]	; (80151cc <USER_Motor_Mspinit+0xc8>)
 801516e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015170:	f003 0310 	and.w	r3, r3, #16
 8015174:	603b      	str	r3, [r7, #0]
 8015176:	683b      	ldr	r3, [r7, #0]
	
    /* GPIO pin configuration  */
 	GPIO_Init.Pin = TS0_PIN;
 8015178:	2308      	movs	r3, #8
 801517a:	60fb      	str	r3, [r7, #12]
	GPIO_Init.Mode = TS0_MODE;
 801517c:	2301      	movs	r3, #1
 801517e:	613b      	str	r3, [r7, #16]
	GPIO_Init.Pull = GPIO_PULLUP;
 8015180:	2301      	movs	r3, #1
 8015182:	617b      	str	r3, [r7, #20]
	GPIO_Init.Speed = GPIO_SPEED_LOW;
 8015184:	2300      	movs	r3, #0
 8015186:	61bb      	str	r3, [r7, #24]
	HAL_GPIO_Init(TS0_GPIO_PORT,&GPIO_Init);
 8015188:	f107 030c 	add.w	r3, r7, #12
 801518c:	4810      	ldr	r0, [pc, #64]	; (80151d0 <USER_Motor_Mspinit+0xcc>)
 801518e:	4619      	mov	r1, r3
 8015190:	f7f8 f924 	bl	800d3dc <HAL_GPIO_Init>
	HAL_GPIO_WritePin(TS0_GPIO_PORT,TS0_PIN, GPIO_PIN_SET);
 8015194:	480e      	ldr	r0, [pc, #56]	; (80151d0 <USER_Motor_Mspinit+0xcc>)
 8015196:	2108      	movs	r1, #8
 8015198:	2201      	movs	r2, #1
 801519a:	f7f8 fbcf 	bl	800d93c <HAL_GPIO_WritePin>
	
	/* GPIO pin configuration  */
 	GPIO_Init.Pin = TS1_PIN;
 801519e:	2320      	movs	r3, #32
 80151a0:	60fb      	str	r3, [r7, #12]
	GPIO_Init.Mode = TS1_MODE;
 80151a2:	2301      	movs	r3, #1
 80151a4:	613b      	str	r3, [r7, #16]
	GPIO_Init.Pull = GPIO_PULLUP;
 80151a6:	2301      	movs	r3, #1
 80151a8:	617b      	str	r3, [r7, #20]
	GPIO_Init.Speed = GPIO_SPEED_LOW;
 80151aa:	2300      	movs	r3, #0
 80151ac:	61bb      	str	r3, [r7, #24]
	HAL_GPIO_Init(TS1_GPIO_PORT,&GPIO_Init);
 80151ae:	f107 030c 	add.w	r3, r7, #12
 80151b2:	4807      	ldr	r0, [pc, #28]	; (80151d0 <USER_Motor_Mspinit+0xcc>)
 80151b4:	4619      	mov	r1, r3
 80151b6:	f7f8 f911 	bl	800d3dc <HAL_GPIO_Init>
	HAL_GPIO_WritePin(TS1_GPIO_PORT,TS1_PIN, GPIO_PIN_SET);
 80151ba:	4805      	ldr	r0, [pc, #20]	; (80151d0 <USER_Motor_Mspinit+0xcc>)
 80151bc:	2120      	movs	r1, #32
 80151be:	2201      	movs	r2, #1
 80151c0:	f7f8 fbbc 	bl	800d93c <HAL_GPIO_WritePin>
}
 80151c4:	3720      	adds	r7, #32
 80151c6:	46bd      	mov	sp, r7
 80151c8:	bd80      	pop	{r7, pc}
 80151ca:	bf00      	nop
 80151cc:	40023800 	.word	0x40023800
 80151d0:	40021000 	.word	0x40021000

080151d4 <USER_Motor_hwinit>:

int USER_Motor_hwinit(void)
{
 80151d4:	b580      	push	{r7, lr}
 80151d6:	af00      	add	r7, sp, #0
USER_Motor_Mspinit();
 80151d8:	f7ff ff94 	bl	8015104 <USER_Motor_Mspinit>
return 0;
 80151dc:	2300      	movs	r3, #0
}
 80151de:	4618      	mov	r0, r3
 80151e0:	bd80      	pop	{r7, pc}
 80151e2:	bf00      	nop

080151e4 <TempSeltest>:

INIT_BOARD_EXPORT(USER_Motor_hwinit);


void TempSeltest(int argc,char **argv)
{
 80151e4:	b580      	push	{r7, lr}
 80151e6:	b082      	sub	sp, #8
 80151e8:	af00      	add	r7, sp, #0
 80151ea:	6078      	str	r0, [r7, #4]
 80151ec:	6039      	str	r1, [r7, #0]
	if(strcmp(argv[1],"0")==0){
 80151ee:	683b      	ldr	r3, [r7, #0]
 80151f0:	3304      	adds	r3, #4
 80151f2:	681b      	ldr	r3, [r3, #0]
 80151f4:	4618      	mov	r0, r3
 80151f6:	492b      	ldr	r1, [pc, #172]	; (80152a4 <TempSeltest+0xc0>)
 80151f8:	f7eb f916 	bl	8000428 <strcmp>
 80151fc:	4603      	mov	r3, r0
 80151fe:	2b00      	cmp	r3, #0
 8015200:	d10a      	bne.n	8015218 <TempSeltest+0x34>
		HAL_GPIO_WritePin(TS0_GPIO_PORT,TS0_PIN,GPIO_PIN_RESET);
 8015202:	4829      	ldr	r0, [pc, #164]	; (80152a8 <TempSeltest+0xc4>)
 8015204:	2108      	movs	r1, #8
 8015206:	2200      	movs	r2, #0
 8015208:	f7f8 fb98 	bl	800d93c <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(TS1_GPIO_PORT,TS1_PIN,GPIO_PIN_RESET);
 801520c:	4826      	ldr	r0, [pc, #152]	; (80152a8 <TempSeltest+0xc4>)
 801520e:	2120      	movs	r1, #32
 8015210:	2200      	movs	r2, #0
 8015212:	f7f8 fb93 	bl	800d93c <HAL_GPIO_WritePin>
 8015216:	e041      	b.n	801529c <TempSeltest+0xb8>
	}else if (strcmp(argv[1],"1")==0){
 8015218:	683b      	ldr	r3, [r7, #0]
 801521a:	3304      	adds	r3, #4
 801521c:	681b      	ldr	r3, [r3, #0]
 801521e:	4618      	mov	r0, r3
 8015220:	4922      	ldr	r1, [pc, #136]	; (80152ac <TempSeltest+0xc8>)
 8015222:	f7eb f901 	bl	8000428 <strcmp>
 8015226:	4603      	mov	r3, r0
 8015228:	2b00      	cmp	r3, #0
 801522a:	d10a      	bne.n	8015242 <TempSeltest+0x5e>
		HAL_GPIO_WritePin(TS0_GPIO_PORT,TS0_PIN,GPIO_PIN_SET);
 801522c:	481e      	ldr	r0, [pc, #120]	; (80152a8 <TempSeltest+0xc4>)
 801522e:	2108      	movs	r1, #8
 8015230:	2201      	movs	r2, #1
 8015232:	f7f8 fb83 	bl	800d93c <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(TS1_GPIO_PORT,TS1_PIN,GPIO_PIN_RESET);
 8015236:	481c      	ldr	r0, [pc, #112]	; (80152a8 <TempSeltest+0xc4>)
 8015238:	2120      	movs	r1, #32
 801523a:	2200      	movs	r2, #0
 801523c:	f7f8 fb7e 	bl	800d93c <HAL_GPIO_WritePin>
 8015240:	e02c      	b.n	801529c <TempSeltest+0xb8>
	}else if(strcmp(argv[1],"2")==0) {
 8015242:	683b      	ldr	r3, [r7, #0]
 8015244:	3304      	adds	r3, #4
 8015246:	681b      	ldr	r3, [r3, #0]
 8015248:	4618      	mov	r0, r3
 801524a:	4919      	ldr	r1, [pc, #100]	; (80152b0 <TempSeltest+0xcc>)
 801524c:	f7eb f8ec 	bl	8000428 <strcmp>
 8015250:	4603      	mov	r3, r0
 8015252:	2b00      	cmp	r3, #0
 8015254:	d10a      	bne.n	801526c <TempSeltest+0x88>
		HAL_GPIO_WritePin(TS0_GPIO_PORT,TS0_PIN,GPIO_PIN_RESET);
 8015256:	4814      	ldr	r0, [pc, #80]	; (80152a8 <TempSeltest+0xc4>)
 8015258:	2108      	movs	r1, #8
 801525a:	2200      	movs	r2, #0
 801525c:	f7f8 fb6e 	bl	800d93c <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(TS1_GPIO_PORT,TS1_PIN,GPIO_PIN_SET);
 8015260:	4811      	ldr	r0, [pc, #68]	; (80152a8 <TempSeltest+0xc4>)
 8015262:	2120      	movs	r1, #32
 8015264:	2201      	movs	r2, #1
 8015266:	f7f8 fb69 	bl	800d93c <HAL_GPIO_WritePin>
 801526a:	e017      	b.n	801529c <TempSeltest+0xb8>
	}else if(strcmp(argv[1],"3")==0) {
 801526c:	683b      	ldr	r3, [r7, #0]
 801526e:	3304      	adds	r3, #4
 8015270:	681b      	ldr	r3, [r3, #0]
 8015272:	4618      	mov	r0, r3
 8015274:	490f      	ldr	r1, [pc, #60]	; (80152b4 <TempSeltest+0xd0>)
 8015276:	f7eb f8d7 	bl	8000428 <strcmp>
 801527a:	4603      	mov	r3, r0
 801527c:	2b00      	cmp	r3, #0
 801527e:	d10a      	bne.n	8015296 <TempSeltest+0xb2>
		HAL_GPIO_WritePin(TS0_GPIO_PORT,TS0_PIN,GPIO_PIN_SET);
 8015280:	4809      	ldr	r0, [pc, #36]	; (80152a8 <TempSeltest+0xc4>)
 8015282:	2108      	movs	r1, #8
 8015284:	2201      	movs	r2, #1
 8015286:	f7f8 fb59 	bl	800d93c <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(TS1_GPIO_PORT,TS1_PIN,GPIO_PIN_SET);
 801528a:	4807      	ldr	r0, [pc, #28]	; (80152a8 <TempSeltest+0xc4>)
 801528c:	2120      	movs	r1, #32
 801528e:	2201      	movs	r2, #1
 8015290:	f7f8 fb54 	bl	800d93c <HAL_GPIO_WritePin>
 8015294:	e002      	b.n	801529c <TempSeltest+0xb8>
	}else{
		rt_kprintf("unknown parameter\r\n");
 8015296:	4808      	ldr	r0, [pc, #32]	; (80152b8 <TempSeltest+0xd4>)
 8015298:	f002 fb10 	bl	80178bc <rt_kprintf>
	}
}
 801529c:	3708      	adds	r7, #8
 801529e:	46bd      	mov	sp, r7
 80152a0:	bd80      	pop	{r7, pc}
 80152a2:	bf00      	nop
 80152a4:	08027210 	.word	0x08027210
 80152a8:	40021000 	.word	0x40021000
 80152ac:	08027214 	.word	0x08027214
 80152b0:	08027218 	.word	0x08027218
 80152b4:	0802721c 	.word	0x0802721c
 80152b8:	08027220 	.word	0x08027220

080152bc <FANtest>:
MSH_CMD_EXPORT_ALIAS(TempSeltest,TS,TS 0 or TS 1 or TS 2 or TS 3);


void FANtest(int argc,char**argv)
{
 80152bc:	b580      	push	{r7, lr}
 80152be:	b082      	sub	sp, #8
 80152c0:	af00      	add	r7, sp, #0
 80152c2:	6078      	str	r0, [r7, #4]
 80152c4:	6039      	str	r1, [r7, #0]
	if (strcmp(argv[1], "on") == 0)
 80152c6:	683b      	ldr	r3, [r7, #0]
 80152c8:	3304      	adds	r3, #4
 80152ca:	681b      	ldr	r3, [r3, #0]
 80152cc:	4618      	mov	r0, r3
 80152ce:	4911      	ldr	r1, [pc, #68]	; (8015314 <FANtest+0x58>)
 80152d0:	f7eb f8aa 	bl	8000428 <strcmp>
 80152d4:	4603      	mov	r3, r0
 80152d6:	2b00      	cmp	r3, #0
 80152d8:	d105      	bne.n	80152e6 <FANtest+0x2a>
		HAL_GPIO_WritePin(FAN_GPIO_PORT,FAN_PIN, GPIO_PIN_RESET);
 80152da:	480f      	ldr	r0, [pc, #60]	; (8015318 <FANtest+0x5c>)
 80152dc:	2140      	movs	r1, #64	; 0x40
 80152de:	2200      	movs	r2, #0
 80152e0:	f7f8 fb2c 	bl	800d93c <HAL_GPIO_WritePin>
 80152e4:	e012      	b.n	801530c <FANtest+0x50>
	else if(strcmp(argv[1], "off") == 0)
 80152e6:	683b      	ldr	r3, [r7, #0]
 80152e8:	3304      	adds	r3, #4
 80152ea:	681b      	ldr	r3, [r3, #0]
 80152ec:	4618      	mov	r0, r3
 80152ee:	490b      	ldr	r1, [pc, #44]	; (801531c <FANtest+0x60>)
 80152f0:	f7eb f89a 	bl	8000428 <strcmp>
 80152f4:	4603      	mov	r3, r0
 80152f6:	2b00      	cmp	r3, #0
 80152f8:	d105      	bne.n	8015306 <FANtest+0x4a>
		HAL_GPIO_WritePin(FAN_GPIO_PORT,FAN_PIN, GPIO_PIN_SET);
 80152fa:	4807      	ldr	r0, [pc, #28]	; (8015318 <FANtest+0x5c>)
 80152fc:	2140      	movs	r1, #64	; 0x40
 80152fe:	2201      	movs	r2, #1
 8015300:	f7f8 fb1c 	bl	800d93c <HAL_GPIO_WritePin>
 8015304:	e002      	b.n	801530c <FANtest+0x50>
	else
		rt_kprintf("unknown parameter\r\n");
 8015306:	4806      	ldr	r0, [pc, #24]	; (8015320 <FANtest+0x64>)
 8015308:	f002 fad8 	bl	80178bc <rt_kprintf>
}
 801530c:	3708      	adds	r7, #8
 801530e:	46bd      	mov	sp, r7
 8015310:	bd80      	pop	{r7, pc}
 8015312:	bf00      	nop
 8015314:	08027234 	.word	0x08027234
 8015318:	40021000 	.word	0x40021000
 801531c:	08027238 	.word	0x08027238
 8015320:	08027220 	.word	0x08027220

08015324 <ADCtest>:
MSH_CMD_EXPORT(FANtest,FANtest on or FANtest off);

void ADCtest(int argc,char**argv)
{
 8015324:	b580      	push	{r7, lr}
 8015326:	b082      	sub	sp, #8
 8015328:	af00      	add	r7, sp, #0
 801532a:	6078      	str	r0, [r7, #4]
 801532c:	6039      	str	r1, [r7, #0]
	rt_kprintf("temp= 0x%x \r\n", Global_User_ADC.Temp.TEMP_value);
 801532e:	4b50      	ldr	r3, [pc, #320]	; (8015470 <ADCtest+0x14c>)
 8015330:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 8015334:	b21b      	sxth	r3, r3
 8015336:	484f      	ldr	r0, [pc, #316]	; (8015474 <ADCtest+0x150>)
 8015338:	4619      	mov	r1, r3
 801533a:	f002 fabf 	bl	80178bc <rt_kprintf>
	rt_kprintf("BUS V= 0x%x \r\n", Global_User_ADC.BUS.qV_value);
 801533e:	4b4c      	ldr	r3, [pc, #304]	; (8015470 <ADCtest+0x14c>)
 8015340:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 8015342:	b21b      	sxth	r3, r3
 8015344:	484c      	ldr	r0, [pc, #304]	; (8015478 <ADCtest+0x154>)
 8015346:	4619      	mov	r1, r3
 8015348:	f002 fab8 	bl	80178bc <rt_kprintf>
	rt_kprintf("BUS I= 0x%x \r\n", Global_User_ADC.BUS.qI_value);
 801534c:	4b48      	ldr	r3, [pc, #288]	; (8015470 <ADCtest+0x14c>)
 801534e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8015350:	b21b      	sxth	r3, r3
 8015352:	484a      	ldr	r0, [pc, #296]	; (801547c <ADCtest+0x158>)
 8015354:	4619      	mov	r1, r3
 8015356:	f002 fab1 	bl	80178bc <rt_kprintf>
	rt_kprintf("VOLTAGE C= 0x%x \r\n", Global_User_ADC.PhaseC.qV_value);
 801535a:	4b45      	ldr	r3, [pc, #276]	; (8015470 <ADCtest+0x14c>)
 801535c:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 801535e:	b21b      	sxth	r3, r3
 8015360:	4847      	ldr	r0, [pc, #284]	; (8015480 <ADCtest+0x15c>)
 8015362:	4619      	mov	r1, r3
 8015364:	f002 faaa 	bl	80178bc <rt_kprintf>
	rt_kprintf("VOLTAGE B= 0x%x \r\n", Global_User_ADC.PhaseB.qV_value);
 8015368:	4b41      	ldr	r3, [pc, #260]	; (8015470 <ADCtest+0x14c>)
 801536a:	8b1b      	ldrh	r3, [r3, #24]
 801536c:	b21b      	sxth	r3, r3
 801536e:	4845      	ldr	r0, [pc, #276]	; (8015484 <ADCtest+0x160>)
 8015370:	4619      	mov	r1, r3
 8015372:	f002 faa3 	bl	80178bc <rt_kprintf>
	rt_kprintf("VOLTAGE A= 0x%x \r\n", Global_User_ADC.PhaseA.qV_value);
 8015376:	4b3e      	ldr	r3, [pc, #248]	; (8015470 <ADCtest+0x14c>)
 8015378:	895b      	ldrh	r3, [r3, #10]
 801537a:	b21b      	sxth	r3, r3
 801537c:	4842      	ldr	r0, [pc, #264]	; (8015488 <ADCtest+0x164>)
 801537e:	4619      	mov	r1, r3
 8015380:	f002 fa9c 	bl	80178bc <rt_kprintf>
	rt_kprintf("current C2= 0x%x \r\n", Global_User_ADC.PhaseC.qI2_value);
 8015384:	4b3a      	ldr	r3, [pc, #232]	; (8015470 <ADCtest+0x14c>)
 8015386:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 8015388:	b21b      	sxth	r3, r3
 801538a:	4840      	ldr	r0, [pc, #256]	; (801548c <ADCtest+0x168>)
 801538c:	4619      	mov	r1, r3
 801538e:	f002 fa95 	bl	80178bc <rt_kprintf>
	rt_kprintf("current C1= 0x%x \r\n", Global_User_ADC.PhaseC.qI1_value);
 8015392:	4b37      	ldr	r3, [pc, #220]	; (8015470 <ADCtest+0x14c>)
 8015394:	8b9b      	ldrh	r3, [r3, #28]
 8015396:	b21b      	sxth	r3, r3
 8015398:	483d      	ldr	r0, [pc, #244]	; (8015490 <ADCtest+0x16c>)
 801539a:	4619      	mov	r1, r3
 801539c:	f002 fa8e 	bl	80178bc <rt_kprintf>
	rt_kprintf("current B2= 0x%x \r\n", Global_User_ADC.PhaseB.qI2_value);
 80153a0:	4b33      	ldr	r3, [pc, #204]	; (8015470 <ADCtest+0x14c>)
 80153a2:	8a9b      	ldrh	r3, [r3, #20]
 80153a4:	b21b      	sxth	r3, r3
 80153a6:	483b      	ldr	r0, [pc, #236]	; (8015494 <ADCtest+0x170>)
 80153a8:	4619      	mov	r1, r3
 80153aa:	f002 fa87 	bl	80178bc <rt_kprintf>
	rt_kprintf("current B1= 0x%x \r\n", Global_User_ADC.PhaseB.qI1_value);
 80153ae:	4b30      	ldr	r3, [pc, #192]	; (8015470 <ADCtest+0x14c>)
 80153b0:	89db      	ldrh	r3, [r3, #14]
 80153b2:	b21b      	sxth	r3, r3
 80153b4:	4838      	ldr	r0, [pc, #224]	; (8015498 <ADCtest+0x174>)
 80153b6:	4619      	mov	r1, r3
 80153b8:	f002 fa80 	bl	80178bc <rt_kprintf>
	rt_kprintf("current A2= 0x%x \r\n", Global_User_ADC.PhaseA.qI2_value);
 80153bc:	4b2c      	ldr	r3, [pc, #176]	; (8015470 <ADCtest+0x14c>)
 80153be:	88db      	ldrh	r3, [r3, #6]
 80153c0:	b21b      	sxth	r3, r3
 80153c2:	4836      	ldr	r0, [pc, #216]	; (801549c <ADCtest+0x178>)
 80153c4:	4619      	mov	r1, r3
 80153c6:	f002 fa79 	bl	80178bc <rt_kprintf>
	rt_kprintf("current A1= 0x%x \r\n", Global_User_ADC.PhaseA.qI1_value);
 80153ca:	4b29      	ldr	r3, [pc, #164]	; (8015470 <ADCtest+0x14c>)
 80153cc:	881b      	ldrh	r3, [r3, #0]
 80153ce:	b21b      	sxth	r3, r3
 80153d0:	4833      	ldr	r0, [pc, #204]	; (80154a0 <ADCtest+0x17c>)
 80153d2:	4619      	mov	r1, r3
 80153d4:	f002 fa72 	bl	80178bc <rt_kprintf>

	
	rt_kprintf("temp offset= 0x%x \r\n", Global_User_ADC.Temp.TEMP_offset);
 80153d8:	4b25      	ldr	r3, [pc, #148]	; (8015470 <ADCtest+0x14c>)
 80153da:	f8b3 305e 	ldrh.w	r3, [r3, #94]	; 0x5e
 80153de:	4831      	ldr	r0, [pc, #196]	; (80154a4 <ADCtest+0x180>)
 80153e0:	4619      	mov	r1, r3
 80153e2:	f002 fa6b 	bl	80178bc <rt_kprintf>
	rt_kprintf("BUS V  offset= 0x%x \r\n", Global_User_ADC.BUS.qV_offset);
 80153e6:	4b22      	ldr	r3, [pc, #136]	; (8015470 <ADCtest+0x14c>)
 80153e8:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 80153ea:	482f      	ldr	r0, [pc, #188]	; (80154a8 <ADCtest+0x184>)
 80153ec:	4619      	mov	r1, r3
 80153ee:	f002 fa65 	bl	80178bc <rt_kprintf>
	rt_kprintf("BUS I offset= 0x%x \r\n", Global_User_ADC.BUS.qI_offset);
 80153f2:	4b1f      	ldr	r3, [pc, #124]	; (8015470 <ADCtest+0x14c>)
 80153f4:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 80153f6:	482d      	ldr	r0, [pc, #180]	; (80154ac <ADCtest+0x188>)
 80153f8:	4619      	mov	r1, r3
 80153fa:	f002 fa5f 	bl	80178bc <rt_kprintf>
	rt_kprintf("VOLTAGE C offset= 0x%x \r\n", Global_User_ADC.PhaseC.qV_offset);
 80153fe:	4b1c      	ldr	r3, [pc, #112]	; (8015470 <ADCtest+0x14c>)
 8015400:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8015402:	482b      	ldr	r0, [pc, #172]	; (80154b0 <ADCtest+0x18c>)
 8015404:	4619      	mov	r1, r3
 8015406:	f002 fa59 	bl	80178bc <rt_kprintf>
	rt_kprintf("VOLTAGE B offset= 0x%x \r\n", Global_User_ADC.PhaseB.qV_offset);
 801540a:	4b19      	ldr	r3, [pc, #100]	; (8015470 <ADCtest+0x14c>)
 801540c:	8b5b      	ldrh	r3, [r3, #26]
 801540e:	4829      	ldr	r0, [pc, #164]	; (80154b4 <ADCtest+0x190>)
 8015410:	4619      	mov	r1, r3
 8015412:	f002 fa53 	bl	80178bc <rt_kprintf>
	rt_kprintf("VOLTAGE A offset= 0x%x \r\n", Global_User_ADC.PhaseA.qV_offset);
 8015416:	4b16      	ldr	r3, [pc, #88]	; (8015470 <ADCtest+0x14c>)
 8015418:	899b      	ldrh	r3, [r3, #12]
 801541a:	4827      	ldr	r0, [pc, #156]	; (80154b8 <ADCtest+0x194>)
 801541c:	4619      	mov	r1, r3
 801541e:	f002 fa4d 	bl	80178bc <rt_kprintf>
	rt_kprintf("current C2 offset= 0x%x \r\n", Global_User_ADC.PhaseC.qI2_offset);
 8015422:	4b13      	ldr	r3, [pc, #76]	; (8015470 <ADCtest+0x14c>)
 8015424:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8015426:	4825      	ldr	r0, [pc, #148]	; (80154bc <ADCtest+0x198>)
 8015428:	4619      	mov	r1, r3
 801542a:	f002 fa47 	bl	80178bc <rt_kprintf>
	rt_kprintf("current C1 offset= 0x%x \r\n", Global_User_ADC.PhaseC.qI1_offset);
 801542e:	4b10      	ldr	r3, [pc, #64]	; (8015470 <ADCtest+0x14c>)
 8015430:	8c1b      	ldrh	r3, [r3, #32]
 8015432:	4823      	ldr	r0, [pc, #140]	; (80154c0 <ADCtest+0x19c>)
 8015434:	4619      	mov	r1, r3
 8015436:	f002 fa41 	bl	80178bc <rt_kprintf>
	rt_kprintf("current B2 offset= 0x%x \r\n", Global_User_ADC.PhaseB.qI2_offset);
 801543a:	4b0d      	ldr	r3, [pc, #52]	; (8015470 <ADCtest+0x14c>)
 801543c:	8adb      	ldrh	r3, [r3, #22]
 801543e:	4821      	ldr	r0, [pc, #132]	; (80154c4 <ADCtest+0x1a0>)
 8015440:	4619      	mov	r1, r3
 8015442:	f002 fa3b 	bl	80178bc <rt_kprintf>
	rt_kprintf("current B1 offset= 0x%x \r\n", Global_User_ADC.PhaseB.qI1_offset);
 8015446:	4b0a      	ldr	r3, [pc, #40]	; (8015470 <ADCtest+0x14c>)
 8015448:	8a5b      	ldrh	r3, [r3, #18]
 801544a:	481f      	ldr	r0, [pc, #124]	; (80154c8 <ADCtest+0x1a4>)
 801544c:	4619      	mov	r1, r3
 801544e:	f002 fa35 	bl	80178bc <rt_kprintf>
	rt_kprintf("current A2 offset= 0x%x \r\n", Global_User_ADC.PhaseA.qI2_offset);
 8015452:	4b07      	ldr	r3, [pc, #28]	; (8015470 <ADCtest+0x14c>)
 8015454:	891b      	ldrh	r3, [r3, #8]
 8015456:	481d      	ldr	r0, [pc, #116]	; (80154cc <ADCtest+0x1a8>)
 8015458:	4619      	mov	r1, r3
 801545a:	f002 fa2f 	bl	80178bc <rt_kprintf>
	rt_kprintf("current A1 offset= 0x%x \r\n", Global_User_ADC.PhaseA.qI1_offset);
 801545e:	4b04      	ldr	r3, [pc, #16]	; (8015470 <ADCtest+0x14c>)
 8015460:	889b      	ldrh	r3, [r3, #4]
 8015462:	481b      	ldr	r0, [pc, #108]	; (80154d0 <ADCtest+0x1ac>)
 8015464:	4619      	mov	r1, r3
 8015466:	f002 fa29 	bl	80178bc <rt_kprintf>
}
 801546a:	3708      	adds	r7, #8
 801546c:	46bd      	mov	sp, r7
 801546e:	bd80      	pop	{r7, pc}
 8015470:	200128c0 	.word	0x200128c0
 8015474:	0802723c 	.word	0x0802723c
 8015478:	0802724c 	.word	0x0802724c
 801547c:	0802725c 	.word	0x0802725c
 8015480:	0802726c 	.word	0x0802726c
 8015484:	08027280 	.word	0x08027280
 8015488:	08027294 	.word	0x08027294
 801548c:	080272a8 	.word	0x080272a8
 8015490:	080272bc 	.word	0x080272bc
 8015494:	080272d0 	.word	0x080272d0
 8015498:	080272e4 	.word	0x080272e4
 801549c:	080272f8 	.word	0x080272f8
 80154a0:	0802730c 	.word	0x0802730c
 80154a4:	08027320 	.word	0x08027320
 80154a8:	08027338 	.word	0x08027338
 80154ac:	08027350 	.word	0x08027350
 80154b0:	08027368 	.word	0x08027368
 80154b4:	08027384 	.word	0x08027384
 80154b8:	080273a0 	.word	0x080273a0
 80154bc:	080273bc 	.word	0x080273bc
 80154c0:	080273d8 	.word	0x080273d8
 80154c4:	080273f4 	.word	0x080273f4
 80154c8:	08027410 	.word	0x08027410
 80154cc:	0802742c 	.word	0x0802742c
 80154d0:	08027448 	.word	0x08027448

080154d4 <MCctrl>:
MSH_CMD_EXPORT(ADCtest,ADCtest print ADCValue);


void MCctrl(int argc,char**argv)
{
 80154d4:	b580      	push	{r7, lr}
 80154d6:	b082      	sub	sp, #8
 80154d8:	af00      	add	r7, sp, #0
 80154da:	6078      	str	r0, [r7, #4]
 80154dc:	6039      	str	r1, [r7, #0]
	if (strcmp(argv[1], "on") == 0)
 80154de:	683b      	ldr	r3, [r7, #0]
 80154e0:	3304      	adds	r3, #4
 80154e2:	681b      	ldr	r3, [r3, #0]
 80154e4:	4618      	mov	r0, r3
 80154e6:	4910      	ldr	r1, [pc, #64]	; (8015528 <MCctrl+0x54>)
 80154e8:	f7ea ff9e 	bl	8000428 <strcmp>
 80154ec:	4603      	mov	r3, r0
 80154ee:	2b00      	cmp	r3, #0
 80154f0:	d106      	bne.n	8015500 <MCctrl+0x2c>
	{
//		State = INIT;
		PWMOutputsEnable(TIM8);
 80154f2:	480e      	ldr	r0, [pc, #56]	; (801552c <MCctrl+0x58>)
 80154f4:	f7fe fdf2 	bl	80140dc <PWMOutputsEnable>

		rt_kprintf("Motor is started\r\n");
 80154f8:	480d      	ldr	r0, [pc, #52]	; (8015530 <MCctrl+0x5c>)
 80154fa:	f002 f9df 	bl	80178bc <rt_kprintf>
 80154fe:	e00f      	b.n	8015520 <MCctrl+0x4c>
	}
	else if(strcmp(argv[1], "off") == 0)
 8015500:	683b      	ldr	r3, [r7, #0]
 8015502:	3304      	adds	r3, #4
 8015504:	681b      	ldr	r3, [r3, #0]
 8015506:	4618      	mov	r0, r3
 8015508:	490a      	ldr	r1, [pc, #40]	; (8015534 <MCctrl+0x60>)
 801550a:	f7ea ff8d 	bl	8000428 <strcmp>
 801550e:	4603      	mov	r3, r0
 8015510:	2b00      	cmp	r3, #0
 8015512:	d105      	bne.n	8015520 <MCctrl+0x4c>
	{
//		State = STOP;
		PWMOutputsDisable(TIM8);
 8015514:	4805      	ldr	r0, [pc, #20]	; (801552c <MCctrl+0x58>)
 8015516:	f7fe fdff 	bl	8014118 <PWMOutputsDisable>
		rt_kprintf("Motor is stopped\r\n");
 801551a:	4807      	ldr	r0, [pc, #28]	; (8015538 <MCctrl+0x64>)
 801551c:	f002 f9ce 	bl	80178bc <rt_kprintf>
	}
}
 8015520:	3708      	adds	r7, #8
 8015522:	46bd      	mov	sp, r7
 8015524:	bd80      	pop	{r7, pc}
 8015526:	bf00      	nop
 8015528:	08027234 	.word	0x08027234
 801552c:	40010400 	.word	0x40010400
 8015530:	08027464 	.word	0x08027464
 8015534:	08027238 	.word	0x08027238
 8015538:	08027478 	.word	0x08027478

0801553c <QEPtest>:
MSH_CMD_EXPORT(MCctrl,MCctrl on or MCctrl off);

#ifdef ENCODER
void QEPtest(int argc,char**argv)
{
 801553c:	b580      	push	{r7, lr}
 801553e:	b082      	sub	sp, #8
 8015540:	af00      	add	r7, sp, #0
 8015542:	6078      	str	r0, [r7, #4]
 8015544:	6039      	str	r1, [r7, #0]
	rt_kprintf("TIM5 CNT =%x\r\n",GetCounterValue(TIM5) );
 8015546:	4805      	ldr	r0, [pc, #20]	; (801555c <QEPtest+0x20>)
 8015548:	f7fe fa2a 	bl	80139a0 <GetCounterValue>
 801554c:	4603      	mov	r3, r0
 801554e:	4804      	ldr	r0, [pc, #16]	; (8015560 <QEPtest+0x24>)
 8015550:	4619      	mov	r1, r3
 8015552:	f002 f9b3 	bl	80178bc <rt_kprintf>
}
 8015556:	3708      	adds	r7, #8
 8015558:	46bd      	mov	sp, r7
 801555a:	bd80      	pop	{r7, pc}
 801555c:	40000c00 	.word	0x40000c00
 8015560:	0802748c 	.word	0x0802748c

08015564 <USER_MotorTask_init>:
MSH_CMD_EXPORT(QEPtest,QEPtest);
#endif

int USER_MotorTask_init()
{
 8015564:	b580      	push	{r7, lr}
 8015566:	b084      	sub	sp, #16
 8015568:	af02      	add	r7, sp, #8
    rt_thread_t tid;
	
	tid = rt_thread_create("Motor",
 801556a:	230a      	movs	r3, #10
 801556c:	9300      	str	r3, [sp, #0]
 801556e:	2314      	movs	r3, #20
 8015570:	9301      	str	r3, [sp, #4]
 8015572:	4809      	ldr	r0, [pc, #36]	; (8015598 <USER_MotorTask_init+0x34>)
 8015574:	4909      	ldr	r1, [pc, #36]	; (801559c <USER_MotorTask_init+0x38>)
 8015576:	2200      	movs	r2, #0
 8015578:	f44f 6380 	mov.w	r3, #1024	; 0x400
 801557c:	f003 fb72 	bl	8018c64 <rt_thread_create>
 8015580:	6078      	str	r0, [r7, #4]
                           USER_MotorTask_entry, RT_NULL,
                           1024, USER_MOTORTASK_PRIORITY, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 8015582:	687b      	ldr	r3, [r7, #4]
 8015584:	2b00      	cmp	r3, #0
 8015586:	d002      	beq.n	801558e <USER_MotorTask_init+0x2a>
 8015588:	6878      	ldr	r0, [r7, #4]
 801558a:	f003 fb2d 	bl	8018be8 <rt_thread_startup>

    return 0;
 801558e:	2300      	movs	r3, #0
}
 8015590:	4618      	mov	r0, r3
 8015592:	3708      	adds	r7, #8
 8015594:	46bd      	mov	sp, r7
 8015596:	bd80      	pop	{r7, pc}
 8015598:	0802749c 	.word	0x0802749c
 801559c:	080150b1 	.word	0x080150b1

080155a0 <rt_init_thread_entry>:

#include <rtthread.h>
#include <components.h>

void rt_init_thread_entry(void *parameter)
{
 80155a0:	b580      	push	{r7, lr}
 80155a2:	b082      	sub	sp, #8
 80155a4:	af00      	add	r7, sp, #0
 80155a6:	6078      	str	r0, [r7, #4]
    rt_components_init();
 80155a8:	f000 faba 	bl	8015b20 <rt_components_init>
}
 80155ac:	3708      	adds	r7, #8
 80155ae:	46bd      	mov	sp, r7
 80155b0:	bd80      	pop	{r7, pc}
 80155b2:	bf00      	nop

080155b4 <rt_application_init>:

int rt_application_init()
{
 80155b4:	b580      	push	{r7, lr}
 80155b6:	b084      	sub	sp, #16
 80155b8:	af02      	add	r7, sp, #8
    rt_thread_t tid;

    tid = rt_thread_create("init",
 80155ba:	230a      	movs	r3, #10
 80155bc:	9300      	str	r3, [sp, #0]
 80155be:	2314      	movs	r3, #20
 80155c0:	9301      	str	r3, [sp, #4]
 80155c2:	4809      	ldr	r0, [pc, #36]	; (80155e8 <rt_application_init+0x34>)
 80155c4:	4909      	ldr	r1, [pc, #36]	; (80155ec <rt_application_init+0x38>)
 80155c6:	2200      	movs	r2, #0
 80155c8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80155cc:	f003 fb4a 	bl	8018c64 <rt_thread_create>
 80155d0:	6078      	str	r0, [r7, #4]
                           rt_init_thread_entry, RT_NULL,
                           2048, RT_THREAD_PRIORITY_MAX / 3, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 80155d2:	687b      	ldr	r3, [r7, #4]
 80155d4:	2b00      	cmp	r3, #0
 80155d6:	d002      	beq.n	80155de <rt_application_init+0x2a>
 80155d8:	6878      	ldr	r0, [r7, #4]
 80155da:	f003 fb05 	bl	8018be8 <rt_thread_startup>

    return 0;
 80155de:	2300      	movs	r3, #0
}
 80155e0:	4618      	mov	r0, r3
 80155e2:	3708      	adds	r7, #8
 80155e4:	46bd      	mov	sp, r7
 80155e6:	bd80      	pop	{r7, pc}
 80155e8:	080274a4 	.word	0x080274a4
 80155ec:	080155a1 	.word	0x080155a1

080155f0 <sram_init>:

#ifdef RT_USING_EXT_SDRAM
struct rt_memheap system_heap;

void sram_init(void)
{
 80155f0:	b580      	push	{r7, lr}
 80155f2:	af00      	add	r7, sp, #0
    /* initialize the built-in SRAM as a memory heap */
    rt_memheap_init(&system_heap,
                    "system",
                    (void *)HEAP_BEGIN,
                    (rt_uint32_t)HEAP_END - (rt_uint32_t)HEAP_BEGIN);
 80155f4:	4a04      	ldr	r2, [pc, #16]	; (8015608 <sram_init+0x18>)
struct rt_memheap system_heap;

void sram_init(void)
{
    /* initialize the built-in SRAM as a memory heap */
    rt_memheap_init(&system_heap,
 80155f6:	4b05      	ldr	r3, [pc, #20]	; (801560c <sram_init+0x1c>)
 80155f8:	1a9b      	subs	r3, r3, r2
 80155fa:	4805      	ldr	r0, [pc, #20]	; (8015610 <sram_init+0x20>)
 80155fc:	4905      	ldr	r1, [pc, #20]	; (8015614 <sram_init+0x24>)
 80155fe:	4a02      	ldr	r2, [pc, #8]	; (8015608 <sram_init+0x18>)
 8015600:	f002 fddc 	bl	80181bc <rt_memheap_init>
                    "system",
                    (void *)HEAP_BEGIN,
                    (rt_uint32_t)HEAP_END - (rt_uint32_t)HEAP_BEGIN);
}
 8015604:	bd80      	pop	{r7, pc}
 8015606:	bf00      	nop
 8015608:	20012fd0 	.word	0x20012fd0
 801560c:	20050000 	.word	0x20050000
 8015610:	200129d0 	.word	0x200129d0
 8015614:	080274ac 	.word	0x080274ac

08015618 <rtthread_startup>:

/**
 * This function will startup RT-Thread RTOS.
 */
void rtthread_startup(void)
{
 8015618:	b580      	push	{r7, lr}
 801561a:	af00      	add	r7, sp, #0
    /* init board */
    rt_hw_board_init();
 801561c:	f7fd fa26 	bl	8012a6c <rt_hw_board_init>

    /* show version */
    rt_show_version();
 8015620:	f001 fd0c 	bl	801703c <rt_show_version>

    /* init tick */
    rt_system_tick_init();
 8015624:	f000 fa00 	bl	8015a28 <rt_system_tick_init>

    /* init kernel object */
    rt_system_object_init();
 8015628:	f002 fe9c 	bl	8018364 <rt_system_object_init>

    /* init timer system */
    rt_system_timer_init();
 801562c:	f004 f87a 	bl	8019724 <rt_system_timer_init>

#ifdef RT_USING_EXT_SDRAM
    sdram_hw_init();
 8015630:	f7fe fc7a 	bl	8013f28 <sdram_hw_init>
    rt_system_heap_init((void*)EXT_SDRAM_BEGIN, (void*)EXT_SDRAM_END);
 8015634:	f04f 4040 	mov.w	r0, #3221225472	; 0xc0000000
 8015638:	4908      	ldr	r1, [pc, #32]	; (801565c <rtthread_startup+0x44>)
 801563a:	f002 fa5f 	bl	8017afc <rt_system_heap_init>
    sram_init();
 801563e:	f7ff ffd7 	bl	80155f0 <sram_init>
#else
    rt_system_heap_init((void*)HEAP_BEGIN, (void*)HEAP_END);
#endif

    /* init scheduler system */
    rt_system_scheduler_init();
 8015642:	f003 f841 	bl	80186c8 <rt_system_scheduler_init>

    /* init application */
    rt_application_init();
 8015646:	f7ff ffb5 	bl	80155b4 <rt_application_init>

    /* init timer thread */
    rt_system_timer_thread_init();
 801564a:	f004 f883 	bl	8019754 <rt_system_timer_thread_init>

    /* init idle thread */
    rt_thread_idle_init();
 801564e:	f000 fcd7 	bl	8016000 <rt_thread_idle_init>
    /* start scheduler */
    rt_system_scheduler_start();
 8015652:	f003 f863 	bl	801871c <rt_system_scheduler_start>

    /* never reach here */
    return ;
 8015656:	bf00      	nop
}
 8015658:	bd80      	pop	{r7, pc}
 801565a:	bf00      	nop
 801565c:	c0100000 	.word	0xc0100000

08015660 <main>:

int main(void)
{
 8015660:	b580      	push	{r7, lr}
 8015662:	af00      	add	r7, sp, #0
    /* disable interrupt first */
    rt_hw_interrupt_disable();
 8015664:	f7ea fdb0 	bl	80001c8 <rt_hw_interrupt_disable>

    /* startup RT-Thread RTOS */
    rtthread_startup();
 8015668:	f7ff ffd6 	bl	8015618 <rtthread_startup>

    return 0;
 801566c:	2300      	movs	r3, #0
}
 801566e:	4618      	mov	r0, r3
 8015670:	bd80      	pop	{r7, pc}
 8015672:	bf00      	nop

08015674 <myprintf>:
	char size;
};

static rt_mq_t rx_mq;
rt_err_t myprintf(char *buf, uint8_t size)
{
 8015674:	b580      	push	{r7, lr}
 8015676:	b086      	sub	sp, #24
 8015678:	af00      	add	r7, sp, #0
 801567a:	6078      	str	r0, [r7, #4]
 801567c:	460b      	mov	r3, r1
 801567e:	70fb      	strb	r3, [r7, #3]
	struct tx_msg txmsg;
	rt_err_t result = RT_EOK;
 8015680:	2300      	movs	r3, #0
 8015682:	617b      	str	r3, [r7, #20]
	
	if(tx_mq == RT_NULL || txfifo == RT_NULL || buf == RT_NULL)
 8015684:	4b22      	ldr	r3, [pc, #136]	; (8015710 <myprintf+0x9c>)
 8015686:	681b      	ldr	r3, [r3, #0]
 8015688:	2b00      	cmp	r3, #0
 801568a:	d006      	beq.n	801569a <myprintf+0x26>
 801568c:	4b21      	ldr	r3, [pc, #132]	; (8015714 <myprintf+0xa0>)
 801568e:	681b      	ldr	r3, [r3, #0]
 8015690:	2b00      	cmp	r3, #0
 8015692:	d002      	beq.n	801569a <myprintf+0x26>
 8015694:	687b      	ldr	r3, [r7, #4]
 8015696:	2b00      	cmp	r3, #0
 8015698:	d103      	bne.n	80156a2 <myprintf+0x2e>
		return (result = RT_ERROR);
 801569a:	2301      	movs	r3, #1
 801569c:	617b      	str	r3, [r7, #20]
 801569e:	697b      	ldr	r3, [r7, #20]
 80156a0:	e032      	b.n	8015708 <myprintf+0x94>
	txmsg.size = size;
 80156a2:	78fb      	ldrb	r3, [r7, #3]
 80156a4:	613b      	str	r3, [r7, #16]
	txmsg.data = buf;
 80156a6:	687b      	ldr	r3, [r7, #4]
 80156a8:	60fb      	str	r3, [r7, #12]
	txfifo->txmsg[txfifo->index] = txmsg;
 80156aa:	4b1a      	ldr	r3, [pc, #104]	; (8015714 <myprintf+0xa0>)
 80156ac:	681b      	ldr	r3, [r3, #0]
 80156ae:	681a      	ldr	r2, [r3, #0]
 80156b0:	4b18      	ldr	r3, [pc, #96]	; (8015714 <myprintf+0xa0>)
 80156b2:	681b      	ldr	r3, [r3, #0]
 80156b4:	791b      	ldrb	r3, [r3, #4]
 80156b6:	00db      	lsls	r3, r3, #3
 80156b8:	4413      	add	r3, r2
 80156ba:	461a      	mov	r2, r3
 80156bc:	f107 030c 	add.w	r3, r7, #12
 80156c0:	e893 0003 	ldmia.w	r3, {r0, r1}
 80156c4:	e882 0003 	stmia.w	r2, {r0, r1}
	result = rt_mq_send(tx_mq,&(txfifo->txmsg[txfifo->index]),sizeof(struct tx_msg));
 80156c8:	4b11      	ldr	r3, [pc, #68]	; (8015710 <myprintf+0x9c>)
 80156ca:	6819      	ldr	r1, [r3, #0]
 80156cc:	4b11      	ldr	r3, [pc, #68]	; (8015714 <myprintf+0xa0>)
 80156ce:	681b      	ldr	r3, [r3, #0]
 80156d0:	681a      	ldr	r2, [r3, #0]
 80156d2:	4b10      	ldr	r3, [pc, #64]	; (8015714 <myprintf+0xa0>)
 80156d4:	681b      	ldr	r3, [r3, #0]
 80156d6:	791b      	ldrb	r3, [r3, #4]
 80156d8:	00db      	lsls	r3, r3, #3
 80156da:	4413      	add	r3, r2
 80156dc:	4608      	mov	r0, r1
 80156de:	4619      	mov	r1, r3
 80156e0:	2208      	movs	r2, #8
 80156e2:	f001 f925 	bl	8016930 <rt_mq_send>
 80156e6:	6178      	str	r0, [r7, #20]
	txfifo->index++;
 80156e8:	4b0a      	ldr	r3, [pc, #40]	; (8015714 <myprintf+0xa0>)
 80156ea:	681b      	ldr	r3, [r3, #0]
 80156ec:	791a      	ldrb	r2, [r3, #4]
 80156ee:	3201      	adds	r2, #1
 80156f0:	b2d2      	uxtb	r2, r2
 80156f2:	711a      	strb	r2, [r3, #4]
	if(txfifo->index > UART3TXFIFOLENGTH)
 80156f4:	4b07      	ldr	r3, [pc, #28]	; (8015714 <myprintf+0xa0>)
 80156f6:	681b      	ldr	r3, [r3, #0]
 80156f8:	791b      	ldrb	r3, [r3, #4]
 80156fa:	2b03      	cmp	r3, #3
 80156fc:	d903      	bls.n	8015706 <myprintf+0x92>
	{
		txfifo->index = 0;
 80156fe:	4b05      	ldr	r3, [pc, #20]	; (8015714 <myprintf+0xa0>)
 8015700:	681b      	ldr	r3, [r3, #0]
 8015702:	2200      	movs	r2, #0
 8015704:	711a      	strb	r2, [r3, #4]
	}
	return result;
 8015706:	697b      	ldr	r3, [r7, #20]
}
 8015708:	4618      	mov	r0, r3
 801570a:	3718      	adds	r7, #24
 801570c:	46bd      	mov	sp, r7
 801570e:	bd80      	pop	{r7, pc}
 8015710:	20010a34 	.word	0x20010a34
 8015714:	20012a34 	.word	0x20012a34

08015718 <USER_Usart3txTask_entry>:

void USER_Usart3txTask_entry(void *parameter)
{
 8015718:	b580      	push	{r7, lr}
 801571a:	b086      	sub	sp, #24
 801571c:	af00      	add	r7, sp, #0
 801571e:	6078      	str	r0, [r7, #4]
	
	rt_device_t device;
	device = rt_device_find("uart3");
 8015720:	4813      	ldr	r0, [pc, #76]	; (8015770 <USER_Usart3txTask_entry+0x58>)
 8015722:	f000 fa3d 	bl	8015ba0 <rt_device_find>
 8015726:	6178      	str	r0, [r7, #20]
	rt_err_t result = RT_EOK;
 8015728:	2300      	movs	r3, #0
 801572a:	613b      	str	r3, [r7, #16]
	
	struct tx_msg txmsg;
	if ( device != RT_NULL )
 801572c:	697b      	ldr	r3, [r7, #20]
 801572e:	2b00      	cmp	r3, #0
 8015730:	d00a      	beq.n	8015748 <USER_Usart3txTask_entry+0x30>
	{
		
		
		if (rt_device_open (device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_INT_RX) != RT_EOK)
 8015732:	6978      	ldr	r0, [r7, #20]
 8015734:	f240 1103 	movw	r1, #259	; 0x103
 8015738:	f000 fa6e 	bl	8015c18 <rt_device_open>
 801573c:	4603      	mov	r3, r0
 801573e:	2b00      	cmp	r3, #0
 8015740:	d002      	beq.n	8015748 <USER_Usart3txTask_entry+0x30>
		{
			rt_kprintf("open error\r\n");
 8015742:	480c      	ldr	r0, [pc, #48]	; (8015774 <USER_Usart3txTask_entry+0x5c>)
 8015744:	f002 f8ba 	bl	80178bc <rt_kprintf>
		}
	}
	
	while(1)
	{
		rt_mq_recv(tx_mq,&txmsg,sizeof(struct tx_msg),50);
 8015748:	4b0b      	ldr	r3, [pc, #44]	; (8015778 <USER_Usart3txTask_entry+0x60>)
 801574a:	681a      	ldr	r2, [r3, #0]
 801574c:	f107 0308 	add.w	r3, r7, #8
 8015750:	4610      	mov	r0, r2
 8015752:	4619      	mov	r1, r3
 8015754:	2208      	movs	r2, #8
 8015756:	2332      	movs	r3, #50	; 0x32
 8015758:	f001 f984 	bl	8016a64 <rt_mq_recv>
		
		if (result == RT_EOK)
 801575c:	693b      	ldr	r3, [r7, #16]
 801575e:	2b00      	cmp	r3, #0
 8015760:	d105      	bne.n	801576e <USER_Usart3txTask_entry+0x56>
		{
			rt_device_write(device, 0,txmsg.data,txmsg.size);
 8015762:	68ba      	ldr	r2, [r7, #8]
 8015764:	68fb      	ldr	r3, [r7, #12]
 8015766:	6978      	ldr	r0, [r7, #20]
 8015768:	2100      	movs	r1, #0
 801576a:	f000 fb3b 	bl	8015de4 <rt_device_write>
		}
	}
 801576e:	e7eb      	b.n	8015748 <USER_Usart3txTask_entry+0x30>
 8015770:	080274b4 	.word	0x080274b4
 8015774:	080274bc 	.word	0x080274bc
 8015778:	20010a34 	.word	0x20010a34

0801577c <USER_Usart3txTask_init>:
	
}


int USER_Usart3txTask_init()
{
 801577c:	b580      	push	{r7, lr}
 801577e:	b084      	sub	sp, #16
 8015780:	af02      	add	r7, sp, #8
    rt_thread_t tid;

	
	if ((tx_mq = rt_mq_create("usart3tx", sizeof(struct tx_msg),UART3TXFIFOLENGTH,RT_IPC_FLAG_FIFO)) == RT_NULL)
 8015782:	4821      	ldr	r0, [pc, #132]	; (8015808 <USER_Usart3txTask_init+0x8c>)
 8015784:	2108      	movs	r1, #8
 8015786:	2203      	movs	r2, #3
 8015788:	2300      	movs	r3, #0
 801578a:	f001 f813 	bl	80167b4 <rt_mq_create>
 801578e:	4602      	mov	r2, r0
 8015790:	4b1e      	ldr	r3, [pc, #120]	; (801580c <USER_Usart3txTask_init+0x90>)
 8015792:	601a      	str	r2, [r3, #0]
 8015794:	4b1d      	ldr	r3, [pc, #116]	; (801580c <USER_Usart3txTask_init+0x90>)
 8015796:	681b      	ldr	r3, [r3, #0]
 8015798:	2b00      	cmp	r3, #0
 801579a:	d102      	bne.n	80157a2 <USER_Usart3txTask_init+0x26>
	{
		rt_kprintf("sem create error\r\n");
 801579c:	481c      	ldr	r0, [pc, #112]	; (8015810 <USER_Usart3txTask_init+0x94>)
 801579e:	f002 f88d 	bl	80178bc <rt_kprintf>
	}
	
	txfifo = (struct Txfifo *)rt_malloc(sizeof(struct Txfifo)+UART3TXFIFOLENGTH*sizeof(struct tx_msg));
 80157a2:	2020      	movs	r0, #32
 80157a4:	f002 fa38 	bl	8017c18 <rt_malloc>
 80157a8:	4602      	mov	r2, r0
 80157aa:	4b1a      	ldr	r3, [pc, #104]	; (8015814 <USER_Usart3txTask_init+0x98>)
 80157ac:	601a      	str	r2, [r3, #0]
	if(txfifo != RT_NULL)
 80157ae:	4b19      	ldr	r3, [pc, #100]	; (8015814 <USER_Usart3txTask_init+0x98>)
 80157b0:	681b      	ldr	r3, [r3, #0]
 80157b2:	2b00      	cmp	r3, #0
 80157b4:	d011      	beq.n	80157da <USER_Usart3txTask_init+0x5e>
	{
		txfifo->txmsg = (struct tx_msg *)(txfifo+1);
 80157b6:	4b17      	ldr	r3, [pc, #92]	; (8015814 <USER_Usart3txTask_init+0x98>)
 80157b8:	681b      	ldr	r3, [r3, #0]
 80157ba:	4a16      	ldr	r2, [pc, #88]	; (8015814 <USER_Usart3txTask_init+0x98>)
 80157bc:	6812      	ldr	r2, [r2, #0]
 80157be:	3208      	adds	r2, #8
 80157c0:	601a      	str	r2, [r3, #0]
		rt_memset(txfifo->txmsg,0,UART3TXFIFOLENGTH*sizeof(struct tx_msg));
 80157c2:	4b14      	ldr	r3, [pc, #80]	; (8015814 <USER_Usart3txTask_init+0x98>)
 80157c4:	681b      	ldr	r3, [r3, #0]
 80157c6:	681b      	ldr	r3, [r3, #0]
 80157c8:	4618      	mov	r0, r3
 80157ca:	2100      	movs	r1, #0
 80157cc:	2218      	movs	r2, #24
 80157ce:	f001 fabd 	bl	8016d4c <rt_memset>
		txfifo->index = 0;
 80157d2:	4b10      	ldr	r3, [pc, #64]	; (8015814 <USER_Usart3txTask_init+0x98>)
 80157d4:	681b      	ldr	r3, [r3, #0]
 80157d6:	2200      	movs	r2, #0
 80157d8:	711a      	strb	r2, [r3, #4]
	}
	
	tid = rt_thread_create("usart3tx",						
 80157da:	2309      	movs	r3, #9
 80157dc:	9300      	str	r3, [sp, #0]
 80157de:	2314      	movs	r3, #20
 80157e0:	9301      	str	r3, [sp, #4]
 80157e2:	4809      	ldr	r0, [pc, #36]	; (8015808 <USER_Usart3txTask_init+0x8c>)
 80157e4:	490c      	ldr	r1, [pc, #48]	; (8015818 <USER_Usart3txTask_init+0x9c>)
 80157e6:	2200      	movs	r2, #0
 80157e8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80157ec:	f003 fa3a 	bl	8018c64 <rt_thread_create>
 80157f0:	6078      	str	r0, [r7, #4]
                           USER_Usart3txTask_entry, RT_NULL,
                           1024, USER_Usart3txTask_PRIORITY, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 80157f2:	687b      	ldr	r3, [r7, #4]
 80157f4:	2b00      	cmp	r3, #0
 80157f6:	d002      	beq.n	80157fe <USER_Usart3txTask_init+0x82>
 80157f8:	6878      	ldr	r0, [r7, #4]
 80157fa:	f003 f9f5 	bl	8018be8 <rt_thread_startup>

    return 0;
 80157fe:	2300      	movs	r3, #0
}
 8015800:	4618      	mov	r0, r3
 8015802:	3708      	adds	r7, #8
 8015804:	46bd      	mov	sp, r7
 8015806:	bd80      	pop	{r7, pc}
 8015808:	080274cc 	.word	0x080274cc
 801580c:	20010a34 	.word	0x20010a34
 8015810:	080274d8 	.word	0x080274d8
 8015814:	20012a34 	.word	0x20012a34
 8015818:	08015719 	.word	0x08015719

0801581c <myscanf>:
INIT_APP_EXPORT(USER_Usart3txTask_init);


rt_err_t myscanf(char *buf)
{
 801581c:	b580      	push	{r7, lr}
 801581e:	b086      	sub	sp, #24
 8015820:	af00      	add	r7, sp, #0
 8015822:	6078      	str	r0, [r7, #4]
	rt_err_t result = RT_EOK;
 8015824:	2300      	movs	r3, #0
 8015826:	613b      	str	r3, [r7, #16]
	char i;
	struct rx_msg rx_msg;
	
	if(rx_mq == RT_NULL || buf ==  RT_NULL)
 8015828:	4b1a      	ldr	r3, [pc, #104]	; (8015894 <myscanf+0x78>)
 801582a:	681b      	ldr	r3, [r3, #0]
 801582c:	2b00      	cmp	r3, #0
 801582e:	d002      	beq.n	8015836 <myscanf+0x1a>
 8015830:	687b      	ldr	r3, [r7, #4]
 8015832:	2b00      	cmp	r3, #0
 8015834:	d103      	bne.n	801583e <myscanf+0x22>
		return (result = RT_ERROR);
 8015836:	2301      	movs	r3, #1
 8015838:	613b      	str	r3, [r7, #16]
 801583a:	693b      	ldr	r3, [r7, #16]
 801583c:	e025      	b.n	801588a <myscanf+0x6e>
	result = rt_mq_recv(rx_mq,&rx_msg,sizeof(struct rx_msg),50);
 801583e:	4b15      	ldr	r3, [pc, #84]	; (8015894 <myscanf+0x78>)
 8015840:	681a      	ldr	r2, [r3, #0]
 8015842:	f107 0308 	add.w	r3, r7, #8
 8015846:	4610      	mov	r0, r2
 8015848:	4619      	mov	r1, r3
 801584a:	2208      	movs	r2, #8
 801584c:	2332      	movs	r3, #50	; 0x32
 801584e:	f001 f909 	bl	8016a64 <rt_mq_recv>
 8015852:	6138      	str	r0, [r7, #16]
	if(result == RT_EOK)
 8015854:	693b      	ldr	r3, [r7, #16]
 8015856:	2b00      	cmp	r3, #0
 8015858:	d116      	bne.n	8015888 <myscanf+0x6c>
	{
		for(i = 0;i<rx_msg.size;i++)
 801585a:	2300      	movs	r3, #0
 801585c:	75fb      	strb	r3, [r7, #23]
 801585e:	e00a      	b.n	8015876 <myscanf+0x5a>
			buf[i] = rx_msg.data[i];
 8015860:	7dfb      	ldrb	r3, [r7, #23]
 8015862:	687a      	ldr	r2, [r7, #4]
 8015864:	4413      	add	r3, r2
 8015866:	68b9      	ldr	r1, [r7, #8]
 8015868:	7dfa      	ldrb	r2, [r7, #23]
 801586a:	440a      	add	r2, r1
 801586c:	7812      	ldrb	r2, [r2, #0]
 801586e:	701a      	strb	r2, [r3, #0]
	if(rx_mq == RT_NULL || buf ==  RT_NULL)
		return (result = RT_ERROR);
	result = rt_mq_recv(rx_mq,&rx_msg,sizeof(struct rx_msg),50);
	if(result == RT_EOK)
	{
		for(i = 0;i<rx_msg.size;i++)
 8015870:	7dfb      	ldrb	r3, [r7, #23]
 8015872:	3301      	adds	r3, #1
 8015874:	75fb      	strb	r3, [r7, #23]
 8015876:	7b3b      	ldrb	r3, [r7, #12]
 8015878:	7dfa      	ldrb	r2, [r7, #23]
 801587a:	429a      	cmp	r2, r3
 801587c:	d3f0      	bcc.n	8015860 <myscanf+0x44>
			buf[i] = rx_msg.data[i];
		buf[i] = '\0';
 801587e:	7dfb      	ldrb	r3, [r7, #23]
 8015880:	687a      	ldr	r2, [r7, #4]
 8015882:	4413      	add	r3, r2
 8015884:	2200      	movs	r2, #0
 8015886:	701a      	strb	r2, [r3, #0]
	}
	return result;
 8015888:	693b      	ldr	r3, [r7, #16]
}
 801588a:	4618      	mov	r0, r3
 801588c:	3718      	adds	r7, #24
 801588e:	46bd      	mov	sp, r7
 8015890:	bd80      	pop	{r7, pc}
 8015892:	bf00      	nop
 8015894:	20010a40 	.word	0x20010a40

08015898 <uart_input>:
static rt_err_t uart_input(rt_device_t dev, rt_size_t size)
{
 8015898:	b580      	push	{r7, lr}
 801589a:	b082      	sub	sp, #8
 801589c:	af00      	add	r7, sp, #0
 801589e:	6078      	str	r0, [r7, #4]
 80158a0:	6039      	str	r1, [r7, #0]
	rt_sem_release(rx_sem);
 80158a2:	4b05      	ldr	r3, [pc, #20]	; (80158b8 <uart_input+0x20>)
 80158a4:	681b      	ldr	r3, [r3, #0]
 80158a6:	4618      	mov	r0, r3
 80158a8:	f000 fd98 	bl	80163dc <rt_sem_release>
	return RT_EOK;
 80158ac:	2300      	movs	r3, #0
}
 80158ae:	4618      	mov	r0, r3
 80158b0:	3708      	adds	r7, #8
 80158b2:	46bd      	mov	sp, r7
 80158b4:	bd80      	pop	{r7, pc}
 80158b6:	bf00      	nop
 80158b8:	20010a3c 	.word	0x20010a3c

080158bc <USER_Usart3rxTask_entry>:

void USER_Usart3rxTask_entry(void *parameter)
{
 80158bc:	b580      	push	{r7, lr}
 80158be:	b08c      	sub	sp, #48	; 0x30
 80158c0:	af00      	add	r7, sp, #0
 80158c2:	6078      	str	r0, [r7, #4]

	rt_device_t device;
	rt_err_t result = RT_EOK;
 80158c4:	2300      	movs	r3, #0
 80158c6:	62fb      	str	r3, [r7, #44]	; 0x2c
	static char i = 0;
	char rcvdata[RCVLENTH];
	struct rx_msg rx_msg;
	
	
	device = rt_device_find("uart3");
 80158c8:	482b      	ldr	r0, [pc, #172]	; (8015978 <USER_Usart3rxTask_entry+0xbc>)
 80158ca:	f000 f969 	bl	8015ba0 <rt_device_find>
 80158ce:	62b8      	str	r0, [r7, #40]	; 0x28
	
	if ( device != RT_NULL )
 80158d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80158d2:	2b00      	cmp	r3, #0
 80158d4:	d00e      	beq.n	80158f4 <USER_Usart3rxTask_entry+0x38>
	{
		rt_device_set_rx_indicate(device, uart_input);
 80158d6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80158d8:	4928      	ldr	r1, [pc, #160]	; (801597c <USER_Usart3rxTask_entry+0xc0>)
 80158da:	f000 fadd 	bl	8015e98 <rt_device_set_rx_indicate>
		if (rt_device_open (device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_INT_RX ) != RT_EOK)
 80158de:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80158e0:	f240 1103 	movw	r1, #259	; 0x103
 80158e4:	f000 f998 	bl	8015c18 <rt_device_open>
 80158e8:	4603      	mov	r3, r0
 80158ea:	2b00      	cmp	r3, #0
 80158ec:	d002      	beq.n	80158f4 <USER_Usart3rxTask_entry+0x38>
		{
			rt_kprintf("open error\r\n");
 80158ee:	4824      	ldr	r0, [pc, #144]	; (8015980 <USER_Usart3rxTask_entry+0xc4>)
 80158f0:	f001 ffe4 	bl	80178bc <rt_kprintf>
	}
	while(1)
	{
		//struct rx_msg msg;
		//rt_device_write(device, 0,buf,130);
		result = rt_sem_take(rx_sem, RT_WAITING_FOREVER);
 80158f4:	4b23      	ldr	r3, [pc, #140]	; (8015984 <USER_Usart3rxTask_entry+0xc8>)
 80158f6:	681b      	ldr	r3, [r3, #0]
 80158f8:	4618      	mov	r0, r3
 80158fa:	f04f 31ff 	mov.w	r1, #4294967295
 80158fe:	f000 fcc9 	bl	8016294 <rt_sem_take>
 8015902:	62f8      	str	r0, [r7, #44]	; 0x2c
		if (result == RT_EOK)
 8015904:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015906:	2b00      	cmp	r3, #0
 8015908:	d134      	bne.n	8015974 <USER_Usart3rxTask_entry+0xb8>
		{
			rt_uint32_t rx_length;
			rx_length = rt_device_read(device, 0, &ch,1);
 801590a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801590c:	2100      	movs	r1, #0
 801590e:	4a1e      	ldr	r2, [pc, #120]	; (8015988 <USER_Usart3rxTask_entry+0xcc>)
 8015910:	2301      	movs	r3, #1
 8015912:	f000 fa33 	bl	8015d7c <rt_device_read>
 8015916:	6278      	str	r0, [r7, #36]	; 0x24
			if(rx_length != 0)
 8015918:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801591a:	2b00      	cmp	r3, #0
 801591c:	d02a      	beq.n	8015974 <USER_Usart3rxTask_entry+0xb8>
			{
				rcvdata[i++] = ch;
 801591e:	4b1b      	ldr	r3, [pc, #108]	; (801598c <USER_Usart3rxTask_entry+0xd0>)
 8015920:	781b      	ldrb	r3, [r3, #0]
 8015922:	1c5a      	adds	r2, r3, #1
 8015924:	b2d1      	uxtb	r1, r2
 8015926:	4a19      	ldr	r2, [pc, #100]	; (801598c <USER_Usart3rxTask_entry+0xd0>)
 8015928:	7011      	strb	r1, [r2, #0]
 801592a:	4619      	mov	r1, r3
 801592c:	4b16      	ldr	r3, [pc, #88]	; (8015988 <USER_Usart3rxTask_entry+0xcc>)
 801592e:	781a      	ldrb	r2, [r3, #0]
 8015930:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8015934:	440b      	add	r3, r1
 8015936:	f803 2c1c 	strb.w	r2, [r3, #-28]
				if(ch == 0x0d)
 801593a:	4b13      	ldr	r3, [pc, #76]	; (8015988 <USER_Usart3rxTask_entry+0xcc>)
 801593c:	781b      	ldrb	r3, [r3, #0]
 801593e:	2b0d      	cmp	r3, #13
 8015940:	d111      	bne.n	8015966 <USER_Usart3rxTask_entry+0xaa>
				{
					rx_msg.size = i;
 8015942:	4b12      	ldr	r3, [pc, #72]	; (801598c <USER_Usart3rxTask_entry+0xd0>)
 8015944:	781b      	ldrb	r3, [r3, #0]
 8015946:	743b      	strb	r3, [r7, #16]
					i = 0;
 8015948:	4b10      	ldr	r3, [pc, #64]	; (801598c <USER_Usart3rxTask_entry+0xd0>)
 801594a:	2200      	movs	r2, #0
 801594c:	701a      	strb	r2, [r3, #0]
					rx_msg.data = rcvdata;
 801594e:	f107 0314 	add.w	r3, r7, #20
 8015952:	60fb      	str	r3, [r7, #12]
					rt_mq_send(rx_mq,&rx_msg,sizeof(struct rx_msg));
 8015954:	4b0e      	ldr	r3, [pc, #56]	; (8015990 <USER_Usart3rxTask_entry+0xd4>)
 8015956:	681a      	ldr	r2, [r3, #0]
 8015958:	f107 030c 	add.w	r3, r7, #12
 801595c:	4610      	mov	r0, r2
 801595e:	4619      	mov	r1, r3
 8015960:	2208      	movs	r2, #8
 8015962:	f000 ffe5 	bl	8016930 <rt_mq_send>
				}
				
				if(i >= RCVLENTH)
 8015966:	4b09      	ldr	r3, [pc, #36]	; (801598c <USER_Usart3rxTask_entry+0xd0>)
 8015968:	781b      	ldrb	r3, [r3, #0]
 801596a:	2b0d      	cmp	r3, #13
 801596c:	d902      	bls.n	8015974 <USER_Usart3rxTask_entry+0xb8>
					i = 0;
 801596e:	4b07      	ldr	r3, [pc, #28]	; (801598c <USER_Usart3rxTask_entry+0xd0>)
 8015970:	2200      	movs	r2, #0
 8015972:	701a      	strb	r2, [r3, #0]
			}
		}
	}
 8015974:	e7be      	b.n	80158f4 <USER_Usart3rxTask_entry+0x38>
 8015976:	bf00      	nop
 8015978:	080274b4 	.word	0x080274b4
 801597c:	08015899 	.word	0x08015899
 8015980:	080274bc 	.word	0x080274bc
 8015984:	20010a3c 	.word	0x20010a3c
 8015988:	20010a38 	.word	0x20010a38
 801598c:	20010a44 	.word	0x20010a44
 8015990:	20010a40 	.word	0x20010a40

08015994 <USER_Usart3rxTask_init>:




int USER_Usart3rxTask_init()
{
 8015994:	b580      	push	{r7, lr}
 8015996:	b084      	sub	sp, #16
 8015998:	af02      	add	r7, sp, #8
    rt_thread_t tid;
	rt_device_t device;

	if ((rx_sem = rt_sem_create("usart3rcv", 0, RT_IPC_FLAG_FIFO)) == RT_NULL)
 801599a:	481b      	ldr	r0, [pc, #108]	; (8015a08 <USER_Usart3rxTask_init+0x74>)
 801599c:	2100      	movs	r1, #0
 801599e:	2200      	movs	r2, #0
 80159a0:	f000 fc3c 	bl	801621c <rt_sem_create>
 80159a4:	4602      	mov	r2, r0
 80159a6:	4b19      	ldr	r3, [pc, #100]	; (8015a0c <USER_Usart3rxTask_init+0x78>)
 80159a8:	601a      	str	r2, [r3, #0]
 80159aa:	4b18      	ldr	r3, [pc, #96]	; (8015a0c <USER_Usart3rxTask_init+0x78>)
 80159ac:	681b      	ldr	r3, [r3, #0]
 80159ae:	2b00      	cmp	r3, #0
 80159b0:	d102      	bne.n	80159b8 <USER_Usart3rxTask_init+0x24>
	{
		rt_kprintf("sem create error\r\n");
 80159b2:	4817      	ldr	r0, [pc, #92]	; (8015a10 <USER_Usart3rxTask_init+0x7c>)
 80159b4:	f001 ff82 	bl	80178bc <rt_kprintf>
	}
	if ((rx_mq = rt_mq_create("usart3rxmq", sizeof(struct rx_msg),RXMQSIZE,RT_IPC_FLAG_FIFO)) == RT_NULL)
 80159b8:	4816      	ldr	r0, [pc, #88]	; (8015a14 <USER_Usart3rxTask_init+0x80>)
 80159ba:	2108      	movs	r1, #8
 80159bc:	2203      	movs	r2, #3
 80159be:	2300      	movs	r3, #0
 80159c0:	f000 fef8 	bl	80167b4 <rt_mq_create>
 80159c4:	4602      	mov	r2, r0
 80159c6:	4b14      	ldr	r3, [pc, #80]	; (8015a18 <USER_Usart3rxTask_init+0x84>)
 80159c8:	601a      	str	r2, [r3, #0]
 80159ca:	4b13      	ldr	r3, [pc, #76]	; (8015a18 <USER_Usart3rxTask_init+0x84>)
 80159cc:	681b      	ldr	r3, [r3, #0]
 80159ce:	2b00      	cmp	r3, #0
 80159d0:	d102      	bne.n	80159d8 <USER_Usart3rxTask_init+0x44>
	{
		rt_kprintf("rx_mq create error\r\n");
 80159d2:	4812      	ldr	r0, [pc, #72]	; (8015a1c <USER_Usart3rxTask_init+0x88>)
 80159d4:	f001 ff72 	bl	80178bc <rt_kprintf>
	}
	
	tid = rt_thread_create("usart3rx",						
 80159d8:	2309      	movs	r3, #9
 80159da:	9300      	str	r3, [sp, #0]
 80159dc:	2314      	movs	r3, #20
 80159de:	9301      	str	r3, [sp, #4]
 80159e0:	480f      	ldr	r0, [pc, #60]	; (8015a20 <USER_Usart3rxTask_init+0x8c>)
 80159e2:	4910      	ldr	r1, [pc, #64]	; (8015a24 <USER_Usart3rxTask_init+0x90>)
 80159e4:	2200      	movs	r2, #0
 80159e6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80159ea:	f003 f93b 	bl	8018c64 <rt_thread_create>
 80159ee:	6078      	str	r0, [r7, #4]
                           USER_Usart3rxTask_entry, RT_NULL,
                           1024, USER_Usart3rxTask_PRIORITY, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 80159f0:	687b      	ldr	r3, [r7, #4]
 80159f2:	2b00      	cmp	r3, #0
 80159f4:	d002      	beq.n	80159fc <USER_Usart3rxTask_init+0x68>
 80159f6:	6878      	ldr	r0, [r7, #4]
 80159f8:	f003 f8f6 	bl	8018be8 <rt_thread_startup>

    return 0;
 80159fc:	2300      	movs	r3, #0
}
 80159fe:	4618      	mov	r0, r3
 8015a00:	3708      	adds	r7, #8
 8015a02:	46bd      	mov	sp, r7
 8015a04:	bd80      	pop	{r7, pc}
 8015a06:	bf00      	nop
 8015a08:	080274ec 	.word	0x080274ec
 8015a0c:	20010a3c 	.word	0x20010a3c
 8015a10:	080274d8 	.word	0x080274d8
 8015a14:	080274f8 	.word	0x080274f8
 8015a18:	20010a40 	.word	0x20010a40
 8015a1c:	08027504 	.word	0x08027504
 8015a20:	0802751c 	.word	0x0802751c
 8015a24:	080158bd 	.word	0x080158bd

08015a28 <rt_system_tick_init>:
 *
 * @deprecated since 1.1.0, this function does not need to be invoked
 * in the system initialization.
 */
void rt_system_tick_init(void)
{
 8015a28:	b480      	push	{r7}
 8015a2a:	af00      	add	r7, sp, #0
}
 8015a2c:	46bd      	mov	sp, r7
 8015a2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015a32:	4770      	bx	lr

08015a34 <rt_tick_get>:
 * This function will return current tick from operating system startup
 *
 * @return current tick
 */
rt_tick_t rt_tick_get(void)
{
 8015a34:	b480      	push	{r7}
 8015a36:	af00      	add	r7, sp, #0
    /* return the global tick */
    return rt_tick;
 8015a38:	4b03      	ldr	r3, [pc, #12]	; (8015a48 <rt_tick_get+0x14>)
 8015a3a:	681b      	ldr	r3, [r3, #0]
}
 8015a3c:	4618      	mov	r0, r3
 8015a3e:	46bd      	mov	sp, r7
 8015a40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015a44:	4770      	bx	lr
 8015a46:	bf00      	nop
 8015a48:	20010a48 	.word	0x20010a48

08015a4c <rt_tick_increase>:
/**
 * This function will notify kernel there is one tick passed. Normally,
 * this function is invoked by clock ISR.
 */
void rt_tick_increase(void)
{
 8015a4c:	b580      	push	{r7, lr}
 8015a4e:	b082      	sub	sp, #8
 8015a50:	af00      	add	r7, sp, #0
    struct rt_thread *thread;

    /* increase the global tick */
    ++ rt_tick;
 8015a52:	4b0e      	ldr	r3, [pc, #56]	; (8015a8c <rt_tick_increase+0x40>)
 8015a54:	681b      	ldr	r3, [r3, #0]
 8015a56:	3301      	adds	r3, #1
 8015a58:	4a0c      	ldr	r2, [pc, #48]	; (8015a8c <rt_tick_increase+0x40>)
 8015a5a:	6013      	str	r3, [r2, #0]

    /* check time slice */
    thread = rt_thread_self();
 8015a5c:	f003 f8b8 	bl	8018bd0 <rt_thread_self>
 8015a60:	6078      	str	r0, [r7, #4]

    -- thread->remaining_tick;
 8015a62:	687b      	ldr	r3, [r7, #4]
 8015a64:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8015a66:	1e5a      	subs	r2, r3, #1
 8015a68:	687b      	ldr	r3, [r7, #4]
 8015a6a:	649a      	str	r2, [r3, #72]	; 0x48
    if (thread->remaining_tick == 0)
 8015a6c:	687b      	ldr	r3, [r7, #4]
 8015a6e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8015a70:	2b00      	cmp	r3, #0
 8015a72:	d105      	bne.n	8015a80 <rt_tick_increase+0x34>
    {
        /* change to initialized tick */
        thread->remaining_tick = thread->init_tick;
 8015a74:	687b      	ldr	r3, [r7, #4]
 8015a76:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8015a78:	687b      	ldr	r3, [r7, #4]
 8015a7a:	649a      	str	r2, [r3, #72]	; 0x48

        /* yield */
        rt_thread_yield();
 8015a7c:	f003 f954 	bl	8018d28 <rt_thread_yield>
    }

    /* check timer */
    rt_timer_check();
 8015a80:	f003 fd68 	bl	8019554 <rt_timer_check>
}
 8015a84:	3708      	adds	r7, #8
 8015a86:	46bd      	mov	sp, r7
 8015a88:	bd80      	pop	{r7, pc}
 8015a8a:	bf00      	nop
 8015a8c:	20010a48 	.word	0x20010a48

08015a90 <rt_tick_from_millisecond>:
 * @param ms the specified millisecond
 *
 * @return the calculated tick
 */
rt_tick_t rt_tick_from_millisecond(rt_uint32_t ms)
{
 8015a90:	b480      	push	{r7}
 8015a92:	b083      	sub	sp, #12
 8015a94:	af00      	add	r7, sp, #0
 8015a96:	6078      	str	r0, [r7, #4]
    /* return the calculated tick */
    return (RT_TICK_PER_SECOND * ms + 999) / 1000;
 8015a98:	687b      	ldr	r3, [r7, #4]
 8015a9a:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8015a9e:	fb02 f303 	mul.w	r3, r2, r3
 8015aa2:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
 8015aa6:	4a05      	ldr	r2, [pc, #20]	; (8015abc <rt_tick_from_millisecond+0x2c>)
 8015aa8:	fba2 2303 	umull	r2, r3, r2, r3
 8015aac:	099b      	lsrs	r3, r3, #6
}
 8015aae:	4618      	mov	r0, r3
 8015ab0:	370c      	adds	r7, #12
 8015ab2:	46bd      	mov	sp, r7
 8015ab4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015ab8:	4770      	bx	lr
 8015aba:	bf00      	nop
 8015abc:	10624dd3 	.word	0x10624dd3

08015ac0 <rti_start>:
 * ...
 * INIT_APP_EXPORT(fn);
 * etc. 
 */
static int rti_start(void)
{
 8015ac0:	b480      	push	{r7}
 8015ac2:	af00      	add	r7, sp, #0
    return 0;
 8015ac4:	2300      	movs	r3, #0
}
 8015ac6:	4618      	mov	r0, r3
 8015ac8:	46bd      	mov	sp, r7
 8015aca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015ace:	4770      	bx	lr

08015ad0 <rti_board_end>:
INIT_EXPORT(rti_start, "0");

static int rti_board_end(void)
{
 8015ad0:	b480      	push	{r7}
 8015ad2:	af00      	add	r7, sp, #0
    return 0;
 8015ad4:	2300      	movs	r3, #0
}
 8015ad6:	4618      	mov	r0, r3
 8015ad8:	46bd      	mov	sp, r7
 8015ada:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015ade:	4770      	bx	lr

08015ae0 <rti_end>:
INIT_EXPORT(rti_board_end, "1.end");

static int rti_end(void)
{
 8015ae0:	b480      	push	{r7}
 8015ae2:	af00      	add	r7, sp, #0
	return 0;
 8015ae4:	2300      	movs	r3, #0
}
 8015ae6:	4618      	mov	r0, r3
 8015ae8:	46bd      	mov	sp, r7
 8015aea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015aee:	4770      	bx	lr

08015af0 <rt_components_board_init>:

/**
 * RT-Thread Components Initialization for board
 */
void rt_components_board_init(void)
{
 8015af0:	b580      	push	{r7, lr}
 8015af2:	b082      	sub	sp, #8
 8015af4:	af00      	add	r7, sp, #0
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_start; fn_ptr < &__rt_init_rti_board_end; fn_ptr++)
 8015af6:	4b08      	ldr	r3, [pc, #32]	; (8015b18 <rt_components_board_init+0x28>)
 8015af8:	607b      	str	r3, [r7, #4]
 8015afa:	e005      	b.n	8015b08 <rt_components_board_init+0x18>
    {
        (*fn_ptr)();
 8015afc:	687b      	ldr	r3, [r7, #4]
 8015afe:	681b      	ldr	r3, [r3, #0]
 8015b00:	4798      	blx	r3
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_start; fn_ptr < &__rt_init_rti_board_end; fn_ptr++)
 8015b02:	687b      	ldr	r3, [r7, #4]
 8015b04:	3304      	adds	r3, #4
 8015b06:	607b      	str	r3, [r7, #4]
 8015b08:	687b      	ldr	r3, [r7, #4]
 8015b0a:	4a04      	ldr	r2, [pc, #16]	; (8015b1c <rt_components_board_init+0x2c>)
 8015b0c:	4293      	cmp	r3, r2
 8015b0e:	d3f5      	bcc.n	8015afc <rt_components_board_init+0xc>
    {
        (*fn_ptr)();
    }
#endif
}
 8015b10:	3708      	adds	r7, #8
 8015b12:	46bd      	mov	sp, r7
 8015b14:	bd80      	pop	{r7, pc}
 8015b16:	bf00      	nop
 8015b18:	0802a5c8 	.word	0x0802a5c8
 8015b1c:	0802a5d8 	.word	0x0802a5d8

08015b20 <rt_components_init>:

/**
 * RT-Thread Components Initialization
 */
void rt_components_init(void)
{
 8015b20:	b580      	push	{r7, lr}
 8015b22:	b082      	sub	sp, #8
 8015b24:	af00      	add	r7, sp, #0
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_board_end; fn_ptr < &__rt_init_rti_end; fn_ptr ++)
 8015b26:	4b08      	ldr	r3, [pc, #32]	; (8015b48 <rt_components_init+0x28>)
 8015b28:	607b      	str	r3, [r7, #4]
 8015b2a:	e005      	b.n	8015b38 <rt_components_init+0x18>
    {
        (*fn_ptr)();
 8015b2c:	687b      	ldr	r3, [r7, #4]
 8015b2e:	681b      	ldr	r3, [r3, #0]
 8015b30:	4798      	blx	r3
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_board_end; fn_ptr < &__rt_init_rti_end; fn_ptr ++)
 8015b32:	687b      	ldr	r3, [r7, #4]
 8015b34:	3304      	adds	r3, #4
 8015b36:	607b      	str	r3, [r7, #4]
 8015b38:	687b      	ldr	r3, [r7, #4]
 8015b3a:	4a04      	ldr	r2, [pc, #16]	; (8015b4c <rt_components_init+0x2c>)
 8015b3c:	4293      	cmp	r3, r2
 8015b3e:	d3f5      	bcc.n	8015b2c <rt_components_init+0xc>
			}
		}
	}
#endif

}
 8015b40:	3708      	adds	r7, #8
 8015b42:	46bd      	mov	sp, r7
 8015b44:	bd80      	pop	{r7, pc}
 8015b46:	bf00      	nop
 8015b48:	0802a5d8 	.word	0x0802a5d8
 8015b4c:	0802a5fc 	.word	0x0802a5fc

08015b50 <rt_device_register>:
 * @return the error code, RT_EOK on initialization successfully.
 */
rt_err_t rt_device_register(rt_device_t dev,
                            const char *name,
                            rt_uint16_t flags)
{
 8015b50:	b580      	push	{r7, lr}
 8015b52:	b084      	sub	sp, #16
 8015b54:	af00      	add	r7, sp, #0
 8015b56:	60f8      	str	r0, [r7, #12]
 8015b58:	60b9      	str	r1, [r7, #8]
 8015b5a:	4613      	mov	r3, r2
 8015b5c:	80fb      	strh	r3, [r7, #6]
    if (dev == RT_NULL)
 8015b5e:	68fb      	ldr	r3, [r7, #12]
 8015b60:	2b00      	cmp	r3, #0
 8015b62:	d102      	bne.n	8015b6a <rt_device_register+0x1a>
        return -RT_ERROR;
 8015b64:	f04f 33ff 	mov.w	r3, #4294967295
 8015b68:	e015      	b.n	8015b96 <rt_device_register+0x46>

    if (rt_device_find(name) != RT_NULL)
 8015b6a:	68b8      	ldr	r0, [r7, #8]
 8015b6c:	f000 f818 	bl	8015ba0 <rt_device_find>
 8015b70:	4603      	mov	r3, r0
 8015b72:	2b00      	cmp	r3, #0
 8015b74:	d002      	beq.n	8015b7c <rt_device_register+0x2c>
        return -RT_ERROR;
 8015b76:	f04f 33ff 	mov.w	r3, #4294967295
 8015b7a:	e00c      	b.n	8015b96 <rt_device_register+0x46>

    rt_object_init(&(dev->parent), RT_Object_Class_Device, name);
 8015b7c:	68fb      	ldr	r3, [r7, #12]
 8015b7e:	4618      	mov	r0, r3
 8015b80:	2108      	movs	r1, #8
 8015b82:	68ba      	ldr	r2, [r7, #8]
 8015b84:	f002 fbf4 	bl	8018370 <rt_object_init>
    dev->flag = flags;
 8015b88:	68fb      	ldr	r3, [r7, #12]
 8015b8a:	88fa      	ldrh	r2, [r7, #6]
 8015b8c:	82da      	strh	r2, [r3, #22]
    dev->ref_count = 0;
 8015b8e:	68fb      	ldr	r3, [r7, #12]
 8015b90:	2200      	movs	r2, #0
 8015b92:	769a      	strb	r2, [r3, #26]

    return RT_EOK;
 8015b94:	2300      	movs	r3, #0
}
 8015b96:	4618      	mov	r0, r3
 8015b98:	3710      	adds	r7, #16
 8015b9a:	46bd      	mov	sp, r7
 8015b9c:	bd80      	pop	{r7, pc}
 8015b9e:	bf00      	nop

08015ba0 <rt_device_find>:
 * @param name the device driver's name
 *
 * @return the registered device driver on successful, or RT_NULL on failure.
 */
rt_device_t rt_device_find(const char *name)
{
 8015ba0:	b580      	push	{r7, lr}
 8015ba2:	b086      	sub	sp, #24
 8015ba4:	af00      	add	r7, sp, #0
 8015ba6:	6078      	str	r0, [r7, #4]
    struct rt_object_information *information;

    extern struct rt_object_information rt_object_container[];

    /* enter critical */
    if (rt_thread_self() != RT_NULL)
 8015ba8:	f003 f812 	bl	8018bd0 <rt_thread_self>
 8015bac:	4603      	mov	r3, r0
 8015bae:	2b00      	cmp	r3, #0
 8015bb0:	d001      	beq.n	8015bb6 <rt_device_find+0x16>
        rt_enter_critical();
 8015bb2:	f002 fe9d 	bl	80188f0 <rt_enter_critical>

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
 8015bb6:	4b17      	ldr	r3, [pc, #92]	; (8015c14 <rt_device_find+0x74>)
 8015bb8:	613b      	str	r3, [r7, #16]
    for (node  = information->object_list.next;
 8015bba:	693b      	ldr	r3, [r7, #16]
 8015bbc:	685b      	ldr	r3, [r3, #4]
 8015bbe:	617b      	str	r3, [r7, #20]
 8015bc0:	e017      	b.n	8015bf2 <rt_device_find+0x52>
         node != &(information->object_list);
         node  = node->next)
    {
        object = rt_list_entry(node, struct rt_object, list);
 8015bc2:	697b      	ldr	r3, [r7, #20]
 8015bc4:	3b0c      	subs	r3, #12
 8015bc6:	60fb      	str	r3, [r7, #12]
        if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
 8015bc8:	68fb      	ldr	r3, [r7, #12]
 8015bca:	4618      	mov	r0, r3
 8015bcc:	6879      	ldr	r1, [r7, #4]
 8015bce:	2208      	movs	r2, #8
 8015bd0:	f001 f9f6 	bl	8016fc0 <rt_strncmp>
 8015bd4:	4603      	mov	r3, r0
 8015bd6:	2b00      	cmp	r3, #0
 8015bd8:	d108      	bne.n	8015bec <rt_device_find+0x4c>
        {
            /* leave critical */
            if (rt_thread_self() != RT_NULL)
 8015bda:	f002 fff9 	bl	8018bd0 <rt_thread_self>
 8015bde:	4603      	mov	r3, r0
 8015be0:	2b00      	cmp	r3, #0
 8015be2:	d001      	beq.n	8015be8 <rt_device_find+0x48>
                rt_exit_critical();
 8015be4:	f002 fe98 	bl	8018918 <rt_exit_critical>

            return (rt_device_t)object;
 8015be8:	68fb      	ldr	r3, [r7, #12]
 8015bea:	e00f      	b.n	8015c0c <rt_device_find+0x6c>

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
    for (node  = information->object_list.next;
         node != &(information->object_list);
         node  = node->next)
 8015bec:	697b      	ldr	r3, [r7, #20]
 8015bee:	681b      	ldr	r3, [r3, #0]
 8015bf0:	617b      	str	r3, [r7, #20]
        rt_enter_critical();

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
    for (node  = information->object_list.next;
         node != &(information->object_list);
 8015bf2:	693b      	ldr	r3, [r7, #16]
 8015bf4:	1d1a      	adds	r2, r3, #4
    if (rt_thread_self() != RT_NULL)
        rt_enter_critical();

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
    for (node  = information->object_list.next;
 8015bf6:	697b      	ldr	r3, [r7, #20]
 8015bf8:	429a      	cmp	r2, r3
 8015bfa:	d1e2      	bne.n	8015bc2 <rt_device_find+0x22>
            return (rt_device_t)object;
        }
    }

    /* leave critical */
    if (rt_thread_self() != RT_NULL)
 8015bfc:	f002 ffe8 	bl	8018bd0 <rt_thread_self>
 8015c00:	4603      	mov	r3, r0
 8015c02:	2b00      	cmp	r3, #0
 8015c04:	d001      	beq.n	8015c0a <rt_device_find+0x6a>
        rt_exit_critical();
 8015c06:	f002 fe87 	bl	8018918 <rt_exit_critical>

    /* not found */
    return RT_NULL;
 8015c0a:	2300      	movs	r3, #0
}
 8015c0c:	4618      	mov	r0, r3
 8015c0e:	3718      	adds	r7, #24
 8015c10:	46bd      	mov	sp, r7
 8015c12:	bd80      	pop	{r7, pc}
 8015c14:	2001009c 	.word	0x2001009c

08015c18 <rt_device_open>:
 * @param oflag the flags for device open
 *
 * @return the result
 */
rt_err_t rt_device_open(rt_device_t dev, rt_uint16_t oflag)
{
 8015c18:	b580      	push	{r7, lr}
 8015c1a:	b084      	sub	sp, #16
 8015c1c:	af00      	add	r7, sp, #0
 8015c1e:	6078      	str	r0, [r7, #4]
 8015c20:	460b      	mov	r3, r1
 8015c22:	807b      	strh	r3, [r7, #2]
    rt_err_t result = RT_EOK;
 8015c24:	2300      	movs	r3, #0
 8015c26:	60fb      	str	r3, [r7, #12]

    RT_ASSERT(dev != RT_NULL);
 8015c28:	687b      	ldr	r3, [r7, #4]
 8015c2a:	2b00      	cmp	r3, #0
 8015c2c:	d104      	bne.n	8015c38 <rt_device_open+0x20>
 8015c2e:	4830      	ldr	r0, [pc, #192]	; (8015cf0 <rt_device_open+0xd8>)
 8015c30:	4930      	ldr	r1, [pc, #192]	; (8015cf4 <rt_device_open+0xdc>)
 8015c32:	22b6      	movs	r2, #182	; 0xb6
 8015c34:	f001 febc 	bl	80179b0 <rt_assert_handler>

    /* if device is not initialized, initialize it. */
    if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
 8015c38:	687b      	ldr	r3, [r7, #4]
 8015c3a:	8adb      	ldrh	r3, [r3, #22]
 8015c3c:	f003 0310 	and.w	r3, r3, #16
 8015c40:	2b00      	cmp	r3, #0
 8015c42:	d11a      	bne.n	8015c7a <rt_device_open+0x62>
    {
        if (dev->init != RT_NULL)
 8015c44:	687b      	ldr	r3, [r7, #4]
 8015c46:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8015c48:	2b00      	cmp	r3, #0
 8015c4a:	d00f      	beq.n	8015c6c <rt_device_open+0x54>
        {
            result = dev->init(dev);
 8015c4c:	687b      	ldr	r3, [r7, #4]
 8015c4e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8015c50:	6878      	ldr	r0, [r7, #4]
 8015c52:	4798      	blx	r3
 8015c54:	60f8      	str	r0, [r7, #12]
            if (result != RT_EOK)
 8015c56:	68fb      	ldr	r3, [r7, #12]
 8015c58:	2b00      	cmp	r3, #0
 8015c5a:	d007      	beq.n	8015c6c <rt_device_open+0x54>
            {
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
                           dev->parent.name, result);
 8015c5c:	687b      	ldr	r3, [r7, #4]
        if (dev->init != RT_NULL)
        {
            result = dev->init(dev);
            if (result != RT_EOK)
            {
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
 8015c5e:	4826      	ldr	r0, [pc, #152]	; (8015cf8 <rt_device_open+0xe0>)
 8015c60:	4619      	mov	r1, r3
 8015c62:	68fa      	ldr	r2, [r7, #12]
 8015c64:	f001 fe2a 	bl	80178bc <rt_kprintf>
                           dev->parent.name, result);

                return result;
 8015c68:	68fb      	ldr	r3, [r7, #12]
 8015c6a:	e03d      	b.n	8015ce8 <rt_device_open+0xd0>
            }
        }

        dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
 8015c6c:	687b      	ldr	r3, [r7, #4]
 8015c6e:	8adb      	ldrh	r3, [r3, #22]
 8015c70:	f043 0310 	orr.w	r3, r3, #16
 8015c74:	b29a      	uxth	r2, r3
 8015c76:	687b      	ldr	r3, [r7, #4]
 8015c78:	82da      	strh	r2, [r3, #22]
    }

    /* device is a stand alone device and opened */
    if ((dev->flag & RT_DEVICE_FLAG_STANDALONE) &&
 8015c7a:	687b      	ldr	r3, [r7, #4]
 8015c7c:	8adb      	ldrh	r3, [r3, #22]
 8015c7e:	f003 0308 	and.w	r3, r3, #8
 8015c82:	2b00      	cmp	r3, #0
 8015c84:	d008      	beq.n	8015c98 <rt_device_open+0x80>
        (dev->open_flag & RT_DEVICE_OFLAG_OPEN))
 8015c86:	687b      	ldr	r3, [r7, #4]
 8015c88:	8b1b      	ldrh	r3, [r3, #24]
 8015c8a:	f003 0308 	and.w	r3, r3, #8

        dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
    }

    /* device is a stand alone device and opened */
    if ((dev->flag & RT_DEVICE_FLAG_STANDALONE) &&
 8015c8e:	2b00      	cmp	r3, #0
 8015c90:	d002      	beq.n	8015c98 <rt_device_open+0x80>
        (dev->open_flag & RT_DEVICE_OFLAG_OPEN))
    {
        return -RT_EBUSY;
 8015c92:	f06f 0306 	mvn.w	r3, #6
 8015c96:	e027      	b.n	8015ce8 <rt_device_open+0xd0>
    }

    /* call device open interface */
    if (dev->open != RT_NULL)
 8015c98:	687b      	ldr	r3, [r7, #4]
 8015c9a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015c9c:	2b00      	cmp	r3, #0
 8015c9e:	d006      	beq.n	8015cae <rt_device_open+0x96>
    {
        result = dev->open(dev, oflag);
 8015ca0:	687b      	ldr	r3, [r7, #4]
 8015ca2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015ca4:	887a      	ldrh	r2, [r7, #2]
 8015ca6:	6878      	ldr	r0, [r7, #4]
 8015ca8:	4611      	mov	r1, r2
 8015caa:	4798      	blx	r3
 8015cac:	60f8      	str	r0, [r7, #12]
    }

    /* set open flag */
    if (result == RT_EOK || result == -RT_ENOSYS)
 8015cae:	68fb      	ldr	r3, [r7, #12]
 8015cb0:	2b00      	cmp	r3, #0
 8015cb2:	d003      	beq.n	8015cbc <rt_device_open+0xa4>
 8015cb4:	68fb      	ldr	r3, [r7, #12]
 8015cb6:	f113 0f06 	cmn.w	r3, #6
 8015cba:	d114      	bne.n	8015ce6 <rt_device_open+0xce>
    {
        dev->open_flag = oflag | RT_DEVICE_OFLAG_OPEN;
 8015cbc:	887b      	ldrh	r3, [r7, #2]
 8015cbe:	f043 0308 	orr.w	r3, r3, #8
 8015cc2:	b29a      	uxth	r2, r3
 8015cc4:	687b      	ldr	r3, [r7, #4]
 8015cc6:	831a      	strh	r2, [r3, #24]

        dev->ref_count++;
 8015cc8:	687b      	ldr	r3, [r7, #4]
 8015cca:	7e9b      	ldrb	r3, [r3, #26]
 8015ccc:	3301      	adds	r3, #1
 8015cce:	b2da      	uxtb	r2, r3
 8015cd0:	687b      	ldr	r3, [r7, #4]
 8015cd2:	769a      	strb	r2, [r3, #26]
        /* don't let bad things happen silently. If you are bitten by this assert,
         * please set the ref_count to a bigger type. */
        RT_ASSERT(dev->ref_count != 0);
 8015cd4:	687b      	ldr	r3, [r7, #4]
 8015cd6:	7e9b      	ldrb	r3, [r3, #26]
 8015cd8:	2b00      	cmp	r3, #0
 8015cda:	d104      	bne.n	8015ce6 <rt_device_open+0xce>
 8015cdc:	4807      	ldr	r0, [pc, #28]	; (8015cfc <rt_device_open+0xe4>)
 8015cde:	4905      	ldr	r1, [pc, #20]	; (8015cf4 <rt_device_open+0xdc>)
 8015ce0:	22df      	movs	r2, #223	; 0xdf
 8015ce2:	f001 fe65 	bl	80179b0 <rt_assert_handler>
    }

    return result;
 8015ce6:	68fb      	ldr	r3, [r7, #12]
}
 8015ce8:	4618      	mov	r0, r3
 8015cea:	3710      	adds	r7, #16
 8015cec:	46bd      	mov	sp, r7
 8015cee:	bd80      	pop	{r7, pc}
 8015cf0:	08027528 	.word	0x08027528
 8015cf4:	08028e28 	.word	0x08028e28
 8015cf8:	08027538 	.word	0x08027538
 8015cfc:	08027570 	.word	0x08027570

08015d00 <rt_device_close>:
 * @param dev the pointer of device driver structure
 *
 * @return the result
 */
rt_err_t rt_device_close(rt_device_t dev)
{
 8015d00:	b580      	push	{r7, lr}
 8015d02:	b084      	sub	sp, #16
 8015d04:	af00      	add	r7, sp, #0
 8015d06:	6078      	str	r0, [r7, #4]
    rt_err_t result = RT_EOK;
 8015d08:	2300      	movs	r3, #0
 8015d0a:	60fb      	str	r3, [r7, #12]

    RT_ASSERT(dev != RT_NULL);
 8015d0c:	687b      	ldr	r3, [r7, #4]
 8015d0e:	2b00      	cmp	r3, #0
 8015d10:	d104      	bne.n	8015d1c <rt_device_close+0x1c>
 8015d12:	4818      	ldr	r0, [pc, #96]	; (8015d74 <rt_device_close+0x74>)
 8015d14:	4918      	ldr	r1, [pc, #96]	; (8015d78 <rt_device_close+0x78>)
 8015d16:	22f1      	movs	r2, #241	; 0xf1
 8015d18:	f001 fe4a 	bl	80179b0 <rt_assert_handler>

    if (dev->ref_count == 0)
 8015d1c:	687b      	ldr	r3, [r7, #4]
 8015d1e:	7e9b      	ldrb	r3, [r3, #26]
 8015d20:	2b00      	cmp	r3, #0
 8015d22:	d102      	bne.n	8015d2a <rt_device_close+0x2a>
        return -RT_ERROR;
 8015d24:	f04f 33ff 	mov.w	r3, #4294967295
 8015d28:	e01f      	b.n	8015d6a <rt_device_close+0x6a>

    dev->ref_count--;
 8015d2a:	687b      	ldr	r3, [r7, #4]
 8015d2c:	7e9b      	ldrb	r3, [r3, #26]
 8015d2e:	3b01      	subs	r3, #1
 8015d30:	b2da      	uxtb	r2, r3
 8015d32:	687b      	ldr	r3, [r7, #4]
 8015d34:	769a      	strb	r2, [r3, #26]

    if (dev->ref_count != 0)
 8015d36:	687b      	ldr	r3, [r7, #4]
 8015d38:	7e9b      	ldrb	r3, [r3, #26]
 8015d3a:	2b00      	cmp	r3, #0
 8015d3c:	d001      	beq.n	8015d42 <rt_device_close+0x42>
        return RT_EOK;
 8015d3e:	2300      	movs	r3, #0
 8015d40:	e013      	b.n	8015d6a <rt_device_close+0x6a>

    /* call device close interface */
    if (dev->close != RT_NULL)
 8015d42:	687b      	ldr	r3, [r7, #4]
 8015d44:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8015d46:	2b00      	cmp	r3, #0
 8015d48:	d004      	beq.n	8015d54 <rt_device_close+0x54>
    {
        result = dev->close(dev);
 8015d4a:	687b      	ldr	r3, [r7, #4]
 8015d4c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8015d4e:	6878      	ldr	r0, [r7, #4]
 8015d50:	4798      	blx	r3
 8015d52:	60f8      	str	r0, [r7, #12]
    }

    /* set open flag */
    if (result == RT_EOK || result == -RT_ENOSYS)
 8015d54:	68fb      	ldr	r3, [r7, #12]
 8015d56:	2b00      	cmp	r3, #0
 8015d58:	d003      	beq.n	8015d62 <rt_device_close+0x62>
 8015d5a:	68fb      	ldr	r3, [r7, #12]
 8015d5c:	f113 0f06 	cmn.w	r3, #6
 8015d60:	d102      	bne.n	8015d68 <rt_device_close+0x68>
        dev->open_flag = RT_DEVICE_OFLAG_CLOSE;
 8015d62:	687b      	ldr	r3, [r7, #4]
 8015d64:	2200      	movs	r2, #0
 8015d66:	831a      	strh	r2, [r3, #24]

    return result;
 8015d68:	68fb      	ldr	r3, [r7, #12]
}
 8015d6a:	4618      	mov	r0, r3
 8015d6c:	3710      	adds	r7, #16
 8015d6e:	46bd      	mov	sp, r7
 8015d70:	bd80      	pop	{r7, pc}
 8015d72:	bf00      	nop
 8015d74:	08027528 	.word	0x08027528
 8015d78:	08028e38 	.word	0x08028e38

08015d7c <rt_device_read>:
 */
rt_size_t rt_device_read(rt_device_t dev,
                         rt_off_t    pos,
                         void       *buffer,
                         rt_size_t   size)
{
 8015d7c:	b590      	push	{r4, r7, lr}
 8015d7e:	b085      	sub	sp, #20
 8015d80:	af00      	add	r7, sp, #0
 8015d82:	60f8      	str	r0, [r7, #12]
 8015d84:	60b9      	str	r1, [r7, #8]
 8015d86:	607a      	str	r2, [r7, #4]
 8015d88:	603b      	str	r3, [r7, #0]
    RT_ASSERT(dev != RT_NULL);
 8015d8a:	68fb      	ldr	r3, [r7, #12]
 8015d8c:	2b00      	cmp	r3, #0
 8015d8e:	d105      	bne.n	8015d9c <rt_device_read+0x20>
 8015d90:	4812      	ldr	r0, [pc, #72]	; (8015ddc <rt_device_read+0x60>)
 8015d92:	4913      	ldr	r1, [pc, #76]	; (8015de0 <rt_device_read+0x64>)
 8015d94:	f44f 728d 	mov.w	r2, #282	; 0x11a
 8015d98:	f001 fe0a 	bl	80179b0 <rt_assert_handler>

    if (dev->ref_count == 0)
 8015d9c:	68fb      	ldr	r3, [r7, #12]
 8015d9e:	7e9b      	ldrb	r3, [r3, #26]
 8015da0:	2b00      	cmp	r3, #0
 8015da2:	d105      	bne.n	8015db0 <rt_device_read+0x34>
    {
        rt_set_errno(-RT_ERROR);
 8015da4:	f04f 30ff 	mov.w	r0, #4294967295
 8015da8:	f000 ffb0 	bl	8016d0c <rt_set_errno>
        return 0;
 8015dac:	2300      	movs	r3, #0
 8015dae:	e011      	b.n	8015dd4 <rt_device_read+0x58>
    }

    /* call device read interface */
    if (dev->read != RT_NULL)
 8015db0:	68fb      	ldr	r3, [r7, #12]
 8015db2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015db4:	2b00      	cmp	r3, #0
 8015db6:	d008      	beq.n	8015dca <rt_device_read+0x4e>
    {
        return dev->read(dev, pos, buffer, size);
 8015db8:	68fb      	ldr	r3, [r7, #12]
 8015dba:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 8015dbc:	68f8      	ldr	r0, [r7, #12]
 8015dbe:	68b9      	ldr	r1, [r7, #8]
 8015dc0:	687a      	ldr	r2, [r7, #4]
 8015dc2:	683b      	ldr	r3, [r7, #0]
 8015dc4:	47a0      	blx	r4
 8015dc6:	4603      	mov	r3, r0
 8015dc8:	e004      	b.n	8015dd4 <rt_device_read+0x58>
    }

    /* set error code */
    rt_set_errno(-RT_ENOSYS);
 8015dca:	f06f 0005 	mvn.w	r0, #5
 8015dce:	f000 ff9d 	bl	8016d0c <rt_set_errno>

    return 0;
 8015dd2:	2300      	movs	r3, #0
}
 8015dd4:	4618      	mov	r0, r3
 8015dd6:	3714      	adds	r7, #20
 8015dd8:	46bd      	mov	sp, r7
 8015dda:	bd90      	pop	{r4, r7, pc}
 8015ddc:	08027528 	.word	0x08027528
 8015de0:	08028e48 	.word	0x08028e48

08015de4 <rt_device_write>:
 */
rt_size_t rt_device_write(rt_device_t dev,
                          rt_off_t    pos,
                          const void *buffer,
                          rt_size_t   size)
{
 8015de4:	b590      	push	{r4, r7, lr}
 8015de6:	b085      	sub	sp, #20
 8015de8:	af00      	add	r7, sp, #0
 8015dea:	60f8      	str	r0, [r7, #12]
 8015dec:	60b9      	str	r1, [r7, #8]
 8015dee:	607a      	str	r2, [r7, #4]
 8015df0:	603b      	str	r3, [r7, #0]
    RT_ASSERT(dev != RT_NULL);
 8015df2:	68fb      	ldr	r3, [r7, #12]
 8015df4:	2b00      	cmp	r3, #0
 8015df6:	d105      	bne.n	8015e04 <rt_device_write+0x20>
 8015df8:	4812      	ldr	r0, [pc, #72]	; (8015e44 <rt_device_write+0x60>)
 8015dfa:	4913      	ldr	r1, [pc, #76]	; (8015e48 <rt_device_write+0x64>)
 8015dfc:	f44f 72a0 	mov.w	r2, #320	; 0x140
 8015e00:	f001 fdd6 	bl	80179b0 <rt_assert_handler>

    if (dev->ref_count == 0)
 8015e04:	68fb      	ldr	r3, [r7, #12]
 8015e06:	7e9b      	ldrb	r3, [r3, #26]
 8015e08:	2b00      	cmp	r3, #0
 8015e0a:	d105      	bne.n	8015e18 <rt_device_write+0x34>
    {
        rt_set_errno(-RT_ERROR);
 8015e0c:	f04f 30ff 	mov.w	r0, #4294967295
 8015e10:	f000 ff7c 	bl	8016d0c <rt_set_errno>
        return 0;
 8015e14:	2300      	movs	r3, #0
 8015e16:	e011      	b.n	8015e3c <rt_device_write+0x58>
    }

    /* call device write interface */
    if (dev->write != RT_NULL)
 8015e18:	68fb      	ldr	r3, [r7, #12]
 8015e1a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015e1c:	2b00      	cmp	r3, #0
 8015e1e:	d008      	beq.n	8015e32 <rt_device_write+0x4e>
    {
        return dev->write(dev, pos, buffer, size);
 8015e20:	68fb      	ldr	r3, [r7, #12]
 8015e22:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 8015e24:	68f8      	ldr	r0, [r7, #12]
 8015e26:	68b9      	ldr	r1, [r7, #8]
 8015e28:	687a      	ldr	r2, [r7, #4]
 8015e2a:	683b      	ldr	r3, [r7, #0]
 8015e2c:	47a0      	blx	r4
 8015e2e:	4603      	mov	r3, r0
 8015e30:	e004      	b.n	8015e3c <rt_device_write+0x58>
    }

    /* set error code */
    rt_set_errno(-RT_ENOSYS);
 8015e32:	f06f 0005 	mvn.w	r0, #5
 8015e36:	f000 ff69 	bl	8016d0c <rt_set_errno>

    return 0;
 8015e3a:	2300      	movs	r3, #0
}
 8015e3c:	4618      	mov	r0, r3
 8015e3e:	3714      	adds	r7, #20
 8015e40:	46bd      	mov	sp, r7
 8015e42:	bd90      	pop	{r4, r7, pc}
 8015e44:	08027528 	.word	0x08027528
 8015e48:	08028e58 	.word	0x08028e58

08015e4c <rt_device_control>:
 * @param arg the argument of command
 *
 * @return the result
 */
rt_err_t rt_device_control(rt_device_t dev, rt_uint8_t cmd, void *arg)
{
 8015e4c:	b580      	push	{r7, lr}
 8015e4e:	b084      	sub	sp, #16
 8015e50:	af00      	add	r7, sp, #0
 8015e52:	60f8      	str	r0, [r7, #12]
 8015e54:	460b      	mov	r3, r1
 8015e56:	607a      	str	r2, [r7, #4]
 8015e58:	72fb      	strb	r3, [r7, #11]
    RT_ASSERT(dev != RT_NULL);
 8015e5a:	68fb      	ldr	r3, [r7, #12]
 8015e5c:	2b00      	cmp	r3, #0
 8015e5e:	d105      	bne.n	8015e6c <rt_device_control+0x20>
 8015e60:	480b      	ldr	r0, [pc, #44]	; (8015e90 <rt_device_control+0x44>)
 8015e62:	490c      	ldr	r1, [pc, #48]	; (8015e94 <rt_device_control+0x48>)
 8015e64:	f44f 72b0 	mov.w	r2, #352	; 0x160
 8015e68:	f001 fda2 	bl	80179b0 <rt_assert_handler>

    /* call device write interface */
    if (dev->control != RT_NULL)
 8015e6c:	68fb      	ldr	r3, [r7, #12]
 8015e6e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8015e70:	2b00      	cmp	r3, #0
 8015e72:	d008      	beq.n	8015e86 <rt_device_control+0x3a>
    {
        return dev->control(dev, cmd, arg);
 8015e74:	68fb      	ldr	r3, [r7, #12]
 8015e76:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8015e78:	7afa      	ldrb	r2, [r7, #11]
 8015e7a:	68f8      	ldr	r0, [r7, #12]
 8015e7c:	4611      	mov	r1, r2
 8015e7e:	687a      	ldr	r2, [r7, #4]
 8015e80:	4798      	blx	r3
 8015e82:	4603      	mov	r3, r0
 8015e84:	e000      	b.n	8015e88 <rt_device_control+0x3c>
    }

    return RT_EOK;
 8015e86:	2300      	movs	r3, #0
}
 8015e88:	4618      	mov	r0, r3
 8015e8a:	3710      	adds	r7, #16
 8015e8c:	46bd      	mov	sp, r7
 8015e8e:	bd80      	pop	{r7, pc}
 8015e90:	08027528 	.word	0x08027528
 8015e94:	08028e68 	.word	0x08028e68

08015e98 <rt_device_set_rx_indicate>:
 * @return RT_EOK
 */
rt_err_t
rt_device_set_rx_indicate(rt_device_t dev,
                          rt_err_t (*rx_ind)(rt_device_t dev, rt_size_t size))
{
 8015e98:	b580      	push	{r7, lr}
 8015e9a:	b082      	sub	sp, #8
 8015e9c:	af00      	add	r7, sp, #0
 8015e9e:	6078      	str	r0, [r7, #4]
 8015ea0:	6039      	str	r1, [r7, #0]
    RT_ASSERT(dev != RT_NULL);
 8015ea2:	687b      	ldr	r3, [r7, #4]
 8015ea4:	2b00      	cmp	r3, #0
 8015ea6:	d105      	bne.n	8015eb4 <rt_device_set_rx_indicate+0x1c>
 8015ea8:	4806      	ldr	r0, [pc, #24]	; (8015ec4 <rt_device_set_rx_indicate+0x2c>)
 8015eaa:	4907      	ldr	r1, [pc, #28]	; (8015ec8 <rt_device_set_rx_indicate+0x30>)
 8015eac:	f240 1279 	movw	r2, #377	; 0x179
 8015eb0:	f001 fd7e 	bl	80179b0 <rt_assert_handler>

    dev->rx_indicate = rx_ind;
 8015eb4:	687b      	ldr	r3, [r7, #4]
 8015eb6:	683a      	ldr	r2, [r7, #0]
 8015eb8:	61da      	str	r2, [r3, #28]

    return RT_EOK;
 8015eba:	2300      	movs	r3, #0
}
 8015ebc:	4618      	mov	r0, r3
 8015ebe:	3708      	adds	r7, #8
 8015ec0:	46bd      	mov	sp, r7
 8015ec2:	bd80      	pop	{r7, pc}
 8015ec4:	08027528 	.word	0x08027528
 8015ec8:	08028e7c 	.word	0x08028e7c

08015ecc <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 8015ecc:	b480      	push	{r7}
 8015ece:	b083      	sub	sp, #12
 8015ed0:	af00      	add	r7, sp, #0
 8015ed2:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 8015ed4:	687b      	ldr	r3, [r7, #4]
 8015ed6:	681b      	ldr	r3, [r3, #0]
 8015ed8:	687a      	ldr	r2, [r7, #4]
 8015eda:	6852      	ldr	r2, [r2, #4]
 8015edc:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 8015ede:	687b      	ldr	r3, [r7, #4]
 8015ee0:	685b      	ldr	r3, [r3, #4]
 8015ee2:	687a      	ldr	r2, [r7, #4]
 8015ee4:	6812      	ldr	r2, [r2, #0]
 8015ee6:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 8015ee8:	687b      	ldr	r3, [r7, #4]
 8015eea:	687a      	ldr	r2, [r7, #4]
 8015eec:	605a      	str	r2, [r3, #4]
 8015eee:	687b      	ldr	r3, [r7, #4]
 8015ef0:	685a      	ldr	r2, [r3, #4]
 8015ef2:	687b      	ldr	r3, [r7, #4]
 8015ef4:	601a      	str	r2, [r3, #0]
}
 8015ef6:	370c      	adds	r7, #12
 8015ef8:	46bd      	mov	sp, r7
 8015efa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015efe:	4770      	bx	lr

08015f00 <_has_defunct_thread>:
}
#endif

/* Return whether there is defunctional thread to be deleted. */
rt_inline int _has_defunct_thread(void)
{
 8015f00:	b480      	push	{r7}
 8015f02:	b083      	sub	sp, #12
 8015f04:	af00      	add	r7, sp, #0
     * So the compiler has a good reason that the rt_thread_defunct list does
     * not change within rt_thread_idle_excute thus optimize the "while" loop
     * into a "if".
     *
     * So add the volatile qualifier here. */
    const volatile rt_list_t *l = (const volatile rt_list_t*)&rt_thread_defunct;
 8015f06:	4b08      	ldr	r3, [pc, #32]	; (8015f28 <_has_defunct_thread+0x28>)
 8015f08:	607b      	str	r3, [r7, #4]

    return l->next != l;
 8015f0a:	687b      	ldr	r3, [r7, #4]
 8015f0c:	681a      	ldr	r2, [r3, #0]
 8015f0e:	687b      	ldr	r3, [r7, #4]
 8015f10:	429a      	cmp	r2, r3
 8015f12:	bf14      	ite	ne
 8015f14:	2301      	movne	r3, #1
 8015f16:	2300      	moveq	r3, #0
 8015f18:	b2db      	uxtb	r3, r3
}
 8015f1a:	4618      	mov	r0, r3
 8015f1c:	370c      	adds	r7, #12
 8015f1e:	46bd      	mov	sp, r7
 8015f20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015f24:	4770      	bx	lr
 8015f26:	bf00      	nop
 8015f28:	20012b58 	.word	0x20012b58

08015f2c <rt_thread_idle_excute>:
 * @ingroup Thread
 *
 * This function will perform system background job when system idle.
 */
void rt_thread_idle_excute(void)
{
 8015f2c:	b580      	push	{r7, lr}
 8015f2e:	b084      	sub	sp, #16
 8015f30:	af00      	add	r7, sp, #0
    /* Loop until there is no dead thread. So one call to rt_thread_idle_excute
     * will do all the cleanups. */
    while (_has_defunct_thread())
 8015f32:	e045      	b.n	8015fc0 <rt_thread_idle_excute+0x94>
        rt_base_t lock;
        rt_thread_t thread;
#ifdef RT_USING_MODULE
        rt_module_t module = RT_NULL;
#endif
        RT_DEBUG_NOT_IN_INTERRUPT;
 8015f34:	f7ea f948 	bl	80001c8 <rt_hw_interrupt_disable>
 8015f38:	60f8      	str	r0, [r7, #12]
 8015f3a:	f000 fedb 	bl	8016cf4 <rt_interrupt_get_nest>
 8015f3e:	4603      	mov	r3, r0
 8015f40:	2b00      	cmp	r3, #0
 8015f42:	d008      	beq.n	8015f56 <rt_thread_idle_excute+0x2a>
 8015f44:	4822      	ldr	r0, [pc, #136]	; (8015fd0 <rt_thread_idle_excute+0xa4>)
 8015f46:	4923      	ldr	r1, [pc, #140]	; (8015fd4 <rt_thread_idle_excute+0xa8>)
 8015f48:	f001 fcb8 	bl	80178bc <rt_kprintf>
 8015f4c:	4822      	ldr	r0, [pc, #136]	; (8015fd8 <rt_thread_idle_excute+0xac>)
 8015f4e:	4921      	ldr	r1, [pc, #132]	; (8015fd4 <rt_thread_idle_excute+0xa8>)
 8015f50:	225e      	movs	r2, #94	; 0x5e
 8015f52:	f001 fd2d 	bl	80179b0 <rt_assert_handler>
 8015f56:	68f8      	ldr	r0, [r7, #12]
 8015f58:	f7ea f93a 	bl	80001d0 <rt_hw_interrupt_enable>

        /* disable interrupt */
        lock = rt_hw_interrupt_disable();
 8015f5c:	f7ea f934 	bl	80001c8 <rt_hw_interrupt_disable>
 8015f60:	60b8      	str	r0, [r7, #8]

        /* re-check whether list is empty */
        if (_has_defunct_thread())
 8015f62:	f7ff ffcd 	bl	8015f00 <_has_defunct_thread>
 8015f66:	4603      	mov	r3, r0
 8015f68:	2b00      	cmp	r3, #0
 8015f6a:	d01a      	beq.n	8015fa2 <rt_thread_idle_excute+0x76>
        {
            /* get defunct thread */
            thread = rt_list_entry(rt_thread_defunct.next,
 8015f6c:	4b1b      	ldr	r3, [pc, #108]	; (8015fdc <rt_thread_idle_excute+0xb0>)
 8015f6e:	681b      	ldr	r3, [r3, #0]
 8015f70:	3b14      	subs	r3, #20
 8015f72:	607b      	str	r3, [r7, #4]
                /* detach module's main thread */
                module->module_thread = RT_NULL;
            }
#endif
            /* remove defunct thread */
            rt_list_remove(&(thread->tlist));
 8015f74:	687b      	ldr	r3, [r7, #4]
 8015f76:	3314      	adds	r3, #20
 8015f78:	4618      	mov	r0, r3
 8015f7a:	f7ff ffa7 	bl	8015ecc <rt_list_remove>
            /* invoke thread cleanup */
            if (thread->cleanup != RT_NULL)
 8015f7e:	687b      	ldr	r3, [r7, #4]
 8015f80:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8015f82:	2b00      	cmp	r3, #0
 8015f84:	d003      	beq.n	8015f8e <rt_thread_idle_excute+0x62>
                thread->cleanup(thread);
 8015f86:	687b      	ldr	r3, [r7, #4]
 8015f88:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8015f8a:	6878      	ldr	r0, [r7, #4]
 8015f8c:	4798      	blx	r3

            /* if it's a system object, not delete it */
            if (rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE)
 8015f8e:	6878      	ldr	r0, [r7, #4]
 8015f90:	f002 fae2 	bl	8018558 <rt_object_is_systemobject>
 8015f94:	4603      	mov	r3, r0
 8015f96:	2b01      	cmp	r3, #1
 8015f98:	d107      	bne.n	8015faa <rt_thread_idle_excute+0x7e>
            {
                /* enable interrupt */
                rt_hw_interrupt_enable(lock);
 8015f9a:	68b8      	ldr	r0, [r7, #8]
 8015f9c:	f7ea f918 	bl	80001d0 <rt_hw_interrupt_enable>

                return;
 8015fa0:	e013      	b.n	8015fca <rt_thread_idle_excute+0x9e>
            }
        }
        else
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(lock);
 8015fa2:	68b8      	ldr	r0, [r7, #8]
 8015fa4:	f7ea f914 	bl	80001d0 <rt_hw_interrupt_enable>

            /* may the defunct thread list is removed by others, just return */
            return;
 8015fa8:	e00f      	b.n	8015fca <rt_thread_idle_excute+0x9e>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(lock);
 8015faa:	68b8      	ldr	r0, [r7, #8]
 8015fac:	f7ea f910 	bl	80001d0 <rt_hw_interrupt_enable>
        if (thread->flags & RT_OBJECT_FLAG_MODULE)
            rt_module_free((rt_module_t)thread->module_id, thread->stack_addr);
        else
#endif
        /* release thread's stack */
        RT_KERNEL_FREE(thread->stack_addr);
 8015fb0:	687b      	ldr	r3, [r7, #4]
 8015fb2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015fb4:	4618      	mov	r0, r3
 8015fb6:	f002 f839 	bl	801802c <rt_free>
        /* delete thread object */
        rt_object_delete((rt_object_t)thread);
 8015fba:	6878      	ldr	r0, [r7, #4]
 8015fbc:	f002 fa92 	bl	80184e4 <rt_object_delete>
 */
void rt_thread_idle_excute(void)
{
    /* Loop until there is no dead thread. So one call to rt_thread_idle_excute
     * will do all the cleanups. */
    while (_has_defunct_thread())
 8015fc0:	f7ff ff9e 	bl	8015f00 <_has_defunct_thread>
 8015fc4:	4603      	mov	r3, r0
 8015fc6:	2b00      	cmp	r3, #0
 8015fc8:	d1b4      	bne.n	8015f34 <rt_thread_idle_excute+0x8>
            if (module->nref == 0)
                rt_module_destroy(module);
        }
#endif
    }
}
 8015fca:	3710      	adds	r7, #16
 8015fcc:	46bd      	mov	sp, r7
 8015fce:	bd80      	pop	{r7, pc}
 8015fd0:	08027584 	.word	0x08027584
 8015fd4:	08028e98 	.word	0x08028e98
 8015fd8:	080275a8 	.word	0x080275a8
 8015fdc:	20012b58 	.word	0x20012b58

08015fe0 <rt_thread_idle_entry>:

static void rt_thread_idle_entry(void *parameter)
{
 8015fe0:	b580      	push	{r7, lr}
 8015fe2:	b082      	sub	sp, #8
 8015fe4:	af00      	add	r7, sp, #0
 8015fe6:	6078      	str	r0, [r7, #4]
    while (1)
    {
        #ifdef RT_USING_HOOK
        if (rt_thread_idle_hook != RT_NULL)
 8015fe8:	4b04      	ldr	r3, [pc, #16]	; (8015ffc <rt_thread_idle_entry+0x1c>)
 8015fea:	681b      	ldr	r3, [r3, #0]
 8015fec:	2b00      	cmp	r3, #0
 8015fee:	d002      	beq.n	8015ff6 <rt_thread_idle_entry+0x16>
            rt_thread_idle_hook();
 8015ff0:	4b02      	ldr	r3, [pc, #8]	; (8015ffc <rt_thread_idle_entry+0x1c>)
 8015ff2:	681b      	ldr	r3, [r3, #0]
 8015ff4:	4798      	blx	r3
        #endif

        rt_thread_idle_excute();
 8015ff6:	f7ff ff99 	bl	8015f2c <rt_thread_idle_excute>
    }
 8015ffa:	e7f5      	b.n	8015fe8 <rt_thread_idle_entry+0x8>
 8015ffc:	20010ccc 	.word	0x20010ccc

08016000 <rt_thread_idle_init>:
 * This function will initialize idle thread, then start it.
 *
 * @note this function must be invoked when system init.
 */
void rt_thread_idle_init(void)
{
 8016000:	b580      	push	{r7, lr}
 8016002:	b084      	sub	sp, #16
 8016004:	af04      	add	r7, sp, #16
    /* initialize thread */
    rt_thread_init(&idle,
 8016006:	4b0a      	ldr	r3, [pc, #40]	; (8016030 <rt_thread_idle_init+0x30>)
 8016008:	9300      	str	r3, [sp, #0]
 801600a:	f44f 7300 	mov.w	r3, #512	; 0x200
 801600e:	9301      	str	r3, [sp, #4]
 8016010:	231f      	movs	r3, #31
 8016012:	9302      	str	r3, [sp, #8]
 8016014:	2320      	movs	r3, #32
 8016016:	9303      	str	r3, [sp, #12]
 8016018:	4806      	ldr	r0, [pc, #24]	; (8016034 <rt_thread_idle_init+0x34>)
 801601a:	4907      	ldr	r1, [pc, #28]	; (8016038 <rt_thread_idle_init+0x38>)
 801601c:	4a07      	ldr	r2, [pc, #28]	; (801603c <rt_thread_idle_init+0x3c>)
 801601e:	2300      	movs	r3, #0
 8016020:	f002 fda0 	bl	8018b64 <rt_thread_init>
                   sizeof(rt_thread_stack),
                   RT_THREAD_PRIORITY_MAX - 1,
                   32);

    /* startup */
    rt_thread_startup(&idle);
 8016024:	4803      	ldr	r0, [pc, #12]	; (8016034 <rt_thread_idle_init+0x34>)
 8016026:	f002 fddf 	bl	8018be8 <rt_thread_startup>
}
 801602a:	46bd      	mov	sp, r7
 801602c:	bd80      	pop	{r7, pc}
 801602e:	bf00      	nop
 8016030:	20010acc 	.word	0x20010acc
 8016034:	20010a4c 	.word	0x20010a4c
 8016038:	080275ac 	.word	0x080275ac
 801603c:	08015fe1 	.word	0x08015fe1

08016040 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 8016040:	b480      	push	{r7}
 8016042:	b083      	sub	sp, #12
 8016044:	af00      	add	r7, sp, #0
 8016046:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 8016048:	687b      	ldr	r3, [r7, #4]
 801604a:	687a      	ldr	r2, [r7, #4]
 801604c:	605a      	str	r2, [r3, #4]
 801604e:	687b      	ldr	r3, [r7, #4]
 8016050:	685a      	ldr	r2, [r3, #4]
 8016052:	687b      	ldr	r3, [r7, #4]
 8016054:	601a      	str	r2, [r3, #0]
}
 8016056:	370c      	adds	r7, #12
 8016058:	46bd      	mov	sp, r7
 801605a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801605e:	4770      	bx	lr

08016060 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 8016060:	b480      	push	{r7}
 8016062:	b083      	sub	sp, #12
 8016064:	af00      	add	r7, sp, #0
 8016066:	6078      	str	r0, [r7, #4]
 8016068:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 801606a:	687b      	ldr	r3, [r7, #4]
 801606c:	685b      	ldr	r3, [r3, #4]
 801606e:	683a      	ldr	r2, [r7, #0]
 8016070:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 8016072:	687b      	ldr	r3, [r7, #4]
 8016074:	685a      	ldr	r2, [r3, #4]
 8016076:	683b      	ldr	r3, [r7, #0]
 8016078:	605a      	str	r2, [r3, #4]

    l->prev = n;
 801607a:	687b      	ldr	r3, [r7, #4]
 801607c:	683a      	ldr	r2, [r7, #0]
 801607e:	605a      	str	r2, [r3, #4]
    n->next = l;
 8016080:	683b      	ldr	r3, [r7, #0]
 8016082:	687a      	ldr	r2, [r7, #4]
 8016084:	601a      	str	r2, [r3, #0]
}
 8016086:	370c      	adds	r7, #12
 8016088:	46bd      	mov	sp, r7
 801608a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801608e:	4770      	bx	lr

08016090 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 8016090:	b480      	push	{r7}
 8016092:	b083      	sub	sp, #12
 8016094:	af00      	add	r7, sp, #0
 8016096:	6078      	str	r0, [r7, #4]
    return l->next == l;
 8016098:	687b      	ldr	r3, [r7, #4]
 801609a:	681a      	ldr	r2, [r3, #0]
 801609c:	687b      	ldr	r3, [r7, #4]
 801609e:	429a      	cmp	r2, r3
 80160a0:	bf0c      	ite	eq
 80160a2:	2301      	moveq	r3, #1
 80160a4:	2300      	movne	r3, #0
 80160a6:	b2db      	uxtb	r3, r3
}
 80160a8:	4618      	mov	r0, r3
 80160aa:	370c      	adds	r7, #12
 80160ac:	46bd      	mov	sp, r7
 80160ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80160b2:	4770      	bx	lr

080160b4 <rt_ipc_object_init>:
 * @param ipc the IPC object
 *
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_object_init(struct rt_ipc_object *ipc)
{
 80160b4:	b580      	push	{r7, lr}
 80160b6:	b082      	sub	sp, #8
 80160b8:	af00      	add	r7, sp, #0
 80160ba:	6078      	str	r0, [r7, #4]
    /* init ipc object */
    rt_list_init(&(ipc->suspend_thread));
 80160bc:	687b      	ldr	r3, [r7, #4]
 80160be:	3314      	adds	r3, #20
 80160c0:	4618      	mov	r0, r3
 80160c2:	f7ff ffbd 	bl	8016040 <rt_list_init>

    return RT_EOK;
 80160c6:	2300      	movs	r3, #0
}
 80160c8:	4618      	mov	r0, r3
 80160ca:	3708      	adds	r7, #8
 80160cc:	46bd      	mov	sp, r7
 80160ce:	bd80      	pop	{r7, pc}

080160d0 <rt_ipc_list_suspend>:
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_list_suspend(rt_list_t        *list,
                                       struct rt_thread *thread,
                                       rt_uint8_t        flag)
{
 80160d0:	b580      	push	{r7, lr}
 80160d2:	b086      	sub	sp, #24
 80160d4:	af00      	add	r7, sp, #0
 80160d6:	60f8      	str	r0, [r7, #12]
 80160d8:	60b9      	str	r1, [r7, #8]
 80160da:	4613      	mov	r3, r2
 80160dc:	71fb      	strb	r3, [r7, #7]
    /* suspend thread */
    rt_thread_suspend(thread);
 80160de:	68b8      	ldr	r0, [r7, #8]
 80160e0:	f002 fefc 	bl	8018edc <rt_thread_suspend>

    switch (flag)
 80160e4:	79fb      	ldrb	r3, [r7, #7]
 80160e6:	2b00      	cmp	r3, #0
 80160e8:	d002      	beq.n	80160f0 <rt_ipc_list_suspend+0x20>
 80160ea:	2b01      	cmp	r3, #1
 80160ec:	d007      	beq.n	80160fe <rt_ipc_list_suspend+0x2e>
 80160ee:	e032      	b.n	8016156 <rt_ipc_list_suspend+0x86>
    {
    case RT_IPC_FLAG_FIFO:
        rt_list_insert_before(list, &(thread->tlist));
 80160f0:	68bb      	ldr	r3, [r7, #8]
 80160f2:	3314      	adds	r3, #20
 80160f4:	68f8      	ldr	r0, [r7, #12]
 80160f6:	4619      	mov	r1, r3
 80160f8:	f7ff ffb2 	bl	8016060 <rt_list_insert_before>
        break;
 80160fc:	e02b      	b.n	8016156 <rt_ipc_list_suspend+0x86>
        {
            struct rt_list_node *n;
            struct rt_thread *sthread;

            /* find a suitable position */
            for (n = list->next; n != list; n = n->next)
 80160fe:	68fb      	ldr	r3, [r7, #12]
 8016100:	681b      	ldr	r3, [r3, #0]
 8016102:	617b      	str	r3, [r7, #20]
 8016104:	e017      	b.n	8016136 <rt_ipc_list_suspend+0x66>
            {
                sthread = rt_list_entry(n, struct rt_thread, tlist);
 8016106:	697b      	ldr	r3, [r7, #20]
 8016108:	3b14      	subs	r3, #20
 801610a:	613b      	str	r3, [r7, #16]

                /* find out */
                if (thread->current_priority < sthread->current_priority)
 801610c:	68bb      	ldr	r3, [r7, #8]
 801610e:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
 8016112:	693b      	ldr	r3, [r7, #16]
 8016114:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8016118:	429a      	cmp	r2, r3
 801611a:	d209      	bcs.n	8016130 <rt_ipc_list_suspend+0x60>
                {
                    /* insert this thread before the sthread */
                    rt_list_insert_before(&(sthread->tlist), &(thread->tlist));
 801611c:	693b      	ldr	r3, [r7, #16]
 801611e:	f103 0214 	add.w	r2, r3, #20
 8016122:	68bb      	ldr	r3, [r7, #8]
 8016124:	3314      	adds	r3, #20
 8016126:	4610      	mov	r0, r2
 8016128:	4619      	mov	r1, r3
 801612a:	f7ff ff99 	bl	8016060 <rt_list_insert_before>
                    break;
 801612e:	e006      	b.n	801613e <rt_ipc_list_suspend+0x6e>
        {
            struct rt_list_node *n;
            struct rt_thread *sthread;

            /* find a suitable position */
            for (n = list->next; n != list; n = n->next)
 8016130:	697b      	ldr	r3, [r7, #20]
 8016132:	681b      	ldr	r3, [r3, #0]
 8016134:	617b      	str	r3, [r7, #20]
 8016136:	697a      	ldr	r2, [r7, #20]
 8016138:	68fb      	ldr	r3, [r7, #12]
 801613a:	429a      	cmp	r2, r3
 801613c:	d1e3      	bne.n	8016106 <rt_ipc_list_suspend+0x36>

            /*
             * not found a suitable position,
             * append to the end of suspend_thread list
             */
            if (n == list)
 801613e:	697a      	ldr	r2, [r7, #20]
 8016140:	68fb      	ldr	r3, [r7, #12]
 8016142:	429a      	cmp	r2, r3
 8016144:	d106      	bne.n	8016154 <rt_ipc_list_suspend+0x84>
                rt_list_insert_before(list, &(thread->tlist));
 8016146:	68bb      	ldr	r3, [r7, #8]
 8016148:	3314      	adds	r3, #20
 801614a:	68f8      	ldr	r0, [r7, #12]
 801614c:	4619      	mov	r1, r3
 801614e:	f7ff ff87 	bl	8016060 <rt_list_insert_before>
        }
        break;
 8016152:	e7ff      	b.n	8016154 <rt_ipc_list_suspend+0x84>
 8016154:	bf00      	nop
    }

    return RT_EOK;
 8016156:	2300      	movs	r3, #0
}
 8016158:	4618      	mov	r0, r3
 801615a:	3718      	adds	r7, #24
 801615c:	46bd      	mov	sp, r7
 801615e:	bd80      	pop	{r7, pc}

08016160 <rt_ipc_list_resume>:
 * @param list the thread list
 *
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_list_resume(rt_list_t *list)
{
 8016160:	b580      	push	{r7, lr}
 8016162:	b084      	sub	sp, #16
 8016164:	af00      	add	r7, sp, #0
 8016166:	6078      	str	r0, [r7, #4]
    struct rt_thread *thread;

    /* get thread entry */
    thread = rt_list_entry(list->next, struct rt_thread, tlist);
 8016168:	687b      	ldr	r3, [r7, #4]
 801616a:	681b      	ldr	r3, [r3, #0]
 801616c:	3b14      	subs	r3, #20
 801616e:	60fb      	str	r3, [r7, #12]

    RT_DEBUG_LOG(RT_DEBUG_IPC, ("resume thread:%s\n", thread->name));

    /* resume it */
    rt_thread_resume(thread);
 8016170:	68f8      	ldr	r0, [r7, #12]
 8016172:	f002 fee3 	bl	8018f3c <rt_thread_resume>

    return RT_EOK;
 8016176:	2300      	movs	r3, #0
}
 8016178:	4618      	mov	r0, r3
 801617a:	3710      	adds	r7, #16
 801617c:	46bd      	mov	sp, r7
 801617e:	bd80      	pop	{r7, pc}

08016180 <rt_ipc_list_resume_all>:
 * @param list of the threads to resume
 *
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_list_resume_all(rt_list_t *list)
{
 8016180:	b590      	push	{r4, r7, lr}
 8016182:	b085      	sub	sp, #20
 8016184:	af00      	add	r7, sp, #0
 8016186:	6078      	str	r0, [r7, #4]
    struct rt_thread *thread;
    register rt_ubase_t temp;

    /* wakeup all suspend threads */
    while (!rt_list_isempty(list))
 8016188:	e012      	b.n	80161b0 <rt_ipc_list_resume_all+0x30>
    {
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
 801618a:	f7ea f81d 	bl	80001c8 <rt_hw_interrupt_disable>
 801618e:	4603      	mov	r3, r0
 8016190:	461c      	mov	r4, r3

        /* get next suspend thread */
        thread = rt_list_entry(list->next, struct rt_thread, tlist);
 8016192:	687b      	ldr	r3, [r7, #4]
 8016194:	681b      	ldr	r3, [r3, #0]
 8016196:	3b14      	subs	r3, #20
 8016198:	60fb      	str	r3, [r7, #12]
        /* set error code to RT_ERROR */
        thread->error = -RT_ERROR;
 801619a:	68fb      	ldr	r3, [r7, #12]
 801619c:	f04f 32ff 	mov.w	r2, #4294967295
 80161a0:	631a      	str	r2, [r3, #48]	; 0x30
        /*
         * resume thread
         * In rt_thread_resume function, it will remove current thread from
         * suspend list
         */
        rt_thread_resume(thread);
 80161a2:	68f8      	ldr	r0, [r7, #12]
 80161a4:	f002 feca 	bl	8018f3c <rt_thread_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 80161a8:	4623      	mov	r3, r4
 80161aa:	4618      	mov	r0, r3
 80161ac:	f7ea f810 	bl	80001d0 <rt_hw_interrupt_enable>
{
    struct rt_thread *thread;
    register rt_ubase_t temp;

    /* wakeup all suspend threads */
    while (!rt_list_isempty(list))
 80161b0:	6878      	ldr	r0, [r7, #4]
 80161b2:	f7ff ff6d 	bl	8016090 <rt_list_isempty>
 80161b6:	4603      	mov	r3, r0
 80161b8:	2b00      	cmp	r3, #0
 80161ba:	d0e6      	beq.n	801618a <rt_ipc_list_resume_all+0xa>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    }

    return RT_EOK;
 80161bc:	2300      	movs	r3, #0
}
 80161be:	4618      	mov	r0, r3
 80161c0:	3714      	adds	r7, #20
 80161c2:	46bd      	mov	sp, r7
 80161c4:	bd90      	pop	{r4, r7, pc}
 80161c6:	bf00      	nop

080161c8 <rt_sem_init>:
 */
rt_err_t rt_sem_init(rt_sem_t    sem,
                     const char *name,
                     rt_uint32_t value,
                     rt_uint8_t  flag)
{
 80161c8:	b580      	push	{r7, lr}
 80161ca:	b084      	sub	sp, #16
 80161cc:	af00      	add	r7, sp, #0
 80161ce:	60f8      	str	r0, [r7, #12]
 80161d0:	60b9      	str	r1, [r7, #8]
 80161d2:	607a      	str	r2, [r7, #4]
 80161d4:	70fb      	strb	r3, [r7, #3]
    RT_ASSERT(sem != RT_NULL);
 80161d6:	68fb      	ldr	r3, [r7, #12]
 80161d8:	2b00      	cmp	r3, #0
 80161da:	d104      	bne.n	80161e6 <rt_sem_init+0x1e>
 80161dc:	480d      	ldr	r0, [pc, #52]	; (8016214 <rt_sem_init+0x4c>)
 80161de:	490e      	ldr	r1, [pc, #56]	; (8016218 <rt_sem_init+0x50>)
 80161e0:	22d8      	movs	r2, #216	; 0xd8
 80161e2:	f001 fbe5 	bl	80179b0 <rt_assert_handler>

    /* init object */
    rt_object_init(&(sem->parent.parent), RT_Object_Class_Semaphore, name);
 80161e6:	68fb      	ldr	r3, [r7, #12]
 80161e8:	4618      	mov	r0, r3
 80161ea:	2101      	movs	r1, #1
 80161ec:	68ba      	ldr	r2, [r7, #8]
 80161ee:	f002 f8bf 	bl	8018370 <rt_object_init>

    /* init ipc object */
    rt_ipc_object_init(&(sem->parent));
 80161f2:	68fb      	ldr	r3, [r7, #12]
 80161f4:	4618      	mov	r0, r3
 80161f6:	f7ff ff5d 	bl	80160b4 <rt_ipc_object_init>

    /* set init value */
    sem->value = value;
 80161fa:	687b      	ldr	r3, [r7, #4]
 80161fc:	b29a      	uxth	r2, r3
 80161fe:	68fb      	ldr	r3, [r7, #12]
 8016200:	839a      	strh	r2, [r3, #28]

    /* set parent */
    sem->parent.parent.flag = flag;
 8016202:	68fb      	ldr	r3, [r7, #12]
 8016204:	78fa      	ldrb	r2, [r7, #3]
 8016206:	725a      	strb	r2, [r3, #9]

    return RT_EOK;
 8016208:	2300      	movs	r3, #0
}
 801620a:	4618      	mov	r0, r3
 801620c:	3710      	adds	r7, #16
 801620e:	46bd      	mov	sp, r7
 8016210:	bd80      	pop	{r7, pc}
 8016212:	bf00      	nop
 8016214:	080275b4 	.word	0x080275b4
 8016218:	08028eb0 	.word	0x08028eb0

0801621c <rt_sem_create>:
 * @return the created semaphore, RT_NULL on error happen
 *
 * @see rt_sem_init
 */
rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag)
{
 801621c:	b580      	push	{r7, lr}
 801621e:	b086      	sub	sp, #24
 8016220:	af00      	add	r7, sp, #0
 8016222:	60f8      	str	r0, [r7, #12]
 8016224:	60b9      	str	r1, [r7, #8]
 8016226:	4613      	mov	r3, r2
 8016228:	71fb      	strb	r3, [r7, #7]
    rt_sem_t sem;

    RT_DEBUG_NOT_IN_INTERRUPT;
 801622a:	f7e9 ffcd 	bl	80001c8 <rt_hw_interrupt_disable>
 801622e:	6178      	str	r0, [r7, #20]
 8016230:	f000 fd60 	bl	8016cf4 <rt_interrupt_get_nest>
 8016234:	4603      	mov	r3, r0
 8016236:	2b00      	cmp	r3, #0
 8016238:	d009      	beq.n	801624e <rt_sem_create+0x32>
 801623a:	4813      	ldr	r0, [pc, #76]	; (8016288 <rt_sem_create+0x6c>)
 801623c:	4913      	ldr	r1, [pc, #76]	; (801628c <rt_sem_create+0x70>)
 801623e:	f001 fb3d 	bl	80178bc <rt_kprintf>
 8016242:	4813      	ldr	r0, [pc, #76]	; (8016290 <rt_sem_create+0x74>)
 8016244:	4911      	ldr	r1, [pc, #68]	; (801628c <rt_sem_create+0x70>)
 8016246:	f240 1211 	movw	r2, #273	; 0x111
 801624a:	f001 fbb1 	bl	80179b0 <rt_assert_handler>
 801624e:	6978      	ldr	r0, [r7, #20]
 8016250:	f7e9 ffbe 	bl	80001d0 <rt_hw_interrupt_enable>

    /* allocate object */
    sem = (rt_sem_t)rt_object_allocate(RT_Object_Class_Semaphore, name);
 8016254:	2001      	movs	r0, #1
 8016256:	68f9      	ldr	r1, [r7, #12]
 8016258:	f002 f8e8 	bl	801842c <rt_object_allocate>
 801625c:	6138      	str	r0, [r7, #16]
    if (sem == RT_NULL)
 801625e:	693b      	ldr	r3, [r7, #16]
 8016260:	2b00      	cmp	r3, #0
 8016262:	d101      	bne.n	8016268 <rt_sem_create+0x4c>
        return sem;
 8016264:	693b      	ldr	r3, [r7, #16]
 8016266:	e00b      	b.n	8016280 <rt_sem_create+0x64>

    /* init ipc object */
    rt_ipc_object_init(&(sem->parent));
 8016268:	693b      	ldr	r3, [r7, #16]
 801626a:	4618      	mov	r0, r3
 801626c:	f7ff ff22 	bl	80160b4 <rt_ipc_object_init>

    /* set init value */
    sem->value = value;
 8016270:	68bb      	ldr	r3, [r7, #8]
 8016272:	b29a      	uxth	r2, r3
 8016274:	693b      	ldr	r3, [r7, #16]
 8016276:	839a      	strh	r2, [r3, #28]

    /* set parent */
    sem->parent.parent.flag = flag;
 8016278:	693b      	ldr	r3, [r7, #16]
 801627a:	79fa      	ldrb	r2, [r7, #7]
 801627c:	725a      	strb	r2, [r3, #9]

    return sem;
 801627e:	693b      	ldr	r3, [r7, #16]
}
 8016280:	4618      	mov	r0, r3
 8016282:	3718      	adds	r7, #24
 8016284:	46bd      	mov	sp, r7
 8016286:	bd80      	pop	{r7, pc}
 8016288:	080275c4 	.word	0x080275c4
 801628c:	08028ebc 	.word	0x08028ebc
 8016290:	080275e8 	.word	0x080275e8

08016294 <rt_sem_take>:
 * @param time the waiting time
 *
 * @return the error code
 */
rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time)
{
 8016294:	b590      	push	{r4, r7, lr}
 8016296:	b087      	sub	sp, #28
 8016298:	af00      	add	r7, sp, #0
 801629a:	6078      	str	r0, [r7, #4]
 801629c:	6039      	str	r1, [r7, #0]
    register rt_base_t temp;
    struct rt_thread *thread;

    RT_ASSERT(sem != RT_NULL);
 801629e:	687b      	ldr	r3, [r7, #4]
 80162a0:	2b00      	cmp	r3, #0
 80162a2:	d105      	bne.n	80162b0 <rt_sem_take+0x1c>
 80162a4:	4846      	ldr	r0, [pc, #280]	; (80163c0 <rt_sem_take+0x12c>)
 80162a6:	4947      	ldr	r1, [pc, #284]	; (80163c4 <rt_sem_take+0x130>)
 80162a8:	f240 124d 	movw	r2, #333	; 0x14d
 80162ac:	f001 fb80 	bl	80179b0 <rt_assert_handler>

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(sem->parent.parent)));
 80162b0:	4b45      	ldr	r3, [pc, #276]	; (80163c8 <rt_sem_take+0x134>)
 80162b2:	681b      	ldr	r3, [r3, #0]
 80162b4:	2b00      	cmp	r3, #0
 80162b6:	d004      	beq.n	80162c2 <rt_sem_take+0x2e>
 80162b8:	4b43      	ldr	r3, [pc, #268]	; (80163c8 <rt_sem_take+0x134>)
 80162ba:	681b      	ldr	r3, [r3, #0]
 80162bc:	687a      	ldr	r2, [r7, #4]
 80162be:	4610      	mov	r0, r2
 80162c0:	4798      	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 80162c2:	f7e9 ff81 	bl	80001c8 <rt_hw_interrupt_disable>
 80162c6:	4604      	mov	r4, r0
    RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s take sem:%s, which value is: %d\n",
                                rt_thread_self()->name,
                                ((struct rt_object *)sem)->name,
                                sem->value));

    if (sem->value > 0)
 80162c8:	687b      	ldr	r3, [r7, #4]
 80162ca:	8b9b      	ldrh	r3, [r3, #28]
 80162cc:	2b00      	cmp	r3, #0
 80162ce:	d009      	beq.n	80162e4 <rt_sem_take+0x50>
    {
        /* semaphore is available */
        sem->value --;
 80162d0:	687b      	ldr	r3, [r7, #4]
 80162d2:	8b9b      	ldrh	r3, [r3, #28]
 80162d4:	3b01      	subs	r3, #1
 80162d6:	b29a      	uxth	r2, r3
 80162d8:	687b      	ldr	r3, [r7, #4]
 80162da:	839a      	strh	r2, [r3, #28]

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 80162dc:	4620      	mov	r0, r4
 80162de:	f7e9 ff77 	bl	80001d0 <rt_hw_interrupt_enable>
 80162e2:	e05f      	b.n	80163a4 <rt_sem_take+0x110>
    }
    else
    {
        /* no waiting, return with timeout */
        if (time == 0)
 80162e4:	683b      	ldr	r3, [r7, #0]
 80162e6:	2b00      	cmp	r3, #0
 80162e8:	d105      	bne.n	80162f6 <rt_sem_take+0x62>
        {
            rt_hw_interrupt_enable(temp);
 80162ea:	4620      	mov	r0, r4
 80162ec:	f7e9 ff70 	bl	80001d0 <rt_hw_interrupt_enable>

            return -RT_ETIMEOUT;
 80162f0:	f06f 0301 	mvn.w	r3, #1
 80162f4:	e060      	b.n	80163b8 <rt_sem_take+0x124>
        }
        else
        {
            /* current context checking */
            RT_DEBUG_IN_THREAD_CONTEXT;
 80162f6:	f7e9 ff67 	bl	80001c8 <rt_hw_interrupt_disable>
 80162fa:	6178      	str	r0, [r7, #20]
 80162fc:	f002 fc68 	bl	8018bd0 <rt_thread_self>
 8016300:	4603      	mov	r3, r0
 8016302:	2b00      	cmp	r3, #0
 8016304:	d109      	bne.n	801631a <rt_sem_take+0x86>
 8016306:	4831      	ldr	r0, [pc, #196]	; (80163cc <rt_sem_take+0x138>)
 8016308:	492e      	ldr	r1, [pc, #184]	; (80163c4 <rt_sem_take+0x130>)
 801630a:	f001 fad7 	bl	80178bc <rt_kprintf>
 801630e:	4830      	ldr	r0, [pc, #192]	; (80163d0 <rt_sem_take+0x13c>)
 8016310:	492c      	ldr	r1, [pc, #176]	; (80163c4 <rt_sem_take+0x130>)
 8016312:	f240 126d 	movw	r2, #365	; 0x16d
 8016316:	f001 fb4b 	bl	80179b0 <rt_assert_handler>
 801631a:	f7e9 ff55 	bl	80001c8 <rt_hw_interrupt_disable>
 801631e:	6138      	str	r0, [r7, #16]
 8016320:	f000 fce8 	bl	8016cf4 <rt_interrupt_get_nest>
 8016324:	4603      	mov	r3, r0
 8016326:	2b00      	cmp	r3, #0
 8016328:	d009      	beq.n	801633e <rt_sem_take+0xaa>
 801632a:	482a      	ldr	r0, [pc, #168]	; (80163d4 <rt_sem_take+0x140>)
 801632c:	4925      	ldr	r1, [pc, #148]	; (80163c4 <rt_sem_take+0x130>)
 801632e:	f001 fac5 	bl	80178bc <rt_kprintf>
 8016332:	4827      	ldr	r0, [pc, #156]	; (80163d0 <rt_sem_take+0x13c>)
 8016334:	4923      	ldr	r1, [pc, #140]	; (80163c4 <rt_sem_take+0x130>)
 8016336:	f240 126d 	movw	r2, #365	; 0x16d
 801633a:	f001 fb39 	bl	80179b0 <rt_assert_handler>
 801633e:	6938      	ldr	r0, [r7, #16]
 8016340:	f7e9 ff46 	bl	80001d0 <rt_hw_interrupt_enable>
 8016344:	6978      	ldr	r0, [r7, #20]
 8016346:	f7e9 ff43 	bl	80001d0 <rt_hw_interrupt_enable>

            /* semaphore is unavailable, push to suspend list */
            /* get current thread */
            thread = rt_thread_self();
 801634a:	f002 fc41 	bl	8018bd0 <rt_thread_self>
 801634e:	60f8      	str	r0, [r7, #12]

            /* reset thread error number */
            thread->error = RT_EOK;
 8016350:	68fb      	ldr	r3, [r7, #12]
 8016352:	2200      	movs	r2, #0
 8016354:	631a      	str	r2, [r3, #48]	; 0x30

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("sem take: suspend thread - %s\n",
                                        thread->name));

            /* suspend thread */
            rt_ipc_list_suspend(&(sem->parent.suspend_thread),
 8016356:	687b      	ldr	r3, [r7, #4]
 8016358:	f103 0214 	add.w	r2, r3, #20
 801635c:	687b      	ldr	r3, [r7, #4]
 801635e:	7a5b      	ldrb	r3, [r3, #9]
 8016360:	4610      	mov	r0, r2
 8016362:	68f9      	ldr	r1, [r7, #12]
 8016364:	461a      	mov	r2, r3
 8016366:	f7ff feb3 	bl	80160d0 <rt_ipc_list_suspend>
                                thread,
                                sem->parent.parent.flag);

            /* has waiting time, start thread timer */
            if (time > 0)
 801636a:	683b      	ldr	r3, [r7, #0]
 801636c:	2b00      	cmp	r3, #0
 801636e:	dd0d      	ble.n	801638c <rt_sem_take+0xf8>
            {
                RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
                                            thread->name));

                /* reset the timeout of thread timer and start it */
                rt_timer_control(&(thread->thread_timer),
 8016370:	68fb      	ldr	r3, [r7, #12]
 8016372:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 8016376:	463b      	mov	r3, r7
 8016378:	4610      	mov	r0, r2
 801637a:	2100      	movs	r1, #0
 801637c:	461a      	mov	r2, r3
 801637e:	f003 f8a7 	bl	80194d0 <rt_timer_control>
                                 RT_TIMER_CTRL_SET_TIME,
                                 &time);
                rt_timer_start(&(thread->thread_timer));
 8016382:	68fb      	ldr	r3, [r7, #12]
 8016384:	334c      	adds	r3, #76	; 0x4c
 8016386:	4618      	mov	r0, r3
 8016388:	f002 ff5c 	bl	8019244 <rt_timer_start>
            }

            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
 801638c:	4620      	mov	r0, r4
 801638e:	f7e9 ff1f 	bl	80001d0 <rt_hw_interrupt_enable>

            /* do schedule */
            rt_schedule();
 8016392:	f002 f9e1 	bl	8018758 <rt_schedule>

            if (thread->error != RT_EOK)
 8016396:	68fb      	ldr	r3, [r7, #12]
 8016398:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801639a:	2b00      	cmp	r3, #0
 801639c:	d002      	beq.n	80163a4 <rt_sem_take+0x110>
            {
                return thread->error;
 801639e:	68fb      	ldr	r3, [r7, #12]
 80163a0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80163a2:	e009      	b.n	80163b8 <rt_sem_take+0x124>
            }
        }
    }

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(sem->parent.parent)));
 80163a4:	4b0c      	ldr	r3, [pc, #48]	; (80163d8 <rt_sem_take+0x144>)
 80163a6:	681b      	ldr	r3, [r3, #0]
 80163a8:	2b00      	cmp	r3, #0
 80163aa:	d004      	beq.n	80163b6 <rt_sem_take+0x122>
 80163ac:	4b0a      	ldr	r3, [pc, #40]	; (80163d8 <rt_sem_take+0x144>)
 80163ae:	681b      	ldr	r3, [r3, #0]
 80163b0:	687a      	ldr	r2, [r7, #4]
 80163b2:	4610      	mov	r0, r2
 80163b4:	4798      	blx	r3

    return RT_EOK;
 80163b6:	2300      	movs	r3, #0
}
 80163b8:	4618      	mov	r0, r3
 80163ba:	371c      	adds	r7, #28
 80163bc:	46bd      	mov	sp, r7
 80163be:	bd90      	pop	{r4, r7, pc}
 80163c0:	080275b4 	.word	0x080275b4
 80163c4:	08028ecc 	.word	0x08028ecc
 80163c8:	20012a48 	.word	0x20012a48
 80163cc:	080275ec 	.word	0x080275ec
 80163d0:	080275e8 	.word	0x080275e8
 80163d4:	080275c4 	.word	0x080275c4
 80163d8:	20012a44 	.word	0x20012a44

080163dc <rt_sem_release>:
 * @param sem the semaphore object
 *
 * @return the error code
 */
rt_err_t rt_sem_release(rt_sem_t sem)
{
 80163dc:	b5b0      	push	{r4, r5, r7, lr}
 80163de:	b082      	sub	sp, #8
 80163e0:	af00      	add	r7, sp, #0
 80163e2:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;
    register rt_bool_t need_schedule;

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(sem->parent.parent)));
 80163e4:	4b16      	ldr	r3, [pc, #88]	; (8016440 <rt_sem_release+0x64>)
 80163e6:	681b      	ldr	r3, [r3, #0]
 80163e8:	2b00      	cmp	r3, #0
 80163ea:	d004      	beq.n	80163f6 <rt_sem_release+0x1a>
 80163ec:	4b14      	ldr	r3, [pc, #80]	; (8016440 <rt_sem_release+0x64>)
 80163ee:	681b      	ldr	r3, [r3, #0]
 80163f0:	687a      	ldr	r2, [r7, #4]
 80163f2:	4610      	mov	r0, r2
 80163f4:	4798      	blx	r3

    need_schedule = RT_FALSE;
 80163f6:	2400      	movs	r4, #0

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 80163f8:	f7e9 fee6 	bl	80001c8 <rt_hw_interrupt_disable>
 80163fc:	4605      	mov	r5, r0
    RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s releases sem:%s, which value is: %d\n",
                                rt_thread_self()->name,
                                ((struct rt_object *)sem)->name,
                                sem->value));

    if (!rt_list_isempty(&sem->parent.suspend_thread))
 80163fe:	687b      	ldr	r3, [r7, #4]
 8016400:	3314      	adds	r3, #20
 8016402:	4618      	mov	r0, r3
 8016404:	f7ff fe44 	bl	8016090 <rt_list_isempty>
 8016408:	4603      	mov	r3, r0
 801640a:	2b00      	cmp	r3, #0
 801640c:	d106      	bne.n	801641c <rt_sem_release+0x40>
    {
        /* resume the suspended thread */
        rt_ipc_list_resume(&(sem->parent.suspend_thread));
 801640e:	687b      	ldr	r3, [r7, #4]
 8016410:	3314      	adds	r3, #20
 8016412:	4618      	mov	r0, r3
 8016414:	f7ff fea4 	bl	8016160 <rt_ipc_list_resume>
        need_schedule = RT_TRUE;
 8016418:	2401      	movs	r4, #1
 801641a:	e005      	b.n	8016428 <rt_sem_release+0x4c>
    }
    else
        sem->value ++; /* increase value */
 801641c:	687b      	ldr	r3, [r7, #4]
 801641e:	8b9b      	ldrh	r3, [r3, #28]
 8016420:	3301      	adds	r3, #1
 8016422:	b29a      	uxth	r2, r3
 8016424:	687b      	ldr	r3, [r7, #4]
 8016426:	839a      	strh	r2, [r3, #28]

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8016428:	4628      	mov	r0, r5
 801642a:	f7e9 fed1 	bl	80001d0 <rt_hw_interrupt_enable>

    /* resume a thread, re-schedule */
    if (need_schedule == RT_TRUE)
 801642e:	2c01      	cmp	r4, #1
 8016430:	d101      	bne.n	8016436 <rt_sem_release+0x5a>
        rt_schedule();
 8016432:	f002 f991 	bl	8018758 <rt_schedule>

    return RT_EOK;
 8016436:	2300      	movs	r3, #0
}
 8016438:	4618      	mov	r0, r3
 801643a:	3708      	adds	r7, #8
 801643c:	46bd      	mov	sp, r7
 801643e:	bdb0      	pop	{r4, r5, r7, pc}
 8016440:	20012a40 	.word	0x20012a40

08016444 <rt_mutex_init>:
 * @param flag the flag of mutex
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag)
{
 8016444:	b580      	push	{r7, lr}
 8016446:	b084      	sub	sp, #16
 8016448:	af00      	add	r7, sp, #0
 801644a:	60f8      	str	r0, [r7, #12]
 801644c:	60b9      	str	r1, [r7, #8]
 801644e:	4613      	mov	r3, r2
 8016450:	71fb      	strb	r3, [r7, #7]
    RT_ASSERT(mutex != RT_NULL);
 8016452:	68fb      	ldr	r3, [r7, #12]
 8016454:	2b00      	cmp	r3, #0
 8016456:	d105      	bne.n	8016464 <rt_mutex_init+0x20>
 8016458:	4811      	ldr	r0, [pc, #68]	; (80164a0 <rt_mutex_init+0x5c>)
 801645a:	4912      	ldr	r1, [pc, #72]	; (80164a4 <rt_mutex_init+0x60>)
 801645c:	f240 220f 	movw	r2, #527	; 0x20f
 8016460:	f001 faa6 	bl	80179b0 <rt_assert_handler>

    /* init object */
    rt_object_init(&(mutex->parent.parent), RT_Object_Class_Mutex, name);
 8016464:	68fb      	ldr	r3, [r7, #12]
 8016466:	4618      	mov	r0, r3
 8016468:	2102      	movs	r1, #2
 801646a:	68ba      	ldr	r2, [r7, #8]
 801646c:	f001 ff80 	bl	8018370 <rt_object_init>

    /* init ipc object */
    rt_ipc_object_init(&(mutex->parent));
 8016470:	68fb      	ldr	r3, [r7, #12]
 8016472:	4618      	mov	r0, r3
 8016474:	f7ff fe1e 	bl	80160b4 <rt_ipc_object_init>

    mutex->value = 1;
 8016478:	68fb      	ldr	r3, [r7, #12]
 801647a:	2201      	movs	r2, #1
 801647c:	839a      	strh	r2, [r3, #28]
    mutex->owner = RT_NULL;
 801647e:	68fb      	ldr	r3, [r7, #12]
 8016480:	2200      	movs	r2, #0
 8016482:	621a      	str	r2, [r3, #32]
    mutex->original_priority = 0xFF;
 8016484:	68fb      	ldr	r3, [r7, #12]
 8016486:	22ff      	movs	r2, #255	; 0xff
 8016488:	779a      	strb	r2, [r3, #30]
    mutex->hold  = 0;
 801648a:	68fb      	ldr	r3, [r7, #12]
 801648c:	2200      	movs	r2, #0
 801648e:	77da      	strb	r2, [r3, #31]

    /* set flag */
    mutex->parent.parent.flag = flag;
 8016490:	68fb      	ldr	r3, [r7, #12]
 8016492:	79fa      	ldrb	r2, [r7, #7]
 8016494:	725a      	strb	r2, [r3, #9]

    return RT_EOK;
 8016496:	2300      	movs	r3, #0
}
 8016498:	4618      	mov	r0, r3
 801649a:	3710      	adds	r7, #16
 801649c:	46bd      	mov	sp, r7
 801649e:	bd80      	pop	{r7, pc}
 80164a0:	08027624 	.word	0x08027624
 80164a4:	08028ed8 	.word	0x08028ed8

080164a8 <rt_mutex_take>:
 * @param time the waiting time
 *
 * @return the error code
 */
rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time)
{
 80164a8:	b590      	push	{r4, r7, lr}
 80164aa:	b087      	sub	sp, #28
 80164ac:	af00      	add	r7, sp, #0
 80164ae:	6078      	str	r0, [r7, #4]
 80164b0:	6039      	str	r1, [r7, #0]
    register rt_base_t temp;
    struct rt_thread *thread;

    /* this function must not be used in interrupt even if time = 0 */
    RT_DEBUG_IN_THREAD_CONTEXT;
 80164b2:	f7e9 fe89 	bl	80001c8 <rt_hw_interrupt_disable>
 80164b6:	6178      	str	r0, [r7, #20]
 80164b8:	f002 fb8a 	bl	8018bd0 <rt_thread_self>
 80164bc:	4603      	mov	r3, r0
 80164be:	2b00      	cmp	r3, #0
 80164c0:	d109      	bne.n	80164d6 <rt_mutex_take+0x2e>
 80164c2:	485e      	ldr	r0, [pc, #376]	; (801663c <rt_mutex_take+0x194>)
 80164c4:	495e      	ldr	r1, [pc, #376]	; (8016640 <rt_mutex_take+0x198>)
 80164c6:	f001 f9f9 	bl	80178bc <rt_kprintf>
 80164ca:	485e      	ldr	r0, [pc, #376]	; (8016644 <rt_mutex_take+0x19c>)
 80164cc:	495c      	ldr	r1, [pc, #368]	; (8016640 <rt_mutex_take+0x198>)
 80164ce:	f44f 7222 	mov.w	r2, #648	; 0x288
 80164d2:	f001 fa6d 	bl	80179b0 <rt_assert_handler>
 80164d6:	f7e9 fe77 	bl	80001c8 <rt_hw_interrupt_disable>
 80164da:	6138      	str	r0, [r7, #16]
 80164dc:	f000 fc0a 	bl	8016cf4 <rt_interrupt_get_nest>
 80164e0:	4603      	mov	r3, r0
 80164e2:	2b00      	cmp	r3, #0
 80164e4:	d009      	beq.n	80164fa <rt_mutex_take+0x52>
 80164e6:	4858      	ldr	r0, [pc, #352]	; (8016648 <rt_mutex_take+0x1a0>)
 80164e8:	4955      	ldr	r1, [pc, #340]	; (8016640 <rt_mutex_take+0x198>)
 80164ea:	f001 f9e7 	bl	80178bc <rt_kprintf>
 80164ee:	4855      	ldr	r0, [pc, #340]	; (8016644 <rt_mutex_take+0x19c>)
 80164f0:	4953      	ldr	r1, [pc, #332]	; (8016640 <rt_mutex_take+0x198>)
 80164f2:	f44f 7222 	mov.w	r2, #648	; 0x288
 80164f6:	f001 fa5b 	bl	80179b0 <rt_assert_handler>
 80164fa:	6938      	ldr	r0, [r7, #16]
 80164fc:	f7e9 fe68 	bl	80001d0 <rt_hw_interrupt_enable>
 8016500:	6978      	ldr	r0, [r7, #20]
 8016502:	f7e9 fe65 	bl	80001d0 <rt_hw_interrupt_enable>

    RT_ASSERT(mutex != RT_NULL);
 8016506:	687b      	ldr	r3, [r7, #4]
 8016508:	2b00      	cmp	r3, #0
 801650a:	d105      	bne.n	8016518 <rt_mutex_take+0x70>
 801650c:	484f      	ldr	r0, [pc, #316]	; (801664c <rt_mutex_take+0x1a4>)
 801650e:	494c      	ldr	r1, [pc, #304]	; (8016640 <rt_mutex_take+0x198>)
 8016510:	f240 228a 	movw	r2, #650	; 0x28a
 8016514:	f001 fa4c 	bl	80179b0 <rt_assert_handler>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8016518:	f7e9 fe56 	bl	80001c8 <rt_hw_interrupt_disable>
 801651c:	4604      	mov	r4, r0

    /* get current thread */
    thread = rt_thread_self();
 801651e:	f002 fb57 	bl	8018bd0 <rt_thread_self>
 8016522:	60f8      	str	r0, [r7, #12]

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mutex->parent.parent)));
 8016524:	4b4a      	ldr	r3, [pc, #296]	; (8016650 <rt_mutex_take+0x1a8>)
 8016526:	681b      	ldr	r3, [r3, #0]
 8016528:	2b00      	cmp	r3, #0
 801652a:	d004      	beq.n	8016536 <rt_mutex_take+0x8e>
 801652c:	4b48      	ldr	r3, [pc, #288]	; (8016650 <rt_mutex_take+0x1a8>)
 801652e:	681b      	ldr	r3, [r3, #0]
 8016530:	687a      	ldr	r2, [r7, #4]
 8016532:	4610      	mov	r0, r2
 8016534:	4798      	blx	r3
    RT_DEBUG_LOG(RT_DEBUG_IPC,
                 ("mutex_take: current thread %s, mutex value: %d, hold: %d\n",
                  thread->name, mutex->value, mutex->hold));

    /* reset thread error */
    thread->error = RT_EOK;
 8016536:	68fb      	ldr	r3, [r7, #12]
 8016538:	2200      	movs	r2, #0
 801653a:	631a      	str	r2, [r3, #48]	; 0x30

    if (mutex->owner == thread)
 801653c:	687b      	ldr	r3, [r7, #4]
 801653e:	6a1a      	ldr	r2, [r3, #32]
 8016540:	68fb      	ldr	r3, [r7, #12]
 8016542:	429a      	cmp	r2, r3
 8016544:	d106      	bne.n	8016554 <rt_mutex_take+0xac>
    {
        /* it's the same thread */
        mutex->hold ++;
 8016546:	687b      	ldr	r3, [r7, #4]
 8016548:	7fdb      	ldrb	r3, [r3, #31]
 801654a:	3301      	adds	r3, #1
 801654c:	b2da      	uxtb	r2, r3
 801654e:	687b      	ldr	r3, [r7, #4]
 8016550:	77da      	strb	r2, [r3, #31]
 8016552:	e061      	b.n	8016618 <rt_mutex_take+0x170>
    else
    {
        /* The value of mutex is 1 in initial status. Therefore, if the
         * value is great than 0, it indicates the mutex is avaible.
         */
        if (mutex->value > 0)
 8016554:	687b      	ldr	r3, [r7, #4]
 8016556:	8b9b      	ldrh	r3, [r3, #28]
 8016558:	2b00      	cmp	r3, #0
 801655a:	d014      	beq.n	8016586 <rt_mutex_take+0xde>
        {
            /* mutex is available */
            mutex->value --;
 801655c:	687b      	ldr	r3, [r7, #4]
 801655e:	8b9b      	ldrh	r3, [r3, #28]
 8016560:	3b01      	subs	r3, #1
 8016562:	b29a      	uxth	r2, r3
 8016564:	687b      	ldr	r3, [r7, #4]
 8016566:	839a      	strh	r2, [r3, #28]

            /* set mutex owner and original priority */
            mutex->owner             = thread;
 8016568:	687b      	ldr	r3, [r7, #4]
 801656a:	68fa      	ldr	r2, [r7, #12]
 801656c:	621a      	str	r2, [r3, #32]
            mutex->original_priority = thread->current_priority;
 801656e:	68fb      	ldr	r3, [r7, #12]
 8016570:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
 8016574:	687b      	ldr	r3, [r7, #4]
 8016576:	779a      	strb	r2, [r3, #30]
            mutex->hold ++;
 8016578:	687b      	ldr	r3, [r7, #4]
 801657a:	7fdb      	ldrb	r3, [r3, #31]
 801657c:	3301      	adds	r3, #1
 801657e:	b2da      	uxtb	r2, r3
 8016580:	687b      	ldr	r3, [r7, #4]
 8016582:	77da      	strb	r2, [r3, #31]
 8016584:	e048      	b.n	8016618 <rt_mutex_take+0x170>
        }
        else
        {
            /* no waiting, return with timeout */
            if (time == 0)
 8016586:	683b      	ldr	r3, [r7, #0]
 8016588:	2b00      	cmp	r3, #0
 801658a:	d109      	bne.n	80165a0 <rt_mutex_take+0xf8>
            {
                /* set error as timeout */
                thread->error = -RT_ETIMEOUT;
 801658c:	68fb      	ldr	r3, [r7, #12]
 801658e:	f06f 0201 	mvn.w	r2, #1
 8016592:	631a      	str	r2, [r3, #48]	; 0x30

                /* enable interrupt */
                rt_hw_interrupt_enable(temp);
 8016594:	4620      	mov	r0, r4
 8016596:	f7e9 fe1b 	bl	80001d0 <rt_hw_interrupt_enable>

                return -RT_ETIMEOUT;
 801659a:	f06f 0301 	mvn.w	r3, #1
 801659e:	e048      	b.n	8016632 <rt_mutex_take+0x18a>
                /* mutex is unavailable, push to suspend list */
                RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_take: suspend thread: %s\n",
                                            thread->name));

                /* change the owner thread priority of mutex */
                if (thread->current_priority < mutex->owner->current_priority)
 80165a0:	68fb      	ldr	r3, [r7, #12]
 80165a2:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
 80165a6:	687b      	ldr	r3, [r7, #4]
 80165a8:	6a1b      	ldr	r3, [r3, #32]
 80165aa:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 80165ae:	429a      	cmp	r2, r3
 80165b0:	d208      	bcs.n	80165c4 <rt_mutex_take+0x11c>
                {
                    /* change the owner thread priority */
                    rt_thread_control(mutex->owner,
 80165b2:	687b      	ldr	r3, [r7, #4]
 80165b4:	6a1a      	ldr	r2, [r3, #32]
                                      RT_THREAD_CTRL_CHANGE_PRIORITY,
                                      &thread->current_priority);
 80165b6:	68fb      	ldr	r3, [r7, #12]
 80165b8:	3335      	adds	r3, #53	; 0x35

                /* change the owner thread priority of mutex */
                if (thread->current_priority < mutex->owner->current_priority)
                {
                    /* change the owner thread priority */
                    rt_thread_control(mutex->owner,
 80165ba:	4610      	mov	r0, r2
 80165bc:	2102      	movs	r1, #2
 80165be:	461a      	mov	r2, r3
 80165c0:	f002 fc32 	bl	8018e28 <rt_thread_control>
                                      RT_THREAD_CTRL_CHANGE_PRIORITY,
                                      &thread->current_priority);
                }

                /* suspend current thread */
                rt_ipc_list_suspend(&(mutex->parent.suspend_thread),
 80165c4:	687b      	ldr	r3, [r7, #4]
 80165c6:	f103 0214 	add.w	r2, r3, #20
 80165ca:	687b      	ldr	r3, [r7, #4]
 80165cc:	7a5b      	ldrb	r3, [r3, #9]
 80165ce:	4610      	mov	r0, r2
 80165d0:	68f9      	ldr	r1, [r7, #12]
 80165d2:	461a      	mov	r2, r3
 80165d4:	f7ff fd7c 	bl	80160d0 <rt_ipc_list_suspend>
                                    thread,
                                    mutex->parent.parent.flag);

                /* has waiting time, start thread timer */
                if (time > 0)
 80165d8:	683b      	ldr	r3, [r7, #0]
 80165da:	2b00      	cmp	r3, #0
 80165dc:	dd0d      	ble.n	80165fa <rt_mutex_take+0x152>
                    RT_DEBUG_LOG(RT_DEBUG_IPC,
                                 ("mutex_take: start the timer of thread:%s\n",
                                  thread->name));

                    /* reset the timeout of thread timer and start it */
                    rt_timer_control(&(thread->thread_timer),
 80165de:	68fb      	ldr	r3, [r7, #12]
 80165e0:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 80165e4:	463b      	mov	r3, r7
 80165e6:	4610      	mov	r0, r2
 80165e8:	2100      	movs	r1, #0
 80165ea:	461a      	mov	r2, r3
 80165ec:	f002 ff70 	bl	80194d0 <rt_timer_control>
                                     RT_TIMER_CTRL_SET_TIME,
                                     &time);
                    rt_timer_start(&(thread->thread_timer));
 80165f0:	68fb      	ldr	r3, [r7, #12]
 80165f2:	334c      	adds	r3, #76	; 0x4c
 80165f4:	4618      	mov	r0, r3
 80165f6:	f002 fe25 	bl	8019244 <rt_timer_start>
                }

                /* enable interrupt */
                rt_hw_interrupt_enable(temp);
 80165fa:	4620      	mov	r0, r4
 80165fc:	f7e9 fde8 	bl	80001d0 <rt_hw_interrupt_enable>

                /* do schedule */
                rt_schedule();
 8016600:	f002 f8aa 	bl	8018758 <rt_schedule>

                if (thread->error != RT_EOK)
 8016604:	68fb      	ldr	r3, [r7, #12]
 8016606:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8016608:	2b00      	cmp	r3, #0
 801660a:	d002      	beq.n	8016612 <rt_mutex_take+0x16a>
                {
                    /* return error */
                    return thread->error;
 801660c:	68fb      	ldr	r3, [r7, #12]
 801660e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8016610:	e00f      	b.n	8016632 <rt_mutex_take+0x18a>
                }
                else
                {
                    /* the mutex is taken successfully. */
                    /* disable interrupt */
                    temp = rt_hw_interrupt_disable();
 8016612:	f7e9 fdd9 	bl	80001c8 <rt_hw_interrupt_disable>
 8016616:	4604      	mov	r4, r0
            }
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8016618:	4620      	mov	r0, r4
 801661a:	f7e9 fdd9 	bl	80001d0 <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mutex->parent.parent)));
 801661e:	4b0d      	ldr	r3, [pc, #52]	; (8016654 <rt_mutex_take+0x1ac>)
 8016620:	681b      	ldr	r3, [r3, #0]
 8016622:	2b00      	cmp	r3, #0
 8016624:	d004      	beq.n	8016630 <rt_mutex_take+0x188>
 8016626:	4b0b      	ldr	r3, [pc, #44]	; (8016654 <rt_mutex_take+0x1ac>)
 8016628:	681b      	ldr	r3, [r3, #0]
 801662a:	687a      	ldr	r2, [r7, #4]
 801662c:	4610      	mov	r0, r2
 801662e:	4798      	blx	r3

    return RT_EOK;
 8016630:	2300      	movs	r3, #0
}
 8016632:	4618      	mov	r0, r3
 8016634:	371c      	adds	r7, #28
 8016636:	46bd      	mov	sp, r7
 8016638:	bd90      	pop	{r4, r7, pc}
 801663a:	bf00      	nop
 801663c:	080275ec 	.word	0x080275ec
 8016640:	08028ee8 	.word	0x08028ee8
 8016644:	080275e8 	.word	0x080275e8
 8016648:	080275c4 	.word	0x080275c4
 801664c:	08027624 	.word	0x08027624
 8016650:	20012a48 	.word	0x20012a48
 8016654:	20012a44 	.word	0x20012a44

08016658 <rt_mutex_release>:
 * @param mutex the mutex object
 *
 * @return the error code
 */
rt_err_t rt_mutex_release(rt_mutex_t mutex)
{
 8016658:	b590      	push	{r4, r7, lr}
 801665a:	b087      	sub	sp, #28
 801665c:	af00      	add	r7, sp, #0
 801665e:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;
    struct rt_thread *thread;
    rt_bool_t need_schedule;

    need_schedule = RT_FALSE;
 8016660:	2300      	movs	r3, #0
 8016662:	617b      	str	r3, [r7, #20]

    /* only thread could release mutex because we need test the ownership */
    RT_DEBUG_IN_THREAD_CONTEXT;
 8016664:	f7e9 fdb0 	bl	80001c8 <rt_hw_interrupt_disable>
 8016668:	6138      	str	r0, [r7, #16]
 801666a:	f002 fab1 	bl	8018bd0 <rt_thread_self>
 801666e:	4603      	mov	r3, r0
 8016670:	2b00      	cmp	r3, #0
 8016672:	d109      	bne.n	8016688 <rt_mutex_release+0x30>
 8016674:	484a      	ldr	r0, [pc, #296]	; (80167a0 <rt_mutex_release+0x148>)
 8016676:	494b      	ldr	r1, [pc, #300]	; (80167a4 <rt_mutex_release+0x14c>)
 8016678:	f001 f920 	bl	80178bc <rt_kprintf>
 801667c:	484a      	ldr	r0, [pc, #296]	; (80167a8 <rt_mutex_release+0x150>)
 801667e:	4949      	ldr	r1, [pc, #292]	; (80167a4 <rt_mutex_release+0x14c>)
 8016680:	f240 320d 	movw	r2, #781	; 0x30d
 8016684:	f001 f994 	bl	80179b0 <rt_assert_handler>
 8016688:	f7e9 fd9e 	bl	80001c8 <rt_hw_interrupt_disable>
 801668c:	60f8      	str	r0, [r7, #12]
 801668e:	f000 fb31 	bl	8016cf4 <rt_interrupt_get_nest>
 8016692:	4603      	mov	r3, r0
 8016694:	2b00      	cmp	r3, #0
 8016696:	d009      	beq.n	80166ac <rt_mutex_release+0x54>
 8016698:	4844      	ldr	r0, [pc, #272]	; (80167ac <rt_mutex_release+0x154>)
 801669a:	4942      	ldr	r1, [pc, #264]	; (80167a4 <rt_mutex_release+0x14c>)
 801669c:	f001 f90e 	bl	80178bc <rt_kprintf>
 80166a0:	4841      	ldr	r0, [pc, #260]	; (80167a8 <rt_mutex_release+0x150>)
 80166a2:	4940      	ldr	r1, [pc, #256]	; (80167a4 <rt_mutex_release+0x14c>)
 80166a4:	f240 320d 	movw	r2, #781	; 0x30d
 80166a8:	f001 f982 	bl	80179b0 <rt_assert_handler>
 80166ac:	68f8      	ldr	r0, [r7, #12]
 80166ae:	f7e9 fd8f 	bl	80001d0 <rt_hw_interrupt_enable>
 80166b2:	6938      	ldr	r0, [r7, #16]
 80166b4:	f7e9 fd8c 	bl	80001d0 <rt_hw_interrupt_enable>

    /* get current thread */
    thread = rt_thread_self();
 80166b8:	f002 fa8a 	bl	8018bd0 <rt_thread_self>
 80166bc:	60b8      	str	r0, [r7, #8]

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 80166be:	f7e9 fd83 	bl	80001c8 <rt_hw_interrupt_disable>
 80166c2:	4604      	mov	r4, r0

    RT_DEBUG_LOG(RT_DEBUG_IPC,
                 ("mutex_release:current thread %s, mutex value: %d, hold: %d\n",
                  thread->name, mutex->value, mutex->hold));

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mutex->parent.parent)));
 80166c4:	4b3a      	ldr	r3, [pc, #232]	; (80167b0 <rt_mutex_release+0x158>)
 80166c6:	681b      	ldr	r3, [r3, #0]
 80166c8:	2b00      	cmp	r3, #0
 80166ca:	d004      	beq.n	80166d6 <rt_mutex_release+0x7e>
 80166cc:	4b38      	ldr	r3, [pc, #224]	; (80167b0 <rt_mutex_release+0x158>)
 80166ce:	681b      	ldr	r3, [r3, #0]
 80166d0:	687a      	ldr	r2, [r7, #4]
 80166d2:	4610      	mov	r0, r2
 80166d4:	4798      	blx	r3

    /* mutex only can be released by owner */
    if (thread != mutex->owner)
 80166d6:	687b      	ldr	r3, [r7, #4]
 80166d8:	6a1a      	ldr	r2, [r3, #32]
 80166da:	68bb      	ldr	r3, [r7, #8]
 80166dc:	429a      	cmp	r2, r3
 80166de:	d009      	beq.n	80166f4 <rt_mutex_release+0x9c>
    {
        thread->error = -RT_ERROR;
 80166e0:	68bb      	ldr	r3, [r7, #8]
 80166e2:	f04f 32ff 	mov.w	r2, #4294967295
 80166e6:	631a      	str	r2, [r3, #48]	; 0x30

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 80166e8:	4620      	mov	r0, r4
 80166ea:	f7e9 fd71 	bl	80001d0 <rt_hw_interrupt_enable>

        return -RT_ERROR;
 80166ee:	f04f 33ff 	mov.w	r3, #4294967295
 80166f2:	e051      	b.n	8016798 <rt_mutex_release+0x140>
    }

    /* decrease hold */
    mutex->hold --;
 80166f4:	687b      	ldr	r3, [r7, #4]
 80166f6:	7fdb      	ldrb	r3, [r3, #31]
 80166f8:	3b01      	subs	r3, #1
 80166fa:	b2da      	uxtb	r2, r3
 80166fc:	687b      	ldr	r3, [r7, #4]
 80166fe:	77da      	strb	r2, [r3, #31]
    /* if no hold */
    if (mutex->hold == 0)
 8016700:	687b      	ldr	r3, [r7, #4]
 8016702:	7fdb      	ldrb	r3, [r3, #31]
 8016704:	2b00      	cmp	r3, #0
 8016706:	d13e      	bne.n	8016786 <rt_mutex_release+0x12e>
    {
        /* change the owner thread to original priority */
        if (mutex->original_priority != mutex->owner->current_priority)
 8016708:	687b      	ldr	r3, [r7, #4]
 801670a:	7f9a      	ldrb	r2, [r3, #30]
 801670c:	687b      	ldr	r3, [r7, #4]
 801670e:	6a1b      	ldr	r3, [r3, #32]
 8016710:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8016714:	429a      	cmp	r2, r3
 8016716:	d008      	beq.n	801672a <rt_mutex_release+0xd2>
        {
            rt_thread_control(mutex->owner,
 8016718:	687b      	ldr	r3, [r7, #4]
 801671a:	6a1a      	ldr	r2, [r3, #32]
                              RT_THREAD_CTRL_CHANGE_PRIORITY,
                              &(mutex->original_priority));
 801671c:	687b      	ldr	r3, [r7, #4]
 801671e:	331e      	adds	r3, #30
    if (mutex->hold == 0)
    {
        /* change the owner thread to original priority */
        if (mutex->original_priority != mutex->owner->current_priority)
        {
            rt_thread_control(mutex->owner,
 8016720:	4610      	mov	r0, r2
 8016722:	2102      	movs	r1, #2
 8016724:	461a      	mov	r2, r3
 8016726:	f002 fb7f 	bl	8018e28 <rt_thread_control>
                              RT_THREAD_CTRL_CHANGE_PRIORITY,
                              &(mutex->original_priority));
        }

        /* wakeup suspended thread */
        if (!rt_list_isempty(&mutex->parent.suspend_thread))
 801672a:	687b      	ldr	r3, [r7, #4]
 801672c:	3314      	adds	r3, #20
 801672e:	4618      	mov	r0, r3
 8016730:	f7ff fcae 	bl	8016090 <rt_list_isempty>
 8016734:	4603      	mov	r3, r0
 8016736:	2b00      	cmp	r3, #0
 8016738:	d119      	bne.n	801676e <rt_mutex_release+0x116>
        {
            /* get suspended thread */
            thread = rt_list_entry(mutex->parent.suspend_thread.next,
 801673a:	687b      	ldr	r3, [r7, #4]
 801673c:	695b      	ldr	r3, [r3, #20]
 801673e:	3b14      	subs	r3, #20
 8016740:	60bb      	str	r3, [r7, #8]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_release: resume thread: %s\n",
                                        thread->name));

            /* set new owner and priority */
            mutex->owner             = thread;
 8016742:	687b      	ldr	r3, [r7, #4]
 8016744:	68ba      	ldr	r2, [r7, #8]
 8016746:	621a      	str	r2, [r3, #32]
            mutex->original_priority = thread->current_priority;
 8016748:	68bb      	ldr	r3, [r7, #8]
 801674a:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
 801674e:	687b      	ldr	r3, [r7, #4]
 8016750:	779a      	strb	r2, [r3, #30]
            mutex->hold ++;
 8016752:	687b      	ldr	r3, [r7, #4]
 8016754:	7fdb      	ldrb	r3, [r3, #31]
 8016756:	3301      	adds	r3, #1
 8016758:	b2da      	uxtb	r2, r3
 801675a:	687b      	ldr	r3, [r7, #4]
 801675c:	77da      	strb	r2, [r3, #31]

            /* resume thread */
            rt_ipc_list_resume(&(mutex->parent.suspend_thread));
 801675e:	687b      	ldr	r3, [r7, #4]
 8016760:	3314      	adds	r3, #20
 8016762:	4618      	mov	r0, r3
 8016764:	f7ff fcfc 	bl	8016160 <rt_ipc_list_resume>

            need_schedule = RT_TRUE;
 8016768:	2301      	movs	r3, #1
 801676a:	617b      	str	r3, [r7, #20]
 801676c:	e00b      	b.n	8016786 <rt_mutex_release+0x12e>
        }
        else
        {
            /* increase value */
            mutex->value ++;
 801676e:	687b      	ldr	r3, [r7, #4]
 8016770:	8b9b      	ldrh	r3, [r3, #28]
 8016772:	3301      	adds	r3, #1
 8016774:	b29a      	uxth	r2, r3
 8016776:	687b      	ldr	r3, [r7, #4]
 8016778:	839a      	strh	r2, [r3, #28]

            /* clear owner */
            mutex->owner             = RT_NULL;
 801677a:	687b      	ldr	r3, [r7, #4]
 801677c:	2200      	movs	r2, #0
 801677e:	621a      	str	r2, [r3, #32]
            mutex->original_priority = 0xff;
 8016780:	687b      	ldr	r3, [r7, #4]
 8016782:	22ff      	movs	r2, #255	; 0xff
 8016784:	779a      	strb	r2, [r3, #30]
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8016786:	4620      	mov	r0, r4
 8016788:	f7e9 fd22 	bl	80001d0 <rt_hw_interrupt_enable>

    /* perform a schedule */
    if (need_schedule == RT_TRUE)
 801678c:	697b      	ldr	r3, [r7, #20]
 801678e:	2b01      	cmp	r3, #1
 8016790:	d101      	bne.n	8016796 <rt_mutex_release+0x13e>
        rt_schedule();
 8016792:	f001 ffe1 	bl	8018758 <rt_schedule>

    return RT_EOK;
 8016796:	2300      	movs	r3, #0
}
 8016798:	4618      	mov	r0, r3
 801679a:	371c      	adds	r7, #28
 801679c:	46bd      	mov	sp, r7
 801679e:	bd90      	pop	{r4, r7, pc}
 80167a0:	080275ec 	.word	0x080275ec
 80167a4:	08028ef8 	.word	0x08028ef8
 80167a8:	080275e8 	.word	0x080275e8
 80167ac:	080275c4 	.word	0x080275c4
 80167b0:	20012a40 	.word	0x20012a40

080167b4 <rt_mq_create>:
 */
rt_mq_t rt_mq_create(const char *name,
                     rt_size_t   msg_size,
                     rt_size_t   max_msgs,
                     rt_uint8_t  flag)
{
 80167b4:	b590      	push	{r4, r7, lr}
 80167b6:	b089      	sub	sp, #36	; 0x24
 80167b8:	af00      	add	r7, sp, #0
 80167ba:	60f8      	str	r0, [r7, #12]
 80167bc:	60b9      	str	r1, [r7, #8]
 80167be:	607a      	str	r2, [r7, #4]
 80167c0:	70fb      	strb	r3, [r7, #3]
    struct rt_messagequeue *mq;
    struct rt_mq_message *head;
    register rt_base_t temp;

    RT_DEBUG_NOT_IN_INTERRUPT;
 80167c2:	f7e9 fd01 	bl	80001c8 <rt_hw_interrupt_disable>
 80167c6:	61f8      	str	r0, [r7, #28]
 80167c8:	f000 fa94 	bl	8016cf4 <rt_interrupt_get_nest>
 80167cc:	4603      	mov	r3, r0
 80167ce:	2b00      	cmp	r3, #0
 80167d0:	d009      	beq.n	80167e6 <rt_mq_create+0x32>
 80167d2:	4835      	ldr	r0, [pc, #212]	; (80168a8 <rt_mq_create+0xf4>)
 80167d4:	4935      	ldr	r1, [pc, #212]	; (80168ac <rt_mq_create+0xf8>)
 80167d6:	f001 f871 	bl	80178bc <rt_kprintf>
 80167da:	4835      	ldr	r0, [pc, #212]	; (80168b0 <rt_mq_create+0xfc>)
 80167dc:	4933      	ldr	r1, [pc, #204]	; (80168ac <rt_mq_create+0xf8>)
 80167de:	f240 7226 	movw	r2, #1830	; 0x726
 80167e2:	f001 f8e5 	bl	80179b0 <rt_assert_handler>
 80167e6:	69f8      	ldr	r0, [r7, #28]
 80167e8:	f7e9 fcf2 	bl	80001d0 <rt_hw_interrupt_enable>

    /* allocate object */
    mq = (rt_mq_t)rt_object_allocate(RT_Object_Class_MessageQueue, name);
 80167ec:	2005      	movs	r0, #5
 80167ee:	68f9      	ldr	r1, [r7, #12]
 80167f0:	f001 fe1c 	bl	801842c <rt_object_allocate>
 80167f4:	61b8      	str	r0, [r7, #24]
    if (mq == RT_NULL)
 80167f6:	69bb      	ldr	r3, [r7, #24]
 80167f8:	2b00      	cmp	r3, #0
 80167fa:	d101      	bne.n	8016800 <rt_mq_create+0x4c>
        return mq;
 80167fc:	69bb      	ldr	r3, [r7, #24]
 80167fe:	e04e      	b.n	801689e <rt_mq_create+0xea>

    /* set parent */
    mq->parent.parent.flag = flag;
 8016800:	69bb      	ldr	r3, [r7, #24]
 8016802:	78fa      	ldrb	r2, [r7, #3]
 8016804:	725a      	strb	r2, [r3, #9]

    /* init ipc object */
    rt_ipc_object_init(&(mq->parent));
 8016806:	69bb      	ldr	r3, [r7, #24]
 8016808:	4618      	mov	r0, r3
 801680a:	f7ff fc53 	bl	80160b4 <rt_ipc_object_init>

    /* init message queue */

    /* get correct message size */
    mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
 801680e:	68bb      	ldr	r3, [r7, #8]
 8016810:	b29b      	uxth	r3, r3
 8016812:	3303      	adds	r3, #3
 8016814:	b29b      	uxth	r3, r3
 8016816:	f023 0303 	bic.w	r3, r3, #3
 801681a:	b29a      	uxth	r2, r3
 801681c:	69bb      	ldr	r3, [r7, #24]
 801681e:	841a      	strh	r2, [r3, #32]
    mq->max_msgs = max_msgs;
 8016820:	687b      	ldr	r3, [r7, #4]
 8016822:	b29a      	uxth	r2, r3
 8016824:	69bb      	ldr	r3, [r7, #24]
 8016826:	845a      	strh	r2, [r3, #34]	; 0x22

    /* allocate message pool */
    mq->msg_pool = RT_KERNEL_MALLOC((mq->msg_size + sizeof(struct rt_mq_message))* mq->max_msgs);
 8016828:	69bb      	ldr	r3, [r7, #24]
 801682a:	8c1b      	ldrh	r3, [r3, #32]
 801682c:	3304      	adds	r3, #4
 801682e:	69ba      	ldr	r2, [r7, #24]
 8016830:	8c52      	ldrh	r2, [r2, #34]	; 0x22
 8016832:	fb02 f303 	mul.w	r3, r2, r3
 8016836:	4618      	mov	r0, r3
 8016838:	f001 f9ee 	bl	8017c18 <rt_malloc>
 801683c:	4602      	mov	r2, r0
 801683e:	69bb      	ldr	r3, [r7, #24]
 8016840:	61da      	str	r2, [r3, #28]
    if (mq->msg_pool == RT_NULL)
 8016842:	69bb      	ldr	r3, [r7, #24]
 8016844:	69db      	ldr	r3, [r3, #28]
 8016846:	2b00      	cmp	r3, #0
 8016848:	d104      	bne.n	8016854 <rt_mq_create+0xa0>
    {
        rt_mq_delete(mq);
 801684a:	69b8      	ldr	r0, [r7, #24]
 801684c:	f000 f832 	bl	80168b4 <rt_mq_delete>

        return RT_NULL;
 8016850:	2300      	movs	r3, #0
 8016852:	e024      	b.n	801689e <rt_mq_create+0xea>
    }

    /* init message list */
    mq->msg_queue_head = RT_NULL;
 8016854:	69bb      	ldr	r3, [r7, #24]
 8016856:	2200      	movs	r2, #0
 8016858:	629a      	str	r2, [r3, #40]	; 0x28
    mq->msg_queue_tail = RT_NULL;
 801685a:	69bb      	ldr	r3, [r7, #24]
 801685c:	2200      	movs	r2, #0
 801685e:	62da      	str	r2, [r3, #44]	; 0x2c

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
 8016860:	69bb      	ldr	r3, [r7, #24]
 8016862:	2200      	movs	r2, #0
 8016864:	631a      	str	r2, [r3, #48]	; 0x30
    for (temp = 0; temp < mq->max_msgs; temp ++)
 8016866:	2400      	movs	r4, #0
 8016868:	e011      	b.n	801688e <rt_mq_create+0xda>
    {
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
 801686a:	69bb      	ldr	r3, [r7, #24]
 801686c:	69da      	ldr	r2, [r3, #28]
               temp * (mq->msg_size + sizeof(struct rt_mq_message)));
 801686e:	69bb      	ldr	r3, [r7, #24]
 8016870:	8c1b      	ldrh	r3, [r3, #32]
 8016872:	3304      	adds	r3, #4

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
    for (temp = 0; temp < mq->max_msgs; temp ++)
    {
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
 8016874:	4621      	mov	r1, r4
 8016876:	fb01 f303 	mul.w	r3, r1, r3
 801687a:	4413      	add	r3, r2
 801687c:	617b      	str	r3, [r7, #20]
               temp * (mq->msg_size + sizeof(struct rt_mq_message)));
        head->next = mq->msg_queue_free;
 801687e:	69bb      	ldr	r3, [r7, #24]
 8016880:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8016882:	697b      	ldr	r3, [r7, #20]
 8016884:	601a      	str	r2, [r3, #0]
        mq->msg_queue_free = head;
 8016886:	69bb      	ldr	r3, [r7, #24]
 8016888:	697a      	ldr	r2, [r7, #20]
 801688a:	631a      	str	r2, [r3, #48]	; 0x30
    mq->msg_queue_head = RT_NULL;
    mq->msg_queue_tail = RT_NULL;

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
    for (temp = 0; temp < mq->max_msgs; temp ++)
 801688c:	3401      	adds	r4, #1
 801688e:	69bb      	ldr	r3, [r7, #24]
 8016890:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 8016892:	42a3      	cmp	r3, r4
 8016894:	dce9      	bgt.n	801686a <rt_mq_create+0xb6>
        head->next = mq->msg_queue_free;
        mq->msg_queue_free = head;
    }

    /* the initial entry is zero */
    mq->entry = 0;
 8016896:	69bb      	ldr	r3, [r7, #24]
 8016898:	2200      	movs	r2, #0
 801689a:	849a      	strh	r2, [r3, #36]	; 0x24

    return mq;
 801689c:	69bb      	ldr	r3, [r7, #24]
}
 801689e:	4618      	mov	r0, r3
 80168a0:	3724      	adds	r7, #36	; 0x24
 80168a2:	46bd      	mov	sp, r7
 80168a4:	bd90      	pop	{r4, r7, pc}
 80168a6:	bf00      	nop
 80168a8:	080275c4 	.word	0x080275c4
 80168ac:	08028f0c 	.word	0x08028f0c
 80168b0:	080275e8 	.word	0x080275e8

080168b4 <rt_mq_delete>:
 * @param mq the message queue object
 *
 * @return the error code
 */
rt_err_t rt_mq_delete(rt_mq_t mq)
{
 80168b4:	b580      	push	{r7, lr}
 80168b6:	b084      	sub	sp, #16
 80168b8:	af00      	add	r7, sp, #0
 80168ba:	6078      	str	r0, [r7, #4]
    RT_DEBUG_NOT_IN_INTERRUPT;
 80168bc:	f7e9 fc84 	bl	80001c8 <rt_hw_interrupt_disable>
 80168c0:	60f8      	str	r0, [r7, #12]
 80168c2:	f000 fa17 	bl	8016cf4 <rt_interrupt_get_nest>
 80168c6:	4603      	mov	r3, r0
 80168c8:	2b00      	cmp	r3, #0
 80168ca:	d009      	beq.n	80168e0 <rt_mq_delete+0x2c>
 80168cc:	4814      	ldr	r0, [pc, #80]	; (8016920 <rt_mq_delete+0x6c>)
 80168ce:	4915      	ldr	r1, [pc, #84]	; (8016924 <rt_mq_delete+0x70>)
 80168d0:	f000 fff4 	bl	80178bc <rt_kprintf>
 80168d4:	4814      	ldr	r0, [pc, #80]	; (8016928 <rt_mq_delete+0x74>)
 80168d6:	4913      	ldr	r1, [pc, #76]	; (8016924 <rt_mq_delete+0x70>)
 80168d8:	f44f 62ec 	mov.w	r2, #1888	; 0x760
 80168dc:	f001 f868 	bl	80179b0 <rt_assert_handler>
 80168e0:	68f8      	ldr	r0, [r7, #12]
 80168e2:	f7e9 fc75 	bl	80001d0 <rt_hw_interrupt_enable>

    /* parameter check */
    RT_ASSERT(mq != RT_NULL);
 80168e6:	687b      	ldr	r3, [r7, #4]
 80168e8:	2b00      	cmp	r3, #0
 80168ea:	d105      	bne.n	80168f8 <rt_mq_delete+0x44>
 80168ec:	480f      	ldr	r0, [pc, #60]	; (801692c <rt_mq_delete+0x78>)
 80168ee:	490d      	ldr	r1, [pc, #52]	; (8016924 <rt_mq_delete+0x70>)
 80168f0:	f240 7263 	movw	r2, #1891	; 0x763
 80168f4:	f001 f85c 	bl	80179b0 <rt_assert_handler>

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&(mq->parent.suspend_thread));
 80168f8:	687b      	ldr	r3, [r7, #4]
 80168fa:	3314      	adds	r3, #20
 80168fc:	4618      	mov	r0, r3
 80168fe:	f7ff fc3f 	bl	8016180 <rt_ipc_list_resume_all>
        rt_module_free(mq->parent.parent.module_id, mq->msg_pool);
    else
#endif

    /* free message queue pool */
    RT_KERNEL_FREE(mq->msg_pool);
 8016902:	687b      	ldr	r3, [r7, #4]
 8016904:	69db      	ldr	r3, [r3, #28]
 8016906:	4618      	mov	r0, r3
 8016908:	f001 fb90 	bl	801802c <rt_free>

    /* delete message queue object */
    rt_object_delete(&(mq->parent.parent));
 801690c:	687b      	ldr	r3, [r7, #4]
 801690e:	4618      	mov	r0, r3
 8016910:	f001 fde8 	bl	80184e4 <rt_object_delete>

    return RT_EOK;
 8016914:	2300      	movs	r3, #0
}
 8016916:	4618      	mov	r0, r3
 8016918:	3710      	adds	r7, #16
 801691a:	46bd      	mov	sp, r7
 801691c:	bd80      	pop	{r7, pc}
 801691e:	bf00      	nop
 8016920:	080275c4 	.word	0x080275c4
 8016924:	08028f1c 	.word	0x08028f1c
 8016928:	080275e8 	.word	0x080275e8
 801692c:	0802765c 	.word	0x0802765c

08016930 <rt_mq_send>:
 * @param size the size of buffer
 *
 * @return the error code
 */
rt_err_t rt_mq_send(rt_mq_t mq, void *buffer, rt_size_t size)
{
 8016930:	b590      	push	{r4, r7, lr}
 8016932:	b087      	sub	sp, #28
 8016934:	af00      	add	r7, sp, #0
 8016936:	60f8      	str	r0, [r7, #12]
 8016938:	60b9      	str	r1, [r7, #8]
 801693a:	607a      	str	r2, [r7, #4]
    register rt_ubase_t temp;
    struct rt_mq_message *msg;

    RT_ASSERT(mq != RT_NULL);
 801693c:	68fb      	ldr	r3, [r7, #12]
 801693e:	2b00      	cmp	r3, #0
 8016940:	d105      	bne.n	801694e <rt_mq_send+0x1e>
 8016942:	4843      	ldr	r0, [pc, #268]	; (8016a50 <rt_mq_send+0x120>)
 8016944:	4943      	ldr	r1, [pc, #268]	; (8016a54 <rt_mq_send+0x124>)
 8016946:	f240 7289 	movw	r2, #1929	; 0x789
 801694a:	f001 f831 	bl	80179b0 <rt_assert_handler>
    RT_ASSERT(buffer != RT_NULL);
 801694e:	68bb      	ldr	r3, [r7, #8]
 8016950:	2b00      	cmp	r3, #0
 8016952:	d105      	bne.n	8016960 <rt_mq_send+0x30>
 8016954:	4840      	ldr	r0, [pc, #256]	; (8016a58 <rt_mq_send+0x128>)
 8016956:	493f      	ldr	r1, [pc, #252]	; (8016a54 <rt_mq_send+0x124>)
 8016958:	f240 728a 	movw	r2, #1930	; 0x78a
 801695c:	f001 f828 	bl	80179b0 <rt_assert_handler>
    RT_ASSERT(size != 0);
 8016960:	687b      	ldr	r3, [r7, #4]
 8016962:	2b00      	cmp	r3, #0
 8016964:	d105      	bne.n	8016972 <rt_mq_send+0x42>
 8016966:	483d      	ldr	r0, [pc, #244]	; (8016a5c <rt_mq_send+0x12c>)
 8016968:	493a      	ldr	r1, [pc, #232]	; (8016a54 <rt_mq_send+0x124>)
 801696a:	f240 728b 	movw	r2, #1931	; 0x78b
 801696e:	f001 f81f 	bl	80179b0 <rt_assert_handler>

    /* greater than one message size */
    if (size > mq->msg_size)
 8016972:	68fb      	ldr	r3, [r7, #12]
 8016974:	8c1b      	ldrh	r3, [r3, #32]
 8016976:	461a      	mov	r2, r3
 8016978:	687b      	ldr	r3, [r7, #4]
 801697a:	429a      	cmp	r2, r3
 801697c:	d202      	bcs.n	8016984 <rt_mq_send+0x54>
        return -RT_ERROR;
 801697e:	f04f 33ff 	mov.w	r3, #4294967295
 8016982:	e061      	b.n	8016a48 <rt_mq_send+0x118>

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
 8016984:	4b36      	ldr	r3, [pc, #216]	; (8016a60 <rt_mq_send+0x130>)
 8016986:	681b      	ldr	r3, [r3, #0]
 8016988:	2b00      	cmp	r3, #0
 801698a:	d004      	beq.n	8016996 <rt_mq_send+0x66>
 801698c:	4b34      	ldr	r3, [pc, #208]	; (8016a60 <rt_mq_send+0x130>)
 801698e:	681b      	ldr	r3, [r3, #0]
 8016990:	68fa      	ldr	r2, [r7, #12]
 8016992:	4610      	mov	r0, r2
 8016994:	4798      	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8016996:	f7e9 fc17 	bl	80001c8 <rt_hw_interrupt_disable>
 801699a:	4603      	mov	r3, r0
 801699c:	461c      	mov	r4, r3

    /* get a free list, there must be an empty item */
    msg = (struct rt_mq_message*)mq->msg_queue_free;
 801699e:	68fb      	ldr	r3, [r7, #12]
 80169a0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80169a2:	617b      	str	r3, [r7, #20]
    /* message queue is full */
    if (msg == RT_NULL)
 80169a4:	697b      	ldr	r3, [r7, #20]
 80169a6:	2b00      	cmp	r3, #0
 80169a8:	d106      	bne.n	80169b8 <rt_mq_send+0x88>
    {
        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 80169aa:	4623      	mov	r3, r4
 80169ac:	4618      	mov	r0, r3
 80169ae:	f7e9 fc0f 	bl	80001d0 <rt_hw_interrupt_enable>

        return -RT_EFULL;
 80169b2:	f06f 0302 	mvn.w	r3, #2
 80169b6:	e047      	b.n	8016a48 <rt_mq_send+0x118>
    }
    /* move free list pointer */
    mq->msg_queue_free = msg->next;
 80169b8:	697b      	ldr	r3, [r7, #20]
 80169ba:	681a      	ldr	r2, [r3, #0]
 80169bc:	68fb      	ldr	r3, [r7, #12]
 80169be:	631a      	str	r2, [r3, #48]	; 0x30

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 80169c0:	4623      	mov	r3, r4
 80169c2:	4618      	mov	r0, r3
 80169c4:	f7e9 fc04 	bl	80001d0 <rt_hw_interrupt_enable>

    /* the msg is the new tailer of list, the next shall be NULL */
    msg->next = RT_NULL;
 80169c8:	697b      	ldr	r3, [r7, #20]
 80169ca:	2200      	movs	r2, #0
 80169cc:	601a      	str	r2, [r3, #0]
    /* copy buffer */
    rt_memcpy(msg + 1, buffer, size);
 80169ce:	697b      	ldr	r3, [r7, #20]
 80169d0:	3304      	adds	r3, #4
 80169d2:	4618      	mov	r0, r3
 80169d4:	68b9      	ldr	r1, [r7, #8]
 80169d6:	687a      	ldr	r2, [r7, #4]
 80169d8:	f000 fa14 	bl	8016e04 <rt_memcpy>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 80169dc:	f7e9 fbf4 	bl	80001c8 <rt_hw_interrupt_disable>
 80169e0:	4603      	mov	r3, r0
 80169e2:	461c      	mov	r4, r3
    /* link msg to message queue */
    if (mq->msg_queue_tail != RT_NULL)
 80169e4:	68fb      	ldr	r3, [r7, #12]
 80169e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80169e8:	2b00      	cmp	r3, #0
 80169ea:	d003      	beq.n	80169f4 <rt_mq_send+0xc4>
    {
        /* if the tail exists, */
        ((struct rt_mq_message *)mq->msg_queue_tail)->next = msg;
 80169ec:	68fb      	ldr	r3, [r7, #12]
 80169ee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80169f0:	697a      	ldr	r2, [r7, #20]
 80169f2:	601a      	str	r2, [r3, #0]
    }

    /* set new tail */
    mq->msg_queue_tail = msg;
 80169f4:	68fb      	ldr	r3, [r7, #12]
 80169f6:	697a      	ldr	r2, [r7, #20]
 80169f8:	62da      	str	r2, [r3, #44]	; 0x2c
    /* if the head is empty, set head */
    if (mq->msg_queue_head == RT_NULL)
 80169fa:	68fb      	ldr	r3, [r7, #12]
 80169fc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80169fe:	2b00      	cmp	r3, #0
 8016a00:	d102      	bne.n	8016a08 <rt_mq_send+0xd8>
        mq->msg_queue_head = msg;
 8016a02:	68fb      	ldr	r3, [r7, #12]
 8016a04:	697a      	ldr	r2, [r7, #20]
 8016a06:	629a      	str	r2, [r3, #40]	; 0x28

    /* increase message entry */
    mq->entry ++;
 8016a08:	68fb      	ldr	r3, [r7, #12]
 8016a0a:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8016a0c:	3301      	adds	r3, #1
 8016a0e:	b29a      	uxth	r2, r3
 8016a10:	68fb      	ldr	r3, [r7, #12]
 8016a12:	849a      	strh	r2, [r3, #36]	; 0x24

    /* resume suspended thread */
    if (!rt_list_isempty(&mq->parent.suspend_thread))
 8016a14:	68fb      	ldr	r3, [r7, #12]
 8016a16:	3314      	adds	r3, #20
 8016a18:	4618      	mov	r0, r3
 8016a1a:	f7ff fb39 	bl	8016090 <rt_list_isempty>
 8016a1e:	4603      	mov	r3, r0
 8016a20:	2b00      	cmp	r3, #0
 8016a22:	d10c      	bne.n	8016a3e <rt_mq_send+0x10e>
    {
        rt_ipc_list_resume(&(mq->parent.suspend_thread));
 8016a24:	68fb      	ldr	r3, [r7, #12]
 8016a26:	3314      	adds	r3, #20
 8016a28:	4618      	mov	r0, r3
 8016a2a:	f7ff fb99 	bl	8016160 <rt_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 8016a2e:	4623      	mov	r3, r4
 8016a30:	4618      	mov	r0, r3
 8016a32:	f7e9 fbcd 	bl	80001d0 <rt_hw_interrupt_enable>

        rt_schedule();
 8016a36:	f001 fe8f 	bl	8018758 <rt_schedule>

        return RT_EOK;
 8016a3a:	2300      	movs	r3, #0
 8016a3c:	e004      	b.n	8016a48 <rt_mq_send+0x118>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8016a3e:	4623      	mov	r3, r4
 8016a40:	4618      	mov	r0, r3
 8016a42:	f7e9 fbc5 	bl	80001d0 <rt_hw_interrupt_enable>

    return RT_EOK;
 8016a46:	2300      	movs	r3, #0
}
 8016a48:	4618      	mov	r0, r3
 8016a4a:	371c      	adds	r7, #28
 8016a4c:	46bd      	mov	sp, r7
 8016a4e:	bd90      	pop	{r4, r7, pc}
 8016a50:	0802765c 	.word	0x0802765c
 8016a54:	08028f2c 	.word	0x08028f2c
 8016a58:	0802766c 	.word	0x0802766c
 8016a5c:	08027680 	.word	0x08027680
 8016a60:	20012a40 	.word	0x20012a40

08016a64 <rt_mq_recv>:
 */
rt_err_t rt_mq_recv(rt_mq_t    mq,
                    void      *buffer,
                    rt_size_t  size,
                    rt_int32_t timeout)
{
 8016a64:	b590      	push	{r4, r7, lr}
 8016a66:	b08b      	sub	sp, #44	; 0x2c
 8016a68:	af00      	add	r7, sp, #0
 8016a6a:	60f8      	str	r0, [r7, #12]
 8016a6c:	60b9      	str	r1, [r7, #8]
 8016a6e:	607a      	str	r2, [r7, #4]
 8016a70:	603b      	str	r3, [r7, #0]
    struct rt_thread *thread;
    register rt_ubase_t temp;
    struct rt_mq_message *msg;
    rt_uint32_t tick_delta;

    RT_ASSERT(mq != RT_NULL);
 8016a72:	68fb      	ldr	r3, [r7, #12]
 8016a74:	2b00      	cmp	r3, #0
 8016a76:	d105      	bne.n	8016a84 <rt_mq_recv+0x20>
 8016a78:	487f      	ldr	r0, [pc, #508]	; (8016c78 <rt_mq_recv+0x214>)
 8016a7a:	4980      	ldr	r1, [pc, #512]	; (8016c7c <rt_mq_recv+0x218>)
 8016a7c:	f640 0239 	movw	r2, #2105	; 0x839
 8016a80:	f000 ff96 	bl	80179b0 <rt_assert_handler>
    RT_ASSERT(buffer != RT_NULL);
 8016a84:	68bb      	ldr	r3, [r7, #8]
 8016a86:	2b00      	cmp	r3, #0
 8016a88:	d105      	bne.n	8016a96 <rt_mq_recv+0x32>
 8016a8a:	487d      	ldr	r0, [pc, #500]	; (8016c80 <rt_mq_recv+0x21c>)
 8016a8c:	497b      	ldr	r1, [pc, #492]	; (8016c7c <rt_mq_recv+0x218>)
 8016a8e:	f640 023a 	movw	r2, #2106	; 0x83a
 8016a92:	f000 ff8d 	bl	80179b0 <rt_assert_handler>
    RT_ASSERT(size != 0);
 8016a96:	687b      	ldr	r3, [r7, #4]
 8016a98:	2b00      	cmp	r3, #0
 8016a9a:	d105      	bne.n	8016aa8 <rt_mq_recv+0x44>
 8016a9c:	4879      	ldr	r0, [pc, #484]	; (8016c84 <rt_mq_recv+0x220>)
 8016a9e:	4977      	ldr	r1, [pc, #476]	; (8016c7c <rt_mq_recv+0x218>)
 8016aa0:	f640 023b 	movw	r2, #2107	; 0x83b
 8016aa4:	f000 ff84 	bl	80179b0 <rt_assert_handler>

    /* initialize delta tick */
    tick_delta = 0;
 8016aa8:	2300      	movs	r3, #0
 8016aaa:	627b      	str	r3, [r7, #36]	; 0x24
    /* get current thread */
    thread = rt_thread_self();
 8016aac:	f002 f890 	bl	8018bd0 <rt_thread_self>
 8016ab0:	6238      	str	r0, [r7, #32]
    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mq->parent.parent)));
 8016ab2:	4b75      	ldr	r3, [pc, #468]	; (8016c88 <rt_mq_recv+0x224>)
 8016ab4:	681b      	ldr	r3, [r3, #0]
 8016ab6:	2b00      	cmp	r3, #0
 8016ab8:	d004      	beq.n	8016ac4 <rt_mq_recv+0x60>
 8016aba:	4b73      	ldr	r3, [pc, #460]	; (8016c88 <rt_mq_recv+0x224>)
 8016abc:	681b      	ldr	r3, [r3, #0]
 8016abe:	68fa      	ldr	r2, [r7, #12]
 8016ac0:	4610      	mov	r0, r2
 8016ac2:	4798      	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8016ac4:	f7e9 fb80 	bl	80001c8 <rt_hw_interrupt_disable>
 8016ac8:	4603      	mov	r3, r0
 8016aca:	461c      	mov	r4, r3

    /* for non-blocking call */
    if (mq->entry == 0 && timeout == 0)
 8016acc:	68fb      	ldr	r3, [r7, #12]
 8016ace:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8016ad0:	2b00      	cmp	r3, #0
 8016ad2:	d109      	bne.n	8016ae8 <rt_mq_recv+0x84>
 8016ad4:	683b      	ldr	r3, [r7, #0]
 8016ad6:	2b00      	cmp	r3, #0
 8016ad8:	d106      	bne.n	8016ae8 <rt_mq_recv+0x84>
    {
        rt_hw_interrupt_enable(temp);
 8016ada:	4623      	mov	r3, r4
 8016adc:	4618      	mov	r0, r3
 8016ade:	f7e9 fb77 	bl	80001d0 <rt_hw_interrupt_enable>

        return -RT_ETIMEOUT;
 8016ae2:	f06f 0301 	mvn.w	r3, #1
 8016ae6:	e0c2      	b.n	8016c6e <rt_mq_recv+0x20a>
    }

    /* message queue is empty */
    while (mq->entry == 0)
 8016ae8:	e07c      	b.n	8016be4 <rt_mq_recv+0x180>
    {
        RT_DEBUG_IN_THREAD_CONTEXT;
 8016aea:	f7e9 fb6d 	bl	80001c8 <rt_hw_interrupt_disable>
 8016aee:	61f8      	str	r0, [r7, #28]
 8016af0:	f002 f86e 	bl	8018bd0 <rt_thread_self>
 8016af4:	4603      	mov	r3, r0
 8016af6:	2b00      	cmp	r3, #0
 8016af8:	d109      	bne.n	8016b0e <rt_mq_recv+0xaa>
 8016afa:	4864      	ldr	r0, [pc, #400]	; (8016c8c <rt_mq_recv+0x228>)
 8016afc:	495f      	ldr	r1, [pc, #380]	; (8016c7c <rt_mq_recv+0x218>)
 8016afe:	f000 fedd 	bl	80178bc <rt_kprintf>
 8016b02:	4863      	ldr	r0, [pc, #396]	; (8016c90 <rt_mq_recv+0x22c>)
 8016b04:	495d      	ldr	r1, [pc, #372]	; (8016c7c <rt_mq_recv+0x218>)
 8016b06:	f640 0251 	movw	r2, #2129	; 0x851
 8016b0a:	f000 ff51 	bl	80179b0 <rt_assert_handler>
 8016b0e:	f7e9 fb5b 	bl	80001c8 <rt_hw_interrupt_disable>
 8016b12:	61b8      	str	r0, [r7, #24]
 8016b14:	f000 f8ee 	bl	8016cf4 <rt_interrupt_get_nest>
 8016b18:	4603      	mov	r3, r0
 8016b1a:	2b00      	cmp	r3, #0
 8016b1c:	d009      	beq.n	8016b32 <rt_mq_recv+0xce>
 8016b1e:	485d      	ldr	r0, [pc, #372]	; (8016c94 <rt_mq_recv+0x230>)
 8016b20:	4956      	ldr	r1, [pc, #344]	; (8016c7c <rt_mq_recv+0x218>)
 8016b22:	f000 fecb 	bl	80178bc <rt_kprintf>
 8016b26:	485a      	ldr	r0, [pc, #360]	; (8016c90 <rt_mq_recv+0x22c>)
 8016b28:	4954      	ldr	r1, [pc, #336]	; (8016c7c <rt_mq_recv+0x218>)
 8016b2a:	f640 0251 	movw	r2, #2129	; 0x851
 8016b2e:	f000 ff3f 	bl	80179b0 <rt_assert_handler>
 8016b32:	69b8      	ldr	r0, [r7, #24]
 8016b34:	f7e9 fb4c 	bl	80001d0 <rt_hw_interrupt_enable>
 8016b38:	69f8      	ldr	r0, [r7, #28]
 8016b3a:	f7e9 fb49 	bl	80001d0 <rt_hw_interrupt_enable>

        /* reset error number in thread */
        thread->error = RT_EOK;
 8016b3e:	6a3b      	ldr	r3, [r7, #32]
 8016b40:	2200      	movs	r2, #0
 8016b42:	631a      	str	r2, [r3, #48]	; 0x30

        /* no waiting, return timeout */
        if (timeout == 0)
 8016b44:	683b      	ldr	r3, [r7, #0]
 8016b46:	2b00      	cmp	r3, #0
 8016b48:	d10a      	bne.n	8016b60 <rt_mq_recv+0xfc>
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
 8016b4a:	4623      	mov	r3, r4
 8016b4c:	4618      	mov	r0, r3
 8016b4e:	f7e9 fb3f 	bl	80001d0 <rt_hw_interrupt_enable>

            thread->error = -RT_ETIMEOUT;
 8016b52:	6a3b      	ldr	r3, [r7, #32]
 8016b54:	f06f 0201 	mvn.w	r2, #1
 8016b58:	631a      	str	r2, [r3, #48]	; 0x30

            return -RT_ETIMEOUT;
 8016b5a:	f06f 0301 	mvn.w	r3, #1
 8016b5e:	e086      	b.n	8016c6e <rt_mq_recv+0x20a>
        }

        /* suspend current thread */
        rt_ipc_list_suspend(&(mq->parent.suspend_thread),
 8016b60:	68fb      	ldr	r3, [r7, #12]
 8016b62:	f103 0214 	add.w	r2, r3, #20
 8016b66:	68fb      	ldr	r3, [r7, #12]
 8016b68:	7a5b      	ldrb	r3, [r3, #9]
 8016b6a:	4610      	mov	r0, r2
 8016b6c:	6a39      	ldr	r1, [r7, #32]
 8016b6e:	461a      	mov	r2, r3
 8016b70:	f7ff faae 	bl	80160d0 <rt_ipc_list_suspend>
                            thread,
                            mq->parent.parent.flag);

        /* has waiting time, start thread timer */
        if (timeout > 0)
 8016b74:	683b      	ldr	r3, [r7, #0]
 8016b76:	2b00      	cmp	r3, #0
 8016b78:	dd10      	ble.n	8016b9c <rt_mq_recv+0x138>
        {
            /* get the start tick of timer */
            tick_delta = rt_tick_get();
 8016b7a:	f7fe ff5b 	bl	8015a34 <rt_tick_get>
 8016b7e:	6278      	str	r0, [r7, #36]	; 0x24

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
                                        thread->name));

            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
 8016b80:	6a3b      	ldr	r3, [r7, #32]
 8016b82:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 8016b86:	463b      	mov	r3, r7
 8016b88:	4610      	mov	r0, r2
 8016b8a:	2100      	movs	r1, #0
 8016b8c:	461a      	mov	r2, r3
 8016b8e:	f002 fc9f 	bl	80194d0 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
 8016b92:	6a3b      	ldr	r3, [r7, #32]
 8016b94:	334c      	adds	r3, #76	; 0x4c
 8016b96:	4618      	mov	r0, r3
 8016b98:	f002 fb54 	bl	8019244 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 8016b9c:	4623      	mov	r3, r4
 8016b9e:	4618      	mov	r0, r3
 8016ba0:	f7e9 fb16 	bl	80001d0 <rt_hw_interrupt_enable>

        /* re-schedule */
        rt_schedule();
 8016ba4:	f001 fdd8 	bl	8018758 <rt_schedule>

        /* recv message */
        if (thread->error != RT_EOK)
 8016ba8:	6a3b      	ldr	r3, [r7, #32]
 8016baa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8016bac:	2b00      	cmp	r3, #0
 8016bae:	d002      	beq.n	8016bb6 <rt_mq_recv+0x152>
        {
            /* return error */
            return thread->error;
 8016bb0:	6a3b      	ldr	r3, [r7, #32]
 8016bb2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8016bb4:	e05b      	b.n	8016c6e <rt_mq_recv+0x20a>
        }

        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
 8016bb6:	f7e9 fb07 	bl	80001c8 <rt_hw_interrupt_disable>
 8016bba:	4603      	mov	r3, r0
 8016bbc:	461c      	mov	r4, r3

        /* if it's not waiting forever and then re-calculate timeout tick */
        if (timeout > 0)
 8016bbe:	683b      	ldr	r3, [r7, #0]
 8016bc0:	2b00      	cmp	r3, #0
 8016bc2:	dd0f      	ble.n	8016be4 <rt_mq_recv+0x180>
        {
            tick_delta = rt_tick_get() - tick_delta;
 8016bc4:	f7fe ff36 	bl	8015a34 <rt_tick_get>
 8016bc8:	4602      	mov	r2, r0
 8016bca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016bcc:	1ad3      	subs	r3, r2, r3
 8016bce:	627b      	str	r3, [r7, #36]	; 0x24
            timeout -= tick_delta;
 8016bd0:	683b      	ldr	r3, [r7, #0]
 8016bd2:	461a      	mov	r2, r3
 8016bd4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016bd6:	1ad3      	subs	r3, r2, r3
 8016bd8:	603b      	str	r3, [r7, #0]
            if (timeout < 0)
 8016bda:	683b      	ldr	r3, [r7, #0]
 8016bdc:	2b00      	cmp	r3, #0
 8016bde:	da01      	bge.n	8016be4 <rt_mq_recv+0x180>
                timeout = 0;
 8016be0:	2300      	movs	r3, #0
 8016be2:	603b      	str	r3, [r7, #0]

        return -RT_ETIMEOUT;
    }

    /* message queue is empty */
    while (mq->entry == 0)
 8016be4:	68fb      	ldr	r3, [r7, #12]
 8016be6:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8016be8:	2b00      	cmp	r3, #0
 8016bea:	f43f af7e 	beq.w	8016aea <rt_mq_recv+0x86>
                timeout = 0;
        }
    }

    /* get message from queue */
    msg = (struct rt_mq_message *)mq->msg_queue_head;
 8016bee:	68fb      	ldr	r3, [r7, #12]
 8016bf0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8016bf2:	617b      	str	r3, [r7, #20]
	
    /* move message queue head */
    mq->msg_queue_head = msg->next;
 8016bf4:	697b      	ldr	r3, [r7, #20]
 8016bf6:	681a      	ldr	r2, [r3, #0]
 8016bf8:	68fb      	ldr	r3, [r7, #12]
 8016bfa:	629a      	str	r2, [r3, #40]	; 0x28
    /* reach queue tail, set to NULL */
    if (mq->msg_queue_tail == msg)
 8016bfc:	68fb      	ldr	r3, [r7, #12]
 8016bfe:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8016c00:	697b      	ldr	r3, [r7, #20]
 8016c02:	429a      	cmp	r2, r3
 8016c04:	d102      	bne.n	8016c0c <rt_mq_recv+0x1a8>
        mq->msg_queue_tail = RT_NULL;
 8016c06:	68fb      	ldr	r3, [r7, #12]
 8016c08:	2200      	movs	r2, #0
 8016c0a:	62da      	str	r2, [r3, #44]	; 0x2c

    /* decrease message entry */
    mq->entry --;
 8016c0c:	68fb      	ldr	r3, [r7, #12]
 8016c0e:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8016c10:	3b01      	subs	r3, #1
 8016c12:	b29a      	uxth	r2, r3
 8016c14:	68fb      	ldr	r3, [r7, #12]
 8016c16:	849a      	strh	r2, [r3, #36]	; 0x24

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8016c18:	4623      	mov	r3, r4
 8016c1a:	4618      	mov	r0, r3
 8016c1c:	f7e9 fad8 	bl	80001d0 <rt_hw_interrupt_enable>

    /* copy message */
    rt_memcpy(buffer, msg + 1, size > mq->msg_size ? mq->msg_size : size);
 8016c20:	697b      	ldr	r3, [r7, #20]
 8016c22:	1d1a      	adds	r2, r3, #4
 8016c24:	68fb      	ldr	r3, [r7, #12]
 8016c26:	8c1b      	ldrh	r3, [r3, #32]
 8016c28:	4619      	mov	r1, r3
 8016c2a:	687b      	ldr	r3, [r7, #4]
 8016c2c:	428b      	cmp	r3, r1
 8016c2e:	bf28      	it	cs
 8016c30:	460b      	movcs	r3, r1
 8016c32:	68b8      	ldr	r0, [r7, #8]
 8016c34:	4611      	mov	r1, r2
 8016c36:	461a      	mov	r2, r3
 8016c38:	f000 f8e4 	bl	8016e04 <rt_memcpy>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8016c3c:	f7e9 fac4 	bl	80001c8 <rt_hw_interrupt_disable>
 8016c40:	4603      	mov	r3, r0
 8016c42:	461c      	mov	r4, r3
    /* put message to free list */
    msg->next = (struct rt_mq_message *)mq->msg_queue_free;
 8016c44:	68fb      	ldr	r3, [r7, #12]
 8016c46:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8016c48:	697b      	ldr	r3, [r7, #20]
 8016c4a:	601a      	str	r2, [r3, #0]
    mq->msg_queue_free = msg;
 8016c4c:	68fb      	ldr	r3, [r7, #12]
 8016c4e:	697a      	ldr	r2, [r7, #20]
 8016c50:	631a      	str	r2, [r3, #48]	; 0x30
    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8016c52:	4623      	mov	r3, r4
 8016c54:	4618      	mov	r0, r3
 8016c56:	f7e9 fabb 	bl	80001d0 <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mq->parent.parent)));
 8016c5a:	4b0f      	ldr	r3, [pc, #60]	; (8016c98 <rt_mq_recv+0x234>)
 8016c5c:	681b      	ldr	r3, [r3, #0]
 8016c5e:	2b00      	cmp	r3, #0
 8016c60:	d004      	beq.n	8016c6c <rt_mq_recv+0x208>
 8016c62:	4b0d      	ldr	r3, [pc, #52]	; (8016c98 <rt_mq_recv+0x234>)
 8016c64:	681b      	ldr	r3, [r3, #0]
 8016c66:	68fa      	ldr	r2, [r7, #12]
 8016c68:	4610      	mov	r0, r2
 8016c6a:	4798      	blx	r3

    return RT_EOK;
 8016c6c:	2300      	movs	r3, #0
}
 8016c6e:	4618      	mov	r0, r3
 8016c70:	372c      	adds	r7, #44	; 0x2c
 8016c72:	46bd      	mov	sp, r7
 8016c74:	bd90      	pop	{r4, r7, pc}
 8016c76:	bf00      	nop
 8016c78:	0802765c 	.word	0x0802765c
 8016c7c:	08028f38 	.word	0x08028f38
 8016c80:	0802766c 	.word	0x0802766c
 8016c84:	08027680 	.word	0x08027680
 8016c88:	20012a48 	.word	0x20012a48
 8016c8c:	080275ec 	.word	0x080275ec
 8016c90:	080275e8 	.word	0x080275e8
 8016c94:	080275c4 	.word	0x080275c4
 8016c98:	20012a44 	.word	0x20012a44

08016c9c <rt_interrupt_enter>:
 * @note please don't invoke this routine in application
 *
 * @see rt_interrupt_leave
 */
void rt_interrupt_enter(void)
{
 8016c9c:	b580      	push	{r7, lr}
 8016c9e:	b082      	sub	sp, #8
 8016ca0:	af00      	add	r7, sp, #0
    rt_base_t level;

    RT_DEBUG_LOG(RT_DEBUG_IRQ, ("irq coming..., irq nest:%d\n",
                                rt_interrupt_nest));

    level = rt_hw_interrupt_disable();
 8016ca2:	f7e9 fa91 	bl	80001c8 <rt_hw_interrupt_disable>
 8016ca6:	6078      	str	r0, [r7, #4]
    rt_interrupt_nest ++;
 8016ca8:	4b06      	ldr	r3, [pc, #24]	; (8016cc4 <rt_interrupt_enter+0x28>)
 8016caa:	781b      	ldrb	r3, [r3, #0]
 8016cac:	b2db      	uxtb	r3, r3
 8016cae:	3301      	adds	r3, #1
 8016cb0:	b2da      	uxtb	r2, r3
 8016cb2:	4b04      	ldr	r3, [pc, #16]	; (8016cc4 <rt_interrupt_enter+0x28>)
 8016cb4:	701a      	strb	r2, [r3, #0]
    rt_hw_interrupt_enable(level);
 8016cb6:	6878      	ldr	r0, [r7, #4]
 8016cb8:	f7e9 fa8a 	bl	80001d0 <rt_hw_interrupt_enable>
}
 8016cbc:	3708      	adds	r7, #8
 8016cbe:	46bd      	mov	sp, r7
 8016cc0:	bd80      	pop	{r7, pc}
 8016cc2:	bf00      	nop
 8016cc4:	20012a38 	.word	0x20012a38

08016cc8 <rt_interrupt_leave>:
 * @note please don't invoke this routine in application
 *
 * @see rt_interrupt_enter
 */
void rt_interrupt_leave(void)
{
 8016cc8:	b580      	push	{r7, lr}
 8016cca:	b082      	sub	sp, #8
 8016ccc:	af00      	add	r7, sp, #0
    rt_base_t level;

    RT_DEBUG_LOG(RT_DEBUG_IRQ, ("irq leave, irq nest:%d\n",
                                rt_interrupt_nest));

    level = rt_hw_interrupt_disable();
 8016cce:	f7e9 fa7b 	bl	80001c8 <rt_hw_interrupt_disable>
 8016cd2:	6078      	str	r0, [r7, #4]
    rt_interrupt_nest --;
 8016cd4:	4b06      	ldr	r3, [pc, #24]	; (8016cf0 <rt_interrupt_leave+0x28>)
 8016cd6:	781b      	ldrb	r3, [r3, #0]
 8016cd8:	b2db      	uxtb	r3, r3
 8016cda:	3b01      	subs	r3, #1
 8016cdc:	b2da      	uxtb	r2, r3
 8016cde:	4b04      	ldr	r3, [pc, #16]	; (8016cf0 <rt_interrupt_leave+0x28>)
 8016ce0:	701a      	strb	r2, [r3, #0]
    rt_hw_interrupt_enable(level);
 8016ce2:	6878      	ldr	r0, [r7, #4]
 8016ce4:	f7e9 fa74 	bl	80001d0 <rt_hw_interrupt_enable>
}
 8016ce8:	3708      	adds	r7, #8
 8016cea:	46bd      	mov	sp, r7
 8016cec:	bd80      	pop	{r7, pc}
 8016cee:	bf00      	nop
 8016cf0:	20012a38 	.word	0x20012a38

08016cf4 <rt_interrupt_get_nest>:
 * context is interrupt context.
 *
 * @return the number of nested interrupts.
 */
rt_uint8_t rt_interrupt_get_nest(void)
{
 8016cf4:	b480      	push	{r7}
 8016cf6:	af00      	add	r7, sp, #0
    return rt_interrupt_nest;
 8016cf8:	4b03      	ldr	r3, [pc, #12]	; (8016d08 <rt_interrupt_get_nest+0x14>)
 8016cfa:	781b      	ldrb	r3, [r3, #0]
 8016cfc:	b2db      	uxtb	r3, r3
}
 8016cfe:	4618      	mov	r0, r3
 8016d00:	46bd      	mov	sp, r7
 8016d02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016d06:	4770      	bx	lr
 8016d08:	20012a38 	.word	0x20012a38

08016d0c <rt_set_errno>:
 * This function will set errno
 *
 * @param error the errno shall be set
 */
void rt_set_errno(rt_err_t error)
{
 8016d0c:	b580      	push	{r7, lr}
 8016d0e:	b084      	sub	sp, #16
 8016d10:	af00      	add	r7, sp, #0
 8016d12:	6078      	str	r0, [r7, #4]
    rt_thread_t tid;

    if (rt_interrupt_get_nest() != 0)
 8016d14:	f7ff ffee 	bl	8016cf4 <rt_interrupt_get_nest>
 8016d18:	4603      	mov	r3, r0
 8016d1a:	2b00      	cmp	r3, #0
 8016d1c:	d003      	beq.n	8016d26 <rt_set_errno+0x1a>
    {
        /* it's in interrupt context */
        _errno = error;
 8016d1e:	4a0a      	ldr	r2, [pc, #40]	; (8016d48 <rt_set_errno+0x3c>)
 8016d20:	687b      	ldr	r3, [r7, #4]
 8016d22:	6013      	str	r3, [r2, #0]

        return;
 8016d24:	e00c      	b.n	8016d40 <rt_set_errno+0x34>
    }

    tid = rt_thread_self();
 8016d26:	f001 ff53 	bl	8018bd0 <rt_thread_self>
 8016d2a:	60f8      	str	r0, [r7, #12]
    if (tid == RT_NULL)
 8016d2c:	68fb      	ldr	r3, [r7, #12]
 8016d2e:	2b00      	cmp	r3, #0
 8016d30:	d103      	bne.n	8016d3a <rt_set_errno+0x2e>
    {
        _errno = error;
 8016d32:	4a05      	ldr	r2, [pc, #20]	; (8016d48 <rt_set_errno+0x3c>)
 8016d34:	687b      	ldr	r3, [r7, #4]
 8016d36:	6013      	str	r3, [r2, #0]

        return;
 8016d38:	e002      	b.n	8016d40 <rt_set_errno+0x34>
    }

    tid->error = error;
 8016d3a:	68fb      	ldr	r3, [r7, #12]
 8016d3c:	687a      	ldr	r2, [r7, #4]
 8016d3e:	631a      	str	r2, [r3, #48]	; 0x30
}
 8016d40:	3710      	adds	r7, #16
 8016d42:	46bd      	mov	sp, r7
 8016d44:	bd80      	pop	{r7, pc}
 8016d46:	bf00      	nop
 8016d48:	20010cd0 	.word	0x20010cd0

08016d4c <rt_memset>:
 * @param count the copied length
 *
 * @return the address of source memory
 */
void *rt_memset(void *s, int c, rt_ubase_t count)
{
 8016d4c:	b480      	push	{r7}
 8016d4e:	b089      	sub	sp, #36	; 0x24
 8016d50:	af00      	add	r7, sp, #0
 8016d52:	60f8      	str	r0, [r7, #12]
 8016d54:	60b9      	str	r1, [r7, #8]
 8016d56:	607a      	str	r2, [r7, #4]
#define LBLOCKSIZE      (sizeof(rt_int32_t))
#define UNALIGNED(X)    ((rt_int32_t)X & (LBLOCKSIZE - 1))
#define TOO_SMALL(LEN)  ((LEN) < LBLOCKSIZE)

    int i;
    char *m = (char *)s;
 8016d58:	68fb      	ldr	r3, [r7, #12]
 8016d5a:	61fb      	str	r3, [r7, #28]
    rt_uint32_t buffer;
    rt_uint32_t *aligned_addr;
    rt_uint32_t d = c & 0xff;
 8016d5c:	68bb      	ldr	r3, [r7, #8]
 8016d5e:	b2db      	uxtb	r3, r3
 8016d60:	617b      	str	r3, [r7, #20]

    if (!TOO_SMALL(count) && !UNALIGNED(s))
 8016d62:	687b      	ldr	r3, [r7, #4]
 8016d64:	2b03      	cmp	r3, #3
 8016d66:	d939      	bls.n	8016ddc <rt_memset+0x90>
 8016d68:	68fb      	ldr	r3, [r7, #12]
 8016d6a:	f003 0303 	and.w	r3, r3, #3
 8016d6e:	2b00      	cmp	r3, #0
 8016d70:	d134      	bne.n	8016ddc <rt_memset+0x90>
    {
        /* If we get this far, we know that n is large and m is word-aligned. */
        aligned_addr = (rt_uint32_t *)s;
 8016d72:	68fb      	ldr	r3, [r7, #12]
 8016d74:	61bb      	str	r3, [r7, #24]
        /* Store D into each char sized location in BUFFER so that
         * we can set large blocks quickly.
         */
        if (LBLOCKSIZE == 4)
        {
            buffer = (d << 8) | d;
 8016d76:	697b      	ldr	r3, [r7, #20]
 8016d78:	021a      	lsls	r2, r3, #8
 8016d7a:	697b      	ldr	r3, [r7, #20]
 8016d7c:	4313      	orrs	r3, r2
 8016d7e:	613b      	str	r3, [r7, #16]
            buffer |= (buffer << 16);
 8016d80:	693b      	ldr	r3, [r7, #16]
 8016d82:	041b      	lsls	r3, r3, #16
 8016d84:	693a      	ldr	r2, [r7, #16]
 8016d86:	4313      	orrs	r3, r2
 8016d88:	613b      	str	r3, [r7, #16]
            buffer = 0;
            for (i = 0; i < LBLOCKSIZE; i ++)
                buffer = (buffer << 8) | d;
        }

        while (count >= LBLOCKSIZE * 4)
 8016d8a:	e016      	b.n	8016dba <rt_memset+0x6e>
        {
            *aligned_addr++ = buffer;
 8016d8c:	69bb      	ldr	r3, [r7, #24]
 8016d8e:	1d1a      	adds	r2, r3, #4
 8016d90:	61ba      	str	r2, [r7, #24]
 8016d92:	693a      	ldr	r2, [r7, #16]
 8016d94:	601a      	str	r2, [r3, #0]
            *aligned_addr++ = buffer;
 8016d96:	69bb      	ldr	r3, [r7, #24]
 8016d98:	1d1a      	adds	r2, r3, #4
 8016d9a:	61ba      	str	r2, [r7, #24]
 8016d9c:	693a      	ldr	r2, [r7, #16]
 8016d9e:	601a      	str	r2, [r3, #0]
            *aligned_addr++ = buffer;
 8016da0:	69bb      	ldr	r3, [r7, #24]
 8016da2:	1d1a      	adds	r2, r3, #4
 8016da4:	61ba      	str	r2, [r7, #24]
 8016da6:	693a      	ldr	r2, [r7, #16]
 8016da8:	601a      	str	r2, [r3, #0]
            *aligned_addr++ = buffer;
 8016daa:	69bb      	ldr	r3, [r7, #24]
 8016dac:	1d1a      	adds	r2, r3, #4
 8016dae:	61ba      	str	r2, [r7, #24]
 8016db0:	693a      	ldr	r2, [r7, #16]
 8016db2:	601a      	str	r2, [r3, #0]
            count -= 4 * LBLOCKSIZE;
 8016db4:	687b      	ldr	r3, [r7, #4]
 8016db6:	3b10      	subs	r3, #16
 8016db8:	607b      	str	r3, [r7, #4]
            buffer = 0;
            for (i = 0; i < LBLOCKSIZE; i ++)
                buffer = (buffer << 8) | d;
        }

        while (count >= LBLOCKSIZE * 4)
 8016dba:	687b      	ldr	r3, [r7, #4]
 8016dbc:	2b0f      	cmp	r3, #15
 8016dbe:	d8e5      	bhi.n	8016d8c <rt_memset+0x40>
            *aligned_addr++ = buffer;
            *aligned_addr++ = buffer;
            count -= 4 * LBLOCKSIZE;
        }

        while (count >= LBLOCKSIZE)
 8016dc0:	e007      	b.n	8016dd2 <rt_memset+0x86>
        {
            *aligned_addr++ = buffer;
 8016dc2:	69bb      	ldr	r3, [r7, #24]
 8016dc4:	1d1a      	adds	r2, r3, #4
 8016dc6:	61ba      	str	r2, [r7, #24]
 8016dc8:	693a      	ldr	r2, [r7, #16]
 8016dca:	601a      	str	r2, [r3, #0]
            count -= LBLOCKSIZE;
 8016dcc:	687b      	ldr	r3, [r7, #4]
 8016dce:	3b04      	subs	r3, #4
 8016dd0:	607b      	str	r3, [r7, #4]
            *aligned_addr++ = buffer;
            *aligned_addr++ = buffer;
            count -= 4 * LBLOCKSIZE;
        }

        while (count >= LBLOCKSIZE)
 8016dd2:	687b      	ldr	r3, [r7, #4]
 8016dd4:	2b03      	cmp	r3, #3
 8016dd6:	d8f4      	bhi.n	8016dc2 <rt_memset+0x76>
            *aligned_addr++ = buffer;
            count -= LBLOCKSIZE;
        }

        /* Pick up the remainder with a bytewise loop. */
        m = (char *)aligned_addr;
 8016dd8:	69bb      	ldr	r3, [r7, #24]
 8016dda:	61fb      	str	r3, [r7, #28]
    }

    while (count--)
 8016ddc:	e005      	b.n	8016dea <rt_memset+0x9e>
    {
        *m++ = (char)d;
 8016dde:	69fb      	ldr	r3, [r7, #28]
 8016de0:	1c5a      	adds	r2, r3, #1
 8016de2:	61fa      	str	r2, [r7, #28]
 8016de4:	697a      	ldr	r2, [r7, #20]
 8016de6:	b2d2      	uxtb	r2, r2
 8016de8:	701a      	strb	r2, [r3, #0]

        /* Pick up the remainder with a bytewise loop. */
        m = (char *)aligned_addr;
    }

    while (count--)
 8016dea:	687b      	ldr	r3, [r7, #4]
 8016dec:	1e5a      	subs	r2, r3, #1
 8016dee:	607a      	str	r2, [r7, #4]
 8016df0:	2b00      	cmp	r3, #0
 8016df2:	d1f4      	bne.n	8016dde <rt_memset+0x92>
    {
        *m++ = (char)d;
    }

    return s;
 8016df4:	68fb      	ldr	r3, [r7, #12]

#undef LBLOCKSIZE
#undef UNALIGNED
#undef TOO_SMALL
#endif
}
 8016df6:	4618      	mov	r0, r3
 8016df8:	3724      	adds	r7, #36	; 0x24
 8016dfa:	46bd      	mov	sp, r7
 8016dfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016e00:	4770      	bx	lr
 8016e02:	bf00      	nop

08016e04 <rt_memcpy>:
 * @param count the copied length
 *
 * @return the address of destination memory
 */
void *rt_memcpy(void *dst, const void *src, rt_ubase_t count)
{
 8016e04:	b480      	push	{r7}
 8016e06:	b08b      	sub	sp, #44	; 0x2c
 8016e08:	af00      	add	r7, sp, #0
 8016e0a:	60f8      	str	r0, [r7, #12]
 8016e0c:	60b9      	str	r1, [r7, #8]
 8016e0e:	607a      	str	r2, [r7, #4]
                         ((rt_int32_t)Y & (sizeof(rt_int32_t) - 1)))
#define BIGBLOCKSIZE    (sizeof(rt_int32_t) << 2)
#define LITTLEBLOCKSIZE (sizeof(rt_int32_t))
#define TOO_SMALL(LEN)  ((LEN) < BIGBLOCKSIZE)

    char *dst_ptr = (char *)dst;
 8016e10:	68fb      	ldr	r3, [r7, #12]
 8016e12:	627b      	str	r3, [r7, #36]	; 0x24
    char *src_ptr = (char *)src;
 8016e14:	68bb      	ldr	r3, [r7, #8]
 8016e16:	623b      	str	r3, [r7, #32]
    rt_int32_t *aligned_dst;
    rt_int32_t *aligned_src;
    int len = count;
 8016e18:	687b      	ldr	r3, [r7, #4]
 8016e1a:	617b      	str	r3, [r7, #20]

    /* If the size is small, or either SRC or DST is unaligned,
    then punt into the byte copy loop.  This should be rare. */
    if (!TOO_SMALL(len) && !UNALIGNED(src_ptr, dst_ptr))
 8016e1c:	697b      	ldr	r3, [r7, #20]
 8016e1e:	2b0f      	cmp	r3, #15
 8016e20:	d944      	bls.n	8016eac <rt_memcpy+0xa8>
 8016e22:	6a3a      	ldr	r2, [r7, #32]
 8016e24:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016e26:	4313      	orrs	r3, r2
 8016e28:	f003 0303 	and.w	r3, r3, #3
 8016e2c:	2b00      	cmp	r3, #0
 8016e2e:	d13d      	bne.n	8016eac <rt_memcpy+0xa8>
    {
        aligned_dst = (rt_int32_t *)dst_ptr;
 8016e30:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016e32:	61fb      	str	r3, [r7, #28]
        aligned_src = (rt_int32_t *)src_ptr;
 8016e34:	6a3b      	ldr	r3, [r7, #32]
 8016e36:	61bb      	str	r3, [r7, #24]

        /* Copy 4X long words at a time if possible. */
        while (len >= BIGBLOCKSIZE)
 8016e38:	e022      	b.n	8016e80 <rt_memcpy+0x7c>
        {
            *aligned_dst++ = *aligned_src++;
 8016e3a:	69fb      	ldr	r3, [r7, #28]
 8016e3c:	1d1a      	adds	r2, r3, #4
 8016e3e:	61fa      	str	r2, [r7, #28]
 8016e40:	69ba      	ldr	r2, [r7, #24]
 8016e42:	1d11      	adds	r1, r2, #4
 8016e44:	61b9      	str	r1, [r7, #24]
 8016e46:	6812      	ldr	r2, [r2, #0]
 8016e48:	601a      	str	r2, [r3, #0]
            *aligned_dst++ = *aligned_src++;
 8016e4a:	69fb      	ldr	r3, [r7, #28]
 8016e4c:	1d1a      	adds	r2, r3, #4
 8016e4e:	61fa      	str	r2, [r7, #28]
 8016e50:	69ba      	ldr	r2, [r7, #24]
 8016e52:	1d11      	adds	r1, r2, #4
 8016e54:	61b9      	str	r1, [r7, #24]
 8016e56:	6812      	ldr	r2, [r2, #0]
 8016e58:	601a      	str	r2, [r3, #0]
            *aligned_dst++ = *aligned_src++;
 8016e5a:	69fb      	ldr	r3, [r7, #28]
 8016e5c:	1d1a      	adds	r2, r3, #4
 8016e5e:	61fa      	str	r2, [r7, #28]
 8016e60:	69ba      	ldr	r2, [r7, #24]
 8016e62:	1d11      	adds	r1, r2, #4
 8016e64:	61b9      	str	r1, [r7, #24]
 8016e66:	6812      	ldr	r2, [r2, #0]
 8016e68:	601a      	str	r2, [r3, #0]
            *aligned_dst++ = *aligned_src++;
 8016e6a:	69fb      	ldr	r3, [r7, #28]
 8016e6c:	1d1a      	adds	r2, r3, #4
 8016e6e:	61fa      	str	r2, [r7, #28]
 8016e70:	69ba      	ldr	r2, [r7, #24]
 8016e72:	1d11      	adds	r1, r2, #4
 8016e74:	61b9      	str	r1, [r7, #24]
 8016e76:	6812      	ldr	r2, [r2, #0]
 8016e78:	601a      	str	r2, [r3, #0]
            len -= BIGBLOCKSIZE;
 8016e7a:	697b      	ldr	r3, [r7, #20]
 8016e7c:	3b10      	subs	r3, #16
 8016e7e:	617b      	str	r3, [r7, #20]
    {
        aligned_dst = (rt_int32_t *)dst_ptr;
        aligned_src = (rt_int32_t *)src_ptr;

        /* Copy 4X long words at a time if possible. */
        while (len >= BIGBLOCKSIZE)
 8016e80:	697b      	ldr	r3, [r7, #20]
 8016e82:	2b0f      	cmp	r3, #15
 8016e84:	d8d9      	bhi.n	8016e3a <rt_memcpy+0x36>
            *aligned_dst++ = *aligned_src++;
            len -= BIGBLOCKSIZE;
        }

        /* Copy one long word at a time if possible. */
        while (len >= LITTLEBLOCKSIZE)
 8016e86:	e00a      	b.n	8016e9e <rt_memcpy+0x9a>
        {
            *aligned_dst++ = *aligned_src++;
 8016e88:	69fb      	ldr	r3, [r7, #28]
 8016e8a:	1d1a      	adds	r2, r3, #4
 8016e8c:	61fa      	str	r2, [r7, #28]
 8016e8e:	69ba      	ldr	r2, [r7, #24]
 8016e90:	1d11      	adds	r1, r2, #4
 8016e92:	61b9      	str	r1, [r7, #24]
 8016e94:	6812      	ldr	r2, [r2, #0]
 8016e96:	601a      	str	r2, [r3, #0]
            len -= LITTLEBLOCKSIZE;
 8016e98:	697b      	ldr	r3, [r7, #20]
 8016e9a:	3b04      	subs	r3, #4
 8016e9c:	617b      	str	r3, [r7, #20]
            *aligned_dst++ = *aligned_src++;
            len -= BIGBLOCKSIZE;
        }

        /* Copy one long word at a time if possible. */
        while (len >= LITTLEBLOCKSIZE)
 8016e9e:	697b      	ldr	r3, [r7, #20]
 8016ea0:	2b03      	cmp	r3, #3
 8016ea2:	d8f1      	bhi.n	8016e88 <rt_memcpy+0x84>
            *aligned_dst++ = *aligned_src++;
            len -= LITTLEBLOCKSIZE;
        }

        /* Pick up any residual with a byte copier. */
        dst_ptr = (char *)aligned_dst;
 8016ea4:	69fb      	ldr	r3, [r7, #28]
 8016ea6:	627b      	str	r3, [r7, #36]	; 0x24
        src_ptr = (char *)aligned_src;
 8016ea8:	69bb      	ldr	r3, [r7, #24]
 8016eaa:	623b      	str	r3, [r7, #32]
    }

    while (len--)
 8016eac:	e007      	b.n	8016ebe <rt_memcpy+0xba>
        *dst_ptr++ = *src_ptr++;
 8016eae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016eb0:	1c5a      	adds	r2, r3, #1
 8016eb2:	627a      	str	r2, [r7, #36]	; 0x24
 8016eb4:	6a3a      	ldr	r2, [r7, #32]
 8016eb6:	1c51      	adds	r1, r2, #1
 8016eb8:	6239      	str	r1, [r7, #32]
 8016eba:	7812      	ldrb	r2, [r2, #0]
 8016ebc:	701a      	strb	r2, [r3, #0]
        /* Pick up any residual with a byte copier. */
        dst_ptr = (char *)aligned_dst;
        src_ptr = (char *)aligned_src;
    }

    while (len--)
 8016ebe:	697b      	ldr	r3, [r7, #20]
 8016ec0:	1e5a      	subs	r2, r3, #1
 8016ec2:	617a      	str	r2, [r7, #20]
 8016ec4:	2b00      	cmp	r3, #0
 8016ec6:	d1f2      	bne.n	8016eae <rt_memcpy+0xaa>
        *dst_ptr++ = *src_ptr++;

    return dst;
 8016ec8:	68fb      	ldr	r3, [r7, #12]
#undef UNALIGNED
#undef BIGBLOCKSIZE
#undef LITTLEBLOCKSIZE
#undef TOO_SMALL
#endif
}
 8016eca:	4618      	mov	r0, r3
 8016ecc:	372c      	adds	r7, #44	; 0x2c
 8016ece:	46bd      	mov	sp, r7
 8016ed0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016ed4:	4770      	bx	lr
 8016ed6:	bf00      	nop

08016ed8 <rt_memmove>:
 * @param n the copied length
 *
 * @return the address of destination memory
 */
void *rt_memmove(void *dest, const void *src, rt_ubase_t n)
{
 8016ed8:	b480      	push	{r7}
 8016eda:	b087      	sub	sp, #28
 8016edc:	af00      	add	r7, sp, #0
 8016ede:	60f8      	str	r0, [r7, #12]
 8016ee0:	60b9      	str	r1, [r7, #8]
 8016ee2:	607a      	str	r2, [r7, #4]
    char *tmp = (char *)dest, *s = (char *)src;
 8016ee4:	68fb      	ldr	r3, [r7, #12]
 8016ee6:	617b      	str	r3, [r7, #20]
 8016ee8:	68bb      	ldr	r3, [r7, #8]
 8016eea:	613b      	str	r3, [r7, #16]

    if (s < tmp && tmp < s + n)
 8016eec:	693a      	ldr	r2, [r7, #16]
 8016eee:	697b      	ldr	r3, [r7, #20]
 8016ef0:	429a      	cmp	r2, r3
 8016ef2:	d21e      	bcs.n	8016f32 <rt_memmove+0x5a>
 8016ef4:	693a      	ldr	r2, [r7, #16]
 8016ef6:	687b      	ldr	r3, [r7, #4]
 8016ef8:	441a      	add	r2, r3
 8016efa:	697b      	ldr	r3, [r7, #20]
 8016efc:	429a      	cmp	r2, r3
 8016efe:	d918      	bls.n	8016f32 <rt_memmove+0x5a>
    {
        tmp += n;
 8016f00:	697a      	ldr	r2, [r7, #20]
 8016f02:	687b      	ldr	r3, [r7, #4]
 8016f04:	4413      	add	r3, r2
 8016f06:	617b      	str	r3, [r7, #20]
        s += n;
 8016f08:	693a      	ldr	r2, [r7, #16]
 8016f0a:	687b      	ldr	r3, [r7, #4]
 8016f0c:	4413      	add	r3, r2
 8016f0e:	613b      	str	r3, [r7, #16]

        while (n--)
 8016f10:	e009      	b.n	8016f26 <rt_memmove+0x4e>
            *(--tmp) = *(--s);
 8016f12:	697b      	ldr	r3, [r7, #20]
 8016f14:	3b01      	subs	r3, #1
 8016f16:	617b      	str	r3, [r7, #20]
 8016f18:	693b      	ldr	r3, [r7, #16]
 8016f1a:	3b01      	subs	r3, #1
 8016f1c:	613b      	str	r3, [r7, #16]
 8016f1e:	693b      	ldr	r3, [r7, #16]
 8016f20:	781a      	ldrb	r2, [r3, #0]
 8016f22:	697b      	ldr	r3, [r7, #20]
 8016f24:	701a      	strb	r2, [r3, #0]
    if (s < tmp && tmp < s + n)
    {
        tmp += n;
        s += n;

        while (n--)
 8016f26:	687b      	ldr	r3, [r7, #4]
 8016f28:	1e5a      	subs	r2, r3, #1
 8016f2a:	607a      	str	r2, [r7, #4]
 8016f2c:	2b00      	cmp	r3, #0
 8016f2e:	d1f0      	bne.n	8016f12 <rt_memmove+0x3a>
 */
void *rt_memmove(void *dest, const void *src, rt_ubase_t n)
{
    char *tmp = (char *)dest, *s = (char *)src;

    if (s < tmp && tmp < s + n)
 8016f30:	e00d      	b.n	8016f4e <rt_memmove+0x76>
        while (n--)
            *(--tmp) = *(--s);
    }
    else
    {
        while (n--)
 8016f32:	e007      	b.n	8016f44 <rt_memmove+0x6c>
            *tmp++ = *s++;
 8016f34:	697b      	ldr	r3, [r7, #20]
 8016f36:	1c5a      	adds	r2, r3, #1
 8016f38:	617a      	str	r2, [r7, #20]
 8016f3a:	693a      	ldr	r2, [r7, #16]
 8016f3c:	1c51      	adds	r1, r2, #1
 8016f3e:	6139      	str	r1, [r7, #16]
 8016f40:	7812      	ldrb	r2, [r2, #0]
 8016f42:	701a      	strb	r2, [r3, #0]
        while (n--)
            *(--tmp) = *(--s);
    }
    else
    {
        while (n--)
 8016f44:	687b      	ldr	r3, [r7, #4]
 8016f46:	1e5a      	subs	r2, r3, #1
 8016f48:	607a      	str	r2, [r7, #4]
 8016f4a:	2b00      	cmp	r3, #0
 8016f4c:	d1f2      	bne.n	8016f34 <rt_memmove+0x5c>
            *tmp++ = *s++;
    }

    return dest;
 8016f4e:	68fb      	ldr	r3, [r7, #12]
}
 8016f50:	4618      	mov	r0, r3
 8016f52:	371c      	adds	r7, #28
 8016f54:	46bd      	mov	sp, r7
 8016f56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016f5a:	4770      	bx	lr

08016f5c <rt_strncpy>:
 * @param n the maximum copied length
 *
 * @return the result
 */
char *rt_strncpy(char *dst, const char *src, rt_ubase_t n)
{
 8016f5c:	b480      	push	{r7}
 8016f5e:	b087      	sub	sp, #28
 8016f60:	af00      	add	r7, sp, #0
 8016f62:	60f8      	str	r0, [r7, #12]
 8016f64:	60b9      	str	r1, [r7, #8]
 8016f66:	607a      	str	r2, [r7, #4]
    if (n != 0)
 8016f68:	687b      	ldr	r3, [r7, #4]
 8016f6a:	2b00      	cmp	r3, #0
 8016f6c:	d021      	beq.n	8016fb2 <rt_strncpy+0x56>
    {
        char *d = dst;
 8016f6e:	68fb      	ldr	r3, [r7, #12]
 8016f70:	617b      	str	r3, [r7, #20]
        const char *s = src;
 8016f72:	68bb      	ldr	r3, [r7, #8]
 8016f74:	613b      	str	r3, [r7, #16]

        do
        {
            if ((*d++ = *s++) == 0)
 8016f76:	697b      	ldr	r3, [r7, #20]
 8016f78:	1c5a      	adds	r2, r3, #1
 8016f7a:	617a      	str	r2, [r7, #20]
 8016f7c:	693a      	ldr	r2, [r7, #16]
 8016f7e:	1c51      	adds	r1, r2, #1
 8016f80:	6139      	str	r1, [r7, #16]
 8016f82:	7812      	ldrb	r2, [r2, #0]
 8016f84:	701a      	strb	r2, [r3, #0]
 8016f86:	781b      	ldrb	r3, [r3, #0]
 8016f88:	2b00      	cmp	r3, #0
 8016f8a:	d10c      	bne.n	8016fa6 <rt_strncpy+0x4a>
            {
                /* NUL pad the remaining n-1 bytes */
                while (--n != 0)
 8016f8c:	e004      	b.n	8016f98 <rt_strncpy+0x3c>
                    *d++ = 0;
 8016f8e:	697b      	ldr	r3, [r7, #20]
 8016f90:	1c5a      	adds	r2, r3, #1
 8016f92:	617a      	str	r2, [r7, #20]
 8016f94:	2200      	movs	r2, #0
 8016f96:	701a      	strb	r2, [r3, #0]
        do
        {
            if ((*d++ = *s++) == 0)
            {
                /* NUL pad the remaining n-1 bytes */
                while (--n != 0)
 8016f98:	687b      	ldr	r3, [r7, #4]
 8016f9a:	3b01      	subs	r3, #1
 8016f9c:	607b      	str	r3, [r7, #4]
 8016f9e:	687b      	ldr	r3, [r7, #4]
 8016fa0:	2b00      	cmp	r3, #0
 8016fa2:	d1f4      	bne.n	8016f8e <rt_strncpy+0x32>
                    *d++ = 0;
                break;
 8016fa4:	e005      	b.n	8016fb2 <rt_strncpy+0x56>
            }
        } while (--n != 0);
 8016fa6:	687b      	ldr	r3, [r7, #4]
 8016fa8:	3b01      	subs	r3, #1
 8016faa:	607b      	str	r3, [r7, #4]
 8016fac:	687b      	ldr	r3, [r7, #4]
 8016fae:	2b00      	cmp	r3, #0
 8016fb0:	d1e1      	bne.n	8016f76 <rt_strncpy+0x1a>
    }

    return (dst);
 8016fb2:	68fb      	ldr	r3, [r7, #12]
}
 8016fb4:	4618      	mov	r0, r3
 8016fb6:	371c      	adds	r7, #28
 8016fb8:	46bd      	mov	sp, r7
 8016fba:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016fbe:	4770      	bx	lr

08016fc0 <rt_strncmp>:
 * @param count the maximum compare length
 *
 * @return the result
 */
rt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count)
{
 8016fc0:	b490      	push	{r4, r7}
 8016fc2:	b084      	sub	sp, #16
 8016fc4:	af00      	add	r7, sp, #0
 8016fc6:	60f8      	str	r0, [r7, #12]
 8016fc8:	60b9      	str	r1, [r7, #8]
 8016fca:	607a      	str	r2, [r7, #4]
    register signed char __res = 0;
 8016fcc:	2400      	movs	r4, #0

    while (count)
 8016fce:	e013      	b.n	8016ff8 <rt_strncmp+0x38>
    {
        if ((__res = *cs - *ct++) != 0 || !*cs++)
 8016fd0:	68fb      	ldr	r3, [r7, #12]
 8016fd2:	781a      	ldrb	r2, [r3, #0]
 8016fd4:	68bb      	ldr	r3, [r7, #8]
 8016fd6:	1c59      	adds	r1, r3, #1
 8016fd8:	60b9      	str	r1, [r7, #8]
 8016fda:	781b      	ldrb	r3, [r3, #0]
 8016fdc:	1ad3      	subs	r3, r2, r3
 8016fde:	b2db      	uxtb	r3, r3
 8016fe0:	b2dc      	uxtb	r4, r3
 8016fe2:	2c00      	cmp	r4, #0
 8016fe4:	d10b      	bne.n	8016ffe <rt_strncmp+0x3e>
 8016fe6:	68fb      	ldr	r3, [r7, #12]
 8016fe8:	1c5a      	adds	r2, r3, #1
 8016fea:	60fa      	str	r2, [r7, #12]
 8016fec:	781b      	ldrb	r3, [r3, #0]
 8016fee:	2b00      	cmp	r3, #0
 8016ff0:	d005      	beq.n	8016ffe <rt_strncmp+0x3e>
            break;
        count --;
 8016ff2:	687b      	ldr	r3, [r7, #4]
 8016ff4:	3b01      	subs	r3, #1
 8016ff6:	607b      	str	r3, [r7, #4]
 */
rt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count)
{
    register signed char __res = 0;

    while (count)
 8016ff8:	687b      	ldr	r3, [r7, #4]
 8016ffa:	2b00      	cmp	r3, #0
 8016ffc:	d1e8      	bne.n	8016fd0 <rt_strncmp+0x10>
        if ((__res = *cs - *ct++) != 0 || !*cs++)
            break;
        count --;
    }

    return __res;
 8016ffe:	b263      	sxtb	r3, r4
}
 8017000:	4618      	mov	r0, r3
 8017002:	3710      	adds	r7, #16
 8017004:	46bd      	mov	sp, r7
 8017006:	bc90      	pop	{r4, r7}
 8017008:	4770      	bx	lr
 801700a:	bf00      	nop

0801700c <rt_strlen>:
 * @param s the string
 *
 * @return the length of string
 */
rt_size_t rt_strlen(const char *s)
{
 801700c:	b480      	push	{r7}
 801700e:	b085      	sub	sp, #20
 8017010:	af00      	add	r7, sp, #0
 8017012:	6078      	str	r0, [r7, #4]
    const char *sc;

    for (sc = s; *sc != '\0'; ++sc) /* nothing */
 8017014:	687b      	ldr	r3, [r7, #4]
 8017016:	60fb      	str	r3, [r7, #12]
 8017018:	e002      	b.n	8017020 <rt_strlen+0x14>
 801701a:	68fb      	ldr	r3, [r7, #12]
 801701c:	3301      	adds	r3, #1
 801701e:	60fb      	str	r3, [r7, #12]
 8017020:	68fb      	ldr	r3, [r7, #12]
 8017022:	781b      	ldrb	r3, [r3, #0]
 8017024:	2b00      	cmp	r3, #0
 8017026:	d1f8      	bne.n	801701a <rt_strlen+0xe>
        ;

    return sc - s;
 8017028:	68fa      	ldr	r2, [r7, #12]
 801702a:	687b      	ldr	r3, [r7, #4]
 801702c:	1ad3      	subs	r3, r2, r3
}
 801702e:	4618      	mov	r0, r3
 8017030:	3714      	adds	r7, #20
 8017032:	46bd      	mov	sp, r7
 8017034:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017038:	4770      	bx	lr
 801703a:	bf00      	nop

0801703c <rt_show_version>:

/**
 * This function will show the version of rt-thread rtos
 */
void rt_show_version(void)
{
 801703c:	b580      	push	{r7, lr}
 801703e:	b082      	sub	sp, #8
 8017040:	af02      	add	r7, sp, #8
    rt_kprintf("\n \\ | /\n");
 8017042:	4809      	ldr	r0, [pc, #36]	; (8017068 <rt_show_version+0x2c>)
 8017044:	f000 fc3a 	bl	80178bc <rt_kprintf>
    rt_kprintf("- RT -     Thread Operating System\n");
 8017048:	4808      	ldr	r0, [pc, #32]	; (801706c <rt_show_version+0x30>)
 801704a:	f000 fc37 	bl	80178bc <rt_kprintf>
    rt_kprintf(" / | \\     %d.%d.%d build %s\n",
 801704e:	4b08      	ldr	r3, [pc, #32]	; (8017070 <rt_show_version+0x34>)
 8017050:	9300      	str	r3, [sp, #0]
 8017052:	4808      	ldr	r0, [pc, #32]	; (8017074 <rt_show_version+0x38>)
 8017054:	2102      	movs	r1, #2
 8017056:	2201      	movs	r2, #1
 8017058:	2300      	movs	r3, #0
 801705a:	f000 fc2f 	bl	80178bc <rt_kprintf>
               RT_VERSION, RT_SUBVERSION, RT_REVISION, __DATE__);
    rt_kprintf(" 2006 - 2015 Copyright by rt-thread team\n");
 801705e:	4806      	ldr	r0, [pc, #24]	; (8017078 <rt_show_version+0x3c>)
 8017060:	f000 fc2c 	bl	80178bc <rt_kprintf>
}
 8017064:	46bd      	mov	sp, r7
 8017066:	bd80      	pop	{r7, pc}
 8017068:	0802768c 	.word	0x0802768c
 801706c:	08027698 	.word	0x08027698
 8017070:	080276dc 	.word	0x080276dc
 8017074:	080276bc 	.word	0x080276bc
 8017078:	080276e8 	.word	0x080276e8

0801707c <divide>:

/* private function */
#define isdigit(c)  ((unsigned)((c) - '0') < 10)

rt_inline rt_int32_t divide(rt_int32_t *n, rt_int32_t base)
{
 801707c:	b480      	push	{r7}
 801707e:	b085      	sub	sp, #20
 8017080:	af00      	add	r7, sp, #0
 8017082:	6078      	str	r0, [r7, #4]
 8017084:	6039      	str	r1, [r7, #0]
    rt_int32_t res;

    /* optimized for processor which does not support divide instructions. */
    if (base == 10)
 8017086:	683b      	ldr	r3, [r7, #0]
 8017088:	2b0a      	cmp	r3, #10
 801708a:	d117      	bne.n	80170bc <divide+0x40>
    {
        res = ((rt_uint32_t)*n) % 10U;
 801708c:	687b      	ldr	r3, [r7, #4]
 801708e:	681b      	ldr	r3, [r3, #0]
 8017090:	4619      	mov	r1, r3
 8017092:	4b13      	ldr	r3, [pc, #76]	; (80170e0 <divide+0x64>)
 8017094:	fba3 2301 	umull	r2, r3, r3, r1
 8017098:	08da      	lsrs	r2, r3, #3
 801709a:	4613      	mov	r3, r2
 801709c:	009b      	lsls	r3, r3, #2
 801709e:	4413      	add	r3, r2
 80170a0:	005b      	lsls	r3, r3, #1
 80170a2:	1aca      	subs	r2, r1, r3
 80170a4:	60fa      	str	r2, [r7, #12]
        *n = ((rt_uint32_t)*n) / 10U;
 80170a6:	687b      	ldr	r3, [r7, #4]
 80170a8:	681b      	ldr	r3, [r3, #0]
 80170aa:	461a      	mov	r2, r3
 80170ac:	4b0c      	ldr	r3, [pc, #48]	; (80170e0 <divide+0x64>)
 80170ae:	fba3 2302 	umull	r2, r3, r3, r2
 80170b2:	08db      	lsrs	r3, r3, #3
 80170b4:	461a      	mov	r2, r3
 80170b6:	687b      	ldr	r3, [r7, #4]
 80170b8:	601a      	str	r2, [r3, #0]
 80170ba:	e00a      	b.n	80170d2 <divide+0x56>
    }
    else
    {
        res = ((rt_uint32_t)*n) % 16U;
 80170bc:	687b      	ldr	r3, [r7, #4]
 80170be:	681b      	ldr	r3, [r3, #0]
 80170c0:	f003 030f 	and.w	r3, r3, #15
 80170c4:	60fb      	str	r3, [r7, #12]
        *n = ((rt_uint32_t)*n) / 16U;
 80170c6:	687b      	ldr	r3, [r7, #4]
 80170c8:	681b      	ldr	r3, [r3, #0]
 80170ca:	091b      	lsrs	r3, r3, #4
 80170cc:	461a      	mov	r2, r3
 80170ce:	687b      	ldr	r3, [r7, #4]
 80170d0:	601a      	str	r2, [r3, #0]
    }

    return res;
 80170d2:	68fb      	ldr	r3, [r7, #12]
}
 80170d4:	4618      	mov	r0, r3
 80170d6:	3714      	adds	r7, #20
 80170d8:	46bd      	mov	sp, r7
 80170da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80170de:	4770      	bx	lr
 80170e0:	cccccccd 	.word	0xcccccccd

080170e4 <skip_atoi>:

rt_inline int skip_atoi(const char **s)
{
 80170e4:	b490      	push	{r4, r7}
 80170e6:	b082      	sub	sp, #8
 80170e8:	af00      	add	r7, sp, #0
 80170ea:	6078      	str	r0, [r7, #4]
    register int i=0;
 80170ec:	2400      	movs	r4, #0
    while (isdigit(**s))
 80170ee:	e00d      	b.n	801710c <skip_atoi+0x28>
        i = i * 10 + *((*s)++) - '0';
 80170f0:	4623      	mov	r3, r4
 80170f2:	009b      	lsls	r3, r3, #2
 80170f4:	4423      	add	r3, r4
 80170f6:	005b      	lsls	r3, r3, #1
 80170f8:	4618      	mov	r0, r3
 80170fa:	687b      	ldr	r3, [r7, #4]
 80170fc:	681b      	ldr	r3, [r3, #0]
 80170fe:	1c59      	adds	r1, r3, #1
 8017100:	687a      	ldr	r2, [r7, #4]
 8017102:	6011      	str	r1, [r2, #0]
 8017104:	781b      	ldrb	r3, [r3, #0]
 8017106:	4403      	add	r3, r0
 8017108:	f1a3 0430 	sub.w	r4, r3, #48	; 0x30
}

rt_inline int skip_atoi(const char **s)
{
    register int i=0;
    while (isdigit(**s))
 801710c:	687b      	ldr	r3, [r7, #4]
 801710e:	681b      	ldr	r3, [r3, #0]
 8017110:	781b      	ldrb	r3, [r3, #0]
 8017112:	3b30      	subs	r3, #48	; 0x30
 8017114:	2b09      	cmp	r3, #9
 8017116:	d9eb      	bls.n	80170f0 <skip_atoi+0xc>
        i = i * 10 + *((*s)++) - '0';

    return i;
 8017118:	4623      	mov	r3, r4
}
 801711a:	4618      	mov	r0, r3
 801711c:	3708      	adds	r7, #8
 801711e:	46bd      	mov	sp, r7
 8017120:	bc90      	pop	{r4, r7}
 8017122:	4770      	bx	lr

08017124 <print_number>:
                          long  num,
                          int   base,
                          int   s,
                          int   type)
#endif
{
 8017124:	b5f0      	push	{r4, r5, r6, r7, lr}
 8017126:	b08d      	sub	sp, #52	; 0x34
 8017128:	af00      	add	r7, sp, #0
 801712a:	60f8      	str	r0, [r7, #12]
 801712c:	60b9      	str	r1, [r7, #8]
 801712e:	607a      	str	r2, [r7, #4]
 8017130:	603b      	str	r3, [r7, #0]
    static const char small_digits[] = "0123456789abcdef";
    static const char large_digits[] = "0123456789ABCDEF";
    register int i;
    register int size;

    size = s;
 8017132:	6cbc      	ldr	r4, [r7, #72]	; 0x48

    digits = (type & LARGE) ? large_digits : small_digits;
 8017134:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8017136:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801713a:	2b00      	cmp	r3, #0
 801713c:	d001      	beq.n	8017142 <print_number+0x1e>
 801713e:	4b6c      	ldr	r3, [pc, #432]	; (80172f0 <print_number+0x1cc>)
 8017140:	e000      	b.n	8017144 <print_number+0x20>
 8017142:	4b6c      	ldr	r3, [pc, #432]	; (80172f4 <print_number+0x1d0>)
 8017144:	62bb      	str	r3, [r7, #40]	; 0x28
    if (type & LEFT)
 8017146:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8017148:	f003 0310 	and.w	r3, r3, #16
 801714c:	2b00      	cmp	r3, #0
 801714e:	d003      	beq.n	8017158 <print_number+0x34>
        type &= ~ZEROPAD;
 8017150:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8017152:	f023 0301 	bic.w	r3, r3, #1
 8017156:	653b      	str	r3, [r7, #80]	; 0x50

    c = (type & ZEROPAD) ? '0' : ' ';
 8017158:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801715a:	f003 0301 	and.w	r3, r3, #1
 801715e:	2b00      	cmp	r3, #0
 8017160:	d001      	beq.n	8017166 <print_number+0x42>
 8017162:	2330      	movs	r3, #48	; 0x30
 8017164:	e000      	b.n	8017168 <print_number+0x44>
 8017166:	2320      	movs	r3, #32
 8017168:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

    /* get sign */
    sign = 0;
 801716c:	2300      	movs	r3, #0
 801716e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    if (type & SIGN)
 8017172:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8017174:	f003 0302 	and.w	r3, r3, #2
 8017178:	2b00      	cmp	r3, #0
 801717a:	d01a      	beq.n	80171b2 <print_number+0x8e>
    {
        if (num < 0)
 801717c:	687b      	ldr	r3, [r7, #4]
 801717e:	2b00      	cmp	r3, #0
 8017180:	da06      	bge.n	8017190 <print_number+0x6c>
        {
            sign = '-';
 8017182:	232d      	movs	r3, #45	; 0x2d
 8017184:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
            num = -num;
 8017188:	687b      	ldr	r3, [r7, #4]
 801718a:	425b      	negs	r3, r3
 801718c:	607b      	str	r3, [r7, #4]
 801718e:	e010      	b.n	80171b2 <print_number+0x8e>
        }
        else if (type & PLUS)
 8017190:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8017192:	f003 0304 	and.w	r3, r3, #4
 8017196:	2b00      	cmp	r3, #0
 8017198:	d003      	beq.n	80171a2 <print_number+0x7e>
            sign = '+';
 801719a:	232b      	movs	r3, #43	; 0x2b
 801719c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 80171a0:	e007      	b.n	80171b2 <print_number+0x8e>
        else if (type & SPACE)
 80171a2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80171a4:	f003 0308 	and.w	r3, r3, #8
 80171a8:	2b00      	cmp	r3, #0
 80171aa:	d002      	beq.n	80171b2 <print_number+0x8e>
            sign = ' ';
 80171ac:	2320      	movs	r3, #32
 80171ae:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
        else if (base == 8)
            size--;
    }
#endif

    i = 0;
 80171b2:	2500      	movs	r5, #0
    if (num == 0)
 80171b4:	687b      	ldr	r3, [r7, #4]
 80171b6:	2b00      	cmp	r3, #0
 80171b8:	d108      	bne.n	80171cc <print_number+0xa8>
        tmp[i++]='0';
 80171ba:	462b      	mov	r3, r5
 80171bc:	1c5d      	adds	r5, r3, #1
 80171be:	f107 0230 	add.w	r2, r7, #48	; 0x30
 80171c2:	4413      	add	r3, r2
 80171c4:	2230      	movs	r2, #48	; 0x30
 80171c6:	f803 2c1c 	strb.w	r2, [r3, #-28]
 80171ca:	e014      	b.n	80171f6 <print_number+0xd2>
    else
    {
        while (num != 0)
 80171cc:	e010      	b.n	80171f0 <print_number+0xcc>
            tmp[i++] = digits[divide(&num, base)];
 80171ce:	462e      	mov	r6, r5
 80171d0:	1c75      	adds	r5, r6, #1
 80171d2:	1d3b      	adds	r3, r7, #4
 80171d4:	4618      	mov	r0, r3
 80171d6:	6839      	ldr	r1, [r7, #0]
 80171d8:	f7ff ff50 	bl	801707c <divide>
 80171dc:	4603      	mov	r3, r0
 80171de:	461a      	mov	r2, r3
 80171e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80171e2:	4413      	add	r3, r2
 80171e4:	781a      	ldrb	r2, [r3, #0]
 80171e6:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80171ea:	4433      	add	r3, r6
 80171ec:	f803 2c1c 	strb.w	r2, [r3, #-28]
    i = 0;
    if (num == 0)
        tmp[i++]='0';
    else
    {
        while (num != 0)
 80171f0:	687b      	ldr	r3, [r7, #4]
 80171f2:	2b00      	cmp	r3, #0
 80171f4:	d1eb      	bne.n	80171ce <print_number+0xaa>
            tmp[i++] = digits[divide(&num, base)];
    }

#ifdef RT_PRINTF_PRECISION
    if (i > precision)
 80171f6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80171f8:	429d      	cmp	r5, r3
 80171fa:	dd00      	ble.n	80171fe <print_number+0xda>
        precision = i;
 80171fc:	64fd      	str	r5, [r7, #76]	; 0x4c
    size -= precision;
 80171fe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8017200:	1ae4      	subs	r4, r4, r3
#else
    size -= i;
#endif

    if (!(type&(ZEROPAD | LEFT)))
 8017202:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8017204:	f003 0311 	and.w	r3, r3, #17
 8017208:	2b00      	cmp	r3, #0
 801720a:	d115      	bne.n	8017238 <print_number+0x114>
    {
        if ((sign)&&(size>0))
 801720c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8017210:	2b00      	cmp	r3, #0
 8017212:	d002      	beq.n	801721a <print_number+0xf6>
 8017214:	2c00      	cmp	r4, #0
 8017216:	dd00      	ble.n	801721a <print_number+0xf6>
            size--;
 8017218:	3c01      	subs	r4, #1

        while (size-->0)
 801721a:	e009      	b.n	8017230 <print_number+0x10c>
        {
            if (buf <= end)
 801721c:	68fa      	ldr	r2, [r7, #12]
 801721e:	68bb      	ldr	r3, [r7, #8]
 8017220:	429a      	cmp	r2, r3
 8017222:	d802      	bhi.n	801722a <print_number+0x106>
                *buf = ' ';
 8017224:	68fb      	ldr	r3, [r7, #12]
 8017226:	2220      	movs	r2, #32
 8017228:	701a      	strb	r2, [r3, #0]
            ++ buf;
 801722a:	68fb      	ldr	r3, [r7, #12]
 801722c:	3301      	adds	r3, #1
 801722e:	60fb      	str	r3, [r7, #12]
    if (!(type&(ZEROPAD | LEFT)))
    {
        if ((sign)&&(size>0))
            size--;

        while (size-->0)
 8017230:	4623      	mov	r3, r4
 8017232:	1e5c      	subs	r4, r3, #1
 8017234:	2b00      	cmp	r3, #0
 8017236:	dcf1      	bgt.n	801721c <print_number+0xf8>
                *buf = ' ';
            ++ buf;
        }
    }

    if (sign)
 8017238:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801723c:	2b00      	cmp	r3, #0
 801723e:	d00b      	beq.n	8017258 <print_number+0x134>
    {
        if (buf <= end)
 8017240:	68fa      	ldr	r2, [r7, #12]
 8017242:	68bb      	ldr	r3, [r7, #8]
 8017244:	429a      	cmp	r2, r3
 8017246:	d804      	bhi.n	8017252 <print_number+0x12e>
        {
            *buf = sign;
 8017248:	68fb      	ldr	r3, [r7, #12]
 801724a:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
 801724e:	701a      	strb	r2, [r3, #0]
            -- size;
 8017250:	3c01      	subs	r4, #1
        }
        ++ buf;
 8017252:	68fb      	ldr	r3, [r7, #12]
 8017254:	3301      	adds	r3, #1
 8017256:	60fb      	str	r3, [r7, #12]
        }
    }
#endif

    /* no align to the left */
    if (!(type & LEFT))
 8017258:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801725a:	f003 0310 	and.w	r3, r3, #16
 801725e:	2b00      	cmp	r3, #0
 8017260:	d10f      	bne.n	8017282 <print_number+0x15e>
    {
        while (size-- > 0)
 8017262:	e00a      	b.n	801727a <print_number+0x156>
        {
            if (buf <= end)
 8017264:	68fa      	ldr	r2, [r7, #12]
 8017266:	68bb      	ldr	r3, [r7, #8]
 8017268:	429a      	cmp	r2, r3
 801726a:	d803      	bhi.n	8017274 <print_number+0x150>
                *buf = c;
 801726c:	68fb      	ldr	r3, [r7, #12]
 801726e:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 8017272:	701a      	strb	r2, [r3, #0]
            ++ buf;
 8017274:	68fb      	ldr	r3, [r7, #12]
 8017276:	3301      	adds	r3, #1
 8017278:	60fb      	str	r3, [r7, #12]
#endif

    /* no align to the left */
    if (!(type & LEFT))
    {
        while (size-- > 0)
 801727a:	4623      	mov	r3, r4
 801727c:	1e5c      	subs	r4, r3, #1
 801727e:	2b00      	cmp	r3, #0
 8017280:	dcf0      	bgt.n	8017264 <print_number+0x140>
            ++ buf;
        }
    }

#ifdef RT_PRINTF_PRECISION
    while (i < precision--)
 8017282:	e009      	b.n	8017298 <print_number+0x174>
    {
        if (buf <= end)
 8017284:	68fa      	ldr	r2, [r7, #12]
 8017286:	68bb      	ldr	r3, [r7, #8]
 8017288:	429a      	cmp	r2, r3
 801728a:	d802      	bhi.n	8017292 <print_number+0x16e>
            *buf = '0';
 801728c:	68fb      	ldr	r3, [r7, #12]
 801728e:	2230      	movs	r2, #48	; 0x30
 8017290:	701a      	strb	r2, [r3, #0]
        ++ buf;
 8017292:	68fb      	ldr	r3, [r7, #12]
 8017294:	3301      	adds	r3, #1
 8017296:	60fb      	str	r3, [r7, #12]
            ++ buf;
        }
    }

#ifdef RT_PRINTF_PRECISION
    while (i < precision--)
 8017298:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801729a:	1e5a      	subs	r2, r3, #1
 801729c:	64fa      	str	r2, [r7, #76]	; 0x4c
 801729e:	42ab      	cmp	r3, r5
 80172a0:	dcf0      	bgt.n	8017284 <print_number+0x160>
        ++ buf;
    }
#endif

    /* put number in the temporary buffer */
    while (i-- > 0)
 80172a2:	e00d      	b.n	80172c0 <print_number+0x19c>
    {
        if (buf <= end)
 80172a4:	68fa      	ldr	r2, [r7, #12]
 80172a6:	68bb      	ldr	r3, [r7, #8]
 80172a8:	429a      	cmp	r2, r3
 80172aa:	d806      	bhi.n	80172ba <print_number+0x196>
            *buf = tmp[i];
 80172ac:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80172b0:	442b      	add	r3, r5
 80172b2:	f813 2c1c 	ldrb.w	r2, [r3, #-28]
 80172b6:	68fb      	ldr	r3, [r7, #12]
 80172b8:	701a      	strb	r2, [r3, #0]
        ++ buf;
 80172ba:	68fb      	ldr	r3, [r7, #12]
 80172bc:	3301      	adds	r3, #1
 80172be:	60fb      	str	r3, [r7, #12]
        ++ buf;
    }
#endif

    /* put number in the temporary buffer */
    while (i-- > 0)
 80172c0:	462b      	mov	r3, r5
 80172c2:	1e5d      	subs	r5, r3, #1
 80172c4:	2b00      	cmp	r3, #0
 80172c6:	dced      	bgt.n	80172a4 <print_number+0x180>
        if (buf <= end)
            *buf = tmp[i];
        ++ buf;
    }

    while (size-- > 0)
 80172c8:	e009      	b.n	80172de <print_number+0x1ba>
    {
        if (buf <= end)
 80172ca:	68fa      	ldr	r2, [r7, #12]
 80172cc:	68bb      	ldr	r3, [r7, #8]
 80172ce:	429a      	cmp	r2, r3
 80172d0:	d802      	bhi.n	80172d8 <print_number+0x1b4>
            *buf = ' ';
 80172d2:	68fb      	ldr	r3, [r7, #12]
 80172d4:	2220      	movs	r2, #32
 80172d6:	701a      	strb	r2, [r3, #0]
        ++ buf;
 80172d8:	68fb      	ldr	r3, [r7, #12]
 80172da:	3301      	adds	r3, #1
 80172dc:	60fb      	str	r3, [r7, #12]
        if (buf <= end)
            *buf = tmp[i];
        ++ buf;
    }

    while (size-- > 0)
 80172de:	4623      	mov	r3, r4
 80172e0:	1e5c      	subs	r4, r3, #1
 80172e2:	2b00      	cmp	r3, #0
 80172e4:	dcf1      	bgt.n	80172ca <print_number+0x1a6>
        if (buf <= end)
            *buf = ' ';
        ++ buf;
    }

    return buf;
 80172e6:	68fb      	ldr	r3, [r7, #12]
}
 80172e8:	4618      	mov	r0, r3
 80172ea:	3734      	adds	r7, #52	; 0x34
 80172ec:	46bd      	mov	sp, r7
 80172ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80172f0:	08029044 	.word	0x08029044
 80172f4:	08029058 	.word	0x08029058

080172f8 <rt_vsnprintf>:

rt_int32_t rt_vsnprintf(char       *buf,
                        rt_size_t   size,
                        const char *fmt,
                        va_list     args)
{
 80172f8:	b5b0      	push	{r4, r5, r7, lr}
 80172fa:	b092      	sub	sp, #72	; 0x48
 80172fc:	af04      	add	r7, sp, #16
 80172fe:	60f8      	str	r0, [r7, #12]
 8017300:	60b9      	str	r1, [r7, #8]
 8017302:	607a      	str	r2, [r7, #4]
 8017304:	603b      	str	r3, [r7, #0]

#ifdef RT_PRINTF_PRECISION
    int precision;      /* min. # of digits for integers and max for a string */
#endif

    str = buf;
 8017306:	68fb      	ldr	r3, [r7, #12]
 8017308:	62bb      	str	r3, [r7, #40]	; 0x28
    end = buf + size - 1;
 801730a:	68bb      	ldr	r3, [r7, #8]
 801730c:	3b01      	subs	r3, #1
 801730e:	68fa      	ldr	r2, [r7, #12]
 8017310:	4413      	add	r3, r2
 8017312:	627b      	str	r3, [r7, #36]	; 0x24

    /* Make sure end is always >= buf */
    if (end < buf)
 8017314:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8017316:	68fb      	ldr	r3, [r7, #12]
 8017318:	429a      	cmp	r2, r3
 801731a:	d206      	bcs.n	801732a <rt_vsnprintf+0x32>
    {
        end  = ((char *)-1);
 801731c:	f04f 33ff 	mov.w	r3, #4294967295
 8017320:	627b      	str	r3, [r7, #36]	; 0x24
        size = end - buf;
 8017322:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8017324:	68fb      	ldr	r3, [r7, #12]
 8017326:	1ad3      	subs	r3, r2, r3
 8017328:	60bb      	str	r3, [r7, #8]
    }

    for (; *fmt ; ++fmt)
 801732a:	e271      	b.n	8017810 <rt_vsnprintf+0x518>
    {
        if (*fmt != '%')
 801732c:	687b      	ldr	r3, [r7, #4]
 801732e:	781b      	ldrb	r3, [r3, #0]
 8017330:	2b25      	cmp	r3, #37	; 0x25
 8017332:	d00b      	beq.n	801734c <rt_vsnprintf+0x54>
        {
            if (str <= end)
 8017334:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8017336:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017338:	429a      	cmp	r2, r3
 801733a:	d803      	bhi.n	8017344 <rt_vsnprintf+0x4c>
                *str = *fmt;
 801733c:	687b      	ldr	r3, [r7, #4]
 801733e:	781a      	ldrb	r2, [r3, #0]
 8017340:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017342:	701a      	strb	r2, [r3, #0]
            ++ str;
 8017344:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017346:	3301      	adds	r3, #1
 8017348:	62bb      	str	r3, [r7, #40]	; 0x28
            continue;
 801734a:	e25e      	b.n	801780a <rt_vsnprintf+0x512>
        }

        /* process flags */
        flags = 0;
 801734c:	2300      	movs	r3, #0
 801734e:	77bb      	strb	r3, [r7, #30]

        while (1)
        {
            /* skips the first '%' also */
            ++ fmt;
 8017350:	687b      	ldr	r3, [r7, #4]
 8017352:	3301      	adds	r3, #1
 8017354:	607b      	str	r3, [r7, #4]
            if (*fmt == '-') flags |= LEFT;
 8017356:	687b      	ldr	r3, [r7, #4]
 8017358:	781b      	ldrb	r3, [r3, #0]
 801735a:	2b2d      	cmp	r3, #45	; 0x2d
 801735c:	d104      	bne.n	8017368 <rt_vsnprintf+0x70>
 801735e:	7fbb      	ldrb	r3, [r7, #30]
 8017360:	f043 0310 	orr.w	r3, r3, #16
 8017364:	77bb      	strb	r3, [r7, #30]
 8017366:	e02d      	b.n	80173c4 <rt_vsnprintf+0xcc>
            else if (*fmt == '+') flags |= PLUS;
 8017368:	687b      	ldr	r3, [r7, #4]
 801736a:	781b      	ldrb	r3, [r3, #0]
 801736c:	2b2b      	cmp	r3, #43	; 0x2b
 801736e:	d104      	bne.n	801737a <rt_vsnprintf+0x82>
 8017370:	7fbb      	ldrb	r3, [r7, #30]
 8017372:	f043 0304 	orr.w	r3, r3, #4
 8017376:	77bb      	strb	r3, [r7, #30]
 8017378:	e024      	b.n	80173c4 <rt_vsnprintf+0xcc>
            else if (*fmt == ' ') flags |= SPACE;
 801737a:	687b      	ldr	r3, [r7, #4]
 801737c:	781b      	ldrb	r3, [r3, #0]
 801737e:	2b20      	cmp	r3, #32
 8017380:	d104      	bne.n	801738c <rt_vsnprintf+0x94>
 8017382:	7fbb      	ldrb	r3, [r7, #30]
 8017384:	f043 0308 	orr.w	r3, r3, #8
 8017388:	77bb      	strb	r3, [r7, #30]
 801738a:	e01b      	b.n	80173c4 <rt_vsnprintf+0xcc>
            else if (*fmt == '#') flags |= SPECIAL;
 801738c:	687b      	ldr	r3, [r7, #4]
 801738e:	781b      	ldrb	r3, [r3, #0]
 8017390:	2b23      	cmp	r3, #35	; 0x23
 8017392:	d104      	bne.n	801739e <rt_vsnprintf+0xa6>
 8017394:	7fbb      	ldrb	r3, [r7, #30]
 8017396:	f043 0320 	orr.w	r3, r3, #32
 801739a:	77bb      	strb	r3, [r7, #30]
 801739c:	e012      	b.n	80173c4 <rt_vsnprintf+0xcc>
            else if (*fmt == '0') flags |= ZEROPAD;
 801739e:	687b      	ldr	r3, [r7, #4]
 80173a0:	781b      	ldrb	r3, [r3, #0]
 80173a2:	2b30      	cmp	r3, #48	; 0x30
 80173a4:	d104      	bne.n	80173b0 <rt_vsnprintf+0xb8>
 80173a6:	7fbb      	ldrb	r3, [r7, #30]
 80173a8:	f043 0301 	orr.w	r3, r3, #1
 80173ac:	77bb      	strb	r3, [r7, #30]
 80173ae:	e009      	b.n	80173c4 <rt_vsnprintf+0xcc>
            else break;
 80173b0:	bf00      	nop
        }

        /* get field width */
        field_width = -1;
 80173b2:	f04f 33ff 	mov.w	r3, #4294967295
 80173b6:	61bb      	str	r3, [r7, #24]
        if (isdigit(*fmt)) field_width = skip_atoi(&fmt);
 80173b8:	687b      	ldr	r3, [r7, #4]
 80173ba:	781b      	ldrb	r3, [r3, #0]
 80173bc:	3b30      	subs	r3, #48	; 0x30
 80173be:	2b09      	cmp	r3, #9
 80173c0:	d807      	bhi.n	80173d2 <rt_vsnprintf+0xda>
 80173c2:	e000      	b.n	80173c6 <rt_vsnprintf+0xce>
            else if (*fmt == '+') flags |= PLUS;
            else if (*fmt == ' ') flags |= SPACE;
            else if (*fmt == '#') flags |= SPECIAL;
            else if (*fmt == '0') flags |= ZEROPAD;
            else break;
        }
 80173c4:	e7c4      	b.n	8017350 <rt_vsnprintf+0x58>

        /* get field width */
        field_width = -1;
        if (isdigit(*fmt)) field_width = skip_atoi(&fmt);
 80173c6:	1d3b      	adds	r3, r7, #4
 80173c8:	4618      	mov	r0, r3
 80173ca:	f7ff fe8b 	bl	80170e4 <skip_atoi>
 80173ce:	61b8      	str	r0, [r7, #24]
 80173d0:	e015      	b.n	80173fe <rt_vsnprintf+0x106>
        else if (*fmt == '*')
 80173d2:	687b      	ldr	r3, [r7, #4]
 80173d4:	781b      	ldrb	r3, [r3, #0]
 80173d6:	2b2a      	cmp	r3, #42	; 0x2a
 80173d8:	d111      	bne.n	80173fe <rt_vsnprintf+0x106>
        {
            ++ fmt;
 80173da:	687b      	ldr	r3, [r7, #4]
 80173dc:	3301      	adds	r3, #1
 80173de:	607b      	str	r3, [r7, #4]
            /* it's the next argument */
            field_width = va_arg(args, int);
 80173e0:	683b      	ldr	r3, [r7, #0]
 80173e2:	1d1a      	adds	r2, r3, #4
 80173e4:	603a      	str	r2, [r7, #0]
 80173e6:	681b      	ldr	r3, [r3, #0]
 80173e8:	61bb      	str	r3, [r7, #24]
            if (field_width < 0)
 80173ea:	69bb      	ldr	r3, [r7, #24]
 80173ec:	2b00      	cmp	r3, #0
 80173ee:	da06      	bge.n	80173fe <rt_vsnprintf+0x106>
            {
                field_width = -field_width;
 80173f0:	69bb      	ldr	r3, [r7, #24]
 80173f2:	425b      	negs	r3, r3
 80173f4:	61bb      	str	r3, [r7, #24]
                flags |= LEFT;
 80173f6:	7fbb      	ldrb	r3, [r7, #30]
 80173f8:	f043 0310 	orr.w	r3, r3, #16
 80173fc:	77bb      	strb	r3, [r7, #30]
            }
        }

#ifdef RT_PRINTF_PRECISION
        /* get the precision */
        precision = -1;
 80173fe:	f04f 33ff 	mov.w	r3, #4294967295
 8017402:	617b      	str	r3, [r7, #20]
        if (*fmt == '.')
 8017404:	687b      	ldr	r3, [r7, #4]
 8017406:	781b      	ldrb	r3, [r3, #0]
 8017408:	2b2e      	cmp	r3, #46	; 0x2e
 801740a:	d11e      	bne.n	801744a <rt_vsnprintf+0x152>
        {
            ++ fmt;
 801740c:	687b      	ldr	r3, [r7, #4]
 801740e:	3301      	adds	r3, #1
 8017410:	607b      	str	r3, [r7, #4]
            if (isdigit(*fmt)) precision = skip_atoi(&fmt);
 8017412:	687b      	ldr	r3, [r7, #4]
 8017414:	781b      	ldrb	r3, [r3, #0]
 8017416:	3b30      	subs	r3, #48	; 0x30
 8017418:	2b09      	cmp	r3, #9
 801741a:	d805      	bhi.n	8017428 <rt_vsnprintf+0x130>
 801741c:	1d3b      	adds	r3, r7, #4
 801741e:	4618      	mov	r0, r3
 8017420:	f7ff fe60 	bl	80170e4 <skip_atoi>
 8017424:	6178      	str	r0, [r7, #20]
 8017426:	e00b      	b.n	8017440 <rt_vsnprintf+0x148>
            else if (*fmt == '*')
 8017428:	687b      	ldr	r3, [r7, #4]
 801742a:	781b      	ldrb	r3, [r3, #0]
 801742c:	2b2a      	cmp	r3, #42	; 0x2a
 801742e:	d107      	bne.n	8017440 <rt_vsnprintf+0x148>
            {
                ++ fmt;
 8017430:	687b      	ldr	r3, [r7, #4]
 8017432:	3301      	adds	r3, #1
 8017434:	607b      	str	r3, [r7, #4]
                /* it's the next argument */
                precision = va_arg(args, int);
 8017436:	683b      	ldr	r3, [r7, #0]
 8017438:	1d1a      	adds	r2, r3, #4
 801743a:	603a      	str	r2, [r7, #0]
 801743c:	681b      	ldr	r3, [r3, #0]
 801743e:	617b      	str	r3, [r7, #20]
            }
            if (precision < 0) precision = 0;
 8017440:	697b      	ldr	r3, [r7, #20]
 8017442:	2b00      	cmp	r3, #0
 8017444:	da01      	bge.n	801744a <rt_vsnprintf+0x152>
 8017446:	2300      	movs	r3, #0
 8017448:	617b      	str	r3, [r7, #20]
        }
#endif
        /* get the conversion qualifier */
        qualifier = 0;
 801744a:	2300      	movs	r3, #0
 801744c:	777b      	strb	r3, [r7, #29]
#ifdef RT_PRINTF_LONGLONG
        if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L')
#else
        if (*fmt == 'h' || *fmt == 'l')
 801744e:	687b      	ldr	r3, [r7, #4]
 8017450:	781b      	ldrb	r3, [r3, #0]
 8017452:	2b68      	cmp	r3, #104	; 0x68
 8017454:	d003      	beq.n	801745e <rt_vsnprintf+0x166>
 8017456:	687b      	ldr	r3, [r7, #4]
 8017458:	781b      	ldrb	r3, [r3, #0]
 801745a:	2b6c      	cmp	r3, #108	; 0x6c
 801745c:	d105      	bne.n	801746a <rt_vsnprintf+0x172>
#endif
        {
            qualifier = *fmt;
 801745e:	687b      	ldr	r3, [r7, #4]
 8017460:	781b      	ldrb	r3, [r3, #0]
 8017462:	777b      	strb	r3, [r7, #29]
            ++ fmt;
 8017464:	687b      	ldr	r3, [r7, #4]
 8017466:	3301      	adds	r3, #1
 8017468:	607b      	str	r3, [r7, #4]
            }
#endif
        }

        /* the default base */
        base = 10;
 801746a:	230a      	movs	r3, #10
 801746c:	77fb      	strb	r3, [r7, #31]

        switch (*fmt)
 801746e:	687b      	ldr	r3, [r7, #4]
 8017470:	781b      	ldrb	r3, [r3, #0]
 8017472:	3b25      	subs	r3, #37	; 0x25
 8017474:	2b53      	cmp	r3, #83	; 0x53
 8017476:	f200 8171 	bhi.w	801775c <rt_vsnprintf+0x464>
 801747a:	a201      	add	r2, pc, #4	; (adr r2, 8017480 <rt_vsnprintf+0x188>)
 801747c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8017480:	08017729 	.word	0x08017729
 8017484:	0801775d 	.word	0x0801775d
 8017488:	0801775d 	.word	0x0801775d
 801748c:	0801775d 	.word	0x0801775d
 8017490:	0801775d 	.word	0x0801775d
 8017494:	0801775d 	.word	0x0801775d
 8017498:	0801775d 	.word	0x0801775d
 801749c:	0801775d 	.word	0x0801775d
 80174a0:	0801775d 	.word	0x0801775d
 80174a4:	0801775d 	.word	0x0801775d
 80174a8:	0801775d 	.word	0x0801775d
 80174ac:	0801775d 	.word	0x0801775d
 80174b0:	0801775d 	.word	0x0801775d
 80174b4:	0801775d 	.word	0x0801775d
 80174b8:	0801775d 	.word	0x0801775d
 80174bc:	0801775d 	.word	0x0801775d
 80174c0:	0801775d 	.word	0x0801775d
 80174c4:	0801775d 	.word	0x0801775d
 80174c8:	0801775d 	.word	0x0801775d
 80174cc:	0801775d 	.word	0x0801775d
 80174d0:	0801775d 	.word	0x0801775d
 80174d4:	0801775d 	.word	0x0801775d
 80174d8:	0801775d 	.word	0x0801775d
 80174dc:	0801775d 	.word	0x0801775d
 80174e0:	0801775d 	.word	0x0801775d
 80174e4:	0801775d 	.word	0x0801775d
 80174e8:	0801775d 	.word	0x0801775d
 80174ec:	0801775d 	.word	0x0801775d
 80174f0:	0801775d 	.word	0x0801775d
 80174f4:	0801775d 	.word	0x0801775d
 80174f8:	0801775d 	.word	0x0801775d
 80174fc:	0801775d 	.word	0x0801775d
 8017500:	0801775d 	.word	0x0801775d
 8017504:	0801775d 	.word	0x0801775d
 8017508:	0801775d 	.word	0x0801775d
 801750c:	0801775d 	.word	0x0801775d
 8017510:	0801775d 	.word	0x0801775d
 8017514:	0801775d 	.word	0x0801775d
 8017518:	0801775d 	.word	0x0801775d
 801751c:	0801775d 	.word	0x0801775d
 8017520:	0801775d 	.word	0x0801775d
 8017524:	0801775d 	.word	0x0801775d
 8017528:	0801775d 	.word	0x0801775d
 801752c:	0801775d 	.word	0x0801775d
 8017530:	0801775d 	.word	0x0801775d
 8017534:	0801775d 	.word	0x0801775d
 8017538:	0801775d 	.word	0x0801775d
 801753c:	0801775d 	.word	0x0801775d
 8017540:	0801775d 	.word	0x0801775d
 8017544:	0801775d 	.word	0x0801775d
 8017548:	0801775d 	.word	0x0801775d
 801754c:	08017745 	.word	0x08017745
 8017550:	0801775d 	.word	0x0801775d
 8017554:	0801775d 	.word	0x0801775d
 8017558:	0801775d 	.word	0x0801775d
 801755c:	0801775d 	.word	0x0801775d
 8017560:	0801775d 	.word	0x0801775d
 8017564:	0801775d 	.word	0x0801775d
 8017568:	0801775d 	.word	0x0801775d
 801756c:	0801775d 	.word	0x0801775d
 8017570:	0801775d 	.word	0x0801775d
 8017574:	0801775d 	.word	0x0801775d
 8017578:	080175d1 	.word	0x080175d1
 801757c:	08017753 	.word	0x08017753
 8017580:	0801775d 	.word	0x0801775d
 8017584:	0801775d 	.word	0x0801775d
 8017588:	0801775d 	.word	0x0801775d
 801758c:	0801775d 	.word	0x0801775d
 8017590:	08017753 	.word	0x08017753
 8017594:	0801775d 	.word	0x0801775d
 8017598:	0801775d 	.word	0x0801775d
 801759c:	0801775d 	.word	0x0801775d
 80175a0:	0801775d 	.word	0x0801775d
 80175a4:	0801775d 	.word	0x0801775d
 80175a8:	0801773f 	.word	0x0801773f
 80175ac:	080176ef 	.word	0x080176ef
 80175b0:	0801775d 	.word	0x0801775d
 80175b4:	0801775d 	.word	0x0801775d
 80175b8:	0801763f 	.word	0x0801763f
 80175bc:	0801775d 	.word	0x0801775d
 80175c0:	08017799 	.word	0x08017799
 80175c4:	0801775d 	.word	0x0801775d
 80175c8:	0801775d 	.word	0x0801775d
 80175cc:	0801774d 	.word	0x0801774d
        {
        case 'c':
            if (!(flags & LEFT))
 80175d0:	7fbb      	ldrb	r3, [r7, #30]
 80175d2:	f003 0310 	and.w	r3, r3, #16
 80175d6:	2b00      	cmp	r3, #0
 80175d8:	d110      	bne.n	80175fc <rt_vsnprintf+0x304>
            {
                while (--field_width > 0)
 80175da:	e009      	b.n	80175f0 <rt_vsnprintf+0x2f8>
                {
                    if (str <= end) *str = ' ';
 80175dc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80175de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80175e0:	429a      	cmp	r2, r3
 80175e2:	d802      	bhi.n	80175ea <rt_vsnprintf+0x2f2>
 80175e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80175e6:	2220      	movs	r2, #32
 80175e8:	701a      	strb	r2, [r3, #0]
                    ++ str;
 80175ea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80175ec:	3301      	adds	r3, #1
 80175ee:	62bb      	str	r3, [r7, #40]	; 0x28
        switch (*fmt)
        {
        case 'c':
            if (!(flags & LEFT))
            {
                while (--field_width > 0)
 80175f0:	69bb      	ldr	r3, [r7, #24]
 80175f2:	3b01      	subs	r3, #1
 80175f4:	61bb      	str	r3, [r7, #24]
 80175f6:	69bb      	ldr	r3, [r7, #24]
 80175f8:	2b00      	cmp	r3, #0
 80175fa:	dcef      	bgt.n	80175dc <rt_vsnprintf+0x2e4>
                    ++ str;
                }
            }

            /* get character */
            c = (rt_uint8_t)va_arg(args, int);
 80175fc:	683b      	ldr	r3, [r7, #0]
 80175fe:	1d1a      	adds	r2, r3, #4
 8017600:	603a      	str	r2, [r7, #0]
 8017602:	681b      	ldr	r3, [r3, #0]
 8017604:	74fb      	strb	r3, [r7, #19]
            if (str <= end) *str = c;
 8017606:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8017608:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801760a:	429a      	cmp	r2, r3
 801760c:	d802      	bhi.n	8017614 <rt_vsnprintf+0x31c>
 801760e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017610:	7cfa      	ldrb	r2, [r7, #19]
 8017612:	701a      	strb	r2, [r3, #0]
            ++ str;
 8017614:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017616:	3301      	adds	r3, #1
 8017618:	62bb      	str	r3, [r7, #40]	; 0x28

            /* put width */
            while (--field_width > 0)
 801761a:	e009      	b.n	8017630 <rt_vsnprintf+0x338>
            {
                if (str <= end) *str = ' ';
 801761c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801761e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017620:	429a      	cmp	r2, r3
 8017622:	d802      	bhi.n	801762a <rt_vsnprintf+0x332>
 8017624:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017626:	2220      	movs	r2, #32
 8017628:	701a      	strb	r2, [r3, #0]
                ++ str;
 801762a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801762c:	3301      	adds	r3, #1
 801762e:	62bb      	str	r3, [r7, #40]	; 0x28
            c = (rt_uint8_t)va_arg(args, int);
            if (str <= end) *str = c;
            ++ str;

            /* put width */
            while (--field_width > 0)
 8017630:	69bb      	ldr	r3, [r7, #24]
 8017632:	3b01      	subs	r3, #1
 8017634:	61bb      	str	r3, [r7, #24]
 8017636:	69bb      	ldr	r3, [r7, #24]
 8017638:	2b00      	cmp	r3, #0
 801763a:	dcef      	bgt.n	801761c <rt_vsnprintf+0x324>
            {
                if (str <= end) *str = ' ';
                ++ str;
            }
            continue;
 801763c:	e0e5      	b.n	801780a <rt_vsnprintf+0x512>

        case 's':
            s = va_arg(args, char *);
 801763e:	683b      	ldr	r3, [r7, #0]
 8017640:	1d1a      	adds	r2, r3, #4
 8017642:	603a      	str	r2, [r7, #0]
 8017644:	681b      	ldr	r3, [r3, #0]
 8017646:	623b      	str	r3, [r7, #32]
            if (!s) s = "(NULL)";
 8017648:	6a3b      	ldr	r3, [r7, #32]
 801764a:	2b00      	cmp	r3, #0
 801764c:	d101      	bne.n	8017652 <rt_vsnprintf+0x35a>
 801764e:	4b7c      	ldr	r3, [pc, #496]	; (8017840 <rt_vsnprintf+0x548>)
 8017650:	623b      	str	r3, [r7, #32]

            len = rt_strlen(s);
 8017652:	6a38      	ldr	r0, [r7, #32]
 8017654:	f7ff fcda 	bl	801700c <rt_strlen>
 8017658:	4603      	mov	r3, r0
 801765a:	62fb      	str	r3, [r7, #44]	; 0x2c
#ifdef RT_PRINTF_PRECISION
            if (precision > 0 && len > precision) len = precision;
 801765c:	697b      	ldr	r3, [r7, #20]
 801765e:	2b00      	cmp	r3, #0
 8017660:	dd05      	ble.n	801766e <rt_vsnprintf+0x376>
 8017662:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8017664:	697b      	ldr	r3, [r7, #20]
 8017666:	429a      	cmp	r2, r3
 8017668:	dd01      	ble.n	801766e <rt_vsnprintf+0x376>
 801766a:	697b      	ldr	r3, [r7, #20]
 801766c:	62fb      	str	r3, [r7, #44]	; 0x2c
#endif

            if (!(flags & LEFT))
 801766e:	7fbb      	ldrb	r3, [r7, #30]
 8017670:	f003 0310 	and.w	r3, r3, #16
 8017674:	2b00      	cmp	r3, #0
 8017676:	d110      	bne.n	801769a <rt_vsnprintf+0x3a2>
            {
                while (len < field_width--)
 8017678:	e009      	b.n	801768e <rt_vsnprintf+0x396>
                {
                    if (str <= end) *str = ' ';
 801767a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801767c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801767e:	429a      	cmp	r2, r3
 8017680:	d802      	bhi.n	8017688 <rt_vsnprintf+0x390>
 8017682:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017684:	2220      	movs	r2, #32
 8017686:	701a      	strb	r2, [r3, #0]
                    ++ str;
 8017688:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801768a:	3301      	adds	r3, #1
 801768c:	62bb      	str	r3, [r7, #40]	; 0x28
            if (precision > 0 && len > precision) len = precision;
#endif

            if (!(flags & LEFT))
            {
                while (len < field_width--)
 801768e:	69bb      	ldr	r3, [r7, #24]
 8017690:	1e5a      	subs	r2, r3, #1
 8017692:	61ba      	str	r2, [r7, #24]
 8017694:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8017696:	4293      	cmp	r3, r2
 8017698:	dcef      	bgt.n	801767a <rt_vsnprintf+0x382>
                    if (str <= end) *str = ' ';
                    ++ str;
                }
            }

            for (i = 0; i < len; ++i)
 801769a:	2300      	movs	r3, #0
 801769c:	633b      	str	r3, [r7, #48]	; 0x30
 801769e:	e010      	b.n	80176c2 <rt_vsnprintf+0x3ca>
            {
                if (str <= end) *str = *s;
 80176a0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80176a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80176a4:	429a      	cmp	r2, r3
 80176a6:	d803      	bhi.n	80176b0 <rt_vsnprintf+0x3b8>
 80176a8:	6a3b      	ldr	r3, [r7, #32]
 80176aa:	781a      	ldrb	r2, [r3, #0]
 80176ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80176ae:	701a      	strb	r2, [r3, #0]
                ++ str;
 80176b0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80176b2:	3301      	adds	r3, #1
 80176b4:	62bb      	str	r3, [r7, #40]	; 0x28
                ++ s;
 80176b6:	6a3b      	ldr	r3, [r7, #32]
 80176b8:	3301      	adds	r3, #1
 80176ba:	623b      	str	r3, [r7, #32]
                    if (str <= end) *str = ' ';
                    ++ str;
                }
            }

            for (i = 0; i < len; ++i)
 80176bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80176be:	3301      	adds	r3, #1
 80176c0:	633b      	str	r3, [r7, #48]	; 0x30
 80176c2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80176c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80176c6:	429a      	cmp	r2, r3
 80176c8:	dbea      	blt.n	80176a0 <rt_vsnprintf+0x3a8>
                if (str <= end) *str = *s;
                ++ str;
                ++ s;
            }

            while (len < field_width--)
 80176ca:	e009      	b.n	80176e0 <rt_vsnprintf+0x3e8>
            {
                if (str <= end) *str = ' ';
 80176cc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80176ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80176d0:	429a      	cmp	r2, r3
 80176d2:	d802      	bhi.n	80176da <rt_vsnprintf+0x3e2>
 80176d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80176d6:	2220      	movs	r2, #32
 80176d8:	701a      	strb	r2, [r3, #0]
                ++ str;
 80176da:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80176dc:	3301      	adds	r3, #1
 80176de:	62bb      	str	r3, [r7, #40]	; 0x28
                if (str <= end) *str = *s;
                ++ str;
                ++ s;
            }

            while (len < field_width--)
 80176e0:	69bb      	ldr	r3, [r7, #24]
 80176e2:	1e5a      	subs	r2, r3, #1
 80176e4:	61ba      	str	r2, [r7, #24]
 80176e6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80176e8:	4293      	cmp	r3, r2
 80176ea:	dcef      	bgt.n	80176cc <rt_vsnprintf+0x3d4>
            {
                if (str <= end) *str = ' ';
                ++ str;
            }
            continue;
 80176ec:	e08d      	b.n	801780a <rt_vsnprintf+0x512>

        case 'p':
            if (field_width == -1)
 80176ee:	69bb      	ldr	r3, [r7, #24]
 80176f0:	f1b3 3fff 	cmp.w	r3, #4294967295
 80176f4:	d105      	bne.n	8017702 <rt_vsnprintf+0x40a>
            {
                field_width = sizeof(void *) << 1;
 80176f6:	2308      	movs	r3, #8
 80176f8:	61bb      	str	r3, [r7, #24]
                flags |= ZEROPAD;
 80176fa:	7fbb      	ldrb	r3, [r7, #30]
 80176fc:	f043 0301 	orr.w	r3, r3, #1
 8017700:	77bb      	strb	r3, [r7, #30]
            }
#ifdef RT_PRINTF_PRECISION
            str = print_number(str, end,
                               (long)va_arg(args, void *),
 8017702:	683b      	ldr	r3, [r7, #0]
 8017704:	1d1a      	adds	r2, r3, #4
 8017706:	603a      	str	r2, [r7, #0]
 8017708:	681b      	ldr	r3, [r3, #0]
            {
                field_width = sizeof(void *) << 1;
                flags |= ZEROPAD;
            }
#ifdef RT_PRINTF_PRECISION
            str = print_number(str, end,
 801770a:	461c      	mov	r4, r3
 801770c:	7fbb      	ldrb	r3, [r7, #30]
 801770e:	69ba      	ldr	r2, [r7, #24]
 8017710:	9200      	str	r2, [sp, #0]
 8017712:	697a      	ldr	r2, [r7, #20]
 8017714:	9201      	str	r2, [sp, #4]
 8017716:	9302      	str	r3, [sp, #8]
 8017718:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801771a:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801771c:	4622      	mov	r2, r4
 801771e:	2310      	movs	r3, #16
 8017720:	f7ff fd00 	bl	8017124 <print_number>
 8017724:	62b8      	str	r0, [r7, #40]	; 0x28
#else
            str = print_number(str, end,
                               (long)va_arg(args, void *),
                               16, field_width, flags);
#endif
            continue;
 8017726:	e070      	b.n	801780a <rt_vsnprintf+0x512>

        case '%':
            if (str <= end) *str = '%';
 8017728:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801772a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801772c:	429a      	cmp	r2, r3
 801772e:	d802      	bhi.n	8017736 <rt_vsnprintf+0x43e>
 8017730:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017732:	2225      	movs	r2, #37	; 0x25
 8017734:	701a      	strb	r2, [r3, #0]
            ++ str;
 8017736:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017738:	3301      	adds	r3, #1
 801773a:	62bb      	str	r3, [r7, #40]	; 0x28
            continue;
 801773c:	e065      	b.n	801780a <rt_vsnprintf+0x512>

            /* integer number formats - set up the flags and "break" */
        case 'o':
            base = 8;
 801773e:	2308      	movs	r3, #8
 8017740:	77fb      	strb	r3, [r7, #31]
            break;
 8017742:	e02a      	b.n	801779a <rt_vsnprintf+0x4a2>

        case 'X':
            flags |= LARGE;
 8017744:	7fbb      	ldrb	r3, [r7, #30]
 8017746:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801774a:	77bb      	strb	r3, [r7, #30]
        case 'x':
            base = 16;
 801774c:	2310      	movs	r3, #16
 801774e:	77fb      	strb	r3, [r7, #31]
            break;
 8017750:	e023      	b.n	801779a <rt_vsnprintf+0x4a2>

        case 'd':
        case 'i':
            flags |= SIGN;
 8017752:	7fbb      	ldrb	r3, [r7, #30]
 8017754:	f043 0302 	orr.w	r3, r3, #2
 8017758:	77bb      	strb	r3, [r7, #30]
        case 'u':
            break;
 801775a:	e01d      	b.n	8017798 <rt_vsnprintf+0x4a0>

        default:
            if (str <= end) *str = '%';
 801775c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801775e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017760:	429a      	cmp	r2, r3
 8017762:	d802      	bhi.n	801776a <rt_vsnprintf+0x472>
 8017764:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017766:	2225      	movs	r2, #37	; 0x25
 8017768:	701a      	strb	r2, [r3, #0]
            ++ str;
 801776a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801776c:	3301      	adds	r3, #1
 801776e:	62bb      	str	r3, [r7, #40]	; 0x28

            if (*fmt)
 8017770:	687b      	ldr	r3, [r7, #4]
 8017772:	781b      	ldrb	r3, [r3, #0]
 8017774:	2b00      	cmp	r3, #0
 8017776:	d00b      	beq.n	8017790 <rt_vsnprintf+0x498>
            {
                if (str <= end) *str = *fmt;
 8017778:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801777a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801777c:	429a      	cmp	r2, r3
 801777e:	d803      	bhi.n	8017788 <rt_vsnprintf+0x490>
 8017780:	687b      	ldr	r3, [r7, #4]
 8017782:	781a      	ldrb	r2, [r3, #0]
 8017784:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017786:	701a      	strb	r2, [r3, #0]
                ++ str;
 8017788:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801778a:	3301      	adds	r3, #1
 801778c:	62bb      	str	r3, [r7, #40]	; 0x28
            }
            else
            {
                -- fmt;
            }
            continue;
 801778e:	e03c      	b.n	801780a <rt_vsnprintf+0x512>
                if (str <= end) *str = *fmt;
                ++ str;
            }
            else
            {
                -- fmt;
 8017790:	687b      	ldr	r3, [r7, #4]
 8017792:	3b01      	subs	r3, #1
 8017794:	607b      	str	r3, [r7, #4]
            }
            continue;
 8017796:	e038      	b.n	801780a <rt_vsnprintf+0x512>

        case 'd':
        case 'i':
            flags |= SIGN;
        case 'u':
            break;
 8017798:	bf00      	nop

#ifdef RT_PRINTF_LONGLONG
        if (qualifier == 'L') num = va_arg(args, long long);
        else if (qualifier == 'l')
#else
        if (qualifier == 'l')
 801779a:	7f7b      	ldrb	r3, [r7, #29]
 801779c:	2b6c      	cmp	r3, #108	; 0x6c
 801779e:	d109      	bne.n	80177b4 <rt_vsnprintf+0x4bc>
#endif
        {
            num = va_arg(args, rt_uint32_t);
 80177a0:	683b      	ldr	r3, [r7, #0]
 80177a2:	1d1a      	adds	r2, r3, #4
 80177a4:	603a      	str	r2, [r7, #0]
 80177a6:	681b      	ldr	r3, [r3, #0]
 80177a8:	637b      	str	r3, [r7, #52]	; 0x34
            if (flags & SIGN) num = (rt_int32_t)num;
 80177aa:	7fbb      	ldrb	r3, [r7, #30]
 80177ac:	f003 0302 	and.w	r3, r3, #2
 80177b0:	2b00      	cmp	r3, #0
 80177b2:	e01b      	b.n	80177ec <rt_vsnprintf+0x4f4>
        }
        else if (qualifier == 'h')
 80177b4:	7f7b      	ldrb	r3, [r7, #29]
 80177b6:	2b68      	cmp	r3, #104	; 0x68
 80177b8:	d10f      	bne.n	80177da <rt_vsnprintf+0x4e2>
        {
            num = (rt_uint16_t)va_arg(args, rt_int32_t);
 80177ba:	683b      	ldr	r3, [r7, #0]
 80177bc:	1d1a      	adds	r2, r3, #4
 80177be:	603a      	str	r2, [r7, #0]
 80177c0:	681b      	ldr	r3, [r3, #0]
 80177c2:	b29b      	uxth	r3, r3
 80177c4:	637b      	str	r3, [r7, #52]	; 0x34
            if (flags & SIGN) num = (rt_int16_t)num;
 80177c6:	7fbb      	ldrb	r3, [r7, #30]
 80177c8:	f003 0302 	and.w	r3, r3, #2
 80177cc:	2b00      	cmp	r3, #0
 80177ce:	d00d      	beq.n	80177ec <rt_vsnprintf+0x4f4>
 80177d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80177d2:	b29b      	uxth	r3, r3
 80177d4:	b21b      	sxth	r3, r3
 80177d6:	637b      	str	r3, [r7, #52]	; 0x34
 80177d8:	e008      	b.n	80177ec <rt_vsnprintf+0x4f4>
        }
        else
        {
            num = va_arg(args, rt_uint32_t);
 80177da:	683b      	ldr	r3, [r7, #0]
 80177dc:	1d1a      	adds	r2, r3, #4
 80177de:	603a      	str	r2, [r7, #0]
 80177e0:	681b      	ldr	r3, [r3, #0]
 80177e2:	637b      	str	r3, [r7, #52]	; 0x34
            if (flags & SIGN) num = (rt_int32_t)num;
 80177e4:	7fbb      	ldrb	r3, [r7, #30]
 80177e6:	f003 0302 	and.w	r3, r3, #2
 80177ea:	2b00      	cmp	r3, #0
        }
#ifdef RT_PRINTF_PRECISION
        str = print_number(str, end, num, base, field_width, precision, flags);
 80177ec:	6b7d      	ldr	r5, [r7, #52]	; 0x34
 80177ee:	7ffc      	ldrb	r4, [r7, #31]
 80177f0:	7fbb      	ldrb	r3, [r7, #30]
 80177f2:	69ba      	ldr	r2, [r7, #24]
 80177f4:	9200      	str	r2, [sp, #0]
 80177f6:	697a      	ldr	r2, [r7, #20]
 80177f8:	9201      	str	r2, [sp, #4]
 80177fa:	9302      	str	r3, [sp, #8]
 80177fc:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80177fe:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8017800:	462a      	mov	r2, r5
 8017802:	4623      	mov	r3, r4
 8017804:	f7ff fc8e 	bl	8017124 <print_number>
 8017808:	62b8      	str	r0, [r7, #40]	; 0x28
    {
        end  = ((char *)-1);
        size = end - buf;
    }

    for (; *fmt ; ++fmt)
 801780a:	687b      	ldr	r3, [r7, #4]
 801780c:	3301      	adds	r3, #1
 801780e:	607b      	str	r3, [r7, #4]
 8017810:	687b      	ldr	r3, [r7, #4]
 8017812:	781b      	ldrb	r3, [r3, #0]
 8017814:	2b00      	cmp	r3, #0
 8017816:	f47f ad89 	bne.w	801732c <rt_vsnprintf+0x34>
#else
        str = print_number(str, end, num, base, field_width, flags);
#endif
    }

    if (str <= end) *str = '\0';
 801781a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801781c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801781e:	429a      	cmp	r2, r3
 8017820:	d803      	bhi.n	801782a <rt_vsnprintf+0x532>
 8017822:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017824:	2200      	movs	r2, #0
 8017826:	701a      	strb	r2, [r3, #0]
 8017828:	e002      	b.n	8017830 <rt_vsnprintf+0x538>
    else *end = '\0';
 801782a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801782c:	2200      	movs	r2, #0
 801782e:	701a      	strb	r2, [r3, #0]

    /* the trailing null byte doesn't count towards the total
    * ++str;
    */
    return str - buf;
 8017830:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8017832:	68fb      	ldr	r3, [r7, #12]
 8017834:	1ad3      	subs	r3, r2, r3
}
 8017836:	4618      	mov	r0, r3
 8017838:	3738      	adds	r7, #56	; 0x38
 801783a:	46bd      	mov	sp, r7
 801783c:	bdb0      	pop	{r4, r5, r7, pc}
 801783e:	bf00      	nop
 8017840:	08027714 	.word	0x08027714

08017844 <rt_console_get_device>:
 * This function returns the device using in console.
 *
 * @return the device using in console or RT_NULL
 */
rt_device_t rt_console_get_device(void)
{
 8017844:	b480      	push	{r7}
 8017846:	af00      	add	r7, sp, #0
    return _console_device;
 8017848:	4b03      	ldr	r3, [pc, #12]	; (8017858 <rt_console_get_device+0x14>)
 801784a:	681b      	ldr	r3, [r3, #0]
}
 801784c:	4618      	mov	r0, r3
 801784e:	46bd      	mov	sp, r7
 8017850:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017854:	4770      	bx	lr
 8017856:	bf00      	nop
 8017858:	20010cd4 	.word	0x20010cd4

0801785c <rt_console_set_device>:
 * @param name the name of new console device
 *
 * @return the old console device handler
 */
rt_device_t rt_console_set_device(const char *name)
{
 801785c:	b580      	push	{r7, lr}
 801785e:	b084      	sub	sp, #16
 8017860:	af00      	add	r7, sp, #0
 8017862:	6078      	str	r0, [r7, #4]
    rt_device_t new, old;

    /* save old device */
    old = _console_device;
 8017864:	4b0f      	ldr	r3, [pc, #60]	; (80178a4 <rt_console_set_device+0x48>)
 8017866:	681b      	ldr	r3, [r3, #0]
 8017868:	60fb      	str	r3, [r7, #12]

    /* find new console device */
    new = rt_device_find(name);
 801786a:	6878      	ldr	r0, [r7, #4]
 801786c:	f7fe f998 	bl	8015ba0 <rt_device_find>
 8017870:	60b8      	str	r0, [r7, #8]
    if (new != RT_NULL)
 8017872:	68bb      	ldr	r3, [r7, #8]
 8017874:	2b00      	cmp	r3, #0
 8017876:	d00f      	beq.n	8017898 <rt_console_set_device+0x3c>
    {
        if (_console_device != RT_NULL)
 8017878:	4b0a      	ldr	r3, [pc, #40]	; (80178a4 <rt_console_set_device+0x48>)
 801787a:	681b      	ldr	r3, [r3, #0]
 801787c:	2b00      	cmp	r3, #0
 801787e:	d004      	beq.n	801788a <rt_console_set_device+0x2e>
        {
            /* close old console device */
            rt_device_close(_console_device);
 8017880:	4b08      	ldr	r3, [pc, #32]	; (80178a4 <rt_console_set_device+0x48>)
 8017882:	681b      	ldr	r3, [r3, #0]
 8017884:	4618      	mov	r0, r3
 8017886:	f7fe fa3b 	bl	8015d00 <rt_device_close>
        }

        /* set new console device */
        rt_device_open(new, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);
 801788a:	68b8      	ldr	r0, [r7, #8]
 801788c:	2143      	movs	r1, #67	; 0x43
 801788e:	f7fe f9c3 	bl	8015c18 <rt_device_open>
        _console_device = new;
 8017892:	4a04      	ldr	r2, [pc, #16]	; (80178a4 <rt_console_set_device+0x48>)
 8017894:	68bb      	ldr	r3, [r7, #8]
 8017896:	6013      	str	r3, [r2, #0]
    }

    return old;
 8017898:	68fb      	ldr	r3, [r7, #12]
}
 801789a:	4618      	mov	r0, r3
 801789c:	3710      	adds	r7, #16
 801789e:	46bd      	mov	sp, r7
 80178a0:	bd80      	pop	{r7, pc}
 80178a2:	bf00      	nop
 80178a4:	20010cd4 	.word	0x20010cd4

080178a8 <rt_hw_console_output>:
RTM_EXPORT(rt_console_set_device);
#endif

WEAK void rt_hw_console_output(const char *str)
{
 80178a8:	b480      	push	{r7}
 80178aa:	b083      	sub	sp, #12
 80178ac:	af00      	add	r7, sp, #0
 80178ae:	6078      	str	r0, [r7, #4]
    /* empty console output */
}
 80178b0:	370c      	adds	r7, #12
 80178b2:	46bd      	mov	sp, r7
 80178b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80178b8:	4770      	bx	lr
 80178ba:	bf00      	nop

080178bc <rt_kprintf>:
 * This function will print a formatted string on system console
 *
 * @param fmt the format
 */
void rt_kprintf(const char *fmt, ...)
{
 80178bc:	b40f      	push	{r0, r1, r2, r3}
 80178be:	b580      	push	{r7, lr}
 80178c0:	b084      	sub	sp, #16
 80178c2:	af00      	add	r7, sp, #0
    va_list args;
    rt_size_t length;
    static char rt_log_buf[RT_CONSOLEBUF_SIZE];

    va_start(args, fmt);
 80178c4:	f107 031c 	add.w	r3, r7, #28
 80178c8:	607b      	str	r3, [r7, #4]
    /* the return value of vsnprintf is the number of bytes that would be
     * written to buffer had if the size of the buffer been sufficiently
     * large excluding the terminating null byte. If the output string
     * would be larger than the rt_log_buf, we have to adjust the output
     * length. */
    length = rt_vsnprintf(rt_log_buf, sizeof(rt_log_buf) - 1, fmt, args);
 80178ca:	481a      	ldr	r0, [pc, #104]	; (8017934 <rt_kprintf+0x78>)
 80178cc:	217f      	movs	r1, #127	; 0x7f
 80178ce:	69ba      	ldr	r2, [r7, #24]
 80178d0:	687b      	ldr	r3, [r7, #4]
 80178d2:	f7ff fd11 	bl	80172f8 <rt_vsnprintf>
 80178d6:	4603      	mov	r3, r0
 80178d8:	60fb      	str	r3, [r7, #12]
    if (length > RT_CONSOLEBUF_SIZE - 1)
 80178da:	68fb      	ldr	r3, [r7, #12]
 80178dc:	2b7f      	cmp	r3, #127	; 0x7f
 80178de:	d901      	bls.n	80178e4 <rt_kprintf+0x28>
        length = RT_CONSOLEBUF_SIZE - 1;
 80178e0:	237f      	movs	r3, #127	; 0x7f
 80178e2:	60fb      	str	r3, [r7, #12]
#ifdef RT_USING_DEVICE
    if (_console_device == RT_NULL)
 80178e4:	4b14      	ldr	r3, [pc, #80]	; (8017938 <rt_kprintf+0x7c>)
 80178e6:	681b      	ldr	r3, [r3, #0]
 80178e8:	2b00      	cmp	r3, #0
 80178ea:	d103      	bne.n	80178f4 <rt_kprintf+0x38>
    {
        rt_hw_console_output(rt_log_buf);
 80178ec:	4811      	ldr	r0, [pc, #68]	; (8017934 <rt_kprintf+0x78>)
 80178ee:	f7ff ffdb 	bl	80178a8 <rt_hw_console_output>
 80178f2:	e018      	b.n	8017926 <rt_kprintf+0x6a>
    }
    else
    {
        rt_uint16_t old_flag = _console_device->open_flag;
 80178f4:	4b10      	ldr	r3, [pc, #64]	; (8017938 <rt_kprintf+0x7c>)
 80178f6:	681b      	ldr	r3, [r3, #0]
 80178f8:	8b1b      	ldrh	r3, [r3, #24]
 80178fa:	817b      	strh	r3, [r7, #10]

        _console_device->open_flag |= RT_DEVICE_FLAG_STREAM;
 80178fc:	4b0e      	ldr	r3, [pc, #56]	; (8017938 <rt_kprintf+0x7c>)
 80178fe:	681b      	ldr	r3, [r3, #0]
 8017900:	4a0d      	ldr	r2, [pc, #52]	; (8017938 <rt_kprintf+0x7c>)
 8017902:	6812      	ldr	r2, [r2, #0]
 8017904:	8b12      	ldrh	r2, [r2, #24]
 8017906:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 801790a:	b292      	uxth	r2, r2
 801790c:	831a      	strh	r2, [r3, #24]
        rt_device_write(_console_device, 0, rt_log_buf, length);
 801790e:	4b0a      	ldr	r3, [pc, #40]	; (8017938 <rt_kprintf+0x7c>)
 8017910:	681b      	ldr	r3, [r3, #0]
 8017912:	4618      	mov	r0, r3
 8017914:	2100      	movs	r1, #0
 8017916:	4a07      	ldr	r2, [pc, #28]	; (8017934 <rt_kprintf+0x78>)
 8017918:	68fb      	ldr	r3, [r7, #12]
 801791a:	f7fe fa63 	bl	8015de4 <rt_device_write>
        _console_device->open_flag = old_flag;
 801791e:	4b06      	ldr	r3, [pc, #24]	; (8017938 <rt_kprintf+0x7c>)
 8017920:	681b      	ldr	r3, [r3, #0]
 8017922:	897a      	ldrh	r2, [r7, #10]
 8017924:	831a      	strh	r2, [r3, #24]
    }
#else
    rt_hw_console_output(rt_log_buf);
#endif
    va_end(args);
}
 8017926:	3710      	adds	r7, #16
 8017928:	46bd      	mov	sp, r7
 801792a:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 801792e:	b004      	add	sp, #16
 8017930:	4770      	bx	lr
 8017932:	bf00      	nop
 8017934:	20010cd8 	.word	0x20010cd8
 8017938:	20010cd4 	.word	0x20010cd4

0801793c <__rt_ffs>:
 *
 * @return return the index of the first bit set. If value is 0, then this function
 * shall return 0.
 */
int __rt_ffs(int value)
{
 801793c:	b480      	push	{r7}
 801793e:	b083      	sub	sp, #12
 8017940:	af00      	add	r7, sp, #0
 8017942:	6078      	str	r0, [r7, #4]
    if (value == 0) return 0;
 8017944:	687b      	ldr	r3, [r7, #4]
 8017946:	2b00      	cmp	r3, #0
 8017948:	d101      	bne.n	801794e <__rt_ffs+0x12>
 801794a:	2300      	movs	r3, #0
 801794c:	e028      	b.n	80179a0 <__rt_ffs+0x64>

    if (value & 0xff)
 801794e:	687b      	ldr	r3, [r7, #4]
 8017950:	b2db      	uxtb	r3, r3
 8017952:	2b00      	cmp	r3, #0
 8017954:	d005      	beq.n	8017962 <__rt_ffs+0x26>
        return __lowest_bit_bitmap[value & 0xff] + 1;
 8017956:	687b      	ldr	r3, [r7, #4]
 8017958:	b2db      	uxtb	r3, r3
 801795a:	4a14      	ldr	r2, [pc, #80]	; (80179ac <__rt_ffs+0x70>)
 801795c:	5cd3      	ldrb	r3, [r2, r3]
 801795e:	3301      	adds	r3, #1
 8017960:	e01e      	b.n	80179a0 <__rt_ffs+0x64>

    if (value & 0xff00)
 8017962:	687b      	ldr	r3, [r7, #4]
 8017964:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8017968:	2b00      	cmp	r3, #0
 801796a:	d007      	beq.n	801797c <__rt_ffs+0x40>
        return __lowest_bit_bitmap[(value & 0xff00) >> 8] + 9;
 801796c:	687b      	ldr	r3, [r7, #4]
 801796e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8017972:	121b      	asrs	r3, r3, #8
 8017974:	4a0d      	ldr	r2, [pc, #52]	; (80179ac <__rt_ffs+0x70>)
 8017976:	5cd3      	ldrb	r3, [r2, r3]
 8017978:	3309      	adds	r3, #9
 801797a:	e011      	b.n	80179a0 <__rt_ffs+0x64>

    if (value & 0xff0000)
 801797c:	687b      	ldr	r3, [r7, #4]
 801797e:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 8017982:	2b00      	cmp	r3, #0
 8017984:	d007      	beq.n	8017996 <__rt_ffs+0x5a>
        return __lowest_bit_bitmap[(value & 0xff0000) >> 16] + 17;
 8017986:	687b      	ldr	r3, [r7, #4]
 8017988:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 801798c:	141b      	asrs	r3, r3, #16
 801798e:	4a07      	ldr	r2, [pc, #28]	; (80179ac <__rt_ffs+0x70>)
 8017990:	5cd3      	ldrb	r3, [r2, r3]
 8017992:	3311      	adds	r3, #17
 8017994:	e004      	b.n	80179a0 <__rt_ffs+0x64>

    return __lowest_bit_bitmap[(value & 0xff000000) >> 24] + 25;
 8017996:	687b      	ldr	r3, [r7, #4]
 8017998:	0e1b      	lsrs	r3, r3, #24
 801799a:	4a04      	ldr	r2, [pc, #16]	; (80179ac <__rt_ffs+0x70>)
 801799c:	5cd3      	ldrb	r3, [r2, r3]
 801799e:	3319      	adds	r3, #25
}
 80179a0:	4618      	mov	r0, r3
 80179a2:	370c      	adds	r7, #12
 80179a4:	46bd      	mov	sp, r7
 80179a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80179aa:	4770      	bx	lr
 80179ac:	08028f44 	.word	0x08028f44

080179b0 <rt_assert_handler>:
 * @param ex the assertion condition string
 * @param func the function name when assertion.
 * @param line the file line number when assertion.
 */
void rt_assert_handler(const char* ex_string, const char* func, rt_size_t line)
{
 80179b0:	b580      	push	{r7, lr}
 80179b2:	b086      	sub	sp, #24
 80179b4:	af00      	add	r7, sp, #0
 80179b6:	60f8      	str	r0, [r7, #12]
 80179b8:	60b9      	str	r1, [r7, #8]
 80179ba:	607a      	str	r2, [r7, #4]
    volatile char dummy = 0;
 80179bc:	2300      	movs	r3, #0
 80179be:	75fb      	strb	r3, [r7, #23]

    if (rt_assert_hook == RT_NULL)
 80179c0:	4b0c      	ldr	r3, [pc, #48]	; (80179f4 <rt_assert_handler+0x44>)
 80179c2:	681b      	ldr	r3, [r3, #0]
 80179c4:	2b00      	cmp	r3, #0
 80179c6:	d10b      	bne.n	80179e0 <rt_assert_handler+0x30>
			rt_schedule();
		}
		else
#endif
		{
	        rt_kprintf("(%s) assertion failed at function:%s, line number:%d \n", ex_string, func, line);
 80179c8:	480b      	ldr	r0, [pc, #44]	; (80179f8 <rt_assert_handler+0x48>)
 80179ca:	68f9      	ldr	r1, [r7, #12]
 80179cc:	68ba      	ldr	r2, [r7, #8]
 80179ce:	687b      	ldr	r3, [r7, #4]
 80179d0:	f7ff ff74 	bl	80178bc <rt_kprintf>
	        while (dummy == 0);
 80179d4:	bf00      	nop
 80179d6:	7dfb      	ldrb	r3, [r7, #23]
 80179d8:	b2db      	uxtb	r3, r3
 80179da:	2b00      	cmp	r3, #0
 80179dc:	d0fb      	beq.n	80179d6 <rt_assert_handler+0x26>
 80179de:	e005      	b.n	80179ec <rt_assert_handler+0x3c>
		}
    }
	else
	{
        rt_assert_hook(ex_string, func, line);
 80179e0:	4b04      	ldr	r3, [pc, #16]	; (80179f4 <rt_assert_handler+0x44>)
 80179e2:	681b      	ldr	r3, [r3, #0]
 80179e4:	68f8      	ldr	r0, [r7, #12]
 80179e6:	68b9      	ldr	r1, [r7, #8]
 80179e8:	687a      	ldr	r2, [r7, #4]
 80179ea:	4798      	blx	r3
    }                                                                     
}
 80179ec:	3718      	adds	r7, #24
 80179ee:	46bd      	mov	sp, r7
 80179f0:	bd80      	pop	{r7, pc}
 80179f2:	bf00      	nop
 80179f4:	20012a3c 	.word	0x20012a3c
 80179f8:	0802771c 	.word	0x0802771c

080179fc <plug_holes>:
#ifdef RT_MEM_STATS
static rt_size_t used_mem, max_mem;
#endif

static void plug_holes(struct heap_mem *mem)
{
 80179fc:	b580      	push	{r7, lr}
 80179fe:	b084      	sub	sp, #16
 8017a00:	af00      	add	r7, sp, #0
 8017a02:	6078      	str	r0, [r7, #4]
    struct heap_mem *nmem;
    struct heap_mem *pmem;

    RT_ASSERT((rt_uint8_t *)mem >= heap_ptr);
 8017a04:	4b36      	ldr	r3, [pc, #216]	; (8017ae0 <plug_holes+0xe4>)
 8017a06:	681b      	ldr	r3, [r3, #0]
 8017a08:	687a      	ldr	r2, [r7, #4]
 8017a0a:	429a      	cmp	r2, r3
 8017a0c:	d204      	bcs.n	8017a18 <plug_holes+0x1c>
 8017a0e:	4835      	ldr	r0, [pc, #212]	; (8017ae4 <plug_holes+0xe8>)
 8017a10:	4935      	ldr	r1, [pc, #212]	; (8017ae8 <plug_holes+0xec>)
 8017a12:	228d      	movs	r2, #141	; 0x8d
 8017a14:	f7ff ffcc 	bl	80179b0 <rt_assert_handler>
    RT_ASSERT((rt_uint8_t *)mem < (rt_uint8_t *)heap_end);
 8017a18:	4b34      	ldr	r3, [pc, #208]	; (8017aec <plug_holes+0xf0>)
 8017a1a:	681b      	ldr	r3, [r3, #0]
 8017a1c:	687a      	ldr	r2, [r7, #4]
 8017a1e:	429a      	cmp	r2, r3
 8017a20:	d304      	bcc.n	8017a2c <plug_holes+0x30>
 8017a22:	4833      	ldr	r0, [pc, #204]	; (8017af0 <plug_holes+0xf4>)
 8017a24:	4930      	ldr	r1, [pc, #192]	; (8017ae8 <plug_holes+0xec>)
 8017a26:	228e      	movs	r2, #142	; 0x8e
 8017a28:	f7ff ffc2 	bl	80179b0 <rt_assert_handler>
    RT_ASSERT(mem->used == 0);
 8017a2c:	687b      	ldr	r3, [r7, #4]
 8017a2e:	885b      	ldrh	r3, [r3, #2]
 8017a30:	2b00      	cmp	r3, #0
 8017a32:	d004      	beq.n	8017a3e <plug_holes+0x42>
 8017a34:	482f      	ldr	r0, [pc, #188]	; (8017af4 <plug_holes+0xf8>)
 8017a36:	492c      	ldr	r1, [pc, #176]	; (8017ae8 <plug_holes+0xec>)
 8017a38:	228f      	movs	r2, #143	; 0x8f
 8017a3a:	f7ff ffb9 	bl	80179b0 <rt_assert_handler>

    /* plug hole forward */
    nmem = (struct heap_mem *)&heap_ptr[mem->next];
 8017a3e:	4b28      	ldr	r3, [pc, #160]	; (8017ae0 <plug_holes+0xe4>)
 8017a40:	681a      	ldr	r2, [r3, #0]
 8017a42:	687b      	ldr	r3, [r7, #4]
 8017a44:	685b      	ldr	r3, [r3, #4]
 8017a46:	4413      	add	r3, r2
 8017a48:	60fb      	str	r3, [r7, #12]
    if (mem != nmem &&
 8017a4a:	687a      	ldr	r2, [r7, #4]
 8017a4c:	68fb      	ldr	r3, [r7, #12]
 8017a4e:	429a      	cmp	r2, r3
 8017a50:	d01e      	beq.n	8017a90 <plug_holes+0x94>
        nmem->used == 0 &&
 8017a52:	68fb      	ldr	r3, [r7, #12]
 8017a54:	885b      	ldrh	r3, [r3, #2]
    RT_ASSERT((rt_uint8_t *)mem < (rt_uint8_t *)heap_end);
    RT_ASSERT(mem->used == 0);

    /* plug hole forward */
    nmem = (struct heap_mem *)&heap_ptr[mem->next];
    if (mem != nmem &&
 8017a56:	2b00      	cmp	r3, #0
 8017a58:	d11a      	bne.n	8017a90 <plug_holes+0x94>
        nmem->used == 0 &&
        (rt_uint8_t *)nmem != (rt_uint8_t *)heap_end)
 8017a5a:	4b24      	ldr	r3, [pc, #144]	; (8017aec <plug_holes+0xf0>)
 8017a5c:	681b      	ldr	r3, [r3, #0]
    RT_ASSERT(mem->used == 0);

    /* plug hole forward */
    nmem = (struct heap_mem *)&heap_ptr[mem->next];
    if (mem != nmem &&
        nmem->used == 0 &&
 8017a5e:	68fa      	ldr	r2, [r7, #12]
 8017a60:	429a      	cmp	r2, r3
 8017a62:	d015      	beq.n	8017a90 <plug_holes+0x94>
        (rt_uint8_t *)nmem != (rt_uint8_t *)heap_end)
    {
        /* if mem->next is unused and not end of heap_ptr,
         * combine mem and mem->next
         */
        if (lfree == nmem)
 8017a64:	4b24      	ldr	r3, [pc, #144]	; (8017af8 <plug_holes+0xfc>)
 8017a66:	681a      	ldr	r2, [r3, #0]
 8017a68:	68fb      	ldr	r3, [r7, #12]
 8017a6a:	429a      	cmp	r2, r3
 8017a6c:	d102      	bne.n	8017a74 <plug_holes+0x78>
        {
            lfree = mem;
 8017a6e:	4a22      	ldr	r2, [pc, #136]	; (8017af8 <plug_holes+0xfc>)
 8017a70:	687b      	ldr	r3, [r7, #4]
 8017a72:	6013      	str	r3, [r2, #0]
        }
        mem->next = nmem->next;
 8017a74:	68fb      	ldr	r3, [r7, #12]
 8017a76:	685a      	ldr	r2, [r3, #4]
 8017a78:	687b      	ldr	r3, [r7, #4]
 8017a7a:	605a      	str	r2, [r3, #4]
        ((struct heap_mem *)&heap_ptr[nmem->next])->prev = (rt_uint8_t *)mem - heap_ptr;
 8017a7c:	4b18      	ldr	r3, [pc, #96]	; (8017ae0 <plug_holes+0xe4>)
 8017a7e:	681a      	ldr	r2, [r3, #0]
 8017a80:	68fb      	ldr	r3, [r7, #12]
 8017a82:	685b      	ldr	r3, [r3, #4]
 8017a84:	4413      	add	r3, r2
 8017a86:	687a      	ldr	r2, [r7, #4]
 8017a88:	4915      	ldr	r1, [pc, #84]	; (8017ae0 <plug_holes+0xe4>)
 8017a8a:	6809      	ldr	r1, [r1, #0]
 8017a8c:	1a52      	subs	r2, r2, r1
 8017a8e:	609a      	str	r2, [r3, #8]
    }

    /* plug hole backward */
    pmem = (struct heap_mem *)&heap_ptr[mem->prev];
 8017a90:	4b13      	ldr	r3, [pc, #76]	; (8017ae0 <plug_holes+0xe4>)
 8017a92:	681a      	ldr	r2, [r3, #0]
 8017a94:	687b      	ldr	r3, [r7, #4]
 8017a96:	689b      	ldr	r3, [r3, #8]
 8017a98:	4413      	add	r3, r2
 8017a9a:	60bb      	str	r3, [r7, #8]
    if (pmem != mem && pmem->used == 0)
 8017a9c:	68ba      	ldr	r2, [r7, #8]
 8017a9e:	687b      	ldr	r3, [r7, #4]
 8017aa0:	429a      	cmp	r2, r3
 8017aa2:	d019      	beq.n	8017ad8 <plug_holes+0xdc>
 8017aa4:	68bb      	ldr	r3, [r7, #8]
 8017aa6:	885b      	ldrh	r3, [r3, #2]
 8017aa8:	2b00      	cmp	r3, #0
 8017aaa:	d115      	bne.n	8017ad8 <plug_holes+0xdc>
    {
        /* if mem->prev is unused, combine mem and mem->prev */
        if (lfree == mem)
 8017aac:	4b12      	ldr	r3, [pc, #72]	; (8017af8 <plug_holes+0xfc>)
 8017aae:	681a      	ldr	r2, [r3, #0]
 8017ab0:	687b      	ldr	r3, [r7, #4]
 8017ab2:	429a      	cmp	r2, r3
 8017ab4:	d102      	bne.n	8017abc <plug_holes+0xc0>
        {
            lfree = pmem;
 8017ab6:	4a10      	ldr	r2, [pc, #64]	; (8017af8 <plug_holes+0xfc>)
 8017ab8:	68bb      	ldr	r3, [r7, #8]
 8017aba:	6013      	str	r3, [r2, #0]
        }
        pmem->next = mem->next;
 8017abc:	687b      	ldr	r3, [r7, #4]
 8017abe:	685a      	ldr	r2, [r3, #4]
 8017ac0:	68bb      	ldr	r3, [r7, #8]
 8017ac2:	605a      	str	r2, [r3, #4]
        ((struct heap_mem *)&heap_ptr[mem->next])->prev = (rt_uint8_t *)pmem - heap_ptr;
 8017ac4:	4b06      	ldr	r3, [pc, #24]	; (8017ae0 <plug_holes+0xe4>)
 8017ac6:	681a      	ldr	r2, [r3, #0]
 8017ac8:	687b      	ldr	r3, [r7, #4]
 8017aca:	685b      	ldr	r3, [r3, #4]
 8017acc:	4413      	add	r3, r2
 8017ace:	68ba      	ldr	r2, [r7, #8]
 8017ad0:	4903      	ldr	r1, [pc, #12]	; (8017ae0 <plug_holes+0xe4>)
 8017ad2:	6809      	ldr	r1, [r1, #0]
 8017ad4:	1a52      	subs	r2, r2, r1
 8017ad6:	609a      	str	r2, [r3, #8]
    }
}
 8017ad8:	3710      	adds	r7, #16
 8017ada:	46bd      	mov	sp, r7
 8017adc:	bd80      	pop	{r7, pc}
 8017ade:	bf00      	nop
 8017ae0:	20010d60 	.word	0x20010d60
 8017ae4:	08027754 	.word	0x08027754
 8017ae8:	08029098 	.word	0x08029098
 8017aec:	20010d64 	.word	0x20010d64
 8017af0:	08027774 	.word	0x08027774
 8017af4:	080277a0 	.word	0x080277a0
 8017af8:	20010d68 	.word	0x20010d68

08017afc <rt_system_heap_init>:
 *
 * @param begin_addr the beginning address of system heap memory.
 * @param end_addr the end address of system heap memory.
 */
void rt_system_heap_init(void *begin_addr, void *end_addr)
{
 8017afc:	b580      	push	{r7, lr}
 8017afe:	b086      	sub	sp, #24
 8017b00:	af00      	add	r7, sp, #0
 8017b02:	6078      	str	r0, [r7, #4]
 8017b04:	6039      	str	r1, [r7, #0]
    struct heap_mem *mem;
    rt_uint32_t begin_align = RT_ALIGN((rt_uint32_t)begin_addr, RT_ALIGN_SIZE);
 8017b06:	687b      	ldr	r3, [r7, #4]
 8017b08:	3303      	adds	r3, #3
 8017b0a:	f023 0303 	bic.w	r3, r3, #3
 8017b0e:	617b      	str	r3, [r7, #20]
    rt_uint32_t end_align = RT_ALIGN_DOWN((rt_uint32_t)end_addr, RT_ALIGN_SIZE);
 8017b10:	683b      	ldr	r3, [r7, #0]
 8017b12:	f023 0303 	bic.w	r3, r3, #3
 8017b16:	613b      	str	r3, [r7, #16]

    RT_DEBUG_NOT_IN_INTERRUPT;
 8017b18:	f7e8 fb56 	bl	80001c8 <rt_hw_interrupt_disable>
 8017b1c:	60f8      	str	r0, [r7, #12]
 8017b1e:	f7ff f8e9 	bl	8016cf4 <rt_interrupt_get_nest>
 8017b22:	4603      	mov	r3, r0
 8017b24:	2b00      	cmp	r3, #0
 8017b26:	d008      	beq.n	8017b3a <rt_system_heap_init+0x3e>
 8017b28:	4831      	ldr	r0, [pc, #196]	; (8017bf0 <rt_system_heap_init+0xf4>)
 8017b2a:	4932      	ldr	r1, [pc, #200]	; (8017bf4 <rt_system_heap_init+0xf8>)
 8017b2c:	f7ff fec6 	bl	80178bc <rt_kprintf>
 8017b30:	4831      	ldr	r0, [pc, #196]	; (8017bf8 <rt_system_heap_init+0xfc>)
 8017b32:	4930      	ldr	r1, [pc, #192]	; (8017bf4 <rt_system_heap_init+0xf8>)
 8017b34:	22be      	movs	r2, #190	; 0xbe
 8017b36:	f7ff ff3b 	bl	80179b0 <rt_assert_handler>
 8017b3a:	68f8      	ldr	r0, [r7, #12]
 8017b3c:	f7e8 fb48 	bl	80001d0 <rt_hw_interrupt_enable>

    /* alignment addr */
    if ((end_align > (2 * SIZEOF_STRUCT_MEM)) &&
 8017b40:	693b      	ldr	r3, [r7, #16]
 8017b42:	2b18      	cmp	r3, #24
 8017b44:	d948      	bls.n	8017bd8 <rt_system_heap_init+0xdc>
        ((end_align - 2 * SIZEOF_STRUCT_MEM) >= begin_align))
 8017b46:	693b      	ldr	r3, [r7, #16]
 8017b48:	f1a3 0218 	sub.w	r2, r3, #24
    rt_uint32_t end_align = RT_ALIGN_DOWN((rt_uint32_t)end_addr, RT_ALIGN_SIZE);

    RT_DEBUG_NOT_IN_INTERRUPT;

    /* alignment addr */
    if ((end_align > (2 * SIZEOF_STRUCT_MEM)) &&
 8017b4c:	697b      	ldr	r3, [r7, #20]
 8017b4e:	429a      	cmp	r2, r3
 8017b50:	d342      	bcc.n	8017bd8 <rt_system_heap_init+0xdc>
        ((end_align - 2 * SIZEOF_STRUCT_MEM) >= begin_align))
    {
        /* calculate the aligned memory size */
        mem_size_aligned = end_align - begin_align - 2 * SIZEOF_STRUCT_MEM;
 8017b52:	693a      	ldr	r2, [r7, #16]
 8017b54:	697b      	ldr	r3, [r7, #20]
 8017b56:	1ad3      	subs	r3, r2, r3
 8017b58:	3b18      	subs	r3, #24
 8017b5a:	4a28      	ldr	r2, [pc, #160]	; (8017bfc <rt_system_heap_init+0x100>)
 8017b5c:	6013      	str	r3, [r2, #0]

        return;
    }

    /* point to begin address of heap */
    heap_ptr = (rt_uint8_t *)begin_align;
 8017b5e:	697b      	ldr	r3, [r7, #20]
 8017b60:	4a27      	ldr	r2, [pc, #156]	; (8017c00 <rt_system_heap_init+0x104>)
 8017b62:	6013      	str	r3, [r2, #0]

    RT_DEBUG_LOG(RT_DEBUG_MEM, ("mem init, heap begin address 0x%x, size %d\n",
                                (rt_uint32_t)heap_ptr, mem_size_aligned));

    /* initialize the start of the heap */
    mem        = (struct heap_mem *)heap_ptr;
 8017b64:	4b26      	ldr	r3, [pc, #152]	; (8017c00 <rt_system_heap_init+0x104>)
 8017b66:	681b      	ldr	r3, [r3, #0]
 8017b68:	60bb      	str	r3, [r7, #8]
    mem->magic = HEAP_MAGIC;
 8017b6a:	68bb      	ldr	r3, [r7, #8]
 8017b6c:	f44f 52f5 	mov.w	r2, #7840	; 0x1ea0
 8017b70:	801a      	strh	r2, [r3, #0]
    mem->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
 8017b72:	4b22      	ldr	r3, [pc, #136]	; (8017bfc <rt_system_heap_init+0x100>)
 8017b74:	681b      	ldr	r3, [r3, #0]
 8017b76:	f103 020c 	add.w	r2, r3, #12
 8017b7a:	68bb      	ldr	r3, [r7, #8]
 8017b7c:	605a      	str	r2, [r3, #4]
    mem->prev  = 0;
 8017b7e:	68bb      	ldr	r3, [r7, #8]
 8017b80:	2200      	movs	r2, #0
 8017b82:	609a      	str	r2, [r3, #8]
    mem->used  = 0;
 8017b84:	68bb      	ldr	r3, [r7, #8]
 8017b86:	2200      	movs	r2, #0
 8017b88:	805a      	strh	r2, [r3, #2]

    /* initialize the end of the heap */
    heap_end        = (struct heap_mem *)&heap_ptr[mem->next];
 8017b8a:	4b1d      	ldr	r3, [pc, #116]	; (8017c00 <rt_system_heap_init+0x104>)
 8017b8c:	681a      	ldr	r2, [r3, #0]
 8017b8e:	68bb      	ldr	r3, [r7, #8]
 8017b90:	685b      	ldr	r3, [r3, #4]
 8017b92:	4413      	add	r3, r2
 8017b94:	4a1b      	ldr	r2, [pc, #108]	; (8017c04 <rt_system_heap_init+0x108>)
 8017b96:	6013      	str	r3, [r2, #0]
    heap_end->magic = HEAP_MAGIC;
 8017b98:	4b1a      	ldr	r3, [pc, #104]	; (8017c04 <rt_system_heap_init+0x108>)
 8017b9a:	681b      	ldr	r3, [r3, #0]
 8017b9c:	f44f 52f5 	mov.w	r2, #7840	; 0x1ea0
 8017ba0:	801a      	strh	r2, [r3, #0]
    heap_end->used  = 1;
 8017ba2:	4b18      	ldr	r3, [pc, #96]	; (8017c04 <rt_system_heap_init+0x108>)
 8017ba4:	681b      	ldr	r3, [r3, #0]
 8017ba6:	2201      	movs	r2, #1
 8017ba8:	805a      	strh	r2, [r3, #2]
    heap_end->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
 8017baa:	4b16      	ldr	r3, [pc, #88]	; (8017c04 <rt_system_heap_init+0x108>)
 8017bac:	681b      	ldr	r3, [r3, #0]
 8017bae:	4a13      	ldr	r2, [pc, #76]	; (8017bfc <rt_system_heap_init+0x100>)
 8017bb0:	6812      	ldr	r2, [r2, #0]
 8017bb2:	320c      	adds	r2, #12
 8017bb4:	605a      	str	r2, [r3, #4]
    heap_end->prev  = mem_size_aligned + SIZEOF_STRUCT_MEM;
 8017bb6:	4b13      	ldr	r3, [pc, #76]	; (8017c04 <rt_system_heap_init+0x108>)
 8017bb8:	681b      	ldr	r3, [r3, #0]
 8017bba:	4a10      	ldr	r2, [pc, #64]	; (8017bfc <rt_system_heap_init+0x100>)
 8017bbc:	6812      	ldr	r2, [r2, #0]
 8017bbe:	320c      	adds	r2, #12
 8017bc0:	609a      	str	r2, [r3, #8]

    rt_sem_init(&heap_sem, "heap", 1, RT_IPC_FLAG_FIFO);
 8017bc2:	4811      	ldr	r0, [pc, #68]	; (8017c08 <rt_system_heap_init+0x10c>)
 8017bc4:	4911      	ldr	r1, [pc, #68]	; (8017c0c <rt_system_heap_init+0x110>)
 8017bc6:	2201      	movs	r2, #1
 8017bc8:	2300      	movs	r3, #0
 8017bca:	f7fe fafd 	bl	80161c8 <rt_sem_init>

    /* initialize the lowest-free pointer to the start of the heap */
    lfree = (struct heap_mem *)heap_ptr;
 8017bce:	4b0c      	ldr	r3, [pc, #48]	; (8017c00 <rt_system_heap_init+0x104>)
 8017bd0:	681b      	ldr	r3, [r3, #0]
 8017bd2:	4a0f      	ldr	r2, [pc, #60]	; (8017c10 <rt_system_heap_init+0x114>)
 8017bd4:	6013      	str	r3, [r2, #0]
 8017bd6:	e007      	b.n	8017be8 <rt_system_heap_init+0xec>
        /* calculate the aligned memory size */
        mem_size_aligned = end_align - begin_align - 2 * SIZEOF_STRUCT_MEM;
    }
    else
    {
        rt_kprintf("mem init, error begin address 0x%x, and end address 0x%x\n",
 8017bd8:	687a      	ldr	r2, [r7, #4]
 8017bda:	683b      	ldr	r3, [r7, #0]
 8017bdc:	480d      	ldr	r0, [pc, #52]	; (8017c14 <rt_system_heap_init+0x118>)
 8017bde:	4611      	mov	r1, r2
 8017be0:	461a      	mov	r2, r3
 8017be2:	f7ff fe6b 	bl	80178bc <rt_kprintf>
                   (rt_uint32_t)begin_addr, (rt_uint32_t)end_addr);

        return;
 8017be6:	bf00      	nop

    rt_sem_init(&heap_sem, "heap", 1, RT_IPC_FLAG_FIFO);

    /* initialize the lowest-free pointer to the start of the heap */
    lfree = (struct heap_mem *)heap_ptr;
}
 8017be8:	3718      	adds	r7, #24
 8017bea:	46bd      	mov	sp, r7
 8017bec:	bd80      	pop	{r7, pc}
 8017bee:	bf00      	nop
 8017bf0:	080277b0 	.word	0x080277b0
 8017bf4:	080290a4 	.word	0x080290a4
 8017bf8:	080277d4 	.word	0x080277d4
 8017bfc:	20010d8c 	.word	0x20010d8c
 8017c00:	20010d60 	.word	0x20010d60
 8017c04:	20010d64 	.word	0x20010d64
 8017c08:	20010d6c 	.word	0x20010d6c
 8017c0c:	08027814 	.word	0x08027814
 8017c10:	20010d68 	.word	0x20010d68
 8017c14:	080277d8 	.word	0x080277d8

08017c18 <rt_malloc>:
 * @param size is the minimum size of the requested block in bytes.
 *
 * @return pointer to allocated memory or NULL if no free memory was found.
 */
void *rt_malloc(rt_size_t size)
{
 8017c18:	b580      	push	{r7, lr}
 8017c1a:	b088      	sub	sp, #32
 8017c1c:	af00      	add	r7, sp, #0
 8017c1e:	6078      	str	r0, [r7, #4]
    rt_size_t ptr, ptr2;
    struct heap_mem *mem, *mem2;

    RT_DEBUG_NOT_IN_INTERRUPT;
 8017c20:	f7e8 fad2 	bl	80001c8 <rt_hw_interrupt_disable>
 8017c24:	61b8      	str	r0, [r7, #24]
 8017c26:	f7ff f865 	bl	8016cf4 <rt_interrupt_get_nest>
 8017c2a:	4603      	mov	r3, r0
 8017c2c:	2b00      	cmp	r3, #0
 8017c2e:	d008      	beq.n	8017c42 <rt_malloc+0x2a>
 8017c30:	488d      	ldr	r0, [pc, #564]	; (8017e68 <rt_malloc+0x250>)
 8017c32:	498e      	ldr	r1, [pc, #568]	; (8017e6c <rt_malloc+0x254>)
 8017c34:	f7ff fe42 	bl	80178bc <rt_kprintf>
 8017c38:	488d      	ldr	r0, [pc, #564]	; (8017e70 <rt_malloc+0x258>)
 8017c3a:	498c      	ldr	r1, [pc, #560]	; (8017e6c <rt_malloc+0x254>)
 8017c3c:	22fb      	movs	r2, #251	; 0xfb
 8017c3e:	f7ff feb7 	bl	80179b0 <rt_assert_handler>
 8017c42:	69b8      	ldr	r0, [r7, #24]
 8017c44:	f7e8 fac4 	bl	80001d0 <rt_hw_interrupt_enable>

    if (size == 0)
 8017c48:	687b      	ldr	r3, [r7, #4]
 8017c4a:	2b00      	cmp	r3, #0
 8017c4c:	d101      	bne.n	8017c52 <rt_malloc+0x3a>
        return RT_NULL;
 8017c4e:	2300      	movs	r3, #0
 8017c50:	e105      	b.n	8017e5e <rt_malloc+0x246>
                                    size, RT_ALIGN(size, RT_ALIGN_SIZE)));
    else
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("malloc size %d\n", size));

    /* alignment size */
    size = RT_ALIGN(size, RT_ALIGN_SIZE);
 8017c52:	687b      	ldr	r3, [r7, #4]
 8017c54:	3303      	adds	r3, #3
 8017c56:	f023 0303 	bic.w	r3, r3, #3
 8017c5a:	607b      	str	r3, [r7, #4]

    if (size > mem_size_aligned)
 8017c5c:	4b85      	ldr	r3, [pc, #532]	; (8017e74 <rt_malloc+0x25c>)
 8017c5e:	681b      	ldr	r3, [r3, #0]
 8017c60:	687a      	ldr	r2, [r7, #4]
 8017c62:	429a      	cmp	r2, r3
 8017c64:	d901      	bls.n	8017c6a <rt_malloc+0x52>
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("no memory\n"));

        return RT_NULL;
 8017c66:	2300      	movs	r3, #0
 8017c68:	e0f9      	b.n	8017e5e <rt_malloc+0x246>
    }

    /* every data block must be at least MIN_SIZE_ALIGNED long */
    if (size < MIN_SIZE_ALIGNED)
 8017c6a:	687b      	ldr	r3, [r7, #4]
 8017c6c:	2b0b      	cmp	r3, #11
 8017c6e:	d801      	bhi.n	8017c74 <rt_malloc+0x5c>
        size = MIN_SIZE_ALIGNED;
 8017c70:	230c      	movs	r3, #12
 8017c72:	607b      	str	r3, [r7, #4]

    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
 8017c74:	4880      	ldr	r0, [pc, #512]	; (8017e78 <rt_malloc+0x260>)
 8017c76:	f04f 31ff 	mov.w	r1, #4294967295
 8017c7a:	f7fe fb0b 	bl	8016294 <rt_sem_take>

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
 8017c7e:	4b7f      	ldr	r3, [pc, #508]	; (8017e7c <rt_malloc+0x264>)
 8017c80:	681b      	ldr	r3, [r3, #0]
 8017c82:	461a      	mov	r2, r3
 8017c84:	4b7e      	ldr	r3, [pc, #504]	; (8017e80 <rt_malloc+0x268>)
 8017c86:	681b      	ldr	r3, [r3, #0]
 8017c88:	1ad3      	subs	r3, r2, r3
 8017c8a:	61fb      	str	r3, [r7, #28]
 8017c8c:	e0db      	b.n	8017e46 <rt_malloc+0x22e>
         ptr < mem_size_aligned - size;
         ptr = ((struct heap_mem *)&heap_ptr[ptr])->next)
    {
        mem = (struct heap_mem *)&heap_ptr[ptr];
 8017c8e:	4b7c      	ldr	r3, [pc, #496]	; (8017e80 <rt_malloc+0x268>)
 8017c90:	681a      	ldr	r2, [r3, #0]
 8017c92:	69fb      	ldr	r3, [r7, #28]
 8017c94:	4413      	add	r3, r2
 8017c96:	617b      	str	r3, [r7, #20]

        if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size)
 8017c98:	697b      	ldr	r3, [r7, #20]
 8017c9a:	885b      	ldrh	r3, [r3, #2]
 8017c9c:	2b00      	cmp	r3, #0
 8017c9e:	f040 80cc 	bne.w	8017e3a <rt_malloc+0x222>
 8017ca2:	697b      	ldr	r3, [r7, #20]
 8017ca4:	685a      	ldr	r2, [r3, #4]
 8017ca6:	69fb      	ldr	r3, [r7, #28]
 8017ca8:	1ad3      	subs	r3, r2, r3
 8017caa:	f1a3 020c 	sub.w	r2, r3, #12
 8017cae:	687b      	ldr	r3, [r7, #4]
 8017cb0:	429a      	cmp	r2, r3
 8017cb2:	f0c0 80c2 	bcc.w	8017e3a <rt_malloc+0x222>
        {
            /* mem is not used and at least perfect fit is possible:
             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >=
 8017cb6:	697b      	ldr	r3, [r7, #20]
 8017cb8:	685a      	ldr	r2, [r3, #4]
 8017cba:	69fb      	ldr	r3, [r7, #28]
 8017cbc:	1ad3      	subs	r3, r2, r3
 8017cbe:	f1a3 020c 	sub.w	r2, r3, #12
                (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))
 8017cc2:	687b      	ldr	r3, [r7, #4]
 8017cc4:	3318      	adds	r3, #24
        if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size)
        {
            /* mem is not used and at least perfect fit is possible:
             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >=
 8017cc6:	429a      	cmp	r2, r3
 8017cc8:	d339      	bcc.n	8017d3e <rt_malloc+0x126>
                 * struct heap_mem would fit in but no data between mem2 and mem2->next
                 * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
                 *       region that couldn't hold data, but when mem->next gets freed,
                 *       the 2 regions would be combined, resulting in more free memory
                 */
                ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 8017cca:	69fa      	ldr	r2, [r7, #28]
 8017ccc:	687b      	ldr	r3, [r7, #4]
 8017cce:	4413      	add	r3, r2
 8017cd0:	330c      	adds	r3, #12
 8017cd2:	613b      	str	r3, [r7, #16]

                /* create mem2 struct */
                mem2       = (struct heap_mem *)&heap_ptr[ptr2];
 8017cd4:	4b6a      	ldr	r3, [pc, #424]	; (8017e80 <rt_malloc+0x268>)
 8017cd6:	681a      	ldr	r2, [r3, #0]
 8017cd8:	693b      	ldr	r3, [r7, #16]
 8017cda:	4413      	add	r3, r2
 8017cdc:	60fb      	str	r3, [r7, #12]
                mem2->used = 0;
 8017cde:	68fb      	ldr	r3, [r7, #12]
 8017ce0:	2200      	movs	r2, #0
 8017ce2:	805a      	strh	r2, [r3, #2]
                mem2->next = mem->next;
 8017ce4:	697b      	ldr	r3, [r7, #20]
 8017ce6:	685a      	ldr	r2, [r3, #4]
 8017ce8:	68fb      	ldr	r3, [r7, #12]
 8017cea:	605a      	str	r2, [r3, #4]
                mem2->prev = ptr;
 8017cec:	68fb      	ldr	r3, [r7, #12]
 8017cee:	69fa      	ldr	r2, [r7, #28]
 8017cf0:	609a      	str	r2, [r3, #8]

                /* and insert it between mem and mem->next */
                mem->next = ptr2;
 8017cf2:	697b      	ldr	r3, [r7, #20]
 8017cf4:	693a      	ldr	r2, [r7, #16]
 8017cf6:	605a      	str	r2, [r3, #4]
                mem->used = 1;
 8017cf8:	697b      	ldr	r3, [r7, #20]
 8017cfa:	2201      	movs	r2, #1
 8017cfc:	805a      	strh	r2, [r3, #2]

                if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
 8017cfe:	68fb      	ldr	r3, [r7, #12]
 8017d00:	685a      	ldr	r2, [r3, #4]
 8017d02:	4b5c      	ldr	r3, [pc, #368]	; (8017e74 <rt_malloc+0x25c>)
 8017d04:	681b      	ldr	r3, [r3, #0]
 8017d06:	330c      	adds	r3, #12
 8017d08:	429a      	cmp	r2, r3
 8017d0a:	d006      	beq.n	8017d1a <rt_malloc+0x102>
                {
                    ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
 8017d0c:	4b5c      	ldr	r3, [pc, #368]	; (8017e80 <rt_malloc+0x268>)
 8017d0e:	681a      	ldr	r2, [r3, #0]
 8017d10:	68fb      	ldr	r3, [r7, #12]
 8017d12:	685b      	ldr	r3, [r3, #4]
 8017d14:	4413      	add	r3, r2
 8017d16:	693a      	ldr	r2, [r7, #16]
 8017d18:	609a      	str	r2, [r3, #8]
                }
#ifdef RT_MEM_STATS
                used_mem += (size + SIZEOF_STRUCT_MEM);
 8017d1a:	4b5a      	ldr	r3, [pc, #360]	; (8017e84 <rt_malloc+0x26c>)
 8017d1c:	681a      	ldr	r2, [r3, #0]
 8017d1e:	687b      	ldr	r3, [r7, #4]
 8017d20:	4413      	add	r3, r2
 8017d22:	330c      	adds	r3, #12
 8017d24:	4a57      	ldr	r2, [pc, #348]	; (8017e84 <rt_malloc+0x26c>)
 8017d26:	6013      	str	r3, [r2, #0]
                if (max_mem < used_mem)
 8017d28:	4b57      	ldr	r3, [pc, #348]	; (8017e88 <rt_malloc+0x270>)
 8017d2a:	681a      	ldr	r2, [r3, #0]
 8017d2c:	4b55      	ldr	r3, [pc, #340]	; (8017e84 <rt_malloc+0x26c>)
 8017d2e:	681b      	ldr	r3, [r3, #0]
 8017d30:	429a      	cmp	r2, r3
 8017d32:	d21e      	bcs.n	8017d72 <rt_malloc+0x15a>
                    max_mem = used_mem;
 8017d34:	4b53      	ldr	r3, [pc, #332]	; (8017e84 <rt_malloc+0x26c>)
 8017d36:	681b      	ldr	r3, [r3, #0]
 8017d38:	4a53      	ldr	r2, [pc, #332]	; (8017e88 <rt_malloc+0x270>)
 8017d3a:	6013      	str	r3, [r2, #0]
 8017d3c:	e019      	b.n	8017d72 <rt_malloc+0x15a>
                 * take care of this).
                 * -> near fit or excact fit: do not split, no mem2 creation
                 * also can't move mem->next directly behind mem, since mem->next
                 * will always be used at this point!
                 */
                mem->used = 1;
 8017d3e:	697b      	ldr	r3, [r7, #20]
 8017d40:	2201      	movs	r2, #1
 8017d42:	805a      	strh	r2, [r3, #2]
#ifdef RT_MEM_STATS
                used_mem += mem->next - ((rt_uint8_t*)mem - heap_ptr);
 8017d44:	697b      	ldr	r3, [r7, #20]
 8017d46:	685b      	ldr	r3, [r3, #4]
 8017d48:	4a4d      	ldr	r2, [pc, #308]	; (8017e80 <rt_malloc+0x268>)
 8017d4a:	6812      	ldr	r2, [r2, #0]
 8017d4c:	4611      	mov	r1, r2
 8017d4e:	697a      	ldr	r2, [r7, #20]
 8017d50:	1a8a      	subs	r2, r1, r2
 8017d52:	441a      	add	r2, r3
 8017d54:	4b4b      	ldr	r3, [pc, #300]	; (8017e84 <rt_malloc+0x26c>)
 8017d56:	681b      	ldr	r3, [r3, #0]
 8017d58:	4413      	add	r3, r2
 8017d5a:	4a4a      	ldr	r2, [pc, #296]	; (8017e84 <rt_malloc+0x26c>)
 8017d5c:	6013      	str	r3, [r2, #0]
                if (max_mem < used_mem)
 8017d5e:	4b4a      	ldr	r3, [pc, #296]	; (8017e88 <rt_malloc+0x270>)
 8017d60:	681a      	ldr	r2, [r3, #0]
 8017d62:	4b48      	ldr	r3, [pc, #288]	; (8017e84 <rt_malloc+0x26c>)
 8017d64:	681b      	ldr	r3, [r3, #0]
 8017d66:	429a      	cmp	r2, r3
 8017d68:	d203      	bcs.n	8017d72 <rt_malloc+0x15a>
                    max_mem = used_mem;
 8017d6a:	4b46      	ldr	r3, [pc, #280]	; (8017e84 <rt_malloc+0x26c>)
 8017d6c:	681b      	ldr	r3, [r3, #0]
 8017d6e:	4a46      	ldr	r2, [pc, #280]	; (8017e88 <rt_malloc+0x270>)
 8017d70:	6013      	str	r3, [r2, #0]
#endif
            }
            /* set memory block magic */
            mem->magic = HEAP_MAGIC;
 8017d72:	697b      	ldr	r3, [r7, #20]
 8017d74:	f44f 52f5 	mov.w	r2, #7840	; 0x1ea0
 8017d78:	801a      	strh	r2, [r3, #0]

            if (mem == lfree)
 8017d7a:	4b40      	ldr	r3, [pc, #256]	; (8017e7c <rt_malloc+0x264>)
 8017d7c:	681b      	ldr	r3, [r3, #0]
 8017d7e:	697a      	ldr	r2, [r7, #20]
 8017d80:	429a      	cmp	r2, r3
 8017d82:	d124      	bne.n	8017dce <rt_malloc+0x1b6>
            {
                /* Find next free block after mem and update lowest free pointer */
                while (lfree->used && lfree != heap_end)
 8017d84:	e007      	b.n	8017d96 <rt_malloc+0x17e>
                    lfree = (struct heap_mem *)&heap_ptr[lfree->next];
 8017d86:	4b3e      	ldr	r3, [pc, #248]	; (8017e80 <rt_malloc+0x268>)
 8017d88:	681a      	ldr	r2, [r3, #0]
 8017d8a:	4b3c      	ldr	r3, [pc, #240]	; (8017e7c <rt_malloc+0x264>)
 8017d8c:	681b      	ldr	r3, [r3, #0]
 8017d8e:	685b      	ldr	r3, [r3, #4]
 8017d90:	4413      	add	r3, r2
 8017d92:	4a3a      	ldr	r2, [pc, #232]	; (8017e7c <rt_malloc+0x264>)
 8017d94:	6013      	str	r3, [r2, #0]
            mem->magic = HEAP_MAGIC;

            if (mem == lfree)
            {
                /* Find next free block after mem and update lowest free pointer */
                while (lfree->used && lfree != heap_end)
 8017d96:	4b39      	ldr	r3, [pc, #228]	; (8017e7c <rt_malloc+0x264>)
 8017d98:	681b      	ldr	r3, [r3, #0]
 8017d9a:	885b      	ldrh	r3, [r3, #2]
 8017d9c:	2b00      	cmp	r3, #0
 8017d9e:	d005      	beq.n	8017dac <rt_malloc+0x194>
 8017da0:	4b36      	ldr	r3, [pc, #216]	; (8017e7c <rt_malloc+0x264>)
 8017da2:	681a      	ldr	r2, [r3, #0]
 8017da4:	4b39      	ldr	r3, [pc, #228]	; (8017e8c <rt_malloc+0x274>)
 8017da6:	681b      	ldr	r3, [r3, #0]
 8017da8:	429a      	cmp	r2, r3
 8017daa:	d1ec      	bne.n	8017d86 <rt_malloc+0x16e>
                    lfree = (struct heap_mem *)&heap_ptr[lfree->next];

                RT_ASSERT(((lfree == heap_end) || (!lfree->used)));
 8017dac:	4b33      	ldr	r3, [pc, #204]	; (8017e7c <rt_malloc+0x264>)
 8017dae:	681a      	ldr	r2, [r3, #0]
 8017db0:	4b36      	ldr	r3, [pc, #216]	; (8017e8c <rt_malloc+0x274>)
 8017db2:	681b      	ldr	r3, [r3, #0]
 8017db4:	429a      	cmp	r2, r3
 8017db6:	d00a      	beq.n	8017dce <rt_malloc+0x1b6>
 8017db8:	4b30      	ldr	r3, [pc, #192]	; (8017e7c <rt_malloc+0x264>)
 8017dba:	681b      	ldr	r3, [r3, #0]
 8017dbc:	885b      	ldrh	r3, [r3, #2]
 8017dbe:	2b00      	cmp	r3, #0
 8017dc0:	d005      	beq.n	8017dce <rt_malloc+0x1b6>
 8017dc2:	4833      	ldr	r0, [pc, #204]	; (8017e90 <rt_malloc+0x278>)
 8017dc4:	4929      	ldr	r1, [pc, #164]	; (8017e6c <rt_malloc+0x254>)
 8017dc6:	f44f 72af 	mov.w	r2, #350	; 0x15e
 8017dca:	f7ff fdf1 	bl	80179b0 <rt_assert_handler>
            }

            rt_sem_release(&heap_sem);
 8017dce:	482a      	ldr	r0, [pc, #168]	; (8017e78 <rt_malloc+0x260>)
 8017dd0:	f7fe fb04 	bl	80163dc <rt_sem_release>
            RT_ASSERT((rt_uint32_t)mem + SIZEOF_STRUCT_MEM + size <= (rt_uint32_t)heap_end);
 8017dd4:	697a      	ldr	r2, [r7, #20]
 8017dd6:	687b      	ldr	r3, [r7, #4]
 8017dd8:	4413      	add	r3, r2
 8017dda:	330c      	adds	r3, #12
 8017ddc:	4a2b      	ldr	r2, [pc, #172]	; (8017e8c <rt_malloc+0x274>)
 8017dde:	6812      	ldr	r2, [r2, #0]
 8017de0:	4293      	cmp	r3, r2
 8017de2:	d905      	bls.n	8017df0 <rt_malloc+0x1d8>
 8017de4:	482b      	ldr	r0, [pc, #172]	; (8017e94 <rt_malloc+0x27c>)
 8017de6:	4921      	ldr	r1, [pc, #132]	; (8017e6c <rt_malloc+0x254>)
 8017de8:	f44f 72b1 	mov.w	r2, #354	; 0x162
 8017dec:	f7ff fde0 	bl	80179b0 <rt_assert_handler>
            RT_ASSERT((rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM) % RT_ALIGN_SIZE == 0);
 8017df0:	697b      	ldr	r3, [r7, #20]
 8017df2:	330c      	adds	r3, #12
 8017df4:	f003 0303 	and.w	r3, r3, #3
 8017df8:	2b00      	cmp	r3, #0
 8017dfa:	d005      	beq.n	8017e08 <rt_malloc+0x1f0>
 8017dfc:	4826      	ldr	r0, [pc, #152]	; (8017e98 <rt_malloc+0x280>)
 8017dfe:	491b      	ldr	r1, [pc, #108]	; (8017e6c <rt_malloc+0x254>)
 8017e00:	f240 1263 	movw	r2, #355	; 0x163
 8017e04:	f7ff fdd4 	bl	80179b0 <rt_assert_handler>
            RT_ASSERT((((rt_uint32_t)mem) & (RT_ALIGN_SIZE-1)) == 0);
 8017e08:	697b      	ldr	r3, [r7, #20]
 8017e0a:	f003 0303 	and.w	r3, r3, #3
 8017e0e:	2b00      	cmp	r3, #0
 8017e10:	d005      	beq.n	8017e1e <rt_malloc+0x206>
 8017e12:	4822      	ldr	r0, [pc, #136]	; (8017e9c <rt_malloc+0x284>)
 8017e14:	4915      	ldr	r1, [pc, #84]	; (8017e6c <rt_malloc+0x254>)
 8017e16:	f44f 72b2 	mov.w	r2, #356	; 0x164
 8017e1a:	f7ff fdc9 	bl	80179b0 <rt_assert_handler>
            RT_DEBUG_LOG(RT_DEBUG_MEM,
                         ("allocate memory at 0x%x, size: %d\n",
                          (rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM),
                          (rt_uint32_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));

            RT_OBJECT_HOOK_CALL(rt_malloc_hook,
 8017e1e:	4b20      	ldr	r3, [pc, #128]	; (8017ea0 <rt_malloc+0x288>)
 8017e20:	681b      	ldr	r3, [r3, #0]
 8017e22:	2b00      	cmp	r3, #0
 8017e24:	d006      	beq.n	8017e34 <rt_malloc+0x21c>
 8017e26:	4b1e      	ldr	r3, [pc, #120]	; (8017ea0 <rt_malloc+0x288>)
 8017e28:	681b      	ldr	r3, [r3, #0]
 8017e2a:	697a      	ldr	r2, [r7, #20]
 8017e2c:	320c      	adds	r2, #12
 8017e2e:	4610      	mov	r0, r2
 8017e30:	6879      	ldr	r1, [r7, #4]
 8017e32:	4798      	blx	r3
                                (((void *)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM)), size));

            /* return the memory data except mem struct */
            return (rt_uint8_t *)mem + SIZEOF_STRUCT_MEM;
 8017e34:	697b      	ldr	r3, [r7, #20]
 8017e36:	330c      	adds	r3, #12
 8017e38:	e011      	b.n	8017e5e <rt_malloc+0x246>
    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
         ptr < mem_size_aligned - size;
         ptr = ((struct heap_mem *)&heap_ptr[ptr])->next)
 8017e3a:	4b11      	ldr	r3, [pc, #68]	; (8017e80 <rt_malloc+0x268>)
 8017e3c:	681a      	ldr	r2, [r3, #0]
 8017e3e:	69fb      	ldr	r3, [r7, #28]
 8017e40:	4413      	add	r3, r2
 8017e42:	685b      	ldr	r3, [r3, #4]
 8017e44:	61fb      	str	r3, [r7, #28]

    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
         ptr < mem_size_aligned - size;
 8017e46:	4b0b      	ldr	r3, [pc, #44]	; (8017e74 <rt_malloc+0x25c>)
 8017e48:	681a      	ldr	r2, [r3, #0]
 8017e4a:	687b      	ldr	r3, [r7, #4]
 8017e4c:	1ad2      	subs	r2, r2, r3
        size = MIN_SIZE_ALIGNED;

    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
 8017e4e:	69fb      	ldr	r3, [r7, #28]
 8017e50:	429a      	cmp	r2, r3
 8017e52:	f63f af1c 	bhi.w	8017c8e <rt_malloc+0x76>
            /* return the memory data except mem struct */
            return (rt_uint8_t *)mem + SIZEOF_STRUCT_MEM;
        }
    }

    rt_sem_release(&heap_sem);
 8017e56:	4808      	ldr	r0, [pc, #32]	; (8017e78 <rt_malloc+0x260>)
 8017e58:	f7fe fac0 	bl	80163dc <rt_sem_release>

    return RT_NULL;
 8017e5c:	2300      	movs	r3, #0
}
 8017e5e:	4618      	mov	r0, r3
 8017e60:	3720      	adds	r7, #32
 8017e62:	46bd      	mov	sp, r7
 8017e64:	bd80      	pop	{r7, pc}
 8017e66:	bf00      	nop
 8017e68:	080277b0 	.word	0x080277b0
 8017e6c:	080290b8 	.word	0x080290b8
 8017e70:	080277d4 	.word	0x080277d4
 8017e74:	20010d8c 	.word	0x20010d8c
 8017e78:	20010d6c 	.word	0x20010d6c
 8017e7c:	20010d68 	.word	0x20010d68
 8017e80:	20010d60 	.word	0x20010d60
 8017e84:	20010d90 	.word	0x20010d90
 8017e88:	20010d94 	.word	0x20010d94
 8017e8c:	20010d64 	.word	0x20010d64
 8017e90:	0802781c 	.word	0x0802781c
 8017e94:	08027844 	.word	0x08027844
 8017e98:	0802788c 	.word	0x0802788c
 8017e9c:	080278d8 	.word	0x080278d8
 8017ea0:	20010d58 	.word	0x20010d58

08017ea4 <rt_realloc>:
 * @param newsize the required new size
 *
 * @return the changed memory block address
 */
void *rt_realloc(void *rmem, rt_size_t newsize)
{
 8017ea4:	b580      	push	{r7, lr}
 8017ea6:	b08a      	sub	sp, #40	; 0x28
 8017ea8:	af00      	add	r7, sp, #0
 8017eaa:	6078      	str	r0, [r7, #4]
 8017eac:	6039      	str	r1, [r7, #0]
    rt_size_t size;
    rt_size_t ptr, ptr2;
    struct heap_mem *mem, *mem2;
    void *nmem;

    RT_DEBUG_NOT_IN_INTERRUPT;
 8017eae:	f7e8 f98b 	bl	80001c8 <rt_hw_interrupt_disable>
 8017eb2:	6278      	str	r0, [r7, #36]	; 0x24
 8017eb4:	f7fe ff1e 	bl	8016cf4 <rt_interrupt_get_nest>
 8017eb8:	4603      	mov	r3, r0
 8017eba:	2b00      	cmp	r3, #0
 8017ebc:	d009      	beq.n	8017ed2 <rt_realloc+0x2e>
 8017ebe:	4853      	ldr	r0, [pc, #332]	; (801800c <rt_realloc+0x168>)
 8017ec0:	4953      	ldr	r1, [pc, #332]	; (8018010 <rt_realloc+0x16c>)
 8017ec2:	f7ff fcfb 	bl	80178bc <rt_kprintf>
 8017ec6:	4853      	ldr	r0, [pc, #332]	; (8018014 <rt_realloc+0x170>)
 8017ec8:	4951      	ldr	r1, [pc, #324]	; (8018010 <rt_realloc+0x16c>)
 8017eca:	f44f 72c4 	mov.w	r2, #392	; 0x188
 8017ece:	f7ff fd6f 	bl	80179b0 <rt_assert_handler>
 8017ed2:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8017ed4:	f7e8 f97c 	bl	80001d0 <rt_hw_interrupt_enable>

    /* alignment size */
    newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);
 8017ed8:	683b      	ldr	r3, [r7, #0]
 8017eda:	3303      	adds	r3, #3
 8017edc:	f023 0303 	bic.w	r3, r3, #3
 8017ee0:	603b      	str	r3, [r7, #0]
    if (newsize > mem_size_aligned)
 8017ee2:	4b4d      	ldr	r3, [pc, #308]	; (8018018 <rt_realloc+0x174>)
 8017ee4:	681b      	ldr	r3, [r3, #0]
 8017ee6:	683a      	ldr	r2, [r7, #0]
 8017ee8:	429a      	cmp	r2, r3
 8017eea:	d901      	bls.n	8017ef0 <rt_realloc+0x4c>
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("realloc: out of memory\n"));

        return RT_NULL;
 8017eec:	2300      	movs	r3, #0
 8017eee:	e089      	b.n	8018004 <rt_realloc+0x160>
    }

    /* allocate a new memory block */
    if (rmem == RT_NULL)
 8017ef0:	687b      	ldr	r3, [r7, #4]
 8017ef2:	2b00      	cmp	r3, #0
 8017ef4:	d104      	bne.n	8017f00 <rt_realloc+0x5c>
        return rt_malloc(newsize);
 8017ef6:	6838      	ldr	r0, [r7, #0]
 8017ef8:	f7ff fe8e 	bl	8017c18 <rt_malloc>
 8017efc:	4603      	mov	r3, r0
 8017efe:	e081      	b.n	8018004 <rt_realloc+0x160>

    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
 8017f00:	4846      	ldr	r0, [pc, #280]	; (801801c <rt_realloc+0x178>)
 8017f02:	f04f 31ff 	mov.w	r1, #4294967295
 8017f06:	f7fe f9c5 	bl	8016294 <rt_sem_take>

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
 8017f0a:	4b45      	ldr	r3, [pc, #276]	; (8018020 <rt_realloc+0x17c>)
 8017f0c:	681b      	ldr	r3, [r3, #0]
 8017f0e:	687a      	ldr	r2, [r7, #4]
 8017f10:	429a      	cmp	r2, r3
 8017f12:	d304      	bcc.n	8017f1e <rt_realloc+0x7a>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
 8017f14:	4b43      	ldr	r3, [pc, #268]	; (8018024 <rt_realloc+0x180>)
 8017f16:	681b      	ldr	r3, [r3, #0]
    if (rmem == RT_NULL)
        return rt_malloc(newsize);

    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
 8017f18:	687a      	ldr	r2, [r7, #4]
 8017f1a:	429a      	cmp	r2, r3
 8017f1c:	d304      	bcc.n	8017f28 <rt_realloc+0x84>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
    {
        /* illegal memory */
        rt_sem_release(&heap_sem);
 8017f1e:	483f      	ldr	r0, [pc, #252]	; (801801c <rt_realloc+0x178>)
 8017f20:	f7fe fa5c 	bl	80163dc <rt_sem_release>

        return rmem;
 8017f24:	687b      	ldr	r3, [r7, #4]
 8017f26:	e06d      	b.n	8018004 <rt_realloc+0x160>
    }

    mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
 8017f28:	687b      	ldr	r3, [r7, #4]
 8017f2a:	3b0c      	subs	r3, #12
 8017f2c:	623b      	str	r3, [r7, #32]

    ptr = (rt_uint8_t *)mem - heap_ptr;
 8017f2e:	6a3b      	ldr	r3, [r7, #32]
 8017f30:	4a3b      	ldr	r2, [pc, #236]	; (8018020 <rt_realloc+0x17c>)
 8017f32:	6812      	ldr	r2, [r2, #0]
 8017f34:	1a9b      	subs	r3, r3, r2
 8017f36:	61fb      	str	r3, [r7, #28]
    size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 8017f38:	6a3b      	ldr	r3, [r7, #32]
 8017f3a:	685a      	ldr	r2, [r3, #4]
 8017f3c:	69fb      	ldr	r3, [r7, #28]
 8017f3e:	1ad3      	subs	r3, r2, r3
 8017f40:	3b0c      	subs	r3, #12
 8017f42:	61bb      	str	r3, [r7, #24]
    if (size == newsize)
 8017f44:	69ba      	ldr	r2, [r7, #24]
 8017f46:	683b      	ldr	r3, [r7, #0]
 8017f48:	429a      	cmp	r2, r3
 8017f4a:	d104      	bne.n	8017f56 <rt_realloc+0xb2>
    {
        /* the size is the same as */
        rt_sem_release(&heap_sem);
 8017f4c:	4833      	ldr	r0, [pc, #204]	; (801801c <rt_realloc+0x178>)
 8017f4e:	f7fe fa45 	bl	80163dc <rt_sem_release>

        return rmem;
 8017f52:	687b      	ldr	r3, [r7, #4]
 8017f54:	e056      	b.n	8018004 <rt_realloc+0x160>
    }

    if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE < size)
 8017f56:	683b      	ldr	r3, [r7, #0]
 8017f58:	f103 0218 	add.w	r2, r3, #24
 8017f5c:	69bb      	ldr	r3, [r7, #24]
 8017f5e:	429a      	cmp	r2, r3
 8017f60:	d238      	bcs.n	8017fd4 <rt_realloc+0x130>
    {
        /* split memory block */
#ifdef RT_MEM_STATS
        used_mem -= (size - newsize);
 8017f62:	683a      	ldr	r2, [r7, #0]
 8017f64:	69bb      	ldr	r3, [r7, #24]
 8017f66:	1ad2      	subs	r2, r2, r3
 8017f68:	4b2f      	ldr	r3, [pc, #188]	; (8018028 <rt_realloc+0x184>)
 8017f6a:	681b      	ldr	r3, [r3, #0]
 8017f6c:	4413      	add	r3, r2
 8017f6e:	4a2e      	ldr	r2, [pc, #184]	; (8018028 <rt_realloc+0x184>)
 8017f70:	6013      	str	r3, [r2, #0]
#endif

        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 8017f72:	69fa      	ldr	r2, [r7, #28]
 8017f74:	683b      	ldr	r3, [r7, #0]
 8017f76:	4413      	add	r3, r2
 8017f78:	330c      	adds	r3, #12
 8017f7a:	617b      	str	r3, [r7, #20]
        mem2 = (struct heap_mem *)&heap_ptr[ptr2];
 8017f7c:	4b28      	ldr	r3, [pc, #160]	; (8018020 <rt_realloc+0x17c>)
 8017f7e:	681a      	ldr	r2, [r3, #0]
 8017f80:	697b      	ldr	r3, [r7, #20]
 8017f82:	4413      	add	r3, r2
 8017f84:	613b      	str	r3, [r7, #16]
        mem2->magic= HEAP_MAGIC;
 8017f86:	693b      	ldr	r3, [r7, #16]
 8017f88:	f44f 52f5 	mov.w	r2, #7840	; 0x1ea0
 8017f8c:	801a      	strh	r2, [r3, #0]
        mem2->used = 0;
 8017f8e:	693b      	ldr	r3, [r7, #16]
 8017f90:	2200      	movs	r2, #0
 8017f92:	805a      	strh	r2, [r3, #2]
        mem2->next = mem->next;
 8017f94:	6a3b      	ldr	r3, [r7, #32]
 8017f96:	685a      	ldr	r2, [r3, #4]
 8017f98:	693b      	ldr	r3, [r7, #16]
 8017f9a:	605a      	str	r2, [r3, #4]
        mem2->prev = ptr;
 8017f9c:	693b      	ldr	r3, [r7, #16]
 8017f9e:	69fa      	ldr	r2, [r7, #28]
 8017fa0:	609a      	str	r2, [r3, #8]
        mem->next = ptr2;
 8017fa2:	6a3b      	ldr	r3, [r7, #32]
 8017fa4:	697a      	ldr	r2, [r7, #20]
 8017fa6:	605a      	str	r2, [r3, #4]
        if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
 8017fa8:	693b      	ldr	r3, [r7, #16]
 8017faa:	685a      	ldr	r2, [r3, #4]
 8017fac:	4b1a      	ldr	r3, [pc, #104]	; (8018018 <rt_realloc+0x174>)
 8017fae:	681b      	ldr	r3, [r3, #0]
 8017fb0:	330c      	adds	r3, #12
 8017fb2:	429a      	cmp	r2, r3
 8017fb4:	d006      	beq.n	8017fc4 <rt_realloc+0x120>
        {
            ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
 8017fb6:	4b1a      	ldr	r3, [pc, #104]	; (8018020 <rt_realloc+0x17c>)
 8017fb8:	681a      	ldr	r2, [r3, #0]
 8017fba:	693b      	ldr	r3, [r7, #16]
 8017fbc:	685b      	ldr	r3, [r3, #4]
 8017fbe:	4413      	add	r3, r2
 8017fc0:	697a      	ldr	r2, [r7, #20]
 8017fc2:	609a      	str	r2, [r3, #8]
        }

        plug_holes(mem2);
 8017fc4:	6938      	ldr	r0, [r7, #16]
 8017fc6:	f7ff fd19 	bl	80179fc <plug_holes>

        rt_sem_release(&heap_sem);
 8017fca:	4814      	ldr	r0, [pc, #80]	; (801801c <rt_realloc+0x178>)
 8017fcc:	f7fe fa06 	bl	80163dc <rt_sem_release>

        return rmem;
 8017fd0:	687b      	ldr	r3, [r7, #4]
 8017fd2:	e017      	b.n	8018004 <rt_realloc+0x160>
    }
    rt_sem_release(&heap_sem);
 8017fd4:	4811      	ldr	r0, [pc, #68]	; (801801c <rt_realloc+0x178>)
 8017fd6:	f7fe fa01 	bl	80163dc <rt_sem_release>

    /* expand memory */
    nmem = rt_malloc(newsize);
 8017fda:	6838      	ldr	r0, [r7, #0]
 8017fdc:	f7ff fe1c 	bl	8017c18 <rt_malloc>
 8017fe0:	60f8      	str	r0, [r7, #12]
    if (nmem != RT_NULL) /* check memory */
 8017fe2:	68fb      	ldr	r3, [r7, #12]
 8017fe4:	2b00      	cmp	r3, #0
 8017fe6:	d00c      	beq.n	8018002 <rt_realloc+0x15e>
    {
        rt_memcpy(nmem, rmem, size < newsize ? size : newsize);
 8017fe8:	683a      	ldr	r2, [r7, #0]
 8017fea:	69bb      	ldr	r3, [r7, #24]
 8017fec:	4293      	cmp	r3, r2
 8017fee:	bf28      	it	cs
 8017ff0:	4613      	movcs	r3, r2
 8017ff2:	68f8      	ldr	r0, [r7, #12]
 8017ff4:	6879      	ldr	r1, [r7, #4]
 8017ff6:	461a      	mov	r2, r3
 8017ff8:	f7fe ff04 	bl	8016e04 <rt_memcpy>
        rt_free(rmem);
 8017ffc:	6878      	ldr	r0, [r7, #4]
 8017ffe:	f000 f815 	bl	801802c <rt_free>
    }

    return nmem;
 8018002:	68fb      	ldr	r3, [r7, #12]
}
 8018004:	4618      	mov	r0, r3
 8018006:	3728      	adds	r7, #40	; 0x28
 8018008:	46bd      	mov	sp, r7
 801800a:	bd80      	pop	{r7, pc}
 801800c:	080277b0 	.word	0x080277b0
 8018010:	080290c4 	.word	0x080290c4
 8018014:	080277d4 	.word	0x080277d4
 8018018:	20010d8c 	.word	0x20010d8c
 801801c:	20010d6c 	.word	0x20010d6c
 8018020:	20010d60 	.word	0x20010d60
 8018024:	20010d64 	.word	0x20010d64
 8018028:	20010d90 	.word	0x20010d90

0801802c <rt_free>:
 * rt_malloc. The released memory block is taken back to system heap.
 *
 * @param rmem the address of memory which will be released
 */
void rt_free(void *rmem)
{
 801802c:	b580      	push	{r7, lr}
 801802e:	b084      	sub	sp, #16
 8018030:	af00      	add	r7, sp, #0
 8018032:	6078      	str	r0, [r7, #4]
    struct heap_mem *mem;

    RT_DEBUG_NOT_IN_INTERRUPT;
 8018034:	f7e8 f8c8 	bl	80001c8 <rt_hw_interrupt_disable>
 8018038:	60f8      	str	r0, [r7, #12]
 801803a:	f7fe fe5b 	bl	8016cf4 <rt_interrupt_get_nest>
 801803e:	4603      	mov	r3, r0
 8018040:	2b00      	cmp	r3, #0
 8018042:	d009      	beq.n	8018058 <rt_free+0x2c>
 8018044:	483f      	ldr	r0, [pc, #252]	; (8018144 <rt_free+0x118>)
 8018046:	4940      	ldr	r1, [pc, #256]	; (8018148 <rt_free+0x11c>)
 8018048:	f7ff fc38 	bl	80178bc <rt_kprintf>
 801804c:	483f      	ldr	r0, [pc, #252]	; (801814c <rt_free+0x120>)
 801804e:	493e      	ldr	r1, [pc, #248]	; (8018148 <rt_free+0x11c>)
 8018050:	f44f 72fe 	mov.w	r2, #508	; 0x1fc
 8018054:	f7ff fcac 	bl	80179b0 <rt_assert_handler>
 8018058:	68f8      	ldr	r0, [r7, #12]
 801805a:	f7e8 f8b9 	bl	80001d0 <rt_hw_interrupt_enable>

    if (rmem == RT_NULL)
 801805e:	687b      	ldr	r3, [r7, #4]
 8018060:	2b00      	cmp	r3, #0
 8018062:	d100      	bne.n	8018066 <rt_free+0x3a>
        return;
 8018064:	e06b      	b.n	801813e <rt_free+0x112>
    RT_ASSERT((((rt_uint32_t)rmem) & (RT_ALIGN_SIZE-1)) == 0);
 8018066:	687b      	ldr	r3, [r7, #4]
 8018068:	f003 0303 	and.w	r3, r3, #3
 801806c:	2b00      	cmp	r3, #0
 801806e:	d005      	beq.n	801807c <rt_free+0x50>
 8018070:	4837      	ldr	r0, [pc, #220]	; (8018150 <rt_free+0x124>)
 8018072:	4935      	ldr	r1, [pc, #212]	; (8018148 <rt_free+0x11c>)
 8018074:	f44f 7200 	mov.w	r2, #512	; 0x200
 8018078:	f7ff fc9a 	bl	80179b0 <rt_assert_handler>
    RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr &&
 801807c:	4b35      	ldr	r3, [pc, #212]	; (8018154 <rt_free+0x128>)
 801807e:	681b      	ldr	r3, [r3, #0]
 8018080:	687a      	ldr	r2, [r7, #4]
 8018082:	429a      	cmp	r2, r3
 8018084:	d304      	bcc.n	8018090 <rt_free+0x64>
 8018086:	4b34      	ldr	r3, [pc, #208]	; (8018158 <rt_free+0x12c>)
 8018088:	681b      	ldr	r3, [r3, #0]
 801808a:	687a      	ldr	r2, [r7, #4]
 801808c:	429a      	cmp	r2, r3
 801808e:	d305      	bcc.n	801809c <rt_free+0x70>
 8018090:	4832      	ldr	r0, [pc, #200]	; (801815c <rt_free+0x130>)
 8018092:	492d      	ldr	r1, [pc, #180]	; (8018148 <rt_free+0x11c>)
 8018094:	f240 2202 	movw	r2, #514	; 0x202
 8018098:	f7ff fc8a 	bl	80179b0 <rt_assert_handler>
              (rt_uint8_t *)rmem < (rt_uint8_t *)heap_end);

    RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));
 801809c:	4b30      	ldr	r3, [pc, #192]	; (8018160 <rt_free+0x134>)
 801809e:	681b      	ldr	r3, [r3, #0]
 80180a0:	2b00      	cmp	r3, #0
 80180a2:	d003      	beq.n	80180ac <rt_free+0x80>
 80180a4:	4b2e      	ldr	r3, [pc, #184]	; (8018160 <rt_free+0x134>)
 80180a6:	681b      	ldr	r3, [r3, #0]
 80180a8:	6878      	ldr	r0, [r7, #4]
 80180aa:	4798      	blx	r3

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
 80180ac:	4b29      	ldr	r3, [pc, #164]	; (8018154 <rt_free+0x128>)
 80180ae:	681b      	ldr	r3, [r3, #0]
 80180b0:	687a      	ldr	r2, [r7, #4]
 80180b2:	429a      	cmp	r2, r3
 80180b4:	d304      	bcc.n	80180c0 <rt_free+0x94>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
 80180b6:	4b28      	ldr	r3, [pc, #160]	; (8018158 <rt_free+0x12c>)
 80180b8:	681b      	ldr	r3, [r3, #0]
    RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr &&
              (rt_uint8_t *)rmem < (rt_uint8_t *)heap_end);

    RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
 80180ba:	687a      	ldr	r2, [r7, #4]
 80180bc:	429a      	cmp	r2, r3
 80180be:	d300      	bcc.n	80180c2 <rt_free+0x96>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("illegal memory\n"));

        return;
 80180c0:	e03d      	b.n	801813e <rt_free+0x112>
    }

    /* Get the corresponding struct heap_mem ... */
    mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
 80180c2:	687b      	ldr	r3, [r7, #4]
 80180c4:	3b0c      	subs	r3, #12
 80180c6:	60bb      	str	r3, [r7, #8]
                  (rt_uint32_t)rmem,
                  (rt_uint32_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));


    /* protect the heap from concurrent access */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
 80180c8:	4826      	ldr	r0, [pc, #152]	; (8018164 <rt_free+0x138>)
 80180ca:	f04f 31ff 	mov.w	r1, #4294967295
 80180ce:	f7fe f8e1 	bl	8016294 <rt_sem_take>

    /* ... which has to be in a used state ... */
    RT_ASSERT(mem->used);
 80180d2:	68bb      	ldr	r3, [r7, #8]
 80180d4:	885b      	ldrh	r3, [r3, #2]
 80180d6:	2b00      	cmp	r3, #0
 80180d8:	d105      	bne.n	80180e6 <rt_free+0xba>
 80180da:	4823      	ldr	r0, [pc, #140]	; (8018168 <rt_free+0x13c>)
 80180dc:	491a      	ldr	r1, [pc, #104]	; (8018148 <rt_free+0x11c>)
 80180de:	f240 221b 	movw	r2, #539	; 0x21b
 80180e2:	f7ff fc65 	bl	80179b0 <rt_assert_handler>
    RT_ASSERT(mem->magic == HEAP_MAGIC);
 80180e6:	68bb      	ldr	r3, [r7, #8]
 80180e8:	881b      	ldrh	r3, [r3, #0]
 80180ea:	f5b3 5ff5 	cmp.w	r3, #7840	; 0x1ea0
 80180ee:	d005      	beq.n	80180fc <rt_free+0xd0>
 80180f0:	481e      	ldr	r0, [pc, #120]	; (801816c <rt_free+0x140>)
 80180f2:	4915      	ldr	r1, [pc, #84]	; (8018148 <rt_free+0x11c>)
 80180f4:	f44f 7207 	mov.w	r2, #540	; 0x21c
 80180f8:	f7ff fc5a 	bl	80179b0 <rt_assert_handler>
    /* ... and is now unused. */
    mem->used  = 0;
 80180fc:	68bb      	ldr	r3, [r7, #8]
 80180fe:	2200      	movs	r2, #0
 8018100:	805a      	strh	r2, [r3, #2]
    mem->magic = 0;
 8018102:	68bb      	ldr	r3, [r7, #8]
 8018104:	2200      	movs	r2, #0
 8018106:	801a      	strh	r2, [r3, #0]

    if (mem < lfree)
 8018108:	4b19      	ldr	r3, [pc, #100]	; (8018170 <rt_free+0x144>)
 801810a:	681b      	ldr	r3, [r3, #0]
 801810c:	68ba      	ldr	r2, [r7, #8]
 801810e:	429a      	cmp	r2, r3
 8018110:	d202      	bcs.n	8018118 <rt_free+0xec>
    {
        /* the newly freed struct is now the lowest */
        lfree = mem;
 8018112:	4a17      	ldr	r2, [pc, #92]	; (8018170 <rt_free+0x144>)
 8018114:	68bb      	ldr	r3, [r7, #8]
 8018116:	6013      	str	r3, [r2, #0]
    }

#ifdef RT_MEM_STATS
    used_mem -= (mem->next - ((rt_uint8_t*)mem - heap_ptr));
 8018118:	4b16      	ldr	r3, [pc, #88]	; (8018174 <rt_free+0x148>)
 801811a:	681a      	ldr	r2, [r3, #0]
 801811c:	68bb      	ldr	r3, [r7, #8]
 801811e:	685b      	ldr	r3, [r3, #4]
 8018120:	490c      	ldr	r1, [pc, #48]	; (8018154 <rt_free+0x128>)
 8018122:	6809      	ldr	r1, [r1, #0]
 8018124:	4608      	mov	r0, r1
 8018126:	68b9      	ldr	r1, [r7, #8]
 8018128:	1a41      	subs	r1, r0, r1
 801812a:	440b      	add	r3, r1
 801812c:	1ad3      	subs	r3, r2, r3
 801812e:	4a11      	ldr	r2, [pc, #68]	; (8018174 <rt_free+0x148>)
 8018130:	6013      	str	r3, [r2, #0]
#endif

    /* finally, see if prev or next are free also */
    plug_holes(mem);
 8018132:	68b8      	ldr	r0, [r7, #8]
 8018134:	f7ff fc62 	bl	80179fc <plug_holes>
    rt_sem_release(&heap_sem);
 8018138:	480a      	ldr	r0, [pc, #40]	; (8018164 <rt_free+0x138>)
 801813a:	f7fe f94f 	bl	80163dc <rt_sem_release>
}
 801813e:	3710      	adds	r7, #16
 8018140:	46bd      	mov	sp, r7
 8018142:	bd80      	pop	{r7, pc}
 8018144:	080277b0 	.word	0x080277b0
 8018148:	080290d0 	.word	0x080290d0
 801814c:	080277d4 	.word	0x080277d4
 8018150:	08027908 	.word	0x08027908
 8018154:	20010d60 	.word	0x20010d60
 8018158:	20010d64 	.word	0x20010d64
 801815c:	08027938 	.word	0x08027938
 8018160:	20010d5c 	.word	0x20010d5c
 8018164:	20010d6c 	.word	0x20010d6c
 8018168:	08027994 	.word	0x08027994
 801816c:	080279a0 	.word	0x080279a0
 8018170:	20010d68 	.word	0x20010d68
 8018174:	20010d90 	.word	0x20010d90

08018178 <list_mem>:

#ifdef RT_USING_FINSH
#include <finsh.h>

void list_mem(void)
{
 8018178:	b580      	push	{r7, lr}
 801817a:	af00      	add	r7, sp, #0
    rt_kprintf("total memory: %d\n", mem_size_aligned);
 801817c:	4b09      	ldr	r3, [pc, #36]	; (80181a4 <list_mem+0x2c>)
 801817e:	681b      	ldr	r3, [r3, #0]
 8018180:	4809      	ldr	r0, [pc, #36]	; (80181a8 <list_mem+0x30>)
 8018182:	4619      	mov	r1, r3
 8018184:	f7ff fb9a 	bl	80178bc <rt_kprintf>
    rt_kprintf("used memory : %d\n", used_mem);
 8018188:	4b08      	ldr	r3, [pc, #32]	; (80181ac <list_mem+0x34>)
 801818a:	681b      	ldr	r3, [r3, #0]
 801818c:	4808      	ldr	r0, [pc, #32]	; (80181b0 <list_mem+0x38>)
 801818e:	4619      	mov	r1, r3
 8018190:	f7ff fb94 	bl	80178bc <rt_kprintf>
    rt_kprintf("maximum allocated memory: %d\n", max_mem);
 8018194:	4b07      	ldr	r3, [pc, #28]	; (80181b4 <list_mem+0x3c>)
 8018196:	681b      	ldr	r3, [r3, #0]
 8018198:	4807      	ldr	r0, [pc, #28]	; (80181b8 <list_mem+0x40>)
 801819a:	4619      	mov	r1, r3
 801819c:	f7ff fb8e 	bl	80178bc <rt_kprintf>
}
 80181a0:	bd80      	pop	{r7, pc}
 80181a2:	bf00      	nop
 80181a4:	20010d8c 	.word	0x20010d8c
 80181a8:	080279bc 	.word	0x080279bc
 80181ac:	20010d90 	.word	0x20010d90
 80181b0:	080279d0 	.word	0x080279d0
 80181b4:	20010d94 	.word	0x20010d94
 80181b8:	080279e4 	.word	0x080279e4

080181bc <rt_memheap_init>:
 */
rt_err_t rt_memheap_init(struct rt_memheap *memheap,
                         const char        *name,
                         void              *start_addr,
                         rt_uint32_t        size)
{
 80181bc:	b580      	push	{r7, lr}
 80181be:	b086      	sub	sp, #24
 80181c0:	af00      	add	r7, sp, #0
 80181c2:	60f8      	str	r0, [r7, #12]
 80181c4:	60b9      	str	r1, [r7, #8]
 80181c6:	607a      	str	r2, [r7, #4]
 80181c8:	603b      	str	r3, [r7, #0]
    struct rt_memheap_item *item;

    RT_ASSERT(memheap != RT_NULL);
 80181ca:	68fb      	ldr	r3, [r7, #12]
 80181cc:	2b00      	cmp	r3, #0
 80181ce:	d104      	bne.n	80181da <rt_memheap_init+0x1e>
 80181d0:	4847      	ldr	r0, [pc, #284]	; (80182f0 <rt_memheap_init+0x134>)
 80181d2:	4948      	ldr	r1, [pc, #288]	; (80182f4 <rt_memheap_init+0x138>)
 80181d4:	2243      	movs	r2, #67	; 0x43
 80181d6:	f7ff fbeb 	bl	80179b0 <rt_assert_handler>

    /* initialize pool object */
    rt_object_init(&(memheap->parent), RT_Object_Class_MemHeap, name);
 80181da:	68fb      	ldr	r3, [r7, #12]
 80181dc:	4618      	mov	r0, r3
 80181de:	2106      	movs	r1, #6
 80181e0:	68ba      	ldr	r2, [r7, #8]
 80181e2:	f000 f8c5 	bl	8018370 <rt_object_init>

    memheap->start_addr     = start_addr;
 80181e6:	68fb      	ldr	r3, [r7, #12]
 80181e8:	687a      	ldr	r2, [r7, #4]
 80181ea:	615a      	str	r2, [r3, #20]
    memheap->pool_size      = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);
 80181ec:	683b      	ldr	r3, [r7, #0]
 80181ee:	f023 0203 	bic.w	r2, r3, #3
 80181f2:	68fb      	ldr	r3, [r7, #12]
 80181f4:	619a      	str	r2, [r3, #24]
    memheap->available_size = memheap->pool_size - (2 * RT_MEMHEAP_SIZE);
 80181f6:	68fb      	ldr	r3, [r7, #12]
 80181f8:	699b      	ldr	r3, [r3, #24]
 80181fa:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 80181fe:	68fb      	ldr	r3, [r7, #12]
 8018200:	61da      	str	r2, [r3, #28]
    memheap->max_used_size  = memheap->pool_size - memheap->available_size;
 8018202:	68fb      	ldr	r3, [r7, #12]
 8018204:	699a      	ldr	r2, [r3, #24]
 8018206:	68fb      	ldr	r3, [r7, #12]
 8018208:	69db      	ldr	r3, [r3, #28]
 801820a:	1ad2      	subs	r2, r2, r3
 801820c:	68fb      	ldr	r3, [r7, #12]
 801820e:	621a      	str	r2, [r3, #32]

    /* initialize the free list header */
    item            = &(memheap->free_header);
 8018210:	68fb      	ldr	r3, [r7, #12]
 8018212:	332c      	adds	r3, #44	; 0x2c
 8018214:	617b      	str	r3, [r7, #20]
    item->magic     = RT_MEMHEAP_MAGIC;
 8018216:	697b      	ldr	r3, [r7, #20]
 8018218:	4a37      	ldr	r2, [pc, #220]	; (80182f8 <rt_memheap_init+0x13c>)
 801821a:	601a      	str	r2, [r3, #0]
    item->pool_ptr  = memheap;
 801821c:	697b      	ldr	r3, [r7, #20]
 801821e:	68fa      	ldr	r2, [r7, #12]
 8018220:	605a      	str	r2, [r3, #4]
    item->next      = RT_NULL;
 8018222:	697b      	ldr	r3, [r7, #20]
 8018224:	2200      	movs	r2, #0
 8018226:	609a      	str	r2, [r3, #8]
    item->prev      = RT_NULL;
 8018228:	697b      	ldr	r3, [r7, #20]
 801822a:	2200      	movs	r2, #0
 801822c:	60da      	str	r2, [r3, #12]
    item->next_free = item;
 801822e:	697b      	ldr	r3, [r7, #20]
 8018230:	697a      	ldr	r2, [r7, #20]
 8018232:	611a      	str	r2, [r3, #16]
    item->prev_free = item;
 8018234:	697b      	ldr	r3, [r7, #20]
 8018236:	697a      	ldr	r2, [r7, #20]
 8018238:	615a      	str	r2, [r3, #20]

    /* set the free list to free list header */
    memheap->free_list = item;
 801823a:	68fb      	ldr	r3, [r7, #12]
 801823c:	697a      	ldr	r2, [r7, #20]
 801823e:	629a      	str	r2, [r3, #40]	; 0x28

    /* initialize the first big memory block */
    item            = (struct rt_memheap_item *)start_addr;
 8018240:	687b      	ldr	r3, [r7, #4]
 8018242:	617b      	str	r3, [r7, #20]
    item->magic     = RT_MEMHEAP_MAGIC;
 8018244:	697b      	ldr	r3, [r7, #20]
 8018246:	4a2c      	ldr	r2, [pc, #176]	; (80182f8 <rt_memheap_init+0x13c>)
 8018248:	601a      	str	r2, [r3, #0]
    item->pool_ptr  = memheap;
 801824a:	697b      	ldr	r3, [r7, #20]
 801824c:	68fa      	ldr	r2, [r7, #12]
 801824e:	605a      	str	r2, [r3, #4]
    item->next      = RT_NULL;
 8018250:	697b      	ldr	r3, [r7, #20]
 8018252:	2200      	movs	r2, #0
 8018254:	609a      	str	r2, [r3, #8]
    item->prev      = RT_NULL;
 8018256:	697b      	ldr	r3, [r7, #20]
 8018258:	2200      	movs	r2, #0
 801825a:	60da      	str	r2, [r3, #12]
    item->next_free = item;
 801825c:	697b      	ldr	r3, [r7, #20]
 801825e:	697a      	ldr	r2, [r7, #20]
 8018260:	611a      	str	r2, [r3, #16]
    item->prev_free = item;
 8018262:	697b      	ldr	r3, [r7, #20]
 8018264:	697a      	ldr	r2, [r7, #20]
 8018266:	615a      	str	r2, [r3, #20]

    item->next = (struct rt_memheap_item *)
        ((rt_uint8_t *)item + memheap->available_size + RT_MEMHEAP_SIZE);
 8018268:	68fb      	ldr	r3, [r7, #12]
 801826a:	69db      	ldr	r3, [r3, #28]
 801826c:	3318      	adds	r3, #24
    item->next      = RT_NULL;
    item->prev      = RT_NULL;
    item->next_free = item;
    item->prev_free = item;

    item->next = (struct rt_memheap_item *)
 801826e:	697a      	ldr	r2, [r7, #20]
 8018270:	441a      	add	r2, r3
 8018272:	697b      	ldr	r3, [r7, #20]
 8018274:	609a      	str	r2, [r3, #8]
        ((rt_uint8_t *)item + memheap->available_size + RT_MEMHEAP_SIZE);
    item->prev = item->next;
 8018276:	697b      	ldr	r3, [r7, #20]
 8018278:	689a      	ldr	r2, [r3, #8]
 801827a:	697b      	ldr	r3, [r7, #20]
 801827c:	60da      	str	r2, [r3, #12]

    /* block list header */
    memheap->block_list = item;
 801827e:	68fb      	ldr	r3, [r7, #12]
 8018280:	697a      	ldr	r2, [r7, #20]
 8018282:	625a      	str	r2, [r3, #36]	; 0x24

    /* place the big memory block to free list */
    item->next_free = memheap->free_list->next_free;
 8018284:	68fb      	ldr	r3, [r7, #12]
 8018286:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8018288:	691a      	ldr	r2, [r3, #16]
 801828a:	697b      	ldr	r3, [r7, #20]
 801828c:	611a      	str	r2, [r3, #16]
    item->prev_free = memheap->free_list;
 801828e:	68fb      	ldr	r3, [r7, #12]
 8018290:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8018292:	697b      	ldr	r3, [r7, #20]
 8018294:	615a      	str	r2, [r3, #20]
    memheap->free_list->next_free->prev_free = item;
 8018296:	68fb      	ldr	r3, [r7, #12]
 8018298:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801829a:	691b      	ldr	r3, [r3, #16]
 801829c:	697a      	ldr	r2, [r7, #20]
 801829e:	615a      	str	r2, [r3, #20]
    memheap->free_list->next_free            = item;
 80182a0:	68fb      	ldr	r3, [r7, #12]
 80182a2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80182a4:	697a      	ldr	r2, [r7, #20]
 80182a6:	611a      	str	r2, [r3, #16]

    /* move to the end of memory pool to build a small tailer block,
     * which prevents block merging
     */
    item = item->next;
 80182a8:	697b      	ldr	r3, [r7, #20]
 80182aa:	689b      	ldr	r3, [r3, #8]
 80182ac:	617b      	str	r3, [r7, #20]
    /* it's a used memory block */
    item->magic     = RT_MEMHEAP_MAGIC | RT_MEMHEAP_USED;
 80182ae:	697b      	ldr	r3, [r7, #20]
 80182b0:	4a12      	ldr	r2, [pc, #72]	; (80182fc <rt_memheap_init+0x140>)
 80182b2:	601a      	str	r2, [r3, #0]
    item->pool_ptr  = memheap;
 80182b4:	697b      	ldr	r3, [r7, #20]
 80182b6:	68fa      	ldr	r2, [r7, #12]
 80182b8:	605a      	str	r2, [r3, #4]
    item->next      = (struct rt_memheap_item *)start_addr;
 80182ba:	697b      	ldr	r3, [r7, #20]
 80182bc:	687a      	ldr	r2, [r7, #4]
 80182be:	609a      	str	r2, [r3, #8]
    item->prev      = (struct rt_memheap_item *)start_addr;
 80182c0:	697b      	ldr	r3, [r7, #20]
 80182c2:	687a      	ldr	r2, [r7, #4]
 80182c4:	60da      	str	r2, [r3, #12]
    /* not in free list */
    item->next_free = item->prev_free = RT_NULL;
 80182c6:	697b      	ldr	r3, [r7, #20]
 80182c8:	2200      	movs	r2, #0
 80182ca:	615a      	str	r2, [r3, #20]
 80182cc:	697b      	ldr	r3, [r7, #20]
 80182ce:	695a      	ldr	r2, [r3, #20]
 80182d0:	697b      	ldr	r3, [r7, #20]
 80182d2:	611a      	str	r2, [r3, #16]

    /* initialize semaphore lock */
    rt_sem_init(&(memheap->lock), name, 1, RT_IPC_FLAG_FIFO);
 80182d4:	68fb      	ldr	r3, [r7, #12]
 80182d6:	3344      	adds	r3, #68	; 0x44
 80182d8:	4618      	mov	r0, r3
 80182da:	68b9      	ldr	r1, [r7, #8]
 80182dc:	2201      	movs	r2, #1
 80182de:	2300      	movs	r3, #0
 80182e0:	f7fd ff72 	bl	80161c8 <rt_sem_init>

    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,
                 ("memory heap: start addr 0x%08x, size %d, free list header 0x%08x\n",
                  start_addr, size, &(memheap->free_header)));

    return RT_EOK;
 80182e4:	2300      	movs	r3, #0
}
 80182e6:	4618      	mov	r0, r3
 80182e8:	3718      	adds	r7, #24
 80182ea:	46bd      	mov	sp, r7
 80182ec:	bd80      	pop	{r7, pc}
 80182ee:	bf00      	nop
 80182f0:	08027a04 	.word	0x08027a04
 80182f4:	080290d8 	.word	0x080290d8
 80182f8:	1ea01ea0 	.word	0x1ea01ea0
 80182fc:	1ea01ea1 	.word	0x1ea01ea1

08018300 <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
 8018300:	b480      	push	{r7}
 8018302:	b083      	sub	sp, #12
 8018304:	af00      	add	r7, sp, #0
 8018306:	6078      	str	r0, [r7, #4]
 8018308:	6039      	str	r1, [r7, #0]
    l->next->prev = n;
 801830a:	687b      	ldr	r3, [r7, #4]
 801830c:	681b      	ldr	r3, [r3, #0]
 801830e:	683a      	ldr	r2, [r7, #0]
 8018310:	605a      	str	r2, [r3, #4]
    n->next = l->next;
 8018312:	687b      	ldr	r3, [r7, #4]
 8018314:	681a      	ldr	r2, [r3, #0]
 8018316:	683b      	ldr	r3, [r7, #0]
 8018318:	601a      	str	r2, [r3, #0]

    l->next = n;
 801831a:	687b      	ldr	r3, [r7, #4]
 801831c:	683a      	ldr	r2, [r7, #0]
 801831e:	601a      	str	r2, [r3, #0]
    n->prev = l;
 8018320:	683b      	ldr	r3, [r7, #0]
 8018322:	687a      	ldr	r2, [r7, #4]
 8018324:	605a      	str	r2, [r3, #4]
}
 8018326:	370c      	adds	r7, #12
 8018328:	46bd      	mov	sp, r7
 801832a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801832e:	4770      	bx	lr

08018330 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 8018330:	b480      	push	{r7}
 8018332:	b083      	sub	sp, #12
 8018334:	af00      	add	r7, sp, #0
 8018336:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 8018338:	687b      	ldr	r3, [r7, #4]
 801833a:	681b      	ldr	r3, [r3, #0]
 801833c:	687a      	ldr	r2, [r7, #4]
 801833e:	6852      	ldr	r2, [r2, #4]
 8018340:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 8018342:	687b      	ldr	r3, [r7, #4]
 8018344:	685b      	ldr	r3, [r3, #4]
 8018346:	687a      	ldr	r2, [r7, #4]
 8018348:	6812      	ldr	r2, [r2, #0]
 801834a:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 801834c:	687b      	ldr	r3, [r7, #4]
 801834e:	687a      	ldr	r2, [r7, #4]
 8018350:	605a      	str	r2, [r3, #4]
 8018352:	687b      	ldr	r3, [r7, #4]
 8018354:	685a      	ldr	r2, [r3, #4]
 8018356:	687b      	ldr	r3, [r7, #4]
 8018358:	601a      	str	r2, [r3, #0]
}
 801835a:	370c      	adds	r7, #12
 801835c:	46bd      	mov	sp, r7
 801835e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018362:	4770      	bx	lr

08018364 <rt_system_object_init>:
 *
 * @deprecated since 0.3.0, this function does not need to be invoked
 * in the system initialization.
 */
void rt_system_object_init(void)
{
 8018364:	b480      	push	{r7}
 8018366:	af00      	add	r7, sp, #0
}
 8018368:	46bd      	mov	sp, r7
 801836a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801836e:	4770      	bx	lr

08018370 <rt_object_init>:
 * @param name the object name. In system, the object's name must be unique.
 */
void rt_object_init(struct rt_object         *object,
                    enum rt_object_class_type type,
                    const char               *name)
{
 8018370:	b590      	push	{r4, r7, lr}
 8018372:	b087      	sub	sp, #28
 8018374:	af00      	add	r7, sp, #0
 8018376:	60f8      	str	r0, [r7, #12]
 8018378:	460b      	mov	r3, r1
 801837a:	607a      	str	r2, [r7, #4]
 801837c:	72fb      	strb	r3, [r7, #11]
    /* get module object information */
    information = (rt_module_self() != RT_NULL) ?
        &rt_module_self()->module_object[type] : &rt_object_container[type];
#else
    /* get object information */
    information = &rt_object_container[type];
 801837e:	7afb      	ldrb	r3, [r7, #11]
 8018380:	011b      	lsls	r3, r3, #4
 8018382:	4a14      	ldr	r2, [pc, #80]	; (80183d4 <rt_object_init+0x64>)
 8018384:	4413      	add	r3, r2
 8018386:	617b      	str	r3, [r7, #20]
#endif

    /* initialize object's parameters */

    /* set object type to static */
    object->type = type | RT_Object_Class_Static;
 8018388:	7afb      	ldrb	r3, [r7, #11]
 801838a:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801838e:	b2da      	uxtb	r2, r3
 8018390:	68fb      	ldr	r3, [r7, #12]
 8018392:	721a      	strb	r2, [r3, #8]

    /* copy name */
    rt_strncpy(object->name, name, RT_NAME_MAX);
 8018394:	68fb      	ldr	r3, [r7, #12]
 8018396:	4618      	mov	r0, r3
 8018398:	6879      	ldr	r1, [r7, #4]
 801839a:	2208      	movs	r2, #8
 801839c:	f7fe fdde 	bl	8016f5c <rt_strncpy>

    RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
 80183a0:	4b0d      	ldr	r3, [pc, #52]	; (80183d8 <rt_object_init+0x68>)
 80183a2:	681b      	ldr	r3, [r3, #0]
 80183a4:	2b00      	cmp	r3, #0
 80183a6:	d003      	beq.n	80183b0 <rt_object_init+0x40>
 80183a8:	4b0b      	ldr	r3, [pc, #44]	; (80183d8 <rt_object_init+0x68>)
 80183aa:	681b      	ldr	r3, [r3, #0]
 80183ac:	68f8      	ldr	r0, [r7, #12]
 80183ae:	4798      	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
 80183b0:	f7e7 ff0a 	bl	80001c8 <rt_hw_interrupt_disable>
 80183b4:	4604      	mov	r4, r0

    /* insert object into information object list */
    rt_list_insert_after(&(information->object_list), &(object->list));
 80183b6:	697b      	ldr	r3, [r7, #20]
 80183b8:	1d1a      	adds	r2, r3, #4
 80183ba:	68fb      	ldr	r3, [r7, #12]
 80183bc:	330c      	adds	r3, #12
 80183be:	4610      	mov	r0, r2
 80183c0:	4619      	mov	r1, r3
 80183c2:	f7ff ff9d 	bl	8018300 <rt_list_insert_after>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
 80183c6:	4620      	mov	r0, r4
 80183c8:	f7e7 ff02 	bl	80001d0 <rt_hw_interrupt_enable>
}
 80183cc:	371c      	adds	r7, #28
 80183ce:	46bd      	mov	sp, r7
 80183d0:	bd90      	pop	{r4, r7, pc}
 80183d2:	bf00      	nop
 80183d4:	2001001c 	.word	0x2001001c
 80183d8:	20010d98 	.word	0x20010d98

080183dc <rt_object_detach>:
 * and the memory of static object is not freed.
 *
 * @param object the specified object to be detached.
 */
void rt_object_detach(rt_object_t object)
{
 80183dc:	b590      	push	{r4, r7, lr}
 80183de:	b083      	sub	sp, #12
 80183e0:	af00      	add	r7, sp, #0
 80183e2:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;

    /* object check */
    RT_ASSERT(object != RT_NULL);
 80183e4:	687b      	ldr	r3, [r7, #4]
 80183e6:	2b00      	cmp	r3, #0
 80183e8:	d104      	bne.n	80183f4 <rt_object_detach+0x18>
 80183ea:	480d      	ldr	r0, [pc, #52]	; (8018420 <rt_object_detach+0x44>)
 80183ec:	490d      	ldr	r1, [pc, #52]	; (8018424 <rt_object_detach+0x48>)
 80183ee:	22fb      	movs	r2, #251	; 0xfb
 80183f0:	f7ff fade 	bl	80179b0 <rt_assert_handler>

    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
 80183f4:	4b0c      	ldr	r3, [pc, #48]	; (8018428 <rt_object_detach+0x4c>)
 80183f6:	681b      	ldr	r3, [r3, #0]
 80183f8:	2b00      	cmp	r3, #0
 80183fa:	d003      	beq.n	8018404 <rt_object_detach+0x28>
 80183fc:	4b0a      	ldr	r3, [pc, #40]	; (8018428 <rt_object_detach+0x4c>)
 80183fe:	681b      	ldr	r3, [r3, #0]
 8018400:	6878      	ldr	r0, [r7, #4]
 8018402:	4798      	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
 8018404:	f7e7 fee0 	bl	80001c8 <rt_hw_interrupt_disable>
 8018408:	4604      	mov	r4, r0

    /* remove from old list */
    rt_list_remove(&(object->list));
 801840a:	687b      	ldr	r3, [r7, #4]
 801840c:	330c      	adds	r3, #12
 801840e:	4618      	mov	r0, r3
 8018410:	f7ff ff8e 	bl	8018330 <rt_list_remove>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
 8018414:	4620      	mov	r0, r4
 8018416:	f7e7 fedb 	bl	80001d0 <rt_hw_interrupt_enable>
}
 801841a:	370c      	adds	r7, #12
 801841c:	46bd      	mov	sp, r7
 801841e:	bd90      	pop	{r4, r7, pc}
 8018420:	08027af8 	.word	0x08027af8
 8018424:	080290e8 	.word	0x080290e8
 8018428:	20010d9c 	.word	0x20010d9c

0801842c <rt_object_allocate>:
 * @param name the object name. In system, the object's name must be unique.
 *
 * @return object
 */
rt_object_t rt_object_allocate(enum rt_object_class_type type, const char *name)
{
 801842c:	b590      	push	{r4, r7, lr}
 801842e:	b087      	sub	sp, #28
 8018430:	af00      	add	r7, sp, #0
 8018432:	4603      	mov	r3, r0
 8018434:	6039      	str	r1, [r7, #0]
 8018436:	71fb      	strb	r3, [r7, #7]
    struct rt_object *object;
    register rt_base_t temp;
    struct rt_object_information *information;

    RT_DEBUG_NOT_IN_INTERRUPT;
 8018438:	f7e7 fec6 	bl	80001c8 <rt_hw_interrupt_disable>
 801843c:	6178      	str	r0, [r7, #20]
 801843e:	f7fe fc59 	bl	8016cf4 <rt_interrupt_get_nest>
 8018442:	4603      	mov	r3, r0
 8018444:	2b00      	cmp	r3, #0
 8018446:	d009      	beq.n	801845c <rt_object_allocate+0x30>
 8018448:	4821      	ldr	r0, [pc, #132]	; (80184d0 <rt_object_allocate+0xa4>)
 801844a:	4922      	ldr	r1, [pc, #136]	; (80184d4 <rt_object_allocate+0xa8>)
 801844c:	f7ff fa36 	bl	80178bc <rt_kprintf>
 8018450:	4821      	ldr	r0, [pc, #132]	; (80184d8 <rt_object_allocate+0xac>)
 8018452:	4920      	ldr	r1, [pc, #128]	; (80184d4 <rt_object_allocate+0xa8>)
 8018454:	f44f 728c 	mov.w	r2, #280	; 0x118
 8018458:	f7ff faaa 	bl	80179b0 <rt_assert_handler>
 801845c:	6978      	ldr	r0, [r7, #20]
 801845e:	f7e7 feb7 	bl	80001d0 <rt_hw_interrupt_enable>
     */
    information = (rt_module_self() != RT_NULL && (type != RT_Object_Class_Module)) ?
                  &rt_module_self()->module_object[type] : &rt_object_container[type];
#else
    /* get object information */
    information = &rt_object_container[type];
 8018462:	79fb      	ldrb	r3, [r7, #7]
 8018464:	011b      	lsls	r3, r3, #4
 8018466:	4a1d      	ldr	r2, [pc, #116]	; (80184dc <rt_object_allocate+0xb0>)
 8018468:	4413      	add	r3, r2
 801846a:	613b      	str	r3, [r7, #16]
#endif

    object = (struct rt_object *)RT_KERNEL_MALLOC(information->object_size);
 801846c:	693b      	ldr	r3, [r7, #16]
 801846e:	68db      	ldr	r3, [r3, #12]
 8018470:	4618      	mov	r0, r3
 8018472:	f7ff fbd1 	bl	8017c18 <rt_malloc>
 8018476:	60f8      	str	r0, [r7, #12]
    if (object == RT_NULL)
 8018478:	68fb      	ldr	r3, [r7, #12]
 801847a:	2b00      	cmp	r3, #0
 801847c:	d101      	bne.n	8018482 <rt_object_allocate+0x56>
    {
        /* no memory can be allocated */
        return RT_NULL;
 801847e:	2300      	movs	r3, #0
 8018480:	e022      	b.n	80184c8 <rt_object_allocate+0x9c>
    }

    /* initialize object's parameters */

    /* set object type */
    object->type = type;
 8018482:	68fb      	ldr	r3, [r7, #12]
 8018484:	79fa      	ldrb	r2, [r7, #7]
 8018486:	721a      	strb	r2, [r3, #8]

    /* set object flag */
    object->flag = 0;
 8018488:	68fb      	ldr	r3, [r7, #12]
 801848a:	2200      	movs	r2, #0
 801848c:	725a      	strb	r2, [r3, #9]
    }
    object->module_id = (void *)rt_module_self();
#endif

    /* copy name */
    rt_strncpy(object->name, name, RT_NAME_MAX);
 801848e:	68fb      	ldr	r3, [r7, #12]
 8018490:	4618      	mov	r0, r3
 8018492:	6839      	ldr	r1, [r7, #0]
 8018494:	2208      	movs	r2, #8
 8018496:	f7fe fd61 	bl	8016f5c <rt_strncpy>

    RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
 801849a:	4b11      	ldr	r3, [pc, #68]	; (80184e0 <rt_object_allocate+0xb4>)
 801849c:	681b      	ldr	r3, [r3, #0]
 801849e:	2b00      	cmp	r3, #0
 80184a0:	d003      	beq.n	80184aa <rt_object_allocate+0x7e>
 80184a2:	4b0f      	ldr	r3, [pc, #60]	; (80184e0 <rt_object_allocate+0xb4>)
 80184a4:	681b      	ldr	r3, [r3, #0]
 80184a6:	68f8      	ldr	r0, [r7, #12]
 80184a8:	4798      	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
 80184aa:	f7e7 fe8d 	bl	80001c8 <rt_hw_interrupt_disable>
 80184ae:	4604      	mov	r4, r0

    /* insert object into information object list */
    rt_list_insert_after(&(information->object_list), &(object->list));
 80184b0:	693b      	ldr	r3, [r7, #16]
 80184b2:	1d1a      	adds	r2, r3, #4
 80184b4:	68fb      	ldr	r3, [r7, #12]
 80184b6:	330c      	adds	r3, #12
 80184b8:	4610      	mov	r0, r2
 80184ba:	4619      	mov	r1, r3
 80184bc:	f7ff ff20 	bl	8018300 <rt_list_insert_after>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
 80184c0:	4620      	mov	r0, r4
 80184c2:	f7e7 fe85 	bl	80001d0 <rt_hw_interrupt_enable>

    /* return object */
    return object;
 80184c6:	68fb      	ldr	r3, [r7, #12]
}
 80184c8:	4618      	mov	r0, r3
 80184ca:	371c      	adds	r7, #28
 80184cc:	46bd      	mov	sp, r7
 80184ce:	bd90      	pop	{r4, r7, pc}
 80184d0:	08027b0c 	.word	0x08027b0c
 80184d4:	080290fc 	.word	0x080290fc
 80184d8:	08027b30 	.word	0x08027b30
 80184dc:	2001001c 	.word	0x2001001c
 80184e0:	20010d98 	.word	0x20010d98

080184e4 <rt_object_delete>:
 * This function will delete an object and release object memory.
 *
 * @param object the specified object to be deleted.
 */
void rt_object_delete(rt_object_t object)
{
 80184e4:	b590      	push	{r4, r7, lr}
 80184e6:	b083      	sub	sp, #12
 80184e8:	af00      	add	r7, sp, #0
 80184ea:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;

    /* object check */
    RT_ASSERT(object != RT_NULL);
 80184ec:	687b      	ldr	r3, [r7, #4]
 80184ee:	2b00      	cmp	r3, #0
 80184f0:	d105      	bne.n	80184fe <rt_object_delete+0x1a>
 80184f2:	4815      	ldr	r0, [pc, #84]	; (8018548 <rt_object_delete+0x64>)
 80184f4:	4915      	ldr	r1, [pc, #84]	; (801854c <rt_object_delete+0x68>)
 80184f6:	f240 1259 	movw	r2, #345	; 0x159
 80184fa:	f7ff fa59 	bl	80179b0 <rt_assert_handler>
    RT_ASSERT(!(object->type & RT_Object_Class_Static));
 80184fe:	687b      	ldr	r3, [r7, #4]
 8018500:	7a1b      	ldrb	r3, [r3, #8]
 8018502:	b2db      	uxtb	r3, r3
 8018504:	b25b      	sxtb	r3, r3
 8018506:	2b00      	cmp	r3, #0
 8018508:	da05      	bge.n	8018516 <rt_object_delete+0x32>
 801850a:	4811      	ldr	r0, [pc, #68]	; (8018550 <rt_object_delete+0x6c>)
 801850c:	490f      	ldr	r1, [pc, #60]	; (801854c <rt_object_delete+0x68>)
 801850e:	f44f 72ad 	mov.w	r2, #346	; 0x15a
 8018512:	f7ff fa4d 	bl	80179b0 <rt_assert_handler>

    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
 8018516:	4b0f      	ldr	r3, [pc, #60]	; (8018554 <rt_object_delete+0x70>)
 8018518:	681b      	ldr	r3, [r3, #0]
 801851a:	2b00      	cmp	r3, #0
 801851c:	d003      	beq.n	8018526 <rt_object_delete+0x42>
 801851e:	4b0d      	ldr	r3, [pc, #52]	; (8018554 <rt_object_delete+0x70>)
 8018520:	681b      	ldr	r3, [r3, #0]
 8018522:	6878      	ldr	r0, [r7, #4]
 8018524:	4798      	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
 8018526:	f7e7 fe4f 	bl	80001c8 <rt_hw_interrupt_disable>
 801852a:	4604      	mov	r4, r0

    /* remove from old list */
    rt_list_remove(&(object->list));
 801852c:	687b      	ldr	r3, [r7, #4]
 801852e:	330c      	adds	r3, #12
 8018530:	4618      	mov	r0, r3
 8018532:	f7ff fefd 	bl	8018330 <rt_list_remove>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
 8018536:	4620      	mov	r0, r4
 8018538:	f7e7 fe4a 	bl	80001d0 <rt_hw_interrupt_enable>
        rt_module_free((rt_module_t)object->module_id, object);
    else
#endif

    /* free the memory of object */
    RT_KERNEL_FREE(object);
 801853c:	6878      	ldr	r0, [r7, #4]
 801853e:	f7ff fd75 	bl	801802c <rt_free>
}
 8018542:	370c      	adds	r7, #12
 8018544:	46bd      	mov	sp, r7
 8018546:	bd90      	pop	{r4, r7, pc}
 8018548:	08027af8 	.word	0x08027af8
 801854c:	08029110 	.word	0x08029110
 8018550:	08027b34 	.word	0x08027b34
 8018554:	20010d9c 	.word	0x20010d9c

08018558 <rt_object_is_systemobject>:
 * @param object the specified object to be judged.
 *
 * @return RT_TRUE if a system object, RT_FALSE for others.
 */
rt_bool_t rt_object_is_systemobject(rt_object_t object)
{
 8018558:	b580      	push	{r7, lr}
 801855a:	b082      	sub	sp, #8
 801855c:	af00      	add	r7, sp, #0
 801855e:	6078      	str	r0, [r7, #4]
    /* object check */
    RT_ASSERT(object != RT_NULL);
 8018560:	687b      	ldr	r3, [r7, #4]
 8018562:	2b00      	cmp	r3, #0
 8018564:	d105      	bne.n	8018572 <rt_object_is_systemobject+0x1a>
 8018566:	4809      	ldr	r0, [pc, #36]	; (801858c <rt_object_is_systemobject+0x34>)
 8018568:	4909      	ldr	r1, [pc, #36]	; (8018590 <rt_object_is_systemobject+0x38>)
 801856a:	f44f 72bf 	mov.w	r2, #382	; 0x17e
 801856e:	f7ff fa1f 	bl	80179b0 <rt_assert_handler>

    if (object->type & RT_Object_Class_Static)
 8018572:	687b      	ldr	r3, [r7, #4]
 8018574:	7a1b      	ldrb	r3, [r3, #8]
 8018576:	b2db      	uxtb	r3, r3
 8018578:	b25b      	sxtb	r3, r3
 801857a:	2b00      	cmp	r3, #0
 801857c:	da01      	bge.n	8018582 <rt_object_is_systemobject+0x2a>
        return RT_TRUE;
 801857e:	2301      	movs	r3, #1
 8018580:	e000      	b.n	8018584 <rt_object_is_systemobject+0x2c>

    return RT_FALSE;
 8018582:	2300      	movs	r3, #0
}
 8018584:	4618      	mov	r0, r3
 8018586:	3708      	adds	r7, #8
 8018588:	46bd      	mov	sp, r7
 801858a:	bd80      	pop	{r7, pc}
 801858c:	08027af8 	.word	0x08027af8
 8018590:	08029124 	.word	0x08029124

08018594 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 8018594:	b480      	push	{r7}
 8018596:	b083      	sub	sp, #12
 8018598:	af00      	add	r7, sp, #0
 801859a:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 801859c:	687b      	ldr	r3, [r7, #4]
 801859e:	687a      	ldr	r2, [r7, #4]
 80185a0:	605a      	str	r2, [r3, #4]
 80185a2:	687b      	ldr	r3, [r7, #4]
 80185a4:	685a      	ldr	r2, [r3, #4]
 80185a6:	687b      	ldr	r3, [r7, #4]
 80185a8:	601a      	str	r2, [r3, #0]
}
 80185aa:	370c      	adds	r7, #12
 80185ac:	46bd      	mov	sp, r7
 80185ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80185b2:	4770      	bx	lr

080185b4 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 80185b4:	b480      	push	{r7}
 80185b6:	b083      	sub	sp, #12
 80185b8:	af00      	add	r7, sp, #0
 80185ba:	6078      	str	r0, [r7, #4]
 80185bc:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 80185be:	687b      	ldr	r3, [r7, #4]
 80185c0:	685b      	ldr	r3, [r3, #4]
 80185c2:	683a      	ldr	r2, [r7, #0]
 80185c4:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 80185c6:	687b      	ldr	r3, [r7, #4]
 80185c8:	685a      	ldr	r2, [r3, #4]
 80185ca:	683b      	ldr	r3, [r7, #0]
 80185cc:	605a      	str	r2, [r3, #4]

    l->prev = n;
 80185ce:	687b      	ldr	r3, [r7, #4]
 80185d0:	683a      	ldr	r2, [r7, #0]
 80185d2:	605a      	str	r2, [r3, #4]
    n->next = l;
 80185d4:	683b      	ldr	r3, [r7, #0]
 80185d6:	687a      	ldr	r2, [r7, #4]
 80185d8:	601a      	str	r2, [r3, #0]
}
 80185da:	370c      	adds	r7, #12
 80185dc:	46bd      	mov	sp, r7
 80185de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80185e2:	4770      	bx	lr

080185e4 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 80185e4:	b480      	push	{r7}
 80185e6:	b083      	sub	sp, #12
 80185e8:	af00      	add	r7, sp, #0
 80185ea:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 80185ec:	687b      	ldr	r3, [r7, #4]
 80185ee:	681b      	ldr	r3, [r3, #0]
 80185f0:	687a      	ldr	r2, [r7, #4]
 80185f2:	6852      	ldr	r2, [r2, #4]
 80185f4:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 80185f6:	687b      	ldr	r3, [r7, #4]
 80185f8:	685b      	ldr	r3, [r3, #4]
 80185fa:	687a      	ldr	r2, [r7, #4]
 80185fc:	6812      	ldr	r2, [r2, #0]
 80185fe:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 8018600:	687b      	ldr	r3, [r7, #4]
 8018602:	687a      	ldr	r2, [r7, #4]
 8018604:	605a      	str	r2, [r3, #4]
 8018606:	687b      	ldr	r3, [r7, #4]
 8018608:	685a      	ldr	r2, [r3, #4]
 801860a:	687b      	ldr	r3, [r7, #4]
 801860c:	601a      	str	r2, [r3, #0]
}
 801860e:	370c      	adds	r7, #12
 8018610:	46bd      	mov	sp, r7
 8018612:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018616:	4770      	bx	lr

08018618 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 8018618:	b480      	push	{r7}
 801861a:	b083      	sub	sp, #12
 801861c:	af00      	add	r7, sp, #0
 801861e:	6078      	str	r0, [r7, #4]
    return l->next == l;
 8018620:	687b      	ldr	r3, [r7, #4]
 8018622:	681a      	ldr	r2, [r3, #0]
 8018624:	687b      	ldr	r3, [r7, #4]
 8018626:	429a      	cmp	r2, r3
 8018628:	bf0c      	ite	eq
 801862a:	2301      	moveq	r3, #1
 801862c:	2300      	movne	r3, #0
 801862e:	b2db      	uxtb	r3, r3
}
 8018630:	4618      	mov	r0, r3
 8018632:	370c      	adds	r7, #12
 8018634:	46bd      	mov	sp, r7
 8018636:	f85d 7b04 	ldr.w	r7, [sp], #4
 801863a:	4770      	bx	lr

0801863c <_rt_scheduler_stack_check>:
/*@}*/
#endif

#ifdef RT_USING_OVERFLOW_CHECK
static void _rt_scheduler_stack_check(struct rt_thread *thread)
{
 801863c:	b580      	push	{r7, lr}
 801863e:	b084      	sub	sp, #16
 8018640:	af00      	add	r7, sp, #0
 8018642:	6078      	str	r0, [r7, #4]
    RT_ASSERT(thread != RT_NULL);
 8018644:	687b      	ldr	r3, [r7, #4]
 8018646:	2b00      	cmp	r3, #0
 8018648:	d104      	bne.n	8018654 <_rt_scheduler_stack_check+0x18>
 801864a:	481b      	ldr	r0, [pc, #108]	; (80186b8 <_rt_scheduler_stack_check+0x7c>)
 801864c:	491b      	ldr	r1, [pc, #108]	; (80186bc <_rt_scheduler_stack_check+0x80>)
 801864e:	225a      	movs	r2, #90	; 0x5a
 8018650:	f7ff f9ae 	bl	80179b0 <rt_assert_handler>

    if ((rt_uint32_t)thread->sp <= (rt_uint32_t)thread->stack_addr ||
 8018654:	687b      	ldr	r3, [r7, #4]
 8018656:	69db      	ldr	r3, [r3, #28]
 8018658:	461a      	mov	r2, r3
 801865a:	687b      	ldr	r3, [r7, #4]
 801865c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801865e:	429a      	cmp	r2, r3
 8018660:	d90a      	bls.n	8018678 <_rt_scheduler_stack_check+0x3c>
        (rt_uint32_t)thread->sp >
 8018662:	687b      	ldr	r3, [r7, #4]
 8018664:	69db      	ldr	r3, [r3, #28]
 8018666:	461a      	mov	r2, r3
        (rt_uint32_t)thread->stack_addr + (rt_uint32_t)thread->stack_size)
 8018668:	687b      	ldr	r3, [r7, #4]
 801866a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801866c:	4619      	mov	r1, r3
 801866e:	687b      	ldr	r3, [r7, #4]
 8018670:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 8018672:	440b      	add	r3, r1
#ifdef RT_USING_OVERFLOW_CHECK
static void _rt_scheduler_stack_check(struct rt_thread *thread)
{
    RT_ASSERT(thread != RT_NULL);

    if ((rt_uint32_t)thread->sp <= (rt_uint32_t)thread->stack_addr ||
 8018674:	429a      	cmp	r2, r3
 8018676:	d90e      	bls.n	8018696 <_rt_scheduler_stack_check+0x5a>
        (rt_uint32_t)thread->sp >
        (rt_uint32_t)thread->stack_addr + (rt_uint32_t)thread->stack_size)
    {
        rt_uint32_t level;

        rt_kprintf("thread:%s stack overflow\n", thread->name);
 8018678:	687b      	ldr	r3, [r7, #4]
 801867a:	4811      	ldr	r0, [pc, #68]	; (80186c0 <_rt_scheduler_stack_check+0x84>)
 801867c:	4619      	mov	r1, r3
 801867e:	f7ff f91d 	bl	80178bc <rt_kprintf>
        #ifdef RT_USING_FINSH
        {
            extern long list_thread(void);
            list_thread();
 8018682:	f004 fc8b 	bl	801cf9c <list_thread>
        }
        #endif
        level = rt_hw_interrupt_disable();
 8018686:	f7e7 fd9f 	bl	80001c8 <rt_hw_interrupt_disable>
 801868a:	4603      	mov	r3, r0
 801868c:	60fb      	str	r3, [r7, #12]
        while (level);
 801868e:	68fb      	ldr	r3, [r7, #12]
 8018690:	2b00      	cmp	r3, #0
 8018692:	d1fc      	bne.n	801868e <_rt_scheduler_stack_check+0x52>
    RT_ASSERT(thread != RT_NULL);

    if ((rt_uint32_t)thread->sp <= (rt_uint32_t)thread->stack_addr ||
        (rt_uint32_t)thread->sp >
        (rt_uint32_t)thread->stack_addr + (rt_uint32_t)thread->stack_size)
    {
 8018694:	e00c      	b.n	80186b0 <_rt_scheduler_stack_check+0x74>
        }
        #endif
        level = rt_hw_interrupt_disable();
        while (level);
    }
    else if ((rt_uint32_t)thread->sp <= ((rt_uint32_t)thread->stack_addr + 32))
 8018696:	687b      	ldr	r3, [r7, #4]
 8018698:	69db      	ldr	r3, [r3, #28]
 801869a:	461a      	mov	r2, r3
 801869c:	687b      	ldr	r3, [r7, #4]
 801869e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80186a0:	3320      	adds	r3, #32
 80186a2:	429a      	cmp	r2, r3
 80186a4:	d804      	bhi.n	80186b0 <_rt_scheduler_stack_check+0x74>
    {
        rt_kprintf("warning: %s stack is close to end of stack address.\n",
                   thread->name);
 80186a6:	687b      	ldr	r3, [r7, #4]
        level = rt_hw_interrupt_disable();
        while (level);
    }
    else if ((rt_uint32_t)thread->sp <= ((rt_uint32_t)thread->stack_addr + 32))
    {
        rt_kprintf("warning: %s stack is close to end of stack address.\n",
 80186a8:	4806      	ldr	r0, [pc, #24]	; (80186c4 <_rt_scheduler_stack_check+0x88>)
 80186aa:	4619      	mov	r1, r3
 80186ac:	f7ff f906 	bl	80178bc <rt_kprintf>
                   thread->name);
    }
}
 80186b0:	3710      	adds	r7, #16
 80186b2:	46bd      	mov	sp, r7
 80186b4:	bd80      	pop	{r7, pc}
 80186b6:	bf00      	nop
 80186b8:	08027b60 	.word	0x08027b60
 80186bc:	08029140 	.word	0x08029140
 80186c0:	08027b74 	.word	0x08027b74
 80186c4:	08027b90 	.word	0x08027b90

080186c8 <rt_system_scheduler_init>:
/**
 * @ingroup SystemInit
 * This function will initialize the system scheduler
 */
void rt_system_scheduler_init(void)
{
 80186c8:	b598      	push	{r3, r4, r7, lr}
 80186ca:	af00      	add	r7, sp, #0
    register rt_base_t offset;

    rt_scheduler_lock_nest = 0;
 80186cc:	4b0d      	ldr	r3, [pc, #52]	; (8018704 <rt_system_scheduler_init+0x3c>)
 80186ce:	2200      	movs	r2, #0
 80186d0:	801a      	strh	r2, [r3, #0]

    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
                                      RT_THREAD_PRIORITY_MAX));

    for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
 80186d2:	2400      	movs	r4, #0
 80186d4:	e006      	b.n	80186e4 <rt_system_scheduler_init+0x1c>
    {
        rt_list_init(&rt_thread_priority_table[offset]);
 80186d6:	00e3      	lsls	r3, r4, #3
 80186d8:	4a0b      	ldr	r2, [pc, #44]	; (8018708 <rt_system_scheduler_init+0x40>)
 80186da:	4413      	add	r3, r2
 80186dc:	4618      	mov	r0, r3
 80186de:	f7ff ff59 	bl	8018594 <rt_list_init>
    rt_scheduler_lock_nest = 0;

    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
                                      RT_THREAD_PRIORITY_MAX));

    for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
 80186e2:	3401      	adds	r4, #1
 80186e4:	2c1f      	cmp	r4, #31
 80186e6:	ddf6      	ble.n	80186d6 <rt_system_scheduler_init+0xe>
    {
        rt_list_init(&rt_thread_priority_table[offset]);
    }

    rt_current_priority = RT_THREAD_PRIORITY_MAX - 1;
 80186e8:	4b08      	ldr	r3, [pc, #32]	; (801870c <rt_system_scheduler_init+0x44>)
 80186ea:	221f      	movs	r2, #31
 80186ec:	701a      	strb	r2, [r3, #0]
    rt_current_thread = RT_NULL;
 80186ee:	4b08      	ldr	r3, [pc, #32]	; (8018710 <rt_system_scheduler_init+0x48>)
 80186f0:	2200      	movs	r2, #0
 80186f2:	601a      	str	r2, [r3, #0]

    /* initialize ready priority group */
    rt_thread_ready_priority_group = 0;
 80186f4:	4b07      	ldr	r3, [pc, #28]	; (8018714 <rt_system_scheduler_init+0x4c>)
 80186f6:	2200      	movs	r2, #0
 80186f8:	601a      	str	r2, [r3, #0]
    /* initialize ready table */
    rt_memset(rt_thread_ready_table, 0, sizeof(rt_thread_ready_table));
#endif

    /* initialize thread defunct */
    rt_list_init(&rt_thread_defunct);
 80186fa:	4807      	ldr	r0, [pc, #28]	; (8018718 <rt_system_scheduler_init+0x50>)
 80186fc:	f7ff ff4a 	bl	8018594 <rt_list_init>
}
 8018700:	bd98      	pop	{r3, r4, r7, pc}
 8018702:	bf00      	nop
 8018704:	20010da0 	.word	0x20010da0
 8018708:	20012a4c 	.word	0x20012a4c
 801870c:	20012b4c 	.word	0x20012b4c
 8018710:	20012b50 	.word	0x20012b50
 8018714:	20012b54 	.word	0x20012b54
 8018718:	20012b58 	.word	0x20012b58

0801871c <rt_system_scheduler_start>:
 * @ingroup SystemInit
 * This function will startup scheduler. It will select one thread
 * with the highest priority level, then switch to it.
 */
void rt_system_scheduler_start(void)
{
 801871c:	b598      	push	{r3, r4, r7, lr}
 801871e:	af00      	add	r7, sp, #0
    register rt_ubase_t number;

    number = __rt_ffs(rt_thread_ready_priority_group) - 1;
    highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
#else
    highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
 8018720:	4b0a      	ldr	r3, [pc, #40]	; (801874c <rt_system_scheduler_start+0x30>)
 8018722:	681b      	ldr	r3, [r3, #0]
 8018724:	4618      	mov	r0, r3
 8018726:	f7ff f909 	bl	801793c <__rt_ffs>
 801872a:	4603      	mov	r3, r0
 801872c:	3b01      	subs	r3, #1
 801872e:	461c      	mov	r4, r3
#endif

    /* get switch to thread */
    to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
 8018730:	4b07      	ldr	r3, [pc, #28]	; (8018750 <rt_system_scheduler_start+0x34>)
 8018732:	f853 3034 	ldr.w	r3, [r3, r4, lsl #3]
 8018736:	f1a3 0414 	sub.w	r4, r3, #20
                              struct rt_thread,
                              tlist);

    rt_current_thread = to_thread;
 801873a:	4b06      	ldr	r3, [pc, #24]	; (8018754 <rt_system_scheduler_start+0x38>)
 801873c:	601c      	str	r4, [r3, #0]

    /* switch to new thread */
    rt_hw_context_switch_to((rt_uint32_t)&to_thread->sp);
 801873e:	f104 031c 	add.w	r3, r4, #28
 8018742:	4618      	mov	r0, r3
 8018744:	f7e7 fd8c 	bl	8000260 <rt_hw_context_switch_to>

    /* never come back */
}
 8018748:	bd98      	pop	{r3, r4, r7, pc}
 801874a:	bf00      	nop
 801874c:	20012b54 	.word	0x20012b54
 8018750:	20012a4c 	.word	0x20012a4c
 8018754:	20012b50 	.word	0x20012b50

08018758 <rt_schedule>:
/**
 * This function will perform one schedule. It will select one thread
 * with the highest priority level, then switch to it.
 */
void rt_schedule(void)
{
 8018758:	b590      	push	{r4, r7, lr}
 801875a:	b085      	sub	sp, #20
 801875c:	af00      	add	r7, sp, #0
    rt_base_t level;
    struct rt_thread *to_thread;
    struct rt_thread *from_thread;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 801875e:	f7e7 fd33 	bl	80001c8 <rt_hw_interrupt_disable>
 8018762:	60f8      	str	r0, [r7, #12]

    /* check the scheduler is enabled or not */
    if (rt_scheduler_lock_nest == 0)
 8018764:	4b24      	ldr	r3, [pc, #144]	; (80187f8 <rt_schedule+0xa0>)
 8018766:	881b      	ldrh	r3, [r3, #0]
 8018768:	2b00      	cmp	r3, #0
 801876a:	d13e      	bne.n	80187ea <rt_schedule+0x92>
    {
        register rt_ubase_t highest_ready_priority;

#if RT_THREAD_PRIORITY_MAX <= 32
        highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
 801876c:	4b23      	ldr	r3, [pc, #140]	; (80187fc <rt_schedule+0xa4>)
 801876e:	681b      	ldr	r3, [r3, #0]
 8018770:	4618      	mov	r0, r3
 8018772:	f7ff f8e3 	bl	801793c <__rt_ffs>
 8018776:	4603      	mov	r3, r0
 8018778:	3b01      	subs	r3, #1
 801877a:	461c      	mov	r4, r3
        number = __rt_ffs(rt_thread_ready_priority_group) - 1;
        highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
#endif

        /* get switch to thread */
        to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
 801877c:	4b20      	ldr	r3, [pc, #128]	; (8018800 <rt_schedule+0xa8>)
 801877e:	f853 3034 	ldr.w	r3, [r3, r4, lsl #3]
 8018782:	3b14      	subs	r3, #20
 8018784:	60bb      	str	r3, [r7, #8]
                                  struct rt_thread,
                                  tlist);

        /* if the destination thread is not the same as current thread */
        if (to_thread != rt_current_thread)
 8018786:	4b1f      	ldr	r3, [pc, #124]	; (8018804 <rt_schedule+0xac>)
 8018788:	681b      	ldr	r3, [r3, #0]
 801878a:	68ba      	ldr	r2, [r7, #8]
 801878c:	429a      	cmp	r2, r3
 801878e:	d02c      	beq.n	80187ea <rt_schedule+0x92>
        {
            rt_current_priority = (rt_uint8_t)highest_ready_priority;
 8018790:	b2e2      	uxtb	r2, r4
 8018792:	4b1d      	ldr	r3, [pc, #116]	; (8018808 <rt_schedule+0xb0>)
 8018794:	701a      	strb	r2, [r3, #0]
            from_thread         = rt_current_thread;
 8018796:	4b1b      	ldr	r3, [pc, #108]	; (8018804 <rt_schedule+0xac>)
 8018798:	681b      	ldr	r3, [r3, #0]
 801879a:	607b      	str	r3, [r7, #4]
            rt_current_thread   = to_thread;
 801879c:	4a19      	ldr	r2, [pc, #100]	; (8018804 <rt_schedule+0xac>)
 801879e:	68bb      	ldr	r3, [r7, #8]
 80187a0:	6013      	str	r3, [r2, #0]

            RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (from_thread, to_thread));
 80187a2:	4b1a      	ldr	r3, [pc, #104]	; (801880c <rt_schedule+0xb4>)
 80187a4:	681b      	ldr	r3, [r3, #0]
 80187a6:	2b00      	cmp	r3, #0
 80187a8:	d004      	beq.n	80187b4 <rt_schedule+0x5c>
 80187aa:	4b18      	ldr	r3, [pc, #96]	; (801880c <rt_schedule+0xb4>)
 80187ac:	681b      	ldr	r3, [r3, #0]
 80187ae:	6878      	ldr	r0, [r7, #4]
 80187b0:	68b9      	ldr	r1, [r7, #8]
 80187b2:	4798      	blx	r3
                          rt_interrupt_nest, highest_ready_priority,
                          RT_NAME_MAX, to_thread->name, to_thread->sp,
                          RT_NAME_MAX, from_thread->name, from_thread->sp));

#ifdef RT_USING_OVERFLOW_CHECK
            _rt_scheduler_stack_check(to_thread);
 80187b4:	68b8      	ldr	r0, [r7, #8]
 80187b6:	f7ff ff41 	bl	801863c <_rt_scheduler_stack_check>
#endif

            if (rt_interrupt_nest == 0)
 80187ba:	4b15      	ldr	r3, [pc, #84]	; (8018810 <rt_schedule+0xb8>)
 80187bc:	781b      	ldrb	r3, [r3, #0]
 80187be:	b2db      	uxtb	r3, r3
 80187c0:	2b00      	cmp	r3, #0
 80187c2:	d109      	bne.n	80187d8 <rt_schedule+0x80>
            {
                rt_hw_context_switch((rt_uint32_t)&from_thread->sp,
 80187c4:	687b      	ldr	r3, [r7, #4]
 80187c6:	331c      	adds	r3, #28
 80187c8:	461a      	mov	r2, r3
                                     (rt_uint32_t)&to_thread->sp);
 80187ca:	68bb      	ldr	r3, [r7, #8]
 80187cc:	331c      	adds	r3, #28
            _rt_scheduler_stack_check(to_thread);
#endif

            if (rt_interrupt_nest == 0)
            {
                rt_hw_context_switch((rt_uint32_t)&from_thread->sp,
 80187ce:	4610      	mov	r0, r2
 80187d0:	4619      	mov	r1, r3
 80187d2:	f7e7 fd00 	bl	80001d6 <rt_hw_context_switch>
 80187d6:	e008      	b.n	80187ea <rt_schedule+0x92>
            }
            else
            {
                RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("switch in interrupt\n"));

                rt_hw_context_switch_interrupt((rt_uint32_t)&from_thread->sp,
 80187d8:	687b      	ldr	r3, [r7, #4]
 80187da:	331c      	adds	r3, #28
 80187dc:	461a      	mov	r2, r3
                                               (rt_uint32_t)&to_thread->sp);
 80187de:	68bb      	ldr	r3, [r7, #8]
 80187e0:	331c      	adds	r3, #28
            }
            else
            {
                RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("switch in interrupt\n"));

                rt_hw_context_switch_interrupt((rt_uint32_t)&from_thread->sp,
 80187e2:	4610      	mov	r0, r2
 80187e4:	4619      	mov	r1, r3
 80187e6:	f7e7 fcf6 	bl	80001d6 <rt_hw_context_switch>
            }
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 80187ea:	68f8      	ldr	r0, [r7, #12]
 80187ec:	f7e7 fcf0 	bl	80001d0 <rt_hw_interrupt_enable>
}
 80187f0:	3714      	adds	r7, #20
 80187f2:	46bd      	mov	sp, r7
 80187f4:	bd90      	pop	{r4, r7, pc}
 80187f6:	bf00      	nop
 80187f8:	20010da0 	.word	0x20010da0
 80187fc:	20012b54 	.word	0x20012b54
 8018800:	20012a4c 	.word	0x20012a4c
 8018804:	20012b50 	.word	0x20012b50
 8018808:	20012b4c 	.word	0x20012b4c
 801880c:	20010da4 	.word	0x20010da4
 8018810:	20012a38 	.word	0x20012a38

08018814 <rt_schedule_insert_thread>:
 *
 * @param thread the thread to be inserted
 * @note Please do not invoke this function in user application.
 */
void rt_schedule_insert_thread(struct rt_thread *thread)
{
 8018814:	b590      	push	{r4, r7, lr}
 8018816:	b083      	sub	sp, #12
 8018818:	af00      	add	r7, sp, #0
 801881a:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;

    RT_ASSERT(thread != RT_NULL);
 801881c:	687b      	ldr	r3, [r7, #4]
 801881e:	2b00      	cmp	r3, #0
 8018820:	d105      	bne.n	801882e <rt_schedule_insert_thread+0x1a>
 8018822:	4813      	ldr	r0, [pc, #76]	; (8018870 <rt_schedule_insert_thread+0x5c>)
 8018824:	4913      	ldr	r1, [pc, #76]	; (8018874 <rt_schedule_insert_thread+0x60>)
 8018826:	f240 120f 	movw	r2, #271	; 0x10f
 801882a:	f7ff f8c1 	bl	80179b0 <rt_assert_handler>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 801882e:	f7e7 fccb 	bl	80001c8 <rt_hw_interrupt_disable>
 8018832:	4604      	mov	r4, r0

    /* change stat */
    thread->stat = RT_THREAD_READY;
 8018834:	687b      	ldr	r3, [r7, #4]
 8018836:	2201      	movs	r2, #1
 8018838:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* insert thread to ready list */
    rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
 801883c:	687b      	ldr	r3, [r7, #4]
 801883e:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8018842:	00db      	lsls	r3, r3, #3
 8018844:	4a0c      	ldr	r2, [pc, #48]	; (8018878 <rt_schedule_insert_thread+0x64>)
 8018846:	441a      	add	r2, r3
 8018848:	687b      	ldr	r3, [r7, #4]
 801884a:	3314      	adds	r3, #20
 801884c:	4610      	mov	r0, r2
 801884e:	4619      	mov	r1, r3
 8018850:	f7ff feb0 	bl	80185b4 <rt_list_insert_before>
#endif

#if RT_THREAD_PRIORITY_MAX > 32
    rt_thread_ready_table[thread->number] |= thread->high_mask;
#endif
    rt_thread_ready_priority_group |= thread->number_mask;
 8018854:	687b      	ldr	r3, [r7, #4]
 8018856:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8018858:	4b08      	ldr	r3, [pc, #32]	; (801887c <rt_schedule_insert_thread+0x68>)
 801885a:	681b      	ldr	r3, [r3, #0]
 801885c:	4313      	orrs	r3, r2
 801885e:	4a07      	ldr	r2, [pc, #28]	; (801887c <rt_schedule_insert_thread+0x68>)
 8018860:	6013      	str	r3, [r2, #0]

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8018862:	4620      	mov	r0, r4
 8018864:	f7e7 fcb4 	bl	80001d0 <rt_hw_interrupt_enable>
}
 8018868:	370c      	adds	r7, #12
 801886a:	46bd      	mov	sp, r7
 801886c:	bd90      	pop	{r4, r7, pc}
 801886e:	bf00      	nop
 8018870:	08027b60 	.word	0x08027b60
 8018874:	0802915c 	.word	0x0802915c
 8018878:	20012a4c 	.word	0x20012a4c
 801887c:	20012b54 	.word	0x20012b54

08018880 <rt_schedule_remove_thread>:
 * @param thread the thread to be removed
 *
 * @note Please do not invoke this function in user application.
 */
void rt_schedule_remove_thread(struct rt_thread *thread)
{
 8018880:	b590      	push	{r4, r7, lr}
 8018882:	b083      	sub	sp, #12
 8018884:	af00      	add	r7, sp, #0
 8018886:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;

    RT_ASSERT(thread != RT_NULL);
 8018888:	687b      	ldr	r3, [r7, #4]
 801888a:	2b00      	cmp	r3, #0
 801888c:	d105      	bne.n	801889a <rt_schedule_remove_thread+0x1a>
 801888e:	4814      	ldr	r0, [pc, #80]	; (80188e0 <rt_schedule_remove_thread+0x60>)
 8018890:	4914      	ldr	r1, [pc, #80]	; (80188e4 <rt_schedule_remove_thread+0x64>)
 8018892:	f240 123d 	movw	r2, #317	; 0x13d
 8018896:	f7ff f88b 	bl	80179b0 <rt_assert_handler>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 801889a:	f7e7 fc95 	bl	80001c8 <rt_hw_interrupt_disable>
 801889e:	4604      	mov	r4, r0
                  thread->number_mask,
                  thread->high_mask));
#endif

    /* remove thread from ready list */
    rt_list_remove(&(thread->tlist));
 80188a0:	687b      	ldr	r3, [r7, #4]
 80188a2:	3314      	adds	r3, #20
 80188a4:	4618      	mov	r0, r3
 80188a6:	f7ff fe9d 	bl	80185e4 <rt_list_remove>
    if (rt_list_isempty(&(rt_thread_priority_table[thread->current_priority])))
 80188aa:	687b      	ldr	r3, [r7, #4]
 80188ac:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 80188b0:	00db      	lsls	r3, r3, #3
 80188b2:	4a0d      	ldr	r2, [pc, #52]	; (80188e8 <rt_schedule_remove_thread+0x68>)
 80188b4:	4413      	add	r3, r2
 80188b6:	4618      	mov	r0, r3
 80188b8:	f7ff feae 	bl	8018618 <rt_list_isempty>
 80188bc:	4603      	mov	r3, r0
 80188be:	2b00      	cmp	r3, #0
 80188c0:	d007      	beq.n	80188d2 <rt_schedule_remove_thread+0x52>
        if (rt_thread_ready_table[thread->number] == 0)
        {
            rt_thread_ready_priority_group &= ~thread->number_mask;
        }
#else
        rt_thread_ready_priority_group &= ~thread->number_mask;
 80188c2:	687b      	ldr	r3, [r7, #4]
 80188c4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80188c6:	43da      	mvns	r2, r3
 80188c8:	4b08      	ldr	r3, [pc, #32]	; (80188ec <rt_schedule_remove_thread+0x6c>)
 80188ca:	681b      	ldr	r3, [r3, #0]
 80188cc:	4013      	ands	r3, r2
 80188ce:	4a07      	ldr	r2, [pc, #28]	; (80188ec <rt_schedule_remove_thread+0x6c>)
 80188d0:	6013      	str	r3, [r2, #0]
#endif
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 80188d2:	4620      	mov	r0, r4
 80188d4:	f7e7 fc7c 	bl	80001d0 <rt_hw_interrupt_enable>
}
 80188d8:	370c      	adds	r7, #12
 80188da:	46bd      	mov	sp, r7
 80188dc:	bd90      	pop	{r4, r7, pc}
 80188de:	bf00      	nop
 80188e0:	08027b60 	.word	0x08027b60
 80188e4:	08029178 	.word	0x08029178
 80188e8:	20012a4c 	.word	0x20012a4c
 80188ec:	20012b54 	.word	0x20012b54

080188f0 <rt_enter_critical>:

/**
 * This function will lock the thread scheduler.
 */
void rt_enter_critical(void)
{
 80188f0:	b598      	push	{r3, r4, r7, lr}
 80188f2:	af00      	add	r7, sp, #0
    register rt_base_t level;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 80188f4:	f7e7 fc68 	bl	80001c8 <rt_hw_interrupt_disable>
 80188f8:	4604      	mov	r4, r0

    /*
     * the maximal number of nest is RT_UINT16_MAX, which is big
     * enough and does not check here
     */
    rt_scheduler_lock_nest ++;
 80188fa:	4b06      	ldr	r3, [pc, #24]	; (8018914 <rt_enter_critical+0x24>)
 80188fc:	881b      	ldrh	r3, [r3, #0]
 80188fe:	b29b      	uxth	r3, r3
 8018900:	b29b      	uxth	r3, r3
 8018902:	3301      	adds	r3, #1
 8018904:	b29b      	uxth	r3, r3
 8018906:	b29a      	uxth	r2, r3
 8018908:	4b02      	ldr	r3, [pc, #8]	; (8018914 <rt_enter_critical+0x24>)
 801890a:	801a      	strh	r2, [r3, #0]

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 801890c:	4620      	mov	r0, r4
 801890e:	f7e7 fc5f 	bl	80001d0 <rt_hw_interrupt_enable>
}
 8018912:	bd98      	pop	{r3, r4, r7, pc}
 8018914:	20010da0 	.word	0x20010da0

08018918 <rt_exit_critical>:

/**
 * This function will unlock the thread scheduler.
 */
void rt_exit_critical(void)
{
 8018918:	b598      	push	{r3, r4, r7, lr}
 801891a:	af00      	add	r7, sp, #0
    register rt_base_t level;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 801891c:	f7e7 fc54 	bl	80001c8 <rt_hw_interrupt_disable>
 8018920:	4604      	mov	r4, r0

    rt_scheduler_lock_nest --;
 8018922:	4b0d      	ldr	r3, [pc, #52]	; (8018958 <rt_exit_critical+0x40>)
 8018924:	881b      	ldrh	r3, [r3, #0]
 8018926:	b29b      	uxth	r3, r3
 8018928:	b29b      	uxth	r3, r3
 801892a:	3b01      	subs	r3, #1
 801892c:	b29b      	uxth	r3, r3
 801892e:	b29a      	uxth	r2, r3
 8018930:	4b09      	ldr	r3, [pc, #36]	; (8018958 <rt_exit_critical+0x40>)
 8018932:	801a      	strh	r2, [r3, #0]

    if (rt_scheduler_lock_nest <= 0)
 8018934:	4b08      	ldr	r3, [pc, #32]	; (8018958 <rt_exit_critical+0x40>)
 8018936:	881b      	ldrh	r3, [r3, #0]
 8018938:	b21b      	sxth	r3, r3
 801893a:	2b00      	cmp	r3, #0
 801893c:	dc08      	bgt.n	8018950 <rt_exit_critical+0x38>
    {
        rt_scheduler_lock_nest = 0;
 801893e:	4b06      	ldr	r3, [pc, #24]	; (8018958 <rt_exit_critical+0x40>)
 8018940:	2200      	movs	r2, #0
 8018942:	801a      	strh	r2, [r3, #0]
        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 8018944:	4620      	mov	r0, r4
 8018946:	f7e7 fc43 	bl	80001d0 <rt_hw_interrupt_enable>

        rt_schedule();
 801894a:	f7ff ff05 	bl	8018758 <rt_schedule>
 801894e:	e002      	b.n	8018956 <rt_exit_critical+0x3e>
    }
    else
    {
        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 8018950:	4620      	mov	r0, r4
 8018952:	f7e7 fc3d 	bl	80001d0 <rt_hw_interrupt_enable>
    }
}
 8018956:	bd98      	pop	{r3, r4, r7, pc}
 8018958:	20010da0 	.word	0x20010da0

0801895c <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 801895c:	b480      	push	{r7}
 801895e:	b083      	sub	sp, #12
 8018960:	af00      	add	r7, sp, #0
 8018962:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 8018964:	687b      	ldr	r3, [r7, #4]
 8018966:	687a      	ldr	r2, [r7, #4]
 8018968:	605a      	str	r2, [r3, #4]
 801896a:	687b      	ldr	r3, [r7, #4]
 801896c:	685a      	ldr	r2, [r3, #4]
 801896e:	687b      	ldr	r3, [r7, #4]
 8018970:	601a      	str	r2, [r3, #0]
}
 8018972:	370c      	adds	r7, #12
 8018974:	46bd      	mov	sp, r7
 8018976:	f85d 7b04 	ldr.w	r7, [sp], #4
 801897a:	4770      	bx	lr

0801897c <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
 801897c:	b480      	push	{r7}
 801897e:	b083      	sub	sp, #12
 8018980:	af00      	add	r7, sp, #0
 8018982:	6078      	str	r0, [r7, #4]
 8018984:	6039      	str	r1, [r7, #0]
    l->next->prev = n;
 8018986:	687b      	ldr	r3, [r7, #4]
 8018988:	681b      	ldr	r3, [r3, #0]
 801898a:	683a      	ldr	r2, [r7, #0]
 801898c:	605a      	str	r2, [r3, #4]
    n->next = l->next;
 801898e:	687b      	ldr	r3, [r7, #4]
 8018990:	681a      	ldr	r2, [r3, #0]
 8018992:	683b      	ldr	r3, [r7, #0]
 8018994:	601a      	str	r2, [r3, #0]

    l->next = n;
 8018996:	687b      	ldr	r3, [r7, #4]
 8018998:	683a      	ldr	r2, [r7, #0]
 801899a:	601a      	str	r2, [r3, #0]
    n->prev = l;
 801899c:	683b      	ldr	r3, [r7, #0]
 801899e:	687a      	ldr	r2, [r7, #4]
 80189a0:	605a      	str	r2, [r3, #4]
}
 80189a2:	370c      	adds	r7, #12
 80189a4:	46bd      	mov	sp, r7
 80189a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80189aa:	4770      	bx	lr

080189ac <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 80189ac:	b480      	push	{r7}
 80189ae:	b083      	sub	sp, #12
 80189b0:	af00      	add	r7, sp, #0
 80189b2:	6078      	str	r0, [r7, #4]
 80189b4:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 80189b6:	687b      	ldr	r3, [r7, #4]
 80189b8:	685b      	ldr	r3, [r3, #4]
 80189ba:	683a      	ldr	r2, [r7, #0]
 80189bc:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 80189be:	687b      	ldr	r3, [r7, #4]
 80189c0:	685a      	ldr	r2, [r3, #4]
 80189c2:	683b      	ldr	r3, [r7, #0]
 80189c4:	605a      	str	r2, [r3, #4]

    l->prev = n;
 80189c6:	687b      	ldr	r3, [r7, #4]
 80189c8:	683a      	ldr	r2, [r7, #0]
 80189ca:	605a      	str	r2, [r3, #4]
    n->next = l;
 80189cc:	683b      	ldr	r3, [r7, #0]
 80189ce:	687a      	ldr	r2, [r7, #4]
 80189d0:	601a      	str	r2, [r3, #0]
}
 80189d2:	370c      	adds	r7, #12
 80189d4:	46bd      	mov	sp, r7
 80189d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80189da:	4770      	bx	lr

080189dc <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 80189dc:	b480      	push	{r7}
 80189de:	b083      	sub	sp, #12
 80189e0:	af00      	add	r7, sp, #0
 80189e2:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 80189e4:	687b      	ldr	r3, [r7, #4]
 80189e6:	681b      	ldr	r3, [r3, #0]
 80189e8:	687a      	ldr	r2, [r7, #4]
 80189ea:	6852      	ldr	r2, [r2, #4]
 80189ec:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 80189ee:	687b      	ldr	r3, [r7, #4]
 80189f0:	685b      	ldr	r3, [r3, #4]
 80189f2:	687a      	ldr	r2, [r7, #4]
 80189f4:	6812      	ldr	r2, [r2, #0]
 80189f6:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 80189f8:	687b      	ldr	r3, [r7, #4]
 80189fa:	687a      	ldr	r2, [r7, #4]
 80189fc:	605a      	str	r2, [r3, #4]
 80189fe:	687b      	ldr	r3, [r7, #4]
 8018a00:	685a      	ldr	r2, [r3, #4]
 8018a02:	687b      	ldr	r3, [r7, #4]
 8018a04:	601a      	str	r2, [r3, #0]
}
 8018a06:	370c      	adds	r7, #12
 8018a08:	46bd      	mov	sp, r7
 8018a0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018a0e:	4770      	bx	lr

08018a10 <rt_thread_exit>:
extern rt_list_t rt_thread_priority_table[RT_THREAD_PRIORITY_MAX];
extern struct rt_thread *rt_current_thread;
extern rt_list_t rt_thread_defunct;

static void rt_thread_exit(void)
{
 8018a10:	b590      	push	{r4, r7, lr}
 8018a12:	b083      	sub	sp, #12
 8018a14:	af00      	add	r7, sp, #0
    struct rt_thread *thread;
    register rt_base_t level;

    /* get current thread */
    thread = rt_current_thread;
 8018a16:	4b17      	ldr	r3, [pc, #92]	; (8018a74 <rt_thread_exit+0x64>)
 8018a18:	681b      	ldr	r3, [r3, #0]
 8018a1a:	607b      	str	r3, [r7, #4]

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 8018a1c:	f7e7 fbd4 	bl	80001c8 <rt_hw_interrupt_disable>
 8018a20:	4604      	mov	r4, r0

    /* remove from schedule */
    rt_schedule_remove_thread(thread);
 8018a22:	6878      	ldr	r0, [r7, #4]
 8018a24:	f7ff ff2c 	bl	8018880 <rt_schedule_remove_thread>
    /* change stat */
    thread->stat = RT_THREAD_CLOSE;
 8018a28:	687b      	ldr	r3, [r7, #4]
 8018a2a:	2204      	movs	r2, #4
 8018a2c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* remove it from timer list */
    rt_timer_detach(&thread->thread_timer);
 8018a30:	687b      	ldr	r3, [r7, #4]
 8018a32:	334c      	adds	r3, #76	; 0x4c
 8018a34:	4618      	mov	r0, r3
 8018a36:	f000 fbc3 	bl	80191c0 <rt_timer_detach>

    if ((rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE) &&
 8018a3a:	6878      	ldr	r0, [r7, #4]
 8018a3c:	f7ff fd8c 	bl	8018558 <rt_object_is_systemobject>
 8018a40:	4603      	mov	r3, r0
 8018a42:	2b01      	cmp	r3, #1
 8018a44:	d107      	bne.n	8018a56 <rt_thread_exit+0x46>
        thread->cleanup == RT_NULL)
 8018a46:	687b      	ldr	r3, [r7, #4]
 8018a48:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    thread->stat = RT_THREAD_CLOSE;

    /* remove it from timer list */
    rt_timer_detach(&thread->thread_timer);

    if ((rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE) &&
 8018a4a:	2b00      	cmp	r3, #0
 8018a4c:	d103      	bne.n	8018a56 <rt_thread_exit+0x46>
        thread->cleanup == RT_NULL)
    {
        rt_object_detach((rt_object_t)thread);
 8018a4e:	6878      	ldr	r0, [r7, #4]
 8018a50:	f7ff fcc4 	bl	80183dc <rt_object_detach>
 8018a54:	e005      	b.n	8018a62 <rt_thread_exit+0x52>
    }
    else
    {
        /* insert to defunct thread list */
        rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
 8018a56:	687b      	ldr	r3, [r7, #4]
 8018a58:	3314      	adds	r3, #20
 8018a5a:	4807      	ldr	r0, [pc, #28]	; (8018a78 <rt_thread_exit+0x68>)
 8018a5c:	4619      	mov	r1, r3
 8018a5e:	f7ff ff8d 	bl	801897c <rt_list_insert_after>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 8018a62:	4620      	mov	r0, r4
 8018a64:	f7e7 fbb4 	bl	80001d0 <rt_hw_interrupt_enable>

    /* switch to next task */
    rt_schedule();
 8018a68:	f7ff fe76 	bl	8018758 <rt_schedule>
}
 8018a6c:	370c      	adds	r7, #12
 8018a6e:	46bd      	mov	sp, r7
 8018a70:	bd90      	pop	{r4, r7, pc}
 8018a72:	bf00      	nop
 8018a74:	20012b50 	.word	0x20012b50
 8018a78:	20012b58 	.word	0x20012b58

08018a7c <_rt_thread_init>:
                                void             *parameter,
                                void             *stack_start,
                                rt_uint32_t       stack_size,
                                rt_uint8_t        priority,
                                rt_uint32_t       tick)
{
 8018a7c:	b580      	push	{r7, lr}
 8018a7e:	b086      	sub	sp, #24
 8018a80:	af02      	add	r7, sp, #8
 8018a82:	60f8      	str	r0, [r7, #12]
 8018a84:	60b9      	str	r1, [r7, #8]
 8018a86:	607a      	str	r2, [r7, #4]
 8018a88:	603b      	str	r3, [r7, #0]
    /* init thread list */
    rt_list_init(&(thread->tlist));
 8018a8a:	68fb      	ldr	r3, [r7, #12]
 8018a8c:	3314      	adds	r3, #20
 8018a8e:	4618      	mov	r0, r3
 8018a90:	f7ff ff64 	bl	801895c <rt_list_init>

    thread->entry = (void *)entry;
 8018a94:	68fb      	ldr	r3, [r7, #12]
 8018a96:	687a      	ldr	r2, [r7, #4]
 8018a98:	621a      	str	r2, [r3, #32]
    thread->parameter = parameter;
 8018a9a:	68fb      	ldr	r3, [r7, #12]
 8018a9c:	683a      	ldr	r2, [r7, #0]
 8018a9e:	625a      	str	r2, [r3, #36]	; 0x24

    /* stack init */
    thread->stack_addr = stack_start;
 8018aa0:	68fb      	ldr	r3, [r7, #12]
 8018aa2:	69ba      	ldr	r2, [r7, #24]
 8018aa4:	629a      	str	r2, [r3, #40]	; 0x28
    thread->stack_size = (rt_uint16_t)stack_size;
 8018aa6:	69fb      	ldr	r3, [r7, #28]
 8018aa8:	b29a      	uxth	r2, r3
 8018aaa:	68fb      	ldr	r3, [r7, #12]
 8018aac:	859a      	strh	r2, [r3, #44]	; 0x2c

    /* init thread stack */
    rt_memset(thread->stack_addr, '#', thread->stack_size);
 8018aae:	68fb      	ldr	r3, [r7, #12]
 8018ab0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8018ab2:	68fb      	ldr	r3, [r7, #12]
 8018ab4:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 8018ab6:	4610      	mov	r0, r2
 8018ab8:	2123      	movs	r1, #35	; 0x23
 8018aba:	461a      	mov	r2, r3
 8018abc:	f7fe f946 	bl	8016d4c <rt_memset>
    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
 8018ac0:	68fb      	ldr	r3, [r7, #12]
 8018ac2:	6a18      	ldr	r0, [r3, #32]
 8018ac4:	68fb      	ldr	r3, [r7, #12]
 8018ac6:	6a59      	ldr	r1, [r3, #36]	; 0x24
        (void *)((char *)thread->stack_addr + thread->stack_size - 4),
 8018ac8:	68fb      	ldr	r3, [r7, #12]
 8018aca:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8018acc:	68fb      	ldr	r3, [r7, #12]
 8018ace:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 8018ad0:	3b04      	subs	r3, #4
 8018ad2:	4413      	add	r3, r2
    thread->stack_addr = stack_start;
    thread->stack_size = (rt_uint16_t)stack_size;

    /* init thread stack */
    rt_memset(thread->stack_addr, '#', thread->stack_size);
    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
 8018ad4:	461a      	mov	r2, r3
 8018ad6:	4b1f      	ldr	r3, [pc, #124]	; (8018b54 <_rt_thread_init+0xd8>)
 8018ad8:	f000 fe6e 	bl	80197b8 <rt_hw_stack_init>
 8018adc:	4602      	mov	r2, r0
 8018ade:	68fb      	ldr	r3, [r7, #12]
 8018ae0:	61da      	str	r2, [r3, #28]
        (void *)((char *)thread->stack_addr + thread->stack_size - 4),
        (void *)rt_thread_exit);

    /* priority init */
    RT_ASSERT(priority < RT_THREAD_PRIORITY_MAX);
 8018ae2:	f897 3020 	ldrb.w	r3, [r7, #32]
 8018ae6:	2b1f      	cmp	r3, #31
 8018ae8:	d904      	bls.n	8018af4 <_rt_thread_init+0x78>
 8018aea:	481b      	ldr	r0, [pc, #108]	; (8018b58 <_rt_thread_init+0xdc>)
 8018aec:	491b      	ldr	r1, [pc, #108]	; (8018b5c <_rt_thread_init+0xe0>)
 8018aee:	226e      	movs	r2, #110	; 0x6e
 8018af0:	f7fe ff5e 	bl	80179b0 <rt_assert_handler>
    thread->init_priority    = priority;
 8018af4:	68fb      	ldr	r3, [r7, #12]
 8018af6:	f897 2020 	ldrb.w	r2, [r7, #32]
 8018afa:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
    thread->current_priority = priority;
 8018afe:	68fb      	ldr	r3, [r7, #12]
 8018b00:	f897 2020 	ldrb.w	r2, [r7, #32]
 8018b04:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* tick init */
    thread->init_tick      = tick;
 8018b08:	68fb      	ldr	r3, [r7, #12]
 8018b0a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8018b0c:	645a      	str	r2, [r3, #68]	; 0x44
    thread->remaining_tick = tick;
 8018b0e:	68fb      	ldr	r3, [r7, #12]
 8018b10:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8018b12:	649a      	str	r2, [r3, #72]	; 0x48

    /* error and flags */
    thread->error = RT_EOK;
 8018b14:	68fb      	ldr	r3, [r7, #12]
 8018b16:	2200      	movs	r2, #0
 8018b18:	631a      	str	r2, [r3, #48]	; 0x30
    thread->stat  = RT_THREAD_INIT;
 8018b1a:	68fb      	ldr	r3, [r7, #12]
 8018b1c:	2200      	movs	r2, #0
 8018b1e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* initialize cleanup function and user data */
    thread->cleanup   = 0;
 8018b22:	68fb      	ldr	r3, [r7, #12]
 8018b24:	2200      	movs	r2, #0
 8018b26:	679a      	str	r2, [r3, #120]	; 0x78
    thread->user_data = 0;
 8018b28:	68fb      	ldr	r3, [r7, #12]
 8018b2a:	2200      	movs	r2, #0
 8018b2c:	67da      	str	r2, [r3, #124]	; 0x7c

    /* init thread timer */
    rt_timer_init(&(thread->thread_timer),
 8018b2e:	68fb      	ldr	r3, [r7, #12]
 8018b30:	f103 014c 	add.w	r1, r3, #76	; 0x4c
                  thread->name,
 8018b34:	68fa      	ldr	r2, [r7, #12]
    /* initialize cleanup function and user data */
    thread->cleanup   = 0;
    thread->user_data = 0;

    /* init thread timer */
    rt_timer_init(&(thread->thread_timer),
 8018b36:	2300      	movs	r3, #0
 8018b38:	9300      	str	r3, [sp, #0]
 8018b3a:	2300      	movs	r3, #0
 8018b3c:	9301      	str	r3, [sp, #4]
 8018b3e:	4608      	mov	r0, r1
 8018b40:	4611      	mov	r1, r2
 8018b42:	4a07      	ldr	r2, [pc, #28]	; (8018b60 <_rt_thread_init+0xe4>)
 8018b44:	68fb      	ldr	r3, [r7, #12]
 8018b46:	f000 fb17 	bl	8019178 <rt_timer_init>
                  rt_thread_timeout,
                  thread,
                  0,
                  RT_TIMER_FLAG_ONE_SHOT);

    return RT_EOK;
 8018b4a:	2300      	movs	r3, #0
}
 8018b4c:	4618      	mov	r0, r3
 8018b4e:	3710      	adds	r7, #16
 8018b50:	46bd      	mov	sp, r7
 8018b52:	bd80      	pop	{r7, pc}
 8018b54:	08018a11 	.word	0x08018a11
 8018b58:	08027bc8 	.word	0x08027bc8
 8018b5c:	08029194 	.word	0x08029194
 8018b60:	08018fa1 	.word	0x08018fa1

08018b64 <rt_thread_init>:
                        void             *parameter,
                        void             *stack_start,
                        rt_uint32_t       stack_size,
                        rt_uint8_t        priority,
                        rt_uint32_t       tick)
{
 8018b64:	b580      	push	{r7, lr}
 8018b66:	b088      	sub	sp, #32
 8018b68:	af04      	add	r7, sp, #16
 8018b6a:	60f8      	str	r0, [r7, #12]
 8018b6c:	60b9      	str	r1, [r7, #8]
 8018b6e:	607a      	str	r2, [r7, #4]
 8018b70:	603b      	str	r3, [r7, #0]
    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 8018b72:	68fb      	ldr	r3, [r7, #12]
 8018b74:	2b00      	cmp	r3, #0
 8018b76:	d104      	bne.n	8018b82 <rt_thread_init+0x1e>
 8018b78:	4812      	ldr	r0, [pc, #72]	; (8018bc4 <rt_thread_init+0x60>)
 8018b7a:	4913      	ldr	r1, [pc, #76]	; (8018bc8 <rt_thread_init+0x64>)
 8018b7c:	22a8      	movs	r2, #168	; 0xa8
 8018b7e:	f7fe ff17 	bl	80179b0 <rt_assert_handler>
    RT_ASSERT(stack_start != RT_NULL);
 8018b82:	69bb      	ldr	r3, [r7, #24]
 8018b84:	2b00      	cmp	r3, #0
 8018b86:	d104      	bne.n	8018b92 <rt_thread_init+0x2e>
 8018b88:	4810      	ldr	r0, [pc, #64]	; (8018bcc <rt_thread_init+0x68>)
 8018b8a:	490f      	ldr	r1, [pc, #60]	; (8018bc8 <rt_thread_init+0x64>)
 8018b8c:	22a9      	movs	r2, #169	; 0xa9
 8018b8e:	f7fe ff0f 	bl	80179b0 <rt_assert_handler>

    /* init thread object */
    rt_object_init((rt_object_t)thread, RT_Object_Class_Thread, name);
 8018b92:	68f8      	ldr	r0, [r7, #12]
 8018b94:	2100      	movs	r1, #0
 8018b96:	68ba      	ldr	r2, [r7, #8]
 8018b98:	f7ff fbea 	bl	8018370 <rt_object_init>

    return _rt_thread_init(thread,
 8018b9c:	69bb      	ldr	r3, [r7, #24]
 8018b9e:	9300      	str	r3, [sp, #0]
 8018ba0:	69fb      	ldr	r3, [r7, #28]
 8018ba2:	9301      	str	r3, [sp, #4]
 8018ba4:	f897 3020 	ldrb.w	r3, [r7, #32]
 8018ba8:	9302      	str	r3, [sp, #8]
 8018baa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018bac:	9303      	str	r3, [sp, #12]
 8018bae:	68f8      	ldr	r0, [r7, #12]
 8018bb0:	68b9      	ldr	r1, [r7, #8]
 8018bb2:	687a      	ldr	r2, [r7, #4]
 8018bb4:	683b      	ldr	r3, [r7, #0]
 8018bb6:	f7ff ff61 	bl	8018a7c <_rt_thread_init>
 8018bba:	4603      	mov	r3, r0
                           parameter,
                           stack_start,
                           stack_size,
                           priority,
                           tick);
}
 8018bbc:	4618      	mov	r0, r3
 8018bbe:	3710      	adds	r7, #16
 8018bc0:	46bd      	mov	sp, r7
 8018bc2:	bd80      	pop	{r7, pc}
 8018bc4:	08027bec 	.word	0x08027bec
 8018bc8:	080291a4 	.word	0x080291a4
 8018bcc:	08027c00 	.word	0x08027c00

08018bd0 <rt_thread_self>:
 * This function will return self thread object
 *
 * @return the self thread object
 */
rt_thread_t rt_thread_self(void)
{
 8018bd0:	b480      	push	{r7}
 8018bd2:	af00      	add	r7, sp, #0
    return rt_current_thread;
 8018bd4:	4b03      	ldr	r3, [pc, #12]	; (8018be4 <rt_thread_self+0x14>)
 8018bd6:	681b      	ldr	r3, [r3, #0]
}
 8018bd8:	4618      	mov	r0, r3
 8018bda:	46bd      	mov	sp, r7
 8018bdc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018be0:	4770      	bx	lr
 8018be2:	bf00      	nop
 8018be4:	20012b50 	.word	0x20012b50

08018be8 <rt_thread_startup>:
 * @param thread the thread to be started
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_startup(rt_thread_t thread)
{
 8018be8:	b580      	push	{r7, lr}
 8018bea:	b082      	sub	sp, #8
 8018bec:	af00      	add	r7, sp, #0
 8018bee:	6078      	str	r0, [r7, #4]
    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 8018bf0:	687b      	ldr	r3, [r7, #4]
 8018bf2:	2b00      	cmp	r3, #0
 8018bf4:	d104      	bne.n	8018c00 <rt_thread_startup+0x18>
 8018bf6:	4818      	ldr	r0, [pc, #96]	; (8018c58 <rt_thread_startup+0x70>)
 8018bf8:	4918      	ldr	r1, [pc, #96]	; (8018c5c <rt_thread_startup+0x74>)
 8018bfa:	22ce      	movs	r2, #206	; 0xce
 8018bfc:	f7fe fed8 	bl	80179b0 <rt_assert_handler>
    RT_ASSERT(thread->stat == RT_THREAD_INIT);
 8018c00:	687b      	ldr	r3, [r7, #4]
 8018c02:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8018c06:	2b00      	cmp	r3, #0
 8018c08:	d004      	beq.n	8018c14 <rt_thread_startup+0x2c>
 8018c0a:	4815      	ldr	r0, [pc, #84]	; (8018c60 <rt_thread_startup+0x78>)
 8018c0c:	4913      	ldr	r1, [pc, #76]	; (8018c5c <rt_thread_startup+0x74>)
 8018c0e:	22cf      	movs	r2, #207	; 0xcf
 8018c10:	f7fe fece 	bl	80179b0 <rt_assert_handler>

    /* set current priority to init priority */
    thread->current_priority = thread->init_priority;
 8018c14:	687b      	ldr	r3, [r7, #4]
 8018c16:	f893 2036 	ldrb.w	r2, [r3, #54]	; 0x36
 8018c1a:	687b      	ldr	r3, [r7, #4]
 8018c1c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
#if RT_THREAD_PRIORITY_MAX > 32
    thread->number      = thread->current_priority >> 3;            /* 5bit */
    thread->number_mask = 1L << thread->number;
    thread->high_mask   = 1L << (thread->current_priority & 0x07);  /* 3bit */
#else
    thread->number_mask = 1L << thread->current_priority;
 8018c20:	687b      	ldr	r3, [r7, #4]
 8018c22:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8018c26:	461a      	mov	r2, r3
 8018c28:	2301      	movs	r3, #1
 8018c2a:	4093      	lsls	r3, r2
 8018c2c:	461a      	mov	r2, r3
 8018c2e:	687b      	ldr	r3, [r7, #4]
 8018c30:	639a      	str	r2, [r3, #56]	; 0x38
#endif

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("startup a thread:%s with priority:%d\n",
                                   thread->name, thread->init_priority));
    /* change thread stat */
    thread->stat = RT_THREAD_SUSPEND;
 8018c32:	687b      	ldr	r3, [r7, #4]
 8018c34:	2202      	movs	r2, #2
 8018c36:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    /* then resume it */
    rt_thread_resume(thread);
 8018c3a:	6878      	ldr	r0, [r7, #4]
 8018c3c:	f000 f97e 	bl	8018f3c <rt_thread_resume>
    if (rt_thread_self() != RT_NULL)
 8018c40:	f7ff ffc6 	bl	8018bd0 <rt_thread_self>
 8018c44:	4603      	mov	r3, r0
 8018c46:	2b00      	cmp	r3, #0
 8018c48:	d001      	beq.n	8018c4e <rt_thread_startup+0x66>
    {
        /* do a scheduling */
        rt_schedule();
 8018c4a:	f7ff fd85 	bl	8018758 <rt_schedule>
    }

    return RT_EOK;
 8018c4e:	2300      	movs	r3, #0
}
 8018c50:	4618      	mov	r0, r3
 8018c52:	3708      	adds	r7, #8
 8018c54:	46bd      	mov	sp, r7
 8018c56:	bd80      	pop	{r7, pc}
 8018c58:	08027bec 	.word	0x08027bec
 8018c5c:	080291b4 	.word	0x080291b4
 8018c60:	08027c18 	.word	0x08027c18

08018c64 <rt_thread_create>:
                             void (*entry)(void *parameter),
                             void       *parameter,
                             rt_uint32_t stack_size,
                             rt_uint8_t  priority,
                             rt_uint32_t tick)
{
 8018c64:	b580      	push	{r7, lr}
 8018c66:	b08a      	sub	sp, #40	; 0x28
 8018c68:	af04      	add	r7, sp, #16
 8018c6a:	60f8      	str	r0, [r7, #12]
 8018c6c:	60b9      	str	r1, [r7, #8]
 8018c6e:	607a      	str	r2, [r7, #4]
 8018c70:	603b      	str	r3, [r7, #0]
    struct rt_thread *thread;
    void *stack_start;

    thread = (struct rt_thread *)rt_object_allocate(RT_Object_Class_Thread,
 8018c72:	2000      	movs	r0, #0
 8018c74:	68f9      	ldr	r1, [r7, #12]
 8018c76:	f7ff fbd9 	bl	801842c <rt_object_allocate>
 8018c7a:	6178      	str	r0, [r7, #20]
                                                    name);
    if (thread == RT_NULL)
 8018c7c:	697b      	ldr	r3, [r7, #20]
 8018c7e:	2b00      	cmp	r3, #0
 8018c80:	d101      	bne.n	8018c86 <rt_thread_create+0x22>
        return RT_NULL;
 8018c82:	2300      	movs	r3, #0
 8018c84:	e01b      	b.n	8018cbe <rt_thread_create+0x5a>

    stack_start = (void *)RT_KERNEL_MALLOC(stack_size);
 8018c86:	6838      	ldr	r0, [r7, #0]
 8018c88:	f7fe ffc6 	bl	8017c18 <rt_malloc>
 8018c8c:	6138      	str	r0, [r7, #16]
    if (stack_start == RT_NULL)
 8018c8e:	693b      	ldr	r3, [r7, #16]
 8018c90:	2b00      	cmp	r3, #0
 8018c92:	d104      	bne.n	8018c9e <rt_thread_create+0x3a>
    {
        /* allocate stack failure */
        rt_object_delete((rt_object_t)thread);
 8018c94:	6978      	ldr	r0, [r7, #20]
 8018c96:	f7ff fc25 	bl	80184e4 <rt_object_delete>

        return RT_NULL;
 8018c9a:	2300      	movs	r3, #0
 8018c9c:	e00f      	b.n	8018cbe <rt_thread_create+0x5a>
    }

    _rt_thread_init(thread,
 8018c9e:	693b      	ldr	r3, [r7, #16]
 8018ca0:	9300      	str	r3, [sp, #0]
 8018ca2:	683b      	ldr	r3, [r7, #0]
 8018ca4:	9301      	str	r3, [sp, #4]
 8018ca6:	f897 3020 	ldrb.w	r3, [r7, #32]
 8018caa:	9302      	str	r3, [sp, #8]
 8018cac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018cae:	9303      	str	r3, [sp, #12]
 8018cb0:	6978      	ldr	r0, [r7, #20]
 8018cb2:	68f9      	ldr	r1, [r7, #12]
 8018cb4:	68ba      	ldr	r2, [r7, #8]
 8018cb6:	687b      	ldr	r3, [r7, #4]
 8018cb8:	f7ff fee0 	bl	8018a7c <_rt_thread_init>
                    stack_start,
                    stack_size,
                    priority,
                    tick);

    return thread;
 8018cbc:	697b      	ldr	r3, [r7, #20]
}
 8018cbe:	4618      	mov	r0, r3
 8018cc0:	3718      	adds	r7, #24
 8018cc2:	46bd      	mov	sp, r7
 8018cc4:	bd80      	pop	{r7, pc}
 8018cc6:	bf00      	nop

08018cc8 <rt_thread_delete>:
 * @param thread the thread to be deleted
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_delete(rt_thread_t thread)
{
 8018cc8:	b580      	push	{r7, lr}
 8018cca:	b084      	sub	sp, #16
 8018ccc:	af00      	add	r7, sp, #0
 8018cce:	6078      	str	r0, [r7, #4]
    rt_base_t lock;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 8018cd0:	687b      	ldr	r3, [r7, #4]
 8018cd2:	2b00      	cmp	r3, #0
 8018cd4:	d105      	bne.n	8018ce2 <rt_thread_delete+0x1a>
 8018cd6:	4811      	ldr	r0, [pc, #68]	; (8018d1c <rt_thread_delete+0x54>)
 8018cd8:	4911      	ldr	r1, [pc, #68]	; (8018d20 <rt_thread_delete+0x58>)
 8018cda:	f240 1259 	movw	r2, #345	; 0x159
 8018cde:	f7fe fe67 	bl	80179b0 <rt_assert_handler>

    /* remove from schedule */
    rt_schedule_remove_thread(thread);
 8018ce2:	6878      	ldr	r0, [r7, #4]
 8018ce4:	f7ff fdcc 	bl	8018880 <rt_schedule_remove_thread>

    /* release thread timer */
    rt_timer_detach(&(thread->thread_timer));
 8018ce8:	687b      	ldr	r3, [r7, #4]
 8018cea:	334c      	adds	r3, #76	; 0x4c
 8018cec:	4618      	mov	r0, r3
 8018cee:	f000 fa67 	bl	80191c0 <rt_timer_detach>

    /* change stat */
    thread->stat = RT_THREAD_CLOSE;
 8018cf2:	687b      	ldr	r3, [r7, #4]
 8018cf4:	2204      	movs	r2, #4
 8018cf6:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* disable interrupt */
    lock = rt_hw_interrupt_disable();
 8018cfa:	f7e7 fa65 	bl	80001c8 <rt_hw_interrupt_disable>
 8018cfe:	60f8      	str	r0, [r7, #12]

    /* insert to defunct thread list */
    rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
 8018d00:	687b      	ldr	r3, [r7, #4]
 8018d02:	3314      	adds	r3, #20
 8018d04:	4807      	ldr	r0, [pc, #28]	; (8018d24 <rt_thread_delete+0x5c>)
 8018d06:	4619      	mov	r1, r3
 8018d08:	f7ff fe38 	bl	801897c <rt_list_insert_after>

    /* enable interrupt */
    rt_hw_interrupt_enable(lock);
 8018d0c:	68f8      	ldr	r0, [r7, #12]
 8018d0e:	f7e7 fa5f 	bl	80001d0 <rt_hw_interrupt_enable>

    return RT_EOK;
 8018d12:	2300      	movs	r3, #0
}
 8018d14:	4618      	mov	r0, r3
 8018d16:	3710      	adds	r7, #16
 8018d18:	46bd      	mov	sp, r7
 8018d1a:	bd80      	pop	{r7, pc}
 8018d1c:	08027bec 	.word	0x08027bec
 8018d20:	080291c8 	.word	0x080291c8
 8018d24:	20012b58 	.word	0x20012b58

08018d28 <rt_thread_yield>:
 * is still in READY state.
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_yield(void)
{
 8018d28:	b590      	push	{r4, r7, lr}
 8018d2a:	b083      	sub	sp, #12
 8018d2c:	af00      	add	r7, sp, #0
    register rt_base_t level;
    struct rt_thread *thread;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 8018d2e:	f7e7 fa4b 	bl	80001c8 <rt_hw_interrupt_disable>
 8018d32:	4604      	mov	r4, r0

    /* set to current thread */
    thread = rt_current_thread;
 8018d34:	4b16      	ldr	r3, [pc, #88]	; (8018d90 <rt_thread_yield+0x68>)
 8018d36:	681b      	ldr	r3, [r3, #0]
 8018d38:	607b      	str	r3, [r7, #4]

    /* if the thread stat is READY and on ready queue list */
    if (thread->stat == RT_THREAD_READY &&
 8018d3a:	687b      	ldr	r3, [r7, #4]
 8018d3c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8018d40:	2b01      	cmp	r3, #1
 8018d42:	d11d      	bne.n	8018d80 <rt_thread_yield+0x58>
        thread->tlist.next != thread->tlist.prev)
 8018d44:	687b      	ldr	r3, [r7, #4]
 8018d46:	695a      	ldr	r2, [r3, #20]
 8018d48:	687b      	ldr	r3, [r7, #4]
 8018d4a:	699b      	ldr	r3, [r3, #24]

    /* set to current thread */
    thread = rt_current_thread;

    /* if the thread stat is READY and on ready queue list */
    if (thread->stat == RT_THREAD_READY &&
 8018d4c:	429a      	cmp	r2, r3
 8018d4e:	d017      	beq.n	8018d80 <rt_thread_yield+0x58>
        thread->tlist.next != thread->tlist.prev)
    {
        /* remove thread from thread list */
        rt_list_remove(&(thread->tlist));
 8018d50:	687b      	ldr	r3, [r7, #4]
 8018d52:	3314      	adds	r3, #20
 8018d54:	4618      	mov	r0, r3
 8018d56:	f7ff fe41 	bl	80189dc <rt_list_remove>

        /* put thread to end of ready queue */
        rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
 8018d5a:	687b      	ldr	r3, [r7, #4]
 8018d5c:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8018d60:	00db      	lsls	r3, r3, #3
 8018d62:	4a0c      	ldr	r2, [pc, #48]	; (8018d94 <rt_thread_yield+0x6c>)
 8018d64:	441a      	add	r2, r3
 8018d66:	687b      	ldr	r3, [r7, #4]
 8018d68:	3314      	adds	r3, #20
 8018d6a:	4610      	mov	r0, r2
 8018d6c:	4619      	mov	r1, r3
 8018d6e:	f7ff fe1d 	bl	80189ac <rt_list_insert_before>
                              &(thread->tlist));

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 8018d72:	4620      	mov	r0, r4
 8018d74:	f7e7 fa2c 	bl	80001d0 <rt_hw_interrupt_enable>

        rt_schedule();
 8018d78:	f7ff fcee 	bl	8018758 <rt_schedule>

        return RT_EOK;
 8018d7c:	2300      	movs	r3, #0
 8018d7e:	e003      	b.n	8018d88 <rt_thread_yield+0x60>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 8018d80:	4620      	mov	r0, r4
 8018d82:	f7e7 fa25 	bl	80001d0 <rt_hw_interrupt_enable>

    return RT_EOK;
 8018d86:	2300      	movs	r3, #0
}
 8018d88:	4618      	mov	r0, r3
 8018d8a:	370c      	adds	r7, #12
 8018d8c:	46bd      	mov	sp, r7
 8018d8e:	bd90      	pop	{r4, r7, pc}
 8018d90:	20012b50 	.word	0x20012b50
 8018d94:	20012a4c 	.word	0x20012a4c

08018d98 <rt_thread_sleep>:
 * @param tick the sleep ticks
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_sleep(rt_tick_t tick)
{
 8018d98:	b590      	push	{r4, r7, lr}
 8018d9a:	b085      	sub	sp, #20
 8018d9c:	af00      	add	r7, sp, #0
 8018d9e:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;
    struct rt_thread *thread;

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8018da0:	f7e7 fa12 	bl	80001c8 <rt_hw_interrupt_disable>
 8018da4:	4604      	mov	r4, r0
    /* set to current thread */
    thread = rt_current_thread;
 8018da6:	4b17      	ldr	r3, [pc, #92]	; (8018e04 <rt_thread_sleep+0x6c>)
 8018da8:	681b      	ldr	r3, [r3, #0]
 8018daa:	60fb      	str	r3, [r7, #12]
    RT_ASSERT(thread != RT_NULL);
 8018dac:	68fb      	ldr	r3, [r7, #12]
 8018dae:	2b00      	cmp	r3, #0
 8018db0:	d105      	bne.n	8018dbe <rt_thread_sleep+0x26>
 8018db2:	4815      	ldr	r0, [pc, #84]	; (8018e08 <rt_thread_sleep+0x70>)
 8018db4:	4915      	ldr	r1, [pc, #84]	; (8018e0c <rt_thread_sleep+0x74>)
 8018db6:	f44f 72d7 	mov.w	r2, #430	; 0x1ae
 8018dba:	f7fe fdf9 	bl	80179b0 <rt_assert_handler>

    /* suspend thread */
    rt_thread_suspend(thread);
 8018dbe:	68f8      	ldr	r0, [r7, #12]
 8018dc0:	f000 f88c 	bl	8018edc <rt_thread_suspend>

    /* reset the timeout of thread timer and start it */
    rt_timer_control(&(thread->thread_timer), RT_TIMER_CTRL_SET_TIME, &tick);
 8018dc4:	68fb      	ldr	r3, [r7, #12]
 8018dc6:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 8018dca:	1d3b      	adds	r3, r7, #4
 8018dcc:	4610      	mov	r0, r2
 8018dce:	2100      	movs	r1, #0
 8018dd0:	461a      	mov	r2, r3
 8018dd2:	f000 fb7d 	bl	80194d0 <rt_timer_control>
    rt_timer_start(&(thread->thread_timer));
 8018dd6:	68fb      	ldr	r3, [r7, #12]
 8018dd8:	334c      	adds	r3, #76	; 0x4c
 8018dda:	4618      	mov	r0, r3
 8018ddc:	f000 fa32 	bl	8019244 <rt_timer_start>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8018de0:	4620      	mov	r0, r4
 8018de2:	f7e7 f9f5 	bl	80001d0 <rt_hw_interrupt_enable>
	
    rt_schedule();
 8018de6:	f7ff fcb7 	bl	8018758 <rt_schedule>

    /* clear error number of this thread to RT_EOK */
    if (thread->error == -RT_ETIMEOUT)
 8018dea:	68fb      	ldr	r3, [r7, #12]
 8018dec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8018dee:	f113 0f02 	cmn.w	r3, #2
 8018df2:	d102      	bne.n	8018dfa <rt_thread_sleep+0x62>
        thread->error = RT_EOK;
 8018df4:	68fb      	ldr	r3, [r7, #12]
 8018df6:	2200      	movs	r2, #0
 8018df8:	631a      	str	r2, [r3, #48]	; 0x30

    return RT_EOK;
 8018dfa:	2300      	movs	r3, #0
}
 8018dfc:	4618      	mov	r0, r3
 8018dfe:	3714      	adds	r7, #20
 8018e00:	46bd      	mov	sp, r7
 8018e02:	bd90      	pop	{r4, r7, pc}
 8018e04:	20012b50 	.word	0x20012b50
 8018e08:	08027bec 	.word	0x08027bec
 8018e0c:	080291dc 	.word	0x080291dc

08018e10 <rt_thread_delay>:
 * @param tick the delay ticks
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_delay(rt_tick_t tick)
{
 8018e10:	b580      	push	{r7, lr}
 8018e12:	b082      	sub	sp, #8
 8018e14:	af00      	add	r7, sp, #0
 8018e16:	6078      	str	r0, [r7, #4]
    return rt_thread_sleep(tick);
 8018e18:	6878      	ldr	r0, [r7, #4]
 8018e1a:	f7ff ffbd 	bl	8018d98 <rt_thread_sleep>
 8018e1e:	4603      	mov	r3, r0
}
 8018e20:	4618      	mov	r0, r3
 8018e22:	3708      	adds	r7, #8
 8018e24:	46bd      	mov	sp, r7
 8018e26:	bd80      	pop	{r7, pc}

08018e28 <rt_thread_control>:
 * @param arg the argument of control command
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_control(rt_thread_t thread, rt_uint8_t cmd, void *arg)
{
 8018e28:	b590      	push	{r4, r7, lr}
 8018e2a:	b085      	sub	sp, #20
 8018e2c:	af00      	add	r7, sp, #0
 8018e2e:	60f8      	str	r0, [r7, #12]
 8018e30:	460b      	mov	r3, r1
 8018e32:	607a      	str	r2, [r7, #4]
 8018e34:	72fb      	strb	r3, [r7, #11]
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 8018e36:	68fb      	ldr	r3, [r7, #12]
 8018e38:	2b00      	cmp	r3, #0
 8018e3a:	d105      	bne.n	8018e48 <rt_thread_control+0x20>
 8018e3c:	4825      	ldr	r0, [pc, #148]	; (8018ed4 <rt_thread_control+0xac>)
 8018e3e:	4926      	ldr	r1, [pc, #152]	; (8018ed8 <rt_thread_control+0xb0>)
 8018e40:	f240 12e1 	movw	r2, #481	; 0x1e1
 8018e44:	f7fe fdb4 	bl	80179b0 <rt_assert_handler>

    switch (cmd)
 8018e48:	7afb      	ldrb	r3, [r7, #11]
 8018e4a:	2b01      	cmp	r3, #1
 8018e4c:	d038      	beq.n	8018ec0 <rt_thread_control+0x98>
 8018e4e:	2b02      	cmp	r3, #2
 8018e50:	d002      	beq.n	8018e58 <rt_thread_control+0x30>
 8018e52:	2b00      	cmp	r3, #0
 8018e54:	d02f      	beq.n	8018eb6 <rt_thread_control+0x8e>
    case RT_THREAD_CTRL_CLOSE:
        return rt_thread_delete(thread);
#endif

    default:
        break;
 8018e56:	e038      	b.n	8018eca <rt_thread_control+0xa2>

    switch (cmd)
    {
    case RT_THREAD_CTRL_CHANGE_PRIORITY:
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
 8018e58:	f7e7 f9b6 	bl	80001c8 <rt_hw_interrupt_disable>
 8018e5c:	4604      	mov	r4, r0

        /* for ready thread, change queue */
        if (thread->stat == RT_THREAD_READY)
 8018e5e:	68fb      	ldr	r3, [r7, #12]
 8018e60:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8018e64:	2b01      	cmp	r3, #1
 8018e66:	d114      	bne.n	8018e92 <rt_thread_control+0x6a>
        {
            /* remove thread from schedule queue first */
            rt_schedule_remove_thread(thread);
 8018e68:	68f8      	ldr	r0, [r7, #12]
 8018e6a:	f7ff fd09 	bl	8018880 <rt_schedule_remove_thread>

            /* change thread priority */
            thread->current_priority = *(rt_uint8_t *)arg;
 8018e6e:	687b      	ldr	r3, [r7, #4]
 8018e70:	781a      	ldrb	r2, [r3, #0]
 8018e72:	68fb      	ldr	r3, [r7, #12]
 8018e74:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
#if RT_THREAD_PRIORITY_MAX > 32
            thread->number      = thread->current_priority >> 3;            /* 5bit */
            thread->number_mask = 1 << thread->number;
            thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
#else
            thread->number_mask = 1 << thread->current_priority;
 8018e78:	68fb      	ldr	r3, [r7, #12]
 8018e7a:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8018e7e:	461a      	mov	r2, r3
 8018e80:	2301      	movs	r3, #1
 8018e82:	4093      	lsls	r3, r2
 8018e84:	461a      	mov	r2, r3
 8018e86:	68fb      	ldr	r3, [r7, #12]
 8018e88:	639a      	str	r2, [r3, #56]	; 0x38
#endif

            /* insert thread to schedule queue again */
            rt_schedule_insert_thread(thread);
 8018e8a:	68f8      	ldr	r0, [r7, #12]
 8018e8c:	f7ff fcc2 	bl	8018814 <rt_schedule_insert_thread>
 8018e90:	e00d      	b.n	8018eae <rt_thread_control+0x86>
        }
        else
        {
            thread->current_priority = *(rt_uint8_t *)arg;
 8018e92:	687b      	ldr	r3, [r7, #4]
 8018e94:	781a      	ldrb	r2, [r3, #0]
 8018e96:	68fb      	ldr	r3, [r7, #12]
 8018e98:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
#if RT_THREAD_PRIORITY_MAX > 32
            thread->number      = thread->current_priority >> 3;            /* 5bit */
            thread->number_mask = 1 << thread->number;
            thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
#else
            thread->number_mask = 1 << thread->current_priority;
 8018e9c:	68fb      	ldr	r3, [r7, #12]
 8018e9e:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8018ea2:	461a      	mov	r2, r3
 8018ea4:	2301      	movs	r3, #1
 8018ea6:	4093      	lsls	r3, r2
 8018ea8:	461a      	mov	r2, r3
 8018eaa:	68fb      	ldr	r3, [r7, #12]
 8018eac:	639a      	str	r2, [r3, #56]	; 0x38
#endif
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 8018eae:	4620      	mov	r0, r4
 8018eb0:	f7e7 f98e 	bl	80001d0 <rt_hw_interrupt_enable>
        break;
 8018eb4:	e009      	b.n	8018eca <rt_thread_control+0xa2>

    case RT_THREAD_CTRL_STARTUP:
        return rt_thread_startup(thread);
 8018eb6:	68f8      	ldr	r0, [r7, #12]
 8018eb8:	f7ff fe96 	bl	8018be8 <rt_thread_startup>
 8018ebc:	4603      	mov	r3, r0
 8018ebe:	e005      	b.n	8018ecc <rt_thread_control+0xa4>

#ifdef RT_USING_HEAP
    case RT_THREAD_CTRL_CLOSE:
        return rt_thread_delete(thread);
 8018ec0:	68f8      	ldr	r0, [r7, #12]
 8018ec2:	f7ff ff01 	bl	8018cc8 <rt_thread_delete>
 8018ec6:	4603      	mov	r3, r0
 8018ec8:	e000      	b.n	8018ecc <rt_thread_control+0xa4>

    default:
        break;
    }

    return RT_EOK;
 8018eca:	2300      	movs	r3, #0
}
 8018ecc:	4618      	mov	r0, r3
 8018ece:	3714      	adds	r7, #20
 8018ed0:	46bd      	mov	sp, r7
 8018ed2:	bd90      	pop	{r4, r7, pc}
 8018ed4:	08027bec 	.word	0x08027bec
 8018ed8:	080291ec 	.word	0x080291ec

08018edc <rt_thread_suspend>:
 *
 * @note if suspend self thread, after this function call, the
 * rt_schedule() must be invoked.
 */
rt_err_t rt_thread_suspend(rt_thread_t thread)
{
 8018edc:	b590      	push	{r4, r7, lr}
 8018ede:	b083      	sub	sp, #12
 8018ee0:	af00      	add	r7, sp, #0
 8018ee2:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 8018ee4:	687b      	ldr	r3, [r7, #4]
 8018ee6:	2b00      	cmp	r3, #0
 8018ee8:	d105      	bne.n	8018ef6 <rt_thread_suspend+0x1a>
 8018eea:	4812      	ldr	r0, [pc, #72]	; (8018f34 <rt_thread_suspend+0x58>)
 8018eec:	4912      	ldr	r1, [pc, #72]	; (8018f38 <rt_thread_suspend+0x5c>)
 8018eee:	f240 222f 	movw	r2, #559	; 0x22f
 8018ef2:	f7fe fd5d 	bl	80179b0 <rt_assert_handler>

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend:  %s\n", thread->name));

    if (thread->stat != RT_THREAD_READY)
 8018ef6:	687b      	ldr	r3, [r7, #4]
 8018ef8:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8018efc:	2b01      	cmp	r3, #1
 8018efe:	d002      	beq.n	8018f06 <rt_thread_suspend+0x2a>
    {
        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend: thread disorder, %d\n",
                                       thread->stat));

        return -RT_ERROR;
 8018f00:	f04f 33ff 	mov.w	r3, #4294967295
 8018f04:	e012      	b.n	8018f2c <rt_thread_suspend+0x50>
    }

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8018f06:	f7e7 f95f 	bl	80001c8 <rt_hw_interrupt_disable>
 8018f0a:	4604      	mov	r4, r0

    /* change thread stat */
    thread->stat = RT_THREAD_SUSPEND;
 8018f0c:	687b      	ldr	r3, [r7, #4]
 8018f0e:	2202      	movs	r2, #2
 8018f10:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    rt_schedule_remove_thread(thread);
 8018f14:	6878      	ldr	r0, [r7, #4]
 8018f16:	f7ff fcb3 	bl	8018880 <rt_schedule_remove_thread>

    /* stop thread timer anyway */
    rt_timer_stop(&(thread->thread_timer));
 8018f1a:	687b      	ldr	r3, [r7, #4]
 8018f1c:	334c      	adds	r3, #76	; 0x4c
 8018f1e:	4618      	mov	r0, r3
 8018f20:	f000 fa9c 	bl	801945c <rt_timer_stop>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8018f24:	4620      	mov	r0, r4
 8018f26:	f7e7 f953 	bl	80001d0 <rt_hw_interrupt_enable>

    return RT_EOK;
 8018f2a:	2300      	movs	r3, #0
}
 8018f2c:	4618      	mov	r0, r3
 8018f2e:	370c      	adds	r7, #12
 8018f30:	46bd      	mov	sp, r7
 8018f32:	bd90      	pop	{r4, r7, pc}
 8018f34:	08027bec 	.word	0x08027bec
 8018f38:	08029200 	.word	0x08029200

08018f3c <rt_thread_resume>:
 * @param thread the thread to be resumed
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_resume(rt_thread_t thread)
{
 8018f3c:	b590      	push	{r4, r7, lr}
 8018f3e:	b083      	sub	sp, #12
 8018f40:	af00      	add	r7, sp, #0
 8018f42:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 8018f44:	687b      	ldr	r3, [r7, #4]
 8018f46:	2b00      	cmp	r3, #0
 8018f48:	d105      	bne.n	8018f56 <rt_thread_resume+0x1a>
 8018f4a:	4813      	ldr	r0, [pc, #76]	; (8018f98 <rt_thread_resume+0x5c>)
 8018f4c:	4913      	ldr	r1, [pc, #76]	; (8018f9c <rt_thread_resume+0x60>)
 8018f4e:	f44f 7216 	mov.w	r2, #600	; 0x258
 8018f52:	f7fe fd2d 	bl	80179b0 <rt_assert_handler>

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume:  %s\n", thread->name));

    if (thread->stat != RT_THREAD_SUSPEND)
 8018f56:	687b      	ldr	r3, [r7, #4]
 8018f58:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8018f5c:	2b02      	cmp	r3, #2
 8018f5e:	d002      	beq.n	8018f66 <rt_thread_resume+0x2a>
    {
        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume: thread disorder, %d\n",
                                       thread->stat));

        return -RT_ERROR;
 8018f60:	f04f 33ff 	mov.w	r3, #4294967295
 8018f64:	e013      	b.n	8018f8e <rt_thread_resume+0x52>
    }

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8018f66:	f7e7 f92f 	bl	80001c8 <rt_hw_interrupt_disable>
 8018f6a:	4604      	mov	r4, r0

    /* remove from suspend list */
    rt_list_remove(&(thread->tlist));
 8018f6c:	687b      	ldr	r3, [r7, #4]
 8018f6e:	3314      	adds	r3, #20
 8018f70:	4618      	mov	r0, r3
 8018f72:	f7ff fd33 	bl	80189dc <rt_list_remove>

    rt_timer_stop(&thread->thread_timer);
 8018f76:	687b      	ldr	r3, [r7, #4]
 8018f78:	334c      	adds	r3, #76	; 0x4c
 8018f7a:	4618      	mov	r0, r3
 8018f7c:	f000 fa6e 	bl	801945c <rt_timer_stop>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8018f80:	4620      	mov	r0, r4
 8018f82:	f7e7 f925 	bl	80001d0 <rt_hw_interrupt_enable>

    /* insert to schedule ready list */
    rt_schedule_insert_thread(thread);
 8018f86:	6878      	ldr	r0, [r7, #4]
 8018f88:	f7ff fc44 	bl	8018814 <rt_schedule_insert_thread>

    return RT_EOK;
 8018f8c:	2300      	movs	r3, #0
}
 8018f8e:	4618      	mov	r0, r3
 8018f90:	370c      	adds	r7, #12
 8018f92:	46bd      	mov	sp, r7
 8018f94:	bd90      	pop	{r4, r7, pc}
 8018f96:	bf00      	nop
 8018f98:	08027bec 	.word	0x08027bec
 8018f9c:	08029214 	.word	0x08029214

08018fa0 <rt_thread_timeout>:
 * when thread is timeout to wait some resource.
 *
 * @param parameter the parameter of thread timeout function
 */
void rt_thread_timeout(void *parameter)
{
 8018fa0:	b580      	push	{r7, lr}
 8018fa2:	b084      	sub	sp, #16
 8018fa4:	af00      	add	r7, sp, #0
 8018fa6:	6078      	str	r0, [r7, #4]
    struct rt_thread *thread;

    thread = (struct rt_thread *)parameter;
 8018fa8:	687b      	ldr	r3, [r7, #4]
 8018faa:	60fb      	str	r3, [r7, #12]

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 8018fac:	68fb      	ldr	r3, [r7, #12]
 8018fae:	2b00      	cmp	r3, #0
 8018fb0:	d105      	bne.n	8018fbe <rt_thread_timeout+0x1e>
 8018fb2:	4811      	ldr	r0, [pc, #68]	; (8018ff8 <rt_thread_timeout+0x58>)
 8018fb4:	4911      	ldr	r1, [pc, #68]	; (8018ffc <rt_thread_timeout+0x5c>)
 8018fb6:	f240 2283 	movw	r2, #643	; 0x283
 8018fba:	f7fe fcf9 	bl	80179b0 <rt_assert_handler>
    RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);
 8018fbe:	68fb      	ldr	r3, [r7, #12]
 8018fc0:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8018fc4:	2b02      	cmp	r3, #2
 8018fc6:	d005      	beq.n	8018fd4 <rt_thread_timeout+0x34>
 8018fc8:	480d      	ldr	r0, [pc, #52]	; (8019000 <rt_thread_timeout+0x60>)
 8018fca:	490c      	ldr	r1, [pc, #48]	; (8018ffc <rt_thread_timeout+0x5c>)
 8018fcc:	f44f 7221 	mov.w	r2, #644	; 0x284
 8018fd0:	f7fe fcee 	bl	80179b0 <rt_assert_handler>

    /* set error number */
    thread->error = -RT_ETIMEOUT;
 8018fd4:	68fb      	ldr	r3, [r7, #12]
 8018fd6:	f06f 0201 	mvn.w	r2, #1
 8018fda:	631a      	str	r2, [r3, #48]	; 0x30

    /* remove from suspend list */
    rt_list_remove(&(thread->tlist));
 8018fdc:	68fb      	ldr	r3, [r7, #12]
 8018fde:	3314      	adds	r3, #20
 8018fe0:	4618      	mov	r0, r3
 8018fe2:	f7ff fcfb 	bl	80189dc <rt_list_remove>

    /* insert to schedule ready list */
    rt_schedule_insert_thread(thread);
 8018fe6:	68f8      	ldr	r0, [r7, #12]
 8018fe8:	f7ff fc14 	bl	8018814 <rt_schedule_insert_thread>

    /* do schedule */
    rt_schedule();
 8018fec:	f7ff fbb4 	bl	8018758 <rt_schedule>
}
 8018ff0:	3710      	adds	r7, #16
 8018ff2:	46bd      	mov	sp, r7
 8018ff4:	bd80      	pop	{r7, pc}
 8018ff6:	bf00      	nop
 8018ff8:	08027bec 	.word	0x08027bec
 8018ffc:	08029228 	.word	0x08029228
 8019000:	08027c38 	.word	0x08027c38

08019004 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 8019004:	b480      	push	{r7}
 8019006:	b083      	sub	sp, #12
 8019008:	af00      	add	r7, sp, #0
 801900a:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 801900c:	687b      	ldr	r3, [r7, #4]
 801900e:	687a      	ldr	r2, [r7, #4]
 8019010:	605a      	str	r2, [r3, #4]
 8019012:	687b      	ldr	r3, [r7, #4]
 8019014:	685a      	ldr	r2, [r3, #4]
 8019016:	687b      	ldr	r3, [r7, #4]
 8019018:	601a      	str	r2, [r3, #0]
}
 801901a:	370c      	adds	r7, #12
 801901c:	46bd      	mov	sp, r7
 801901e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019022:	4770      	bx	lr

08019024 <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
 8019024:	b480      	push	{r7}
 8019026:	b083      	sub	sp, #12
 8019028:	af00      	add	r7, sp, #0
 801902a:	6078      	str	r0, [r7, #4]
 801902c:	6039      	str	r1, [r7, #0]
    l->next->prev = n;
 801902e:	687b      	ldr	r3, [r7, #4]
 8019030:	681b      	ldr	r3, [r3, #0]
 8019032:	683a      	ldr	r2, [r7, #0]
 8019034:	605a      	str	r2, [r3, #4]
    n->next = l->next;
 8019036:	687b      	ldr	r3, [r7, #4]
 8019038:	681a      	ldr	r2, [r3, #0]
 801903a:	683b      	ldr	r3, [r7, #0]
 801903c:	601a      	str	r2, [r3, #0]

    l->next = n;
 801903e:	687b      	ldr	r3, [r7, #4]
 8019040:	683a      	ldr	r2, [r7, #0]
 8019042:	601a      	str	r2, [r3, #0]
    n->prev = l;
 8019044:	683b      	ldr	r3, [r7, #0]
 8019046:	687a      	ldr	r2, [r7, #4]
 8019048:	605a      	str	r2, [r3, #4]
}
 801904a:	370c      	adds	r7, #12
 801904c:	46bd      	mov	sp, r7
 801904e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019052:	4770      	bx	lr

08019054 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 8019054:	b480      	push	{r7}
 8019056:	b083      	sub	sp, #12
 8019058:	af00      	add	r7, sp, #0
 801905a:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 801905c:	687b      	ldr	r3, [r7, #4]
 801905e:	681b      	ldr	r3, [r3, #0]
 8019060:	687a      	ldr	r2, [r7, #4]
 8019062:	6852      	ldr	r2, [r2, #4]
 8019064:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 8019066:	687b      	ldr	r3, [r7, #4]
 8019068:	685b      	ldr	r3, [r3, #4]
 801906a:	687a      	ldr	r2, [r7, #4]
 801906c:	6812      	ldr	r2, [r2, #0]
 801906e:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 8019070:	687b      	ldr	r3, [r7, #4]
 8019072:	687a      	ldr	r2, [r7, #4]
 8019074:	605a      	str	r2, [r3, #4]
 8019076:	687b      	ldr	r3, [r7, #4]
 8019078:	685a      	ldr	r2, [r3, #4]
 801907a:	687b      	ldr	r3, [r7, #4]
 801907c:	601a      	str	r2, [r3, #0]
}
 801907e:	370c      	adds	r7, #12
 8019080:	46bd      	mov	sp, r7
 8019082:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019086:	4770      	bx	lr

08019088 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 8019088:	b480      	push	{r7}
 801908a:	b083      	sub	sp, #12
 801908c:	af00      	add	r7, sp, #0
 801908e:	6078      	str	r0, [r7, #4]
    return l->next == l;
 8019090:	687b      	ldr	r3, [r7, #4]
 8019092:	681a      	ldr	r2, [r3, #0]
 8019094:	687b      	ldr	r3, [r7, #4]
 8019096:	429a      	cmp	r2, r3
 8019098:	bf0c      	ite	eq
 801909a:	2301      	moveq	r3, #1
 801909c:	2300      	movne	r3, #0
 801909e:	b2db      	uxtb	r3, r3
}
 80190a0:	4618      	mov	r0, r3
 80190a2:	370c      	adds	r7, #12
 80190a4:	46bd      	mov	sp, r7
 80190a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80190aa:	4770      	bx	lr

080190ac <_rt_timer_init>:
static void _rt_timer_init(rt_timer_t timer,
                           void (*timeout)(void *parameter),
                           void      *parameter,
                           rt_tick_t  time,
                           rt_uint8_t flag)
{
 80190ac:	b580      	push	{r7, lr}
 80190ae:	b086      	sub	sp, #24
 80190b0:	af00      	add	r7, sp, #0
 80190b2:	60f8      	str	r0, [r7, #12]
 80190b4:	60b9      	str	r1, [r7, #8]
 80190b6:	607a      	str	r2, [r7, #4]
 80190b8:	603b      	str	r3, [r7, #0]
    int i;

    /* set flag */
    timer->parent.flag  = flag;
 80190ba:	68fb      	ldr	r3, [r7, #12]
 80190bc:	f897 2020 	ldrb.w	r2, [r7, #32]
 80190c0:	725a      	strb	r2, [r3, #9]

    /* set deactivated */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 80190c2:	68fb      	ldr	r3, [r7, #12]
 80190c4:	7a5b      	ldrb	r3, [r3, #9]
 80190c6:	f023 0301 	bic.w	r3, r3, #1
 80190ca:	b2da      	uxtb	r2, r3
 80190cc:	68fb      	ldr	r3, [r7, #12]
 80190ce:	725a      	strb	r2, [r3, #9]

    timer->timeout_func = timeout;
 80190d0:	68fb      	ldr	r3, [r7, #12]
 80190d2:	68ba      	ldr	r2, [r7, #8]
 80190d4:	61da      	str	r2, [r3, #28]
    timer->parameter    = parameter;
 80190d6:	68fb      	ldr	r3, [r7, #12]
 80190d8:	687a      	ldr	r2, [r7, #4]
 80190da:	621a      	str	r2, [r3, #32]

    timer->timeout_tick = 0;
 80190dc:	68fb      	ldr	r3, [r7, #12]
 80190de:	2200      	movs	r2, #0
 80190e0:	629a      	str	r2, [r3, #40]	; 0x28
    timer->init_tick    = time;
 80190e2:	68fb      	ldr	r3, [r7, #12]
 80190e4:	683a      	ldr	r2, [r7, #0]
 80190e6:	625a      	str	r2, [r3, #36]	; 0x24

    /* initialize timer list */
    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
 80190e8:	2300      	movs	r3, #0
 80190ea:	617b      	str	r3, [r7, #20]
 80190ec:	e00b      	b.n	8019106 <_rt_timer_init+0x5a>
    {
        rt_list_init(&(timer->row[i]));
 80190ee:	697b      	ldr	r3, [r7, #20]
 80190f0:	3302      	adds	r3, #2
 80190f2:	00db      	lsls	r3, r3, #3
 80190f4:	68fa      	ldr	r2, [r7, #12]
 80190f6:	4413      	add	r3, r2
 80190f8:	3304      	adds	r3, #4
 80190fa:	4618      	mov	r0, r3
 80190fc:	f7ff ff82 	bl	8019004 <rt_list_init>

    timer->timeout_tick = 0;
    timer->init_tick    = time;

    /* initialize timer list */
    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
 8019100:	697b      	ldr	r3, [r7, #20]
 8019102:	3301      	adds	r3, #1
 8019104:	617b      	str	r3, [r7, #20]
 8019106:	697b      	ldr	r3, [r7, #20]
 8019108:	2b00      	cmp	r3, #0
 801910a:	ddf0      	ble.n	80190ee <_rt_timer_init+0x42>
    {
        rt_list_init(&(timer->row[i]));
    }
}
 801910c:	3718      	adds	r7, #24
 801910e:	46bd      	mov	sp, r7
 8019110:	bd80      	pop	{r7, pc}
 8019112:	bf00      	nop

08019114 <rt_timer_list_next_timeout>:

/* the fist timer always in the last row */
static rt_tick_t rt_timer_list_next_timeout(rt_list_t timer_list[])
{
 8019114:	b580      	push	{r7, lr}
 8019116:	b084      	sub	sp, #16
 8019118:	af00      	add	r7, sp, #0
 801911a:	6078      	str	r0, [r7, #4]
    struct rt_timer *timer;

    if (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
 801911c:	6878      	ldr	r0, [r7, #4]
 801911e:	f7ff ffb3 	bl	8019088 <rt_list_isempty>
 8019122:	4603      	mov	r3, r0
 8019124:	2b00      	cmp	r3, #0
 8019126:	d002      	beq.n	801912e <rt_timer_list_next_timeout+0x1a>
        return RT_TICK_MAX;
 8019128:	f04f 33ff 	mov.w	r3, #4294967295
 801912c:	e005      	b.n	801913a <rt_timer_list_next_timeout+0x26>

    timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
 801912e:	687b      	ldr	r3, [r7, #4]
 8019130:	681b      	ldr	r3, [r3, #0]
 8019132:	3b14      	subs	r3, #20
 8019134:	60fb      	str	r3, [r7, #12]
                          struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);

    return timer->timeout_tick;
 8019136:	68fb      	ldr	r3, [r7, #12]
 8019138:	6a9b      	ldr	r3, [r3, #40]	; 0x28
}
 801913a:	4618      	mov	r0, r3
 801913c:	3710      	adds	r7, #16
 801913e:	46bd      	mov	sp, r7
 8019140:	bd80      	pop	{r7, pc}
 8019142:	bf00      	nop

08019144 <_rt_timer_remove>:

rt_inline void _rt_timer_remove(rt_timer_t timer)
{
 8019144:	b580      	push	{r7, lr}
 8019146:	b084      	sub	sp, #16
 8019148:	af00      	add	r7, sp, #0
 801914a:	6078      	str	r0, [r7, #4]
    int i;

    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
 801914c:	2300      	movs	r3, #0
 801914e:	60fb      	str	r3, [r7, #12]
 8019150:	e00b      	b.n	801916a <_rt_timer_remove+0x26>
    {
        rt_list_remove(&timer->row[i]);
 8019152:	68fb      	ldr	r3, [r7, #12]
 8019154:	3302      	adds	r3, #2
 8019156:	00db      	lsls	r3, r3, #3
 8019158:	687a      	ldr	r2, [r7, #4]
 801915a:	4413      	add	r3, r2
 801915c:	3304      	adds	r3, #4
 801915e:	4618      	mov	r0, r3
 8019160:	f7ff ff78 	bl	8019054 <rt_list_remove>

rt_inline void _rt_timer_remove(rt_timer_t timer)
{
    int i;

    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
 8019164:	68fb      	ldr	r3, [r7, #12]
 8019166:	3301      	adds	r3, #1
 8019168:	60fb      	str	r3, [r7, #12]
 801916a:	68fb      	ldr	r3, [r7, #12]
 801916c:	2b00      	cmp	r3, #0
 801916e:	ddf0      	ble.n	8019152 <_rt_timer_remove+0xe>
    {
        rt_list_remove(&timer->row[i]);
    }
}
 8019170:	3710      	adds	r7, #16
 8019172:	46bd      	mov	sp, r7
 8019174:	bd80      	pop	{r7, pc}
 8019176:	bf00      	nop

08019178 <rt_timer_init>:
                   const char *name,
                   void (*timeout)(void *parameter),
                   void       *parameter,
                   rt_tick_t   time,
                   rt_uint8_t  flag)
{
 8019178:	b580      	push	{r7, lr}
 801917a:	b086      	sub	sp, #24
 801917c:	af02      	add	r7, sp, #8
 801917e:	60f8      	str	r0, [r7, #12]
 8019180:	60b9      	str	r1, [r7, #8]
 8019182:	607a      	str	r2, [r7, #4]
 8019184:	603b      	str	r3, [r7, #0]
    /* timer check */
    RT_ASSERT(timer != RT_NULL);
 8019186:	68fb      	ldr	r3, [r7, #12]
 8019188:	2b00      	cmp	r3, #0
 801918a:	d104      	bne.n	8019196 <rt_timer_init+0x1e>
 801918c:	480a      	ldr	r0, [pc, #40]	; (80191b8 <rt_timer_init+0x40>)
 801918e:	490b      	ldr	r1, [pc, #44]	; (80191bc <rt_timer_init+0x44>)
 8019190:	22bc      	movs	r2, #188	; 0xbc
 8019192:	f7fe fc0d 	bl	80179b0 <rt_assert_handler>

    /* timer object initialization */
    rt_object_init((rt_object_t)timer, RT_Object_Class_Timer, name);
 8019196:	68f8      	ldr	r0, [r7, #12]
 8019198:	2109      	movs	r1, #9
 801919a:	68ba      	ldr	r2, [r7, #8]
 801919c:	f7ff f8e8 	bl	8018370 <rt_object_init>

    _rt_timer_init(timer, timeout, parameter, time, flag);
 80191a0:	7f3b      	ldrb	r3, [r7, #28]
 80191a2:	9300      	str	r3, [sp, #0]
 80191a4:	68f8      	ldr	r0, [r7, #12]
 80191a6:	6879      	ldr	r1, [r7, #4]
 80191a8:	683a      	ldr	r2, [r7, #0]
 80191aa:	69bb      	ldr	r3, [r7, #24]
 80191ac:	f7ff ff7e 	bl	80190ac <_rt_timer_init>
}
 80191b0:	3710      	adds	r7, #16
 80191b2:	46bd      	mov	sp, r7
 80191b4:	bd80      	pop	{r7, pc}
 80191b6:	bf00      	nop
 80191b8:	08027c5c 	.word	0x08027c5c
 80191bc:	0802923c 	.word	0x0802923c

080191c0 <rt_timer_detach>:
 * @param timer the static timer object
 *
 * @return the operation status, RT_EOK on OK; RT_ERROR on error
 */
rt_err_t rt_timer_detach(rt_timer_t timer)
{
 80191c0:	b590      	push	{r4, r7, lr}
 80191c2:	b083      	sub	sp, #12
 80191c4:	af00      	add	r7, sp, #0
 80191c6:	6078      	str	r0, [r7, #4]
    register rt_base_t level;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
 80191c8:	687b      	ldr	r3, [r7, #4]
 80191ca:	2b00      	cmp	r3, #0
 80191cc:	d104      	bne.n	80191d8 <rt_timer_detach+0x18>
 80191ce:	480b      	ldr	r0, [pc, #44]	; (80191fc <rt_timer_detach+0x3c>)
 80191d0:	490b      	ldr	r1, [pc, #44]	; (8019200 <rt_timer_detach+0x40>)
 80191d2:	22d1      	movs	r2, #209	; 0xd1
 80191d4:	f7fe fbec 	bl	80179b0 <rt_assert_handler>

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 80191d8:	f7e6 fff6 	bl	80001c8 <rt_hw_interrupt_disable>
 80191dc:	4604      	mov	r4, r0

    _rt_timer_remove(timer);
 80191de:	6878      	ldr	r0, [r7, #4]
 80191e0:	f7ff ffb0 	bl	8019144 <_rt_timer_remove>

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 80191e4:	4620      	mov	r0, r4
 80191e6:	f7e6 fff3 	bl	80001d0 <rt_hw_interrupt_enable>

    rt_object_detach((rt_object_t)timer);
 80191ea:	6878      	ldr	r0, [r7, #4]
 80191ec:	f7ff f8f6 	bl	80183dc <rt_object_detach>

    return -RT_EOK;
 80191f0:	2300      	movs	r3, #0
}
 80191f2:	4618      	mov	r0, r3
 80191f4:	370c      	adds	r7, #12
 80191f6:	46bd      	mov	sp, r7
 80191f8:	bd90      	pop	{r4, r7, pc}
 80191fa:	bf00      	nop
 80191fc:	08027c5c 	.word	0x08027c5c
 8019200:	0802924c 	.word	0x0802924c

08019204 <rt_timer_create>:
rt_timer_t rt_timer_create(const char *name,
                           void (*timeout)(void *parameter),
                           void       *parameter,
                           rt_tick_t   time,
                           rt_uint8_t  flag)
{
 8019204:	b580      	push	{r7, lr}
 8019206:	b088      	sub	sp, #32
 8019208:	af02      	add	r7, sp, #8
 801920a:	60f8      	str	r0, [r7, #12]
 801920c:	60b9      	str	r1, [r7, #8]
 801920e:	607a      	str	r2, [r7, #4]
 8019210:	603b      	str	r3, [r7, #0]
    struct rt_timer *timer;

    /* allocate a object */
    timer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);
 8019212:	2009      	movs	r0, #9
 8019214:	68f9      	ldr	r1, [r7, #12]
 8019216:	f7ff f909 	bl	801842c <rt_object_allocate>
 801921a:	6178      	str	r0, [r7, #20]
    if (timer == RT_NULL)
 801921c:	697b      	ldr	r3, [r7, #20]
 801921e:	2b00      	cmp	r3, #0
 8019220:	d101      	bne.n	8019226 <rt_timer_create+0x22>
    {
        return RT_NULL;
 8019222:	2300      	movs	r3, #0
 8019224:	e009      	b.n	801923a <rt_timer_create+0x36>
    }

    _rt_timer_init(timer, timeout, parameter, time, flag);
 8019226:	f897 3020 	ldrb.w	r3, [r7, #32]
 801922a:	9300      	str	r3, [sp, #0]
 801922c:	6978      	ldr	r0, [r7, #20]
 801922e:	68b9      	ldr	r1, [r7, #8]
 8019230:	687a      	ldr	r2, [r7, #4]
 8019232:	683b      	ldr	r3, [r7, #0]
 8019234:	f7ff ff3a 	bl	80190ac <_rt_timer_init>

    return timer;
 8019238:	697b      	ldr	r3, [r7, #20]
}
 801923a:	4618      	mov	r0, r3
 801923c:	3718      	adds	r7, #24
 801923e:	46bd      	mov	sp, r7
 8019240:	bd80      	pop	{r7, pc}
 8019242:	bf00      	nop

08019244 <rt_timer_start>:
 * @param timer the timer to be started
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_timer_start(rt_timer_t timer)
{
 8019244:	b590      	push	{r4, r7, lr}
 8019246:	b089      	sub	sp, #36	; 0x24
 8019248:	af00      	add	r7, sp, #0
 801924a:	6078      	str	r0, [r7, #4]
    rt_list_t *row_head[RT_TIMER_SKIP_LIST_LEVEL];
    unsigned int tst_nr;
    static unsigned int random_nr;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
 801924c:	687b      	ldr	r3, [r7, #4]
 801924e:	2b00      	cmp	r3, #0
 8019250:	d105      	bne.n	801925e <rt_timer_start+0x1a>
 8019252:	4879      	ldr	r0, [pc, #484]	; (8019438 <rt_timer_start+0x1f4>)
 8019254:	4979      	ldr	r1, [pc, #484]	; (801943c <rt_timer_start+0x1f8>)
 8019256:	f44f 7298 	mov.w	r2, #304	; 0x130
 801925a:	f7fe fba9 	bl	80179b0 <rt_assert_handler>

	/* stop timer firstly */
	level = rt_hw_interrupt_disable();
 801925e:	f7e6 ffb3 	bl	80001c8 <rt_hw_interrupt_disable>
 8019262:	4604      	mov	r4, r0
	/* remove timer from list */
    _rt_timer_remove(timer);
 8019264:	6878      	ldr	r0, [r7, #4]
 8019266:	f7ff ff6d 	bl	8019144 <_rt_timer_remove>
    /* change status of timer */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 801926a:	687b      	ldr	r3, [r7, #4]
 801926c:	7a5b      	ldrb	r3, [r3, #9]
 801926e:	f023 0301 	bic.w	r3, r3, #1
 8019272:	b2da      	uxtb	r2, r3
 8019274:	687b      	ldr	r3, [r7, #4]
 8019276:	725a      	strb	r2, [r3, #9]
    rt_hw_interrupt_enable(level);
 8019278:	4620      	mov	r0, r4
 801927a:	f7e6 ffa9 	bl	80001d0 <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(timer->parent)));
 801927e:	4b70      	ldr	r3, [pc, #448]	; (8019440 <rt_timer_start+0x1fc>)
 8019280:	681b      	ldr	r3, [r3, #0]
 8019282:	2b00      	cmp	r3, #0
 8019284:	d004      	beq.n	8019290 <rt_timer_start+0x4c>
 8019286:	4b6e      	ldr	r3, [pc, #440]	; (8019440 <rt_timer_start+0x1fc>)
 8019288:	681b      	ldr	r3, [r3, #0]
 801928a:	687a      	ldr	r2, [r7, #4]
 801928c:	4610      	mov	r0, r2
 801928e:	4798      	blx	r3

    /*
     * get timeout tick,
     * the max timeout tick shall not great than RT_TICK_MAX/2
     */
    RT_ASSERT(timer->init_tick < RT_TICK_MAX / 2);
 8019290:	687b      	ldr	r3, [r7, #4]
 8019292:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8019294:	4a6b      	ldr	r2, [pc, #428]	; (8019444 <rt_timer_start+0x200>)
 8019296:	4293      	cmp	r3, r2
 8019298:	d905      	bls.n	80192a6 <rt_timer_start+0x62>
 801929a:	486b      	ldr	r0, [pc, #428]	; (8019448 <rt_timer_start+0x204>)
 801929c:	4967      	ldr	r1, [pc, #412]	; (801943c <rt_timer_start+0x1f8>)
 801929e:	f44f 72a0 	mov.w	r2, #320	; 0x140
 80192a2:	f7fe fb85 	bl	80179b0 <rt_assert_handler>
    timer->timeout_tick = rt_tick_get() + timer->init_tick;
 80192a6:	f7fc fbc5 	bl	8015a34 <rt_tick_get>
 80192aa:	4602      	mov	r2, r0
 80192ac:	687b      	ldr	r3, [r7, #4]
 80192ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80192b0:	441a      	add	r2, r3
 80192b2:	687b      	ldr	r3, [r7, #4]
 80192b4:	629a      	str	r2, [r3, #40]	; 0x28

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 80192b6:	f7e6 ff87 	bl	80001c8 <rt_hw_interrupt_disable>
 80192ba:	4604      	mov	r4, r0

#ifdef RT_USING_TIMER_SOFT
    if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
 80192bc:	687b      	ldr	r3, [r7, #4]
 80192be:	7a5b      	ldrb	r3, [r3, #9]
 80192c0:	f003 0304 	and.w	r3, r3, #4
 80192c4:	2b00      	cmp	r3, #0
 80192c6:	d002      	beq.n	80192ce <rt_timer_start+0x8a>
    {
        /* insert timer to soft timer list */
        timer_list = rt_soft_timer_list;
 80192c8:	4b60      	ldr	r3, [pc, #384]	; (801944c <rt_timer_start+0x208>)
 80192ca:	61bb      	str	r3, [r7, #24]
 80192cc:	e001      	b.n	80192d2 <rt_timer_start+0x8e>
    }
    else
#endif
    {
        /* insert timer to system timer list */
        timer_list = rt_timer_list;
 80192ce:	4b60      	ldr	r3, [pc, #384]	; (8019450 <rt_timer_start+0x20c>)
 80192d0:	61bb      	str	r3, [r7, #24]
    }

    row_head[0]  = &timer_list[0];
 80192d2:	69bb      	ldr	r3, [r7, #24]
 80192d4:	60bb      	str	r3, [r7, #8]
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
 80192d6:	2300      	movs	r3, #0
 80192d8:	61fb      	str	r3, [r7, #28]
 80192da:	e054      	b.n	8019386 <rt_timer_start+0x142>
    {
        for (;row_head[row_lvl] != timer_list[row_lvl].prev;
 80192dc:	e02e      	b.n	801933c <rt_timer_start+0xf8>
             row_head[row_lvl]  = row_head[row_lvl]->next)
        {
            struct rt_timer *t;
            rt_list_t *p = row_head[row_lvl]->next;
 80192de:	69fb      	ldr	r3, [r7, #28]
 80192e0:	009b      	lsls	r3, r3, #2
 80192e2:	f107 0220 	add.w	r2, r7, #32
 80192e6:	4413      	add	r3, r2
 80192e8:	f853 3c18 	ldr.w	r3, [r3, #-24]
 80192ec:	681b      	ldr	r3, [r3, #0]
 80192ee:	613b      	str	r3, [r7, #16]

            /* fix up the entry pointer */
            t = rt_list_entry(p, struct rt_timer, row[row_lvl]);
 80192f0:	69fb      	ldr	r3, [r7, #28]
 80192f2:	00db      	lsls	r3, r3, #3
 80192f4:	3314      	adds	r3, #20
 80192f6:	425b      	negs	r3, r3
 80192f8:	693a      	ldr	r2, [r7, #16]
 80192fa:	4413      	add	r3, r2
 80192fc:	60fb      	str	r3, [r7, #12]
            /* If we have two timers that timeout at the same time, it's
             * preferred that the timer inserted early get called early.
             * So insert the new timer to the end the the some-timeout timer
             * list.
             */
            if ((t->timeout_tick - timer->timeout_tick) == 0)
 80192fe:	68fb      	ldr	r3, [r7, #12]
 8019300:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8019302:	687b      	ldr	r3, [r7, #4]
 8019304:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8019306:	429a      	cmp	r2, r3
 8019308:	d100      	bne.n	801930c <rt_timer_start+0xc8>
            {
                continue;
 801930a:	e008      	b.n	801931e <rt_timer_start+0xda>
            }
            else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
 801930c:	68fb      	ldr	r3, [r7, #12]
 801930e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8019310:	687b      	ldr	r3, [r7, #4]
 8019312:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8019314:	1ad3      	subs	r3, r2, r3
 8019316:	4a4b      	ldr	r2, [pc, #300]	; (8019444 <rt_timer_start+0x200>)
 8019318:	4293      	cmp	r3, r2
 801931a:	d800      	bhi.n	801931e <rt_timer_start+0xda>
            {
                break;
 801931c:	e01c      	b.n	8019358 <rt_timer_start+0x114>

    row_head[0]  = &timer_list[0];
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    {
        for (;row_head[row_lvl] != timer_list[row_lvl].prev;
             row_head[row_lvl]  = row_head[row_lvl]->next)
 801931e:	69fb      	ldr	r3, [r7, #28]
 8019320:	009b      	lsls	r3, r3, #2
 8019322:	f107 0220 	add.w	r2, r7, #32
 8019326:	4413      	add	r3, r2
 8019328:	f853 3c18 	ldr.w	r3, [r3, #-24]
 801932c:	681a      	ldr	r2, [r3, #0]
 801932e:	69fb      	ldr	r3, [r7, #28]
 8019330:	009b      	lsls	r3, r3, #2
 8019332:	f107 0120 	add.w	r1, r7, #32
 8019336:	440b      	add	r3, r1
 8019338:	f843 2c18 	str.w	r2, [r3, #-24]
    }

    row_head[0]  = &timer_list[0];
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    {
        for (;row_head[row_lvl] != timer_list[row_lvl].prev;
 801933c:	69fb      	ldr	r3, [r7, #28]
 801933e:	009b      	lsls	r3, r3, #2
 8019340:	f107 0220 	add.w	r2, r7, #32
 8019344:	4413      	add	r3, r2
 8019346:	f853 2c18 	ldr.w	r2, [r3, #-24]
 801934a:	69fb      	ldr	r3, [r7, #28]
 801934c:	00db      	lsls	r3, r3, #3
 801934e:	69b9      	ldr	r1, [r7, #24]
 8019350:	440b      	add	r3, r1
 8019352:	685b      	ldr	r3, [r3, #4]
 8019354:	429a      	cmp	r2, r3
 8019356:	d1c2      	bne.n	80192de <rt_timer_start+0x9a>
            else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
            {
                break;
            }
        }
        if (row_lvl != RT_TIMER_SKIP_LIST_LEVEL - 1)
 8019358:	69fb      	ldr	r3, [r7, #28]
 801935a:	2b00      	cmp	r3, #0
 801935c:	d010      	beq.n	8019380 <rt_timer_start+0x13c>
            row_head[row_lvl+1] = row_head[row_lvl]+1;
 801935e:	69fb      	ldr	r3, [r7, #28]
 8019360:	1c59      	adds	r1, r3, #1
 8019362:	69fb      	ldr	r3, [r7, #28]
 8019364:	009b      	lsls	r3, r3, #2
 8019366:	f107 0220 	add.w	r2, r7, #32
 801936a:	4413      	add	r3, r2
 801936c:	f853 3c18 	ldr.w	r3, [r3, #-24]
 8019370:	f103 0208 	add.w	r2, r3, #8
 8019374:	008b      	lsls	r3, r1, #2
 8019376:	f107 0120 	add.w	r1, r7, #32
 801937a:	440b      	add	r3, r1
 801937c:	f843 2c18 	str.w	r2, [r3, #-24]
        /* insert timer to system timer list */
        timer_list = rt_timer_list;
    }

    row_head[0]  = &timer_list[0];
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
 8019380:	69fb      	ldr	r3, [r7, #28]
 8019382:	3301      	adds	r3, #1
 8019384:	61fb      	str	r3, [r7, #28]
 8019386:	69fb      	ldr	r3, [r7, #28]
 8019388:	2b00      	cmp	r3, #0
 801938a:	d0a7      	beq.n	80192dc <rt_timer_start+0x98>

    /* Interestingly, this super simple timer insert counter works very very
     * well on distributing the list height uniformly. By means of "very very
     * well", I mean it beats the randomness of timer->timeout_tick very easily
     * (actually, the timeout_tick is not random and easy to be attacked). */
    random_nr++;
 801938c:	4b31      	ldr	r3, [pc, #196]	; (8019454 <rt_timer_start+0x210>)
 801938e:	681b      	ldr	r3, [r3, #0]
 8019390:	3301      	adds	r3, #1
 8019392:	4a30      	ldr	r2, [pc, #192]	; (8019454 <rt_timer_start+0x210>)
 8019394:	6013      	str	r3, [r2, #0]
    tst_nr = random_nr;
 8019396:	4b2f      	ldr	r3, [pc, #188]	; (8019454 <rt_timer_start+0x210>)
 8019398:	681b      	ldr	r3, [r3, #0]
 801939a:	617b      	str	r3, [r7, #20]

    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
 801939c:	68ba      	ldr	r2, [r7, #8]
 801939e:	687b      	ldr	r3, [r7, #4]
 80193a0:	3314      	adds	r3, #20
 80193a2:	4610      	mov	r0, r2
 80193a4:	4619      	mov	r1, r3
 80193a6:	f7ff fe3d 	bl	8019024 <rt_list_insert_after>
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
 80193aa:	2302      	movs	r3, #2
 80193ac:	61fb      	str	r3, [r7, #28]
 80193ae:	e021      	b.n	80193f4 <rt_timer_start+0x1b0>
    {
        if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
 80193b0:	697b      	ldr	r3, [r7, #20]
 80193b2:	f003 0303 	and.w	r3, r3, #3
 80193b6:	2b00      	cmp	r3, #0
 80193b8:	d115      	bne.n	80193e6 <rt_timer_start+0x1a2>
            rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
 80193ba:	69fb      	ldr	r3, [r7, #28]
 80193bc:	f1c3 0301 	rsb	r3, r3, #1
 80193c0:	009b      	lsls	r3, r3, #2
 80193c2:	f107 0220 	add.w	r2, r7, #32
 80193c6:	4413      	add	r3, r2
 80193c8:	f853 1c18 	ldr.w	r1, [r3, #-24]
                                 &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
 80193cc:	69fb      	ldr	r3, [r7, #28]
 80193ce:	f1c3 0301 	rsb	r3, r3, #1
    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    {
        if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
            rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
 80193d2:	3302      	adds	r3, #2
 80193d4:	00db      	lsls	r3, r3, #3
 80193d6:	687a      	ldr	r2, [r7, #4]
 80193d8:	4413      	add	r3, r2
 80193da:	3304      	adds	r3, #4
 80193dc:	4608      	mov	r0, r1
 80193de:	4619      	mov	r1, r3
 80193e0:	f7ff fe20 	bl	8019024 <rt_list_insert_after>
 80193e4:	e000      	b.n	80193e8 <rt_timer_start+0x1a4>
                                 &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
        else
            break;
 80193e6:	e008      	b.n	80193fa <rt_timer_start+0x1b6>
        /* Shift over the bits we have tested. Works well with 1 bit and 2
         * bits. */
        tst_nr >>= (RT_TIMER_SKIP_LIST_MASK+1)>>1;
 80193e8:	697b      	ldr	r3, [r7, #20]
 80193ea:	089b      	lsrs	r3, r3, #2
 80193ec:	617b      	str	r3, [r7, #20]
    random_nr++;
    tst_nr = random_nr;

    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
 80193ee:	69fb      	ldr	r3, [r7, #28]
 80193f0:	3301      	adds	r3, #1
 80193f2:	61fb      	str	r3, [r7, #28]
 80193f4:	69fb      	ldr	r3, [r7, #28]
 80193f6:	2b01      	cmp	r3, #1
 80193f8:	d9da      	bls.n	80193b0 <rt_timer_start+0x16c>
        /* Shift over the bits we have tested. Works well with 1 bit and 2
         * bits. */
        tst_nr >>= (RT_TIMER_SKIP_LIST_MASK+1)>>1;
    }

    timer->parent.flag |= RT_TIMER_FLAG_ACTIVATED;
 80193fa:	687b      	ldr	r3, [r7, #4]
 80193fc:	7a5b      	ldrb	r3, [r3, #9]
 80193fe:	f043 0301 	orr.w	r3, r3, #1
 8019402:	b2da      	uxtb	r2, r3
 8019404:	687b      	ldr	r3, [r7, #4]
 8019406:	725a      	strb	r2, [r3, #9]

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 8019408:	4620      	mov	r0, r4
 801940a:	f7e6 fee1 	bl	80001d0 <rt_hw_interrupt_enable>

#ifdef RT_USING_TIMER_SOFT
    if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
 801940e:	687b      	ldr	r3, [r7, #4]
 8019410:	7a5b      	ldrb	r3, [r3, #9]
 8019412:	f003 0304 	and.w	r3, r3, #4
 8019416:	2b00      	cmp	r3, #0
 8019418:	d009      	beq.n	801942e <rt_timer_start+0x1ea>
    {
        /* check whether timer thread is ready */
        if (timer_thread.stat != RT_THREAD_READY)
 801941a:	4b0f      	ldr	r3, [pc, #60]	; (8019458 <rt_timer_start+0x214>)
 801941c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8019420:	2b01      	cmp	r3, #1
 8019422:	d004      	beq.n	801942e <rt_timer_start+0x1ea>
        {
            /* resume timer thread to check soft timer */
            rt_thread_resume(&timer_thread);
 8019424:	480c      	ldr	r0, [pc, #48]	; (8019458 <rt_timer_start+0x214>)
 8019426:	f7ff fd89 	bl	8018f3c <rt_thread_resume>
            rt_schedule();
 801942a:	f7ff f995 	bl	8018758 <rt_schedule>
        }
    }
#endif

    return -RT_EOK;
 801942e:	2300      	movs	r3, #0
}
 8019430:	4618      	mov	r0, r3
 8019432:	3724      	adds	r7, #36	; 0x24
 8019434:	46bd      	mov	sp, r7
 8019436:	bd90      	pop	{r4, r7, pc}
 8019438:	08027c5c 	.word	0x08027c5c
 801943c:	0802925c 	.word	0x0802925c
 8019440:	20012a44 	.word	0x20012a44
 8019444:	7ffffffe 	.word	0x7ffffffe
 8019448:	08027c70 	.word	0x08027c70
 801944c:	20010db0 	.word	0x20010db0
 8019450:	20010da8 	.word	0x20010da8
 8019454:	2001103c 	.word	0x2001103c
 8019458:	20010db8 	.word	0x20010db8

0801945c <rt_timer_stop>:
 * @param timer the timer to be stopped
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_timer_stop(rt_timer_t timer)
{
 801945c:	b590      	push	{r4, r7, lr}
 801945e:	b083      	sub	sp, #12
 8019460:	af00      	add	r7, sp, #0
 8019462:	6078      	str	r0, [r7, #4]
    register rt_base_t level;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
 8019464:	687b      	ldr	r3, [r7, #4]
 8019466:	2b00      	cmp	r3, #0
 8019468:	d105      	bne.n	8019476 <rt_timer_stop+0x1a>
 801946a:	4816      	ldr	r0, [pc, #88]	; (80194c4 <rt_timer_stop+0x68>)
 801946c:	4916      	ldr	r1, [pc, #88]	; (80194c8 <rt_timer_stop+0x6c>)
 801946e:	f44f 72d4 	mov.w	r2, #424	; 0x1a8
 8019472:	f7fe fa9d 	bl	80179b0 <rt_assert_handler>
    if (!(timer->parent.flag & RT_TIMER_FLAG_ACTIVATED))
 8019476:	687b      	ldr	r3, [r7, #4]
 8019478:	7a5b      	ldrb	r3, [r3, #9]
 801947a:	f003 0301 	and.w	r3, r3, #1
 801947e:	2b00      	cmp	r3, #0
 8019480:	d102      	bne.n	8019488 <rt_timer_stop+0x2c>
        return -RT_ERROR;
 8019482:	f04f 33ff 	mov.w	r3, #4294967295
 8019486:	e019      	b.n	80194bc <rt_timer_stop+0x60>

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(timer->parent)));
 8019488:	4b10      	ldr	r3, [pc, #64]	; (80194cc <rt_timer_stop+0x70>)
 801948a:	681b      	ldr	r3, [r3, #0]
 801948c:	2b00      	cmp	r3, #0
 801948e:	d004      	beq.n	801949a <rt_timer_stop+0x3e>
 8019490:	4b0e      	ldr	r3, [pc, #56]	; (80194cc <rt_timer_stop+0x70>)
 8019492:	681b      	ldr	r3, [r3, #0]
 8019494:	687a      	ldr	r2, [r7, #4]
 8019496:	4610      	mov	r0, r2
 8019498:	4798      	blx	r3

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 801949a:	f7e6 fe95 	bl	80001c8 <rt_hw_interrupt_disable>
 801949e:	4604      	mov	r4, r0

    _rt_timer_remove(timer);
 80194a0:	6878      	ldr	r0, [r7, #4]
 80194a2:	f7ff fe4f 	bl	8019144 <_rt_timer_remove>

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 80194a6:	4620      	mov	r0, r4
 80194a8:	f7e6 fe92 	bl	80001d0 <rt_hw_interrupt_enable>

    /* change stat */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 80194ac:	687b      	ldr	r3, [r7, #4]
 80194ae:	7a5b      	ldrb	r3, [r3, #9]
 80194b0:	f023 0301 	bic.w	r3, r3, #1
 80194b4:	b2da      	uxtb	r2, r3
 80194b6:	687b      	ldr	r3, [r7, #4]
 80194b8:	725a      	strb	r2, [r3, #9]

    return RT_EOK;
 80194ba:	2300      	movs	r3, #0
}
 80194bc:	4618      	mov	r0, r3
 80194be:	370c      	adds	r7, #12
 80194c0:	46bd      	mov	sp, r7
 80194c2:	bd90      	pop	{r4, r7, pc}
 80194c4:	08027c5c 	.word	0x08027c5c
 80194c8:	0802926c 	.word	0x0802926c
 80194cc:	20012a40 	.word	0x20012a40

080194d0 <rt_timer_control>:
 * @param arg the argument
 *
 * @return RT_EOK
 */
rt_err_t rt_timer_control(rt_timer_t timer, rt_uint8_t cmd, void *arg)
{
 80194d0:	b580      	push	{r7, lr}
 80194d2:	b084      	sub	sp, #16
 80194d4:	af00      	add	r7, sp, #0
 80194d6:	60f8      	str	r0, [r7, #12]
 80194d8:	460b      	mov	r3, r1
 80194da:	607a      	str	r2, [r7, #4]
 80194dc:	72fb      	strb	r3, [r7, #11]
    /* timer check */
    RT_ASSERT(timer != RT_NULL);
 80194de:	68fb      	ldr	r3, [r7, #12]
 80194e0:	2b00      	cmp	r3, #0
 80194e2:	d105      	bne.n	80194f0 <rt_timer_control+0x20>
 80194e4:	4819      	ldr	r0, [pc, #100]	; (801954c <rt_timer_control+0x7c>)
 80194e6:	491a      	ldr	r1, [pc, #104]	; (8019550 <rt_timer_control+0x80>)
 80194e8:	f240 12c9 	movw	r2, #457	; 0x1c9
 80194ec:	f7fe fa60 	bl	80179b0 <rt_assert_handler>

    switch (cmd)
 80194f0:	7afb      	ldrb	r3, [r7, #11]
 80194f2:	2b03      	cmp	r3, #3
 80194f4:	d824      	bhi.n	8019540 <rt_timer_control+0x70>
 80194f6:	a201      	add	r2, pc, #4	; (adr r2, 80194fc <rt_timer_control+0x2c>)
 80194f8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80194fc:	08019517 	.word	0x08019517
 8019500:	0801950d 	.word	0x0801950d
 8019504:	08019521 	.word	0x08019521
 8019508:	08019531 	.word	0x08019531
    {
    case RT_TIMER_CTRL_GET_TIME:
        *(rt_tick_t *)arg = timer->init_tick;
 801950c:	68fb      	ldr	r3, [r7, #12]
 801950e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8019510:	687b      	ldr	r3, [r7, #4]
 8019512:	601a      	str	r2, [r3, #0]
        break;
 8019514:	e014      	b.n	8019540 <rt_timer_control+0x70>

    case RT_TIMER_CTRL_SET_TIME:
        timer->init_tick = *(rt_tick_t *)arg;
 8019516:	687b      	ldr	r3, [r7, #4]
 8019518:	681a      	ldr	r2, [r3, #0]
 801951a:	68fb      	ldr	r3, [r7, #12]
 801951c:	625a      	str	r2, [r3, #36]	; 0x24
        break;
 801951e:	e00f      	b.n	8019540 <rt_timer_control+0x70>

    case RT_TIMER_CTRL_SET_ONESHOT:
        timer->parent.flag &= ~RT_TIMER_FLAG_PERIODIC;
 8019520:	68fb      	ldr	r3, [r7, #12]
 8019522:	7a5b      	ldrb	r3, [r3, #9]
 8019524:	f023 0302 	bic.w	r3, r3, #2
 8019528:	b2da      	uxtb	r2, r3
 801952a:	68fb      	ldr	r3, [r7, #12]
 801952c:	725a      	strb	r2, [r3, #9]
        break;
 801952e:	e007      	b.n	8019540 <rt_timer_control+0x70>

    case RT_TIMER_CTRL_SET_PERIODIC:
        timer->parent.flag |= RT_TIMER_FLAG_PERIODIC;
 8019530:	68fb      	ldr	r3, [r7, #12]
 8019532:	7a5b      	ldrb	r3, [r3, #9]
 8019534:	f043 0302 	orr.w	r3, r3, #2
 8019538:	b2da      	uxtb	r2, r3
 801953a:	68fb      	ldr	r3, [r7, #12]
 801953c:	725a      	strb	r2, [r3, #9]
        break;
 801953e:	bf00      	nop
    }

    return RT_EOK;
 8019540:	2300      	movs	r3, #0
}
 8019542:	4618      	mov	r0, r3
 8019544:	3710      	adds	r7, #16
 8019546:	46bd      	mov	sp, r7
 8019548:	bd80      	pop	{r7, pc}
 801954a:	bf00      	nop
 801954c:	08027c5c 	.word	0x08027c5c
 8019550:	0802927c 	.word	0x0802927c

08019554 <rt_timer_check>:
 * corresponding timeout function will be invoked.
 *
 * @note this function shall be invoked in operating system timer interrupt.
 */
void rt_timer_check(void)
{
 8019554:	b590      	push	{r4, r7, lr}
 8019556:	b083      	sub	sp, #12
 8019558:	af00      	add	r7, sp, #0
    rt_tick_t current_tick;
    register rt_base_t level;

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check enter\n"));

    current_tick = rt_tick_get();
 801955a:	f7fc fa6b 	bl	8015a34 <rt_tick_get>
 801955e:	6078      	str	r0, [r7, #4]

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 8019560:	f7e6 fe32 	bl	80001c8 <rt_hw_interrupt_disable>
 8019564:	4604      	mov	r4, r0

    while (!rt_list_isempty(&rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1]))
 8019566:	e03e      	b.n	80195e6 <rt_timer_check+0x92>
    {
        t = rt_list_entry(rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
 8019568:	4b25      	ldr	r3, [pc, #148]	; (8019600 <rt_timer_check+0xac>)
 801956a:	681b      	ldr	r3, [r3, #0]
 801956c:	3b14      	subs	r3, #20
 801956e:	603b      	str	r3, [r7, #0]

        /*
         * It supposes that the new tick shall less than the half duration of
         * tick max.
         */
        if ((current_tick - t->timeout_tick) < RT_TICK_MAX/2)
 8019570:	683b      	ldr	r3, [r7, #0]
 8019572:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8019574:	687a      	ldr	r2, [r7, #4]
 8019576:	1ad3      	subs	r3, r2, r3
 8019578:	4a22      	ldr	r2, [pc, #136]	; (8019604 <rt_timer_check+0xb0>)
 801957a:	4293      	cmp	r3, r2
 801957c:	d832      	bhi.n	80195e4 <rt_timer_check+0x90>
        {
            RT_OBJECT_HOOK_CALL(rt_timer_timeout_hook, (t));
 801957e:	4b22      	ldr	r3, [pc, #136]	; (8019608 <rt_timer_check+0xb4>)
 8019580:	681b      	ldr	r3, [r3, #0]
 8019582:	2b00      	cmp	r3, #0
 8019584:	d003      	beq.n	801958e <rt_timer_check+0x3a>
 8019586:	4b20      	ldr	r3, [pc, #128]	; (8019608 <rt_timer_check+0xb4>)
 8019588:	681b      	ldr	r3, [r3, #0]
 801958a:	6838      	ldr	r0, [r7, #0]
 801958c:	4798      	blx	r3

            /* remove timer from timer list firstly */
            _rt_timer_remove(t);
 801958e:	6838      	ldr	r0, [r7, #0]
 8019590:	f7ff fdd8 	bl	8019144 <_rt_timer_remove>

            /* call timeout function */
            t->timeout_func(t->parameter);
 8019594:	683b      	ldr	r3, [r7, #0]
 8019596:	69db      	ldr	r3, [r3, #28]
 8019598:	683a      	ldr	r2, [r7, #0]
 801959a:	6a12      	ldr	r2, [r2, #32]
 801959c:	4610      	mov	r0, r2
 801959e:	4798      	blx	r3

            /* re-get tick */
            current_tick = rt_tick_get();
 80195a0:	f7fc fa48 	bl	8015a34 <rt_tick_get>
 80195a4:	6078      	str	r0, [r7, #4]

            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
 80195a6:	683b      	ldr	r3, [r7, #0]
 80195a8:	7a5b      	ldrb	r3, [r3, #9]
 80195aa:	f003 0302 	and.w	r3, r3, #2
 80195ae:	2b00      	cmp	r3, #0
 80195b0:	d010      	beq.n	80195d4 <rt_timer_check+0x80>
                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
 80195b2:	683b      	ldr	r3, [r7, #0]
 80195b4:	7a5b      	ldrb	r3, [r3, #9]
 80195b6:	f003 0301 	and.w	r3, r3, #1
            /* re-get tick */
            current_tick = rt_tick_get();

            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
 80195ba:	2b00      	cmp	r3, #0
 80195bc:	d00a      	beq.n	80195d4 <rt_timer_check+0x80>
                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
            {
                /* start it */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 80195be:	683b      	ldr	r3, [r7, #0]
 80195c0:	7a5b      	ldrb	r3, [r3, #9]
 80195c2:	f023 0301 	bic.w	r3, r3, #1
 80195c6:	b2da      	uxtb	r2, r3
 80195c8:	683b      	ldr	r3, [r7, #0]
 80195ca:	725a      	strb	r2, [r3, #9]
                rt_timer_start(t);
 80195cc:	6838      	ldr	r0, [r7, #0]
 80195ce:	f7ff fe39 	bl	8019244 <rt_timer_start>
 80195d2:	e006      	b.n	80195e2 <rt_timer_check+0x8e>
            }
            else
            {
                /* stop timer */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 80195d4:	683b      	ldr	r3, [r7, #0]
 80195d6:	7a5b      	ldrb	r3, [r3, #9]
 80195d8:	f023 0301 	bic.w	r3, r3, #1
 80195dc:	b2da      	uxtb	r2, r3
 80195de:	683b      	ldr	r3, [r7, #0]
 80195e0:	725a      	strb	r2, [r3, #9]
 80195e2:	e000      	b.n	80195e6 <rt_timer_check+0x92>
            }
        }
        else
            break;
 80195e4:	e005      	b.n	80195f2 <rt_timer_check+0x9e>
    current_tick = rt_tick_get();

    /* disable interrupt */
    level = rt_hw_interrupt_disable();

    while (!rt_list_isempty(&rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1]))
 80195e6:	4806      	ldr	r0, [pc, #24]	; (8019600 <rt_timer_check+0xac>)
 80195e8:	f7ff fd4e 	bl	8019088 <rt_list_isempty>
 80195ec:	4603      	mov	r3, r0
 80195ee:	2b00      	cmp	r3, #0
 80195f0:	d0ba      	beq.n	8019568 <rt_timer_check+0x14>
        else
            break;
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 80195f2:	4620      	mov	r0, r4
 80195f4:	f7e6 fdec 	bl	80001d0 <rt_hw_interrupt_enable>

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check leave\n"));
}
 80195f8:	370c      	adds	r7, #12
 80195fa:	46bd      	mov	sp, r7
 80195fc:	bd90      	pop	{r4, r7, pc}
 80195fe:	bf00      	nop
 8019600:	20010da8 	.word	0x20010da8
 8019604:	7ffffffe 	.word	0x7ffffffe
 8019608:	20011038 	.word	0x20011038

0801960c <rt_soft_timer_check>:
/**
 * This function will check timer list, if a timeout event happens, the
 * corresponding timeout function will be invoked.
 */
void rt_soft_timer_check(void)
{
 801960c:	b580      	push	{r7, lr}
 801960e:	b084      	sub	sp, #16
 8019610:	af00      	add	r7, sp, #0
    rt_list_t *n;
    struct rt_timer *t;

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("software timer check enter\n"));

    current_tick = rt_tick_get();
 8019612:	f7fc fa0f 	bl	8015a34 <rt_tick_get>
 8019616:	60f8      	str	r0, [r7, #12]

	/* lock scheduler */
	rt_enter_critical();
 8019618:	f7ff f96a 	bl	80188f0 <rt_enter_critical>

    for (n = rt_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1].next;
 801961c:	4b28      	ldr	r3, [pc, #160]	; (80196c0 <rt_soft_timer_check+0xb4>)
 801961e:	681b      	ldr	r3, [r3, #0]
 8019620:	60bb      	str	r3, [r7, #8]
 8019622:	e044      	b.n	80196ae <rt_soft_timer_check+0xa2>
         n != &(rt_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1]);)
    {
        t = rt_list_entry(n, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL-1]);
 8019624:	68bb      	ldr	r3, [r7, #8]
 8019626:	3b14      	subs	r3, #20
 8019628:	607b      	str	r3, [r7, #4]

        /*
         * It supposes that the new tick shall less than the half duration of
         * tick max.
         */
        if ((current_tick - t->timeout_tick) < RT_TICK_MAX / 2)
 801962a:	687b      	ldr	r3, [r7, #4]
 801962c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801962e:	68fa      	ldr	r2, [r7, #12]
 8019630:	1ad3      	subs	r3, r2, r3
 8019632:	4a24      	ldr	r2, [pc, #144]	; (80196c4 <rt_soft_timer_check+0xb8>)
 8019634:	4293      	cmp	r3, r2
 8019636:	d839      	bhi.n	80196ac <rt_soft_timer_check+0xa0>
        {
            RT_OBJECT_HOOK_CALL(rt_timer_timeout_hook, (t));
 8019638:	4b23      	ldr	r3, [pc, #140]	; (80196c8 <rt_soft_timer_check+0xbc>)
 801963a:	681b      	ldr	r3, [r3, #0]
 801963c:	2b00      	cmp	r3, #0
 801963e:	d003      	beq.n	8019648 <rt_soft_timer_check+0x3c>
 8019640:	4b21      	ldr	r3, [pc, #132]	; (80196c8 <rt_soft_timer_check+0xbc>)
 8019642:	681b      	ldr	r3, [r3, #0]
 8019644:	6878      	ldr	r0, [r7, #4]
 8019646:	4798      	blx	r3

            /* move node to the next */
            n = n->next;
 8019648:	68bb      	ldr	r3, [r7, #8]
 801964a:	681b      	ldr	r3, [r3, #0]
 801964c:	60bb      	str	r3, [r7, #8]

            /* remove timer from timer list firstly */
            _rt_timer_remove(t);
 801964e:	6878      	ldr	r0, [r7, #4]
 8019650:	f7ff fd78 	bl	8019144 <_rt_timer_remove>

			/* not lock scheduler when performing timeout function */
			rt_exit_critical();
 8019654:	f7ff f960 	bl	8018918 <rt_exit_critical>
            /* call timeout function */
            t->timeout_func(t->parameter);
 8019658:	687b      	ldr	r3, [r7, #4]
 801965a:	69db      	ldr	r3, [r3, #28]
 801965c:	687a      	ldr	r2, [r7, #4]
 801965e:	6a12      	ldr	r2, [r2, #32]
 8019660:	4610      	mov	r0, r2
 8019662:	4798      	blx	r3

            /* re-get tick */
            current_tick = rt_tick_get();
 8019664:	f7fc f9e6 	bl	8015a34 <rt_tick_get>
 8019668:	60f8      	str	r0, [r7, #12]

            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

			/* lock scheduler */
			rt_enter_critical();
 801966a:	f7ff f941 	bl	80188f0 <rt_enter_critical>

            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
 801966e:	687b      	ldr	r3, [r7, #4]
 8019670:	7a5b      	ldrb	r3, [r3, #9]
 8019672:	f003 0302 	and.w	r3, r3, #2
 8019676:	2b00      	cmp	r3, #0
 8019678:	d010      	beq.n	801969c <rt_soft_timer_check+0x90>
                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
 801967a:	687b      	ldr	r3, [r7, #4]
 801967c:	7a5b      	ldrb	r3, [r3, #9]
 801967e:	f003 0301 	and.w	r3, r3, #1
            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

			/* lock scheduler */
			rt_enter_critical();

            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
 8019682:	2b00      	cmp	r3, #0
 8019684:	d00a      	beq.n	801969c <rt_soft_timer_check+0x90>
                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
            {
                /* start it */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 8019686:	687b      	ldr	r3, [r7, #4]
 8019688:	7a5b      	ldrb	r3, [r3, #9]
 801968a:	f023 0301 	bic.w	r3, r3, #1
 801968e:	b2da      	uxtb	r2, r3
 8019690:	687b      	ldr	r3, [r7, #4]
 8019692:	725a      	strb	r2, [r3, #9]
                rt_timer_start(t);
 8019694:	6878      	ldr	r0, [r7, #4]
 8019696:	f7ff fdd5 	bl	8019244 <rt_timer_start>
 801969a:	e006      	b.n	80196aa <rt_soft_timer_check+0x9e>
            }
            else
            {
                /* stop timer */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 801969c:	687b      	ldr	r3, [r7, #4]
 801969e:	7a5b      	ldrb	r3, [r3, #9]
 80196a0:	f023 0301 	bic.w	r3, r3, #1
 80196a4:	b2da      	uxtb	r2, r3
 80196a6:	687b      	ldr	r3, [r7, #4]
 80196a8:	725a      	strb	r2, [r3, #9]
 80196aa:	e000      	b.n	80196ae <rt_soft_timer_check+0xa2>
            }
        }
        else break; /* not check anymore */
 80196ac:	e003      	b.n	80196b6 <rt_soft_timer_check+0xaa>
    current_tick = rt_tick_get();

	/* lock scheduler */
	rt_enter_critical();

    for (n = rt_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1].next;
 80196ae:	68bb      	ldr	r3, [r7, #8]
 80196b0:	4a03      	ldr	r2, [pc, #12]	; (80196c0 <rt_soft_timer_check+0xb4>)
 80196b2:	4293      	cmp	r3, r2
 80196b4:	d1b6      	bne.n	8019624 <rt_soft_timer_check+0x18>
        }
        else break; /* not check anymore */
    }

	/* unlock scheduler */
	rt_exit_critical();
 80196b6:	f7ff f92f 	bl	8018918 <rt_exit_critical>

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("software timer check leave\n"));
}
 80196ba:	3710      	adds	r7, #16
 80196bc:	46bd      	mov	sp, r7
 80196be:	bd80      	pop	{r7, pc}
 80196c0:	20010db0 	.word	0x20010db0
 80196c4:	7ffffffe 	.word	0x7ffffffe
 80196c8:	20011038 	.word	0x20011038

080196cc <rt_thread_timer_entry>:

/* system timer thread entry */
static void rt_thread_timer_entry(void *parameter)
{
 80196cc:	b580      	push	{r7, lr}
 80196ce:	b084      	sub	sp, #16
 80196d0:	af00      	add	r7, sp, #0
 80196d2:	6078      	str	r0, [r7, #4]
    rt_tick_t next_timeout;

    while (1)
    {
        /* get the next timeout tick */
        next_timeout = rt_timer_list_next_timeout(rt_soft_timer_list);
 80196d4:	4811      	ldr	r0, [pc, #68]	; (801971c <rt_thread_timer_entry+0x50>)
 80196d6:	f7ff fd1d 	bl	8019114 <rt_timer_list_next_timeout>
 80196da:	60f8      	str	r0, [r7, #12]
        if (next_timeout == RT_TICK_MAX)
 80196dc:	68fb      	ldr	r3, [r7, #12]
 80196de:	f1b3 3fff 	cmp.w	r3, #4294967295
 80196e2:	d108      	bne.n	80196f6 <rt_thread_timer_entry+0x2a>
        {
            /* no software timer exist, suspend self. */
            rt_thread_suspend(rt_thread_self());
 80196e4:	f7ff fa74 	bl	8018bd0 <rt_thread_self>
 80196e8:	4603      	mov	r3, r0
 80196ea:	4618      	mov	r0, r3
 80196ec:	f7ff fbf6 	bl	8018edc <rt_thread_suspend>
            rt_schedule();
 80196f0:	f7ff f832 	bl	8018758 <rt_schedule>
 80196f4:	e00f      	b.n	8019716 <rt_thread_timer_entry+0x4a>
        else
        {
            rt_tick_t current_tick;

            /* get current tick */
            current_tick = rt_tick_get();
 80196f6:	f7fc f99d 	bl	8015a34 <rt_tick_get>
 80196fa:	60b8      	str	r0, [r7, #8]

            if ((next_timeout - current_tick) < RT_TICK_MAX/2)
 80196fc:	68fa      	ldr	r2, [r7, #12]
 80196fe:	68bb      	ldr	r3, [r7, #8]
 8019700:	1ad3      	subs	r3, r2, r3
 8019702:	4a07      	ldr	r2, [pc, #28]	; (8019720 <rt_thread_timer_entry+0x54>)
 8019704:	4293      	cmp	r3, r2
 8019706:	d806      	bhi.n	8019716 <rt_thread_timer_entry+0x4a>
            {
                /* get the delta timeout tick */
                next_timeout = next_timeout - current_tick;
 8019708:	68fa      	ldr	r2, [r7, #12]
 801970a:	68bb      	ldr	r3, [r7, #8]
 801970c:	1ad3      	subs	r3, r2, r3
 801970e:	60fb      	str	r3, [r7, #12]
                rt_thread_delay(next_timeout);
 8019710:	68f8      	ldr	r0, [r7, #12]
 8019712:	f7ff fb7d 	bl	8018e10 <rt_thread_delay>
            }
        }

        /* check software timer */
        rt_soft_timer_check();
 8019716:	f7ff ff79 	bl	801960c <rt_soft_timer_check>
    }
 801971a:	e7db      	b.n	80196d4 <rt_thread_timer_entry+0x8>
 801971c:	20010db0 	.word	0x20010db0
 8019720:	7ffffffe 	.word	0x7ffffffe

08019724 <rt_system_timer_init>:
 * @ingroup SystemInit
 *
 * This function will initialize system timer
 */
void rt_system_timer_init(void)
{
 8019724:	b580      	push	{r7, lr}
 8019726:	b082      	sub	sp, #8
 8019728:	af00      	add	r7, sp, #0
    int i;

    for (i = 0; i < sizeof(rt_timer_list)/sizeof(rt_timer_list[0]); i++)
 801972a:	2300      	movs	r3, #0
 801972c:	607b      	str	r3, [r7, #4]
 801972e:	e009      	b.n	8019744 <rt_system_timer_init+0x20>
    {
        rt_list_init(rt_timer_list+i);
 8019730:	687b      	ldr	r3, [r7, #4]
 8019732:	00db      	lsls	r3, r3, #3
 8019734:	4a06      	ldr	r2, [pc, #24]	; (8019750 <rt_system_timer_init+0x2c>)
 8019736:	4413      	add	r3, r2
 8019738:	4618      	mov	r0, r3
 801973a:	f7ff fc63 	bl	8019004 <rt_list_init>
 */
void rt_system_timer_init(void)
{
    int i;

    for (i = 0; i < sizeof(rt_timer_list)/sizeof(rt_timer_list[0]); i++)
 801973e:	687b      	ldr	r3, [r7, #4]
 8019740:	3301      	adds	r3, #1
 8019742:	607b      	str	r3, [r7, #4]
 8019744:	687b      	ldr	r3, [r7, #4]
 8019746:	2b00      	cmp	r3, #0
 8019748:	d0f2      	beq.n	8019730 <rt_system_timer_init+0xc>
    {
        rt_list_init(rt_timer_list+i);
    }
}
 801974a:	3708      	adds	r7, #8
 801974c:	46bd      	mov	sp, r7
 801974e:	bd80      	pop	{r7, pc}
 8019750:	20010da8 	.word	0x20010da8

08019754 <rt_system_timer_thread_init>:
 * @ingroup SystemInit
 *
 * This function will initialize system timer thread
 */
void rt_system_timer_thread_init(void)
{
 8019754:	b580      	push	{r7, lr}
 8019756:	b086      	sub	sp, #24
 8019758:	af04      	add	r7, sp, #16
#ifdef RT_USING_TIMER_SOFT
    int i;

    for (i = 0;
 801975a:	2300      	movs	r3, #0
 801975c:	607b      	str	r3, [r7, #4]
 801975e:	e009      	b.n	8019774 <rt_system_timer_thread_init+0x20>
         i < sizeof(rt_soft_timer_list)/sizeof(rt_soft_timer_list[0]);
         i++)
    {
        rt_list_init(rt_soft_timer_list+i);
 8019760:	687b      	ldr	r3, [r7, #4]
 8019762:	00db      	lsls	r3, r3, #3
 8019764:	4a0f      	ldr	r2, [pc, #60]	; (80197a4 <rt_system_timer_thread_init+0x50>)
 8019766:	4413      	add	r3, r2
 8019768:	4618      	mov	r0, r3
 801976a:	f7ff fc4b 	bl	8019004 <rt_list_init>
#ifdef RT_USING_TIMER_SOFT
    int i;

    for (i = 0;
         i < sizeof(rt_soft_timer_list)/sizeof(rt_soft_timer_list[0]);
         i++)
 801976e:	687b      	ldr	r3, [r7, #4]
 8019770:	3301      	adds	r3, #1
 8019772:	607b      	str	r3, [r7, #4]
void rt_system_timer_thread_init(void)
{
#ifdef RT_USING_TIMER_SOFT
    int i;

    for (i = 0;
 8019774:	687b      	ldr	r3, [r7, #4]
 8019776:	2b00      	cmp	r3, #0
 8019778:	d0f2      	beq.n	8019760 <rt_system_timer_thread_init+0xc>
    {
        rt_list_init(rt_soft_timer_list+i);
    }

    /* start software timer thread */
    rt_thread_init(&timer_thread,
 801977a:	4b0b      	ldr	r3, [pc, #44]	; (80197a8 <rt_system_timer_thread_init+0x54>)
 801977c:	9300      	str	r3, [sp, #0]
 801977e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8019782:	9301      	str	r3, [sp, #4]
 8019784:	2304      	movs	r3, #4
 8019786:	9302      	str	r3, [sp, #8]
 8019788:	230a      	movs	r3, #10
 801978a:	9303      	str	r3, [sp, #12]
 801978c:	4807      	ldr	r0, [pc, #28]	; (80197ac <rt_system_timer_thread_init+0x58>)
 801978e:	4908      	ldr	r1, [pc, #32]	; (80197b0 <rt_system_timer_thread_init+0x5c>)
 8019790:	4a08      	ldr	r2, [pc, #32]	; (80197b4 <rt_system_timer_thread_init+0x60>)
 8019792:	2300      	movs	r3, #0
 8019794:	f7ff f9e6 	bl	8018b64 <rt_thread_init>
                   sizeof(timer_thread_stack),
                   RT_TIMER_THREAD_PRIO,
                   10);

    /* startup */
    rt_thread_startup(&timer_thread);
 8019798:	4804      	ldr	r0, [pc, #16]	; (80197ac <rt_system_timer_thread_init+0x58>)
 801979a:	f7ff fa25 	bl	8018be8 <rt_thread_startup>
#endif
}
 801979e:	3708      	adds	r7, #8
 80197a0:	46bd      	mov	sp, r7
 80197a2:	bd80      	pop	{r7, pc}
 80197a4:	20010db0 	.word	0x20010db0
 80197a8:	20010e38 	.word	0x20010e38
 80197ac:	20010db8 	.word	0x20010db8
 80197b0:	08027c94 	.word	0x08027c94
 80197b4:	080196cd 	.word	0x080196cd

080197b8 <rt_hw_stack_init>:

rt_uint8_t *rt_hw_stack_init(void       *tentry,
                             void       *parameter,
                             rt_uint8_t *stack_addr,
                             void       *texit)
{
 80197b8:	b480      	push	{r7}
 80197ba:	b089      	sub	sp, #36	; 0x24
 80197bc:	af00      	add	r7, sp, #0
 80197be:	60f8      	str	r0, [r7, #12]
 80197c0:	60b9      	str	r1, [r7, #8]
 80197c2:	607a      	str	r2, [r7, #4]
 80197c4:	603b      	str	r3, [r7, #0]
    struct stack_frame *stack_frame;
    rt_uint8_t         *stk;
    unsigned long       i;

    stk  = stack_addr + sizeof(rt_uint32_t);
 80197c6:	687b      	ldr	r3, [r7, #4]
 80197c8:	3304      	adds	r3, #4
 80197ca:	61bb      	str	r3, [r7, #24]
    stk  = (rt_uint8_t *)RT_ALIGN_DOWN((rt_uint32_t)stk, 8);
 80197cc:	69bb      	ldr	r3, [r7, #24]
 80197ce:	f023 0307 	bic.w	r3, r3, #7
 80197d2:	61bb      	str	r3, [r7, #24]
    stk -= sizeof(struct stack_frame);
 80197d4:	69bb      	ldr	r3, [r7, #24]
 80197d6:	3b44      	subs	r3, #68	; 0x44
 80197d8:	61bb      	str	r3, [r7, #24]

    stack_frame = (struct stack_frame *)stk;
 80197da:	69bb      	ldr	r3, [r7, #24]
 80197dc:	617b      	str	r3, [r7, #20]

    /* init all register */
    for (i = 0; i < sizeof(struct stack_frame) / sizeof(rt_uint32_t); i ++)
 80197de:	2300      	movs	r3, #0
 80197e0:	61fb      	str	r3, [r7, #28]
 80197e2:	e008      	b.n	80197f6 <rt_hw_stack_init+0x3e>
    {
        ((rt_uint32_t *)stack_frame)[i] = 0xdeadbeef;
 80197e4:	69fb      	ldr	r3, [r7, #28]
 80197e6:	009b      	lsls	r3, r3, #2
 80197e8:	697a      	ldr	r2, [r7, #20]
 80197ea:	4413      	add	r3, r2
 80197ec:	4a15      	ldr	r2, [pc, #84]	; (8019844 <rt_hw_stack_init+0x8c>)
 80197ee:	601a      	str	r2, [r3, #0]
    stk -= sizeof(struct stack_frame);

    stack_frame = (struct stack_frame *)stk;

    /* init all register */
    for (i = 0; i < sizeof(struct stack_frame) / sizeof(rt_uint32_t); i ++)
 80197f0:	69fb      	ldr	r3, [r7, #28]
 80197f2:	3301      	adds	r3, #1
 80197f4:	61fb      	str	r3, [r7, #28]
 80197f6:	69fb      	ldr	r3, [r7, #28]
 80197f8:	2b10      	cmp	r3, #16
 80197fa:	d9f3      	bls.n	80197e4 <rt_hw_stack_init+0x2c>
    {
        ((rt_uint32_t *)stack_frame)[i] = 0xdeadbeef;
    }

    stack_frame->exception_stack_frame.r0  = (unsigned long)parameter; /* r0 : argument */
 80197fc:	68ba      	ldr	r2, [r7, #8]
 80197fe:	697b      	ldr	r3, [r7, #20]
 8019800:	625a      	str	r2, [r3, #36]	; 0x24
    stack_frame->exception_stack_frame.r1  = 0;                        /* r1 */
 8019802:	697b      	ldr	r3, [r7, #20]
 8019804:	2200      	movs	r2, #0
 8019806:	629a      	str	r2, [r3, #40]	; 0x28
    stack_frame->exception_stack_frame.r2  = 0;                        /* r2 */
 8019808:	697b      	ldr	r3, [r7, #20]
 801980a:	2200      	movs	r2, #0
 801980c:	62da      	str	r2, [r3, #44]	; 0x2c
    stack_frame->exception_stack_frame.r3  = 0;                        /* r3 */
 801980e:	697b      	ldr	r3, [r7, #20]
 8019810:	2200      	movs	r2, #0
 8019812:	631a      	str	r2, [r3, #48]	; 0x30
    stack_frame->exception_stack_frame.r12 = 0;                        /* r12 */
 8019814:	697b      	ldr	r3, [r7, #20]
 8019816:	2200      	movs	r2, #0
 8019818:	635a      	str	r2, [r3, #52]	; 0x34
    stack_frame->exception_stack_frame.lr  = (unsigned long)texit;     /* lr */
 801981a:	683a      	ldr	r2, [r7, #0]
 801981c:	697b      	ldr	r3, [r7, #20]
 801981e:	639a      	str	r2, [r3, #56]	; 0x38
    stack_frame->exception_stack_frame.pc  = (unsigned long)tentry;    /* entry point, pc */
 8019820:	68fa      	ldr	r2, [r7, #12]
 8019822:	697b      	ldr	r3, [r7, #20]
 8019824:	63da      	str	r2, [r3, #60]	; 0x3c
    stack_frame->exception_stack_frame.psr = 0x01000000L;              /* PSR */
 8019826:	697b      	ldr	r3, [r7, #20]
 8019828:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 801982c:	641a      	str	r2, [r3, #64]	; 0x40

#if USE_FPU
    stack_frame->flag = 0;
 801982e:	697b      	ldr	r3, [r7, #20]
 8019830:	2200      	movs	r2, #0
 8019832:	601a      	str	r2, [r3, #0]
#endif /* USE_FPU */

    /* return task's current stack address */
    return stk;
 8019834:	69bb      	ldr	r3, [r7, #24]
}
 8019836:	4618      	mov	r0, r3
 8019838:	3724      	adds	r7, #36	; 0x24
 801983a:	46bd      	mov	sp, r7
 801983c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019840:	4770      	bx	lr
 8019842:	bf00      	nop
 8019844:	deadbeef 	.word	0xdeadbeef

08019848 <rt_hw_hard_fault_exception>:
{
    rt_exception_hook = exception_handle;
}

void rt_hw_hard_fault_exception(struct exception_stack_frame *exception_stack)
{
 8019848:	b580      	push	{r7, lr}
 801984a:	b084      	sub	sp, #16
 801984c:	af00      	add	r7, sp, #0
 801984e:	6078      	str	r0, [r7, #4]
    extern long list_thread(void);

    if (rt_exception_hook != RT_NULL)
 8019850:	4b24      	ldr	r3, [pc, #144]	; (80198e4 <rt_hw_hard_fault_exception+0x9c>)
 8019852:	681b      	ldr	r3, [r3, #0]
 8019854:	2b00      	cmp	r3, #0
 8019856:	d008      	beq.n	801986a <rt_hw_hard_fault_exception+0x22>
    {
        rt_err_t result;

        result = rt_exception_hook(exception_stack);
 8019858:	4b22      	ldr	r3, [pc, #136]	; (80198e4 <rt_hw_hard_fault_exception+0x9c>)
 801985a:	681b      	ldr	r3, [r3, #0]
 801985c:	6878      	ldr	r0, [r7, #4]
 801985e:	4798      	blx	r3
 8019860:	60f8      	str	r0, [r7, #12]
        if (result == RT_EOK) return;
 8019862:	68fb      	ldr	r3, [r7, #12]
 8019864:	2b00      	cmp	r3, #0
 8019866:	d100      	bne.n	801986a <rt_hw_hard_fault_exception+0x22>
 8019868:	e039      	b.n	80198de <rt_hw_hard_fault_exception+0x96>
    }

    rt_kprintf("psr: 0x%08x\n", exception_stack->psr);
 801986a:	687b      	ldr	r3, [r7, #4]
 801986c:	69db      	ldr	r3, [r3, #28]
 801986e:	481e      	ldr	r0, [pc, #120]	; (80198e8 <rt_hw_hard_fault_exception+0xa0>)
 8019870:	4619      	mov	r1, r3
 8019872:	f7fe f823 	bl	80178bc <rt_kprintf>
    rt_kprintf(" pc: 0x%08x\n", exception_stack->pc);
 8019876:	687b      	ldr	r3, [r7, #4]
 8019878:	699b      	ldr	r3, [r3, #24]
 801987a:	481c      	ldr	r0, [pc, #112]	; (80198ec <rt_hw_hard_fault_exception+0xa4>)
 801987c:	4619      	mov	r1, r3
 801987e:	f7fe f81d 	bl	80178bc <rt_kprintf>
    rt_kprintf(" lr: 0x%08x\n", exception_stack->lr);
 8019882:	687b      	ldr	r3, [r7, #4]
 8019884:	695b      	ldr	r3, [r3, #20]
 8019886:	481a      	ldr	r0, [pc, #104]	; (80198f0 <rt_hw_hard_fault_exception+0xa8>)
 8019888:	4619      	mov	r1, r3
 801988a:	f7fe f817 	bl	80178bc <rt_kprintf>
    rt_kprintf("r12: 0x%08x\n", exception_stack->r12);
 801988e:	687b      	ldr	r3, [r7, #4]
 8019890:	691b      	ldr	r3, [r3, #16]
 8019892:	4818      	ldr	r0, [pc, #96]	; (80198f4 <rt_hw_hard_fault_exception+0xac>)
 8019894:	4619      	mov	r1, r3
 8019896:	f7fe f811 	bl	80178bc <rt_kprintf>
    rt_kprintf("r03: 0x%08x\n", exception_stack->r3);
 801989a:	687b      	ldr	r3, [r7, #4]
 801989c:	68db      	ldr	r3, [r3, #12]
 801989e:	4816      	ldr	r0, [pc, #88]	; (80198f8 <rt_hw_hard_fault_exception+0xb0>)
 80198a0:	4619      	mov	r1, r3
 80198a2:	f7fe f80b 	bl	80178bc <rt_kprintf>
    rt_kprintf("r02: 0x%08x\n", exception_stack->r2);
 80198a6:	687b      	ldr	r3, [r7, #4]
 80198a8:	689b      	ldr	r3, [r3, #8]
 80198aa:	4814      	ldr	r0, [pc, #80]	; (80198fc <rt_hw_hard_fault_exception+0xb4>)
 80198ac:	4619      	mov	r1, r3
 80198ae:	f7fe f805 	bl	80178bc <rt_kprintf>
    rt_kprintf("r01: 0x%08x\n", exception_stack->r1);
 80198b2:	687b      	ldr	r3, [r7, #4]
 80198b4:	685b      	ldr	r3, [r3, #4]
 80198b6:	4812      	ldr	r0, [pc, #72]	; (8019900 <rt_hw_hard_fault_exception+0xb8>)
 80198b8:	4619      	mov	r1, r3
 80198ba:	f7fd ffff 	bl	80178bc <rt_kprintf>
    rt_kprintf("r00: 0x%08x\n", exception_stack->r0);
 80198be:	687b      	ldr	r3, [r7, #4]
 80198c0:	681b      	ldr	r3, [r3, #0]
 80198c2:	4810      	ldr	r0, [pc, #64]	; (8019904 <rt_hw_hard_fault_exception+0xbc>)
 80198c4:	4619      	mov	r1, r3
 80198c6:	f7fd fff9 	bl	80178bc <rt_kprintf>

    rt_kprintf("hard fault on thread: %s\n", rt_thread_self()->name);
 80198ca:	f7ff f981 	bl	8018bd0 <rt_thread_self>
 80198ce:	4603      	mov	r3, r0
 80198d0:	480d      	ldr	r0, [pc, #52]	; (8019908 <rt_hw_hard_fault_exception+0xc0>)
 80198d2:	4619      	mov	r1, r3
 80198d4:	f7fd fff2 	bl	80178bc <rt_kprintf>

#ifdef RT_USING_FINSH
    list_thread();
 80198d8:	f003 fb60 	bl	801cf9c <list_thread>
#endif

    while (1);
 80198dc:	e7fe      	b.n	80198dc <rt_hw_hard_fault_exception+0x94>
}
 80198de:	3710      	adds	r7, #16
 80198e0:	46bd      	mov	sp, r7
 80198e2:	bd80      	pop	{r7, pc}
 80198e4:	20011040 	.word	0x20011040
 80198e8:	08027c9c 	.word	0x08027c9c
 80198ec:	08027cac 	.word	0x08027cac
 80198f0:	08027cbc 	.word	0x08027cbc
 80198f4:	08027ccc 	.word	0x08027ccc
 80198f8:	08027cdc 	.word	0x08027cdc
 80198fc:	08027cec 	.word	0x08027cec
 8019900:	08027cfc 	.word	0x08027cfc
 8019904:	08027d0c 	.word	0x08027d0c
 8019908:	08027d1c 	.word	0x08027d1c

0801990c <clock_time_system_init>:
#include <rtthread.h>
#include <pthread.h>

struct timeval _timevalue;
void clock_time_system_init()
{
 801990c:	b580      	push	{r7, lr}
 801990e:	b084      	sub	sp, #16
 8019910:	af00      	add	r7, sp, #0
    time_t time;
    rt_tick_t tick;
    rt_device_t device;

    time = 0;
 8019912:	2300      	movs	r3, #0
 8019914:	607b      	str	r3, [r7, #4]
    device = rt_device_find("rtc");
 8019916:	4818      	ldr	r0, [pc, #96]	; (8019978 <clock_time_system_init+0x6c>)
 8019918:	f7fc f942 	bl	8015ba0 <rt_device_find>
 801991c:	60f8      	str	r0, [r7, #12]
    if (device != RT_NULL)
 801991e:	68fb      	ldr	r3, [r7, #12]
 8019920:	2b00      	cmp	r3, #0
 8019922:	d005      	beq.n	8019930 <clock_time_system_init+0x24>
    {
        /* get realtime seconds */
        rt_device_control(device, RT_DEVICE_CTRL_RTC_GET_TIME, &time);
 8019924:	1d3b      	adds	r3, r7, #4
 8019926:	68f8      	ldr	r0, [r7, #12]
 8019928:	2110      	movs	r1, #16
 801992a:	461a      	mov	r2, r3
 801992c:	f7fc fa8e 	bl	8015e4c <rt_device_control>
    }

    /* get tick */
    tick = rt_tick_get();
 8019930:	f7fc f880 	bl	8015a34 <rt_tick_get>
 8019934:	60b8      	str	r0, [r7, #8]

    _timevalue.tv_usec = (tick%RT_TICK_PER_SECOND) * MICROSECOND_PER_TICK;
 8019936:	68ba      	ldr	r2, [r7, #8]
 8019938:	4b10      	ldr	r3, [pc, #64]	; (801997c <clock_time_system_init+0x70>)
 801993a:	fba3 1302 	umull	r1, r3, r3, r2
 801993e:	09db      	lsrs	r3, r3, #7
 8019940:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 8019944:	fb01 f303 	mul.w	r3, r1, r3
 8019948:	1ad3      	subs	r3, r2, r3
 801994a:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 801994e:	fb02 f303 	mul.w	r3, r2, r3
 8019952:	461a      	mov	r2, r3
 8019954:	4b0a      	ldr	r3, [pc, #40]	; (8019980 <clock_time_system_init+0x74>)
 8019956:	605a      	str	r2, [r3, #4]
    _timevalue.tv_sec = time - tick/RT_TICK_PER_SECOND - 1;
 8019958:	687b      	ldr	r3, [r7, #4]
 801995a:	4619      	mov	r1, r3
 801995c:	68bb      	ldr	r3, [r7, #8]
 801995e:	4a07      	ldr	r2, [pc, #28]	; (801997c <clock_time_system_init+0x70>)
 8019960:	fba2 2303 	umull	r2, r3, r2, r3
 8019964:	09db      	lsrs	r3, r3, #7
 8019966:	1acb      	subs	r3, r1, r3
 8019968:	3b01      	subs	r3, #1
 801996a:	461a      	mov	r2, r3
 801996c:	4b04      	ldr	r3, [pc, #16]	; (8019980 <clock_time_system_init+0x74>)
 801996e:	601a      	str	r2, [r3, #0]
}
 8019970:	3710      	adds	r7, #16
 8019972:	46bd      	mov	sp, r7
 8019974:	bd80      	pop	{r7, pc}
 8019976:	bf00      	nop
 8019978:	08027d4c 	.word	0x08027d4c
 801997c:	10624dd3 	.word	0x10624dd3
 8019980:	20012b6c 	.word	0x20012b6c

08019984 <posix_mq_system_init>:
#include "pthread_internal.h"

static mqd_t posix_mq_list = RT_NULL;
static struct rt_semaphore posix_mq_lock;
void posix_mq_system_init()
{
 8019984:	b580      	push	{r7, lr}
 8019986:	af00      	add	r7, sp, #0
    rt_sem_init(&posix_mq_lock, "pmq", 1, RT_IPC_FLAG_FIFO);
 8019988:	4803      	ldr	r0, [pc, #12]	; (8019998 <posix_mq_system_init+0x14>)
 801998a:	4904      	ldr	r1, [pc, #16]	; (801999c <posix_mq_system_init+0x18>)
 801998c:	2201      	movs	r2, #1
 801998e:	2300      	movs	r3, #0
 8019990:	f7fc fc1a 	bl	80161c8 <rt_sem_init>
}
 8019994:	bd80      	pop	{r7, pc}
 8019996:	bf00      	nop
 8019998:	20011044 	.word	0x20011044
 801999c:	08027d60 	.word	0x08027d60

080199a0 <pthread_system_init>:
#include <pthread.h>
#include <sched.h>
#include "pthread_internal.h"

int pthread_system_init(void)
{
 80199a0:	b580      	push	{r7, lr}
 80199a2:	af00      	add	r7, sp, #0
    /* initialize clock and time */
    clock_time_system_init();
 80199a4:	f7ff ffb2 	bl	801990c <clock_time_system_init>

    /* initialize key area */
    pthread_key_system_init();
 80199a8:	f000 f808 	bl	80199bc <pthread_key_system_init>
    /* initialize posix mqueue */
    posix_mq_system_init();
 80199ac:	f7ff ffea 	bl	8019984 <posix_mq_system_init>
    /* initialize posix semaphore */
    posix_sem_system_init();
 80199b0:	f000 f80e 	bl	80199d0 <posix_sem_system_init>

    return 0;
 80199b4:	2300      	movs	r3, #0
}
 80199b6:	4618      	mov	r0, r3
 80199b8:	bd80      	pop	{r7, pc}
 80199ba:	bf00      	nop

080199bc <pthread_key_system_init>:
#include "pthread_internal.h"

_pthread_key_data_t _thread_keys[PTHREAD_KEY_MAX];

void pthread_key_system_init()
{
 80199bc:	b580      	push	{r7, lr}
 80199be:	af00      	add	r7, sp, #0
    rt_memset(&_thread_keys[0], 0, sizeof(_thread_keys));
 80199c0:	4802      	ldr	r0, [pc, #8]	; (80199cc <pthread_key_system_init+0x10>)
 80199c2:	2100      	movs	r1, #0
 80199c4:	2240      	movs	r2, #64	; 0x40
 80199c6:	f7fd f9c1 	bl	8016d4c <rt_memset>
}
 80199ca:	bd80      	pop	{r7, pc}
 80199cc:	20012b74 	.word	0x20012b74

080199d0 <posix_sem_system_init>:
#include "pthread_internal.h"

static sem_t *posix_sem_list = RT_NULL;
static struct rt_semaphore posix_sem_lock;
void posix_sem_system_init()
{
 80199d0:	b580      	push	{r7, lr}
 80199d2:	af00      	add	r7, sp, #0
    rt_sem_init(&posix_sem_lock, "psem", 1, RT_IPC_FLAG_FIFO);
 80199d4:	4803      	ldr	r0, [pc, #12]	; (80199e4 <posix_sem_system_init+0x14>)
 80199d6:	4904      	ldr	r1, [pc, #16]	; (80199e8 <posix_sem_system_init+0x18>)
 80199d8:	2201      	movs	r2, #1
 80199da:	2300      	movs	r3, #0
 80199dc:	f7fc fbf4 	bl	80161c8 <rt_sem_init>
}
 80199e0:	bd80      	pop	{r7, pc}
 80199e2:	bf00      	nop
 80199e4:	20011064 	.word	0x20011064
 80199e8:	08027d64 	.word	0x08027d64

080199ec <libc_system_init>:
#endif

#endif

int libc_system_init(void)
{
 80199ec:	b580      	push	{r7, lr}
 80199ee:	af00      	add	r7, sp, #0
        fd = fd;
    }
#endif

    /* set PATH and HOME */
    putenv("PATH=/bin");
 80199f0:	4805      	ldr	r0, [pc, #20]	; (8019a08 <libc_system_init+0x1c>)
 80199f2:	f009 fcd5 	bl	80233a0 <putenv>
    putenv("HOME=/home");
 80199f6:	4805      	ldr	r0, [pc, #20]	; (8019a0c <libc_system_init+0x20>)
 80199f8:	f009 fcd2 	bl	80233a0 <putenv>

#ifdef RT_USING_PTHREADS
    pthread_system_init();
 80199fc:	f7ff ffd0 	bl	80199a0 <pthread_system_init>
#endif

    return 0;
 8019a00:	2300      	movs	r3, #0
}
 8019a02:	4618      	mov	r0, r3
 8019a04:	bd80      	pop	{r7, pc}
 8019a06:	bf00      	nop
 8019a08:	08027d78 	.word	0x08027d78
 8019a0c:	08027d84 	.word	0x08027d84

08019a10 <_malloc_r>:
#endif

/* Memory routine */
void *
_malloc_r (struct _reent *ptr, size_t size)
{
 8019a10:	b580      	push	{r7, lr}
 8019a12:	b084      	sub	sp, #16
 8019a14:	af00      	add	r7, sp, #0
 8019a16:	6078      	str	r0, [r7, #4]
 8019a18:	6039      	str	r1, [r7, #0]
	void* result;

	result = (void*)rt_malloc (size);
 8019a1a:	6838      	ldr	r0, [r7, #0]
 8019a1c:	f7fe f8fc 	bl	8017c18 <rt_malloc>
 8019a20:	60f8      	str	r0, [r7, #12]
	if (result == RT_NULL)
 8019a22:	68fb      	ldr	r3, [r7, #12]
 8019a24:	2b00      	cmp	r3, #0
 8019a26:	d102      	bne.n	8019a2e <_malloc_r+0x1e>
	{
		ptr->_errno = ENOMEM;
 8019a28:	687b      	ldr	r3, [r7, #4]
 8019a2a:	220c      	movs	r2, #12
 8019a2c:	601a      	str	r2, [r3, #0]
	}

	return result;
 8019a2e:	68fb      	ldr	r3, [r7, #12]
}
 8019a30:	4618      	mov	r0, r3
 8019a32:	3710      	adds	r7, #16
 8019a34:	46bd      	mov	sp, r7
 8019a36:	bd80      	pop	{r7, pc}

08019a38 <_realloc_r>:

void *
_realloc_r (struct _reent *ptr, void *old, size_t newlen)
{
 8019a38:	b580      	push	{r7, lr}
 8019a3a:	b086      	sub	sp, #24
 8019a3c:	af00      	add	r7, sp, #0
 8019a3e:	60f8      	str	r0, [r7, #12]
 8019a40:	60b9      	str	r1, [r7, #8]
 8019a42:	607a      	str	r2, [r7, #4]
	void* result;

	result = (void*)rt_realloc (old, newlen);
 8019a44:	68b8      	ldr	r0, [r7, #8]
 8019a46:	6879      	ldr	r1, [r7, #4]
 8019a48:	f7fe fa2c 	bl	8017ea4 <rt_realloc>
 8019a4c:	6178      	str	r0, [r7, #20]
	if (result == RT_NULL)
 8019a4e:	697b      	ldr	r3, [r7, #20]
 8019a50:	2b00      	cmp	r3, #0
 8019a52:	d102      	bne.n	8019a5a <_realloc_r+0x22>
	{
		ptr->_errno = ENOMEM;
 8019a54:	68fb      	ldr	r3, [r7, #12]
 8019a56:	220c      	movs	r2, #12
 8019a58:	601a      	str	r2, [r3, #0]
	}

	return result;
 8019a5a:	697b      	ldr	r3, [r7, #20]
}
 8019a5c:	4618      	mov	r0, r3
 8019a5e:	3718      	adds	r7, #24
 8019a60:	46bd      	mov	sp, r7
 8019a62:	bd80      	pop	{r7, pc}

08019a64 <_free_r>:
	return result;
}

void 
_free_r (struct _reent *ptr, void *addr)
{
 8019a64:	b580      	push	{r7, lr}
 8019a66:	b082      	sub	sp, #8
 8019a68:	af00      	add	r7, sp, #0
 8019a6a:	6078      	str	r0, [r7, #4]
 8019a6c:	6039      	str	r1, [r7, #0]
	rt_free (addr);
 8019a6e:	6838      	ldr	r0, [r7, #0]
 8019a70:	f7fe fadc 	bl	801802c <rt_free>
}
 8019a74:	3708      	adds	r7, #8
 8019a76:	46bd      	mov	sp, r7
 8019a78:	bd80      	pop	{r7, pc}
 8019a7a:	bf00      	nop

08019a7c <__libc_init_array>:
    /* not support this call */
    return;
}

void __libc_init_array(void)
{
 8019a7c:	b480      	push	{r7}
 8019a7e:	af00      	add	r7, sp, #0
	/* we not use __libc init_aray to initialize C++ objects */
}
 8019a80:	46bd      	mov	sp, r7
 8019a82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019a86:	4770      	bx	lr

08019a88 <osDelay>:

// Generic Wait API

/// Wait for Timeout (Time Delay)
osStatus osDelay(uint32_t millisec)
{
 8019a88:	b580      	push	{r7, lr}
 8019a8a:	b084      	sub	sp, #16
 8019a8c:	af00      	add	r7, sp, #0
 8019a8e:	6078      	str	r0, [r7, #4]
    rt_err_t result;
    rt_tick_t ticks;

    ticks = rt_tick_from_millisecond(millisec);
 8019a90:	6878      	ldr	r0, [r7, #4]
 8019a92:	f7fb fffd 	bl	8015a90 <rt_tick_from_millisecond>
 8019a96:	60f8      	str	r0, [r7, #12]
    result = rt_thread_delay(ticks);
 8019a98:	68f8      	ldr	r0, [r7, #12]
 8019a9a:	f7ff f9b9 	bl	8018e10 <rt_thread_delay>
 8019a9e:	60b8      	str	r0, [r7, #8]

    if (result == RT_EOK)
 8019aa0:	68bb      	ldr	r3, [r7, #8]
 8019aa2:	2b00      	cmp	r3, #0
 8019aa4:	d101      	bne.n	8019aaa <osDelay+0x22>
        return osOK;
 8019aa6:	2300      	movs	r3, #0
 8019aa8:	e000      	b.n	8019aac <osDelay+0x24>
    else
        return osErrorOS;
 8019aaa:	23ff      	movs	r3, #255	; 0xff
}
 8019aac:	4618      	mov	r0, r3
 8019aae:	3710      	adds	r7, #16
 8019ab0:	46bd      	mov	sp, r7
 8019ab2:	bd80      	pop	{r7, pc}

08019ab4 <osTimerCreate>:

// Timer Management Public API

/// Create timer
osTimerId osTimerCreate(osTimerDef_t *timer_def, os_timer_type type, void *argument)
{
 8019ab4:	b590      	push	{r4, r7, lr}
 8019ab6:	b089      	sub	sp, #36	; 0x24
 8019ab8:	af02      	add	r7, sp, #8
 8019aba:	60f8      	str	r0, [r7, #12]
 8019abc:	460b      	mov	r3, r1
 8019abe:	607a      	str	r2, [r7, #4]
 8019ac0:	72fb      	strb	r3, [r7, #11]
    uint8_t flag = RT_TIMER_FLAG_SOFT_TIMER;
 8019ac2:	2304      	movs	r3, #4
 8019ac4:	75fb      	strb	r3, [r7, #23]

    if (type == osTimerPeriodic)
 8019ac6:	7afb      	ldrb	r3, [r7, #11]
 8019ac8:	2b01      	cmp	r3, #1
 8019aca:	d103      	bne.n	8019ad4 <osTimerCreate+0x20>
    {
        flag |= RT_TIMER_FLAG_PERIODIC;
 8019acc:	7dfb      	ldrb	r3, [r7, #23]
 8019ace:	f043 0302 	orr.w	r3, r3, #2
 8019ad2:	75fb      	strb	r3, [r7, #23]
    }

    return rt_timer_create(timer_def->name, timer_def->timeout, argument, timer_def->time, flag);
 8019ad4:	68fb      	ldr	r3, [r7, #12]
 8019ad6:	6819      	ldr	r1, [r3, #0]
 8019ad8:	68fb      	ldr	r3, [r7, #12]
 8019ada:	685a      	ldr	r2, [r3, #4]
 8019adc:	68fb      	ldr	r3, [r7, #12]
 8019ade:	68dc      	ldr	r4, [r3, #12]
 8019ae0:	7dfb      	ldrb	r3, [r7, #23]
 8019ae2:	9300      	str	r3, [sp, #0]
 8019ae4:	4608      	mov	r0, r1
 8019ae6:	4611      	mov	r1, r2
 8019ae8:	687a      	ldr	r2, [r7, #4]
 8019aea:	4623      	mov	r3, r4
 8019aec:	f7ff fb8a 	bl	8019204 <rt_timer_create>
 8019af0:	4603      	mov	r3, r0
}
 8019af2:	4618      	mov	r0, r3
 8019af4:	371c      	adds	r7, #28
 8019af6:	46bd      	mov	sp, r7
 8019af8:	bd90      	pop	{r4, r7, pc}
 8019afa:	bf00      	nop

08019afc <osTimerStart>:

/// Start or restart timer
osStatus osTimerStart(osTimerId timer_id, uint32_t millisec)
{
 8019afc:	b580      	push	{r7, lr}
 8019afe:	b084      	sub	sp, #16
 8019b00:	af00      	add	r7, sp, #0
 8019b02:	6078      	str	r0, [r7, #4]
 8019b04:	6039      	str	r1, [r7, #0]
    rt_err_t result;
    rt_tick_t ticks;

    ticks = rt_tick_from_millisecond(millisec);
 8019b06:	6838      	ldr	r0, [r7, #0]
 8019b08:	f7fb ffc2 	bl	8015a90 <rt_tick_from_millisecond>
 8019b0c:	4603      	mov	r3, r0
 8019b0e:	60bb      	str	r3, [r7, #8]
    rt_timer_control(timer_id, RT_TIMER_CTRL_SET_TIME, &ticks);
 8019b10:	f107 0308 	add.w	r3, r7, #8
 8019b14:	6878      	ldr	r0, [r7, #4]
 8019b16:	2100      	movs	r1, #0
 8019b18:	461a      	mov	r2, r3
 8019b1a:	f7ff fcd9 	bl	80194d0 <rt_timer_control>
    result = rt_timer_start(timer_id);
 8019b1e:	6878      	ldr	r0, [r7, #4]
 8019b20:	f7ff fb90 	bl	8019244 <rt_timer_start>
 8019b24:	60f8      	str	r0, [r7, #12]
    if (result == RT_EOK)
 8019b26:	68fb      	ldr	r3, [r7, #12]
 8019b28:	2b00      	cmp	r3, #0
 8019b2a:	d101      	bne.n	8019b30 <osTimerStart+0x34>
        return osOK;
 8019b2c:	2300      	movs	r3, #0
 8019b2e:	e000      	b.n	8019b32 <osTimerStart+0x36>
    else
        return osErrorOS;
 8019b30:	23ff      	movs	r3, #255	; 0xff
}
 8019b32:	4618      	mov	r0, r3
 8019b34:	3710      	adds	r7, #16
 8019b36:	46bd      	mov	sp, r7
 8019b38:	bd80      	pop	{r7, pc}
 8019b3a:	bf00      	nop

08019b3c <osMessageCreate>:

// Message Queue Management Public API

/// Create and Initialize Message Queue
osMessageQId osMessageCreate(osMessageQDef_t *queue_def, osThreadId thread_id)
{
 8019b3c:	b580      	push	{r7, lr}
 8019b3e:	b082      	sub	sp, #8
 8019b40:	af00      	add	r7, sp, #0
 8019b42:	6078      	str	r0, [r7, #4]
 8019b44:	6039      	str	r1, [r7, #0]
    return rt_mq_create(queue_def->name, queue_def->msg_size, queue_def->max_msgs, queue_def->flag);
 8019b46:	687b      	ldr	r3, [r7, #4]
 8019b48:	6818      	ldr	r0, [r3, #0]
 8019b4a:	687b      	ldr	r3, [r7, #4]
 8019b4c:	6899      	ldr	r1, [r3, #8]
 8019b4e:	687b      	ldr	r3, [r7, #4]
 8019b50:	685a      	ldr	r2, [r3, #4]
 8019b52:	687b      	ldr	r3, [r7, #4]
 8019b54:	7b1b      	ldrb	r3, [r3, #12]
 8019b56:	f7fc fe2d 	bl	80167b4 <rt_mq_create>
 8019b5a:	4603      	mov	r3, r0
}
 8019b5c:	4618      	mov	r0, r3
 8019b5e:	3708      	adds	r7, #8
 8019b60:	46bd      	mov	sp, r7
 8019b62:	bd80      	pop	{r7, pc}

08019b64 <osMessagePut>:

/// Put a Message to a Queue
osStatus osMessagePut(osMessageQId queue_id, uint32_t info, uint32_t millisec)
{
 8019b64:	b580      	push	{r7, lr}
 8019b66:	b086      	sub	sp, #24
 8019b68:	af00      	add	r7, sp, #0
 8019b6a:	60f8      	str	r0, [r7, #12]
 8019b6c:	60b9      	str	r1, [r7, #8]
 8019b6e:	607a      	str	r2, [r7, #4]
    rt_err_t result;

    result = rt_mq_send(queue_id,&info, 4);
 8019b70:	f107 0308 	add.w	r3, r7, #8
 8019b74:	68f8      	ldr	r0, [r7, #12]
 8019b76:	4619      	mov	r1, r3
 8019b78:	2204      	movs	r2, #4
 8019b7a:	f7fc fed9 	bl	8016930 <rt_mq_send>
 8019b7e:	6178      	str	r0, [r7, #20]

    if (result == RT_EOK)
 8019b80:	697b      	ldr	r3, [r7, #20]
 8019b82:	2b00      	cmp	r3, #0
 8019b84:	d101      	bne.n	8019b8a <osMessagePut+0x26>
        return osOK;
 8019b86:	2300      	movs	r3, #0
 8019b88:	e000      	b.n	8019b8c <osMessagePut+0x28>
    else
        return osErrorOS;
 8019b8a:	23ff      	movs	r3, #255	; 0xff
}
 8019b8c:	4618      	mov	r0, r3
 8019b8e:	3718      	adds	r7, #24
 8019b90:	46bd      	mov	sp, r7
 8019b92:	bd80      	pop	{r7, pc}

08019b94 <osMessageGet>:

/// Get a Message or Wait for a Message from a Queue
osEvent osMessageGet(osMessageQId queue_id, uint32_t millisec)
{
 8019b94:	b590      	push	{r4, r7, lr}
 8019b96:	b08b      	sub	sp, #44	; 0x2c
 8019b98:	af00      	add	r7, sp, #0
 8019b9a:	60f8      	str	r0, [r7, #12]
 8019b9c:	60b9      	str	r1, [r7, #8]
 8019b9e:	607a      	str	r2, [r7, #4]
    osEvent event;
    rt_err_t result;
    rt_tick_t ticks;

    ticks = rt_tick_from_millisecond(millisec);
 8019ba0:	6878      	ldr	r0, [r7, #4]
 8019ba2:	f7fb ff75 	bl	8015a90 <rt_tick_from_millisecond>
 8019ba6:	6278      	str	r0, [r7, #36]	; 0x24
    result = rt_mq_recv(queue_id, &event.value, 4, ticks);
 8019ba8:	6a7c      	ldr	r4, [r7, #36]	; 0x24
 8019baa:	f107 0314 	add.w	r3, r7, #20
 8019bae:	3304      	adds	r3, #4
 8019bb0:	68b8      	ldr	r0, [r7, #8]
 8019bb2:	4619      	mov	r1, r3
 8019bb4:	2204      	movs	r2, #4
 8019bb6:	4623      	mov	r3, r4
 8019bb8:	f7fc ff54 	bl	8016a64 <rt_mq_recv>
 8019bbc:	6238      	str	r0, [r7, #32]

    if (result == RT_EOK)
 8019bbe:	6a3b      	ldr	r3, [r7, #32]
 8019bc0:	2b00      	cmp	r3, #0
 8019bc2:	d102      	bne.n	8019bca <osMessageGet+0x36>
    {
        event.status = osEventMessage;
 8019bc4:	2310      	movs	r3, #16
 8019bc6:	617b      	str	r3, [r7, #20]
 8019bc8:	e001      	b.n	8019bce <osMessageGet+0x3a>
    }
    else
    {
        event.status = osEventTimeout;
 8019bca:	2340      	movs	r3, #64	; 0x40
 8019bcc:	617b      	str	r3, [r7, #20]
    }

    return event;
 8019bce:	68fb      	ldr	r3, [r7, #12]
 8019bd0:	461c      	mov	r4, r3
 8019bd2:	f107 0314 	add.w	r3, r7, #20
 8019bd6:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8019bda:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 8019bde:	68f8      	ldr	r0, [r7, #12]
 8019be0:	372c      	adds	r7, #44	; 0x2c
 8019be2:	46bd      	mov	sp, r7
 8019be4:	bd90      	pop	{r4, r7, pc}
 8019be6:	bf00      	nop

08019be8 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 8019be8:	b480      	push	{r7}
 8019bea:	b083      	sub	sp, #12
 8019bec:	af00      	add	r7, sp, #0
 8019bee:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 8019bf0:	687b      	ldr	r3, [r7, #4]
 8019bf2:	687a      	ldr	r2, [r7, #4]
 8019bf4:	605a      	str	r2, [r3, #4]
 8019bf6:	687b      	ldr	r3, [r7, #4]
 8019bf8:	685a      	ldr	r2, [r3, #4]
 8019bfa:	687b      	ldr	r3, [r7, #4]
 8019bfc:	601a      	str	r2, [r3, #0]
}
 8019bfe:	370c      	adds	r7, #12
 8019c00:	46bd      	mov	sp, r7
 8019c02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019c06:	4770      	bx	lr

08019c08 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 8019c08:	b480      	push	{r7}
 8019c0a:	b083      	sub	sp, #12
 8019c0c:	af00      	add	r7, sp, #0
 8019c0e:	6078      	str	r0, [r7, #4]
 8019c10:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 8019c12:	687b      	ldr	r3, [r7, #4]
 8019c14:	685b      	ldr	r3, [r3, #4]
 8019c16:	683a      	ldr	r2, [r7, #0]
 8019c18:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 8019c1a:	687b      	ldr	r3, [r7, #4]
 8019c1c:	685a      	ldr	r2, [r3, #4]
 8019c1e:	683b      	ldr	r3, [r7, #0]
 8019c20:	605a      	str	r2, [r3, #4]

    l->prev = n;
 8019c22:	687b      	ldr	r3, [r7, #4]
 8019c24:	683a      	ldr	r2, [r7, #0]
 8019c26:	605a      	str	r2, [r3, #4]
    n->next = l;
 8019c28:	683b      	ldr	r3, [r7, #0]
 8019c2a:	687a      	ldr	r2, [r7, #4]
 8019c2c:	601a      	str	r2, [r3, #0]
}
 8019c2e:	370c      	adds	r7, #12
 8019c30:	46bd      	mov	sp, r7
 8019c32:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019c36:	4770      	bx	lr

08019c38 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 8019c38:	b480      	push	{r7}
 8019c3a:	b083      	sub	sp, #12
 8019c3c:	af00      	add	r7, sp, #0
 8019c3e:	6078      	str	r0, [r7, #4]
    return l->next == l;
 8019c40:	687b      	ldr	r3, [r7, #4]
 8019c42:	681a      	ldr	r2, [r3, #0]
 8019c44:	687b      	ldr	r3, [r7, #4]
 8019c46:	429a      	cmp	r2, r3
 8019c48:	bf0c      	ite	eq
 8019c4a:	2301      	moveq	r3, #1
 8019c4c:	2300      	movne	r3, #0
 8019c4e:	b2db      	uxtb	r3, r3
}
 8019c50:	4618      	mov	r0, r3
 8019c52:	370c      	adds	r7, #12
 8019c54:	46bd      	mov	sp, r7
 8019c56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019c5a:	4770      	bx	lr

08019c5c <rt_completion_init>:

#define RT_COMPLETED    1
#define RT_UNCOMPLETED  0

void rt_completion_init(struct rt_completion *completion)
{
 8019c5c:	b580      	push	{r7, lr}
 8019c5e:	b084      	sub	sp, #16
 8019c60:	af00      	add	r7, sp, #0
 8019c62:	6078      	str	r0, [r7, #4]
    rt_base_t level;
    RT_ASSERT(completion != RT_NULL);
 8019c64:	687b      	ldr	r3, [r7, #4]
 8019c66:	2b00      	cmp	r3, #0
 8019c68:	d104      	bne.n	8019c74 <rt_completion_init+0x18>
 8019c6a:	480b      	ldr	r0, [pc, #44]	; (8019c98 <rt_completion_init+0x3c>)
 8019c6c:	490b      	ldr	r1, [pc, #44]	; (8019c9c <rt_completion_init+0x40>)
 8019c6e:	2223      	movs	r2, #35	; 0x23
 8019c70:	f7fd fe9e 	bl	80179b0 <rt_assert_handler>

    level = rt_hw_interrupt_disable();
 8019c74:	f7e6 faa8 	bl	80001c8 <rt_hw_interrupt_disable>
 8019c78:	60f8      	str	r0, [r7, #12]
    completion->flag = RT_UNCOMPLETED;
 8019c7a:	687b      	ldr	r3, [r7, #4]
 8019c7c:	2200      	movs	r2, #0
 8019c7e:	601a      	str	r2, [r3, #0]
    rt_list_init(&completion->suspended_list);
 8019c80:	687b      	ldr	r3, [r7, #4]
 8019c82:	3304      	adds	r3, #4
 8019c84:	4618      	mov	r0, r3
 8019c86:	f7ff ffaf 	bl	8019be8 <rt_list_init>
    rt_hw_interrupt_enable(level);
 8019c8a:	68f8      	ldr	r0, [r7, #12]
 8019c8c:	f7e6 faa0 	bl	80001d0 <rt_hw_interrupt_enable>
}
 8019c90:	3710      	adds	r7, #16
 8019c92:	46bd      	mov	sp, r7
 8019c94:	bd80      	pop	{r7, pc}
 8019c96:	bf00      	nop
 8019c98:	08027d90 	.word	0x08027d90
 8019c9c:	08029290 	.word	0x08029290

08019ca0 <rt_completion_wait>:
RTM_EXPORT(rt_completion_init);

rt_err_t rt_completion_wait(struct rt_completion *completion,
                            rt_int32_t            timeout)
{
 8019ca0:	b580      	push	{r7, lr}
 8019ca2:	b086      	sub	sp, #24
 8019ca4:	af00      	add	r7, sp, #0
 8019ca6:	6078      	str	r0, [r7, #4]
 8019ca8:	6039      	str	r1, [r7, #0]
    rt_err_t result;
    rt_base_t level;
    rt_thread_t thread;
    RT_ASSERT(completion != RT_NULL);
 8019caa:	687b      	ldr	r3, [r7, #4]
 8019cac:	2b00      	cmp	r3, #0
 8019cae:	d104      	bne.n	8019cba <rt_completion_wait+0x1a>
 8019cb0:	4836      	ldr	r0, [pc, #216]	; (8019d8c <rt_completion_wait+0xec>)
 8019cb2:	4937      	ldr	r1, [pc, #220]	; (8019d90 <rt_completion_wait+0xf0>)
 8019cb4:	2232      	movs	r2, #50	; 0x32
 8019cb6:	f7fd fe7b 	bl	80179b0 <rt_assert_handler>

    result = RT_EOK;
 8019cba:	2300      	movs	r3, #0
 8019cbc:	617b      	str	r3, [r7, #20]
    thread = rt_thread_self();
 8019cbe:	f7fe ff87 	bl	8018bd0 <rt_thread_self>
 8019cc2:	60f8      	str	r0, [r7, #12]

    level = rt_hw_interrupt_disable();
 8019cc4:	f7e6 fa80 	bl	80001c8 <rt_hw_interrupt_disable>
 8019cc8:	6138      	str	r0, [r7, #16]
    if (completion->flag != RT_COMPLETED)
 8019cca:	687b      	ldr	r3, [r7, #4]
 8019ccc:	681b      	ldr	r3, [r3, #0]
 8019cce:	2b01      	cmp	r3, #1
 8019cd0:	d051      	beq.n	8019d76 <rt_completion_wait+0xd6>
    {
        /* only one thread can suspend on complete */
        RT_ASSERT(rt_list_isempty(&(completion->suspended_list)));
 8019cd2:	687b      	ldr	r3, [r7, #4]
 8019cd4:	3304      	adds	r3, #4
 8019cd6:	4618      	mov	r0, r3
 8019cd8:	f7ff ffae 	bl	8019c38 <rt_list_isempty>
 8019cdc:	4603      	mov	r3, r0
 8019cde:	2b00      	cmp	r3, #0
 8019ce0:	d104      	bne.n	8019cec <rt_completion_wait+0x4c>
 8019ce2:	482c      	ldr	r0, [pc, #176]	; (8019d94 <rt_completion_wait+0xf4>)
 8019ce4:	492a      	ldr	r1, [pc, #168]	; (8019d90 <rt_completion_wait+0xf0>)
 8019ce6:	223b      	movs	r2, #59	; 0x3b
 8019ce8:	f7fd fe62 	bl	80179b0 <rt_assert_handler>

        if (timeout == 0)
 8019cec:	683b      	ldr	r3, [r7, #0]
 8019cee:	2b00      	cmp	r3, #0
 8019cf0:	d103      	bne.n	8019cfa <rt_completion_wait+0x5a>
        {
            result = -RT_ETIMEOUT;
 8019cf2:	f06f 0301 	mvn.w	r3, #1
 8019cf6:	617b      	str	r3, [r7, #20]
            goto __exit;
 8019cf8:	e040      	b.n	8019d7c <rt_completion_wait+0xdc>
        }
        else
        {
            /* reset thread error number */
            thread->error = RT_EOK;
 8019cfa:	68fb      	ldr	r3, [r7, #12]
 8019cfc:	2200      	movs	r2, #0
 8019cfe:	631a      	str	r2, [r3, #48]	; 0x30

            /* suspend thread */
            rt_thread_suspend(thread);
 8019d00:	68f8      	ldr	r0, [r7, #12]
 8019d02:	f7ff f8eb 	bl	8018edc <rt_thread_suspend>
            /* add to suspended list */
            rt_list_insert_before(&(completion->suspended_list),
 8019d06:	687b      	ldr	r3, [r7, #4]
 8019d08:	1d1a      	adds	r2, r3, #4
 8019d0a:	68fb      	ldr	r3, [r7, #12]
 8019d0c:	3314      	adds	r3, #20
 8019d0e:	4610      	mov	r0, r2
 8019d10:	4619      	mov	r1, r3
 8019d12:	f7ff ff79 	bl	8019c08 <rt_list_insert_before>
                                  &(thread->tlist));

            /* current context checking */
            RT_DEBUG_NOT_IN_INTERRUPT;
 8019d16:	f7e6 fa57 	bl	80001c8 <rt_hw_interrupt_disable>
 8019d1a:	60b8      	str	r0, [r7, #8]
 8019d1c:	f7fc ffea 	bl	8016cf4 <rt_interrupt_get_nest>
 8019d20:	4603      	mov	r3, r0
 8019d22:	2b00      	cmp	r3, #0
 8019d24:	d008      	beq.n	8019d38 <rt_completion_wait+0x98>
 8019d26:	481c      	ldr	r0, [pc, #112]	; (8019d98 <rt_completion_wait+0xf8>)
 8019d28:	4919      	ldr	r1, [pc, #100]	; (8019d90 <rt_completion_wait+0xf0>)
 8019d2a:	f7fd fdc7 	bl	80178bc <rt_kprintf>
 8019d2e:	481b      	ldr	r0, [pc, #108]	; (8019d9c <rt_completion_wait+0xfc>)
 8019d30:	4917      	ldr	r1, [pc, #92]	; (8019d90 <rt_completion_wait+0xf0>)
 8019d32:	224e      	movs	r2, #78	; 0x4e
 8019d34:	f7fd fe3c 	bl	80179b0 <rt_assert_handler>
 8019d38:	68b8      	ldr	r0, [r7, #8]
 8019d3a:	f7e6 fa49 	bl	80001d0 <rt_hw_interrupt_enable>

            /* start timer */
            if (timeout > 0)
 8019d3e:	683b      	ldr	r3, [r7, #0]
 8019d40:	2b00      	cmp	r3, #0
 8019d42:	dd0d      	ble.n	8019d60 <rt_completion_wait+0xc0>
            {
                /* reset the timeout of thread timer and start it */
                rt_timer_control(&(thread->thread_timer),
 8019d44:	68fb      	ldr	r3, [r7, #12]
 8019d46:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 8019d4a:	463b      	mov	r3, r7
 8019d4c:	4610      	mov	r0, r2
 8019d4e:	2100      	movs	r1, #0
 8019d50:	461a      	mov	r2, r3
 8019d52:	f7ff fbbd 	bl	80194d0 <rt_timer_control>
                                 RT_TIMER_CTRL_SET_TIME,
                                 &timeout);
                rt_timer_start(&(thread->thread_timer));
 8019d56:	68fb      	ldr	r3, [r7, #12]
 8019d58:	334c      	adds	r3, #76	; 0x4c
 8019d5a:	4618      	mov	r0, r3
 8019d5c:	f7ff fa72 	bl	8019244 <rt_timer_start>
            }
            /* enable interrupt */
            rt_hw_interrupt_enable(level);
 8019d60:	6938      	ldr	r0, [r7, #16]
 8019d62:	f7e6 fa35 	bl	80001d0 <rt_hw_interrupt_enable>

            /* do schedule */
            rt_schedule();
 8019d66:	f7fe fcf7 	bl	8018758 <rt_schedule>

            /* thread is waked up */
            result = thread->error;
 8019d6a:	68fb      	ldr	r3, [r7, #12]
 8019d6c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8019d6e:	617b      	str	r3, [r7, #20]

            level = rt_hw_interrupt_disable();
 8019d70:	f7e6 fa2a 	bl	80001c8 <rt_hw_interrupt_disable>
 8019d74:	6138      	str	r0, [r7, #16]
        }
    }
    /* clean completed flag */
    completion->flag = RT_UNCOMPLETED;
 8019d76:	687b      	ldr	r3, [r7, #4]
 8019d78:	2200      	movs	r2, #0
 8019d7a:	601a      	str	r2, [r3, #0]

__exit:
    rt_hw_interrupt_enable(level);
 8019d7c:	6938      	ldr	r0, [r7, #16]
 8019d7e:	f7e6 fa27 	bl	80001d0 <rt_hw_interrupt_enable>

    return result;
 8019d82:	697b      	ldr	r3, [r7, #20]
}
 8019d84:	4618      	mov	r0, r3
 8019d86:	3718      	adds	r7, #24
 8019d88:	46bd      	mov	sp, r7
 8019d8a:	bd80      	pop	{r7, pc}
 8019d8c:	08027d90 	.word	0x08027d90
 8019d90:	080292a4 	.word	0x080292a4
 8019d94:	08027da8 	.word	0x08027da8
 8019d98:	08027dd8 	.word	0x08027dd8
 8019d9c:	08027dfc 	.word	0x08027dfc

08019da0 <rt_completion_done>:
RTM_EXPORT(rt_completion_wait);

void rt_completion_done(struct rt_completion *completion)
{
 8019da0:	b580      	push	{r7, lr}
 8019da2:	b084      	sub	sp, #16
 8019da4:	af00      	add	r7, sp, #0
 8019da6:	6078      	str	r0, [r7, #4]
    rt_base_t level;
    RT_ASSERT(completion != RT_NULL);
 8019da8:	687b      	ldr	r3, [r7, #4]
 8019daa:	2b00      	cmp	r3, #0
 8019dac:	d104      	bne.n	8019db8 <rt_completion_done+0x18>
 8019dae:	4815      	ldr	r0, [pc, #84]	; (8019e04 <rt_completion_done+0x64>)
 8019db0:	4915      	ldr	r1, [pc, #84]	; (8019e08 <rt_completion_done+0x68>)
 8019db2:	2272      	movs	r2, #114	; 0x72
 8019db4:	f7fd fdfc 	bl	80179b0 <rt_assert_handler>

    if (completion->flag == RT_COMPLETED)
 8019db8:	687b      	ldr	r3, [r7, #4]
 8019dba:	681b      	ldr	r3, [r3, #0]
 8019dbc:	2b01      	cmp	r3, #1
 8019dbe:	d100      	bne.n	8019dc2 <rt_completion_done+0x22>
        return;
 8019dc0:	e01d      	b.n	8019dfe <rt_completion_done+0x5e>

    level = rt_hw_interrupt_disable();
 8019dc2:	f7e6 fa01 	bl	80001c8 <rt_hw_interrupt_disable>
 8019dc6:	60f8      	str	r0, [r7, #12]
    completion->flag = RT_COMPLETED;
 8019dc8:	687b      	ldr	r3, [r7, #4]
 8019dca:	2201      	movs	r2, #1
 8019dcc:	601a      	str	r2, [r3, #0]

    if (!rt_list_isempty(&(completion->suspended_list)))
 8019dce:	687b      	ldr	r3, [r7, #4]
 8019dd0:	3304      	adds	r3, #4
 8019dd2:	4618      	mov	r0, r3
 8019dd4:	f7ff ff30 	bl	8019c38 <rt_list_isempty>
 8019dd8:	4603      	mov	r3, r0
 8019dda:	2b00      	cmp	r3, #0
 8019ddc:	d10c      	bne.n	8019df8 <rt_completion_done+0x58>
    {
        /* there is one thread in suspended list */
        struct rt_thread *thread;

        /* get thread entry */
        thread = rt_list_entry(completion->suspended_list.next,
 8019dde:	687b      	ldr	r3, [r7, #4]
 8019de0:	685b      	ldr	r3, [r3, #4]
 8019de2:	3b14      	subs	r3, #20
 8019de4:	60bb      	str	r3, [r7, #8]
                               struct rt_thread,
                               tlist);

        /* resume it */
        rt_thread_resume(thread);
 8019de6:	68b8      	ldr	r0, [r7, #8]
 8019de8:	f7ff f8a8 	bl	8018f3c <rt_thread_resume>
        rt_hw_interrupt_enable(level);
 8019dec:	68f8      	ldr	r0, [r7, #12]
 8019dee:	f7e6 f9ef 	bl	80001d0 <rt_hw_interrupt_enable>

        /* perform a schedule */
        rt_schedule();
 8019df2:	f7fe fcb1 	bl	8018758 <rt_schedule>
 8019df6:	e002      	b.n	8019dfe <rt_completion_done+0x5e>
    }
    else
    {
        rt_hw_interrupt_enable(level);
 8019df8:	68f8      	ldr	r0, [r7, #12]
 8019dfa:	f7e6 f9e9 	bl	80001d0 <rt_hw_interrupt_enable>
    }
}
 8019dfe:	3710      	adds	r7, #16
 8019e00:	46bd      	mov	sp, r7
 8019e02:	bd80      	pop	{r7, pc}
 8019e04:	08027d90 	.word	0x08027d90
 8019e08:	080292b8 	.word	0x080292b8

08019e0c <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 8019e0c:	b480      	push	{r7}
 8019e0e:	b083      	sub	sp, #12
 8019e10:	af00      	add	r7, sp, #0
 8019e12:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 8019e14:	687b      	ldr	r3, [r7, #4]
 8019e16:	687a      	ldr	r2, [r7, #4]
 8019e18:	605a      	str	r2, [r3, #4]
 8019e1a:	687b      	ldr	r3, [r7, #4]
 8019e1c:	685a      	ldr	r2, [r3, #4]
 8019e1e:	687b      	ldr	r3, [r7, #4]
 8019e20:	601a      	str	r2, [r3, #0]
}
 8019e22:	370c      	adds	r7, #12
 8019e24:	46bd      	mov	sp, r7
 8019e26:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019e2a:	4770      	bx	lr

08019e2c <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 8019e2c:	b480      	push	{r7}
 8019e2e:	b083      	sub	sp, #12
 8019e30:	af00      	add	r7, sp, #0
 8019e32:	6078      	str	r0, [r7, #4]
 8019e34:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 8019e36:	687b      	ldr	r3, [r7, #4]
 8019e38:	685b      	ldr	r3, [r3, #4]
 8019e3a:	683a      	ldr	r2, [r7, #0]
 8019e3c:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 8019e3e:	687b      	ldr	r3, [r7, #4]
 8019e40:	685a      	ldr	r2, [r3, #4]
 8019e42:	683b      	ldr	r3, [r7, #0]
 8019e44:	605a      	str	r2, [r3, #4]

    l->prev = n;
 8019e46:	687b      	ldr	r3, [r7, #4]
 8019e48:	683a      	ldr	r2, [r7, #0]
 8019e4a:	605a      	str	r2, [r3, #4]
    n->next = l;
 8019e4c:	683b      	ldr	r3, [r7, #0]
 8019e4e:	687a      	ldr	r2, [r7, #4]
 8019e50:	601a      	str	r2, [r3, #0]
}
 8019e52:	370c      	adds	r7, #12
 8019e54:	46bd      	mov	sp, r7
 8019e56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019e5a:	4770      	bx	lr

08019e5c <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 8019e5c:	b480      	push	{r7}
 8019e5e:	b083      	sub	sp, #12
 8019e60:	af00      	add	r7, sp, #0
 8019e62:	6078      	str	r0, [r7, #4]
    return l->next == l;
 8019e64:	687b      	ldr	r3, [r7, #4]
 8019e66:	681a      	ldr	r2, [r3, #0]
 8019e68:	687b      	ldr	r3, [r7, #4]
 8019e6a:	429a      	cmp	r2, r3
 8019e6c:	bf0c      	ite	eq
 8019e6e:	2301      	moveq	r3, #1
 8019e70:	2300      	movne	r3, #0
 8019e72:	b2db      	uxtb	r3, r3
}
 8019e74:	4618      	mov	r0, r3
 8019e76:	370c      	adds	r7, #12
 8019e78:	46bd      	mov	sp, r7
 8019e7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019e7e:	4770      	bx	lr

08019e80 <rt_data_queue_init>:
rt_err_t
rt_data_queue_init(struct rt_data_queue *queue,
                   rt_uint16_t size,
                   rt_uint16_t lwm,
                   void (*evt_notify)(struct rt_data_queue *queue, rt_uint32_t event))
{
 8019e80:	b580      	push	{r7, lr}
 8019e82:	b084      	sub	sp, #16
 8019e84:	af00      	add	r7, sp, #0
 8019e86:	60f8      	str	r0, [r7, #12]
 8019e88:	607b      	str	r3, [r7, #4]
 8019e8a:	460b      	mov	r3, r1
 8019e8c:	817b      	strh	r3, [r7, #10]
 8019e8e:	4613      	mov	r3, r2
 8019e90:	813b      	strh	r3, [r7, #8]
    RT_ASSERT(queue != RT_NULL);
 8019e92:	68fb      	ldr	r3, [r7, #12]
 8019e94:	2b00      	cmp	r3, #0
 8019e96:	d104      	bne.n	8019ea2 <rt_data_queue_init+0x22>
 8019e98:	481a      	ldr	r0, [pc, #104]	; (8019f04 <rt_data_queue_init+0x84>)
 8019e9a:	491b      	ldr	r1, [pc, #108]	; (8019f08 <rt_data_queue_init+0x88>)
 8019e9c:	2229      	movs	r2, #41	; 0x29
 8019e9e:	f7fd fd87 	bl	80179b0 <rt_assert_handler>

    queue->evt_notify = evt_notify;
 8019ea2:	68fb      	ldr	r3, [r7, #12]
 8019ea4:	687a      	ldr	r2, [r7, #4]
 8019ea6:	621a      	str	r2, [r3, #32]

    queue->size = size;
 8019ea8:	68fb      	ldr	r3, [r7, #12]
 8019eaa:	897a      	ldrh	r2, [r7, #10]
 8019eac:	801a      	strh	r2, [r3, #0]
    queue->lwm = lwm;
 8019eae:	68fb      	ldr	r3, [r7, #12]
 8019eb0:	893a      	ldrh	r2, [r7, #8]
 8019eb2:	805a      	strh	r2, [r3, #2]
    queue->waiting_lwm = RT_FALSE;
 8019eb4:	68fb      	ldr	r3, [r7, #12]
 8019eb6:	2200      	movs	r2, #0
 8019eb8:	605a      	str	r2, [r3, #4]

    queue->get_index = 0;
 8019eba:	68fb      	ldr	r3, [r7, #12]
 8019ebc:	2200      	movs	r2, #0
 8019ebe:	811a      	strh	r2, [r3, #8]
    queue->put_index = 0;
 8019ec0:	68fb      	ldr	r3, [r7, #12]
 8019ec2:	2200      	movs	r2, #0
 8019ec4:	815a      	strh	r2, [r3, #10]

    rt_list_init(&(queue->suspended_push_list));
 8019ec6:	68fb      	ldr	r3, [r7, #12]
 8019ec8:	3310      	adds	r3, #16
 8019eca:	4618      	mov	r0, r3
 8019ecc:	f7ff ff9e 	bl	8019e0c <rt_list_init>
    rt_list_init(&(queue->suspended_pop_list));
 8019ed0:	68fb      	ldr	r3, [r7, #12]
 8019ed2:	3318      	adds	r3, #24
 8019ed4:	4618      	mov	r0, r3
 8019ed6:	f7ff ff99 	bl	8019e0c <rt_list_init>

    queue->queue = (struct rt_data_item *)rt_malloc(sizeof(struct rt_data_item) * size);
 8019eda:	897b      	ldrh	r3, [r7, #10]
 8019edc:	00db      	lsls	r3, r3, #3
 8019ede:	4618      	mov	r0, r3
 8019ee0:	f7fd fe9a 	bl	8017c18 <rt_malloc>
 8019ee4:	4602      	mov	r2, r0
 8019ee6:	68fb      	ldr	r3, [r7, #12]
 8019ee8:	60da      	str	r2, [r3, #12]
    if (queue->queue == RT_NULL)
 8019eea:	68fb      	ldr	r3, [r7, #12]
 8019eec:	68db      	ldr	r3, [r3, #12]
 8019eee:	2b00      	cmp	r3, #0
 8019ef0:	d102      	bne.n	8019ef8 <rt_data_queue_init+0x78>
    {
        return -RT_ENOMEM;
 8019ef2:	f06f 0304 	mvn.w	r3, #4
 8019ef6:	e000      	b.n	8019efa <rt_data_queue_init+0x7a>
    }

    return RT_EOK;
 8019ef8:	2300      	movs	r3, #0
}
 8019efa:	4618      	mov	r0, r3
 8019efc:	3710      	adds	r7, #16
 8019efe:	46bd      	mov	sp, r7
 8019f00:	bd80      	pop	{r7, pc}
 8019f02:	bf00      	nop
 8019f04:	08027e00 	.word	0x08027e00
 8019f08:	080292cc 	.word	0x080292cc

08019f0c <rt_data_queue_push>:

rt_err_t rt_data_queue_push(struct rt_data_queue *queue,
                            const void *data_ptr,
                            rt_size_t data_size,
                            rt_int32_t timeout)
{
 8019f0c:	b580      	push	{r7, lr}
 8019f0e:	b08a      	sub	sp, #40	; 0x28
 8019f10:	af00      	add	r7, sp, #0
 8019f12:	60f8      	str	r0, [r7, #12]
 8019f14:	60b9      	str	r1, [r7, #8]
 8019f16:	607a      	str	r2, [r7, #4]
 8019f18:	603b      	str	r3, [r7, #0]
    rt_uint16_t mask;
    rt_ubase_t  level;
    rt_thread_t thread;
    rt_err_t    result;
    
    RT_ASSERT(queue != RT_NULL);
 8019f1a:	68fb      	ldr	r3, [r7, #12]
 8019f1c:	2b00      	cmp	r3, #0
 8019f1e:	d104      	bne.n	8019f2a <rt_data_queue_push+0x1e>
 8019f20:	4859      	ldr	r0, [pc, #356]	; (801a088 <rt_data_queue_push+0x17c>)
 8019f22:	495a      	ldr	r1, [pc, #360]	; (801a08c <rt_data_queue_push+0x180>)
 8019f24:	224b      	movs	r2, #75	; 0x4b
 8019f26:	f7fd fd43 	bl	80179b0 <rt_assert_handler>

    result = RT_EOK;
 8019f2a:	2300      	movs	r3, #0
 8019f2c:	623b      	str	r3, [r7, #32]
    thread = rt_thread_self();
 8019f2e:	f7fe fe4f 	bl	8018bd0 <rt_thread_self>
 8019f32:	61f8      	str	r0, [r7, #28]
    mask = queue->size - 1;
 8019f34:	68fb      	ldr	r3, [r7, #12]
 8019f36:	881b      	ldrh	r3, [r3, #0]
 8019f38:	3b01      	subs	r3, #1
 8019f3a:	837b      	strh	r3, [r7, #26]

    level = rt_hw_interrupt_disable();
 8019f3c:	f7e6 f944 	bl	80001c8 <rt_hw_interrupt_disable>
 8019f40:	4603      	mov	r3, r0
 8019f42:	627b      	str	r3, [r7, #36]	; 0x24
    while (queue->put_index - queue->get_index == queue->size)
 8019f44:	e04e      	b.n	8019fe4 <rt_data_queue_push+0xd8>
    {
        queue->waiting_lwm = RT_TRUE;
 8019f46:	68fb      	ldr	r3, [r7, #12]
 8019f48:	2201      	movs	r2, #1
 8019f4a:	605a      	str	r2, [r3, #4]

        /* queue is full */
        if (timeout == 0)
 8019f4c:	683b      	ldr	r3, [r7, #0]
 8019f4e:	2b00      	cmp	r3, #0
 8019f50:	d103      	bne.n	8019f5a <rt_data_queue_push+0x4e>
        {
            result = -RT_ETIMEOUT;
 8019f52:	f06f 0301 	mvn.w	r3, #1
 8019f56:	623b      	str	r3, [r7, #32]

            goto __exit;
 8019f58:	e081      	b.n	801a05e <rt_data_queue_push+0x152>
        }

        /* current context checking */
        RT_DEBUG_NOT_IN_INTERRUPT;
 8019f5a:	f7e6 f935 	bl	80001c8 <rt_hw_interrupt_disable>
 8019f5e:	6178      	str	r0, [r7, #20]
 8019f60:	f7fc fec8 	bl	8016cf4 <rt_interrupt_get_nest>
 8019f64:	4603      	mov	r3, r0
 8019f66:	2b00      	cmp	r3, #0
 8019f68:	d008      	beq.n	8019f7c <rt_data_queue_push+0x70>
 8019f6a:	4849      	ldr	r0, [pc, #292]	; (801a090 <rt_data_queue_push+0x184>)
 8019f6c:	4947      	ldr	r1, [pc, #284]	; (801a08c <rt_data_queue_push+0x180>)
 8019f6e:	f7fd fca5 	bl	80178bc <rt_kprintf>
 8019f72:	4848      	ldr	r0, [pc, #288]	; (801a094 <rt_data_queue_push+0x188>)
 8019f74:	4945      	ldr	r1, [pc, #276]	; (801a08c <rt_data_queue_push+0x180>)
 8019f76:	225f      	movs	r2, #95	; 0x5f
 8019f78:	f7fd fd1a 	bl	80179b0 <rt_assert_handler>
 8019f7c:	6978      	ldr	r0, [r7, #20]
 8019f7e:	f7e6 f927 	bl	80001d0 <rt_hw_interrupt_enable>

        /* reset thread error number */
        thread->error = RT_EOK;
 8019f82:	69fb      	ldr	r3, [r7, #28]
 8019f84:	2200      	movs	r2, #0
 8019f86:	631a      	str	r2, [r3, #48]	; 0x30
        
        /* suspend thread on the push list */
        rt_thread_suspend(thread);
 8019f88:	69f8      	ldr	r0, [r7, #28]
 8019f8a:	f7fe ffa7 	bl	8018edc <rt_thread_suspend>
        rt_list_insert_before(&(queue->suspended_push_list), &(thread->tlist));
 8019f8e:	68fb      	ldr	r3, [r7, #12]
 8019f90:	f103 0210 	add.w	r2, r3, #16
 8019f94:	69fb      	ldr	r3, [r7, #28]
 8019f96:	3314      	adds	r3, #20
 8019f98:	4610      	mov	r0, r2
 8019f9a:	4619      	mov	r1, r3
 8019f9c:	f7ff ff46 	bl	8019e2c <rt_list_insert_before>
        /* start timer */
        if (timeout > 0)
 8019fa0:	683b      	ldr	r3, [r7, #0]
 8019fa2:	2b00      	cmp	r3, #0
 8019fa4:	dd0d      	ble.n	8019fc2 <rt_data_queue_push+0xb6>
        {
            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
 8019fa6:	69fb      	ldr	r3, [r7, #28]
 8019fa8:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 8019fac:	463b      	mov	r3, r7
 8019fae:	4610      	mov	r0, r2
 8019fb0:	2100      	movs	r1, #0
 8019fb2:	461a      	mov	r2, r3
 8019fb4:	f7ff fa8c 	bl	80194d0 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
 8019fb8:	69fb      	ldr	r3, [r7, #28]
 8019fba:	334c      	adds	r3, #76	; 0x4c
 8019fbc:	4618      	mov	r0, r3
 8019fbe:	f7ff f941 	bl	8019244 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 8019fc2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019fc4:	4618      	mov	r0, r3
 8019fc6:	f7e6 f903 	bl	80001d0 <rt_hw_interrupt_enable>

        /* do schedule */
        rt_schedule();
 8019fca:	f7fe fbc5 	bl	8018758 <rt_schedule>

        /* thread is waked up */
        result = thread->error;
 8019fce:	69fb      	ldr	r3, [r7, #28]
 8019fd0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8019fd2:	623b      	str	r3, [r7, #32]
        level = rt_hw_interrupt_disable();
 8019fd4:	f7e6 f8f8 	bl	80001c8 <rt_hw_interrupt_disable>
 8019fd8:	4603      	mov	r3, r0
 8019fda:	627b      	str	r3, [r7, #36]	; 0x24
        if (result != RT_EOK) goto __exit;
 8019fdc:	6a3b      	ldr	r3, [r7, #32]
 8019fde:	2b00      	cmp	r3, #0
 8019fe0:	d000      	beq.n	8019fe4 <rt_data_queue_push+0xd8>
 8019fe2:	e03c      	b.n	801a05e <rt_data_queue_push+0x152>
    result = RT_EOK;
    thread = rt_thread_self();
    mask = queue->size - 1;

    level = rt_hw_interrupt_disable();
    while (queue->put_index - queue->get_index == queue->size)
 8019fe4:	68fb      	ldr	r3, [r7, #12]
 8019fe6:	895b      	ldrh	r3, [r3, #10]
 8019fe8:	461a      	mov	r2, r3
 8019fea:	68fb      	ldr	r3, [r7, #12]
 8019fec:	891b      	ldrh	r3, [r3, #8]
 8019fee:	1ad3      	subs	r3, r2, r3
 8019ff0:	68fa      	ldr	r2, [r7, #12]
 8019ff2:	8812      	ldrh	r2, [r2, #0]
 8019ff4:	4293      	cmp	r3, r2
 8019ff6:	d0a6      	beq.n	8019f46 <rt_data_queue_push+0x3a>
        result = thread->error;
        level = rt_hw_interrupt_disable();
        if (result != RT_EOK) goto __exit;
    }

    queue->queue[queue->put_index & mask].data_ptr  = data_ptr;
 8019ff8:	68fb      	ldr	r3, [r7, #12]
 8019ffa:	68da      	ldr	r2, [r3, #12]
 8019ffc:	68fb      	ldr	r3, [r7, #12]
 8019ffe:	8959      	ldrh	r1, [r3, #10]
 801a000:	8b7b      	ldrh	r3, [r7, #26]
 801a002:	400b      	ands	r3, r1
 801a004:	b29b      	uxth	r3, r3
 801a006:	00db      	lsls	r3, r3, #3
 801a008:	4413      	add	r3, r2
 801a00a:	68ba      	ldr	r2, [r7, #8]
 801a00c:	601a      	str	r2, [r3, #0]
    queue->queue[queue->put_index & mask].data_size = data_size;
 801a00e:	68fb      	ldr	r3, [r7, #12]
 801a010:	68da      	ldr	r2, [r3, #12]
 801a012:	68fb      	ldr	r3, [r7, #12]
 801a014:	8959      	ldrh	r1, [r3, #10]
 801a016:	8b7b      	ldrh	r3, [r7, #26]
 801a018:	400b      	ands	r3, r1
 801a01a:	b29b      	uxth	r3, r3
 801a01c:	00db      	lsls	r3, r3, #3
 801a01e:	4413      	add	r3, r2
 801a020:	687a      	ldr	r2, [r7, #4]
 801a022:	605a      	str	r2, [r3, #4]
    queue->put_index += 1;
 801a024:	68fb      	ldr	r3, [r7, #12]
 801a026:	895b      	ldrh	r3, [r3, #10]
 801a028:	3301      	adds	r3, #1
 801a02a:	b29a      	uxth	r2, r3
 801a02c:	68fb      	ldr	r3, [r7, #12]
 801a02e:	815a      	strh	r2, [r3, #10]

    if (!rt_list_isempty(&(queue->suspended_pop_list)))
 801a030:	68fb      	ldr	r3, [r7, #12]
 801a032:	3318      	adds	r3, #24
 801a034:	4618      	mov	r0, r3
 801a036:	f7ff ff11 	bl	8019e5c <rt_list_isempty>
 801a03a:	4603      	mov	r3, r0
 801a03c:	2b00      	cmp	r3, #0
 801a03e:	d10e      	bne.n	801a05e <rt_data_queue_push+0x152>
    {
        /* there is at least one thread in suspended list */

        /* get thread entry */
        thread = rt_list_entry(queue->suspended_pop_list.next,
 801a040:	68fb      	ldr	r3, [r7, #12]
 801a042:	699b      	ldr	r3, [r3, #24]
 801a044:	3b14      	subs	r3, #20
 801a046:	61fb      	str	r3, [r7, #28]
                               struct rt_thread,
                               tlist);

        /* resume it */
        rt_thread_resume(thread);
 801a048:	69f8      	ldr	r0, [r7, #28]
 801a04a:	f7fe ff77 	bl	8018f3c <rt_thread_resume>
        rt_hw_interrupt_enable(level);
 801a04e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a050:	4618      	mov	r0, r3
 801a052:	f7e6 f8bd 	bl	80001d0 <rt_hw_interrupt_enable>

        /* perform a schedule */
        rt_schedule();
 801a056:	f7fe fb7f 	bl	8018758 <rt_schedule>

        return result;
 801a05a:	6a3b      	ldr	r3, [r7, #32]
 801a05c:	e010      	b.n	801a080 <rt_data_queue_push+0x174>
    }

__exit:
    rt_hw_interrupt_enable(level);
 801a05e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a060:	4618      	mov	r0, r3
 801a062:	f7e6 f8b5 	bl	80001d0 <rt_hw_interrupt_enable>
    if ((result == RT_EOK) && queue->evt_notify != RT_NULL)
 801a066:	6a3b      	ldr	r3, [r7, #32]
 801a068:	2b00      	cmp	r3, #0
 801a06a:	d108      	bne.n	801a07e <rt_data_queue_push+0x172>
 801a06c:	68fb      	ldr	r3, [r7, #12]
 801a06e:	6a1b      	ldr	r3, [r3, #32]
 801a070:	2b00      	cmp	r3, #0
 801a072:	d004      	beq.n	801a07e <rt_data_queue_push+0x172>
    {
        queue->evt_notify(queue, RT_DATAQUEUE_EVENT_PUSH);
 801a074:	68fb      	ldr	r3, [r7, #12]
 801a076:	6a1b      	ldr	r3, [r3, #32]
 801a078:	68f8      	ldr	r0, [r7, #12]
 801a07a:	2102      	movs	r1, #2
 801a07c:	4798      	blx	r3
    }

    return result;
 801a07e:	6a3b      	ldr	r3, [r7, #32]
}
 801a080:	4618      	mov	r0, r3
 801a082:	3728      	adds	r7, #40	; 0x28
 801a084:	46bd      	mov	sp, r7
 801a086:	bd80      	pop	{r7, pc}
 801a088:	08027e00 	.word	0x08027e00
 801a08c:	080292e0 	.word	0x080292e0
 801a090:	08027e14 	.word	0x08027e14
 801a094:	08027e38 	.word	0x08027e38

0801a098 <rt_data_queue_pop>:

rt_err_t rt_data_queue_pop(struct rt_data_queue *queue,
                           const void** data_ptr,
                           rt_size_t *size, 
                           rt_int32_t timeout)
{
 801a098:	b580      	push	{r7, lr}
 801a09a:	b08a      	sub	sp, #40	; 0x28
 801a09c:	af00      	add	r7, sp, #0
 801a09e:	60f8      	str	r0, [r7, #12]
 801a0a0:	60b9      	str	r1, [r7, #8]
 801a0a2:	607a      	str	r2, [r7, #4]
 801a0a4:	603b      	str	r3, [r7, #0]
    rt_ubase_t  level;
    rt_thread_t thread;
    rt_err_t    result;
    rt_uint16_t mask;

    RT_ASSERT(queue != RT_NULL);
 801a0a6:	68fb      	ldr	r3, [r7, #12]
 801a0a8:	2b00      	cmp	r3, #0
 801a0aa:	d104      	bne.n	801a0b6 <rt_data_queue_pop+0x1e>
 801a0ac:	486c      	ldr	r0, [pc, #432]	; (801a260 <rt_data_queue_pop+0x1c8>)
 801a0ae:	496d      	ldr	r1, [pc, #436]	; (801a264 <rt_data_queue_pop+0x1cc>)
 801a0b0:	22a9      	movs	r2, #169	; 0xa9
 801a0b2:	f7fd fc7d 	bl	80179b0 <rt_assert_handler>
    RT_ASSERT(data_ptr != RT_NULL);
 801a0b6:	68bb      	ldr	r3, [r7, #8]
 801a0b8:	2b00      	cmp	r3, #0
 801a0ba:	d104      	bne.n	801a0c6 <rt_data_queue_pop+0x2e>
 801a0bc:	486a      	ldr	r0, [pc, #424]	; (801a268 <rt_data_queue_pop+0x1d0>)
 801a0be:	4969      	ldr	r1, [pc, #420]	; (801a264 <rt_data_queue_pop+0x1cc>)
 801a0c0:	22aa      	movs	r2, #170	; 0xaa
 801a0c2:	f7fd fc75 	bl	80179b0 <rt_assert_handler>
    RT_ASSERT(size != RT_NULL);
 801a0c6:	687b      	ldr	r3, [r7, #4]
 801a0c8:	2b00      	cmp	r3, #0
 801a0ca:	d104      	bne.n	801a0d6 <rt_data_queue_pop+0x3e>
 801a0cc:	4867      	ldr	r0, [pc, #412]	; (801a26c <rt_data_queue_pop+0x1d4>)
 801a0ce:	4965      	ldr	r1, [pc, #404]	; (801a264 <rt_data_queue_pop+0x1cc>)
 801a0d0:	22ab      	movs	r2, #171	; 0xab
 801a0d2:	f7fd fc6d 	bl	80179b0 <rt_assert_handler>

    result = RT_EOK;
 801a0d6:	2300      	movs	r3, #0
 801a0d8:	623b      	str	r3, [r7, #32]
    thread = rt_thread_self();
 801a0da:	f7fe fd79 	bl	8018bd0 <rt_thread_self>
 801a0de:	61f8      	str	r0, [r7, #28]
    mask   = queue->size - 1;
 801a0e0:	68fb      	ldr	r3, [r7, #12]
 801a0e2:	881b      	ldrh	r3, [r3, #0]
 801a0e4:	3b01      	subs	r3, #1
 801a0e6:	837b      	strh	r3, [r7, #26]

    level = rt_hw_interrupt_disable();
 801a0e8:	f7e6 f86e 	bl	80001c8 <rt_hw_interrupt_disable>
 801a0ec:	4603      	mov	r3, r0
 801a0ee:	627b      	str	r3, [r7, #36]	; 0x24
    while (queue->get_index == queue->put_index)
 801a0f0:	e04b      	b.n	801a18a <rt_data_queue_pop+0xf2>
    {
        /* queue is empty */
        if (timeout == 0)
 801a0f2:	683b      	ldr	r3, [r7, #0]
 801a0f4:	2b00      	cmp	r3, #0
 801a0f6:	d103      	bne.n	801a100 <rt_data_queue_pop+0x68>
        {
            result = -RT_ETIMEOUT;
 801a0f8:	f06f 0301 	mvn.w	r3, #1
 801a0fc:	623b      	str	r3, [r7, #32]
            goto __exit;
 801a0fe:	e099      	b.n	801a234 <rt_data_queue_pop+0x19c>
        }

        /* current context checking */
        RT_DEBUG_NOT_IN_INTERRUPT;
 801a100:	f7e6 f862 	bl	80001c8 <rt_hw_interrupt_disable>
 801a104:	6178      	str	r0, [r7, #20]
 801a106:	f7fc fdf5 	bl	8016cf4 <rt_interrupt_get_nest>
 801a10a:	4603      	mov	r3, r0
 801a10c:	2b00      	cmp	r3, #0
 801a10e:	d008      	beq.n	801a122 <rt_data_queue_pop+0x8a>
 801a110:	4857      	ldr	r0, [pc, #348]	; (801a270 <rt_data_queue_pop+0x1d8>)
 801a112:	4954      	ldr	r1, [pc, #336]	; (801a264 <rt_data_queue_pop+0x1cc>)
 801a114:	f7fd fbd2 	bl	80178bc <rt_kprintf>
 801a118:	4856      	ldr	r0, [pc, #344]	; (801a274 <rt_data_queue_pop+0x1dc>)
 801a11a:	4952      	ldr	r1, [pc, #328]	; (801a264 <rt_data_queue_pop+0x1cc>)
 801a11c:	22bc      	movs	r2, #188	; 0xbc
 801a11e:	f7fd fc47 	bl	80179b0 <rt_assert_handler>
 801a122:	6978      	ldr	r0, [r7, #20]
 801a124:	f7e6 f854 	bl	80001d0 <rt_hw_interrupt_enable>

        /* reset thread error number */
        thread->error = RT_EOK;
 801a128:	69fb      	ldr	r3, [r7, #28]
 801a12a:	2200      	movs	r2, #0
 801a12c:	631a      	str	r2, [r3, #48]	; 0x30
        
        /* suspend thread on the pop list */
        rt_thread_suspend(thread);
 801a12e:	69f8      	ldr	r0, [r7, #28]
 801a130:	f7fe fed4 	bl	8018edc <rt_thread_suspend>
        rt_list_insert_before(&(queue->suspended_pop_list), &(thread->tlist));
 801a134:	68fb      	ldr	r3, [r7, #12]
 801a136:	f103 0218 	add.w	r2, r3, #24
 801a13a:	69fb      	ldr	r3, [r7, #28]
 801a13c:	3314      	adds	r3, #20
 801a13e:	4610      	mov	r0, r2
 801a140:	4619      	mov	r1, r3
 801a142:	f7ff fe73 	bl	8019e2c <rt_list_insert_before>
        /* start timer */
        if (timeout > 0)
 801a146:	683b      	ldr	r3, [r7, #0]
 801a148:	2b00      	cmp	r3, #0
 801a14a:	dd0d      	ble.n	801a168 <rt_data_queue_pop+0xd0>
        {
            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
 801a14c:	69fb      	ldr	r3, [r7, #28]
 801a14e:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 801a152:	463b      	mov	r3, r7
 801a154:	4610      	mov	r0, r2
 801a156:	2100      	movs	r1, #0
 801a158:	461a      	mov	r2, r3
 801a15a:	f7ff f9b9 	bl	80194d0 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
 801a15e:	69fb      	ldr	r3, [r7, #28]
 801a160:	334c      	adds	r3, #76	; 0x4c
 801a162:	4618      	mov	r0, r3
 801a164:	f7ff f86e 	bl	8019244 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 801a168:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a16a:	4618      	mov	r0, r3
 801a16c:	f7e6 f830 	bl	80001d0 <rt_hw_interrupt_enable>

        /* do schedule */
        rt_schedule();
 801a170:	f7fe faf2 	bl	8018758 <rt_schedule>

        /* thread is waked up */
        result = thread->error;
 801a174:	69fb      	ldr	r3, [r7, #28]
 801a176:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801a178:	623b      	str	r3, [r7, #32]
        level  = rt_hw_interrupt_disable();
 801a17a:	f7e6 f825 	bl	80001c8 <rt_hw_interrupt_disable>
 801a17e:	4603      	mov	r3, r0
 801a180:	627b      	str	r3, [r7, #36]	; 0x24
        if (result != RT_EOK)
 801a182:	6a3b      	ldr	r3, [r7, #32]
 801a184:	2b00      	cmp	r3, #0
 801a186:	d000      	beq.n	801a18a <rt_data_queue_pop+0xf2>
            goto __exit;
 801a188:	e054      	b.n	801a234 <rt_data_queue_pop+0x19c>
    result = RT_EOK;
    thread = rt_thread_self();
    mask   = queue->size - 1;

    level = rt_hw_interrupt_disable();
    while (queue->get_index == queue->put_index)
 801a18a:	68fb      	ldr	r3, [r7, #12]
 801a18c:	891a      	ldrh	r2, [r3, #8]
 801a18e:	68fb      	ldr	r3, [r7, #12]
 801a190:	895b      	ldrh	r3, [r3, #10]
 801a192:	429a      	cmp	r2, r3
 801a194:	d0ad      	beq.n	801a0f2 <rt_data_queue_pop+0x5a>
        level  = rt_hw_interrupt_disable();
        if (result != RT_EOK)
            goto __exit;
    }

    *data_ptr = queue->queue[queue->get_index & mask].data_ptr;
 801a196:	68fb      	ldr	r3, [r7, #12]
 801a198:	68da      	ldr	r2, [r3, #12]
 801a19a:	68fb      	ldr	r3, [r7, #12]
 801a19c:	8919      	ldrh	r1, [r3, #8]
 801a19e:	8b7b      	ldrh	r3, [r7, #26]
 801a1a0:	400b      	ands	r3, r1
 801a1a2:	b29b      	uxth	r3, r3
 801a1a4:	00db      	lsls	r3, r3, #3
 801a1a6:	4413      	add	r3, r2
 801a1a8:	681a      	ldr	r2, [r3, #0]
 801a1aa:	68bb      	ldr	r3, [r7, #8]
 801a1ac:	601a      	str	r2, [r3, #0]
    *size     = queue->queue[queue->get_index & mask].data_size;
 801a1ae:	68fb      	ldr	r3, [r7, #12]
 801a1b0:	68da      	ldr	r2, [r3, #12]
 801a1b2:	68fb      	ldr	r3, [r7, #12]
 801a1b4:	8919      	ldrh	r1, [r3, #8]
 801a1b6:	8b7b      	ldrh	r3, [r7, #26]
 801a1b8:	400b      	ands	r3, r1
 801a1ba:	b29b      	uxth	r3, r3
 801a1bc:	00db      	lsls	r3, r3, #3
 801a1be:	4413      	add	r3, r2
 801a1c0:	685a      	ldr	r2, [r3, #4]
 801a1c2:	687b      	ldr	r3, [r7, #4]
 801a1c4:	601a      	str	r2, [r3, #0]

    queue->get_index += 1;
 801a1c6:	68fb      	ldr	r3, [r7, #12]
 801a1c8:	891b      	ldrh	r3, [r3, #8]
 801a1ca:	3301      	adds	r3, #1
 801a1cc:	b29a      	uxth	r2, r3
 801a1ce:	68fb      	ldr	r3, [r7, #12]
 801a1d0:	811a      	strh	r2, [r3, #8]

    if ((queue->waiting_lwm == RT_TRUE) && 
 801a1d2:	68fb      	ldr	r3, [r7, #12]
 801a1d4:	685b      	ldr	r3, [r3, #4]
 801a1d6:	2b01      	cmp	r3, #1
 801a1d8:	d12c      	bne.n	801a234 <rt_data_queue_pop+0x19c>
        (queue->put_index - queue->get_index) <= queue->lwm)
 801a1da:	68fb      	ldr	r3, [r7, #12]
 801a1dc:	895b      	ldrh	r3, [r3, #10]
 801a1de:	461a      	mov	r2, r3
 801a1e0:	68fb      	ldr	r3, [r7, #12]
 801a1e2:	891b      	ldrh	r3, [r3, #8]
 801a1e4:	1ad3      	subs	r3, r2, r3
 801a1e6:	68fa      	ldr	r2, [r7, #12]
 801a1e8:	8852      	ldrh	r2, [r2, #2]
    *data_ptr = queue->queue[queue->get_index & mask].data_ptr;
    *size     = queue->queue[queue->get_index & mask].data_size;

    queue->get_index += 1;

    if ((queue->waiting_lwm == RT_TRUE) && 
 801a1ea:	4293      	cmp	r3, r2
 801a1ec:	dc22      	bgt.n	801a234 <rt_data_queue_pop+0x19c>
        (queue->put_index - queue->get_index) <= queue->lwm)
    {
        queue->waiting_lwm = RT_FALSE;
 801a1ee:	68fb      	ldr	r3, [r7, #12]
 801a1f0:	2200      	movs	r2, #0
 801a1f2:	605a      	str	r2, [r3, #4]

        /*
         * there is at least one thread in suspended list
         * and less than low water mark
         */
        if (!rt_list_isempty(&(queue->suspended_push_list)))
 801a1f4:	68fb      	ldr	r3, [r7, #12]
 801a1f6:	3310      	adds	r3, #16
 801a1f8:	4618      	mov	r0, r3
 801a1fa:	f7ff fe2f 	bl	8019e5c <rt_list_isempty>
 801a1fe:	4603      	mov	r3, r0
 801a200:	2b00      	cmp	r3, #0
 801a202:	d10c      	bne.n	801a21e <rt_data_queue_pop+0x186>
        {
            /* get thread entry */
            thread = rt_list_entry(queue->suspended_push_list.next,
 801a204:	68fb      	ldr	r3, [r7, #12]
 801a206:	691b      	ldr	r3, [r3, #16]
 801a208:	3b14      	subs	r3, #20
 801a20a:	61fb      	str	r3, [r7, #28]
                                   struct rt_thread,
                                   tlist);

            /* resume it */
            rt_thread_resume(thread);
 801a20c:	69f8      	ldr	r0, [r7, #28]
 801a20e:	f7fe fe95 	bl	8018f3c <rt_thread_resume>
            rt_hw_interrupt_enable(level);
 801a212:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a214:	4618      	mov	r0, r3
 801a216:	f7e5 ffdb 	bl	80001d0 <rt_hw_interrupt_enable>

            /* perform a schedule */
            rt_schedule();
 801a21a:	f7fe fa9d 	bl	8018758 <rt_schedule>
        }

        if (queue->evt_notify != RT_NULL)
 801a21e:	68fb      	ldr	r3, [r7, #12]
 801a220:	6a1b      	ldr	r3, [r3, #32]
 801a222:	2b00      	cmp	r3, #0
 801a224:	d004      	beq.n	801a230 <rt_data_queue_pop+0x198>
            queue->evt_notify(queue, RT_DATAQUEUE_EVENT_LWM);
 801a226:	68fb      	ldr	r3, [r7, #12]
 801a228:	6a1b      	ldr	r3, [r3, #32]
 801a22a:	68f8      	ldr	r0, [r7, #12]
 801a22c:	2103      	movs	r1, #3
 801a22e:	4798      	blx	r3

        return result;
 801a230:	6a3b      	ldr	r3, [r7, #32]
 801a232:	e010      	b.n	801a256 <rt_data_queue_pop+0x1be>
    }

__exit:
    rt_hw_interrupt_enable(level);
 801a234:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a236:	4618      	mov	r0, r3
 801a238:	f7e5 ffca 	bl	80001d0 <rt_hw_interrupt_enable>
    if ((result == RT_EOK) && (queue->evt_notify != RT_NULL))
 801a23c:	6a3b      	ldr	r3, [r7, #32]
 801a23e:	2b00      	cmp	r3, #0
 801a240:	d108      	bne.n	801a254 <rt_data_queue_pop+0x1bc>
 801a242:	68fb      	ldr	r3, [r7, #12]
 801a244:	6a1b      	ldr	r3, [r3, #32]
 801a246:	2b00      	cmp	r3, #0
 801a248:	d004      	beq.n	801a254 <rt_data_queue_pop+0x1bc>
    {
        queue->evt_notify(queue, RT_DATAQUEUE_EVENT_POP);
 801a24a:	68fb      	ldr	r3, [r7, #12]
 801a24c:	6a1b      	ldr	r3, [r3, #32]
 801a24e:	68f8      	ldr	r0, [r7, #12]
 801a250:	2101      	movs	r1, #1
 801a252:	4798      	blx	r3
    }

    return result;
 801a254:	6a3b      	ldr	r3, [r7, #32]
}
 801a256:	4618      	mov	r0, r3
 801a258:	3728      	adds	r7, #40	; 0x28
 801a25a:	46bd      	mov	sp, r7
 801a25c:	bd80      	pop	{r7, pc}
 801a25e:	bf00      	nop
 801a260:	08027e00 	.word	0x08027e00
 801a264:	080292f4 	.word	0x080292f4
 801a268:	08027e3c 	.word	0x08027e3c
 801a26c:	08027e50 	.word	0x08027e50
 801a270:	08027e14 	.word	0x08027e14
 801a274:	08027e38 	.word	0x08027e38

0801a278 <rt_data_queue_peak>:
RTM_EXPORT(rt_data_queue_pop);

rt_err_t rt_data_queue_peak(struct rt_data_queue *queue,
                            const void** data_ptr,
                            rt_size_t *size)
{
 801a278:	b580      	push	{r7, lr}
 801a27a:	b086      	sub	sp, #24
 801a27c:	af00      	add	r7, sp, #0
 801a27e:	60f8      	str	r0, [r7, #12]
 801a280:	60b9      	str	r1, [r7, #8]
 801a282:	607a      	str	r2, [r7, #4]
    rt_ubase_t  level;
    rt_uint16_t mask;

    RT_ASSERT(queue != RT_NULL);
 801a284:	68fb      	ldr	r3, [r7, #12]
 801a286:	2b00      	cmp	r3, #0
 801a288:	d105      	bne.n	801a296 <rt_data_queue_peak+0x1e>
 801a28a:	481e      	ldr	r0, [pc, #120]	; (801a304 <rt_data_queue_peak+0x8c>)
 801a28c:	491e      	ldr	r1, [pc, #120]	; (801a308 <rt_data_queue_peak+0x90>)
 801a28e:	f44f 7288 	mov.w	r2, #272	; 0x110
 801a292:	f7fd fb8d 	bl	80179b0 <rt_assert_handler>

    mask = queue->size - 1;
 801a296:	68fb      	ldr	r3, [r7, #12]
 801a298:	881b      	ldrh	r3, [r3, #0]
 801a29a:	3b01      	subs	r3, #1
 801a29c:	82fb      	strh	r3, [r7, #22]

    level = rt_hw_interrupt_disable();
 801a29e:	f7e5 ff93 	bl	80001c8 <rt_hw_interrupt_disable>
 801a2a2:	4603      	mov	r3, r0
 801a2a4:	613b      	str	r3, [r7, #16]

    if (queue->get_index == queue->put_index) 
 801a2a6:	68fb      	ldr	r3, [r7, #12]
 801a2a8:	891a      	ldrh	r2, [r3, #8]
 801a2aa:	68fb      	ldr	r3, [r7, #12]
 801a2ac:	895b      	ldrh	r3, [r3, #10]
 801a2ae:	429a      	cmp	r2, r3
 801a2b0:	d106      	bne.n	801a2c0 <rt_data_queue_peak+0x48>
    {
        rt_hw_interrupt_enable(level);
 801a2b2:	693b      	ldr	r3, [r7, #16]
 801a2b4:	4618      	mov	r0, r3
 801a2b6:	f7e5 ff8b 	bl	80001d0 <rt_hw_interrupt_enable>
        
        return -RT_EEMPTY;
 801a2ba:	f06f 0303 	mvn.w	r3, #3
 801a2be:	e01c      	b.n	801a2fa <rt_data_queue_peak+0x82>
    }

    *data_ptr = queue->queue[queue->get_index & mask].data_ptr;
 801a2c0:	68fb      	ldr	r3, [r7, #12]
 801a2c2:	68da      	ldr	r2, [r3, #12]
 801a2c4:	68fb      	ldr	r3, [r7, #12]
 801a2c6:	8919      	ldrh	r1, [r3, #8]
 801a2c8:	8afb      	ldrh	r3, [r7, #22]
 801a2ca:	400b      	ands	r3, r1
 801a2cc:	b29b      	uxth	r3, r3
 801a2ce:	00db      	lsls	r3, r3, #3
 801a2d0:	4413      	add	r3, r2
 801a2d2:	681a      	ldr	r2, [r3, #0]
 801a2d4:	68bb      	ldr	r3, [r7, #8]
 801a2d6:	601a      	str	r2, [r3, #0]
    *size     = queue->queue[queue->get_index & mask].data_size;
 801a2d8:	68fb      	ldr	r3, [r7, #12]
 801a2da:	68da      	ldr	r2, [r3, #12]
 801a2dc:	68fb      	ldr	r3, [r7, #12]
 801a2de:	8919      	ldrh	r1, [r3, #8]
 801a2e0:	8afb      	ldrh	r3, [r7, #22]
 801a2e2:	400b      	ands	r3, r1
 801a2e4:	b29b      	uxth	r3, r3
 801a2e6:	00db      	lsls	r3, r3, #3
 801a2e8:	4413      	add	r3, r2
 801a2ea:	685a      	ldr	r2, [r3, #4]
 801a2ec:	687b      	ldr	r3, [r7, #4]
 801a2ee:	601a      	str	r2, [r3, #0]

    rt_hw_interrupt_enable(level);
 801a2f0:	693b      	ldr	r3, [r7, #16]
 801a2f2:	4618      	mov	r0, r3
 801a2f4:	f7e5 ff6c 	bl	80001d0 <rt_hw_interrupt_enable>

    return RT_EOK;
 801a2f8:	2300      	movs	r3, #0
}
 801a2fa:	4618      	mov	r0, r3
 801a2fc:	3718      	adds	r7, #24
 801a2fe:	46bd      	mov	sp, r7
 801a300:	bd80      	pop	{r7, pc}
 801a302:	bf00      	nop
 801a304:	08027e00 	.word	0x08027e00
 801a308:	08029308 	.word	0x08029308

0801a30c <rt_i2c_core_init>:

    return (ret > 0) ? count : ret;
}

int rt_i2c_core_init(void)
{
 801a30c:	b480      	push	{r7}
 801a30e:	af00      	add	r7, sp, #0
    return 0;
 801a310:	2300      	movs	r3, #0
}
 801a312:	4618      	mov	r0, r3
 801a314:	46bd      	mov	sp, r7
 801a316:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a31a:	4770      	bx	lr

0801a31c <rt_mtd_nand_read_id>:
};

rt_err_t rt_mtd_nand_register_device(const char* name, struct rt_mtd_nand_device* device);

rt_inline rt_uint32_t rt_mtd_nand_read_id(struct rt_mtd_nand_device* device)
{
 801a31c:	b580      	push	{r7, lr}
 801a31e:	b082      	sub	sp, #8
 801a320:	af00      	add	r7, sp, #0
 801a322:	6078      	str	r0, [r7, #4]
	return device->ops->read_id(device);
 801a324:	687b      	ldr	r3, [r7, #4]
 801a326:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801a328:	681b      	ldr	r3, [r3, #0]
 801a32a:	6878      	ldr	r0, [r7, #4]
 801a32c:	4798      	blx	r3
 801a32e:	4603      	mov	r3, r0
}
 801a330:	4618      	mov	r0, r3
 801a332:	3708      	adds	r7, #8
 801a334:	46bd      	mov	sp, r7
 801a336:	bd80      	pop	{r7, pc}

0801a338 <rt_mtd_nand_read>:
rt_inline rt_err_t rt_mtd_nand_read(
	struct rt_mtd_nand_device* device,
	rt_off_t page,
	rt_uint8_t* data, rt_uint32_t data_len,
	rt_uint8_t * spare, rt_uint32_t spare_len)
{
 801a338:	b590      	push	{r4, r7, lr}
 801a33a:	b087      	sub	sp, #28
 801a33c:	af02      	add	r7, sp, #8
 801a33e:	60f8      	str	r0, [r7, #12]
 801a340:	60b9      	str	r1, [r7, #8]
 801a342:	607a      	str	r2, [r7, #4]
 801a344:	603b      	str	r3, [r7, #0]
	return device->ops->read_page(device, page, data, data_len, spare, spare_len);
 801a346:	68fb      	ldr	r3, [r7, #12]
 801a348:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801a34a:	685c      	ldr	r4, [r3, #4]
 801a34c:	6a3b      	ldr	r3, [r7, #32]
 801a34e:	9300      	str	r3, [sp, #0]
 801a350:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a352:	9301      	str	r3, [sp, #4]
 801a354:	68f8      	ldr	r0, [r7, #12]
 801a356:	68b9      	ldr	r1, [r7, #8]
 801a358:	687a      	ldr	r2, [r7, #4]
 801a35a:	683b      	ldr	r3, [r7, #0]
 801a35c:	47a0      	blx	r4
 801a35e:	4603      	mov	r3, r0
}
 801a360:	4618      	mov	r0, r3
 801a362:	3714      	adds	r7, #20
 801a364:	46bd      	mov	sp, r7
 801a366:	bd90      	pop	{r4, r7, pc}

0801a368 <rt_mtd_nand_write>:
rt_inline rt_err_t rt_mtd_nand_write(
	struct rt_mtd_nand_device* device,
	rt_off_t page,
	const rt_uint8_t* data, rt_uint32_t data_len,
	const rt_uint8_t * spare, rt_uint32_t spare_len)
{
 801a368:	b590      	push	{r4, r7, lr}
 801a36a:	b087      	sub	sp, #28
 801a36c:	af02      	add	r7, sp, #8
 801a36e:	60f8      	str	r0, [r7, #12]
 801a370:	60b9      	str	r1, [r7, #8]
 801a372:	607a      	str	r2, [r7, #4]
 801a374:	603b      	str	r3, [r7, #0]
	return device->ops->write_page(device, page, data, data_len, spare, spare_len);
 801a376:	68fb      	ldr	r3, [r7, #12]
 801a378:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801a37a:	689c      	ldr	r4, [r3, #8]
 801a37c:	6a3b      	ldr	r3, [r7, #32]
 801a37e:	9300      	str	r3, [sp, #0]
 801a380:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a382:	9301      	str	r3, [sp, #4]
 801a384:	68f8      	ldr	r0, [r7, #12]
 801a386:	68b9      	ldr	r1, [r7, #8]
 801a388:	687a      	ldr	r2, [r7, #4]
 801a38a:	683b      	ldr	r3, [r7, #0]
 801a38c:	47a0      	blx	r4
 801a38e:	4603      	mov	r3, r0
}
 801a390:	4618      	mov	r0, r3
 801a392:	3714      	adds	r7, #20
 801a394:	46bd      	mov	sp, r7
 801a396:	bd90      	pop	{r4, r7, pc}

0801a398 <rt_mtd_nand_erase_block>:
{
	return device->ops->move_page(device, src_page, dst_page);
}

rt_inline rt_err_t rt_mtd_nand_erase_block(struct rt_mtd_nand_device* device, rt_uint32_t block)
{
 801a398:	b580      	push	{r7, lr}
 801a39a:	b082      	sub	sp, #8
 801a39c:	af00      	add	r7, sp, #0
 801a39e:	6078      	str	r0, [r7, #4]
 801a3a0:	6039      	str	r1, [r7, #0]
	return device->ops->erase_block(device, block);
 801a3a2:	687b      	ldr	r3, [r7, #4]
 801a3a4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801a3a6:	691b      	ldr	r3, [r3, #16]
 801a3a8:	6878      	ldr	r0, [r7, #4]
 801a3aa:	6839      	ldr	r1, [r7, #0]
 801a3ac:	4798      	blx	r3
 801a3ae:	4603      	mov	r3, r0
}
 801a3b0:	4618      	mov	r0, r3
 801a3b2:	3708      	adds	r7, #8
 801a3b4:	46bd      	mov	sp, r7
 801a3b6:	bd80      	pop	{r7, pc}

0801a3b8 <mtd_dump_hex>:
#if defined(RT_MTD_NAND_DEBUG) && defined(RT_USING_FINSH)
#include <finsh.h>
#define __is_print(ch) ((unsigned int)((ch) - ' ') < 127u - ' ')

static void mtd_dump_hex(const rt_uint8_t *ptr, rt_size_t buflen)
{
 801a3b8:	b580      	push	{r7, lr}
 801a3ba:	b086      	sub	sp, #24
 801a3bc:	af00      	add	r7, sp, #0
 801a3be:	6078      	str	r0, [r7, #4]
 801a3c0:	6039      	str	r1, [r7, #0]
	unsigned char *buf = (unsigned char*)ptr;
 801a3c2:	687b      	ldr	r3, [r7, #4]
 801a3c4:	60fb      	str	r3, [r7, #12]
	int i, j;
	for (i=0; i<buflen; i+=16) 
 801a3c6:	2300      	movs	r3, #0
 801a3c8:	617b      	str	r3, [r7, #20]
 801a3ca:	e052      	b.n	801a472 <mtd_dump_hex+0xba>
	{
		rt_kprintf("%06x: ", i);
 801a3cc:	482c      	ldr	r0, [pc, #176]	; (801a480 <mtd_dump_hex+0xc8>)
 801a3ce:	6979      	ldr	r1, [r7, #20]
 801a3d0:	f7fd fa74 	bl	80178bc <rt_kprintf>
		for (j=0; j<16; j++)
 801a3d4:	2300      	movs	r3, #0
 801a3d6:	613b      	str	r3, [r7, #16]
 801a3d8:	e018      	b.n	801a40c <mtd_dump_hex+0x54>
			if (i+j < buflen)
 801a3da:	697a      	ldr	r2, [r7, #20]
 801a3dc:	693b      	ldr	r3, [r7, #16]
 801a3de:	4413      	add	r3, r2
 801a3e0:	461a      	mov	r2, r3
 801a3e2:	683b      	ldr	r3, [r7, #0]
 801a3e4:	429a      	cmp	r2, r3
 801a3e6:	d20b      	bcs.n	801a400 <mtd_dump_hex+0x48>
				rt_kprintf("%02x ", buf[i+j]);
 801a3e8:	697a      	ldr	r2, [r7, #20]
 801a3ea:	693b      	ldr	r3, [r7, #16]
 801a3ec:	4413      	add	r3, r2
 801a3ee:	461a      	mov	r2, r3
 801a3f0:	68fb      	ldr	r3, [r7, #12]
 801a3f2:	4413      	add	r3, r2
 801a3f4:	781b      	ldrb	r3, [r3, #0]
 801a3f6:	4823      	ldr	r0, [pc, #140]	; (801a484 <mtd_dump_hex+0xcc>)
 801a3f8:	4619      	mov	r1, r3
 801a3fa:	f7fd fa5f 	bl	80178bc <rt_kprintf>
 801a3fe:	e002      	b.n	801a406 <mtd_dump_hex+0x4e>
			else
				rt_kprintf("   ");
 801a400:	4821      	ldr	r0, [pc, #132]	; (801a488 <mtd_dump_hex+0xd0>)
 801a402:	f7fd fa5b 	bl	80178bc <rt_kprintf>
	unsigned char *buf = (unsigned char*)ptr;
	int i, j;
	for (i=0; i<buflen; i+=16) 
	{
		rt_kprintf("%06x: ", i);
		for (j=0; j<16; j++)
 801a406:	693b      	ldr	r3, [r7, #16]
 801a408:	3301      	adds	r3, #1
 801a40a:	613b      	str	r3, [r7, #16]
 801a40c:	693b      	ldr	r3, [r7, #16]
 801a40e:	2b0f      	cmp	r3, #15
 801a410:	dde3      	ble.n	801a3da <mtd_dump_hex+0x22>
			if (i+j < buflen)
				rt_kprintf("%02x ", buf[i+j]);
			else
				rt_kprintf("   ");
		rt_kprintf(" ");
 801a412:	481e      	ldr	r0, [pc, #120]	; (801a48c <mtd_dump_hex+0xd4>)
 801a414:	f7fd fa52 	bl	80178bc <rt_kprintf>
		for (j=0; j<16; j++)
 801a418:	2300      	movs	r3, #0
 801a41a:	613b      	str	r3, [r7, #16]
 801a41c:	e020      	b.n	801a460 <mtd_dump_hex+0xa8>
			if (i+j < buflen)
 801a41e:	697a      	ldr	r2, [r7, #20]
 801a420:	693b      	ldr	r3, [r7, #16]
 801a422:	4413      	add	r3, r2
 801a424:	461a      	mov	r2, r3
 801a426:	683b      	ldr	r3, [r7, #0]
 801a428:	429a      	cmp	r2, r3
 801a42a:	d216      	bcs.n	801a45a <mtd_dump_hex+0xa2>
				rt_kprintf("%c", __is_print(buf[i+j]) ? buf[i+j] : '.');
 801a42c:	697a      	ldr	r2, [r7, #20]
 801a42e:	693b      	ldr	r3, [r7, #16]
 801a430:	4413      	add	r3, r2
 801a432:	461a      	mov	r2, r3
 801a434:	68fb      	ldr	r3, [r7, #12]
 801a436:	4413      	add	r3, r2
 801a438:	781b      	ldrb	r3, [r3, #0]
 801a43a:	3b20      	subs	r3, #32
 801a43c:	2b5e      	cmp	r3, #94	; 0x5e
 801a43e:	d807      	bhi.n	801a450 <mtd_dump_hex+0x98>
 801a440:	697a      	ldr	r2, [r7, #20]
 801a442:	693b      	ldr	r3, [r7, #16]
 801a444:	4413      	add	r3, r2
 801a446:	461a      	mov	r2, r3
 801a448:	68fb      	ldr	r3, [r7, #12]
 801a44a:	4413      	add	r3, r2
 801a44c:	781b      	ldrb	r3, [r3, #0]
 801a44e:	e000      	b.n	801a452 <mtd_dump_hex+0x9a>
 801a450:	232e      	movs	r3, #46	; 0x2e
 801a452:	480f      	ldr	r0, [pc, #60]	; (801a490 <mtd_dump_hex+0xd8>)
 801a454:	4619      	mov	r1, r3
 801a456:	f7fd fa31 	bl	80178bc <rt_kprintf>
			if (i+j < buflen)
				rt_kprintf("%02x ", buf[i+j]);
			else
				rt_kprintf("   ");
		rt_kprintf(" ");
		for (j=0; j<16; j++)
 801a45a:	693b      	ldr	r3, [r7, #16]
 801a45c:	3301      	adds	r3, #1
 801a45e:	613b      	str	r3, [r7, #16]
 801a460:	693b      	ldr	r3, [r7, #16]
 801a462:	2b0f      	cmp	r3, #15
 801a464:	dddb      	ble.n	801a41e <mtd_dump_hex+0x66>
			if (i+j < buflen)
				rt_kprintf("%c", __is_print(buf[i+j]) ? buf[i+j] : '.');
		rt_kprintf("\n");
 801a466:	480b      	ldr	r0, [pc, #44]	; (801a494 <mtd_dump_hex+0xdc>)
 801a468:	f7fd fa28 	bl	80178bc <rt_kprintf>

static void mtd_dump_hex(const rt_uint8_t *ptr, rt_size_t buflen)
{
	unsigned char *buf = (unsigned char*)ptr;
	int i, j;
	for (i=0; i<buflen; i+=16) 
 801a46c:	697b      	ldr	r3, [r7, #20]
 801a46e:	3310      	adds	r3, #16
 801a470:	617b      	str	r3, [r7, #20]
 801a472:	697a      	ldr	r2, [r7, #20]
 801a474:	683b      	ldr	r3, [r7, #0]
 801a476:	429a      	cmp	r2, r3
 801a478:	d3a8      	bcc.n	801a3cc <mtd_dump_hex+0x14>
		for (j=0; j<16; j++)
			if (i+j < buflen)
				rt_kprintf("%c", __is_print(buf[i+j]) ? buf[i+j] : '.');
		rt_kprintf("\n");
	}
}
 801a47a:	3718      	adds	r7, #24
 801a47c:	46bd      	mov	sp, r7
 801a47e:	bd80      	pop	{r7, pc}
 801a480:	08027e70 	.word	0x08027e70
 801a484:	08027e78 	.word	0x08027e78
 801a488:	08027e80 	.word	0x08027e80
 801a48c:	08027e84 	.word	0x08027e84
 801a490:	08027e88 	.word	0x08027e88
 801a494:	08027e8c 	.word	0x08027e8c

0801a498 <mtd_nandid>:

int mtd_nandid(const char* name)
{
 801a498:	b580      	push	{r7, lr}
 801a49a:	b084      	sub	sp, #16
 801a49c:	af00      	add	r7, sp, #0
 801a49e:	6078      	str	r0, [r7, #4]
	struct rt_mtd_nand_device *nand;
	nand = RT_MTD_NAND_DEVICE(rt_device_find(name));
 801a4a0:	6878      	ldr	r0, [r7, #4]
 801a4a2:	f7fb fb7d 	bl	8015ba0 <rt_device_find>
 801a4a6:	60f8      	str	r0, [r7, #12]
	if (nand == RT_NULL)
 801a4a8:	68fb      	ldr	r3, [r7, #12]
 801a4aa:	2b00      	cmp	r3, #0
 801a4ac:	d105      	bne.n	801a4ba <mtd_nandid+0x22>
	{
		rt_kprintf("no nand device found!\n");
 801a4ae:	4807      	ldr	r0, [pc, #28]	; (801a4cc <mtd_nandid+0x34>)
 801a4b0:	f7fd fa04 	bl	80178bc <rt_kprintf>
		return -RT_ERROR;
 801a4b4:	f04f 33ff 	mov.w	r3, #4294967295
 801a4b8:	e003      	b.n	801a4c2 <mtd_nandid+0x2a>
	}

	return rt_mtd_nand_read_id(nand);
 801a4ba:	68f8      	ldr	r0, [r7, #12]
 801a4bc:	f7ff ff2e 	bl	801a31c <rt_mtd_nand_read_id>
 801a4c0:	4603      	mov	r3, r0
}
 801a4c2:	4618      	mov	r0, r3
 801a4c4:	3710      	adds	r7, #16
 801a4c6:	46bd      	mov	sp, r7
 801a4c8:	bd80      	pop	{r7, pc}
 801a4ca:	bf00      	nop
 801a4cc:	08027e90 	.word	0x08027e90

0801a4d0 <mtd_nand_read>:
FINSH_FUNCTION_EXPORT_ALIAS(mtd_nandid, nand_id, read ID - nandid(name));

int mtd_nand_read(const char* name, int block, int page)
{
 801a4d0:	b590      	push	{r4, r7, lr}
 801a4d2:	b08b      	sub	sp, #44	; 0x2c
 801a4d4:	af02      	add	r7, sp, #8
 801a4d6:	60f8      	str	r0, [r7, #12]
 801a4d8:	60b9      	str	r1, [r7, #8]
 801a4da:	607a      	str	r2, [r7, #4]
	rt_err_t result;
	rt_uint8_t *page_ptr;
	rt_uint8_t *oob_ptr;
	struct rt_mtd_nand_device *nand;

	nand = RT_MTD_NAND_DEVICE(rt_device_find(name));
 801a4dc:	68f8      	ldr	r0, [r7, #12]
 801a4de:	f7fb fb5f 	bl	8015ba0 <rt_device_find>
 801a4e2:	61f8      	str	r0, [r7, #28]
	if (nand == RT_NULL)
 801a4e4:	69fb      	ldr	r3, [r7, #28]
 801a4e6:	2b00      	cmp	r3, #0
 801a4e8:	d105      	bne.n	801a4f6 <mtd_nand_read+0x26>
	{
		rt_kprintf("no nand device found!\n");
 801a4ea:	4831      	ldr	r0, [pc, #196]	; (801a5b0 <mtd_nand_read+0xe0>)
 801a4ec:	f7fd f9e6 	bl	80178bc <rt_kprintf>
		return -RT_ERROR;
 801a4f0:	f04f 33ff 	mov.w	r3, #4294967295
 801a4f4:	e058      	b.n	801a5a8 <mtd_nand_read+0xd8>
	}

	page_ptr = rt_malloc(nand->page_size + nand->oob_size);
 801a4f6:	69fb      	ldr	r3, [r7, #28]
 801a4f8:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 801a4fc:	461a      	mov	r2, r3
 801a4fe:	69fb      	ldr	r3, [r7, #28]
 801a500:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 801a504:	4413      	add	r3, r2
 801a506:	4618      	mov	r0, r3
 801a508:	f7fd fb86 	bl	8017c18 <rt_malloc>
 801a50c:	61b8      	str	r0, [r7, #24]
	if (page_ptr == RT_NULL)
 801a50e:	69bb      	ldr	r3, [r7, #24]
 801a510:	2b00      	cmp	r3, #0
 801a512:	d105      	bne.n	801a520 <mtd_nand_read+0x50>
	{
		rt_kprintf("out of memory!\n");
 801a514:	4827      	ldr	r0, [pc, #156]	; (801a5b4 <mtd_nand_read+0xe4>)
 801a516:	f7fd f9d1 	bl	80178bc <rt_kprintf>
		return -RT_ENOMEM;
 801a51a:	f06f 0304 	mvn.w	r3, #4
 801a51e:	e043      	b.n	801a5a8 <mtd_nand_read+0xd8>
	}

	oob_ptr = page_ptr + nand->page_size;
 801a520:	69fb      	ldr	r3, [r7, #28]
 801a522:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 801a526:	461a      	mov	r2, r3
 801a528:	69bb      	ldr	r3, [r7, #24]
 801a52a:	4413      	add	r3, r2
 801a52c:	617b      	str	r3, [r7, #20]
	rt_memset(page_ptr, 0xff, nand->page_size + nand->oob_size);
 801a52e:	69fb      	ldr	r3, [r7, #28]
 801a530:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 801a534:	461a      	mov	r2, r3
 801a536:	69fb      	ldr	r3, [r7, #28]
 801a538:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 801a53c:	4413      	add	r3, r2
 801a53e:	69b8      	ldr	r0, [r7, #24]
 801a540:	21ff      	movs	r1, #255	; 0xff
 801a542:	461a      	mov	r2, r3
 801a544:	f7fc fc02 	bl	8016d4c <rt_memset>

	/* calculate the page number */
	page = block * nand->pages_per_block + page;
 801a548:	69fb      	ldr	r3, [r7, #28]
 801a54a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801a54c:	68ba      	ldr	r2, [r7, #8]
 801a54e:	fb02 f203 	mul.w	r2, r2, r3
 801a552:	687b      	ldr	r3, [r7, #4]
 801a554:	4413      	add	r3, r2
 801a556:	607b      	str	r3, [r7, #4]
	result = rt_mtd_nand_read(nand, page, page_ptr, nand->page_size,
 801a558:	69fb      	ldr	r3, [r7, #28]
 801a55a:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 801a55e:	461c      	mov	r4, r3
		oob_ptr, nand->oob_size);
 801a560:	69fb      	ldr	r3, [r7, #28]
 801a562:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
	oob_ptr = page_ptr + nand->page_size;
	rt_memset(page_ptr, 0xff, nand->page_size + nand->oob_size);

	/* calculate the page number */
	page = block * nand->pages_per_block + page;
	result = rt_mtd_nand_read(nand, page, page_ptr, nand->page_size,
 801a566:	461a      	mov	r2, r3
 801a568:	697b      	ldr	r3, [r7, #20]
 801a56a:	9300      	str	r3, [sp, #0]
 801a56c:	9201      	str	r2, [sp, #4]
 801a56e:	69f8      	ldr	r0, [r7, #28]
 801a570:	6879      	ldr	r1, [r7, #4]
 801a572:	69ba      	ldr	r2, [r7, #24]
 801a574:	4623      	mov	r3, r4
 801a576:	f7ff fedf 	bl	801a338 <rt_mtd_nand_read>
 801a57a:	6138      	str	r0, [r7, #16]
		oob_ptr, nand->oob_size);

	rt_kprintf("read page, rc=%d\n", result);
 801a57c:	480e      	ldr	r0, [pc, #56]	; (801a5b8 <mtd_nand_read+0xe8>)
 801a57e:	6939      	ldr	r1, [r7, #16]
 801a580:	f7fd f99c 	bl	80178bc <rt_kprintf>
	mtd_dump_hex(page_ptr, nand->page_size);
 801a584:	69fb      	ldr	r3, [r7, #28]
 801a586:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 801a58a:	69b8      	ldr	r0, [r7, #24]
 801a58c:	4619      	mov	r1, r3
 801a58e:	f7ff ff13 	bl	801a3b8 <mtd_dump_hex>
	mtd_dump_hex(oob_ptr, nand->oob_size);
 801a592:	69fb      	ldr	r3, [r7, #28]
 801a594:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 801a598:	6978      	ldr	r0, [r7, #20]
 801a59a:	4619      	mov	r1, r3
 801a59c:	f7ff ff0c 	bl	801a3b8 <mtd_dump_hex>

	rt_free(page_ptr);
 801a5a0:	69b8      	ldr	r0, [r7, #24]
 801a5a2:	f7fd fd43 	bl	801802c <rt_free>
	return 0;
 801a5a6:	2300      	movs	r3, #0
}
 801a5a8:	4618      	mov	r0, r3
 801a5aa:	3724      	adds	r7, #36	; 0x24
 801a5ac:	46bd      	mov	sp, r7
 801a5ae:	bd90      	pop	{r4, r7, pc}
 801a5b0:	08027e90 	.word	0x08027e90
 801a5b4:	08027ea8 	.word	0x08027ea8
 801a5b8:	08027eb8 	.word	0x08027eb8

0801a5bc <mtd_nand_readoob>:
FINSH_FUNCTION_EXPORT_ALIAS(mtd_nand_read, nand_read, read page in nand - nand_read(name, block, page));

int mtd_nand_readoob(const char* name, int block, int page)
{
 801a5bc:	b590      	push	{r4, r7, lr}
 801a5be:	b089      	sub	sp, #36	; 0x24
 801a5c0:	af02      	add	r7, sp, #8
 801a5c2:	60f8      	str	r0, [r7, #12]
 801a5c4:	60b9      	str	r1, [r7, #8]
 801a5c6:	607a      	str	r2, [r7, #4]
	struct rt_mtd_nand_device *nand;
	rt_uint8_t *oob_ptr;

	nand = RT_MTD_NAND_DEVICE(rt_device_find(name));
 801a5c8:	68f8      	ldr	r0, [r7, #12]
 801a5ca:	f7fb fae9 	bl	8015ba0 <rt_device_find>
 801a5ce:	6178      	str	r0, [r7, #20]
	if (nand == RT_NULL)
 801a5d0:	697b      	ldr	r3, [r7, #20]
 801a5d2:	2b00      	cmp	r3, #0
 801a5d4:	d105      	bne.n	801a5e2 <mtd_nand_readoob+0x26>
	{
		rt_kprintf("no nand device found!\n");
 801a5d6:	481f      	ldr	r0, [pc, #124]	; (801a654 <mtd_nand_readoob+0x98>)
 801a5d8:	f7fd f970 	bl	80178bc <rt_kprintf>
		return -RT_ERROR;
 801a5dc:	f04f 33ff 	mov.w	r3, #4294967295
 801a5e0:	e033      	b.n	801a64a <mtd_nand_readoob+0x8e>
	}

	oob_ptr = rt_malloc(nand->oob_size);
 801a5e2:	697b      	ldr	r3, [r7, #20]
 801a5e4:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 801a5e8:	4618      	mov	r0, r3
 801a5ea:	f7fd fb15 	bl	8017c18 <rt_malloc>
 801a5ee:	6138      	str	r0, [r7, #16]
	if (oob_ptr == RT_NULL)
 801a5f0:	693b      	ldr	r3, [r7, #16]
 801a5f2:	2b00      	cmp	r3, #0
 801a5f4:	d105      	bne.n	801a602 <mtd_nand_readoob+0x46>
	{
		rt_kprintf("out of memory!\n");
 801a5f6:	4818      	ldr	r0, [pc, #96]	; (801a658 <mtd_nand_readoob+0x9c>)
 801a5f8:	f7fd f960 	bl	80178bc <rt_kprintf>
		return -RT_ENOMEM;
 801a5fc:	f06f 0304 	mvn.w	r3, #4
 801a600:	e023      	b.n	801a64a <mtd_nand_readoob+0x8e>
	}

	/* calculate the page number */
	page = block * nand->pages_per_block + page;
 801a602:	697b      	ldr	r3, [r7, #20]
 801a604:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801a606:	68ba      	ldr	r2, [r7, #8]
 801a608:	fb02 f203 	mul.w	r2, r2, r3
 801a60c:	687b      	ldr	r3, [r7, #4]
 801a60e:	4413      	add	r3, r2
 801a610:	607b      	str	r3, [r7, #4]
	rt_mtd_nand_read(nand, page, RT_NULL, nand->page_size,
 801a612:	697b      	ldr	r3, [r7, #20]
 801a614:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 801a618:	461c      	mov	r4, r3
		oob_ptr, nand->oob_size);
 801a61a:	697b      	ldr	r3, [r7, #20]
 801a61c:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
		return -RT_ENOMEM;
	}

	/* calculate the page number */
	page = block * nand->pages_per_block + page;
	rt_mtd_nand_read(nand, page, RT_NULL, nand->page_size,
 801a620:	461a      	mov	r2, r3
 801a622:	693b      	ldr	r3, [r7, #16]
 801a624:	9300      	str	r3, [sp, #0]
 801a626:	9201      	str	r2, [sp, #4]
 801a628:	6978      	ldr	r0, [r7, #20]
 801a62a:	6879      	ldr	r1, [r7, #4]
 801a62c:	2200      	movs	r2, #0
 801a62e:	4623      	mov	r3, r4
 801a630:	f7ff fe82 	bl	801a338 <rt_mtd_nand_read>
		oob_ptr, nand->oob_size);
	mtd_dump_hex(oob_ptr, nand->oob_size);
 801a634:	697b      	ldr	r3, [r7, #20]
 801a636:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 801a63a:	6938      	ldr	r0, [r7, #16]
 801a63c:	4619      	mov	r1, r3
 801a63e:	f7ff febb 	bl	801a3b8 <mtd_dump_hex>

	rt_free(oob_ptr);
 801a642:	6938      	ldr	r0, [r7, #16]
 801a644:	f7fd fcf2 	bl	801802c <rt_free>
	return 0;
 801a648:	2300      	movs	r3, #0
}
 801a64a:	4618      	mov	r0, r3
 801a64c:	371c      	adds	r7, #28
 801a64e:	46bd      	mov	sp, r7
 801a650:	bd90      	pop	{r4, r7, pc}
 801a652:	bf00      	nop
 801a654:	08027e90 	.word	0x08027e90
 801a658:	08027ea8 	.word	0x08027ea8

0801a65c <mtd_nand_write>:
FINSH_FUNCTION_EXPORT_ALIAS(mtd_nand_readoob, nand_readoob, read spare data in nand - nand_readoob(name, block, page));

int mtd_nand_write(const char* name, int block, int page)
{
 801a65c:	b590      	push	{r4, r7, lr}
 801a65e:	b08d      	sub	sp, #52	; 0x34
 801a660:	af02      	add	r7, sp, #8
 801a662:	60f8      	str	r0, [r7, #12]
 801a664:	60b9      	str	r1, [r7, #8]
 801a666:	607a      	str	r2, [r7, #4]
	rt_uint8_t *page_ptr;
	rt_uint8_t *oob_ptr;
	rt_uint32_t index;
	struct rt_mtd_nand_device *nand;

	nand = RT_MTD_NAND_DEVICE(rt_device_find(name));
 801a668:	68f8      	ldr	r0, [r7, #12]
 801a66a:	f7fb fa99 	bl	8015ba0 <rt_device_find>
 801a66e:	6238      	str	r0, [r7, #32]
	if (nand == RT_NULL)
 801a670:	6a3b      	ldr	r3, [r7, #32]
 801a672:	2b00      	cmp	r3, #0
 801a674:	d105      	bne.n	801a682 <mtd_nand_write+0x26>
	{
		rt_kprintf("no nand device found!\n");
 801a676:	4838      	ldr	r0, [pc, #224]	; (801a758 <mtd_nand_write+0xfc>)
 801a678:	f7fd f920 	bl	80178bc <rt_kprintf>
		return -RT_ERROR;
 801a67c:	f04f 33ff 	mov.w	r3, #4294967295
 801a680:	e066      	b.n	801a750 <mtd_nand_write+0xf4>
	}

	page_ptr = rt_malloc(nand->page_size + nand->oob_size);
 801a682:	6a3b      	ldr	r3, [r7, #32]
 801a684:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 801a688:	461a      	mov	r2, r3
 801a68a:	6a3b      	ldr	r3, [r7, #32]
 801a68c:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 801a690:	4413      	add	r3, r2
 801a692:	4618      	mov	r0, r3
 801a694:	f7fd fac0 	bl	8017c18 <rt_malloc>
 801a698:	61f8      	str	r0, [r7, #28]
	if (page_ptr == RT_NULL)
 801a69a:	69fb      	ldr	r3, [r7, #28]
 801a69c:	2b00      	cmp	r3, #0
 801a69e:	d105      	bne.n	801a6ac <mtd_nand_write+0x50>
	{
		rt_kprintf("out of memory!\n");
 801a6a0:	482e      	ldr	r0, [pc, #184]	; (801a75c <mtd_nand_write+0x100>)
 801a6a2:	f7fd f90b 	bl	80178bc <rt_kprintf>
		return -RT_ENOMEM;
 801a6a6:	f06f 0304 	mvn.w	r3, #4
 801a6aa:	e051      	b.n	801a750 <mtd_nand_write+0xf4>
	}

	oob_ptr = page_ptr + nand->page_size;
 801a6ac:	6a3b      	ldr	r3, [r7, #32]
 801a6ae:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 801a6b2:	461a      	mov	r2, r3
 801a6b4:	69fb      	ldr	r3, [r7, #28]
 801a6b6:	4413      	add	r3, r2
 801a6b8:	61bb      	str	r3, [r7, #24]
	/* prepare page data */
	for (index = 0; index < nand->page_size; index ++)
 801a6ba:	2300      	movs	r3, #0
 801a6bc:	627b      	str	r3, [r7, #36]	; 0x24
 801a6be:	e008      	b.n	801a6d2 <mtd_nand_write+0x76>
	{
		page_ptr[index] = index & 0xff;
 801a6c0:	69fa      	ldr	r2, [r7, #28]
 801a6c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a6c4:	4413      	add	r3, r2
 801a6c6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801a6c8:	b2d2      	uxtb	r2, r2
 801a6ca:	701a      	strb	r2, [r3, #0]
		return -RT_ENOMEM;
	}

	oob_ptr = page_ptr + nand->page_size;
	/* prepare page data */
	for (index = 0; index < nand->page_size; index ++)
 801a6cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a6ce:	3301      	adds	r3, #1
 801a6d0:	627b      	str	r3, [r7, #36]	; 0x24
 801a6d2:	6a3b      	ldr	r3, [r7, #32]
 801a6d4:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 801a6d8:	461a      	mov	r2, r3
 801a6da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a6dc:	429a      	cmp	r2, r3
 801a6de:	d8ef      	bhi.n	801a6c0 <mtd_nand_write+0x64>
	{
		page_ptr[index] = index & 0xff;
	}
	/* prepare oob data */
	for (index = 0; index < nand->oob_size; index ++)
 801a6e0:	2300      	movs	r3, #0
 801a6e2:	627b      	str	r3, [r7, #36]	; 0x24
 801a6e4:	e008      	b.n	801a6f8 <mtd_nand_write+0x9c>
	{
		oob_ptr[index] = index & 0xff;
 801a6e6:	69ba      	ldr	r2, [r7, #24]
 801a6e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a6ea:	4413      	add	r3, r2
 801a6ec:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801a6ee:	b2d2      	uxtb	r2, r2
 801a6f0:	701a      	strb	r2, [r3, #0]
	for (index = 0; index < nand->page_size; index ++)
	{
		page_ptr[index] = index & 0xff;
	}
	/* prepare oob data */
	for (index = 0; index < nand->oob_size; index ++)
 801a6f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a6f4:	3301      	adds	r3, #1
 801a6f6:	627b      	str	r3, [r7, #36]	; 0x24
 801a6f8:	6a3b      	ldr	r3, [r7, #32]
 801a6fa:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 801a6fe:	461a      	mov	r2, r3
 801a700:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a702:	429a      	cmp	r2, r3
 801a704:	d8ef      	bhi.n	801a6e6 <mtd_nand_write+0x8a>
	{
		oob_ptr[index] = index & 0xff;
	}

	/* calculate the page number */
	page = block * nand->pages_per_block + page;
 801a706:	6a3b      	ldr	r3, [r7, #32]
 801a708:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801a70a:	68ba      	ldr	r2, [r7, #8]
 801a70c:	fb02 f203 	mul.w	r2, r2, r3
 801a710:	687b      	ldr	r3, [r7, #4]
 801a712:	4413      	add	r3, r2
 801a714:	607b      	str	r3, [r7, #4]
	result = rt_mtd_nand_write(nand, page, page_ptr, nand->page_size,
 801a716:	6a3b      	ldr	r3, [r7, #32]
 801a718:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 801a71c:	461c      	mov	r4, r3
		oob_ptr, nand->oob_size);
 801a71e:	6a3b      	ldr	r3, [r7, #32]
 801a720:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
		oob_ptr[index] = index & 0xff;
	}

	/* calculate the page number */
	page = block * nand->pages_per_block + page;
	result = rt_mtd_nand_write(nand, page, page_ptr, nand->page_size,
 801a724:	461a      	mov	r2, r3
 801a726:	69bb      	ldr	r3, [r7, #24]
 801a728:	9300      	str	r3, [sp, #0]
 801a72a:	9201      	str	r2, [sp, #4]
 801a72c:	6a38      	ldr	r0, [r7, #32]
 801a72e:	6879      	ldr	r1, [r7, #4]
 801a730:	69fa      	ldr	r2, [r7, #28]
 801a732:	4623      	mov	r3, r4
 801a734:	f7ff fe18 	bl	801a368 <rt_mtd_nand_write>
 801a738:	6178      	str	r0, [r7, #20]
		oob_ptr, nand->oob_size);
	if (result != RT_MTD_EOK)
 801a73a:	697b      	ldr	r3, [r7, #20]
 801a73c:	2b00      	cmp	r3, #0
 801a73e:	d003      	beq.n	801a748 <mtd_nand_write+0xec>
	{
		rt_kprintf("write page failed!, rc=%d\n", result);
 801a740:	4807      	ldr	r0, [pc, #28]	; (801a760 <mtd_nand_write+0x104>)
 801a742:	6979      	ldr	r1, [r7, #20]
 801a744:	f7fd f8ba 	bl	80178bc <rt_kprintf>
	}

	rt_free(page_ptr);
 801a748:	69f8      	ldr	r0, [r7, #28]
 801a74a:	f7fd fc6f 	bl	801802c <rt_free>
	return 0;
 801a74e:	2300      	movs	r3, #0
}
 801a750:	4618      	mov	r0, r3
 801a752:	372c      	adds	r7, #44	; 0x2c
 801a754:	46bd      	mov	sp, r7
 801a756:	bd90      	pop	{r4, r7, pc}
 801a758:	08027e90 	.word	0x08027e90
 801a75c:	08027ea8 	.word	0x08027ea8
 801a760:	08027ecc 	.word	0x08027ecc

0801a764 <mtd_nand_erase>:
FINSH_FUNCTION_EXPORT_ALIAS(mtd_nand_write, nand_write, write dump data to nand - nand_write(name, block, page));

int mtd_nand_erase(const char* name, int block)
{
 801a764:	b580      	push	{r7, lr}
 801a766:	b084      	sub	sp, #16
 801a768:	af00      	add	r7, sp, #0
 801a76a:	6078      	str	r0, [r7, #4]
 801a76c:	6039      	str	r1, [r7, #0]
	struct rt_mtd_nand_device *nand;
	nand = RT_MTD_NAND_DEVICE(rt_device_find(name));
 801a76e:	6878      	ldr	r0, [r7, #4]
 801a770:	f7fb fa16 	bl	8015ba0 <rt_device_find>
 801a774:	60f8      	str	r0, [r7, #12]
	if (nand == RT_NULL)
 801a776:	68fb      	ldr	r3, [r7, #12]
 801a778:	2b00      	cmp	r3, #0
 801a77a:	d105      	bne.n	801a788 <mtd_nand_erase+0x24>
	{
		rt_kprintf("no nand device found!\n");
 801a77c:	4807      	ldr	r0, [pc, #28]	; (801a79c <mtd_nand_erase+0x38>)
 801a77e:	f7fd f89d 	bl	80178bc <rt_kprintf>
		return -RT_ERROR;
 801a782:	f04f 33ff 	mov.w	r3, #4294967295
 801a786:	e005      	b.n	801a794 <mtd_nand_erase+0x30>
	}

	return rt_mtd_nand_erase_block(nand, block);
 801a788:	683b      	ldr	r3, [r7, #0]
 801a78a:	68f8      	ldr	r0, [r7, #12]
 801a78c:	4619      	mov	r1, r3
 801a78e:	f7ff fe03 	bl	801a398 <rt_mtd_nand_erase_block>
 801a792:	4603      	mov	r3, r0
}
 801a794:	4618      	mov	r0, r3
 801a796:	3710      	adds	r7, #16
 801a798:	46bd      	mov	sp, r7
 801a79a:	bd80      	pop	{r7, pc}
 801a79c:	08027e90 	.word	0x08027e90

0801a7a0 <mtd_nand_erase_all>:
FINSH_FUNCTION_EXPORT_ALIAS(mtd_nand_erase, nand_erase, nand_erase(name, block));

int mtd_nand_erase_all(const char* name)
{
 801a7a0:	b580      	push	{r7, lr}
 801a7a2:	b084      	sub	sp, #16
 801a7a4:	af00      	add	r7, sp, #0
 801a7a6:	6078      	str	r0, [r7, #4]
	rt_uint32_t index = 0;
 801a7a8:	2300      	movs	r3, #0
 801a7aa:	60fb      	str	r3, [r7, #12]
	struct rt_mtd_nand_device *nand;
	
	nand = RT_MTD_NAND_DEVICE(rt_device_find(name));
 801a7ac:	6878      	ldr	r0, [r7, #4]
 801a7ae:	f7fb f9f7 	bl	8015ba0 <rt_device_find>
 801a7b2:	60b8      	str	r0, [r7, #8]
	if (nand == RT_NULL)
 801a7b4:	68bb      	ldr	r3, [r7, #8]
 801a7b6:	2b00      	cmp	r3, #0
 801a7b8:	d105      	bne.n	801a7c6 <mtd_nand_erase_all+0x26>
	{
		rt_kprintf("no nand device found!\n");
 801a7ba:	480e      	ldr	r0, [pc, #56]	; (801a7f4 <mtd_nand_erase_all+0x54>)
 801a7bc:	f7fd f87e 	bl	80178bc <rt_kprintf>
		return -RT_ERROR;
 801a7c0:	f04f 33ff 	mov.w	r3, #4294967295
 801a7c4:	e012      	b.n	801a7ec <mtd_nand_erase_all+0x4c>
	}

	for (index = 0; index < (nand->block_end - nand->block_start); index ++)
 801a7c6:	2300      	movs	r3, #0
 801a7c8:	60fb      	str	r3, [r7, #12]
 801a7ca:	e006      	b.n	801a7da <mtd_nand_erase_all+0x3a>
	{
		rt_mtd_nand_erase_block(nand, index);
 801a7cc:	68b8      	ldr	r0, [r7, #8]
 801a7ce:	68f9      	ldr	r1, [r7, #12]
 801a7d0:	f7ff fde2 	bl	801a398 <rt_mtd_nand_erase_block>
	{
		rt_kprintf("no nand device found!\n");
		return -RT_ERROR;
	}

	for (index = 0; index < (nand->block_end - nand->block_start); index ++)
 801a7d4:	68fb      	ldr	r3, [r7, #12]
 801a7d6:	3301      	adds	r3, #1
 801a7d8:	60fb      	str	r3, [r7, #12]
 801a7da:	68bb      	ldr	r3, [r7, #8]
 801a7dc:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801a7de:	68bb      	ldr	r3, [r7, #8]
 801a7e0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a7e2:	1ad2      	subs	r2, r2, r3
 801a7e4:	68fb      	ldr	r3, [r7, #12]
 801a7e6:	429a      	cmp	r2, r3
 801a7e8:	d8f0      	bhi.n	801a7cc <mtd_nand_erase_all+0x2c>
	{
		rt_mtd_nand_erase_block(nand, index);
	}
	
	return 0;
 801a7ea:	2300      	movs	r3, #0
}
 801a7ec:	4618      	mov	r0, r3
 801a7ee:	3710      	adds	r7, #16
 801a7f0:	46bd      	mov	sp, r7
 801a7f2:	bd80      	pop	{r7, pc}
 801a7f4:	08027e90 	.word	0x08027e90

0801a7f8 <time>:
#pragma module_name = "?time"
time_t (__time32)(time_t *t) /* Only supports 32-bit timestamp */
#else
time_t time(time_t *t)
#endif
{
 801a7f8:	b580      	push	{r7, lr}
 801a7fa:	b084      	sub	sp, #16
 801a7fc:	af00      	add	r7, sp, #0
 801a7fe:	6078      	str	r0, [r7, #4]
    static rt_device_t device = RT_NULL;
    time_t time_now = 0;
 801a800:	2300      	movs	r3, #0
 801a802:	60fb      	str	r3, [r7, #12]

    /* optimization: find rtc device only first. */
    if (device == RT_NULL)
 801a804:	4b17      	ldr	r3, [pc, #92]	; (801a864 <time+0x6c>)
 801a806:	681b      	ldr	r3, [r3, #0]
 801a808:	2b00      	cmp	r3, #0
 801a80a:	d105      	bne.n	801a818 <time+0x20>
    {
        device = rt_device_find("rtc");
 801a80c:	4816      	ldr	r0, [pc, #88]	; (801a868 <time+0x70>)
 801a80e:	f7fb f9c7 	bl	8015ba0 <rt_device_find>
 801a812:	4602      	mov	r2, r0
 801a814:	4b13      	ldr	r3, [pc, #76]	; (801a864 <time+0x6c>)
 801a816:	601a      	str	r2, [r3, #0]
    }

    /* read timestamp from RTC device. */
    if (device != RT_NULL)
 801a818:	4b12      	ldr	r3, [pc, #72]	; (801a864 <time+0x6c>)
 801a81a:	681b      	ldr	r3, [r3, #0]
 801a81c:	2b00      	cmp	r3, #0
 801a81e:	d016      	beq.n	801a84e <time+0x56>
    {
        if (rt_device_open(device, 0) == RT_EOK)
 801a820:	4b10      	ldr	r3, [pc, #64]	; (801a864 <time+0x6c>)
 801a822:	681b      	ldr	r3, [r3, #0]
 801a824:	4618      	mov	r0, r3
 801a826:	2100      	movs	r1, #0
 801a828:	f7fb f9f6 	bl	8015c18 <rt_device_open>
 801a82c:	4603      	mov	r3, r0
 801a82e:	2b00      	cmp	r3, #0
 801a830:	d10d      	bne.n	801a84e <time+0x56>
        {
            rt_device_control(device, RT_DEVICE_CTRL_RTC_GET_TIME, &time_now);
 801a832:	4b0c      	ldr	r3, [pc, #48]	; (801a864 <time+0x6c>)
 801a834:	681a      	ldr	r2, [r3, #0]
 801a836:	f107 030c 	add.w	r3, r7, #12
 801a83a:	4610      	mov	r0, r2
 801a83c:	2110      	movs	r1, #16
 801a83e:	461a      	mov	r2, r3
 801a840:	f7fb fb04 	bl	8015e4c <rt_device_control>
            rt_device_close(device);
 801a844:	4b07      	ldr	r3, [pc, #28]	; (801a864 <time+0x6c>)
 801a846:	681b      	ldr	r3, [r3, #0]
 801a848:	4618      	mov	r0, r3
 801a84a:	f7fb fa59 	bl	8015d00 <rt_device_close>
        }
    }

    /* if t is not NULL, write timestamp to *t */
    if (t != RT_NULL)
 801a84e:	687b      	ldr	r3, [r7, #4]
 801a850:	2b00      	cmp	r3, #0
 801a852:	d002      	beq.n	801a85a <time+0x62>
    {
        *t = time_now;
 801a854:	68fa      	ldr	r2, [r7, #12]
 801a856:	687b      	ldr	r3, [r7, #4]
 801a858:	601a      	str	r2, [r3, #0]
    }

    return time_now;
 801a85a:	68fb      	ldr	r3, [r7, #12]
}
 801a85c:	4618      	mov	r0, r3
 801a85e:	3710      	adds	r7, #16
 801a860:	46bd      	mov	sp, r7
 801a862:	bd80      	pop	{r7, pc}
 801a864:	20011084 	.word	0x20011084
 801a868:	08027ee8 	.word	0x08027ee8

0801a86c <set_date>:
 * \param rt_uint32_t day   e.g: e.g: 31.
 * \return rt_err_t if set success, return RT_EOK.
 *
 */
rt_err_t set_date(rt_uint32_t year, rt_uint32_t month, rt_uint32_t day)
{
 801a86c:	b580      	push	{r7, lr}
 801a86e:	b092      	sub	sp, #72	; 0x48
 801a870:	af00      	add	r7, sp, #0
 801a872:	60f8      	str	r0, [r7, #12]
 801a874:	60b9      	str	r1, [r7, #8]
 801a876:	607a      	str	r2, [r7, #4]
    time_t now;
    struct tm *p_tm;
    struct tm tm_new;
    rt_device_t device;
    rt_err_t ret = -RT_ERROR;
 801a878:	f04f 33ff 	mov.w	r3, #4294967295
 801a87c:	647b      	str	r3, [r7, #68]	; 0x44

    /* get current time */
    now = time(RT_NULL);
 801a87e:	2000      	movs	r0, #0
 801a880:	f7ff ffba 	bl	801a7f8 <time>
 801a884:	4603      	mov	r3, r0
 801a886:	63bb      	str	r3, [r7, #56]	; 0x38

    /* lock scheduler. */
    rt_enter_critical();
 801a888:	f7fe f832 	bl	80188f0 <rt_enter_critical>
    /* converts calendar time time into local time. */
    p_tm = localtime(&now);
 801a88c:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801a890:	4618      	mov	r0, r3
 801a892:	f008 f933 	bl	8022afc <localtime>
 801a896:	6438      	str	r0, [r7, #64]	; 0x40
    /* copy the statically located variable */
    memcpy(&tm_new, p_tm, sizeof(struct tm));
 801a898:	f107 0314 	add.w	r3, r7, #20
 801a89c:	4618      	mov	r0, r3
 801a89e:	6c39      	ldr	r1, [r7, #64]	; 0x40
 801a8a0:	2224      	movs	r2, #36	; 0x24
 801a8a2:	f7e5 fd1b 	bl	80002dc <memcpy>
    /* unlock scheduler. */
    rt_exit_critical();
 801a8a6:	f7fe f837 	bl	8018918 <rt_exit_critical>

    /* update date. */
    tm_new.tm_year = year - 1900;
 801a8aa:	68fb      	ldr	r3, [r7, #12]
 801a8ac:	f2a3 736c 	subw	r3, r3, #1900	; 0x76c
 801a8b0:	62bb      	str	r3, [r7, #40]	; 0x28
    tm_new.tm_mon  = month - 1; /* tm_mon: 0~11 */
 801a8b2:	68bb      	ldr	r3, [r7, #8]
 801a8b4:	3b01      	subs	r3, #1
 801a8b6:	627b      	str	r3, [r7, #36]	; 0x24
    tm_new.tm_mday = day;
 801a8b8:	687b      	ldr	r3, [r7, #4]
 801a8ba:	623b      	str	r3, [r7, #32]

    /* converts the local time in time to calendar time. */
    now = mktime(&tm_new);
 801a8bc:	f107 0314 	add.w	r3, r7, #20
 801a8c0:	4618      	mov	r0, r3
 801a8c2:	f008 fbb1 	bl	8023028 <mktime>
 801a8c6:	4603      	mov	r3, r0
 801a8c8:	63bb      	str	r3, [r7, #56]	; 0x38

    device = rt_device_find("rtc");
 801a8ca:	480b      	ldr	r0, [pc, #44]	; (801a8f8 <set_date+0x8c>)
 801a8cc:	f7fb f968 	bl	8015ba0 <rt_device_find>
 801a8d0:	63f8      	str	r0, [r7, #60]	; 0x3c
    if (device == RT_NULL)
 801a8d2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a8d4:	2b00      	cmp	r3, #0
 801a8d6:	d102      	bne.n	801a8de <set_date+0x72>
    {
        return -RT_ERROR;
 801a8d8:	f04f 33ff 	mov.w	r3, #4294967295
 801a8dc:	e008      	b.n	801a8f0 <set_date+0x84>
    }

    /* update to RTC device. */
    ret = rt_device_control(device, RT_DEVICE_CTRL_RTC_SET_TIME, &now);
 801a8de:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801a8e2:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 801a8e4:	2111      	movs	r1, #17
 801a8e6:	461a      	mov	r2, r3
 801a8e8:	f7fb fab0 	bl	8015e4c <rt_device_control>
 801a8ec:	6478      	str	r0, [r7, #68]	; 0x44

    return ret;
 801a8ee:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 801a8f0:	4618      	mov	r0, r3
 801a8f2:	3748      	adds	r7, #72	; 0x48
 801a8f4:	46bd      	mov	sp, r7
 801a8f6:	bd80      	pop	{r7, pc}
 801a8f8:	08027ee8 	.word	0x08027ee8

0801a8fc <set_time>:
 * \param rt_uint32_t second e.g: 0~59.
 * \return rt_err_t if set success, return RT_EOK.
 *
 */
rt_err_t set_time(rt_uint32_t hour, rt_uint32_t minute, rt_uint32_t second)
{
 801a8fc:	b580      	push	{r7, lr}
 801a8fe:	b092      	sub	sp, #72	; 0x48
 801a900:	af00      	add	r7, sp, #0
 801a902:	60f8      	str	r0, [r7, #12]
 801a904:	60b9      	str	r1, [r7, #8]
 801a906:	607a      	str	r2, [r7, #4]
    time_t now;
    struct tm *p_tm;
    struct tm tm_new;
    rt_device_t device;
    rt_err_t ret = -RT_ERROR;
 801a908:	f04f 33ff 	mov.w	r3, #4294967295
 801a90c:	647b      	str	r3, [r7, #68]	; 0x44

    /* get current time */
    now = time(RT_NULL);
 801a90e:	2000      	movs	r0, #0
 801a910:	f7ff ff72 	bl	801a7f8 <time>
 801a914:	4603      	mov	r3, r0
 801a916:	63bb      	str	r3, [r7, #56]	; 0x38

    /* lock scheduler. */
    rt_enter_critical();
 801a918:	f7fd ffea 	bl	80188f0 <rt_enter_critical>
    /* converts calendar time time into local time. */
    p_tm = localtime(&now);
 801a91c:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801a920:	4618      	mov	r0, r3
 801a922:	f008 f8eb 	bl	8022afc <localtime>
 801a926:	6438      	str	r0, [r7, #64]	; 0x40
    /* copy the statically located variable */
    memcpy(&tm_new, p_tm, sizeof(struct tm));
 801a928:	f107 0314 	add.w	r3, r7, #20
 801a92c:	4618      	mov	r0, r3
 801a92e:	6c39      	ldr	r1, [r7, #64]	; 0x40
 801a930:	2224      	movs	r2, #36	; 0x24
 801a932:	f7e5 fcd3 	bl	80002dc <memcpy>
    /* unlock scheduler. */
    rt_exit_critical();
 801a936:	f7fd ffef 	bl	8018918 <rt_exit_critical>

    /* update time. */
    tm_new.tm_hour = hour;
 801a93a:	68fb      	ldr	r3, [r7, #12]
 801a93c:	61fb      	str	r3, [r7, #28]
    tm_new.tm_min  = minute;
 801a93e:	68bb      	ldr	r3, [r7, #8]
 801a940:	61bb      	str	r3, [r7, #24]
    tm_new.tm_sec  = second;
 801a942:	687b      	ldr	r3, [r7, #4]
 801a944:	617b      	str	r3, [r7, #20]

    /* converts the local time in time to calendar time. */
    now = mktime(&tm_new);
 801a946:	f107 0314 	add.w	r3, r7, #20
 801a94a:	4618      	mov	r0, r3
 801a94c:	f008 fb6c 	bl	8023028 <mktime>
 801a950:	4603      	mov	r3, r0
 801a952:	63bb      	str	r3, [r7, #56]	; 0x38

    device = rt_device_find("rtc");
 801a954:	480b      	ldr	r0, [pc, #44]	; (801a984 <set_time+0x88>)
 801a956:	f7fb f923 	bl	8015ba0 <rt_device_find>
 801a95a:	63f8      	str	r0, [r7, #60]	; 0x3c
    if (device == RT_NULL)
 801a95c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a95e:	2b00      	cmp	r3, #0
 801a960:	d102      	bne.n	801a968 <set_time+0x6c>
    {
        return -RT_ERROR;
 801a962:	f04f 33ff 	mov.w	r3, #4294967295
 801a966:	e008      	b.n	801a97a <set_time+0x7e>
    }

    /* update to RTC device. */
    ret = rt_device_control(device, RT_DEVICE_CTRL_RTC_SET_TIME, &now);
 801a968:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801a96c:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 801a96e:	2111      	movs	r1, #17
 801a970:	461a      	mov	r2, r3
 801a972:	f7fb fa6b 	bl	8015e4c <rt_device_control>
 801a976:	6478      	str	r0, [r7, #68]	; 0x44

    return ret;
 801a978:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 801a97a:	4618      	mov	r0, r3
 801a97c:	3748      	adds	r7, #72	; 0x48
 801a97e:	46bd      	mov	sp, r7
 801a980:	bd80      	pop	{r7, pc}
 801a982:	bf00      	nop
 801a984:	08027ee8 	.word	0x08027ee8

0801a988 <list_date>:
#ifdef RT_USING_FINSH
#include <finsh.h>
#include <rtdevice.h>

void list_date(void)
{
 801a988:	b580      	push	{r7, lr}
 801a98a:	b082      	sub	sp, #8
 801a98c:	af00      	add	r7, sp, #0
    time_t now;

    now = time(RT_NULL);
 801a98e:	2000      	movs	r0, #0
 801a990:	f7ff ff32 	bl	801a7f8 <time>
 801a994:	4603      	mov	r3, r0
 801a996:	607b      	str	r3, [r7, #4]
    rt_kprintf("%s\n", ctime(&now));
 801a998:	1d3b      	adds	r3, r7, #4
 801a99a:	4618      	mov	r0, r3
 801a99c:	f008 f8a6 	bl	8022aec <ctime>
 801a9a0:	4603      	mov	r3, r0
 801a9a2:	4803      	ldr	r0, [pc, #12]	; (801a9b0 <list_date+0x28>)
 801a9a4:	4619      	mov	r1, r3
 801a9a6:	f7fc ff89 	bl	80178bc <rt_kprintf>
}
 801a9aa:	3708      	adds	r7, #8
 801a9ac:	46bd      	mov	sp, r7
 801a9ae:	bd80      	pop	{r7, pc}
 801a9b0:	08027eec 	.word	0x08027eec

0801a9b4 <_serial_poll_rx>:

/*
 * Serial poll routines 
 */
rt_inline int _serial_poll_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
 801a9b4:	b580      	push	{r7, lr}
 801a9b6:	b086      	sub	sp, #24
 801a9b8:	af00      	add	r7, sp, #0
 801a9ba:	60f8      	str	r0, [r7, #12]
 801a9bc:	60b9      	str	r1, [r7, #8]
 801a9be:	607a      	str	r2, [r7, #4]
    int ch;
    int size;
    
    RT_ASSERT(serial != RT_NULL);
 801a9c0:	68fb      	ldr	r3, [r7, #12]
 801a9c2:	2b00      	cmp	r3, #0
 801a9c4:	d104      	bne.n	801a9d0 <_serial_poll_rx+0x1c>
 801a9c6:	4813      	ldr	r0, [pc, #76]	; (801aa14 <_serial_poll_rx+0x60>)
 801a9c8:	4913      	ldr	r1, [pc, #76]	; (801aa18 <_serial_poll_rx+0x64>)
 801a9ca:	222e      	movs	r2, #46	; 0x2e
 801a9cc:	f7fc fff0 	bl	80179b0 <rt_assert_handler>
    size = length;
 801a9d0:	687b      	ldr	r3, [r7, #4]
 801a9d2:	617b      	str	r3, [r7, #20]

    while (length)
 801a9d4:	e013      	b.n	801a9fe <_serial_poll_rx+0x4a>
    {
        ch = serial->ops->getc(serial);
 801a9d6:	68fb      	ldr	r3, [r7, #12]
 801a9d8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a9da:	68db      	ldr	r3, [r3, #12]
 801a9dc:	68f8      	ldr	r0, [r7, #12]
 801a9de:	4798      	blx	r3
 801a9e0:	6138      	str	r0, [r7, #16]
        *data = ch; 
 801a9e2:	693b      	ldr	r3, [r7, #16]
 801a9e4:	b2da      	uxtb	r2, r3
 801a9e6:	68bb      	ldr	r3, [r7, #8]
 801a9e8:	701a      	strb	r2, [r3, #0]
        data ++; length --;
 801a9ea:	68bb      	ldr	r3, [r7, #8]
 801a9ec:	3301      	adds	r3, #1
 801a9ee:	60bb      	str	r3, [r7, #8]
 801a9f0:	687b      	ldr	r3, [r7, #4]
 801a9f2:	3b01      	subs	r3, #1
 801a9f4:	607b      	str	r3, [r7, #4]

        if (ch == '\n') break;
 801a9f6:	693b      	ldr	r3, [r7, #16]
 801a9f8:	2b0a      	cmp	r3, #10
 801a9fa:	d100      	bne.n	801a9fe <_serial_poll_rx+0x4a>
 801a9fc:	e002      	b.n	801aa04 <_serial_poll_rx+0x50>
    int size;
    
    RT_ASSERT(serial != RT_NULL);
    size = length;

    while (length)
 801a9fe:	687b      	ldr	r3, [r7, #4]
 801aa00:	2b00      	cmp	r3, #0
 801aa02:	d1e8      	bne.n	801a9d6 <_serial_poll_rx+0x22>
        data ++; length --;

        if (ch == '\n') break;
    }

    return size - length;
 801aa04:	697a      	ldr	r2, [r7, #20]
 801aa06:	687b      	ldr	r3, [r7, #4]
 801aa08:	1ad3      	subs	r3, r2, r3
}
 801aa0a:	4618      	mov	r0, r3
 801aa0c:	3718      	adds	r7, #24
 801aa0e:	46bd      	mov	sp, r7
 801aa10:	bd80      	pop	{r7, pc}
 801aa12:	bf00      	nop
 801aa14:	08027ef0 	.word	0x08027ef0
 801aa18:	08029558 	.word	0x08029558

0801aa1c <_serial_poll_tx>:

rt_inline int _serial_poll_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
 801aa1c:	b580      	push	{r7, lr}
 801aa1e:	b086      	sub	sp, #24
 801aa20:	af00      	add	r7, sp, #0
 801aa22:	60f8      	str	r0, [r7, #12]
 801aa24:	60b9      	str	r1, [r7, #8]
 801aa26:	607a      	str	r2, [r7, #4]
    int size;
    RT_ASSERT(serial != RT_NULL);
 801aa28:	68fb      	ldr	r3, [r7, #12]
 801aa2a:	2b00      	cmp	r3, #0
 801aa2c:	d104      	bne.n	801aa38 <_serial_poll_tx+0x1c>
 801aa2e:	4818      	ldr	r0, [pc, #96]	; (801aa90 <_serial_poll_tx+0x74>)
 801aa30:	4918      	ldr	r1, [pc, #96]	; (801aa94 <_serial_poll_tx+0x78>)
 801aa32:	2240      	movs	r2, #64	; 0x40
 801aa34:	f7fc ffbc 	bl	80179b0 <rt_assert_handler>

    size = length;
 801aa38:	687b      	ldr	r3, [r7, #4]
 801aa3a:	617b      	str	r3, [r7, #20]
    while (length)
 801aa3c:	e01d      	b.n	801aa7a <_serial_poll_tx+0x5e>
    {
        /*
         * to be polite with serial console add a line feed
         * to the carriage return character
         */
        if (*data == '\n' && (serial->parent.open_flag & RT_DEVICE_FLAG_STREAM))
 801aa3e:	68bb      	ldr	r3, [r7, #8]
 801aa40:	781b      	ldrb	r3, [r3, #0]
 801aa42:	2b0a      	cmp	r3, #10
 801aa44:	d10b      	bne.n	801aa5e <_serial_poll_tx+0x42>
 801aa46:	68fb      	ldr	r3, [r7, #12]
 801aa48:	8b1b      	ldrh	r3, [r3, #24]
 801aa4a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801aa4e:	2b00      	cmp	r3, #0
 801aa50:	d005      	beq.n	801aa5e <_serial_poll_tx+0x42>
        {
            serial->ops->putc(serial, '\r');
 801aa52:	68fb      	ldr	r3, [r7, #12]
 801aa54:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801aa56:	689b      	ldr	r3, [r3, #8]
 801aa58:	68f8      	ldr	r0, [r7, #12]
 801aa5a:	210d      	movs	r1, #13
 801aa5c:	4798      	blx	r3
        }
    
        serial->ops->putc(serial, *data);
 801aa5e:	68fb      	ldr	r3, [r7, #12]
 801aa60:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801aa62:	689b      	ldr	r3, [r3, #8]
 801aa64:	68ba      	ldr	r2, [r7, #8]
 801aa66:	7812      	ldrb	r2, [r2, #0]
 801aa68:	68f8      	ldr	r0, [r7, #12]
 801aa6a:	4611      	mov	r1, r2
 801aa6c:	4798      	blx	r3
    
        ++ data;
 801aa6e:	68bb      	ldr	r3, [r7, #8]
 801aa70:	3301      	adds	r3, #1
 801aa72:	60bb      	str	r3, [r7, #8]
        -- length;
 801aa74:	687b      	ldr	r3, [r7, #4]
 801aa76:	3b01      	subs	r3, #1
 801aa78:	607b      	str	r3, [r7, #4]
{
    int size;
    RT_ASSERT(serial != RT_NULL);

    size = length;
    while (length)
 801aa7a:	687b      	ldr	r3, [r7, #4]
 801aa7c:	2b00      	cmp	r3, #0
 801aa7e:	d1de      	bne.n	801aa3e <_serial_poll_tx+0x22>
    
        ++ data;
        -- length;
    }

    return size - length;
 801aa80:	697a      	ldr	r2, [r7, #20]
 801aa82:	687b      	ldr	r3, [r7, #4]
 801aa84:	1ad3      	subs	r3, r2, r3
}
 801aa86:	4618      	mov	r0, r3
 801aa88:	3718      	adds	r7, #24
 801aa8a:	46bd      	mov	sp, r7
 801aa8c:	bd80      	pop	{r7, pc}
 801aa8e:	bf00      	nop
 801aa90:	08027ef0 	.word	0x08027ef0
 801aa94:	08029588 	.word	0x08029588

0801aa98 <_serial_int_rx>:

/*
 * Serial interrupt routines
 */
rt_inline int _serial_int_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
 801aa98:	b580      	push	{r7, lr}
 801aa9a:	b088      	sub	sp, #32
 801aa9c:	af00      	add	r7, sp, #0
 801aa9e:	60f8      	str	r0, [r7, #12]
 801aaa0:	60b9      	str	r1, [r7, #8]
 801aaa2:	607a      	str	r2, [r7, #4]
    int size;
    struct rt_serial_rx_fifo* rx_fifo;

    RT_ASSERT(serial != RT_NULL);
 801aaa4:	68fb      	ldr	r3, [r7, #12]
 801aaa6:	2b00      	cmp	r3, #0
 801aaa8:	d104      	bne.n	801aab4 <_serial_int_rx+0x1c>
 801aaaa:	4828      	ldr	r0, [pc, #160]	; (801ab4c <_serial_int_rx+0xb4>)
 801aaac:	4928      	ldr	r1, [pc, #160]	; (801ab50 <_serial_int_rx+0xb8>)
 801aaae:	225f      	movs	r2, #95	; 0x5f
 801aab0:	f7fc ff7e 	bl	80179b0 <rt_assert_handler>
    size = length; 
 801aab4:	687b      	ldr	r3, [r7, #4]
 801aab6:	61fb      	str	r3, [r7, #28]
    
    rx_fifo = (struct rt_serial_rx_fifo*) serial->serial_rx;
 801aab8:	68fb      	ldr	r3, [r7, #12]
 801aaba:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801aabc:	61bb      	str	r3, [r7, #24]
    RT_ASSERT(rx_fifo != RT_NULL);
 801aabe:	69bb      	ldr	r3, [r7, #24]
 801aac0:	2b00      	cmp	r3, #0
 801aac2:	d104      	bne.n	801aace <_serial_int_rx+0x36>
 801aac4:	4823      	ldr	r0, [pc, #140]	; (801ab54 <_serial_int_rx+0xbc>)
 801aac6:	4922      	ldr	r1, [pc, #136]	; (801ab50 <_serial_int_rx+0xb8>)
 801aac8:	2263      	movs	r2, #99	; 0x63
 801aaca:	f7fc ff71 	bl	80179b0 <rt_assert_handler>

    /* read from software FIFO */
    while (length)
 801aace:	e033      	b.n	801ab38 <_serial_int_rx+0xa0>
    {
        int ch;
        rt_base_t level;

        /* disable interrupt */
        level = rt_hw_interrupt_disable();
 801aad0:	f7e5 fb7a 	bl	80001c8 <rt_hw_interrupt_disable>
 801aad4:	6178      	str	r0, [r7, #20]
        if (rx_fifo->get_index != rx_fifo->put_index)
 801aad6:	69bb      	ldr	r3, [r7, #24]
 801aad8:	88da      	ldrh	r2, [r3, #6]
 801aada:	69bb      	ldr	r3, [r7, #24]
 801aadc:	889b      	ldrh	r3, [r3, #4]
 801aade:	429a      	cmp	r2, r3
 801aae0:	d019      	beq.n	801ab16 <_serial_int_rx+0x7e>
        {
            ch = rx_fifo->buffer[rx_fifo->get_index];
 801aae2:	69bb      	ldr	r3, [r7, #24]
 801aae4:	681b      	ldr	r3, [r3, #0]
 801aae6:	69ba      	ldr	r2, [r7, #24]
 801aae8:	88d2      	ldrh	r2, [r2, #6]
 801aaea:	4413      	add	r3, r2
 801aaec:	781b      	ldrb	r3, [r3, #0]
 801aaee:	613b      	str	r3, [r7, #16]
            rx_fifo->get_index += 1;
 801aaf0:	69bb      	ldr	r3, [r7, #24]
 801aaf2:	88db      	ldrh	r3, [r3, #6]
 801aaf4:	3301      	adds	r3, #1
 801aaf6:	b29a      	uxth	r2, r3
 801aaf8:	69bb      	ldr	r3, [r7, #24]
 801aafa:	80da      	strh	r2, [r3, #6]
            if (rx_fifo->get_index >= serial->config.bufsz) rx_fifo->get_index = 0;
 801aafc:	69bb      	ldr	r3, [r7, #24]
 801aafe:	88da      	ldrh	r2, [r3, #6]
 801ab00:	68fb      	ldr	r3, [r7, #12]
 801ab02:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801ab04:	f3c3 238f 	ubfx	r3, r3, #10, #16
 801ab08:	b29b      	uxth	r3, r3
 801ab0a:	429a      	cmp	r2, r3
 801ab0c:	d307      	bcc.n	801ab1e <_serial_int_rx+0x86>
 801ab0e:	69bb      	ldr	r3, [r7, #24]
 801ab10:	2200      	movs	r2, #0
 801ab12:	80da      	strh	r2, [r3, #6]
 801ab14:	e003      	b.n	801ab1e <_serial_int_rx+0x86>
        }
        else
        {
            /* no data, enable interrupt and break out */
            rt_hw_interrupt_enable(level);
 801ab16:	6978      	ldr	r0, [r7, #20]
 801ab18:	f7e5 fb5a 	bl	80001d0 <rt_hw_interrupt_enable>
            break;
 801ab1c:	e00f      	b.n	801ab3e <_serial_int_rx+0xa6>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 801ab1e:	6978      	ldr	r0, [r7, #20]
 801ab20:	f7e5 fb56 	bl	80001d0 <rt_hw_interrupt_enable>

        *data = ch & 0xff;
 801ab24:	693b      	ldr	r3, [r7, #16]
 801ab26:	b2da      	uxtb	r2, r3
 801ab28:	68bb      	ldr	r3, [r7, #8]
 801ab2a:	701a      	strb	r2, [r3, #0]
        data ++; length --;
 801ab2c:	68bb      	ldr	r3, [r7, #8]
 801ab2e:	3301      	adds	r3, #1
 801ab30:	60bb      	str	r3, [r7, #8]
 801ab32:	687b      	ldr	r3, [r7, #4]
 801ab34:	3b01      	subs	r3, #1
 801ab36:	607b      	str	r3, [r7, #4]
    
    rx_fifo = (struct rt_serial_rx_fifo*) serial->serial_rx;
    RT_ASSERT(rx_fifo != RT_NULL);

    /* read from software FIFO */
    while (length)
 801ab38:	687b      	ldr	r3, [r7, #4]
 801ab3a:	2b00      	cmp	r3, #0
 801ab3c:	d1c8      	bne.n	801aad0 <_serial_int_rx+0x38>

        *data = ch & 0xff;
        data ++; length --;
    }

    return size - length;
 801ab3e:	69fa      	ldr	r2, [r7, #28]
 801ab40:	687b      	ldr	r3, [r7, #4]
 801ab42:	1ad3      	subs	r3, r2, r3
}
 801ab44:	4618      	mov	r0, r3
 801ab46:	3720      	adds	r7, #32
 801ab48:	46bd      	mov	sp, r7
 801ab4a:	bd80      	pop	{r7, pc}
 801ab4c:	08027ef0 	.word	0x08027ef0
 801ab50:	08029538 	.word	0x08029538
 801ab54:	08027f04 	.word	0x08027f04

0801ab58 <_serial_int_tx>:

rt_inline int _serial_int_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
 801ab58:	b580      	push	{r7, lr}
 801ab5a:	b086      	sub	sp, #24
 801ab5c:	af00      	add	r7, sp, #0
 801ab5e:	60f8      	str	r0, [r7, #12]
 801ab60:	60b9      	str	r1, [r7, #8]
 801ab62:	607a      	str	r2, [r7, #4]
    int size;
    struct rt_serial_tx_fifo *tx;
    
    RT_ASSERT(serial != RT_NULL);
 801ab64:	68fb      	ldr	r3, [r7, #12]
 801ab66:	2b00      	cmp	r3, #0
 801ab68:	d104      	bne.n	801ab74 <_serial_int_tx+0x1c>
 801ab6a:	481b      	ldr	r0, [pc, #108]	; (801abd8 <_serial_int_tx+0x80>)
 801ab6c:	491b      	ldr	r1, [pc, #108]	; (801abdc <_serial_int_tx+0x84>)
 801ab6e:	2289      	movs	r2, #137	; 0x89
 801ab70:	f7fc ff1e 	bl	80179b0 <rt_assert_handler>

    size = length;
 801ab74:	687b      	ldr	r3, [r7, #4]
 801ab76:	617b      	str	r3, [r7, #20]
    tx = (struct rt_serial_tx_fifo*) serial->serial_tx;
 801ab78:	68fb      	ldr	r3, [r7, #12]
 801ab7a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801ab7c:	613b      	str	r3, [r7, #16]
    RT_ASSERT(tx != RT_NULL);
 801ab7e:	693b      	ldr	r3, [r7, #16]
 801ab80:	2b00      	cmp	r3, #0
 801ab82:	d104      	bne.n	801ab8e <_serial_int_tx+0x36>
 801ab84:	4816      	ldr	r0, [pc, #88]	; (801abe0 <_serial_int_tx+0x88>)
 801ab86:	4915      	ldr	r1, [pc, #84]	; (801abdc <_serial_int_tx+0x84>)
 801ab88:	228d      	movs	r2, #141	; 0x8d
 801ab8a:	f7fc ff11 	bl	80179b0 <rt_assert_handler>

    while (length)
 801ab8e:	e018      	b.n	801abc2 <_serial_int_tx+0x6a>
    {
        if (serial->ops->putc(serial, *(char*)data) == -1)
 801ab90:	68fb      	ldr	r3, [r7, #12]
 801ab92:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801ab94:	689b      	ldr	r3, [r3, #8]
 801ab96:	68ba      	ldr	r2, [r7, #8]
 801ab98:	7812      	ldrb	r2, [r2, #0]
 801ab9a:	68f8      	ldr	r0, [r7, #12]
 801ab9c:	4611      	mov	r1, r2
 801ab9e:	4798      	blx	r3
 801aba0:	4603      	mov	r3, r0
 801aba2:	f1b3 3fff 	cmp.w	r3, #4294967295
 801aba6:	d106      	bne.n	801abb6 <_serial_int_tx+0x5e>
        {
            rt_completion_wait(&(tx->completion), RT_WAITING_FOREVER);
 801aba8:	693b      	ldr	r3, [r7, #16]
 801abaa:	4618      	mov	r0, r3
 801abac:	f04f 31ff 	mov.w	r1, #4294967295
 801abb0:	f7ff f876 	bl	8019ca0 <rt_completion_wait>
            continue;
 801abb4:	e005      	b.n	801abc2 <_serial_int_tx+0x6a>
        }

        data ++; length --;
 801abb6:	68bb      	ldr	r3, [r7, #8]
 801abb8:	3301      	adds	r3, #1
 801abba:	60bb      	str	r3, [r7, #8]
 801abbc:	687b      	ldr	r3, [r7, #4]
 801abbe:	3b01      	subs	r3, #1
 801abc0:	607b      	str	r3, [r7, #4]

    size = length;
    tx = (struct rt_serial_tx_fifo*) serial->serial_tx;
    RT_ASSERT(tx != RT_NULL);

    while (length)
 801abc2:	687b      	ldr	r3, [r7, #4]
 801abc4:	2b00      	cmp	r3, #0
 801abc6:	d1e3      	bne.n	801ab90 <_serial_int_tx+0x38>
        }

        data ++; length --;
    }

    return size - length;
 801abc8:	697a      	ldr	r2, [r7, #20]
 801abca:	687b      	ldr	r3, [r7, #4]
 801abcc:	1ad3      	subs	r3, r2, r3
}
 801abce:	4618      	mov	r0, r3
 801abd0:	3718      	adds	r7, #24
 801abd2:	46bd      	mov	sp, r7
 801abd4:	bd80      	pop	{r7, pc}
 801abd6:	bf00      	nop
 801abd8:	08027ef0 	.word	0x08027ef0
 801abdc:	08029578 	.word	0x08029578
 801abe0:	08027f18 	.word	0x08027f18

0801abe4 <_serial_dma_rx>:

/*
 * Serial DMA routines
 */
rt_inline int _serial_dma_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
 801abe4:	b590      	push	{r4, r7, lr}
 801abe6:	b089      	sub	sp, #36	; 0x24
 801abe8:	af00      	add	r7, sp, #0
 801abea:	60f8      	str	r0, [r7, #12]
 801abec:	60b9      	str	r1, [r7, #8]
 801abee:	607a      	str	r2, [r7, #4]
    rt_base_t level;
    int result = RT_EOK;
 801abf0:	2300      	movs	r3, #0
 801abf2:	61fb      	str	r3, [r7, #28]
    struct rt_serial_rx_dma *rx_dma;

    RT_ASSERT((serial != RT_NULL) && (data != RT_NULL));
 801abf4:	68fb      	ldr	r3, [r7, #12]
 801abf6:	2b00      	cmp	r3, #0
 801abf8:	d002      	beq.n	801ac00 <_serial_dma_rx+0x1c>
 801abfa:	68bb      	ldr	r3, [r7, #8]
 801abfc:	2b00      	cmp	r3, #0
 801abfe:	d104      	bne.n	801ac0a <_serial_dma_rx+0x26>
 801ac00:	4815      	ldr	r0, [pc, #84]	; (801ac58 <_serial_dma_rx+0x74>)
 801ac02:	4916      	ldr	r1, [pc, #88]	; (801ac5c <_serial_dma_rx+0x78>)
 801ac04:	22a6      	movs	r2, #166	; 0xa6
 801ac06:	f7fc fed3 	bl	80179b0 <rt_assert_handler>
    rx_dma = (struct rt_serial_rx_dma*)serial->serial_rx;
 801ac0a:	68fb      	ldr	r3, [r7, #12]
 801ac0c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801ac0e:	61bb      	str	r3, [r7, #24]
    RT_ASSERT(rx_dma != RT_NULL);
 801ac10:	69bb      	ldr	r3, [r7, #24]
 801ac12:	2b00      	cmp	r3, #0
 801ac14:	d104      	bne.n	801ac20 <_serial_dma_rx+0x3c>
 801ac16:	4812      	ldr	r0, [pc, #72]	; (801ac60 <_serial_dma_rx+0x7c>)
 801ac18:	4910      	ldr	r1, [pc, #64]	; (801ac5c <_serial_dma_rx+0x78>)
 801ac1a:	22a8      	movs	r2, #168	; 0xa8
 801ac1c:	f7fc fec8 	bl	80179b0 <rt_assert_handler>
    level = rt_hw_interrupt_disable();
 801ac20:	f7e5 fad2 	bl	80001c8 <rt_hw_interrupt_disable>
 801ac24:	6178      	str	r0, [r7, #20]
    //if (rx_dma->activated != RT_TRUE)
    //{
        //rx_dma->activated = RT_TRUE;
        serial->ops->dma_transmit(serial, data, length, RT_SERIAL_DMA_RX);
 801ac26:	68fb      	ldr	r3, [r7, #12]
 801ac28:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801ac2a:	691c      	ldr	r4, [r3, #16]
 801ac2c:	687b      	ldr	r3, [r7, #4]
 801ac2e:	68f8      	ldr	r0, [r7, #12]
 801ac30:	68b9      	ldr	r1, [r7, #8]
 801ac32:	461a      	mov	r2, r3
 801ac34:	2301      	movs	r3, #1
 801ac36:	47a0      	blx	r4
    //}
    //else result = -RT_EBUSY;
    rt_hw_interrupt_enable(level);
 801ac38:	6978      	ldr	r0, [r7, #20]
 801ac3a:	f7e5 fac9 	bl	80001d0 <rt_hw_interrupt_enable>

    if (result == RT_EOK) return length;
 801ac3e:	69fb      	ldr	r3, [r7, #28]
 801ac40:	2b00      	cmp	r3, #0
 801ac42:	d101      	bne.n	801ac48 <_serial_dma_rx+0x64>
 801ac44:	687b      	ldr	r3, [r7, #4]
 801ac46:	e003      	b.n	801ac50 <_serial_dma_rx+0x6c>

    rt_set_errno(result);
 801ac48:	69f8      	ldr	r0, [r7, #28]
 801ac4a:	f7fc f85f 	bl	8016d0c <rt_set_errno>
    return 0;
 801ac4e:	2300      	movs	r3, #0
}
 801ac50:	4618      	mov	r0, r3
 801ac52:	3724      	adds	r7, #36	; 0x24
 801ac54:	46bd      	mov	sp, r7
 801ac56:	bd90      	pop	{r4, r7, pc}
 801ac58:	08027f28 	.word	0x08027f28
 801ac5c:	08029548 	.word	0x08029548
 801ac60:	08027f54 	.word	0x08027f54

0801ac64 <_serial_dma_tx>:

rt_inline int _serial_dma_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
 801ac64:	b590      	push	{r4, r7, lr}
 801ac66:	b089      	sub	sp, #36	; 0x24
 801ac68:	af00      	add	r7, sp, #0
 801ac6a:	60f8      	str	r0, [r7, #12]
 801ac6c:	60b9      	str	r1, [r7, #8]
 801ac6e:	607a      	str	r2, [r7, #4]
    rt_base_t level;
    rt_err_t result;
    struct rt_serial_tx_dma *tx_dma;

    tx_dma = (struct rt_serial_tx_dma*)(serial->serial_tx);
 801ac70:	68fb      	ldr	r3, [r7, #12]
 801ac72:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801ac74:	61fb      	str	r3, [r7, #28]
    
    result = rt_data_queue_push(&(tx_dma->data_queue), data, length, RT_WAITING_FOREVER); 
 801ac76:	69fb      	ldr	r3, [r7, #28]
 801ac78:	1d1a      	adds	r2, r3, #4
 801ac7a:	687b      	ldr	r3, [r7, #4]
 801ac7c:	4610      	mov	r0, r2
 801ac7e:	68b9      	ldr	r1, [r7, #8]
 801ac80:	461a      	mov	r2, r3
 801ac82:	f04f 33ff 	mov.w	r3, #4294967295
 801ac86:	f7ff f941 	bl	8019f0c <rt_data_queue_push>
 801ac8a:	61b8      	str	r0, [r7, #24]
    if (result == RT_EOK)
 801ac8c:	69bb      	ldr	r3, [r7, #24]
 801ac8e:	2b00      	cmp	r3, #0
 801ac90:	d11b      	bne.n	801acca <_serial_dma_tx+0x66>
    {
        level = rt_hw_interrupt_disable();
 801ac92:	f7e5 fa99 	bl	80001c8 <rt_hw_interrupt_disable>
 801ac96:	6178      	str	r0, [r7, #20]
        if (tx_dma->activated != RT_TRUE)
 801ac98:	69fb      	ldr	r3, [r7, #28]
 801ac9a:	681b      	ldr	r3, [r3, #0]
 801ac9c:	2b01      	cmp	r3, #1
 801ac9e:	d00f      	beq.n	801acc0 <_serial_dma_tx+0x5c>
        {
            tx_dma->activated = RT_TRUE;
 801aca0:	69fb      	ldr	r3, [r7, #28]
 801aca2:	2201      	movs	r2, #1
 801aca4:	601a      	str	r2, [r3, #0]
            rt_hw_interrupt_enable(level);
 801aca6:	6978      	ldr	r0, [r7, #20]
 801aca8:	f7e5 fa92 	bl	80001d0 <rt_hw_interrupt_enable>

            /* make a DMA transfer */
            serial->ops->dma_transmit(serial, data, length, RT_SERIAL_DMA_TX);
 801acac:	68fb      	ldr	r3, [r7, #12]
 801acae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801acb0:	691c      	ldr	r4, [r3, #16]
 801acb2:	687b      	ldr	r3, [r7, #4]
 801acb4:	68f8      	ldr	r0, [r7, #12]
 801acb6:	68b9      	ldr	r1, [r7, #8]
 801acb8:	461a      	mov	r2, r3
 801acba:	2302      	movs	r3, #2
 801acbc:	47a0      	blx	r4
 801acbe:	e002      	b.n	801acc6 <_serial_dma_tx+0x62>
        }
        else
        {
            rt_hw_interrupt_enable(level);
 801acc0:	6978      	ldr	r0, [r7, #20]
 801acc2:	f7e5 fa85 	bl	80001d0 <rt_hw_interrupt_enable>
        }

        return length;
 801acc6:	687b      	ldr	r3, [r7, #4]
 801acc8:	e003      	b.n	801acd2 <_serial_dma_tx+0x6e>
    }
    else
    {
        rt_set_errno(result);
 801acca:	69b8      	ldr	r0, [r7, #24]
 801accc:	f7fc f81e 	bl	8016d0c <rt_set_errno>
        return 0;
 801acd0:	2300      	movs	r3, #0
    }
}
 801acd2:	4618      	mov	r0, r3
 801acd4:	3724      	adds	r7, #36	; 0x24
 801acd6:	46bd      	mov	sp, r7
 801acd8:	bd90      	pop	{r4, r7, pc}
 801acda:	bf00      	nop

0801acdc <rt_serial_init>:
/* RT-Thread Device Interface */
/*
 * This function initializes serial device.
 */
static rt_err_t rt_serial_init(struct rt_device *dev)
{
 801acdc:	b580      	push	{r7, lr}
 801acde:	b084      	sub	sp, #16
 801ace0:	af00      	add	r7, sp, #0
 801ace2:	6078      	str	r0, [r7, #4]
    rt_err_t result = RT_EOK;
 801ace4:	2300      	movs	r3, #0
 801ace6:	60fb      	str	r3, [r7, #12]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
 801ace8:	687b      	ldr	r3, [r7, #4]
 801acea:	2b00      	cmp	r3, #0
 801acec:	d104      	bne.n	801acf8 <rt_serial_init+0x1c>
 801acee:	4812      	ldr	r0, [pc, #72]	; (801ad38 <rt_serial_init+0x5c>)
 801acf0:	4912      	ldr	r1, [pc, #72]	; (801ad3c <rt_serial_init+0x60>)
 801acf2:	22e3      	movs	r2, #227	; 0xe3
 801acf4:	f7fc fe5c 	bl	80179b0 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
 801acf8:	687b      	ldr	r3, [r7, #4]
 801acfa:	60bb      	str	r3, [r7, #8]

    /* initialize rx/tx */
    serial->serial_rx = RT_NULL;
 801acfc:	68bb      	ldr	r3, [r7, #8]
 801acfe:	2200      	movs	r2, #0
 801ad00:	64da      	str	r2, [r3, #76]	; 0x4c
    serial->serial_tx = RT_NULL;
 801ad02:	68bb      	ldr	r3, [r7, #8]
 801ad04:	2200      	movs	r2, #0
 801ad06:	651a      	str	r2, [r3, #80]	; 0x50

    /* apply configuration */
    if (serial->ops->configure)
 801ad08:	68bb      	ldr	r3, [r7, #8]
 801ad0a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801ad0c:	681b      	ldr	r3, [r3, #0]
 801ad0e:	2b00      	cmp	r3, #0
 801ad10:	d008      	beq.n	801ad24 <rt_serial_init+0x48>
        result = serial->ops->configure(serial, &serial->config);
 801ad12:	68bb      	ldr	r3, [r7, #8]
 801ad14:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801ad16:	681b      	ldr	r3, [r3, #0]
 801ad18:	68ba      	ldr	r2, [r7, #8]
 801ad1a:	3244      	adds	r2, #68	; 0x44
 801ad1c:	68b8      	ldr	r0, [r7, #8]
 801ad1e:	4611      	mov	r1, r2
 801ad20:	4798      	blx	r3
 801ad22:	60f8      	str	r0, [r7, #12]
	rt_kprintf("%x\r\n", result);
 801ad24:	4806      	ldr	r0, [pc, #24]	; (801ad40 <rt_serial_init+0x64>)
 801ad26:	68f9      	ldr	r1, [r7, #12]
 801ad28:	f7fc fdc8 	bl	80178bc <rt_kprintf>
    return result;
 801ad2c:	68fb      	ldr	r3, [r7, #12]
}
 801ad2e:	4618      	mov	r0, r3
 801ad30:	3710      	adds	r7, #16
 801ad32:	46bd      	mov	sp, r7
 801ad34:	bd80      	pop	{r7, pc}
 801ad36:	bf00      	nop
 801ad38:	08027f68 	.word	0x08027f68
 801ad3c:	080294f8 	.word	0x080294f8
 801ad40:	08027f78 	.word	0x08027f78

0801ad44 <rt_serial_open>:

static rt_err_t rt_serial_open(struct rt_device *dev, rt_uint16_t oflag)
{
 801ad44:	b580      	push	{r7, lr}
 801ad46:	b088      	sub	sp, #32
 801ad48:	af00      	add	r7, sp, #0
 801ad4a:	6078      	str	r0, [r7, #4]
 801ad4c:	460b      	mov	r3, r1
 801ad4e:	807b      	strh	r3, [r7, #2]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
 801ad50:	687b      	ldr	r3, [r7, #4]
 801ad52:	2b00      	cmp	r3, #0
 801ad54:	d104      	bne.n	801ad60 <rt_serial_open+0x1c>
 801ad56:	4889      	ldr	r0, [pc, #548]	; (801af7c <rt_serial_open+0x238>)
 801ad58:	4989      	ldr	r1, [pc, #548]	; (801af80 <rt_serial_open+0x23c>)
 801ad5a:	22f5      	movs	r2, #245	; 0xf5
 801ad5c:	f7fc fe28 	bl	80179b0 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
 801ad60:	687b      	ldr	r3, [r7, #4]
 801ad62:	61fb      	str	r3, [r7, #28]

    /* check device flag with the open flag */
    if ((oflag & RT_DEVICE_FLAG_DMA_RX) && !(dev->flag & RT_DEVICE_FLAG_DMA_RX)) 
 801ad64:	887b      	ldrh	r3, [r7, #2]
 801ad66:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801ad6a:	2b00      	cmp	r3, #0
 801ad6c:	d008      	beq.n	801ad80 <rt_serial_open+0x3c>
 801ad6e:	687b      	ldr	r3, [r7, #4]
 801ad70:	8adb      	ldrh	r3, [r3, #22]
 801ad72:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801ad76:	2b00      	cmp	r3, #0
 801ad78:	d102      	bne.n	801ad80 <rt_serial_open+0x3c>
        return -RT_EIO;
 801ad7a:	f06f 0307 	mvn.w	r3, #7
 801ad7e:	e0f8      	b.n	801af72 <rt_serial_open+0x22e>
    if ((oflag & RT_DEVICE_FLAG_DMA_TX) && !(dev->flag & RT_DEVICE_FLAG_DMA_TX))
 801ad80:	887b      	ldrh	r3, [r7, #2]
 801ad82:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801ad86:	2b00      	cmp	r3, #0
 801ad88:	d008      	beq.n	801ad9c <rt_serial_open+0x58>
 801ad8a:	687b      	ldr	r3, [r7, #4]
 801ad8c:	8adb      	ldrh	r3, [r3, #22]
 801ad8e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801ad92:	2b00      	cmp	r3, #0
 801ad94:	d102      	bne.n	801ad9c <rt_serial_open+0x58>
        return -RT_EIO;
 801ad96:	f06f 0307 	mvn.w	r3, #7
 801ad9a:	e0ea      	b.n	801af72 <rt_serial_open+0x22e>
    if ((oflag & RT_DEVICE_FLAG_INT_RX) && !(dev->flag & RT_DEVICE_FLAG_INT_RX))
 801ad9c:	887b      	ldrh	r3, [r7, #2]
 801ad9e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801ada2:	2b00      	cmp	r3, #0
 801ada4:	d008      	beq.n	801adb8 <rt_serial_open+0x74>
 801ada6:	687b      	ldr	r3, [r7, #4]
 801ada8:	8adb      	ldrh	r3, [r3, #22]
 801adaa:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801adae:	2b00      	cmp	r3, #0
 801adb0:	d102      	bne.n	801adb8 <rt_serial_open+0x74>
        return -RT_EIO;
 801adb2:	f06f 0307 	mvn.w	r3, #7
 801adb6:	e0dc      	b.n	801af72 <rt_serial_open+0x22e>
    if ((oflag & RT_DEVICE_FLAG_INT_TX) && !(dev->flag & RT_DEVICE_FLAG_INT_TX))
 801adb8:	887b      	ldrh	r3, [r7, #2]
 801adba:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801adbe:	2b00      	cmp	r3, #0
 801adc0:	d008      	beq.n	801add4 <rt_serial_open+0x90>
 801adc2:	687b      	ldr	r3, [r7, #4]
 801adc4:	8adb      	ldrh	r3, [r3, #22]
 801adc6:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801adca:	2b00      	cmp	r3, #0
 801adcc:	d102      	bne.n	801add4 <rt_serial_open+0x90>
        return -RT_EIO;
 801adce:	f06f 0307 	mvn.w	r3, #7
 801add2:	e0ce      	b.n	801af72 <rt_serial_open+0x22e>

    /* get open flags */
    dev->open_flag = oflag & 0xff;
 801add4:	887b      	ldrh	r3, [r7, #2]
 801add6:	b2db      	uxtb	r3, r3
 801add8:	b29a      	uxth	r2, r3
 801adda:	687b      	ldr	r3, [r7, #4]
 801addc:	831a      	strh	r2, [r3, #24]
    
    /* initialize the Rx/Tx structure according to open flag */
    if (serial->serial_rx == RT_NULL)
 801adde:	69fb      	ldr	r3, [r7, #28]
 801ade0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801ade2:	2b00      	cmp	r3, #0
 801ade4:	d16c      	bne.n	801aec0 <rt_serial_open+0x17c>
    {
        if (oflag & RT_DEVICE_FLAG_DMA_RX)
 801ade6:	887b      	ldrh	r3, [r7, #2]
 801ade8:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801adec:	2b00      	cmp	r3, #0
 801adee:	d022      	beq.n	801ae36 <rt_serial_open+0xf2>
        {
            struct rt_serial_rx_dma* rx_dma;

            rx_dma = (struct rt_serial_rx_dma*) rt_malloc (sizeof(struct rt_serial_rx_dma));
 801adf0:	2004      	movs	r0, #4
 801adf2:	f7fc ff11 	bl	8017c18 <rt_malloc>
 801adf6:	61b8      	str	r0, [r7, #24]
            RT_ASSERT(rx_dma != RT_NULL);
 801adf8:	69bb      	ldr	r3, [r7, #24]
 801adfa:	2b00      	cmp	r3, #0
 801adfc:	d105      	bne.n	801ae0a <rt_serial_open+0xc6>
 801adfe:	4861      	ldr	r0, [pc, #388]	; (801af84 <rt_serial_open+0x240>)
 801ae00:	495f      	ldr	r1, [pc, #380]	; (801af80 <rt_serial_open+0x23c>)
 801ae02:	f240 120d 	movw	r2, #269	; 0x10d
 801ae06:	f7fc fdd3 	bl	80179b0 <rt_assert_handler>
            rx_dma->activated = RT_FALSE;
 801ae0a:	69bb      	ldr	r3, [r7, #24]
 801ae0c:	2200      	movs	r2, #0
 801ae0e:	601a      	str	r2, [r3, #0]

            serial->serial_rx = rx_dma;
 801ae10:	69fb      	ldr	r3, [r7, #28]
 801ae12:	69ba      	ldr	r2, [r7, #24]
 801ae14:	64da      	str	r2, [r3, #76]	; 0x4c
            dev->open_flag |= RT_DEVICE_FLAG_DMA_RX;
 801ae16:	687b      	ldr	r3, [r7, #4]
 801ae18:	8b1b      	ldrh	r3, [r3, #24]
 801ae1a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 801ae1e:	b29a      	uxth	r2, r3
 801ae20:	687b      	ldr	r3, [r7, #4]
 801ae22:	831a      	strh	r2, [r3, #24]
            serial->ops->control(serial, RT_DEVICE_CTRL_SET_DMARX, (void *)RT_DEVICE_FLAG_DMA_RX);
 801ae24:	69fb      	ldr	r3, [r7, #28]
 801ae26:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801ae28:	685b      	ldr	r3, [r3, #4]
 801ae2a:	69f8      	ldr	r0, [r7, #28]
 801ae2c:	2114      	movs	r1, #20
 801ae2e:	f44f 7200 	mov.w	r2, #512	; 0x200
 801ae32:	4798      	blx	r3
 801ae34:	e044      	b.n	801aec0 <rt_serial_open+0x17c>
        }
        else if (oflag & RT_DEVICE_FLAG_INT_RX)
 801ae36:	887b      	ldrh	r3, [r7, #2]
 801ae38:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801ae3c:	2b00      	cmp	r3, #0
 801ae3e:	d03c      	beq.n	801aeba <rt_serial_open+0x176>
        {
            struct rt_serial_rx_fifo* rx_fifo;

            rx_fifo = (struct rt_serial_rx_fifo*) rt_malloc (sizeof(struct rt_serial_rx_fifo) + 
                serial->config.bufsz);
 801ae40:	69fb      	ldr	r3, [r7, #28]
 801ae42:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801ae44:	f3c3 238f 	ubfx	r3, r3, #10, #16
 801ae48:	b29b      	uxth	r3, r3
        }
        else if (oflag & RT_DEVICE_FLAG_INT_RX)
        {
            struct rt_serial_rx_fifo* rx_fifo;

            rx_fifo = (struct rt_serial_rx_fifo*) rt_malloc (sizeof(struct rt_serial_rx_fifo) + 
 801ae4a:	3308      	adds	r3, #8
 801ae4c:	4618      	mov	r0, r3
 801ae4e:	f7fc fee3 	bl	8017c18 <rt_malloc>
 801ae52:	6178      	str	r0, [r7, #20]
                serial->config.bufsz);
            RT_ASSERT(rx_fifo != RT_NULL);
 801ae54:	697b      	ldr	r3, [r7, #20]
 801ae56:	2b00      	cmp	r3, #0
 801ae58:	d105      	bne.n	801ae66 <rt_serial_open+0x122>
 801ae5a:	484b      	ldr	r0, [pc, #300]	; (801af88 <rt_serial_open+0x244>)
 801ae5c:	4948      	ldr	r1, [pc, #288]	; (801af80 <rt_serial_open+0x23c>)
 801ae5e:	f44f 728d 	mov.w	r2, #282	; 0x11a
 801ae62:	f7fc fda5 	bl	80179b0 <rt_assert_handler>
            rx_fifo->buffer = (rt_uint8_t*) (rx_fifo + 1);
 801ae66:	697b      	ldr	r3, [r7, #20]
 801ae68:	f103 0208 	add.w	r2, r3, #8
 801ae6c:	697b      	ldr	r3, [r7, #20]
 801ae6e:	601a      	str	r2, [r3, #0]
            rt_memset(rx_fifo->buffer, 0, serial->config.bufsz);
 801ae70:	697b      	ldr	r3, [r7, #20]
 801ae72:	681a      	ldr	r2, [r3, #0]
 801ae74:	69fb      	ldr	r3, [r7, #28]
 801ae76:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801ae78:	f3c3 238f 	ubfx	r3, r3, #10, #16
 801ae7c:	b29b      	uxth	r3, r3
 801ae7e:	4610      	mov	r0, r2
 801ae80:	2100      	movs	r1, #0
 801ae82:	461a      	mov	r2, r3
 801ae84:	f7fb ff62 	bl	8016d4c <rt_memset>
            rx_fifo->put_index = 0;
 801ae88:	697b      	ldr	r3, [r7, #20]
 801ae8a:	2200      	movs	r2, #0
 801ae8c:	809a      	strh	r2, [r3, #4]
            rx_fifo->get_index = 0;
 801ae8e:	697b      	ldr	r3, [r7, #20]
 801ae90:	2200      	movs	r2, #0
 801ae92:	80da      	strh	r2, [r3, #6]

            serial->serial_rx = rx_fifo;
 801ae94:	69fb      	ldr	r3, [r7, #28]
 801ae96:	697a      	ldr	r2, [r7, #20]
 801ae98:	64da      	str	r2, [r3, #76]	; 0x4c
            dev->open_flag |= RT_DEVICE_FLAG_INT_RX;
 801ae9a:	687b      	ldr	r3, [r7, #4]
 801ae9c:	8b1b      	ldrh	r3, [r3, #24]
 801ae9e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 801aea2:	b29a      	uxth	r2, r3
 801aea4:	687b      	ldr	r3, [r7, #4]
 801aea6:	831a      	strh	r2, [r3, #24]
            /* configure low level device */
            serial->ops->control(serial, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_RX);
 801aea8:	69fb      	ldr	r3, [r7, #28]
 801aeaa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801aeac:	685b      	ldr	r3, [r3, #4]
 801aeae:	69f8      	ldr	r0, [r7, #28]
 801aeb0:	2110      	movs	r1, #16
 801aeb2:	f44f 7280 	mov.w	r2, #256	; 0x100
 801aeb6:	4798      	blx	r3
 801aeb8:	e002      	b.n	801aec0 <rt_serial_open+0x17c>
        }
        else
        {
            serial->serial_rx = RT_NULL;
 801aeba:	69fb      	ldr	r3, [r7, #28]
 801aebc:	2200      	movs	r2, #0
 801aebe:	64da      	str	r2, [r3, #76]	; 0x4c
        }
    }

    if (serial->serial_tx == RT_NULL)
 801aec0:	69fb      	ldr	r3, [r7, #28]
 801aec2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801aec4:	2b00      	cmp	r3, #0
 801aec6:	d153      	bne.n	801af70 <rt_serial_open+0x22c>
    {
        if (oflag & RT_DEVICE_FLAG_DMA_TX)
 801aec8:	887b      	ldrh	r3, [r7, #2]
 801aeca:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801aece:	2b00      	cmp	r3, #0
 801aed0:	d022      	beq.n	801af18 <rt_serial_open+0x1d4>
        {
            struct rt_serial_tx_dma* tx_dma;

            tx_dma = (struct rt_serial_tx_dma*) rt_malloc (sizeof(struct rt_serial_tx_dma));
 801aed2:	2028      	movs	r0, #40	; 0x28
 801aed4:	f7fc fea0 	bl	8017c18 <rt_malloc>
 801aed8:	6138      	str	r0, [r7, #16]
            RT_ASSERT(tx_dma != RT_NULL);
 801aeda:	693b      	ldr	r3, [r7, #16]
 801aedc:	2b00      	cmp	r3, #0
 801aede:	d105      	bne.n	801aeec <rt_serial_open+0x1a8>
 801aee0:	482a      	ldr	r0, [pc, #168]	; (801af8c <rt_serial_open+0x248>)
 801aee2:	4927      	ldr	r1, [pc, #156]	; (801af80 <rt_serial_open+0x23c>)
 801aee4:	f44f 7299 	mov.w	r2, #306	; 0x132
 801aee8:	f7fc fd62 	bl	80179b0 <rt_assert_handler>
            tx_dma->activated = RT_FALSE;
 801aeec:	693b      	ldr	r3, [r7, #16]
 801aeee:	2200      	movs	r2, #0
 801aef0:	601a      	str	r2, [r3, #0]
            
            rt_data_queue_init(&(tx_dma->data_queue), 8, 4, RT_NULL);
 801aef2:	693b      	ldr	r3, [r7, #16]
 801aef4:	3304      	adds	r3, #4
 801aef6:	4618      	mov	r0, r3
 801aef8:	2108      	movs	r1, #8
 801aefa:	2204      	movs	r2, #4
 801aefc:	2300      	movs	r3, #0
 801aefe:	f7fe ffbf 	bl	8019e80 <rt_data_queue_init>
            serial->serial_tx = tx_dma;
 801af02:	69fb      	ldr	r3, [r7, #28]
 801af04:	693a      	ldr	r2, [r7, #16]
 801af06:	651a      	str	r2, [r3, #80]	; 0x50

            dev->open_flag |= RT_DEVICE_FLAG_DMA_TX;
 801af08:	687b      	ldr	r3, [r7, #4]
 801af0a:	8b1b      	ldrh	r3, [r3, #24]
 801af0c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 801af10:	b29a      	uxth	r2, r3
 801af12:	687b      	ldr	r3, [r7, #4]
 801af14:	831a      	strh	r2, [r3, #24]
 801af16:	e02b      	b.n	801af70 <rt_serial_open+0x22c>
        }
        else if (oflag & RT_DEVICE_FLAG_INT_TX)
 801af18:	887b      	ldrh	r3, [r7, #2]
 801af1a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801af1e:	2b00      	cmp	r3, #0
 801af20:	d023      	beq.n	801af6a <rt_serial_open+0x226>
        {
            struct rt_serial_tx_fifo *tx_fifo;

            tx_fifo = (struct rt_serial_tx_fifo*) rt_malloc(sizeof(struct rt_serial_tx_fifo));
 801af22:	200c      	movs	r0, #12
 801af24:	f7fc fe78 	bl	8017c18 <rt_malloc>
 801af28:	60f8      	str	r0, [r7, #12]
            RT_ASSERT(tx_fifo != RT_NULL);
 801af2a:	68fb      	ldr	r3, [r7, #12]
 801af2c:	2b00      	cmp	r3, #0
 801af2e:	d105      	bne.n	801af3c <rt_serial_open+0x1f8>
 801af30:	4817      	ldr	r0, [pc, #92]	; (801af90 <rt_serial_open+0x24c>)
 801af32:	4913      	ldr	r1, [pc, #76]	; (801af80 <rt_serial_open+0x23c>)
 801af34:	f240 123f 	movw	r2, #319	; 0x13f
 801af38:	f7fc fd3a 	bl	80179b0 <rt_assert_handler>

            rt_completion_init(&(tx_fifo->completion));
 801af3c:	68fb      	ldr	r3, [r7, #12]
 801af3e:	4618      	mov	r0, r3
 801af40:	f7fe fe8c 	bl	8019c5c <rt_completion_init>
            serial->serial_tx = tx_fifo;
 801af44:	69fb      	ldr	r3, [r7, #28]
 801af46:	68fa      	ldr	r2, [r7, #12]
 801af48:	651a      	str	r2, [r3, #80]	; 0x50

            dev->open_flag |= RT_DEVICE_FLAG_INT_TX;
 801af4a:	687b      	ldr	r3, [r7, #4]
 801af4c:	8b1b      	ldrh	r3, [r3, #24]
 801af4e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 801af52:	b29a      	uxth	r2, r3
 801af54:	687b      	ldr	r3, [r7, #4]
 801af56:	831a      	strh	r2, [r3, #24]
            /* configure low level device */
            serial->ops->control(serial, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_TX);
 801af58:	69fb      	ldr	r3, [r7, #28]
 801af5a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801af5c:	685b      	ldr	r3, [r3, #4]
 801af5e:	69f8      	ldr	r0, [r7, #28]
 801af60:	2110      	movs	r1, #16
 801af62:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801af66:	4798      	blx	r3
 801af68:	e002      	b.n	801af70 <rt_serial_open+0x22c>
        }
        else
        {
            serial->serial_tx = RT_NULL;
 801af6a:	69fb      	ldr	r3, [r7, #28]
 801af6c:	2200      	movs	r2, #0
 801af6e:	651a      	str	r2, [r3, #80]	; 0x50
        }
    }

    return RT_EOK;
 801af70:	2300      	movs	r3, #0
}
 801af72:	4618      	mov	r0, r3
 801af74:	3720      	adds	r7, #32
 801af76:	46bd      	mov	sp, r7
 801af78:	bd80      	pop	{r7, pc}
 801af7a:	bf00      	nop
 801af7c:	08027f68 	.word	0x08027f68
 801af80:	08029508 	.word	0x08029508
 801af84:	08027f54 	.word	0x08027f54
 801af88:	08027f04 	.word	0x08027f04
 801af8c:	08027f80 	.word	0x08027f80
 801af90:	08027f94 	.word	0x08027f94

0801af94 <rt_serial_close>:

static rt_err_t rt_serial_close(struct rt_device *dev)
{
 801af94:	b580      	push	{r7, lr}
 801af96:	b088      	sub	sp, #32
 801af98:	af00      	add	r7, sp, #0
 801af9a:	6078      	str	r0, [r7, #4]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
 801af9c:	687b      	ldr	r3, [r7, #4]
 801af9e:	2b00      	cmp	r3, #0
 801afa0:	d105      	bne.n	801afae <rt_serial_close+0x1a>
 801afa2:	4850      	ldr	r0, [pc, #320]	; (801b0e4 <rt_serial_close+0x150>)
 801afa4:	4950      	ldr	r1, [pc, #320]	; (801b0e8 <rt_serial_close+0x154>)
 801afa6:	f240 1255 	movw	r2, #341	; 0x155
 801afaa:	f7fc fd01 	bl	80179b0 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
 801afae:	687b      	ldr	r3, [r7, #4]
 801afb0:	61fb      	str	r3, [r7, #28]

    /* this device has more reference count */
    if (dev->ref_count > 1) return RT_EOK;
 801afb2:	687b      	ldr	r3, [r7, #4]
 801afb4:	7e9b      	ldrb	r3, [r3, #26]
 801afb6:	2b01      	cmp	r3, #1
 801afb8:	d901      	bls.n	801afbe <rt_serial_close+0x2a>
 801afba:	2300      	movs	r3, #0
 801afbc:	e08e      	b.n	801b0dc <rt_serial_close+0x148>
    
    if (dev->open_flag & RT_DEVICE_FLAG_INT_RX)
 801afbe:	687b      	ldr	r3, [r7, #4]
 801afc0:	8b1b      	ldrh	r3, [r3, #24]
 801afc2:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801afc6:	2b00      	cmp	r3, #0
 801afc8:	d021      	beq.n	801b00e <rt_serial_close+0x7a>
    {
        struct rt_serial_rx_fifo* rx_fifo;

        rx_fifo = (struct rt_serial_rx_fifo*)serial->serial_rx;
 801afca:	69fb      	ldr	r3, [r7, #28]
 801afcc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801afce:	61bb      	str	r3, [r7, #24]
        RT_ASSERT(rx_fifo != RT_NULL);
 801afd0:	69bb      	ldr	r3, [r7, #24]
 801afd2:	2b00      	cmp	r3, #0
 801afd4:	d105      	bne.n	801afe2 <rt_serial_close+0x4e>
 801afd6:	4845      	ldr	r0, [pc, #276]	; (801b0ec <rt_serial_close+0x158>)
 801afd8:	4943      	ldr	r1, [pc, #268]	; (801b0e8 <rt_serial_close+0x154>)
 801afda:	f44f 72b0 	mov.w	r2, #352	; 0x160
 801afde:	f7fc fce7 	bl	80179b0 <rt_assert_handler>

        rt_free(rx_fifo);
 801afe2:	69b8      	ldr	r0, [r7, #24]
 801afe4:	f7fd f822 	bl	801802c <rt_free>
        serial->serial_rx = RT_NULL;
 801afe8:	69fb      	ldr	r3, [r7, #28]
 801afea:	2200      	movs	r2, #0
 801afec:	64da      	str	r2, [r3, #76]	; 0x4c
        dev->open_flag &= ~RT_DEVICE_FLAG_INT_RX;
 801afee:	687b      	ldr	r3, [r7, #4]
 801aff0:	8b1b      	ldrh	r3, [r3, #24]
 801aff2:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 801aff6:	b29a      	uxth	r2, r3
 801aff8:	687b      	ldr	r3, [r7, #4]
 801affa:	831a      	strh	r2, [r3, #24]
        /* configure low level device */
        serial->ops->control(serial, RT_DEVICE_CTRL_CLR_INT, (void*)RT_DEVICE_FLAG_INT_TX);
 801affc:	69fb      	ldr	r3, [r7, #28]
 801affe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b000:	685b      	ldr	r3, [r3, #4]
 801b002:	69f8      	ldr	r0, [r7, #28]
 801b004:	2111      	movs	r1, #17
 801b006:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801b00a:	4798      	blx	r3
 801b00c:	e01e      	b.n	801b04c <rt_serial_close+0xb8>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_RX)
 801b00e:	687b      	ldr	r3, [r7, #4]
 801b010:	8b1b      	ldrh	r3, [r3, #24]
 801b012:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801b016:	2b00      	cmp	r3, #0
 801b018:	d018      	beq.n	801b04c <rt_serial_close+0xb8>
    {
        struct rt_serial_rx_dma* rx_dma;

        rx_dma = (struct rt_serial_rx_dma*)serial->serial_tx;
 801b01a:	69fb      	ldr	r3, [r7, #28]
 801b01c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801b01e:	617b      	str	r3, [r7, #20]
        RT_ASSERT(rx_dma != RT_NULL);
 801b020:	697b      	ldr	r3, [r7, #20]
 801b022:	2b00      	cmp	r3, #0
 801b024:	d105      	bne.n	801b032 <rt_serial_close+0x9e>
 801b026:	4832      	ldr	r0, [pc, #200]	; (801b0f0 <rt_serial_close+0x15c>)
 801b028:	492f      	ldr	r1, [pc, #188]	; (801b0e8 <rt_serial_close+0x154>)
 801b02a:	f240 126d 	movw	r2, #365	; 0x16d
 801b02e:	f7fc fcbf 	bl	80179b0 <rt_assert_handler>

        rt_free(rx_dma);
 801b032:	6978      	ldr	r0, [r7, #20]
 801b034:	f7fc fffa 	bl	801802c <rt_free>
        serial->serial_rx = RT_NULL;
 801b038:	69fb      	ldr	r3, [r7, #28]
 801b03a:	2200      	movs	r2, #0
 801b03c:	64da      	str	r2, [r3, #76]	; 0x4c
        dev->open_flag &= ~RT_DEVICE_FLAG_DMA_RX;
 801b03e:	687b      	ldr	r3, [r7, #4]
 801b040:	8b1b      	ldrh	r3, [r3, #24]
 801b042:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 801b046:	b29a      	uxth	r2, r3
 801b048:	687b      	ldr	r3, [r7, #4]
 801b04a:	831a      	strh	r2, [r3, #24]
    }

    if (dev->open_flag & RT_DEVICE_FLAG_INT_TX)
 801b04c:	687b      	ldr	r3, [r7, #4]
 801b04e:	8b1b      	ldrh	r3, [r3, #24]
 801b050:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801b054:	2b00      	cmp	r3, #0
 801b056:	d021      	beq.n	801b09c <rt_serial_close+0x108>
    {
        struct rt_serial_tx_fifo* tx_fifo;

        tx_fifo = (struct rt_serial_tx_fifo*)serial->serial_rx;
 801b058:	69fb      	ldr	r3, [r7, #28]
 801b05a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801b05c:	613b      	str	r3, [r7, #16]
        RT_ASSERT(tx_fifo != RT_NULL);
 801b05e:	693b      	ldr	r3, [r7, #16]
 801b060:	2b00      	cmp	r3, #0
 801b062:	d105      	bne.n	801b070 <rt_serial_close+0xdc>
 801b064:	4823      	ldr	r0, [pc, #140]	; (801b0f4 <rt_serial_close+0x160>)
 801b066:	4920      	ldr	r1, [pc, #128]	; (801b0e8 <rt_serial_close+0x154>)
 801b068:	f240 1279 	movw	r2, #377	; 0x179
 801b06c:	f7fc fca0 	bl	80179b0 <rt_assert_handler>

        rt_free(tx_fifo);
 801b070:	6938      	ldr	r0, [r7, #16]
 801b072:	f7fc ffdb 	bl	801802c <rt_free>
        serial->serial_tx = RT_NULL;
 801b076:	69fb      	ldr	r3, [r7, #28]
 801b078:	2200      	movs	r2, #0
 801b07a:	651a      	str	r2, [r3, #80]	; 0x50
        dev->open_flag &= ~RT_DEVICE_FLAG_INT_TX;
 801b07c:	687b      	ldr	r3, [r7, #4]
 801b07e:	8b1b      	ldrh	r3, [r3, #24]
 801b080:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 801b084:	b29a      	uxth	r2, r3
 801b086:	687b      	ldr	r3, [r7, #4]
 801b088:	831a      	strh	r2, [r3, #24]
        /* configure low level device */
        serial->ops->control(serial, RT_DEVICE_CTRL_CLR_INT, (void*)RT_DEVICE_FLAG_INT_TX);
 801b08a:	69fb      	ldr	r3, [r7, #28]
 801b08c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b08e:	685b      	ldr	r3, [r3, #4]
 801b090:	69f8      	ldr	r0, [r7, #28]
 801b092:	2111      	movs	r1, #17
 801b094:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801b098:	4798      	blx	r3
 801b09a:	e01e      	b.n	801b0da <rt_serial_close+0x146>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_TX)
 801b09c:	687b      	ldr	r3, [r7, #4]
 801b09e:	8b1b      	ldrh	r3, [r3, #24]
 801b0a0:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801b0a4:	2b00      	cmp	r3, #0
 801b0a6:	d018      	beq.n	801b0da <rt_serial_close+0x146>
    {
        struct rt_serial_tx_dma* tx_dma;

        tx_dma = (struct rt_serial_tx_dma*)serial->serial_tx;
 801b0a8:	69fb      	ldr	r3, [r7, #28]
 801b0aa:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801b0ac:	60fb      	str	r3, [r7, #12]
        RT_ASSERT(tx_dma != RT_NULL);
 801b0ae:	68fb      	ldr	r3, [r7, #12]
 801b0b0:	2b00      	cmp	r3, #0
 801b0b2:	d105      	bne.n	801b0c0 <rt_serial_close+0x12c>
 801b0b4:	4810      	ldr	r0, [pc, #64]	; (801b0f8 <rt_serial_close+0x164>)
 801b0b6:	490c      	ldr	r1, [pc, #48]	; (801b0e8 <rt_serial_close+0x154>)
 801b0b8:	f44f 72c3 	mov.w	r2, #390	; 0x186
 801b0bc:	f7fc fc78 	bl	80179b0 <rt_assert_handler>

        rt_free(tx_dma);
 801b0c0:	68f8      	ldr	r0, [r7, #12]
 801b0c2:	f7fc ffb3 	bl	801802c <rt_free>
        serial->serial_tx = RT_NULL;
 801b0c6:	69fb      	ldr	r3, [r7, #28]
 801b0c8:	2200      	movs	r2, #0
 801b0ca:	651a      	str	r2, [r3, #80]	; 0x50
        dev->open_flag &= ~RT_DEVICE_FLAG_DMA_TX;
 801b0cc:	687b      	ldr	r3, [r7, #4]
 801b0ce:	8b1b      	ldrh	r3, [r3, #24]
 801b0d0:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 801b0d4:	b29a      	uxth	r2, r3
 801b0d6:	687b      	ldr	r3, [r7, #4]
 801b0d8:	831a      	strh	r2, [r3, #24]
    }

    return RT_EOK;
 801b0da:	2300      	movs	r3, #0
}
 801b0dc:	4618      	mov	r0, r3
 801b0de:	3720      	adds	r7, #32
 801b0e0:	46bd      	mov	sp, r7
 801b0e2:	bd80      	pop	{r7, pc}
 801b0e4:	08027f68 	.word	0x08027f68
 801b0e8:	08029518 	.word	0x08029518
 801b0ec:	08027f04 	.word	0x08027f04
 801b0f0:	08027f54 	.word	0x08027f54
 801b0f4:	08027f94 	.word	0x08027f94
 801b0f8:	08027f80 	.word	0x08027f80

0801b0fc <rt_serial_read>:

static rt_size_t rt_serial_read(struct rt_device *dev,
                                rt_off_t          pos,
                                void             *buffer,
                                rt_size_t         size)
{
 801b0fc:	b580      	push	{r7, lr}
 801b0fe:	b086      	sub	sp, #24
 801b100:	af00      	add	r7, sp, #0
 801b102:	60f8      	str	r0, [r7, #12]
 801b104:	60b9      	str	r1, [r7, #8]
 801b106:	607a      	str	r2, [r7, #4]
 801b108:	603b      	str	r3, [r7, #0]
    struct rt_serial_device *serial;
	//rt_kprintf("&x\r\n",dev->open_flag);

    RT_ASSERT(dev != RT_NULL);
 801b10a:	68fb      	ldr	r3, [r7, #12]
 801b10c:	2b00      	cmp	r3, #0
 801b10e:	d105      	bne.n	801b11c <rt_serial_read+0x20>
 801b110:	4819      	ldr	r0, [pc, #100]	; (801b178 <rt_serial_read+0x7c>)
 801b112:	491a      	ldr	r1, [pc, #104]	; (801b17c <rt_serial_read+0x80>)
 801b114:	f44f 72cc 	mov.w	r2, #408	; 0x198
 801b118:	f7fc fc4a 	bl	80179b0 <rt_assert_handler>
    if (size == 0) return 0;
 801b11c:	683b      	ldr	r3, [r7, #0]
 801b11e:	2b00      	cmp	r3, #0
 801b120:	d101      	bne.n	801b126 <rt_serial_read+0x2a>
 801b122:	2300      	movs	r3, #0
 801b124:	e024      	b.n	801b170 <rt_serial_read+0x74>

    serial = (struct rt_serial_device *)dev;
 801b126:	68fb      	ldr	r3, [r7, #12]
 801b128:	617b      	str	r3, [r7, #20]
    if (dev->open_flag & RT_DEVICE_FLAG_INT_RX)
 801b12a:	68fb      	ldr	r3, [r7, #12]
 801b12c:	8b1b      	ldrh	r3, [r3, #24]
 801b12e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801b132:	2b00      	cmp	r3, #0
 801b134:	d007      	beq.n	801b146 <rt_serial_read+0x4a>
    {
        return _serial_int_rx(serial, buffer, size);
 801b136:	683b      	ldr	r3, [r7, #0]
 801b138:	6978      	ldr	r0, [r7, #20]
 801b13a:	6879      	ldr	r1, [r7, #4]
 801b13c:	461a      	mov	r2, r3
 801b13e:	f7ff fcab 	bl	801aa98 <_serial_int_rx>
 801b142:	4603      	mov	r3, r0
 801b144:	e014      	b.n	801b170 <rt_serial_read+0x74>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_RX)
 801b146:	68fb      	ldr	r3, [r7, #12]
 801b148:	8b1b      	ldrh	r3, [r3, #24]
 801b14a:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801b14e:	2b00      	cmp	r3, #0
 801b150:	d007      	beq.n	801b162 <rt_serial_read+0x66>
    {
        return _serial_dma_rx(serial, buffer, size);
 801b152:	683b      	ldr	r3, [r7, #0]
 801b154:	6978      	ldr	r0, [r7, #20]
 801b156:	6879      	ldr	r1, [r7, #4]
 801b158:	461a      	mov	r2, r3
 801b15a:	f7ff fd43 	bl	801abe4 <_serial_dma_rx>
 801b15e:	4603      	mov	r3, r0
 801b160:	e006      	b.n	801b170 <rt_serial_read+0x74>
    }

    return _serial_poll_rx(serial, buffer, size);
 801b162:	683b      	ldr	r3, [r7, #0]
 801b164:	6978      	ldr	r0, [r7, #20]
 801b166:	6879      	ldr	r1, [r7, #4]
 801b168:	461a      	mov	r2, r3
 801b16a:	f7ff fc23 	bl	801a9b4 <_serial_poll_rx>
 801b16e:	4603      	mov	r3, r0
}
 801b170:	4618      	mov	r0, r3
 801b172:	3718      	adds	r7, #24
 801b174:	46bd      	mov	sp, r7
 801b176:	bd80      	pop	{r7, pc}
 801b178:	08027f68 	.word	0x08027f68
 801b17c:	08029528 	.word	0x08029528

0801b180 <rt_serial_write>:

static rt_size_t rt_serial_write(struct rt_device *dev,
                                 rt_off_t          pos,
                                 const void       *buffer,
                                 rt_size_t         size)
{
 801b180:	b580      	push	{r7, lr}
 801b182:	b086      	sub	sp, #24
 801b184:	af00      	add	r7, sp, #0
 801b186:	60f8      	str	r0, [r7, #12]
 801b188:	60b9      	str	r1, [r7, #8]
 801b18a:	607a      	str	r2, [r7, #4]
 801b18c:	603b      	str	r3, [r7, #0]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
 801b18e:	68fb      	ldr	r3, [r7, #12]
 801b190:	2b00      	cmp	r3, #0
 801b192:	d105      	bne.n	801b1a0 <rt_serial_write+0x20>
 801b194:	4819      	ldr	r0, [pc, #100]	; (801b1fc <rt_serial_write+0x7c>)
 801b196:	491a      	ldr	r1, [pc, #104]	; (801b200 <rt_serial_write+0x80>)
 801b198:	f240 12af 	movw	r2, #431	; 0x1af
 801b19c:	f7fc fc08 	bl	80179b0 <rt_assert_handler>
    if (size == 0) return 0;
 801b1a0:	683b      	ldr	r3, [r7, #0]
 801b1a2:	2b00      	cmp	r3, #0
 801b1a4:	d101      	bne.n	801b1aa <rt_serial_write+0x2a>
 801b1a6:	2300      	movs	r3, #0
 801b1a8:	e024      	b.n	801b1f4 <rt_serial_write+0x74>

    serial = (struct rt_serial_device *)dev;
 801b1aa:	68fb      	ldr	r3, [r7, #12]
 801b1ac:	617b      	str	r3, [r7, #20]

    if (dev->open_flag & RT_DEVICE_FLAG_INT_TX)
 801b1ae:	68fb      	ldr	r3, [r7, #12]
 801b1b0:	8b1b      	ldrh	r3, [r3, #24]
 801b1b2:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801b1b6:	2b00      	cmp	r3, #0
 801b1b8:	d007      	beq.n	801b1ca <rt_serial_write+0x4a>
    {
        return _serial_int_tx(serial, buffer, size);
 801b1ba:	683b      	ldr	r3, [r7, #0]
 801b1bc:	6978      	ldr	r0, [r7, #20]
 801b1be:	6879      	ldr	r1, [r7, #4]
 801b1c0:	461a      	mov	r2, r3
 801b1c2:	f7ff fcc9 	bl	801ab58 <_serial_int_tx>
 801b1c6:	4603      	mov	r3, r0
 801b1c8:	e014      	b.n	801b1f4 <rt_serial_write+0x74>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_TX)
 801b1ca:	68fb      	ldr	r3, [r7, #12]
 801b1cc:	8b1b      	ldrh	r3, [r3, #24]
 801b1ce:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801b1d2:	2b00      	cmp	r3, #0
 801b1d4:	d007      	beq.n	801b1e6 <rt_serial_write+0x66>
    {
        return _serial_dma_tx(serial, buffer, size);
 801b1d6:	683b      	ldr	r3, [r7, #0]
 801b1d8:	6978      	ldr	r0, [r7, #20]
 801b1da:	6879      	ldr	r1, [r7, #4]
 801b1dc:	461a      	mov	r2, r3
 801b1de:	f7ff fd41 	bl	801ac64 <_serial_dma_tx>
 801b1e2:	4603      	mov	r3, r0
 801b1e4:	e006      	b.n	801b1f4 <rt_serial_write+0x74>
    }
    else
    {
        return _serial_poll_tx(serial, buffer, size);
 801b1e6:	683b      	ldr	r3, [r7, #0]
 801b1e8:	6978      	ldr	r0, [r7, #20]
 801b1ea:	6879      	ldr	r1, [r7, #4]
 801b1ec:	461a      	mov	r2, r3
 801b1ee:	f7ff fc15 	bl	801aa1c <_serial_poll_tx>
 801b1f2:	4603      	mov	r3, r0
    }
}
 801b1f4:	4618      	mov	r0, r3
 801b1f6:	3718      	adds	r7, #24
 801b1f8:	46bd      	mov	sp, r7
 801b1fa:	bd80      	pop	{r7, pc}
 801b1fc:	08027f68 	.word	0x08027f68
 801b200:	08029568 	.word	0x08029568

0801b204 <rt_serial_control>:

static rt_err_t rt_serial_control(struct rt_device *dev,
                                  rt_uint8_t        cmd,
                                  void             *args)
{
 801b204:	b580      	push	{r7, lr}
 801b206:	b086      	sub	sp, #24
 801b208:	af00      	add	r7, sp, #0
 801b20a:	60f8      	str	r0, [r7, #12]
 801b20c:	460b      	mov	r3, r1
 801b20e:	607a      	str	r2, [r7, #4]
 801b210:	72fb      	strb	r3, [r7, #11]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
 801b212:	68fb      	ldr	r3, [r7, #12]
 801b214:	2b00      	cmp	r3, #0
 801b216:	d105      	bne.n	801b224 <rt_serial_control+0x20>
 801b218:	481a      	ldr	r0, [pc, #104]	; (801b284 <rt_serial_control+0x80>)
 801b21a:	491b      	ldr	r1, [pc, #108]	; (801b288 <rt_serial_control+0x84>)
 801b21c:	f44f 72e4 	mov.w	r2, #456	; 0x1c8
 801b220:	f7fc fbc6 	bl	80179b0 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
 801b224:	68fb      	ldr	r3, [r7, #12]
 801b226:	617b      	str	r3, [r7, #20]

    switch (cmd)
 801b228:	7afb      	ldrb	r3, [r7, #11]
 801b22a:	2b02      	cmp	r3, #2
 801b22c:	d004      	beq.n	801b238 <rt_serial_control+0x34>
 801b22e:	2b03      	cmp	r3, #3
 801b230:	d012      	beq.n	801b258 <rt_serial_control+0x54>
 801b232:	2b01      	cmp	r3, #1
 801b234:	d008      	beq.n	801b248 <rt_serial_control+0x44>
 801b236:	e016      	b.n	801b266 <rt_serial_control+0x62>
    {
        case RT_DEVICE_CTRL_SUSPEND:
            /* suspend device */
            dev->flag |= RT_DEVICE_FLAG_SUSPENDED;
 801b238:	68fb      	ldr	r3, [r7, #12]
 801b23a:	8adb      	ldrh	r3, [r3, #22]
 801b23c:	f043 0320 	orr.w	r3, r3, #32
 801b240:	b29a      	uxth	r2, r3
 801b242:	68fb      	ldr	r3, [r7, #12]
 801b244:	82da      	strh	r2, [r3, #22]
            break;
 801b246:	e017      	b.n	801b278 <rt_serial_control+0x74>

        case RT_DEVICE_CTRL_RESUME:
            /* resume device */
            dev->flag &= ~RT_DEVICE_FLAG_SUSPENDED;
 801b248:	68fb      	ldr	r3, [r7, #12]
 801b24a:	8adb      	ldrh	r3, [r3, #22]
 801b24c:	f023 0320 	bic.w	r3, r3, #32
 801b250:	b29a      	uxth	r2, r3
 801b252:	68fb      	ldr	r3, [r7, #12]
 801b254:	82da      	strh	r2, [r3, #22]
            break;
 801b256:	e00f      	b.n	801b278 <rt_serial_control+0x74>

        case RT_DEVICE_CTRL_CONFIG:
            /* configure device */
            serial->ops->configure(serial, (struct serial_configure *)args);
 801b258:	697b      	ldr	r3, [r7, #20]
 801b25a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b25c:	681b      	ldr	r3, [r3, #0]
 801b25e:	6978      	ldr	r0, [r7, #20]
 801b260:	6879      	ldr	r1, [r7, #4]
 801b262:	4798      	blx	r3
            break;
 801b264:	e008      	b.n	801b278 <rt_serial_control+0x74>

        default :
            /* control device */
            serial->ops->control(serial, cmd, args);
 801b266:	697b      	ldr	r3, [r7, #20]
 801b268:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b26a:	685b      	ldr	r3, [r3, #4]
 801b26c:	7afa      	ldrb	r2, [r7, #11]
 801b26e:	6978      	ldr	r0, [r7, #20]
 801b270:	4611      	mov	r1, r2
 801b272:	687a      	ldr	r2, [r7, #4]
 801b274:	4798      	blx	r3
            break;
 801b276:	bf00      	nop
    }

    return RT_EOK;
 801b278:	2300      	movs	r3, #0
}
 801b27a:	4618      	mov	r0, r3
 801b27c:	3718      	adds	r7, #24
 801b27e:	46bd      	mov	sp, r7
 801b280:	bd80      	pop	{r7, pc}
 801b282:	bf00      	nop
 801b284:	08027f68 	.word	0x08027f68
 801b288:	08029598 	.word	0x08029598

0801b28c <rt_hw_serial_register>:
 */
rt_err_t rt_hw_serial_register(struct rt_serial_device *serial,
                               const char              *name,
                               rt_uint32_t              flag,
                               void                    *data)
{
 801b28c:	b580      	push	{r7, lr}
 801b28e:	b086      	sub	sp, #24
 801b290:	af00      	add	r7, sp, #0
 801b292:	60f8      	str	r0, [r7, #12]
 801b294:	60b9      	str	r1, [r7, #8]
 801b296:	607a      	str	r2, [r7, #4]
 801b298:	603b      	str	r3, [r7, #0]
    struct rt_device *device;
    RT_ASSERT(serial != RT_NULL);
 801b29a:	68fb      	ldr	r3, [r7, #12]
 801b29c:	2b00      	cmp	r3, #0
 801b29e:	d105      	bne.n	801b2ac <rt_hw_serial_register+0x20>
 801b2a0:	4818      	ldr	r0, [pc, #96]	; (801b304 <rt_hw_serial_register+0x78>)
 801b2a2:	4919      	ldr	r1, [pc, #100]	; (801b308 <rt_hw_serial_register+0x7c>)
 801b2a4:	f44f 72f7 	mov.w	r2, #494	; 0x1ee
 801b2a8:	f7fc fb82 	bl	80179b0 <rt_assert_handler>

    device = &(serial->parent);
 801b2ac:	68fb      	ldr	r3, [r7, #12]
 801b2ae:	617b      	str	r3, [r7, #20]

    device->type        = RT_Device_Class_Char;
 801b2b0:	697b      	ldr	r3, [r7, #20]
 801b2b2:	2200      	movs	r2, #0
 801b2b4:	751a      	strb	r2, [r3, #20]
    device->rx_indicate = RT_NULL;
 801b2b6:	697b      	ldr	r3, [r7, #20]
 801b2b8:	2200      	movs	r2, #0
 801b2ba:	61da      	str	r2, [r3, #28]
    device->tx_complete = RT_NULL;
 801b2bc:	697b      	ldr	r3, [r7, #20]
 801b2be:	2200      	movs	r2, #0
 801b2c0:	621a      	str	r2, [r3, #32]

    device->init        = rt_serial_init;
 801b2c2:	697b      	ldr	r3, [r7, #20]
 801b2c4:	4a11      	ldr	r2, [pc, #68]	; (801b30c <rt_hw_serial_register+0x80>)
 801b2c6:	625a      	str	r2, [r3, #36]	; 0x24
    device->open        = rt_serial_open;
 801b2c8:	697b      	ldr	r3, [r7, #20]
 801b2ca:	4a11      	ldr	r2, [pc, #68]	; (801b310 <rt_hw_serial_register+0x84>)
 801b2cc:	629a      	str	r2, [r3, #40]	; 0x28
    device->close       = rt_serial_close;
 801b2ce:	697b      	ldr	r3, [r7, #20]
 801b2d0:	4a10      	ldr	r2, [pc, #64]	; (801b314 <rt_hw_serial_register+0x88>)
 801b2d2:	62da      	str	r2, [r3, #44]	; 0x2c
    device->read        = rt_serial_read;
 801b2d4:	697b      	ldr	r3, [r7, #20]
 801b2d6:	4a10      	ldr	r2, [pc, #64]	; (801b318 <rt_hw_serial_register+0x8c>)
 801b2d8:	631a      	str	r2, [r3, #48]	; 0x30
    device->write       = rt_serial_write;
 801b2da:	697b      	ldr	r3, [r7, #20]
 801b2dc:	4a0f      	ldr	r2, [pc, #60]	; (801b31c <rt_hw_serial_register+0x90>)
 801b2de:	635a      	str	r2, [r3, #52]	; 0x34
    device->control     = rt_serial_control;
 801b2e0:	697b      	ldr	r3, [r7, #20]
 801b2e2:	4a0f      	ldr	r2, [pc, #60]	; (801b320 <rt_hw_serial_register+0x94>)
 801b2e4:	639a      	str	r2, [r3, #56]	; 0x38
    device->user_data   = data;
 801b2e6:	697b      	ldr	r3, [r7, #20]
 801b2e8:	683a      	ldr	r2, [r7, #0]
 801b2ea:	63da      	str	r2, [r3, #60]	; 0x3c

    /* register a character device */
    return rt_device_register(device, name, flag);
 801b2ec:	687b      	ldr	r3, [r7, #4]
 801b2ee:	b29b      	uxth	r3, r3
 801b2f0:	6978      	ldr	r0, [r7, #20]
 801b2f2:	68b9      	ldr	r1, [r7, #8]
 801b2f4:	461a      	mov	r2, r3
 801b2f6:	f7fa fc2b 	bl	8015b50 <rt_device_register>
 801b2fa:	4603      	mov	r3, r0
}
 801b2fc:	4618      	mov	r0, r3
 801b2fe:	3718      	adds	r7, #24
 801b300:	46bd      	mov	sp, r7
 801b302:	bd80      	pop	{r7, pc}
 801b304:	08027ef0 	.word	0x08027ef0
 801b308:	080295ac 	.word	0x080295ac
 801b30c:	0801acdd 	.word	0x0801acdd
 801b310:	0801ad45 	.word	0x0801ad45
 801b314:	0801af95 	.word	0x0801af95
 801b318:	0801b0fd 	.word	0x0801b0fd
 801b31c:	0801b181 	.word	0x0801b181
 801b320:	0801b205 	.word	0x0801b205

0801b324 <rt_hw_serial_isr>:

/* ISR for serial interrupt */
void rt_hw_serial_isr(struct rt_serial_device *serial, int event)
{
 801b324:	b590      	push	{r4, r7, lr}
 801b326:	b08f      	sub	sp, #60	; 0x3c
 801b328:	af00      	add	r7, sp, #0
 801b32a:	6078      	str	r0, [r7, #4]
 801b32c:	6039      	str	r1, [r7, #0]
    switch (event & 0xff)
 801b32e:	683b      	ldr	r3, [r7, #0]
 801b330:	b2db      	uxtb	r3, r3
 801b332:	3b01      	subs	r3, #1
 801b334:	2b03      	cmp	r3, #3
 801b336:	f200 80ec 	bhi.w	801b512 <rt_hw_serial_isr+0x1ee>
 801b33a:	a201      	add	r2, pc, #4	; (adr r2, 801b340 <rt_hw_serial_isr+0x1c>)
 801b33c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801b340:	0801b351 	.word	0x0801b351
 801b344:	0801b46b 	.word	0x0801b46b
 801b348:	0801b4f1 	.word	0x0801b4f1
 801b34c:	0801b47b 	.word	0x0801b47b
    {
        case RT_SERIAL_EVENT_RX_IND:
        {
            int ch = -1;
 801b350:	f04f 33ff 	mov.w	r3, #4294967295
 801b354:	637b      	str	r3, [r7, #52]	; 0x34
            rt_base_t level;
            struct rt_serial_rx_fifo* rx_fifo;

            rx_fifo = (struct rt_serial_rx_fifo*)serial->serial_rx;
 801b356:	687b      	ldr	r3, [r7, #4]
 801b358:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801b35a:	633b      	str	r3, [r7, #48]	; 0x30
            RT_ASSERT(rx_fifo != RT_NULL);
 801b35c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b35e:	2b00      	cmp	r3, #0
 801b360:	d105      	bne.n	801b36e <rt_hw_serial_isr+0x4a>
 801b362:	486d      	ldr	r0, [pc, #436]	; (801b518 <rt_hw_serial_isr+0x1f4>)
 801b364:	496d      	ldr	r1, [pc, #436]	; (801b51c <rt_hw_serial_isr+0x1f8>)
 801b366:	f240 220e 	movw	r2, #526	; 0x20e
 801b36a:	f7fc fb21 	bl	80179b0 <rt_assert_handler>
            
            /* interrupt mode receive */
            RT_ASSERT(serial->parent.open_flag & RT_DEVICE_FLAG_INT_RX);
 801b36e:	687b      	ldr	r3, [r7, #4]
 801b370:	8b1b      	ldrh	r3, [r3, #24]
 801b372:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801b376:	2b00      	cmp	r3, #0
 801b378:	d105      	bne.n	801b386 <rt_hw_serial_isr+0x62>
 801b37a:	4869      	ldr	r0, [pc, #420]	; (801b520 <rt_hw_serial_isr+0x1fc>)
 801b37c:	4967      	ldr	r1, [pc, #412]	; (801b51c <rt_hw_serial_isr+0x1f8>)
 801b37e:	f240 2211 	movw	r2, #529	; 0x211
 801b382:	f7fc fb15 	bl	80179b0 <rt_assert_handler>
            
            while (1)
            {
                ch = serial->ops->getc(serial);
 801b386:	687b      	ldr	r3, [r7, #4]
 801b388:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b38a:	68db      	ldr	r3, [r3, #12]
 801b38c:	6878      	ldr	r0, [r7, #4]
 801b38e:	4798      	blx	r3
 801b390:	6378      	str	r0, [r7, #52]	; 0x34
                if (ch == -1) break;
 801b392:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b394:	f1b3 3fff 	cmp.w	r3, #4294967295
 801b398:	d105      	bne.n	801b3a6 <rt_hw_serial_isr+0x82>
 801b39a:	bf00      	nop
                /* enable interrupt */
                rt_hw_interrupt_enable(level);
            }
            
            /* invoke callback */
            if (serial->parent.rx_indicate != RT_NULL)
 801b39c:	687b      	ldr	r3, [r7, #4]
 801b39e:	69db      	ldr	r3, [r3, #28]
 801b3a0:	2b00      	cmp	r3, #0
 801b3a2:	d061      	beq.n	801b468 <rt_hw_serial_isr+0x144>
 801b3a4:	e038      	b.n	801b418 <rt_hw_serial_isr+0xf4>
            {
                ch = serial->ops->getc(serial);
                if (ch == -1) break;
                
                /* disable interrupt */
                level = rt_hw_interrupt_disable();
 801b3a6:	f7e4 ff0f 	bl	80001c8 <rt_hw_interrupt_disable>
 801b3aa:	62f8      	str	r0, [r7, #44]	; 0x2c
                
                rx_fifo->buffer[rx_fifo->put_index] = ch;
 801b3ac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b3ae:	681b      	ldr	r3, [r3, #0]
 801b3b0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801b3b2:	8892      	ldrh	r2, [r2, #4]
 801b3b4:	4413      	add	r3, r2
 801b3b6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801b3b8:	b2d2      	uxtb	r2, r2
 801b3ba:	701a      	strb	r2, [r3, #0]
                rx_fifo->put_index += 1;
 801b3bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b3be:	889b      	ldrh	r3, [r3, #4]
 801b3c0:	3301      	adds	r3, #1
 801b3c2:	b29a      	uxth	r2, r3
 801b3c4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b3c6:	809a      	strh	r2, [r3, #4]
                if (rx_fifo->put_index >= serial->config.bufsz) rx_fifo->put_index = 0;
 801b3c8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b3ca:	889a      	ldrh	r2, [r3, #4]
 801b3cc:	687b      	ldr	r3, [r7, #4]
 801b3ce:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801b3d0:	f3c3 238f 	ubfx	r3, r3, #10, #16
 801b3d4:	b29b      	uxth	r3, r3
 801b3d6:	429a      	cmp	r2, r3
 801b3d8:	d302      	bcc.n	801b3e0 <rt_hw_serial_isr+0xbc>
 801b3da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b3dc:	2200      	movs	r2, #0
 801b3de:	809a      	strh	r2, [r3, #4]
                
                /* if the next position is read index, discard this 'read char' */
                if (rx_fifo->put_index == rx_fifo->get_index)
 801b3e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b3e2:	889a      	ldrh	r2, [r3, #4]
 801b3e4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b3e6:	88db      	ldrh	r3, [r3, #6]
 801b3e8:	429a      	cmp	r2, r3
 801b3ea:	d111      	bne.n	801b410 <rt_hw_serial_isr+0xec>
                {
                    rx_fifo->get_index += 1;
 801b3ec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b3ee:	88db      	ldrh	r3, [r3, #6]
 801b3f0:	3301      	adds	r3, #1
 801b3f2:	b29a      	uxth	r2, r3
 801b3f4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b3f6:	80da      	strh	r2, [r3, #6]
                    if (rx_fifo->get_index >= serial->config.bufsz) rx_fifo->get_index = 0;
 801b3f8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b3fa:	88da      	ldrh	r2, [r3, #6]
 801b3fc:	687b      	ldr	r3, [r7, #4]
 801b3fe:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801b400:	f3c3 238f 	ubfx	r3, r3, #10, #16
 801b404:	b29b      	uxth	r3, r3
 801b406:	429a      	cmp	r2, r3
 801b408:	d302      	bcc.n	801b410 <rt_hw_serial_isr+0xec>
 801b40a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b40c:	2200      	movs	r2, #0
 801b40e:	80da      	strh	r2, [r3, #6]
                }
                
                /* enable interrupt */
                rt_hw_interrupt_enable(level);
 801b410:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801b412:	f7e4 fedd 	bl	80001d0 <rt_hw_interrupt_enable>
            }
 801b416:	e7b6      	b.n	801b386 <rt_hw_serial_isr+0x62>
            if (serial->parent.rx_indicate != RT_NULL)
            {
                rt_size_t rx_length;
            
                /* get rx length */
                level = rt_hw_interrupt_disable();
 801b418:	f7e4 fed6 	bl	80001c8 <rt_hw_interrupt_disable>
 801b41c:	62f8      	str	r0, [r7, #44]	; 0x2c
                rx_length = (rx_fifo->put_index >= rx_fifo->get_index)? (rx_fifo->put_index - rx_fifo->get_index):
 801b41e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b420:	889a      	ldrh	r2, [r3, #4]
 801b422:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b424:	88db      	ldrh	r3, [r3, #6]
 801b426:	429a      	cmp	r2, r3
 801b428:	d306      	bcc.n	801b438 <rt_hw_serial_isr+0x114>
 801b42a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b42c:	889b      	ldrh	r3, [r3, #4]
 801b42e:	461a      	mov	r2, r3
 801b430:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b432:	88db      	ldrh	r3, [r3, #6]
 801b434:	1ad3      	subs	r3, r2, r3
 801b436:	e00c      	b.n	801b452 <rt_hw_serial_isr+0x12e>
                    (serial->config.bufsz - (rx_fifo->get_index - rx_fifo->put_index));
 801b438:	687b      	ldr	r3, [r7, #4]
 801b43a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801b43c:	f3c3 238f 	ubfx	r3, r3, #10, #16
 801b440:	b29b      	uxth	r3, r3
 801b442:	461a      	mov	r2, r3
 801b444:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b446:	889b      	ldrh	r3, [r3, #4]
 801b448:	4619      	mov	r1, r3
 801b44a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b44c:	88db      	ldrh	r3, [r3, #6]
 801b44e:	1acb      	subs	r3, r1, r3
 801b450:	4413      	add	r3, r2
            {
                rt_size_t rx_length;
            
                /* get rx length */
                level = rt_hw_interrupt_disable();
                rx_length = (rx_fifo->put_index >= rx_fifo->get_index)? (rx_fifo->put_index - rx_fifo->get_index):
 801b452:	62bb      	str	r3, [r7, #40]	; 0x28
                    (serial->config.bufsz - (rx_fifo->get_index - rx_fifo->put_index));
                rt_hw_interrupt_enable(level);
 801b454:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801b456:	f7e4 febb 	bl	80001d0 <rt_hw_interrupt_enable>

                serial->parent.rx_indicate(&serial->parent, rx_length);
 801b45a:	687b      	ldr	r3, [r7, #4]
 801b45c:	69db      	ldr	r3, [r3, #28]
 801b45e:	687a      	ldr	r2, [r7, #4]
 801b460:	4610      	mov	r0, r2
 801b462:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801b464:	4798      	blx	r3
            }
            break;
 801b466:	e054      	b.n	801b512 <rt_hw_serial_isr+0x1ee>
 801b468:	e053      	b.n	801b512 <rt_hw_serial_isr+0x1ee>
        }
        case RT_SERIAL_EVENT_TX_DONE:
        {
            struct rt_serial_tx_fifo* tx_fifo;

            tx_fifo = (struct rt_serial_tx_fifo*)serial->serial_tx;
 801b46a:	687b      	ldr	r3, [r7, #4]
 801b46c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801b46e:	627b      	str	r3, [r7, #36]	; 0x24
            rt_completion_done(&(tx_fifo->completion));
 801b470:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b472:	4618      	mov	r0, r3
 801b474:	f7fe fc94 	bl	8019da0 <rt_completion_done>
            break;
 801b478:	e04b      	b.n	801b512 <rt_hw_serial_isr+0x1ee>
            const void *data_ptr;
            rt_size_t data_size;
            const void *last_data_ptr;
            struct rt_serial_tx_dma* tx_dma;

            tx_dma = (struct rt_serial_tx_dma*) serial->serial_tx;
 801b47a:	687b      	ldr	r3, [r7, #4]
 801b47c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801b47e:	623b      	str	r3, [r7, #32]
            
            rt_data_queue_pop(&(tx_dma->data_queue), &last_data_ptr, &data_size, 0);
 801b480:	6a3b      	ldr	r3, [r7, #32]
 801b482:	1d19      	adds	r1, r3, #4
 801b484:	f107 020c 	add.w	r2, r7, #12
 801b488:	f107 0310 	add.w	r3, r7, #16
 801b48c:	4608      	mov	r0, r1
 801b48e:	4611      	mov	r1, r2
 801b490:	461a      	mov	r2, r3
 801b492:	2300      	movs	r3, #0
 801b494:	f7fe fe00 	bl	801a098 <rt_data_queue_pop>
            if (rt_data_queue_peak(&(tx_dma->data_queue), &data_ptr, &data_size) == RT_EOK)
 801b498:	6a3b      	ldr	r3, [r7, #32]
 801b49a:	1d19      	adds	r1, r3, #4
 801b49c:	f107 0214 	add.w	r2, r7, #20
 801b4a0:	f107 0310 	add.w	r3, r7, #16
 801b4a4:	4608      	mov	r0, r1
 801b4a6:	4611      	mov	r1, r2
 801b4a8:	461a      	mov	r2, r3
 801b4aa:	f7fe fee5 	bl	801a278 <rt_data_queue_peak>
 801b4ae:	4603      	mov	r3, r0
 801b4b0:	2b00      	cmp	r3, #0
 801b4b2:	d10d      	bne.n	801b4d0 <rt_hw_serial_isr+0x1ac>
            {
                /* transmit next data node */
                tx_dma->activated = RT_TRUE;
 801b4b4:	6a3b      	ldr	r3, [r7, #32]
 801b4b6:	2201      	movs	r2, #1
 801b4b8:	601a      	str	r2, [r3, #0]
                serial->ops->dma_transmit(serial, data_ptr, data_size, RT_SERIAL_DMA_TX);
 801b4ba:	687b      	ldr	r3, [r7, #4]
 801b4bc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b4be:	691c      	ldr	r4, [r3, #16]
 801b4c0:	697a      	ldr	r2, [r7, #20]
 801b4c2:	693b      	ldr	r3, [r7, #16]
 801b4c4:	6878      	ldr	r0, [r7, #4]
 801b4c6:	4611      	mov	r1, r2
 801b4c8:	461a      	mov	r2, r3
 801b4ca:	2302      	movs	r3, #2
 801b4cc:	47a0      	blx	r4
 801b4ce:	e002      	b.n	801b4d6 <rt_hw_serial_isr+0x1b2>
            }
            else
            {
                tx_dma->activated = RT_FALSE;
 801b4d0:	6a3b      	ldr	r3, [r7, #32]
 801b4d2:	2200      	movs	r2, #0
 801b4d4:	601a      	str	r2, [r3, #0]
            }
            
            /* invoke callback */
            if (serial->parent.tx_complete != RT_NULL)
 801b4d6:	687b      	ldr	r3, [r7, #4]
 801b4d8:	6a1b      	ldr	r3, [r3, #32]
 801b4da:	2b00      	cmp	r3, #0
 801b4dc:	d006      	beq.n	801b4ec <rt_hw_serial_isr+0x1c8>
            {
                serial->parent.tx_complete(&serial->parent, (void*)last_data_ptr);
 801b4de:	687b      	ldr	r3, [r7, #4]
 801b4e0:	6a1b      	ldr	r3, [r3, #32]
 801b4e2:	6879      	ldr	r1, [r7, #4]
 801b4e4:	68fa      	ldr	r2, [r7, #12]
 801b4e6:	4608      	mov	r0, r1
 801b4e8:	4611      	mov	r1, r2
 801b4ea:	4798      	blx	r3
            }
            break;
 801b4ec:	bf00      	nop
 801b4ee:	e010      	b.n	801b512 <rt_hw_serial_isr+0x1ee>
        case RT_SERIAL_EVENT_RX_DMADONE:
        {
            int length;
            struct rt_serial_rx_dma* rx_dma;

            rx_dma = (struct rt_serial_rx_dma*)serial->serial_rx;
 801b4f0:	687b      	ldr	r3, [r7, #4]
 801b4f2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801b4f4:	61fb      	str	r3, [r7, #28]
            /* get DMA rx length */
            length = (event & (~0xff)) >> 8;
 801b4f6:	683b      	ldr	r3, [r7, #0]
 801b4f8:	121b      	asrs	r3, r3, #8
 801b4fa:	61bb      	str	r3, [r7, #24]
            serial->parent.rx_indicate(&(serial->parent), length);
 801b4fc:	687b      	ldr	r3, [r7, #4]
 801b4fe:	69db      	ldr	r3, [r3, #28]
 801b500:	6879      	ldr	r1, [r7, #4]
 801b502:	69ba      	ldr	r2, [r7, #24]
 801b504:	4608      	mov	r0, r1
 801b506:	4611      	mov	r1, r2
 801b508:	4798      	blx	r3
            rx_dma->activated = RT_FALSE;
 801b50a:	69fb      	ldr	r3, [r7, #28]
 801b50c:	2200      	movs	r2, #0
 801b50e:	601a      	str	r2, [r3, #0]
            break;
 801b510:	bf00      	nop
        }
    }
}
 801b512:	373c      	adds	r7, #60	; 0x3c
 801b514:	46bd      	mov	sp, r7
 801b516:	bd90      	pop	{r4, r7, pc}
 801b518:	08027f04 	.word	0x08027f04
 801b51c:	080295c4 	.word	0x080295c4
 801b520:	08027fa8 	.word	0x08027fa8

0801b524 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 801b524:	b480      	push	{r7}
 801b526:	b083      	sub	sp, #12
 801b528:	af00      	add	r7, sp, #0
 801b52a:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 801b52c:	687b      	ldr	r3, [r7, #4]
 801b52e:	687a      	ldr	r2, [r7, #4]
 801b530:	605a      	str	r2, [r3, #4]
 801b532:	687b      	ldr	r3, [r7, #4]
 801b534:	685a      	ldr	r2, [r3, #4]
 801b536:	687b      	ldr	r3, [r7, #4]
 801b538:	601a      	str	r2, [r3, #0]
}
 801b53a:	370c      	adds	r7, #12
 801b53c:	46bd      	mov	sp, r7
 801b53e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b542:	4770      	bx	lr

0801b544 <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
 801b544:	b480      	push	{r7}
 801b546:	b083      	sub	sp, #12
 801b548:	af00      	add	r7, sp, #0
 801b54a:	6078      	str	r0, [r7, #4]
 801b54c:	6039      	str	r1, [r7, #0]
    l->next->prev = n;
 801b54e:	687b      	ldr	r3, [r7, #4]
 801b550:	681b      	ldr	r3, [r3, #0]
 801b552:	683a      	ldr	r2, [r7, #0]
 801b554:	605a      	str	r2, [r3, #4]
    n->next = l->next;
 801b556:	687b      	ldr	r3, [r7, #4]
 801b558:	681a      	ldr	r2, [r3, #0]
 801b55a:	683b      	ldr	r3, [r7, #0]
 801b55c:	601a      	str	r2, [r3, #0]

    l->next = n;
 801b55e:	687b      	ldr	r3, [r7, #4]
 801b560:	683a      	ldr	r2, [r7, #0]
 801b562:	601a      	str	r2, [r3, #0]
    n->prev = l;
 801b564:	683b      	ldr	r3, [r7, #0]
 801b566:	687a      	ldr	r2, [r7, #4]
 801b568:	605a      	str	r2, [r3, #4]
}
 801b56a:	370c      	adds	r7, #12
 801b56c:	46bd      	mov	sp, r7
 801b56e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b572:	4770      	bx	lr

0801b574 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 801b574:	b480      	push	{r7}
 801b576:	b083      	sub	sp, #12
 801b578:	af00      	add	r7, sp, #0
 801b57a:	6078      	str	r0, [r7, #4]
 801b57c:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 801b57e:	687b      	ldr	r3, [r7, #4]
 801b580:	685b      	ldr	r3, [r3, #4]
 801b582:	683a      	ldr	r2, [r7, #0]
 801b584:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 801b586:	687b      	ldr	r3, [r7, #4]
 801b588:	685a      	ldr	r2, [r3, #4]
 801b58a:	683b      	ldr	r3, [r7, #0]
 801b58c:	605a      	str	r2, [r3, #4]

    l->prev = n;
 801b58e:	687b      	ldr	r3, [r7, #4]
 801b590:	683a      	ldr	r2, [r7, #0]
 801b592:	605a      	str	r2, [r3, #4]
    n->next = l;
 801b594:	683b      	ldr	r3, [r7, #0]
 801b596:	687a      	ldr	r2, [r7, #4]
 801b598:	601a      	str	r2, [r3, #0]
}
 801b59a:	370c      	adds	r7, #12
 801b59c:	46bd      	mov	sp, r7
 801b59e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b5a2:	4770      	bx	lr

0801b5a4 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 801b5a4:	b480      	push	{r7}
 801b5a6:	b083      	sub	sp, #12
 801b5a8:	af00      	add	r7, sp, #0
 801b5aa:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 801b5ac:	687b      	ldr	r3, [r7, #4]
 801b5ae:	681b      	ldr	r3, [r3, #0]
 801b5b0:	687a      	ldr	r2, [r7, #4]
 801b5b2:	6852      	ldr	r2, [r2, #4]
 801b5b4:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 801b5b6:	687b      	ldr	r3, [r7, #4]
 801b5b8:	685b      	ldr	r3, [r3, #4]
 801b5ba:	687a      	ldr	r2, [r7, #4]
 801b5bc:	6812      	ldr	r2, [r2, #0]
 801b5be:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 801b5c0:	687b      	ldr	r3, [r7, #4]
 801b5c2:	687a      	ldr	r2, [r7, #4]
 801b5c4:	605a      	str	r2, [r3, #4]
 801b5c6:	687b      	ldr	r3, [r7, #4]
 801b5c8:	685a      	ldr	r2, [r3, #4]
 801b5ca:	687b      	ldr	r3, [r7, #4]
 801b5cc:	601a      	str	r2, [r3, #0]
}
 801b5ce:	370c      	adds	r7, #12
 801b5d0:	46bd      	mov	sp, r7
 801b5d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b5d6:	4770      	bx	lr

0801b5d8 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 801b5d8:	b480      	push	{r7}
 801b5da:	b083      	sub	sp, #12
 801b5dc:	af00      	add	r7, sp, #0
 801b5de:	6078      	str	r0, [r7, #4]
    return l->next == l;
 801b5e0:	687b      	ldr	r3, [r7, #4]
 801b5e2:	681a      	ldr	r2, [r3, #0]
 801b5e4:	687b      	ldr	r3, [r7, #4]
 801b5e6:	429a      	cmp	r2, r3
 801b5e8:	bf0c      	ite	eq
 801b5ea:	2301      	moveq	r3, #1
 801b5ec:	2300      	movne	r3, #0
 801b5ee:	b2db      	uxtb	r3, r3
}
 801b5f0:	4618      	mov	r0, r3
 801b5f2:	370c      	adds	r7, #12
 801b5f4:	46bd      	mov	sp, r7
 801b5f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b5fa:	4770      	bx	lr

0801b5fc <rt_can_init>:

#define CAN_LOCK(can)   rt_mutex_take(&(can->lock), RT_WAITING_FOREVER)
#define CAN_UNLOCK(can) rt_mutex_release(&(can->lock))

static rt_err_t rt_can_init(struct rt_device *dev)
{
 801b5fc:	b580      	push	{r7, lr}
 801b5fe:	b084      	sub	sp, #16
 801b600:	af00      	add	r7, sp, #0
 801b602:	6078      	str	r0, [r7, #4]
    rt_err_t result = RT_EOK;
 801b604:	2300      	movs	r3, #0
 801b606:	60fb      	str	r3, [r7, #12]
    struct rt_can_device *can;

    RT_ASSERT(dev != RT_NULL);
 801b608:	687b      	ldr	r3, [r7, #4]
 801b60a:	2b00      	cmp	r3, #0
 801b60c:	d104      	bne.n	801b618 <rt_can_init+0x1c>
 801b60e:	4811      	ldr	r0, [pc, #68]	; (801b654 <rt_can_init+0x58>)
 801b610:	4911      	ldr	r1, [pc, #68]	; (801b658 <rt_can_init+0x5c>)
 801b612:	2226      	movs	r2, #38	; 0x26
 801b614:	f7fc f9cc 	bl	80179b0 <rt_assert_handler>
    can = (struct rt_can_device *)dev;
 801b618:	687b      	ldr	r3, [r7, #4]
 801b61a:	60bb      	str	r3, [r7, #8]

    /* initialize rx/tx */
    can->can_rx = RT_NULL;
 801b61c:	68bb      	ldr	r3, [r7, #8]
 801b61e:	2200      	movs	r2, #0
 801b620:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
    can->can_tx = RT_NULL;
 801b624:	68bb      	ldr	r3, [r7, #8]
 801b626:	2200      	movs	r2, #0
 801b628:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4

    /* apply configuration */
    if (can->ops->configure)
 801b62c:	68bb      	ldr	r3, [r7, #8]
 801b62e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b630:	681b      	ldr	r3, [r3, #0]
 801b632:	2b00      	cmp	r3, #0
 801b634:	d008      	beq.n	801b648 <rt_can_init+0x4c>
        result = can->ops->configure(can, &can->config);
 801b636:	68bb      	ldr	r3, [r7, #8]
 801b638:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b63a:	681b      	ldr	r3, [r3, #0]
 801b63c:	68ba      	ldr	r2, [r7, #8]
 801b63e:	3244      	adds	r2, #68	; 0x44
 801b640:	68b8      	ldr	r0, [r7, #8]
 801b642:	4611      	mov	r1, r2
 801b644:	4798      	blx	r3
 801b646:	60f8      	str	r0, [r7, #12]

    return result;
 801b648:	68fb      	ldr	r3, [r7, #12]
}
 801b64a:	4618      	mov	r0, r3
 801b64c:	3710      	adds	r7, #16
 801b64e:	46bd      	mov	sp, r7
 801b650:	bd80      	pop	{r7, pc}
 801b652:	bf00      	nop
 801b654:	08027fdc 	.word	0x08027fdc
 801b658:	08029600 	.word	0x08029600

0801b65c <_can_int_rx>:

/*
 * can interrupt routines
 */
rt_inline int _can_int_rx(struct rt_can_device *can, struct rt_can_msg *data, int msgs)
{
 801b65c:	b580      	push	{r7, lr}
 801b65e:	b088      	sub	sp, #32
 801b660:	af00      	add	r7, sp, #0
 801b662:	60f8      	str	r0, [r7, #12]
 801b664:	60b9      	str	r1, [r7, #8]
 801b666:	607a      	str	r2, [r7, #4]
    int size;
    struct rt_can_rx_fifo *rx_fifo;
    RT_ASSERT(can != RT_NULL);
 801b668:	68fb      	ldr	r3, [r7, #12]
 801b66a:	2b00      	cmp	r3, #0
 801b66c:	d104      	bne.n	801b678 <_can_int_rx+0x1c>
 801b66e:	4836      	ldr	r0, [pc, #216]	; (801b748 <_can_int_rx+0xec>)
 801b670:	4936      	ldr	r1, [pc, #216]	; (801b74c <_can_int_rx+0xf0>)
 801b672:	223b      	movs	r2, #59	; 0x3b
 801b674:	f7fc f99c 	bl	80179b0 <rt_assert_handler>
    size = msgs;
 801b678:	687b      	ldr	r3, [r7, #4]
 801b67a:	61fb      	str	r3, [r7, #28]

    rx_fifo = (struct rt_can_rx_fifo *) can->can_rx;
 801b67c:	68fb      	ldr	r3, [r7, #12]
 801b67e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 801b682:	61bb      	str	r3, [r7, #24]
    RT_ASSERT(rx_fifo != RT_NULL);
 801b684:	69bb      	ldr	r3, [r7, #24]
 801b686:	2b00      	cmp	r3, #0
 801b688:	d104      	bne.n	801b694 <_can_int_rx+0x38>
 801b68a:	4831      	ldr	r0, [pc, #196]	; (801b750 <_can_int_rx+0xf4>)
 801b68c:	492f      	ldr	r1, [pc, #188]	; (801b74c <_can_int_rx+0xf0>)
 801b68e:	223f      	movs	r2, #63	; 0x3f
 801b690:	f7fc f98e 	bl	80179b0 <rt_assert_handler>

    /* read from software FIFO */
    while (msgs)
 801b694:	e04d      	b.n	801b732 <_can_int_rx+0xd6>
    {
        rt_base_t level;
#ifdef RT_CAN_USING_HDR
        rt_int32_t hdr;
#endif /*RT_CAN_USING_HDR*/
        struct rt_can_msg_list *listmsg = RT_NULL;
 801b696:	2300      	movs	r3, #0
 801b698:	617b      	str	r3, [r7, #20]

        /* disable interrupt */
        level = rt_hw_interrupt_disable();
 801b69a:	f7e4 fd95 	bl	80001c8 <rt_hw_interrupt_disable>
 801b69e:	6138      	str	r0, [r7, #16]
            listmsg->owner = RT_NULL;
        }
        else if (hdr == -1)
#endif /*RT_CAN_USING_HDR*/
        {
            if (!rt_list_isempty(&rx_fifo->uselist))
 801b6a0:	69bb      	ldr	r3, [r7, #24]
 801b6a2:	3310      	adds	r3, #16
 801b6a4:	4618      	mov	r0, r3
 801b6a6:	f7ff ff97 	bl	801b5d8 <rt_list_isempty>
 801b6aa:	4603      	mov	r3, r0
 801b6ac:	2b00      	cmp	r3, #0
 801b6ae:	d10d      	bne.n	801b6cc <_can_int_rx+0x70>
            {
                listmsg = rt_list_entry(rx_fifo->uselist.next, struct rt_can_msg_list, list);
 801b6b0:	69bb      	ldr	r3, [r7, #24]
 801b6b2:	691b      	ldr	r3, [r3, #16]
 801b6b4:	617b      	str	r3, [r7, #20]
                rt_list_remove(&listmsg->list);
 801b6b6:	697b      	ldr	r3, [r7, #20]
 801b6b8:	4618      	mov	r0, r3
 801b6ba:	f7ff ff73 	bl	801b5a4 <rt_list_remove>
                break;
            }
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 801b6be:	6938      	ldr	r0, [r7, #16]
 801b6c0:	f7e4 fd86 	bl	80001d0 <rt_hw_interrupt_enable>
        if (listmsg != RT_NULL)
 801b6c4:	697b      	ldr	r3, [r7, #20]
 801b6c6:	2b00      	cmp	r3, #0
 801b6c8:	d02c      	beq.n	801b724 <_can_int_rx+0xc8>
 801b6ca:	e003      	b.n	801b6d4 <_can_int_rx+0x78>
#endif /*RT_CAN_USING_HDR*/
            }
            else
            {
                /* no data, enable interrupt and break out */
                rt_hw_interrupt_enable(level);
 801b6cc:	6938      	ldr	r0, [r7, #16]
 801b6ce:	f7e4 fd7f 	bl	80001d0 <rt_hw_interrupt_enable>
                break;
 801b6d2:	e031      	b.n	801b738 <_can_int_rx+0xdc>

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
        if (listmsg != RT_NULL)
        {
            rt_memcpy(data, &listmsg->data, sizeof(struct rt_can_msg));
 801b6d4:	697b      	ldr	r3, [r7, #20]
 801b6d6:	3308      	adds	r3, #8
 801b6d8:	68b8      	ldr	r0, [r7, #8]
 801b6da:	4619      	mov	r1, r3
 801b6dc:	2210      	movs	r2, #16
 801b6de:	f7fb fb91 	bl	8016e04 <rt_memcpy>

            level = rt_hw_interrupt_disable();
 801b6e2:	f7e4 fd71 	bl	80001c8 <rt_hw_interrupt_disable>
 801b6e6:	6138      	str	r0, [r7, #16]
            rt_list_insert_before(&rx_fifo->freelist, &listmsg->list);
 801b6e8:	69bb      	ldr	r3, [r7, #24]
 801b6ea:	f103 0208 	add.w	r2, r3, #8
 801b6ee:	697b      	ldr	r3, [r7, #20]
 801b6f0:	4610      	mov	r0, r2
 801b6f2:	4619      	mov	r1, r3
 801b6f4:	f7ff ff3e 	bl	801b574 <rt_list_insert_before>
            rx_fifo->freenumbers++;
 801b6f8:	69bb      	ldr	r3, [r7, #24]
 801b6fa:	685b      	ldr	r3, [r3, #4]
 801b6fc:	1c5a      	adds	r2, r3, #1
 801b6fe:	69bb      	ldr	r3, [r7, #24]
 801b700:	605a      	str	r2, [r3, #4]
            RT_ASSERT(rx_fifo->freenumbers <= can->config.msgboxsz);
 801b702:	69bb      	ldr	r3, [r7, #24]
 801b704:	685a      	ldr	r2, [r3, #4]
 801b706:	68fb      	ldr	r3, [r7, #12]
 801b708:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801b70a:	429a      	cmp	r2, r3
 801b70c:	d904      	bls.n	801b718 <_can_int_rx+0xbc>
 801b70e:	4811      	ldr	r0, [pc, #68]	; (801b754 <_can_int_rx+0xf8>)
 801b710:	490e      	ldr	r1, [pc, #56]	; (801b74c <_can_int_rx+0xf0>)
 801b712:	227b      	movs	r2, #123	; 0x7b
 801b714:	f7fc f94c 	bl	80179b0 <rt_assert_handler>
            rt_hw_interrupt_enable(level);
 801b718:	6938      	ldr	r0, [r7, #16]
 801b71a:	f7e4 fd59 	bl	80001d0 <rt_hw_interrupt_enable>

            listmsg = RT_NULL;
 801b71e:	2300      	movs	r3, #0
 801b720:	617b      	str	r3, [r7, #20]
 801b722:	e000      	b.n	801b726 <_can_int_rx+0xca>
        }
        else
        {
            break;
 801b724:	e008      	b.n	801b738 <_can_int_rx+0xdc>
        }
        data ++;
 801b726:	68bb      	ldr	r3, [r7, #8]
 801b728:	3310      	adds	r3, #16
 801b72a:	60bb      	str	r3, [r7, #8]
        msgs -= sizeof(struct rt_can_msg);
 801b72c:	687b      	ldr	r3, [r7, #4]
 801b72e:	3b10      	subs	r3, #16
 801b730:	607b      	str	r3, [r7, #4]

    rx_fifo = (struct rt_can_rx_fifo *) can->can_rx;
    RT_ASSERT(rx_fifo != RT_NULL);

    /* read from software FIFO */
    while (msgs)
 801b732:	687b      	ldr	r3, [r7, #4]
 801b734:	2b00      	cmp	r3, #0
 801b736:	d1ae      	bne.n	801b696 <_can_int_rx+0x3a>
        }
        data ++;
        msgs -= sizeof(struct rt_can_msg);
    }

    return (size - msgs);
 801b738:	69fa      	ldr	r2, [r7, #28]
 801b73a:	687b      	ldr	r3, [r7, #4]
 801b73c:	1ad3      	subs	r3, r2, r3
}
 801b73e:	4618      	mov	r0, r3
 801b740:	3720      	adds	r7, #32
 801b742:	46bd      	mov	sp, r7
 801b744:	bd80      	pop	{r7, pc}
 801b746:	bf00      	nop
 801b748:	08027fec 	.word	0x08027fec
 801b74c:	08029634 	.word	0x08029634
 801b750:	08027ffc 	.word	0x08027ffc
 801b754:	08028010 	.word	0x08028010

0801b758 <_can_int_tx>:

rt_inline int _can_int_tx(struct rt_can_device *can, const struct rt_can_msg *data, int msgs)
{
 801b758:	b580      	push	{r7, lr}
 801b75a:	b08a      	sub	sp, #40	; 0x28
 801b75c:	af00      	add	r7, sp, #0
 801b75e:	60f8      	str	r0, [r7, #12]
 801b760:	60b9      	str	r1, [r7, #8]
 801b762:	607a      	str	r2, [r7, #4]
    int size;
    struct rt_can_tx_fifo *tx_fifo;

    RT_ASSERT(can != RT_NULL);
 801b764:	68fb      	ldr	r3, [r7, #12]
 801b766:	2b00      	cmp	r3, #0
 801b768:	d104      	bne.n	801b774 <_can_int_tx+0x1c>
 801b76a:	485f      	ldr	r0, [pc, #380]	; (801b8e8 <_can_int_tx+0x190>)
 801b76c:	495f      	ldr	r1, [pc, #380]	; (801b8ec <_can_int_tx+0x194>)
 801b76e:	2290      	movs	r2, #144	; 0x90
 801b770:	f7fc f91e 	bl	80179b0 <rt_assert_handler>

    size = msgs;
 801b774:	687b      	ldr	r3, [r7, #4]
 801b776:	627b      	str	r3, [r7, #36]	; 0x24
    tx_fifo = (struct rt_can_tx_fifo *) can->can_tx;
 801b778:	68fb      	ldr	r3, [r7, #12]
 801b77a:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 801b77e:	623b      	str	r3, [r7, #32]
    RT_ASSERT(tx_fifo != RT_NULL);
 801b780:	6a3b      	ldr	r3, [r7, #32]
 801b782:	2b00      	cmp	r3, #0
 801b784:	d104      	bne.n	801b790 <_can_int_tx+0x38>
 801b786:	485a      	ldr	r0, [pc, #360]	; (801b8f0 <_can_int_tx+0x198>)
 801b788:	4958      	ldr	r1, [pc, #352]	; (801b8ec <_can_int_tx+0x194>)
 801b78a:	2294      	movs	r2, #148	; 0x94
 801b78c:	f7fc f910 	bl	80179b0 <rt_assert_handler>

    while (msgs)
 801b790:	e09f      	b.n	801b8d2 <_can_int_tx+0x17a>
    {
        rt_base_t level;
        rt_uint32_t no;
        rt_uint32_t result;
        struct rt_can_sndbxinx_list *tx_tosnd = RT_NULL;
 801b792:	2300      	movs	r3, #0
 801b794:	61fb      	str	r3, [r7, #28]

        level = rt_hw_interrupt_disable();
 801b796:	f7e4 fd17 	bl	80001c8 <rt_hw_interrupt_disable>
 801b79a:	61b8      	str	r0, [r7, #24]
        if (!rt_list_isempty(&tx_fifo->freelist))
 801b79c:	6a3b      	ldr	r3, [r7, #32]
 801b79e:	3310      	adds	r3, #16
 801b7a0:	4618      	mov	r0, r3
 801b7a2:	f7ff ff19 	bl	801b5d8 <rt_list_isempty>
 801b7a6:	4603      	mov	r3, r0
 801b7a8:	2b00      	cmp	r3, #0
 801b7aa:	d128      	bne.n	801b7fe <_can_int_tx+0xa6>
        {
            tx_tosnd = rt_list_entry(tx_fifo->freelist.next, struct rt_can_sndbxinx_list, list);
 801b7ac:	6a3b      	ldr	r3, [r7, #32]
 801b7ae:	691b      	ldr	r3, [r3, #16]
 801b7b0:	61fb      	str	r3, [r7, #28]
            RT_ASSERT(tx_tosnd != RT_NULL);
 801b7b2:	69fb      	ldr	r3, [r7, #28]
 801b7b4:	2b00      	cmp	r3, #0
 801b7b6:	d104      	bne.n	801b7c2 <_can_int_tx+0x6a>
 801b7b8:	484e      	ldr	r0, [pc, #312]	; (801b8f4 <_can_int_tx+0x19c>)
 801b7ba:	494c      	ldr	r1, [pc, #304]	; (801b8ec <_can_int_tx+0x194>)
 801b7bc:	22a1      	movs	r2, #161	; 0xa1
 801b7be:	f7fc f8f7 	bl	80179b0 <rt_assert_handler>
            rt_list_remove(&tx_tosnd->list);
 801b7c2:	69fb      	ldr	r3, [r7, #28]
 801b7c4:	4618      	mov	r0, r3
 801b7c6:	f7ff feed 	bl	801b5a4 <rt_list_remove>
            rt_hw_interrupt_enable(level);

            rt_completion_wait(&(tx_fifo->completion), RT_WAITING_FOREVER);
            continue;
        }
        rt_hw_interrupt_enable(level);
 801b7ca:	69b8      	ldr	r0, [r7, #24]
 801b7cc:	f7e4 fd00 	bl	80001d0 <rt_hw_interrupt_enable>

        no = ((rt_uint32_t)tx_tosnd - (rt_uint32_t)tx_fifo->buffer) / sizeof(struct rt_can_sndbxinx_list);
 801b7d0:	69fb      	ldr	r3, [r7, #28]
 801b7d2:	6a3a      	ldr	r2, [r7, #32]
 801b7d4:	6812      	ldr	r2, [r2, #0]
 801b7d6:	1a9b      	subs	r3, r3, r2
 801b7d8:	4a47      	ldr	r2, [pc, #284]	; (801b8f8 <_can_int_tx+0x1a0>)
 801b7da:	fba2 2303 	umull	r2, r3, r2, r3
 801b7de:	091b      	lsrs	r3, r3, #4
 801b7e0:	617b      	str	r3, [r7, #20]
        tx_tosnd->result = RT_CAN_SND_RESULT_WAIT;
 801b7e2:	69fb      	ldr	r3, [r7, #28]
 801b7e4:	2202      	movs	r2, #2
 801b7e6:	615a      	str	r2, [r3, #20]
        if (can->ops->sendmsg(can, data, no) != RT_EOK)
 801b7e8:	68fb      	ldr	r3, [r7, #12]
 801b7ea:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b7ec:	689b      	ldr	r3, [r3, #8]
 801b7ee:	68f8      	ldr	r0, [r7, #12]
 801b7f0:	68b9      	ldr	r1, [r7, #8]
 801b7f2:	697a      	ldr	r2, [r7, #20]
 801b7f4:	4798      	blx	r3
 801b7f6:	4603      	mov	r3, r0
 801b7f8:	2b00      	cmp	r3, #0
 801b7fa:	d01a      	beq.n	801b832 <_can_int_tx+0xda>
 801b7fc:	e00a      	b.n	801b814 <_can_int_tx+0xbc>
            RT_ASSERT(tx_tosnd != RT_NULL);
            rt_list_remove(&tx_tosnd->list);
        }
        else
        {
            rt_hw_interrupt_enable(level);
 801b7fe:	69b8      	ldr	r0, [r7, #24]
 801b800:	f7e4 fce6 	bl	80001d0 <rt_hw_interrupt_enable>

            rt_completion_wait(&(tx_fifo->completion), RT_WAITING_FOREVER);
 801b804:	6a3b      	ldr	r3, [r7, #32]
 801b806:	3304      	adds	r3, #4
 801b808:	4618      	mov	r0, r3
 801b80a:	f04f 31ff 	mov.w	r1, #4294967295
 801b80e:	f7fe fa47 	bl	8019ca0 <rt_completion_wait>
            continue;
 801b812:	e05e      	b.n	801b8d2 <_can_int_tx+0x17a>
        no = ((rt_uint32_t)tx_tosnd - (rt_uint32_t)tx_fifo->buffer) / sizeof(struct rt_can_sndbxinx_list);
        tx_tosnd->result = RT_CAN_SND_RESULT_WAIT;
        if (can->ops->sendmsg(can, data, no) != RT_EOK)
        {
            /* send failed. */
            level = rt_hw_interrupt_disable();
 801b814:	f7e4 fcd8 	bl	80001c8 <rt_hw_interrupt_disable>
 801b818:	61b8      	str	r0, [r7, #24]
            rt_list_insert_after(&tx_fifo->freelist, &tx_tosnd->list);
 801b81a:	6a3b      	ldr	r3, [r7, #32]
 801b81c:	f103 0210 	add.w	r2, r3, #16
 801b820:	69fb      	ldr	r3, [r7, #28]
 801b822:	4610      	mov	r0, r2
 801b824:	4619      	mov	r1, r3
 801b826:	f7ff fe8d 	bl	801b544 <rt_list_insert_after>
            rt_hw_interrupt_enable(level);
 801b82a:	69b8      	ldr	r0, [r7, #24]
 801b82c:	f7e4 fcd0 	bl	80001d0 <rt_hw_interrupt_enable>
            continue;
 801b830:	e04f      	b.n	801b8d2 <_can_int_tx+0x17a>
        }

        can->status.sndchange = 1;
 801b832:	68fb      	ldr	r3, [r7, #12]
 801b834:	2201      	movs	r2, #1
 801b836:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        rt_completion_wait(&(tx_tosnd->completion), RT_WAITING_FOREVER);
 801b83a:	69fb      	ldr	r3, [r7, #28]
 801b83c:	3308      	adds	r3, #8
 801b83e:	4618      	mov	r0, r3
 801b840:	f04f 31ff 	mov.w	r1, #4294967295
 801b844:	f7fe fa2c 	bl	8019ca0 <rt_completion_wait>

        level = rt_hw_interrupt_disable();
 801b848:	f7e4 fcbe 	bl	80001c8 <rt_hw_interrupt_disable>
 801b84c:	61b8      	str	r0, [r7, #24]
        result = tx_tosnd->result;
 801b84e:	69fb      	ldr	r3, [r7, #28]
 801b850:	695b      	ldr	r3, [r3, #20]
 801b852:	613b      	str	r3, [r7, #16]
        if (!rt_list_isempty(&tx_tosnd->list))
 801b854:	69fb      	ldr	r3, [r7, #28]
 801b856:	4618      	mov	r0, r3
 801b858:	f7ff febe 	bl	801b5d8 <rt_list_isempty>
 801b85c:	4603      	mov	r3, r0
 801b85e:	2b00      	cmp	r3, #0
 801b860:	d103      	bne.n	801b86a <_can_int_tx+0x112>
        {
            rt_list_remove(&tx_tosnd->list);
 801b862:	69fb      	ldr	r3, [r7, #28]
 801b864:	4618      	mov	r0, r3
 801b866:	f7ff fe9d 	bl	801b5a4 <rt_list_remove>
        }
        rt_list_insert_before(&tx_fifo->freelist, &tx_tosnd->list);
 801b86a:	6a3b      	ldr	r3, [r7, #32]
 801b86c:	f103 0210 	add.w	r2, r3, #16
 801b870:	69fb      	ldr	r3, [r7, #28]
 801b872:	4610      	mov	r0, r2
 801b874:	4619      	mov	r1, r3
 801b876:	f7ff fe7d 	bl	801b574 <rt_list_insert_before>
        rt_completion_done(&(tx_fifo->completion));
 801b87a:	6a3b      	ldr	r3, [r7, #32]
 801b87c:	3304      	adds	r3, #4
 801b87e:	4618      	mov	r0, r3
 801b880:	f7fe fa8e 	bl	8019da0 <rt_completion_done>
        rt_hw_interrupt_enable(level);
 801b884:	69b8      	ldr	r0, [r7, #24]
 801b886:	f7e4 fca3 	bl	80001d0 <rt_hw_interrupt_enable>

        if (result == RT_CAN_SND_RESULT_OK)
 801b88a:	693b      	ldr	r3, [r7, #16]
 801b88c:	2b00      	cmp	r3, #0
 801b88e:	d114      	bne.n	801b8ba <_can_int_tx+0x162>
        {
            level = rt_hw_interrupt_disable();
 801b890:	f7e4 fc9a 	bl	80001c8 <rt_hw_interrupt_disable>
 801b894:	61b8      	str	r0, [r7, #24]
            can->status.sndpkg++;
 801b896:	68fb      	ldr	r3, [r7, #12]
 801b898:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 801b89a:	1c5a      	adds	r2, r3, #1
 801b89c:	68fb      	ldr	r3, [r7, #12]
 801b89e:	66da      	str	r2, [r3, #108]	; 0x6c
            rt_hw_interrupt_enable(level);
 801b8a0:	69b8      	ldr	r0, [r7, #24]
 801b8a2:	f7e4 fc95 	bl	80001d0 <rt_hw_interrupt_enable>

            data ++;
 801b8a6:	68bb      	ldr	r3, [r7, #8]
 801b8a8:	3310      	adds	r3, #16
 801b8aa:	60bb      	str	r3, [r7, #8]
            msgs -= sizeof(struct rt_can_msg);
 801b8ac:	687b      	ldr	r3, [r7, #4]
 801b8ae:	3b10      	subs	r3, #16
 801b8b0:	607b      	str	r3, [r7, #4]
            if (!msgs) break;
 801b8b2:	687b      	ldr	r3, [r7, #4]
 801b8b4:	2b00      	cmp	r3, #0
 801b8b6:	d10c      	bne.n	801b8d2 <_can_int_tx+0x17a>
 801b8b8:	e00f      	b.n	801b8da <_can_int_tx+0x182>
        }
        else
        {
            level = rt_hw_interrupt_disable();
 801b8ba:	f7e4 fc85 	bl	80001c8 <rt_hw_interrupt_disable>
 801b8be:	61b8      	str	r0, [r7, #24]
            can->status.dropedsndpkg++;
 801b8c0:	68fb      	ldr	r3, [r7, #12]
 801b8c2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801b8c4:	1c5a      	adds	r2, r3, #1
 801b8c6:	68fb      	ldr	r3, [r7, #12]
 801b8c8:	671a      	str	r2, [r3, #112]	; 0x70
            rt_hw_interrupt_enable(level);
 801b8ca:	69b8      	ldr	r0, [r7, #24]
 801b8cc:	f7e4 fc80 	bl	80001d0 <rt_hw_interrupt_enable>
            break;
 801b8d0:	e003      	b.n	801b8da <_can_int_tx+0x182>

    size = msgs;
    tx_fifo = (struct rt_can_tx_fifo *) can->can_tx;
    RT_ASSERT(tx_fifo != RT_NULL);

    while (msgs)
 801b8d2:	687b      	ldr	r3, [r7, #4]
 801b8d4:	2b00      	cmp	r3, #0
 801b8d6:	f47f af5c 	bne.w	801b792 <_can_int_tx+0x3a>
            rt_hw_interrupt_enable(level);
            break;
        }
    }

    return (size - msgs);
 801b8da:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801b8dc:	687b      	ldr	r3, [r7, #4]
 801b8de:	1ad3      	subs	r3, r2, r3
}
 801b8e0:	4618      	mov	r0, r3
 801b8e2:	3728      	adds	r7, #40	; 0x28
 801b8e4:	46bd      	mov	sp, r7
 801b8e6:	bd80      	pop	{r7, pc}
 801b8e8:	08027fec 	.word	0x08027fec
 801b8ec:	08029664 	.word	0x08029664
 801b8f0:	08028040 	.word	0x08028040
 801b8f4:	08028054 	.word	0x08028054
 801b8f8:	aaaaaaab 	.word	0xaaaaaaab

0801b8fc <_can_int_tx_priv>:

rt_inline int _can_int_tx_priv(struct rt_can_device *can, const struct rt_can_msg *data, int msgs)
{
 801b8fc:	b580      	push	{r7, lr}
 801b8fe:	b08a      	sub	sp, #40	; 0x28
 801b900:	af00      	add	r7, sp, #0
 801b902:	60f8      	str	r0, [r7, #12]
 801b904:	60b9      	str	r1, [r7, #8]
 801b906:	607a      	str	r2, [r7, #4]
    int size;
    rt_base_t level;
    rt_uint32_t no, result;
    struct rt_can_tx_fifo *tx_fifo;

    RT_ASSERT(can != RT_NULL);
 801b908:	68fb      	ldr	r3, [r7, #12]
 801b90a:	2b00      	cmp	r3, #0
 801b90c:	d104      	bne.n	801b918 <_can_int_tx_priv+0x1c>
 801b90e:	4850      	ldr	r0, [pc, #320]	; (801ba50 <_can_int_tx_priv+0x154>)
 801b910:	4950      	ldr	r1, [pc, #320]	; (801ba54 <_can_int_tx_priv+0x158>)
 801b912:	22e2      	movs	r2, #226	; 0xe2
 801b914:	f7fc f84c 	bl	80179b0 <rt_assert_handler>

    size = msgs;
 801b918:	687b      	ldr	r3, [r7, #4]
 801b91a:	627b      	str	r3, [r7, #36]	; 0x24
    tx_fifo = (struct rt_can_tx_fifo *) can->can_tx;
 801b91c:	68fb      	ldr	r3, [r7, #12]
 801b91e:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 801b922:	623b      	str	r3, [r7, #32]
    RT_ASSERT(tx_fifo != RT_NULL);
 801b924:	6a3b      	ldr	r3, [r7, #32]
 801b926:	2b00      	cmp	r3, #0
 801b928:	d104      	bne.n	801b934 <_can_int_tx_priv+0x38>
 801b92a:	484b      	ldr	r0, [pc, #300]	; (801ba58 <_can_int_tx_priv+0x15c>)
 801b92c:	4949      	ldr	r1, [pc, #292]	; (801ba54 <_can_int_tx_priv+0x158>)
 801b92e:	22e6      	movs	r2, #230	; 0xe6
 801b930:	f7fc f83e 	bl	80179b0 <rt_assert_handler>

    while (msgs)
 801b934:	e080      	b.n	801ba38 <_can_int_tx_priv+0x13c>
    {
        no = data->priv;
 801b936:	68bb      	ldr	r3, [r7, #8]
 801b938:	795b      	ldrb	r3, [r3, #5]
 801b93a:	61fb      	str	r3, [r7, #28]
        if (no >= can->config.sndboxnumber)
 801b93c:	68fb      	ldr	r3, [r7, #12]
 801b93e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801b940:	69fb      	ldr	r3, [r7, #28]
 801b942:	429a      	cmp	r2, r3
 801b944:	d800      	bhi.n	801b948 <_can_int_tx_priv+0x4c>
        {
            break;
 801b946:	e07b      	b.n	801ba40 <_can_int_tx_priv+0x144>
        }

        level = rt_hw_interrupt_disable();
 801b948:	f7e4 fc3e 	bl	80001c8 <rt_hw_interrupt_disable>
 801b94c:	61b8      	str	r0, [r7, #24]
        if ((tx_fifo->buffer[no].result != RT_CAN_SND_RESULT_OK))
 801b94e:	6a3b      	ldr	r3, [r7, #32]
 801b950:	6819      	ldr	r1, [r3, #0]
 801b952:	69fa      	ldr	r2, [r7, #28]
 801b954:	4613      	mov	r3, r2
 801b956:	005b      	lsls	r3, r3, #1
 801b958:	4413      	add	r3, r2
 801b95a:	00db      	lsls	r3, r3, #3
 801b95c:	440b      	add	r3, r1
 801b95e:	695b      	ldr	r3, [r3, #20]
 801b960:	2b00      	cmp	r3, #0
 801b962:	d011      	beq.n	801b988 <_can_int_tx_priv+0x8c>
        {
            rt_hw_interrupt_enable(level);
 801b964:	69b8      	ldr	r0, [r7, #24]
 801b966:	f7e4 fc33 	bl	80001d0 <rt_hw_interrupt_enable>

            rt_completion_wait(&(tx_fifo->buffer[no].completion), RT_WAITING_FOREVER);
 801b96a:	6a3b      	ldr	r3, [r7, #32]
 801b96c:	6819      	ldr	r1, [r3, #0]
 801b96e:	69fa      	ldr	r2, [r7, #28]
 801b970:	4613      	mov	r3, r2
 801b972:	005b      	lsls	r3, r3, #1
 801b974:	4413      	add	r3, r2
 801b976:	00db      	lsls	r3, r3, #3
 801b978:	440b      	add	r3, r1
 801b97a:	3308      	adds	r3, #8
 801b97c:	4618      	mov	r0, r3
 801b97e:	f04f 31ff 	mov.w	r1, #4294967295
 801b982:	f7fe f98d 	bl	8019ca0 <rt_completion_wait>
            continue;
 801b986:	e057      	b.n	801ba38 <_can_int_tx_priv+0x13c>
        }
        tx_fifo->buffer[no].result = RT_CAN_SND_RESULT_WAIT;
 801b988:	6a3b      	ldr	r3, [r7, #32]
 801b98a:	6819      	ldr	r1, [r3, #0]
 801b98c:	69fa      	ldr	r2, [r7, #28]
 801b98e:	4613      	mov	r3, r2
 801b990:	005b      	lsls	r3, r3, #1
 801b992:	4413      	add	r3, r2
 801b994:	00db      	lsls	r3, r3, #3
 801b996:	440b      	add	r3, r1
 801b998:	2202      	movs	r2, #2
 801b99a:	615a      	str	r2, [r3, #20]
        rt_hw_interrupt_enable(level);
 801b99c:	69b8      	ldr	r0, [r7, #24]
 801b99e:	f7e4 fc17 	bl	80001d0 <rt_hw_interrupt_enable>

        if (can->ops->sendmsg(can, data, no) != RT_EOK)
 801b9a2:	68fb      	ldr	r3, [r7, #12]
 801b9a4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b9a6:	689b      	ldr	r3, [r3, #8]
 801b9a8:	68f8      	ldr	r0, [r7, #12]
 801b9aa:	68b9      	ldr	r1, [r7, #8]
 801b9ac:	69fa      	ldr	r2, [r7, #28]
 801b9ae:	4798      	blx	r3
 801b9b0:	4603      	mov	r3, r0
 801b9b2:	2b00      	cmp	r3, #0
 801b9b4:	d000      	beq.n	801b9b8 <_can_int_tx_priv+0xbc>
        {
            continue;
 801b9b6:	e03f      	b.n	801ba38 <_can_int_tx_priv+0x13c>
        }
        can->status.sndchange = 1;
 801b9b8:	68fb      	ldr	r3, [r7, #12]
 801b9ba:	2201      	movs	r2, #1
 801b9bc:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        rt_completion_wait(&(tx_fifo->buffer[no].completion), RT_WAITING_FOREVER);
 801b9c0:	6a3b      	ldr	r3, [r7, #32]
 801b9c2:	6819      	ldr	r1, [r3, #0]
 801b9c4:	69fa      	ldr	r2, [r7, #28]
 801b9c6:	4613      	mov	r3, r2
 801b9c8:	005b      	lsls	r3, r3, #1
 801b9ca:	4413      	add	r3, r2
 801b9cc:	00db      	lsls	r3, r3, #3
 801b9ce:	440b      	add	r3, r1
 801b9d0:	3308      	adds	r3, #8
 801b9d2:	4618      	mov	r0, r3
 801b9d4:	f04f 31ff 	mov.w	r1, #4294967295
 801b9d8:	f7fe f962 	bl	8019ca0 <rt_completion_wait>

        result = tx_fifo->buffer[no].result;
 801b9dc:	6a3b      	ldr	r3, [r7, #32]
 801b9de:	6819      	ldr	r1, [r3, #0]
 801b9e0:	69fa      	ldr	r2, [r7, #28]
 801b9e2:	4613      	mov	r3, r2
 801b9e4:	005b      	lsls	r3, r3, #1
 801b9e6:	4413      	add	r3, r2
 801b9e8:	00db      	lsls	r3, r3, #3
 801b9ea:	440b      	add	r3, r1
 801b9ec:	695b      	ldr	r3, [r3, #20]
 801b9ee:	617b      	str	r3, [r7, #20]
        if (result == RT_CAN_SND_RESULT_OK)
 801b9f0:	697b      	ldr	r3, [r7, #20]
 801b9f2:	2b00      	cmp	r3, #0
 801b9f4:	d114      	bne.n	801ba20 <_can_int_tx_priv+0x124>
        {
            level = rt_hw_interrupt_disable();
 801b9f6:	f7e4 fbe7 	bl	80001c8 <rt_hw_interrupt_disable>
 801b9fa:	61b8      	str	r0, [r7, #24]
            can->status.sndpkg++;
 801b9fc:	68fb      	ldr	r3, [r7, #12]
 801b9fe:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 801ba00:	1c5a      	adds	r2, r3, #1
 801ba02:	68fb      	ldr	r3, [r7, #12]
 801ba04:	66da      	str	r2, [r3, #108]	; 0x6c
            rt_hw_interrupt_enable(level);
 801ba06:	69b8      	ldr	r0, [r7, #24]
 801ba08:	f7e4 fbe2 	bl	80001d0 <rt_hw_interrupt_enable>
            data ++;
 801ba0c:	68bb      	ldr	r3, [r7, #8]
 801ba0e:	3310      	adds	r3, #16
 801ba10:	60bb      	str	r3, [r7, #8]
            msgs -= sizeof(struct rt_can_msg);
 801ba12:	687b      	ldr	r3, [r7, #4]
 801ba14:	3b10      	subs	r3, #16
 801ba16:	607b      	str	r3, [r7, #4]
            if (!msgs) break;
 801ba18:	687b      	ldr	r3, [r7, #4]
 801ba1a:	2b00      	cmp	r3, #0
 801ba1c:	d10c      	bne.n	801ba38 <_can_int_tx_priv+0x13c>
 801ba1e:	e00f      	b.n	801ba40 <_can_int_tx_priv+0x144>
        }
        else
        {
            level = rt_hw_interrupt_disable();
 801ba20:	f7e4 fbd2 	bl	80001c8 <rt_hw_interrupt_disable>
 801ba24:	61b8      	str	r0, [r7, #24]
            can->status.dropedsndpkg++;
 801ba26:	68fb      	ldr	r3, [r7, #12]
 801ba28:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801ba2a:	1c5a      	adds	r2, r3, #1
 801ba2c:	68fb      	ldr	r3, [r7, #12]
 801ba2e:	671a      	str	r2, [r3, #112]	; 0x70
            rt_hw_interrupt_enable(level);
 801ba30:	69b8      	ldr	r0, [r7, #24]
 801ba32:	f7e4 fbcd 	bl	80001d0 <rt_hw_interrupt_enable>
            break;
 801ba36:	e003      	b.n	801ba40 <_can_int_tx_priv+0x144>

    size = msgs;
    tx_fifo = (struct rt_can_tx_fifo *) can->can_tx;
    RT_ASSERT(tx_fifo != RT_NULL);

    while (msgs)
 801ba38:	687b      	ldr	r3, [r7, #4]
 801ba3a:	2b00      	cmp	r3, #0
 801ba3c:	f47f af7b 	bne.w	801b936 <_can_int_tx_priv+0x3a>
            rt_hw_interrupt_enable(level);
            break;
        }
    }

    return (size - msgs);
 801ba40:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801ba42:	687b      	ldr	r3, [r7, #4]
 801ba44:	1ad3      	subs	r3, r2, r3
}
 801ba46:	4618      	mov	r0, r3
 801ba48:	3728      	adds	r7, #40	; 0x28
 801ba4a:	46bd      	mov	sp, r7
 801ba4c:	bd80      	pop	{r7, pc}
 801ba4e:	bf00      	nop
 801ba50:	08027fec 	.word	0x08027fec
 801ba54:	08029650 	.word	0x08029650
 801ba58:	08028040 	.word	0x08028040

0801ba5c <rt_can_open>:

static rt_err_t rt_can_open(struct rt_device *dev, rt_uint16_t oflag)
{
 801ba5c:	b580      	push	{r7, lr}
 801ba5e:	b088      	sub	sp, #32
 801ba60:	af00      	add	r7, sp, #0
 801ba62:	6078      	str	r0, [r7, #4]
 801ba64:	460b      	mov	r3, r1
 801ba66:	807b      	strh	r3, [r7, #2]
    struct rt_can_device *can;

    RT_ASSERT(dev != RT_NULL);
 801ba68:	687b      	ldr	r3, [r7, #4]
 801ba6a:	2b00      	cmp	r3, #0
 801ba6c:	d105      	bne.n	801ba7a <rt_can_open+0x1e>
 801ba6e:	4891      	ldr	r0, [pc, #580]	; (801bcb4 <rt_can_open+0x258>)
 801ba70:	4991      	ldr	r1, [pc, #580]	; (801bcb8 <rt_can_open+0x25c>)
 801ba72:	f44f 728e 	mov.w	r2, #284	; 0x11c
 801ba76:	f7fb ff9b 	bl	80179b0 <rt_assert_handler>
    can = (struct rt_can_device *)dev;
 801ba7a:	687b      	ldr	r3, [r7, #4]
 801ba7c:	617b      	str	r3, [r7, #20]

    CAN_LOCK(can);
 801ba7e:	697b      	ldr	r3, [r7, #20]
 801ba80:	33cc      	adds	r3, #204	; 0xcc
 801ba82:	4618      	mov	r0, r3
 801ba84:	f04f 31ff 	mov.w	r1, #4294967295
 801ba88:	f7fa fd0e 	bl	80164a8 <rt_mutex_take>

    /* get open flags */
    dev->open_flag = oflag & 0xff;
 801ba8c:	887b      	ldrh	r3, [r7, #2]
 801ba8e:	b2db      	uxtb	r3, r3
 801ba90:	b29a      	uxth	r2, r3
 801ba92:	687b      	ldr	r3, [r7, #4]
 801ba94:	831a      	strh	r2, [r3, #24]
    if (can->can_rx == RT_NULL)
 801ba96:	697b      	ldr	r3, [r7, #20]
 801ba98:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 801ba9c:	2b00      	cmp	r3, #0
 801ba9e:	d166      	bne.n	801bb6e <rt_can_open+0x112>
    {
        if (oflag & RT_DEVICE_FLAG_INT_RX)
 801baa0:	887b      	ldrh	r3, [r7, #2]
 801baa2:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801baa6:	2b00      	cmp	r3, #0
 801baa8:	d061      	beq.n	801bb6e <rt_can_open+0x112>
        {
            int i = 0;
 801baaa:	2300      	movs	r3, #0
 801baac:	61fb      	str	r3, [r7, #28]
            struct rt_can_rx_fifo *rx_fifo;

            rx_fifo = (struct rt_can_rx_fifo *) rt_malloc(sizeof(struct rt_can_rx_fifo) +
                      can->config.msgboxsz * sizeof(struct rt_can_msg_list));
 801baae:	697b      	ldr	r3, [r7, #20]
 801bab0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
        if (oflag & RT_DEVICE_FLAG_INT_RX)
        {
            int i = 0;
            struct rt_can_rx_fifo *rx_fifo;

            rx_fifo = (struct rt_can_rx_fifo *) rt_malloc(sizeof(struct rt_can_rx_fifo) +
 801bab2:	1c5a      	adds	r2, r3, #1
 801bab4:	4613      	mov	r3, r2
 801bab6:	005b      	lsls	r3, r3, #1
 801bab8:	4413      	add	r3, r2
 801baba:	00db      	lsls	r3, r3, #3
 801babc:	4618      	mov	r0, r3
 801babe:	f7fc f8ab 	bl	8017c18 <rt_malloc>
 801bac2:	6138      	str	r0, [r7, #16]
                      can->config.msgboxsz * sizeof(struct rt_can_msg_list));
            RT_ASSERT(rx_fifo != RT_NULL);
 801bac4:	693b      	ldr	r3, [r7, #16]
 801bac6:	2b00      	cmp	r3, #0
 801bac8:	d105      	bne.n	801bad6 <rt_can_open+0x7a>
 801baca:	487c      	ldr	r0, [pc, #496]	; (801bcbc <rt_can_open+0x260>)
 801bacc:	497a      	ldr	r1, [pc, #488]	; (801bcb8 <rt_can_open+0x25c>)
 801bace:	f44f 7296 	mov.w	r2, #300	; 0x12c
 801bad2:	f7fb ff6d 	bl	80179b0 <rt_assert_handler>

            rx_fifo->buffer = (struct rt_can_msg_list *)(rx_fifo + 1);
 801bad6:	693b      	ldr	r3, [r7, #16]
 801bad8:	f103 0218 	add.w	r2, r3, #24
 801badc:	693b      	ldr	r3, [r7, #16]
 801bade:	601a      	str	r2, [r3, #0]
            rt_memset(rx_fifo->buffer, 0, can->config.msgboxsz * sizeof(struct rt_can_msg_list));
 801bae0:	693b      	ldr	r3, [r7, #16]
 801bae2:	6819      	ldr	r1, [r3, #0]
 801bae4:	697b      	ldr	r3, [r7, #20]
 801bae6:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 801bae8:	4613      	mov	r3, r2
 801baea:	005b      	lsls	r3, r3, #1
 801baec:	4413      	add	r3, r2
 801baee:	00db      	lsls	r3, r3, #3
 801baf0:	4608      	mov	r0, r1
 801baf2:	2100      	movs	r1, #0
 801baf4:	461a      	mov	r2, r3
 801baf6:	f7fb f929 	bl	8016d4c <rt_memset>
            rt_list_init(&rx_fifo->freelist);
 801bafa:	693b      	ldr	r3, [r7, #16]
 801bafc:	3308      	adds	r3, #8
 801bafe:	4618      	mov	r0, r3
 801bb00:	f7ff fd10 	bl	801b524 <rt_list_init>
            rt_list_init(&rx_fifo->uselist);
 801bb04:	693b      	ldr	r3, [r7, #16]
 801bb06:	3310      	adds	r3, #16
 801bb08:	4618      	mov	r0, r3
 801bb0a:	f7ff fd0b 	bl	801b524 <rt_list_init>
            rx_fifo->freenumbers = can->config.msgboxsz;
 801bb0e:	697b      	ldr	r3, [r7, #20]
 801bb10:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 801bb12:	693b      	ldr	r3, [r7, #16]
 801bb14:	605a      	str	r2, [r3, #4]
            for (i = 0;  i < can->config.msgboxsz; i++)
 801bb16:	2300      	movs	r3, #0
 801bb18:	61fb      	str	r3, [r7, #28]
 801bb1a:	e010      	b.n	801bb3e <rt_can_open+0xe2>
            {
                rt_list_insert_before(&rx_fifo->freelist, &rx_fifo->buffer[i].list);
 801bb1c:	693b      	ldr	r3, [r7, #16]
 801bb1e:	f103 0008 	add.w	r0, r3, #8
 801bb22:	693b      	ldr	r3, [r7, #16]
 801bb24:	6819      	ldr	r1, [r3, #0]
 801bb26:	69fa      	ldr	r2, [r7, #28]
 801bb28:	4613      	mov	r3, r2
 801bb2a:	005b      	lsls	r3, r3, #1
 801bb2c:	4413      	add	r3, r2
 801bb2e:	00db      	lsls	r3, r3, #3
 801bb30:	440b      	add	r3, r1
 801bb32:	4619      	mov	r1, r3
 801bb34:	f7ff fd1e 	bl	801b574 <rt_list_insert_before>
            rx_fifo->buffer = (struct rt_can_msg_list *)(rx_fifo + 1);
            rt_memset(rx_fifo->buffer, 0, can->config.msgboxsz * sizeof(struct rt_can_msg_list));
            rt_list_init(&rx_fifo->freelist);
            rt_list_init(&rx_fifo->uselist);
            rx_fifo->freenumbers = can->config.msgboxsz;
            for (i = 0;  i < can->config.msgboxsz; i++)
 801bb38:	69fb      	ldr	r3, [r7, #28]
 801bb3a:	3301      	adds	r3, #1
 801bb3c:	61fb      	str	r3, [r7, #28]
 801bb3e:	69fa      	ldr	r2, [r7, #28]
 801bb40:	697b      	ldr	r3, [r7, #20]
 801bb42:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801bb44:	429a      	cmp	r2, r3
 801bb46:	d3e9      	bcc.n	801bb1c <rt_can_open+0xc0>
#ifdef RT_CAN_USING_HDR
                rt_list_init(&rx_fifo->buffer[i].hdrlist);
                rx_fifo->buffer[i].owner = RT_NULL;
#endif
            }
            can->can_rx = rx_fifo;
 801bb48:	697b      	ldr	r3, [r7, #20]
 801bb4a:	693a      	ldr	r2, [r7, #16]
 801bb4c:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0

            dev->open_flag |= RT_DEVICE_FLAG_INT_RX;
 801bb50:	687b      	ldr	r3, [r7, #4]
 801bb52:	8b1b      	ldrh	r3, [r3, #24]
 801bb54:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 801bb58:	b29a      	uxth	r2, r3
 801bb5a:	687b      	ldr	r3, [r7, #4]
 801bb5c:	831a      	strh	r2, [r3, #24]
            /* configure low level device */
            can->ops->control(can, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_RX);
 801bb5e:	697b      	ldr	r3, [r7, #20]
 801bb60:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801bb62:	685b      	ldr	r3, [r3, #4]
 801bb64:	6978      	ldr	r0, [r7, #20]
 801bb66:	2110      	movs	r1, #16
 801bb68:	f44f 7280 	mov.w	r2, #256	; 0x100
 801bb6c:	4798      	blx	r3

		//else
			//can->can_rx = RT_NULL;
    }

    if (can->can_tx == RT_NULL)
 801bb6e:	697b      	ldr	r3, [r7, #20]
 801bb70:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 801bb74:	2b00      	cmp	r3, #0
 801bb76:	d17d      	bne.n	801bc74 <rt_can_open+0x218>
    {
        if (oflag & RT_DEVICE_FLAG_INT_TX)
 801bb78:	887b      	ldrh	r3, [r7, #2]
 801bb7a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801bb7e:	2b00      	cmp	r3, #0
 801bb80:	d074      	beq.n	801bc6c <rt_can_open+0x210>
        {
            int i = 0;
 801bb82:	2300      	movs	r3, #0
 801bb84:	61bb      	str	r3, [r7, #24]
            struct rt_can_tx_fifo *tx_fifo;

            tx_fifo = (struct rt_can_tx_fifo *) rt_malloc(sizeof(struct rt_can_tx_fifo) +
                      can->config.sndboxnumber * sizeof(struct rt_can_sndbxinx_list));
 801bb86:	697b      	ldr	r3, [r7, #20]
 801bb88:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
        if (oflag & RT_DEVICE_FLAG_INT_TX)
        {
            int i = 0;
            struct rt_can_tx_fifo *tx_fifo;

            tx_fifo = (struct rt_can_tx_fifo *) rt_malloc(sizeof(struct rt_can_tx_fifo) +
 801bb8a:	1c5a      	adds	r2, r3, #1
 801bb8c:	4613      	mov	r3, r2
 801bb8e:	005b      	lsls	r3, r3, #1
 801bb90:	4413      	add	r3, r2
 801bb92:	00db      	lsls	r3, r3, #3
 801bb94:	4618      	mov	r0, r3
 801bb96:	f7fc f83f 	bl	8017c18 <rt_malloc>
 801bb9a:	60f8      	str	r0, [r7, #12]
                      can->config.sndboxnumber * sizeof(struct rt_can_sndbxinx_list));
            RT_ASSERT(tx_fifo != RT_NULL);
 801bb9c:	68fb      	ldr	r3, [r7, #12]
 801bb9e:	2b00      	cmp	r3, #0
 801bba0:	d105      	bne.n	801bbae <rt_can_open+0x152>
 801bba2:	4847      	ldr	r0, [pc, #284]	; (801bcc0 <rt_can_open+0x264>)
 801bba4:	4944      	ldr	r1, [pc, #272]	; (801bcb8 <rt_can_open+0x25c>)
 801bba6:	f240 124f 	movw	r2, #335	; 0x14f
 801bbaa:	f7fb ff01 	bl	80179b0 <rt_assert_handler>

            tx_fifo->buffer = (struct rt_can_sndbxinx_list *)(tx_fifo + 1);
 801bbae:	68fb      	ldr	r3, [r7, #12]
 801bbb0:	f103 0218 	add.w	r2, r3, #24
 801bbb4:	68fb      	ldr	r3, [r7, #12]
 801bbb6:	601a      	str	r2, [r3, #0]
            rt_memset(tx_fifo->buffer, 0,
 801bbb8:	68fb      	ldr	r3, [r7, #12]
 801bbba:	6819      	ldr	r1, [r3, #0]
                      can->config.sndboxnumber * sizeof(struct rt_can_sndbxinx_list));
 801bbbc:	697b      	ldr	r3, [r7, #20]
 801bbbe:	6cda      	ldr	r2, [r3, #76]	; 0x4c
            tx_fifo = (struct rt_can_tx_fifo *) rt_malloc(sizeof(struct rt_can_tx_fifo) +
                      can->config.sndboxnumber * sizeof(struct rt_can_sndbxinx_list));
            RT_ASSERT(tx_fifo != RT_NULL);

            tx_fifo->buffer = (struct rt_can_sndbxinx_list *)(tx_fifo + 1);
            rt_memset(tx_fifo->buffer, 0,
 801bbc0:	4613      	mov	r3, r2
 801bbc2:	005b      	lsls	r3, r3, #1
 801bbc4:	4413      	add	r3, r2
 801bbc6:	00db      	lsls	r3, r3, #3
 801bbc8:	4608      	mov	r0, r1
 801bbca:	2100      	movs	r1, #0
 801bbcc:	461a      	mov	r2, r3
 801bbce:	f7fb f8bd 	bl	8016d4c <rt_memset>
                      can->config.sndboxnumber * sizeof(struct rt_can_sndbxinx_list));
            rt_list_init(&tx_fifo->freelist);
 801bbd2:	68fb      	ldr	r3, [r7, #12]
 801bbd4:	3310      	adds	r3, #16
 801bbd6:	4618      	mov	r0, r3
 801bbd8:	f7ff fca4 	bl	801b524 <rt_list_init>
            for (i = 0;  i < can->config.sndboxnumber; i++)
 801bbdc:	2300      	movs	r3, #0
 801bbde:	61bb      	str	r3, [r7, #24]
 801bbe0:	e026      	b.n	801bc30 <rt_can_open+0x1d4>
            {
                rt_list_insert_before(&tx_fifo->freelist, &tx_fifo->buffer[i].list);
 801bbe2:	68fb      	ldr	r3, [r7, #12]
 801bbe4:	f103 0010 	add.w	r0, r3, #16
 801bbe8:	68fb      	ldr	r3, [r7, #12]
 801bbea:	6819      	ldr	r1, [r3, #0]
 801bbec:	69ba      	ldr	r2, [r7, #24]
 801bbee:	4613      	mov	r3, r2
 801bbf0:	005b      	lsls	r3, r3, #1
 801bbf2:	4413      	add	r3, r2
 801bbf4:	00db      	lsls	r3, r3, #3
 801bbf6:	440b      	add	r3, r1
 801bbf8:	4619      	mov	r1, r3
 801bbfa:	f7ff fcbb 	bl	801b574 <rt_list_insert_before>
                rt_completion_init(&(tx_fifo->buffer[i].completion));
 801bbfe:	68fb      	ldr	r3, [r7, #12]
 801bc00:	6819      	ldr	r1, [r3, #0]
 801bc02:	69ba      	ldr	r2, [r7, #24]
 801bc04:	4613      	mov	r3, r2
 801bc06:	005b      	lsls	r3, r3, #1
 801bc08:	4413      	add	r3, r2
 801bc0a:	00db      	lsls	r3, r3, #3
 801bc0c:	440b      	add	r3, r1
 801bc0e:	3308      	adds	r3, #8
 801bc10:	4618      	mov	r0, r3
 801bc12:	f7fe f823 	bl	8019c5c <rt_completion_init>
                tx_fifo->buffer[i].result = RT_CAN_SND_RESULT_OK;
 801bc16:	68fb      	ldr	r3, [r7, #12]
 801bc18:	6819      	ldr	r1, [r3, #0]
 801bc1a:	69ba      	ldr	r2, [r7, #24]
 801bc1c:	4613      	mov	r3, r2
 801bc1e:	005b      	lsls	r3, r3, #1
 801bc20:	4413      	add	r3, r2
 801bc22:	00db      	lsls	r3, r3, #3
 801bc24:	440b      	add	r3, r1
 801bc26:	2200      	movs	r2, #0
 801bc28:	615a      	str	r2, [r3, #20]

            tx_fifo->buffer = (struct rt_can_sndbxinx_list *)(tx_fifo + 1);
            rt_memset(tx_fifo->buffer, 0,
                      can->config.sndboxnumber * sizeof(struct rt_can_sndbxinx_list));
            rt_list_init(&tx_fifo->freelist);
            for (i = 0;  i < can->config.sndboxnumber; i++)
 801bc2a:	69bb      	ldr	r3, [r7, #24]
 801bc2c:	3301      	adds	r3, #1
 801bc2e:	61bb      	str	r3, [r7, #24]
 801bc30:	69ba      	ldr	r2, [r7, #24]
 801bc32:	697b      	ldr	r3, [r7, #20]
 801bc34:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801bc36:	429a      	cmp	r2, r3
 801bc38:	d3d3      	bcc.n	801bbe2 <rt_can_open+0x186>
            {
                rt_list_insert_before(&tx_fifo->freelist, &tx_fifo->buffer[i].list);
                rt_completion_init(&(tx_fifo->buffer[i].completion));
                tx_fifo->buffer[i].result = RT_CAN_SND_RESULT_OK;
            }
            rt_completion_init(&(tx_fifo->completion));
 801bc3a:	68fb      	ldr	r3, [r7, #12]
 801bc3c:	3304      	adds	r3, #4
 801bc3e:	4618      	mov	r0, r3
 801bc40:	f7fe f80c 	bl	8019c5c <rt_completion_init>
            can->can_tx = tx_fifo;
 801bc44:	697b      	ldr	r3, [r7, #20]
 801bc46:	68fa      	ldr	r2, [r7, #12]
 801bc48:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4

            dev->open_flag |= RT_DEVICE_FLAG_INT_TX;
 801bc4c:	687b      	ldr	r3, [r7, #4]
 801bc4e:	8b1b      	ldrh	r3, [r3, #24]
 801bc50:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 801bc54:	b29a      	uxth	r2, r3
 801bc56:	687b      	ldr	r3, [r7, #4]
 801bc58:	831a      	strh	r2, [r3, #24]
            /* configure low level device */
            can->ops->control(can, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_TX);
 801bc5a:	697b      	ldr	r3, [r7, #20]
 801bc5c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801bc5e:	685b      	ldr	r3, [r3, #4]
 801bc60:	6978      	ldr	r0, [r7, #20]
 801bc62:	2110      	movs	r1, #16
 801bc64:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801bc68:	4798      	blx	r3
 801bc6a:	e003      	b.n	801bc74 <rt_can_open+0x218>
        }
		else 
			can->can_tx = RT_NULL;
 801bc6c:	697b      	ldr	r3, [r7, #20]
 801bc6e:	2200      	movs	r2, #0
 801bc70:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
    }

    can->ops->control(can, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_CAN_INT_ERR);
 801bc74:	697b      	ldr	r3, [r7, #20]
 801bc76:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801bc78:	685b      	ldr	r3, [r3, #4]
 801bc7a:	6978      	ldr	r0, [r7, #20]
 801bc7c:	2110      	movs	r1, #16
 801bc7e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801bc82:	4798      	blx	r3

        can->hdr = phdr;
    }
#endif

    if (!can->timerinitflag)
 801bc84:	697b      	ldr	r3, [r7, #20]
 801bc86:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 801bc8a:	2b00      	cmp	r3, #0
 801bc8c:	d108      	bne.n	801bca0 <rt_can_open+0x244>
    {
        can->timerinitflag = 1;
 801bc8e:	697b      	ldr	r3, [r7, #20]
 801bc90:	2201      	movs	r2, #1
 801bc92:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

        rt_timer_start(&can->timer);
 801bc96:	697b      	ldr	r3, [r7, #20]
 801bc98:	3398      	adds	r3, #152	; 0x98
 801bc9a:	4618      	mov	r0, r3
 801bc9c:	f7fd fad2 	bl	8019244 <rt_timer_start>
    }

    CAN_UNLOCK(can);
 801bca0:	697b      	ldr	r3, [r7, #20]
 801bca2:	33cc      	adds	r3, #204	; 0xcc
 801bca4:	4618      	mov	r0, r3
 801bca6:	f7fa fcd7 	bl	8016658 <rt_mutex_release>

    return RT_EOK;
 801bcaa:	2300      	movs	r3, #0
}
 801bcac:	4618      	mov	r0, r3
 801bcae:	3720      	adds	r7, #32
 801bcb0:	46bd      	mov	sp, r7
 801bcb2:	bd80      	pop	{r7, pc}
 801bcb4:	08027fdc 	.word	0x08027fdc
 801bcb8:	0802960c 	.word	0x0802960c
 801bcbc:	08027ffc 	.word	0x08027ffc
 801bcc0:	08028040 	.word	0x08028040

0801bcc4 <rt_can_close>:

static rt_err_t rt_can_close(struct rt_device *dev)
{
 801bcc4:	b580      	push	{r7, lr}
 801bcc6:	b086      	sub	sp, #24
 801bcc8:	af00      	add	r7, sp, #0
 801bcca:	6078      	str	r0, [r7, #4]
    struct rt_can_device *can;

    RT_ASSERT(dev != RT_NULL);
 801bccc:	687b      	ldr	r3, [r7, #4]
 801bcce:	2b00      	cmp	r3, #0
 801bcd0:	d105      	bne.n	801bcde <rt_can_close+0x1a>
 801bcd2:	4846      	ldr	r0, [pc, #280]	; (801bdec <rt_can_close+0x128>)
 801bcd4:	4946      	ldr	r1, [pc, #280]	; (801bdf0 <rt_can_close+0x12c>)
 801bcd6:	f44f 72c5 	mov.w	r2, #394	; 0x18a
 801bcda:	f7fb fe69 	bl	80179b0 <rt_assert_handler>
    can = (struct rt_can_device *)dev;
 801bcde:	687b      	ldr	r3, [r7, #4]
 801bce0:	617b      	str	r3, [r7, #20]

    CAN_LOCK(can);
 801bce2:	697b      	ldr	r3, [r7, #20]
 801bce4:	33cc      	adds	r3, #204	; 0xcc
 801bce6:	4618      	mov	r0, r3
 801bce8:	f04f 31ff 	mov.w	r1, #4294967295
 801bcec:	f7fa fbdc 	bl	80164a8 <rt_mutex_take>

    /* this device has more reference count */
    if (dev->ref_count > 1)
 801bcf0:	687b      	ldr	r3, [r7, #4]
 801bcf2:	7e9b      	ldrb	r3, [r3, #26]
 801bcf4:	2b01      	cmp	r3, #1
 801bcf6:	d906      	bls.n	801bd06 <rt_can_close+0x42>
    {
        CAN_UNLOCK(can);
 801bcf8:	697b      	ldr	r3, [r7, #20]
 801bcfa:	33cc      	adds	r3, #204	; 0xcc
 801bcfc:	4618      	mov	r0, r3
 801bcfe:	f7fa fcab 	bl	8016658 <rt_mutex_release>
        return RT_EOK;
 801bd02:	2300      	movs	r3, #0
 801bd04:	e06d      	b.n	801bde2 <rt_can_close+0x11e>
    }

    if (can->timerinitflag)
 801bd06:	697b      	ldr	r3, [r7, #20]
 801bd08:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 801bd0c:	2b00      	cmp	r3, #0
 801bd0e:	d008      	beq.n	801bd22 <rt_can_close+0x5e>
    {
        can->timerinitflag = 0;
 801bd10:	697b      	ldr	r3, [r7, #20]
 801bd12:	2200      	movs	r2, #0
 801bd14:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

        rt_timer_stop(&can->timer);
 801bd18:	697b      	ldr	r3, [r7, #20]
 801bd1a:	3398      	adds	r3, #152	; 0x98
 801bd1c:	4618      	mov	r0, r3
 801bd1e:	f7fd fb9d 	bl	801945c <rt_timer_stop>
    }

    can->status_indicate.ind = RT_NULL;
 801bd22:	697b      	ldr	r3, [r7, #20]
 801bd24:	2200      	movs	r2, #0
 801bd26:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
    can->status_indicate.args = RT_NULL;
 801bd2a:	697b      	ldr	r3, [r7, #20]
 801bd2c:	2200      	movs	r2, #0
 801bd2e:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
        rt_free(can->hdr);
        can->hdr = RT_NULL;
    }
#endif

    if (dev->open_flag & RT_DEVICE_FLAG_INT_RX)
 801bd32:	687b      	ldr	r3, [r7, #4]
 801bd34:	8b1b      	ldrh	r3, [r3, #24]
 801bd36:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801bd3a:	2b00      	cmp	r3, #0
 801bd3c:	d01e      	beq.n	801bd7c <rt_can_close+0xb8>
    {
        struct rt_can_rx_fifo *rx_fifo;

        rx_fifo = (struct rt_can_rx_fifo *)can->can_rx;
 801bd3e:	697b      	ldr	r3, [r7, #20]
 801bd40:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 801bd44:	613b      	str	r3, [r7, #16]
        RT_ASSERT(rx_fifo != RT_NULL);
 801bd46:	693b      	ldr	r3, [r7, #16]
 801bd48:	2b00      	cmp	r3, #0
 801bd4a:	d105      	bne.n	801bd58 <rt_can_close+0x94>
 801bd4c:	4829      	ldr	r0, [pc, #164]	; (801bdf4 <rt_can_close+0x130>)
 801bd4e:	4928      	ldr	r1, [pc, #160]	; (801bdf0 <rt_can_close+0x12c>)
 801bd50:	f240 12ad 	movw	r2, #429	; 0x1ad
 801bd54:	f7fb fe2c 	bl	80179b0 <rt_assert_handler>

        rt_free(rx_fifo);
 801bd58:	6938      	ldr	r0, [r7, #16]
 801bd5a:	f7fc f967 	bl	801802c <rt_free>
        dev->open_flag &= ~RT_DEVICE_FLAG_INT_RX;
 801bd5e:	687b      	ldr	r3, [r7, #4]
 801bd60:	8b1b      	ldrh	r3, [r3, #24]
 801bd62:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 801bd66:	b29a      	uxth	r2, r3
 801bd68:	687b      	ldr	r3, [r7, #4]
 801bd6a:	831a      	strh	r2, [r3, #24]
        /* configure low level device */
        can->ops->control(can, RT_DEVICE_CTRL_CLR_INT, (void *)RT_DEVICE_FLAG_INT_RX);
 801bd6c:	697b      	ldr	r3, [r7, #20]
 801bd6e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801bd70:	685b      	ldr	r3, [r3, #4]
 801bd72:	6978      	ldr	r0, [r7, #20]
 801bd74:	2111      	movs	r1, #17
 801bd76:	f44f 7280 	mov.w	r2, #256	; 0x100
 801bd7a:	4798      	blx	r3
    }

    if (dev->open_flag & RT_DEVICE_FLAG_INT_TX)
 801bd7c:	687b      	ldr	r3, [r7, #4]
 801bd7e:	8b1b      	ldrh	r3, [r3, #24]
 801bd80:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801bd84:	2b00      	cmp	r3, #0
 801bd86:	d01e      	beq.n	801bdc6 <rt_can_close+0x102>
    {
        struct rt_can_tx_fifo *tx_fifo;

        tx_fifo = (struct rt_can_tx_fifo *)can->can_tx;
 801bd88:	697b      	ldr	r3, [r7, #20]
 801bd8a:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 801bd8e:	60fb      	str	r3, [r7, #12]
        RT_ASSERT(tx_fifo != RT_NULL);
 801bd90:	68fb      	ldr	r3, [r7, #12]
 801bd92:	2b00      	cmp	r3, #0
 801bd94:	d105      	bne.n	801bda2 <rt_can_close+0xde>
 801bd96:	4818      	ldr	r0, [pc, #96]	; (801bdf8 <rt_can_close+0x134>)
 801bd98:	4915      	ldr	r1, [pc, #84]	; (801bdf0 <rt_can_close+0x12c>)
 801bd9a:	f44f 72dd 	mov.w	r2, #442	; 0x1ba
 801bd9e:	f7fb fe07 	bl	80179b0 <rt_assert_handler>

        rt_free(tx_fifo);
 801bda2:	68f8      	ldr	r0, [r7, #12]
 801bda4:	f7fc f942 	bl	801802c <rt_free>
        dev->open_flag &= ~RT_DEVICE_FLAG_INT_TX;
 801bda8:	687b      	ldr	r3, [r7, #4]
 801bdaa:	8b1b      	ldrh	r3, [r3, #24]
 801bdac:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 801bdb0:	b29a      	uxth	r2, r3
 801bdb2:	687b      	ldr	r3, [r7, #4]
 801bdb4:	831a      	strh	r2, [r3, #24]
        /* configure low level device */
        can->ops->control(can, RT_DEVICE_CTRL_CLR_INT, (void *)RT_DEVICE_FLAG_INT_TX);
 801bdb6:	697b      	ldr	r3, [r7, #20]
 801bdb8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801bdba:	685b      	ldr	r3, [r3, #4]
 801bdbc:	6978      	ldr	r0, [r7, #20]
 801bdbe:	2111      	movs	r1, #17
 801bdc0:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801bdc4:	4798      	blx	r3
    }

    can->ops->control(can, RT_DEVICE_CTRL_CLR_INT, (void *)RT_DEVICE_CAN_INT_ERR);
 801bdc6:	697b      	ldr	r3, [r7, #20]
 801bdc8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801bdca:	685b      	ldr	r3, [r3, #4]
 801bdcc:	6978      	ldr	r0, [r7, #20]
 801bdce:	2111      	movs	r1, #17
 801bdd0:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801bdd4:	4798      	blx	r3

    CAN_UNLOCK(can);
 801bdd6:	697b      	ldr	r3, [r7, #20]
 801bdd8:	33cc      	adds	r3, #204	; 0xcc
 801bdda:	4618      	mov	r0, r3
 801bddc:	f7fa fc3c 	bl	8016658 <rt_mutex_release>

    return RT_EOK;
 801bde0:	2300      	movs	r3, #0
}
 801bde2:	4618      	mov	r0, r3
 801bde4:	3718      	adds	r7, #24
 801bde6:	46bd      	mov	sp, r7
 801bde8:	bd80      	pop	{r7, pc}
 801bdea:	bf00      	nop
 801bdec:	08027fdc 	.word	0x08027fdc
 801bdf0:	08029618 	.word	0x08029618
 801bdf4:	08027ffc 	.word	0x08027ffc
 801bdf8:	08028040 	.word	0x08028040

0801bdfc <rt_can_read>:

static rt_size_t rt_can_read(struct rt_device *dev,
                             rt_off_t          pos,
                             void             *buffer,
                             rt_size_t         size)
{
 801bdfc:	b580      	push	{r7, lr}
 801bdfe:	b086      	sub	sp, #24
 801be00:	af00      	add	r7, sp, #0
 801be02:	60f8      	str	r0, [r7, #12]
 801be04:	60b9      	str	r1, [r7, #8]
 801be06:	607a      	str	r2, [r7, #4]
 801be08:	603b      	str	r3, [r7, #0]
    struct rt_can_device *can;

    RT_ASSERT(dev != RT_NULL);
 801be0a:	68fb      	ldr	r3, [r7, #12]
 801be0c:	2b00      	cmp	r3, #0
 801be0e:	d105      	bne.n	801be1c <rt_can_read+0x20>
 801be10:	4811      	ldr	r0, [pc, #68]	; (801be58 <rt_can_read+0x5c>)
 801be12:	4912      	ldr	r1, [pc, #72]	; (801be5c <rt_can_read+0x60>)
 801be14:	f44f 72e8 	mov.w	r2, #464	; 0x1d0
 801be18:	f7fb fdca 	bl	80179b0 <rt_assert_handler>
    if (size == 0) return 0;
 801be1c:	683b      	ldr	r3, [r7, #0]
 801be1e:	2b00      	cmp	r3, #0
 801be20:	d101      	bne.n	801be26 <rt_can_read+0x2a>
 801be22:	2300      	movs	r3, #0
 801be24:	e014      	b.n	801be50 <rt_can_read+0x54>

    can = (struct rt_can_device *)dev;
 801be26:	68fb      	ldr	r3, [r7, #12]
 801be28:	617b      	str	r3, [r7, #20]

    if ((dev->open_flag & RT_DEVICE_FLAG_INT_RX) && (dev->ref_count > 0))
 801be2a:	68fb      	ldr	r3, [r7, #12]
 801be2c:	8b1b      	ldrh	r3, [r3, #24]
 801be2e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801be32:	2b00      	cmp	r3, #0
 801be34:	d00b      	beq.n	801be4e <rt_can_read+0x52>
 801be36:	68fb      	ldr	r3, [r7, #12]
 801be38:	7e9b      	ldrb	r3, [r3, #26]
 801be3a:	2b00      	cmp	r3, #0
 801be3c:	d007      	beq.n	801be4e <rt_can_read+0x52>
    {
        return _can_int_rx(can, buffer, size);
 801be3e:	683b      	ldr	r3, [r7, #0]
 801be40:	6978      	ldr	r0, [r7, #20]
 801be42:	6879      	ldr	r1, [r7, #4]
 801be44:	461a      	mov	r2, r3
 801be46:	f7ff fc09 	bl	801b65c <_can_int_rx>
 801be4a:	4603      	mov	r3, r0
 801be4c:	e000      	b.n	801be50 <rt_can_read+0x54>
    }

    return 0;
 801be4e:	2300      	movs	r3, #0
}
 801be50:	4618      	mov	r0, r3
 801be52:	3718      	adds	r7, #24
 801be54:	46bd      	mov	sp, r7
 801be56:	bd80      	pop	{r7, pc}
 801be58:	08027fdc 	.word	0x08027fdc
 801be5c:	08029628 	.word	0x08029628

0801be60 <rt_can_write>:

static rt_size_t rt_can_write(struct rt_device *dev,
                              rt_off_t          pos,
                              const void       *buffer,
                              rt_size_t         size)
{
 801be60:	b580      	push	{r7, lr}
 801be62:	b086      	sub	sp, #24
 801be64:	af00      	add	r7, sp, #0
 801be66:	60f8      	str	r0, [r7, #12]
 801be68:	60b9      	str	r1, [r7, #8]
 801be6a:	607a      	str	r2, [r7, #4]
 801be6c:	603b      	str	r3, [r7, #0]
    struct rt_can_device *can;

    RT_ASSERT(dev != RT_NULL);
 801be6e:	68fb      	ldr	r3, [r7, #12]
 801be70:	2b00      	cmp	r3, #0
 801be72:	d105      	bne.n	801be80 <rt_can_write+0x20>
 801be74:	481b      	ldr	r0, [pc, #108]	; (801bee4 <rt_can_write+0x84>)
 801be76:	491c      	ldr	r1, [pc, #112]	; (801bee8 <rt_can_write+0x88>)
 801be78:	f44f 72f2 	mov.w	r2, #484	; 0x1e4
 801be7c:	f7fb fd98 	bl	80179b0 <rt_assert_handler>
    if (size == 0) return 0;
 801be80:	683b      	ldr	r3, [r7, #0]
 801be82:	2b00      	cmp	r3, #0
 801be84:	d101      	bne.n	801be8a <rt_can_write+0x2a>
 801be86:	2300      	movs	r3, #0
 801be88:	e028      	b.n	801bedc <rt_can_write+0x7c>

    can = (struct rt_can_device *)dev;
 801be8a:	68fb      	ldr	r3, [r7, #12]
 801be8c:	617b      	str	r3, [r7, #20]

    if ((dev->open_flag & RT_DEVICE_FLAG_INT_TX) && (dev->ref_count > 0))
 801be8e:	68fb      	ldr	r3, [r7, #12]
 801be90:	8b1b      	ldrh	r3, [r3, #24]
 801be92:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801be96:	2b00      	cmp	r3, #0
 801be98:	d018      	beq.n	801becc <rt_can_write+0x6c>
 801be9a:	68fb      	ldr	r3, [r7, #12]
 801be9c:	7e9b      	ldrb	r3, [r3, #26]
 801be9e:	2b00      	cmp	r3, #0
 801bea0:	d014      	beq.n	801becc <rt_can_write+0x6c>
    {
        if (can->config.privmode)
 801bea2:	697b      	ldr	r3, [r7, #20]
 801bea4:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 801bea8:	2b00      	cmp	r3, #0
 801beaa:	d007      	beq.n	801bebc <rt_can_write+0x5c>
        {
            return _can_int_tx_priv(can, buffer, size);
 801beac:	683b      	ldr	r3, [r7, #0]
 801beae:	6978      	ldr	r0, [r7, #20]
 801beb0:	6879      	ldr	r1, [r7, #4]
 801beb2:	461a      	mov	r2, r3
 801beb4:	f7ff fd22 	bl	801b8fc <_can_int_tx_priv>
 801beb8:	4603      	mov	r3, r0
 801beba:	e00f      	b.n	801bedc <rt_can_write+0x7c>
        }
        else
        {
            return _can_int_tx(can, buffer, size);
 801bebc:	683b      	ldr	r3, [r7, #0]
 801bebe:	6978      	ldr	r0, [r7, #20]
 801bec0:	6879      	ldr	r1, [r7, #4]
 801bec2:	461a      	mov	r2, r3
 801bec4:	f7ff fc48 	bl	801b758 <_can_int_tx>
 801bec8:	4603      	mov	r3, r0
 801beca:	e007      	b.n	801bedc <rt_can_write+0x7c>
        }
    }
	else
		//stm32_CANsendmsg(can, buffer, size);
		return can->ops->sendmsg(can, buffer, size);
 801becc:	697b      	ldr	r3, [r7, #20]
 801bece:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801bed0:	689b      	ldr	r3, [r3, #8]
 801bed2:	6978      	ldr	r0, [r7, #20]
 801bed4:	6879      	ldr	r1, [r7, #4]
 801bed6:	683a      	ldr	r2, [r7, #0]
 801bed8:	4798      	blx	r3
 801beda:	4603      	mov	r3, r0
    return 0;
}
 801bedc:	4618      	mov	r0, r3
 801bede:	3718      	adds	r7, #24
 801bee0:	46bd      	mov	sp, r7
 801bee2:	bd80      	pop	{r7, pc}
 801bee4:	08027fdc 	.word	0x08027fdc
 801bee8:	08029640 	.word	0x08029640

0801beec <rt_can_control>:

static rt_err_t rt_can_control(struct rt_device *dev,
                               rt_uint8_t        cmd,
                               void             *args)
{
 801beec:	b580      	push	{r7, lr}
 801beee:	b08a      	sub	sp, #40	; 0x28
 801bef0:	af00      	add	r7, sp, #0
 801bef2:	60f8      	str	r0, [r7, #12]
 801bef4:	460b      	mov	r3, r1
 801bef6:	607a      	str	r2, [r7, #4]
 801bef8:	72fb      	strb	r3, [r7, #11]
    struct rt_can_device *can;
    rt_err_t res;

    RT_ASSERT(dev != RT_NULL);
 801befa:	68fb      	ldr	r3, [r7, #12]
 801befc:	2b00      	cmp	r3, #0
 801befe:	d105      	bne.n	801bf0c <rt_can_control+0x20>
 801bf00:	4870      	ldr	r0, [pc, #448]	; (801c0c4 <rt_can_control+0x1d8>)
 801bf02:	4971      	ldr	r1, [pc, #452]	; (801c0c8 <rt_can_control+0x1dc>)
 801bf04:	f240 2201 	movw	r2, #513	; 0x201
 801bf08:	f7fb fd52 	bl	80179b0 <rt_assert_handler>
    can = (struct rt_can_device *)dev;
 801bf0c:	68fb      	ldr	r3, [r7, #12]
 801bf0e:	623b      	str	r3, [r7, #32]

    switch (cmd)
 801bf10:	7afb      	ldrb	r3, [r7, #11]
 801bf12:	3b01      	subs	r3, #1
 801bf14:	2b17      	cmp	r3, #23
 801bf16:	f200 80c1 	bhi.w	801c09c <rt_can_control+0x1b0>
 801bf1a:	a201      	add	r2, pc, #4	; (adr r2, 801bf20 <rt_can_control+0x34>)
 801bf1c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801bf20:	0801bf91 	.word	0x0801bf91
 801bf24:	0801bf81 	.word	0x0801bf81
 801bf28:	0801bfa1 	.word	0x0801bfa1
 801bf2c:	0801c09d 	.word	0x0801c09d
 801bf30:	0801c09d 	.word	0x0801c09d
 801bf34:	0801c09d 	.word	0x0801c09d
 801bf38:	0801c09d 	.word	0x0801c09d
 801bf3c:	0801c09d 	.word	0x0801c09d
 801bf40:	0801c09d 	.word	0x0801c09d
 801bf44:	0801c09d 	.word	0x0801c09d
 801bf48:	0801c09d 	.word	0x0801c09d
 801bf4c:	0801c09d 	.word	0x0801c09d
 801bf50:	0801c09d 	.word	0x0801c09d
 801bf54:	0801c09d 	.word	0x0801c09d
 801bf58:	0801c09d 	.word	0x0801c09d
 801bf5c:	0801c09d 	.word	0x0801c09d
 801bf60:	0801c09d 	.word	0x0801c09d
 801bf64:	0801c09d 	.word	0x0801c09d
 801bf68:	0801c09d 	.word	0x0801c09d
 801bf6c:	0801c09d 	.word	0x0801c09d
 801bf70:	0801c09d 	.word	0x0801c09d
 801bf74:	0801bfaf 	.word	0x0801bfaf
 801bf78:	0801c09d 	.word	0x0801c09d
 801bf7c:	0801c087 	.word	0x0801c087
    {
    case RT_DEVICE_CTRL_SUSPEND:
        /* suspend device */
        dev->flag |= RT_DEVICE_FLAG_SUSPENDED;
 801bf80:	68fb      	ldr	r3, [r7, #12]
 801bf82:	8adb      	ldrh	r3, [r3, #22]
 801bf84:	f043 0320 	orr.w	r3, r3, #32
 801bf88:	b29a      	uxth	r2, r3
 801bf8a:	68fb      	ldr	r3, [r7, #12]
 801bf8c:	82da      	strh	r2, [r3, #22]
        break;
 801bf8e:	e094      	b.n	801c0ba <rt_can_control+0x1ce>

    case RT_DEVICE_CTRL_RESUME:
        /* resume device */
        dev->flag &= ~RT_DEVICE_FLAG_SUSPENDED;
 801bf90:	68fb      	ldr	r3, [r7, #12]
 801bf92:	8adb      	ldrh	r3, [r3, #22]
 801bf94:	f023 0320 	bic.w	r3, r3, #32
 801bf98:	b29a      	uxth	r2, r3
 801bf9a:	68fb      	ldr	r3, [r7, #12]
 801bf9c:	82da      	strh	r2, [r3, #22]
        break;
 801bf9e:	e08c      	b.n	801c0ba <rt_can_control+0x1ce>

    case RT_DEVICE_CTRL_CONFIG:
        /* configure device */
        can->ops->configure(can, (struct can_configure *)args);
 801bfa0:	6a3b      	ldr	r3, [r7, #32]
 801bfa2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801bfa4:	681b      	ldr	r3, [r3, #0]
 801bfa6:	6a38      	ldr	r0, [r7, #32]
 801bfa8:	6879      	ldr	r1, [r7, #4]
 801bfaa:	4798      	blx	r3
        break;
 801bfac:	e085      	b.n	801c0ba <rt_can_control+0x1ce>
    case RT_CAN_CMD_SET_PRIV:
        /* configure device */
        if ((rt_uint32_t)args != can->config.privmode)
 801bfae:	687b      	ldr	r3, [r7, #4]
 801bfb0:	6a3a      	ldr	r2, [r7, #32]
 801bfb2:	f892 2051 	ldrb.w	r2, [r2, #81]	; 0x51
 801bfb6:	4293      	cmp	r3, r2
 801bfb8:	d064      	beq.n	801c084 <rt_can_control+0x198>
        {
            int i;
            rt_base_t level;
            struct rt_can_tx_fifo *tx_fifo;

            res = can->ops->control(can, cmd, args);
 801bfba:	6a3b      	ldr	r3, [r7, #32]
 801bfbc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801bfbe:	685b      	ldr	r3, [r3, #4]
 801bfc0:	7afa      	ldrb	r2, [r7, #11]
 801bfc2:	6a38      	ldr	r0, [r7, #32]
 801bfc4:	4611      	mov	r1, r2
 801bfc6:	687a      	ldr	r2, [r7, #4]
 801bfc8:	4798      	blx	r3
 801bfca:	61f8      	str	r0, [r7, #28]
            if (res != RT_EOK) return res;
 801bfcc:	69fb      	ldr	r3, [r7, #28]
 801bfce:	2b00      	cmp	r3, #0
 801bfd0:	d001      	beq.n	801bfd6 <rt_can_control+0xea>
 801bfd2:	69fb      	ldr	r3, [r7, #28]
 801bfd4:	e072      	b.n	801c0bc <rt_can_control+0x1d0>

            tx_fifo = (struct rt_can_tx_fifo *) can->can_tx;
 801bfd6:	6a3b      	ldr	r3, [r7, #32]
 801bfd8:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 801bfdc:	61bb      	str	r3, [r7, #24]
            if (can->config.privmode)
 801bfde:	6a3b      	ldr	r3, [r7, #32]
 801bfe0:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 801bfe4:	2b00      	cmp	r3, #0
 801bfe6:	d021      	beq.n	801c02c <rt_can_control+0x140>
            {
                rt_completion_done(&(tx_fifo->completion));
 801bfe8:	69bb      	ldr	r3, [r7, #24]
 801bfea:	3304      	adds	r3, #4
 801bfec:	4618      	mov	r0, r3
 801bfee:	f7fd fed7 	bl	8019da0 <rt_completion_done>

                for (i = 0;  i < can->config.sndboxnumber; i++)
 801bff2:	2300      	movs	r3, #0
 801bff4:	627b      	str	r3, [r7, #36]	; 0x24
 801bff6:	e013      	b.n	801c020 <rt_can_control+0x134>
                {
		    level = rt_hw_interrupt_disable();
 801bff8:	f7e4 f8e6 	bl	80001c8 <rt_hw_interrupt_disable>
 801bffc:	6178      	str	r0, [r7, #20]
                    rt_list_remove(&tx_fifo->buffer[i].list);
 801bffe:	69bb      	ldr	r3, [r7, #24]
 801c000:	6819      	ldr	r1, [r3, #0]
 801c002:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801c004:	4613      	mov	r3, r2
 801c006:	005b      	lsls	r3, r3, #1
 801c008:	4413      	add	r3, r2
 801c00a:	00db      	lsls	r3, r3, #3
 801c00c:	440b      	add	r3, r1
 801c00e:	4618      	mov	r0, r3
 801c010:	f7ff fac8 	bl	801b5a4 <rt_list_remove>
                    rt_hw_interrupt_enable(level);
 801c014:	6978      	ldr	r0, [r7, #20]
 801c016:	f7e4 f8db 	bl	80001d0 <rt_hw_interrupt_enable>
            tx_fifo = (struct rt_can_tx_fifo *) can->can_tx;
            if (can->config.privmode)
            {
                rt_completion_done(&(tx_fifo->completion));

                for (i = 0;  i < can->config.sndboxnumber; i++)
 801c01a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c01c:	3301      	adds	r3, #1
 801c01e:	627b      	str	r3, [r7, #36]	; 0x24
 801c020:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801c022:	6a3b      	ldr	r3, [r7, #32]
 801c024:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801c026:	429a      	cmp	r2, r3
 801c028:	d3e6      	bcc.n	801bff8 <rt_can_control+0x10c>
 801c02a:	e029      	b.n	801c080 <rt_can_control+0x194>
                    rt_hw_interrupt_enable(level);
                }
            }
            else
            {
                for (i = 0;  i < can->config.sndboxnumber; i++)
 801c02c:	2300      	movs	r3, #0
 801c02e:	627b      	str	r3, [r7, #36]	; 0x24
 801c030:	e021      	b.n	801c076 <rt_can_control+0x18a>
                {
                    level = rt_hw_interrupt_disable();
 801c032:	f7e4 f8c9 	bl	80001c8 <rt_hw_interrupt_disable>
 801c036:	6178      	str	r0, [r7, #20]
                    if (tx_fifo->buffer[i].result == RT_CAN_SND_RESULT_OK)
 801c038:	69bb      	ldr	r3, [r7, #24]
 801c03a:	6819      	ldr	r1, [r3, #0]
 801c03c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801c03e:	4613      	mov	r3, r2
 801c040:	005b      	lsls	r3, r3, #1
 801c042:	4413      	add	r3, r2
 801c044:	00db      	lsls	r3, r3, #3
 801c046:	440b      	add	r3, r1
 801c048:	695b      	ldr	r3, [r3, #20]
 801c04a:	2b00      	cmp	r3, #0
 801c04c:	d10d      	bne.n	801c06a <rt_can_control+0x17e>
                    {
                        rt_list_insert_before(&tx_fifo->freelist, &tx_fifo->buffer[i].list);
 801c04e:	69bb      	ldr	r3, [r7, #24]
 801c050:	f103 0010 	add.w	r0, r3, #16
 801c054:	69bb      	ldr	r3, [r7, #24]
 801c056:	6819      	ldr	r1, [r3, #0]
 801c058:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801c05a:	4613      	mov	r3, r2
 801c05c:	005b      	lsls	r3, r3, #1
 801c05e:	4413      	add	r3, r2
 801c060:	00db      	lsls	r3, r3, #3
 801c062:	440b      	add	r3, r1
 801c064:	4619      	mov	r1, r3
 801c066:	f7ff fa85 	bl	801b574 <rt_list_insert_before>
                    }
                    rt_hw_interrupt_enable(level);
 801c06a:	6978      	ldr	r0, [r7, #20]
 801c06c:	f7e4 f8b0 	bl	80001d0 <rt_hw_interrupt_enable>
                    rt_hw_interrupt_enable(level);
                }
            }
            else
            {
                for (i = 0;  i < can->config.sndboxnumber; i++)
 801c070:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c072:	3301      	adds	r3, #1
 801c074:	627b      	str	r3, [r7, #36]	; 0x24
 801c076:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801c078:	6a3b      	ldr	r3, [r7, #32]
 801c07a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801c07c:	429a      	cmp	r2, r3
 801c07e:	d3d8      	bcc.n	801c032 <rt_can_control+0x146>
                        rt_list_insert_before(&tx_fifo->freelist, &tx_fifo->buffer[i].list);
                    }
                    rt_hw_interrupt_enable(level);
                }
            }
            return RT_EOK;
 801c080:	2300      	movs	r3, #0
 801c082:	e01b      	b.n	801c0bc <rt_can_control+0x1d0>
        }
        break;
 801c084:	e019      	b.n	801c0ba <rt_can_control+0x1ce>

    case RT_CAN_CMD_SET_STATUS_IND:
        can->status_indicate.ind = ((rt_can_status_ind_type_t)args)->ind;
 801c086:	687b      	ldr	r3, [r7, #4]
 801c088:	681a      	ldr	r2, [r3, #0]
 801c08a:	6a3b      	ldr	r3, [r7, #32]
 801c08c:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
        can->status_indicate.args = ((rt_can_status_ind_type_t)args)->args;
 801c090:	687b      	ldr	r3, [r7, #4]
 801c092:	685a      	ldr	r2, [r3, #4]
 801c094:	6a3b      	ldr	r3, [r7, #32]
 801c096:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
        break;
 801c09a:	e00e      	b.n	801c0ba <rt_can_control+0x1ce>
        can->bus_hook = (rt_can_bus_hook) args;
        break;
#endif /*RT_CAN_USING_BUS_HOOK*/
    default :
        /* control device */
        if (can->ops->control != RT_NULL)
 801c09c:	6a3b      	ldr	r3, [r7, #32]
 801c09e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801c0a0:	685b      	ldr	r3, [r3, #4]
 801c0a2:	2b00      	cmp	r3, #0
 801c0a4:	d008      	beq.n	801c0b8 <rt_can_control+0x1cc>
        {
            can->ops->control(can, cmd, args);
 801c0a6:	6a3b      	ldr	r3, [r7, #32]
 801c0a8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801c0aa:	685b      	ldr	r3, [r3, #4]
 801c0ac:	7afa      	ldrb	r2, [r7, #11]
 801c0ae:	6a38      	ldr	r0, [r7, #32]
 801c0b0:	4611      	mov	r1, r2
 801c0b2:	687a      	ldr	r2, [r7, #4]
 801c0b4:	4798      	blx	r3
        }
        break;
 801c0b6:	e7ff      	b.n	801c0b8 <rt_can_control+0x1cc>
 801c0b8:	bf00      	nop
    }

    return RT_EOK;
 801c0ba:	2300      	movs	r3, #0
}
 801c0bc:	4618      	mov	r0, r3
 801c0be:	3728      	adds	r7, #40	; 0x28
 801c0c0:	46bd      	mov	sp, r7
 801c0c2:	bd80      	pop	{r7, pc}
 801c0c4:	08027fdc 	.word	0x08027fdc
 801c0c8:	08029670 	.word	0x08029670

0801c0cc <cantimeout>:

/*
 * can timer
 */
static void cantimeout(void *arg)
{
 801c0cc:	b580      	push	{r7, lr}
 801c0ce:	b084      	sub	sp, #16
 801c0d0:	af00      	add	r7, sp, #0
 801c0d2:	6078      	str	r0, [r7, #4]
    rt_can_t can = (rt_can_t)arg;
 801c0d4:	687b      	ldr	r3, [r7, #4]
 801c0d6:	60fb      	str	r3, [r7, #12]

    rt_device_control((rt_device_t)can, RT_CAN_CMD_GET_STATUS, (void *)&can->status);
 801c0d8:	68fb      	ldr	r3, [r7, #12]
 801c0da:	3358      	adds	r3, #88	; 0x58
 801c0dc:	68f8      	ldr	r0, [r7, #12]
 801c0de:	2117      	movs	r1, #23
 801c0e0:	461a      	mov	r2, r3
 801c0e2:	f7f9 feb3 	bl	8015e4c <rt_device_control>

    if (can->status_indicate.ind != RT_NULL)
 801c0e6:	68fb      	ldr	r3, [r7, #12]
 801c0e8:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 801c0ec:	2b00      	cmp	r3, #0
 801c0ee:	d008      	beq.n	801c102 <cantimeout+0x36>
    {
        can->status_indicate.ind(can, can->status_indicate.args);
 801c0f0:	68fb      	ldr	r3, [r7, #12]
 801c0f2:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 801c0f6:	68fa      	ldr	r2, [r7, #12]
 801c0f8:	f8d2 20c8 	ldr.w	r2, [r2, #200]	; 0xc8
 801c0fc:	68f8      	ldr	r0, [r7, #12]
 801c0fe:	4611      	mov	r1, r2
 801c100:	4798      	blx	r3
    if(can->bus_hook)
    {
        can->bus_hook(can);
    }
#endif /*RT_CAN_USING_BUS_HOOK*/
    if (can->timerinitflag == 1)
 801c102:	68fb      	ldr	r3, [r7, #12]
 801c104:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 801c108:	2b01      	cmp	r3, #1
 801c10a:	d103      	bne.n	801c114 <cantimeout+0x48>
    {
        can->timerinitflag = 0xFF;
 801c10c:	68fb      	ldr	r3, [r7, #12]
 801c10e:	22ff      	movs	r2, #255	; 0xff
 801c110:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    }
}
 801c114:	3710      	adds	r7, #16
 801c116:	46bd      	mov	sp, r7
 801c118:	bd80      	pop	{r7, pc}
 801c11a:	bf00      	nop

0801c11c <rt_hw_can_register>:
 */
rt_err_t rt_hw_can_register(struct rt_can_device *can,
                            const char              *name,
                            const struct rt_can_ops *ops,
                            void                    *data)
{
 801c11c:	b580      	push	{r7, lr}
 801c11e:	b088      	sub	sp, #32
 801c120:	af02      	add	r7, sp, #8
 801c122:	60f8      	str	r0, [r7, #12]
 801c124:	60b9      	str	r1, [r7, #8]
 801c126:	607a      	str	r2, [r7, #4]
 801c128:	603b      	str	r3, [r7, #0]
    struct rt_device *device;
    RT_ASSERT(can != RT_NULL);
 801c12a:	68fb      	ldr	r3, [r7, #12]
 801c12c:	2b00      	cmp	r3, #0
 801c12e:	d105      	bne.n	801c13c <rt_hw_can_register+0x20>
 801c130:	4831      	ldr	r0, [pc, #196]	; (801c1f8 <rt_hw_can_register+0xdc>)
 801c132:	4932      	ldr	r1, [pc, #200]	; (801c1fc <rt_hw_can_register+0xe0>)
 801c134:	f240 22c3 	movw	r2, #707	; 0x2c3
 801c138:	f7fb fc3a 	bl	80179b0 <rt_assert_handler>

    device = &(can->parent);
 801c13c:	68fb      	ldr	r3, [r7, #12]
 801c13e:	617b      	str	r3, [r7, #20]

    device->type        = RT_Device_Class_CAN;
 801c140:	697b      	ldr	r3, [r7, #20]
 801c142:	2204      	movs	r2, #4
 801c144:	751a      	strb	r2, [r3, #20]
    device->rx_indicate = RT_NULL;
 801c146:	697b      	ldr	r3, [r7, #20]
 801c148:	2200      	movs	r2, #0
 801c14a:	61da      	str	r2, [r3, #28]
    device->tx_complete = RT_NULL;
 801c14c:	697b      	ldr	r3, [r7, #20]
 801c14e:	2200      	movs	r2, #0
 801c150:	621a      	str	r2, [r3, #32]
#ifdef RT_CAN_USING_HDR
    can->hdr            = RT_NULL;
#endif
    can->can_rx         = RT_NULL;
 801c152:	68fb      	ldr	r3, [r7, #12]
 801c154:	2200      	movs	r2, #0
 801c156:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
    can->can_tx         = RT_NULL;
 801c15a:	68fb      	ldr	r3, [r7, #12]
 801c15c:	2200      	movs	r2, #0
 801c15e:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
    rt_mutex_init(&(can->lock), "can", RT_IPC_FLAG_PRIO);
 801c162:	68fb      	ldr	r3, [r7, #12]
 801c164:	33cc      	adds	r3, #204	; 0xcc
 801c166:	4618      	mov	r0, r3
 801c168:	4925      	ldr	r1, [pc, #148]	; (801c200 <rt_hw_can_register+0xe4>)
 801c16a:	2201      	movs	r2, #1
 801c16c:	f7fa f96a 	bl	8016444 <rt_mutex_init>
#ifdef RT_CAN_USING_BUS_HOOK
    can->bus_hook       = RT_NULL;
#endif /*RT_CAN_USING_BUS_HOOK*/
    device->init        = rt_can_init;
 801c170:	697b      	ldr	r3, [r7, #20]
 801c172:	4a24      	ldr	r2, [pc, #144]	; (801c204 <rt_hw_can_register+0xe8>)
 801c174:	625a      	str	r2, [r3, #36]	; 0x24
    device->open        = rt_can_open;
 801c176:	697b      	ldr	r3, [r7, #20]
 801c178:	4a23      	ldr	r2, [pc, #140]	; (801c208 <rt_hw_can_register+0xec>)
 801c17a:	629a      	str	r2, [r3, #40]	; 0x28
    device->close       = rt_can_close;
 801c17c:	697b      	ldr	r3, [r7, #20]
 801c17e:	4a23      	ldr	r2, [pc, #140]	; (801c20c <rt_hw_can_register+0xf0>)
 801c180:	62da      	str	r2, [r3, #44]	; 0x2c
    device->read        = rt_can_read;
 801c182:	697b      	ldr	r3, [r7, #20]
 801c184:	4a22      	ldr	r2, [pc, #136]	; (801c210 <rt_hw_can_register+0xf4>)
 801c186:	631a      	str	r2, [r3, #48]	; 0x30
    device->write       = rt_can_write;
 801c188:	697b      	ldr	r3, [r7, #20]
 801c18a:	4a22      	ldr	r2, [pc, #136]	; (801c214 <rt_hw_can_register+0xf8>)
 801c18c:	635a      	str	r2, [r3, #52]	; 0x34
    device->control     = rt_can_control;
 801c18e:	697b      	ldr	r3, [r7, #20]
 801c190:	4a21      	ldr	r2, [pc, #132]	; (801c218 <rt_hw_can_register+0xfc>)
 801c192:	639a      	str	r2, [r3, #56]	; 0x38
    can->ops            = ops;
 801c194:	68fb      	ldr	r3, [r7, #12]
 801c196:	687a      	ldr	r2, [r7, #4]
 801c198:	641a      	str	r2, [r3, #64]	; 0x40

    can->status_indicate.ind  = RT_NULL;
 801c19a:	68fb      	ldr	r3, [r7, #12]
 801c19c:	2200      	movs	r2, #0
 801c19e:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
    can->status_indicate.args = RT_NULL;
 801c1a2:	68fb      	ldr	r3, [r7, #12]
 801c1a4:	2200      	movs	r2, #0
 801c1a6:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    rt_memset(&can->status, 0, sizeof(can->status));
 801c1aa:	68fb      	ldr	r3, [r7, #12]
 801c1ac:	3358      	adds	r3, #88	; 0x58
 801c1ae:	4618      	mov	r0, r3
 801c1b0:	2100      	movs	r1, #0
 801c1b2:	223c      	movs	r2, #60	; 0x3c
 801c1b4:	f7fa fdca 	bl	8016d4c <rt_memset>

    device->user_data   = data;
 801c1b8:	697b      	ldr	r3, [r7, #20]
 801c1ba:	683a      	ldr	r2, [r7, #0]
 801c1bc:	63da      	str	r2, [r3, #60]	; 0x3c

    can->timerinitflag  = 0;
 801c1be:	68fb      	ldr	r3, [r7, #12]
 801c1c0:	2200      	movs	r2, #0
 801c1c2:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    rt_timer_init(&can->timer,
 801c1c6:	68fb      	ldr	r3, [r7, #12]
 801c1c8:	f103 0298 	add.w	r2, r3, #152	; 0x98
 801c1cc:	68fb      	ldr	r3, [r7, #12]
 801c1ce:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801c1d0:	9300      	str	r3, [sp, #0]
 801c1d2:	2302      	movs	r3, #2
 801c1d4:	9301      	str	r3, [sp, #4]
 801c1d6:	4610      	mov	r0, r2
 801c1d8:	68b9      	ldr	r1, [r7, #8]
 801c1da:	4a10      	ldr	r2, [pc, #64]	; (801c21c <rt_hw_can_register+0x100>)
 801c1dc:	68fb      	ldr	r3, [r7, #12]
 801c1de:	f7fc ffcb 	bl	8019178 <rt_timer_init>
                  cantimeout,
                  (void *)can,
                  can->config.ticks,
                  RT_TIMER_FLAG_PERIODIC);
    /* register a character device */
    return rt_device_register(device, name, RT_DEVICE_FLAG_RDWR);
 801c1e2:	6978      	ldr	r0, [r7, #20]
 801c1e4:	68b9      	ldr	r1, [r7, #8]
 801c1e6:	2203      	movs	r2, #3
 801c1e8:	f7f9 fcb2 	bl	8015b50 <rt_device_register>
 801c1ec:	4603      	mov	r3, r0
}
 801c1ee:	4618      	mov	r0, r3
 801c1f0:	3718      	adds	r7, #24
 801c1f2:	46bd      	mov	sp, r7
 801c1f4:	bd80      	pop	{r7, pc}
 801c1f6:	bf00      	nop
 801c1f8:	08027fec 	.word	0x08027fec
 801c1fc:	08029680 	.word	0x08029680
 801c200:	08028068 	.word	0x08028068
 801c204:	0801b5fd 	.word	0x0801b5fd
 801c208:	0801ba5d 	.word	0x0801ba5d
 801c20c:	0801bcc5 	.word	0x0801bcc5
 801c210:	0801bdfd 	.word	0x0801bdfd
 801c214:	0801be61 	.word	0x0801be61
 801c218:	0801beed 	.word	0x0801beed
 801c21c:	0801c0cd 	.word	0x0801c0cd

0801c220 <cmd_canstat>:
}

#ifdef RT_USING_FINSH
#include <finsh.h>
int cmd_canstat(int argc, void **argv)
{
 801c220:	b580      	push	{r7, lr}
 801c222:	b092      	sub	sp, #72	; 0x48
 801c224:	af00      	add	r7, sp, #0
 801c226:	6078      	str	r0, [r7, #4]
 801c228:	6039      	str	r1, [r7, #0]
        "Warning !",
        "Passive !",
        "Bus Off !"
    };

    if (argc >= 2)
 801c22a:	687b      	ldr	r3, [r7, #4]
 801c22c:	2b01      	cmp	r3, #1
 801c22e:	f340 8082 	ble.w	801c336 <cmd_canstat+0x116>
    {
        struct rt_can_status status;
        rt_device_t candev = rt_device_find(argv[1]);
 801c232:	683b      	ldr	r3, [r7, #0]
 801c234:	3304      	adds	r3, #4
 801c236:	681b      	ldr	r3, [r3, #0]
 801c238:	4618      	mov	r0, r3
 801c23a:	f7f9 fcb1 	bl	8015ba0 <rt_device_find>
 801c23e:	6478      	str	r0, [r7, #68]	; 0x44
        if (!candev)
 801c240:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c242:	2b00      	cmp	r3, #0
 801c244:	d109      	bne.n	801c25a <cmd_canstat+0x3a>
        {
            rt_kprintf(" Can't find can device %s\n", argv[1]);
 801c246:	683b      	ldr	r3, [r7, #0]
 801c248:	3304      	adds	r3, #4
 801c24a:	681b      	ldr	r3, [r3, #0]
 801c24c:	4842      	ldr	r0, [pc, #264]	; (801c358 <cmd_canstat+0x138>)
 801c24e:	4619      	mov	r1, r3
 801c250:	f7fb fb34 	bl	80178bc <rt_kprintf>
            return -1;
 801c254:	f04f 33ff 	mov.w	r3, #4294967295
 801c258:	e07a      	b.n	801c350 <cmd_canstat+0x130>
        }
        rt_kprintf(" Finded can device: %s...", argv[1]);
 801c25a:	683b      	ldr	r3, [r7, #0]
 801c25c:	3304      	adds	r3, #4
 801c25e:	681b      	ldr	r3, [r3, #0]
 801c260:	483e      	ldr	r0, [pc, #248]	; (801c35c <cmd_canstat+0x13c>)
 801c262:	4619      	mov	r1, r3
 801c264:	f7fb fb2a 	bl	80178bc <rt_kprintf>

        rt_device_control(candev, RT_CAN_CMD_GET_STATUS, &status);
 801c268:	f107 0308 	add.w	r3, r7, #8
 801c26c:	6c78      	ldr	r0, [r7, #68]	; 0x44
 801c26e:	2117      	movs	r1, #23
 801c270:	461a      	mov	r2, r3
 801c272:	f7f9 fdeb 	bl	8015e4c <rt_device_control>
        rt_kprintf("\n Receive...error..count: %010ld. Send.....error....count: %010ld.",
 801c276:	68ba      	ldr	r2, [r7, #8]
 801c278:	68fb      	ldr	r3, [r7, #12]
 801c27a:	4839      	ldr	r0, [pc, #228]	; (801c360 <cmd_canstat+0x140>)
 801c27c:	4611      	mov	r1, r2
 801c27e:	461a      	mov	r2, r3
 801c280:	f7fb fb1c 	bl	80178bc <rt_kprintf>
                   status.rcverrcnt, status.snderrcnt);
        rt_kprintf("\n Bit..pad..error..count: %010ld. Format...error....count: %010ld",
 801c284:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801c286:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c288:	4836      	ldr	r0, [pc, #216]	; (801c364 <cmd_canstat+0x144>)
 801c28a:	4611      	mov	r1, r2
 801c28c:	461a      	mov	r2, r3
 801c28e:	f7fb fb15 	bl	80178bc <rt_kprintf>
                   status.bitpaderrcnt, status.formaterrcnt);
        rt_kprintf("\n Ack.......error..count: %010ld. Bit......error....count: %010ld.",
 801c292:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801c294:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c296:	4834      	ldr	r0, [pc, #208]	; (801c368 <cmd_canstat+0x148>)
 801c298:	4611      	mov	r1, r2
 801c29a:	461a      	mov	r2, r3
 801c29c:	f7fb fb0e 	bl	80178bc <rt_kprintf>
                   status.ackerrcnt, status.biterrcnt);
        rt_kprintf("\n CRC.......error..count: %010ld. Error.code.[%010ld]: ",
 801c2a0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801c2a2:	693b      	ldr	r3, [r7, #16]
 801c2a4:	4831      	ldr	r0, [pc, #196]	; (801c36c <cmd_canstat+0x14c>)
 801c2a6:	4611      	mov	r1, r2
 801c2a8:	461a      	mov	r2, r3
 801c2aa:	f7fb fb07 	bl	80178bc <rt_kprintf>
                   status.crcerrcnt, status.errcode);
        switch (status.errcode)
 801c2ae:	693b      	ldr	r3, [r7, #16]
 801c2b0:	2b07      	cmp	r3, #7
 801c2b2:	d82f      	bhi.n	801c314 <cmd_canstat+0xf4>
 801c2b4:	a201      	add	r2, pc, #4	; (adr r2, 801c2bc <cmd_canstat+0x9c>)
 801c2b6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801c2ba:	bf00      	nop
 801c2bc:	0801c2dd 	.word	0x0801c2dd
 801c2c0:	0801c2eb 	.word	0x0801c2eb
 801c2c4:	0801c2f9 	.word	0x0801c2f9
 801c2c8:	0801c2f9 	.word	0x0801c2f9
 801c2cc:	0801c307 	.word	0x0801c307
 801c2d0:	0801c307 	.word	0x0801c307
 801c2d4:	0801c307 	.word	0x0801c307
 801c2d8:	0801c307 	.word	0x0801c307
        {
        case 0:
            rt_kprintf("%s.", ErrCode[0]);
 801c2dc:	4b24      	ldr	r3, [pc, #144]	; (801c370 <cmd_canstat+0x150>)
 801c2de:	681b      	ldr	r3, [r3, #0]
 801c2e0:	4824      	ldr	r0, [pc, #144]	; (801c374 <cmd_canstat+0x154>)
 801c2e2:	4619      	mov	r1, r3
 801c2e4:	f7fb faea 	bl	80178bc <rt_kprintf>
            break;
 801c2e8:	e014      	b.n	801c314 <cmd_canstat+0xf4>
        case 1:
            rt_kprintf("%s.", ErrCode[1]);
 801c2ea:	4b21      	ldr	r3, [pc, #132]	; (801c370 <cmd_canstat+0x150>)
 801c2ec:	685b      	ldr	r3, [r3, #4]
 801c2ee:	4821      	ldr	r0, [pc, #132]	; (801c374 <cmd_canstat+0x154>)
 801c2f0:	4619      	mov	r1, r3
 801c2f2:	f7fb fae3 	bl	80178bc <rt_kprintf>
            break;
 801c2f6:	e00d      	b.n	801c314 <cmd_canstat+0xf4>
        case 2:
        case 3:
            rt_kprintf("%s.", ErrCode[2]);
 801c2f8:	4b1d      	ldr	r3, [pc, #116]	; (801c370 <cmd_canstat+0x150>)
 801c2fa:	689b      	ldr	r3, [r3, #8]
 801c2fc:	481d      	ldr	r0, [pc, #116]	; (801c374 <cmd_canstat+0x154>)
 801c2fe:	4619      	mov	r1, r3
 801c300:	f7fb fadc 	bl	80178bc <rt_kprintf>
            break;
 801c304:	e006      	b.n	801c314 <cmd_canstat+0xf4>
        case 4:
        case 5:
        case 6:
        case 7:
            rt_kprintf("%s.", ErrCode[3]);
 801c306:	4b1a      	ldr	r3, [pc, #104]	; (801c370 <cmd_canstat+0x150>)
 801c308:	68db      	ldr	r3, [r3, #12]
 801c30a:	481a      	ldr	r0, [pc, #104]	; (801c374 <cmd_canstat+0x154>)
 801c30c:	4619      	mov	r1, r3
 801c30e:	f7fb fad5 	bl	80178bc <rt_kprintf>
            break;
 801c312:	bf00      	nop
        }
        rt_kprintf("\n Total.receive.packages: %010ld. Droped.receive.packages: %010ld.",
 801c314:	697a      	ldr	r2, [r7, #20]
 801c316:	69bb      	ldr	r3, [r7, #24]
 801c318:	4817      	ldr	r0, [pc, #92]	; (801c378 <cmd_canstat+0x158>)
 801c31a:	4611      	mov	r1, r2
 801c31c:	461a      	mov	r2, r3
 801c31e:	f7fb facd 	bl	80178bc <rt_kprintf>
                   status.rcvpkg, status.dropedrcvpkg);
        rt_kprintf("\n Total..send...packages: %010ld. Droped...send..packages: %010ld.\n",
                   status.sndpkg + status.dropedsndpkg, status.dropedsndpkg);
 801c322:	69fa      	ldr	r2, [r7, #28]
 801c324:	6a3b      	ldr	r3, [r7, #32]
            rt_kprintf("%s.", ErrCode[3]);
            break;
        }
        rt_kprintf("\n Total.receive.packages: %010ld. Droped.receive.packages: %010ld.",
                   status.rcvpkg, status.dropedrcvpkg);
        rt_kprintf("\n Total..send...packages: %010ld. Droped...send..packages: %010ld.\n",
 801c326:	441a      	add	r2, r3
 801c328:	6a3b      	ldr	r3, [r7, #32]
 801c32a:	4814      	ldr	r0, [pc, #80]	; (801c37c <cmd_canstat+0x15c>)
 801c32c:	4611      	mov	r1, r2
 801c32e:	461a      	mov	r2, r3
 801c330:	f7fb fac4 	bl	80178bc <rt_kprintf>
 801c334:	e00b      	b.n	801c34e <cmd_canstat+0x12e>
                   status.sndpkg + status.dropedsndpkg, status.dropedsndpkg);
    }
    else
    {
        rt_kprintf(" Invalid Call %s\n", argv[0]);
 801c336:	683b      	ldr	r3, [r7, #0]
 801c338:	681b      	ldr	r3, [r3, #0]
 801c33a:	4811      	ldr	r0, [pc, #68]	; (801c380 <cmd_canstat+0x160>)
 801c33c:	4619      	mov	r1, r3
 801c33e:	f7fb fabd 	bl	80178bc <rt_kprintf>
        rt_kprintf(" Please using %s cannamex .Here canname is driver name and x is candrive number.\n", argv[0]);
 801c342:	683b      	ldr	r3, [r7, #0]
 801c344:	681b      	ldr	r3, [r3, #0]
 801c346:	480f      	ldr	r0, [pc, #60]	; (801c384 <cmd_canstat+0x164>)
 801c348:	4619      	mov	r1, r3
 801c34a:	f7fb fab7 	bl	80178bc <rt_kprintf>
    }
    return 0;
 801c34e:	2300      	movs	r3, #0
}
 801c350:	4618      	mov	r0, r3
 801c352:	3748      	adds	r7, #72	; 0x48
 801c354:	46bd      	mov	sp, r7
 801c356:	bd80      	pop	{r7, pc}
 801c358:	080280b8 	.word	0x080280b8
 801c35c:	080280d4 	.word	0x080280d4
 801c360:	080280f0 	.word	0x080280f0
 801c364:	08028134 	.word	0x08028134
 801c368:	08028178 	.word	0x08028178
 801c36c:	080281bc 	.word	0x080281bc
 801c370:	200100bc 	.word	0x200100bc
 801c374:	080281f4 	.word	0x080281f4
 801c378:	080281f8 	.word	0x080281f8
 801c37c:	0802823c 	.word	0x0802823c
 801c380:	08028280 	.word	0x08028280
 801c384:	08028294 	.word	0x08028294

0801c388 <finsh_get_prompt>:
#if defined(FINSH_USING_MSH) || (defined(RT_USING_DFS) && defined(DFS_USING_WORKDIR))
#if defined(RT_USING_DFS)
#include <dfs_posix.h>
#endif
const char *finsh_get_prompt()
{
 801c388:	b580      	push	{r7, lr}
 801c38a:	af00      	add	r7, sp, #0
#define _MSH_PROMPT "msh "
#define _PROMPT     "finsh "
    static char finsh_prompt[RT_CONSOLEBUF_SIZE + 1] = {0};

#ifdef FINSH_USING_MSH
    if (msh_is_used()) strcpy(finsh_prompt, _MSH_PROMPT);
 801c38c:	f001 fb78 	bl	801da80 <msh_is_used>
 801c390:	4603      	mov	r3, r0
 801c392:	2b00      	cmp	r3, #0
 801c394:	d007      	beq.n	801c3a6 <finsh_get_prompt+0x1e>
 801c396:	4b10      	ldr	r3, [pc, #64]	; (801c3d8 <finsh_get_prompt+0x50>)
 801c398:	4a10      	ldr	r2, [pc, #64]	; (801c3dc <finsh_get_prompt+0x54>)
 801c39a:	e892 0003 	ldmia.w	r2, {r0, r1}
 801c39e:	6018      	str	r0, [r3, #0]
 801c3a0:	3304      	adds	r3, #4
 801c3a2:	7019      	strb	r1, [r3, #0]
 801c3a4:	e009      	b.n	801c3ba <finsh_get_prompt+0x32>
    else
#endif
        strcpy(finsh_prompt, _PROMPT);
 801c3a6:	4b0c      	ldr	r3, [pc, #48]	; (801c3d8 <finsh_get_prompt+0x50>)
 801c3a8:	4a0d      	ldr	r2, [pc, #52]	; (801c3e0 <finsh_get_prompt+0x58>)
 801c3aa:	e892 0003 	ldmia.w	r2, {r0, r1}
 801c3ae:	6018      	str	r0, [r3, #0]
 801c3b0:	3304      	adds	r3, #4
 801c3b2:	8019      	strh	r1, [r3, #0]
 801c3b4:	3302      	adds	r3, #2
 801c3b6:	0c0a      	lsrs	r2, r1, #16
 801c3b8:	701a      	strb	r2, [r3, #0]
#if defined(RT_USING_DFS) && defined(DFS_USING_WORKDIR)
    /* get current working directory */
    getcwd(&finsh_prompt[rt_strlen(finsh_prompt)], RT_CONSOLEBUF_SIZE - rt_strlen(finsh_prompt));
#endif

    strcat(finsh_prompt, ">");
 801c3ba:	4807      	ldr	r0, [pc, #28]	; (801c3d8 <finsh_get_prompt+0x50>)
 801c3bc:	f007 f972 	bl	80236a4 <strlen>
 801c3c0:	4603      	mov	r3, r0
 801c3c2:	461a      	mov	r2, r3
 801c3c4:	4b04      	ldr	r3, [pc, #16]	; (801c3d8 <finsh_get_prompt+0x50>)
 801c3c6:	4413      	add	r3, r2
 801c3c8:	4906      	ldr	r1, [pc, #24]	; (801c3e4 <finsh_get_prompt+0x5c>)
 801c3ca:	461a      	mov	r2, r3
 801c3cc:	460b      	mov	r3, r1
 801c3ce:	881b      	ldrh	r3, [r3, #0]
 801c3d0:	8013      	strh	r3, [r2, #0]

    return finsh_prompt;
 801c3d2:	4b01      	ldr	r3, [pc, #4]	; (801c3d8 <finsh_get_prompt+0x50>)
}
 801c3d4:	4618      	mov	r0, r3
 801c3d6:	bd80      	pop	{r7, pc}
 801c3d8:	20012108 	.word	0x20012108
 801c3dc:	08028318 	.word	0x08028318
 801c3e0:	08028320 	.word	0x08028320
 801c3e4:	08028328 	.word	0x08028328

0801c3e8 <finsh_rx_ind>:
#endif

static rt_err_t finsh_rx_ind(rt_device_t dev, rt_size_t size)
{
 801c3e8:	b580      	push	{r7, lr}
 801c3ea:	b082      	sub	sp, #8
 801c3ec:	af00      	add	r7, sp, #0
 801c3ee:	6078      	str	r0, [r7, #4]
 801c3f0:	6039      	str	r1, [r7, #0]
    RT_ASSERT(shell != RT_NULL);
 801c3f2:	4b09      	ldr	r3, [pc, #36]	; (801c418 <finsh_rx_ind+0x30>)
 801c3f4:	681b      	ldr	r3, [r3, #0]
 801c3f6:	2b00      	cmp	r3, #0
 801c3f8:	d104      	bne.n	801c404 <finsh_rx_ind+0x1c>
 801c3fa:	4808      	ldr	r0, [pc, #32]	; (801c41c <finsh_rx_ind+0x34>)
 801c3fc:	4908      	ldr	r1, [pc, #32]	; (801c420 <finsh_rx_ind+0x38>)
 801c3fe:	2256      	movs	r2, #86	; 0x56
 801c400:	f7fb fad6 	bl	80179b0 <rt_assert_handler>

    /* release semaphore to let finsh thread rx data */
    rt_sem_release(&shell->rx_sem);
 801c404:	4b04      	ldr	r3, [pc, #16]	; (801c418 <finsh_rx_ind+0x30>)
 801c406:	681b      	ldr	r3, [r3, #0]
 801c408:	4618      	mov	r0, r3
 801c40a:	f7f9 ffe7 	bl	80163dc <rt_sem_release>

    return RT_EOK;
 801c40e:	2300      	movs	r3, #0
}
 801c410:	4618      	mov	r0, r3
 801c412:	3708      	adds	r7, #8
 801c414:	46bd      	mov	sp, r7
 801c416:	bd80      	pop	{r7, pc}
 801c418:	20012bb4 	.word	0x20012bb4
 801c41c:	0802832c 	.word	0x0802832c
 801c420:	08029694 	.word	0x08029694

0801c424 <shell_auto_complete>:

    return shell->echo_mode;
}

static void shell_auto_complete(char *prefix)
{
 801c424:	b580      	push	{r7, lr}
 801c426:	b082      	sub	sp, #8
 801c428:	af00      	add	r7, sp, #0
 801c42a:	6078      	str	r0, [r7, #4]

    rt_kprintf("\n");
 801c42c:	480c      	ldr	r0, [pc, #48]	; (801c460 <shell_auto_complete+0x3c>)
 801c42e:	f7fb fa45 	bl	80178bc <rt_kprintf>
#ifdef FINSH_USING_MSH
    if (msh_is_used() == RT_TRUE)
 801c432:	f001 fb25 	bl	801da80 <msh_is_used>
 801c436:	4603      	mov	r3, r0
 801c438:	2b01      	cmp	r3, #1
 801c43a:	d103      	bne.n	801c444 <shell_auto_complete+0x20>
    {
        msh_auto_complete(prefix);
 801c43c:	6878      	ldr	r0, [r7, #4]
 801c43e:	f001 fd31 	bl	801dea4 <msh_auto_complete>
 801c442:	e002      	b.n	801c44a <shell_auto_complete+0x26>
    else
#endif
    {
#ifndef FINSH_USING_MSH_ONLY
        extern void list_prefix(char * prefix);
        list_prefix(prefix);
 801c444:	6878      	ldr	r0, [r7, #4]
 801c446:	f001 f9ad 	bl	801d7a4 <list_prefix>
#endif
    }

    rt_kprintf("%s%s", FINSH_PROMPT, prefix);
 801c44a:	f7ff ff9d 	bl	801c388 <finsh_get_prompt>
 801c44e:	4603      	mov	r3, r0
 801c450:	4804      	ldr	r0, [pc, #16]	; (801c464 <shell_auto_complete+0x40>)
 801c452:	4619      	mov	r1, r3
 801c454:	687a      	ldr	r2, [r7, #4]
 801c456:	f7fb fa31 	bl	80178bc <rt_kprintf>
}
 801c45a:	3708      	adds	r7, #8
 801c45c:	46bd      	mov	sp, r7
 801c45e:	bd80      	pop	{r7, pc}
 801c460:	08028360 	.word	0x08028360
 801c464:	08028364 	.word	0x08028364

0801c468 <finsh_run_line>:

#ifndef FINSH_USING_MSH_ONLY
void finsh_run_line(struct finsh_parser *parser, const char *line)
{
 801c468:	b5b0      	push	{r4, r5, r7, lr}
 801c46a:	b084      	sub	sp, #16
 801c46c:	af00      	add	r7, sp, #0
 801c46e:	6078      	str	r0, [r7, #4]
 801c470:	6039      	str	r1, [r7, #0]
    const char *err_str;

    rt_kprintf("\n");
 801c472:	4829      	ldr	r0, [pc, #164]	; (801c518 <finsh_run_line+0xb0>)
 801c474:	f7fb fa22 	bl	80178bc <rt_kprintf>
    finsh_parser_run(parser, (unsigned char *)line);
 801c478:	6878      	ldr	r0, [r7, #4]
 801c47a:	6839      	ldr	r1, [r7, #0]
 801c47c:	f005 fbce 	bl	8021c1c <finsh_parser_run>

    /* compile node root */
    if (finsh_errno() == 0)
 801c480:	f003 fad4 	bl	801fa2c <finsh_errno>
 801c484:	4603      	mov	r3, r0
 801c486:	2b00      	cmp	r3, #0
 801c488:	d106      	bne.n	801c498 <finsh_run_line+0x30>
    {
        finsh_compiler_run(parser->root);
 801c48a:	687b      	ldr	r3, [r7, #4]
 801c48c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 801c490:	4618      	mov	r0, r3
 801c492:	f003 fa69 	bl	801f968 <finsh_compiler_run>
 801c496:	e00a      	b.n	801c4ae <finsh_run_line+0x46>
    }
    else
    {
        err_str = finsh_error_string(finsh_errno());
 801c498:	f003 fac8 	bl	801fa2c <finsh_errno>
 801c49c:	4603      	mov	r3, r0
 801c49e:	4618      	mov	r0, r3
 801c4a0:	f003 fad0 	bl	801fa44 <finsh_error_string>
 801c4a4:	60f8      	str	r0, [r7, #12]
        rt_kprintf("%s\n", err_str);
 801c4a6:	481d      	ldr	r0, [pc, #116]	; (801c51c <finsh_run_line+0xb4>)
 801c4a8:	68f9      	ldr	r1, [r7, #12]
 801c4aa:	f7fb fa07 	bl	80178bc <rt_kprintf>
    }

    /* run virtual machine */
    if (finsh_errno() == 0)
 801c4ae:	f003 fabd 	bl	801fa2c <finsh_errno>
 801c4b2:	4603      	mov	r3, r0
 801c4b4:	2b00      	cmp	r3, #0
 801c4b6:	d129      	bne.n	801c50c <finsh_run_line+0xa4>
    {
        char ch;
        finsh_vm_run();
 801c4b8:	f005 fd44 	bl	8021f44 <finsh_vm_run>

        ch = (unsigned char)finsh_stack_bottom();
 801c4bc:	f003 fcb8 	bl	801fe30 <finsh_stack_bottom>
 801c4c0:	4603      	mov	r3, r0
 801c4c2:	72fb      	strb	r3, [r7, #11]
        if (ch > 0x20 && ch < 0x7e)
 801c4c4:	7afb      	ldrb	r3, [r7, #11]
 801c4c6:	2b20      	cmp	r3, #32
 801c4c8:	d914      	bls.n	801c4f4 <finsh_run_line+0x8c>
 801c4ca:	7afb      	ldrb	r3, [r7, #11]
 801c4cc:	2b7d      	cmp	r3, #125	; 0x7d
 801c4ce:	d811      	bhi.n	801c4f4 <finsh_run_line+0x8c>
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
                       (unsigned char)finsh_stack_bottom(),
 801c4d0:	f003 fcae 	bl	801fe30 <finsh_stack_bottom>
 801c4d4:	4603      	mov	r3, r0
 801c4d6:	b2db      	uxtb	r3, r3
        finsh_vm_run();

        ch = (unsigned char)finsh_stack_bottom();
        if (ch > 0x20 && ch < 0x7e)
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
 801c4d8:	461d      	mov	r5, r3
                       (unsigned char)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom(),
 801c4da:	f003 fca9 	bl	801fe30 <finsh_stack_bottom>
 801c4de:	4603      	mov	r3, r0
        finsh_vm_run();

        ch = (unsigned char)finsh_stack_bottom();
        if (ch > 0x20 && ch < 0x7e)
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
 801c4e0:	461c      	mov	r4, r3
                       (unsigned char)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
 801c4e2:	f003 fca5 	bl	801fe30 <finsh_stack_bottom>
 801c4e6:	4603      	mov	r3, r0
        finsh_vm_run();

        ch = (unsigned char)finsh_stack_bottom();
        if (ch > 0x20 && ch < 0x7e)
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
 801c4e8:	480d      	ldr	r0, [pc, #52]	; (801c520 <finsh_run_line+0xb8>)
 801c4ea:	4629      	mov	r1, r5
 801c4ec:	4622      	mov	r2, r4
 801c4ee:	f7fb f9e5 	bl	80178bc <rt_kprintf>
 801c4f2:	e00b      	b.n	801c50c <finsh_run_line+0xa4>
                       (unsigned int)finsh_stack_bottom());
        }
        else
        {
            rt_kprintf("\t%d, 0x%08x\n",
                       (unsigned int)finsh_stack_bottom(),
 801c4f4:	f003 fc9c 	bl	801fe30 <finsh_stack_bottom>
 801c4f8:	4603      	mov	r3, r0
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
        }
        else
        {
            rt_kprintf("\t%d, 0x%08x\n",
 801c4fa:	461c      	mov	r4, r3
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
 801c4fc:	f003 fc98 	bl	801fe30 <finsh_stack_bottom>
 801c500:	4603      	mov	r3, r0
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
        }
        else
        {
            rt_kprintf("\t%d, 0x%08x\n",
 801c502:	4808      	ldr	r0, [pc, #32]	; (801c524 <finsh_run_line+0xbc>)
 801c504:	4621      	mov	r1, r4
 801c506:	461a      	mov	r2, r3
 801c508:	f7fb f9d8 	bl	80178bc <rt_kprintf>
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
        }
    }

    finsh_flush(parser);
 801c50c:	6878      	ldr	r0, [r7, #4]
 801c50e:	f003 fc9b 	bl	801fe48 <finsh_flush>
}
 801c512:	3710      	adds	r7, #16
 801c514:	46bd      	mov	sp, r7
 801c516:	bdb0      	pop	{r4, r5, r7, pc}
 801c518:	08028360 	.word	0x08028360
 801c51c:	0802836c 	.word	0x0802836c
 801c520:	08028370 	.word	0x08028370
 801c524:	08028384 	.word	0x08028384

0801c528 <shell_handle_history>:
#endif

#ifdef FINSH_USING_HISTORY
static rt_bool_t shell_handle_history(struct finsh_shell *shell)
{
 801c528:	b580      	push	{r7, lr}
 801c52a:	b082      	sub	sp, #8
 801c52c:	af00      	add	r7, sp, #0
 801c52e:	6078      	str	r0, [r7, #4]
    for (i = 0; i <= 60; i++)
        putchar(' ');
    rt_kprintf("\r");

#else
    rt_kprintf("\033[2K\r");
 801c530:	4809      	ldr	r0, [pc, #36]	; (801c558 <shell_handle_history+0x30>)
 801c532:	f7fb f9c3 	bl	80178bc <rt_kprintf>
#endif
    rt_kprintf("%s%s", FINSH_PROMPT, shell->line);
 801c536:	f7ff ff27 	bl	801c388 <finsh_get_prompt>
 801c53a:	4602      	mov	r2, r0
 801c53c:	687b      	ldr	r3, [r7, #4]
 801c53e:	f503 7315 	add.w	r3, r3, #596	; 0x254
 801c542:	4806      	ldr	r0, [pc, #24]	; (801c55c <shell_handle_history+0x34>)
 801c544:	4611      	mov	r1, r2
 801c546:	461a      	mov	r2, r3
 801c548:	f7fb f9b8 	bl	80178bc <rt_kprintf>
    return RT_FALSE;
 801c54c:	2300      	movs	r3, #0
}
 801c54e:	4618      	mov	r0, r3
 801c550:	3708      	adds	r7, #8
 801c552:	46bd      	mov	sp, r7
 801c554:	bd80      	pop	{r7, pc}
 801c556:	bf00      	nop
 801c558:	08028394 	.word	0x08028394
 801c55c:	08028364 	.word	0x08028364

0801c560 <shell_push_history>:

static void shell_push_history(struct finsh_shell *shell)
{
 801c560:	b580      	push	{r7, lr}
 801c562:	b084      	sub	sp, #16
 801c564:	af00      	add	r7, sp, #0
 801c566:	6078      	str	r0, [r7, #4]
    if (shell->line_position != 0)
 801c568:	687b      	ldr	r3, [r7, #4]
 801c56a:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801c56e:	2b00      	cmp	r3, #0
 801c570:	d076      	beq.n	801c660 <shell_push_history+0x100>
    {
        /* push history */
        if (shell->history_count >= FINSH_HISTORY_LINES)
 801c572:	687b      	ldr	r3, [r7, #4]
 801c574:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801c576:	2b04      	cmp	r3, #4
 801c578:	d946      	bls.n	801c608 <shell_push_history+0xa8>
        {
            /* move history */
            int index;
            for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
 801c57a:	2300      	movs	r3, #0
 801c57c:	60fb      	str	r3, [r7, #12]
 801c57e:	e01a      	b.n	801c5b6 <shell_push_history+0x56>
            {
                memcpy(&shell->cmd_history[index][0],
 801c580:	68fa      	ldr	r2, [r7, #12]
 801c582:	4613      	mov	r3, r2
 801c584:	009b      	lsls	r3, r3, #2
 801c586:	4413      	add	r3, r2
 801c588:	011b      	lsls	r3, r3, #4
 801c58a:	3320      	adds	r3, #32
 801c58c:	687a      	ldr	r2, [r7, #4]
 801c58e:	4413      	add	r3, r2
 801c590:	1d99      	adds	r1, r3, #6
                       &shell->cmd_history[index + 1][0], FINSH_CMD_SIZE);
 801c592:	68fb      	ldr	r3, [r7, #12]
 801c594:	1c5a      	adds	r2, r3, #1
 801c596:	4613      	mov	r3, r2
 801c598:	009b      	lsls	r3, r3, #2
 801c59a:	4413      	add	r3, r2
 801c59c:	011b      	lsls	r3, r3, #4
 801c59e:	3320      	adds	r3, #32
 801c5a0:	687a      	ldr	r2, [r7, #4]
 801c5a2:	4413      	add	r3, r2
 801c5a4:	3306      	adds	r3, #6
        {
            /* move history */
            int index;
            for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
            {
                memcpy(&shell->cmd_history[index][0],
 801c5a6:	4608      	mov	r0, r1
 801c5a8:	4619      	mov	r1, r3
 801c5aa:	2250      	movs	r2, #80	; 0x50
 801c5ac:	f7e3 fe96 	bl	80002dc <memcpy>
        /* push history */
        if (shell->history_count >= FINSH_HISTORY_LINES)
        {
            /* move history */
            int index;
            for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
 801c5b0:	68fb      	ldr	r3, [r7, #12]
 801c5b2:	3301      	adds	r3, #1
 801c5b4:	60fb      	str	r3, [r7, #12]
 801c5b6:	68fb      	ldr	r3, [r7, #12]
 801c5b8:	2b03      	cmp	r3, #3
 801c5ba:	dde1      	ble.n	801c580 <shell_push_history+0x20>
            {
                memcpy(&shell->cmd_history[index][0],
                       &shell->cmd_history[index + 1][0], FINSH_CMD_SIZE);
            }
            memset(&shell->cmd_history[index][0], 0, FINSH_CMD_SIZE);
 801c5bc:	68fa      	ldr	r2, [r7, #12]
 801c5be:	4613      	mov	r3, r2
 801c5c0:	009b      	lsls	r3, r3, #2
 801c5c2:	4413      	add	r3, r2
 801c5c4:	011b      	lsls	r3, r3, #4
 801c5c6:	3320      	adds	r3, #32
 801c5c8:	687a      	ldr	r2, [r7, #4]
 801c5ca:	4413      	add	r3, r2
 801c5cc:	3306      	adds	r3, #6
 801c5ce:	4618      	mov	r0, r3
 801c5d0:	2100      	movs	r1, #0
 801c5d2:	2250      	movs	r2, #80	; 0x50
 801c5d4:	f006 fbd4 	bl	8022d80 <memset>
            memcpy(&shell->cmd_history[index][0], shell->line, shell->line_position);
 801c5d8:	68fa      	ldr	r2, [r7, #12]
 801c5da:	4613      	mov	r3, r2
 801c5dc:	009b      	lsls	r3, r3, #2
 801c5de:	4413      	add	r3, r2
 801c5e0:	011b      	lsls	r3, r3, #4
 801c5e2:	3320      	adds	r3, #32
 801c5e4:	687a      	ldr	r2, [r7, #4]
 801c5e6:	4413      	add	r3, r2
 801c5e8:	1d99      	adds	r1, r3, #6
 801c5ea:	687b      	ldr	r3, [r7, #4]
 801c5ec:	f503 7215 	add.w	r2, r3, #596	; 0x254
 801c5f0:	687b      	ldr	r3, [r7, #4]
 801c5f2:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801c5f6:	4608      	mov	r0, r1
 801c5f8:	4611      	mov	r1, r2
 801c5fa:	461a      	mov	r2, r3
 801c5fc:	f7e3 fe6e 	bl	80002dc <memcpy>

            /* it's the maximum history */
            shell->history_count = FINSH_HISTORY_LINES;
 801c600:	687b      	ldr	r3, [r7, #4]
 801c602:	2205      	movs	r2, #5
 801c604:	849a      	strh	r2, [r3, #36]	; 0x24
 801c606:	e02b      	b.n	801c660 <shell_push_history+0x100>
        }
        else
        {
            memset(&shell->cmd_history[shell->history_count][0], 0, FINSH_CMD_SIZE);
 801c608:	687b      	ldr	r3, [r7, #4]
 801c60a:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801c60c:	461a      	mov	r2, r3
 801c60e:	4613      	mov	r3, r2
 801c610:	009b      	lsls	r3, r3, #2
 801c612:	4413      	add	r3, r2
 801c614:	011b      	lsls	r3, r3, #4
 801c616:	3320      	adds	r3, #32
 801c618:	687a      	ldr	r2, [r7, #4]
 801c61a:	4413      	add	r3, r2
 801c61c:	3306      	adds	r3, #6
 801c61e:	4618      	mov	r0, r3
 801c620:	2100      	movs	r1, #0
 801c622:	2250      	movs	r2, #80	; 0x50
 801c624:	f006 fbac 	bl	8022d80 <memset>
            memcpy(&shell->cmd_history[shell->history_count][0], shell->line, shell->line_position);
 801c628:	687b      	ldr	r3, [r7, #4]
 801c62a:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801c62c:	461a      	mov	r2, r3
 801c62e:	4613      	mov	r3, r2
 801c630:	009b      	lsls	r3, r3, #2
 801c632:	4413      	add	r3, r2
 801c634:	011b      	lsls	r3, r3, #4
 801c636:	3320      	adds	r3, #32
 801c638:	687a      	ldr	r2, [r7, #4]
 801c63a:	4413      	add	r3, r2
 801c63c:	1d99      	adds	r1, r3, #6
 801c63e:	687b      	ldr	r3, [r7, #4]
 801c640:	f503 7215 	add.w	r2, r3, #596	; 0x254
 801c644:	687b      	ldr	r3, [r7, #4]
 801c646:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801c64a:	4608      	mov	r0, r1
 801c64c:	4611      	mov	r1, r2
 801c64e:	461a      	mov	r2, r3
 801c650:	f7e3 fe44 	bl	80002dc <memcpy>

            /* increase count and set current history position */
            shell->history_count ++;
 801c654:	687b      	ldr	r3, [r7, #4]
 801c656:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801c658:	3301      	adds	r3, #1
 801c65a:	b29a      	uxth	r2, r3
 801c65c:	687b      	ldr	r3, [r7, #4]
 801c65e:	849a      	strh	r2, [r3, #36]	; 0x24
        }
    }
    shell->current_history = shell->history_count;
 801c660:	687b      	ldr	r3, [r7, #4]
 801c662:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 801c664:	687b      	ldr	r3, [r7, #4]
 801c666:	845a      	strh	r2, [r3, #34]	; 0x22
}
 801c668:	3710      	adds	r7, #16
 801c66a:	46bd      	mov	sp, r7
 801c66c:	bd80      	pop	{r7, pc}
 801c66e:	bf00      	nop

0801c670 <finsh_thread_entry>:

#ifndef RT_USING_HEAP
struct finsh_shell _shell;
#endif
void finsh_thread_entry(void *parameter)
{
 801c670:	b5b0      	push	{r4, r5, r7, lr}
 801c672:	b086      	sub	sp, #24
 801c674:	af00      	add	r7, sp, #0
 801c676:	6078      	str	r0, [r7, #4]
    char ch;

    /* normal is echo mode */
    shell->echo_mode = 1;
 801c678:	4bae      	ldr	r3, [pc, #696]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c67a:	681a      	ldr	r2, [r3, #0]
 801c67c:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
 801c680:	f043 0301 	orr.w	r3, r3, #1
 801c684:	f882 3021 	strb.w	r3, [r2, #33]	; 0x21

#ifndef FINSH_USING_MSH_ONLY
    finsh_init(&shell->parser);
 801c688:	4baa      	ldr	r3, [pc, #680]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c68a:	681b      	ldr	r3, [r3, #0]
 801c68c:	f503 73dc 	add.w	r3, r3, #440	; 0x1b8
 801c690:	4618      	mov	r0, r3
 801c692:	f003 fbb9 	bl	801fe08 <finsh_init>
#endif
    rt_kprintf(FINSH_PROMPT);
 801c696:	f7ff fe77 	bl	801c388 <finsh_get_prompt>
 801c69a:	4603      	mov	r3, r0
 801c69c:	4618      	mov	r0, r3
 801c69e:	f7fb f90d 	bl	80178bc <rt_kprintf>

    /* set console device as shell device */
    if (shell->device == RT_NULL)
 801c6a2:	4ba4      	ldr	r3, [pc, #656]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c6a4:	681b      	ldr	r3, [r3, #0]
 801c6a6:	f8d3 32a8 	ldr.w	r3, [r3, #680]	; 0x2a8
 801c6aa:	2b00      	cmp	r3, #0
 801c6ac:	d123      	bne.n	801c6f6 <finsh_thread_entry+0x86>
    {
#ifdef RT_USING_CONSOLE
        shell->device = rt_console_get_device();
 801c6ae:	4ba1      	ldr	r3, [pc, #644]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c6b0:	681c      	ldr	r4, [r3, #0]
 801c6b2:	f7fb f8c7 	bl	8017844 <rt_console_get_device>
 801c6b6:	4603      	mov	r3, r0
 801c6b8:	f8c4 32a8 	str.w	r3, [r4, #680]	; 0x2a8
        RT_ASSERT(shell->device);
 801c6bc:	4b9d      	ldr	r3, [pc, #628]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c6be:	681b      	ldr	r3, [r3, #0]
 801c6c0:	f8d3 32a8 	ldr.w	r3, [r3, #680]	; 0x2a8
 801c6c4:	2b00      	cmp	r3, #0
 801c6c6:	d105      	bne.n	801c6d4 <finsh_thread_entry+0x64>
 801c6c8:	489b      	ldr	r0, [pc, #620]	; (801c938 <finsh_thread_entry+0x2c8>)
 801c6ca:	499c      	ldr	r1, [pc, #624]	; (801c93c <finsh_thread_entry+0x2cc>)
 801c6cc:	f44f 729d 	mov.w	r2, #314	; 0x13a
 801c6d0:	f7fb f96e 	bl	80179b0 <rt_assert_handler>
        rt_device_set_rx_indicate(shell->device, finsh_rx_ind);
 801c6d4:	4b97      	ldr	r3, [pc, #604]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c6d6:	681b      	ldr	r3, [r3, #0]
 801c6d8:	f8d3 32a8 	ldr.w	r3, [r3, #680]	; 0x2a8
 801c6dc:	4618      	mov	r0, r3
 801c6de:	4998      	ldr	r1, [pc, #608]	; (801c940 <finsh_thread_entry+0x2d0>)
 801c6e0:	f7f9 fbda 	bl	8015e98 <rt_device_set_rx_indicate>
        rt_device_open(shell->device, (RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM | RT_DEVICE_FLAG_INT_RX));
 801c6e4:	4b93      	ldr	r3, [pc, #588]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c6e6:	681b      	ldr	r3, [r3, #0]
 801c6e8:	f8d3 32a8 	ldr.w	r3, [r3, #680]	; 0x2a8
 801c6ec:	4618      	mov	r0, r3
 801c6ee:	f240 1143 	movw	r1, #323	; 0x143
 801c6f2:	f7f9 fa91 	bl	8015c18 <rt_device_open>
    }

    while (1)
    {
        /* wait receive */
        if (rt_sem_take(&shell->rx_sem, RT_WAITING_FOREVER) != RT_EOK) continue;
 801c6f6:	4b8f      	ldr	r3, [pc, #572]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c6f8:	681b      	ldr	r3, [r3, #0]
 801c6fa:	4618      	mov	r0, r3
 801c6fc:	f04f 31ff 	mov.w	r1, #4294967295
 801c700:	f7f9 fdc8 	bl	8016294 <rt_sem_take>
 801c704:	4603      	mov	r3, r0
 801c706:	2b00      	cmp	r3, #0
 801c708:	d000      	beq.n	801c70c <finsh_thread_entry+0x9c>
 801c70a:	e2f4      	b.n	801ccf6 <finsh_thread_entry+0x686>

        /* read one character from device */
        while (rt_device_read(shell->device, 0, &ch, 1) == 1)
 801c70c:	e2e3      	b.n	801ccd6 <finsh_thread_entry+0x666>
             * up key  : 0x1b 0x5b 0x41
             * down key: 0x1b 0x5b 0x42
             * right key:0x1b 0x5b 0x43
             * left key: 0x1b 0x5b 0x44
             */
            if (ch == 0x1b)
 801c70e:	7afb      	ldrb	r3, [r7, #11]
 801c710:	2b1b      	cmp	r3, #27
 801c712:	d105      	bne.n	801c720 <finsh_thread_entry+0xb0>
            {
                shell->stat = WAIT_SPEC_KEY;
 801c714:	4b87      	ldr	r3, [pc, #540]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c716:	681b      	ldr	r3, [r3, #0]
 801c718:	2201      	movs	r2, #1
 801c71a:	f883 2020 	strb.w	r2, [r3, #32]
                continue;
 801c71e:	e2da      	b.n	801ccd6 <finsh_thread_entry+0x666>
            }
            else if (shell->stat == WAIT_SPEC_KEY)
 801c720:	4b84      	ldr	r3, [pc, #528]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c722:	681b      	ldr	r3, [r3, #0]
 801c724:	f893 3020 	ldrb.w	r3, [r3, #32]
 801c728:	2b01      	cmp	r3, #1
 801c72a:	d10e      	bne.n	801c74a <finsh_thread_entry+0xda>
            {
                if (ch == 0x5b)
 801c72c:	7afb      	ldrb	r3, [r7, #11]
 801c72e:	2b5b      	cmp	r3, #91	; 0x5b
 801c730:	d105      	bne.n	801c73e <finsh_thread_entry+0xce>
                {
                    shell->stat = WAIT_FUNC_KEY;
 801c732:	4b80      	ldr	r3, [pc, #512]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c734:	681b      	ldr	r3, [r3, #0]
 801c736:	2202      	movs	r2, #2
 801c738:	f883 2020 	strb.w	r2, [r3, #32]
                    continue;
 801c73c:	e2cb      	b.n	801ccd6 <finsh_thread_entry+0x666>
                }

                shell->stat = WAIT_NORMAL;
 801c73e:	4b7d      	ldr	r3, [pc, #500]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c740:	681b      	ldr	r3, [r3, #0]
 801c742:	2200      	movs	r2, #0
 801c744:	f883 2020 	strb.w	r2, [r3, #32]
 801c748:	e0d5      	b.n	801c8f6 <finsh_thread_entry+0x286>
            }
            else if (shell->stat == WAIT_FUNC_KEY)
 801c74a:	4b7a      	ldr	r3, [pc, #488]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c74c:	681b      	ldr	r3, [r3, #0]
 801c74e:	f893 3020 	ldrb.w	r3, [r3, #32]
 801c752:	2b02      	cmp	r3, #2
 801c754:	f040 80cf 	bne.w	801c8f6 <finsh_thread_entry+0x286>
            {
                shell->stat = WAIT_NORMAL;
 801c758:	4b76      	ldr	r3, [pc, #472]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c75a:	681b      	ldr	r3, [r3, #0]
 801c75c:	2200      	movs	r2, #0
 801c75e:	f883 2020 	strb.w	r2, [r3, #32]

                if (ch == 0x41) /* up key */
 801c762:	7afb      	ldrb	r3, [r7, #11]
 801c764:	2b41      	cmp	r3, #65	; 0x41
 801c766:	d13d      	bne.n	801c7e4 <finsh_thread_entry+0x174>
                {
#ifdef FINSH_USING_HISTORY
                    /* prev history */
                    if (shell->current_history > 0)
 801c768:	4b72      	ldr	r3, [pc, #456]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c76a:	681b      	ldr	r3, [r3, #0]
 801c76c:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 801c76e:	2b00      	cmp	r3, #0
 801c770:	d033      	beq.n	801c7da <finsh_thread_entry+0x16a>
                        shell->current_history --;
 801c772:	4b70      	ldr	r3, [pc, #448]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c774:	681b      	ldr	r3, [r3, #0]
 801c776:	8c5a      	ldrh	r2, [r3, #34]	; 0x22
 801c778:	3a01      	subs	r2, #1
 801c77a:	b292      	uxth	r2, r2
 801c77c:	845a      	strh	r2, [r3, #34]	; 0x22
                        shell->current_history = 0;
                        continue;
                    }

                    /* copy the history command */
                    memcpy(shell->line, &shell->cmd_history[shell->current_history][0],
 801c77e:	4b6d      	ldr	r3, [pc, #436]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c780:	681b      	ldr	r3, [r3, #0]
 801c782:	f503 7015 	add.w	r0, r3, #596	; 0x254
 801c786:	4b6b      	ldr	r3, [pc, #428]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c788:	681a      	ldr	r2, [r3, #0]
 801c78a:	4b6a      	ldr	r3, [pc, #424]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c78c:	681b      	ldr	r3, [r3, #0]
 801c78e:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 801c790:	4619      	mov	r1, r3
 801c792:	460b      	mov	r3, r1
 801c794:	009b      	lsls	r3, r3, #2
 801c796:	440b      	add	r3, r1
 801c798:	011b      	lsls	r3, r3, #4
 801c79a:	3320      	adds	r3, #32
 801c79c:	4413      	add	r3, r2
 801c79e:	3306      	adds	r3, #6
 801c7a0:	4619      	mov	r1, r3
 801c7a2:	2250      	movs	r2, #80	; 0x50
 801c7a4:	f7e3 fd9a 	bl	80002dc <memcpy>
                           FINSH_CMD_SIZE);
                    shell->line_curpos = shell->line_position = strlen(shell->line);
 801c7a8:	4b62      	ldr	r3, [pc, #392]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c7aa:	681d      	ldr	r5, [r3, #0]
 801c7ac:	4b61      	ldr	r3, [pc, #388]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c7ae:	681c      	ldr	r4, [r3, #0]
 801c7b0:	4b60      	ldr	r3, [pc, #384]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c7b2:	681b      	ldr	r3, [r3, #0]
 801c7b4:	f503 7315 	add.w	r3, r3, #596	; 0x254
 801c7b8:	4618      	mov	r0, r3
 801c7ba:	f006 ff73 	bl	80236a4 <strlen>
 801c7be:	4603      	mov	r3, r0
 801c7c0:	b2db      	uxtb	r3, r3
 801c7c2:	f884 32a4 	strb.w	r3, [r4, #676]	; 0x2a4
 801c7c6:	f894 32a4 	ldrb.w	r3, [r4, #676]	; 0x2a4
 801c7ca:	f885 32a5 	strb.w	r3, [r5, #677]	; 0x2a5
                    shell_handle_history(shell);
 801c7ce:	4b59      	ldr	r3, [pc, #356]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c7d0:	681b      	ldr	r3, [r3, #0]
 801c7d2:	4618      	mov	r0, r3
 801c7d4:	f7ff fea8 	bl	801c528 <shell_handle_history>
#endif
                    continue;
 801c7d8:	e27d      	b.n	801ccd6 <finsh_thread_entry+0x666>
                    /* prev history */
                    if (shell->current_history > 0)
                        shell->current_history --;
                    else
                    {
                        shell->current_history = 0;
 801c7da:	4b56      	ldr	r3, [pc, #344]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c7dc:	681b      	ldr	r3, [r3, #0]
 801c7de:	2200      	movs	r2, #0
 801c7e0:	845a      	strh	r2, [r3, #34]	; 0x22
                        continue;
 801c7e2:	e278      	b.n	801ccd6 <finsh_thread_entry+0x666>
                    shell->line_curpos = shell->line_position = strlen(shell->line);
                    shell_handle_history(shell);
#endif
                    continue;
                }
                else if (ch == 0x42) /* down key */
 801c7e4:	7afb      	ldrb	r3, [r7, #11]
 801c7e6:	2b42      	cmp	r3, #66	; 0x42
 801c7e8:	d14d      	bne.n	801c886 <finsh_thread_entry+0x216>
                {
#ifdef FINSH_USING_HISTORY
                    /* next history */
                    if (shell->current_history < shell->history_count - 1)
 801c7ea:	4b52      	ldr	r3, [pc, #328]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c7ec:	681b      	ldr	r3, [r3, #0]
 801c7ee:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 801c7f0:	461a      	mov	r2, r3
 801c7f2:	4b50      	ldr	r3, [pc, #320]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c7f4:	681b      	ldr	r3, [r3, #0]
 801c7f6:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801c7f8:	3b01      	subs	r3, #1
 801c7fa:	429a      	cmp	r2, r3
 801c7fc:	da06      	bge.n	801c80c <finsh_thread_entry+0x19c>
                        shell->current_history ++;
 801c7fe:	4b4d      	ldr	r3, [pc, #308]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c800:	681b      	ldr	r3, [r3, #0]
 801c802:	8c5a      	ldrh	r2, [r3, #34]	; 0x22
 801c804:	3201      	adds	r2, #1
 801c806:	b292      	uxth	r2, r2
 801c808:	845a      	strh	r2, [r3, #34]	; 0x22
 801c80a:	e00e      	b.n	801c82a <finsh_thread_entry+0x1ba>
                    else
                    {
                        /* set to the end of history */
                        if (shell->history_count != 0)
 801c80c:	4b49      	ldr	r3, [pc, #292]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c80e:	681b      	ldr	r3, [r3, #0]
 801c810:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801c812:	2b00      	cmp	r3, #0
 801c814:	d008      	beq.n	801c828 <finsh_thread_entry+0x1b8>
                            shell->current_history = shell->history_count - 1;
 801c816:	4b47      	ldr	r3, [pc, #284]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c818:	681b      	ldr	r3, [r3, #0]
 801c81a:	4a46      	ldr	r2, [pc, #280]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c81c:	6812      	ldr	r2, [r2, #0]
 801c81e:	8c92      	ldrh	r2, [r2, #36]	; 0x24
 801c820:	3a01      	subs	r2, #1
 801c822:	b292      	uxth	r2, r2
 801c824:	845a      	strh	r2, [r3, #34]	; 0x22
 801c826:	e000      	b.n	801c82a <finsh_thread_entry+0x1ba>
                        else
                            continue;
 801c828:	e255      	b.n	801ccd6 <finsh_thread_entry+0x666>
                    }

                    memcpy(shell->line, &shell->cmd_history[shell->current_history][0],
 801c82a:	4b42      	ldr	r3, [pc, #264]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c82c:	681b      	ldr	r3, [r3, #0]
 801c82e:	f503 7015 	add.w	r0, r3, #596	; 0x254
 801c832:	4b40      	ldr	r3, [pc, #256]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c834:	681a      	ldr	r2, [r3, #0]
 801c836:	4b3f      	ldr	r3, [pc, #252]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c838:	681b      	ldr	r3, [r3, #0]
 801c83a:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 801c83c:	4619      	mov	r1, r3
 801c83e:	460b      	mov	r3, r1
 801c840:	009b      	lsls	r3, r3, #2
 801c842:	440b      	add	r3, r1
 801c844:	011b      	lsls	r3, r3, #4
 801c846:	3320      	adds	r3, #32
 801c848:	4413      	add	r3, r2
 801c84a:	3306      	adds	r3, #6
 801c84c:	4619      	mov	r1, r3
 801c84e:	2250      	movs	r2, #80	; 0x50
 801c850:	f7e3 fd44 	bl	80002dc <memcpy>
                           FINSH_CMD_SIZE);
                    shell->line_curpos = shell->line_position = strlen(shell->line);
 801c854:	4b37      	ldr	r3, [pc, #220]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c856:	681d      	ldr	r5, [r3, #0]
 801c858:	4b36      	ldr	r3, [pc, #216]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c85a:	681c      	ldr	r4, [r3, #0]
 801c85c:	4b35      	ldr	r3, [pc, #212]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c85e:	681b      	ldr	r3, [r3, #0]
 801c860:	f503 7315 	add.w	r3, r3, #596	; 0x254
 801c864:	4618      	mov	r0, r3
 801c866:	f006 ff1d 	bl	80236a4 <strlen>
 801c86a:	4603      	mov	r3, r0
 801c86c:	b2db      	uxtb	r3, r3
 801c86e:	f884 32a4 	strb.w	r3, [r4, #676]	; 0x2a4
 801c872:	f894 32a4 	ldrb.w	r3, [r4, #676]	; 0x2a4
 801c876:	f885 32a5 	strb.w	r3, [r5, #677]	; 0x2a5
                    shell_handle_history(shell);
 801c87a:	4b2e      	ldr	r3, [pc, #184]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c87c:	681b      	ldr	r3, [r3, #0]
 801c87e:	4618      	mov	r0, r3
 801c880:	f7ff fe52 	bl	801c528 <shell_handle_history>
#endif
                    continue;
 801c884:	e227      	b.n	801ccd6 <finsh_thread_entry+0x666>
                }
                else if (ch == 0x44) /* left key */
 801c886:	7afb      	ldrb	r3, [r7, #11]
 801c888:	2b44      	cmp	r3, #68	; 0x44
 801c88a:	d111      	bne.n	801c8b0 <finsh_thread_entry+0x240>
                {
                    if (shell->line_curpos)
 801c88c:	4b29      	ldr	r3, [pc, #164]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c88e:	681b      	ldr	r3, [r3, #0]
 801c890:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801c894:	2b00      	cmp	r3, #0
 801c896:	d00a      	beq.n	801c8ae <finsh_thread_entry+0x23e>
                    {
                        rt_kprintf("\b");
 801c898:	482a      	ldr	r0, [pc, #168]	; (801c944 <finsh_thread_entry+0x2d4>)
 801c89a:	f7fb f80f 	bl	80178bc <rt_kprintf>
                        shell->line_curpos --;
 801c89e:	4b25      	ldr	r3, [pc, #148]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c8a0:	681b      	ldr	r3, [r3, #0]
 801c8a2:	f893 22a5 	ldrb.w	r2, [r3, #677]	; 0x2a5
 801c8a6:	3a01      	subs	r2, #1
 801c8a8:	b2d2      	uxtb	r2, r2
 801c8aa:	f883 22a5 	strb.w	r2, [r3, #677]	; 0x2a5
                    }

                    continue;
 801c8ae:	e212      	b.n	801ccd6 <finsh_thread_entry+0x666>
                }
                else if (ch == 0x43) /* right key */
 801c8b0:	7afb      	ldrb	r3, [r7, #11]
 801c8b2:	2b43      	cmp	r3, #67	; 0x43
 801c8b4:	d11f      	bne.n	801c8f6 <finsh_thread_entry+0x286>
                {
                    if (shell->line_curpos < shell->line_position)
 801c8b6:	4b1f      	ldr	r3, [pc, #124]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c8b8:	681b      	ldr	r3, [r3, #0]
 801c8ba:	f893 22a5 	ldrb.w	r2, [r3, #677]	; 0x2a5
 801c8be:	4b1d      	ldr	r3, [pc, #116]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c8c0:	681b      	ldr	r3, [r3, #0]
 801c8c2:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801c8c6:	429a      	cmp	r2, r3
 801c8c8:	d214      	bcs.n	801c8f4 <finsh_thread_entry+0x284>
                    {
                        rt_kprintf("%c", shell->line[shell->line_curpos]);
 801c8ca:	4b1a      	ldr	r3, [pc, #104]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c8cc:	681b      	ldr	r3, [r3, #0]
 801c8ce:	4a19      	ldr	r2, [pc, #100]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c8d0:	6812      	ldr	r2, [r2, #0]
 801c8d2:	f892 22a5 	ldrb.w	r2, [r2, #677]	; 0x2a5
 801c8d6:	4413      	add	r3, r2
 801c8d8:	f893 3254 	ldrb.w	r3, [r3, #596]	; 0x254
 801c8dc:	481a      	ldr	r0, [pc, #104]	; (801c948 <finsh_thread_entry+0x2d8>)
 801c8de:	4619      	mov	r1, r3
 801c8e0:	f7fa ffec 	bl	80178bc <rt_kprintf>
                        shell->line_curpos ++;
 801c8e4:	4b13      	ldr	r3, [pc, #76]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c8e6:	681b      	ldr	r3, [r3, #0]
 801c8e8:	f893 22a5 	ldrb.w	r2, [r3, #677]	; 0x2a5
 801c8ec:	3201      	adds	r2, #1
 801c8ee:	b2d2      	uxtb	r2, r2
 801c8f0:	f883 22a5 	strb.w	r2, [r3, #677]	; 0x2a5
                    }

                    continue;
 801c8f4:	e1ef      	b.n	801ccd6 <finsh_thread_entry+0x666>
                }

            }

            /* handle CR key */
            if (ch == '\r')
 801c8f6:	7afb      	ldrb	r3, [r7, #11]
 801c8f8:	2b0d      	cmp	r3, #13
 801c8fa:	d127      	bne.n	801c94c <finsh_thread_entry+0x2dc>
            {
                char next;

                if (rt_device_read(shell->device, 0, &next, 1) == 1)
 801c8fc:	4b0d      	ldr	r3, [pc, #52]	; (801c934 <finsh_thread_entry+0x2c4>)
 801c8fe:	681b      	ldr	r3, [r3, #0]
 801c900:	f8d3 22a8 	ldr.w	r2, [r3, #680]	; 0x2a8
 801c904:	f107 030a 	add.w	r3, r7, #10
 801c908:	4610      	mov	r0, r2
 801c90a:	2100      	movs	r1, #0
 801c90c:	461a      	mov	r2, r3
 801c90e:	2301      	movs	r3, #1
 801c910:	f7f9 fa34 	bl	8015d7c <rt_device_read>
 801c914:	4603      	mov	r3, r0
 801c916:	2b01      	cmp	r3, #1
 801c918:	d108      	bne.n	801c92c <finsh_thread_entry+0x2bc>
                {
                    if (next == '\0') ch = 'r'; /* linux telnet will issue '\0' */
 801c91a:	7abb      	ldrb	r3, [r7, #10]
 801c91c:	2b00      	cmp	r3, #0
 801c91e:	d102      	bne.n	801c926 <finsh_thread_entry+0x2b6>
 801c920:	2372      	movs	r3, #114	; 0x72
 801c922:	72fb      	strb	r3, [r7, #11]
 801c924:	e0c7      	b.n	801cab6 <finsh_thread_entry+0x446>
                    else ch = next;
 801c926:	7abb      	ldrb	r3, [r7, #10]
 801c928:	72fb      	strb	r3, [r7, #11]
 801c92a:	e0c4      	b.n	801cab6 <finsh_thread_entry+0x446>
                }
                else ch = '\r';
 801c92c:	230d      	movs	r3, #13
 801c92e:	72fb      	strb	r3, [r7, #11]
 801c930:	e0c1      	b.n	801cab6 <finsh_thread_entry+0x446>
 801c932:	bf00      	nop
 801c934:	20012bb4 	.word	0x20012bb4
 801c938:	0802839c 	.word	0x0802839c
 801c93c:	080296a4 	.word	0x080296a4
 801c940:	0801c3e9 	.word	0x0801c3e9
 801c944:	080283ac 	.word	0x080283ac
 801c948:	080283b0 	.word	0x080283b0
            }
            /* handle tab key */
            else if (ch == '\t')
 801c94c:	7afb      	ldrb	r3, [r7, #11]
 801c94e:	2b09      	cmp	r3, #9
 801c950:	d12b      	bne.n	801c9aa <finsh_thread_entry+0x33a>
            {
                int i;
                /* move the cursor to the beginning of line */
                for (i = 0; i < shell->line_curpos; i++)
 801c952:	2300      	movs	r3, #0
 801c954:	617b      	str	r3, [r7, #20]
 801c956:	e005      	b.n	801c964 <finsh_thread_entry+0x2f4>
                    rt_kprintf("\b");
 801c958:	4884      	ldr	r0, [pc, #528]	; (801cb6c <finsh_thread_entry+0x4fc>)
 801c95a:	f7fa ffaf 	bl	80178bc <rt_kprintf>
            /* handle tab key */
            else if (ch == '\t')
            {
                int i;
                /* move the cursor to the beginning of line */
                for (i = 0; i < shell->line_curpos; i++)
 801c95e:	697b      	ldr	r3, [r7, #20]
 801c960:	3301      	adds	r3, #1
 801c962:	617b      	str	r3, [r7, #20]
 801c964:	4b82      	ldr	r3, [pc, #520]	; (801cb70 <finsh_thread_entry+0x500>)
 801c966:	681b      	ldr	r3, [r3, #0]
 801c968:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801c96c:	461a      	mov	r2, r3
 801c96e:	697b      	ldr	r3, [r7, #20]
 801c970:	429a      	cmp	r2, r3
 801c972:	dcf1      	bgt.n	801c958 <finsh_thread_entry+0x2e8>
                    rt_kprintf("\b");

                /* auto complete */
                shell_auto_complete(&shell->line[0]);
 801c974:	4b7e      	ldr	r3, [pc, #504]	; (801cb70 <finsh_thread_entry+0x500>)
 801c976:	681b      	ldr	r3, [r3, #0]
 801c978:	f503 7315 	add.w	r3, r3, #596	; 0x254
 801c97c:	4618      	mov	r0, r3
 801c97e:	f7ff fd51 	bl	801c424 <shell_auto_complete>
                /* re-calculate position */
                shell->line_curpos = shell->line_position = strlen(shell->line);
 801c982:	4b7b      	ldr	r3, [pc, #492]	; (801cb70 <finsh_thread_entry+0x500>)
 801c984:	681d      	ldr	r5, [r3, #0]
 801c986:	4b7a      	ldr	r3, [pc, #488]	; (801cb70 <finsh_thread_entry+0x500>)
 801c988:	681c      	ldr	r4, [r3, #0]
 801c98a:	4b79      	ldr	r3, [pc, #484]	; (801cb70 <finsh_thread_entry+0x500>)
 801c98c:	681b      	ldr	r3, [r3, #0]
 801c98e:	f503 7315 	add.w	r3, r3, #596	; 0x254
 801c992:	4618      	mov	r0, r3
 801c994:	f006 fe86 	bl	80236a4 <strlen>
 801c998:	4603      	mov	r3, r0
 801c99a:	b2db      	uxtb	r3, r3
 801c99c:	f884 32a4 	strb.w	r3, [r4, #676]	; 0x2a4
 801c9a0:	f894 32a4 	ldrb.w	r3, [r4, #676]	; 0x2a4
 801c9a4:	f885 32a5 	strb.w	r3, [r5, #677]	; 0x2a5

                continue;
 801c9a8:	e195      	b.n	801ccd6 <finsh_thread_entry+0x666>
            }
            /* handle backspace key */
            else if (ch == 0x7f || ch == 0x08)
 801c9aa:	7afb      	ldrb	r3, [r7, #11]
 801c9ac:	2b7f      	cmp	r3, #127	; 0x7f
 801c9ae:	d002      	beq.n	801c9b6 <finsh_thread_entry+0x346>
 801c9b0:	7afb      	ldrb	r3, [r7, #11]
 801c9b2:	2b08      	cmp	r3, #8
 801c9b4:	d17f      	bne.n	801cab6 <finsh_thread_entry+0x446>
            {
                /* note that shell->line_curpos >= 0 */
                if (shell->line_curpos == 0)
 801c9b6:	4b6e      	ldr	r3, [pc, #440]	; (801cb70 <finsh_thread_entry+0x500>)
 801c9b8:	681b      	ldr	r3, [r3, #0]
 801c9ba:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801c9be:	2b00      	cmp	r3, #0
 801c9c0:	d100      	bne.n	801c9c4 <finsh_thread_entry+0x354>
                    continue;
 801c9c2:	e188      	b.n	801ccd6 <finsh_thread_entry+0x666>

                shell->line_position--;
 801c9c4:	4b6a      	ldr	r3, [pc, #424]	; (801cb70 <finsh_thread_entry+0x500>)
 801c9c6:	681b      	ldr	r3, [r3, #0]
 801c9c8:	f893 22a4 	ldrb.w	r2, [r3, #676]	; 0x2a4
 801c9cc:	3a01      	subs	r2, #1
 801c9ce:	b2d2      	uxtb	r2, r2
 801c9d0:	f883 22a4 	strb.w	r2, [r3, #676]	; 0x2a4
                shell->line_curpos--;
 801c9d4:	4b66      	ldr	r3, [pc, #408]	; (801cb70 <finsh_thread_entry+0x500>)
 801c9d6:	681b      	ldr	r3, [r3, #0]
 801c9d8:	f893 22a5 	ldrb.w	r2, [r3, #677]	; 0x2a5
 801c9dc:	3a01      	subs	r2, #1
 801c9de:	b2d2      	uxtb	r2, r2
 801c9e0:	f883 22a5 	strb.w	r2, [r3, #677]	; 0x2a5

                if (shell->line_position > shell->line_curpos)
 801c9e4:	4b62      	ldr	r3, [pc, #392]	; (801cb70 <finsh_thread_entry+0x500>)
 801c9e6:	681b      	ldr	r3, [r3, #0]
 801c9e8:	f893 22a4 	ldrb.w	r2, [r3, #676]	; 0x2a4
 801c9ec:	4b60      	ldr	r3, [pc, #384]	; (801cb70 <finsh_thread_entry+0x500>)
 801c9ee:	681b      	ldr	r3, [r3, #0]
 801c9f0:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801c9f4:	429a      	cmp	r2, r3
 801c9f6:	d950      	bls.n	801ca9a <finsh_thread_entry+0x42a>
                {
                    int i;

                    rt_memmove(&shell->line[shell->line_curpos],
 801c9f8:	4b5d      	ldr	r3, [pc, #372]	; (801cb70 <finsh_thread_entry+0x500>)
 801c9fa:	681a      	ldr	r2, [r3, #0]
 801c9fc:	4b5c      	ldr	r3, [pc, #368]	; (801cb70 <finsh_thread_entry+0x500>)
 801c9fe:	681b      	ldr	r3, [r3, #0]
 801ca00:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801ca04:	f503 7314 	add.w	r3, r3, #592	; 0x250
 801ca08:	4413      	add	r3, r2
 801ca0a:	1d19      	adds	r1, r3, #4
                               &shell->line[shell->line_curpos + 1],
 801ca0c:	4b58      	ldr	r3, [pc, #352]	; (801cb70 <finsh_thread_entry+0x500>)
 801ca0e:	681a      	ldr	r2, [r3, #0]
 801ca10:	4b57      	ldr	r3, [pc, #348]	; (801cb70 <finsh_thread_entry+0x500>)
 801ca12:	681b      	ldr	r3, [r3, #0]
 801ca14:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801ca18:	3301      	adds	r3, #1
 801ca1a:	f503 7314 	add.w	r3, r3, #592	; 0x250
 801ca1e:	4413      	add	r3, r2
 801ca20:	1d1a      	adds	r2, r3, #4
                               shell->line_position - shell->line_curpos);
 801ca22:	4b53      	ldr	r3, [pc, #332]	; (801cb70 <finsh_thread_entry+0x500>)
 801ca24:	681b      	ldr	r3, [r3, #0]
 801ca26:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801ca2a:	4618      	mov	r0, r3
 801ca2c:	4b50      	ldr	r3, [pc, #320]	; (801cb70 <finsh_thread_entry+0x500>)
 801ca2e:	681b      	ldr	r3, [r3, #0]
 801ca30:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801ca34:	1ac3      	subs	r3, r0, r3

                if (shell->line_position > shell->line_curpos)
                {
                    int i;

                    rt_memmove(&shell->line[shell->line_curpos],
 801ca36:	4608      	mov	r0, r1
 801ca38:	4611      	mov	r1, r2
 801ca3a:	461a      	mov	r2, r3
 801ca3c:	f7fa fa4c 	bl	8016ed8 <rt_memmove>
                               &shell->line[shell->line_curpos + 1],
                               shell->line_position - shell->line_curpos);
                    shell->line[shell->line_position] = 0;
 801ca40:	4b4b      	ldr	r3, [pc, #300]	; (801cb70 <finsh_thread_entry+0x500>)
 801ca42:	681b      	ldr	r3, [r3, #0]
 801ca44:	4a4a      	ldr	r2, [pc, #296]	; (801cb70 <finsh_thread_entry+0x500>)
 801ca46:	6812      	ldr	r2, [r2, #0]
 801ca48:	f892 22a4 	ldrb.w	r2, [r2, #676]	; 0x2a4
 801ca4c:	4413      	add	r3, r2
 801ca4e:	2200      	movs	r2, #0
 801ca50:	f883 2254 	strb.w	r2, [r3, #596]	; 0x254

                    rt_kprintf("\b%s  \b", &shell->line[shell->line_curpos]);
 801ca54:	4b46      	ldr	r3, [pc, #280]	; (801cb70 <finsh_thread_entry+0x500>)
 801ca56:	681a      	ldr	r2, [r3, #0]
 801ca58:	4b45      	ldr	r3, [pc, #276]	; (801cb70 <finsh_thread_entry+0x500>)
 801ca5a:	681b      	ldr	r3, [r3, #0]
 801ca5c:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801ca60:	f503 7314 	add.w	r3, r3, #592	; 0x250
 801ca64:	4413      	add	r3, r2
 801ca66:	3304      	adds	r3, #4
 801ca68:	4842      	ldr	r0, [pc, #264]	; (801cb74 <finsh_thread_entry+0x504>)
 801ca6a:	4619      	mov	r1, r3
 801ca6c:	f7fa ff26 	bl	80178bc <rt_kprintf>

                    /* move the cursor to the origin position */
                    for (i = shell->line_curpos; i <= shell->line_position; i++)
 801ca70:	4b3f      	ldr	r3, [pc, #252]	; (801cb70 <finsh_thread_entry+0x500>)
 801ca72:	681b      	ldr	r3, [r3, #0]
 801ca74:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801ca78:	613b      	str	r3, [r7, #16]
 801ca7a:	e005      	b.n	801ca88 <finsh_thread_entry+0x418>
                        rt_kprintf("\b");
 801ca7c:	483b      	ldr	r0, [pc, #236]	; (801cb6c <finsh_thread_entry+0x4fc>)
 801ca7e:	f7fa ff1d 	bl	80178bc <rt_kprintf>
                    shell->line[shell->line_position] = 0;

                    rt_kprintf("\b%s  \b", &shell->line[shell->line_curpos]);

                    /* move the cursor to the origin position */
                    for (i = shell->line_curpos; i <= shell->line_position; i++)
 801ca82:	693b      	ldr	r3, [r7, #16]
 801ca84:	3301      	adds	r3, #1
 801ca86:	613b      	str	r3, [r7, #16]
 801ca88:	4b39      	ldr	r3, [pc, #228]	; (801cb70 <finsh_thread_entry+0x500>)
 801ca8a:	681b      	ldr	r3, [r3, #0]
 801ca8c:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801ca90:	461a      	mov	r2, r3
 801ca92:	693b      	ldr	r3, [r7, #16]
 801ca94:	429a      	cmp	r2, r3
 801ca96:	daf1      	bge.n	801ca7c <finsh_thread_entry+0x40c>
 801ca98:	e00c      	b.n	801cab4 <finsh_thread_entry+0x444>
                        rt_kprintf("\b");
                }
                else
                {
                    rt_kprintf("\b \b");
 801ca9a:	4837      	ldr	r0, [pc, #220]	; (801cb78 <finsh_thread_entry+0x508>)
 801ca9c:	f7fa ff0e 	bl	80178bc <rt_kprintf>
                    shell->line[shell->line_position] = 0;
 801caa0:	4b33      	ldr	r3, [pc, #204]	; (801cb70 <finsh_thread_entry+0x500>)
 801caa2:	681b      	ldr	r3, [r3, #0]
 801caa4:	4a32      	ldr	r2, [pc, #200]	; (801cb70 <finsh_thread_entry+0x500>)
 801caa6:	6812      	ldr	r2, [r2, #0]
 801caa8:	f892 22a4 	ldrb.w	r2, [r2, #676]	; 0x2a4
 801caac:	4413      	add	r3, r2
 801caae:	2200      	movs	r2, #0
 801cab0:	f883 2254 	strb.w	r2, [r3, #596]	; 0x254
                }

                continue;
 801cab4:	e10f      	b.n	801ccd6 <finsh_thread_entry+0x666>
            }

            /* handle end of line, break */
            if (ch == '\r' || ch == '\n')
 801cab6:	7afb      	ldrb	r3, [r7, #11]
 801cab8:	2b0d      	cmp	r3, #13
 801caba:	d002      	beq.n	801cac2 <finsh_thread_entry+0x452>
 801cabc:	7afb      	ldrb	r3, [r7, #11]
 801cabe:	2b0a      	cmp	r3, #10
 801cac0:	d15e      	bne.n	801cb80 <finsh_thread_entry+0x510>
            {
#ifdef FINSH_USING_HISTORY
                shell_push_history(shell);
 801cac2:	4b2b      	ldr	r3, [pc, #172]	; (801cb70 <finsh_thread_entry+0x500>)
 801cac4:	681b      	ldr	r3, [r3, #0]
 801cac6:	4618      	mov	r0, r3
 801cac8:	f7ff fd4a 	bl	801c560 <shell_push_history>
#endif

#ifdef FINSH_USING_MSH
                if (msh_is_used() == RT_TRUE)
 801cacc:	f000 ffd8 	bl	801da80 <msh_is_used>
 801cad0:	4603      	mov	r3, r0
 801cad2:	2b01      	cmp	r3, #1
 801cad4:	d10f      	bne.n	801caf6 <finsh_thread_entry+0x486>
                {
                    rt_kprintf("\n");
 801cad6:	4829      	ldr	r0, [pc, #164]	; (801cb7c <finsh_thread_entry+0x50c>)
 801cad8:	f7fa fef0 	bl	80178bc <rt_kprintf>
                    msh_exec(shell->line, shell->line_position);
 801cadc:	4b24      	ldr	r3, [pc, #144]	; (801cb70 <finsh_thread_entry+0x500>)
 801cade:	681b      	ldr	r3, [r3, #0]
 801cae0:	f503 7215 	add.w	r2, r3, #596	; 0x254
 801cae4:	4b22      	ldr	r3, [pc, #136]	; (801cb70 <finsh_thread_entry+0x500>)
 801cae6:	681b      	ldr	r3, [r3, #0]
 801cae8:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801caec:	4610      	mov	r0, r2
 801caee:	4619      	mov	r1, r3
 801caf0:	f001 f970 	bl	801ddd4 <msh_exec>
 801caf4:	e01f      	b.n	801cb36 <finsh_thread_entry+0x4c6>
                else
#endif
                {
#ifndef FINSH_USING_MSH_ONLY
                    /* add ';' and run the command line */
                    shell->line[shell->line_position] = ';';
 801caf6:	4b1e      	ldr	r3, [pc, #120]	; (801cb70 <finsh_thread_entry+0x500>)
 801caf8:	681b      	ldr	r3, [r3, #0]
 801cafa:	4a1d      	ldr	r2, [pc, #116]	; (801cb70 <finsh_thread_entry+0x500>)
 801cafc:	6812      	ldr	r2, [r2, #0]
 801cafe:	f892 22a4 	ldrb.w	r2, [r2, #676]	; 0x2a4
 801cb02:	4413      	add	r3, r2
 801cb04:	223b      	movs	r2, #59	; 0x3b
 801cb06:	f883 2254 	strb.w	r2, [r3, #596]	; 0x254

                    if (shell->line_position != 0) finsh_run_line(&shell->parser, shell->line);
 801cb0a:	4b19      	ldr	r3, [pc, #100]	; (801cb70 <finsh_thread_entry+0x500>)
 801cb0c:	681b      	ldr	r3, [r3, #0]
 801cb0e:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801cb12:	2b00      	cmp	r3, #0
 801cb14:	d00c      	beq.n	801cb30 <finsh_thread_entry+0x4c0>
 801cb16:	4b16      	ldr	r3, [pc, #88]	; (801cb70 <finsh_thread_entry+0x500>)
 801cb18:	681b      	ldr	r3, [r3, #0]
 801cb1a:	f503 72dc 	add.w	r2, r3, #440	; 0x1b8
 801cb1e:	4b14      	ldr	r3, [pc, #80]	; (801cb70 <finsh_thread_entry+0x500>)
 801cb20:	681b      	ldr	r3, [r3, #0]
 801cb22:	f503 7315 	add.w	r3, r3, #596	; 0x254
 801cb26:	4610      	mov	r0, r2
 801cb28:	4619      	mov	r1, r3
 801cb2a:	f7ff fc9d 	bl	801c468 <finsh_run_line>
 801cb2e:	e002      	b.n	801cb36 <finsh_thread_entry+0x4c6>
                    else rt_kprintf("\n");
 801cb30:	4812      	ldr	r0, [pc, #72]	; (801cb7c <finsh_thread_entry+0x50c>)
 801cb32:	f7fa fec3 	bl	80178bc <rt_kprintf>
#endif
                }

                rt_kprintf(FINSH_PROMPT);
 801cb36:	f7ff fc27 	bl	801c388 <finsh_get_prompt>
 801cb3a:	4603      	mov	r3, r0
 801cb3c:	4618      	mov	r0, r3
 801cb3e:	f7fa febd 	bl	80178bc <rt_kprintf>
                memset(shell->line, 0, sizeof(shell->line));
 801cb42:	4b0b      	ldr	r3, [pc, #44]	; (801cb70 <finsh_thread_entry+0x500>)
 801cb44:	681b      	ldr	r3, [r3, #0]
 801cb46:	f503 7315 	add.w	r3, r3, #596	; 0x254
 801cb4a:	4618      	mov	r0, r3
 801cb4c:	2100      	movs	r1, #0
 801cb4e:	2250      	movs	r2, #80	; 0x50
 801cb50:	f006 f916 	bl	8022d80 <memset>
                shell->line_curpos = shell->line_position = 0;
 801cb54:	4b06      	ldr	r3, [pc, #24]	; (801cb70 <finsh_thread_entry+0x500>)
 801cb56:	681a      	ldr	r2, [r3, #0]
 801cb58:	4b05      	ldr	r3, [pc, #20]	; (801cb70 <finsh_thread_entry+0x500>)
 801cb5a:	681b      	ldr	r3, [r3, #0]
 801cb5c:	2100      	movs	r1, #0
 801cb5e:	f883 12a4 	strb.w	r1, [r3, #676]	; 0x2a4
 801cb62:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801cb66:	f882 32a5 	strb.w	r3, [r2, #677]	; 0x2a5
                break;
 801cb6a:	e0c4      	b.n	801ccf6 <finsh_thread_entry+0x686>
 801cb6c:	080283ac 	.word	0x080283ac
 801cb70:	20012bb4 	.word	0x20012bb4
 801cb74:	080283b4 	.word	0x080283b4
 801cb78:	080283bc 	.word	0x080283bc
 801cb7c:	08028360 	.word	0x08028360
            }

            /* it's a large line, discard it */
            if (shell->line_position >= FINSH_CMD_SIZE)
 801cb80:	4b5d      	ldr	r3, [pc, #372]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cb82:	681b      	ldr	r3, [r3, #0]
 801cb84:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801cb88:	2b4f      	cmp	r3, #79	; 0x4f
 801cb8a:	d904      	bls.n	801cb96 <finsh_thread_entry+0x526>
                shell->line_position = 0;
 801cb8c:	4b5a      	ldr	r3, [pc, #360]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cb8e:	681b      	ldr	r3, [r3, #0]
 801cb90:	2200      	movs	r2, #0
 801cb92:	f883 22a4 	strb.w	r2, [r3, #676]	; 0x2a4

            /* normal character */
            if (shell->line_curpos < shell->line_position)
 801cb96:	4b58      	ldr	r3, [pc, #352]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cb98:	681b      	ldr	r3, [r3, #0]
 801cb9a:	f893 22a5 	ldrb.w	r2, [r3, #677]	; 0x2a5
 801cb9e:	4b56      	ldr	r3, [pc, #344]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cba0:	681b      	ldr	r3, [r3, #0]
 801cba2:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801cba6:	429a      	cmp	r2, r3
 801cba8:	d25a      	bcs.n	801cc60 <finsh_thread_entry+0x5f0>
            {
                int i;

                rt_memmove(&shell->line[shell->line_curpos + 1],
 801cbaa:	4b53      	ldr	r3, [pc, #332]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cbac:	681a      	ldr	r2, [r3, #0]
 801cbae:	4b52      	ldr	r3, [pc, #328]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cbb0:	681b      	ldr	r3, [r3, #0]
 801cbb2:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801cbb6:	3301      	adds	r3, #1
 801cbb8:	f503 7314 	add.w	r3, r3, #592	; 0x250
 801cbbc:	4413      	add	r3, r2
 801cbbe:	1d19      	adds	r1, r3, #4
                           &shell->line[shell->line_curpos],
 801cbc0:	4b4d      	ldr	r3, [pc, #308]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cbc2:	681a      	ldr	r2, [r3, #0]
 801cbc4:	4b4c      	ldr	r3, [pc, #304]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cbc6:	681b      	ldr	r3, [r3, #0]
 801cbc8:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801cbcc:	f503 7314 	add.w	r3, r3, #592	; 0x250
 801cbd0:	4413      	add	r3, r2
 801cbd2:	1d1a      	adds	r2, r3, #4
                           shell->line_position - shell->line_curpos);
 801cbd4:	4b48      	ldr	r3, [pc, #288]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cbd6:	681b      	ldr	r3, [r3, #0]
 801cbd8:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801cbdc:	4618      	mov	r0, r3
 801cbde:	4b46      	ldr	r3, [pc, #280]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cbe0:	681b      	ldr	r3, [r3, #0]
 801cbe2:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801cbe6:	1ac3      	subs	r3, r0, r3
            /* normal character */
            if (shell->line_curpos < shell->line_position)
            {
                int i;

                rt_memmove(&shell->line[shell->line_curpos + 1],
 801cbe8:	4608      	mov	r0, r1
 801cbea:	4611      	mov	r1, r2
 801cbec:	461a      	mov	r2, r3
 801cbee:	f7fa f973 	bl	8016ed8 <rt_memmove>
                           &shell->line[shell->line_curpos],
                           shell->line_position - shell->line_curpos);
                shell->line[shell->line_curpos] = ch;
 801cbf2:	4b41      	ldr	r3, [pc, #260]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cbf4:	681b      	ldr	r3, [r3, #0]
 801cbf6:	4a40      	ldr	r2, [pc, #256]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cbf8:	6812      	ldr	r2, [r2, #0]
 801cbfa:	f892 22a5 	ldrb.w	r2, [r2, #677]	; 0x2a5
 801cbfe:	4611      	mov	r1, r2
 801cc00:	7afa      	ldrb	r2, [r7, #11]
 801cc02:	440b      	add	r3, r1
 801cc04:	f883 2254 	strb.w	r2, [r3, #596]	; 0x254
                if (shell->echo_mode)
 801cc08:	4b3b      	ldr	r3, [pc, #236]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cc0a:	681b      	ldr	r3, [r3, #0]
 801cc0c:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 801cc10:	f003 0301 	and.w	r3, r3, #1
 801cc14:	b2db      	uxtb	r3, r3
 801cc16:	2b00      	cmp	r3, #0
 801cc18:	d00d      	beq.n	801cc36 <finsh_thread_entry+0x5c6>
                    rt_kprintf("%s", &shell->line[shell->line_curpos]);
 801cc1a:	4b37      	ldr	r3, [pc, #220]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cc1c:	681a      	ldr	r2, [r3, #0]
 801cc1e:	4b36      	ldr	r3, [pc, #216]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cc20:	681b      	ldr	r3, [r3, #0]
 801cc22:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801cc26:	f503 7314 	add.w	r3, r3, #592	; 0x250
 801cc2a:	4413      	add	r3, r2
 801cc2c:	3304      	adds	r3, #4
 801cc2e:	4833      	ldr	r0, [pc, #204]	; (801ccfc <finsh_thread_entry+0x68c>)
 801cc30:	4619      	mov	r1, r3
 801cc32:	f7fa fe43 	bl	80178bc <rt_kprintf>

                /* move the cursor to new position */
                for (i = shell->line_curpos; i < shell->line_position; i++)
 801cc36:	4b30      	ldr	r3, [pc, #192]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cc38:	681b      	ldr	r3, [r3, #0]
 801cc3a:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801cc3e:	60fb      	str	r3, [r7, #12]
 801cc40:	e005      	b.n	801cc4e <finsh_thread_entry+0x5de>
                    rt_kprintf("\b");
 801cc42:	482f      	ldr	r0, [pc, #188]	; (801cd00 <finsh_thread_entry+0x690>)
 801cc44:	f7fa fe3a 	bl	80178bc <rt_kprintf>
                shell->line[shell->line_curpos] = ch;
                if (shell->echo_mode)
                    rt_kprintf("%s", &shell->line[shell->line_curpos]);

                /* move the cursor to new position */
                for (i = shell->line_curpos; i < shell->line_position; i++)
 801cc48:	68fb      	ldr	r3, [r7, #12]
 801cc4a:	3301      	adds	r3, #1
 801cc4c:	60fb      	str	r3, [r7, #12]
 801cc4e:	4b2a      	ldr	r3, [pc, #168]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cc50:	681b      	ldr	r3, [r3, #0]
 801cc52:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801cc56:	461a      	mov	r2, r3
 801cc58:	68fb      	ldr	r3, [r7, #12]
 801cc5a:	429a      	cmp	r2, r3
 801cc5c:	dcf1      	bgt.n	801cc42 <finsh_thread_entry+0x5d2>
 801cc5e:	e018      	b.n	801cc92 <finsh_thread_entry+0x622>
                    rt_kprintf("\b");
            }
            else
            {
                shell->line[shell->line_position] = ch;
 801cc60:	4b25      	ldr	r3, [pc, #148]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cc62:	681b      	ldr	r3, [r3, #0]
 801cc64:	4a24      	ldr	r2, [pc, #144]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cc66:	6812      	ldr	r2, [r2, #0]
 801cc68:	f892 22a4 	ldrb.w	r2, [r2, #676]	; 0x2a4
 801cc6c:	4611      	mov	r1, r2
 801cc6e:	7afa      	ldrb	r2, [r7, #11]
 801cc70:	440b      	add	r3, r1
 801cc72:	f883 2254 	strb.w	r2, [r3, #596]	; 0x254
                if (shell->echo_mode)
 801cc76:	4b20      	ldr	r3, [pc, #128]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cc78:	681b      	ldr	r3, [r3, #0]
 801cc7a:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 801cc7e:	f003 0301 	and.w	r3, r3, #1
 801cc82:	b2db      	uxtb	r3, r3
 801cc84:	2b00      	cmp	r3, #0
 801cc86:	d004      	beq.n	801cc92 <finsh_thread_entry+0x622>
                    rt_kprintf("%c", ch);
 801cc88:	7afb      	ldrb	r3, [r7, #11]
 801cc8a:	481e      	ldr	r0, [pc, #120]	; (801cd04 <finsh_thread_entry+0x694>)
 801cc8c:	4619      	mov	r1, r3
 801cc8e:	f7fa fe15 	bl	80178bc <rt_kprintf>
            }

            ch = 0;
 801cc92:	2300      	movs	r3, #0
 801cc94:	72fb      	strb	r3, [r7, #11]
            shell->line_position ++;
 801cc96:	4b18      	ldr	r3, [pc, #96]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cc98:	681b      	ldr	r3, [r3, #0]
 801cc9a:	f893 22a4 	ldrb.w	r2, [r3, #676]	; 0x2a4
 801cc9e:	3201      	adds	r2, #1
 801cca0:	b2d2      	uxtb	r2, r2
 801cca2:	f883 22a4 	strb.w	r2, [r3, #676]	; 0x2a4
            shell->line_curpos++;
 801cca6:	4b14      	ldr	r3, [pc, #80]	; (801ccf8 <finsh_thread_entry+0x688>)
 801cca8:	681b      	ldr	r3, [r3, #0]
 801ccaa:	f893 22a5 	ldrb.w	r2, [r3, #677]	; 0x2a5
 801ccae:	3201      	adds	r2, #1
 801ccb0:	b2d2      	uxtb	r2, r2
 801ccb2:	f883 22a5 	strb.w	r2, [r3, #677]	; 0x2a5
            if (shell->line_position >= 80)
 801ccb6:	4b10      	ldr	r3, [pc, #64]	; (801ccf8 <finsh_thread_entry+0x688>)
 801ccb8:	681b      	ldr	r3, [r3, #0]
 801ccba:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801ccbe:	2b4f      	cmp	r3, #79	; 0x4f
 801ccc0:	d909      	bls.n	801ccd6 <finsh_thread_entry+0x666>
            {
                /* clear command line */
                shell->line_position = 0;
 801ccc2:	4b0d      	ldr	r3, [pc, #52]	; (801ccf8 <finsh_thread_entry+0x688>)
 801ccc4:	681b      	ldr	r3, [r3, #0]
 801ccc6:	2200      	movs	r2, #0
 801ccc8:	f883 22a4 	strb.w	r2, [r3, #676]	; 0x2a4
                shell->line_curpos = 0;
 801cccc:	4b0a      	ldr	r3, [pc, #40]	; (801ccf8 <finsh_thread_entry+0x688>)
 801ccce:	681b      	ldr	r3, [r3, #0]
 801ccd0:	2200      	movs	r2, #0
 801ccd2:	f883 22a5 	strb.w	r2, [r3, #677]	; 0x2a5
    {
        /* wait receive */
        if (rt_sem_take(&shell->rx_sem, RT_WAITING_FOREVER) != RT_EOK) continue;

        /* read one character from device */
        while (rt_device_read(shell->device, 0, &ch, 1) == 1)
 801ccd6:	4b08      	ldr	r3, [pc, #32]	; (801ccf8 <finsh_thread_entry+0x688>)
 801ccd8:	681b      	ldr	r3, [r3, #0]
 801ccda:	f8d3 22a8 	ldr.w	r2, [r3, #680]	; 0x2a8
 801ccde:	f107 030b 	add.w	r3, r7, #11
 801cce2:	4610      	mov	r0, r2
 801cce4:	2100      	movs	r1, #0
 801cce6:	461a      	mov	r2, r3
 801cce8:	2301      	movs	r3, #1
 801ccea:	f7f9 f847 	bl	8015d7c <rt_device_read>
 801ccee:	4603      	mov	r3, r0
 801ccf0:	2b01      	cmp	r3, #1
 801ccf2:	f43f ad0c 	beq.w	801c70e <finsh_thread_entry+0x9e>
                /* clear command line */
                shell->line_position = 0;
                shell->line_curpos = 0;
            }
        } /* end of device read */
    }
 801ccf6:	e4fe      	b.n	801c6f6 <finsh_thread_entry+0x86>
 801ccf8:	20012bb4 	.word	0x20012bb4
 801ccfc:	080283c0 	.word	0x080283c0
 801cd00:	080283ac 	.word	0x080283ac
 801cd04:	080283b0 	.word	0x080283b0

0801cd08 <finsh_system_function_init>:
}

void finsh_system_function_init(const void *begin, const void *end)
{
 801cd08:	b480      	push	{r7}
 801cd0a:	b083      	sub	sp, #12
 801cd0c:	af00      	add	r7, sp, #0
 801cd0e:	6078      	str	r0, [r7, #4]
 801cd10:	6039      	str	r1, [r7, #0]
    _syscall_table_begin = (struct finsh_syscall *) begin;
 801cd12:	4a05      	ldr	r2, [pc, #20]	; (801cd28 <finsh_system_function_init+0x20>)
 801cd14:	687b      	ldr	r3, [r7, #4]
 801cd16:	6013      	str	r3, [r2, #0]
    _syscall_table_end = (struct finsh_syscall *) end;
 801cd18:	4a04      	ldr	r2, [pc, #16]	; (801cd2c <finsh_system_function_init+0x24>)
 801cd1a:	683b      	ldr	r3, [r7, #0]
 801cd1c:	6013      	str	r3, [r2, #0]
}
 801cd1e:	370c      	adds	r7, #12
 801cd20:	46bd      	mov	sp, r7
 801cd22:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cd26:	4770      	bx	lr
 801cd28:	2001218c 	.word	0x2001218c
 801cd2c:	20012190 	.word	0x20012190

0801cd30 <finsh_system_var_init>:

void finsh_system_var_init(const void *begin, const void *end)
{
 801cd30:	b480      	push	{r7}
 801cd32:	b083      	sub	sp, #12
 801cd34:	af00      	add	r7, sp, #0
 801cd36:	6078      	str	r0, [r7, #4]
 801cd38:	6039      	str	r1, [r7, #0]
    _sysvar_table_begin = (struct finsh_sysvar *) begin;
 801cd3a:	4a05      	ldr	r2, [pc, #20]	; (801cd50 <finsh_system_var_init+0x20>)
 801cd3c:	687b      	ldr	r3, [r7, #4]
 801cd3e:	6013      	str	r3, [r2, #0]
    _sysvar_table_end = (struct finsh_sysvar *) end;
 801cd40:	4a04      	ldr	r2, [pc, #16]	; (801cd54 <finsh_system_var_init+0x24>)
 801cd42:	683b      	ldr	r3, [r7, #0]
 801cd44:	6013      	str	r3, [r2, #0]
}
 801cd46:	370c      	adds	r7, #12
 801cd48:	46bd      	mov	sp, r7
 801cd4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cd4e:	4770      	bx	lr
 801cd50:	20012194 	.word	0x20012194
 801cd54:	20012198 	.word	0x20012198

0801cd58 <finsh_system_init>:
 * @ingroup finsh
 *
 * This function will initialize finsh shell
 */
int finsh_system_init(void)
{
 801cd58:	b580      	push	{r7, lr}
 801cd5a:	b086      	sub	sp, #24
 801cd5c:	af04      	add	r7, sp, #16
    /* GNU GCC Compiler and TI CCS */
    extern const int __fsymtab_start;
    extern const int __fsymtab_end;
    extern const int __vsymtab_start;
    extern const int __vsymtab_end;
    finsh_system_function_init(&__fsymtab_start, &__fsymtab_end);
 801cd5e:	4822      	ldr	r0, [pc, #136]	; (801cde8 <finsh_system_init+0x90>)
 801cd60:	4922      	ldr	r1, [pc, #136]	; (801cdec <finsh_system_init+0x94>)
 801cd62:	f7ff ffd1 	bl	801cd08 <finsh_system_function_init>
    finsh_system_var_init(&__vsymtab_start, &__vsymtab_end);
 801cd66:	4822      	ldr	r0, [pc, #136]	; (801cdf0 <finsh_system_init+0x98>)
 801cd68:	4922      	ldr	r1, [pc, #136]	; (801cdf4 <finsh_system_init+0x9c>)
 801cd6a:	f7ff ffe1 	bl	801cd30 <finsh_system_var_init>
#endif
#endif

    /* create or set shell structure */
#ifdef RT_USING_HEAP
    shell = (struct finsh_shell *)rt_malloc(sizeof(struct finsh_shell));
 801cd6e:	f44f 702b 	mov.w	r0, #684	; 0x2ac
 801cd72:	f7fa ff51 	bl	8017c18 <rt_malloc>
 801cd76:	4602      	mov	r2, r0
 801cd78:	4b1f      	ldr	r3, [pc, #124]	; (801cdf8 <finsh_system_init+0xa0>)
 801cd7a:	601a      	str	r2, [r3, #0]
    if (shell == RT_NULL)
 801cd7c:	4b1e      	ldr	r3, [pc, #120]	; (801cdf8 <finsh_system_init+0xa0>)
 801cd7e:	681b      	ldr	r3, [r3, #0]
 801cd80:	2b00      	cmp	r3, #0
 801cd82:	d105      	bne.n	801cd90 <finsh_system_init+0x38>
    {
        rt_kprintf("no memory for shell\n");
 801cd84:	481d      	ldr	r0, [pc, #116]	; (801cdfc <finsh_system_init+0xa4>)
 801cd86:	f7fa fd99 	bl	80178bc <rt_kprintf>
        return -1;
 801cd8a:	f04f 33ff 	mov.w	r3, #4294967295
 801cd8e:	e026      	b.n	801cdde <finsh_system_init+0x86>
    }
#else
    shell = &_shell;
#endif

    memset(shell, 0, sizeof(struct finsh_shell));
 801cd90:	4b19      	ldr	r3, [pc, #100]	; (801cdf8 <finsh_system_init+0xa0>)
 801cd92:	681b      	ldr	r3, [r3, #0]
 801cd94:	4618      	mov	r0, r3
 801cd96:	2100      	movs	r1, #0
 801cd98:	f44f 722b 	mov.w	r2, #684	; 0x2ac
 801cd9c:	f005 fff0 	bl	8022d80 <memset>

    rt_sem_init(&(shell->rx_sem), "shrx", 0, 0);
 801cda0:	4b15      	ldr	r3, [pc, #84]	; (801cdf8 <finsh_system_init+0xa0>)
 801cda2:	681b      	ldr	r3, [r3, #0]
 801cda4:	4618      	mov	r0, r3
 801cda6:	4916      	ldr	r1, [pc, #88]	; (801ce00 <finsh_system_init+0xa8>)
 801cda8:	2200      	movs	r2, #0
 801cdaa:	2300      	movs	r3, #0
 801cdac:	f7f9 fa0c 	bl	80161c8 <rt_sem_init>
    result = rt_thread_init(&finsh_thread,
 801cdb0:	4b14      	ldr	r3, [pc, #80]	; (801ce04 <finsh_system_init+0xac>)
 801cdb2:	9300      	str	r3, [sp, #0]
 801cdb4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 801cdb8:	9301      	str	r3, [sp, #4]
 801cdba:	230a      	movs	r3, #10
 801cdbc:	9302      	str	r3, [sp, #8]
 801cdbe:	230a      	movs	r3, #10
 801cdc0:	9303      	str	r3, [sp, #12]
 801cdc2:	4811      	ldr	r0, [pc, #68]	; (801ce08 <finsh_system_init+0xb0>)
 801cdc4:	4911      	ldr	r1, [pc, #68]	; (801ce0c <finsh_system_init+0xb4>)
 801cdc6:	4a12      	ldr	r2, [pc, #72]	; (801ce10 <finsh_system_init+0xb8>)
 801cdc8:	2300      	movs	r3, #0
 801cdca:	f7fb fecb 	bl	8018b64 <rt_thread_init>
 801cdce:	6078      	str	r0, [r7, #4]
                            "tshell",
                            finsh_thread_entry, RT_NULL,
                            &finsh_thread_stack[0], sizeof(finsh_thread_stack),
                            FINSH_THREAD_PRIORITY, 10);

    if (result == RT_EOK)
 801cdd0:	687b      	ldr	r3, [r7, #4]
 801cdd2:	2b00      	cmp	r3, #0
 801cdd4:	d102      	bne.n	801cddc <finsh_system_init+0x84>
        rt_thread_startup(&finsh_thread);
 801cdd6:	480c      	ldr	r0, [pc, #48]	; (801ce08 <finsh_system_init+0xb0>)
 801cdd8:	f7fb ff06 	bl	8018be8 <rt_thread_startup>
    return 0;
 801cddc:	2300      	movs	r3, #0
}
 801cdde:	4618      	mov	r0, r3
 801cde0:	3708      	adds	r7, #8
 801cde2:	46bd      	mov	sp, r7
 801cde4:	bd80      	pop	{r7, pc}
 801cde6:	bf00      	nop
 801cde8:	0802a384 	.word	0x0802a384
 801cdec:	0802a5b8 	.word	0x0802a5b8
 801cdf0:	0802a5b8 	.word	0x0802a5b8
 801cdf4:	0802a5c8 	.word	0x0802a5c8
 801cdf8:	20012bb4 	.word	0x20012bb4
 801cdfc:	080283c4 	.word	0x080283c4
 801ce00:	080283dc 	.word	0x080283dc
 801ce04:	20011108 	.word	0x20011108
 801ce08:	20011088 	.word	0x20011088
 801ce0c:	080283e4 	.word	0x080283e4
 801ce10:	0801c671 	.word	0x0801c671

0801ce14 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 801ce14:	b480      	push	{r7}
 801ce16:	b083      	sub	sp, #12
 801ce18:	af00      	add	r7, sp, #0
 801ce1a:	6078      	str	r0, [r7, #4]
    return l->next == l;
 801ce1c:	687b      	ldr	r3, [r7, #4]
 801ce1e:	681a      	ldr	r2, [r3, #0]
 801ce20:	687b      	ldr	r3, [r7, #4]
 801ce22:	429a      	cmp	r2, r3
 801ce24:	bf0c      	ite	eq
 801ce26:	2301      	moveq	r3, #1
 801ce28:	2300      	movne	r3, #0
 801ce2a:	b2db      	uxtb	r3, r3
}
 801ce2c:	4618      	mov	r0, r3
 801ce2e:	370c      	adds	r7, #12
 801ce30:	46bd      	mov	sp, r7
 801ce32:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ce36:	4770      	bx	lr

0801ce38 <rt_list_len>:

#include <rtthread.h>
#include "finsh.h"

rt_inline unsigned int rt_list_len(const rt_list_t *l)
{
 801ce38:	b480      	push	{r7}
 801ce3a:	b085      	sub	sp, #20
 801ce3c:	af00      	add	r7, sp, #0
 801ce3e:	6078      	str	r0, [r7, #4]
    unsigned int len = 0;
 801ce40:	2300      	movs	r3, #0
 801ce42:	60fb      	str	r3, [r7, #12]
    const rt_list_t *p = l;
 801ce44:	687b      	ldr	r3, [r7, #4]
 801ce46:	60bb      	str	r3, [r7, #8]
    while (p->next != l)
 801ce48:	e005      	b.n	801ce56 <rt_list_len+0x1e>
    {
        p = p->next;
 801ce4a:	68bb      	ldr	r3, [r7, #8]
 801ce4c:	681b      	ldr	r3, [r3, #0]
 801ce4e:	60bb      	str	r3, [r7, #8]
        len ++;
 801ce50:	68fb      	ldr	r3, [r7, #12]
 801ce52:	3301      	adds	r3, #1
 801ce54:	60fb      	str	r3, [r7, #12]

rt_inline unsigned int rt_list_len(const rt_list_t *l)
{
    unsigned int len = 0;
    const rt_list_t *p = l;
    while (p->next != l)
 801ce56:	68bb      	ldr	r3, [r7, #8]
 801ce58:	681a      	ldr	r2, [r3, #0]
 801ce5a:	687b      	ldr	r3, [r7, #4]
 801ce5c:	429a      	cmp	r2, r3
 801ce5e:	d1f4      	bne.n	801ce4a <rt_list_len+0x12>
    {
        p = p->next;
        len ++;
    }

    return len;
 801ce60:	68fb      	ldr	r3, [r7, #12]
}
 801ce62:	4618      	mov	r0, r3
 801ce64:	3714      	adds	r7, #20
 801ce66:	46bd      	mov	sp, r7
 801ce68:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ce6c:	4770      	bx	lr
 801ce6e:	bf00      	nop

0801ce70 <hello>:

long hello(void)
{
 801ce70:	b580      	push	{r7, lr}
 801ce72:	af00      	add	r7, sp, #0
    rt_kprintf("Hello RT-Thread!\n");
 801ce74:	4802      	ldr	r0, [pc, #8]	; (801ce80 <hello+0x10>)
 801ce76:	f7fa fd21 	bl	80178bc <rt_kprintf>

    return 0;
 801ce7a:	2300      	movs	r3, #0
}
 801ce7c:	4618      	mov	r0, r3
 801ce7e:	bd80      	pop	{r7, pc}
 801ce80:	080283ec 	.word	0x080283ec

0801ce84 <version>:
FINSH_FUNCTION_EXPORT(hello, say hello world);

extern void rt_show_version(void);
long version(void)
{
 801ce84:	b580      	push	{r7, lr}
 801ce86:	af00      	add	r7, sp, #0
    rt_show_version();
 801ce88:	f7fa f8d8 	bl	801703c <rt_show_version>

    return 0;
 801ce8c:	2300      	movs	r3, #0
}
 801ce8e:	4618      	mov	r0, r3
 801ce90:	bd80      	pop	{r7, pc}
 801ce92:	bf00      	nop

0801ce94 <_list_thread>:
MSH_CMD_EXPORT(version, show RT-Thread version information);

extern struct rt_object_information rt_object_container[];

static long _list_thread(struct rt_list_node *list)
{
 801ce94:	b5b0      	push	{r4, r5, r7, lr}
 801ce96:	b088      	sub	sp, #32
 801ce98:	af02      	add	r7, sp, #8
 801ce9a:	6078      	str	r0, [r7, #4]
    struct rt_thread *thread;
    struct rt_list_node *node;
    rt_uint8_t *ptr;

    rt_kprintf(" thread  pri  status      sp     stack size max used   left tick  error\n");
 801ce9c:	4837      	ldr	r0, [pc, #220]	; (801cf7c <_list_thread+0xe8>)
 801ce9e:	f7fa fd0d 	bl	80178bc <rt_kprintf>
    rt_kprintf("-------- ---- ------- ---------- ---------- ---------- ---------- ---\n");
 801cea2:	4837      	ldr	r0, [pc, #220]	; (801cf80 <_list_thread+0xec>)
 801cea4:	f7fa fd0a 	bl	80178bc <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801cea8:	687b      	ldr	r3, [r7, #4]
 801ceaa:	681b      	ldr	r3, [r3, #0]
 801ceac:	617b      	str	r3, [r7, #20]
 801ceae:	e05c      	b.n	801cf6a <_list_thread+0xd6>
    {
        thread = rt_list_entry(node, struct rt_thread, list);
 801ceb0:	697b      	ldr	r3, [r7, #20]
 801ceb2:	3b0c      	subs	r3, #12
 801ceb4:	60fb      	str	r3, [r7, #12]
        rt_kprintf("%-8.*s 0x%02x", RT_NAME_MAX, thread->name, thread->current_priority);
 801ceb6:	68fa      	ldr	r2, [r7, #12]
 801ceb8:	68fb      	ldr	r3, [r7, #12]
 801ceba:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 801cebe:	4831      	ldr	r0, [pc, #196]	; (801cf84 <_list_thread+0xf0>)
 801cec0:	2108      	movs	r1, #8
 801cec2:	f7fa fcfb 	bl	80178bc <rt_kprintf>

        if (thread->stat == RT_THREAD_READY)        rt_kprintf(" ready  ");
 801cec6:	68fb      	ldr	r3, [r7, #12]
 801cec8:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801cecc:	2b01      	cmp	r3, #1
 801cece:	d103      	bne.n	801ced8 <_list_thread+0x44>
 801ced0:	482d      	ldr	r0, [pc, #180]	; (801cf88 <_list_thread+0xf4>)
 801ced2:	f7fa fcf3 	bl	80178bc <rt_kprintf>
 801ced6:	e019      	b.n	801cf0c <_list_thread+0x78>
        else if (thread->stat == RT_THREAD_SUSPEND) rt_kprintf(" suspend");
 801ced8:	68fb      	ldr	r3, [r7, #12]
 801ceda:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801cede:	2b02      	cmp	r3, #2
 801cee0:	d103      	bne.n	801ceea <_list_thread+0x56>
 801cee2:	482a      	ldr	r0, [pc, #168]	; (801cf8c <_list_thread+0xf8>)
 801cee4:	f7fa fcea 	bl	80178bc <rt_kprintf>
 801cee8:	e010      	b.n	801cf0c <_list_thread+0x78>
        else if (thread->stat == RT_THREAD_INIT)    rt_kprintf(" init   ");
 801ceea:	68fb      	ldr	r3, [r7, #12]
 801ceec:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801cef0:	2b00      	cmp	r3, #0
 801cef2:	d103      	bne.n	801cefc <_list_thread+0x68>
 801cef4:	4826      	ldr	r0, [pc, #152]	; (801cf90 <_list_thread+0xfc>)
 801cef6:	f7fa fce1 	bl	80178bc <rt_kprintf>
 801cefa:	e007      	b.n	801cf0c <_list_thread+0x78>
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");
 801cefc:	68fb      	ldr	r3, [r7, #12]
 801cefe:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801cf02:	2b04      	cmp	r3, #4
 801cf04:	d102      	bne.n	801cf0c <_list_thread+0x78>
 801cf06:	4823      	ldr	r0, [pc, #140]	; (801cf94 <_list_thread+0x100>)
 801cf08:	f7fa fcd8 	bl	80178bc <rt_kprintf>

        ptr = (rt_uint8_t*)thread->stack_addr;
 801cf0c:	68fb      	ldr	r3, [r7, #12]
 801cf0e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801cf10:	613b      	str	r3, [r7, #16]
        while (*ptr == '#')ptr ++;
 801cf12:	e002      	b.n	801cf1a <_list_thread+0x86>
 801cf14:	693b      	ldr	r3, [r7, #16]
 801cf16:	3301      	adds	r3, #1
 801cf18:	613b      	str	r3, [r7, #16]
 801cf1a:	693b      	ldr	r3, [r7, #16]
 801cf1c:	781b      	ldrb	r3, [r3, #0]
 801cf1e:	2b23      	cmp	r3, #35	; 0x23
 801cf20:	d0f8      	beq.n	801cf14 <_list_thread+0x80>

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
 801cf22:	68fb      	ldr	r3, [r7, #12]
 801cf24:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
 801cf26:	461a      	mov	r2, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
 801cf28:	68fb      	ldr	r3, [r7, #12]
 801cf2a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801cf2c:	4619      	mov	r1, r3
 801cf2e:	68fb      	ldr	r3, [r7, #12]
 801cf30:	69db      	ldr	r3, [r3, #28]
 801cf32:	1acb      	subs	r3, r1, r3
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
 801cf34:	18d1      	adds	r1, r2, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
            thread->stack_size,
 801cf36:	68fb      	ldr	r3, [r7, #12]
 801cf38:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
 801cf3a:	461d      	mov	r5, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
            thread->stack_size,
            thread->stack_size - ((rt_uint32_t) ptr - (rt_uint32_t)thread->stack_addr),
 801cf3c:	68fb      	ldr	r3, [r7, #12]
 801cf3e:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
 801cf40:	461a      	mov	r2, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
            thread->stack_size,
            thread->stack_size - ((rt_uint32_t) ptr - (rt_uint32_t)thread->stack_addr),
 801cf42:	68fb      	ldr	r3, [r7, #12]
 801cf44:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801cf46:	4618      	mov	r0, r3
 801cf48:	693b      	ldr	r3, [r7, #16]
 801cf4a:	1ac3      	subs	r3, r0, r3
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
 801cf4c:	18d4      	adds	r4, r2, r3
 801cf4e:	68fb      	ldr	r3, [r7, #12]
 801cf50:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 801cf52:	68fb      	ldr	r3, [r7, #12]
 801cf54:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801cf56:	9200      	str	r2, [sp, #0]
 801cf58:	9301      	str	r3, [sp, #4]
 801cf5a:	480f      	ldr	r0, [pc, #60]	; (801cf98 <_list_thread+0x104>)
 801cf5c:	462a      	mov	r2, r5
 801cf5e:	4623      	mov	r3, r4
 801cf60:	f7fa fcac 	bl	80178bc <rt_kprintf>
    struct rt_list_node *node;
    rt_uint8_t *ptr;

    rt_kprintf(" thread  pri  status      sp     stack size max used   left tick  error\n");
    rt_kprintf("-------- ---- ------- ---------- ---------- ---------- ---------- ---\n");
    for (node = list->next; node != list; node = node->next)
 801cf64:	697b      	ldr	r3, [r7, #20]
 801cf66:	681b      	ldr	r3, [r3, #0]
 801cf68:	617b      	str	r3, [r7, #20]
 801cf6a:	697a      	ldr	r2, [r7, #20]
 801cf6c:	687b      	ldr	r3, [r7, #4]
 801cf6e:	429a      	cmp	r2, r3
 801cf70:	d19e      	bne.n	801ceb0 <_list_thread+0x1c>
            thread->stack_size - ((rt_uint32_t) ptr - (rt_uint32_t)thread->stack_addr),
            thread->remaining_tick,
            thread->error);
    }
	
    return 0;
 801cf72:	2300      	movs	r3, #0
}
 801cf74:	4618      	mov	r0, r3
 801cf76:	3718      	adds	r7, #24
 801cf78:	46bd      	mov	sp, r7
 801cf7a:	bdb0      	pop	{r4, r5, r7, pc}
 801cf7c:	08028400 	.word	0x08028400
 801cf80:	0802844c 	.word	0x0802844c
 801cf84:	08028494 	.word	0x08028494
 801cf88:	080284a4 	.word	0x080284a4
 801cf8c:	080284b0 	.word	0x080284b0
 801cf90:	080284bc 	.word	0x080284bc
 801cf94:	080284c8 	.word	0x080284c8
 801cf98:	080284d4 	.word	0x080284d4

0801cf9c <list_thread>:

long list_thread(void)
{
 801cf9c:	b580      	push	{r7, lr}
 801cf9e:	af00      	add	r7, sp, #0
    return _list_thread(&rt_object_container[RT_Object_Class_Thread].object_list);
 801cfa0:	4802      	ldr	r0, [pc, #8]	; (801cfac <list_thread+0x10>)
 801cfa2:	f7ff ff77 	bl	801ce94 <_list_thread>
 801cfa6:	4603      	mov	r3, r0
}
 801cfa8:	4618      	mov	r0, r3
 801cfaa:	bd80      	pop	{r7, pc}
 801cfac:	20010020 	.word	0x20010020

0801cfb0 <show_wait_queue>:
FINSH_FUNCTION_EXPORT(list_thread, list thread);
MSH_CMD_EXPORT(list_thread, list thread);

static void show_wait_queue(struct rt_list_node *list)
{
 801cfb0:	b580      	push	{r7, lr}
 801cfb2:	b084      	sub	sp, #16
 801cfb4:	af00      	add	r7, sp, #0
 801cfb6:	6078      	str	r0, [r7, #4]
    struct rt_thread *thread;
    struct rt_list_node *node;

    for (node = list->next; node != list; node = node->next)
 801cfb8:	687b      	ldr	r3, [r7, #4]
 801cfba:	681b      	ldr	r3, [r3, #0]
 801cfbc:	60fb      	str	r3, [r7, #12]
 801cfbe:	e012      	b.n	801cfe6 <show_wait_queue+0x36>
    {
        thread = rt_list_entry(node, struct rt_thread, tlist);
 801cfc0:	68fb      	ldr	r3, [r7, #12]
 801cfc2:	3b14      	subs	r3, #20
 801cfc4:	60bb      	str	r3, [r7, #8]
        rt_kprintf("%s", thread->name);
 801cfc6:	68bb      	ldr	r3, [r7, #8]
 801cfc8:	480a      	ldr	r0, [pc, #40]	; (801cff4 <show_wait_queue+0x44>)
 801cfca:	4619      	mov	r1, r3
 801cfcc:	f7fa fc76 	bl	80178bc <rt_kprintf>

        if (node->next != list)
 801cfd0:	68fb      	ldr	r3, [r7, #12]
 801cfd2:	681a      	ldr	r2, [r3, #0]
 801cfd4:	687b      	ldr	r3, [r7, #4]
 801cfd6:	429a      	cmp	r2, r3
 801cfd8:	d002      	beq.n	801cfe0 <show_wait_queue+0x30>
            rt_kprintf("/");
 801cfda:	4807      	ldr	r0, [pc, #28]	; (801cff8 <show_wait_queue+0x48>)
 801cfdc:	f7fa fc6e 	bl	80178bc <rt_kprintf>
static void show_wait_queue(struct rt_list_node *list)
{
    struct rt_thread *thread;
    struct rt_list_node *node;

    for (node = list->next; node != list; node = node->next)
 801cfe0:	68fb      	ldr	r3, [r7, #12]
 801cfe2:	681b      	ldr	r3, [r3, #0]
 801cfe4:	60fb      	str	r3, [r7, #12]
 801cfe6:	68fa      	ldr	r2, [r7, #12]
 801cfe8:	687b      	ldr	r3, [r7, #4]
 801cfea:	429a      	cmp	r2, r3
 801cfec:	d1e8      	bne.n	801cfc0 <show_wait_queue+0x10>
        rt_kprintf("%s", thread->name);

        if (node->next != list)
            rt_kprintf("/");
    }
}
 801cfee:	3710      	adds	r7, #16
 801cff0:	46bd      	mov	sp, r7
 801cff2:	bd80      	pop	{r7, pc}
 801cff4:	080284f8 	.word	0x080284f8
 801cff8:	080284fc 	.word	0x080284fc

0801cffc <_list_sem>:

#ifdef RT_USING_SEMAPHORE
static long _list_sem(struct rt_list_node *list)
{
 801cffc:	b5b0      	push	{r4, r5, r7, lr}
 801cffe:	b086      	sub	sp, #24
 801d000:	af02      	add	r7, sp, #8
 801d002:	6078      	str	r0, [r7, #4]
    struct rt_semaphore *sem;
    struct rt_list_node *node;

    rt_kprintf("semaphore v   suspend thread\n");
 801d004:	4825      	ldr	r0, [pc, #148]	; (801d09c <_list_sem+0xa0>)
 801d006:	f7fa fc59 	bl	80178bc <rt_kprintf>
    rt_kprintf("--------  --- --------------\n");
 801d00a:	4825      	ldr	r0, [pc, #148]	; (801d0a0 <_list_sem+0xa4>)
 801d00c:	f7fa fc56 	bl	80178bc <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801d010:	687b      	ldr	r3, [r7, #4]
 801d012:	681b      	ldr	r3, [r3, #0]
 801d014:	60fb      	str	r3, [r7, #12]
 801d016:	e038      	b.n	801d08a <_list_sem+0x8e>
    {
        sem = (struct rt_semaphore *)(rt_list_entry(node, struct rt_object, list));
 801d018:	68fb      	ldr	r3, [r7, #12]
 801d01a:	3b0c      	subs	r3, #12
 801d01c:	60bb      	str	r3, [r7, #8]
        if (!rt_list_isempty(&sem->parent.suspend_thread))
 801d01e:	68bb      	ldr	r3, [r7, #8]
 801d020:	3314      	adds	r3, #20
 801d022:	4618      	mov	r0, r3
 801d024:	f7ff fef6 	bl	801ce14 <rt_list_isempty>
 801d028:	4603      	mov	r3, r0
 801d02a:	2b00      	cmp	r3, #0
 801d02c:	d119      	bne.n	801d062 <_list_sem+0x66>
        {
            rt_kprintf("%-8.*s  %03d %d:", 
                       RT_NAME_MAX,
                       sem->parent.parent.name,
 801d02e:	68bc      	ldr	r4, [r7, #8]
                       sem->value,
 801d030:	68bb      	ldr	r3, [r7, #8]
 801d032:	8b9b      	ldrh	r3, [r3, #28]
    for (node = list->next; node != list; node = node->next)
    {
        sem = (struct rt_semaphore *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&sem->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  %03d %d:", 
 801d034:	461d      	mov	r5, r3
                       RT_NAME_MAX,
                       sem->parent.parent.name,
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
 801d036:	68bb      	ldr	r3, [r7, #8]
 801d038:	3314      	adds	r3, #20
    for (node = list->next; node != list; node = node->next)
    {
        sem = (struct rt_semaphore *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&sem->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  %03d %d:", 
 801d03a:	4618      	mov	r0, r3
 801d03c:	f7ff fefc 	bl	801ce38 <rt_list_len>
 801d040:	4603      	mov	r3, r0
 801d042:	9300      	str	r3, [sp, #0]
 801d044:	4817      	ldr	r0, [pc, #92]	; (801d0a4 <_list_sem+0xa8>)
 801d046:	2108      	movs	r1, #8
 801d048:	4622      	mov	r2, r4
 801d04a:	462b      	mov	r3, r5
 801d04c:	f7fa fc36 	bl	80178bc <rt_kprintf>
                       RT_NAME_MAX,
                       sem->parent.parent.name,
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
            show_wait_queue(&(sem->parent.suspend_thread));
 801d050:	68bb      	ldr	r3, [r7, #8]
 801d052:	3314      	adds	r3, #20
 801d054:	4618      	mov	r0, r3
 801d056:	f7ff ffab 	bl	801cfb0 <show_wait_queue>
            rt_kprintf("\n");
 801d05a:	4813      	ldr	r0, [pc, #76]	; (801d0a8 <_list_sem+0xac>)
 801d05c:	f7fa fc2e 	bl	80178bc <rt_kprintf>
 801d060:	e010      	b.n	801d084 <_list_sem+0x88>
        }
        else
        {
            rt_kprintf("%-8.*s  %03d %d\n",
                       RT_NAME_MAX,
                       sem->parent.parent.name,
 801d062:	68bc      	ldr	r4, [r7, #8]
                       sem->value,
 801d064:	68bb      	ldr	r3, [r7, #8]
 801d066:	8b9b      	ldrh	r3, [r3, #28]
            show_wait_queue(&(sem->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s  %03d %d\n",
 801d068:	461d      	mov	r5, r3
                       RT_NAME_MAX,
                       sem->parent.parent.name,
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
 801d06a:	68bb      	ldr	r3, [r7, #8]
 801d06c:	3314      	adds	r3, #20
            show_wait_queue(&(sem->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s  %03d %d\n",
 801d06e:	4618      	mov	r0, r3
 801d070:	f7ff fee2 	bl	801ce38 <rt_list_len>
 801d074:	4603      	mov	r3, r0
 801d076:	9300      	str	r3, [sp, #0]
 801d078:	480c      	ldr	r0, [pc, #48]	; (801d0ac <_list_sem+0xb0>)
 801d07a:	2108      	movs	r1, #8
 801d07c:	4622      	mov	r2, r4
 801d07e:	462b      	mov	r3, r5
 801d080:	f7fa fc1c 	bl	80178bc <rt_kprintf>
    struct rt_semaphore *sem;
    struct rt_list_node *node;

    rt_kprintf("semaphore v   suspend thread\n");
    rt_kprintf("--------  --- --------------\n");
    for (node = list->next; node != list; node = node->next)
 801d084:	68fb      	ldr	r3, [r7, #12]
 801d086:	681b      	ldr	r3, [r3, #0]
 801d088:	60fb      	str	r3, [r7, #12]
 801d08a:	68fa      	ldr	r2, [r7, #12]
 801d08c:	687b      	ldr	r3, [r7, #4]
 801d08e:	429a      	cmp	r2, r3
 801d090:	d1c2      	bne.n	801d018 <_list_sem+0x1c>
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
        }
    }

    return 0;
 801d092:	2300      	movs	r3, #0
}
 801d094:	4618      	mov	r0, r3
 801d096:	3710      	adds	r7, #16
 801d098:	46bd      	mov	sp, r7
 801d09a:	bdb0      	pop	{r4, r5, r7, pc}
 801d09c:	08028500 	.word	0x08028500
 801d0a0:	08028520 	.word	0x08028520
 801d0a4:	08028540 	.word	0x08028540
 801d0a8:	08028554 	.word	0x08028554
 801d0ac:	08028558 	.word	0x08028558

0801d0b0 <list_sem>:

long list_sem(void)
{
 801d0b0:	b580      	push	{r7, lr}
 801d0b2:	af00      	add	r7, sp, #0
    return _list_sem(&rt_object_container[RT_Object_Class_Semaphore].object_list);
 801d0b4:	4802      	ldr	r0, [pc, #8]	; (801d0c0 <list_sem+0x10>)
 801d0b6:	f7ff ffa1 	bl	801cffc <_list_sem>
 801d0ba:	4603      	mov	r3, r0
}
 801d0bc:	4618      	mov	r0, r3
 801d0be:	bd80      	pop	{r7, pc}
 801d0c0:	20010030 	.word	0x20010030

0801d0c4 <_list_event>:
MSH_CMD_EXPORT(list_sem, list semaphore in system);
#endif

#ifdef RT_USING_EVENT
static long _list_event(struct rt_list_node *list)
{
 801d0c4:	b5b0      	push	{r4, r5, r7, lr}
 801d0c6:	b086      	sub	sp, #24
 801d0c8:	af02      	add	r7, sp, #8
 801d0ca:	6078      	str	r0, [r7, #4]
    struct rt_event *e;
    struct rt_list_node *node;

    rt_kprintf("event    set        suspend thread\n");
 801d0cc:	4820      	ldr	r0, [pc, #128]	; (801d150 <_list_event+0x8c>)
 801d0ce:	f7fa fbf5 	bl	80178bc <rt_kprintf>
    rt_kprintf("-------- ---------- --------------\n");
 801d0d2:	4820      	ldr	r0, [pc, #128]	; (801d154 <_list_event+0x90>)
 801d0d4:	f7fa fbf2 	bl	80178bc <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801d0d8:	687b      	ldr	r3, [r7, #4]
 801d0da:	681b      	ldr	r3, [r3, #0]
 801d0dc:	60fb      	str	r3, [r7, #12]
 801d0de:	e02d      	b.n	801d13c <_list_event+0x78>
    {
        e = (struct rt_event *)(rt_list_entry(node, struct rt_object, list));
 801d0e0:	68fb      	ldr	r3, [r7, #12]
 801d0e2:	3b0c      	subs	r3, #12
 801d0e4:	60bb      	str	r3, [r7, #8]
        if (!rt_list_isempty(&e->parent.suspend_thread))
 801d0e6:	68bb      	ldr	r3, [r7, #8]
 801d0e8:	3314      	adds	r3, #20
 801d0ea:	4618      	mov	r0, r3
 801d0ec:	f7ff fe92 	bl	801ce14 <rt_list_isempty>
 801d0f0:	4603      	mov	r3, r0
 801d0f2:	2b00      	cmp	r3, #0
 801d0f4:	d118      	bne.n	801d128 <_list_event+0x64>
        {
            rt_kprintf("%-8.*s  0x%08x %03d:",
                       RT_NAME_MAX,
                       e->parent.parent.name,
 801d0f6:	68bd      	ldr	r5, [r7, #8]
    for (node = list->next; node != list; node = node->next)
    {
        e = (struct rt_event *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&e->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  0x%08x %03d:",
 801d0f8:	68bb      	ldr	r3, [r7, #8]
 801d0fa:	69dc      	ldr	r4, [r3, #28]
                       RT_NAME_MAX,
                       e->parent.parent.name,
                       e->set,
                       rt_list_len(&e->parent.suspend_thread));
 801d0fc:	68bb      	ldr	r3, [r7, #8]
 801d0fe:	3314      	adds	r3, #20
    for (node = list->next; node != list; node = node->next)
    {
        e = (struct rt_event *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&e->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  0x%08x %03d:",
 801d100:	4618      	mov	r0, r3
 801d102:	f7ff fe99 	bl	801ce38 <rt_list_len>
 801d106:	4603      	mov	r3, r0
 801d108:	9300      	str	r3, [sp, #0]
 801d10a:	4813      	ldr	r0, [pc, #76]	; (801d158 <_list_event+0x94>)
 801d10c:	2108      	movs	r1, #8
 801d10e:	462a      	mov	r2, r5
 801d110:	4623      	mov	r3, r4
 801d112:	f7fa fbd3 	bl	80178bc <rt_kprintf>
                       RT_NAME_MAX,
                       e->parent.parent.name,
                       e->set,
                       rt_list_len(&e->parent.suspend_thread));
            show_wait_queue(&(e->parent.suspend_thread));
 801d116:	68bb      	ldr	r3, [r7, #8]
 801d118:	3314      	adds	r3, #20
 801d11a:	4618      	mov	r0, r3
 801d11c:	f7ff ff48 	bl	801cfb0 <show_wait_queue>
            rt_kprintf("\n");
 801d120:	480e      	ldr	r0, [pc, #56]	; (801d15c <_list_event+0x98>)
 801d122:	f7fa fbcb 	bl	80178bc <rt_kprintf>
 801d126:	e006      	b.n	801d136 <_list_event+0x72>
        }
        else
        {
            rt_kprintf("%-8.*s  0x%08x 0\n",
                       RT_NAME_MAX, e->parent.parent.name, e->set);
 801d128:	68ba      	ldr	r2, [r7, #8]
            show_wait_queue(&(e->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s  0x%08x 0\n",
 801d12a:	68bb      	ldr	r3, [r7, #8]
 801d12c:	69db      	ldr	r3, [r3, #28]
 801d12e:	480c      	ldr	r0, [pc, #48]	; (801d160 <_list_event+0x9c>)
 801d130:	2108      	movs	r1, #8
 801d132:	f7fa fbc3 	bl	80178bc <rt_kprintf>
    struct rt_event *e;
    struct rt_list_node *node;

    rt_kprintf("event    set        suspend thread\n");
    rt_kprintf("-------- ---------- --------------\n");
    for (node = list->next; node != list; node = node->next)
 801d136:	68fb      	ldr	r3, [r7, #12]
 801d138:	681b      	ldr	r3, [r3, #0]
 801d13a:	60fb      	str	r3, [r7, #12]
 801d13c:	68fa      	ldr	r2, [r7, #12]
 801d13e:	687b      	ldr	r3, [r7, #4]
 801d140:	429a      	cmp	r2, r3
 801d142:	d1cd      	bne.n	801d0e0 <_list_event+0x1c>
            rt_kprintf("%-8.*s  0x%08x 0\n",
                       RT_NAME_MAX, e->parent.parent.name, e->set);
        }
    }

    return 0;
 801d144:	2300      	movs	r3, #0
}
 801d146:	4618      	mov	r0, r3
 801d148:	3710      	adds	r7, #16
 801d14a:	46bd      	mov	sp, r7
 801d14c:	bdb0      	pop	{r4, r5, r7, pc}
 801d14e:	bf00      	nop
 801d150:	0802856c 	.word	0x0802856c
 801d154:	08028590 	.word	0x08028590
 801d158:	080285b4 	.word	0x080285b4
 801d15c:	08028554 	.word	0x08028554
 801d160:	080285cc 	.word	0x080285cc

0801d164 <list_event>:

long list_event(void)
{
 801d164:	b580      	push	{r7, lr}
 801d166:	af00      	add	r7, sp, #0
    return _list_event(&rt_object_container[RT_Object_Class_Event].object_list);
 801d168:	4802      	ldr	r0, [pc, #8]	; (801d174 <list_event+0x10>)
 801d16a:	f7ff ffab 	bl	801d0c4 <_list_event>
 801d16e:	4603      	mov	r3, r0
}
 801d170:	4618      	mov	r0, r3
 801d172:	bd80      	pop	{r7, pc}
 801d174:	20010050 	.word	0x20010050

0801d178 <_list_mutex>:
MSH_CMD_EXPORT(list_event, list event in system);
#endif

#ifdef RT_USING_MUTEX
static long _list_mutex(struct rt_list_node *list)
{
 801d178:	b5f0      	push	{r4, r5, r6, r7, lr}
 801d17a:	b089      	sub	sp, #36	; 0x24
 801d17c:	af04      	add	r7, sp, #16
 801d17e:	6078      	str	r0, [r7, #4]
    struct rt_mutex *m;
    struct rt_list_node *node;

    rt_kprintf("mutex    owner    hold suspend thread\n");
 801d180:	4817      	ldr	r0, [pc, #92]	; (801d1e0 <_list_mutex+0x68>)
 801d182:	f7fa fb9b 	bl	80178bc <rt_kprintf>
    rt_kprintf("-------- -------- ---- --------------\n");
 801d186:	4817      	ldr	r0, [pc, #92]	; (801d1e4 <_list_mutex+0x6c>)
 801d188:	f7fa fb98 	bl	80178bc <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801d18c:	687b      	ldr	r3, [r7, #4]
 801d18e:	681b      	ldr	r3, [r3, #0]
 801d190:	60fb      	str	r3, [r7, #12]
 801d192:	e01b      	b.n	801d1cc <_list_mutex+0x54>
    {
        m = (struct rt_mutex *)(rt_list_entry(node, struct rt_object, list));
 801d194:	68fb      	ldr	r3, [r7, #12]
 801d196:	3b0c      	subs	r3, #12
 801d198:	60bb      	str	r3, [r7, #8]
        rt_kprintf("%-8.*s %-8.*s %04d %d\n",
                   RT_NAME_MAX,
                   m->parent.parent.name,
 801d19a:	68bc      	ldr	r4, [r7, #8]
                   RT_NAME_MAX,
                   m->owner->name,
 801d19c:	68bb      	ldr	r3, [r7, #8]
 801d19e:	6a1b      	ldr	r3, [r3, #32]
 801d1a0:	461e      	mov	r6, r3
                   m->hold,
 801d1a2:	68bb      	ldr	r3, [r7, #8]
 801d1a4:	7fdb      	ldrb	r3, [r3, #31]
    rt_kprintf("mutex    owner    hold suspend thread\n");
    rt_kprintf("-------- -------- ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mutex *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-8.*s %04d %d\n",
 801d1a6:	461d      	mov	r5, r3
                   RT_NAME_MAX,
                   m->parent.parent.name,
                   RT_NAME_MAX,
                   m->owner->name,
                   m->hold,
                   rt_list_len(&m->parent.suspend_thread));
 801d1a8:	68bb      	ldr	r3, [r7, #8]
 801d1aa:	3314      	adds	r3, #20
    rt_kprintf("mutex    owner    hold suspend thread\n");
    rt_kprintf("-------- -------- ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mutex *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-8.*s %04d %d\n",
 801d1ac:	4618      	mov	r0, r3
 801d1ae:	f7ff fe43 	bl	801ce38 <rt_list_len>
 801d1b2:	4603      	mov	r3, r0
 801d1b4:	9600      	str	r6, [sp, #0]
 801d1b6:	9501      	str	r5, [sp, #4]
 801d1b8:	9302      	str	r3, [sp, #8]
 801d1ba:	480b      	ldr	r0, [pc, #44]	; (801d1e8 <_list_mutex+0x70>)
 801d1bc:	2108      	movs	r1, #8
 801d1be:	4622      	mov	r2, r4
 801d1c0:	2308      	movs	r3, #8
 801d1c2:	f7fa fb7b 	bl	80178bc <rt_kprintf>
    struct rt_mutex *m;
    struct rt_list_node *node;

    rt_kprintf("mutex    owner    hold suspend thread\n");
    rt_kprintf("-------- -------- ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
 801d1c6:	68fb      	ldr	r3, [r7, #12]
 801d1c8:	681b      	ldr	r3, [r3, #0]
 801d1ca:	60fb      	str	r3, [r7, #12]
 801d1cc:	68fa      	ldr	r2, [r7, #12]
 801d1ce:	687b      	ldr	r3, [r7, #4]
 801d1d0:	429a      	cmp	r2, r3
 801d1d2:	d1df      	bne.n	801d194 <_list_mutex+0x1c>
                   m->owner->name,
                   m->hold,
                   rt_list_len(&m->parent.suspend_thread));
    }

    return 0;
 801d1d4:	2300      	movs	r3, #0
}
 801d1d6:	4618      	mov	r0, r3
 801d1d8:	3714      	adds	r7, #20
 801d1da:	46bd      	mov	sp, r7
 801d1dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801d1de:	bf00      	nop
 801d1e0:	080285e0 	.word	0x080285e0
 801d1e4:	08028608 	.word	0x08028608
 801d1e8:	08028630 	.word	0x08028630

0801d1ec <list_mutex>:

long list_mutex(void)
{
 801d1ec:	b580      	push	{r7, lr}
 801d1ee:	af00      	add	r7, sp, #0
    return _list_mutex(&rt_object_container[RT_Object_Class_Mutex].object_list);
 801d1f0:	4802      	ldr	r0, [pc, #8]	; (801d1fc <list_mutex+0x10>)
 801d1f2:	f7ff ffc1 	bl	801d178 <_list_mutex>
 801d1f6:	4603      	mov	r3, r0
}
 801d1f8:	4618      	mov	r0, r3
 801d1fa:	bd80      	pop	{r7, pc}
 801d1fc:	20010040 	.word	0x20010040

0801d200 <_list_mailbox>:
MSH_CMD_EXPORT(list_mutex, list mutex in system);
#endif

#ifdef RT_USING_MAILBOX
static long _list_mailbox(struct rt_list_node *list)
{
 801d200:	b5f0      	push	{r4, r5, r6, r7, lr}
 801d202:	b087      	sub	sp, #28
 801d204:	af02      	add	r7, sp, #8
 801d206:	6078      	str	r0, [r7, #4]
    struct rt_mailbox *m;
    struct rt_list_node *node;

    rt_kprintf("mailbox  entry size suspend thread\n");
 801d208:	4829      	ldr	r0, [pc, #164]	; (801d2b0 <_list_mailbox+0xb0>)
 801d20a:	f7fa fb57 	bl	80178bc <rt_kprintf>
    rt_kprintf("-------- ----  ---- --------------\n");
 801d20e:	4829      	ldr	r0, [pc, #164]	; (801d2b4 <_list_mailbox+0xb4>)
 801d210:	f7fa fb54 	bl	80178bc <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801d214:	687b      	ldr	r3, [r7, #4]
 801d216:	681b      	ldr	r3, [r3, #0]
 801d218:	60fb      	str	r3, [r7, #12]
 801d21a:	e040      	b.n	801d29e <_list_mailbox+0x9e>
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
 801d21c:	68fb      	ldr	r3, [r7, #12]
 801d21e:	3b0c      	subs	r3, #12
 801d220:	60bb      	str	r3, [r7, #8]
        if (!rt_list_isempty(&m->parent.suspend_thread))
 801d222:	68bb      	ldr	r3, [r7, #8]
 801d224:	3314      	adds	r3, #20
 801d226:	4618      	mov	r0, r3
 801d228:	f7ff fdf4 	bl	801ce14 <rt_list_isempty>
 801d22c:	4603      	mov	r3, r0
 801d22e:	2b00      	cmp	r3, #0
 801d230:	d11d      	bne.n	801d26e <_list_mailbox+0x6e>
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
                       RT_NAME_MAX,
                       m->parent.parent.name,
 801d232:	68bc      	ldr	r4, [r7, #8]
                       m->entry,
 801d234:	68bb      	ldr	r3, [r7, #8]
 801d236:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
 801d238:	461e      	mov	r6, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
 801d23a:	68bb      	ldr	r3, [r7, #8]
 801d23c:	8c1b      	ldrh	r3, [r3, #32]
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
 801d23e:	461d      	mov	r5, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
 801d240:	68bb      	ldr	r3, [r7, #8]
 801d242:	3314      	adds	r3, #20
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
 801d244:	4618      	mov	r0, r3
 801d246:	f7ff fdf7 	bl	801ce38 <rt_list_len>
 801d24a:	4603      	mov	r3, r0
 801d24c:	9500      	str	r5, [sp, #0]
 801d24e:	9301      	str	r3, [sp, #4]
 801d250:	4819      	ldr	r0, [pc, #100]	; (801d2b8 <_list_mailbox+0xb8>)
 801d252:	2108      	movs	r1, #8
 801d254:	4622      	mov	r2, r4
 801d256:	4633      	mov	r3, r6
 801d258:	f7fa fb30 	bl	80178bc <rt_kprintf>
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
            show_wait_queue(&(m->parent.suspend_thread));
 801d25c:	68bb      	ldr	r3, [r7, #8]
 801d25e:	3314      	adds	r3, #20
 801d260:	4618      	mov	r0, r3
 801d262:	f7ff fea5 	bl	801cfb0 <show_wait_queue>
            rt_kprintf("\n");
 801d266:	4815      	ldr	r0, [pc, #84]	; (801d2bc <_list_mailbox+0xbc>)
 801d268:	f7fa fb28 	bl	80178bc <rt_kprintf>
 801d26c:	e014      	b.n	801d298 <_list_mailbox+0x98>
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
                       RT_NAME_MAX,
                       m->parent.parent.name,
 801d26e:	68bc      	ldr	r4, [r7, #8]
                       m->entry,
 801d270:	68bb      	ldr	r3, [r7, #8]
 801d272:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
 801d274:	461e      	mov	r6, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
 801d276:	68bb      	ldr	r3, [r7, #8]
 801d278:	8c1b      	ldrh	r3, [r3, #32]
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
 801d27a:	461d      	mov	r5, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
 801d27c:	68bb      	ldr	r3, [r7, #8]
 801d27e:	3314      	adds	r3, #20
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
 801d280:	4618      	mov	r0, r3
 801d282:	f7ff fdd9 	bl	801ce38 <rt_list_len>
 801d286:	4603      	mov	r3, r0
 801d288:	9500      	str	r5, [sp, #0]
 801d28a:	9301      	str	r3, [sp, #4]
 801d28c:	480c      	ldr	r0, [pc, #48]	; (801d2c0 <_list_mailbox+0xc0>)
 801d28e:	2108      	movs	r1, #8
 801d290:	4622      	mov	r2, r4
 801d292:	4633      	mov	r3, r6
 801d294:	f7fa fb12 	bl	80178bc <rt_kprintf>
    struct rt_mailbox *m;
    struct rt_list_node *node;

    rt_kprintf("mailbox  entry size suspend thread\n");
    rt_kprintf("-------- ----  ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
 801d298:	68fb      	ldr	r3, [r7, #12]
 801d29a:	681b      	ldr	r3, [r3, #0]
 801d29c:	60fb      	str	r3, [r7, #12]
 801d29e:	68fa      	ldr	r2, [r7, #12]
 801d2a0:	687b      	ldr	r3, [r7, #4]
 801d2a2:	429a      	cmp	r2, r3
 801d2a4:	d1ba      	bne.n	801d21c <_list_mailbox+0x1c>
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
        }
    }

    return 0;
 801d2a6:	2300      	movs	r3, #0
}
 801d2a8:	4618      	mov	r0, r3
 801d2aa:	3714      	adds	r7, #20
 801d2ac:	46bd      	mov	sp, r7
 801d2ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801d2b0:	08028648 	.word	0x08028648
 801d2b4:	0802866c 	.word	0x0802866c
 801d2b8:	08028690 	.word	0x08028690
 801d2bc:	08028554 	.word	0x08028554
 801d2c0:	080286a8 	.word	0x080286a8

0801d2c4 <list_mailbox>:

long list_mailbox(void)
{
 801d2c4:	b580      	push	{r7, lr}
 801d2c6:	af00      	add	r7, sp, #0
    return _list_mailbox(&rt_object_container[RT_Object_Class_MailBox].object_list);
 801d2c8:	4802      	ldr	r0, [pc, #8]	; (801d2d4 <list_mailbox+0x10>)
 801d2ca:	f7ff ff99 	bl	801d200 <_list_mailbox>
 801d2ce:	4603      	mov	r3, r0
}
 801d2d0:	4618      	mov	r0, r3
 801d2d2:	bd80      	pop	{r7, pc}
 801d2d4:	20010060 	.word	0x20010060

0801d2d8 <_list_msgqueue>:
MSH_CMD_EXPORT(list_mailbox, list mail box in system);
#endif

#ifdef RT_USING_MESSAGEQUEUE
static long _list_msgqueue(struct rt_list_node *list)
{
 801d2d8:	b5b0      	push	{r4, r5, r7, lr}
 801d2da:	b086      	sub	sp, #24
 801d2dc:	af02      	add	r7, sp, #8
 801d2de:	6078      	str	r0, [r7, #4]
    struct rt_messagequeue *m;
    struct rt_list_node *node;

    rt_kprintf("msgqueue entry suspend thread\n");
 801d2e0:	4825      	ldr	r0, [pc, #148]	; (801d378 <_list_msgqueue+0xa0>)
 801d2e2:	f7fa faeb 	bl	80178bc <rt_kprintf>
    rt_kprintf("-------- ----  --------------\n");
 801d2e6:	4825      	ldr	r0, [pc, #148]	; (801d37c <_list_msgqueue+0xa4>)
 801d2e8:	f7fa fae8 	bl	80178bc <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801d2ec:	687b      	ldr	r3, [r7, #4]
 801d2ee:	681b      	ldr	r3, [r3, #0]
 801d2f0:	60fb      	str	r3, [r7, #12]
 801d2f2:	e038      	b.n	801d366 <_list_msgqueue+0x8e>
    {
        m = (struct rt_messagequeue *)(rt_list_entry(node, struct rt_object, list));
 801d2f4:	68fb      	ldr	r3, [r7, #12]
 801d2f6:	3b0c      	subs	r3, #12
 801d2f8:	60bb      	str	r3, [r7, #8]
        if (!rt_list_isempty(&m->parent.suspend_thread))
 801d2fa:	68bb      	ldr	r3, [r7, #8]
 801d2fc:	3314      	adds	r3, #20
 801d2fe:	4618      	mov	r0, r3
 801d300:	f7ff fd88 	bl	801ce14 <rt_list_isempty>
 801d304:	4603      	mov	r3, r0
 801d306:	2b00      	cmp	r3, #0
 801d308:	d119      	bne.n	801d33e <_list_msgqueue+0x66>
        {
            rt_kprintf("%-8.*s %04d  %d:",
                       RT_NAME_MAX,
                       m->parent.parent.name,
 801d30a:	68bc      	ldr	r4, [r7, #8]
                       m->entry,
 801d30c:	68bb      	ldr	r3, [r7, #8]
 801d30e:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_messagequeue *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %d:",
 801d310:	461d      	mov	r5, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
 801d312:	68bb      	ldr	r3, [r7, #8]
 801d314:	3314      	adds	r3, #20
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_messagequeue *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %d:",
 801d316:	4618      	mov	r0, r3
 801d318:	f7ff fd8e 	bl	801ce38 <rt_list_len>
 801d31c:	4603      	mov	r3, r0
 801d31e:	9300      	str	r3, [sp, #0]
 801d320:	4817      	ldr	r0, [pc, #92]	; (801d380 <_list_msgqueue+0xa8>)
 801d322:	2108      	movs	r1, #8
 801d324:	4622      	mov	r2, r4
 801d326:	462b      	mov	r3, r5
 801d328:	f7fa fac8 	bl	80178bc <rt_kprintf>
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
            show_wait_queue(&(m->parent.suspend_thread));
 801d32c:	68bb      	ldr	r3, [r7, #8]
 801d32e:	3314      	adds	r3, #20
 801d330:	4618      	mov	r0, r3
 801d332:	f7ff fe3d 	bl	801cfb0 <show_wait_queue>
            rt_kprintf("\n");
 801d336:	4813      	ldr	r0, [pc, #76]	; (801d384 <_list_msgqueue+0xac>)
 801d338:	f7fa fac0 	bl	80178bc <rt_kprintf>
 801d33c:	e010      	b.n	801d360 <_list_msgqueue+0x88>
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %d\n",
                       RT_NAME_MAX,
                       m->parent.parent.name,
 801d33e:	68bc      	ldr	r4, [r7, #8]
                       m->entry,
 801d340:	68bb      	ldr	r3, [r7, #8]
 801d342:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %d\n",
 801d344:	461d      	mov	r5, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
 801d346:	68bb      	ldr	r3, [r7, #8]
 801d348:	3314      	adds	r3, #20
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %d\n",
 801d34a:	4618      	mov	r0, r3
 801d34c:	f7ff fd74 	bl	801ce38 <rt_list_len>
 801d350:	4603      	mov	r3, r0
 801d352:	9300      	str	r3, [sp, #0]
 801d354:	480c      	ldr	r0, [pc, #48]	; (801d388 <_list_msgqueue+0xb0>)
 801d356:	2108      	movs	r1, #8
 801d358:	4622      	mov	r2, r4
 801d35a:	462b      	mov	r3, r5
 801d35c:	f7fa faae 	bl	80178bc <rt_kprintf>
    struct rt_messagequeue *m;
    struct rt_list_node *node;

    rt_kprintf("msgqueue entry suspend thread\n");
    rt_kprintf("-------- ----  --------------\n");
    for (node = list->next; node != list; node = node->next)
 801d360:	68fb      	ldr	r3, [r7, #12]
 801d362:	681b      	ldr	r3, [r3, #0]
 801d364:	60fb      	str	r3, [r7, #12]
 801d366:	68fa      	ldr	r2, [r7, #12]
 801d368:	687b      	ldr	r3, [r7, #4]
 801d36a:	429a      	cmp	r2, r3
 801d36c:	d1c2      	bne.n	801d2f4 <_list_msgqueue+0x1c>
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
        }
    }

    return 0;
 801d36e:	2300      	movs	r3, #0
}
 801d370:	4618      	mov	r0, r3
 801d372:	3710      	adds	r7, #16
 801d374:	46bd      	mov	sp, r7
 801d376:	bdb0      	pop	{r4, r5, r7, pc}
 801d378:	080286c0 	.word	0x080286c0
 801d37c:	080286e0 	.word	0x080286e0
 801d380:	08028700 	.word	0x08028700
 801d384:	08028554 	.word	0x08028554
 801d388:	08028714 	.word	0x08028714

0801d38c <list_msgqueue>:

long list_msgqueue(void)
{
 801d38c:	b580      	push	{r7, lr}
 801d38e:	af00      	add	r7, sp, #0
    return _list_msgqueue(&rt_object_container[RT_Object_Class_MessageQueue].object_list);
 801d390:	4802      	ldr	r0, [pc, #8]	; (801d39c <list_msgqueue+0x10>)
 801d392:	f7ff ffa1 	bl	801d2d8 <_list_msgqueue>
 801d396:	4603      	mov	r3, r0
}
 801d398:	4618      	mov	r0, r3
 801d39a:	bd80      	pop	{r7, pc}
 801d39c:	20010070 	.word	0x20010070

0801d3a0 <_list_memheap>:
MSH_CMD_EXPORT(list_msgqueue, list message queue in system);
#endif

#ifdef RT_USING_MEMHEAP
static long _list_memheap(struct rt_list_node *list)
{
 801d3a0:	b5b0      	push	{r4, r5, r7, lr}
 801d3a2:	b086      	sub	sp, #24
 801d3a4:	af02      	add	r7, sp, #8
 801d3a6:	6078      	str	r0, [r7, #4]
    struct rt_memheap *mh;
    struct rt_list_node *node;

    rt_kprintf("memheap  pool size  max used size available size\n");
 801d3a8:	4813      	ldr	r0, [pc, #76]	; (801d3f8 <_list_memheap+0x58>)
 801d3aa:	f7fa fa87 	bl	80178bc <rt_kprintf>
    rt_kprintf("-------- ---------- ------------- --------------\n");
 801d3ae:	4813      	ldr	r0, [pc, #76]	; (801d3fc <_list_memheap+0x5c>)
 801d3b0:	f7fa fa84 	bl	80178bc <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801d3b4:	687b      	ldr	r3, [r7, #4]
 801d3b6:	681b      	ldr	r3, [r3, #0]
 801d3b8:	60fb      	str	r3, [r7, #12]
 801d3ba:	e014      	b.n	801d3e6 <_list_memheap+0x46>
    {
        mh = (struct rt_memheap *)rt_list_entry(node, struct rt_object, list);
 801d3bc:	68fb      	ldr	r3, [r7, #12]
 801d3be:	3b0c      	subs	r3, #12
 801d3c0:	60bb      	str	r3, [r7, #8]

        rt_kprintf("%-8.*s %-010d %-013d %-05d\n",
                   RT_NAME_MAX,
                   mh->parent.name,
 801d3c2:	68bd      	ldr	r5, [r7, #8]
    rt_kprintf("-------- ---------- ------------- --------------\n");
    for (node = list->next; node != list; node = node->next)
    {
        mh = (struct rt_memheap *)rt_list_entry(node, struct rt_object, list);

        rt_kprintf("%-8.*s %-010d %-013d %-05d\n",
 801d3c4:	68bb      	ldr	r3, [r7, #8]
 801d3c6:	699c      	ldr	r4, [r3, #24]
 801d3c8:	68bb      	ldr	r3, [r7, #8]
 801d3ca:	6a1a      	ldr	r2, [r3, #32]
 801d3cc:	68bb      	ldr	r3, [r7, #8]
 801d3ce:	69db      	ldr	r3, [r3, #28]
 801d3d0:	9200      	str	r2, [sp, #0]
 801d3d2:	9301      	str	r3, [sp, #4]
 801d3d4:	480a      	ldr	r0, [pc, #40]	; (801d400 <_list_memheap+0x60>)
 801d3d6:	2108      	movs	r1, #8
 801d3d8:	462a      	mov	r2, r5
 801d3da:	4623      	mov	r3, r4
 801d3dc:	f7fa fa6e 	bl	80178bc <rt_kprintf>
    struct rt_memheap *mh;
    struct rt_list_node *node;

    rt_kprintf("memheap  pool size  max used size available size\n");
    rt_kprintf("-------- ---------- ------------- --------------\n");
    for (node = list->next; node != list; node = node->next)
 801d3e0:	68fb      	ldr	r3, [r7, #12]
 801d3e2:	681b      	ldr	r3, [r3, #0]
 801d3e4:	60fb      	str	r3, [r7, #12]
 801d3e6:	68fa      	ldr	r2, [r7, #12]
 801d3e8:	687b      	ldr	r3, [r7, #4]
 801d3ea:	429a      	cmp	r2, r3
 801d3ec:	d1e6      	bne.n	801d3bc <_list_memheap+0x1c>
                   mh->pool_size,
                   mh->max_used_size,
                   mh->available_size);
    }

    return 0;
 801d3ee:	2300      	movs	r3, #0
}
 801d3f0:	4618      	mov	r0, r3
 801d3f2:	3710      	adds	r7, #16
 801d3f4:	46bd      	mov	sp, r7
 801d3f6:	bdb0      	pop	{r4, r5, r7, pc}
 801d3f8:	08028728 	.word	0x08028728
 801d3fc:	0802875c 	.word	0x0802875c
 801d400:	08028790 	.word	0x08028790

0801d404 <list_memheap>:

long list_memheap(void)
{
 801d404:	b580      	push	{r7, lr}
 801d406:	af00      	add	r7, sp, #0
    return _list_memheap(&rt_object_container[RT_Object_Class_MemHeap].object_list);
 801d408:	4802      	ldr	r0, [pc, #8]	; (801d414 <list_memheap+0x10>)
 801d40a:	f7ff ffc9 	bl	801d3a0 <_list_memheap>
 801d40e:	4603      	mov	r3, r0
}
 801d410:	4618      	mov	r0, r3
 801d412:	bd80      	pop	{r7, pc}
 801d414:	20010080 	.word	0x20010080

0801d418 <_list_mempool>:
MSH_CMD_EXPORT(list_memheap, list memory heap in system);
#endif

#ifdef RT_USING_MEMPOOL
static long _list_mempool(struct rt_list_node *list)
{
 801d418:	b5b0      	push	{r4, r5, r7, lr}
 801d41a:	b088      	sub	sp, #32
 801d41c:	af04      	add	r7, sp, #16
 801d41e:	6078      	str	r0, [r7, #4]
    struct rt_mempool *mp;
    struct rt_list_node *node;

    rt_kprintf("mempool  block total free suspend thread\n");
 801d420:	4824      	ldr	r0, [pc, #144]	; (801d4b4 <_list_mempool+0x9c>)
 801d422:	f7fa fa4b 	bl	80178bc <rt_kprintf>
    rt_kprintf("-------- ----  ----  ---- --------------\n");
 801d426:	4824      	ldr	r0, [pc, #144]	; (801d4b8 <_list_mempool+0xa0>)
 801d428:	f7fa fa48 	bl	80178bc <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801d42c:	687b      	ldr	r3, [r7, #4]
 801d42e:	681b      	ldr	r3, [r3, #0]
 801d430:	60fb      	str	r3, [r7, #12]
 801d432:	e036      	b.n	801d4a2 <_list_mempool+0x8a>
    {
        mp = (struct rt_mempool *)rt_list_entry(node, struct rt_object, list);
 801d434:	68fb      	ldr	r3, [r7, #12]
 801d436:	3b0c      	subs	r3, #12
 801d438:	60bb      	str	r3, [r7, #8]
        if (mp->suspend_thread_count > 0)
 801d43a:	68bb      	ldr	r3, [r7, #8]
 801d43c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801d43e:	2b00      	cmp	r3, #0
 801d440:	d01a      	beq.n	801d478 <_list_mempool+0x60>
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d:",
                       RT_NAME_MAX,
                       mp->parent.name,
 801d442:	68bd      	ldr	r5, [r7, #8]
    for (node = list->next; node != list; node = node->next)
    {
        mp = (struct rt_mempool *)rt_list_entry(node, struct rt_object, list);
        if (mp->suspend_thread_count > 0)
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d:",
 801d444:	68bb      	ldr	r3, [r7, #8]
 801d446:	69dc      	ldr	r4, [r3, #28]
 801d448:	68bb      	ldr	r3, [r7, #8]
 801d44a:	6a59      	ldr	r1, [r3, #36]	; 0x24
 801d44c:	68bb      	ldr	r3, [r7, #8]
 801d44e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 801d450:	68bb      	ldr	r3, [r7, #8]
 801d452:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801d454:	9100      	str	r1, [sp, #0]
 801d456:	9201      	str	r2, [sp, #4]
 801d458:	9302      	str	r3, [sp, #8]
 801d45a:	4818      	ldr	r0, [pc, #96]	; (801d4bc <_list_mempool+0xa4>)
 801d45c:	2108      	movs	r1, #8
 801d45e:	462a      	mov	r2, r5
 801d460:	4623      	mov	r3, r4
 801d462:	f7fa fa2b 	bl	80178bc <rt_kprintf>
                       mp->parent.name,
                       mp->block_size,
                       mp->block_total_count,
                       mp->block_free_count,
                       mp->suspend_thread_count);
            show_wait_queue(&(mp->suspend_thread));
 801d466:	68bb      	ldr	r3, [r7, #8]
 801d468:	332c      	adds	r3, #44	; 0x2c
 801d46a:	4618      	mov	r0, r3
 801d46c:	f7ff fda0 	bl	801cfb0 <show_wait_queue>
            rt_kprintf("\n");
 801d470:	4813      	ldr	r0, [pc, #76]	; (801d4c0 <_list_mempool+0xa8>)
 801d472:	f7fa fa23 	bl	80178bc <rt_kprintf>
 801d476:	e011      	b.n	801d49c <_list_mempool+0x84>
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d\n",
                       RT_NAME_MAX,
                       mp->parent.name,
 801d478:	68bd      	ldr	r5, [r7, #8]
            show_wait_queue(&(mp->suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d\n",
 801d47a:	68bb      	ldr	r3, [r7, #8]
 801d47c:	69dc      	ldr	r4, [r3, #28]
 801d47e:	68bb      	ldr	r3, [r7, #8]
 801d480:	6a59      	ldr	r1, [r3, #36]	; 0x24
 801d482:	68bb      	ldr	r3, [r7, #8]
 801d484:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 801d486:	68bb      	ldr	r3, [r7, #8]
 801d488:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801d48a:	9100      	str	r1, [sp, #0]
 801d48c:	9201      	str	r2, [sp, #4]
 801d48e:	9302      	str	r3, [sp, #8]
 801d490:	480c      	ldr	r0, [pc, #48]	; (801d4c4 <_list_mempool+0xac>)
 801d492:	2108      	movs	r1, #8
 801d494:	462a      	mov	r2, r5
 801d496:	4623      	mov	r3, r4
 801d498:	f7fa fa10 	bl	80178bc <rt_kprintf>
    struct rt_mempool *mp;
    struct rt_list_node *node;

    rt_kprintf("mempool  block total free suspend thread\n");
    rt_kprintf("-------- ----  ----  ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
 801d49c:	68fb      	ldr	r3, [r7, #12]
 801d49e:	681b      	ldr	r3, [r3, #0]
 801d4a0:	60fb      	str	r3, [r7, #12]
 801d4a2:	68fa      	ldr	r2, [r7, #12]
 801d4a4:	687b      	ldr	r3, [r7, #4]
 801d4a6:	429a      	cmp	r2, r3
 801d4a8:	d1c4      	bne.n	801d434 <_list_mempool+0x1c>
                       mp->block_free_count,
                       mp->suspend_thread_count);
        }
    }

    return 0;
 801d4aa:	2300      	movs	r3, #0
}
 801d4ac:	4618      	mov	r0, r3
 801d4ae:	3710      	adds	r7, #16
 801d4b0:	46bd      	mov	sp, r7
 801d4b2:	bdb0      	pop	{r4, r5, r7, pc}
 801d4b4:	080287ac 	.word	0x080287ac
 801d4b8:	080287d8 	.word	0x080287d8
 801d4bc:	08028804 	.word	0x08028804
 801d4c0:	08028554 	.word	0x08028554
 801d4c4:	08028820 	.word	0x08028820

0801d4c8 <list_mempool>:

long list_mempool(void)
{
 801d4c8:	b580      	push	{r7, lr}
 801d4ca:	af00      	add	r7, sp, #0
    return _list_mempool(&rt_object_container[RT_Object_Class_MemPool].object_list);
 801d4cc:	4802      	ldr	r0, [pc, #8]	; (801d4d8 <list_mempool+0x10>)
 801d4ce:	f7ff ffa3 	bl	801d418 <_list_mempool>
 801d4d2:	4603      	mov	r3, r0
}
 801d4d4:	4618      	mov	r0, r3
 801d4d6:	bd80      	pop	{r7, pc}
 801d4d8:	20010090 	.word	0x20010090

0801d4dc <_list_timer>:
FINSH_FUNCTION_EXPORT(list_mempool, list memory pool in system)
MSH_CMD_EXPORT(list_mempool, list memory pool in system);
#endif

static long _list_timer(struct rt_list_node *list)
{
 801d4dc:	b590      	push	{r4, r7, lr}
 801d4de:	b087      	sub	sp, #28
 801d4e0:	af02      	add	r7, sp, #8
 801d4e2:	6078      	str	r0, [r7, #4]
    struct rt_timer *timer;
    struct rt_list_node *node;

    rt_kprintf("timer    periodic   timeout    flag\n");
 801d4e4:	481b      	ldr	r0, [pc, #108]	; (801d554 <_list_timer+0x78>)
 801d4e6:	f7fa f9e9 	bl	80178bc <rt_kprintf>
    rt_kprintf("-------- ---------- ---------- -----------\n");
 801d4ea:	481b      	ldr	r0, [pc, #108]	; (801d558 <_list_timer+0x7c>)
 801d4ec:	f7fa f9e6 	bl	80178bc <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801d4f0:	687b      	ldr	r3, [r7, #4]
 801d4f2:	681b      	ldr	r3, [r3, #0]
 801d4f4:	60fb      	str	r3, [r7, #12]
 801d4f6:	e01d      	b.n	801d534 <_list_timer+0x58>
    {
        timer = (struct rt_timer *)(rt_list_entry(node, struct rt_object, list));
 801d4f8:	68fb      	ldr	r3, [r7, #12]
 801d4fa:	3b0c      	subs	r3, #12
 801d4fc:	60bb      	str	r3, [r7, #8]
        rt_kprintf("%-8.*s 0x%08x 0x%08x ",
                   RT_NAME_MAX,
                   timer->parent.name,
 801d4fe:	68ba      	ldr	r2, [r7, #8]
    rt_kprintf("timer    periodic   timeout    flag\n");
    rt_kprintf("-------- ---------- ---------- -----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        timer = (struct rt_timer *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s 0x%08x 0x%08x ",
 801d500:	68bb      	ldr	r3, [r7, #8]
 801d502:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 801d504:	68bb      	ldr	r3, [r7, #8]
 801d506:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801d508:	9300      	str	r3, [sp, #0]
 801d50a:	4814      	ldr	r0, [pc, #80]	; (801d55c <_list_timer+0x80>)
 801d50c:	2108      	movs	r1, #8
 801d50e:	4623      	mov	r3, r4
 801d510:	f7fa f9d4 	bl	80178bc <rt_kprintf>
                   RT_NAME_MAX,
                   timer->parent.name,
                   timer->init_tick,
                   timer->timeout_tick);
        if (timer->parent.flag & RT_TIMER_FLAG_ACTIVATED)
 801d514:	68bb      	ldr	r3, [r7, #8]
 801d516:	7a5b      	ldrb	r3, [r3, #9]
 801d518:	f003 0301 	and.w	r3, r3, #1
 801d51c:	2b00      	cmp	r3, #0
 801d51e:	d003      	beq.n	801d528 <_list_timer+0x4c>
            rt_kprintf("activated\n");
 801d520:	480f      	ldr	r0, [pc, #60]	; (801d560 <_list_timer+0x84>)
 801d522:	f7fa f9cb 	bl	80178bc <rt_kprintf>
 801d526:	e002      	b.n	801d52e <_list_timer+0x52>
        else
            rt_kprintf("deactivated\n");
 801d528:	480e      	ldr	r0, [pc, #56]	; (801d564 <_list_timer+0x88>)
 801d52a:	f7fa f9c7 	bl	80178bc <rt_kprintf>
    struct rt_timer *timer;
    struct rt_list_node *node;

    rt_kprintf("timer    periodic   timeout    flag\n");
    rt_kprintf("-------- ---------- ---------- -----------\n");
    for (node = list->next; node != list; node = node->next)
 801d52e:	68fb      	ldr	r3, [r7, #12]
 801d530:	681b      	ldr	r3, [r3, #0]
 801d532:	60fb      	str	r3, [r7, #12]
 801d534:	68fa      	ldr	r2, [r7, #12]
 801d536:	687b      	ldr	r3, [r7, #4]
 801d538:	429a      	cmp	r2, r3
 801d53a:	d1dd      	bne.n	801d4f8 <_list_timer+0x1c>
            rt_kprintf("activated\n");
        else
            rt_kprintf("deactivated\n");
    }

    rt_kprintf("current tick:0x%08x\n", rt_tick_get());
 801d53c:	f7f8 fa7a 	bl	8015a34 <rt_tick_get>
 801d540:	4603      	mov	r3, r0
 801d542:	4809      	ldr	r0, [pc, #36]	; (801d568 <_list_timer+0x8c>)
 801d544:	4619      	mov	r1, r3
 801d546:	f7fa f9b9 	bl	80178bc <rt_kprintf>

    return 0;
 801d54a:	2300      	movs	r3, #0
}
 801d54c:	4618      	mov	r0, r3
 801d54e:	3714      	adds	r7, #20
 801d550:	46bd      	mov	sp, r7
 801d552:	bd90      	pop	{r4, r7, pc}
 801d554:	0802883c 	.word	0x0802883c
 801d558:	08028864 	.word	0x08028864
 801d55c:	08028890 	.word	0x08028890
 801d560:	080288a8 	.word	0x080288a8
 801d564:	080288b4 	.word	0x080288b4
 801d568:	080288c4 	.word	0x080288c4

0801d56c <list_timer>:

long list_timer(void)
{
 801d56c:	b580      	push	{r7, lr}
 801d56e:	af00      	add	r7, sp, #0
    return _list_timer(&rt_object_container[RT_Object_Class_Timer].object_list);
 801d570:	4802      	ldr	r0, [pc, #8]	; (801d57c <list_timer+0x10>)
 801d572:	f7ff ffb3 	bl	801d4dc <_list_timer>
 801d576:	4603      	mov	r3, r0
}
 801d578:	4618      	mov	r0, r3
 801d57a:	bd80      	pop	{r7, pc}
 801d57c:	200100b0 	.word	0x200100b0

0801d580 <_list_device>:
FINSH_FUNCTION_EXPORT(list_timer, list timer in system);
MSH_CMD_EXPORT(list_timer, list timer in system);

#ifdef RT_USING_DEVICE
static long _list_device(struct rt_list_node *list)
{
 801d580:	b590      	push	{r4, r7, lr}
 801d582:	b09b      	sub	sp, #108	; 0x6c
 801d584:	af02      	add	r7, sp, #8
 801d586:	6078      	str	r0, [r7, #4]
    struct rt_device *device;
    struct rt_list_node *node;
    char * const device_type_str[] =
 801d588:	4a1b      	ldr	r2, [pc, #108]	; (801d5f8 <_list_device+0x78>)
 801d58a:	f107 0308 	add.w	r3, r7, #8
 801d58e:	4611      	mov	r1, r2
 801d590:	2250      	movs	r2, #80	; 0x50
 801d592:	4618      	mov	r0, r3
 801d594:	f7e2 fea2 	bl	80002dc <memcpy>
		"Timer Device",
		"Miscellaneous Device",
        "Unknown"
    };

    rt_kprintf("device   type                 ref count\n");
 801d598:	4818      	ldr	r0, [pc, #96]	; (801d5fc <_list_device+0x7c>)
 801d59a:	f7fa f98f 	bl	80178bc <rt_kprintf>
    rt_kprintf("-------- -------------------- ----------\n");
 801d59e:	4818      	ldr	r0, [pc, #96]	; (801d600 <_list_device+0x80>)
 801d5a0:	f7fa f98c 	bl	80178bc <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801d5a4:	687b      	ldr	r3, [r7, #4]
 801d5a6:	681b      	ldr	r3, [r3, #0]
 801d5a8:	65fb      	str	r3, [r7, #92]	; 0x5c
 801d5aa:	e01c      	b.n	801d5e6 <_list_device+0x66>
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
 801d5ac:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801d5ae:	3b0c      	subs	r3, #12
 801d5b0:	65bb      	str	r3, [r7, #88]	; 0x58
        rt_kprintf("%-8.*s %-20s %-8d\n",
                   RT_NAME_MAX,
                   device->parent.name,
 801d5b2:	6dbc      	ldr	r4, [r7, #88]	; 0x58
                   (device->type <= RT_Device_Class_Unknown) ?
 801d5b4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801d5b6:	7d1b      	ldrb	r3, [r3, #20]
    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-20s %-8d\n",
 801d5b8:	2b13      	cmp	r3, #19
 801d5ba:	d808      	bhi.n	801d5ce <_list_device+0x4e>
                   RT_NAME_MAX,
                   device->parent.name,
                   (device->type <= RT_Device_Class_Unknown) ?
                   device_type_str[device->type] :
 801d5bc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801d5be:	7d1b      	ldrb	r3, [r3, #20]
    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-20s %-8d\n",
 801d5c0:	009b      	lsls	r3, r3, #2
 801d5c2:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801d5c6:	4413      	add	r3, r2
 801d5c8:	f853 3c58 	ldr.w	r3, [r3, #-88]
 801d5cc:	e000      	b.n	801d5d0 <_list_device+0x50>
 801d5ce:	6d7b      	ldr	r3, [r7, #84]	; 0x54
                   RT_NAME_MAX,
                   device->parent.name,
                   (device->type <= RT_Device_Class_Unknown) ?
                   device_type_str[device->type] :
                   device_type_str[RT_Device_Class_Unknown],
                   device->ref_count);
 801d5d0:	6dba      	ldr	r2, [r7, #88]	; 0x58
 801d5d2:	7e92      	ldrb	r2, [r2, #26]
    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-20s %-8d\n",
 801d5d4:	9200      	str	r2, [sp, #0]
 801d5d6:	480b      	ldr	r0, [pc, #44]	; (801d604 <_list_device+0x84>)
 801d5d8:	2108      	movs	r1, #8
 801d5da:	4622      	mov	r2, r4
 801d5dc:	f7fa f96e 	bl	80178bc <rt_kprintf>
        "Unknown"
    };

    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
 801d5e0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801d5e2:	681b      	ldr	r3, [r3, #0]
 801d5e4:	65fb      	str	r3, [r7, #92]	; 0x5c
 801d5e6:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801d5e8:	687b      	ldr	r3, [r7, #4]
 801d5ea:	429a      	cmp	r2, r3
 801d5ec:	d1de      	bne.n	801d5ac <_list_device+0x2c>
                   device_type_str[device->type] :
                   device_type_str[RT_Device_Class_Unknown],
                   device->ref_count);
    }

    return 0;
 801d5ee:	2300      	movs	r3, #0
}
 801d5f0:	4618      	mov	r0, r3
 801d5f2:	3764      	adds	r7, #100	; 0x64
 801d5f4:	46bd      	mov	sp, r7
 801d5f6:	bd90      	pop	{r4, r7, pc}
 801d5f8:	08028a64 	.word	0x08028a64
 801d5fc:	080288dc 	.word	0x080288dc
 801d600:	08028908 	.word	0x08028908
 801d604:	08028934 	.word	0x08028934

0801d608 <list_device>:

long list_device(void)
{
 801d608:	b580      	push	{r7, lr}
 801d60a:	af00      	add	r7, sp, #0
    return _list_device(&rt_object_container[RT_Object_Class_Device].object_list);
 801d60c:	4802      	ldr	r0, [pc, #8]	; (801d618 <list_device+0x10>)
 801d60e:	f7ff ffb7 	bl	801d580 <_list_device>
 801d612:	4603      	mov	r3, r0
}
 801d614:	4618      	mov	r0, r3
 801d616:	bd80      	pop	{r7, pc}
 801d618:	200100a0 	.word	0x200100a0

0801d61c <list>:
}
FINSH_FUNCTION_EXPORT(list_mod_detail, list module objects in system)
#endif

long list(void)
{
 801d61c:	b580      	push	{r7, lr}
 801d61e:	b084      	sub	sp, #16
 801d620:	af00      	add	r7, sp, #0
#ifndef FINSH_USING_MSH_ONLY
    struct finsh_syscall_item *syscall_item;
    struct finsh_sysvar_item *sysvar_item;
#endif
	
    rt_kprintf("--Function List:\n");
 801d622:	4830      	ldr	r0, [pc, #192]	; (801d6e4 <list+0xc8>)
 801d624:	f7fa f94a 	bl	80178bc <rt_kprintf>
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
 801d628:	4b2f      	ldr	r3, [pc, #188]	; (801d6e8 <list+0xcc>)
 801d62a:	681b      	ldr	r3, [r3, #0]
 801d62c:	607b      	str	r3, [r7, #4]
 801d62e:	e016      	b.n	801d65e <list+0x42>
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
        {
			/* skip the internal command */
			if (strncmp((char*)index->name, "__", 2) == 0) continue;
 801d630:	687b      	ldr	r3, [r7, #4]
 801d632:	681b      	ldr	r3, [r3, #0]
 801d634:	4618      	mov	r0, r3
 801d636:	492d      	ldr	r1, [pc, #180]	; (801d6ec <list+0xd0>)
 801d638:	2202      	movs	r2, #2
 801d63a:	f006 f861 	bl	8023700 <strncmp>
 801d63e:	4603      	mov	r3, r0
 801d640:	2b00      	cmp	r3, #0
 801d642:	d100      	bne.n	801d646 <list+0x2a>
 801d644:	e008      	b.n	801d658 <list+0x3c>

#ifdef FINSH_USING_DESCRIPTION
            rt_kprintf("%-16s -- %s\n", index->name, index->desc);
 801d646:	687b      	ldr	r3, [r7, #4]
 801d648:	681a      	ldr	r2, [r3, #0]
 801d64a:	687b      	ldr	r3, [r7, #4]
 801d64c:	685b      	ldr	r3, [r3, #4]
 801d64e:	4828      	ldr	r0, [pc, #160]	; (801d6f0 <list+0xd4>)
 801d650:	4611      	mov	r1, r2
 801d652:	461a      	mov	r2, r3
 801d654:	f7fa f932 	bl	80178bc <rt_kprintf>
    rt_kprintf("--Function List:\n");
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
 801d658:	687b      	ldr	r3, [r7, #4]
 801d65a:	330c      	adds	r3, #12
 801d65c:	607b      	str	r3, [r7, #4]
	
    rt_kprintf("--Function List:\n");
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
 801d65e:	4b25      	ldr	r3, [pc, #148]	; (801d6f4 <list+0xd8>)
 801d660:	681b      	ldr	r3, [r3, #0]
#endif
	
    rt_kprintf("--Function List:\n");
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
 801d662:	687a      	ldr	r2, [r7, #4]
 801d664:	429a      	cmp	r2, r3
 801d666:	d3e3      	bcc.n	801d630 <list+0x14>
        }
    }

#ifndef FINSH_USING_MSH_ONLY
    /* list syscall list */
    syscall_item = global_syscall_list;
 801d668:	4b23      	ldr	r3, [pc, #140]	; (801d6f8 <list+0xdc>)
 801d66a:	681b      	ldr	r3, [r3, #0]
 801d66c:	60fb      	str	r3, [r7, #12]
    while (syscall_item != NULL)
 801d66e:	e008      	b.n	801d682 <list+0x66>
    {
        rt_kprintf("[l] %s\n", syscall_item->syscall.name);
 801d670:	68fb      	ldr	r3, [r7, #12]
 801d672:	685b      	ldr	r3, [r3, #4]
 801d674:	4821      	ldr	r0, [pc, #132]	; (801d6fc <list+0xe0>)
 801d676:	4619      	mov	r1, r3
 801d678:	f7fa f920 	bl	80178bc <rt_kprintf>
        syscall_item = syscall_item->next;
 801d67c:	68fb      	ldr	r3, [r7, #12]
 801d67e:	681b      	ldr	r3, [r3, #0]
 801d680:	60fb      	str	r3, [r7, #12]
    }

#ifndef FINSH_USING_MSH_ONLY
    /* list syscall list */
    syscall_item = global_syscall_list;
    while (syscall_item != NULL)
 801d682:	68fb      	ldr	r3, [r7, #12]
 801d684:	2b00      	cmp	r3, #0
 801d686:	d1f3      	bne.n	801d670 <list+0x54>
    {
        rt_kprintf("[l] %s\n", syscall_item->syscall.name);
        syscall_item = syscall_item->next;
    }

    rt_kprintf("--Variable List:\n");
 801d688:	481d      	ldr	r0, [pc, #116]	; (801d700 <list+0xe4>)
 801d68a:	f7fa f917 	bl	80178bc <rt_kprintf>
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
 801d68e:	4b1d      	ldr	r3, [pc, #116]	; (801d704 <list+0xe8>)
 801d690:	681b      	ldr	r3, [r3, #0]
 801d692:	603b      	str	r3, [r7, #0]
 801d694:	e00b      	b.n	801d6ae <list+0x92>
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
        {
#ifdef FINSH_USING_DESCRIPTION
            rt_kprintf("%-16s -- %s\n", index->name, index->desc);
 801d696:	683b      	ldr	r3, [r7, #0]
 801d698:	681a      	ldr	r2, [r3, #0]
 801d69a:	683b      	ldr	r3, [r7, #0]
 801d69c:	685b      	ldr	r3, [r3, #4]
 801d69e:	4814      	ldr	r0, [pc, #80]	; (801d6f0 <list+0xd4>)
 801d6a0:	4611      	mov	r1, r2
 801d6a2:	461a      	mov	r2, r3
 801d6a4:	f7fa f90a 	bl	80178bc <rt_kprintf>
    rt_kprintf("--Variable List:\n");
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
 801d6a8:	683b      	ldr	r3, [r7, #0]
 801d6aa:	3310      	adds	r3, #16
 801d6ac:	603b      	str	r3, [r7, #0]

    rt_kprintf("--Variable List:\n");
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
 801d6ae:	4b16      	ldr	r3, [pc, #88]	; (801d708 <list+0xec>)
 801d6b0:	681b      	ldr	r3, [r3, #0]
    }

    rt_kprintf("--Variable List:\n");
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
 801d6b2:	683a      	ldr	r2, [r7, #0]
 801d6b4:	429a      	cmp	r2, r3
 801d6b6:	d3ee      	bcc.n	801d696 <list+0x7a>
            rt_kprintf("%s\n", index->name);
#endif
        }
    }

    sysvar_item = global_sysvar_list;
 801d6b8:	4b14      	ldr	r3, [pc, #80]	; (801d70c <list+0xf0>)
 801d6ba:	681b      	ldr	r3, [r3, #0]
 801d6bc:	60bb      	str	r3, [r7, #8]
    while (sysvar_item != NULL)
 801d6be:	e008      	b.n	801d6d2 <list+0xb6>
    {
        rt_kprintf("[l] %s\n", sysvar_item->sysvar.name);
 801d6c0:	68bb      	ldr	r3, [r7, #8]
 801d6c2:	685b      	ldr	r3, [r3, #4]
 801d6c4:	480d      	ldr	r0, [pc, #52]	; (801d6fc <list+0xe0>)
 801d6c6:	4619      	mov	r1, r3
 801d6c8:	f7fa f8f8 	bl	80178bc <rt_kprintf>
        sysvar_item = sysvar_item->next;
 801d6cc:	68bb      	ldr	r3, [r7, #8]
 801d6ce:	681b      	ldr	r3, [r3, #0]
 801d6d0:	60bb      	str	r3, [r7, #8]
#endif
        }
    }

    sysvar_item = global_sysvar_list;
    while (sysvar_item != NULL)
 801d6d2:	68bb      	ldr	r3, [r7, #8]
 801d6d4:	2b00      	cmp	r3, #0
 801d6d6:	d1f3      	bne.n	801d6c0 <list+0xa4>
        rt_kprintf("[l] %s\n", sysvar_item->sysvar.name);
        sysvar_item = sysvar_item->next;
    }
#endif
	
    return 0;
 801d6d8:	2300      	movs	r3, #0
}
 801d6da:	4618      	mov	r0, r3
 801d6dc:	3710      	adds	r7, #16
 801d6de:	46bd      	mov	sp, r7
 801d6e0:	bd80      	pop	{r7, pc}
 801d6e2:	bf00      	nop
 801d6e4:	08028ab4 	.word	0x08028ab4
 801d6e8:	2001218c 	.word	0x2001218c
 801d6ec:	08028ac8 	.word	0x08028ac8
 801d6f0:	08028acc 	.word	0x08028acc
 801d6f4:	20012190 	.word	0x20012190
 801d6f8:	200121a8 	.word	0x200121a8
 801d6fc:	08028adc 	.word	0x08028adc
 801d700:	08028ae4 	.word	0x08028ae4
 801d704:	20012194 	.word	0x20012194
 801d708:	20012198 	.word	0x20012198
 801d70c:	20012d84 	.word	0x20012d84

0801d710 <str_is_prefix>:
FINSH_FUNCTION_EXPORT(list, list all symbol in system)

#ifndef FINSH_USING_MSH_ONLY
static int str_is_prefix(const char *prefix, const char *str)
{
 801d710:	b480      	push	{r7}
 801d712:	b083      	sub	sp, #12
 801d714:	af00      	add	r7, sp, #0
 801d716:	6078      	str	r0, [r7, #4]
 801d718:	6039      	str	r1, [r7, #0]
    while ((*prefix) && (*prefix == *str))
 801d71a:	e005      	b.n	801d728 <str_is_prefix+0x18>
    {
        prefix ++;
 801d71c:	687b      	ldr	r3, [r7, #4]
 801d71e:	3301      	adds	r3, #1
 801d720:	607b      	str	r3, [r7, #4]
        str ++;
 801d722:	683b      	ldr	r3, [r7, #0]
 801d724:	3301      	adds	r3, #1
 801d726:	603b      	str	r3, [r7, #0]
FINSH_FUNCTION_EXPORT(list, list all symbol in system)

#ifndef FINSH_USING_MSH_ONLY
static int str_is_prefix(const char *prefix, const char *str)
{
    while ((*prefix) && (*prefix == *str))
 801d728:	687b      	ldr	r3, [r7, #4]
 801d72a:	781b      	ldrb	r3, [r3, #0]
 801d72c:	2b00      	cmp	r3, #0
 801d72e:	d005      	beq.n	801d73c <str_is_prefix+0x2c>
 801d730:	687b      	ldr	r3, [r7, #4]
 801d732:	781a      	ldrb	r2, [r3, #0]
 801d734:	683b      	ldr	r3, [r7, #0]
 801d736:	781b      	ldrb	r3, [r3, #0]
 801d738:	429a      	cmp	r2, r3
 801d73a:	d0ef      	beq.n	801d71c <str_is_prefix+0xc>
    {
        prefix ++;
        str ++;
    }

    if (*prefix == 0)
 801d73c:	687b      	ldr	r3, [r7, #4]
 801d73e:	781b      	ldrb	r3, [r3, #0]
 801d740:	2b00      	cmp	r3, #0
 801d742:	d101      	bne.n	801d748 <str_is_prefix+0x38>
        return 0;
 801d744:	2300      	movs	r3, #0
 801d746:	e001      	b.n	801d74c <str_is_prefix+0x3c>

    return -1;
 801d748:	f04f 33ff 	mov.w	r3, #4294967295
}
 801d74c:	4618      	mov	r0, r3
 801d74e:	370c      	adds	r7, #12
 801d750:	46bd      	mov	sp, r7
 801d752:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d756:	4770      	bx	lr

0801d758 <str_common>:

static int str_common(const char *str1, const char *str2)
{
 801d758:	b480      	push	{r7}
 801d75a:	b085      	sub	sp, #20
 801d75c:	af00      	add	r7, sp, #0
 801d75e:	6078      	str	r0, [r7, #4]
 801d760:	6039      	str	r1, [r7, #0]
    const char *str = str1;
 801d762:	687b      	ldr	r3, [r7, #4]
 801d764:	60fb      	str	r3, [r7, #12]

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
 801d766:	e005      	b.n	801d774 <str_common+0x1c>
    {
        str ++;
 801d768:	68fb      	ldr	r3, [r7, #12]
 801d76a:	3301      	adds	r3, #1
 801d76c:	60fb      	str	r3, [r7, #12]
        str2 ++;
 801d76e:	683b      	ldr	r3, [r7, #0]
 801d770:	3301      	adds	r3, #1
 801d772:	603b      	str	r3, [r7, #0]

static int str_common(const char *str1, const char *str2)
{
    const char *str = str1;

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
 801d774:	68fb      	ldr	r3, [r7, #12]
 801d776:	781b      	ldrb	r3, [r3, #0]
 801d778:	2b00      	cmp	r3, #0
 801d77a:	d009      	beq.n	801d790 <str_common+0x38>
 801d77c:	683b      	ldr	r3, [r7, #0]
 801d77e:	781b      	ldrb	r3, [r3, #0]
 801d780:	2b00      	cmp	r3, #0
 801d782:	d005      	beq.n	801d790 <str_common+0x38>
 801d784:	68fb      	ldr	r3, [r7, #12]
 801d786:	781a      	ldrb	r2, [r3, #0]
 801d788:	683b      	ldr	r3, [r7, #0]
 801d78a:	781b      	ldrb	r3, [r3, #0]
 801d78c:	429a      	cmp	r2, r3
 801d78e:	d0eb      	beq.n	801d768 <str_common+0x10>
    {
        str ++;
        str2 ++;
    }

    return (str - str1);
 801d790:	68fa      	ldr	r2, [r7, #12]
 801d792:	687b      	ldr	r3, [r7, #4]
 801d794:	1ad3      	subs	r3, r2, r3
}
 801d796:	4618      	mov	r0, r3
 801d798:	3714      	adds	r7, #20
 801d79a:	46bd      	mov	sp, r7
 801d79c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d7a0:	4770      	bx	lr
 801d7a2:	bf00      	nop

0801d7a4 <list_prefix>:

void list_prefix(char *prefix)
{
 801d7a4:	b580      	push	{r7, lr}
 801d7a6:	b08a      	sub	sp, #40	; 0x28
 801d7a8:	af00      	add	r7, sp, #0
 801d7aa:	6078      	str	r0, [r7, #4]
    struct finsh_sysvar_item *sysvar_item;
    rt_uint16_t func_cnt, var_cnt;
    int length, min_length;
    const char *name_ptr;

    func_cnt = 0;
 801d7ac:	2300      	movs	r3, #0
 801d7ae:	83fb      	strh	r3, [r7, #30]
    var_cnt  = 0;
 801d7b0:	2300      	movs	r3, #0
 801d7b2:	83bb      	strh	r3, [r7, #28]
    min_length = 0;
 801d7b4:	2300      	movs	r3, #0
 801d7b6:	61bb      	str	r3, [r7, #24]
    name_ptr = RT_NULL;
 801d7b8:	2300      	movs	r3, #0
 801d7ba:	617b      	str	r3, [r7, #20]

    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
 801d7bc:	4b92      	ldr	r3, [pc, #584]	; (801da08 <list_prefix+0x264>)
 801d7be:	681b      	ldr	r3, [r3, #0]
 801d7c0:	613b      	str	r3, [r7, #16]
 801d7c2:	e044      	b.n	801d84e <list_prefix+0xaa>
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
        {
			/* skip internal command */
			if (str_is_prefix("__", index->name) == 0) continue;
 801d7c4:	693b      	ldr	r3, [r7, #16]
 801d7c6:	681b      	ldr	r3, [r3, #0]
 801d7c8:	4890      	ldr	r0, [pc, #576]	; (801da0c <list_prefix+0x268>)
 801d7ca:	4619      	mov	r1, r3
 801d7cc:	f7ff ffa0 	bl	801d710 <str_is_prefix>
 801d7d0:	4603      	mov	r3, r0
 801d7d2:	2b00      	cmp	r3, #0
 801d7d4:	d100      	bne.n	801d7d8 <list_prefix+0x34>
 801d7d6:	e037      	b.n	801d848 <list_prefix+0xa4>
			
            if (str_is_prefix(prefix, index->name) == 0)
 801d7d8:	693b      	ldr	r3, [r7, #16]
 801d7da:	681b      	ldr	r3, [r3, #0]
 801d7dc:	6878      	ldr	r0, [r7, #4]
 801d7de:	4619      	mov	r1, r3
 801d7e0:	f7ff ff96 	bl	801d710 <str_is_prefix>
 801d7e4:	4603      	mov	r3, r0
 801d7e6:	2b00      	cmp	r3, #0
 801d7e8:	d12e      	bne.n	801d848 <list_prefix+0xa4>
            {
                if (func_cnt == 0)
 801d7ea:	8bfb      	ldrh	r3, [r7, #30]
 801d7ec:	2b00      	cmp	r3, #0
 801d7ee:	d10e      	bne.n	801d80e <list_prefix+0x6a>
                {
                    rt_kprintf("--function:\n");
 801d7f0:	4887      	ldr	r0, [pc, #540]	; (801da10 <list_prefix+0x26c>)
 801d7f2:	f7fa f863 	bl	80178bc <rt_kprintf>

                    if (*prefix != 0)
 801d7f6:	687b      	ldr	r3, [r7, #4]
 801d7f8:	781b      	ldrb	r3, [r3, #0]
 801d7fa:	2b00      	cmp	r3, #0
 801d7fc:	d007      	beq.n	801d80e <list_prefix+0x6a>
                    {
                        /* set name_ptr */
                        name_ptr = index->name;
 801d7fe:	693b      	ldr	r3, [r7, #16]
 801d800:	681b      	ldr	r3, [r3, #0]
 801d802:	617b      	str	r3, [r7, #20]

                        /* set initial length */
                        min_length = strlen(name_ptr);
 801d804:	6978      	ldr	r0, [r7, #20]
 801d806:	f005 ff4d 	bl	80236a4 <strlen>
 801d80a:	4603      	mov	r3, r0
 801d80c:	61bb      	str	r3, [r7, #24]
                    }
                }

                func_cnt ++;
 801d80e:	8bfb      	ldrh	r3, [r7, #30]
 801d810:	3301      	adds	r3, #1
 801d812:	83fb      	strh	r3, [r7, #30]

                if (*prefix != 0)
 801d814:	687b      	ldr	r3, [r7, #4]
 801d816:	781b      	ldrb	r3, [r3, #0]
 801d818:	2b00      	cmp	r3, #0
 801d81a:	d00c      	beq.n	801d836 <list_prefix+0x92>
                {
                    length = str_common(name_ptr, index->name);
 801d81c:	693b      	ldr	r3, [r7, #16]
 801d81e:	681b      	ldr	r3, [r3, #0]
 801d820:	6978      	ldr	r0, [r7, #20]
 801d822:	4619      	mov	r1, r3
 801d824:	f7ff ff98 	bl	801d758 <str_common>
 801d828:	60b8      	str	r0, [r7, #8]
                    if (length < min_length)
 801d82a:	68ba      	ldr	r2, [r7, #8]
 801d82c:	69bb      	ldr	r3, [r7, #24]
 801d82e:	429a      	cmp	r2, r3
 801d830:	da01      	bge.n	801d836 <list_prefix+0x92>
                        min_length = length;
 801d832:	68bb      	ldr	r3, [r7, #8]
 801d834:	61bb      	str	r3, [r7, #24]
                }

#ifdef FINSH_USING_DESCRIPTION
                rt_kprintf("%-16s -- %s\n", index->name, index->desc);
 801d836:	693b      	ldr	r3, [r7, #16]
 801d838:	681a      	ldr	r2, [r3, #0]
 801d83a:	693b      	ldr	r3, [r7, #16]
 801d83c:	685b      	ldr	r3, [r3, #4]
 801d83e:	4875      	ldr	r0, [pc, #468]	; (801da14 <list_prefix+0x270>)
 801d840:	4611      	mov	r1, r2
 801d842:	461a      	mov	r2, r3
 801d844:	f7fa f83a 	bl	80178bc <rt_kprintf>
    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
 801d848:	693b      	ldr	r3, [r7, #16]
 801d84a:	330c      	adds	r3, #12
 801d84c:	613b      	str	r3, [r7, #16]

    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
 801d84e:	4b72      	ldr	r3, [pc, #456]	; (801da18 <list_prefix+0x274>)
 801d850:	681b      	ldr	r3, [r3, #0]
    name_ptr = RT_NULL;

    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
 801d852:	693a      	ldr	r2, [r7, #16]
 801d854:	429a      	cmp	r2, r3
 801d856:	d3b5      	bcc.n	801d7c4 <list_prefix+0x20>
            }
        }
    }

    /* checks in dynamic system function call */
    syscall_item = global_syscall_list;
 801d858:	4b70      	ldr	r3, [pc, #448]	; (801da1c <list_prefix+0x278>)
 801d85a:	681b      	ldr	r3, [r3, #0]
 801d85c:	627b      	str	r3, [r7, #36]	; 0x24
    while (syscall_item != NULL)
 801d85e:	e03a      	b.n	801d8d6 <list_prefix+0x132>
    {
        if (str_is_prefix(prefix, syscall_item->syscall.name) == 0)
 801d860:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d862:	685b      	ldr	r3, [r3, #4]
 801d864:	6878      	ldr	r0, [r7, #4]
 801d866:	4619      	mov	r1, r3
 801d868:	f7ff ff52 	bl	801d710 <str_is_prefix>
 801d86c:	4603      	mov	r3, r0
 801d86e:	2b00      	cmp	r3, #0
 801d870:	d12e      	bne.n	801d8d0 <list_prefix+0x12c>
        {
            if (func_cnt == 0)
 801d872:	8bfb      	ldrh	r3, [r7, #30]
 801d874:	2b00      	cmp	r3, #0
 801d876:	d111      	bne.n	801d89c <list_prefix+0xf8>
            {
                rt_kprintf("--function:\n");
 801d878:	4865      	ldr	r0, [pc, #404]	; (801da10 <list_prefix+0x26c>)
 801d87a:	f7fa f81f 	bl	80178bc <rt_kprintf>
                if (*prefix != 0 && name_ptr == NULL)
 801d87e:	687b      	ldr	r3, [r7, #4]
 801d880:	781b      	ldrb	r3, [r3, #0]
 801d882:	2b00      	cmp	r3, #0
 801d884:	d00a      	beq.n	801d89c <list_prefix+0xf8>
 801d886:	697b      	ldr	r3, [r7, #20]
 801d888:	2b00      	cmp	r3, #0
 801d88a:	d107      	bne.n	801d89c <list_prefix+0xf8>
                {
                    /* set name_ptr */
                    name_ptr = syscall_item->syscall.name;
 801d88c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d88e:	685b      	ldr	r3, [r3, #4]
 801d890:	617b      	str	r3, [r7, #20]

                    /* set initial length */
                    min_length = strlen(name_ptr);
 801d892:	6978      	ldr	r0, [r7, #20]
 801d894:	f005 ff06 	bl	80236a4 <strlen>
 801d898:	4603      	mov	r3, r0
 801d89a:	61bb      	str	r3, [r7, #24]
                }
            }

            func_cnt ++;
 801d89c:	8bfb      	ldrh	r3, [r7, #30]
 801d89e:	3301      	adds	r3, #1
 801d8a0:	83fb      	strh	r3, [r7, #30]

            if (*prefix != 0)
 801d8a2:	687b      	ldr	r3, [r7, #4]
 801d8a4:	781b      	ldrb	r3, [r3, #0]
 801d8a6:	2b00      	cmp	r3, #0
 801d8a8:	d00c      	beq.n	801d8c4 <list_prefix+0x120>
            {
                length = str_common(name_ptr, syscall_item->syscall.name);
 801d8aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d8ac:	685b      	ldr	r3, [r3, #4]
 801d8ae:	6978      	ldr	r0, [r7, #20]
 801d8b0:	4619      	mov	r1, r3
 801d8b2:	f7ff ff51 	bl	801d758 <str_common>
 801d8b6:	60b8      	str	r0, [r7, #8]
                if (length < min_length)
 801d8b8:	68ba      	ldr	r2, [r7, #8]
 801d8ba:	69bb      	ldr	r3, [r7, #24]
 801d8bc:	429a      	cmp	r2, r3
 801d8be:	da01      	bge.n	801d8c4 <list_prefix+0x120>
                    min_length = length;
 801d8c0:	68bb      	ldr	r3, [r7, #8]
 801d8c2:	61bb      	str	r3, [r7, #24]
            }

            rt_kprintf("[l] %s\n", syscall_item->syscall.name);
 801d8c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d8c6:	685b      	ldr	r3, [r3, #4]
 801d8c8:	4855      	ldr	r0, [pc, #340]	; (801da20 <list_prefix+0x27c>)
 801d8ca:	4619      	mov	r1, r3
 801d8cc:	f7f9 fff6 	bl	80178bc <rt_kprintf>
        }
        syscall_item = syscall_item->next;
 801d8d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d8d2:	681b      	ldr	r3, [r3, #0]
 801d8d4:	627b      	str	r3, [r7, #36]	; 0x24
        }
    }

    /* checks in dynamic system function call */
    syscall_item = global_syscall_list;
    while (syscall_item != NULL)
 801d8d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d8d8:	2b00      	cmp	r3, #0
 801d8da:	d1c1      	bne.n	801d860 <list_prefix+0xbc>
    }

    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
 801d8dc:	4b51      	ldr	r3, [pc, #324]	; (801da24 <list_prefix+0x280>)
 801d8de:	681b      	ldr	r3, [r3, #0]
 801d8e0:	60fb      	str	r3, [r7, #12]
 801d8e2:	e03d      	b.n	801d960 <list_prefix+0x1bc>
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
        {
            if (str_is_prefix(prefix, index->name) == 0)
 801d8e4:	68fb      	ldr	r3, [r7, #12]
 801d8e6:	681b      	ldr	r3, [r3, #0]
 801d8e8:	6878      	ldr	r0, [r7, #4]
 801d8ea:	4619      	mov	r1, r3
 801d8ec:	f7ff ff10 	bl	801d710 <str_is_prefix>
 801d8f0:	4603      	mov	r3, r0
 801d8f2:	2b00      	cmp	r3, #0
 801d8f4:	d131      	bne.n	801d95a <list_prefix+0x1b6>
            {
                if (var_cnt == 0)
 801d8f6:	8bbb      	ldrh	r3, [r7, #28]
 801d8f8:	2b00      	cmp	r3, #0
 801d8fa:	d111      	bne.n	801d920 <list_prefix+0x17c>
                {
                    rt_kprintf("--variable:\n");
 801d8fc:	484a      	ldr	r0, [pc, #296]	; (801da28 <list_prefix+0x284>)
 801d8fe:	f7f9 ffdd 	bl	80178bc <rt_kprintf>

                    if (*prefix != 0 && name_ptr == NULL)
 801d902:	687b      	ldr	r3, [r7, #4]
 801d904:	781b      	ldrb	r3, [r3, #0]
 801d906:	2b00      	cmp	r3, #0
 801d908:	d00a      	beq.n	801d920 <list_prefix+0x17c>
 801d90a:	697b      	ldr	r3, [r7, #20]
 801d90c:	2b00      	cmp	r3, #0
 801d90e:	d107      	bne.n	801d920 <list_prefix+0x17c>
                    {
                        /* set name_ptr */
                        name_ptr = index->name;
 801d910:	68fb      	ldr	r3, [r7, #12]
 801d912:	681b      	ldr	r3, [r3, #0]
 801d914:	617b      	str	r3, [r7, #20]

                        /* set initial length */
                        min_length = strlen(name_ptr);
 801d916:	6978      	ldr	r0, [r7, #20]
 801d918:	f005 fec4 	bl	80236a4 <strlen>
 801d91c:	4603      	mov	r3, r0
 801d91e:	61bb      	str	r3, [r7, #24]

                    }
                }

                var_cnt ++;
 801d920:	8bbb      	ldrh	r3, [r7, #28]
 801d922:	3301      	adds	r3, #1
 801d924:	83bb      	strh	r3, [r7, #28]

                if (*prefix != 0)
 801d926:	687b      	ldr	r3, [r7, #4]
 801d928:	781b      	ldrb	r3, [r3, #0]
 801d92a:	2b00      	cmp	r3, #0
 801d92c:	d00c      	beq.n	801d948 <list_prefix+0x1a4>
                {
                    length = str_common(name_ptr, index->name);
 801d92e:	68fb      	ldr	r3, [r7, #12]
 801d930:	681b      	ldr	r3, [r3, #0]
 801d932:	6978      	ldr	r0, [r7, #20]
 801d934:	4619      	mov	r1, r3
 801d936:	f7ff ff0f 	bl	801d758 <str_common>
 801d93a:	60b8      	str	r0, [r7, #8]
                    if (length < min_length)
 801d93c:	68ba      	ldr	r2, [r7, #8]
 801d93e:	69bb      	ldr	r3, [r7, #24]
 801d940:	429a      	cmp	r2, r3
 801d942:	da01      	bge.n	801d948 <list_prefix+0x1a4>
                        min_length = length;
 801d944:	68bb      	ldr	r3, [r7, #8]
 801d946:	61bb      	str	r3, [r7, #24]
                }

#ifdef FINSH_USING_DESCRIPTION
                rt_kprintf("%-16s -- %s\n", index->name, index->desc);
 801d948:	68fb      	ldr	r3, [r7, #12]
 801d94a:	681a      	ldr	r2, [r3, #0]
 801d94c:	68fb      	ldr	r3, [r7, #12]
 801d94e:	685b      	ldr	r3, [r3, #4]
 801d950:	4830      	ldr	r0, [pc, #192]	; (801da14 <list_prefix+0x270>)
 801d952:	4611      	mov	r1, r2
 801d954:	461a      	mov	r2, r3
 801d956:	f7f9 ffb1 	bl	80178bc <rt_kprintf>
    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
 801d95a:	68fb      	ldr	r3, [r7, #12]
 801d95c:	3310      	adds	r3, #16
 801d95e:	60fb      	str	r3, [r7, #12]

    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
 801d960:	4b32      	ldr	r3, [pc, #200]	; (801da2c <list_prefix+0x288>)
 801d962:	681b      	ldr	r3, [r3, #0]
    }

    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
 801d964:	68fa      	ldr	r2, [r7, #12]
 801d966:	429a      	cmp	r2, r3
 801d968:	d3bc      	bcc.n	801d8e4 <list_prefix+0x140>
            }
        }
    }

    /* checks in dynamic system variable */
    sysvar_item = global_sysvar_list;
 801d96a:	4b31      	ldr	r3, [pc, #196]	; (801da30 <list_prefix+0x28c>)
 801d96c:	681b      	ldr	r3, [r3, #0]
 801d96e:	623b      	str	r3, [r7, #32]
    while (sysvar_item != NULL)
 801d970:	e03a      	b.n	801d9e8 <list_prefix+0x244>
    {
        if (str_is_prefix(prefix, sysvar_item->sysvar.name) == 0)
 801d972:	6a3b      	ldr	r3, [r7, #32]
 801d974:	685b      	ldr	r3, [r3, #4]
 801d976:	6878      	ldr	r0, [r7, #4]
 801d978:	4619      	mov	r1, r3
 801d97a:	f7ff fec9 	bl	801d710 <str_is_prefix>
 801d97e:	4603      	mov	r3, r0
 801d980:	2b00      	cmp	r3, #0
 801d982:	d12e      	bne.n	801d9e2 <list_prefix+0x23e>
        {
            if (var_cnt == 0)
 801d984:	8bbb      	ldrh	r3, [r7, #28]
 801d986:	2b00      	cmp	r3, #0
 801d988:	d111      	bne.n	801d9ae <list_prefix+0x20a>
            {
                rt_kprintf("--variable:\n");
 801d98a:	4827      	ldr	r0, [pc, #156]	; (801da28 <list_prefix+0x284>)
 801d98c:	f7f9 ff96 	bl	80178bc <rt_kprintf>
                if (*prefix != 0 && name_ptr == NULL)
 801d990:	687b      	ldr	r3, [r7, #4]
 801d992:	781b      	ldrb	r3, [r3, #0]
 801d994:	2b00      	cmp	r3, #0
 801d996:	d00a      	beq.n	801d9ae <list_prefix+0x20a>
 801d998:	697b      	ldr	r3, [r7, #20]
 801d99a:	2b00      	cmp	r3, #0
 801d99c:	d107      	bne.n	801d9ae <list_prefix+0x20a>
                {
                    /* set name_ptr */
                    name_ptr = sysvar_item->sysvar.name;
 801d99e:	6a3b      	ldr	r3, [r7, #32]
 801d9a0:	685b      	ldr	r3, [r3, #4]
 801d9a2:	617b      	str	r3, [r7, #20]

                    /* set initial length */
                    min_length = strlen(name_ptr);
 801d9a4:	6978      	ldr	r0, [r7, #20]
 801d9a6:	f005 fe7d 	bl	80236a4 <strlen>
 801d9aa:	4603      	mov	r3, r0
 801d9ac:	61bb      	str	r3, [r7, #24]
                }
            }

            var_cnt ++;
 801d9ae:	8bbb      	ldrh	r3, [r7, #28]
 801d9b0:	3301      	adds	r3, #1
 801d9b2:	83bb      	strh	r3, [r7, #28]

            if (*prefix != 0)
 801d9b4:	687b      	ldr	r3, [r7, #4]
 801d9b6:	781b      	ldrb	r3, [r3, #0]
 801d9b8:	2b00      	cmp	r3, #0
 801d9ba:	d00c      	beq.n	801d9d6 <list_prefix+0x232>
            {
                length = str_common(name_ptr, sysvar_item->sysvar.name);
 801d9bc:	6a3b      	ldr	r3, [r7, #32]
 801d9be:	685b      	ldr	r3, [r3, #4]
 801d9c0:	6978      	ldr	r0, [r7, #20]
 801d9c2:	4619      	mov	r1, r3
 801d9c4:	f7ff fec8 	bl	801d758 <str_common>
 801d9c8:	60b8      	str	r0, [r7, #8]
                if (length < min_length)
 801d9ca:	68ba      	ldr	r2, [r7, #8]
 801d9cc:	69bb      	ldr	r3, [r7, #24]
 801d9ce:	429a      	cmp	r2, r3
 801d9d0:	da01      	bge.n	801d9d6 <list_prefix+0x232>
                    min_length = length;
 801d9d2:	68bb      	ldr	r3, [r7, #8]
 801d9d4:	61bb      	str	r3, [r7, #24]
            }

            rt_kprintf("[v] %s\n", sysvar_item->sysvar.name);
 801d9d6:	6a3b      	ldr	r3, [r7, #32]
 801d9d8:	685b      	ldr	r3, [r3, #4]
 801d9da:	4816      	ldr	r0, [pc, #88]	; (801da34 <list_prefix+0x290>)
 801d9dc:	4619      	mov	r1, r3
 801d9de:	f7f9 ff6d 	bl	80178bc <rt_kprintf>
        }
        sysvar_item = sysvar_item->next;
 801d9e2:	6a3b      	ldr	r3, [r7, #32]
 801d9e4:	681b      	ldr	r3, [r3, #0]
 801d9e6:	623b      	str	r3, [r7, #32]
        }
    }

    /* checks in dynamic system variable */
    sysvar_item = global_sysvar_list;
    while (sysvar_item != NULL)
 801d9e8:	6a3b      	ldr	r3, [r7, #32]
 801d9ea:	2b00      	cmp	r3, #0
 801d9ec:	d1c1      	bne.n	801d972 <list_prefix+0x1ce>
        }
        sysvar_item = sysvar_item->next;
    }

    /* only one matched */
    if (name_ptr != NULL)
 801d9ee:	697b      	ldr	r3, [r7, #20]
 801d9f0:	2b00      	cmp	r3, #0
 801d9f2:	d005      	beq.n	801da00 <list_prefix+0x25c>
    {
        rt_strncpy(prefix, name_ptr, min_length);
 801d9f4:	69bb      	ldr	r3, [r7, #24]
 801d9f6:	6878      	ldr	r0, [r7, #4]
 801d9f8:	6979      	ldr	r1, [r7, #20]
 801d9fa:	461a      	mov	r2, r3
 801d9fc:	f7f9 faae 	bl	8016f5c <rt_strncpy>
    }
}
 801da00:	3728      	adds	r7, #40	; 0x28
 801da02:	46bd      	mov	sp, r7
 801da04:	bd80      	pop	{r7, pc}
 801da06:	bf00      	nop
 801da08:	2001218c 	.word	0x2001218c
 801da0c:	08028ac8 	.word	0x08028ac8
 801da10:	08028af8 	.word	0x08028af8
 801da14:	08028acc 	.word	0x08028acc
 801da18:	20012190 	.word	0x20012190
 801da1c:	200121a8 	.word	0x200121a8
 801da20:	08028adc 	.word	0x08028adc
 801da24:	20012194 	.word	0x20012194
 801da28:	08028b08 	.word	0x08028b08
 801da2c:	20012198 	.word	0x20012198
 801da30:	20012d84 	.word	0x20012d84
 801da34:	08028b18 	.word	0x08028b18

0801da38 <cmd_ps>:
FINSH_FUNCTION_EXPORT_ALIAS(cmd_netstat, __cmd_netstat, list the information of TCP/IP);
#endif
#endif /* RT_USING_LWIP */

int cmd_ps(int argc, char** argv)
{
 801da38:	b580      	push	{r7, lr}
 801da3a:	b082      	sub	sp, #8
 801da3c:	af00      	add	r7, sp, #0
 801da3e:	6078      	str	r0, [r7, #4]
 801da40:	6039      	str	r1, [r7, #0]
    extern long list_thread(void);

    list_thread();
 801da42:	f7ff faab 	bl	801cf9c <list_thread>
    return 0;
 801da46:	2300      	movs	r3, #0
}
 801da48:	4618      	mov	r0, r3
 801da4a:	3708      	adds	r7, #8
 801da4c:	46bd      	mov	sp, r7
 801da4e:	bd80      	pop	{r7, pc}

0801da50 <cmd_time>:
FINSH_FUNCTION_EXPORT_ALIAS(cmd_ps, __cmd_ps, List threads in the system.);

int cmd_time(int argc, char** argv)
{
 801da50:	b480      	push	{r7}
 801da52:	b083      	sub	sp, #12
 801da54:	af00      	add	r7, sp, #0
 801da56:	6078      	str	r0, [r7, #4]
 801da58:	6039      	str	r1, [r7, #0]
    return 0;
 801da5a:	2300      	movs	r3, #0
}
 801da5c:	4618      	mov	r0, r3
 801da5e:	370c      	adds	r7, #12
 801da60:	46bd      	mov	sp, r7
 801da62:	f85d 7b04 	ldr.w	r7, [sp], #4
 801da66:	4770      	bx	lr

0801da68 <cmd_free>:
FINSH_FUNCTION_EXPORT_ALIAS(cmd_time, __cmd_time, Execute command with time.);

#ifdef RT_USING_HEAP
int cmd_free(int argc, char** argv)
{
 801da68:	b580      	push	{r7, lr}
 801da6a:	b082      	sub	sp, #8
 801da6c:	af00      	add	r7, sp, #0
 801da6e:	6078      	str	r0, [r7, #4]
 801da70:	6039      	str	r1, [r7, #0]
    extern void list_memheap(void);

#ifdef RT_USING_MEMHEAP_AS_HEAP
    list_memheap();
#else
    list_mem();
 801da72:	f7fa fb81 	bl	8018178 <list_mem>
#endif
    return 0;
 801da76:	2300      	movs	r3, #0
}
 801da78:	4618      	mov	r0, r3
 801da7a:	3708      	adds	r7, #8
 801da7c:	46bd      	mov	sp, r7
 801da7e:	bd80      	pop	{r7, pc}

0801da80 <msh_is_used>:
static rt_bool_t __msh_state = RT_TRUE;
#else
static rt_bool_t __msh_state = RT_FALSE;
#endif
rt_bool_t msh_is_used(void)
{
 801da80:	b480      	push	{r7}
 801da82:	af00      	add	r7, sp, #0
    return __msh_state;
 801da84:	4b03      	ldr	r3, [pc, #12]	; (801da94 <msh_is_used+0x14>)
 801da86:	681b      	ldr	r3, [r3, #0]
}
 801da88:	4618      	mov	r0, r3
 801da8a:	46bd      	mov	sp, r7
 801da8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801da90:	4770      	bx	lr
 801da92:	bf00      	nop
 801da94:	200100cc 	.word	0x200100cc

0801da98 <msh_exit>:

static int msh_exit(int argc, char** argv)
{
 801da98:	b480      	push	{r7}
 801da9a:	b083      	sub	sp, #12
 801da9c:	af00      	add	r7, sp, #0
 801da9e:	6078      	str	r0, [r7, #4]
 801daa0:	6039      	str	r1, [r7, #0]
    /* return to finsh shell mode */
    __msh_state = RT_FALSE;
 801daa2:	4b05      	ldr	r3, [pc, #20]	; (801dab8 <msh_exit+0x20>)
 801daa4:	2200      	movs	r2, #0
 801daa6:	601a      	str	r2, [r3, #0]

    return 0;
 801daa8:	2300      	movs	r3, #0
}
 801daaa:	4618      	mov	r0, r3
 801daac:	370c      	adds	r7, #12
 801daae:	46bd      	mov	sp, r7
 801dab0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801dab4:	4770      	bx	lr
 801dab6:	bf00      	nop
 801dab8:	200100cc 	.word	0x200100cc

0801dabc <msh_enter>:
FINSH_FUNCTION_EXPORT_ALIAS(msh_exit, __cmd_exit, return to RT-Thread shell mode.);

static int msh_enter(void)
{
 801dabc:	b480      	push	{r7}
 801dabe:	af00      	add	r7, sp, #0
    /* enter module shell mode */
    __msh_state = RT_TRUE;
 801dac0:	4b04      	ldr	r3, [pc, #16]	; (801dad4 <msh_enter+0x18>)
 801dac2:	2201      	movs	r2, #1
 801dac4:	601a      	str	r2, [r3, #0]
    return 0;
 801dac6:	2300      	movs	r3, #0
}
 801dac8:	4618      	mov	r0, r3
 801daca:	46bd      	mov	sp, r7
 801dacc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801dad0:	4770      	bx	lr
 801dad2:	bf00      	nop
 801dad4:	200100cc 	.word	0x200100cc

0801dad8 <msh_help>:
FINSH_FUNCTION_EXPORT_ALIAS(msh_enter, msh, use module shell);
#endif

int msh_help(int argc, char** argv)
{
 801dad8:	b580      	push	{r7, lr}
 801dada:	b084      	sub	sp, #16
 801dadc:	af00      	add	r7, sp, #0
 801dade:	6078      	str	r0, [r7, #4]
 801dae0:	6039      	str	r1, [r7, #0]
    rt_kprintf("RT-Thread shell commands:\n");
 801dae2:	4816      	ldr	r0, [pc, #88]	; (801db3c <msh_help+0x64>)
 801dae4:	f7f9 feea 	bl	80178bc <rt_kprintf>
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
 801dae8:	4b15      	ldr	r3, [pc, #84]	; (801db40 <msh_help+0x68>)
 801daea:	681b      	ldr	r3, [r3, #0]
 801daec:	60fb      	str	r3, [r7, #12]
 801daee:	e017      	b.n	801db20 <msh_help+0x48>
            index < _syscall_table_end;
            FINSH_NEXT_SYSCALL(index))
        {
            if (strncmp(index->name, "__cmd_", 6) != 0) continue;
 801daf0:	68fb      	ldr	r3, [r7, #12]
 801daf2:	681b      	ldr	r3, [r3, #0]
 801daf4:	4618      	mov	r0, r3
 801daf6:	4913      	ldr	r1, [pc, #76]	; (801db44 <msh_help+0x6c>)
 801daf8:	2206      	movs	r2, #6
 801dafa:	f005 fe01 	bl	8023700 <strncmp>
 801dafe:	4603      	mov	r3, r0
 801db00:	2b00      	cmp	r3, #0
 801db02:	d000      	beq.n	801db06 <msh_help+0x2e>
 801db04:	e009      	b.n	801db1a <msh_help+0x42>
#if defined(FINSH_USING_DESCRIPTION) && defined(FINSH_USING_SYMTAB)
            rt_kprintf("%-16s - %s\n", &index->name[6], index->desc);
 801db06:	68fb      	ldr	r3, [r7, #12]
 801db08:	681b      	ldr	r3, [r3, #0]
 801db0a:	1d9a      	adds	r2, r3, #6
 801db0c:	68fb      	ldr	r3, [r7, #12]
 801db0e:	685b      	ldr	r3, [r3, #4]
 801db10:	480d      	ldr	r0, [pc, #52]	; (801db48 <msh_help+0x70>)
 801db12:	4611      	mov	r1, r2
 801db14:	461a      	mov	r2, r3
 801db16:	f7f9 fed1 	bl	80178bc <rt_kprintf>
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
            index < _syscall_table_end;
            FINSH_NEXT_SYSCALL(index))
 801db1a:	68fb      	ldr	r3, [r7, #12]
 801db1c:	330c      	adds	r3, #12
 801db1e:	60fb      	str	r3, [r7, #12]
    rt_kprintf("RT-Thread shell commands:\n");
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
            index < _syscall_table_end;
 801db20:	4b0a      	ldr	r3, [pc, #40]	; (801db4c <msh_help+0x74>)
 801db22:	681b      	ldr	r3, [r3, #0]
{
    rt_kprintf("RT-Thread shell commands:\n");
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
 801db24:	68fa      	ldr	r2, [r7, #12]
 801db26:	429a      	cmp	r2, r3
 801db28:	d3e2      	bcc.n	801daf0 <msh_help+0x18>
#else
            rt_kprintf("%s ", &index->name[6]);
#endif
        }
    }
    rt_kprintf("\n");
 801db2a:	4809      	ldr	r0, [pc, #36]	; (801db50 <msh_help+0x78>)
 801db2c:	f7f9 fec6 	bl	80178bc <rt_kprintf>

    return 0;
 801db30:	2300      	movs	r3, #0
}
 801db32:	4618      	mov	r0, r3
 801db34:	3710      	adds	r7, #16
 801db36:	46bd      	mov	sp, r7
 801db38:	bd80      	pop	{r7, pc}
 801db3a:	bf00      	nop
 801db3c:	08028b20 	.word	0x08028b20
 801db40:	2001218c 	.word	0x2001218c
 801db44:	08028b3c 	.word	0x08028b3c
 801db48:	08028b44 	.word	0x08028b44
 801db4c:	20012190 	.word	0x20012190
 801db50:	08028b50 	.word	0x08028b50

0801db54 <msh_split>:
FINSH_FUNCTION_EXPORT_ALIAS(msh_help, __cmd_help, RT-Thread shell help.);

static int msh_split(char* cmd, rt_size_t length, char* argv[RT_FINSH_ARG_MAX])
{
 801db54:	b480      	push	{r7}
 801db56:	b089      	sub	sp, #36	; 0x24
 801db58:	af00      	add	r7, sp, #0
 801db5a:	60f8      	str	r0, [r7, #12]
 801db5c:	60b9      	str	r1, [r7, #8]
 801db5e:	607a      	str	r2, [r7, #4]
    char *ptr;
    rt_size_t position;
    rt_size_t argc;

    ptr = cmd;
 801db60:	68fb      	ldr	r3, [r7, #12]
 801db62:	61fb      	str	r3, [r7, #28]
    position = 0; argc = 0;
 801db64:	2300      	movs	r3, #0
 801db66:	61bb      	str	r3, [r7, #24]
 801db68:	2300      	movs	r3, #0
 801db6a:	617b      	str	r3, [r7, #20]

    while (position < length)
 801db6c:	e07b      	b.n	801dc66 <msh_split+0x112>
    {
        /* strip bank and tab */
        while ((*ptr == ' ' || *ptr == '\t') && position < length)
 801db6e:	e008      	b.n	801db82 <msh_split+0x2e>
        {
            *ptr = '\0';
 801db70:	69fb      	ldr	r3, [r7, #28]
 801db72:	2200      	movs	r2, #0
 801db74:	701a      	strb	r2, [r3, #0]
            ptr ++; position ++;
 801db76:	69fb      	ldr	r3, [r7, #28]
 801db78:	3301      	adds	r3, #1
 801db7a:	61fb      	str	r3, [r7, #28]
 801db7c:	69bb      	ldr	r3, [r7, #24]
 801db7e:	3301      	adds	r3, #1
 801db80:	61bb      	str	r3, [r7, #24]
    position = 0; argc = 0;

    while (position < length)
    {
        /* strip bank and tab */
        while ((*ptr == ' ' || *ptr == '\t') && position < length)
 801db82:	69fb      	ldr	r3, [r7, #28]
 801db84:	781b      	ldrb	r3, [r3, #0]
 801db86:	2b20      	cmp	r3, #32
 801db88:	d003      	beq.n	801db92 <msh_split+0x3e>
 801db8a:	69fb      	ldr	r3, [r7, #28]
 801db8c:	781b      	ldrb	r3, [r3, #0]
 801db8e:	2b09      	cmp	r3, #9
 801db90:	d103      	bne.n	801db9a <msh_split+0x46>
 801db92:	69ba      	ldr	r2, [r7, #24]
 801db94:	68bb      	ldr	r3, [r7, #8]
 801db96:	429a      	cmp	r2, r3
 801db98:	d3ea      	bcc.n	801db70 <msh_split+0x1c>
        {
            *ptr = '\0';
            ptr ++; position ++;
        }
        if (position >= length) break;
 801db9a:	69ba      	ldr	r2, [r7, #24]
 801db9c:	68bb      	ldr	r3, [r7, #8]
 801db9e:	429a      	cmp	r2, r3
 801dba0:	d300      	bcc.n	801dba4 <msh_split+0x50>
 801dba2:	e065      	b.n	801dc70 <msh_split+0x11c>

        /* handle string */
        if (*ptr == '"')
 801dba4:	69fb      	ldr	r3, [r7, #28]
 801dba6:	781b      	ldrb	r3, [r3, #0]
 801dba8:	2b22      	cmp	r3, #34	; 0x22
 801dbaa:	d13b      	bne.n	801dc24 <msh_split+0xd0>
        {
            ptr ++; position ++;
 801dbac:	69fb      	ldr	r3, [r7, #28]
 801dbae:	3301      	adds	r3, #1
 801dbb0:	61fb      	str	r3, [r7, #28]
 801dbb2:	69bb      	ldr	r3, [r7, #24]
 801dbb4:	3301      	adds	r3, #1
 801dbb6:	61bb      	str	r3, [r7, #24]
            argv[argc] = ptr; argc ++;
 801dbb8:	697b      	ldr	r3, [r7, #20]
 801dbba:	009b      	lsls	r3, r3, #2
 801dbbc:	687a      	ldr	r2, [r7, #4]
 801dbbe:	4413      	add	r3, r2
 801dbc0:	69fa      	ldr	r2, [r7, #28]
 801dbc2:	601a      	str	r2, [r3, #0]
 801dbc4:	697b      	ldr	r3, [r7, #20]
 801dbc6:	3301      	adds	r3, #1
 801dbc8:	617b      	str	r3, [r7, #20]

            /* skip this string */
            while (*ptr != '"' && position < length)
 801dbca:	e014      	b.n	801dbf6 <msh_split+0xa2>
            {
                if (*ptr == '\\')
 801dbcc:	69fb      	ldr	r3, [r7, #28]
 801dbce:	781b      	ldrb	r3, [r3, #0]
 801dbd0:	2b5c      	cmp	r3, #92	; 0x5c
 801dbd2:	d10a      	bne.n	801dbea <msh_split+0x96>
                {
                    if (*(ptr + 1) == '"')
 801dbd4:	69fb      	ldr	r3, [r7, #28]
 801dbd6:	3301      	adds	r3, #1
 801dbd8:	781b      	ldrb	r3, [r3, #0]
 801dbda:	2b22      	cmp	r3, #34	; 0x22
 801dbdc:	d105      	bne.n	801dbea <msh_split+0x96>
                    {
                        ptr ++; position ++;
 801dbde:	69fb      	ldr	r3, [r7, #28]
 801dbe0:	3301      	adds	r3, #1
 801dbe2:	61fb      	str	r3, [r7, #28]
 801dbe4:	69bb      	ldr	r3, [r7, #24]
 801dbe6:	3301      	adds	r3, #1
 801dbe8:	61bb      	str	r3, [r7, #24]
                    }
                }
                ptr ++; position ++;
 801dbea:	69fb      	ldr	r3, [r7, #28]
 801dbec:	3301      	adds	r3, #1
 801dbee:	61fb      	str	r3, [r7, #28]
 801dbf0:	69bb      	ldr	r3, [r7, #24]
 801dbf2:	3301      	adds	r3, #1
 801dbf4:	61bb      	str	r3, [r7, #24]
        {
            ptr ++; position ++;
            argv[argc] = ptr; argc ++;

            /* skip this string */
            while (*ptr != '"' && position < length)
 801dbf6:	69fb      	ldr	r3, [r7, #28]
 801dbf8:	781b      	ldrb	r3, [r3, #0]
 801dbfa:	2b22      	cmp	r3, #34	; 0x22
 801dbfc:	d003      	beq.n	801dc06 <msh_split+0xb2>
 801dbfe:	69ba      	ldr	r2, [r7, #24]
 801dc00:	68bb      	ldr	r3, [r7, #8]
 801dc02:	429a      	cmp	r2, r3
 801dc04:	d3e2      	bcc.n	801dbcc <msh_split+0x78>
                        ptr ++; position ++;
                    }
                }
                ptr ++; position ++;
            }
            if (position >= length) break;
 801dc06:	69ba      	ldr	r2, [r7, #24]
 801dc08:	68bb      	ldr	r3, [r7, #8]
 801dc0a:	429a      	cmp	r2, r3
 801dc0c:	d300      	bcc.n	801dc10 <msh_split+0xbc>
 801dc0e:	e02f      	b.n	801dc70 <msh_split+0x11c>

            /* skip '"' */
            *ptr = '\0'; ptr ++; position ++;
 801dc10:	69fb      	ldr	r3, [r7, #28]
 801dc12:	2200      	movs	r2, #0
 801dc14:	701a      	strb	r2, [r3, #0]
 801dc16:	69fb      	ldr	r3, [r7, #28]
 801dc18:	3301      	adds	r3, #1
 801dc1a:	61fb      	str	r3, [r7, #28]
 801dc1c:	69bb      	ldr	r3, [r7, #24]
 801dc1e:	3301      	adds	r3, #1
 801dc20:	61bb      	str	r3, [r7, #24]
 801dc22:	e020      	b.n	801dc66 <msh_split+0x112>
        }
        else
        {
            argv[argc] = ptr;
 801dc24:	697b      	ldr	r3, [r7, #20]
 801dc26:	009b      	lsls	r3, r3, #2
 801dc28:	687a      	ldr	r2, [r7, #4]
 801dc2a:	4413      	add	r3, r2
 801dc2c:	69fa      	ldr	r2, [r7, #28]
 801dc2e:	601a      	str	r2, [r3, #0]
            argc ++;
 801dc30:	697b      	ldr	r3, [r7, #20]
 801dc32:	3301      	adds	r3, #1
 801dc34:	617b      	str	r3, [r7, #20]
            while ((*ptr != ' ' && *ptr != '\t') && position < length)
 801dc36:	e005      	b.n	801dc44 <msh_split+0xf0>
            {
                ptr ++; position ++;
 801dc38:	69fb      	ldr	r3, [r7, #28]
 801dc3a:	3301      	adds	r3, #1
 801dc3c:	61fb      	str	r3, [r7, #28]
 801dc3e:	69bb      	ldr	r3, [r7, #24]
 801dc40:	3301      	adds	r3, #1
 801dc42:	61bb      	str	r3, [r7, #24]
        }
        else
        {
            argv[argc] = ptr;
            argc ++;
            while ((*ptr != ' ' && *ptr != '\t') && position < length)
 801dc44:	69fb      	ldr	r3, [r7, #28]
 801dc46:	781b      	ldrb	r3, [r3, #0]
 801dc48:	2b20      	cmp	r3, #32
 801dc4a:	d007      	beq.n	801dc5c <msh_split+0x108>
 801dc4c:	69fb      	ldr	r3, [r7, #28]
 801dc4e:	781b      	ldrb	r3, [r3, #0]
 801dc50:	2b09      	cmp	r3, #9
 801dc52:	d003      	beq.n	801dc5c <msh_split+0x108>
 801dc54:	69ba      	ldr	r2, [r7, #24]
 801dc56:	68bb      	ldr	r3, [r7, #8]
 801dc58:	429a      	cmp	r2, r3
 801dc5a:	d3ed      	bcc.n	801dc38 <msh_split+0xe4>
            {
                ptr ++; position ++;
            }
            if (position >= length) break;
 801dc5c:	69ba      	ldr	r2, [r7, #24]
 801dc5e:	68bb      	ldr	r3, [r7, #8]
 801dc60:	429a      	cmp	r2, r3
 801dc62:	d300      	bcc.n	801dc66 <msh_split+0x112>
 801dc64:	e004      	b.n	801dc70 <msh_split+0x11c>
    rt_size_t argc;

    ptr = cmd;
    position = 0; argc = 0;

    while (position < length)
 801dc66:	69ba      	ldr	r2, [r7, #24]
 801dc68:	68bb      	ldr	r3, [r7, #8]
 801dc6a:	429a      	cmp	r2, r3
 801dc6c:	f4ff af7f 	bcc.w	801db6e <msh_split+0x1a>
            }
            if (position >= length) break;
        }
    }

    return argc;
 801dc70:	697b      	ldr	r3, [r7, #20]
}
 801dc72:	4618      	mov	r0, r3
 801dc74:	3724      	adds	r7, #36	; 0x24
 801dc76:	46bd      	mov	sp, r7
 801dc78:	f85d 7b04 	ldr.w	r7, [sp], #4
 801dc7c:	4770      	bx	lr
 801dc7e:	bf00      	nop

0801dc80 <msh_get_cmd>:

static cmd_function_t msh_get_cmd(char *cmd, int size)
{
 801dc80:	b580      	push	{r7, lr}
 801dc82:	b084      	sub	sp, #16
 801dc84:	af00      	add	r7, sp, #0
 801dc86:	6078      	str	r0, [r7, #4]
 801dc88:	6039      	str	r1, [r7, #0]
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;
 801dc8a:	2300      	movs	r3, #0
 801dc8c:	60bb      	str	r3, [r7, #8]

    for (index = _syscall_table_begin;
 801dc8e:	4b1a      	ldr	r3, [pc, #104]	; (801dcf8 <msh_get_cmd+0x78>)
 801dc90:	681b      	ldr	r3, [r3, #0]
 801dc92:	60fb      	str	r3, [r7, #12]
 801dc94:	e025      	b.n	801dce2 <msh_get_cmd+0x62>
        index < _syscall_table_end;
        FINSH_NEXT_SYSCALL(index))
    {
        if (strncmp(index->name, "__cmd_", 6) != 0) continue;
 801dc96:	68fb      	ldr	r3, [r7, #12]
 801dc98:	681b      	ldr	r3, [r3, #0]
 801dc9a:	4618      	mov	r0, r3
 801dc9c:	4917      	ldr	r1, [pc, #92]	; (801dcfc <msh_get_cmd+0x7c>)
 801dc9e:	2206      	movs	r2, #6
 801dca0:	f005 fd2e 	bl	8023700 <strncmp>
 801dca4:	4603      	mov	r3, r0
 801dca6:	2b00      	cmp	r3, #0
 801dca8:	d000      	beq.n	801dcac <msh_get_cmd+0x2c>
 801dcaa:	e017      	b.n	801dcdc <msh_get_cmd+0x5c>
        
        if (strncmp(&index->name[6], cmd, size) == 0 &&
 801dcac:	68fb      	ldr	r3, [r7, #12]
 801dcae:	681b      	ldr	r3, [r3, #0]
 801dcb0:	1d9a      	adds	r2, r3, #6
 801dcb2:	683b      	ldr	r3, [r7, #0]
 801dcb4:	4610      	mov	r0, r2
 801dcb6:	6879      	ldr	r1, [r7, #4]
 801dcb8:	461a      	mov	r2, r3
 801dcba:	f005 fd21 	bl	8023700 <strncmp>
 801dcbe:	4603      	mov	r3, r0
 801dcc0:	2b00      	cmp	r3, #0
 801dcc2:	d10b      	bne.n	801dcdc <msh_get_cmd+0x5c>
			index->name[6 + size] == '\0')
 801dcc4:	68fb      	ldr	r3, [r7, #12]
 801dcc6:	681b      	ldr	r3, [r3, #0]
 801dcc8:	683a      	ldr	r2, [r7, #0]
 801dcca:	3206      	adds	r2, #6
 801dccc:	4413      	add	r3, r2
 801dcce:	781b      	ldrb	r3, [r3, #0]
        index < _syscall_table_end;
        FINSH_NEXT_SYSCALL(index))
    {
        if (strncmp(index->name, "__cmd_", 6) != 0) continue;
        
        if (strncmp(&index->name[6], cmd, size) == 0 &&
 801dcd0:	2b00      	cmp	r3, #0
 801dcd2:	d103      	bne.n	801dcdc <msh_get_cmd+0x5c>
			index->name[6 + size] == '\0')
        {
            cmd_func = (cmd_function_t)index->func;
 801dcd4:	68fb      	ldr	r3, [r7, #12]
 801dcd6:	689b      	ldr	r3, [r3, #8]
 801dcd8:	60bb      	str	r3, [r7, #8]
            break;
 801dcda:	e007      	b.n	801dcec <msh_get_cmd+0x6c>
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;

    for (index = _syscall_table_begin;
        index < _syscall_table_end;
        FINSH_NEXT_SYSCALL(index))
 801dcdc:	68fb      	ldr	r3, [r7, #12]
 801dcde:	330c      	adds	r3, #12
 801dce0:	60fb      	str	r3, [r7, #12]
{
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;

    for (index = _syscall_table_begin;
        index < _syscall_table_end;
 801dce2:	4b07      	ldr	r3, [pc, #28]	; (801dd00 <msh_get_cmd+0x80>)
 801dce4:	681b      	ldr	r3, [r3, #0]
static cmd_function_t msh_get_cmd(char *cmd, int size)
{
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;

    for (index = _syscall_table_begin;
 801dce6:	68fa      	ldr	r2, [r7, #12]
 801dce8:	429a      	cmp	r2, r3
 801dcea:	d3d4      	bcc.n	801dc96 <msh_get_cmd+0x16>
            cmd_func = (cmd_function_t)index->func;
            break;
        }
    }

    return cmd_func;
 801dcec:	68bb      	ldr	r3, [r7, #8]
}
 801dcee:	4618      	mov	r0, r3
 801dcf0:	3710      	adds	r7, #16
 801dcf2:	46bd      	mov	sp, r7
 801dcf4:	bd80      	pop	{r7, pc}
 801dcf6:	bf00      	nop
 801dcf8:	2001218c 	.word	0x2001218c
 801dcfc:	08028b3c 	.word	0x08028b3c
 801dd00:	20012190 	.word	0x20012190

0801dd04 <_msh_exec_cmd>:
}
RTM_EXPORT(system);
#endif

static int _msh_exec_cmd(char* cmd, rt_size_t length, int *retp)
{
 801dd04:	b580      	push	{r7, lr}
 801dd06:	b092      	sub	sp, #72	; 0x48
 801dd08:	af00      	add	r7, sp, #0
 801dd0a:	60f8      	str	r0, [r7, #12]
 801dd0c:	60b9      	str	r1, [r7, #8]
 801dd0e:	607a      	str	r2, [r7, #4]
    int argc;
    int cmd0_size = 0;
 801dd10:	2300      	movs	r3, #0
 801dd12:	647b      	str	r3, [r7, #68]	; 0x44
    cmd_function_t cmd_func;
    char *argv[RT_FINSH_ARG_MAX];

    RT_ASSERT(cmd);
 801dd14:	68fb      	ldr	r3, [r7, #12]
 801dd16:	2b00      	cmp	r3, #0
 801dd18:	d105      	bne.n	801dd26 <_msh_exec_cmd+0x22>
 801dd1a:	482b      	ldr	r0, [pc, #172]	; (801ddc8 <_msh_exec_cmd+0xc4>)
 801dd1c:	492b      	ldr	r1, [pc, #172]	; (801ddcc <_msh_exec_cmd+0xc8>)
 801dd1e:	f44f 7285 	mov.w	r2, #266	; 0x10a
 801dd22:	f7f9 fe45 	bl	80179b0 <rt_assert_handler>
    RT_ASSERT(retp);
 801dd26:	687b      	ldr	r3, [r7, #4]
 801dd28:	2b00      	cmp	r3, #0
 801dd2a:	d105      	bne.n	801dd38 <_msh_exec_cmd+0x34>
 801dd2c:	4828      	ldr	r0, [pc, #160]	; (801ddd0 <_msh_exec_cmd+0xcc>)
 801dd2e:	4927      	ldr	r1, [pc, #156]	; (801ddcc <_msh_exec_cmd+0xc8>)
 801dd30:	f240 120b 	movw	r2, #267	; 0x10b
 801dd34:	f7f9 fe3c 	bl	80179b0 <rt_assert_handler>

    /* find the size of first command */
    while ((cmd[cmd0_size] != ' ' && cmd[cmd0_size] != '\t') && cmd0_size < length)
 801dd38:	e002      	b.n	801dd40 <_msh_exec_cmd+0x3c>
        cmd0_size ++;
 801dd3a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801dd3c:	3301      	adds	r3, #1
 801dd3e:	647b      	str	r3, [r7, #68]	; 0x44

    RT_ASSERT(cmd);
    RT_ASSERT(retp);

    /* find the size of first command */
    while ((cmd[cmd0_size] != ' ' && cmd[cmd0_size] != '\t') && cmd0_size < length)
 801dd40:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801dd42:	68fa      	ldr	r2, [r7, #12]
 801dd44:	4413      	add	r3, r2
 801dd46:	781b      	ldrb	r3, [r3, #0]
 801dd48:	2b20      	cmp	r3, #32
 801dd4a:	d009      	beq.n	801dd60 <_msh_exec_cmd+0x5c>
 801dd4c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801dd4e:	68fa      	ldr	r2, [r7, #12]
 801dd50:	4413      	add	r3, r2
 801dd52:	781b      	ldrb	r3, [r3, #0]
 801dd54:	2b09      	cmp	r3, #9
 801dd56:	d003      	beq.n	801dd60 <_msh_exec_cmd+0x5c>
 801dd58:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801dd5a:	68bb      	ldr	r3, [r7, #8]
 801dd5c:	429a      	cmp	r2, r3
 801dd5e:	d3ec      	bcc.n	801dd3a <_msh_exec_cmd+0x36>
        cmd0_size ++;
    if (cmd0_size == 0)
 801dd60:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801dd62:	2b00      	cmp	r3, #0
 801dd64:	d102      	bne.n	801dd6c <_msh_exec_cmd+0x68>
        return -RT_ERROR;
 801dd66:	f04f 33ff 	mov.w	r3, #4294967295
 801dd6a:	e029      	b.n	801ddc0 <_msh_exec_cmd+0xbc>

    cmd_func = msh_get_cmd(cmd, cmd0_size);
 801dd6c:	68f8      	ldr	r0, [r7, #12]
 801dd6e:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801dd70:	f7ff ff86 	bl	801dc80 <msh_get_cmd>
 801dd74:	6438      	str	r0, [r7, #64]	; 0x40
    if (cmd_func == RT_NULL)
 801dd76:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801dd78:	2b00      	cmp	r3, #0
 801dd7a:	d102      	bne.n	801dd82 <_msh_exec_cmd+0x7e>
        return -RT_ERROR;
 801dd7c:	f04f 33ff 	mov.w	r3, #4294967295
 801dd80:	e01e      	b.n	801ddc0 <_msh_exec_cmd+0xbc>

    /* split arguments */
    memset(argv, 0x00, sizeof(argv));
 801dd82:	f107 0314 	add.w	r3, r7, #20
 801dd86:	4618      	mov	r0, r3
 801dd88:	2100      	movs	r1, #0
 801dd8a:	2228      	movs	r2, #40	; 0x28
 801dd8c:	f004 fff8 	bl	8022d80 <memset>
    argc = msh_split(cmd, length, argv);
 801dd90:	f107 0314 	add.w	r3, r7, #20
 801dd94:	68f8      	ldr	r0, [r7, #12]
 801dd96:	68b9      	ldr	r1, [r7, #8]
 801dd98:	461a      	mov	r2, r3
 801dd9a:	f7ff fedb 	bl	801db54 <msh_split>
 801dd9e:	63f8      	str	r0, [r7, #60]	; 0x3c
    if (argc == 0)
 801dda0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801dda2:	2b00      	cmp	r3, #0
 801dda4:	d102      	bne.n	801ddac <_msh_exec_cmd+0xa8>
        return -RT_ERROR;
 801dda6:	f04f 33ff 	mov.w	r3, #4294967295
 801ddaa:	e009      	b.n	801ddc0 <_msh_exec_cmd+0xbc>

    /* exec this command */
    *retp = cmd_func(argc, argv);
 801ddac:	f107 0214 	add.w	r2, r7, #20
 801ddb0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801ddb2:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 801ddb4:	4611      	mov	r1, r2
 801ddb6:	4798      	blx	r3
 801ddb8:	4602      	mov	r2, r0
 801ddba:	687b      	ldr	r3, [r7, #4]
 801ddbc:	601a      	str	r2, [r3, #0]
    return 0;
 801ddbe:	2300      	movs	r3, #0
}
 801ddc0:	4618      	mov	r0, r3
 801ddc2:	3748      	adds	r7, #72	; 0x48
 801ddc4:	46bd      	mov	sp, r7
 801ddc6:	bd80      	pop	{r7, pc}
 801ddc8:	08028b54 	.word	0x08028b54
 801ddcc:	08029ba0 	.word	0x08029ba0
 801ddd0:	08028b58 	.word	0x08028b58

0801ddd4 <msh_exec>:

int msh_exec(char* cmd, rt_size_t length)
{
 801ddd4:	b580      	push	{r7, lr}
 801ddd6:	b084      	sub	sp, #16
 801ddd8:	af00      	add	r7, sp, #0
 801ddda:	6078      	str	r0, [r7, #4]
 801dddc:	6039      	str	r1, [r7, #0]
    int cmd_ret;

	/* strim the beginning of command */
    while(*cmd  == ' ' || *cmd == '\t')
 801ddde:	e005      	b.n	801ddec <msh_exec+0x18>
    {
        cmd++;
 801dde0:	687b      	ldr	r3, [r7, #4]
 801dde2:	3301      	adds	r3, #1
 801dde4:	607b      	str	r3, [r7, #4]
        length--;
 801dde6:	683b      	ldr	r3, [r7, #0]
 801dde8:	3b01      	subs	r3, #1
 801ddea:	603b      	str	r3, [r7, #0]
int msh_exec(char* cmd, rt_size_t length)
{
    int cmd_ret;

	/* strim the beginning of command */
    while(*cmd  == ' ' || *cmd == '\t')
 801ddec:	687b      	ldr	r3, [r7, #4]
 801ddee:	781b      	ldrb	r3, [r3, #0]
 801ddf0:	2b20      	cmp	r3, #32
 801ddf2:	d0f5      	beq.n	801dde0 <msh_exec+0xc>
 801ddf4:	687b      	ldr	r3, [r7, #4]
 801ddf6:	781b      	ldrb	r3, [r3, #0]
 801ddf8:	2b09      	cmp	r3, #9
 801ddfa:	d0f1      	beq.n	801dde0 <msh_exec+0xc>
    {
        cmd++;
        length--;
    }

    if (length == 0)
 801ddfc:	683b      	ldr	r3, [r7, #0]
 801ddfe:	2b00      	cmp	r3, #0
 801de00:	d101      	bne.n	801de06 <msh_exec+0x32>
        return 0;
 801de02:	2300      	movs	r3, #0
 801de04:	e022      	b.n	801de4c <msh_exec+0x78>
    /* Exec sequence:
     * 1. built-in command
     * 2. module(if enabled)
     * 3. chdir to the directry(if possible)
     */
    if (_msh_exec_cmd(cmd, length, &cmd_ret) == 0)
 801de06:	f107 0308 	add.w	r3, r7, #8
 801de0a:	6878      	ldr	r0, [r7, #4]
 801de0c:	6839      	ldr	r1, [r7, #0]
 801de0e:	461a      	mov	r2, r3
 801de10:	f7ff ff78 	bl	801dd04 <_msh_exec_cmd>
 801de14:	4603      	mov	r3, r0
 801de16:	2b00      	cmp	r3, #0
 801de18:	d101      	bne.n	801de1e <msh_exec+0x4a>
    {
        return cmd_ret;
 801de1a:	68bb      	ldr	r3, [r7, #8]
 801de1c:	e016      	b.n	801de4c <msh_exec+0x78>
#endif

    /* truncate the cmd at the first space. */
    {
        char *tcmd;
        tcmd = cmd;
 801de1e:	687b      	ldr	r3, [r7, #4]
 801de20:	60fb      	str	r3, [r7, #12]
        while(*tcmd != ' ' && *tcmd != '\0')
 801de22:	e002      	b.n	801de2a <msh_exec+0x56>
        {
            tcmd++;
 801de24:	68fb      	ldr	r3, [r7, #12]
 801de26:	3301      	adds	r3, #1
 801de28:	60fb      	str	r3, [r7, #12]

    /* truncate the cmd at the first space. */
    {
        char *tcmd;
        tcmd = cmd;
        while(*tcmd != ' ' && *tcmd != '\0')
 801de2a:	68fb      	ldr	r3, [r7, #12]
 801de2c:	781b      	ldrb	r3, [r3, #0]
 801de2e:	2b20      	cmp	r3, #32
 801de30:	d003      	beq.n	801de3a <msh_exec+0x66>
 801de32:	68fb      	ldr	r3, [r7, #12]
 801de34:	781b      	ldrb	r3, [r3, #0]
 801de36:	2b00      	cmp	r3, #0
 801de38:	d1f4      	bne.n	801de24 <msh_exec+0x50>
        {
            tcmd++;
        }
        *tcmd = '\0';
 801de3a:	68fb      	ldr	r3, [r7, #12]
 801de3c:	2200      	movs	r2, #0
 801de3e:	701a      	strb	r2, [r3, #0]
    }
    rt_kprintf("%s: command not found.\n", cmd);
 801de40:	4804      	ldr	r0, [pc, #16]	; (801de54 <msh_exec+0x80>)
 801de42:	6879      	ldr	r1, [r7, #4]
 801de44:	f7f9 fd3a 	bl	80178bc <rt_kprintf>
    return -1;
 801de48:	f04f 33ff 	mov.w	r3, #4294967295
}
 801de4c:	4618      	mov	r0, r3
 801de4e:	3710      	adds	r7, #16
 801de50:	46bd      	mov	sp, r7
 801de52:	bd80      	pop	{r7, pc}
 801de54:	08028b60 	.word	0x08028b60

0801de58 <str_common>:

static int str_common(const char *str1, const char *str2)
{
 801de58:	b480      	push	{r7}
 801de5a:	b085      	sub	sp, #20
 801de5c:	af00      	add	r7, sp, #0
 801de5e:	6078      	str	r0, [r7, #4]
 801de60:	6039      	str	r1, [r7, #0]
    const char *str = str1;
 801de62:	687b      	ldr	r3, [r7, #4]
 801de64:	60fb      	str	r3, [r7, #12]

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
 801de66:	e005      	b.n	801de74 <str_common+0x1c>
    {
        str ++;
 801de68:	68fb      	ldr	r3, [r7, #12]
 801de6a:	3301      	adds	r3, #1
 801de6c:	60fb      	str	r3, [r7, #12]
        str2 ++;
 801de6e:	683b      	ldr	r3, [r7, #0]
 801de70:	3301      	adds	r3, #1
 801de72:	603b      	str	r3, [r7, #0]

static int str_common(const char *str1, const char *str2)
{
    const char *str = str1;

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
 801de74:	68fb      	ldr	r3, [r7, #12]
 801de76:	781b      	ldrb	r3, [r3, #0]
 801de78:	2b00      	cmp	r3, #0
 801de7a:	d009      	beq.n	801de90 <str_common+0x38>
 801de7c:	683b      	ldr	r3, [r7, #0]
 801de7e:	781b      	ldrb	r3, [r3, #0]
 801de80:	2b00      	cmp	r3, #0
 801de82:	d005      	beq.n	801de90 <str_common+0x38>
 801de84:	68fb      	ldr	r3, [r7, #12]
 801de86:	781a      	ldrb	r2, [r3, #0]
 801de88:	683b      	ldr	r3, [r7, #0]
 801de8a:	781b      	ldrb	r3, [r3, #0]
 801de8c:	429a      	cmp	r2, r3
 801de8e:	d0eb      	beq.n	801de68 <str_common+0x10>
    {
        str ++;
        str2 ++;
    }

    return (str - str1);
 801de90:	68fa      	ldr	r2, [r7, #12]
 801de92:	687b      	ldr	r3, [r7, #4]
 801de94:	1ad3      	subs	r3, r2, r3
}
 801de96:	4618      	mov	r0, r3
 801de98:	3714      	adds	r7, #20
 801de9a:	46bd      	mov	sp, r7
 801de9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801dea0:	4770      	bx	lr
 801dea2:	bf00      	nop

0801dea4 <msh_auto_complete>:
    rt_free(full_path);
}
#endif

void msh_auto_complete(char *prefix)
{
 801dea4:	b580      	push	{r7, lr}
 801dea6:	b088      	sub	sp, #32
 801dea8:	af00      	add	r7, sp, #0
 801deaa:	6078      	str	r0, [r7, #4]
    int length, min_length;
    const char *name_ptr, *cmd_name;
    struct finsh_syscall *index;

    min_length = 0;
 801deac:	2300      	movs	r3, #0
 801deae:	61fb      	str	r3, [r7, #28]
    name_ptr = RT_NULL;
 801deb0:	2300      	movs	r3, #0
 801deb2:	61bb      	str	r3, [r7, #24]

    if (*prefix == '\0') 
 801deb4:	687b      	ldr	r3, [r7, #4]
 801deb6:	781b      	ldrb	r3, [r3, #0]
 801deb8:	2b00      	cmp	r3, #0
 801deba:	d104      	bne.n	801dec6 <msh_auto_complete+0x22>
    {
        msh_help(0, RT_NULL);
 801debc:	2000      	movs	r0, #0
 801debe:	2100      	movs	r1, #0
 801dec0:	f7ff fe0a 	bl	801dad8 <msh_help>
        return;
 801dec4:	e049      	b.n	801df5a <msh_auto_complete+0xb6>
    }
#endif

    /* checks in internal command */
    {
        for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
 801dec6:	4b26      	ldr	r3, [pc, #152]	; (801df60 <msh_auto_complete+0xbc>)
 801dec8:	681b      	ldr	r3, [r3, #0]
 801deca:	617b      	str	r3, [r7, #20]
 801decc:	e036      	b.n	801df3c <msh_auto_complete+0x98>
        {
            /* skip finsh shell function */
            if (strncmp(index->name, "__cmd_", 6) != 0) continue;
 801dece:	697b      	ldr	r3, [r7, #20]
 801ded0:	681b      	ldr	r3, [r3, #0]
 801ded2:	4618      	mov	r0, r3
 801ded4:	4923      	ldr	r1, [pc, #140]	; (801df64 <msh_auto_complete+0xc0>)
 801ded6:	2206      	movs	r2, #6
 801ded8:	f005 fc12 	bl	8023700 <strncmp>
 801dedc:	4603      	mov	r3, r0
 801dede:	2b00      	cmp	r3, #0
 801dee0:	d000      	beq.n	801dee4 <msh_auto_complete+0x40>
 801dee2:	e028      	b.n	801df36 <msh_auto_complete+0x92>

            cmd_name = (const char*) &index->name[6];
 801dee4:	697b      	ldr	r3, [r7, #20]
 801dee6:	681b      	ldr	r3, [r3, #0]
 801dee8:	3306      	adds	r3, #6
 801deea:	613b      	str	r3, [r7, #16]
            if (strncmp(prefix, cmd_name, strlen(prefix)) == 0)
 801deec:	6878      	ldr	r0, [r7, #4]
 801deee:	f005 fbd9 	bl	80236a4 <strlen>
 801def2:	4603      	mov	r3, r0
 801def4:	6878      	ldr	r0, [r7, #4]
 801def6:	6939      	ldr	r1, [r7, #16]
 801def8:	461a      	mov	r2, r3
 801defa:	f005 fc01 	bl	8023700 <strncmp>
 801defe:	4603      	mov	r3, r0
 801df00:	2b00      	cmp	r3, #0
 801df02:	d118      	bne.n	801df36 <msh_auto_complete+0x92>
            {
                if (min_length == 0)
 801df04:	69fb      	ldr	r3, [r7, #28]
 801df06:	2b00      	cmp	r3, #0
 801df08:	d106      	bne.n	801df18 <msh_auto_complete+0x74>
                {
                    /* set name_ptr */
                    name_ptr = cmd_name;
 801df0a:	693b      	ldr	r3, [r7, #16]
 801df0c:	61bb      	str	r3, [r7, #24]
                    /* set initial length */
                    min_length = strlen(name_ptr);
 801df0e:	69b8      	ldr	r0, [r7, #24]
 801df10:	f005 fbc8 	bl	80236a4 <strlen>
 801df14:	4603      	mov	r3, r0
 801df16:	61fb      	str	r3, [r7, #28]
                }

                length = str_common(name_ptr, cmd_name);
 801df18:	69b8      	ldr	r0, [r7, #24]
 801df1a:	6939      	ldr	r1, [r7, #16]
 801df1c:	f7ff ff9c 	bl	801de58 <str_common>
 801df20:	60f8      	str	r0, [r7, #12]
                if (length < min_length)
 801df22:	68fa      	ldr	r2, [r7, #12]
 801df24:	69fb      	ldr	r3, [r7, #28]
 801df26:	429a      	cmp	r2, r3
 801df28:	da01      	bge.n	801df2e <msh_auto_complete+0x8a>
                    min_length = length;
 801df2a:	68fb      	ldr	r3, [r7, #12]
 801df2c:	61fb      	str	r3, [r7, #28]

                rt_kprintf("%s\n", cmd_name);
 801df2e:	480e      	ldr	r0, [pc, #56]	; (801df68 <msh_auto_complete+0xc4>)
 801df30:	6939      	ldr	r1, [r7, #16]
 801df32:	f7f9 fcc3 	bl	80178bc <rt_kprintf>
    }
#endif

    /* checks in internal command */
    {
        for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
 801df36:	697b      	ldr	r3, [r7, #20]
 801df38:	330c      	adds	r3, #12
 801df3a:	617b      	str	r3, [r7, #20]
 801df3c:	4b0b      	ldr	r3, [pc, #44]	; (801df6c <msh_auto_complete+0xc8>)
 801df3e:	681b      	ldr	r3, [r3, #0]
 801df40:	697a      	ldr	r2, [r7, #20]
 801df42:	429a      	cmp	r2, r3
 801df44:	d3c3      	bcc.n	801dece <msh_auto_complete+0x2a>
            }
        }
    }

    /* auto complete string */
    if (name_ptr != NULL)
 801df46:	69bb      	ldr	r3, [r7, #24]
 801df48:	2b00      	cmp	r3, #0
 801df4a:	d005      	beq.n	801df58 <msh_auto_complete+0xb4>
    {
        rt_strncpy(prefix, name_ptr, min_length);
 801df4c:	69fb      	ldr	r3, [r7, #28]
 801df4e:	6878      	ldr	r0, [r7, #4]
 801df50:	69b9      	ldr	r1, [r7, #24]
 801df52:	461a      	mov	r2, r3
 801df54:	f7f9 f802 	bl	8016f5c <rt_strncpy>
    }

    return ;
 801df58:	bf00      	nop
}
 801df5a:	3720      	adds	r7, #32
 801df5c:	46bd      	mov	sp, r7
 801df5e:	bd80      	pop	{r7, pc}
 801df60:	2001218c 	.word	0x2001218c
 801df64:	08028b3c 	.word	0x08028b3c
 801df68:	08028b78 	.word	0x08028b78
 801df6c:	20012190 	.word	0x20012190

0801df70 <finsh_compile>:
#define finsh_code_byte(x)  do { *finsh_compile_pc = (x); finsh_compile_pc ++; } while(0)
#define finsh_code_word(x)  do { FINSH_SET16(finsh_compile_pc, x); finsh_compile_pc +=2; } while(0)
#define finsh_code_dword(x) do { FINSH_SET32(finsh_compile_pc, x); finsh_compile_pc +=4; } while(0)

static int finsh_compile(struct finsh_node* node)
{
 801df70:	b580      	push	{r7, lr}
 801df72:	b08a      	sub	sp, #40	; 0x28
 801df74:	af00      	add	r7, sp, #0
 801df76:	6078      	str	r0, [r7, #4]
    if (node != NULL)
 801df78:	687b      	ldr	r3, [r7, #4]
 801df7a:	2b00      	cmp	r3, #0
 801df7c:	f001 83e0 	beq.w	801f740 <finsh_compile+0x17d0>
    {
        /* compile child node */
        if (finsh_node_child(node) != NULL)
 801df80:	687b      	ldr	r3, [r7, #4]
 801df82:	691b      	ldr	r3, [r3, #16]
 801df84:	2b00      	cmp	r3, #0
 801df86:	d004      	beq.n	801df92 <finsh_compile+0x22>
            finsh_compile(finsh_node_child(node));
 801df88:	687b      	ldr	r3, [r7, #4]
 801df8a:	691b      	ldr	r3, [r3, #16]
 801df8c:	4618      	mov	r0, r3
 801df8e:	f7ff ffef 	bl	801df70 <finsh_compile>

        /* compile current node */
        switch (node->node_type)
 801df92:	687b      	ldr	r3, [r7, #4]
 801df94:	781b      	ldrb	r3, [r3, #0]
 801df96:	3b01      	subs	r3, #1
 801df98:	2b1a      	cmp	r3, #26
 801df9a:	f201 83c1 	bhi.w	801f720 <finsh_compile+0x17b0>
 801df9e:	a201      	add	r2, pc, #4	; (adr r2, 801dfa4 <finsh_compile+0x34>)
 801dfa0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801dfa4:	0801e011 	.word	0x0801e011
 801dfa8:	0801e413 	.word	0x0801e413
 801dfac:	0801e43d 	.word	0x0801e43d
 801dfb0:	0801e43d 	.word	0x0801e43d
 801dfb4:	0801e499 	.word	0x0801e499
 801dfb8:	0801e499 	.word	0x0801e499
 801dfbc:	0801e4f5 	.word	0x0801e4f5
 801dfc0:	0801e553 	.word	0x0801e553
 801dfc4:	0801e5ad 	.word	0x0801e5ad
 801dfc8:	0801e607 	.word	0x0801e607
 801dfcc:	0801e661 	.word	0x0801e661
 801dfd0:	0801e6bb 	.word	0x0801e6bb
 801dfd4:	0801e715 	.word	0x0801e715
 801dfd8:	0801e775 	.word	0x0801e775
 801dfdc:	0801e7cf 	.word	0x0801e7cf
 801dfe0:	0801e829 	.word	0x0801e829
 801dfe4:	0801e883 	.word	0x0801e883
 801dfe8:	0801e8dd 	.word	0x0801e8dd
 801dfec:	0801e933 	.word	0x0801e933
 801dff0:	0801f721 	.word	0x0801f721
 801dff4:	0801ea79 	.word	0x0801ea79
 801dff8:	0801ecfb 	.word	0x0801ecfb
 801dffc:	0801ef7b 	.word	0x0801ef7b
 801e000:	0801f309 	.word	0x0801f309
 801e004:	0801f6c5 	.word	0x0801f6c5
 801e008:	0801f729 	.word	0x0801f729
 801e00c:	0801f68f 	.word	0x0801f68f
        {
        case FINSH_NODE_ID:
            {
                /* identifier::syscall */
                if (node->idtype & FINSH_IDTYPE_SYSCALL)
 801e010:	687b      	ldr	r3, [r7, #4]
 801e012:	789b      	ldrb	r3, [r3, #2]
 801e014:	f003 0304 	and.w	r3, r3, #4
 801e018:	2b00      	cmp	r3, #0
 801e01a:	d030      	beq.n	801e07e <finsh_compile+0x10e>
                {
                    /* load address */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801e01c:	4b9f      	ldr	r3, [pc, #636]	; (801e29c <finsh_compile+0x32c>)
 801e01e:	681b      	ldr	r3, [r3, #0]
 801e020:	2224      	movs	r2, #36	; 0x24
 801e022:	701a      	strb	r2, [r3, #0]
 801e024:	4b9d      	ldr	r3, [pc, #628]	; (801e29c <finsh_compile+0x32c>)
 801e026:	681b      	ldr	r3, [r3, #0]
 801e028:	3301      	adds	r3, #1
 801e02a:	4a9c      	ldr	r2, [pc, #624]	; (801e29c <finsh_compile+0x32c>)
 801e02c:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)node->id.syscall->func);
 801e02e:	4b9b      	ldr	r3, [pc, #620]	; (801e29c <finsh_compile+0x32c>)
 801e030:	681b      	ldr	r3, [r3, #0]
 801e032:	687a      	ldr	r2, [r7, #4]
 801e034:	6892      	ldr	r2, [r2, #8]
 801e036:	6892      	ldr	r2, [r2, #8]
 801e038:	b2d2      	uxtb	r2, r2
 801e03a:	701a      	strb	r2, [r3, #0]
 801e03c:	4b97      	ldr	r3, [pc, #604]	; (801e29c <finsh_compile+0x32c>)
 801e03e:	681b      	ldr	r3, [r3, #0]
 801e040:	3301      	adds	r3, #1
 801e042:	687a      	ldr	r2, [r7, #4]
 801e044:	6892      	ldr	r2, [r2, #8]
 801e046:	6892      	ldr	r2, [r2, #8]
 801e048:	0a12      	lsrs	r2, r2, #8
 801e04a:	b2d2      	uxtb	r2, r2
 801e04c:	701a      	strb	r2, [r3, #0]
 801e04e:	4b93      	ldr	r3, [pc, #588]	; (801e29c <finsh_compile+0x32c>)
 801e050:	681b      	ldr	r3, [r3, #0]
 801e052:	3302      	adds	r3, #2
 801e054:	687a      	ldr	r2, [r7, #4]
 801e056:	6892      	ldr	r2, [r2, #8]
 801e058:	6892      	ldr	r2, [r2, #8]
 801e05a:	0c12      	lsrs	r2, r2, #16
 801e05c:	b2d2      	uxtb	r2, r2
 801e05e:	701a      	strb	r2, [r3, #0]
 801e060:	4b8e      	ldr	r3, [pc, #568]	; (801e29c <finsh_compile+0x32c>)
 801e062:	681b      	ldr	r3, [r3, #0]
 801e064:	3303      	adds	r3, #3
 801e066:	687a      	ldr	r2, [r7, #4]
 801e068:	6892      	ldr	r2, [r2, #8]
 801e06a:	6892      	ldr	r2, [r2, #8]
 801e06c:	0e12      	lsrs	r2, r2, #24
 801e06e:	b2d2      	uxtb	r2, r2
 801e070:	701a      	strb	r2, [r3, #0]
 801e072:	4b8a      	ldr	r3, [pc, #552]	; (801e29c <finsh_compile+0x32c>)
 801e074:	681b      	ldr	r3, [r3, #0]
 801e076:	3304      	adds	r3, #4
 801e078:	4a88      	ldr	r2, [pc, #544]	; (801e29c <finsh_compile+0x32c>)
 801e07a:	6013      	str	r3, [r2, #0]
 801e07c:	e1c7      	b.n	801e40e <finsh_compile+0x49e>
                }
                /* identifier::sysvar */
                else if (node->idtype & FINSH_IDTYPE_SYSVAR)
 801e07e:	687b      	ldr	r3, [r7, #4]
 801e080:	789b      	ldrb	r3, [r3, #2]
 801e082:	f003 0302 	and.w	r3, r3, #2
 801e086:	2b00      	cmp	r3, #0
 801e088:	f000 80e0 	beq.w	801e24c <finsh_compile+0x2dc>
                {
                    struct finsh_sysvar* sysvar;

                    sysvar = node->id.sysvar;
 801e08c:	687b      	ldr	r3, [r7, #4]
 801e08e:	689b      	ldr	r3, [r3, #8]
 801e090:	61fb      	str	r3, [r7, #28]
                    if (sysvar != NULL)
 801e092:	69fb      	ldr	r3, [r7, #28]
 801e094:	2b00      	cmp	r3, #0
 801e096:	f000 80d8 	beq.w	801e24a <finsh_compile+0x2da>
                    {
                        switch (sysvar->type)
 801e09a:	69fb      	ldr	r3, [r7, #28]
 801e09c:	7a1b      	ldrb	r3, [r3, #8]
 801e09e:	3b03      	subs	r3, #3
 801e0a0:	2b0b      	cmp	r3, #11
 801e0a2:	f200 81b4 	bhi.w	801e40e <finsh_compile+0x49e>
 801e0a6:	a201      	add	r2, pc, #4	; (adr r2, 801e0ac <finsh_compile+0x13c>)
 801e0a8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801e0ac:	0801e0dd 	.word	0x0801e0dd
 801e0b0:	0801e0dd 	.word	0x0801e0dd
 801e0b4:	0801e1d1 	.word	0x0801e1d1
 801e0b8:	0801e157 	.word	0x0801e157
 801e0bc:	0801e157 	.word	0x0801e157
 801e0c0:	0801e1d1 	.word	0x0801e1d1
 801e0c4:	0801e1d1 	.word	0x0801e1d1
 801e0c8:	0801e1d1 	.word	0x0801e1d1
 801e0cc:	0801e1d1 	.word	0x0801e1d1
 801e0d0:	0801e1d1 	.word	0x0801e1d1
 801e0d4:	0801e1d1 	.word	0x0801e1d1
 801e0d8:	0801e1d1 	.word	0x0801e1d1
                        {
                        case finsh_type_char:
                        case finsh_type_uchar:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801e0dc:	687b      	ldr	r3, [r7, #4]
 801e0de:	789b      	ldrb	r3, [r3, #2]
 801e0e0:	f003 0308 	and.w	r3, r3, #8
 801e0e4:	2b00      	cmp	r3, #0
 801e0e6:	d009      	beq.n	801e0fc <finsh_compile+0x18c>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
 801e0e8:	4b6c      	ldr	r3, [pc, #432]	; (801e29c <finsh_compile+0x32c>)
 801e0ea:	681b      	ldr	r3, [r3, #0]
 801e0ec:	2224      	movs	r2, #36	; 0x24
 801e0ee:	701a      	strb	r2, [r3, #0]
 801e0f0:	4b6a      	ldr	r3, [pc, #424]	; (801e29c <finsh_compile+0x32c>)
 801e0f2:	681b      	ldr	r3, [r3, #0]
 801e0f4:	3301      	adds	r3, #1
 801e0f6:	4a69      	ldr	r2, [pc, #420]	; (801e29c <finsh_compile+0x32c>)
 801e0f8:	6013      	str	r3, [r2, #0]
 801e0fa:	e008      	b.n	801e10e <finsh_compile+0x19e>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
 801e0fc:	4b67      	ldr	r3, [pc, #412]	; (801e29c <finsh_compile+0x32c>)
 801e0fe:	681b      	ldr	r3, [r3, #0]
 801e100:	2225      	movs	r2, #37	; 0x25
 801e102:	701a      	strb	r2, [r3, #0]
 801e104:	4b65      	ldr	r3, [pc, #404]	; (801e29c <finsh_compile+0x32c>)
 801e106:	681b      	ldr	r3, [r3, #0]
 801e108:	3301      	adds	r3, #1
 801e10a:	4a64      	ldr	r2, [pc, #400]	; (801e29c <finsh_compile+0x32c>)
 801e10c:	6013      	str	r3, [r2, #0]
                            }

                            finsh_code_dword((long)(sysvar->var));
 801e10e:	4b63      	ldr	r3, [pc, #396]	; (801e29c <finsh_compile+0x32c>)
 801e110:	681b      	ldr	r3, [r3, #0]
 801e112:	69fa      	ldr	r2, [r7, #28]
 801e114:	68d2      	ldr	r2, [r2, #12]
 801e116:	b2d2      	uxtb	r2, r2
 801e118:	701a      	strb	r2, [r3, #0]
 801e11a:	4b60      	ldr	r3, [pc, #384]	; (801e29c <finsh_compile+0x32c>)
 801e11c:	681b      	ldr	r3, [r3, #0]
 801e11e:	3301      	adds	r3, #1
 801e120:	69fa      	ldr	r2, [r7, #28]
 801e122:	68d2      	ldr	r2, [r2, #12]
 801e124:	0a12      	lsrs	r2, r2, #8
 801e126:	b2d2      	uxtb	r2, r2
 801e128:	701a      	strb	r2, [r3, #0]
 801e12a:	4b5c      	ldr	r3, [pc, #368]	; (801e29c <finsh_compile+0x32c>)
 801e12c:	681b      	ldr	r3, [r3, #0]
 801e12e:	3302      	adds	r3, #2
 801e130:	69fa      	ldr	r2, [r7, #28]
 801e132:	68d2      	ldr	r2, [r2, #12]
 801e134:	0c12      	lsrs	r2, r2, #16
 801e136:	b2d2      	uxtb	r2, r2
 801e138:	701a      	strb	r2, [r3, #0]
 801e13a:	4b58      	ldr	r3, [pc, #352]	; (801e29c <finsh_compile+0x32c>)
 801e13c:	681b      	ldr	r3, [r3, #0]
 801e13e:	3303      	adds	r3, #3
 801e140:	69fa      	ldr	r2, [r7, #28]
 801e142:	68d2      	ldr	r2, [r2, #12]
 801e144:	0e12      	lsrs	r2, r2, #24
 801e146:	b2d2      	uxtb	r2, r2
 801e148:	701a      	strb	r2, [r3, #0]
 801e14a:	4b54      	ldr	r3, [pc, #336]	; (801e29c <finsh_compile+0x32c>)
 801e14c:	681b      	ldr	r3, [r3, #0]
 801e14e:	3304      	adds	r3, #4
 801e150:	4a52      	ldr	r2, [pc, #328]	; (801e29c <finsh_compile+0x32c>)
 801e152:	6013      	str	r3, [r2, #0]
                            break;
 801e154:	e079      	b.n	801e24a <finsh_compile+0x2da>

                        case finsh_type_short:
                        case finsh_type_ushort:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801e156:	687b      	ldr	r3, [r7, #4]
 801e158:	789b      	ldrb	r3, [r3, #2]
 801e15a:	f003 0308 	and.w	r3, r3, #8
 801e15e:	2b00      	cmp	r3, #0
 801e160:	d009      	beq.n	801e176 <finsh_compile+0x206>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
 801e162:	4b4e      	ldr	r3, [pc, #312]	; (801e29c <finsh_compile+0x32c>)
 801e164:	681b      	ldr	r3, [r3, #0]
 801e166:	2224      	movs	r2, #36	; 0x24
 801e168:	701a      	strb	r2, [r3, #0]
 801e16a:	4b4c      	ldr	r3, [pc, #304]	; (801e29c <finsh_compile+0x32c>)
 801e16c:	681b      	ldr	r3, [r3, #0]
 801e16e:	3301      	adds	r3, #1
 801e170:	4a4a      	ldr	r2, [pc, #296]	; (801e29c <finsh_compile+0x32c>)
 801e172:	6013      	str	r3, [r2, #0]
 801e174:	e008      	b.n	801e188 <finsh_compile+0x218>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
 801e176:	4b49      	ldr	r3, [pc, #292]	; (801e29c <finsh_compile+0x32c>)
 801e178:	681b      	ldr	r3, [r3, #0]
 801e17a:	2226      	movs	r2, #38	; 0x26
 801e17c:	701a      	strb	r2, [r3, #0]
 801e17e:	4b47      	ldr	r3, [pc, #284]	; (801e29c <finsh_compile+0x32c>)
 801e180:	681b      	ldr	r3, [r3, #0]
 801e182:	3301      	adds	r3, #1
 801e184:	4a45      	ldr	r2, [pc, #276]	; (801e29c <finsh_compile+0x32c>)
 801e186:	6013      	str	r3, [r2, #0]
                            }

                            finsh_code_dword((long)(sysvar->var));
 801e188:	4b44      	ldr	r3, [pc, #272]	; (801e29c <finsh_compile+0x32c>)
 801e18a:	681b      	ldr	r3, [r3, #0]
 801e18c:	69fa      	ldr	r2, [r7, #28]
 801e18e:	68d2      	ldr	r2, [r2, #12]
 801e190:	b2d2      	uxtb	r2, r2
 801e192:	701a      	strb	r2, [r3, #0]
 801e194:	4b41      	ldr	r3, [pc, #260]	; (801e29c <finsh_compile+0x32c>)
 801e196:	681b      	ldr	r3, [r3, #0]
 801e198:	3301      	adds	r3, #1
 801e19a:	69fa      	ldr	r2, [r7, #28]
 801e19c:	68d2      	ldr	r2, [r2, #12]
 801e19e:	0a12      	lsrs	r2, r2, #8
 801e1a0:	b2d2      	uxtb	r2, r2
 801e1a2:	701a      	strb	r2, [r3, #0]
 801e1a4:	4b3d      	ldr	r3, [pc, #244]	; (801e29c <finsh_compile+0x32c>)
 801e1a6:	681b      	ldr	r3, [r3, #0]
 801e1a8:	3302      	adds	r3, #2
 801e1aa:	69fa      	ldr	r2, [r7, #28]
 801e1ac:	68d2      	ldr	r2, [r2, #12]
 801e1ae:	0c12      	lsrs	r2, r2, #16
 801e1b0:	b2d2      	uxtb	r2, r2
 801e1b2:	701a      	strb	r2, [r3, #0]
 801e1b4:	4b39      	ldr	r3, [pc, #228]	; (801e29c <finsh_compile+0x32c>)
 801e1b6:	681b      	ldr	r3, [r3, #0]
 801e1b8:	3303      	adds	r3, #3
 801e1ba:	69fa      	ldr	r2, [r7, #28]
 801e1bc:	68d2      	ldr	r2, [r2, #12]
 801e1be:	0e12      	lsrs	r2, r2, #24
 801e1c0:	b2d2      	uxtb	r2, r2
 801e1c2:	701a      	strb	r2, [r3, #0]
 801e1c4:	4b35      	ldr	r3, [pc, #212]	; (801e29c <finsh_compile+0x32c>)
 801e1c6:	681b      	ldr	r3, [r3, #0]
 801e1c8:	3304      	adds	r3, #4
 801e1ca:	4a34      	ldr	r2, [pc, #208]	; (801e29c <finsh_compile+0x32c>)
 801e1cc:	6013      	str	r3, [r2, #0]
                            break;
 801e1ce:	e03c      	b.n	801e24a <finsh_compile+0x2da>
                        case finsh_type_ulong:
                        case finsh_type_charp:
                        case finsh_type_shortp:
                        case finsh_type_intp:
                        case finsh_type_longp:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801e1d0:	687b      	ldr	r3, [r7, #4]
 801e1d2:	789b      	ldrb	r3, [r3, #2]
 801e1d4:	f003 0308 	and.w	r3, r3, #8
 801e1d8:	2b00      	cmp	r3, #0
 801e1da:	d009      	beq.n	801e1f0 <finsh_compile+0x280>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
 801e1dc:	4b2f      	ldr	r3, [pc, #188]	; (801e29c <finsh_compile+0x32c>)
 801e1de:	681b      	ldr	r3, [r3, #0]
 801e1e0:	2224      	movs	r2, #36	; 0x24
 801e1e2:	701a      	strb	r2, [r3, #0]
 801e1e4:	4b2d      	ldr	r3, [pc, #180]	; (801e29c <finsh_compile+0x32c>)
 801e1e6:	681b      	ldr	r3, [r3, #0]
 801e1e8:	3301      	adds	r3, #1
 801e1ea:	4a2c      	ldr	r2, [pc, #176]	; (801e29c <finsh_compile+0x32c>)
 801e1ec:	6013      	str	r3, [r2, #0]
 801e1ee:	e008      	b.n	801e202 <finsh_compile+0x292>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
 801e1f0:	4b2a      	ldr	r3, [pc, #168]	; (801e29c <finsh_compile+0x32c>)
 801e1f2:	681b      	ldr	r3, [r3, #0]
 801e1f4:	2227      	movs	r2, #39	; 0x27
 801e1f6:	701a      	strb	r2, [r3, #0]
 801e1f8:	4b28      	ldr	r3, [pc, #160]	; (801e29c <finsh_compile+0x32c>)
 801e1fa:	681b      	ldr	r3, [r3, #0]
 801e1fc:	3301      	adds	r3, #1
 801e1fe:	4a27      	ldr	r2, [pc, #156]	; (801e29c <finsh_compile+0x32c>)
 801e200:	6013      	str	r3, [r2, #0]
                            }

                            finsh_code_dword((long)(sysvar->var));
 801e202:	4b26      	ldr	r3, [pc, #152]	; (801e29c <finsh_compile+0x32c>)
 801e204:	681b      	ldr	r3, [r3, #0]
 801e206:	69fa      	ldr	r2, [r7, #28]
 801e208:	68d2      	ldr	r2, [r2, #12]
 801e20a:	b2d2      	uxtb	r2, r2
 801e20c:	701a      	strb	r2, [r3, #0]
 801e20e:	4b23      	ldr	r3, [pc, #140]	; (801e29c <finsh_compile+0x32c>)
 801e210:	681b      	ldr	r3, [r3, #0]
 801e212:	3301      	adds	r3, #1
 801e214:	69fa      	ldr	r2, [r7, #28]
 801e216:	68d2      	ldr	r2, [r2, #12]
 801e218:	0a12      	lsrs	r2, r2, #8
 801e21a:	b2d2      	uxtb	r2, r2
 801e21c:	701a      	strb	r2, [r3, #0]
 801e21e:	4b1f      	ldr	r3, [pc, #124]	; (801e29c <finsh_compile+0x32c>)
 801e220:	681b      	ldr	r3, [r3, #0]
 801e222:	3302      	adds	r3, #2
 801e224:	69fa      	ldr	r2, [r7, #28]
 801e226:	68d2      	ldr	r2, [r2, #12]
 801e228:	0c12      	lsrs	r2, r2, #16
 801e22a:	b2d2      	uxtb	r2, r2
 801e22c:	701a      	strb	r2, [r3, #0]
 801e22e:	4b1b      	ldr	r3, [pc, #108]	; (801e29c <finsh_compile+0x32c>)
 801e230:	681b      	ldr	r3, [r3, #0]
 801e232:	3303      	adds	r3, #3
 801e234:	69fa      	ldr	r2, [r7, #28]
 801e236:	68d2      	ldr	r2, [r2, #12]
 801e238:	0e12      	lsrs	r2, r2, #24
 801e23a:	b2d2      	uxtb	r2, r2
 801e23c:	701a      	strb	r2, [r3, #0]
 801e23e:	4b17      	ldr	r3, [pc, #92]	; (801e29c <finsh_compile+0x32c>)
 801e240:	681b      	ldr	r3, [r3, #0]
 801e242:	3304      	adds	r3, #4
 801e244:	4a15      	ldr	r2, [pc, #84]	; (801e29c <finsh_compile+0x32c>)
 801e246:	6013      	str	r3, [r2, #0]
                            break;
 801e248:	bf00      	nop
 801e24a:	e0e0      	b.n	801e40e <finsh_compile+0x49e>
                /* identifier::var */
                else
                {
                    struct finsh_var* var;

                    var = node->id.var;
 801e24c:	687b      	ldr	r3, [r7, #4]
 801e24e:	689b      	ldr	r3, [r3, #8]
 801e250:	61bb      	str	r3, [r7, #24]
                    if (var != NULL)
 801e252:	69bb      	ldr	r3, [r7, #24]
 801e254:	2b00      	cmp	r3, #0
 801e256:	f000 80da 	beq.w	801e40e <finsh_compile+0x49e>
                    {
                        switch (var->type)
 801e25a:	69bb      	ldr	r3, [r7, #24]
 801e25c:	7c5b      	ldrb	r3, [r3, #17]
 801e25e:	3b03      	subs	r3, #3
 801e260:	2b0b      	cmp	r3, #11
 801e262:	f201 8263 	bhi.w	801f72c <finsh_compile+0x17bc>
 801e266:	a201      	add	r2, pc, #4	; (adr r2, 801e26c <finsh_compile+0x2fc>)
 801e268:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801e26c:	0801e2a1 	.word	0x0801e2a1
 801e270:	0801e2a1 	.word	0x0801e2a1
 801e274:	0801e395 	.word	0x0801e395
 801e278:	0801e31b 	.word	0x0801e31b
 801e27c:	0801e31b 	.word	0x0801e31b
 801e280:	0801e395 	.word	0x0801e395
 801e284:	0801e395 	.word	0x0801e395
 801e288:	0801e395 	.word	0x0801e395
 801e28c:	0801e395 	.word	0x0801e395
 801e290:	0801e395 	.word	0x0801e395
 801e294:	0801e395 	.word	0x0801e395
 801e298:	0801e395 	.word	0x0801e395
 801e29c:	20012bb8 	.word	0x20012bb8
                        {
                        case finsh_type_char:
                        case finsh_type_uchar:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801e2a0:	687b      	ldr	r3, [r7, #4]
 801e2a2:	789b      	ldrb	r3, [r3, #2]
 801e2a4:	f003 0308 	and.w	r3, r3, #8
 801e2a8:	2b00      	cmp	r3, #0
 801e2aa:	d009      	beq.n	801e2c0 <finsh_compile+0x350>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
 801e2ac:	4b98      	ldr	r3, [pc, #608]	; (801e510 <finsh_compile+0x5a0>)
 801e2ae:	681b      	ldr	r3, [r3, #0]
 801e2b0:	2224      	movs	r2, #36	; 0x24
 801e2b2:	701a      	strb	r2, [r3, #0]
 801e2b4:	4b96      	ldr	r3, [pc, #600]	; (801e510 <finsh_compile+0x5a0>)
 801e2b6:	681b      	ldr	r3, [r3, #0]
 801e2b8:	3301      	adds	r3, #1
 801e2ba:	4a95      	ldr	r2, [pc, #596]	; (801e510 <finsh_compile+0x5a0>)
 801e2bc:	6013      	str	r3, [r2, #0]
 801e2be:	e008      	b.n	801e2d2 <finsh_compile+0x362>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
 801e2c0:	4b93      	ldr	r3, [pc, #588]	; (801e510 <finsh_compile+0x5a0>)
 801e2c2:	681b      	ldr	r3, [r3, #0]
 801e2c4:	2225      	movs	r2, #37	; 0x25
 801e2c6:	701a      	strb	r2, [r3, #0]
 801e2c8:	4b91      	ldr	r3, [pc, #580]	; (801e510 <finsh_compile+0x5a0>)
 801e2ca:	681b      	ldr	r3, [r3, #0]
 801e2cc:	3301      	adds	r3, #1
 801e2ce:	4a90      	ldr	r2, [pc, #576]	; (801e510 <finsh_compile+0x5a0>)
 801e2d0:	6013      	str	r3, [r2, #0]
                            }

                            finsh_code_dword((long)&(var->value.char_value));
 801e2d2:	4b8f      	ldr	r3, [pc, #572]	; (801e510 <finsh_compile+0x5a0>)
 801e2d4:	681b      	ldr	r3, [r3, #0]
 801e2d6:	69ba      	ldr	r2, [r7, #24]
 801e2d8:	3214      	adds	r2, #20
 801e2da:	b2d2      	uxtb	r2, r2
 801e2dc:	701a      	strb	r2, [r3, #0]
 801e2de:	4b8c      	ldr	r3, [pc, #560]	; (801e510 <finsh_compile+0x5a0>)
 801e2e0:	681b      	ldr	r3, [r3, #0]
 801e2e2:	3301      	adds	r3, #1
 801e2e4:	69ba      	ldr	r2, [r7, #24]
 801e2e6:	3214      	adds	r2, #20
 801e2e8:	0a12      	lsrs	r2, r2, #8
 801e2ea:	b2d2      	uxtb	r2, r2
 801e2ec:	701a      	strb	r2, [r3, #0]
 801e2ee:	4b88      	ldr	r3, [pc, #544]	; (801e510 <finsh_compile+0x5a0>)
 801e2f0:	681b      	ldr	r3, [r3, #0]
 801e2f2:	3302      	adds	r3, #2
 801e2f4:	69ba      	ldr	r2, [r7, #24]
 801e2f6:	3214      	adds	r2, #20
 801e2f8:	0c12      	lsrs	r2, r2, #16
 801e2fa:	b2d2      	uxtb	r2, r2
 801e2fc:	701a      	strb	r2, [r3, #0]
 801e2fe:	4b84      	ldr	r3, [pc, #528]	; (801e510 <finsh_compile+0x5a0>)
 801e300:	681b      	ldr	r3, [r3, #0]
 801e302:	3303      	adds	r3, #3
 801e304:	69ba      	ldr	r2, [r7, #24]
 801e306:	3214      	adds	r2, #20
 801e308:	0e12      	lsrs	r2, r2, #24
 801e30a:	b2d2      	uxtb	r2, r2
 801e30c:	701a      	strb	r2, [r3, #0]
 801e30e:	4b80      	ldr	r3, [pc, #512]	; (801e510 <finsh_compile+0x5a0>)
 801e310:	681b      	ldr	r3, [r3, #0]
 801e312:	3304      	adds	r3, #4
 801e314:	4a7e      	ldr	r2, [pc, #504]	; (801e510 <finsh_compile+0x5a0>)
 801e316:	6013      	str	r3, [r2, #0]
                            break;
 801e318:	e079      	b.n	801e40e <finsh_compile+0x49e>

                        case finsh_type_short:
                        case finsh_type_ushort:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801e31a:	687b      	ldr	r3, [r7, #4]
 801e31c:	789b      	ldrb	r3, [r3, #2]
 801e31e:	f003 0308 	and.w	r3, r3, #8
 801e322:	2b00      	cmp	r3, #0
 801e324:	d009      	beq.n	801e33a <finsh_compile+0x3ca>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
 801e326:	4b7a      	ldr	r3, [pc, #488]	; (801e510 <finsh_compile+0x5a0>)
 801e328:	681b      	ldr	r3, [r3, #0]
 801e32a:	2224      	movs	r2, #36	; 0x24
 801e32c:	701a      	strb	r2, [r3, #0]
 801e32e:	4b78      	ldr	r3, [pc, #480]	; (801e510 <finsh_compile+0x5a0>)
 801e330:	681b      	ldr	r3, [r3, #0]
 801e332:	3301      	adds	r3, #1
 801e334:	4a76      	ldr	r2, [pc, #472]	; (801e510 <finsh_compile+0x5a0>)
 801e336:	6013      	str	r3, [r2, #0]
 801e338:	e008      	b.n	801e34c <finsh_compile+0x3dc>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
 801e33a:	4b75      	ldr	r3, [pc, #468]	; (801e510 <finsh_compile+0x5a0>)
 801e33c:	681b      	ldr	r3, [r3, #0]
 801e33e:	2226      	movs	r2, #38	; 0x26
 801e340:	701a      	strb	r2, [r3, #0]
 801e342:	4b73      	ldr	r3, [pc, #460]	; (801e510 <finsh_compile+0x5a0>)
 801e344:	681b      	ldr	r3, [r3, #0]
 801e346:	3301      	adds	r3, #1
 801e348:	4a71      	ldr	r2, [pc, #452]	; (801e510 <finsh_compile+0x5a0>)
 801e34a:	6013      	str	r3, [r2, #0]
                            }

                            finsh_code_dword((long)&(var->value.short_value));
 801e34c:	4b70      	ldr	r3, [pc, #448]	; (801e510 <finsh_compile+0x5a0>)
 801e34e:	681b      	ldr	r3, [r3, #0]
 801e350:	69ba      	ldr	r2, [r7, #24]
 801e352:	3214      	adds	r2, #20
 801e354:	b2d2      	uxtb	r2, r2
 801e356:	701a      	strb	r2, [r3, #0]
 801e358:	4b6d      	ldr	r3, [pc, #436]	; (801e510 <finsh_compile+0x5a0>)
 801e35a:	681b      	ldr	r3, [r3, #0]
 801e35c:	3301      	adds	r3, #1
 801e35e:	69ba      	ldr	r2, [r7, #24]
 801e360:	3214      	adds	r2, #20
 801e362:	0a12      	lsrs	r2, r2, #8
 801e364:	b2d2      	uxtb	r2, r2
 801e366:	701a      	strb	r2, [r3, #0]
 801e368:	4b69      	ldr	r3, [pc, #420]	; (801e510 <finsh_compile+0x5a0>)
 801e36a:	681b      	ldr	r3, [r3, #0]
 801e36c:	3302      	adds	r3, #2
 801e36e:	69ba      	ldr	r2, [r7, #24]
 801e370:	3214      	adds	r2, #20
 801e372:	0c12      	lsrs	r2, r2, #16
 801e374:	b2d2      	uxtb	r2, r2
 801e376:	701a      	strb	r2, [r3, #0]
 801e378:	4b65      	ldr	r3, [pc, #404]	; (801e510 <finsh_compile+0x5a0>)
 801e37a:	681b      	ldr	r3, [r3, #0]
 801e37c:	3303      	adds	r3, #3
 801e37e:	69ba      	ldr	r2, [r7, #24]
 801e380:	3214      	adds	r2, #20
 801e382:	0e12      	lsrs	r2, r2, #24
 801e384:	b2d2      	uxtb	r2, r2
 801e386:	701a      	strb	r2, [r3, #0]
 801e388:	4b61      	ldr	r3, [pc, #388]	; (801e510 <finsh_compile+0x5a0>)
 801e38a:	681b      	ldr	r3, [r3, #0]
 801e38c:	3304      	adds	r3, #4
 801e38e:	4a60      	ldr	r2, [pc, #384]	; (801e510 <finsh_compile+0x5a0>)
 801e390:	6013      	str	r3, [r2, #0]
                            break;
 801e392:	e03c      	b.n	801e40e <finsh_compile+0x49e>
                        case finsh_type_ulong:
                        case finsh_type_charp:
                        case finsh_type_shortp:
                        case finsh_type_intp:
                        case finsh_type_longp:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801e394:	687b      	ldr	r3, [r7, #4]
 801e396:	789b      	ldrb	r3, [r3, #2]
 801e398:	f003 0308 	and.w	r3, r3, #8
 801e39c:	2b00      	cmp	r3, #0
 801e39e:	d009      	beq.n	801e3b4 <finsh_compile+0x444>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
 801e3a0:	4b5b      	ldr	r3, [pc, #364]	; (801e510 <finsh_compile+0x5a0>)
 801e3a2:	681b      	ldr	r3, [r3, #0]
 801e3a4:	2224      	movs	r2, #36	; 0x24
 801e3a6:	701a      	strb	r2, [r3, #0]
 801e3a8:	4b59      	ldr	r3, [pc, #356]	; (801e510 <finsh_compile+0x5a0>)
 801e3aa:	681b      	ldr	r3, [r3, #0]
 801e3ac:	3301      	adds	r3, #1
 801e3ae:	4a58      	ldr	r2, [pc, #352]	; (801e510 <finsh_compile+0x5a0>)
 801e3b0:	6013      	str	r3, [r2, #0]
 801e3b2:	e008      	b.n	801e3c6 <finsh_compile+0x456>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
 801e3b4:	4b56      	ldr	r3, [pc, #344]	; (801e510 <finsh_compile+0x5a0>)
 801e3b6:	681b      	ldr	r3, [r3, #0]
 801e3b8:	2227      	movs	r2, #39	; 0x27
 801e3ba:	701a      	strb	r2, [r3, #0]
 801e3bc:	4b54      	ldr	r3, [pc, #336]	; (801e510 <finsh_compile+0x5a0>)
 801e3be:	681b      	ldr	r3, [r3, #0]
 801e3c0:	3301      	adds	r3, #1
 801e3c2:	4a53      	ldr	r2, [pc, #332]	; (801e510 <finsh_compile+0x5a0>)
 801e3c4:	6013      	str	r3, [r2, #0]
                            }

                            finsh_code_dword((long)&(var->value.long_value));
 801e3c6:	4b52      	ldr	r3, [pc, #328]	; (801e510 <finsh_compile+0x5a0>)
 801e3c8:	681b      	ldr	r3, [r3, #0]
 801e3ca:	69ba      	ldr	r2, [r7, #24]
 801e3cc:	3214      	adds	r2, #20
 801e3ce:	b2d2      	uxtb	r2, r2
 801e3d0:	701a      	strb	r2, [r3, #0]
 801e3d2:	4b4f      	ldr	r3, [pc, #316]	; (801e510 <finsh_compile+0x5a0>)
 801e3d4:	681b      	ldr	r3, [r3, #0]
 801e3d6:	3301      	adds	r3, #1
 801e3d8:	69ba      	ldr	r2, [r7, #24]
 801e3da:	3214      	adds	r2, #20
 801e3dc:	0a12      	lsrs	r2, r2, #8
 801e3de:	b2d2      	uxtb	r2, r2
 801e3e0:	701a      	strb	r2, [r3, #0]
 801e3e2:	4b4b      	ldr	r3, [pc, #300]	; (801e510 <finsh_compile+0x5a0>)
 801e3e4:	681b      	ldr	r3, [r3, #0]
 801e3e6:	3302      	adds	r3, #2
 801e3e8:	69ba      	ldr	r2, [r7, #24]
 801e3ea:	3214      	adds	r2, #20
 801e3ec:	0c12      	lsrs	r2, r2, #16
 801e3ee:	b2d2      	uxtb	r2, r2
 801e3f0:	701a      	strb	r2, [r3, #0]
 801e3f2:	4b47      	ldr	r3, [pc, #284]	; (801e510 <finsh_compile+0x5a0>)
 801e3f4:	681b      	ldr	r3, [r3, #0]
 801e3f6:	3303      	adds	r3, #3
 801e3f8:	69ba      	ldr	r2, [r7, #24]
 801e3fa:	3214      	adds	r2, #20
 801e3fc:	0e12      	lsrs	r2, r2, #24
 801e3fe:	b2d2      	uxtb	r2, r2
 801e400:	701a      	strb	r2, [r3, #0]
 801e402:	4b43      	ldr	r3, [pc, #268]	; (801e510 <finsh_compile+0x5a0>)
 801e404:	681b      	ldr	r3, [r3, #0]
 801e406:	3304      	adds	r3, #4
 801e408:	4a41      	ldr	r2, [pc, #260]	; (801e510 <finsh_compile+0x5a0>)
 801e40a:	6013      	str	r3, [r2, #0]
                            break;
 801e40c:	bf00      	nop
                        }
                    }
                }
            }
            break;
 801e40e:	f001 b98d 	b.w	801f72c <finsh_compile+0x17bc>

        /* load const */
        case FINSH_NODE_VALUE_CHAR:
            finsh_code_byte(FINSH_OP_LD_BYTE);
 801e412:	4b3f      	ldr	r3, [pc, #252]	; (801e510 <finsh_compile+0x5a0>)
 801e414:	681b      	ldr	r3, [r3, #0]
 801e416:	2222      	movs	r2, #34	; 0x22
 801e418:	701a      	strb	r2, [r3, #0]
 801e41a:	4b3d      	ldr	r3, [pc, #244]	; (801e510 <finsh_compile+0x5a0>)
 801e41c:	681b      	ldr	r3, [r3, #0]
 801e41e:	3301      	adds	r3, #1
 801e420:	4a3b      	ldr	r2, [pc, #236]	; (801e510 <finsh_compile+0x5a0>)
 801e422:	6013      	str	r3, [r2, #0]
            finsh_code_byte(node->value.char_value);
 801e424:	4b3a      	ldr	r3, [pc, #232]	; (801e510 <finsh_compile+0x5a0>)
 801e426:	681b      	ldr	r3, [r3, #0]
 801e428:	687a      	ldr	r2, [r7, #4]
 801e42a:	7912      	ldrb	r2, [r2, #4]
 801e42c:	701a      	strb	r2, [r3, #0]
 801e42e:	4b38      	ldr	r3, [pc, #224]	; (801e510 <finsh_compile+0x5a0>)
 801e430:	681b      	ldr	r3, [r3, #0]
 801e432:	3301      	adds	r3, #1
 801e434:	4a36      	ldr	r2, [pc, #216]	; (801e510 <finsh_compile+0x5a0>)
 801e436:	6013      	str	r3, [r2, #0]
            break;
 801e438:	f001 b979 	b.w	801f72e <finsh_compile+0x17be>

        case FINSH_NODE_VALUE_INT:
        case FINSH_NODE_VALUE_LONG:
            finsh_code_byte(FINSH_OP_LD_DWORD);
 801e43c:	4b34      	ldr	r3, [pc, #208]	; (801e510 <finsh_compile+0x5a0>)
 801e43e:	681b      	ldr	r3, [r3, #0]
 801e440:	2224      	movs	r2, #36	; 0x24
 801e442:	701a      	strb	r2, [r3, #0]
 801e444:	4b32      	ldr	r3, [pc, #200]	; (801e510 <finsh_compile+0x5a0>)
 801e446:	681b      	ldr	r3, [r3, #0]
 801e448:	3301      	adds	r3, #1
 801e44a:	4a31      	ldr	r2, [pc, #196]	; (801e510 <finsh_compile+0x5a0>)
 801e44c:	6013      	str	r3, [r2, #0]
            finsh_code_dword(node->value.long_value);
 801e44e:	4b30      	ldr	r3, [pc, #192]	; (801e510 <finsh_compile+0x5a0>)
 801e450:	681b      	ldr	r3, [r3, #0]
 801e452:	687a      	ldr	r2, [r7, #4]
 801e454:	6852      	ldr	r2, [r2, #4]
 801e456:	b2d2      	uxtb	r2, r2
 801e458:	701a      	strb	r2, [r3, #0]
 801e45a:	4b2d      	ldr	r3, [pc, #180]	; (801e510 <finsh_compile+0x5a0>)
 801e45c:	681b      	ldr	r3, [r3, #0]
 801e45e:	3301      	adds	r3, #1
 801e460:	687a      	ldr	r2, [r7, #4]
 801e462:	6852      	ldr	r2, [r2, #4]
 801e464:	0a12      	lsrs	r2, r2, #8
 801e466:	b2d2      	uxtb	r2, r2
 801e468:	701a      	strb	r2, [r3, #0]
 801e46a:	4b29      	ldr	r3, [pc, #164]	; (801e510 <finsh_compile+0x5a0>)
 801e46c:	681b      	ldr	r3, [r3, #0]
 801e46e:	3302      	adds	r3, #2
 801e470:	687a      	ldr	r2, [r7, #4]
 801e472:	6852      	ldr	r2, [r2, #4]
 801e474:	0c12      	lsrs	r2, r2, #16
 801e476:	b2d2      	uxtb	r2, r2
 801e478:	701a      	strb	r2, [r3, #0]
 801e47a:	4b25      	ldr	r3, [pc, #148]	; (801e510 <finsh_compile+0x5a0>)
 801e47c:	681b      	ldr	r3, [r3, #0]
 801e47e:	3303      	adds	r3, #3
 801e480:	687a      	ldr	r2, [r7, #4]
 801e482:	6852      	ldr	r2, [r2, #4]
 801e484:	0e12      	lsrs	r2, r2, #24
 801e486:	b2d2      	uxtb	r2, r2
 801e488:	701a      	strb	r2, [r3, #0]
 801e48a:	4b21      	ldr	r3, [pc, #132]	; (801e510 <finsh_compile+0x5a0>)
 801e48c:	681b      	ldr	r3, [r3, #0]
 801e48e:	3304      	adds	r3, #4
 801e490:	4a1f      	ldr	r2, [pc, #124]	; (801e510 <finsh_compile+0x5a0>)
 801e492:	6013      	str	r3, [r2, #0]
            break;
 801e494:	f001 b94b 	b.w	801f72e <finsh_compile+0x17be>

        case FINSH_NODE_VALUE_NULL:
        case FINSH_NODE_VALUE_STRING:
            finsh_code_byte(FINSH_OP_LD_DWORD);
 801e498:	4b1d      	ldr	r3, [pc, #116]	; (801e510 <finsh_compile+0x5a0>)
 801e49a:	681b      	ldr	r3, [r3, #0]
 801e49c:	2224      	movs	r2, #36	; 0x24
 801e49e:	701a      	strb	r2, [r3, #0]
 801e4a0:	4b1b      	ldr	r3, [pc, #108]	; (801e510 <finsh_compile+0x5a0>)
 801e4a2:	681b      	ldr	r3, [r3, #0]
 801e4a4:	3301      	adds	r3, #1
 801e4a6:	4a1a      	ldr	r2, [pc, #104]	; (801e510 <finsh_compile+0x5a0>)
 801e4a8:	6013      	str	r3, [r2, #0]
            finsh_code_dword((u_long)node->value.ptr);
 801e4aa:	4b19      	ldr	r3, [pc, #100]	; (801e510 <finsh_compile+0x5a0>)
 801e4ac:	681b      	ldr	r3, [r3, #0]
 801e4ae:	687a      	ldr	r2, [r7, #4]
 801e4b0:	6852      	ldr	r2, [r2, #4]
 801e4b2:	b2d2      	uxtb	r2, r2
 801e4b4:	701a      	strb	r2, [r3, #0]
 801e4b6:	4b16      	ldr	r3, [pc, #88]	; (801e510 <finsh_compile+0x5a0>)
 801e4b8:	681b      	ldr	r3, [r3, #0]
 801e4ba:	3301      	adds	r3, #1
 801e4bc:	687a      	ldr	r2, [r7, #4]
 801e4be:	6852      	ldr	r2, [r2, #4]
 801e4c0:	0a12      	lsrs	r2, r2, #8
 801e4c2:	b2d2      	uxtb	r2, r2
 801e4c4:	701a      	strb	r2, [r3, #0]
 801e4c6:	4b12      	ldr	r3, [pc, #72]	; (801e510 <finsh_compile+0x5a0>)
 801e4c8:	681b      	ldr	r3, [r3, #0]
 801e4ca:	3302      	adds	r3, #2
 801e4cc:	687a      	ldr	r2, [r7, #4]
 801e4ce:	6852      	ldr	r2, [r2, #4]
 801e4d0:	0c12      	lsrs	r2, r2, #16
 801e4d2:	b2d2      	uxtb	r2, r2
 801e4d4:	701a      	strb	r2, [r3, #0]
 801e4d6:	4b0e      	ldr	r3, [pc, #56]	; (801e510 <finsh_compile+0x5a0>)
 801e4d8:	681b      	ldr	r3, [r3, #0]
 801e4da:	3303      	adds	r3, #3
 801e4dc:	687a      	ldr	r2, [r7, #4]
 801e4de:	6852      	ldr	r2, [r2, #4]
 801e4e0:	0e12      	lsrs	r2, r2, #24
 801e4e2:	b2d2      	uxtb	r2, r2
 801e4e4:	701a      	strb	r2, [r3, #0]
 801e4e6:	4b0a      	ldr	r3, [pc, #40]	; (801e510 <finsh_compile+0x5a0>)
 801e4e8:	681b      	ldr	r3, [r3, #0]
 801e4ea:	3304      	adds	r3, #4
 801e4ec:	4a08      	ldr	r2, [pc, #32]	; (801e510 <finsh_compile+0x5a0>)
 801e4ee:	6013      	str	r3, [r2, #0]
            break;
 801e4f0:	f001 b91d 	b.w	801f72e <finsh_compile+0x17be>

        /* arithmetic operation */
        case FINSH_NODE_SYS_ADD:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_ADD_BYTE);
 801e4f4:	687b      	ldr	r3, [r7, #4]
 801e4f6:	785b      	ldrb	r3, [r3, #1]
 801e4f8:	2b01      	cmp	r3, #1
 801e4fa:	d10b      	bne.n	801e514 <finsh_compile+0x5a4>
 801e4fc:	4b04      	ldr	r3, [pc, #16]	; (801e510 <finsh_compile+0x5a0>)
 801e4fe:	681b      	ldr	r3, [r3, #0]
 801e500:	2201      	movs	r2, #1
 801e502:	701a      	strb	r2, [r3, #0]
 801e504:	4b02      	ldr	r3, [pc, #8]	; (801e510 <finsh_compile+0x5a0>)
 801e506:	681b      	ldr	r3, [r3, #0]
 801e508:	3301      	adds	r3, #1
 801e50a:	4a01      	ldr	r2, [pc, #4]	; (801e510 <finsh_compile+0x5a0>)
 801e50c:	6013      	str	r3, [r2, #0]
 801e50e:	e01e      	b.n	801e54e <finsh_compile+0x5de>
 801e510:	20012bb8 	.word	0x20012bb8
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_ADD_WORD);
 801e514:	687b      	ldr	r3, [r7, #4]
 801e516:	785b      	ldrb	r3, [r3, #1]
 801e518:	2b02      	cmp	r3, #2
 801e51a:	d109      	bne.n	801e530 <finsh_compile+0x5c0>
 801e51c:	4b94      	ldr	r3, [pc, #592]	; (801e770 <finsh_compile+0x800>)
 801e51e:	681b      	ldr	r3, [r3, #0]
 801e520:	2202      	movs	r2, #2
 801e522:	701a      	strb	r2, [r3, #0]
 801e524:	4b92      	ldr	r3, [pc, #584]	; (801e770 <finsh_compile+0x800>)
 801e526:	681b      	ldr	r3, [r3, #0]
 801e528:	3301      	adds	r3, #1
 801e52a:	4a91      	ldr	r2, [pc, #580]	; (801e770 <finsh_compile+0x800>)
 801e52c:	6013      	str	r3, [r2, #0]
 801e52e:	e00e      	b.n	801e54e <finsh_compile+0x5de>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_ADD_DWORD);
 801e530:	687b      	ldr	r3, [r7, #4]
 801e532:	785b      	ldrb	r3, [r3, #1]
 801e534:	2b03      	cmp	r3, #3
 801e536:	d10a      	bne.n	801e54e <finsh_compile+0x5de>
 801e538:	4b8d      	ldr	r3, [pc, #564]	; (801e770 <finsh_compile+0x800>)
 801e53a:	681b      	ldr	r3, [r3, #0]
 801e53c:	2203      	movs	r2, #3
 801e53e:	701a      	strb	r2, [r3, #0]
 801e540:	4b8b      	ldr	r3, [pc, #556]	; (801e770 <finsh_compile+0x800>)
 801e542:	681b      	ldr	r3, [r3, #0]
 801e544:	3301      	adds	r3, #1
 801e546:	4a8a      	ldr	r2, [pc, #552]	; (801e770 <finsh_compile+0x800>)
 801e548:	6013      	str	r3, [r2, #0]
            break;
 801e54a:	f001 b8f0 	b.w	801f72e <finsh_compile+0x17be>
 801e54e:	f001 b8ee 	b.w	801f72e <finsh_compile+0x17be>

        case FINSH_NODE_SYS_SUB:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_SUB_BYTE);
 801e552:	687b      	ldr	r3, [r7, #4]
 801e554:	785b      	ldrb	r3, [r3, #1]
 801e556:	2b01      	cmp	r3, #1
 801e558:	d109      	bne.n	801e56e <finsh_compile+0x5fe>
 801e55a:	4b85      	ldr	r3, [pc, #532]	; (801e770 <finsh_compile+0x800>)
 801e55c:	681b      	ldr	r3, [r3, #0]
 801e55e:	2204      	movs	r2, #4
 801e560:	701a      	strb	r2, [r3, #0]
 801e562:	4b83      	ldr	r3, [pc, #524]	; (801e770 <finsh_compile+0x800>)
 801e564:	681b      	ldr	r3, [r3, #0]
 801e566:	3301      	adds	r3, #1
 801e568:	4a81      	ldr	r2, [pc, #516]	; (801e770 <finsh_compile+0x800>)
 801e56a:	6013      	str	r3, [r2, #0]
 801e56c:	e01c      	b.n	801e5a8 <finsh_compile+0x638>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_SUB_WORD);
 801e56e:	687b      	ldr	r3, [r7, #4]
 801e570:	785b      	ldrb	r3, [r3, #1]
 801e572:	2b02      	cmp	r3, #2
 801e574:	d109      	bne.n	801e58a <finsh_compile+0x61a>
 801e576:	4b7e      	ldr	r3, [pc, #504]	; (801e770 <finsh_compile+0x800>)
 801e578:	681b      	ldr	r3, [r3, #0]
 801e57a:	2205      	movs	r2, #5
 801e57c:	701a      	strb	r2, [r3, #0]
 801e57e:	4b7c      	ldr	r3, [pc, #496]	; (801e770 <finsh_compile+0x800>)
 801e580:	681b      	ldr	r3, [r3, #0]
 801e582:	3301      	adds	r3, #1
 801e584:	4a7a      	ldr	r2, [pc, #488]	; (801e770 <finsh_compile+0x800>)
 801e586:	6013      	str	r3, [r2, #0]
 801e588:	e00e      	b.n	801e5a8 <finsh_compile+0x638>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_SUB_DWORD);
 801e58a:	687b      	ldr	r3, [r7, #4]
 801e58c:	785b      	ldrb	r3, [r3, #1]
 801e58e:	2b03      	cmp	r3, #3
 801e590:	d10a      	bne.n	801e5a8 <finsh_compile+0x638>
 801e592:	4b77      	ldr	r3, [pc, #476]	; (801e770 <finsh_compile+0x800>)
 801e594:	681b      	ldr	r3, [r3, #0]
 801e596:	2206      	movs	r2, #6
 801e598:	701a      	strb	r2, [r3, #0]
 801e59a:	4b75      	ldr	r3, [pc, #468]	; (801e770 <finsh_compile+0x800>)
 801e59c:	681b      	ldr	r3, [r3, #0]
 801e59e:	3301      	adds	r3, #1
 801e5a0:	4a73      	ldr	r2, [pc, #460]	; (801e770 <finsh_compile+0x800>)
 801e5a2:	6013      	str	r3, [r2, #0]
            break;
 801e5a4:	f001 b8c3 	b.w	801f72e <finsh_compile+0x17be>
 801e5a8:	f001 b8c1 	b.w	801f72e <finsh_compile+0x17be>

        case FINSH_NODE_SYS_MUL:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_MUL_BYTE);
 801e5ac:	687b      	ldr	r3, [r7, #4]
 801e5ae:	785b      	ldrb	r3, [r3, #1]
 801e5b0:	2b01      	cmp	r3, #1
 801e5b2:	d109      	bne.n	801e5c8 <finsh_compile+0x658>
 801e5b4:	4b6e      	ldr	r3, [pc, #440]	; (801e770 <finsh_compile+0x800>)
 801e5b6:	681b      	ldr	r3, [r3, #0]
 801e5b8:	220d      	movs	r2, #13
 801e5ba:	701a      	strb	r2, [r3, #0]
 801e5bc:	4b6c      	ldr	r3, [pc, #432]	; (801e770 <finsh_compile+0x800>)
 801e5be:	681b      	ldr	r3, [r3, #0]
 801e5c0:	3301      	adds	r3, #1
 801e5c2:	4a6b      	ldr	r2, [pc, #428]	; (801e770 <finsh_compile+0x800>)
 801e5c4:	6013      	str	r3, [r2, #0]
 801e5c6:	e01c      	b.n	801e602 <finsh_compile+0x692>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_MUL_WORD);
 801e5c8:	687b      	ldr	r3, [r7, #4]
 801e5ca:	785b      	ldrb	r3, [r3, #1]
 801e5cc:	2b02      	cmp	r3, #2
 801e5ce:	d109      	bne.n	801e5e4 <finsh_compile+0x674>
 801e5d0:	4b67      	ldr	r3, [pc, #412]	; (801e770 <finsh_compile+0x800>)
 801e5d2:	681b      	ldr	r3, [r3, #0]
 801e5d4:	220e      	movs	r2, #14
 801e5d6:	701a      	strb	r2, [r3, #0]
 801e5d8:	4b65      	ldr	r3, [pc, #404]	; (801e770 <finsh_compile+0x800>)
 801e5da:	681b      	ldr	r3, [r3, #0]
 801e5dc:	3301      	adds	r3, #1
 801e5de:	4a64      	ldr	r2, [pc, #400]	; (801e770 <finsh_compile+0x800>)
 801e5e0:	6013      	str	r3, [r2, #0]
 801e5e2:	e00e      	b.n	801e602 <finsh_compile+0x692>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_MUL_DWORD);
 801e5e4:	687b      	ldr	r3, [r7, #4]
 801e5e6:	785b      	ldrb	r3, [r3, #1]
 801e5e8:	2b03      	cmp	r3, #3
 801e5ea:	d10a      	bne.n	801e602 <finsh_compile+0x692>
 801e5ec:	4b60      	ldr	r3, [pc, #384]	; (801e770 <finsh_compile+0x800>)
 801e5ee:	681b      	ldr	r3, [r3, #0]
 801e5f0:	220f      	movs	r2, #15
 801e5f2:	701a      	strb	r2, [r3, #0]
 801e5f4:	4b5e      	ldr	r3, [pc, #376]	; (801e770 <finsh_compile+0x800>)
 801e5f6:	681b      	ldr	r3, [r3, #0]
 801e5f8:	3301      	adds	r3, #1
 801e5fa:	4a5d      	ldr	r2, [pc, #372]	; (801e770 <finsh_compile+0x800>)
 801e5fc:	6013      	str	r3, [r2, #0]
            break;
 801e5fe:	f001 b896 	b.w	801f72e <finsh_compile+0x17be>
 801e602:	f001 b894 	b.w	801f72e <finsh_compile+0x17be>

        case FINSH_NODE_SYS_DIV:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_DIV_BYTE);
 801e606:	687b      	ldr	r3, [r7, #4]
 801e608:	785b      	ldrb	r3, [r3, #1]
 801e60a:	2b01      	cmp	r3, #1
 801e60c:	d109      	bne.n	801e622 <finsh_compile+0x6b2>
 801e60e:	4b58      	ldr	r3, [pc, #352]	; (801e770 <finsh_compile+0x800>)
 801e610:	681b      	ldr	r3, [r3, #0]
 801e612:	2207      	movs	r2, #7
 801e614:	701a      	strb	r2, [r3, #0]
 801e616:	4b56      	ldr	r3, [pc, #344]	; (801e770 <finsh_compile+0x800>)
 801e618:	681b      	ldr	r3, [r3, #0]
 801e61a:	3301      	adds	r3, #1
 801e61c:	4a54      	ldr	r2, [pc, #336]	; (801e770 <finsh_compile+0x800>)
 801e61e:	6013      	str	r3, [r2, #0]
 801e620:	e01c      	b.n	801e65c <finsh_compile+0x6ec>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_DIV_WORD);
 801e622:	687b      	ldr	r3, [r7, #4]
 801e624:	785b      	ldrb	r3, [r3, #1]
 801e626:	2b02      	cmp	r3, #2
 801e628:	d109      	bne.n	801e63e <finsh_compile+0x6ce>
 801e62a:	4b51      	ldr	r3, [pc, #324]	; (801e770 <finsh_compile+0x800>)
 801e62c:	681b      	ldr	r3, [r3, #0]
 801e62e:	2208      	movs	r2, #8
 801e630:	701a      	strb	r2, [r3, #0]
 801e632:	4b4f      	ldr	r3, [pc, #316]	; (801e770 <finsh_compile+0x800>)
 801e634:	681b      	ldr	r3, [r3, #0]
 801e636:	3301      	adds	r3, #1
 801e638:	4a4d      	ldr	r2, [pc, #308]	; (801e770 <finsh_compile+0x800>)
 801e63a:	6013      	str	r3, [r2, #0]
 801e63c:	e00e      	b.n	801e65c <finsh_compile+0x6ec>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_DIV_DWORD);
 801e63e:	687b      	ldr	r3, [r7, #4]
 801e640:	785b      	ldrb	r3, [r3, #1]
 801e642:	2b03      	cmp	r3, #3
 801e644:	d10a      	bne.n	801e65c <finsh_compile+0x6ec>
 801e646:	4b4a      	ldr	r3, [pc, #296]	; (801e770 <finsh_compile+0x800>)
 801e648:	681b      	ldr	r3, [r3, #0]
 801e64a:	2209      	movs	r2, #9
 801e64c:	701a      	strb	r2, [r3, #0]
 801e64e:	4b48      	ldr	r3, [pc, #288]	; (801e770 <finsh_compile+0x800>)
 801e650:	681b      	ldr	r3, [r3, #0]
 801e652:	3301      	adds	r3, #1
 801e654:	4a46      	ldr	r2, [pc, #280]	; (801e770 <finsh_compile+0x800>)
 801e656:	6013      	str	r3, [r2, #0]
            break;
 801e658:	f001 b869 	b.w	801f72e <finsh_compile+0x17be>
 801e65c:	f001 b867 	b.w	801f72e <finsh_compile+0x17be>

        case FINSH_NODE_SYS_MOD:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_MOD_BYTE);
 801e660:	687b      	ldr	r3, [r7, #4]
 801e662:	785b      	ldrb	r3, [r3, #1]
 801e664:	2b01      	cmp	r3, #1
 801e666:	d109      	bne.n	801e67c <finsh_compile+0x70c>
 801e668:	4b41      	ldr	r3, [pc, #260]	; (801e770 <finsh_compile+0x800>)
 801e66a:	681b      	ldr	r3, [r3, #0]
 801e66c:	220a      	movs	r2, #10
 801e66e:	701a      	strb	r2, [r3, #0]
 801e670:	4b3f      	ldr	r3, [pc, #252]	; (801e770 <finsh_compile+0x800>)
 801e672:	681b      	ldr	r3, [r3, #0]
 801e674:	3301      	adds	r3, #1
 801e676:	4a3e      	ldr	r2, [pc, #248]	; (801e770 <finsh_compile+0x800>)
 801e678:	6013      	str	r3, [r2, #0]
 801e67a:	e01c      	b.n	801e6b6 <finsh_compile+0x746>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_MOD_WORD);
 801e67c:	687b      	ldr	r3, [r7, #4]
 801e67e:	785b      	ldrb	r3, [r3, #1]
 801e680:	2b02      	cmp	r3, #2
 801e682:	d109      	bne.n	801e698 <finsh_compile+0x728>
 801e684:	4b3a      	ldr	r3, [pc, #232]	; (801e770 <finsh_compile+0x800>)
 801e686:	681b      	ldr	r3, [r3, #0]
 801e688:	220b      	movs	r2, #11
 801e68a:	701a      	strb	r2, [r3, #0]
 801e68c:	4b38      	ldr	r3, [pc, #224]	; (801e770 <finsh_compile+0x800>)
 801e68e:	681b      	ldr	r3, [r3, #0]
 801e690:	3301      	adds	r3, #1
 801e692:	4a37      	ldr	r2, [pc, #220]	; (801e770 <finsh_compile+0x800>)
 801e694:	6013      	str	r3, [r2, #0]
 801e696:	e00e      	b.n	801e6b6 <finsh_compile+0x746>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_MOD_DWORD);
 801e698:	687b      	ldr	r3, [r7, #4]
 801e69a:	785b      	ldrb	r3, [r3, #1]
 801e69c:	2b03      	cmp	r3, #3
 801e69e:	d10a      	bne.n	801e6b6 <finsh_compile+0x746>
 801e6a0:	4b33      	ldr	r3, [pc, #204]	; (801e770 <finsh_compile+0x800>)
 801e6a2:	681b      	ldr	r3, [r3, #0]
 801e6a4:	220c      	movs	r2, #12
 801e6a6:	701a      	strb	r2, [r3, #0]
 801e6a8:	4b31      	ldr	r3, [pc, #196]	; (801e770 <finsh_compile+0x800>)
 801e6aa:	681b      	ldr	r3, [r3, #0]
 801e6ac:	3301      	adds	r3, #1
 801e6ae:	4a30      	ldr	r2, [pc, #192]	; (801e770 <finsh_compile+0x800>)
 801e6b0:	6013      	str	r3, [r2, #0]
            break;
 801e6b2:	f001 b83c 	b.w	801f72e <finsh_compile+0x17be>
 801e6b6:	f001 b83a 	b.w	801f72e <finsh_compile+0x17be>

        /* bit operation */
        case FINSH_NODE_SYS_AND:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_AND_BYTE);
 801e6ba:	687b      	ldr	r3, [r7, #4]
 801e6bc:	785b      	ldrb	r3, [r3, #1]
 801e6be:	2b01      	cmp	r3, #1
 801e6c0:	d109      	bne.n	801e6d6 <finsh_compile+0x766>
 801e6c2:	4b2b      	ldr	r3, [pc, #172]	; (801e770 <finsh_compile+0x800>)
 801e6c4:	681b      	ldr	r3, [r3, #0]
 801e6c6:	2210      	movs	r2, #16
 801e6c8:	701a      	strb	r2, [r3, #0]
 801e6ca:	4b29      	ldr	r3, [pc, #164]	; (801e770 <finsh_compile+0x800>)
 801e6cc:	681b      	ldr	r3, [r3, #0]
 801e6ce:	3301      	adds	r3, #1
 801e6d0:	4a27      	ldr	r2, [pc, #156]	; (801e770 <finsh_compile+0x800>)
 801e6d2:	6013      	str	r3, [r2, #0]
 801e6d4:	e01c      	b.n	801e710 <finsh_compile+0x7a0>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_AND_WORD);
 801e6d6:	687b      	ldr	r3, [r7, #4]
 801e6d8:	785b      	ldrb	r3, [r3, #1]
 801e6da:	2b02      	cmp	r3, #2
 801e6dc:	d109      	bne.n	801e6f2 <finsh_compile+0x782>
 801e6de:	4b24      	ldr	r3, [pc, #144]	; (801e770 <finsh_compile+0x800>)
 801e6e0:	681b      	ldr	r3, [r3, #0]
 801e6e2:	2211      	movs	r2, #17
 801e6e4:	701a      	strb	r2, [r3, #0]
 801e6e6:	4b22      	ldr	r3, [pc, #136]	; (801e770 <finsh_compile+0x800>)
 801e6e8:	681b      	ldr	r3, [r3, #0]
 801e6ea:	3301      	adds	r3, #1
 801e6ec:	4a20      	ldr	r2, [pc, #128]	; (801e770 <finsh_compile+0x800>)
 801e6ee:	6013      	str	r3, [r2, #0]
 801e6f0:	e00e      	b.n	801e710 <finsh_compile+0x7a0>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_AND_DWORD);
 801e6f2:	687b      	ldr	r3, [r7, #4]
 801e6f4:	785b      	ldrb	r3, [r3, #1]
 801e6f6:	2b03      	cmp	r3, #3
 801e6f8:	d10a      	bne.n	801e710 <finsh_compile+0x7a0>
 801e6fa:	4b1d      	ldr	r3, [pc, #116]	; (801e770 <finsh_compile+0x800>)
 801e6fc:	681b      	ldr	r3, [r3, #0]
 801e6fe:	2212      	movs	r2, #18
 801e700:	701a      	strb	r2, [r3, #0]
 801e702:	4b1b      	ldr	r3, [pc, #108]	; (801e770 <finsh_compile+0x800>)
 801e704:	681b      	ldr	r3, [r3, #0]
 801e706:	3301      	adds	r3, #1
 801e708:	4a19      	ldr	r2, [pc, #100]	; (801e770 <finsh_compile+0x800>)
 801e70a:	6013      	str	r3, [r2, #0]
            break;
 801e70c:	f001 b80f 	b.w	801f72e <finsh_compile+0x17be>
 801e710:	f001 b80d 	b.w	801f72e <finsh_compile+0x17be>

        case FINSH_NODE_SYS_OR:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_OR_BYTE);
 801e714:	687b      	ldr	r3, [r7, #4]
 801e716:	785b      	ldrb	r3, [r3, #1]
 801e718:	2b01      	cmp	r3, #1
 801e71a:	d109      	bne.n	801e730 <finsh_compile+0x7c0>
 801e71c:	4b14      	ldr	r3, [pc, #80]	; (801e770 <finsh_compile+0x800>)
 801e71e:	681b      	ldr	r3, [r3, #0]
 801e720:	2213      	movs	r2, #19
 801e722:	701a      	strb	r2, [r3, #0]
 801e724:	4b12      	ldr	r3, [pc, #72]	; (801e770 <finsh_compile+0x800>)
 801e726:	681b      	ldr	r3, [r3, #0]
 801e728:	3301      	adds	r3, #1
 801e72a:	4a11      	ldr	r2, [pc, #68]	; (801e770 <finsh_compile+0x800>)
 801e72c:	6013      	str	r3, [r2, #0]
 801e72e:	e01c      	b.n	801e76a <finsh_compile+0x7fa>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_OR_WORD);
 801e730:	687b      	ldr	r3, [r7, #4]
 801e732:	785b      	ldrb	r3, [r3, #1]
 801e734:	2b02      	cmp	r3, #2
 801e736:	d109      	bne.n	801e74c <finsh_compile+0x7dc>
 801e738:	4b0d      	ldr	r3, [pc, #52]	; (801e770 <finsh_compile+0x800>)
 801e73a:	681b      	ldr	r3, [r3, #0]
 801e73c:	2214      	movs	r2, #20
 801e73e:	701a      	strb	r2, [r3, #0]
 801e740:	4b0b      	ldr	r3, [pc, #44]	; (801e770 <finsh_compile+0x800>)
 801e742:	681b      	ldr	r3, [r3, #0]
 801e744:	3301      	adds	r3, #1
 801e746:	4a0a      	ldr	r2, [pc, #40]	; (801e770 <finsh_compile+0x800>)
 801e748:	6013      	str	r3, [r2, #0]
 801e74a:	e00e      	b.n	801e76a <finsh_compile+0x7fa>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_OR_DWORD);
 801e74c:	687b      	ldr	r3, [r7, #4]
 801e74e:	785b      	ldrb	r3, [r3, #1]
 801e750:	2b03      	cmp	r3, #3
 801e752:	d10a      	bne.n	801e76a <finsh_compile+0x7fa>
 801e754:	4b06      	ldr	r3, [pc, #24]	; (801e770 <finsh_compile+0x800>)
 801e756:	681b      	ldr	r3, [r3, #0]
 801e758:	2215      	movs	r2, #21
 801e75a:	701a      	strb	r2, [r3, #0]
 801e75c:	4b04      	ldr	r3, [pc, #16]	; (801e770 <finsh_compile+0x800>)
 801e75e:	681b      	ldr	r3, [r3, #0]
 801e760:	3301      	adds	r3, #1
 801e762:	4a03      	ldr	r2, [pc, #12]	; (801e770 <finsh_compile+0x800>)
 801e764:	6013      	str	r3, [r2, #0]
            break;
 801e766:	f000 bfe2 	b.w	801f72e <finsh_compile+0x17be>
 801e76a:	f000 bfe0 	b.w	801f72e <finsh_compile+0x17be>
 801e76e:	bf00      	nop
 801e770:	20012bb8 	.word	0x20012bb8

        case FINSH_NODE_SYS_XOR:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_XOR_BYTE);
 801e774:	687b      	ldr	r3, [r7, #4]
 801e776:	785b      	ldrb	r3, [r3, #1]
 801e778:	2b01      	cmp	r3, #1
 801e77a:	d109      	bne.n	801e790 <finsh_compile+0x820>
 801e77c:	4b95      	ldr	r3, [pc, #596]	; (801e9d4 <finsh_compile+0xa64>)
 801e77e:	681b      	ldr	r3, [r3, #0]
 801e780:	2216      	movs	r2, #22
 801e782:	701a      	strb	r2, [r3, #0]
 801e784:	4b93      	ldr	r3, [pc, #588]	; (801e9d4 <finsh_compile+0xa64>)
 801e786:	681b      	ldr	r3, [r3, #0]
 801e788:	3301      	adds	r3, #1
 801e78a:	4a92      	ldr	r2, [pc, #584]	; (801e9d4 <finsh_compile+0xa64>)
 801e78c:	6013      	str	r3, [r2, #0]
 801e78e:	e01c      	b.n	801e7ca <finsh_compile+0x85a>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_XOR_WORD);
 801e790:	687b      	ldr	r3, [r7, #4]
 801e792:	785b      	ldrb	r3, [r3, #1]
 801e794:	2b02      	cmp	r3, #2
 801e796:	d109      	bne.n	801e7ac <finsh_compile+0x83c>
 801e798:	4b8e      	ldr	r3, [pc, #568]	; (801e9d4 <finsh_compile+0xa64>)
 801e79a:	681b      	ldr	r3, [r3, #0]
 801e79c:	2217      	movs	r2, #23
 801e79e:	701a      	strb	r2, [r3, #0]
 801e7a0:	4b8c      	ldr	r3, [pc, #560]	; (801e9d4 <finsh_compile+0xa64>)
 801e7a2:	681b      	ldr	r3, [r3, #0]
 801e7a4:	3301      	adds	r3, #1
 801e7a6:	4a8b      	ldr	r2, [pc, #556]	; (801e9d4 <finsh_compile+0xa64>)
 801e7a8:	6013      	str	r3, [r2, #0]
 801e7aa:	e00e      	b.n	801e7ca <finsh_compile+0x85a>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_XOR_DWORD);
 801e7ac:	687b      	ldr	r3, [r7, #4]
 801e7ae:	785b      	ldrb	r3, [r3, #1]
 801e7b0:	2b03      	cmp	r3, #3
 801e7b2:	d10a      	bne.n	801e7ca <finsh_compile+0x85a>
 801e7b4:	4b87      	ldr	r3, [pc, #540]	; (801e9d4 <finsh_compile+0xa64>)
 801e7b6:	681b      	ldr	r3, [r3, #0]
 801e7b8:	2218      	movs	r2, #24
 801e7ba:	701a      	strb	r2, [r3, #0]
 801e7bc:	4b85      	ldr	r3, [pc, #532]	; (801e9d4 <finsh_compile+0xa64>)
 801e7be:	681b      	ldr	r3, [r3, #0]
 801e7c0:	3301      	adds	r3, #1
 801e7c2:	4a84      	ldr	r2, [pc, #528]	; (801e9d4 <finsh_compile+0xa64>)
 801e7c4:	6013      	str	r3, [r2, #0]
            break;
 801e7c6:	f000 bfb2 	b.w	801f72e <finsh_compile+0x17be>
 801e7ca:	f000 bfb0 	b.w	801f72e <finsh_compile+0x17be>

        case FINSH_NODE_SYS_BITWISE:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_BITWISE_BYTE);
 801e7ce:	687b      	ldr	r3, [r7, #4]
 801e7d0:	785b      	ldrb	r3, [r3, #1]
 801e7d2:	2b01      	cmp	r3, #1
 801e7d4:	d109      	bne.n	801e7ea <finsh_compile+0x87a>
 801e7d6:	4b7f      	ldr	r3, [pc, #508]	; (801e9d4 <finsh_compile+0xa64>)
 801e7d8:	681b      	ldr	r3, [r3, #0]
 801e7da:	2219      	movs	r2, #25
 801e7dc:	701a      	strb	r2, [r3, #0]
 801e7de:	4b7d      	ldr	r3, [pc, #500]	; (801e9d4 <finsh_compile+0xa64>)
 801e7e0:	681b      	ldr	r3, [r3, #0]
 801e7e2:	3301      	adds	r3, #1
 801e7e4:	4a7b      	ldr	r2, [pc, #492]	; (801e9d4 <finsh_compile+0xa64>)
 801e7e6:	6013      	str	r3, [r2, #0]
 801e7e8:	e01c      	b.n	801e824 <finsh_compile+0x8b4>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_BITWISE_WORD);
 801e7ea:	687b      	ldr	r3, [r7, #4]
 801e7ec:	785b      	ldrb	r3, [r3, #1]
 801e7ee:	2b02      	cmp	r3, #2
 801e7f0:	d109      	bne.n	801e806 <finsh_compile+0x896>
 801e7f2:	4b78      	ldr	r3, [pc, #480]	; (801e9d4 <finsh_compile+0xa64>)
 801e7f4:	681b      	ldr	r3, [r3, #0]
 801e7f6:	221a      	movs	r2, #26
 801e7f8:	701a      	strb	r2, [r3, #0]
 801e7fa:	4b76      	ldr	r3, [pc, #472]	; (801e9d4 <finsh_compile+0xa64>)
 801e7fc:	681b      	ldr	r3, [r3, #0]
 801e7fe:	3301      	adds	r3, #1
 801e800:	4a74      	ldr	r2, [pc, #464]	; (801e9d4 <finsh_compile+0xa64>)
 801e802:	6013      	str	r3, [r2, #0]
 801e804:	e00e      	b.n	801e824 <finsh_compile+0x8b4>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_BITWISE_DWORD);
 801e806:	687b      	ldr	r3, [r7, #4]
 801e808:	785b      	ldrb	r3, [r3, #1]
 801e80a:	2b03      	cmp	r3, #3
 801e80c:	d10a      	bne.n	801e824 <finsh_compile+0x8b4>
 801e80e:	4b71      	ldr	r3, [pc, #452]	; (801e9d4 <finsh_compile+0xa64>)
 801e810:	681b      	ldr	r3, [r3, #0]
 801e812:	221b      	movs	r2, #27
 801e814:	701a      	strb	r2, [r3, #0]
 801e816:	4b6f      	ldr	r3, [pc, #444]	; (801e9d4 <finsh_compile+0xa64>)
 801e818:	681b      	ldr	r3, [r3, #0]
 801e81a:	3301      	adds	r3, #1
 801e81c:	4a6d      	ldr	r2, [pc, #436]	; (801e9d4 <finsh_compile+0xa64>)
 801e81e:	6013      	str	r3, [r2, #0]
            break;
 801e820:	f000 bf85 	b.w	801f72e <finsh_compile+0x17be>
 801e824:	f000 bf83 	b.w	801f72e <finsh_compile+0x17be>

        case FINSH_NODE_SYS_SHL:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_SHL_BYTE);
 801e828:	687b      	ldr	r3, [r7, #4]
 801e82a:	785b      	ldrb	r3, [r3, #1]
 801e82c:	2b01      	cmp	r3, #1
 801e82e:	d109      	bne.n	801e844 <finsh_compile+0x8d4>
 801e830:	4b68      	ldr	r3, [pc, #416]	; (801e9d4 <finsh_compile+0xa64>)
 801e832:	681b      	ldr	r3, [r3, #0]
 801e834:	221c      	movs	r2, #28
 801e836:	701a      	strb	r2, [r3, #0]
 801e838:	4b66      	ldr	r3, [pc, #408]	; (801e9d4 <finsh_compile+0xa64>)
 801e83a:	681b      	ldr	r3, [r3, #0]
 801e83c:	3301      	adds	r3, #1
 801e83e:	4a65      	ldr	r2, [pc, #404]	; (801e9d4 <finsh_compile+0xa64>)
 801e840:	6013      	str	r3, [r2, #0]
 801e842:	e01c      	b.n	801e87e <finsh_compile+0x90e>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_SHL_WORD);
 801e844:	687b      	ldr	r3, [r7, #4]
 801e846:	785b      	ldrb	r3, [r3, #1]
 801e848:	2b02      	cmp	r3, #2
 801e84a:	d109      	bne.n	801e860 <finsh_compile+0x8f0>
 801e84c:	4b61      	ldr	r3, [pc, #388]	; (801e9d4 <finsh_compile+0xa64>)
 801e84e:	681b      	ldr	r3, [r3, #0]
 801e850:	221d      	movs	r2, #29
 801e852:	701a      	strb	r2, [r3, #0]
 801e854:	4b5f      	ldr	r3, [pc, #380]	; (801e9d4 <finsh_compile+0xa64>)
 801e856:	681b      	ldr	r3, [r3, #0]
 801e858:	3301      	adds	r3, #1
 801e85a:	4a5e      	ldr	r2, [pc, #376]	; (801e9d4 <finsh_compile+0xa64>)
 801e85c:	6013      	str	r3, [r2, #0]
 801e85e:	e00e      	b.n	801e87e <finsh_compile+0x90e>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_SHL_DWORD);
 801e860:	687b      	ldr	r3, [r7, #4]
 801e862:	785b      	ldrb	r3, [r3, #1]
 801e864:	2b03      	cmp	r3, #3
 801e866:	d10a      	bne.n	801e87e <finsh_compile+0x90e>
 801e868:	4b5a      	ldr	r3, [pc, #360]	; (801e9d4 <finsh_compile+0xa64>)
 801e86a:	681b      	ldr	r3, [r3, #0]
 801e86c:	221e      	movs	r2, #30
 801e86e:	701a      	strb	r2, [r3, #0]
 801e870:	4b58      	ldr	r3, [pc, #352]	; (801e9d4 <finsh_compile+0xa64>)
 801e872:	681b      	ldr	r3, [r3, #0]
 801e874:	3301      	adds	r3, #1
 801e876:	4a57      	ldr	r2, [pc, #348]	; (801e9d4 <finsh_compile+0xa64>)
 801e878:	6013      	str	r3, [r2, #0]
            break;
 801e87a:	f000 bf58 	b.w	801f72e <finsh_compile+0x17be>
 801e87e:	f000 bf56 	b.w	801f72e <finsh_compile+0x17be>

        case FINSH_NODE_SYS_SHR:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_SHR_BYTE);
 801e882:	687b      	ldr	r3, [r7, #4]
 801e884:	785b      	ldrb	r3, [r3, #1]
 801e886:	2b01      	cmp	r3, #1
 801e888:	d109      	bne.n	801e89e <finsh_compile+0x92e>
 801e88a:	4b52      	ldr	r3, [pc, #328]	; (801e9d4 <finsh_compile+0xa64>)
 801e88c:	681b      	ldr	r3, [r3, #0]
 801e88e:	221f      	movs	r2, #31
 801e890:	701a      	strb	r2, [r3, #0]
 801e892:	4b50      	ldr	r3, [pc, #320]	; (801e9d4 <finsh_compile+0xa64>)
 801e894:	681b      	ldr	r3, [r3, #0]
 801e896:	3301      	adds	r3, #1
 801e898:	4a4e      	ldr	r2, [pc, #312]	; (801e9d4 <finsh_compile+0xa64>)
 801e89a:	6013      	str	r3, [r2, #0]
 801e89c:	e01c      	b.n	801e8d8 <finsh_compile+0x968>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_SHR_WORD);
 801e89e:	687b      	ldr	r3, [r7, #4]
 801e8a0:	785b      	ldrb	r3, [r3, #1]
 801e8a2:	2b02      	cmp	r3, #2
 801e8a4:	d109      	bne.n	801e8ba <finsh_compile+0x94a>
 801e8a6:	4b4b      	ldr	r3, [pc, #300]	; (801e9d4 <finsh_compile+0xa64>)
 801e8a8:	681b      	ldr	r3, [r3, #0]
 801e8aa:	2220      	movs	r2, #32
 801e8ac:	701a      	strb	r2, [r3, #0]
 801e8ae:	4b49      	ldr	r3, [pc, #292]	; (801e9d4 <finsh_compile+0xa64>)
 801e8b0:	681b      	ldr	r3, [r3, #0]
 801e8b2:	3301      	adds	r3, #1
 801e8b4:	4a47      	ldr	r2, [pc, #284]	; (801e9d4 <finsh_compile+0xa64>)
 801e8b6:	6013      	str	r3, [r2, #0]
 801e8b8:	e00e      	b.n	801e8d8 <finsh_compile+0x968>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_SHR_DWORD);
 801e8ba:	687b      	ldr	r3, [r7, #4]
 801e8bc:	785b      	ldrb	r3, [r3, #1]
 801e8be:	2b03      	cmp	r3, #3
 801e8c0:	d10a      	bne.n	801e8d8 <finsh_compile+0x968>
 801e8c2:	4b44      	ldr	r3, [pc, #272]	; (801e9d4 <finsh_compile+0xa64>)
 801e8c4:	681b      	ldr	r3, [r3, #0]
 801e8c6:	2221      	movs	r2, #33	; 0x21
 801e8c8:	701a      	strb	r2, [r3, #0]
 801e8ca:	4b42      	ldr	r3, [pc, #264]	; (801e9d4 <finsh_compile+0xa64>)
 801e8cc:	681b      	ldr	r3, [r3, #0]
 801e8ce:	3301      	adds	r3, #1
 801e8d0:	4a40      	ldr	r2, [pc, #256]	; (801e9d4 <finsh_compile+0xa64>)
 801e8d2:	6013      	str	r3, [r2, #0]
            break;
 801e8d4:	f000 bf2b 	b.w	801f72e <finsh_compile+0x17be>
 801e8d8:	f000 bf29 	b.w	801f72e <finsh_compile+0x17be>
        case FINSH_NODE_SYS_FUNC:
            {
                int parameters;
                struct finsh_node* sibling;

                parameters = 0;
 801e8dc:	2300      	movs	r3, #0
 801e8de:	627b      	str	r3, [r7, #36]	; 0x24
                if (finsh_node_child(node) != NULL)
 801e8e0:	687b      	ldr	r3, [r7, #4]
 801e8e2:	691b      	ldr	r3, [r3, #16]
 801e8e4:	2b00      	cmp	r3, #0
 801e8e6:	d022      	beq.n	801e92e <finsh_compile+0x9be>
                {
                    sibling = finsh_node_sibling(finsh_node_child(node));
 801e8e8:	687b      	ldr	r3, [r7, #4]
 801e8ea:	691b      	ldr	r3, [r3, #16]
 801e8ec:	68db      	ldr	r3, [r3, #12]
 801e8ee:	623b      	str	r3, [r7, #32]
                    while (sibling != NULL)
 801e8f0:	e005      	b.n	801e8fe <finsh_compile+0x98e>
                    {
                        parameters ++;
 801e8f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e8f4:	3301      	adds	r3, #1
 801e8f6:	627b      	str	r3, [r7, #36]	; 0x24
                        sibling = finsh_node_sibling(sibling);
 801e8f8:	6a3b      	ldr	r3, [r7, #32]
 801e8fa:	68db      	ldr	r3, [r3, #12]
 801e8fc:	623b      	str	r3, [r7, #32]

                parameters = 0;
                if (finsh_node_child(node) != NULL)
                {
                    sibling = finsh_node_sibling(finsh_node_child(node));
                    while (sibling != NULL)
 801e8fe:	6a3b      	ldr	r3, [r7, #32]
 801e900:	2b00      	cmp	r3, #0
 801e902:	d1f6      	bne.n	801e8f2 <finsh_compile+0x982>

                    /* load address of function */
                    // finsh_code_dword((long)&(node->var->value.ptr));

                    /* syscall parameters */
                    finsh_code_byte(FINSH_OP_SYSCALL);
 801e904:	4b33      	ldr	r3, [pc, #204]	; (801e9d4 <finsh_compile+0xa64>)
 801e906:	681b      	ldr	r3, [r3, #0]
 801e908:	222c      	movs	r2, #44	; 0x2c
 801e90a:	701a      	strb	r2, [r3, #0]
 801e90c:	4b31      	ldr	r3, [pc, #196]	; (801e9d4 <finsh_compile+0xa64>)
 801e90e:	681b      	ldr	r3, [r3, #0]
 801e910:	3301      	adds	r3, #1
 801e912:	4a30      	ldr	r2, [pc, #192]	; (801e9d4 <finsh_compile+0xa64>)
 801e914:	6013      	str	r3, [r2, #0]
                    finsh_code_byte(parameters);
 801e916:	4b2f      	ldr	r3, [pc, #188]	; (801e9d4 <finsh_compile+0xa64>)
 801e918:	681b      	ldr	r3, [r3, #0]
 801e91a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801e91c:	b2d2      	uxtb	r2, r2
 801e91e:	701a      	strb	r2, [r3, #0]
 801e920:	4b2c      	ldr	r3, [pc, #176]	; (801e9d4 <finsh_compile+0xa64>)
 801e922:	681b      	ldr	r3, [r3, #0]
 801e924:	3301      	adds	r3, #1
 801e926:	4a2b      	ldr	r2, [pc, #172]	; (801e9d4 <finsh_compile+0xa64>)
 801e928:	6013      	str	r3, [r2, #0]
                }
            }
            break;
 801e92a:	f000 bf00 	b.w	801f72e <finsh_compile+0x17be>
 801e92e:	f000 befe 	b.w	801f72e <finsh_compile+0x17be>

        /* assign expression */
        case FINSH_NODE_SYS_ASSIGN:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
 801e932:	687b      	ldr	r3, [r7, #4]
 801e934:	691b      	ldr	r3, [r3, #16]
 801e936:	2b00      	cmp	r3, #0
 801e938:	d04e      	beq.n	801e9d8 <finsh_compile+0xa68>
 801e93a:	687b      	ldr	r3, [r7, #4]
 801e93c:	691b      	ldr	r3, [r3, #16]
 801e93e:	781b      	ldrb	r3, [r3, #0]
 801e940:	2b01      	cmp	r3, #1
 801e942:	d149      	bne.n	801e9d8 <finsh_compile+0xa68>
            {
                switch (finsh_node_child(node)->data_type)
 801e944:	687b      	ldr	r3, [r7, #4]
 801e946:	691b      	ldr	r3, [r3, #16]
 801e948:	785b      	ldrb	r3, [r3, #1]
 801e94a:	2b02      	cmp	r3, #2
 801e94c:	d016      	beq.n	801e97c <finsh_compile+0xa0c>
 801e94e:	2b03      	cmp	r3, #3
 801e950:	d027      	beq.n	801e9a2 <finsh_compile+0xa32>
 801e952:	2b01      	cmp	r3, #1
 801e954:	d138      	bne.n	801e9c8 <finsh_compile+0xa58>
                {
                case FINSH_DATA_TYPE_BYTE:
                    finsh_code_byte(FINSH_OP_ST_BYTE);
 801e956:	4b1f      	ldr	r3, [pc, #124]	; (801e9d4 <finsh_compile+0xa64>)
 801e958:	681b      	ldr	r3, [r3, #0]
 801e95a:	2228      	movs	r2, #40	; 0x28
 801e95c:	701a      	strb	r2, [r3, #0]
 801e95e:	4b1d      	ldr	r3, [pc, #116]	; (801e9d4 <finsh_compile+0xa64>)
 801e960:	681b      	ldr	r3, [r3, #0]
 801e962:	3301      	adds	r3, #1
 801e964:	4a1b      	ldr	r2, [pc, #108]	; (801e9d4 <finsh_compile+0xa64>)
 801e966:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE_STACK);
 801e968:	4b1a      	ldr	r3, [pc, #104]	; (801e9d4 <finsh_compile+0xa64>)
 801e96a:	681b      	ldr	r3, [r3, #0]
 801e96c:	222d      	movs	r2, #45	; 0x2d
 801e96e:	701a      	strb	r2, [r3, #0]
 801e970:	4b18      	ldr	r3, [pc, #96]	; (801e9d4 <finsh_compile+0xa64>)
 801e972:	681b      	ldr	r3, [r3, #0]
 801e974:	3301      	adds	r3, #1
 801e976:	4a17      	ldr	r2, [pc, #92]	; (801e9d4 <finsh_compile+0xa64>)
 801e978:	6013      	str	r3, [r2, #0]
                    break;
 801e97a:	e029      	b.n	801e9d0 <finsh_compile+0xa60>

                case FINSH_DATA_TYPE_WORD:
                    finsh_code_byte(FINSH_OP_ST_WORD);
 801e97c:	4b15      	ldr	r3, [pc, #84]	; (801e9d4 <finsh_compile+0xa64>)
 801e97e:	681b      	ldr	r3, [r3, #0]
 801e980:	2229      	movs	r2, #41	; 0x29
 801e982:	701a      	strb	r2, [r3, #0]
 801e984:	4b13      	ldr	r3, [pc, #76]	; (801e9d4 <finsh_compile+0xa64>)
 801e986:	681b      	ldr	r3, [r3, #0]
 801e988:	3301      	adds	r3, #1
 801e98a:	4a12      	ldr	r2, [pc, #72]	; (801e9d4 <finsh_compile+0xa64>)
 801e98c:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD_STACK);
 801e98e:	4b11      	ldr	r3, [pc, #68]	; (801e9d4 <finsh_compile+0xa64>)
 801e990:	681b      	ldr	r3, [r3, #0]
 801e992:	222e      	movs	r2, #46	; 0x2e
 801e994:	701a      	strb	r2, [r3, #0]
 801e996:	4b0f      	ldr	r3, [pc, #60]	; (801e9d4 <finsh_compile+0xa64>)
 801e998:	681b      	ldr	r3, [r3, #0]
 801e99a:	3301      	adds	r3, #1
 801e99c:	4a0d      	ldr	r2, [pc, #52]	; (801e9d4 <finsh_compile+0xa64>)
 801e99e:	6013      	str	r3, [r2, #0]
                    break;
 801e9a0:	e016      	b.n	801e9d0 <finsh_compile+0xa60>

                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_ST_DWORD);
 801e9a2:	4b0c      	ldr	r3, [pc, #48]	; (801e9d4 <finsh_compile+0xa64>)
 801e9a4:	681b      	ldr	r3, [r3, #0]
 801e9a6:	222a      	movs	r2, #42	; 0x2a
 801e9a8:	701a      	strb	r2, [r3, #0]
 801e9aa:	4b0a      	ldr	r3, [pc, #40]	; (801e9d4 <finsh_compile+0xa64>)
 801e9ac:	681b      	ldr	r3, [r3, #0]
 801e9ae:	3301      	adds	r3, #1
 801e9b0:	4a08      	ldr	r2, [pc, #32]	; (801e9d4 <finsh_compile+0xa64>)
 801e9b2:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801e9b4:	4b07      	ldr	r3, [pc, #28]	; (801e9d4 <finsh_compile+0xa64>)
 801e9b6:	681b      	ldr	r3, [r3, #0]
 801e9b8:	222f      	movs	r2, #47	; 0x2f
 801e9ba:	701a      	strb	r2, [r3, #0]
 801e9bc:	4b05      	ldr	r3, [pc, #20]	; (801e9d4 <finsh_compile+0xa64>)
 801e9be:	681b      	ldr	r3, [r3, #0]
 801e9c0:	3301      	adds	r3, #1
 801e9c2:	4a04      	ldr	r2, [pc, #16]	; (801e9d4 <finsh_compile+0xa64>)
 801e9c4:	6013      	str	r3, [r2, #0]
                    break;
 801e9c6:	e003      	b.n	801e9d0 <finsh_compile+0xa60>

                default:
                    finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
 801e9c8:	2003      	movs	r0, #3
 801e9ca:	f001 f81d 	bl	801fa08 <finsh_error_set>
                }
            }
 801e9ce:	e051      	b.n	801ea74 <finsh_compile+0xb04>
 801e9d0:	e050      	b.n	801ea74 <finsh_compile+0xb04>
 801e9d2:	bf00      	nop
 801e9d4:	20012bb8 	.word	0x20012bb8
            else if (finsh_node_child(node)->node_type == FINSH_NODE_SYS_GETVALUE)
 801e9d8:	687b      	ldr	r3, [r7, #4]
 801e9da:	691b      	ldr	r3, [r3, #16]
 801e9dc:	781b      	ldrb	r3, [r3, #0]
 801e9de:	2b19      	cmp	r3, #25
 801e9e0:	d148      	bne.n	801ea74 <finsh_compile+0xb04>
            {
                switch ((finsh_node_child(node)->data_type) & 0x0F)
 801e9e2:	687b      	ldr	r3, [r7, #4]
 801e9e4:	691b      	ldr	r3, [r3, #16]
 801e9e6:	785b      	ldrb	r3, [r3, #1]
 801e9e8:	f003 030f 	and.w	r3, r3, #15
 801e9ec:	2b02      	cmp	r3, #2
 801e9ee:	d016      	beq.n	801ea1e <finsh_compile+0xaae>
 801e9f0:	2b03      	cmp	r3, #3
 801e9f2:	d027      	beq.n	801ea44 <finsh_compile+0xad4>
 801e9f4:	2b01      	cmp	r3, #1
 801e9f6:	d138      	bne.n	801ea6a <finsh_compile+0xafa>
                {
                case FINSH_DATA_TYPE_BYTE:
                    finsh_code_byte(FINSH_OP_ST_BYTE);
 801e9f8:	4b89      	ldr	r3, [pc, #548]	; (801ec20 <finsh_compile+0xcb0>)
 801e9fa:	681b      	ldr	r3, [r3, #0]
 801e9fc:	2228      	movs	r2, #40	; 0x28
 801e9fe:	701a      	strb	r2, [r3, #0]
 801ea00:	4b87      	ldr	r3, [pc, #540]	; (801ec20 <finsh_compile+0xcb0>)
 801ea02:	681b      	ldr	r3, [r3, #0]
 801ea04:	3301      	adds	r3, #1
 801ea06:	4a86      	ldr	r2, [pc, #536]	; (801ec20 <finsh_compile+0xcb0>)
 801ea08:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE_STACK);
 801ea0a:	4b85      	ldr	r3, [pc, #532]	; (801ec20 <finsh_compile+0xcb0>)
 801ea0c:	681b      	ldr	r3, [r3, #0]
 801ea0e:	222d      	movs	r2, #45	; 0x2d
 801ea10:	701a      	strb	r2, [r3, #0]
 801ea12:	4b83      	ldr	r3, [pc, #524]	; (801ec20 <finsh_compile+0xcb0>)
 801ea14:	681b      	ldr	r3, [r3, #0]
 801ea16:	3301      	adds	r3, #1
 801ea18:	4a81      	ldr	r2, [pc, #516]	; (801ec20 <finsh_compile+0xcb0>)
 801ea1a:	6013      	str	r3, [r2, #0]
                    break;
 801ea1c:	e02a      	b.n	801ea74 <finsh_compile+0xb04>

                case FINSH_DATA_TYPE_WORD:
                    finsh_code_byte(FINSH_OP_ST_WORD);
 801ea1e:	4b80      	ldr	r3, [pc, #512]	; (801ec20 <finsh_compile+0xcb0>)
 801ea20:	681b      	ldr	r3, [r3, #0]
 801ea22:	2229      	movs	r2, #41	; 0x29
 801ea24:	701a      	strb	r2, [r3, #0]
 801ea26:	4b7e      	ldr	r3, [pc, #504]	; (801ec20 <finsh_compile+0xcb0>)
 801ea28:	681b      	ldr	r3, [r3, #0]
 801ea2a:	3301      	adds	r3, #1
 801ea2c:	4a7c      	ldr	r2, [pc, #496]	; (801ec20 <finsh_compile+0xcb0>)
 801ea2e:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD_STACK);
 801ea30:	4b7b      	ldr	r3, [pc, #492]	; (801ec20 <finsh_compile+0xcb0>)
 801ea32:	681b      	ldr	r3, [r3, #0]
 801ea34:	222e      	movs	r2, #46	; 0x2e
 801ea36:	701a      	strb	r2, [r3, #0]
 801ea38:	4b79      	ldr	r3, [pc, #484]	; (801ec20 <finsh_compile+0xcb0>)
 801ea3a:	681b      	ldr	r3, [r3, #0]
 801ea3c:	3301      	adds	r3, #1
 801ea3e:	4a78      	ldr	r2, [pc, #480]	; (801ec20 <finsh_compile+0xcb0>)
 801ea40:	6013      	str	r3, [r2, #0]
                    break;
 801ea42:	e017      	b.n	801ea74 <finsh_compile+0xb04>

                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_ST_DWORD);
 801ea44:	4b76      	ldr	r3, [pc, #472]	; (801ec20 <finsh_compile+0xcb0>)
 801ea46:	681b      	ldr	r3, [r3, #0]
 801ea48:	222a      	movs	r2, #42	; 0x2a
 801ea4a:	701a      	strb	r2, [r3, #0]
 801ea4c:	4b74      	ldr	r3, [pc, #464]	; (801ec20 <finsh_compile+0xcb0>)
 801ea4e:	681b      	ldr	r3, [r3, #0]
 801ea50:	3301      	adds	r3, #1
 801ea52:	4a73      	ldr	r2, [pc, #460]	; (801ec20 <finsh_compile+0xcb0>)
 801ea54:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801ea56:	4b72      	ldr	r3, [pc, #456]	; (801ec20 <finsh_compile+0xcb0>)
 801ea58:	681b      	ldr	r3, [r3, #0]
 801ea5a:	222f      	movs	r2, #47	; 0x2f
 801ea5c:	701a      	strb	r2, [r3, #0]
 801ea5e:	4b70      	ldr	r3, [pc, #448]	; (801ec20 <finsh_compile+0xcb0>)
 801ea60:	681b      	ldr	r3, [r3, #0]
 801ea62:	3301      	adds	r3, #1
 801ea64:	4a6e      	ldr	r2, [pc, #440]	; (801ec20 <finsh_compile+0xcb0>)
 801ea66:	6013      	str	r3, [r2, #0]
                    break;
 801ea68:	e004      	b.n	801ea74 <finsh_compile+0xb04>

                default:
                    finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
 801ea6a:	2003      	movs	r0, #3
 801ea6c:	f000 ffcc 	bl	801fa08 <finsh_error_set>
                }
            }
            break;
 801ea70:	f000 be5d 	b.w	801f72e <finsh_compile+0x17be>
 801ea74:	f000 be5b 	b.w	801f72e <finsh_compile+0x17be>

        /* pre-increase */
        case FINSH_NODE_SYS_PREINC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
 801ea78:	687b      	ldr	r3, [r7, #4]
 801ea7a:	691b      	ldr	r3, [r3, #16]
 801ea7c:	2b00      	cmp	r3, #0
 801ea7e:	f000 813a 	beq.w	801ecf6 <finsh_compile+0xd86>
 801ea82:	687b      	ldr	r3, [r7, #4]
 801ea84:	691b      	ldr	r3, [r3, #16]
 801ea86:	781b      	ldrb	r3, [r3, #0]
 801ea88:	2b01      	cmp	r3, #1
 801ea8a:	f040 8134 	bne.w	801ecf6 <finsh_compile+0xd86>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
 801ea8e:	687b      	ldr	r3, [r7, #4]
 801ea90:	691b      	ldr	r3, [r3, #16]
 801ea92:	689b      	ldr	r3, [r3, #8]
 801ea94:	617b      	str	r3, [r7, #20]

                /* ld_dword &id */
                // finsh_code_byte(FINSH_OP_LD_DWORD);

                switch (node->data_type)
 801ea96:	687b      	ldr	r3, [r7, #4]
 801ea98:	785b      	ldrb	r3, [r3, #1]
 801ea9a:	2b02      	cmp	r3, #2
 801ea9c:	d060      	beq.n	801eb60 <finsh_compile+0xbf0>
 801ea9e:	2b03      	cmp	r3, #3
 801eaa0:	f000 80c0 	beq.w	801ec24 <finsh_compile+0xcb4>
 801eaa4:	2b01      	cmp	r3, #1
 801eaa6:	d001      	beq.n	801eaac <finsh_compile+0xb3c>
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);

                    break;
                }
            }
            break;
 801eaa8:	f000 be41 	b.w	801f72e <finsh_compile+0x17be>
                case FINSH_DATA_TYPE_BYTE:
                    /* address */
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
 801eaac:	4b5c      	ldr	r3, [pc, #368]	; (801ec20 <finsh_compile+0xcb0>)
 801eaae:	681b      	ldr	r3, [r3, #0]
 801eab0:	2225      	movs	r2, #37	; 0x25
 801eab2:	701a      	strb	r2, [r3, #0]
 801eab4:	4b5a      	ldr	r3, [pc, #360]	; (801ec20 <finsh_compile+0xcb0>)
 801eab6:	681b      	ldr	r3, [r3, #0]
 801eab8:	3301      	adds	r3, #1
 801eaba:	4a59      	ldr	r2, [pc, #356]	; (801ec20 <finsh_compile+0xcb0>)
 801eabc:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.char_value));
 801eabe:	4b58      	ldr	r3, [pc, #352]	; (801ec20 <finsh_compile+0xcb0>)
 801eac0:	681b      	ldr	r3, [r3, #0]
 801eac2:	697a      	ldr	r2, [r7, #20]
 801eac4:	3214      	adds	r2, #20
 801eac6:	b2d2      	uxtb	r2, r2
 801eac8:	701a      	strb	r2, [r3, #0]
 801eaca:	4b55      	ldr	r3, [pc, #340]	; (801ec20 <finsh_compile+0xcb0>)
 801eacc:	681b      	ldr	r3, [r3, #0]
 801eace:	3301      	adds	r3, #1
 801ead0:	697a      	ldr	r2, [r7, #20]
 801ead2:	3214      	adds	r2, #20
 801ead4:	0a12      	lsrs	r2, r2, #8
 801ead6:	b2d2      	uxtb	r2, r2
 801ead8:	701a      	strb	r2, [r3, #0]
 801eada:	4b51      	ldr	r3, [pc, #324]	; (801ec20 <finsh_compile+0xcb0>)
 801eadc:	681b      	ldr	r3, [r3, #0]
 801eade:	3302      	adds	r3, #2
 801eae0:	697a      	ldr	r2, [r7, #20]
 801eae2:	3214      	adds	r2, #20
 801eae4:	0c12      	lsrs	r2, r2, #16
 801eae6:	b2d2      	uxtb	r2, r2
 801eae8:	701a      	strb	r2, [r3, #0]
 801eaea:	4b4d      	ldr	r3, [pc, #308]	; (801ec20 <finsh_compile+0xcb0>)
 801eaec:	681b      	ldr	r3, [r3, #0]
 801eaee:	3303      	adds	r3, #3
 801eaf0:	697a      	ldr	r2, [r7, #20]
 801eaf2:	3214      	adds	r2, #20
 801eaf4:	0e12      	lsrs	r2, r2, #24
 801eaf6:	b2d2      	uxtb	r2, r2
 801eaf8:	701a      	strb	r2, [r3, #0]
 801eafa:	4b49      	ldr	r3, [pc, #292]	; (801ec20 <finsh_compile+0xcb0>)
 801eafc:	681b      	ldr	r3, [r3, #0]
 801eafe:	3304      	adds	r3, #4
 801eb00:	4a47      	ldr	r2, [pc, #284]	; (801ec20 <finsh_compile+0xcb0>)
 801eb02:	6013      	str	r3, [r2, #0]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
 801eb04:	4b46      	ldr	r3, [pc, #280]	; (801ec20 <finsh_compile+0xcb0>)
 801eb06:	681b      	ldr	r3, [r3, #0]
 801eb08:	2222      	movs	r2, #34	; 0x22
 801eb0a:	701a      	strb	r2, [r3, #0]
 801eb0c:	4b44      	ldr	r3, [pc, #272]	; (801ec20 <finsh_compile+0xcb0>)
 801eb0e:	681b      	ldr	r3, [r3, #0]
 801eb10:	3301      	adds	r3, #1
 801eb12:	4a43      	ldr	r2, [pc, #268]	; (801ec20 <finsh_compile+0xcb0>)
 801eb14:	6013      	str	r3, [r2, #0]
                    finsh_code_byte(1);
 801eb16:	4b42      	ldr	r3, [pc, #264]	; (801ec20 <finsh_compile+0xcb0>)
 801eb18:	681b      	ldr	r3, [r3, #0]
 801eb1a:	2201      	movs	r2, #1
 801eb1c:	701a      	strb	r2, [r3, #0]
 801eb1e:	4b40      	ldr	r3, [pc, #256]	; (801ec20 <finsh_compile+0xcb0>)
 801eb20:	681b      	ldr	r3, [r3, #0]
 801eb22:	3301      	adds	r3, #1
 801eb24:	4a3e      	ldr	r2, [pc, #248]	; (801ec20 <finsh_compile+0xcb0>)
 801eb26:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_BYTE);
 801eb28:	4b3d      	ldr	r3, [pc, #244]	; (801ec20 <finsh_compile+0xcb0>)
 801eb2a:	681b      	ldr	r3, [r3, #0]
 801eb2c:	2201      	movs	r2, #1
 801eb2e:	701a      	strb	r2, [r3, #0]
 801eb30:	4b3b      	ldr	r3, [pc, #236]	; (801ec20 <finsh_compile+0xcb0>)
 801eb32:	681b      	ldr	r3, [r3, #0]
 801eb34:	3301      	adds	r3, #1
 801eb36:	4a3a      	ldr	r2, [pc, #232]	; (801ec20 <finsh_compile+0xcb0>)
 801eb38:	6013      	str	r3, [r2, #0]
                    /* st_byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
 801eb3a:	4b39      	ldr	r3, [pc, #228]	; (801ec20 <finsh_compile+0xcb0>)
 801eb3c:	681b      	ldr	r3, [r3, #0]
 801eb3e:	2228      	movs	r2, #40	; 0x28
 801eb40:	701a      	strb	r2, [r3, #0]
 801eb42:	4b37      	ldr	r3, [pc, #220]	; (801ec20 <finsh_compile+0xcb0>)
 801eb44:	681b      	ldr	r3, [r3, #0]
 801eb46:	3301      	adds	r3, #1
 801eb48:	4a35      	ldr	r2, [pc, #212]	; (801ec20 <finsh_compile+0xcb0>)
 801eb4a:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801eb4c:	4b34      	ldr	r3, [pc, #208]	; (801ec20 <finsh_compile+0xcb0>)
 801eb4e:	681b      	ldr	r3, [r3, #0]
 801eb50:	222f      	movs	r2, #47	; 0x2f
 801eb52:	701a      	strb	r2, [r3, #0]
 801eb54:	4b32      	ldr	r3, [pc, #200]	; (801ec20 <finsh_compile+0xcb0>)
 801eb56:	681b      	ldr	r3, [r3, #0]
 801eb58:	3301      	adds	r3, #1
 801eb5a:	4a31      	ldr	r2, [pc, #196]	; (801ec20 <finsh_compile+0xcb0>)
 801eb5c:	6013      	str	r3, [r2, #0]

                    break;
 801eb5e:	e0ca      	b.n	801ecf6 <finsh_compile+0xd86>
                case FINSH_DATA_TYPE_WORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
 801eb60:	4b2f      	ldr	r3, [pc, #188]	; (801ec20 <finsh_compile+0xcb0>)
 801eb62:	681b      	ldr	r3, [r3, #0]
 801eb64:	2226      	movs	r2, #38	; 0x26
 801eb66:	701a      	strb	r2, [r3, #0]
 801eb68:	4b2d      	ldr	r3, [pc, #180]	; (801ec20 <finsh_compile+0xcb0>)
 801eb6a:	681b      	ldr	r3, [r3, #0]
 801eb6c:	3301      	adds	r3, #1
 801eb6e:	4a2c      	ldr	r2, [pc, #176]	; (801ec20 <finsh_compile+0xcb0>)
 801eb70:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.short_value));
 801eb72:	4b2b      	ldr	r3, [pc, #172]	; (801ec20 <finsh_compile+0xcb0>)
 801eb74:	681b      	ldr	r3, [r3, #0]
 801eb76:	697a      	ldr	r2, [r7, #20]
 801eb78:	3214      	adds	r2, #20
 801eb7a:	b2d2      	uxtb	r2, r2
 801eb7c:	701a      	strb	r2, [r3, #0]
 801eb7e:	4b28      	ldr	r3, [pc, #160]	; (801ec20 <finsh_compile+0xcb0>)
 801eb80:	681b      	ldr	r3, [r3, #0]
 801eb82:	3301      	adds	r3, #1
 801eb84:	697a      	ldr	r2, [r7, #20]
 801eb86:	3214      	adds	r2, #20
 801eb88:	0a12      	lsrs	r2, r2, #8
 801eb8a:	b2d2      	uxtb	r2, r2
 801eb8c:	701a      	strb	r2, [r3, #0]
 801eb8e:	4b24      	ldr	r3, [pc, #144]	; (801ec20 <finsh_compile+0xcb0>)
 801eb90:	681b      	ldr	r3, [r3, #0]
 801eb92:	3302      	adds	r3, #2
 801eb94:	697a      	ldr	r2, [r7, #20]
 801eb96:	3214      	adds	r2, #20
 801eb98:	0c12      	lsrs	r2, r2, #16
 801eb9a:	b2d2      	uxtb	r2, r2
 801eb9c:	701a      	strb	r2, [r3, #0]
 801eb9e:	4b20      	ldr	r3, [pc, #128]	; (801ec20 <finsh_compile+0xcb0>)
 801eba0:	681b      	ldr	r3, [r3, #0]
 801eba2:	3303      	adds	r3, #3
 801eba4:	697a      	ldr	r2, [r7, #20]
 801eba6:	3214      	adds	r2, #20
 801eba8:	0e12      	lsrs	r2, r2, #24
 801ebaa:	b2d2      	uxtb	r2, r2
 801ebac:	701a      	strb	r2, [r3, #0]
 801ebae:	4b1c      	ldr	r3, [pc, #112]	; (801ec20 <finsh_compile+0xcb0>)
 801ebb0:	681b      	ldr	r3, [r3, #0]
 801ebb2:	3304      	adds	r3, #4
 801ebb4:	4a1a      	ldr	r2, [pc, #104]	; (801ec20 <finsh_compile+0xcb0>)
 801ebb6:	6013      	str	r3, [r2, #0]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
 801ebb8:	4b19      	ldr	r3, [pc, #100]	; (801ec20 <finsh_compile+0xcb0>)
 801ebba:	681b      	ldr	r3, [r3, #0]
 801ebbc:	2223      	movs	r2, #35	; 0x23
 801ebbe:	701a      	strb	r2, [r3, #0]
 801ebc0:	4b17      	ldr	r3, [pc, #92]	; (801ec20 <finsh_compile+0xcb0>)
 801ebc2:	681b      	ldr	r3, [r3, #0]
 801ebc4:	3301      	adds	r3, #1
 801ebc6:	4a16      	ldr	r2, [pc, #88]	; (801ec20 <finsh_compile+0xcb0>)
 801ebc8:	6013      	str	r3, [r2, #0]
                    finsh_code_word(1);
 801ebca:	4b15      	ldr	r3, [pc, #84]	; (801ec20 <finsh_compile+0xcb0>)
 801ebcc:	681b      	ldr	r3, [r3, #0]
 801ebce:	2201      	movs	r2, #1
 801ebd0:	701a      	strb	r2, [r3, #0]
 801ebd2:	4b13      	ldr	r3, [pc, #76]	; (801ec20 <finsh_compile+0xcb0>)
 801ebd4:	681b      	ldr	r3, [r3, #0]
 801ebd6:	3301      	adds	r3, #1
 801ebd8:	2200      	movs	r2, #0
 801ebda:	701a      	strb	r2, [r3, #0]
 801ebdc:	4b10      	ldr	r3, [pc, #64]	; (801ec20 <finsh_compile+0xcb0>)
 801ebde:	681b      	ldr	r3, [r3, #0]
 801ebe0:	3302      	adds	r3, #2
 801ebe2:	4a0f      	ldr	r2, [pc, #60]	; (801ec20 <finsh_compile+0xcb0>)
 801ebe4:	6013      	str	r3, [r2, #0]

                    /* add_word */
                    finsh_code_byte(FINSH_OP_ADD_WORD);
 801ebe6:	4b0e      	ldr	r3, [pc, #56]	; (801ec20 <finsh_compile+0xcb0>)
 801ebe8:	681b      	ldr	r3, [r3, #0]
 801ebea:	2202      	movs	r2, #2
 801ebec:	701a      	strb	r2, [r3, #0]
 801ebee:	4b0c      	ldr	r3, [pc, #48]	; (801ec20 <finsh_compile+0xcb0>)
 801ebf0:	681b      	ldr	r3, [r3, #0]
 801ebf2:	3301      	adds	r3, #1
 801ebf4:	4a0a      	ldr	r2, [pc, #40]	; (801ec20 <finsh_compile+0xcb0>)
 801ebf6:	6013      	str	r3, [r2, #0]
                    /* st_word */
                    finsh_code_byte(FINSH_OP_ST_WORD);
 801ebf8:	4b09      	ldr	r3, [pc, #36]	; (801ec20 <finsh_compile+0xcb0>)
 801ebfa:	681b      	ldr	r3, [r3, #0]
 801ebfc:	2229      	movs	r2, #41	; 0x29
 801ebfe:	701a      	strb	r2, [r3, #0]
 801ec00:	4b07      	ldr	r3, [pc, #28]	; (801ec20 <finsh_compile+0xcb0>)
 801ec02:	681b      	ldr	r3, [r3, #0]
 801ec04:	3301      	adds	r3, #1
 801ec06:	4a06      	ldr	r2, [pc, #24]	; (801ec20 <finsh_compile+0xcb0>)
 801ec08:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801ec0a:	4b05      	ldr	r3, [pc, #20]	; (801ec20 <finsh_compile+0xcb0>)
 801ec0c:	681b      	ldr	r3, [r3, #0]
 801ec0e:	222f      	movs	r2, #47	; 0x2f
 801ec10:	701a      	strb	r2, [r3, #0]
 801ec12:	4b03      	ldr	r3, [pc, #12]	; (801ec20 <finsh_compile+0xcb0>)
 801ec14:	681b      	ldr	r3, [r3, #0]
 801ec16:	3301      	adds	r3, #1
 801ec18:	4a01      	ldr	r2, [pc, #4]	; (801ec20 <finsh_compile+0xcb0>)
 801ec1a:	6013      	str	r3, [r2, #0]

                    break;
 801ec1c:	e06b      	b.n	801ecf6 <finsh_compile+0xd86>
 801ec1e:	bf00      	nop
 801ec20:	20012bb8 	.word	0x20012bb8
                case FINSH_DATA_TYPE_DWORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
 801ec24:	4b6f      	ldr	r3, [pc, #444]	; (801ede4 <finsh_compile+0xe74>)
 801ec26:	681b      	ldr	r3, [r3, #0]
 801ec28:	2227      	movs	r2, #39	; 0x27
 801ec2a:	701a      	strb	r2, [r3, #0]
 801ec2c:	4b6d      	ldr	r3, [pc, #436]	; (801ede4 <finsh_compile+0xe74>)
 801ec2e:	681b      	ldr	r3, [r3, #0]
 801ec30:	3301      	adds	r3, #1
 801ec32:	4a6c      	ldr	r2, [pc, #432]	; (801ede4 <finsh_compile+0xe74>)
 801ec34:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.long_value));
 801ec36:	4b6b      	ldr	r3, [pc, #428]	; (801ede4 <finsh_compile+0xe74>)
 801ec38:	681b      	ldr	r3, [r3, #0]
 801ec3a:	697a      	ldr	r2, [r7, #20]
 801ec3c:	3214      	adds	r2, #20
 801ec3e:	b2d2      	uxtb	r2, r2
 801ec40:	701a      	strb	r2, [r3, #0]
 801ec42:	4b68      	ldr	r3, [pc, #416]	; (801ede4 <finsh_compile+0xe74>)
 801ec44:	681b      	ldr	r3, [r3, #0]
 801ec46:	3301      	adds	r3, #1
 801ec48:	697a      	ldr	r2, [r7, #20]
 801ec4a:	3214      	adds	r2, #20
 801ec4c:	0a12      	lsrs	r2, r2, #8
 801ec4e:	b2d2      	uxtb	r2, r2
 801ec50:	701a      	strb	r2, [r3, #0]
 801ec52:	4b64      	ldr	r3, [pc, #400]	; (801ede4 <finsh_compile+0xe74>)
 801ec54:	681b      	ldr	r3, [r3, #0]
 801ec56:	3302      	adds	r3, #2
 801ec58:	697a      	ldr	r2, [r7, #20]
 801ec5a:	3214      	adds	r2, #20
 801ec5c:	0c12      	lsrs	r2, r2, #16
 801ec5e:	b2d2      	uxtb	r2, r2
 801ec60:	701a      	strb	r2, [r3, #0]
 801ec62:	4b60      	ldr	r3, [pc, #384]	; (801ede4 <finsh_compile+0xe74>)
 801ec64:	681b      	ldr	r3, [r3, #0]
 801ec66:	3303      	adds	r3, #3
 801ec68:	697a      	ldr	r2, [r7, #20]
 801ec6a:	3214      	adds	r2, #20
 801ec6c:	0e12      	lsrs	r2, r2, #24
 801ec6e:	b2d2      	uxtb	r2, r2
 801ec70:	701a      	strb	r2, [r3, #0]
 801ec72:	4b5c      	ldr	r3, [pc, #368]	; (801ede4 <finsh_compile+0xe74>)
 801ec74:	681b      	ldr	r3, [r3, #0]
 801ec76:	3304      	adds	r3, #4
 801ec78:	4a5a      	ldr	r2, [pc, #360]	; (801ede4 <finsh_compile+0xe74>)
 801ec7a:	6013      	str	r3, [r2, #0]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801ec7c:	4b59      	ldr	r3, [pc, #356]	; (801ede4 <finsh_compile+0xe74>)
 801ec7e:	681b      	ldr	r3, [r3, #0]
 801ec80:	2224      	movs	r2, #36	; 0x24
 801ec82:	701a      	strb	r2, [r3, #0]
 801ec84:	4b57      	ldr	r3, [pc, #348]	; (801ede4 <finsh_compile+0xe74>)
 801ec86:	681b      	ldr	r3, [r3, #0]
 801ec88:	3301      	adds	r3, #1
 801ec8a:	4a56      	ldr	r2, [pc, #344]	; (801ede4 <finsh_compile+0xe74>)
 801ec8c:	6013      	str	r3, [r2, #0]
                    finsh_code_dword(1);
 801ec8e:	4b55      	ldr	r3, [pc, #340]	; (801ede4 <finsh_compile+0xe74>)
 801ec90:	681b      	ldr	r3, [r3, #0]
 801ec92:	2201      	movs	r2, #1
 801ec94:	701a      	strb	r2, [r3, #0]
 801ec96:	4b53      	ldr	r3, [pc, #332]	; (801ede4 <finsh_compile+0xe74>)
 801ec98:	681b      	ldr	r3, [r3, #0]
 801ec9a:	3301      	adds	r3, #1
 801ec9c:	2200      	movs	r2, #0
 801ec9e:	701a      	strb	r2, [r3, #0]
 801eca0:	4b50      	ldr	r3, [pc, #320]	; (801ede4 <finsh_compile+0xe74>)
 801eca2:	681b      	ldr	r3, [r3, #0]
 801eca4:	3302      	adds	r3, #2
 801eca6:	2200      	movs	r2, #0
 801eca8:	701a      	strb	r2, [r3, #0]
 801ecaa:	4b4e      	ldr	r3, [pc, #312]	; (801ede4 <finsh_compile+0xe74>)
 801ecac:	681b      	ldr	r3, [r3, #0]
 801ecae:	3303      	adds	r3, #3
 801ecb0:	2200      	movs	r2, #0
 801ecb2:	701a      	strb	r2, [r3, #0]
 801ecb4:	4b4b      	ldr	r3, [pc, #300]	; (801ede4 <finsh_compile+0xe74>)
 801ecb6:	681b      	ldr	r3, [r3, #0]
 801ecb8:	3304      	adds	r3, #4
 801ecba:	4a4a      	ldr	r2, [pc, #296]	; (801ede4 <finsh_compile+0xe74>)
 801ecbc:	6013      	str	r3, [r2, #0]

                    /* add_dword */
                    finsh_code_byte(FINSH_OP_ADD_DWORD);
 801ecbe:	4b49      	ldr	r3, [pc, #292]	; (801ede4 <finsh_compile+0xe74>)
 801ecc0:	681b      	ldr	r3, [r3, #0]
 801ecc2:	2203      	movs	r2, #3
 801ecc4:	701a      	strb	r2, [r3, #0]
 801ecc6:	4b47      	ldr	r3, [pc, #284]	; (801ede4 <finsh_compile+0xe74>)
 801ecc8:	681b      	ldr	r3, [r3, #0]
 801ecca:	3301      	adds	r3, #1
 801eccc:	4a45      	ldr	r2, [pc, #276]	; (801ede4 <finsh_compile+0xe74>)
 801ecce:	6013      	str	r3, [r2, #0]
                    /* st_dword */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
 801ecd0:	4b44      	ldr	r3, [pc, #272]	; (801ede4 <finsh_compile+0xe74>)
 801ecd2:	681b      	ldr	r3, [r3, #0]
 801ecd4:	222a      	movs	r2, #42	; 0x2a
 801ecd6:	701a      	strb	r2, [r3, #0]
 801ecd8:	4b42      	ldr	r3, [pc, #264]	; (801ede4 <finsh_compile+0xe74>)
 801ecda:	681b      	ldr	r3, [r3, #0]
 801ecdc:	3301      	adds	r3, #1
 801ecde:	4a41      	ldr	r2, [pc, #260]	; (801ede4 <finsh_compile+0xe74>)
 801ece0:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801ece2:	4b40      	ldr	r3, [pc, #256]	; (801ede4 <finsh_compile+0xe74>)
 801ece4:	681b      	ldr	r3, [r3, #0]
 801ece6:	222f      	movs	r2, #47	; 0x2f
 801ece8:	701a      	strb	r2, [r3, #0]
 801ecea:	4b3e      	ldr	r3, [pc, #248]	; (801ede4 <finsh_compile+0xe74>)
 801ecec:	681b      	ldr	r3, [r3, #0]
 801ecee:	3301      	adds	r3, #1
 801ecf0:	4a3c      	ldr	r2, [pc, #240]	; (801ede4 <finsh_compile+0xe74>)
 801ecf2:	6013      	str	r3, [r2, #0]

                    break;
 801ecf4:	bf00      	nop
                }
            }
            break;
 801ecf6:	f000 bd1a 	b.w	801f72e <finsh_compile+0x17be>

        /* pre-decrease */
        case FINSH_NODE_SYS_PREDEC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
 801ecfa:	687b      	ldr	r3, [r7, #4]
 801ecfc:	691b      	ldr	r3, [r3, #16]
 801ecfe:	2b00      	cmp	r3, #0
 801ed00:	f000 813a 	beq.w	801ef78 <finsh_compile+0x1008>
 801ed04:	687b      	ldr	r3, [r7, #4]
 801ed06:	691b      	ldr	r3, [r3, #16]
 801ed08:	781b      	ldrb	r3, [r3, #0]
 801ed0a:	2b01      	cmp	r3, #1
 801ed0c:	f040 8134 	bne.w	801ef78 <finsh_compile+0x1008>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
 801ed10:	687b      	ldr	r3, [r7, #4]
 801ed12:	691b      	ldr	r3, [r3, #16]
 801ed14:	689b      	ldr	r3, [r3, #8]
 801ed16:	613b      	str	r3, [r7, #16]

                /* ld_dword &id */
                // finsh_code_byte(FINSH_OP_LD_DWORD);

                switch (node->data_type)
 801ed18:	687b      	ldr	r3, [r7, #4]
 801ed1a:	785b      	ldrb	r3, [r3, #1]
 801ed1c:	2b02      	cmp	r3, #2
 801ed1e:	d063      	beq.n	801ede8 <finsh_compile+0xe78>
 801ed20:	2b03      	cmp	r3, #3
 801ed22:	f000 80c0 	beq.w	801eea6 <finsh_compile+0xf36>
 801ed26:	2b01      	cmp	r3, #1
 801ed28:	d001      	beq.n	801ed2e <finsh_compile+0xdbe>
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);

                    break;
                }
            }
            break;
 801ed2a:	f000 bd00 	b.w	801f72e <finsh_compile+0x17be>
                case FINSH_DATA_TYPE_BYTE:
                    /* address */
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
 801ed2e:	4b2d      	ldr	r3, [pc, #180]	; (801ede4 <finsh_compile+0xe74>)
 801ed30:	681b      	ldr	r3, [r3, #0]
 801ed32:	2225      	movs	r2, #37	; 0x25
 801ed34:	701a      	strb	r2, [r3, #0]
 801ed36:	4b2b      	ldr	r3, [pc, #172]	; (801ede4 <finsh_compile+0xe74>)
 801ed38:	681b      	ldr	r3, [r3, #0]
 801ed3a:	3301      	adds	r3, #1
 801ed3c:	4a29      	ldr	r2, [pc, #164]	; (801ede4 <finsh_compile+0xe74>)
 801ed3e:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.char_value));
 801ed40:	4b28      	ldr	r3, [pc, #160]	; (801ede4 <finsh_compile+0xe74>)
 801ed42:	681b      	ldr	r3, [r3, #0]
 801ed44:	693a      	ldr	r2, [r7, #16]
 801ed46:	3214      	adds	r2, #20
 801ed48:	b2d2      	uxtb	r2, r2
 801ed4a:	701a      	strb	r2, [r3, #0]
 801ed4c:	4b25      	ldr	r3, [pc, #148]	; (801ede4 <finsh_compile+0xe74>)
 801ed4e:	681b      	ldr	r3, [r3, #0]
 801ed50:	3301      	adds	r3, #1
 801ed52:	693a      	ldr	r2, [r7, #16]
 801ed54:	3214      	adds	r2, #20
 801ed56:	0a12      	lsrs	r2, r2, #8
 801ed58:	b2d2      	uxtb	r2, r2
 801ed5a:	701a      	strb	r2, [r3, #0]
 801ed5c:	4b21      	ldr	r3, [pc, #132]	; (801ede4 <finsh_compile+0xe74>)
 801ed5e:	681b      	ldr	r3, [r3, #0]
 801ed60:	3302      	adds	r3, #2
 801ed62:	693a      	ldr	r2, [r7, #16]
 801ed64:	3214      	adds	r2, #20
 801ed66:	0c12      	lsrs	r2, r2, #16
 801ed68:	b2d2      	uxtb	r2, r2
 801ed6a:	701a      	strb	r2, [r3, #0]
 801ed6c:	4b1d      	ldr	r3, [pc, #116]	; (801ede4 <finsh_compile+0xe74>)
 801ed6e:	681b      	ldr	r3, [r3, #0]
 801ed70:	3303      	adds	r3, #3
 801ed72:	693a      	ldr	r2, [r7, #16]
 801ed74:	3214      	adds	r2, #20
 801ed76:	0e12      	lsrs	r2, r2, #24
 801ed78:	b2d2      	uxtb	r2, r2
 801ed7a:	701a      	strb	r2, [r3, #0]
 801ed7c:	4b19      	ldr	r3, [pc, #100]	; (801ede4 <finsh_compile+0xe74>)
 801ed7e:	681b      	ldr	r3, [r3, #0]
 801ed80:	3304      	adds	r3, #4
 801ed82:	4a18      	ldr	r2, [pc, #96]	; (801ede4 <finsh_compile+0xe74>)
 801ed84:	6013      	str	r3, [r2, #0]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
 801ed86:	4b17      	ldr	r3, [pc, #92]	; (801ede4 <finsh_compile+0xe74>)
 801ed88:	681b      	ldr	r3, [r3, #0]
 801ed8a:	2222      	movs	r2, #34	; 0x22
 801ed8c:	701a      	strb	r2, [r3, #0]
 801ed8e:	4b15      	ldr	r3, [pc, #84]	; (801ede4 <finsh_compile+0xe74>)
 801ed90:	681b      	ldr	r3, [r3, #0]
 801ed92:	3301      	adds	r3, #1
 801ed94:	4a13      	ldr	r2, [pc, #76]	; (801ede4 <finsh_compile+0xe74>)
 801ed96:	6013      	str	r3, [r2, #0]
                    finsh_code_byte(1);
 801ed98:	4b12      	ldr	r3, [pc, #72]	; (801ede4 <finsh_compile+0xe74>)
 801ed9a:	681b      	ldr	r3, [r3, #0]
 801ed9c:	2201      	movs	r2, #1
 801ed9e:	701a      	strb	r2, [r3, #0]
 801eda0:	4b10      	ldr	r3, [pc, #64]	; (801ede4 <finsh_compile+0xe74>)
 801eda2:	681b      	ldr	r3, [r3, #0]
 801eda4:	3301      	adds	r3, #1
 801eda6:	4a0f      	ldr	r2, [pc, #60]	; (801ede4 <finsh_compile+0xe74>)
 801eda8:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_BYTE);
 801edaa:	4b0e      	ldr	r3, [pc, #56]	; (801ede4 <finsh_compile+0xe74>)
 801edac:	681b      	ldr	r3, [r3, #0]
 801edae:	2204      	movs	r2, #4
 801edb0:	701a      	strb	r2, [r3, #0]
 801edb2:	4b0c      	ldr	r3, [pc, #48]	; (801ede4 <finsh_compile+0xe74>)
 801edb4:	681b      	ldr	r3, [r3, #0]
 801edb6:	3301      	adds	r3, #1
 801edb8:	4a0a      	ldr	r2, [pc, #40]	; (801ede4 <finsh_compile+0xe74>)
 801edba:	6013      	str	r3, [r2, #0]
                    /* st_byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
 801edbc:	4b09      	ldr	r3, [pc, #36]	; (801ede4 <finsh_compile+0xe74>)
 801edbe:	681b      	ldr	r3, [r3, #0]
 801edc0:	2228      	movs	r2, #40	; 0x28
 801edc2:	701a      	strb	r2, [r3, #0]
 801edc4:	4b07      	ldr	r3, [pc, #28]	; (801ede4 <finsh_compile+0xe74>)
 801edc6:	681b      	ldr	r3, [r3, #0]
 801edc8:	3301      	adds	r3, #1
 801edca:	4a06      	ldr	r2, [pc, #24]	; (801ede4 <finsh_compile+0xe74>)
 801edcc:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801edce:	4b05      	ldr	r3, [pc, #20]	; (801ede4 <finsh_compile+0xe74>)
 801edd0:	681b      	ldr	r3, [r3, #0]
 801edd2:	222f      	movs	r2, #47	; 0x2f
 801edd4:	701a      	strb	r2, [r3, #0]
 801edd6:	4b03      	ldr	r3, [pc, #12]	; (801ede4 <finsh_compile+0xe74>)
 801edd8:	681b      	ldr	r3, [r3, #0]
 801edda:	3301      	adds	r3, #1
 801eddc:	4a01      	ldr	r2, [pc, #4]	; (801ede4 <finsh_compile+0xe74>)
 801edde:	6013      	str	r3, [r2, #0]

                    break;
 801ede0:	e0ca      	b.n	801ef78 <finsh_compile+0x1008>
 801ede2:	bf00      	nop
 801ede4:	20012bb8 	.word	0x20012bb8
                case FINSH_DATA_TYPE_WORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
 801ede8:	4b71      	ldr	r3, [pc, #452]	; (801efb0 <finsh_compile+0x1040>)
 801edea:	681b      	ldr	r3, [r3, #0]
 801edec:	2226      	movs	r2, #38	; 0x26
 801edee:	701a      	strb	r2, [r3, #0]
 801edf0:	4b6f      	ldr	r3, [pc, #444]	; (801efb0 <finsh_compile+0x1040>)
 801edf2:	681b      	ldr	r3, [r3, #0]
 801edf4:	3301      	adds	r3, #1
 801edf6:	4a6e      	ldr	r2, [pc, #440]	; (801efb0 <finsh_compile+0x1040>)
 801edf8:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.short_value));
 801edfa:	4b6d      	ldr	r3, [pc, #436]	; (801efb0 <finsh_compile+0x1040>)
 801edfc:	681b      	ldr	r3, [r3, #0]
 801edfe:	693a      	ldr	r2, [r7, #16]
 801ee00:	3214      	adds	r2, #20
 801ee02:	b2d2      	uxtb	r2, r2
 801ee04:	701a      	strb	r2, [r3, #0]
 801ee06:	4b6a      	ldr	r3, [pc, #424]	; (801efb0 <finsh_compile+0x1040>)
 801ee08:	681b      	ldr	r3, [r3, #0]
 801ee0a:	3301      	adds	r3, #1
 801ee0c:	693a      	ldr	r2, [r7, #16]
 801ee0e:	3214      	adds	r2, #20
 801ee10:	0a12      	lsrs	r2, r2, #8
 801ee12:	b2d2      	uxtb	r2, r2
 801ee14:	701a      	strb	r2, [r3, #0]
 801ee16:	4b66      	ldr	r3, [pc, #408]	; (801efb0 <finsh_compile+0x1040>)
 801ee18:	681b      	ldr	r3, [r3, #0]
 801ee1a:	3302      	adds	r3, #2
 801ee1c:	693a      	ldr	r2, [r7, #16]
 801ee1e:	3214      	adds	r2, #20
 801ee20:	0c12      	lsrs	r2, r2, #16
 801ee22:	b2d2      	uxtb	r2, r2
 801ee24:	701a      	strb	r2, [r3, #0]
 801ee26:	4b62      	ldr	r3, [pc, #392]	; (801efb0 <finsh_compile+0x1040>)
 801ee28:	681b      	ldr	r3, [r3, #0]
 801ee2a:	3303      	adds	r3, #3
 801ee2c:	693a      	ldr	r2, [r7, #16]
 801ee2e:	3214      	adds	r2, #20
 801ee30:	0e12      	lsrs	r2, r2, #24
 801ee32:	b2d2      	uxtb	r2, r2
 801ee34:	701a      	strb	r2, [r3, #0]
 801ee36:	4b5e      	ldr	r3, [pc, #376]	; (801efb0 <finsh_compile+0x1040>)
 801ee38:	681b      	ldr	r3, [r3, #0]
 801ee3a:	3304      	adds	r3, #4
 801ee3c:	4a5c      	ldr	r2, [pc, #368]	; (801efb0 <finsh_compile+0x1040>)
 801ee3e:	6013      	str	r3, [r2, #0]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
 801ee40:	4b5b      	ldr	r3, [pc, #364]	; (801efb0 <finsh_compile+0x1040>)
 801ee42:	681b      	ldr	r3, [r3, #0]
 801ee44:	2223      	movs	r2, #35	; 0x23
 801ee46:	701a      	strb	r2, [r3, #0]
 801ee48:	4b59      	ldr	r3, [pc, #356]	; (801efb0 <finsh_compile+0x1040>)
 801ee4a:	681b      	ldr	r3, [r3, #0]
 801ee4c:	3301      	adds	r3, #1
 801ee4e:	4a58      	ldr	r2, [pc, #352]	; (801efb0 <finsh_compile+0x1040>)
 801ee50:	6013      	str	r3, [r2, #0]
                    finsh_code_word(1);
 801ee52:	4b57      	ldr	r3, [pc, #348]	; (801efb0 <finsh_compile+0x1040>)
 801ee54:	681b      	ldr	r3, [r3, #0]
 801ee56:	2201      	movs	r2, #1
 801ee58:	701a      	strb	r2, [r3, #0]
 801ee5a:	4b55      	ldr	r3, [pc, #340]	; (801efb0 <finsh_compile+0x1040>)
 801ee5c:	681b      	ldr	r3, [r3, #0]
 801ee5e:	3301      	adds	r3, #1
 801ee60:	2200      	movs	r2, #0
 801ee62:	701a      	strb	r2, [r3, #0]
 801ee64:	4b52      	ldr	r3, [pc, #328]	; (801efb0 <finsh_compile+0x1040>)
 801ee66:	681b      	ldr	r3, [r3, #0]
 801ee68:	3302      	adds	r3, #2
 801ee6a:	4a51      	ldr	r2, [pc, #324]	; (801efb0 <finsh_compile+0x1040>)
 801ee6c:	6013      	str	r3, [r2, #0]

                    /* add_word */
                    finsh_code_byte(FINSH_OP_SUB_WORD);
 801ee6e:	4b50      	ldr	r3, [pc, #320]	; (801efb0 <finsh_compile+0x1040>)
 801ee70:	681b      	ldr	r3, [r3, #0]
 801ee72:	2205      	movs	r2, #5
 801ee74:	701a      	strb	r2, [r3, #0]
 801ee76:	4b4e      	ldr	r3, [pc, #312]	; (801efb0 <finsh_compile+0x1040>)
 801ee78:	681b      	ldr	r3, [r3, #0]
 801ee7a:	3301      	adds	r3, #1
 801ee7c:	4a4c      	ldr	r2, [pc, #304]	; (801efb0 <finsh_compile+0x1040>)
 801ee7e:	6013      	str	r3, [r2, #0]
                    /* st_word */
                    finsh_code_byte(FINSH_OP_ST_WORD);
 801ee80:	4b4b      	ldr	r3, [pc, #300]	; (801efb0 <finsh_compile+0x1040>)
 801ee82:	681b      	ldr	r3, [r3, #0]
 801ee84:	2229      	movs	r2, #41	; 0x29
 801ee86:	701a      	strb	r2, [r3, #0]
 801ee88:	4b49      	ldr	r3, [pc, #292]	; (801efb0 <finsh_compile+0x1040>)
 801ee8a:	681b      	ldr	r3, [r3, #0]
 801ee8c:	3301      	adds	r3, #1
 801ee8e:	4a48      	ldr	r2, [pc, #288]	; (801efb0 <finsh_compile+0x1040>)
 801ee90:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801ee92:	4b47      	ldr	r3, [pc, #284]	; (801efb0 <finsh_compile+0x1040>)
 801ee94:	681b      	ldr	r3, [r3, #0]
 801ee96:	222f      	movs	r2, #47	; 0x2f
 801ee98:	701a      	strb	r2, [r3, #0]
 801ee9a:	4b45      	ldr	r3, [pc, #276]	; (801efb0 <finsh_compile+0x1040>)
 801ee9c:	681b      	ldr	r3, [r3, #0]
 801ee9e:	3301      	adds	r3, #1
 801eea0:	4a43      	ldr	r2, [pc, #268]	; (801efb0 <finsh_compile+0x1040>)
 801eea2:	6013      	str	r3, [r2, #0]

                    break;
 801eea4:	e068      	b.n	801ef78 <finsh_compile+0x1008>
                case FINSH_DATA_TYPE_DWORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
 801eea6:	4b42      	ldr	r3, [pc, #264]	; (801efb0 <finsh_compile+0x1040>)
 801eea8:	681b      	ldr	r3, [r3, #0]
 801eeaa:	2227      	movs	r2, #39	; 0x27
 801eeac:	701a      	strb	r2, [r3, #0]
 801eeae:	4b40      	ldr	r3, [pc, #256]	; (801efb0 <finsh_compile+0x1040>)
 801eeb0:	681b      	ldr	r3, [r3, #0]
 801eeb2:	3301      	adds	r3, #1
 801eeb4:	4a3e      	ldr	r2, [pc, #248]	; (801efb0 <finsh_compile+0x1040>)
 801eeb6:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.long_value));
 801eeb8:	4b3d      	ldr	r3, [pc, #244]	; (801efb0 <finsh_compile+0x1040>)
 801eeba:	681b      	ldr	r3, [r3, #0]
 801eebc:	693a      	ldr	r2, [r7, #16]
 801eebe:	3214      	adds	r2, #20
 801eec0:	b2d2      	uxtb	r2, r2
 801eec2:	701a      	strb	r2, [r3, #0]
 801eec4:	4b3a      	ldr	r3, [pc, #232]	; (801efb0 <finsh_compile+0x1040>)
 801eec6:	681b      	ldr	r3, [r3, #0]
 801eec8:	3301      	adds	r3, #1
 801eeca:	693a      	ldr	r2, [r7, #16]
 801eecc:	3214      	adds	r2, #20
 801eece:	0a12      	lsrs	r2, r2, #8
 801eed0:	b2d2      	uxtb	r2, r2
 801eed2:	701a      	strb	r2, [r3, #0]
 801eed4:	4b36      	ldr	r3, [pc, #216]	; (801efb0 <finsh_compile+0x1040>)
 801eed6:	681b      	ldr	r3, [r3, #0]
 801eed8:	3302      	adds	r3, #2
 801eeda:	693a      	ldr	r2, [r7, #16]
 801eedc:	3214      	adds	r2, #20
 801eede:	0c12      	lsrs	r2, r2, #16
 801eee0:	b2d2      	uxtb	r2, r2
 801eee2:	701a      	strb	r2, [r3, #0]
 801eee4:	4b32      	ldr	r3, [pc, #200]	; (801efb0 <finsh_compile+0x1040>)
 801eee6:	681b      	ldr	r3, [r3, #0]
 801eee8:	3303      	adds	r3, #3
 801eeea:	693a      	ldr	r2, [r7, #16]
 801eeec:	3214      	adds	r2, #20
 801eeee:	0e12      	lsrs	r2, r2, #24
 801eef0:	b2d2      	uxtb	r2, r2
 801eef2:	701a      	strb	r2, [r3, #0]
 801eef4:	4b2e      	ldr	r3, [pc, #184]	; (801efb0 <finsh_compile+0x1040>)
 801eef6:	681b      	ldr	r3, [r3, #0]
 801eef8:	3304      	adds	r3, #4
 801eefa:	4a2d      	ldr	r2, [pc, #180]	; (801efb0 <finsh_compile+0x1040>)
 801eefc:	6013      	str	r3, [r2, #0]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801eefe:	4b2c      	ldr	r3, [pc, #176]	; (801efb0 <finsh_compile+0x1040>)
 801ef00:	681b      	ldr	r3, [r3, #0]
 801ef02:	2224      	movs	r2, #36	; 0x24
 801ef04:	701a      	strb	r2, [r3, #0]
 801ef06:	4b2a      	ldr	r3, [pc, #168]	; (801efb0 <finsh_compile+0x1040>)
 801ef08:	681b      	ldr	r3, [r3, #0]
 801ef0a:	3301      	adds	r3, #1
 801ef0c:	4a28      	ldr	r2, [pc, #160]	; (801efb0 <finsh_compile+0x1040>)
 801ef0e:	6013      	str	r3, [r2, #0]
                    finsh_code_dword(1);
 801ef10:	4b27      	ldr	r3, [pc, #156]	; (801efb0 <finsh_compile+0x1040>)
 801ef12:	681b      	ldr	r3, [r3, #0]
 801ef14:	2201      	movs	r2, #1
 801ef16:	701a      	strb	r2, [r3, #0]
 801ef18:	4b25      	ldr	r3, [pc, #148]	; (801efb0 <finsh_compile+0x1040>)
 801ef1a:	681b      	ldr	r3, [r3, #0]
 801ef1c:	3301      	adds	r3, #1
 801ef1e:	2200      	movs	r2, #0
 801ef20:	701a      	strb	r2, [r3, #0]
 801ef22:	4b23      	ldr	r3, [pc, #140]	; (801efb0 <finsh_compile+0x1040>)
 801ef24:	681b      	ldr	r3, [r3, #0]
 801ef26:	3302      	adds	r3, #2
 801ef28:	2200      	movs	r2, #0
 801ef2a:	701a      	strb	r2, [r3, #0]
 801ef2c:	4b20      	ldr	r3, [pc, #128]	; (801efb0 <finsh_compile+0x1040>)
 801ef2e:	681b      	ldr	r3, [r3, #0]
 801ef30:	3303      	adds	r3, #3
 801ef32:	2200      	movs	r2, #0
 801ef34:	701a      	strb	r2, [r3, #0]
 801ef36:	4b1e      	ldr	r3, [pc, #120]	; (801efb0 <finsh_compile+0x1040>)
 801ef38:	681b      	ldr	r3, [r3, #0]
 801ef3a:	3304      	adds	r3, #4
 801ef3c:	4a1c      	ldr	r2, [pc, #112]	; (801efb0 <finsh_compile+0x1040>)
 801ef3e:	6013      	str	r3, [r2, #0]

                    /* add_dword */
                    finsh_code_byte(FINSH_OP_SUB_DWORD);
 801ef40:	4b1b      	ldr	r3, [pc, #108]	; (801efb0 <finsh_compile+0x1040>)
 801ef42:	681b      	ldr	r3, [r3, #0]
 801ef44:	2206      	movs	r2, #6
 801ef46:	701a      	strb	r2, [r3, #0]
 801ef48:	4b19      	ldr	r3, [pc, #100]	; (801efb0 <finsh_compile+0x1040>)
 801ef4a:	681b      	ldr	r3, [r3, #0]
 801ef4c:	3301      	adds	r3, #1
 801ef4e:	4a18      	ldr	r2, [pc, #96]	; (801efb0 <finsh_compile+0x1040>)
 801ef50:	6013      	str	r3, [r2, #0]
                    /* st_dword */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
 801ef52:	4b17      	ldr	r3, [pc, #92]	; (801efb0 <finsh_compile+0x1040>)
 801ef54:	681b      	ldr	r3, [r3, #0]
 801ef56:	222a      	movs	r2, #42	; 0x2a
 801ef58:	701a      	strb	r2, [r3, #0]
 801ef5a:	4b15      	ldr	r3, [pc, #84]	; (801efb0 <finsh_compile+0x1040>)
 801ef5c:	681b      	ldr	r3, [r3, #0]
 801ef5e:	3301      	adds	r3, #1
 801ef60:	4a13      	ldr	r2, [pc, #76]	; (801efb0 <finsh_compile+0x1040>)
 801ef62:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801ef64:	4b12      	ldr	r3, [pc, #72]	; (801efb0 <finsh_compile+0x1040>)
 801ef66:	681b      	ldr	r3, [r3, #0]
 801ef68:	222f      	movs	r2, #47	; 0x2f
 801ef6a:	701a      	strb	r2, [r3, #0]
 801ef6c:	4b10      	ldr	r3, [pc, #64]	; (801efb0 <finsh_compile+0x1040>)
 801ef6e:	681b      	ldr	r3, [r3, #0]
 801ef70:	3301      	adds	r3, #1
 801ef72:	4a0f      	ldr	r2, [pc, #60]	; (801efb0 <finsh_compile+0x1040>)
 801ef74:	6013      	str	r3, [r2, #0]

                    break;
 801ef76:	bf00      	nop
                }
            }
            break;
 801ef78:	e3d9      	b.n	801f72e <finsh_compile+0x17be>

        /* increase */
        case FINSH_NODE_SYS_INC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
 801ef7a:	687b      	ldr	r3, [r7, #4]
 801ef7c:	691b      	ldr	r3, [r3, #16]
 801ef7e:	2b00      	cmp	r3, #0
 801ef80:	f000 81c1 	beq.w	801f306 <finsh_compile+0x1396>
 801ef84:	687b      	ldr	r3, [r7, #4]
 801ef86:	691b      	ldr	r3, [r3, #16]
 801ef88:	781b      	ldrb	r3, [r3, #0]
 801ef8a:	2b01      	cmp	r3, #1
 801ef8c:	f040 81bb 	bne.w	801f306 <finsh_compile+0x1396>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
 801ef90:	687b      	ldr	r3, [r7, #4]
 801ef92:	691b      	ldr	r3, [r3, #16]
 801ef94:	689b      	ldr	r3, [r3, #8]
 801ef96:	60fb      	str	r3, [r7, #12]

                switch (node->data_type)
 801ef98:	687b      	ldr	r3, [r7, #4]
 801ef9a:	785b      	ldrb	r3, [r3, #1]
 801ef9c:	2b02      	cmp	r3, #2
 801ef9e:	f000 808f 	beq.w	801f0c0 <finsh_compile+0x1150>
 801efa2:	2b03      	cmp	r3, #3
 801efa4:	f000 811a 	beq.w	801f1dc <finsh_compile+0x126c>
 801efa8:	2b01      	cmp	r3, #1
 801efaa:	d003      	beq.n	801efb4 <finsh_compile+0x1044>
                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
                    break;
                }
            }
            break;
 801efac:	e3bf      	b.n	801f72e <finsh_compile+0x17be>
 801efae:	bf00      	nop
 801efb0:	20012bb8 	.word	0x20012bb8
                    /* ld_value_byte &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801efb4:	4b88      	ldr	r3, [pc, #544]	; (801f1d8 <finsh_compile+0x1268>)
 801efb6:	681b      	ldr	r3, [r3, #0]
 801efb8:	2224      	movs	r2, #36	; 0x24
 801efba:	701a      	strb	r2, [r3, #0]
 801efbc:	4b86      	ldr	r3, [pc, #536]	; (801f1d8 <finsh_compile+0x1268>)
 801efbe:	681b      	ldr	r3, [r3, #0]
 801efc0:	3301      	adds	r3, #1
 801efc2:	4a85      	ldr	r2, [pc, #532]	; (801f1d8 <finsh_compile+0x1268>)
 801efc4:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.char_value));
 801efc6:	4b84      	ldr	r3, [pc, #528]	; (801f1d8 <finsh_compile+0x1268>)
 801efc8:	681b      	ldr	r3, [r3, #0]
 801efca:	68fa      	ldr	r2, [r7, #12]
 801efcc:	3214      	adds	r2, #20
 801efce:	b2d2      	uxtb	r2, r2
 801efd0:	701a      	strb	r2, [r3, #0]
 801efd2:	4b81      	ldr	r3, [pc, #516]	; (801f1d8 <finsh_compile+0x1268>)
 801efd4:	681b      	ldr	r3, [r3, #0]
 801efd6:	3301      	adds	r3, #1
 801efd8:	68fa      	ldr	r2, [r7, #12]
 801efda:	3214      	adds	r2, #20
 801efdc:	0a12      	lsrs	r2, r2, #8
 801efde:	b2d2      	uxtb	r2, r2
 801efe0:	701a      	strb	r2, [r3, #0]
 801efe2:	4b7d      	ldr	r3, [pc, #500]	; (801f1d8 <finsh_compile+0x1268>)
 801efe4:	681b      	ldr	r3, [r3, #0]
 801efe6:	3302      	adds	r3, #2
 801efe8:	68fa      	ldr	r2, [r7, #12]
 801efea:	3214      	adds	r2, #20
 801efec:	0c12      	lsrs	r2, r2, #16
 801efee:	b2d2      	uxtb	r2, r2
 801eff0:	701a      	strb	r2, [r3, #0]
 801eff2:	4b79      	ldr	r3, [pc, #484]	; (801f1d8 <finsh_compile+0x1268>)
 801eff4:	681b      	ldr	r3, [r3, #0]
 801eff6:	3303      	adds	r3, #3
 801eff8:	68fa      	ldr	r2, [r7, #12]
 801effa:	3214      	adds	r2, #20
 801effc:	0e12      	lsrs	r2, r2, #24
 801effe:	b2d2      	uxtb	r2, r2
 801f000:	701a      	strb	r2, [r3, #0]
 801f002:	4b75      	ldr	r3, [pc, #468]	; (801f1d8 <finsh_compile+0x1268>)
 801f004:	681b      	ldr	r3, [r3, #0]
 801f006:	3304      	adds	r3, #4
 801f008:	4a73      	ldr	r2, [pc, #460]	; (801f1d8 <finsh_compile+0x1268>)
 801f00a:	6013      	str	r3, [r2, #0]

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
 801f00c:	4b72      	ldr	r3, [pc, #456]	; (801f1d8 <finsh_compile+0x1268>)
 801f00e:	681b      	ldr	r3, [r3, #0]
 801f010:	2225      	movs	r2, #37	; 0x25
 801f012:	701a      	strb	r2, [r3, #0]
 801f014:	4b70      	ldr	r3, [pc, #448]	; (801f1d8 <finsh_compile+0x1268>)
 801f016:	681b      	ldr	r3, [r3, #0]
 801f018:	3301      	adds	r3, #1
 801f01a:	4a6f      	ldr	r2, [pc, #444]	; (801f1d8 <finsh_compile+0x1268>)
 801f01c:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.char_value));
 801f01e:	4b6e      	ldr	r3, [pc, #440]	; (801f1d8 <finsh_compile+0x1268>)
 801f020:	681b      	ldr	r3, [r3, #0]
 801f022:	68fa      	ldr	r2, [r7, #12]
 801f024:	3214      	adds	r2, #20
 801f026:	b2d2      	uxtb	r2, r2
 801f028:	701a      	strb	r2, [r3, #0]
 801f02a:	4b6b      	ldr	r3, [pc, #428]	; (801f1d8 <finsh_compile+0x1268>)
 801f02c:	681b      	ldr	r3, [r3, #0]
 801f02e:	3301      	adds	r3, #1
 801f030:	68fa      	ldr	r2, [r7, #12]
 801f032:	3214      	adds	r2, #20
 801f034:	0a12      	lsrs	r2, r2, #8
 801f036:	b2d2      	uxtb	r2, r2
 801f038:	701a      	strb	r2, [r3, #0]
 801f03a:	4b67      	ldr	r3, [pc, #412]	; (801f1d8 <finsh_compile+0x1268>)
 801f03c:	681b      	ldr	r3, [r3, #0]
 801f03e:	3302      	adds	r3, #2
 801f040:	68fa      	ldr	r2, [r7, #12]
 801f042:	3214      	adds	r2, #20
 801f044:	0c12      	lsrs	r2, r2, #16
 801f046:	b2d2      	uxtb	r2, r2
 801f048:	701a      	strb	r2, [r3, #0]
 801f04a:	4b63      	ldr	r3, [pc, #396]	; (801f1d8 <finsh_compile+0x1268>)
 801f04c:	681b      	ldr	r3, [r3, #0]
 801f04e:	3303      	adds	r3, #3
 801f050:	68fa      	ldr	r2, [r7, #12]
 801f052:	3214      	adds	r2, #20
 801f054:	0e12      	lsrs	r2, r2, #24
 801f056:	b2d2      	uxtb	r2, r2
 801f058:	701a      	strb	r2, [r3, #0]
 801f05a:	4b5f      	ldr	r3, [pc, #380]	; (801f1d8 <finsh_compile+0x1268>)
 801f05c:	681b      	ldr	r3, [r3, #0]
 801f05e:	3304      	adds	r3, #4
 801f060:	4a5d      	ldr	r2, [pc, #372]	; (801f1d8 <finsh_compile+0x1268>)
 801f062:	6013      	str	r3, [r2, #0]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
 801f064:	4b5c      	ldr	r3, [pc, #368]	; (801f1d8 <finsh_compile+0x1268>)
 801f066:	681b      	ldr	r3, [r3, #0]
 801f068:	2222      	movs	r2, #34	; 0x22
 801f06a:	701a      	strb	r2, [r3, #0]
 801f06c:	4b5a      	ldr	r3, [pc, #360]	; (801f1d8 <finsh_compile+0x1268>)
 801f06e:	681b      	ldr	r3, [r3, #0]
 801f070:	3301      	adds	r3, #1
 801f072:	4a59      	ldr	r2, [pc, #356]	; (801f1d8 <finsh_compile+0x1268>)
 801f074:	6013      	str	r3, [r2, #0]
                    finsh_code_byte(1);
 801f076:	4b58      	ldr	r3, [pc, #352]	; (801f1d8 <finsh_compile+0x1268>)
 801f078:	681b      	ldr	r3, [r3, #0]
 801f07a:	2201      	movs	r2, #1
 801f07c:	701a      	strb	r2, [r3, #0]
 801f07e:	4b56      	ldr	r3, [pc, #344]	; (801f1d8 <finsh_compile+0x1268>)
 801f080:	681b      	ldr	r3, [r3, #0]
 801f082:	3301      	adds	r3, #1
 801f084:	4a54      	ldr	r2, [pc, #336]	; (801f1d8 <finsh_compile+0x1268>)
 801f086:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_BYTE);
 801f088:	4b53      	ldr	r3, [pc, #332]	; (801f1d8 <finsh_compile+0x1268>)
 801f08a:	681b      	ldr	r3, [r3, #0]
 801f08c:	2201      	movs	r2, #1
 801f08e:	701a      	strb	r2, [r3, #0]
 801f090:	4b51      	ldr	r3, [pc, #324]	; (801f1d8 <finsh_compile+0x1268>)
 801f092:	681b      	ldr	r3, [r3, #0]
 801f094:	3301      	adds	r3, #1
 801f096:	4a50      	ldr	r2, [pc, #320]	; (801f1d8 <finsh_compile+0x1268>)
 801f098:	6013      	str	r3, [r2, #0]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
 801f09a:	4b4f      	ldr	r3, [pc, #316]	; (801f1d8 <finsh_compile+0x1268>)
 801f09c:	681b      	ldr	r3, [r3, #0]
 801f09e:	2228      	movs	r2, #40	; 0x28
 801f0a0:	701a      	strb	r2, [r3, #0]
 801f0a2:	4b4d      	ldr	r3, [pc, #308]	; (801f1d8 <finsh_compile+0x1268>)
 801f0a4:	681b      	ldr	r3, [r3, #0]
 801f0a6:	3301      	adds	r3, #1
 801f0a8:	4a4b      	ldr	r2, [pc, #300]	; (801f1d8 <finsh_compile+0x1268>)
 801f0aa:	6013      	str	r3, [r2, #0]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
 801f0ac:	4b4a      	ldr	r3, [pc, #296]	; (801f1d8 <finsh_compile+0x1268>)
 801f0ae:	681b      	ldr	r3, [r3, #0]
 801f0b0:	222b      	movs	r2, #43	; 0x2b
 801f0b2:	701a      	strb	r2, [r3, #0]
 801f0b4:	4b48      	ldr	r3, [pc, #288]	; (801f1d8 <finsh_compile+0x1268>)
 801f0b6:	681b      	ldr	r3, [r3, #0]
 801f0b8:	3301      	adds	r3, #1
 801f0ba:	4a47      	ldr	r2, [pc, #284]	; (801f1d8 <finsh_compile+0x1268>)
 801f0bc:	6013      	str	r3, [r2, #0]
                    break;
 801f0be:	e122      	b.n	801f306 <finsh_compile+0x1396>
                    /* ld_value_word &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801f0c0:	4b45      	ldr	r3, [pc, #276]	; (801f1d8 <finsh_compile+0x1268>)
 801f0c2:	681b      	ldr	r3, [r3, #0]
 801f0c4:	2224      	movs	r2, #36	; 0x24
 801f0c6:	701a      	strb	r2, [r3, #0]
 801f0c8:	4b43      	ldr	r3, [pc, #268]	; (801f1d8 <finsh_compile+0x1268>)
 801f0ca:	681b      	ldr	r3, [r3, #0]
 801f0cc:	3301      	adds	r3, #1
 801f0ce:	4a42      	ldr	r2, [pc, #264]	; (801f1d8 <finsh_compile+0x1268>)
 801f0d0:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.short_value));
 801f0d2:	4b41      	ldr	r3, [pc, #260]	; (801f1d8 <finsh_compile+0x1268>)
 801f0d4:	681b      	ldr	r3, [r3, #0]
 801f0d6:	68fa      	ldr	r2, [r7, #12]
 801f0d8:	3214      	adds	r2, #20
 801f0da:	b2d2      	uxtb	r2, r2
 801f0dc:	701a      	strb	r2, [r3, #0]
 801f0de:	4b3e      	ldr	r3, [pc, #248]	; (801f1d8 <finsh_compile+0x1268>)
 801f0e0:	681b      	ldr	r3, [r3, #0]
 801f0e2:	3301      	adds	r3, #1
 801f0e4:	68fa      	ldr	r2, [r7, #12]
 801f0e6:	3214      	adds	r2, #20
 801f0e8:	0a12      	lsrs	r2, r2, #8
 801f0ea:	b2d2      	uxtb	r2, r2
 801f0ec:	701a      	strb	r2, [r3, #0]
 801f0ee:	4b3a      	ldr	r3, [pc, #232]	; (801f1d8 <finsh_compile+0x1268>)
 801f0f0:	681b      	ldr	r3, [r3, #0]
 801f0f2:	3302      	adds	r3, #2
 801f0f4:	68fa      	ldr	r2, [r7, #12]
 801f0f6:	3214      	adds	r2, #20
 801f0f8:	0c12      	lsrs	r2, r2, #16
 801f0fa:	b2d2      	uxtb	r2, r2
 801f0fc:	701a      	strb	r2, [r3, #0]
 801f0fe:	4b36      	ldr	r3, [pc, #216]	; (801f1d8 <finsh_compile+0x1268>)
 801f100:	681b      	ldr	r3, [r3, #0]
 801f102:	3303      	adds	r3, #3
 801f104:	68fa      	ldr	r2, [r7, #12]
 801f106:	3214      	adds	r2, #20
 801f108:	0e12      	lsrs	r2, r2, #24
 801f10a:	b2d2      	uxtb	r2, r2
 801f10c:	701a      	strb	r2, [r3, #0]
 801f10e:	4b32      	ldr	r3, [pc, #200]	; (801f1d8 <finsh_compile+0x1268>)
 801f110:	681b      	ldr	r3, [r3, #0]
 801f112:	3304      	adds	r3, #4
 801f114:	4a30      	ldr	r2, [pc, #192]	; (801f1d8 <finsh_compile+0x1268>)
 801f116:	6013      	str	r3, [r2, #0]

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
 801f118:	4b2f      	ldr	r3, [pc, #188]	; (801f1d8 <finsh_compile+0x1268>)
 801f11a:	681b      	ldr	r3, [r3, #0]
 801f11c:	2226      	movs	r2, #38	; 0x26
 801f11e:	701a      	strb	r2, [r3, #0]
 801f120:	4b2d      	ldr	r3, [pc, #180]	; (801f1d8 <finsh_compile+0x1268>)
 801f122:	681b      	ldr	r3, [r3, #0]
 801f124:	3301      	adds	r3, #1
 801f126:	4a2c      	ldr	r2, [pc, #176]	; (801f1d8 <finsh_compile+0x1268>)
 801f128:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.short_value));
 801f12a:	4b2b      	ldr	r3, [pc, #172]	; (801f1d8 <finsh_compile+0x1268>)
 801f12c:	681b      	ldr	r3, [r3, #0]
 801f12e:	68fa      	ldr	r2, [r7, #12]
 801f130:	3214      	adds	r2, #20
 801f132:	b2d2      	uxtb	r2, r2
 801f134:	701a      	strb	r2, [r3, #0]
 801f136:	4b28      	ldr	r3, [pc, #160]	; (801f1d8 <finsh_compile+0x1268>)
 801f138:	681b      	ldr	r3, [r3, #0]
 801f13a:	3301      	adds	r3, #1
 801f13c:	68fa      	ldr	r2, [r7, #12]
 801f13e:	3214      	adds	r2, #20
 801f140:	0a12      	lsrs	r2, r2, #8
 801f142:	b2d2      	uxtb	r2, r2
 801f144:	701a      	strb	r2, [r3, #0]
 801f146:	4b24      	ldr	r3, [pc, #144]	; (801f1d8 <finsh_compile+0x1268>)
 801f148:	681b      	ldr	r3, [r3, #0]
 801f14a:	3302      	adds	r3, #2
 801f14c:	68fa      	ldr	r2, [r7, #12]
 801f14e:	3214      	adds	r2, #20
 801f150:	0c12      	lsrs	r2, r2, #16
 801f152:	b2d2      	uxtb	r2, r2
 801f154:	701a      	strb	r2, [r3, #0]
 801f156:	4b20      	ldr	r3, [pc, #128]	; (801f1d8 <finsh_compile+0x1268>)
 801f158:	681b      	ldr	r3, [r3, #0]
 801f15a:	3303      	adds	r3, #3
 801f15c:	68fa      	ldr	r2, [r7, #12]
 801f15e:	3214      	adds	r2, #20
 801f160:	0e12      	lsrs	r2, r2, #24
 801f162:	b2d2      	uxtb	r2, r2
 801f164:	701a      	strb	r2, [r3, #0]
 801f166:	4b1c      	ldr	r3, [pc, #112]	; (801f1d8 <finsh_compile+0x1268>)
 801f168:	681b      	ldr	r3, [r3, #0]
 801f16a:	3304      	adds	r3, #4
 801f16c:	4a1a      	ldr	r2, [pc, #104]	; (801f1d8 <finsh_compile+0x1268>)
 801f16e:	6013      	str	r3, [r2, #0]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
 801f170:	4b19      	ldr	r3, [pc, #100]	; (801f1d8 <finsh_compile+0x1268>)
 801f172:	681b      	ldr	r3, [r3, #0]
 801f174:	2223      	movs	r2, #35	; 0x23
 801f176:	701a      	strb	r2, [r3, #0]
 801f178:	4b17      	ldr	r3, [pc, #92]	; (801f1d8 <finsh_compile+0x1268>)
 801f17a:	681b      	ldr	r3, [r3, #0]
 801f17c:	3301      	adds	r3, #1
 801f17e:	4a16      	ldr	r2, [pc, #88]	; (801f1d8 <finsh_compile+0x1268>)
 801f180:	6013      	str	r3, [r2, #0]
                    finsh_code_word(1);
 801f182:	4b15      	ldr	r3, [pc, #84]	; (801f1d8 <finsh_compile+0x1268>)
 801f184:	681b      	ldr	r3, [r3, #0]
 801f186:	2201      	movs	r2, #1
 801f188:	701a      	strb	r2, [r3, #0]
 801f18a:	4b13      	ldr	r3, [pc, #76]	; (801f1d8 <finsh_compile+0x1268>)
 801f18c:	681b      	ldr	r3, [r3, #0]
 801f18e:	3301      	adds	r3, #1
 801f190:	2200      	movs	r2, #0
 801f192:	701a      	strb	r2, [r3, #0]
 801f194:	4b10      	ldr	r3, [pc, #64]	; (801f1d8 <finsh_compile+0x1268>)
 801f196:	681b      	ldr	r3, [r3, #0]
 801f198:	3302      	adds	r3, #2
 801f19a:	4a0f      	ldr	r2, [pc, #60]	; (801f1d8 <finsh_compile+0x1268>)
 801f19c:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_WORD);
 801f19e:	4b0e      	ldr	r3, [pc, #56]	; (801f1d8 <finsh_compile+0x1268>)
 801f1a0:	681b      	ldr	r3, [r3, #0]
 801f1a2:	2202      	movs	r2, #2
 801f1a4:	701a      	strb	r2, [r3, #0]
 801f1a6:	4b0c      	ldr	r3, [pc, #48]	; (801f1d8 <finsh_compile+0x1268>)
 801f1a8:	681b      	ldr	r3, [r3, #0]
 801f1aa:	3301      	adds	r3, #1
 801f1ac:	4a0a      	ldr	r2, [pc, #40]	; (801f1d8 <finsh_compile+0x1268>)
 801f1ae:	6013      	str	r3, [r2, #0]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_WORD);
 801f1b0:	4b09      	ldr	r3, [pc, #36]	; (801f1d8 <finsh_compile+0x1268>)
 801f1b2:	681b      	ldr	r3, [r3, #0]
 801f1b4:	2229      	movs	r2, #41	; 0x29
 801f1b6:	701a      	strb	r2, [r3, #0]
 801f1b8:	4b07      	ldr	r3, [pc, #28]	; (801f1d8 <finsh_compile+0x1268>)
 801f1ba:	681b      	ldr	r3, [r3, #0]
 801f1bc:	3301      	adds	r3, #1
 801f1be:	4a06      	ldr	r2, [pc, #24]	; (801f1d8 <finsh_compile+0x1268>)
 801f1c0:	6013      	str	r3, [r2, #0]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
 801f1c2:	4b05      	ldr	r3, [pc, #20]	; (801f1d8 <finsh_compile+0x1268>)
 801f1c4:	681b      	ldr	r3, [r3, #0]
 801f1c6:	222b      	movs	r2, #43	; 0x2b
 801f1c8:	701a      	strb	r2, [r3, #0]
 801f1ca:	4b03      	ldr	r3, [pc, #12]	; (801f1d8 <finsh_compile+0x1268>)
 801f1cc:	681b      	ldr	r3, [r3, #0]
 801f1ce:	3301      	adds	r3, #1
 801f1d0:	4a01      	ldr	r2, [pc, #4]	; (801f1d8 <finsh_compile+0x1268>)
 801f1d2:	6013      	str	r3, [r2, #0]
                    break;
 801f1d4:	e097      	b.n	801f306 <finsh_compile+0x1396>
 801f1d6:	bf00      	nop
 801f1d8:	20012bb8 	.word	0x20012bb8
                    /* ld_value_dword &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801f1dc:	4b9a      	ldr	r3, [pc, #616]	; (801f448 <finsh_compile+0x14d8>)
 801f1de:	681b      	ldr	r3, [r3, #0]
 801f1e0:	2224      	movs	r2, #36	; 0x24
 801f1e2:	701a      	strb	r2, [r3, #0]
 801f1e4:	4b98      	ldr	r3, [pc, #608]	; (801f448 <finsh_compile+0x14d8>)
 801f1e6:	681b      	ldr	r3, [r3, #0]
 801f1e8:	3301      	adds	r3, #1
 801f1ea:	4a97      	ldr	r2, [pc, #604]	; (801f448 <finsh_compile+0x14d8>)
 801f1ec:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.long_value));
 801f1ee:	4b96      	ldr	r3, [pc, #600]	; (801f448 <finsh_compile+0x14d8>)
 801f1f0:	681b      	ldr	r3, [r3, #0]
 801f1f2:	68fa      	ldr	r2, [r7, #12]
 801f1f4:	3214      	adds	r2, #20
 801f1f6:	b2d2      	uxtb	r2, r2
 801f1f8:	701a      	strb	r2, [r3, #0]
 801f1fa:	4b93      	ldr	r3, [pc, #588]	; (801f448 <finsh_compile+0x14d8>)
 801f1fc:	681b      	ldr	r3, [r3, #0]
 801f1fe:	3301      	adds	r3, #1
 801f200:	68fa      	ldr	r2, [r7, #12]
 801f202:	3214      	adds	r2, #20
 801f204:	0a12      	lsrs	r2, r2, #8
 801f206:	b2d2      	uxtb	r2, r2
 801f208:	701a      	strb	r2, [r3, #0]
 801f20a:	4b8f      	ldr	r3, [pc, #572]	; (801f448 <finsh_compile+0x14d8>)
 801f20c:	681b      	ldr	r3, [r3, #0]
 801f20e:	3302      	adds	r3, #2
 801f210:	68fa      	ldr	r2, [r7, #12]
 801f212:	3214      	adds	r2, #20
 801f214:	0c12      	lsrs	r2, r2, #16
 801f216:	b2d2      	uxtb	r2, r2
 801f218:	701a      	strb	r2, [r3, #0]
 801f21a:	4b8b      	ldr	r3, [pc, #556]	; (801f448 <finsh_compile+0x14d8>)
 801f21c:	681b      	ldr	r3, [r3, #0]
 801f21e:	3303      	adds	r3, #3
 801f220:	68fa      	ldr	r2, [r7, #12]
 801f222:	3214      	adds	r2, #20
 801f224:	0e12      	lsrs	r2, r2, #24
 801f226:	b2d2      	uxtb	r2, r2
 801f228:	701a      	strb	r2, [r3, #0]
 801f22a:	4b87      	ldr	r3, [pc, #540]	; (801f448 <finsh_compile+0x14d8>)
 801f22c:	681b      	ldr	r3, [r3, #0]
 801f22e:	3304      	adds	r3, #4
 801f230:	4a85      	ldr	r2, [pc, #532]	; (801f448 <finsh_compile+0x14d8>)
 801f232:	6013      	str	r3, [r2, #0]

                    /* ld_value_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
 801f234:	4b84      	ldr	r3, [pc, #528]	; (801f448 <finsh_compile+0x14d8>)
 801f236:	681b      	ldr	r3, [r3, #0]
 801f238:	2227      	movs	r2, #39	; 0x27
 801f23a:	701a      	strb	r2, [r3, #0]
 801f23c:	4b82      	ldr	r3, [pc, #520]	; (801f448 <finsh_compile+0x14d8>)
 801f23e:	681b      	ldr	r3, [r3, #0]
 801f240:	3301      	adds	r3, #1
 801f242:	4a81      	ldr	r2, [pc, #516]	; (801f448 <finsh_compile+0x14d8>)
 801f244:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.long_value));
 801f246:	4b80      	ldr	r3, [pc, #512]	; (801f448 <finsh_compile+0x14d8>)
 801f248:	681b      	ldr	r3, [r3, #0]
 801f24a:	68fa      	ldr	r2, [r7, #12]
 801f24c:	3214      	adds	r2, #20
 801f24e:	b2d2      	uxtb	r2, r2
 801f250:	701a      	strb	r2, [r3, #0]
 801f252:	4b7d      	ldr	r3, [pc, #500]	; (801f448 <finsh_compile+0x14d8>)
 801f254:	681b      	ldr	r3, [r3, #0]
 801f256:	3301      	adds	r3, #1
 801f258:	68fa      	ldr	r2, [r7, #12]
 801f25a:	3214      	adds	r2, #20
 801f25c:	0a12      	lsrs	r2, r2, #8
 801f25e:	b2d2      	uxtb	r2, r2
 801f260:	701a      	strb	r2, [r3, #0]
 801f262:	4b79      	ldr	r3, [pc, #484]	; (801f448 <finsh_compile+0x14d8>)
 801f264:	681b      	ldr	r3, [r3, #0]
 801f266:	3302      	adds	r3, #2
 801f268:	68fa      	ldr	r2, [r7, #12]
 801f26a:	3214      	adds	r2, #20
 801f26c:	0c12      	lsrs	r2, r2, #16
 801f26e:	b2d2      	uxtb	r2, r2
 801f270:	701a      	strb	r2, [r3, #0]
 801f272:	4b75      	ldr	r3, [pc, #468]	; (801f448 <finsh_compile+0x14d8>)
 801f274:	681b      	ldr	r3, [r3, #0]
 801f276:	3303      	adds	r3, #3
 801f278:	68fa      	ldr	r2, [r7, #12]
 801f27a:	3214      	adds	r2, #20
 801f27c:	0e12      	lsrs	r2, r2, #24
 801f27e:	b2d2      	uxtb	r2, r2
 801f280:	701a      	strb	r2, [r3, #0]
 801f282:	4b71      	ldr	r3, [pc, #452]	; (801f448 <finsh_compile+0x14d8>)
 801f284:	681b      	ldr	r3, [r3, #0]
 801f286:	3304      	adds	r3, #4
 801f288:	4a6f      	ldr	r2, [pc, #444]	; (801f448 <finsh_compile+0x14d8>)
 801f28a:	6013      	str	r3, [r2, #0]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801f28c:	4b6e      	ldr	r3, [pc, #440]	; (801f448 <finsh_compile+0x14d8>)
 801f28e:	681b      	ldr	r3, [r3, #0]
 801f290:	2224      	movs	r2, #36	; 0x24
 801f292:	701a      	strb	r2, [r3, #0]
 801f294:	4b6c      	ldr	r3, [pc, #432]	; (801f448 <finsh_compile+0x14d8>)
 801f296:	681b      	ldr	r3, [r3, #0]
 801f298:	3301      	adds	r3, #1
 801f29a:	4a6b      	ldr	r2, [pc, #428]	; (801f448 <finsh_compile+0x14d8>)
 801f29c:	6013      	str	r3, [r2, #0]
                    finsh_code_dword(1);
 801f29e:	4b6a      	ldr	r3, [pc, #424]	; (801f448 <finsh_compile+0x14d8>)
 801f2a0:	681b      	ldr	r3, [r3, #0]
 801f2a2:	2201      	movs	r2, #1
 801f2a4:	701a      	strb	r2, [r3, #0]
 801f2a6:	4b68      	ldr	r3, [pc, #416]	; (801f448 <finsh_compile+0x14d8>)
 801f2a8:	681b      	ldr	r3, [r3, #0]
 801f2aa:	3301      	adds	r3, #1
 801f2ac:	2200      	movs	r2, #0
 801f2ae:	701a      	strb	r2, [r3, #0]
 801f2b0:	4b65      	ldr	r3, [pc, #404]	; (801f448 <finsh_compile+0x14d8>)
 801f2b2:	681b      	ldr	r3, [r3, #0]
 801f2b4:	3302      	adds	r3, #2
 801f2b6:	2200      	movs	r2, #0
 801f2b8:	701a      	strb	r2, [r3, #0]
 801f2ba:	4b63      	ldr	r3, [pc, #396]	; (801f448 <finsh_compile+0x14d8>)
 801f2bc:	681b      	ldr	r3, [r3, #0]
 801f2be:	3303      	adds	r3, #3
 801f2c0:	2200      	movs	r2, #0
 801f2c2:	701a      	strb	r2, [r3, #0]
 801f2c4:	4b60      	ldr	r3, [pc, #384]	; (801f448 <finsh_compile+0x14d8>)
 801f2c6:	681b      	ldr	r3, [r3, #0]
 801f2c8:	3304      	adds	r3, #4
 801f2ca:	4a5f      	ldr	r2, [pc, #380]	; (801f448 <finsh_compile+0x14d8>)
 801f2cc:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_DWORD);
 801f2ce:	4b5e      	ldr	r3, [pc, #376]	; (801f448 <finsh_compile+0x14d8>)
 801f2d0:	681b      	ldr	r3, [r3, #0]
 801f2d2:	2203      	movs	r2, #3
 801f2d4:	701a      	strb	r2, [r3, #0]
 801f2d6:	4b5c      	ldr	r3, [pc, #368]	; (801f448 <finsh_compile+0x14d8>)
 801f2d8:	681b      	ldr	r3, [r3, #0]
 801f2da:	3301      	adds	r3, #1
 801f2dc:	4a5a      	ldr	r2, [pc, #360]	; (801f448 <finsh_compile+0x14d8>)
 801f2de:	6013      	str	r3, [r2, #0]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
 801f2e0:	4b59      	ldr	r3, [pc, #356]	; (801f448 <finsh_compile+0x14d8>)
 801f2e2:	681b      	ldr	r3, [r3, #0]
 801f2e4:	222a      	movs	r2, #42	; 0x2a
 801f2e6:	701a      	strb	r2, [r3, #0]
 801f2e8:	4b57      	ldr	r3, [pc, #348]	; (801f448 <finsh_compile+0x14d8>)
 801f2ea:	681b      	ldr	r3, [r3, #0]
 801f2ec:	3301      	adds	r3, #1
 801f2ee:	4a56      	ldr	r2, [pc, #344]	; (801f448 <finsh_compile+0x14d8>)
 801f2f0:	6013      	str	r3, [r2, #0]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
 801f2f2:	4b55      	ldr	r3, [pc, #340]	; (801f448 <finsh_compile+0x14d8>)
 801f2f4:	681b      	ldr	r3, [r3, #0]
 801f2f6:	222b      	movs	r2, #43	; 0x2b
 801f2f8:	701a      	strb	r2, [r3, #0]
 801f2fa:	4b53      	ldr	r3, [pc, #332]	; (801f448 <finsh_compile+0x14d8>)
 801f2fc:	681b      	ldr	r3, [r3, #0]
 801f2fe:	3301      	adds	r3, #1
 801f300:	4a51      	ldr	r2, [pc, #324]	; (801f448 <finsh_compile+0x14d8>)
 801f302:	6013      	str	r3, [r2, #0]
                    break;
 801f304:	bf00      	nop
                }
            }
            break;
 801f306:	e212      	b.n	801f72e <finsh_compile+0x17be>

        /* decrease */
        case FINSH_NODE_SYS_DEC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
 801f308:	687b      	ldr	r3, [r7, #4]
 801f30a:	691b      	ldr	r3, [r3, #16]
 801f30c:	2b00      	cmp	r3, #0
 801f30e:	f000 81bd 	beq.w	801f68c <finsh_compile+0x171c>
 801f312:	687b      	ldr	r3, [r7, #4]
 801f314:	691b      	ldr	r3, [r3, #16]
 801f316:	781b      	ldrb	r3, [r3, #0]
 801f318:	2b01      	cmp	r3, #1
 801f31a:	f040 81b7 	bne.w	801f68c <finsh_compile+0x171c>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
 801f31e:	687b      	ldr	r3, [r7, #4]
 801f320:	691b      	ldr	r3, [r3, #16]
 801f322:	689b      	ldr	r3, [r3, #8]
 801f324:	60bb      	str	r3, [r7, #8]

                switch (node->data_type)
 801f326:	687b      	ldr	r3, [r7, #4]
 801f328:	785b      	ldrb	r3, [r3, #1]
 801f32a:	2b02      	cmp	r3, #2
 801f32c:	f000 808e 	beq.w	801f44c <finsh_compile+0x14dc>
 801f330:	2b03      	cmp	r3, #3
 801f332:	f000 8116 	beq.w	801f562 <finsh_compile+0x15f2>
 801f336:	2b01      	cmp	r3, #1
 801f338:	d000      	beq.n	801f33c <finsh_compile+0x13cc>
                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
                    break;
                }
            }
            break;
 801f33a:	e1f8      	b.n	801f72e <finsh_compile+0x17be>
                    /* ld_value_byte &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801f33c:	4b42      	ldr	r3, [pc, #264]	; (801f448 <finsh_compile+0x14d8>)
 801f33e:	681b      	ldr	r3, [r3, #0]
 801f340:	2224      	movs	r2, #36	; 0x24
 801f342:	701a      	strb	r2, [r3, #0]
 801f344:	4b40      	ldr	r3, [pc, #256]	; (801f448 <finsh_compile+0x14d8>)
 801f346:	681b      	ldr	r3, [r3, #0]
 801f348:	3301      	adds	r3, #1
 801f34a:	4a3f      	ldr	r2, [pc, #252]	; (801f448 <finsh_compile+0x14d8>)
 801f34c:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.char_value));
 801f34e:	4b3e      	ldr	r3, [pc, #248]	; (801f448 <finsh_compile+0x14d8>)
 801f350:	681b      	ldr	r3, [r3, #0]
 801f352:	68ba      	ldr	r2, [r7, #8]
 801f354:	3214      	adds	r2, #20
 801f356:	b2d2      	uxtb	r2, r2
 801f358:	701a      	strb	r2, [r3, #0]
 801f35a:	4b3b      	ldr	r3, [pc, #236]	; (801f448 <finsh_compile+0x14d8>)
 801f35c:	681b      	ldr	r3, [r3, #0]
 801f35e:	3301      	adds	r3, #1
 801f360:	68ba      	ldr	r2, [r7, #8]
 801f362:	3214      	adds	r2, #20
 801f364:	0a12      	lsrs	r2, r2, #8
 801f366:	b2d2      	uxtb	r2, r2
 801f368:	701a      	strb	r2, [r3, #0]
 801f36a:	4b37      	ldr	r3, [pc, #220]	; (801f448 <finsh_compile+0x14d8>)
 801f36c:	681b      	ldr	r3, [r3, #0]
 801f36e:	3302      	adds	r3, #2
 801f370:	68ba      	ldr	r2, [r7, #8]
 801f372:	3214      	adds	r2, #20
 801f374:	0c12      	lsrs	r2, r2, #16
 801f376:	b2d2      	uxtb	r2, r2
 801f378:	701a      	strb	r2, [r3, #0]
 801f37a:	4b33      	ldr	r3, [pc, #204]	; (801f448 <finsh_compile+0x14d8>)
 801f37c:	681b      	ldr	r3, [r3, #0]
 801f37e:	3303      	adds	r3, #3
 801f380:	68ba      	ldr	r2, [r7, #8]
 801f382:	3214      	adds	r2, #20
 801f384:	0e12      	lsrs	r2, r2, #24
 801f386:	b2d2      	uxtb	r2, r2
 801f388:	701a      	strb	r2, [r3, #0]
 801f38a:	4b2f      	ldr	r3, [pc, #188]	; (801f448 <finsh_compile+0x14d8>)
 801f38c:	681b      	ldr	r3, [r3, #0]
 801f38e:	3304      	adds	r3, #4
 801f390:	4a2d      	ldr	r2, [pc, #180]	; (801f448 <finsh_compile+0x14d8>)
 801f392:	6013      	str	r3, [r2, #0]

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
 801f394:	4b2c      	ldr	r3, [pc, #176]	; (801f448 <finsh_compile+0x14d8>)
 801f396:	681b      	ldr	r3, [r3, #0]
 801f398:	2225      	movs	r2, #37	; 0x25
 801f39a:	701a      	strb	r2, [r3, #0]
 801f39c:	4b2a      	ldr	r3, [pc, #168]	; (801f448 <finsh_compile+0x14d8>)
 801f39e:	681b      	ldr	r3, [r3, #0]
 801f3a0:	3301      	adds	r3, #1
 801f3a2:	4a29      	ldr	r2, [pc, #164]	; (801f448 <finsh_compile+0x14d8>)
 801f3a4:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.char_value));
 801f3a6:	4b28      	ldr	r3, [pc, #160]	; (801f448 <finsh_compile+0x14d8>)
 801f3a8:	681b      	ldr	r3, [r3, #0]
 801f3aa:	68ba      	ldr	r2, [r7, #8]
 801f3ac:	3214      	adds	r2, #20
 801f3ae:	b2d2      	uxtb	r2, r2
 801f3b0:	701a      	strb	r2, [r3, #0]
 801f3b2:	4b25      	ldr	r3, [pc, #148]	; (801f448 <finsh_compile+0x14d8>)
 801f3b4:	681b      	ldr	r3, [r3, #0]
 801f3b6:	3301      	adds	r3, #1
 801f3b8:	68ba      	ldr	r2, [r7, #8]
 801f3ba:	3214      	adds	r2, #20
 801f3bc:	0a12      	lsrs	r2, r2, #8
 801f3be:	b2d2      	uxtb	r2, r2
 801f3c0:	701a      	strb	r2, [r3, #0]
 801f3c2:	4b21      	ldr	r3, [pc, #132]	; (801f448 <finsh_compile+0x14d8>)
 801f3c4:	681b      	ldr	r3, [r3, #0]
 801f3c6:	3302      	adds	r3, #2
 801f3c8:	68ba      	ldr	r2, [r7, #8]
 801f3ca:	3214      	adds	r2, #20
 801f3cc:	0c12      	lsrs	r2, r2, #16
 801f3ce:	b2d2      	uxtb	r2, r2
 801f3d0:	701a      	strb	r2, [r3, #0]
 801f3d2:	4b1d      	ldr	r3, [pc, #116]	; (801f448 <finsh_compile+0x14d8>)
 801f3d4:	681b      	ldr	r3, [r3, #0]
 801f3d6:	3303      	adds	r3, #3
 801f3d8:	68ba      	ldr	r2, [r7, #8]
 801f3da:	3214      	adds	r2, #20
 801f3dc:	0e12      	lsrs	r2, r2, #24
 801f3de:	b2d2      	uxtb	r2, r2
 801f3e0:	701a      	strb	r2, [r3, #0]
 801f3e2:	4b19      	ldr	r3, [pc, #100]	; (801f448 <finsh_compile+0x14d8>)
 801f3e4:	681b      	ldr	r3, [r3, #0]
 801f3e6:	3304      	adds	r3, #4
 801f3e8:	4a17      	ldr	r2, [pc, #92]	; (801f448 <finsh_compile+0x14d8>)
 801f3ea:	6013      	str	r3, [r2, #0]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
 801f3ec:	4b16      	ldr	r3, [pc, #88]	; (801f448 <finsh_compile+0x14d8>)
 801f3ee:	681b      	ldr	r3, [r3, #0]
 801f3f0:	2222      	movs	r2, #34	; 0x22
 801f3f2:	701a      	strb	r2, [r3, #0]
 801f3f4:	4b14      	ldr	r3, [pc, #80]	; (801f448 <finsh_compile+0x14d8>)
 801f3f6:	681b      	ldr	r3, [r3, #0]
 801f3f8:	3301      	adds	r3, #1
 801f3fa:	4a13      	ldr	r2, [pc, #76]	; (801f448 <finsh_compile+0x14d8>)
 801f3fc:	6013      	str	r3, [r2, #0]
                    finsh_code_byte(1);
 801f3fe:	4b12      	ldr	r3, [pc, #72]	; (801f448 <finsh_compile+0x14d8>)
 801f400:	681b      	ldr	r3, [r3, #0]
 801f402:	2201      	movs	r2, #1
 801f404:	701a      	strb	r2, [r3, #0]
 801f406:	4b10      	ldr	r3, [pc, #64]	; (801f448 <finsh_compile+0x14d8>)
 801f408:	681b      	ldr	r3, [r3, #0]
 801f40a:	3301      	adds	r3, #1
 801f40c:	4a0e      	ldr	r2, [pc, #56]	; (801f448 <finsh_compile+0x14d8>)
 801f40e:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_BYTE);
 801f410:	4b0d      	ldr	r3, [pc, #52]	; (801f448 <finsh_compile+0x14d8>)
 801f412:	681b      	ldr	r3, [r3, #0]
 801f414:	2204      	movs	r2, #4
 801f416:	701a      	strb	r2, [r3, #0]
 801f418:	4b0b      	ldr	r3, [pc, #44]	; (801f448 <finsh_compile+0x14d8>)
 801f41a:	681b      	ldr	r3, [r3, #0]
 801f41c:	3301      	adds	r3, #1
 801f41e:	4a0a      	ldr	r2, [pc, #40]	; (801f448 <finsh_compile+0x14d8>)
 801f420:	6013      	str	r3, [r2, #0]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
 801f422:	4b09      	ldr	r3, [pc, #36]	; (801f448 <finsh_compile+0x14d8>)
 801f424:	681b      	ldr	r3, [r3, #0]
 801f426:	2228      	movs	r2, #40	; 0x28
 801f428:	701a      	strb	r2, [r3, #0]
 801f42a:	4b07      	ldr	r3, [pc, #28]	; (801f448 <finsh_compile+0x14d8>)
 801f42c:	681b      	ldr	r3, [r3, #0]
 801f42e:	3301      	adds	r3, #1
 801f430:	4a05      	ldr	r2, [pc, #20]	; (801f448 <finsh_compile+0x14d8>)
 801f432:	6013      	str	r3, [r2, #0]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
 801f434:	4b04      	ldr	r3, [pc, #16]	; (801f448 <finsh_compile+0x14d8>)
 801f436:	681b      	ldr	r3, [r3, #0]
 801f438:	222b      	movs	r2, #43	; 0x2b
 801f43a:	701a      	strb	r2, [r3, #0]
 801f43c:	4b02      	ldr	r3, [pc, #8]	; (801f448 <finsh_compile+0x14d8>)
 801f43e:	681b      	ldr	r3, [r3, #0]
 801f440:	3301      	adds	r3, #1
 801f442:	4a01      	ldr	r2, [pc, #4]	; (801f448 <finsh_compile+0x14d8>)
 801f444:	6013      	str	r3, [r2, #0]
                    break;
 801f446:	e121      	b.n	801f68c <finsh_compile+0x171c>
 801f448:	20012bb8 	.word	0x20012bb8
                    /* ld_value_word &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801f44c:	4b9c      	ldr	r3, [pc, #624]	; (801f6c0 <finsh_compile+0x1750>)
 801f44e:	681b      	ldr	r3, [r3, #0]
 801f450:	2224      	movs	r2, #36	; 0x24
 801f452:	701a      	strb	r2, [r3, #0]
 801f454:	4b9a      	ldr	r3, [pc, #616]	; (801f6c0 <finsh_compile+0x1750>)
 801f456:	681b      	ldr	r3, [r3, #0]
 801f458:	3301      	adds	r3, #1
 801f45a:	4a99      	ldr	r2, [pc, #612]	; (801f6c0 <finsh_compile+0x1750>)
 801f45c:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.short_value));
 801f45e:	4b98      	ldr	r3, [pc, #608]	; (801f6c0 <finsh_compile+0x1750>)
 801f460:	681b      	ldr	r3, [r3, #0]
 801f462:	68ba      	ldr	r2, [r7, #8]
 801f464:	3214      	adds	r2, #20
 801f466:	b2d2      	uxtb	r2, r2
 801f468:	701a      	strb	r2, [r3, #0]
 801f46a:	4b95      	ldr	r3, [pc, #596]	; (801f6c0 <finsh_compile+0x1750>)
 801f46c:	681b      	ldr	r3, [r3, #0]
 801f46e:	3301      	adds	r3, #1
 801f470:	68ba      	ldr	r2, [r7, #8]
 801f472:	3214      	adds	r2, #20
 801f474:	0a12      	lsrs	r2, r2, #8
 801f476:	b2d2      	uxtb	r2, r2
 801f478:	701a      	strb	r2, [r3, #0]
 801f47a:	4b91      	ldr	r3, [pc, #580]	; (801f6c0 <finsh_compile+0x1750>)
 801f47c:	681b      	ldr	r3, [r3, #0]
 801f47e:	3302      	adds	r3, #2
 801f480:	68ba      	ldr	r2, [r7, #8]
 801f482:	3214      	adds	r2, #20
 801f484:	0c12      	lsrs	r2, r2, #16
 801f486:	b2d2      	uxtb	r2, r2
 801f488:	701a      	strb	r2, [r3, #0]
 801f48a:	4b8d      	ldr	r3, [pc, #564]	; (801f6c0 <finsh_compile+0x1750>)
 801f48c:	681b      	ldr	r3, [r3, #0]
 801f48e:	3303      	adds	r3, #3
 801f490:	68ba      	ldr	r2, [r7, #8]
 801f492:	3214      	adds	r2, #20
 801f494:	0e12      	lsrs	r2, r2, #24
 801f496:	b2d2      	uxtb	r2, r2
 801f498:	701a      	strb	r2, [r3, #0]
 801f49a:	4b89      	ldr	r3, [pc, #548]	; (801f6c0 <finsh_compile+0x1750>)
 801f49c:	681b      	ldr	r3, [r3, #0]
 801f49e:	3304      	adds	r3, #4
 801f4a0:	4a87      	ldr	r2, [pc, #540]	; (801f6c0 <finsh_compile+0x1750>)
 801f4a2:	6013      	str	r3, [r2, #0]

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
 801f4a4:	4b86      	ldr	r3, [pc, #536]	; (801f6c0 <finsh_compile+0x1750>)
 801f4a6:	681b      	ldr	r3, [r3, #0]
 801f4a8:	2226      	movs	r2, #38	; 0x26
 801f4aa:	701a      	strb	r2, [r3, #0]
 801f4ac:	4b84      	ldr	r3, [pc, #528]	; (801f6c0 <finsh_compile+0x1750>)
 801f4ae:	681b      	ldr	r3, [r3, #0]
 801f4b0:	3301      	adds	r3, #1
 801f4b2:	4a83      	ldr	r2, [pc, #524]	; (801f6c0 <finsh_compile+0x1750>)
 801f4b4:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.short_value));
 801f4b6:	4b82      	ldr	r3, [pc, #520]	; (801f6c0 <finsh_compile+0x1750>)
 801f4b8:	681b      	ldr	r3, [r3, #0]
 801f4ba:	68ba      	ldr	r2, [r7, #8]
 801f4bc:	3214      	adds	r2, #20
 801f4be:	b2d2      	uxtb	r2, r2
 801f4c0:	701a      	strb	r2, [r3, #0]
 801f4c2:	4b7f      	ldr	r3, [pc, #508]	; (801f6c0 <finsh_compile+0x1750>)
 801f4c4:	681b      	ldr	r3, [r3, #0]
 801f4c6:	3301      	adds	r3, #1
 801f4c8:	68ba      	ldr	r2, [r7, #8]
 801f4ca:	3214      	adds	r2, #20
 801f4cc:	0a12      	lsrs	r2, r2, #8
 801f4ce:	b2d2      	uxtb	r2, r2
 801f4d0:	701a      	strb	r2, [r3, #0]
 801f4d2:	4b7b      	ldr	r3, [pc, #492]	; (801f6c0 <finsh_compile+0x1750>)
 801f4d4:	681b      	ldr	r3, [r3, #0]
 801f4d6:	3302      	adds	r3, #2
 801f4d8:	68ba      	ldr	r2, [r7, #8]
 801f4da:	3214      	adds	r2, #20
 801f4dc:	0c12      	lsrs	r2, r2, #16
 801f4de:	b2d2      	uxtb	r2, r2
 801f4e0:	701a      	strb	r2, [r3, #0]
 801f4e2:	4b77      	ldr	r3, [pc, #476]	; (801f6c0 <finsh_compile+0x1750>)
 801f4e4:	681b      	ldr	r3, [r3, #0]
 801f4e6:	3303      	adds	r3, #3
 801f4e8:	68ba      	ldr	r2, [r7, #8]
 801f4ea:	3214      	adds	r2, #20
 801f4ec:	0e12      	lsrs	r2, r2, #24
 801f4ee:	b2d2      	uxtb	r2, r2
 801f4f0:	701a      	strb	r2, [r3, #0]
 801f4f2:	4b73      	ldr	r3, [pc, #460]	; (801f6c0 <finsh_compile+0x1750>)
 801f4f4:	681b      	ldr	r3, [r3, #0]
 801f4f6:	3304      	adds	r3, #4
 801f4f8:	4a71      	ldr	r2, [pc, #452]	; (801f6c0 <finsh_compile+0x1750>)
 801f4fa:	6013      	str	r3, [r2, #0]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
 801f4fc:	4b70      	ldr	r3, [pc, #448]	; (801f6c0 <finsh_compile+0x1750>)
 801f4fe:	681b      	ldr	r3, [r3, #0]
 801f500:	2223      	movs	r2, #35	; 0x23
 801f502:	701a      	strb	r2, [r3, #0]
 801f504:	4b6e      	ldr	r3, [pc, #440]	; (801f6c0 <finsh_compile+0x1750>)
 801f506:	681b      	ldr	r3, [r3, #0]
 801f508:	3301      	adds	r3, #1
 801f50a:	4a6d      	ldr	r2, [pc, #436]	; (801f6c0 <finsh_compile+0x1750>)
 801f50c:	6013      	str	r3, [r2, #0]
                    finsh_code_word(1);
 801f50e:	4b6c      	ldr	r3, [pc, #432]	; (801f6c0 <finsh_compile+0x1750>)
 801f510:	681b      	ldr	r3, [r3, #0]
 801f512:	2201      	movs	r2, #1
 801f514:	701a      	strb	r2, [r3, #0]
 801f516:	4b6a      	ldr	r3, [pc, #424]	; (801f6c0 <finsh_compile+0x1750>)
 801f518:	681b      	ldr	r3, [r3, #0]
 801f51a:	3301      	adds	r3, #1
 801f51c:	2200      	movs	r2, #0
 801f51e:	701a      	strb	r2, [r3, #0]
 801f520:	4b67      	ldr	r3, [pc, #412]	; (801f6c0 <finsh_compile+0x1750>)
 801f522:	681b      	ldr	r3, [r3, #0]
 801f524:	3302      	adds	r3, #2
 801f526:	4a66      	ldr	r2, [pc, #408]	; (801f6c0 <finsh_compile+0x1750>)
 801f528:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_WORD);
 801f52a:	4b65      	ldr	r3, [pc, #404]	; (801f6c0 <finsh_compile+0x1750>)
 801f52c:	681b      	ldr	r3, [r3, #0]
 801f52e:	2205      	movs	r2, #5
 801f530:	701a      	strb	r2, [r3, #0]
 801f532:	4b63      	ldr	r3, [pc, #396]	; (801f6c0 <finsh_compile+0x1750>)
 801f534:	681b      	ldr	r3, [r3, #0]
 801f536:	3301      	adds	r3, #1
 801f538:	4a61      	ldr	r2, [pc, #388]	; (801f6c0 <finsh_compile+0x1750>)
 801f53a:	6013      	str	r3, [r2, #0]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_WORD);
 801f53c:	4b60      	ldr	r3, [pc, #384]	; (801f6c0 <finsh_compile+0x1750>)
 801f53e:	681b      	ldr	r3, [r3, #0]
 801f540:	2229      	movs	r2, #41	; 0x29
 801f542:	701a      	strb	r2, [r3, #0]
 801f544:	4b5e      	ldr	r3, [pc, #376]	; (801f6c0 <finsh_compile+0x1750>)
 801f546:	681b      	ldr	r3, [r3, #0]
 801f548:	3301      	adds	r3, #1
 801f54a:	4a5d      	ldr	r2, [pc, #372]	; (801f6c0 <finsh_compile+0x1750>)
 801f54c:	6013      	str	r3, [r2, #0]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
 801f54e:	4b5c      	ldr	r3, [pc, #368]	; (801f6c0 <finsh_compile+0x1750>)
 801f550:	681b      	ldr	r3, [r3, #0]
 801f552:	222b      	movs	r2, #43	; 0x2b
 801f554:	701a      	strb	r2, [r3, #0]
 801f556:	4b5a      	ldr	r3, [pc, #360]	; (801f6c0 <finsh_compile+0x1750>)
 801f558:	681b      	ldr	r3, [r3, #0]
 801f55a:	3301      	adds	r3, #1
 801f55c:	4a58      	ldr	r2, [pc, #352]	; (801f6c0 <finsh_compile+0x1750>)
 801f55e:	6013      	str	r3, [r2, #0]
                    break;
 801f560:	e094      	b.n	801f68c <finsh_compile+0x171c>
                    /* ld_value_dword &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801f562:	4b57      	ldr	r3, [pc, #348]	; (801f6c0 <finsh_compile+0x1750>)
 801f564:	681b      	ldr	r3, [r3, #0]
 801f566:	2224      	movs	r2, #36	; 0x24
 801f568:	701a      	strb	r2, [r3, #0]
 801f56a:	4b55      	ldr	r3, [pc, #340]	; (801f6c0 <finsh_compile+0x1750>)
 801f56c:	681b      	ldr	r3, [r3, #0]
 801f56e:	3301      	adds	r3, #1
 801f570:	4a53      	ldr	r2, [pc, #332]	; (801f6c0 <finsh_compile+0x1750>)
 801f572:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.long_value));
 801f574:	4b52      	ldr	r3, [pc, #328]	; (801f6c0 <finsh_compile+0x1750>)
 801f576:	681b      	ldr	r3, [r3, #0]
 801f578:	68ba      	ldr	r2, [r7, #8]
 801f57a:	3214      	adds	r2, #20
 801f57c:	b2d2      	uxtb	r2, r2
 801f57e:	701a      	strb	r2, [r3, #0]
 801f580:	4b4f      	ldr	r3, [pc, #316]	; (801f6c0 <finsh_compile+0x1750>)
 801f582:	681b      	ldr	r3, [r3, #0]
 801f584:	3301      	adds	r3, #1
 801f586:	68ba      	ldr	r2, [r7, #8]
 801f588:	3214      	adds	r2, #20
 801f58a:	0a12      	lsrs	r2, r2, #8
 801f58c:	b2d2      	uxtb	r2, r2
 801f58e:	701a      	strb	r2, [r3, #0]
 801f590:	4b4b      	ldr	r3, [pc, #300]	; (801f6c0 <finsh_compile+0x1750>)
 801f592:	681b      	ldr	r3, [r3, #0]
 801f594:	3302      	adds	r3, #2
 801f596:	68ba      	ldr	r2, [r7, #8]
 801f598:	3214      	adds	r2, #20
 801f59a:	0c12      	lsrs	r2, r2, #16
 801f59c:	b2d2      	uxtb	r2, r2
 801f59e:	701a      	strb	r2, [r3, #0]
 801f5a0:	4b47      	ldr	r3, [pc, #284]	; (801f6c0 <finsh_compile+0x1750>)
 801f5a2:	681b      	ldr	r3, [r3, #0]
 801f5a4:	3303      	adds	r3, #3
 801f5a6:	68ba      	ldr	r2, [r7, #8]
 801f5a8:	3214      	adds	r2, #20
 801f5aa:	0e12      	lsrs	r2, r2, #24
 801f5ac:	b2d2      	uxtb	r2, r2
 801f5ae:	701a      	strb	r2, [r3, #0]
 801f5b0:	4b43      	ldr	r3, [pc, #268]	; (801f6c0 <finsh_compile+0x1750>)
 801f5b2:	681b      	ldr	r3, [r3, #0]
 801f5b4:	3304      	adds	r3, #4
 801f5b6:	4a42      	ldr	r2, [pc, #264]	; (801f6c0 <finsh_compile+0x1750>)
 801f5b8:	6013      	str	r3, [r2, #0]

                    /* ld_value_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
 801f5ba:	4b41      	ldr	r3, [pc, #260]	; (801f6c0 <finsh_compile+0x1750>)
 801f5bc:	681b      	ldr	r3, [r3, #0]
 801f5be:	2227      	movs	r2, #39	; 0x27
 801f5c0:	701a      	strb	r2, [r3, #0]
 801f5c2:	4b3f      	ldr	r3, [pc, #252]	; (801f6c0 <finsh_compile+0x1750>)
 801f5c4:	681b      	ldr	r3, [r3, #0]
 801f5c6:	3301      	adds	r3, #1
 801f5c8:	4a3d      	ldr	r2, [pc, #244]	; (801f6c0 <finsh_compile+0x1750>)
 801f5ca:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.long_value));
 801f5cc:	4b3c      	ldr	r3, [pc, #240]	; (801f6c0 <finsh_compile+0x1750>)
 801f5ce:	681b      	ldr	r3, [r3, #0]
 801f5d0:	68ba      	ldr	r2, [r7, #8]
 801f5d2:	3214      	adds	r2, #20
 801f5d4:	b2d2      	uxtb	r2, r2
 801f5d6:	701a      	strb	r2, [r3, #0]
 801f5d8:	4b39      	ldr	r3, [pc, #228]	; (801f6c0 <finsh_compile+0x1750>)
 801f5da:	681b      	ldr	r3, [r3, #0]
 801f5dc:	3301      	adds	r3, #1
 801f5de:	68ba      	ldr	r2, [r7, #8]
 801f5e0:	3214      	adds	r2, #20
 801f5e2:	0a12      	lsrs	r2, r2, #8
 801f5e4:	b2d2      	uxtb	r2, r2
 801f5e6:	701a      	strb	r2, [r3, #0]
 801f5e8:	4b35      	ldr	r3, [pc, #212]	; (801f6c0 <finsh_compile+0x1750>)
 801f5ea:	681b      	ldr	r3, [r3, #0]
 801f5ec:	3302      	adds	r3, #2
 801f5ee:	68ba      	ldr	r2, [r7, #8]
 801f5f0:	3214      	adds	r2, #20
 801f5f2:	0c12      	lsrs	r2, r2, #16
 801f5f4:	b2d2      	uxtb	r2, r2
 801f5f6:	701a      	strb	r2, [r3, #0]
 801f5f8:	4b31      	ldr	r3, [pc, #196]	; (801f6c0 <finsh_compile+0x1750>)
 801f5fa:	681b      	ldr	r3, [r3, #0]
 801f5fc:	3303      	adds	r3, #3
 801f5fe:	68ba      	ldr	r2, [r7, #8]
 801f600:	3214      	adds	r2, #20
 801f602:	0e12      	lsrs	r2, r2, #24
 801f604:	b2d2      	uxtb	r2, r2
 801f606:	701a      	strb	r2, [r3, #0]
 801f608:	4b2d      	ldr	r3, [pc, #180]	; (801f6c0 <finsh_compile+0x1750>)
 801f60a:	681b      	ldr	r3, [r3, #0]
 801f60c:	3304      	adds	r3, #4
 801f60e:	4a2c      	ldr	r2, [pc, #176]	; (801f6c0 <finsh_compile+0x1750>)
 801f610:	6013      	str	r3, [r2, #0]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801f612:	4b2b      	ldr	r3, [pc, #172]	; (801f6c0 <finsh_compile+0x1750>)
 801f614:	681b      	ldr	r3, [r3, #0]
 801f616:	2224      	movs	r2, #36	; 0x24
 801f618:	701a      	strb	r2, [r3, #0]
 801f61a:	4b29      	ldr	r3, [pc, #164]	; (801f6c0 <finsh_compile+0x1750>)
 801f61c:	681b      	ldr	r3, [r3, #0]
 801f61e:	3301      	adds	r3, #1
 801f620:	4a27      	ldr	r2, [pc, #156]	; (801f6c0 <finsh_compile+0x1750>)
 801f622:	6013      	str	r3, [r2, #0]
                    finsh_code_dword(1);
 801f624:	4b26      	ldr	r3, [pc, #152]	; (801f6c0 <finsh_compile+0x1750>)
 801f626:	681b      	ldr	r3, [r3, #0]
 801f628:	2201      	movs	r2, #1
 801f62a:	701a      	strb	r2, [r3, #0]
 801f62c:	4b24      	ldr	r3, [pc, #144]	; (801f6c0 <finsh_compile+0x1750>)
 801f62e:	681b      	ldr	r3, [r3, #0]
 801f630:	3301      	adds	r3, #1
 801f632:	2200      	movs	r2, #0
 801f634:	701a      	strb	r2, [r3, #0]
 801f636:	4b22      	ldr	r3, [pc, #136]	; (801f6c0 <finsh_compile+0x1750>)
 801f638:	681b      	ldr	r3, [r3, #0]
 801f63a:	3302      	adds	r3, #2
 801f63c:	2200      	movs	r2, #0
 801f63e:	701a      	strb	r2, [r3, #0]
 801f640:	4b1f      	ldr	r3, [pc, #124]	; (801f6c0 <finsh_compile+0x1750>)
 801f642:	681b      	ldr	r3, [r3, #0]
 801f644:	3303      	adds	r3, #3
 801f646:	2200      	movs	r2, #0
 801f648:	701a      	strb	r2, [r3, #0]
 801f64a:	4b1d      	ldr	r3, [pc, #116]	; (801f6c0 <finsh_compile+0x1750>)
 801f64c:	681b      	ldr	r3, [r3, #0]
 801f64e:	3304      	adds	r3, #4
 801f650:	4a1b      	ldr	r2, [pc, #108]	; (801f6c0 <finsh_compile+0x1750>)
 801f652:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_DWORD);
 801f654:	4b1a      	ldr	r3, [pc, #104]	; (801f6c0 <finsh_compile+0x1750>)
 801f656:	681b      	ldr	r3, [r3, #0]
 801f658:	2206      	movs	r2, #6
 801f65a:	701a      	strb	r2, [r3, #0]
 801f65c:	4b18      	ldr	r3, [pc, #96]	; (801f6c0 <finsh_compile+0x1750>)
 801f65e:	681b      	ldr	r3, [r3, #0]
 801f660:	3301      	adds	r3, #1
 801f662:	4a17      	ldr	r2, [pc, #92]	; (801f6c0 <finsh_compile+0x1750>)
 801f664:	6013      	str	r3, [r2, #0]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
 801f666:	4b16      	ldr	r3, [pc, #88]	; (801f6c0 <finsh_compile+0x1750>)
 801f668:	681b      	ldr	r3, [r3, #0]
 801f66a:	222a      	movs	r2, #42	; 0x2a
 801f66c:	701a      	strb	r2, [r3, #0]
 801f66e:	4b14      	ldr	r3, [pc, #80]	; (801f6c0 <finsh_compile+0x1750>)
 801f670:	681b      	ldr	r3, [r3, #0]
 801f672:	3301      	adds	r3, #1
 801f674:	4a12      	ldr	r2, [pc, #72]	; (801f6c0 <finsh_compile+0x1750>)
 801f676:	6013      	str	r3, [r2, #0]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
 801f678:	4b11      	ldr	r3, [pc, #68]	; (801f6c0 <finsh_compile+0x1750>)
 801f67a:	681b      	ldr	r3, [r3, #0]
 801f67c:	222b      	movs	r2, #43	; 0x2b
 801f67e:	701a      	strb	r2, [r3, #0]
 801f680:	4b0f      	ldr	r3, [pc, #60]	; (801f6c0 <finsh_compile+0x1750>)
 801f682:	681b      	ldr	r3, [r3, #0]
 801f684:	3301      	adds	r3, #1
 801f686:	4a0e      	ldr	r2, [pc, #56]	; (801f6c0 <finsh_compile+0x1750>)
 801f688:	6013      	str	r3, [r2, #0]
                    break;
 801f68a:	bf00      	nop
                }
            }
            break;
 801f68c:	e04f      	b.n	801f72e <finsh_compile+0x17be>

        case FINSH_NODE_SYS_NULL:
            finsh_code_dword(0);
 801f68e:	4b0c      	ldr	r3, [pc, #48]	; (801f6c0 <finsh_compile+0x1750>)
 801f690:	681b      	ldr	r3, [r3, #0]
 801f692:	2200      	movs	r2, #0
 801f694:	701a      	strb	r2, [r3, #0]
 801f696:	4b0a      	ldr	r3, [pc, #40]	; (801f6c0 <finsh_compile+0x1750>)
 801f698:	681b      	ldr	r3, [r3, #0]
 801f69a:	3301      	adds	r3, #1
 801f69c:	2200      	movs	r2, #0
 801f69e:	701a      	strb	r2, [r3, #0]
 801f6a0:	4b07      	ldr	r3, [pc, #28]	; (801f6c0 <finsh_compile+0x1750>)
 801f6a2:	681b      	ldr	r3, [r3, #0]
 801f6a4:	3302      	adds	r3, #2
 801f6a6:	2200      	movs	r2, #0
 801f6a8:	701a      	strb	r2, [r3, #0]
 801f6aa:	4b05      	ldr	r3, [pc, #20]	; (801f6c0 <finsh_compile+0x1750>)
 801f6ac:	681b      	ldr	r3, [r3, #0]
 801f6ae:	3303      	adds	r3, #3
 801f6b0:	2200      	movs	r2, #0
 801f6b2:	701a      	strb	r2, [r3, #0]
 801f6b4:	4b02      	ldr	r3, [pc, #8]	; (801f6c0 <finsh_compile+0x1750>)
 801f6b6:	681b      	ldr	r3, [r3, #0]
 801f6b8:	3304      	adds	r3, #4
 801f6ba:	4a01      	ldr	r2, [pc, #4]	; (801f6c0 <finsh_compile+0x1750>)
 801f6bc:	6013      	str	r3, [r2, #0]
            break;
 801f6be:	e036      	b.n	801f72e <finsh_compile+0x17be>
 801f6c0:	20012bb8 	.word	0x20012bb8

        case FINSH_NODE_SYS_GETVALUE:
            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801f6c4:	687b      	ldr	r3, [r7, #4]
 801f6c6:	789b      	ldrb	r3, [r3, #2]
 801f6c8:	f003 0308 	and.w	r3, r3, #8
 801f6cc:	2b00      	cmp	r3, #0
 801f6ce:	d126      	bne.n	801f71e <finsh_compile+0x17ae>
            {
                /* nothing will be generated */
            }
            else
            {
                switch (node->data_type)
 801f6d0:	687b      	ldr	r3, [r7, #4]
 801f6d2:	785b      	ldrb	r3, [r3, #1]
 801f6d4:	2b02      	cmp	r3, #2
 801f6d6:	d00e      	beq.n	801f6f6 <finsh_compile+0x1786>
 801f6d8:	2b03      	cmp	r3, #3
 801f6da:	d016      	beq.n	801f70a <finsh_compile+0x179a>
 801f6dc:	2b01      	cmp	r3, #1
 801f6de:	d000      	beq.n	801f6e2 <finsh_compile+0x1772>
                    break;
                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
                    break;
                default:
                    break;
 801f6e0:	e01d      	b.n	801f71e <finsh_compile+0x17ae>
            else
            {
                switch (node->data_type)
                {
                case FINSH_DATA_TYPE_BYTE:
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE_STACK);
 801f6e2:	4b1a      	ldr	r3, [pc, #104]	; (801f74c <finsh_compile+0x17dc>)
 801f6e4:	681b      	ldr	r3, [r3, #0]
 801f6e6:	222d      	movs	r2, #45	; 0x2d
 801f6e8:	701a      	strb	r2, [r3, #0]
 801f6ea:	4b18      	ldr	r3, [pc, #96]	; (801f74c <finsh_compile+0x17dc>)
 801f6ec:	681b      	ldr	r3, [r3, #0]
 801f6ee:	3301      	adds	r3, #1
 801f6f0:	4a16      	ldr	r2, [pc, #88]	; (801f74c <finsh_compile+0x17dc>)
 801f6f2:	6013      	str	r3, [r2, #0]
                    break;
 801f6f4:	e013      	b.n	801f71e <finsh_compile+0x17ae>
                case FINSH_DATA_TYPE_WORD:
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD_STACK);
 801f6f6:	4b15      	ldr	r3, [pc, #84]	; (801f74c <finsh_compile+0x17dc>)
 801f6f8:	681b      	ldr	r3, [r3, #0]
 801f6fa:	222e      	movs	r2, #46	; 0x2e
 801f6fc:	701a      	strb	r2, [r3, #0]
 801f6fe:	4b13      	ldr	r3, [pc, #76]	; (801f74c <finsh_compile+0x17dc>)
 801f700:	681b      	ldr	r3, [r3, #0]
 801f702:	3301      	adds	r3, #1
 801f704:	4a11      	ldr	r2, [pc, #68]	; (801f74c <finsh_compile+0x17dc>)
 801f706:	6013      	str	r3, [r2, #0]
                    break;
 801f708:	e009      	b.n	801f71e <finsh_compile+0x17ae>
                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801f70a:	4b10      	ldr	r3, [pc, #64]	; (801f74c <finsh_compile+0x17dc>)
 801f70c:	681b      	ldr	r3, [r3, #0]
 801f70e:	222f      	movs	r2, #47	; 0x2f
 801f710:	701a      	strb	r2, [r3, #0]
 801f712:	4b0e      	ldr	r3, [pc, #56]	; (801f74c <finsh_compile+0x17dc>)
 801f714:	681b      	ldr	r3, [r3, #0]
 801f716:	3301      	adds	r3, #1
 801f718:	4a0c      	ldr	r2, [pc, #48]	; (801f74c <finsh_compile+0x17dc>)
 801f71a:	6013      	str	r3, [r2, #0]
                    break;
 801f71c:	bf00      	nop
                default:
                    break;
                }
            }
            break;
 801f71e:	e006      	b.n	801f72e <finsh_compile+0x17be>
        case FINSH_NODE_SYS_GETADDR:
            /* nothing will be generated */
            break;

        default:
            finsh_error_set(FINSH_ERROR_UNKNOWN_NODE);
 801f720:	2008      	movs	r0, #8
 801f722:	f000 f971 	bl	801fa08 <finsh_error_set>
            break;
 801f726:	e002      	b.n	801f72e <finsh_compile+0x17be>
            }
            break;

        case FINSH_NODE_SYS_GETADDR:
            /* nothing will be generated */
            break;
 801f728:	bf00      	nop
 801f72a:	e000      	b.n	801f72e <finsh_compile+0x17be>
                            break;
                        }
                    }
                }
            }
            break;
 801f72c:	bf00      	nop
            finsh_error_set(FINSH_ERROR_UNKNOWN_NODE);
            break;
        }

        /* compile sibling node */
        if (finsh_node_sibling(node) != NULL)
 801f72e:	687b      	ldr	r3, [r7, #4]
 801f730:	68db      	ldr	r3, [r3, #12]
 801f732:	2b00      	cmp	r3, #0
 801f734:	d004      	beq.n	801f740 <finsh_compile+0x17d0>
            finsh_compile(finsh_node_sibling(node));
 801f736:	687b      	ldr	r3, [r7, #4]
 801f738:	68db      	ldr	r3, [r3, #12]
 801f73a:	4618      	mov	r0, r3
 801f73c:	f7fe fc18 	bl	801df70 <finsh_compile>
    }

    return 0;
 801f740:	2300      	movs	r3, #0
}
 801f742:	4618      	mov	r0, r3
 801f744:	3728      	adds	r7, #40	; 0x28
 801f746:	46bd      	mov	sp, r7
 801f748:	bd80      	pop	{r7, pc}
 801f74a:	bf00      	nop
 801f74c:	20012bb8 	.word	0x20012bb8

0801f750 <finsh_type_check>:

static int finsh_type_check(struct finsh_node* node, u_char is_addr)
{
 801f750:	b580      	push	{r7, lr}
 801f752:	b084      	sub	sp, #16
 801f754:	af00      	add	r7, sp, #0
 801f756:	6078      	str	r0, [r7, #4]
 801f758:	460b      	mov	r3, r1
 801f75a:	70fb      	strb	r3, [r7, #3]
    if (node != NULL)
 801f75c:	687b      	ldr	r3, [r7, #4]
 801f75e:	2b00      	cmp	r3, #0
 801f760:	f000 80fc 	beq.w	801f95c <finsh_type_check+0x20c>
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
 801f764:	687b      	ldr	r3, [r7, #4]
 801f766:	781b      	ldrb	r3, [r3, #0]
 801f768:	2b13      	cmp	r3, #19
 801f76a:	d00b      	beq.n	801f784 <finsh_type_check+0x34>
            node->node_type == FINSH_NODE_SYS_PREINC ||
 801f76c:	687b      	ldr	r3, [r7, #4]
 801f76e:	781b      	ldrb	r3, [r3, #0]
static int finsh_type_check(struct finsh_node* node, u_char is_addr)
{
    if (node != NULL)
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
 801f770:	2b15      	cmp	r3, #21
 801f772:	d007      	beq.n	801f784 <finsh_type_check+0x34>
            node->node_type == FINSH_NODE_SYS_PREINC ||
            node->node_type == FINSH_NODE_SYS_PREDEC ||
 801f774:	687b      	ldr	r3, [r7, #4]
 801f776:	781b      	ldrb	r3, [r3, #0]
{
    if (node != NULL)
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
            node->node_type == FINSH_NODE_SYS_PREINC ||
 801f778:	2b16      	cmp	r3, #22
 801f77a:	d003      	beq.n	801f784 <finsh_type_check+0x34>
            node->node_type == FINSH_NODE_SYS_PREDEC ||
            node->node_type == FINSH_NODE_SYS_GETADDR)
 801f77c:	687b      	ldr	r3, [r7, #4]
 801f77e:	781b      	ldrb	r3, [r3, #0]
    if (node != NULL)
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
            node->node_type == FINSH_NODE_SYS_PREINC ||
            node->node_type == FINSH_NODE_SYS_PREDEC ||
 801f780:	2b1a      	cmp	r3, #26
 801f782:	d106      	bne.n	801f792 <finsh_type_check+0x42>
            node->node_type == FINSH_NODE_SYS_GETADDR)
        {
            /* address */
            finsh_type_check(finsh_node_child(node), FINSH_IDTYPE_ADDRESS);
 801f784:	687b      	ldr	r3, [r7, #4]
 801f786:	691b      	ldr	r3, [r3, #16]
 801f788:	4618      	mov	r0, r3
 801f78a:	2108      	movs	r1, #8
 801f78c:	f7ff ffe0 	bl	801f750 <finsh_type_check>
 801f790:	e014      	b.n	801f7bc <finsh_type_check+0x6c>
        }
        else if (node->node_type == FINSH_NODE_SYS_GETVALUE && is_addr)
 801f792:	687b      	ldr	r3, [r7, #4]
 801f794:	781b      	ldrb	r3, [r3, #0]
 801f796:	2b19      	cmp	r3, #25
 801f798:	d109      	bne.n	801f7ae <finsh_type_check+0x5e>
 801f79a:	78fb      	ldrb	r3, [r7, #3]
 801f79c:	2b00      	cmp	r3, #0
 801f79e:	d006      	beq.n	801f7ae <finsh_type_check+0x5e>
        {
            /* change the attribute of getvalue in left expr */
            finsh_type_check(finsh_node_child(node), 0);
 801f7a0:	687b      	ldr	r3, [r7, #4]
 801f7a2:	691b      	ldr	r3, [r3, #16]
 801f7a4:	4618      	mov	r0, r3
 801f7a6:	2100      	movs	r1, #0
 801f7a8:	f7ff ffd2 	bl	801f750 <finsh_type_check>
 801f7ac:	e006      	b.n	801f7bc <finsh_type_check+0x6c>
        }
        else
        {
            /* transfer 'av' to child node */
            finsh_type_check(finsh_node_child(node), is_addr);
 801f7ae:	687b      	ldr	r3, [r7, #4]
 801f7b0:	691a      	ldr	r2, [r3, #16]
 801f7b2:	78fb      	ldrb	r3, [r7, #3]
 801f7b4:	4610      	mov	r0, r2
 801f7b6:	4619      	mov	r1, r3
 801f7b8:	f7ff ffca 	bl	801f750 <finsh_type_check>
        }

        /* always does not load address in sibling */
        finsh_type_check(finsh_node_sibling(node), FINSH_NODE_VALUE);
 801f7bc:	687b      	ldr	r3, [r7, #4]
 801f7be:	68db      	ldr	r3, [r3, #12]
 801f7c0:	4618      	mov	r0, r3
 801f7c2:	2100      	movs	r1, #0
 801f7c4:	f7ff ffc4 	bl	801f750 <finsh_type_check>

        /** set attribute of current node */

        /* make sure the current node is address or value */
        if (node->idtype != FINSH_IDTYPE_SYSCALL) node->idtype |= is_addr;
 801f7c8:	687b      	ldr	r3, [r7, #4]
 801f7ca:	789b      	ldrb	r3, [r3, #2]
 801f7cc:	2b04      	cmp	r3, #4
 801f7ce:	d006      	beq.n	801f7de <finsh_type_check+0x8e>
 801f7d0:	687b      	ldr	r3, [r7, #4]
 801f7d2:	789a      	ldrb	r2, [r3, #2]
 801f7d4:	78fb      	ldrb	r3, [r7, #3]
 801f7d6:	4313      	orrs	r3, r2
 801f7d8:	b2da      	uxtb	r2, r3
 801f7da:	687b      	ldr	r3, [r7, #4]
 801f7dc:	709a      	strb	r2, [r3, #2]

        if (finsh_node_child(node) != NULL)
 801f7de:	687b      	ldr	r3, [r7, #4]
 801f7e0:	691b      	ldr	r3, [r3, #16]
 801f7e2:	2b00      	cmp	r3, #0
 801f7e4:	d006      	beq.n	801f7f4 <finsh_type_check+0xa4>
        {
            node->data_type = finsh_node_child(node)->data_type;
 801f7e6:	687b      	ldr	r3, [r7, #4]
 801f7e8:	691b      	ldr	r3, [r3, #16]
 801f7ea:	785a      	ldrb	r2, [r3, #1]
 801f7ec:	687b      	ldr	r3, [r7, #4]
 801f7ee:	705a      	strb	r2, [r3, #1]
            return 0;
 801f7f0:	2300      	movs	r3, #0
 801f7f2:	e0b4      	b.n	801f95e <finsh_type_check+0x20e>
        }

        if (node->node_type == FINSH_NODE_ID)
 801f7f4:	687b      	ldr	r3, [r7, #4]
 801f7f6:	781b      	ldrb	r3, [r3, #0]
 801f7f8:	2b01      	cmp	r3, #1
 801f7fa:	f040 8094 	bne.w	801f926 <finsh_type_check+0x1d6>
        {
            if (node->idtype & FINSH_IDTYPE_VAR)
 801f7fe:	687b      	ldr	r3, [r7, #4]
 801f800:	789b      	ldrb	r3, [r3, #2]
 801f802:	f003 0301 	and.w	r3, r3, #1
 801f806:	2b00      	cmp	r3, #0
 801f808:	d043      	beq.n	801f892 <finsh_type_check+0x142>
            {
                struct finsh_var* var;

                var = node->id.var;
 801f80a:	687b      	ldr	r3, [r7, #4]
 801f80c:	689b      	ldr	r3, [r3, #8]
 801f80e:	60fb      	str	r3, [r7, #12]
                if (var != NULL)
 801f810:	68fb      	ldr	r3, [r7, #12]
 801f812:	2b00      	cmp	r3, #0
 801f814:	d03c      	beq.n	801f890 <finsh_type_check+0x140>
                {
                    switch (var->type)
 801f816:	68fb      	ldr	r3, [r7, #12]
 801f818:	7c5b      	ldrb	r3, [r3, #17]
 801f81a:	3b01      	subs	r3, #1
 801f81c:	2b0d      	cmp	r3, #13
 801f81e:	d833      	bhi.n	801f888 <finsh_type_check+0x138>
 801f820:	a201      	add	r2, pc, #4	; (adr r2, 801f828 <finsh_type_check+0xd8>)
 801f822:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801f826:	bf00      	nop
 801f828:	0801f861 	.word	0x0801f861
 801f82c:	0801f881 	.word	0x0801f881
 801f830:	0801f869 	.word	0x0801f869
 801f834:	0801f869 	.word	0x0801f869
 801f838:	0801f881 	.word	0x0801f881
 801f83c:	0801f871 	.word	0x0801f871
 801f840:	0801f871 	.word	0x0801f871
 801f844:	0801f881 	.word	0x0801f881
 801f848:	0801f879 	.word	0x0801f879
 801f84c:	0801f879 	.word	0x0801f879
 801f850:	0801f881 	.word	0x0801f881
 801f854:	0801f879 	.word	0x0801f879
 801f858:	0801f879 	.word	0x0801f879
 801f85c:	0801f881 	.word	0x0801f881
                    {
                    case finsh_type_void:
                        node->data_type = FINSH_DATA_TYPE_VOID;
 801f860:	687b      	ldr	r3, [r7, #4]
 801f862:	2200      	movs	r2, #0
 801f864:	705a      	strb	r2, [r3, #1]
                        break;
 801f866:	e013      	b.n	801f890 <finsh_type_check+0x140>

                    case finsh_type_char:
                    case finsh_type_uchar:
                        node->data_type = FINSH_DATA_TYPE_BYTE;
 801f868:	687b      	ldr	r3, [r7, #4]
 801f86a:	2201      	movs	r2, #1
 801f86c:	705a      	strb	r2, [r3, #1]
                        break;
 801f86e:	e00f      	b.n	801f890 <finsh_type_check+0x140>

                    case finsh_type_short:
                    case finsh_type_ushort:
                        node->data_type = FINSH_DATA_TYPE_WORD;
 801f870:	687b      	ldr	r3, [r7, #4]
 801f872:	2202      	movs	r2, #2
 801f874:	705a      	strb	r2, [r3, #1]
                        break;
 801f876:	e00b      	b.n	801f890 <finsh_type_check+0x140>

                    case finsh_type_int:
                    case finsh_type_uint:
                    case finsh_type_long:
                    case finsh_type_ulong:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
 801f878:	687b      	ldr	r3, [r7, #4]
 801f87a:	2203      	movs	r2, #3
 801f87c:	705a      	strb	r2, [r3, #1]
                        break;
 801f87e:	e007      	b.n	801f890 <finsh_type_check+0x140>
                    case finsh_type_charp:
                    case finsh_type_voidp:
                    case finsh_type_shortp:
                    case finsh_type_intp:
                    case finsh_type_longp:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
 801f880:	687b      	ldr	r3, [r7, #4]
 801f882:	2203      	movs	r2, #3
 801f884:	705a      	strb	r2, [r3, #1]
                        break;
 801f886:	e003      	b.n	801f890 <finsh_type_check+0x140>

                    default:
                        finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
 801f888:	2003      	movs	r0, #3
 801f88a:	f000 f8bd 	bl	801fa08 <finsh_error_set>
                        break;
 801f88e:	bf00      	nop
 801f890:	e064      	b.n	801f95c <finsh_type_check+0x20c>
                    }
                }
            }
            else if (node->idtype & FINSH_IDTYPE_SYSVAR)
 801f892:	687b      	ldr	r3, [r7, #4]
 801f894:	789b      	ldrb	r3, [r3, #2]
 801f896:	f003 0302 	and.w	r3, r3, #2
 801f89a:	2b00      	cmp	r3, #0
 801f89c:	d042      	beq.n	801f924 <finsh_type_check+0x1d4>
            {
                struct finsh_sysvar *sysvar;

                sysvar = node->id.sysvar;
 801f89e:	687b      	ldr	r3, [r7, #4]
 801f8a0:	689b      	ldr	r3, [r3, #8]
 801f8a2:	60bb      	str	r3, [r7, #8]
                if (sysvar != NULL)
 801f8a4:	68bb      	ldr	r3, [r7, #8]
 801f8a6:	2b00      	cmp	r3, #0
 801f8a8:	d03c      	beq.n	801f924 <finsh_type_check+0x1d4>
                {
                    switch (sysvar->type)
 801f8aa:	68bb      	ldr	r3, [r7, #8]
 801f8ac:	7a1b      	ldrb	r3, [r3, #8]
 801f8ae:	3b01      	subs	r3, #1
 801f8b0:	2b0d      	cmp	r3, #13
 801f8b2:	d833      	bhi.n	801f91c <finsh_type_check+0x1cc>
 801f8b4:	a201      	add	r2, pc, #4	; (adr r2, 801f8bc <finsh_type_check+0x16c>)
 801f8b6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801f8ba:	bf00      	nop
 801f8bc:	0801f8f5 	.word	0x0801f8f5
 801f8c0:	0801f915 	.word	0x0801f915
 801f8c4:	0801f8fd 	.word	0x0801f8fd
 801f8c8:	0801f8fd 	.word	0x0801f8fd
 801f8cc:	0801f915 	.word	0x0801f915
 801f8d0:	0801f905 	.word	0x0801f905
 801f8d4:	0801f905 	.word	0x0801f905
 801f8d8:	0801f915 	.word	0x0801f915
 801f8dc:	0801f90d 	.word	0x0801f90d
 801f8e0:	0801f90d 	.word	0x0801f90d
 801f8e4:	0801f915 	.word	0x0801f915
 801f8e8:	0801f90d 	.word	0x0801f90d
 801f8ec:	0801f90d 	.word	0x0801f90d
 801f8f0:	0801f915 	.word	0x0801f915
                    {
                    case finsh_type_void:
                        node->data_type = FINSH_DATA_TYPE_VOID;
 801f8f4:	687b      	ldr	r3, [r7, #4]
 801f8f6:	2200      	movs	r2, #0
 801f8f8:	705a      	strb	r2, [r3, #1]
                        break;
 801f8fa:	e013      	b.n	801f924 <finsh_type_check+0x1d4>

                    case finsh_type_char:
                    case finsh_type_uchar:
                        node->data_type = FINSH_DATA_TYPE_BYTE;
 801f8fc:	687b      	ldr	r3, [r7, #4]
 801f8fe:	2201      	movs	r2, #1
 801f900:	705a      	strb	r2, [r3, #1]
                        break;
 801f902:	e00f      	b.n	801f924 <finsh_type_check+0x1d4>

                    case finsh_type_short:
                    case finsh_type_ushort:
                        node->data_type = FINSH_DATA_TYPE_WORD;
 801f904:	687b      	ldr	r3, [r7, #4]
 801f906:	2202      	movs	r2, #2
 801f908:	705a      	strb	r2, [r3, #1]
                        break;
 801f90a:	e00b      	b.n	801f924 <finsh_type_check+0x1d4>

                    case finsh_type_int:
                    case finsh_type_uint:
                    case finsh_type_long:
                    case finsh_type_ulong:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
 801f90c:	687b      	ldr	r3, [r7, #4]
 801f90e:	2203      	movs	r2, #3
 801f910:	705a      	strb	r2, [r3, #1]
                        break;
 801f912:	e007      	b.n	801f924 <finsh_type_check+0x1d4>
                    case finsh_type_charp:
                    case finsh_type_voidp:
                    case finsh_type_shortp:
                    case finsh_type_intp:
                    case finsh_type_longp:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
 801f914:	687b      	ldr	r3, [r7, #4]
 801f916:	2203      	movs	r2, #3
 801f918:	705a      	strb	r2, [r3, #1]
                        break;
 801f91a:	e003      	b.n	801f924 <finsh_type_check+0x1d4>

                    default:
                        finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
 801f91c:	2003      	movs	r0, #3
 801f91e:	f000 f873 	bl	801fa08 <finsh_error_set>
                        break;
 801f922:	bf00      	nop
 801f924:	e01a      	b.n	801f95c <finsh_type_check+0x20c>
                    }
                }
            }
        }
        else if (node->node_type == FINSH_NODE_VALUE_CHAR)
 801f926:	687b      	ldr	r3, [r7, #4]
 801f928:	781b      	ldrb	r3, [r3, #0]
 801f92a:	2b02      	cmp	r3, #2
 801f92c:	d103      	bne.n	801f936 <finsh_type_check+0x1e6>
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
 801f92e:	687b      	ldr	r3, [r7, #4]
 801f930:	2201      	movs	r2, #1
 801f932:	705a      	strb	r2, [r3, #1]
 801f934:	e012      	b.n	801f95c <finsh_type_check+0x20c>
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
 801f936:	687b      	ldr	r3, [r7, #4]
 801f938:	781b      	ldrb	r3, [r3, #0]
 801f93a:	2b03      	cmp	r3, #3
 801f93c:	d00b      	beq.n	801f956 <finsh_type_check+0x206>
            node->node_type == FINSH_NODE_VALUE_LONG    ||
 801f93e:	687b      	ldr	r3, [r7, #4]
 801f940:	781b      	ldrb	r3, [r3, #0]
        }
        else if (node->node_type == FINSH_NODE_VALUE_CHAR)
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
 801f942:	2b04      	cmp	r3, #4
 801f944:	d007      	beq.n	801f956 <finsh_type_check+0x206>
            node->node_type == FINSH_NODE_VALUE_LONG    ||
            node->node_type == FINSH_NODE_VALUE_STRING  ||
 801f946:	687b      	ldr	r3, [r7, #4]
 801f948:	781b      	ldrb	r3, [r3, #0]
        else if (node->node_type == FINSH_NODE_VALUE_CHAR)
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
            node->node_type == FINSH_NODE_VALUE_LONG    ||
 801f94a:	2b05      	cmp	r3, #5
 801f94c:	d003      	beq.n	801f956 <finsh_type_check+0x206>
            node->node_type == FINSH_NODE_VALUE_STRING  ||
            node->node_type == FINSH_NODE_VALUE_NULL)
 801f94e:	687b      	ldr	r3, [r7, #4]
 801f950:	781b      	ldrb	r3, [r3, #0]
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
            node->node_type == FINSH_NODE_VALUE_LONG    ||
            node->node_type == FINSH_NODE_VALUE_STRING  ||
 801f952:	2b06      	cmp	r3, #6
 801f954:	d102      	bne.n	801f95c <finsh_type_check+0x20c>
            node->node_type == FINSH_NODE_VALUE_NULL)
        {
            node->data_type = FINSH_DATA_TYPE_DWORD;
 801f956:	687b      	ldr	r3, [r7, #4]
 801f958:	2203      	movs	r2, #3
 801f95a:	705a      	strb	r2, [r3, #1]
        }
    }
    return 0;
 801f95c:	2300      	movs	r3, #0
}
 801f95e:	4618      	mov	r0, r3
 801f960:	3710      	adds	r7, #16
 801f962:	46bd      	mov	sp, r7
 801f964:	bd80      	pop	{r7, pc}
 801f966:	bf00      	nop

0801f968 <finsh_compiler_run>:

int finsh_compiler_run(struct finsh_node* node)
{
 801f968:	b580      	push	{r7, lr}
 801f96a:	b084      	sub	sp, #16
 801f96c:	af00      	add	r7, sp, #0
 801f96e:	6078      	str	r0, [r7, #4]
    struct finsh_node* sibling;

    /* type check */
    finsh_type_check(node, FINSH_NODE_VALUE);
 801f970:	6878      	ldr	r0, [r7, #4]
 801f972:	2100      	movs	r1, #0
 801f974:	f7ff feec 	bl	801f750 <finsh_type_check>

    /* clean text segment and vm stack */
    memset(&text_segment[0], 0, sizeof(text_segment));
 801f978:	4818      	ldr	r0, [pc, #96]	; (801f9dc <finsh_compiler_run+0x74>)
 801f97a:	2100      	movs	r1, #0
 801f97c:	2280      	movs	r2, #128	; 0x80
 801f97e:	f003 f9ff 	bl	8022d80 <memset>
    memset(&finsh_vm_stack[0], 0, sizeof(finsh_vm_stack[0]));
 801f982:	4817      	ldr	r0, [pc, #92]	; (801f9e0 <finsh_compiler_run+0x78>)
 801f984:	2100      	movs	r1, #0
 801f986:	2204      	movs	r2, #4
 801f988:	f003 f9fa 	bl	8022d80 <memset>

    /* reset compile stack pointer and pc */
    finsh_compile_sp = &finsh_vm_stack[0];
 801f98c:	4b15      	ldr	r3, [pc, #84]	; (801f9e4 <finsh_compiler_run+0x7c>)
 801f98e:	4a14      	ldr	r2, [pc, #80]	; (801f9e0 <finsh_compiler_run+0x78>)
 801f990:	601a      	str	r2, [r3, #0]
    finsh_compile_pc = &text_segment[0];
 801f992:	4b15      	ldr	r3, [pc, #84]	; (801f9e8 <finsh_compiler_run+0x80>)
 801f994:	4a11      	ldr	r2, [pc, #68]	; (801f9dc <finsh_compiler_run+0x74>)
 801f996:	601a      	str	r2, [r3, #0]

    /* compile node */
    sibling = node;
 801f998:	687b      	ldr	r3, [r7, #4]
 801f99a:	60fb      	str	r3, [r7, #12]
    while (sibling != NULL)
 801f99c:	e016      	b.n	801f9cc <finsh_compiler_run+0x64>
    {
        struct finsh_node* current_node;
        current_node = sibling;
 801f99e:	68fb      	ldr	r3, [r7, #12]
 801f9a0:	60bb      	str	r3, [r7, #8]

        /* get sibling node */
        sibling = current_node->sibling;
 801f9a2:	68bb      	ldr	r3, [r7, #8]
 801f9a4:	68db      	ldr	r3, [r3, #12]
 801f9a6:	60fb      	str	r3, [r7, #12]

        /* clean sibling node */
        current_node->sibling = NULL;
 801f9a8:	68bb      	ldr	r3, [r7, #8]
 801f9aa:	2200      	movs	r2, #0
 801f9ac:	60da      	str	r2, [r3, #12]
        finsh_compile(current_node);
 801f9ae:	68b8      	ldr	r0, [r7, #8]
 801f9b0:	f7fe fade 	bl	801df70 <finsh_compile>

        /* pop current value */
        if (sibling != NULL) finsh_code_byte(FINSH_OP_POP);
 801f9b4:	68fb      	ldr	r3, [r7, #12]
 801f9b6:	2b00      	cmp	r3, #0
 801f9b8:	d008      	beq.n	801f9cc <finsh_compiler_run+0x64>
 801f9ba:	4b0b      	ldr	r3, [pc, #44]	; (801f9e8 <finsh_compiler_run+0x80>)
 801f9bc:	681b      	ldr	r3, [r3, #0]
 801f9be:	222b      	movs	r2, #43	; 0x2b
 801f9c0:	701a      	strb	r2, [r3, #0]
 801f9c2:	4b09      	ldr	r3, [pc, #36]	; (801f9e8 <finsh_compiler_run+0x80>)
 801f9c4:	681b      	ldr	r3, [r3, #0]
 801f9c6:	3301      	adds	r3, #1
 801f9c8:	4a07      	ldr	r2, [pc, #28]	; (801f9e8 <finsh_compiler_run+0x80>)
 801f9ca:	6013      	str	r3, [r2, #0]
    finsh_compile_sp = &finsh_vm_stack[0];
    finsh_compile_pc = &text_segment[0];

    /* compile node */
    sibling = node;
    while (sibling != NULL)
 801f9cc:	68fb      	ldr	r3, [r7, #12]
 801f9ce:	2b00      	cmp	r3, #0
 801f9d0:	d1e5      	bne.n	801f99e <finsh_compiler_run+0x36>

        /* pop current value */
        if (sibling != NULL) finsh_code_byte(FINSH_OP_POP);
    }

    return 0;
 801f9d2:	2300      	movs	r3, #0
}
 801f9d4:	4618      	mov	r0, r3
 801f9d6:	3710      	adds	r7, #16
 801f9d8:	46bd      	mov	sp, r7
 801f9da:	bd80      	pop	{r7, pc}
 801f9dc:	20012e48 	.word	0x20012e48
 801f9e0:	20012ec8 	.word	0x20012ec8
 801f9e4:	20012bbc 	.word	0x20012bbc
 801f9e8:	20012bb8 	.word	0x20012bb8

0801f9ec <finsh_error_init>:
	"Unknown symbol",
	"Null node"
};

int finsh_error_init()
{
 801f9ec:	b480      	push	{r7}
 801f9ee:	af00      	add	r7, sp, #0
	global_errno = FINSH_ERROR_OK;
 801f9f0:	4b04      	ldr	r3, [pc, #16]	; (801fa04 <finsh_error_init+0x18>)
 801f9f2:	2200      	movs	r2, #0
 801f9f4:	701a      	strb	r2, [r3, #0]

	return 0;
 801f9f6:	2300      	movs	r3, #0
}
 801f9f8:	4618      	mov	r0, r3
 801f9fa:	46bd      	mov	sp, r7
 801f9fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fa00:	4770      	bx	lr
 801fa02:	bf00      	nop
 801fa04:	20012bc0 	.word	0x20012bc0

0801fa08 <finsh_error_set>:

int finsh_error_set(u_char type)
{
 801fa08:	b480      	push	{r7}
 801fa0a:	b083      	sub	sp, #12
 801fa0c:	af00      	add	r7, sp, #0
 801fa0e:	4603      	mov	r3, r0
 801fa10:	71fb      	strb	r3, [r7, #7]
	global_errno = type;
 801fa12:	4a05      	ldr	r2, [pc, #20]	; (801fa28 <finsh_error_set+0x20>)
 801fa14:	79fb      	ldrb	r3, [r7, #7]
 801fa16:	7013      	strb	r3, [r2, #0]

	return 0;
 801fa18:	2300      	movs	r3, #0
}
 801fa1a:	4618      	mov	r0, r3
 801fa1c:	370c      	adds	r7, #12
 801fa1e:	46bd      	mov	sp, r7
 801fa20:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fa24:	4770      	bx	lr
 801fa26:	bf00      	nop
 801fa28:	20012bc0 	.word	0x20012bc0

0801fa2c <finsh_errno>:

u_char finsh_errno()
{
 801fa2c:	b480      	push	{r7}
 801fa2e:	af00      	add	r7, sp, #0
	return global_errno;
 801fa30:	4b03      	ldr	r3, [pc, #12]	; (801fa40 <finsh_errno+0x14>)
 801fa32:	781b      	ldrb	r3, [r3, #0]
}
 801fa34:	4618      	mov	r0, r3
 801fa36:	46bd      	mov	sp, r7
 801fa38:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fa3c:	4770      	bx	lr
 801fa3e:	bf00      	nop
 801fa40:	20012bc0 	.word	0x20012bc0

0801fa44 <finsh_error_string>:

const char* finsh_error_string(u_char type)
{
 801fa44:	b480      	push	{r7}
 801fa46:	b083      	sub	sp, #12
 801fa48:	af00      	add	r7, sp, #0
 801fa4a:	4603      	mov	r3, r0
 801fa4c:	71fb      	strb	r3, [r7, #7]
	return finsh_error_string_table[type];
 801fa4e:	79fb      	ldrb	r3, [r7, #7]
 801fa50:	4a04      	ldr	r2, [pc, #16]	; (801fa64 <finsh_error_string+0x20>)
 801fa52:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 801fa56:	4618      	mov	r0, r3
 801fa58:	370c      	adds	r7, #12
 801fa5a:	46bd      	mov	sp, r7
 801fa5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fa60:	4770      	bx	lr
 801fa62:	bf00      	nop
 801fa64:	200100d0 	.word	0x200100d0

0801fa68 <finsh_heap_init>:
static void finsh_block_remove(struct finsh_block_header** list, struct finsh_block_header* header);
static void finsh_block_split(struct finsh_block_header* header, size_t size);
static void finsh_block_merge(struct finsh_block_header** list, struct finsh_block_header* header);

int finsh_heap_init(void)
{
 801fa68:	b580      	push	{r7, lr}
 801fa6a:	af00      	add	r7, sp, #0
	/* clear heap to zero */
	memset(&finsh_heap[0], 0, sizeof(finsh_heap));
 801fa6c:	480a      	ldr	r0, [pc, #40]	; (801fa98 <finsh_heap_init+0x30>)
 801fa6e:	2100      	movs	r1, #0
 801fa70:	2280      	movs	r2, #128	; 0x80
 801fa72:	f003 f985 	bl	8022d80 <memset>

	/* init free and alloc list */
    free_list           = BLOCK_HEADER(&finsh_heap[0]);
 801fa76:	4b09      	ldr	r3, [pc, #36]	; (801fa9c <finsh_heap_init+0x34>)
 801fa78:	4a07      	ldr	r2, [pc, #28]	; (801fa98 <finsh_heap_init+0x30>)
 801fa7a:	601a      	str	r2, [r3, #0]
	free_list->length   = FINSH_HEAP_MAX - sizeof(struct finsh_block_header);
 801fa7c:	4b07      	ldr	r3, [pc, #28]	; (801fa9c <finsh_heap_init+0x34>)
 801fa7e:	681b      	ldr	r3, [r3, #0]
 801fa80:	2278      	movs	r2, #120	; 0x78
 801fa82:	601a      	str	r2, [r3, #0]
    free_list->next     = NULL;
 801fa84:	4b05      	ldr	r3, [pc, #20]	; (801fa9c <finsh_heap_init+0x34>)
 801fa86:	681b      	ldr	r3, [r3, #0]
 801fa88:	2200      	movs	r2, #0
 801fa8a:	605a      	str	r2, [r3, #4]

    allocate_list       = NULL;
 801fa8c:	4b04      	ldr	r3, [pc, #16]	; (801faa0 <finsh_heap_init+0x38>)
 801fa8e:	2200      	movs	r2, #0
 801fa90:	601a      	str	r2, [r3, #0]

    return 0;
 801fa92:	2300      	movs	r3, #0
}
 801fa94:	4618      	mov	r0, r3
 801fa96:	bd80      	pop	{r7, pc}
 801fa98:	20012bc4 	.word	0x20012bc4
 801fa9c:	200121a0 	.word	0x200121a0
 801faa0:	200121a4 	.word	0x200121a4

0801faa4 <finsh_heap_allocate>:

/**
 * allocate a block from heap
 */
void* finsh_heap_allocate(size_t size)
{
 801faa4:	b580      	push	{r7, lr}
 801faa6:	b084      	sub	sp, #16
 801faa8:	af00      	add	r7, sp, #0
 801faaa:	6078      	str	r0, [r7, #4]
	struct finsh_block_header* header;

	size = HEAP_ALIGN_SIZE(size);
 801faac:	687b      	ldr	r3, [r7, #4]
 801faae:	3303      	adds	r3, #3
 801fab0:	f023 0303 	bic.w	r3, r3, #3
 801fab4:	607b      	str	r3, [r7, #4]

    /* find the first fit block */
    for (header = free_list;
 801fab6:	4b23      	ldr	r3, [pc, #140]	; (801fb44 <finsh_heap_allocate+0xa0>)
 801fab8:	681b      	ldr	r3, [r3, #0]
 801faba:	60fb      	str	r3, [r7, #12]
 801fabc:	e002      	b.n	801fac4 <finsh_heap_allocate+0x20>
        ((header != NULL) && (header->length <= size + sizeof(struct finsh_block_header)));
        header = header->next) ;
 801fabe:	68fb      	ldr	r3, [r7, #12]
 801fac0:	685b      	ldr	r3, [r3, #4]
 801fac2:	60fb      	str	r3, [r7, #12]
	struct finsh_block_header* header;

	size = HEAP_ALIGN_SIZE(size);

    /* find the first fit block */
    for (header = free_list;
 801fac4:	68fb      	ldr	r3, [r7, #12]
 801fac6:	2b00      	cmp	r3, #0
 801fac8:	d005      	beq.n	801fad6 <finsh_heap_allocate+0x32>
        ((header != NULL) && (header->length <= size + sizeof(struct finsh_block_header)));
 801faca:	68fb      	ldr	r3, [r7, #12]
 801facc:	681a      	ldr	r2, [r3, #0]
 801face:	687b      	ldr	r3, [r7, #4]
 801fad0:	3308      	adds	r3, #8
 801fad2:	429a      	cmp	r2, r3
 801fad4:	d9f3      	bls.n	801fabe <finsh_heap_allocate+0x1a>
        header = header->next) ;

	if (header == NULL)
 801fad6:	68fb      	ldr	r3, [r7, #12]
 801fad8:	2b00      	cmp	r3, #0
 801fada:	d116      	bne.n	801fb0a <finsh_heap_allocate+0x66>
	{
		finsh_heap_gc();
 801fadc:	f000 f850 	bl	801fb80 <finsh_heap_gc>

		/* find the first fit block */
		for (header = free_list;
 801fae0:	4b18      	ldr	r3, [pc, #96]	; (801fb44 <finsh_heap_allocate+0xa0>)
 801fae2:	681b      	ldr	r3, [r3, #0]
 801fae4:	60fb      	str	r3, [r7, #12]
 801fae6:	e002      	b.n	801faee <finsh_heap_allocate+0x4a>
			((header != NULL) && (header->length < size + sizeof(struct finsh_block_header)));
			header = header->next) ;
 801fae8:	68fb      	ldr	r3, [r7, #12]
 801faea:	685b      	ldr	r3, [r3, #4]
 801faec:	60fb      	str	r3, [r7, #12]
	if (header == NULL)
	{
		finsh_heap_gc();

		/* find the first fit block */
		for (header = free_list;
 801faee:	68fb      	ldr	r3, [r7, #12]
 801faf0:	2b00      	cmp	r3, #0
 801faf2:	d005      	beq.n	801fb00 <finsh_heap_allocate+0x5c>
			((header != NULL) && (header->length < size + sizeof(struct finsh_block_header)));
 801faf4:	68fb      	ldr	r3, [r7, #12]
 801faf6:	681a      	ldr	r2, [r3, #0]
 801faf8:	687b      	ldr	r3, [r7, #4]
 801fafa:	3308      	adds	r3, #8
 801fafc:	429a      	cmp	r2, r3
 801fafe:	d3f3      	bcc.n	801fae8 <finsh_heap_allocate+0x44>
			header = header->next) ;

		/* there is no memory */
		if (header == NULL) return NULL;
 801fb00:	68fb      	ldr	r3, [r7, #12]
 801fb02:	2b00      	cmp	r3, #0
 801fb04:	d101      	bne.n	801fb0a <finsh_heap_allocate+0x66>
 801fb06:	2300      	movs	r3, #0
 801fb08:	e017      	b.n	801fb3a <finsh_heap_allocate+0x96>
	}

    /* split block */
	finsh_block_split(header, size);
 801fb0a:	68f8      	ldr	r0, [r7, #12]
 801fb0c:	6879      	ldr	r1, [r7, #4]
 801fb0e:	f000 f8e7 	bl	801fce0 <finsh_block_split>

	/* remove from free list */
	finsh_block_remove(&free_list, header);
 801fb12:	480c      	ldr	r0, [pc, #48]	; (801fb44 <finsh_heap_allocate+0xa0>)
 801fb14:	68f9      	ldr	r1, [r7, #12]
 801fb16:	f000 f8b5 	bl	801fc84 <finsh_block_remove>
	header->next = NULL;
 801fb1a:	68fb      	ldr	r3, [r7, #12]
 801fb1c:	2200      	movs	r2, #0
 801fb1e:	605a      	str	r2, [r3, #4]

    /* insert to allocate list */
    finsh_block_insert(&allocate_list, header);
 801fb20:	4809      	ldr	r0, [pc, #36]	; (801fb48 <finsh_heap_allocate+0xa4>)
 801fb22:	68f9      	ldr	r1, [r7, #12]
 801fb24:	f000 f86e 	bl	801fc04 <finsh_block_insert>

	memset(finsh_block_get_data(header), 0, size);
 801fb28:	68fb      	ldr	r3, [r7, #12]
 801fb2a:	3308      	adds	r3, #8
 801fb2c:	4618      	mov	r0, r3
 801fb2e:	2100      	movs	r1, #0
 801fb30:	687a      	ldr	r2, [r7, #4]
 801fb32:	f003 f925 	bl	8022d80 <memset>

	return finsh_block_get_data(header);
 801fb36:	68fb      	ldr	r3, [r7, #12]
 801fb38:	3308      	adds	r3, #8
}
 801fb3a:	4618      	mov	r0, r3
 801fb3c:	3710      	adds	r7, #16
 801fb3e:	46bd      	mov	sp, r7
 801fb40:	bd80      	pop	{r7, pc}
 801fb42:	bf00      	nop
 801fb44:	200121a0 	.word	0x200121a0
 801fb48:	200121a4 	.word	0x200121a4

0801fb4c <finsh_heap_free>:

/**
 * release the allocated block
 */
void  finsh_heap_free(void*ptr)
{
 801fb4c:	b580      	push	{r7, lr}
 801fb4e:	b084      	sub	sp, #16
 801fb50:	af00      	add	r7, sp, #0
 801fb52:	6078      	str	r0, [r7, #4]
    struct finsh_block_header* header;

    /* get block header */
	header = finsh_block_get_header(ptr);
 801fb54:	687b      	ldr	r3, [r7, #4]
 801fb56:	3b08      	subs	r3, #8
 801fb58:	60fb      	str	r3, [r7, #12]

    /* remove from allocate list */
	finsh_block_remove(&allocate_list, header);
 801fb5a:	4807      	ldr	r0, [pc, #28]	; (801fb78 <finsh_heap_free+0x2c>)
 801fb5c:	68f9      	ldr	r1, [r7, #12]
 801fb5e:	f000 f891 	bl	801fc84 <finsh_block_remove>

	/* insert to free list */
	finsh_block_insert(&free_list, header);
 801fb62:	4806      	ldr	r0, [pc, #24]	; (801fb7c <finsh_heap_free+0x30>)
 801fb64:	68f9      	ldr	r1, [r7, #12]
 801fb66:	f000 f84d 	bl	801fc04 <finsh_block_insert>
	finsh_block_merge(&free_list, header);
 801fb6a:	4804      	ldr	r0, [pc, #16]	; (801fb7c <finsh_heap_free+0x30>)
 801fb6c:	68f9      	ldr	r1, [r7, #12]
 801fb6e:	f000 f8d9 	bl	801fd24 <finsh_block_merge>
}
 801fb72:	3710      	adds	r7, #16
 801fb74:	46bd      	mov	sp, r7
 801fb76:	bd80      	pop	{r7, pc}
 801fb78:	200121a4 	.word	0x200121a4
 801fb7c:	200121a0 	.word	0x200121a0

0801fb80 <finsh_heap_gc>:

/**
 * garbage collector
 */
static void finsh_heap_gc(void)
{
 801fb80:	b580      	push	{r7, lr}
 801fb82:	b084      	sub	sp, #16
 801fb84:	af00      	add	r7, sp, #0
	int i;
	struct finsh_block_header *header, *temp;

	temp = NULL;
 801fb86:	2300      	movs	r3, #0
 801fb88:	607b      	str	r3, [r7, #4]

    /* find the first fit block */
    for (header = allocate_list; header != NULL; )
 801fb8a:	4b1c      	ldr	r3, [pc, #112]	; (801fbfc <finsh_heap_gc+0x7c>)
 801fb8c:	681b      	ldr	r3, [r3, #0]
 801fb8e:	60bb      	str	r3, [r7, #8]
 801fb90:	e02e      	b.n	801fbf0 <finsh_heap_gc+0x70>
    {
    	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
 801fb92:	2300      	movs	r3, #0
 801fb94:	60fb      	str	r3, [r7, #12]
 801fb96:	e01b      	b.n	801fbd0 <finsh_heap_gc+0x50>
    	{
    		if (global_variable[i].type != finsh_type_unknown)
 801fb98:	4919      	ldr	r1, [pc, #100]	; (801fc00 <finsh_heap_gc+0x80>)
 801fb9a:	68fa      	ldr	r2, [r7, #12]
 801fb9c:	4613      	mov	r3, r2
 801fb9e:	005b      	lsls	r3, r3, #1
 801fba0:	4413      	add	r3, r2
 801fba2:	00db      	lsls	r3, r3, #3
 801fba4:	440b      	add	r3, r1
 801fba6:	3310      	adds	r3, #16
 801fba8:	785b      	ldrb	r3, [r3, #1]
 801fbaa:	2b00      	cmp	r3, #0
 801fbac:	d00d      	beq.n	801fbca <finsh_heap_gc+0x4a>
    		{
    			if (global_variable[i].value.ptr == finsh_block_get_data(header))
 801fbae:	4914      	ldr	r1, [pc, #80]	; (801fc00 <finsh_heap_gc+0x80>)
 801fbb0:	68fa      	ldr	r2, [r7, #12]
 801fbb2:	4613      	mov	r3, r2
 801fbb4:	005b      	lsls	r3, r3, #1
 801fbb6:	4413      	add	r3, r2
 801fbb8:	00db      	lsls	r3, r3, #3
 801fbba:	440b      	add	r3, r1
 801fbbc:	3310      	adds	r3, #16
 801fbbe:	685a      	ldr	r2, [r3, #4]
 801fbc0:	68bb      	ldr	r3, [r7, #8]
 801fbc2:	3308      	adds	r3, #8
 801fbc4:	429a      	cmp	r2, r3
 801fbc6:	d100      	bne.n	801fbca <finsh_heap_gc+0x4a>
					break;
 801fbc8:	e005      	b.n	801fbd6 <finsh_heap_gc+0x56>
	temp = NULL;

    /* find the first fit block */
    for (header = allocate_list; header != NULL; )
    {
    	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
 801fbca:	68fb      	ldr	r3, [r7, #12]
 801fbcc:	3301      	adds	r3, #1
 801fbce:	60fb      	str	r3, [r7, #12]
 801fbd0:	68fb      	ldr	r3, [r7, #12]
 801fbd2:	2b07      	cmp	r3, #7
 801fbd4:	dde0      	ble.n	801fb98 <finsh_heap_gc+0x18>
    			if (global_variable[i].value.ptr == finsh_block_get_data(header))
					break;
    		}
    	}

		temp   = header;
 801fbd6:	68bb      	ldr	r3, [r7, #8]
 801fbd8:	607b      	str	r3, [r7, #4]
		header = header->next;
 801fbda:	68bb      	ldr	r3, [r7, #8]
 801fbdc:	685b      	ldr	r3, [r3, #4]
 801fbde:	60bb      	str	r3, [r7, #8]

		/* this block is an unused block, release it */
    	if (i == FINSH_VARIABLE_MAX)
 801fbe0:	68fb      	ldr	r3, [r7, #12]
 801fbe2:	2b08      	cmp	r3, #8
 801fbe4:	d104      	bne.n	801fbf0 <finsh_heap_gc+0x70>
    	{
    		finsh_heap_free(finsh_block_get_data(temp));
 801fbe6:	687b      	ldr	r3, [r7, #4]
 801fbe8:	3308      	adds	r3, #8
 801fbea:	4618      	mov	r0, r3
 801fbec:	f7ff ffae 	bl	801fb4c <finsh_heap_free>
	struct finsh_block_header *header, *temp;

	temp = NULL;

    /* find the first fit block */
    for (header = allocate_list; header != NULL; )
 801fbf0:	68bb      	ldr	r3, [r7, #8]
 801fbf2:	2b00      	cmp	r3, #0
 801fbf4:	d1cd      	bne.n	801fb92 <finsh_heap_gc+0x12>
    	if (i == FINSH_VARIABLE_MAX)
    	{
    		finsh_heap_free(finsh_block_get_data(temp));
    	}
    }
}
 801fbf6:	3710      	adds	r7, #16
 801fbf8:	46bd      	mov	sp, r7
 801fbfa:	bd80      	pop	{r7, pc}
 801fbfc:	200121a4 	.word	0x200121a4
 801fc00:	20012d88 	.word	0x20012d88

0801fc04 <finsh_block_insert>:

/**
 * insert a block to list
 */
void finsh_block_insert(struct finsh_block_header** list, struct finsh_block_header* header)
{
 801fc04:	b480      	push	{r7}
 801fc06:	b085      	sub	sp, #20
 801fc08:	af00      	add	r7, sp, #0
 801fc0a:	6078      	str	r0, [r7, #4]
 801fc0c:	6039      	str	r1, [r7, #0]
    struct finsh_block_header* node;

    if (*list == NULL)
 801fc0e:	687b      	ldr	r3, [r7, #4]
 801fc10:	681b      	ldr	r3, [r3, #0]
 801fc12:	2b00      	cmp	r3, #0
 801fc14:	d103      	bne.n	801fc1e <finsh_block_insert+0x1a>
    {
        *list = header;
 801fc16:	687b      	ldr	r3, [r7, #4]
 801fc18:	683a      	ldr	r2, [r7, #0]
 801fc1a:	601a      	str	r2, [r3, #0]
        return;
 801fc1c:	e02d      	b.n	801fc7a <finsh_block_insert+0x76>
    }

    /* find out insert point */
	node = *list;
 801fc1e:	687b      	ldr	r3, [r7, #4]
 801fc20:	681b      	ldr	r3, [r3, #0]
 801fc22:	60fb      	str	r3, [r7, #12]

	if (node > header)
 801fc24:	68fa      	ldr	r2, [r7, #12]
 801fc26:	683b      	ldr	r3, [r7, #0]
 801fc28:	429a      	cmp	r2, r3
 801fc2a:	d906      	bls.n	801fc3a <finsh_block_insert+0x36>
	{
		/* insert node in the header of list */
		header->next = node;
 801fc2c:	683b      	ldr	r3, [r7, #0]
 801fc2e:	68fa      	ldr	r2, [r7, #12]
 801fc30:	605a      	str	r2, [r3, #4]
		*list = header;
 801fc32:	687b      	ldr	r3, [r7, #4]
 801fc34:	683a      	ldr	r2, [r7, #0]
 801fc36:	601a      	str	r2, [r3, #0]

		return;
 801fc38:	e01f      	b.n	801fc7a <finsh_block_insert+0x76>
	}
	else
	{
		for (node = *list; node; node = node->next)
 801fc3a:	687b      	ldr	r3, [r7, #4]
 801fc3c:	681b      	ldr	r3, [r3, #0]
 801fc3e:	60fb      	str	r3, [r7, #12]
 801fc40:	e00d      	b.n	801fc5e <finsh_block_insert+0x5a>
		{
    		if (node->next > header) break;
 801fc42:	68fb      	ldr	r3, [r7, #12]
 801fc44:	685a      	ldr	r2, [r3, #4]
 801fc46:	683b      	ldr	r3, [r7, #0]
 801fc48:	429a      	cmp	r2, r3
 801fc4a:	d900      	bls.n	801fc4e <finsh_block_insert+0x4a>
 801fc4c:	e00a      	b.n	801fc64 <finsh_block_insert+0x60>

    		if (node->next == NULL) break;
 801fc4e:	68fb      	ldr	r3, [r7, #12]
 801fc50:	685b      	ldr	r3, [r3, #4]
 801fc52:	2b00      	cmp	r3, #0
 801fc54:	d100      	bne.n	801fc58 <finsh_block_insert+0x54>
 801fc56:	e005      	b.n	801fc64 <finsh_block_insert+0x60>

		return;
	}
	else
	{
		for (node = *list; node; node = node->next)
 801fc58:	68fb      	ldr	r3, [r7, #12]
 801fc5a:	685b      	ldr	r3, [r3, #4]
 801fc5c:	60fb      	str	r3, [r7, #12]
 801fc5e:	68fb      	ldr	r3, [r7, #12]
 801fc60:	2b00      	cmp	r3, #0
 801fc62:	d1ee      	bne.n	801fc42 <finsh_block_insert+0x3e>
    		if (node->next == NULL) break;
		}
	}

    /* insert node */
    if (node->next != NULL) header->next = node->next;
 801fc64:	68fb      	ldr	r3, [r7, #12]
 801fc66:	685b      	ldr	r3, [r3, #4]
 801fc68:	2b00      	cmp	r3, #0
 801fc6a:	d003      	beq.n	801fc74 <finsh_block_insert+0x70>
 801fc6c:	68fb      	ldr	r3, [r7, #12]
 801fc6e:	685a      	ldr	r2, [r3, #4]
 801fc70:	683b      	ldr	r3, [r7, #0]
 801fc72:	605a      	str	r2, [r3, #4]
    node->next      = header;
 801fc74:	68fb      	ldr	r3, [r7, #12]
 801fc76:	683a      	ldr	r2, [r7, #0]
 801fc78:	605a      	str	r2, [r3, #4]
}
 801fc7a:	3714      	adds	r7, #20
 801fc7c:	46bd      	mov	sp, r7
 801fc7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fc82:	4770      	bx	lr

0801fc84 <finsh_block_remove>:

/**
 * remove block from list
 */
void finsh_block_remove(struct finsh_block_header** list, struct finsh_block_header* header)
{
 801fc84:	b480      	push	{r7}
 801fc86:	b085      	sub	sp, #20
 801fc88:	af00      	add	r7, sp, #0
 801fc8a:	6078      	str	r0, [r7, #4]
 801fc8c:	6039      	str	r1, [r7, #0]
    struct finsh_block_header* node;

    node = *list;
 801fc8e:	687b      	ldr	r3, [r7, #4]
 801fc90:	681b      	ldr	r3, [r3, #0]
 801fc92:	60fb      	str	r3, [r7, #12]
    if (node == header)
 801fc94:	68fa      	ldr	r2, [r7, #12]
 801fc96:	683b      	ldr	r3, [r7, #0]
 801fc98:	429a      	cmp	r2, r3
 801fc9a:	d107      	bne.n	801fcac <finsh_block_remove+0x28>
    {
        /* remove list header */
        *list = header->next;
 801fc9c:	683b      	ldr	r3, [r7, #0]
 801fc9e:	685a      	ldr	r2, [r3, #4]
 801fca0:	687b      	ldr	r3, [r7, #4]
 801fca2:	601a      	str	r2, [r3, #0]
        header->next = NULL;
 801fca4:	683b      	ldr	r3, [r7, #0]
 801fca6:	2200      	movs	r2, #0
 801fca8:	605a      	str	r2, [r3, #4]

        return;
 801fcaa:	e013      	b.n	801fcd4 <finsh_block_remove+0x50>
    }

    for (node = *list; node != NULL; node = node->next)
 801fcac:	687b      	ldr	r3, [r7, #4]
 801fcae:	681b      	ldr	r3, [r3, #0]
 801fcb0:	60fb      	str	r3, [r7, #12]
 801fcb2:	e00c      	b.n	801fcce <finsh_block_remove+0x4a>
    {
        if (node->next == header)
 801fcb4:	68fb      	ldr	r3, [r7, #12]
 801fcb6:	685a      	ldr	r2, [r3, #4]
 801fcb8:	683b      	ldr	r3, [r7, #0]
 801fcba:	429a      	cmp	r2, r3
 801fcbc:	d104      	bne.n	801fcc8 <finsh_block_remove+0x44>
        {
            node->next = header->next;
 801fcbe:	683b      	ldr	r3, [r7, #0]
 801fcc0:	685a      	ldr	r2, [r3, #4]
 801fcc2:	68fb      	ldr	r3, [r7, #12]
 801fcc4:	605a      	str	r2, [r3, #4]
            break;
 801fcc6:	e005      	b.n	801fcd4 <finsh_block_remove+0x50>
        header->next = NULL;

        return;
    }

    for (node = *list; node != NULL; node = node->next)
 801fcc8:	68fb      	ldr	r3, [r7, #12]
 801fcca:	685b      	ldr	r3, [r3, #4]
 801fccc:	60fb      	str	r3, [r7, #12]
 801fcce:	68fb      	ldr	r3, [r7, #12]
 801fcd0:	2b00      	cmp	r3, #0
 801fcd2:	d1ef      	bne.n	801fcb4 <finsh_block_remove+0x30>
        {
            node->next = header->next;
            break;
        }
    }
}
 801fcd4:	3714      	adds	r7, #20
 801fcd6:	46bd      	mov	sp, r7
 801fcd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fcdc:	4770      	bx	lr
 801fcde:	bf00      	nop

0801fce0 <finsh_block_split>:

/**
 * split block
 */
void finsh_block_split(struct finsh_block_header* header, size_t size)
{
 801fce0:	b480      	push	{r7}
 801fce2:	b085      	sub	sp, #20
 801fce4:	af00      	add	r7, sp, #0
 801fce6:	6078      	str	r0, [r7, #4]
 801fce8:	6039      	str	r1, [r7, #0]

    /*
     * split header into two node:
     * header->next->...
     */
    next = BLOCK_HEADER((u_char*)header + sizeof(struct finsh_block_header) + size);
 801fcea:	683b      	ldr	r3, [r7, #0]
 801fcec:	3308      	adds	r3, #8
 801fcee:	687a      	ldr	r2, [r7, #4]
 801fcf0:	4413      	add	r3, r2
 801fcf2:	60fb      	str	r3, [r7, #12]
    next->length = header->length - sizeof(struct finsh_block_header) - size;
 801fcf4:	687b      	ldr	r3, [r7, #4]
 801fcf6:	681a      	ldr	r2, [r3, #0]
 801fcf8:	683b      	ldr	r3, [r7, #0]
 801fcfa:	1ad3      	subs	r3, r2, r3
 801fcfc:	f1a3 0208 	sub.w	r2, r3, #8
 801fd00:	68fb      	ldr	r3, [r7, #12]
 801fd02:	601a      	str	r2, [r3, #0]
    header->length = size;
 801fd04:	687b      	ldr	r3, [r7, #4]
 801fd06:	683a      	ldr	r2, [r7, #0]
 801fd08:	601a      	str	r2, [r3, #0]
    next->next = header->next;
 801fd0a:	687b      	ldr	r3, [r7, #4]
 801fd0c:	685a      	ldr	r2, [r3, #4]
 801fd0e:	68fb      	ldr	r3, [r7, #12]
 801fd10:	605a      	str	r2, [r3, #4]

    header->next = next;
 801fd12:	687b      	ldr	r3, [r7, #4]
 801fd14:	68fa      	ldr	r2, [r7, #12]
 801fd16:	605a      	str	r2, [r3, #4]
}
 801fd18:	3714      	adds	r7, #20
 801fd1a:	46bd      	mov	sp, r7
 801fd1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fd20:	4770      	bx	lr
 801fd22:	bf00      	nop

0801fd24 <finsh_block_merge>:

void finsh_block_merge(struct finsh_block_header** list, struct finsh_block_header* header)
{
 801fd24:	b480      	push	{r7}
 801fd26:	b085      	sub	sp, #20
 801fd28:	af00      	add	r7, sp, #0
 801fd2a:	6078      	str	r0, [r7, #4]
 801fd2c:	6039      	str	r1, [r7, #0]
    struct finsh_block_header* prev_node;
    struct finsh_block_header* next_node;

    next_node = header->next;
 801fd2e:	683b      	ldr	r3, [r7, #0]
 801fd30:	685b      	ldr	r3, [r3, #4]
 801fd32:	60bb      	str	r3, [r7, #8]

    if (*list == header) prev_node = NULL;
 801fd34:	687b      	ldr	r3, [r7, #4]
 801fd36:	681a      	ldr	r2, [r3, #0]
 801fd38:	683b      	ldr	r3, [r7, #0]
 801fd3a:	429a      	cmp	r2, r3
 801fd3c:	d102      	bne.n	801fd44 <finsh_block_merge+0x20>
 801fd3e:	2300      	movs	r3, #0
 801fd40:	60fb      	str	r3, [r7, #12]
 801fd42:	e00f      	b.n	801fd64 <finsh_block_merge+0x40>
    else
    {
        /* find out the previous header */
        for (prev_node = *list; prev_node; prev_node =prev_node->next)
 801fd44:	687b      	ldr	r3, [r7, #4]
 801fd46:	681b      	ldr	r3, [r3, #0]
 801fd48:	60fb      	str	r3, [r7, #12]
 801fd4a:	e008      	b.n	801fd5e <finsh_block_merge+0x3a>
        {
            if (prev_node->next == header)
 801fd4c:	68fb      	ldr	r3, [r7, #12]
 801fd4e:	685a      	ldr	r2, [r3, #4]
 801fd50:	683b      	ldr	r3, [r7, #0]
 801fd52:	429a      	cmp	r2, r3
 801fd54:	d100      	bne.n	801fd58 <finsh_block_merge+0x34>
                break;
 801fd56:	e005      	b.n	801fd64 <finsh_block_merge+0x40>

    if (*list == header) prev_node = NULL;
    else
    {
        /* find out the previous header */
        for (prev_node = *list; prev_node; prev_node =prev_node->next)
 801fd58:	68fb      	ldr	r3, [r7, #12]
 801fd5a:	685b      	ldr	r3, [r3, #4]
 801fd5c:	60fb      	str	r3, [r7, #12]
 801fd5e:	68fb      	ldr	r3, [r7, #12]
 801fd60:	2b00      	cmp	r3, #0
 801fd62:	d1f3      	bne.n	801fd4c <finsh_block_merge+0x28>
    }

    /* try merge node */

    /* merge to previous node */
    if (prev_node != NULL &&
 801fd64:	68fb      	ldr	r3, [r7, #12]
 801fd66:	2b00      	cmp	r3, #0
 801fd68:	d031      	beq.n	801fdce <finsh_block_merge+0xaa>
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
 801fd6a:	68fb      	ldr	r3, [r7, #12]
 801fd6c:	681b      	ldr	r3, [r3, #0]
 801fd6e:	3308      	adds	r3, #8
 801fd70:	68fa      	ldr	r2, [r7, #12]
 801fd72:	441a      	add	r2, r3
    }

    /* try merge node */

    /* merge to previous node */
    if (prev_node != NULL &&
 801fd74:	683b      	ldr	r3, [r7, #0]
 801fd76:	429a      	cmp	r2, r3
 801fd78:	d129      	bne.n	801fdce <finsh_block_merge+0xaa>
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
 801fd7a:	68bb      	ldr	r3, [r7, #8]
 801fd7c:	2b00      	cmp	r3, #0
 801fd7e:	d018      	beq.n	801fdb2 <finsh_block_merge+0x8e>
            ((u_char*)header + header->length + sizeof(struct finsh_block_header)
 801fd80:	683b      	ldr	r3, [r7, #0]
 801fd82:	681b      	ldr	r3, [r3, #0]
 801fd84:	3308      	adds	r3, #8
 801fd86:	683a      	ldr	r2, [r7, #0]
 801fd88:	441a      	add	r2, r3
    if (prev_node != NULL &&
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
 801fd8a:	68bb      	ldr	r3, [r7, #8]
 801fd8c:	429a      	cmp	r2, r3
 801fd8e:	d110      	bne.n	801fdb2 <finsh_block_merge+0x8e>
            ((u_char*)header + header->length + sizeof(struct finsh_block_header)
            == (u_char*)next_node))
        {
            /* merge three node */
        	prev_node->length += header->length + next_node->length +
 801fd90:	68fb      	ldr	r3, [r7, #12]
 801fd92:	681a      	ldr	r2, [r3, #0]
 801fd94:	683b      	ldr	r3, [r7, #0]
 801fd96:	6819      	ldr	r1, [r3, #0]
 801fd98:	68bb      	ldr	r3, [r7, #8]
 801fd9a:	681b      	ldr	r3, [r3, #0]
 801fd9c:	440b      	add	r3, r1
 801fd9e:	4413      	add	r3, r2
 801fda0:	f103 0210 	add.w	r2, r3, #16
 801fda4:	68fb      	ldr	r3, [r7, #12]
 801fda6:	601a      	str	r2, [r3, #0]
                2 * sizeof(struct finsh_block_header);

            prev_node->next = next_node->next;
 801fda8:	68bb      	ldr	r3, [r7, #8]
 801fdaa:	685a      	ldr	r2, [r3, #4]
 801fdac:	68fb      	ldr	r3, [r7, #12]
 801fdae:	605a      	str	r2, [r3, #4]
    if (prev_node != NULL &&
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
 801fdb0:	e025      	b.n	801fdfe <finsh_block_merge+0xda>

            prev_node->next = next_node->next;
        }
        else
        {
            prev_node->length += header->length + sizeof(struct finsh_block_header);
 801fdb2:	68fb      	ldr	r3, [r7, #12]
 801fdb4:	681a      	ldr	r2, [r3, #0]
 801fdb6:	683b      	ldr	r3, [r7, #0]
 801fdb8:	681b      	ldr	r3, [r3, #0]
 801fdba:	4413      	add	r3, r2
 801fdbc:	f103 0208 	add.w	r2, r3, #8
 801fdc0:	68fb      	ldr	r3, [r7, #12]
 801fdc2:	601a      	str	r2, [r3, #0]
            prev_node->next = header->next;
 801fdc4:	683b      	ldr	r3, [r7, #0]
 801fdc6:	685a      	ldr	r2, [r3, #4]
 801fdc8:	68fb      	ldr	r3, [r7, #12]
 801fdca:	605a      	str	r2, [r3, #4]
    if (prev_node != NULL &&
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
 801fdcc:	e017      	b.n	801fdfe <finsh_block_merge+0xda>
            prev_node->length += header->length + sizeof(struct finsh_block_header);
            prev_node->next = header->next;
        }
    }
    else /* merge to last node */
    if ( (next_node != NULL) &&
 801fdce:	68bb      	ldr	r3, [r7, #8]
 801fdd0:	2b00      	cmp	r3, #0
 801fdd2:	d014      	beq.n	801fdfe <finsh_block_merge+0xda>
        ((u_char*)header + header->length + sizeof(struct finsh_block_header)
 801fdd4:	683b      	ldr	r3, [r7, #0]
 801fdd6:	681b      	ldr	r3, [r3, #0]
 801fdd8:	3308      	adds	r3, #8
 801fdda:	683a      	ldr	r2, [r7, #0]
 801fddc:	441a      	add	r2, r3
            prev_node->length += header->length + sizeof(struct finsh_block_header);
            prev_node->next = header->next;
        }
    }
    else /* merge to last node */
    if ( (next_node != NULL) &&
 801fdde:	68bb      	ldr	r3, [r7, #8]
 801fde0:	429a      	cmp	r2, r3
 801fde2:	d10c      	bne.n	801fdfe <finsh_block_merge+0xda>
        ((u_char*)header + header->length + sizeof(struct finsh_block_header)
        == (u_char*)next_node))
    {
        header->length += next_node->length + sizeof(struct finsh_block_header);
 801fde4:	683b      	ldr	r3, [r7, #0]
 801fde6:	681a      	ldr	r2, [r3, #0]
 801fde8:	68bb      	ldr	r3, [r7, #8]
 801fdea:	681b      	ldr	r3, [r3, #0]
 801fdec:	4413      	add	r3, r2
 801fdee:	f103 0208 	add.w	r2, r3, #8
 801fdf2:	683b      	ldr	r3, [r7, #0]
 801fdf4:	601a      	str	r2, [r3, #0]
        header->next = next_node->next;
 801fdf6:	68bb      	ldr	r3, [r7, #8]
 801fdf8:	685a      	ldr	r2, [r3, #4]
 801fdfa:	683b      	ldr	r3, [r7, #0]
 801fdfc:	605a      	str	r2, [r3, #4]
    }
}
 801fdfe:	3714      	adds	r7, #20
 801fe00:	46bd      	mov	sp, r7
 801fe02:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fe06:	4770      	bx	lr

0801fe08 <finsh_init>:
#include "finsh_var.h"
#include "finsh_error.h"
#include "finsh_heap.h"

int finsh_init(struct finsh_parser* parser)
{
 801fe08:	b580      	push	{r7, lr}
 801fe0a:	b082      	sub	sp, #8
 801fe0c:	af00      	add	r7, sp, #0
 801fe0e:	6078      	str	r0, [r7, #4]
	finsh_parser_init(parser);
 801fe10:	6878      	ldr	r0, [r7, #4]
 801fe12:	f001 ffb1 	bl	8021d78 <finsh_parser_init>

	/* finsh init */
	finsh_node_init();
 801fe16:	f000 f827 	bl	801fe68 <finsh_node_init>
	finsh_var_init();
 801fe1a:	f001 ffbb 	bl	8021d94 <finsh_var_init>
	finsh_error_init();
 801fe1e:	f7ff fde5 	bl	801f9ec <finsh_error_init>
	finsh_heap_init();
 801fe22:	f7ff fe21 	bl	801fa68 <finsh_heap_init>

	return 0;
 801fe26:	2300      	movs	r3, #0
}
 801fe28:	4618      	mov	r0, r3
 801fe2a:	3708      	adds	r7, #8
 801fe2c:	46bd      	mov	sp, r7
 801fe2e:	bd80      	pop	{r7, pc}

0801fe30 <finsh_stack_bottom>:

long finsh_stack_bottom()
{
 801fe30:	b480      	push	{r7}
 801fe32:	af00      	add	r7, sp, #0
    return finsh_vm_stack[0].long_value;
 801fe34:	4b03      	ldr	r3, [pc, #12]	; (801fe44 <finsh_stack_bottom+0x14>)
 801fe36:	681b      	ldr	r3, [r3, #0]
}
 801fe38:	4618      	mov	r0, r3
 801fe3a:	46bd      	mov	sp, r7
 801fe3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fe40:	4770      	bx	lr
 801fe42:	bf00      	nop
 801fe44:	20012ec8 	.word	0x20012ec8

0801fe48 <finsh_flush>:

int finsh_flush(struct finsh_parser* parser)
{
 801fe48:	b580      	push	{r7, lr}
 801fe4a:	b082      	sub	sp, #8
 801fe4c:	af00      	add	r7, sp, #0
 801fe4e:	6078      	str	r0, [r7, #4]
	finsh_parser_init(parser);
 801fe50:	6878      	ldr	r0, [r7, #4]
 801fe52:	f001 ff91 	bl	8021d78 <finsh_parser_init>

	/* finsh init */
	finsh_node_init();
 801fe56:	f000 f807 	bl	801fe68 <finsh_node_init>
	finsh_error_init();
 801fe5a:	f7ff fdc7 	bl	801f9ec <finsh_error_init>

	return 0;
 801fe5e:	2300      	movs	r3, #0
}
 801fe60:	4618      	mov	r0, r3
 801fe62:	3708      	adds	r7, #8
 801fe64:	46bd      	mov	sp, r7
 801fe66:	bd80      	pop	{r7, pc}

0801fe68 <finsh_node_init>:
#include "finsh_heap.h"

struct finsh_node global_node_table[FINSH_NODE_MAX];

int finsh_node_init()
{
 801fe68:	b580      	push	{r7, lr}
 801fe6a:	af00      	add	r7, sp, #0
	memset(global_node_table, 0, sizeof(global_node_table));
 801fe6c:	4804      	ldr	r0, [pc, #16]	; (801fe80 <finsh_node_init+0x18>)
 801fe6e:	2100      	movs	r1, #0
 801fe70:	f44f 72a0 	mov.w	r2, #320	; 0x140
 801fe74:	f002 ff84 	bl	8022d80 <memset>

	return 0;
 801fe78:	2300      	movs	r3, #0
}
 801fe7a:	4618      	mov	r0, r3
 801fe7c:	bd80      	pop	{r7, pc}
 801fe7e:	bf00      	nop
 801fe80:	20012c44 	.word	0x20012c44

0801fe84 <finsh_node_allocate>:

struct finsh_node* finsh_node_allocate(u_char type)
{
 801fe84:	b480      	push	{r7}
 801fe86:	b085      	sub	sp, #20
 801fe88:	af00      	add	r7, sp, #0
 801fe8a:	4603      	mov	r3, r0
 801fe8c:	71fb      	strb	r3, [r7, #7]
	int i;

	/* find an empty entry */
	for (i = 0; i < FINSH_NODE_MAX; i ++)
 801fe8e:	2300      	movs	r3, #0
 801fe90:	60fb      	str	r3, [r7, #12]
 801fe92:	e00d      	b.n	801feb0 <finsh_node_allocate+0x2c>
	{
		if (global_node_table[i].node_type == FINSH_NODE_UNKNOWN) break;
 801fe94:	4915      	ldr	r1, [pc, #84]	; (801feec <finsh_node_allocate+0x68>)
 801fe96:	68fa      	ldr	r2, [r7, #12]
 801fe98:	4613      	mov	r3, r2
 801fe9a:	009b      	lsls	r3, r3, #2
 801fe9c:	4413      	add	r3, r2
 801fe9e:	009b      	lsls	r3, r3, #2
 801fea0:	440b      	add	r3, r1
 801fea2:	781b      	ldrb	r3, [r3, #0]
 801fea4:	2b00      	cmp	r3, #0
 801fea6:	d100      	bne.n	801feaa <finsh_node_allocate+0x26>
 801fea8:	e005      	b.n	801feb6 <finsh_node_allocate+0x32>
struct finsh_node* finsh_node_allocate(u_char type)
{
	int i;

	/* find an empty entry */
	for (i = 0; i < FINSH_NODE_MAX; i ++)
 801feaa:	68fb      	ldr	r3, [r7, #12]
 801feac:	3301      	adds	r3, #1
 801feae:	60fb      	str	r3, [r7, #12]
 801feb0:	68fb      	ldr	r3, [r7, #12]
 801feb2:	2b0f      	cmp	r3, #15
 801feb4:	ddee      	ble.n	801fe94 <finsh_node_allocate+0x10>
	{
		if (global_node_table[i].node_type == FINSH_NODE_UNKNOWN) break;
	}

	if (i == FINSH_NODE_MAX) return NULL;
 801feb6:	68fb      	ldr	r3, [r7, #12]
 801feb8:	2b10      	cmp	r3, #16
 801feba:	d101      	bne.n	801fec0 <finsh_node_allocate+0x3c>
 801febc:	2300      	movs	r3, #0
 801febe:	e00f      	b.n	801fee0 <finsh_node_allocate+0x5c>

	/* fill type field */
	global_node_table[i].node_type = type;
 801fec0:	490a      	ldr	r1, [pc, #40]	; (801feec <finsh_node_allocate+0x68>)
 801fec2:	68fa      	ldr	r2, [r7, #12]
 801fec4:	4613      	mov	r3, r2
 801fec6:	009b      	lsls	r3, r3, #2
 801fec8:	4413      	add	r3, r2
 801feca:	009b      	lsls	r3, r3, #2
 801fecc:	440b      	add	r3, r1
 801fece:	79fa      	ldrb	r2, [r7, #7]
 801fed0:	701a      	strb	r2, [r3, #0]

	/* return this allocated node */
	return &global_node_table[i];
 801fed2:	68fa      	ldr	r2, [r7, #12]
 801fed4:	4613      	mov	r3, r2
 801fed6:	009b      	lsls	r3, r3, #2
 801fed8:	4413      	add	r3, r2
 801feda:	009b      	lsls	r3, r3, #2
 801fedc:	4a03      	ldr	r2, [pc, #12]	; (801feec <finsh_node_allocate+0x68>)
 801fede:	4413      	add	r3, r2
}
 801fee0:	4618      	mov	r0, r3
 801fee2:	3714      	adds	r7, #20
 801fee4:	46bd      	mov	sp, r7
 801fee6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801feea:	4770      	bx	lr
 801feec:	20012c44 	.word	0x20012c44

0801fef0 <finsh_node_new_id>:

struct finsh_node* finsh_node_new_id(char* id)
{
 801fef0:	b580      	push	{r7, lr}
 801fef2:	b086      	sub	sp, #24
 801fef4:	af00      	add	r7, sp, #0
 801fef6:	6078      	str	r0, [r7, #4]
	struct finsh_node* node;
	void*  symbol;
	unsigned char type;

	symbol	= NULL;
 801fef8:	2300      	movs	r3, #0
 801fefa:	613b      	str	r3, [r7, #16]
	type	= 0;
 801fefc:	2300      	movs	r3, #0
 801fefe:	73fb      	strb	r3, [r7, #15]
	node	= NULL;
 801ff00:	2300      	movs	r3, #0
 801ff02:	617b      	str	r3, [r7, #20]

	/* lookup variable firstly */
	symbol = (void*)finsh_var_lookup(id);
 801ff04:	6878      	ldr	r0, [r7, #4]
 801ff06:	f001 ffab 	bl	8021e60 <finsh_var_lookup>
 801ff0a:	6138      	str	r0, [r7, #16]
	if (symbol == NULL)
 801ff0c:	693b      	ldr	r3, [r7, #16]
 801ff0e:	2b00      	cmp	r3, #0
 801ff10:	d113      	bne.n	801ff3a <finsh_node_new_id+0x4a>
	{
		/* then lookup system variable */
		symbol = (void*)finsh_sysvar_lookup(id);
 801ff12:	6878      	ldr	r0, [r7, #4]
 801ff14:	f001 ffd4 	bl	8021ec0 <finsh_sysvar_lookup>
 801ff18:	6138      	str	r0, [r7, #16]
		if (symbol == NULL)
 801ff1a:	693b      	ldr	r3, [r7, #16]
 801ff1c:	2b00      	cmp	r3, #0
 801ff1e:	d109      	bne.n	801ff34 <finsh_node_new_id+0x44>
		{
			/* then lookup system call */
			symbol = (void*)finsh_syscall_lookup(id);
 801ff20:	6878      	ldr	r0, [r7, #4]
 801ff22:	f002 f841 	bl	8021fa8 <finsh_syscall_lookup>
 801ff26:	6138      	str	r0, [r7, #16]
			if (symbol != NULL) type = FINSH_IDTYPE_SYSCALL;
 801ff28:	693b      	ldr	r3, [r7, #16]
 801ff2a:	2b00      	cmp	r3, #0
 801ff2c:	d007      	beq.n	801ff3e <finsh_node_new_id+0x4e>
 801ff2e:	2304      	movs	r3, #4
 801ff30:	73fb      	strb	r3, [r7, #15]
 801ff32:	e004      	b.n	801ff3e <finsh_node_new_id+0x4e>
		}
		else type = FINSH_IDTYPE_SYSVAR;
 801ff34:	2302      	movs	r3, #2
 801ff36:	73fb      	strb	r3, [r7, #15]
 801ff38:	e001      	b.n	801ff3e <finsh_node_new_id+0x4e>
	}
	else type = FINSH_IDTYPE_VAR;
 801ff3a:	2301      	movs	r3, #1
 801ff3c:	73fb      	strb	r3, [r7, #15]

	if (symbol != NULL)
 801ff3e:	693b      	ldr	r3, [r7, #16]
 801ff40:	2b00      	cmp	r3, #0
 801ff42:	d022      	beq.n	801ff8a <finsh_node_new_id+0x9a>
	{
		/* allocate a new node */
		node = finsh_node_allocate(FINSH_NODE_ID);
 801ff44:	2001      	movs	r0, #1
 801ff46:	f7ff ff9d 	bl	801fe84 <finsh_node_allocate>
 801ff4a:	6178      	str	r0, [r7, #20]

		/* allocate node error */
		if (node == NULL)
 801ff4c:	697b      	ldr	r3, [r7, #20]
 801ff4e:	2b00      	cmp	r3, #0
 801ff50:	d104      	bne.n	801ff5c <finsh_node_new_id+0x6c>
		{
			finsh_error_set(FINSH_ERROR_MEMORY_FULL);
 801ff52:	2006      	movs	r0, #6
 801ff54:	f7ff fd58 	bl	801fa08 <finsh_error_set>
			return NULL;
 801ff58:	2300      	movs	r3, #0
 801ff5a:	e01a      	b.n	801ff92 <finsh_node_new_id+0xa2>
		}

		/* fill node value according type */
		switch (type)
 801ff5c:	7bfb      	ldrb	r3, [r7, #15]
 801ff5e:	2b02      	cmp	r3, #2
 801ff60:	d007      	beq.n	801ff72 <finsh_node_new_id+0x82>
 801ff62:	2b04      	cmp	r3, #4
 801ff64:	d009      	beq.n	801ff7a <finsh_node_new_id+0x8a>
 801ff66:	2b01      	cmp	r3, #1
 801ff68:	d10b      	bne.n	801ff82 <finsh_node_new_id+0x92>
		{
		case FINSH_IDTYPE_VAR:
			node->id.var = (struct finsh_var*)symbol;
 801ff6a:	697b      	ldr	r3, [r7, #20]
 801ff6c:	693a      	ldr	r2, [r7, #16]
 801ff6e:	609a      	str	r2, [r3, #8]
			break;
 801ff70:	e007      	b.n	801ff82 <finsh_node_new_id+0x92>

		case FINSH_IDTYPE_SYSVAR:
			node->id.sysvar = (struct finsh_sysvar*)symbol;
 801ff72:	697b      	ldr	r3, [r7, #20]
 801ff74:	693a      	ldr	r2, [r7, #16]
 801ff76:	609a      	str	r2, [r3, #8]
			break;
 801ff78:	e003      	b.n	801ff82 <finsh_node_new_id+0x92>

		case FINSH_IDTYPE_SYSCALL:
			node->id.syscall = (struct finsh_syscall*)symbol;
 801ff7a:	697b      	ldr	r3, [r7, #20]
 801ff7c:	693a      	ldr	r2, [r7, #16]
 801ff7e:	609a      	str	r2, [r3, #8]
			break;
 801ff80:	bf00      	nop
		}
		/* fill identifier type */
		node->idtype = type;
 801ff82:	697b      	ldr	r3, [r7, #20]
 801ff84:	7bfa      	ldrb	r2, [r7, #15]
 801ff86:	709a      	strb	r2, [r3, #2]
 801ff88:	e002      	b.n	801ff90 <finsh_node_new_id+0xa0>
	}
	else finsh_error_set(FINSH_ERROR_UNKNOWN_SYMBOL);
 801ff8a:	200d      	movs	r0, #13
 801ff8c:	f7ff fd3c 	bl	801fa08 <finsh_error_set>

	return node;
 801ff90:	697b      	ldr	r3, [r7, #20]
}
 801ff92:	4618      	mov	r0, r3
 801ff94:	3718      	adds	r7, #24
 801ff96:	46bd      	mov	sp, r7
 801ff98:	bd80      	pop	{r7, pc}
 801ff9a:	bf00      	nop

0801ff9c <finsh_node_new_char>:

struct finsh_node* finsh_node_new_char(char c)
{
 801ff9c:	b580      	push	{r7, lr}
 801ff9e:	b084      	sub	sp, #16
 801ffa0:	af00      	add	r7, sp, #0
 801ffa2:	4603      	mov	r3, r0
 801ffa4:	71fb      	strb	r3, [r7, #7]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_CHAR);
 801ffa6:	2002      	movs	r0, #2
 801ffa8:	f7ff ff6c 	bl	801fe84 <finsh_node_allocate>
 801ffac:	60f8      	str	r0, [r7, #12]
	if (node == NULL)
 801ffae:	68fb      	ldr	r3, [r7, #12]
 801ffb0:	2b00      	cmp	r3, #0
 801ffb2:	d104      	bne.n	801ffbe <finsh_node_new_char+0x22>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
 801ffb4:	2006      	movs	r0, #6
 801ffb6:	f7ff fd27 	bl	801fa08 <finsh_error_set>
		return NULL;
 801ffba:	2300      	movs	r3, #0
 801ffbc:	e003      	b.n	801ffc6 <finsh_node_new_char+0x2a>
	}

	node->value.char_value = c;
 801ffbe:	68fb      	ldr	r3, [r7, #12]
 801ffc0:	79fa      	ldrb	r2, [r7, #7]
 801ffc2:	711a      	strb	r2, [r3, #4]
	return node;
 801ffc4:	68fb      	ldr	r3, [r7, #12]
}
 801ffc6:	4618      	mov	r0, r3
 801ffc8:	3710      	adds	r7, #16
 801ffca:	46bd      	mov	sp, r7
 801ffcc:	bd80      	pop	{r7, pc}
 801ffce:	bf00      	nop

0801ffd0 <finsh_node_new_int>:

struct finsh_node* finsh_node_new_int(int i)
{
 801ffd0:	b580      	push	{r7, lr}
 801ffd2:	b084      	sub	sp, #16
 801ffd4:	af00      	add	r7, sp, #0
 801ffd6:	6078      	str	r0, [r7, #4]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_INT);
 801ffd8:	2003      	movs	r0, #3
 801ffda:	f7ff ff53 	bl	801fe84 <finsh_node_allocate>
 801ffde:	60f8      	str	r0, [r7, #12]
	if (node == NULL)
 801ffe0:	68fb      	ldr	r3, [r7, #12]
 801ffe2:	2b00      	cmp	r3, #0
 801ffe4:	d104      	bne.n	801fff0 <finsh_node_new_int+0x20>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
 801ffe6:	2006      	movs	r0, #6
 801ffe8:	f7ff fd0e 	bl	801fa08 <finsh_error_set>
		return NULL;
 801ffec:	2300      	movs	r3, #0
 801ffee:	e003      	b.n	801fff8 <finsh_node_new_int+0x28>
	}

	node->value.int_value = i;
 801fff0:	68fb      	ldr	r3, [r7, #12]
 801fff2:	687a      	ldr	r2, [r7, #4]
 801fff4:	605a      	str	r2, [r3, #4]
	return node;
 801fff6:	68fb      	ldr	r3, [r7, #12]
}
 801fff8:	4618      	mov	r0, r3
 801fffa:	3710      	adds	r7, #16
 801fffc:	46bd      	mov	sp, r7
 801fffe:	bd80      	pop	{r7, pc}

08020000 <finsh_node_new_long>:

struct finsh_node* finsh_node_new_long(long l)
{
 8020000:	b580      	push	{r7, lr}
 8020002:	b084      	sub	sp, #16
 8020004:	af00      	add	r7, sp, #0
 8020006:	6078      	str	r0, [r7, #4]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_LONG);
 8020008:	2004      	movs	r0, #4
 802000a:	f7ff ff3b 	bl	801fe84 <finsh_node_allocate>
 802000e:	60f8      	str	r0, [r7, #12]
	if (node == NULL)
 8020010:	68fb      	ldr	r3, [r7, #12]
 8020012:	2b00      	cmp	r3, #0
 8020014:	d104      	bne.n	8020020 <finsh_node_new_long+0x20>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
 8020016:	2006      	movs	r0, #6
 8020018:	f7ff fcf6 	bl	801fa08 <finsh_error_set>
		return NULL;
 802001c:	2300      	movs	r3, #0
 802001e:	e003      	b.n	8020028 <finsh_node_new_long+0x28>
	}

	node->value.long_value = l;
 8020020:	68fb      	ldr	r3, [r7, #12]
 8020022:	687a      	ldr	r2, [r7, #4]
 8020024:	605a      	str	r2, [r3, #4]
	return node;
 8020026:	68fb      	ldr	r3, [r7, #12]
}
 8020028:	4618      	mov	r0, r3
 802002a:	3710      	adds	r7, #16
 802002c:	46bd      	mov	sp, r7
 802002e:	bd80      	pop	{r7, pc}

08020030 <finsh_node_new_string>:

struct finsh_node* finsh_node_new_string(char* s)
{
 8020030:	b590      	push	{r4, r7, lr}
 8020032:	b085      	sub	sp, #20
 8020034:	af00      	add	r7, sp, #0
 8020036:	6078      	str	r0, [r7, #4]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_STRING);
 8020038:	2005      	movs	r0, #5
 802003a:	f7ff ff23 	bl	801fe84 <finsh_node_allocate>
 802003e:	60f8      	str	r0, [r7, #12]
	if (node == NULL)
 8020040:	68fb      	ldr	r3, [r7, #12]
 8020042:	2b00      	cmp	r3, #0
 8020044:	d104      	bne.n	8020050 <finsh_node_new_string+0x20>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
 8020046:	2006      	movs	r0, #6
 8020048:	f7ff fcde 	bl	801fa08 <finsh_error_set>
		return NULL;
 802004c:	2300      	movs	r3, #0
 802004e:	e01f      	b.n	8020090 <finsh_node_new_string+0x60>
	}

	/* make string */
	node->value.ptr = finsh_heap_allocate(strlen(s) + 1);
 8020050:	6878      	ldr	r0, [r7, #4]
 8020052:	f003 fb27 	bl	80236a4 <strlen>
 8020056:	4603      	mov	r3, r0
 8020058:	3301      	adds	r3, #1
 802005a:	4618      	mov	r0, r3
 802005c:	f7ff fd22 	bl	801faa4 <finsh_heap_allocate>
 8020060:	4602      	mov	r2, r0
 8020062:	68fb      	ldr	r3, [r7, #12]
 8020064:	605a      	str	r2, [r3, #4]
	strncpy(node->value.ptr, s, strlen(s));
 8020066:	68fb      	ldr	r3, [r7, #12]
 8020068:	685c      	ldr	r4, [r3, #4]
 802006a:	6878      	ldr	r0, [r7, #4]
 802006c:	f003 fb1a 	bl	80236a4 <strlen>
 8020070:	4603      	mov	r3, r0
 8020072:	4620      	mov	r0, r4
 8020074:	6879      	ldr	r1, [r7, #4]
 8020076:	461a      	mov	r2, r3
 8020078:	f003 fb8e 	bl	8023798 <strncpy>
	((u_char*)node->value.ptr)[strlen(s)] = '\0';
 802007c:	68fb      	ldr	r3, [r7, #12]
 802007e:	685c      	ldr	r4, [r3, #4]
 8020080:	6878      	ldr	r0, [r7, #4]
 8020082:	f003 fb0f 	bl	80236a4 <strlen>
 8020086:	4603      	mov	r3, r0
 8020088:	4423      	add	r3, r4
 802008a:	2200      	movs	r2, #0
 802008c:	701a      	strb	r2, [r3, #0]

	return node;
 802008e:	68fb      	ldr	r3, [r7, #12]
}
 8020090:	4618      	mov	r0, r3
 8020092:	3714      	adds	r7, #20
 8020094:	46bd      	mov	sp, r7
 8020096:	bd90      	pop	{r4, r7, pc}

08020098 <finsh_node_new_ptr>:

struct finsh_node* finsh_node_new_ptr(void* ptr)
{
 8020098:	b580      	push	{r7, lr}
 802009a:	b084      	sub	sp, #16
 802009c:	af00      	add	r7, sp, #0
 802009e:	6078      	str	r0, [r7, #4]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_NULL);
 80200a0:	2006      	movs	r0, #6
 80200a2:	f7ff feef 	bl	801fe84 <finsh_node_allocate>
 80200a6:	60f8      	str	r0, [r7, #12]
	if (node == NULL)
 80200a8:	68fb      	ldr	r3, [r7, #12]
 80200aa:	2b00      	cmp	r3, #0
 80200ac:	d104      	bne.n	80200b8 <finsh_node_new_ptr+0x20>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
 80200ae:	2006      	movs	r0, #6
 80200b0:	f7ff fcaa 	bl	801fa08 <finsh_error_set>
		return NULL;
 80200b4:	2300      	movs	r3, #0
 80200b6:	e003      	b.n	80200c0 <finsh_node_new_ptr+0x28>
	}

	node->value.ptr = ptr;
 80200b8:	68fb      	ldr	r3, [r7, #12]
 80200ba:	687a      	ldr	r2, [r7, #4]
 80200bc:	605a      	str	r2, [r3, #4]
	return node;
 80200be:	68fb      	ldr	r3, [r7, #12]
}
 80200c0:	4618      	mov	r0, r3
 80200c2:	3710      	adds	r7, #16
 80200c4:	46bd      	mov	sp, r7
 80200c6:	bd80      	pop	{r7, pc}

080200c8 <OP_no_op>:
        finsh_sp--; \
    }while (0)

/* --- noop --- */
void OP_no_op()
{
 80200c8:	b480      	push	{r7}
 80200ca:	af00      	add	r7, sp, #0
	/* none */
	return ;
 80200cc:	bf00      	nop
}
 80200ce:	46bd      	mov	sp, r7
 80200d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80200d4:	4770      	bx	lr
 80200d6:	bf00      	nop

080200d8 <OP_add_byte>:

/* --- add --- */
void OP_add_byte()
{
 80200d8:	b480      	push	{r7}
 80200da:	af00      	add	r7, sp, #0
    OP_BIN_BYTE(+);
 80200dc:	4b0b      	ldr	r3, [pc, #44]	; (802010c <OP_add_byte+0x34>)
 80200de:	681b      	ldr	r3, [r3, #0]
 80200e0:	3b08      	subs	r3, #8
 80200e2:	4a0a      	ldr	r2, [pc, #40]	; (802010c <OP_add_byte+0x34>)
 80200e4:	6812      	ldr	r2, [r2, #0]
 80200e6:	3a08      	subs	r2, #8
 80200e8:	7811      	ldrb	r1, [r2, #0]
 80200ea:	4a08      	ldr	r2, [pc, #32]	; (802010c <OP_add_byte+0x34>)
 80200ec:	6812      	ldr	r2, [r2, #0]
 80200ee:	3a04      	subs	r2, #4
 80200f0:	7812      	ldrb	r2, [r2, #0]
 80200f2:	440a      	add	r2, r1
 80200f4:	b2d2      	uxtb	r2, r2
 80200f6:	701a      	strb	r2, [r3, #0]
 80200f8:	4b04      	ldr	r3, [pc, #16]	; (802010c <OP_add_byte+0x34>)
 80200fa:	681b      	ldr	r3, [r3, #0]
 80200fc:	3b04      	subs	r3, #4
 80200fe:	4a03      	ldr	r2, [pc, #12]	; (802010c <OP_add_byte+0x34>)
 8020100:	6013      	str	r3, [r2, #0]

	return ;
 8020102:	bf00      	nop
}
 8020104:	46bd      	mov	sp, r7
 8020106:	f85d 7b04 	ldr.w	r7, [sp], #4
 802010a:	4770      	bx	lr
 802010c:	20012fcc 	.word	0x20012fcc

08020110 <OP_add_word>:

void OP_add_word()
{
 8020110:	b480      	push	{r7}
 8020112:	af00      	add	r7, sp, #0
    OP_BIN_WORD(+);
 8020114:	4b0d      	ldr	r3, [pc, #52]	; (802014c <OP_add_word+0x3c>)
 8020116:	681b      	ldr	r3, [r3, #0]
 8020118:	3b08      	subs	r3, #8
 802011a:	4a0c      	ldr	r2, [pc, #48]	; (802014c <OP_add_word+0x3c>)
 802011c:	6812      	ldr	r2, [r2, #0]
 802011e:	3a08      	subs	r2, #8
 8020120:	8812      	ldrh	r2, [r2, #0]
 8020122:	b291      	uxth	r1, r2
 8020124:	4a09      	ldr	r2, [pc, #36]	; (802014c <OP_add_word+0x3c>)
 8020126:	6812      	ldr	r2, [r2, #0]
 8020128:	3a04      	subs	r2, #4
 802012a:	8812      	ldrh	r2, [r2, #0]
 802012c:	b292      	uxth	r2, r2
 802012e:	440a      	add	r2, r1
 8020130:	b292      	uxth	r2, r2
 8020132:	b292      	uxth	r2, r2
 8020134:	801a      	strh	r2, [r3, #0]
 8020136:	4b05      	ldr	r3, [pc, #20]	; (802014c <OP_add_word+0x3c>)
 8020138:	681b      	ldr	r3, [r3, #0]
 802013a:	3b04      	subs	r3, #4
 802013c:	4a03      	ldr	r2, [pc, #12]	; (802014c <OP_add_word+0x3c>)
 802013e:	6013      	str	r3, [r2, #0]

	return ;
 8020140:	bf00      	nop
}
 8020142:	46bd      	mov	sp, r7
 8020144:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020148:	4770      	bx	lr
 802014a:	bf00      	nop
 802014c:	20012fcc 	.word	0x20012fcc

08020150 <OP_add_dword>:

void OP_add_dword()
{
 8020150:	b480      	push	{r7}
 8020152:	af00      	add	r7, sp, #0
    OP_BIN_DWORD(+);
 8020154:	4b0b      	ldr	r3, [pc, #44]	; (8020184 <OP_add_dword+0x34>)
 8020156:	681b      	ldr	r3, [r3, #0]
 8020158:	3b08      	subs	r3, #8
 802015a:	4a0a      	ldr	r2, [pc, #40]	; (8020184 <OP_add_dword+0x34>)
 802015c:	6812      	ldr	r2, [r2, #0]
 802015e:	3a08      	subs	r2, #8
 8020160:	6811      	ldr	r1, [r2, #0]
 8020162:	4a08      	ldr	r2, [pc, #32]	; (8020184 <OP_add_dword+0x34>)
 8020164:	6812      	ldr	r2, [r2, #0]
 8020166:	3a04      	subs	r2, #4
 8020168:	6812      	ldr	r2, [r2, #0]
 802016a:	440a      	add	r2, r1
 802016c:	601a      	str	r2, [r3, #0]
 802016e:	4b05      	ldr	r3, [pc, #20]	; (8020184 <OP_add_dword+0x34>)
 8020170:	681b      	ldr	r3, [r3, #0]
 8020172:	3b04      	subs	r3, #4
 8020174:	4a03      	ldr	r2, [pc, #12]	; (8020184 <OP_add_dword+0x34>)
 8020176:	6013      	str	r3, [r2, #0]

	return ;
 8020178:	bf00      	nop
}
 802017a:	46bd      	mov	sp, r7
 802017c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020180:	4770      	bx	lr
 8020182:	bf00      	nop
 8020184:	20012fcc 	.word	0x20012fcc

08020188 <OP_sub_byte>:

/* --- sub --- */
void OP_sub_byte()
{
 8020188:	b480      	push	{r7}
 802018a:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(-);
 802018c:	4b0b      	ldr	r3, [pc, #44]	; (80201bc <OP_sub_byte+0x34>)
 802018e:	681b      	ldr	r3, [r3, #0]
 8020190:	3b08      	subs	r3, #8
 8020192:	4a0a      	ldr	r2, [pc, #40]	; (80201bc <OP_sub_byte+0x34>)
 8020194:	6812      	ldr	r2, [r2, #0]
 8020196:	3a08      	subs	r2, #8
 8020198:	7811      	ldrb	r1, [r2, #0]
 802019a:	4a08      	ldr	r2, [pc, #32]	; (80201bc <OP_sub_byte+0x34>)
 802019c:	6812      	ldr	r2, [r2, #0]
 802019e:	3a04      	subs	r2, #4
 80201a0:	7812      	ldrb	r2, [r2, #0]
 80201a2:	1a8a      	subs	r2, r1, r2
 80201a4:	b2d2      	uxtb	r2, r2
 80201a6:	701a      	strb	r2, [r3, #0]
 80201a8:	4b04      	ldr	r3, [pc, #16]	; (80201bc <OP_sub_byte+0x34>)
 80201aa:	681b      	ldr	r3, [r3, #0]
 80201ac:	3b04      	subs	r3, #4
 80201ae:	4a03      	ldr	r2, [pc, #12]	; (80201bc <OP_sub_byte+0x34>)
 80201b0:	6013      	str	r3, [r2, #0]

	return ;
 80201b2:	bf00      	nop
}
 80201b4:	46bd      	mov	sp, r7
 80201b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80201ba:	4770      	bx	lr
 80201bc:	20012fcc 	.word	0x20012fcc

080201c0 <OP_sub_word>:

void OP_sub_word()
{
 80201c0:	b480      	push	{r7}
 80201c2:	af00      	add	r7, sp, #0
	OP_BIN_WORD(-);
 80201c4:	4b0d      	ldr	r3, [pc, #52]	; (80201fc <OP_sub_word+0x3c>)
 80201c6:	681b      	ldr	r3, [r3, #0]
 80201c8:	3b08      	subs	r3, #8
 80201ca:	4a0c      	ldr	r2, [pc, #48]	; (80201fc <OP_sub_word+0x3c>)
 80201cc:	6812      	ldr	r2, [r2, #0]
 80201ce:	3a08      	subs	r2, #8
 80201d0:	8812      	ldrh	r2, [r2, #0]
 80201d2:	b291      	uxth	r1, r2
 80201d4:	4a09      	ldr	r2, [pc, #36]	; (80201fc <OP_sub_word+0x3c>)
 80201d6:	6812      	ldr	r2, [r2, #0]
 80201d8:	3a04      	subs	r2, #4
 80201da:	8812      	ldrh	r2, [r2, #0]
 80201dc:	b292      	uxth	r2, r2
 80201de:	1a8a      	subs	r2, r1, r2
 80201e0:	b292      	uxth	r2, r2
 80201e2:	b292      	uxth	r2, r2
 80201e4:	801a      	strh	r2, [r3, #0]
 80201e6:	4b05      	ldr	r3, [pc, #20]	; (80201fc <OP_sub_word+0x3c>)
 80201e8:	681b      	ldr	r3, [r3, #0]
 80201ea:	3b04      	subs	r3, #4
 80201ec:	4a03      	ldr	r2, [pc, #12]	; (80201fc <OP_sub_word+0x3c>)
 80201ee:	6013      	str	r3, [r2, #0]

	return ;
 80201f0:	bf00      	nop
}
 80201f2:	46bd      	mov	sp, r7
 80201f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80201f8:	4770      	bx	lr
 80201fa:	bf00      	nop
 80201fc:	20012fcc 	.word	0x20012fcc

08020200 <OP_sub_dword>:

void OP_sub_dword()
{
 8020200:	b480      	push	{r7}
 8020202:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(-);
 8020204:	4b0b      	ldr	r3, [pc, #44]	; (8020234 <OP_sub_dword+0x34>)
 8020206:	681b      	ldr	r3, [r3, #0]
 8020208:	3b08      	subs	r3, #8
 802020a:	4a0a      	ldr	r2, [pc, #40]	; (8020234 <OP_sub_dword+0x34>)
 802020c:	6812      	ldr	r2, [r2, #0]
 802020e:	3a08      	subs	r2, #8
 8020210:	6811      	ldr	r1, [r2, #0]
 8020212:	4a08      	ldr	r2, [pc, #32]	; (8020234 <OP_sub_dword+0x34>)
 8020214:	6812      	ldr	r2, [r2, #0]
 8020216:	3a04      	subs	r2, #4
 8020218:	6812      	ldr	r2, [r2, #0]
 802021a:	1a8a      	subs	r2, r1, r2
 802021c:	601a      	str	r2, [r3, #0]
 802021e:	4b05      	ldr	r3, [pc, #20]	; (8020234 <OP_sub_dword+0x34>)
 8020220:	681b      	ldr	r3, [r3, #0]
 8020222:	3b04      	subs	r3, #4
 8020224:	4a03      	ldr	r2, [pc, #12]	; (8020234 <OP_sub_dword+0x34>)
 8020226:	6013      	str	r3, [r2, #0]

	return ;
 8020228:	bf00      	nop
}
 802022a:	46bd      	mov	sp, r7
 802022c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020230:	4770      	bx	lr
 8020232:	bf00      	nop
 8020234:	20012fcc 	.word	0x20012fcc

08020238 <OP_div_byte>:

/* --- div --- */
void OP_div_byte()
{
 8020238:	b480      	push	{r7}
 802023a:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(/);
 802023c:	4b0c      	ldr	r3, [pc, #48]	; (8020270 <OP_div_byte+0x38>)
 802023e:	681b      	ldr	r3, [r3, #0]
 8020240:	3b08      	subs	r3, #8
 8020242:	4a0b      	ldr	r2, [pc, #44]	; (8020270 <OP_div_byte+0x38>)
 8020244:	6812      	ldr	r2, [r2, #0]
 8020246:	3a08      	subs	r2, #8
 8020248:	7811      	ldrb	r1, [r2, #0]
 802024a:	4a09      	ldr	r2, [pc, #36]	; (8020270 <OP_div_byte+0x38>)
 802024c:	6812      	ldr	r2, [r2, #0]
 802024e:	3a04      	subs	r2, #4
 8020250:	7812      	ldrb	r2, [r2, #0]
 8020252:	fbb1 f2f2 	udiv	r2, r1, r2
 8020256:	b2d2      	uxtb	r2, r2
 8020258:	701a      	strb	r2, [r3, #0]
 802025a:	4b05      	ldr	r3, [pc, #20]	; (8020270 <OP_div_byte+0x38>)
 802025c:	681b      	ldr	r3, [r3, #0]
 802025e:	3b04      	subs	r3, #4
 8020260:	4a03      	ldr	r2, [pc, #12]	; (8020270 <OP_div_byte+0x38>)
 8020262:	6013      	str	r3, [r2, #0]

	return ;
 8020264:	bf00      	nop
}
 8020266:	46bd      	mov	sp, r7
 8020268:	f85d 7b04 	ldr.w	r7, [sp], #4
 802026c:	4770      	bx	lr
 802026e:	bf00      	nop
 8020270:	20012fcc 	.word	0x20012fcc

08020274 <OP_div_word>:

void OP_div_word()
{
 8020274:	b480      	push	{r7}
 8020276:	af00      	add	r7, sp, #0
	OP_BIN_WORD(/);
 8020278:	4b0d      	ldr	r3, [pc, #52]	; (80202b0 <OP_div_word+0x3c>)
 802027a:	681b      	ldr	r3, [r3, #0]
 802027c:	3b08      	subs	r3, #8
 802027e:	4a0c      	ldr	r2, [pc, #48]	; (80202b0 <OP_div_word+0x3c>)
 8020280:	6812      	ldr	r2, [r2, #0]
 8020282:	3a08      	subs	r2, #8
 8020284:	8812      	ldrh	r2, [r2, #0]
 8020286:	b211      	sxth	r1, r2
 8020288:	4a09      	ldr	r2, [pc, #36]	; (80202b0 <OP_div_word+0x3c>)
 802028a:	6812      	ldr	r2, [r2, #0]
 802028c:	3a04      	subs	r2, #4
 802028e:	8812      	ldrh	r2, [r2, #0]
 8020290:	b212      	sxth	r2, r2
 8020292:	fb91 f2f2 	sdiv	r2, r1, r2
 8020296:	b292      	uxth	r2, r2
 8020298:	801a      	strh	r2, [r3, #0]
 802029a:	4b05      	ldr	r3, [pc, #20]	; (80202b0 <OP_div_word+0x3c>)
 802029c:	681b      	ldr	r3, [r3, #0]
 802029e:	3b04      	subs	r3, #4
 80202a0:	4a03      	ldr	r2, [pc, #12]	; (80202b0 <OP_div_word+0x3c>)
 80202a2:	6013      	str	r3, [r2, #0]

	return ;
 80202a4:	bf00      	nop
}
 80202a6:	46bd      	mov	sp, r7
 80202a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80202ac:	4770      	bx	lr
 80202ae:	bf00      	nop
 80202b0:	20012fcc 	.word	0x20012fcc

080202b4 <OP_div_dword>:

void OP_div_dword()
{
 80202b4:	b480      	push	{r7}
 80202b6:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(/);
 80202b8:	4b0b      	ldr	r3, [pc, #44]	; (80202e8 <OP_div_dword+0x34>)
 80202ba:	681b      	ldr	r3, [r3, #0]
 80202bc:	3b08      	subs	r3, #8
 80202be:	4a0a      	ldr	r2, [pc, #40]	; (80202e8 <OP_div_dword+0x34>)
 80202c0:	6812      	ldr	r2, [r2, #0]
 80202c2:	3a08      	subs	r2, #8
 80202c4:	6811      	ldr	r1, [r2, #0]
 80202c6:	4a08      	ldr	r2, [pc, #32]	; (80202e8 <OP_div_dword+0x34>)
 80202c8:	6812      	ldr	r2, [r2, #0]
 80202ca:	3a04      	subs	r2, #4
 80202cc:	6812      	ldr	r2, [r2, #0]
 80202ce:	fb91 f2f2 	sdiv	r2, r1, r2
 80202d2:	601a      	str	r2, [r3, #0]
 80202d4:	4b04      	ldr	r3, [pc, #16]	; (80202e8 <OP_div_dword+0x34>)
 80202d6:	681b      	ldr	r3, [r3, #0]
 80202d8:	3b04      	subs	r3, #4
 80202da:	4a03      	ldr	r2, [pc, #12]	; (80202e8 <OP_div_dword+0x34>)
 80202dc:	6013      	str	r3, [r2, #0]

	return ;
 80202de:	bf00      	nop
}
 80202e0:	46bd      	mov	sp, r7
 80202e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80202e6:	4770      	bx	lr
 80202e8:	20012fcc 	.word	0x20012fcc

080202ec <OP_mod_byte>:

/* --- mod --- */
void OP_mod_byte()
{
 80202ec:	b480      	push	{r7}
 80202ee:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(%);
 80202f0:	4b0e      	ldr	r3, [pc, #56]	; (802032c <OP_mod_byte+0x40>)
 80202f2:	681b      	ldr	r3, [r3, #0]
 80202f4:	f1a3 0108 	sub.w	r1, r3, #8
 80202f8:	4b0c      	ldr	r3, [pc, #48]	; (802032c <OP_mod_byte+0x40>)
 80202fa:	681b      	ldr	r3, [r3, #0]
 80202fc:	3b08      	subs	r3, #8
 80202fe:	781b      	ldrb	r3, [r3, #0]
 8020300:	4a0a      	ldr	r2, [pc, #40]	; (802032c <OP_mod_byte+0x40>)
 8020302:	6812      	ldr	r2, [r2, #0]
 8020304:	3a04      	subs	r2, #4
 8020306:	7812      	ldrb	r2, [r2, #0]
 8020308:	fbb3 f0f2 	udiv	r0, r3, r2
 802030c:	fb02 f200 	mul.w	r2, r2, r0
 8020310:	1a9b      	subs	r3, r3, r2
 8020312:	b2db      	uxtb	r3, r3
 8020314:	700b      	strb	r3, [r1, #0]
 8020316:	4b05      	ldr	r3, [pc, #20]	; (802032c <OP_mod_byte+0x40>)
 8020318:	681b      	ldr	r3, [r3, #0]
 802031a:	3b04      	subs	r3, #4
 802031c:	4a03      	ldr	r2, [pc, #12]	; (802032c <OP_mod_byte+0x40>)
 802031e:	6013      	str	r3, [r2, #0]

	return ;
 8020320:	bf00      	nop
}
 8020322:	46bd      	mov	sp, r7
 8020324:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020328:	4770      	bx	lr
 802032a:	bf00      	nop
 802032c:	20012fcc 	.word	0x20012fcc

08020330 <OP_mod_word>:

void OP_mod_word()
{
 8020330:	b480      	push	{r7}
 8020332:	af00      	add	r7, sp, #0
	OP_BIN_WORD(%);
 8020334:	4b0f      	ldr	r3, [pc, #60]	; (8020374 <OP_mod_word+0x44>)
 8020336:	681b      	ldr	r3, [r3, #0]
 8020338:	f1a3 0108 	sub.w	r1, r3, #8
 802033c:	4b0d      	ldr	r3, [pc, #52]	; (8020374 <OP_mod_word+0x44>)
 802033e:	681b      	ldr	r3, [r3, #0]
 8020340:	3b08      	subs	r3, #8
 8020342:	881b      	ldrh	r3, [r3, #0]
 8020344:	b21b      	sxth	r3, r3
 8020346:	4a0b      	ldr	r2, [pc, #44]	; (8020374 <OP_mod_word+0x44>)
 8020348:	6812      	ldr	r2, [r2, #0]
 802034a:	3a04      	subs	r2, #4
 802034c:	8812      	ldrh	r2, [r2, #0]
 802034e:	b212      	sxth	r2, r2
 8020350:	fb93 f0f2 	sdiv	r0, r3, r2
 8020354:	fb02 f200 	mul.w	r2, r2, r0
 8020358:	1a9b      	subs	r3, r3, r2
 802035a:	b29b      	uxth	r3, r3
 802035c:	800b      	strh	r3, [r1, #0]
 802035e:	4b05      	ldr	r3, [pc, #20]	; (8020374 <OP_mod_word+0x44>)
 8020360:	681b      	ldr	r3, [r3, #0]
 8020362:	3b04      	subs	r3, #4
 8020364:	4a03      	ldr	r2, [pc, #12]	; (8020374 <OP_mod_word+0x44>)
 8020366:	6013      	str	r3, [r2, #0]

	return ;
 8020368:	bf00      	nop
}
 802036a:	46bd      	mov	sp, r7
 802036c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020370:	4770      	bx	lr
 8020372:	bf00      	nop
 8020374:	20012fcc 	.word	0x20012fcc

08020378 <OP_mod_dword>:

void OP_mod_dword()
{
 8020378:	b480      	push	{r7}
 802037a:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(%);
 802037c:	4b0d      	ldr	r3, [pc, #52]	; (80203b4 <OP_mod_dword+0x3c>)
 802037e:	681b      	ldr	r3, [r3, #0]
 8020380:	f1a3 0108 	sub.w	r1, r3, #8
 8020384:	4b0b      	ldr	r3, [pc, #44]	; (80203b4 <OP_mod_dword+0x3c>)
 8020386:	681b      	ldr	r3, [r3, #0]
 8020388:	3b08      	subs	r3, #8
 802038a:	681b      	ldr	r3, [r3, #0]
 802038c:	4a09      	ldr	r2, [pc, #36]	; (80203b4 <OP_mod_dword+0x3c>)
 802038e:	6812      	ldr	r2, [r2, #0]
 8020390:	3a04      	subs	r2, #4
 8020392:	6812      	ldr	r2, [r2, #0]
 8020394:	fb93 f0f2 	sdiv	r0, r3, r2
 8020398:	fb02 f200 	mul.w	r2, r2, r0
 802039c:	1a9b      	subs	r3, r3, r2
 802039e:	600b      	str	r3, [r1, #0]
 80203a0:	4b04      	ldr	r3, [pc, #16]	; (80203b4 <OP_mod_dword+0x3c>)
 80203a2:	681b      	ldr	r3, [r3, #0]
 80203a4:	3b04      	subs	r3, #4
 80203a6:	4a03      	ldr	r2, [pc, #12]	; (80203b4 <OP_mod_dword+0x3c>)
 80203a8:	6013      	str	r3, [r2, #0]

	return ;
 80203aa:	bf00      	nop
}
 80203ac:	46bd      	mov	sp, r7
 80203ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80203b2:	4770      	bx	lr
 80203b4:	20012fcc 	.word	0x20012fcc

080203b8 <OP_mul_byte>:

/* --- mul --- */
void OP_mul_byte()
{
 80203b8:	b480      	push	{r7}
 80203ba:	af00      	add	r7, sp, #0
    OP_BIN_BYTE(*);
 80203bc:	4b0c      	ldr	r3, [pc, #48]	; (80203f0 <OP_mul_byte+0x38>)
 80203be:	681b      	ldr	r3, [r3, #0]
 80203c0:	3b08      	subs	r3, #8
 80203c2:	4a0b      	ldr	r2, [pc, #44]	; (80203f0 <OP_mul_byte+0x38>)
 80203c4:	6812      	ldr	r2, [r2, #0]
 80203c6:	3a08      	subs	r2, #8
 80203c8:	7811      	ldrb	r1, [r2, #0]
 80203ca:	4a09      	ldr	r2, [pc, #36]	; (80203f0 <OP_mul_byte+0x38>)
 80203cc:	6812      	ldr	r2, [r2, #0]
 80203ce:	3a04      	subs	r2, #4
 80203d0:	7812      	ldrb	r2, [r2, #0]
 80203d2:	fb11 f202 	smulbb	r2, r1, r2
 80203d6:	b2d2      	uxtb	r2, r2
 80203d8:	701a      	strb	r2, [r3, #0]
 80203da:	4b05      	ldr	r3, [pc, #20]	; (80203f0 <OP_mul_byte+0x38>)
 80203dc:	681b      	ldr	r3, [r3, #0]
 80203de:	3b04      	subs	r3, #4
 80203e0:	4a03      	ldr	r2, [pc, #12]	; (80203f0 <OP_mul_byte+0x38>)
 80203e2:	6013      	str	r3, [r2, #0]

	return ;
 80203e4:	bf00      	nop
}
 80203e6:	46bd      	mov	sp, r7
 80203e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80203ec:	4770      	bx	lr
 80203ee:	bf00      	nop
 80203f0:	20012fcc 	.word	0x20012fcc

080203f4 <OP_mul_word>:

void OP_mul_word()
{
 80203f4:	b480      	push	{r7}
 80203f6:	af00      	add	r7, sp, #0
	OP_BIN_WORD(*);
 80203f8:	4b0d      	ldr	r3, [pc, #52]	; (8020430 <OP_mul_word+0x3c>)
 80203fa:	681b      	ldr	r3, [r3, #0]
 80203fc:	3b08      	subs	r3, #8
 80203fe:	4a0c      	ldr	r2, [pc, #48]	; (8020430 <OP_mul_word+0x3c>)
 8020400:	6812      	ldr	r2, [r2, #0]
 8020402:	3a08      	subs	r2, #8
 8020404:	8812      	ldrh	r2, [r2, #0]
 8020406:	b291      	uxth	r1, r2
 8020408:	4a09      	ldr	r2, [pc, #36]	; (8020430 <OP_mul_word+0x3c>)
 802040a:	6812      	ldr	r2, [r2, #0]
 802040c:	3a04      	subs	r2, #4
 802040e:	8812      	ldrh	r2, [r2, #0]
 8020410:	b292      	uxth	r2, r2
 8020412:	fb11 f202 	smulbb	r2, r1, r2
 8020416:	b292      	uxth	r2, r2
 8020418:	b292      	uxth	r2, r2
 802041a:	801a      	strh	r2, [r3, #0]
 802041c:	4b04      	ldr	r3, [pc, #16]	; (8020430 <OP_mul_word+0x3c>)
 802041e:	681b      	ldr	r3, [r3, #0]
 8020420:	3b04      	subs	r3, #4
 8020422:	4a03      	ldr	r2, [pc, #12]	; (8020430 <OP_mul_word+0x3c>)
 8020424:	6013      	str	r3, [r2, #0]

	return ;
 8020426:	bf00      	nop
}
 8020428:	46bd      	mov	sp, r7
 802042a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802042e:	4770      	bx	lr
 8020430:	20012fcc 	.word	0x20012fcc

08020434 <OP_mul_dword>:

void OP_mul_dword()
{
 8020434:	b480      	push	{r7}
 8020436:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(*);
 8020438:	4b0b      	ldr	r3, [pc, #44]	; (8020468 <OP_mul_dword+0x34>)
 802043a:	681b      	ldr	r3, [r3, #0]
 802043c:	3b08      	subs	r3, #8
 802043e:	4a0a      	ldr	r2, [pc, #40]	; (8020468 <OP_mul_dword+0x34>)
 8020440:	6812      	ldr	r2, [r2, #0]
 8020442:	3a08      	subs	r2, #8
 8020444:	6812      	ldr	r2, [r2, #0]
 8020446:	4908      	ldr	r1, [pc, #32]	; (8020468 <OP_mul_dword+0x34>)
 8020448:	6809      	ldr	r1, [r1, #0]
 802044a:	3904      	subs	r1, #4
 802044c:	6809      	ldr	r1, [r1, #0]
 802044e:	fb01 f202 	mul.w	r2, r1, r2
 8020452:	601a      	str	r2, [r3, #0]
 8020454:	4b04      	ldr	r3, [pc, #16]	; (8020468 <OP_mul_dword+0x34>)
 8020456:	681b      	ldr	r3, [r3, #0]
 8020458:	3b04      	subs	r3, #4
 802045a:	4a03      	ldr	r2, [pc, #12]	; (8020468 <OP_mul_dword+0x34>)
 802045c:	6013      	str	r3, [r2, #0]

	return ;
 802045e:	bf00      	nop
}
 8020460:	46bd      	mov	sp, r7
 8020462:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020466:	4770      	bx	lr
 8020468:	20012fcc 	.word	0x20012fcc

0802046c <OP_and_byte>:

/* --- and --- */
void OP_and_byte()
{
 802046c:	b480      	push	{r7}
 802046e:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(&);
 8020470:	4b0b      	ldr	r3, [pc, #44]	; (80204a0 <OP_and_byte+0x34>)
 8020472:	681b      	ldr	r3, [r3, #0]
 8020474:	3b08      	subs	r3, #8
 8020476:	4a0a      	ldr	r2, [pc, #40]	; (80204a0 <OP_and_byte+0x34>)
 8020478:	6812      	ldr	r2, [r2, #0]
 802047a:	3a08      	subs	r2, #8
 802047c:	7811      	ldrb	r1, [r2, #0]
 802047e:	4a08      	ldr	r2, [pc, #32]	; (80204a0 <OP_and_byte+0x34>)
 8020480:	6812      	ldr	r2, [r2, #0]
 8020482:	3a04      	subs	r2, #4
 8020484:	7812      	ldrb	r2, [r2, #0]
 8020486:	400a      	ands	r2, r1
 8020488:	b2d2      	uxtb	r2, r2
 802048a:	701a      	strb	r2, [r3, #0]
 802048c:	4b04      	ldr	r3, [pc, #16]	; (80204a0 <OP_and_byte+0x34>)
 802048e:	681b      	ldr	r3, [r3, #0]
 8020490:	3b04      	subs	r3, #4
 8020492:	4a03      	ldr	r2, [pc, #12]	; (80204a0 <OP_and_byte+0x34>)
 8020494:	6013      	str	r3, [r2, #0]

	return ;
 8020496:	bf00      	nop
}
 8020498:	46bd      	mov	sp, r7
 802049a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802049e:	4770      	bx	lr
 80204a0:	20012fcc 	.word	0x20012fcc

080204a4 <OP_and_word>:

void OP_and_word()
{
 80204a4:	b480      	push	{r7}
 80204a6:	af00      	add	r7, sp, #0
	OP_BIN_WORD(&);
 80204a8:	4b0b      	ldr	r3, [pc, #44]	; (80204d8 <OP_and_word+0x34>)
 80204aa:	681b      	ldr	r3, [r3, #0]
 80204ac:	3b08      	subs	r3, #8
 80204ae:	4a0a      	ldr	r2, [pc, #40]	; (80204d8 <OP_and_word+0x34>)
 80204b0:	6812      	ldr	r2, [r2, #0]
 80204b2:	3a08      	subs	r2, #8
 80204b4:	8811      	ldrh	r1, [r2, #0]
 80204b6:	4a08      	ldr	r2, [pc, #32]	; (80204d8 <OP_and_word+0x34>)
 80204b8:	6812      	ldr	r2, [r2, #0]
 80204ba:	3a04      	subs	r2, #4
 80204bc:	8812      	ldrh	r2, [r2, #0]
 80204be:	400a      	ands	r2, r1
 80204c0:	b292      	uxth	r2, r2
 80204c2:	801a      	strh	r2, [r3, #0]
 80204c4:	4b04      	ldr	r3, [pc, #16]	; (80204d8 <OP_and_word+0x34>)
 80204c6:	681b      	ldr	r3, [r3, #0]
 80204c8:	3b04      	subs	r3, #4
 80204ca:	4a03      	ldr	r2, [pc, #12]	; (80204d8 <OP_and_word+0x34>)
 80204cc:	6013      	str	r3, [r2, #0]

	return ;
 80204ce:	bf00      	nop
}
 80204d0:	46bd      	mov	sp, r7
 80204d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80204d6:	4770      	bx	lr
 80204d8:	20012fcc 	.word	0x20012fcc

080204dc <OP_and_dword>:

void OP_and_dword()
{
 80204dc:	b480      	push	{r7}
 80204de:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(&);
 80204e0:	4b0b      	ldr	r3, [pc, #44]	; (8020510 <OP_and_dword+0x34>)
 80204e2:	681b      	ldr	r3, [r3, #0]
 80204e4:	3b08      	subs	r3, #8
 80204e6:	4a0a      	ldr	r2, [pc, #40]	; (8020510 <OP_and_dword+0x34>)
 80204e8:	6812      	ldr	r2, [r2, #0]
 80204ea:	3a08      	subs	r2, #8
 80204ec:	6811      	ldr	r1, [r2, #0]
 80204ee:	4a08      	ldr	r2, [pc, #32]	; (8020510 <OP_and_dword+0x34>)
 80204f0:	6812      	ldr	r2, [r2, #0]
 80204f2:	3a04      	subs	r2, #4
 80204f4:	6812      	ldr	r2, [r2, #0]
 80204f6:	400a      	ands	r2, r1
 80204f8:	601a      	str	r2, [r3, #0]
 80204fa:	4b05      	ldr	r3, [pc, #20]	; (8020510 <OP_and_dword+0x34>)
 80204fc:	681b      	ldr	r3, [r3, #0]
 80204fe:	3b04      	subs	r3, #4
 8020500:	4a03      	ldr	r2, [pc, #12]	; (8020510 <OP_and_dword+0x34>)
 8020502:	6013      	str	r3, [r2, #0]

	return ;
 8020504:	bf00      	nop
}
 8020506:	46bd      	mov	sp, r7
 8020508:	f85d 7b04 	ldr.w	r7, [sp], #4
 802050c:	4770      	bx	lr
 802050e:	bf00      	nop
 8020510:	20012fcc 	.word	0x20012fcc

08020514 <OP_or_byte>:

/* --- or --- */
void OP_or_byte()
{
 8020514:	b480      	push	{r7}
 8020516:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(|);
 8020518:	4b0b      	ldr	r3, [pc, #44]	; (8020548 <OP_or_byte+0x34>)
 802051a:	681b      	ldr	r3, [r3, #0]
 802051c:	3b08      	subs	r3, #8
 802051e:	4a0a      	ldr	r2, [pc, #40]	; (8020548 <OP_or_byte+0x34>)
 8020520:	6812      	ldr	r2, [r2, #0]
 8020522:	3a08      	subs	r2, #8
 8020524:	7811      	ldrb	r1, [r2, #0]
 8020526:	4a08      	ldr	r2, [pc, #32]	; (8020548 <OP_or_byte+0x34>)
 8020528:	6812      	ldr	r2, [r2, #0]
 802052a:	3a04      	subs	r2, #4
 802052c:	7812      	ldrb	r2, [r2, #0]
 802052e:	430a      	orrs	r2, r1
 8020530:	b2d2      	uxtb	r2, r2
 8020532:	701a      	strb	r2, [r3, #0]
 8020534:	4b04      	ldr	r3, [pc, #16]	; (8020548 <OP_or_byte+0x34>)
 8020536:	681b      	ldr	r3, [r3, #0]
 8020538:	3b04      	subs	r3, #4
 802053a:	4a03      	ldr	r2, [pc, #12]	; (8020548 <OP_or_byte+0x34>)
 802053c:	6013      	str	r3, [r2, #0]

	return ;
 802053e:	bf00      	nop
}
 8020540:	46bd      	mov	sp, r7
 8020542:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020546:	4770      	bx	lr
 8020548:	20012fcc 	.word	0x20012fcc

0802054c <OP_or_word>:

void OP_or_word()
{
 802054c:	b480      	push	{r7}
 802054e:	af00      	add	r7, sp, #0
	OP_BIN_WORD(|);
 8020550:	4b0b      	ldr	r3, [pc, #44]	; (8020580 <OP_or_word+0x34>)
 8020552:	681b      	ldr	r3, [r3, #0]
 8020554:	3b08      	subs	r3, #8
 8020556:	4a0a      	ldr	r2, [pc, #40]	; (8020580 <OP_or_word+0x34>)
 8020558:	6812      	ldr	r2, [r2, #0]
 802055a:	3a08      	subs	r2, #8
 802055c:	8811      	ldrh	r1, [r2, #0]
 802055e:	4a08      	ldr	r2, [pc, #32]	; (8020580 <OP_or_word+0x34>)
 8020560:	6812      	ldr	r2, [r2, #0]
 8020562:	3a04      	subs	r2, #4
 8020564:	8812      	ldrh	r2, [r2, #0]
 8020566:	430a      	orrs	r2, r1
 8020568:	b292      	uxth	r2, r2
 802056a:	801a      	strh	r2, [r3, #0]
 802056c:	4b04      	ldr	r3, [pc, #16]	; (8020580 <OP_or_word+0x34>)
 802056e:	681b      	ldr	r3, [r3, #0]
 8020570:	3b04      	subs	r3, #4
 8020572:	4a03      	ldr	r2, [pc, #12]	; (8020580 <OP_or_word+0x34>)
 8020574:	6013      	str	r3, [r2, #0]

	return ;
 8020576:	bf00      	nop
}
 8020578:	46bd      	mov	sp, r7
 802057a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802057e:	4770      	bx	lr
 8020580:	20012fcc 	.word	0x20012fcc

08020584 <OP_or_dword>:

void OP_or_dword()
{
 8020584:	b480      	push	{r7}
 8020586:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(|);
 8020588:	4b0b      	ldr	r3, [pc, #44]	; (80205b8 <OP_or_dword+0x34>)
 802058a:	681b      	ldr	r3, [r3, #0]
 802058c:	3b08      	subs	r3, #8
 802058e:	4a0a      	ldr	r2, [pc, #40]	; (80205b8 <OP_or_dword+0x34>)
 8020590:	6812      	ldr	r2, [r2, #0]
 8020592:	3a08      	subs	r2, #8
 8020594:	6811      	ldr	r1, [r2, #0]
 8020596:	4a08      	ldr	r2, [pc, #32]	; (80205b8 <OP_or_dword+0x34>)
 8020598:	6812      	ldr	r2, [r2, #0]
 802059a:	3a04      	subs	r2, #4
 802059c:	6812      	ldr	r2, [r2, #0]
 802059e:	430a      	orrs	r2, r1
 80205a0:	601a      	str	r2, [r3, #0]
 80205a2:	4b05      	ldr	r3, [pc, #20]	; (80205b8 <OP_or_dword+0x34>)
 80205a4:	681b      	ldr	r3, [r3, #0]
 80205a6:	3b04      	subs	r3, #4
 80205a8:	4a03      	ldr	r2, [pc, #12]	; (80205b8 <OP_or_dword+0x34>)
 80205aa:	6013      	str	r3, [r2, #0]

	return ;
 80205ac:	bf00      	nop
}
 80205ae:	46bd      	mov	sp, r7
 80205b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80205b4:	4770      	bx	lr
 80205b6:	bf00      	nop
 80205b8:	20012fcc 	.word	0x20012fcc

080205bc <OP_xor_byte>:

/* --- xor --- */
void OP_xor_byte()
{
 80205bc:	b480      	push	{r7}
 80205be:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(^);
 80205c0:	4b0b      	ldr	r3, [pc, #44]	; (80205f0 <OP_xor_byte+0x34>)
 80205c2:	681b      	ldr	r3, [r3, #0]
 80205c4:	3b08      	subs	r3, #8
 80205c6:	4a0a      	ldr	r2, [pc, #40]	; (80205f0 <OP_xor_byte+0x34>)
 80205c8:	6812      	ldr	r2, [r2, #0]
 80205ca:	3a08      	subs	r2, #8
 80205cc:	7811      	ldrb	r1, [r2, #0]
 80205ce:	4a08      	ldr	r2, [pc, #32]	; (80205f0 <OP_xor_byte+0x34>)
 80205d0:	6812      	ldr	r2, [r2, #0]
 80205d2:	3a04      	subs	r2, #4
 80205d4:	7812      	ldrb	r2, [r2, #0]
 80205d6:	404a      	eors	r2, r1
 80205d8:	b2d2      	uxtb	r2, r2
 80205da:	701a      	strb	r2, [r3, #0]
 80205dc:	4b04      	ldr	r3, [pc, #16]	; (80205f0 <OP_xor_byte+0x34>)
 80205de:	681b      	ldr	r3, [r3, #0]
 80205e0:	3b04      	subs	r3, #4
 80205e2:	4a03      	ldr	r2, [pc, #12]	; (80205f0 <OP_xor_byte+0x34>)
 80205e4:	6013      	str	r3, [r2, #0]

	return ;
 80205e6:	bf00      	nop
}
 80205e8:	46bd      	mov	sp, r7
 80205ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80205ee:	4770      	bx	lr
 80205f0:	20012fcc 	.word	0x20012fcc

080205f4 <OP_xor_word>:

void OP_xor_word()
{
 80205f4:	b480      	push	{r7}
 80205f6:	af00      	add	r7, sp, #0
	OP_BIN_WORD(^);
 80205f8:	4b0b      	ldr	r3, [pc, #44]	; (8020628 <OP_xor_word+0x34>)
 80205fa:	681b      	ldr	r3, [r3, #0]
 80205fc:	3b08      	subs	r3, #8
 80205fe:	4a0a      	ldr	r2, [pc, #40]	; (8020628 <OP_xor_word+0x34>)
 8020600:	6812      	ldr	r2, [r2, #0]
 8020602:	3a08      	subs	r2, #8
 8020604:	8811      	ldrh	r1, [r2, #0]
 8020606:	4a08      	ldr	r2, [pc, #32]	; (8020628 <OP_xor_word+0x34>)
 8020608:	6812      	ldr	r2, [r2, #0]
 802060a:	3a04      	subs	r2, #4
 802060c:	8812      	ldrh	r2, [r2, #0]
 802060e:	404a      	eors	r2, r1
 8020610:	b292      	uxth	r2, r2
 8020612:	801a      	strh	r2, [r3, #0]
 8020614:	4b04      	ldr	r3, [pc, #16]	; (8020628 <OP_xor_word+0x34>)
 8020616:	681b      	ldr	r3, [r3, #0]
 8020618:	3b04      	subs	r3, #4
 802061a:	4a03      	ldr	r2, [pc, #12]	; (8020628 <OP_xor_word+0x34>)
 802061c:	6013      	str	r3, [r2, #0]

	return ;
 802061e:	bf00      	nop
}
 8020620:	46bd      	mov	sp, r7
 8020622:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020626:	4770      	bx	lr
 8020628:	20012fcc 	.word	0x20012fcc

0802062c <OP_xor_dword>:

void OP_xor_dword()
{
 802062c:	b480      	push	{r7}
 802062e:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(^);
 8020630:	4b0b      	ldr	r3, [pc, #44]	; (8020660 <OP_xor_dword+0x34>)
 8020632:	681b      	ldr	r3, [r3, #0]
 8020634:	3b08      	subs	r3, #8
 8020636:	4a0a      	ldr	r2, [pc, #40]	; (8020660 <OP_xor_dword+0x34>)
 8020638:	6812      	ldr	r2, [r2, #0]
 802063a:	3a08      	subs	r2, #8
 802063c:	6811      	ldr	r1, [r2, #0]
 802063e:	4a08      	ldr	r2, [pc, #32]	; (8020660 <OP_xor_dword+0x34>)
 8020640:	6812      	ldr	r2, [r2, #0]
 8020642:	3a04      	subs	r2, #4
 8020644:	6812      	ldr	r2, [r2, #0]
 8020646:	404a      	eors	r2, r1
 8020648:	601a      	str	r2, [r3, #0]
 802064a:	4b05      	ldr	r3, [pc, #20]	; (8020660 <OP_xor_dword+0x34>)
 802064c:	681b      	ldr	r3, [r3, #0]
 802064e:	3b04      	subs	r3, #4
 8020650:	4a03      	ldr	r2, [pc, #12]	; (8020660 <OP_xor_dword+0x34>)
 8020652:	6013      	str	r3, [r2, #0]

	return ;
 8020654:	bf00      	nop
}
 8020656:	46bd      	mov	sp, r7
 8020658:	f85d 7b04 	ldr.w	r7, [sp], #4
 802065c:	4770      	bx	lr
 802065e:	bf00      	nop
 8020660:	20012fcc 	.word	0x20012fcc

08020664 <OP_bw_byte>:

/* --- bw --- */
void OP_bw_byte()
{
 8020664:	b480      	push	{r7}
 8020666:	af00      	add	r7, sp, #0
	(finsh_sp - 1)->char_value = ~ ((finsh_sp - 1)->char_value);
 8020668:	4b07      	ldr	r3, [pc, #28]	; (8020688 <OP_bw_byte+0x24>)
 802066a:	681b      	ldr	r3, [r3, #0]
 802066c:	3b04      	subs	r3, #4
 802066e:	4a06      	ldr	r2, [pc, #24]	; (8020688 <OP_bw_byte+0x24>)
 8020670:	6812      	ldr	r2, [r2, #0]
 8020672:	3a04      	subs	r2, #4
 8020674:	7812      	ldrb	r2, [r2, #0]
 8020676:	43d2      	mvns	r2, r2
 8020678:	b2d2      	uxtb	r2, r2
 802067a:	701a      	strb	r2, [r3, #0]

	return ;
 802067c:	bf00      	nop
}
 802067e:	46bd      	mov	sp, r7
 8020680:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020684:	4770      	bx	lr
 8020686:	bf00      	nop
 8020688:	20012fcc 	.word	0x20012fcc

0802068c <OP_bw_word>:

void OP_bw_word()
{
 802068c:	b480      	push	{r7}
 802068e:	af00      	add	r7, sp, #0
	(finsh_sp - 1)->short_value = ~ ((finsh_sp - 1)->short_value);
 8020690:	4b07      	ldr	r3, [pc, #28]	; (80206b0 <OP_bw_word+0x24>)
 8020692:	681b      	ldr	r3, [r3, #0]
 8020694:	3b04      	subs	r3, #4
 8020696:	4a06      	ldr	r2, [pc, #24]	; (80206b0 <OP_bw_word+0x24>)
 8020698:	6812      	ldr	r2, [r2, #0]
 802069a:	3a04      	subs	r2, #4
 802069c:	8812      	ldrh	r2, [r2, #0]
 802069e:	43d2      	mvns	r2, r2
 80206a0:	b292      	uxth	r2, r2
 80206a2:	801a      	strh	r2, [r3, #0]

	return ;
 80206a4:	bf00      	nop
}
 80206a6:	46bd      	mov	sp, r7
 80206a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80206ac:	4770      	bx	lr
 80206ae:	bf00      	nop
 80206b0:	20012fcc 	.word	0x20012fcc

080206b4 <OP_bw_dword>:

void OP_bw_dword()
{
 80206b4:	b480      	push	{r7}
 80206b6:	af00      	add	r7, sp, #0
	(finsh_sp - 1)->long_value = ~ ((finsh_sp - 1)->long_value);
 80206b8:	4b06      	ldr	r3, [pc, #24]	; (80206d4 <OP_bw_dword+0x20>)
 80206ba:	681b      	ldr	r3, [r3, #0]
 80206bc:	3b04      	subs	r3, #4
 80206be:	4a05      	ldr	r2, [pc, #20]	; (80206d4 <OP_bw_dword+0x20>)
 80206c0:	6812      	ldr	r2, [r2, #0]
 80206c2:	3a04      	subs	r2, #4
 80206c4:	6812      	ldr	r2, [r2, #0]
 80206c6:	43d2      	mvns	r2, r2
 80206c8:	601a      	str	r2, [r3, #0]

	return ;
 80206ca:	bf00      	nop
}
 80206cc:	46bd      	mov	sp, r7
 80206ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80206d2:	4770      	bx	lr
 80206d4:	20012fcc 	.word	0x20012fcc

080206d8 <OP_shl_byte>:

/* --- shl --- */
void OP_shl_byte()
{
 80206d8:	b480      	push	{r7}
 80206da:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(<<);
 80206dc:	4b0c      	ldr	r3, [pc, #48]	; (8020710 <OP_shl_byte+0x38>)
 80206de:	681b      	ldr	r3, [r3, #0]
 80206e0:	3b08      	subs	r3, #8
 80206e2:	4a0b      	ldr	r2, [pc, #44]	; (8020710 <OP_shl_byte+0x38>)
 80206e4:	6812      	ldr	r2, [r2, #0]
 80206e6:	3a08      	subs	r2, #8
 80206e8:	7812      	ldrb	r2, [r2, #0]
 80206ea:	4611      	mov	r1, r2
 80206ec:	4a08      	ldr	r2, [pc, #32]	; (8020710 <OP_shl_byte+0x38>)
 80206ee:	6812      	ldr	r2, [r2, #0]
 80206f0:	3a04      	subs	r2, #4
 80206f2:	7812      	ldrb	r2, [r2, #0]
 80206f4:	fa01 f202 	lsl.w	r2, r1, r2
 80206f8:	b2d2      	uxtb	r2, r2
 80206fa:	701a      	strb	r2, [r3, #0]
 80206fc:	4b04      	ldr	r3, [pc, #16]	; (8020710 <OP_shl_byte+0x38>)
 80206fe:	681b      	ldr	r3, [r3, #0]
 8020700:	3b04      	subs	r3, #4
 8020702:	4a03      	ldr	r2, [pc, #12]	; (8020710 <OP_shl_byte+0x38>)
 8020704:	6013      	str	r3, [r2, #0]

	return ;
 8020706:	bf00      	nop
}
 8020708:	46bd      	mov	sp, r7
 802070a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802070e:	4770      	bx	lr
 8020710:	20012fcc 	.word	0x20012fcc

08020714 <OP_shl_word>:

void OP_shl_word()
{
 8020714:	b480      	push	{r7}
 8020716:	af00      	add	r7, sp, #0
	OP_BIN_WORD(<<);
 8020718:	4b0d      	ldr	r3, [pc, #52]	; (8020750 <OP_shl_word+0x3c>)
 802071a:	681b      	ldr	r3, [r3, #0]
 802071c:	3b08      	subs	r3, #8
 802071e:	4a0c      	ldr	r2, [pc, #48]	; (8020750 <OP_shl_word+0x3c>)
 8020720:	6812      	ldr	r2, [r2, #0]
 8020722:	3a08      	subs	r2, #8
 8020724:	8812      	ldrh	r2, [r2, #0]
 8020726:	b211      	sxth	r1, r2
 8020728:	4a09      	ldr	r2, [pc, #36]	; (8020750 <OP_shl_word+0x3c>)
 802072a:	6812      	ldr	r2, [r2, #0]
 802072c:	3a04      	subs	r2, #4
 802072e:	8812      	ldrh	r2, [r2, #0]
 8020730:	b212      	sxth	r2, r2
 8020732:	fa01 f202 	lsl.w	r2, r1, r2
 8020736:	b292      	uxth	r2, r2
 8020738:	801a      	strh	r2, [r3, #0]
 802073a:	4b05      	ldr	r3, [pc, #20]	; (8020750 <OP_shl_word+0x3c>)
 802073c:	681b      	ldr	r3, [r3, #0]
 802073e:	3b04      	subs	r3, #4
 8020740:	4a03      	ldr	r2, [pc, #12]	; (8020750 <OP_shl_word+0x3c>)
 8020742:	6013      	str	r3, [r2, #0]

	return ;
 8020744:	bf00      	nop
}
 8020746:	46bd      	mov	sp, r7
 8020748:	f85d 7b04 	ldr.w	r7, [sp], #4
 802074c:	4770      	bx	lr
 802074e:	bf00      	nop
 8020750:	20012fcc 	.word	0x20012fcc

08020754 <OP_shl_dword>:

void OP_shl_dword()
{
 8020754:	b480      	push	{r7}
 8020756:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(<<);
 8020758:	4b0b      	ldr	r3, [pc, #44]	; (8020788 <OP_shl_dword+0x34>)
 802075a:	681b      	ldr	r3, [r3, #0]
 802075c:	3b08      	subs	r3, #8
 802075e:	4a0a      	ldr	r2, [pc, #40]	; (8020788 <OP_shl_dword+0x34>)
 8020760:	6812      	ldr	r2, [r2, #0]
 8020762:	3a08      	subs	r2, #8
 8020764:	6811      	ldr	r1, [r2, #0]
 8020766:	4a08      	ldr	r2, [pc, #32]	; (8020788 <OP_shl_dword+0x34>)
 8020768:	6812      	ldr	r2, [r2, #0]
 802076a:	3a04      	subs	r2, #4
 802076c:	6812      	ldr	r2, [r2, #0]
 802076e:	fa01 f202 	lsl.w	r2, r1, r2
 8020772:	601a      	str	r2, [r3, #0]
 8020774:	4b04      	ldr	r3, [pc, #16]	; (8020788 <OP_shl_dword+0x34>)
 8020776:	681b      	ldr	r3, [r3, #0]
 8020778:	3b04      	subs	r3, #4
 802077a:	4a03      	ldr	r2, [pc, #12]	; (8020788 <OP_shl_dword+0x34>)
 802077c:	6013      	str	r3, [r2, #0]

	return ;
 802077e:	bf00      	nop
}
 8020780:	46bd      	mov	sp, r7
 8020782:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020786:	4770      	bx	lr
 8020788:	20012fcc 	.word	0x20012fcc

0802078c <OP_shr_byte>:

/* --- shr --- */
void OP_shr_byte()
{
 802078c:	b480      	push	{r7}
 802078e:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(>>);
 8020790:	4b0c      	ldr	r3, [pc, #48]	; (80207c4 <OP_shr_byte+0x38>)
 8020792:	681b      	ldr	r3, [r3, #0]
 8020794:	3b08      	subs	r3, #8
 8020796:	4a0b      	ldr	r2, [pc, #44]	; (80207c4 <OP_shr_byte+0x38>)
 8020798:	6812      	ldr	r2, [r2, #0]
 802079a:	3a08      	subs	r2, #8
 802079c:	7812      	ldrb	r2, [r2, #0]
 802079e:	4611      	mov	r1, r2
 80207a0:	4a08      	ldr	r2, [pc, #32]	; (80207c4 <OP_shr_byte+0x38>)
 80207a2:	6812      	ldr	r2, [r2, #0]
 80207a4:	3a04      	subs	r2, #4
 80207a6:	7812      	ldrb	r2, [r2, #0]
 80207a8:	fa41 f202 	asr.w	r2, r1, r2
 80207ac:	b2d2      	uxtb	r2, r2
 80207ae:	701a      	strb	r2, [r3, #0]
 80207b0:	4b04      	ldr	r3, [pc, #16]	; (80207c4 <OP_shr_byte+0x38>)
 80207b2:	681b      	ldr	r3, [r3, #0]
 80207b4:	3b04      	subs	r3, #4
 80207b6:	4a03      	ldr	r2, [pc, #12]	; (80207c4 <OP_shr_byte+0x38>)
 80207b8:	6013      	str	r3, [r2, #0]

	return ;
 80207ba:	bf00      	nop
}
 80207bc:	46bd      	mov	sp, r7
 80207be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80207c2:	4770      	bx	lr
 80207c4:	20012fcc 	.word	0x20012fcc

080207c8 <OP_shr_word>:

void OP_shr_word()
{
 80207c8:	b480      	push	{r7}
 80207ca:	af00      	add	r7, sp, #0
	OP_BIN_WORD(>>);
 80207cc:	4b0d      	ldr	r3, [pc, #52]	; (8020804 <OP_shr_word+0x3c>)
 80207ce:	681b      	ldr	r3, [r3, #0]
 80207d0:	3b08      	subs	r3, #8
 80207d2:	4a0c      	ldr	r2, [pc, #48]	; (8020804 <OP_shr_word+0x3c>)
 80207d4:	6812      	ldr	r2, [r2, #0]
 80207d6:	3a08      	subs	r2, #8
 80207d8:	8812      	ldrh	r2, [r2, #0]
 80207da:	b211      	sxth	r1, r2
 80207dc:	4a09      	ldr	r2, [pc, #36]	; (8020804 <OP_shr_word+0x3c>)
 80207de:	6812      	ldr	r2, [r2, #0]
 80207e0:	3a04      	subs	r2, #4
 80207e2:	8812      	ldrh	r2, [r2, #0]
 80207e4:	b212      	sxth	r2, r2
 80207e6:	fa41 f202 	asr.w	r2, r1, r2
 80207ea:	b292      	uxth	r2, r2
 80207ec:	801a      	strh	r2, [r3, #0]
 80207ee:	4b05      	ldr	r3, [pc, #20]	; (8020804 <OP_shr_word+0x3c>)
 80207f0:	681b      	ldr	r3, [r3, #0]
 80207f2:	3b04      	subs	r3, #4
 80207f4:	4a03      	ldr	r2, [pc, #12]	; (8020804 <OP_shr_word+0x3c>)
 80207f6:	6013      	str	r3, [r2, #0]

	return ;
 80207f8:	bf00      	nop
}
 80207fa:	46bd      	mov	sp, r7
 80207fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020800:	4770      	bx	lr
 8020802:	bf00      	nop
 8020804:	20012fcc 	.word	0x20012fcc

08020808 <OP_shr_dword>:

void OP_shr_dword()
{
 8020808:	b480      	push	{r7}
 802080a:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(>>);
 802080c:	4b0b      	ldr	r3, [pc, #44]	; (802083c <OP_shr_dword+0x34>)
 802080e:	681b      	ldr	r3, [r3, #0]
 8020810:	3b08      	subs	r3, #8
 8020812:	4a0a      	ldr	r2, [pc, #40]	; (802083c <OP_shr_dword+0x34>)
 8020814:	6812      	ldr	r2, [r2, #0]
 8020816:	3a08      	subs	r2, #8
 8020818:	6811      	ldr	r1, [r2, #0]
 802081a:	4a08      	ldr	r2, [pc, #32]	; (802083c <OP_shr_dword+0x34>)
 802081c:	6812      	ldr	r2, [r2, #0]
 802081e:	3a04      	subs	r2, #4
 8020820:	6812      	ldr	r2, [r2, #0]
 8020822:	fa41 f202 	asr.w	r2, r1, r2
 8020826:	601a      	str	r2, [r3, #0]
 8020828:	4b04      	ldr	r3, [pc, #16]	; (802083c <OP_shr_dword+0x34>)
 802082a:	681b      	ldr	r3, [r3, #0]
 802082c:	3b04      	subs	r3, #4
 802082e:	4a03      	ldr	r2, [pc, #12]	; (802083c <OP_shr_dword+0x34>)
 8020830:	6013      	str	r3, [r2, #0]

	return ;
 8020832:	bf00      	nop
}
 8020834:	46bd      	mov	sp, r7
 8020836:	f85d 7b04 	ldr.w	r7, [sp], #4
 802083a:	4770      	bx	lr
 802083c:	20012fcc 	.word	0x20012fcc

08020840 <OP_ld_byte>:

/* --- ld --- */
void OP_ld_byte()
{
 8020840:	b480      	push	{r7}
 8020842:	af00      	add	r7, sp, #0
	finsh_sp->char_value = *finsh_pc;
 8020844:	4b0a      	ldr	r3, [pc, #40]	; (8020870 <OP_ld_byte+0x30>)
 8020846:	681b      	ldr	r3, [r3, #0]
 8020848:	4a0a      	ldr	r2, [pc, #40]	; (8020874 <OP_ld_byte+0x34>)
 802084a:	6812      	ldr	r2, [r2, #0]
 802084c:	7812      	ldrb	r2, [r2, #0]
 802084e:	701a      	strb	r2, [r3, #0]

	finsh_sp++;
 8020850:	4b07      	ldr	r3, [pc, #28]	; (8020870 <OP_ld_byte+0x30>)
 8020852:	681b      	ldr	r3, [r3, #0]
 8020854:	3304      	adds	r3, #4
 8020856:	4a06      	ldr	r2, [pc, #24]	; (8020870 <OP_ld_byte+0x30>)
 8020858:	6013      	str	r3, [r2, #0]
	finsh_pc++;
 802085a:	4b06      	ldr	r3, [pc, #24]	; (8020874 <OP_ld_byte+0x34>)
 802085c:	681b      	ldr	r3, [r3, #0]
 802085e:	3301      	adds	r3, #1
 8020860:	4a04      	ldr	r2, [pc, #16]	; (8020874 <OP_ld_byte+0x34>)
 8020862:	6013      	str	r3, [r2, #0]

	return ;
 8020864:	bf00      	nop
}
 8020866:	46bd      	mov	sp, r7
 8020868:	f85d 7b04 	ldr.w	r7, [sp], #4
 802086c:	4770      	bx	lr
 802086e:	bf00      	nop
 8020870:	20012fcc 	.word	0x20012fcc
 8020874:	20012fc8 	.word	0x20012fc8

08020878 <OP_ld_word>:

void OP_ld_word()
{
 8020878:	b480      	push	{r7}
 802087a:	af00      	add	r7, sp, #0
	finsh_sp->short_value = FINSH_GET16(finsh_pc);
 802087c:	4b0e      	ldr	r3, [pc, #56]	; (80208b8 <OP_ld_word+0x40>)
 802087e:	681b      	ldr	r3, [r3, #0]
 8020880:	4a0e      	ldr	r2, [pc, #56]	; (80208bc <OP_ld_word+0x44>)
 8020882:	6812      	ldr	r2, [r2, #0]
 8020884:	7812      	ldrb	r2, [r2, #0]
 8020886:	b291      	uxth	r1, r2
 8020888:	4a0c      	ldr	r2, [pc, #48]	; (80208bc <OP_ld_word+0x44>)
 802088a:	6812      	ldr	r2, [r2, #0]
 802088c:	3201      	adds	r2, #1
 802088e:	7812      	ldrb	r2, [r2, #0]
 8020890:	0212      	lsls	r2, r2, #8
 8020892:	b292      	uxth	r2, r2
 8020894:	430a      	orrs	r2, r1
 8020896:	b292      	uxth	r2, r2
 8020898:	801a      	strh	r2, [r3, #0]

	finsh_sp ++;
 802089a:	4b07      	ldr	r3, [pc, #28]	; (80208b8 <OP_ld_word+0x40>)
 802089c:	681b      	ldr	r3, [r3, #0]
 802089e:	3304      	adds	r3, #4
 80208a0:	4a05      	ldr	r2, [pc, #20]	; (80208b8 <OP_ld_word+0x40>)
 80208a2:	6013      	str	r3, [r2, #0]
	finsh_pc += 2;
 80208a4:	4b05      	ldr	r3, [pc, #20]	; (80208bc <OP_ld_word+0x44>)
 80208a6:	681b      	ldr	r3, [r3, #0]
 80208a8:	3302      	adds	r3, #2
 80208aa:	4a04      	ldr	r2, [pc, #16]	; (80208bc <OP_ld_word+0x44>)
 80208ac:	6013      	str	r3, [r2, #0]

	return ;
 80208ae:	bf00      	nop
}
 80208b0:	46bd      	mov	sp, r7
 80208b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80208b6:	4770      	bx	lr
 80208b8:	20012fcc 	.word	0x20012fcc
 80208bc:	20012fc8 	.word	0x20012fc8

080208c0 <OP_ld_dword>:

void OP_ld_dword()
{
 80208c0:	b480      	push	{r7}
 80208c2:	af00      	add	r7, sp, #0
	finsh_sp->long_value = FINSH_GET32(finsh_pc);
 80208c4:	4b13      	ldr	r3, [pc, #76]	; (8020914 <OP_ld_dword+0x54>)
 80208c6:	681b      	ldr	r3, [r3, #0]
 80208c8:	4a13      	ldr	r2, [pc, #76]	; (8020918 <OP_ld_dword+0x58>)
 80208ca:	6812      	ldr	r2, [r2, #0]
 80208cc:	7812      	ldrb	r2, [r2, #0]
 80208ce:	4611      	mov	r1, r2
 80208d0:	4a11      	ldr	r2, [pc, #68]	; (8020918 <OP_ld_dword+0x58>)
 80208d2:	6812      	ldr	r2, [r2, #0]
 80208d4:	3201      	adds	r2, #1
 80208d6:	7812      	ldrb	r2, [r2, #0]
 80208d8:	0212      	lsls	r2, r2, #8
 80208da:	4311      	orrs	r1, r2
 80208dc:	4a0e      	ldr	r2, [pc, #56]	; (8020918 <OP_ld_dword+0x58>)
 80208de:	6812      	ldr	r2, [r2, #0]
 80208e0:	3202      	adds	r2, #2
 80208e2:	7812      	ldrb	r2, [r2, #0]
 80208e4:	0412      	lsls	r2, r2, #16
 80208e6:	4311      	orrs	r1, r2
 80208e8:	4a0b      	ldr	r2, [pc, #44]	; (8020918 <OP_ld_dword+0x58>)
 80208ea:	6812      	ldr	r2, [r2, #0]
 80208ec:	3203      	adds	r2, #3
 80208ee:	7812      	ldrb	r2, [r2, #0]
 80208f0:	0612      	lsls	r2, r2, #24
 80208f2:	430a      	orrs	r2, r1
 80208f4:	601a      	str	r2, [r3, #0]

	finsh_sp ++;
 80208f6:	4b07      	ldr	r3, [pc, #28]	; (8020914 <OP_ld_dword+0x54>)
 80208f8:	681b      	ldr	r3, [r3, #0]
 80208fa:	3304      	adds	r3, #4
 80208fc:	4a05      	ldr	r2, [pc, #20]	; (8020914 <OP_ld_dword+0x54>)
 80208fe:	6013      	str	r3, [r2, #0]
	finsh_pc += 4;
 8020900:	4b05      	ldr	r3, [pc, #20]	; (8020918 <OP_ld_dword+0x58>)
 8020902:	681b      	ldr	r3, [r3, #0]
 8020904:	3304      	adds	r3, #4
 8020906:	4a04      	ldr	r2, [pc, #16]	; (8020918 <OP_ld_dword+0x58>)
 8020908:	6013      	str	r3, [r2, #0]

	return ;
 802090a:	bf00      	nop
}
 802090c:	46bd      	mov	sp, r7
 802090e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020912:	4770      	bx	lr
 8020914:	20012fcc 	.word	0x20012fcc
 8020918:	20012fc8 	.word	0x20012fc8

0802091c <OP_ld_value_byte>:

void OP_ld_value_byte()
{
 802091c:	b480      	push	{r7}
 802091e:	b083      	sub	sp, #12
 8020920:	af00      	add	r7, sp, #0
	char* c;

	c = (char*) (FINSH_GET32(finsh_pc));
 8020922:	4b16      	ldr	r3, [pc, #88]	; (802097c <OP_ld_value_byte+0x60>)
 8020924:	681b      	ldr	r3, [r3, #0]
 8020926:	781b      	ldrb	r3, [r3, #0]
 8020928:	461a      	mov	r2, r3
 802092a:	4b14      	ldr	r3, [pc, #80]	; (802097c <OP_ld_value_byte+0x60>)
 802092c:	681b      	ldr	r3, [r3, #0]
 802092e:	3301      	adds	r3, #1
 8020930:	781b      	ldrb	r3, [r3, #0]
 8020932:	021b      	lsls	r3, r3, #8
 8020934:	431a      	orrs	r2, r3
 8020936:	4b11      	ldr	r3, [pc, #68]	; (802097c <OP_ld_value_byte+0x60>)
 8020938:	681b      	ldr	r3, [r3, #0]
 802093a:	3302      	adds	r3, #2
 802093c:	781b      	ldrb	r3, [r3, #0]
 802093e:	041b      	lsls	r3, r3, #16
 8020940:	431a      	orrs	r2, r3
 8020942:	4b0e      	ldr	r3, [pc, #56]	; (802097c <OP_ld_value_byte+0x60>)
 8020944:	681b      	ldr	r3, [r3, #0]
 8020946:	3303      	adds	r3, #3
 8020948:	781b      	ldrb	r3, [r3, #0]
 802094a:	061b      	lsls	r3, r3, #24
 802094c:	4313      	orrs	r3, r2
 802094e:	607b      	str	r3, [r7, #4]

	finsh_sp->char_value = *c;
 8020950:	4b0b      	ldr	r3, [pc, #44]	; (8020980 <OP_ld_value_byte+0x64>)
 8020952:	681b      	ldr	r3, [r3, #0]
 8020954:	687a      	ldr	r2, [r7, #4]
 8020956:	7812      	ldrb	r2, [r2, #0]
 8020958:	701a      	strb	r2, [r3, #0]

	finsh_sp ++;
 802095a:	4b09      	ldr	r3, [pc, #36]	; (8020980 <OP_ld_value_byte+0x64>)
 802095c:	681b      	ldr	r3, [r3, #0]
 802095e:	3304      	adds	r3, #4
 8020960:	4a07      	ldr	r2, [pc, #28]	; (8020980 <OP_ld_value_byte+0x64>)
 8020962:	6013      	str	r3, [r2, #0]
	finsh_pc += 4;
 8020964:	4b05      	ldr	r3, [pc, #20]	; (802097c <OP_ld_value_byte+0x60>)
 8020966:	681b      	ldr	r3, [r3, #0]
 8020968:	3304      	adds	r3, #4
 802096a:	4a04      	ldr	r2, [pc, #16]	; (802097c <OP_ld_value_byte+0x60>)
 802096c:	6013      	str	r3, [r2, #0]

	return;
 802096e:	bf00      	nop
}
 8020970:	370c      	adds	r7, #12
 8020972:	46bd      	mov	sp, r7
 8020974:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020978:	4770      	bx	lr
 802097a:	bf00      	nop
 802097c:	20012fc8 	.word	0x20012fc8
 8020980:	20012fcc 	.word	0x20012fcc

08020984 <OP_ld_value_byte_stack>:

void OP_ld_value_byte_stack()
{
 8020984:	b480      	push	{r7}
 8020986:	b083      	sub	sp, #12
 8020988:	af00      	add	r7, sp, #0
	char* c;

	c = (char *)(finsh_sp - 1)->long_value;
 802098a:	4b08      	ldr	r3, [pc, #32]	; (80209ac <OP_ld_value_byte_stack+0x28>)
 802098c:	681b      	ldr	r3, [r3, #0]
 802098e:	3b04      	subs	r3, #4
 8020990:	681b      	ldr	r3, [r3, #0]
 8020992:	607b      	str	r3, [r7, #4]
	(finsh_sp - 1)->char_value = *c;
 8020994:	4b05      	ldr	r3, [pc, #20]	; (80209ac <OP_ld_value_byte_stack+0x28>)
 8020996:	681b      	ldr	r3, [r3, #0]
 8020998:	3b04      	subs	r3, #4
 802099a:	687a      	ldr	r2, [r7, #4]
 802099c:	7812      	ldrb	r2, [r2, #0]
 802099e:	701a      	strb	r2, [r3, #0]

	return;
 80209a0:	bf00      	nop
}
 80209a2:	370c      	adds	r7, #12
 80209a4:	46bd      	mov	sp, r7
 80209a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80209aa:	4770      	bx	lr
 80209ac:	20012fcc 	.word	0x20012fcc

080209b0 <OP_ld_value_word>:

void OP_ld_value_word()
{
 80209b0:	b480      	push	{r7}
 80209b2:	b083      	sub	sp, #12
 80209b4:	af00      	add	r7, sp, #0
	short* s;

	s = (short*) (FINSH_GET32(finsh_pc));
 80209b6:	4b16      	ldr	r3, [pc, #88]	; (8020a10 <OP_ld_value_word+0x60>)
 80209b8:	681b      	ldr	r3, [r3, #0]
 80209ba:	781b      	ldrb	r3, [r3, #0]
 80209bc:	461a      	mov	r2, r3
 80209be:	4b14      	ldr	r3, [pc, #80]	; (8020a10 <OP_ld_value_word+0x60>)
 80209c0:	681b      	ldr	r3, [r3, #0]
 80209c2:	3301      	adds	r3, #1
 80209c4:	781b      	ldrb	r3, [r3, #0]
 80209c6:	021b      	lsls	r3, r3, #8
 80209c8:	431a      	orrs	r2, r3
 80209ca:	4b11      	ldr	r3, [pc, #68]	; (8020a10 <OP_ld_value_word+0x60>)
 80209cc:	681b      	ldr	r3, [r3, #0]
 80209ce:	3302      	adds	r3, #2
 80209d0:	781b      	ldrb	r3, [r3, #0]
 80209d2:	041b      	lsls	r3, r3, #16
 80209d4:	431a      	orrs	r2, r3
 80209d6:	4b0e      	ldr	r3, [pc, #56]	; (8020a10 <OP_ld_value_word+0x60>)
 80209d8:	681b      	ldr	r3, [r3, #0]
 80209da:	3303      	adds	r3, #3
 80209dc:	781b      	ldrb	r3, [r3, #0]
 80209de:	061b      	lsls	r3, r3, #24
 80209e0:	4313      	orrs	r3, r2
 80209e2:	607b      	str	r3, [r7, #4]

	finsh_sp->short_value = *s;
 80209e4:	4b0b      	ldr	r3, [pc, #44]	; (8020a14 <OP_ld_value_word+0x64>)
 80209e6:	681b      	ldr	r3, [r3, #0]
 80209e8:	687a      	ldr	r2, [r7, #4]
 80209ea:	8812      	ldrh	r2, [r2, #0]
 80209ec:	801a      	strh	r2, [r3, #0]

	finsh_sp ++;
 80209ee:	4b09      	ldr	r3, [pc, #36]	; (8020a14 <OP_ld_value_word+0x64>)
 80209f0:	681b      	ldr	r3, [r3, #0]
 80209f2:	3304      	adds	r3, #4
 80209f4:	4a07      	ldr	r2, [pc, #28]	; (8020a14 <OP_ld_value_word+0x64>)
 80209f6:	6013      	str	r3, [r2, #0]
	finsh_pc += 4;
 80209f8:	4b05      	ldr	r3, [pc, #20]	; (8020a10 <OP_ld_value_word+0x60>)
 80209fa:	681b      	ldr	r3, [r3, #0]
 80209fc:	3304      	adds	r3, #4
 80209fe:	4a04      	ldr	r2, [pc, #16]	; (8020a10 <OP_ld_value_word+0x60>)
 8020a00:	6013      	str	r3, [r2, #0]

	return;
 8020a02:	bf00      	nop
}
 8020a04:	370c      	adds	r7, #12
 8020a06:	46bd      	mov	sp, r7
 8020a08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020a0c:	4770      	bx	lr
 8020a0e:	bf00      	nop
 8020a10:	20012fc8 	.word	0x20012fc8
 8020a14:	20012fcc 	.word	0x20012fcc

08020a18 <OP_ld_value_word_stack>:

void OP_ld_value_word_stack()
{
 8020a18:	b480      	push	{r7}
 8020a1a:	b083      	sub	sp, #12
 8020a1c:	af00      	add	r7, sp, #0
	short* s;

	s = (short *)(finsh_sp - 1)->long_value;
 8020a1e:	4b08      	ldr	r3, [pc, #32]	; (8020a40 <OP_ld_value_word_stack+0x28>)
 8020a20:	681b      	ldr	r3, [r3, #0]
 8020a22:	3b04      	subs	r3, #4
 8020a24:	681b      	ldr	r3, [r3, #0]
 8020a26:	607b      	str	r3, [r7, #4]
	(finsh_sp - 1)->short_value = *s;
 8020a28:	4b05      	ldr	r3, [pc, #20]	; (8020a40 <OP_ld_value_word_stack+0x28>)
 8020a2a:	681b      	ldr	r3, [r3, #0]
 8020a2c:	3b04      	subs	r3, #4
 8020a2e:	687a      	ldr	r2, [r7, #4]
 8020a30:	8812      	ldrh	r2, [r2, #0]
 8020a32:	801a      	strh	r2, [r3, #0]

	return;
 8020a34:	bf00      	nop
}
 8020a36:	370c      	adds	r7, #12
 8020a38:	46bd      	mov	sp, r7
 8020a3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020a3e:	4770      	bx	lr
 8020a40:	20012fcc 	.word	0x20012fcc

08020a44 <OP_ld_value_dword>:

void OP_ld_value_dword()
{
 8020a44:	b480      	push	{r7}
 8020a46:	b083      	sub	sp, #12
 8020a48:	af00      	add	r7, sp, #0
	long* l;

	l = (long*) (FINSH_GET32(finsh_pc));
 8020a4a:	4b16      	ldr	r3, [pc, #88]	; (8020aa4 <OP_ld_value_dword+0x60>)
 8020a4c:	681b      	ldr	r3, [r3, #0]
 8020a4e:	781b      	ldrb	r3, [r3, #0]
 8020a50:	461a      	mov	r2, r3
 8020a52:	4b14      	ldr	r3, [pc, #80]	; (8020aa4 <OP_ld_value_dword+0x60>)
 8020a54:	681b      	ldr	r3, [r3, #0]
 8020a56:	3301      	adds	r3, #1
 8020a58:	781b      	ldrb	r3, [r3, #0]
 8020a5a:	021b      	lsls	r3, r3, #8
 8020a5c:	431a      	orrs	r2, r3
 8020a5e:	4b11      	ldr	r3, [pc, #68]	; (8020aa4 <OP_ld_value_dword+0x60>)
 8020a60:	681b      	ldr	r3, [r3, #0]
 8020a62:	3302      	adds	r3, #2
 8020a64:	781b      	ldrb	r3, [r3, #0]
 8020a66:	041b      	lsls	r3, r3, #16
 8020a68:	431a      	orrs	r2, r3
 8020a6a:	4b0e      	ldr	r3, [pc, #56]	; (8020aa4 <OP_ld_value_dword+0x60>)
 8020a6c:	681b      	ldr	r3, [r3, #0]
 8020a6e:	3303      	adds	r3, #3
 8020a70:	781b      	ldrb	r3, [r3, #0]
 8020a72:	061b      	lsls	r3, r3, #24
 8020a74:	4313      	orrs	r3, r2
 8020a76:	607b      	str	r3, [r7, #4]

	finsh_sp->long_value = *l;
 8020a78:	4b0b      	ldr	r3, [pc, #44]	; (8020aa8 <OP_ld_value_dword+0x64>)
 8020a7a:	681b      	ldr	r3, [r3, #0]
 8020a7c:	687a      	ldr	r2, [r7, #4]
 8020a7e:	6812      	ldr	r2, [r2, #0]
 8020a80:	601a      	str	r2, [r3, #0]

	finsh_sp ++;
 8020a82:	4b09      	ldr	r3, [pc, #36]	; (8020aa8 <OP_ld_value_dword+0x64>)
 8020a84:	681b      	ldr	r3, [r3, #0]
 8020a86:	3304      	adds	r3, #4
 8020a88:	4a07      	ldr	r2, [pc, #28]	; (8020aa8 <OP_ld_value_dword+0x64>)
 8020a8a:	6013      	str	r3, [r2, #0]
	finsh_pc += 4;
 8020a8c:	4b05      	ldr	r3, [pc, #20]	; (8020aa4 <OP_ld_value_dword+0x60>)
 8020a8e:	681b      	ldr	r3, [r3, #0]
 8020a90:	3304      	adds	r3, #4
 8020a92:	4a04      	ldr	r2, [pc, #16]	; (8020aa4 <OP_ld_value_dword+0x60>)
 8020a94:	6013      	str	r3, [r2, #0]

	return;
 8020a96:	bf00      	nop
}
 8020a98:	370c      	adds	r7, #12
 8020a9a:	46bd      	mov	sp, r7
 8020a9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020aa0:	4770      	bx	lr
 8020aa2:	bf00      	nop
 8020aa4:	20012fc8 	.word	0x20012fc8
 8020aa8:	20012fcc 	.word	0x20012fcc

08020aac <OP_ld_value_dword_stack>:

void OP_ld_value_dword_stack()
{
 8020aac:	b480      	push	{r7}
 8020aae:	b083      	sub	sp, #12
 8020ab0:	af00      	add	r7, sp, #0
	long* l;

	l = (long *)(finsh_sp - 1)->long_value;
 8020ab2:	4b08      	ldr	r3, [pc, #32]	; (8020ad4 <OP_ld_value_dword_stack+0x28>)
 8020ab4:	681b      	ldr	r3, [r3, #0]
 8020ab6:	3b04      	subs	r3, #4
 8020ab8:	681b      	ldr	r3, [r3, #0]
 8020aba:	607b      	str	r3, [r7, #4]
	(finsh_sp - 1)->long_value = *l;
 8020abc:	4b05      	ldr	r3, [pc, #20]	; (8020ad4 <OP_ld_value_dword_stack+0x28>)
 8020abe:	681b      	ldr	r3, [r3, #0]
 8020ac0:	3b04      	subs	r3, #4
 8020ac2:	687a      	ldr	r2, [r7, #4]
 8020ac4:	6812      	ldr	r2, [r2, #0]
 8020ac6:	601a      	str	r2, [r3, #0]

	return;
 8020ac8:	bf00      	nop
}
 8020aca:	370c      	adds	r7, #12
 8020acc:	46bd      	mov	sp, r7
 8020ace:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020ad2:	4770      	bx	lr
 8020ad4:	20012fcc 	.word	0x20012fcc

08020ad8 <OP_st_byte>:
/*
 * 2006-4-16 bernard
 * fixed the sp move bug
 */
void OP_st_byte()
{
 8020ad8:	b480      	push	{r7}
 8020ada:	af00      	add	r7, sp, #0
	*(char*)((finsh_sp - 2)->long_value) = (finsh_sp - 1)->char_value;
 8020adc:	4b09      	ldr	r3, [pc, #36]	; (8020b04 <OP_st_byte+0x2c>)
 8020ade:	681b      	ldr	r3, [r3, #0]
 8020ae0:	3b08      	subs	r3, #8
 8020ae2:	681b      	ldr	r3, [r3, #0]
 8020ae4:	461a      	mov	r2, r3
 8020ae6:	4b07      	ldr	r3, [pc, #28]	; (8020b04 <OP_st_byte+0x2c>)
 8020ae8:	681b      	ldr	r3, [r3, #0]
 8020aea:	3b04      	subs	r3, #4
 8020aec:	781b      	ldrb	r3, [r3, #0]
 8020aee:	7013      	strb	r3, [r2, #0]
	finsh_sp --;
 8020af0:	4b04      	ldr	r3, [pc, #16]	; (8020b04 <OP_st_byte+0x2c>)
 8020af2:	681b      	ldr	r3, [r3, #0]
 8020af4:	3b04      	subs	r3, #4
 8020af6:	4a03      	ldr	r2, [pc, #12]	; (8020b04 <OP_st_byte+0x2c>)
 8020af8:	6013      	str	r3, [r2, #0]

	return ;
 8020afa:	bf00      	nop
}
 8020afc:	46bd      	mov	sp, r7
 8020afe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020b02:	4770      	bx	lr
 8020b04:	20012fcc 	.word	0x20012fcc

08020b08 <OP_st_word>:
/*
 * 2006-4-16 bernard
 * fixed the sp move bug
 */
void OP_st_word()
{
 8020b08:	b480      	push	{r7}
 8020b0a:	af00      	add	r7, sp, #0
	*(short*)((finsh_sp - 2)->long_value) = (finsh_sp - 1)->short_value;
 8020b0c:	4b09      	ldr	r3, [pc, #36]	; (8020b34 <OP_st_word+0x2c>)
 8020b0e:	681b      	ldr	r3, [r3, #0]
 8020b10:	3b08      	subs	r3, #8
 8020b12:	681b      	ldr	r3, [r3, #0]
 8020b14:	461a      	mov	r2, r3
 8020b16:	4b07      	ldr	r3, [pc, #28]	; (8020b34 <OP_st_word+0x2c>)
 8020b18:	681b      	ldr	r3, [r3, #0]
 8020b1a:	3b04      	subs	r3, #4
 8020b1c:	881b      	ldrh	r3, [r3, #0]
 8020b1e:	8013      	strh	r3, [r2, #0]
	finsh_sp --;
 8020b20:	4b04      	ldr	r3, [pc, #16]	; (8020b34 <OP_st_word+0x2c>)
 8020b22:	681b      	ldr	r3, [r3, #0]
 8020b24:	3b04      	subs	r3, #4
 8020b26:	4a03      	ldr	r2, [pc, #12]	; (8020b34 <OP_st_word+0x2c>)
 8020b28:	6013      	str	r3, [r2, #0]

	return ;
 8020b2a:	bf00      	nop
}
 8020b2c:	46bd      	mov	sp, r7
 8020b2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020b32:	4770      	bx	lr
 8020b34:	20012fcc 	.word	0x20012fcc

08020b38 <OP_st_dword>:
/*
 * 2006-4-16 bernard
 * fixed the sp move bug
 */
void OP_st_dword()
{
 8020b38:	b480      	push	{r7}
 8020b3a:	af00      	add	r7, sp, #0
	*(long*)((finsh_sp - 2)->long_value) = (finsh_sp - 1)->long_value;
 8020b3c:	4b09      	ldr	r3, [pc, #36]	; (8020b64 <OP_st_dword+0x2c>)
 8020b3e:	681b      	ldr	r3, [r3, #0]
 8020b40:	3b08      	subs	r3, #8
 8020b42:	681b      	ldr	r3, [r3, #0]
 8020b44:	461a      	mov	r2, r3
 8020b46:	4b07      	ldr	r3, [pc, #28]	; (8020b64 <OP_st_dword+0x2c>)
 8020b48:	681b      	ldr	r3, [r3, #0]
 8020b4a:	3b04      	subs	r3, #4
 8020b4c:	681b      	ldr	r3, [r3, #0]
 8020b4e:	6013      	str	r3, [r2, #0]
	finsh_sp --;
 8020b50:	4b04      	ldr	r3, [pc, #16]	; (8020b64 <OP_st_dword+0x2c>)
 8020b52:	681b      	ldr	r3, [r3, #0]
 8020b54:	3b04      	subs	r3, #4
 8020b56:	4a03      	ldr	r2, [pc, #12]	; (8020b64 <OP_st_dword+0x2c>)
 8020b58:	6013      	str	r3, [r2, #0]

	return ;
 8020b5a:	bf00      	nop
}
 8020b5c:	46bd      	mov	sp, r7
 8020b5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020b62:	4770      	bx	lr
 8020b64:	20012fcc 	.word	0x20012fcc

08020b68 <OP_pop>:

/* --- pop --- */
void OP_pop()
{
 8020b68:	b480      	push	{r7}
 8020b6a:	af00      	add	r7, sp, #0
	finsh_sp --;
 8020b6c:	4b04      	ldr	r3, [pc, #16]	; (8020b80 <OP_pop+0x18>)
 8020b6e:	681b      	ldr	r3, [r3, #0]
 8020b70:	3b04      	subs	r3, #4
 8020b72:	4a03      	ldr	r2, [pc, #12]	; (8020b80 <OP_pop+0x18>)
 8020b74:	6013      	str	r3, [r2, #0]
	return ;
 8020b76:	bf00      	nop
}
 8020b78:	46bd      	mov	sp, r7
 8020b7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020b7e:	4770      	bx	lr
 8020b80:	20012fcc 	.word	0x20012fcc

08020b84 <OP_call>:

/* --- call --- */
void OP_call()
{
 8020b84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020b88:	b0a5      	sub	sp, #148	; 0x94
 8020b8a:	af0c      	add	r7, sp, #48	; 0x30
	typedef unsigned long var_t;
	typedef var_t (*op_func)();
	op_func f;
	var_t   r;

	parameters = *finsh_pc ++;
 8020b8c:	4b95      	ldr	r3, [pc, #596]	; (8020de4 <OP_call+0x260>)
 8020b8e:	681b      	ldr	r3, [r3, #0]
 8020b90:	1c5a      	adds	r2, r3, #1
 8020b92:	4994      	ldr	r1, [pc, #592]	; (8020de4 <OP_call+0x260>)
 8020b94:	600a      	str	r2, [r1, #0]
 8020b96:	781b      	ldrb	r3, [r3, #0]
 8020b98:	657b      	str	r3, [r7, #84]	; 0x54

	i = 0; finsh_sp --;
 8020b9a:	2300      	movs	r3, #0
 8020b9c:	65fb      	str	r3, [r7, #92]	; 0x5c
 8020b9e:	4b92      	ldr	r3, [pc, #584]	; (8020de8 <OP_call+0x264>)
 8020ba0:	681b      	ldr	r3, [r3, #0]
 8020ba2:	3b04      	subs	r3, #4
 8020ba4:	4a90      	ldr	r2, [pc, #576]	; (8020de8 <OP_call+0x264>)
 8020ba6:	6013      	str	r3, [r2, #0]
	while (i < parameters)
 8020ba8:	e014      	b.n	8020bd4 <OP_call+0x50>
	{
		parameterv[parameters - 1 - i] = finsh_sp->long_value;
 8020baa:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8020bac:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8020bae:	1ad3      	subs	r3, r2, r3
 8020bb0:	3b01      	subs	r3, #1
 8020bb2:	4a8d      	ldr	r2, [pc, #564]	; (8020de8 <OP_call+0x264>)
 8020bb4:	6812      	ldr	r2, [r2, #0]
 8020bb6:	6812      	ldr	r2, [r2, #0]
 8020bb8:	009b      	lsls	r3, r3, #2
 8020bba:	f107 0160 	add.w	r1, r7, #96	; 0x60
 8020bbe:	440b      	add	r3, r1
 8020bc0:	f843 2c50 	str.w	r2, [r3, #-80]
		finsh_sp --;
 8020bc4:	4b88      	ldr	r3, [pc, #544]	; (8020de8 <OP_call+0x264>)
 8020bc6:	681b      	ldr	r3, [r3, #0]
 8020bc8:	3b04      	subs	r3, #4
 8020bca:	4a87      	ldr	r2, [pc, #540]	; (8020de8 <OP_call+0x264>)
 8020bcc:	6013      	str	r3, [r2, #0]
		i++;
 8020bce:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8020bd0:	3301      	adds	r3, #1
 8020bd2:	65fb      	str	r3, [r7, #92]	; 0x5c
	var_t   r;

	parameters = *finsh_pc ++;

	i = 0; finsh_sp --;
	while (i < parameters)
 8020bd4:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8020bd6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8020bd8:	429a      	cmp	r2, r3
 8020bda:	d3e6      	bcc.n	8020baa <OP_call+0x26>
		parameterv[parameters - 1 - i] = finsh_sp->long_value;
		finsh_sp --;
		i++;
	}

	f = (op_func)(finsh_sp->long_value);
 8020bdc:	4b82      	ldr	r3, [pc, #520]	; (8020de8 <OP_call+0x264>)
 8020bde:	681b      	ldr	r3, [r3, #0]
 8020be0:	681b      	ldr	r3, [r3, #0]
 8020be2:	653b      	str	r3, [r7, #80]	; 0x50
	switch (parameters)
 8020be4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8020be6:	2b10      	cmp	r3, #16
 8020be8:	f200 81b0 	bhi.w	8020f4c <OP_call+0x3c8>
 8020bec:	a201      	add	r2, pc, #4	; (adr r2, 8020bf4 <OP_call+0x70>)
 8020bee:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8020bf2:	bf00      	nop
 8020bf4:	08020c39 	.word	0x08020c39
 8020bf8:	08020c43 	.word	0x08020c43
 8020bfc:	08020c4f 	.word	0x08020c4f
 8020c00:	08020c5f 	.word	0x08020c5f
 8020c04:	08020c6d 	.word	0x08020c6d
 8020c08:	08020c7d 	.word	0x08020c7d
 8020c0c:	08020c93 	.word	0x08020c93
 8020c10:	08020caf 	.word	0x08020caf
 8020c14:	08020cd3 	.word	0x08020cd3
 8020c18:	08020cff 	.word	0x08020cff
 8020c1c:	08020d2f 	.word	0x08020d2f
 8020c20:	08020d65 	.word	0x08020d65
 8020c24:	08020da1 	.word	0x08020da1
 8020c28:	08020ded 	.word	0x08020ded
 8020c2c:	08020e39 	.word	0x08020e39
 8020c30:	08020e8d 	.word	0x08020e8d
 8020c34:	08020ee9 	.word	0x08020ee9
	{
	case 0:
		r = f(0);
 8020c38:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8020c3a:	2000      	movs	r0, #0
 8020c3c:	4798      	blx	r3
 8020c3e:	65b8      	str	r0, [r7, #88]	; 0x58
		break;
 8020c40:	e187      	b.n	8020f52 <OP_call+0x3ce>

	case 1:
		r = f(parameterv[0]);
 8020c42:	693a      	ldr	r2, [r7, #16]
 8020c44:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8020c46:	4610      	mov	r0, r2
 8020c48:	4798      	blx	r3
 8020c4a:	65b8      	str	r0, [r7, #88]	; 0x58
		break;
 8020c4c:	e181      	b.n	8020f52 <OP_call+0x3ce>

	case 2:
		r = f(parameterv[0], parameterv[1]);
 8020c4e:	6939      	ldr	r1, [r7, #16]
 8020c50:	697a      	ldr	r2, [r7, #20]
 8020c52:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8020c54:	4608      	mov	r0, r1
 8020c56:	4611      	mov	r1, r2
 8020c58:	4798      	blx	r3
 8020c5a:	65b8      	str	r0, [r7, #88]	; 0x58
		break;
 8020c5c:	e179      	b.n	8020f52 <OP_call+0x3ce>

	case 3:
		r = f(parameterv[0], parameterv[1], parameterv[2]);
 8020c5e:	6938      	ldr	r0, [r7, #16]
 8020c60:	6979      	ldr	r1, [r7, #20]
 8020c62:	69ba      	ldr	r2, [r7, #24]
 8020c64:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8020c66:	4798      	blx	r3
 8020c68:	65b8      	str	r0, [r7, #88]	; 0x58
		break;
 8020c6a:	e172      	b.n	8020f52 <OP_call+0x3ce>

	case 4:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3]);
 8020c6c:	6938      	ldr	r0, [r7, #16]
 8020c6e:	6979      	ldr	r1, [r7, #20]
 8020c70:	69ba      	ldr	r2, [r7, #24]
 8020c72:	69fb      	ldr	r3, [r7, #28]
 8020c74:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8020c76:	47a0      	blx	r4
 8020c78:	65b8      	str	r0, [r7, #88]	; 0x58
		break;
 8020c7a:	e16a      	b.n	8020f52 <OP_call+0x3ce>

	case 5:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 8020c7c:	6938      	ldr	r0, [r7, #16]
 8020c7e:	6979      	ldr	r1, [r7, #20]
 8020c80:	69ba      	ldr	r2, [r7, #24]
 8020c82:	69fd      	ldr	r5, [r7, #28]
 8020c84:	6a3b      	ldr	r3, [r7, #32]
 8020c86:	9300      	str	r3, [sp, #0]
 8020c88:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8020c8a:	462b      	mov	r3, r5
 8020c8c:	47a0      	blx	r4
 8020c8e:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4]);
		break;
 8020c90:	e15f      	b.n	8020f52 <OP_call+0x3ce>

	case 6:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 8020c92:	6938      	ldr	r0, [r7, #16]
 8020c94:	6979      	ldr	r1, [r7, #20]
 8020c96:	69be      	ldr	r6, [r7, #24]
 8020c98:	69fd      	ldr	r5, [r7, #28]
 8020c9a:	6a3a      	ldr	r2, [r7, #32]
 8020c9c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8020c9e:	9200      	str	r2, [sp, #0]
 8020ca0:	9301      	str	r3, [sp, #4]
 8020ca2:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8020ca4:	4632      	mov	r2, r6
 8020ca6:	462b      	mov	r3, r5
 8020ca8:	47a0      	blx	r4
 8020caa:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5]);
		break;
 8020cac:	e151      	b.n	8020f52 <OP_call+0x3ce>

	case 7:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 8020cae:	6938      	ldr	r0, [r7, #16]
 8020cb0:	f8d7 e014 	ldr.w	lr, [r7, #20]
 8020cb4:	69be      	ldr	r6, [r7, #24]
 8020cb6:	69fd      	ldr	r5, [r7, #28]
 8020cb8:	6a39      	ldr	r1, [r7, #32]
 8020cba:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8020cbc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020cbe:	9100      	str	r1, [sp, #0]
 8020cc0:	9201      	str	r2, [sp, #4]
 8020cc2:	9302      	str	r3, [sp, #8]
 8020cc4:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8020cc6:	4671      	mov	r1, lr
 8020cc8:	4632      	mov	r2, r6
 8020cca:	462b      	mov	r3, r5
 8020ccc:	47a0      	blx	r4
 8020cce:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6]);
		break;
 8020cd0:	e13f      	b.n	8020f52 <OP_call+0x3ce>

	case 8:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 8020cd2:	f8d7 c010 	ldr.w	ip, [r7, #16]
 8020cd6:	f8d7 e014 	ldr.w	lr, [r7, #20]
 8020cda:	69be      	ldr	r6, [r7, #24]
 8020cdc:	69fd      	ldr	r5, [r7, #28]
 8020cde:	6a38      	ldr	r0, [r7, #32]
 8020ce0:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8020ce2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8020ce4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8020ce6:	9000      	str	r0, [sp, #0]
 8020ce8:	9101      	str	r1, [sp, #4]
 8020cea:	9202      	str	r2, [sp, #8]
 8020cec:	9303      	str	r3, [sp, #12]
 8020cee:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8020cf0:	4660      	mov	r0, ip
 8020cf2:	4671      	mov	r1, lr
 8020cf4:	4632      	mov	r2, r6
 8020cf6:	462b      	mov	r3, r5
 8020cf8:	47a0      	blx	r4
 8020cfa:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7]);
		break;
 8020cfc:	e129      	b.n	8020f52 <OP_call+0x3ce>

	case 9:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 8020cfe:	f8d7 c010 	ldr.w	ip, [r7, #16]
 8020d02:	f8d7 e014 	ldr.w	lr, [r7, #20]
 8020d06:	69be      	ldr	r6, [r7, #24]
 8020d08:	69fd      	ldr	r5, [r7, #28]
 8020d0a:	6a3c      	ldr	r4, [r7, #32]
 8020d0c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8020d0e:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8020d10:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8020d12:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8020d14:	9400      	str	r4, [sp, #0]
 8020d16:	9001      	str	r0, [sp, #4]
 8020d18:	9102      	str	r1, [sp, #8]
 8020d1a:	9203      	str	r2, [sp, #12]
 8020d1c:	9304      	str	r3, [sp, #16]
 8020d1e:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8020d20:	4660      	mov	r0, ip
 8020d22:	4671      	mov	r1, lr
 8020d24:	4632      	mov	r2, r6
 8020d26:	462b      	mov	r3, r5
 8020d28:	47a0      	blx	r4
 8020d2a:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8]);
		break;
 8020d2c:	e111      	b.n	8020f52 <OP_call+0x3ce>

	case 10:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 8020d2e:	f8d7 8010 	ldr.w	r8, [r7, #16]
 8020d32:	f8d7 c014 	ldr.w	ip, [r7, #20]
 8020d36:	f8d7 e018 	ldr.w	lr, [r7, #24]
 8020d3a:	69fe      	ldr	r6, [r7, #28]
 8020d3c:	6a3d      	ldr	r5, [r7, #32]
 8020d3e:	6a7c      	ldr	r4, [r7, #36]	; 0x24
 8020d40:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8020d42:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8020d44:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8020d46:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8020d48:	9500      	str	r5, [sp, #0]
 8020d4a:	9401      	str	r4, [sp, #4]
 8020d4c:	9002      	str	r0, [sp, #8]
 8020d4e:	9103      	str	r1, [sp, #12]
 8020d50:	9204      	str	r2, [sp, #16]
 8020d52:	9305      	str	r3, [sp, #20]
 8020d54:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8020d56:	4640      	mov	r0, r8
 8020d58:	4661      	mov	r1, ip
 8020d5a:	4672      	mov	r2, lr
 8020d5c:	4633      	mov	r3, r6
 8020d5e:	47a0      	blx	r4
 8020d60:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9]);
		break;
 8020d62:	e0f6      	b.n	8020f52 <OP_call+0x3ce>

	case 11:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 8020d64:	f8d7 9010 	ldr.w	r9, [r7, #16]
 8020d68:	f8d7 8014 	ldr.w	r8, [r7, #20]
 8020d6c:	f8d7 c018 	ldr.w	ip, [r7, #24]
 8020d70:	f8d7 e01c 	ldr.w	lr, [r7, #28]
 8020d74:	6a3e      	ldr	r6, [r7, #32]
 8020d76:	6a7d      	ldr	r5, [r7, #36]	; 0x24
 8020d78:	6abc      	ldr	r4, [r7, #40]	; 0x28
 8020d7a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8020d7c:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8020d7e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8020d80:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8020d82:	9600      	str	r6, [sp, #0]
 8020d84:	9501      	str	r5, [sp, #4]
 8020d86:	9402      	str	r4, [sp, #8]
 8020d88:	9003      	str	r0, [sp, #12]
 8020d8a:	9104      	str	r1, [sp, #16]
 8020d8c:	9205      	str	r2, [sp, #20]
 8020d8e:	9306      	str	r3, [sp, #24]
 8020d90:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8020d92:	4648      	mov	r0, r9
 8020d94:	4641      	mov	r1, r8
 8020d96:	4662      	mov	r2, ip
 8020d98:	4673      	mov	r3, lr
 8020d9a:	47a0      	blx	r4
 8020d9c:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10]);
		break;
 8020d9e:	e0d8      	b.n	8020f52 <OP_call+0x3ce>

	case 12:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 8020da0:	f8d7 a010 	ldr.w	sl, [r7, #16]
 8020da4:	f8d7 9014 	ldr.w	r9, [r7, #20]
 8020da8:	f8d7 8018 	ldr.w	r8, [r7, #24]
 8020dac:	f8d7 c01c 	ldr.w	ip, [r7, #28]
 8020db0:	f8d7 e020 	ldr.w	lr, [r7, #32]
 8020db4:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 8020db6:	6abd      	ldr	r5, [r7, #40]	; 0x28
 8020db8:	6afc      	ldr	r4, [r7, #44]	; 0x2c
 8020dba:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8020dbc:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8020dbe:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8020dc0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8020dc2:	f8cd e000 	str.w	lr, [sp]
 8020dc6:	9601      	str	r6, [sp, #4]
 8020dc8:	9502      	str	r5, [sp, #8]
 8020dca:	9403      	str	r4, [sp, #12]
 8020dcc:	9004      	str	r0, [sp, #16]
 8020dce:	9105      	str	r1, [sp, #20]
 8020dd0:	9206      	str	r2, [sp, #24]
 8020dd2:	9307      	str	r3, [sp, #28]
 8020dd4:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8020dd6:	4650      	mov	r0, sl
 8020dd8:	4649      	mov	r1, r9
 8020dda:	4642      	mov	r2, r8
 8020ddc:	4663      	mov	r3, ip
 8020dde:	47a0      	blx	r4
 8020de0:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11]);
		break;
 8020de2:	e0b6      	b.n	8020f52 <OP_call+0x3ce>
 8020de4:	20012fc8 	.word	0x20012fc8
 8020de8:	20012fcc 	.word	0x20012fcc

	case 13:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 8020dec:	f8d7 b010 	ldr.w	fp, [r7, #16]
 8020df0:	f8d7 a014 	ldr.w	sl, [r7, #20]
 8020df4:	f8d7 9018 	ldr.w	r9, [r7, #24]
 8020df8:	f8d7 801c 	ldr.w	r8, [r7, #28]
 8020dfc:	f8d7 c020 	ldr.w	ip, [r7, #32]
 8020e00:	f8d7 e024 	ldr.w	lr, [r7, #36]	; 0x24
 8020e04:	6abe      	ldr	r6, [r7, #40]	; 0x28
 8020e06:	6afd      	ldr	r5, [r7, #44]	; 0x2c
 8020e08:	6b3c      	ldr	r4, [r7, #48]	; 0x30
 8020e0a:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8020e0c:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8020e0e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8020e10:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8020e12:	f8cd c000 	str.w	ip, [sp]
 8020e16:	f8cd e004 	str.w	lr, [sp, #4]
 8020e1a:	9602      	str	r6, [sp, #8]
 8020e1c:	9503      	str	r5, [sp, #12]
 8020e1e:	9404      	str	r4, [sp, #16]
 8020e20:	9005      	str	r0, [sp, #20]
 8020e22:	9106      	str	r1, [sp, #24]
 8020e24:	9207      	str	r2, [sp, #28]
 8020e26:	9308      	str	r3, [sp, #32]
 8020e28:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8020e2a:	4658      	mov	r0, fp
 8020e2c:	4651      	mov	r1, sl
 8020e2e:	464a      	mov	r2, r9
 8020e30:	4643      	mov	r3, r8
 8020e32:	47a0      	blx	r4
 8020e34:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12]);
		break;
 8020e36:	e08c      	b.n	8020f52 <OP_call+0x3ce>

	case 14:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 8020e38:	693b      	ldr	r3, [r7, #16]
 8020e3a:	60fb      	str	r3, [r7, #12]
 8020e3c:	f8d7 b014 	ldr.w	fp, [r7, #20]
 8020e40:	f8d7 a018 	ldr.w	sl, [r7, #24]
 8020e44:	f8d7 901c 	ldr.w	r9, [r7, #28]
 8020e48:	f8d7 8020 	ldr.w	r8, [r7, #32]
 8020e4c:	f8d7 c024 	ldr.w	ip, [r7, #36]	; 0x24
 8020e50:	f8d7 e028 	ldr.w	lr, [r7, #40]	; 0x28
 8020e54:	6afe      	ldr	r6, [r7, #44]	; 0x2c
 8020e56:	6b3d      	ldr	r5, [r7, #48]	; 0x30
 8020e58:	6b7c      	ldr	r4, [r7, #52]	; 0x34
 8020e5a:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8020e5c:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8020e5e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8020e60:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8020e62:	f8cd 8000 	str.w	r8, [sp]
 8020e66:	f8cd c004 	str.w	ip, [sp, #4]
 8020e6a:	f8cd e008 	str.w	lr, [sp, #8]
 8020e6e:	9603      	str	r6, [sp, #12]
 8020e70:	9504      	str	r5, [sp, #16]
 8020e72:	9405      	str	r4, [sp, #20]
 8020e74:	9006      	str	r0, [sp, #24]
 8020e76:	9107      	str	r1, [sp, #28]
 8020e78:	9208      	str	r2, [sp, #32]
 8020e7a:	9309      	str	r3, [sp, #36]	; 0x24
 8020e7c:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8020e7e:	68f8      	ldr	r0, [r7, #12]
 8020e80:	4659      	mov	r1, fp
 8020e82:	4652      	mov	r2, sl
 8020e84:	464b      	mov	r3, r9
 8020e86:	47a0      	blx	r4
 8020e88:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12], parameterv[13]);
		break;
 8020e8a:	e062      	b.n	8020f52 <OP_call+0x3ce>

	case 15:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 8020e8c:	693b      	ldr	r3, [r7, #16]
 8020e8e:	60fb      	str	r3, [r7, #12]
 8020e90:	697a      	ldr	r2, [r7, #20]
 8020e92:	60ba      	str	r2, [r7, #8]
 8020e94:	f8d7 b018 	ldr.w	fp, [r7, #24]
 8020e98:	f8d7 a01c 	ldr.w	sl, [r7, #28]
 8020e9c:	6a3a      	ldr	r2, [r7, #32]
 8020e9e:	f8d7 9024 	ldr.w	r9, [r7, #36]	; 0x24
 8020ea2:	f8d7 8028 	ldr.w	r8, [r7, #40]	; 0x28
 8020ea6:	f8d7 c02c 	ldr.w	ip, [r7, #44]	; 0x2c
 8020eaa:	f8d7 e030 	ldr.w	lr, [r7, #48]	; 0x30
 8020eae:	6b7e      	ldr	r6, [r7, #52]	; 0x34
 8020eb0:	6bbd      	ldr	r5, [r7, #56]	; 0x38
 8020eb2:	6bfc      	ldr	r4, [r7, #60]	; 0x3c
 8020eb4:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8020eb6:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8020eb8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8020eba:	9200      	str	r2, [sp, #0]
 8020ebc:	f8cd 9004 	str.w	r9, [sp, #4]
 8020ec0:	f8cd 8008 	str.w	r8, [sp, #8]
 8020ec4:	f8cd c00c 	str.w	ip, [sp, #12]
 8020ec8:	f8cd e010 	str.w	lr, [sp, #16]
 8020ecc:	9605      	str	r6, [sp, #20]
 8020ece:	9506      	str	r5, [sp, #24]
 8020ed0:	9407      	str	r4, [sp, #28]
 8020ed2:	9008      	str	r0, [sp, #32]
 8020ed4:	9109      	str	r1, [sp, #36]	; 0x24
 8020ed6:	930a      	str	r3, [sp, #40]	; 0x28
 8020ed8:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8020eda:	68f8      	ldr	r0, [r7, #12]
 8020edc:	68b9      	ldr	r1, [r7, #8]
 8020ede:	465a      	mov	r2, fp
 8020ee0:	4653      	mov	r3, sl
 8020ee2:	47a0      	blx	r4
 8020ee4:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12], parameterv[13], parameterv[14]);
		break;
 8020ee6:	e034      	b.n	8020f52 <OP_call+0x3ce>

	case 16:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 8020ee8:	693b      	ldr	r3, [r7, #16]
 8020eea:	60fb      	str	r3, [r7, #12]
 8020eec:	697a      	ldr	r2, [r7, #20]
 8020eee:	60ba      	str	r2, [r7, #8]
 8020ef0:	69bc      	ldr	r4, [r7, #24]
 8020ef2:	607c      	str	r4, [r7, #4]
 8020ef4:	f8d7 b01c 	ldr.w	fp, [r7, #28]
 8020ef8:	6a3a      	ldr	r2, [r7, #32]
 8020efa:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8020efc:	f8d7 a028 	ldr.w	sl, [r7, #40]	; 0x28
 8020f00:	f8d7 902c 	ldr.w	r9, [r7, #44]	; 0x2c
 8020f04:	f8d7 8030 	ldr.w	r8, [r7, #48]	; 0x30
 8020f08:	f8d7 c034 	ldr.w	ip, [r7, #52]	; 0x34
 8020f0c:	f8d7 e038 	ldr.w	lr, [r7, #56]	; 0x38
 8020f10:	6bfe      	ldr	r6, [r7, #60]	; 0x3c
 8020f12:	6c3d      	ldr	r5, [r7, #64]	; 0x40
 8020f14:	6c7c      	ldr	r4, [r7, #68]	; 0x44
 8020f16:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8020f18:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020f1a:	9200      	str	r2, [sp, #0]
 8020f1c:	9001      	str	r0, [sp, #4]
 8020f1e:	f8cd a008 	str.w	sl, [sp, #8]
 8020f22:	f8cd 900c 	str.w	r9, [sp, #12]
 8020f26:	f8cd 8010 	str.w	r8, [sp, #16]
 8020f2a:	f8cd c014 	str.w	ip, [sp, #20]
 8020f2e:	f8cd e018 	str.w	lr, [sp, #24]
 8020f32:	9607      	str	r6, [sp, #28]
 8020f34:	9508      	str	r5, [sp, #32]
 8020f36:	9409      	str	r4, [sp, #36]	; 0x24
 8020f38:	910a      	str	r1, [sp, #40]	; 0x28
 8020f3a:	930b      	str	r3, [sp, #44]	; 0x2c
 8020f3c:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8020f3e:	68f8      	ldr	r0, [r7, #12]
 8020f40:	68b9      	ldr	r1, [r7, #8]
 8020f42:	687a      	ldr	r2, [r7, #4]
 8020f44:	465b      	mov	r3, fp
 8020f46:	47a0      	blx	r4
 8020f48:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12], parameterv[13], parameterv[14], parameterv[15]);
		break;
 8020f4a:	e002      	b.n	8020f52 <OP_call+0x3ce>

	default:
		r = 0;
 8020f4c:	2300      	movs	r3, #0
 8020f4e:	65bb      	str	r3, [r7, #88]	; 0x58
		break;
 8020f50:	bf00      	nop
	}

	finsh_sp->long_value = r;
 8020f52:	4b07      	ldr	r3, [pc, #28]	; (8020f70 <OP_call+0x3ec>)
 8020f54:	681b      	ldr	r3, [r3, #0]
 8020f56:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8020f58:	601a      	str	r2, [r3, #0]
	finsh_sp ++;
 8020f5a:	4b05      	ldr	r3, [pc, #20]	; (8020f70 <OP_call+0x3ec>)
 8020f5c:	681b      	ldr	r3, [r3, #0]
 8020f5e:	3304      	adds	r3, #4
 8020f60:	4a03      	ldr	r2, [pc, #12]	; (8020f70 <OP_call+0x3ec>)
 8020f62:	6013      	str	r3, [r2, #0]

	return ;
 8020f64:	bf00      	nop
}
 8020f66:	3764      	adds	r7, #100	; 0x64
 8020f68:	46bd      	mov	sp, r7
 8020f6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8020f6e:	bf00      	nop
 8020f70:	20012fcc 	.word	0x20012fcc

08020f74 <proc_variable_decl>:
	| declarator
declarator -> identifier
	| identifier ASSIGN expr_assign
*/
static struct finsh_node* proc_variable_decl(struct finsh_parser* self)
{
 8020f74:	b580      	push	{r7, lr}
 8020f76:	b090      	sub	sp, #64	; 0x40
 8020f78:	af00      	add	r7, sp, #0
 8020f7a:	6078      	str	r0, [r7, #4]

	struct finsh_node *node;
	struct finsh_node *end;
	struct finsh_node *assign;

    node = NULL;
 8020f7c:	2300      	movs	r3, #0
 8020f7e:	63bb      	str	r3, [r7, #56]	; 0x38
	end  = NULL;
 8020f80:	2300      	movs	r3, #0
 8020f82:	637b      	str	r3, [r7, #52]	; 0x34

	/* get type */
	type = proc_type(self);
 8020f84:	6878      	ldr	r0, [r7, #4]
 8020f86:	f000 f955 	bl	8021234 <proc_type>
 8020f8a:	4603      	mov	r3, r0
 8020f8c:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

	/*process id.*/
	if (proc_identifier(self, id) == 0)
 8020f90:	f107 030c 	add.w	r3, r7, #12
 8020f94:	6878      	ldr	r0, [r7, #4]
 8020f96:	4619      	mov	r1, r3
 8020f98:	f000 fa1a 	bl	80213d0 <proc_identifier>
 8020f9c:	4603      	mov	r3, r0
 8020f9e:	2b00      	cmp	r3, #0
 8020fa0:	d10d      	bne.n	8020fbe <proc_variable_decl+0x4a>
	{
		/* if add variable failed */
		if (finsh_var_insert(id, type) < 0)
 8020fa2:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8020fa6:	f107 020c 	add.w	r2, r7, #12
 8020faa:	4610      	mov	r0, r2
 8020fac:	4619      	mov	r1, r3
 8020fae:	f000 fefd 	bl	8021dac <finsh_var_insert>
 8020fb2:	4603      	mov	r3, r0
 8020fb4:	2b00      	cmp	r3, #0
 8020fb6:	da02      	bge.n	8020fbe <proc_variable_decl+0x4a>
		{
			finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
 8020fb8:	2004      	movs	r0, #4
 8020fba:	f7fe fd25 	bl	801fa08 <finsh_error_set>
		}
	}

	next_token(token, &(self->token));
 8020fbe:	687b      	ldr	r3, [r7, #4]
 8020fc0:	3304      	adds	r3, #4
 8020fc2:	4618      	mov	r0, r3
 8020fc4:	f001 f844 	bl	8022050 <finsh_token_token>
 8020fc8:	4603      	mov	r3, r0
 8020fca:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
	switch ( token )
 8020fce:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8020fd2:	2b04      	cmp	r3, #4
 8020fd4:	f000 8123 	beq.w	802121e <proc_variable_decl+0x2aa>
 8020fd8:	2b0c      	cmp	r3, #12
 8020fda:	f000 80a3 	beq.w	8021124 <proc_variable_decl+0x1b0>
 8020fde:	2b03      	cmp	r3, #3
 8020fe0:	f040 811f 	bne.w	8021222 <proc_variable_decl+0x2ae>
	{
	case finsh_token_type_comma:/*',', it's a variable_list declaration.*/
		if (proc_identifier(self, id) == 0)
 8020fe4:	f107 030c 	add.w	r3, r7, #12
 8020fe8:	6878      	ldr	r0, [r7, #4]
 8020fea:	4619      	mov	r1, r3
 8020fec:	f000 f9f0 	bl	80213d0 <proc_identifier>
 8020ff0:	4603      	mov	r3, r0
 8020ff2:	2b00      	cmp	r3, #0
 8020ff4:	d10d      	bne.n	8021012 <proc_variable_decl+0x9e>
		{
			/* if add variable failed */
			if (finsh_var_insert(id, type) < 0)
 8020ff6:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8020ffa:	f107 020c 	add.w	r2, r7, #12
 8020ffe:	4610      	mov	r0, r2
 8021000:	4619      	mov	r1, r3
 8021002:	f000 fed3 	bl	8021dac <finsh_var_insert>
 8021006:	4603      	mov	r3, r0
 8021008:	2b00      	cmp	r3, #0
 802100a:	da02      	bge.n	8021012 <proc_variable_decl+0x9e>
			{
				finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
 802100c:	2004      	movs	r0, #4
 802100e:	f7fe fcfb 	bl	801fa08 <finsh_error_set>
			}
		}

		next_token(token, &(self->token));
 8021012:	687b      	ldr	r3, [r7, #4]
 8021014:	3304      	adds	r3, #4
 8021016:	4618      	mov	r0, r3
 8021018:	f001 f81a 	bl	8022050 <finsh_token_token>
 802101c:	4603      	mov	r3, r0
 802101e:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
		if ( token == finsh_token_type_assign )
 8021022:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8021026:	2b0c      	cmp	r3, #12
 8021028:	d11c      	bne.n	8021064 <proc_variable_decl+0xf0>
		{
			/* get the right side of assign expression */
			assign = proc_assign_expr(self);
 802102a:	6878      	ldr	r0, [r7, #4]
 802102c:	f000 fa2a 	bl	8021484 <proc_assign_expr>
 8021030:	62f8      	str	r0, [r7, #44]	; 0x2c

			if (assign != NULL)
 8021032:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8021034:	2b00      	cmp	r3, #0
 8021036:	d015      	beq.n	8021064 <proc_variable_decl+0xf0>
			{
				struct finsh_node* idnode;

				idnode = finsh_node_new_id(id);
 8021038:	f107 030c 	add.w	r3, r7, #12
 802103c:	4618      	mov	r0, r3
 802103e:	f7fe ff57 	bl	801fef0 <finsh_node_new_id>
 8021042:	62b8      	str	r0, [r7, #40]	; 0x28
				end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
 8021044:	2013      	movs	r0, #19
 8021046:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8021048:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 802104a:	f000 fdc5 	bl	8021bd8 <make_sys_node>
 802104e:	6378      	str	r0, [r7, #52]	; 0x34
				node = end;
 8021050:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8021052:	63bb      	str	r3, [r7, #56]	; 0x38

				next_token(token, &(self->token));
 8021054:	687b      	ldr	r3, [r7, #4]
 8021056:	3304      	adds	r3, #4
 8021058:	4618      	mov	r0, r3
 802105a:	f000 fff9 	bl	8022050 <finsh_token_token>
 802105e:	4603      	mov	r3, r0
 8021060:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
			}
		}

		while ( token == finsh_token_type_comma )
 8021064:	e04e      	b.n	8021104 <proc_variable_decl+0x190>
		{
			if (proc_identifier(self, id) == 0)
 8021066:	f107 030c 	add.w	r3, r7, #12
 802106a:	6878      	ldr	r0, [r7, #4]
 802106c:	4619      	mov	r1, r3
 802106e:	f000 f9af 	bl	80213d0 <proc_identifier>
 8021072:	4603      	mov	r3, r0
 8021074:	2b00      	cmp	r3, #0
 8021076:	d10d      	bne.n	8021094 <proc_variable_decl+0x120>
			{
				/* if add variable failed */
				if (finsh_var_insert(id, type) < 0)
 8021078:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 802107c:	f107 020c 	add.w	r2, r7, #12
 8021080:	4610      	mov	r0, r2
 8021082:	4619      	mov	r1, r3
 8021084:	f000 fe92 	bl	8021dac <finsh_var_insert>
 8021088:	4603      	mov	r3, r0
 802108a:	2b00      	cmp	r3, #0
 802108c:	da02      	bge.n	8021094 <proc_variable_decl+0x120>
				{
					finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
 802108e:	2004      	movs	r0, #4
 8021090:	f7fe fcba 	bl	801fa08 <finsh_error_set>
				}
			}

			next_token(token, &(self->token));
 8021094:	687b      	ldr	r3, [r7, #4]
 8021096:	3304      	adds	r3, #4
 8021098:	4618      	mov	r0, r3
 802109a:	f000 ffd9 	bl	8022050 <finsh_token_token>
 802109e:	4603      	mov	r3, r0
 80210a0:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
			if ( token == finsh_token_type_assign )
 80210a4:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 80210a8:	2b0c      	cmp	r3, #12
 80210aa:	d12b      	bne.n	8021104 <proc_variable_decl+0x190>
			{
				/* get the right side of assign expression */
				assign = proc_assign_expr(self);
 80210ac:	6878      	ldr	r0, [r7, #4]
 80210ae:	f000 f9e9 	bl	8021484 <proc_assign_expr>
 80210b2:	62f8      	str	r0, [r7, #44]	; 0x2c

				if (assign != NULL)
 80210b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80210b6:	2b00      	cmp	r3, #0
 80210b8:	d024      	beq.n	8021104 <proc_variable_decl+0x190>
				{
					struct finsh_node* idnode;

					idnode = finsh_node_new_id(id);
 80210ba:	f107 030c 	add.w	r3, r7, #12
 80210be:	4618      	mov	r0, r3
 80210c0:	f7fe ff16 	bl	801fef0 <finsh_node_new_id>
 80210c4:	6278      	str	r0, [r7, #36]	; 0x24

					/* make assign expression node */
					if (node != NULL)
 80210c6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80210c8:	2b00      	cmp	r3, #0
 80210ca:	d00b      	beq.n	80210e4 <proc_variable_decl+0x170>
					{
						finsh_node_sibling(end) = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
 80210cc:	2013      	movs	r0, #19
 80210ce:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80210d0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80210d2:	f000 fd81 	bl	8021bd8 <make_sys_node>
 80210d6:	4602      	mov	r2, r0
 80210d8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80210da:	60da      	str	r2, [r3, #12]
						end = finsh_node_sibling(end);
 80210dc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80210de:	68db      	ldr	r3, [r3, #12]
 80210e0:	637b      	str	r3, [r7, #52]	; 0x34
 80210e2:	e007      	b.n	80210f4 <proc_variable_decl+0x180>
					}
					else
					{
						end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
 80210e4:	2013      	movs	r0, #19
 80210e6:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80210e8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80210ea:	f000 fd75 	bl	8021bd8 <make_sys_node>
 80210ee:	6378      	str	r0, [r7, #52]	; 0x34
						node = end;
 80210f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80210f2:	63bb      	str	r3, [r7, #56]	; 0x38
					}

					next_token(token, &(self->token));
 80210f4:	687b      	ldr	r3, [r7, #4]
 80210f6:	3304      	adds	r3, #4
 80210f8:	4618      	mov	r0, r3
 80210fa:	f000 ffa9 	bl	8022050 <finsh_token_token>
 80210fe:	4603      	mov	r3, r0
 8021100:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f

				next_token(token, &(self->token));
			}
		}

		while ( token == finsh_token_type_comma )
 8021104:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8021108:	2b03      	cmp	r3, #3
 802110a:	d0ac      	beq.n	8021066 <proc_variable_decl+0xf2>
					next_token(token, &(self->token));
				}
			}
		}

		check_token(token, &(self->token), finsh_token_type_semicolon);
 802110c:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8021110:	2b04      	cmp	r3, #4
 8021112:	d005      	beq.n	8021120 <proc_variable_decl+0x1ac>
 8021114:	2001      	movs	r0, #1
 8021116:	f7fe fc77 	bl	801fa08 <finsh_error_set>
 802111a:	687b      	ldr	r3, [r7, #4]
 802111c:	2201      	movs	r2, #1
 802111e:	715a      	strb	r2, [r3, #5]
		return node;
 8021120:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8021122:	e082      	b.n	802122a <proc_variable_decl+0x2b6>

	case finsh_token_type_assign:/*'=', it's a variable with assign declaration.*/
	{
		struct finsh_node *idnode;

		assign = proc_assign_expr(self);
 8021124:	6878      	ldr	r0, [r7, #4]
 8021126:	f000 f9ad 	bl	8021484 <proc_assign_expr>
 802112a:	62f8      	str	r0, [r7, #44]	; 0x2c
		if (assign != NULL)
 802112c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802112e:	2b00      	cmp	r3, #0
 8021130:	d015      	beq.n	802115e <proc_variable_decl+0x1ea>
		{
			idnode = finsh_node_new_id(id);
 8021132:	f107 030c 	add.w	r3, r7, #12
 8021136:	4618      	mov	r0, r3
 8021138:	f7fe feda 	bl	801fef0 <finsh_node_new_id>
 802113c:	6238      	str	r0, [r7, #32]

			/* make assign expression node */
			end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
 802113e:	2013      	movs	r0, #19
 8021140:	6a39      	ldr	r1, [r7, #32]
 8021142:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8021144:	f000 fd48 	bl	8021bd8 <make_sys_node>
 8021148:	6378      	str	r0, [r7, #52]	; 0x34
			node = end;
 802114a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802114c:	63bb      	str	r3, [r7, #56]	; 0x38

			next_token(token, &(self->token));
 802114e:	687b      	ldr	r3, [r7, #4]
 8021150:	3304      	adds	r3, #4
 8021152:	4618      	mov	r0, r3
 8021154:	f000 ff7c 	bl	8022050 <finsh_token_token>
 8021158:	4603      	mov	r3, r0
 802115a:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
		}

		while ( token == finsh_token_type_comma )
 802115e:	e04e      	b.n	80211fe <proc_variable_decl+0x28a>
		{
			if (proc_identifier(self, id) == 0)
 8021160:	f107 030c 	add.w	r3, r7, #12
 8021164:	6878      	ldr	r0, [r7, #4]
 8021166:	4619      	mov	r1, r3
 8021168:	f000 f932 	bl	80213d0 <proc_identifier>
 802116c:	4603      	mov	r3, r0
 802116e:	2b00      	cmp	r3, #0
 8021170:	d10d      	bne.n	802118e <proc_variable_decl+0x21a>
			{
				/* if add variable failed */
				if (finsh_var_insert(id, type) < 0)
 8021172:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8021176:	f107 020c 	add.w	r2, r7, #12
 802117a:	4610      	mov	r0, r2
 802117c:	4619      	mov	r1, r3
 802117e:	f000 fe15 	bl	8021dac <finsh_var_insert>
 8021182:	4603      	mov	r3, r0
 8021184:	2b00      	cmp	r3, #0
 8021186:	da02      	bge.n	802118e <proc_variable_decl+0x21a>
				{
					finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
 8021188:	2004      	movs	r0, #4
 802118a:	f7fe fc3d 	bl	801fa08 <finsh_error_set>
				}
			}

			next_token(token, &(self->token));
 802118e:	687b      	ldr	r3, [r7, #4]
 8021190:	3304      	adds	r3, #4
 8021192:	4618      	mov	r0, r3
 8021194:	f000 ff5c 	bl	8022050 <finsh_token_token>
 8021198:	4603      	mov	r3, r0
 802119a:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
			if (token == finsh_token_type_assign)
 802119e:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 80211a2:	2b0c      	cmp	r3, #12
 80211a4:	d12b      	bne.n	80211fe <proc_variable_decl+0x28a>
			{
				/* get the right side of assign expression */
				assign = proc_assign_expr(self);
 80211a6:	6878      	ldr	r0, [r7, #4]
 80211a8:	f000 f96c 	bl	8021484 <proc_assign_expr>
 80211ac:	62f8      	str	r0, [r7, #44]	; 0x2c

				if (assign != NULL)
 80211ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80211b0:	2b00      	cmp	r3, #0
 80211b2:	d024      	beq.n	80211fe <proc_variable_decl+0x28a>
				{
					idnode = finsh_node_new_id(id);
 80211b4:	f107 030c 	add.w	r3, r7, #12
 80211b8:	4618      	mov	r0, r3
 80211ba:	f7fe fe99 	bl	801fef0 <finsh_node_new_id>
 80211be:	6238      	str	r0, [r7, #32]

					/* make assign expression node */
					if (node != NULL)
 80211c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80211c2:	2b00      	cmp	r3, #0
 80211c4:	d00b      	beq.n	80211de <proc_variable_decl+0x26a>
					{
						finsh_node_sibling(end) = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
 80211c6:	2013      	movs	r0, #19
 80211c8:	6a39      	ldr	r1, [r7, #32]
 80211ca:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80211cc:	f000 fd04 	bl	8021bd8 <make_sys_node>
 80211d0:	4602      	mov	r2, r0
 80211d2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80211d4:	60da      	str	r2, [r3, #12]
						end = finsh_node_sibling(end);
 80211d6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80211d8:	68db      	ldr	r3, [r3, #12]
 80211da:	637b      	str	r3, [r7, #52]	; 0x34
 80211dc:	e007      	b.n	80211ee <proc_variable_decl+0x27a>
					}
					else
					{
						end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
 80211de:	2013      	movs	r0, #19
 80211e0:	6a39      	ldr	r1, [r7, #32]
 80211e2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80211e4:	f000 fcf8 	bl	8021bd8 <make_sys_node>
 80211e8:	6378      	str	r0, [r7, #52]	; 0x34
						node = end;
 80211ea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80211ec:	63bb      	str	r3, [r7, #56]	; 0x38
					}

					next_token(token, &(self->token));
 80211ee:	687b      	ldr	r3, [r7, #4]
 80211f0:	3304      	adds	r3, #4
 80211f2:	4618      	mov	r0, r3
 80211f4:	f000 ff2c 	bl	8022050 <finsh_token_token>
 80211f8:	4603      	mov	r3, r0
 80211fa:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
			node = end;

			next_token(token, &(self->token));
		}

		while ( token == finsh_token_type_comma )
 80211fe:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8021202:	2b03      	cmp	r3, #3
 8021204:	d0ac      	beq.n	8021160 <proc_variable_decl+0x1ec>
					next_token(token, &(self->token));
				}
			}
		}

		check_token(token, &(self->token), finsh_token_type_semicolon);
 8021206:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 802120a:	2b04      	cmp	r3, #4
 802120c:	d005      	beq.n	802121a <proc_variable_decl+0x2a6>
 802120e:	2001      	movs	r0, #1
 8021210:	f7fe fbfa 	bl	801fa08 <finsh_error_set>
 8021214:	687b      	ldr	r3, [r7, #4]
 8021216:	2201      	movs	r2, #1
 8021218:	715a      	strb	r2, [r3, #5]
		return node;
 802121a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802121c:	e005      	b.n	802122a <proc_variable_decl+0x2b6>
	}

	case finsh_token_type_semicolon:/*';', it's a variable declaration.*/
		return node;
 802121e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8021220:	e003      	b.n	802122a <proc_variable_decl+0x2b6>

	default:
		finsh_error_set(FINSH_ERROR_EXPECT_TYPE);
 8021222:	2002      	movs	r0, #2
 8021224:	f7fe fbf0 	bl	801fa08 <finsh_error_set>

		return NULL;
 8021228:	2300      	movs	r3, #0
	}
}
 802122a:	4618      	mov	r0, r3
 802122c:	3740      	adds	r7, #64	; 0x40
 802122e:	46bd      	mov	sp, r7
 8021230:	bd80      	pop	{r7, pc}
 8021232:	bf00      	nop

08021234 <proc_type>:
	| SHORT
	| INT
	| STRING
*/
static enum finsh_type proc_type(struct finsh_parser* self)
{
 8021234:	b580      	push	{r7, lr}
 8021236:	b084      	sub	sp, #16
 8021238:	af00      	add	r7, sp, #0
 802123a:	6078      	str	r0, [r7, #4]
	enum finsh_type type;
	enum finsh_token_type token;

	/* set init type */
	type = finsh_type_unknown;
 802123c:	2300      	movs	r3, #0
 802123e:	73fb      	strb	r3, [r7, #15]

	next_token(token, &(self->token));
 8021240:	687b      	ldr	r3, [r7, #4]
 8021242:	3304      	adds	r3, #4
 8021244:	4618      	mov	r0, r3
 8021246:	f000 ff03 	bl	8022050 <finsh_token_token>
 802124a:	4603      	mov	r3, r0
 802124c:	73bb      	strb	r3, [r7, #14]
	if ( is_base_type(token) ) /* base_type */
 802124e:	7bbb      	ldrb	r3, [r7, #14]
 8021250:	2b14      	cmp	r3, #20
 8021252:	d00b      	beq.n	802126c <proc_type+0x38>
 8021254:	7bbb      	ldrb	r3, [r7, #14]
 8021256:	2b15      	cmp	r3, #21
 8021258:	d008      	beq.n	802126c <proc_type+0x38>
 802125a:	7bbb      	ldrb	r3, [r7, #14]
 802125c:	2b16      	cmp	r3, #22
 802125e:	d005      	beq.n	802126c <proc_type+0x38>
 8021260:	7bbb      	ldrb	r3, [r7, #14]
 8021262:	2b17      	cmp	r3, #23
 8021264:	d002      	beq.n	802126c <proc_type+0x38>
 8021266:	7bbb      	ldrb	r3, [r7, #14]
 8021268:	2b18      	cmp	r3, #24
 802126a:	d121      	bne.n	80212b0 <proc_type+0x7c>
	{
		switch (token)
 802126c:	7bbb      	ldrb	r3, [r7, #14]
 802126e:	3b14      	subs	r3, #20
 8021270:	2b04      	cmp	r3, #4
 8021272:	f200 809f 	bhi.w	80213b4 <proc_type+0x180>
 8021276:	a201      	add	r2, pc, #4	; (adr r2, 802127c <proc_type+0x48>)
 8021278:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802127c:	08021291 	.word	0x08021291
 8021280:	08021297 	.word	0x08021297
 8021284:	0802129d 	.word	0x0802129d
 8021288:	080212a3 	.word	0x080212a3
 802128c:	080212a9 	.word	0x080212a9
		{
		case finsh_token_type_void:
			type = finsh_type_void;
 8021290:	2301      	movs	r3, #1
 8021292:	73fb      	strb	r3, [r7, #15]
			break;
 8021294:	e00b      	b.n	80212ae <proc_type+0x7a>

		case finsh_token_type_char:
			type = finsh_type_char;
 8021296:	2303      	movs	r3, #3
 8021298:	73fb      	strb	r3, [r7, #15]
			break;
 802129a:	e008      	b.n	80212ae <proc_type+0x7a>

		case finsh_token_type_short:
			type = finsh_type_short;
 802129c:	2306      	movs	r3, #6
 802129e:	73fb      	strb	r3, [r7, #15]
			break;
 80212a0:	e005      	b.n	80212ae <proc_type+0x7a>

		case finsh_token_type_int:
			type = finsh_type_int;
 80212a2:	2309      	movs	r3, #9
 80212a4:	73fb      	strb	r3, [r7, #15]
			break;
 80212a6:	e002      	b.n	80212ae <proc_type+0x7a>

		case finsh_token_type_long:
			type = finsh_type_long;
 80212a8:	230c      	movs	r3, #12
 80212aa:	73fb      	strb	r3, [r7, #15]
			break;
 80212ac:	bf00      	nop

		default:
			goto __return;
		}
	}
 80212ae:	e03d      	b.n	802132c <proc_type+0xf8>
	else if ( token == finsh_token_type_unsigned ) /* unsigned base_type */
 80212b0:	7bbb      	ldrb	r3, [r7, #14]
 80212b2:	2b19      	cmp	r3, #25
 80212b4:	d139      	bne.n	802132a <proc_type+0xf6>
	{
		next_token(token, &(self->token));
 80212b6:	687b      	ldr	r3, [r7, #4]
 80212b8:	3304      	adds	r3, #4
 80212ba:	4618      	mov	r0, r3
 80212bc:	f000 fec8 	bl	8022050 <finsh_token_token>
 80212c0:	4603      	mov	r3, r0
 80212c2:	73bb      	strb	r3, [r7, #14]
		if ( is_base_type(token) )
 80212c4:	7bbb      	ldrb	r3, [r7, #14]
 80212c6:	2b14      	cmp	r3, #20
 80212c8:	d00b      	beq.n	80212e2 <proc_type+0xae>
 80212ca:	7bbb      	ldrb	r3, [r7, #14]
 80212cc:	2b15      	cmp	r3, #21
 80212ce:	d008      	beq.n	80212e2 <proc_type+0xae>
 80212d0:	7bbb      	ldrb	r3, [r7, #14]
 80212d2:	2b16      	cmp	r3, #22
 80212d4:	d005      	beq.n	80212e2 <proc_type+0xae>
 80212d6:	7bbb      	ldrb	r3, [r7, #14]
 80212d8:	2b17      	cmp	r3, #23
 80212da:	d002      	beq.n	80212e2 <proc_type+0xae>
 80212dc:	7bbb      	ldrb	r3, [r7, #14]
 80212de:	2b18      	cmp	r3, #24
 80212e0:	d11c      	bne.n	802131c <proc_type+0xe8>
		{
			switch (token)
 80212e2:	7bbb      	ldrb	r3, [r7, #14]
 80212e4:	3b15      	subs	r3, #21
 80212e6:	2b03      	cmp	r3, #3
 80212e8:	d866      	bhi.n	80213b8 <proc_type+0x184>
 80212ea:	a201      	add	r2, pc, #4	; (adr r2, 80212f0 <proc_type+0xbc>)
 80212ec:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80212f0:	08021301 	.word	0x08021301
 80212f4:	08021307 	.word	0x08021307
 80212f8:	0802130d 	.word	0x0802130d
 80212fc:	08021313 	.word	0x08021313
			{
			case finsh_token_type_char:
				type = finsh_type_uchar;
 8021300:	2304      	movs	r3, #4
 8021302:	73fb      	strb	r3, [r7, #15]
				break;
 8021304:	e008      	b.n	8021318 <proc_type+0xe4>

			case finsh_token_type_short:
				type = finsh_type_ushort;
 8021306:	2307      	movs	r3, #7
 8021308:	73fb      	strb	r3, [r7, #15]
				break;
 802130a:	e005      	b.n	8021318 <proc_type+0xe4>

			case finsh_token_type_int:
				type = finsh_type_uint;
 802130c:	230a      	movs	r3, #10
 802130e:	73fb      	strb	r3, [r7, #15]
				break;
 8021310:	e002      	b.n	8021318 <proc_type+0xe4>

			case finsh_token_type_long:
				type = finsh_type_ulong;
 8021312:	230d      	movs	r3, #13
 8021314:	73fb      	strb	r3, [r7, #15]
				break;
 8021316:	bf00      	nop

			default:
				goto __return;
			}
		}
 8021318:	bf00      	nop
 802131a:	e007      	b.n	802132c <proc_type+0xf8>
		else
		{
			finsh_token_replay(&(self->token));
 802131c:	687b      	ldr	r3, [r7, #4]
 802131e:	2201      	movs	r2, #1
 8021320:	715a      	strb	r2, [r3, #5]
			finsh_error_set(FINSH_ERROR_EXPECT_TYPE);
 8021322:	2002      	movs	r0, #2
 8021324:	f7fe fb70 	bl	801fa08 <finsh_error_set>
 8021328:	e000      	b.n	802132c <proc_type+0xf8>
		}
	}
	else
	{
		goto __return;
 802132a:	e046      	b.n	80213ba <proc_type+0x186>
	}

	/* parse for pointer */
	next_token(token, &(self->token));
 802132c:	687b      	ldr	r3, [r7, #4]
 802132e:	3304      	adds	r3, #4
 8021330:	4618      	mov	r0, r3
 8021332:	f000 fe8d 	bl	8022050 <finsh_token_token>
 8021336:	4603      	mov	r3, r0
 8021338:	73bb      	strb	r3, [r7, #14]
	if (token == finsh_token_type_mul)
 802133a:	7bbb      	ldrb	r3, [r7, #14]
 802133c:	2b05      	cmp	r3, #5
 802133e:	d134      	bne.n	80213aa <proc_type+0x176>
	{
		switch (type)
 8021340:	7bfb      	ldrb	r3, [r7, #15]
 8021342:	3b01      	subs	r3, #1
 8021344:	2b0c      	cmp	r3, #12
 8021346:	d82c      	bhi.n	80213a2 <proc_type+0x16e>
 8021348:	a201      	add	r2, pc, #4	; (adr r2, 8021350 <proc_type+0x11c>)
 802134a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802134e:	bf00      	nop
 8021350:	08021385 	.word	0x08021385
 8021354:	080213a3 	.word	0x080213a3
 8021358:	0802138b 	.word	0x0802138b
 802135c:	0802138b 	.word	0x0802138b
 8021360:	080213a3 	.word	0x080213a3
 8021364:	08021391 	.word	0x08021391
 8021368:	08021391 	.word	0x08021391
 802136c:	080213a3 	.word	0x080213a3
 8021370:	08021397 	.word	0x08021397
 8021374:	08021397 	.word	0x08021397
 8021378:	080213a3 	.word	0x080213a3
 802137c:	0802139d 	.word	0x0802139d
 8021380:	0802139d 	.word	0x0802139d
		{
		case finsh_type_void:
			type = finsh_type_voidp;
 8021384:	2302      	movs	r3, #2
 8021386:	73fb      	strb	r3, [r7, #15]
			break;
 8021388:	e00e      	b.n	80213a8 <proc_type+0x174>

		case finsh_type_char:
		case finsh_type_uchar:
			type = finsh_type_charp;
 802138a:	2305      	movs	r3, #5
 802138c:	73fb      	strb	r3, [r7, #15]
			break;
 802138e:	e00b      	b.n	80213a8 <proc_type+0x174>

		case finsh_type_short:
		case finsh_type_ushort:
			type = finsh_type_shortp;
 8021390:	2308      	movs	r3, #8
 8021392:	73fb      	strb	r3, [r7, #15]
			break;
 8021394:	e008      	b.n	80213a8 <proc_type+0x174>

		case finsh_type_int:
		case finsh_type_uint:
			type = finsh_type_intp;
 8021396:	230b      	movs	r3, #11
 8021398:	73fb      	strb	r3, [r7, #15]
			break;
 802139a:	e005      	b.n	80213a8 <proc_type+0x174>

		case finsh_type_long:
		case finsh_type_ulong:
			type = finsh_type_longp;
 802139c:	230e      	movs	r3, #14
 802139e:	73fb      	strb	r3, [r7, #15]
			break;
 80213a0:	e002      	b.n	80213a8 <proc_type+0x174>

		default:
			type = finsh_type_voidp;
 80213a2:	2302      	movs	r3, #2
 80213a4:	73fb      	strb	r3, [r7, #15]
			break;
 80213a6:	bf00      	nop
 80213a8:	e002      	b.n	80213b0 <proc_type+0x17c>
		}
	}
	else finsh_token_replay(&(self->token));
 80213aa:	687b      	ldr	r3, [r7, #4]
 80213ac:	2201      	movs	r2, #1
 80213ae:	715a      	strb	r2, [r3, #5]

	return type;
 80213b0:	7bfb      	ldrb	r3, [r7, #15]
 80213b2:	e009      	b.n	80213c8 <proc_type+0x194>
		case finsh_token_type_long:
			type = finsh_type_long;
			break;

		default:
			goto __return;
 80213b4:	bf00      	nop
 80213b6:	e000      	b.n	80213ba <proc_type+0x186>
			case finsh_token_type_long:
				type = finsh_type_ulong;
				break;

			default:
				goto __return;
 80213b8:	bf00      	nop
	else finsh_token_replay(&(self->token));

	return type;

__return:
	finsh_token_replay(&(self->token));
 80213ba:	687b      	ldr	r3, [r7, #4]
 80213bc:	2201      	movs	r2, #1
 80213be:	715a      	strb	r2, [r3, #5]
	finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
 80213c0:	2003      	movs	r0, #3
 80213c2:	f7fe fb21 	bl	801fa08 <finsh_error_set>

	return type;
 80213c6:	7bfb      	ldrb	r3, [r7, #15]
}
 80213c8:	4618      	mov	r0, r3
 80213ca:	3710      	adds	r7, #16
 80213cc:	46bd      	mov	sp, r7
 80213ce:	bd80      	pop	{r7, pc}

080213d0 <proc_identifier>:

/*
identifier -> IDENTIFIER
*/
static int proc_identifier(struct finsh_parser* self, char* id)
{
 80213d0:	b580      	push	{r7, lr}
 80213d2:	b084      	sub	sp, #16
 80213d4:	af00      	add	r7, sp, #0
 80213d6:	6078      	str	r0, [r7, #4]
 80213d8:	6039      	str	r1, [r7, #0]
	enum finsh_token_type token;

	match_token(token, &(self->token), finsh_token_type_identifier);
 80213da:	687b      	ldr	r3, [r7, #4]
 80213dc:	3304      	adds	r3, #4
 80213de:	4618      	mov	r0, r3
 80213e0:	f000 fe36 	bl	8022050 <finsh_token_token>
 80213e4:	4603      	mov	r3, r0
 80213e6:	73fb      	strb	r3, [r7, #15]
 80213e8:	7bfb      	ldrb	r3, [r7, #15]
 80213ea:	2b1f      	cmp	r3, #31
 80213ec:	d005      	beq.n	80213fa <proc_identifier+0x2a>
 80213ee:	2001      	movs	r0, #1
 80213f0:	f7fe fb0a 	bl	801fa08 <finsh_error_set>
 80213f4:	687b      	ldr	r3, [r7, #4]
 80213f6:	2201      	movs	r2, #1
 80213f8:	715a      	strb	r2, [r3, #5]

	strncpy(id, (char*)self->token.string, FINSH_NAME_MAX);
 80213fa:	687b      	ldr	r3, [r7, #4]
 80213fc:	3314      	adds	r3, #20
 80213fe:	6838      	ldr	r0, [r7, #0]
 8021400:	4619      	mov	r1, r3
 8021402:	2210      	movs	r2, #16
 8021404:	f002 f9c8 	bl	8023798 <strncpy>

	return 0;
 8021408:	2300      	movs	r3, #0
}
 802140a:	4618      	mov	r0, r3
 802140c:	3710      	adds	r7, #16
 802140e:	46bd      	mov	sp, r7
 8021410:	bd80      	pop	{r7, pc}
 8021412:	bf00      	nop

08021414 <proc_expr_statement>:
/*
statement_expr -> ';'
	| expr ';'
*/
static struct finsh_node* proc_expr_statement(struct finsh_parser* self)
{
 8021414:	b580      	push	{r7, lr}
 8021416:	b084      	sub	sp, #16
 8021418:	af00      	add	r7, sp, #0
 802141a:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* expr;

	expr = NULL;
 802141c:	2300      	movs	r3, #0
 802141e:	60fb      	str	r3, [r7, #12]
	next_token(token, &(self->token));
 8021420:	687b      	ldr	r3, [r7, #4]
 8021422:	3304      	adds	r3, #4
 8021424:	4618      	mov	r0, r3
 8021426:	f000 fe13 	bl	8022050 <finsh_token_token>
 802142a:	4603      	mov	r3, r0
 802142c:	72fb      	strb	r3, [r7, #11]
	if ( token != finsh_token_type_semicolon )
 802142e:	7afb      	ldrb	r3, [r7, #11]
 8021430:	2b04      	cmp	r3, #4
 8021432:	d016      	beq.n	8021462 <proc_expr_statement+0x4e>
	{
		finsh_token_replay(&(self->token));
 8021434:	687b      	ldr	r3, [r7, #4]
 8021436:	2201      	movs	r2, #1
 8021438:	715a      	strb	r2, [r3, #5]
		expr = proc_expr(self);
 802143a:	6878      	ldr	r0, [r7, #4]
 802143c:	f000 f816 	bl	802146c <proc_expr>
 8021440:	60f8      	str	r0, [r7, #12]

		match_token(token, &(self->token), finsh_token_type_semicolon);
 8021442:	687b      	ldr	r3, [r7, #4]
 8021444:	3304      	adds	r3, #4
 8021446:	4618      	mov	r0, r3
 8021448:	f000 fe02 	bl	8022050 <finsh_token_token>
 802144c:	4603      	mov	r3, r0
 802144e:	72fb      	strb	r3, [r7, #11]
 8021450:	7afb      	ldrb	r3, [r7, #11]
 8021452:	2b04      	cmp	r3, #4
 8021454:	d005      	beq.n	8021462 <proc_expr_statement+0x4e>
 8021456:	2001      	movs	r0, #1
 8021458:	f7fe fad6 	bl	801fa08 <finsh_error_set>
 802145c:	687b      	ldr	r3, [r7, #4]
 802145e:	2201      	movs	r2, #1
 8021460:	715a      	strb	r2, [r3, #5]
	}

	return expr;
 8021462:	68fb      	ldr	r3, [r7, #12]
}
 8021464:	4618      	mov	r0, r3
 8021466:	3710      	adds	r7, #16
 8021468:	46bd      	mov	sp, r7
 802146a:	bd80      	pop	{r7, pc}

0802146c <proc_expr>:

/*
expr -> expr_assign
*/
static struct finsh_node* proc_expr(struct finsh_parser* self)
{
 802146c:	b580      	push	{r7, lr}
 802146e:	b082      	sub	sp, #8
 8021470:	af00      	add	r7, sp, #0
 8021472:	6078      	str	r0, [r7, #4]
	return proc_assign_expr(self);
 8021474:	6878      	ldr	r0, [r7, #4]
 8021476:	f000 f805 	bl	8021484 <proc_assign_expr>
 802147a:	4603      	mov	r3, r0
}
 802147c:	4618      	mov	r0, r3
 802147e:	3708      	adds	r7, #8
 8021480:	46bd      	mov	sp, r7
 8021482:	bd80      	pop	{r7, pc}

08021484 <proc_assign_expr>:
/*
expr_assign -> expr_inclusive_or
	| expr_unary ASSIGN expr_assign
*/
static struct finsh_node* proc_assign_expr(struct finsh_parser* self)
{
 8021484:	b580      	push	{r7, lr}
 8021486:	b086      	sub	sp, #24
 8021488:	af00      	add	r7, sp, #0
 802148a:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* or;
	struct finsh_node* assign;

	or = proc_inclusive_or_expr(self);
 802148c:	6878      	ldr	r0, [r7, #4]
 802148e:	f000 f81f 	bl	80214d0 <proc_inclusive_or_expr>
 8021492:	6178      	str	r0, [r7, #20]

	next_token(token, &(self->token));
 8021494:	687b      	ldr	r3, [r7, #4]
 8021496:	3304      	adds	r3, #4
 8021498:	4618      	mov	r0, r3
 802149a:	f000 fdd9 	bl	8022050 <finsh_token_token>
 802149e:	4603      	mov	r3, r0
 80214a0:	74fb      	strb	r3, [r7, #19]

	if (token == finsh_token_type_assign)
 80214a2:	7cfb      	ldrb	r3, [r7, #19]
 80214a4:	2b0c      	cmp	r3, #12
 80214a6:	d10a      	bne.n	80214be <proc_assign_expr+0x3a>
	{
		assign = proc_assign_expr(self);
 80214a8:	6878      	ldr	r0, [r7, #4]
 80214aa:	f7ff ffeb 	bl	8021484 <proc_assign_expr>
 80214ae:	60f8      	str	r0, [r7, #12]

		return make_sys_node(FINSH_NODE_SYS_ASSIGN, or, assign);
 80214b0:	2013      	movs	r0, #19
 80214b2:	6979      	ldr	r1, [r7, #20]
 80214b4:	68fa      	ldr	r2, [r7, #12]
 80214b6:	f000 fb8f 	bl	8021bd8 <make_sys_node>
 80214ba:	4603      	mov	r3, r0
 80214bc:	e003      	b.n	80214c6 <proc_assign_expr+0x42>
	}
	else finsh_token_replay(&(self->token));
 80214be:	687b      	ldr	r3, [r7, #4]
 80214c0:	2201      	movs	r2, #1
 80214c2:	715a      	strb	r2, [r3, #5]

	return or;
 80214c4:	697b      	ldr	r3, [r7, #20]
}
 80214c6:	4618      	mov	r0, r3
 80214c8:	3718      	adds	r7, #24
 80214ca:	46bd      	mov	sp, r7
 80214cc:	bd80      	pop	{r7, pc}
 80214ce:	bf00      	nop

080214d0 <proc_inclusive_or_expr>:
/*
expr_inclusive_or -> expr_exclusive_or
	| expr_inclusive_or '|' expr_exclusive_or
*/
static struct finsh_node* proc_inclusive_or_expr(struct finsh_parser* self)
{
 80214d0:	b580      	push	{r7, lr}
 80214d2:	b086      	sub	sp, #24
 80214d4:	af00      	add	r7, sp, #0
 80214d6:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* xor;
	struct finsh_node* xor_new;

	xor = proc_exclusive_or_expr(self);
 80214d8:	6878      	ldr	r0, [r7, #4]
 80214da:	f000 f82d 	bl	8021538 <proc_exclusive_or_expr>
 80214de:	6138      	str	r0, [r7, #16]

	next_token(token, &(self->token));
 80214e0:	687b      	ldr	r3, [r7, #4]
 80214e2:	3304      	adds	r3, #4
 80214e4:	4618      	mov	r0, r3
 80214e6:	f000 fdb3 	bl	8022050 <finsh_token_token>
 80214ea:	4603      	mov	r3, r0
 80214ec:	75fb      	strb	r3, [r7, #23]
	while ( token == finsh_token_type_or )
 80214ee:	e017      	b.n	8021520 <proc_inclusive_or_expr+0x50>
	{
		xor_new = proc_exclusive_or_expr(self);
 80214f0:	6878      	ldr	r0, [r7, #4]
 80214f2:	f000 f821 	bl	8021538 <proc_exclusive_or_expr>
 80214f6:	60f8      	str	r0, [r7, #12]

		if (xor_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 80214f8:	68fb      	ldr	r3, [r7, #12]
 80214fa:	2b00      	cmp	r3, #0
 80214fc:	d103      	bne.n	8021506 <proc_inclusive_or_expr+0x36>
 80214fe:	2005      	movs	r0, #5
 8021500:	f7fe fa82 	bl	801fa08 <finsh_error_set>
 8021504:	e005      	b.n	8021512 <proc_inclusive_or_expr+0x42>
		else xor = make_sys_node(FINSH_NODE_SYS_OR, xor, xor_new);
 8021506:	200d      	movs	r0, #13
 8021508:	6939      	ldr	r1, [r7, #16]
 802150a:	68fa      	ldr	r2, [r7, #12]
 802150c:	f000 fb64 	bl	8021bd8 <make_sys_node>
 8021510:	6138      	str	r0, [r7, #16]

		next_token(token, &(self->token));
 8021512:	687b      	ldr	r3, [r7, #4]
 8021514:	3304      	adds	r3, #4
 8021516:	4618      	mov	r0, r3
 8021518:	f000 fd9a 	bl	8022050 <finsh_token_token>
 802151c:	4603      	mov	r3, r0
 802151e:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* xor_new;

	xor = proc_exclusive_or_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_or )
 8021520:	7dfb      	ldrb	r3, [r7, #23]
 8021522:	2b0e      	cmp	r3, #14
 8021524:	d0e4      	beq.n	80214f0 <proc_inclusive_or_expr+0x20>
		else xor = make_sys_node(FINSH_NODE_SYS_OR, xor, xor_new);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 8021526:	687b      	ldr	r3, [r7, #4]
 8021528:	2201      	movs	r2, #1
 802152a:	715a      	strb	r2, [r3, #5]
	return xor;
 802152c:	693b      	ldr	r3, [r7, #16]
}
 802152e:	4618      	mov	r0, r3
 8021530:	3718      	adds	r7, #24
 8021532:	46bd      	mov	sp, r7
 8021534:	bd80      	pop	{r7, pc}
 8021536:	bf00      	nop

08021538 <proc_exclusive_or_expr>:
/*
expr_exclusive_or -> expr_and
	| expr_exclusive '^' expr_and
*/
static struct finsh_node* proc_exclusive_or_expr(struct finsh_parser* self)
{
 8021538:	b580      	push	{r7, lr}
 802153a:	b086      	sub	sp, #24
 802153c:	af00      	add	r7, sp, #0
 802153e:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* and;
	struct finsh_node* and_new;

	and = proc_and_expr(self);
 8021540:	6878      	ldr	r0, [r7, #4]
 8021542:	f000 f82d 	bl	80215a0 <proc_and_expr>
 8021546:	6138      	str	r0, [r7, #16]
	next_token(token, &(self->token));
 8021548:	687b      	ldr	r3, [r7, #4]
 802154a:	3304      	adds	r3, #4
 802154c:	4618      	mov	r0, r3
 802154e:	f000 fd7f 	bl	8022050 <finsh_token_token>
 8021552:	4603      	mov	r3, r0
 8021554:	75fb      	strb	r3, [r7, #23]
	while ( token == finsh_token_type_xor )
 8021556:	e017      	b.n	8021588 <proc_exclusive_or_expr+0x50>
	{
		and_new = proc_and_expr(self);
 8021558:	6878      	ldr	r0, [r7, #4]
 802155a:	f000 f821 	bl	80215a0 <proc_and_expr>
 802155e:	60f8      	str	r0, [r7, #12]
		if (and_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 8021560:	68fb      	ldr	r3, [r7, #12]
 8021562:	2b00      	cmp	r3, #0
 8021564:	d103      	bne.n	802156e <proc_exclusive_or_expr+0x36>
 8021566:	2005      	movs	r0, #5
 8021568:	f7fe fa4e 	bl	801fa08 <finsh_error_set>
 802156c:	e005      	b.n	802157a <proc_exclusive_or_expr+0x42>
		else and = make_sys_node(FINSH_NODE_SYS_XOR, and, and_new);
 802156e:	200e      	movs	r0, #14
 8021570:	6939      	ldr	r1, [r7, #16]
 8021572:	68fa      	ldr	r2, [r7, #12]
 8021574:	f000 fb30 	bl	8021bd8 <make_sys_node>
 8021578:	6138      	str	r0, [r7, #16]

		next_token(token, &(self->token));
 802157a:	687b      	ldr	r3, [r7, #4]
 802157c:	3304      	adds	r3, #4
 802157e:	4618      	mov	r0, r3
 8021580:	f000 fd66 	bl	8022050 <finsh_token_token>
 8021584:	4603      	mov	r3, r0
 8021586:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* and;
	struct finsh_node* and_new;

	and = proc_and_expr(self);
	next_token(token, &(self->token));
	while ( token == finsh_token_type_xor )
 8021588:	7dfb      	ldrb	r3, [r7, #23]
 802158a:	2b0f      	cmp	r3, #15
 802158c:	d0e4      	beq.n	8021558 <proc_exclusive_or_expr+0x20>
		else and = make_sys_node(FINSH_NODE_SYS_XOR, and, and_new);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 802158e:	687b      	ldr	r3, [r7, #4]
 8021590:	2201      	movs	r2, #1
 8021592:	715a      	strb	r2, [r3, #5]
	return and;
 8021594:	693b      	ldr	r3, [r7, #16]
}
 8021596:	4618      	mov	r0, r3
 8021598:	3718      	adds	r7, #24
 802159a:	46bd      	mov	sp, r7
 802159c:	bd80      	pop	{r7, pc}
 802159e:	bf00      	nop

080215a0 <proc_and_expr>:
/*
expr_and -> expr_shift
	| expr_and '&' expr_shift
*/
static struct finsh_node* proc_and_expr(struct finsh_parser* self)
{
 80215a0:	b580      	push	{r7, lr}
 80215a2:	b086      	sub	sp, #24
 80215a4:	af00      	add	r7, sp, #0
 80215a6:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* shift;
	struct finsh_node* shift_new;

	shift = proc_shift_expr(self);
 80215a8:	6878      	ldr	r0, [r7, #4]
 80215aa:	f000 f82d 	bl	8021608 <proc_shift_expr>
 80215ae:	6138      	str	r0, [r7, #16]

	next_token(token, &(self->token));
 80215b0:	687b      	ldr	r3, [r7, #4]
 80215b2:	3304      	adds	r3, #4
 80215b4:	4618      	mov	r0, r3
 80215b6:	f000 fd4b 	bl	8022050 <finsh_token_token>
 80215ba:	4603      	mov	r3, r0
 80215bc:	75fb      	strb	r3, [r7, #23]
	while ( token == finsh_token_type_and )
 80215be:	e017      	b.n	80215f0 <proc_and_expr+0x50>
	{
		shift_new = proc_shift_expr(self);
 80215c0:	6878      	ldr	r0, [r7, #4]
 80215c2:	f000 f821 	bl	8021608 <proc_shift_expr>
 80215c6:	60f8      	str	r0, [r7, #12]

		if (shift_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 80215c8:	68fb      	ldr	r3, [r7, #12]
 80215ca:	2b00      	cmp	r3, #0
 80215cc:	d103      	bne.n	80215d6 <proc_and_expr+0x36>
 80215ce:	2005      	movs	r0, #5
 80215d0:	f7fe fa1a 	bl	801fa08 <finsh_error_set>
 80215d4:	e005      	b.n	80215e2 <proc_and_expr+0x42>
		else shift = make_sys_node(FINSH_NODE_SYS_AND, shift, shift_new);
 80215d6:	200c      	movs	r0, #12
 80215d8:	6939      	ldr	r1, [r7, #16]
 80215da:	68fa      	ldr	r2, [r7, #12]
 80215dc:	f000 fafc 	bl	8021bd8 <make_sys_node>
 80215e0:	6138      	str	r0, [r7, #16]

		next_token(token, &(self->token));
 80215e2:	687b      	ldr	r3, [r7, #4]
 80215e4:	3304      	adds	r3, #4
 80215e6:	4618      	mov	r0, r3
 80215e8:	f000 fd32 	bl	8022050 <finsh_token_token>
 80215ec:	4603      	mov	r3, r0
 80215ee:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* shift_new;

	shift = proc_shift_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_and )
 80215f0:	7dfb      	ldrb	r3, [r7, #23]
 80215f2:	2b0d      	cmp	r3, #13
 80215f4:	d0e4      	beq.n	80215c0 <proc_and_expr+0x20>
		else shift = make_sys_node(FINSH_NODE_SYS_AND, shift, shift_new);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 80215f6:	687b      	ldr	r3, [r7, #4]
 80215f8:	2201      	movs	r2, #1
 80215fa:	715a      	strb	r2, [r3, #5]
	return shift;
 80215fc:	693b      	ldr	r3, [r7, #16]
}
 80215fe:	4618      	mov	r0, r3
 8021600:	3718      	adds	r7, #24
 8021602:	46bd      	mov	sp, r7
 8021604:	bd80      	pop	{r7, pc}
 8021606:	bf00      	nop

08021608 <proc_shift_expr>:
expr_shift -> expr_additive
	| expr_shift '<<' expr_additive
	| expr_shift '>>' expr_additive
*/
static struct finsh_node* proc_shift_expr(struct finsh_parser* self)
{
 8021608:	b580      	push	{r7, lr}
 802160a:	b086      	sub	sp, #24
 802160c:	af00      	add	r7, sp, #0
 802160e:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* add;
	struct finsh_node* add_new;

	add = proc_additive_expr(self);
 8021610:	6878      	ldr	r0, [r7, #4]
 8021612:	f000 f841 	bl	8021698 <proc_additive_expr>
 8021616:	6138      	str	r0, [r7, #16]

	next_token(token, &(self->token));
 8021618:	687b      	ldr	r3, [r7, #4]
 802161a:	3304      	adds	r3, #4
 802161c:	4618      	mov	r0, r3
 802161e:	f000 fd17 	bl	8022050 <finsh_token_token>
 8021622:	4603      	mov	r3, r0
 8021624:	75fb      	strb	r3, [r7, #23]
	while ( token == finsh_token_type_shl || token == finsh_token_type_shr)
 8021626:	e029      	b.n	802167c <proc_shift_expr+0x74>
	{
		add_new = proc_additive_expr(self);
 8021628:	6878      	ldr	r0, [r7, #4]
 802162a:	f000 f835 	bl	8021698 <proc_additive_expr>
 802162e:	60f8      	str	r0, [r7, #12]
		if (add_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 8021630:	68fb      	ldr	r3, [r7, #12]
 8021632:	2b00      	cmp	r3, #0
 8021634:	d103      	bne.n	802163e <proc_shift_expr+0x36>
 8021636:	2005      	movs	r0, #5
 8021638:	f7fe f9e6 	bl	801fa08 <finsh_error_set>
 802163c:	e017      	b.n	802166e <proc_shift_expr+0x66>
		else
		{
			switch (token)
 802163e:	7dfb      	ldrb	r3, [r7, #23]
 8021640:	2b11      	cmp	r3, #17
 8021642:	d002      	beq.n	802164a <proc_shift_expr+0x42>
 8021644:	2b12      	cmp	r3, #18
 8021646:	d007      	beq.n	8021658 <proc_shift_expr+0x50>
 8021648:	e00d      	b.n	8021666 <proc_shift_expr+0x5e>
			{
			case finsh_token_type_shl:
				add = make_sys_node(FINSH_NODE_SYS_SHL, add, add_new);
 802164a:	2010      	movs	r0, #16
 802164c:	6939      	ldr	r1, [r7, #16]
 802164e:	68fa      	ldr	r2, [r7, #12]
 8021650:	f000 fac2 	bl	8021bd8 <make_sys_node>
 8021654:	6138      	str	r0, [r7, #16]
				break;
 8021656:	e00a      	b.n	802166e <proc_shift_expr+0x66>
			case finsh_token_type_shr:
				add = make_sys_node(FINSH_NODE_SYS_SHR, add, add_new);
 8021658:	2011      	movs	r0, #17
 802165a:	6939      	ldr	r1, [r7, #16]
 802165c:	68fa      	ldr	r2, [r7, #12]
 802165e:	f000 fabb 	bl	8021bd8 <make_sys_node>
 8021662:	6138      	str	r0, [r7, #16]
				break;
 8021664:	e003      	b.n	802166e <proc_shift_expr+0x66>
			default:
				finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 8021666:	2005      	movs	r0, #5
 8021668:	f7fe f9ce 	bl	801fa08 <finsh_error_set>
				break;
 802166c:	bf00      	nop
			}
		}
		next_token(token, &(self->token));
 802166e:	687b      	ldr	r3, [r7, #4]
 8021670:	3304      	adds	r3, #4
 8021672:	4618      	mov	r0, r3
 8021674:	f000 fcec 	bl	8022050 <finsh_token_token>
 8021678:	4603      	mov	r3, r0
 802167a:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* add_new;

	add = proc_additive_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_shl || token == finsh_token_type_shr)
 802167c:	7dfb      	ldrb	r3, [r7, #23]
 802167e:	2b11      	cmp	r3, #17
 8021680:	d0d2      	beq.n	8021628 <proc_shift_expr+0x20>
 8021682:	7dfb      	ldrb	r3, [r7, #23]
 8021684:	2b12      	cmp	r3, #18
 8021686:	d0cf      	beq.n	8021628 <proc_shift_expr+0x20>
			}
		}
		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 8021688:	687b      	ldr	r3, [r7, #4]
 802168a:	2201      	movs	r2, #1
 802168c:	715a      	strb	r2, [r3, #5]
	return add;
 802168e:	693b      	ldr	r3, [r7, #16]
}
 8021690:	4618      	mov	r0, r3
 8021692:	3718      	adds	r7, #24
 8021694:	46bd      	mov	sp, r7
 8021696:	bd80      	pop	{r7, pc}

08021698 <proc_additive_expr>:
expr_additive -> expr_multiplicative
	| expr_additive SUB expr_multiplicative
	| expr_additive ADD expr_multiplicative
*/
static struct finsh_node* proc_additive_expr(struct finsh_parser* self)
{
 8021698:	b580      	push	{r7, lr}
 802169a:	b086      	sub	sp, #24
 802169c:	af00      	add	r7, sp, #0
 802169e:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* mul;
	struct finsh_node* mul_new;

	mul = proc_multiplicative_expr(self);
 80216a0:	6878      	ldr	r0, [r7, #4]
 80216a2:	f000 f841 	bl	8021728 <proc_multiplicative_expr>
 80216a6:	6138      	str	r0, [r7, #16]

	next_token(token, &(self->token));
 80216a8:	687b      	ldr	r3, [r7, #4]
 80216aa:	3304      	adds	r3, #4
 80216ac:	4618      	mov	r0, r3
 80216ae:	f000 fccf 	bl	8022050 <finsh_token_token>
 80216b2:	4603      	mov	r3, r0
 80216b4:	75fb      	strb	r3, [r7, #23]
	while ( token == finsh_token_type_sub || token == finsh_token_type_add )
 80216b6:	e028      	b.n	802170a <proc_additive_expr+0x72>
	{
		mul_new = proc_multiplicative_expr(self);
 80216b8:	6878      	ldr	r0, [r7, #4]
 80216ba:	f000 f835 	bl	8021728 <proc_multiplicative_expr>
 80216be:	60f8      	str	r0, [r7, #12]
		if (mul_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 80216c0:	68fb      	ldr	r3, [r7, #12]
 80216c2:	2b00      	cmp	r3, #0
 80216c4:	d103      	bne.n	80216ce <proc_additive_expr+0x36>
 80216c6:	2005      	movs	r0, #5
 80216c8:	f7fe f99e 	bl	801fa08 <finsh_error_set>
 80216cc:	e016      	b.n	80216fc <proc_additive_expr+0x64>
		else
		{
			switch (token)
 80216ce:	7dfb      	ldrb	r3, [r7, #23]
 80216d0:	2b06      	cmp	r3, #6
 80216d2:	d008      	beq.n	80216e6 <proc_additive_expr+0x4e>
 80216d4:	2b08      	cmp	r3, #8
 80216d6:	d10d      	bne.n	80216f4 <proc_additive_expr+0x5c>
			{
			case finsh_token_type_sub:
				mul = make_sys_node(FINSH_NODE_SYS_SUB, mul, mul_new);
 80216d8:	2008      	movs	r0, #8
 80216da:	6939      	ldr	r1, [r7, #16]
 80216dc:	68fa      	ldr	r2, [r7, #12]
 80216de:	f000 fa7b 	bl	8021bd8 <make_sys_node>
 80216e2:	6138      	str	r0, [r7, #16]
				break;
 80216e4:	e00a      	b.n	80216fc <proc_additive_expr+0x64>
			case finsh_token_type_add:
				mul = make_sys_node(FINSH_NODE_SYS_ADD, mul, mul_new);
 80216e6:	2007      	movs	r0, #7
 80216e8:	6939      	ldr	r1, [r7, #16]
 80216ea:	68fa      	ldr	r2, [r7, #12]
 80216ec:	f000 fa74 	bl	8021bd8 <make_sys_node>
 80216f0:	6138      	str	r0, [r7, #16]
				break;
 80216f2:	e003      	b.n	80216fc <proc_additive_expr+0x64>
			default:
				finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 80216f4:	2005      	movs	r0, #5
 80216f6:	f7fe f987 	bl	801fa08 <finsh_error_set>
				break;
 80216fa:	bf00      	nop
			}
		}
		next_token(token, &(self->token));
 80216fc:	687b      	ldr	r3, [r7, #4]
 80216fe:	3304      	adds	r3, #4
 8021700:	4618      	mov	r0, r3
 8021702:	f000 fca5 	bl	8022050 <finsh_token_token>
 8021706:	4603      	mov	r3, r0
 8021708:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* mul_new;

	mul = proc_multiplicative_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_sub || token == finsh_token_type_add )
 802170a:	7dfb      	ldrb	r3, [r7, #23]
 802170c:	2b08      	cmp	r3, #8
 802170e:	d0d3      	beq.n	80216b8 <proc_additive_expr+0x20>
 8021710:	7dfb      	ldrb	r3, [r7, #23]
 8021712:	2b06      	cmp	r3, #6
 8021714:	d0d0      	beq.n	80216b8 <proc_additive_expr+0x20>
			}
		}
		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 8021716:	687b      	ldr	r3, [r7, #4]
 8021718:	2201      	movs	r2, #1
 802171a:	715a      	strb	r2, [r3, #5]
	return mul;
 802171c:	693b      	ldr	r3, [r7, #16]
}
 802171e:	4618      	mov	r0, r3
 8021720:	3718      	adds	r7, #24
 8021722:	46bd      	mov	sp, r7
 8021724:	bd80      	pop	{r7, pc}
 8021726:	bf00      	nop

08021728 <proc_multiplicative_expr>:
	| expr_multiplicative '*' expr_cast
	| expr_multiplicative '/' expr_cast
	| expr_multiplicative '%' expr_cast
*/
static struct finsh_node* proc_multiplicative_expr(struct finsh_parser* self)
{
 8021728:	b580      	push	{r7, lr}
 802172a:	b086      	sub	sp, #24
 802172c:	af00      	add	r7, sp, #0
 802172e:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* cast;
	struct finsh_node* cast_new;

	cast = proc_cast_expr(self);
 8021730:	6878      	ldr	r0, [r7, #4]
 8021732:	f000 f84d 	bl	80217d0 <proc_cast_expr>
 8021736:	6138      	str	r0, [r7, #16]
	next_token(token, &(self->token));
 8021738:	687b      	ldr	r3, [r7, #4]
 802173a:	3304      	adds	r3, #4
 802173c:	4618      	mov	r0, r3
 802173e:	f000 fc87 	bl	8022050 <finsh_token_token>
 8021742:	4603      	mov	r3, r0
 8021744:	75fb      	strb	r3, [r7, #23]
	while (token == finsh_token_type_mul ||
 8021746:	e031      	b.n	80217ac <proc_multiplicative_expr+0x84>
		token == finsh_token_type_div ||
		token == finsh_token_type_mod )
	{
		cast_new = proc_cast_expr(self);
 8021748:	6878      	ldr	r0, [r7, #4]
 802174a:	f000 f841 	bl	80217d0 <proc_cast_expr>
 802174e:	60f8      	str	r0, [r7, #12]
		if (cast_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 8021750:	68fb      	ldr	r3, [r7, #12]
 8021752:	2b00      	cmp	r3, #0
 8021754:	d103      	bne.n	802175e <proc_multiplicative_expr+0x36>
 8021756:	2005      	movs	r0, #5
 8021758:	f7fe f956 	bl	801fa08 <finsh_error_set>
 802175c:	e01f      	b.n	802179e <proc_multiplicative_expr+0x76>
		else
		{
			switch (token)
 802175e:	7dfb      	ldrb	r3, [r7, #23]
 8021760:	2b0a      	cmp	r3, #10
 8021762:	d00a      	beq.n	802177a <proc_multiplicative_expr+0x52>
 8021764:	2b0b      	cmp	r3, #11
 8021766:	d00f      	beq.n	8021788 <proc_multiplicative_expr+0x60>
 8021768:	2b05      	cmp	r3, #5
 802176a:	d114      	bne.n	8021796 <proc_multiplicative_expr+0x6e>
			{
			case finsh_token_type_mul:
				cast = make_sys_node(FINSH_NODE_SYS_MUL, cast, cast_new);
 802176c:	2009      	movs	r0, #9
 802176e:	6939      	ldr	r1, [r7, #16]
 8021770:	68fa      	ldr	r2, [r7, #12]
 8021772:	f000 fa31 	bl	8021bd8 <make_sys_node>
 8021776:	6138      	str	r0, [r7, #16]
				break;
 8021778:	e011      	b.n	802179e <proc_multiplicative_expr+0x76>

			case finsh_token_type_div:
				cast = make_sys_node(FINSH_NODE_SYS_DIV, cast, cast_new);
 802177a:	200a      	movs	r0, #10
 802177c:	6939      	ldr	r1, [r7, #16]
 802177e:	68fa      	ldr	r2, [r7, #12]
 8021780:	f000 fa2a 	bl	8021bd8 <make_sys_node>
 8021784:	6138      	str	r0, [r7, #16]
				break;
 8021786:	e00a      	b.n	802179e <proc_multiplicative_expr+0x76>

			case finsh_token_type_mod:
				cast = make_sys_node(FINSH_NODE_SYS_MOD, cast, cast_new);
 8021788:	200b      	movs	r0, #11
 802178a:	6939      	ldr	r1, [r7, #16]
 802178c:	68fa      	ldr	r2, [r7, #12]
 802178e:	f000 fa23 	bl	8021bd8 <make_sys_node>
 8021792:	6138      	str	r0, [r7, #16]
				break;
 8021794:	e003      	b.n	802179e <proc_multiplicative_expr+0x76>

			default:
				finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 8021796:	2005      	movs	r0, #5
 8021798:	f7fe f936 	bl	801fa08 <finsh_error_set>
				break;
 802179c:	bf00      	nop
			}
		}
		next_token(token, &(self->token));
 802179e:	687b      	ldr	r3, [r7, #4]
 80217a0:	3304      	adds	r3, #4
 80217a2:	4618      	mov	r0, r3
 80217a4:	f000 fc54 	bl	8022050 <finsh_token_token>
 80217a8:	4603      	mov	r3, r0
 80217aa:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* cast;
	struct finsh_node* cast_new;

	cast = proc_cast_expr(self);
	next_token(token, &(self->token));
	while (token == finsh_token_type_mul ||
 80217ac:	7dfb      	ldrb	r3, [r7, #23]
 80217ae:	2b05      	cmp	r3, #5
 80217b0:	d0ca      	beq.n	8021748 <proc_multiplicative_expr+0x20>
 80217b2:	7dfb      	ldrb	r3, [r7, #23]
 80217b4:	2b0a      	cmp	r3, #10
 80217b6:	d0c7      	beq.n	8021748 <proc_multiplicative_expr+0x20>
		token == finsh_token_type_div ||
 80217b8:	7dfb      	ldrb	r3, [r7, #23]
 80217ba:	2b0b      	cmp	r3, #11
 80217bc:	d0c4      	beq.n	8021748 <proc_multiplicative_expr+0x20>
			}
		}
		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 80217be:	687b      	ldr	r3, [r7, #4]
 80217c0:	2201      	movs	r2, #1
 80217c2:	715a      	strb	r2, [r3, #5]
	return cast;
 80217c4:	693b      	ldr	r3, [r7, #16]
}
 80217c6:	4618      	mov	r0, r3
 80217c8:	3718      	adds	r7, #24
 80217ca:	46bd      	mov	sp, r7
 80217cc:	bd80      	pop	{r7, pc}
 80217ce:	bf00      	nop

080217d0 <proc_cast_expr>:
20060313, add recast parse
expr_cast -> expr_unary
	| '(' type ')' expr_cast
*/
static struct finsh_node* proc_cast_expr(struct finsh_parser* self)
{
 80217d0:	b580      	push	{r7, lr}
 80217d2:	b084      	sub	sp, #16
 80217d4:	af00      	add	r7, sp, #0
 80217d6:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	enum finsh_type type;
	struct finsh_node* cast;

	next_token(token, &(self->token));
 80217d8:	687b      	ldr	r3, [r7, #4]
 80217da:	3304      	adds	r3, #4
 80217dc:	4618      	mov	r0, r3
 80217de:	f000 fc37 	bl	8022050 <finsh_token_token>
 80217e2:	4603      	mov	r3, r0
 80217e4:	73fb      	strb	r3, [r7, #15]
	if (token == finsh_token_type_left_paren)
 80217e6:	7bfb      	ldrb	r3, [r7, #15]
 80217e8:	2b01      	cmp	r3, #1
 80217ea:	d120      	bne.n	802182e <proc_cast_expr+0x5e>
	{
		type = proc_type(self);
 80217ec:	6878      	ldr	r0, [r7, #4]
 80217ee:	f7ff fd21 	bl	8021234 <proc_type>
 80217f2:	4603      	mov	r3, r0
 80217f4:	73bb      	strb	r3, [r7, #14]
		match_token(token, &(self->token), finsh_token_type_right_paren);
 80217f6:	687b      	ldr	r3, [r7, #4]
 80217f8:	3304      	adds	r3, #4
 80217fa:	4618      	mov	r0, r3
 80217fc:	f000 fc28 	bl	8022050 <finsh_token_token>
 8021800:	4603      	mov	r3, r0
 8021802:	73fb      	strb	r3, [r7, #15]
 8021804:	7bfb      	ldrb	r3, [r7, #15]
 8021806:	2b02      	cmp	r3, #2
 8021808:	d005      	beq.n	8021816 <proc_cast_expr+0x46>
 802180a:	2001      	movs	r0, #1
 802180c:	f7fe f8fc 	bl	801fa08 <finsh_error_set>
 8021810:	687b      	ldr	r3, [r7, #4]
 8021812:	2201      	movs	r2, #1
 8021814:	715a      	strb	r2, [r3, #5]

		cast = proc_cast_expr(self);
 8021816:	6878      	ldr	r0, [r7, #4]
 8021818:	f7ff ffda 	bl	80217d0 <proc_cast_expr>
 802181c:	60b8      	str	r0, [r7, #8]
		if (cast != NULL)
 802181e:	68bb      	ldr	r3, [r7, #8]
 8021820:	2b00      	cmp	r3, #0
 8021822:	d004      	beq.n	802182e <proc_cast_expr+0x5e>
		{
			cast->data_type = type;
 8021824:	68bb      	ldr	r3, [r7, #8]
 8021826:	7bba      	ldrb	r2, [r7, #14]
 8021828:	705a      	strb	r2, [r3, #1]
			return cast;
 802182a:	68bb      	ldr	r3, [r7, #8]
 802182c:	e006      	b.n	802183c <proc_cast_expr+0x6c>
		}
	}

	finsh_token_replay(&(self->token));
 802182e:	687b      	ldr	r3, [r7, #4]
 8021830:	2201      	movs	r2, #1
 8021832:	715a      	strb	r2, [r3, #5]
	return proc_unary_expr(self);
 8021834:	6878      	ldr	r0, [r7, #4]
 8021836:	f000 f805 	bl	8021844 <proc_unary_expr>
 802183a:	4603      	mov	r3, r0
}
 802183c:	4618      	mov	r0, r3
 802183e:	3710      	adds	r7, #16
 8021840:	46bd      	mov	sp, r7
 8021842:	bd80      	pop	{r7, pc}

08021844 <proc_unary_expr>:
	| '~' expr_cast
	| '*' expr_cast
	| '&' expr_cast
*/
static struct finsh_node* proc_unary_expr(struct finsh_parser* self)
{
 8021844:	b580      	push	{r7, lr}
 8021846:	b084      	sub	sp, #16
 8021848:	af00      	add	r7, sp, #0
 802184a:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node *cast;

	next_token(token, &(self->token));
 802184c:	687b      	ldr	r3, [r7, #4]
 802184e:	3304      	adds	r3, #4
 8021850:	4618      	mov	r0, r3
 8021852:	f000 fbfd 	bl	8022050 <finsh_token_token>
 8021856:	4603      	mov	r3, r0
 8021858:	73fb      	strb	r3, [r7, #15]
	switch (token)
 802185a:	7bfb      	ldrb	r3, [r7, #15]
 802185c:	3b05      	subs	r3, #5
 802185e:	2b0b      	cmp	r3, #11
 8021860:	d866      	bhi.n	8021930 <proc_unary_expr+0xec>
 8021862:	a201      	add	r2, pc, #4	; (adr r2, 8021868 <proc_unary_expr+0x24>)
 8021864:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8021868:	08021905 	.word	0x08021905
 802186c:	08021899 	.word	0x08021899
 8021870:	080218a5 	.word	0x080218a5
 8021874:	080218bb 	.word	0x080218bb
 8021878:	080218d9 	.word	0x080218d9
 802187c:	08021931 	.word	0x08021931
 8021880:	08021931 	.word	0x08021931
 8021884:	08021931 	.word	0x08021931
 8021888:	0802191b 	.word	0x0802191b
 802188c:	08021931 	.word	0x08021931
 8021890:	08021931 	.word	0x08021931
 8021894:	080218ef 	.word	0x080218ef
	{
	case finsh_token_type_add: /* + */
		cast = proc_cast_expr(self);
 8021898:	6878      	ldr	r0, [r7, #4]
 802189a:	f7ff ff99 	bl	80217d0 <proc_cast_expr>
 802189e:	60b8      	str	r0, [r7, #8]
		return cast;
 80218a0:	68bb      	ldr	r3, [r7, #8]
 80218a2:	e04c      	b.n	802193e <proc_unary_expr+0xfa>

	case finsh_token_type_inc: /* ++ */
		cast = proc_cast_expr(self);
 80218a4:	6878      	ldr	r0, [r7, #4]
 80218a6:	f7ff ff93 	bl	80217d0 <proc_cast_expr>
 80218aa:	60b8      	str	r0, [r7, #8]
		return make_sys_node(FINSH_NODE_SYS_PREINC, cast, NULL);
 80218ac:	2015      	movs	r0, #21
 80218ae:	68b9      	ldr	r1, [r7, #8]
 80218b0:	2200      	movs	r2, #0
 80218b2:	f000 f991 	bl	8021bd8 <make_sys_node>
 80218b6:	4603      	mov	r3, r0
 80218b8:	e041      	b.n	802193e <proc_unary_expr+0xfa>

	case finsh_token_type_sub: /* - */
		cast = proc_cast_expr(self);
 80218ba:	6878      	ldr	r0, [r7, #4]
 80218bc:	f7ff ff88 	bl	80217d0 <proc_cast_expr>
 80218c0:	60b8      	str	r0, [r7, #8]
		return make_sys_node(FINSH_NODE_SYS_SUB, finsh_node_new_long(0), cast);
 80218c2:	2000      	movs	r0, #0
 80218c4:	f7fe fb9c 	bl	8020000 <finsh_node_new_long>
 80218c8:	4603      	mov	r3, r0
 80218ca:	2008      	movs	r0, #8
 80218cc:	4619      	mov	r1, r3
 80218ce:	68ba      	ldr	r2, [r7, #8]
 80218d0:	f000 f982 	bl	8021bd8 <make_sys_node>
 80218d4:	4603      	mov	r3, r0
 80218d6:	e032      	b.n	802193e <proc_unary_expr+0xfa>

	case finsh_token_type_dec: /* -- */
		cast = proc_cast_expr(self);
 80218d8:	6878      	ldr	r0, [r7, #4]
 80218da:	f7ff ff79 	bl	80217d0 <proc_cast_expr>
 80218de:	60b8      	str	r0, [r7, #8]
		return make_sys_node(FINSH_NODE_SYS_PREDEC, cast, NULL);
 80218e0:	2016      	movs	r0, #22
 80218e2:	68b9      	ldr	r1, [r7, #8]
 80218e4:	2200      	movs	r2, #0
 80218e6:	f000 f977 	bl	8021bd8 <make_sys_node>
 80218ea:	4603      	mov	r3, r0
 80218ec:	e027      	b.n	802193e <proc_unary_expr+0xfa>

	case finsh_token_type_bitwise: /* ~ */
		cast = proc_cast_expr(self);
 80218ee:	6878      	ldr	r0, [r7, #4]
 80218f0:	f7ff ff6e 	bl	80217d0 <proc_cast_expr>
 80218f4:	60b8      	str	r0, [r7, #8]
		return make_sys_node(FINSH_NODE_SYS_BITWISE, cast, NULL);
 80218f6:	200f      	movs	r0, #15
 80218f8:	68b9      	ldr	r1, [r7, #8]
 80218fa:	2200      	movs	r2, #0
 80218fc:	f000 f96c 	bl	8021bd8 <make_sys_node>
 8021900:	4603      	mov	r3, r0
 8021902:	e01c      	b.n	802193e <proc_unary_expr+0xfa>

    case finsh_token_type_mul: /* * */
        cast = proc_cast_expr(self);
 8021904:	6878      	ldr	r0, [r7, #4]
 8021906:	f7ff ff63 	bl	80217d0 <proc_cast_expr>
 802190a:	60b8      	str	r0, [r7, #8]
        return make_sys_node(FINSH_NODE_SYS_GETVALUE, cast, NULL);
 802190c:	2019      	movs	r0, #25
 802190e:	68b9      	ldr	r1, [r7, #8]
 8021910:	2200      	movs	r2, #0
 8021912:	f000 f961 	bl	8021bd8 <make_sys_node>
 8021916:	4603      	mov	r3, r0
 8021918:	e011      	b.n	802193e <proc_unary_expr+0xfa>

    case finsh_token_type_and: /* & */
        cast = proc_cast_expr(self);
 802191a:	6878      	ldr	r0, [r7, #4]
 802191c:	f7ff ff58 	bl	80217d0 <proc_cast_expr>
 8021920:	60b8      	str	r0, [r7, #8]
        return make_sys_node(FINSH_NODE_SYS_GETADDR, cast, NULL);
 8021922:	201a      	movs	r0, #26
 8021924:	68b9      	ldr	r1, [r7, #8]
 8021926:	2200      	movs	r2, #0
 8021928:	f000 f956 	bl	8021bd8 <make_sys_node>
 802192c:	4603      	mov	r3, r0
 802192e:	e006      	b.n	802193e <proc_unary_expr+0xfa>

	default:
		finsh_token_replay(&(self->token));
 8021930:	687b      	ldr	r3, [r7, #4]
 8021932:	2201      	movs	r2, #1
 8021934:	715a      	strb	r2, [r3, #5]
		return proc_postfix_expr(self);
 8021936:	6878      	ldr	r0, [r7, #4]
 8021938:	f000 f806 	bl	8021948 <proc_postfix_expr>
 802193c:	4603      	mov	r3, r0
	}
}
 802193e:	4618      	mov	r0, r3
 8021940:	3710      	adds	r7, #16
 8021942:	46bd      	mov	sp, r7
 8021944:	bd80      	pop	{r7, pc}
 8021946:	bf00      	nop

08021948 <proc_postfix_expr>:
	| expr_postfix INC
	| expr_postfix DEC
	| expr_postfix '(' param_list ')'
*/
static struct finsh_node* proc_postfix_expr(struct finsh_parser* self)
{
 8021948:	b580      	push	{r7, lr}
 802194a:	b086      	sub	sp, #24
 802194c:	af00      	add	r7, sp, #0
 802194e:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* postfix;

	postfix = proc_primary_expr(self);
 8021950:	6878      	ldr	r0, [r7, #4]
 8021952:	f000 f861 	bl	8021a18 <proc_primary_expr>
 8021956:	6138      	str	r0, [r7, #16]

	next_token(token, &(self->token));
 8021958:	687b      	ldr	r3, [r7, #4]
 802195a:	3304      	adds	r3, #4
 802195c:	4618      	mov	r0, r3
 802195e:	f000 fb77 	bl	8022050 <finsh_token_token>
 8021962:	4603      	mov	r3, r0
 8021964:	75fb      	strb	r3, [r7, #23]
	while ( token == finsh_token_type_inc 	||
 8021966:	e046      	b.n	80219f6 <proc_postfix_expr+0xae>
		token == finsh_token_type_dec 		||
		token == finsh_token_type_left_paren )
	{
		switch (token)
 8021968:	7dfb      	ldrb	r3, [r7, #23]
 802196a:	2b07      	cmp	r3, #7
 802196c:	d004      	beq.n	8021978 <proc_postfix_expr+0x30>
 802196e:	2b09      	cmp	r3, #9
 8021970:	d009      	beq.n	8021986 <proc_postfix_expr+0x3e>
 8021972:	2b01      	cmp	r3, #1
 8021974:	d00e      	beq.n	8021994 <proc_postfix_expr+0x4c>
				postfix = make_sys_node(FINSH_NODE_SYS_FUNC, postfix, param_list);
			}
			break;

		default:
			break;
 8021976:	e037      	b.n	80219e8 <proc_postfix_expr+0xa0>
		token == finsh_token_type_left_paren )
	{
		switch (token)
		{
		case finsh_token_type_inc :/* '++' */
			postfix = make_sys_node(FINSH_NODE_SYS_INC, postfix, NULL);
 8021978:	2017      	movs	r0, #23
 802197a:	6939      	ldr	r1, [r7, #16]
 802197c:	2200      	movs	r2, #0
 802197e:	f000 f92b 	bl	8021bd8 <make_sys_node>
 8021982:	6138      	str	r0, [r7, #16]
			break;
 8021984:	e030      	b.n	80219e8 <proc_postfix_expr+0xa0>

		case finsh_token_type_dec :/* '--' */
			postfix = make_sys_node(FINSH_NODE_SYS_DEC, postfix, NULL);
 8021986:	2018      	movs	r0, #24
 8021988:	6939      	ldr	r1, [r7, #16]
 802198a:	2200      	movs	r2, #0
 802198c:	f000 f924 	bl	8021bd8 <make_sys_node>
 8021990:	6138      	str	r0, [r7, #16]
			break;
 8021992:	e029      	b.n	80219e8 <proc_postfix_expr+0xa0>

		case finsh_token_type_left_paren :/* '(' */
			{
				struct finsh_node* param_list;

				param_list = NULL;
 8021994:	2300      	movs	r3, #0
 8021996:	60fb      	str	r3, [r7, #12]
				next_token(token, &(self->token));
 8021998:	687b      	ldr	r3, [r7, #4]
 802199a:	3304      	adds	r3, #4
 802199c:	4618      	mov	r0, r3
 802199e:	f000 fb57 	bl	8022050 <finsh_token_token>
 80219a2:	4603      	mov	r3, r0
 80219a4:	75fb      	strb	r3, [r7, #23]
				if (token != finsh_token_type_right_paren)
 80219a6:	7dfb      	ldrb	r3, [r7, #23]
 80219a8:	2b02      	cmp	r3, #2
 80219aa:	d016      	beq.n	80219da <proc_postfix_expr+0x92>
				{
					finsh_token_replay(&(self->token));
 80219ac:	687b      	ldr	r3, [r7, #4]
 80219ae:	2201      	movs	r2, #1
 80219b0:	715a      	strb	r2, [r3, #5]
					param_list = proc_param_list(self);
 80219b2:	6878      	ldr	r0, [r7, #4]
 80219b4:	f000 f8d6 	bl	8021b64 <proc_param_list>
 80219b8:	60f8      	str	r0, [r7, #12]

					match_token(token, &(self->token), finsh_token_type_right_paren);
 80219ba:	687b      	ldr	r3, [r7, #4]
 80219bc:	3304      	adds	r3, #4
 80219be:	4618      	mov	r0, r3
 80219c0:	f000 fb46 	bl	8022050 <finsh_token_token>
 80219c4:	4603      	mov	r3, r0
 80219c6:	75fb      	strb	r3, [r7, #23]
 80219c8:	7dfb      	ldrb	r3, [r7, #23]
 80219ca:	2b02      	cmp	r3, #2
 80219cc:	d005      	beq.n	80219da <proc_postfix_expr+0x92>
 80219ce:	2001      	movs	r0, #1
 80219d0:	f7fe f81a 	bl	801fa08 <finsh_error_set>
 80219d4:	687b      	ldr	r3, [r7, #4]
 80219d6:	2201      	movs	r2, #1
 80219d8:	715a      	strb	r2, [r3, #5]
				}

				postfix = make_sys_node(FINSH_NODE_SYS_FUNC, postfix, param_list);
 80219da:	2012      	movs	r0, #18
 80219dc:	6939      	ldr	r1, [r7, #16]
 80219de:	68fa      	ldr	r2, [r7, #12]
 80219e0:	f000 f8fa 	bl	8021bd8 <make_sys_node>
 80219e4:	6138      	str	r0, [r7, #16]
			}
			break;
 80219e6:	bf00      	nop

		default:
			break;
		}

		next_token(token, &(self->token));
 80219e8:	687b      	ldr	r3, [r7, #4]
 80219ea:	3304      	adds	r3, #4
 80219ec:	4618      	mov	r0, r3
 80219ee:	f000 fb2f 	bl	8022050 <finsh_token_token>
 80219f2:	4603      	mov	r3, r0
 80219f4:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* postfix;

	postfix = proc_primary_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_inc 	||
 80219f6:	7dfb      	ldrb	r3, [r7, #23]
 80219f8:	2b07      	cmp	r3, #7
 80219fa:	d0b5      	beq.n	8021968 <proc_postfix_expr+0x20>
 80219fc:	7dfb      	ldrb	r3, [r7, #23]
 80219fe:	2b09      	cmp	r3, #9
 8021a00:	d0b2      	beq.n	8021968 <proc_postfix_expr+0x20>
		token == finsh_token_type_dec 		||
 8021a02:	7dfb      	ldrb	r3, [r7, #23]
 8021a04:	2b01      	cmp	r3, #1
 8021a06:	d0af      	beq.n	8021968 <proc_postfix_expr+0x20>
		}

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 8021a08:	687b      	ldr	r3, [r7, #4]
 8021a0a:	2201      	movs	r2, #1
 8021a0c:	715a      	strb	r2, [r3, #5]
	return postfix;
 8021a0e:	693b      	ldr	r3, [r7, #16]
}
 8021a10:	4618      	mov	r0, r3
 8021a12:	3718      	adds	r7, #24
 8021a14:	46bd      	mov	sp, r7
 8021a16:	bd80      	pop	{r7, pc}

08021a18 <proc_primary_expr>:
expr_primary -> literal
	| '(' expr ')'
	| identifier
*/
static struct finsh_node* proc_primary_expr(struct finsh_parser* self)
{
 8021a18:	b580      	push	{r7, lr}
 8021a1a:	b08a      	sub	sp, #40	; 0x28
 8021a1c:	af00      	add	r7, sp, #0
 8021a1e:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* expr;

	next_token(token, &(self->token));
 8021a20:	687b      	ldr	r3, [r7, #4]
 8021a22:	3304      	adds	r3, #4
 8021a24:	4618      	mov	r0, r3
 8021a26:	f000 fb13 	bl	8022050 <finsh_token_token>
 8021a2a:	4603      	mov	r3, r0
 8021a2c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	switch ( token )
 8021a30:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8021a34:	3b01      	subs	r3, #1
 8021a36:	2b1e      	cmp	r3, #30
 8021a38:	f200 808b 	bhi.w	8021b52 <proc_primary_expr+0x13a>
 8021a3c:	a201      	add	r2, pc, #4	; (adr r2, 8021a44 <proc_primary_expr+0x2c>)
 8021a3e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8021a42:	bf00      	nop
 8021a44:	08021ae1 	.word	0x08021ae1
 8021a48:	08021b53 	.word	0x08021b53
 8021a4c:	08021b53 	.word	0x08021b53
 8021a50:	08021b53 	.word	0x08021b53
 8021a54:	08021b53 	.word	0x08021b53
 8021a58:	08021b53 	.word	0x08021b53
 8021a5c:	08021b53 	.word	0x08021b53
 8021a60:	08021b53 	.word	0x08021b53
 8021a64:	08021b53 	.word	0x08021b53
 8021a68:	08021b53 	.word	0x08021b53
 8021a6c:	08021b53 	.word	0x08021b53
 8021a70:	08021b53 	.word	0x08021b53
 8021a74:	08021b53 	.word	0x08021b53
 8021a78:	08021b53 	.word	0x08021b53
 8021a7c:	08021b53 	.word	0x08021b53
 8021a80:	08021b53 	.word	0x08021b53
 8021a84:	08021b53 	.word	0x08021b53
 8021a88:	08021b53 	.word	0x08021b53
 8021a8c:	08021b53 	.word	0x08021b53
 8021a90:	08021b53 	.word	0x08021b53
 8021a94:	08021b53 	.word	0x08021b53
 8021a98:	08021b53 	.word	0x08021b53
 8021a9c:	08021b53 	.word	0x08021b53
 8021aa0:	08021b53 	.word	0x08021b53
 8021aa4:	08021b53 	.word	0x08021b53
 8021aa8:	08021b2d 	.word	0x08021b2d
 8021aac:	08021b11 	.word	0x08021b11
 8021ab0:	08021b1f 	.word	0x08021b1f
 8021ab4:	08021b3b 	.word	0x08021b3b
 8021ab8:	08021b49 	.word	0x08021b49
 8021abc:	08021ac1 	.word	0x08021ac1
	{
	case finsh_token_type_identifier:
		{
			char id[FINSH_NAME_MAX + 1];

			finsh_token_replay(&(self->token));
 8021ac0:	687b      	ldr	r3, [r7, #4]
 8021ac2:	2201      	movs	r2, #1
 8021ac4:	715a      	strb	r2, [r3, #5]
			proc_identifier(self, id);
 8021ac6:	f107 030c 	add.w	r3, r7, #12
 8021aca:	6878      	ldr	r0, [r7, #4]
 8021acc:	4619      	mov	r1, r3
 8021ace:	f7ff fc7f 	bl	80213d0 <proc_identifier>
			return finsh_node_new_id(id);
 8021ad2:	f107 030c 	add.w	r3, r7, #12
 8021ad6:	4618      	mov	r0, r3
 8021ad8:	f7fe fa0a 	bl	801fef0 <finsh_node_new_id>
 8021adc:	4603      	mov	r3, r0
 8021ade:	e03d      	b.n	8021b5c <proc_primary_expr+0x144>
		}

	case finsh_token_type_left_paren:
		expr = proc_expr(self);
 8021ae0:	6878      	ldr	r0, [r7, #4]
 8021ae2:	f7ff fcc3 	bl	802146c <proc_expr>
 8021ae6:	6238      	str	r0, [r7, #32]
		match_token(token, &(self->token), finsh_token_type_right_paren);
 8021ae8:	687b      	ldr	r3, [r7, #4]
 8021aea:	3304      	adds	r3, #4
 8021aec:	4618      	mov	r0, r3
 8021aee:	f000 faaf 	bl	8022050 <finsh_token_token>
 8021af2:	4603      	mov	r3, r0
 8021af4:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8021af8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8021afc:	2b02      	cmp	r3, #2
 8021afe:	d005      	beq.n	8021b0c <proc_primary_expr+0xf4>
 8021b00:	2001      	movs	r0, #1
 8021b02:	f7fd ff81 	bl	801fa08 <finsh_error_set>
 8021b06:	687b      	ldr	r3, [r7, #4]
 8021b08:	2201      	movs	r2, #1
 8021b0a:	715a      	strb	r2, [r3, #5]
		return expr;
 8021b0c:	6a3b      	ldr	r3, [r7, #32]
 8021b0e:	e025      	b.n	8021b5c <proc_primary_expr+0x144>

	case finsh_token_type_value_int:
		return finsh_node_new_int(self->token.value.int_value);
 8021b10:	687b      	ldr	r3, [r7, #4]
 8021b12:	691b      	ldr	r3, [r3, #16]
 8021b14:	4618      	mov	r0, r3
 8021b16:	f7fe fa5b 	bl	801ffd0 <finsh_node_new_int>
 8021b1a:	4603      	mov	r3, r0
 8021b1c:	e01e      	b.n	8021b5c <proc_primary_expr+0x144>

	case finsh_token_type_value_long:
		return finsh_node_new_long(self->token.value.long_value);
 8021b1e:	687b      	ldr	r3, [r7, #4]
 8021b20:	691b      	ldr	r3, [r3, #16]
 8021b22:	4618      	mov	r0, r3
 8021b24:	f7fe fa6c 	bl	8020000 <finsh_node_new_long>
 8021b28:	4603      	mov	r3, r0
 8021b2a:	e017      	b.n	8021b5c <proc_primary_expr+0x144>

	case finsh_token_type_value_char:
		return finsh_node_new_char(self->token.value.char_value);
 8021b2c:	687b      	ldr	r3, [r7, #4]
 8021b2e:	7c1b      	ldrb	r3, [r3, #16]
 8021b30:	4618      	mov	r0, r3
 8021b32:	f7fe fa33 	bl	801ff9c <finsh_node_new_char>
 8021b36:	4603      	mov	r3, r0
 8021b38:	e010      	b.n	8021b5c <proc_primary_expr+0x144>

	case finsh_token_type_value_string:
		return finsh_node_new_string((char*)self->token.string);
 8021b3a:	687b      	ldr	r3, [r7, #4]
 8021b3c:	3314      	adds	r3, #20
 8021b3e:	4618      	mov	r0, r3
 8021b40:	f7fe fa76 	bl	8020030 <finsh_node_new_string>
 8021b44:	4603      	mov	r3, r0
 8021b46:	e009      	b.n	8021b5c <proc_primary_expr+0x144>

	case finsh_token_type_value_null:
		return finsh_node_new_ptr(NULL);
 8021b48:	2000      	movs	r0, #0
 8021b4a:	f7fe faa5 	bl	8020098 <finsh_node_new_ptr>
 8021b4e:	4603      	mov	r3, r0
 8021b50:	e004      	b.n	8021b5c <proc_primary_expr+0x144>

	default:
		finsh_error_set(FINSH_ERROR_INVALID_TOKEN);
 8021b52:	2001      	movs	r0, #1
 8021b54:	f7fd ff58 	bl	801fa08 <finsh_error_set>
		break;
 8021b58:	bf00      	nop
	}

	return NULL;
 8021b5a:	2300      	movs	r3, #0
}
 8021b5c:	4618      	mov	r0, r3
 8021b5e:	3728      	adds	r7, #40	; 0x28
 8021b60:	46bd      	mov	sp, r7
 8021b62:	bd80      	pop	{r7, pc}

08021b64 <proc_param_list>:
param_list -> empty
	| expr_assign
	| param_list ',' expr_assign
*/
static struct finsh_node* proc_param_list(struct finsh_parser* self)
{
 8021b64:	b580      	push	{r7, lr}
 8021b66:	b086      	sub	sp, #24
 8021b68:	af00      	add	r7, sp, #0
 8021b6a:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node *node, *assign;

	assign = proc_assign_expr(self);
 8021b6c:	6878      	ldr	r0, [r7, #4]
 8021b6e:	f7ff fc89 	bl	8021484 <proc_assign_expr>
 8021b72:	6138      	str	r0, [r7, #16]
	if (assign == NULL) return NULL;
 8021b74:	693b      	ldr	r3, [r7, #16]
 8021b76:	2b00      	cmp	r3, #0
 8021b78:	d101      	bne.n	8021b7e <proc_param_list+0x1a>
 8021b7a:	2300      	movs	r3, #0
 8021b7c:	e028      	b.n	8021bd0 <proc_param_list+0x6c>
	node = assign;
 8021b7e:	693b      	ldr	r3, [r7, #16]
 8021b80:	60fb      	str	r3, [r7, #12]

	next_token(token, &(self->token));
 8021b82:	687b      	ldr	r3, [r7, #4]
 8021b84:	3304      	adds	r3, #4
 8021b86:	4618      	mov	r0, r3
 8021b88:	f000 fa62 	bl	8022050 <finsh_token_token>
 8021b8c:	4603      	mov	r3, r0
 8021b8e:	75fb      	strb	r3, [r7, #23]
	while (token == finsh_token_type_comma )
 8021b90:	e017      	b.n	8021bc2 <proc_param_list+0x5e>
	{
		finsh_node_sibling(assign) = proc_assign_expr(self);
 8021b92:	6878      	ldr	r0, [r7, #4]
 8021b94:	f7ff fc76 	bl	8021484 <proc_assign_expr>
 8021b98:	4602      	mov	r2, r0
 8021b9a:	693b      	ldr	r3, [r7, #16]
 8021b9c:	60da      	str	r2, [r3, #12]

		if (finsh_node_sibling(assign) != NULL)	assign = finsh_node_sibling(assign);
 8021b9e:	693b      	ldr	r3, [r7, #16]
 8021ba0:	68db      	ldr	r3, [r3, #12]
 8021ba2:	2b00      	cmp	r3, #0
 8021ba4:	d003      	beq.n	8021bae <proc_param_list+0x4a>
 8021ba6:	693b      	ldr	r3, [r7, #16]
 8021ba8:	68db      	ldr	r3, [r3, #12]
 8021baa:	613b      	str	r3, [r7, #16]
 8021bac:	e002      	b.n	8021bb4 <proc_param_list+0x50>
		else finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 8021bae:	2005      	movs	r0, #5
 8021bb0:	f7fd ff2a 	bl	801fa08 <finsh_error_set>

		next_token(token, &(self->token));
 8021bb4:	687b      	ldr	r3, [r7, #4]
 8021bb6:	3304      	adds	r3, #4
 8021bb8:	4618      	mov	r0, r3
 8021bba:	f000 fa49 	bl	8022050 <finsh_token_token>
 8021bbe:	4603      	mov	r3, r0
 8021bc0:	75fb      	strb	r3, [r7, #23]
	assign = proc_assign_expr(self);
	if (assign == NULL) return NULL;
	node = assign;

	next_token(token, &(self->token));
	while (token == finsh_token_type_comma )
 8021bc2:	7dfb      	ldrb	r3, [r7, #23]
 8021bc4:	2b03      	cmp	r3, #3
 8021bc6:	d0e4      	beq.n	8021b92 <proc_param_list+0x2e>
		else finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 8021bc8:	687b      	ldr	r3, [r7, #4]
 8021bca:	2201      	movs	r2, #1
 8021bcc:	715a      	strb	r2, [r3, #5]

	return node;
 8021bce:	68fb      	ldr	r3, [r7, #12]
}
 8021bd0:	4618      	mov	r0, r3
 8021bd2:	3718      	adds	r7, #24
 8021bd4:	46bd      	mov	sp, r7
 8021bd6:	bd80      	pop	{r7, pc}

08021bd8 <make_sys_node>:
node1__
       \
       node2
*/
static struct finsh_node* make_sys_node(u_char type, struct finsh_node* node1, struct finsh_node* node2)
{
 8021bd8:	b580      	push	{r7, lr}
 8021bda:	b086      	sub	sp, #24
 8021bdc:	af00      	add	r7, sp, #0
 8021bde:	4603      	mov	r3, r0
 8021be0:	60b9      	str	r1, [r7, #8]
 8021be2:	607a      	str	r2, [r7, #4]
 8021be4:	73fb      	strb	r3, [r7, #15]
	struct finsh_node* node;

	node = finsh_node_allocate(type);
 8021be6:	7bfb      	ldrb	r3, [r7, #15]
 8021be8:	4618      	mov	r0, r3
 8021bea:	f7fe f94b 	bl	801fe84 <finsh_node_allocate>
 8021bee:	6178      	str	r0, [r7, #20]

	if ((node1 != NULL) && (node != NULL))
 8021bf0:	68bb      	ldr	r3, [r7, #8]
 8021bf2:	2b00      	cmp	r3, #0
 8021bf4:	d009      	beq.n	8021c0a <make_sys_node+0x32>
 8021bf6:	697b      	ldr	r3, [r7, #20]
 8021bf8:	2b00      	cmp	r3, #0
 8021bfa:	d006      	beq.n	8021c0a <make_sys_node+0x32>
	{
		finsh_node_child(node) = node1;
 8021bfc:	697b      	ldr	r3, [r7, #20]
 8021bfe:	68ba      	ldr	r2, [r7, #8]
 8021c00:	611a      	str	r2, [r3, #16]
		finsh_node_sibling(node1) = node2;
 8021c02:	68bb      	ldr	r3, [r7, #8]
 8021c04:	687a      	ldr	r2, [r7, #4]
 8021c06:	60da      	str	r2, [r3, #12]
 8021c08:	e002      	b.n	8021c10 <make_sys_node+0x38>
	}
	else finsh_error_set(FINSH_ERROR_NULL_NODE);
 8021c0a:	200e      	movs	r0, #14
 8021c0c:	f7fd fefc 	bl	801fa08 <finsh_error_set>

	return node;
 8021c10:	697b      	ldr	r3, [r7, #20]
}
 8021c12:	4618      	mov	r0, r3
 8021c14:	3718      	adds	r7, #24
 8021c16:	46bd      	mov	sp, r7
 8021c18:	bd80      	pop	{r7, pc}
 8021c1a:	bf00      	nop

08021c1c <finsh_parser_run>:

/*
start -> statement_expr | decl_variable
*/
void finsh_parser_run(struct finsh_parser* self, const u_char* string)
{
 8021c1c:	b580      	push	{r7, lr}
 8021c1e:	b084      	sub	sp, #16
 8021c20:	af00      	add	r7, sp, #0
 8021c22:	6078      	str	r0, [r7, #4]
 8021c24:	6039      	str	r1, [r7, #0]
	enum finsh_token_type token;
	struct finsh_node *node;

    node = NULL;
 8021c26:	2300      	movs	r3, #0
 8021c28:	60bb      	str	r3, [r7, #8]

	/* init parser */
	self->parser_string = (u_char*)string;
 8021c2a:	687b      	ldr	r3, [r7, #4]
 8021c2c:	683a      	ldr	r2, [r7, #0]
 8021c2e:	601a      	str	r2, [r3, #0]

	/* init token */
	finsh_token_init(&(self->token), self->parser_string);
 8021c30:	687b      	ldr	r3, [r7, #4]
 8021c32:	1d1a      	adds	r2, r3, #4
 8021c34:	687b      	ldr	r3, [r7, #4]
 8021c36:	681b      	ldr	r3, [r3, #0]
 8021c38:	4610      	mov	r0, r2
 8021c3a:	4619      	mov	r1, r3
 8021c3c:	f000 f9f6 	bl	802202c <finsh_token_init>

	/* get next token */
	next_token(token, &(self->token));
 8021c40:	687b      	ldr	r3, [r7, #4]
 8021c42:	3304      	adds	r3, #4
 8021c44:	4618      	mov	r0, r3
 8021c46:	f000 fa03 	bl	8022050 <finsh_token_token>
 8021c4a:	4603      	mov	r3, r0
 8021c4c:	73fb      	strb	r3, [r7, #15]
	while (token != finsh_token_type_eof && token != finsh_token_type_bad)
 8021c4e:	e089      	b.n	8021d64 <finsh_parser_run+0x148>
	{
		switch (token)
 8021c50:	7bfb      	ldrb	r3, [r7, #15]
 8021c52:	2b1f      	cmp	r3, #31
 8021c54:	d11f      	bne.n	8021c96 <finsh_parser_run+0x7a>
		{
        case finsh_token_type_identifier:
            /* process expr_statement */
            finsh_token_replay(&(self->token));
 8021c56:	687b      	ldr	r3, [r7, #4]
 8021c58:	2201      	movs	r2, #1
 8021c5a:	715a      	strb	r2, [r3, #5]

			if (self->root != NULL)
 8021c5c:	687b      	ldr	r3, [r7, #4]
 8021c5e:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8021c62:	2b00      	cmp	r3, #0
 8021c64:	d00d      	beq.n	8021c82 <finsh_parser_run+0x66>
			{
				finsh_node_sibling(node) = proc_expr_statement(self);
 8021c66:	6878      	ldr	r0, [r7, #4]
 8021c68:	f7ff fbd4 	bl	8021414 <proc_expr_statement>
 8021c6c:	4602      	mov	r2, r0
 8021c6e:	68bb      	ldr	r3, [r7, #8]
 8021c70:	60da      	str	r2, [r3, #12]
				if (finsh_node_sibling(node) != NULL)
 8021c72:	68bb      	ldr	r3, [r7, #8]
 8021c74:	68db      	ldr	r3, [r3, #12]
 8021c76:	2b00      	cmp	r3, #0
 8021c78:	d00c      	beq.n	8021c94 <finsh_parser_run+0x78>
					node = finsh_node_sibling(node);
 8021c7a:	68bb      	ldr	r3, [r7, #8]
 8021c7c:	68db      	ldr	r3, [r3, #12]
 8021c7e:	60bb      	str	r3, [r7, #8]
			else
			{
            	node = proc_expr_statement(self);
				self->root = node;
			}
            break;
 8021c80:	e063      	b.n	8021d4a <finsh_parser_run+0x12e>
				if (finsh_node_sibling(node) != NULL)
					node = finsh_node_sibling(node);
			}
			else
			{
            	node = proc_expr_statement(self);
 8021c82:	6878      	ldr	r0, [r7, #4]
 8021c84:	f7ff fbc6 	bl	8021414 <proc_expr_statement>
 8021c88:	60b8      	str	r0, [r7, #8]
				self->root = node;
 8021c8a:	687b      	ldr	r3, [r7, #4]
 8021c8c:	68ba      	ldr	r2, [r7, #8]
 8021c8e:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
			}
            break;
 8021c92:	e05a      	b.n	8021d4a <finsh_parser_run+0x12e>
 8021c94:	e059      	b.n	8021d4a <finsh_parser_run+0x12e>

		default:
            if (is_base_type(token) || token == finsh_token_type_unsigned)
 8021c96:	7bfb      	ldrb	r3, [r7, #15]
 8021c98:	2b14      	cmp	r3, #20
 8021c9a:	d00e      	beq.n	8021cba <finsh_parser_run+0x9e>
 8021c9c:	7bfb      	ldrb	r3, [r7, #15]
 8021c9e:	2b15      	cmp	r3, #21
 8021ca0:	d00b      	beq.n	8021cba <finsh_parser_run+0x9e>
 8021ca2:	7bfb      	ldrb	r3, [r7, #15]
 8021ca4:	2b16      	cmp	r3, #22
 8021ca6:	d008      	beq.n	8021cba <finsh_parser_run+0x9e>
 8021ca8:	7bfb      	ldrb	r3, [r7, #15]
 8021caa:	2b17      	cmp	r3, #23
 8021cac:	d005      	beq.n	8021cba <finsh_parser_run+0x9e>
 8021cae:	7bfb      	ldrb	r3, [r7, #15]
 8021cb0:	2b18      	cmp	r3, #24
 8021cb2:	d002      	beq.n	8021cba <finsh_parser_run+0x9e>
 8021cb4:	7bfb      	ldrb	r3, [r7, #15]
 8021cb6:	2b19      	cmp	r3, #25
 8021cb8:	d11f      	bne.n	8021cfa <finsh_parser_run+0xde>
            {
            	/* variable decl */
            	finsh_token_replay(&(self->token));
 8021cba:	687b      	ldr	r3, [r7, #4]
 8021cbc:	2201      	movs	r2, #1
 8021cbe:	715a      	strb	r2, [r3, #5]

				if (self->root != NULL)
 8021cc0:	687b      	ldr	r3, [r7, #4]
 8021cc2:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8021cc6:	2b00      	cmp	r3, #0
 8021cc8:	d00d      	beq.n	8021ce6 <finsh_parser_run+0xca>
				{
					finsh_node_sibling(node) = proc_variable_decl(self);
 8021cca:	6878      	ldr	r0, [r7, #4]
 8021ccc:	f7ff f952 	bl	8020f74 <proc_variable_decl>
 8021cd0:	4602      	mov	r2, r0
 8021cd2:	68bb      	ldr	r3, [r7, #8]
 8021cd4:	60da      	str	r2, [r3, #12]
					if (finsh_node_sibling(node) != NULL)
 8021cd6:	68bb      	ldr	r3, [r7, #8]
 8021cd8:	68db      	ldr	r3, [r3, #12]
 8021cda:	2b00      	cmp	r3, #0
 8021cdc:	d00c      	beq.n	8021cf8 <finsh_parser_run+0xdc>
						node = finsh_node_sibling(node);
 8021cde:	68bb      	ldr	r3, [r7, #8]
 8021ce0:	68db      	ldr	r3, [r3, #12]
 8021ce2:	60bb      	str	r3, [r7, #8]
            if (is_base_type(token) || token == finsh_token_type_unsigned)
            {
            	/* variable decl */
            	finsh_token_replay(&(self->token));

				if (self->root != NULL)
 8021ce4:	e030      	b.n	8021d48 <finsh_parser_run+0x12c>
					if (finsh_node_sibling(node) != NULL)
						node = finsh_node_sibling(node);
				}
				else
				{
					node = proc_variable_decl(self);
 8021ce6:	6878      	ldr	r0, [r7, #4]
 8021ce8:	f7ff f944 	bl	8020f74 <proc_variable_decl>
 8021cec:	60b8      	str	r0, [r7, #8]
					self->root = node;
 8021cee:	687b      	ldr	r3, [r7, #4]
 8021cf0:	68ba      	ldr	r2, [r7, #8]
 8021cf2:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
            if (is_base_type(token) || token == finsh_token_type_unsigned)
            {
            	/* variable decl */
            	finsh_token_replay(&(self->token));

				if (self->root != NULL)
 8021cf6:	e027      	b.n	8021d48 <finsh_parser_run+0x12c>
 8021cf8:	e026      	b.n	8021d48 <finsh_parser_run+0x12c>
				}
            }
            else
            {
            	/* process expr_statement */
                finsh_token_replay(&(self->token));
 8021cfa:	687b      	ldr	r3, [r7, #4]
 8021cfc:	2201      	movs	r2, #1
 8021cfe:	715a      	strb	r2, [r3, #5]

				if (self->root != NULL)
 8021d00:	687b      	ldr	r3, [r7, #4]
 8021d02:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8021d06:	2b00      	cmp	r3, #0
 8021d08:	d015      	beq.n	8021d36 <finsh_parser_run+0x11a>
				{
                    finsh_node_sibling(node) = proc_expr_statement(self);
 8021d0a:	6878      	ldr	r0, [r7, #4]
 8021d0c:	f7ff fb82 	bl	8021414 <proc_expr_statement>
 8021d10:	4602      	mov	r2, r0
 8021d12:	68bb      	ldr	r3, [r7, #8]
 8021d14:	60da      	str	r2, [r3, #12]
					if (finsh_node_sibling(node) != NULL)
 8021d16:	68bb      	ldr	r3, [r7, #8]
 8021d18:	68db      	ldr	r3, [r3, #12]
 8021d1a:	2b00      	cmp	r3, #0
 8021d1c:	d003      	beq.n	8021d26 <finsh_parser_run+0x10a>
						node = finsh_node_sibling(node);
 8021d1e:	68bb      	ldr	r3, [r7, #8]
 8021d20:	68db      	ldr	r3, [r3, #12]
 8021d22:	60bb      	str	r3, [r7, #8]
 8021d24:	e010      	b.n	8021d48 <finsh_parser_run+0x12c>
					else next_token(token, &(self->token));
 8021d26:	687b      	ldr	r3, [r7, #4]
 8021d28:	3304      	adds	r3, #4
 8021d2a:	4618      	mov	r0, r3
 8021d2c:	f000 f990 	bl	8022050 <finsh_token_token>
 8021d30:	4603      	mov	r3, r0
 8021d32:	73fb      	strb	r3, [r7, #15]
					node = proc_expr_statement(self);
					self->root = node;
				}
            }

			break;
 8021d34:	e008      	b.n	8021d48 <finsh_parser_run+0x12c>
						node = finsh_node_sibling(node);
					else next_token(token, &(self->token));
				}
				else
				{
					node = proc_expr_statement(self);
 8021d36:	6878      	ldr	r0, [r7, #4]
 8021d38:	f7ff fb6c 	bl	8021414 <proc_expr_statement>
 8021d3c:	60b8      	str	r0, [r7, #8]
					self->root = node;
 8021d3e:	687b      	ldr	r3, [r7, #4]
 8021d40:	68ba      	ldr	r2, [r7, #8]
 8021d42:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
				}
            }

			break;
 8021d46:	e7ff      	b.n	8021d48 <finsh_parser_run+0x12c>
 8021d48:	bf00      	nop
		}

		/* no root found, break out */
		if (self->root == NULL) break;
 8021d4a:	687b      	ldr	r3, [r7, #4]
 8021d4c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8021d50:	2b00      	cmp	r3, #0
 8021d52:	d100      	bne.n	8021d56 <finsh_parser_run+0x13a>
 8021d54:	e00d      	b.n	8021d72 <finsh_parser_run+0x156>

        /* get next token */
		next_token(token, &(self->token));
 8021d56:	687b      	ldr	r3, [r7, #4]
 8021d58:	3304      	adds	r3, #4
 8021d5a:	4618      	mov	r0, r3
 8021d5c:	f000 f978 	bl	8022050 <finsh_token_token>
 8021d60:	4603      	mov	r3, r0
 8021d62:	73fb      	strb	r3, [r7, #15]
	/* init token */
	finsh_token_init(&(self->token), self->parser_string);

	/* get next token */
	next_token(token, &(self->token));
	while (token != finsh_token_type_eof && token != finsh_token_type_bad)
 8021d64:	7bfb      	ldrb	r3, [r7, #15]
 8021d66:	2b21      	cmp	r3, #33	; 0x21
 8021d68:	d003      	beq.n	8021d72 <finsh_parser_run+0x156>
 8021d6a:	7bfb      	ldrb	r3, [r7, #15]
 8021d6c:	2b20      	cmp	r3, #32
 8021d6e:	f47f af6f 	bne.w	8021c50 <finsh_parser_run+0x34>
		if (self->root == NULL) break;

        /* get next token */
		next_token(token, &(self->token));
	}
}
 8021d72:	3710      	adds	r7, #16
 8021d74:	46bd      	mov	sp, r7
 8021d76:	bd80      	pop	{r7, pc}

08021d78 <finsh_parser_init>:

int finsh_parser_init(struct finsh_parser* self)
{
 8021d78:	b580      	push	{r7, lr}
 8021d7a:	b082      	sub	sp, #8
 8021d7c:	af00      	add	r7, sp, #0
 8021d7e:	6078      	str	r0, [r7, #4]
	memset(self, 0, sizeof(struct finsh_parser));
 8021d80:	6878      	ldr	r0, [r7, #4]
 8021d82:	2100      	movs	r1, #0
 8021d84:	229c      	movs	r2, #156	; 0x9c
 8021d86:	f000 fffb 	bl	8022d80 <memset>

	return 0;
 8021d8a:	2300      	movs	r3, #0
}
 8021d8c:	4618      	mov	r0, r3
 8021d8e:	3708      	adds	r7, #8
 8021d90:	46bd      	mov	sp, r7
 8021d92:	bd80      	pop	{r7, pc}

08021d94 <finsh_var_init>:

struct finsh_var global_variable[FINSH_VARIABLE_MAX];
struct finsh_sysvar_item* global_sysvar_list;

int finsh_var_init()
{
 8021d94:	b580      	push	{r7, lr}
 8021d96:	af00      	add	r7, sp, #0
	memset(global_variable, 0, sizeof(global_variable));
 8021d98:	4803      	ldr	r0, [pc, #12]	; (8021da8 <finsh_var_init+0x14>)
 8021d9a:	2100      	movs	r1, #0
 8021d9c:	22c0      	movs	r2, #192	; 0xc0
 8021d9e:	f000 ffef 	bl	8022d80 <memset>

	return 0;
 8021da2:	2300      	movs	r3, #0
}
 8021da4:	4618      	mov	r0, r3
 8021da6:	bd80      	pop	{r7, pc}
 8021da8:	20012d88 	.word	0x20012d88

08021dac <finsh_var_insert>:

int finsh_var_insert(const char* name, int type)
{
 8021dac:	b580      	push	{r7, lr}
 8021dae:	b084      	sub	sp, #16
 8021db0:	af00      	add	r7, sp, #0
 8021db2:	6078      	str	r0, [r7, #4]
 8021db4:	6039      	str	r1, [r7, #0]
	int i, empty;

	empty = -1;
 8021db6:	f04f 33ff 	mov.w	r3, #4294967295
 8021dba:	60bb      	str	r3, [r7, #8]
	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
 8021dbc:	2300      	movs	r3, #0
 8021dbe:	60fb      	str	r3, [r7, #12]
 8021dc0:	e025      	b.n	8021e0e <finsh_var_insert+0x62>
	{
		/* there is a same name variable exist. */
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
 8021dc2:	68fa      	ldr	r2, [r7, #12]
 8021dc4:	4613      	mov	r3, r2
 8021dc6:	005b      	lsls	r3, r3, #1
 8021dc8:	4413      	add	r3, r2
 8021dca:	00db      	lsls	r3, r3, #3
 8021dcc:	4a23      	ldr	r2, [pc, #140]	; (8021e5c <finsh_var_insert+0xb0>)
 8021dce:	4413      	add	r3, r2
 8021dd0:	4618      	mov	r0, r3
 8021dd2:	6879      	ldr	r1, [r7, #4]
 8021dd4:	2210      	movs	r2, #16
 8021dd6:	f001 fc93 	bl	8023700 <strncmp>
 8021dda:	4603      	mov	r3, r0
 8021ddc:	2b00      	cmp	r3, #0
 8021dde:	d102      	bne.n	8021de6 <finsh_var_insert+0x3a>
			return -1;
 8021de0:	f04f 33ff 	mov.w	r3, #4294967295
 8021de4:	e036      	b.n	8021e54 <finsh_var_insert+0xa8>

		if (global_variable[i].type == finsh_type_unknown && empty == -1)
 8021de6:	491d      	ldr	r1, [pc, #116]	; (8021e5c <finsh_var_insert+0xb0>)
 8021de8:	68fa      	ldr	r2, [r7, #12]
 8021dea:	4613      	mov	r3, r2
 8021dec:	005b      	lsls	r3, r3, #1
 8021dee:	4413      	add	r3, r2
 8021df0:	00db      	lsls	r3, r3, #3
 8021df2:	440b      	add	r3, r1
 8021df4:	3310      	adds	r3, #16
 8021df6:	785b      	ldrb	r3, [r3, #1]
 8021df8:	2b00      	cmp	r3, #0
 8021dfa:	d105      	bne.n	8021e08 <finsh_var_insert+0x5c>
 8021dfc:	68bb      	ldr	r3, [r7, #8]
 8021dfe:	f1b3 3fff 	cmp.w	r3, #4294967295
 8021e02:	d101      	bne.n	8021e08 <finsh_var_insert+0x5c>
		{
			empty = i;
 8021e04:	68fb      	ldr	r3, [r7, #12]
 8021e06:	60bb      	str	r3, [r7, #8]
int finsh_var_insert(const char* name, int type)
{
	int i, empty;

	empty = -1;
	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
 8021e08:	68fb      	ldr	r3, [r7, #12]
 8021e0a:	3301      	adds	r3, #1
 8021e0c:	60fb      	str	r3, [r7, #12]
 8021e0e:	68fb      	ldr	r3, [r7, #12]
 8021e10:	2b07      	cmp	r3, #7
 8021e12:	ddd6      	ble.n	8021dc2 <finsh_var_insert+0x16>
			empty = i;
		}
	}

	/* there is no empty entry */
	if (empty == -1) return -1;
 8021e14:	68bb      	ldr	r3, [r7, #8]
 8021e16:	f1b3 3fff 	cmp.w	r3, #4294967295
 8021e1a:	d102      	bne.n	8021e22 <finsh_var_insert+0x76>
 8021e1c:	f04f 33ff 	mov.w	r3, #4294967295
 8021e20:	e018      	b.n	8021e54 <finsh_var_insert+0xa8>

	/* insert entry */
	strncpy(global_variable[empty].name, name, FINSH_NAME_MAX);
 8021e22:	68ba      	ldr	r2, [r7, #8]
 8021e24:	4613      	mov	r3, r2
 8021e26:	005b      	lsls	r3, r3, #1
 8021e28:	4413      	add	r3, r2
 8021e2a:	00db      	lsls	r3, r3, #3
 8021e2c:	4a0b      	ldr	r2, [pc, #44]	; (8021e5c <finsh_var_insert+0xb0>)
 8021e2e:	4413      	add	r3, r2
 8021e30:	4618      	mov	r0, r3
 8021e32:	6879      	ldr	r1, [r7, #4]
 8021e34:	2210      	movs	r2, #16
 8021e36:	f001 fcaf 	bl	8023798 <strncpy>
	global_variable[empty].type = type;
 8021e3a:	683b      	ldr	r3, [r7, #0]
 8021e3c:	b2d8      	uxtb	r0, r3
 8021e3e:	4907      	ldr	r1, [pc, #28]	; (8021e5c <finsh_var_insert+0xb0>)
 8021e40:	68ba      	ldr	r2, [r7, #8]
 8021e42:	4613      	mov	r3, r2
 8021e44:	005b      	lsls	r3, r3, #1
 8021e46:	4413      	add	r3, r2
 8021e48:	00db      	lsls	r3, r3, #3
 8021e4a:	440b      	add	r3, r1
 8021e4c:	3310      	adds	r3, #16
 8021e4e:	4602      	mov	r2, r0
 8021e50:	705a      	strb	r2, [r3, #1]

	/* return the offset */
	return empty;
 8021e52:	68bb      	ldr	r3, [r7, #8]
}
 8021e54:	4618      	mov	r0, r3
 8021e56:	3710      	adds	r7, #16
 8021e58:	46bd      	mov	sp, r7
 8021e5a:	bd80      	pop	{r7, pc}
 8021e5c:	20012d88 	.word	0x20012d88

08021e60 <finsh_var_lookup>:

	return 0;
}

struct finsh_var* finsh_var_lookup(const char* name)
{
 8021e60:	b580      	push	{r7, lr}
 8021e62:	b084      	sub	sp, #16
 8021e64:	af00      	add	r7, sp, #0
 8021e66:	6078      	str	r0, [r7, #4]
	int i;

	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
 8021e68:	2300      	movs	r3, #0
 8021e6a:	60fb      	str	r3, [r7, #12]
 8021e6c:	e012      	b.n	8021e94 <finsh_var_lookup+0x34>
	{
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
 8021e6e:	68fa      	ldr	r2, [r7, #12]
 8021e70:	4613      	mov	r3, r2
 8021e72:	005b      	lsls	r3, r3, #1
 8021e74:	4413      	add	r3, r2
 8021e76:	00db      	lsls	r3, r3, #3
 8021e78:	4a10      	ldr	r2, [pc, #64]	; (8021ebc <finsh_var_lookup+0x5c>)
 8021e7a:	4413      	add	r3, r2
 8021e7c:	4618      	mov	r0, r3
 8021e7e:	6879      	ldr	r1, [r7, #4]
 8021e80:	2210      	movs	r2, #16
 8021e82:	f001 fc3d 	bl	8023700 <strncmp>
 8021e86:	4603      	mov	r3, r0
 8021e88:	2b00      	cmp	r3, #0
 8021e8a:	d100      	bne.n	8021e8e <finsh_var_lookup+0x2e>
			break;
 8021e8c:	e005      	b.n	8021e9a <finsh_var_lookup+0x3a>

struct finsh_var* finsh_var_lookup(const char* name)
{
	int i;

	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
 8021e8e:	68fb      	ldr	r3, [r7, #12]
 8021e90:	3301      	adds	r3, #1
 8021e92:	60fb      	str	r3, [r7, #12]
 8021e94:	68fb      	ldr	r3, [r7, #12]
 8021e96:	2b07      	cmp	r3, #7
 8021e98:	dde9      	ble.n	8021e6e <finsh_var_lookup+0xe>
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
			break;
	}

	/* can't find variable */
	if (i == FINSH_VARIABLE_MAX) return NULL;
 8021e9a:	68fb      	ldr	r3, [r7, #12]
 8021e9c:	2b08      	cmp	r3, #8
 8021e9e:	d101      	bne.n	8021ea4 <finsh_var_lookup+0x44>
 8021ea0:	2300      	movs	r3, #0
 8021ea2:	e006      	b.n	8021eb2 <finsh_var_lookup+0x52>

	return &global_variable[i];
 8021ea4:	68fa      	ldr	r2, [r7, #12]
 8021ea6:	4613      	mov	r3, r2
 8021ea8:	005b      	lsls	r3, r3, #1
 8021eaa:	4413      	add	r3, r2
 8021eac:	00db      	lsls	r3, r3, #3
 8021eae:	4a03      	ldr	r2, [pc, #12]	; (8021ebc <finsh_var_lookup+0x5c>)
 8021eb0:	4413      	add	r3, r2
}
 8021eb2:	4618      	mov	r0, r3
 8021eb4:	3710      	adds	r7, #16
 8021eb6:	46bd      	mov	sp, r7
 8021eb8:	bd80      	pop	{r7, pc}
 8021eba:	bf00      	nop
 8021ebc:	20012d88 	.word	0x20012d88

08021ec0 <finsh_sysvar_lookup>:
	}
}
#endif

struct finsh_sysvar* finsh_sysvar_lookup(const char* name)
{
 8021ec0:	b590      	push	{r4, r7, lr}
 8021ec2:	b085      	sub	sp, #20
 8021ec4:	af00      	add	r7, sp, #0
 8021ec6:	6078      	str	r0, [r7, #4]
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
 8021ec8:	4b1b      	ldr	r3, [pc, #108]	; (8021f38 <finsh_sysvar_lookup+0x78>)
 8021eca:	681b      	ldr	r3, [r3, #0]
 8021ecc:	60fb      	str	r3, [r7, #12]
 8021ece:	e00d      	b.n	8021eec <finsh_sysvar_lookup+0x2c>
	     index < _sysvar_table_end;
	     FINSH_NEXT_SYSVAR(index))
	{
		if (strcmp(index->name, name) == 0)
 8021ed0:	68fb      	ldr	r3, [r7, #12]
 8021ed2:	681b      	ldr	r3, [r3, #0]
 8021ed4:	4618      	mov	r0, r3
 8021ed6:	6879      	ldr	r1, [r7, #4]
 8021ed8:	f7de faa6 	bl	8000428 <strcmp>
 8021edc:	4603      	mov	r3, r0
 8021ede:	2b00      	cmp	r3, #0
 8021ee0:	d101      	bne.n	8021ee6 <finsh_sysvar_lookup+0x26>
			return index;
 8021ee2:	68fb      	ldr	r3, [r7, #12]
 8021ee4:	e023      	b.n	8021f2e <finsh_sysvar_lookup+0x6e>
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
	     index < _sysvar_table_end;
	     FINSH_NEXT_SYSVAR(index))
 8021ee6:	68fb      	ldr	r3, [r7, #12]
 8021ee8:	3310      	adds	r3, #16
 8021eea:	60fb      	str	r3, [r7, #12]
{
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
	     index < _sysvar_table_end;
 8021eec:	4b13      	ldr	r3, [pc, #76]	; (8021f3c <finsh_sysvar_lookup+0x7c>)
 8021eee:	681b      	ldr	r3, [r3, #0]
struct finsh_sysvar* finsh_sysvar_lookup(const char* name)
{
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
 8021ef0:	68fa      	ldr	r2, [r7, #12]
 8021ef2:	429a      	cmp	r2, r3
 8021ef4:	d3ec      	bcc.n	8021ed0 <finsh_sysvar_lookup+0x10>
		if (strcmp(index->name, name) == 0)
			return index;
	}

	/* find in sysvar list */
	item = global_sysvar_list;
 8021ef6:	4b12      	ldr	r3, [pc, #72]	; (8021f40 <finsh_sysvar_lookup+0x80>)
 8021ef8:	681b      	ldr	r3, [r3, #0]
 8021efa:	60bb      	str	r3, [r7, #8]
	while (item != NULL)
 8021efc:	e013      	b.n	8021f26 <finsh_sysvar_lookup+0x66>
	{
		if (strncmp(item->sysvar.name, name, strlen(name)) == 0)
 8021efe:	68bb      	ldr	r3, [r7, #8]
 8021f00:	685c      	ldr	r4, [r3, #4]
 8021f02:	6878      	ldr	r0, [r7, #4]
 8021f04:	f001 fbce 	bl	80236a4 <strlen>
 8021f08:	4603      	mov	r3, r0
 8021f0a:	4620      	mov	r0, r4
 8021f0c:	6879      	ldr	r1, [r7, #4]
 8021f0e:	461a      	mov	r2, r3
 8021f10:	f001 fbf6 	bl	8023700 <strncmp>
 8021f14:	4603      	mov	r3, r0
 8021f16:	2b00      	cmp	r3, #0
 8021f18:	d102      	bne.n	8021f20 <finsh_sysvar_lookup+0x60>
		{
			return &(item->sysvar);
 8021f1a:	68bb      	ldr	r3, [r7, #8]
 8021f1c:	3304      	adds	r3, #4
 8021f1e:	e006      	b.n	8021f2e <finsh_sysvar_lookup+0x6e>
		}

		/* move to next item */
		item = item->next;
 8021f20:	68bb      	ldr	r3, [r7, #8]
 8021f22:	681b      	ldr	r3, [r3, #0]
 8021f24:	60bb      	str	r3, [r7, #8]
			return index;
	}

	/* find in sysvar list */
	item = global_sysvar_list;
	while (item != NULL)
 8021f26:	68bb      	ldr	r3, [r7, #8]
 8021f28:	2b00      	cmp	r3, #0
 8021f2a:	d1e8      	bne.n	8021efe <finsh_sysvar_lookup+0x3e>
		/* move to next item */
		item = item->next;
	}

	/* can't find variable */
	return NULL;
 8021f2c:	2300      	movs	r3, #0
}
 8021f2e:	4618      	mov	r0, r3
 8021f30:	3714      	adds	r7, #20
 8021f32:	46bd      	mov	sp, r7
 8021f34:	bd90      	pop	{r4, r7, pc}
 8021f36:	bf00      	nop
 8021f38:	20012194 	.word	0x20012194
 8021f3c:	20012198 	.word	0x20012198
 8021f40:	20012d84 	.word	0x20012d84

08021f44 <finsh_vm_run>:
/* syscall list, for dynamic system call register */
struct finsh_syscall_item* global_syscall_list = NULL;

// #define FINSH_VM_DISASSEMBLE
void finsh_vm_run()
{
 8021f44:	b580      	push	{r7, lr}
 8021f46:	b082      	sub	sp, #8
 8021f48:	af00      	add	r7, sp, #0
	void finsh_disassemble();
	finsh_disassemble();
#endif

	/* set sp(stack pointer) to the beginning of stack */
	finsh_sp = &finsh_vm_stack[0];
 8021f4a:	4b12      	ldr	r3, [pc, #72]	; (8021f94 <finsh_vm_run+0x50>)
 8021f4c:	4a12      	ldr	r2, [pc, #72]	; (8021f98 <finsh_vm_run+0x54>)
 8021f4e:	601a      	str	r2, [r3, #0]

	/* set pc to the beginning of text segment */
	finsh_pc = &text_segment[0];
 8021f50:	4b12      	ldr	r3, [pc, #72]	; (8021f9c <finsh_vm_run+0x58>)
 8021f52:	4a13      	ldr	r2, [pc, #76]	; (8021fa0 <finsh_vm_run+0x5c>)
 8021f54:	601a      	str	r2, [r3, #0]

	while ((finsh_pc - &text_segment[0] >= 0) &&
 8021f56:	e00b      	b.n	8021f70 <finsh_vm_run+0x2c>
		(finsh_pc - &text_segment[0] < FINSH_TEXT_MAX))
	{
		/* get op */
		op = *finsh_pc++;
 8021f58:	4b10      	ldr	r3, [pc, #64]	; (8021f9c <finsh_vm_run+0x58>)
 8021f5a:	681b      	ldr	r3, [r3, #0]
 8021f5c:	1c5a      	adds	r2, r3, #1
 8021f5e:	490f      	ldr	r1, [pc, #60]	; (8021f9c <finsh_vm_run+0x58>)
 8021f60:	600a      	str	r2, [r1, #0]
 8021f62:	781b      	ldrb	r3, [r3, #0]
 8021f64:	71fb      	strb	r3, [r7, #7]

		/* call op function */
		op_table[op]();
 8021f66:	79fb      	ldrb	r3, [r7, #7]
 8021f68:	4a0e      	ldr	r2, [pc, #56]	; (8021fa4 <finsh_vm_run+0x60>)
 8021f6a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8021f6e:	4798      	blx	r3
	finsh_sp = &finsh_vm_stack[0];

	/* set pc to the beginning of text segment */
	finsh_pc = &text_segment[0];

	while ((finsh_pc - &text_segment[0] >= 0) &&
 8021f70:	4b0a      	ldr	r3, [pc, #40]	; (8021f9c <finsh_vm_run+0x58>)
 8021f72:	681b      	ldr	r3, [r3, #0]
 8021f74:	461a      	mov	r2, r3
 8021f76:	4b0a      	ldr	r3, [pc, #40]	; (8021fa0 <finsh_vm_run+0x5c>)
 8021f78:	1ad3      	subs	r3, r2, r3
 8021f7a:	2b00      	cmp	r3, #0
 8021f7c:	db06      	blt.n	8021f8c <finsh_vm_run+0x48>
		(finsh_pc - &text_segment[0] < FINSH_TEXT_MAX))
 8021f7e:	4b07      	ldr	r3, [pc, #28]	; (8021f9c <finsh_vm_run+0x58>)
 8021f80:	681b      	ldr	r3, [r3, #0]
 8021f82:	461a      	mov	r2, r3
 8021f84:	4b06      	ldr	r3, [pc, #24]	; (8021fa0 <finsh_vm_run+0x5c>)
 8021f86:	1ad3      	subs	r3, r2, r3
	finsh_sp = &finsh_vm_stack[0];

	/* set pc to the beginning of text segment */
	finsh_pc = &text_segment[0];

	while ((finsh_pc - &text_segment[0] >= 0) &&
 8021f88:	2b7f      	cmp	r3, #127	; 0x7f
 8021f8a:	dde5      	ble.n	8021f58 <finsh_vm_run+0x14>
		op = *finsh_pc++;

		/* call op function */
		op_table[op]();
	}
}
 8021f8c:	3708      	adds	r7, #8
 8021f8e:	46bd      	mov	sp, r7
 8021f90:	bd80      	pop	{r7, pc}
 8021f92:	bf00      	nop
 8021f94:	20012fcc 	.word	0x20012fcc
 8021f98:	20012ec8 	.word	0x20012ec8
 8021f9c:	20012fc8 	.word	0x20012fc8
 8021fa0:	20012e48 	.word	0x20012e48
 8021fa4:	08029bb0 	.word	0x08029bb0

08021fa8 <finsh_syscall_lookup>:
	return (struct finsh_sysvar*)ptr;
}
#endif

struct finsh_syscall* finsh_syscall_lookup(const char* name)
{
 8021fa8:	b590      	push	{r4, r7, lr}
 8021faa:	b085      	sub	sp, #20
 8021fac:	af00      	add	r7, sp, #0
 8021fae:	6078      	str	r0, [r7, #4]
	struct finsh_syscall* index;
	struct finsh_syscall_item* item;

	for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
 8021fb0:	4b1b      	ldr	r3, [pc, #108]	; (8022020 <finsh_syscall_lookup+0x78>)
 8021fb2:	681b      	ldr	r3, [r3, #0]
 8021fb4:	60fb      	str	r3, [r7, #12]
 8021fb6:	e00d      	b.n	8021fd4 <finsh_syscall_lookup+0x2c>
	{
		if (strcmp(index->name, name) == 0)
 8021fb8:	68fb      	ldr	r3, [r7, #12]
 8021fba:	681b      	ldr	r3, [r3, #0]
 8021fbc:	4618      	mov	r0, r3
 8021fbe:	6879      	ldr	r1, [r7, #4]
 8021fc0:	f7de fa32 	bl	8000428 <strcmp>
 8021fc4:	4603      	mov	r3, r0
 8021fc6:	2b00      	cmp	r3, #0
 8021fc8:	d101      	bne.n	8021fce <finsh_syscall_lookup+0x26>
			return index;
 8021fca:	68fb      	ldr	r3, [r7, #12]
 8021fcc:	e023      	b.n	8022016 <finsh_syscall_lookup+0x6e>
struct finsh_syscall* finsh_syscall_lookup(const char* name)
{
	struct finsh_syscall* index;
	struct finsh_syscall_item* item;

	for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
 8021fce:	68fb      	ldr	r3, [r7, #12]
 8021fd0:	330c      	adds	r3, #12
 8021fd2:	60fb      	str	r3, [r7, #12]
 8021fd4:	4b13      	ldr	r3, [pc, #76]	; (8022024 <finsh_syscall_lookup+0x7c>)
 8021fd6:	681b      	ldr	r3, [r3, #0]
 8021fd8:	68fa      	ldr	r2, [r7, #12]
 8021fda:	429a      	cmp	r2, r3
 8021fdc:	d3ec      	bcc.n	8021fb8 <finsh_syscall_lookup+0x10>
		if (strcmp(index->name, name) == 0)
			return index;
	}

	/* find on syscall list */
	item = global_syscall_list;
 8021fde:	4b12      	ldr	r3, [pc, #72]	; (8022028 <finsh_syscall_lookup+0x80>)
 8021fe0:	681b      	ldr	r3, [r3, #0]
 8021fe2:	60bb      	str	r3, [r7, #8]
	while (item != NULL)
 8021fe4:	e013      	b.n	802200e <finsh_syscall_lookup+0x66>
	{
		if (strncmp(item->syscall.name, name, strlen(name)) == 0)
 8021fe6:	68bb      	ldr	r3, [r7, #8]
 8021fe8:	685c      	ldr	r4, [r3, #4]
 8021fea:	6878      	ldr	r0, [r7, #4]
 8021fec:	f001 fb5a 	bl	80236a4 <strlen>
 8021ff0:	4603      	mov	r3, r0
 8021ff2:	4620      	mov	r0, r4
 8021ff4:	6879      	ldr	r1, [r7, #4]
 8021ff6:	461a      	mov	r2, r3
 8021ff8:	f001 fb82 	bl	8023700 <strncmp>
 8021ffc:	4603      	mov	r3, r0
 8021ffe:	2b00      	cmp	r3, #0
 8022000:	d102      	bne.n	8022008 <finsh_syscall_lookup+0x60>
		{
			return &(item->syscall);
 8022002:	68bb      	ldr	r3, [r7, #8]
 8022004:	3304      	adds	r3, #4
 8022006:	e006      	b.n	8022016 <finsh_syscall_lookup+0x6e>
		}

		item = item->next;
 8022008:	68bb      	ldr	r3, [r7, #8]
 802200a:	681b      	ldr	r3, [r3, #0]
 802200c:	60bb      	str	r3, [r7, #8]
			return index;
	}

	/* find on syscall list */
	item = global_syscall_list;
	while (item != NULL)
 802200e:	68bb      	ldr	r3, [r7, #8]
 8022010:	2b00      	cmp	r3, #0
 8022012:	d1e8      	bne.n	8021fe6 <finsh_syscall_lookup+0x3e>
		}

		item = item->next;
	}

	return NULL;
 8022014:	2300      	movs	r3, #0
}
 8022016:	4618      	mov	r0, r3
 8022018:	3714      	adds	r7, #20
 802201a:	46bd      	mov	sp, r7
 802201c:	bd90      	pop	{r4, r7, pc}
 802201e:	bf00      	nop
 8022020:	2001218c 	.word	0x2001218c
 8022024:	20012190 	.word	0x20012190
 8022028:	200121a8 	.word	0x200121a8

0802202c <finsh_token_init>:
static void token_trim_space(struct finsh_token* self);
static char token_proc_char(struct finsh_token* self);
static int token_proc_escape(struct finsh_token* self);

void finsh_token_init(struct finsh_token* self, u_char* line)
{
 802202c:	b580      	push	{r7, lr}
 802202e:	b082      	sub	sp, #8
 8022030:	af00      	add	r7, sp, #0
 8022032:	6078      	str	r0, [r7, #4]
 8022034:	6039      	str	r1, [r7, #0]
	memset(self, 0, sizeof(struct finsh_token));
 8022036:	6878      	ldr	r0, [r7, #4]
 8022038:	2100      	movs	r1, #0
 802203a:	2294      	movs	r2, #148	; 0x94
 802203c:	f000 fea0 	bl	8022d80 <memset>

	self->line = line;
 8022040:	687b      	ldr	r3, [r7, #4]
 8022042:	683a      	ldr	r2, [r7, #0]
 8022044:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
}
 8022048:	3708      	adds	r7, #8
 802204a:	46bd      	mov	sp, r7
 802204c:	bd80      	pop	{r7, pc}
 802204e:	bf00      	nop

08022050 <finsh_token_token>:

enum finsh_token_type finsh_token_token(struct finsh_token* self)
{
 8022050:	b580      	push	{r7, lr}
 8022052:	b082      	sub	sp, #8
 8022054:	af00      	add	r7, sp, #0
 8022056:	6078      	str	r0, [r7, #4]
	if ( self->replay )	self->replay = 0;
 8022058:	687b      	ldr	r3, [r7, #4]
 802205a:	785b      	ldrb	r3, [r3, #1]
 802205c:	2b00      	cmp	r3, #0
 802205e:	d003      	beq.n	8022068 <finsh_token_token+0x18>
 8022060:	687b      	ldr	r3, [r7, #4]
 8022062:	2200      	movs	r2, #0
 8022064:	705a      	strb	r2, [r3, #1]
 8022066:	e002      	b.n	802206e <finsh_token_token+0x1e>
	else token_run(self);
 8022068:	6878      	ldr	r0, [r7, #4]
 802206a:	f000 f8a7 	bl	80221bc <token_run>

	return (enum finsh_token_type)self->current_token;
 802206e:	687b      	ldr	r3, [r7, #4]
 8022070:	7a1b      	ldrb	r3, [r3, #8]
}
 8022072:	4618      	mov	r0, r3
 8022074:	3708      	adds	r7, #8
 8022076:	46bd      	mov	sp, r7
 8022078:	bd80      	pop	{r7, pc}
 802207a:	bf00      	nop

0802207c <token_get_string>:
{
	strncpy((char*)token, (char*)self->string, FINSH_NAME_MAX);
}

int token_get_string(struct finsh_token* self, u_char* str)
{
 802207c:	b580      	push	{r7, lr}
 802207e:	b084      	sub	sp, #16
 8022080:	af00      	add	r7, sp, #0
 8022082:	6078      	str	r0, [r7, #4]
 8022084:	6039      	str	r1, [r7, #0]
	unsigned char *p=str;
 8022086:	683b      	ldr	r3, [r7, #0]
 8022088:	60fb      	str	r3, [r7, #12]
	char ch;

	ch = token_next_char(self);
 802208a:	6878      	ldr	r0, [r7, #4]
 802208c:	f000 f84a 	bl	8022124 <token_next_char>
 8022090:	4603      	mov	r3, r0
 8022092:	72fb      	strb	r3, [r7, #11]
	if (is_eof(self)) return -1;
 8022094:	687b      	ldr	r3, [r7, #4]
 8022096:	781b      	ldrb	r3, [r3, #0]
 8022098:	2b00      	cmp	r3, #0
 802209a:	d002      	beq.n	80220a2 <token_get_string+0x26>
 802209c:	f04f 33ff 	mov.w	r3, #4294967295
 80220a0:	e03c      	b.n	802211c <token_get_string+0xa0>

	str[0] = '\0';
 80220a2:	683b      	ldr	r3, [r7, #0]
 80220a4:	2200      	movs	r2, #0
 80220a6:	701a      	strb	r2, [r3, #0]

	if ( is_digit(ch) )/*the first character of identifier is not a digit.*/
 80220a8:	7afb      	ldrb	r3, [r7, #11]
 80220aa:	2b2f      	cmp	r3, #47	; 0x2f
 80220ac:	d908      	bls.n	80220c0 <token_get_string+0x44>
 80220ae:	7afb      	ldrb	r3, [r7, #11]
 80220b0:	2b39      	cmp	r3, #57	; 0x39
 80220b2:	d805      	bhi.n	80220c0 <token_get_string+0x44>
	{
		token_prev_char(self);
 80220b4:	6878      	ldr	r0, [r7, #4]
 80220b6:	f000 f869 	bl	802218c <token_prev_char>
		return -1;
 80220ba:	f04f 33ff 	mov.w	r3, #4294967295
 80220be:	e02d      	b.n	802211c <token_get_string+0xa0>
	}

	while (!is_separator(ch) && !is_eof(self))
 80220c0:	e009      	b.n	80220d6 <token_get_string+0x5a>
	{
		*p++ = ch;
 80220c2:	68fb      	ldr	r3, [r7, #12]
 80220c4:	1c5a      	adds	r2, r3, #1
 80220c6:	60fa      	str	r2, [r7, #12]
 80220c8:	7afa      	ldrb	r2, [r7, #11]
 80220ca:	701a      	strb	r2, [r3, #0]

		ch = token_next_char(self);
 80220cc:	6878      	ldr	r0, [r7, #4]
 80220ce:	f000 f829 	bl	8022124 <token_next_char>
 80220d2:	4603      	mov	r3, r0
 80220d4:	72fb      	strb	r3, [r7, #11]
	{
		token_prev_char(self);
		return -1;
	}

	while (!is_separator(ch) && !is_eof(self))
 80220d6:	7afb      	ldrb	r3, [r7, #11]
 80220d8:	2b60      	cmp	r3, #96	; 0x60
 80220da:	d902      	bls.n	80220e2 <token_get_string+0x66>
 80220dc:	7afb      	ldrb	r3, [r7, #11]
 80220de:	2b7a      	cmp	r3, #122	; 0x7a
 80220e0:	d90e      	bls.n	8022100 <token_get_string+0x84>
 80220e2:	7afb      	ldrb	r3, [r7, #11]
 80220e4:	2b40      	cmp	r3, #64	; 0x40
 80220e6:	d902      	bls.n	80220ee <token_get_string+0x72>
 80220e8:	7afb      	ldrb	r3, [r7, #11]
 80220ea:	2b5a      	cmp	r3, #90	; 0x5a
 80220ec:	d908      	bls.n	8022100 <token_get_string+0x84>
 80220ee:	7afb      	ldrb	r3, [r7, #11]
 80220f0:	2b2f      	cmp	r3, #47	; 0x2f
 80220f2:	d902      	bls.n	80220fa <token_get_string+0x7e>
 80220f4:	7afb      	ldrb	r3, [r7, #11]
 80220f6:	2b39      	cmp	r3, #57	; 0x39
 80220f8:	d902      	bls.n	8022100 <token_get_string+0x84>
 80220fa:	7afb      	ldrb	r3, [r7, #11]
 80220fc:	2b5f      	cmp	r3, #95	; 0x5f
 80220fe:	d103      	bne.n	8022108 <token_get_string+0x8c>
 8022100:	687b      	ldr	r3, [r7, #4]
 8022102:	781b      	ldrb	r3, [r3, #0]
 8022104:	2b00      	cmp	r3, #0
 8022106:	d0dc      	beq.n	80220c2 <token_get_string+0x46>
	{
		*p++ = ch;

		ch = token_next_char(self);
	}
	self->eof = 0;
 8022108:	687b      	ldr	r3, [r7, #4]
 802210a:	2200      	movs	r2, #0
 802210c:	701a      	strb	r2, [r3, #0]

	token_prev_char(self);
 802210e:	6878      	ldr	r0, [r7, #4]
 8022110:	f000 f83c 	bl	802218c <token_prev_char>
	*p = '\0';
 8022114:	68fb      	ldr	r3, [r7, #12]
 8022116:	2200      	movs	r2, #0
 8022118:	701a      	strb	r2, [r3, #0]

	return 0;
 802211a:	2300      	movs	r3, #0
}
 802211c:	4618      	mov	r0, r3
 802211e:	3710      	adds	r7, #16
 8022120:	46bd      	mov	sp, r7
 8022122:	bd80      	pop	{r7, pc}

08022124 <token_next_char>:

/*
get next character.
*/
static char token_next_char(struct finsh_token* self)
{
 8022124:	b590      	push	{r4, r7, lr}
 8022126:	b083      	sub	sp, #12
 8022128:	af00      	add	r7, sp, #0
 802212a:	6078      	str	r0, [r7, #4]
	if (self->eof) return '\0';
 802212c:	687b      	ldr	r3, [r7, #4]
 802212e:	781b      	ldrb	r3, [r3, #0]
 8022130:	2b00      	cmp	r3, #0
 8022132:	d001      	beq.n	8022138 <token_next_char+0x14>
 8022134:	2300      	movs	r3, #0
 8022136:	e025      	b.n	8022184 <token_next_char+0x60>

	if (self->position == (int)strlen((char*)self->line) || self->line[self->position] =='\n')
 8022138:	687b      	ldr	r3, [r7, #4]
 802213a:	685c      	ldr	r4, [r3, #4]
 802213c:	687b      	ldr	r3, [r7, #4]
 802213e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8022142:	4618      	mov	r0, r3
 8022144:	f001 faae 	bl	80236a4 <strlen>
 8022148:	4603      	mov	r3, r0
 802214a:	429c      	cmp	r4, r3
 802214c:	d008      	beq.n	8022160 <token_next_char+0x3c>
 802214e:	687b      	ldr	r3, [r7, #4]
 8022150:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8022154:	687a      	ldr	r2, [r7, #4]
 8022156:	6852      	ldr	r2, [r2, #4]
 8022158:	4413      	add	r3, r2
 802215a:	781b      	ldrb	r3, [r3, #0]
 802215c:	2b0a      	cmp	r3, #10
 802215e:	d107      	bne.n	8022170 <token_next_char+0x4c>
	{
			self->eof = 1;
 8022160:	687b      	ldr	r3, [r7, #4]
 8022162:	2201      	movs	r2, #1
 8022164:	701a      	strb	r2, [r3, #0]
			self->position = 0;
 8022166:	687b      	ldr	r3, [r7, #4]
 8022168:	2200      	movs	r2, #0
 802216a:	605a      	str	r2, [r3, #4]
			return '\0';
 802216c:	2300      	movs	r3, #0
 802216e:	e009      	b.n	8022184 <token_next_char+0x60>
	}

	return self->line[self->position++];
 8022170:	687b      	ldr	r3, [r7, #4]
 8022172:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8022176:	687b      	ldr	r3, [r7, #4]
 8022178:	685b      	ldr	r3, [r3, #4]
 802217a:	1c58      	adds	r0, r3, #1
 802217c:	6879      	ldr	r1, [r7, #4]
 802217e:	6048      	str	r0, [r1, #4]
 8022180:	4413      	add	r3, r2
 8022182:	781b      	ldrb	r3, [r3, #0]
}
 8022184:	4618      	mov	r0, r3
 8022186:	370c      	adds	r7, #12
 8022188:	46bd      	mov	sp, r7
 802218a:	bd90      	pop	{r4, r7, pc}

0802218c <token_prev_char>:

static void token_prev_char(struct finsh_token* self)
{
 802218c:	b480      	push	{r7}
 802218e:	b083      	sub	sp, #12
 8022190:	af00      	add	r7, sp, #0
 8022192:	6078      	str	r0, [r7, #4]
	if ( self->eof ) return;
 8022194:	687b      	ldr	r3, [r7, #4]
 8022196:	781b      	ldrb	r3, [r3, #0]
 8022198:	2b00      	cmp	r3, #0
 802219a:	d000      	beq.n	802219e <token_prev_char+0x12>
 802219c:	e009      	b.n	80221b2 <token_prev_char+0x26>

	if ( self->position == 0 ) return;
 802219e:	687b      	ldr	r3, [r7, #4]
 80221a0:	685b      	ldr	r3, [r3, #4]
 80221a2:	2b00      	cmp	r3, #0
 80221a4:	d100      	bne.n	80221a8 <token_prev_char+0x1c>
 80221a6:	e004      	b.n	80221b2 <token_prev_char+0x26>
    else self->position--;
 80221a8:	687b      	ldr	r3, [r7, #4]
 80221aa:	685b      	ldr	r3, [r3, #4]
 80221ac:	1e5a      	subs	r2, r3, #1
 80221ae:	687b      	ldr	r3, [r7, #4]
 80221b0:	605a      	str	r2, [r3, #4]
}
 80221b2:	370c      	adds	r7, #12
 80221b4:	46bd      	mov	sp, r7
 80221b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80221ba:	4770      	bx	lr

080221bc <token_run>:

static void token_run(struct finsh_token* self)
{
 80221bc:	b580      	push	{r7, lr}
 80221be:	b084      	sub	sp, #16
 80221c0:	af00      	add	r7, sp, #0
 80221c2:	6078      	str	r0, [r7, #4]
	char ch;

	token_trim_space(self); /* first trim space and tab. */
 80221c4:	6878      	ldr	r0, [r7, #4]
 80221c6:	f000 f9c5 	bl	8022554 <token_trim_space>
	token_get_string(self, &(self->string[0]));
 80221ca:	687b      	ldr	r3, [r7, #4]
 80221cc:	3310      	adds	r3, #16
 80221ce:	6878      	ldr	r0, [r7, #4]
 80221d0:	4619      	mov	r1, r3
 80221d2:	f7ff ff53 	bl	802207c <token_get_string>

	if ( is_eof(self) ) /*if it is eof, break;*/
 80221d6:	687b      	ldr	r3, [r7, #4]
 80221d8:	781b      	ldrb	r3, [r3, #0]
 80221da:	2b00      	cmp	r3, #0
 80221dc:	d003      	beq.n	80221e6 <token_run+0x2a>
	{
		self->current_token = finsh_token_type_eof;
 80221de:	687b      	ldr	r3, [r7, #4]
 80221e0:	2221      	movs	r2, #33	; 0x21
 80221e2:	721a      	strb	r2, [r3, #8]
		return ;
 80221e4:	e189      	b.n	80224fa <token_run+0x33e>
	}

	if (self->string[0] != '\0') /*It is a key word or a identifier.*/
 80221e6:	687b      	ldr	r3, [r7, #4]
 80221e8:	7c1b      	ldrb	r3, [r3, #16]
 80221ea:	2b00      	cmp	r3, #0
 80221ec:	d00d      	beq.n	802220a <token_run+0x4e>
	{
		if ( !token_match_name(self, (char*)self->string) )
 80221ee:	687b      	ldr	r3, [r7, #4]
 80221f0:	3310      	adds	r3, #16
 80221f2:	6878      	ldr	r0, [r7, #4]
 80221f4:	4619      	mov	r1, r3
 80221f6:	f000 f983 	bl	8022500 <token_match_name>
 80221fa:	4603      	mov	r3, r0
 80221fc:	2b00      	cmp	r3, #0
 80221fe:	f040 817c 	bne.w	80224fa <token_run+0x33e>
		{
			self->current_token = finsh_token_type_identifier;
 8022202:	687b      	ldr	r3, [r7, #4]
 8022204:	221f      	movs	r2, #31
 8022206:	721a      	strb	r2, [r3, #8]
 8022208:	e177      	b.n	80224fa <token_run+0x33e>
		}
	}
	else/*It is a operator character.*/
	{
		ch = token_next_char(self);
 802220a:	6878      	ldr	r0, [r7, #4]
 802220c:	f7ff ff8a 	bl	8022124 <token_next_char>
 8022210:	4603      	mov	r3, r0
 8022212:	73fb      	strb	r3, [r7, #15]

		switch ( ch )
 8022214:	7bfb      	ldrb	r3, [r7, #15]
 8022216:	3b22      	subs	r3, #34	; 0x22
 8022218:	2b5c      	cmp	r3, #92	; 0x5c
 802221a:	f200 815a 	bhi.w	80224d2 <token_run+0x316>
 802221e:	a201      	add	r2, pc, #4	; (adr r2, 8022224 <token_run+0x68>)
 8022220:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8022224:	080224c5 	.word	0x080224c5
 8022228:	080224d3 	.word	0x080224d3
 802222c:	080224d3 	.word	0x080224d3
 8022230:	0802248f 	.word	0x0802248f
 8022234:	080223b9 	.word	0x080223b9
 8022238:	080224af 	.word	0x080224af
 802223c:	08022399 	.word	0x08022399
 8022240:	080223a1 	.word	0x080223a1
 8022244:	080223c1 	.word	0x080223c1
 8022248:	080223c9 	.word	0x080223c9
 802224c:	080223a9 	.word	0x080223a9
 8022250:	080223ef 	.word	0x080223ef
 8022254:	080224d3 	.word	0x080224d3
 8022258:	08022415 	.word	0x08022415
 802225c:	080224d3 	.word	0x080224d3
 8022260:	080224d3 	.word	0x080224d3
 8022264:	080224d3 	.word	0x080224d3
 8022268:	080224d3 	.word	0x080224d3
 802226c:	080224d3 	.word	0x080224d3
 8022270:	080224d3 	.word	0x080224d3
 8022274:	080224d3 	.word	0x080224d3
 8022278:	080224d3 	.word	0x080224d3
 802227c:	080224d3 	.word	0x080224d3
 8022280:	080224d3 	.word	0x080224d3
 8022284:	080224d3 	.word	0x080224d3
 8022288:	080223b1 	.word	0x080223b1
 802228c:	0802243b 	.word	0x0802243b
 8022290:	080224a7 	.word	0x080224a7
 8022294:	08022461 	.word	0x08022461
 8022298:	080224d3 	.word	0x080224d3
 802229c:	080224d3 	.word	0x080224d3
 80222a0:	080224d3 	.word	0x080224d3
 80222a4:	080224d3 	.word	0x080224d3
 80222a8:	080224d3 	.word	0x080224d3
 80222ac:	080224d3 	.word	0x080224d3
 80222b0:	080224d3 	.word	0x080224d3
 80222b4:	080224d3 	.word	0x080224d3
 80222b8:	080224d3 	.word	0x080224d3
 80222bc:	080224d3 	.word	0x080224d3
 80222c0:	080224d3 	.word	0x080224d3
 80222c4:	080224d3 	.word	0x080224d3
 80222c8:	080224d3 	.word	0x080224d3
 80222cc:	080224d3 	.word	0x080224d3
 80222d0:	080224d3 	.word	0x080224d3
 80222d4:	080224d3 	.word	0x080224d3
 80222d8:	080224d3 	.word	0x080224d3
 80222dc:	080224d3 	.word	0x080224d3
 80222e0:	080224d3 	.word	0x080224d3
 80222e4:	080224d3 	.word	0x080224d3
 80222e8:	080224d3 	.word	0x080224d3
 80222ec:	080224d3 	.word	0x080224d3
 80222f0:	080224d3 	.word	0x080224d3
 80222f4:	080224d3 	.word	0x080224d3
 80222f8:	080224d3 	.word	0x080224d3
 80222fc:	080224d3 	.word	0x080224d3
 8022300:	080224d3 	.word	0x080224d3
 8022304:	080224d3 	.word	0x080224d3
 8022308:	080224d3 	.word	0x080224d3
 802230c:	080224d3 	.word	0x080224d3
 8022310:	080224d3 	.word	0x080224d3
 8022314:	0802249f 	.word	0x0802249f
 8022318:	080224d3 	.word	0x080224d3
 802231c:	080224d3 	.word	0x080224d3
 8022320:	080224d3 	.word	0x080224d3
 8022324:	080224d3 	.word	0x080224d3
 8022328:	080224d3 	.word	0x080224d3
 802232c:	080224d3 	.word	0x080224d3
 8022330:	080224d3 	.word	0x080224d3
 8022334:	080224d3 	.word	0x080224d3
 8022338:	080224d3 	.word	0x080224d3
 802233c:	080224d3 	.word	0x080224d3
 8022340:	080224d3 	.word	0x080224d3
 8022344:	080224d3 	.word	0x080224d3
 8022348:	080224d3 	.word	0x080224d3
 802234c:	080224d3 	.word	0x080224d3
 8022350:	080224d3 	.word	0x080224d3
 8022354:	080224d3 	.word	0x080224d3
 8022358:	080224d3 	.word	0x080224d3
 802235c:	080224d3 	.word	0x080224d3
 8022360:	080224d3 	.word	0x080224d3
 8022364:	080224d3 	.word	0x080224d3
 8022368:	080224d3 	.word	0x080224d3
 802236c:	080224d3 	.word	0x080224d3
 8022370:	080224d3 	.word	0x080224d3
 8022374:	080224d3 	.word	0x080224d3
 8022378:	080224d3 	.word	0x080224d3
 802237c:	080224d3 	.word	0x080224d3
 8022380:	080224d3 	.word	0x080224d3
 8022384:	080224d3 	.word	0x080224d3
 8022388:	080224d3 	.word	0x080224d3
 802238c:	08022487 	.word	0x08022487
 8022390:	080224d3 	.word	0x080224d3
 8022394:	08022497 	.word	0x08022497
		{
		case '(':
			self->current_token = finsh_token_type_left_paren;
 8022398:	687b      	ldr	r3, [r7, #4]
 802239a:	2201      	movs	r2, #1
 802239c:	721a      	strb	r2, [r3, #8]
			break;
 802239e:	e0ac      	b.n	80224fa <token_run+0x33e>

		case ')':
			self->current_token = finsh_token_type_right_paren;
 80223a0:	687b      	ldr	r3, [r7, #4]
 80223a2:	2202      	movs	r2, #2
 80223a4:	721a      	strb	r2, [r3, #8]
			break;
 80223a6:	e0a8      	b.n	80224fa <token_run+0x33e>

		case ',':
			self->current_token = finsh_token_type_comma;
 80223a8:	687b      	ldr	r3, [r7, #4]
 80223aa:	2203      	movs	r2, #3
 80223ac:	721a      	strb	r2, [r3, #8]
			break;
 80223ae:	e0a4      	b.n	80224fa <token_run+0x33e>

		case ';':
			self->current_token = finsh_token_type_semicolon;
 80223b0:	687b      	ldr	r3, [r7, #4]
 80223b2:	2204      	movs	r2, #4
 80223b4:	721a      	strb	r2, [r3, #8]
			break;
 80223b6:	e0a0      	b.n	80224fa <token_run+0x33e>

		case '&':
			self->current_token = finsh_token_type_and;
 80223b8:	687b      	ldr	r3, [r7, #4]
 80223ba:	220d      	movs	r2, #13
 80223bc:	721a      	strb	r2, [r3, #8]
			break;
 80223be:	e09c      	b.n	80224fa <token_run+0x33e>

		case '*':
			self->current_token = finsh_token_type_mul;
 80223c0:	687b      	ldr	r3, [r7, #4]
 80223c2:	2205      	movs	r2, #5
 80223c4:	721a      	strb	r2, [r3, #8]
			break;
 80223c6:	e098      	b.n	80224fa <token_run+0x33e>

		case '+':
			ch = token_next_char(self);
 80223c8:	6878      	ldr	r0, [r7, #4]
 80223ca:	f7ff feab 	bl	8022124 <token_next_char>
 80223ce:	4603      	mov	r3, r0
 80223d0:	73fb      	strb	r3, [r7, #15]

			if ( ch == '+' )
 80223d2:	7bfb      	ldrb	r3, [r7, #15]
 80223d4:	2b2b      	cmp	r3, #43	; 0x2b
 80223d6:	d103      	bne.n	80223e0 <token_run+0x224>
			{
				self->current_token = finsh_token_type_inc;
 80223d8:	687b      	ldr	r3, [r7, #4]
 80223da:	2207      	movs	r2, #7
 80223dc:	721a      	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_add;
			}
			break;
 80223de:	e08c      	b.n	80224fa <token_run+0x33e>
			{
				self->current_token = finsh_token_type_inc;
			}
			else
			{
				token_prev_char(self);
 80223e0:	6878      	ldr	r0, [r7, #4]
 80223e2:	f7ff fed3 	bl	802218c <token_prev_char>
				self->current_token = finsh_token_type_add;
 80223e6:	687b      	ldr	r3, [r7, #4]
 80223e8:	2206      	movs	r2, #6
 80223ea:	721a      	strb	r2, [r3, #8]
			}
			break;
 80223ec:	e085      	b.n	80224fa <token_run+0x33e>

		case '-':
			ch = token_next_char(self);
 80223ee:	6878      	ldr	r0, [r7, #4]
 80223f0:	f7ff fe98 	bl	8022124 <token_next_char>
 80223f4:	4603      	mov	r3, r0
 80223f6:	73fb      	strb	r3, [r7, #15]

			if ( ch == '-' )
 80223f8:	7bfb      	ldrb	r3, [r7, #15]
 80223fa:	2b2d      	cmp	r3, #45	; 0x2d
 80223fc:	d103      	bne.n	8022406 <token_run+0x24a>
			{
				self->current_token = finsh_token_type_dec;
 80223fe:	687b      	ldr	r3, [r7, #4]
 8022400:	2209      	movs	r2, #9
 8022402:	721a      	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_sub;
			}
			break;
 8022404:	e079      	b.n	80224fa <token_run+0x33e>
			{
				self->current_token = finsh_token_type_dec;
			}
			else
			{
				token_prev_char(self);
 8022406:	6878      	ldr	r0, [r7, #4]
 8022408:	f7ff fec0 	bl	802218c <token_prev_char>
				self->current_token = finsh_token_type_sub;
 802240c:	687b      	ldr	r3, [r7, #4]
 802240e:	2208      	movs	r2, #8
 8022410:	721a      	strb	r2, [r3, #8]
			}
			break;
 8022412:	e072      	b.n	80224fa <token_run+0x33e>

		case '/':
			ch = token_next_char(self);
 8022414:	6878      	ldr	r0, [r7, #4]
 8022416:	f7ff fe85 	bl	8022124 <token_next_char>
 802241a:	4603      	mov	r3, r0
 802241c:	73fb      	strb	r3, [r7, #15]
			if (ch == '/')
 802241e:	7bfb      	ldrb	r3, [r7, #15]
 8022420:	2b2f      	cmp	r3, #47	; 0x2f
 8022422:	d103      	bne.n	802242c <token_run+0x270>
			{
				/* line comments, set to end of file */
				self->current_token = finsh_token_type_eof;
 8022424:	687b      	ldr	r3, [r7, #4]
 8022426:	2221      	movs	r2, #33	; 0x21
 8022428:	721a      	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_div;
			}
			break;
 802242a:	e066      	b.n	80224fa <token_run+0x33e>
				/* line comments, set to end of file */
				self->current_token = finsh_token_type_eof;
			}
			else
			{
				token_prev_char(self);
 802242c:	6878      	ldr	r0, [r7, #4]
 802242e:	f7ff fead 	bl	802218c <token_prev_char>
				self->current_token = finsh_token_type_div;
 8022432:	687b      	ldr	r3, [r7, #4]
 8022434:	220a      	movs	r2, #10
 8022436:	721a      	strb	r2, [r3, #8]
			}
			break;
 8022438:	e05f      	b.n	80224fa <token_run+0x33e>

		case '<':
			ch = token_next_char(self);
 802243a:	6878      	ldr	r0, [r7, #4]
 802243c:	f7ff fe72 	bl	8022124 <token_next_char>
 8022440:	4603      	mov	r3, r0
 8022442:	73fb      	strb	r3, [r7, #15]

			if ( ch == '<' )
 8022444:	7bfb      	ldrb	r3, [r7, #15]
 8022446:	2b3c      	cmp	r3, #60	; 0x3c
 8022448:	d103      	bne.n	8022452 <token_run+0x296>
			{
				self->current_token = finsh_token_type_shl;
 802244a:	687b      	ldr	r3, [r7, #4]
 802244c:	2211      	movs	r2, #17
 802244e:	721a      	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_bad;
			}
			break;
 8022450:	e053      	b.n	80224fa <token_run+0x33e>
			{
				self->current_token = finsh_token_type_shl;
			}
			else
			{
				token_prev_char(self);
 8022452:	6878      	ldr	r0, [r7, #4]
 8022454:	f7ff fe9a 	bl	802218c <token_prev_char>
				self->current_token = finsh_token_type_bad;
 8022458:	687b      	ldr	r3, [r7, #4]
 802245a:	2220      	movs	r2, #32
 802245c:	721a      	strb	r2, [r3, #8]
			}
			break;
 802245e:	e04c      	b.n	80224fa <token_run+0x33e>

		case '>':
			ch = token_next_char(self);
 8022460:	6878      	ldr	r0, [r7, #4]
 8022462:	f7ff fe5f 	bl	8022124 <token_next_char>
 8022466:	4603      	mov	r3, r0
 8022468:	73fb      	strb	r3, [r7, #15]

			if ( ch == '>' )
 802246a:	7bfb      	ldrb	r3, [r7, #15]
 802246c:	2b3e      	cmp	r3, #62	; 0x3e
 802246e:	d103      	bne.n	8022478 <token_run+0x2bc>
			{
				self->current_token = finsh_token_type_shr;
 8022470:	687b      	ldr	r3, [r7, #4]
 8022472:	2212      	movs	r2, #18
 8022474:	721a      	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_bad;
			}
			break;
 8022476:	e040      	b.n	80224fa <token_run+0x33e>
			{
				self->current_token = finsh_token_type_shr;
			}
			else
			{
				token_prev_char(self);
 8022478:	6878      	ldr	r0, [r7, #4]
 802247a:	f7ff fe87 	bl	802218c <token_prev_char>
				self->current_token = finsh_token_type_bad;
 802247e:	687b      	ldr	r3, [r7, #4]
 8022480:	2220      	movs	r2, #32
 8022482:	721a      	strb	r2, [r3, #8]
			}
			break;
 8022484:	e039      	b.n	80224fa <token_run+0x33e>

		case '|':
			self->current_token = finsh_token_type_or;
 8022486:	687b      	ldr	r3, [r7, #4]
 8022488:	220e      	movs	r2, #14
 802248a:	721a      	strb	r2, [r3, #8]
			break;
 802248c:	e035      	b.n	80224fa <token_run+0x33e>

		case '%':
			self->current_token = finsh_token_type_mod;
 802248e:	687b      	ldr	r3, [r7, #4]
 8022490:	220b      	movs	r2, #11
 8022492:	721a      	strb	r2, [r3, #8]
			break;
 8022494:	e031      	b.n	80224fa <token_run+0x33e>

		case '~':
			self->current_token = finsh_token_type_bitwise;
 8022496:	687b      	ldr	r3, [r7, #4]
 8022498:	2210      	movs	r2, #16
 802249a:	721a      	strb	r2, [r3, #8]
			break;
 802249c:	e02d      	b.n	80224fa <token_run+0x33e>

		case '^':
			self->current_token = finsh_token_type_xor;
 802249e:	687b      	ldr	r3, [r7, #4]
 80224a0:	220f      	movs	r2, #15
 80224a2:	721a      	strb	r2, [r3, #8]
			break;
 80224a4:	e029      	b.n	80224fa <token_run+0x33e>

		case '=':
			self->current_token = finsh_token_type_assign;
 80224a6:	687b      	ldr	r3, [r7, #4]
 80224a8:	220c      	movs	r2, #12
 80224aa:	721a      	strb	r2, [r3, #8]
			break;
 80224ac:	e025      	b.n	80224fa <token_run+0x33e>

		case '\'':
			self->value.char_value = token_proc_char(self);
 80224ae:	6878      	ldr	r0, [r7, #4]
 80224b0:	f000 f868 	bl	8022584 <token_proc_char>
 80224b4:	4603      	mov	r3, r0
 80224b6:	461a      	mov	r2, r3
 80224b8:	687b      	ldr	r3, [r7, #4]
 80224ba:	731a      	strb	r2, [r3, #12]
			self->current_token = finsh_token_type_value_char;
 80224bc:	687b      	ldr	r3, [r7, #4]
 80224be:	221a      	movs	r2, #26
 80224c0:	721a      	strb	r2, [r3, #8]
			break;
 80224c2:	e01a      	b.n	80224fa <token_run+0x33e>

		case '"':
			token_proc_string(self);
 80224c4:	6878      	ldr	r0, [r7, #4]
 80224c6:	f000 f8c9 	bl	802265c <token_proc_string>
			self->current_token = finsh_token_type_value_string;
 80224ca:	687b      	ldr	r3, [r7, #4]
 80224cc:	221d      	movs	r2, #29
 80224ce:	721a      	strb	r2, [r3, #8]
			break;
 80224d0:	e013      	b.n	80224fa <token_run+0x33e>

		default:
			if ( is_digit(ch) )
 80224d2:	7bfb      	ldrb	r3, [r7, #15]
 80224d4:	2b2f      	cmp	r3, #47	; 0x2f
 80224d6:	d909      	bls.n	80224ec <token_run+0x330>
 80224d8:	7bfb      	ldrb	r3, [r7, #15]
 80224da:	2b39      	cmp	r3, #57	; 0x39
 80224dc:	d806      	bhi.n	80224ec <token_run+0x330>
			{
				token_prev_char(self);
 80224de:	6878      	ldr	r0, [r7, #4]
 80224e0:	f7ff fe54 	bl	802218c <token_prev_char>
				token_proc_number(self);
 80224e4:	6878      	ldr	r0, [r7, #4]
 80224e6:	f000 f983 	bl	80227f0 <token_proc_number>
				break;
 80224ea:	e006      	b.n	80224fa <token_run+0x33e>
			}

			finsh_error_set(FINSH_ERROR_UNKNOWN_TOKEN);
 80224ec:	200b      	movs	r0, #11
 80224ee:	f7fd fa8b 	bl	801fa08 <finsh_error_set>
			self->current_token = finsh_token_type_bad;
 80224f2:	687b      	ldr	r3, [r7, #4]
 80224f4:	2220      	movs	r2, #32
 80224f6:	721a      	strb	r2, [r3, #8]

			break;
 80224f8:	bf00      	nop
		}
	}
}
 80224fa:	3710      	adds	r7, #16
 80224fc:	46bd      	mov	sp, r7
 80224fe:	bd80      	pop	{r7, pc}

08022500 <token_match_name>:

static int token_match_name(struct finsh_token* self, const char* str)
{
 8022500:	b580      	push	{r7, lr}
 8022502:	b084      	sub	sp, #16
 8022504:	af00      	add	r7, sp, #0
 8022506:	6078      	str	r0, [r7, #4]
 8022508:	6039      	str	r1, [r7, #0]
	int i;

	for (i = 0; i < sizeof(finsh_name_table)/sizeof(struct name_table); i++)
 802250a:	2300      	movs	r3, #0
 802250c:	60fb      	str	r3, [r7, #12]
 802250e:	e016      	b.n	802253e <token_match_name+0x3e>
	{
		if ( strcmp(finsh_name_table[i].name, str)==0 )
 8022510:	4a0f      	ldr	r2, [pc, #60]	; (8022550 <token_match_name+0x50>)
 8022512:	68fb      	ldr	r3, [r7, #12]
 8022514:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8022518:	4618      	mov	r0, r3
 802251a:	6839      	ldr	r1, [r7, #0]
 802251c:	f7dd ff84 	bl	8000428 <strcmp>
 8022520:	4603      	mov	r3, r0
 8022522:	2b00      	cmp	r3, #0
 8022524:	d108      	bne.n	8022538 <token_match_name+0x38>
		{
			self->current_token = finsh_name_table[i].type;
 8022526:	4a0a      	ldr	r2, [pc, #40]	; (8022550 <token_match_name+0x50>)
 8022528:	68fb      	ldr	r3, [r7, #12]
 802252a:	00db      	lsls	r3, r3, #3
 802252c:	4413      	add	r3, r2
 802252e:	791a      	ldrb	r2, [r3, #4]
 8022530:	687b      	ldr	r3, [r7, #4]
 8022532:	721a      	strb	r2, [r3, #8]
			return 1;
 8022534:	2301      	movs	r3, #1
 8022536:	e006      	b.n	8022546 <token_match_name+0x46>

static int token_match_name(struct finsh_token* self, const char* str)
{
	int i;

	for (i = 0; i < sizeof(finsh_name_table)/sizeof(struct name_table); i++)
 8022538:	68fb      	ldr	r3, [r7, #12]
 802253a:	3301      	adds	r3, #1
 802253c:	60fb      	str	r3, [r7, #12]
 802253e:	68fb      	ldr	r3, [r7, #12]
 8022540:	2b07      	cmp	r3, #7
 8022542:	d9e5      	bls.n	8022510 <token_match_name+0x10>
			self->current_token = finsh_name_table[i].type;
			return 1;
		}
	}

	return 0;
 8022544:	2300      	movs	r3, #0
}
 8022546:	4618      	mov	r0, r3
 8022548:	3710      	adds	r7, #16
 802254a:	46bd      	mov	sp, r7
 802254c:	bd80      	pop	{r7, pc}
 802254e:	bf00      	nop
 8022550:	08029c74 	.word	0x08029c74

08022554 <token_trim_space>:

static void token_trim_space(struct finsh_token* self)
{
 8022554:	b580      	push	{r7, lr}
 8022556:	b084      	sub	sp, #16
 8022558:	af00      	add	r7, sp, #0
 802255a:	6078      	str	r0, [r7, #4]
	char ch;
	while ( (ch = token_next_char(self)) ==' ' || 
 802255c:	6878      	ldr	r0, [r7, #4]
 802255e:	f7ff fde1 	bl	8022124 <token_next_char>
 8022562:	4603      	mov	r3, r0
 8022564:	73fb      	strb	r3, [r7, #15]
 8022566:	7bfb      	ldrb	r3, [r7, #15]
 8022568:	2b20      	cmp	r3, #32
 802256a:	d0f7      	beq.n	802255c <token_trim_space+0x8>
 802256c:	7bfb      	ldrb	r3, [r7, #15]
 802256e:	2b09      	cmp	r3, #9
 8022570:	d0f4      	beq.n	802255c <token_trim_space+0x8>
        ch == '\t' || 
 8022572:	7bfb      	ldrb	r3, [r7, #15]
 8022574:	2b0d      	cmp	r3, #13
 8022576:	d0f1      	beq.n	802255c <token_trim_space+0x8>
        ch == '\r');

	token_prev_char(self);
 8022578:	6878      	ldr	r0, [r7, #4]
 802257a:	f7ff fe07 	bl	802218c <token_prev_char>
}
 802257e:	3710      	adds	r7, #16
 8022580:	46bd      	mov	sp, r7
 8022582:	bd80      	pop	{r7, pc}

08022584 <token_proc_char>:

static char token_proc_char(struct finsh_token* self)
{
 8022584:	b580      	push	{r7, lr}
 8022586:	b086      	sub	sp, #24
 8022588:	af00      	add	r7, sp, #0
 802258a:	6078      	str	r0, [r7, #4]
	char ch;
	char buf[4], *p;

	p = buf;
 802258c:	f107 030c 	add.w	r3, r7, #12
 8022590:	613b      	str	r3, [r7, #16]
	ch = token_next_char(self);
 8022592:	6878      	ldr	r0, [r7, #4]
 8022594:	f7ff fdc6 	bl	8022124 <token_next_char>
 8022598:	4603      	mov	r3, r0
 802259a:	75fb      	strb	r3, [r7, #23]

	if ( ch == '\\' )
 802259c:	7dfb      	ldrb	r3, [r7, #23]
 802259e:	2b5c      	cmp	r3, #92	; 0x5c
 80225a0:	d149      	bne.n	8022636 <token_proc_char+0xb2>
	{
		ch = token_next_char(self);
 80225a2:	6878      	ldr	r0, [r7, #4]
 80225a4:	f7ff fdbe 	bl	8022124 <token_next_char>
 80225a8:	4603      	mov	r3, r0
 80225aa:	75fb      	strb	r3, [r7, #23]
		switch ( ch )
 80225ac:	7dfb      	ldrb	r3, [r7, #23]
 80225ae:	2b6e      	cmp	r3, #110	; 0x6e
 80225b0:	d00f      	beq.n	80225d2 <token_proc_char+0x4e>
 80225b2:	2b6e      	cmp	r3, #110	; 0x6e
 80225b4:	dc06      	bgt.n	80225c4 <token_proc_char+0x40>
 80225b6:	2b5c      	cmp	r3, #92	; 0x5c
 80225b8:	d01a      	beq.n	80225f0 <token_proc_char+0x6c>
 80225ba:	2b62      	cmp	r3, #98	; 0x62
 80225bc:	d012      	beq.n	80225e4 <token_proc_char+0x60>
 80225be:	2b27      	cmp	r3, #39	; 0x27
 80225c0:	d019      	beq.n	80225f6 <token_proc_char+0x72>
 80225c2:	e01b      	b.n	80225fc <token_proc_char+0x78>
 80225c4:	2b74      	cmp	r3, #116	; 0x74
 80225c6:	d007      	beq.n	80225d8 <token_proc_char+0x54>
 80225c8:	2b76      	cmp	r3, #118	; 0x76
 80225ca:	d008      	beq.n	80225de <token_proc_char+0x5a>
 80225cc:	2b72      	cmp	r3, #114	; 0x72
 80225ce:	d00c      	beq.n	80225ea <token_proc_char+0x66>
 80225d0:	e014      	b.n	80225fc <token_proc_char+0x78>
		{
		case 'n': ch = '\n'; break;
 80225d2:	230a      	movs	r3, #10
 80225d4:	75fb      	strb	r3, [r7, #23]
 80225d6:	e02e      	b.n	8022636 <token_proc_char+0xb2>
		case 't': ch = '\t'; break;
 80225d8:	2309      	movs	r3, #9
 80225da:	75fb      	strb	r3, [r7, #23]
 80225dc:	e02b      	b.n	8022636 <token_proc_char+0xb2>
		case 'v': ch = '\v'; break;
 80225de:	230b      	movs	r3, #11
 80225e0:	75fb      	strb	r3, [r7, #23]
 80225e2:	e028      	b.n	8022636 <token_proc_char+0xb2>
		case 'b': ch = '\b'; break;
 80225e4:	2308      	movs	r3, #8
 80225e6:	75fb      	strb	r3, [r7, #23]
 80225e8:	e025      	b.n	8022636 <token_proc_char+0xb2>
		case 'r': ch = '\r'; break;
 80225ea:	230d      	movs	r3, #13
 80225ec:	75fb      	strb	r3, [r7, #23]
 80225ee:	e022      	b.n	8022636 <token_proc_char+0xb2>
		case '\\': ch = '\\';  break;
 80225f0:	235c      	movs	r3, #92	; 0x5c
 80225f2:	75fb      	strb	r3, [r7, #23]
 80225f4:	e01f      	b.n	8022636 <token_proc_char+0xb2>
		case '\'': ch = '\'';  break;
 80225f6:	2327      	movs	r3, #39	; 0x27
 80225f8:	75fb      	strb	r3, [r7, #23]
 80225fa:	e01c      	b.n	8022636 <token_proc_char+0xb2>
		default :
			while ( is_digit(ch) )/*for '\113' char*/
 80225fc:	e009      	b.n	8022612 <token_proc_char+0x8e>
			{
				ch = token_next_char(self);
 80225fe:	6878      	ldr	r0, [r7, #4]
 8022600:	f7ff fd90 	bl	8022124 <token_next_char>
 8022604:	4603      	mov	r3, r0
 8022606:	75fb      	strb	r3, [r7, #23]
				*p++ = ch;
 8022608:	693b      	ldr	r3, [r7, #16]
 802260a:	1c5a      	adds	r2, r3, #1
 802260c:	613a      	str	r2, [r7, #16]
 802260e:	7dfa      	ldrb	r2, [r7, #23]
 8022610:	701a      	strb	r2, [r3, #0]
		case 'b': ch = '\b'; break;
		case 'r': ch = '\r'; break;
		case '\\': ch = '\\';  break;
		case '\'': ch = '\'';  break;
		default :
			while ( is_digit(ch) )/*for '\113' char*/
 8022612:	7dfb      	ldrb	r3, [r7, #23]
 8022614:	2b2f      	cmp	r3, #47	; 0x2f
 8022616:	d902      	bls.n	802261e <token_proc_char+0x9a>
 8022618:	7dfb      	ldrb	r3, [r7, #23]
 802261a:	2b39      	cmp	r3, #57	; 0x39
 802261c:	d9ef      	bls.n	80225fe <token_proc_char+0x7a>
			{
				ch = token_next_char(self);
				*p++ = ch;
			}

			token_prev_char(self);
 802261e:	6878      	ldr	r0, [r7, #4]
 8022620:	f7ff fdb4 	bl	802218c <token_prev_char>
			*p = '\0';
 8022624:	693b      	ldr	r3, [r7, #16]
 8022626:	2200      	movs	r2, #0
 8022628:	701a      	strb	r2, [r3, #0]
			ch = atoi(p);
 802262a:	6938      	ldr	r0, [r7, #16]
 802262c:	f000 fa5a 	bl	8022ae4 <atoi>
 8022630:	4603      	mov	r3, r0
 8022632:	75fb      	strb	r3, [r7, #23]
			break;
 8022634:	bf00      	nop
		}
	}

	if ( token_next_char(self) != '\'' )
 8022636:	6878      	ldr	r0, [r7, #4]
 8022638:	f7ff fd74 	bl	8022124 <token_next_char>
 802263c:	4603      	mov	r3, r0
 802263e:	2b27      	cmp	r3, #39	; 0x27
 8022640:	d007      	beq.n	8022652 <token_proc_char+0xce>
	{
		token_prev_char(self);
 8022642:	6878      	ldr	r0, [r7, #4]
 8022644:	f7ff fda2 	bl	802218c <token_prev_char>
		finsh_error_set(FINSH_ERROR_EXPECT_CHAR);
 8022648:	2009      	movs	r0, #9
 802264a:	f7fd f9dd 	bl	801fa08 <finsh_error_set>
		return ch;
 802264e:	7dfb      	ldrb	r3, [r7, #23]
 8022650:	e000      	b.n	8022654 <token_proc_char+0xd0>
	}

	return ch;
 8022652:	7dfb      	ldrb	r3, [r7, #23]
}
 8022654:	4618      	mov	r0, r3
 8022656:	3718      	adds	r7, #24
 8022658:	46bd      	mov	sp, r7
 802265a:	bd80      	pop	{r7, pc}

0802265c <token_proc_string>:

static u_char* token_proc_string(struct finsh_token* self)
{
 802265c:	b580      	push	{r7, lr}
 802265e:	b084      	sub	sp, #16
 8022660:	af00      	add	r7, sp, #0
 8022662:	6078      	str	r0, [r7, #4]
	u_char* p;

	for ( p = &self->string[0]; p - &(self->string[0]) < FINSH_STRING_MAX; )
 8022664:	687b      	ldr	r3, [r7, #4]
 8022666:	3310      	adds	r3, #16
 8022668:	60fb      	str	r3, [r7, #12]
 802266a:	e024      	b.n	80226b6 <token_proc_string+0x5a>
	{
		char ch = token_next_char(self);
 802266c:	6878      	ldr	r0, [r7, #4]
 802266e:	f7ff fd59 	bl	8022124 <token_next_char>
 8022672:	4603      	mov	r3, r0
 8022674:	72fb      	strb	r3, [r7, #11]

		if ( is_eof(self) )
 8022676:	687b      	ldr	r3, [r7, #4]
 8022678:	781b      	ldrb	r3, [r3, #0]
 802267a:	2b00      	cmp	r3, #0
 802267c:	d004      	beq.n	8022688 <token_proc_string+0x2c>
		{
			finsh_error_set(FINSH_ERROR_UNEXPECT_END);
 802267e:	200a      	movs	r0, #10
 8022680:	f7fd f9c2 	bl	801fa08 <finsh_error_set>
			return NULL;;
 8022684:	2300      	movs	r3, #0
 8022686:	e01d      	b.n	80226c4 <token_proc_string+0x68>
		}
		if ( ch == '\\' )
 8022688:	7afb      	ldrb	r3, [r7, #11]
 802268a:	2b5c      	cmp	r3, #92	; 0x5c
 802268c:	d105      	bne.n	802269a <token_proc_string+0x3e>
		{
			ch = token_proc_escape(self);
 802268e:	6878      	ldr	r0, [r7, #4]
 8022690:	f000 f81c 	bl	80226cc <token_proc_escape>
 8022694:	4603      	mov	r3, r0
 8022696:	72fb      	strb	r3, [r7, #11]
 8022698:	e008      	b.n	80226ac <token_proc_string+0x50>
		}
		else if ( ch == '"' )/*end of string.*/
 802269a:	7afb      	ldrb	r3, [r7, #11]
 802269c:	2b22      	cmp	r3, #34	; 0x22
 802269e:	d105      	bne.n	80226ac <token_proc_string+0x50>
		{
			*p = '\0';
 80226a0:	68fb      	ldr	r3, [r7, #12]
 80226a2:	2200      	movs	r2, #0
 80226a4:	701a      	strb	r2, [r3, #0]
			return self->string;
 80226a6:	687b      	ldr	r3, [r7, #4]
 80226a8:	3310      	adds	r3, #16
 80226aa:	e00b      	b.n	80226c4 <token_proc_string+0x68>
		}

		*p++ = ch;
 80226ac:	68fb      	ldr	r3, [r7, #12]
 80226ae:	1c5a      	adds	r2, r3, #1
 80226b0:	60fa      	str	r2, [r7, #12]
 80226b2:	7afa      	ldrb	r2, [r7, #11]
 80226b4:	701a      	strb	r2, [r3, #0]

static u_char* token_proc_string(struct finsh_token* self)
{
	u_char* p;

	for ( p = &self->string[0]; p - &(self->string[0]) < FINSH_STRING_MAX; )
 80226b6:	68fb      	ldr	r3, [r7, #12]
 80226b8:	687a      	ldr	r2, [r7, #4]
 80226ba:	3210      	adds	r2, #16
 80226bc:	1a9b      	subs	r3, r3, r2
 80226be:	2b7f      	cmp	r3, #127	; 0x7f
 80226c0:	ddd4      	ble.n	802266c <token_proc_string+0x10>
		}

		*p++ = ch;
	}

	return NULL;
 80226c2:	2300      	movs	r3, #0
}
 80226c4:	4618      	mov	r0, r3
 80226c6:	3710      	adds	r7, #16
 80226c8:	46bd      	mov	sp, r7
 80226ca:	bd80      	pop	{r7, pc}

080226cc <token_proc_escape>:

static int token_proc_escape(struct finsh_token* self)
{
 80226cc:	b580      	push	{r7, lr}
 80226ce:	b084      	sub	sp, #16
 80226d0:	af00      	add	r7, sp, #0
 80226d2:	6078      	str	r0, [r7, #4]
	char ch;
	int result=0;
 80226d4:	2300      	movs	r3, #0
 80226d6:	60bb      	str	r3, [r7, #8]

	ch = token_next_char(self);
 80226d8:	6878      	ldr	r0, [r7, #4]
 80226da:	f7ff fd23 	bl	8022124 <token_next_char>
 80226de:	4603      	mov	r3, r0
 80226e0:	73fb      	strb	r3, [r7, #15]
	switch (ch)
 80226e2:	7bfb      	ldrb	r3, [r7, #15]
 80226e4:	3b61      	subs	r3, #97	; 0x61
 80226e6:	2b17      	cmp	r3, #23
 80226e8:	d862      	bhi.n	80227b0 <token_proc_escape+0xe4>
 80226ea:	a201      	add	r2, pc, #4	; (adr r2, 80226f0 <token_proc_escape+0x24>)
 80226ec:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80226f0:	08022775 	.word	0x08022775
 80226f4:	08022763 	.word	0x08022763
 80226f8:	080227b1 	.word	0x080227b1
 80226fc:	080227b1 	.word	0x080227b1
 8022700:	080227b1 	.word	0x080227b1
 8022704:	0802276f 	.word	0x0802276f
 8022708:	080227b1 	.word	0x080227b1
 802270c:	080227b1 	.word	0x080227b1
 8022710:	080227b1 	.word	0x080227b1
 8022714:	080227b1 	.word	0x080227b1
 8022718:	080227b1 	.word	0x080227b1
 802271c:	080227b1 	.word	0x080227b1
 8022720:	080227b1 	.word	0x080227b1
 8022724:	08022751 	.word	0x08022751
 8022728:	080227b1 	.word	0x080227b1
 802272c:	080227b1 	.word	0x080227b1
 8022730:	080227b1 	.word	0x080227b1
 8022734:	08022769 	.word	0x08022769
 8022738:	080227b1 	.word	0x080227b1
 802273c:	08022757 	.word	0x08022757
 8022740:	080227b1 	.word	0x080227b1
 8022744:	0802275d 	.word	0x0802275d
 8022748:	080227b1 	.word	0x080227b1
 802274c:	0802277b 	.word	0x0802277b
	{
	case 'n':
		result = '\n';
 8022750:	230a      	movs	r3, #10
 8022752:	60bb      	str	r3, [r7, #8]
		break;
 8022754:	e047      	b.n	80227e6 <token_proc_escape+0x11a>
	case 't':
		result = '\t';
 8022756:	2309      	movs	r3, #9
 8022758:	60bb      	str	r3, [r7, #8]
		break;
 802275a:	e044      	b.n	80227e6 <token_proc_escape+0x11a>
	case 'v':
		result = '\v';
 802275c:	230b      	movs	r3, #11
 802275e:	60bb      	str	r3, [r7, #8]
		break;
 8022760:	e041      	b.n	80227e6 <token_proc_escape+0x11a>
	case 'b':
		result = '\b';
 8022762:	2308      	movs	r3, #8
 8022764:	60bb      	str	r3, [r7, #8]
		break;
 8022766:	e03e      	b.n	80227e6 <token_proc_escape+0x11a>
	case 'r':
		result = '\r';
 8022768:	230d      	movs	r3, #13
 802276a:	60bb      	str	r3, [r7, #8]
		break;
 802276c:	e03b      	b.n	80227e6 <token_proc_escape+0x11a>
	case 'f':
		result = '\f';
 802276e:	230c      	movs	r3, #12
 8022770:	60bb      	str	r3, [r7, #8]
		break;
 8022772:	e038      	b.n	80227e6 <token_proc_escape+0x11a>
	case 'a':
		result = '\007';
 8022774:	2307      	movs	r3, #7
 8022776:	60bb      	str	r3, [r7, #8]
		break;
 8022778:	e035      	b.n	80227e6 <token_proc_escape+0x11a>
	case 'x':
		result = 0;
 802277a:	2300      	movs	r3, #0
 802277c:	60bb      	str	r3, [r7, #8]
		ch  = token_next_char(self);
 802277e:	6878      	ldr	r0, [r7, #4]
 8022780:	f7ff fcd0 	bl	8022124 <token_next_char>
 8022784:	4603      	mov	r3, r0
 8022786:	73fb      	strb	r3, [r7, #15]
		while ( (ch - '0')<16u )
 8022788:	e00a      	b.n	80227a0 <token_proc_escape+0xd4>
		{
			result = result*16 + ch - '0';
 802278a:	68bb      	ldr	r3, [r7, #8]
 802278c:	011a      	lsls	r2, r3, #4
 802278e:	7bfb      	ldrb	r3, [r7, #15]
 8022790:	4413      	add	r3, r2
 8022792:	3b30      	subs	r3, #48	; 0x30
 8022794:	60bb      	str	r3, [r7, #8]
			ch = token_next_char(self);
 8022796:	6878      	ldr	r0, [r7, #4]
 8022798:	f7ff fcc4 	bl	8022124 <token_next_char>
 802279c:	4603      	mov	r3, r0
 802279e:	73fb      	strb	r3, [r7, #15]
		result = '\007';
		break;
	case 'x':
		result = 0;
		ch  = token_next_char(self);
		while ( (ch - '0')<16u )
 80227a0:	7bfb      	ldrb	r3, [r7, #15]
 80227a2:	3b30      	subs	r3, #48	; 0x30
 80227a4:	2b0f      	cmp	r3, #15
 80227a6:	d9f0      	bls.n	802278a <token_proc_escape+0xbe>
		{
			result = result*16 + ch - '0';
			ch = token_next_char(self);
		}
		token_prev_char(self);
 80227a8:	6878      	ldr	r0, [r7, #4]
 80227aa:	f7ff fcef 	bl	802218c <token_prev_char>
		break;
 80227ae:	e01a      	b.n	80227e6 <token_proc_escape+0x11a>
	default:
		if ( (ch - '0') < 8u)
 80227b0:	7bfb      	ldrb	r3, [r7, #15]
 80227b2:	3b30      	subs	r3, #48	; 0x30
 80227b4:	2b07      	cmp	r3, #7
 80227b6:	d815      	bhi.n	80227e4 <token_proc_escape+0x118>
		{
			result = 0;
 80227b8:	2300      	movs	r3, #0
 80227ba:	60bb      	str	r3, [r7, #8]
			while ( (ch - '0') < 8u )
 80227bc:	e00a      	b.n	80227d4 <token_proc_escape+0x108>
			{
				result = result*8 + ch - '0';
 80227be:	68bb      	ldr	r3, [r7, #8]
 80227c0:	00da      	lsls	r2, r3, #3
 80227c2:	7bfb      	ldrb	r3, [r7, #15]
 80227c4:	4413      	add	r3, r2
 80227c6:	3b30      	subs	r3, #48	; 0x30
 80227c8:	60bb      	str	r3, [r7, #8]
				ch = token_next_char(self);
 80227ca:	6878      	ldr	r0, [r7, #4]
 80227cc:	f7ff fcaa 	bl	8022124 <token_next_char>
 80227d0:	4603      	mov	r3, r0
 80227d2:	73fb      	strb	r3, [r7, #15]
		break;
	default:
		if ( (ch - '0') < 8u)
		{
			result = 0;
			while ( (ch - '0') < 8u )
 80227d4:	7bfb      	ldrb	r3, [r7, #15]
 80227d6:	3b30      	subs	r3, #48	; 0x30
 80227d8:	2b07      	cmp	r3, #7
 80227da:	d9f0      	bls.n	80227be <token_proc_escape+0xf2>
			{
				result = result*8 + ch - '0';
				ch = token_next_char(self);
			}

			token_prev_char(self);
 80227dc:	6878      	ldr	r0, [r7, #4]
 80227de:	f7ff fcd5 	bl	802218c <token_prev_char>
		}
		break;
 80227e2:	e7ff      	b.n	80227e4 <token_proc_escape+0x118>
 80227e4:	bf00      	nop
	}

	return result;
 80227e6:	68bb      	ldr	r3, [r7, #8]
}
 80227e8:	4618      	mov	r0, r3
 80227ea:	3710      	adds	r7, #16
 80227ec:	46bd      	mov	sp, r7
 80227ee:	bd80      	pop	{r7, pc}

080227f0 <token_proc_number>:

/*
(0|0x|0X|0b|0B)number+(l|L)
*/
static void token_proc_number(struct finsh_token* self)
{
 80227f0:	b580      	push	{r7, lr}
 80227f2:	b0a6      	sub	sp, #152	; 0x98
 80227f4:	af00      	add	r7, sp, #0
 80227f6:	6078      	str	r0, [r7, #4]
	char ch;
	char *p, buf[128];
	long value;

	value = 0;
 80227f8:	2300      	movs	r3, #0
 80227fa:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
	p = buf;
 80227fe:	f107 0308 	add.w	r3, r7, #8
 8022802:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

	ch  = token_next_char(self);
 8022806:	6878      	ldr	r0, [r7, #4]
 8022808:	f7ff fc8c 	bl	8022124 <token_next_char>
 802280c:	4603      	mov	r3, r0
 802280e:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
	if ( ch == '0' )
 8022812:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 8022816:	2b30      	cmp	r3, #48	; 0x30
 8022818:	f040 80af 	bne.w	802297a <token_proc_number+0x18a>
	{
		int b;
		ch = token_next_char(self);
 802281c:	6878      	ldr	r0, [r7, #4]
 802281e:	f7ff fc81 	bl	8022124 <token_next_char>
 8022822:	4603      	mov	r3, r0
 8022824:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
		if ( ch == 'x' || ch == 'X' )/*it's a hex number*/
 8022828:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 802282c:	2b78      	cmp	r3, #120	; 0x78
 802282e:	d003      	beq.n	8022838 <token_proc_number+0x48>
 8022830:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 8022834:	2b58      	cmp	r3, #88	; 0x58
 8022836:	d12c      	bne.n	8022892 <token_proc_number+0xa2>
		{
			b = 16;
 8022838:	2310      	movs	r3, #16
 802283a:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
			ch = token_next_char(self);
 802283e:	6878      	ldr	r0, [r7, #4]
 8022840:	f7ff fc70 	bl	8022124 <token_next_char>
 8022844:	4603      	mov	r3, r0
 8022846:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
			while ( is_digit(ch) || is_alpha(ch) )
 802284a:	e00d      	b.n	8022868 <token_proc_number+0x78>
			{
				*p++ = ch;
 802284c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8022850:	1c5a      	adds	r2, r3, #1
 8022852:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
 8022856:	f897 2097 	ldrb.w	r2, [r7, #151]	; 0x97
 802285a:	701a      	strb	r2, [r3, #0]
				ch = token_next_char(self);
 802285c:	6878      	ldr	r0, [r7, #4]
 802285e:	f7ff fc61 	bl	8022124 <token_next_char>
 8022862:	4603      	mov	r3, r0
 8022864:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
		ch = token_next_char(self);
		if ( ch == 'x' || ch == 'X' )/*it's a hex number*/
		{
			b = 16;
			ch = token_next_char(self);
			while ( is_digit(ch) || is_alpha(ch) )
 8022868:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 802286c:	2b2f      	cmp	r3, #47	; 0x2f
 802286e:	d903      	bls.n	8022878 <token_proc_number+0x88>
 8022870:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 8022874:	2b39      	cmp	r3, #57	; 0x39
 8022876:	d9e9      	bls.n	802284c <token_proc_number+0x5c>
 8022878:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 802287c:	f043 0320 	orr.w	r3, r3, #32
 8022880:	b2db      	uxtb	r3, r3
 8022882:	3b61      	subs	r3, #97	; 0x61
 8022884:	2b19      	cmp	r3, #25
 8022886:	d9e1      	bls.n	802284c <token_proc_number+0x5c>
			{
				*p++ = ch;
				ch = token_next_char(self);
			}

			*p = '\0';
 8022888:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 802288c:	2200      	movs	r2, #0
 802288e:	701a      	strb	r2, [r3, #0]
 8022890:	e05d      	b.n	802294e <token_proc_number+0x15e>
		}
		else if ( ch == 'b' || ch == 'B' )
 8022892:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 8022896:	2b62      	cmp	r3, #98	; 0x62
 8022898:	d003      	beq.n	80228a2 <token_proc_number+0xb2>
 802289a:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 802289e:	2b42      	cmp	r3, #66	; 0x42
 80228a0:	d124      	bne.n	80228ec <token_proc_number+0xfc>
		{
			b = 2;
 80228a2:	2302      	movs	r3, #2
 80228a4:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
			ch = token_next_char(self);
 80228a8:	6878      	ldr	r0, [r7, #4]
 80228aa:	f7ff fc3b 	bl	8022124 <token_next_char>
 80228ae:	4603      	mov	r3, r0
 80228b0:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
			while ( (ch=='0')||(ch=='1') )
 80228b4:	e00d      	b.n	80228d2 <token_proc_number+0xe2>
			{
				*p++ = ch;
 80228b6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80228ba:	1c5a      	adds	r2, r3, #1
 80228bc:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
 80228c0:	f897 2097 	ldrb.w	r2, [r7, #151]	; 0x97
 80228c4:	701a      	strb	r2, [r3, #0]
				ch = token_next_char(self);
 80228c6:	6878      	ldr	r0, [r7, #4]
 80228c8:	f7ff fc2c 	bl	8022124 <token_next_char>
 80228cc:	4603      	mov	r3, r0
 80228ce:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
		}
		else if ( ch == 'b' || ch == 'B' )
		{
			b = 2;
			ch = token_next_char(self);
			while ( (ch=='0')||(ch=='1') )
 80228d2:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 80228d6:	2b30      	cmp	r3, #48	; 0x30
 80228d8:	d0ed      	beq.n	80228b6 <token_proc_number+0xc6>
 80228da:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 80228de:	2b31      	cmp	r3, #49	; 0x31
 80228e0:	d0e9      	beq.n	80228b6 <token_proc_number+0xc6>
			{
				*p++ = ch;
				ch = token_next_char(self);
			}

			*p = '\0';
 80228e2:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80228e6:	2200      	movs	r2, #0
 80228e8:	701a      	strb	r2, [r3, #0]
 80228ea:	e030      	b.n	802294e <token_proc_number+0x15e>
		}
		else if ( '0' <= ch && ch <= '7' )
 80228ec:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 80228f0:	2b2f      	cmp	r3, #47	; 0x2f
 80228f2:	d922      	bls.n	802293a <token_proc_number+0x14a>
 80228f4:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 80228f8:	2b37      	cmp	r3, #55	; 0x37
 80228fa:	d81e      	bhi.n	802293a <token_proc_number+0x14a>
		{
			b = 8;
 80228fc:	2308      	movs	r3, #8
 80228fe:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
			while ( '0' <= ch && ch <= '7' )
 8022902:	e00d      	b.n	8022920 <token_proc_number+0x130>
			{
				*p++ = ch;
 8022904:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8022908:	1c5a      	adds	r2, r3, #1
 802290a:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
 802290e:	f897 2097 	ldrb.w	r2, [r7, #151]	; 0x97
 8022912:	701a      	strb	r2, [r3, #0]
				ch = token_next_char(self);
 8022914:	6878      	ldr	r0, [r7, #4]
 8022916:	f7ff fc05 	bl	8022124 <token_next_char>
 802291a:	4603      	mov	r3, r0
 802291c:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
			*p = '\0';
		}
		else if ( '0' <= ch && ch <= '7' )
		{
			b = 8;
			while ( '0' <= ch && ch <= '7' )
 8022920:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 8022924:	2b2f      	cmp	r3, #47	; 0x2f
 8022926:	d903      	bls.n	8022930 <token_proc_number+0x140>
 8022928:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 802292c:	2b37      	cmp	r3, #55	; 0x37
 802292e:	d9e9      	bls.n	8022904 <token_proc_number+0x114>
			{
				*p++ = ch;
				ch = token_next_char(self);
			}

			*p = '\0';
 8022930:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8022934:	2200      	movs	r2, #0
 8022936:	701a      	strb	r2, [r3, #0]
 8022938:	e009      	b.n	802294e <token_proc_number+0x15e>
		}
		else
		{
			token_prev_char(self);
 802293a:	6878      	ldr	r0, [r7, #4]
 802293c:	f7ff fc26 	bl	802218c <token_prev_char>

			/* made as 0 value */
			self->value.int_value = 0;
 8022940:	687b      	ldr	r3, [r7, #4]
 8022942:	2200      	movs	r2, #0
 8022944:	60da      	str	r2, [r3, #12]
			self->current_token = finsh_token_type_value_int;
 8022946:	687b      	ldr	r3, [r7, #4]
 8022948:	221b      	movs	r2, #27
 802294a:	721a      	strb	r2, [r3, #8]
			return;
 802294c:	e046      	b.n	80229dc <token_proc_number+0x1ec>
		}

		self->value.int_value = token_spec_number(buf, strlen(buf), b);
 802294e:	f107 0308 	add.w	r3, r7, #8
 8022952:	4618      	mov	r0, r3
 8022954:	f000 fea6 	bl	80236a4 <strlen>
 8022958:	4603      	mov	r3, r0
 802295a:	461a      	mov	r2, r3
 802295c:	f107 0308 	add.w	r3, r7, #8
 8022960:	4618      	mov	r0, r3
 8022962:	4611      	mov	r1, r2
 8022964:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 8022968:	f000 f83c 	bl	80229e4 <token_spec_number>
 802296c:	4602      	mov	r2, r0
 802296e:	687b      	ldr	r3, [r7, #4]
 8022970:	60da      	str	r2, [r3, #12]
		self->current_token = finsh_token_type_value_int;
 8022972:	687b      	ldr	r3, [r7, #4]
 8022974:	221b      	movs	r2, #27
 8022976:	721a      	strb	r2, [r3, #8]
 8022978:	e022      	b.n	80229c0 <token_proc_number+0x1d0>
	}
	else
	{
		while ( is_digit(ch) )
 802297a:	e012      	b.n	80229a2 <token_proc_number+0x1b2>
		{
			value = value*10 + ( ch - '0' );
 802297c:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 8022980:	4613      	mov	r3, r2
 8022982:	009b      	lsls	r3, r3, #2
 8022984:	4413      	add	r3, r2
 8022986:	005b      	lsls	r3, r3, #1
 8022988:	461a      	mov	r2, r3
 802298a:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 802298e:	3b30      	subs	r3, #48	; 0x30
 8022990:	4413      	add	r3, r2
 8022992:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
			ch = token_next_char(self);
 8022996:	6878      	ldr	r0, [r7, #4]
 8022998:	f7ff fbc4 	bl	8022124 <token_next_char>
 802299c:	4603      	mov	r3, r0
 802299e:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
		self->value.int_value = token_spec_number(buf, strlen(buf), b);
		self->current_token = finsh_token_type_value_int;
	}
	else
	{
		while ( is_digit(ch) )
 80229a2:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 80229a6:	2b2f      	cmp	r3, #47	; 0x2f
 80229a8:	d903      	bls.n	80229b2 <token_proc_number+0x1c2>
 80229aa:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 80229ae:	2b39      	cmp	r3, #57	; 0x39
 80229b0:	d9e4      	bls.n	802297c <token_proc_number+0x18c>
		{
			value = value*10 + ( ch - '0' );
			ch = token_next_char(self);
		}

		self->value.int_value = value;
 80229b2:	687b      	ldr	r3, [r7, #4]
 80229b4:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 80229b8:	60da      	str	r2, [r3, #12]
		self->current_token = finsh_token_type_value_int;
 80229ba:	687b      	ldr	r3, [r7, #4]
 80229bc:	221b      	movs	r2, #27
 80229be:	721a      	strb	r2, [r3, #8]
	}

	switch ( ch )
 80229c0:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 80229c4:	2b4c      	cmp	r3, #76	; 0x4c
 80229c6:	d001      	beq.n	80229cc <token_proc_number+0x1dc>
 80229c8:	2b6c      	cmp	r3, #108	; 0x6c
 80229ca:	d103      	bne.n	80229d4 <token_proc_number+0x1e4>
	{
	case 'l':
	case 'L':
		self->current_token = finsh_token_type_value_long;
 80229cc:	687b      	ldr	r3, [r7, #4]
 80229ce:	221c      	movs	r2, #28
 80229d0:	721a      	strb	r2, [r3, #8]
		break;
 80229d2:	e003      	b.n	80229dc <token_proc_number+0x1ec>

	default:
		token_prev_char(self);
 80229d4:	6878      	ldr	r0, [r7, #4]
 80229d6:	f7ff fbd9 	bl	802218c <token_prev_char>
		break;
 80229da:	bf00      	nop
	}
}
 80229dc:	3798      	adds	r7, #152	; 0x98
 80229de:	46bd      	mov	sp, r7
 80229e0:	bd80      	pop	{r7, pc}
 80229e2:	bf00      	nop

080229e4 <token_spec_number>:

/*use 64 bit number*/
#define BN_SIZE 2

static long token_spec_number(char* string, int length, int b)
{
 80229e4:	b480      	push	{r7}
 80229e6:	b08f      	sub	sp, #60	; 0x3c
 80229e8:	af00      	add	r7, sp, #0
 80229ea:	60f8      	str	r0, [r7, #12]
 80229ec:	60b9      	str	r1, [r7, #8]
 80229ee:	607a      	str	r2, [r7, #4]
	char* p;
	int t;
	int i, j, shift=1;
 80229f0:	2301      	movs	r3, #1
 80229f2:	627b      	str	r3, [r7, #36]	; 0x24
	unsigned int bn[BN_SIZE], v;
	long d;

	p = string;
 80229f4:	68fb      	ldr	r3, [r7, #12]
 80229f6:	637b      	str	r3, [r7, #52]	; 0x34
	i = 0;
 80229f8:	2300      	movs	r3, #0
 80229fa:	62fb      	str	r3, [r7, #44]	; 0x2c

	switch ( b )
 80229fc:	687b      	ldr	r3, [r7, #4]
 80229fe:	2b08      	cmp	r3, #8
 8022a00:	d007      	beq.n	8022a12 <token_spec_number+0x2e>
 8022a02:	2b10      	cmp	r3, #16
 8022a04:	d002      	beq.n	8022a0c <token_spec_number+0x28>
 8022a06:	2b02      	cmp	r3, #2
 8022a08:	d006      	beq.n	8022a18 <token_spec_number+0x34>
		break;
	case 8:  shift = 3;
		break;
	case 2:  shift = 1;
		break;
	default: break;
 8022a0a:	e008      	b.n	8022a1e <token_spec_number+0x3a>
	p = string;
	i = 0;

	switch ( b )
	{
	case 16: shift = 4;
 8022a0c:	2304      	movs	r3, #4
 8022a0e:	627b      	str	r3, [r7, #36]	; 0x24
		break;
 8022a10:	e005      	b.n	8022a1e <token_spec_number+0x3a>
	case 8:  shift = 3;
 8022a12:	2303      	movs	r3, #3
 8022a14:	627b      	str	r3, [r7, #36]	; 0x24
		break;
 8022a16:	e002      	b.n	8022a1e <token_spec_number+0x3a>
	case 2:  shift = 1;
 8022a18:	2301      	movs	r3, #1
 8022a1a:	627b      	str	r3, [r7, #36]	; 0x24
		break;
 8022a1c:	bf00      	nop
	default: break;
	}

	for ( j=0; j<BN_SIZE ; j++) bn[j] = 0;
 8022a1e:	2300      	movs	r3, #0
 8022a20:	62bb      	str	r3, [r7, #40]	; 0x28
 8022a22:	e00a      	b.n	8022a3a <token_spec_number+0x56>
 8022a24:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8022a26:	009b      	lsls	r3, r3, #2
 8022a28:	f107 0238 	add.w	r2, r7, #56	; 0x38
 8022a2c:	4413      	add	r3, r2
 8022a2e:	2200      	movs	r2, #0
 8022a30:	f843 2c24 	str.w	r2, [r3, #-36]
 8022a34:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8022a36:	3301      	adds	r3, #1
 8022a38:	62bb      	str	r3, [r7, #40]	; 0x28
 8022a3a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8022a3c:	2b01      	cmp	r3, #1
 8022a3e:	ddf1      	ble.n	8022a24 <token_spec_number+0x40>

	while ( i<length )
 8022a40:	e042      	b.n	8022ac8 <token_spec_number+0xe4>
	{
		t = *p++;
 8022a42:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8022a44:	1c5a      	adds	r2, r3, #1
 8022a46:	637a      	str	r2, [r7, #52]	; 0x34
 8022a48:	781b      	ldrb	r3, [r3, #0]
 8022a4a:	633b      	str	r3, [r7, #48]	; 0x30
		if ( t>='a' && t <='f' )
 8022a4c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8022a4e:	2b60      	cmp	r3, #96	; 0x60
 8022a50:	dd06      	ble.n	8022a60 <token_spec_number+0x7c>
 8022a52:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8022a54:	2b66      	cmp	r3, #102	; 0x66
 8022a56:	dc03      	bgt.n	8022a60 <token_spec_number+0x7c>
		{
			t = t - 'a' +10;
 8022a58:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8022a5a:	3b57      	subs	r3, #87	; 0x57
 8022a5c:	633b      	str	r3, [r7, #48]	; 0x30
 8022a5e:	e00c      	b.n	8022a7a <token_spec_number+0x96>
		}
		else if ( t >='A' && t <='F' )
 8022a60:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8022a62:	2b40      	cmp	r3, #64	; 0x40
 8022a64:	dd06      	ble.n	8022a74 <token_spec_number+0x90>
 8022a66:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8022a68:	2b46      	cmp	r3, #70	; 0x46
 8022a6a:	dc03      	bgt.n	8022a74 <token_spec_number+0x90>
		{
			t = t - 'A' +10;
 8022a6c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8022a6e:	3b37      	subs	r3, #55	; 0x37
 8022a70:	633b      	str	r3, [r7, #48]	; 0x30
 8022a72:	e002      	b.n	8022a7a <token_spec_number+0x96>
		}
		else t = t - '0';
 8022a74:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8022a76:	3b30      	subs	r3, #48	; 0x30
 8022a78:	633b      	str	r3, [r7, #48]	; 0x30

		for ( j=0; j<BN_SIZE ; j++)
 8022a7a:	2300      	movs	r3, #0
 8022a7c:	62bb      	str	r3, [r7, #40]	; 0x28
 8022a7e:	e01d      	b.n	8022abc <token_spec_number+0xd8>
		{
			v = bn[j];
 8022a80:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8022a82:	009b      	lsls	r3, r3, #2
 8022a84:	f107 0238 	add.w	r2, r7, #56	; 0x38
 8022a88:	4413      	add	r3, r2
 8022a8a:	f853 3c24 	ldr.w	r3, [r3, #-36]
 8022a8e:	623b      	str	r3, [r7, #32]
			bn[j] = (v<<shift) | t;
 8022a90:	6a3a      	ldr	r2, [r7, #32]
 8022a92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8022a94:	409a      	lsls	r2, r3
 8022a96:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8022a98:	431a      	orrs	r2, r3
 8022a9a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8022a9c:	009b      	lsls	r3, r3, #2
 8022a9e:	f107 0138 	add.w	r1, r7, #56	; 0x38
 8022aa2:	440b      	add	r3, r1
 8022aa4:	f843 2c24 	str.w	r2, [r3, #-36]
			t = v >> (32 - shift);
 8022aa8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8022aaa:	f1c3 0320 	rsb	r3, r3, #32
 8022aae:	6a3a      	ldr	r2, [r7, #32]
 8022ab0:	fa22 f303 	lsr.w	r3, r2, r3
 8022ab4:	633b      	str	r3, [r7, #48]	; 0x30
		{
			t = t - 'A' +10;
		}
		else t = t - '0';

		for ( j=0; j<BN_SIZE ; j++)
 8022ab6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8022ab8:	3301      	adds	r3, #1
 8022aba:	62bb      	str	r3, [r7, #40]	; 0x28
 8022abc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8022abe:	2b01      	cmp	r3, #1
 8022ac0:	ddde      	ble.n	8022a80 <token_spec_number+0x9c>
		{
			v = bn[j];
			bn[j] = (v<<shift) | t;
			t = v >> (32 - shift);
		}
		i++;
 8022ac2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8022ac4:	3301      	adds	r3, #1
 8022ac6:	62fb      	str	r3, [r7, #44]	; 0x2c
	default: break;
	}

	for ( j=0; j<BN_SIZE ; j++) bn[j] = 0;

	while ( i<length )
 8022ac8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8022aca:	68bb      	ldr	r3, [r7, #8]
 8022acc:	429a      	cmp	r2, r3
 8022ace:	dbb8      	blt.n	8022a42 <token_spec_number+0x5e>
			t = v >> (32 - shift);
		}
		i++;
	}

	d = (long)bn[0];
 8022ad0:	697b      	ldr	r3, [r7, #20]
 8022ad2:	61fb      	str	r3, [r7, #28]

	return d;
 8022ad4:	69fb      	ldr	r3, [r7, #28]
}
 8022ad6:	4618      	mov	r0, r3
 8022ad8:	373c      	adds	r7, #60	; 0x3c
 8022ada:	46bd      	mov	sp, r7
 8022adc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022ae0:	4770      	bx	lr
 8022ae2:	bf00      	nop

08022ae4 <atoi>:
 8022ae4:	2100      	movs	r1, #0
 8022ae6:	220a      	movs	r2, #10
 8022ae8:	f000 bf18 	b.w	802391c <strtol>

08022aec <ctime>:
 8022aec:	b508      	push	{r3, lr}
 8022aee:	f000 f805 	bl	8022afc <localtime>
 8022af2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8022af6:	f001 b9a7 	b.w	8023e48 <asctime>
 8022afa:	bf00      	nop

08022afc <localtime>:
 8022afc:	4b02      	ldr	r3, [pc, #8]	; (8022b08 <localtime+0xc>)
 8022afe:	6819      	ldr	r1, [r3, #0]
 8022b00:	317c      	adds	r1, #124	; 0x7c
 8022b02:	f000 b803 	b.w	8022b0c <localtime_r>
 8022b06:	bf00      	nop
 8022b08:	20010588 	.word	0x20010588

08022b0c <localtime_r>:
 8022b0c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8022b10:	460c      	mov	r4, r1
 8022b12:	4606      	mov	r6, r0
 8022b14:	f001 fa40 	bl	8023f98 <__gettzinfo>
 8022b18:	4621      	mov	r1, r4
 8022b1a:	4680      	mov	r8, r0
 8022b1c:	4630      	mov	r0, r6
 8022b1e:	f001 fa3f 	bl	8023fa0 <gmtime_r>
 8022b22:	6947      	ldr	r7, [r0, #20]
 8022b24:	f207 776c 	addw	r7, r7, #1900	; 0x76c
 8022b28:	07b9      	lsls	r1, r7, #30
 8022b2a:	4604      	mov	r4, r0
 8022b2c:	f000 80c6 	beq.w	8022cbc <localtime_r+0x1b0>
 8022b30:	17fa      	asrs	r2, r7, #31
 8022b32:	4b86      	ldr	r3, [pc, #536]	; (8022d4c <localtime_r+0x240>)
 8022b34:	fb83 1307 	smull	r1, r3, r3, r7
 8022b38:	ebc2 12e3 	rsb	r2, r2, r3, asr #7
 8022b3c:	f44f 73c8 	mov.w	r3, #400	; 0x190
 8022b40:	fb03 7312 	mls	r3, r3, r2, r7
 8022b44:	fab3 f383 	clz	r3, r3
 8022b48:	095b      	lsrs	r3, r3, #5
 8022b4a:	005a      	lsls	r2, r3, #1
 8022b4c:	4d80      	ldr	r5, [pc, #512]	; (8022d50 <localtime_r+0x244>)
 8022b4e:	4413      	add	r3, r2
 8022b50:	eb05 1503 	add.w	r5, r5, r3, lsl #4
 8022b54:	f000 ffb4 	bl	8023ac0 <__tz_lock>
 8022b58:	4b7e      	ldr	r3, [pc, #504]	; (8022d54 <localtime_r+0x248>)
 8022b5a:	681b      	ldr	r3, [r3, #0]
 8022b5c:	b343      	cbz	r3, 8022bb0 <localtime_r+0xa4>
 8022b5e:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8022b62:	42bb      	cmp	r3, r7
 8022b64:	d005      	beq.n	8022b72 <localtime_r+0x66>
 8022b66:	4638      	mov	r0, r7
 8022b68:	f000 fee4 	bl	8023934 <__tzcalc_limits>
 8022b6c:	2800      	cmp	r0, #0
 8022b6e:	f000 80b3 	beq.w	8022cd8 <localtime_r+0x1cc>
 8022b72:	f8d8 3000 	ldr.w	r3, [r8]
 8022b76:	b983      	cbnz	r3, 8022b9a <localtime_r+0x8e>
 8022b78:	6833      	ldr	r3, [r6, #0]
 8022b7a:	f8d8 201c 	ldr.w	r2, [r8, #28]
 8022b7e:	4293      	cmp	r3, r2
 8022b80:	f280 80ae 	bge.w	8022ce0 <localtime_r+0x1d4>
 8022b84:	f8d8 2038 	ldr.w	r2, [r8, #56]	; 0x38
 8022b88:	4293      	cmp	r3, r2
 8022b8a:	bfac      	ite	ge
 8022b8c:	2300      	movge	r3, #0
 8022b8e:	2301      	movlt	r3, #1
 8022b90:	6223      	str	r3, [r4, #32]
 8022b92:	b173      	cbz	r3, 8022bb2 <localtime_r+0xa6>
 8022b94:	f8d8 203c 	ldr.w	r2, [r8, #60]	; 0x3c
 8022b98:	e00d      	b.n	8022bb6 <localtime_r+0xaa>
 8022b9a:	6833      	ldr	r3, [r6, #0]
 8022b9c:	f8d8 201c 	ldr.w	r2, [r8, #28]
 8022ba0:	4293      	cmp	r3, r2
 8022ba2:	db04      	blt.n	8022bae <localtime_r+0xa2>
 8022ba4:	f8d8 2038 	ldr.w	r2, [r8, #56]	; 0x38
 8022ba8:	4293      	cmp	r3, r2
 8022baa:	f2c0 8099 	blt.w	8022ce0 <localtime_r+0x1d4>
 8022bae:	2300      	movs	r3, #0
 8022bb0:	6223      	str	r3, [r4, #32]
 8022bb2:	f8d8 2020 	ldr.w	r2, [r8, #32]
 8022bb6:	4868      	ldr	r0, [pc, #416]	; (8022d58 <localtime_r+0x24c>)
 8022bb8:	4968      	ldr	r1, [pc, #416]	; (8022d5c <localtime_r+0x250>)
 8022bba:	68a6      	ldr	r6, [r4, #8]
 8022bbc:	fb82 8900 	smull	r8, r9, r2, r0
 8022bc0:	eb02 0309 	add.w	r3, r2, r9
 8022bc4:	17d7      	asrs	r7, r2, #31
 8022bc6:	f44f 6861 	mov.w	r8, #3600	; 0xe10
 8022bca:	ebc7 23e3 	rsb	r3, r7, r3, asr #11
 8022bce:	fb08 2313 	mls	r3, r8, r3, r2
 8022bd2:	fb83 8901 	smull	r8, r9, r3, r1
 8022bd6:	4499      	add	r9, r3
 8022bd8:	ea4f 78e3 	mov.w	r8, r3, asr #31
 8022bdc:	ebc8 1969 	rsb	r9, r8, r9, asr #5
 8022be0:	fb81 1e03 	smull	r1, lr, r1, r3
 8022be4:	ebc9 1909 	rsb	r9, r9, r9, lsl #4
 8022be8:	6821      	ldr	r1, [r4, #0]
 8022bea:	449e      	add	lr, r3
 8022bec:	fb80 0c02 	smull	r0, ip, r0, r2
 8022bf0:	eba3 0389 	sub.w	r3, r3, r9, lsl #2
 8022bf4:	1acb      	subs	r3, r1, r3
 8022bf6:	4462      	add	r2, ip
 8022bf8:	6861      	ldr	r1, [r4, #4]
 8022bfa:	6023      	str	r3, [r4, #0]
 8022bfc:	ebc7 22e2 	rsb	r2, r7, r2, asr #11
 8022c00:	ebc8 1e6e 	rsb	lr, r8, lr, asr #5
 8022c04:	1ab2      	subs	r2, r6, r2
 8022c06:	ebce 0101 	rsb	r1, lr, r1
 8022c0a:	2b3b      	cmp	r3, #59	; 0x3b
 8022c0c:	60a2      	str	r2, [r4, #8]
 8022c0e:	6061      	str	r1, [r4, #4]
 8022c10:	dd4d      	ble.n	8022cae <localtime_r+0x1a2>
 8022c12:	3101      	adds	r1, #1
 8022c14:	3b3c      	subs	r3, #60	; 0x3c
 8022c16:	6061      	str	r1, [r4, #4]
 8022c18:	6023      	str	r3, [r4, #0]
 8022c1a:	293b      	cmp	r1, #59	; 0x3b
 8022c1c:	dd40      	ble.n	8022ca0 <localtime_r+0x194>
 8022c1e:	3201      	adds	r2, #1
 8022c20:	393c      	subs	r1, #60	; 0x3c
 8022c22:	60a2      	str	r2, [r4, #8]
 8022c24:	6061      	str	r1, [r4, #4]
 8022c26:	2a17      	cmp	r2, #23
 8022c28:	dd1d      	ble.n	8022c66 <localtime_r+0x15a>
 8022c2a:	69a3      	ldr	r3, [r4, #24]
 8022c2c:	69e1      	ldr	r1, [r4, #28]
 8022c2e:	3301      	adds	r3, #1
 8022c30:	2b06      	cmp	r3, #6
 8022c32:	bfc8      	it	gt
 8022c34:	2300      	movgt	r3, #0
 8022c36:	61a3      	str	r3, [r4, #24]
 8022c38:	68e3      	ldr	r3, [r4, #12]
 8022c3a:	3101      	adds	r1, #1
 8022c3c:	61e1      	str	r1, [r4, #28]
 8022c3e:	3a18      	subs	r2, #24
 8022c40:	3301      	adds	r3, #1
 8022c42:	6921      	ldr	r1, [r4, #16]
 8022c44:	60a2      	str	r2, [r4, #8]
 8022c46:	60e3      	str	r3, [r4, #12]
 8022c48:	f855 2021 	ldr.w	r2, [r5, r1, lsl #2]
 8022c4c:	4293      	cmp	r3, r2
 8022c4e:	dd05      	ble.n	8022c5c <localtime_r+0x150>
 8022c50:	3101      	adds	r1, #1
 8022c52:	1a9b      	subs	r3, r3, r2
 8022c54:	290c      	cmp	r1, #12
 8022c56:	60e3      	str	r3, [r4, #12]
 8022c58:	d045      	beq.n	8022ce6 <localtime_r+0x1da>
 8022c5a:	6121      	str	r1, [r4, #16]
 8022c5c:	f000 ff32 	bl	8023ac4 <__tz_unlock>
 8022c60:	4620      	mov	r0, r4
 8022c62:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8022c66:	2a00      	cmp	r2, #0
 8022c68:	daf8      	bge.n	8022c5c <localtime_r+0x150>
 8022c6a:	69a3      	ldr	r3, [r4, #24]
 8022c6c:	69e1      	ldr	r1, [r4, #28]
 8022c6e:	3b01      	subs	r3, #1
 8022c70:	bf48      	it	mi
 8022c72:	2306      	movmi	r3, #6
 8022c74:	61a3      	str	r3, [r4, #24]
 8022c76:	68e3      	ldr	r3, [r4, #12]
 8022c78:	3901      	subs	r1, #1
 8022c7a:	3218      	adds	r2, #24
 8022c7c:	3b01      	subs	r3, #1
 8022c7e:	61e1      	str	r1, [r4, #28]
 8022c80:	60a2      	str	r2, [r4, #8]
 8022c82:	60e3      	str	r3, [r4, #12]
 8022c84:	2b00      	cmp	r3, #0
 8022c86:	d1e9      	bne.n	8022c5c <localtime_r+0x150>
 8022c88:	6923      	ldr	r3, [r4, #16]
 8022c8a:	3b01      	subs	r3, #1
 8022c8c:	d432      	bmi.n	8022cf4 <localtime_r+0x1e8>
 8022c8e:	6123      	str	r3, [r4, #16]
 8022c90:	009b      	lsls	r3, r3, #2
 8022c92:	58eb      	ldr	r3, [r5, r3]
 8022c94:	60e3      	str	r3, [r4, #12]
 8022c96:	f000 ff15 	bl	8023ac4 <__tz_unlock>
 8022c9a:	4620      	mov	r0, r4
 8022c9c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8022ca0:	2900      	cmp	r1, #0
 8022ca2:	dac0      	bge.n	8022c26 <localtime_r+0x11a>
 8022ca4:	3a01      	subs	r2, #1
 8022ca6:	313c      	adds	r1, #60	; 0x3c
 8022ca8:	60a2      	str	r2, [r4, #8]
 8022caa:	6061      	str	r1, [r4, #4]
 8022cac:	e7bb      	b.n	8022c26 <localtime_r+0x11a>
 8022cae:	2b00      	cmp	r3, #0
 8022cb0:	dab3      	bge.n	8022c1a <localtime_r+0x10e>
 8022cb2:	3901      	subs	r1, #1
 8022cb4:	333c      	adds	r3, #60	; 0x3c
 8022cb6:	6061      	str	r1, [r4, #4]
 8022cb8:	6023      	str	r3, [r4, #0]
 8022cba:	e7ae      	b.n	8022c1a <localtime_r+0x10e>
 8022cbc:	4b23      	ldr	r3, [pc, #140]	; (8022d4c <localtime_r+0x240>)
 8022cbe:	17fa      	asrs	r2, r7, #31
 8022cc0:	fb83 1307 	smull	r1, r3, r3, r7
 8022cc4:	ebc2 1363 	rsb	r3, r2, r3, asr #5
 8022cc8:	2164      	movs	r1, #100	; 0x64
 8022cca:	fb01 7313 	mls	r3, r1, r3, r7
 8022cce:	2b00      	cmp	r3, #0
 8022cd0:	f43f af2f 	beq.w	8022b32 <localtime_r+0x26>
 8022cd4:	2301      	movs	r3, #1
 8022cd6:	e738      	b.n	8022b4a <localtime_r+0x3e>
 8022cd8:	f04f 33ff 	mov.w	r3, #4294967295
 8022cdc:	6223      	str	r3, [r4, #32]
 8022cde:	e768      	b.n	8022bb2 <localtime_r+0xa6>
 8022ce0:	2301      	movs	r3, #1
 8022ce2:	6223      	str	r3, [r4, #32]
 8022ce4:	e756      	b.n	8022b94 <localtime_r+0x88>
 8022ce6:	6963      	ldr	r3, [r4, #20]
 8022ce8:	2200      	movs	r2, #0
 8022cea:	3301      	adds	r3, #1
 8022cec:	6163      	str	r3, [r4, #20]
 8022cee:	6122      	str	r2, [r4, #16]
 8022cf0:	61e2      	str	r2, [r4, #28]
 8022cf2:	e7b3      	b.n	8022c5c <localtime_r+0x150>
 8022cf4:	6963      	ldr	r3, [r4, #20]
 8022cf6:	1e5a      	subs	r2, r3, #1
 8022cf8:	210b      	movs	r1, #11
 8022cfa:	6162      	str	r2, [r4, #20]
 8022cfc:	0792      	lsls	r2, r2, #30
 8022cfe:	6121      	str	r1, [r4, #16]
 8022d00:	d013      	beq.n	8022d2a <localtime_r+0x21e>
 8022d02:	f203 716b 	addw	r1, r3, #1899	; 0x76b
 8022d06:	17ca      	asrs	r2, r1, #31
 8022d08:	4b10      	ldr	r3, [pc, #64]	; (8022d4c <localtime_r+0x240>)
 8022d0a:	fb83 0301 	smull	r0, r3, r3, r1
 8022d0e:	ebc2 12e3 	rsb	r2, r2, r3, asr #7
 8022d12:	f44f 73c8 	mov.w	r3, #400	; 0x190
 8022d16:	fb03 1312 	mls	r3, r3, r2, r1
 8022d1a:	fab3 f383 	clz	r3, r3
 8022d1e:	095b      	lsrs	r3, r3, #5
 8022d20:	f503 73b6 	add.w	r3, r3, #364	; 0x16c
 8022d24:	61e3      	str	r3, [r4, #28]
 8022d26:	232c      	movs	r3, #44	; 0x2c
 8022d28:	e7b3      	b.n	8022c92 <localtime_r+0x186>
 8022d2a:	4a08      	ldr	r2, [pc, #32]	; (8022d4c <localtime_r+0x240>)
 8022d2c:	f203 716b 	addw	r1, r3, #1899	; 0x76b
 8022d30:	fb82 2301 	smull	r2, r3, r2, r1
 8022d34:	17ca      	asrs	r2, r1, #31
 8022d36:	ebc2 1363 	rsb	r3, r2, r3, asr #5
 8022d3a:	2064      	movs	r0, #100	; 0x64
 8022d3c:	fb00 1313 	mls	r3, r0, r3, r1
 8022d40:	2b00      	cmp	r3, #0
 8022d42:	d0e1      	beq.n	8022d08 <localtime_r+0x1fc>
 8022d44:	f240 136d 	movw	r3, #365	; 0x16d
 8022d48:	e7ec      	b.n	8022d24 <localtime_r+0x218>
 8022d4a:	bf00      	nop
 8022d4c:	51eb851f 	.word	0x51eb851f
 8022d50:	08029d14 	.word	0x08029d14
 8022d54:	200121cc 	.word	0x200121cc
 8022d58:	91a2b3c5 	.word	0x91a2b3c5
 8022d5c:	88888889 	.word	0x88888889

08022d60 <malloc>:
 8022d60:	4b02      	ldr	r3, [pc, #8]	; (8022d6c <malloc+0xc>)
 8022d62:	4601      	mov	r1, r0
 8022d64:	6818      	ldr	r0, [r3, #0]
 8022d66:	f7f6 be53 	b.w	8019a10 <_malloc_r>
 8022d6a:	bf00      	nop
 8022d6c:	20010588 	.word	0x20010588

08022d70 <free>:
 8022d70:	4b02      	ldr	r3, [pc, #8]	; (8022d7c <free+0xc>)
 8022d72:	4601      	mov	r1, r0
 8022d74:	6818      	ldr	r0, [r3, #0]
 8022d76:	f7f6 be75 	b.w	8019a64 <_free_r>
 8022d7a:	bf00      	nop
 8022d7c:	20010588 	.word	0x20010588

08022d80 <memset>:
 8022d80:	b470      	push	{r4, r5, r6}
 8022d82:	0784      	lsls	r4, r0, #30
 8022d84:	d046      	beq.n	8022e14 <memset+0x94>
 8022d86:	1e54      	subs	r4, r2, #1
 8022d88:	2a00      	cmp	r2, #0
 8022d8a:	d041      	beq.n	8022e10 <memset+0x90>
 8022d8c:	b2cd      	uxtb	r5, r1
 8022d8e:	4603      	mov	r3, r0
 8022d90:	e002      	b.n	8022d98 <memset+0x18>
 8022d92:	1e62      	subs	r2, r4, #1
 8022d94:	b3e4      	cbz	r4, 8022e10 <memset+0x90>
 8022d96:	4614      	mov	r4, r2
 8022d98:	f803 5b01 	strb.w	r5, [r3], #1
 8022d9c:	079a      	lsls	r2, r3, #30
 8022d9e:	d1f8      	bne.n	8022d92 <memset+0x12>
 8022da0:	2c03      	cmp	r4, #3
 8022da2:	d92e      	bls.n	8022e02 <memset+0x82>
 8022da4:	b2cd      	uxtb	r5, r1
 8022da6:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 8022daa:	2c0f      	cmp	r4, #15
 8022dac:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8022db0:	d919      	bls.n	8022de6 <memset+0x66>
 8022db2:	f103 0210 	add.w	r2, r3, #16
 8022db6:	4626      	mov	r6, r4
 8022db8:	3e10      	subs	r6, #16
 8022dba:	2e0f      	cmp	r6, #15
 8022dbc:	f842 5c10 	str.w	r5, [r2, #-16]
 8022dc0:	f842 5c0c 	str.w	r5, [r2, #-12]
 8022dc4:	f842 5c08 	str.w	r5, [r2, #-8]
 8022dc8:	f842 5c04 	str.w	r5, [r2, #-4]
 8022dcc:	f102 0210 	add.w	r2, r2, #16
 8022dd0:	d8f2      	bhi.n	8022db8 <memset+0x38>
 8022dd2:	f1a4 0210 	sub.w	r2, r4, #16
 8022dd6:	f022 020f 	bic.w	r2, r2, #15
 8022dda:	f004 040f 	and.w	r4, r4, #15
 8022dde:	3210      	adds	r2, #16
 8022de0:	2c03      	cmp	r4, #3
 8022de2:	4413      	add	r3, r2
 8022de4:	d90d      	bls.n	8022e02 <memset+0x82>
 8022de6:	461e      	mov	r6, r3
 8022de8:	4622      	mov	r2, r4
 8022dea:	3a04      	subs	r2, #4
 8022dec:	2a03      	cmp	r2, #3
 8022dee:	f846 5b04 	str.w	r5, [r6], #4
 8022df2:	d8fa      	bhi.n	8022dea <memset+0x6a>
 8022df4:	1f22      	subs	r2, r4, #4
 8022df6:	f022 0203 	bic.w	r2, r2, #3
 8022dfa:	3204      	adds	r2, #4
 8022dfc:	4413      	add	r3, r2
 8022dfe:	f004 0403 	and.w	r4, r4, #3
 8022e02:	b12c      	cbz	r4, 8022e10 <memset+0x90>
 8022e04:	b2c9      	uxtb	r1, r1
 8022e06:	441c      	add	r4, r3
 8022e08:	f803 1b01 	strb.w	r1, [r3], #1
 8022e0c:	42a3      	cmp	r3, r4
 8022e0e:	d1fb      	bne.n	8022e08 <memset+0x88>
 8022e10:	bc70      	pop	{r4, r5, r6}
 8022e12:	4770      	bx	lr
 8022e14:	4614      	mov	r4, r2
 8022e16:	4603      	mov	r3, r0
 8022e18:	e7c2      	b.n	8022da0 <memset+0x20>
 8022e1a:	bf00      	nop

08022e1c <validate_structure>:
 8022e1c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8022e20:	6801      	ldr	r1, [r0, #0]
 8022e22:	293b      	cmp	r1, #59	; 0x3b
 8022e24:	b083      	sub	sp, #12
 8022e26:	4604      	mov	r4, r0
 8022e28:	f200 80bc 	bhi.w	8022fa4 <validate_structure+0x188>
 8022e2c:	6841      	ldr	r1, [r0, #4]
 8022e2e:	293b      	cmp	r1, #59	; 0x3b
 8022e30:	f200 80ab 	bhi.w	8022f8a <validate_structure+0x16e>
 8022e34:	68a1      	ldr	r1, [r4, #8]
 8022e36:	2917      	cmp	r1, #23
 8022e38:	f200 809a 	bhi.w	8022f70 <validate_structure+0x154>
 8022e3c:	6921      	ldr	r1, [r4, #16]
 8022e3e:	290b      	cmp	r1, #11
 8022e40:	f200 8089 	bhi.w	8022f56 <validate_structure+0x13a>
 8022e44:	6963      	ldr	r3, [r4, #20]
 8022e46:	079e      	lsls	r6, r3, #30
 8022e48:	d13d      	bne.n	8022ec6 <validate_structure+0xaa>
 8022e4a:	4875      	ldr	r0, [pc, #468]	; (8023020 <validate_structure+0x204>)
 8022e4c:	17da      	asrs	r2, r3, #31
 8022e4e:	fb80 6503 	smull	r6, r5, r0, r3
 8022e52:	ebc2 1265 	rsb	r2, r2, r5, asr #5
 8022e56:	2564      	movs	r5, #100	; 0x64
 8022e58:	fb05 3212 	mls	r2, r5, r2, r3
 8022e5c:	2a00      	cmp	r2, #0
 8022e5e:	d173      	bne.n	8022f48 <validate_structure+0x12c>
 8022e60:	f203 736c 	addw	r3, r3, #1900	; 0x76c
 8022e64:	fb80 2003 	smull	r2, r0, r0, r3
 8022e68:	17da      	asrs	r2, r3, #31
 8022e6a:	ebc2 10e0 	rsb	r0, r2, r0, asr #7
 8022e6e:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8022e72:	fb02 3310 	mls	r3, r2, r0, r3
 8022e76:	2b00      	cmp	r3, #0
 8022e78:	bf0c      	ite	eq
 8022e7a:	251d      	moveq	r5, #29
 8022e7c:	251c      	movne	r5, #28
 8022e7e:	68e3      	ldr	r3, [r4, #12]
 8022e80:	2b00      	cmp	r3, #0
 8022e82:	dc25      	bgt.n	8022ed0 <validate_structure+0xb4>
 8022e84:	4e67      	ldr	r6, [pc, #412]	; (8023024 <validate_structure+0x208>)
 8022e86:	4f66      	ldr	r7, [pc, #408]	; (8023020 <validate_structure+0x204>)
 8022e88:	f04f 0e64 	mov.w	lr, #100	; 0x64
 8022e8c:	f44f 7cc8 	mov.w	ip, #400	; 0x190
 8022e90:	e006      	b.n	8022ea0 <validate_structure+0x84>
 8022e92:	2901      	cmp	r1, #1
 8022e94:	d05a      	beq.n	8022f4c <validate_structure+0x130>
 8022e96:	f856 2021 	ldr.w	r2, [r6, r1, lsl #2]
 8022e9a:	4413      	add	r3, r2
 8022e9c:	2b00      	cmp	r3, #0
 8022e9e:	dc39      	bgt.n	8022f14 <validate_structure+0xf8>
 8022ea0:	f111 31ff 	adds.w	r1, r1, #4294967295
 8022ea4:	d2f5      	bcs.n	8022e92 <validate_structure+0x76>
 8022ea6:	6961      	ldr	r1, [r4, #20]
 8022ea8:	1e4a      	subs	r2, r1, #1
 8022eaa:	0795      	lsls	r5, r2, #30
 8022eac:	6162      	str	r2, [r4, #20]
 8022eae:	d14f      	bne.n	8022f50 <validate_structure+0x134>
 8022eb0:	fb87 0502 	smull	r0, r5, r7, r2
 8022eb4:	17d0      	asrs	r0, r2, #31
 8022eb6:	ebc0 1065 	rsb	r0, r0, r5, asr #5
 8022eba:	fb0e 2210 	mls	r2, lr, r0, r2
 8022ebe:	2a00      	cmp	r2, #0
 8022ec0:	d07d      	beq.n	8022fbe <validate_structure+0x1a2>
 8022ec2:	251d      	movs	r5, #29
 8022ec4:	e045      	b.n	8022f52 <validate_structure+0x136>
 8022ec6:	68e3      	ldr	r3, [r4, #12]
 8022ec8:	2b00      	cmp	r3, #0
 8022eca:	f04f 051c 	mov.w	r5, #28
 8022ece:	ddd9      	ble.n	8022e84 <validate_structure+0x68>
 8022ed0:	4f54      	ldr	r7, [pc, #336]	; (8023024 <validate_structure+0x208>)
 8022ed2:	f8df c14c 	ldr.w	ip, [pc, #332]	; 8023020 <validate_structure+0x204>
 8022ed6:	f04f 0e00 	mov.w	lr, #0
 8022eda:	f04f 0864 	mov.w	r8, #100	; 0x64
 8022ede:	f44f 79c8 	mov.w	r9, #400	; 0x190
 8022ee2:	1c4a      	adds	r2, r1, #1
 8022ee4:	eb07 0081 	add.w	r0, r7, r1, lsl #2
 8022ee8:	e00b      	b.n	8022f02 <validate_structure+0xe6>
 8022eea:	6806      	ldr	r6, [r0, #0]
 8022eec:	429e      	cmp	r6, r3
 8022eee:	eba3 0306 	sub.w	r3, r3, r6
 8022ef2:	da11      	bge.n	8022f18 <validate_structure+0xfc>
 8022ef4:	2a0c      	cmp	r2, #12
 8022ef6:	60e3      	str	r3, [r4, #12]
 8022ef8:	6122      	str	r2, [r4, #16]
 8022efa:	d010      	beq.n	8022f1e <validate_structure+0x102>
 8022efc:	3101      	adds	r1, #1
 8022efe:	3201      	adds	r2, #1
 8022f00:	3004      	adds	r0, #4
 8022f02:	2901      	cmp	r1, #1
 8022f04:	d1f1      	bne.n	8022eea <validate_structure+0xce>
 8022f06:	429d      	cmp	r5, r3
 8022f08:	eba3 0305 	sub.w	r3, r3, r5
 8022f0c:	da04      	bge.n	8022f18 <validate_structure+0xfc>
 8022f0e:	60e3      	str	r3, [r4, #12]
 8022f10:	6122      	str	r2, [r4, #16]
 8022f12:	e7f3      	b.n	8022efc <validate_structure+0xe0>
 8022f14:	6121      	str	r1, [r4, #16]
 8022f16:	60e3      	str	r3, [r4, #12]
 8022f18:	b003      	add	sp, #12
 8022f1a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8022f1e:	6961      	ldr	r1, [r4, #20]
 8022f20:	f8c4 e010 	str.w	lr, [r4, #16]
 8022f24:	1c4a      	adds	r2, r1, #1
 8022f26:	0790      	lsls	r0, r2, #30
 8022f28:	6162      	str	r2, [r4, #20]
 8022f2a:	d002      	beq.n	8022f32 <validate_structure+0x116>
 8022f2c:	251c      	movs	r5, #28
 8022f2e:	2100      	movs	r1, #0
 8022f30:	e7d7      	b.n	8022ee2 <validate_structure+0xc6>
 8022f32:	fb8c 0502 	smull	r0, r5, ip, r2
 8022f36:	17d0      	asrs	r0, r2, #31
 8022f38:	ebc0 1065 	rsb	r0, r0, r5, asr #5
 8022f3c:	fb08 2210 	mls	r2, r8, r0, r2
 8022f40:	2a00      	cmp	r2, #0
 8022f42:	d04a      	beq.n	8022fda <validate_structure+0x1be>
 8022f44:	251d      	movs	r5, #29
 8022f46:	e7f2      	b.n	8022f2e <validate_structure+0x112>
 8022f48:	251d      	movs	r5, #29
 8022f4a:	e798      	b.n	8022e7e <validate_structure+0x62>
 8022f4c:	462a      	mov	r2, r5
 8022f4e:	e7a4      	b.n	8022e9a <validate_structure+0x7e>
 8022f50:	251c      	movs	r5, #28
 8022f52:	210b      	movs	r1, #11
 8022f54:	e79f      	b.n	8022e96 <validate_structure+0x7a>
 8022f56:	220c      	movs	r2, #12
 8022f58:	4668      	mov	r0, sp
 8022f5a:	f000 ffa7 	bl	8023eac <div>
 8022f5e:	6962      	ldr	r2, [r4, #20]
 8022f60:	9b00      	ldr	r3, [sp, #0]
 8022f62:	9901      	ldr	r1, [sp, #4]
 8022f64:	4413      	add	r3, r2
 8022f66:	2900      	cmp	r1, #0
 8022f68:	6163      	str	r3, [r4, #20]
 8022f6a:	db53      	blt.n	8023014 <validate_structure+0x1f8>
 8022f6c:	6121      	str	r1, [r4, #16]
 8022f6e:	e76a      	b.n	8022e46 <validate_structure+0x2a>
 8022f70:	2218      	movs	r2, #24
 8022f72:	4668      	mov	r0, sp
 8022f74:	f000 ff9a 	bl	8023eac <div>
 8022f78:	68e1      	ldr	r1, [r4, #12]
 8022f7a:	9b00      	ldr	r3, [sp, #0]
 8022f7c:	9a01      	ldr	r2, [sp, #4]
 8022f7e:	440b      	add	r3, r1
 8022f80:	2a00      	cmp	r2, #0
 8022f82:	60e3      	str	r3, [r4, #12]
 8022f84:	db41      	blt.n	802300a <validate_structure+0x1ee>
 8022f86:	60a2      	str	r2, [r4, #8]
 8022f88:	e758      	b.n	8022e3c <validate_structure+0x20>
 8022f8a:	223c      	movs	r2, #60	; 0x3c
 8022f8c:	4668      	mov	r0, sp
 8022f8e:	f000 ff8d 	bl	8023eac <div>
 8022f92:	68a1      	ldr	r1, [r4, #8]
 8022f94:	9b00      	ldr	r3, [sp, #0]
 8022f96:	9a01      	ldr	r2, [sp, #4]
 8022f98:	4419      	add	r1, r3
 8022f9a:	2a00      	cmp	r2, #0
 8022f9c:	60a1      	str	r1, [r4, #8]
 8022f9e:	db2f      	blt.n	8023000 <validate_structure+0x1e4>
 8022fa0:	6062      	str	r2, [r4, #4]
 8022fa2:	e748      	b.n	8022e36 <validate_structure+0x1a>
 8022fa4:	223c      	movs	r2, #60	; 0x3c
 8022fa6:	4668      	mov	r0, sp
 8022fa8:	f000 ff80 	bl	8023eac <div>
 8022fac:	6863      	ldr	r3, [r4, #4]
 8022fae:	9900      	ldr	r1, [sp, #0]
 8022fb0:	9a01      	ldr	r2, [sp, #4]
 8022fb2:	4419      	add	r1, r3
 8022fb4:	2a00      	cmp	r2, #0
 8022fb6:	6061      	str	r1, [r4, #4]
 8022fb8:	db1d      	blt.n	8022ff6 <validate_structure+0x1da>
 8022fba:	6022      	str	r2, [r4, #0]
 8022fbc:	e737      	b.n	8022e2e <validate_structure+0x12>
 8022fbe:	f201 716b 	addw	r1, r1, #1899	; 0x76b
 8022fc2:	fb87 2001 	smull	r2, r0, r7, r1
 8022fc6:	17ca      	asrs	r2, r1, #31
 8022fc8:	ebc2 12e0 	rsb	r2, r2, r0, asr #7
 8022fcc:	fb0c 1112 	mls	r1, ip, r2, r1
 8022fd0:	2900      	cmp	r1, #0
 8022fd2:	bf14      	ite	ne
 8022fd4:	251c      	movne	r5, #28
 8022fd6:	251d      	moveq	r5, #29
 8022fd8:	e7bb      	b.n	8022f52 <validate_structure+0x136>
 8022fda:	f201 716d 	addw	r1, r1, #1901	; 0x76d
 8022fde:	fb8c 2001 	smull	r2, r0, ip, r1
 8022fe2:	17ca      	asrs	r2, r1, #31
 8022fe4:	ebc2 12e0 	rsb	r2, r2, r0, asr #7
 8022fe8:	fb09 1112 	mls	r1, r9, r2, r1
 8022fec:	2900      	cmp	r1, #0
 8022fee:	bf14      	ite	ne
 8022ff0:	251c      	movne	r5, #28
 8022ff2:	251d      	moveq	r5, #29
 8022ff4:	e79b      	b.n	8022f2e <validate_structure+0x112>
 8022ff6:	323c      	adds	r2, #60	; 0x3c
 8022ff8:	3901      	subs	r1, #1
 8022ffa:	6022      	str	r2, [r4, #0]
 8022ffc:	6061      	str	r1, [r4, #4]
 8022ffe:	e716      	b.n	8022e2e <validate_structure+0x12>
 8023000:	323c      	adds	r2, #60	; 0x3c
 8023002:	3901      	subs	r1, #1
 8023004:	6062      	str	r2, [r4, #4]
 8023006:	60a1      	str	r1, [r4, #8]
 8023008:	e715      	b.n	8022e36 <validate_structure+0x1a>
 802300a:	3218      	adds	r2, #24
 802300c:	3b01      	subs	r3, #1
 802300e:	60a2      	str	r2, [r4, #8]
 8023010:	60e3      	str	r3, [r4, #12]
 8023012:	e713      	b.n	8022e3c <validate_structure+0x20>
 8023014:	310c      	adds	r1, #12
 8023016:	3b01      	subs	r3, #1
 8023018:	6121      	str	r1, [r4, #16]
 802301a:	6163      	str	r3, [r4, #20]
 802301c:	e713      	b.n	8022e46 <validate_structure+0x2a>
 802301e:	bf00      	nop
 8023020:	51eb851f 	.word	0x51eb851f
 8023024:	08029ce4 	.word	0x08029ce4

08023028 <mktime>:
 8023028:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802302c:	4606      	mov	r6, r0
 802302e:	f000 ffb3 	bl	8023f98 <__gettzinfo>
 8023032:	4680      	mov	r8, r0
 8023034:	4630      	mov	r0, r6
 8023036:	f7ff fef1 	bl	8022e1c <validate_structure>
 802303a:	4cbd      	ldr	r4, [pc, #756]	; (8023330 <mktime+0x308>)
 802303c:	6935      	ldr	r5, [r6, #16]
 802303e:	6873      	ldr	r3, [r6, #4]
 8023040:	6830      	ldr	r0, [r6, #0]
 8023042:	68f2      	ldr	r2, [r6, #12]
 8023044:	f854 4025 	ldr.w	r4, [r4, r5, lsl #2]
 8023048:	68b1      	ldr	r1, [r6, #8]
 802304a:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 802304e:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8023052:	f44f 6e61 	mov.w	lr, #3600	; 0xe10
 8023056:	3a01      	subs	r2, #1
 8023058:	2d01      	cmp	r5, #1
 802305a:	fb0e 3e01 	mla	lr, lr, r1, r3
 802305e:	4414      	add	r4, r2
 8023060:	6975      	ldr	r5, [r6, #20]
 8023062:	dd02      	ble.n	802306a <mktime+0x42>
 8023064:	07ab      	lsls	r3, r5, #30
 8023066:	f000 80c0 	beq.w	80231ea <mktime+0x1c2>
 802306a:	f505 531c 	add.w	r3, r5, #9984	; 0x2700
 802306e:	3310      	adds	r3, #16
 8023070:	f644 6220 	movw	r2, #20000	; 0x4e20
 8023074:	4293      	cmp	r3, r2
 8023076:	61f4      	str	r4, [r6, #28]
 8023078:	f200 8153 	bhi.w	8023322 <mktime+0x2fa>
 802307c:	2d46      	cmp	r5, #70	; 0x46
 802307e:	dc55      	bgt.n	802312c <mktime+0x104>
 8023080:	f000 8081 	beq.w	8023186 <mktime+0x15e>
 8023084:	2d45      	cmp	r5, #69	; 0x45
 8023086:	f000 80f8 	beq.w	802327a <mktime+0x252>
 802308a:	48aa      	ldr	r0, [pc, #680]	; (8023334 <mktime+0x30c>)
 802308c:	2345      	movs	r3, #69	; 0x45
 802308e:	f240 196d 	movw	r9, #365	; 0x16d
 8023092:	2764      	movs	r7, #100	; 0x64
 8023094:	f44f 7cc8 	mov.w	ip, #400	; 0x190
 8023098:	e016      	b.n	80230c8 <mktime+0xa0>
 802309a:	f203 7b6c 	addw	fp, r3, #1900	; 0x76c
 802309e:	fb80 a10b 	smull	sl, r1, r0, fp
 80230a2:	ea4f 7aeb 	mov.w	sl, fp, asr #31
 80230a6:	ebca 11e1 	rsb	r1, sl, r1, asr #7
 80230aa:	fb0c b111 	mls	r1, ip, r1, fp
 80230ae:	2a00      	cmp	r2, #0
 80230b0:	f040 80ca 	bne.w	8023248 <mktime+0x220>
 80230b4:	2900      	cmp	r1, #0
 80230b6:	bf14      	ite	ne
 80230b8:	464a      	movne	r2, r9
 80230ba:	f44f 72b7 	moveq.w	r2, #366	; 0x16e
 80230be:	3b01      	subs	r3, #1
 80230c0:	42ab      	cmp	r3, r5
 80230c2:	eba4 0402 	sub.w	r4, r4, r2
 80230c6:	d010      	beq.n	80230ea <mktime+0xc2>
 80230c8:	fb80 1203 	smull	r1, r2, r0, r3
 80230cc:	17d9      	asrs	r1, r3, #31
 80230ce:	ebc1 1262 	rsb	r2, r1, r2, asr #5
 80230d2:	f013 0f03 	tst.w	r3, #3
 80230d6:	fb07 3212 	mls	r2, r7, r2, r3
 80230da:	d0de      	beq.n	802309a <mktime+0x72>
 80230dc:	3b01      	subs	r3, #1
 80230de:	f240 126d 	movw	r2, #365	; 0x16d
 80230e2:	42ab      	cmp	r3, r5
 80230e4:	eba4 0402 	sub.w	r4, r4, r2
 80230e8:	d1ee      	bne.n	80230c8 <mktime+0xa0>
 80230ea:	07af      	lsls	r7, r5, #30
 80230ec:	f040 80c5 	bne.w	802327a <mktime+0x252>
 80230f0:	4a90      	ldr	r2, [pc, #576]	; (8023334 <mktime+0x30c>)
 80230f2:	17eb      	asrs	r3, r5, #31
 80230f4:	fb82 0105 	smull	r0, r1, r2, r5
 80230f8:	ebc3 1361 	rsb	r3, r3, r1, asr #5
 80230fc:	2164      	movs	r1, #100	; 0x64
 80230fe:	fb01 5313 	mls	r3, r1, r3, r5
 8023102:	2b00      	cmp	r3, #0
 8023104:	f040 8108 	bne.w	8023318 <mktime+0x2f0>
 8023108:	f205 716c 	addw	r1, r5, #1900	; 0x76c
 802310c:	fb82 3201 	smull	r3, r2, r2, r1
 8023110:	17cb      	asrs	r3, r1, #31
 8023112:	ebc3 12e2 	rsb	r2, r3, r2, asr #7
 8023116:	f44f 73c8 	mov.w	r3, #400	; 0x190
 802311a:	fb03 1312 	mls	r3, r3, r2, r1
 802311e:	2b00      	cmp	r3, #0
 8023120:	f240 136d 	movw	r3, #365	; 0x16d
 8023124:	bf08      	it	eq
 8023126:	f44f 73b7 	moveq.w	r3, #366	; 0x16e
 802312a:	e0a8      	b.n	802327e <mktime+0x256>
 802312c:	4881      	ldr	r0, [pc, #516]	; (8023334 <mktime+0x30c>)
 802312e:	2346      	movs	r3, #70	; 0x46
 8023130:	f240 196d 	movw	r9, #365	; 0x16d
 8023134:	2764      	movs	r7, #100	; 0x64
 8023136:	f44f 7cc8 	mov.w	ip, #400	; 0x190
 802313a:	e014      	b.n	8023166 <mktime+0x13e>
 802313c:	f203 7b6c 	addw	fp, r3, #1900	; 0x76c
 8023140:	fb80 a10b 	smull	sl, r1, r0, fp
 8023144:	ea4f 7aeb 	mov.w	sl, fp, asr #31
 8023148:	ebca 11e1 	rsb	r1, sl, r1, asr #7
 802314c:	fb0c b111 	mls	r1, ip, r1, fp
 8023150:	2a00      	cmp	r2, #0
 8023152:	d156      	bne.n	8023202 <mktime+0x1da>
 8023154:	2900      	cmp	r1, #0
 8023156:	bf14      	ite	ne
 8023158:	464a      	movne	r2, r9
 802315a:	f44f 72b7 	moveq.w	r2, #366	; 0x16e
 802315e:	3301      	adds	r3, #1
 8023160:	42ab      	cmp	r3, r5
 8023162:	4414      	add	r4, r2
 8023164:	d00f      	beq.n	8023186 <mktime+0x15e>
 8023166:	fb80 1203 	smull	r1, r2, r0, r3
 802316a:	17d9      	asrs	r1, r3, #31
 802316c:	ebc1 1262 	rsb	r2, r1, r2, asr #5
 8023170:	f013 0f03 	tst.w	r3, #3
 8023174:	fb07 3212 	mls	r2, r7, r2, r3
 8023178:	d0e0      	beq.n	802313c <mktime+0x114>
 802317a:	3301      	adds	r3, #1
 802317c:	f240 126d 	movw	r2, #365	; 0x16d
 8023180:	42ab      	cmp	r3, r5
 8023182:	4414      	add	r4, r2
 8023184:	d1ef      	bne.n	8023166 <mktime+0x13e>
 8023186:	486c      	ldr	r0, [pc, #432]	; (8023338 <mktime+0x310>)
 8023188:	fb00 e904 	mla	r9, r0, r4, lr
 802318c:	f000 fc98 	bl	8023ac0 <__tz_lock>
 8023190:	4b6a      	ldr	r3, [pc, #424]	; (802333c <mktime+0x314>)
 8023192:	681f      	ldr	r7, [r3, #0]
 8023194:	2f00      	cmp	r7, #0
 8023196:	d052      	beq.n	802323e <mktime+0x216>
 8023198:	6a37      	ldr	r7, [r6, #32]
 802319a:	6970      	ldr	r0, [r6, #20]
 802319c:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80231a0:	2f01      	cmp	r7, #1
 80231a2:	f200 706c 	addw	r0, r0, #1900	; 0x76c
 80231a6:	bfa8      	it	ge
 80231a8:	2701      	movge	r7, #1
 80231aa:	4283      	cmp	r3, r0
 80231ac:	d02c      	beq.n	8023208 <mktime+0x1e0>
 80231ae:	f000 fbc1 	bl	8023934 <__tzcalc_limits>
 80231b2:	bb48      	cbnz	r0, 8023208 <mktime+0x1e0>
 80231b4:	2f01      	cmp	r7, #1
 80231b6:	d142      	bne.n	802323e <mktime+0x216>
 80231b8:	f8d8 103c 	ldr.w	r1, [r8, #60]	; 0x3c
 80231bc:	eb09 0501 	add.w	r5, r9, r1
 80231c0:	2701      	movs	r7, #1
 80231c2:	f000 fc7f 	bl	8023ac4 <__tz_unlock>
 80231c6:	4a5e      	ldr	r2, [pc, #376]	; (8023340 <mktime+0x318>)
 80231c8:	6237      	str	r7, [r6, #32]
 80231ca:	3404      	adds	r4, #4
 80231cc:	fb84 2302 	smull	r2, r3, r4, r2
 80231d0:	18e2      	adds	r2, r4, r3
 80231d2:	17e3      	asrs	r3, r4, #31
 80231d4:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 80231d8:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80231dc:	1ae3      	subs	r3, r4, r3
 80231de:	bf48      	it	mi
 80231e0:	3307      	addmi	r3, #7
 80231e2:	61b3      	str	r3, [r6, #24]
 80231e4:	4628      	mov	r0, r5
 80231e6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80231ea:	4a52      	ldr	r2, [pc, #328]	; (8023334 <mktime+0x30c>)
 80231ec:	17eb      	asrs	r3, r5, #31
 80231ee:	fb82 0105 	smull	r0, r1, r2, r5
 80231f2:	ebc3 1361 	rsb	r3, r3, r1, asr #5
 80231f6:	2164      	movs	r1, #100	; 0x64
 80231f8:	fb01 5313 	mls	r3, r1, r3, r5
 80231fc:	b33b      	cbz	r3, 802324e <mktime+0x226>
 80231fe:	3401      	adds	r4, #1
 8023200:	e733      	b.n	802306a <mktime+0x42>
 8023202:	f44f 72b7 	mov.w	r2, #366	; 0x16e
 8023206:	e7aa      	b.n	802315e <mktime+0x136>
 8023208:	f8d8 2038 	ldr.w	r2, [r8, #56]	; 0x38
 802320c:	f8d8 0020 	ldr.w	r0, [r8, #32]
 8023210:	f8d8 103c 	ldr.w	r1, [r8, #60]	; 0x3c
 8023214:	f8d8 301c 	ldr.w	r3, [r8, #28]
 8023218:	ebc0 0e02 	rsb	lr, r0, r2
 802321c:	45f1      	cmp	r9, lr
 802321e:	eba3 0301 	sub.w	r3, r3, r1
 8023222:	db02      	blt.n	802322a <mktime+0x202>
 8023224:	1a52      	subs	r2, r2, r1
 8023226:	4591      	cmp	r9, r2
 8023228:	dbc4      	blt.n	80231b4 <mktime+0x18c>
 802322a:	f8d8 2000 	ldr.w	r2, [r8]
 802322e:	b1ea      	cbz	r2, 802326c <mktime+0x244>
 8023230:	4599      	cmp	r9, r3
 8023232:	da26      	bge.n	8023282 <mktime+0x25a>
 8023234:	2f00      	cmp	r7, #0
 8023236:	db72      	blt.n	802331e <mktime+0x2f6>
 8023238:	f04f 0a00 	mov.w	sl, #0
 802323c:	e029      	b.n	8023292 <mktime+0x26a>
 802323e:	f8d8 0020 	ldr.w	r0, [r8, #32]
 8023242:	eb09 0500 	add.w	r5, r9, r0
 8023246:	e7bc      	b.n	80231c2 <mktime+0x19a>
 8023248:	f44f 72b7 	mov.w	r2, #366	; 0x16e
 802324c:	e737      	b.n	80230be <mktime+0x96>
 802324e:	f205 716c 	addw	r1, r5, #1900	; 0x76c
 8023252:	fb82 3201 	smull	r3, r2, r2, r1
 8023256:	17cb      	asrs	r3, r1, #31
 8023258:	ebc3 12e2 	rsb	r2, r3, r2, asr #7
 802325c:	f44f 73c8 	mov.w	r3, #400	; 0x190
 8023260:	fb03 1212 	mls	r2, r3, r2, r1
 8023264:	2a00      	cmp	r2, #0
 8023266:	f47f af00 	bne.w	802306a <mktime+0x42>
 802326a:	e7c8      	b.n	80231fe <mktime+0x1d6>
 802326c:	4599      	cmp	r9, r3
 802326e:	db08      	blt.n	8023282 <mktime+0x25a>
 8023270:	2f00      	cmp	r7, #0
 8023272:	dba3      	blt.n	80231bc <mktime+0x194>
 8023274:	f04f 0a01 	mov.w	sl, #1
 8023278:	e00b      	b.n	8023292 <mktime+0x26a>
 802327a:	f240 136d 	movw	r3, #365	; 0x16d
 802327e:	1ae4      	subs	r4, r4, r3
 8023280:	e781      	b.n	8023186 <mktime+0x15e>
 8023282:	45f1      	cmp	r9, lr
 8023284:	bfac      	ite	ge
 8023286:	f04f 0a00 	movge.w	sl, #0
 802328a:	f04f 0a01 	movlt.w	sl, #1
 802328e:	2f00      	cmp	r7, #0
 8023290:	db03      	blt.n	802329a <mktime+0x272>
 8023292:	ea8a 0707 	eor.w	r7, sl, r7
 8023296:	2f01      	cmp	r7, #1
 8023298:	d001      	beq.n	802329e <mktime+0x276>
 802329a:	4657      	mov	r7, sl
 802329c:	e78a      	b.n	80231b4 <mktime+0x18c>
 802329e:	f08a 0301 	eor.w	r3, sl, #1
 80232a2:	425a      	negs	r2, r3
 80232a4:	1a41      	subs	r1, r0, r1
 80232a6:	4051      	eors	r1, r2
 80232a8:	6832      	ldr	r2, [r6, #0]
 80232aa:	68f7      	ldr	r7, [r6, #12]
 80232ac:	440b      	add	r3, r1
 80232ae:	441a      	add	r2, r3
 80232b0:	6032      	str	r2, [r6, #0]
 80232b2:	4630      	mov	r0, r6
 80232b4:	4499      	add	r9, r3
 80232b6:	f7ff fdb1 	bl	8022e1c <validate_structure>
 80232ba:	68f3      	ldr	r3, [r6, #12]
 80232bc:	1bdb      	subs	r3, r3, r7
 80232be:	d0ec      	beq.n	802329a <mktime+0x272>
 80232c0:	2b01      	cmp	r3, #1
 80232c2:	dd5e      	ble.n	8023382 <mktime+0x35a>
 80232c4:	f04f 33ff 	mov.w	r3, #4294967295
 80232c8:	69f2      	ldr	r2, [r6, #28]
 80232ca:	441c      	add	r4, r3
 80232cc:	189b      	adds	r3, r3, r2
 80232ce:	d439      	bmi.n	8023344 <mktime+0x31c>
 80232d0:	07aa      	lsls	r2, r5, #30
 80232d2:	d12a      	bne.n	802332a <mktime+0x302>
 80232d4:	4917      	ldr	r1, [pc, #92]	; (8023334 <mktime+0x30c>)
 80232d6:	17ea      	asrs	r2, r5, #31
 80232d8:	fb81 7005 	smull	r7, r0, r1, r5
 80232dc:	ebc2 1260 	rsb	r2, r2, r0, asr #5
 80232e0:	2064      	movs	r0, #100	; 0x64
 80232e2:	fb00 5212 	mls	r2, r0, r2, r5
 80232e6:	2a00      	cmp	r2, #0
 80232e8:	d14f      	bne.n	802338a <mktime+0x362>
 80232ea:	f205 756c 	addw	r5, r5, #1900	; 0x76c
 80232ee:	fb81 1205 	smull	r1, r2, r1, r5
 80232f2:	17e9      	asrs	r1, r5, #31
 80232f4:	ebc1 11e2 	rsb	r1, r1, r2, asr #7
 80232f8:	f44f 72c8 	mov.w	r2, #400	; 0x190
 80232fc:	fb02 5211 	mls	r2, r2, r1, r5
 8023300:	2a00      	cmp	r2, #0
 8023302:	f240 126d 	movw	r2, #365	; 0x16d
 8023306:	bf08      	it	eq
 8023308:	f44f 72b7 	moveq.w	r2, #366	; 0x16e
 802330c:	429a      	cmp	r2, r3
 802330e:	bfd8      	it	le
 8023310:	1a9b      	suble	r3, r3, r2
 8023312:	61f3      	str	r3, [r6, #28]
 8023314:	4657      	mov	r7, sl
 8023316:	e74d      	b.n	80231b4 <mktime+0x18c>
 8023318:	f44f 73b7 	mov.w	r3, #366	; 0x16e
 802331c:	e7af      	b.n	802327e <mktime+0x256>
 802331e:	2700      	movs	r7, #0
 8023320:	e78f      	b.n	8023242 <mktime+0x21a>
 8023322:	f04f 30ff 	mov.w	r0, #4294967295
 8023326:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802332a:	f240 126d 	movw	r2, #365	; 0x16d
 802332e:	e7ed      	b.n	802330c <mktime+0x2e4>
 8023330:	08029cb4 	.word	0x08029cb4
 8023334:	51eb851f 	.word	0x51eb851f
 8023338:	00015180 	.word	0x00015180
 802333c:	200121cc 	.word	0x200121cc
 8023340:	92492493 	.word	0x92492493
 8023344:	1e68      	subs	r0, r5, #1
 8023346:	0781      	lsls	r1, r0, #30
 8023348:	d122      	bne.n	8023390 <mktime+0x368>
 802334a:	4914      	ldr	r1, [pc, #80]	; (802339c <mktime+0x374>)
 802334c:	17c2      	asrs	r2, r0, #31
 802334e:	fb81 7300 	smull	r7, r3, r1, r0
 8023352:	ebc2 1263 	rsb	r2, r2, r3, asr #5
 8023356:	2364      	movs	r3, #100	; 0x64
 8023358:	fb03 0312 	mls	r3, r3, r2, r0
 802335c:	b9db      	cbnz	r3, 8023396 <mktime+0x36e>
 802335e:	f205 756b 	addw	r5, r5, #1899	; 0x76b
 8023362:	fb81 3105 	smull	r3, r1, r1, r5
 8023366:	17ea      	asrs	r2, r5, #31
 8023368:	ebc2 12e1 	rsb	r2, r2, r1, asr #7
 802336c:	f44f 73c8 	mov.w	r3, #400	; 0x190
 8023370:	fb03 5312 	mls	r3, r3, r2, r5
 8023374:	2b00      	cmp	r3, #0
 8023376:	f240 136d 	movw	r3, #365	; 0x16d
 802337a:	bf18      	it	ne
 802337c:	f44f 73b6 	movne.w	r3, #364	; 0x16c
 8023380:	e7c7      	b.n	8023312 <mktime+0x2ea>
 8023382:	1c98      	adds	r0, r3, #2
 8023384:	bfd8      	it	le
 8023386:	2301      	movle	r3, #1
 8023388:	e79e      	b.n	80232c8 <mktime+0x2a0>
 802338a:	f44f 72b7 	mov.w	r2, #366	; 0x16e
 802338e:	e7bd      	b.n	802330c <mktime+0x2e4>
 8023390:	f44f 73b6 	mov.w	r3, #364	; 0x16c
 8023394:	e7bd      	b.n	8023312 <mktime+0x2ea>
 8023396:	f240 136d 	movw	r3, #365	; 0x16d
 802339a:	e7ba      	b.n	8023312 <mktime+0x2ea>
 802339c:	51eb851f 	.word	0x51eb851f

080233a0 <putenv>:
 80233a0:	4b02      	ldr	r3, [pc, #8]	; (80233ac <putenv+0xc>)
 80233a2:	4601      	mov	r1, r0
 80233a4:	6818      	ldr	r0, [r3, #0]
 80233a6:	f000 b803 	b.w	80233b0 <_putenv_r>
 80233aa:	bf00      	nop
 80233ac:	20010588 	.word	0x20010588

080233b0 <_putenv_r>:
 80233b0:	b570      	push	{r4, r5, r6, lr}
 80233b2:	4606      	mov	r6, r0
 80233b4:	f000 f962 	bl	802367c <_strdup_r>
 80233b8:	b1a0      	cbz	r0, 80233e4 <_putenv_r+0x34>
 80233ba:	213d      	movs	r1, #61	; 0x3d
 80233bc:	4605      	mov	r5, r0
 80233be:	f000 f8f7 	bl	80235b0 <strchr>
 80233c2:	b188      	cbz	r0, 80233e8 <_putenv_r+0x38>
 80233c4:	4602      	mov	r2, r0
 80233c6:	2300      	movs	r3, #0
 80233c8:	f802 3b01 	strb.w	r3, [r2], #1
 80233cc:	4629      	mov	r1, r5
 80233ce:	2301      	movs	r3, #1
 80233d0:	4630      	mov	r0, r6
 80233d2:	f000 f80f 	bl	80233f4 <_setenv_r>
 80233d6:	4629      	mov	r1, r5
 80233d8:	4604      	mov	r4, r0
 80233da:	4630      	mov	r0, r6
 80233dc:	f7f6 fb42 	bl	8019a64 <_free_r>
 80233e0:	4620      	mov	r0, r4
 80233e2:	bd70      	pop	{r4, r5, r6, pc}
 80233e4:	2001      	movs	r0, #1
 80233e6:	bd70      	pop	{r4, r5, r6, pc}
 80233e8:	4630      	mov	r0, r6
 80233ea:	4629      	mov	r1, r5
 80233ec:	f7f6 fb3a 	bl	8019a64 <_free_r>
 80233f0:	2001      	movs	r0, #1
 80233f2:	bd70      	pop	{r4, r5, r6, pc}

080233f4 <_setenv_r>:
 80233f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80233f8:	460d      	mov	r5, r1
 80233fa:	b083      	sub	sp, #12
 80233fc:	4606      	mov	r6, r0
 80233fe:	213d      	movs	r1, #61	; 0x3d
 8023400:	4628      	mov	r0, r5
 8023402:	4614      	mov	r4, r2
 8023404:	461f      	mov	r7, r3
 8023406:	f000 f8d3 	bl	80235b0 <strchr>
 802340a:	2800      	cmp	r0, #0
 802340c:	d17e      	bne.n	802350c <_setenv_r+0x118>
 802340e:	4630      	mov	r0, r6
 8023410:	f000 fd6c 	bl	8023eec <__env_lock>
 8023414:	4620      	mov	r0, r4
 8023416:	f000 f945 	bl	80236a4 <strlen>
 802341a:	4629      	mov	r1, r5
 802341c:	4680      	mov	r8, r0
 802341e:	aa01      	add	r2, sp, #4
 8023420:	4630      	mov	r0, r6
 8023422:	f000 fd6d 	bl	8023f00 <_findenv_r>
 8023426:	4682      	mov	sl, r0
 8023428:	2800      	cmp	r0, #0
 802342a:	d078      	beq.n	802351e <_setenv_r+0x12a>
 802342c:	2f00      	cmp	r7, #0
 802342e:	d052      	beq.n	80234d6 <_setenv_r+0xe2>
 8023430:	f000 f938 	bl	80236a4 <strlen>
 8023434:	4580      	cmp	r8, r0
 8023436:	d955      	bls.n	80234e4 <_setenv_r+0xf0>
 8023438:	9b01      	ldr	r3, [sp, #4]
 802343a:	4f59      	ldr	r7, [pc, #356]	; (80235a0 <_setenv_r+0x1ac>)
 802343c:	ea4f 0983 	mov.w	r9, r3, lsl #2
 8023440:	7829      	ldrb	r1, [r5, #0]
 8023442:	b159      	cbz	r1, 802345c <_setenv_r+0x68>
 8023444:	293d      	cmp	r1, #61	; 0x3d
 8023446:	f000 809f 	beq.w	8023588 <_setenv_r+0x194>
 802344a:	4629      	mov	r1, r5
 802344c:	e001      	b.n	8023452 <_setenv_r+0x5e>
 802344e:	2b3d      	cmp	r3, #61	; 0x3d
 8023450:	d003      	beq.n	802345a <_setenv_r+0x66>
 8023452:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 8023456:	2b00      	cmp	r3, #0
 8023458:	d1f9      	bne.n	802344e <_setenv_r+0x5a>
 802345a:	1b49      	subs	r1, r1, r5
 802345c:	4441      	add	r1, r8
 802345e:	3102      	adds	r1, #2
 8023460:	4630      	mov	r0, r6
 8023462:	f8d7 8000 	ldr.w	r8, [r7]
 8023466:	f8df a138 	ldr.w	sl, [pc, #312]	; 80235a0 <_setenv_r+0x1ac>
 802346a:	f7f6 fad1 	bl	8019a10 <_malloc_r>
 802346e:	f848 0009 	str.w	r0, [r8, r9]
 8023472:	2800      	cmp	r0, #0
 8023474:	f000 808d 	beq.w	8023592 <_setenv_r+0x19e>
 8023478:	9901      	ldr	r1, [sp, #4]
 802347a:	f8da 2000 	ldr.w	r2, [sl]
 802347e:	782b      	ldrb	r3, [r5, #0]
 8023480:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 8023484:	1c69      	adds	r1, r5, #1
 8023486:	7013      	strb	r3, [r2, #0]
 8023488:	b163      	cbz	r3, 80234a4 <_setenv_r+0xb0>
 802348a:	2b3d      	cmp	r3, #61	; 0x3d
 802348c:	d00a      	beq.n	80234a4 <_setenv_r+0xb0>
 802348e:	1c50      	adds	r0, r2, #1
 8023490:	e001      	b.n	8023496 <_setenv_r+0xa2>
 8023492:	2b3d      	cmp	r3, #61	; 0x3d
 8023494:	d006      	beq.n	80234a4 <_setenv_r+0xb0>
 8023496:	f811 3b01 	ldrb.w	r3, [r1], #1
 802349a:	4602      	mov	r2, r0
 802349c:	f800 3b01 	strb.w	r3, [r0], #1
 80234a0:	2b00      	cmp	r3, #0
 80234a2:	d1f6      	bne.n	8023492 <_setenv_r+0x9e>
 80234a4:	233d      	movs	r3, #61	; 0x3d
 80234a6:	7013      	strb	r3, [r2, #0]
 80234a8:	4613      	mov	r3, r2
 80234aa:	f814 2b01 	ldrb.w	r2, [r4], #1
 80234ae:	f803 2f01 	strb.w	r2, [r3, #1]!
 80234b2:	2a00      	cmp	r2, #0
 80234b4:	d1f9      	bne.n	80234aa <_setenv_r+0xb6>
 80234b6:	4630      	mov	r0, r6
 80234b8:	f000 fd1a 	bl	8023ef0 <__env_unlock>
 80234bc:	9a01      	ldr	r2, [sp, #4]
 80234be:	683b      	ldr	r3, [r7, #0]
 80234c0:	4938      	ldr	r1, [pc, #224]	; (80235a4 <_setenv_r+0x1b0>)
 80234c2:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 80234c6:	2203      	movs	r2, #3
 80234c8:	f000 f91a 	bl	8023700 <strncmp>
 80234cc:	b1d8      	cbz	r0, 8023506 <_setenv_r+0x112>
 80234ce:	2000      	movs	r0, #0
 80234d0:	b003      	add	sp, #12
 80234d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80234d6:	4630      	mov	r0, r6
 80234d8:	f000 fd0a 	bl	8023ef0 <__env_unlock>
 80234dc:	4638      	mov	r0, r7
 80234de:	b003      	add	sp, #12
 80234e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80234e4:	f10a 30ff 	add.w	r0, sl, #4294967295
 80234e8:	f814 3b01 	ldrb.w	r3, [r4], #1
 80234ec:	f800 3f01 	strb.w	r3, [r0, #1]!
 80234f0:	2b00      	cmp	r3, #0
 80234f2:	d1f9      	bne.n	80234e8 <_setenv_r+0xf4>
 80234f4:	4630      	mov	r0, r6
 80234f6:	f000 fcfb 	bl	8023ef0 <__env_unlock>
 80234fa:	4628      	mov	r0, r5
 80234fc:	492a      	ldr	r1, [pc, #168]	; (80235a8 <_setenv_r+0x1b4>)
 80234fe:	f7dc ff93 	bl	8000428 <strcmp>
 8023502:	2800      	cmp	r0, #0
 8023504:	d1e3      	bne.n	80234ce <_setenv_r+0xda>
 8023506:	f000 fadf 	bl	8023ac8 <tzset>
 802350a:	e7e0      	b.n	80234ce <_setenv_r+0xda>
 802350c:	f000 fcf2 	bl	8023ef4 <__errno>
 8023510:	2316      	movs	r3, #22
 8023512:	6003      	str	r3, [r0, #0]
 8023514:	f04f 30ff 	mov.w	r0, #4294967295
 8023518:	b003      	add	sp, #12
 802351a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802351e:	4f20      	ldr	r7, [pc, #128]	; (80235a0 <_setenv_r+0x1ac>)
 8023520:	6839      	ldr	r1, [r7, #0]
 8023522:	6808      	ldr	r0, [r1, #0]
 8023524:	b390      	cbz	r0, 802358c <_setenv_r+0x198>
 8023526:	460b      	mov	r3, r1
 8023528:	f853 2f04 	ldr.w	r2, [r3, #4]!
 802352c:	f10a 0a01 	add.w	sl, sl, #1
 8023530:	2a00      	cmp	r2, #0
 8023532:	d1f9      	bne.n	8023528 <_setenv_r+0x134>
 8023534:	f10a 0202 	add.w	r2, sl, #2
 8023538:	0092      	lsls	r2, r2, #2
 802353a:	f8df e070 	ldr.w	lr, [pc, #112]	; 80235ac <_setenv_r+0x1b8>
 802353e:	f8de 3000 	ldr.w	r3, [lr]
 8023542:	b173      	cbz	r3, 8023562 <_setenv_r+0x16e>
 8023544:	4630      	mov	r0, r6
 8023546:	f7f6 fa77 	bl	8019a38 <_realloc_r>
 802354a:	6038      	str	r0, [r7, #0]
 802354c:	b308      	cbz	r0, 8023592 <_setenv_r+0x19e>
 802354e:	ea4f 098a 	mov.w	r9, sl, lsl #2
 8023552:	f10a 0301 	add.w	r3, sl, #1
 8023556:	2200      	movs	r2, #0
 8023558:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 802355c:	f8cd a004 	str.w	sl, [sp, #4]
 8023560:	e76e      	b.n	8023440 <_setenv_r+0x4c>
 8023562:	2301      	movs	r3, #1
 8023564:	4611      	mov	r1, r2
 8023566:	4630      	mov	r0, r6
 8023568:	f8ce 3000 	str.w	r3, [lr]
 802356c:	f7f6 fa50 	bl	8019a10 <_malloc_r>
 8023570:	4683      	mov	fp, r0
 8023572:	b170      	cbz	r0, 8023592 <_setenv_r+0x19e>
 8023574:	ea4f 098a 	mov.w	r9, sl, lsl #2
 8023578:	464a      	mov	r2, r9
 802357a:	6839      	ldr	r1, [r7, #0]
 802357c:	f7dc feae 	bl	80002dc <memcpy>
 8023580:	f8c7 b000 	str.w	fp, [r7]
 8023584:	4658      	mov	r0, fp
 8023586:	e7e4      	b.n	8023552 <_setenv_r+0x15e>
 8023588:	2100      	movs	r1, #0
 802358a:	e767      	b.n	802345c <_setenv_r+0x68>
 802358c:	4682      	mov	sl, r0
 802358e:	2208      	movs	r2, #8
 8023590:	e7d3      	b.n	802353a <_setenv_r+0x146>
 8023592:	4630      	mov	r0, r6
 8023594:	f000 fcac 	bl	8023ef0 <__env_unlock>
 8023598:	f04f 30ff 	mov.w	r0, #4294967295
 802359c:	e79f      	b.n	80234de <_setenv_r+0xea>
 802359e:	bf00      	nop
 80235a0:	20010118 	.word	0x20010118
 80235a4:	08029d78 	.word	0x08029d78
 80235a8:	08029d74 	.word	0x08029d74
 80235ac:	200121ac 	.word	0x200121ac

080235b0 <strchr>:
 80235b0:	b2c9      	uxtb	r1, r1
 80235b2:	b470      	push	{r4, r5, r6}
 80235b4:	2900      	cmp	r1, #0
 80235b6:	d033      	beq.n	8023620 <strchr+0x70>
 80235b8:	0785      	lsls	r5, r0, #30
 80235ba:	d010      	beq.n	80235de <strchr+0x2e>
 80235bc:	7803      	ldrb	r3, [r0, #0]
 80235be:	2b00      	cmp	r3, #0
 80235c0:	d059      	beq.n	8023676 <strchr+0xc6>
 80235c2:	4299      	cmp	r1, r3
 80235c4:	bf18      	it	ne
 80235c6:	1c43      	addne	r3, r0, #1
 80235c8:	d106      	bne.n	80235d8 <strchr+0x28>
 80235ca:	e027      	b.n	802361c <strchr+0x6c>
 80235cc:	f813 2b01 	ldrb.w	r2, [r3], #1
 80235d0:	2a00      	cmp	r2, #0
 80235d2:	d04d      	beq.n	8023670 <strchr+0xc0>
 80235d4:	4291      	cmp	r1, r2
 80235d6:	d021      	beq.n	802361c <strchr+0x6c>
 80235d8:	079a      	lsls	r2, r3, #30
 80235da:	4618      	mov	r0, r3
 80235dc:	d1f6      	bne.n	80235cc <strchr+0x1c>
 80235de:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 80235e2:	6803      	ldr	r3, [r0, #0]
 80235e4:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 80235e8:	e001      	b.n	80235ee <strchr+0x3e>
 80235ea:	f850 3f04 	ldr.w	r3, [r0, #4]!
 80235ee:	ea83 0506 	eor.w	r5, r3, r6
 80235f2:	f1a5 3401 	sub.w	r4, r5, #16843009	; 0x1010101
 80235f6:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 80235fa:	ea24 0405 	bic.w	r4, r4, r5
 80235fe:	ea22 0303 	bic.w	r3, r2, r3
 8023602:	4323      	orrs	r3, r4
 8023604:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8023608:	d0ef      	beq.n	80235ea <strchr+0x3a>
 802360a:	7803      	ldrb	r3, [r0, #0]
 802360c:	b923      	cbnz	r3, 8023618 <strchr+0x68>
 802360e:	e032      	b.n	8023676 <strchr+0xc6>
 8023610:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8023614:	2b00      	cmp	r3, #0
 8023616:	d02e      	beq.n	8023676 <strchr+0xc6>
 8023618:	4299      	cmp	r1, r3
 802361a:	d1f9      	bne.n	8023610 <strchr+0x60>
 802361c:	bc70      	pop	{r4, r5, r6}
 802361e:	4770      	bx	lr
 8023620:	0784      	lsls	r4, r0, #30
 8023622:	d00b      	beq.n	802363c <strchr+0x8c>
 8023624:	7803      	ldrb	r3, [r0, #0]
 8023626:	2b00      	cmp	r3, #0
 8023628:	d0f8      	beq.n	802361c <strchr+0x6c>
 802362a:	1c43      	adds	r3, r0, #1
 802362c:	e003      	b.n	8023636 <strchr+0x86>
 802362e:	7802      	ldrb	r2, [r0, #0]
 8023630:	3301      	adds	r3, #1
 8023632:	2a00      	cmp	r2, #0
 8023634:	d0f2      	beq.n	802361c <strchr+0x6c>
 8023636:	0799      	lsls	r1, r3, #30
 8023638:	4618      	mov	r0, r3
 802363a:	d1f8      	bne.n	802362e <strchr+0x7e>
 802363c:	6802      	ldr	r2, [r0, #0]
 802363e:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 8023642:	ea23 0302 	bic.w	r3, r3, r2
 8023646:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 802364a:	d108      	bne.n	802365e <strchr+0xae>
 802364c:	f850 2f04 	ldr.w	r2, [r0, #4]!
 8023650:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 8023654:	ea23 0302 	bic.w	r3, r3, r2
 8023658:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 802365c:	d0f6      	beq.n	802364c <strchr+0x9c>
 802365e:	7803      	ldrb	r3, [r0, #0]
 8023660:	2b00      	cmp	r3, #0
 8023662:	d0db      	beq.n	802361c <strchr+0x6c>
 8023664:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8023668:	2b00      	cmp	r3, #0
 802366a:	d1fb      	bne.n	8023664 <strchr+0xb4>
 802366c:	bc70      	pop	{r4, r5, r6}
 802366e:	4770      	bx	lr
 8023670:	4610      	mov	r0, r2
 8023672:	bc70      	pop	{r4, r5, r6}
 8023674:	4770      	bx	lr
 8023676:	4618      	mov	r0, r3
 8023678:	bc70      	pop	{r4, r5, r6}
 802367a:	4770      	bx	lr

0802367c <_strdup_r>:
 802367c:	b570      	push	{r4, r5, r6, lr}
 802367e:	4606      	mov	r6, r0
 8023680:	4608      	mov	r0, r1
 8023682:	460d      	mov	r5, r1
 8023684:	f000 f80e 	bl	80236a4 <strlen>
 8023688:	1c44      	adds	r4, r0, #1
 802368a:	4621      	mov	r1, r4
 802368c:	4630      	mov	r0, r6
 802368e:	f7f6 f9bf 	bl	8019a10 <_malloc_r>
 8023692:	4606      	mov	r6, r0
 8023694:	b118      	cbz	r0, 802369e <_strdup_r+0x22>
 8023696:	4629      	mov	r1, r5
 8023698:	4622      	mov	r2, r4
 802369a:	f7dc fe1f 	bl	80002dc <memcpy>
 802369e:	4630      	mov	r0, r6
 80236a0:	bd70      	pop	{r4, r5, r6, pc}
 80236a2:	bf00      	nop

080236a4 <strlen>:
 80236a4:	f020 0103 	bic.w	r1, r0, #3
 80236a8:	f010 0003 	ands.w	r0, r0, #3
 80236ac:	f1c0 0000 	rsb	r0, r0, #0
 80236b0:	f851 3b04 	ldr.w	r3, [r1], #4
 80236b4:	f100 0c04 	add.w	ip, r0, #4
 80236b8:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 80236bc:	f06f 0200 	mvn.w	r2, #0
 80236c0:	bf1c      	itt	ne
 80236c2:	fa22 f20c 	lsrne.w	r2, r2, ip
 80236c6:	4313      	orrne	r3, r2
 80236c8:	f04f 0c01 	mov.w	ip, #1
 80236cc:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 80236d0:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 80236d4:	eba3 020c 	sub.w	r2, r3, ip
 80236d8:	ea22 0203 	bic.w	r2, r2, r3
 80236dc:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 80236e0:	bf04      	itt	eq
 80236e2:	f851 3b04 	ldreq.w	r3, [r1], #4
 80236e6:	3004      	addeq	r0, #4
 80236e8:	d0f4      	beq.n	80236d4 <strlen+0x30>
 80236ea:	f1c2 0100 	rsb	r1, r2, #0
 80236ee:	ea02 0201 	and.w	r2, r2, r1
 80236f2:	fab2 f282 	clz	r2, r2
 80236f6:	f1c2 021f 	rsb	r2, r2, #31
 80236fa:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 80236fe:	4770      	bx	lr

08023700 <strncmp>:
 8023700:	2a00      	cmp	r2, #0
 8023702:	d03e      	beq.n	8023782 <strncmp+0x82>
 8023704:	ea40 0301 	orr.w	r3, r0, r1
 8023708:	f013 0303 	ands.w	r3, r3, #3
 802370c:	b4f0      	push	{r4, r5, r6, r7}
 802370e:	d125      	bne.n	802375c <strncmp+0x5c>
 8023710:	2a03      	cmp	r2, #3
 8023712:	d923      	bls.n	802375c <strncmp+0x5c>
 8023714:	6804      	ldr	r4, [r0, #0]
 8023716:	680d      	ldr	r5, [r1, #0]
 8023718:	42ac      	cmp	r4, r5
 802371a:	d11f      	bne.n	802375c <strncmp+0x5c>
 802371c:	3a04      	subs	r2, #4
 802371e:	d032      	beq.n	8023786 <strncmp+0x86>
 8023720:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 8023724:	ea25 0404 	bic.w	r4, r5, r4
 8023728:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 802372c:	d12e      	bne.n	802378c <strncmp+0x8c>
 802372e:	1d07      	adds	r7, r0, #4
 8023730:	1d0d      	adds	r5, r1, #4
 8023732:	e00d      	b.n	8023750 <strncmp+0x50>
 8023734:	f857 3b04 	ldr.w	r3, [r7], #4
 8023738:	680e      	ldr	r6, [r1, #0]
 802373a:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
 802373e:	42b3      	cmp	r3, r6
 8023740:	ea24 0403 	bic.w	r4, r4, r3
 8023744:	d10a      	bne.n	802375c <strncmp+0x5c>
 8023746:	3a04      	subs	r2, #4
 8023748:	d01d      	beq.n	8023786 <strncmp+0x86>
 802374a:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 802374e:	d120      	bne.n	8023792 <strncmp+0x92>
 8023750:	2a03      	cmp	r2, #3
 8023752:	4629      	mov	r1, r5
 8023754:	4638      	mov	r0, r7
 8023756:	f105 0504 	add.w	r5, r5, #4
 802375a:	d8eb      	bhi.n	8023734 <strncmp+0x34>
 802375c:	7803      	ldrb	r3, [r0, #0]
 802375e:	780c      	ldrb	r4, [r1, #0]
 8023760:	42a3      	cmp	r3, r4
 8023762:	f102 32ff 	add.w	r2, r2, #4294967295
 8023766:	d109      	bne.n	802377c <strncmp+0x7c>
 8023768:	b16a      	cbz	r2, 8023786 <strncmp+0x86>
 802376a:	b17b      	cbz	r3, 802378c <strncmp+0x8c>
 802376c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8023770:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8023774:	42a3      	cmp	r3, r4
 8023776:	f102 32ff 	add.w	r2, r2, #4294967295
 802377a:	d0f5      	beq.n	8023768 <strncmp+0x68>
 802377c:	1b18      	subs	r0, r3, r4
 802377e:	bcf0      	pop	{r4, r5, r6, r7}
 8023780:	4770      	bx	lr
 8023782:	4610      	mov	r0, r2
 8023784:	4770      	bx	lr
 8023786:	4610      	mov	r0, r2
 8023788:	bcf0      	pop	{r4, r5, r6, r7}
 802378a:	4770      	bx	lr
 802378c:	4618      	mov	r0, r3
 802378e:	bcf0      	pop	{r4, r5, r6, r7}
 8023790:	4770      	bx	lr
 8023792:	2000      	movs	r0, #0
 8023794:	e7f3      	b.n	802377e <strncmp+0x7e>
 8023796:	bf00      	nop

08023798 <strncpy>:
 8023798:	ea40 0301 	orr.w	r3, r0, r1
 802379c:	079b      	lsls	r3, r3, #30
 802379e:	b470      	push	{r4, r5, r6}
 80237a0:	d12b      	bne.n	80237fa <strncpy+0x62>
 80237a2:	2a03      	cmp	r2, #3
 80237a4:	d929      	bls.n	80237fa <strncpy+0x62>
 80237a6:	460c      	mov	r4, r1
 80237a8:	4603      	mov	r3, r0
 80237aa:	4621      	mov	r1, r4
 80237ac:	f854 6b04 	ldr.w	r6, [r4], #4
 80237b0:	f1a6 3501 	sub.w	r5, r6, #16843009	; 0x1010101
 80237b4:	ea25 0506 	bic.w	r5, r5, r6
 80237b8:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
 80237bc:	d105      	bne.n	80237ca <strncpy+0x32>
 80237be:	3a04      	subs	r2, #4
 80237c0:	2a03      	cmp	r2, #3
 80237c2:	f843 6b04 	str.w	r6, [r3], #4
 80237c6:	4621      	mov	r1, r4
 80237c8:	d8ef      	bhi.n	80237aa <strncpy+0x12>
 80237ca:	b1a2      	cbz	r2, 80237f6 <strncpy+0x5e>
 80237cc:	780c      	ldrb	r4, [r1, #0]
 80237ce:	701c      	strb	r4, [r3, #0]
 80237d0:	3a01      	subs	r2, #1
 80237d2:	3301      	adds	r3, #1
 80237d4:	3101      	adds	r1, #1
 80237d6:	b13c      	cbz	r4, 80237e8 <strncpy+0x50>
 80237d8:	b16a      	cbz	r2, 80237f6 <strncpy+0x5e>
 80237da:	f811 4b01 	ldrb.w	r4, [r1], #1
 80237de:	f803 4b01 	strb.w	r4, [r3], #1
 80237e2:	3a01      	subs	r2, #1
 80237e4:	2c00      	cmp	r4, #0
 80237e6:	d1f7      	bne.n	80237d8 <strncpy+0x40>
 80237e8:	b12a      	cbz	r2, 80237f6 <strncpy+0x5e>
 80237ea:	441a      	add	r2, r3
 80237ec:	2100      	movs	r1, #0
 80237ee:	f803 1b01 	strb.w	r1, [r3], #1
 80237f2:	4293      	cmp	r3, r2
 80237f4:	d1fb      	bne.n	80237ee <strncpy+0x56>
 80237f6:	bc70      	pop	{r4, r5, r6}
 80237f8:	4770      	bx	lr
 80237fa:	4603      	mov	r3, r0
 80237fc:	e7e5      	b.n	80237ca <strncpy+0x32>
 80237fe:	bf00      	nop

08023800 <_strtol_r>:
 8023800:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023804:	4c44      	ldr	r4, [pc, #272]	; (8023918 <_strtol_r+0x118>)
 8023806:	4683      	mov	fp, r0
 8023808:	460e      	mov	r6, r1
 802380a:	f8d4 e000 	ldr.w	lr, [r4]
 802380e:	e000      	b.n	8023812 <_strtol_r+0x12>
 8023810:	4626      	mov	r6, r4
 8023812:	4634      	mov	r4, r6
 8023814:	f814 5b01 	ldrb.w	r5, [r4], #1
 8023818:	eb0e 0005 	add.w	r0, lr, r5
 802381c:	7840      	ldrb	r0, [r0, #1]
 802381e:	f000 0008 	and.w	r0, r0, #8
 8023822:	f000 08ff 	and.w	r8, r0, #255	; 0xff
 8023826:	2800      	cmp	r0, #0
 8023828:	d1f2      	bne.n	8023810 <_strtol_r+0x10>
 802382a:	2d2d      	cmp	r5, #45	; 0x2d
 802382c:	d04b      	beq.n	80238c6 <_strtol_r+0xc6>
 802382e:	2d2b      	cmp	r5, #43	; 0x2b
 8023830:	bf04      	itt	eq
 8023832:	7875      	ldrbeq	r5, [r6, #1]
 8023834:	1cb4      	addeq	r4, r6, #2
 8023836:	b11b      	cbz	r3, 8023840 <_strtol_r+0x40>
 8023838:	2b10      	cmp	r3, #16
 802383a:	d060      	beq.n	80238fe <_strtol_r+0xfe>
 802383c:	469a      	mov	sl, r3
 802383e:	e003      	b.n	8023848 <_strtol_r+0x48>
 8023840:	2d30      	cmp	r5, #48	; 0x30
 8023842:	d054      	beq.n	80238ee <_strtol_r+0xee>
 8023844:	230a      	movs	r3, #10
 8023846:	469a      	mov	sl, r3
 8023848:	f1b8 0f00 	cmp.w	r8, #0
 802384c:	bf14      	ite	ne
 802384e:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 8023852:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8023856:	2700      	movs	r7, #0
 8023858:	fbb0 f9fa 	udiv	r9, r0, sl
 802385c:	46bc      	mov	ip, r7
 802385e:	fb0a 0019 	mls	r0, sl, r9, r0
 8023862:	e00c      	b.n	802387e <_strtol_r+0x7e>
 8023864:	3d30      	subs	r5, #48	; 0x30
 8023866:	42ab      	cmp	r3, r5
 8023868:	dd19      	ble.n	802389e <_strtol_r+0x9e>
 802386a:	1c7e      	adds	r6, r7, #1
 802386c:	d005      	beq.n	802387a <_strtol_r+0x7a>
 802386e:	45cc      	cmp	ip, r9
 8023870:	d824      	bhi.n	80238bc <_strtol_r+0xbc>
 8023872:	d021      	beq.n	80238b8 <_strtol_r+0xb8>
 8023874:	fb0a 5c0c 	mla	ip, sl, ip, r5
 8023878:	2701      	movs	r7, #1
 802387a:	f814 5b01 	ldrb.w	r5, [r4], #1
 802387e:	eb0e 0605 	add.w	r6, lr, r5
 8023882:	7876      	ldrb	r6, [r6, #1]
 8023884:	f016 0f04 	tst.w	r6, #4
 8023888:	d1ec      	bne.n	8023864 <_strtol_r+0x64>
 802388a:	f016 0603 	ands.w	r6, r6, #3
 802388e:	d006      	beq.n	802389e <_strtol_r+0x9e>
 8023890:	2e01      	cmp	r6, #1
 8023892:	bf0c      	ite	eq
 8023894:	2637      	moveq	r6, #55	; 0x37
 8023896:	2657      	movne	r6, #87	; 0x57
 8023898:	1bad      	subs	r5, r5, r6
 802389a:	42ab      	cmp	r3, r5
 802389c:	dce5      	bgt.n	802386a <_strtol_r+0x6a>
 802389e:	1c7b      	adds	r3, r7, #1
 80238a0:	d016      	beq.n	80238d0 <_strtol_r+0xd0>
 80238a2:	f1c8 0000 	rsb	r0, r8, #0
 80238a6:	ea8c 0000 	eor.w	r0, ip, r0
 80238aa:	4440      	add	r0, r8
 80238ac:	b14a      	cbz	r2, 80238c2 <_strtol_r+0xc2>
 80238ae:	b107      	cbz	r7, 80238b2 <_strtol_r+0xb2>
 80238b0:	1e61      	subs	r1, r4, #1
 80238b2:	6011      	str	r1, [r2, #0]
 80238b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80238b8:	4285      	cmp	r5, r0
 80238ba:	dddb      	ble.n	8023874 <_strtol_r+0x74>
 80238bc:	f04f 37ff 	mov.w	r7, #4294967295
 80238c0:	e7db      	b.n	802387a <_strtol_r+0x7a>
 80238c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80238c6:	1cb4      	adds	r4, r6, #2
 80238c8:	7875      	ldrb	r5, [r6, #1]
 80238ca:	f04f 0801 	mov.w	r8, #1
 80238ce:	e7b2      	b.n	8023836 <_strtol_r+0x36>
 80238d0:	f1b8 0f00 	cmp.w	r8, #0
 80238d4:	f04f 0322 	mov.w	r3, #34	; 0x22
 80238d8:	bf14      	ite	ne
 80238da:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 80238de:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80238e2:	f8cb 3000 	str.w	r3, [fp]
 80238e6:	2a00      	cmp	r2, #0
 80238e8:	d1e2      	bne.n	80238b0 <_strtol_r+0xb0>
 80238ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80238ee:	7823      	ldrb	r3, [r4, #0]
 80238f0:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 80238f4:	2b58      	cmp	r3, #88	; 0x58
 80238f6:	d009      	beq.n	802390c <_strtol_r+0x10c>
 80238f8:	2308      	movs	r3, #8
 80238fa:	469a      	mov	sl, r3
 80238fc:	e7a4      	b.n	8023848 <_strtol_r+0x48>
 80238fe:	2d30      	cmp	r5, #48	; 0x30
 8023900:	d19c      	bne.n	802383c <_strtol_r+0x3c>
 8023902:	7820      	ldrb	r0, [r4, #0]
 8023904:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 8023908:	2858      	cmp	r0, #88	; 0x58
 802390a:	d197      	bne.n	802383c <_strtol_r+0x3c>
 802390c:	f04f 0a10 	mov.w	sl, #16
 8023910:	7865      	ldrb	r5, [r4, #1]
 8023912:	4653      	mov	r3, sl
 8023914:	3402      	adds	r4, #2
 8023916:	e797      	b.n	8023848 <_strtol_r+0x48>
 8023918:	20010114 	.word	0x20010114

0802391c <strtol>:
 802391c:	b430      	push	{r4, r5}
 802391e:	4c04      	ldr	r4, [pc, #16]	; (8023930 <strtol+0x14>)
 8023920:	460d      	mov	r5, r1
 8023922:	4613      	mov	r3, r2
 8023924:	4601      	mov	r1, r0
 8023926:	462a      	mov	r2, r5
 8023928:	6820      	ldr	r0, [r4, #0]
 802392a:	bc30      	pop	{r4, r5}
 802392c:	f7ff bf68 	b.w	8023800 <_strtol_r>
 8023930:	20010588 	.word	0x20010588

08023934 <__tzcalc_limits>:
 8023934:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023938:	b083      	sub	sp, #12
 802393a:	4604      	mov	r4, r0
 802393c:	f000 fb2c 	bl	8023f98 <__gettzinfo>
 8023940:	f240 73b1 	movw	r3, #1969	; 0x7b1
 8023944:	429c      	cmp	r4, r3
 8023946:	f340 8097 	ble.w	8023a78 <__tzcalc_limits+0x144>
 802394a:	4959      	ldr	r1, [pc, #356]	; (8023ab0 <__tzcalc_limits+0x17c>)
 802394c:	f8df c16c 	ldr.w	ip, [pc, #364]	; 8023abc <__tzcalc_limits+0x188>
 8023950:	6044      	str	r4, [r0, #4]
 8023952:	f2a4 736d 	subw	r3, r4, #1901	; 0x76d
 8023956:	f46f 62f6 	mvn.w	r2, #1968	; 0x7b0
 802395a:	eb04 0902 	add.w	r9, r4, r2
 802395e:	fb81 2503 	smull	r2, r5, r1, r3
 8023962:	17db      	asrs	r3, r3, #31
 8023964:	eba3 1365 	sub.w	r3, r3, r5, asr #5
 8023968:	f46f 65c8 	mvn.w	r5, #1600	; 0x640
 802396c:	f2a4 72b2 	subw	r2, r4, #1970	; 0x7b2
 8023970:	1965      	adds	r5, r4, r5
 8023972:	ea4f 06a9 	mov.w	r6, r9, asr #2
 8023976:	f240 196d 	movw	r9, #365	; 0x16d
 802397a:	fb81 7e04 	smull	r7, lr, r1, r4
 802397e:	fb09 6902 	mla	r9, r9, r2, r6
 8023982:	fb81 2105 	smull	r2, r1, r1, r5
 8023986:	17ea      	asrs	r2, r5, #31
 8023988:	17e7      	asrs	r7, r4, #31
 802398a:	444b      	add	r3, r9
 802398c:	ebc2 15e1 	rsb	r5, r2, r1, asr #7
 8023990:	ebc7 16ee 	rsb	r6, r7, lr, asr #7
 8023994:	f44f 78c8 	mov.w	r8, #400	; 0x190
 8023998:	ebc7 176e 	rsb	r7, r7, lr, asr #5
 802399c:	441d      	add	r5, r3
 802399e:	f04f 0e64 	mov.w	lr, #100	; 0x64
 80239a2:	f004 0303 	and.w	r3, r4, #3
 80239a6:	fb08 4616 	mls	r6, r8, r6, r4
 80239aa:	fb0e 4717 	mls	r7, lr, r7, r4
 80239ae:	fab6 f686 	clz	r6, r6
 80239b2:	4604      	mov	r4, r0
 80239b4:	0976      	lsrs	r6, r6, #5
 80239b6:	f100 0e38 	add.w	lr, r0, #56	; 0x38
 80239ba:	469b      	mov	fp, r3
 80239bc:	7a23      	ldrb	r3, [r4, #8]
 80239be:	2b4a      	cmp	r3, #74	; 0x4a
 80239c0:	d05e      	beq.n	8023a80 <__tzcalc_limits+0x14c>
 80239c2:	2b44      	cmp	r3, #68	; 0x44
 80239c4:	d06d      	beq.n	8023aa2 <__tzcalc_limits+0x16e>
 80239c6:	f1bb 0f00 	cmp.w	fp, #0
 80239ca:	d050      	beq.n	8023a6e <__tzcalc_limits+0x13a>
 80239cc:	4633      	mov	r3, r6
 80239ce:	0059      	lsls	r1, r3, #1
 80239d0:	68e2      	ldr	r2, [r4, #12]
 80239d2:	4419      	add	r1, r3
 80239d4:	4b37      	ldr	r3, [pc, #220]	; (8023ab4 <__tzcalc_limits+0x180>)
 80239d6:	2a01      	cmp	r2, #1
 80239d8:	eb03 1101 	add.w	r1, r3, r1, lsl #4
 80239dc:	dd64      	ble.n	8023aa8 <__tzcalc_limits+0x174>
 80239de:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 80239e2:	3a02      	subs	r2, #2
 80239e4:	ea4f 0a82 	mov.w	sl, r2, lsl #2
 80239e8:	eb01 090a 	add.w	r9, r1, sl
 80239ec:	f1a1 0804 	sub.w	r8, r1, #4
 80239f0:	462b      	mov	r3, r5
 80239f2:	f858 2f04 	ldr.w	r2, [r8, #4]!
 80239f6:	45c8      	cmp	r8, r9
 80239f8:	4413      	add	r3, r2
 80239fa:	d1fa      	bne.n	80239f2 <__tzcalc_limits+0xbe>
 80239fc:	f10a 0204 	add.w	r2, sl, #4
 8023a00:	9201      	str	r2, [sp, #4]
 8023a02:	4a2d      	ldr	r2, [pc, #180]	; (8023ab8 <__tzcalc_limits+0x184>)
 8023a04:	f103 0a04 	add.w	sl, r3, #4
 8023a08:	fb8a 8902 	smull	r8, r9, sl, r2
 8023a0c:	44d1      	add	r9, sl
 8023a0e:	ea4f 78ea 	mov.w	r8, sl, asr #31
 8023a12:	ebc8 08a9 	rsb	r8, r8, r9, asr #2
 8023a16:	6962      	ldr	r2, [r4, #20]
 8023a18:	ebc8 08c8 	rsb	r8, r8, r8, lsl #3
 8023a1c:	ebc8 0a0a 	rsb	sl, r8, sl
 8023a20:	ebb2 0a0a 	subs.w	sl, r2, sl
 8023a24:	9a01      	ldr	r2, [sp, #4]
 8023a26:	588a      	ldr	r2, [r1, r2]
 8023a28:	6921      	ldr	r1, [r4, #16]
 8023a2a:	f101 31ff 	add.w	r1, r1, #4294967295
 8023a2e:	bf48      	it	mi
 8023a30:	f10a 0a07 	addmi.w	sl, sl, #7
 8023a34:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 8023a38:	4451      	add	r1, sl
 8023a3a:	4291      	cmp	r1, r2
 8023a3c:	db02      	blt.n	8023a44 <__tzcalc_limits+0x110>
 8023a3e:	3907      	subs	r1, #7
 8023a40:	4291      	cmp	r1, r2
 8023a42:	dafc      	bge.n	8023a3e <__tzcalc_limits+0x10a>
 8023a44:	440b      	add	r3, r1
 8023a46:	69a1      	ldr	r1, [r4, #24]
 8023a48:	6a22      	ldr	r2, [r4, #32]
 8023a4a:	fb0c 1103 	mla	r1, ip, r3, r1
 8023a4e:	4411      	add	r1, r2
 8023a50:	f844 1f1c 	str.w	r1, [r4, #28]!
 8023a54:	4574      	cmp	r4, lr
 8023a56:	d1b1      	bne.n	80239bc <__tzcalc_limits+0x88>
 8023a58:	69c3      	ldr	r3, [r0, #28]
 8023a5a:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8023a5c:	4293      	cmp	r3, r2
 8023a5e:	bfac      	ite	ge
 8023a60:	2300      	movge	r3, #0
 8023a62:	2301      	movlt	r3, #1
 8023a64:	6003      	str	r3, [r0, #0]
 8023a66:	2001      	movs	r0, #1
 8023a68:	b003      	add	sp, #12
 8023a6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8023a6e:	2f00      	cmp	r7, #0
 8023a70:	bf0c      	ite	eq
 8023a72:	4633      	moveq	r3, r6
 8023a74:	2301      	movne	r3, #1
 8023a76:	e7aa      	b.n	80239ce <__tzcalc_limits+0x9a>
 8023a78:	2000      	movs	r0, #0
 8023a7a:	b003      	add	sp, #12
 8023a7c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8023a80:	6962      	ldr	r2, [r4, #20]
 8023a82:	1951      	adds	r1, r2, r5
 8023a84:	f1bb 0f00 	cmp.w	fp, #0
 8023a88:	d107      	bne.n	8023a9a <__tzcalc_limits+0x166>
 8023a8a:	b137      	cbz	r7, 8023a9a <__tzcalc_limits+0x166>
 8023a8c:	2a3b      	cmp	r2, #59	; 0x3b
 8023a8e:	bfd4      	ite	le
 8023a90:	2200      	movle	r2, #0
 8023a92:	2201      	movgt	r2, #1
 8023a94:	4411      	add	r1, r2
 8023a96:	1e4b      	subs	r3, r1, #1
 8023a98:	e7d5      	b.n	8023a46 <__tzcalc_limits+0x112>
 8023a9a:	2e00      	cmp	r6, #0
 8023a9c:	d1f6      	bne.n	8023a8c <__tzcalc_limits+0x158>
 8023a9e:	4632      	mov	r2, r6
 8023aa0:	e7f8      	b.n	8023a94 <__tzcalc_limits+0x160>
 8023aa2:	6961      	ldr	r1, [r4, #20]
 8023aa4:	186b      	adds	r3, r5, r1
 8023aa6:	e7ce      	b.n	8023a46 <__tzcalc_limits+0x112>
 8023aa8:	2200      	movs	r2, #0
 8023aaa:	462b      	mov	r3, r5
 8023aac:	9201      	str	r2, [sp, #4]
 8023aae:	e7a8      	b.n	8023a02 <__tzcalc_limits+0xce>
 8023ab0:	51eb851f 	.word	0x51eb851f
 8023ab4:	08029d14 	.word	0x08029d14
 8023ab8:	92492493 	.word	0x92492493
 8023abc:	00015180 	.word	0x00015180

08023ac0 <__tz_lock>:
 8023ac0:	4770      	bx	lr
 8023ac2:	bf00      	nop

08023ac4 <__tz_unlock>:
 8023ac4:	4770      	bx	lr
 8023ac6:	bf00      	nop

08023ac8 <tzset>:
 8023ac8:	4b01      	ldr	r3, [pc, #4]	; (8023ad0 <tzset+0x8>)
 8023aca:	6818      	ldr	r0, [r3, #0]
 8023acc:	f000 b802 	b.w	8023ad4 <_tzset_r>
 8023ad0:	20010588 	.word	0x20010588

08023ad4 <_tzset_r>:
 8023ad4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023ad8:	b08d      	sub	sp, #52	; 0x34
 8023ada:	4606      	mov	r6, r0
 8023adc:	f000 fa5c 	bl	8023f98 <__gettzinfo>
 8023ae0:	49c7      	ldr	r1, [pc, #796]	; (8023e00 <_tzset_r+0x32c>)
 8023ae2:	4dc8      	ldr	r5, [pc, #800]	; (8023e04 <_tzset_r+0x330>)
 8023ae4:	4682      	mov	sl, r0
 8023ae6:	4630      	mov	r0, r6
 8023ae8:	f000 fa4e 	bl	8023f88 <_getenv_r>
 8023aec:	4604      	mov	r4, r0
 8023aee:	2800      	cmp	r0, #0
 8023af0:	f000 8102 	beq.w	8023cf8 <_tzset_r+0x224>
 8023af4:	f7ff ffe4 	bl	8023ac0 <__tz_lock>
 8023af8:	6829      	ldr	r1, [r5, #0]
 8023afa:	b131      	cbz	r1, 8023b0a <_tzset_r+0x36>
 8023afc:	4620      	mov	r0, r4
 8023afe:	f7dc fc93 	bl	8000428 <strcmp>
 8023b02:	2800      	cmp	r0, #0
 8023b04:	f000 80ec 	beq.w	8023ce0 <_tzset_r+0x20c>
 8023b08:	6829      	ldr	r1, [r5, #0]
 8023b0a:	4608      	mov	r0, r1
 8023b0c:	f7ff f930 	bl	8022d70 <free>
 8023b10:	4620      	mov	r0, r4
 8023b12:	f7ff fdc7 	bl	80236a4 <strlen>
 8023b16:	1c41      	adds	r1, r0, #1
 8023b18:	4630      	mov	r0, r6
 8023b1a:	f7f5 ff79 	bl	8019a10 <_malloc_r>
 8023b1e:	6028      	str	r0, [r5, #0]
 8023b20:	b110      	cbz	r0, 8023b28 <_tzset_r+0x54>
 8023b22:	4621      	mov	r1, r4
 8023b24:	f000 fb40 	bl	80241a8 <strcpy>
 8023b28:	7823      	ldrb	r3, [r4, #0]
 8023b2a:	49b7      	ldr	r1, [pc, #732]	; (8023e08 <_tzset_r+0x334>)
 8023b2c:	4ab7      	ldr	r2, [pc, #732]	; (8023e0c <_tzset_r+0x338>)
 8023b2e:	2b3a      	cmp	r3, #58	; 0x3a
 8023b30:	bf08      	it	eq
 8023b32:	3401      	addeq	r4, #1
 8023b34:	ad0a      	add	r5, sp, #40	; 0x28
 8023b36:	462b      	mov	r3, r5
 8023b38:	4620      	mov	r0, r4
 8023b3a:	f000 fb07 	bl	802414c <siscanf>
 8023b3e:	2800      	cmp	r0, #0
 8023b40:	f340 80ce 	ble.w	8023ce0 <_tzset_r+0x20c>
 8023b44:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8023b46:	5ce2      	ldrb	r2, [r4, r3]
 8023b48:	2a2d      	cmp	r2, #45	; 0x2d
 8023b4a:	441c      	add	r4, r3
 8023b4c:	f000 80d0 	beq.w	8023cf0 <_tzset_r+0x21c>
 8023b50:	2a2b      	cmp	r2, #43	; 0x2b
 8023b52:	bf08      	it	eq
 8023b54:	3401      	addeq	r4, #1
 8023b56:	f04f 0801 	mov.w	r8, #1
 8023b5a:	f10d 061e 	add.w	r6, sp, #30
 8023b5e:	af08      	add	r7, sp, #32
 8023b60:	f04f 0900 	mov.w	r9, #0
 8023b64:	9501      	str	r5, [sp, #4]
 8023b66:	9503      	str	r5, [sp, #12]
 8023b68:	aa07      	add	r2, sp, #28
 8023b6a:	9600      	str	r6, [sp, #0]
 8023b6c:	9702      	str	r7, [sp, #8]
 8023b6e:	4620      	mov	r0, r4
 8023b70:	49a7      	ldr	r1, [pc, #668]	; (8023e10 <_tzset_r+0x33c>)
 8023b72:	f8ad 901e 	strh.w	r9, [sp, #30]
 8023b76:	462b      	mov	r3, r5
 8023b78:	f8ad 9020 	strh.w	r9, [sp, #32]
 8023b7c:	f000 fae6 	bl	802414c <siscanf>
 8023b80:	4548      	cmp	r0, r9
 8023b82:	f340 80ad 	ble.w	8023ce0 <_tzset_r+0x20c>
 8023b86:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8023b8a:	f8bd 1020 	ldrh.w	r1, [sp, #32]
 8023b8e:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 8023b92:	980a      	ldr	r0, [sp, #40]	; 0x28
 8023b94:	f8df c294 	ldr.w	ip, [pc, #660]	; 8023e2c <_tzset_r+0x358>
 8023b98:	f8df b280 	ldr.w	fp, [pc, #640]	; 8023e1c <_tzset_r+0x348>
 8023b9c:	f8cd c014 	str.w	ip, [sp, #20]
 8023ba0:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 8023ba4:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8023ba8:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 8023bac:	fb01 3302 	mla	r3, r1, r2, r3
 8023bb0:	fb08 f303 	mul.w	r3, r8, r3
 8023bb4:	f8ca 3020 	str.w	r3, [sl, #32]
 8023bb8:	4404      	add	r4, r0
 8023bba:	4b94      	ldr	r3, [pc, #592]	; (8023e0c <_tzset_r+0x338>)
 8023bbc:	f8cb 3000 	str.w	r3, [fp]
 8023bc0:	4662      	mov	r2, ip
 8023bc2:	4620      	mov	r0, r4
 8023bc4:	4990      	ldr	r1, [pc, #576]	; (8023e08 <_tzset_r+0x334>)
 8023bc6:	462b      	mov	r3, r5
 8023bc8:	f000 fac0 	bl	802414c <siscanf>
 8023bcc:	4548      	cmp	r0, r9
 8023bce:	f8dd c014 	ldr.w	ip, [sp, #20]
 8023bd2:	f340 8107 	ble.w	8023de4 <_tzset_r+0x310>
 8023bd6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8023bd8:	f8cb c004 	str.w	ip, [fp, #4]
 8023bdc:	5ce2      	ldrb	r2, [r4, r3]
 8023bde:	2a2d      	cmp	r2, #45	; 0x2d
 8023be0:	441c      	add	r4, r3
 8023be2:	f000 809c 	beq.w	8023d1e <_tzset_r+0x24a>
 8023be6:	2a2b      	cmp	r2, #43	; 0x2b
 8023be8:	bf08      	it	eq
 8023bea:	3401      	addeq	r4, #1
 8023bec:	f04f 0801 	mov.w	r8, #1
 8023bf0:	f04f 0e00 	mov.w	lr, #0
 8023bf4:	9600      	str	r6, [sp, #0]
 8023bf6:	9501      	str	r5, [sp, #4]
 8023bf8:	9702      	str	r7, [sp, #8]
 8023bfa:	9503      	str	r5, [sp, #12]
 8023bfc:	4620      	mov	r0, r4
 8023bfe:	4984      	ldr	r1, [pc, #528]	; (8023e10 <_tzset_r+0x33c>)
 8023c00:	f8ad e01c 	strh.w	lr, [sp, #28]
 8023c04:	aa07      	add	r2, sp, #28
 8023c06:	462b      	mov	r3, r5
 8023c08:	f8ad e01e 	strh.w	lr, [sp, #30]
 8023c0c:	f8ad e020 	strh.w	lr, [sp, #32]
 8023c10:	f8cd e028 	str.w	lr, [sp, #40]	; 0x28
 8023c14:	f000 fa9a 	bl	802414c <siscanf>
 8023c18:	2800      	cmp	r0, #0
 8023c1a:	f340 8084 	ble.w	8023d26 <_tzset_r+0x252>
 8023c1e:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8023c22:	f8bd 1020 	ldrh.w	r1, [sp, #32]
 8023c26:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 8023c2a:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 8023c2e:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8023c32:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 8023c36:	fb01 3302 	mla	r3, r1, r2, r3
 8023c3a:	fb08 f303 	mul.w	r3, r8, r3
 8023c3e:	f8ca 303c 	str.w	r3, [sl, #60]	; 0x3c
 8023c42:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8023c44:	46d1      	mov	r9, sl
 8023c46:	441c      	add	r4, r3
 8023c48:	f04f 0b00 	mov.w	fp, #0
 8023c4c:	f894 8000 	ldrb.w	r8, [r4]
 8023c50:	f1b8 0f2c 	cmp.w	r8, #44	; 0x2c
 8023c54:	bf04      	itt	eq
 8023c56:	f894 8001 	ldrbeq.w	r8, [r4, #1]
 8023c5a:	3401      	addeq	r4, #1
 8023c5c:	f1b8 0f4d 	cmp.w	r8, #77	; 0x4d
 8023c60:	d068      	beq.n	8023d34 <_tzset_r+0x260>
 8023c62:	f1b8 0f4a 	cmp.w	r8, #74	; 0x4a
 8023c66:	bf08      	it	eq
 8023c68:	3401      	addeq	r4, #1
 8023c6a:	4620      	mov	r0, r4
 8023c6c:	a90b      	add	r1, sp, #44	; 0x2c
 8023c6e:	f04f 020a 	mov.w	r2, #10
 8023c72:	bf18      	it	ne
 8023c74:	f04f 0844 	movne.w	r8, #68	; 0x44
 8023c78:	f000 fb88 	bl	802438c <strtoul>
 8023c7c:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
 8023c80:	f8ad 0026 	strh.w	r0, [sp, #38]	; 0x26
 8023c84:	45a4      	cmp	ip, r4
 8023c86:	f000 809d 	beq.w	8023dc4 <_tzset_r+0x2f0>
 8023c8a:	b280      	uxth	r0, r0
 8023c8c:	f8c9 0014 	str.w	r0, [r9, #20]
 8023c90:	f889 8008 	strb.w	r8, [r9, #8]
 8023c94:	2400      	movs	r4, #0
 8023c96:	2302      	movs	r3, #2
 8023c98:	f8ad 301c 	strh.w	r3, [sp, #28]
 8023c9c:	f8ad 401e 	strh.w	r4, [sp, #30]
 8023ca0:	f8ad 4020 	strh.w	r4, [sp, #32]
 8023ca4:	940a      	str	r4, [sp, #40]	; 0x28
 8023ca6:	f89c 3000 	ldrb.w	r3, [ip]
 8023caa:	2b2f      	cmp	r3, #47	; 0x2f
 8023cac:	d06c      	beq.n	8023d88 <_tzset_r+0x2b4>
 8023cae:	f44f 53e1 	mov.w	r3, #7200	; 0x1c20
 8023cb2:	f8c9 3018 	str.w	r3, [r9, #24]
 8023cb6:	4464      	add	r4, ip
 8023cb8:	f109 091c 	add.w	r9, r9, #28
 8023cbc:	f1bb 0f00 	cmp.w	fp, #0
 8023cc0:	d013      	beq.n	8023cea <_tzset_r+0x216>
 8023cc2:	f8da 0004 	ldr.w	r0, [sl, #4]
 8023cc6:	f7ff fe35 	bl	8023934 <__tzcalc_limits>
 8023cca:	f8da 2020 	ldr.w	r2, [sl, #32]
 8023cce:	f8da 303c 	ldr.w	r3, [sl, #60]	; 0x3c
 8023cd2:	4850      	ldr	r0, [pc, #320]	; (8023e14 <_tzset_r+0x340>)
 8023cd4:	4950      	ldr	r1, [pc, #320]	; (8023e18 <_tzset_r+0x344>)
 8023cd6:	1ad3      	subs	r3, r2, r3
 8023cd8:	bf18      	it	ne
 8023cda:	2301      	movne	r3, #1
 8023cdc:	6003      	str	r3, [r0, #0]
 8023cde:	600a      	str	r2, [r1, #0]
 8023ce0:	f7ff fef0 	bl	8023ac4 <__tz_unlock>
 8023ce4:	b00d      	add	sp, #52	; 0x34
 8023ce6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8023cea:	f04f 0b01 	mov.w	fp, #1
 8023cee:	e7ad      	b.n	8023c4c <_tzset_r+0x178>
 8023cf0:	3401      	adds	r4, #1
 8023cf2:	f04f 38ff 	mov.w	r8, #4294967295
 8023cf6:	e730      	b.n	8023b5a <_tzset_r+0x86>
 8023cf8:	f7ff fee2 	bl	8023ac0 <__tz_lock>
 8023cfc:	4e46      	ldr	r6, [pc, #280]	; (8023e18 <_tzset_r+0x344>)
 8023cfe:	4b47      	ldr	r3, [pc, #284]	; (8023e1c <_tzset_r+0x348>)
 8023d00:	4944      	ldr	r1, [pc, #272]	; (8023e14 <_tzset_r+0x340>)
 8023d02:	4a47      	ldr	r2, [pc, #284]	; (8023e20 <_tzset_r+0x34c>)
 8023d04:	6828      	ldr	r0, [r5, #0]
 8023d06:	600c      	str	r4, [r1, #0]
 8023d08:	601a      	str	r2, [r3, #0]
 8023d0a:	605a      	str	r2, [r3, #4]
 8023d0c:	6034      	str	r4, [r6, #0]
 8023d0e:	f7ff f82f 	bl	8022d70 <free>
 8023d12:	602c      	str	r4, [r5, #0]
 8023d14:	f7ff fed6 	bl	8023ac4 <__tz_unlock>
 8023d18:	b00d      	add	sp, #52	; 0x34
 8023d1a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8023d1e:	3401      	adds	r4, #1
 8023d20:	f04f 38ff 	mov.w	r8, #4294967295
 8023d24:	e764      	b.n	8023bf0 <_tzset_r+0x11c>
 8023d26:	f8da 3020 	ldr.w	r3, [sl, #32]
 8023d2a:	f5a3 6361 	sub.w	r3, r3, #3600	; 0xe10
 8023d2e:	f8ca 303c 	str.w	r3, [sl, #60]	; 0x3c
 8023d32:	e786      	b.n	8023c42 <_tzset_r+0x16e>
 8023d34:	aa09      	add	r2, sp, #36	; 0x24
 8023d36:	f10d 0326 	add.w	r3, sp, #38	; 0x26
 8023d3a:	9200      	str	r2, [sp, #0]
 8023d3c:	9302      	str	r3, [sp, #8]
 8023d3e:	9501      	str	r5, [sp, #4]
 8023d40:	9503      	str	r5, [sp, #12]
 8023d42:	4620      	mov	r0, r4
 8023d44:	4937      	ldr	r1, [pc, #220]	; (8023e24 <_tzset_r+0x350>)
 8023d46:	f10d 0222 	add.w	r2, sp, #34	; 0x22
 8023d4a:	462b      	mov	r3, r5
 8023d4c:	f000 f9fe 	bl	802414c <siscanf>
 8023d50:	2803      	cmp	r0, #3
 8023d52:	d1c5      	bne.n	8023ce0 <_tzset_r+0x20c>
 8023d54:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
 8023d58:	1e5a      	subs	r2, r3, #1
 8023d5a:	2a0b      	cmp	r2, #11
 8023d5c:	d8c0      	bhi.n	8023ce0 <_tzset_r+0x20c>
 8023d5e:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
 8023d62:	1e51      	subs	r1, r2, #1
 8023d64:	2904      	cmp	r1, #4
 8023d66:	d8bb      	bhi.n	8023ce0 <_tzset_r+0x20c>
 8023d68:	f8bd 1026 	ldrh.w	r1, [sp, #38]	; 0x26
 8023d6c:	2906      	cmp	r1, #6
 8023d6e:	d8b7      	bhi.n	8023ce0 <_tzset_r+0x20c>
 8023d70:	f889 8008 	strb.w	r8, [r9, #8]
 8023d74:	f8c9 300c 	str.w	r3, [r9, #12]
 8023d78:	f8c9 2010 	str.w	r2, [r9, #16]
 8023d7c:	f8c9 1014 	str.w	r1, [r9, #20]
 8023d80:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8023d82:	eb04 0c03 	add.w	ip, r4, r3
 8023d86:	e785      	b.n	8023c94 <_tzset_r+0x1c0>
 8023d88:	4660      	mov	r0, ip
 8023d8a:	4927      	ldr	r1, [pc, #156]	; (8023e28 <_tzset_r+0x354>)
 8023d8c:	9600      	str	r6, [sp, #0]
 8023d8e:	aa07      	add	r2, sp, #28
 8023d90:	462b      	mov	r3, r5
 8023d92:	9501      	str	r5, [sp, #4]
 8023d94:	9702      	str	r7, [sp, #8]
 8023d96:	9503      	str	r5, [sp, #12]
 8023d98:	f8cd c014 	str.w	ip, [sp, #20]
 8023d9c:	f000 f9d6 	bl	802414c <siscanf>
 8023da0:	f8bd 101e 	ldrh.w	r1, [sp, #30]
 8023da4:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 8023da8:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 8023dac:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8023dae:	f8dd c014 	ldr.w	ip, [sp, #20]
 8023db2:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
 8023db6:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8023dba:	f44f 6361 	mov.w	r3, #3600	; 0xe10
 8023dbe:	fb03 1302 	mla	r3, r3, r2, r1
 8023dc2:	e776      	b.n	8023cb2 <_tzset_r+0x1de>
 8023dc4:	f1bb 0f00 	cmp.w	fp, #0
 8023dc8:	d032      	beq.n	8023e30 <_tzset_r+0x35c>
 8023dca:	204d      	movs	r0, #77	; 0x4d
 8023dcc:	210b      	movs	r1, #11
 8023dce:	2201      	movs	r2, #1
 8023dd0:	2300      	movs	r3, #0
 8023dd2:	f88a 0024 	strb.w	r0, [sl, #36]	; 0x24
 8023dd6:	f8ca 1028 	str.w	r1, [sl, #40]	; 0x28
 8023dda:	f8ca 202c 	str.w	r2, [sl, #44]	; 0x2c
 8023dde:	f8ca 3030 	str.w	r3, [sl, #48]	; 0x30
 8023de2:	e757      	b.n	8023c94 <_tzset_r+0x1c0>
 8023de4:	490c      	ldr	r1, [pc, #48]	; (8023e18 <_tzset_r+0x344>)
 8023de6:	4a0b      	ldr	r2, [pc, #44]	; (8023e14 <_tzset_r+0x340>)
 8023de8:	f8da 0020 	ldr.w	r0, [sl, #32]
 8023dec:	f8db 3000 	ldr.w	r3, [fp]
 8023df0:	6008      	str	r0, [r1, #0]
 8023df2:	f8c2 9000 	str.w	r9, [r2]
 8023df6:	f8cb 3004 	str.w	r3, [fp, #4]
 8023dfa:	f7ff fe63 	bl	8023ac4 <__tz_unlock>
 8023dfe:	e771      	b.n	8023ce4 <_tzset_r+0x210>
 8023e00:	08029d74 	.word	0x08029d74
 8023e04:	200121c8 	.word	0x200121c8
 8023e08:	08029d80 	.word	0x08029d80
 8023e0c:	200121bc 	.word	0x200121bc
 8023e10:	08029d90 	.word	0x08029d90
 8023e14:	200121cc 	.word	0x200121cc
 8023e18:	200121d0 	.word	0x200121d0
 8023e1c:	2001010c 	.word	0x2001010c
 8023e20:	08029d7c 	.word	0x08029d7c
 8023e24:	08029da4 	.word	0x08029da4
 8023e28:	08029db8 	.word	0x08029db8
 8023e2c:	200121b0 	.word	0x200121b0
 8023e30:	214d      	movs	r1, #77	; 0x4d
 8023e32:	2203      	movs	r2, #3
 8023e34:	2302      	movs	r3, #2
 8023e36:	f8ca b014 	str.w	fp, [sl, #20]
 8023e3a:	f88a 1008 	strb.w	r1, [sl, #8]
 8023e3e:	f8ca 200c 	str.w	r2, [sl, #12]
 8023e42:	f8ca 3010 	str.w	r3, [sl, #16]
 8023e46:	e725      	b.n	8023c94 <_tzset_r+0x1c0>

08023e48 <asctime>:
 8023e48:	4b02      	ldr	r3, [pc, #8]	; (8023e54 <asctime+0xc>)
 8023e4a:	6819      	ldr	r1, [r3, #0]
 8023e4c:	3160      	adds	r1, #96	; 0x60
 8023e4e:	f000 b803 	b.w	8023e58 <asctime_r>
 8023e52:	bf00      	nop
 8023e54:	20010588 	.word	0x20010588

08023e58 <asctime_r>:
 8023e58:	b5f0      	push	{r4, r5, r6, r7, lr}
 8023e5a:	f8d0 c008 	ldr.w	ip, [r0, #8]
 8023e5e:	6946      	ldr	r6, [r0, #20]
 8023e60:	6985      	ldr	r5, [r0, #24]
 8023e62:	6904      	ldr	r4, [r0, #16]
 8023e64:	68c7      	ldr	r7, [r0, #12]
 8023e66:	4a0e      	ldr	r2, [pc, #56]	; (8023ea0 <asctime_r+0x48>)
 8023e68:	4b0e      	ldr	r3, [pc, #56]	; (8023ea4 <asctime_r+0x4c>)
 8023e6a:	e890 4001 	ldmia.w	r0, {r0, lr}
 8023e6e:	b087      	sub	sp, #28
 8023e70:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8023e74:	9700      	str	r7, [sp, #0]
 8023e76:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8023e7a:	460f      	mov	r7, r1
 8023e7c:	f206 716c 	addw	r1, r6, #1900	; 0x76c
 8023e80:	9104      	str	r1, [sp, #16]
 8023e82:	9003      	str	r0, [sp, #12]
 8023e84:	442a      	add	r2, r5
 8023e86:	4423      	add	r3, r4
 8023e88:	f8cd c004 	str.w	ip, [sp, #4]
 8023e8c:	f8cd e008 	str.w	lr, [sp, #8]
 8023e90:	4638      	mov	r0, r7
 8023e92:	4905      	ldr	r1, [pc, #20]	; (8023ea8 <asctime_r+0x50>)
 8023e94:	f000 f934 	bl	8024100 <siprintf>
 8023e98:	4638      	mov	r0, r7
 8023e9a:	b007      	add	sp, #28
 8023e9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8023e9e:	bf00      	nop
 8023ea0:	08029e10 	.word	0x08029e10
 8023ea4:	08029dcc 	.word	0x08029dcc
 8023ea8:	08029df0 	.word	0x08029df0

08023eac <div>:
 8023eac:	2900      	cmp	r1, #0
 8023eae:	b410      	push	{r4}
 8023eb0:	fb91 f4f2 	sdiv	r4, r1, r2
 8023eb4:	fb02 1314 	mls	r3, r2, r4, r1
 8023eb8:	db06      	blt.n	8023ec8 <div+0x1c>
 8023eba:	2b00      	cmp	r3, #0
 8023ebc:	db0e      	blt.n	8023edc <div+0x30>
 8023ebe:	6004      	str	r4, [r0, #0]
 8023ec0:	6043      	str	r3, [r0, #4]
 8023ec2:	f85d 4b04 	ldr.w	r4, [sp], #4
 8023ec6:	4770      	bx	lr
 8023ec8:	2b00      	cmp	r3, #0
 8023eca:	bfc4      	itt	gt
 8023ecc:	f104 34ff 	addgt.w	r4, r4, #4294967295
 8023ed0:	189b      	addgt	r3, r3, r2
 8023ed2:	6004      	str	r4, [r0, #0]
 8023ed4:	6043      	str	r3, [r0, #4]
 8023ed6:	f85d 4b04 	ldr.w	r4, [sp], #4
 8023eda:	4770      	bx	lr
 8023edc:	3401      	adds	r4, #1
 8023ede:	1a9b      	subs	r3, r3, r2
 8023ee0:	6004      	str	r4, [r0, #0]
 8023ee2:	6043      	str	r3, [r0, #4]
 8023ee4:	f85d 4b04 	ldr.w	r4, [sp], #4
 8023ee8:	4770      	bx	lr
 8023eea:	bf00      	nop

08023eec <__env_lock>:
 8023eec:	4770      	bx	lr
 8023eee:	bf00      	nop

08023ef0 <__env_unlock>:
 8023ef0:	4770      	bx	lr
 8023ef2:	bf00      	nop

08023ef4 <__errno>:
 8023ef4:	4b01      	ldr	r3, [pc, #4]	; (8023efc <__errno+0x8>)
 8023ef6:	6818      	ldr	r0, [r3, #0]
 8023ef8:	4770      	bx	lr
 8023efa:	bf00      	nop
 8023efc:	20010588 	.word	0x20010588

08023f00 <_findenv_r>:
 8023f00:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8023f04:	4e1f      	ldr	r6, [pc, #124]	; (8023f84 <_findenv_r+0x84>)
 8023f06:	460d      	mov	r5, r1
 8023f08:	4690      	mov	r8, r2
 8023f0a:	4607      	mov	r7, r0
 8023f0c:	f7ff ffee 	bl	8023eec <__env_lock>
 8023f10:	f8d6 9000 	ldr.w	r9, [r6]
 8023f14:	f1b9 0f00 	cmp.w	r9, #0
 8023f18:	d020      	beq.n	8023f5c <_findenv_r+0x5c>
 8023f1a:	782c      	ldrb	r4, [r5, #0]
 8023f1c:	b15c      	cbz	r4, 8023f36 <_findenv_r+0x36>
 8023f1e:	2c3d      	cmp	r4, #61	; 0x3d
 8023f20:	bf18      	it	ne
 8023f22:	462c      	movne	r4, r5
 8023f24:	d102      	bne.n	8023f2c <_findenv_r+0x2c>
 8023f26:	e019      	b.n	8023f5c <_findenv_r+0x5c>
 8023f28:	2b3d      	cmp	r3, #61	; 0x3d
 8023f2a:	d017      	beq.n	8023f5c <_findenv_r+0x5c>
 8023f2c:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 8023f30:	2b00      	cmp	r3, #0
 8023f32:	d1f9      	bne.n	8023f28 <_findenv_r+0x28>
 8023f34:	1b64      	subs	r4, r4, r5
 8023f36:	f8d9 0000 	ldr.w	r0, [r9]
 8023f3a:	b178      	cbz	r0, 8023f5c <_findenv_r+0x5c>
 8023f3c:	4629      	mov	r1, r5
 8023f3e:	4622      	mov	r2, r4
 8023f40:	f7ff fbde 	bl	8023700 <strncmp>
 8023f44:	b930      	cbnz	r0, 8023f54 <_findenv_r+0x54>
 8023f46:	f8d9 0000 	ldr.w	r0, [r9]
 8023f4a:	5d03      	ldrb	r3, [r0, r4]
 8023f4c:	2b3d      	cmp	r3, #61	; 0x3d
 8023f4e:	eb00 0a04 	add.w	sl, r0, r4
 8023f52:	d009      	beq.n	8023f68 <_findenv_r+0x68>
 8023f54:	f859 0f04 	ldr.w	r0, [r9, #4]!
 8023f58:	2800      	cmp	r0, #0
 8023f5a:	d1ef      	bne.n	8023f3c <_findenv_r+0x3c>
 8023f5c:	4638      	mov	r0, r7
 8023f5e:	f7ff ffc7 	bl	8023ef0 <__env_unlock>
 8023f62:	2000      	movs	r0, #0
 8023f64:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8023f68:	6833      	ldr	r3, [r6, #0]
 8023f6a:	ebc3 0909 	rsb	r9, r3, r9
 8023f6e:	ea4f 03a9 	mov.w	r3, r9, asr #2
 8023f72:	4638      	mov	r0, r7
 8023f74:	f8c8 3000 	str.w	r3, [r8]
 8023f78:	f7ff ffba 	bl	8023ef0 <__env_unlock>
 8023f7c:	f10a 0001 	add.w	r0, sl, #1
 8023f80:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8023f84:	20010118 	.word	0x20010118

08023f88 <_getenv_r>:
 8023f88:	b500      	push	{lr}
 8023f8a:	b083      	sub	sp, #12
 8023f8c:	aa01      	add	r2, sp, #4
 8023f8e:	f7ff ffb7 	bl	8023f00 <_findenv_r>
 8023f92:	b003      	add	sp, #12
 8023f94:	f85d fb04 	ldr.w	pc, [sp], #4

08023f98 <__gettzinfo>:
 8023f98:	4800      	ldr	r0, [pc, #0]	; (8023f9c <__gettzinfo+0x4>)
 8023f9a:	4770      	bx	lr
 8023f9c:	2001011c 	.word	0x2001011c

08023fa0 <gmtime_r>:
 8023fa0:	6800      	ldr	r0, [r0, #0]
 8023fa2:	4b4c      	ldr	r3, [pc, #304]	; (80240d4 <gmtime_r+0x134>)
 8023fa4:	4a4c      	ldr	r2, [pc, #304]	; (80240d8 <gmtime_r+0x138>)
 8023fa6:	b5f0      	push	{r4, r5, r6, r7, lr}
 8023fa8:	fb83 4300 	smull	r4, r3, r3, r0
 8023fac:	4403      	add	r3, r0
 8023fae:	17c4      	asrs	r4, r0, #31
 8023fb0:	ebc4 4323 	rsb	r3, r4, r3, asr #16
 8023fb4:	fb02 0213 	mls	r2, r2, r3, r0
 8023fb8:	2a00      	cmp	r2, #0
 8023fba:	da04      	bge.n	8023fc6 <gmtime_r+0x26>
 8023fbc:	f502 32a8 	add.w	r2, r2, #86016	; 0x15000
 8023fc0:	f502 72c0 	add.w	r2, r2, #384	; 0x180
 8023fc4:	3b01      	subs	r3, #1
 8023fc6:	4845      	ldr	r0, [pc, #276]	; (80240dc <gmtime_r+0x13c>)
 8023fc8:	4d45      	ldr	r5, [pc, #276]	; (80240e0 <gmtime_r+0x140>)
 8023fca:	4e46      	ldr	r6, [pc, #280]	; (80240e4 <gmtime_r+0x144>)
 8023fcc:	fb80 0e02 	smull	r0, lr, r0, r2
 8023fd0:	eb0e 0002 	add.w	r0, lr, r2
 8023fd4:	ea4f 7ee2 	mov.w	lr, r2, asr #31
 8023fd8:	ebce 2ee0 	rsb	lr, lr, r0, asr #11
 8023fdc:	f44f 6061 	mov.w	r0, #3600	; 0xe10
 8023fe0:	fb00 221e 	mls	r2, r0, lr, r2
 8023fe4:	1d1c      	adds	r4, r3, #4
 8023fe6:	fb85 0502 	smull	r0, r5, r5, r2
 8023fea:	fb84 6706 	smull	r6, r7, r4, r6
 8023fee:	17d0      	asrs	r0, r2, #31
 8023ff0:	4415      	add	r5, r2
 8023ff2:	ebc0 1565 	rsb	r5, r0, r5, asr #5
 8023ff6:	4427      	add	r7, r4
 8023ff8:	17e0      	asrs	r0, r4, #31
 8023ffa:	ebc5 1605 	rsb	r6, r5, r5, lsl #4
 8023ffe:	ebc0 00a7 	rsb	r0, r0, r7, asr #2
 8024002:	eba2 0286 	sub.w	r2, r2, r6, lsl #2
 8024006:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 802400a:	1a20      	subs	r0, r4, r0
 802400c:	e881 4024 	stmia.w	r1, {r2, r5, lr}
 8024010:	4a35      	ldr	r2, [pc, #212]	; (80240e8 <gmtime_r+0x148>)
 8024012:	4c36      	ldr	r4, [pc, #216]	; (80240ec <gmtime_r+0x14c>)
 8024014:	bf48      	it	mi
 8024016:	3007      	addmi	r0, #7
 8024018:	6188      	str	r0, [r1, #24]
 802401a:	fb82 2003 	smull	r2, r0, r2, r3
 802401e:	17da      	asrs	r2, r3, #31
 8024020:	ebc2 12e0 	rsb	r2, r2, r0, asr #7
 8024024:	fb04 3302 	mla	r3, r4, r2, r3
 8024028:	2b00      	cmp	r3, #0
 802402a:	ea4f 0282 	mov.w	r2, r2, lsl #2
 802402e:	f202 72b2 	addw	r2, r2, #1970	; 0x7b2
 8024032:	db46      	blt.n	80240c2 <gmtime_r+0x122>
 8024034:	f5b3 7fb6 	cmp.w	r3, #364	; 0x16c
 8024038:	dd09      	ble.n	802404e <gmtime_r+0xae>
 802403a:	4d2d      	ldr	r5, [pc, #180]	; (80240f0 <gmtime_r+0x150>)
 802403c:	f240 146d 	movw	r4, #365	; 0x16d
 8024040:	1b1b      	subs	r3, r3, r4
 8024042:	f855 4f04 	ldr.w	r4, [r5, #4]!
 8024046:	429c      	cmp	r4, r3
 8024048:	f102 0201 	add.w	r2, r2, #1
 802404c:	ddf8      	ble.n	8024040 <gmtime_r+0xa0>
 802404e:	f2a2 706c 	subw	r0, r2, #1900	; 0x76c
 8024052:	6148      	str	r0, [r1, #20]
 8024054:	0790      	lsls	r0, r2, #30
 8024056:	61cb      	str	r3, [r1, #28]
 8024058:	d026      	beq.n	80240a8 <gmtime_r+0x108>
 802405a:	17d0      	asrs	r0, r2, #31
 802405c:	4c25      	ldr	r4, [pc, #148]	; (80240f4 <gmtime_r+0x154>)
 802405e:	fb84 5402 	smull	r5, r4, r4, r2
 8024062:	ebc0 10e4 	rsb	r0, r0, r4, asr #7
 8024066:	f44f 74c8 	mov.w	r4, #400	; 0x190
 802406a:	fb04 2210 	mls	r2, r4, r0, r2
 802406e:	fab2 f282 	clz	r2, r2
 8024072:	0952      	lsrs	r2, r2, #5
 8024074:	0055      	lsls	r5, r2, #1
 8024076:	4415      	add	r5, r2
 8024078:	012d      	lsls	r5, r5, #4
 802407a:	4c1f      	ldr	r4, [pc, #124]	; (80240f8 <gmtime_r+0x158>)
 802407c:	592a      	ldr	r2, [r5, r4]
 802407e:	2000      	movs	r0, #0
 8024080:	4293      	cmp	r3, r2
 8024082:	4425      	add	r5, r4
 8024084:	6108      	str	r0, [r1, #16]
 8024086:	db09      	blt.n	802409c <gmtime_r+0xfc>
 8024088:	2401      	movs	r4, #1
 802408a:	1a9b      	subs	r3, r3, r2
 802408c:	f855 2f04 	ldr.w	r2, [r5, #4]!
 8024090:	429a      	cmp	r2, r3
 8024092:	4620      	mov	r0, r4
 8024094:	f104 0401 	add.w	r4, r4, #1
 8024098:	ddf7      	ble.n	802408a <gmtime_r+0xea>
 802409a:	6108      	str	r0, [r1, #16]
 802409c:	3301      	adds	r3, #1
 802409e:	2200      	movs	r2, #0
 80240a0:	60cb      	str	r3, [r1, #12]
 80240a2:	620a      	str	r2, [r1, #32]
 80240a4:	4608      	mov	r0, r1
 80240a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80240a8:	4c12      	ldr	r4, [pc, #72]	; (80240f4 <gmtime_r+0x154>)
 80240aa:	17d0      	asrs	r0, r2, #31
 80240ac:	fb84 5402 	smull	r5, r4, r4, r2
 80240b0:	ebc0 1464 	rsb	r4, r0, r4, asr #5
 80240b4:	2564      	movs	r5, #100	; 0x64
 80240b6:	fb05 2414 	mls	r4, r5, r4, r2
 80240ba:	2c00      	cmp	r4, #0
 80240bc:	d0ce      	beq.n	802405c <gmtime_r+0xbc>
 80240be:	2201      	movs	r2, #1
 80240c0:	e7d8      	b.n	8024074 <gmtime_r+0xd4>
 80240c2:	4c0e      	ldr	r4, [pc, #56]	; (80240fc <gmtime_r+0x15c>)
 80240c4:	f854 0904 	ldr.w	r0, [r4], #-4
 80240c8:	181b      	adds	r3, r3, r0
 80240ca:	f102 32ff 	add.w	r2, r2, #4294967295
 80240ce:	d4f9      	bmi.n	80240c4 <gmtime_r+0x124>
 80240d0:	e7bd      	b.n	802404e <gmtime_r+0xae>
 80240d2:	bf00      	nop
 80240d4:	c22e4507 	.word	0xc22e4507
 80240d8:	00015180 	.word	0x00015180
 80240dc:	91a2b3c5 	.word	0x91a2b3c5
 80240e0:	88888889 	.word	0x88888889
 80240e4:	92492493 	.word	0x92492493
 80240e8:	166db073 	.word	0x166db073
 80240ec:	fffffa4b 	.word	0xfffffa4b
 80240f0:	08029f2c 	.word	0x08029f2c
 80240f4:	51eb851f 	.word	0x51eb851f
 80240f8:	08029d14 	.word	0x08029d14
 80240fc:	08029f38 	.word	0x08029f38

08024100 <siprintf>:
 8024100:	b40e      	push	{r1, r2, r3}
 8024102:	b5f0      	push	{r4, r5, r6, r7, lr}
 8024104:	b09c      	sub	sp, #112	; 0x70
 8024106:	ab21      	add	r3, sp, #132	; 0x84
 8024108:	490f      	ldr	r1, [pc, #60]	; (8024148 <siprintf+0x48>)
 802410a:	f853 2b04 	ldr.w	r2, [r3], #4
 802410e:	9301      	str	r3, [sp, #4]
 8024110:	4605      	mov	r5, r0
 8024112:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
 8024116:	6808      	ldr	r0, [r1, #0]
 8024118:	9502      	str	r5, [sp, #8]
 802411a:	f44f 7702 	mov.w	r7, #520	; 0x208
 802411e:	f64f 76ff 	movw	r6, #65535	; 0xffff
 8024122:	a902      	add	r1, sp, #8
 8024124:	9506      	str	r5, [sp, #24]
 8024126:	f8ad 7014 	strh.w	r7, [sp, #20]
 802412a:	9404      	str	r4, [sp, #16]
 802412c:	9407      	str	r4, [sp, #28]
 802412e:	f8ad 6016 	strh.w	r6, [sp, #22]
 8024132:	f000 f9b9 	bl	80244a8 <_svfiprintf_r>
 8024136:	9b02      	ldr	r3, [sp, #8]
 8024138:	2200      	movs	r2, #0
 802413a:	701a      	strb	r2, [r3, #0]
 802413c:	b01c      	add	sp, #112	; 0x70
 802413e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8024142:	b003      	add	sp, #12
 8024144:	4770      	bx	lr
 8024146:	bf00      	nop
 8024148:	20010588 	.word	0x20010588

0802414c <siscanf>:
 802414c:	b40e      	push	{r1, r2, r3}
 802414e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8024150:	b09c      	sub	sp, #112	; 0x70
 8024152:	ac21      	add	r4, sp, #132	; 0x84
 8024154:	f44f 7201 	mov.w	r2, #516	; 0x204
 8024158:	f854 6b04 	ldr.w	r6, [r4], #4
 802415c:	f8ad 2014 	strh.w	r2, [sp, #20]
 8024160:	9002      	str	r0, [sp, #8]
 8024162:	9006      	str	r0, [sp, #24]
 8024164:	f7ff fa9e 	bl	80236a4 <strlen>
 8024168:	4b0c      	ldr	r3, [pc, #48]	; (802419c <siscanf+0x50>)
 802416a:	9401      	str	r4, [sp, #4]
 802416c:	4605      	mov	r5, r0
 802416e:	4632      	mov	r2, r6
 8024170:	4f0b      	ldr	r7, [pc, #44]	; (80241a0 <siscanf+0x54>)
 8024172:	6818      	ldr	r0, [r3, #0]
 8024174:	9503      	str	r5, [sp, #12]
 8024176:	4623      	mov	r3, r4
 8024178:	f64f 76ff 	movw	r6, #65535	; 0xffff
 802417c:	2400      	movs	r4, #0
 802417e:	a902      	add	r1, sp, #8
 8024180:	9507      	str	r5, [sp, #28]
 8024182:	970a      	str	r7, [sp, #40]	; 0x28
 8024184:	940e      	str	r4, [sp, #56]	; 0x38
 8024186:	9413      	str	r4, [sp, #76]	; 0x4c
 8024188:	f8ad 6016 	strh.w	r6, [sp, #22]
 802418c:	f000 ff78 	bl	8025080 <__ssvfiscanf_r>
 8024190:	b01c      	add	sp, #112	; 0x70
 8024192:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8024196:	b003      	add	sp, #12
 8024198:	4770      	bx	lr
 802419a:	bf00      	nop
 802419c:	20010588 	.word	0x20010588
 80241a0:	080241a5 	.word	0x080241a5

080241a4 <__seofread>:
 80241a4:	2000      	movs	r0, #0
 80241a6:	4770      	bx	lr

080241a8 <strcpy>:
 80241a8:	ea80 0201 	eor.w	r2, r0, r1
 80241ac:	4684      	mov	ip, r0
 80241ae:	f012 0f03 	tst.w	r2, #3
 80241b2:	d14f      	bne.n	8024254 <strcpy+0xac>
 80241b4:	f011 0f03 	tst.w	r1, #3
 80241b8:	d132      	bne.n	8024220 <strcpy+0x78>
 80241ba:	f84d 4d04 	str.w	r4, [sp, #-4]!
 80241be:	f011 0f04 	tst.w	r1, #4
 80241c2:	f851 3b04 	ldr.w	r3, [r1], #4
 80241c6:	d00b      	beq.n	80241e0 <strcpy+0x38>
 80241c8:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 80241cc:	439a      	bics	r2, r3
 80241ce:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 80241d2:	bf04      	itt	eq
 80241d4:	f84c 3b04 	streq.w	r3, [ip], #4
 80241d8:	f851 3b04 	ldreq.w	r3, [r1], #4
 80241dc:	d116      	bne.n	802420c <strcpy+0x64>
 80241de:	bf00      	nop
 80241e0:	f851 4b04 	ldr.w	r4, [r1], #4
 80241e4:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 80241e8:	439a      	bics	r2, r3
 80241ea:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 80241ee:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 80241f2:	d10b      	bne.n	802420c <strcpy+0x64>
 80241f4:	f84c 3b04 	str.w	r3, [ip], #4
 80241f8:	43a2      	bics	r2, r4
 80241fa:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 80241fe:	bf04      	itt	eq
 8024200:	f851 3b04 	ldreq.w	r3, [r1], #4
 8024204:	f84c 4b04 	streq.w	r4, [ip], #4
 8024208:	d0ea      	beq.n	80241e0 <strcpy+0x38>
 802420a:	4623      	mov	r3, r4
 802420c:	f80c 3b01 	strb.w	r3, [ip], #1
 8024210:	f013 0fff 	tst.w	r3, #255	; 0xff
 8024214:	ea4f 2333 	mov.w	r3, r3, ror #8
 8024218:	d1f8      	bne.n	802420c <strcpy+0x64>
 802421a:	f85d 4b04 	ldr.w	r4, [sp], #4
 802421e:	4770      	bx	lr
 8024220:	f011 0f01 	tst.w	r1, #1
 8024224:	d006      	beq.n	8024234 <strcpy+0x8c>
 8024226:	f811 2b01 	ldrb.w	r2, [r1], #1
 802422a:	f80c 2b01 	strb.w	r2, [ip], #1
 802422e:	2a00      	cmp	r2, #0
 8024230:	bf08      	it	eq
 8024232:	4770      	bxeq	lr
 8024234:	f011 0f02 	tst.w	r1, #2
 8024238:	d0bf      	beq.n	80241ba <strcpy+0x12>
 802423a:	f831 2b02 	ldrh.w	r2, [r1], #2
 802423e:	f012 0fff 	tst.w	r2, #255	; 0xff
 8024242:	bf16      	itet	ne
 8024244:	f82c 2b02 	strhne.w	r2, [ip], #2
 8024248:	f88c 2000 	strbeq.w	r2, [ip]
 802424c:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
 8024250:	d1b3      	bne.n	80241ba <strcpy+0x12>
 8024252:	4770      	bx	lr
 8024254:	f811 2b01 	ldrb.w	r2, [r1], #1
 8024258:	f80c 2b01 	strb.w	r2, [ip], #1
 802425c:	2a00      	cmp	r2, #0
 802425e:	d1f9      	bne.n	8024254 <strcpy+0xac>
 8024260:	4770      	bx	lr
 8024262:	bf00      	nop

08024264 <_strtoul_r>:
 8024264:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024268:	4c46      	ldr	r4, [pc, #280]	; (8024384 <_strtoul_r+0x120>)
 802426a:	460f      	mov	r7, r1
 802426c:	f8d4 e000 	ldr.w	lr, [r4]
 8024270:	e000      	b.n	8024274 <_strtoul_r+0x10>
 8024272:	4627      	mov	r7, r4
 8024274:	463c      	mov	r4, r7
 8024276:	f814 5b01 	ldrb.w	r5, [r4], #1
 802427a:	eb0e 0605 	add.w	r6, lr, r5
 802427e:	7876      	ldrb	r6, [r6, #1]
 8024280:	f006 0608 	and.w	r6, r6, #8
 8024284:	f006 08ff 	and.w	r8, r6, #255	; 0xff
 8024288:	2e00      	cmp	r6, #0
 802428a:	d1f2      	bne.n	8024272 <_strtoul_r+0xe>
 802428c:	2d2d      	cmp	r5, #45	; 0x2d
 802428e:	d051      	beq.n	8024334 <_strtoul_r+0xd0>
 8024290:	2d2b      	cmp	r5, #43	; 0x2b
 8024292:	bf04      	itt	eq
 8024294:	787d      	ldrbeq	r5, [r7, #1]
 8024296:	1cbc      	addeq	r4, r7, #2
 8024298:	b15b      	cbz	r3, 80242b2 <_strtoul_r+0x4e>
 802429a:	2b10      	cmp	r3, #16
 802429c:	d05b      	beq.n	8024356 <_strtoul_r+0xf2>
 802429e:	f04f 39ff 	mov.w	r9, #4294967295
 80242a2:	fbb9 f9f3 	udiv	r9, r9, r3
 80242a6:	fb03 fb09 	mul.w	fp, r3, r9
 80242aa:	ea6f 0b0b 	mvn.w	fp, fp
 80242ae:	469a      	mov	sl, r3
 80242b0:	e007      	b.n	80242c2 <_strtoul_r+0x5e>
 80242b2:	2d30      	cmp	r5, #48	; 0x30
 80242b4:	d043      	beq.n	802433e <_strtoul_r+0xda>
 80242b6:	230a      	movs	r3, #10
 80242b8:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 8024388 <_strtoul_r+0x124>
 80242bc:	469a      	mov	sl, r3
 80242be:	f04f 0b05 	mov.w	fp, #5
 80242c2:	2700      	movs	r7, #0
 80242c4:	46bc      	mov	ip, r7
 80242c6:	e00c      	b.n	80242e2 <_strtoul_r+0x7e>
 80242c8:	3d30      	subs	r5, #48	; 0x30
 80242ca:	42ab      	cmp	r3, r5
 80242cc:	dd19      	ble.n	8024302 <_strtoul_r+0x9e>
 80242ce:	1c7e      	adds	r6, r7, #1
 80242d0:	d005      	beq.n	80242de <_strtoul_r+0x7a>
 80242d2:	45cc      	cmp	ip, r9
 80242d4:	d824      	bhi.n	8024320 <_strtoul_r+0xbc>
 80242d6:	d021      	beq.n	802431c <_strtoul_r+0xb8>
 80242d8:	fb0a 5c0c 	mla	ip, sl, ip, r5
 80242dc:	2701      	movs	r7, #1
 80242de:	f814 5b01 	ldrb.w	r5, [r4], #1
 80242e2:	eb0e 0605 	add.w	r6, lr, r5
 80242e6:	7876      	ldrb	r6, [r6, #1]
 80242e8:	f016 0f04 	tst.w	r6, #4
 80242ec:	d1ec      	bne.n	80242c8 <_strtoul_r+0x64>
 80242ee:	f016 0603 	ands.w	r6, r6, #3
 80242f2:	d006      	beq.n	8024302 <_strtoul_r+0x9e>
 80242f4:	2e01      	cmp	r6, #1
 80242f6:	bf0c      	ite	eq
 80242f8:	2637      	moveq	r6, #55	; 0x37
 80242fa:	2657      	movne	r6, #87	; 0x57
 80242fc:	1bad      	subs	r5, r5, r6
 80242fe:	42ab      	cmp	r3, r5
 8024300:	dce5      	bgt.n	80242ce <_strtoul_r+0x6a>
 8024302:	2f00      	cmp	r7, #0
 8024304:	db11      	blt.n	802432a <_strtoul_r+0xc6>
 8024306:	f1c8 0000 	rsb	r0, r8, #0
 802430a:	ea8c 0000 	eor.w	r0, ip, r0
 802430e:	4440      	add	r0, r8
 8024310:	b14a      	cbz	r2, 8024326 <_strtoul_r+0xc2>
 8024312:	b107      	cbz	r7, 8024316 <_strtoul_r+0xb2>
 8024314:	1e61      	subs	r1, r4, #1
 8024316:	6011      	str	r1, [r2, #0]
 8024318:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802431c:	455d      	cmp	r5, fp
 802431e:	dddb      	ble.n	80242d8 <_strtoul_r+0x74>
 8024320:	f04f 37ff 	mov.w	r7, #4294967295
 8024324:	e7db      	b.n	80242de <_strtoul_r+0x7a>
 8024326:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802432a:	2322      	movs	r3, #34	; 0x22
 802432c:	6003      	str	r3, [r0, #0]
 802432e:	f04f 30ff 	mov.w	r0, #4294967295
 8024332:	e7ed      	b.n	8024310 <_strtoul_r+0xac>
 8024334:	1cbc      	adds	r4, r7, #2
 8024336:	787d      	ldrb	r5, [r7, #1]
 8024338:	f04f 0801 	mov.w	r8, #1
 802433c:	e7ac      	b.n	8024298 <_strtoul_r+0x34>
 802433e:	7823      	ldrb	r3, [r4, #0]
 8024340:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8024344:	2b58      	cmp	r3, #88	; 0x58
 8024346:	d013      	beq.n	8024370 <_strtoul_r+0x10c>
 8024348:	2308      	movs	r3, #8
 802434a:	469a      	mov	sl, r3
 802434c:	f04f 0b07 	mov.w	fp, #7
 8024350:	f06f 4960 	mvn.w	r9, #3758096384	; 0xe0000000
 8024354:	e7b5      	b.n	80242c2 <_strtoul_r+0x5e>
 8024356:	2d30      	cmp	r5, #48	; 0x30
 8024358:	d005      	beq.n	8024366 <_strtoul_r+0x102>
 802435a:	f04f 0b0f 	mov.w	fp, #15
 802435e:	f06f 4970 	mvn.w	r9, #4026531840	; 0xf0000000
 8024362:	469a      	mov	sl, r3
 8024364:	e7ad      	b.n	80242c2 <_strtoul_r+0x5e>
 8024366:	7826      	ldrb	r6, [r4, #0]
 8024368:	f006 06df 	and.w	r6, r6, #223	; 0xdf
 802436c:	2e58      	cmp	r6, #88	; 0x58
 802436e:	d1f4      	bne.n	802435a <_strtoul_r+0xf6>
 8024370:	f04f 0a10 	mov.w	sl, #16
 8024374:	7865      	ldrb	r5, [r4, #1]
 8024376:	4653      	mov	r3, sl
 8024378:	f04f 0b0f 	mov.w	fp, #15
 802437c:	3402      	adds	r4, #2
 802437e:	f06f 4970 	mvn.w	r9, #4026531840	; 0xf0000000
 8024382:	e79e      	b.n	80242c2 <_strtoul_r+0x5e>
 8024384:	20010114 	.word	0x20010114
 8024388:	19999999 	.word	0x19999999

0802438c <strtoul>:
 802438c:	b430      	push	{r4, r5}
 802438e:	4c04      	ldr	r4, [pc, #16]	; (80243a0 <strtoul+0x14>)
 8024390:	460d      	mov	r5, r1
 8024392:	4613      	mov	r3, r2
 8024394:	4601      	mov	r1, r0
 8024396:	462a      	mov	r2, r5
 8024398:	6820      	ldr	r0, [r4, #0]
 802439a:	bc30      	pop	{r4, r5}
 802439c:	f7ff bf62 	b.w	8024264 <_strtoul_r>
 80243a0:	20010588 	.word	0x20010588

080243a4 <__ssprint_r>:
 80243a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80243a8:	6893      	ldr	r3, [r2, #8]
 80243aa:	f8d2 8000 	ldr.w	r8, [r2]
 80243ae:	b083      	sub	sp, #12
 80243b0:	4691      	mov	r9, r2
 80243b2:	2b00      	cmp	r3, #0
 80243b4:	d072      	beq.n	802449c <__ssprint_r+0xf8>
 80243b6:	4607      	mov	r7, r0
 80243b8:	f04f 0b00 	mov.w	fp, #0
 80243bc:	6808      	ldr	r0, [r1, #0]
 80243be:	688b      	ldr	r3, [r1, #8]
 80243c0:	460d      	mov	r5, r1
 80243c2:	465c      	mov	r4, fp
 80243c4:	2c00      	cmp	r4, #0
 80243c6:	d045      	beq.n	8024454 <__ssprint_r+0xb0>
 80243c8:	429c      	cmp	r4, r3
 80243ca:	461e      	mov	r6, r3
 80243cc:	469a      	mov	sl, r3
 80243ce:	d348      	bcc.n	8024462 <__ssprint_r+0xbe>
 80243d0:	89ab      	ldrh	r3, [r5, #12]
 80243d2:	f413 6f90 	tst.w	r3, #1152	; 0x480
 80243d6:	d02d      	beq.n	8024434 <__ssprint_r+0x90>
 80243d8:	696e      	ldr	r6, [r5, #20]
 80243da:	6929      	ldr	r1, [r5, #16]
 80243dc:	eb06 0646 	add.w	r6, r6, r6, lsl #1
 80243e0:	ebc1 0a00 	rsb	sl, r1, r0
 80243e4:	eb06 76d6 	add.w	r6, r6, r6, lsr #31
 80243e8:	1c60      	adds	r0, r4, #1
 80243ea:	1076      	asrs	r6, r6, #1
 80243ec:	4450      	add	r0, sl
 80243ee:	4286      	cmp	r6, r0
 80243f0:	4632      	mov	r2, r6
 80243f2:	bf3c      	itt	cc
 80243f4:	4606      	movcc	r6, r0
 80243f6:	4632      	movcc	r2, r6
 80243f8:	055b      	lsls	r3, r3, #21
 80243fa:	d535      	bpl.n	8024468 <__ssprint_r+0xc4>
 80243fc:	4611      	mov	r1, r2
 80243fe:	4638      	mov	r0, r7
 8024400:	f7f5 fb06 	bl	8019a10 <_malloc_r>
 8024404:	2800      	cmp	r0, #0
 8024406:	d039      	beq.n	802447c <__ssprint_r+0xd8>
 8024408:	4652      	mov	r2, sl
 802440a:	6929      	ldr	r1, [r5, #16]
 802440c:	9001      	str	r0, [sp, #4]
 802440e:	f7db ff65 	bl	80002dc <memcpy>
 8024412:	89aa      	ldrh	r2, [r5, #12]
 8024414:	9b01      	ldr	r3, [sp, #4]
 8024416:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 802441a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 802441e:	81aa      	strh	r2, [r5, #12]
 8024420:	ebca 0206 	rsb	r2, sl, r6
 8024424:	eb03 000a 	add.w	r0, r3, sl
 8024428:	616e      	str	r6, [r5, #20]
 802442a:	612b      	str	r3, [r5, #16]
 802442c:	6028      	str	r0, [r5, #0]
 802442e:	60aa      	str	r2, [r5, #8]
 8024430:	4626      	mov	r6, r4
 8024432:	46a2      	mov	sl, r4
 8024434:	4652      	mov	r2, sl
 8024436:	4659      	mov	r1, fp
 8024438:	f001 fbe0 	bl	8025bfc <memmove>
 802443c:	f8d9 2008 	ldr.w	r2, [r9, #8]
 8024440:	68ab      	ldr	r3, [r5, #8]
 8024442:	6828      	ldr	r0, [r5, #0]
 8024444:	1b9b      	subs	r3, r3, r6
 8024446:	4450      	add	r0, sl
 8024448:	1b14      	subs	r4, r2, r4
 802444a:	60ab      	str	r3, [r5, #8]
 802444c:	6028      	str	r0, [r5, #0]
 802444e:	f8c9 4008 	str.w	r4, [r9, #8]
 8024452:	b31c      	cbz	r4, 802449c <__ssprint_r+0xf8>
 8024454:	f8d8 b000 	ldr.w	fp, [r8]
 8024458:	f8d8 4004 	ldr.w	r4, [r8, #4]
 802445c:	f108 0808 	add.w	r8, r8, #8
 8024460:	e7b0      	b.n	80243c4 <__ssprint_r+0x20>
 8024462:	4626      	mov	r6, r4
 8024464:	46a2      	mov	sl, r4
 8024466:	e7e5      	b.n	8024434 <__ssprint_r+0x90>
 8024468:	4638      	mov	r0, r7
 802446a:	f7f5 fae5 	bl	8019a38 <_realloc_r>
 802446e:	4603      	mov	r3, r0
 8024470:	2800      	cmp	r0, #0
 8024472:	d1d5      	bne.n	8024420 <__ssprint_r+0x7c>
 8024474:	4638      	mov	r0, r7
 8024476:	6929      	ldr	r1, [r5, #16]
 8024478:	f7f5 faf4 	bl	8019a64 <_free_r>
 802447c:	230c      	movs	r3, #12
 802447e:	603b      	str	r3, [r7, #0]
 8024480:	89ab      	ldrh	r3, [r5, #12]
 8024482:	2200      	movs	r2, #0
 8024484:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8024488:	f04f 30ff 	mov.w	r0, #4294967295
 802448c:	81ab      	strh	r3, [r5, #12]
 802448e:	f8c9 2008 	str.w	r2, [r9, #8]
 8024492:	f8c9 2004 	str.w	r2, [r9, #4]
 8024496:	b003      	add	sp, #12
 8024498:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802449c:	2000      	movs	r0, #0
 802449e:	f8c9 0004 	str.w	r0, [r9, #4]
 80244a2:	b003      	add	sp, #12
 80244a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080244a8 <_svfiprintf_r>:
 80244a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80244ac:	4691      	mov	r9, r2
 80244ae:	898a      	ldrh	r2, [r1, #12]
 80244b0:	b0ad      	sub	sp, #180	; 0xb4
 80244b2:	0612      	lsls	r2, r2, #24
 80244b4:	468a      	mov	sl, r1
 80244b6:	9306      	str	r3, [sp, #24]
 80244b8:	9004      	str	r0, [sp, #16]
 80244ba:	d503      	bpl.n	80244c4 <_svfiprintf_r+0x1c>
 80244bc:	690b      	ldr	r3, [r1, #16]
 80244be:	2b00      	cmp	r3, #0
 80244c0:	f000 850f 	beq.w	8024ee2 <_svfiprintf_r+0xa3a>
 80244c4:	2300      	movs	r3, #0
 80244c6:	f10d 0870 	add.w	r8, sp, #112	; 0x70
 80244ca:	930a      	str	r3, [sp, #40]	; 0x28
 80244cc:	9311      	str	r3, [sp, #68]	; 0x44
 80244ce:	9310      	str	r3, [sp, #64]	; 0x40
 80244d0:	9303      	str	r3, [sp, #12]
 80244d2:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
 80244d6:	4644      	mov	r4, r8
 80244d8:	f899 3000 	ldrb.w	r3, [r9]
 80244dc:	2b00      	cmp	r3, #0
 80244de:	f000 8382 	beq.w	8024be6 <_svfiprintf_r+0x73e>
 80244e2:	2b25      	cmp	r3, #37	; 0x25
 80244e4:	f000 837f 	beq.w	8024be6 <_svfiprintf_r+0x73e>
 80244e8:	464a      	mov	r2, r9
 80244ea:	e001      	b.n	80244f0 <_svfiprintf_r+0x48>
 80244ec:	2b25      	cmp	r3, #37	; 0x25
 80244ee:	d003      	beq.n	80244f8 <_svfiprintf_r+0x50>
 80244f0:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 80244f4:	2b00      	cmp	r3, #0
 80244f6:	d1f9      	bne.n	80244ec <_svfiprintf_r+0x44>
 80244f8:	ebc9 0602 	rsb	r6, r9, r2
 80244fc:	4615      	mov	r5, r2
 80244fe:	b17e      	cbz	r6, 8024520 <_svfiprintf_r+0x78>
 8024500:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8024502:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8024504:	f8c4 9000 	str.w	r9, [r4]
 8024508:	3301      	adds	r3, #1
 802450a:	4432      	add	r2, r6
 802450c:	2b07      	cmp	r3, #7
 802450e:	6066      	str	r6, [r4, #4]
 8024510:	9211      	str	r2, [sp, #68]	; 0x44
 8024512:	9310      	str	r3, [sp, #64]	; 0x40
 8024514:	f300 83fb 	bgt.w	8024d0e <_svfiprintf_r+0x866>
 8024518:	3408      	adds	r4, #8
 802451a:	9b03      	ldr	r3, [sp, #12]
 802451c:	4433      	add	r3, r6
 802451e:	9303      	str	r3, [sp, #12]
 8024520:	782b      	ldrb	r3, [r5, #0]
 8024522:	2b00      	cmp	r3, #0
 8024524:	f000 8384 	beq.w	8024c30 <_svfiprintf_r+0x788>
 8024528:	2100      	movs	r1, #0
 802452a:	f04f 32ff 	mov.w	r2, #4294967295
 802452e:	1c68      	adds	r0, r5, #1
 8024530:	786b      	ldrb	r3, [r5, #1]
 8024532:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 8024536:	9100      	str	r1, [sp, #0]
 8024538:	9201      	str	r2, [sp, #4]
 802453a:	460d      	mov	r5, r1
 802453c:	f100 0901 	add.w	r9, r0, #1
 8024540:	f1a3 0220 	sub.w	r2, r3, #32
 8024544:	2a58      	cmp	r2, #88	; 0x58
 8024546:	f200 8286 	bhi.w	8024a56 <_svfiprintf_r+0x5ae>
 802454a:	e8df f012 	tbh	[pc, r2, lsl #1]
 802454e:	01e0      	.short	0x01e0
 8024550:	02840284 	.word	0x02840284
 8024554:	028401d8 	.word	0x028401d8
 8024558:	02840284 	.word	0x02840284
 802455c:	02840284 	.word	0x02840284
 8024560:	02530284 	.word	0x02530284
 8024564:	0284024e 	.word	0x0284024e
 8024568:	026700b7 	.word	0x026700b7
 802456c:	02460284 	.word	0x02460284
 8024570:	02380238 	.word	0x02380238
 8024574:	02380238 	.word	0x02380238
 8024578:	02380238 	.word	0x02380238
 802457c:	02380238 	.word	0x02380238
 8024580:	02840238 	.word	0x02840238
 8024584:	02840284 	.word	0x02840284
 8024588:	02840284 	.word	0x02840284
 802458c:	02840284 	.word	0x02840284
 8024590:	02840284 	.word	0x02840284
 8024594:	021c0284 	.word	0x021c0284
 8024598:	02840284 	.word	0x02840284
 802459c:	02840284 	.word	0x02840284
 80245a0:	02840284 	.word	0x02840284
 80245a4:	02840284 	.word	0x02840284
 80245a8:	02840284 	.word	0x02840284
 80245ac:	02840200 	.word	0x02840200
 80245b0:	02840284 	.word	0x02840284
 80245b4:	02840284 	.word	0x02840284
 80245b8:	028401c3 	.word	0x028401c3
 80245bc:	019f0284 	.word	0x019f0284
 80245c0:	02840284 	.word	0x02840284
 80245c4:	02840284 	.word	0x02840284
 80245c8:	02840284 	.word	0x02840284
 80245cc:	02840284 	.word	0x02840284
 80245d0:	02840284 	.word	0x02840284
 80245d4:	01270143 	.word	0x01270143
 80245d8:	02840284 	.word	0x02840284
 80245dc:	011f0284 	.word	0x011f0284
 80245e0:	02840127 	.word	0x02840127
 80245e4:	01140284 	.word	0x01140284
 80245e8:	00fe0284 	.word	0x00fe0284
 80245ec:	00e900a6 	.word	0x00e900a6
 80245f0:	028400e1 	.word	0x028400e1
 80245f4:	028400bf 	.word	0x028400bf
 80245f8:	02840059 	.word	0x02840059
 80245fc:	01e80284 	.word	0x01e80284
 8024600:	9b00      	ldr	r3, [sp, #0]
 8024602:	9505      	str	r5, [sp, #20]
 8024604:	069a      	lsls	r2, r3, #26
 8024606:	f140 816e 	bpl.w	80248e6 <_svfiprintf_r+0x43e>
 802460a:	9b06      	ldr	r3, [sp, #24]
 802460c:	3307      	adds	r3, #7
 802460e:	f023 0307 	bic.w	r3, r3, #7
 8024612:	f103 0208 	add.w	r2, r3, #8
 8024616:	e9d3 6700 	ldrd	r6, r7, [r3]
 802461a:	9206      	str	r2, [sp, #24]
 802461c:	2301      	movs	r3, #1
 802461e:	2200      	movs	r2, #0
 8024620:	f88d 2037 	strb.w	r2, [sp, #55]	; 0x37
 8024624:	9a01      	ldr	r2, [sp, #4]
 8024626:	9202      	str	r2, [sp, #8]
 8024628:	f04f 0b00 	mov.w	fp, #0
 802462c:	9a01      	ldr	r2, [sp, #4]
 802462e:	2a00      	cmp	r2, #0
 8024630:	db03      	blt.n	802463a <_svfiprintf_r+0x192>
 8024632:	9a00      	ldr	r2, [sp, #0]
 8024634:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8024638:	9200      	str	r2, [sp, #0]
 802463a:	ea56 0207 	orrs.w	r2, r6, r7
 802463e:	f040 82d4 	bne.w	8024bea <_svfiprintf_r+0x742>
 8024642:	9a01      	ldr	r2, [sp, #4]
 8024644:	2a00      	cmp	r2, #0
 8024646:	f000 8350 	beq.w	8024cea <_svfiprintf_r+0x842>
 802464a:	2b01      	cmp	r3, #1
 802464c:	f000 83b2 	beq.w	8024db4 <_svfiprintf_r+0x90c>
 8024650:	2b02      	cmp	r3, #2
 8024652:	f000 8371 	beq.w	8024d38 <_svfiprintf_r+0x890>
 8024656:	4641      	mov	r1, r8
 8024658:	08f2      	lsrs	r2, r6, #3
 802465a:	ea42 7247 	orr.w	r2, r2, r7, lsl #29
 802465e:	08f8      	lsrs	r0, r7, #3
 8024660:	f006 0307 	and.w	r3, r6, #7
 8024664:	4607      	mov	r7, r0
 8024666:	4616      	mov	r6, r2
 8024668:	3330      	adds	r3, #48	; 0x30
 802466a:	ea56 0207 	orrs.w	r2, r6, r7
 802466e:	f801 3d01 	strb.w	r3, [r1, #-1]!
 8024672:	d1f1      	bne.n	8024658 <_svfiprintf_r+0x1b0>
 8024674:	9a00      	ldr	r2, [sp, #0]
 8024676:	9109      	str	r1, [sp, #36]	; 0x24
 8024678:	07d0      	lsls	r0, r2, #31
 802467a:	f140 8397 	bpl.w	8024dac <_svfiprintf_r+0x904>
 802467e:	2b30      	cmp	r3, #48	; 0x30
 8024680:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8024682:	f000 82d1 	beq.w	8024c28 <_svfiprintf_r+0x780>
 8024686:	3b01      	subs	r3, #1
 8024688:	461a      	mov	r2, r3
 802468a:	9309      	str	r3, [sp, #36]	; 0x24
 802468c:	ebc2 0208 	rsb	r2, r2, r8
 8024690:	2330      	movs	r3, #48	; 0x30
 8024692:	9202      	str	r2, [sp, #8]
 8024694:	f801 3c01 	strb.w	r3, [r1, #-1]
 8024698:	e32d      	b.n	8024cf6 <_svfiprintf_r+0x84e>
 802469a:	9b00      	ldr	r3, [sp, #0]
 802469c:	9505      	str	r5, [sp, #20]
 802469e:	f013 0320 	ands.w	r3, r3, #32
 80246a2:	f000 815e 	beq.w	8024962 <_svfiprintf_r+0x4ba>
 80246a6:	9b06      	ldr	r3, [sp, #24]
 80246a8:	3307      	adds	r3, #7
 80246aa:	f023 0307 	bic.w	r3, r3, #7
 80246ae:	f103 0208 	add.w	r2, r3, #8
 80246b2:	e9d3 6700 	ldrd	r6, r7, [r3]
 80246b6:	9206      	str	r2, [sp, #24]
 80246b8:	2300      	movs	r3, #0
 80246ba:	e7b0      	b.n	802461e <_svfiprintf_r+0x176>
 80246bc:	4648      	mov	r0, r9
 80246be:	9b00      	ldr	r3, [sp, #0]
 80246c0:	f043 0304 	orr.w	r3, r3, #4
 80246c4:	9300      	str	r3, [sp, #0]
 80246c6:	f899 3000 	ldrb.w	r3, [r9]
 80246ca:	e737      	b.n	802453c <_svfiprintf_r+0x94>
 80246cc:	9a06      	ldr	r2, [sp, #24]
 80246ce:	9505      	str	r5, [sp, #20]
 80246d0:	6813      	ldr	r3, [r2, #0]
 80246d2:	9309      	str	r3, [sp, #36]	; 0x24
 80246d4:	2100      	movs	r1, #0
 80246d6:	1d16      	adds	r6, r2, #4
 80246d8:	9a01      	ldr	r2, [sp, #4]
 80246da:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 80246de:	9202      	str	r2, [sp, #8]
 80246e0:	2b00      	cmp	r3, #0
 80246e2:	f000 83f3 	beq.w	8024ecc <_svfiprintf_r+0xa24>
 80246e6:	9b01      	ldr	r3, [sp, #4]
 80246e8:	2b00      	cmp	r3, #0
 80246ea:	f2c0 83e5 	blt.w	8024eb8 <_svfiprintf_r+0xa10>
 80246ee:	9d09      	ldr	r5, [sp, #36]	; 0x24
 80246f0:	461a      	mov	r2, r3
 80246f2:	4628      	mov	r0, r5
 80246f4:	2100      	movs	r1, #0
 80246f6:	f001 fa37 	bl	8025b68 <memchr>
 80246fa:	2800      	cmp	r0, #0
 80246fc:	f000 8402 	beq.w	8024f04 <_svfiprintf_r+0xa5c>
 8024700:	1b43      	subs	r3, r0, r5
 8024702:	9302      	str	r3, [sp, #8]
 8024704:	2300      	movs	r3, #0
 8024706:	9606      	str	r6, [sp, #24]
 8024708:	f89d b037 	ldrb.w	fp, [sp, #55]	; 0x37
 802470c:	9301      	str	r3, [sp, #4]
 802470e:	e2f2      	b.n	8024cf6 <_svfiprintf_r+0x84e>
 8024710:	9b00      	ldr	r3, [sp, #0]
 8024712:	f043 0320 	orr.w	r3, r3, #32
 8024716:	9300      	str	r3, [sp, #0]
 8024718:	f899 3000 	ldrb.w	r3, [r9]
 802471c:	4648      	mov	r0, r9
 802471e:	e70d      	b.n	802453c <_svfiprintf_r+0x94>
 8024720:	9806      	ldr	r0, [sp, #24]
 8024722:	9900      	ldr	r1, [sp, #0]
 8024724:	9505      	str	r5, [sp, #20]
 8024726:	2330      	movs	r3, #48	; 0x30
 8024728:	4602      	mov	r2, r0
 802472a:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
 802472e:	2378      	movs	r3, #120	; 0x78
 8024730:	f041 0102 	orr.w	r1, r1, #2
 8024734:	3204      	adds	r2, #4
 8024736:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
 802473a:	4bb5      	ldr	r3, [pc, #724]	; (8024a10 <_svfiprintf_r+0x568>)
 802473c:	930a      	str	r3, [sp, #40]	; 0x28
 802473e:	6806      	ldr	r6, [r0, #0]
 8024740:	9100      	str	r1, [sp, #0]
 8024742:	9206      	str	r2, [sp, #24]
 8024744:	2700      	movs	r7, #0
 8024746:	2302      	movs	r3, #2
 8024748:	e769      	b.n	802461e <_svfiprintf_r+0x176>
 802474a:	9b00      	ldr	r3, [sp, #0]
 802474c:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 8024750:	069d      	lsls	r5, r3, #26
 8024752:	f100 837f 	bmi.w	8024e54 <_svfiprintf_r+0x9ac>
 8024756:	9b00      	ldr	r3, [sp, #0]
 8024758:	06d8      	lsls	r0, r3, #27
 802475a:	f100 8394 	bmi.w	8024e86 <_svfiprintf_r+0x9de>
 802475e:	9b00      	ldr	r3, [sp, #0]
 8024760:	0659      	lsls	r1, r3, #25
 8024762:	f140 8390 	bpl.w	8024e86 <_svfiprintf_r+0x9de>
 8024766:	9a06      	ldr	r2, [sp, #24]
 8024768:	6813      	ldr	r3, [r2, #0]
 802476a:	3204      	adds	r2, #4
 802476c:	9206      	str	r2, [sp, #24]
 802476e:	f8bd 200c 	ldrh.w	r2, [sp, #12]
 8024772:	801a      	strh	r2, [r3, #0]
 8024774:	e6b0      	b.n	80244d8 <_svfiprintf_r+0x30>
 8024776:	f899 3000 	ldrb.w	r3, [r9]
 802477a:	2b6c      	cmp	r3, #108	; 0x6c
 802477c:	4648      	mov	r0, r9
 802477e:	f000 8375 	beq.w	8024e6c <_svfiprintf_r+0x9c4>
 8024782:	9a00      	ldr	r2, [sp, #0]
 8024784:	f042 0210 	orr.w	r2, r2, #16
 8024788:	9200      	str	r2, [sp, #0]
 802478a:	e6d7      	b.n	802453c <_svfiprintf_r+0x94>
 802478c:	9b00      	ldr	r3, [sp, #0]
 802478e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8024792:	9300      	str	r3, [sp, #0]
 8024794:	f899 3000 	ldrb.w	r3, [r9]
 8024798:	4648      	mov	r0, r9
 802479a:	e6cf      	b.n	802453c <_svfiprintf_r+0x94>
 802479c:	9b00      	ldr	r3, [sp, #0]
 802479e:	9505      	str	r5, [sp, #20]
 80247a0:	069b      	lsls	r3, r3, #26
 80247a2:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 80247a6:	f140 80f9 	bpl.w	802499c <_svfiprintf_r+0x4f4>
 80247aa:	9906      	ldr	r1, [sp, #24]
 80247ac:	3107      	adds	r1, #7
 80247ae:	f021 0107 	bic.w	r1, r1, #7
 80247b2:	e9d1 2300 	ldrd	r2, r3, [r1]
 80247b6:	3108      	adds	r1, #8
 80247b8:	9106      	str	r1, [sp, #24]
 80247ba:	4616      	mov	r6, r2
 80247bc:	461f      	mov	r7, r3
 80247be:	2a00      	cmp	r2, #0
 80247c0:	f173 0300 	sbcs.w	r3, r3, #0
 80247c4:	f2c0 8326 	blt.w	8024e14 <_svfiprintf_r+0x96c>
 80247c8:	9b01      	ldr	r3, [sp, #4]
 80247ca:	9302      	str	r3, [sp, #8]
 80247cc:	f89d b037 	ldrb.w	fp, [sp, #55]	; 0x37
 80247d0:	2301      	movs	r3, #1
 80247d2:	e72b      	b.n	802462c <_svfiprintf_r+0x184>
 80247d4:	9a06      	ldr	r2, [sp, #24]
 80247d6:	9505      	str	r5, [sp, #20]
 80247d8:	6813      	ldr	r3, [r2, #0]
 80247da:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48
 80247de:	4613      	mov	r3, r2
 80247e0:	3304      	adds	r3, #4
 80247e2:	2601      	movs	r6, #1
 80247e4:	2100      	movs	r1, #0
 80247e6:	9306      	str	r3, [sp, #24]
 80247e8:	ab12      	add	r3, sp, #72	; 0x48
 80247ea:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 80247ee:	9602      	str	r6, [sp, #8]
 80247f0:	9309      	str	r3, [sp, #36]	; 0x24
 80247f2:	2300      	movs	r3, #0
 80247f4:	9301      	str	r3, [sp, #4]
 80247f6:	9b00      	ldr	r3, [sp, #0]
 80247f8:	f013 0302 	ands.w	r3, r3, #2
 80247fc:	9307      	str	r3, [sp, #28]
 80247fe:	9b00      	ldr	r3, [sp, #0]
 8024800:	bf18      	it	ne
 8024802:	3602      	addne	r6, #2
 8024804:	f013 0384 	ands.w	r3, r3, #132	; 0x84
 8024808:	9308      	str	r3, [sp, #32]
 802480a:	f040 8136 	bne.w	8024a7a <_svfiprintf_r+0x5d2>
 802480e:	9b05      	ldr	r3, [sp, #20]
 8024810:	1b9d      	subs	r5, r3, r6
 8024812:	2d00      	cmp	r5, #0
 8024814:	f340 8131 	ble.w	8024a7a <_svfiprintf_r+0x5d2>
 8024818:	2d10      	cmp	r5, #16
 802481a:	9911      	ldr	r1, [sp, #68]	; 0x44
 802481c:	9a10      	ldr	r2, [sp, #64]	; 0x40
 802481e:	f8df b1f8 	ldr.w	fp, [pc, #504]	; 8024a18 <_svfiprintf_r+0x570>
 8024822:	dd27      	ble.n	8024874 <_svfiprintf_r+0x3cc>
 8024824:	960b      	str	r6, [sp, #44]	; 0x2c
 8024826:	2710      	movs	r7, #16
 8024828:	465e      	mov	r6, fp
 802482a:	46ab      	mov	fp, r5
 802482c:	9d04      	ldr	r5, [sp, #16]
 802482e:	e006      	b.n	802483e <_svfiprintf_r+0x396>
 8024830:	f1ab 0b10 	sub.w	fp, fp, #16
 8024834:	f1bb 0f10 	cmp.w	fp, #16
 8024838:	f104 0408 	add.w	r4, r4, #8
 802483c:	dd17      	ble.n	802486e <_svfiprintf_r+0x3c6>
 802483e:	3201      	adds	r2, #1
 8024840:	3110      	adds	r1, #16
 8024842:	2a07      	cmp	r2, #7
 8024844:	9111      	str	r1, [sp, #68]	; 0x44
 8024846:	9210      	str	r2, [sp, #64]	; 0x40
 8024848:	e884 00c0 	stmia.w	r4, {r6, r7}
 802484c:	ddf0      	ble.n	8024830 <_svfiprintf_r+0x388>
 802484e:	4628      	mov	r0, r5
 8024850:	4651      	mov	r1, sl
 8024852:	aa0f      	add	r2, sp, #60	; 0x3c
 8024854:	f7ff fda6 	bl	80243a4 <__ssprint_r>
 8024858:	2800      	cmp	r0, #0
 802485a:	f040 81f0 	bne.w	8024c3e <_svfiprintf_r+0x796>
 802485e:	f1ab 0b10 	sub.w	fp, fp, #16
 8024862:	f1bb 0f10 	cmp.w	fp, #16
 8024866:	9911      	ldr	r1, [sp, #68]	; 0x44
 8024868:	9a10      	ldr	r2, [sp, #64]	; 0x40
 802486a:	4644      	mov	r4, r8
 802486c:	dce7      	bgt.n	802483e <_svfiprintf_r+0x396>
 802486e:	465d      	mov	r5, fp
 8024870:	46b3      	mov	fp, r6
 8024872:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 8024874:	f8c4 b000 	str.w	fp, [r4]
 8024878:	3201      	adds	r2, #1
 802487a:	4429      	add	r1, r5
 802487c:	2a07      	cmp	r2, #7
 802487e:	9111      	str	r1, [sp, #68]	; 0x44
 8024880:	9210      	str	r2, [sp, #64]	; 0x40
 8024882:	6065      	str	r5, [r4, #4]
 8024884:	f300 8281 	bgt.w	8024d8a <_svfiprintf_r+0x8e2>
 8024888:	3408      	adds	r4, #8
 802488a:	e0f8      	b.n	8024a7e <_svfiprintf_r+0x5d6>
 802488c:	4a61      	ldr	r2, [pc, #388]	; (8024a14 <_svfiprintf_r+0x56c>)
 802488e:	920a      	str	r2, [sp, #40]	; 0x28
 8024890:	9a00      	ldr	r2, [sp, #0]
 8024892:	9505      	str	r5, [sp, #20]
 8024894:	0697      	lsls	r7, r2, #26
 8024896:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 802489a:	d548      	bpl.n	802492e <_svfiprintf_r+0x486>
 802489c:	9a06      	ldr	r2, [sp, #24]
 802489e:	3207      	adds	r2, #7
 80248a0:	f022 0207 	bic.w	r2, r2, #7
 80248a4:	e9d2 6700 	ldrd	r6, r7, [r2]
 80248a8:	f102 0108 	add.w	r1, r2, #8
 80248ac:	9106      	str	r1, [sp, #24]
 80248ae:	9a00      	ldr	r2, [sp, #0]
 80248b0:	07d5      	lsls	r5, r2, #31
 80248b2:	f140 80e0 	bpl.w	8024a76 <_svfiprintf_r+0x5ce>
 80248b6:	ea56 0207 	orrs.w	r2, r6, r7
 80248ba:	f000 80dc 	beq.w	8024a76 <_svfiprintf_r+0x5ce>
 80248be:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
 80248c2:	9b00      	ldr	r3, [sp, #0]
 80248c4:	2230      	movs	r2, #48	; 0x30
 80248c6:	f043 0302 	orr.w	r3, r3, #2
 80248ca:	9300      	str	r3, [sp, #0]
 80248cc:	f88d 2038 	strb.w	r2, [sp, #56]	; 0x38
 80248d0:	2302      	movs	r3, #2
 80248d2:	e6a4      	b.n	802461e <_svfiprintf_r+0x176>
 80248d4:	9b00      	ldr	r3, [sp, #0]
 80248d6:	9505      	str	r5, [sp, #20]
 80248d8:	f043 0310 	orr.w	r3, r3, #16
 80248dc:	9300      	str	r3, [sp, #0]
 80248de:	9b00      	ldr	r3, [sp, #0]
 80248e0:	069a      	lsls	r2, r3, #26
 80248e2:	f53f ae92 	bmi.w	802460a <_svfiprintf_r+0x162>
 80248e6:	9b00      	ldr	r3, [sp, #0]
 80248e8:	06db      	lsls	r3, r3, #27
 80248ea:	f140 82a5 	bpl.w	8024e38 <_svfiprintf_r+0x990>
 80248ee:	9a06      	ldr	r2, [sp, #24]
 80248f0:	4613      	mov	r3, r2
 80248f2:	3204      	adds	r2, #4
 80248f4:	681e      	ldr	r6, [r3, #0]
 80248f6:	9206      	str	r2, [sp, #24]
 80248f8:	2301      	movs	r3, #1
 80248fa:	2700      	movs	r7, #0
 80248fc:	e68f      	b.n	802461e <_svfiprintf_r+0x176>
 80248fe:	9b00      	ldr	r3, [sp, #0]
 8024900:	f043 0301 	orr.w	r3, r3, #1
 8024904:	9300      	str	r3, [sp, #0]
 8024906:	f899 3000 	ldrb.w	r3, [r9]
 802490a:	4648      	mov	r0, r9
 802490c:	e616      	b.n	802453c <_svfiprintf_r+0x94>
 802490e:	f899 3000 	ldrb.w	r3, [r9]
 8024912:	4648      	mov	r0, r9
 8024914:	2900      	cmp	r1, #0
 8024916:	f47f ae11 	bne.w	802453c <_svfiprintf_r+0x94>
 802491a:	2120      	movs	r1, #32
 802491c:	e60e      	b.n	802453c <_svfiprintf_r+0x94>
 802491e:	4a3c      	ldr	r2, [pc, #240]	; (8024a10 <_svfiprintf_r+0x568>)
 8024920:	920a      	str	r2, [sp, #40]	; 0x28
 8024922:	9a00      	ldr	r2, [sp, #0]
 8024924:	9505      	str	r5, [sp, #20]
 8024926:	0697      	lsls	r7, r2, #26
 8024928:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 802492c:	d4b6      	bmi.n	802489c <_svfiprintf_r+0x3f4>
 802492e:	9a00      	ldr	r2, [sp, #0]
 8024930:	06d6      	lsls	r6, r2, #27
 8024932:	f100 827a 	bmi.w	8024e2a <_svfiprintf_r+0x982>
 8024936:	9a00      	ldr	r2, [sp, #0]
 8024938:	9906      	ldr	r1, [sp, #24]
 802493a:	f012 0f40 	tst.w	r2, #64	; 0x40
 802493e:	460a      	mov	r2, r1
 8024940:	f000 82b5 	beq.w	8024eae <_svfiprintf_r+0xa06>
 8024944:	3204      	adds	r2, #4
 8024946:	880e      	ldrh	r6, [r1, #0]
 8024948:	9206      	str	r2, [sp, #24]
 802494a:	2700      	movs	r7, #0
 802494c:	e7af      	b.n	80248ae <_svfiprintf_r+0x406>
 802494e:	9b00      	ldr	r3, [sp, #0]
 8024950:	9505      	str	r5, [sp, #20]
 8024952:	f043 0310 	orr.w	r3, r3, #16
 8024956:	9300      	str	r3, [sp, #0]
 8024958:	9b00      	ldr	r3, [sp, #0]
 802495a:	f013 0320 	ands.w	r3, r3, #32
 802495e:	f47f aea2 	bne.w	80246a6 <_svfiprintf_r+0x1fe>
 8024962:	9a00      	ldr	r2, [sp, #0]
 8024964:	f012 0210 	ands.w	r2, r2, #16
 8024968:	f040 8240 	bne.w	8024dec <_svfiprintf_r+0x944>
 802496c:	9b00      	ldr	r3, [sp, #0]
 802496e:	f013 0340 	ands.w	r3, r3, #64	; 0x40
 8024972:	f000 823b 	beq.w	8024dec <_svfiprintf_r+0x944>
 8024976:	9906      	ldr	r1, [sp, #24]
 8024978:	4613      	mov	r3, r2
 802497a:	460a      	mov	r2, r1
 802497c:	3204      	adds	r2, #4
 802497e:	880e      	ldrh	r6, [r1, #0]
 8024980:	9206      	str	r2, [sp, #24]
 8024982:	2700      	movs	r7, #0
 8024984:	e64b      	b.n	802461e <_svfiprintf_r+0x176>
 8024986:	9b00      	ldr	r3, [sp, #0]
 8024988:	9505      	str	r5, [sp, #20]
 802498a:	f043 0310 	orr.w	r3, r3, #16
 802498e:	9300      	str	r3, [sp, #0]
 8024990:	9b00      	ldr	r3, [sp, #0]
 8024992:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 8024996:	069b      	lsls	r3, r3, #26
 8024998:	f53f af07 	bmi.w	80247aa <_svfiprintf_r+0x302>
 802499c:	9b00      	ldr	r3, [sp, #0]
 802499e:	06df      	lsls	r7, r3, #27
 80249a0:	f100 822b 	bmi.w	8024dfa <_svfiprintf_r+0x952>
 80249a4:	9b00      	ldr	r3, [sp, #0]
 80249a6:	065e      	lsls	r6, r3, #25
 80249a8:	f140 8227 	bpl.w	8024dfa <_svfiprintf_r+0x952>
 80249ac:	9906      	ldr	r1, [sp, #24]
 80249ae:	f9b1 6000 	ldrsh.w	r6, [r1]
 80249b2:	3104      	adds	r1, #4
 80249b4:	17f7      	asrs	r7, r6, #31
 80249b6:	4632      	mov	r2, r6
 80249b8:	463b      	mov	r3, r7
 80249ba:	9106      	str	r1, [sp, #24]
 80249bc:	e6ff      	b.n	80247be <_svfiprintf_r+0x316>
 80249be:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 80249c2:	2500      	movs	r5, #0
 80249c4:	f819 3b01 	ldrb.w	r3, [r9], #1
 80249c8:	eb05 0585 	add.w	r5, r5, r5, lsl #2
 80249cc:	eb02 0545 	add.w	r5, r2, r5, lsl #1
 80249d0:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 80249d4:	2a09      	cmp	r2, #9
 80249d6:	d9f5      	bls.n	80249c4 <_svfiprintf_r+0x51c>
 80249d8:	e5b2      	b.n	8024540 <_svfiprintf_r+0x98>
 80249da:	9b00      	ldr	r3, [sp, #0]
 80249dc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80249e0:	9300      	str	r3, [sp, #0]
 80249e2:	f899 3000 	ldrb.w	r3, [r9]
 80249e6:	4648      	mov	r0, r9
 80249e8:	e5a8      	b.n	802453c <_svfiprintf_r+0x94>
 80249ea:	f899 3000 	ldrb.w	r3, [r9]
 80249ee:	4648      	mov	r0, r9
 80249f0:	212b      	movs	r1, #43	; 0x2b
 80249f2:	e5a3      	b.n	802453c <_svfiprintf_r+0x94>
 80249f4:	9a06      	ldr	r2, [sp, #24]
 80249f6:	6815      	ldr	r5, [r2, #0]
 80249f8:	4613      	mov	r3, r2
 80249fa:	2d00      	cmp	r5, #0
 80249fc:	f103 0304 	add.w	r3, r3, #4
 8024a00:	f2c0 823d 	blt.w	8024e7e <_svfiprintf_r+0x9d6>
 8024a04:	9306      	str	r3, [sp, #24]
 8024a06:	f899 3000 	ldrb.w	r3, [r9]
 8024a0a:	4648      	mov	r0, r9
 8024a0c:	e596      	b.n	802453c <_svfiprintf_r+0x94>
 8024a0e:	bf00      	nop
 8024a10:	08029f64 	.word	0x08029f64
 8024a14:	08029f50 	.word	0x08029f50
 8024a18:	08029f40 	.word	0x08029f40
 8024a1c:	f899 3000 	ldrb.w	r3, [r9]
 8024a20:	2b2a      	cmp	r3, #42	; 0x2a
 8024a22:	f109 0001 	add.w	r0, r9, #1
 8024a26:	f000 8272 	beq.w	8024f0e <_svfiprintf_r+0xa66>
 8024a2a:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8024a2e:	2a09      	cmp	r2, #9
 8024a30:	4681      	mov	r9, r0
 8024a32:	bf98      	it	ls
 8024a34:	2000      	movls	r0, #0
 8024a36:	f200 8261 	bhi.w	8024efc <_svfiprintf_r+0xa54>
 8024a3a:	f819 3b01 	ldrb.w	r3, [r9], #1
 8024a3e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8024a42:	eb02 0040 	add.w	r0, r2, r0, lsl #1
 8024a46:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8024a4a:	2a09      	cmp	r2, #9
 8024a4c:	d9f5      	bls.n	8024a3a <_svfiprintf_r+0x592>
 8024a4e:	ea40 72e0 	orr.w	r2, r0, r0, asr #31
 8024a52:	9201      	str	r2, [sp, #4]
 8024a54:	e574      	b.n	8024540 <_svfiprintf_r+0x98>
 8024a56:	9505      	str	r5, [sp, #20]
 8024a58:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 8024a5c:	2b00      	cmp	r3, #0
 8024a5e:	f000 80e7 	beq.w	8024c30 <_svfiprintf_r+0x788>
 8024a62:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48
 8024a66:	2300      	movs	r3, #0
 8024a68:	2601      	movs	r6, #1
 8024a6a:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8024a6e:	ab12      	add	r3, sp, #72	; 0x48
 8024a70:	9602      	str	r6, [sp, #8]
 8024a72:	9309      	str	r3, [sp, #36]	; 0x24
 8024a74:	e6bd      	b.n	80247f2 <_svfiprintf_r+0x34a>
 8024a76:	2302      	movs	r3, #2
 8024a78:	e5d1      	b.n	802461e <_svfiprintf_r+0x176>
 8024a7a:	9911      	ldr	r1, [sp, #68]	; 0x44
 8024a7c:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8024a7e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8024a82:	b163      	cbz	r3, 8024a9e <_svfiprintf_r+0x5f6>
 8024a84:	3201      	adds	r2, #1
 8024a86:	3101      	adds	r1, #1
 8024a88:	f10d 0037 	add.w	r0, sp, #55	; 0x37
 8024a8c:	2301      	movs	r3, #1
 8024a8e:	2a07      	cmp	r2, #7
 8024a90:	9111      	str	r1, [sp, #68]	; 0x44
 8024a92:	9210      	str	r2, [sp, #64]	; 0x40
 8024a94:	e884 0009 	stmia.w	r4, {r0, r3}
 8024a98:	f300 815f 	bgt.w	8024d5a <_svfiprintf_r+0x8b2>
 8024a9c:	3408      	adds	r4, #8
 8024a9e:	9b07      	ldr	r3, [sp, #28]
 8024aa0:	b15b      	cbz	r3, 8024aba <_svfiprintf_r+0x612>
 8024aa2:	3201      	adds	r2, #1
 8024aa4:	3102      	adds	r1, #2
 8024aa6:	a80e      	add	r0, sp, #56	; 0x38
 8024aa8:	2302      	movs	r3, #2
 8024aaa:	2a07      	cmp	r2, #7
 8024aac:	9111      	str	r1, [sp, #68]	; 0x44
 8024aae:	9210      	str	r2, [sp, #64]	; 0x40
 8024ab0:	e884 0009 	stmia.w	r4, {r0, r3}
 8024ab4:	f300 815d 	bgt.w	8024d72 <_svfiprintf_r+0x8ca>
 8024ab8:	3408      	adds	r4, #8
 8024aba:	9b08      	ldr	r3, [sp, #32]
 8024abc:	2b80      	cmp	r3, #128	; 0x80
 8024abe:	f000 80ca 	beq.w	8024c56 <_svfiprintf_r+0x7ae>
 8024ac2:	9b01      	ldr	r3, [sp, #4]
 8024ac4:	9802      	ldr	r0, [sp, #8]
 8024ac6:	1a1d      	subs	r5, r3, r0
 8024ac8:	2d00      	cmp	r5, #0
 8024aca:	dd31      	ble.n	8024b30 <_svfiprintf_r+0x688>
 8024acc:	2d10      	cmp	r5, #16
 8024ace:	4fb5      	ldr	r7, [pc, #724]	; (8024da4 <_svfiprintf_r+0x8fc>)
 8024ad0:	dd24      	ble.n	8024b1c <_svfiprintf_r+0x674>
 8024ad2:	9601      	str	r6, [sp, #4]
 8024ad4:	f04f 0b10 	mov.w	fp, #16
 8024ad8:	463e      	mov	r6, r7
 8024ada:	462f      	mov	r7, r5
 8024adc:	9d04      	ldr	r5, [sp, #16]
 8024ade:	e004      	b.n	8024aea <_svfiprintf_r+0x642>
 8024ae0:	3f10      	subs	r7, #16
 8024ae2:	2f10      	cmp	r7, #16
 8024ae4:	f104 0408 	add.w	r4, r4, #8
 8024ae8:	dd15      	ble.n	8024b16 <_svfiprintf_r+0x66e>
 8024aea:	3201      	adds	r2, #1
 8024aec:	3110      	adds	r1, #16
 8024aee:	2a07      	cmp	r2, #7
 8024af0:	9111      	str	r1, [sp, #68]	; 0x44
 8024af2:	9210      	str	r2, [sp, #64]	; 0x40
 8024af4:	e884 0840 	stmia.w	r4, {r6, fp}
 8024af8:	ddf2      	ble.n	8024ae0 <_svfiprintf_r+0x638>
 8024afa:	4628      	mov	r0, r5
 8024afc:	4651      	mov	r1, sl
 8024afe:	aa0f      	add	r2, sp, #60	; 0x3c
 8024b00:	f7ff fc50 	bl	80243a4 <__ssprint_r>
 8024b04:	2800      	cmp	r0, #0
 8024b06:	f040 809a 	bne.w	8024c3e <_svfiprintf_r+0x796>
 8024b0a:	3f10      	subs	r7, #16
 8024b0c:	2f10      	cmp	r7, #16
 8024b0e:	9911      	ldr	r1, [sp, #68]	; 0x44
 8024b10:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8024b12:	4644      	mov	r4, r8
 8024b14:	dce9      	bgt.n	8024aea <_svfiprintf_r+0x642>
 8024b16:	463d      	mov	r5, r7
 8024b18:	4637      	mov	r7, r6
 8024b1a:	9e01      	ldr	r6, [sp, #4]
 8024b1c:	6027      	str	r7, [r4, #0]
 8024b1e:	3201      	adds	r2, #1
 8024b20:	4429      	add	r1, r5
 8024b22:	2a07      	cmp	r2, #7
 8024b24:	9111      	str	r1, [sp, #68]	; 0x44
 8024b26:	9210      	str	r2, [sp, #64]	; 0x40
 8024b28:	6065      	str	r5, [r4, #4]
 8024b2a:	f300 80fa 	bgt.w	8024d22 <_svfiprintf_r+0x87a>
 8024b2e:	3408      	adds	r4, #8
 8024b30:	9802      	ldr	r0, [sp, #8]
 8024b32:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8024b34:	6023      	str	r3, [r4, #0]
 8024b36:	3201      	adds	r2, #1
 8024b38:	4401      	add	r1, r0
 8024b3a:	2a07      	cmp	r2, #7
 8024b3c:	9111      	str	r1, [sp, #68]	; 0x44
 8024b3e:	9210      	str	r2, [sp, #64]	; 0x40
 8024b40:	6060      	str	r0, [r4, #4]
 8024b42:	f300 80bf 	bgt.w	8024cc4 <_svfiprintf_r+0x81c>
 8024b46:	3408      	adds	r4, #8
 8024b48:	9b00      	ldr	r3, [sp, #0]
 8024b4a:	075b      	lsls	r3, r3, #29
 8024b4c:	d539      	bpl.n	8024bc2 <_svfiprintf_r+0x71a>
 8024b4e:	9b05      	ldr	r3, [sp, #20]
 8024b50:	1b9d      	subs	r5, r3, r6
 8024b52:	2d00      	cmp	r5, #0
 8024b54:	dd35      	ble.n	8024bc2 <_svfiprintf_r+0x71a>
 8024b56:	2d10      	cmp	r5, #16
 8024b58:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8024b5a:	f8df b24c 	ldr.w	fp, [pc, #588]	; 8024da8 <_svfiprintf_r+0x900>
 8024b5e:	dd26      	ble.n	8024bae <_svfiprintf_r+0x706>
 8024b60:	9600      	str	r6, [sp, #0]
 8024b62:	2710      	movs	r7, #16
 8024b64:	465e      	mov	r6, fp
 8024b66:	46ab      	mov	fp, r5
 8024b68:	9d04      	ldr	r5, [sp, #16]
 8024b6a:	e006      	b.n	8024b7a <_svfiprintf_r+0x6d2>
 8024b6c:	f1ab 0b10 	sub.w	fp, fp, #16
 8024b70:	f1bb 0f10 	cmp.w	fp, #16
 8024b74:	f104 0408 	add.w	r4, r4, #8
 8024b78:	dd16      	ble.n	8024ba8 <_svfiprintf_r+0x700>
 8024b7a:	3201      	adds	r2, #1
 8024b7c:	3110      	adds	r1, #16
 8024b7e:	2a07      	cmp	r2, #7
 8024b80:	9111      	str	r1, [sp, #68]	; 0x44
 8024b82:	9210      	str	r2, [sp, #64]	; 0x40
 8024b84:	e884 00c0 	stmia.w	r4, {r6, r7}
 8024b88:	ddf0      	ble.n	8024b6c <_svfiprintf_r+0x6c4>
 8024b8a:	4628      	mov	r0, r5
 8024b8c:	4651      	mov	r1, sl
 8024b8e:	aa0f      	add	r2, sp, #60	; 0x3c
 8024b90:	f7ff fc08 	bl	80243a4 <__ssprint_r>
 8024b94:	2800      	cmp	r0, #0
 8024b96:	d152      	bne.n	8024c3e <_svfiprintf_r+0x796>
 8024b98:	f1ab 0b10 	sub.w	fp, fp, #16
 8024b9c:	f1bb 0f10 	cmp.w	fp, #16
 8024ba0:	9911      	ldr	r1, [sp, #68]	; 0x44
 8024ba2:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8024ba4:	4644      	mov	r4, r8
 8024ba6:	dce8      	bgt.n	8024b7a <_svfiprintf_r+0x6d2>
 8024ba8:	465d      	mov	r5, fp
 8024baa:	46b3      	mov	fp, r6
 8024bac:	9e00      	ldr	r6, [sp, #0]
 8024bae:	f8c4 b000 	str.w	fp, [r4]
 8024bb2:	3201      	adds	r2, #1
 8024bb4:	4429      	add	r1, r5
 8024bb6:	2a07      	cmp	r2, #7
 8024bb8:	9111      	str	r1, [sp, #68]	; 0x44
 8024bba:	9210      	str	r2, [sp, #64]	; 0x40
 8024bbc:	6065      	str	r5, [r4, #4]
 8024bbe:	f300 8102 	bgt.w	8024dc6 <_svfiprintf_r+0x91e>
 8024bc2:	9b03      	ldr	r3, [sp, #12]
 8024bc4:	9a05      	ldr	r2, [sp, #20]
 8024bc6:	4296      	cmp	r6, r2
 8024bc8:	bfac      	ite	ge
 8024bca:	199b      	addge	r3, r3, r6
 8024bcc:	189b      	addlt	r3, r3, r2
 8024bce:	9303      	str	r3, [sp, #12]
 8024bd0:	2900      	cmp	r1, #0
 8024bd2:	f040 8081 	bne.w	8024cd8 <_svfiprintf_r+0x830>
 8024bd6:	2300      	movs	r3, #0
 8024bd8:	9310      	str	r3, [sp, #64]	; 0x40
 8024bda:	f899 3000 	ldrb.w	r3, [r9]
 8024bde:	4644      	mov	r4, r8
 8024be0:	2b00      	cmp	r3, #0
 8024be2:	f47f ac7e 	bne.w	80244e2 <_svfiprintf_r+0x3a>
 8024be6:	464d      	mov	r5, r9
 8024be8:	e49a      	b.n	8024520 <_svfiprintf_r+0x78>
 8024bea:	2b01      	cmp	r3, #1
 8024bec:	f47f ad30 	bne.w	8024650 <_svfiprintf_r+0x1a8>
 8024bf0:	2f00      	cmp	r7, #0
 8024bf2:	bf08      	it	eq
 8024bf4:	2e0a      	cmpeq	r6, #10
 8024bf6:	f0c0 80dd 	bcc.w	8024db4 <_svfiprintf_r+0x90c>
 8024bfa:	4645      	mov	r5, r8
 8024bfc:	4630      	mov	r0, r6
 8024bfe:	4639      	mov	r1, r7
 8024c00:	220a      	movs	r2, #10
 8024c02:	2300      	movs	r3, #0
 8024c04:	f7dc fa3e 	bl	8001084 <__aeabi_uldivmod>
 8024c08:	3230      	adds	r2, #48	; 0x30
 8024c0a:	4630      	mov	r0, r6
 8024c0c:	4639      	mov	r1, r7
 8024c0e:	f805 2d01 	strb.w	r2, [r5, #-1]!
 8024c12:	2300      	movs	r3, #0
 8024c14:	220a      	movs	r2, #10
 8024c16:	f7dc fa35 	bl	8001084 <__aeabi_uldivmod>
 8024c1a:	4606      	mov	r6, r0
 8024c1c:	460f      	mov	r7, r1
 8024c1e:	ea56 0307 	orrs.w	r3, r6, r7
 8024c22:	d1eb      	bne.n	8024bfc <_svfiprintf_r+0x754>
 8024c24:	462b      	mov	r3, r5
 8024c26:	9509      	str	r5, [sp, #36]	; 0x24
 8024c28:	ebc3 0308 	rsb	r3, r3, r8
 8024c2c:	9302      	str	r3, [sp, #8]
 8024c2e:	e062      	b.n	8024cf6 <_svfiprintf_r+0x84e>
 8024c30:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8024c32:	b123      	cbz	r3, 8024c3e <_svfiprintf_r+0x796>
 8024c34:	9804      	ldr	r0, [sp, #16]
 8024c36:	4651      	mov	r1, sl
 8024c38:	aa0f      	add	r2, sp, #60	; 0x3c
 8024c3a:	f7ff fbb3 	bl	80243a4 <__ssprint_r>
 8024c3e:	f8ba 300c 	ldrh.w	r3, [sl, #12]
 8024c42:	f013 0f40 	tst.w	r3, #64	; 0x40
 8024c46:	9b03      	ldr	r3, [sp, #12]
 8024c48:	bf18      	it	ne
 8024c4a:	f04f 33ff 	movne.w	r3, #4294967295
 8024c4e:	4618      	mov	r0, r3
 8024c50:	b02d      	add	sp, #180	; 0xb4
 8024c52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024c56:	9b05      	ldr	r3, [sp, #20]
 8024c58:	1b9d      	subs	r5, r3, r6
 8024c5a:	2d00      	cmp	r5, #0
 8024c5c:	f77f af31 	ble.w	8024ac2 <_svfiprintf_r+0x61a>
 8024c60:	2d10      	cmp	r5, #16
 8024c62:	4f50      	ldr	r7, [pc, #320]	; (8024da4 <_svfiprintf_r+0x8fc>)
 8024c64:	dd23      	ble.n	8024cae <_svfiprintf_r+0x806>
 8024c66:	9607      	str	r6, [sp, #28]
 8024c68:	f04f 0b10 	mov.w	fp, #16
 8024c6c:	463e      	mov	r6, r7
 8024c6e:	462f      	mov	r7, r5
 8024c70:	9d04      	ldr	r5, [sp, #16]
 8024c72:	e004      	b.n	8024c7e <_svfiprintf_r+0x7d6>
 8024c74:	3f10      	subs	r7, #16
 8024c76:	2f10      	cmp	r7, #16
 8024c78:	f104 0408 	add.w	r4, r4, #8
 8024c7c:	dd14      	ble.n	8024ca8 <_svfiprintf_r+0x800>
 8024c7e:	3201      	adds	r2, #1
 8024c80:	3110      	adds	r1, #16
 8024c82:	2a07      	cmp	r2, #7
 8024c84:	9111      	str	r1, [sp, #68]	; 0x44
 8024c86:	9210      	str	r2, [sp, #64]	; 0x40
 8024c88:	e884 0840 	stmia.w	r4, {r6, fp}
 8024c8c:	ddf2      	ble.n	8024c74 <_svfiprintf_r+0x7cc>
 8024c8e:	4628      	mov	r0, r5
 8024c90:	4651      	mov	r1, sl
 8024c92:	aa0f      	add	r2, sp, #60	; 0x3c
 8024c94:	f7ff fb86 	bl	80243a4 <__ssprint_r>
 8024c98:	2800      	cmp	r0, #0
 8024c9a:	d1d0      	bne.n	8024c3e <_svfiprintf_r+0x796>
 8024c9c:	3f10      	subs	r7, #16
 8024c9e:	2f10      	cmp	r7, #16
 8024ca0:	9911      	ldr	r1, [sp, #68]	; 0x44
 8024ca2:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8024ca4:	4644      	mov	r4, r8
 8024ca6:	dcea      	bgt.n	8024c7e <_svfiprintf_r+0x7d6>
 8024ca8:	463d      	mov	r5, r7
 8024caa:	4637      	mov	r7, r6
 8024cac:	9e07      	ldr	r6, [sp, #28]
 8024cae:	6027      	str	r7, [r4, #0]
 8024cb0:	3201      	adds	r2, #1
 8024cb2:	4429      	add	r1, r5
 8024cb4:	2a07      	cmp	r2, #7
 8024cb6:	9111      	str	r1, [sp, #68]	; 0x44
 8024cb8:	9210      	str	r2, [sp, #64]	; 0x40
 8024cba:	6065      	str	r5, [r4, #4]
 8024cbc:	f300 80eb 	bgt.w	8024e96 <_svfiprintf_r+0x9ee>
 8024cc0:	3408      	adds	r4, #8
 8024cc2:	e6fe      	b.n	8024ac2 <_svfiprintf_r+0x61a>
 8024cc4:	9804      	ldr	r0, [sp, #16]
 8024cc6:	4651      	mov	r1, sl
 8024cc8:	aa0f      	add	r2, sp, #60	; 0x3c
 8024cca:	f7ff fb6b 	bl	80243a4 <__ssprint_r>
 8024cce:	2800      	cmp	r0, #0
 8024cd0:	d1b5      	bne.n	8024c3e <_svfiprintf_r+0x796>
 8024cd2:	9911      	ldr	r1, [sp, #68]	; 0x44
 8024cd4:	4644      	mov	r4, r8
 8024cd6:	e737      	b.n	8024b48 <_svfiprintf_r+0x6a0>
 8024cd8:	9804      	ldr	r0, [sp, #16]
 8024cda:	4651      	mov	r1, sl
 8024cdc:	aa0f      	add	r2, sp, #60	; 0x3c
 8024cde:	f7ff fb61 	bl	80243a4 <__ssprint_r>
 8024ce2:	2800      	cmp	r0, #0
 8024ce4:	f43f af77 	beq.w	8024bd6 <_svfiprintf_r+0x72e>
 8024ce8:	e7a9      	b.n	8024c3e <_svfiprintf_r+0x796>
 8024cea:	b913      	cbnz	r3, 8024cf2 <_svfiprintf_r+0x84a>
 8024cec:	9b00      	ldr	r3, [sp, #0]
 8024cee:	07da      	lsls	r2, r3, #31
 8024cf0:	d473      	bmi.n	8024dda <_svfiprintf_r+0x932>
 8024cf2:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
 8024cf6:	9b02      	ldr	r3, [sp, #8]
 8024cf8:	9a01      	ldr	r2, [sp, #4]
 8024cfa:	4293      	cmp	r3, r2
 8024cfc:	bfb8      	it	lt
 8024cfe:	4613      	movlt	r3, r2
 8024d00:	461e      	mov	r6, r3
 8024d02:	f1bb 0f00 	cmp.w	fp, #0
 8024d06:	f43f ad76 	beq.w	80247f6 <_svfiprintf_r+0x34e>
 8024d0a:	3601      	adds	r6, #1
 8024d0c:	e573      	b.n	80247f6 <_svfiprintf_r+0x34e>
 8024d0e:	9804      	ldr	r0, [sp, #16]
 8024d10:	4651      	mov	r1, sl
 8024d12:	aa0f      	add	r2, sp, #60	; 0x3c
 8024d14:	f7ff fb46 	bl	80243a4 <__ssprint_r>
 8024d18:	2800      	cmp	r0, #0
 8024d1a:	d190      	bne.n	8024c3e <_svfiprintf_r+0x796>
 8024d1c:	4644      	mov	r4, r8
 8024d1e:	f7ff bbfc 	b.w	802451a <_svfiprintf_r+0x72>
 8024d22:	9804      	ldr	r0, [sp, #16]
 8024d24:	4651      	mov	r1, sl
 8024d26:	aa0f      	add	r2, sp, #60	; 0x3c
 8024d28:	f7ff fb3c 	bl	80243a4 <__ssprint_r>
 8024d2c:	2800      	cmp	r0, #0
 8024d2e:	d186      	bne.n	8024c3e <_svfiprintf_r+0x796>
 8024d30:	9911      	ldr	r1, [sp, #68]	; 0x44
 8024d32:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8024d34:	4644      	mov	r4, r8
 8024d36:	e6fb      	b.n	8024b30 <_svfiprintf_r+0x688>
 8024d38:	980a      	ldr	r0, [sp, #40]	; 0x28
 8024d3a:	4645      	mov	r5, r8
 8024d3c:	0933      	lsrs	r3, r6, #4
 8024d3e:	f006 010f 	and.w	r1, r6, #15
 8024d42:	ea43 7307 	orr.w	r3, r3, r7, lsl #28
 8024d46:	093a      	lsrs	r2, r7, #4
 8024d48:	461e      	mov	r6, r3
 8024d4a:	4617      	mov	r7, r2
 8024d4c:	5c43      	ldrb	r3, [r0, r1]
 8024d4e:	f805 3d01 	strb.w	r3, [r5, #-1]!
 8024d52:	ea56 0307 	orrs.w	r3, r6, r7
 8024d56:	d1f1      	bne.n	8024d3c <_svfiprintf_r+0x894>
 8024d58:	e764      	b.n	8024c24 <_svfiprintf_r+0x77c>
 8024d5a:	9804      	ldr	r0, [sp, #16]
 8024d5c:	4651      	mov	r1, sl
 8024d5e:	aa0f      	add	r2, sp, #60	; 0x3c
 8024d60:	f7ff fb20 	bl	80243a4 <__ssprint_r>
 8024d64:	2800      	cmp	r0, #0
 8024d66:	f47f af6a 	bne.w	8024c3e <_svfiprintf_r+0x796>
 8024d6a:	9911      	ldr	r1, [sp, #68]	; 0x44
 8024d6c:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8024d6e:	4644      	mov	r4, r8
 8024d70:	e695      	b.n	8024a9e <_svfiprintf_r+0x5f6>
 8024d72:	9804      	ldr	r0, [sp, #16]
 8024d74:	4651      	mov	r1, sl
 8024d76:	aa0f      	add	r2, sp, #60	; 0x3c
 8024d78:	f7ff fb14 	bl	80243a4 <__ssprint_r>
 8024d7c:	2800      	cmp	r0, #0
 8024d7e:	f47f af5e 	bne.w	8024c3e <_svfiprintf_r+0x796>
 8024d82:	9911      	ldr	r1, [sp, #68]	; 0x44
 8024d84:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8024d86:	4644      	mov	r4, r8
 8024d88:	e697      	b.n	8024aba <_svfiprintf_r+0x612>
 8024d8a:	9804      	ldr	r0, [sp, #16]
 8024d8c:	4651      	mov	r1, sl
 8024d8e:	aa0f      	add	r2, sp, #60	; 0x3c
 8024d90:	f7ff fb08 	bl	80243a4 <__ssprint_r>
 8024d94:	2800      	cmp	r0, #0
 8024d96:	f47f af52 	bne.w	8024c3e <_svfiprintf_r+0x796>
 8024d9a:	9911      	ldr	r1, [sp, #68]	; 0x44
 8024d9c:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8024d9e:	4644      	mov	r4, r8
 8024da0:	e66d      	b.n	8024a7e <_svfiprintf_r+0x5d6>
 8024da2:	bf00      	nop
 8024da4:	08029f80 	.word	0x08029f80
 8024da8:	08029f40 	.word	0x08029f40
 8024dac:	ebc1 0308 	rsb	r3, r1, r8
 8024db0:	9302      	str	r3, [sp, #8]
 8024db2:	e7a0      	b.n	8024cf6 <_svfiprintf_r+0x84e>
 8024db4:	ad2c      	add	r5, sp, #176	; 0xb0
 8024db6:	3630      	adds	r6, #48	; 0x30
 8024db8:	f805 6d41 	strb.w	r6, [r5, #-65]!
 8024dbc:	ebc5 0308 	rsb	r3, r5, r8
 8024dc0:	9302      	str	r3, [sp, #8]
 8024dc2:	9509      	str	r5, [sp, #36]	; 0x24
 8024dc4:	e797      	b.n	8024cf6 <_svfiprintf_r+0x84e>
 8024dc6:	9804      	ldr	r0, [sp, #16]
 8024dc8:	4651      	mov	r1, sl
 8024dca:	aa0f      	add	r2, sp, #60	; 0x3c
 8024dcc:	f7ff faea 	bl	80243a4 <__ssprint_r>
 8024dd0:	2800      	cmp	r0, #0
 8024dd2:	f47f af34 	bne.w	8024c3e <_svfiprintf_r+0x796>
 8024dd6:	9911      	ldr	r1, [sp, #68]	; 0x44
 8024dd8:	e6f3      	b.n	8024bc2 <_svfiprintf_r+0x71a>
 8024dda:	ad2c      	add	r5, sp, #176	; 0xb0
 8024ddc:	2330      	movs	r3, #48	; 0x30
 8024dde:	f805 3d41 	strb.w	r3, [r5, #-65]!
 8024de2:	ebc5 0308 	rsb	r3, r5, r8
 8024de6:	9302      	str	r3, [sp, #8]
 8024de8:	9509      	str	r5, [sp, #36]	; 0x24
 8024dea:	e784      	b.n	8024cf6 <_svfiprintf_r+0x84e>
 8024dec:	9906      	ldr	r1, [sp, #24]
 8024dee:	460a      	mov	r2, r1
 8024df0:	3204      	adds	r2, #4
 8024df2:	680e      	ldr	r6, [r1, #0]
 8024df4:	9206      	str	r2, [sp, #24]
 8024df6:	2700      	movs	r7, #0
 8024df8:	e411      	b.n	802461e <_svfiprintf_r+0x176>
 8024dfa:	9a06      	ldr	r2, [sp, #24]
 8024dfc:	6816      	ldr	r6, [r2, #0]
 8024dfe:	4613      	mov	r3, r2
 8024e00:	3304      	adds	r3, #4
 8024e02:	17f7      	asrs	r7, r6, #31
 8024e04:	4632      	mov	r2, r6
 8024e06:	9306      	str	r3, [sp, #24]
 8024e08:	2a00      	cmp	r2, #0
 8024e0a:	463b      	mov	r3, r7
 8024e0c:	f173 0300 	sbcs.w	r3, r3, #0
 8024e10:	f6bf acda 	bge.w	80247c8 <_svfiprintf_r+0x320>
 8024e14:	9b01      	ldr	r3, [sp, #4]
 8024e16:	9302      	str	r3, [sp, #8]
 8024e18:	f04f 0b2d 	mov.w	fp, #45	; 0x2d
 8024e1c:	4276      	negs	r6, r6
 8024e1e:	eb67 0747 	sbc.w	r7, r7, r7, lsl #1
 8024e22:	f88d b037 	strb.w	fp, [sp, #55]	; 0x37
 8024e26:	2301      	movs	r3, #1
 8024e28:	e400      	b.n	802462c <_svfiprintf_r+0x184>
 8024e2a:	9906      	ldr	r1, [sp, #24]
 8024e2c:	460a      	mov	r2, r1
 8024e2e:	3204      	adds	r2, #4
 8024e30:	680e      	ldr	r6, [r1, #0]
 8024e32:	9206      	str	r2, [sp, #24]
 8024e34:	2700      	movs	r7, #0
 8024e36:	e53a      	b.n	80248ae <_svfiprintf_r+0x406>
 8024e38:	9b00      	ldr	r3, [sp, #0]
 8024e3a:	9a06      	ldr	r2, [sp, #24]
 8024e3c:	f013 0f40 	tst.w	r3, #64	; 0x40
 8024e40:	4613      	mov	r3, r2
 8024e42:	f43f ad56 	beq.w	80248f2 <_svfiprintf_r+0x44a>
 8024e46:	8816      	ldrh	r6, [r2, #0]
 8024e48:	3204      	adds	r2, #4
 8024e4a:	2700      	movs	r7, #0
 8024e4c:	2301      	movs	r3, #1
 8024e4e:	9206      	str	r2, [sp, #24]
 8024e50:	f7ff bbe5 	b.w	802461e <_svfiprintf_r+0x176>
 8024e54:	9a06      	ldr	r2, [sp, #24]
 8024e56:	9903      	ldr	r1, [sp, #12]
 8024e58:	6813      	ldr	r3, [r2, #0]
 8024e5a:	17cf      	asrs	r7, r1, #31
 8024e5c:	4608      	mov	r0, r1
 8024e5e:	3204      	adds	r2, #4
 8024e60:	4639      	mov	r1, r7
 8024e62:	9206      	str	r2, [sp, #24]
 8024e64:	e9c3 0100 	strd	r0, r1, [r3]
 8024e68:	f7ff bb36 	b.w	80244d8 <_svfiprintf_r+0x30>
 8024e6c:	9b00      	ldr	r3, [sp, #0]
 8024e6e:	f043 0320 	orr.w	r3, r3, #32
 8024e72:	9300      	str	r3, [sp, #0]
 8024e74:	3001      	adds	r0, #1
 8024e76:	f899 3001 	ldrb.w	r3, [r9, #1]
 8024e7a:	f7ff bb5f 	b.w	802453c <_svfiprintf_r+0x94>
 8024e7e:	426d      	negs	r5, r5
 8024e80:	9306      	str	r3, [sp, #24]
 8024e82:	4648      	mov	r0, r9
 8024e84:	e41b      	b.n	80246be <_svfiprintf_r+0x216>
 8024e86:	9a06      	ldr	r2, [sp, #24]
 8024e88:	6813      	ldr	r3, [r2, #0]
 8024e8a:	3204      	adds	r2, #4
 8024e8c:	9206      	str	r2, [sp, #24]
 8024e8e:	9a03      	ldr	r2, [sp, #12]
 8024e90:	601a      	str	r2, [r3, #0]
 8024e92:	f7ff bb21 	b.w	80244d8 <_svfiprintf_r+0x30>
 8024e96:	9804      	ldr	r0, [sp, #16]
 8024e98:	4651      	mov	r1, sl
 8024e9a:	aa0f      	add	r2, sp, #60	; 0x3c
 8024e9c:	f7ff fa82 	bl	80243a4 <__ssprint_r>
 8024ea0:	2800      	cmp	r0, #0
 8024ea2:	f47f aecc 	bne.w	8024c3e <_svfiprintf_r+0x796>
 8024ea6:	9911      	ldr	r1, [sp, #68]	; 0x44
 8024ea8:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8024eaa:	4644      	mov	r4, r8
 8024eac:	e609      	b.n	8024ac2 <_svfiprintf_r+0x61a>
 8024eae:	3204      	adds	r2, #4
 8024eb0:	680e      	ldr	r6, [r1, #0]
 8024eb2:	9206      	str	r2, [sp, #24]
 8024eb4:	2700      	movs	r7, #0
 8024eb6:	e4fa      	b.n	80248ae <_svfiprintf_r+0x406>
 8024eb8:	9809      	ldr	r0, [sp, #36]	; 0x24
 8024eba:	9606      	str	r6, [sp, #24]
 8024ebc:	f7fe fbf2 	bl	80236a4 <strlen>
 8024ec0:	2300      	movs	r3, #0
 8024ec2:	9002      	str	r0, [sp, #8]
 8024ec4:	f89d b037 	ldrb.w	fp, [sp, #55]	; 0x37
 8024ec8:	9301      	str	r3, [sp, #4]
 8024eca:	e714      	b.n	8024cf6 <_svfiprintf_r+0x84e>
 8024ecc:	2a06      	cmp	r2, #6
 8024ece:	4613      	mov	r3, r2
 8024ed0:	bf28      	it	cs
 8024ed2:	2306      	movcs	r3, #6
 8024ed4:	9302      	str	r3, [sp, #8]
 8024ed6:	9606      	str	r6, [sp, #24]
 8024ed8:	ea23 76e3 	bic.w	r6, r3, r3, asr #31
 8024edc:	4b16      	ldr	r3, [pc, #88]	; (8024f38 <_svfiprintf_r+0xa90>)
 8024ede:	9309      	str	r3, [sp, #36]	; 0x24
 8024ee0:	e487      	b.n	80247f2 <_svfiprintf_r+0x34a>
 8024ee2:	2140      	movs	r1, #64	; 0x40
 8024ee4:	f7f4 fd94 	bl	8019a10 <_malloc_r>
 8024ee8:	f8ca 0000 	str.w	r0, [sl]
 8024eec:	f8ca 0010 	str.w	r0, [sl, #16]
 8024ef0:	b1e0      	cbz	r0, 8024f2c <_svfiprintf_r+0xa84>
 8024ef2:	2340      	movs	r3, #64	; 0x40
 8024ef4:	f8ca 3014 	str.w	r3, [sl, #20]
 8024ef8:	f7ff bae4 	b.w	80244c4 <_svfiprintf_r+0x1c>
 8024efc:	2200      	movs	r2, #0
 8024efe:	9201      	str	r2, [sp, #4]
 8024f00:	f7ff bb1e 	b.w	8024540 <_svfiprintf_r+0x98>
 8024f04:	f89d b037 	ldrb.w	fp, [sp, #55]	; 0x37
 8024f08:	9606      	str	r6, [sp, #24]
 8024f0a:	9001      	str	r0, [sp, #4]
 8024f0c:	e6f3      	b.n	8024cf6 <_svfiprintf_r+0x84e>
 8024f0e:	9a06      	ldr	r2, [sp, #24]
 8024f10:	6813      	ldr	r3, [r2, #0]
 8024f12:	9301      	str	r3, [sp, #4]
 8024f14:	3204      	adds	r2, #4
 8024f16:	2b00      	cmp	r3, #0
 8024f18:	9206      	str	r2, [sp, #24]
 8024f1a:	f899 3001 	ldrb.w	r3, [r9, #1]
 8024f1e:	f6bf ab0d 	bge.w	802453c <_svfiprintf_r+0x94>
 8024f22:	f04f 32ff 	mov.w	r2, #4294967295
 8024f26:	9201      	str	r2, [sp, #4]
 8024f28:	f7ff bb08 	b.w	802453c <_svfiprintf_r+0x94>
 8024f2c:	9a04      	ldr	r2, [sp, #16]
 8024f2e:	230c      	movs	r3, #12
 8024f30:	6013      	str	r3, [r2, #0]
 8024f32:	f04f 30ff 	mov.w	r0, #4294967295
 8024f36:	e68b      	b.n	8024c50 <_svfiprintf_r+0x7a8>
 8024f38:	08029f78 	.word	0x08029f78

08024f3c <_sungetc_r>:
 8024f3c:	f1b1 3fff 	cmp.w	r1, #4294967295
 8024f40:	d037      	beq.n	8024fb2 <_sungetc_r+0x76>
 8024f42:	b538      	push	{r3, r4, r5, lr}
 8024f44:	8993      	ldrh	r3, [r2, #12]
 8024f46:	4614      	mov	r4, r2
 8024f48:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8024f4a:	f023 0320 	bic.w	r3, r3, #32
 8024f4e:	b2cd      	uxtb	r5, r1
 8024f50:	81a3      	strh	r3, [r4, #12]
 8024f52:	b1aa      	cbz	r2, 8024f80 <_sungetc_r+0x44>
 8024f54:	6862      	ldr	r2, [r4, #4]
 8024f56:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8024f58:	429a      	cmp	r2, r3
 8024f5a:	da09      	bge.n	8024f70 <_sungetc_r+0x34>
 8024f5c:	6823      	ldr	r3, [r4, #0]
 8024f5e:	1e5a      	subs	r2, r3, #1
 8024f60:	6022      	str	r2, [r4, #0]
 8024f62:	f803 5c01 	strb.w	r5, [r3, #-1]
 8024f66:	6863      	ldr	r3, [r4, #4]
 8024f68:	3301      	adds	r3, #1
 8024f6a:	4628      	mov	r0, r5
 8024f6c:	6063      	str	r3, [r4, #4]
 8024f6e:	bd38      	pop	{r3, r4, r5, pc}
 8024f70:	4621      	mov	r1, r4
 8024f72:	f000 fd61 	bl	8025a38 <__submore>
 8024f76:	2800      	cmp	r0, #0
 8024f78:	d0f0      	beq.n	8024f5c <_sungetc_r+0x20>
 8024f7a:	f04f 30ff 	mov.w	r0, #4294967295
 8024f7e:	bd38      	pop	{r3, r4, r5, pc}
 8024f80:	6922      	ldr	r2, [r4, #16]
 8024f82:	6823      	ldr	r3, [r4, #0]
 8024f84:	b12a      	cbz	r2, 8024f92 <_sungetc_r+0x56>
 8024f86:	429a      	cmp	r2, r3
 8024f88:	d203      	bcs.n	8024f92 <_sungetc_r+0x56>
 8024f8a:	f813 0c01 	ldrb.w	r0, [r3, #-1]
 8024f8e:	42a8      	cmp	r0, r5
 8024f90:	d012      	beq.n	8024fb8 <_sungetc_r+0x7c>
 8024f92:	63a3      	str	r3, [r4, #56]	; 0x38
 8024f94:	4623      	mov	r3, r4
 8024f96:	6860      	ldr	r0, [r4, #4]
 8024f98:	63e0      	str	r0, [r4, #60]	; 0x3c
 8024f9a:	f104 0140 	add.w	r1, r4, #64	; 0x40
 8024f9e:	2203      	movs	r2, #3
 8024fa0:	6362      	str	r2, [r4, #52]	; 0x34
 8024fa2:	6321      	str	r1, [r4, #48]	; 0x30
 8024fa4:	f803 5f42 	strb.w	r5, [r3, #66]!
 8024fa8:	2201      	movs	r2, #1
 8024faa:	6023      	str	r3, [r4, #0]
 8024fac:	4628      	mov	r0, r5
 8024fae:	6062      	str	r2, [r4, #4]
 8024fb0:	bd38      	pop	{r3, r4, r5, pc}
 8024fb2:	f04f 30ff 	mov.w	r0, #4294967295
 8024fb6:	4770      	bx	lr
 8024fb8:	6862      	ldr	r2, [r4, #4]
 8024fba:	3b01      	subs	r3, #1
 8024fbc:	3201      	adds	r2, #1
 8024fbe:	6023      	str	r3, [r4, #0]
 8024fc0:	6062      	str	r2, [r4, #4]
 8024fc2:	bd38      	pop	{r3, r4, r5, pc}

08024fc4 <__ssrefill_r>:
 8024fc4:	b510      	push	{r4, lr}
 8024fc6:	460c      	mov	r4, r1
 8024fc8:	6b09      	ldr	r1, [r1, #48]	; 0x30
 8024fca:	b169      	cbz	r1, 8024fe8 <__ssrefill_r+0x24>
 8024fcc:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8024fd0:	4299      	cmp	r1, r3
 8024fd2:	d001      	beq.n	8024fd8 <__ssrefill_r+0x14>
 8024fd4:	f7f4 fd46 	bl	8019a64 <_free_r>
 8024fd8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8024fda:	6063      	str	r3, [r4, #4]
 8024fdc:	2000      	movs	r0, #0
 8024fde:	6320      	str	r0, [r4, #48]	; 0x30
 8024fe0:	b113      	cbz	r3, 8024fe8 <__ssrefill_r+0x24>
 8024fe2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8024fe4:	6023      	str	r3, [r4, #0]
 8024fe6:	bd10      	pop	{r4, pc}
 8024fe8:	89a3      	ldrh	r3, [r4, #12]
 8024fea:	6922      	ldr	r2, [r4, #16]
 8024fec:	6022      	str	r2, [r4, #0]
 8024fee:	f043 0320 	orr.w	r3, r3, #32
 8024ff2:	2200      	movs	r2, #0
 8024ff4:	81a3      	strh	r3, [r4, #12]
 8024ff6:	6062      	str	r2, [r4, #4]
 8024ff8:	f04f 30ff 	mov.w	r0, #4294967295
 8024ffc:	bd10      	pop	{r4, pc}
 8024ffe:	bf00      	nop

08025000 <_sfread_r>:
 8025000:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025004:	469a      	mov	sl, r3
 8025006:	b083      	sub	sp, #12
 8025008:	fb02 f90a 	mul.w	r9, r2, sl
 802500c:	9201      	str	r2, [sp, #4]
 802500e:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8025010:	f1b9 0f00 	cmp.w	r9, #0
 8025014:	d028      	beq.n	8025068 <_sfread_r+0x68>
 8025016:	4607      	mov	r7, r0
 8025018:	460e      	mov	r6, r1
 802501a:	464d      	mov	r5, r9
 802501c:	f04f 0800 	mov.w	r8, #0
 8025020:	e00e      	b.n	8025040 <_sfread_r+0x40>
 8025022:	f7db f95b 	bl	80002dc <memcpy>
 8025026:	6822      	ldr	r2, [r4, #0]
 8025028:	f8c4 8004 	str.w	r8, [r4, #4]
 802502c:	445a      	add	r2, fp
 802502e:	6022      	str	r2, [r4, #0]
 8025030:	4638      	mov	r0, r7
 8025032:	4621      	mov	r1, r4
 8025034:	445e      	add	r6, fp
 8025036:	ebcb 0505 	rsb	r5, fp, r5
 802503a:	f7ff ffc3 	bl	8024fc4 <__ssrefill_r>
 802503e:	b9b8      	cbnz	r0, 8025070 <_sfread_r+0x70>
 8025040:	f8d4 b004 	ldr.w	fp, [r4, #4]
 8025044:	6821      	ldr	r1, [r4, #0]
 8025046:	455d      	cmp	r5, fp
 8025048:	4630      	mov	r0, r6
 802504a:	465a      	mov	r2, fp
 802504c:	d8e9      	bhi.n	8025022 <_sfread_r+0x22>
 802504e:	462a      	mov	r2, r5
 8025050:	f7db f944 	bl	80002dc <memcpy>
 8025054:	6862      	ldr	r2, [r4, #4]
 8025056:	6823      	ldr	r3, [r4, #0]
 8025058:	1b52      	subs	r2, r2, r5
 802505a:	442b      	add	r3, r5
 802505c:	4650      	mov	r0, sl
 802505e:	6062      	str	r2, [r4, #4]
 8025060:	6023      	str	r3, [r4, #0]
 8025062:	b003      	add	sp, #12
 8025064:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025068:	4648      	mov	r0, r9
 802506a:	b003      	add	sp, #12
 802506c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025070:	9b01      	ldr	r3, [sp, #4]
 8025072:	ebc5 0909 	rsb	r9, r5, r9
 8025076:	fbb9 f0f3 	udiv	r0, r9, r3
 802507a:	b003      	add	sp, #12
 802507c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08025080 <__ssvfiscanf_r>:
 8025080:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025084:	460c      	mov	r4, r1
 8025086:	8989      	ldrh	r1, [r1, #12]
 8025088:	b0db      	sub	sp, #364	; 0x16c
 802508a:	048d      	lsls	r5, r1, #18
 802508c:	9305      	str	r3, [sp, #20]
 802508e:	d406      	bmi.n	802509e <__ssvfiscanf_r+0x1e>
 8025090:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8025092:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 8025096:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 802509a:	81a1      	strh	r1, [r4, #12]
 802509c:	6663      	str	r3, [r4, #100]	; 0x64
 802509e:	4617      	mov	r7, r2
 80250a0:	2300      	movs	r3, #0
 80250a2:	f817 1b01 	ldrb.w	r1, [r7], #1
 80250a6:	9306      	str	r3, [sp, #24]
 80250a8:	9304      	str	r3, [sp, #16]
 80250aa:	461d      	mov	r5, r3
 80250ac:	9308      	str	r3, [sp, #32]
 80250ae:	f8df b3e8 	ldr.w	fp, [pc, #1000]	; 8025498 <__ssvfiscanf_r+0x418>
 80250b2:	910d      	str	r1, [sp, #52]	; 0x34
 80250b4:	4680      	mov	r8, r0
 80250b6:	b339      	cbz	r1, 8025108 <__ssvfiscanf_r+0x88>
 80250b8:	f8db 0000 	ldr.w	r0, [fp]
 80250bc:	1843      	adds	r3, r0, r1
 80250be:	785b      	ldrb	r3, [r3, #1]
 80250c0:	f003 0308 	and.w	r3, r3, #8
 80250c4:	f003 09ff 	and.w	r9, r3, #255	; 0xff
 80250c8:	b313      	cbz	r3, 8025110 <__ssvfiscanf_r+0x90>
 80250ca:	6863      	ldr	r3, [r4, #4]
 80250cc:	e00d      	b.n	80250ea <__ssvfiscanf_r+0x6a>
 80250ce:	6823      	ldr	r3, [r4, #0]
 80250d0:	f8db 1000 	ldr.w	r1, [fp]
 80250d4:	781a      	ldrb	r2, [r3, #0]
 80250d6:	440a      	add	r2, r1
 80250d8:	3301      	adds	r3, #1
 80250da:	7852      	ldrb	r2, [r2, #1]
 80250dc:	0711      	lsls	r1, r2, #28
 80250de:	d50c      	bpl.n	80250fa <__ssvfiscanf_r+0x7a>
 80250e0:	6862      	ldr	r2, [r4, #4]
 80250e2:	6023      	str	r3, [r4, #0]
 80250e4:	1e53      	subs	r3, r2, #1
 80250e6:	3501      	adds	r5, #1
 80250e8:	6063      	str	r3, [r4, #4]
 80250ea:	2b00      	cmp	r3, #0
 80250ec:	dcef      	bgt.n	80250ce <__ssvfiscanf_r+0x4e>
 80250ee:	4640      	mov	r0, r8
 80250f0:	4621      	mov	r1, r4
 80250f2:	f7ff ff67 	bl	8024fc4 <__ssrefill_r>
 80250f6:	2800      	cmp	r0, #0
 80250f8:	d0e9      	beq.n	80250ce <__ssvfiscanf_r+0x4e>
 80250fa:	463a      	mov	r2, r7
 80250fc:	4617      	mov	r7, r2
 80250fe:	f817 1b01 	ldrb.w	r1, [r7], #1
 8025102:	910d      	str	r1, [sp, #52]	; 0x34
 8025104:	2900      	cmp	r1, #0
 8025106:	d1d7      	bne.n	80250b8 <__ssvfiscanf_r+0x38>
 8025108:	9808      	ldr	r0, [sp, #32]
 802510a:	b05b      	add	sp, #364	; 0x16c
 802510c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025110:	2925      	cmp	r1, #37	; 0x25
 8025112:	f040 8087 	bne.w	8025224 <__ssvfiscanf_r+0x1a4>
 8025116:	7853      	ldrb	r3, [r2, #1]
 8025118:	46ca      	mov	sl, r9
 802511a:	1c79      	adds	r1, r7, #1
 802511c:	2b78      	cmp	r3, #120	; 0x78
 802511e:	f200 814a 	bhi.w	80253b6 <__ssvfiscanf_r+0x336>
 8025122:	e8df f013 	tbh	[pc, r3, lsl #1]
 8025126:	0079      	.short	0x0079
 8025128:	01480148 	.word	0x01480148
 802512c:	01480148 	.word	0x01480148
 8025130:	01480148 	.word	0x01480148
 8025134:	01480148 	.word	0x01480148
 8025138:	01480148 	.word	0x01480148
 802513c:	01480148 	.word	0x01480148
 8025140:	01480148 	.word	0x01480148
 8025144:	01480148 	.word	0x01480148
 8025148:	01480148 	.word	0x01480148
 802514c:	01480148 	.word	0x01480148
 8025150:	01480148 	.word	0x01480148
 8025154:	01480148 	.word	0x01480148
 8025158:	01480148 	.word	0x01480148
 802515c:	01480148 	.word	0x01480148
 8025160:	01480148 	.word	0x01480148
 8025164:	01480148 	.word	0x01480148
 8025168:	01480148 	.word	0x01480148
 802516c:	01480148 	.word	0x01480148
 8025170:	0148007e 	.word	0x0148007e
 8025174:	01480148 	.word	0x01480148
 8025178:	01430148 	.word	0x01430148
 802517c:	01480148 	.word	0x01480148
 8025180:	01480148 	.word	0x01480148
 8025184:	013a0148 	.word	0x013a0148
 8025188:	013a013a 	.word	0x013a013a
 802518c:	013a013a 	.word	0x013a013a
 8025190:	013a013a 	.word	0x013a013a
 8025194:	013a013a 	.word	0x013a013a
 8025198:	0148013a 	.word	0x0148013a
 802519c:	01480148 	.word	0x01480148
 80251a0:	01480148 	.word	0x01480148
 80251a4:	01480148 	.word	0x01480148
 80251a8:	01480148 	.word	0x01480148
 80251ac:	01360148 	.word	0x01360148
 80251b0:	01480148 	.word	0x01480148
 80251b4:	01480148 	.word	0x01480148
 80251b8:	01480148 	.word	0x01480148
 80251bc:	01310148 	.word	0x01310148
 80251c0:	01480148 	.word	0x01480148
 80251c4:	0148012d 	.word	0x0148012d
 80251c8:	01480148 	.word	0x01480148
 80251cc:	01480148 	.word	0x01480148
 80251d0:	01480148 	.word	0x01480148
 80251d4:	01290148 	.word	0x01290148
 80251d8:	01480148 	.word	0x01480148
 80251dc:	01480120 	.word	0x01480120
 80251e0:	01480148 	.word	0x01480148
 80251e4:	01480148 	.word	0x01480148
 80251e8:	01480148 	.word	0x01480148
 80251ec:	0112011a 	.word	0x0112011a
 80251f0:	01480148 	.word	0x01480148
 80251f4:	010d0148 	.word	0x010d0148
 80251f8:	01480105 	.word	0x01480105
 80251fc:	00fd0148 	.word	0x00fd0148
 8025200:	00e30148 	.word	0x00e30148
 8025204:	00f300db 	.word	0x00f300db
 8025208:	01480148 	.word	0x01480148
 802520c:	014800be 	.word	0x014800be
 8025210:	01480092 	.word	0x01480092
 8025214:	01290148 	.word	0x01290148
 8025218:	f04f 30ff 	mov.w	r0, #4294967295
 802521c:	b05b      	add	sp, #364	; 0x16c
 802521e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025222:	460f      	mov	r7, r1
 8025224:	6863      	ldr	r3, [r4, #4]
 8025226:	2b00      	cmp	r3, #0
 8025228:	f340 834f 	ble.w	80258ca <__ssvfiscanf_r+0x84a>
 802522c:	6823      	ldr	r3, [r4, #0]
 802522e:	f817 2c01 	ldrb.w	r2, [r7, #-1]
 8025232:	7819      	ldrb	r1, [r3, #0]
 8025234:	4291      	cmp	r1, r2
 8025236:	f47f af67 	bne.w	8025108 <__ssvfiscanf_r+0x88>
 802523a:	6862      	ldr	r2, [r4, #4]
 802523c:	3301      	adds	r3, #1
 802523e:	3a01      	subs	r2, #1
 8025240:	6062      	str	r2, [r4, #4]
 8025242:	6023      	str	r3, [r4, #0]
 8025244:	3501      	adds	r5, #1
 8025246:	463a      	mov	r2, r7
 8025248:	e758      	b.n	80250fc <__ssvfiscanf_r+0x7c>
 802524a:	4b91      	ldr	r3, [pc, #580]	; (8025490 <__ssvfiscanf_r+0x410>)
 802524c:	9306      	str	r3, [sp, #24]
 802524e:	230a      	movs	r3, #10
 8025250:	9304      	str	r3, [sp, #16]
 8025252:	460f      	mov	r7, r1
 8025254:	4656      	mov	r6, sl
 8025256:	2303      	movs	r3, #3
 8025258:	6862      	ldr	r2, [r4, #4]
 802525a:	2a00      	cmp	r2, #0
 802525c:	dd28      	ble.n	80252b0 <__ssvfiscanf_r+0x230>
 802525e:	f019 0f40 	tst.w	r9, #64	; 0x40
 8025262:	f040 80b6 	bne.w	80253d2 <__ssvfiscanf_r+0x352>
 8025266:	f8db 0000 	ldr.w	r0, [fp]
 802526a:	6821      	ldr	r1, [r4, #0]
 802526c:	e000      	b.n	8025270 <__ssvfiscanf_r+0x1f0>
 802526e:	6021      	str	r1, [r4, #0]
 8025270:	780a      	ldrb	r2, [r1, #0]
 8025272:	4402      	add	r2, r0
 8025274:	3101      	adds	r1, #1
 8025276:	7852      	ldrb	r2, [r2, #1]
 8025278:	0712      	lsls	r2, r2, #28
 802527a:	f140 80aa 	bpl.w	80253d2 <__ssvfiscanf_r+0x352>
 802527e:	6862      	ldr	r2, [r4, #4]
 8025280:	3a01      	subs	r2, #1
 8025282:	2a00      	cmp	r2, #0
 8025284:	f105 0501 	add.w	r5, r5, #1
 8025288:	6062      	str	r2, [r4, #4]
 802528a:	dcf0      	bgt.n	802526e <__ssvfiscanf_r+0x1ee>
 802528c:	4640      	mov	r0, r8
 802528e:	4621      	mov	r1, r4
 8025290:	9303      	str	r3, [sp, #12]
 8025292:	f7ff fe97 	bl	8024fc4 <__ssrefill_r>
 8025296:	b998      	cbnz	r0, 80252c0 <__ssvfiscanf_r+0x240>
 8025298:	f8db 0000 	ldr.w	r0, [fp]
 802529c:	6821      	ldr	r1, [r4, #0]
 802529e:	9b03      	ldr	r3, [sp, #12]
 80252a0:	e7e6      	b.n	8025270 <__ssvfiscanf_r+0x1f0>
 80252a2:	6862      	ldr	r2, [r4, #4]
 80252a4:	2a00      	cmp	r2, #0
 80252a6:	460f      	mov	r7, r1
 80252a8:	4656      	mov	r6, sl
 80252aa:	f04f 0302 	mov.w	r3, #2
 80252ae:	dcd6      	bgt.n	802525e <__ssvfiscanf_r+0x1de>
 80252b0:	4640      	mov	r0, r8
 80252b2:	4621      	mov	r1, r4
 80252b4:	9303      	str	r3, [sp, #12]
 80252b6:	f7ff fe85 	bl	8024fc4 <__ssrefill_r>
 80252ba:	9b03      	ldr	r3, [sp, #12]
 80252bc:	2800      	cmp	r0, #0
 80252be:	d0ce      	beq.n	802525e <__ssvfiscanf_r+0x1de>
 80252c0:	9a08      	ldr	r2, [sp, #32]
 80252c2:	2a00      	cmp	r2, #0
 80252c4:	d0a8      	beq.n	8025218 <__ssvfiscanf_r+0x198>
 80252c6:	89a3      	ldrh	r3, [r4, #12]
 80252c8:	f013 0f40 	tst.w	r3, #64	; 0x40
 80252cc:	4613      	mov	r3, r2
 80252ce:	bf18      	it	ne
 80252d0:	f04f 33ff 	movne.w	r3, #4294967295
 80252d4:	4618      	mov	r0, r3
 80252d6:	b05b      	add	sp, #364	; 0x16c
 80252d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80252dc:	460f      	mov	r7, r1
 80252de:	4b6c      	ldr	r3, [pc, #432]	; (8025490 <__ssvfiscanf_r+0x410>)
 80252e0:	9306      	str	r3, [sp, #24]
 80252e2:	2308      	movs	r3, #8
 80252e4:	9304      	str	r3, [sp, #16]
 80252e6:	4656      	mov	r6, sl
 80252e8:	2303      	movs	r3, #3
 80252ea:	e7b5      	b.n	8025258 <__ssvfiscanf_r+0x1d8>
 80252ec:	f019 0f10 	tst.w	r9, #16
 80252f0:	460f      	mov	r7, r1
 80252f2:	f47f af02 	bne.w	80250fa <__ssvfiscanf_r+0x7a>
 80252f6:	f019 0f04 	tst.w	r9, #4
 80252fa:	f000 8300 	beq.w	80258fe <__ssvfiscanf_r+0x87e>
 80252fe:	9a05      	ldr	r2, [sp, #20]
 8025300:	6813      	ldr	r3, [r2, #0]
 8025302:	3204      	adds	r2, #4
 8025304:	9205      	str	r2, [sp, #20]
 8025306:	801d      	strh	r5, [r3, #0]
 8025308:	463a      	mov	r2, r7
 802530a:	e6f7      	b.n	80250fc <__ssvfiscanf_r+0x7c>
 802530c:	460f      	mov	r7, r1
 802530e:	f449 7908 	orr.w	r9, r9, #544	; 0x220
 8025312:	4b5f      	ldr	r3, [pc, #380]	; (8025490 <__ssvfiscanf_r+0x410>)
 8025314:	9306      	str	r3, [sp, #24]
 8025316:	2310      	movs	r3, #16
 8025318:	9304      	str	r3, [sp, #16]
 802531a:	4656      	mov	r6, sl
 802531c:	2303      	movs	r3, #3
 802531e:	e79b      	b.n	8025258 <__ssvfiscanf_r+0x1d8>
 8025320:	787b      	ldrb	r3, [r7, #1]
 8025322:	2b6c      	cmp	r3, #108	; 0x6c
 8025324:	f000 82e6 	beq.w	80258f4 <__ssvfiscanf_r+0x874>
 8025328:	f049 0901 	orr.w	r9, r9, #1
 802532c:	460f      	mov	r7, r1
 802532e:	e6f4      	b.n	802511a <__ssvfiscanf_r+0x9a>
 8025330:	4b58      	ldr	r3, [pc, #352]	; (8025494 <__ssvfiscanf_r+0x414>)
 8025332:	9306      	str	r3, [sp, #24]
 8025334:	2300      	movs	r3, #0
 8025336:	9304      	str	r3, [sp, #16]
 8025338:	460f      	mov	r7, r1
 802533a:	4656      	mov	r6, sl
 802533c:	2303      	movs	r3, #3
 802533e:	e78b      	b.n	8025258 <__ssvfiscanf_r+0x1d8>
 8025340:	787b      	ldrb	r3, [r7, #1]
 8025342:	f049 0904 	orr.w	r9, r9, #4
 8025346:	460f      	mov	r7, r1
 8025348:	e6e7      	b.n	802511a <__ssvfiscanf_r+0x9a>
 802534a:	460f      	mov	r7, r1
 802534c:	4b51      	ldr	r3, [pc, #324]	; (8025494 <__ssvfiscanf_r+0x414>)
 802534e:	9306      	str	r3, [sp, #24]
 8025350:	230a      	movs	r3, #10
 8025352:	9304      	str	r3, [sp, #16]
 8025354:	4656      	mov	r6, sl
 8025356:	2303      	movs	r3, #3
 8025358:	e77e      	b.n	8025258 <__ssvfiscanf_r+0x1d8>
 802535a:	460f      	mov	r7, r1
 802535c:	f049 0940 	orr.w	r9, r9, #64	; 0x40
 8025360:	4656      	mov	r6, sl
 8025362:	2300      	movs	r3, #0
 8025364:	e778      	b.n	8025258 <__ssvfiscanf_r+0x1d8>
 8025366:	a81a      	add	r0, sp, #104	; 0x68
 8025368:	f000 fcac 	bl	8025cc4 <__sccl>
 802536c:	f049 0940 	orr.w	r9, r9, #64	; 0x40
 8025370:	4607      	mov	r7, r0
 8025372:	4656      	mov	r6, sl
 8025374:	2301      	movs	r3, #1
 8025376:	e76f      	b.n	8025258 <__ssvfiscanf_r+0x1d8>
 8025378:	460f      	mov	r7, r1
 802537a:	f449 7900 	orr.w	r9, r9, #512	; 0x200
 802537e:	e7c8      	b.n	8025312 <__ssvfiscanf_r+0x292>
 8025380:	460f      	mov	r7, r1
 8025382:	f049 0901 	orr.w	r9, r9, #1
 8025386:	e7aa      	b.n	80252de <__ssvfiscanf_r+0x25e>
 8025388:	787b      	ldrb	r3, [r7, #1]
 802538a:	f049 0902 	orr.w	r9, r9, #2
 802538e:	460f      	mov	r7, r1
 8025390:	e6c3      	b.n	802511a <__ssvfiscanf_r+0x9a>
 8025392:	460f      	mov	r7, r1
 8025394:	f049 0901 	orr.w	r9, r9, #1
 8025398:	e7d8      	b.n	802534c <__ssvfiscanf_r+0x2cc>
 802539a:	eb0a 0a8a 	add.w	sl, sl, sl, lsl #2
 802539e:	eb03 0a4a 	add.w	sl, r3, sl, lsl #1
 80253a2:	f1aa 0a30 	sub.w	sl, sl, #48	; 0x30
 80253a6:	787b      	ldrb	r3, [r7, #1]
 80253a8:	460f      	mov	r7, r1
 80253aa:	e6b6      	b.n	802511a <__ssvfiscanf_r+0x9a>
 80253ac:	787b      	ldrb	r3, [r7, #1]
 80253ae:	f049 0910 	orr.w	r9, r9, #16
 80253b2:	460f      	mov	r7, r1
 80253b4:	e6b1      	b.n	802511a <__ssvfiscanf_r+0x9a>
 80253b6:	4403      	add	r3, r0
 80253b8:	460f      	mov	r7, r1
 80253ba:	785b      	ldrb	r3, [r3, #1]
 80253bc:	f003 0303 	and.w	r3, r3, #3
 80253c0:	2b01      	cmp	r3, #1
 80253c2:	d0e7      	beq.n	8025394 <__ssvfiscanf_r+0x314>
 80253c4:	4b33      	ldr	r3, [pc, #204]	; (8025494 <__ssvfiscanf_r+0x414>)
 80253c6:	9306      	str	r3, [sp, #24]
 80253c8:	230a      	movs	r3, #10
 80253ca:	9304      	str	r3, [sp, #16]
 80253cc:	4656      	mov	r6, sl
 80253ce:	2303      	movs	r3, #3
 80253d0:	e742      	b.n	8025258 <__ssvfiscanf_r+0x1d8>
 80253d2:	2b02      	cmp	r3, #2
 80253d4:	f000 8115 	beq.w	8025602 <__ssvfiscanf_r+0x582>
 80253d8:	2b03      	cmp	r3, #3
 80253da:	d05f      	beq.n	802549c <__ssvfiscanf_r+0x41c>
 80253dc:	2b01      	cmp	r3, #1
 80253de:	d025      	beq.n	802542c <__ssvfiscanf_r+0x3ac>
 80253e0:	f1ba 0f00 	cmp.w	sl, #0
 80253e4:	bf14      	ite	ne
 80253e6:	4656      	movne	r6, sl
 80253e8:	2601      	moveq	r6, #1
 80253ea:	f019 0301 	ands.w	r3, r9, #1
 80253ee:	f040 81d3 	bne.w	8025798 <__ssvfiscanf_r+0x718>
 80253f2:	f019 0f10 	tst.w	r9, #16
 80253f6:	f000 8252 	beq.w	802589e <__ssvfiscanf_r+0x81e>
 80253fa:	4699      	mov	r9, r3
 80253fc:	e008      	b.n	8025410 <__ssvfiscanf_r+0x390>
 80253fe:	4413      	add	r3, r2
 8025400:	6023      	str	r3, [r4, #0]
 8025402:	4491      	add	r9, r2
 8025404:	1ab6      	subs	r6, r6, r2
 8025406:	f7ff fddd 	bl	8024fc4 <__ssrefill_r>
 802540a:	2800      	cmp	r0, #0
 802540c:	f040 8241 	bne.w	8025892 <__ssvfiscanf_r+0x812>
 8025410:	6862      	ldr	r2, [r4, #4]
 8025412:	6823      	ldr	r3, [r4, #0]
 8025414:	42b2      	cmp	r2, r6
 8025416:	4640      	mov	r0, r8
 8025418:	4621      	mov	r1, r4
 802541a:	dbf0      	blt.n	80253fe <__ssvfiscanf_r+0x37e>
 802541c:	1b92      	subs	r2, r2, r6
 802541e:	4433      	add	r3, r6
 8025420:	6062      	str	r2, [r4, #4]
 8025422:	44b1      	add	r9, r6
 8025424:	6023      	str	r3, [r4, #0]
 8025426:	444d      	add	r5, r9
 8025428:	463a      	mov	r2, r7
 802542a:	e667      	b.n	80250fc <__ssvfiscanf_r+0x7c>
 802542c:	f1ba 0f00 	cmp.w	sl, #0
 8025430:	bf14      	ite	ne
 8025432:	4656      	movne	r6, sl
 8025434:	f04f 36ff 	moveq.w	r6, #4294967295
 8025438:	f019 0f10 	tst.w	r9, #16
 802543c:	f000 810f 	beq.w	802565e <__ssvfiscanf_r+0x5de>
 8025440:	aa1a      	add	r2, sp, #104	; 0x68
 8025442:	6821      	ldr	r1, [r4, #0]
 8025444:	f04f 0900 	mov.w	r9, #0
 8025448:	4692      	mov	sl, r2
 802544a:	780b      	ldrb	r3, [r1, #0]
 802544c:	f81a 3003 	ldrb.w	r3, [sl, r3]
 8025450:	3101      	adds	r1, #1
 8025452:	b1b3      	cbz	r3, 8025482 <__ssvfiscanf_r+0x402>
 8025454:	6863      	ldr	r3, [r4, #4]
 8025456:	6021      	str	r1, [r4, #0]
 8025458:	f109 0901 	add.w	r9, r9, #1
 802545c:	3b01      	subs	r3, #1
 802545e:	454e      	cmp	r6, r9
 8025460:	6063      	str	r3, [r4, #4]
 8025462:	d0e0      	beq.n	8025426 <__ssvfiscanf_r+0x3a6>
 8025464:	2b00      	cmp	r3, #0
 8025466:	dcf0      	bgt.n	802544a <__ssvfiscanf_r+0x3ca>
 8025468:	4640      	mov	r0, r8
 802546a:	4621      	mov	r1, r4
 802546c:	f7ff fdaa 	bl	8024fc4 <__ssrefill_r>
 8025470:	2800      	cmp	r0, #0
 8025472:	d1d8      	bne.n	8025426 <__ssvfiscanf_r+0x3a6>
 8025474:	6821      	ldr	r1, [r4, #0]
 8025476:	780b      	ldrb	r3, [r1, #0]
 8025478:	f81a 3003 	ldrb.w	r3, [sl, r3]
 802547c:	3101      	adds	r1, #1
 802547e:	2b00      	cmp	r3, #0
 8025480:	d1e8      	bne.n	8025454 <__ssvfiscanf_r+0x3d4>
 8025482:	f1b9 0f00 	cmp.w	r9, #0
 8025486:	f43f ae3f 	beq.w	8025108 <__ssvfiscanf_r+0x88>
 802548a:	444d      	add	r5, r9
 802548c:	e7cc      	b.n	8025428 <__ssvfiscanf_r+0x3a8>
 802548e:	bf00      	nop
 8025490:	08024265 	.word	0x08024265
 8025494:	08023801 	.word	0x08023801
 8025498:	20010114 	.word	0x20010114
 802549c:	f10a 33ff 	add.w	r3, sl, #4294967295
 80254a0:	2b26      	cmp	r3, #38	; 0x26
 80254a2:	bf8c      	ite	hi
 80254a4:	f1aa 0327 	subhi.w	r3, sl, #39	; 0x27
 80254a8:	2300      	movls	r3, #0
 80254aa:	f04f 0200 	mov.w	r2, #0
 80254ae:	f10d 0c40 	add.w	ip, sp, #64	; 0x40
 80254b2:	9307      	str	r3, [sp, #28]
 80254b4:	462b      	mov	r3, r5
 80254b6:	9d04      	ldr	r5, [sp, #16]
 80254b8:	9203      	str	r2, [sp, #12]
 80254ba:	bf88      	it	hi
 80254bc:	2627      	movhi	r6, #39	; 0x27
 80254be:	f449 6958 	orr.w	r9, r9, #3456	; 0xd80
 80254c2:	46e2      	mov	sl, ip
 80254c4:	463a      	mov	r2, r7
 80254c6:	6820      	ldr	r0, [r4, #0]
 80254c8:	f890 e000 	ldrb.w	lr, [r0]
 80254cc:	f1ae 012b 	sub.w	r1, lr, #43	; 0x2b
 80254d0:	294d      	cmp	r1, #77	; 0x4d
 80254d2:	d83f      	bhi.n	8025554 <__ssvfiscanf_r+0x4d4>
 80254d4:	e8df f001 	tbb	[pc, r1]
 80254d8:	3e8f3e8f 	.word	0x3e8f3e8f
 80254dc:	6060663e 	.word	0x6060663e
 80254e0:	60606060 	.word	0x60606060
 80254e4:	3e5a5a60 	.word	0x3e5a5a60
 80254e8:	3e3e3e3e 	.word	0x3e3e3e3e
 80254ec:	55553e3e 	.word	0x55553e3e
 80254f0:	55555555 	.word	0x55555555
 80254f4:	3e3e3e3e 	.word	0x3e3e3e3e
 80254f8:	3e3e3e3e 	.word	0x3e3e3e3e
 80254fc:	3e3e3e3e 	.word	0x3e3e3e3e
 8025500:	3e3e3e3e 	.word	0x3e3e3e3e
 8025504:	3e3e273e 	.word	0x3e3e273e
 8025508:	3e3e3e3e 	.word	0x3e3e3e3e
 802550c:	55553e3e 	.word	0x55553e3e
 8025510:	55555555 	.word	0x55555555
 8025514:	3e3e3e3e 	.word	0x3e3e3e3e
 8025518:	3e3e3e3e 	.word	0x3e3e3e3e
 802551c:	3e3e3e3e 	.word	0x3e3e3e3e
 8025520:	3e3e3e3e 	.word	0x3e3e3e3e
 8025524:	273e      	.short	0x273e
 8025526:	f409 61c0 	and.w	r1, r9, #1536	; 0x600
 802552a:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 802552e:	d111      	bne.n	8025554 <__ssvfiscanf_r+0x4d4>
 8025530:	f429 7900 	bic.w	r9, r9, #512	; 0x200
 8025534:	f449 69a0 	orr.w	r9, r9, #1280	; 0x500
 8025538:	2510      	movs	r5, #16
 802553a:	6861      	ldr	r1, [r4, #4]
 802553c:	f88a e000 	strb.w	lr, [sl]
 8025540:	3901      	subs	r1, #1
 8025542:	2900      	cmp	r1, #0
 8025544:	f10a 0a01 	add.w	sl, sl, #1
 8025548:	6061      	str	r1, [r4, #4]
 802554a:	dd45      	ble.n	80255d8 <__ssvfiscanf_r+0x558>
 802554c:	3001      	adds	r0, #1
 802554e:	6020      	str	r0, [r4, #0]
 8025550:	3e01      	subs	r6, #1
 8025552:	d1b8      	bne.n	80254c6 <__ssvfiscanf_r+0x446>
 8025554:	f419 7f80 	tst.w	r9, #256	; 0x100
 8025558:	9504      	str	r5, [sp, #16]
 802555a:	4617      	mov	r7, r2
 802555c:	461d      	mov	r5, r3
 802555e:	d005      	beq.n	802556c <__ssvfiscanf_r+0x4ec>
 8025560:	45e2      	cmp	sl, ip
 8025562:	f200 81ba 	bhi.w	80258da <__ssvfiscanf_r+0x85a>
 8025566:	45e2      	cmp	sl, ip
 8025568:	f43f adce 	beq.w	8025108 <__ssvfiscanf_r+0x88>
 802556c:	f019 0610 	ands.w	r6, r9, #16
 8025570:	f000 80fa 	beq.w	8025768 <__ssvfiscanf_r+0x6e8>
 8025574:	9b03      	ldr	r3, [sp, #12]
 8025576:	ebcc 0c0a 	rsb	ip, ip, sl
 802557a:	449c      	add	ip, r3
 802557c:	4465      	add	r5, ip
 802557e:	463a      	mov	r2, r7
 8025580:	e5bc      	b.n	80250fc <__ssvfiscanf_r+0x7c>
 8025582:	2d0a      	cmp	r5, #10
 8025584:	dde6      	ble.n	8025554 <__ssvfiscanf_r+0x4d4>
 8025586:	f429 6938 	bic.w	r9, r9, #2944	; 0xb80
 802558a:	e7d6      	b.n	802553a <__ssvfiscanf_r+0x4ba>
 802558c:	49ad      	ldr	r1, [pc, #692]	; (8025844 <__ssvfiscanf_r+0x7c4>)
 802558e:	f931 5015 	ldrsh.w	r5, [r1, r5, lsl #1]
 8025592:	2d08      	cmp	r5, #8
 8025594:	dcf7      	bgt.n	8025586 <__ssvfiscanf_r+0x506>
 8025596:	e7dd      	b.n	8025554 <__ssvfiscanf_r+0x4d4>
 8025598:	49aa      	ldr	r1, [pc, #680]	; (8025844 <__ssvfiscanf_r+0x7c4>)
 802559a:	f429 6938 	bic.w	r9, r9, #2944	; 0xb80
 802559e:	f931 5015 	ldrsh.w	r5, [r1, r5, lsl #1]
 80255a2:	e7ca      	b.n	802553a <__ssvfiscanf_r+0x4ba>
 80255a4:	f419 6f00 	tst.w	r9, #2048	; 0x800
 80255a8:	d0c7      	beq.n	802553a <__ssvfiscanf_r+0x4ba>
 80255aa:	b915      	cbnz	r5, 80255b2 <__ssvfiscanf_r+0x532>
 80255ac:	f449 7900 	orr.w	r9, r9, #512	; 0x200
 80255b0:	2508      	movs	r5, #8
 80255b2:	f419 6f80 	tst.w	r9, #1024	; 0x400
 80255b6:	f040 813b 	bne.w	8025830 <__ssvfiscanf_r+0x7b0>
 80255ba:	9907      	ldr	r1, [sp, #28]
 80255bc:	f429 7960 	bic.w	r9, r9, #896	; 0x380
 80255c0:	b111      	cbz	r1, 80255c8 <__ssvfiscanf_r+0x548>
 80255c2:	3901      	subs	r1, #1
 80255c4:	9107      	str	r1, [sp, #28]
 80255c6:	3601      	adds	r6, #1
 80255c8:	9903      	ldr	r1, [sp, #12]
 80255ca:	3101      	adds	r1, #1
 80255cc:	9103      	str	r1, [sp, #12]
 80255ce:	6861      	ldr	r1, [r4, #4]
 80255d0:	3901      	subs	r1, #1
 80255d2:	2900      	cmp	r1, #0
 80255d4:	6061      	str	r1, [r4, #4]
 80255d6:	dcb9      	bgt.n	802554c <__ssvfiscanf_r+0x4cc>
 80255d8:	4640      	mov	r0, r8
 80255da:	4621      	mov	r1, r4
 80255dc:	920a      	str	r2, [sp, #40]	; 0x28
 80255de:	9309      	str	r3, [sp, #36]	; 0x24
 80255e0:	f8cd c010 	str.w	ip, [sp, #16]
 80255e4:	f7ff fcee 	bl	8024fc4 <__ssrefill_r>
 80255e8:	f8dd c010 	ldr.w	ip, [sp, #16]
 80255ec:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80255ee:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80255f0:	2800      	cmp	r0, #0
 80255f2:	d0ad      	beq.n	8025550 <__ssvfiscanf_r+0x4d0>
 80255f4:	e7ae      	b.n	8025554 <__ssvfiscanf_r+0x4d4>
 80255f6:	f019 0f80 	tst.w	r9, #128	; 0x80
 80255fa:	d0ab      	beq.n	8025554 <__ssvfiscanf_r+0x4d4>
 80255fc:	f029 0980 	bic.w	r9, r9, #128	; 0x80
 8025600:	e79b      	b.n	802553a <__ssvfiscanf_r+0x4ba>
 8025602:	f1ba 0f00 	cmp.w	sl, #0
 8025606:	bf14      	ite	ne
 8025608:	4656      	movne	r6, sl
 802560a:	f04f 36ff 	moveq.w	r6, #4294967295
 802560e:	f019 0301 	ands.w	r3, r9, #1
 8025612:	f040 8083 	bne.w	802571c <__ssvfiscanf_r+0x69c>
 8025616:	f019 0f10 	tst.w	r9, #16
 802561a:	d050      	beq.n	80256be <__ssvfiscanf_r+0x63e>
 802561c:	f8db 1000 	ldr.w	r1, [fp]
 8025620:	6822      	ldr	r2, [r4, #0]
 8025622:	4699      	mov	r9, r3
 8025624:	7813      	ldrb	r3, [r2, #0]
 8025626:	440b      	add	r3, r1
 8025628:	3201      	adds	r2, #1
 802562a:	785b      	ldrb	r3, [r3, #1]
 802562c:	0718      	lsls	r0, r3, #28
 802562e:	f53f aefa 	bmi.w	8025426 <__ssvfiscanf_r+0x3a6>
 8025632:	6863      	ldr	r3, [r4, #4]
 8025634:	6022      	str	r2, [r4, #0]
 8025636:	f109 0901 	add.w	r9, r9, #1
 802563a:	3b01      	subs	r3, #1
 802563c:	454e      	cmp	r6, r9
 802563e:	6063      	str	r3, [r4, #4]
 8025640:	f43f aef1 	beq.w	8025426 <__ssvfiscanf_r+0x3a6>
 8025644:	2b00      	cmp	r3, #0
 8025646:	dced      	bgt.n	8025624 <__ssvfiscanf_r+0x5a4>
 8025648:	4640      	mov	r0, r8
 802564a:	4621      	mov	r1, r4
 802564c:	f7ff fcba 	bl	8024fc4 <__ssrefill_r>
 8025650:	2800      	cmp	r0, #0
 8025652:	f47f aee8 	bne.w	8025426 <__ssvfiscanf_r+0x3a6>
 8025656:	f8db 1000 	ldr.w	r1, [fp]
 802565a:	6822      	ldr	r2, [r4, #0]
 802565c:	e7e2      	b.n	8025624 <__ssvfiscanf_r+0x5a4>
 802565e:	9a05      	ldr	r2, [sp, #20]
 8025660:	4613      	mov	r3, r2
 8025662:	f8d2 9000 	ldr.w	r9, [r2]
 8025666:	3304      	adds	r3, #4
 8025668:	9305      	str	r3, [sp, #20]
 802566a:	46ca      	mov	sl, r9
 802566c:	aa1a      	add	r2, sp, #104	; 0x68
 802566e:	6823      	ldr	r3, [r4, #0]
 8025670:	7819      	ldrb	r1, [r3, #0]
 8025672:	5c51      	ldrb	r1, [r2, r1]
 8025674:	1c58      	adds	r0, r3, #1
 8025676:	b1b1      	cbz	r1, 80256a6 <__ssvfiscanf_r+0x626>
 8025678:	6861      	ldr	r1, [r4, #4]
 802567a:	6020      	str	r0, [r4, #0]
 802567c:	3901      	subs	r1, #1
 802567e:	6061      	str	r1, [r4, #4]
 8025680:	781b      	ldrb	r3, [r3, #0]
 8025682:	f80a 3b01 	strb.w	r3, [sl], #1
 8025686:	3e01      	subs	r6, #1
 8025688:	d00d      	beq.n	80256a6 <__ssvfiscanf_r+0x626>
 802568a:	6863      	ldr	r3, [r4, #4]
 802568c:	2b00      	cmp	r3, #0
 802568e:	dcee      	bgt.n	802566e <__ssvfiscanf_r+0x5ee>
 8025690:	4640      	mov	r0, r8
 8025692:	4621      	mov	r1, r4
 8025694:	9203      	str	r2, [sp, #12]
 8025696:	f7ff fc95 	bl	8024fc4 <__ssrefill_r>
 802569a:	9a03      	ldr	r2, [sp, #12]
 802569c:	2800      	cmp	r0, #0
 802569e:	d0e6      	beq.n	802566e <__ssvfiscanf_r+0x5ee>
 80256a0:	45ca      	cmp	sl, r9
 80256a2:	f43f ae0d 	beq.w	80252c0 <__ssvfiscanf_r+0x240>
 80256a6:	ebba 0909 	subs.w	r9, sl, r9
 80256aa:	f43f ad2d 	beq.w	8025108 <__ssvfiscanf_r+0x88>
 80256ae:	9b08      	ldr	r3, [sp, #32]
 80256b0:	2200      	movs	r2, #0
 80256b2:	3301      	adds	r3, #1
 80256b4:	9308      	str	r3, [sp, #32]
 80256b6:	f88a 2000 	strb.w	r2, [sl]
 80256ba:	444d      	add	r5, r9
 80256bc:	e6b4      	b.n	8025428 <__ssvfiscanf_r+0x3a8>
 80256be:	9a05      	ldr	r2, [sp, #20]
 80256c0:	4613      	mov	r3, r2
 80256c2:	f8d2 9000 	ldr.w	r9, [r2]
 80256c6:	3304      	adds	r3, #4
 80256c8:	9303      	str	r3, [sp, #12]
 80256ca:	46ca      	mov	sl, r9
 80256cc:	6821      	ldr	r1, [r4, #0]
 80256ce:	f8db 2000 	ldr.w	r2, [fp]
 80256d2:	780b      	ldrb	r3, [r1, #0]
 80256d4:	4413      	add	r3, r2
 80256d6:	1c4a      	adds	r2, r1, #1
 80256d8:	785b      	ldrb	r3, [r3, #1]
 80256da:	071b      	lsls	r3, r3, #28
 80256dc:	d411      	bmi.n	8025702 <__ssvfiscanf_r+0x682>
 80256de:	6863      	ldr	r3, [r4, #4]
 80256e0:	6022      	str	r2, [r4, #0]
 80256e2:	3b01      	subs	r3, #1
 80256e4:	6063      	str	r3, [r4, #4]
 80256e6:	780b      	ldrb	r3, [r1, #0]
 80256e8:	f80a 3b01 	strb.w	r3, [sl], #1
 80256ec:	3e01      	subs	r6, #1
 80256ee:	d008      	beq.n	8025702 <__ssvfiscanf_r+0x682>
 80256f0:	6863      	ldr	r3, [r4, #4]
 80256f2:	2b00      	cmp	r3, #0
 80256f4:	dcea      	bgt.n	80256cc <__ssvfiscanf_r+0x64c>
 80256f6:	4640      	mov	r0, r8
 80256f8:	4621      	mov	r1, r4
 80256fa:	f7ff fc63 	bl	8024fc4 <__ssrefill_r>
 80256fe:	2800      	cmp	r0, #0
 8025700:	d0e4      	beq.n	80256cc <__ssvfiscanf_r+0x64c>
 8025702:	9a08      	ldr	r2, [sp, #32]
 8025704:	3201      	adds	r2, #1
 8025706:	ebc9 090a 	rsb	r9, r9, sl
 802570a:	2300      	movs	r3, #0
 802570c:	9208      	str	r2, [sp, #32]
 802570e:	9a03      	ldr	r2, [sp, #12]
 8025710:	9205      	str	r2, [sp, #20]
 8025712:	444d      	add	r5, r9
 8025714:	f88a 3000 	strb.w	r3, [sl]
 8025718:	463a      	mov	r2, r7
 802571a:	e4ef      	b.n	80250fc <__ssvfiscanf_r+0x7c>
 802571c:	ab0e      	add	r3, sp, #56	; 0x38
 802571e:	4618      	mov	r0, r3
 8025720:	2100      	movs	r1, #0
 8025722:	2208      	movs	r2, #8
 8025724:	9309      	str	r3, [sp, #36]	; 0x24
 8025726:	f7fd fb2b 	bl	8022d80 <memset>
 802572a:	f019 0310 	ands.w	r3, r9, #16
 802572e:	9303      	str	r3, [sp, #12]
 8025730:	f000 8081 	beq.w	8025836 <__ssvfiscanf_r+0x7b6>
 8025734:	f10d 0a34 	add.w	sl, sp, #52	; 0x34
 8025738:	2200      	movs	r2, #0
 802573a:	4691      	mov	r9, r2
 802573c:	6823      	ldr	r3, [r4, #0]
 802573e:	f8db 2000 	ldr.w	r2, [fp]
 8025742:	781b      	ldrb	r3, [r3, #0]
 8025744:	4413      	add	r3, r2
 8025746:	785b      	ldrb	r3, [r3, #1]
 8025748:	071b      	lsls	r3, r3, #28
 802574a:	d402      	bmi.n	8025752 <__ssvfiscanf_r+0x6d2>
 802574c:	2e00      	cmp	r6, #0
 802574e:	f040 810b 	bne.w	8025968 <__ssvfiscanf_r+0x8e8>
 8025752:	9b03      	ldr	r3, [sp, #12]
 8025754:	2b00      	cmp	r3, #0
 8025756:	f47f acd0 	bne.w	80250fa <__ssvfiscanf_r+0x7a>
 802575a:	f8ca 3000 	str.w	r3, [sl]
 802575e:	9b08      	ldr	r3, [sp, #32]
 8025760:	3301      	adds	r3, #1
 8025762:	9308      	str	r3, [sp, #32]
 8025764:	463a      	mov	r2, r7
 8025766:	e4c9      	b.n	80250fc <__ssvfiscanf_r+0x7c>
 8025768:	4632      	mov	r2, r6
 802576a:	4661      	mov	r1, ip
 802576c:	f88a 6000 	strb.w	r6, [sl]
 8025770:	4640      	mov	r0, r8
 8025772:	9b04      	ldr	r3, [sp, #16]
 8025774:	9e06      	ldr	r6, [sp, #24]
 8025776:	f8cd c01c 	str.w	ip, [sp, #28]
 802577a:	47b0      	blx	r6
 802577c:	f019 0f20 	tst.w	r9, #32
 8025780:	f8dd c01c 	ldr.w	ip, [sp, #28]
 8025784:	d075      	beq.n	8025872 <__ssvfiscanf_r+0x7f2>
 8025786:	9a05      	ldr	r2, [sp, #20]
 8025788:	6813      	ldr	r3, [r2, #0]
 802578a:	3204      	adds	r2, #4
 802578c:	9205      	str	r2, [sp, #20]
 802578e:	6018      	str	r0, [r3, #0]
 8025790:	9b08      	ldr	r3, [sp, #32]
 8025792:	3301      	adds	r3, #1
 8025794:	9308      	str	r3, [sp, #32]
 8025796:	e6ed      	b.n	8025574 <__ssvfiscanf_r+0x4f4>
 8025798:	ab0e      	add	r3, sp, #56	; 0x38
 802579a:	4618      	mov	r0, r3
 802579c:	2100      	movs	r1, #0
 802579e:	2208      	movs	r2, #8
 80257a0:	9309      	str	r3, [sp, #36]	; 0x24
 80257a2:	f7fd faed 	bl	8022d80 <memset>
 80257a6:	f019 0310 	ands.w	r3, r9, #16
 80257aa:	930a      	str	r3, [sp, #40]	; 0x28
 80257ac:	d05a      	beq.n	8025864 <__ssvfiscanf_r+0x7e4>
 80257ae:	2300      	movs	r3, #0
 80257b0:	4619      	mov	r1, r3
 80257b2:	9503      	str	r5, [sp, #12]
 80257b4:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 80257b6:	970b      	str	r7, [sp, #44]	; 0x2c
 80257b8:	f04f 0a00 	mov.w	sl, #0
 80257bc:	f10d 0940 	add.w	r9, sp, #64	; 0x40
 80257c0:	460f      	mov	r7, r1
 80257c2:	f8cd 801c 	str.w	r8, [sp, #28]
 80257c6:	f000 f985 	bl	8025ad4 <__locale_mb_cur_max>
 80257ca:	4550      	cmp	r0, sl
 80257cc:	f43f ad78 	beq.w	80252c0 <__ssvfiscanf_r+0x240>
 80257d0:	e894 000a 	ldmia.w	r4, {r1, r3}
 80257d4:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80257d6:	f811 eb01 	ldrb.w	lr, [r1], #1
 80257da:	6021      	str	r1, [r4, #0]
 80257dc:	3b01      	subs	r3, #1
 80257de:	f10a 0801 	add.w	r8, sl, #1
 80257e2:	9200      	str	r2, [sp, #0]
 80257e4:	4639      	mov	r1, r7
 80257e6:	6063      	str	r3, [r4, #4]
 80257e8:	9807      	ldr	r0, [sp, #28]
 80257ea:	f809 e00a 	strb.w	lr, [r9, sl]
 80257ee:	4643      	mov	r3, r8
 80257f0:	464a      	mov	r2, r9
 80257f2:	f000 f975 	bl	8025ae0 <_mbrtowc_r>
 80257f6:	1c41      	adds	r1, r0, #1
 80257f8:	f43f ad62 	beq.w	80252c0 <__ssvfiscanf_r+0x240>
 80257fc:	2800      	cmp	r0, #0
 80257fe:	d141      	bne.n	8025884 <__ssvfiscanf_r+0x804>
 8025800:	b905      	cbnz	r5, 8025804 <__ssvfiscanf_r+0x784>
 8025802:	603d      	str	r5, [r7, #0]
 8025804:	9b03      	ldr	r3, [sp, #12]
 8025806:	4443      	add	r3, r8
 8025808:	9303      	str	r3, [sp, #12]
 802580a:	3e01      	subs	r6, #1
 802580c:	2d00      	cmp	r5, #0
 802580e:	d13d      	bne.n	802588c <__ssvfiscanf_r+0x80c>
 8025810:	3704      	adds	r7, #4
 8025812:	46aa      	mov	sl, r5
 8025814:	6863      	ldr	r3, [r4, #4]
 8025816:	2b00      	cmp	r3, #0
 8025818:	dd16      	ble.n	8025848 <__ssvfiscanf_r+0x7c8>
 802581a:	2e00      	cmp	r6, #0
 802581c:	d1d3      	bne.n	80257c6 <__ssvfiscanf_r+0x746>
 802581e:	9d03      	ldr	r5, [sp, #12]
 8025820:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 8025822:	f8dd 801c 	ldr.w	r8, [sp, #28]
 8025826:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8025828:	2b00      	cmp	r3, #0
 802582a:	d098      	beq.n	802575e <__ssvfiscanf_r+0x6de>
 802582c:	463a      	mov	r2, r7
 802582e:	e465      	b.n	80250fc <__ssvfiscanf_r+0x7c>
 8025830:	f429 69b0 	bic.w	r9, r9, #1408	; 0x580
 8025834:	e681      	b.n	802553a <__ssvfiscanf_r+0x4ba>
 8025836:	9a05      	ldr	r2, [sp, #20]
 8025838:	4613      	mov	r3, r2
 802583a:	3304      	adds	r3, #4
 802583c:	f8d2 a000 	ldr.w	sl, [r2]
 8025840:	9305      	str	r3, [sp, #20]
 8025842:	e779      	b.n	8025738 <__ssvfiscanf_r+0x6b8>
 8025844:	08029f90 	.word	0x08029f90
 8025848:	9807      	ldr	r0, [sp, #28]
 802584a:	4621      	mov	r1, r4
 802584c:	f7ff fbba 	bl	8024fc4 <__ssrefill_r>
 8025850:	2800      	cmp	r0, #0
 8025852:	d0e2      	beq.n	802581a <__ssvfiscanf_r+0x79a>
 8025854:	9d03      	ldr	r5, [sp, #12]
 8025856:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 8025858:	f8dd 801c 	ldr.w	r8, [sp, #28]
 802585c:	f1ba 0f00 	cmp.w	sl, #0
 8025860:	d0e1      	beq.n	8025826 <__ssvfiscanf_r+0x7a6>
 8025862:	e52d      	b.n	80252c0 <__ssvfiscanf_r+0x240>
 8025864:	9a05      	ldr	r2, [sp, #20]
 8025866:	6813      	ldr	r3, [r2, #0]
 8025868:	4619      	mov	r1, r3
 802586a:	4613      	mov	r3, r2
 802586c:	3304      	adds	r3, #4
 802586e:	9305      	str	r3, [sp, #20]
 8025870:	e79f      	b.n	80257b2 <__ssvfiscanf_r+0x732>
 8025872:	f019 0f04 	tst.w	r9, #4
 8025876:	d05b      	beq.n	8025930 <__ssvfiscanf_r+0x8b0>
 8025878:	9a05      	ldr	r2, [sp, #20]
 802587a:	6813      	ldr	r3, [r2, #0]
 802587c:	3204      	adds	r2, #4
 802587e:	9205      	str	r2, [sp, #20]
 8025880:	8018      	strh	r0, [r3, #0]
 8025882:	e785      	b.n	8025790 <__ssvfiscanf_r+0x710>
 8025884:	3002      	adds	r0, #2
 8025886:	d1bd      	bne.n	8025804 <__ssvfiscanf_r+0x784>
 8025888:	46c2      	mov	sl, r8
 802588a:	e7c3      	b.n	8025814 <__ssvfiscanf_r+0x794>
 802588c:	f04f 0a00 	mov.w	sl, #0
 8025890:	e7c0      	b.n	8025814 <__ssvfiscanf_r+0x794>
 8025892:	f1b9 0f00 	cmp.w	r9, #0
 8025896:	f43f ad13 	beq.w	80252c0 <__ssvfiscanf_r+0x240>
 802589a:	444d      	add	r5, r9
 802589c:	e5c4      	b.n	8025428 <__ssvfiscanf_r+0x3a8>
 802589e:	9b05      	ldr	r3, [sp, #20]
 80258a0:	4640      	mov	r0, r8
 80258a2:	6819      	ldr	r1, [r3, #0]
 80258a4:	9400      	str	r4, [sp, #0]
 80258a6:	4633      	mov	r3, r6
 80258a8:	2201      	movs	r2, #1
 80258aa:	f7ff fba9 	bl	8025000 <_sfread_r>
 80258ae:	9b05      	ldr	r3, [sp, #20]
 80258b0:	f103 0a04 	add.w	sl, r3, #4
 80258b4:	2800      	cmp	r0, #0
 80258b6:	f43f ad03 	beq.w	80252c0 <__ssvfiscanf_r+0x240>
 80258ba:	9b08      	ldr	r3, [sp, #32]
 80258bc:	f8cd a014 	str.w	sl, [sp, #20]
 80258c0:	3301      	adds	r3, #1
 80258c2:	4405      	add	r5, r0
 80258c4:	9308      	str	r3, [sp, #32]
 80258c6:	463a      	mov	r2, r7
 80258c8:	e418      	b.n	80250fc <__ssvfiscanf_r+0x7c>
 80258ca:	4640      	mov	r0, r8
 80258cc:	4621      	mov	r1, r4
 80258ce:	f7ff fb79 	bl	8024fc4 <__ssrefill_r>
 80258d2:	2800      	cmp	r0, #0
 80258d4:	f43f acaa 	beq.w	802522c <__ssvfiscanf_r+0x1ac>
 80258d8:	e4f2      	b.n	80252c0 <__ssvfiscanf_r+0x240>
 80258da:	f81a 1c01 	ldrb.w	r1, [sl, #-1]
 80258de:	f8cd c01c 	str.w	ip, [sp, #28]
 80258e2:	4640      	mov	r0, r8
 80258e4:	4622      	mov	r2, r4
 80258e6:	f7ff fb29 	bl	8024f3c <_sungetc_r>
 80258ea:	f10a 3aff 	add.w	sl, sl, #4294967295
 80258ee:	f8dd c01c 	ldr.w	ip, [sp, #28]
 80258f2:	e638      	b.n	8025566 <__ssvfiscanf_r+0x4e6>
 80258f4:	78bb      	ldrb	r3, [r7, #2]
 80258f6:	f049 0902 	orr.w	r9, r9, #2
 80258fa:	3702      	adds	r7, #2
 80258fc:	e40d      	b.n	802511a <__ssvfiscanf_r+0x9a>
 80258fe:	f019 0f01 	tst.w	r9, #1
 8025902:	d10d      	bne.n	8025920 <__ssvfiscanf_r+0x8a0>
 8025904:	f019 0f02 	tst.w	r9, #2
 8025908:	d00a      	beq.n	8025920 <__ssvfiscanf_r+0x8a0>
 802590a:	9a05      	ldr	r2, [sp, #20]
 802590c:	6813      	ldr	r3, [r2, #0]
 802590e:	4628      	mov	r0, r5
 8025910:	3204      	adds	r2, #4
 8025912:	17e9      	asrs	r1, r5, #31
 8025914:	9205      	str	r2, [sp, #20]
 8025916:	e9c3 0100 	strd	r0, r1, [r3]
 802591a:	463a      	mov	r2, r7
 802591c:	f7ff bbee 	b.w	80250fc <__ssvfiscanf_r+0x7c>
 8025920:	9a05      	ldr	r2, [sp, #20]
 8025922:	6813      	ldr	r3, [r2, #0]
 8025924:	3204      	adds	r2, #4
 8025926:	9205      	str	r2, [sp, #20]
 8025928:	601d      	str	r5, [r3, #0]
 802592a:	463a      	mov	r2, r7
 802592c:	f7ff bbe6 	b.w	80250fc <__ssvfiscanf_r+0x7c>
 8025930:	f019 0201 	ands.w	r2, r9, #1
 8025934:	f47f af27 	bne.w	8025786 <__ssvfiscanf_r+0x706>
 8025938:	f019 0f02 	tst.w	r9, #2
 802593c:	f43f af23 	beq.w	8025786 <__ssvfiscanf_r+0x706>
 8025940:	4b3c      	ldr	r3, [pc, #240]	; (8025a34 <__ssvfiscanf_r+0x9b4>)
 8025942:	9906      	ldr	r1, [sp, #24]
 8025944:	f8cd c01c 	str.w	ip, [sp, #28]
 8025948:	4299      	cmp	r1, r3
 802594a:	4640      	mov	r0, r8
 802594c:	4661      	mov	r1, ip
 802594e:	9b04      	ldr	r3, [sp, #16]
 8025950:	d067      	beq.n	8025a22 <__ssvfiscanf_r+0x9a2>
 8025952:	f000 f9f3 	bl	8025d3c <_strtoll_r>
 8025956:	f8dd c01c 	ldr.w	ip, [sp, #28]
 802595a:	9a05      	ldr	r2, [sp, #20]
 802595c:	6813      	ldr	r3, [r2, #0]
 802595e:	3204      	adds	r2, #4
 8025960:	9205      	str	r2, [sp, #20]
 8025962:	e9c3 0100 	strd	r0, r1, [r3]
 8025966:	e713      	b.n	8025790 <__ssvfiscanf_r+0x710>
 8025968:	f000 f8b4 	bl	8025ad4 <__locale_mb_cur_max>
 802596c:	4548      	cmp	r0, r9
 802596e:	f43f aca7 	beq.w	80252c0 <__ssvfiscanf_r+0x240>
 8025972:	e894 000a 	ldmia.w	r4, {r1, r3}
 8025976:	f10d 0e40 	add.w	lr, sp, #64	; 0x40
 802597a:	f811 2b01 	ldrb.w	r2, [r1], #1
 802597e:	6021      	str	r1, [r4, #0]
 8025980:	f109 0c01 	add.w	ip, r9, #1
 8025984:	9909      	ldr	r1, [sp, #36]	; 0x24
 8025986:	9100      	str	r1, [sp, #0]
 8025988:	3b01      	subs	r3, #1
 802598a:	6063      	str	r3, [r4, #4]
 802598c:	f80e 2009 	strb.w	r2, [lr, r9]
 8025990:	4663      	mov	r3, ip
 8025992:	4672      	mov	r2, lr
 8025994:	4640      	mov	r0, r8
 8025996:	4651      	mov	r1, sl
 8025998:	f8cd c01c 	str.w	ip, [sp, #28]
 802599c:	f000 f8a0 	bl	8025ae0 <_mbrtowc_r>
 80259a0:	1c42      	adds	r2, r0, #1
 80259a2:	f43f ac8d 	beq.w	80252c0 <__ssvfiscanf_r+0x240>
 80259a6:	f8dd c01c 	ldr.w	ip, [sp, #28]
 80259aa:	b198      	cbz	r0, 80259d4 <__ssvfiscanf_r+0x954>
 80259ac:	3002      	adds	r0, #2
 80259ae:	bf08      	it	eq
 80259b0:	46e1      	moveq	r9, ip
 80259b2:	d13b      	bne.n	8025a2c <__ssvfiscanf_r+0x9ac>
 80259b4:	6863      	ldr	r3, [r4, #4]
 80259b6:	2b00      	cmp	r3, #0
 80259b8:	f73f aec0 	bgt.w	802573c <__ssvfiscanf_r+0x6bc>
 80259bc:	4640      	mov	r0, r8
 80259be:	4621      	mov	r1, r4
 80259c0:	f7ff fb00 	bl	8024fc4 <__ssrefill_r>
 80259c4:	2800      	cmp	r0, #0
 80259c6:	f43f aeb9 	beq.w	802573c <__ssvfiscanf_r+0x6bc>
 80259ca:	464a      	mov	r2, r9
 80259cc:	2a00      	cmp	r2, #0
 80259ce:	f47f ac77 	bne.w	80252c0 <__ssvfiscanf_r+0x240>
 80259d2:	e6be      	b.n	8025752 <__ssvfiscanf_r+0x6d2>
 80259d4:	f8ca 0000 	str.w	r0, [sl]
 80259d8:	f8cd c01c 	str.w	ip, [sp, #28]
 80259dc:	f000 f868 	bl	8025ab0 <iswspace>
 80259e0:	f8dd c01c 	ldr.w	ip, [sp, #28]
 80259e4:	b198      	cbz	r0, 8025a0e <__ssvfiscanf_r+0x98e>
 80259e6:	46e1      	mov	r9, ip
 80259e8:	f1bc 0f00 	cmp.w	ip, #0
 80259ec:	f43f aeb1 	beq.w	8025752 <__ssvfiscanf_r+0x6d2>
 80259f0:	ab10      	add	r3, sp, #64	; 0x40
 80259f2:	eb03 060c 	add.w	r6, r3, ip
 80259f6:	f109 39ff 	add.w	r9, r9, #4294967295
 80259fa:	4640      	mov	r0, r8
 80259fc:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 8025a00:	4622      	mov	r2, r4
 8025a02:	f7ff fa9b 	bl	8024f3c <_sungetc_r>
 8025a06:	f1b9 0f00 	cmp.w	r9, #0
 8025a0a:	d1f4      	bne.n	80259f6 <__ssvfiscanf_r+0x976>
 8025a0c:	e6a1      	b.n	8025752 <__ssvfiscanf_r+0x6d2>
 8025a0e:	9b03      	ldr	r3, [sp, #12]
 8025a10:	4465      	add	r5, ip
 8025a12:	3e01      	subs	r6, #1
 8025a14:	b91b      	cbnz	r3, 8025a1e <__ssvfiscanf_r+0x99e>
 8025a16:	f10a 0a04 	add.w	sl, sl, #4
 8025a1a:	4699      	mov	r9, r3
 8025a1c:	e7ca      	b.n	80259b4 <__ssvfiscanf_r+0x934>
 8025a1e:	4681      	mov	r9, r0
 8025a20:	e7c8      	b.n	80259b4 <__ssvfiscanf_r+0x934>
 8025a22:	f000 fa71 	bl	8025f08 <_strtoull_r>
 8025a26:	f8dd c01c 	ldr.w	ip, [sp, #28]
 8025a2a:	e796      	b.n	802595a <__ssvfiscanf_r+0x8da>
 8025a2c:	f8da 0000 	ldr.w	r0, [sl]
 8025a30:	e7d2      	b.n	80259d8 <__ssvfiscanf_r+0x958>
 8025a32:	bf00      	nop
 8025a34:	08024265 	.word	0x08024265

08025a38 <__submore>:
 8025a38:	f101 0340 	add.w	r3, r1, #64	; 0x40
 8025a3c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8025a40:	460c      	mov	r4, r1
 8025a42:	6b09      	ldr	r1, [r1, #48]	; 0x30
 8025a44:	4299      	cmp	r1, r3
 8025a46:	d014      	beq.n	8025a72 <__submore+0x3a>
 8025a48:	6b66      	ldr	r6, [r4, #52]	; 0x34
 8025a4a:	0077      	lsls	r7, r6, #1
 8025a4c:	463a      	mov	r2, r7
 8025a4e:	f7f3 fff3 	bl	8019a38 <_realloc_r>
 8025a52:	4605      	mov	r5, r0
 8025a54:	b340      	cbz	r0, 8025aa8 <__submore+0x70>
 8025a56:	eb00 0806 	add.w	r8, r0, r6
 8025a5a:	4632      	mov	r2, r6
 8025a5c:	4640      	mov	r0, r8
 8025a5e:	4629      	mov	r1, r5
 8025a60:	f7da fc3c 	bl	80002dc <memcpy>
 8025a64:	f8c4 8000 	str.w	r8, [r4]
 8025a68:	6325      	str	r5, [r4, #48]	; 0x30
 8025a6a:	6367      	str	r7, [r4, #52]	; 0x34
 8025a6c:	2000      	movs	r0, #0
 8025a6e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8025a72:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8025a76:	f7f3 ffcb 	bl	8019a10 <_malloc_r>
 8025a7a:	b1a8      	cbz	r0, 8025aa8 <__submore+0x70>
 8025a7c:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8025a80:	6320      	str	r0, [r4, #48]	; 0x30
 8025a82:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8025a86:	6362      	str	r2, [r4, #52]	; 0x34
 8025a88:	f880 33ff 	strb.w	r3, [r0, #1023]	; 0x3ff
 8025a8c:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8025a90:	f880 33fe 	strb.w	r3, [r0, #1022]	; 0x3fe
 8025a94:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8025a98:	f880 33fd 	strb.w	r3, [r0, #1021]	; 0x3fd
 8025a9c:	f200 30fd 	addw	r0, r0, #1021	; 0x3fd
 8025aa0:	6020      	str	r0, [r4, #0]
 8025aa2:	2000      	movs	r0, #0
 8025aa4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8025aa8:	f04f 30ff 	mov.w	r0, #4294967295
 8025aac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08025ab0 <iswspace>:
 8025ab0:	28ff      	cmp	r0, #255	; 0xff
 8025ab2:	d807      	bhi.n	8025ac4 <iswspace+0x14>
 8025ab4:	4b04      	ldr	r3, [pc, #16]	; (8025ac8 <iswspace+0x18>)
 8025ab6:	681b      	ldr	r3, [r3, #0]
 8025ab8:	4418      	add	r0, r3
 8025aba:	7840      	ldrb	r0, [r0, #1]
 8025abc:	f000 0008 	and.w	r0, r0, #8
 8025ac0:	b2c0      	uxtb	r0, r0
 8025ac2:	4770      	bx	lr
 8025ac4:	2000      	movs	r0, #0
 8025ac6:	4770      	bx	lr
 8025ac8:	20010114 	.word	0x20010114

08025acc <__locale_charset>:
 8025acc:	4800      	ldr	r0, [pc, #0]	; (8025ad0 <__locale_charset+0x4>)
 8025ace:	4770      	bx	lr
 8025ad0:	2001058c 	.word	0x2001058c

08025ad4 <__locale_mb_cur_max>:
 8025ad4:	4b01      	ldr	r3, [pc, #4]	; (8025adc <__locale_mb_cur_max+0x8>)
 8025ad6:	6818      	ldr	r0, [r3, #0]
 8025ad8:	4770      	bx	lr
 8025ada:	bf00      	nop
 8025adc:	200105ac 	.word	0x200105ac

08025ae0 <_mbrtowc_r>:
 8025ae0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8025ae4:	b083      	sub	sp, #12
 8025ae6:	4605      	mov	r5, r0
 8025ae8:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 8025aea:	4614      	mov	r4, r2
 8025aec:	b1b2      	cbz	r2, 8025b1c <_mbrtowc_r+0x3c>
 8025aee:	461f      	mov	r7, r3
 8025af0:	4b10      	ldr	r3, [pc, #64]	; (8025b34 <_mbrtowc_r+0x54>)
 8025af2:	4688      	mov	r8, r1
 8025af4:	f8d3 9000 	ldr.w	r9, [r3]
 8025af8:	f7ff ffe8 	bl	8025acc <__locale_charset>
 8025afc:	4641      	mov	r1, r8
 8025afe:	e88d 0041 	stmia.w	sp, {r0, r6}
 8025b02:	4622      	mov	r2, r4
 8025b04:	463b      	mov	r3, r7
 8025b06:	4628      	mov	r0, r5
 8025b08:	47c8      	blx	r9
 8025b0a:	1c43      	adds	r3, r0, #1
 8025b0c:	d103      	bne.n	8025b16 <_mbrtowc_r+0x36>
 8025b0e:	2200      	movs	r2, #0
 8025b10:	238a      	movs	r3, #138	; 0x8a
 8025b12:	6032      	str	r2, [r6, #0]
 8025b14:	602b      	str	r3, [r5, #0]
 8025b16:	b003      	add	sp, #12
 8025b18:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8025b1c:	4b05      	ldr	r3, [pc, #20]	; (8025b34 <_mbrtowc_r+0x54>)
 8025b1e:	681f      	ldr	r7, [r3, #0]
 8025b20:	f7ff ffd4 	bl	8025acc <__locale_charset>
 8025b24:	4621      	mov	r1, r4
 8025b26:	e88d 0041 	stmia.w	sp, {r0, r6}
 8025b2a:	4a03      	ldr	r2, [pc, #12]	; (8025b38 <_mbrtowc_r+0x58>)
 8025b2c:	4628      	mov	r0, r5
 8025b2e:	2301      	movs	r3, #1
 8025b30:	47b8      	blx	r7
 8025b32:	e7ea      	b.n	8025b0a <_mbrtowc_r+0x2a>
 8025b34:	200105b0 	.word	0x200105b0
 8025b38:	08029f60 	.word	0x08029f60

08025b3c <__ascii_mbtowc>:
 8025b3c:	b082      	sub	sp, #8
 8025b3e:	b149      	cbz	r1, 8025b54 <__ascii_mbtowc+0x18>
 8025b40:	b15a      	cbz	r2, 8025b5a <__ascii_mbtowc+0x1e>
 8025b42:	b16b      	cbz	r3, 8025b60 <__ascii_mbtowc+0x24>
 8025b44:	7813      	ldrb	r3, [r2, #0]
 8025b46:	600b      	str	r3, [r1, #0]
 8025b48:	7812      	ldrb	r2, [r2, #0]
 8025b4a:	1c10      	adds	r0, r2, #0
 8025b4c:	bf18      	it	ne
 8025b4e:	2001      	movne	r0, #1
 8025b50:	b002      	add	sp, #8
 8025b52:	4770      	bx	lr
 8025b54:	a901      	add	r1, sp, #4
 8025b56:	2a00      	cmp	r2, #0
 8025b58:	d1f3      	bne.n	8025b42 <__ascii_mbtowc+0x6>
 8025b5a:	4610      	mov	r0, r2
 8025b5c:	b002      	add	sp, #8
 8025b5e:	4770      	bx	lr
 8025b60:	f06f 0001 	mvn.w	r0, #1
 8025b64:	e7f4      	b.n	8025b50 <__ascii_mbtowc+0x14>
 8025b66:	bf00      	nop

08025b68 <memchr>:
 8025b68:	0783      	lsls	r3, r0, #30
 8025b6a:	b470      	push	{r4, r5, r6}
 8025b6c:	b2c9      	uxtb	r1, r1
 8025b6e:	d040      	beq.n	8025bf2 <memchr+0x8a>
 8025b70:	1e54      	subs	r4, r2, #1
 8025b72:	2a00      	cmp	r2, #0
 8025b74:	d03f      	beq.n	8025bf6 <memchr+0x8e>
 8025b76:	7803      	ldrb	r3, [r0, #0]
 8025b78:	428b      	cmp	r3, r1
 8025b7a:	bf18      	it	ne
 8025b7c:	1c43      	addne	r3, r0, #1
 8025b7e:	d106      	bne.n	8025b8e <memchr+0x26>
 8025b80:	e01d      	b.n	8025bbe <memchr+0x56>
 8025b82:	b1f4      	cbz	r4, 8025bc2 <memchr+0x5a>
 8025b84:	7802      	ldrb	r2, [r0, #0]
 8025b86:	428a      	cmp	r2, r1
 8025b88:	f104 34ff 	add.w	r4, r4, #4294967295
 8025b8c:	d017      	beq.n	8025bbe <memchr+0x56>
 8025b8e:	f013 0f03 	tst.w	r3, #3
 8025b92:	4618      	mov	r0, r3
 8025b94:	f103 0301 	add.w	r3, r3, #1
 8025b98:	d1f3      	bne.n	8025b82 <memchr+0x1a>
 8025b9a:	2c03      	cmp	r4, #3
 8025b9c:	d814      	bhi.n	8025bc8 <memchr+0x60>
 8025b9e:	b184      	cbz	r4, 8025bc2 <memchr+0x5a>
 8025ba0:	7803      	ldrb	r3, [r0, #0]
 8025ba2:	428b      	cmp	r3, r1
 8025ba4:	d00b      	beq.n	8025bbe <memchr+0x56>
 8025ba6:	1905      	adds	r5, r0, r4
 8025ba8:	1c43      	adds	r3, r0, #1
 8025baa:	e002      	b.n	8025bb2 <memchr+0x4a>
 8025bac:	7802      	ldrb	r2, [r0, #0]
 8025bae:	428a      	cmp	r2, r1
 8025bb0:	d005      	beq.n	8025bbe <memchr+0x56>
 8025bb2:	42ab      	cmp	r3, r5
 8025bb4:	4618      	mov	r0, r3
 8025bb6:	f103 0301 	add.w	r3, r3, #1
 8025bba:	d1f7      	bne.n	8025bac <memchr+0x44>
 8025bbc:	2000      	movs	r0, #0
 8025bbe:	bc70      	pop	{r4, r5, r6}
 8025bc0:	4770      	bx	lr
 8025bc2:	4620      	mov	r0, r4
 8025bc4:	bc70      	pop	{r4, r5, r6}
 8025bc6:	4770      	bx	lr
 8025bc8:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 8025bcc:	4602      	mov	r2, r0
 8025bce:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 8025bd2:	4610      	mov	r0, r2
 8025bd4:	3204      	adds	r2, #4
 8025bd6:	6803      	ldr	r3, [r0, #0]
 8025bd8:	4073      	eors	r3, r6
 8025bda:	f1a3 3501 	sub.w	r5, r3, #16843009	; 0x1010101
 8025bde:	ea25 0303 	bic.w	r3, r5, r3
 8025be2:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8025be6:	d1da      	bne.n	8025b9e <memchr+0x36>
 8025be8:	3c04      	subs	r4, #4
 8025bea:	2c03      	cmp	r4, #3
 8025bec:	4610      	mov	r0, r2
 8025bee:	d8f0      	bhi.n	8025bd2 <memchr+0x6a>
 8025bf0:	e7d5      	b.n	8025b9e <memchr+0x36>
 8025bf2:	4614      	mov	r4, r2
 8025bf4:	e7d1      	b.n	8025b9a <memchr+0x32>
 8025bf6:	4610      	mov	r0, r2
 8025bf8:	e7e1      	b.n	8025bbe <memchr+0x56>
 8025bfa:	bf00      	nop

08025bfc <memmove>:
 8025bfc:	4288      	cmp	r0, r1
 8025bfe:	b5f0      	push	{r4, r5, r6, r7, lr}
 8025c00:	d90d      	bls.n	8025c1e <memmove+0x22>
 8025c02:	188b      	adds	r3, r1, r2
 8025c04:	4298      	cmp	r0, r3
 8025c06:	d20a      	bcs.n	8025c1e <memmove+0x22>
 8025c08:	1881      	adds	r1, r0, r2
 8025c0a:	2a00      	cmp	r2, #0
 8025c0c:	d054      	beq.n	8025cb8 <memmove+0xbc>
 8025c0e:	1a9a      	subs	r2, r3, r2
 8025c10:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8025c14:	f801 4d01 	strb.w	r4, [r1, #-1]!
 8025c18:	4293      	cmp	r3, r2
 8025c1a:	d1f9      	bne.n	8025c10 <memmove+0x14>
 8025c1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8025c1e:	2a0f      	cmp	r2, #15
 8025c20:	d948      	bls.n	8025cb4 <memmove+0xb8>
 8025c22:	ea40 0301 	orr.w	r3, r0, r1
 8025c26:	079b      	lsls	r3, r3, #30
 8025c28:	d147      	bne.n	8025cba <memmove+0xbe>
 8025c2a:	f100 0410 	add.w	r4, r0, #16
 8025c2e:	f101 0310 	add.w	r3, r1, #16
 8025c32:	4615      	mov	r5, r2
 8025c34:	f853 6c10 	ldr.w	r6, [r3, #-16]
 8025c38:	f844 6c10 	str.w	r6, [r4, #-16]
 8025c3c:	f853 6c0c 	ldr.w	r6, [r3, #-12]
 8025c40:	f844 6c0c 	str.w	r6, [r4, #-12]
 8025c44:	f853 6c08 	ldr.w	r6, [r3, #-8]
 8025c48:	f844 6c08 	str.w	r6, [r4, #-8]
 8025c4c:	3d10      	subs	r5, #16
 8025c4e:	f853 6c04 	ldr.w	r6, [r3, #-4]
 8025c52:	f844 6c04 	str.w	r6, [r4, #-4]
 8025c56:	2d0f      	cmp	r5, #15
 8025c58:	f103 0310 	add.w	r3, r3, #16
 8025c5c:	f104 0410 	add.w	r4, r4, #16
 8025c60:	d8e8      	bhi.n	8025c34 <memmove+0x38>
 8025c62:	f1a2 0310 	sub.w	r3, r2, #16
 8025c66:	f023 030f 	bic.w	r3, r3, #15
 8025c6a:	f002 0e0f 	and.w	lr, r2, #15
 8025c6e:	3310      	adds	r3, #16
 8025c70:	f1be 0f03 	cmp.w	lr, #3
 8025c74:	4419      	add	r1, r3
 8025c76:	4403      	add	r3, r0
 8025c78:	d921      	bls.n	8025cbe <memmove+0xc2>
 8025c7a:	1f1e      	subs	r6, r3, #4
 8025c7c:	460d      	mov	r5, r1
 8025c7e:	4674      	mov	r4, lr
 8025c80:	3c04      	subs	r4, #4
 8025c82:	f855 7b04 	ldr.w	r7, [r5], #4
 8025c86:	f846 7f04 	str.w	r7, [r6, #4]!
 8025c8a:	2c03      	cmp	r4, #3
 8025c8c:	d8f8      	bhi.n	8025c80 <memmove+0x84>
 8025c8e:	f1ae 0404 	sub.w	r4, lr, #4
 8025c92:	f024 0403 	bic.w	r4, r4, #3
 8025c96:	3404      	adds	r4, #4
 8025c98:	4423      	add	r3, r4
 8025c9a:	4421      	add	r1, r4
 8025c9c:	f002 0203 	and.w	r2, r2, #3
 8025ca0:	b152      	cbz	r2, 8025cb8 <memmove+0xbc>
 8025ca2:	3b01      	subs	r3, #1
 8025ca4:	440a      	add	r2, r1
 8025ca6:	f811 4b01 	ldrb.w	r4, [r1], #1
 8025caa:	f803 4f01 	strb.w	r4, [r3, #1]!
 8025cae:	4291      	cmp	r1, r2
 8025cb0:	d1f9      	bne.n	8025ca6 <memmove+0xaa>
 8025cb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8025cb4:	4603      	mov	r3, r0
 8025cb6:	e7f3      	b.n	8025ca0 <memmove+0xa4>
 8025cb8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8025cba:	4603      	mov	r3, r0
 8025cbc:	e7f1      	b.n	8025ca2 <memmove+0xa6>
 8025cbe:	4672      	mov	r2, lr
 8025cc0:	e7ee      	b.n	8025ca0 <memmove+0xa4>
 8025cc2:	bf00      	nop

08025cc4 <__sccl>:
 8025cc4:	b470      	push	{r4, r5, r6}
 8025cc6:	780d      	ldrb	r5, [r1, #0]
 8025cc8:	2d5e      	cmp	r5, #94	; 0x5e
 8025cca:	d02f      	beq.n	8025d2c <__sccl+0x68>
 8025ccc:	2200      	movs	r2, #0
 8025cce:	3101      	adds	r1, #1
 8025cd0:	4616      	mov	r6, r2
 8025cd2:	1e43      	subs	r3, r0, #1
 8025cd4:	f100 04ff 	add.w	r4, r0, #255	; 0xff
 8025cd8:	f803 2f01 	strb.w	r2, [r3, #1]!
 8025cdc:	42a3      	cmp	r3, r4
 8025cde:	d1fb      	bne.n	8025cd8 <__sccl+0x14>
 8025ce0:	b185      	cbz	r5, 8025d04 <__sccl+0x40>
 8025ce2:	f086 0201 	eor.w	r2, r6, #1
 8025ce6:	5542      	strb	r2, [r0, r5]
 8025ce8:	1c4e      	adds	r6, r1, #1
 8025cea:	f816 3c01 	ldrb.w	r3, [r6, #-1]
 8025cee:	2b2d      	cmp	r3, #45	; 0x2d
 8025cf0:	d00e      	beq.n	8025d10 <__sccl+0x4c>
 8025cf2:	2b5d      	cmp	r3, #93	; 0x5d
 8025cf4:	d009      	beq.n	8025d0a <__sccl+0x46>
 8025cf6:	b113      	cbz	r3, 8025cfe <__sccl+0x3a>
 8025cf8:	461d      	mov	r5, r3
 8025cfa:	4631      	mov	r1, r6
 8025cfc:	e7f3      	b.n	8025ce6 <__sccl+0x22>
 8025cfe:	4608      	mov	r0, r1
 8025d00:	bc70      	pop	{r4, r5, r6}
 8025d02:	4770      	bx	lr
 8025d04:	1e48      	subs	r0, r1, #1
 8025d06:	bc70      	pop	{r4, r5, r6}
 8025d08:	4770      	bx	lr
 8025d0a:	4630      	mov	r0, r6
 8025d0c:	bc70      	pop	{r4, r5, r6}
 8025d0e:	4770      	bx	lr
 8025d10:	784c      	ldrb	r4, [r1, #1]
 8025d12:	2c5d      	cmp	r4, #93	; 0x5d
 8025d14:	d00f      	beq.n	8025d36 <__sccl+0x72>
 8025d16:	42a5      	cmp	r5, r4
 8025d18:	dc0d      	bgt.n	8025d36 <__sccl+0x72>
 8025d1a:	3102      	adds	r1, #2
 8025d1c:	1943      	adds	r3, r0, r5
 8025d1e:	3501      	adds	r5, #1
 8025d20:	42ac      	cmp	r4, r5
 8025d22:	f803 2f01 	strb.w	r2, [r3, #1]!
 8025d26:	dcfa      	bgt.n	8025d1e <__sccl+0x5a>
 8025d28:	3602      	adds	r6, #2
 8025d2a:	e7de      	b.n	8025cea <__sccl+0x26>
 8025d2c:	2201      	movs	r2, #1
 8025d2e:	784d      	ldrb	r5, [r1, #1]
 8025d30:	4616      	mov	r6, r2
 8025d32:	3102      	adds	r1, #2
 8025d34:	e7cd      	b.n	8025cd2 <__sccl+0xe>
 8025d36:	4631      	mov	r1, r6
 8025d38:	461d      	mov	r5, r3
 8025d3a:	e7d4      	b.n	8025ce6 <__sccl+0x22>

08025d3c <_strtoll_r>:
 8025d3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025d40:	4c70      	ldr	r4, [pc, #448]	; (8025f04 <_strtoll_r+0x1c8>)
 8025d42:	b087      	sub	sp, #28
 8025d44:	469b      	mov	fp, r3
 8025d46:	9201      	str	r2, [sp, #4]
 8025d48:	9104      	str	r1, [sp, #16]
 8025d4a:	9005      	str	r0, [sp, #20]
 8025d4c:	460a      	mov	r2, r1
 8025d4e:	f8d4 a000 	ldr.w	sl, [r4]
 8025d52:	e000      	b.n	8025d56 <_strtoll_r+0x1a>
 8025d54:	462a      	mov	r2, r5
 8025d56:	4615      	mov	r5, r2
 8025d58:	f815 4b01 	ldrb.w	r4, [r5], #1
 8025d5c:	eb0a 0304 	add.w	r3, sl, r4
 8025d60:	785b      	ldrb	r3, [r3, #1]
 8025d62:	f003 0308 	and.w	r3, r3, #8
 8025d66:	f003 01ff 	and.w	r1, r3, #255	; 0xff
 8025d6a:	2b00      	cmp	r3, #0
 8025d6c:	d1f2      	bne.n	8025d54 <_strtoll_r+0x18>
 8025d6e:	2c2d      	cmp	r4, #45	; 0x2d
 8025d70:	f000 8092 	beq.w	8025e98 <_strtoll_r+0x15c>
 8025d74:	2c2b      	cmp	r4, #43	; 0x2b
 8025d76:	bf08      	it	eq
 8025d78:	7854      	ldrbeq	r4, [r2, #1]
 8025d7a:	468c      	mov	ip, r1
 8025d7c:	bf08      	it	eq
 8025d7e:	1c95      	addeq	r5, r2, #2
 8025d80:	f1bb 0f00 	cmp.w	fp, #0
 8025d84:	d071      	beq.n	8025e6a <_strtoll_r+0x12e>
 8025d86:	f1bb 0f10 	cmp.w	fp, #16
 8025d8a:	f000 80a2 	beq.w	8025ed2 <_strtoll_r+0x196>
 8025d8e:	465e      	mov	r6, fp
 8025d90:	17f7      	asrs	r7, r6, #31
 8025d92:	f1bc 0f00 	cmp.w	ip, #0
 8025d96:	d171      	bne.n	8025e7c <_strtoll_r+0x140>
 8025d98:	f04f 38ff 	mov.w	r8, #4294967295
 8025d9c:	f06f 4900 	mvn.w	r9, #2147483648	; 0x80000000
 8025da0:	4640      	mov	r0, r8
 8025da2:	4649      	mov	r1, r9
 8025da4:	4632      	mov	r2, r6
 8025da6:	463b      	mov	r3, r7
 8025da8:	f8cd c00c 	str.w	ip, [sp, #12]
 8025dac:	f7db f96a 	bl	8001084 <__aeabi_uldivmod>
 8025db0:	4640      	mov	r0, r8
 8025db2:	9202      	str	r2, [sp, #8]
 8025db4:	463b      	mov	r3, r7
 8025db6:	4632      	mov	r2, r6
 8025db8:	4649      	mov	r1, r9
 8025dba:	f7db f963 	bl	8001084 <__aeabi_uldivmod>
 8025dbe:	f04f 0e00 	mov.w	lr, #0
 8025dc2:	2200      	movs	r2, #0
 8025dc4:	2300      	movs	r3, #0
 8025dc6:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8025dca:	f8dd 8008 	ldr.w	r8, [sp, #8]
 8025dce:	e01b      	b.n	8025e08 <_strtoll_r+0xcc>
 8025dd0:	3c30      	subs	r4, #48	; 0x30
 8025dd2:	45a3      	cmp	fp, r4
 8025dd4:	dd2d      	ble.n	8025e32 <_strtoll_r+0xf6>
 8025dd6:	f1be 3fff 	cmp.w	lr, #4294967295
 8025dda:	d013      	beq.n	8025e04 <_strtoll_r+0xc8>
 8025ddc:	4299      	cmp	r1, r3
 8025dde:	bf08      	it	eq
 8025de0:	4290      	cmpeq	r0, r2
 8025de2:	d352      	bcc.n	8025e8a <_strtoll_r+0x14e>
 8025de4:	428b      	cmp	r3, r1
 8025de6:	bf08      	it	eq
 8025de8:	4282      	cmpeq	r2, r0
 8025dea:	d04c      	beq.n	8025e86 <_strtoll_r+0x14a>
 8025dec:	fb02 fe07 	mul.w	lr, r2, r7
 8025df0:	fb06 ee03 	mla	lr, r6, r3, lr
 8025df4:	fba2 2306 	umull	r2, r3, r2, r6
 8025df8:	4473      	add	r3, lr
 8025dfa:	1912      	adds	r2, r2, r4
 8025dfc:	eb43 73e4 	adc.w	r3, r3, r4, asr #31
 8025e00:	f04f 0e01 	mov.w	lr, #1
 8025e04:	f815 4b01 	ldrb.w	r4, [r5], #1
 8025e08:	eb0a 0904 	add.w	r9, sl, r4
 8025e0c:	f899 9001 	ldrb.w	r9, [r9, #1]
 8025e10:	f019 0f04 	tst.w	r9, #4
 8025e14:	d1dc      	bne.n	8025dd0 <_strtoll_r+0x94>
 8025e16:	f019 0903 	ands.w	r9, r9, #3
 8025e1a:	d00a      	beq.n	8025e32 <_strtoll_r+0xf6>
 8025e1c:	f1b9 0f01 	cmp.w	r9, #1
 8025e20:	bf0c      	ite	eq
 8025e22:	f04f 0937 	moveq.w	r9, #55	; 0x37
 8025e26:	f04f 0957 	movne.w	r9, #87	; 0x57
 8025e2a:	ebc9 0404 	rsb	r4, r9, r4
 8025e2e:	45a3      	cmp	fp, r4
 8025e30:	dcd1      	bgt.n	8025dd6 <_strtoll_r+0x9a>
 8025e32:	f1be 3fff 	cmp.w	lr, #4294967295
 8025e36:	d034      	beq.n	8025ea2 <_strtoll_r+0x166>
 8025e38:	4660      	mov	r0, ip
 8025e3a:	17c1      	asrs	r1, r0, #31
 8025e3c:	f1dc 0600 	rsbs	r6, ip, #0
 8025e40:	eb61 0741 	sbc.w	r7, r1, r1, lsl #1
 8025e44:	4072      	eors	r2, r6
 8025e46:	407b      	eors	r3, r7
 8025e48:	eb12 020c 	adds.w	r2, r2, ip
 8025e4c:	414b      	adcs	r3, r1
 8025e4e:	9901      	ldr	r1, [sp, #4]
 8025e50:	2900      	cmp	r1, #0
 8025e52:	d053      	beq.n	8025efc <_strtoll_r+0x1c0>
 8025e54:	f1be 0f00 	cmp.w	lr, #0
 8025e58:	d11a      	bne.n	8025e90 <_strtoll_r+0x154>
 8025e5a:	9d04      	ldr	r5, [sp, #16]
 8025e5c:	4610      	mov	r0, r2
 8025e5e:	4619      	mov	r1, r3
 8025e60:	9b01      	ldr	r3, [sp, #4]
 8025e62:	601d      	str	r5, [r3, #0]
 8025e64:	b007      	add	sp, #28
 8025e66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025e6a:	2c30      	cmp	r4, #48	; 0x30
 8025e6c:	d027      	beq.n	8025ebe <_strtoll_r+0x182>
 8025e6e:	260a      	movs	r6, #10
 8025e70:	2700      	movs	r7, #0
 8025e72:	f04f 0b0a 	mov.w	fp, #10
 8025e76:	f1bc 0f00 	cmp.w	ip, #0
 8025e7a:	d08d      	beq.n	8025d98 <_strtoll_r+0x5c>
 8025e7c:	f04f 0800 	mov.w	r8, #0
 8025e80:	f04f 4900 	mov.w	r9, #2147483648	; 0x80000000
 8025e84:	e78c      	b.n	8025da0 <_strtoll_r+0x64>
 8025e86:	4544      	cmp	r4, r8
 8025e88:	ddb0      	ble.n	8025dec <_strtoll_r+0xb0>
 8025e8a:	f04f 3eff 	mov.w	lr, #4294967295
 8025e8e:	e7b9      	b.n	8025e04 <_strtoll_r+0xc8>
 8025e90:	4610      	mov	r0, r2
 8025e92:	4619      	mov	r1, r3
 8025e94:	3d01      	subs	r5, #1
 8025e96:	e7e3      	b.n	8025e60 <_strtoll_r+0x124>
 8025e98:	1c95      	adds	r5, r2, #2
 8025e9a:	7854      	ldrb	r4, [r2, #1]
 8025e9c:	f04f 0c01 	mov.w	ip, #1
 8025ea0:	e76e      	b.n	8025d80 <_strtoll_r+0x44>
 8025ea2:	f1bc 0f00 	cmp.w	ip, #0
 8025ea6:	d119      	bne.n	8025edc <_strtoll_r+0x1a0>
 8025ea8:	f04f 30ff 	mov.w	r0, #4294967295
 8025eac:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8025eb0:	9a05      	ldr	r2, [sp, #20]
 8025eb2:	2322      	movs	r3, #34	; 0x22
 8025eb4:	6013      	str	r3, [r2, #0]
 8025eb6:	9b01      	ldr	r3, [sp, #4]
 8025eb8:	2b00      	cmp	r3, #0
 8025eba:	d1eb      	bne.n	8025e94 <_strtoll_r+0x158>
 8025ebc:	e7d2      	b.n	8025e64 <_strtoll_r+0x128>
 8025ebe:	782b      	ldrb	r3, [r5, #0]
 8025ec0:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8025ec4:	2b58      	cmp	r3, #88	; 0x58
 8025ec6:	d012      	beq.n	8025eee <_strtoll_r+0x1b2>
 8025ec8:	2608      	movs	r6, #8
 8025eca:	2700      	movs	r7, #0
 8025ecc:	f04f 0b08 	mov.w	fp, #8
 8025ed0:	e75f      	b.n	8025d92 <_strtoll_r+0x56>
 8025ed2:	2c30      	cmp	r4, #48	; 0x30
 8025ed4:	d006      	beq.n	8025ee4 <_strtoll_r+0x1a8>
 8025ed6:	2610      	movs	r6, #16
 8025ed8:	2700      	movs	r7, #0
 8025eda:	e75a      	b.n	8025d92 <_strtoll_r+0x56>
 8025edc:	2000      	movs	r0, #0
 8025ede:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
 8025ee2:	e7e5      	b.n	8025eb0 <_strtoll_r+0x174>
 8025ee4:	782b      	ldrb	r3, [r5, #0]
 8025ee6:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8025eea:	2b58      	cmp	r3, #88	; 0x58
 8025eec:	d1f3      	bne.n	8025ed6 <_strtoll_r+0x19a>
 8025eee:	786c      	ldrb	r4, [r5, #1]
 8025ef0:	2610      	movs	r6, #16
 8025ef2:	2700      	movs	r7, #0
 8025ef4:	3502      	adds	r5, #2
 8025ef6:	f04f 0b10 	mov.w	fp, #16
 8025efa:	e74a      	b.n	8025d92 <_strtoll_r+0x56>
 8025efc:	4610      	mov	r0, r2
 8025efe:	4619      	mov	r1, r3
 8025f00:	e7b0      	b.n	8025e64 <_strtoll_r+0x128>
 8025f02:	bf00      	nop
 8025f04:	20010114 	.word	0x20010114

08025f08 <_strtoull_r>:
 8025f08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025f0c:	4c72      	ldr	r4, [pc, #456]	; (80260d8 <_strtoull_r+0x1d0>)
 8025f0e:	b087      	sub	sp, #28
 8025f10:	4692      	mov	sl, r2
 8025f12:	468b      	mov	fp, r1
 8025f14:	9004      	str	r0, [sp, #16]
 8025f16:	4699      	mov	r9, r3
 8025f18:	460a      	mov	r2, r1
 8025f1a:	f8d4 8000 	ldr.w	r8, [r4]
 8025f1e:	e000      	b.n	8025f22 <_strtoull_r+0x1a>
 8025f20:	462a      	mov	r2, r5
 8025f22:	4615      	mov	r5, r2
 8025f24:	f815 4b01 	ldrb.w	r4, [r5], #1
 8025f28:	eb08 0304 	add.w	r3, r8, r4
 8025f2c:	785b      	ldrb	r3, [r3, #1]
 8025f2e:	f003 0308 	and.w	r3, r3, #8
 8025f32:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8025f36:	2b00      	cmp	r3, #0
 8025f38:	d1f2      	bne.n	8025f20 <_strtoull_r+0x18>
 8025f3a:	2c2d      	cmp	r4, #45	; 0x2d
 8025f3c:	f000 8099 	beq.w	8026072 <_strtoull_r+0x16a>
 8025f40:	2c2b      	cmp	r4, #43	; 0x2b
 8025f42:	bf08      	it	eq
 8025f44:	7854      	ldrbeq	r4, [r2, #1]
 8025f46:	9003      	str	r0, [sp, #12]
 8025f48:	bf08      	it	eq
 8025f4a:	1c95      	addeq	r5, r2, #2
 8025f4c:	f1b9 0f00 	cmp.w	r9, #0
 8025f50:	d01d      	beq.n	8025f8e <_strtoull_r+0x86>
 8025f52:	f1b9 0f10 	cmp.w	r9, #16
 8025f56:	f000 80a1 	beq.w	802609c <_strtoull_r+0x194>
 8025f5a:	464e      	mov	r6, r9
 8025f5c:	17f7      	asrs	r7, r6, #31
 8025f5e:	464a      	mov	r2, r9
 8025f60:	463b      	mov	r3, r7
 8025f62:	f04f 30ff 	mov.w	r0, #4294967295
 8025f66:	f04f 31ff 	mov.w	r1, #4294967295
 8025f6a:	f7db f88b 	bl	8001084 <__aeabi_uldivmod>
 8025f6e:	464a      	mov	r2, r9
 8025f70:	9005      	str	r0, [sp, #20]
 8025f72:	9100      	str	r1, [sp, #0]
 8025f74:	463b      	mov	r3, r7
 8025f76:	f04f 30ff 	mov.w	r0, #4294967295
 8025f7a:	f04f 31ff 	mov.w	r1, #4294967295
 8025f7e:	f7db f881 	bl	8001084 <__aeabi_uldivmod>
 8025f82:	f8dd c014 	ldr.w	ip, [sp, #20]
 8025f86:	9202      	str	r2, [sp, #8]
 8025f88:	4660      	mov	r0, ip
 8025f8a:	9900      	ldr	r1, [sp, #0]
 8025f8c:	e00a      	b.n	8025fa4 <_strtoull_r+0x9c>
 8025f8e:	2c30      	cmp	r4, #48	; 0x30
 8025f90:	d074      	beq.n	802607c <_strtoull_r+0x174>
 8025f92:	2305      	movs	r3, #5
 8025f94:	4951      	ldr	r1, [pc, #324]	; (80260dc <_strtoull_r+0x1d4>)
 8025f96:	9302      	str	r3, [sp, #8]
 8025f98:	f04f 3099 	mov.w	r0, #2576980377	; 0x99999999
 8025f9c:	260a      	movs	r6, #10
 8025f9e:	2700      	movs	r7, #0
 8025fa0:	f04f 090a 	mov.w	r9, #10
 8025fa4:	f04f 0e00 	mov.w	lr, #0
 8025fa8:	2200      	movs	r2, #0
 8025faa:	2300      	movs	r3, #0
 8025fac:	e9cd 6700 	strd	r6, r7, [sp]
 8025fb0:	e01d      	b.n	8025fee <_strtoull_r+0xe6>
 8025fb2:	3c30      	subs	r4, #48	; 0x30
 8025fb4:	45a1      	cmp	r9, r4
 8025fb6:	dd2f      	ble.n	8026018 <_strtoull_r+0x110>
 8025fb8:	f1be 3fff 	cmp.w	lr, #4294967295
 8025fbc:	d015      	beq.n	8025fea <_strtoull_r+0xe2>
 8025fbe:	4299      	cmp	r1, r3
 8025fc0:	bf08      	it	eq
 8025fc2:	4290      	cmpeq	r0, r2
 8025fc4:	d348      	bcc.n	8026058 <_strtoull_r+0x150>
 8025fc6:	428b      	cmp	r3, r1
 8025fc8:	bf08      	it	eq
 8025fca:	4282      	cmpeq	r2, r0
 8025fcc:	d041      	beq.n	8026052 <_strtoull_r+0x14a>
 8025fce:	9e01      	ldr	r6, [sp, #4]
 8025fd0:	fb02 fe06 	mul.w	lr, r2, r6
 8025fd4:	9e00      	ldr	r6, [sp, #0]
 8025fd6:	fb06 ee03 	mla	lr, r6, r3, lr
 8025fda:	fba2 2306 	umull	r2, r3, r2, r6
 8025fde:	4473      	add	r3, lr
 8025fe0:	1912      	adds	r2, r2, r4
 8025fe2:	eb43 73e4 	adc.w	r3, r3, r4, asr #31
 8025fe6:	f04f 0e01 	mov.w	lr, #1
 8025fea:	f815 4b01 	ldrb.w	r4, [r5], #1
 8025fee:	eb08 0c04 	add.w	ip, r8, r4
 8025ff2:	f89c c001 	ldrb.w	ip, [ip, #1]
 8025ff6:	f01c 0f04 	tst.w	ip, #4
 8025ffa:	d1da      	bne.n	8025fb2 <_strtoull_r+0xaa>
 8025ffc:	f01c 0c03 	ands.w	ip, ip, #3
 8026000:	d00a      	beq.n	8026018 <_strtoull_r+0x110>
 8026002:	f1bc 0f01 	cmp.w	ip, #1
 8026006:	bf0c      	ite	eq
 8026008:	f04f 0c37 	moveq.w	ip, #55	; 0x37
 802600c:	f04f 0c57 	movne.w	ip, #87	; 0x57
 8026010:	ebcc 0404 	rsb	r4, ip, r4
 8026014:	45a1      	cmp	r9, r4
 8026016:	dccf      	bgt.n	8025fb8 <_strtoull_r+0xb0>
 8026018:	f1be 0f00 	cmp.w	lr, #0
 802601c:	db21      	blt.n	8026062 <_strtoull_r+0x15a>
 802601e:	9903      	ldr	r1, [sp, #12]
 8026020:	460e      	mov	r6, r1
 8026022:	4276      	negs	r6, r6
 8026024:	ea4f 77e1 	mov.w	r7, r1, asr #31
 8026028:	4608      	mov	r0, r1
 802602a:	ea82 0206 	eor.w	r2, r2, r6
 802602e:	4639      	mov	r1, r7
 8026030:	eb67 0747 	sbc.w	r7, r7, r7, lsl #1
 8026034:	407b      	eors	r3, r7
 8026036:	1880      	adds	r0, r0, r2
 8026038:	4159      	adcs	r1, r3
 802603a:	f1ba 0f00 	cmp.w	sl, #0
 802603e:	d005      	beq.n	802604c <_strtoull_r+0x144>
 8026040:	f1be 0f00 	cmp.w	lr, #0
 8026044:	d00b      	beq.n	802605e <_strtoull_r+0x156>
 8026046:	3d01      	subs	r5, #1
 8026048:	f8ca 5000 	str.w	r5, [sl]
 802604c:	b007      	add	sp, #28
 802604e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8026052:	9e02      	ldr	r6, [sp, #8]
 8026054:	42b4      	cmp	r4, r6
 8026056:	ddba      	ble.n	8025fce <_strtoull_r+0xc6>
 8026058:	f04f 3eff 	mov.w	lr, #4294967295
 802605c:	e7c5      	b.n	8025fea <_strtoull_r+0xe2>
 802605e:	465d      	mov	r5, fp
 8026060:	e7f2      	b.n	8026048 <_strtoull_r+0x140>
 8026062:	9a04      	ldr	r2, [sp, #16]
 8026064:	2322      	movs	r3, #34	; 0x22
 8026066:	6013      	str	r3, [r2, #0]
 8026068:	f04f 30ff 	mov.w	r0, #4294967295
 802606c:	f04f 31ff 	mov.w	r1, #4294967295
 8026070:	e7e3      	b.n	802603a <_strtoull_r+0x132>
 8026072:	2301      	movs	r3, #1
 8026074:	1c95      	adds	r5, r2, #2
 8026076:	7854      	ldrb	r4, [r2, #1]
 8026078:	9303      	str	r3, [sp, #12]
 802607a:	e767      	b.n	8025f4c <_strtoull_r+0x44>
 802607c:	782b      	ldrb	r3, [r5, #0]
 802607e:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8026082:	2b58      	cmp	r3, #88	; 0x58
 8026084:	d01a      	beq.n	80260bc <_strtoull_r+0x1b4>
 8026086:	2307      	movs	r3, #7
 8026088:	9302      	str	r3, [sp, #8]
 802608a:	f04f 30ff 	mov.w	r0, #4294967295
 802608e:	f06f 4160 	mvn.w	r1, #3758096384	; 0xe0000000
 8026092:	2608      	movs	r6, #8
 8026094:	2700      	movs	r7, #0
 8026096:	f04f 0908 	mov.w	r9, #8
 802609a:	e783      	b.n	8025fa4 <_strtoull_r+0x9c>
 802609c:	2c30      	cmp	r4, #48	; 0x30
 802609e:	d008      	beq.n	80260b2 <_strtoull_r+0x1aa>
 80260a0:	230f      	movs	r3, #15
 80260a2:	9302      	str	r3, [sp, #8]
 80260a4:	f04f 30ff 	mov.w	r0, #4294967295
 80260a8:	f06f 4170 	mvn.w	r1, #4026531840	; 0xf0000000
 80260ac:	2610      	movs	r6, #16
 80260ae:	2700      	movs	r7, #0
 80260b0:	e778      	b.n	8025fa4 <_strtoull_r+0x9c>
 80260b2:	782b      	ldrb	r3, [r5, #0]
 80260b4:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 80260b8:	2b58      	cmp	r3, #88	; 0x58
 80260ba:	d1f1      	bne.n	80260a0 <_strtoull_r+0x198>
 80260bc:	230f      	movs	r3, #15
 80260be:	9302      	str	r3, [sp, #8]
 80260c0:	f06f 4370 	mvn.w	r3, #4026531840	; 0xf0000000
 80260c4:	786c      	ldrb	r4, [r5, #1]
 80260c6:	9300      	str	r3, [sp, #0]
 80260c8:	3502      	adds	r5, #2
 80260ca:	f04f 3cff 	mov.w	ip, #4294967295
 80260ce:	2610      	movs	r6, #16
 80260d0:	2700      	movs	r7, #0
 80260d2:	f04f 0910 	mov.w	r9, #16
 80260d6:	e757      	b.n	8025f88 <_strtoull_r+0x80>
 80260d8:	20010114 	.word	0x20010114
 80260dc:	19999999 	.word	0x19999999

080260e0 <ceil>:
 80260e0:	ec51 0b10 	vmov	r0, r1, d0
 80260e4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80260e8:	f3c1 570a 	ubfx	r7, r1, #20, #11
 80260ec:	f2a7 35ff 	subw	r5, r7, #1023	; 0x3ff
 80260f0:	2d13      	cmp	r5, #19
 80260f2:	460c      	mov	r4, r1
 80260f4:	ee10 3a10 	vmov	r3, s0
 80260f8:	4688      	mov	r8, r1
 80260fa:	4606      	mov	r6, r0
 80260fc:	dc20      	bgt.n	8026140 <ceil+0x60>
 80260fe:	2d00      	cmp	r5, #0
 8026100:	db51      	blt.n	80261a6 <ceil+0xc6>
 8026102:	4f3b      	ldr	r7, [pc, #236]	; (80261f0 <ceil+0x110>)
 8026104:	412f      	asrs	r7, r5
 8026106:	ea07 0201 	and.w	r2, r7, r1
 802610a:	4313      	orrs	r3, r2
 802610c:	d01d      	beq.n	802614a <ceil+0x6a>
 802610e:	a336      	add	r3, pc, #216	; (adr r3, 80261e8 <ceil+0x108>)
 8026110:	e9d3 2300 	ldrd	r2, r3, [r3]
 8026114:	f7da fafa 	bl	800070c <__adddf3>
 8026118:	2200      	movs	r2, #0
 802611a:	2300      	movs	r3, #0
 802611c:	f7da ff38 	bl	8000f90 <__aeabi_dcmpgt>
 8026120:	b140      	cbz	r0, 8026134 <ceil+0x54>
 8026122:	2c00      	cmp	r4, #0
 8026124:	dd03      	ble.n	802612e <ceil+0x4e>
 8026126:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 802612a:	412b      	asrs	r3, r5
 802612c:	4498      	add	r8, r3
 802612e:	ea28 0407 	bic.w	r4, r8, r7
 8026132:	2600      	movs	r6, #0
 8026134:	4623      	mov	r3, r4
 8026136:	4632      	mov	r2, r6
 8026138:	ec43 2b10 	vmov	d0, r2, r3
 802613c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8026140:	2d33      	cmp	r5, #51	; 0x33
 8026142:	dd06      	ble.n	8026152 <ceil+0x72>
 8026144:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
 8026148:	d03f      	beq.n	80261ca <ceil+0xea>
 802614a:	ec41 0b10 	vmov	d0, r0, r1
 802614e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8026152:	f2a7 4313 	subw	r3, r7, #1043	; 0x413
 8026156:	f04f 39ff 	mov.w	r9, #4294967295
 802615a:	fa29 f903 	lsr.w	r9, r9, r3
 802615e:	ea19 0f00 	tst.w	r9, r0
 8026162:	d0f2      	beq.n	802614a <ceil+0x6a>
 8026164:	a320      	add	r3, pc, #128	; (adr r3, 80261e8 <ceil+0x108>)
 8026166:	e9d3 2300 	ldrd	r2, r3, [r3]
 802616a:	f7da facf 	bl	800070c <__adddf3>
 802616e:	2200      	movs	r2, #0
 8026170:	2300      	movs	r3, #0
 8026172:	f7da ff0d 	bl	8000f90 <__aeabi_dcmpgt>
 8026176:	2800      	cmp	r0, #0
 8026178:	d0dc      	beq.n	8026134 <ceil+0x54>
 802617a:	2c00      	cmp	r4, #0
 802617c:	dd0a      	ble.n	8026194 <ceil+0xb4>
 802617e:	2d14      	cmp	r5, #20
 8026180:	d006      	beq.n	8026190 <ceil+0xb0>
 8026182:	f5c7 6786 	rsb	r7, r7, #1072	; 0x430
 8026186:	3703      	adds	r7, #3
 8026188:	2401      	movs	r4, #1
 802618a:	40bc      	lsls	r4, r7
 802618c:	19a6      	adds	r6, r4, r6
 802618e:	d301      	bcc.n	8026194 <ceil+0xb4>
 8026190:	f108 0801 	add.w	r8, r8, #1
 8026194:	4644      	mov	r4, r8
 8026196:	ea26 0609 	bic.w	r6, r6, r9
 802619a:	4623      	mov	r3, r4
 802619c:	4632      	mov	r2, r6
 802619e:	ec43 2b10 	vmov	d0, r2, r3
 80261a2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80261a6:	a310      	add	r3, pc, #64	; (adr r3, 80261e8 <ceil+0x108>)
 80261a8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80261ac:	f7da faae 	bl	800070c <__adddf3>
 80261b0:	2200      	movs	r2, #0
 80261b2:	2300      	movs	r3, #0
 80261b4:	f7da feec 	bl	8000f90 <__aeabi_dcmpgt>
 80261b8:	2800      	cmp	r0, #0
 80261ba:	d0bb      	beq.n	8026134 <ceil+0x54>
 80261bc:	2c00      	cmp	r4, #0
 80261be:	db0f      	blt.n	80261e0 <ceil+0x100>
 80261c0:	4326      	orrs	r6, r4
 80261c2:	d00b      	beq.n	80261dc <ceil+0xfc>
 80261c4:	4c0b      	ldr	r4, [pc, #44]	; (80261f4 <ceil+0x114>)
 80261c6:	2600      	movs	r6, #0
 80261c8:	e7b4      	b.n	8026134 <ceil+0x54>
 80261ca:	ee10 2a10 	vmov	r2, s0
 80261ce:	460b      	mov	r3, r1
 80261d0:	f7da fa9c 	bl	800070c <__adddf3>
 80261d4:	ec41 0b10 	vmov	d0, r0, r1
 80261d8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80261dc:	4634      	mov	r4, r6
 80261de:	e7a9      	b.n	8026134 <ceil+0x54>
 80261e0:	2600      	movs	r6, #0
 80261e2:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
 80261e6:	e7a5      	b.n	8026134 <ceil+0x54>
 80261e8:	8800759c 	.word	0x8800759c
 80261ec:	7e37e43c 	.word	0x7e37e43c
 80261f0:	000fffff 	.word	0x000fffff
 80261f4:	3ff00000 	.word	0x3ff00000

080261f8 <cosf>:
 80261f8:	b500      	push	{lr}
 80261fa:	ee10 3a10 	vmov	r3, s0
 80261fe:	4a1a      	ldr	r2, [pc, #104]	; (8026268 <cosf+0x70>)
 8026200:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8026204:	4293      	cmp	r3, r2
 8026206:	b083      	sub	sp, #12
 8026208:	dd19      	ble.n	802623e <cosf+0x46>
 802620a:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802620e:	db04      	blt.n	802621a <cosf+0x22>
 8026210:	ee30 0a40 	vsub.f32	s0, s0, s0
 8026214:	b003      	add	sp, #12
 8026216:	f85d fb04 	ldr.w	pc, [sp], #4
 802621a:	4668      	mov	r0, sp
 802621c:	f000 f866 	bl	80262ec <__ieee754_rem_pio2f>
 8026220:	f000 0003 	and.w	r0, r0, #3
 8026224:	2801      	cmp	r0, #1
 8026226:	ed9d 0a00 	vldr	s0, [sp]
 802622a:	eddd 0a01 	vldr	s1, [sp, #4]
 802622e:	d012      	beq.n	8026256 <cosf+0x5e>
 8026230:	2802      	cmp	r0, #2
 8026232:	d00b      	beq.n	802624c <cosf+0x54>
 8026234:	b1a0      	cbz	r0, 8026260 <cosf+0x68>
 8026236:	2001      	movs	r0, #1
 8026238:	f000 fd14 	bl	8026c64 <__kernel_sinf>
 802623c:	e7ea      	b.n	8026214 <cosf+0x1c>
 802623e:	eddf 0a0b 	vldr	s1, [pc, #44]	; 802626c <cosf+0x74>
 8026242:	f000 f99b 	bl	802657c <__kernel_cosf>
 8026246:	b003      	add	sp, #12
 8026248:	f85d fb04 	ldr.w	pc, [sp], #4
 802624c:	f000 f996 	bl	802657c <__kernel_cosf>
 8026250:	eeb1 0a40 	vneg.f32	s0, s0
 8026254:	e7de      	b.n	8026214 <cosf+0x1c>
 8026256:	f000 fd05 	bl	8026c64 <__kernel_sinf>
 802625a:	eeb1 0a40 	vneg.f32	s0, s0
 802625e:	e7d9      	b.n	8026214 <cosf+0x1c>
 8026260:	f000 f98c 	bl	802657c <__kernel_cosf>
 8026264:	e7d6      	b.n	8026214 <cosf+0x1c>
 8026266:	bf00      	nop
 8026268:	3f490fd8 	.word	0x3f490fd8
 802626c:	00000000 	.word	0x00000000

08026270 <sinf>:
 8026270:	b500      	push	{lr}
 8026272:	ee10 3a10 	vmov	r3, s0
 8026276:	4a1b      	ldr	r2, [pc, #108]	; (80262e4 <sinf+0x74>)
 8026278:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802627c:	4293      	cmp	r3, r2
 802627e:	b083      	sub	sp, #12
 8026280:	dd1a      	ble.n	80262b8 <sinf+0x48>
 8026282:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8026286:	db04      	blt.n	8026292 <sinf+0x22>
 8026288:	ee30 0a40 	vsub.f32	s0, s0, s0
 802628c:	b003      	add	sp, #12
 802628e:	f85d fb04 	ldr.w	pc, [sp], #4
 8026292:	4668      	mov	r0, sp
 8026294:	f000 f82a 	bl	80262ec <__ieee754_rem_pio2f>
 8026298:	f000 0003 	and.w	r0, r0, #3
 802629c:	2801      	cmp	r0, #1
 802629e:	ed9d 0a00 	vldr	s0, [sp]
 80262a2:	eddd 0a01 	vldr	s1, [sp, #4]
 80262a6:	d015      	beq.n	80262d4 <sinf+0x64>
 80262a8:	2802      	cmp	r0, #2
 80262aa:	d00d      	beq.n	80262c8 <sinf+0x58>
 80262ac:	b1a8      	cbz	r0, 80262da <sinf+0x6a>
 80262ae:	f000 f965 	bl	802657c <__kernel_cosf>
 80262b2:	eeb1 0a40 	vneg.f32	s0, s0
 80262b6:	e7e9      	b.n	802628c <sinf+0x1c>
 80262b8:	eddf 0a0b 	vldr	s1, [pc, #44]	; 80262e8 <sinf+0x78>
 80262bc:	2000      	movs	r0, #0
 80262be:	f000 fcd1 	bl	8026c64 <__kernel_sinf>
 80262c2:	b003      	add	sp, #12
 80262c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80262c8:	2001      	movs	r0, #1
 80262ca:	f000 fccb 	bl	8026c64 <__kernel_sinf>
 80262ce:	eeb1 0a40 	vneg.f32	s0, s0
 80262d2:	e7db      	b.n	802628c <sinf+0x1c>
 80262d4:	f000 f952 	bl	802657c <__kernel_cosf>
 80262d8:	e7d8      	b.n	802628c <sinf+0x1c>
 80262da:	2001      	movs	r0, #1
 80262dc:	f000 fcc2 	bl	8026c64 <__kernel_sinf>
 80262e0:	e7d4      	b.n	802628c <sinf+0x1c>
 80262e2:	bf00      	nop
 80262e4:	3f490fd8 	.word	0x3f490fd8
 80262e8:	00000000 	.word	0x00000000

080262ec <__ieee754_rem_pio2f>:
 80262ec:	b570      	push	{r4, r5, r6, lr}
 80262ee:	ee10 3a10 	vmov	r3, s0
 80262f2:	4a94      	ldr	r2, [pc, #592]	; (8026544 <__ieee754_rem_pio2f+0x258>)
 80262f4:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
 80262f8:	4294      	cmp	r4, r2
 80262fa:	b086      	sub	sp, #24
 80262fc:	ee10 6a10 	vmov	r6, s0
 8026300:	4605      	mov	r5, r0
 8026302:	dd66      	ble.n	80263d2 <__ieee754_rem_pio2f+0xe6>
 8026304:	4a90      	ldr	r2, [pc, #576]	; (8026548 <__ieee754_rem_pio2f+0x25c>)
 8026306:	4294      	cmp	r4, r2
 8026308:	dc1a      	bgt.n	8026340 <__ieee754_rem_pio2f+0x54>
 802630a:	2b00      	cmp	r3, #0
 802630c:	eddf 7a8f 	vldr	s15, [pc, #572]	; 802654c <__ieee754_rem_pio2f+0x260>
 8026310:	4a8f      	ldr	r2, [pc, #572]	; (8026550 <__ieee754_rem_pio2f+0x264>)
 8026312:	f024 040f 	bic.w	r4, r4, #15
 8026316:	f340 80dd 	ble.w	80264d4 <__ieee754_rem_pio2f+0x1e8>
 802631a:	4294      	cmp	r4, r2
 802631c:	ee70 7a67 	vsub.f32	s15, s0, s15
 8026320:	d066      	beq.n	80263f0 <__ieee754_rem_pio2f+0x104>
 8026322:	ed9f 7a8c 	vldr	s14, [pc, #560]	; 8026554 <__ieee754_rem_pio2f+0x268>
 8026326:	ee77 6ac7 	vsub.f32	s13, s15, s14
 802632a:	2001      	movs	r0, #1
 802632c:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8026330:	edc5 6a00 	vstr	s13, [r5]
 8026334:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8026338:	edc5 7a01 	vstr	s15, [r5, #4]
 802633c:	b006      	add	sp, #24
 802633e:	bd70      	pop	{r4, r5, r6, pc}
 8026340:	4a85      	ldr	r2, [pc, #532]	; (8026558 <__ieee754_rem_pio2f+0x26c>)
 8026342:	4294      	cmp	r4, r2
 8026344:	dd66      	ble.n	8026414 <__ieee754_rem_pio2f+0x128>
 8026346:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 802634a:	da49      	bge.n	80263e0 <__ieee754_rem_pio2f+0xf4>
 802634c:	15e2      	asrs	r2, r4, #23
 802634e:	3a86      	subs	r2, #134	; 0x86
 8026350:	eba4 53c2 	sub.w	r3, r4, r2, lsl #23
 8026354:	ee07 3a10 	vmov	s14, r3
 8026358:	eefd 6ac7 	vcvt.s32.f32	s13, s14
 802635c:	eddf 7a7f 	vldr	s15, [pc, #508]	; 802655c <__ieee754_rem_pio2f+0x270>
 8026360:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 8026364:	ee37 7a66 	vsub.f32	s14, s14, s13
 8026368:	edcd 6a03 	vstr	s13, [sp, #12]
 802636c:	ee27 7a27 	vmul.f32	s14, s14, s15
 8026370:	eefd 6ac7 	vcvt.s32.f32	s13, s14
 8026374:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 8026378:	ee37 7a66 	vsub.f32	s14, s14, s13
 802637c:	edcd 6a04 	vstr	s13, [sp, #16]
 8026380:	ee67 7a27 	vmul.f32	s15, s14, s15
 8026384:	eef5 7a40 	vcmp.f32	s15, #0.0
 8026388:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802638c:	edcd 7a05 	vstr	s15, [sp, #20]
 8026390:	f040 80b3 	bne.w	80264fa <__ieee754_rem_pio2f+0x20e>
 8026394:	eef5 6a40 	vcmp.f32	s13, #0.0
 8026398:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802639c:	bf14      	ite	ne
 802639e:	2302      	movne	r3, #2
 80263a0:	2301      	moveq	r3, #1
 80263a2:	496f      	ldr	r1, [pc, #444]	; (8026560 <__ieee754_rem_pio2f+0x274>)
 80263a4:	2002      	movs	r0, #2
 80263a6:	e88d 0003 	stmia.w	sp, {r0, r1}
 80263aa:	a803      	add	r0, sp, #12
 80263ac:	4629      	mov	r1, r5
 80263ae:	f000 f967 	bl	8026680 <__kernel_rem_pio2f>
 80263b2:	2e00      	cmp	r6, #0
 80263b4:	da12      	bge.n	80263dc <__ieee754_rem_pio2f+0xf0>
 80263b6:	ed95 7a00 	vldr	s14, [r5]
 80263ba:	edd5 7a01 	vldr	s15, [r5, #4]
 80263be:	eeb1 7a47 	vneg.f32	s14, s14
 80263c2:	eef1 7a67 	vneg.f32	s15, s15
 80263c6:	4240      	negs	r0, r0
 80263c8:	ed85 7a00 	vstr	s14, [r5]
 80263cc:	edc5 7a01 	vstr	s15, [r5, #4]
 80263d0:	e004      	b.n	80263dc <__ieee754_rem_pio2f+0xf0>
 80263d2:	2200      	movs	r2, #0
 80263d4:	ed85 0a00 	vstr	s0, [r5]
 80263d8:	6042      	str	r2, [r0, #4]
 80263da:	2000      	movs	r0, #0
 80263dc:	b006      	add	sp, #24
 80263de:	bd70      	pop	{r4, r5, r6, pc}
 80263e0:	ee70 7a40 	vsub.f32	s15, s0, s0
 80263e4:	2000      	movs	r0, #0
 80263e6:	edc5 7a01 	vstr	s15, [r5, #4]
 80263ea:	edc5 7a00 	vstr	s15, [r5]
 80263ee:	e7f5      	b.n	80263dc <__ieee754_rem_pio2f+0xf0>
 80263f0:	eddf 6a5c 	vldr	s13, [pc, #368]	; 8026564 <__ieee754_rem_pio2f+0x278>
 80263f4:	ed9f 7a5c 	vldr	s14, [pc, #368]	; 8026568 <__ieee754_rem_pio2f+0x27c>
 80263f8:	ee77 7ae6 	vsub.f32	s15, s15, s13
 80263fc:	2001      	movs	r0, #1
 80263fe:	ee77 6ac7 	vsub.f32	s13, s15, s14
 8026402:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8026406:	edc5 6a00 	vstr	s13, [r5]
 802640a:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802640e:	edc5 7a01 	vstr	s15, [r5, #4]
 8026412:	e7e3      	b.n	80263dc <__ieee754_rem_pio2f+0xf0>
 8026414:	f000 fc6e 	bl	8026cf4 <fabsf>
 8026418:	eddf 6a54 	vldr	s13, [pc, #336]	; 802656c <__ieee754_rem_pio2f+0x280>
 802641c:	eddf 5a4b 	vldr	s11, [pc, #300]	; 802654c <__ieee754_rem_pio2f+0x260>
 8026420:	ed9f 7a4c 	vldr	s14, [pc, #304]	; 8026554 <__ieee754_rem_pio2f+0x268>
 8026424:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 8026428:	eee0 7a26 	vfma.f32	s15, s0, s13
 802642c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8026430:	ee17 0a90 	vmov	r0, s15
 8026434:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 8026438:	281f      	cmp	r0, #31
 802643a:	eeb1 6a66 	vneg.f32	s12, s13
 802643e:	eea6 0a25 	vfma.f32	s0, s12, s11
 8026442:	ee66 7a87 	vmul.f32	s15, s13, s14
 8026446:	dc1d      	bgt.n	8026484 <__ieee754_rem_pio2f+0x198>
 8026448:	4a49      	ldr	r2, [pc, #292]	; (8026570 <__ieee754_rem_pio2f+0x284>)
 802644a:	1e41      	subs	r1, r0, #1
 802644c:	f024 03ff 	bic.w	r3, r4, #255	; 0xff
 8026450:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 8026454:	4293      	cmp	r3, r2
 8026456:	d015      	beq.n	8026484 <__ieee754_rem_pio2f+0x198>
 8026458:	ee30 7a67 	vsub.f32	s14, s0, s15
 802645c:	ed85 7a00 	vstr	s14, [r5]
 8026460:	ee30 0a47 	vsub.f32	s0, s0, s14
 8026464:	2e00      	cmp	r6, #0
 8026466:	ee30 0a67 	vsub.f32	s0, s0, s15
 802646a:	ed85 0a01 	vstr	s0, [r5, #4]
 802646e:	dab5      	bge.n	80263dc <__ieee754_rem_pio2f+0xf0>
 8026470:	eeb1 7a47 	vneg.f32	s14, s14
 8026474:	eeb1 0a40 	vneg.f32	s0, s0
 8026478:	ed85 7a00 	vstr	s14, [r5]
 802647c:	ed85 0a01 	vstr	s0, [r5, #4]
 8026480:	4240      	negs	r0, r0
 8026482:	e7ab      	b.n	80263dc <__ieee754_rem_pio2f+0xf0>
 8026484:	ee30 7a67 	vsub.f32	s14, s0, s15
 8026488:	15e4      	asrs	r4, r4, #23
 802648a:	ee17 3a10 	vmov	r3, s14
 802648e:	f3c3 53c7 	ubfx	r3, r3, #23, #8
 8026492:	1ae3      	subs	r3, r4, r3
 8026494:	2b08      	cmp	r3, #8
 8026496:	dde1      	ble.n	802645c <__ieee754_rem_pio2f+0x170>
 8026498:	eddf 7a32 	vldr	s15, [pc, #200]	; 8026564 <__ieee754_rem_pio2f+0x278>
 802649c:	ed9f 7a32 	vldr	s14, [pc, #200]	; 8026568 <__ieee754_rem_pio2f+0x27c>
 80264a0:	eef0 5a40 	vmov.f32	s11, s0
 80264a4:	eee6 5a27 	vfma.f32	s11, s12, s15
 80264a8:	ee30 0a65 	vsub.f32	s0, s0, s11
 80264ac:	eea6 0a27 	vfma.f32	s0, s12, s15
 80264b0:	eef0 7a40 	vmov.f32	s15, s0
 80264b4:	eed6 7a87 	vfnms.f32	s15, s13, s14
 80264b8:	ee35 7ae7 	vsub.f32	s14, s11, s15
 80264bc:	ee17 3a10 	vmov	r3, s14
 80264c0:	f3c3 53c7 	ubfx	r3, r3, #23, #8
 80264c4:	1ae4      	subs	r4, r4, r3
 80264c6:	2c19      	cmp	r4, #25
 80264c8:	dc2c      	bgt.n	8026524 <__ieee754_rem_pio2f+0x238>
 80264ca:	ed85 7a00 	vstr	s14, [r5]
 80264ce:	eeb0 0a65 	vmov.f32	s0, s11
 80264d2:	e7c5      	b.n	8026460 <__ieee754_rem_pio2f+0x174>
 80264d4:	4294      	cmp	r4, r2
 80264d6:	ee70 7a27 	vadd.f32	s15, s0, s15
 80264da:	d010      	beq.n	80264fe <__ieee754_rem_pio2f+0x212>
 80264dc:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 8026554 <__ieee754_rem_pio2f+0x268>
 80264e0:	ee77 6a87 	vadd.f32	s13, s15, s14
 80264e4:	f04f 30ff 	mov.w	r0, #4294967295
 80264e8:	ee77 7ae6 	vsub.f32	s15, s15, s13
 80264ec:	edc5 6a00 	vstr	s13, [r5]
 80264f0:	ee77 7a87 	vadd.f32	s15, s15, s14
 80264f4:	edc5 7a01 	vstr	s15, [r5, #4]
 80264f8:	e770      	b.n	80263dc <__ieee754_rem_pio2f+0xf0>
 80264fa:	2303      	movs	r3, #3
 80264fc:	e751      	b.n	80263a2 <__ieee754_rem_pio2f+0xb6>
 80264fe:	eddf 6a19 	vldr	s13, [pc, #100]	; 8026564 <__ieee754_rem_pio2f+0x278>
 8026502:	ed9f 7a19 	vldr	s14, [pc, #100]	; 8026568 <__ieee754_rem_pio2f+0x27c>
 8026506:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802650a:	f04f 30ff 	mov.w	r0, #4294967295
 802650e:	ee77 6a87 	vadd.f32	s13, s15, s14
 8026512:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8026516:	edc5 6a00 	vstr	s13, [r5]
 802651a:	ee77 7a87 	vadd.f32	s15, s15, s14
 802651e:	edc5 7a01 	vstr	s15, [r5, #4]
 8026522:	e75b      	b.n	80263dc <__ieee754_rem_pio2f+0xf0>
 8026524:	ed9f 7a13 	vldr	s14, [pc, #76]	; 8026574 <__ieee754_rem_pio2f+0x288>
 8026528:	ed9f 5a13 	vldr	s10, [pc, #76]	; 8026578 <__ieee754_rem_pio2f+0x28c>
 802652c:	eeb0 0a65 	vmov.f32	s0, s11
 8026530:	eea6 0a07 	vfma.f32	s0, s12, s14
 8026534:	ee75 7ac0 	vsub.f32	s15, s11, s0
 8026538:	eee6 7a07 	vfma.f32	s15, s12, s14
 802653c:	eed6 7a85 	vfnms.f32	s15, s13, s10
 8026540:	e78a      	b.n	8026458 <__ieee754_rem_pio2f+0x16c>
 8026542:	bf00      	nop
 8026544:	3f490fd8 	.word	0x3f490fd8
 8026548:	4016cbe3 	.word	0x4016cbe3
 802654c:	3fc90f80 	.word	0x3fc90f80
 8026550:	3fc90fd0 	.word	0x3fc90fd0
 8026554:	37354443 	.word	0x37354443
 8026558:	43490f80 	.word	0x43490f80
 802655c:	43800000 	.word	0x43800000
 8026560:	0802a034 	.word	0x0802a034
 8026564:	37354400 	.word	0x37354400
 8026568:	2e85a308 	.word	0x2e85a308
 802656c:	3f22f984 	.word	0x3f22f984
 8026570:	08029fb4 	.word	0x08029fb4
 8026574:	2e85a300 	.word	0x2e85a300
 8026578:	248d3132 	.word	0x248d3132

0802657c <__kernel_cosf>:
 802657c:	ee10 3a10 	vmov	r3, s0
 8026580:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8026584:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 8026588:	da2c      	bge.n	80265e4 <__kernel_cosf+0x68>
 802658a:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 802658e:	ee17 3a90 	vmov	r3, s15
 8026592:	2b00      	cmp	r3, #0
 8026594:	d060      	beq.n	8026658 <__kernel_cosf+0xdc>
 8026596:	ee20 7a00 	vmul.f32	s14, s0, s0
 802659a:	eddf 4a31 	vldr	s9, [pc, #196]	; 8026660 <__kernel_cosf+0xe4>
 802659e:	ed9f 5a31 	vldr	s10, [pc, #196]	; 8026664 <__kernel_cosf+0xe8>
 80265a2:	eddf 5a31 	vldr	s11, [pc, #196]	; 8026668 <__kernel_cosf+0xec>
 80265a6:	ed9f 6a31 	vldr	s12, [pc, #196]	; 802666c <__kernel_cosf+0xf0>
 80265aa:	eddf 7a31 	vldr	s15, [pc, #196]	; 8026670 <__kernel_cosf+0xf4>
 80265ae:	eddf 6a31 	vldr	s13, [pc, #196]	; 8026674 <__kernel_cosf+0xf8>
 80265b2:	eea7 5a24 	vfma.f32	s10, s14, s9
 80265b6:	eee5 5a07 	vfma.f32	s11, s10, s14
 80265ba:	eea5 6a87 	vfma.f32	s12, s11, s14
 80265be:	eee6 7a07 	vfma.f32	s15, s12, s14
 80265c2:	eee7 6a87 	vfma.f32	s13, s15, s14
 80265c6:	ee66 6a87 	vmul.f32	s13, s13, s14
 80265ca:	ee60 0ac0 	vnmul.f32	s1, s1, s0
 80265ce:	eeb6 6a00 	vmov.f32	s12, #96	; 0x60
 80265d2:	eee7 0a26 	vfma.f32	s1, s14, s13
 80265d6:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 80265da:	eed7 0a06 	vfnms.f32	s1, s14, s12
 80265de:	ee37 0ae0 	vsub.f32	s0, s15, s1
 80265e2:	4770      	bx	lr
 80265e4:	ee20 7a00 	vmul.f32	s14, s0, s0
 80265e8:	eddf 4a1d 	vldr	s9, [pc, #116]	; 8026660 <__kernel_cosf+0xe4>
 80265ec:	ed9f 5a1d 	vldr	s10, [pc, #116]	; 8026664 <__kernel_cosf+0xe8>
 80265f0:	eddf 5a1d 	vldr	s11, [pc, #116]	; 8026668 <__kernel_cosf+0xec>
 80265f4:	ed9f 6a1d 	vldr	s12, [pc, #116]	; 802666c <__kernel_cosf+0xf0>
 80265f8:	eddf 7a1d 	vldr	s15, [pc, #116]	; 8026670 <__kernel_cosf+0xf4>
 80265fc:	eddf 6a1d 	vldr	s13, [pc, #116]	; 8026674 <__kernel_cosf+0xf8>
 8026600:	4a1d      	ldr	r2, [pc, #116]	; (8026678 <__kernel_cosf+0xfc>)
 8026602:	eea7 5a24 	vfma.f32	s10, s14, s9
 8026606:	4293      	cmp	r3, r2
 8026608:	eee5 5a07 	vfma.f32	s11, s10, s14
 802660c:	eea5 6a87 	vfma.f32	s12, s11, s14
 8026610:	eee6 7a07 	vfma.f32	s15, s12, s14
 8026614:	eee7 6a87 	vfma.f32	s13, s15, s14
 8026618:	ee66 6a87 	vmul.f32	s13, s13, s14
 802661c:	ddd5      	ble.n	80265ca <__kernel_cosf+0x4e>
 802661e:	4a17      	ldr	r2, [pc, #92]	; (802667c <__kernel_cosf+0x100>)
 8026620:	4293      	cmp	r3, r2
 8026622:	dc14      	bgt.n	802664e <__kernel_cosf+0xd2>
 8026624:	f103 437f 	add.w	r3, r3, #4278190080	; 0xff000000
 8026628:	ee07 3a90 	vmov	s15, r3
 802662c:	eeb7 6a00 	vmov.f32	s12, #112	; 0x70
 8026630:	ee36 6a67 	vsub.f32	s12, s12, s15
 8026634:	ee60 0ac0 	vnmul.f32	s1, s1, s0
 8026638:	eef6 5a00 	vmov.f32	s11, #96	; 0x60
 802663c:	eee7 0a26 	vfma.f32	s1, s14, s13
 8026640:	eed7 7a25 	vfnms.f32	s15, s14, s11
 8026644:	ee77 7ae0 	vsub.f32	s15, s15, s1
 8026648:	ee36 0a67 	vsub.f32	s0, s12, s15
 802664c:	4770      	bx	lr
 802664e:	eeb6 6a07 	vmov.f32	s12, #103	; 0x67
 8026652:	eef5 7a02 	vmov.f32	s15, #82	; 0x52
 8026656:	e7ed      	b.n	8026634 <__kernel_cosf+0xb8>
 8026658:	eeb7 0a00 	vmov.f32	s0, #112	; 0x70
 802665c:	4770      	bx	lr
 802665e:	bf00      	nop
 8026660:	ad47d74e 	.word	0xad47d74e
 8026664:	310f74f6 	.word	0x310f74f6
 8026668:	b493f27c 	.word	0xb493f27c
 802666c:	37d00d01 	.word	0x37d00d01
 8026670:	bab60b61 	.word	0xbab60b61
 8026674:	3d2aaaab 	.word	0x3d2aaaab
 8026678:	3e999999 	.word	0x3e999999
 802667c:	3f480000 	.word	0x3f480000

08026680 <__kernel_rem_pio2f>:
 8026680:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8026684:	ed2d 8b04 	vpush	{d8-d9}
 8026688:	b0d7      	sub	sp, #348	; 0x15c
 802668a:	1e5f      	subs	r7, r3, #1
 802668c:	4cd7      	ldr	r4, [pc, #860]	; (80269ec <__kernel_rem_pio2f+0x36c>)
 802668e:	9d64      	ldr	r5, [sp, #400]	; 0x190
 8026690:	9302      	str	r3, [sp, #8]
 8026692:	1ed3      	subs	r3, r2, #3
 8026694:	bf48      	it	mi
 8026696:	1d13      	addmi	r3, r2, #4
 8026698:	f854 6025 	ldr.w	r6, [r4, r5, lsl #2]
 802669c:	9101      	str	r1, [sp, #4]
 802669e:	10db      	asrs	r3, r3, #3
 80266a0:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80266a4:	ea6f 0b03 	mvn.w	fp, r3
 80266a8:	19b9      	adds	r1, r7, r6
 80266aa:	9303      	str	r3, [sp, #12]
 80266ac:	4682      	mov	sl, r0
 80266ae:	eb02 0bcb 	add.w	fp, r2, fp, lsl #3
 80266b2:	eba3 0307 	sub.w	r3, r3, r7
 80266b6:	d414      	bmi.n	80266e2 <__kernel_rem_pio2f+0x62>
 80266b8:	4419      	add	r1, r3
 80266ba:	9865      	ldr	r0, [sp, #404]	; 0x194
 80266bc:	3101      	adds	r1, #1
 80266be:	aa1a      	add	r2, sp, #104	; 0x68
 80266c0:	2b00      	cmp	r3, #0
 80266c2:	bfaa      	itet	ge
 80266c4:	f850 4023 	ldrge.w	r4, [r0, r3, lsl #2]
 80266c8:	eddf 7acc 	vldrlt	s15, [pc, #816]	; 80269fc <__kernel_rem_pio2f+0x37c>
 80266cc:	ee07 4a90 	vmovge	s15, r4
 80266d0:	f103 0301 	add.w	r3, r3, #1
 80266d4:	bfa8      	it	ge
 80266d6:	eef8 7ae7 	vcvtge.f32.s32	s15, s15
 80266da:	428b      	cmp	r3, r1
 80266dc:	ece2 7a01 	vstmia	r2!, {s15}
 80266e0:	d1ee      	bne.n	80266c0 <__kernel_rem_pio2f+0x40>
 80266e2:	2e00      	cmp	r6, #0
 80266e4:	db1a      	blt.n	802671c <__kernel_rem_pio2f+0x9c>
 80266e6:	9b02      	ldr	r3, [sp, #8]
 80266e8:	a91a      	add	r1, sp, #104	; 0x68
 80266ea:	1c74      	adds	r4, r6, #1
 80266ec:	eb01 0484 	add.w	r4, r1, r4, lsl #2
 80266f0:	a842      	add	r0, sp, #264	; 0x108
 80266f2:	009d      	lsls	r5, r3, #2
 80266f4:	2f00      	cmp	r7, #0
 80266f6:	f2c0 81ba 	blt.w	8026a6e <__kernel_rem_pio2f+0x3ee>
 80266fa:	eddf 7ac0 	vldr	s15, [pc, #768]	; 80269fc <__kernel_rem_pio2f+0x37c>
 80266fe:	4652      	mov	r2, sl
 8026700:	194b      	adds	r3, r1, r5
 8026702:	ed33 7a01 	vldmdb	r3!, {s14}
 8026706:	ecf2 6a01 	vldmia	r2!, {s13}
 802670a:	4299      	cmp	r1, r3
 802670c:	eee6 7a87 	vfma.f32	s15, s13, s14
 8026710:	d1f7      	bne.n	8026702 <__kernel_rem_pio2f+0x82>
 8026712:	3104      	adds	r1, #4
 8026714:	42a1      	cmp	r1, r4
 8026716:	ece0 7a01 	vstmia	r0!, {s15}
 802671a:	d1eb      	bne.n	80266f4 <__kernel_rem_pio2f+0x74>
 802671c:	9a02      	ldr	r2, [sp, #8]
 802671e:	eddf 8ab4 	vldr	s17, [pc, #720]	; 80269f0 <__kernel_rem_pio2f+0x370>
 8026722:	ed9f 8ab4 	vldr	s16, [pc, #720]	; 80269f4 <__kernel_rem_pio2f+0x374>
 8026726:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
 802672a:	3b01      	subs	r3, #1
 802672c:	009b      	lsls	r3, r3, #2
 802672e:	ebc2 7982 	rsb	r9, r2, r2, lsl #30
 8026732:	aa06      	add	r2, sp, #24
 8026734:	f103 0804 	add.w	r8, r3, #4
 8026738:	4413      	add	r3, r2
 802673a:	4490      	add	r8, r2
 802673c:	9304      	str	r3, [sp, #16]
 802673e:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8026742:	4634      	mov	r4, r6
 8026744:	00a5      	lsls	r5, r4, #2
 8026746:	ab56      	add	r3, sp, #344	; 0x158
 8026748:	442b      	add	r3, r5
 802674a:	2c00      	cmp	r4, #0
 802674c:	ed13 0a14 	vldr	s0, [r3, #-80]	; 0xffffffb0
 8026750:	dd18      	ble.n	8026784 <__kernel_rem_pio2f+0x104>
 8026752:	a942      	add	r1, sp, #264	; 0x108
 8026754:	194b      	adds	r3, r1, r5
 8026756:	aa05      	add	r2, sp, #20
 8026758:	ee60 7a28 	vmul.f32	s15, s0, s17
 802675c:	eeb0 7a40 	vmov.f32	s14, s0
 8026760:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8026764:	ed73 6a01 	vldmdb	r3!, {s13}
 8026768:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802676c:	428b      	cmp	r3, r1
 802676e:	eea7 7ac8 	vfms.f32	s14, s15, s16
 8026772:	ee37 0aa6 	vadd.f32	s0, s15, s13
 8026776:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 802677a:	ee17 0a10 	vmov	r0, s14
 802677e:	f842 0f04 	str.w	r0, [r2, #4]!
 8026782:	d1e9      	bne.n	8026758 <__kernel_rem_pio2f+0xd8>
 8026784:	4658      	mov	r0, fp
 8026786:	f000 fb05 	bl	8026d94 <scalbnf>
 802678a:	eeb0 9a40 	vmov.f32	s18, s0
 802678e:	eeb4 0a00 	vmov.f32	s0, #64	; 0x40
 8026792:	ee29 0a00 	vmul.f32	s0, s18, s0
 8026796:	f000 fab5 	bl	8026d04 <floorf>
 802679a:	eef2 7a00 	vmov.f32	s15, #32
 802679e:	eea0 9a67 	vfms.f32	s18, s0, s15
 80267a2:	f1bb 0f00 	cmp.w	fp, #0
 80267a6:	eefd 9ac9 	vcvt.s32.f32	s19, s18
 80267aa:	eef8 7ae9 	vcvt.f32.s32	s15, s19
 80267ae:	ee39 9a67 	vsub.f32	s18, s18, s15
 80267b2:	f340 8141 	ble.w	8026a38 <__kernel_rem_pio2f+0x3b8>
 80267b6:	1e60      	subs	r0, r4, #1
 80267b8:	aa06      	add	r2, sp, #24
 80267ba:	f1cb 0308 	rsb	r3, fp, #8
 80267be:	f852 1020 	ldr.w	r1, [r2, r0, lsl #2]
 80267c2:	fa41 f203 	asr.w	r2, r1, r3
 80267c6:	fa02 f303 	lsl.w	r3, r2, r3
 80267ca:	f10d 0e18 	add.w	lr, sp, #24
 80267ce:	1ac9      	subs	r1, r1, r3
 80267d0:	f84e 1020 	str.w	r1, [lr, r0, lsl #2]
 80267d4:	ee19 0a90 	vmov	r0, s19
 80267d8:	4410      	add	r0, r2
 80267da:	f1cb 0307 	rsb	r3, fp, #7
 80267de:	ee09 0a90 	vmov	s19, r0
 80267e2:	4119      	asrs	r1, r3
 80267e4:	2900      	cmp	r1, #0
 80267e6:	dd39      	ble.n	802685c <__kernel_rem_pio2f+0x1dc>
 80267e8:	ee19 3a90 	vmov	r3, s19
 80267ec:	2c00      	cmp	r4, #0
 80267ee:	f103 0301 	add.w	r3, r3, #1
 80267f2:	ee09 3a90 	vmov	s19, r3
 80267f6:	f340 81cb 	ble.w	8026b90 <__kernel_rem_pio2f+0x510>
 80267fa:	2200      	movs	r2, #0
 80267fc:	4610      	mov	r0, r2
 80267fe:	f10d 0e14 	add.w	lr, sp, #20
 8026802:	e008      	b.n	8026816 <__kernel_rem_pio2f+0x196>
 8026804:	f5c3 7c80 	rsb	ip, r3, #256	; 0x100
 8026808:	b113      	cbz	r3, 8026810 <__kernel_rem_pio2f+0x190>
 802680a:	f8ce c000 	str.w	ip, [lr]
 802680e:	2001      	movs	r0, #1
 8026810:	3201      	adds	r2, #1
 8026812:	4294      	cmp	r4, r2
 8026814:	dd0c      	ble.n	8026830 <__kernel_rem_pio2f+0x1b0>
 8026816:	f85e 3f04 	ldr.w	r3, [lr, #4]!
 802681a:	2800      	cmp	r0, #0
 802681c:	d0f2      	beq.n	8026804 <__kernel_rem_pio2f+0x184>
 802681e:	3201      	adds	r2, #1
 8026820:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8026824:	4294      	cmp	r4, r2
 8026826:	f8ce 3000 	str.w	r3, [lr]
 802682a:	f04f 0001 	mov.w	r0, #1
 802682e:	dcf2      	bgt.n	8026816 <__kernel_rem_pio2f+0x196>
 8026830:	f1bb 0f00 	cmp.w	fp, #0
 8026834:	dd10      	ble.n	8026858 <__kernel_rem_pio2f+0x1d8>
 8026836:	f1bb 0f01 	cmp.w	fp, #1
 802683a:	f000 8104 	beq.w	8026a46 <__kernel_rem_pio2f+0x3c6>
 802683e:	f1bb 0f02 	cmp.w	fp, #2
 8026842:	d109      	bne.n	8026858 <__kernel_rem_pio2f+0x1d8>
 8026844:	1e62      	subs	r2, r4, #1
 8026846:	ab06      	add	r3, sp, #24
 8026848:	f10d 0e18 	add.w	lr, sp, #24
 802684c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8026850:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8026854:	f84e 3022 	str.w	r3, [lr, r2, lsl #2]
 8026858:	2902      	cmp	r1, #2
 802685a:	d059      	beq.n	8026910 <__kernel_rem_pio2f+0x290>
 802685c:	eeb5 9a40 	vcmp.f32	s18, #0.0
 8026860:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026864:	d166      	bne.n	8026934 <__kernel_rem_pio2f+0x2b4>
 8026866:	1e63      	subs	r3, r4, #1
 8026868:	429e      	cmp	r6, r3
 802686a:	dc0b      	bgt.n	8026884 <__kernel_rem_pio2f+0x204>
 802686c:	aa06      	add	r2, sp, #24
 802686e:	4415      	add	r5, r2
 8026870:	2200      	movs	r2, #0
 8026872:	f855 0d04 	ldr.w	r0, [r5, #-4]!
 8026876:	4545      	cmp	r5, r8
 8026878:	ea42 0200 	orr.w	r2, r2, r0
 802687c:	d1f9      	bne.n	8026872 <__kernel_rem_pio2f+0x1f2>
 802687e:	2a00      	cmp	r2, #0
 8026880:	f040 8170 	bne.w	8026b64 <__kernel_rem_pio2f+0x4e4>
 8026884:	1e73      	subs	r3, r6, #1
 8026886:	aa06      	add	r2, sp, #24
 8026888:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 802688c:	2b00      	cmp	r3, #0
 802688e:	f040 817c 	bne.w	8026b8a <__kernel_rem_pio2f+0x50a>
 8026892:	9b04      	ldr	r3, [sp, #16]
 8026894:	f04f 0e01 	mov.w	lr, #1
 8026898:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 802689c:	f10e 0e01 	add.w	lr, lr, #1
 80268a0:	2a00      	cmp	r2, #0
 80268a2:	d0f9      	beq.n	8026898 <__kernel_rem_pio2f+0x218>
 80268a4:	44a6      	add	lr, r4
 80268a6:	1c63      	adds	r3, r4, #1
 80268a8:	4573      	cmp	r3, lr
 80268aa:	dc2f      	bgt.n	802690c <__kernel_rem_pio2f+0x28c>
 80268ac:	9a03      	ldr	r2, [sp, #12]
 80268ae:	189d      	adds	r5, r3, r2
 80268b0:	9a02      	ldr	r2, [sp, #8]
 80268b2:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 80268b6:	18a0      	adds	r0, r4, r2
 80268b8:	eb0e 0c02 	add.w	ip, lr, r2
 80268bc:	9a65      	ldr	r2, [sp, #404]	; 0x194
 80268be:	3d01      	subs	r5, #1
 80268c0:	eb02 0585 	add.w	r5, r2, r5, lsl #2
 80268c4:	aa1a      	add	r2, sp, #104	; 0x68
 80268c6:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 80268ca:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
 80268ce:	aa42      	add	r2, sp, #264	; 0x108
 80268d0:	eb02 0483 	add.w	r4, r2, r3, lsl #2
 80268d4:	f855 3f04 	ldr.w	r3, [r5, #4]!
 80268d8:	ee07 3a90 	vmov	s15, r3
 80268dc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80268e0:	2f00      	cmp	r7, #0
 80268e2:	ece0 7a01 	vstmia	r0!, {s15}
 80268e6:	eddf 7a45 	vldr	s15, [pc, #276]	; 80269fc <__kernel_rem_pio2f+0x37c>
 80268ea:	db0b      	blt.n	8026904 <__kernel_rem_pio2f+0x284>
 80268ec:	4652      	mov	r2, sl
 80268ee:	eb00 0109 	add.w	r1, r0, r9
 80268f2:	4603      	mov	r3, r0
 80268f4:	ed33 7a01 	vldmdb	r3!, {s14}
 80268f8:	ecf2 6a01 	vldmia	r2!, {s13}
 80268fc:	428b      	cmp	r3, r1
 80268fe:	eee6 7a87 	vfma.f32	s15, s13, s14
 8026902:	d1f7      	bne.n	80268f4 <__kernel_rem_pio2f+0x274>
 8026904:	4560      	cmp	r0, ip
 8026906:	ece4 7a01 	vstmia	r4!, {s15}
 802690a:	d1e3      	bne.n	80268d4 <__kernel_rem_pio2f+0x254>
 802690c:	4674      	mov	r4, lr
 802690e:	e719      	b.n	8026744 <__kernel_rem_pio2f+0xc4>
 8026910:	eeb7 0a00 	vmov.f32	s0, #112	; 0x70
 8026914:	ee30 9a49 	vsub.f32	s18, s0, s18
 8026918:	2800      	cmp	r0, #0
 802691a:	d09f      	beq.n	802685c <__kernel_rem_pio2f+0x1dc>
 802691c:	4658      	mov	r0, fp
 802691e:	9105      	str	r1, [sp, #20]
 8026920:	f000 fa38 	bl	8026d94 <scalbnf>
 8026924:	ee39 9a40 	vsub.f32	s18, s18, s0
 8026928:	9905      	ldr	r1, [sp, #20]
 802692a:	eeb5 9a40 	vcmp.f32	s18, #0.0
 802692e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026932:	d098      	beq.n	8026866 <__kernel_rem_pio2f+0x1e6>
 8026934:	eeb0 0a49 	vmov.f32	s0, s18
 8026938:	f1cb 0000 	rsb	r0, fp, #0
 802693c:	9102      	str	r1, [sp, #8]
 802693e:	f000 fa29 	bl	8026d94 <scalbnf>
 8026942:	ed9f 7a2c 	vldr	s14, [pc, #176]	; 80269f4 <__kernel_rem_pio2f+0x374>
 8026946:	9902      	ldr	r1, [sp, #8]
 8026948:	eeb4 0ac7 	vcmpe.f32	s0, s14
 802694c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026950:	f2c0 817e 	blt.w	8026c50 <__kernel_rem_pio2f+0x5d0>
 8026954:	eddf 7a26 	vldr	s15, [pc, #152]	; 80269f0 <__kernel_rem_pio2f+0x370>
 8026958:	ee60 7a27 	vmul.f32	s15, s0, s15
 802695c:	a806      	add	r0, sp, #24
 802695e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8026962:	1c63      	adds	r3, r4, #1
 8026964:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8026968:	f10b 0b08 	add.w	fp, fp, #8
 802696c:	eea7 0ac7 	vfms.f32	s0, s15, s14
 8026970:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8026974:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 8026978:	ee10 2a10 	vmov	r2, s0
 802697c:	f840 2024 	str.w	r2, [r0, r4, lsl #2]
 8026980:	ee17 2a90 	vmov	r2, s15
 8026984:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 8026988:	4658      	mov	r0, fp
 802698a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x70
 802698e:	9303      	str	r3, [sp, #12]
 8026990:	9102      	str	r1, [sp, #8]
 8026992:	f000 f9ff 	bl	8026d94 <scalbnf>
 8026996:	9b03      	ldr	r3, [sp, #12]
 8026998:	9902      	ldr	r1, [sp, #8]
 802699a:	2b00      	cmp	r3, #0
 802699c:	f2c0 80c7 	blt.w	8026b2e <__kernel_rem_pio2f+0x4ae>
 80269a0:	f103 0e01 	add.w	lr, r3, #1
 80269a4:	ea4f 028e 	mov.w	r2, lr, lsl #2
 80269a8:	ac42      	add	r4, sp, #264	; 0x108
 80269aa:	a806      	add	r0, sp, #24
 80269ac:	ed9f 7a10 	vldr	s14, [pc, #64]	; 80269f0 <__kernel_rem_pio2f+0x370>
 80269b0:	4410      	add	r0, r2
 80269b2:	18a7      	adds	r7, r4, r2
 80269b4:	ed70 7a01 	vldmdb	r0!, {s15}
 80269b8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80269bc:	ee67 7a80 	vmul.f32	s15, s15, s0
 80269c0:	ee20 0a07 	vmul.f32	s0, s0, s14
 80269c4:	ed67 7a01 	vstmdb	r7!, {s15}
 80269c8:	42a7      	cmp	r7, r4
 80269ca:	d1f3      	bne.n	80269b4 <__kernel_rem_pio2f+0x334>
 80269cc:	3a04      	subs	r2, #4
 80269ce:	4417      	add	r7, r2
 80269d0:	2500      	movs	r5, #0
 80269d2:	2e00      	cmp	r6, #0
 80269d4:	f2c0 80a8 	blt.w	8026b28 <__kernel_rem_pio2f+0x4a8>
 80269d8:	2d00      	cmp	r5, #0
 80269da:	f2c0 80a5 	blt.w	8026b28 <__kernel_rem_pio2f+0x4a8>
 80269de:	4c06      	ldr	r4, [pc, #24]	; (80269f8 <__kernel_rem_pio2f+0x378>)
 80269e0:	eddf 7a06 	vldr	s15, [pc, #24]	; 80269fc <__kernel_rem_pio2f+0x37c>
 80269e4:	4638      	mov	r0, r7
 80269e6:	2200      	movs	r2, #0
 80269e8:	e00c      	b.n	8026a04 <__kernel_rem_pio2f+0x384>
 80269ea:	bf00      	nop
 80269ec:	0802a34c 	.word	0x0802a34c
 80269f0:	3b800000 	.word	0x3b800000
 80269f4:	43800000 	.word	0x43800000
 80269f8:	0802a358 	.word	0x0802a358
 80269fc:	00000000 	.word	0x00000000
 8026a00:	42aa      	cmp	r2, r5
 8026a02:	dc08      	bgt.n	8026a16 <__kernel_rem_pio2f+0x396>
 8026a04:	ecf4 6a01 	vldmia	r4!, {s13}
 8026a08:	ecb0 7a01 	vldmia	r0!, {s14}
 8026a0c:	3201      	adds	r2, #1
 8026a0e:	4296      	cmp	r6, r2
 8026a10:	eee6 7a87 	vfma.f32	s15, s13, s14
 8026a14:	daf4      	bge.n	8026a00 <__kernel_rem_pio2f+0x380>
 8026a16:	aa56      	add	r2, sp, #344	; 0x158
 8026a18:	eb02 0285 	add.w	r2, r2, r5, lsl #2
 8026a1c:	3501      	adds	r5, #1
 8026a1e:	4575      	cmp	r5, lr
 8026a20:	f1a7 0704 	sub.w	r7, r7, #4
 8026a24:	ed42 7a28 	vstr	s15, [r2, #-160]	; 0xffffff60
 8026a28:	d1d3      	bne.n	80269d2 <__kernel_rem_pio2f+0x352>
 8026a2a:	9a64      	ldr	r2, [sp, #400]	; 0x190
 8026a2c:	2a03      	cmp	r2, #3
 8026a2e:	d85f      	bhi.n	8026af0 <__kernel_rem_pio2f+0x470>
 8026a30:	e8df f002 	tbb	[pc, r2]
 8026a34:	b0373767 	.word	0xb0373767
 8026a38:	d110      	bne.n	8026a5c <__kernel_rem_pio2f+0x3dc>
 8026a3a:	1e63      	subs	r3, r4, #1
 8026a3c:	aa06      	add	r2, sp, #24
 8026a3e:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 8026a42:	1209      	asrs	r1, r1, #8
 8026a44:	e6ce      	b.n	80267e4 <__kernel_rem_pio2f+0x164>
 8026a46:	1e62      	subs	r2, r4, #1
 8026a48:	ab06      	add	r3, sp, #24
 8026a4a:	f10d 0e18 	add.w	lr, sp, #24
 8026a4e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8026a52:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8026a56:	f84e 3022 	str.w	r3, [lr, r2, lsl #2]
 8026a5a:	e6fd      	b.n	8026858 <__kernel_rem_pio2f+0x1d8>
 8026a5c:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 8026a60:	eeb4 9ae7 	vcmpe.f32	s18, s15
 8026a64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026a68:	da0a      	bge.n	8026a80 <__kernel_rem_pio2f+0x400>
 8026a6a:	2100      	movs	r1, #0
 8026a6c:	e6f6      	b.n	802685c <__kernel_rem_pio2f+0x1dc>
 8026a6e:	ed5f 7a1d 	vldr	s15, [pc, #-116]	; 80269fc <__kernel_rem_pio2f+0x37c>
 8026a72:	3104      	adds	r1, #4
 8026a74:	42a1      	cmp	r1, r4
 8026a76:	ece0 7a01 	vstmia	r0!, {s15}
 8026a7a:	f47f ae3b 	bne.w	80266f4 <__kernel_rem_pio2f+0x74>
 8026a7e:	e64d      	b.n	802671c <__kernel_rem_pio2f+0x9c>
 8026a80:	ee19 3a90 	vmov	r3, s19
 8026a84:	2c00      	cmp	r4, #0
 8026a86:	f103 0301 	add.w	r3, r3, #1
 8026a8a:	ee09 3a90 	vmov	s19, r3
 8026a8e:	bfc8      	it	gt
 8026a90:	2102      	movgt	r1, #2
 8026a92:	f73f aeb2 	bgt.w	80267fa <__kernel_rem_pio2f+0x17a>
 8026a96:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 8026a9a:	ee37 9ac9 	vsub.f32	s18, s15, s18
 8026a9e:	2102      	movs	r1, #2
 8026aa0:	e6dc      	b.n	802685c <__kernel_rem_pio2f+0x1dc>
 8026aa2:	aa2e      	add	r2, sp, #184	; 0xb8
 8026aa4:	ed5f 7a2b 	vldr	s15, [pc, #-172]	; 80269fc <__kernel_rem_pio2f+0x37c>
 8026aa8:	eb02 0e8e 	add.w	lr, r2, lr, lsl #2
 8026aac:	ed3e 7a01 	vldmdb	lr!, {s14}
 8026ab0:	4596      	cmp	lr, r2
 8026ab2:	ee77 7a87 	vadd.f32	s15, s15, s14
 8026ab6:	d1f9      	bne.n	8026aac <__kernel_rem_pio2f+0x42c>
 8026ab8:	2900      	cmp	r1, #0
 8026aba:	d043      	beq.n	8026b44 <__kernel_rem_pio2f+0x4c4>
 8026abc:	eddd 6a2e 	vldr	s13, [sp, #184]	; 0xb8
 8026ac0:	9a01      	ldr	r2, [sp, #4]
 8026ac2:	eeb1 7a67 	vneg.f32	s14, s15
 8026ac6:	2b00      	cmp	r3, #0
 8026ac8:	ee76 7ae7 	vsub.f32	s15, s13, s15
 8026acc:	ed82 7a00 	vstr	s14, [r2]
 8026ad0:	dd09      	ble.n	8026ae6 <__kernel_rem_pio2f+0x466>
 8026ad2:	a82f      	add	r0, sp, #188	; 0xbc
 8026ad4:	2201      	movs	r2, #1
 8026ad6:	ecb0 7a01 	vldmia	r0!, {s14}
 8026ada:	3201      	adds	r2, #1
 8026adc:	4293      	cmp	r3, r2
 8026ade:	ee77 7a87 	vadd.f32	s15, s15, s14
 8026ae2:	daf8      	bge.n	8026ad6 <__kernel_rem_pio2f+0x456>
 8026ae4:	b109      	cbz	r1, 8026aea <__kernel_rem_pio2f+0x46a>
 8026ae6:	eef1 7a67 	vneg.f32	s15, s15
 8026aea:	9b01      	ldr	r3, [sp, #4]
 8026aec:	edc3 7a01 	vstr	s15, [r3, #4]
 8026af0:	ee19 3a90 	vmov	r3, s19
 8026af4:	f003 0007 	and.w	r0, r3, #7
 8026af8:	b057      	add	sp, #348	; 0x15c
 8026afa:	ecbd 8b04 	vpop	{d8-d9}
 8026afe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8026b02:	aa2e      	add	r2, sp, #184	; 0xb8
 8026b04:	ed5f 7a43 	vldr	s15, [pc, #-268]	; 80269fc <__kernel_rem_pio2f+0x37c>
 8026b08:	eb02 0e8e 	add.w	lr, r2, lr, lsl #2
 8026b0c:	ed3e 7a01 	vldmdb	lr!, {s14}
 8026b10:	3b01      	subs	r3, #1
 8026b12:	1c5a      	adds	r2, r3, #1
 8026b14:	ee77 7a87 	vadd.f32	s15, s15, s14
 8026b18:	d1f8      	bne.n	8026b0c <__kernel_rem_pio2f+0x48c>
 8026b1a:	b109      	cbz	r1, 8026b20 <__kernel_rem_pio2f+0x4a0>
 8026b1c:	eef1 7a67 	vneg.f32	s15, s15
 8026b20:	9b01      	ldr	r3, [sp, #4]
 8026b22:	edc3 7a00 	vstr	s15, [r3]
 8026b26:	e7e3      	b.n	8026af0 <__kernel_rem_pio2f+0x470>
 8026b28:	ed5f 7a4c 	vldr	s15, [pc, #-304]	; 80269fc <__kernel_rem_pio2f+0x37c>
 8026b2c:	e773      	b.n	8026a16 <__kernel_rem_pio2f+0x396>
 8026b2e:	9a64      	ldr	r2, [sp, #400]	; 0x190
 8026b30:	2a03      	cmp	r2, #3
 8026b32:	d8dd      	bhi.n	8026af0 <__kernel_rem_pio2f+0x470>
 8026b34:	e8df f002 	tbb	[pc, r2]
 8026b38:	80020213 	.word	0x80020213
 8026b3c:	ed5f 7a51 	vldr	s15, [pc, #-324]	; 80269fc <__kernel_rem_pio2f+0x37c>
 8026b40:	2900      	cmp	r1, #0
 8026b42:	d1bb      	bne.n	8026abc <__kernel_rem_pio2f+0x43c>
 8026b44:	ed9d 7a2e 	vldr	s14, [sp, #184]	; 0xb8
 8026b48:	9a01      	ldr	r2, [sp, #4]
 8026b4a:	2b00      	cmp	r3, #0
 8026b4c:	edc2 7a00 	vstr	s15, [r2]
 8026b50:	ee77 7a67 	vsub.f32	s15, s14, s15
 8026b54:	dcbd      	bgt.n	8026ad2 <__kernel_rem_pio2f+0x452>
 8026b56:	9b01      	ldr	r3, [sp, #4]
 8026b58:	edc3 7a01 	vstr	s15, [r3, #4]
 8026b5c:	e7c8      	b.n	8026af0 <__kernel_rem_pio2f+0x470>
 8026b5e:	ed5f 7a59 	vldr	s15, [pc, #-356]	; 80269fc <__kernel_rem_pio2f+0x37c>
 8026b62:	e7da      	b.n	8026b1a <__kernel_rem_pio2f+0x49a>
 8026b64:	aa06      	add	r2, sp, #24
 8026b66:	f1ab 0b08 	sub.w	fp, fp, #8
 8026b6a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8026b6e:	2a00      	cmp	r2, #0
 8026b70:	f47f af0a 	bne.w	8026988 <__kernel_rem_pio2f+0x308>
 8026b74:	aa06      	add	r2, sp, #24
 8026b76:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8026b7a:	f852 0d04 	ldr.w	r0, [r2, #-4]!
 8026b7e:	3b01      	subs	r3, #1
 8026b80:	f1ab 0b08 	sub.w	fp, fp, #8
 8026b84:	2800      	cmp	r0, #0
 8026b86:	d0f8      	beq.n	8026b7a <__kernel_rem_pio2f+0x4fa>
 8026b88:	e6fe      	b.n	8026988 <__kernel_rem_pio2f+0x308>
 8026b8a:	f04f 0e01 	mov.w	lr, #1
 8026b8e:	e689      	b.n	80268a4 <__kernel_rem_pio2f+0x224>
 8026b90:	2000      	movs	r0, #0
 8026b92:	e64d      	b.n	8026830 <__kernel_rem_pio2f+0x1b0>
 8026b94:	2b00      	cmp	r3, #0
 8026b96:	dd4f      	ble.n	8026c38 <__kernel_rem_pio2f+0x5b8>
 8026b98:	009a      	lsls	r2, r3, #2
 8026b9a:	a856      	add	r0, sp, #344	; 0x158
 8026b9c:	4410      	add	r0, r2
 8026b9e:	ad2e      	add	r5, sp, #184	; 0xb8
 8026ba0:	1d14      	adds	r4, r2, #4
 8026ba2:	ed10 7a28 	vldr	s14, [r0, #-160]	; 0xffffff60
 8026ba6:	442c      	add	r4, r5
 8026ba8:	18a8      	adds	r0, r5, r2
 8026baa:	ed70 7a01 	vldmdb	r0!, {s15}
 8026bae:	ee77 6a27 	vadd.f32	s13, s14, s15
 8026bb2:	42a8      	cmp	r0, r5
 8026bb4:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8026bb8:	ee77 7a27 	vadd.f32	s15, s14, s15
 8026bbc:	eeb0 7a66 	vmov.f32	s14, s13
 8026bc0:	ed64 7a01 	vstmdb	r4!, {s15}
 8026bc4:	edc0 6a00 	vstr	s13, [r0]
 8026bc8:	d1ef      	bne.n	8026baa <__kernel_rem_pio2f+0x52a>
 8026bca:	2b01      	cmp	r3, #1
 8026bcc:	dd34      	ble.n	8026c38 <__kernel_rem_pio2f+0x5b8>
 8026bce:	1d13      	adds	r3, r2, #4
 8026bd0:	ac56      	add	r4, sp, #344	; 0x158
 8026bd2:	4414      	add	r4, r2
 8026bd4:	4403      	add	r3, r0
 8026bd6:	ed14 7a28 	vldr	s14, [r4, #-160]	; 0xffffff60
 8026bda:	4402      	add	r2, r0
 8026bdc:	ac2f      	add	r4, sp, #188	; 0xbc
 8026bde:	4618      	mov	r0, r3
 8026be0:	ed72 7a01 	vldmdb	r2!, {s15}
 8026be4:	ee77 6a87 	vadd.f32	s13, s15, s14
 8026be8:	42a2      	cmp	r2, r4
 8026bea:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8026bee:	ee77 7a87 	vadd.f32	s15, s15, s14
 8026bf2:	eeb0 7a66 	vmov.f32	s14, s13
 8026bf6:	ed60 7a01 	vstmdb	r0!, {s15}
 8026bfa:	edc2 6a00 	vstr	s13, [r2]
 8026bfe:	d1ef      	bne.n	8026be0 <__kernel_rem_pio2f+0x560>
 8026c00:	ed5f 7a82 	vldr	s15, [pc, #-520]	; 80269fc <__kernel_rem_pio2f+0x37c>
 8026c04:	aa30      	add	r2, sp, #192	; 0xc0
 8026c06:	ed33 7a01 	vldmdb	r3!, {s14}
 8026c0a:	4293      	cmp	r3, r2
 8026c0c:	ee77 7a87 	vadd.f32	s15, s15, s14
 8026c10:	d1f9      	bne.n	8026c06 <__kernel_rem_pio2f+0x586>
 8026c12:	b1a9      	cbz	r1, 8026c40 <__kernel_rem_pio2f+0x5c0>
 8026c14:	eddd 6a2e 	vldr	s13, [sp, #184]	; 0xb8
 8026c18:	ed9d 7a2f 	vldr	s14, [sp, #188]	; 0xbc
 8026c1c:	9a01      	ldr	r2, [sp, #4]
 8026c1e:	eef1 7a67 	vneg.f32	s15, s15
 8026c22:	eef1 6a66 	vneg.f32	s13, s13
 8026c26:	eeb1 7a47 	vneg.f32	s14, s14
 8026c2a:	edc2 7a02 	vstr	s15, [r2, #8]
 8026c2e:	edc2 6a00 	vstr	s13, [r2]
 8026c32:	ed82 7a01 	vstr	s14, [r2, #4]
 8026c36:	e75b      	b.n	8026af0 <__kernel_rem_pio2f+0x470>
 8026c38:	ed5f 7a90 	vldr	s15, [pc, #-576]	; 80269fc <__kernel_rem_pio2f+0x37c>
 8026c3c:	2900      	cmp	r1, #0
 8026c3e:	d1e9      	bne.n	8026c14 <__kernel_rem_pio2f+0x594>
 8026c40:	9801      	ldr	r0, [sp, #4]
 8026c42:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 8026c44:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 8026c46:	edc0 7a02 	vstr	s15, [r0, #8]
 8026c4a:	6002      	str	r2, [r0, #0]
 8026c4c:	6043      	str	r3, [r0, #4]
 8026c4e:	e74f      	b.n	8026af0 <__kernel_rem_pio2f+0x470>
 8026c50:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 8026c54:	a806      	add	r0, sp, #24
 8026c56:	ee10 2a10 	vmov	r2, s0
 8026c5a:	4623      	mov	r3, r4
 8026c5c:	f840 2024 	str.w	r2, [r0, r4, lsl #2]
 8026c60:	e692      	b.n	8026988 <__kernel_rem_pio2f+0x308>
 8026c62:	bf00      	nop

08026c64 <__kernel_sinf>:
 8026c64:	ee10 3a10 	vmov	r3, s0
 8026c68:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8026c6c:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 8026c70:	da04      	bge.n	8026c7c <__kernel_sinf+0x18>
 8026c72:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8026c76:	ee17 3a90 	vmov	r3, s15
 8026c7a:	b323      	cbz	r3, 8026cc6 <__kernel_sinf+0x62>
 8026c7c:	ee60 7a00 	vmul.f32	s15, s0, s0
 8026c80:	ed9f 5a15 	vldr	s10, [pc, #84]	; 8026cd8 <__kernel_sinf+0x74>
 8026c84:	eddf 5a15 	vldr	s11, [pc, #84]	; 8026cdc <__kernel_sinf+0x78>
 8026c88:	ed9f 6a15 	vldr	s12, [pc, #84]	; 8026ce0 <__kernel_sinf+0x7c>
 8026c8c:	eddf 6a15 	vldr	s13, [pc, #84]	; 8026ce4 <__kernel_sinf+0x80>
 8026c90:	ed9f 7a15 	vldr	s14, [pc, #84]	; 8026ce8 <__kernel_sinf+0x84>
 8026c94:	eee7 5a85 	vfma.f32	s11, s15, s10
 8026c98:	ee27 5a80 	vmul.f32	s10, s15, s0
 8026c9c:	eea5 6aa7 	vfma.f32	s12, s11, s15
 8026ca0:	eee6 6a27 	vfma.f32	s13, s12, s15
 8026ca4:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8026ca8:	b170      	cbz	r0, 8026cc8 <__kernel_sinf+0x64>
 8026caa:	ee27 7a45 	vnmul.f32	s14, s14, s10
 8026cae:	eef6 6a00 	vmov.f32	s13, #96	; 0x60
 8026cb2:	eea0 7aa6 	vfma.f32	s14, s1, s13
 8026cb6:	eddf 6a0d 	vldr	s13, [pc, #52]	; 8026cec <__kernel_sinf+0x88>
 8026cba:	eed7 0a27 	vfnms.f32	s1, s14, s15
 8026cbe:	eee5 0a26 	vfma.f32	s1, s10, s13
 8026cc2:	ee30 0a60 	vsub.f32	s0, s0, s1
 8026cc6:	4770      	bx	lr
 8026cc8:	eddf 6a09 	vldr	s13, [pc, #36]	; 8026cf0 <__kernel_sinf+0x8c>
 8026ccc:	eee7 6a87 	vfma.f32	s13, s15, s14
 8026cd0:	eea6 0a85 	vfma.f32	s0, s13, s10
 8026cd4:	4770      	bx	lr
 8026cd6:	bf00      	nop
 8026cd8:	2f2ec9d3 	.word	0x2f2ec9d3
 8026cdc:	b2d72f34 	.word	0xb2d72f34
 8026ce0:	3638ef1b 	.word	0x3638ef1b
 8026ce4:	b9500d01 	.word	0xb9500d01
 8026ce8:	3c088889 	.word	0x3c088889
 8026cec:	3e2aaaab 	.word	0x3e2aaaab
 8026cf0:	be2aaaab 	.word	0xbe2aaaab

08026cf4 <fabsf>:
 8026cf4:	ee10 3a10 	vmov	r3, s0
 8026cf8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8026cfc:	ee00 3a10 	vmov	s0, r3
 8026d00:	4770      	bx	lr
 8026d02:	bf00      	nop

08026d04 <floorf>:
 8026d04:	ee10 2a10 	vmov	r2, s0
 8026d08:	f022 4100 	bic.w	r1, r2, #2147483648	; 0x80000000
 8026d0c:	0dcb      	lsrs	r3, r1, #23
 8026d0e:	3b7f      	subs	r3, #127	; 0x7f
 8026d10:	2b16      	cmp	r3, #22
 8026d12:	dc17      	bgt.n	8026d44 <floorf+0x40>
 8026d14:	2b00      	cmp	r3, #0
 8026d16:	ee10 0a10 	vmov	r0, s0
 8026d1a:	db19      	blt.n	8026d50 <floorf+0x4c>
 8026d1c:	491a      	ldr	r1, [pc, #104]	; (8026d88 <floorf+0x84>)
 8026d1e:	4119      	asrs	r1, r3
 8026d20:	4211      	tst	r1, r2
 8026d22:	d022      	beq.n	8026d6a <floorf+0x66>
 8026d24:	eddf 7a19 	vldr	s15, [pc, #100]	; 8026d8c <floorf+0x88>
 8026d28:	ee70 7a27 	vadd.f32	s15, s0, s15
 8026d2c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8026d30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026d34:	dd19      	ble.n	8026d6a <floorf+0x66>
 8026d36:	2a00      	cmp	r2, #0
 8026d38:	db18      	blt.n	8026d6c <floorf+0x68>
 8026d3a:	ea20 0301 	bic.w	r3, r0, r1
 8026d3e:	ee00 3a10 	vmov	s0, r3
 8026d42:	4770      	bx	lr
 8026d44:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 8026d48:	d30f      	bcc.n	8026d6a <floorf+0x66>
 8026d4a:	ee30 0a00 	vadd.f32	s0, s0, s0
 8026d4e:	4770      	bx	lr
 8026d50:	eddf 7a0e 	vldr	s15, [pc, #56]	; 8026d8c <floorf+0x88>
 8026d54:	ee70 7a27 	vadd.f32	s15, s0, s15
 8026d58:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8026d5c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026d60:	dd03      	ble.n	8026d6a <floorf+0x66>
 8026d62:	2a00      	cmp	r2, #0
 8026d64:	db08      	blt.n	8026d78 <floorf+0x74>
 8026d66:	ed9f 0a0a 	vldr	s0, [pc, #40]	; 8026d90 <floorf+0x8c>
 8026d6a:	4770      	bx	lr
 8026d6c:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 8026d70:	fa42 f303 	asr.w	r3, r2, r3
 8026d74:	4418      	add	r0, r3
 8026d76:	e7e0      	b.n	8026d3a <floorf+0x36>
 8026d78:	2900      	cmp	r1, #0
 8026d7a:	eeff 7a00 	vmov.f32	s15, #240	; 0xf0
 8026d7e:	bf18      	it	ne
 8026d80:	eeb0 0a67 	vmovne.f32	s0, s15
 8026d84:	4770      	bx	lr
 8026d86:	bf00      	nop
 8026d88:	007fffff 	.word	0x007fffff
 8026d8c:	7149f2ca 	.word	0x7149f2ca
 8026d90:	00000000 	.word	0x00000000

08026d94 <scalbnf>:
 8026d94:	b508      	push	{r3, lr}
 8026d96:	ee10 3a10 	vmov	r3, s0
 8026d9a:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
 8026d9e:	ed2d 8b02 	vpush	{d8}
 8026da2:	d011      	beq.n	8026dc8 <scalbnf+0x34>
 8026da4:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8026da8:	d211      	bcs.n	8026dce <scalbnf+0x3a>
 8026daa:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 8026dae:	d313      	bcc.n	8026dd8 <scalbnf+0x44>
 8026db0:	0dd2      	lsrs	r2, r2, #23
 8026db2:	4402      	add	r2, r0
 8026db4:	2afe      	cmp	r2, #254	; 0xfe
 8026db6:	dc2e      	bgt.n	8026e16 <scalbnf+0x82>
 8026db8:	2a00      	cmp	r2, #0
 8026dba:	dd1a      	ble.n	8026df2 <scalbnf+0x5e>
 8026dbc:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 8026dc0:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 8026dc4:	ee00 3a10 	vmov	s0, r3
 8026dc8:	ecbd 8b02 	vpop	{d8}
 8026dcc:	bd08      	pop	{r3, pc}
 8026dce:	ecbd 8b02 	vpop	{d8}
 8026dd2:	ee30 0a00 	vadd.f32	s0, s0, s0
 8026dd6:	bd08      	pop	{r3, pc}
 8026dd8:	4b1d      	ldr	r3, [pc, #116]	; (8026e50 <scalbnf+0xbc>)
 8026dda:	eddf 7a1e 	vldr	s15, [pc, #120]	; 8026e54 <scalbnf+0xc0>
 8026dde:	4298      	cmp	r0, r3
 8026de0:	ee20 0a27 	vmul.f32	s0, s0, s15
 8026de4:	db22      	blt.n	8026e2c <scalbnf+0x98>
 8026de6:	ee10 3a10 	vmov	r3, s0
 8026dea:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 8026dee:	3a19      	subs	r2, #25
 8026df0:	e7df      	b.n	8026db2 <scalbnf+0x1e>
 8026df2:	f112 0f16 	cmn.w	r2, #22
 8026df6:	da1e      	bge.n	8026e36 <scalbnf+0xa2>
 8026df8:	f24c 3350 	movw	r3, #50000	; 0xc350
 8026dfc:	4298      	cmp	r0, r3
 8026dfe:	dc0a      	bgt.n	8026e16 <scalbnf+0x82>
 8026e00:	ed9f 8a15 	vldr	s16, [pc, #84]	; 8026e58 <scalbnf+0xc4>
 8026e04:	eef0 0a40 	vmov.f32	s1, s0
 8026e08:	eeb0 0a48 	vmov.f32	s0, s16
 8026e0c:	f000 f82a 	bl	8026e64 <copysignf>
 8026e10:	ee20 0a08 	vmul.f32	s0, s0, s16
 8026e14:	e7d8      	b.n	8026dc8 <scalbnf+0x34>
 8026e16:	ed9f 8a11 	vldr	s16, [pc, #68]	; 8026e5c <scalbnf+0xc8>
 8026e1a:	eef0 0a40 	vmov.f32	s1, s0
 8026e1e:	eeb0 0a48 	vmov.f32	s0, s16
 8026e22:	f000 f81f 	bl	8026e64 <copysignf>
 8026e26:	ee20 0a08 	vmul.f32	s0, s0, s16
 8026e2a:	e7cd      	b.n	8026dc8 <scalbnf+0x34>
 8026e2c:	eddf 0a0a 	vldr	s1, [pc, #40]	; 8026e58 <scalbnf+0xc4>
 8026e30:	ee20 0a20 	vmul.f32	s0, s0, s1
 8026e34:	e7c8      	b.n	8026dc8 <scalbnf+0x34>
 8026e36:	3219      	adds	r2, #25
 8026e38:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 8026e3c:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 8026e40:	eddf 7a07 	vldr	s15, [pc, #28]	; 8026e60 <scalbnf+0xcc>
 8026e44:	ee00 3a10 	vmov	s0, r3
 8026e48:	ee20 0a27 	vmul.f32	s0, s0, s15
 8026e4c:	e7bc      	b.n	8026dc8 <scalbnf+0x34>
 8026e4e:	bf00      	nop
 8026e50:	ffff3cb0 	.word	0xffff3cb0
 8026e54:	4c000000 	.word	0x4c000000
 8026e58:	0da24260 	.word	0x0da24260
 8026e5c:	7149f2ca 	.word	0x7149f2ca
 8026e60:	33000000 	.word	0x33000000

08026e64 <copysignf>:
 8026e64:	ee10 3a10 	vmov	r3, s0
 8026e68:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 8026e6c:	ee10 3a90 	vmov	r3, s1
 8026e70:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8026e74:	4313      	orrs	r3, r2
 8026e76:	ee00 3a10 	vmov	s0, r3
 8026e7a:	4770      	bx	lr
 8026e7c:	6c727463 	.word	0x6c727463
 8026e80:	20736920 	.word	0x20736920
 8026e84:	6f727265 	.word	0x6f727265
 8026e88:	000a0d72 	.word	0x000a0d72
 8026e8c:	4c525443 	.word	0x4c525443
 8026e90:	6174535f 	.word	0x6174535f
 8026e94:	4f5f6574 	.word	0x4f5f6574
 8026e98:	4c6e6570 	.word	0x4c6e6570
 8026e9c:	0d706f6f 	.word	0x0d706f6f
 8026ea0:	0000000a 	.word	0x0000000a
 8026ea4:	4c525443 	.word	0x4c525443
 8026ea8:	6174535f 	.word	0x6174535f
 8026eac:	435f6574 	.word	0x435f6574
 8026eb0:	65727275 	.word	0x65727275
 8026eb4:	6c43746e 	.word	0x6c43746e
 8026eb8:	4c65736f 	.word	0x4c65736f
 8026ebc:	0d706f6f 	.word	0x0d706f6f
 8026ec0:	0000000a 	.word	0x0000000a
 8026ec4:	4c525443 	.word	0x4c525443
 8026ec8:	6174535f 	.word	0x6174535f
 8026ecc:	535f6574 	.word	0x535f6574
 8026ed0:	64656570 	.word	0x64656570
 8026ed4:	736f6c43 	.word	0x736f6c43
 8026ed8:	6f6f4c65 	.word	0x6f6f4c65
 8026edc:	000a0d70 	.word	0x000a0d70
 8026ee0:	00007874 	.word	0x00007874
 8026ee4:	0a0d7325 	.word	0x0a0d7325
 8026ee8:	00000000 	.word	0x00000000
 8026eec:	00007872 	.word	0x00007872
 8026ef0:	65636572 	.word	0x65636572
 8026ef4:	20657669 	.word	0x20657669
 8026ef8:	20737472 	.word	0x20737472
 8026efc:	6b636170 	.word	0x6b636170
 8026f00:	20737465 	.word	0x20737465
 8026f04:	6425203d 	.word	0x6425203d
 8026f08:	00000a0d 	.word	0x00000a0d
 8026f0c:	6d61620a 	.word	0x6d61620a
 8026f10:	63657220 	.word	0x63657220
 8026f14:	65766965 	.word	0x65766965
 8026f18:	20642520 	.word	0x20642520
 8026f1c:	61746164 	.word	0x61746164
 8026f20:	000a0d3a 	.word	0x000a0d3a
 8026f24:	61746144 	.word	0x61746144
 8026f28:	205d305b 	.word	0x205d305b
 8026f2c:	6425203d 	.word	0x6425203d
 8026f30:	6372202c 	.word	0x6372202c
 8026f34:	63617076 	.word	0x63617076
 8026f38:	7374656b 	.word	0x7374656b
 8026f3c:	25203d20 	.word	0x25203d20
 8026f40:	000a0d64 	.word	0x000a0d64
 8026f44:	2054440a 	.word	0x2054440a
 8026f48:	65636572 	.word	0x65636572
 8026f4c:	20657669 	.word	0x20657669
 8026f50:	64206425 	.word	0x64206425
 8026f54:	3a617461 	.word	0x3a617461
 8026f58:	00000a0d 	.word	0x00000a0d
 8026f5c:	65636572 	.word	0x65636572
 8026f60:	20657669 	.word	0x20657669
 8026f64:	4f646e65 	.word	0x4f646e65
 8026f68:	67734d66 	.word	0x67734d66
 8026f6c:	0d6b6341 	.word	0x0d6b6341
 8026f70:	0000000a 	.word	0x0000000a
 8026f74:	65636572 	.word	0x65636572
 8026f78:	20657669 	.word	0x20657669
 8026f7c:	0d6d6162 	.word	0x0d6d6162
 8026f80:	0000000a 	.word	0x0000000a
 8026f84:	3339314a 	.word	0x3339314a
 8026f88:	6d697439 	.word	0x6d697439
 8026f8c:	00007265 	.word	0x00007265
 8026f90:	316e6163 	.word	0x316e6163
 8026f94:	00000000 	.word	0x00000000
 8026f98:	20677765 	.word	0x20677765
 8026f9c:	6f727265 	.word	0x6f727265
 8026fa0:	000a0d72 	.word	0x000a0d72
 8026fa4:	20767065 	.word	0x20767065
 8026fa8:	6f727265 	.word	0x6f727265
 8026fac:	000a0d72 	.word	0x000a0d72
 8026fb0:	20666f62 	.word	0x20666f62
 8026fb4:	6f727265 	.word	0x6f727265
 8026fb8:	000a0d72 	.word	0x000a0d72
 8026fbc:	20667473 	.word	0x20667473
 8026fc0:	6f727265 	.word	0x6f727265
 8026fc4:	000a0d72 	.word	0x000a0d72
 8026fc8:	20726f66 	.word	0x20726f66
 8026fcc:	6f727265 	.word	0x6f727265
 8026fd0:	000a0d72 	.word	0x000a0d72
 8026fd4:	206b6361 	.word	0x206b6361
 8026fd8:	6f727265 	.word	0x6f727265
 8026fdc:	000a0d72 	.word	0x000a0d72
 8026fe0:	65207262 	.word	0x65207262
 8026fe4:	726f7272 	.word	0x726f7272
 8026fe8:	00000a0d 	.word	0x00000a0d
 8026fec:	65206462 	.word	0x65206462
 8026ff0:	726f7272 	.word	0x726f7272
 8026ff4:	00000a0d 	.word	0x00000a0d
 8026ff8:	20637263 	.word	0x20637263
 8026ffc:	6f727265 	.word	0x6f727265
 8027000:	000a0d72 	.word	0x000a0d72
 8027004:	204e4143 	.word	0x204e4143
 8027008:	66207874 	.word	0x66207874
 802700c:	216c6961 	.word	0x216c6961
 8027010:	0d782520 	.word	0x0d782520
 8027014:	0000000a 	.word	0x0000000a
 8027018:	65636572 	.word	0x65636572
 802701c:	20657669 	.word	0x20657669
 8027020:	0d6e6163 	.word	0x0d6e6163
 8027024:	0000000a 	.word	0x0000000a
 8027028:	665f7872 	.word	0x665f7872
 802702c:	206f6669 	.word	0x206f6669
 8027030:	52203d21 	.word	0x52203d21
 8027034:	554e5f54 	.word	0x554e5f54
 8027038:	00004c4c 	.word	0x00004c4c
 802703c:	665f7872 	.word	0x665f7872
 8027040:	2d6f6669 	.word	0x2d6f6669
 8027044:	6572663e 	.word	0x6572663e
 8027048:	6d756e65 	.word	0x6d756e65
 802704c:	73726562 	.word	0x73726562
 8027050:	30203e20 	.word	0x30203e20
 8027054:	00000000 	.word	0x00000000
 8027058:	6f727265 	.word	0x6f727265
 802705c:	65642072 	.word	0x65642072
 8027060:	74696e69 	.word	0x74696e69
 8027064:	6e616320 	.word	0x6e616320
 8027068:	00000a0d 	.word	0x00000a0d
 802706c:	6f727265 	.word	0x6f727265
 8027070:	6e692072 	.word	0x6e692072
 8027074:	63207469 	.word	0x63207469
 8027078:	0a0d6e61 	.word	0x0a0d6e61
 802707c:	00000000 	.word	0x00000000
 8027080:	6c6c616d 	.word	0x6c6c616d
 8027084:	6620636f 	.word	0x6620636f
 8027088:	0d6c6961 	.word	0x0d6c6961
 802708c:	0000000a 	.word	0x0000000a
 8027090:	656d6974 	.word	0x656d6974
 8027094:	6e614372 	.word	0x6e614372
 8027098:	00007872 	.word	0x00007872
 802709c:	316e6163 	.word	0x316e6163
 80270a0:	00000000 	.word	0x00000000
 80270a4:	000000fa 	.word	0x000000fa
 80270a8:	00000040 	.word	0x00000040
	...
 80270b4:	0000000a 	.word	0x0000000a
 80270b8:	74726175 	.word	0x74726175
 80270bc:	00000031 	.word	0x00000031
 80270c0:	45524220 	.word	0x45524220
 80270c4:	20314b41 	.word	0x20314b41
 80270c8:	74207369 	.word	0x74207369
 80270cc:	67676972 	.word	0x67676972
 80270d0:	64657265 	.word	0x64657265
 80270d4:	00000a0d 	.word	0x00000a0d
 80270d8:	45524220 	.word	0x45524220
 80270dc:	20324b41 	.word	0x20324b41
 80270e0:	74207369 	.word	0x74207369
 80270e4:	67676972 	.word	0x67676972
 80270e8:	64657265 	.word	0x64657265
 80270ec:	00000a0d 	.word	0x00000a0d
 80270f0:	384d4954 	.word	0x384d4954
 80270f4:	20736920 	.word	0x20736920
 80270f8:	67697274 	.word	0x67697274
 80270fc:	65726567 	.word	0x65726567
 8027100:	000a0d64 	.word	0x000a0d64
 8027104:	69726573 	.word	0x69726573
 8027108:	21206c61 	.word	0x21206c61
 802710c:	5452203d 	.word	0x5452203d
 8027110:	4c554e5f 	.word	0x4c554e5f
 8027114:	0000004c 	.word	0x0000004c
 8027118:	20676663 	.word	0x20676663
 802711c:	52203d21 	.word	0x52203d21
 8027120:	554e5f54 	.word	0x554e5f54
 8027124:	00004c4c 	.word	0x00004c4c
 8027128:	74206e69 	.word	0x74206e69
 802712c:	63206568 	.word	0x63206568
 8027130:	72746e6f 	.word	0x72746e6f
 8027134:	0a0d6c6f 	.word	0x0a0d6c6f
 8027138:	00000000 	.word	0x00000000
 802713c:	74726175 	.word	0x74726175
 8027140:	00000031 	.word	0x00000031
 8027144:	74726175 	.word	0x74726175
 8027148:	00000033 	.word	0x00000033
 802714c:	0001c200 	.word	0x0001c200
 8027150:	00010008 	.word	0x00010008
 8027154:	00038400 	.word	0x00038400
 8027158:	00010008 	.word	0x00010008
 802715c:	655f6372 	.word	0x655f6372
 8027160:	726f7272 	.word	0x726f7272
 8027164:	00000a0d 	.word	0x00000a0d
 8027168:	3339314a 	.word	0x3339314a
 802716c:	64787439 	.word	0x64787439
 8027170:	00000000 	.word	0x00000000
 8027174:	316e6163 	.word	0x316e6163
 8027178:	00000000 	.word	0x00000000
 802717c:	6e65706f 	.word	0x6e65706f
 8027180:	72726520 	.word	0x72726520
 8027184:	0a0d726f 	.word	0x0a0d726f
 8027188:	00000000 	.word	0x00000000
 802718c:	206c6176 	.word	0x206c6176
 8027190:	6c6c756e 	.word	0x6c6c756e
 8027194:	00000a0d 	.word	0x00000a0d
 8027198:	3a706420 	.word	0x3a706420
 802719c:	0d782520 	.word	0x0d782520
 80271a0:	0000000a 	.word	0x0000000a
 80271a4:	203a6670 	.word	0x203a6670
 80271a8:	0d207825 	.word	0x0d207825
 80271ac:	0000000a 	.word	0x0000000a
 80271b0:	203a7370 	.word	0x203a7370
 80271b4:	0d207825 	.word	0x0d207825
 80271b8:	0000000a 	.word	0x0000000a
 80271bc:	20766372 	.word	0x20766372
 80271c0:	61746164 	.word	0x61746164
 80271c4:	0000203a 	.word	0x0000203a
 80271c8:	00207825 	.word	0x00207825
 80271cc:	00000a0d 	.word	0x00000a0d
 80271d0:	08a00047 	.word	0x08a00047
 80271d4:	352e46aa 	.word	0x352e46aa
 80271d8:	006e6143 	.word	0x006e6143
 80271dc:	3339314a 	.word	0x3339314a
 80271e0:	76637239 	.word	0x76637239
 80271e4:	00000000 	.word	0x00000000
 80271e8:	5f6e6163 	.word	0x5f6e6163
 80271ec:	735f7872 	.word	0x735f7872
 80271f0:	63206d65 	.word	0x63206d65
 80271f4:	74616572 	.word	0x74616572
 80271f8:	72652065 	.word	0x72652065
 80271fc:	0d726f72 	.word	0x0d726f72
 8027200:	0000000a 	.word	0x0000000a
 8027204:	3339314a 	.word	0x3339314a
 8027208:	76635239 	.word	0x76635239
 802720c:	00000000 	.word	0x00000000
 8027210:	00000030 	.word	0x00000030
 8027214:	00000031 	.word	0x00000031
 8027218:	00000032 	.word	0x00000032
 802721c:	00000033 	.word	0x00000033
 8027220:	6e6b6e75 	.word	0x6e6b6e75
 8027224:	206e776f 	.word	0x206e776f
 8027228:	61726170 	.word	0x61726170
 802722c:	6574656d 	.word	0x6574656d
 8027230:	000a0d72 	.word	0x000a0d72
 8027234:	00006e6f 	.word	0x00006e6f
 8027238:	0066666f 	.word	0x0066666f
 802723c:	706d6574 	.word	0x706d6574
 8027240:	7830203d 	.word	0x7830203d
 8027244:	0d207825 	.word	0x0d207825
 8027248:	0000000a 	.word	0x0000000a
 802724c:	20535542 	.word	0x20535542
 8027250:	30203d56 	.word	0x30203d56
 8027254:	20782578 	.word	0x20782578
 8027258:	00000a0d 	.word	0x00000a0d
 802725c:	20535542 	.word	0x20535542
 8027260:	30203d49 	.word	0x30203d49
 8027264:	20782578 	.word	0x20782578
 8027268:	00000a0d 	.word	0x00000a0d
 802726c:	544c4f56 	.word	0x544c4f56
 8027270:	20454741 	.word	0x20454741
 8027274:	30203d43 	.word	0x30203d43
 8027278:	20782578 	.word	0x20782578
 802727c:	00000a0d 	.word	0x00000a0d
 8027280:	544c4f56 	.word	0x544c4f56
 8027284:	20454741 	.word	0x20454741
 8027288:	30203d42 	.word	0x30203d42
 802728c:	20782578 	.word	0x20782578
 8027290:	00000a0d 	.word	0x00000a0d
 8027294:	544c4f56 	.word	0x544c4f56
 8027298:	20454741 	.word	0x20454741
 802729c:	30203d41 	.word	0x30203d41
 80272a0:	20782578 	.word	0x20782578
 80272a4:	00000a0d 	.word	0x00000a0d
 80272a8:	72727563 	.word	0x72727563
 80272ac:	20746e65 	.word	0x20746e65
 80272b0:	203d3243 	.word	0x203d3243
 80272b4:	78257830 	.word	0x78257830
 80272b8:	000a0d20 	.word	0x000a0d20
 80272bc:	72727563 	.word	0x72727563
 80272c0:	20746e65 	.word	0x20746e65
 80272c4:	203d3143 	.word	0x203d3143
 80272c8:	78257830 	.word	0x78257830
 80272cc:	000a0d20 	.word	0x000a0d20
 80272d0:	72727563 	.word	0x72727563
 80272d4:	20746e65 	.word	0x20746e65
 80272d8:	203d3242 	.word	0x203d3242
 80272dc:	78257830 	.word	0x78257830
 80272e0:	000a0d20 	.word	0x000a0d20
 80272e4:	72727563 	.word	0x72727563
 80272e8:	20746e65 	.word	0x20746e65
 80272ec:	203d3142 	.word	0x203d3142
 80272f0:	78257830 	.word	0x78257830
 80272f4:	000a0d20 	.word	0x000a0d20
 80272f8:	72727563 	.word	0x72727563
 80272fc:	20746e65 	.word	0x20746e65
 8027300:	203d3241 	.word	0x203d3241
 8027304:	78257830 	.word	0x78257830
 8027308:	000a0d20 	.word	0x000a0d20
 802730c:	72727563 	.word	0x72727563
 8027310:	20746e65 	.word	0x20746e65
 8027314:	203d3141 	.word	0x203d3141
 8027318:	78257830 	.word	0x78257830
 802731c:	000a0d20 	.word	0x000a0d20
 8027320:	706d6574 	.word	0x706d6574
 8027324:	66666f20 	.word	0x66666f20
 8027328:	3d746573 	.word	0x3d746573
 802732c:	25783020 	.word	0x25783020
 8027330:	0a0d2078 	.word	0x0a0d2078
 8027334:	00000000 	.word	0x00000000
 8027338:	20535542 	.word	0x20535542
 802733c:	6f202056 	.word	0x6f202056
 8027340:	65736666 	.word	0x65736666
 8027344:	30203d74 	.word	0x30203d74
 8027348:	20782578 	.word	0x20782578
 802734c:	00000a0d 	.word	0x00000a0d
 8027350:	20535542 	.word	0x20535542
 8027354:	666f2049 	.word	0x666f2049
 8027358:	74657366 	.word	0x74657366
 802735c:	7830203d 	.word	0x7830203d
 8027360:	0d207825 	.word	0x0d207825
 8027364:	0000000a 	.word	0x0000000a
 8027368:	544c4f56 	.word	0x544c4f56
 802736c:	20454741 	.word	0x20454741
 8027370:	666f2043 	.word	0x666f2043
 8027374:	74657366 	.word	0x74657366
 8027378:	7830203d 	.word	0x7830203d
 802737c:	0d207825 	.word	0x0d207825
 8027380:	0000000a 	.word	0x0000000a
 8027384:	544c4f56 	.word	0x544c4f56
 8027388:	20454741 	.word	0x20454741
 802738c:	666f2042 	.word	0x666f2042
 8027390:	74657366 	.word	0x74657366
 8027394:	7830203d 	.word	0x7830203d
 8027398:	0d207825 	.word	0x0d207825
 802739c:	0000000a 	.word	0x0000000a
 80273a0:	544c4f56 	.word	0x544c4f56
 80273a4:	20454741 	.word	0x20454741
 80273a8:	666f2041 	.word	0x666f2041
 80273ac:	74657366 	.word	0x74657366
 80273b0:	7830203d 	.word	0x7830203d
 80273b4:	0d207825 	.word	0x0d207825
 80273b8:	0000000a 	.word	0x0000000a
 80273bc:	72727563 	.word	0x72727563
 80273c0:	20746e65 	.word	0x20746e65
 80273c4:	6f203243 	.word	0x6f203243
 80273c8:	65736666 	.word	0x65736666
 80273cc:	30203d74 	.word	0x30203d74
 80273d0:	20782578 	.word	0x20782578
 80273d4:	00000a0d 	.word	0x00000a0d
 80273d8:	72727563 	.word	0x72727563
 80273dc:	20746e65 	.word	0x20746e65
 80273e0:	6f203143 	.word	0x6f203143
 80273e4:	65736666 	.word	0x65736666
 80273e8:	30203d74 	.word	0x30203d74
 80273ec:	20782578 	.word	0x20782578
 80273f0:	00000a0d 	.word	0x00000a0d
 80273f4:	72727563 	.word	0x72727563
 80273f8:	20746e65 	.word	0x20746e65
 80273fc:	6f203242 	.word	0x6f203242
 8027400:	65736666 	.word	0x65736666
 8027404:	30203d74 	.word	0x30203d74
 8027408:	20782578 	.word	0x20782578
 802740c:	00000a0d 	.word	0x00000a0d
 8027410:	72727563 	.word	0x72727563
 8027414:	20746e65 	.word	0x20746e65
 8027418:	6f203142 	.word	0x6f203142
 802741c:	65736666 	.word	0x65736666
 8027420:	30203d74 	.word	0x30203d74
 8027424:	20782578 	.word	0x20782578
 8027428:	00000a0d 	.word	0x00000a0d
 802742c:	72727563 	.word	0x72727563
 8027430:	20746e65 	.word	0x20746e65
 8027434:	6f203241 	.word	0x6f203241
 8027438:	65736666 	.word	0x65736666
 802743c:	30203d74 	.word	0x30203d74
 8027440:	20782578 	.word	0x20782578
 8027444:	00000a0d 	.word	0x00000a0d
 8027448:	72727563 	.word	0x72727563
 802744c:	20746e65 	.word	0x20746e65
 8027450:	6f203141 	.word	0x6f203141
 8027454:	65736666 	.word	0x65736666
 8027458:	30203d74 	.word	0x30203d74
 802745c:	20782578 	.word	0x20782578
 8027460:	00000a0d 	.word	0x00000a0d
 8027464:	6f746f4d 	.word	0x6f746f4d
 8027468:	73692072 	.word	0x73692072
 802746c:	61747320 	.word	0x61747320
 8027470:	64657472 	.word	0x64657472
 8027474:	00000a0d 	.word	0x00000a0d
 8027478:	6f746f4d 	.word	0x6f746f4d
 802747c:	73692072 	.word	0x73692072
 8027480:	6f747320 	.word	0x6f747320
 8027484:	64657070 	.word	0x64657070
 8027488:	00000a0d 	.word	0x00000a0d
 802748c:	354d4954 	.word	0x354d4954
 8027490:	544e4320 	.word	0x544e4320
 8027494:	78253d20 	.word	0x78253d20
 8027498:	00000a0d 	.word	0x00000a0d
 802749c:	6f746f4d 	.word	0x6f746f4d
 80274a0:	00000072 	.word	0x00000072
 80274a4:	74696e69 	.word	0x74696e69
 80274a8:	00000000 	.word	0x00000000
 80274ac:	74737973 	.word	0x74737973
 80274b0:	00006d65 	.word	0x00006d65
 80274b4:	74726175 	.word	0x74726175
 80274b8:	00000033 	.word	0x00000033
 80274bc:	6e65706f 	.word	0x6e65706f
 80274c0:	72726520 	.word	0x72726520
 80274c4:	0a0d726f 	.word	0x0a0d726f
 80274c8:	00000000 	.word	0x00000000
 80274cc:	72617375 	.word	0x72617375
 80274d0:	78743374 	.word	0x78743374
 80274d4:	00000000 	.word	0x00000000
 80274d8:	206d6573 	.word	0x206d6573
 80274dc:	61657263 	.word	0x61657263
 80274e0:	65206574 	.word	0x65206574
 80274e4:	726f7272 	.word	0x726f7272
 80274e8:	00000a0d 	.word	0x00000a0d
 80274ec:	72617375 	.word	0x72617375
 80274f0:	63723374 	.word	0x63723374
 80274f4:	00000076 	.word	0x00000076
 80274f8:	72617375 	.word	0x72617375
 80274fc:	78723374 	.word	0x78723374
 8027500:	0000716d 	.word	0x0000716d
 8027504:	6d5f7872 	.word	0x6d5f7872
 8027508:	72632071 	.word	0x72632071
 802750c:	65746165 	.word	0x65746165
 8027510:	72726520 	.word	0x72726520
 8027514:	0a0d726f 	.word	0x0a0d726f
 8027518:	00000000 	.word	0x00000000
 802751c:	72617375 	.word	0x72617375
 8027520:	78723374 	.word	0x78723374
 8027524:	00000000 	.word	0x00000000
 8027528:	20766564 	.word	0x20766564
 802752c:	52203d21 	.word	0x52203d21
 8027530:	554e5f54 	.word	0x554e5f54
 8027534:	00004c4c 	.word	0x00004c4c
 8027538:	69206f54 	.word	0x69206f54
 802753c:	6974696e 	.word	0x6974696e
 8027540:	7a696c61 	.word	0x7a696c61
 8027544:	65642065 	.word	0x65642065
 8027548:	65636976 	.word	0x65636976
 802754c:	2073253a 	.word	0x2073253a
 8027550:	6c696166 	.word	0x6c696166
 8027554:	202e6465 	.word	0x202e6465
 8027558:	20656854 	.word	0x20656854
 802755c:	6f727265 	.word	0x6f727265
 8027560:	6f632072 	.word	0x6f632072
 8027564:	69206564 	.word	0x69206564
 8027568:	64252073 	.word	0x64252073
 802756c:	0000000a 	.word	0x0000000a
 8027570:	2d766564 	.word	0x2d766564
 8027574:	6665723e 	.word	0x6665723e
 8027578:	756f635f 	.word	0x756f635f
 802757c:	2120746e 	.word	0x2120746e
 8027580:	0030203d 	.word	0x0030203d
 8027584:	636e7546 	.word	0x636e7546
 8027588:	6e6f6974 	.word	0x6e6f6974
 802758c:	5d73255b 	.word	0x5d73255b
 8027590:	61687320 	.word	0x61687320
 8027594:	6e206c6c 	.word	0x6e206c6c
 8027598:	7520746f 	.word	0x7520746f
 802759c:	20646573 	.word	0x20646573
 80275a0:	49206e69 	.word	0x49206e69
 80275a4:	000a5253 	.word	0x000a5253
 80275a8:	00000030 	.word	0x00000030
 80275ac:	6c646974 	.word	0x6c646974
 80275b0:	00000065 	.word	0x00000065
 80275b4:	206d6573 	.word	0x206d6573
 80275b8:	52203d21 	.word	0x52203d21
 80275bc:	554e5f54 	.word	0x554e5f54
 80275c0:	00004c4c 	.word	0x00004c4c
 80275c4:	636e7546 	.word	0x636e7546
 80275c8:	6e6f6974 	.word	0x6e6f6974
 80275cc:	5d73255b 	.word	0x5d73255b
 80275d0:	61687320 	.word	0x61687320
 80275d4:	6e206c6c 	.word	0x6e206c6c
 80275d8:	7520746f 	.word	0x7520746f
 80275dc:	20646573 	.word	0x20646573
 80275e0:	49206e69 	.word	0x49206e69
 80275e4:	000a5253 	.word	0x000a5253
 80275e8:	00000030 	.word	0x00000030
 80275ec:	636e7546 	.word	0x636e7546
 80275f0:	6e6f6974 	.word	0x6e6f6974
 80275f4:	5d73255b 	.word	0x5d73255b
 80275f8:	61687320 	.word	0x61687320
 80275fc:	6e206c6c 	.word	0x6e206c6c
 8027600:	6220746f 	.word	0x6220746f
 8027604:	73752065 	.word	0x73752065
 8027608:	62206465 	.word	0x62206465
 802760c:	726f6665 	.word	0x726f6665
 8027610:	63732065 	.word	0x63732065
 8027614:	75646568 	.word	0x75646568
 8027618:	2072656c 	.word	0x2072656c
 802761c:	72617473 	.word	0x72617473
 8027620:	00000a74 	.word	0x00000a74
 8027624:	6574756d 	.word	0x6574756d
 8027628:	3d212078 	.word	0x3d212078
 802762c:	5f545220 	.word	0x5f545220
 8027630:	4c4c554e 	.word	0x4c4c554e
 8027634:	00000000 	.word	0x00000000
 8027638:	6e657665 	.word	0x6e657665
 802763c:	3d212074 	.word	0x3d212074
 8027640:	5f545220 	.word	0x5f545220
 8027644:	4c4c554e 	.word	0x4c4c554e
 8027648:	00000000 	.word	0x00000000
 802764c:	2120626d 	.word	0x2120626d
 8027650:	5452203d 	.word	0x5452203d
 8027654:	4c554e5f 	.word	0x4c554e5f
 8027658:	0000004c 	.word	0x0000004c
 802765c:	2120716d 	.word	0x2120716d
 8027660:	5452203d 	.word	0x5452203d
 8027664:	4c554e5f 	.word	0x4c554e5f
 8027668:	0000004c 	.word	0x0000004c
 802766c:	66667562 	.word	0x66667562
 8027670:	21207265 	.word	0x21207265
 8027674:	5452203d 	.word	0x5452203d
 8027678:	4c554e5f 	.word	0x4c554e5f
 802767c:	0000004c 	.word	0x0000004c
 8027680:	657a6973 	.word	0x657a6973
 8027684:	203d2120 	.word	0x203d2120
 8027688:	00000030 	.word	0x00000030
 802768c:	205c200a 	.word	0x205c200a
 8027690:	0a2f207c 	.word	0x0a2f207c
 8027694:	00000000 	.word	0x00000000
 8027698:	5452202d 	.word	0x5452202d
 802769c:	20202d20 	.word	0x20202d20
 80276a0:	54202020 	.word	0x54202020
 80276a4:	61657268 	.word	0x61657268
 80276a8:	704f2064 	.word	0x704f2064
 80276ac:	74617265 	.word	0x74617265
 80276b0:	20676e69 	.word	0x20676e69
 80276b4:	74737953 	.word	0x74737953
 80276b8:	000a6d65 	.word	0x000a6d65
 80276bc:	7c202f20 	.word	0x7c202f20
 80276c0:	20205c20 	.word	0x20205c20
 80276c4:	25202020 	.word	0x25202020
 80276c8:	64252e64 	.word	0x64252e64
 80276cc:	2064252e 	.word	0x2064252e
 80276d0:	6c697562 	.word	0x6c697562
 80276d4:	73252064 	.word	0x73252064
 80276d8:	0000000a 	.word	0x0000000a
 80276dc:	20677541 	.word	0x20677541
 80276e0:	32203931 	.word	0x32203931
 80276e4:	00363130 	.word	0x00363130
 80276e8:	30303220 	.word	0x30303220
 80276ec:	202d2036 	.word	0x202d2036
 80276f0:	35313032 	.word	0x35313032
 80276f4:	706f4320 	.word	0x706f4320
 80276f8:	67697279 	.word	0x67697279
 80276fc:	62207468 	.word	0x62207468
 8027700:	74722079 	.word	0x74722079
 8027704:	7268742d 	.word	0x7268742d
 8027708:	20646165 	.word	0x20646165
 802770c:	6d616574 	.word	0x6d616574
 8027710:	0000000a 	.word	0x0000000a
 8027714:	4c554e28 	.word	0x4c554e28
 8027718:	0000294c 	.word	0x0000294c
 802771c:	29732528 	.word	0x29732528
 8027720:	73736120 	.word	0x73736120
 8027724:	69747265 	.word	0x69747265
 8027728:	66206e6f 	.word	0x66206e6f
 802772c:	656c6961 	.word	0x656c6961
 8027730:	74612064 	.word	0x74612064
 8027734:	6e756620 	.word	0x6e756620
 8027738:	6f697463 	.word	0x6f697463
 802773c:	73253a6e 	.word	0x73253a6e
 8027740:	696c202c 	.word	0x696c202c
 8027744:	6e20656e 	.word	0x6e20656e
 8027748:	65626d75 	.word	0x65626d75
 802774c:	64253a72 	.word	0x64253a72
 8027750:	00000a20 	.word	0x00000a20
 8027754:	5f747228 	.word	0x5f747228
 8027758:	746e6975 	.word	0x746e6975
 802775c:	20745f38 	.word	0x20745f38
 8027760:	656d292a 	.word	0x656d292a
 8027764:	3d3e206d 	.word	0x3d3e206d
 8027768:	61656820 	.word	0x61656820
 802776c:	74705f70 	.word	0x74705f70
 8027770:	00000072 	.word	0x00000072
 8027774:	5f747228 	.word	0x5f747228
 8027778:	746e6975 	.word	0x746e6975
 802777c:	20745f38 	.word	0x20745f38
 8027780:	656d292a 	.word	0x656d292a
 8027784:	203c206d 	.word	0x203c206d
 8027788:	5f747228 	.word	0x5f747228
 802778c:	746e6975 	.word	0x746e6975
 8027790:	20745f38 	.word	0x20745f38
 8027794:	6568292a 	.word	0x6568292a
 8027798:	655f7061 	.word	0x655f7061
 802779c:	0000646e 	.word	0x0000646e
 80277a0:	2d6d656d 	.word	0x2d6d656d
 80277a4:	6573753e 	.word	0x6573753e
 80277a8:	3d3d2064 	.word	0x3d3d2064
 80277ac:	00003020 	.word	0x00003020
 80277b0:	636e7546 	.word	0x636e7546
 80277b4:	6e6f6974 	.word	0x6e6f6974
 80277b8:	5d73255b 	.word	0x5d73255b
 80277bc:	61687320 	.word	0x61687320
 80277c0:	6e206c6c 	.word	0x6e206c6c
 80277c4:	7520746f 	.word	0x7520746f
 80277c8:	20646573 	.word	0x20646573
 80277cc:	49206e69 	.word	0x49206e69
 80277d0:	000a5253 	.word	0x000a5253
 80277d4:	00000030 	.word	0x00000030
 80277d8:	206d656d 	.word	0x206d656d
 80277dc:	74696e69 	.word	0x74696e69
 80277e0:	7265202c 	.word	0x7265202c
 80277e4:	20726f72 	.word	0x20726f72
 80277e8:	69676562 	.word	0x69676562
 80277ec:	6461206e 	.word	0x6461206e
 80277f0:	73657264 	.word	0x73657264
 80277f4:	78302073 	.word	0x78302073
 80277f8:	202c7825 	.word	0x202c7825
 80277fc:	20646e61 	.word	0x20646e61
 8027800:	20646e65 	.word	0x20646e65
 8027804:	72646461 	.word	0x72646461
 8027808:	20737365 	.word	0x20737365
 802780c:	78257830 	.word	0x78257830
 8027810:	0000000a 	.word	0x0000000a
 8027814:	70616568 	.word	0x70616568
 8027818:	00000000 	.word	0x00000000
 802781c:	666c2828 	.word	0x666c2828
 8027820:	20656572 	.word	0x20656572
 8027824:	68203d3d 	.word	0x68203d3d
 8027828:	5f706165 	.word	0x5f706165
 802782c:	29646e65 	.word	0x29646e65
 8027830:	207c7c20 	.word	0x207c7c20
 8027834:	666c2128 	.word	0x666c2128
 8027838:	2d656572 	.word	0x2d656572
 802783c:	6573753e 	.word	0x6573753e
 8027840:	00292964 	.word	0x00292964
 8027844:	5f747228 	.word	0x5f747228
 8027848:	746e6975 	.word	0x746e6975
 802784c:	745f3233 	.word	0x745f3233
 8027850:	6d656d29 	.word	0x6d656d29
 8027854:	53202b20 	.word	0x53202b20
 8027858:	4f455a49 	.word	0x4f455a49
 802785c:	54535f46 	.word	0x54535f46
 8027860:	54435552 	.word	0x54435552
 8027864:	4d454d5f 	.word	0x4d454d5f
 8027868:	73202b20 	.word	0x73202b20
 802786c:	20657a69 	.word	0x20657a69
 8027870:	28203d3c 	.word	0x28203d3c
 8027874:	755f7472 	.word	0x755f7472
 8027878:	33746e69 	.word	0x33746e69
 802787c:	29745f32 	.word	0x29745f32
 8027880:	70616568 	.word	0x70616568
 8027884:	646e655f 	.word	0x646e655f
 8027888:	00000000 	.word	0x00000000
 802788c:	5f747228 	.word	0x5f747228
 8027890:	746e6975 	.word	0x746e6975
 8027894:	745f3233 	.word	0x745f3233
 8027898:	72282829 	.word	0x72282829
 802789c:	69755f74 	.word	0x69755f74
 80278a0:	5f38746e 	.word	0x5f38746e
 80278a4:	292a2074 	.word	0x292a2074
 80278a8:	206d656d 	.word	0x206d656d
 80278ac:	4953202b 	.word	0x4953202b
 80278b0:	464f455a 	.word	0x464f455a
 80278b4:	5254535f 	.word	0x5254535f
 80278b8:	5f544355 	.word	0x5f544355
 80278bc:	294d454d 	.word	0x294d454d
 80278c0:	52202520 	.word	0x52202520
 80278c4:	4c415f54 	.word	0x4c415f54
 80278c8:	5f4e4749 	.word	0x5f4e4749
 80278cc:	455a4953 	.word	0x455a4953
 80278d0:	203d3d20 	.word	0x203d3d20
 80278d4:	00000030 	.word	0x00000030
 80278d8:	72282828 	.word	0x72282828
 80278dc:	69755f74 	.word	0x69755f74
 80278e0:	3233746e 	.word	0x3233746e
 80278e4:	6d29745f 	.word	0x6d29745f
 80278e8:	20296d65 	.word	0x20296d65
 80278ec:	52282026 	.word	0x52282026
 80278f0:	4c415f54 	.word	0x4c415f54
 80278f4:	5f4e4749 	.word	0x5f4e4749
 80278f8:	455a4953 	.word	0x455a4953
 80278fc:	2929312d 	.word	0x2929312d
 8027900:	203d3d20 	.word	0x203d3d20
 8027904:	00000030 	.word	0x00000030
 8027908:	72282828 	.word	0x72282828
 802790c:	69755f74 	.word	0x69755f74
 8027910:	3233746e 	.word	0x3233746e
 8027914:	7229745f 	.word	0x7229745f
 8027918:	296d656d 	.word	0x296d656d
 802791c:	28202620 	.word	0x28202620
 8027920:	415f5452 	.word	0x415f5452
 8027924:	4e47494c 	.word	0x4e47494c
 8027928:	5a49535f 	.word	0x5a49535f
 802792c:	29312d45 	.word	0x29312d45
 8027930:	3d3d2029 	.word	0x3d3d2029
 8027934:	00003020 	.word	0x00003020
 8027938:	5f747228 	.word	0x5f747228
 802793c:	746e6975 	.word	0x746e6975
 8027940:	20745f38 	.word	0x20745f38
 8027944:	6d72292a 	.word	0x6d72292a
 8027948:	3e206d65 	.word	0x3e206d65
 802794c:	7228203d 	.word	0x7228203d
 8027950:	69755f74 	.word	0x69755f74
 8027954:	5f38746e 	.word	0x5f38746e
 8027958:	292a2074 	.word	0x292a2074
 802795c:	70616568 	.word	0x70616568
 8027960:	7274705f 	.word	0x7274705f
 8027964:	20262620 	.word	0x20262620
 8027968:	5f747228 	.word	0x5f747228
 802796c:	746e6975 	.word	0x746e6975
 8027970:	20745f38 	.word	0x20745f38
 8027974:	6d72292a 	.word	0x6d72292a
 8027978:	3c206d65 	.word	0x3c206d65
 802797c:	74722820 	.word	0x74722820
 8027980:	6e69755f 	.word	0x6e69755f
 8027984:	745f3874 	.word	0x745f3874
 8027988:	68292a20 	.word	0x68292a20
 802798c:	5f706165 	.word	0x5f706165
 8027990:	00646e65 	.word	0x00646e65
 8027994:	2d6d656d 	.word	0x2d6d656d
 8027998:	6573753e 	.word	0x6573753e
 802799c:	00000064 	.word	0x00000064
 80279a0:	2d6d656d 	.word	0x2d6d656d
 80279a4:	67616d3e 	.word	0x67616d3e
 80279a8:	3d206369 	.word	0x3d206369
 80279ac:	4548203d 	.word	0x4548203d
 80279b0:	4d5f5041 	.word	0x4d5f5041
 80279b4:	43494741 	.word	0x43494741
 80279b8:	00000000 	.word	0x00000000
 80279bc:	61746f74 	.word	0x61746f74
 80279c0:	656d206c 	.word	0x656d206c
 80279c4:	79726f6d 	.word	0x79726f6d
 80279c8:	6425203a 	.word	0x6425203a
 80279cc:	0000000a 	.word	0x0000000a
 80279d0:	64657375 	.word	0x64657375
 80279d4:	6d656d20 	.word	0x6d656d20
 80279d8:	2079726f 	.word	0x2079726f
 80279dc:	6425203a 	.word	0x6425203a
 80279e0:	0000000a 	.word	0x0000000a
 80279e4:	6978616d 	.word	0x6978616d
 80279e8:	206d756d 	.word	0x206d756d
 80279ec:	6f6c6c61 	.word	0x6f6c6c61
 80279f0:	65746163 	.word	0x65746163
 80279f4:	656d2064 	.word	0x656d2064
 80279f8:	79726f6d 	.word	0x79726f6d
 80279fc:	6425203a 	.word	0x6425203a
 8027a00:	0000000a 	.word	0x0000000a
 8027a04:	686d656d 	.word	0x686d656d
 8027a08:	20706165 	.word	0x20706165
 8027a0c:	52203d21 	.word	0x52203d21
 8027a10:	554e5f54 	.word	0x554e5f54
 8027a14:	00004c4c 	.word	0x00004c4c
 8027a18:	70616568 	.word	0x70616568
 8027a1c:	00000000 	.word	0x00000000
 8027a20:	70616568 	.word	0x70616568
 8027a24:	203d2120 	.word	0x203d2120
 8027a28:	4e5f5452 	.word	0x4e5f5452
 8027a2c:	004c4c55 	.word	0x004c4c55
 8027a30:	7478656e 	.word	0x7478656e
 8027a34:	7274705f 	.word	0x7274705f
 8027a38:	68203e20 	.word	0x68203e20
 8027a3c:	65646165 	.word	0x65646165
 8027a40:	74705f72 	.word	0x74705f72
 8027a44:	00000072 	.word	0x00000072
 8027a48:	7478656e 	.word	0x7478656e
 8027a4c:	7274705f 	.word	0x7274705f
 8027a50:	30203e20 	.word	0x30203e20
 8027a54:	00000000 	.word	0x00000000
 8027a58:	61656828 	.word	0x61656828
 8027a5c:	5f726564 	.word	0x5f726564
 8027a60:	2d727470 	.word	0x2d727470
 8027a64:	67616d3e 	.word	0x67616d3e
 8027a68:	26206369 	.word	0x26206369
 8027a6c:	5f545220 	.word	0x5f545220
 8027a70:	484d454d 	.word	0x484d454d
 8027a74:	5f504145 	.word	0x5f504145
 8027a78:	4b53414d 	.word	0x4b53414d
 8027a7c:	3d3d2029 	.word	0x3d3d2029
 8027a80:	5f545220 	.word	0x5f545220
 8027a84:	484d454d 	.word	0x484d454d
 8027a88:	5f504145 	.word	0x5f504145
 8027a8c:	4947414d 	.word	0x4947414d
 8027a90:	00000043 	.word	0x00000043
 8027a94:	64616568 	.word	0x64616568
 8027a98:	705f7265 	.word	0x705f7265
 8027a9c:	3e2d7274 	.word	0x3e2d7274
 8027aa0:	6967616d 	.word	0x6967616d
 8027aa4:	20262063 	.word	0x20262063
 8027aa8:	4d5f5452 	.word	0x4d5f5452
 8027aac:	45484d45 	.word	0x45484d45
 8027ab0:	555f5041 	.word	0x555f5041
 8027ab4:	00444553 	.word	0x00444553
 8027ab8:	61656828 	.word	0x61656828
 8027abc:	5f726564 	.word	0x5f726564
 8027ac0:	2d727470 	.word	0x2d727470
 8027ac4:	78656e3e 	.word	0x78656e3e
 8027ac8:	6d3e2d74 	.word	0x6d3e2d74
 8027acc:	63696761 	.word	0x63696761
 8027ad0:	52202620 	.word	0x52202620
 8027ad4:	454d5f54 	.word	0x454d5f54
 8027ad8:	4145484d 	.word	0x4145484d
 8027adc:	414d5f50 	.word	0x414d5f50
 8027ae0:	20294b53 	.word	0x20294b53
 8027ae4:	52203d3d 	.word	0x52203d3d
 8027ae8:	454d5f54 	.word	0x454d5f54
 8027aec:	4145484d 	.word	0x4145484d
 8027af0:	414d5f50 	.word	0x414d5f50
 8027af4:	00434947 	.word	0x00434947
 8027af8:	656a626f 	.word	0x656a626f
 8027afc:	21207463 	.word	0x21207463
 8027b00:	5452203d 	.word	0x5452203d
 8027b04:	4c554e5f 	.word	0x4c554e5f
 8027b08:	0000004c 	.word	0x0000004c
 8027b0c:	636e7546 	.word	0x636e7546
 8027b10:	6e6f6974 	.word	0x6e6f6974
 8027b14:	5d73255b 	.word	0x5d73255b
 8027b18:	61687320 	.word	0x61687320
 8027b1c:	6e206c6c 	.word	0x6e206c6c
 8027b20:	7520746f 	.word	0x7520746f
 8027b24:	20646573 	.word	0x20646573
 8027b28:	49206e69 	.word	0x49206e69
 8027b2c:	000a5253 	.word	0x000a5253
 8027b30:	00000030 	.word	0x00000030
 8027b34:	626f2821 	.word	0x626f2821
 8027b38:	7463656a 	.word	0x7463656a
 8027b3c:	79743e2d 	.word	0x79743e2d
 8027b40:	26206570 	.word	0x26206570
 8027b44:	5f545220 	.word	0x5f545220
 8027b48:	656a624f 	.word	0x656a624f
 8027b4c:	435f7463 	.word	0x435f7463
 8027b50:	7373616c 	.word	0x7373616c
 8027b54:	6174535f 	.word	0x6174535f
 8027b58:	29636974 	.word	0x29636974
 8027b5c:	00000000 	.word	0x00000000
 8027b60:	65726874 	.word	0x65726874
 8027b64:	21206461 	.word	0x21206461
 8027b68:	5452203d 	.word	0x5452203d
 8027b6c:	4c554e5f 	.word	0x4c554e5f
 8027b70:	0000004c 	.word	0x0000004c
 8027b74:	65726874 	.word	0x65726874
 8027b78:	253a6461 	.word	0x253a6461
 8027b7c:	74732073 	.word	0x74732073
 8027b80:	206b6361 	.word	0x206b6361
 8027b84:	7265766f 	.word	0x7265766f
 8027b88:	776f6c66 	.word	0x776f6c66
 8027b8c:	0000000a 	.word	0x0000000a
 8027b90:	6e726177 	.word	0x6e726177
 8027b94:	3a676e69 	.word	0x3a676e69
 8027b98:	20732520 	.word	0x20732520
 8027b9c:	63617473 	.word	0x63617473
 8027ba0:	7369206b 	.word	0x7369206b
 8027ba4:	6f6c6320 	.word	0x6f6c6320
 8027ba8:	74206573 	.word	0x74206573
 8027bac:	6e65206f 	.word	0x6e65206f
 8027bb0:	666f2064 	.word	0x666f2064
 8027bb4:	61747320 	.word	0x61747320
 8027bb8:	61206b63 	.word	0x61206b63
 8027bbc:	65726464 	.word	0x65726464
 8027bc0:	0a2e7373 	.word	0x0a2e7373
 8027bc4:	00000000 	.word	0x00000000
 8027bc8:	6f697270 	.word	0x6f697270
 8027bcc:	79746972 	.word	0x79746972
 8027bd0:	52203c20 	.word	0x52203c20
 8027bd4:	48545f54 	.word	0x48545f54
 8027bd8:	44414552 	.word	0x44414552
 8027bdc:	4952505f 	.word	0x4952505f
 8027be0:	5449524f 	.word	0x5449524f
 8027be4:	414d5f59 	.word	0x414d5f59
 8027be8:	00000058 	.word	0x00000058
 8027bec:	65726874 	.word	0x65726874
 8027bf0:	21206461 	.word	0x21206461
 8027bf4:	5452203d 	.word	0x5452203d
 8027bf8:	4c554e5f 	.word	0x4c554e5f
 8027bfc:	0000004c 	.word	0x0000004c
 8027c00:	63617473 	.word	0x63617473
 8027c04:	74735f6b 	.word	0x74735f6b
 8027c08:	20747261 	.word	0x20747261
 8027c0c:	52203d21 	.word	0x52203d21
 8027c10:	554e5f54 	.word	0x554e5f54
 8027c14:	00004c4c 	.word	0x00004c4c
 8027c18:	65726874 	.word	0x65726874
 8027c1c:	3e2d6461 	.word	0x3e2d6461
 8027c20:	74617473 	.word	0x74617473
 8027c24:	203d3d20 	.word	0x203d3d20
 8027c28:	545f5452 	.word	0x545f5452
 8027c2c:	41455248 	.word	0x41455248
 8027c30:	4e495f44 	.word	0x4e495f44
 8027c34:	00005449 	.word	0x00005449
 8027c38:	65726874 	.word	0x65726874
 8027c3c:	3e2d6461 	.word	0x3e2d6461
 8027c40:	74617473 	.word	0x74617473
 8027c44:	203d3d20 	.word	0x203d3d20
 8027c48:	545f5452 	.word	0x545f5452
 8027c4c:	41455248 	.word	0x41455248
 8027c50:	55535f44 	.word	0x55535f44
 8027c54:	4e455053 	.word	0x4e455053
 8027c58:	00000044 	.word	0x00000044
 8027c5c:	656d6974 	.word	0x656d6974
 8027c60:	3d212072 	.word	0x3d212072
 8027c64:	5f545220 	.word	0x5f545220
 8027c68:	4c4c554e 	.word	0x4c4c554e
 8027c6c:	00000000 	.word	0x00000000
 8027c70:	656d6974 	.word	0x656d6974
 8027c74:	693e2d72 	.word	0x693e2d72
 8027c78:	5f74696e 	.word	0x5f74696e
 8027c7c:	6b636974 	.word	0x6b636974
 8027c80:	52203c20 	.word	0x52203c20
 8027c84:	49545f54 	.word	0x49545f54
 8027c88:	4d5f4b43 	.word	0x4d5f4b43
 8027c8c:	2f205841 	.word	0x2f205841
 8027c90:	00003220 	.word	0x00003220
 8027c94:	656d6974 	.word	0x656d6974
 8027c98:	00000072 	.word	0x00000072
 8027c9c:	3a727370 	.word	0x3a727370
 8027ca0:	25783020 	.word	0x25783020
 8027ca4:	0a783830 	.word	0x0a783830
 8027ca8:	00000000 	.word	0x00000000
 8027cac:	3a637020 	.word	0x3a637020
 8027cb0:	25783020 	.word	0x25783020
 8027cb4:	0a783830 	.word	0x0a783830
 8027cb8:	00000000 	.word	0x00000000
 8027cbc:	3a726c20 	.word	0x3a726c20
 8027cc0:	25783020 	.word	0x25783020
 8027cc4:	0a783830 	.word	0x0a783830
 8027cc8:	00000000 	.word	0x00000000
 8027ccc:	3a323172 	.word	0x3a323172
 8027cd0:	25783020 	.word	0x25783020
 8027cd4:	0a783830 	.word	0x0a783830
 8027cd8:	00000000 	.word	0x00000000
 8027cdc:	3a333072 	.word	0x3a333072
 8027ce0:	25783020 	.word	0x25783020
 8027ce4:	0a783830 	.word	0x0a783830
 8027ce8:	00000000 	.word	0x00000000
 8027cec:	3a323072 	.word	0x3a323072
 8027cf0:	25783020 	.word	0x25783020
 8027cf4:	0a783830 	.word	0x0a783830
 8027cf8:	00000000 	.word	0x00000000
 8027cfc:	3a313072 	.word	0x3a313072
 8027d00:	25783020 	.word	0x25783020
 8027d04:	0a783830 	.word	0x0a783830
 8027d08:	00000000 	.word	0x00000000
 8027d0c:	3a303072 	.word	0x3a303072
 8027d10:	25783020 	.word	0x25783020
 8027d14:	0a783830 	.word	0x0a783830
 8027d18:	00000000 	.word	0x00000000
 8027d1c:	64726168 	.word	0x64726168
 8027d20:	75616620 	.word	0x75616620
 8027d24:	6f20746c 	.word	0x6f20746c
 8027d28:	6874206e 	.word	0x6874206e
 8027d2c:	64616572 	.word	0x64616572
 8027d30:	7325203a 	.word	0x7325203a
 8027d34:	0000000a 	.word	0x0000000a
 8027d38:	74756873 	.word	0x74756873
 8027d3c:	6e776f64 	.word	0x6e776f64
 8027d40:	0a2e2e2e 	.word	0x0a2e2e2e
 8027d44:	00000000 	.word	0x00000000
 8027d48:	00000030 	.word	0x00000030
 8027d4c:	00637472 	.word	0x00637472
 8027d50:	656d6974 	.word	0x656d6974
 8027d54:	203d2120 	.word	0x203d2120
 8027d58:	4e5f5452 	.word	0x4e5f5452
 8027d5c:	004c4c55 	.word	0x004c4c55
 8027d60:	00716d70 	.word	0x00716d70
 8027d64:	6d657370 	.word	0x6d657370
 8027d68:	00000000 	.word	0x00000000
 8027d6c:	6d657370 	.word	0x6d657370
 8027d70:	64323025 	.word	0x64323025
 8027d74:	00000000 	.word	0x00000000
 8027d78:	48544150 	.word	0x48544150
 8027d7c:	69622f3d 	.word	0x69622f3d
 8027d80:	0000006e 	.word	0x0000006e
 8027d84:	454d4f48 	.word	0x454d4f48
 8027d88:	6f682f3d 	.word	0x6f682f3d
 8027d8c:	0000656d 	.word	0x0000656d
 8027d90:	706d6f63 	.word	0x706d6f63
 8027d94:	6974656c 	.word	0x6974656c
 8027d98:	21206e6f 	.word	0x21206e6f
 8027d9c:	5452203d 	.word	0x5452203d
 8027da0:	4c554e5f 	.word	0x4c554e5f
 8027da4:	0000004c 	.word	0x0000004c
 8027da8:	6c5f7472 	.word	0x6c5f7472
 8027dac:	5f747369 	.word	0x5f747369
 8027db0:	6d657369 	.word	0x6d657369
 8027db4:	28797470 	.word	0x28797470
 8027db8:	6f632826 	.word	0x6f632826
 8027dbc:	656c706d 	.word	0x656c706d
 8027dc0:	6e6f6974 	.word	0x6e6f6974
 8027dc4:	75733e2d 	.word	0x75733e2d
 8027dc8:	6e657073 	.word	0x6e657073
 8027dcc:	5f646564 	.word	0x5f646564
 8027dd0:	7473696c 	.word	0x7473696c
 8027dd4:	00002929 	.word	0x00002929
 8027dd8:	636e7546 	.word	0x636e7546
 8027ddc:	6e6f6974 	.word	0x6e6f6974
 8027de0:	5d73255b 	.word	0x5d73255b
 8027de4:	61687320 	.word	0x61687320
 8027de8:	6e206c6c 	.word	0x6e206c6c
 8027dec:	7520746f 	.word	0x7520746f
 8027df0:	20646573 	.word	0x20646573
 8027df4:	49206e69 	.word	0x49206e69
 8027df8:	000a5253 	.word	0x000a5253
 8027dfc:	00000030 	.word	0x00000030
 8027e00:	75657571 	.word	0x75657571
 8027e04:	3d212065 	.word	0x3d212065
 8027e08:	5f545220 	.word	0x5f545220
 8027e0c:	4c4c554e 	.word	0x4c4c554e
 8027e10:	00000000 	.word	0x00000000
 8027e14:	636e7546 	.word	0x636e7546
 8027e18:	6e6f6974 	.word	0x6e6f6974
 8027e1c:	5d73255b 	.word	0x5d73255b
 8027e20:	61687320 	.word	0x61687320
 8027e24:	6e206c6c 	.word	0x6e206c6c
 8027e28:	7520746f 	.word	0x7520746f
 8027e2c:	20646573 	.word	0x20646573
 8027e30:	49206e69 	.word	0x49206e69
 8027e34:	000a5253 	.word	0x000a5253
 8027e38:	00000030 	.word	0x00000030
 8027e3c:	61746164 	.word	0x61746164
 8027e40:	7274705f 	.word	0x7274705f
 8027e44:	203d2120 	.word	0x203d2120
 8027e48:	4e5f5452 	.word	0x4e5f5452
 8027e4c:	004c4c55 	.word	0x004c4c55
 8027e50:	657a6973 	.word	0x657a6973
 8027e54:	203d2120 	.word	0x203d2120
 8027e58:	4e5f5452 	.word	0x4e5f5452
 8027e5c:	004c4c55 	.word	0x004c4c55
 8027e60:	20766564 	.word	0x20766564
 8027e64:	52203d21 	.word	0x52203d21
 8027e68:	554e5f54 	.word	0x554e5f54
 8027e6c:	00004c4c 	.word	0x00004c4c
 8027e70:	78363025 	.word	0x78363025
 8027e74:	0000203a 	.word	0x0000203a
 8027e78:	78323025 	.word	0x78323025
 8027e7c:	00000020 	.word	0x00000020
 8027e80:	00202020 	.word	0x00202020
 8027e84:	00000020 	.word	0x00000020
 8027e88:	00006325 	.word	0x00006325
 8027e8c:	0000000a 	.word	0x0000000a
 8027e90:	6e206f6e 	.word	0x6e206f6e
 8027e94:	20646e61 	.word	0x20646e61
 8027e98:	69766564 	.word	0x69766564
 8027e9c:	66206563 	.word	0x66206563
 8027ea0:	646e756f 	.word	0x646e756f
 8027ea4:	00000a21 	.word	0x00000a21
 8027ea8:	2074756f 	.word	0x2074756f
 8027eac:	6d20666f 	.word	0x6d20666f
 8027eb0:	726f6d65 	.word	0x726f6d65
 8027eb4:	000a2179 	.word	0x000a2179
 8027eb8:	64616572 	.word	0x64616572
 8027ebc:	67617020 	.word	0x67617020
 8027ec0:	72202c65 	.word	0x72202c65
 8027ec4:	64253d63 	.word	0x64253d63
 8027ec8:	0000000a 	.word	0x0000000a
 8027ecc:	74697277 	.word	0x74697277
 8027ed0:	61702065 	.word	0x61702065
 8027ed4:	66206567 	.word	0x66206567
 8027ed8:	656c6961 	.word	0x656c6961
 8027edc:	202c2164 	.word	0x202c2164
 8027ee0:	253d6372 	.word	0x253d6372
 8027ee4:	00000a64 	.word	0x00000a64
 8027ee8:	00637472 	.word	0x00637472
 8027eec:	000a7325 	.word	0x000a7325
 8027ef0:	69726573 	.word	0x69726573
 8027ef4:	21206c61 	.word	0x21206c61
 8027ef8:	5452203d 	.word	0x5452203d
 8027efc:	4c554e5f 	.word	0x4c554e5f
 8027f00:	0000004c 	.word	0x0000004c
 8027f04:	665f7872 	.word	0x665f7872
 8027f08:	206f6669 	.word	0x206f6669
 8027f0c:	52203d21 	.word	0x52203d21
 8027f10:	554e5f54 	.word	0x554e5f54
 8027f14:	00004c4c 	.word	0x00004c4c
 8027f18:	21207874 	.word	0x21207874
 8027f1c:	5452203d 	.word	0x5452203d
 8027f20:	4c554e5f 	.word	0x4c554e5f
 8027f24:	0000004c 	.word	0x0000004c
 8027f28:	72657328 	.word	0x72657328
 8027f2c:	206c6169 	.word	0x206c6169
 8027f30:	52203d21 	.word	0x52203d21
 8027f34:	554e5f54 	.word	0x554e5f54
 8027f38:	20294c4c 	.word	0x20294c4c
 8027f3c:	28202626 	.word	0x28202626
 8027f40:	61746164 	.word	0x61746164
 8027f44:	203d2120 	.word	0x203d2120
 8027f48:	4e5f5452 	.word	0x4e5f5452
 8027f4c:	294c4c55 	.word	0x294c4c55
 8027f50:	00000000 	.word	0x00000000
 8027f54:	645f7872 	.word	0x645f7872
 8027f58:	2120616d 	.word	0x2120616d
 8027f5c:	5452203d 	.word	0x5452203d
 8027f60:	4c554e5f 	.word	0x4c554e5f
 8027f64:	0000004c 	.word	0x0000004c
 8027f68:	20766564 	.word	0x20766564
 8027f6c:	52203d21 	.word	0x52203d21
 8027f70:	554e5f54 	.word	0x554e5f54
 8027f74:	00004c4c 	.word	0x00004c4c
 8027f78:	0a0d7825 	.word	0x0a0d7825
 8027f7c:	00000000 	.word	0x00000000
 8027f80:	645f7874 	.word	0x645f7874
 8027f84:	2120616d 	.word	0x2120616d
 8027f88:	5452203d 	.word	0x5452203d
 8027f8c:	4c554e5f 	.word	0x4c554e5f
 8027f90:	0000004c 	.word	0x0000004c
 8027f94:	665f7874 	.word	0x665f7874
 8027f98:	206f6669 	.word	0x206f6669
 8027f9c:	52203d21 	.word	0x52203d21
 8027fa0:	554e5f54 	.word	0x554e5f54
 8027fa4:	00004c4c 	.word	0x00004c4c
 8027fa8:	69726573 	.word	0x69726573
 8027fac:	3e2d6c61 	.word	0x3e2d6c61
 8027fb0:	65726170 	.word	0x65726170
 8027fb4:	6f2e746e 	.word	0x6f2e746e
 8027fb8:	5f6e6570 	.word	0x5f6e6570
 8027fbc:	67616c66 	.word	0x67616c66
 8027fc0:	52202620 	.word	0x52202620
 8027fc4:	45445f54 	.word	0x45445f54
 8027fc8:	45434956 	.word	0x45434956
 8027fcc:	414c465f 	.word	0x414c465f
 8027fd0:	4e495f47 	.word	0x4e495f47
 8027fd4:	58525f54 	.word	0x58525f54
 8027fd8:	00000000 	.word	0x00000000
 8027fdc:	20766564 	.word	0x20766564
 8027fe0:	52203d21 	.word	0x52203d21
 8027fe4:	554e5f54 	.word	0x554e5f54
 8027fe8:	00004c4c 	.word	0x00004c4c
 8027fec:	206e6163 	.word	0x206e6163
 8027ff0:	52203d21 	.word	0x52203d21
 8027ff4:	554e5f54 	.word	0x554e5f54
 8027ff8:	00004c4c 	.word	0x00004c4c
 8027ffc:	665f7872 	.word	0x665f7872
 8028000:	206f6669 	.word	0x206f6669
 8028004:	52203d21 	.word	0x52203d21
 8028008:	554e5f54 	.word	0x554e5f54
 802800c:	00004c4c 	.word	0x00004c4c
 8028010:	665f7872 	.word	0x665f7872
 8028014:	2d6f6669 	.word	0x2d6f6669
 8028018:	6572663e 	.word	0x6572663e
 802801c:	6d756e65 	.word	0x6d756e65
 8028020:	73726562 	.word	0x73726562
 8028024:	203d3c20 	.word	0x203d3c20
 8028028:	2d6e6163 	.word	0x2d6e6163
 802802c:	6e6f633e 	.word	0x6e6f633e
 8028030:	2e676966 	.word	0x2e676966
 8028034:	6267736d 	.word	0x6267736d
 8028038:	7a73786f 	.word	0x7a73786f
 802803c:	00000000 	.word	0x00000000
 8028040:	665f7874 	.word	0x665f7874
 8028044:	206f6669 	.word	0x206f6669
 8028048:	52203d21 	.word	0x52203d21
 802804c:	554e5f54 	.word	0x554e5f54
 8028050:	00004c4c 	.word	0x00004c4c
 8028054:	745f7874 	.word	0x745f7874
 8028058:	646e736f 	.word	0x646e736f
 802805c:	203d2120 	.word	0x203d2120
 8028060:	4e5f5452 	.word	0x4e5f5452
 8028064:	004c4c55 	.word	0x004c4c55
 8028068:	006e6163 	.word	0x006e6163
 802806c:	2d6e6163 	.word	0x2d6e6163
 8028070:	7261703e 	.word	0x7261703e
 8028074:	2e746e65 	.word	0x2e746e65
 8028078:	6e65706f 	.word	0x6e65706f
 802807c:	616c665f 	.word	0x616c665f
 8028080:	20262067 	.word	0x20262067
 8028084:	445f5452 	.word	0x445f5452
 8028088:	43495645 	.word	0x43495645
 802808c:	4c465f45 	.word	0x4c465f45
 8028090:	495f4741 	.word	0x495f4741
 8028094:	525f544e 	.word	0x525f544e
 8028098:	00000058 	.word	0x00000058
 802809c:	665f7872 	.word	0x665f7872
 80280a0:	2d6f6669 	.word	0x2d6f6669
 80280a4:	6572663e 	.word	0x6572663e
 80280a8:	6d756e65 	.word	0x6d756e65
 80280ac:	73726562 	.word	0x73726562
 80280b0:	30203e20 	.word	0x30203e20
 80280b4:	00000000 	.word	0x00000000
 80280b8:	6e614320 	.word	0x6e614320
 80280bc:	66207427 	.word	0x66207427
 80280c0:	20646e69 	.word	0x20646e69
 80280c4:	206e6163 	.word	0x206e6163
 80280c8:	69766564 	.word	0x69766564
 80280cc:	25206563 	.word	0x25206563
 80280d0:	00000a73 	.word	0x00000a73
 80280d4:	6e694620 	.word	0x6e694620
 80280d8:	20646564 	.word	0x20646564
 80280dc:	206e6163 	.word	0x206e6163
 80280e0:	69766564 	.word	0x69766564
 80280e4:	203a6563 	.word	0x203a6563
 80280e8:	2e2e7325 	.word	0x2e2e7325
 80280ec:	0000002e 	.word	0x0000002e
 80280f0:	6552200a 	.word	0x6552200a
 80280f4:	76696563 	.word	0x76696563
 80280f8:	2e2e2e65 	.word	0x2e2e2e65
 80280fc:	6f727265 	.word	0x6f727265
 8028100:	632e2e72 	.word	0x632e2e72
 8028104:	746e756f 	.word	0x746e756f
 8028108:	3025203a 	.word	0x3025203a
 802810c:	646c3031 	.word	0x646c3031
 8028110:	6553202e 	.word	0x6553202e
 8028114:	2e2e646e 	.word	0x2e2e646e
 8028118:	652e2e2e 	.word	0x652e2e2e
 802811c:	726f7272 	.word	0x726f7272
 8028120:	2e2e2e2e 	.word	0x2e2e2e2e
 8028124:	6e756f63 	.word	0x6e756f63
 8028128:	25203a74 	.word	0x25203a74
 802812c:	6c303130 	.word	0x6c303130
 8028130:	00002e64 	.word	0x00002e64
 8028134:	6942200a 	.word	0x6942200a
 8028138:	702e2e74 	.word	0x702e2e74
 802813c:	2e2e6461 	.word	0x2e2e6461
 8028140:	6f727265 	.word	0x6f727265
 8028144:	632e2e72 	.word	0x632e2e72
 8028148:	746e756f 	.word	0x746e756f
 802814c:	3025203a 	.word	0x3025203a
 8028150:	646c3031 	.word	0x646c3031
 8028154:	6f46202e 	.word	0x6f46202e
 8028158:	74616d72 	.word	0x74616d72
 802815c:	652e2e2e 	.word	0x652e2e2e
 8028160:	726f7272 	.word	0x726f7272
 8028164:	2e2e2e2e 	.word	0x2e2e2e2e
 8028168:	6e756f63 	.word	0x6e756f63
 802816c:	25203a74 	.word	0x25203a74
 8028170:	6c303130 	.word	0x6c303130
 8028174:	00000064 	.word	0x00000064
 8028178:	6341200a 	.word	0x6341200a
 802817c:	2e2e2e6b 	.word	0x2e2e2e6b
 8028180:	2e2e2e2e 	.word	0x2e2e2e2e
 8028184:	6f727265 	.word	0x6f727265
 8028188:	632e2e72 	.word	0x632e2e72
 802818c:	746e756f 	.word	0x746e756f
 8028190:	3025203a 	.word	0x3025203a
 8028194:	646c3031 	.word	0x646c3031
 8028198:	6942202e 	.word	0x6942202e
 802819c:	2e2e2e74 	.word	0x2e2e2e74
 80281a0:	652e2e2e 	.word	0x652e2e2e
 80281a4:	726f7272 	.word	0x726f7272
 80281a8:	2e2e2e2e 	.word	0x2e2e2e2e
 80281ac:	6e756f63 	.word	0x6e756f63
 80281b0:	25203a74 	.word	0x25203a74
 80281b4:	6c303130 	.word	0x6c303130
 80281b8:	00002e64 	.word	0x00002e64
 80281bc:	5243200a 	.word	0x5243200a
 80281c0:	2e2e2e43 	.word	0x2e2e2e43
 80281c4:	2e2e2e2e 	.word	0x2e2e2e2e
 80281c8:	6f727265 	.word	0x6f727265
 80281cc:	632e2e72 	.word	0x632e2e72
 80281d0:	746e756f 	.word	0x746e756f
 80281d4:	3025203a 	.word	0x3025203a
 80281d8:	646c3031 	.word	0x646c3031
 80281dc:	7245202e 	.word	0x7245202e
 80281e0:	2e726f72 	.word	0x2e726f72
 80281e4:	65646f63 	.word	0x65646f63
 80281e8:	30255b2e 	.word	0x30255b2e
 80281ec:	646c3031 	.word	0x646c3031
 80281f0:	00203a5d 	.word	0x00203a5d
 80281f4:	002e7325 	.word	0x002e7325
 80281f8:	6f54200a 	.word	0x6f54200a
 80281fc:	2e6c6174 	.word	0x2e6c6174
 8028200:	65636572 	.word	0x65636572
 8028204:	2e657669 	.word	0x2e657669
 8028208:	6b636170 	.word	0x6b636170
 802820c:	73656761 	.word	0x73656761
 8028210:	3025203a 	.word	0x3025203a
 8028214:	646c3031 	.word	0x646c3031
 8028218:	7244202e 	.word	0x7244202e
 802821c:	6465706f 	.word	0x6465706f
 8028220:	6365722e 	.word	0x6365722e
 8028224:	65766965 	.word	0x65766965
 8028228:	6361702e 	.word	0x6361702e
 802822c:	6567616b 	.word	0x6567616b
 8028230:	25203a73 	.word	0x25203a73
 8028234:	6c303130 	.word	0x6c303130
 8028238:	00002e64 	.word	0x00002e64
 802823c:	6f54200a 	.word	0x6f54200a
 8028240:	2e6c6174 	.word	0x2e6c6174
 8028244:	6e65732e 	.word	0x6e65732e
 8028248:	2e2e2e64 	.word	0x2e2e2e64
 802824c:	6b636170 	.word	0x6b636170
 8028250:	73656761 	.word	0x73656761
 8028254:	3025203a 	.word	0x3025203a
 8028258:	646c3031 	.word	0x646c3031
 802825c:	7244202e 	.word	0x7244202e
 8028260:	6465706f 	.word	0x6465706f
 8028264:	732e2e2e 	.word	0x732e2e2e
 8028268:	2e646e65 	.word	0x2e646e65
 802826c:	6361702e 	.word	0x6361702e
 8028270:	6567616b 	.word	0x6567616b
 8028274:	25203a73 	.word	0x25203a73
 8028278:	6c303130 	.word	0x6c303130
 802827c:	000a2e64 	.word	0x000a2e64
 8028280:	766e4920 	.word	0x766e4920
 8028284:	64696c61 	.word	0x64696c61
 8028288:	6c614320 	.word	0x6c614320
 802828c:	7325206c 	.word	0x7325206c
 8028290:	0000000a 	.word	0x0000000a
 8028294:	656c5020 	.word	0x656c5020
 8028298:	20657361 	.word	0x20657361
 802829c:	6e697375 	.word	0x6e697375
 80282a0:	73252067 	.word	0x73252067
 80282a4:	6e616320 	.word	0x6e616320
 80282a8:	656d616e 	.word	0x656d616e
 80282ac:	482e2078 	.word	0x482e2078
 80282b0:	20657265 	.word	0x20657265
 80282b4:	6e6e6163 	.word	0x6e6e6163
 80282b8:	20656d61 	.word	0x20656d61
 80282bc:	64207369 	.word	0x64207369
 80282c0:	65766972 	.word	0x65766972
 80282c4:	616e2072 	.word	0x616e2072
 80282c8:	6120656d 	.word	0x6120656d
 80282cc:	7820646e 	.word	0x7820646e
 80282d0:	20736920 	.word	0x20736920
 80282d4:	646e6163 	.word	0x646e6163
 80282d8:	65766972 	.word	0x65766972
 80282dc:	6d756e20 	.word	0x6d756e20
 80282e0:	2e726562 	.word	0x2e726562
 80282e4:	0000000a 	.word	0x0000000a
 80282e8:	45206f4e 	.word	0x45206f4e
 80282ec:	726f7272 	.word	0x726f7272
 80282f0:	00000021 	.word	0x00000021
 80282f4:	6e726157 	.word	0x6e726157
 80282f8:	20676e69 	.word	0x20676e69
 80282fc:	00000021 	.word	0x00000021
 8028300:	73736150 	.word	0x73736150
 8028304:	20657669 	.word	0x20657669
 8028308:	00000021 	.word	0x00000021
 802830c:	20737542 	.word	0x20737542
 8028310:	2066664f 	.word	0x2066664f
 8028314:	00000021 	.word	0x00000021
 8028318:	2068736d 	.word	0x2068736d
 802831c:	00000000 	.word	0x00000000
 8028320:	736e6966 	.word	0x736e6966
 8028324:	00002068 	.word	0x00002068
 8028328:	0000003e 	.word	0x0000003e
 802832c:	6c656873 	.word	0x6c656873
 8028330:	3d21206c 	.word	0x3d21206c
 8028334:	5f545220 	.word	0x5f545220
 8028338:	4c4c554e 	.word	0x4c4c554e
 802833c:	00000000 	.word	0x00000000
 8028340:	736e6966 	.word	0x736e6966
 8028344:	63203a68 	.word	0x63203a68
 8028348:	6e206e61 	.word	0x6e206e61
 802834c:	6620746f 	.word	0x6620746f
 8028350:	20646e69 	.word	0x20646e69
 8028354:	69766564 	.word	0x69766564
 8028358:	203a6563 	.word	0x203a6563
 802835c:	000a7325 	.word	0x000a7325
 8028360:	0000000a 	.word	0x0000000a
 8028364:	73257325 	.word	0x73257325
 8028368:	00000000 	.word	0x00000000
 802836c:	000a7325 	.word	0x000a7325
 8028370:	63252709 	.word	0x63252709
 8028374:	25202c27 	.word	0x25202c27
 8028378:	30202c64 	.word	0x30202c64
 802837c:	38302578 	.word	0x38302578
 8028380:	00000a78 	.word	0x00000a78
 8028384:	2c642509 	.word	0x2c642509
 8028388:	25783020 	.word	0x25783020
 802838c:	0a783830 	.word	0x0a783830
 8028390:	00000000 	.word	0x00000000
 8028394:	4b325b1b 	.word	0x4b325b1b
 8028398:	0000000d 	.word	0x0000000d
 802839c:	6c656873 	.word	0x6c656873
 80283a0:	643e2d6c 	.word	0x643e2d6c
 80283a4:	63697665 	.word	0x63697665
 80283a8:	00000065 	.word	0x00000065
 80283ac:	00000008 	.word	0x00000008
 80283b0:	00006325 	.word	0x00006325
 80283b4:	20732508 	.word	0x20732508
 80283b8:	00000820 	.word	0x00000820
 80283bc:	00082008 	.word	0x00082008
 80283c0:	00007325 	.word	0x00007325
 80283c4:	6d206f6e 	.word	0x6d206f6e
 80283c8:	726f6d65 	.word	0x726f6d65
 80283cc:	6f662079 	.word	0x6f662079
 80283d0:	68732072 	.word	0x68732072
 80283d4:	0a6c6c65 	.word	0x0a6c6c65
 80283d8:	00000000 	.word	0x00000000
 80283dc:	78726873 	.word	0x78726873
 80283e0:	00000000 	.word	0x00000000
 80283e4:	65687374 	.word	0x65687374
 80283e8:	00006c6c 	.word	0x00006c6c
 80283ec:	6c6c6548 	.word	0x6c6c6548
 80283f0:	5452206f 	.word	0x5452206f
 80283f4:	7268542d 	.word	0x7268542d
 80283f8:	21646165 	.word	0x21646165
 80283fc:	0000000a 	.word	0x0000000a
 8028400:	72687420 	.word	0x72687420
 8028404:	20646165 	.word	0x20646165
 8028408:	69727020 	.word	0x69727020
 802840c:	74732020 	.word	0x74732020
 8028410:	73757461 	.word	0x73757461
 8028414:	20202020 	.word	0x20202020
 8028418:	70732020 	.word	0x70732020
 802841c:	20202020 	.word	0x20202020
 8028420:	61747320 	.word	0x61747320
 8028424:	73206b63 	.word	0x73206b63
 8028428:	20657a69 	.word	0x20657a69
 802842c:	2078616d 	.word	0x2078616d
 8028430:	64657375 	.word	0x64657375
 8028434:	6c202020 	.word	0x6c202020
 8028438:	20746665 	.word	0x20746665
 802843c:	6b636974 	.word	0x6b636974
 8028440:	72652020 	.word	0x72652020
 8028444:	0a726f72 	.word	0x0a726f72
 8028448:	00000000 	.word	0x00000000
 802844c:	2d2d2d2d 	.word	0x2d2d2d2d
 8028450:	2d2d2d2d 	.word	0x2d2d2d2d
 8028454:	2d2d2d20 	.word	0x2d2d2d20
 8028458:	2d2d202d 	.word	0x2d2d202d
 802845c:	2d2d2d2d 	.word	0x2d2d2d2d
 8028460:	2d2d202d 	.word	0x2d2d202d
 8028464:	2d2d2d2d 	.word	0x2d2d2d2d
 8028468:	2d2d2d2d 	.word	0x2d2d2d2d
 802846c:	2d2d2d20 	.word	0x2d2d2d20
 8028470:	2d2d2d2d 	.word	0x2d2d2d2d
 8028474:	202d2d2d 	.word	0x202d2d2d
 8028478:	2d2d2d2d 	.word	0x2d2d2d2d
 802847c:	2d2d2d2d 	.word	0x2d2d2d2d
 8028480:	2d202d2d 	.word	0x2d202d2d
 8028484:	2d2d2d2d 	.word	0x2d2d2d2d
 8028488:	2d2d2d2d 	.word	0x2d2d2d2d
 802848c:	2d2d202d 	.word	0x2d2d202d
 8028490:	00000a2d 	.word	0x00000a2d
 8028494:	2e382d25 	.word	0x2e382d25
 8028498:	3020732a 	.word	0x3020732a
 802849c:	32302578 	.word	0x32302578
 80284a0:	00000078 	.word	0x00000078
 80284a4:	61657220 	.word	0x61657220
 80284a8:	20207964 	.word	0x20207964
 80284ac:	00000000 	.word	0x00000000
 80284b0:	73757320 	.word	0x73757320
 80284b4:	646e6570 	.word	0x646e6570
 80284b8:	00000000 	.word	0x00000000
 80284bc:	696e6920 	.word	0x696e6920
 80284c0:	20202074 	.word	0x20202074
 80284c4:	00000000 	.word	0x00000000
 80284c8:	6f6c6320 	.word	0x6f6c6320
 80284cc:	20206573 	.word	0x20206573
 80284d0:	00000000 	.word	0x00000000
 80284d4:	25783020 	.word	0x25783020
 80284d8:	20783830 	.word	0x20783830
 80284dc:	30257830 	.word	0x30257830
 80284e0:	30207838 	.word	0x30207838
 80284e4:	38302578 	.word	0x38302578
 80284e8:	78302078 	.word	0x78302078
 80284ec:	78383025 	.word	0x78383025
 80284f0:	33302520 	.word	0x33302520
 80284f4:	00000a64 	.word	0x00000a64
 80284f8:	00007325 	.word	0x00007325
 80284fc:	0000002f 	.word	0x0000002f
 8028500:	616d6573 	.word	0x616d6573
 8028504:	726f6870 	.word	0x726f6870
 8028508:	20762065 	.word	0x20762065
 802850c:	75732020 	.word	0x75732020
 8028510:	6e657073 	.word	0x6e657073
 8028514:	68742064 	.word	0x68742064
 8028518:	64616572 	.word	0x64616572
 802851c:	0000000a 	.word	0x0000000a
 8028520:	2d2d2d2d 	.word	0x2d2d2d2d
 8028524:	2d2d2d2d 	.word	0x2d2d2d2d
 8028528:	2d2d2020 	.word	0x2d2d2020
 802852c:	2d2d202d 	.word	0x2d2d202d
 8028530:	2d2d2d2d 	.word	0x2d2d2d2d
 8028534:	2d2d2d2d 	.word	0x2d2d2d2d
 8028538:	2d2d2d2d 	.word	0x2d2d2d2d
 802853c:	0000000a 	.word	0x0000000a
 8028540:	2e382d25 	.word	0x2e382d25
 8028544:	2020732a 	.word	0x2020732a
 8028548:	64333025 	.word	0x64333025
 802854c:	3a642520 	.word	0x3a642520
 8028550:	00000000 	.word	0x00000000
 8028554:	0000000a 	.word	0x0000000a
 8028558:	2e382d25 	.word	0x2e382d25
 802855c:	2020732a 	.word	0x2020732a
 8028560:	64333025 	.word	0x64333025
 8028564:	0a642520 	.word	0x0a642520
 8028568:	00000000 	.word	0x00000000
 802856c:	6e657665 	.word	0x6e657665
 8028570:	20202074 	.word	0x20202074
 8028574:	74657320 	.word	0x74657320
 8028578:	20202020 	.word	0x20202020
 802857c:	20202020 	.word	0x20202020
 8028580:	70737573 	.word	0x70737573
 8028584:	20646e65 	.word	0x20646e65
 8028588:	65726874 	.word	0x65726874
 802858c:	000a6461 	.word	0x000a6461
 8028590:	2d2d2d2d 	.word	0x2d2d2d2d
 8028594:	2d2d2d2d 	.word	0x2d2d2d2d
 8028598:	2d2d2d20 	.word	0x2d2d2d20
 802859c:	2d2d2d2d 	.word	0x2d2d2d2d
 80285a0:	202d2d2d 	.word	0x202d2d2d
 80285a4:	2d2d2d2d 	.word	0x2d2d2d2d
 80285a8:	2d2d2d2d 	.word	0x2d2d2d2d
 80285ac:	2d2d2d2d 	.word	0x2d2d2d2d
 80285b0:	000a2d2d 	.word	0x000a2d2d
 80285b4:	2e382d25 	.word	0x2e382d25
 80285b8:	2020732a 	.word	0x2020732a
 80285bc:	30257830 	.word	0x30257830
 80285c0:	25207838 	.word	0x25207838
 80285c4:	3a643330 	.word	0x3a643330
 80285c8:	00000000 	.word	0x00000000
 80285cc:	2e382d25 	.word	0x2e382d25
 80285d0:	2020732a 	.word	0x2020732a
 80285d4:	30257830 	.word	0x30257830
 80285d8:	30207838 	.word	0x30207838
 80285dc:	0000000a 	.word	0x0000000a
 80285e0:	6574756d 	.word	0x6574756d
 80285e4:	20202078 	.word	0x20202078
 80285e8:	6e776f20 	.word	0x6e776f20
 80285ec:	20207265 	.word	0x20207265
 80285f0:	6f682020 	.word	0x6f682020
 80285f4:	7320646c 	.word	0x7320646c
 80285f8:	65707375 	.word	0x65707375
 80285fc:	7420646e 	.word	0x7420646e
 8028600:	61657268 	.word	0x61657268
 8028604:	00000a64 	.word	0x00000a64
 8028608:	2d2d2d2d 	.word	0x2d2d2d2d
 802860c:	2d2d2d2d 	.word	0x2d2d2d2d
 8028610:	2d2d2d20 	.word	0x2d2d2d20
 8028614:	2d2d2d2d 	.word	0x2d2d2d2d
 8028618:	2d2d202d 	.word	0x2d2d202d
 802861c:	2d202d2d 	.word	0x2d202d2d
 8028620:	2d2d2d2d 	.word	0x2d2d2d2d
 8028624:	2d2d2d2d 	.word	0x2d2d2d2d
 8028628:	2d2d2d2d 	.word	0x2d2d2d2d
 802862c:	00000a2d 	.word	0x00000a2d
 8028630:	2e382d25 	.word	0x2e382d25
 8028634:	2520732a 	.word	0x2520732a
 8028638:	2a2e382d 	.word	0x2a2e382d
 802863c:	30252073 	.word	0x30252073
 8028640:	25206434 	.word	0x25206434
 8028644:	00000a64 	.word	0x00000a64
 8028648:	6c69616d 	.word	0x6c69616d
 802864c:	20786f62 	.word	0x20786f62
 8028650:	746e6520 	.word	0x746e6520
 8028654:	73207972 	.word	0x73207972
 8028658:	20657a69 	.word	0x20657a69
 802865c:	70737573 	.word	0x70737573
 8028660:	20646e65 	.word	0x20646e65
 8028664:	65726874 	.word	0x65726874
 8028668:	000a6461 	.word	0x000a6461
 802866c:	2d2d2d2d 	.word	0x2d2d2d2d
 8028670:	2d2d2d2d 	.word	0x2d2d2d2d
 8028674:	2d2d2d20 	.word	0x2d2d2d20
 8028678:	2d20202d 	.word	0x2d20202d
 802867c:	202d2d2d 	.word	0x202d2d2d
 8028680:	2d2d2d2d 	.word	0x2d2d2d2d
 8028684:	2d2d2d2d 	.word	0x2d2d2d2d
 8028688:	2d2d2d2d 	.word	0x2d2d2d2d
 802868c:	000a2d2d 	.word	0x000a2d2d
 8028690:	2e382d25 	.word	0x2e382d25
 8028694:	2520732a 	.word	0x2520732a
 8028698:	20643430 	.word	0x20643430
 802869c:	34302520 	.word	0x34302520
 80286a0:	64252064 	.word	0x64252064
 80286a4:	0000003a 	.word	0x0000003a
 80286a8:	2e382d25 	.word	0x2e382d25
 80286ac:	2520732a 	.word	0x2520732a
 80286b0:	20643430 	.word	0x20643430
 80286b4:	34302520 	.word	0x34302520
 80286b8:	64252064 	.word	0x64252064
 80286bc:	0000000a 	.word	0x0000000a
 80286c0:	7167736d 	.word	0x7167736d
 80286c4:	65756575 	.word	0x65756575
 80286c8:	746e6520 	.word	0x746e6520
 80286cc:	73207972 	.word	0x73207972
 80286d0:	65707375 	.word	0x65707375
 80286d4:	7420646e 	.word	0x7420646e
 80286d8:	61657268 	.word	0x61657268
 80286dc:	00000a64 	.word	0x00000a64
 80286e0:	2d2d2d2d 	.word	0x2d2d2d2d
 80286e4:	2d2d2d2d 	.word	0x2d2d2d2d
 80286e8:	2d2d2d20 	.word	0x2d2d2d20
 80286ec:	2d20202d 	.word	0x2d20202d
 80286f0:	2d2d2d2d 	.word	0x2d2d2d2d
 80286f4:	2d2d2d2d 	.word	0x2d2d2d2d
 80286f8:	2d2d2d2d 	.word	0x2d2d2d2d
 80286fc:	00000a2d 	.word	0x00000a2d
 8028700:	2e382d25 	.word	0x2e382d25
 8028704:	2520732a 	.word	0x2520732a
 8028708:	20643430 	.word	0x20643430
 802870c:	3a642520 	.word	0x3a642520
 8028710:	00000000 	.word	0x00000000
 8028714:	2e382d25 	.word	0x2e382d25
 8028718:	2520732a 	.word	0x2520732a
 802871c:	20643430 	.word	0x20643430
 8028720:	0a642520 	.word	0x0a642520
 8028724:	00000000 	.word	0x00000000
 8028728:	686d656d 	.word	0x686d656d
 802872c:	20706165 	.word	0x20706165
 8028730:	6f6f7020 	.word	0x6f6f7020
 8028734:	6973206c 	.word	0x6973206c
 8028738:	2020657a 	.word	0x2020657a
 802873c:	2078616d 	.word	0x2078616d
 8028740:	64657375 	.word	0x64657375
 8028744:	7a697320 	.word	0x7a697320
 8028748:	76612065 	.word	0x76612065
 802874c:	616c6961 	.word	0x616c6961
 8028750:	20656c62 	.word	0x20656c62
 8028754:	657a6973 	.word	0x657a6973
 8028758:	0000000a 	.word	0x0000000a
 802875c:	2d2d2d2d 	.word	0x2d2d2d2d
 8028760:	2d2d2d2d 	.word	0x2d2d2d2d
 8028764:	2d2d2d20 	.word	0x2d2d2d20
 8028768:	2d2d2d2d 	.word	0x2d2d2d2d
 802876c:	202d2d2d 	.word	0x202d2d2d
 8028770:	2d2d2d2d 	.word	0x2d2d2d2d
 8028774:	2d2d2d2d 	.word	0x2d2d2d2d
 8028778:	2d2d2d2d 	.word	0x2d2d2d2d
 802877c:	2d2d202d 	.word	0x2d2d202d
 8028780:	2d2d2d2d 	.word	0x2d2d2d2d
 8028784:	2d2d2d2d 	.word	0x2d2d2d2d
 8028788:	2d2d2d2d 	.word	0x2d2d2d2d
 802878c:	0000000a 	.word	0x0000000a
 8028790:	2e382d25 	.word	0x2e382d25
 8028794:	2520732a 	.word	0x2520732a
 8028798:	3031302d 	.word	0x3031302d
 802879c:	2d252064 	.word	0x2d252064
 80287a0:	64333130 	.word	0x64333130
 80287a4:	302d2520 	.word	0x302d2520
 80287a8:	000a6435 	.word	0x000a6435
 80287ac:	706d656d 	.word	0x706d656d
 80287b0:	206c6f6f 	.word	0x206c6f6f
 80287b4:	6f6c6220 	.word	0x6f6c6220
 80287b8:	74206b63 	.word	0x74206b63
 80287bc:	6c61746f 	.word	0x6c61746f
 80287c0:	65726620 	.word	0x65726620
 80287c4:	75732065 	.word	0x75732065
 80287c8:	6e657073 	.word	0x6e657073
 80287cc:	68742064 	.word	0x68742064
 80287d0:	64616572 	.word	0x64616572
 80287d4:	0000000a 	.word	0x0000000a
 80287d8:	2d2d2d2d 	.word	0x2d2d2d2d
 80287dc:	2d2d2d2d 	.word	0x2d2d2d2d
 80287e0:	2d2d2d20 	.word	0x2d2d2d20
 80287e4:	2d20202d 	.word	0x2d20202d
 80287e8:	202d2d2d 	.word	0x202d2d2d
 80287ec:	2d2d2d20 	.word	0x2d2d2d20
 80287f0:	2d2d202d 	.word	0x2d2d202d
 80287f4:	2d2d2d2d 	.word	0x2d2d2d2d
 80287f8:	2d2d2d2d 	.word	0x2d2d2d2d
 80287fc:	2d2d2d2d 	.word	0x2d2d2d2d
 8028800:	0000000a 	.word	0x0000000a
 8028804:	2e382d25 	.word	0x2e382d25
 8028808:	2520732a 	.word	0x2520732a
 802880c:	20643430 	.word	0x20643430
 8028810:	34302520 	.word	0x34302520
 8028814:	25202064 	.word	0x25202064
 8028818:	20643430 	.word	0x20643430
 802881c:	003a6425 	.word	0x003a6425
 8028820:	2e382d25 	.word	0x2e382d25
 8028824:	2520732a 	.word	0x2520732a
 8028828:	20643430 	.word	0x20643430
 802882c:	34302520 	.word	0x34302520
 8028830:	25202064 	.word	0x25202064
 8028834:	20643430 	.word	0x20643430
 8028838:	000a6425 	.word	0x000a6425
 802883c:	656d6974 	.word	0x656d6974
 8028840:	20202072 	.word	0x20202072
 8028844:	72657020 	.word	0x72657020
 8028848:	69646f69 	.word	0x69646f69
 802884c:	20202063 	.word	0x20202063
 8028850:	656d6974 	.word	0x656d6974
 8028854:	2074756f 	.word	0x2074756f
 8028858:	66202020 	.word	0x66202020
 802885c:	0a67616c 	.word	0x0a67616c
 8028860:	00000000 	.word	0x00000000
 8028864:	2d2d2d2d 	.word	0x2d2d2d2d
 8028868:	2d2d2d2d 	.word	0x2d2d2d2d
 802886c:	2d2d2d20 	.word	0x2d2d2d20
 8028870:	2d2d2d2d 	.word	0x2d2d2d2d
 8028874:	202d2d2d 	.word	0x202d2d2d
 8028878:	2d2d2d2d 	.word	0x2d2d2d2d
 802887c:	2d2d2d2d 	.word	0x2d2d2d2d
 8028880:	2d202d2d 	.word	0x2d202d2d
 8028884:	2d2d2d2d 	.word	0x2d2d2d2d
 8028888:	2d2d2d2d 	.word	0x2d2d2d2d
 802888c:	000a2d2d 	.word	0x000a2d2d
 8028890:	2e382d25 	.word	0x2e382d25
 8028894:	3020732a 	.word	0x3020732a
 8028898:	38302578 	.word	0x38302578
 802889c:	78302078 	.word	0x78302078
 80288a0:	78383025 	.word	0x78383025
 80288a4:	00000020 	.word	0x00000020
 80288a8:	69746361 	.word	0x69746361
 80288ac:	65746176 	.word	0x65746176
 80288b0:	00000a64 	.word	0x00000a64
 80288b4:	63616564 	.word	0x63616564
 80288b8:	61766974 	.word	0x61766974
 80288bc:	0a646574 	.word	0x0a646574
 80288c0:	00000000 	.word	0x00000000
 80288c4:	72727563 	.word	0x72727563
 80288c8:	20746e65 	.word	0x20746e65
 80288cc:	6b636974 	.word	0x6b636974
 80288d0:	2578303a 	.word	0x2578303a
 80288d4:	0a783830 	.word	0x0a783830
 80288d8:	00000000 	.word	0x00000000
 80288dc:	69766564 	.word	0x69766564
 80288e0:	20206563 	.word	0x20206563
 80288e4:	70797420 	.word	0x70797420
 80288e8:	20202065 	.word	0x20202065
 80288ec:	20202020 	.word	0x20202020
 80288f0:	20202020 	.word	0x20202020
 80288f4:	20202020 	.word	0x20202020
 80288f8:	65722020 	.word	0x65722020
 80288fc:	6f632066 	.word	0x6f632066
 8028900:	0a746e75 	.word	0x0a746e75
 8028904:	00000000 	.word	0x00000000
 8028908:	2d2d2d2d 	.word	0x2d2d2d2d
 802890c:	2d2d2d2d 	.word	0x2d2d2d2d
 8028910:	2d2d2d20 	.word	0x2d2d2d20
 8028914:	2d2d2d2d 	.word	0x2d2d2d2d
 8028918:	2d2d2d2d 	.word	0x2d2d2d2d
 802891c:	2d2d2d2d 	.word	0x2d2d2d2d
 8028920:	2d2d2d2d 	.word	0x2d2d2d2d
 8028924:	2d2d202d 	.word	0x2d2d202d
 8028928:	2d2d2d2d 	.word	0x2d2d2d2d
 802892c:	2d2d2d2d 	.word	0x2d2d2d2d
 8028930:	0000000a 	.word	0x0000000a
 8028934:	2e382d25 	.word	0x2e382d25
 8028938:	2520732a 	.word	0x2520732a
 802893c:	7330322d 	.word	0x7330322d
 8028940:	382d2520 	.word	0x382d2520
 8028944:	00000a64 	.word	0x00000a64
 8028948:	72616843 	.word	0x72616843
 802894c:	65746361 	.word	0x65746361
 8028950:	65442072 	.word	0x65442072
 8028954:	65636976 	.word	0x65636976
 8028958:	00000000 	.word	0x00000000
 802895c:	636f6c42 	.word	0x636f6c42
 8028960:	6544206b 	.word	0x6544206b
 8028964:	65636976 	.word	0x65636976
 8028968:	00000000 	.word	0x00000000
 802896c:	7774654e 	.word	0x7774654e
 8028970:	206b726f 	.word	0x206b726f
 8028974:	65746e49 	.word	0x65746e49
 8028978:	63616672 	.word	0x63616672
 802897c:	00000065 	.word	0x00000065
 8028980:	2044544d 	.word	0x2044544d
 8028984:	69766544 	.word	0x69766544
 8028988:	00006563 	.word	0x00006563
 802898c:	204e4143 	.word	0x204e4143
 8028990:	69766544 	.word	0x69766544
 8028994:	00006563 	.word	0x00006563
 8028998:	00435452 	.word	0x00435452
 802899c:	6e756f53 	.word	0x6e756f53
 80289a0:	65442064 	.word	0x65442064
 80289a4:	65636976 	.word	0x65636976
 80289a8:	00000000 	.word	0x00000000
 80289ac:	70617247 	.word	0x70617247
 80289b0:	20636968 	.word	0x20636968
 80289b4:	69766544 	.word	0x69766544
 80289b8:	00006563 	.word	0x00006563
 80289bc:	20433249 	.word	0x20433249
 80289c0:	00737542 	.word	0x00737542
 80289c4:	20425355 	.word	0x20425355
 80289c8:	76616c53 	.word	0x76616c53
 80289cc:	65442065 	.word	0x65442065
 80289d0:	65636976 	.word	0x65636976
 80289d4:	00000000 	.word	0x00000000
 80289d8:	20425355 	.word	0x20425355
 80289dc:	74736f48 	.word	0x74736f48
 80289e0:	73754220 	.word	0x73754220
 80289e4:	00000000 	.word	0x00000000
 80289e8:	20495053 	.word	0x20495053
 80289ec:	00737542 	.word	0x00737542
 80289f0:	20495053 	.word	0x20495053
 80289f4:	69766544 	.word	0x69766544
 80289f8:	00006563 	.word	0x00006563
 80289fc:	4f494453 	.word	0x4f494453
 8028a00:	73754220 	.word	0x73754220
 8028a04:	00000000 	.word	0x00000000
 8028a08:	50204d50 	.word	0x50204d50
 8028a0c:	64756573 	.word	0x64756573
 8028a10:	6544206f 	.word	0x6544206f
 8028a14:	65636976 	.word	0x65636976
 8028a18:	00000000 	.word	0x00000000
 8028a1c:	65706950 	.word	0x65706950
 8028a20:	00000000 	.word	0x00000000
 8028a24:	74726f50 	.word	0x74726f50
 8028a28:	44206c61 	.word	0x44206c61
 8028a2c:	63697665 	.word	0x63697665
 8028a30:	00000065 	.word	0x00000065
 8028a34:	656d6954 	.word	0x656d6954
 8028a38:	65442072 	.word	0x65442072
 8028a3c:	65636976 	.word	0x65636976
 8028a40:	00000000 	.word	0x00000000
 8028a44:	6373694d 	.word	0x6373694d
 8028a48:	616c6c65 	.word	0x616c6c65
 8028a4c:	756f656e 	.word	0x756f656e
 8028a50:	65442073 	.word	0x65442073
 8028a54:	65636976 	.word	0x65636976
 8028a58:	00000000 	.word	0x00000000
 8028a5c:	6e6b6e55 	.word	0x6e6b6e55
 8028a60:	006e776f 	.word	0x006e776f
 8028a64:	08028948 	.word	0x08028948
 8028a68:	0802895c 	.word	0x0802895c
 8028a6c:	0802896c 	.word	0x0802896c
 8028a70:	08028980 	.word	0x08028980
 8028a74:	0802898c 	.word	0x0802898c
 8028a78:	08028998 	.word	0x08028998
 8028a7c:	0802899c 	.word	0x0802899c
 8028a80:	080289ac 	.word	0x080289ac
 8028a84:	080289bc 	.word	0x080289bc
 8028a88:	080289c4 	.word	0x080289c4
 8028a8c:	080289d8 	.word	0x080289d8
 8028a90:	080289e8 	.word	0x080289e8
 8028a94:	080289f0 	.word	0x080289f0
 8028a98:	080289fc 	.word	0x080289fc
 8028a9c:	08028a08 	.word	0x08028a08
 8028aa0:	08028a1c 	.word	0x08028a1c
 8028aa4:	08028a24 	.word	0x08028a24
 8028aa8:	08028a34 	.word	0x08028a34
 8028aac:	08028a44 	.word	0x08028a44
 8028ab0:	08028a5c 	.word	0x08028a5c
 8028ab4:	75462d2d 	.word	0x75462d2d
 8028ab8:	6974636e 	.word	0x6974636e
 8028abc:	4c206e6f 	.word	0x4c206e6f
 8028ac0:	3a747369 	.word	0x3a747369
 8028ac4:	0000000a 	.word	0x0000000a
 8028ac8:	00005f5f 	.word	0x00005f5f
 8028acc:	36312d25 	.word	0x36312d25
 8028ad0:	2d2d2073 	.word	0x2d2d2073
 8028ad4:	0a732520 	.word	0x0a732520
 8028ad8:	00000000 	.word	0x00000000
 8028adc:	205d6c5b 	.word	0x205d6c5b
 8028ae0:	000a7325 	.word	0x000a7325
 8028ae4:	61562d2d 	.word	0x61562d2d
 8028ae8:	62616972 	.word	0x62616972
 8028aec:	4c20656c 	.word	0x4c20656c
 8028af0:	3a747369 	.word	0x3a747369
 8028af4:	0000000a 	.word	0x0000000a
 8028af8:	75662d2d 	.word	0x75662d2d
 8028afc:	6974636e 	.word	0x6974636e
 8028b00:	0a3a6e6f 	.word	0x0a3a6e6f
 8028b04:	00000000 	.word	0x00000000
 8028b08:	61762d2d 	.word	0x61762d2d
 8028b0c:	62616972 	.word	0x62616972
 8028b10:	0a3a656c 	.word	0x0a3a656c
 8028b14:	00000000 	.word	0x00000000
 8028b18:	205d765b 	.word	0x205d765b
 8028b1c:	000a7325 	.word	0x000a7325
 8028b20:	542d5452 	.word	0x542d5452
 8028b24:	61657268 	.word	0x61657268
 8028b28:	68732064 	.word	0x68732064
 8028b2c:	206c6c65 	.word	0x206c6c65
 8028b30:	6d6d6f63 	.word	0x6d6d6f63
 8028b34:	73646e61 	.word	0x73646e61
 8028b38:	00000a3a 	.word	0x00000a3a
 8028b3c:	6d635f5f 	.word	0x6d635f5f
 8028b40:	00005f64 	.word	0x00005f64
 8028b44:	36312d25 	.word	0x36312d25
 8028b48:	202d2073 	.word	0x202d2073
 8028b4c:	000a7325 	.word	0x000a7325
 8028b50:	0000000a 	.word	0x0000000a
 8028b54:	00646d63 	.word	0x00646d63
 8028b58:	70746572 	.word	0x70746572
 8028b5c:	00000000 	.word	0x00000000
 8028b60:	203a7325 	.word	0x203a7325
 8028b64:	6d6d6f63 	.word	0x6d6d6f63
 8028b68:	20646e61 	.word	0x20646e61
 8028b6c:	20746f6e 	.word	0x20746f6e
 8028b70:	6e756f66 	.word	0x6e756f66
 8028b74:	000a2e64 	.word	0x000a2e64
 8028b78:	000a7325 	.word	0x000a7325
 8028b7c:	65206f4e 	.word	0x65206f4e
 8028b80:	726f7272 	.word	0x726f7272
 8028b84:	00000000 	.word	0x00000000
 8028b88:	61766e49 	.word	0x61766e49
 8028b8c:	2064696c 	.word	0x2064696c
 8028b90:	656b6f74 	.word	0x656b6f74
 8028b94:	0000006e 	.word	0x0000006e
 8028b98:	65707845 	.word	0x65707845
 8028b9c:	61207463 	.word	0x61207463
 8028ba0:	70797420 	.word	0x70797420
 8028ba4:	00000065 	.word	0x00000065
 8028ba8:	6e6b6e55 	.word	0x6e6b6e55
 8028bac:	206e776f 	.word	0x206e776f
 8028bb0:	65707974 	.word	0x65707974
 8028bb4:	00000000 	.word	0x00000000
 8028bb8:	69726156 	.word	0x69726156
 8028bbc:	656c6261 	.word	0x656c6261
 8028bc0:	69786520 	.word	0x69786520
 8028bc4:	00007473 	.word	0x00007473
 8028bc8:	65707845 	.word	0x65707845
 8028bcc:	61207463 	.word	0x61207463
 8028bd0:	65706f20 	.word	0x65706f20
 8028bd4:	65746172 	.word	0x65746172
 8028bd8:	00000072 	.word	0x00000072
 8028bdc:	6f6d654d 	.word	0x6f6d654d
 8028be0:	66207972 	.word	0x66207972
 8028be4:	006c6c75 	.word	0x006c6c75
 8028be8:	6e6b6e55 	.word	0x6e6b6e55
 8028bec:	206e776f 	.word	0x206e776f
 8028bf0:	7265706f 	.word	0x7265706f
 8028bf4:	726f7461 	.word	0x726f7461
 8028bf8:	00000000 	.word	0x00000000
 8028bfc:	6e6b6e55 	.word	0x6e6b6e55
 8028c00:	206e776f 	.word	0x206e776f
 8028c04:	65646f6e 	.word	0x65646f6e
 8028c08:	00000000 	.word	0x00000000
 8028c0c:	65707845 	.word	0x65707845
 8028c10:	61207463 	.word	0x61207463
 8028c14:	61686320 	.word	0x61686320
 8028c18:	74636172 	.word	0x74636172
 8028c1c:	00007265 	.word	0x00007265
 8028c20:	78656e55 	.word	0x78656e55
 8028c24:	74636570 	.word	0x74636570
 8028c28:	646e6520 	.word	0x646e6520
 8028c2c:	00000000 	.word	0x00000000
 8028c30:	6e6b6e55 	.word	0x6e6b6e55
 8028c34:	206e776f 	.word	0x206e776f
 8028c38:	656b6f74 	.word	0x656b6f74
 8028c3c:	0000006e 	.word	0x0000006e
 8028c40:	616f6c46 	.word	0x616f6c46
 8028c44:	6f6e2074 	.word	0x6f6e2074
 8028c48:	75732074 	.word	0x75732074
 8028c4c:	726f7070 	.word	0x726f7070
 8028c50:	00646574 	.word	0x00646574
 8028c54:	6e6b6e55 	.word	0x6e6b6e55
 8028c58:	206e776f 	.word	0x206e776f
 8028c5c:	626d7973 	.word	0x626d7973
 8028c60:	00006c6f 	.word	0x00006c6f
 8028c64:	6c6c754e 	.word	0x6c6c754e
 8028c68:	646f6e20 	.word	0x646f6e20
 8028c6c:	00000065 	.word	0x00000065
 8028c70:	64696f76 	.word	0x64696f76
 8028c74:	00000000 	.word	0x00000000
 8028c78:	72616863 	.word	0x72616863
 8028c7c:	00000000 	.word	0x00000000
 8028c80:	726f6873 	.word	0x726f6873
 8028c84:	00000074 	.word	0x00000074
 8028c88:	00746e69 	.word	0x00746e69
 8028c8c:	676e6f6c 	.word	0x676e6f6c
 8028c90:	00000000 	.word	0x00000000
 8028c94:	69736e75 	.word	0x69736e75
 8028c98:	64656e67 	.word	0x64656e67
 8028c9c:	00000000 	.word	0x00000000
 8028ca0:	4c4c554e 	.word	0x4c4c554e
 8028ca4:	00000000 	.word	0x00000000
 8028ca8:	6c6c756e 	.word	0x6c6c756e
 8028cac:	00000000 	.word	0x00000000

08028cb0 <APBAHBPrescTable>:
 8028cb0:	00000000 04030201 04030201 09080706     ................

08028cc0 <stm32_can_ops>:
 8028cc0:	08012649 0801231d 08012371 08012449     I&...#..q#..I$..

08028cd0 <__FUNCTION__.12222>:
 8028cd0:	336d7473 41435f32 6365724e 67736d76     stm32_CANrecvmsg
 8028ce0:	00000000                                ....

08028ce4 <stm32_uart_ops>:
 8028ce4:	080144e9 0801470d 08014891 080148e1     .D...G...H...H..
 8028cf4:	08014931                                1I..

08028cf8 <__FUNCTION__.12007>:
 8028cf8:	336d7473 6f635f32 6769666e 00657275     stm32_configure.

08028d08 <__FUNCTION__.12050>:
 8028d08:	336d7473 6f635f32 6f72746e 0000006c     stm32_control...

08028d18 <__FUNCTION__.12061>:
 8028d18:	336d7473 75705f32 00006374              stm32_putc..

08028d24 <__FUNCTION__.12070>:
 8028d24:	336d7473 65675f32 00006374              stm32_getc..

08028d30 <__FUNCTION__.12080>:
 8028d30:	336d7473 6d645f32 72745f61 6d736e61     stm32_dma_transm
 8028d40:	00007469                                it..

08028d44 <__fsym___cmd_CANtx_name>:
 8028d44:	6d635f5f 41435f64 0078744e              __cmd_CANtx.

08028d50 <__fsym___cmd_CANtx_desc>:
 8028d50:	744e4143 65732078 6973646e 7020657a     CANtx sendsize p
 8028d60:	73702066 00000000                       f ps....

08028d68 <__fsym___cmd_TS_name>:
 8028d68:	6d635f5f 53545f64 00000000              __cmd_TS....

08028d74 <__fsym___cmd_TS_desc>:
 8028d74:	30205354 20726f20 31205354 20726f20     TS 0 or TS 1 or 
 8028d84:	32205354 20726f20 33205354 00000000     TS 2 or TS 3....

08028d94 <__fsym___cmd_FANtest_name>:
 8028d94:	6d635f5f 41465f64 7365744e 00000074     __cmd_FANtest...

08028da4 <__fsym___cmd_FANtest_desc>:
 8028da4:	744e4146 20747365 6f206e6f 41462072     FANtest on or FA
 8028db4:	7365744e 666f2074 00000066              Ntest off...

08028dc0 <__fsym___cmd_ADCtest_name>:
 8028dc0:	6d635f5f 44415f64 73657443 00000074     __cmd_ADCtest...

08028dd0 <__fsym___cmd_ADCtest_desc>:
 8028dd0:	74434441 20747365 6e697270 44412074     ADCtest print AD
 8028de0:	6c615643 00006575                       CValue..

08028de8 <__fsym___cmd_MCctrl_name>:
 8028de8:	6d635f5f 434d5f64 6c727463 00000000     __cmd_MCctrl....

08028df8 <__fsym___cmd_MCctrl_desc>:
 8028df8:	7463434d 6f206c72 726f206e 63434d20     MCctrl on or MCc
 8028e08:	206c7274 0066666f                       trl off.

08028e10 <__fsym___cmd_QEPtest_name>:
 8028e10:	6d635f5f 45515f64 73657450 00000074     __cmd_QEPtest...

08028e20 <__fsym___cmd_QEPtest_desc>:
 8028e20:	74504551 00747365                       QEPtest.

08028e28 <__FUNCTION__.4872>:
 8028e28:	645f7472 63697665 706f5f65 00006e65     rt_device_open..

08028e38 <__FUNCTION__.4877>:
 8028e38:	645f7472 63697665 6c635f65 0065736f     rt_device_close.

08028e48 <__FUNCTION__.4884>:
 8028e48:	645f7472 63697665 65725f65 00006461     rt_device_read..

08028e58 <__FUNCTION__.4891>:
 8028e58:	645f7472 63697665 72775f65 00657469     rt_device_write.

08028e68 <__FUNCTION__.4897>:
 8028e68:	645f7472 63697665 6f635f65 6f72746e     rt_device_contro
 8028e78:	0000006c                                l...

08028e7c <__FUNCTION__.4904>:
 8028e7c:	645f7472 63697665 65735f65 78725f74     rt_device_set_rx
 8028e8c:	646e695f 74616369 00000065              _indicate...

08028e98 <__FUNCTION__.4918>:
 8028e98:	745f7472 61657268 64695f64 655f656c     rt_thread_idle_e
 8028ea8:	74756378 00000065                       xcute...

08028eb0 <__FUNCTION__.4940>:
 8028eb0:	735f7472 695f6d65 0074696e              rt_sem_init.

08028ebc <__FUNCTION__.4952>:
 8028ebc:	735f7472 635f6d65 74616572 00000065     rt_sem_create...

08028ecc <__FUNCTION__.4964>:
 8028ecc:	735f7472 745f6d65 00656b61              rt_sem_take.

08028ed8 <__FUNCTION__.4988>:
 8028ed8:	6d5f7472 78657475 696e695f 00000074     rt_mutex_init...

08028ee8 <__FUNCTION__.5012>:
 8028ee8:	6d5f7472 78657475 6b61745f 00000065     rt_mutex_take...

08028ef8 <__FUNCTION__.5021>:
 8028ef8:	6d5f7472 78657475 6c65725f 65736165     rt_mutex_release
 8028f08:	00000000                                ....

08028f0c <__FUNCTION__.5177>:
 8028f0c:	6d5f7472 72635f71 65746165 00000000     rt_mq_create....

08028f1c <__FUNCTION__.5185>:
 8028f1c:	6d5f7472 65645f71 6574656c 00000000     rt_mq_delete....

08028f2c <__FUNCTION__.5193>:
 8028f2c:	6d5f7472 65735f71 0000646e              rt_mq_send..

08028f38 <__FUNCTION__.5212>:
 8028f38:	6d5f7472 65725f71 00007663              rt_mq_recv..

08028f44 <__lowest_bit_bitmap>:
 8028f44:	00010000 00010002 00010003 00010002     ................
 8028f54:	00010004 00010002 00010003 00010002     ................
 8028f64:	00010005 00010002 00010003 00010002     ................
 8028f74:	00010004 00010002 00010003 00010002     ................
 8028f84:	00010006 00010002 00010003 00010002     ................
 8028f94:	00010004 00010002 00010003 00010002     ................
 8028fa4:	00010005 00010002 00010003 00010002     ................
 8028fb4:	00010004 00010002 00010003 00010002     ................
 8028fc4:	00010007 00010002 00010003 00010002     ................
 8028fd4:	00010004 00010002 00010003 00010002     ................
 8028fe4:	00010005 00010002 00010003 00010002     ................
 8028ff4:	00010004 00010002 00010003 00010002     ................
 8029004:	00010006 00010002 00010003 00010002     ................
 8029014:	00010004 00010002 00010003 00010002     ................
 8029024:	00010005 00010002 00010003 00010002     ................
 8029034:	00010004 00010002 00010003 00010002     ................

08029044 <large_digits.5065>:
 8029044:	33323130 37363534 42413938 46454443     0123456789ABCDEF
 8029054:	00000000                                ....

08029058 <small_digits.5064>:
 8029058:	33323130 37363534 62613938 66656463     0123456789abcdef
 8029068:	00000000                                ....

0802906c <__fsym_list_mem_name>:
 802906c:	7473696c 6d656d5f 00000000              list_mem....

08029078 <__fsym_list_mem_desc>:
 8029078:	7473696c 6d656d20 2079726f 67617375     list memory usag
 8029088:	6e692065 6d726f66 6f697461 0000006e     e information...

08029098 <__FUNCTION__.4931>:
 8029098:	67756c70 6c6f685f 00007365              plug_holes..

080290a4 <__FUNCTION__.4940>:
 80290a4:	735f7472 65747379 65685f6d 695f7061     rt_system_heap_i
 80290b4:	0074696e                                nit.

080290b8 <__FUNCTION__.4949>:
 80290b8:	6d5f7472 6f6c6c61 00000063              rt_malloc...

080290c4 <__FUNCTION__.4967>:
 80290c4:	725f7472 6c6c6165 0000636f              rt_realloc..

080290d0 <__FUNCTION__.4980>:
 80290d0:	665f7472 00656572                       rt_free.

080290d8 <__FUNCTION__.4907>:
 80290d8:	6d5f7472 65686d65 695f7061 0074696e     rt_memheap_init.

080290e8 <__FUNCTION__.4948>:
 80290e8:	6f5f7472 63656a62 65645f74 68636174     rt_object_detach
 80290f8:	00000000                                ....

080290fc <__FUNCTION__.4957>:
 80290fc:	6f5f7472 63656a62 6c615f74 61636f6c     rt_object_alloca
 802910c:	00006574                                te..

08029110 <__FUNCTION__.4962>:
 8029110:	6f5f7472 63656a62 65645f74 6574656c     rt_object_delete
 8029120:	00000000                                ....

08029124 <__FUNCTION__.4966>:
 8029124:	6f5f7472 63656a62 73695f74 7379735f     rt_object_is_sys
 8029134:	6f6d6574 63656a62 00000074              temobject...

08029140 <__FUNCTION__.4920>:
 8029140:	5f74725f 65686373 656c7564 74735f72     _rt_scheduler_st
 8029150:	5f6b6361 63656863 0000006b              ack_check...

0802915c <__FUNCTION__.4951>:
 802915c:	735f7472 64656863 5f656c75 65736e69     rt_schedule_inse
 802916c:	745f7472 61657268 00000064              rt_thread...

08029178 <__FUNCTION__.4956>:
 8029178:	735f7472 64656863 5f656c75 6f6d6572     rt_schedule_remo
 8029188:	745f6576 61657268 00000064              ve_thread...

08029194 <__FUNCTION__.4919>:
 8029194:	5f74725f 65726874 695f6461 0074696e     _rt_thread_init.

080291a4 <__FUNCTION__.4931>:
 80291a4:	745f7472 61657268 6e695f64 00007469     rt_thread_init..

080291b4 <__FUNCTION__.4938>:
 80291b4:	745f7472 61657268 74735f64 75747261     rt_thread_startu
 80291c4:	00000070                                p...

080291c8 <__FUNCTION__.4959>:
 80291c8:	745f7472 61657268 65645f64 6574656c     rt_thread_delete
 80291d8:	00000000                                ....

080291dc <__FUNCTION__.4970>:
 80291dc:	745f7472 61657268 6c735f64 00706565     rt_thread_sleep.

080291ec <__FUNCTION__.4980>:
 80291ec:	745f7472 61657268 6f635f64 6f72746e     rt_thread_contro
 80291fc:	0000006c                                l...

08029200 <__FUNCTION__.4990>:
 8029200:	745f7472 61657268 75735f64 6e657073     rt_thread_suspen
 8029210:	00000064                                d...

08029214 <__FUNCTION__.4995>:
 8029214:	745f7472 61657268 65725f64 656d7573     rt_thread_resume
 8029224:	00000000                                ....

08029228 <__FUNCTION__.5000>:
 8029228:	745f7472 61657268 69745f64 756f656d     rt_thread_timeou
 8029238:	00000074                                t...

0802923c <__FUNCTION__.4946>:
 802923c:	745f7472 72656d69 696e695f 00000074     rt_timer_init...

0802924c <__FUNCTION__.4951>:
 802924c:	745f7472 72656d69 7465645f 00686361     rt_timer_detach.

0802925c <__FUNCTION__.4975>:
 802925c:	745f7472 72656d69 6174735f 00007472     rt_timer_start..

0802926c <__FUNCTION__.4992>:
 802926c:	745f7472 72656d69 6f74735f 00000070     rt_timer_stop...

0802927c <__FUNCTION__.4998>:
 802927c:	745f7472 72656d69 6e6f635f 6c6f7274     rt_timer_control
 802928c:	00000000                                ....

08029290 <__FUNCTION__.6081>:
 8029290:	635f7472 6c706d6f 6f697465 6e695f6e     rt_completion_in
 80292a0:	00007469                                it..

080292a4 <__FUNCTION__.6089>:
 80292a4:	635f7472 6c706d6f 6f697465 61775f6e     rt_completion_wa
 80292b4:	00007469                                it..

080292b8 <__FUNCTION__.6096>:
 80292b8:	635f7472 6c706d6f 6f697465 6f645f6e     rt_completion_do
 80292c8:	0000656e                                ne..

080292cc <__FUNCTION__.6087>:
 80292cc:	645f7472 5f617461 75657571 6e695f65     rt_data_queue_in
 80292dc:	00007469                                it..

080292e0 <__FUNCTION__.6098>:
 80292e0:	645f7472 5f617461 75657571 75705f65     rt_data_queue_pu
 80292f0:	00006873                                sh..

080292f4 <__FUNCTION__.6114>:
 80292f4:	645f7472 5f617461 75657571 6f705f65     rt_data_queue_po
 8029304:	00000070                                p...

08029308 <__FUNCTION__.6127>:
 8029308:	645f7472 5f617461 75657571 65705f65     rt_data_queue_pe
 8029318:	00006b61                                ak..

0802931c <__fsym_nand_id_name>:
 802931c:	646e616e 0064695f                       nand_id.

08029324 <__fsym_nand_id_desc>:
 8029324:	64616572 20444920 616e202d 6469646e     read ID - nandid
 8029334:	6d616e28 00002965                       (name)..

0802933c <__fsym_nand_read_name>:
 802933c:	646e616e 6165725f 00000064              nand_read...

08029348 <__fsym_nand_read_desc>:
 8029348:	64616572 67617020 6e692065 6e616e20     read page in nan
 8029358:	202d2064 646e616e 6165725f 616e2864     d - nand_read(na
 8029368:	202c656d 636f6c62 70202c6b 29656761     me, block, page)
 8029378:	00000000                                ....

0802937c <__fsym_nand_readoob_name>:
 802937c:	646e616e 6165725f 626f6f64 00000000     nand_readoob....

0802938c <__fsym_nand_readoob_desc>:
 802938c:	64616572 61707320 64206572 20617461     read spare data 
 802939c:	6e206e69 20646e61 616e202d 725f646e     in nand - nand_r
 80293ac:	6f646165 6e28626f 2c656d61 6f6c6220     eadoob(name, blo
 80293bc:	202c6b63 65676170 00000029              ck, page)...

080293c8 <__fsym_nand_write_name>:
 80293c8:	646e616e 6972775f 00006574              nand_write..

080293d4 <__fsym_nand_write_desc>:
 80293d4:	74697277 75642065 6420706d 20617461     write dump data 
 80293e4:	6e206f74 20646e61 616e202d 775f646e     to nand - nand_w
 80293f4:	65746972 6d616e28 62202c65 6b636f6c     rite(name, block
 8029404:	6170202c 00296567                       , page).

0802940c <__fsym_nand_erase_name>:
 802940c:	646e616e 6172655f 00006573              nand_erase..

08029418 <__fsym_nand_erase_desc>:
 8029418:	646e616e 6172655f 6e286573 2c656d61     nand_erase(name,
 8029428:	6f6c6220 00296b63                        block).

08029430 <__fsym_nand_erase_all_name>:
 8029430:	646e616e 6172655f 615f6573 00006c6c     nand_erase_all..

08029440 <__fsym_nand_erase_all_desc>:
 8029440:	73617265 6c612065 666f206c 6e616e20     erase all of nan
 8029450:	65642064 65636976 6e202d20 5f646e61     d device - nand_
 8029460:	73617265 6c615f65 616e286c 202c656d     erase_all(name, 
 8029470:	636f6c62 0000296b                       block)..

08029478 <__fsym_list_date_name>:
 8029478:	7473696c 7461645f 00000065              list_date...

08029484 <__fsym_list_date_desc>:
 8029484:	776f6873 74616420 6e612065 69742064     show date and ti
 8029494:	002e656d                                me..

08029498 <__fsym_set_date_name>:
 8029498:	5f746573 65746164 00000000              set_date....

080294a4 <__fsym_set_date_desc>:
 80294a4:	20746573 65746164 2e65202e 73203a67     set date. e.g: s
 80294b4:	645f7465 28657461 30313032 322c322c     et_date(2010,2,2
 80294c4:	00002938                                8)..

080294c8 <__fsym_set_time_name>:
 80294c8:	5f746573 656d6974 00000000              set_time....

080294d4 <__fsym_set_time_desc>:
 80294d4:	20746573 656d6974 2e65202e 73203a67     set time. e.g: s
 80294e4:	745f7465 28656d69 352c3332 39352c39     et_time(23,59,59
 80294f4:	00000029                                )...

080294f8 <__FUNCTION__.6144>:
 80294f8:	735f7472 61697265 6e695f6c 00007469     rt_serial_init..

08029508 <__FUNCTION__.6150>:
 8029508:	735f7472 61697265 706f5f6c 00006e65     rt_serial_open..

08029518 <__FUNCTION__.6159>:
 8029518:	735f7472 61697265 6c635f6c 0065736f     rt_serial_close.

08029528 <__FUNCTION__.6171>:
 8029528:	735f7472 61697265 65725f6c 00006461     rt_serial_read..

08029538 <__FUNCTION__.6105>:
 8029538:	7265735f 5f6c6169 5f746e69 00007872     _serial_int_rx..

08029548 <__FUNCTION__.6130>:
 8029548:	7265735f 5f6c6169 5f616d64 00007872     _serial_dma_rx..

08029558 <__FUNCTION__.6084>:
 8029558:	7265735f 5f6c6169 6c6c6f70 0078725f     _serial_poll_rx.

08029568 <__FUNCTION__.6179>:
 8029568:	735f7472 61697265 72775f6c 00657469     rt_serial_write.

08029578 <__FUNCTION__.6118>:
 8029578:	7265735f 5f6c6169 5f746e69 00007874     _serial_int_tx..

08029588 <__FUNCTION__.6094>:
 8029588:	7265735f 5f6c6169 6c6c6f70 0078745f     _serial_poll_tx.

08029598 <__FUNCTION__.6186>:
 8029598:	735f7472 61697265 6f635f6c 6f72746e     rt_serial_contro
 80295a8:	0000006c                                l...

080295ac <__FUNCTION__.6199>:
 80295ac:	685f7472 65735f77 6c616972 6765725f     rt_hw_serial_reg
 80295bc:	65747369 00000072                       ister...

080295c4 <__FUNCTION__.6208>:
 80295c4:	685f7472 65735f77 6c616972 7273695f     rt_hw_serial_isr
 80295d4:	00000000                                ....

080295d8 <__fsym___cmd_canstat_name>:
 80295d8:	6d635f5f 61635f64 6174736e 00000074     __cmd_canstat...

080295e8 <__fsym___cmd_canstat_desc>:
 80295e8:	74617453 6e614320 76654420 20656369     Stat Can Device 
 80295f8:	74617453 002e7375                       Status..

08029600 <__FUNCTION__.6082>:
 8029600:	635f7472 695f6e61 0074696e              rt_can_init.

0802960c <__FUNCTION__.6130>:
 802960c:	635f7472 6f5f6e61 006e6570              rt_can_open.

08029618 <__FUNCTION__.6145>:
 8029618:	635f7472 635f6e61 65736f6c 00000000     rt_can_close....

08029628 <__FUNCTION__.6155>:
 8029628:	635f7472 725f6e61 00646165              rt_can_read.

08029634 <__FUNCTION__.6090>:
 8029634:	6e61635f 746e695f 0078725f              _can_int_rx.

08029640 <__FUNCTION__.6163>:
 8029640:	635f7472 775f6e61 65746972 00000000     rt_can_write....

08029650 <__FUNCTION__.6121>:
 8029650:	6e61635f 746e695f 5f78745f 76697270     _can_int_tx_priv
 8029660:	00000000                                ....

08029664 <__FUNCTION__.6103>:
 8029664:	6e61635f 746e695f 0078745f              _can_int_tx.

08029670 <__FUNCTION__.6171>:
 8029670:	635f7472 635f6e61 72746e6f 00006c6f     rt_can_control..

08029680 <__FUNCTION__.6199>:
 8029680:	685f7472 61635f77 65725f6e 74736967     rt_hw_can_regist
 8029690:	00007265                                er..

08029694 <__FUNCTION__.5426>:
 8029694:	736e6966 78725f68 646e695f 00000000     finsh_rx_ind....

080296a4 <__FUNCTION__.5468>:
 80296a4:	736e6966 68745f68 64616572 746e655f     finsh_thread_ent
 80296b4:	00007972                                ry..

080296b8 <__fsym_hello_name>:
 80296b8:	6c6c6568 0000006f                       hello...

080296c0 <__fsym_hello_desc>:
 80296c0:	20796173 6c6c6568 6f77206f 00646c72     say hello world.

080296d0 <__fsym_version_name>:
 80296d0:	73726576 006e6f69                       version.

080296d8 <__fsym_version_desc>:
 80296d8:	776f6873 2d545220 65726854 76206461     show RT-Thread v
 80296e8:	69737265 69206e6f 726f666e 6974616d     ersion informati
 80296f8:	00006e6f                                on..

080296fc <__fsym___cmd_version_name>:
 80296fc:	6d635f5f 65765f64 6f697372 0000006e     __cmd_version...

0802970c <__fsym___cmd_version_desc>:
 802970c:	776f6873 2d545220 65726854 76206461     show RT-Thread v
 802971c:	69737265 69206e6f 726f666e 6974616d     ersion informati
 802972c:	00006e6f                                on..

08029730 <__fsym_list_thread_name>:
 8029730:	7473696c 7268745f 00646165              list_thread.

0802973c <__fsym_list_thread_desc>:
 802973c:	7473696c 72687420 00646165              list thread.

08029748 <__fsym___cmd_list_thread_name>:
 8029748:	6d635f5f 696c5f64 745f7473 61657268     __cmd_list_threa
 8029758:	00000064                                d...

0802975c <__fsym___cmd_list_thread_desc>:
 802975c:	7473696c 72687420 00646165              list thread.

08029768 <__fsym_list_sem_name>:
 8029768:	7473696c 6d65735f 00000000              list_sem....

08029774 <__fsym_list_sem_desc>:
 8029774:	7473696c 6d657320 6f687061 6920656e     list semaphone i
 8029784:	7973206e 6d657473 00000000              n system....

08029790 <__fsym___cmd_list_sem_name>:
 8029790:	6d635f5f 696c5f64 735f7473 00006d65     __cmd_list_sem..

080297a0 <__fsym___cmd_list_sem_desc>:
 80297a0:	7473696c 6d657320 6f687061 69206572     list semaphore i
 80297b0:	7973206e 6d657473 00000000              n system....

080297bc <__fsym_list_event_name>:
 80297bc:	7473696c 6576655f 0000746e              list_event..

080297c8 <__fsym_list_event_desc>:
 80297c8:	7473696c 65766520 6920746e 7973206e     list event in sy
 80297d8:	6d657473 00000000                       stem....

080297e0 <__fsym___cmd_list_event_name>:
 80297e0:	6d635f5f 696c5f64 655f7473 746e6576     __cmd_list_event
 80297f0:	00000000                                ....

080297f4 <__fsym___cmd_list_event_desc>:
 80297f4:	7473696c 65766520 6920746e 7973206e     list event in sy
 8029804:	6d657473 00000000                       stem....

0802980c <__fsym_list_mutex_name>:
 802980c:	7473696c 74756d5f 00007865              list_mutex..

08029818 <__fsym_list_mutex_desc>:
 8029818:	7473696c 74756d20 69207865 7973206e     list mutex in sy
 8029828:	6d657473 00000000                       stem....

08029830 <__fsym___cmd_list_mutex_name>:
 8029830:	6d635f5f 696c5f64 6d5f7473 78657475     __cmd_list_mutex
 8029840:	00000000                                ....

08029844 <__fsym___cmd_list_mutex_desc>:
 8029844:	7473696c 74756d20 69207865 7973206e     list mutex in sy
 8029854:	6d657473 00000000                       stem....

0802985c <__fsym_list_mailbox_name>:
 802985c:	7473696c 69616d5f 786f626c 00000000     list_mailbox....

0802986c <__fsym_list_mailbox_desc>:
 802986c:	7473696c 69616d20 6f62206c 6e692078     list mail box in
 802987c:	73797320 006d6574                        system.

08029884 <__fsym___cmd_list_mailbox_name>:
 8029884:	6d635f5f 696c5f64 6d5f7473 626c6961     __cmd_list_mailb
 8029894:	0000786f                                ox..

08029898 <__fsym___cmd_list_mailbox_desc>:
 8029898:	7473696c 69616d20 6f62206c 6e692078     list mail box in
 80298a8:	73797320 006d6574                        system.

080298b0 <__fsym_list_msgqueue_name>:
 80298b0:	7473696c 67736d5f 75657571 00000065     list_msgqueue...

080298c0 <__fsym_list_msgqueue_desc>:
 80298c0:	7473696c 73656d20 65676173 65757120     list message que
 80298d0:	69206575 7973206e 6d657473 00000000     ue in system....

080298e0 <__fsym___cmd_list_msgqueue_name>:
 80298e0:	6d635f5f 696c5f64 6d5f7473 75716773     __cmd_list_msgqu
 80298f0:	00657565                                eue.

080298f4 <__fsym___cmd_list_msgqueue_desc>:
 80298f4:	7473696c 73656d20 65676173 65757120     list message que
 8029904:	69206575 7973206e 6d657473 00000000     ue in system....

08029914 <__fsym_list_memheap_name>:
 8029914:	7473696c 6d656d5f 70616568 00000000     list_memheap....

08029924 <__fsym_list_memheap_desc>:
 8029924:	7473696c 6d656d20 2079726f 70616568     list memory heap
 8029934:	206e6920 74737973 00006d65               in system..

08029940 <__fsym___cmd_list_memheap_name>:
 8029940:	6d635f5f 696c5f64 6d5f7473 65686d65     __cmd_list_memhe
 8029950:	00007061                                ap..

08029954 <__fsym___cmd_list_memheap_desc>:
 8029954:	7473696c 6d656d20 2079726f 70616568     list memory heap
 8029964:	206e6920 74737973 00006d65               in system..

08029970 <__fsym_list_mempool_name>:
 8029970:	7473696c 6d656d5f 6c6f6f70 00000000     list_mempool....

08029980 <__fsym_list_mempool_desc>:
 8029980:	7473696c 6d656d20 2079726f 6c6f6f70     list memory pool
 8029990:	206e6920 74737973 00006d65               in system..

0802999c <__fsym___cmd_list_mempool_name>:
 802999c:	6d635f5f 696c5f64 6d5f7473 6f706d65     __cmd_list_mempo
 80299ac:	00006c6f                                ol..

080299b0 <__fsym___cmd_list_mempool_desc>:
 80299b0:	7473696c 6d656d20 2079726f 6c6f6f70     list memory pool
 80299c0:	206e6920 74737973 00006d65               in system..

080299cc <__fsym_list_timer_name>:
 80299cc:	7473696c 6d69745f 00007265              list_timer..

080299d8 <__fsym_list_timer_desc>:
 80299d8:	7473696c 6d697420 69207265 7973206e     list timer in sy
 80299e8:	6d657473 00000000                       stem....

080299f0 <__fsym___cmd_list_timer_name>:
 80299f0:	6d635f5f 696c5f64 745f7473 72656d69     __cmd_list_timer
 8029a00:	00000000                                ....

08029a04 <__fsym___cmd_list_timer_desc>:
 8029a04:	7473696c 6d697420 69207265 7973206e     list timer in sy
 8029a14:	6d657473 00000000                       stem....

08029a1c <__fsym_list_device_name>:
 8029a1c:	7473696c 7665645f 00656369              list_device.

08029a28 <__fsym_list_device_desc>:
 8029a28:	7473696c 76656420 20656369 73206e69     list device in s
 8029a38:	65747379 0000006d                       ystem...

08029a40 <__fsym___cmd_list_device_name>:
 8029a40:	6d635f5f 696c5f64 645f7473 63697665     __cmd_list_devic
 8029a50:	00000065                                e...

08029a54 <__fsym___cmd_list_device_desc>:
 8029a54:	7473696c 76656420 20656369 73206e69     list device in s
 8029a64:	65747379 0000006d                       ystem...

08029a6c <__fsym_list_name>:
 8029a6c:	7473696c 00000000                       list....

08029a74 <__fsym_list_desc>:
 8029a74:	7473696c 6c6c6120 6d797320 206c6f62     list all symbol 
 8029a84:	73206e69 65747379 0000006d              in system...

08029a90 <__vsym_dummy_name>:
 8029a90:	6d6d7564 00000079                       dummy...

08029a98 <__vsym_dummy_desc>:
 8029a98:	6d6d7564 61762079 62616972 6620656c     dummy variable f
 8029aa8:	6620726f 68736e69 00000000              or finsh....

08029ab4 <__fsym___cmd_ps_name>:
 8029ab4:	6d635f5f 73705f64 00000000              __cmd_ps....

08029ac0 <__fsym___cmd_ps_desc>:
 8029ac0:	7473694c 72687420 73646165 206e6920     List threads in 
 8029ad0:	20656874 74737973 002e6d65              the system..

08029adc <__fsym___cmd_time_name>:
 8029adc:	6d635f5f 69745f64 0000656d              __cmd_time..

08029ae8 <__fsym___cmd_time_desc>:
 8029ae8:	63657845 20657475 6d6d6f63 20646e61     Execute command 
 8029af8:	68746977 6d697420 00002e65              with time...

08029b04 <__fsym___cmd_free_name>:
 8029b04:	6d635f5f 72665f64 00006565              __cmd_free..

08029b10 <__fsym___cmd_free_desc>:
 8029b10:	776f6853 65687420 6d656d20 2079726f     Show the memory 
 8029b20:	67617375 6e692065 65687420 73797320     usage in the sys
 8029b30:	2e6d6574 00000000                       tem.....

08029b38 <__fsym___cmd_exit_name>:
 8029b38:	6d635f5f 78655f64 00007469              __cmd_exit..

08029b44 <__fsym___cmd_exit_desc>:
 8029b44:	75746572 74206e72 5452206f 7268542d     return to RT-Thr
 8029b54:	20646165 6c656873 6f6d206c 002e6564     ead shell mode..

08029b64 <__fsym_msh_name>:
 8029b64:	0068736d                                msh.

08029b68 <__fsym_msh_desc>:
 8029b68:	20657375 75646f6d 7320656c 6c6c6568     use module shell
 8029b78:	00000000                                ....

08029b7c <__fsym___cmd_help_name>:
 8029b7c:	6d635f5f 65685f64 0000706c              __cmd_help..

08029b88 <__fsym___cmd_help_desc>:
 8029b88:	542d5452 61657268 68732064 206c6c65     RT-Thread shell 
 8029b98:	706c6568 0000002e                       help....

08029ba0 <__FUNCTION__.5426>:
 8029ba0:	68736d5f 6578655f 6d635f63 00000064     _msh_exec_cmd...

08029bb0 <op_table>:
 8029bb0:	080200c9 080200d9 08020111 08020151     ............Q...
 8029bc0:	08020189 080201c1 08020201 08020239     ............9...
 8029bd0:	08020275 080202b5 080202ed 08020331     u...........1...
 8029be0:	08020379 080203b9 080203f5 08020435     y...........5...
 8029bf0:	0802046d 080204a5 080204dd 08020515     m...............
 8029c00:	0802054d 08020585 080205bd 080205f5     M...............
 8029c10:	0802062d 08020665 0802068d 080206b5     -...e...........
 8029c20:	080206d9 08020715 08020755 0802078d     ........U.......
 8029c30:	080207c9 08020809 08020841 08020879     ........A...y...
 8029c40:	080208c1 0802091d 080209b1 08020a45     ............E...
 8029c50:	08020ad9 08020b09 08020b39 08020b69     ........9...i...
 8029c60:	08020b85 08020985 08020a19 08020aad     ................
 8029c70:	00000000                                ....

08029c74 <finsh_name_table>:
 8029c74:	08028c70 00000014 08028c78 00000015     p.......x.......
 8029c84:	08028c80 00000016 08028c88 00000017     ................
 8029c94:	08028c8c 00000018 08028c94 00000019     ................
 8029ca4:	08028ca0 0000001e 08028ca8 0000001e     ................

08029cb4 <_DAYS_BEFORE_MONTH>:
 8029cb4:	00000000 0000001f 0000003b 0000005a     ........;...Z...
 8029cc4:	00000078 00000097 000000b5 000000d4     x...............
 8029cd4:	000000f3 00000111 00000130 0000014e     ........0...N...

08029ce4 <DAYS_IN_MONTH>:
 8029ce4:	0000001f 0000001c 0000001f 0000001e     ................
 8029cf4:	0000001f 0000001e 0000001f 0000001f     ................
 8029d04:	0000001e 0000001f 0000001e 0000001f     ................

08029d14 <__month_lengths>:
 8029d14:	0000001f 0000001c 0000001f 0000001e     ................
 8029d24:	0000001f 0000001e 0000001f 0000001f     ................
 8029d34:	0000001e 0000001f 0000001e 0000001f     ................
 8029d44:	0000001f 0000001d 0000001f 0000001e     ................
 8029d54:	0000001f 0000001e 0000001f 0000001f     ................
 8029d64:	0000001e 0000001f 0000001e 0000001f     ................
 8029d74:	00005a54 003d5a54 00544d47 5b303125     TZ..TZ=.GMT.%10[
 8029d84:	392d305e 5d2d2b2c 00006e25 25756825     ^0-9,+-]%n..%hu%
 8029d94:	68253a6e 3a6e2575 25756825 0000006e     n:%hu%n:%hu%n...
 8029da4:	7568254d 252e6e25 6e257568 7568252e     M%hu%n.%hu%n.%hu
 8029db4:	00006e25 7568252f 253a6e25 6e257568     %n../%hu%n:%hu%n
 8029dc4:	7568253a 00006e25                       :%hu%n..

08029dcc <mon_name.4605>:
 8029dcc:	466e614a 614d6265 72704172 4a79614d     JanFebMarAprMayJ
 8029ddc:	754a6e75 6775416c 4f706553 6f4e7463     unJulAugSepOctNo
 8029dec:	63654476 73332e25 332e2520 64332573     vDec%.3s %.3s%3d
 8029dfc:	322e2520 2e253a64 253a6432 2064322e      %.2d:%.2d:%.2d 
 8029e0c:	000a6425                                %d..

08029e10 <day_name.4604>:
 8029e10:	4d6e7553 75546e6f 64655765 46756854     SunMonTueWedThuF
 8029e20:	61536972 00000074                       riSat...

08029e28 <_ctype_>:
 8029e28:	20202000 20202020 28282020 20282828     .         ((((( 
 8029e38:	20202020 20202020 20202020 20202020                     
 8029e48:	10108820 10101010 10101010 10101010      ...............
 8029e58:	04040410 04040404 10040404 10101010     ................
 8029e68:	41411010 41414141 01010101 01010101     ..AAAAAA........
 8029e78:	01010101 01010101 01010101 10101010     ................
 8029e88:	42421010 42424242 02020202 02020202     ..BBBBBB........
 8029e98:	02020202 02020202 02020202 10101010     ................
 8029ea8:	00000020 00000000 00000000 00000000      ...............
	...

08029f2c <days_per_year>:
 8029f2c:	0000016d 0000016d 0000016e 0000016d     m...m...n...m...
 8029f3c:	00000043                                C...

08029f40 <blanks.6738>:
 8029f40:	20202020 20202020 20202020 20202020                     
 8029f50:	33323130 37363534 42413938 46454443     0123456789ABCDEF
 8029f60:	00000000 33323130 37363534 62613938     ....0123456789ab
 8029f70:	66656463 00000000 6c756e28 0000296c     cdef....(null)..

08029f80 <zeroes.6739>:
 8029f80:	30303030 30303030 30303030 30303030     0000000000000000

08029f90 <basefix.6210>:
 8029f90:	0001000a 00030002 00050004 00070006     ................
 8029fa0:	00090008 000b000a 000d000c 000f000e     ................
 8029fb0:	00000010                                ....

08029fb4 <npio2_hw>:
 8029fb4:	3fc90f00 40490f00 4096cb00 40c90f00     ...?..I@...@...@
 8029fc4:	40fb5300 4116cb00 412fed00 41490f00     .S.@...A../A..IA
 8029fd4:	41623100 417b5300 418a3a00 4196cb00     .1bA.S{A.:.A...A
 8029fe4:	41a35c00 41afed00 41bc7e00 41c90f00     .\.A...A.~.A...A
 8029ff4:	41d5a000 41e23100 41eec200 41fb5300     ...A.1.A...A.S.A
 802a004:	4203f200 420a3a00 42108300 4216cb00     ...B.:.B...B...B
 802a014:	421d1400 42235c00 4229a500 422fed00     ...B.\#B..)B../B
 802a024:	42363600 423c7e00 4242c700 42490f00     .66B.~<B..BB..IB

0802a034 <two_over_pi>:
 802a034:	000000a2 000000f9 00000083 0000006e     ............n...
 802a044:	0000004e 00000044 00000015 00000029     N...D.......)...
 802a054:	000000fc 00000027 00000057 000000d1     ....'...W.......
 802a064:	000000f5 00000034 000000dd 000000c0     ....4...........
 802a074:	000000db 00000062 00000095 00000099     ....b...........
 802a084:	0000003c 00000043 00000090 00000041     <...C.......A...
 802a094:	000000fe 00000051 00000063 000000ab     ....Q...c.......
 802a0a4:	000000de 000000bb 000000c5 00000061     ............a...
 802a0b4:	000000b7 00000024 0000006e 0000003a     ....$...n...:...
 802a0c4:	00000042 0000004d 000000d2 000000e0     B...M...........
 802a0d4:	00000006 00000049 0000002e 000000ea     ....I...........
 802a0e4:	00000009 000000d1 00000092 0000001c     ................
 802a0f4:	000000fe 0000001d 000000eb 0000001c     ................
 802a104:	000000b1 00000029 000000a7 0000003e     ....).......>...
 802a114:	000000e8 00000082 00000035 000000f5     ........5.......
 802a124:	0000002e 000000bb 00000044 00000084     ........D.......
 802a134:	000000e9 0000009c 00000070 00000026     ........p...&...
 802a144:	000000b4 0000005f 0000007e 00000041     ...._...~...A...
 802a154:	00000039 00000091 000000d6 00000039     9...........9...
 802a164:	00000083 00000053 00000039 000000f4     ....S...9.......
 802a174:	0000009c 00000084 0000005f 0000008b     ........_.......
 802a184:	000000bd 000000f9 00000028 0000003b     ........(...;...
 802a194:	0000001f 000000f8 00000097 000000ff     ................
 802a1a4:	000000de 00000005 00000098 0000000f     ................
 802a1b4:	000000ef 0000002f 00000011 0000008b     ..../...........
 802a1c4:	0000005a 0000000a 0000006d 0000001f     Z.......m.......
 802a1d4:	0000006d 00000036 0000007e 000000cf     m...6...~.......
 802a1e4:	00000027 000000cb 00000009 000000b7     '...............
 802a1f4:	0000004f 00000046 0000003f 00000066     O...F...?...f...
 802a204:	0000009e 0000005f 000000ea 0000002d     ...._.......-...
 802a214:	00000075 00000027 000000ba 000000c7     u...'...........
 802a224:	000000eb 000000e5 000000f1 0000007b     ............{...
 802a234:	0000003d 00000007 00000039 000000f7     =.......9.......
 802a244:	0000008a 00000052 00000092 000000ea     ....R...........
 802a254:	0000006b 000000fb 0000005f 000000b1     k......._.......
 802a264:	0000001f 0000008d 0000005d 00000008     ........].......
 802a274:	00000056 00000003 00000030 00000046     V.......0...F...
 802a284:	000000fc 0000007b 0000006b 000000ab     ....{...k.......
 802a294:	000000f0 000000cf 000000bc 00000020     ............ ...
 802a2a4:	0000009a 000000f4 00000036 0000001d     ........6.......
 802a2b4:	000000a9 000000e3 00000091 00000061     ............a...
 802a2c4:	0000005e 000000e6 0000001b 00000008     ^...............
 802a2d4:	00000065 00000099 00000085 0000005f     e..........._...
 802a2e4:	00000014 000000a0 00000068 00000040     ........h...@...
 802a2f4:	0000008d 000000ff 000000d8 00000080     ................
 802a304:	0000004d 00000073 00000027 00000031     M...s...'...1...
 802a314:	00000006 00000006 00000015 00000056     ............V...
 802a324:	000000ca 00000073 000000a8 000000c9     ....s...........
 802a334:	00000060 000000e2 0000007b 000000c0     `.......{.......
 802a344:	0000008c 0000006b                       ....k...

0802a34c <init_jk>:
 802a34c:	00000004 00000007 00000009              ............

0802a358 <PIo2>:
 802a358:	3fc90000 39f00000 37da0000 33a20000     ...?...9...7...3
 802a368:	2e840000 2b500000 27c20000 22d00000     ......P+...'..."
 802a378:	1fc40000 1bc60000 17440000              ..........D.

0802a384 <__fsym___cmd_CANtx>:
 802a384:	08028d44 08028d50 08014d6d              D...P...mM..

0802a390 <__fsym___cmd_TS>:
 802a390:	08028d68 08028d74 080151e5              h...t....Q..

0802a39c <__fsym___cmd_FANtest>:
 802a39c:	08028d94 08028da4 080152bd              .........R..

0802a3a8 <__fsym___cmd_ADCtest>:
 802a3a8:	08028dc0 08028dd0 08015325              ........%S..

0802a3b4 <__fsym___cmd_MCctrl>:
 802a3b4:	08028de8 08028df8 080154d5              .........T..

0802a3c0 <__fsym___cmd_QEPtest>:
 802a3c0:	08028e10 08028e20 0801553d              .... ...=U..

0802a3cc <__fsym_list_mem>:
 802a3cc:	0802906c 08029078 08018179              l...x...y...

0802a3d8 <__fsym_nand_id>:
 802a3d8:	0802931c 08029324 0801a499              ....$.......

0802a3e4 <__fsym_nand_read>:
 802a3e4:	0802933c 08029348 0801a4d1              <...H.......

0802a3f0 <__fsym_nand_readoob>:
 802a3f0:	0802937c 0802938c 0801a5bd              |...........

0802a3fc <__fsym_nand_write>:
 802a3fc:	080293c8 080293d4 0801a65d              ........]...

0802a408 <__fsym_nand_erase>:
 802a408:	0802940c 08029418 0801a765              ........e...

0802a414 <__fsym_nand_erase_all>:
 802a414:	08029430 08029440 0801a7a1              0...@.......

0802a420 <__fsym_list_date>:
 802a420:	08029478 08029484 0801a989              x...........

0802a42c <__fsym_set_date>:
 802a42c:	08029498 080294a4 0801a86d              ........m...

0802a438 <__fsym_set_time>:
 802a438:	080294c8 080294d4 0801a8fd              ............

0802a444 <__fsym___cmd_canstat>:
 802a444:	080295d8 080295e8 0801c221              ........!...

0802a450 <__fsym_hello>:
 802a450:	080296b8 080296c0 0801ce71              ........q...

0802a45c <__fsym_version>:
 802a45c:	080296d0 080296d8 0801ce85              ............

0802a468 <__fsym___cmd_version>:
 802a468:	080296fc 0802970c 0801ce85              ............

0802a474 <__fsym_list_thread>:
 802a474:	08029730 0802973c 0801cf9d              0...<.......

0802a480 <__fsym___cmd_list_thread>:
 802a480:	08029748 0802975c 0801cf9d              H...\.......

0802a48c <__fsym_list_sem>:
 802a48c:	08029768 08029774 0801d0b1              h...t.......

0802a498 <__fsym___cmd_list_sem>:
 802a498:	08029790 080297a0 0801d0b1              ............

0802a4a4 <__fsym_list_event>:
 802a4a4:	080297bc 080297c8 0801d165              ........e...

0802a4b0 <__fsym___cmd_list_event>:
 802a4b0:	080297e0 080297f4 0801d165              ........e...

0802a4bc <__fsym_list_mutex>:
 802a4bc:	0802980c 08029818 0801d1ed              ............

0802a4c8 <__fsym___cmd_list_mutex>:
 802a4c8:	08029830 08029844 0801d1ed              0...D.......

0802a4d4 <__fsym_list_mailbox>:
 802a4d4:	0802985c 0802986c 0801d2c5              \...l.......

0802a4e0 <__fsym___cmd_list_mailbox>:
 802a4e0:	08029884 08029898 0801d2c5              ............

0802a4ec <__fsym_list_msgqueue>:
 802a4ec:	080298b0 080298c0 0801d38d              ............

0802a4f8 <__fsym___cmd_list_msgqueue>:
 802a4f8:	080298e0 080298f4 0801d38d              ............

0802a504 <__fsym_list_memheap>:
 802a504:	08029914 08029924 0801d405              ....$.......

0802a510 <__fsym___cmd_list_memheap>:
 802a510:	08029940 08029954 0801d405              @...T.......

0802a51c <__fsym_list_mempool>:
 802a51c:	08029970 08029980 0801d4c9              p...........

0802a528 <__fsym___cmd_list_mempool>:
 802a528:	0802999c 080299b0 0801d4c9              ............

0802a534 <__fsym_list_timer>:
 802a534:	080299cc 080299d8 0801d56d              ........m...

0802a540 <__fsym___cmd_list_timer>:
 802a540:	080299f0 08029a04 0801d56d              ........m...

0802a54c <__fsym_list_device>:
 802a54c:	08029a1c 08029a28 0801d609              ....(.......

0802a558 <__fsym___cmd_list_device>:
 802a558:	08029a40 08029a54 0801d609              @...T.......

0802a564 <__fsym_list>:
 802a564:	08029a6c 08029a74 0801d61d              l...t.......

0802a570 <__fsym___cmd_ps>:
 802a570:	08029ab4 08029ac0 0801da39              ........9...

0802a57c <__fsym___cmd_time>:
 802a57c:	08029adc 08029ae8 0801da51              ........Q...

0802a588 <__fsym___cmd_free>:
 802a588:	08029b04 08029b10 0801da69              ........i...

0802a594 <__fsym___cmd_exit>:
 802a594:	08029b38 08029b44 0801da99              8...D.......

0802a5a0 <__fsym_msh>:
 802a5a0:	08029b64 08029b68 0801dabd              d...h.......

0802a5ac <__fsym___cmd_help>:
 802a5ac:	08029b7c 08029b88 0801dad9              |...........

0802a5b8 <__fsymtab_end>:
 802a5b8:	08029a90 	.word	0x08029a90
 802a5bc:	08029a98 	.word	0x08029a98
 802a5c0:	00000009 	.word	0x00000009
 802a5c4:	2001219c 	.word	0x2001219c

0802a5c8 <__rt_init_rti_start>:
 802a5c8:	08015ac1                                .Z..

0802a5cc <__rt_init_Can_hw_init>:
 802a5cc:	08012795                                .'..

0802a5d0 <__rt_init_stm32_hw_usart_init>:
 802a5d0:	08014c49                                IL..

0802a5d4 <__rt_init_USER_Motor_hwinit>:
 802a5d4:	080151d5                                .Q..

0802a5d8 <__rt_init_rti_board_end>:
 802a5d8:	08015ad1                                .Z..

0802a5dc <__rt_init_rt_i2c_core_init>:
 802a5dc:	0801a30d                                ....

0802a5e0 <__rt_init_finsh_system_init>:
 802a5e0:	0801cd59                                Y...

0802a5e4 <__rt_init_libc_system_init>:
 802a5e4:	080199ed                                ....

0802a5e8 <__rt_init_USER_CanTask_init>:
 802a5e8:	08014fa1                                .O..

0802a5ec <__rt_init_J1939_RcvTask_init>:
 802a5ec:	08015049                                IP..

0802a5f0 <__rt_init_USER_MotorTask_init>:
 802a5f0:	08015565                                eU..

0802a5f4 <__rt_init_USER_Usart3txTask_init>:
 802a5f4:	0801577d                                }W..

0802a5f8 <__rt_init_USER_Usart3rxTask_init>:
 802a5f8:	08015995                                .Y..

0802a5fc <__rt_init_rti_end>:
 802a5fc:	08015ae1                                .Z..
