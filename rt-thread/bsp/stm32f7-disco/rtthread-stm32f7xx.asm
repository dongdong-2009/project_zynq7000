
rtthread-stm32f7xx.axf:     file format elf32-littlearm


Disassembly of section .text:

08000000 <_stext>:
 8000000:	200107ec 	.word	0x200107ec
 8000004:	0800fbfd 	.word	0x0800fbfd
 8000008:	08014529 	.word	0x08014529
 800000c:	080002ab 	.word	0x080002ab
 8000010:	0800fc4d 	.word	0x0800fc4d
 8000014:	08014535 	.word	0x08014535
 8000018:	0801453d 	.word	0x0801453d
	...
 800002c:	0800fc4d 	.word	0x0800fc4d
 8000030:	08014545 	.word	0x08014545
 8000034:	00000000 	.word	0x00000000
 8000038:	080001f9 	.word	0x080001f9
 800003c:	0801225d 	.word	0x0801225d
 8000040:	0800fc4d 	.word	0x0800fc4d
 8000044:	0800fc4d 	.word	0x0800fc4d
 8000048:	0800fc4d 	.word	0x0800fc4d
 800004c:	0800fc4d 	.word	0x0800fc4d
 8000050:	0800fc4d 	.word	0x0800fc4d
 8000054:	0800fc4d 	.word	0x0800fc4d
 8000058:	0800fc4d 	.word	0x0800fc4d
 800005c:	0800fc4d 	.word	0x0800fc4d
 8000060:	0800fc4d 	.word	0x0800fc4d
 8000064:	0800fc4d 	.word	0x0800fc4d
 8000068:	0800fc4d 	.word	0x0800fc4d
 800006c:	0800fc4d 	.word	0x0800fc4d
 8000070:	0801425d 	.word	0x0801425d
 8000074:	0800fc4d 	.word	0x0800fc4d
 8000078:	0800fc4d 	.word	0x0800fc4d
 800007c:	0800fc4d 	.word	0x0800fc4d
 8000080:	0800fc4d 	.word	0x0800fc4d
 8000084:	0800fc4d 	.word	0x0800fc4d
 8000088:	08012b85 	.word	0x08012b85
 800008c:	0801192d 	.word	0x0801192d
 8000090:	08011965 	.word	0x08011965
 8000094:	08011989 	.word	0x08011989
 8000098:	08011a81 	.word	0x08011a81
 800009c:	0800fc4d 	.word	0x0800fc4d
 80000a0:	0800fc4d 	.word	0x0800fc4d
 80000a4:	0800fc4d 	.word	0x0800fc4d
 80000a8:	0800fc4d 	.word	0x0800fc4d
 80000ac:	0800fc4d 	.word	0x0800fc4d
 80000b0:	0800fc4d 	.word	0x0800fc4d
 80000b4:	0800fc4d 	.word	0x0800fc4d
 80000b8:	0800fc4d 	.word	0x0800fc4d
 80000bc:	0800fc4d 	.word	0x0800fc4d
 80000c0:	0800fc4d 	.word	0x0800fc4d
 80000c4:	0800fc4d 	.word	0x0800fc4d
 80000c8:	0800fc4d 	.word	0x0800fc4d
 80000cc:	0800fc4d 	.word	0x0800fc4d
 80000d0:	0800fc4d 	.word	0x0800fc4d
 80000d4:	080141b5 	.word	0x080141b5
 80000d8:	0800fc4d 	.word	0x0800fc4d
 80000dc:	08014209 	.word	0x08014209
 80000e0:	0800fc4d 	.word	0x0800fc4d
 80000e4:	0800fc4d 	.word	0x0800fc4d
 80000e8:	0800fc4d 	.word	0x0800fc4d
 80000ec:	08013875 	.word	0x08013875
 80000f0:	08013899 	.word	0x08013899
 80000f4:	0800fc4d 	.word	0x0800fc4d
 80000f8:	0800fc4d 	.word	0x0800fc4d
 80000fc:	0800fc4d 	.word	0x0800fc4d
 8000100:	0800fc4d 	.word	0x0800fc4d
 8000104:	0800fc4d 	.word	0x0800fc4d
 8000108:	080131ad 	.word	0x080131ad
 800010c:	0800fc4d 	.word	0x0800fc4d
 8000110:	0800fc4d 	.word	0x0800fc4d
 8000114:	0800fc4d 	.word	0x0800fc4d
 8000118:	0800fc4d 	.word	0x0800fc4d
 800011c:	0800fc4d 	.word	0x0800fc4d
 8000120:	08013815 	.word	0x08013815
 8000124:	0800fc4d 	.word	0x0800fc4d
 8000128:	0800fc4d 	.word	0x0800fc4d
 800012c:	0800fc4d 	.word	0x0800fc4d
 8000130:	0800fc4d 	.word	0x0800fc4d
 8000134:	0800fc4d 	.word	0x0800fc4d
 8000138:	0800fc4d 	.word	0x0800fc4d
 800013c:	0800fc4d 	.word	0x0800fc4d
 8000140:	0800fc4d 	.word	0x0800fc4d
 8000144:	0800fc4d 	.word	0x0800fc4d
 8000148:	0800fc4d 	.word	0x0800fc4d
 800014c:	0800fc4d 	.word	0x0800fc4d
 8000150:	0800fc4d 	.word	0x0800fc4d
 8000154:	0800fc4d 	.word	0x0800fc4d
 8000158:	0800fc4d 	.word	0x0800fc4d
 800015c:	0800fc4d 	.word	0x0800fc4d
 8000160:	0800fc4d 	.word	0x0800fc4d
 8000164:	0800fc4d 	.word	0x0800fc4d
 8000168:	0800fc4d 	.word	0x0800fc4d
 800016c:	0800fc4d 	.word	0x0800fc4d
 8000170:	0800fc4d 	.word	0x0800fc4d
 8000174:	0800fc4d 	.word	0x0800fc4d
 8000178:	0800fc4d 	.word	0x0800fc4d
 800017c:	00000000 	.word	0x00000000
 8000180:	0800fc4d 	.word	0x0800fc4d
 8000184:	0800fc4d 	.word	0x0800fc4d
 8000188:	0800fc4d 	.word	0x0800fc4d
 800018c:	0800fc4d 	.word	0x0800fc4d
 8000190:	0800fc4d 	.word	0x0800fc4d
 8000194:	0800fc4d 	.word	0x0800fc4d
 8000198:	0800fc4d 	.word	0x0800fc4d
 800019c:	0800fc4d 	.word	0x0800fc4d
 80001a0:	0800fc4d 	.word	0x0800fc4d
 80001a4:	0800fc4d 	.word	0x0800fc4d
 80001a8:	0800fc4d 	.word	0x0800fc4d
 80001ac:	0800fc4d 	.word	0x0800fc4d
 80001b0:	0800fc4d 	.word	0x0800fc4d
 80001b4:	0800fc4d 	.word	0x0800fc4d
 80001b8:	0800fc4d 	.word	0x0800fc4d
 80001bc:	0800fc4d 	.word	0x0800fc4d
 80001c0:	0800fc4d 	.word	0x0800fc4d
 80001c4:	0800fc4d 	.word	0x0800fc4d

080001c8 <mymul>:
.text
.global mymul
mymul:
		//vmul.f64	d0, d0, d1			
		mov pc, lr
 80001c8:	46f7      	mov	pc, lr
	...

080001cc <rt_hw_interrupt_disable>:
 * rt_base_t rt_hw_interrupt_disable();
 */
.global rt_hw_interrupt_disable
.type rt_hw_interrupt_disable, %function
rt_hw_interrupt_disable:
    MRS     r0, PRIMASK
 80001cc:	f3ef 8010 	mrs	r0, PRIMASK
    CPSID   I
 80001d0:	b672      	cpsid	i
    BX      LR
 80001d2:	4770      	bx	lr

080001d4 <rt_hw_interrupt_enable>:
 * void rt_hw_interrupt_enable(rt_base_t level);
 */
.global rt_hw_interrupt_enable
.type rt_hw_interrupt_enable, %function
rt_hw_interrupt_enable:
    MSR     PRIMASK, r0
 80001d4:	f380 8810 	msr	PRIMASK, r0
    BX      LR
 80001d8:	4770      	bx	lr

080001da <rt_hw_context_switch>:
.type rt_hw_context_switch, %function

rt_hw_context_switch_interrupt:
rt_hw_context_switch:
    /* set rt_thread_switch_interrupt_flag to 1 */
    LDR     r2, =rt_thread_switch_interrupt_flag
 80001da:	4a39      	ldr	r2, [pc, #228]	; (80002c0 <HardFault_Handler+0x16>)
    LDR     r3, [r2]
 80001dc:	6813      	ldr	r3, [r2, #0]
    CMP     r3, #1
 80001de:	2b01      	cmp	r3, #1
    BEQ     _reswitch
 80001e0:	d004      	beq.n	80001ec <_reswitch>
    MOV     r3, #1
 80001e2:	f04f 0301 	mov.w	r3, #1
    STR     r3, [r2]
 80001e6:	6013      	str	r3, [r2, #0]

    LDR     r2, =rt_interrupt_from_thread   /* set rt_interrupt_from_thread */
 80001e8:	4a36      	ldr	r2, [pc, #216]	; (80002c4 <HardFault_Handler+0x1a>)
    STR     r0, [r2]
 80001ea:	6010      	str	r0, [r2, #0]

080001ec <_reswitch>:

_reswitch:
    LDR     r2, =rt_interrupt_to_thread     /* set rt_interrupt_to_thread */
 80001ec:	4a36      	ldr	r2, [pc, #216]	; (80002c8 <HardFault_Handler+0x1e>)
    STR     r1, [r2]
 80001ee:	6011      	str	r1, [r2, #0]

    LDR r0, =NVIC_INT_CTRL              /* trigger the PendSV exception (causes context switch) */
 80001f0:	4836      	ldr	r0, [pc, #216]	; (80002cc <HardFault_Handler+0x22>)
    LDR r1, =NVIC_PENDSVSET
 80001f2:	4937      	ldr	r1, [pc, #220]	; (80002d0 <HardFault_Handler+0x26>)
    STR r1, [r0]
 80001f4:	6001      	str	r1, [r0, #0]
    BX  LR
 80001f6:	4770      	bx	lr

080001f8 <PendSV_Handler>:
 */
.global PendSV_Handler
.type PendSV_Handler, %function
PendSV_Handler:
    /* disable interrupt to protect context switch */
    MRS r2, PRIMASK
 80001f8:	f3ef 8210 	mrs	r2, PRIMASK
    CPSID   I
 80001fc:	b672      	cpsid	i

    /* get rt_thread_switch_interrupt_flag */
    LDR r0, =rt_thread_switch_interrupt_flag
 80001fe:	4830      	ldr	r0, [pc, #192]	; (80002c0 <HardFault_Handler+0x16>)
    LDR r1, [r0]
 8000200:	6801      	ldr	r1, [r0, #0]
    CBZ r1, pendsv_exit         /* pendsv already handled */
 8000202:	b321      	cbz	r1, 800024e <pendsv_exit>

    /* clear rt_thread_switch_interrupt_flag to 0 */
    MOV r1, #0x00
 8000204:	f04f 0100 	mov.w	r1, #0
    STR r1, [r0]
 8000208:	6001      	str	r1, [r0, #0]

    LDR r0, =rt_interrupt_from_thread
 800020a:	482e      	ldr	r0, [pc, #184]	; (80002c4 <HardFault_Handler+0x1a>)
    LDR r1, [r0]
 800020c:	6801      	ldr	r1, [r0, #0]
    CBZ r1, switch_to_thread    /* skip register save at the first time */
 800020e:	b191      	cbz	r1, 8000236 <switch_to_thread>

    MRS r1, psp                 /* get from thread stack pointer */
 8000210:	f3ef 8109 	mrs	r1, PSP
    
#if defined (__VFP_FP__) && !defined(__SOFTFP__)
    TST     lr, #0x10           /* if(!EXC_RETURN[4]) */
 8000214:	f01e 0f10 	tst.w	lr, #16
    VSTMDBEQ r1!, {d8 - d15}    /* push FPU register s16~s31 */
 8000218:	bf08      	it	eq
 800021a:	ed21 8b10 	vstmdbeq	r1!, {d8-d15}
#endif
    
    STMFD   r1!, {r4 - r11}     /* push r4 - r11 register */
 800021e:	e921 0ff0 	stmdb	r1!, {r4, r5, r6, r7, r8, r9, sl, fp}

#if defined (__VFP_FP__) && !defined(__SOFTFP__)
    MOV     r4, #0x00           /* flag = 0 */
 8000222:	f04f 0400 	mov.w	r4, #0

    TST     lr, #0x10           /* if(!EXC_RETURN[4]) */
 8000226:	f01e 0f10 	tst.w	lr, #16
    MOVEQ   r4, #0x01           /* flag = 1 */
 800022a:	bf08      	it	eq
 800022c:	2401      	moveq	r4, #1

    STMFD   r1!, {r4}           /* push flag */
 800022e:	f841 4d04 	str.w	r4, [r1, #-4]!
#endif

    LDR r0, [r0]
 8000232:	6800      	ldr	r0, [r0, #0]
    STR r1, [r0]                /* update from thread stack pointer */
 8000234:	6001      	str	r1, [r0, #0]

08000236 <switch_to_thread>:

switch_to_thread:
    LDR r1, =rt_interrupt_to_thread
 8000236:	4924      	ldr	r1, [pc, #144]	; (80002c8 <HardFault_Handler+0x1e>)
    LDR r1, [r1]
 8000238:	6809      	ldr	r1, [r1, #0]
    LDR r1, [r1]                /* load thread stack pointer */
 800023a:	6809      	ldr	r1, [r1, #0]

#if defined (__VFP_FP__) && !defined(__SOFTFP__)
    LDMFD   r1!, {r3}           /* pop flag */
 800023c:	c908      	ldmia	r1!, {r3}
#endif

    LDMFD   r1!, {r4 - r11}     /* pop r4 - r11 register */
 800023e:	e8b1 0ff0 	ldmia.w	r1!, {r4, r5, r6, r7, r8, r9, sl, fp}

#if defined (__VFP_FP__) && !defined(__SOFTFP__)
    CMP     r3,  #0             /* if(flag_r3 != 0) */
 8000242:	2b00      	cmp	r3, #0
    VLDMIANE  r1!, {d8 - d15}   /* pop FPU register s16~s31 */
 8000244:	bf18      	it	ne
 8000246:	ecb1 8b10 	vldmiane	r1!, {d8-d15}
#endif

    MSR psp, r1                 /* update stack pointer */
 800024a:	f381 8809 	msr	PSP, r1

0800024e <pendsv_exit>:

pendsv_exit:
    /* restore interrupt */
    MSR PRIMASK, r2
 800024e:	f382 8810 	msr	PRIMASK, r2

#if defined (__VFP_FP__) && !defined(__SOFTFP__)
    ORR     lr, lr, #0x10       /* lr |=  (1 << 4), clean FPCA. */
 8000252:	f04e 0e10 	orr.w	lr, lr, #16
    CMP     r3,  #0             /* if(flag_r3 != 0) */
 8000256:	2b00      	cmp	r3, #0
    BICNE   lr, lr, #0x10       /* lr &= ~(1 << 4), set FPCA. */
 8000258:	bf18      	it	ne
 800025a:	f02e 0e10 	bicne.w	lr, lr, #16
#endif

    ORR lr, lr, #0x04
 800025e:	f04e 0e04 	orr.w	lr, lr, #4
    BX  lr
 8000262:	4770      	bx	lr

08000264 <rt_hw_context_switch_to>:
 * r0 --> to
 */
.global rt_hw_context_switch_to
.type rt_hw_context_switch_to, %function
rt_hw_context_switch_to:
    LDR r1, =rt_interrupt_to_thread
 8000264:	4918      	ldr	r1, [pc, #96]	; (80002c8 <HardFault_Handler+0x1e>)
    STR r0, [r1]
 8000266:	6008      	str	r0, [r1, #0]

#if defined (__VFP_FP__) && !defined(__SOFTFP__)
    /* CLEAR CONTROL.FPCA */
    MRS     r2, CONTROL         /* read */
 8000268:	f3ef 8214 	mrs	r2, CONTROL
    BIC     r2, #0x04           /* modify */
 800026c:	f022 0204 	bic.w	r2, r2, #4
    MSR     CONTROL, r2         /* write-back */
 8000270:	f382 8814 	msr	CONTROL, r2
#endif

    /* set from thread to 0 */
    LDR r1, =rt_interrupt_from_thread
 8000274:	4913      	ldr	r1, [pc, #76]	; (80002c4 <HardFault_Handler+0x1a>)
    MOV r0, #0x0
 8000276:	f04f 0000 	mov.w	r0, #0
    STR r0, [r1]
 800027a:	6008      	str	r0, [r1, #0]

    /* set interrupt flag to 1 */
    LDR     r1, =rt_thread_switch_interrupt_flag
 800027c:	4910      	ldr	r1, [pc, #64]	; (80002c0 <HardFault_Handler+0x16>)
    MOV     r0, #1
 800027e:	f04f 0001 	mov.w	r0, #1
    STR     r0, [r1]
 8000282:	6008      	str	r0, [r1, #0]

    /* set the PendSV exception priority */
    LDR r0, =NVIC_SYSPRI2
 8000284:	4813      	ldr	r0, [pc, #76]	; (80002d4 <HardFault_Handler+0x2a>)
    LDR r1, =NVIC_PENDSV_PRI
 8000286:	4914      	ldr	r1, [pc, #80]	; (80002d8 <HardFault_Handler+0x2e>)
    LDR.W   r2, [r0,#0x00]       /* read       */
 8000288:	f8d0 2000 	ldr.w	r2, [r0]
    ORR     r1,r1,r2             /* modify     */
 800028c:	ea41 0102 	orr.w	r1, r1, r2
    STR     r1, [r0]             /* write-back */
 8000290:	6001      	str	r1, [r0, #0]

    LDR r0, =NVIC_INT_CTRL      /* trigger the PendSV exception (causes context switch) */
 8000292:	480e      	ldr	r0, [pc, #56]	; (80002cc <HardFault_Handler+0x22>)
    LDR r1, =NVIC_PENDSVSET
 8000294:	490e      	ldr	r1, [pc, #56]	; (80002d0 <HardFault_Handler+0x26>)
    STR r1, [r0]
 8000296:	6001      	str	r1, [r0, #0]

    /* restore MSP */
    LDR     r0, =SCB_VTOR
 8000298:	4810      	ldr	r0, [pc, #64]	; (80002dc <HardFault_Handler+0x32>)
    LDR     r0, [r0]
 800029a:	6800      	ldr	r0, [r0, #0]
    LDR     r0, [r0]
 800029c:	6800      	ldr	r0, [r0, #0]
    NOP
 800029e:	bf00      	nop
    MSR     msp, r0
 80002a0:	f380 8808 	msr	MSP, r0

    CPSIE   I                       /* enable interrupts at processor level */
 80002a4:	b662      	cpsie	i

080002a6 <rt_hw_interrupt_thread_switch>:

/* compatible with old version */
.global rt_hw_interrupt_thread_switch
.type rt_hw_interrupt_thread_switch, %function
rt_hw_interrupt_thread_switch:
    BX  lr
 80002a6:	4770      	bx	lr
    NOP
 80002a8:	bf00      	nop

080002aa <HardFault_Handler>:

.global HardFault_Handler
.type HardFault_Handler, %function
HardFault_Handler:
    /* get current context */
    MRS     r0, psp                 /* get fault thread stack pointer */
 80002aa:	f3ef 8009 	mrs	r0, PSP
    PUSH    {lr}
 80002ae:	b500      	push	{lr}
    BL      rt_hw_hard_fault_exception
 80002b0:	f018 ff2e 	bl	8019110 <rt_hw_hard_fault_exception>
    POP     {lr}
 80002b4:	f85d eb04 	ldr.w	lr, [sp], #4

    ORR     lr, lr, #0x04
 80002b8:	f04e 0e04 	orr.w	lr, lr, #4
    BX      lr
 80002bc:	4770      	bx	lr
 80002be:	0000      	.short	0x0000
.type rt_hw_context_switch, %function

rt_hw_context_switch_interrupt:
rt_hw_context_switch:
    /* set rt_thread_switch_interrupt_flag to 1 */
    LDR     r2, =rt_thread_switch_interrupt_flag
 80002c0:	20012b8c 	.word	0x20012b8c
    CMP     r3, #1
    BEQ     _reswitch
    MOV     r3, #1
    STR     r3, [r2]

    LDR     r2, =rt_interrupt_from_thread   /* set rt_interrupt_from_thread */
 80002c4:	20012b88 	.word	0x20012b88
    STR     r0, [r2]

_reswitch:
    LDR     r2, =rt_interrupt_to_thread     /* set rt_interrupt_to_thread */
 80002c8:	20012b84 	.word	0x20012b84
    STR     r1, [r2]

    LDR r0, =NVIC_INT_CTRL              /* trigger the PendSV exception (causes context switch) */
 80002cc:	e000ed04 	.word	0xe000ed04
    LDR r1, =NVIC_PENDSVSET
 80002d0:	10000000 	.word	0x10000000
    LDR     r1, =rt_thread_switch_interrupt_flag
    MOV     r0, #1
    STR     r0, [r1]

    /* set the PendSV exception priority */
    LDR r0, =NVIC_SYSPRI2
 80002d4:	e000ed20 	.word	0xe000ed20
    LDR r1, =NVIC_PENDSV_PRI
 80002d8:	00ff0000 	.word	0x00ff0000
    LDR r0, =NVIC_INT_CTRL      /* trigger the PendSV exception (causes context switch) */
    LDR r1, =NVIC_PENDSVSET
    STR r1, [r0]

    /* restore MSP */
    LDR     r0, =SCB_VTOR
 80002dc:	e000ed08 	.word	0xe000ed08

080002e0 <memcpy>:
 80002e0:	4684      	mov	ip, r0
 80002e2:	ea41 0300 	orr.w	r3, r1, r0
 80002e6:	f013 0303 	ands.w	r3, r3, #3
 80002ea:	d16d      	bne.n	80003c8 <memcpy+0xe8>
 80002ec:	3a40      	subs	r2, #64	; 0x40
 80002ee:	d341      	bcc.n	8000374 <memcpy+0x94>
 80002f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002f4:	f840 3b04 	str.w	r3, [r0], #4
 80002f8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002fc:	f840 3b04 	str.w	r3, [r0], #4
 8000300:	f851 3b04 	ldr.w	r3, [r1], #4
 8000304:	f840 3b04 	str.w	r3, [r0], #4
 8000308:	f851 3b04 	ldr.w	r3, [r1], #4
 800030c:	f840 3b04 	str.w	r3, [r0], #4
 8000310:	f851 3b04 	ldr.w	r3, [r1], #4
 8000314:	f840 3b04 	str.w	r3, [r0], #4
 8000318:	f851 3b04 	ldr.w	r3, [r1], #4
 800031c:	f840 3b04 	str.w	r3, [r0], #4
 8000320:	f851 3b04 	ldr.w	r3, [r1], #4
 8000324:	f840 3b04 	str.w	r3, [r0], #4
 8000328:	f851 3b04 	ldr.w	r3, [r1], #4
 800032c:	f840 3b04 	str.w	r3, [r0], #4
 8000330:	f851 3b04 	ldr.w	r3, [r1], #4
 8000334:	f840 3b04 	str.w	r3, [r0], #4
 8000338:	f851 3b04 	ldr.w	r3, [r1], #4
 800033c:	f840 3b04 	str.w	r3, [r0], #4
 8000340:	f851 3b04 	ldr.w	r3, [r1], #4
 8000344:	f840 3b04 	str.w	r3, [r0], #4
 8000348:	f851 3b04 	ldr.w	r3, [r1], #4
 800034c:	f840 3b04 	str.w	r3, [r0], #4
 8000350:	f851 3b04 	ldr.w	r3, [r1], #4
 8000354:	f840 3b04 	str.w	r3, [r0], #4
 8000358:	f851 3b04 	ldr.w	r3, [r1], #4
 800035c:	f840 3b04 	str.w	r3, [r0], #4
 8000360:	f851 3b04 	ldr.w	r3, [r1], #4
 8000364:	f840 3b04 	str.w	r3, [r0], #4
 8000368:	f851 3b04 	ldr.w	r3, [r1], #4
 800036c:	f840 3b04 	str.w	r3, [r0], #4
 8000370:	3a40      	subs	r2, #64	; 0x40
 8000372:	d2bd      	bcs.n	80002f0 <memcpy+0x10>
 8000374:	3230      	adds	r2, #48	; 0x30
 8000376:	d311      	bcc.n	800039c <memcpy+0xbc>
 8000378:	f851 3b04 	ldr.w	r3, [r1], #4
 800037c:	f840 3b04 	str.w	r3, [r0], #4
 8000380:	f851 3b04 	ldr.w	r3, [r1], #4
 8000384:	f840 3b04 	str.w	r3, [r0], #4
 8000388:	f851 3b04 	ldr.w	r3, [r1], #4
 800038c:	f840 3b04 	str.w	r3, [r0], #4
 8000390:	f851 3b04 	ldr.w	r3, [r1], #4
 8000394:	f840 3b04 	str.w	r3, [r0], #4
 8000398:	3a10      	subs	r2, #16
 800039a:	d2ed      	bcs.n	8000378 <memcpy+0x98>
 800039c:	320c      	adds	r2, #12
 800039e:	d305      	bcc.n	80003ac <memcpy+0xcc>
 80003a0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003a4:	f840 3b04 	str.w	r3, [r0], #4
 80003a8:	3a04      	subs	r2, #4
 80003aa:	d2f9      	bcs.n	80003a0 <memcpy+0xc0>
 80003ac:	3204      	adds	r2, #4
 80003ae:	d008      	beq.n	80003c2 <memcpy+0xe2>
 80003b0:	07d2      	lsls	r2, r2, #31
 80003b2:	bf1c      	itt	ne
 80003b4:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003b8:	f800 3b01 	strbne.w	r3, [r0], #1
 80003bc:	d301      	bcc.n	80003c2 <memcpy+0xe2>
 80003be:	880b      	ldrh	r3, [r1, #0]
 80003c0:	8003      	strh	r3, [r0, #0]
 80003c2:	4660      	mov	r0, ip
 80003c4:	4770      	bx	lr
 80003c6:	bf00      	nop
 80003c8:	2a08      	cmp	r2, #8
 80003ca:	d313      	bcc.n	80003f4 <memcpy+0x114>
 80003cc:	078b      	lsls	r3, r1, #30
 80003ce:	d08d      	beq.n	80002ec <memcpy+0xc>
 80003d0:	f010 0303 	ands.w	r3, r0, #3
 80003d4:	d08a      	beq.n	80002ec <memcpy+0xc>
 80003d6:	f1c3 0304 	rsb	r3, r3, #4
 80003da:	1ad2      	subs	r2, r2, r3
 80003dc:	07db      	lsls	r3, r3, #31
 80003de:	bf1c      	itt	ne
 80003e0:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003e4:	f800 3b01 	strbne.w	r3, [r0], #1
 80003e8:	d380      	bcc.n	80002ec <memcpy+0xc>
 80003ea:	f831 3b02 	ldrh.w	r3, [r1], #2
 80003ee:	f820 3b02 	strh.w	r3, [r0], #2
 80003f2:	e77b      	b.n	80002ec <memcpy+0xc>
 80003f4:	3a04      	subs	r2, #4
 80003f6:	d3d9      	bcc.n	80003ac <memcpy+0xcc>
 80003f8:	3a01      	subs	r2, #1
 80003fa:	f811 3b01 	ldrb.w	r3, [r1], #1
 80003fe:	f800 3b01 	strb.w	r3, [r0], #1
 8000402:	d2f9      	bcs.n	80003f8 <memcpy+0x118>
 8000404:	780b      	ldrb	r3, [r1, #0]
 8000406:	7003      	strb	r3, [r0, #0]
 8000408:	784b      	ldrb	r3, [r1, #1]
 800040a:	7043      	strb	r3, [r0, #1]
 800040c:	788b      	ldrb	r3, [r1, #2]
 800040e:	7083      	strb	r3, [r0, #2]
 8000410:	4660      	mov	r0, ip
 8000412:	4770      	bx	lr
	...
 8000420:	eba2 0003 	sub.w	r0, r2, r3
 8000424:	4770      	bx	lr
 8000426:	bf00      	nop

08000428 <strcmp>:
 8000428:	7802      	ldrb	r2, [r0, #0]
 800042a:	780b      	ldrb	r3, [r1, #0]
 800042c:	2a01      	cmp	r2, #1
 800042e:	bf28      	it	cs
 8000430:	429a      	cmpcs	r2, r3
 8000432:	d1f5      	bne.n	8000420 <memcpy+0x140>
 8000434:	e96d 4504 	strd	r4, r5, [sp, #-16]!
 8000438:	ea40 0401 	orr.w	r4, r0, r1
 800043c:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8000440:	f06f 0c00 	mvn.w	ip, #0
 8000444:	ea4f 7244 	mov.w	r2, r4, lsl #29
 8000448:	b312      	cbz	r2, 8000490 <strcmp+0x68>
 800044a:	ea80 0401 	eor.w	r4, r0, r1
 800044e:	f014 0f07 	tst.w	r4, #7
 8000452:	d16a      	bne.n	800052a <strcmp+0x102>
 8000454:	f000 0407 	and.w	r4, r0, #7
 8000458:	f020 0007 	bic.w	r0, r0, #7
 800045c:	f004 0503 	and.w	r5, r4, #3
 8000460:	f021 0107 	bic.w	r1, r1, #7
 8000464:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 8000468:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 800046c:	f014 0f04 	tst.w	r4, #4
 8000470:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8000474:	fa0c f405 	lsl.w	r4, ip, r5
 8000478:	ea62 0204 	orn	r2, r2, r4
 800047c:	ea66 0604 	orn	r6, r6, r4
 8000480:	d00a      	beq.n	8000498 <strcmp+0x70>
 8000482:	ea63 0304 	orn	r3, r3, r4
 8000486:	4662      	mov	r2, ip
 8000488:	ea67 0704 	orn	r7, r7, r4
 800048c:	4666      	mov	r6, ip
 800048e:	e003      	b.n	8000498 <strcmp+0x70>
 8000490:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 8000494:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8000498:	fa82 f54c 	uadd8	r5, r2, ip
 800049c:	ea82 0406 	eor.w	r4, r2, r6
 80004a0:	faa4 f48c 	sel	r4, r4, ip
 80004a4:	bb6c      	cbnz	r4, 8000502 <strcmp+0xda>
 80004a6:	fa83 f54c 	uadd8	r5, r3, ip
 80004aa:	ea83 0507 	eor.w	r5, r3, r7
 80004ae:	faa5 f58c 	sel	r5, r5, ip
 80004b2:	b995      	cbnz	r5, 80004da <strcmp+0xb2>
 80004b4:	e950 2302 	ldrd	r2, r3, [r0, #-8]
 80004b8:	e951 6702 	ldrd	r6, r7, [r1, #-8]
 80004bc:	fa82 f54c 	uadd8	r5, r2, ip
 80004c0:	ea82 0406 	eor.w	r4, r2, r6
 80004c4:	faa4 f48c 	sel	r4, r4, ip
 80004c8:	fa83 f54c 	uadd8	r5, r3, ip
 80004cc:	ea83 0507 	eor.w	r5, r3, r7
 80004d0:	faa5 f58c 	sel	r5, r5, ip
 80004d4:	4325      	orrs	r5, r4
 80004d6:	d0db      	beq.n	8000490 <strcmp+0x68>
 80004d8:	b99c      	cbnz	r4, 8000502 <strcmp+0xda>
 80004da:	ba2d      	rev	r5, r5
 80004dc:	fab5 f485 	clz	r4, r5
 80004e0:	f024 0407 	bic.w	r4, r4, #7
 80004e4:	fa27 f104 	lsr.w	r1, r7, r4
 80004e8:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 80004ec:	fa23 f304 	lsr.w	r3, r3, r4
 80004f0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 80004f4:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80004f8:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80004fc:	eba0 0001 	sub.w	r0, r0, r1
 8000500:	4770      	bx	lr
 8000502:	ba24      	rev	r4, r4
 8000504:	fab4 f484 	clz	r4, r4
 8000508:	f024 0407 	bic.w	r4, r4, #7
 800050c:	fa26 f104 	lsr.w	r1, r6, r4
 8000510:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8000514:	fa22 f204 	lsr.w	r2, r2, r4
 8000518:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800051c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000520:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000524:	eba0 0001 	sub.w	r0, r0, r1
 8000528:	4770      	bx	lr
 800052a:	f014 0f03 	tst.w	r4, #3
 800052e:	d13c      	bne.n	80005aa <strcmp+0x182>
 8000530:	f010 0403 	ands.w	r4, r0, #3
 8000534:	d128      	bne.n	8000588 <strcmp+0x160>
 8000536:	f850 2b08 	ldr.w	r2, [r0], #8
 800053a:	f851 3b08 	ldr.w	r3, [r1], #8
 800053e:	fa82 f54c 	uadd8	r5, r2, ip
 8000542:	ea82 0503 	eor.w	r5, r2, r3
 8000546:	faa5 f58c 	sel	r5, r5, ip
 800054a:	b95d      	cbnz	r5, 8000564 <strcmp+0x13c>
 800054c:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8000550:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8000554:	fa82 f54c 	uadd8	r5, r2, ip
 8000558:	ea82 0503 	eor.w	r5, r2, r3
 800055c:	faa5 f58c 	sel	r5, r5, ip
 8000560:	2d00      	cmp	r5, #0
 8000562:	d0e8      	beq.n	8000536 <strcmp+0x10e>
 8000564:	ba2d      	rev	r5, r5
 8000566:	fab5 f485 	clz	r4, r5
 800056a:	f024 0407 	bic.w	r4, r4, #7
 800056e:	fa23 f104 	lsr.w	r1, r3, r4
 8000572:	fa22 f204 	lsr.w	r2, r2, r4
 8000576:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800057a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800057e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000582:	eba0 0001 	sub.w	r0, r0, r1
 8000586:	4770      	bx	lr
 8000588:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 800058c:	f020 0003 	bic.w	r0, r0, #3
 8000590:	f850 2b08 	ldr.w	r2, [r0], #8
 8000594:	f021 0103 	bic.w	r1, r1, #3
 8000598:	f851 3b08 	ldr.w	r3, [r1], #8
 800059c:	fa0c f404 	lsl.w	r4, ip, r4
 80005a0:	ea62 0204 	orn	r2, r2, r4
 80005a4:	ea63 0304 	orn	r3, r3, r4
 80005a8:	e7c9      	b.n	800053e <strcmp+0x116>
 80005aa:	f010 0403 	ands.w	r4, r0, #3
 80005ae:	d01a      	beq.n	80005e6 <strcmp+0x1be>
 80005b0:	eba1 0104 	sub.w	r1, r1, r4
 80005b4:	f020 0003 	bic.w	r0, r0, #3
 80005b8:	07e4      	lsls	r4, r4, #31
 80005ba:	f850 2b04 	ldr.w	r2, [r0], #4
 80005be:	d006      	beq.n	80005ce <strcmp+0x1a6>
 80005c0:	d20f      	bcs.n	80005e2 <strcmp+0x1ba>
 80005c2:	788b      	ldrb	r3, [r1, #2]
 80005c4:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
 80005c8:	1ae4      	subs	r4, r4, r3
 80005ca:	d106      	bne.n	80005da <strcmp+0x1b2>
 80005cc:	b12b      	cbz	r3, 80005da <strcmp+0x1b2>
 80005ce:	78cb      	ldrb	r3, [r1, #3]
 80005d0:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
 80005d4:	1ae4      	subs	r4, r4, r3
 80005d6:	d100      	bne.n	80005da <strcmp+0x1b2>
 80005d8:	b91b      	cbnz	r3, 80005e2 <strcmp+0x1ba>
 80005da:	4620      	mov	r0, r4
 80005dc:	f85d 4b10 	ldr.w	r4, [sp], #16
 80005e0:	4770      	bx	lr
 80005e2:	f101 0104 	add.w	r1, r1, #4
 80005e6:	f850 2b04 	ldr.w	r2, [r0], #4
 80005ea:	07cc      	lsls	r4, r1, #31
 80005ec:	f021 0103 	bic.w	r1, r1, #3
 80005f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80005f4:	d848      	bhi.n	8000688 <strcmp+0x260>
 80005f6:	d224      	bcs.n	8000642 <strcmp+0x21a>
 80005f8:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
 80005fc:	fa82 f54c 	uadd8	r5, r2, ip
 8000600:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
 8000604:	faa5 f58c 	sel	r5, r5, ip
 8000608:	d10a      	bne.n	8000620 <strcmp+0x1f8>
 800060a:	b965      	cbnz	r5, 8000626 <strcmp+0x1fe>
 800060c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000610:	ea84 0402 	eor.w	r4, r4, r2
 8000614:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
 8000618:	d10e      	bne.n	8000638 <strcmp+0x210>
 800061a:	f850 2b04 	ldr.w	r2, [r0], #4
 800061e:	e7eb      	b.n	80005f8 <strcmp+0x1d0>
 8000620:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8000624:	e055      	b.n	80006d2 <strcmp+0x2aa>
 8000626:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
 800062a:	d14d      	bne.n	80006c8 <strcmp+0x2a0>
 800062c:	7808      	ldrb	r0, [r1, #0]
 800062e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000632:	f1c0 0000 	rsb	r0, r0, #0
 8000636:	4770      	bx	lr
 8000638:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800063c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8000640:	e047      	b.n	80006d2 <strcmp+0x2aa>
 8000642:	ea02 441c 	and.w	r4, r2, ip, lsr #16
 8000646:	fa82 f54c 	uadd8	r5, r2, ip
 800064a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
 800064e:	faa5 f58c 	sel	r5, r5, ip
 8000652:	d10a      	bne.n	800066a <strcmp+0x242>
 8000654:	b965      	cbnz	r5, 8000670 <strcmp+0x248>
 8000656:	f851 3b04 	ldr.w	r3, [r1], #4
 800065a:	ea84 0402 	eor.w	r4, r4, r2
 800065e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
 8000662:	d10c      	bne.n	800067e <strcmp+0x256>
 8000664:	f850 2b04 	ldr.w	r2, [r0], #4
 8000668:	e7eb      	b.n	8000642 <strcmp+0x21a>
 800066a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800066e:	e030      	b.n	80006d2 <strcmp+0x2aa>
 8000670:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
 8000674:	d128      	bne.n	80006c8 <strcmp+0x2a0>
 8000676:	880b      	ldrh	r3, [r1, #0]
 8000678:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800067c:	e029      	b.n	80006d2 <strcmp+0x2aa>
 800067e:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8000682:	ea03 431c 	and.w	r3, r3, ip, lsr #16
 8000686:	e024      	b.n	80006d2 <strcmp+0x2aa>
 8000688:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 800068c:	fa82 f54c 	uadd8	r5, r2, ip
 8000690:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
 8000694:	faa5 f58c 	sel	r5, r5, ip
 8000698:	d10a      	bne.n	80006b0 <strcmp+0x288>
 800069a:	b965      	cbnz	r5, 80006b6 <strcmp+0x28e>
 800069c:	f851 3b04 	ldr.w	r3, [r1], #4
 80006a0:	ea84 0402 	eor.w	r4, r4, r2
 80006a4:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
 80006a8:	d109      	bne.n	80006be <strcmp+0x296>
 80006aa:	f850 2b04 	ldr.w	r2, [r0], #4
 80006ae:	e7eb      	b.n	8000688 <strcmp+0x260>
 80006b0:	ea4f 6313 	mov.w	r3, r3, lsr #24
 80006b4:	e00d      	b.n	80006d2 <strcmp+0x2aa>
 80006b6:	f015 0fff 	tst.w	r5, #255	; 0xff
 80006ba:	d105      	bne.n	80006c8 <strcmp+0x2a0>
 80006bc:	680b      	ldr	r3, [r1, #0]
 80006be:	ea4f 2212 	mov.w	r2, r2, lsr #8
 80006c2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80006c6:	e004      	b.n	80006d2 <strcmp+0x2aa>
 80006c8:	f04f 0000 	mov.w	r0, #0
 80006cc:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80006d0:	4770      	bx	lr
 80006d2:	ba12      	rev	r2, r2
 80006d4:	ba1b      	rev	r3, r3
 80006d6:	fa82 f44c 	uadd8	r4, r2, ip
 80006da:	ea82 0403 	eor.w	r4, r2, r3
 80006de:	faa4 f58c 	sel	r5, r4, ip
 80006e2:	fab5 f485 	clz	r4, r5
 80006e6:	fa02 f204 	lsl.w	r2, r2, r4
 80006ea:	fa03 f304 	lsl.w	r3, r3, r4
 80006ee:	ea4f 6012 	mov.w	r0, r2, lsr #24
 80006f2:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80006f6:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
 80006fa:	4770      	bx	lr
 80006fc:	f3af 8000 	nop.w

08000700 <__aeabi_drsub>:
 8000700:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000704:	e002      	b.n	800070c <__adddf3>
 8000706:	bf00      	nop

08000708 <__aeabi_dsub>:
 8000708:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800070c <__adddf3>:
 800070c:	b530      	push	{r4, r5, lr}
 800070e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8000712:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000716:	ea94 0f05 	teq	r4, r5
 800071a:	bf08      	it	eq
 800071c:	ea90 0f02 	teqeq	r0, r2
 8000720:	bf1f      	itttt	ne
 8000722:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000726:	ea55 0c02 	orrsne.w	ip, r5, r2
 800072a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800072e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000732:	f000 80e2 	beq.w	80008fa <__adddf3+0x1ee>
 8000736:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800073a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800073e:	bfb8      	it	lt
 8000740:	426d      	neglt	r5, r5
 8000742:	dd0c      	ble.n	800075e <__adddf3+0x52>
 8000744:	442c      	add	r4, r5
 8000746:	ea80 0202 	eor.w	r2, r0, r2
 800074a:	ea81 0303 	eor.w	r3, r1, r3
 800074e:	ea82 0000 	eor.w	r0, r2, r0
 8000752:	ea83 0101 	eor.w	r1, r3, r1
 8000756:	ea80 0202 	eor.w	r2, r0, r2
 800075a:	ea81 0303 	eor.w	r3, r1, r3
 800075e:	2d36      	cmp	r5, #54	; 0x36
 8000760:	bf88      	it	hi
 8000762:	bd30      	pophi	{r4, r5, pc}
 8000764:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000768:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800076c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000770:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000774:	d002      	beq.n	800077c <__adddf3+0x70>
 8000776:	4240      	negs	r0, r0
 8000778:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800077c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000780:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000784:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000788:	d002      	beq.n	8000790 <__adddf3+0x84>
 800078a:	4252      	negs	r2, r2
 800078c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000790:	ea94 0f05 	teq	r4, r5
 8000794:	f000 80a7 	beq.w	80008e6 <__adddf3+0x1da>
 8000798:	f1a4 0401 	sub.w	r4, r4, #1
 800079c:	f1d5 0e20 	rsbs	lr, r5, #32
 80007a0:	db0d      	blt.n	80007be <__adddf3+0xb2>
 80007a2:	fa02 fc0e 	lsl.w	ip, r2, lr
 80007a6:	fa22 f205 	lsr.w	r2, r2, r5
 80007aa:	1880      	adds	r0, r0, r2
 80007ac:	f141 0100 	adc.w	r1, r1, #0
 80007b0:	fa03 f20e 	lsl.w	r2, r3, lr
 80007b4:	1880      	adds	r0, r0, r2
 80007b6:	fa43 f305 	asr.w	r3, r3, r5
 80007ba:	4159      	adcs	r1, r3
 80007bc:	e00e      	b.n	80007dc <__adddf3+0xd0>
 80007be:	f1a5 0520 	sub.w	r5, r5, #32
 80007c2:	f10e 0e20 	add.w	lr, lr, #32
 80007c6:	2a01      	cmp	r2, #1
 80007c8:	fa03 fc0e 	lsl.w	ip, r3, lr
 80007cc:	bf28      	it	cs
 80007ce:	f04c 0c02 	orrcs.w	ip, ip, #2
 80007d2:	fa43 f305 	asr.w	r3, r3, r5
 80007d6:	18c0      	adds	r0, r0, r3
 80007d8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80007dc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80007e0:	d507      	bpl.n	80007f2 <__adddf3+0xe6>
 80007e2:	f04f 0e00 	mov.w	lr, #0
 80007e6:	f1dc 0c00 	rsbs	ip, ip, #0
 80007ea:	eb7e 0000 	sbcs.w	r0, lr, r0
 80007ee:	eb6e 0101 	sbc.w	r1, lr, r1
 80007f2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80007f6:	d31b      	bcc.n	8000830 <__adddf3+0x124>
 80007f8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80007fc:	d30c      	bcc.n	8000818 <__adddf3+0x10c>
 80007fe:	0849      	lsrs	r1, r1, #1
 8000800:	ea5f 0030 	movs.w	r0, r0, rrx
 8000804:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000808:	f104 0401 	add.w	r4, r4, #1
 800080c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000810:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000814:	f080 809a 	bcs.w	800094c <__adddf3+0x240>
 8000818:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800081c:	bf08      	it	eq
 800081e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000822:	f150 0000 	adcs.w	r0, r0, #0
 8000826:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800082a:	ea41 0105 	orr.w	r1, r1, r5
 800082e:	bd30      	pop	{r4, r5, pc}
 8000830:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000834:	4140      	adcs	r0, r0
 8000836:	eb41 0101 	adc.w	r1, r1, r1
 800083a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800083e:	f1a4 0401 	sub.w	r4, r4, #1
 8000842:	d1e9      	bne.n	8000818 <__adddf3+0x10c>
 8000844:	f091 0f00 	teq	r1, #0
 8000848:	bf04      	itt	eq
 800084a:	4601      	moveq	r1, r0
 800084c:	2000      	moveq	r0, #0
 800084e:	fab1 f381 	clz	r3, r1
 8000852:	bf08      	it	eq
 8000854:	3320      	addeq	r3, #32
 8000856:	f1a3 030b 	sub.w	r3, r3, #11
 800085a:	f1b3 0220 	subs.w	r2, r3, #32
 800085e:	da0c      	bge.n	800087a <__adddf3+0x16e>
 8000860:	320c      	adds	r2, #12
 8000862:	dd08      	ble.n	8000876 <__adddf3+0x16a>
 8000864:	f102 0c14 	add.w	ip, r2, #20
 8000868:	f1c2 020c 	rsb	r2, r2, #12
 800086c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000870:	fa21 f102 	lsr.w	r1, r1, r2
 8000874:	e00c      	b.n	8000890 <__adddf3+0x184>
 8000876:	f102 0214 	add.w	r2, r2, #20
 800087a:	bfd8      	it	le
 800087c:	f1c2 0c20 	rsble	ip, r2, #32
 8000880:	fa01 f102 	lsl.w	r1, r1, r2
 8000884:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000888:	bfdc      	itt	le
 800088a:	ea41 010c 	orrle.w	r1, r1, ip
 800088e:	4090      	lslle	r0, r2
 8000890:	1ae4      	subs	r4, r4, r3
 8000892:	bfa2      	ittt	ge
 8000894:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000898:	4329      	orrge	r1, r5
 800089a:	bd30      	popge	{r4, r5, pc}
 800089c:	ea6f 0404 	mvn.w	r4, r4
 80008a0:	3c1f      	subs	r4, #31
 80008a2:	da1c      	bge.n	80008de <__adddf3+0x1d2>
 80008a4:	340c      	adds	r4, #12
 80008a6:	dc0e      	bgt.n	80008c6 <__adddf3+0x1ba>
 80008a8:	f104 0414 	add.w	r4, r4, #20
 80008ac:	f1c4 0220 	rsb	r2, r4, #32
 80008b0:	fa20 f004 	lsr.w	r0, r0, r4
 80008b4:	fa01 f302 	lsl.w	r3, r1, r2
 80008b8:	ea40 0003 	orr.w	r0, r0, r3
 80008bc:	fa21 f304 	lsr.w	r3, r1, r4
 80008c0:	ea45 0103 	orr.w	r1, r5, r3
 80008c4:	bd30      	pop	{r4, r5, pc}
 80008c6:	f1c4 040c 	rsb	r4, r4, #12
 80008ca:	f1c4 0220 	rsb	r2, r4, #32
 80008ce:	fa20 f002 	lsr.w	r0, r0, r2
 80008d2:	fa01 f304 	lsl.w	r3, r1, r4
 80008d6:	ea40 0003 	orr.w	r0, r0, r3
 80008da:	4629      	mov	r1, r5
 80008dc:	bd30      	pop	{r4, r5, pc}
 80008de:	fa21 f004 	lsr.w	r0, r1, r4
 80008e2:	4629      	mov	r1, r5
 80008e4:	bd30      	pop	{r4, r5, pc}
 80008e6:	f094 0f00 	teq	r4, #0
 80008ea:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80008ee:	bf06      	itte	eq
 80008f0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80008f4:	3401      	addeq	r4, #1
 80008f6:	3d01      	subne	r5, #1
 80008f8:	e74e      	b.n	8000798 <__adddf3+0x8c>
 80008fa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80008fe:	bf18      	it	ne
 8000900:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000904:	d029      	beq.n	800095a <__adddf3+0x24e>
 8000906:	ea94 0f05 	teq	r4, r5
 800090a:	bf08      	it	eq
 800090c:	ea90 0f02 	teqeq	r0, r2
 8000910:	d005      	beq.n	800091e <__adddf3+0x212>
 8000912:	ea54 0c00 	orrs.w	ip, r4, r0
 8000916:	bf04      	itt	eq
 8000918:	4619      	moveq	r1, r3
 800091a:	4610      	moveq	r0, r2
 800091c:	bd30      	pop	{r4, r5, pc}
 800091e:	ea91 0f03 	teq	r1, r3
 8000922:	bf1e      	ittt	ne
 8000924:	2100      	movne	r1, #0
 8000926:	2000      	movne	r0, #0
 8000928:	bd30      	popne	{r4, r5, pc}
 800092a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800092e:	d105      	bne.n	800093c <__adddf3+0x230>
 8000930:	0040      	lsls	r0, r0, #1
 8000932:	4149      	adcs	r1, r1
 8000934:	bf28      	it	cs
 8000936:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800093a:	bd30      	pop	{r4, r5, pc}
 800093c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000940:	bf3c      	itt	cc
 8000942:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8000946:	bd30      	popcc	{r4, r5, pc}
 8000948:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800094c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000950:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000954:	f04f 0000 	mov.w	r0, #0
 8000958:	bd30      	pop	{r4, r5, pc}
 800095a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800095e:	bf1a      	itte	ne
 8000960:	4619      	movne	r1, r3
 8000962:	4610      	movne	r0, r2
 8000964:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000968:	bf1c      	itt	ne
 800096a:	460b      	movne	r3, r1
 800096c:	4602      	movne	r2, r0
 800096e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000972:	bf06      	itte	eq
 8000974:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000978:	ea91 0f03 	teqeq	r1, r3
 800097c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000980:	bd30      	pop	{r4, r5, pc}
 8000982:	bf00      	nop

08000984 <__aeabi_ui2d>:
 8000984:	f090 0f00 	teq	r0, #0
 8000988:	bf04      	itt	eq
 800098a:	2100      	moveq	r1, #0
 800098c:	4770      	bxeq	lr
 800098e:	b530      	push	{r4, r5, lr}
 8000990:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000994:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000998:	f04f 0500 	mov.w	r5, #0
 800099c:	f04f 0100 	mov.w	r1, #0
 80009a0:	e750      	b.n	8000844 <__adddf3+0x138>
 80009a2:	bf00      	nop

080009a4 <__aeabi_i2d>:
 80009a4:	f090 0f00 	teq	r0, #0
 80009a8:	bf04      	itt	eq
 80009aa:	2100      	moveq	r1, #0
 80009ac:	4770      	bxeq	lr
 80009ae:	b530      	push	{r4, r5, lr}
 80009b0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80009b4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80009b8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80009bc:	bf48      	it	mi
 80009be:	4240      	negmi	r0, r0
 80009c0:	f04f 0100 	mov.w	r1, #0
 80009c4:	e73e      	b.n	8000844 <__adddf3+0x138>
 80009c6:	bf00      	nop

080009c8 <__aeabi_f2d>:
 80009c8:	0042      	lsls	r2, r0, #1
 80009ca:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80009ce:	ea4f 0131 	mov.w	r1, r1, rrx
 80009d2:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80009d6:	bf1f      	itttt	ne
 80009d8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80009dc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80009e0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80009e4:	4770      	bxne	lr
 80009e6:	f092 0f00 	teq	r2, #0
 80009ea:	bf14      	ite	ne
 80009ec:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80009f0:	4770      	bxeq	lr
 80009f2:	b530      	push	{r4, r5, lr}
 80009f4:	f44f 7460 	mov.w	r4, #896	; 0x380
 80009f8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80009fc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000a00:	e720      	b.n	8000844 <__adddf3+0x138>
 8000a02:	bf00      	nop

08000a04 <__aeabi_ul2d>:
 8000a04:	ea50 0201 	orrs.w	r2, r0, r1
 8000a08:	bf08      	it	eq
 8000a0a:	4770      	bxeq	lr
 8000a0c:	b530      	push	{r4, r5, lr}
 8000a0e:	f04f 0500 	mov.w	r5, #0
 8000a12:	e00a      	b.n	8000a2a <__aeabi_l2d+0x16>

08000a14 <__aeabi_l2d>:
 8000a14:	ea50 0201 	orrs.w	r2, r0, r1
 8000a18:	bf08      	it	eq
 8000a1a:	4770      	bxeq	lr
 8000a1c:	b530      	push	{r4, r5, lr}
 8000a1e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8000a22:	d502      	bpl.n	8000a2a <__aeabi_l2d+0x16>
 8000a24:	4240      	negs	r0, r0
 8000a26:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000a2a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000a2e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000a32:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000a36:	f43f aedc 	beq.w	80007f2 <__adddf3+0xe6>
 8000a3a:	f04f 0203 	mov.w	r2, #3
 8000a3e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000a42:	bf18      	it	ne
 8000a44:	3203      	addne	r2, #3
 8000a46:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000a4a:	bf18      	it	ne
 8000a4c:	3203      	addne	r2, #3
 8000a4e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000a52:	f1c2 0320 	rsb	r3, r2, #32
 8000a56:	fa00 fc03 	lsl.w	ip, r0, r3
 8000a5a:	fa20 f002 	lsr.w	r0, r0, r2
 8000a5e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000a62:	ea40 000e 	orr.w	r0, r0, lr
 8000a66:	fa21 f102 	lsr.w	r1, r1, r2
 8000a6a:	4414      	add	r4, r2
 8000a6c:	e6c1      	b.n	80007f2 <__adddf3+0xe6>
 8000a6e:	bf00      	nop

08000a70 <__aeabi_dmul>:
 8000a70:	b570      	push	{r4, r5, r6, lr}
 8000a72:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000a76:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000a7a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000a7e:	bf1d      	ittte	ne
 8000a80:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000a84:	ea94 0f0c 	teqne	r4, ip
 8000a88:	ea95 0f0c 	teqne	r5, ip
 8000a8c:	f000 f8de 	bleq	8000c4c <__aeabi_dmul+0x1dc>
 8000a90:	442c      	add	r4, r5
 8000a92:	ea81 0603 	eor.w	r6, r1, r3
 8000a96:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000a9a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000a9e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000aa2:	bf18      	it	ne
 8000aa4:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000aa8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000aac:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000ab0:	d038      	beq.n	8000b24 <__aeabi_dmul+0xb4>
 8000ab2:	fba0 ce02 	umull	ip, lr, r0, r2
 8000ab6:	f04f 0500 	mov.w	r5, #0
 8000aba:	fbe1 e502 	umlal	lr, r5, r1, r2
 8000abe:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8000ac2:	fbe0 e503 	umlal	lr, r5, r0, r3
 8000ac6:	f04f 0600 	mov.w	r6, #0
 8000aca:	fbe1 5603 	umlal	r5, r6, r1, r3
 8000ace:	f09c 0f00 	teq	ip, #0
 8000ad2:	bf18      	it	ne
 8000ad4:	f04e 0e01 	orrne.w	lr, lr, #1
 8000ad8:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8000adc:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000ae0:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8000ae4:	d204      	bcs.n	8000af0 <__aeabi_dmul+0x80>
 8000ae6:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8000aea:	416d      	adcs	r5, r5
 8000aec:	eb46 0606 	adc.w	r6, r6, r6
 8000af0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8000af4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000af8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8000afc:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000b00:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8000b04:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000b08:	bf88      	it	hi
 8000b0a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8000b0e:	d81e      	bhi.n	8000b4e <__aeabi_dmul+0xde>
 8000b10:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8000b14:	bf08      	it	eq
 8000b16:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8000b1a:	f150 0000 	adcs.w	r0, r0, #0
 8000b1e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000b22:	bd70      	pop	{r4, r5, r6, pc}
 8000b24:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000b28:	ea46 0101 	orr.w	r1, r6, r1
 8000b2c:	ea40 0002 	orr.w	r0, r0, r2
 8000b30:	ea81 0103 	eor.w	r1, r1, r3
 8000b34:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000b38:	bfc2      	ittt	gt
 8000b3a:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000b3e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000b42:	bd70      	popgt	{r4, r5, r6, pc}
 8000b44:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000b48:	f04f 0e00 	mov.w	lr, #0
 8000b4c:	3c01      	subs	r4, #1
 8000b4e:	f300 80ab 	bgt.w	8000ca8 <__aeabi_dmul+0x238>
 8000b52:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8000b56:	bfde      	ittt	le
 8000b58:	2000      	movle	r0, #0
 8000b5a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8000b5e:	bd70      	pople	{r4, r5, r6, pc}
 8000b60:	f1c4 0400 	rsb	r4, r4, #0
 8000b64:	3c20      	subs	r4, #32
 8000b66:	da35      	bge.n	8000bd4 <__aeabi_dmul+0x164>
 8000b68:	340c      	adds	r4, #12
 8000b6a:	dc1b      	bgt.n	8000ba4 <__aeabi_dmul+0x134>
 8000b6c:	f104 0414 	add.w	r4, r4, #20
 8000b70:	f1c4 0520 	rsb	r5, r4, #32
 8000b74:	fa00 f305 	lsl.w	r3, r0, r5
 8000b78:	fa20 f004 	lsr.w	r0, r0, r4
 8000b7c:	fa01 f205 	lsl.w	r2, r1, r5
 8000b80:	ea40 0002 	orr.w	r0, r0, r2
 8000b84:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000b88:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000b8c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000b90:	fa21 f604 	lsr.w	r6, r1, r4
 8000b94:	eb42 0106 	adc.w	r1, r2, r6
 8000b98:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000b9c:	bf08      	it	eq
 8000b9e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000ba2:	bd70      	pop	{r4, r5, r6, pc}
 8000ba4:	f1c4 040c 	rsb	r4, r4, #12
 8000ba8:	f1c4 0520 	rsb	r5, r4, #32
 8000bac:	fa00 f304 	lsl.w	r3, r0, r4
 8000bb0:	fa20 f005 	lsr.w	r0, r0, r5
 8000bb4:	fa01 f204 	lsl.w	r2, r1, r4
 8000bb8:	ea40 0002 	orr.w	r0, r0, r2
 8000bbc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000bc0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000bc4:	f141 0100 	adc.w	r1, r1, #0
 8000bc8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000bcc:	bf08      	it	eq
 8000bce:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000bd2:	bd70      	pop	{r4, r5, r6, pc}
 8000bd4:	f1c4 0520 	rsb	r5, r4, #32
 8000bd8:	fa00 f205 	lsl.w	r2, r0, r5
 8000bdc:	ea4e 0e02 	orr.w	lr, lr, r2
 8000be0:	fa20 f304 	lsr.w	r3, r0, r4
 8000be4:	fa01 f205 	lsl.w	r2, r1, r5
 8000be8:	ea43 0302 	orr.w	r3, r3, r2
 8000bec:	fa21 f004 	lsr.w	r0, r1, r4
 8000bf0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000bf4:	fa21 f204 	lsr.w	r2, r1, r4
 8000bf8:	ea20 0002 	bic.w	r0, r0, r2
 8000bfc:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000c00:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000c04:	bf08      	it	eq
 8000c06:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000c0a:	bd70      	pop	{r4, r5, r6, pc}
 8000c0c:	f094 0f00 	teq	r4, #0
 8000c10:	d10f      	bne.n	8000c32 <__aeabi_dmul+0x1c2>
 8000c12:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8000c16:	0040      	lsls	r0, r0, #1
 8000c18:	eb41 0101 	adc.w	r1, r1, r1
 8000c1c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000c20:	bf08      	it	eq
 8000c22:	3c01      	subeq	r4, #1
 8000c24:	d0f7      	beq.n	8000c16 <__aeabi_dmul+0x1a6>
 8000c26:	ea41 0106 	orr.w	r1, r1, r6
 8000c2a:	f095 0f00 	teq	r5, #0
 8000c2e:	bf18      	it	ne
 8000c30:	4770      	bxne	lr
 8000c32:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8000c36:	0052      	lsls	r2, r2, #1
 8000c38:	eb43 0303 	adc.w	r3, r3, r3
 8000c3c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8000c40:	bf08      	it	eq
 8000c42:	3d01      	subeq	r5, #1
 8000c44:	d0f7      	beq.n	8000c36 <__aeabi_dmul+0x1c6>
 8000c46:	ea43 0306 	orr.w	r3, r3, r6
 8000c4a:	4770      	bx	lr
 8000c4c:	ea94 0f0c 	teq	r4, ip
 8000c50:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000c54:	bf18      	it	ne
 8000c56:	ea95 0f0c 	teqne	r5, ip
 8000c5a:	d00c      	beq.n	8000c76 <__aeabi_dmul+0x206>
 8000c5c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000c60:	bf18      	it	ne
 8000c62:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000c66:	d1d1      	bne.n	8000c0c <__aeabi_dmul+0x19c>
 8000c68:	ea81 0103 	eor.w	r1, r1, r3
 8000c6c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000c70:	f04f 0000 	mov.w	r0, #0
 8000c74:	bd70      	pop	{r4, r5, r6, pc}
 8000c76:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000c7a:	bf06      	itte	eq
 8000c7c:	4610      	moveq	r0, r2
 8000c7e:	4619      	moveq	r1, r3
 8000c80:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000c84:	d019      	beq.n	8000cba <__aeabi_dmul+0x24a>
 8000c86:	ea94 0f0c 	teq	r4, ip
 8000c8a:	d102      	bne.n	8000c92 <__aeabi_dmul+0x222>
 8000c8c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000c90:	d113      	bne.n	8000cba <__aeabi_dmul+0x24a>
 8000c92:	ea95 0f0c 	teq	r5, ip
 8000c96:	d105      	bne.n	8000ca4 <__aeabi_dmul+0x234>
 8000c98:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000c9c:	bf1c      	itt	ne
 8000c9e:	4610      	movne	r0, r2
 8000ca0:	4619      	movne	r1, r3
 8000ca2:	d10a      	bne.n	8000cba <__aeabi_dmul+0x24a>
 8000ca4:	ea81 0103 	eor.w	r1, r1, r3
 8000ca8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000cac:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000cb0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000cb4:	f04f 0000 	mov.w	r0, #0
 8000cb8:	bd70      	pop	{r4, r5, r6, pc}
 8000cba:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000cbe:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8000cc2:	bd70      	pop	{r4, r5, r6, pc}

08000cc4 <__aeabi_ddiv>:
 8000cc4:	b570      	push	{r4, r5, r6, lr}
 8000cc6:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000cca:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000cce:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000cd2:	bf1d      	ittte	ne
 8000cd4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000cd8:	ea94 0f0c 	teqne	r4, ip
 8000cdc:	ea95 0f0c 	teqne	r5, ip
 8000ce0:	f000 f8a7 	bleq	8000e32 <__aeabi_ddiv+0x16e>
 8000ce4:	eba4 0405 	sub.w	r4, r4, r5
 8000ce8:	ea81 0e03 	eor.w	lr, r1, r3
 8000cec:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000cf0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000cf4:	f000 8088 	beq.w	8000e08 <__aeabi_ddiv+0x144>
 8000cf8:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000cfc:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8000d00:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8000d04:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000d08:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8000d0c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8000d10:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8000d14:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000d18:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8000d1c:	429d      	cmp	r5, r3
 8000d1e:	bf08      	it	eq
 8000d20:	4296      	cmpeq	r6, r2
 8000d22:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8000d26:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8000d2a:	d202      	bcs.n	8000d32 <__aeabi_ddiv+0x6e>
 8000d2c:	085b      	lsrs	r3, r3, #1
 8000d2e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000d32:	1ab6      	subs	r6, r6, r2
 8000d34:	eb65 0503 	sbc.w	r5, r5, r3
 8000d38:	085b      	lsrs	r3, r3, #1
 8000d3a:	ea4f 0232 	mov.w	r2, r2, rrx
 8000d3e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8000d42:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8000d46:	ebb6 0e02 	subs.w	lr, r6, r2
 8000d4a:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000d4e:	bf22      	ittt	cs
 8000d50:	1ab6      	subcs	r6, r6, r2
 8000d52:	4675      	movcs	r5, lr
 8000d54:	ea40 000c 	orrcs.w	r0, r0, ip
 8000d58:	085b      	lsrs	r3, r3, #1
 8000d5a:	ea4f 0232 	mov.w	r2, r2, rrx
 8000d5e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000d62:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000d66:	bf22      	ittt	cs
 8000d68:	1ab6      	subcs	r6, r6, r2
 8000d6a:	4675      	movcs	r5, lr
 8000d6c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000d70:	085b      	lsrs	r3, r3, #1
 8000d72:	ea4f 0232 	mov.w	r2, r2, rrx
 8000d76:	ebb6 0e02 	subs.w	lr, r6, r2
 8000d7a:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000d7e:	bf22      	ittt	cs
 8000d80:	1ab6      	subcs	r6, r6, r2
 8000d82:	4675      	movcs	r5, lr
 8000d84:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000d88:	085b      	lsrs	r3, r3, #1
 8000d8a:	ea4f 0232 	mov.w	r2, r2, rrx
 8000d8e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000d92:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000d96:	bf22      	ittt	cs
 8000d98:	1ab6      	subcs	r6, r6, r2
 8000d9a:	4675      	movcs	r5, lr
 8000d9c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000da0:	ea55 0e06 	orrs.w	lr, r5, r6
 8000da4:	d018      	beq.n	8000dd8 <__aeabi_ddiv+0x114>
 8000da6:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000daa:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000dae:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000db2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000db6:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8000dba:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000dbe:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8000dc2:	d1c0      	bne.n	8000d46 <__aeabi_ddiv+0x82>
 8000dc4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000dc8:	d10b      	bne.n	8000de2 <__aeabi_ddiv+0x11e>
 8000dca:	ea41 0100 	orr.w	r1, r1, r0
 8000dce:	f04f 0000 	mov.w	r0, #0
 8000dd2:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8000dd6:	e7b6      	b.n	8000d46 <__aeabi_ddiv+0x82>
 8000dd8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000ddc:	bf04      	itt	eq
 8000dde:	4301      	orreq	r1, r0
 8000de0:	2000      	moveq	r0, #0
 8000de2:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000de6:	bf88      	it	hi
 8000de8:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8000dec:	f63f aeaf 	bhi.w	8000b4e <__aeabi_dmul+0xde>
 8000df0:	ebb5 0c03 	subs.w	ip, r5, r3
 8000df4:	bf04      	itt	eq
 8000df6:	ebb6 0c02 	subseq.w	ip, r6, r2
 8000dfa:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000dfe:	f150 0000 	adcs.w	r0, r0, #0
 8000e02:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000e06:	bd70      	pop	{r4, r5, r6, pc}
 8000e08:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8000e0c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000e10:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8000e14:	bfc2      	ittt	gt
 8000e16:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000e1a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000e1e:	bd70      	popgt	{r4, r5, r6, pc}
 8000e20:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000e24:	f04f 0e00 	mov.w	lr, #0
 8000e28:	3c01      	subs	r4, #1
 8000e2a:	e690      	b.n	8000b4e <__aeabi_dmul+0xde>
 8000e2c:	ea45 0e06 	orr.w	lr, r5, r6
 8000e30:	e68d      	b.n	8000b4e <__aeabi_dmul+0xde>
 8000e32:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000e36:	ea94 0f0c 	teq	r4, ip
 8000e3a:	bf08      	it	eq
 8000e3c:	ea95 0f0c 	teqeq	r5, ip
 8000e40:	f43f af3b 	beq.w	8000cba <__aeabi_dmul+0x24a>
 8000e44:	ea94 0f0c 	teq	r4, ip
 8000e48:	d10a      	bne.n	8000e60 <__aeabi_ddiv+0x19c>
 8000e4a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000e4e:	f47f af34 	bne.w	8000cba <__aeabi_dmul+0x24a>
 8000e52:	ea95 0f0c 	teq	r5, ip
 8000e56:	f47f af25 	bne.w	8000ca4 <__aeabi_dmul+0x234>
 8000e5a:	4610      	mov	r0, r2
 8000e5c:	4619      	mov	r1, r3
 8000e5e:	e72c      	b.n	8000cba <__aeabi_dmul+0x24a>
 8000e60:	ea95 0f0c 	teq	r5, ip
 8000e64:	d106      	bne.n	8000e74 <__aeabi_ddiv+0x1b0>
 8000e66:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000e6a:	f43f aefd 	beq.w	8000c68 <__aeabi_dmul+0x1f8>
 8000e6e:	4610      	mov	r0, r2
 8000e70:	4619      	mov	r1, r3
 8000e72:	e722      	b.n	8000cba <__aeabi_dmul+0x24a>
 8000e74:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000e78:	bf18      	it	ne
 8000e7a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000e7e:	f47f aec5 	bne.w	8000c0c <__aeabi_dmul+0x19c>
 8000e82:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000e86:	f47f af0d 	bne.w	8000ca4 <__aeabi_dmul+0x234>
 8000e8a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000e8e:	f47f aeeb 	bne.w	8000c68 <__aeabi_dmul+0x1f8>
 8000e92:	e712      	b.n	8000cba <__aeabi_dmul+0x24a>

08000e94 <__gedf2>:
 8000e94:	f04f 3cff 	mov.w	ip, #4294967295
 8000e98:	e006      	b.n	8000ea8 <__cmpdf2+0x4>
 8000e9a:	bf00      	nop

08000e9c <__ledf2>:
 8000e9c:	f04f 0c01 	mov.w	ip, #1
 8000ea0:	e002      	b.n	8000ea8 <__cmpdf2+0x4>
 8000ea2:	bf00      	nop

08000ea4 <__cmpdf2>:
 8000ea4:	f04f 0c01 	mov.w	ip, #1
 8000ea8:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000eac:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000eb0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000eb4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000eb8:	bf18      	it	ne
 8000eba:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000ebe:	d01b      	beq.n	8000ef8 <__cmpdf2+0x54>
 8000ec0:	b001      	add	sp, #4
 8000ec2:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000ec6:	bf0c      	ite	eq
 8000ec8:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000ecc:	ea91 0f03 	teqne	r1, r3
 8000ed0:	bf02      	ittt	eq
 8000ed2:	ea90 0f02 	teqeq	r0, r2
 8000ed6:	2000      	moveq	r0, #0
 8000ed8:	4770      	bxeq	lr
 8000eda:	f110 0f00 	cmn.w	r0, #0
 8000ede:	ea91 0f03 	teq	r1, r3
 8000ee2:	bf58      	it	pl
 8000ee4:	4299      	cmppl	r1, r3
 8000ee6:	bf08      	it	eq
 8000ee8:	4290      	cmpeq	r0, r2
 8000eea:	bf2c      	ite	cs
 8000eec:	17d8      	asrcs	r0, r3, #31
 8000eee:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000ef2:	f040 0001 	orr.w	r0, r0, #1
 8000ef6:	4770      	bx	lr
 8000ef8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000efc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000f00:	d102      	bne.n	8000f08 <__cmpdf2+0x64>
 8000f02:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000f06:	d107      	bne.n	8000f18 <__cmpdf2+0x74>
 8000f08:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000f0c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000f10:	d1d6      	bne.n	8000ec0 <__cmpdf2+0x1c>
 8000f12:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000f16:	d0d3      	beq.n	8000ec0 <__cmpdf2+0x1c>
 8000f18:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000f1c:	4770      	bx	lr
 8000f1e:	bf00      	nop

08000f20 <__aeabi_cdrcmple>:
 8000f20:	4684      	mov	ip, r0
 8000f22:	4610      	mov	r0, r2
 8000f24:	4662      	mov	r2, ip
 8000f26:	468c      	mov	ip, r1
 8000f28:	4619      	mov	r1, r3
 8000f2a:	4663      	mov	r3, ip
 8000f2c:	e000      	b.n	8000f30 <__aeabi_cdcmpeq>
 8000f2e:	bf00      	nop

08000f30 <__aeabi_cdcmpeq>:
 8000f30:	b501      	push	{r0, lr}
 8000f32:	f7ff ffb7 	bl	8000ea4 <__cmpdf2>
 8000f36:	2800      	cmp	r0, #0
 8000f38:	bf48      	it	mi
 8000f3a:	f110 0f00 	cmnmi.w	r0, #0
 8000f3e:	bd01      	pop	{r0, pc}

08000f40 <__aeabi_dcmpeq>:
 8000f40:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000f44:	f7ff fff4 	bl	8000f30 <__aeabi_cdcmpeq>
 8000f48:	bf0c      	ite	eq
 8000f4a:	2001      	moveq	r0, #1
 8000f4c:	2000      	movne	r0, #0
 8000f4e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000f52:	bf00      	nop

08000f54 <__aeabi_dcmplt>:
 8000f54:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000f58:	f7ff ffea 	bl	8000f30 <__aeabi_cdcmpeq>
 8000f5c:	bf34      	ite	cc
 8000f5e:	2001      	movcc	r0, #1
 8000f60:	2000      	movcs	r0, #0
 8000f62:	f85d fb08 	ldr.w	pc, [sp], #8
 8000f66:	bf00      	nop

08000f68 <__aeabi_dcmple>:
 8000f68:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000f6c:	f7ff ffe0 	bl	8000f30 <__aeabi_cdcmpeq>
 8000f70:	bf94      	ite	ls
 8000f72:	2001      	movls	r0, #1
 8000f74:	2000      	movhi	r0, #0
 8000f76:	f85d fb08 	ldr.w	pc, [sp], #8
 8000f7a:	bf00      	nop

08000f7c <__aeabi_dcmpge>:
 8000f7c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000f80:	f7ff ffce 	bl	8000f20 <__aeabi_cdrcmple>
 8000f84:	bf94      	ite	ls
 8000f86:	2001      	movls	r0, #1
 8000f88:	2000      	movhi	r0, #0
 8000f8a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000f8e:	bf00      	nop

08000f90 <__aeabi_dcmpgt>:
 8000f90:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000f94:	f7ff ffc4 	bl	8000f20 <__aeabi_cdrcmple>
 8000f98:	bf34      	ite	cc
 8000f9a:	2001      	movcc	r0, #1
 8000f9c:	2000      	movcs	r0, #0
 8000f9e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000fa2:	bf00      	nop

08000fa4 <__aeabi_d2iz>:
 8000fa4:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000fa8:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000fac:	d215      	bcs.n	8000fda <__aeabi_d2iz+0x36>
 8000fae:	d511      	bpl.n	8000fd4 <__aeabi_d2iz+0x30>
 8000fb0:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000fb4:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000fb8:	d912      	bls.n	8000fe0 <__aeabi_d2iz+0x3c>
 8000fba:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000fbe:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000fc2:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000fc6:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000fca:	fa23 f002 	lsr.w	r0, r3, r2
 8000fce:	bf18      	it	ne
 8000fd0:	4240      	negne	r0, r0
 8000fd2:	4770      	bx	lr
 8000fd4:	f04f 0000 	mov.w	r0, #0
 8000fd8:	4770      	bx	lr
 8000fda:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000fde:	d105      	bne.n	8000fec <__aeabi_d2iz+0x48>
 8000fe0:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8000fe4:	bf08      	it	eq
 8000fe6:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000fea:	4770      	bx	lr
 8000fec:	f04f 0000 	mov.w	r0, #0
 8000ff0:	4770      	bx	lr
 8000ff2:	bf00      	nop

08000ff4 <__aeabi_d2uiz>:
 8000ff4:	004a      	lsls	r2, r1, #1
 8000ff6:	d211      	bcs.n	800101c <__aeabi_d2uiz+0x28>
 8000ff8:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000ffc:	d211      	bcs.n	8001022 <__aeabi_d2uiz+0x2e>
 8000ffe:	d50d      	bpl.n	800101c <__aeabi_d2uiz+0x28>
 8001000:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8001004:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8001008:	d40e      	bmi.n	8001028 <__aeabi_d2uiz+0x34>
 800100a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800100e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8001012:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8001016:	fa23 f002 	lsr.w	r0, r3, r2
 800101a:	4770      	bx	lr
 800101c:	f04f 0000 	mov.w	r0, #0
 8001020:	4770      	bx	lr
 8001022:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8001026:	d102      	bne.n	800102e <__aeabi_d2uiz+0x3a>
 8001028:	f04f 30ff 	mov.w	r0, #4294967295
 800102c:	4770      	bx	lr
 800102e:	f04f 0000 	mov.w	r0, #0
 8001032:	4770      	bx	lr

08001034 <__aeabi_uldivmod>:
 8001034:	b94b      	cbnz	r3, 800104a <__aeabi_uldivmod+0x16>
 8001036:	b942      	cbnz	r2, 800104a <__aeabi_uldivmod+0x16>
 8001038:	2900      	cmp	r1, #0
 800103a:	bf08      	it	eq
 800103c:	2800      	cmpeq	r0, #0
 800103e:	d002      	beq.n	8001046 <__aeabi_uldivmod+0x12>
 8001040:	f04f 31ff 	mov.w	r1, #4294967295
 8001044:	4608      	mov	r0, r1
 8001046:	f000 b83b 	b.w	80010c0 <__aeabi_idiv0>
 800104a:	b082      	sub	sp, #8
 800104c:	46ec      	mov	ip, sp
 800104e:	e92d 5000 	stmdb	sp!, {ip, lr}
 8001052:	f000 f81d 	bl	8001090 <__gnu_uldivmod_helper>
 8001056:	f8dd e004 	ldr.w	lr, [sp, #4]
 800105a:	b002      	add	sp, #8
 800105c:	bc0c      	pop	{r2, r3}
 800105e:	4770      	bx	lr

08001060 <__gnu_ldivmod_helper>:
 8001060:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001064:	9c06      	ldr	r4, [sp, #24]
 8001066:	4615      	mov	r5, r2
 8001068:	4606      	mov	r6, r0
 800106a:	460f      	mov	r7, r1
 800106c:	4698      	mov	r8, r3
 800106e:	f000 f829 	bl	80010c4 <__divdi3>
 8001072:	fb05 f301 	mul.w	r3, r5, r1
 8001076:	fb00 3808 	mla	r8, r0, r8, r3
 800107a:	fba5 2300 	umull	r2, r3, r5, r0
 800107e:	1ab2      	subs	r2, r6, r2
 8001080:	4443      	add	r3, r8
 8001082:	eb67 0303 	sbc.w	r3, r7, r3
 8001086:	e9c4 2300 	strd	r2, r3, [r4]
 800108a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800108e:	bf00      	nop

08001090 <__gnu_uldivmod_helper>:
 8001090:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001094:	9c06      	ldr	r4, [sp, #24]
 8001096:	4690      	mov	r8, r2
 8001098:	4606      	mov	r6, r0
 800109a:	460f      	mov	r7, r1
 800109c:	461d      	mov	r5, r3
 800109e:	f000 f95f 	bl	8001360 <__udivdi3>
 80010a2:	fb00 f505 	mul.w	r5, r0, r5
 80010a6:	fba0 2308 	umull	r2, r3, r0, r8
 80010aa:	fb08 5501 	mla	r5, r8, r1, r5
 80010ae:	1ab2      	subs	r2, r6, r2
 80010b0:	442b      	add	r3, r5
 80010b2:	eb67 0303 	sbc.w	r3, r7, r3
 80010b6:	e9c4 2300 	strd	r2, r3, [r4]
 80010ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80010be:	bf00      	nop

080010c0 <__aeabi_idiv0>:
 80010c0:	4770      	bx	lr
 80010c2:	bf00      	nop

080010c4 <__divdi3>:
 80010c4:	2900      	cmp	r1, #0
 80010c6:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80010ca:	f2c0 80a6 	blt.w	800121a <__divdi3+0x156>
 80010ce:	2600      	movs	r6, #0
 80010d0:	2b00      	cmp	r3, #0
 80010d2:	f2c0 809c 	blt.w	800120e <__divdi3+0x14a>
 80010d6:	4688      	mov	r8, r1
 80010d8:	4694      	mov	ip, r2
 80010da:	469e      	mov	lr, r3
 80010dc:	4615      	mov	r5, r2
 80010de:	4604      	mov	r4, r0
 80010e0:	460f      	mov	r7, r1
 80010e2:	2b00      	cmp	r3, #0
 80010e4:	d13d      	bne.n	8001162 <__divdi3+0x9e>
 80010e6:	428a      	cmp	r2, r1
 80010e8:	d959      	bls.n	800119e <__divdi3+0xda>
 80010ea:	fab2 f382 	clz	r3, r2
 80010ee:	b13b      	cbz	r3, 8001100 <__divdi3+0x3c>
 80010f0:	f1c3 0220 	rsb	r2, r3, #32
 80010f4:	409f      	lsls	r7, r3
 80010f6:	fa20 f202 	lsr.w	r2, r0, r2
 80010fa:	409d      	lsls	r5, r3
 80010fc:	4317      	orrs	r7, r2
 80010fe:	409c      	lsls	r4, r3
 8001100:	0c29      	lsrs	r1, r5, #16
 8001102:	0c22      	lsrs	r2, r4, #16
 8001104:	fbb7 fef1 	udiv	lr, r7, r1
 8001108:	b2a8      	uxth	r0, r5
 800110a:	fb01 771e 	mls	r7, r1, lr, r7
 800110e:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
 8001112:	fb00 f30e 	mul.w	r3, r0, lr
 8001116:	42bb      	cmp	r3, r7
 8001118:	d90a      	bls.n	8001130 <__divdi3+0x6c>
 800111a:	197f      	adds	r7, r7, r5
 800111c:	f10e 32ff 	add.w	r2, lr, #4294967295
 8001120:	f080 8105 	bcs.w	800132e <__divdi3+0x26a>
 8001124:	42bb      	cmp	r3, r7
 8001126:	f240 8102 	bls.w	800132e <__divdi3+0x26a>
 800112a:	f1ae 0e02 	sub.w	lr, lr, #2
 800112e:	442f      	add	r7, r5
 8001130:	1aff      	subs	r7, r7, r3
 8001132:	b2a4      	uxth	r4, r4
 8001134:	fbb7 f3f1 	udiv	r3, r7, r1
 8001138:	fb01 7713 	mls	r7, r1, r3, r7
 800113c:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 8001140:	fb00 f003 	mul.w	r0, r0, r3
 8001144:	42b8      	cmp	r0, r7
 8001146:	d908      	bls.n	800115a <__divdi3+0x96>
 8001148:	197f      	adds	r7, r7, r5
 800114a:	f103 32ff 	add.w	r2, r3, #4294967295
 800114e:	f080 80f0 	bcs.w	8001332 <__divdi3+0x26e>
 8001152:	42b8      	cmp	r0, r7
 8001154:	f240 80ed 	bls.w	8001332 <__divdi3+0x26e>
 8001158:	3b02      	subs	r3, #2
 800115a:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 800115e:	2200      	movs	r2, #0
 8001160:	e003      	b.n	800116a <__divdi3+0xa6>
 8001162:	428b      	cmp	r3, r1
 8001164:	d90f      	bls.n	8001186 <__divdi3+0xc2>
 8001166:	2200      	movs	r2, #0
 8001168:	4613      	mov	r3, r2
 800116a:	1c34      	adds	r4, r6, #0
 800116c:	bf18      	it	ne
 800116e:	2401      	movne	r4, #1
 8001170:	4260      	negs	r0, r4
 8001172:	f04f 0500 	mov.w	r5, #0
 8001176:	eb65 0145 	sbc.w	r1, r5, r5, lsl #1
 800117a:	4058      	eors	r0, r3
 800117c:	4051      	eors	r1, r2
 800117e:	1900      	adds	r0, r0, r4
 8001180:	4169      	adcs	r1, r5
 8001182:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8001186:	fab3 f283 	clz	r2, r3
 800118a:	2a00      	cmp	r2, #0
 800118c:	f040 8086 	bne.w	800129c <__divdi3+0x1d8>
 8001190:	428b      	cmp	r3, r1
 8001192:	d302      	bcc.n	800119a <__divdi3+0xd6>
 8001194:	4584      	cmp	ip, r0
 8001196:	f200 80db 	bhi.w	8001350 <__divdi3+0x28c>
 800119a:	2301      	movs	r3, #1
 800119c:	e7e5      	b.n	800116a <__divdi3+0xa6>
 800119e:	b912      	cbnz	r2, 80011a6 <__divdi3+0xe2>
 80011a0:	2301      	movs	r3, #1
 80011a2:	fbb3 f5f2 	udiv	r5, r3, r2
 80011a6:	fab5 f085 	clz	r0, r5
 80011aa:	2800      	cmp	r0, #0
 80011ac:	d13b      	bne.n	8001226 <__divdi3+0x162>
 80011ae:	1b78      	subs	r0, r7, r5
 80011b0:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80011b4:	fa1f fc85 	uxth.w	ip, r5
 80011b8:	2201      	movs	r2, #1
 80011ba:	fbb0 f8fe 	udiv	r8, r0, lr
 80011be:	0c21      	lsrs	r1, r4, #16
 80011c0:	fb0e 0718 	mls	r7, lr, r8, r0
 80011c4:	ea41 4707 	orr.w	r7, r1, r7, lsl #16
 80011c8:	fb0c f308 	mul.w	r3, ip, r8
 80011cc:	42bb      	cmp	r3, r7
 80011ce:	d907      	bls.n	80011e0 <__divdi3+0x11c>
 80011d0:	197f      	adds	r7, r7, r5
 80011d2:	f108 31ff 	add.w	r1, r8, #4294967295
 80011d6:	d202      	bcs.n	80011de <__divdi3+0x11a>
 80011d8:	42bb      	cmp	r3, r7
 80011da:	f200 80bd 	bhi.w	8001358 <__divdi3+0x294>
 80011de:	4688      	mov	r8, r1
 80011e0:	1aff      	subs	r7, r7, r3
 80011e2:	b2a4      	uxth	r4, r4
 80011e4:	fbb7 f3fe 	udiv	r3, r7, lr
 80011e8:	fb0e 7713 	mls	r7, lr, r3, r7
 80011ec:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 80011f0:	fb0c fc03 	mul.w	ip, ip, r3
 80011f4:	45bc      	cmp	ip, r7
 80011f6:	d907      	bls.n	8001208 <__divdi3+0x144>
 80011f8:	197f      	adds	r7, r7, r5
 80011fa:	f103 31ff 	add.w	r1, r3, #4294967295
 80011fe:	d202      	bcs.n	8001206 <__divdi3+0x142>
 8001200:	45bc      	cmp	ip, r7
 8001202:	f200 80a7 	bhi.w	8001354 <__divdi3+0x290>
 8001206:	460b      	mov	r3, r1
 8001208:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 800120c:	e7ad      	b.n	800116a <__divdi3+0xa6>
 800120e:	4252      	negs	r2, r2
 8001210:	ea6f 0606 	mvn.w	r6, r6
 8001214:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8001218:	e75d      	b.n	80010d6 <__divdi3+0x12>
 800121a:	4240      	negs	r0, r0
 800121c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8001220:	f04f 36ff 	mov.w	r6, #4294967295
 8001224:	e754      	b.n	80010d0 <__divdi3+0xc>
 8001226:	f1c0 0220 	rsb	r2, r0, #32
 800122a:	fa24 f102 	lsr.w	r1, r4, r2
 800122e:	fa07 f300 	lsl.w	r3, r7, r0
 8001232:	4085      	lsls	r5, r0
 8001234:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8001238:	40d7      	lsrs	r7, r2
 800123a:	4319      	orrs	r1, r3
 800123c:	fbb7 f2fe 	udiv	r2, r7, lr
 8001240:	0c0b      	lsrs	r3, r1, #16
 8001242:	fb0e 7712 	mls	r7, lr, r2, r7
 8001246:	fa1f fc85 	uxth.w	ip, r5
 800124a:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 800124e:	fb0c f702 	mul.w	r7, ip, r2
 8001252:	429f      	cmp	r7, r3
 8001254:	fa04 f400 	lsl.w	r4, r4, r0
 8001258:	d907      	bls.n	800126a <__divdi3+0x1a6>
 800125a:	195b      	adds	r3, r3, r5
 800125c:	f102 30ff 	add.w	r0, r2, #4294967295
 8001260:	d274      	bcs.n	800134c <__divdi3+0x288>
 8001262:	429f      	cmp	r7, r3
 8001264:	d972      	bls.n	800134c <__divdi3+0x288>
 8001266:	3a02      	subs	r2, #2
 8001268:	442b      	add	r3, r5
 800126a:	1bdf      	subs	r7, r3, r7
 800126c:	b289      	uxth	r1, r1
 800126e:	fbb7 f8fe 	udiv	r8, r7, lr
 8001272:	fb0e 7318 	mls	r3, lr, r8, r7
 8001276:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 800127a:	fb0c f708 	mul.w	r7, ip, r8
 800127e:	429f      	cmp	r7, r3
 8001280:	d908      	bls.n	8001294 <__divdi3+0x1d0>
 8001282:	195b      	adds	r3, r3, r5
 8001284:	f108 31ff 	add.w	r1, r8, #4294967295
 8001288:	d25c      	bcs.n	8001344 <__divdi3+0x280>
 800128a:	429f      	cmp	r7, r3
 800128c:	d95a      	bls.n	8001344 <__divdi3+0x280>
 800128e:	f1a8 0802 	sub.w	r8, r8, #2
 8001292:	442b      	add	r3, r5
 8001294:	1bd8      	subs	r0, r3, r7
 8001296:	ea48 4202 	orr.w	r2, r8, r2, lsl #16
 800129a:	e78e      	b.n	80011ba <__divdi3+0xf6>
 800129c:	f1c2 0320 	rsb	r3, r2, #32
 80012a0:	fa2c f103 	lsr.w	r1, ip, r3
 80012a4:	fa0e fe02 	lsl.w	lr, lr, r2
 80012a8:	fa20 f703 	lsr.w	r7, r0, r3
 80012ac:	ea41 0e0e 	orr.w	lr, r1, lr
 80012b0:	fa08 f002 	lsl.w	r0, r8, r2
 80012b4:	fa28 f103 	lsr.w	r1, r8, r3
 80012b8:	ea4f 451e 	mov.w	r5, lr, lsr #16
 80012bc:	4338      	orrs	r0, r7
 80012be:	fbb1 f8f5 	udiv	r8, r1, r5
 80012c2:	0c03      	lsrs	r3, r0, #16
 80012c4:	fb05 1118 	mls	r1, r5, r8, r1
 80012c8:	fa1f f78e 	uxth.w	r7, lr
 80012cc:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 80012d0:	fb07 f308 	mul.w	r3, r7, r8
 80012d4:	428b      	cmp	r3, r1
 80012d6:	fa0c fc02 	lsl.w	ip, ip, r2
 80012da:	d909      	bls.n	80012f0 <__divdi3+0x22c>
 80012dc:	eb11 010e 	adds.w	r1, r1, lr
 80012e0:	f108 39ff 	add.w	r9, r8, #4294967295
 80012e4:	d230      	bcs.n	8001348 <__divdi3+0x284>
 80012e6:	428b      	cmp	r3, r1
 80012e8:	d92e      	bls.n	8001348 <__divdi3+0x284>
 80012ea:	f1a8 0802 	sub.w	r8, r8, #2
 80012ee:	4471      	add	r1, lr
 80012f0:	1ac9      	subs	r1, r1, r3
 80012f2:	b280      	uxth	r0, r0
 80012f4:	fbb1 f3f5 	udiv	r3, r1, r5
 80012f8:	fb05 1113 	mls	r1, r5, r3, r1
 80012fc:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 8001300:	fb07 f703 	mul.w	r7, r7, r3
 8001304:	428f      	cmp	r7, r1
 8001306:	d908      	bls.n	800131a <__divdi3+0x256>
 8001308:	eb11 010e 	adds.w	r1, r1, lr
 800130c:	f103 30ff 	add.w	r0, r3, #4294967295
 8001310:	d216      	bcs.n	8001340 <__divdi3+0x27c>
 8001312:	428f      	cmp	r7, r1
 8001314:	d914      	bls.n	8001340 <__divdi3+0x27c>
 8001316:	3b02      	subs	r3, #2
 8001318:	4471      	add	r1, lr
 800131a:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 800131e:	1bc9      	subs	r1, r1, r7
 8001320:	fba3 890c 	umull	r8, r9, r3, ip
 8001324:	4549      	cmp	r1, r9
 8001326:	d309      	bcc.n	800133c <__divdi3+0x278>
 8001328:	d005      	beq.n	8001336 <__divdi3+0x272>
 800132a:	2200      	movs	r2, #0
 800132c:	e71d      	b.n	800116a <__divdi3+0xa6>
 800132e:	4696      	mov	lr, r2
 8001330:	e6fe      	b.n	8001130 <__divdi3+0x6c>
 8001332:	4613      	mov	r3, r2
 8001334:	e711      	b.n	800115a <__divdi3+0x96>
 8001336:	4094      	lsls	r4, r2
 8001338:	4544      	cmp	r4, r8
 800133a:	d2f6      	bcs.n	800132a <__divdi3+0x266>
 800133c:	3b01      	subs	r3, #1
 800133e:	e7f4      	b.n	800132a <__divdi3+0x266>
 8001340:	4603      	mov	r3, r0
 8001342:	e7ea      	b.n	800131a <__divdi3+0x256>
 8001344:	4688      	mov	r8, r1
 8001346:	e7a5      	b.n	8001294 <__divdi3+0x1d0>
 8001348:	46c8      	mov	r8, r9
 800134a:	e7d1      	b.n	80012f0 <__divdi3+0x22c>
 800134c:	4602      	mov	r2, r0
 800134e:	e78c      	b.n	800126a <__divdi3+0x1a6>
 8001350:	4613      	mov	r3, r2
 8001352:	e70a      	b.n	800116a <__divdi3+0xa6>
 8001354:	3b02      	subs	r3, #2
 8001356:	e757      	b.n	8001208 <__divdi3+0x144>
 8001358:	f1a8 0802 	sub.w	r8, r8, #2
 800135c:	442f      	add	r7, r5
 800135e:	e73f      	b.n	80011e0 <__divdi3+0x11c>

08001360 <__udivdi3>:
 8001360:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001364:	2b00      	cmp	r3, #0
 8001366:	d144      	bne.n	80013f2 <__udivdi3+0x92>
 8001368:	428a      	cmp	r2, r1
 800136a:	4615      	mov	r5, r2
 800136c:	4604      	mov	r4, r0
 800136e:	d94f      	bls.n	8001410 <__udivdi3+0xb0>
 8001370:	fab2 f782 	clz	r7, r2
 8001374:	460e      	mov	r6, r1
 8001376:	b14f      	cbz	r7, 800138c <__udivdi3+0x2c>
 8001378:	f1c7 0320 	rsb	r3, r7, #32
 800137c:	40b9      	lsls	r1, r7
 800137e:	fa20 f603 	lsr.w	r6, r0, r3
 8001382:	fa02 f507 	lsl.w	r5, r2, r7
 8001386:	430e      	orrs	r6, r1
 8001388:	fa00 f407 	lsl.w	r4, r0, r7
 800138c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8001390:	0c23      	lsrs	r3, r4, #16
 8001392:	fbb6 f0fe 	udiv	r0, r6, lr
 8001396:	b2af      	uxth	r7, r5
 8001398:	fb0e 6110 	mls	r1, lr, r0, r6
 800139c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80013a0:	fb07 f100 	mul.w	r1, r7, r0
 80013a4:	4299      	cmp	r1, r3
 80013a6:	d909      	bls.n	80013bc <__udivdi3+0x5c>
 80013a8:	195b      	adds	r3, r3, r5
 80013aa:	f100 32ff 	add.w	r2, r0, #4294967295
 80013ae:	f080 80ec 	bcs.w	800158a <__udivdi3+0x22a>
 80013b2:	4299      	cmp	r1, r3
 80013b4:	f240 80e9 	bls.w	800158a <__udivdi3+0x22a>
 80013b8:	3802      	subs	r0, #2
 80013ba:	442b      	add	r3, r5
 80013bc:	1a5a      	subs	r2, r3, r1
 80013be:	b2a4      	uxth	r4, r4
 80013c0:	fbb2 f3fe 	udiv	r3, r2, lr
 80013c4:	fb0e 2213 	mls	r2, lr, r3, r2
 80013c8:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
 80013cc:	fb07 f703 	mul.w	r7, r7, r3
 80013d0:	4297      	cmp	r7, r2
 80013d2:	d908      	bls.n	80013e6 <__udivdi3+0x86>
 80013d4:	1952      	adds	r2, r2, r5
 80013d6:	f103 31ff 	add.w	r1, r3, #4294967295
 80013da:	f080 80d8 	bcs.w	800158e <__udivdi3+0x22e>
 80013de:	4297      	cmp	r7, r2
 80013e0:	f240 80d5 	bls.w	800158e <__udivdi3+0x22e>
 80013e4:	3b02      	subs	r3, #2
 80013e6:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80013ea:	2600      	movs	r6, #0
 80013ec:	4631      	mov	r1, r6
 80013ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80013f2:	428b      	cmp	r3, r1
 80013f4:	d847      	bhi.n	8001486 <__udivdi3+0x126>
 80013f6:	fab3 f683 	clz	r6, r3
 80013fa:	2e00      	cmp	r6, #0
 80013fc:	d148      	bne.n	8001490 <__udivdi3+0x130>
 80013fe:	428b      	cmp	r3, r1
 8001400:	d302      	bcc.n	8001408 <__udivdi3+0xa8>
 8001402:	4282      	cmp	r2, r0
 8001404:	f200 80cd 	bhi.w	80015a2 <__udivdi3+0x242>
 8001408:	2001      	movs	r0, #1
 800140a:	4631      	mov	r1, r6
 800140c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001410:	b912      	cbnz	r2, 8001418 <__udivdi3+0xb8>
 8001412:	2501      	movs	r5, #1
 8001414:	fbb5 f5f2 	udiv	r5, r5, r2
 8001418:	fab5 f885 	clz	r8, r5
 800141c:	f1b8 0f00 	cmp.w	r8, #0
 8001420:	d177      	bne.n	8001512 <__udivdi3+0x1b2>
 8001422:	1b4a      	subs	r2, r1, r5
 8001424:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8001428:	b2af      	uxth	r7, r5
 800142a:	2601      	movs	r6, #1
 800142c:	fbb2 f0fe 	udiv	r0, r2, lr
 8001430:	0c23      	lsrs	r3, r4, #16
 8001432:	fb0e 2110 	mls	r1, lr, r0, r2
 8001436:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 800143a:	fb07 f300 	mul.w	r3, r7, r0
 800143e:	428b      	cmp	r3, r1
 8001440:	d907      	bls.n	8001452 <__udivdi3+0xf2>
 8001442:	1949      	adds	r1, r1, r5
 8001444:	f100 32ff 	add.w	r2, r0, #4294967295
 8001448:	d202      	bcs.n	8001450 <__udivdi3+0xf0>
 800144a:	428b      	cmp	r3, r1
 800144c:	f200 80ba 	bhi.w	80015c4 <__udivdi3+0x264>
 8001450:	4610      	mov	r0, r2
 8001452:	1ac9      	subs	r1, r1, r3
 8001454:	b2a4      	uxth	r4, r4
 8001456:	fbb1 f3fe 	udiv	r3, r1, lr
 800145a:	fb0e 1113 	mls	r1, lr, r3, r1
 800145e:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 8001462:	fb07 f703 	mul.w	r7, r7, r3
 8001466:	42a7      	cmp	r7, r4
 8001468:	d908      	bls.n	800147c <__udivdi3+0x11c>
 800146a:	1964      	adds	r4, r4, r5
 800146c:	f103 32ff 	add.w	r2, r3, #4294967295
 8001470:	f080 808f 	bcs.w	8001592 <__udivdi3+0x232>
 8001474:	42a7      	cmp	r7, r4
 8001476:	f240 808c 	bls.w	8001592 <__udivdi3+0x232>
 800147a:	3b02      	subs	r3, #2
 800147c:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8001480:	4631      	mov	r1, r6
 8001482:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001486:	2600      	movs	r6, #0
 8001488:	4630      	mov	r0, r6
 800148a:	4631      	mov	r1, r6
 800148c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001490:	f1c6 0420 	rsb	r4, r6, #32
 8001494:	fa22 f504 	lsr.w	r5, r2, r4
 8001498:	40b3      	lsls	r3, r6
 800149a:	432b      	orrs	r3, r5
 800149c:	fa20 fc04 	lsr.w	ip, r0, r4
 80014a0:	fa01 f706 	lsl.w	r7, r1, r6
 80014a4:	fa21 f504 	lsr.w	r5, r1, r4
 80014a8:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 80014ac:	ea4c 0707 	orr.w	r7, ip, r7
 80014b0:	fbb5 f8fe 	udiv	r8, r5, lr
 80014b4:	0c39      	lsrs	r1, r7, #16
 80014b6:	fb0e 5518 	mls	r5, lr, r8, r5
 80014ba:	fa1f fc83 	uxth.w	ip, r3
 80014be:	ea41 4505 	orr.w	r5, r1, r5, lsl #16
 80014c2:	fb0c f108 	mul.w	r1, ip, r8
 80014c6:	42a9      	cmp	r1, r5
 80014c8:	fa02 f206 	lsl.w	r2, r2, r6
 80014cc:	d904      	bls.n	80014d8 <__udivdi3+0x178>
 80014ce:	18ed      	adds	r5, r5, r3
 80014d0:	f108 34ff 	add.w	r4, r8, #4294967295
 80014d4:	d367      	bcc.n	80015a6 <__udivdi3+0x246>
 80014d6:	46a0      	mov	r8, r4
 80014d8:	1a6d      	subs	r5, r5, r1
 80014da:	b2bf      	uxth	r7, r7
 80014dc:	fbb5 f4fe 	udiv	r4, r5, lr
 80014e0:	fb0e 5514 	mls	r5, lr, r4, r5
 80014e4:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
 80014e8:	fb0c fc04 	mul.w	ip, ip, r4
 80014ec:	458c      	cmp	ip, r1
 80014ee:	d904      	bls.n	80014fa <__udivdi3+0x19a>
 80014f0:	18c9      	adds	r1, r1, r3
 80014f2:	f104 35ff 	add.w	r5, r4, #4294967295
 80014f6:	d35c      	bcc.n	80015b2 <__udivdi3+0x252>
 80014f8:	462c      	mov	r4, r5
 80014fa:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
 80014fe:	ebcc 0101 	rsb	r1, ip, r1
 8001502:	fba4 2302 	umull	r2, r3, r4, r2
 8001506:	4299      	cmp	r1, r3
 8001508:	d348      	bcc.n	800159c <__udivdi3+0x23c>
 800150a:	d044      	beq.n	8001596 <__udivdi3+0x236>
 800150c:	4620      	mov	r0, r4
 800150e:	2600      	movs	r6, #0
 8001510:	e76c      	b.n	80013ec <__udivdi3+0x8c>
 8001512:	f1c8 0420 	rsb	r4, r8, #32
 8001516:	fa01 f308 	lsl.w	r3, r1, r8
 800151a:	fa05 f508 	lsl.w	r5, r5, r8
 800151e:	fa20 f704 	lsr.w	r7, r0, r4
 8001522:	40e1      	lsrs	r1, r4
 8001524:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8001528:	431f      	orrs	r7, r3
 800152a:	fbb1 f6fe 	udiv	r6, r1, lr
 800152e:	0c3a      	lsrs	r2, r7, #16
 8001530:	fb0e 1116 	mls	r1, lr, r6, r1
 8001534:	fa1f fc85 	uxth.w	ip, r5
 8001538:	ea42 4301 	orr.w	r3, r2, r1, lsl #16
 800153c:	fb0c f206 	mul.w	r2, ip, r6
 8001540:	429a      	cmp	r2, r3
 8001542:	fa00 f408 	lsl.w	r4, r0, r8
 8001546:	d907      	bls.n	8001558 <__udivdi3+0x1f8>
 8001548:	195b      	adds	r3, r3, r5
 800154a:	f106 31ff 	add.w	r1, r6, #4294967295
 800154e:	d237      	bcs.n	80015c0 <__udivdi3+0x260>
 8001550:	429a      	cmp	r2, r3
 8001552:	d935      	bls.n	80015c0 <__udivdi3+0x260>
 8001554:	3e02      	subs	r6, #2
 8001556:	442b      	add	r3, r5
 8001558:	1a9b      	subs	r3, r3, r2
 800155a:	b2bf      	uxth	r7, r7
 800155c:	fbb3 f0fe 	udiv	r0, r3, lr
 8001560:	fb0e 3310 	mls	r3, lr, r0, r3
 8001564:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
 8001568:	fb0c f100 	mul.w	r1, ip, r0
 800156c:	4299      	cmp	r1, r3
 800156e:	d907      	bls.n	8001580 <__udivdi3+0x220>
 8001570:	195b      	adds	r3, r3, r5
 8001572:	f100 32ff 	add.w	r2, r0, #4294967295
 8001576:	d221      	bcs.n	80015bc <__udivdi3+0x25c>
 8001578:	4299      	cmp	r1, r3
 800157a:	d91f      	bls.n	80015bc <__udivdi3+0x25c>
 800157c:	3802      	subs	r0, #2
 800157e:	442b      	add	r3, r5
 8001580:	1a5a      	subs	r2, r3, r1
 8001582:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 8001586:	4667      	mov	r7, ip
 8001588:	e750      	b.n	800142c <__udivdi3+0xcc>
 800158a:	4610      	mov	r0, r2
 800158c:	e716      	b.n	80013bc <__udivdi3+0x5c>
 800158e:	460b      	mov	r3, r1
 8001590:	e729      	b.n	80013e6 <__udivdi3+0x86>
 8001592:	4613      	mov	r3, r2
 8001594:	e772      	b.n	800147c <__udivdi3+0x11c>
 8001596:	40b0      	lsls	r0, r6
 8001598:	4290      	cmp	r0, r2
 800159a:	d2b7      	bcs.n	800150c <__udivdi3+0x1ac>
 800159c:	1e60      	subs	r0, r4, #1
 800159e:	2600      	movs	r6, #0
 80015a0:	e724      	b.n	80013ec <__udivdi3+0x8c>
 80015a2:	4630      	mov	r0, r6
 80015a4:	e722      	b.n	80013ec <__udivdi3+0x8c>
 80015a6:	42a9      	cmp	r1, r5
 80015a8:	d995      	bls.n	80014d6 <__udivdi3+0x176>
 80015aa:	f1a8 0802 	sub.w	r8, r8, #2
 80015ae:	441d      	add	r5, r3
 80015b0:	e792      	b.n	80014d8 <__udivdi3+0x178>
 80015b2:	458c      	cmp	ip, r1
 80015b4:	d9a0      	bls.n	80014f8 <__udivdi3+0x198>
 80015b6:	3c02      	subs	r4, #2
 80015b8:	4419      	add	r1, r3
 80015ba:	e79e      	b.n	80014fa <__udivdi3+0x19a>
 80015bc:	4610      	mov	r0, r2
 80015be:	e7df      	b.n	8001580 <__udivdi3+0x220>
 80015c0:	460e      	mov	r6, r1
 80015c2:	e7c9      	b.n	8001558 <__udivdi3+0x1f8>
 80015c4:	3802      	subs	r0, #2
 80015c6:	4429      	add	r1, r5
 80015c8:	e743      	b.n	8001452 <__udivdi3+0xf2>
 80015ca:	bf00      	nop

080015cc <MATH_abs>:

//! \brief     Finds the absolute value 
//! \param[in] in   The input value
//! \return    The absolute value
static inline float_t MATH_abs(const float_t in)
{
 80015cc:	b480      	push	{r7}
 80015ce:	b085      	sub	sp, #20
 80015d0:	af00      	add	r7, sp, #0
 80015d2:	ed87 0a01 	vstr	s0, [r7, #4]
  float_t out = in;
 80015d6:	687b      	ldr	r3, [r7, #4]
 80015d8:	60fb      	str	r3, [r7, #12]


  if(in < 0.0f)
 80015da:	edd7 7a01 	vldr	s15, [r7, #4]
 80015de:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80015e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80015e6:	d505      	bpl.n	80015f4 <MATH_abs+0x28>
    {
      out = -in;
 80015e8:	edd7 7a01 	vldr	s15, [r7, #4]
 80015ec:	eef1 7a67 	vneg.f32	s15, s15
 80015f0:	edc7 7a03 	vstr	s15, [r7, #12]
    }

  return(out);
 80015f4:	68fb      	ldr	r3, [r7, #12]
 80015f6:	ee07 3a90 	vmov	s15, r3
} // end of MATH_abs() function
 80015fa:	eeb0 0a67 	vmov.f32	s0, s15
 80015fe:	3714      	adds	r7, #20
 8001600:	46bd      	mov	sp, r7
 8001602:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001606:	4770      	bx	lr

08001608 <INITPOSDET_Init>:

#include "modules/InitPosDet/InitPosDet.h"


INITPOSDET_Handle INITPOSDET_Init(void *pMemory, const size_t numBytes)//! \Mod By Dl.K
{
 8001608:	b480      	push	{r7}
 800160a:	b085      	sub	sp, #20
 800160c:	af00      	add	r7, sp, #0
 800160e:	6078      	str	r0, [r7, #4]
 8001610:	6039      	str	r1, [r7, #0]
	INITPOSDET_Handle handle;
	uint16_t i;

	if (numBytes < sizeof(INITPOSDET_Obj))
 8001612:	683b      	ldr	r3, [r7, #0]
 8001614:	2b5f      	cmp	r3, #95	; 0x5f
 8001616:	d801      	bhi.n	800161c <INITPOSDET_Init+0x14>
		return((INITPOSDET_Handle)NULL);
 8001618:	2300      	movs	r3, #0
 800161a:	e046      	b.n	80016aa <INITPOSDET_Init+0xa2>

	// assign the handle
	handle = (INITPOSDET_Handle)pMemory;
 800161c:	687b      	ldr	r3, [r7, #4]
 800161e:	60bb      	str	r3, [r7, #8]

	handle->InitPosDetFlag = true;
 8001620:	68bb      	ldr	r3, [r7, #8]
 8001622:	2201      	movs	r2, #1
 8001624:	801a      	strh	r2, [r3, #0]
	handle->InitPosAngleCount = 0;
 8001626:	68bb      	ldr	r3, [r7, #8]
 8001628:	2200      	movs	r2, #0
 800162a:	805a      	strh	r2, [r3, #2]
	handle->InitPosAngle = (0.0);
 800162c:	68bb      	ldr	r3, [r7, #8]
 800162e:	f04f 0200 	mov.w	r2, #0
 8001632:	605a      	str	r2, [r3, #4]
	handle->SubdivideAngle = (SUBDIVIDE_ANGLE_PU);
 8001634:	68bb      	ldr	r3, [r7, #8]
 8001636:	4a20      	ldr	r2, [pc, #128]	; (80016b8 <INITPOSDET_Init+0xb0>)
 8001638:	609a      	str	r2, [r3, #8]
	handle->VolVecAngleFlag = false;
 800163a:	68bb      	ldr	r3, [r7, #8]
 800163c:	2200      	movs	r2, #0
 800163e:	819a      	strh	r2, [r3, #12]
	handle->VolVecAngleCount = 0;
 8001640:	68bb      	ldr	r3, [r7, #8]
 8001642:	2200      	movs	r2, #0
 8001644:	81da      	strh	r2, [r3, #14]
	handle->VolVecAngle = (0.0);
 8001646:	68bb      	ldr	r3, [r7, #8]
 8001648:	f04f 0200 	mov.w	r2, #0
 800164c:	611a      	str	r2, [r3, #16]
	handle->VolVecAngleOffset = (-0.5);//-0.1666667
 800164e:	68bb      	ldr	r3, [r7, #8]
 8001650:	f04f 423f 	mov.w	r2, #3204448256	; 0xbf000000
 8001654:	615a      	str	r2, [r3, #20]
	handle->VolVecAngleIntervalTime = VOL_VEC_ANGLE_INTERVAL_TIME_SCLAR;
 8001656:	68bb      	ldr	r3, [r7, #8]
 8001658:	220a      	movs	r2, #10
 800165a:	831a      	strh	r2, [r3, #24]
	handle->IdSampAngleFlag = false;
 800165c:	68bb      	ldr	r3, [r7, #8]
 800165e:	2200      	movs	r2, #0
 8001660:	835a      	strh	r2, [r3, #26]
	handle->IdSampAngle = (0.0);
 8001662:	68bb      	ldr	r3, [r7, #8]
 8001664:	f04f 0200 	mov.w	r2, #0
 8001668:	61da      	str	r2, [r3, #28]
	handle->IdSampAngleCount = 0;
 800166a:	68bb      	ldr	r3, [r7, #8]
 800166c:	2200      	movs	r2, #0
 800166e:	841a      	strh	r2, [r3, #32]
	for (i = 0; i<VOL_VEC_ANGLE_SCLAR / 2; i++)
 8001670:	2300      	movs	r3, #0
 8001672:	81fb      	strh	r3, [r7, #14]
 8001674:	e00a      	b.n	800168c <INITPOSDET_Init+0x84>
	{
		handle->IdEvg[i] = (0.0);
 8001676:	89fb      	ldrh	r3, [r7, #14]
 8001678:	68ba      	ldr	r2, [r7, #8]
 800167a:	3308      	adds	r3, #8
 800167c:	009b      	lsls	r3, r3, #2
 800167e:	4413      	add	r3, r2
 8001680:	f04f 0200 	mov.w	r2, #0
 8001684:	605a      	str	r2, [r3, #4]
	handle->VolVecAngleOffset = (-0.5);//-0.1666667
	handle->VolVecAngleIntervalTime = VOL_VEC_ANGLE_INTERVAL_TIME_SCLAR;
	handle->IdSampAngleFlag = false;
	handle->IdSampAngle = (0.0);
	handle->IdSampAngleCount = 0;
	for (i = 0; i<VOL_VEC_ANGLE_SCLAR / 2; i++)
 8001686:	89fb      	ldrh	r3, [r7, #14]
 8001688:	3301      	adds	r3, #1
 800168a:	81fb      	strh	r3, [r7, #14]
 800168c:	89fb      	ldrh	r3, [r7, #14]
 800168e:	2b0b      	cmp	r3, #11
 8001690:	d9f1      	bls.n	8001676 <INITPOSDET_Init+0x6e>
	{
		handle->IdEvg[i] = (0.0);
	}
	handle->IdEvgCoeff = (1.0 / ID_EVG_SCLAR1);
 8001692:	68bb      	ldr	r3, [r7, #8]
 8001694:	4a09      	ldr	r2, [pc, #36]	; (80016bc <INITPOSDET_Init+0xb4>)
 8001696:	655a      	str	r2, [r3, #84]	; 0x54
	handle->IdEvgCount = 0;
 8001698:	68bb      	ldr	r3, [r7, #8]
 800169a:	2200      	movs	r2, #0
 800169c:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58

	handle->IdEvgTmp = (0.0);
 80016a0:	68bb      	ldr	r3, [r7, #8]
 80016a2:	f04f 0200 	mov.w	r2, #0
 80016a6:	65da      	str	r2, [r3, #92]	; 0x5c

	return(handle);
 80016a8:	68bb      	ldr	r3, [r7, #8]
}
 80016aa:	4618      	mov	r0, r3
 80016ac:	3714      	adds	r7, #20
 80016ae:	46bd      	mov	sp, r7
 80016b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80016b4:	4770      	bx	lr
 80016b6:	bf00      	nop
 80016b8:	3daaaaa6 	.word	0x3daaaaa6
 80016bc:	3ca3d70a 	.word	0x3ca3d70a

080016c0 <BubbleSort>:


void BubbleSort(float_t a[], uint16_t b[],uint16_t size)
{
 80016c0:	b480      	push	{r7}
 80016c2:	b089      	sub	sp, #36	; 0x24
 80016c4:	af00      	add	r7, sp, #0
 80016c6:	60f8      	str	r0, [r7, #12]
 80016c8:	60b9      	str	r1, [r7, #8]
 80016ca:	4613      	mov	r3, r2
 80016cc:	80fb      	strh	r3, [r7, #6]
	uint16_t lastSwapPos = 0,lastSwapPosTemp = 0;
 80016ce:	2300      	movs	r3, #0
 80016d0:	833b      	strh	r3, [r7, #24]
 80016d2:	2300      	movs	r3, #0
 80016d4:	83fb      	strh	r3, [r7, #30]
	uint16_t i,j;
	float_t temp;
	uint16_t temp1;
    for (i = 0; i < size - 1; i++)
 80016d6:	2300      	movs	r3, #0
 80016d8:	83bb      	strh	r3, [r7, #28]
 80016da:	e062      	b.n	80017a2 <BubbleSort+0xe2>
    {
        lastSwapPos = lastSwapPosTemp;
 80016dc:	8bfb      	ldrh	r3, [r7, #30]
 80016de:	833b      	strh	r3, [r7, #24]
        for (j = size - 1; j >lastSwapPos; j--)
 80016e0:	88fb      	ldrh	r3, [r7, #6]
 80016e2:	3b01      	subs	r3, #1
 80016e4:	837b      	strh	r3, [r7, #26]
 80016e6:	e050      	b.n	800178a <BubbleSort+0xca>
        {
            if (a[j - 1] < a[j])
 80016e8:	8b7a      	ldrh	r2, [r7, #26]
 80016ea:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
 80016ee:	4413      	add	r3, r2
 80016f0:	009b      	lsls	r3, r3, #2
 80016f2:	68fa      	ldr	r2, [r7, #12]
 80016f4:	4413      	add	r3, r2
 80016f6:	ed93 7a00 	vldr	s14, [r3]
 80016fa:	8b7b      	ldrh	r3, [r7, #26]
 80016fc:	009b      	lsls	r3, r3, #2
 80016fe:	68fa      	ldr	r2, [r7, #12]
 8001700:	4413      	add	r3, r2
 8001702:	edd3 7a00 	vldr	s15, [r3]
 8001706:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800170a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800170e:	d539      	bpl.n	8001784 <BubbleSort+0xc4>
            {
            	temp = a[j - 1];
 8001710:	8b7a      	ldrh	r2, [r7, #26]
 8001712:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
 8001716:	4413      	add	r3, r2
 8001718:	009b      	lsls	r3, r3, #2
 800171a:	68fa      	ldr	r2, [r7, #12]
 800171c:	4413      	add	r3, r2
 800171e:	681b      	ldr	r3, [r3, #0]
 8001720:	617b      	str	r3, [r7, #20]
                a[j - 1] = a[j];
 8001722:	8b7a      	ldrh	r2, [r7, #26]
 8001724:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
 8001728:	4413      	add	r3, r2
 800172a:	009b      	lsls	r3, r3, #2
 800172c:	68fa      	ldr	r2, [r7, #12]
 800172e:	4413      	add	r3, r2
 8001730:	8b7a      	ldrh	r2, [r7, #26]
 8001732:	0092      	lsls	r2, r2, #2
 8001734:	68f9      	ldr	r1, [r7, #12]
 8001736:	440a      	add	r2, r1
 8001738:	6812      	ldr	r2, [r2, #0]
 800173a:	601a      	str	r2, [r3, #0]
                a[j] = temp;
 800173c:	8b7b      	ldrh	r3, [r7, #26]
 800173e:	009b      	lsls	r3, r3, #2
 8001740:	68fa      	ldr	r2, [r7, #12]
 8001742:	4413      	add	r3, r2
 8001744:	697a      	ldr	r2, [r7, #20]
 8001746:	601a      	str	r2, [r3, #0]

                temp1 = b[j - 1];
 8001748:	8b7a      	ldrh	r2, [r7, #26]
 800174a:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 800174e:	4413      	add	r3, r2
 8001750:	005b      	lsls	r3, r3, #1
 8001752:	68ba      	ldr	r2, [r7, #8]
 8001754:	4413      	add	r3, r2
 8001756:	881b      	ldrh	r3, [r3, #0]
 8001758:	827b      	strh	r3, [r7, #18]
                b[j - 1] = b[j];
 800175a:	8b7a      	ldrh	r2, [r7, #26]
 800175c:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 8001760:	4413      	add	r3, r2
 8001762:	005b      	lsls	r3, r3, #1
 8001764:	68ba      	ldr	r2, [r7, #8]
 8001766:	4413      	add	r3, r2
 8001768:	8b7a      	ldrh	r2, [r7, #26]
 800176a:	0052      	lsls	r2, r2, #1
 800176c:	68b9      	ldr	r1, [r7, #8]
 800176e:	440a      	add	r2, r1
 8001770:	8812      	ldrh	r2, [r2, #0]
 8001772:	801a      	strh	r2, [r3, #0]
                b[j] = temp1;
 8001774:	8b7b      	ldrh	r3, [r7, #26]
 8001776:	005b      	lsls	r3, r3, #1
 8001778:	68ba      	ldr	r2, [r7, #8]
 800177a:	4413      	add	r3, r2
 800177c:	8a7a      	ldrh	r2, [r7, #18]
 800177e:	801a      	strh	r2, [r3, #0]

                lastSwapPosTemp = j;
 8001780:	8b7b      	ldrh	r3, [r7, #26]
 8001782:	83fb      	strh	r3, [r7, #30]
	float_t temp;
	uint16_t temp1;
    for (i = 0; i < size - 1; i++)
    {
        lastSwapPos = lastSwapPosTemp;
        for (j = size - 1; j >lastSwapPos; j--)
 8001784:	8b7b      	ldrh	r3, [r7, #26]
 8001786:	3b01      	subs	r3, #1
 8001788:	837b      	strh	r3, [r7, #26]
 800178a:	8b7a      	ldrh	r2, [r7, #26]
 800178c:	8b3b      	ldrh	r3, [r7, #24]
 800178e:	429a      	cmp	r2, r3
 8001790:	d8aa      	bhi.n	80016e8 <BubbleSort+0x28>
                b[j] = temp1;

                lastSwapPosTemp = j;
            }
        }
        if (lastSwapPos == lastSwapPosTemp)break;
 8001792:	8b3a      	ldrh	r2, [r7, #24]
 8001794:	8bfb      	ldrh	r3, [r7, #30]
 8001796:	429a      	cmp	r2, r3
 8001798:	d100      	bne.n	800179c <BubbleSort+0xdc>
 800179a:	e007      	b.n	80017ac <BubbleSort+0xec>
{
	uint16_t lastSwapPos = 0,lastSwapPosTemp = 0;
	uint16_t i,j;
	float_t temp;
	uint16_t temp1;
    for (i = 0; i < size - 1; i++)
 800179c:	8bbb      	ldrh	r3, [r7, #28]
 800179e:	3301      	adds	r3, #1
 80017a0:	83bb      	strh	r3, [r7, #28]
 80017a2:	8bba      	ldrh	r2, [r7, #28]
 80017a4:	88fb      	ldrh	r3, [r7, #6]
 80017a6:	3b01      	subs	r3, #1
 80017a8:	429a      	cmp	r2, r3
 80017aa:	db97      	blt.n	80016dc <BubbleSort+0x1c>
                lastSwapPosTemp = j;
            }
        }
        if (lastSwapPos == lastSwapPosTemp)break;
    }
}
 80017ac:	3724      	adds	r7, #36	; 0x24
 80017ae:	46bd      	mov	sp, r7
 80017b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80017b4:	4770      	bx	lr
 80017b6:	bf00      	nop

080017b8 <MATH_UINT16_T_ABS>:

uint16_t MATH_UINT16_T_ABS(uint16_t a, uint16_t b)
{
 80017b8:	b480      	push	{r7}
 80017ba:	b083      	sub	sp, #12
 80017bc:	af00      	add	r7, sp, #0
 80017be:	4603      	mov	r3, r0
 80017c0:	460a      	mov	r2, r1
 80017c2:	80fb      	strh	r3, [r7, #6]
 80017c4:	4613      	mov	r3, r2
 80017c6:	80bb      	strh	r3, [r7, #4]
	if(a>b)
 80017c8:	88fa      	ldrh	r2, [r7, #6]
 80017ca:	88bb      	ldrh	r3, [r7, #4]
 80017cc:	429a      	cmp	r2, r3
 80017ce:	d904      	bls.n	80017da <MATH_UINT16_T_ABS+0x22>
		return a-b;
 80017d0:	88fa      	ldrh	r2, [r7, #6]
 80017d2:	88bb      	ldrh	r3, [r7, #4]
 80017d4:	1ad3      	subs	r3, r2, r3
 80017d6:	b29b      	uxth	r3, r3
 80017d8:	e003      	b.n	80017e2 <MATH_UINT16_T_ABS+0x2a>
	else
		return b-a;
 80017da:	88ba      	ldrh	r2, [r7, #4]
 80017dc:	88fb      	ldrh	r3, [r7, #6]
 80017de:	1ad3      	subs	r3, r2, r3
 80017e0:	b29b      	uxth	r3, r3
}
 80017e2:	4618      	mov	r0, r3
 80017e4:	370c      	adds	r7, #12
 80017e6:	46bd      	mov	sp, r7
 80017e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80017ec:	4770      	bx	lr
 80017ee:	bf00      	nop

080017f0 <INITPOSDET_Run>:

void INITPOSDET_Run(INITPOSDET_Handle handle, float_t value)
{
 80017f0:	b580      	push	{r7, lr}
 80017f2:	b08e      	sub	sp, #56	; 0x38
 80017f4:	af00      	add	r7, sp, #0
 80017f6:	6078      	str	r0, [r7, #4]
 80017f8:	ed87 0a00 	vstr	s0, [r7]
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
 80017fc:	687b      	ldr	r3, [r7, #4]
 80017fe:	633b      	str	r3, [r7, #48]	; 0x30
	uint16_t i,InitPosAngleCount_Evg,InitPosAngleCount_Min,InitPosAngleCount_Mid,InitPosAngleCount_Max,b[VOL_VEC_ANGLE_SCLAR/2]={0};
 8001800:	f107 030c 	add.w	r3, r7, #12
 8001804:	2200      	movs	r2, #0
 8001806:	601a      	str	r2, [r3, #0]
 8001808:	3304      	adds	r3, #4
 800180a:	2200      	movs	r2, #0
 800180c:	601a      	str	r2, [r3, #0]
 800180e:	3304      	adds	r3, #4
 8001810:	2200      	movs	r2, #0
 8001812:	601a      	str	r2, [r3, #0]
 8001814:	3304      	adds	r3, #4
 8001816:	2200      	movs	r2, #0
 8001818:	601a      	str	r2, [r3, #0]
 800181a:	3304      	adds	r3, #4
 800181c:	2200      	movs	r2, #0
 800181e:	601a      	str	r2, [r3, #0]
 8001820:	3304      	adds	r3, #4
 8001822:	2200      	movs	r2, #0
 8001824:	601a      	str	r2, [r3, #0]
 8001826:	3304      	adds	r3, #4

	if(obj->IdSampAngleFlag)
 8001828:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800182a:	8b5b      	ldrh	r3, [r3, #26]
 800182c:	2b00      	cmp	r3, #0
 800182e:	f000 81be 	beq.w	8001bae <INITPOSDET_Run+0x3be>
	{
		if( obj->IdEvgCount<ID_EVG_SCLAR1*VOL_VEC_ANGLE_SCLAR/2 )
 8001832:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001834:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 8001838:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
 800183c:	f080 81b7 	bcs.w	8001bae <INITPOSDET_Run+0x3be>
		{
			if(obj->IdEvgCount>=ID_EVG_SCLAR2*VOL_VEC_ANGLE_SCLAR/2)// Need Improve
 8001840:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001842:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 8001846:	2b3b      	cmp	r3, #59	; 0x3b
 8001848:	d966      	bls.n	8001918 <INITPOSDET_Run+0x128>
			{
				float_t value_tmp = obj->IdEvg[obj->IdSampAngleCount]/(obj->IdEvgCount/(VOL_VEC_ANGLE_SCLAR/2));
 800184a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800184c:	8c1b      	ldrh	r3, [r3, #32]
 800184e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8001850:	3308      	adds	r3, #8
 8001852:	009b      	lsls	r3, r3, #2
 8001854:	4413      	add	r3, r2
 8001856:	ed93 7a01 	vldr	s14, [r3, #4]
 800185a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800185c:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 8001860:	4aa6      	ldr	r2, [pc, #664]	; (8001afc <INITPOSDET_Run+0x30c>)
 8001862:	fba2 2303 	umull	r2, r3, r2, r3
 8001866:	08db      	lsrs	r3, r3, #3
 8001868:	b29b      	uxth	r3, r3
 800186a:	ee07 3a90 	vmov	s15, r3
 800186e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8001872:	eec7 7a27 	vdiv.f32	s15, s14, s15
 8001876:	edc7 7a0b 	vstr	s15, [r7, #44]	; 0x2c
				if( MATH_abs( value_tmp - (obj->IdEvgCoeff * value) )
 800187a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800187c:	ed93 7a15 	vldr	s14, [r3, #84]	; 0x54
 8001880:	edd7 7a00 	vldr	s15, [r7]
 8001884:	ee67 7a27 	vmul.f32	s15, s14, s15
 8001888:	ed97 7a0b 	vldr	s14, [r7, #44]	; 0x2c
 800188c:	ee77 7a67 	vsub.f32	s15, s14, s15
 8001890:	eeb0 0a67 	vmov.f32	s0, s15
 8001894:	f7ff fe9a 	bl	80015cc <MATH_abs>
 8001898:	eef0 6a40 	vmov.f32	s13, s0
						> ((0.2f) * value_tmp) )
 800189c:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
 80018a0:	ed9f 7a97 	vldr	s14, [pc, #604]	; 8001b00 <INITPOSDET_Run+0x310>
 80018a4:	ee67 7a87 	vmul.f32	s15, s15, s14
		if( obj->IdEvgCount<ID_EVG_SCLAR1*VOL_VEC_ANGLE_SCLAR/2 )
		{
			if(obj->IdEvgCount>=ID_EVG_SCLAR2*VOL_VEC_ANGLE_SCLAR/2)// Need Improve
			{
				float_t value_tmp = obj->IdEvg[obj->IdSampAngleCount]/(obj->IdEvgCount/(VOL_VEC_ANGLE_SCLAR/2));
				if( MATH_abs( value_tmp - (obj->IdEvgCoeff * value) )
 80018a8:	eef4 6ae7 	vcmpe.f32	s13, s15
 80018ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80018b0:	dd16      	ble.n	80018e0 <INITPOSDET_Run+0xf0>
						> ((0.2f) * value_tmp) )
				{
					obj->IdEvg[obj->IdSampAngleCount] += value_tmp;
 80018b2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80018b4:	8c1b      	ldrh	r3, [r3, #32]
 80018b6:	4619      	mov	r1, r3
 80018b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80018ba:	8c1b      	ldrh	r3, [r3, #32]
 80018bc:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80018be:	3308      	adds	r3, #8
 80018c0:	009b      	lsls	r3, r3, #2
 80018c2:	4413      	add	r3, r2
 80018c4:	ed93 7a01 	vldr	s14, [r3, #4]
 80018c8:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
 80018cc:	ee77 7a27 	vadd.f32	s15, s14, s15
 80018d0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80018d2:	f101 0308 	add.w	r3, r1, #8
 80018d6:	009b      	lsls	r3, r3, #2
 80018d8:	4413      	add	r3, r2
 80018da:	edc3 7a01 	vstr	s15, [r3, #4]
 80018de:	e036      	b.n	800194e <INITPOSDET_Run+0x15e>
				}
				else
				{
					obj->IdEvg[obj->IdSampAngleCount] += (obj->IdEvgCoeff * value);
 80018e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80018e2:	8c1b      	ldrh	r3, [r3, #32]
 80018e4:	4619      	mov	r1, r3
 80018e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80018e8:	8c1b      	ldrh	r3, [r3, #32]
 80018ea:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80018ec:	3308      	adds	r3, #8
 80018ee:	009b      	lsls	r3, r3, #2
 80018f0:	4413      	add	r3, r2
 80018f2:	ed93 7a01 	vldr	s14, [r3, #4]
 80018f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80018f8:	edd3 6a15 	vldr	s13, [r3, #84]	; 0x54
 80018fc:	edd7 7a00 	vldr	s15, [r7]
 8001900:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8001904:	ee77 7a27 	vadd.f32	s15, s14, s15
 8001908:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800190a:	f101 0308 	add.w	r3, r1, #8
 800190e:	009b      	lsls	r3, r3, #2
 8001910:	4413      	add	r3, r2
 8001912:	edc3 7a01 	vstr	s15, [r3, #4]
 8001916:	e01a      	b.n	800194e <INITPOSDET_Run+0x15e>
				}
			}
			else
			{
				obj->IdEvg[obj->IdSampAngleCount] += (obj->IdEvgCoeff * value);
 8001918:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800191a:	8c1b      	ldrh	r3, [r3, #32]
 800191c:	4619      	mov	r1, r3
 800191e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001920:	8c1b      	ldrh	r3, [r3, #32]
 8001922:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8001924:	3308      	adds	r3, #8
 8001926:	009b      	lsls	r3, r3, #2
 8001928:	4413      	add	r3, r2
 800192a:	ed93 7a01 	vldr	s14, [r3, #4]
 800192e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001930:	edd3 6a15 	vldr	s13, [r3, #84]	; 0x54
 8001934:	edd7 7a00 	vldr	s15, [r7]
 8001938:	ee66 7aa7 	vmul.f32	s15, s13, s15
 800193c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8001940:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8001942:	f101 0308 	add.w	r3, r1, #8
 8001946:	009b      	lsls	r3, r3, #2
 8001948:	4413      	add	r3, r2
 800194a:	edc3 7a01 	vstr	s15, [r3, #4]
			}

			obj->IdEvgCount++;
 800194e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001950:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 8001954:	3301      	adds	r3, #1
 8001956:	b29a      	uxth	r2, r3
 8001958:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800195a:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58

			if( obj->IdEvgCount>=ID_EVG_SCLAR1*VOL_VEC_ANGLE_SCLAR/2 )
 800195e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001960:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 8001964:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
 8001968:	f0c0 8121 	bcc.w	8001bae <INITPOSDET_Run+0x3be>
//						Id_max = obj->IdEvg[i];
//						obj->InitPosAngleCount = i;
//					}
//				}

				for(i=0;i<VOL_VEC_ANGLE_SCLAR/2;i++)
 800196c:	2300      	movs	r3, #0
 800196e:	86fb      	strh	r3, [r7, #54]	; 0x36
 8001970:	e00a      	b.n	8001988 <INITPOSDET_Run+0x198>
				{
					b[i]=i;
 8001972:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8001974:	005b      	lsls	r3, r3, #1
 8001976:	f107 0238 	add.w	r2, r7, #56	; 0x38
 800197a:	4413      	add	r3, r2
 800197c:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 800197e:	f823 2c2c 	strh.w	r2, [r3, #-44]
//						Id_max = obj->IdEvg[i];
//						obj->InitPosAngleCount = i;
//					}
//				}

				for(i=0;i<VOL_VEC_ANGLE_SCLAR/2;i++)
 8001982:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8001984:	3301      	adds	r3, #1
 8001986:	86fb      	strh	r3, [r7, #54]	; 0x36
 8001988:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 800198a:	2b0b      	cmp	r3, #11
 800198c:	d9f1      	bls.n	8001972 <INITPOSDET_Run+0x182>
				{
					b[i]=i;
					//obj->IdEvgArray[obj->ArrayCount][i]=obj->IdEvg[i];
				}

				obj->IdEvg[0]=0;obj->IdEvg[1]=2;obj->IdEvg[2]=4;obj->IdEvg[3]=6;obj->IdEvg[4]=8;obj->IdEvg[5]=10;
 800198e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001990:	f04f 0200 	mov.w	r2, #0
 8001994:	625a      	str	r2, [r3, #36]	; 0x24
 8001996:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001998:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800199c:	629a      	str	r2, [r3, #40]	; 0x28
 800199e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80019a0:	f04f 4281 	mov.w	r2, #1082130432	; 0x40800000
 80019a4:	62da      	str	r2, [r3, #44]	; 0x2c
 80019a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80019a8:	4a56      	ldr	r2, [pc, #344]	; (8001b04 <INITPOSDET_Run+0x314>)
 80019aa:	631a      	str	r2, [r3, #48]	; 0x30
 80019ac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80019ae:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
 80019b2:	635a      	str	r2, [r3, #52]	; 0x34
 80019b4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80019b6:	4a54      	ldr	r2, [pc, #336]	; (8001b08 <INITPOSDET_Run+0x318>)
 80019b8:	639a      	str	r2, [r3, #56]	; 0x38
				obj->IdEvg[6]=1;obj->IdEvg[7]=3;obj->IdEvg[8]=5;obj->IdEvg[9]=7;obj->IdEvg[10]=9;obj->IdEvg[11]=11;
 80019ba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80019bc:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 80019c0:	63da      	str	r2, [r3, #60]	; 0x3c
 80019c2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80019c4:	4a51      	ldr	r2, [pc, #324]	; (8001b0c <INITPOSDET_Run+0x31c>)
 80019c6:	641a      	str	r2, [r3, #64]	; 0x40
 80019c8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80019ca:	4a51      	ldr	r2, [pc, #324]	; (8001b10 <INITPOSDET_Run+0x320>)
 80019cc:	645a      	str	r2, [r3, #68]	; 0x44
 80019ce:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80019d0:	4a50      	ldr	r2, [pc, #320]	; (8001b14 <INITPOSDET_Run+0x324>)
 80019d2:	649a      	str	r2, [r3, #72]	; 0x48
 80019d4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80019d6:	4a50      	ldr	r2, [pc, #320]	; (8001b18 <INITPOSDET_Run+0x328>)
 80019d8:	64da      	str	r2, [r3, #76]	; 0x4c
 80019da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80019dc:	4a4f      	ldr	r2, [pc, #316]	; (8001b1c <INITPOSDET_Run+0x32c>)
 80019de:	651a      	str	r2, [r3, #80]	; 0x50
				BubbleSort(obj->IdEvg,b,VOL_VEC_ANGLE_SCLAR/2);
 80019e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80019e2:	f103 0224 	add.w	r2, r3, #36	; 0x24
 80019e6:	f107 030c 	add.w	r3, r7, #12
 80019ea:	4610      	mov	r0, r2
 80019ec:	4619      	mov	r1, r3
 80019ee:	220c      	movs	r2, #12
 80019f0:	f7ff fe66 	bl	80016c0 <BubbleSort>

				InitPosAngleCount_Evg = (b[0] + b[1] + b[2] + b[3] + b[4])/5;
 80019f4:	89bb      	ldrh	r3, [r7, #12]
 80019f6:	461a      	mov	r2, r3
 80019f8:	89fb      	ldrh	r3, [r7, #14]
 80019fa:	4413      	add	r3, r2
 80019fc:	8a3a      	ldrh	r2, [r7, #16]
 80019fe:	4413      	add	r3, r2
 8001a00:	8a7a      	ldrh	r2, [r7, #18]
 8001a02:	4413      	add	r3, r2
 8001a04:	8aba      	ldrh	r2, [r7, #20]
 8001a06:	4413      	add	r3, r2
 8001a08:	4a45      	ldr	r2, [pc, #276]	; (8001b20 <INITPOSDET_Run+0x330>)
 8001a0a:	fb82 1203 	smull	r1, r2, r2, r3
 8001a0e:	1052      	asrs	r2, r2, #1
 8001a10:	17db      	asrs	r3, r3, #31
 8001a12:	1ad3      	subs	r3, r2, r3
 8001a14:	857b      	strh	r3, [r7, #42]	; 0x2a
				InitPosAngleCount_Min = MATH_UINT16_T_ABS(b[0],InitPosAngleCount_Evg);
 8001a16:	89ba      	ldrh	r2, [r7, #12]
 8001a18:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8001a1a:	4610      	mov	r0, r2
 8001a1c:	4619      	mov	r1, r3
 8001a1e:	f7ff fecb 	bl	80017b8 <MATH_UINT16_T_ABS>
 8001a22:	4603      	mov	r3, r0
 8001a24:	853b      	strh	r3, [r7, #40]	; 0x28
				InitPosAngleCount_Mid = MATH_UINT16_T_ABS(b[1],InitPosAngleCount_Evg);
 8001a26:	89fa      	ldrh	r2, [r7, #14]
 8001a28:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8001a2a:	4610      	mov	r0, r2
 8001a2c:	4619      	mov	r1, r3
 8001a2e:	f7ff fec3 	bl	80017b8 <MATH_UINT16_T_ABS>
 8001a32:	4603      	mov	r3, r0
 8001a34:	84fb      	strh	r3, [r7, #38]	; 0x26
				InitPosAngleCount_Max = MATH_UINT16_T_ABS(b[2],InitPosAngleCount_Evg);
 8001a36:	8a3a      	ldrh	r2, [r7, #16]
 8001a38:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8001a3a:	4610      	mov	r0, r2
 8001a3c:	4619      	mov	r1, r3
 8001a3e:	f7ff febb 	bl	80017b8 <MATH_UINT16_T_ABS>
 8001a42:	4603      	mov	r3, r0
 8001a44:	84bb      	strh	r3, [r7, #36]	; 0x24
				if( InitPosAngleCount_Min < InitPosAngleCount_Mid && InitPosAngleCount_Min < InitPosAngleCount_Max )
 8001a46:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 8001a48:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8001a4a:	429a      	cmp	r2, r3
 8001a4c:	d207      	bcs.n	8001a5e <INITPOSDET_Run+0x26e>
 8001a4e:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 8001a50:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8001a52:	429a      	cmp	r2, r3
 8001a54:	d203      	bcs.n	8001a5e <INITPOSDET_Run+0x26e>
				{
					obj->InitPosAngleCount = b[0];
 8001a56:	89ba      	ldrh	r2, [r7, #12]
 8001a58:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001a5a:	805a      	strh	r2, [r3, #2]
 8001a5c:	e016      	b.n	8001a8c <INITPOSDET_Run+0x29c>
				}
				else if( InitPosAngleCount_Mid < InitPosAngleCount_Min && InitPosAngleCount_Mid < InitPosAngleCount_Max )
 8001a5e:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8001a60:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8001a62:	429a      	cmp	r2, r3
 8001a64:	d207      	bcs.n	8001a76 <INITPOSDET_Run+0x286>
 8001a66:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8001a68:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8001a6a:	429a      	cmp	r2, r3
 8001a6c:	d203      	bcs.n	8001a76 <INITPOSDET_Run+0x286>
				{
					obj->InitPosAngleCount = b[1];
 8001a6e:	89fa      	ldrh	r2, [r7, #14]
 8001a70:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001a72:	805a      	strh	r2, [r3, #2]
 8001a74:	e00a      	b.n	8001a8c <INITPOSDET_Run+0x29c>
				}
				else if( InitPosAngleCount_Max < InitPosAngleCount_Min && InitPosAngleCount_Max < InitPosAngleCount_Mid )
 8001a76:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8001a78:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8001a7a:	429a      	cmp	r2, r3
 8001a7c:	d206      	bcs.n	8001a8c <INITPOSDET_Run+0x29c>
 8001a7e:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8001a80:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8001a82:	429a      	cmp	r2, r3
 8001a84:	d202      	bcs.n	8001a8c <INITPOSDET_Run+0x29c>
				{
					obj->InitPosAngleCount = b[2];
 8001a86:	8a3a      	ldrh	r2, [r7, #16]
 8001a88:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001a8a:	805a      	strh	r2, [r3, #2]
				}
				
				obj->InitPosAngle = obj->InitPosAngleCount*obj->SubdivideAngle + obj->VolVecAngleOffset;
 8001a8c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001a8e:	885b      	ldrh	r3, [r3, #2]
 8001a90:	ee07 3a90 	vmov	s15, r3
 8001a94:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8001a98:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001a9a:	edd3 7a02 	vldr	s15, [r3, #8]
 8001a9e:	ee27 7a27 	vmul.f32	s14, s14, s15
 8001aa2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001aa4:	edd3 7a05 	vldr	s15, [r3, #20]
 8001aa8:	ee77 7a27 	vadd.f32	s15, s14, s15
 8001aac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001aae:	edc3 7a01 	vstr	s15, [r3, #4]
				obj->VolVecAngleOffset = obj->InitPosAngle - obj->SubdivideAngle - obj->SubdivideAngle;
 8001ab2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001ab4:	ed93 7a01 	vldr	s14, [r3, #4]
 8001ab8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001aba:	edd3 7a02 	vldr	s15, [r3, #8]
 8001abe:	ee37 7a67 	vsub.f32	s14, s14, s15
 8001ac2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001ac4:	edd3 7a02 	vldr	s15, [r3, #8]
 8001ac8:	ee77 7a67 	vsub.f32	s15, s14, s15
 8001acc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001ace:	edc3 7a05 	vstr	s15, [r3, #20]
				if( obj->VolVecAngleOffset > (1.0f) )
 8001ad2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001ad4:	edd3 7a05 	vldr	s15, [r3, #20]
 8001ad8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8001adc:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001ae0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001ae4:	dd22      	ble.n	8001b2c <INITPOSDET_Run+0x33c>
					obj->VolVecAngleOffset -= (1.0f);
 8001ae6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001ae8:	edd3 7a05 	vldr	s15, [r3, #20]
 8001aec:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8001af0:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8001af4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001af6:	edc3 7a05 	vstr	s15, [r3, #20]
 8001afa:	e02b      	b.n	8001b54 <INITPOSDET_Run+0x364>
 8001afc:	aaaaaaab 	.word	0xaaaaaaab
 8001b00:	3e4ccccd 	.word	0x3e4ccccd
 8001b04:	40c00000 	.word	0x40c00000
 8001b08:	41200000 	.word	0x41200000
 8001b0c:	40400000 	.word	0x40400000
 8001b10:	40a00000 	.word	0x40a00000
 8001b14:	40e00000 	.word	0x40e00000
 8001b18:	41100000 	.word	0x41100000
 8001b1c:	41300000 	.word	0x41300000
 8001b20:	66666667 	.word	0x66666667
 8001b24:	3eaaaa9f 	.word	0x3eaaaa9f
 8001b28:	3c23d70a 	.word	0x3c23d70a
				else if( obj->VolVecAngleOffset < (-1.0f) )
 8001b2c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b2e:	edd3 7a05 	vldr	s15, [r3, #20]
 8001b32:	eebf 7a00 	vmov.f32	s14, #240	; 0xf0
 8001b36:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001b3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001b3e:	d509      	bpl.n	8001b54 <INITPOSDET_Run+0x364>
					obj->VolVecAngleOffset += (1.0f);
 8001b40:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b42:	edd3 7a05 	vldr	s15, [r3, #20]
 8001b46:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8001b4a:	ee77 7a87 	vadd.f32	s15, s15, s14
 8001b4e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b50:	edc3 7a05 	vstr	s15, [r3, #20]
				obj->SubdivideAngle = (obj->SubdivideAngle * (0.333333f));//(0.5f) Test:(1.0f)
 8001b54:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b56:	edd3 7a02 	vldr	s15, [r3, #8]
 8001b5a:	ed1f 7a0e 	vldr	s14, [pc, #-56]	; 8001b24 <INITPOSDET_Run+0x334>
 8001b5e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8001b62:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b64:	edc3 7a02 	vstr	s15, [r3, #8]
				if( obj->SubdivideAngle < (0.01f) )// 0.005f Test: 0.01f
 8001b68:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b6a:	edd3 7a02 	vldr	s15, [r3, #8]
 8001b6e:	ed1f 7a12 	vldr	s14, [pc, #-72]	; 8001b28 <INITPOSDET_Run+0x338>
 8001b72:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001b76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001b7a:	d503      	bpl.n	8001b84 <INITPOSDET_Run+0x394>
				{
					obj->InitPosDetFlag = false;
 8001b7c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b7e:	2200      	movs	r2, #0
 8001b80:	801a      	strh	r2, [r3, #0]
 8001b82:	e014      	b.n	8001bae <INITPOSDET_Run+0x3be>
				}
				else
				{
					obj->IdEvgCount = 0;
 8001b84:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001b86:	2200      	movs	r2, #0
 8001b88:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
					for(i=0;i<VOL_VEC_ANGLE_SCLAR/2;i++)
 8001b8c:	2300      	movs	r3, #0
 8001b8e:	86fb      	strh	r3, [r7, #54]	; 0x36
 8001b90:	e00a      	b.n	8001ba8 <INITPOSDET_Run+0x3b8>
					{
						obj->IdEvg[i] = (0.0f);
 8001b92:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8001b94:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8001b96:	3308      	adds	r3, #8
 8001b98:	009b      	lsls	r3, r3, #2
 8001b9a:	4413      	add	r3, r2
 8001b9c:	f04f 0200 	mov.w	r2, #0
 8001ba0:	605a      	str	r2, [r3, #4]
					obj->InitPosDetFlag = false;
				}
				else
				{
					obj->IdEvgCount = 0;
					for(i=0;i<VOL_VEC_ANGLE_SCLAR/2;i++)
 8001ba2:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8001ba4:	3301      	adds	r3, #1
 8001ba6:	86fb      	strh	r3, [r7, #54]	; 0x36
 8001ba8:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8001baa:	2b0b      	cmp	r3, #11
 8001bac:	d9f1      	bls.n	8001b92 <INITPOSDET_Run+0x3a2>
//				obj->IdEvgCount = 0;
			}
		}
	}

	return;
 8001bae:	bf00      	nop
}
 8001bb0:	3738      	adds	r7, #56	; 0x38
 8001bb2:	46bd      	mov	sp, r7
 8001bb4:	bd80      	pop	{r7, pc}
 8001bb6:	bf00      	nop

08001bb8 <INITPOSDET_VolVecAngleRun>:


void INITPOSDET_VolVecAngleRun(INITPOSDET_Handle handle)
{
 8001bb8:	b480      	push	{r7}
 8001bba:	b085      	sub	sp, #20
 8001bbc:	af00      	add	r7, sp, #0
 8001bbe:	6078      	str	r0, [r7, #4]
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
 8001bc0:	687b      	ldr	r3, [r7, #4]
 8001bc2:	60fb      	str	r3, [r7, #12]
	uint16_t count_temp = 0;
 8001bc4:	2300      	movs	r3, #0
 8001bc6:	817b      	strh	r3, [r7, #10]

	if(obj->InitPosDetFlag)
 8001bc8:	68fb      	ldr	r3, [r7, #12]
 8001bca:	881b      	ldrh	r3, [r3, #0]
 8001bcc:	2b00      	cmp	r3, #0
 8001bce:	f000 8087 	beq.w	8001ce0 <INITPOSDET_VolVecAngleRun+0x128>
	{
		if( obj->VolVecAngleIntervalTime >= VOL_VEC_ANGLE_INTERVAL_TIME_SCLAR )
 8001bd2:	68fb      	ldr	r3, [r7, #12]
 8001bd4:	8b1b      	ldrh	r3, [r3, #24]
 8001bd6:	2b09      	cmp	r3, #9
 8001bd8:	d975      	bls.n	8001cc6 <INITPOSDET_VolVecAngleRun+0x10e>
		{
			if( obj->VolVecAngleCount < VOL_VEC_ANGLE_SCLAR )
 8001bda:	68fb      	ldr	r3, [r7, #12]
 8001bdc:	89db      	ldrh	r3, [r3, #14]
 8001bde:	2b17      	cmp	r3, #23
 8001be0:	f200 8084 	bhi.w	8001cec <INITPOSDET_VolVecAngleRun+0x134>
			{
				count_temp = obj->VolVecAngleCount / 2;
 8001be4:	68fb      	ldr	r3, [r7, #12]
 8001be6:	89db      	ldrh	r3, [r3, #14]
 8001be8:	085b      	lsrs	r3, r3, #1
 8001bea:	817b      	strh	r3, [r7, #10]
				obj->VolVecAngle = count_temp * obj->SubdivideAngle + obj->VolVecAngleOffset;
 8001bec:	897b      	ldrh	r3, [r7, #10]
 8001bee:	ee07 3a90 	vmov	s15, r3
 8001bf2:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8001bf6:	68fb      	ldr	r3, [r7, #12]
 8001bf8:	edd3 7a02 	vldr	s15, [r3, #8]
 8001bfc:	ee27 7a27 	vmul.f32	s14, s14, s15
 8001c00:	68fb      	ldr	r3, [r7, #12]
 8001c02:	edd3 7a05 	vldr	s15, [r3, #20]
 8001c06:	ee77 7a27 	vadd.f32	s15, s14, s15
 8001c0a:	68fb      	ldr	r3, [r7, #12]
 8001c0c:	edc3 7a04 	vstr	s15, [r3, #16]
				obj->IdSampAngle = obj->VolVecAngle;
 8001c10:	68fb      	ldr	r3, [r7, #12]
 8001c12:	691a      	ldr	r2, [r3, #16]
 8001c14:	68fb      	ldr	r3, [r7, #12]
 8001c16:	61da      	str	r2, [r3, #28]
				obj->IdSampAngleFlag = false;
 8001c18:	68fb      	ldr	r3, [r7, #12]
 8001c1a:	2200      	movs	r2, #0
 8001c1c:	835a      	strh	r2, [r3, #26]
				obj->IdSampAngleCount = count_temp;
 8001c1e:	68fb      	ldr	r3, [r7, #12]
 8001c20:	897a      	ldrh	r2, [r7, #10]
 8001c22:	841a      	strh	r2, [r3, #32]
				if( obj->VolVecAngleCount %2 == 1 )
 8001c24:	68fb      	ldr	r3, [r7, #12]
 8001c26:	89db      	ldrh	r3, [r3, #14]
 8001c28:	f003 0301 	and.w	r3, r3, #1
 8001c2c:	b29b      	uxth	r3, r3
 8001c2e:	2b00      	cmp	r3, #0
 8001c30:	d00f      	beq.n	8001c52 <INITPOSDET_VolVecAngleRun+0x9a>
				{
					obj->VolVecAngle += (0.5f);
 8001c32:	68fb      	ldr	r3, [r7, #12]
 8001c34:	edd3 7a04 	vldr	s15, [r3, #16]
 8001c38:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 8001c3c:	ee77 7a87 	vadd.f32	s15, s15, s14
 8001c40:	68fb      	ldr	r3, [r7, #12]
 8001c42:	edc3 7a04 	vstr	s15, [r3, #16]
					obj->VolVecAngleIntervalTime = 1;
 8001c46:	68fb      	ldr	r3, [r7, #12]
 8001c48:	2201      	movs	r2, #1
 8001c4a:	831a      	strh	r2, [r3, #24]
					obj->IdSampAngleFlag = true;
 8001c4c:	68fb      	ldr	r3, [r7, #12]
 8001c4e:	2201      	movs	r2, #1
 8001c50:	835a      	strh	r2, [r3, #26]
				}
				if( obj->VolVecAngle > (1.0f) )
 8001c52:	68fb      	ldr	r3, [r7, #12]
 8001c54:	edd3 7a04 	vldr	s15, [r3, #16]
 8001c58:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8001c5c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001c60:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001c64:	dd0a      	ble.n	8001c7c <INITPOSDET_VolVecAngleRun+0xc4>
					obj->VolVecAngle -= (1.0f);
 8001c66:	68fb      	ldr	r3, [r7, #12]
 8001c68:	edd3 7a04 	vldr	s15, [r3, #16]
 8001c6c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8001c70:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8001c74:	68fb      	ldr	r3, [r7, #12]
 8001c76:	edc3 7a04 	vstr	s15, [r3, #16]
 8001c7a:	e013      	b.n	8001ca4 <INITPOSDET_VolVecAngleRun+0xec>
				else if( obj->VolVecAngle < (-1.0f) )
 8001c7c:	68fb      	ldr	r3, [r7, #12]
 8001c7e:	edd3 7a04 	vldr	s15, [r3, #16]
 8001c82:	eebf 7a00 	vmov.f32	s14, #240	; 0xf0
 8001c86:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001c8a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001c8e:	d509      	bpl.n	8001ca4 <INITPOSDET_VolVecAngleRun+0xec>
					obj->VolVecAngle += (1.0f);
 8001c90:	68fb      	ldr	r3, [r7, #12]
 8001c92:	edd3 7a04 	vldr	s15, [r3, #16]
 8001c96:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8001c9a:	ee77 7a87 	vadd.f32	s15, s15, s14
 8001c9e:	68fb      	ldr	r3, [r7, #12]
 8001ca0:	edc3 7a04 	vstr	s15, [r3, #16]

				obj->VolVecAngleCount++;
 8001ca4:	68fb      	ldr	r3, [r7, #12]
 8001ca6:	89db      	ldrh	r3, [r3, #14]
 8001ca8:	3301      	adds	r3, #1
 8001caa:	b29a      	uxth	r2, r3
 8001cac:	68fb      	ldr	r3, [r7, #12]
 8001cae:	81da      	strh	r2, [r3, #14]

				obj->VolVecAngleFlag = true;
 8001cb0:	68fb      	ldr	r3, [r7, #12]
 8001cb2:	2201      	movs	r2, #1
 8001cb4:	819a      	strh	r2, [r3, #12]

				if( obj->VolVecAngleCount >= VOL_VEC_ANGLE_SCLAR )
 8001cb6:	68fb      	ldr	r3, [r7, #12]
 8001cb8:	89db      	ldrh	r3, [r3, #14]
 8001cba:	2b17      	cmp	r3, #23
 8001cbc:	d916      	bls.n	8001cec <INITPOSDET_VolVecAngleRun+0x134>
				{
					obj->VolVecAngleCount=0;
 8001cbe:	68fb      	ldr	r3, [r7, #12]
 8001cc0:	2200      	movs	r2, #0
 8001cc2:	81da      	strh	r2, [r3, #14]
 8001cc4:	e012      	b.n	8001cec <INITPOSDET_VolVecAngleRun+0x134>
				}
			}
		}
		else
		{
			obj->VolVecAngleIntervalTime++;
 8001cc6:	68fb      	ldr	r3, [r7, #12]
 8001cc8:	8b1b      	ldrh	r3, [r3, #24]
 8001cca:	3301      	adds	r3, #1
 8001ccc:	b29a      	uxth	r2, r3
 8001cce:	68fb      	ldr	r3, [r7, #12]
 8001cd0:	831a      	strh	r2, [r3, #24]
			obj->VolVecAngleFlag = false;
 8001cd2:	68fb      	ldr	r3, [r7, #12]
 8001cd4:	2200      	movs	r2, #0
 8001cd6:	819a      	strh	r2, [r3, #12]
			obj->IdSampAngleFlag = false;
 8001cd8:	68fb      	ldr	r3, [r7, #12]
 8001cda:	2200      	movs	r2, #0
 8001cdc:	835a      	strh	r2, [r3, #26]
	else
	{
		obj->VolVecAngleFlag = false;
		obj->IdSampAngleFlag = false;
	}
	return;
 8001cde:	e006      	b.n	8001cee <INITPOSDET_VolVecAngleRun+0x136>
			obj->IdSampAngleFlag = false;
		}
	}
	else
	{
		obj->VolVecAngleFlag = false;
 8001ce0:	68fb      	ldr	r3, [r7, #12]
 8001ce2:	2200      	movs	r2, #0
 8001ce4:	819a      	strh	r2, [r3, #12]
		obj->IdSampAngleFlag = false;
 8001ce6:	68fb      	ldr	r3, [r7, #12]
 8001ce8:	2200      	movs	r2, #0
 8001cea:	835a      	strh	r2, [r3, #26]
	}
	return;
 8001cec:	bf00      	nop
}
 8001cee:	3714      	adds	r7, #20
 8001cf0:	46bd      	mov	sp, r7
 8001cf2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001cf6:	4770      	bx	lr

08001cf8 <MATH_sat>:
//! \param[in] in   The input value
//! \param[in] max  The maximum value allowed
//! \param[in] min  The minimum value allowed
//! \return    The saturated value
static inline float_t MATH_sat(const float_t in,const float_t max,const float_t min)
{
 8001cf8:	b480      	push	{r7}
 8001cfa:	b087      	sub	sp, #28
 8001cfc:	af00      	add	r7, sp, #0
 8001cfe:	ed87 0a03 	vstr	s0, [r7, #12]
 8001d02:	edc7 0a02 	vstr	s1, [r7, #8]
 8001d06:	ed87 1a01 	vstr	s2, [r7, #4]
  float_t out = in;
 8001d0a:	68fb      	ldr	r3, [r7, #12]
 8001d0c:	617b      	str	r3, [r7, #20]


  if(in < min)
 8001d0e:	ed97 7a03 	vldr	s14, [r7, #12]
 8001d12:	edd7 7a01 	vldr	s15, [r7, #4]
 8001d16:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8001d1a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001d1e:	d502      	bpl.n	8001d26 <MATH_sat+0x2e>
    {
      out = min;
 8001d20:	687b      	ldr	r3, [r7, #4]
 8001d22:	617b      	str	r3, [r7, #20]
 8001d24:	e00a      	b.n	8001d3c <MATH_sat+0x44>
    }
  else if(in > max)
 8001d26:	ed97 7a03 	vldr	s14, [r7, #12]
 8001d2a:	edd7 7a02 	vldr	s15, [r7, #8]
 8001d2e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8001d32:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001d36:	dd01      	ble.n	8001d3c <MATH_sat+0x44>
    {
      out = max;
 8001d38:	68bb      	ldr	r3, [r7, #8]
 8001d3a:	617b      	str	r3, [r7, #20]
    }

  return(out);
 8001d3c:	697b      	ldr	r3, [r7, #20]
 8001d3e:	ee07 3a90 	vmov	s15, r3
} // end of MATH_sat() function
 8001d42:	eeb0 0a67 	vmov.f32	s0, s15
 8001d46:	371c      	adds	r7, #28
 8001d48:	46bd      	mov	sp, r7
 8001d4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d4e:	4770      	bx	lr

08001d50 <DATA_TXD_Status>:
	}
	else return true;
}

static inline uint8_t DATA_TXD_Status(DATA_RTXD_Handle handle)
{
 8001d50:	b480      	push	{r7}
 8001d52:	b085      	sub	sp, #20
 8001d54:	af00      	add	r7, sp, #0
 8001d56:	6078      	str	r0, [r7, #4]
	DATA_RTXD_Obj *obj = (DATA_RTXD_Obj *)handle;
 8001d58:	687b      	ldr	r3, [r7, #4]
 8001d5a:	60fb      	str	r3, [r7, #12]

	if( obj->data_txd_num == DATA_TXD_SIZE )
 8001d5c:	68fb      	ldr	r3, [r7, #12]
 8001d5e:	7b9b      	ldrb	r3, [r3, #14]
 8001d60:	2b0d      	cmp	r3, #13
 8001d62:	d101      	bne.n	8001d68 <DATA_TXD_Status+0x18>
	{
		return false;
 8001d64:	2300      	movs	r3, #0
 8001d66:	e000      	b.n	8001d6a <DATA_TXD_Status+0x1a>
	}
	else return true;
 8001d68:	2301      	movs	r3, #1
}
 8001d6a:	4618      	mov	r0, r3
 8001d6c:	3714      	adds	r7, #20
 8001d6e:	46bd      	mov	sp, r7
 8001d70:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d74:	4770      	bx	lr
 8001d76:	bf00      	nop

08001d78 <Get_DATA_TXD_Ptr>:

	return value;
}

static inline uint8_t* Get_DATA_TXD_Ptr(DATA_RTXD_Handle handle)
{
 8001d78:	b480      	push	{r7}
 8001d7a:	b085      	sub	sp, #20
 8001d7c:	af00      	add	r7, sp, #0
 8001d7e:	6078      	str	r0, [r7, #4]
	DATA_RTXD_Obj *obj = (DATA_RTXD_Obj *)handle;
 8001d80:	687b      	ldr	r3, [r7, #4]
 8001d82:	60fb      	str	r3, [r7, #12]
	
	obj->data_txd_num = DATA_TXD_SIZE;
 8001d84:	68fb      	ldr	r3, [r7, #12]
 8001d86:	220d      	movs	r2, #13
 8001d88:	739a      	strb	r2, [r3, #14]

	return obj->data_txd;
 8001d8a:	68fb      	ldr	r3, [r7, #12]
 8001d8c:	330f      	adds	r3, #15
}
 8001d8e:	4618      	mov	r0, r3
 8001d90:	3714      	adds	r7, #20
 8001d92:	46bd      	mov	sp, r7
 8001d94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d98:	4770      	bx	lr
 8001d9a:	bf00      	nop

08001d9c <HAL_getCurrentScaleFactor>:
//!             This scale factor is not used when converting between PU amps
//!             and real amps.
//! \param[in]  handle  The hardware abstraction layer (HAL) handle
//! \return     The current scale factor
static inline float_t HAL_getCurrentScaleFactor(HAL_Handle handle)//! \Mod By Dl.K
{
 8001d9c:	b480      	push	{r7}
 8001d9e:	b085      	sub	sp, #20
 8001da0:	af00      	add	r7, sp, #0
 8001da2:	6078      	str	r0, [r7, #4]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8001da4:	687b      	ldr	r3, [r7, #4]
 8001da6:	60fb      	str	r3, [r7, #12]

  return(obj->current_sf);
 8001da8:	68fb      	ldr	r3, [r7, #12]
 8001daa:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 8001dae:	ee07 3a90 	vmov	s15, r3
} // end of HAL_getCurrentScaleFactor() function
 8001db2:	eeb0 0a67 	vmov.f32	s0, s15
 8001db6:	3714      	adds	r7, #20
 8001db8:	46bd      	mov	sp, r7
 8001dba:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001dbe:	4770      	bx	lr

08001dc0 <HAL_getVoltageScaleFactor>:
//!             This scale factor is not used when converting between PU volts
//!             and real volts.
//! \param[in]  handle  The hardware abstraction layer (HAL) handle
//! \return     The voltage scale factor
static inline float_t HAL_getVoltageScaleFactor(HAL_Handle handle)//! \Mod By Dl.K
{
 8001dc0:	b480      	push	{r7}
 8001dc2:	b085      	sub	sp, #20
 8001dc4:	af00      	add	r7, sp, #0
 8001dc6:	6078      	str	r0, [r7, #4]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8001dc8:	687b      	ldr	r3, [r7, #4]
 8001dca:	60fb      	str	r3, [r7, #12]

  return(obj->voltage_sf);
 8001dcc:	68fb      	ldr	r3, [r7, #12]
 8001dce:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 8001dd2:	ee07 3a90 	vmov	s15, r3
} // end of HAL_getVoltageScaleFactor() function
 8001dd6:	eeb0 0a67 	vmov.f32	s0, s15
 8001dda:	3714      	adds	r7, #20
 8001ddc:	46bd      	mov	sp, r7
 8001dde:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001de2:	4770      	bx	lr

08001de4 <HAL_readAdcData>:
//!             structure gAdcData holds three phase voltages, three line
//!             currents, and one DC bus voltage.
//! \param[in]  handle    The hardware abstraction layer (HAL) handle
//! \param[in]  pAdcData  A pointer to the ADC data buffer
static inline void HAL_readAdcData(HAL_Handle handle,HAL_AdcData_t *pAdcData)
{
 8001de4:	b580      	push	{r7, lr}
 8001de6:	b086      	sub	sp, #24
 8001de8:	af00      	add	r7, sp, #0
 8001dea:	6078      	str	r0, [r7, #4]
 8001dec:	6039      	str	r1, [r7, #0]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8001dee:	687b      	ldr	r3, [r7, #4]
 8001df0:	617b      	str	r3, [r7, #20]

  float_t value;
  float_t current_sf = HAL_getCurrentScaleFactor(handle);
 8001df2:	6878      	ldr	r0, [r7, #4]
 8001df4:	f7ff ffd2 	bl	8001d9c <HAL_getCurrentScaleFactor>
 8001df8:	ed87 0a04 	vstr	s0, [r7, #16]
  float_t voltage_sf = HAL_getVoltageScaleFactor(handle);
 8001dfc:	6878      	ldr	r0, [r7, #4]
 8001dfe:	f7ff ffdf 	bl	8001dc0 <HAL_getVoltageScaleFactor>
 8001e02:	ed87 0a03 	vstr	s0, [r7, #12]
	//! \Mod By Dl.K

  // convert current A
  // sample the first sample twice due to errata sprz342f, ignore the first sample
	value = pAdcData->I.value[0] * AD_CONV_RATIO;
 8001e06:	683b      	ldr	r3, [r7, #0]
 8001e08:	edd3 7a00 	vldr	s15, [r3]
 8001e0c:	ed9f 7a63 	vldr	s14, [pc, #396]	; 8001f9c <HAL_readAdcData+0x1b8>
 8001e10:	ee67 7a87 	vmul.f32	s15, s15, s14
 8001e14:	edc7 7a02 	vstr	s15, [r7, #8]
  value = (value*current_sf) - obj->adcBias.I.value[0];      // divide by 2^numAdcBits = 2^12
 8001e18:	ed97 7a02 	vldr	s14, [r7, #8]
 8001e1c:	edd7 7a04 	vldr	s15, [r7, #16]
 8001e20:	ee27 7a27 	vmul.f32	s14, s14, s15
 8001e24:	697b      	ldr	r3, [r7, #20]
 8001e26:	edd3 7a36 	vldr	s15, [r3, #216]	; 0xd8
 8001e2a:	ee77 7a67 	vsub.f32	s15, s14, s15
 8001e2e:	edc7 7a02 	vstr	s15, [r7, #8]
  pAdcData->I.value[0] = value;//! \Mod By Dl.K Del'-'
 8001e32:	683b      	ldr	r3, [r7, #0]
 8001e34:	68ba      	ldr	r2, [r7, #8]
 8001e36:	601a      	str	r2, [r3, #0]

  // convert current B
	value = pAdcData->I.value[1] * AD_CONV_RATIO;
 8001e38:	683b      	ldr	r3, [r7, #0]
 8001e3a:	edd3 7a01 	vldr	s15, [r3, #4]
 8001e3e:	ed9f 7a57 	vldr	s14, [pc, #348]	; 8001f9c <HAL_readAdcData+0x1b8>
 8001e42:	ee67 7a87 	vmul.f32	s15, s15, s14
 8001e46:	edc7 7a02 	vstr	s15, [r7, #8]
  value = (value*current_sf) - obj->adcBias.I.value[1];      // divide by 2^numAdcBits = 2^12
 8001e4a:	ed97 7a02 	vldr	s14, [r7, #8]
 8001e4e:	edd7 7a04 	vldr	s15, [r7, #16]
 8001e52:	ee27 7a27 	vmul.f32	s14, s14, s15
 8001e56:	697b      	ldr	r3, [r7, #20]
 8001e58:	edd3 7a37 	vldr	s15, [r3, #220]	; 0xdc
 8001e5c:	ee77 7a67 	vsub.f32	s15, s14, s15
 8001e60:	edc7 7a02 	vstr	s15, [r7, #8]
  pAdcData->I.value[1] = value;//! \Mod By Dl.K Del'-'
 8001e64:	683b      	ldr	r3, [r7, #0]
 8001e66:	68ba      	ldr	r2, [r7, #8]
 8001e68:	605a      	str	r2, [r3, #4]

  // convert current C
	value = pAdcData->I.value[2] * AD_CONV_RATIO;
 8001e6a:	683b      	ldr	r3, [r7, #0]
 8001e6c:	edd3 7a02 	vldr	s15, [r3, #8]
 8001e70:	ed9f 7a4a 	vldr	s14, [pc, #296]	; 8001f9c <HAL_readAdcData+0x1b8>
 8001e74:	ee67 7a87 	vmul.f32	s15, s15, s14
 8001e78:	edc7 7a02 	vstr	s15, [r7, #8]
  value = (value*current_sf) - obj->adcBias.I.value[2];      // divide by 2^numAdcBits = 2^12
 8001e7c:	ed97 7a02 	vldr	s14, [r7, #8]
 8001e80:	edd7 7a04 	vldr	s15, [r7, #16]
 8001e84:	ee27 7a27 	vmul.f32	s14, s14, s15
 8001e88:	697b      	ldr	r3, [r7, #20]
 8001e8a:	edd3 7a38 	vldr	s15, [r3, #224]	; 0xe0
 8001e8e:	ee77 7a67 	vsub.f32	s15, s14, s15
 8001e92:	edc7 7a02 	vstr	s15, [r7, #8]
  pAdcData->I.value[2] = value;//! \Mod By Dl.K Del'-'
 8001e96:	683b      	ldr	r3, [r7, #0]
 8001e98:	68ba      	ldr	r2, [r7, #8]
 8001e9a:	609a      	str	r2, [r3, #8]

  // convert voltage A
	value = pAdcData->V.value[0] * AD_CONV_RATIO;
 8001e9c:	683b      	ldr	r3, [r7, #0]
 8001e9e:	edd3 7a03 	vldr	s15, [r3, #12]
 8001ea2:	ed9f 7a3e 	vldr	s14, [pc, #248]	; 8001f9c <HAL_readAdcData+0x1b8>
 8001ea6:	ee67 7a87 	vmul.f32	s15, s15, s14
 8001eaa:	edc7 7a02 	vstr	s15, [r7, #8]
  value = (value*voltage_sf) - obj->adcBias.V.value[0];      // divide by 2^numAdcBits = 2^12
 8001eae:	ed97 7a02 	vldr	s14, [r7, #8]
 8001eb2:	edd7 7a03 	vldr	s15, [r7, #12]
 8001eb6:	ee27 7a27 	vmul.f32	s14, s14, s15
 8001eba:	697b      	ldr	r3, [r7, #20]
 8001ebc:	edd3 7a39 	vldr	s15, [r3, #228]	; 0xe4
 8001ec0:	ee77 7a67 	vsub.f32	s15, s14, s15
 8001ec4:	edc7 7a02 	vstr	s15, [r7, #8]
  pAdcData->V.value[0] = value;
 8001ec8:	683b      	ldr	r3, [r7, #0]
 8001eca:	68ba      	ldr	r2, [r7, #8]
 8001ecc:	60da      	str	r2, [r3, #12]

  // convert voltage B
	value = pAdcData->V.value[1] * AD_CONV_RATIO;
 8001ece:	683b      	ldr	r3, [r7, #0]
 8001ed0:	edd3 7a04 	vldr	s15, [r3, #16]
 8001ed4:	ed9f 7a31 	vldr	s14, [pc, #196]	; 8001f9c <HAL_readAdcData+0x1b8>
 8001ed8:	ee67 7a87 	vmul.f32	s15, s15, s14
 8001edc:	edc7 7a02 	vstr	s15, [r7, #8]
  value = (value*voltage_sf) - obj->adcBias.V.value[1];      // divide by 2^numAdcBits = 2^12
 8001ee0:	ed97 7a02 	vldr	s14, [r7, #8]
 8001ee4:	edd7 7a03 	vldr	s15, [r7, #12]
 8001ee8:	ee27 7a27 	vmul.f32	s14, s14, s15
 8001eec:	697b      	ldr	r3, [r7, #20]
 8001eee:	edd3 7a3a 	vldr	s15, [r3, #232]	; 0xe8
 8001ef2:	ee77 7a67 	vsub.f32	s15, s14, s15
 8001ef6:	edc7 7a02 	vstr	s15, [r7, #8]
  pAdcData->V.value[1] = value;
 8001efa:	683b      	ldr	r3, [r7, #0]
 8001efc:	68ba      	ldr	r2, [r7, #8]
 8001efe:	611a      	str	r2, [r3, #16]

  // convert voltage C
	value = pAdcData->I.value[2] * AD_CONV_RATIO;
 8001f00:	683b      	ldr	r3, [r7, #0]
 8001f02:	edd3 7a02 	vldr	s15, [r3, #8]
 8001f06:	ed9f 7a25 	vldr	s14, [pc, #148]	; 8001f9c <HAL_readAdcData+0x1b8>
 8001f0a:	ee67 7a87 	vmul.f32	s15, s15, s14
 8001f0e:	edc7 7a02 	vstr	s15, [r7, #8]
  value = (value*voltage_sf) - obj->adcBias.V.value[2];      // divide by 2^numAdcBits = 2^12
 8001f12:	ed97 7a02 	vldr	s14, [r7, #8]
 8001f16:	edd7 7a03 	vldr	s15, [r7, #12]
 8001f1a:	ee27 7a27 	vmul.f32	s14, s14, s15
 8001f1e:	697b      	ldr	r3, [r7, #20]
 8001f20:	edd3 7a3b 	vldr	s15, [r3, #236]	; 0xec
 8001f24:	ee77 7a67 	vsub.f32	s15, s14, s15
 8001f28:	edc7 7a02 	vstr	s15, [r7, #8]
  pAdcData->V.value[2] = value;
 8001f2c:	683b      	ldr	r3, [r7, #0]
 8001f2e:	68ba      	ldr	r2, [r7, #8]
 8001f30:	615a      	str	r2, [r3, #20]

  // read the dcBus voltage value //! \Mod By Dl.K
	value = pAdcData->VdcBus * AD_CONV_RATIO;
 8001f32:	683b      	ldr	r3, [r7, #0]
 8001f34:	edd3 7a06 	vldr	s15, [r3, #24]
 8001f38:	ed9f 7a18 	vldr	s14, [pc, #96]	; 8001f9c <HAL_readAdcData+0x1b8>
 8001f3c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8001f40:	edc7 7a02 	vstr	s15, [r7, #8]
  value = (value*voltage_sf) - (V_DC_offset)*USER_VOLTAGE_SF;
 8001f44:	ed97 7a02 	vldr	s14, [r7, #8]
 8001f48:	edd7 7a03 	vldr	s15, [r7, #12]
 8001f4c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8001f50:	ed9f 7a13 	vldr	s14, [pc, #76]	; 8001fa0 <HAL_readAdcData+0x1bc>
 8001f54:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8001f58:	edc7 7a02 	vstr	s15, [r7, #8]
  pAdcData->VdcBus = value;
 8001f5c:	683b      	ldr	r3, [r7, #0]
 8001f5e:	68ba      	ldr	r2, [r7, #8]
 8001f60:	619a      	str	r2, [r3, #24]

  // read the dcBus current value //! \Mod By Dl.K
	value = pAdcData->IdcBus * AD_CONV_RATIO;
 8001f62:	683b      	ldr	r3, [r7, #0]
 8001f64:	edd3 7a07 	vldr	s15, [r3, #28]
 8001f68:	ed9f 7a0c 	vldr	s14, [pc, #48]	; 8001f9c <HAL_readAdcData+0x1b8>
 8001f6c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8001f70:	edc7 7a02 	vstr	s15, [r7, #8]
  value = (value*current_sf) - (I_DC_offset)*USER_CURRENT_SF;
 8001f74:	ed97 7a02 	vldr	s14, [r7, #8]
 8001f78:	edd7 7a04 	vldr	s15, [r7, #16]
 8001f7c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8001f80:	ed9f 7a08 	vldr	s14, [pc, #32]	; 8001fa4 <HAL_readAdcData+0x1c0>
 8001f84:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8001f88:	edc7 7a02 	vstr	s15, [r7, #8]
  pAdcData->IdcBus = value;
 8001f8c:	683b      	ldr	r3, [r7, #0]
 8001f8e:	68ba      	ldr	r2, [r7, #8]
 8001f90:	61da      	str	r2, [r3, #28]

  return;
 8001f92:	bf00      	nop
} // end of HAL_readAdcData() function
 8001f94:	3718      	adds	r7, #24
 8001f96:	46bd      	mov	sp, r7
 8001f98:	bd80      	pop	{r7, pc}
 8001f9a:	bf00      	nop
 8001f9c:	39800000 	.word	0x39800000
 8001fa0:	3f05f57f 	.word	0x3f05f57f
 8001fa4:	3f47fff2 	.word	0x3f47fff2

08001fa8 <HAL_writePwmData>:

//! \brief     Writes PWM data to the PWM comparators for motor control
//! \param[in] handle    The hardware abstraction layer (HAL) handle
//! \param[in] pPwmData  The pointer to the PWM data
static inline void HAL_writePwmData(HAL_Handle handle,HAL_PwmData_t *pPwmData)
{
 8001fa8:	b580      	push	{r7, lr}
 8001faa:	b086      	sub	sp, #24
 8001fac:	af00      	add	r7, sp, #0
 8001fae:	6078      	str	r0, [r7, #4]
 8001fb0:	6039      	str	r1, [r7, #0]
  uint_least8_t cnt;
  float_t pwmData_neg;
  float_t pwmData_sat;
  float_t pwmData_sat_dc;

  for(cnt=0;cnt<3;cnt++)
 8001fb2:	2300      	movs	r3, #0
 8001fb4:	75fb      	strb	r3, [r7, #23]
 8001fb6:	e024      	b.n	8002002 <HAL_writePwmData+0x5a>
    {
      pwmData_neg = (pPwmData->Tabc.value[cnt]*(1.0f));//! \Attention : Dl.K
 8001fb8:	7dfb      	ldrb	r3, [r7, #23]
 8001fba:	683a      	ldr	r2, [r7, #0]
 8001fbc:	009b      	lsls	r3, r3, #2
 8001fbe:	4413      	add	r3, r2
 8001fc0:	681b      	ldr	r3, [r3, #0]
 8001fc2:	613b      	str	r3, [r7, #16]
      pwmData_sat = MATH_sat(pwmData_neg,(1.0f),(-1.0f));
 8001fc4:	ed97 0a04 	vldr	s0, [r7, #16]
 8001fc8:	eef7 0a00 	vmov.f32	s1, #112	; 0x70
 8001fcc:	eebf 1a00 	vmov.f32	s2, #240	; 0xf0
 8001fd0:	f7ff fe92 	bl	8001cf8 <MATH_sat>
 8001fd4:	ed87 0a03 	vstr	s0, [r7, #12]
      pwmData_sat_dc = ( (pwmData_sat + (1.0f)) * (0.5f) );
 8001fd8:	edd7 7a03 	vldr	s15, [r7, #12]
 8001fdc:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8001fe0:	ee77 7a87 	vadd.f32	s15, s15, s14
 8001fe4:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 8001fe8:	ee67 7a87 	vmul.f32	s15, s15, s14
 8001fec:	edc7 7a02 	vstr	s15, [r7, #8]
			pPwmData->Tabc.value[cnt] = pwmData_sat_dc;
 8001ff0:	7dfb      	ldrb	r3, [r7, #23]
 8001ff2:	683a      	ldr	r2, [r7, #0]
 8001ff4:	009b      	lsls	r3, r3, #2
 8001ff6:	4413      	add	r3, r2
 8001ff8:	68ba      	ldr	r2, [r7, #8]
 8001ffa:	601a      	str	r2, [r3, #0]
  uint_least8_t cnt;
  float_t pwmData_neg;
  float_t pwmData_sat;
  float_t pwmData_sat_dc;

  for(cnt=0;cnt<3;cnt++)
 8001ffc:	7dfb      	ldrb	r3, [r7, #23]
 8001ffe:	3301      	adds	r3, #1
 8002000:	75fb      	strb	r3, [r7, #23]
 8002002:	7dfb      	ldrb	r3, [r7, #23]
 8002004:	2b02      	cmp	r3, #2
 8002006:	d9d7      	bls.n	8001fb8 <HAL_writePwmData+0x10>
      pwmData_sat = MATH_sat(pwmData_neg,(1.0f),(-1.0f));
      pwmData_sat_dc = ( (pwmData_sat + (1.0f)) * (0.5f) );
			pPwmData->Tabc.value[cnt] = pwmData_sat_dc;
    }

  return;
 8002008:	bf00      	nop
} // end of HAL_writePwmData() function
 800200a:	3718      	adds	r7, #24
 800200c:	46bd      	mov	sp, r7
 800200e:	bd80      	pop	{r7, pc}

08002010 <Motor_Ctrl_Init>:
CTRL_Obj gCtrl;
CTRL_Handle gCtrlHandle;


void Motor_Ctrl_Init(void)
{
 8002010:	b580      	push	{r7, lr}
 8002012:	af00      	add	r7, sp, #0
	gHalHandle = HAL_init(&gHal, sizeof(gHal));
 8002014:	480f      	ldr	r0, [pc, #60]	; (8002054 <Motor_Ctrl_Init+0x44>)
 8002016:	f44f 7182 	mov.w	r1, #260	; 0x104
 800201a:	f003 fcc7 	bl	80059ac <HAL_init>
 800201e:	4602      	mov	r2, r0
 8002020:	4b0d      	ldr	r3, [pc, #52]	; (8002058 <Motor_Ctrl_Init+0x48>)
 8002022:	601a      	str	r2, [r3, #0]
	
	gCtrlHandle = CTRL_init(&gCtrl, sizeof(gCtrl));
 8002024:	480d      	ldr	r0, [pc, #52]	; (800205c <Motor_Ctrl_Init+0x4c>)
 8002026:	f44f 714b 	mov.w	r1, #812	; 0x32c
 800202a:	f002 fb23 	bl	8004674 <CTRL_init>
 800202e:	4602      	mov	r2, r0
 8002030:	4b0b      	ldr	r3, [pc, #44]	; (8002060 <Motor_Ctrl_Init+0x50>)
 8002032:	601a      	str	r2, [r3, #0]
	
	USER_setParams(&gUserParams);
 8002034:	480b      	ldr	r0, [pc, #44]	; (8002064 <Motor_Ctrl_Init+0x54>)
 8002036:	f003 ff4b 	bl	8005ed0 <USER_setParams>
	
	HAL_setParams(gHalHandle, &gUserParams);
 800203a:	4b07      	ldr	r3, [pc, #28]	; (8002058 <Motor_Ctrl_Init+0x48>)
 800203c:	681b      	ldr	r3, [r3, #0]
 800203e:	4618      	mov	r0, r3
 8002040:	4908      	ldr	r1, [pc, #32]	; (8002064 <Motor_Ctrl_Init+0x54>)
 8002042:	f003 fcf9 	bl	8005a38 <HAL_setParams>
	
	CTRL_setParams(gCtrlHandle, &gUserParams);
 8002046:	4b06      	ldr	r3, [pc, #24]	; (8002060 <Motor_Ctrl_Init+0x50>)
 8002048:	681b      	ldr	r3, [r3, #0]
 800204a:	4618      	mov	r0, r3
 800204c:	4905      	ldr	r1, [pc, #20]	; (8002064 <Motor_Ctrl_Init+0x54>)
 800204e:	f002 fbc5 	bl	80047dc <CTRL_setParams>
	
}
 8002052:	bd80      	pop	{r7, pc}
 8002054:	2001252c 	.word	0x2001252c
 8002058:	200121fc 	.word	0x200121fc
 800205c:	20012200 	.word	0x20012200
 8002060:	20012630 	.word	0x20012630
 8002064:	20012634 	.word	0x20012634

08002068 <Motor_Ctrl_Run>:
			return true;
		}
}

void Motor_Ctrl_Run(HAL_AdcData_t *pAdcData, HAL_PwmData_t *pPwmData, HAL_QepData_t *pQepData)
{
 8002068:	b580      	push	{r7, lr}
 800206a:	b086      	sub	sp, #24
 800206c:	af02      	add	r7, sp, #8
 800206e:	60f8      	str	r0, [r7, #12]
 8002070:	60b9      	str	r1, [r7, #8]
 8002072:	607a      	str	r2, [r7, #4]
	static uint_least16_t count_sci=50,numSciTick=50;

  // convert the ADC data
  HAL_readAdcData(gHalHandle,pAdcData);
 8002074:	4b29      	ldr	r3, [pc, #164]	; (800211c <Motor_Ctrl_Run+0xb4>)
 8002076:	681b      	ldr	r3, [r3, #0]
 8002078:	4618      	mov	r0, r3
 800207a:	68f9      	ldr	r1, [r7, #12]
 800207c:	f7ff feb2 	bl	8001de4 <HAL_readAdcData>

  // run the controller
  
#if 1
  CTRL_run(gCtrlHandle,gHalHandle,pAdcData,pPwmData,pQepData);
 8002080:	4b27      	ldr	r3, [pc, #156]	; (8002120 <Motor_Ctrl_Run+0xb8>)
 8002082:	6819      	ldr	r1, [r3, #0]
 8002084:	4b25      	ldr	r3, [pc, #148]	; (800211c <Motor_Ctrl_Run+0xb4>)
 8002086:	681a      	ldr	r2, [r3, #0]
 8002088:	687b      	ldr	r3, [r7, #4]
 800208a:	9300      	str	r3, [sp, #0]
 800208c:	4608      	mov	r0, r1
 800208e:	4611      	mov	r1, r2
 8002090:	68fa      	ldr	r2, [r7, #12]
 8002092:	68bb      	ldr	r3, [r7, #8]
 8002094:	f002 fa2e 	bl	80044f4 <CTRL_run>
//	pPwmData->Tabc.value[0] = -0.1f;
//	pPwmData->Tabc.value[1] = -0.0f;
//	pPwmData->Tabc.value[2] = 0.1f;
  // write the PWM compare values
  
  HAL_writePwmData(gHalHandle,pPwmData);
 8002098:	4b20      	ldr	r3, [pc, #128]	; (800211c <Motor_Ctrl_Run+0xb4>)
 800209a:	681b      	ldr	r3, [r3, #0]
 800209c:	4618      	mov	r0, r3
 800209e:	68b9      	ldr	r1, [r7, #8]
 80020a0:	f7ff ff82 	bl	8001fa8 <HAL_writePwmData>

//  // setup the controller
//  CTRL_setup(gCtrlHandle);
#if 1
	if(count_sci>=numSciTick)
 80020a4:	4b1f      	ldr	r3, [pc, #124]	; (8002124 <Motor_Ctrl_Run+0xbc>)
 80020a6:	881a      	ldrh	r2, [r3, #0]
 80020a8:	4b1f      	ldr	r3, [pc, #124]	; (8002128 <Motor_Ctrl_Run+0xc0>)
 80020aa:	881b      	ldrh	r3, [r3, #0]
 80020ac:	429a      	cmp	r2, r3
 80020ae:	d32c      	bcc.n	800210a <Motor_Ctrl_Run+0xa2>
	{
		count_sci = 1;
 80020b0:	4b1c      	ldr	r3, [pc, #112]	; (8002124 <Motor_Ctrl_Run+0xbc>)
 80020b2:	2201      	movs	r2, #1
 80020b4:	801a      	strh	r2, [r3, #0]
		DATA_RTXD_Decode(gCtrlHandle,gHalHandle);
 80020b6:	4b1a      	ldr	r3, [pc, #104]	; (8002120 <Motor_Ctrl_Run+0xb8>)
 80020b8:	681a      	ldr	r2, [r3, #0]
 80020ba:	4b18      	ldr	r3, [pc, #96]	; (800211c <Motor_Ctrl_Run+0xb4>)
 80020bc:	681b      	ldr	r3, [r3, #0]
 80020be:	4610      	mov	r0, r2
 80020c0:	4619      	mov	r1, r3
 80020c2:	f003 fa07 	bl	80054d4 <DATA_RTXD_Decode>
		DATA_RTXD_Run(gCtrlHandle,gHalHandle,pAdcData,pQepData);
 80020c6:	4b16      	ldr	r3, [pc, #88]	; (8002120 <Motor_Ctrl_Run+0xb8>)
 80020c8:	681a      	ldr	r2, [r3, #0]
 80020ca:	4b14      	ldr	r3, [pc, #80]	; (800211c <Motor_Ctrl_Run+0xb4>)
 80020cc:	681b      	ldr	r3, [r3, #0]
 80020ce:	4610      	mov	r0, r2
 80020d0:	4619      	mov	r1, r3
 80020d2:	68fa      	ldr	r2, [r7, #12]
 80020d4:	687b      	ldr	r3, [r7, #4]
 80020d6:	f003 f979 	bl	80053cc <DATA_RTXD_Run>
		while( DATA_TXD_Status(gCtrlHandle->data_rtxd_handle))
 80020da:	e00b      	b.n	80020f4 <Motor_Ctrl_Run+0x8c>
		{
			//rt_kprintf("%c",DATA_TXD_Run(handle->data_rtxd_handle));
			myprintf((char*)Get_DATA_TXD_Ptr(gCtrlHandle->data_rtxd_handle), 13);
 80020dc:	4b10      	ldr	r3, [pc, #64]	; (8002120 <Motor_Ctrl_Run+0xb8>)
 80020de:	681b      	ldr	r3, [r3, #0]
 80020e0:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
 80020e4:	4618      	mov	r0, r3
 80020e6:	f7ff fe47 	bl	8001d78 <Get_DATA_TXD_Ptr>
 80020ea:	4603      	mov	r3, r0
 80020ec:	4618      	mov	r0, r3
 80020ee:	210d      	movs	r1, #13
 80020f0:	f012 ff28 	bl	8014f44 <myprintf>
	if(count_sci>=numSciTick)
	{
		count_sci = 1;
		DATA_RTXD_Decode(gCtrlHandle,gHalHandle);
		DATA_RTXD_Run(gCtrlHandle,gHalHandle,pAdcData,pQepData);
		while( DATA_TXD_Status(gCtrlHandle->data_rtxd_handle))
 80020f4:	4b0a      	ldr	r3, [pc, #40]	; (8002120 <Motor_Ctrl_Run+0xb8>)
 80020f6:	681b      	ldr	r3, [r3, #0]
 80020f8:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
 80020fc:	4618      	mov	r0, r3
 80020fe:	f7ff fe27 	bl	8001d50 <DATA_TXD_Status>
 8002102:	4603      	mov	r3, r0
 8002104:	2b00      	cmp	r3, #0
 8002106:	d1e9      	bne.n	80020dc <Motor_Ctrl_Run+0x74>
 8002108:	e005      	b.n	8002116 <Motor_Ctrl_Run+0xae>
		{
			//rt_kprintf("%c",DATA_TXD_Run(handle->data_rtxd_handle));
			myprintf((char*)Get_DATA_TXD_Ptr(gCtrlHandle->data_rtxd_handle), 13);
		}		
	}
	else count_sci++;//! \Mod By Dl.K
 800210a:	4b06      	ldr	r3, [pc, #24]	; (8002124 <Motor_Ctrl_Run+0xbc>)
 800210c:	881b      	ldrh	r3, [r3, #0]
 800210e:	3301      	adds	r3, #1
 8002110:	b29a      	uxth	r2, r3
 8002112:	4b04      	ldr	r3, [pc, #16]	; (8002124 <Motor_Ctrl_Run+0xbc>)
 8002114:	801a      	strh	r2, [r3, #0]
	#endif
}
 8002116:	3710      	adds	r7, #16
 8002118:	46bd      	mov	sp, r7
 800211a:	bd80      	pop	{r7, pc}
 800211c:	200121fc 	.word	0x200121fc
 8002120:	20012630 	.word	0x20012630
 8002124:	20010000 	.word	0x20010000
 8002128:	20010002 	.word	0x20010002

0800212c <MATH_abs>:

//! \brief     Finds the absolute value 
//! \param[in] in   The input value
//! \return    The absolute value
static inline float_t MATH_abs(const float_t in)
{
 800212c:	b480      	push	{r7}
 800212e:	b085      	sub	sp, #20
 8002130:	af00      	add	r7, sp, #0
 8002132:	ed87 0a01 	vstr	s0, [r7, #4]
  float_t out = in;
 8002136:	687b      	ldr	r3, [r7, #4]
 8002138:	60fb      	str	r3, [r7, #12]


  if(in < 0.0f)
 800213a:	edd7 7a01 	vldr	s15, [r7, #4]
 800213e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8002142:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002146:	d505      	bpl.n	8002154 <MATH_abs+0x28>
    {
      out = -in;
 8002148:	edd7 7a01 	vldr	s15, [r7, #4]
 800214c:	eef1 7a67 	vneg.f32	s15, s15
 8002150:	edc7 7a03 	vstr	s15, [r7, #12]
    }

  return(out);
 8002154:	68fb      	ldr	r3, [r7, #12]
 8002156:	ee07 3a90 	vmov	s15, r3
} // end of MATH_abs() function
 800215a:	eeb0 0a67 	vmov.f32	s0, s15
 800215e:	3714      	adds	r7, #20
 8002160:	46bd      	mov	sp, r7
 8002162:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002166:	4770      	bx	lr

08002168 <Speed_UpdateElecTheta>:

	return;
}

static inline void Speed_UpdateElecTheta(SPEED_Handle handle)//! \Mod By Dl.K
{
 8002168:	b480      	push	{r7}
 800216a:	b085      	sub	sp, #20
 800216c:	af00      	add	r7, sp, #0
 800216e:	6078      	str	r0, [r7, #4]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
 8002170:	687b      	ldr	r3, [r7, #4]
 8002172:	60fb      	str	r3, [r7, #12]

	obj->OldElecTheta = obj->ElecTheta;
 8002174:	68fb      	ldr	r3, [r7, #12]
 8002176:	681a      	ldr	r2, [r3, #0]
 8002178:	68fb      	ldr	r3, [r7, #12]
 800217a:	605a      	str	r2, [r3, #4]

	return;
 800217c:	bf00      	nop
}
 800217e:	3714      	adds	r7, #20
 8002180:	46bd      	mov	sp, r7
 8002182:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002186:	4770      	bx	lr

08002188 <Speed_UpdateElecSpeed>:

static inline void Speed_UpdateElecSpeed(SPEED_Handle handle)//! \Mod By Dl.K
{
 8002188:	b480      	push	{r7}
 800218a:	b085      	sub	sp, #20
 800218c:	af00      	add	r7, sp, #0
 800218e:	6078      	str	r0, [r7, #4]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
 8002190:	687b      	ldr	r3, [r7, #4]
 8002192:	60fb      	str	r3, [r7, #12]

	obj->OldElecSpeed = obj->ElecSpeed;
 8002194:	68fb      	ldr	r3, [r7, #12]
 8002196:	68da      	ldr	r2, [r3, #12]
 8002198:	68fb      	ldr	r3, [r7, #12]
 800219a:	611a      	str	r2, [r3, #16]

	return;
 800219c:	bf00      	nop
}
 800219e:	3714      	adds	r7, #20
 80021a0:	46bd      	mov	sp, r7
 80021a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80021a6:	4770      	bx	lr

080021a8 <Speed_Init>:
-------------------------------------------------------------------------------------*/

#include "modules/Speed/Speed.h"

SPEED_Handle Speed_Init(void *pMemory, const size_t numBytes)//! \Mod By Dl.K
{
 80021a8:	b480      	push	{r7}
 80021aa:	b085      	sub	sp, #20
 80021ac:	af00      	add	r7, sp, #0
 80021ae:	6078      	str	r0, [r7, #4]
 80021b0:	6039      	str	r1, [r7, #0]
	SPEED_Handle handle;

	if (numBytes < sizeof(SPEED_Obj))
 80021b2:	683b      	ldr	r3, [r7, #0]
 80021b4:	2b1b      	cmp	r3, #27
 80021b6:	d801      	bhi.n	80021bc <Speed_Init+0x14>
		return((SPEED_Handle)NULL);
 80021b8:	2300      	movs	r3, #0
 80021ba:	e01e      	b.n	80021fa <Speed_Init+0x52>

	// assign the handle
	handle = (SPEED_Handle)pMemory;
 80021bc:	687b      	ldr	r3, [r7, #4]
 80021be:	60fb      	str	r3, [r7, #12]

	handle->ElecTheta = (0.0f);
 80021c0:	68fb      	ldr	r3, [r7, #12]
 80021c2:	f04f 0200 	mov.w	r2, #0
 80021c6:	601a      	str	r2, [r3, #0]
	handle->OldElecTheta = (0.0f);
 80021c8:	68fb      	ldr	r3, [r7, #12]
 80021ca:	f04f 0200 	mov.w	r2, #0
 80021ce:	605a      	str	r2, [r3, #4]
	handle->ElecThetaChagTimeRatio = (0.0f);// Real:1/(T) PU:1/(T)/SpeedBaseFreq
 80021d0:	68fb      	ldr	r3, [r7, #12]
 80021d2:	f04f 0200 	mov.w	r2, #0
 80021d6:	609a      	str	r2, [r3, #8]
	handle->ElecSpeed = (0.0f);
 80021d8:	68fb      	ldr	r3, [r7, #12]
 80021da:	f04f 0200 	mov.w	r2, #0
 80021de:	60da      	str	r2, [r3, #12]
	handle->OldElecSpeed = (0.0f);
 80021e0:	68fb      	ldr	r3, [r7, #12]
 80021e2:	f04f 0200 	mov.w	r2, #0
 80021e6:	611a      	str	r2, [r3, #16]
	handle->ElecFilterSpeed = (0.0f);
 80021e8:	68fb      	ldr	r3, [r7, #12]
 80021ea:	f04f 0200 	mov.w	r2, #0
 80021ee:	619a      	str	r2, [r3, #24]
	handle->ElecFilterSpeedRatio = (0.0f);// 1/(1+2*pi*Fc*Ts)
 80021f0:	68fb      	ldr	r3, [r7, #12]
 80021f2:	f04f 0200 	mov.w	r2, #0
 80021f6:	615a      	str	r2, [r3, #20]

	return(handle);
 80021f8:	68fb      	ldr	r3, [r7, #12]
}
 80021fa:	4618      	mov	r0, r3
 80021fc:	3714      	adds	r7, #20
 80021fe:	46bd      	mov	sp, r7
 8002200:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002204:	4770      	bx	lr
 8002206:	bf00      	nop

08002208 <Speed_Run>:

void Speed_Run(SPEED_Handle handle)
{
 8002208:	b580      	push	{r7, lr}
 800220a:	b084      	sub	sp, #16
 800220c:	af00      	add	r7, sp, #0
 800220e:	6078      	str	r0, [r7, #4]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
 8002210:	687b      	ldr	r3, [r7, #4]
 8002212:	60fb      	str	r3, [r7, #12]

	Speed_UpdateElecSpeed( obj );
 8002214:	68f8      	ldr	r0, [r7, #12]
 8002216:	f7ff ffb7 	bl	8002188 <Speed_UpdateElecSpeed>
	// Need to Change the Time between Elec And OldElec According to Speed
	// 1kHz:1ms ElecSpeed:500Hz RealSpeed:125Hz@4poles, 2kHz:0.5ms ElecSpeed:500Hz RealSpeed:125Hz@4poles,
	if( MATH_abs(obj->ElecTheta - obj->OldElecTheta) > (0.5f) )
 800221a:	68fb      	ldr	r3, [r7, #12]
 800221c:	ed93 7a00 	vldr	s14, [r3]
 8002220:	68fb      	ldr	r3, [r7, #12]
 8002222:	edd3 7a01 	vldr	s15, [r3, #4]
 8002226:	ee77 7a67 	vsub.f32	s15, s14, s15
 800222a:	eeb0 0a67 	vmov.f32	s0, s15
 800222e:	f7ff ff7d 	bl	800212c <MATH_abs>
 8002232:	eeb0 7a40 	vmov.f32	s14, s0
 8002236:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 800223a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800223e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002242:	dd50      	ble.n	80022e6 <Speed_Run+0xde>
	{
		if( (obj->ElecTheta + (1.0f)- obj->OldElecTheta)<(0.5f) )
 8002244:	68fb      	ldr	r3, [r7, #12]
 8002246:	edd3 7a00 	vldr	s15, [r3]
 800224a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 800224e:	ee37 7a87 	vadd.f32	s14, s15, s14
 8002252:	68fb      	ldr	r3, [r7, #12]
 8002254:	edd3 7a01 	vldr	s15, [r3, #4]
 8002258:	ee77 7a67 	vsub.f32	s15, s14, s15
 800225c:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 8002260:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002264:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002268:	d514      	bpl.n	8002294 <Speed_Run+0x8c>
		{
			obj->ElecSpeed = ( obj->ElecThetaChagTimeRatio * (obj->ElecTheta +(1.0f)- obj->OldElecTheta) );
 800226a:	68fb      	ldr	r3, [r7, #12]
 800226c:	ed93 7a02 	vldr	s14, [r3, #8]
 8002270:	68fb      	ldr	r3, [r7, #12]
 8002272:	edd3 7a00 	vldr	s15, [r3]
 8002276:	eef7 6a00 	vmov.f32	s13, #112	; 0x70
 800227a:	ee77 6aa6 	vadd.f32	s13, s15, s13
 800227e:	68fb      	ldr	r3, [r7, #12]
 8002280:	edd3 7a01 	vldr	s15, [r3, #4]
 8002284:	ee76 7ae7 	vsub.f32	s15, s13, s15
 8002288:	ee67 7a27 	vmul.f32	s15, s14, s15
 800228c:	68fb      	ldr	r3, [r7, #12]
 800228e:	edc3 7a03 	vstr	s15, [r3, #12]
 8002292:	e038      	b.n	8002306 <Speed_Run+0xfe>
		}
		else if( (obj->ElecTheta - (1.0f) - obj->OldElecTheta)>(-0.5f) )
 8002294:	68fb      	ldr	r3, [r7, #12]
 8002296:	edd3 7a00 	vldr	s15, [r3]
 800229a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 800229e:	ee37 7ac7 	vsub.f32	s14, s15, s14
 80022a2:	68fb      	ldr	r3, [r7, #12]
 80022a4:	edd3 7a01 	vldr	s15, [r3, #4]
 80022a8:	ee77 7a67 	vsub.f32	s15, s14, s15
 80022ac:	eebe 7a00 	vmov.f32	s14, #224	; 0xe0
 80022b0:	eef4 7ac7 	vcmpe.f32	s15, s14
 80022b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80022b8:	dc00      	bgt.n	80022bc <Speed_Run+0xb4>
 80022ba:	e024      	b.n	8002306 <Speed_Run+0xfe>
		{
			obj->ElecSpeed = ( obj->ElecThetaChagTimeRatio * (obj->ElecTheta -(1.0f)- obj->OldElecTheta) );
 80022bc:	68fb      	ldr	r3, [r7, #12]
 80022be:	ed93 7a02 	vldr	s14, [r3, #8]
 80022c2:	68fb      	ldr	r3, [r7, #12]
 80022c4:	edd3 7a00 	vldr	s15, [r3]
 80022c8:	eef7 6a00 	vmov.f32	s13, #112	; 0x70
 80022cc:	ee77 6ae6 	vsub.f32	s13, s15, s13
 80022d0:	68fb      	ldr	r3, [r7, #12]
 80022d2:	edd3 7a01 	vldr	s15, [r3, #4]
 80022d6:	ee76 7ae7 	vsub.f32	s15, s13, s15
 80022da:	ee67 7a27 	vmul.f32	s15, s14, s15
 80022de:	68fb      	ldr	r3, [r7, #12]
 80022e0:	edc3 7a03 	vstr	s15, [r3, #12]
 80022e4:	e00f      	b.n	8002306 <Speed_Run+0xfe>
		}
	}
	else
	{
		obj->ElecSpeed = ( obj->ElecThetaChagTimeRatio * (obj->ElecTheta - obj->OldElecTheta) );
 80022e6:	68fb      	ldr	r3, [r7, #12]
 80022e8:	ed93 7a02 	vldr	s14, [r3, #8]
 80022ec:	68fb      	ldr	r3, [r7, #12]
 80022ee:	edd3 6a00 	vldr	s13, [r3]
 80022f2:	68fb      	ldr	r3, [r7, #12]
 80022f4:	edd3 7a01 	vldr	s15, [r3, #4]
 80022f8:	ee76 7ae7 	vsub.f32	s15, s13, s15
 80022fc:	ee67 7a27 	vmul.f32	s15, s14, s15
 8002300:	68fb      	ldr	r3, [r7, #12]
 8002302:	edc3 7a03 	vstr	s15, [r3, #12]
	}
	obj->OldElecSpeed = obj->ElecFilterSpeed;
 8002306:	68fb      	ldr	r3, [r7, #12]
 8002308:	699a      	ldr	r2, [r3, #24]
 800230a:	68fb      	ldr	r3, [r7, #12]
 800230c:	611a      	str	r2, [r3, #16]
	obj->ElecFilterSpeed = obj->ElecSpeed;
 800230e:	68fb      	ldr	r3, [r7, #12]
 8002310:	68da      	ldr	r2, [r3, #12]
 8002312:	68fb      	ldr	r3, [r7, #12]
 8002314:	619a      	str	r2, [r3, #24]
	// Need to Change the Time between ElecSpeed And OldElecSpeed According to Acceleration
	// 1.0f@10ms:0.1f@1ms=>FreqRespose100HzORTimeRespose10ms:0~1.0f(800Hz) And the FilterFreq must 10x;
	if( MATH_abs(obj->ElecFilterSpeed - obj->OldElecSpeed) > (0.1f) )
 8002316:	68fb      	ldr	r3, [r7, #12]
 8002318:	ed93 7a06 	vldr	s14, [r3, #24]
 800231c:	68fb      	ldr	r3, [r7, #12]
 800231e:	edd3 7a04 	vldr	s15, [r3, #16]
 8002322:	ee77 7a67 	vsub.f32	s15, s14, s15
 8002326:	eeb0 0a67 	vmov.f32	s0, s15
 800232a:	f7ff feff 	bl	800212c <MATH_abs>
 800232e:	eeb0 7a40 	vmov.f32	s14, s0
 8002332:	eddf 7a09 	vldr	s15, [pc, #36]	; 8002358 <Speed_Run+0x150>
 8002336:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800233a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800233e:	dd03      	ble.n	8002348 <Speed_Run+0x140>
	{
		obj->ElecFilterSpeed = obj->OldElecSpeed;
 8002340:	68fb      	ldr	r3, [r7, #12]
 8002342:	691a      	ldr	r2, [r3, #16]
 8002344:	68fb      	ldr	r3, [r7, #12]
 8002346:	619a      	str	r2, [r3, #24]
	}
//	else
//	{
		Speed_UpdateElecTheta(obj);
 8002348:	68f8      	ldr	r0, [r7, #12]
 800234a:	f7ff ff0d 	bl	8002168 <Speed_UpdateElecTheta>

//	obj->ElecFilterSpeed = (obj->ElecSpeed * ((1.0f)-obj->ElecFilterSpeedRatio)) + (obj->ElecFilterSpeed * obj->ElecFilterSpeedRatio);

//	obj->ElecFilterSpeed = MATH_sat(obj->ElecFilterSpeed, (2.0f), (-2.0f));

	return;
 800234e:	bf00      	nop
}
 8002350:	3710      	adds	r7, #16
 8002352:	46bd      	mov	sp, r7
 8002354:	bd80      	pop	{r7, pc}
 8002356:	bf00      	nop
 8002358:	3dcccccd 	.word	0x3dcccccd

0800235c <CLARKE_init>:

// **************************************************************************
// the functions

CLARKE_Handle CLARKE_init(void *pMemory,const size_t numBytes)
{
 800235c:	b480      	push	{r7}
 800235e:	b085      	sub	sp, #20
 8002360:	af00      	add	r7, sp, #0
 8002362:	6078      	str	r0, [r7, #4]
 8002364:	6039      	str	r1, [r7, #0]
  CLARKE_Handle handle;

  if(numBytes < sizeof(CLARKE_Obj))
 8002366:	683b      	ldr	r3, [r7, #0]
 8002368:	2b0b      	cmp	r3, #11
 800236a:	d801      	bhi.n	8002370 <CLARKE_init+0x14>
    return((CLARKE_Handle)NULL);
 800236c:	2300      	movs	r3, #0
 800236e:	e002      	b.n	8002376 <CLARKE_init+0x1a>

  // assign the handle
  handle = (CLARKE_Handle)pMemory;
 8002370:	687b      	ldr	r3, [r7, #4]
 8002372:	60fb      	str	r3, [r7, #12]

  return(handle);
 8002374:	68fb      	ldr	r3, [r7, #12]
} // end of CLARKE_init() function
 8002376:	4618      	mov	r0, r3
 8002378:	3714      	adds	r7, #20
 800237a:	46bd      	mov	sp, r7
 800237c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002380:	4770      	bx	lr
 8002382:	bf00      	nop

08002384 <MATH_abs>:

//! \brief     Finds the absolute value 
//! \param[in] in   The input value
//! \return    The absolute value
static inline float_t MATH_abs(const float_t in)
{
 8002384:	b480      	push	{r7}
 8002386:	b085      	sub	sp, #20
 8002388:	af00      	add	r7, sp, #0
 800238a:	ed87 0a01 	vstr	s0, [r7, #4]
  float_t out = in;
 800238e:	687b      	ldr	r3, [r7, #4]
 8002390:	60fb      	str	r3, [r7, #12]


  if(in < 0.0f)
 8002392:	edd7 7a01 	vldr	s15, [r7, #4]
 8002396:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800239a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800239e:	d505      	bpl.n	80023ac <MATH_abs+0x28>
    {
      out = -in;
 80023a0:	edd7 7a01 	vldr	s15, [r7, #4]
 80023a4:	eef1 7a67 	vneg.f32	s15, s15
 80023a8:	edc7 7a03 	vstr	s15, [r7, #12]
    }

  return(out);
 80023ac:	68fb      	ldr	r3, [r7, #12]
 80023ae:	ee07 3a90 	vmov	s15, r3
} // end of MATH_abs() function
 80023b2:	eeb0 0a67 	vmov.f32	s0, s15
 80023b6:	3714      	adds	r7, #20
 80023b8:	46bd      	mov	sp, r7
 80023ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80023be:	4770      	bx	lr

080023c0 <MATH_sat>:
//! \param[in] in   The input value
//! \param[in] max  The maximum value allowed
//! \param[in] min  The minimum value allowed
//! \return    The saturated value
static inline float_t MATH_sat(const float_t in,const float_t max,const float_t min)
{
 80023c0:	b480      	push	{r7}
 80023c2:	b087      	sub	sp, #28
 80023c4:	af00      	add	r7, sp, #0
 80023c6:	ed87 0a03 	vstr	s0, [r7, #12]
 80023ca:	edc7 0a02 	vstr	s1, [r7, #8]
 80023ce:	ed87 1a01 	vstr	s2, [r7, #4]
  float_t out = in;
 80023d2:	68fb      	ldr	r3, [r7, #12]
 80023d4:	617b      	str	r3, [r7, #20]


  if(in < min)
 80023d6:	ed97 7a03 	vldr	s14, [r7, #12]
 80023da:	edd7 7a01 	vldr	s15, [r7, #4]
 80023de:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80023e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80023e6:	d502      	bpl.n	80023ee <MATH_sat+0x2e>
    {
      out = min;
 80023e8:	687b      	ldr	r3, [r7, #4]
 80023ea:	617b      	str	r3, [r7, #20]
 80023ec:	e00a      	b.n	8002404 <MATH_sat+0x44>
    }
  else if(in > max)
 80023ee:	ed97 7a03 	vldr	s14, [r7, #12]
 80023f2:	edd7 7a02 	vldr	s15, [r7, #8]
 80023f6:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80023fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80023fe:	dd01      	ble.n	8002404 <MATH_sat+0x44>
    {
      out = max;
 8002400:	68bb      	ldr	r3, [r7, #8]
 8002402:	617b      	str	r3, [r7, #20]
    }

  return(out);
 8002404:	697b      	ldr	r3, [r7, #20]
 8002406:	ee07 3a90 	vmov	s15, r3
} // end of MATH_sat() function
 800240a:	eeb0 0a67 	vmov.f32	s0, s15
 800240e:	371c      	adds	r7, #28
 8002410:	46bd      	mov	sp, r7
 8002412:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002416:	4770      	bx	lr

08002418 <CLARKE_run>:
//! \brief     Runs the Clarke transform module for three inputs
//! \param[in] handle  The Clarke transform handle
//! \param[in] pInVec        The pointer to the input vector
//! \param[in] pOutVec       The pointer to the output vector
static inline void CLARKE_run(CLARKE_Handle handle,const MATH_vec3 *pInVec,MATH_vec2 *pOutVec)//! \Mod By Dl.K
{
 8002418:	b480      	push	{r7}
 800241a:	b089      	sub	sp, #36	; 0x24
 800241c:	af00      	add	r7, sp, #0
 800241e:	60f8      	str	r0, [r7, #12]
 8002420:	60b9      	str	r1, [r7, #8]
 8002422:	607a      	str	r2, [r7, #4]
  CLARKE_Obj *obj = (CLARKE_Obj *)handle;
 8002424:	68fb      	ldr	r3, [r7, #12]
 8002426:	61fb      	str	r3, [r7, #28]

  uint_least8_t numSensors = obj->numSensors;
 8002428:	69fb      	ldr	r3, [r7, #28]
 800242a:	7a1b      	ldrb	r3, [r3, #8]
 800242c:	76fb      	strb	r3, [r7, #27]

  float_t alpha_sf = obj->alpha_sf;
 800242e:	69fb      	ldr	r3, [r7, #28]
 8002430:	681b      	ldr	r3, [r3, #0]
 8002432:	617b      	str	r3, [r7, #20]
  float_t beta_sf = obj->beta_sf;
 8002434:	69fb      	ldr	r3, [r7, #28]
 8002436:	685b      	ldr	r3, [r3, #4]
 8002438:	613b      	str	r3, [r7, #16]


  if(numSensors == 3)
 800243a:	7efb      	ldrb	r3, [r7, #27]
 800243c:	2b03      	cmp	r3, #3
 800243e:	d125      	bne.n	800248c <CLARKE_run+0x74>
    {
      pOutVec->value[0] = ( (2.0f*(pInVec->value[0]) - (pInVec->value[1] + pInVec->value[2])) * alpha_sf );
 8002440:	68bb      	ldr	r3, [r7, #8]
 8002442:	edd3 7a00 	vldr	s15, [r3]
 8002446:	ee37 7aa7 	vadd.f32	s14, s15, s15
 800244a:	68bb      	ldr	r3, [r7, #8]
 800244c:	edd3 6a01 	vldr	s13, [r3, #4]
 8002450:	68bb      	ldr	r3, [r7, #8]
 8002452:	edd3 7a02 	vldr	s15, [r3, #8]
 8002456:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800245a:	ee37 7a67 	vsub.f32	s14, s14, s15
 800245e:	edd7 7a05 	vldr	s15, [r7, #20]
 8002462:	ee67 7a27 	vmul.f32	s15, s14, s15
 8002466:	687b      	ldr	r3, [r7, #4]
 8002468:	edc3 7a00 	vstr	s15, [r3]
      pOutVec->value[1] = (pInVec->value[1] - pInVec->value[2] * beta_sf);
 800246c:	68bb      	ldr	r3, [r7, #8]
 800246e:	ed93 7a01 	vldr	s14, [r3, #4]
 8002472:	68bb      	ldr	r3, [r7, #8]
 8002474:	edd3 6a02 	vldr	s13, [r3, #8]
 8002478:	edd7 7a04 	vldr	s15, [r7, #16]
 800247c:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8002480:	ee77 7a67 	vsub.f32	s15, s14, s15
 8002484:	687b      	ldr	r3, [r7, #4]
 8002486:	edc3 7a01 	vstr	s15, [r3, #4]
 800248a:	e01d      	b.n	80024c8 <CLARKE_run+0xb0>
    }
  else if(numSensors == 2)
 800248c:	7efb      	ldrb	r3, [r7, #27]
 800248e:	2b02      	cmp	r3, #2
 8002490:	d11a      	bne.n	80024c8 <CLARKE_run+0xb0>
    {
      pOutVec->value[0] = (pInVec->value[0] * alpha_sf);
 8002492:	68bb      	ldr	r3, [r7, #8]
 8002494:	ed93 7a00 	vldr	s14, [r3]
 8002498:	edd7 7a05 	vldr	s15, [r7, #20]
 800249c:	ee67 7a27 	vmul.f32	s15, s14, s15
 80024a0:	687b      	ldr	r3, [r7, #4]
 80024a2:	edc3 7a00 	vstr	s15, [r3]
      pOutVec->value[1] = ( (pInVec->value[0] + 2.0f*(pInVec->value[1])) * beta_sf );
 80024a6:	68bb      	ldr	r3, [r7, #8]
 80024a8:	ed93 7a00 	vldr	s14, [r3]
 80024ac:	68bb      	ldr	r3, [r7, #8]
 80024ae:	edd3 7a01 	vldr	s15, [r3, #4]
 80024b2:	ee77 7aa7 	vadd.f32	s15, s15, s15
 80024b6:	ee37 7a27 	vadd.f32	s14, s14, s15
 80024ba:	edd7 7a04 	vldr	s15, [r7, #16]
 80024be:	ee67 7a27 	vmul.f32	s15, s14, s15
 80024c2:	687b      	ldr	r3, [r7, #4]
 80024c4:	edc3 7a01 	vstr	s15, [r3, #4]
    }

  return;
 80024c8:	bf00      	nop
} // end of CLARKE_run() function
 80024ca:	3724      	adds	r7, #36	; 0x24
 80024cc:	46bd      	mov	sp, r7
 80024ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80024d2:	4770      	bx	lr

080024d4 <CLARKE_setNumSensors>:

//! \brief     Sets the number of sensors
//! \param[in] handle  The Clarke transform handle
//! \param[in] numSensors    The number of sensors
static inline void CLARKE_setNumSensors(CLARKE_Handle handle,const uint_least8_t numSensors)//! \Mod By Dl.K
{
 80024d4:	b480      	push	{r7}
 80024d6:	b085      	sub	sp, #20
 80024d8:	af00      	add	r7, sp, #0
 80024da:	6078      	str	r0, [r7, #4]
 80024dc:	460b      	mov	r3, r1
 80024de:	70fb      	strb	r3, [r7, #3]
  CLARKE_Obj *obj = (CLARKE_Obj *)handle;
 80024e0:	687b      	ldr	r3, [r7, #4]
 80024e2:	60fb      	str	r3, [r7, #12]

  obj->numSensors = numSensors;
 80024e4:	68fb      	ldr	r3, [r7, #12]
 80024e6:	78fa      	ldrb	r2, [r7, #3]
 80024e8:	721a      	strb	r2, [r3, #8]

  return;
 80024ea:	bf00      	nop
} // end of CLARKE_setNumSensors() function
 80024ec:	3714      	adds	r7, #20
 80024ee:	46bd      	mov	sp, r7
 80024f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80024f4:	4770      	bx	lr
 80024f6:	bf00      	nop

080024f8 <CLARKE_setScaleFactors>:
//! \brief     Sets the scale factors
//! \param[in] handle  The Clarke transform handle
//! \param[in] alpha_sf      The scale factor for the alpha voltage
//! \param[in] beta_sf       The scale factor for the beta voltage
static inline void CLARKE_setScaleFactors(CLARKE_Handle handle,const float_t alpha_sf,const float_t beta_sf)//! \Mod By Dl.K
{
 80024f8:	b480      	push	{r7}
 80024fa:	b087      	sub	sp, #28
 80024fc:	af00      	add	r7, sp, #0
 80024fe:	60f8      	str	r0, [r7, #12]
 8002500:	ed87 0a02 	vstr	s0, [r7, #8]
 8002504:	edc7 0a01 	vstr	s1, [r7, #4]
  CLARKE_Obj *obj = (CLARKE_Obj *)handle;
 8002508:	68fb      	ldr	r3, [r7, #12]
 800250a:	617b      	str	r3, [r7, #20]


  obj->alpha_sf = alpha_sf;
 800250c:	697b      	ldr	r3, [r7, #20]
 800250e:	68ba      	ldr	r2, [r7, #8]
 8002510:	601a      	str	r2, [r3, #0]
  obj->beta_sf = beta_sf;
 8002512:	697b      	ldr	r3, [r7, #20]
 8002514:	687a      	ldr	r2, [r7, #4]
 8002516:	605a      	str	r2, [r3, #4]

  return;
 8002518:	bf00      	nop
} // end of CLARKE_setScaleFactors() function
 800251a:	371c      	adds	r7, #28
 800251c:	46bd      	mov	sp, r7
 800251e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002522:	4770      	bx	lr

08002524 <PARK_run>:
//! \brief     Runs the Park transform module
//! \param[in] handle  The Park transform handle
//! \param[in] pInVec      The pointer to the input vector
//! \param[in] pOutVec     The pointer to the output vector
static inline void PARK_run(PARK_Handle handle,const MATH_vec2 *pInVec,MATH_vec2 *pOutVec)//! \Mod By Dl.K
{
 8002524:	b480      	push	{r7}
 8002526:	b08b      	sub	sp, #44	; 0x2c
 8002528:	af00      	add	r7, sp, #0
 800252a:	60f8      	str	r0, [r7, #12]
 800252c:	60b9      	str	r1, [r7, #8]
 800252e:	607a      	str	r2, [r7, #4]
  PARK_Obj *obj = (PARK_Obj *)handle;
 8002530:	68fb      	ldr	r3, [r7, #12]
 8002532:	627b      	str	r3, [r7, #36]	; 0x24

  float_t sinTh = obj->sinTh;
 8002534:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002536:	681b      	ldr	r3, [r3, #0]
 8002538:	623b      	str	r3, [r7, #32]
  float_t cosTh = obj->cosTh;
 800253a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800253c:	685b      	ldr	r3, [r3, #4]
 800253e:	61fb      	str	r3, [r7, #28]

  float_t value_0 = pInVec->value[0];
 8002540:	68bb      	ldr	r3, [r7, #8]
 8002542:	681b      	ldr	r3, [r3, #0]
 8002544:	61bb      	str	r3, [r7, #24]
  float_t value_1 = pInVec->value[1];
 8002546:	68bb      	ldr	r3, [r7, #8]
 8002548:	685b      	ldr	r3, [r3, #4]
 800254a:	617b      	str	r3, [r7, #20]


  pOutVec->value[0] = (value_0*cosTh) + (value_1*sinTh);
 800254c:	ed97 7a06 	vldr	s14, [r7, #24]
 8002550:	edd7 7a07 	vldr	s15, [r7, #28]
 8002554:	ee27 7a27 	vmul.f32	s14, s14, s15
 8002558:	edd7 6a05 	vldr	s13, [r7, #20]
 800255c:	edd7 7a08 	vldr	s15, [r7, #32]
 8002560:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8002564:	ee77 7a27 	vadd.f32	s15, s14, s15
 8002568:	687b      	ldr	r3, [r7, #4]
 800256a:	edc3 7a00 	vstr	s15, [r3]
  pOutVec->value[1] = (value_1*cosTh) - (value_0*sinTh);
 800256e:	ed97 7a05 	vldr	s14, [r7, #20]
 8002572:	edd7 7a07 	vldr	s15, [r7, #28]
 8002576:	ee27 7a27 	vmul.f32	s14, s14, s15
 800257a:	edd7 6a06 	vldr	s13, [r7, #24]
 800257e:	edd7 7a08 	vldr	s15, [r7, #32]
 8002582:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8002586:	ee77 7a67 	vsub.f32	s15, s14, s15
 800258a:	687b      	ldr	r3, [r7, #4]
 800258c:	edc3 7a01 	vstr	s15, [r3, #4]

  return;
 8002590:	bf00      	nop
} // end of PARK_run() function
 8002592:	372c      	adds	r7, #44	; 0x2c
 8002594:	46bd      	mov	sp, r7
 8002596:	f85d 7b04 	ldr.w	r7, [sp], #4
 800259a:	4770      	bx	lr

0800259c <PARK_setPhasor>:

//! \brief     Sets the cosine/sine phasor for the inverse Park transform
//! \param[in] handle   The Park transform handle
//! \param[in] pPhasor      The pointer to the cosine/sine phasor, pu
static inline void PARK_setPhasor(PARK_Handle handle,const MATH_vec2 *pPhasor)//! \Mod By Dl.K
{
 800259c:	b480      	push	{r7}
 800259e:	b085      	sub	sp, #20
 80025a0:	af00      	add	r7, sp, #0
 80025a2:	6078      	str	r0, [r7, #4]
 80025a4:	6039      	str	r1, [r7, #0]
  PARK_Obj *obj = (PARK_Obj *)handle;
 80025a6:	687b      	ldr	r3, [r7, #4]
 80025a8:	60fb      	str	r3, [r7, #12]

  obj->cosTh = pPhasor->value[0];
 80025aa:	683b      	ldr	r3, [r7, #0]
 80025ac:	681a      	ldr	r2, [r3, #0]
 80025ae:	68fb      	ldr	r3, [r7, #12]
 80025b0:	605a      	str	r2, [r3, #4]
  obj->sinTh = pPhasor->value[1];
 80025b2:	683b      	ldr	r3, [r7, #0]
 80025b4:	685a      	ldr	r2, [r3, #4]
 80025b6:	68fb      	ldr	r3, [r7, #12]
 80025b8:	601a      	str	r2, [r3, #0]

  return;
 80025ba:	bf00      	nop
} // end of PARK_setPhasor() function
 80025bc:	3714      	adds	r7, #20
 80025be:	46bd      	mov	sp, r7
 80025c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80025c4:	4770      	bx	lr
 80025c6:	bf00      	nop

080025c8 <IPARK_run>:
//! \brief     Runs the inverse Park transform module
//! \param[in] handle  The inverse Park transform handle
//! \param[in] pInVec       The pointer to the input vector
//! \param[in] pOutVec      The pointer to the output vector
static inline void IPARK_run(IPARK_Handle handle,const MATH_vec2 *pInVec,MATH_vec2 *pOutVec)//! \Mod By Dl.K
{
 80025c8:	b480      	push	{r7}
 80025ca:	b08b      	sub	sp, #44	; 0x2c
 80025cc:	af00      	add	r7, sp, #0
 80025ce:	60f8      	str	r0, [r7, #12]
 80025d0:	60b9      	str	r1, [r7, #8]
 80025d2:	607a      	str	r2, [r7, #4]
  IPARK_Obj *obj = (IPARK_Obj *)handle;
 80025d4:	68fb      	ldr	r3, [r7, #12]
 80025d6:	627b      	str	r3, [r7, #36]	; 0x24

  float_t sinTh = obj->sinTh;
 80025d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80025da:	681b      	ldr	r3, [r3, #0]
 80025dc:	623b      	str	r3, [r7, #32]
  float_t cosTh = obj->cosTh;
 80025de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80025e0:	685b      	ldr	r3, [r3, #4]
 80025e2:	61fb      	str	r3, [r7, #28]

  float_t value_0 = pInVec->value[0];
 80025e4:	68bb      	ldr	r3, [r7, #8]
 80025e6:	681b      	ldr	r3, [r3, #0]
 80025e8:	61bb      	str	r3, [r7, #24]
  float_t value_1 = pInVec->value[1];
 80025ea:	68bb      	ldr	r3, [r7, #8]
 80025ec:	685b      	ldr	r3, [r3, #4]
 80025ee:	617b      	str	r3, [r7, #20]


  pOutVec->value[0] = (value_0*cosTh) - (value_1*sinTh);
 80025f0:	ed97 7a06 	vldr	s14, [r7, #24]
 80025f4:	edd7 7a07 	vldr	s15, [r7, #28]
 80025f8:	ee27 7a27 	vmul.f32	s14, s14, s15
 80025fc:	edd7 6a05 	vldr	s13, [r7, #20]
 8002600:	edd7 7a08 	vldr	s15, [r7, #32]
 8002604:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8002608:	ee77 7a67 	vsub.f32	s15, s14, s15
 800260c:	687b      	ldr	r3, [r7, #4]
 800260e:	edc3 7a00 	vstr	s15, [r3]
  pOutVec->value[1] = (value_1*cosTh) + (value_0*sinTh);
 8002612:	ed97 7a05 	vldr	s14, [r7, #20]
 8002616:	edd7 7a07 	vldr	s15, [r7, #28]
 800261a:	ee27 7a27 	vmul.f32	s14, s14, s15
 800261e:	edd7 6a06 	vldr	s13, [r7, #24]
 8002622:	edd7 7a08 	vldr	s15, [r7, #32]
 8002626:	ee66 7aa7 	vmul.f32	s15, s13, s15
 800262a:	ee77 7a27 	vadd.f32	s15, s14, s15
 800262e:	687b      	ldr	r3, [r7, #4]
 8002630:	edc3 7a01 	vstr	s15, [r3, #4]

  return;
 8002634:	bf00      	nop
} // end of IPARK_run() function
 8002636:	372c      	adds	r7, #44	; 0x2c
 8002638:	46bd      	mov	sp, r7
 800263a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800263e:	4770      	bx	lr

08002640 <IPARK_setPhasor>:

//! \brief     Sets the cosine/sine phasor for the inverse Park transform
//! \param[in] handle   The inverse Park transform handle
//! \param[in] pPhasor  The pointer to the cosine/sine phasor, pu
static inline void IPARK_setPhasor(IPARK_Handle handle,const MATH_vec2 *pPhasor)//! \Mod By Dl.K
{
 8002640:	b480      	push	{r7}
 8002642:	b085      	sub	sp, #20
 8002644:	af00      	add	r7, sp, #0
 8002646:	6078      	str	r0, [r7, #4]
 8002648:	6039      	str	r1, [r7, #0]
  IPARK_Obj *obj = (IPARK_Obj *)handle;
 800264a:	687b      	ldr	r3, [r7, #4]
 800264c:	60fb      	str	r3, [r7, #12]

  obj->cosTh = pPhasor->value[0];
 800264e:	683b      	ldr	r3, [r7, #0]
 8002650:	681a      	ldr	r2, [r3, #0]
 8002652:	68fb      	ldr	r3, [r7, #12]
 8002654:	605a      	str	r2, [r3, #4]
  obj->sinTh = pPhasor->value[1];
 8002656:	683b      	ldr	r3, [r7, #0]
 8002658:	685a      	ldr	r2, [r3, #4]
 800265a:	68fb      	ldr	r3, [r7, #12]
 800265c:	601a      	str	r2, [r3, #0]

  return;
 800265e:	bf00      	nop
} // end of IPARK_setPhasor() function
 8002660:	3714      	adds	r7, #20
 8002662:	46bd      	mov	sp, r7
 8002664:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002668:	4770      	bx	lr
 800266a:	bf00      	nop

0800266c <FILTER_FO_run>:
//!
//! \param[in] handle      The filter handle
//! \param[in] inputValue  The input value to filter
//! \return    The output value from the filter
static inline float_t FILTER_FO_run(FILTER_FO_Handle handle,const float_t inputValue)
{
 800266c:	b480      	push	{r7}
 800266e:	b08b      	sub	sp, #44	; 0x2c
 8002670:	af00      	add	r7, sp, #0
 8002672:	6078      	str	r0, [r7, #4]
 8002674:	ed87 0a00 	vstr	s0, [r7]
  FILTER_FO_Obj *obj = (FILTER_FO_Obj *)handle;
 8002678:	687b      	ldr	r3, [r7, #4]
 800267a:	627b      	str	r3, [r7, #36]	; 0x24

  float a1 = obj->a1;
 800267c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800267e:	681b      	ldr	r3, [r3, #0]
 8002680:	623b      	str	r3, [r7, #32]
  float b0 = obj->b0;
 8002682:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002684:	685b      	ldr	r3, [r3, #4]
 8002686:	61fb      	str	r3, [r7, #28]
  float b1 = obj->b1;
 8002688:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800268a:	689b      	ldr	r3, [r3, #8]
 800268c:	61bb      	str	r3, [r7, #24]
  float x1 = obj->x1;
 800268e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002690:	68db      	ldr	r3, [r3, #12]
 8002692:	617b      	str	r3, [r7, #20]
  float y1 = obj->y1;
 8002694:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002696:	691b      	ldr	r3, [r3, #16]
 8002698:	613b      	str	r3, [r7, #16]


  // compute the output
  //settestpin();

  float y0 = (b0 * inputValue) + (b1 * x1) - (a1 * y1);
 800269a:	ed97 7a07 	vldr	s14, [r7, #28]
 800269e:	edd7 7a00 	vldr	s15, [r7]
 80026a2:	ee27 7a27 	vmul.f32	s14, s14, s15
 80026a6:	edd7 6a06 	vldr	s13, [r7, #24]
 80026aa:	edd7 7a05 	vldr	s15, [r7, #20]
 80026ae:	ee66 7aa7 	vmul.f32	s15, s13, s15
 80026b2:	ee37 7a27 	vadd.f32	s14, s14, s15
 80026b6:	edd7 6a08 	vldr	s13, [r7, #32]
 80026ba:	edd7 7a04 	vldr	s15, [r7, #16]
 80026be:	ee66 7aa7 	vmul.f32	s15, s13, s15
 80026c2:	ee77 7a67 	vsub.f32	s15, s14, s15
 80026c6:	edc7 7a03 	vstr	s15, [r7, #12]
  //double y0 = 0;
  //cleartestpin();


  // store values for next time
  obj->x1 = inputValue;
 80026ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80026cc:	683a      	ldr	r2, [r7, #0]
 80026ce:	60da      	str	r2, [r3, #12]
  obj->y1 = (float_t)y0;
 80026d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80026d2:	68fa      	ldr	r2, [r7, #12]
 80026d4:	611a      	str	r2, [r3, #16]

  return((float_t)y0);
 80026d6:	68fb      	ldr	r3, [r7, #12]
 80026d8:	ee07 3a90 	vmov	s15, r3
} // end of FILTER_FO_run() function
 80026dc:	eeb0 0a67 	vmov.f32	s0, s15
 80026e0:	372c      	adds	r7, #44	; 0x2c
 80026e2:	46bd      	mov	sp, r7
 80026e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80026e8:	4770      	bx	lr
 80026ea:	bf00      	nop

080026ec <OFFSET_run>:
//!            x -> The ADC measurement
//!
//! \param[in] handle  The offset handle
//! \param[in] inputValue    The input value to offset filter
static inline void OFFSET_run(OFFSET_Handle handle,const float_t inputValue)
{
 80026ec:	b580      	push	{r7, lr}
 80026ee:	b084      	sub	sp, #16
 80026f0:	af00      	add	r7, sp, #0
 80026f2:	6078      	str	r0, [r7, #4]
 80026f4:	ed87 0a00 	vstr	s0, [r7]
  OFFSET_Obj *obj = (OFFSET_Obj *)handle;
 80026f8:	687b      	ldr	r3, [r7, #4]
 80026fa:	60fb      	str	r3, [r7, #12]

  obj->value = FILTER_FO_run(obj->filterHandle,inputValue);
 80026fc:	68fb      	ldr	r3, [r7, #12]
 80026fe:	69db      	ldr	r3, [r3, #28]
 8002700:	4618      	mov	r0, r3
 8002702:	ed97 0a00 	vldr	s0, [r7]
 8002706:	f7ff ffb1 	bl	800266c <FILTER_FO_run>
 800270a:	eef0 7a40 	vmov.f32	s15, s0
 800270e:	68fb      	ldr	r3, [r7, #12]
 8002710:	edc3 7a00 	vstr	s15, [r3]

  return;
 8002714:	bf00      	nop
} // end of OFFSET_run() function
 8002716:	3710      	adds	r7, #16
 8002718:	46bd      	mov	sp, r7
 800271a:	bd80      	pop	{r7, pc}

0800271c <PID_run>:
//! \param[in] handle      The PID controller handle
//! \param[in] refValue    The reference value to the controller
//! \param[in] fbackValue  The feedback value to the controller
//! \param[in] pOutValue   The pointer to the controller output value
static inline void PID_run(PID_Handle handle,const float_t refValue,const float_t fbackValue,float_t *pOutValue)//! \Mod By Dl.K
{
 800271c:	b580      	push	{r7, lr}
 800271e:	b088      	sub	sp, #32
 8002720:	af00      	add	r7, sp, #0
 8002722:	60f8      	str	r0, [r7, #12]
 8002724:	ed87 0a02 	vstr	s0, [r7, #8]
 8002728:	edc7 0a01 	vstr	s1, [r7, #4]
 800272c:	6039      	str	r1, [r7, #0]
  PID_Obj *obj = (PID_Obj *)handle;
 800272e:	68fb      	ldr	r3, [r7, #12]
 8002730:	61fb      	str	r3, [r7, #28]

  float_t Error;
  float_t Up,Ui;


  Error = refValue - fbackValue;
 8002732:	ed97 7a02 	vldr	s14, [r7, #8]
 8002736:	edd7 7a01 	vldr	s15, [r7, #4]
 800273a:	ee77 7a67 	vsub.f32	s15, s14, s15
 800273e:	edc7 7a06 	vstr	s15, [r7, #24]

  Ui = obj->Ui;                                                  // load the previous integral output
 8002742:	69fb      	ldr	r3, [r7, #28]
 8002744:	68db      	ldr	r3, [r3, #12]
 8002746:	617b      	str	r3, [r7, #20]
  Up = (obj->Kp * Error);                                    // Compute the proportional output
 8002748:	69fb      	ldr	r3, [r7, #28]
 800274a:	ed93 7a00 	vldr	s14, [r3]
 800274e:	edd7 7a06 	vldr	s15, [r7, #24]
 8002752:	ee67 7a27 	vmul.f32	s15, s14, s15
 8002756:	edc7 7a04 	vstr	s15, [r7, #16]
  Ui = MATH_sat(Ui + (obj->Ki * Up), obj->outMax, obj->outMin);  // Compute the integral output
 800275a:	69fb      	ldr	r3, [r7, #28]
 800275c:	ed93 7a01 	vldr	s14, [r3, #4]
 8002760:	edd7 7a04 	vldr	s15, [r7, #16]
 8002764:	ee27 7a27 	vmul.f32	s14, s14, s15
 8002768:	edd7 7a05 	vldr	s15, [r7, #20]
 800276c:	ee77 6a27 	vadd.f32	s13, s14, s15
 8002770:	69fb      	ldr	r3, [r7, #28]
 8002772:	ed93 7a07 	vldr	s14, [r3, #28]
 8002776:	69fb      	ldr	r3, [r7, #28]
 8002778:	edd3 7a06 	vldr	s15, [r3, #24]
 800277c:	eeb0 0a66 	vmov.f32	s0, s13
 8002780:	eef0 0a47 	vmov.f32	s1, s14
 8002784:	eeb0 1a67 	vmov.f32	s2, s15
 8002788:	f7ff fe1a 	bl	80023c0 <MATH_sat>
 800278c:	ed87 0a05 	vstr	s0, [r7, #20]

  obj->Ui = Ui;                                                  // store the intetral output
 8002790:	69fb      	ldr	r3, [r7, #28]
 8002792:	697a      	ldr	r2, [r7, #20]
 8002794:	60da      	str	r2, [r3, #12]
  obj->refValue = refValue;
 8002796:	69fb      	ldr	r3, [r7, #28]
 8002798:	68ba      	ldr	r2, [r7, #8]
 800279a:	611a      	str	r2, [r3, #16]
  obj->fbackValue = fbackValue;
 800279c:	69fb      	ldr	r3, [r7, #28]
 800279e:	687a      	ldr	r2, [r7, #4]
 80027a0:	615a      	str	r2, [r3, #20]

  *pOutValue = MATH_sat(Up + Ui, obj->outMax, obj->outMin);          // Saturate the output
 80027a2:	ed97 7a04 	vldr	s14, [r7, #16]
 80027a6:	edd7 7a05 	vldr	s15, [r7, #20]
 80027aa:	ee77 6a27 	vadd.f32	s13, s14, s15
 80027ae:	69fb      	ldr	r3, [r7, #28]
 80027b0:	ed93 7a07 	vldr	s14, [r3, #28]
 80027b4:	69fb      	ldr	r3, [r7, #28]
 80027b6:	edd3 7a06 	vldr	s15, [r3, #24]
 80027ba:	eeb0 0a66 	vmov.f32	s0, s13
 80027be:	eef0 0a47 	vmov.f32	s1, s14
 80027c2:	eeb0 1a67 	vmov.f32	s2, s15
 80027c6:	f7ff fdfb 	bl	80023c0 <MATH_sat>
 80027ca:	eef0 7a40 	vmov.f32	s15, s0
 80027ce:	683b      	ldr	r3, [r7, #0]
 80027d0:	edc3 7a00 	vstr	s15, [r3]

  return;
 80027d4:	bf00      	nop
} // end of PID_run() function
 80027d6:	3720      	adds	r7, #32
 80027d8:	46bd      	mov	sp, r7
 80027da:	bd80      	pop	{r7, pc}

080027dc <PID_run_spd>:
//! \param[in] handle      The PID controller handle
//! \param[in] refValue    The reference value to the controller
//! \param[in] fbackValue  The feedback value to the controller
//! \param[in] pOutValue   The pointer to the controller output value
static inline void PID_run_spd(PID_Handle handle,const float_t refValue,const float_t fbackValue,float_t *pOutValue)//! \Mod By Dl.K
{
 80027dc:	b580      	push	{r7, lr}
 80027de:	b088      	sub	sp, #32
 80027e0:	af00      	add	r7, sp, #0
 80027e2:	60f8      	str	r0, [r7, #12]
 80027e4:	ed87 0a02 	vstr	s0, [r7, #8]
 80027e8:	edc7 0a01 	vstr	s1, [r7, #4]
 80027ec:	6039      	str	r1, [r7, #0]
  PID_Obj *obj = (PID_Obj *)handle;
 80027ee:	68fb      	ldr	r3, [r7, #12]
 80027f0:	61fb      	str	r3, [r7, #28]

  float_t Error;
  float_t Up,Ui;

  Error = refValue - fbackValue;
 80027f2:	ed97 7a02 	vldr	s14, [r7, #8]
 80027f6:	edd7 7a01 	vldr	s15, [r7, #4]
 80027fa:	ee77 7a67 	vsub.f32	s15, s14, s15
 80027fe:	edc7 7a06 	vstr	s15, [r7, #24]

  Ui = obj->Ui;                                                     // load the previous integral output
 8002802:	69fb      	ldr	r3, [r7, #28]
 8002804:	68db      	ldr	r3, [r3, #12]
 8002806:	617b      	str	r3, [r7, #20]
  Up = (obj->Kp * Error);                                       // Compute the proportional output
 8002808:	69fb      	ldr	r3, [r7, #28]
 800280a:	ed93 7a00 	vldr	s14, [r3]
 800280e:	edd7 7a06 	vldr	s15, [r7, #24]
 8002812:	ee67 7a27 	vmul.f32	s15, s14, s15
 8002816:	edc7 7a04 	vstr	s15, [r7, #16]
  Ui = MATH_sat(Ui + (obj->Ki * Error), obj->outMax, obj->outMin);  // Compute the integral output
 800281a:	69fb      	ldr	r3, [r7, #28]
 800281c:	ed93 7a01 	vldr	s14, [r3, #4]
 8002820:	edd7 7a06 	vldr	s15, [r7, #24]
 8002824:	ee27 7a27 	vmul.f32	s14, s14, s15
 8002828:	edd7 7a05 	vldr	s15, [r7, #20]
 800282c:	ee77 6a27 	vadd.f32	s13, s14, s15
 8002830:	69fb      	ldr	r3, [r7, #28]
 8002832:	ed93 7a07 	vldr	s14, [r3, #28]
 8002836:	69fb      	ldr	r3, [r7, #28]
 8002838:	edd3 7a06 	vldr	s15, [r3, #24]
 800283c:	eeb0 0a66 	vmov.f32	s0, s13
 8002840:	eef0 0a47 	vmov.f32	s1, s14
 8002844:	eeb0 1a67 	vmov.f32	s2, s15
 8002848:	f7ff fdba 	bl	80023c0 <MATH_sat>
 800284c:	ed87 0a05 	vstr	s0, [r7, #20]

  obj->Ui = Ui;                                                     // store the intetral output
 8002850:	69fb      	ldr	r3, [r7, #28]
 8002852:	697a      	ldr	r2, [r7, #20]
 8002854:	60da      	str	r2, [r3, #12]
  obj->refValue = refValue;
 8002856:	69fb      	ldr	r3, [r7, #28]
 8002858:	68ba      	ldr	r2, [r7, #8]
 800285a:	611a      	str	r2, [r3, #16]
  obj->fbackValue = fbackValue;
 800285c:	69fb      	ldr	r3, [r7, #28]
 800285e:	687a      	ldr	r2, [r7, #4]
 8002860:	615a      	str	r2, [r3, #20]

  *pOutValue = MATH_sat(Up + Ui, obj->outMax, obj->outMin);             // Saturate the output
 8002862:	ed97 7a04 	vldr	s14, [r7, #16]
 8002866:	edd7 7a05 	vldr	s15, [r7, #20]
 800286a:	ee77 6a27 	vadd.f32	s13, s14, s15
 800286e:	69fb      	ldr	r3, [r7, #28]
 8002870:	ed93 7a07 	vldr	s14, [r3, #28]
 8002874:	69fb      	ldr	r3, [r7, #28]
 8002876:	edd3 7a06 	vldr	s15, [r3, #24]
 800287a:	eeb0 0a66 	vmov.f32	s0, s13
 800287e:	eef0 0a47 	vmov.f32	s1, s14
 8002882:	eeb0 1a67 	vmov.f32	s2, s15
 8002886:	f7ff fd9b 	bl	80023c0 <MATH_sat>
 800288a:	eef0 7a40 	vmov.f32	s15, s0
 800288e:	683b      	ldr	r3, [r7, #0]
 8002890:	edc3 7a00 	vstr	s15, [r3]

  return;
 8002894:	bf00      	nop
} // end of PID_run_spd() function
 8002896:	3720      	adds	r7, #32
 8002898:	46bd      	mov	sp, r7
 800289a:	bd80      	pop	{r7, pc}

0800289c <PID_setGains>:
//! \param[in] handle  The PID controller handle
//! \param[in] Kp      The proportional gain for the PID controller
//! \param[in] Ki      The integrator gain for the PID controller
//! \param[in] Kd      The derivative gain for the PID controller
static inline void PID_setGains(PID_Handle handle,const float_t Kp,const float_t Ki,const float_t Kd)//! \Mod By Dl.K
{
 800289c:	b480      	push	{r7}
 800289e:	b087      	sub	sp, #28
 80028a0:	af00      	add	r7, sp, #0
 80028a2:	60f8      	str	r0, [r7, #12]
 80028a4:	ed87 0a02 	vstr	s0, [r7, #8]
 80028a8:	edc7 0a01 	vstr	s1, [r7, #4]
 80028ac:	ed87 1a00 	vstr	s2, [r7]
  PID_Obj *obj = (PID_Obj *)handle;
 80028b0:	68fb      	ldr	r3, [r7, #12]
 80028b2:	617b      	str	r3, [r7, #20]

  obj->Kp = Kp;
 80028b4:	697b      	ldr	r3, [r7, #20]
 80028b6:	68ba      	ldr	r2, [r7, #8]
 80028b8:	601a      	str	r2, [r3, #0]
  obj->Ki = Ki;
 80028ba:	697b      	ldr	r3, [r7, #20]
 80028bc:	687a      	ldr	r2, [r7, #4]
 80028be:	605a      	str	r2, [r3, #4]
  obj->Kd = Kd;
 80028c0:	697b      	ldr	r3, [r7, #20]
 80028c2:	683a      	ldr	r2, [r7, #0]
 80028c4:	609a      	str	r2, [r3, #8]

  return;
 80028c6:	bf00      	nop
} // end of PID_setGains() function
 80028c8:	371c      	adds	r7, #28
 80028ca:	46bd      	mov	sp, r7
 80028cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80028d0:	4770      	bx	lr
 80028d2:	bf00      	nop

080028d4 <PID_setKi>:

//! \brief     Sets the integral gain in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] Ki      The integral gain for the PID controller
static inline void PID_setKi(PID_Handle handle,const float_t Ki)//! \Mod By Dl.K
{
 80028d4:	b480      	push	{r7}
 80028d6:	b085      	sub	sp, #20
 80028d8:	af00      	add	r7, sp, #0
 80028da:	6078      	str	r0, [r7, #4]
 80028dc:	ed87 0a00 	vstr	s0, [r7]
  PID_Obj *obj = (PID_Obj *)handle;
 80028e0:	687b      	ldr	r3, [r7, #4]
 80028e2:	60fb      	str	r3, [r7, #12]

  obj->Ki = Ki;
 80028e4:	68fb      	ldr	r3, [r7, #12]
 80028e6:	683a      	ldr	r2, [r7, #0]
 80028e8:	605a      	str	r2, [r3, #4]

  return;
 80028ea:	bf00      	nop
} // end of PID_setKi() function
 80028ec:	3714      	adds	r7, #20
 80028ee:	46bd      	mov	sp, r7
 80028f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80028f4:	4770      	bx	lr
 80028f6:	bf00      	nop

080028f8 <PID_setKp>:

//! \brief     Sets the proportional gain in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] Kp      The proportional gain for the PID controller
static inline void PID_setKp(PID_Handle handle,const float_t Kp)//! \Mod By Dl.K
{
 80028f8:	b480      	push	{r7}
 80028fa:	b085      	sub	sp, #20
 80028fc:	af00      	add	r7, sp, #0
 80028fe:	6078      	str	r0, [r7, #4]
 8002900:	ed87 0a00 	vstr	s0, [r7]
  PID_Obj *obj = (PID_Obj *)handle;
 8002904:	687b      	ldr	r3, [r7, #4]
 8002906:	60fb      	str	r3, [r7, #12]

  obj->Kp = Kp;
 8002908:	68fb      	ldr	r3, [r7, #12]
 800290a:	683a      	ldr	r2, [r7, #0]
 800290c:	601a      	str	r2, [r3, #0]

  return;
 800290e:	bf00      	nop
} // end of PID_setKp() function
 8002910:	3714      	adds	r7, #20
 8002912:	46bd      	mov	sp, r7
 8002914:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002918:	4770      	bx	lr
 800291a:	bf00      	nop

0800291c <PID_setMinMax>:
//! \brief     Sets the minimum and maximum output value allowed in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] outMin  The minimum output value allowed
//! \param[in] outMax  The maximum output value allowed
static inline void PID_setMinMax(PID_Handle handle,const float_t outMin,const float_t outMax)//! \Mod By Dl.K
{
 800291c:	b480      	push	{r7}
 800291e:	b087      	sub	sp, #28
 8002920:	af00      	add	r7, sp, #0
 8002922:	60f8      	str	r0, [r7, #12]
 8002924:	ed87 0a02 	vstr	s0, [r7, #8]
 8002928:	edc7 0a01 	vstr	s1, [r7, #4]
  PID_Obj *obj = (PID_Obj *)handle;
 800292c:	68fb      	ldr	r3, [r7, #12]
 800292e:	617b      	str	r3, [r7, #20]

  obj->outMin = outMin;
 8002930:	697b      	ldr	r3, [r7, #20]
 8002932:	68ba      	ldr	r2, [r7, #8]
 8002934:	619a      	str	r2, [r3, #24]
  obj->outMax = outMax;
 8002936:	697b      	ldr	r3, [r7, #20]
 8002938:	687a      	ldr	r2, [r7, #4]
 800293a:	61da      	str	r2, [r3, #28]

  return;
 800293c:	bf00      	nop
} // end of PID_setMinMax() function
 800293e:	371c      	adds	r7, #28
 8002940:	46bd      	mov	sp, r7
 8002942:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002946:	4770      	bx	lr

08002948 <PID_setUi>:

//! \brief     Sets the integrator start value in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] Ui         The integral start value for the PID controller
static inline void PID_setUi(PID_Handle handle,const float_t Ui)//! \Mod By Dl.K
{
 8002948:	b480      	push	{r7}
 800294a:	b085      	sub	sp, #20
 800294c:	af00      	add	r7, sp, #0
 800294e:	6078      	str	r0, [r7, #4]
 8002950:	ed87 0a00 	vstr	s0, [r7]
  PID_Obj *obj = (PID_Obj *)handle;
 8002954:	687b      	ldr	r3, [r7, #4]
 8002956:	60fb      	str	r3, [r7, #12]

  obj->Ui = Ui;
 8002958:	68fb      	ldr	r3, [r7, #12]
 800295a:	683a      	ldr	r2, [r7, #0]
 800295c:	60da      	str	r2, [r3, #12]

  return;
 800295e:	bf00      	nop
} // end of PID_setUi() function
 8002960:	3714      	adds	r7, #20
 8002962:	46bd      	mov	sp, r7
 8002964:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002968:	4770      	bx	lr
 800296a:	bf00      	nop

0800296c <SVGEN_run>:
//! \brief	Implements a SVM that saturates at the level of MaxModulation.
//! \param[in] handle  The space vector generator (SVGEN) handle
//! \param[in] pVab    The pointer to the a/b voltages
//! \param[in] pT      The pointer to the pwm duty cycle time durations
static inline void SVGEN_run(SVGEN_Handle handle,const MATH_vec2 *pVab,MATH_vec3 *pT)//! \Mod By Dl.K
{
 800296c:	b480      	push	{r7}
 800296e:	b08d      	sub	sp, #52	; 0x34
 8002970:	af00      	add	r7, sp, #0
 8002972:	60f8      	str	r0, [r7, #12]
 8002974:	60b9      	str	r1, [r7, #8]
 8002976:	607a      	str	r2, [r7, #4]

  float_t Vmax,Vmin,Vcom;
  float_t Va,Vb,Vc;
  float_t Va_tmp = -(pVab->value[0]*0.5f);
 8002978:	68bb      	ldr	r3, [r7, #8]
 800297a:	edd3 7a00 	vldr	s15, [r3]
 800297e:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 8002982:	ee67 7a87 	vmul.f32	s15, s15, s14
 8002986:	eef1 7a67 	vneg.f32	s15, s15
 800298a:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
  float_t Vb_tmp = (SVGEN_SQRT3_OVER_2 * pVab->value[1]);
 800298e:	68bb      	ldr	r3, [r7, #8]
 8002990:	edd3 7a01 	vldr	s15, [r3, #4]
 8002994:	ed9f 7a3a 	vldr	s14, [pc, #232]	; 8002a80 <SVGEN_run+0x114>
 8002998:	ee67 7a87 	vmul.f32	s15, s15, s14
 800299c:	edc7 7a08 	vstr	s15, [r7, #32]
  
  Va = pVab->value[0];  //alpha
 80029a0:	68bb      	ldr	r3, [r7, #8]
 80029a2:	681b      	ldr	r3, [r3, #0]
 80029a4:	61fb      	str	r3, [r7, #28]
  Vb = Va_tmp + Vb_tmp; //-0.5*alpha + sqrt(3)/2 * beta;
 80029a6:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 80029aa:	edd7 7a08 	vldr	s15, [r7, #32]
 80029ae:	ee77 7a27 	vadd.f32	s15, s14, s15
 80029b2:	edc7 7a06 	vstr	s15, [r7, #24]
  Vc = Va_tmp - Vb_tmp; //-0.5*alpha - sqrt(3)/2 * beta;
 80029b6:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 80029ba:	edd7 7a08 	vldr	s15, [r7, #32]
 80029be:	ee77 7a67 	vsub.f32	s15, s14, s15
 80029c2:	edc7 7a05 	vstr	s15, [r7, #20]
	
  Vmax=0;
 80029c6:	f04f 0300 	mov.w	r3, #0
 80029ca:	62fb      	str	r3, [r7, #44]	; 0x2c
  Vmin=0;
 80029cc:	f04f 0300 	mov.w	r3, #0
 80029d0:	62bb      	str	r3, [r7, #40]	; 0x28

  // find order Vmin,Vmid,Vmax
  if (Va > Vb)			
 80029d2:	ed97 7a07 	vldr	s14, [r7, #28]
 80029d6:	edd7 7a06 	vldr	s15, [r7, #24]
 80029da:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80029de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80029e2:	dd04      	ble.n	80029ee <SVGEN_run+0x82>
  {
    Vmax = Va;
 80029e4:	69fb      	ldr	r3, [r7, #28]
 80029e6:	62fb      	str	r3, [r7, #44]	; 0x2c
    Vmin = Vb;
 80029e8:	69bb      	ldr	r3, [r7, #24]
 80029ea:	62bb      	str	r3, [r7, #40]	; 0x28
 80029ec:	e003      	b.n	80029f6 <SVGEN_run+0x8a>
  }
  else
  {
    Vmax = Vb;
 80029ee:	69bb      	ldr	r3, [r7, #24]
 80029f0:	62fb      	str	r3, [r7, #44]	; 0x2c
    Vmin = Va;
 80029f2:	69fb      	ldr	r3, [r7, #28]
 80029f4:	62bb      	str	r3, [r7, #40]	; 0x28
  }

  if (Vc > Vmax)
 80029f6:	ed97 7a05 	vldr	s14, [r7, #20]
 80029fa:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
 80029fe:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8002a02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002a06:	dd02      	ble.n	8002a0e <SVGEN_run+0xa2>
  {
    Vmax = Vc;
 8002a08:	697b      	ldr	r3, [r7, #20]
 8002a0a:	62fb      	str	r3, [r7, #44]	; 0x2c
 8002a0c:	e00a      	b.n	8002a24 <SVGEN_run+0xb8>
  }
  else if (Vc < Vmin)
 8002a0e:	ed97 7a05 	vldr	s14, [r7, #20]
 8002a12:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
 8002a16:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8002a1a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002a1e:	d501      	bpl.n	8002a24 <SVGEN_run+0xb8>
  {
    Vmin = Vc;
 8002a20:	697b      	ldr	r3, [r7, #20]
 8002a22:	62bb      	str	r3, [r7, #40]	; 0x28
  }
		
  Vcom = ( (Vmax+Vmin) * (0.5f));
 8002a24:	ed97 7a0b 	vldr	s14, [r7, #44]	; 0x2c
 8002a28:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
 8002a2c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8002a30:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 8002a34:	ee67 7a87 	vmul.f32	s15, s15, s14
 8002a38:	edc7 7a04 	vstr	s15, [r7, #16]

  // Subtract common-mode term to achieve SV modulation
  pT->value[0] = (Va - Vcom);
 8002a3c:	ed97 7a07 	vldr	s14, [r7, #28]
 8002a40:	edd7 7a04 	vldr	s15, [r7, #16]
 8002a44:	ee77 7a67 	vsub.f32	s15, s14, s15
 8002a48:	687b      	ldr	r3, [r7, #4]
 8002a4a:	edc3 7a00 	vstr	s15, [r3]
  pT->value[1] = (Vb - Vcom);
 8002a4e:	ed97 7a06 	vldr	s14, [r7, #24]
 8002a52:	edd7 7a04 	vldr	s15, [r7, #16]
 8002a56:	ee77 7a67 	vsub.f32	s15, s14, s15
 8002a5a:	687b      	ldr	r3, [r7, #4]
 8002a5c:	edc3 7a01 	vstr	s15, [r3, #4]
  pT->value[2] = (Vc - Vcom);
 8002a60:	ed97 7a05 	vldr	s14, [r7, #20]
 8002a64:	edd7 7a04 	vldr	s15, [r7, #16]
 8002a68:	ee77 7a67 	vsub.f32	s15, s14, s15
 8002a6c:	687b      	ldr	r3, [r7, #4]
 8002a6e:	edc3 7a02 	vstr	s15, [r3, #8]
  
  return;
 8002a72:	bf00      	nop
} // end of SVGEN_run() function
 8002a74:	3734      	adds	r7, #52	; 0x34
 8002a76:	46bd      	mov	sp, r7
 8002a78:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002a7c:	4770      	bx	lr
 8002a7e:	bf00      	nop
 8002a80:	3f5db3d7 	.word	0x3f5db3d7

08002a84 <SVGEN_setMaxModulation>:

//! \brief     Sets the maximum modulation in the space vector generator module
//! \param[in] handle         The space vector generator (SVGEN) handle
//! \param[in] maxModulation  The maximum modulation
static inline void SVGEN_setMaxModulation(SVGEN_Handle handle,const float_t maxModulation)
{
 8002a84:	b480      	push	{r7}
 8002a86:	b085      	sub	sp, #20
 8002a88:	af00      	add	r7, sp, #0
 8002a8a:	6078      	str	r0, [r7, #4]
 8002a8c:	ed87 0a00 	vstr	s0, [r7]
  SVGEN_Obj *obj = (SVGEN_Obj *)handle;
 8002a90:	687b      	ldr	r3, [r7, #4]
 8002a92:	60bb      	str	r3, [r7, #8]
  float_t maxMod = maxModulation;
 8002a94:	683b      	ldr	r3, [r7, #0]
 8002a96:	60fb      	str	r3, [r7, #12]

  if(maxMod > SVGEN_4_OVER_3)
 8002a98:	edd7 7a03 	vldr	s15, [r7, #12]
 8002a9c:	ed9f 7a0e 	vldr	s14, [pc, #56]	; 8002ad8 <SVGEN_setMaxModulation+0x54>
 8002aa0:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002aa4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002aa8:	dd02      	ble.n	8002ab0 <SVGEN_setMaxModulation+0x2c>
      maxMod = SVGEN_4_OVER_3;
 8002aaa:	4b0c      	ldr	r3, [pc, #48]	; (8002adc <SVGEN_setMaxModulation+0x58>)
 8002aac:	60fb      	str	r3, [r7, #12]
 8002aae:	e009      	b.n	8002ac4 <SVGEN_setMaxModulation+0x40>
  else if(maxMod < (0.0f))
 8002ab0:	edd7 7a03 	vldr	s15, [r7, #12]
 8002ab4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8002ab8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002abc:	d502      	bpl.n	8002ac4 <SVGEN_setMaxModulation+0x40>
      maxMod = (0.0f);
 8002abe:	f04f 0300 	mov.w	r3, #0
 8002ac2:	60fb      	str	r3, [r7, #12]

  obj->maxModulation = maxMod;
 8002ac4:	68bb      	ldr	r3, [r7, #8]
 8002ac6:	68fa      	ldr	r2, [r7, #12]
 8002ac8:	601a      	str	r2, [r3, #0]

  return;
 8002aca:	bf00      	nop
} // end of SVGEN_setMaxModulation() function
 8002acc:	3714      	adds	r7, #20
 8002ace:	46bd      	mov	sp, r7
 8002ad0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002ad4:	4770      	bx	lr
 8002ad6:	bf00      	nop
 8002ad8:	3faaaaab 	.word	0x3faaaaab
 8002adc:	3faaaaab 	.word	0x3faaaaab

08002ae0 <TRAJ_setIntValue>:

//! \brief     Sets the intermediate value for the trajectory
//! \param[in] handle    The trajectory (TRAJ) handle
//! \param[in] intValue  The intermediate value
static inline void TRAJ_setIntValue(TRAJ_Handle handle,const float_t intValue)
{
 8002ae0:	b480      	push	{r7}
 8002ae2:	b085      	sub	sp, #20
 8002ae4:	af00      	add	r7, sp, #0
 8002ae6:	6078      	str	r0, [r7, #4]
 8002ae8:	ed87 0a00 	vstr	s0, [r7]
  TRAJ_Obj *obj = (TRAJ_Obj *)handle;
 8002aec:	687b      	ldr	r3, [r7, #4]
 8002aee:	60fb      	str	r3, [r7, #12]

  obj->intValue = intValue;
 8002af0:	68fb      	ldr	r3, [r7, #12]
 8002af2:	683a      	ldr	r2, [r7, #0]
 8002af4:	605a      	str	r2, [r3, #4]

  return;
 8002af6:	bf00      	nop
} // end of TRAJ_setIntValue() function
 8002af8:	3714      	adds	r7, #20
 8002afa:	46bd      	mov	sp, r7
 8002afc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002b00:	4770      	bx	lr
 8002b02:	bf00      	nop

08002b04 <TRAJ_setMaxDelta>:

//! \brief     Sets the maximum delta value for the trajectory
//! \param[in] handle    The trajectory (TRAJ) handle
//! \param[in] maxDelta  The maximum delta value
static inline void TRAJ_setMaxDelta(TRAJ_Handle handle,const float_t maxDelta)
{
 8002b04:	b480      	push	{r7}
 8002b06:	b085      	sub	sp, #20
 8002b08:	af00      	add	r7, sp, #0
 8002b0a:	6078      	str	r0, [r7, #4]
 8002b0c:	ed87 0a00 	vstr	s0, [r7]
  TRAJ_Obj *obj = (TRAJ_Obj *)handle;
 8002b10:	687b      	ldr	r3, [r7, #4]
 8002b12:	60fb      	str	r3, [r7, #12]

  obj->maxDelta = maxDelta;
 8002b14:	68fb      	ldr	r3, [r7, #12]
 8002b16:	683a      	ldr	r2, [r7, #0]
 8002b18:	611a      	str	r2, [r3, #16]

  return;
 8002b1a:	bf00      	nop
} // end of TRAJ_setMaxDelta() function
 8002b1c:	3714      	adds	r7, #20
 8002b1e:	46bd      	mov	sp, r7
 8002b20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002b24:	4770      	bx	lr
 8002b26:	bf00      	nop

08002b28 <TRAJ_setMaxValue>:

//! \brief     Sets the maximum value for the trajectory
//! \param[in] handle    The trajectory (TRAJ) handle
//! \param[in] maxValue  The maximum value
static inline void TRAJ_setMaxValue(TRAJ_Handle handle,const float_t maxValue)
{
 8002b28:	b480      	push	{r7}
 8002b2a:	b085      	sub	sp, #20
 8002b2c:	af00      	add	r7, sp, #0
 8002b2e:	6078      	str	r0, [r7, #4]
 8002b30:	ed87 0a00 	vstr	s0, [r7]
  TRAJ_Obj *obj = (TRAJ_Obj *)handle;
 8002b34:	687b      	ldr	r3, [r7, #4]
 8002b36:	60fb      	str	r3, [r7, #12]

  obj->maxValue = maxValue;
 8002b38:	68fb      	ldr	r3, [r7, #12]
 8002b3a:	683a      	ldr	r2, [r7, #0]
 8002b3c:	60da      	str	r2, [r3, #12]

  return;
 8002b3e:	bf00      	nop
} // end of TRAJ_setMaxValue() function
 8002b40:	3714      	adds	r7, #20
 8002b42:	46bd      	mov	sp, r7
 8002b44:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002b48:	4770      	bx	lr
 8002b4a:	bf00      	nop

08002b4c <TRAJ_setMinValue>:

//! \brief     Sets the minimum value for the trajectory
//! \param[in] handle    The trajectory (TRAJ) handle
//! \param[in] minValue  The minimum value
static inline void TRAJ_setMinValue(TRAJ_Handle handle,const float_t minValue)
{
 8002b4c:	b480      	push	{r7}
 8002b4e:	b085      	sub	sp, #20
 8002b50:	af00      	add	r7, sp, #0
 8002b52:	6078      	str	r0, [r7, #4]
 8002b54:	ed87 0a00 	vstr	s0, [r7]
  TRAJ_Obj *obj = (TRAJ_Obj *)handle;
 8002b58:	687b      	ldr	r3, [r7, #4]
 8002b5a:	60fb      	str	r3, [r7, #12]

  obj->minValue = minValue;
 8002b5c:	68fb      	ldr	r3, [r7, #12]
 8002b5e:	683a      	ldr	r2, [r7, #0]
 8002b60:	609a      	str	r2, [r3, #8]

  return;
 8002b62:	bf00      	nop
} // end of TRAJ_setMinValue() function
 8002b64:	3714      	adds	r7, #20
 8002b66:	46bd      	mov	sp, r7
 8002b68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002b6c:	4770      	bx	lr
 8002b6e:	bf00      	nop

08002b70 <TRAJ_setTargetValue>:

//! \brief     Sets the target value for the trajectory
//! \param[in] handle       The trajectory (TRAJ) handle
//! \param[in] targetValue  The target value
static inline void TRAJ_setTargetValue(TRAJ_Handle handle,const float_t targetValue)
{
 8002b70:	b480      	push	{r7}
 8002b72:	b085      	sub	sp, #20
 8002b74:	af00      	add	r7, sp, #0
 8002b76:	6078      	str	r0, [r7, #4]
 8002b78:	ed87 0a00 	vstr	s0, [r7]
  TRAJ_Obj *obj = (TRAJ_Obj *)handle;
 8002b7c:	687b      	ldr	r3, [r7, #4]
 8002b7e:	60fb      	str	r3, [r7, #12]

  obj->targetValue = targetValue;
 8002b80:	68fb      	ldr	r3, [r7, #12]
 8002b82:	683a      	ldr	r2, [r7, #0]
 8002b84:	601a      	str	r2, [r3, #0]

  return;
 8002b86:	bf00      	nop
} // end of TRAJ_setTargetValue() function
 8002b88:	3714      	adds	r7, #20
 8002b8a:	46bd      	mov	sp, r7
 8002b8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002b90:	4770      	bx	lr
 8002b92:	bf00      	nop

08002b94 <RMP_CNTL_SetRampDelayMax>:
// the functions

extern RMPCNTL_Handle RMP_CNTL_Init(void *pMemory, const size_t numBytes);//! \Mod By Dl.K

static inline void RMP_CNTL_SetRampDelayMax(RMPCNTL_Handle handle, const uint_least32_t value)//! \Mod By Dl.K
{
 8002b94:	b480      	push	{r7}
 8002b96:	b085      	sub	sp, #20
 8002b98:	af00      	add	r7, sp, #0
 8002b9a:	6078      	str	r0, [r7, #4]
 8002b9c:	6039      	str	r1, [r7, #0]
	RMPCNTL_Obj *obj = (RMPCNTL_Obj *)handle;
 8002b9e:	687b      	ldr	r3, [r7, #4]
 8002ba0:	60fb      	str	r3, [r7, #12]

	obj->RampDelayMax = value;
 8002ba2:	68fb      	ldr	r3, [r7, #12]
 8002ba4:	683a      	ldr	r2, [r7, #0]
 8002ba6:	605a      	str	r2, [r3, #4]

	return;
 8002ba8:	bf00      	nop
}
 8002baa:	3714      	adds	r7, #20
 8002bac:	46bd      	mov	sp, r7
 8002bae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002bb2:	4770      	bx	lr

08002bb4 <RMP_CNTL_SetTargetValue>:

static inline void RMP_CNTL_SetTargetValue(RMPCNTL_Handle handle, const float_t target_value)//! \Mod By Dl.K
{
 8002bb4:	b480      	push	{r7}
 8002bb6:	b085      	sub	sp, #20
 8002bb8:	af00      	add	r7, sp, #0
 8002bba:	6078      	str	r0, [r7, #4]
 8002bbc:	ed87 0a00 	vstr	s0, [r7]
	RMPCNTL_Obj *obj = (RMPCNTL_Obj *)handle;
 8002bc0:	687b      	ldr	r3, [r7, #4]
 8002bc2:	60fb      	str	r3, [r7, #12]

	obj->TargetValue = target_value;
 8002bc4:	68fb      	ldr	r3, [r7, #12]
 8002bc6:	683a      	ldr	r2, [r7, #0]
 8002bc8:	601a      	str	r2, [r3, #0]

	return;
 8002bca:	bf00      	nop
}
 8002bcc:	3714      	adds	r7, #20
 8002bce:	46bd      	mov	sp, r7
 8002bd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002bd4:	4770      	bx	lr
 8002bd6:	bf00      	nop

08002bd8 <RMP_CNTL_GetFreq>:

static inline float_t RMP_CNTL_GetFreq(RMPCNTL_Handle handle)//! \Mod By Dl.K
{
 8002bd8:	b480      	push	{r7}
 8002bda:	b085      	sub	sp, #20
 8002bdc:	af00      	add	r7, sp, #0
 8002bde:	6078      	str	r0, [r7, #4]
	RMPCNTL_Obj *obj = (RMPCNTL_Obj *)handle;
 8002be0:	687b      	ldr	r3, [r7, #4]
 8002be2:	60fb      	str	r3, [r7, #12]

	return (obj->SetpointValue);
 8002be4:	68fb      	ldr	r3, [r7, #12]
 8002be6:	695b      	ldr	r3, [r3, #20]
 8002be8:	ee07 3a90 	vmov	s15, r3
}
 8002bec:	eeb0 0a67 	vmov.f32	s0, s15
 8002bf0:	3714      	adds	r7, #20
 8002bf2:	46bd      	mov	sp, r7
 8002bf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002bf8:	4770      	bx	lr
 8002bfa:	bf00      	nop

08002bfc <RMP_CNTL_Run>:
	
	return ;
}

static inline void RMP_CNTL_Run(RMPCNTL_Handle handle)//! \Mod By Dl.K
{
 8002bfc:	b580      	push	{r7, lr}
 8002bfe:	b084      	sub	sp, #16
 8002c00:	af00      	add	r7, sp, #0
 8002c02:	6078      	str	r0, [r7, #4]
	RMPCNTL_Obj *obj = (RMPCNTL_Obj *)handle;
 8002c04:	687b      	ldr	r3, [r7, #4]
 8002c06:	60fb      	str	r3, [r7, #12]

	float_t tmp;

	tmp = obj->TargetValue - obj->SetpointValue;
 8002c08:	68fb      	ldr	r3, [r7, #12]
 8002c0a:	ed93 7a00 	vldr	s14, [r3]
 8002c0e:	68fb      	ldr	r3, [r7, #12]
 8002c10:	edd3 7a05 	vldr	s15, [r3, #20]
 8002c14:	ee77 7a67 	vsub.f32	s15, s14, s15
 8002c18:	edc7 7a02 	vstr	s15, [r7, #8]

	if (MATH_abs(tmp) > (0.0000305f))
 8002c1c:	ed97 0a02 	vldr	s0, [r7, #8]
 8002c20:	f7ff fbb0 	bl	8002384 <MATH_abs>
 8002c24:	eeb0 7a40 	vmov.f32	s14, s0
 8002c28:	eddf 7a2f 	vldr	s15, [pc, #188]	; 8002ce8 <RMP_CNTL_Run+0xec>
 8002c2c:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8002c30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002c34:	dd4f      	ble.n	8002cd6 <RMP_CNTL_Run+0xda>
	{
		obj->RampDelayCount += 1;
 8002c36:	68fb      	ldr	r3, [r7, #12]
 8002c38:	691b      	ldr	r3, [r3, #16]
 8002c3a:	1c5a      	adds	r2, r3, #1
 8002c3c:	68fb      	ldr	r3, [r7, #12]
 8002c3e:	611a      	str	r2, [r3, #16]
		if (obj->RampDelayCount >= obj->RampDelayMax)
 8002c40:	68fb      	ldr	r3, [r7, #12]
 8002c42:	691a      	ldr	r2, [r3, #16]
 8002c44:	68fb      	ldr	r3, [r7, #12]
 8002c46:	685b      	ldr	r3, [r3, #4]
 8002c48:	429a      	cmp	r2, r3
 8002c4a:	d348      	bcc.n	8002cde <RMP_CNTL_Run+0xe2>
		{
			if (obj->TargetValue >= obj->SetpointValue)
 8002c4c:	68fb      	ldr	r3, [r7, #12]
 8002c4e:	ed93 7a00 	vldr	s14, [r3]
 8002c52:	68fb      	ldr	r3, [r7, #12]
 8002c54:	edd3 7a05 	vldr	s15, [r3, #20]
 8002c58:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8002c5c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002c60:	db1c      	blt.n	8002c9c <RMP_CNTL_Run+0xa0>
			{
				obj->SetpointValue += (0.0000305f);        // 0.0000305 is resolution(1/2^15) of Q15
 8002c62:	68fb      	ldr	r3, [r7, #12]
 8002c64:	edd3 7a05 	vldr	s15, [r3, #20]
 8002c68:	ed9f 7a1f 	vldr	s14, [pc, #124]	; 8002ce8 <RMP_CNTL_Run+0xec>
 8002c6c:	ee77 7a87 	vadd.f32	s15, s15, s14
 8002c70:	68fb      	ldr	r3, [r7, #12]
 8002c72:	edc3 7a05 	vstr	s15, [r3, #20]
				if (obj->SetpointValue > obj->RampHighLimit)
 8002c76:	68fb      	ldr	r3, [r7, #12]
 8002c78:	ed93 7a05 	vldr	s14, [r3, #20]
 8002c7c:	68fb      	ldr	r3, [r7, #12]
 8002c7e:	edd3 7a03 	vldr	s15, [r3, #12]
 8002c82:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8002c86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002c8a:	dd03      	ble.n	8002c94 <RMP_CNTL_Run+0x98>
					obj->SetpointValue = obj->RampHighLimit;
 8002c8c:	68fb      	ldr	r3, [r7, #12]
 8002c8e:	68da      	ldr	r2, [r3, #12]
 8002c90:	68fb      	ldr	r3, [r7, #12]
 8002c92:	615a      	str	r2, [r3, #20]
				obj->RampDelayCount = 0;
 8002c94:	68fb      	ldr	r3, [r7, #12]
 8002c96:	2200      	movs	r2, #0
 8002c98:	611a      	str	r2, [r3, #16]
 8002c9a:	e020      	b.n	8002cde <RMP_CNTL_Run+0xe2>
			}
			else
			{
				obj->SetpointValue -= (0.0000305f);        // 0.0000305 is resolution of Q15
 8002c9c:	68fb      	ldr	r3, [r7, #12]
 8002c9e:	edd3 7a05 	vldr	s15, [r3, #20]
 8002ca2:	ed9f 7a11 	vldr	s14, [pc, #68]	; 8002ce8 <RMP_CNTL_Run+0xec>
 8002ca6:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8002caa:	68fb      	ldr	r3, [r7, #12]
 8002cac:	edc3 7a05 	vstr	s15, [r3, #20]
				if (obj->SetpointValue < obj->RampLowLimit)
 8002cb0:	68fb      	ldr	r3, [r7, #12]
 8002cb2:	ed93 7a05 	vldr	s14, [r3, #20]
 8002cb6:	68fb      	ldr	r3, [r7, #12]
 8002cb8:	edd3 7a02 	vldr	s15, [r3, #8]
 8002cbc:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8002cc0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002cc4:	d503      	bpl.n	8002cce <RMP_CNTL_Run+0xd2>
					obj->SetpointValue = obj->RampLowLimit;
 8002cc6:	68fb      	ldr	r3, [r7, #12]
 8002cc8:	689a      	ldr	r2, [r3, #8]
 8002cca:	68fb      	ldr	r3, [r7, #12]
 8002ccc:	615a      	str	r2, [r3, #20]
				obj->RampDelayCount = 0;
 8002cce:	68fb      	ldr	r3, [r7, #12]
 8002cd0:	2200      	movs	r2, #0
 8002cd2:	611a      	str	r2, [r3, #16]
			}
		}
	}
	else  obj->EqualFlag = 0x7FFFFFFF;
	return;
 8002cd4:	e004      	b.n	8002ce0 <RMP_CNTL_Run+0xe4>
					obj->SetpointValue = obj->RampLowLimit;
				obj->RampDelayCount = 0;
			}
		}
	}
	else  obj->EqualFlag = 0x7FFFFFFF;
 8002cd6:	68fb      	ldr	r3, [r7, #12]
 8002cd8:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
 8002cdc:	619a      	str	r2, [r3, #24]
	return;
 8002cde:	bf00      	nop
}
 8002ce0:	3710      	adds	r7, #16
 8002ce2:	46bd      	mov	sp, r7
 8002ce4:	bd80      	pop	{r7, pc}
 8002ce6:	bf00      	nop
 8002ce8:	37ffda40 	.word	0x37ffda40

08002cec <RAMPGEN_GetAngleOut>:
// the functions

extern RAMPGEN_Handle RAMPGEN_Init(void *pMemory, const size_t numBytes);

static inline float_t RAMPGEN_GetAngleOut(RAMPGEN_Handle handle)//! \Mod By Dl.K
{
 8002cec:	b480      	push	{r7}
 8002cee:	b085      	sub	sp, #20
 8002cf0:	af00      	add	r7, sp, #0
 8002cf2:	6078      	str	r0, [r7, #4]
	RAMPGEN_Obj *obj = (RAMPGEN_Obj *)handle;
 8002cf4:	687b      	ldr	r3, [r7, #4]
 8002cf6:	60fb      	str	r3, [r7, #12]

	return (obj->Out);
 8002cf8:	68fb      	ldr	r3, [r7, #12]
 8002cfa:	691b      	ldr	r3, [r3, #16]
 8002cfc:	ee07 3a90 	vmov	s15, r3
}
 8002d00:	eeb0 0a67 	vmov.f32	s0, s15
 8002d04:	3714      	adds	r7, #20
 8002d06:	46bd      	mov	sp, r7
 8002d08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002d0c:	4770      	bx	lr
 8002d0e:	bf00      	nop

08002d10 <RAMPGEN_SetFreq>:

static inline void RAMPGEN_SetFreq(RAMPGEN_Handle handle, const float_t freq)//! \Mod By Dl.K
{
 8002d10:	b480      	push	{r7}
 8002d12:	b085      	sub	sp, #20
 8002d14:	af00      	add	r7, sp, #0
 8002d16:	6078      	str	r0, [r7, #4]
 8002d18:	ed87 0a00 	vstr	s0, [r7]
	RAMPGEN_Obj *obj = (RAMPGEN_Obj *)handle;
 8002d1c:	687b      	ldr	r3, [r7, #4]
 8002d1e:	60fb      	str	r3, [r7, #12]

	obj->Freq = freq;
 8002d20:	68fb      	ldr	r3, [r7, #12]
 8002d22:	683a      	ldr	r2, [r7, #0]
 8002d24:	601a      	str	r2, [r3, #0]

	return;
 8002d26:	bf00      	nop
}
 8002d28:	3714      	adds	r7, #20
 8002d2a:	46bd      	mov	sp, r7
 8002d2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002d30:	4770      	bx	lr
 8002d32:	bf00      	nop

08002d34 <RAMPGEN_SetStepAngleMax>:

static inline void RAMPGEN_SetStepAngleMax(RAMPGEN_Handle handle, const float_t step_angle_max)//! \Mod By Dl.K
{
 8002d34:	b480      	push	{r7}
 8002d36:	b085      	sub	sp, #20
 8002d38:	af00      	add	r7, sp, #0
 8002d3a:	6078      	str	r0, [r7, #4]
 8002d3c:	ed87 0a00 	vstr	s0, [r7]
	RAMPGEN_Obj *obj = (RAMPGEN_Obj *)handle;
 8002d40:	687b      	ldr	r3, [r7, #4]
 8002d42:	60fb      	str	r3, [r7, #12]

	obj->StepAngleMax = step_angle_max;
 8002d44:	68fb      	ldr	r3, [r7, #12]
 8002d46:	683a      	ldr	r2, [r7, #0]
 8002d48:	605a      	str	r2, [r3, #4]

	return;
 8002d4a:	bf00      	nop
}
 8002d4c:	3714      	adds	r7, #20
 8002d4e:	46bd      	mov	sp, r7
 8002d50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002d54:	4770      	bx	lr
 8002d56:	bf00      	nop

08002d58 <RAMPGEN_SetAngleOffset>:

static inline void RAMPGEN_SetAngleOffset(RAMPGEN_Handle handle, const float_t offset)//! \Mod By Dl.K
{
 8002d58:	b480      	push	{r7}
 8002d5a:	b085      	sub	sp, #20
 8002d5c:	af00      	add	r7, sp, #0
 8002d5e:	6078      	str	r0, [r7, #4]
 8002d60:	ed87 0a00 	vstr	s0, [r7]
	RAMPGEN_Obj *obj = (RAMPGEN_Obj *)handle;
 8002d64:	687b      	ldr	r3, [r7, #4]
 8002d66:	60fb      	str	r3, [r7, #12]

	obj->Offset = offset;
 8002d68:	68fb      	ldr	r3, [r7, #12]
 8002d6a:	683a      	ldr	r2, [r7, #0]
 8002d6c:	615a      	str	r2, [r3, #20]

	return;
 8002d6e:	bf00      	nop
}
 8002d70:	3714      	adds	r7, #20
 8002d72:	46bd      	mov	sp, r7
 8002d74:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002d78:	4770      	bx	lr
 8002d7a:	bf00      	nop

08002d7c <RAMPGEN_Run>:

static inline void RAMPGEN_Run(RAMPGEN_Handle handle)//! \Mod By Dl.K
{
 8002d7c:	b480      	push	{r7}
 8002d7e:	b085      	sub	sp, #20
 8002d80:	af00      	add	r7, sp, #0
 8002d82:	6078      	str	r0, [r7, #4]
	RAMPGEN_Obj *obj = (RAMPGEN_Obj *)handle;
 8002d84:	687b      	ldr	r3, [r7, #4]
 8002d86:	60fb      	str	r3, [r7, #12]

	// Compute the angle rate
	obj->Angle += (obj->StepAngleMax * obj->Freq);
 8002d88:	68fb      	ldr	r3, [r7, #12]
 8002d8a:	ed93 7a02 	vldr	s14, [r3, #8]
 8002d8e:	68fb      	ldr	r3, [r7, #12]
 8002d90:	edd3 6a01 	vldr	s13, [r3, #4]
 8002d94:	68fb      	ldr	r3, [r7, #12]
 8002d96:	edd3 7a00 	vldr	s15, [r3]
 8002d9a:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8002d9e:	ee77 7a27 	vadd.f32	s15, s14, s15
 8002da2:	68fb      	ldr	r3, [r7, #12]
 8002da4:	edc3 7a02 	vstr	s15, [r3, #8]

	// Saturate the angle rate within (-1,1)        
	if (obj->Angle>(1.0f))
 8002da8:	68fb      	ldr	r3, [r7, #12]
 8002daa:	edd3 7a02 	vldr	s15, [r3, #8]
 8002dae:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8002db2:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002db6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002dba:	dd0a      	ble.n	8002dd2 <RAMPGEN_Run+0x56>
		obj->Angle -= (1.0f);
 8002dbc:	68fb      	ldr	r3, [r7, #12]
 8002dbe:	edd3 7a02 	vldr	s15, [r3, #8]
 8002dc2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8002dc6:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8002dca:	68fb      	ldr	r3, [r7, #12]
 8002dcc:	edc3 7a02 	vstr	s15, [r3, #8]
 8002dd0:	e013      	b.n	8002dfa <RAMPGEN_Run+0x7e>
	else if (obj->Angle<(-1.0f))
 8002dd2:	68fb      	ldr	r3, [r7, #12]
 8002dd4:	edd3 7a02 	vldr	s15, [r3, #8]
 8002dd8:	eebf 7a00 	vmov.f32	s14, #240	; 0xf0
 8002ddc:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002de0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002de4:	d509      	bpl.n	8002dfa <RAMPGEN_Run+0x7e>
		obj->Angle += (1.0f);
 8002de6:	68fb      	ldr	r3, [r7, #12]
 8002de8:	edd3 7a02 	vldr	s15, [r3, #8]
 8002dec:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8002df0:	ee77 7a87 	vadd.f32	s15, s15, s14
 8002df4:	68fb      	ldr	r3, [r7, #12]
 8002df6:	edc3 7a02 	vstr	s15, [r3, #8]

	// Compute the ramp output
	obj->Out = (obj->Angle * obj->Gain) + obj->Offset;
 8002dfa:	68fb      	ldr	r3, [r7, #12]
 8002dfc:	ed93 7a02 	vldr	s14, [r3, #8]
 8002e00:	68fb      	ldr	r3, [r7, #12]
 8002e02:	edd3 7a03 	vldr	s15, [r3, #12]
 8002e06:	ee27 7a27 	vmul.f32	s14, s14, s15
 8002e0a:	68fb      	ldr	r3, [r7, #12]
 8002e0c:	edd3 7a05 	vldr	s15, [r3, #20]
 8002e10:	ee77 7a27 	vadd.f32	s15, s14, s15
 8002e14:	68fb      	ldr	r3, [r7, #12]
 8002e16:	edc3 7a04 	vstr	s15, [r3, #16]

	// Saturate the ramp output within (-1,1)     
	if (obj->Out>(1.0f))
 8002e1a:	68fb      	ldr	r3, [r7, #12]
 8002e1c:	edd3 7a04 	vldr	s15, [r3, #16]
 8002e20:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8002e24:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002e28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002e2c:	dd0a      	ble.n	8002e44 <RAMPGEN_Run+0xc8>
		obj->Out -= (1.0f);
 8002e2e:	68fb      	ldr	r3, [r7, #12]
 8002e30:	edd3 7a04 	vldr	s15, [r3, #16]
 8002e34:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8002e38:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8002e3c:	68fb      	ldr	r3, [r7, #12]
 8002e3e:	edc3 7a04 	vstr	s15, [r3, #16]
 8002e42:	e014      	b.n	8002e6e <RAMPGEN_Run+0xf2>
	else if (obj->Out<(-1.0f))
 8002e44:	68fb      	ldr	r3, [r7, #12]
 8002e46:	edd3 7a04 	vldr	s15, [r3, #16]
 8002e4a:	eebf 7a00 	vmov.f32	s14, #240	; 0xf0
 8002e4e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002e52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002e56:	d400      	bmi.n	8002e5a <RAMPGEN_Run+0xde>
		obj->Out += (1.0f);

	return;
 8002e58:	e00a      	b.n	8002e70 <RAMPGEN_Run+0xf4>

	// Saturate the ramp output within (-1,1)     
	if (obj->Out>(1.0f))
		obj->Out -= (1.0f);
	else if (obj->Out<(-1.0f))
		obj->Out += (1.0f);
 8002e5a:	68fb      	ldr	r3, [r7, #12]
 8002e5c:	edd3 7a04 	vldr	s15, [r3, #16]
 8002e60:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8002e64:	ee77 7a87 	vadd.f32	s15, s15, s14
 8002e68:	68fb      	ldr	r3, [r7, #12]
 8002e6a:	edc3 7a04 	vstr	s15, [r3, #16]

	return;
 8002e6e:	bf00      	nop
}
 8002e70:	3714      	adds	r7, #20
 8002e72:	46bd      	mov	sp, r7
 8002e74:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002e78:	4770      	bx	lr
 8002e7a:	bf00      	nop

08002e7c <INITPOSDET_GetInitPosAngle>:
// the functions

extern INITPOSDET_Handle INITPOSDET_Init(void *pMemory, const size_t numBytes);//! \Mod By Dl.K

static inline float_t INITPOSDET_GetInitPosAngle(INITPOSDET_Handle handle)//! \Mod By Dl.K
{
 8002e7c:	b480      	push	{r7}
 8002e7e:	b085      	sub	sp, #20
 8002e80:	af00      	add	r7, sp, #0
 8002e82:	6078      	str	r0, [r7, #4]
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
 8002e84:	687b      	ldr	r3, [r7, #4]
 8002e86:	60fb      	str	r3, [r7, #12]

	return (obj->InitPosAngle);
 8002e88:	68fb      	ldr	r3, [r7, #12]
 8002e8a:	685b      	ldr	r3, [r3, #4]
 8002e8c:	ee07 3a90 	vmov	s15, r3
}
 8002e90:	eeb0 0a67 	vmov.f32	s0, s15
 8002e94:	3714      	adds	r7, #20
 8002e96:	46bd      	mov	sp, r7
 8002e98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002e9c:	4770      	bx	lr
 8002e9e:	bf00      	nop

08002ea0 <INITPOSDET_GetVolVecAngleFlag>:

static inline uint16_t INITPOSDET_GetVolVecAngleFlag(INITPOSDET_Handle handle)//! \Mod By Dl.K
{
 8002ea0:	b480      	push	{r7}
 8002ea2:	b085      	sub	sp, #20
 8002ea4:	af00      	add	r7, sp, #0
 8002ea6:	6078      	str	r0, [r7, #4]
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
 8002ea8:	687b      	ldr	r3, [r7, #4]
 8002eaa:	60fb      	str	r3, [r7, #12]

	return (obj->VolVecAngleFlag);
 8002eac:	68fb      	ldr	r3, [r7, #12]
 8002eae:	899b      	ldrh	r3, [r3, #12]
}
 8002eb0:	4618      	mov	r0, r3
 8002eb2:	3714      	adds	r7, #20
 8002eb4:	46bd      	mov	sp, r7
 8002eb6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002eba:	4770      	bx	lr

08002ebc <INITPOSDET_GetVolVecAngle>:

static inline float_t INITPOSDET_GetVolVecAngle(INITPOSDET_Handle handle)//! \Mod By Dl.K
{
 8002ebc:	b480      	push	{r7}
 8002ebe:	b085      	sub	sp, #20
 8002ec0:	af00      	add	r7, sp, #0
 8002ec2:	6078      	str	r0, [r7, #4]
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
 8002ec4:	687b      	ldr	r3, [r7, #4]
 8002ec6:	60fb      	str	r3, [r7, #12]

	return (obj->VolVecAngle);
 8002ec8:	68fb      	ldr	r3, [r7, #12]
 8002eca:	691b      	ldr	r3, [r3, #16]
 8002ecc:	ee07 3a90 	vmov	s15, r3
}
 8002ed0:	eeb0 0a67 	vmov.f32	s0, s15
 8002ed4:	3714      	adds	r7, #20
 8002ed6:	46bd      	mov	sp, r7
 8002ed8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002edc:	4770      	bx	lr
 8002ede:	bf00      	nop

08002ee0 <INITPOSDET_GetIdSampAngle>:

static inline float_t INITPOSDET_GetIdSampAngle(INITPOSDET_Handle handle)//! \Mod By Dl.K
{
 8002ee0:	b480      	push	{r7}
 8002ee2:	b085      	sub	sp, #20
 8002ee4:	af00      	add	r7, sp, #0
 8002ee6:	6078      	str	r0, [r7, #4]
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
 8002ee8:	687b      	ldr	r3, [r7, #4]
 8002eea:	60fb      	str	r3, [r7, #12]

	return (obj->IdSampAngle);
 8002eec:	68fb      	ldr	r3, [r7, #12]
 8002eee:	69db      	ldr	r3, [r3, #28]
 8002ef0:	ee07 3a90 	vmov	s15, r3
}
 8002ef4:	eeb0 0a67 	vmov.f32	s0, s15
 8002ef8:	3714      	adds	r7, #20
 8002efa:	46bd      	mov	sp, r7
 8002efc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002f00:	4770      	bx	lr
 8002f02:	bf00      	nop

08002f04 <INITPOSDET_GetIdSampAngleFlag>:

static inline uint16_t INITPOSDET_GetIdSampAngleFlag(INITPOSDET_Handle handle)//! \Mod By Dl.K
{
 8002f04:	b480      	push	{r7}
 8002f06:	b085      	sub	sp, #20
 8002f08:	af00      	add	r7, sp, #0
 8002f0a:	6078      	str	r0, [r7, #4]
	INITPOSDET_Obj *obj = (INITPOSDET_Obj *)handle;
 8002f0c:	687b      	ldr	r3, [r7, #4]
 8002f0e:	60fb      	str	r3, [r7, #12]

	return (obj->IdSampAngleFlag);
 8002f10:	68fb      	ldr	r3, [r7, #12]
 8002f12:	8b5b      	ldrh	r3, [r3, #26]
}
 8002f14:	4618      	mov	r0, r3
 8002f16:	3714      	adds	r7, #20
 8002f18:	46bd      	mov	sp, r7
 8002f1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002f1e:	4770      	bx	lr

08002f20 <Speed_SetElecTheta>:
// the functions
extern SPEED_Handle Speed_Init(void *pMemory, const size_t numBytes);//! \Mod By Dl.K


static inline void Speed_SetElecTheta(SPEED_Handle handle, float_t theta)//! \Mod By Dl.K
{
 8002f20:	b480      	push	{r7}
 8002f22:	b085      	sub	sp, #20
 8002f24:	af00      	add	r7, sp, #0
 8002f26:	6078      	str	r0, [r7, #4]
 8002f28:	ed87 0a00 	vstr	s0, [r7]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
 8002f2c:	687b      	ldr	r3, [r7, #4]
 8002f2e:	60fb      	str	r3, [r7, #12]

	obj->ElecTheta = theta;
 8002f30:	68fb      	ldr	r3, [r7, #12]
 8002f32:	683a      	ldr	r2, [r7, #0]
 8002f34:	601a      	str	r2, [r3, #0]

	return;
 8002f36:	bf00      	nop
}
 8002f38:	3714      	adds	r7, #20
 8002f3a:	46bd      	mov	sp, r7
 8002f3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002f40:	4770      	bx	lr
 8002f42:	bf00      	nop

08002f44 <Speed_SetElecFilterSpeedRatio>:

static inline void Speed_SetElecFilterSpeedRatio(SPEED_Handle handle, float_t ratio)//! \Mod By Dl.K
{
 8002f44:	b480      	push	{r7}
 8002f46:	b085      	sub	sp, #20
 8002f48:	af00      	add	r7, sp, #0
 8002f4a:	6078      	str	r0, [r7, #4]
 8002f4c:	ed87 0a00 	vstr	s0, [r7]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
 8002f50:	687b      	ldr	r3, [r7, #4]
 8002f52:	60fb      	str	r3, [r7, #12]

	obj->ElecFilterSpeedRatio = ratio;
 8002f54:	68fb      	ldr	r3, [r7, #12]
 8002f56:	683a      	ldr	r2, [r7, #0]
 8002f58:	615a      	str	r2, [r3, #20]

	return;
 8002f5a:	bf00      	nop
}
 8002f5c:	3714      	adds	r7, #20
 8002f5e:	46bd      	mov	sp, r7
 8002f60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002f64:	4770      	bx	lr
 8002f66:	bf00      	nop

08002f68 <Speed_SetElecThetaChagTimeRatio>:

static inline void Speed_SetElecThetaChagTimeRatio(SPEED_Handle handle, float_t ratio)//! \Mod By Dl.K
{
 8002f68:	b480      	push	{r7}
 8002f6a:	b085      	sub	sp, #20
 8002f6c:	af00      	add	r7, sp, #0
 8002f6e:	6078      	str	r0, [r7, #4]
 8002f70:	ed87 0a00 	vstr	s0, [r7]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
 8002f74:	687b      	ldr	r3, [r7, #4]
 8002f76:	60fb      	str	r3, [r7, #12]

	obj->ElecThetaChagTimeRatio = ratio;
 8002f78:	68fb      	ldr	r3, [r7, #12]
 8002f7a:	683a      	ldr	r2, [r7, #0]
 8002f7c:	609a      	str	r2, [r3, #8]

	return;
 8002f7e:	bf00      	nop
}
 8002f80:	3714      	adds	r7, #20
 8002f82:	46bd      	mov	sp, r7
 8002f84:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002f88:	4770      	bx	lr
 8002f8a:	bf00      	nop

08002f8c <Speed_UpdateElecTheta>:

static inline void Speed_UpdateElecTheta(SPEED_Handle handle)//! \Mod By Dl.K
{
 8002f8c:	b480      	push	{r7}
 8002f8e:	b085      	sub	sp, #20
 8002f90:	af00      	add	r7, sp, #0
 8002f92:	6078      	str	r0, [r7, #4]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
 8002f94:	687b      	ldr	r3, [r7, #4]
 8002f96:	60fb      	str	r3, [r7, #12]

	obj->OldElecTheta = obj->ElecTheta;
 8002f98:	68fb      	ldr	r3, [r7, #12]
 8002f9a:	681a      	ldr	r2, [r3, #0]
 8002f9c:	68fb      	ldr	r3, [r7, #12]
 8002f9e:	605a      	str	r2, [r3, #4]

	return;
 8002fa0:	bf00      	nop
}
 8002fa2:	3714      	adds	r7, #20
 8002fa4:	46bd      	mov	sp, r7
 8002fa6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002faa:	4770      	bx	lr

08002fac <Speed_GetElecSpeed>:

	return;
}

static inline float_t Speed_GetElecSpeed(SPEED_Handle handle)//! \Mod By Dl.K
{
 8002fac:	b480      	push	{r7}
 8002fae:	b085      	sub	sp, #20
 8002fb0:	af00      	add	r7, sp, #0
 8002fb2:	6078      	str	r0, [r7, #4]
	SPEED_Obj *obj = (SPEED_Obj *)handle;
 8002fb4:	687b      	ldr	r3, [r7, #4]
 8002fb6:	60fb      	str	r3, [r7, #12]

	return( obj->ElecSpeed );
 8002fb8:	68fb      	ldr	r3, [r7, #12]
 8002fba:	68db      	ldr	r3, [r3, #12]
 8002fbc:	ee07 3a90 	vmov	s15, r3
}
 8002fc0:	eeb0 0a67 	vmov.f32	s0, s15
 8002fc4:	3714      	adds	r7, #20
 8002fc6:	46bd      	mov	sp, r7
 8002fc8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002fcc:	4770      	bx	lr
 8002fce:	bf00      	nop

08002fd0 <HAL_runOffsetEst>:
//!             speed performance of the motor drive.
//! \param[in]  handle    The hardware abstraction layer (HAL) handle
//! \param[in]  pAdcData  The pointer to the ADC data

static inline void HAL_runOffsetEst(HAL_Handle handle,const HAL_AdcData_t *pAdcData)
{
 8002fd0:	b580      	push	{r7, lr}
 8002fd2:	b084      	sub	sp, #16
 8002fd4:	af00      	add	r7, sp, #0
 8002fd6:	6078      	str	r0, [r7, #4]
 8002fd8:	6039      	str	r1, [r7, #0]
  	unsigned char cnt;
  	HAL_Obj *obj = (HAL_Obj *)handle;
 8002fda:	687b      	ldr	r3, [r7, #4]
 8002fdc:	60bb      	str	r3, [r7, #8]


  // estimate the current offsets
  	for(cnt=0;cnt<obj->numCurrentSensors;cnt++)
 8002fde:	2300      	movs	r3, #0
 8002fe0:	73fb      	strb	r3, [r7, #15]
 8002fe2:	e011      	b.n	8003008 <HAL_runOffsetEst+0x38>
    {
      	OFFSET_run(obj->offsetHandle_I[cnt],pAdcData->I.value[cnt]);
 8002fe4:	7bfa      	ldrb	r2, [r7, #15]
 8002fe6:	68bb      	ldr	r3, [r7, #8]
 8002fe8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8002fec:	7bfb      	ldrb	r3, [r7, #15]
 8002fee:	683a      	ldr	r2, [r7, #0]
 8002ff0:	009b      	lsls	r3, r3, #2
 8002ff2:	4413      	add	r3, r2
 8002ff4:	edd3 7a00 	vldr	s15, [r3]
 8002ff8:	4608      	mov	r0, r1
 8002ffa:	eeb0 0a67 	vmov.f32	s0, s15
 8002ffe:	f7ff fb75 	bl	80026ec <OFFSET_run>
  	unsigned char cnt;
  	HAL_Obj *obj = (HAL_Obj *)handle;


  // estimate the current offsets
  	for(cnt=0;cnt<obj->numCurrentSensors;cnt++)
 8003002:	7bfb      	ldrb	r3, [r7, #15]
 8003004:	3301      	adds	r3, #1
 8003006:	73fb      	strb	r3, [r7, #15]
 8003008:	68bb      	ldr	r3, [r7, #8]
 800300a:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
 800300e:	7bfa      	ldrb	r2, [r7, #15]
 8003010:	429a      	cmp	r2, r3
 8003012:	d3e7      	bcc.n	8002fe4 <HAL_runOffsetEst+0x14>
      	OFFSET_run(obj->offsetHandle_I[cnt],pAdcData->I.value[cnt]);
    }


  // estimate the voltage offsets
  	for(cnt=0;cnt<obj->numVoltageSensors;cnt++)
 8003014:	2300      	movs	r3, #0
 8003016:	73fb      	strb	r3, [r7, #15]
 8003018:	e014      	b.n	8003044 <HAL_runOffsetEst+0x74>
    {
    	OFFSET_run(obj->offsetHandle_V[cnt],pAdcData->V.value[cnt]);
 800301a:	7bfb      	ldrb	r3, [r7, #15]
 800301c:	68ba      	ldr	r2, [r7, #8]
 800301e:	331a      	adds	r3, #26
 8003020:	009b      	lsls	r3, r3, #2
 8003022:	4413      	add	r3, r2
 8003024:	6859      	ldr	r1, [r3, #4]
 8003026:	7bfb      	ldrb	r3, [r7, #15]
 8003028:	683a      	ldr	r2, [r7, #0]
 800302a:	3302      	adds	r3, #2
 800302c:	009b      	lsls	r3, r3, #2
 800302e:	4413      	add	r3, r2
 8003030:	edd3 7a01 	vldr	s15, [r3, #4]
 8003034:	4608      	mov	r0, r1
 8003036:	eeb0 0a67 	vmov.f32	s0, s15
 800303a:	f7ff fb57 	bl	80026ec <OFFSET_run>
      	OFFSET_run(obj->offsetHandle_I[cnt],pAdcData->I.value[cnt]);
    }


  // estimate the voltage offsets
  	for(cnt=0;cnt<obj->numVoltageSensors;cnt++)
 800303e:	7bfb      	ldrb	r3, [r7, #15]
 8003040:	3301      	adds	r3, #1
 8003042:	73fb      	strb	r3, [r7, #15]
 8003044:	68bb      	ldr	r3, [r7, #8]
 8003046:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 800304a:	7bfa      	ldrb	r2, [r7, #15]
 800304c:	429a      	cmp	r2, r3
 800304e:	d3e4      	bcc.n	800301a <HAL_runOffsetEst+0x4a>
    {
    	OFFSET_run(obj->offsetHandle_V[cnt],pAdcData->V.value[cnt]);
    }

  	return;
 8003050:	bf00      	nop
} // end of HAL_runOffsetEst() function
 8003052:	3710      	adds	r7, #16
 8003054:	46bd      	mov	sp, r7
 8003056:	bd80      	pop	{r7, pc}

08003058 <CTRL_getCount_isr>:

//! \brief      Gets the isr count
//! \param[in]  handle  The controller (CTRL) handle
//! \return    The isr count
static inline uint_least16_t CTRL_getCount_isr(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003058:	b480      	push	{r7}
 800305a:	b085      	sub	sp, #20
 800305c:	af00      	add	r7, sp, #0
 800305e:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003060:	687b      	ldr	r3, [r7, #4]
 8003062:	60fb      	str	r3, [r7, #12]

  return(obj->counter_isr);
 8003064:	68fb      	ldr	r3, [r7, #12]
 8003066:	f8b3 31ee 	ldrh.w	r3, [r3, #494]	; 0x1ee
} // end of CTRL_getCount_isr() function
 800306a:	4618      	mov	r0, r3
 800306c:	3714      	adds	r7, #20
 800306e:	46bd      	mov	sp, r7
 8003070:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003074:	4770      	bx	lr
 8003076:	bf00      	nop

08003078 <CTRL_getFlag_enableCurrentCtrl>:

//! \brief     Gets the enable current controllers flag value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The enable current controller flag value
static inline bool CTRL_getFlag_enableCurrentCtrl(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003078:	b480      	push	{r7}
 800307a:	b085      	sub	sp, #20
 800307c:	af00      	add	r7, sp, #0
 800307e:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003080:	687b      	ldr	r3, [r7, #4]
 8003082:	60fb      	str	r3, [r7, #12]

  return(obj->flag_enableCurrentCtrl);
 8003084:	68fb      	ldr	r3, [r7, #12]
 8003086:	f893 3220 	ldrb.w	r3, [r3, #544]	; 0x220
} // end of CTRL_getFlag_enableCurrentCtrl() function
 800308a:	4618      	mov	r0, r3
 800308c:	3714      	adds	r7, #20
 800308e:	46bd      	mov	sp, r7
 8003090:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003094:	4770      	bx	lr
 8003096:	bf00      	nop

08003098 <CTRL_getFlag_enableSpeedCtrl>:

//! \brief     Gets the enable speed control flag value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The enable speed control flag value
static inline bool CTRL_getFlag_enableSpeedCtrl(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003098:	b480      	push	{r7}
 800309a:	b085      	sub	sp, #20
 800309c:	af00      	add	r7, sp, #0
 800309e:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80030a0:	687b      	ldr	r3, [r7, #4]
 80030a2:	60fb      	str	r3, [r7, #12]

  return(obj->flag_enableSpeedCtrl);
 80030a4:	68fb      	ldr	r3, [r7, #12]
 80030a6:	f893 31f8 	ldrb.w	r3, [r3, #504]	; 0x1f8
} // end of CTRL_getFlag_enableSpeedCtrl() function
 80030aa:	4618      	mov	r0, r3
 80030ac:	3714      	adds	r7, #20
 80030ae:	46bd      	mov	sp, r7
 80030b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80030b4:	4770      	bx	lr
 80030b6:	bf00      	nop

080030b8 <CTRL_getIab_in_addr>:

//! \brief     Gets the alpha/beta current input vector memory address from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The alpha/beta current input vector memory address
static inline MATH_vec2 *CTRL_getIab_in_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
 80030b8:	b480      	push	{r7}
 80030ba:	b085      	sub	sp, #20
 80030bc:	af00      	add	r7, sp, #0
 80030be:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80030c0:	687b      	ldr	r3, [r7, #4]
 80030c2:	60fb      	str	r3, [r7, #12]

  return(&(obj->Iab_in));
 80030c4:	68fb      	ldr	r3, [r7, #12]
 80030c6:	f503 73b4 	add.w	r3, r3, #360	; 0x168
} // end of CTRL_getIab_in_addr() function
 80030ca:	4618      	mov	r0, r3
 80030cc:	3714      	adds	r7, #20
 80030ce:	46bd      	mov	sp, r7
 80030d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80030d4:	4770      	bx	lr
 80030d6:	bf00      	nop

080030d8 <CTRL_getId_in_pu>:

//! \brief     Gets the direct current input value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The direct current input value, pu
static inline float_t CTRL_getId_in_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
 80030d8:	b480      	push	{r7}
 80030da:	b085      	sub	sp, #20
 80030dc:	af00      	add	r7, sp, #0
 80030de:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80030e0:	687b      	ldr	r3, [r7, #4]
 80030e2:	60fb      	str	r3, [r7, #12]

  return(obj->Idq_in.value[0]);
 80030e4:	68fb      	ldr	r3, [r7, #12]
 80030e6:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 80030ea:	ee07 3a90 	vmov	s15, r3
} // end of CTRL_getId_in_pu() function
 80030ee:	eeb0 0a67 	vmov.f32	s0, s15
 80030f2:	3714      	adds	r7, #20
 80030f4:	46bd      	mov	sp, r7
 80030f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80030fa:	4770      	bx	lr

080030fc <CTRL_getId_ref_pu>:

//! \brief     Gets the direct current (Id) reference value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The direct current reference value, pu
static inline float_t CTRL_getId_ref_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
 80030fc:	b480      	push	{r7}
 80030fe:	b085      	sub	sp, #20
 8003100:	af00      	add	r7, sp, #0
 8003102:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003104:	687b      	ldr	r3, [r7, #4]
 8003106:	60fb      	str	r3, [r7, #12]

  return(obj->Idq_ref.value[0]);
 8003108:	68fb      	ldr	r3, [r7, #12]
 800310a:	f8d3 31d8 	ldr.w	r3, [r3, #472]	; 0x1d8
 800310e:	ee07 3a90 	vmov	s15, r3
} // end of CTRL_getId_ref_pu() function
 8003112:	eeb0 0a67 	vmov.f32	s0, s15
 8003116:	3714      	adds	r7, #20
 8003118:	46bd      	mov	sp, r7
 800311a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800311e:	4770      	bx	lr

08003120 <CTRL_getIdq_in_addr>:

//! \brief     Gets the direct/quadrature current input vector memory address from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The direct/quadrature current input vector memory address
static inline MATH_vec2 *CTRL_getIdq_in_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003120:	b480      	push	{r7}
 8003122:	b085      	sub	sp, #20
 8003124:	af00      	add	r7, sp, #0
 8003126:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003128:	687b      	ldr	r3, [r7, #4]
 800312a:	60fb      	str	r3, [r7, #12]

  return(&(obj->Idq_in));
 800312c:	68fb      	ldr	r3, [r7, #12]
 800312e:	f503 73bc 	add.w	r3, r3, #376	; 0x178
} // end of CTRL_getIdq_in_addr() function
 8003132:	4618      	mov	r0, r3
 8003134:	3714      	adds	r7, #20
 8003136:	46bd      	mov	sp, r7
 8003138:	f85d 7b04 	ldr.w	r7, [sp], #4
 800313c:	4770      	bx	lr
 800313e:	bf00      	nop

08003140 <CTRL_getIq_in_pu>:

//! \brief     Gets the quadrature current input value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The quadrature current input value, pu
static inline float_t CTRL_getIq_in_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003140:	b480      	push	{r7}
 8003142:	b085      	sub	sp, #20
 8003144:	af00      	add	r7, sp, #0
 8003146:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003148:	687b      	ldr	r3, [r7, #4]
 800314a:	60fb      	str	r3, [r7, #12]

  return(obj->Idq_in.value[1]);
 800314c:	68fb      	ldr	r3, [r7, #12]
 800314e:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
 8003152:	ee07 3a90 	vmov	s15, r3
} // end of CTRL_getIq_in_pu() function
 8003156:	eeb0 0a67 	vmov.f32	s0, s15
 800315a:	3714      	adds	r7, #20
 800315c:	46bd      	mov	sp, r7
 800315e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003162:	4770      	bx	lr

08003164 <CTRL_getIq_ref_pu>:

//! \brief     Gets the quadrature current (Iq) reference value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The quadrature current reference value, pu
static inline float_t CTRL_getIq_ref_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003164:	b480      	push	{r7}
 8003166:	b085      	sub	sp, #20
 8003168:	af00      	add	r7, sp, #0
 800316a:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 800316c:	687b      	ldr	r3, [r7, #4]
 800316e:	60fb      	str	r3, [r7, #12]

  return(obj->Idq_ref.value[1]);
 8003170:	68fb      	ldr	r3, [r7, #12]
 8003172:	f8d3 31dc 	ldr.w	r3, [r3, #476]	; 0x1dc
 8003176:	ee07 3a90 	vmov	s15, r3
} // end of CTRL_getIq_ref_pu() function
 800317a:	eeb0 0a67 	vmov.f32	s0, s15
 800317e:	3714      	adds	r7, #20
 8003180:	46bd      	mov	sp, r7
 8003182:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003186:	4770      	bx	lr

08003188 <CTRL_getKi>:
//! \brief     Gets the integral gain (Ki) value from the specified controller
//! \param[in] handle    The controller (CTRL) handle
//! \param[in] ctrlType  The controller type
//! \return    The Ki value
static inline float_t CTRL_getKi(CTRL_Handle handle,const CTRL_Type_e ctrlType)//! \Mod By Dl.K
{
 8003188:	b480      	push	{r7}
 800318a:	b085      	sub	sp, #20
 800318c:	af00      	add	r7, sp, #0
 800318e:	6078      	str	r0, [r7, #4]
 8003190:	460b      	mov	r3, r1
 8003192:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003194:	687b      	ldr	r3, [r7, #4]
 8003196:	60bb      	str	r3, [r7, #8]
  float_t Ki = (0.0f);
 8003198:	f04f 0300 	mov.w	r3, #0
 800319c:	60fb      	str	r3, [r7, #12]

  if(ctrlType == CTRL_Type_PID_spd)
 800319e:	78fb      	ldrb	r3, [r7, #3]
 80031a0:	2b00      	cmp	r3, #0
 80031a2:	d104      	bne.n	80031ae <CTRL_getKi+0x26>
    {
      Ki = obj->Ki_spd;
 80031a4:	68bb      	ldr	r3, [r7, #8]
 80031a6:	f8d3 31bc 	ldr.w	r3, [r3, #444]	; 0x1bc
 80031aa:	60fb      	str	r3, [r7, #12]
 80031ac:	e00e      	b.n	80031cc <CTRL_getKi+0x44>
    }
  else if(ctrlType == CTRL_Type_PID_Id)
 80031ae:	78fb      	ldrb	r3, [r7, #3]
 80031b0:	2b01      	cmp	r3, #1
 80031b2:	d104      	bne.n	80031be <CTRL_getKi+0x36>
    {
      Ki = obj->Ki_Id;
 80031b4:	68bb      	ldr	r3, [r7, #8]
 80031b6:	f8d3 31b4 	ldr.w	r3, [r3, #436]	; 0x1b4
 80031ba:	60fb      	str	r3, [r7, #12]
 80031bc:	e006      	b.n	80031cc <CTRL_getKi+0x44>
    }
  else if(ctrlType == CTRL_Type_PID_Iq)
 80031be:	78fb      	ldrb	r3, [r7, #3]
 80031c0:	2b02      	cmp	r3, #2
 80031c2:	d103      	bne.n	80031cc <CTRL_getKi+0x44>
    {
      Ki = obj->Ki_Iq;
 80031c4:	68bb      	ldr	r3, [r7, #8]
 80031c6:	f8d3 31b8 	ldr.w	r3, [r3, #440]	; 0x1b8
 80031ca:	60fb      	str	r3, [r7, #12]
    }

  return(Ki);
 80031cc:	68fb      	ldr	r3, [r7, #12]
 80031ce:	ee07 3a90 	vmov	s15, r3
} // end of CTRL_getKi() function
 80031d2:	eeb0 0a67 	vmov.f32	s0, s15
 80031d6:	3714      	adds	r7, #20
 80031d8:	46bd      	mov	sp, r7
 80031da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80031de:	4770      	bx	lr

080031e0 <CTRL_getKp>:
//! \brief     Gets the proportional gain (Kp) value from the specified controller
//! \param[in] handle    The controller (CTRL) handle
//! \param[in] ctrlType  The controller type
//! \return    The Kp value
static inline float_t CTRL_getKp(CTRL_Handle handle,const CTRL_Type_e ctrlType)//! \Mod By Dl.K
{
 80031e0:	b480      	push	{r7}
 80031e2:	b085      	sub	sp, #20
 80031e4:	af00      	add	r7, sp, #0
 80031e6:	6078      	str	r0, [r7, #4]
 80031e8:	460b      	mov	r3, r1
 80031ea:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80031ec:	687b      	ldr	r3, [r7, #4]
 80031ee:	60bb      	str	r3, [r7, #8]
  float_t Kp = (0.0f);
 80031f0:	f04f 0300 	mov.w	r3, #0
 80031f4:	60fb      	str	r3, [r7, #12]

  if(ctrlType == CTRL_Type_PID_spd)
 80031f6:	78fb      	ldrb	r3, [r7, #3]
 80031f8:	2b00      	cmp	r3, #0
 80031fa:	d104      	bne.n	8003206 <CTRL_getKp+0x26>
    {
      Kp = obj->Kp_spd;
 80031fc:	68bb      	ldr	r3, [r7, #8]
 80031fe:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 8003202:	60fb      	str	r3, [r7, #12]
 8003204:	e00e      	b.n	8003224 <CTRL_getKp+0x44>
    }
  else if(ctrlType == CTRL_Type_PID_Id)
 8003206:	78fb      	ldrb	r3, [r7, #3]
 8003208:	2b01      	cmp	r3, #1
 800320a:	d104      	bne.n	8003216 <CTRL_getKp+0x36>
    {
      Kp = obj->Kp_Id;
 800320c:	68bb      	ldr	r3, [r7, #8]
 800320e:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8003212:	60fb      	str	r3, [r7, #12]
 8003214:	e006      	b.n	8003224 <CTRL_getKp+0x44>
    }
  else if(ctrlType == CTRL_Type_PID_Iq)
 8003216:	78fb      	ldrb	r3, [r7, #3]
 8003218:	2b02      	cmp	r3, #2
 800321a:	d103      	bne.n	8003224 <CTRL_getKp+0x44>
    {
      Kp = obj->Kp_Iq;
 800321c:	68bb      	ldr	r3, [r7, #8]
 800321e:	f8d3 31ac 	ldr.w	r3, [r3, #428]	; 0x1ac
 8003222:	60fb      	str	r3, [r7, #12]
    }

  return(Kp);
 8003224:	68fb      	ldr	r3, [r7, #12]
 8003226:	ee07 3a90 	vmov	s15, r3
} // end of CTRL_getKp() function
 800322a:	eeb0 0a67 	vmov.f32	s0, s15
 800322e:	3714      	adds	r7, #20
 8003230:	46bd      	mov	sp, r7
 8003232:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003236:	4770      	bx	lr

08003238 <CTRL_getNumIsrTicksPerCtrlTick>:

//! \brief     Gets the number of Interrupt Service Routine (ISR) clock ticks per controller clock tick
//! \param[in] handle  The controller (CTRL) handle
//! \return    The number of Interrupt Service Routine (ISR) clock ticks per controller clock tick
static inline uint_least16_t CTRL_getNumIsrTicksPerCtrlTick(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003238:	b480      	push	{r7}
 800323a:	b085      	sub	sp, #20
 800323c:	af00      	add	r7, sp, #0
 800323e:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003240:	687b      	ldr	r3, [r7, #4]
 8003242:	60fb      	str	r3, [r7, #12]
  
  return(obj->numIsrTicksPerCtrlTick);
 8003244:	68fb      	ldr	r3, [r7, #12]
 8003246:	f8b3 314c 	ldrh.w	r3, [r3, #332]	; 0x14c
} // end of CTRL_getNumIsrTicksPerCtrlTick() function
 800324a:	4618      	mov	r0, r3
 800324c:	3714      	adds	r7, #20
 800324e:	46bd      	mov	sp, r7
 8003250:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003254:	4770      	bx	lr
 8003256:	bf00      	nop

08003258 <CTRL_getSpd_out_addr>:

//! \brief     Gets the output speed memory address from the controller
//! \param[in] handle    The controller (CTRL) handle
//! \return    The output speed memory address
static inline float_t *CTRL_getSpd_out_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003258:	b480      	push	{r7}
 800325a:	b085      	sub	sp, #20
 800325c:	af00      	add	r7, sp, #0
 800325e:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003260:	687b      	ldr	r3, [r7, #4]
 8003262:	60fb      	str	r3, [r7, #12]

  return(&(obj->spd_out));
 8003264:	68fb      	ldr	r3, [r7, #12]
 8003266:	f503 73c4 	add.w	r3, r3, #392	; 0x188
} // end of CTRL_getSpd_out_addr() function
 800326a:	4618      	mov	r0, r3
 800326c:	3714      	adds	r7, #20
 800326e:	46bd      	mov	sp, r7
 8003270:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003274:	4770      	bx	lr
 8003276:	bf00      	nop

08003278 <CTRL_getSpd_out_pu>:

//! \brief     Gets the output speed value from the controller
//! \param[in] handle    The controller (CTRL) handle
//! \return    The output speed value, pu
static inline float_t CTRL_getSpd_out_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003278:	b480      	push	{r7}
 800327a:	b085      	sub	sp, #20
 800327c:	af00      	add	r7, sp, #0
 800327e:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003280:	687b      	ldr	r3, [r7, #4]
 8003282:	60fb      	str	r3, [r7, #12]

  return(obj->spd_out);
 8003284:	68fb      	ldr	r3, [r7, #12]
 8003286:	f8d3 3188 	ldr.w	r3, [r3, #392]	; 0x188
 800328a:	ee07 3a90 	vmov	s15, r3
} // end of CTRL_getSpd_out_pu() function
 800328e:	eeb0 0a67 	vmov.f32	s0, s15
 8003292:	3714      	adds	r7, #20
 8003294:	46bd      	mov	sp, r7
 8003296:	f85d 7b04 	ldr.w	r7, [sp], #4
 800329a:	4770      	bx	lr

0800329c <CTRL_getSpd_ref_pu>:

//! \brief     Gets the output speed reference value from the controller
//! \param[in] handle    The controller (CTRL) handle
//! \return    The output speed reference value, pu
static inline float_t CTRL_getSpd_ref_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
 800329c:	b480      	push	{r7}
 800329e:	b085      	sub	sp, #20
 80032a0:	af00      	add	r7, sp, #0
 80032a2:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80032a4:	687b      	ldr	r3, [r7, #4]
 80032a6:	60fb      	str	r3, [r7, #12]

  return(obj->spd_ref);
 80032a8:	68fb      	ldr	r3, [r7, #12]
 80032aa:	f8d3 31e4 	ldr.w	r3, [r3, #484]	; 0x1e4
 80032ae:	ee07 3a90 	vmov	s15, r3
} // end of CTRL_getSpd_ref_pu() function
 80032b2:	eeb0 0a67 	vmov.f32	s0, s15
 80032b6:	3714      	adds	r7, #20
 80032b8:	46bd      	mov	sp, r7
 80032ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80032be:	4770      	bx	lr

080032c0 <CTRL_getState>:

//! \brief     Gets the controller state
//! \param[in] handle  The controller (CTRL) handle
//! \return    The controller state
static inline CTRL_State_e CTRL_getState(CTRL_Handle handle)//! \Mod By Dl.K
{
 80032c0:	b480      	push	{r7}
 80032c2:	b085      	sub	sp, #20
 80032c4:	af00      	add	r7, sp, #0
 80032c6:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80032c8:	687b      	ldr	r3, [r7, #4]
 80032ca:	60fb      	str	r3, [r7, #12]

  return(obj->state);
 80032cc:	68fb      	ldr	r3, [r7, #12]
 80032ce:	7a1b      	ldrb	r3, [r3, #8]
} // end of CTRL_getState() function
 80032d0:	4618      	mov	r0, r3
 80032d2:	3714      	adds	r7, #20
 80032d4:	46bd      	mov	sp, r7
 80032d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80032da:	4770      	bx	lr

080032dc <CTRL_getVab_out_addr>:

//! \brief     Gets the alpha/beta voltage output vector memory address from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The alpha/beta voltage output vector memory address
static inline MATH_vec2 *CTRL_getVab_out_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
 80032dc:	b480      	push	{r7}
 80032de:	b085      	sub	sp, #20
 80032e0:	af00      	add	r7, sp, #0
 80032e2:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80032e4:	687b      	ldr	r3, [r7, #4]
 80032e6:	60fb      	str	r3, [r7, #12]

  return(&(obj->Vab_out));
 80032e8:	68fb      	ldr	r3, [r7, #12]
 80032ea:	f503 73c6 	add.w	r3, r3, #396	; 0x18c
} // end of CTRL_getVab_out_addr() function
 80032ee:	4618      	mov	r0, r3
 80032f0:	3714      	adds	r7, #20
 80032f2:	46bd      	mov	sp, r7
 80032f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80032f8:	4770      	bx	lr
 80032fa:	bf00      	nop

080032fc <CTRL_getVd_out_addr>:

//! \brief     Gets the direct voltage output value memory address from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The direct voltage output value memory address
static inline float_t *CTRL_getVd_out_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
 80032fc:	b480      	push	{r7}
 80032fe:	b085      	sub	sp, #20
 8003300:	af00      	add	r7, sp, #0
 8003302:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003304:	687b      	ldr	r3, [r7, #4]
 8003306:	60fb      	str	r3, [r7, #12]

  return(&(obj->Vdq_out.value[0]));
 8003308:	68fb      	ldr	r3, [r7, #12]
 800330a:	f503 73ca 	add.w	r3, r3, #404	; 0x194
} // end of CTRL_getVd_out_addr() function
 800330e:	4618      	mov	r0, r3
 8003310:	3714      	adds	r7, #20
 8003312:	46bd      	mov	sp, r7
 8003314:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003318:	4770      	bx	lr
 800331a:	bf00      	nop

0800331c <CTRL_getVdq_out_addr>:

//! \brief     Gets the direct/quadrature voltage output vector memory address from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The direct/quadrature voltage output vector memory address
static inline MATH_vec2 *CTRL_getVdq_out_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
 800331c:	b480      	push	{r7}
 800331e:	b085      	sub	sp, #20
 8003320:	af00      	add	r7, sp, #0
 8003322:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003324:	687b      	ldr	r3, [r7, #4]
 8003326:	60fb      	str	r3, [r7, #12]

  return(&(obj->Vdq_out));
 8003328:	68fb      	ldr	r3, [r7, #12]
 800332a:	f503 73ca 	add.w	r3, r3, #404	; 0x194
} // end of CTRL_getVdq_out_pu() function
 800332e:	4618      	mov	r0, r3
 8003330:	3714      	adds	r7, #20
 8003332:	46bd      	mov	sp, r7
 8003334:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003338:	4770      	bx	lr
 800333a:	bf00      	nop

0800333c <CTRL_getVq_out_addr>:

//! \brief     Gets the quadrature voltage output value memory address from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The quadrature voltage output value memory address
static inline float_t *CTRL_getVq_out_addr(CTRL_Handle handle)//! \Mod By Dl.K
{
 800333c:	b480      	push	{r7}
 800333e:	b085      	sub	sp, #20
 8003340:	af00      	add	r7, sp, #0
 8003342:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003344:	687b      	ldr	r3, [r7, #4]
 8003346:	60fb      	str	r3, [r7, #12]

  return(&(obj->Vdq_out.value[1]));
 8003348:	68fb      	ldr	r3, [r7, #12]
 800334a:	f503 73cc 	add.w	r3, r3, #408	; 0x198
} // end of CTRL_getVq_out_addr() function
 800334e:	4618      	mov	r0, r3
 8003350:	3714      	adds	r7, #20
 8003352:	46bd      	mov	sp, r7
 8003354:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003358:	4770      	bx	lr
 800335a:	bf00      	nop

0800335c <CTRL_getVq_out_pu>:

//! \brief     Gets the quadrature voltage output value from the controller
//! \param[in] handle  The controller (CTRL) handle
//! \return    The quadrature voltage output value, pu
static inline float_t CTRL_getVq_out_pu(CTRL_Handle handle)//! \Mod By Dl.K
{
 800335c:	b480      	push	{r7}
 800335e:	b085      	sub	sp, #20
 8003360:	af00      	add	r7, sp, #0
 8003362:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003364:	687b      	ldr	r3, [r7, #4]
 8003366:	60fb      	str	r3, [r7, #12]

  return(obj->Vdq_out.value[1]);
 8003368:	68fb      	ldr	r3, [r7, #12]
 800336a:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 800336e:	ee07 3a90 	vmov	s15, r3
} // end of CTRL_getVq_out_pu() function
 8003372:	eeb0 0a67 	vmov.f32	s0, s15
 8003376:	3714      	adds	r7, #20
 8003378:	46bd      	mov	sp, r7
 800337a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800337e:	4770      	bx	lr

08003380 <CTRL_incrCounter_current>:


//! \brief     Increments the current counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_incrCounter_current(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003380:	b480      	push	{r7}
 8003382:	b085      	sub	sp, #20
 8003384:	af00      	add	r7, sp, #0
 8003386:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003388:	687b      	ldr	r3, [r7, #4]
 800338a:	60fb      	str	r3, [r7, #12]

  uint_least16_t count = obj->counter_current;
 800338c:	68fb      	ldr	r3, [r7, #12]
 800338e:	f8b3 31ec 	ldrh.w	r3, [r3, #492]	; 0x1ec
 8003392:	817b      	strh	r3, [r7, #10]

  // increment the count
  count++;
 8003394:	897b      	ldrh	r3, [r7, #10]
 8003396:	3301      	adds	r3, #1
 8003398:	817b      	strh	r3, [r7, #10]

  // save the count value
  obj->counter_current = count;
 800339a:	68fb      	ldr	r3, [r7, #12]
 800339c:	897a      	ldrh	r2, [r7, #10]
 800339e:	f8a3 21ec 	strh.w	r2, [r3, #492]	; 0x1ec

  return;
 80033a2:	bf00      	nop
} // end of CTRL_incrCounter_current() function
 80033a4:	3714      	adds	r7, #20
 80033a6:	46bd      	mov	sp, r7
 80033a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80033ac:	4770      	bx	lr
 80033ae:	bf00      	nop

080033b0 <CTRL_incrCounter_isr>:


//! \brief     Increments the isr counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_incrCounter_isr(CTRL_Handle handle)//! \Mod By Dl.K
{
 80033b0:	b480      	push	{r7}
 80033b2:	b085      	sub	sp, #20
 80033b4:	af00      	add	r7, sp, #0
 80033b6:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80033b8:	687b      	ldr	r3, [r7, #4]
 80033ba:	60fb      	str	r3, [r7, #12]

  uint_least16_t count = obj->counter_isr;
 80033bc:	68fb      	ldr	r3, [r7, #12]
 80033be:	f8b3 31ee 	ldrh.w	r3, [r3, #494]	; 0x1ee
 80033c2:	817b      	strh	r3, [r7, #10]

  // increment the count
  count++;
 80033c4:	897b      	ldrh	r3, [r7, #10]
 80033c6:	3301      	adds	r3, #1
 80033c8:	817b      	strh	r3, [r7, #10]

  // save the count value
  obj->counter_isr = count;
 80033ca:	68fb      	ldr	r3, [r7, #12]
 80033cc:	897a      	ldrh	r2, [r7, #10]
 80033ce:	f8a3 21ee 	strh.w	r2, [r3, #494]	; 0x1ee

  return;
 80033d2:	bf00      	nop
} // end of CTRL_incrCounter_isr() function
 80033d4:	3714      	adds	r7, #20
 80033d6:	46bd      	mov	sp, r7
 80033d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80033dc:	4770      	bx	lr
 80033de:	bf00      	nop

080033e0 <CTRL_incrCounter_speed>:


//! \brief     Increments the speed counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_incrCounter_speed(CTRL_Handle handle)//! \Mod By Dl.K
{
 80033e0:	b480      	push	{r7}
 80033e2:	b085      	sub	sp, #20
 80033e4:	af00      	add	r7, sp, #0
 80033e6:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80033e8:	687b      	ldr	r3, [r7, #4]
 80033ea:	60fb      	str	r3, [r7, #12]

  uint_least16_t count = obj->counter_speed;
 80033ec:	68fb      	ldr	r3, [r7, #12]
 80033ee:	f8b3 31f0 	ldrh.w	r3, [r3, #496]	; 0x1f0
 80033f2:	817b      	strh	r3, [r7, #10]

  // increment the count
  count++;
 80033f4:	897b      	ldrh	r3, [r7, #10]
 80033f6:	3301      	adds	r3, #1
 80033f8:	817b      	strh	r3, [r7, #10]

  // save the count value
  obj->counter_speed = count;
 80033fa:	68fb      	ldr	r3, [r7, #12]
 80033fc:	897a      	ldrh	r2, [r7, #10]
 80033fe:	f8a3 21f0 	strh.w	r2, [r3, #496]	; 0x1f0

  return;
 8003402:	bf00      	nop
} // end of CTRL_incrCounter_speed() function
 8003404:	3714      	adds	r7, #20
 8003406:	46bd      	mov	sp, r7
 8003408:	f85d 7b04 	ldr.w	r7, [sp], #4
 800340c:	4770      	bx	lr
 800340e:	bf00      	nop

08003410 <CTRL_incrCounter_traj>:


//! \brief     Increments the trajectory counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_incrCounter_traj(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003410:	b480      	push	{r7}
 8003412:	b085      	sub	sp, #20
 8003414:	af00      	add	r7, sp, #0
 8003416:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003418:	687b      	ldr	r3, [r7, #4]
 800341a:	60fb      	str	r3, [r7, #12]

  uint_least16_t count = obj->counter_traj;
 800341c:	68fb      	ldr	r3, [r7, #12]
 800341e:	f8b3 31f2 	ldrh.w	r3, [r3, #498]	; 0x1f2
 8003422:	817b      	strh	r3, [r7, #10]

  // increment the count
  count++;
 8003424:	897b      	ldrh	r3, [r7, #10]
 8003426:	3301      	adds	r3, #1
 8003428:	817b      	strh	r3, [r7, #10]

  // save the count value
  obj->counter_traj = count;
 800342a:	68fb      	ldr	r3, [r7, #12]
 800342c:	897a      	ldrh	r2, [r7, #10]
 800342e:	f8a3 21f2 	strh.w	r2, [r3, #498]	; 0x1f2

  return;
 8003432:	bf00      	nop
} // end of CTRL_incrCounter_traj() function
 8003434:	3714      	adds	r7, #20
 8003436:	46bd      	mov	sp, r7
 8003438:	f85d 7b04 	ldr.w	r7, [sp], #4
 800343c:	4770      	bx	lr
 800343e:	bf00      	nop

08003440 <CTRL_resetCounter_current>:


//! \brief     Resets the current counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_resetCounter_current(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003440:	b480      	push	{r7}
 8003442:	b085      	sub	sp, #20
 8003444:	af00      	add	r7, sp, #0
 8003446:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003448:	687b      	ldr	r3, [r7, #4]
 800344a:	60fb      	str	r3, [r7, #12]

  obj->counter_current = 0;
 800344c:	68fb      	ldr	r3, [r7, #12]
 800344e:	2200      	movs	r2, #0
 8003450:	f8a3 21ec 	strh.w	r2, [r3, #492]	; 0x1ec

  return;
 8003454:	bf00      	nop
} // end of CTRL_resetCounter_current() function
 8003456:	3714      	adds	r7, #20
 8003458:	46bd      	mov	sp, r7
 800345a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800345e:	4770      	bx	lr

08003460 <CTRL_resetCounter_isr>:


//! \brief     Resets the isr counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_resetCounter_isr(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003460:	b480      	push	{r7}
 8003462:	b085      	sub	sp, #20
 8003464:	af00      	add	r7, sp, #0
 8003466:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003468:	687b      	ldr	r3, [r7, #4]
 800346a:	60fb      	str	r3, [r7, #12]

  obj->counter_isr = 1;
 800346c:	68fb      	ldr	r3, [r7, #12]
 800346e:	2201      	movs	r2, #1
 8003470:	f8a3 21ee 	strh.w	r2, [r3, #494]	; 0x1ee

  return;
 8003474:	bf00      	nop
} // end of CTRL_resetCounter_isr() function
 8003476:	3714      	adds	r7, #20
 8003478:	46bd      	mov	sp, r7
 800347a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800347e:	4770      	bx	lr

08003480 <CTRL_resetCounter_speed>:


//! \brief     Resets the speed counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_resetCounter_speed(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003480:	b480      	push	{r7}
 8003482:	b085      	sub	sp, #20
 8003484:	af00      	add	r7, sp, #0
 8003486:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003488:	687b      	ldr	r3, [r7, #4]
 800348a:	60fb      	str	r3, [r7, #12]

  obj->counter_speed = 0;
 800348c:	68fb      	ldr	r3, [r7, #12]
 800348e:	2200      	movs	r2, #0
 8003490:	f8a3 21f0 	strh.w	r2, [r3, #496]	; 0x1f0

  return;
 8003494:	bf00      	nop
} // end of CTRL_resetCounter_speed() function
 8003496:	3714      	adds	r7, #20
 8003498:	46bd      	mov	sp, r7
 800349a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800349e:	4770      	bx	lr

080034a0 <CTRL_resetCounter_state>:


//! \brief     Resets the state counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_resetCounter_state(CTRL_Handle handle)//! \Mod By Dl.K
{
 80034a0:	b480      	push	{r7}
 80034a2:	b085      	sub	sp, #20
 80034a4:	af00      	add	r7, sp, #0
 80034a6:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80034a8:	687b      	ldr	r3, [r7, #4]
 80034aa:	60fb      	str	r3, [r7, #12]

  obj->counter_state = 0;
 80034ac:	68fb      	ldr	r3, [r7, #12]
 80034ae:	2200      	movs	r2, #0
 80034b0:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148

  return;
 80034b4:	bf00      	nop
} // end of CTRL_resetCounter_state() function
 80034b6:	3714      	adds	r7, #20
 80034b8:	46bd      	mov	sp, r7
 80034ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80034be:	4770      	bx	lr

080034c0 <CTRL_resetCounter_traj>:


//! \brief     Resets the trajectory counter
//! \param[in] handle  The controller (CTRL) handle
static inline void CTRL_resetCounter_traj(CTRL_Handle handle)//! \Mod By Dl.K
{
 80034c0:	b480      	push	{r7}
 80034c2:	b085      	sub	sp, #20
 80034c4:	af00      	add	r7, sp, #0
 80034c6:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80034c8:	687b      	ldr	r3, [r7, #4]
 80034ca:	60fb      	str	r3, [r7, #12]

  obj->counter_traj = 0;
 80034cc:	68fb      	ldr	r3, [r7, #12]
 80034ce:	2200      	movs	r2, #0
 80034d0:	f8a3 21f2 	strh.w	r2, [r3, #498]	; 0x1f2

  return;
 80034d4:	bf00      	nop
} // end of CTRL_resetCounter_traj() function
 80034d6:	3714      	adds	r7, #20
 80034d8:	46bd      	mov	sp, r7
 80034da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80034de:	4770      	bx	lr

080034e0 <CTRL_setCtrlFreq_Hz>:

//! \brief      Sets the controller frequency
//! \param[in]  handle       The controller (CTRL) handle
//! \param[in]  ctrlFreq_Hz  The controller frequency, Hz
static inline void CTRL_setCtrlFreq_Hz(CTRL_Handle handle,const uint_least32_t ctrlFreq_Hz)//! \Mod By Dl.K
{
 80034e0:	b480      	push	{r7}
 80034e2:	b085      	sub	sp, #20
 80034e4:	af00      	add	r7, sp, #0
 80034e6:	6078      	str	r0, [r7, #4]
 80034e8:	6039      	str	r1, [r7, #0]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80034ea:	687b      	ldr	r3, [r7, #4]
 80034ec:	60fb      	str	r3, [r7, #12]

  obj->ctrlFreq_Hz = ctrlFreq_Hz;
 80034ee:	68fb      	ldr	r3, [r7, #12]
 80034f0:	683a      	ldr	r2, [r7, #0]
 80034f2:	f8c3 2154 	str.w	r2, [r3, #340]	; 0x154

  return;
 80034f6:	bf00      	nop
} // end of CTRL_setCtrlFreq_Hz() function
 80034f8:	3714      	adds	r7, #20
 80034fa:	46bd      	mov	sp, r7
 80034fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003500:	4770      	bx	lr
 8003502:	bf00      	nop

08003504 <CTRL_setCtrlPeriod_sec>:

//! \brief      Sets the controller execution period
//! \param[in]  handle          The controller (CTRL) handle
//! \param[in]  ctrlPeriod_sec  The controller execution period, sec
static inline void CTRL_setCtrlPeriod_sec(CTRL_Handle handle,const float_t ctrlPeriod_sec)//! \Mod By Dl.K
{
 8003504:	b480      	push	{r7}
 8003506:	b085      	sub	sp, #20
 8003508:	af00      	add	r7, sp, #0
 800350a:	6078      	str	r0, [r7, #4]
 800350c:	ed87 0a00 	vstr	s0, [r7]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003510:	687b      	ldr	r3, [r7, #4]
 8003512:	60fb      	str	r3, [r7, #12]

  obj->ctrlPeriod_sec = ctrlPeriod_sec;
 8003514:	68fb      	ldr	r3, [r7, #12]
 8003516:	683a      	ldr	r2, [r7, #0]
 8003518:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160

  return;
 800351c:	bf00      	nop
} // end of CTRL_setCtrlPeriod_sec() function
 800351e:	3714      	adds	r7, #20
 8003520:	46bd      	mov	sp, r7
 8003522:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003526:	4770      	bx	lr

08003528 <CTRL_setErrorCode>:

//! \brief      Sets the error code in the controller
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  errorCode   The error code
static inline void CTRL_setErrorCode(CTRL_Handle handle,const CTRL_ErrorCode_e errorCode)//! \Mod By Dl.K
{
 8003528:	b480      	push	{r7}
 800352a:	b085      	sub	sp, #20
 800352c:	af00      	add	r7, sp, #0
 800352e:	6078      	str	r0, [r7, #4]
 8003530:	460b      	mov	r3, r1
 8003532:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003534:	687b      	ldr	r3, [r7, #4]
 8003536:	60fb      	str	r3, [r7, #12]

  obj->errorCode = errorCode;
 8003538:	68fb      	ldr	r3, [r7, #12]
 800353a:	78fa      	ldrb	r2, [r7, #3]
 800353c:	729a      	strb	r2, [r3, #10]

  return;
 800353e:	bf00      	nop
} // end of CTRL_setErrorCode() function
 8003540:	3714      	adds	r7, #20
 8003542:	46bd      	mov	sp, r7
 8003544:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003548:	4770      	bx	lr
 800354a:	bf00      	nop

0800354c <CTRL_setEstParams>:
//! \details    Copies all scale factors that are defined in the file user.h and used
//!             by CTRL into the CTRL object.
//! \param[in]  estHandle    The estimator (EST) handle
//! \param[in]  pUserParams  The pointer to the user parameters
static inline void CTRL_setEstParams(EST_Handle estHandle,USER_Params *pUserParams)
{
 800354c:	b480      	push	{r7}
 800354e:	b083      	sub	sp, #12
 8003550:	af00      	add	r7, sp, #0
 8003552:	6078      	str	r0, [r7, #4]
 8003554:	6039      	str	r1, [r7, #0]
}
 8003556:	370c      	adds	r7, #12
 8003558:	46bd      	mov	sp, r7
 800355a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800355e:	4770      	bx	lr

08003560 <CTRL_setFlag_enableCtrl>:
//!             motor commissioning is performed and then subsequent times it is called the
//!             motor starts to run.
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  state   The desired state
static inline void CTRL_setFlag_enableCtrl(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
 8003560:	b480      	push	{r7}
 8003562:	b085      	sub	sp, #20
 8003564:	af00      	add	r7, sp, #0
 8003566:	6078      	str	r0, [r7, #4]
 8003568:	460b      	mov	r3, r1
 800356a:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 800356c:	687b      	ldr	r3, [r7, #4]
 800356e:	60fb      	str	r3, [r7, #12]

  obj->flag_enableCtrl = state;
 8003570:	68fb      	ldr	r3, [r7, #12]
 8003572:	78fa      	ldrb	r2, [r7, #3]
 8003574:	f883 21f4 	strb.w	r2, [r3, #500]	; 0x1f4

  return;
 8003578:	bf00      	nop
} // end of CTRL_setFlag_enableCtrl() function
 800357a:	3714      	adds	r7, #20
 800357c:	46bd      	mov	sp, r7
 800357e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003582:	4770      	bx	lr

08003584 <CTRL_setFlag_enableCurrentCtrl>:

//! \brief     Sets the enable current controllers flag value in the controller
//! \param[in] handle  The controller (CTRL) handle
//! \param[in] state   The desired state
static inline void CTRL_setFlag_enableCurrentCtrl(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
 8003584:	b480      	push	{r7}
 8003586:	b085      	sub	sp, #20
 8003588:	af00      	add	r7, sp, #0
 800358a:	6078      	str	r0, [r7, #4]
 800358c:	460b      	mov	r3, r1
 800358e:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003590:	687b      	ldr	r3, [r7, #4]
 8003592:	60fb      	str	r3, [r7, #12]

  obj->flag_enableCurrentCtrl = state;
 8003594:	68fb      	ldr	r3, [r7, #12]
 8003596:	78fa      	ldrb	r2, [r7, #3]
 8003598:	f883 2220 	strb.w	r2, [r3, #544]	; 0x220

  return;
 800359c:	bf00      	nop
} // end of CTRL_setFlag_enableCurrentCtrl() function
 800359e:	3714      	adds	r7, #20
 80035a0:	46bd      	mov	sp, r7
 80035a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80035a6:	4770      	bx	lr

080035a8 <CTRL_setFlag_enableDcBusComp>:
//! \details    The DC bus compensation algorithm will compensate the Iq and Id PI controller's
//!             proportional gains for DC bus variations.
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  state   The desired state
static inline void CTRL_setFlag_enableDcBusComp(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
 80035a8:	b480      	push	{r7}
 80035aa:	b085      	sub	sp, #20
 80035ac:	af00      	add	r7, sp, #0
 80035ae:	6078      	str	r0, [r7, #4]
 80035b0:	460b      	mov	r3, r1
 80035b2:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80035b4:	687b      	ldr	r3, [r7, #4]
 80035b6:	60fb      	str	r3, [r7, #12]

  obj->flag_enableDcBusComp = state;
 80035b8:	68fb      	ldr	r3, [r7, #12]
 80035ba:	78fa      	ldrb	r2, [r7, #3]
 80035bc:	f883 21f5 	strb.w	r2, [r3, #501]	; 0x1f5

  return;
 80035c0:	bf00      	nop
} // end of CTRL_setFlag_enableDcBusComp() function
 80035c2:	3714      	adds	r7, #20
 80035c4:	46bd      	mov	sp, r7
 80035c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80035ca:	4770      	bx	lr

080035cc <CTRL_setFlag_enablePowerWarp>:
//!             levels so that the least amount of power is used according to the load on
//!             the motor.
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  state   The desired state
static inline void CTRL_setFlag_enablePowerWarp(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
 80035cc:	b480      	push	{r7}
 80035ce:	b085      	sub	sp, #20
 80035d0:	af00      	add	r7, sp, #0
 80035d2:	6078      	str	r0, [r7, #4]
 80035d4:	460b      	mov	r3, r1
 80035d6:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80035d8:	687b      	ldr	r3, [r7, #4]
 80035da:	60fb      	str	r3, [r7, #12]

  obj->flag_enablePowerWarp = state;
 80035dc:	68fb      	ldr	r3, [r7, #12]
 80035de:	78fa      	ldrb	r2, [r7, #3]
 80035e0:	f883 21f6 	strb.w	r2, [r3, #502]	; 0x1f6

  return;
 80035e4:	bf00      	nop
} // end of CTRL_setFlag_enablePowerWarp() function
 80035e6:	3714      	adds	r7, #20
 80035e8:	46bd      	mov	sp, r7
 80035ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80035ee:	4770      	bx	lr

080035f0 <CTRL_setFlag_enableOffset>:

//! \brief      Sets the enable offset flag value in the estimator
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  state   The desired state
static inline void CTRL_setFlag_enableOffset(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
 80035f0:	b480      	push	{r7}
 80035f2:	b085      	sub	sp, #20
 80035f4:	af00      	add	r7, sp, #0
 80035f6:	6078      	str	r0, [r7, #4]
 80035f8:	460b      	mov	r3, r1
 80035fa:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80035fc:	687b      	ldr	r3, [r7, #4]
 80035fe:	60fb      	str	r3, [r7, #12]

  obj->flag_enableOffset = state;
 8003600:	68fb      	ldr	r3, [r7, #12]
 8003602:	78fa      	ldrb	r2, [r7, #3]
 8003604:	f883 21f7 	strb.w	r2, [r3, #503]	; 0x1f7

  return;
 8003608:	bf00      	nop
} // end of CTRL_setFlag_enableOffset() function
 800360a:	3714      	adds	r7, #20
 800360c:	46bd      	mov	sp, r7
 800360e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003612:	4770      	bx	lr

08003614 <CTRL_setFlag_enableSpeedCtrl>:

//! \brief      Sets the enable speed control value in the estimator
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  state   The desired state
static inline void CTRL_setFlag_enableSpeedCtrl(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
 8003614:	b480      	push	{r7}
 8003616:	b085      	sub	sp, #20
 8003618:	af00      	add	r7, sp, #0
 800361a:	6078      	str	r0, [r7, #4]
 800361c:	460b      	mov	r3, r1
 800361e:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003620:	687b      	ldr	r3, [r7, #4]
 8003622:	60fb      	str	r3, [r7, #12]

  obj->flag_enableSpeedCtrl = state;
 8003624:	68fb      	ldr	r3, [r7, #12]
 8003626:	78fa      	ldrb	r2, [r7, #3]
 8003628:	f883 21f8 	strb.w	r2, [r3, #504]	; 0x1f8

  return;
 800362c:	bf00      	nop
} // end of CTRL_setFlag_enableSpeedCtrl() function
 800362e:	3714      	adds	r7, #20
 8003630:	46bd      	mov	sp, r7
 8003632:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003636:	4770      	bx	lr

08003638 <CTRL_setFlag_enableUserMotorParams>:
//!             in user.h are used instead of performing a motor commissioning at
//!             startup.
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  state   The desired state
static inline void CTRL_setFlag_enableUserMotorParams(CTRL_Handle handle,const bool state)//! \Mod By Dl.K
{
 8003638:	b480      	push	{r7}
 800363a:	b085      	sub	sp, #20
 800363c:	af00      	add	r7, sp, #0
 800363e:	6078      	str	r0, [r7, #4]
 8003640:	460b      	mov	r3, r1
 8003642:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003644:	687b      	ldr	r3, [r7, #4]
 8003646:	60fb      	str	r3, [r7, #12]

  obj->flag_enableUserMotorParams = state;
 8003648:	68fb      	ldr	r3, [r7, #12]
 800364a:	78fa      	ldrb	r2, [r7, #3]
 800364c:	f883 21f9 	strb.w	r2, [r3, #505]	; 0x1f9

  return;
 8003650:	bf00      	nop
} // end of CTRL_setFlag_enableUserMotorParams() function
 8003652:	3714      	adds	r7, #20
 8003654:	46bd      	mov	sp, r7
 8003656:	f85d 7b04 	ldr.w	r7, [sp], #4
 800365a:	4770      	bx	lr

0800365c <CTRL_setIab_in_pu>:

//! \brief      Sets the alpha/beta current (Iab) input vector values in the controller
//! \param[in]  handle      The controller (CTRL) handle
//! \param[in]  pIab_in_pu  The vector of the alpha/beta current input vector values, pu
static inline void CTRL_setIab_in_pu(CTRL_Handle handle,const MATH_vec2 *pIab_in_pu)//! \Mod By Dl.K
{
 800365c:	b480      	push	{r7}
 800365e:	b085      	sub	sp, #20
 8003660:	af00      	add	r7, sp, #0
 8003662:	6078      	str	r0, [r7, #4]
 8003664:	6039      	str	r1, [r7, #0]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003666:	687b      	ldr	r3, [r7, #4]
 8003668:	60fb      	str	r3, [r7, #12]

  obj->Iab_in.value[0] = pIab_in_pu->value[0];
 800366a:	683b      	ldr	r3, [r7, #0]
 800366c:	681a      	ldr	r2, [r3, #0]
 800366e:	68fb      	ldr	r3, [r7, #12]
 8003670:	f8c3 2168 	str.w	r2, [r3, #360]	; 0x168
  obj->Iab_in.value[1] = pIab_in_pu->value[1];
 8003674:	683b      	ldr	r3, [r7, #0]
 8003676:	685a      	ldr	r2, [r3, #4]
 8003678:	68fb      	ldr	r3, [r7, #12]
 800367a:	f8c3 216c 	str.w	r2, [r3, #364]	; 0x16c

  return;
 800367e:	bf00      	nop
} // end of CTRL_setIab_in_pu() function
 8003680:	3714      	adds	r7, #20
 8003682:	46bd      	mov	sp, r7
 8003684:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003688:	4770      	bx	lr
 800368a:	bf00      	nop

0800368c <CTRL_setIdq_in_pu>:

//! \brief      Sets the direct/quadrature current (Idq) input vector values in the controller
//! \param[in]  handle      The controller (CTRL) handle
//! \param[in]  pIdq_in_pu  The vector of the direct/quadrature current input vector values, pu
static inline void CTRL_setIdq_in_pu(CTRL_Handle handle,const MATH_vec2 *pIdq_in_pu)//! \Mod By Dl.K
{
 800368c:	b480      	push	{r7}
 800368e:	b085      	sub	sp, #20
 8003690:	af00      	add	r7, sp, #0
 8003692:	6078      	str	r0, [r7, #4]
 8003694:	6039      	str	r1, [r7, #0]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003696:	687b      	ldr	r3, [r7, #4]
 8003698:	60fb      	str	r3, [r7, #12]

  obj->Idq_in.value[0] = pIdq_in_pu->value[0];
 800369a:	683b      	ldr	r3, [r7, #0]
 800369c:	681a      	ldr	r2, [r3, #0]
 800369e:	68fb      	ldr	r3, [r7, #12]
 80036a0:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
  obj->Idq_in.value[1] = pIdq_in_pu->value[1];
 80036a4:	683b      	ldr	r3, [r7, #0]
 80036a6:	685a      	ldr	r2, [r3, #4]
 80036a8:	68fb      	ldr	r3, [r7, #12]
 80036aa:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c

  return;
 80036ae:	bf00      	nop
} // end of CTRL_setIdq_in_pu() function
 80036b0:	3714      	adds	r7, #20
 80036b2:	46bd      	mov	sp, r7
 80036b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80036b8:	4770      	bx	lr
 80036ba:	bf00      	nop

080036bc <CTRL_setIdq_ref_pu>:

//! \brief      Sets the direct/quadrature current (Idq) reference vector values in the controller
//! \param[in]  handle       The controller (CTRL) handle
//! \param[in]  pIdq_ref_pu  The vector of the direct/quadrature current reference vector values, pu
static inline void CTRL_setIdq_ref_pu(CTRL_Handle handle,const MATH_vec2 *pIdq_ref_pu)//! \Mod By Dl.K
{
 80036bc:	b480      	push	{r7}
 80036be:	b085      	sub	sp, #20
 80036c0:	af00      	add	r7, sp, #0
 80036c2:	6078      	str	r0, [r7, #4]
 80036c4:	6039      	str	r1, [r7, #0]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80036c6:	687b      	ldr	r3, [r7, #4]
 80036c8:	60fb      	str	r3, [r7, #12]

  obj->Idq_ref.value[0] = pIdq_ref_pu->value[0];
 80036ca:	683b      	ldr	r3, [r7, #0]
 80036cc:	681a      	ldr	r2, [r3, #0]
 80036ce:	68fb      	ldr	r3, [r7, #12]
 80036d0:	f8c3 21d8 	str.w	r2, [r3, #472]	; 0x1d8
  obj->Idq_ref.value[1] = pIdq_ref_pu->value[1];
 80036d4:	683b      	ldr	r3, [r7, #0]
 80036d6:	685a      	ldr	r2, [r3, #4]
 80036d8:	68fb      	ldr	r3, [r7, #12]
 80036da:	f8c3 21dc 	str.w	r2, [r3, #476]	; 0x1dc

  return;
 80036de:	bf00      	nop
} // end of CTRL_setIdq_ref_pu() function
 80036e0:	3714      	adds	r7, #20
 80036e2:	46bd      	mov	sp, r7
 80036e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80036e8:	4770      	bx	lr
 80036ea:	bf00      	nop

080036ec <CTRL_setIdRated_pu>:

//! \brief      Sets the Id rated current value in the controller
//! \param[in]  handle      The controller (CTRL) handle
//! \param[in]  IdRated_pu  The Id rated current value, pu
static inline void CTRL_setIdRated_pu(CTRL_Handle handle,const float_t IdRated_pu)//! \Mod By Dl.K
{
 80036ec:	b480      	push	{r7}
 80036ee:	b085      	sub	sp, #20
 80036f0:	af00      	add	r7, sp, #0
 80036f2:	6078      	str	r0, [r7, #4]
 80036f4:	ed87 0a00 	vstr	s0, [r7]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80036f8:	687b      	ldr	r3, [r7, #4]
 80036fa:	60fb      	str	r3, [r7, #12]

  obj->IdRated = IdRated_pu;
 80036fc:	68fb      	ldr	r3, [r7, #12]
 80036fe:	683a      	ldr	r2, [r7, #0]
 8003700:	f8c3 21e0 	str.w	r2, [r3, #480]	; 0x1e0

  return;
 8003704:	bf00      	nop
} // end of CTRL_setIdRated_pu() function
 8003706:	3714      	adds	r7, #20
 8003708:	46bd      	mov	sp, r7
 800370a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800370e:	4770      	bx	lr

08003710 <CTRL_setKd>:
//! \brief      Sets the derivative gain (Kd) value for the specified controller
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  ctrlType  The controller type
//! \param[in]  Kd        The Kd value
static inline void CTRL_setKd(CTRL_Handle handle,const CTRL_Type_e ctrlType,const float_t Kd)//! \Mod By Dl.K
{
 8003710:	b480      	push	{r7}
 8003712:	b087      	sub	sp, #28
 8003714:	af00      	add	r7, sp, #0
 8003716:	60f8      	str	r0, [r7, #12]
 8003718:	460b      	mov	r3, r1
 800371a:	ed87 0a01 	vstr	s0, [r7, #4]
 800371e:	72fb      	strb	r3, [r7, #11]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003720:	68fb      	ldr	r3, [r7, #12]
 8003722:	617b      	str	r3, [r7, #20]

  if(ctrlType == CTRL_Type_PID_spd)
 8003724:	7afb      	ldrb	r3, [r7, #11]
 8003726:	2b00      	cmp	r3, #0
 8003728:	d104      	bne.n	8003734 <CTRL_setKd+0x24>
    {
      obj->Kd_spd = Kd;
 800372a:	697b      	ldr	r3, [r7, #20]
 800372c:	687a      	ldr	r2, [r7, #4]
 800372e:	f8c3 21c8 	str.w	r2, [r3, #456]	; 0x1c8
 8003732:	e00e      	b.n	8003752 <CTRL_setKd+0x42>
    }
  else if(ctrlType == CTRL_Type_PID_Id)
 8003734:	7afb      	ldrb	r3, [r7, #11]
 8003736:	2b01      	cmp	r3, #1
 8003738:	d104      	bne.n	8003744 <CTRL_setKd+0x34>
    {
      obj->Kd_Id = Kd;
 800373a:	697b      	ldr	r3, [r7, #20]
 800373c:	687a      	ldr	r2, [r7, #4]
 800373e:	f8c3 21c0 	str.w	r2, [r3, #448]	; 0x1c0
 8003742:	e006      	b.n	8003752 <CTRL_setKd+0x42>
    }
  else if(ctrlType == CTRL_Type_PID_Iq)
 8003744:	7afb      	ldrb	r3, [r7, #11]
 8003746:	2b02      	cmp	r3, #2
 8003748:	d103      	bne.n	8003752 <CTRL_setKd+0x42>
    {
      obj->Kd_Iq = Kd;
 800374a:	697b      	ldr	r3, [r7, #20]
 800374c:	687a      	ldr	r2, [r7, #4]
 800374e:	f8c3 21c4 	str.w	r2, [r3, #452]	; 0x1c4
    }

  return;
 8003752:	bf00      	nop
} // end of CTRL_setKd() function
 8003754:	371c      	adds	r7, #28
 8003756:	46bd      	mov	sp, r7
 8003758:	f85d 7b04 	ldr.w	r7, [sp], #4
 800375c:	4770      	bx	lr
 800375e:	bf00      	nop

08003760 <CTRL_setKi>:
//! \brief      Sets the integral gain (Ki) value for the specified controller
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  ctrlType  The controller type
//! \param[in]  Ki        The Ki value
static inline void CTRL_setKi(CTRL_Handle handle,const CTRL_Type_e ctrlType,const float_t Ki)//! \Mod By Dl.K
{
 8003760:	b480      	push	{r7}
 8003762:	b087      	sub	sp, #28
 8003764:	af00      	add	r7, sp, #0
 8003766:	60f8      	str	r0, [r7, #12]
 8003768:	460b      	mov	r3, r1
 800376a:	ed87 0a01 	vstr	s0, [r7, #4]
 800376e:	72fb      	strb	r3, [r7, #11]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003770:	68fb      	ldr	r3, [r7, #12]
 8003772:	617b      	str	r3, [r7, #20]

  if(ctrlType == CTRL_Type_PID_spd)
 8003774:	7afb      	ldrb	r3, [r7, #11]
 8003776:	2b00      	cmp	r3, #0
 8003778:	d104      	bne.n	8003784 <CTRL_setKi+0x24>
    {
      obj->Ki_spd = Ki;
 800377a:	697b      	ldr	r3, [r7, #20]
 800377c:	687a      	ldr	r2, [r7, #4]
 800377e:	f8c3 21bc 	str.w	r2, [r3, #444]	; 0x1bc
 8003782:	e00e      	b.n	80037a2 <CTRL_setKi+0x42>
    }
  else if(ctrlType == CTRL_Type_PID_Id)
 8003784:	7afb      	ldrb	r3, [r7, #11]
 8003786:	2b01      	cmp	r3, #1
 8003788:	d104      	bne.n	8003794 <CTRL_setKi+0x34>
    {
      obj->Ki_Id = Ki;
 800378a:	697b      	ldr	r3, [r7, #20]
 800378c:	687a      	ldr	r2, [r7, #4]
 800378e:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
 8003792:	e006      	b.n	80037a2 <CTRL_setKi+0x42>
    }
  else if(ctrlType == CTRL_Type_PID_Iq)
 8003794:	7afb      	ldrb	r3, [r7, #11]
 8003796:	2b02      	cmp	r3, #2
 8003798:	d103      	bne.n	80037a2 <CTRL_setKi+0x42>
    {
      obj->Ki_Iq = Ki;
 800379a:	697b      	ldr	r3, [r7, #20]
 800379c:	687a      	ldr	r2, [r7, #4]
 800379e:	f8c3 21b8 	str.w	r2, [r3, #440]	; 0x1b8
    }

  return;
 80037a2:	bf00      	nop
} // end of CTRL_setKi() function
 80037a4:	371c      	adds	r7, #28
 80037a6:	46bd      	mov	sp, r7
 80037a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80037ac:	4770      	bx	lr
 80037ae:	bf00      	nop

080037b0 <CTRL_setKp>:
//! \brief      Sets the proportional gain (Kp) value for the specified controller
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  ctrlType  The controller type
//! \param[in]  Kp        The Kp value
static inline void CTRL_setKp(CTRL_Handle handle,const CTRL_Type_e ctrlType,const float_t Kp)//! \Mod By Dl.K
{
 80037b0:	b480      	push	{r7}
 80037b2:	b087      	sub	sp, #28
 80037b4:	af00      	add	r7, sp, #0
 80037b6:	60f8      	str	r0, [r7, #12]
 80037b8:	460b      	mov	r3, r1
 80037ba:	ed87 0a01 	vstr	s0, [r7, #4]
 80037be:	72fb      	strb	r3, [r7, #11]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80037c0:	68fb      	ldr	r3, [r7, #12]
 80037c2:	617b      	str	r3, [r7, #20]

  if(ctrlType == CTRL_Type_PID_spd)
 80037c4:	7afb      	ldrb	r3, [r7, #11]
 80037c6:	2b00      	cmp	r3, #0
 80037c8:	d104      	bne.n	80037d4 <CTRL_setKp+0x24>
    {
      obj->Kp_spd = Kp;
 80037ca:	697b      	ldr	r3, [r7, #20]
 80037cc:	687a      	ldr	r2, [r7, #4]
 80037ce:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
 80037d2:	e00e      	b.n	80037f2 <CTRL_setKp+0x42>
    }
  else if(ctrlType == CTRL_Type_PID_Id)
 80037d4:	7afb      	ldrb	r3, [r7, #11]
 80037d6:	2b01      	cmp	r3, #1
 80037d8:	d104      	bne.n	80037e4 <CTRL_setKp+0x34>
    {
      obj->Kp_Id = Kp;
 80037da:	697b      	ldr	r3, [r7, #20]
 80037dc:	687a      	ldr	r2, [r7, #4]
 80037de:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
 80037e2:	e006      	b.n	80037f2 <CTRL_setKp+0x42>
    }
  else if(ctrlType == CTRL_Type_PID_Iq)
 80037e4:	7afb      	ldrb	r3, [r7, #11]
 80037e6:	2b02      	cmp	r3, #2
 80037e8:	d103      	bne.n	80037f2 <CTRL_setKp+0x42>
    {
      obj->Kp_Iq = Kp;
 80037ea:	697b      	ldr	r3, [r7, #20]
 80037ec:	687a      	ldr	r2, [r7, #4]
 80037ee:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
    }

  return;
 80037f2:	bf00      	nop
} // end of CTRL_setKp() function
 80037f4:	371c      	adds	r7, #28
 80037f6:	46bd      	mov	sp, r7
 80037f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80037fc:	4770      	bx	lr
 80037fe:	bf00      	nop

08003800 <CTRL_setLhf>:

//! \brief      Sets the high frequency inductance (Lhf) value in the controller
//! \param[in]  handle  The controller (CTRL) handle
//! \param[in]  Lhf     The Lhf value
static inline void CTRL_setLhf(CTRL_Handle handle,const float_t Lhf)//! \Mod By Dl.K
{
 8003800:	b480      	push	{r7}
 8003802:	b085      	sub	sp, #20
 8003804:	af00      	add	r7, sp, #0
 8003806:	6078      	str	r0, [r7, #4]
 8003808:	ed87 0a00 	vstr	s0, [r7]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 800380c:	687b      	ldr	r3, [r7, #4]
 800380e:	60fb      	str	r3, [r7, #12]

  obj->Lhf = Lhf;
 8003810:	68fb      	ldr	r3, [r7, #12]
 8003812:	683a      	ldr	r2, [r7, #0]
 8003814:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0

  return;
 8003818:	bf00      	nop
} // end of CTRL_setLhf() function
 800381a:	3714      	adds	r7, #20
 800381c:	46bd      	mov	sp, r7
 800381e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003822:	4770      	bx	lr

08003824 <CTRL_setMaxVsMag_pu>:

//! \brief      Sets the maximum voltage vector in the controller
//! \param[in]  handle        The controller (CTRL) handle
//! \param[in]  maxVsMag      The maximum voltage vector (value betwen 0 and 4/3)
static inline void CTRL_setMaxVsMag_pu(CTRL_Handle handle,const float_t maxVsMag)//! \Mod By Dl.K
{
 8003824:	b480      	push	{r7}
 8003826:	b085      	sub	sp, #20
 8003828:	af00      	add	r7, sp, #0
 800382a:	6078      	str	r0, [r7, #4]
 800382c:	ed87 0a00 	vstr	s0, [r7]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003830:	687b      	ldr	r3, [r7, #4]
 8003832:	60fb      	str	r3, [r7, #12]

  obj->maxVsMag_pu = maxVsMag;
 8003834:	68fb      	ldr	r3, [r7, #12]
 8003836:	683a      	ldr	r2, [r7, #0]
 8003838:	f8c3 2164 	str.w	r2, [r3, #356]	; 0x164

  return;
 800383c:	bf00      	nop
} // end of CTRL_setmaxVsMag_pu() function
 800383e:	3714      	adds	r7, #20
 8003840:	46bd      	mov	sp, r7
 8003842:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003846:	4770      	bx	lr

08003848 <CTRL_setMotorParams>:
                                const float_t ratedFlux,
                                const float_t Ls_d,
                                const float_t Ls_q,
                                const float_t Rr,
                                const float_t Rs)//! \Mod By Dl.K
{
 8003848:	b480      	push	{r7}
 800384a:	b08b      	sub	sp, #44	; 0x2c
 800384c:	af00      	add	r7, sp, #0
 800384e:	61f8      	str	r0, [r7, #28]
 8003850:	460b      	mov	r3, r1
 8003852:	ed87 0a05 	vstr	s0, [r7, #20]
 8003856:	edc7 0a04 	vstr	s1, [r7, #16]
 800385a:	ed87 1a03 	vstr	s2, [r7, #12]
 800385e:	edc7 1a02 	vstr	s3, [r7, #8]
 8003862:	ed87 2a01 	vstr	s4, [r7, #4]
 8003866:	76fb      	strb	r3, [r7, #27]
 8003868:	4613      	mov	r3, r2
 800386a:	833b      	strh	r3, [r7, #24]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 800386c:	69fb      	ldr	r3, [r7, #28]
 800386e:	627b      	str	r3, [r7, #36]	; 0x24

  obj->motorParams.type = motorType;
 8003870:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003872:	7efa      	ldrb	r2, [r7, #27]
 8003874:	f883 2104 	strb.w	r2, [r3, #260]	; 0x104
  obj->motorParams.numPolePairs = numPolePairs;
 8003878:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800387a:	8b3a      	ldrh	r2, [r7, #24]
 800387c:	f8a3 2106 	strh.w	r2, [r3, #262]	; 0x106
  obj->motorParams.ratedFlux_VpHz = ratedFlux;
 8003880:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003882:	697a      	ldr	r2, [r7, #20]
 8003884:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
  obj->motorParams.Ls_d_H = Ls_d;
 8003888:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800388a:	693a      	ldr	r2, [r7, #16]
 800388c:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
  obj->motorParams.Ls_q_H = Ls_q;
 8003890:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003892:	68fa      	ldr	r2, [r7, #12]
 8003894:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
  obj->motorParams.Rr_Ohm = Rr;
 8003898:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800389a:	68ba      	ldr	r2, [r7, #8]
 800389c:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
  obj->motorParams.Rs_Ohm = Rs;
 80038a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80038a2:	687a      	ldr	r2, [r7, #4]
 80038a4:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118

  return;
 80038a8:	bf00      	nop
} // end of CTRL_setMotorParams() function
 80038aa:	372c      	adds	r7, #44	; 0x2c
 80038ac:	46bd      	mov	sp, r7
 80038ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80038b2:	4770      	bx	lr

080038b4 <CTRL_setNumCtrlTicksPerCurrentTick>:
//! \brief     Sets the number of controller clock ticks per current controller clock tick
//! \param[in] handle                      The controller (CTRL) handle
//! \param[in] numCtrlTicksPerCurrentTick  The number of controller clock ticks per estimator clock tick
static inline void CTRL_setNumCtrlTicksPerCurrentTick(CTRL_Handle handle,
                                               const uint_least16_t numCtrlTicksPerCurrentTick)//! \Mod By Dl.K
{
 80038b4:	b480      	push	{r7}
 80038b6:	b085      	sub	sp, #20
 80038b8:	af00      	add	r7, sp, #0
 80038ba:	6078      	str	r0, [r7, #4]
 80038bc:	460b      	mov	r3, r1
 80038be:	807b      	strh	r3, [r7, #2]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80038c0:	687b      	ldr	r3, [r7, #4]
 80038c2:	60fb      	str	r3, [r7, #12]

  obj->numCtrlTicksPerCurrentTick = numCtrlTicksPerCurrentTick;
 80038c4:	68fb      	ldr	r3, [r7, #12]
 80038c6:	887a      	ldrh	r2, [r7, #2]
 80038c8:	f8a3 214e 	strh.w	r2, [r3, #334]	; 0x14e

  return;
 80038cc:	bf00      	nop
} // end of CTRL_setNumCtrlTicksPerCurrentTick() function
 80038ce:	3714      	adds	r7, #20
 80038d0:	46bd      	mov	sp, r7
 80038d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80038d6:	4770      	bx	lr

080038d8 <CTRL_setNumCtrlTicksPerSpeedTick>:
//! \brief     Sets the number of controller clock ticks per speed controller clock tick
//! \param[in] handle                    The controller (CTRL) handle
//! \param[in] numCtrlTicksPerSpeedTick  The number of controller clock ticks per speed clock tick
static inline void CTRL_setNumCtrlTicksPerSpeedTick(CTRL_Handle handle,
                                               const uint_least16_t numCtrlTicksPerSpeedTick)//! \Mod By Dl.K
{
 80038d8:	b480      	push	{r7}
 80038da:	b085      	sub	sp, #20
 80038dc:	af00      	add	r7, sp, #0
 80038de:	6078      	str	r0, [r7, #4]
 80038e0:	460b      	mov	r3, r1
 80038e2:	807b      	strh	r3, [r7, #2]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80038e4:	687b      	ldr	r3, [r7, #4]
 80038e6:	60fb      	str	r3, [r7, #12]

  obj->numCtrlTicksPerSpeedTick = numCtrlTicksPerSpeedTick;
 80038e8:	68fb      	ldr	r3, [r7, #12]
 80038ea:	887a      	ldrh	r2, [r7, #2]
 80038ec:	f8a3 2150 	strh.w	r2, [r3, #336]	; 0x150

  return;
 80038f0:	bf00      	nop
} // end of CTRL_setNumCtrlTicksPerSpeedTick() function
 80038f2:	3714      	adds	r7, #20
 80038f4:	46bd      	mov	sp, r7
 80038f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80038fa:	4770      	bx	lr

080038fc <CTRL_setNumCtrlTicksPerTrajTick>:
//! \brief     Sets the number of controller clock ticks per trajectory clock tick
//! \param[in] handle                   The controller (CTRL) handle
//! \param[in] numCtrlTicksPerTrajTick  The number of controller clock ticks per trajectory clock tick
static inline void CTRL_setNumCtrlTicksPerTrajTick(CTRL_Handle handle,
                                               const uint_least16_t numCtrlTicksPerTrajTick)//! \Mod By Dl.K
{
 80038fc:	b480      	push	{r7}
 80038fe:	b085      	sub	sp, #20
 8003900:	af00      	add	r7, sp, #0
 8003902:	6078      	str	r0, [r7, #4]
 8003904:	460b      	mov	r3, r1
 8003906:	807b      	strh	r3, [r7, #2]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003908:	687b      	ldr	r3, [r7, #4]
 800390a:	60fb      	str	r3, [r7, #12]

  obj->numCtrlTicksPerTrajTick = numCtrlTicksPerTrajTick;
 800390c:	68fb      	ldr	r3, [r7, #12]
 800390e:	887a      	ldrh	r2, [r7, #2]
 8003910:	f8a3 2152 	strh.w	r2, [r3, #338]	; 0x152

  return;
 8003914:	bf00      	nop
} // end of CTRL_setNumCtrlTicksPerTrajTick() function
 8003916:	3714      	adds	r7, #20
 8003918:	46bd      	mov	sp, r7
 800391a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800391e:	4770      	bx	lr

08003920 <CTRL_setNumIsrTicksPerCtrlTick>:
//! \brief     Sets the number of Interrupt Service Routine (ISR) clock ticks per controller clock tick
//! \param[in] handle                  The controller (CTRL) handle
//! \param[in] numIsrTicksPerCtrlTick  The number of Interrupt Service Routine (ISR) clock ticks per controller clock tick
static inline void CTRL_setNumIsrTicksPerCtrlTick(CTRL_Handle handle,
                                           const uint_least16_t numIsrTicksPerCtrlTick)//! \Mod By Dl.K
{
 8003920:	b480      	push	{r7}
 8003922:	b085      	sub	sp, #20
 8003924:	af00      	add	r7, sp, #0
 8003926:	6078      	str	r0, [r7, #4]
 8003928:	460b      	mov	r3, r1
 800392a:	807b      	strh	r3, [r7, #2]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 800392c:	687b      	ldr	r3, [r7, #4]
 800392e:	60fb      	str	r3, [r7, #12]

  obj->numIsrTicksPerCtrlTick = numIsrTicksPerCtrlTick;
 8003930:	68fb      	ldr	r3, [r7, #12]
 8003932:	887a      	ldrh	r2, [r7, #2]
 8003934:	f8a3 214c 	strh.w	r2, [r3, #332]	; 0x14c

  return;
 8003938:	bf00      	nop
} // end of CTRL_setNumIsrTicksPerCtrlTick() function
 800393a:	3714      	adds	r7, #20
 800393c:	46bd      	mov	sp, r7
 800393e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003942:	4770      	bx	lr

08003944 <CTRL_setRhf>:

//! \brief     Sets the high frequency resistance (Rhf) value in the controller
//! \param[in] handle  The controller (CTRL) handle
//! \param[in] Rhf     The Rhf value
static inline void CTRL_setRhf(CTRL_Handle handle,const float_t Rhf)//! \Mod By Dl.K
{
 8003944:	b480      	push	{r7}
 8003946:	b085      	sub	sp, #20
 8003948:	af00      	add	r7, sp, #0
 800394a:	6078      	str	r0, [r7, #4]
 800394c:	ed87 0a00 	vstr	s0, [r7]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003950:	687b      	ldr	r3, [r7, #4]
 8003952:	60fb      	str	r3, [r7, #12]

  obj->Rhf = Rhf;
 8003954:	68fb      	ldr	r3, [r7, #12]
 8003956:	683a      	ldr	r2, [r7, #0]
 8003958:	f8c3 219c 	str.w	r2, [r3, #412]	; 0x19c

  return;
 800395c:	bf00      	nop
} // end of CTRL_setRhf() function
 800395e:	3714      	adds	r7, #20
 8003960:	46bd      	mov	sp, r7
 8003962:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003966:	4770      	bx	lr

08003968 <CTRL_setRoverL>:

//! \brief     Sets the R/L value in the controller
//! \param[in] handle  The controller (CTRL) handle
//! \param[in] RoverL  The R/L value
static inline void CTRL_setRoverL(CTRL_Handle handle,const float_t RoverL)//! \Mod By Dl.K
{
 8003968:	b480      	push	{r7}
 800396a:	b085      	sub	sp, #20
 800396c:	af00      	add	r7, sp, #0
 800396e:	6078      	str	r0, [r7, #4]
 8003970:	ed87 0a00 	vstr	s0, [r7]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003974:	687b      	ldr	r3, [r7, #4]
 8003976:	60fb      	str	r3, [r7, #12]

  obj->RoverL = RoverL;
 8003978:	68fb      	ldr	r3, [r7, #12]
 800397a:	683a      	ldr	r2, [r7, #0]
 800397c:	f8c3 21a4 	str.w	r2, [r3, #420]	; 0x1a4

  return;
 8003980:	bf00      	nop
} // end of CTRL_setRoverL() function
 8003982:	3714      	adds	r7, #20
 8003984:	46bd      	mov	sp, r7
 8003986:	f85d 7b04 	ldr.w	r7, [sp], #4
 800398a:	4770      	bx	lr

0800398c <CTRL_setSpd_out_pu>:

//! \brief     Sets the output speed value in the controller
//! \param[in] handle      The controller (CTRL) handle
//! \param[in] spd_out_pu  The output speed value, pu
static inline void CTRL_setSpd_out_pu(CTRL_Handle handle,const float_t spd_out_pu)//! \Mod By Dl.K
{
 800398c:	b480      	push	{r7}
 800398e:	b085      	sub	sp, #20
 8003990:	af00      	add	r7, sp, #0
 8003992:	6078      	str	r0, [r7, #4]
 8003994:	ed87 0a00 	vstr	s0, [r7]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003998:	687b      	ldr	r3, [r7, #4]
 800399a:	60fb      	str	r3, [r7, #12]

  obj->spd_out = spd_out_pu;
 800399c:	68fb      	ldr	r3, [r7, #12]
 800399e:	683a      	ldr	r2, [r7, #0]
 80039a0:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188

  return;
 80039a4:	bf00      	nop
} // end of CTRL_setSpd_out_pu() function
 80039a6:	3714      	adds	r7, #20
 80039a8:	46bd      	mov	sp, r7
 80039aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80039ae:	4770      	bx	lr

080039b0 <CTRL_setState>:

//! \brief     Sets the controller state
//! \param[in] handle  The controller (CTRL) handle
//! \param[in] state       The new state
static inline void CTRL_setState(CTRL_Handle handle,const CTRL_State_e state)//! \Mod By Dl.K
{
 80039b0:	b480      	push	{r7}
 80039b2:	b085      	sub	sp, #20
 80039b4:	af00      	add	r7, sp, #0
 80039b6:	6078      	str	r0, [r7, #4]
 80039b8:	460b      	mov	r3, r1
 80039ba:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80039bc:	687b      	ldr	r3, [r7, #4]
 80039be:	60fb      	str	r3, [r7, #12]

  obj->prevState = obj->state;
 80039c0:	68fb      	ldr	r3, [r7, #12]
 80039c2:	7a1a      	ldrb	r2, [r3, #8]
 80039c4:	68fb      	ldr	r3, [r7, #12]
 80039c6:	725a      	strb	r2, [r3, #9]
  obj->state = state;
 80039c8:	68fb      	ldr	r3, [r7, #12]
 80039ca:	78fa      	ldrb	r2, [r7, #3]
 80039cc:	721a      	strb	r2, [r3, #8]

  return;
 80039ce:	bf00      	nop
} // end of CTRL_setState() function
 80039d0:	3714      	adds	r7, #20
 80039d2:	46bd      	mov	sp, r7
 80039d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80039d8:	4770      	bx	lr
 80039da:	bf00      	nop

080039dc <CTRL_setTrajFreq_Hz>:

//! \brief      Sets the trajectory execution frequency
//! \param[in]  handle       The controller (CTRL) handle
//! \param[in]  trajFreq_Hz  The trajectory execution frequency, Hz
static inline void CTRL_setTrajFreq_Hz(CTRL_Handle handle,const uint_least32_t trajFreq_Hz)//! \Mod By Dl.K
{
 80039dc:	b480      	push	{r7}
 80039de:	b085      	sub	sp, #20
 80039e0:	af00      	add	r7, sp, #0
 80039e2:	6078      	str	r0, [r7, #4]
 80039e4:	6039      	str	r1, [r7, #0]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80039e6:	687b      	ldr	r3, [r7, #4]
 80039e8:	60fb      	str	r3, [r7, #12]

  obj->trajFreq_Hz = trajFreq_Hz;
 80039ea:	68fb      	ldr	r3, [r7, #12]
 80039ec:	683a      	ldr	r2, [r7, #0]
 80039ee:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158

  return;
 80039f2:	bf00      	nop
} // end of CTRL_setTrajFreq_Hz() function
 80039f4:	3714      	adds	r7, #20
 80039f6:	46bd      	mov	sp, r7
 80039f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80039fc:	4770      	bx	lr
 80039fe:	bf00      	nop

08003a00 <CTRL_setTrajPeriod_sec>:

//! \brief      Sets the trajectory execution period
//! \param[in]  handle          The controller (CTRL) handle
//! \param[in]  trajPeriod_sec  The trajectory execution period, sec
static inline void CTRL_setTrajPeriod_sec(CTRL_Handle handle,const float_t trajPeriod_sec)//! \Mod By Dl.K
{
 8003a00:	b480      	push	{r7}
 8003a02:	b085      	sub	sp, #20
 8003a04:	af00      	add	r7, sp, #0
 8003a06:	6078      	str	r0, [r7, #4]
 8003a08:	ed87 0a00 	vstr	s0, [r7]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003a0c:	687b      	ldr	r3, [r7, #4]
 8003a0e:	60fb      	str	r3, [r7, #12]

  obj->trajPeriod_sec = trajPeriod_sec;
 8003a10:	68fb      	ldr	r3, [r7, #12]
 8003a12:	683a      	ldr	r2, [r7, #0]
 8003a14:	f8c3 215c 	str.w	r2, [r3, #348]	; 0x15c

  return;
 8003a18:	bf00      	nop
} // end of CTRL_setTrajPeriod_sec() function
 8003a1a:	3714      	adds	r7, #20
 8003a1c:	46bd      	mov	sp, r7
 8003a1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003a22:	4770      	bx	lr

08003a24 <CTRL_setVab_in_pu>:

//! \brief     Sets the alpha/beta voltage input vector values in the controller
//! \param[in] handle      The controller (CTRL) handle
//! \param[in] pVab_in_pu  The vector of alpha/beta voltage input vector values, pu
static inline void CTRL_setVab_in_pu(CTRL_Handle handle,const MATH_vec2 *pVab_in_pu)//! \Mod By Dl.K
{
 8003a24:	b480      	push	{r7}
 8003a26:	b085      	sub	sp, #20
 8003a28:	af00      	add	r7, sp, #0
 8003a2a:	6078      	str	r0, [r7, #4]
 8003a2c:	6039      	str	r1, [r7, #0]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003a2e:	687b      	ldr	r3, [r7, #4]
 8003a30:	60fb      	str	r3, [r7, #12]

  obj->Vab_in.value[0] = pVab_in_pu->value[0];
 8003a32:	683b      	ldr	r3, [r7, #0]
 8003a34:	681a      	ldr	r2, [r3, #0]
 8003a36:	68fb      	ldr	r3, [r7, #12]
 8003a38:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  obj->Vab_in.value[1] = pVab_in_pu->value[1];
 8003a3c:	683b      	ldr	r3, [r7, #0]
 8003a3e:	685a      	ldr	r2, [r3, #4]
 8003a40:	68fb      	ldr	r3, [r7, #12]
 8003a42:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184

  return;
 8003a46:	bf00      	nop
} // end of CTRL_setVab_in_pu() function
 8003a48:	3714      	adds	r7, #20
 8003a4a:	46bd      	mov	sp, r7
 8003a4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003a50:	4770      	bx	lr
 8003a52:	bf00      	nop

08003a54 <CTRL_setVab_out_pu>:

//! \brief     Sets the alpha/beta current output vector values in the controller
//! \param[in] handle       The controller (CTRL) handle
//! \param[in] pVab_out_pu  The vector of alpha/beta current output vector values, pu
static inline void CTRL_setVab_out_pu(CTRL_Handle handle,const MATH_vec2 *pVab_out_pu)//! \Mod By Dl.K
{
 8003a54:	b480      	push	{r7}
 8003a56:	b085      	sub	sp, #20
 8003a58:	af00      	add	r7, sp, #0
 8003a5a:	6078      	str	r0, [r7, #4]
 8003a5c:	6039      	str	r1, [r7, #0]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003a5e:	687b      	ldr	r3, [r7, #4]
 8003a60:	60fb      	str	r3, [r7, #12]

  obj->Vab_out.value[0] = pVab_out_pu->value[0];
 8003a62:	683b      	ldr	r3, [r7, #0]
 8003a64:	681a      	ldr	r2, [r3, #0]
 8003a66:	68fb      	ldr	r3, [r7, #12]
 8003a68:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
  obj->Vab_out.value[1] = pVab_out_pu->value[1];
 8003a6c:	683b      	ldr	r3, [r7, #0]
 8003a6e:	685a      	ldr	r2, [r3, #4]
 8003a70:	68fb      	ldr	r3, [r7, #12]
 8003a72:	f8c3 2190 	str.w	r2, [r3, #400]	; 0x190

  return;
 8003a76:	bf00      	nop
} // end of CTRL_setVab_out_pu() function
 8003a78:	3714      	adds	r7, #20
 8003a7a:	46bd      	mov	sp, r7
 8003a7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003a80:	4770      	bx	lr
 8003a82:	bf00      	nop

08003a84 <CTRL_setVdq_out_pu>:

//! \brief     Sets the direct/quadrature voltage output vector values in the controller
//! \param[in] handle       The controller (CTRL) handle
//! \param[in] pVdq_out_pu  The vector of direct/quadrature voltage output vector values, pu
static inline void CTRL_setVdq_out_pu(CTRL_Handle handle,const MATH_vec2 *pVdq_out_pu)//! \Mod By Dl.K
{
 8003a84:	b480      	push	{r7}
 8003a86:	b085      	sub	sp, #20
 8003a88:	af00      	add	r7, sp, #0
 8003a8a:	6078      	str	r0, [r7, #4]
 8003a8c:	6039      	str	r1, [r7, #0]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003a8e:	687b      	ldr	r3, [r7, #4]
 8003a90:	60fb      	str	r3, [r7, #12]

  obj->Vdq_out.value[0] = pVdq_out_pu->value[0];
 8003a92:	683b      	ldr	r3, [r7, #0]
 8003a94:	681a      	ldr	r2, [r3, #0]
 8003a96:	68fb      	ldr	r3, [r7, #12]
 8003a98:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194
  obj->Vdq_out.value[1] = pVdq_out_pu->value[1];
 8003a9c:	683b      	ldr	r3, [r7, #0]
 8003a9e:	685a      	ldr	r2, [r3, #4]
 8003aa0:	68fb      	ldr	r3, [r7, #12]
 8003aa2:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198

  return;
 8003aa6:	bf00      	nop
} // end of CTRL_setVdq_out_pu() function
 8003aa8:	3714      	adds	r7, #20
 8003aaa:	46bd      	mov	sp, r7
 8003aac:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003ab0:	4770      	bx	lr
 8003ab2:	bf00      	nop

08003ab4 <CTRL_computePhasor>:

//! \brief      Computes a phasor for a given angle
//! \param[in]  angle_pu  The angle, pu
//! \param[out] pPhasor   The pointer to the phasor vector values
static inline void CTRL_computePhasor(const float_t angle_pu,MATH_vec2 *pPhasor)//! \Mod By Dl.K
{
 8003ab4:	b580      	push	{r7, lr}
 8003ab6:	b082      	sub	sp, #8
 8003ab8:	af00      	add	r7, sp, #0
 8003aba:	ed87 0a01 	vstr	s0, [r7, #4]
 8003abe:	6038      	str	r0, [r7, #0]

  pPhasor->value[0] = cosf(angle_pu);
 8003ac0:	ed97 0a01 	vldr	s0, [r7, #4]
 8003ac4:	f023 ffd8 	bl	8027a78 <cosf>
 8003ac8:	eef0 7a40 	vmov.f32	s15, s0
 8003acc:	683b      	ldr	r3, [r7, #0]
 8003ace:	edc3 7a00 	vstr	s15, [r3]
  pPhasor->value[1] = sinf(angle_pu);
 8003ad2:	ed97 0a01 	vldr	s0, [r7, #4]
 8003ad6:	f024 f80b 	bl	8027af0 <sinf>
 8003ada:	eef0 7a40 	vmov.f32	s15, s0
 8003ade:	683b      	ldr	r3, [r7, #0]
 8003ae0:	edc3 7a01 	vstr	s15, [r3, #4]

  return;
 8003ae4:	bf00      	nop
} // end of CTRL_computePhasor() function
 8003ae6:	3708      	adds	r7, #8
 8003ae8:	46bd      	mov	sp, r7
 8003aea:	bd80      	pop	{r7, pc}

08003aec <CTRL_doCurrentCtrl>:

//! \brief      Determines if the current controllers should be run
//! \param[in]  handle  The controller (CTRL) handle
//! \return     The value denoting that the current controllers should be run (true) or not (false)
static inline bool CTRL_doCurrentCtrl(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003aec:	b580      	push	{r7, lr}
 8003aee:	b084      	sub	sp, #16
 8003af0:	af00      	add	r7, sp, #0
 8003af2:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003af4:	687b      	ldr	r3, [r7, #4]
 8003af6:	60bb      	str	r3, [r7, #8]
  bool result = false;
 8003af8:	2300      	movs	r3, #0
 8003afa:	73fb      	strb	r3, [r7, #15]

  if(CTRL_getFlag_enableCurrentCtrl(handle) && (obj->counter_current >= obj->numCtrlTicksPerCurrentTick))
 8003afc:	6878      	ldr	r0, [r7, #4]
 8003afe:	f7ff fabb 	bl	8003078 <CTRL_getFlag_enableCurrentCtrl>
 8003b02:	4603      	mov	r3, r0
 8003b04:	2b00      	cmp	r3, #0
 8003b06:	d009      	beq.n	8003b1c <CTRL_doCurrentCtrl+0x30>
 8003b08:	68bb      	ldr	r3, [r7, #8]
 8003b0a:	f8b3 21ec 	ldrh.w	r2, [r3, #492]	; 0x1ec
 8003b0e:	68bb      	ldr	r3, [r7, #8]
 8003b10:	f8b3 314e 	ldrh.w	r3, [r3, #334]	; 0x14e
 8003b14:	429a      	cmp	r2, r3
 8003b16:	d301      	bcc.n	8003b1c <CTRL_doCurrentCtrl+0x30>
  {
    result = true;
 8003b18:	2301      	movs	r3, #1
 8003b1a:	73fb      	strb	r3, [r7, #15]
  }

  return(result);
 8003b1c:	7bfb      	ldrb	r3, [r7, #15]
} // end of CTRL_doCurrentCtrl() function
 8003b1e:	4618      	mov	r0, r3
 8003b20:	3710      	adds	r7, #16
 8003b22:	46bd      	mov	sp, r7
 8003b24:	bd80      	pop	{r7, pc}
 8003b26:	bf00      	nop

08003b28 <CTRL_doSpeedCtrl>:

//! \brief     Determines if the speed controller should be executed
//! \param[in] handle  The controller (CTRL) handle
//! \return    A boolean value denoting if the speed controller should be executed (true) or not (false)
static inline bool CTRL_doSpeedCtrl(CTRL_Handle handle)//! \Mod By Dl.K
{
 8003b28:	b480      	push	{r7}
 8003b2a:	b085      	sub	sp, #20
 8003b2c:	af00      	add	r7, sp, #0
 8003b2e:	6078      	str	r0, [r7, #4]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003b30:	687b      	ldr	r3, [r7, #4]
 8003b32:	60bb      	str	r3, [r7, #8]
  bool result = false;
 8003b34:	2300      	movs	r3, #0
 8003b36:	73fb      	strb	r3, [r7, #15]

  if((obj->counter_speed >= obj->numCtrlTicksPerSpeedTick))
 8003b38:	68bb      	ldr	r3, [r7, #8]
 8003b3a:	f8b3 21f0 	ldrh.w	r2, [r3, #496]	; 0x1f0
 8003b3e:	68bb      	ldr	r3, [r7, #8]
 8003b40:	f8b3 3150 	ldrh.w	r3, [r3, #336]	; 0x150
 8003b44:	429a      	cmp	r2, r3
 8003b46:	d301      	bcc.n	8003b4c <CTRL_doSpeedCtrl+0x24>
  {
    result = true;
 8003b48:	2301      	movs	r3, #1
 8003b4a:	73fb      	strb	r3, [r7, #15]
  }

  return(result);
 8003b4c:	7bfb      	ldrb	r3, [r7, #15]
} // end of CTRL_doSpeedCtrl() function
 8003b4e:	4618      	mov	r0, r3
 8003b50:	3714      	adds	r7, #20
 8003b52:	46bd      	mov	sp, r7
 8003b54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003b58:	4770      	bx	lr
 8003b5a:	bf00      	nop

08003b5c <CTRL_runOffLine>:
//! \param[in]  pAdcData   The pointer to the ADC data
//! \param[out] pPwmData   The pointer to the PWM data

static inline void CTRL_runOffLine(CTRL_Handle handle,HAL_Handle halHandle,
                            const HAL_AdcData_t *pAdcData,HAL_PwmData_t *pPwmData, HAL_QepData_t *pQepData)//! \Mod By Dl.K
{
 8003b5c:	b580      	push	{r7, lr}
 8003b5e:	b084      	sub	sp, #16
 8003b60:	af00      	add	r7, sp, #0
 8003b62:	60f8      	str	r0, [r7, #12]
 8003b64:	60b9      	str	r1, [r7, #8]
 8003b66:	607a      	str	r2, [r7, #4]
 8003b68:	603b      	str	r3, [r7, #0]

	// run offset estimation
	//settestpin();
	HAL_runOffsetEst(halHandle,pAdcData);
 8003b6a:	68b8      	ldr	r0, [r7, #8]
 8003b6c:	6879      	ldr	r1, [r7, #4]
 8003b6e:	f7ff fa2f 	bl	8002fd0 <HAL_runOffsetEst>
	//cleartestpin();
  
	Speed_SetElecTheta(handle->Speed_handle,0.0f);
 8003b72:	68fb      	ldr	r3, [r7, #12]
 8003b74:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 8003b78:	4618      	mov	r0, r3
 8003b7a:	ed9f 0a14 	vldr	s0, [pc, #80]	; 8003bcc <CTRL_runOffLine+0x70>
 8003b7e:	f7ff f9cf 	bl	8002f20 <Speed_SetElecTheta>
	Speed_UpdateElecTheta(handle->Speed_handle);
 8003b82:	68fb      	ldr	r3, [r7, #12]
 8003b84:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 8003b88:	4618      	mov	r0, r3
 8003b8a:	f7ff f9ff 	bl	8002f8c <Speed_UpdateElecTheta>
	
	// create PWM data
	pPwmData->Tabc.value[0] = (0.0f);
 8003b8e:	683b      	ldr	r3, [r7, #0]
 8003b90:	f04f 0200 	mov.w	r2, #0
 8003b94:	601a      	str	r2, [r3, #0]
	pPwmData->Tabc.value[1] = (0.0f);
 8003b96:	683b      	ldr	r3, [r7, #0]
 8003b98:	f04f 0200 	mov.w	r2, #0
 8003b9c:	605a      	str	r2, [r3, #4]
	pPwmData->Tabc.value[2] = (0.0f);
 8003b9e:	683b      	ldr	r3, [r7, #0]
 8003ba0:	f04f 0200 	mov.w	r2, #0
 8003ba4:	609a      	str	r2, [r3, #8]

	handle->MntValue.value[0] = halHandle->offset_I[0].value;
 8003ba6:	68bb      	ldr	r3, [r7, #8]
 8003ba8:	68da      	ldr	r2, [r3, #12]
 8003baa:	68fb      	ldr	r3, [r7, #12]
 8003bac:	f8c3 2320 	str.w	r2, [r3, #800]	; 0x320
	handle->MntValue.value[1] = halHandle->offset_I[1].value;
 8003bb0:	68bb      	ldr	r3, [r7, #8]
 8003bb2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8003bb4:	68fb      	ldr	r3, [r7, #12]
 8003bb6:	f8c3 2324 	str.w	r2, [r3, #804]	; 0x324
	handle->MntValue.value[2] = halHandle->offset_I[2].value;
 8003bba:	68bb      	ldr	r3, [r7, #8]
 8003bbc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8003bbe:	68fb      	ldr	r3, [r7, #12]
 8003bc0:	f8c3 2328 	str.w	r2, [r3, #808]	; 0x328
  return;
 8003bc4:	bf00      	nop
} // end of CTRL_runOffLine() function
 8003bc6:	3710      	adds	r7, #16
 8003bc8:	46bd      	mov	sp, r7
 8003bca:	bd80      	pop	{r7, pc}
 8003bcc:	00000000 	.word	0x00000000

08003bd0 <CTRL_runInitDete_User>:
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  pAdcData  The pointer to the ADC data
//! \param[out] pPwmData  The pointer to the PWM data
static inline void CTRL_runInitDete_User(CTRL_Handle handle,HAL_Handle halHandle,
                           const HAL_AdcData_t *pAdcData,HAL_PwmData_t *pPwmData, HAL_QepData_t *pQepData)//! \Mod By Dl.K
{
 8003bd0:	b5b0      	push	{r4, r5, r7, lr}
 8003bd2:	b08c      	sub	sp, #48	; 0x30
 8003bd4:	af00      	add	r7, sp, #0
 8003bd6:	6178      	str	r0, [r7, #20]
 8003bd8:	6139      	str	r1, [r7, #16]
 8003bda:	60fa      	str	r2, [r7, #12]
 8003bdc:	60bb      	str	r3, [r7, #8]
	//! \Mod By Dl.K Dynamic Stator Initial Position Detection
	CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003bde:	697b      	ldr	r3, [r7, #20]
 8003be0:	62fb      	str	r3, [r7, #44]	; 0x2c
	static uint16_t flag=true;
	MATH_vec2 phasor;
	MATH_vec2 vdq = {0.0f,0.0f};
 8003be2:	f04f 0300 	mov.w	r3, #0
 8003be6:	61bb      	str	r3, [r7, #24]
 8003be8:	f04f 0300 	mov.w	r3, #0
 8003bec:	61fb      	str	r3, [r7, #28]
	int16_t angle_temp_pu;

	// run Clarke transform on current
	CLARKE_run(obj->clarkeHandle_I,&pAdcData->I,CTRL_getIab_in_addr(handle));
 8003bee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003bf0:	68dd      	ldr	r5, [r3, #12]
 8003bf2:	68fc      	ldr	r4, [r7, #12]
 8003bf4:	6978      	ldr	r0, [r7, #20]
 8003bf6:	f7ff fa5f 	bl	80030b8 <CTRL_getIab_in_addr>
 8003bfa:	4603      	mov	r3, r0
 8003bfc:	4628      	mov	r0, r5
 8003bfe:	4621      	mov	r1, r4
 8003c00:	461a      	mov	r2, r3
 8003c02:	f7fe fc09 	bl	8002418 <CLARKE_run>

	// clear the position counter
//	QEP_clear_posn_counter(halHandle->qepHandle[0]);
	
	angle_temp_pu = 32768.0f*pQepData->qep_cnt*USER_MOTOR_NUM_POLE_PAIRS;
 8003c06:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8003c08:	edd3 7a00 	vldr	s15, [r3]
 8003c0c:	ed9f 7a44 	vldr	s14, [pc, #272]	; 8003d20 <CTRL_runInitDete_User+0x150>
 8003c10:	ee67 7a87 	vmul.f32	s15, s15, s14
 8003c14:	eeb1 7a00 	vmov.f32	s14, #16
 8003c18:	ee67 7a87 	vmul.f32	s15, s15, s14
 8003c1c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8003c20:	edc7 7a01 	vstr	s15, [r7, #4]
 8003c24:	88bb      	ldrh	r3, [r7, #4]
 8003c26:	857b      	strh	r3, [r7, #42]	; 0x2a
	angle_temp_pu &= 0x7FFF;
 8003c28:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8003c2a:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8003c2e:	857b      	strh	r3, [r7, #42]	; 0x2a
	obj->angle_offset_pu = angle_temp_pu *0.0000305f;
 8003c30:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8003c34:	ee07 3a90 	vmov	s15, r3
 8003c38:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8003c3c:	ed9f 7a39 	vldr	s14, [pc, #228]	; 8003d24 <CTRL_runInitDete_User+0x154>
 8003c40:	ee67 7a87 	vmul.f32	s15, s15, s14
 8003c44:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003c46:	edc3 7a83 	vstr	s15, [r3, #524]	; 0x20c

	Speed_SetElecTheta(obj->Speed_handle,0.0f);
 8003c4a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003c4c:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 8003c50:	4618      	mov	r0, r3
 8003c52:	ed9f 0a35 	vldr	s0, [pc, #212]	; 8003d28 <CTRL_runInitDete_User+0x158>
 8003c56:	f7ff f963 	bl	8002f20 <Speed_SetElecTheta>
	Speed_UpdateElecTheta(obj->Speed_handle);
 8003c5a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003c5c:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 8003c60:	4618      	mov	r0, r3
 8003c62:	f7ff f993 	bl	8002f8c <Speed_UpdateElecTheta>
	
	// compute the sin/cos phasor
	CTRL_computePhasor(obj->AngleRef * MATH_TWO_PI,&phasor);//-0.25
 8003c66:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003c68:	edd3 7ac7 	vldr	s15, [r3, #796]	; 0x31c
 8003c6c:	ed9f 7a2f 	vldr	s14, [pc, #188]	; 8003d2c <CTRL_runInitDete_User+0x15c>
 8003c70:	ee67 7a87 	vmul.f32	s15, s15, s14
 8003c74:	f107 0320 	add.w	r3, r7, #32
 8003c78:	eeb0 0a67 	vmov.f32	s0, s15
 8003c7c:	4618      	mov	r0, r3
 8003c7e:	f7ff ff19 	bl	8003ab4 <CTRL_computePhasor>

	// set
	if( flag==true )
 8003c82:	4b2b      	ldr	r3, [pc, #172]	; (8003d30 <CTRL_runInitDete_User+0x160>)
 8003c84:	881b      	ldrh	r3, [r3, #0]
 8003c86:	2b01      	cmp	r3, #1
 8003c88:	d105      	bne.n	8003c96 <CTRL_runInitDete_User+0xc6>
	{
		vdq.value[0] = (0.0f);
 8003c8a:	f04f 0300 	mov.w	r3, #0
 8003c8e:	61bb      	str	r3, [r7, #24]
		vdq.value[1] = (0.1f);
 8003c90:	4b28      	ldr	r3, [pc, #160]	; (8003d34 <CTRL_runInitDete_User+0x164>)
 8003c92:	61fb      	str	r3, [r7, #28]
 8003c94:	e005      	b.n	8003ca2 <CTRL_runInitDete_User+0xd2>
	}
	else
	{
		vdq.value[0] = (0.0f);
 8003c96:	f04f 0300 	mov.w	r3, #0
 8003c9a:	61bb      	str	r3, [r7, #24]
		vdq.value[1] = (0.0f);
 8003c9c:	f04f 0300 	mov.w	r3, #0
 8003ca0:	61fb      	str	r3, [r7, #28]
	}
	CTRL_setVdq_out_pu(obj,&vdq);
 8003ca2:	f107 0318 	add.w	r3, r7, #24
 8003ca6:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8003ca8:	4619      	mov	r1, r3
 8003caa:	f7ff feeb 	bl	8003a84 <CTRL_setVdq_out_pu>

	// set the phasor in the inverse Park transform
	IPARK_setPhasor(obj->iparkHandle,&phasor);
 8003cae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003cb0:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
 8003cb4:	f107 0320 	add.w	r3, r7, #32
 8003cb8:	4610      	mov	r0, r2
 8003cba:	4619      	mov	r1, r3
 8003cbc:	f7fe fcc0 	bl	8002640 <IPARK_setPhasor>

	// run the inverse Park module
	IPARK_run(obj->iparkHandle,CTRL_getVdq_out_addr(obj),CTRL_getVab_out_addr(obj));
 8003cc0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003cc2:	f8d3 40a8 	ldr.w	r4, [r3, #168]	; 0xa8
 8003cc6:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8003cc8:	f7ff fb28 	bl	800331c <CTRL_getVdq_out_addr>
 8003ccc:	4605      	mov	r5, r0
 8003cce:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8003cd0:	f7ff fb04 	bl	80032dc <CTRL_getVab_out_addr>
 8003cd4:	4603      	mov	r3, r0
 8003cd6:	4620      	mov	r0, r4
 8003cd8:	4629      	mov	r1, r5
 8003cda:	461a      	mov	r2, r3
 8003cdc:	f7fe fc74 	bl	80025c8 <IPARK_run>

	// run the space Vector Generator (SVGEN) module
	SVGEN_run(obj->svgenHandle,CTRL_getVab_out_addr(handle),&(pPwmData->Tabc));
 8003ce0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003ce2:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8003ce6:	6978      	ldr	r0, [r7, #20]
 8003ce8:	f7ff faf8 	bl	80032dc <CTRL_getVab_out_addr>
 8003cec:	4602      	mov	r2, r0
 8003cee:	68bb      	ldr	r3, [r7, #8]
 8003cf0:	4620      	mov	r0, r4
 8003cf2:	4611      	mov	r1, r2
 8003cf4:	461a      	mov	r2, r3
 8003cf6:	f7fe fe39 	bl	800296c <SVGEN_run>

	obj->Tabc.value[0]=pPwmData->Tabc.value[0];
 8003cfa:	68bb      	ldr	r3, [r7, #8]
 8003cfc:	681a      	ldr	r2, [r3, #0]
 8003cfe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003d00:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
	obj->Tabc.value[1]=pPwmData->Tabc.value[1];
 8003d04:	68bb      	ldr	r3, [r7, #8]
 8003d06:	685a      	ldr	r2, [r3, #4]
 8003d08:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003d0a:	f8c3 230c 	str.w	r2, [r3, #780]	; 0x30c
	obj->Tabc.value[2]=pPwmData->Tabc.value[2];
 8003d0e:	68bb      	ldr	r3, [r7, #8]
 8003d10:	689a      	ldr	r2, [r3, #8]
 8003d12:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003d14:	f8c3 2310 	str.w	r2, [r3, #784]	; 0x310
}
 8003d18:	3730      	adds	r7, #48	; 0x30
 8003d1a:	46bd      	mov	sp, r7
 8003d1c:	bdb0      	pop	{r4, r5, r7, pc}
 8003d1e:	bf00      	nop
 8003d20:	47000000 	.word	0x47000000
 8003d24:	37ffda40 	.word	0x37ffda40
 8003d28:	00000000 	.word	0x00000000
 8003d2c:	40c90fdb 	.word	0x40c90fdb
 8003d30:	20010004 	.word	0x20010004
 8003d34:	3dcccccd 	.word	0x3dcccccd

08003d38 <CTRL_runStaticStatorInitDete_User>:
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  pAdcData  The pointer to the ADC data
//! \param[out] pPwmData  The pointer to the PWM data
static inline void CTRL_runStaticStatorInitDete_User(CTRL_Handle handle,HAL_Handle halHandle,
                           const HAL_AdcData_t *pAdcData,HAL_PwmData_t *pPwmData, HAL_QepData_t *pQepData)//! \Mod By Dl.K
{
 8003d38:	b5b0      	push	{r4, r5, r7, lr}
 8003d3a:	b08a      	sub	sp, #40	; 0x28
 8003d3c:	af00      	add	r7, sp, #0
 8003d3e:	60f8      	str	r0, [r7, #12]
 8003d40:	60b9      	str	r1, [r7, #8]
 8003d42:	607a      	str	r2, [r7, #4]
 8003d44:	603b      	str	r3, [r7, #0]
	//! \Mod By Dl.K Static Stator Initial Position Detection
	CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003d46:	68fb      	ldr	r3, [r7, #12]
 8003d48:	627b      	str	r3, [r7, #36]	; 0x24
	float_t angle_pu;
	MATH_vec2 phasor;
	MATH_vec2 vdq = {0.0f,0.0f};
 8003d4a:	f04f 0300 	mov.w	r3, #0
 8003d4e:	613b      	str	r3, [r7, #16]
 8003d50:	f04f 0300 	mov.w	r3, #0
 8003d54:	617b      	str	r3, [r7, #20]
	static uint16_t sInitPosDetTick = 5,sInitPosDetSclar = 5;

	//GPIO_setHigh(halHandle->gpioHandle,GPIO_Number_32);

	if( INITPOSDET_GetIdSampAngleFlag(obj->InitPosDet_handle) &&
 8003d56:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003d58:	f8d3 3284 	ldr.w	r3, [r3, #644]	; 0x284
 8003d5c:	4618      	mov	r0, r3
 8003d5e:	f7ff f8d1 	bl	8002f04 <INITPOSDET_GetIdSampAngleFlag>
 8003d62:	4603      	mov	r3, r0
 8003d64:	2b00      	cmp	r3, #0
 8003d66:	d077      	beq.n	8003e58 <CTRL_runStaticStatorInitDete_User+0x120>
			sInitPosDetTick==4 )
 8003d68:	4b83      	ldr	r3, [pc, #524]	; (8003f78 <CTRL_runStaticStatorInitDete_User+0x240>)
 8003d6a:	881b      	ldrh	r3, [r3, #0]
	MATH_vec2 vdq = {0.0f,0.0f};
	static uint16_t sInitPosDetTick = 5,sInitPosDetSclar = 5;

	//GPIO_setHigh(halHandle->gpioHandle,GPIO_Number_32);

	if( INITPOSDET_GetIdSampAngleFlag(obj->InitPosDet_handle) &&
 8003d6c:	2b04      	cmp	r3, #4
 8003d6e:	d173      	bne.n	8003e58 <CTRL_runStaticStatorInitDete_User+0x120>
			sInitPosDetTick==4 )
	{
//		GPIO_setHigh(halHandle->gpioHandle,GPIO_Number_43);

		obj->MntValue.value[0] = pAdcData->I.value[0];
 8003d70:	687b      	ldr	r3, [r7, #4]
 8003d72:	681a      	ldr	r2, [r3, #0]
 8003d74:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003d76:	f8c3 2320 	str.w	r2, [r3, #800]	; 0x320
		obj->MntValue.value[1] = pAdcData->I.value[1];
 8003d7a:	687b      	ldr	r3, [r7, #4]
 8003d7c:	685a      	ldr	r2, [r3, #4]
 8003d7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003d80:	f8c3 2324 	str.w	r2, [r3, #804]	; 0x324
		obj->MntValue.value[2] = pAdcData->I.value[2];
 8003d84:	687b      	ldr	r3, [r7, #4]
 8003d86:	689a      	ldr	r2, [r3, #8]
 8003d88:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003d8a:	f8c3 2328 	str.w	r2, [r3, #808]	; 0x328

		// run Clarke transform on current
		CLARKE_run(obj->clarkeHandle_I,&pAdcData->I,CTRL_getIab_in_addr(obj));
 8003d8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003d90:	68dd      	ldr	r5, [r3, #12]
 8003d92:	687c      	ldr	r4, [r7, #4]
 8003d94:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8003d96:	f7ff f98f 	bl	80030b8 <CTRL_getIab_in_addr>
 8003d9a:	4603      	mov	r3, r0
 8003d9c:	4628      	mov	r0, r5
 8003d9e:	4621      	mov	r1, r4
 8003da0:	461a      	mov	r2, r3
 8003da2:	f7fe fb39 	bl	8002418 <CLARKE_run>

		// generate the motor electrical angle
		angle_pu = INITPOSDET_GetIdSampAngle(obj->InitPosDet_handle);
 8003da6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003da8:	f8d3 3284 	ldr.w	r3, [r3, #644]	; 0x284
 8003dac:	4618      	mov	r0, r3
 8003dae:	f7ff f897 	bl	8002ee0 <INITPOSDET_GetIdSampAngle>
 8003db2:	ed87 0a08 	vstr	s0, [r7, #32]

		// compute the sin/cos phasor
		CTRL_computePhasor(angle_pu * MATH_TWO_PI,&phasor);
 8003db6:	edd7 7a08 	vldr	s15, [r7, #32]
 8003dba:	ed9f 7a70 	vldr	s14, [pc, #448]	; 8003f7c <CTRL_runStaticStatorInitDete_User+0x244>
 8003dbe:	ee67 7a87 	vmul.f32	s15, s15, s14
 8003dc2:	f107 0318 	add.w	r3, r7, #24
 8003dc6:	eeb0 0a67 	vmov.f32	s0, s15
 8003dca:	4618      	mov	r0, r3
 8003dcc:	f7ff fe72 	bl	8003ab4 <CTRL_computePhasor>

		// set the phasor in the Park transform
		PARK_setPhasor(obj->parkHandle,&phasor);
 8003dd0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003dd2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003dd4:	f107 0318 	add.w	r3, r7, #24
 8003dd8:	4610      	mov	r0, r2
 8003dda:	4619      	mov	r1, r3
 8003ddc:	f7fe fbde 	bl	800259c <PARK_setPhasor>

		// run the Park transform
		PARK_run(obj->parkHandle,CTRL_getIab_in_addr(obj),CTRL_getIdq_in_addr(obj));
 8003de0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003de2:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 8003de4:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8003de6:	f7ff f967 	bl	80030b8 <CTRL_getIab_in_addr>
 8003dea:	4605      	mov	r5, r0
 8003dec:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8003dee:	f7ff f997 	bl	8003120 <CTRL_getIdq_in_addr>
 8003df2:	4603      	mov	r3, r0
 8003df4:	4620      	mov	r0, r4
 8003df6:	4629      	mov	r1, r5
 8003df8:	461a      	mov	r2, r3
 8003dfa:	f7fe fb93 	bl	8002524 <PARK_run>

		INITPOSDET_Run(obj->InitPosDet_handle,CTRL_getId_in_pu(obj));
 8003dfe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003e00:	f8d3 4284 	ldr.w	r4, [r3, #644]	; 0x284
 8003e04:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8003e06:	f7ff f967 	bl	80030d8 <CTRL_getId_in_pu>
 8003e0a:	eef0 7a40 	vmov.f32	s15, s0
 8003e0e:	4620      	mov	r0, r4
 8003e10:	eeb0 0a67 	vmov.f32	s0, s15
 8003e14:	f7fd fcec 	bl	80017f0 <INITPOSDET_Run>

		obj->angle_offset_pu = - INITPOSDET_GetInitPosAngle(obj->InitPosDet_handle);
 8003e18:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003e1a:	f8d3 3284 	ldr.w	r3, [r3, #644]	; 0x284
 8003e1e:	4618      	mov	r0, r3
 8003e20:	f7ff f82c 	bl	8002e7c <INITPOSDET_GetInitPosAngle>
 8003e24:	eef0 7a40 	vmov.f32	s15, s0
 8003e28:	eef1 7a67 	vneg.f32	s15, s15
 8003e2c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003e2e:	edc3 7a83 	vstr	s15, [r3, #524]	; 0x20c
		
		Speed_SetElecTheta(obj->Speed_handle,-obj->angle_offset_pu);
 8003e32:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003e34:	f8d3 22e8 	ldr.w	r2, [r3, #744]	; 0x2e8
 8003e38:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003e3a:	edd3 7a83 	vldr	s15, [r3, #524]	; 0x20c
 8003e3e:	eef1 7a67 	vneg.f32	s15, s15
 8003e42:	4610      	mov	r0, r2
 8003e44:	eeb0 0a67 	vmov.f32	s0, s15
 8003e48:	f7ff f86a 	bl	8002f20 <Speed_SetElecTheta>
		Speed_UpdateElecTheta(obj->Speed_handle);
 8003e4c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003e4e:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 8003e52:	4618      	mov	r0, r3
 8003e54:	f7ff f89a 	bl	8002f8c <Speed_UpdateElecTheta>
//		GPIO_setLow(halHandle->gpioHandle,GPIO_Number_43);
	}

	if(sInitPosDetTick>=sInitPosDetSclar)
 8003e58:	4b47      	ldr	r3, [pc, #284]	; (8003f78 <CTRL_runStaticStatorInitDete_User+0x240>)
 8003e5a:	881a      	ldrh	r2, [r3, #0]
 8003e5c:	4b48      	ldr	r3, [pc, #288]	; (8003f80 <CTRL_runStaticStatorInitDete_User+0x248>)
 8003e5e:	881b      	ldrh	r3, [r3, #0]
 8003e60:	429a      	cmp	r2, r3
 8003e62:	d309      	bcc.n	8003e78 <CTRL_runStaticStatorInitDete_User+0x140>
	{
		sInitPosDetTick=1;
 8003e64:	4b44      	ldr	r3, [pc, #272]	; (8003f78 <CTRL_runStaticStatorInitDete_User+0x240>)
 8003e66:	2201      	movs	r2, #1
 8003e68:	801a      	strh	r2, [r3, #0]
		INITPOSDET_VolVecAngleRun(obj->InitPosDet_handle);
 8003e6a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003e6c:	f8d3 3284 	ldr.w	r3, [r3, #644]	; 0x284
 8003e70:	4618      	mov	r0, r3
 8003e72:	f7fd fea1 	bl	8001bb8 <INITPOSDET_VolVecAngleRun>
 8003e76:	e005      	b.n	8003e84 <CTRL_runStaticStatorInitDete_User+0x14c>
	}
	else sInitPosDetTick++;
 8003e78:	4b3f      	ldr	r3, [pc, #252]	; (8003f78 <CTRL_runStaticStatorInitDete_User+0x240>)
 8003e7a:	881b      	ldrh	r3, [r3, #0]
 8003e7c:	3301      	adds	r3, #1
 8003e7e:	b29a      	uxth	r2, r3
 8003e80:	4b3d      	ldr	r3, [pc, #244]	; (8003f78 <CTRL_runStaticStatorInitDete_User+0x240>)
 8003e82:	801a      	strh	r2, [r3, #0]

	// set
	if( INITPOSDET_GetVolVecAngleFlag(obj->InitPosDet_handle) )
 8003e84:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003e86:	f8d3 3284 	ldr.w	r3, [r3, #644]	; 0x284
 8003e8a:	4618      	mov	r0, r3
 8003e8c:	f7ff f808 	bl	8002ea0 <INITPOSDET_GetVolVecAngleFlag>
 8003e90:	4603      	mov	r3, r0
 8003e92:	2b00      	cmp	r3, #0
 8003e94:	d01c      	beq.n	8003ed0 <CTRL_runStaticStatorInitDete_User+0x198>
	{
		vdq.value[0] = obj->VdqRef.value[0];
 8003e96:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003e98:	f8d3 3314 	ldr.w	r3, [r3, #788]	; 0x314
 8003e9c:	613b      	str	r3, [r7, #16]
		vdq.value[1] = (0.0f);
 8003e9e:	f04f 0300 	mov.w	r3, #0
 8003ea2:	617b      	str	r3, [r7, #20]

		// generate the motor electrical angle
		angle_pu = INITPOSDET_GetVolVecAngle(obj->InitPosDet_handle);
 8003ea4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003ea6:	f8d3 3284 	ldr.w	r3, [r3, #644]	; 0x284
 8003eaa:	4618      	mov	r0, r3
 8003eac:	f7ff f806 	bl	8002ebc <INITPOSDET_GetVolVecAngle>
 8003eb0:	ed87 0a08 	vstr	s0, [r7, #32]

		// compute the sin/cos phasor
		CTRL_computePhasor(angle_pu * MATH_TWO_PI,&phasor);
 8003eb4:	edd7 7a08 	vldr	s15, [r7, #32]
 8003eb8:	ed9f 7a30 	vldr	s14, [pc, #192]	; 8003f7c <CTRL_runStaticStatorInitDete_User+0x244>
 8003ebc:	ee67 7a87 	vmul.f32	s15, s15, s14
 8003ec0:	f107 0318 	add.w	r3, r7, #24
 8003ec4:	eeb0 0a67 	vmov.f32	s0, s15
 8003ec8:	4618      	mov	r0, r3
 8003eca:	f7ff fdf3 	bl	8003ab4 <CTRL_computePhasor>
 8003ece:	e015      	b.n	8003efc <CTRL_runStaticStatorInitDete_User+0x1c4>
	}
	else
	{
		vdq.value[0] = (0.0f);
 8003ed0:	f04f 0300 	mov.w	r3, #0
 8003ed4:	613b      	str	r3, [r7, #16]
		vdq.value[1] = (0.0f);
 8003ed6:	f04f 0300 	mov.w	r3, #0
 8003eda:	617b      	str	r3, [r7, #20]

		// generate the motor electrical angle
		angle_pu = (0.0f);
 8003edc:	f04f 0300 	mov.w	r3, #0
 8003ee0:	623b      	str	r3, [r7, #32]

		// compute the sin/cos phasor
		CTRL_computePhasor(angle_pu * MATH_TWO_PI,&phasor);
 8003ee2:	edd7 7a08 	vldr	s15, [r7, #32]
 8003ee6:	ed9f 7a25 	vldr	s14, [pc, #148]	; 8003f7c <CTRL_runStaticStatorInitDete_User+0x244>
 8003eea:	ee67 7a87 	vmul.f32	s15, s15, s14
 8003eee:	f107 0318 	add.w	r3, r7, #24
 8003ef2:	eeb0 0a67 	vmov.f32	s0, s15
 8003ef6:	4618      	mov	r0, r3
 8003ef8:	f7ff fddc 	bl	8003ab4 <CTRL_computePhasor>
	}
	CTRL_setVdq_out_pu(obj,&vdq);
 8003efc:	f107 0310 	add.w	r3, r7, #16
 8003f00:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8003f02:	4619      	mov	r1, r3
 8003f04:	f7ff fdbe 	bl	8003a84 <CTRL_setVdq_out_pu>

	// set the phasor in the inverse Park transform
	IPARK_setPhasor(obj->iparkHandle,&phasor);
 8003f08:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003f0a:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
 8003f0e:	f107 0318 	add.w	r3, r7, #24
 8003f12:	4610      	mov	r0, r2
 8003f14:	4619      	mov	r1, r3
 8003f16:	f7fe fb93 	bl	8002640 <IPARK_setPhasor>

	// run the inverse Park module
	IPARK_run(obj->iparkHandle,CTRL_getVdq_out_addr(obj),CTRL_getVab_out_addr(obj));
 8003f1a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003f1c:	f8d3 40a8 	ldr.w	r4, [r3, #168]	; 0xa8
 8003f20:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8003f22:	f7ff f9fb 	bl	800331c <CTRL_getVdq_out_addr>
 8003f26:	4605      	mov	r5, r0
 8003f28:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8003f2a:	f7ff f9d7 	bl	80032dc <CTRL_getVab_out_addr>
 8003f2e:	4603      	mov	r3, r0
 8003f30:	4620      	mov	r0, r4
 8003f32:	4629      	mov	r1, r5
 8003f34:	461a      	mov	r2, r3
 8003f36:	f7fe fb47 	bl	80025c8 <IPARK_run>

	// run the space Vector Generator (SVGEN) module
	SVGEN_run(obj->svgenHandle,CTRL_getVab_out_addr(obj),&(pPwmData->Tabc));
 8003f3a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003f3c:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8003f40:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8003f42:	f7ff f9cb 	bl	80032dc <CTRL_getVab_out_addr>
 8003f46:	4602      	mov	r2, r0
 8003f48:	683b      	ldr	r3, [r7, #0]
 8003f4a:	4620      	mov	r0, r4
 8003f4c:	4611      	mov	r1, r2
 8003f4e:	461a      	mov	r2, r3
 8003f50:	f7fe fd0c 	bl	800296c <SVGEN_run>

	obj->Tabc.value[0]=pPwmData->Tabc.value[0];
 8003f54:	683b      	ldr	r3, [r7, #0]
 8003f56:	681a      	ldr	r2, [r3, #0]
 8003f58:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003f5a:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
	obj->Tabc.value[1]=pPwmData->Tabc.value[1];
 8003f5e:	683b      	ldr	r3, [r7, #0]
 8003f60:	685a      	ldr	r2, [r3, #4]
 8003f62:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003f64:	f8c3 230c 	str.w	r2, [r3, #780]	; 0x30c
	obj->Tabc.value[2]=pPwmData->Tabc.value[2];
 8003f68:	683b      	ldr	r3, [r7, #0]
 8003f6a:	689a      	ldr	r2, [r3, #8]
 8003f6c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003f6e:	f8c3 2310 	str.w	r2, [r3, #784]	; 0x310

	//GPIO_setLow(halHandle->gpioHandle,GPIO_Number_32);
}
 8003f72:	3728      	adds	r7, #40	; 0x28
 8003f74:	46bd      	mov	sp, r7
 8003f76:	bdb0      	pop	{r4, r5, r7, pc}
 8003f78:	20010006 	.word	0x20010006
 8003f7c:	40c90fdb 	.word	0x40c90fdb
 8003f80:	20010008 	.word	0x20010008

08003f84 <CTRL_runOpenLoop_User>:
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  pAdcData  The pointer to the ADC data
//! \param[out] pPwmData  The pointer to the PWM data
static inline void CTRL_runOpenLoop_User(CTRL_Handle handle,HAL_Handle halHandle,
                           const HAL_AdcData_t *pAdcData,HAL_PwmData_t *pPwmData, HAL_QepData_t *pQepData)//! \Mod By Dl.K
{
 8003f84:	b5b0      	push	{r4, r5, r7, lr}
 8003f86:	b08e      	sub	sp, #56	; 0x38
 8003f88:	af00      	add	r7, sp, #0
 8003f8a:	6178      	str	r0, [r7, #20]
 8003f8c:	6139      	str	r1, [r7, #16]
 8003f8e:	60fa      	str	r2, [r7, #12]
 8003f90:	60bb      	str	r3, [r7, #8]
	//! \Mod By Dl.K OpenLoop Control
	CTRL_Obj *obj = (CTRL_Obj *)handle;
 8003f92:	697b      	ldr	r3, [r7, #20]
 8003f94:	637b      	str	r3, [r7, #52]	; 0x34
	int16_t angle_temp_pu;
	float_t angle_pu;
	MATH_vec2 phasor;
	MATH_vec2 vdq = {0,0};
 8003f96:	f04f 0300 	mov.w	r3, #0
 8003f9a:	61fb      	str	r3, [r7, #28]
 8003f9c:	f04f 0300 	mov.w	r3, #0
 8003fa0:	623b      	str	r3, [r7, #32]

	// run Clarke transform on current
	CLARKE_run(obj->clarkeHandle_I,&pAdcData->I,CTRL_getIab_in_addr(handle));
 8003fa2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003fa4:	68dd      	ldr	r5, [r3, #12]
 8003fa6:	68fc      	ldr	r4, [r7, #12]
 8003fa8:	6978      	ldr	r0, [r7, #20]
 8003faa:	f7ff f885 	bl	80030b8 <CTRL_getIab_in_addr>
 8003fae:	4603      	mov	r3, r0
 8003fb0:	4628      	mov	r0, r5
 8003fb2:	4621      	mov	r1, r4
 8003fb4:	461a      	mov	r2, r3
 8003fb6:	f7fe fa2f 	bl	8002418 <CLARKE_run>

	RMP_CNTL_SetTargetValue(obj->rmpcntl_handle,CTRL_getSpd_ref_pu(obj));
 8003fba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003fbc:	f8d3 4224 	ldr.w	r4, [r3, #548]	; 0x224
 8003fc0:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8003fc2:	f7ff f96b 	bl	800329c <CTRL_getSpd_ref_pu>
 8003fc6:	eef0 7a40 	vmov.f32	s15, s0
 8003fca:	4620      	mov	r0, r4
 8003fcc:	eeb0 0a67 	vmov.f32	s0, s15
 8003fd0:	f7fe fdf0 	bl	8002bb4 <RMP_CNTL_SetTargetValue>
	RMP_CNTL_Run(obj->rmpcntl_handle);
 8003fd4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003fd6:	f8d3 3224 	ldr.w	r3, [r3, #548]	; 0x224
 8003fda:	4618      	mov	r0, r3
 8003fdc:	f7fe fe0e 	bl	8002bfc <RMP_CNTL_Run>

	RAMPGEN_SetFreq(obj->rampgen_handle,RMP_CNTL_GetFreq(obj->rmpcntl_handle));
 8003fe0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003fe2:	f8d3 4244 	ldr.w	r4, [r3, #580]	; 0x244
 8003fe6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003fe8:	f8d3 3224 	ldr.w	r3, [r3, #548]	; 0x224
 8003fec:	4618      	mov	r0, r3
 8003fee:	f7fe fdf3 	bl	8002bd8 <RMP_CNTL_GetFreq>
 8003ff2:	eef0 7a40 	vmov.f32	s15, s0
 8003ff6:	4620      	mov	r0, r4
 8003ff8:	eeb0 0a67 	vmov.f32	s0, s15
 8003ffc:	f7fe fe88 	bl	8002d10 <RAMPGEN_SetFreq>
	RAMPGEN_Run(obj->rampgen_handle);
 8004000:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004002:	f8d3 3244 	ldr.w	r3, [r3, #580]	; 0x244
 8004006:	4618      	mov	r0, r3
 8004008:	f7fe feb8 	bl	8002d7c <RAMPGEN_Run>

	// generate the motor electrical angle
	angle_pu = RAMPGEN_GetAngleOut(obj->rampgen_handle);
 800400c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800400e:	f8d3 3244 	ldr.w	r3, [r3, #580]	; 0x244
 8004012:	4618      	mov	r0, r3
 8004014:	f7fe fe6a 	bl	8002cec <RAMPGEN_GetAngleOut>
 8004018:	ed87 0a0c 	vstr	s0, [r7, #48]	; 0x30

	// compute the sin/cos phasor
	CTRL_computePhasor(angle_pu * MATH_TWO_PI,&phasor);
 800401c:	edd7 7a0c 	vldr	s15, [r7, #48]	; 0x30
 8004020:	ed9f 7a50 	vldr	s14, [pc, #320]	; 8004164 <CTRL_runOpenLoop_User+0x1e0>
 8004024:	ee67 7a87 	vmul.f32	s15, s15, s14
 8004028:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800402c:	eeb0 0a67 	vmov.f32	s0, s15
 8004030:	4618      	mov	r0, r3
 8004032:	f7ff fd3f 	bl	8003ab4 <CTRL_computePhasor>

	if(CTRL_doSpeedCtrl(handle))
 8004036:	6978      	ldr	r0, [r7, #20]
 8004038:	f7ff fd76 	bl	8003b28 <CTRL_doSpeedCtrl>
 800403c:	4603      	mov	r3, r0
 800403e:	2b00      	cmp	r3, #0
 8004040:	d034      	beq.n	80040ac <CTRL_runOpenLoop_User+0x128>
	{
		angle_temp_pu = 32768.0f*pQepData->qep_cnt*USER_MOTOR_NUM_POLE_PAIRS;
 8004042:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8004044:	edd3 7a00 	vldr	s15, [r3]
 8004048:	ed9f 7a47 	vldr	s14, [pc, #284]	; 8004168 <CTRL_runOpenLoop_User+0x1e4>
 800404c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8004050:	eeb1 7a00 	vmov.f32	s14, #16
 8004054:	ee67 7a87 	vmul.f32	s15, s15, s14
 8004058:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800405c:	edc7 7a01 	vstr	s15, [r7, #4]
 8004060:	88bb      	ldrh	r3, [r7, #4]
 8004062:	85fb      	strh	r3, [r7, #46]	; 0x2e
		angle_temp_pu &= 0x7FFF;
 8004064:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8004066:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800406a:	85fb      	strh	r3, [r7, #46]	; 0x2e
		angle_pu = angle_temp_pu *0.0000305f;
 800406c:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 8004070:	ee07 3a90 	vmov	s15, r3
 8004074:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8004078:	ed9f 7a3c 	vldr	s14, [pc, #240]	; 800416c <CTRL_runOpenLoop_User+0x1e8>
 800407c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8004080:	edc7 7a0c 	vstr	s15, [r7, #48]	; 0x30
		Speed_SetElecTheta(obj->Speed_handle, angle_pu * MATH_TWO_PI);
 8004084:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004086:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 800408a:	edd7 7a0c 	vldr	s15, [r7, #48]	; 0x30
 800408e:	ed9f 7a35 	vldr	s14, [pc, #212]	; 8004164 <CTRL_runOpenLoop_User+0x1e0>
 8004092:	ee67 7a87 	vmul.f32	s15, s15, s14
 8004096:	4618      	mov	r0, r3
 8004098:	eeb0 0a67 	vmov.f32	s0, s15
 800409c:	f7fe ff40 	bl	8002f20 <Speed_SetElecTheta>
		Speed_Run(obj->Speed_handle);
 80040a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80040a2:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 80040a6:	4618      	mov	r0, r3
 80040a8:	f7fe f8ae 	bl	8002208 <Speed_Run>
	}

	// set
	vdq.value[0] = (0.0f);
 80040ac:	f04f 0300 	mov.w	r3, #0
 80040b0:	61fb      	str	r3, [r7, #28]
	vdq.value[1] = ((15.0f)*RMP_CNTL_GetFreq(obj->rmpcntl_handle));//ESTUN: (10.0), PHASE: (15.0)
 80040b2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80040b4:	f8d3 3224 	ldr.w	r3, [r3, #548]	; 0x224
 80040b8:	4618      	mov	r0, r3
 80040ba:	f7fe fd8d 	bl	8002bd8 <RMP_CNTL_GetFreq>
 80040be:	eeb0 7a40 	vmov.f32	s14, s0
 80040c2:	eef2 7a0e 	vmov.f32	s15, #46	; 0x2e
 80040c6:	ee67 7a27 	vmul.f32	s15, s14, s15
 80040ca:	edc7 7a08 	vstr	s15, [r7, #32]
	if( vdq.value[1] > (0.2f) )
 80040ce:	edd7 7a08 	vldr	s15, [r7, #32]
 80040d2:	ed9f 7a27 	vldr	s14, [pc, #156]	; 8004170 <CTRL_runOpenLoop_User+0x1ec>
 80040d6:	eef4 7ac7 	vcmpe.f32	s15, s14
 80040da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80040de:	dd01      	ble.n	80040e4 <CTRL_runOpenLoop_User+0x160>
	{
		vdq.value[1] = (0.2f);
 80040e0:	4b24      	ldr	r3, [pc, #144]	; (8004174 <CTRL_runOpenLoop_User+0x1f0>)
 80040e2:	623b      	str	r3, [r7, #32]
	}
	CTRL_setVdq_out_pu(obj,&vdq);
 80040e4:	f107 031c 	add.w	r3, r7, #28
 80040e8:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80040ea:	4619      	mov	r1, r3
 80040ec:	f7ff fcca 	bl	8003a84 <CTRL_setVdq_out_pu>

	// set the phasor in the inverse Park transform
	IPARK_setPhasor(obj->iparkHandle,&phasor);
 80040f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80040f2:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
 80040f6:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80040fa:	4610      	mov	r0, r2
 80040fc:	4619      	mov	r1, r3
 80040fe:	f7fe fa9f 	bl	8002640 <IPARK_setPhasor>

	// run the inverse Park module
	IPARK_run(obj->iparkHandle,CTRL_getVdq_out_addr(obj),CTRL_getVab_out_addr(obj));
 8004102:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004104:	f8d3 40a8 	ldr.w	r4, [r3, #168]	; 0xa8
 8004108:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800410a:	f7ff f907 	bl	800331c <CTRL_getVdq_out_addr>
 800410e:	4605      	mov	r5, r0
 8004110:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8004112:	f7ff f8e3 	bl	80032dc <CTRL_getVab_out_addr>
 8004116:	4603      	mov	r3, r0
 8004118:	4620      	mov	r0, r4
 800411a:	4629      	mov	r1, r5
 800411c:	461a      	mov	r2, r3
 800411e:	f7fe fa53 	bl	80025c8 <IPARK_run>

	// run the space Vector Generator (SVGEN) module
	SVGEN_run(obj->svgenHandle,CTRL_getVab_out_addr(obj),&(pPwmData->Tabc));
 8004122:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004124:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8004128:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800412a:	f7ff f8d7 	bl	80032dc <CTRL_getVab_out_addr>
 800412e:	4602      	mov	r2, r0
 8004130:	68bb      	ldr	r3, [r7, #8]
 8004132:	4620      	mov	r0, r4
 8004134:	4611      	mov	r1, r2
 8004136:	461a      	mov	r2, r3
 8004138:	f7fe fc18 	bl	800296c <SVGEN_run>

	obj->Tabc.value[0]=pPwmData->Tabc.value[0];
 800413c:	68bb      	ldr	r3, [r7, #8]
 800413e:	681a      	ldr	r2, [r3, #0]
 8004140:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004142:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
	obj->Tabc.value[1]=pPwmData->Tabc.value[1];
 8004146:	68bb      	ldr	r3, [r7, #8]
 8004148:	685a      	ldr	r2, [r3, #4]
 800414a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800414c:	f8c3 230c 	str.w	r2, [r3, #780]	; 0x30c
	obj->Tabc.value[2]=pPwmData->Tabc.value[2];
 8004150:	68bb      	ldr	r3, [r7, #8]
 8004152:	689a      	ldr	r2, [r3, #8]
 8004154:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004156:	f8c3 2310 	str.w	r2, [r3, #784]	; 0x310

 return;
 800415a:	bf00      	nop
} // end of CTRL_runOnLine_User() function
 800415c:	3738      	adds	r7, #56	; 0x38
 800415e:	46bd      	mov	sp, r7
 8004160:	bdb0      	pop	{r4, r5, r7, pc}
 8004162:	bf00      	nop
 8004164:	40c90fdb 	.word	0x40c90fdb
 8004168:	47000000 	.word	0x47000000
 800416c:	37ffda40 	.word	0x37ffda40
 8004170:	3e4ccccd 	.word	0x3e4ccccd
 8004174:	3e4ccccd 	.word	0x3e4ccccd

08004178 <CTRL_runOnLine_User>:
//! \param[in]  handle    The controller (CTRL) handle
//! \param[in]  pAdcData  The pointer to the ADC data
//! \param[out] pPwmData  The pointer to the PWM data
static inline void CTRL_runOnLine_User(CTRL_Handle handle,HAL_Handle halHandle,
                           const HAL_AdcData_t *pAdcData,HAL_PwmData_t *pPwmData, HAL_QepData_t *pQepData)//! \Mod By Dl.K
{
 8004178:	b5b0      	push	{r4, r5, r7, lr}
 800417a:	b09a      	sub	sp, #104	; 0x68
 800417c:	af00      	add	r7, sp, #0
 800417e:	6178      	str	r0, [r7, #20]
 8004180:	6139      	str	r1, [r7, #16]
 8004182:	60fa      	str	r2, [r7, #12]
 8004184:	60bb      	str	r3, [r7, #8]

 // run the space Vector Generator (SVGEN) module
 SVGEN_run(obj->svgenHandle,CTRL_getVab_out_addr(handle),&(pPwmData->Tabc));
*/

	CTRL_Obj *obj = (CTRL_Obj *)handle;
 8004186:	697b      	ldr	r3, [r7, #20]
 8004188:	663b      	str	r3, [r7, #96]	; 0x60

	MATH_vec2 phasor;


	// run Clarke transform on current
	CLARKE_run(obj->clarkeHandle_I,&pAdcData->I,CTRL_getIab_in_addr(handle));
 800418a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800418c:	68dd      	ldr	r5, [r3, #12]
 800418e:	68fc      	ldr	r4, [r7, #12]
 8004190:	6978      	ldr	r0, [r7, #20]
 8004192:	f7fe ff91 	bl	80030b8 <CTRL_getIab_in_addr>
 8004196:	4603      	mov	r3, r0
 8004198:	4628      	mov	r0, r5
 800419a:	4621      	mov	r1, r4
 800419c:	461a      	mov	r2, r3
 800419e:	f7fe f93b 	bl	8002418 <CLARKE_run>

//	// generate the motor electrical angle
//	angle_pu = EST_getAngle_pu(obj->estHandle);
//	angle_pu = _IQ13toIQ(QEP_read_posn_count(halHandle->qepHandle[0]))*USER_MOTOR_NUM_POLE_PAIRS;
//	angle_pu &= 0xFFFFFF;
	angle_temp_pu = 32768.0f*pQepData->qep_cnt*USER_MOTOR_NUM_POLE_PAIRS;
 80041a2:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80041a4:	edd3 7a00 	vldr	s15, [r3]
 80041a8:	ed9f 7acd 	vldr	s14, [pc, #820]	; 80044e0 <CTRL_runOnLine_User+0x368>
 80041ac:	ee67 7a87 	vmul.f32	s15, s15, s14
 80041b0:	eeb1 7a00 	vmov.f32	s14, #16
 80041b4:	ee67 7a87 	vmul.f32	s15, s15, s14
 80041b8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80041bc:	edc7 7a01 	vstr	s15, [r7, #4]
 80041c0:	88bb      	ldrh	r3, [r7, #4]
 80041c2:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
	angle_temp_pu &= 0x7FFF;
 80041c6:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 80041ca:	f3c3 030e 	ubfx	r3, r3, #0, #15
 80041ce:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
	angle_pu = angle_temp_pu *0.0000305f - obj->angle_offset_pu;
 80041d2:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 80041d6:	ee07 3a90 	vmov	s15, r3
 80041da:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80041de:	ed9f 7ac1 	vldr	s14, [pc, #772]	; 80044e4 <CTRL_runOnLine_User+0x36c>
 80041e2:	ee27 7a87 	vmul.f32	s14, s15, s14
 80041e6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80041e8:	edd3 7a83 	vldr	s15, [r3, #524]	; 0x20c
 80041ec:	ee77 7a67 	vsub.f32	s15, s14, s15
 80041f0:	edc7 7a16 	vstr	s15, [r7, #88]	; 0x58

//	obj->angle_pu = angle_pu;

	// compute the sin/cos phasor
	CTRL_computePhasor(angle_pu * MATH_TWO_PI,&phasor);
 80041f4:	edd7 7a16 	vldr	s15, [r7, #88]	; 0x58
 80041f8:	ed9f 7abb 	vldr	s14, [pc, #748]	; 80044e8 <CTRL_runOnLine_User+0x370>
 80041fc:	ee67 7a87 	vmul.f32	s15, s15, s14
 8004200:	f107 0318 	add.w	r3, r7, #24
 8004204:	eeb0 0a67 	vmov.f32	s0, s15
 8004208:	4618      	mov	r0, r3
 800420a:	f7ff fc53 	bl	8003ab4 <CTRL_computePhasor>


	// set the phasor in the Park transform
	PARK_setPhasor(obj->parkHandle,&phasor);
 800420e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004210:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004212:	f107 0318 	add.w	r3, r7, #24
 8004216:	4610      	mov	r0, r2
 8004218:	4619      	mov	r1, r3
 800421a:	f7fe f9bf 	bl	800259c <PARK_setPhasor>


	// run the Park transform
	PARK_run(obj->parkHandle,CTRL_getIab_in_addr(handle),CTRL_getIdq_in_addr(handle));
 800421e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004220:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 8004222:	6978      	ldr	r0, [r7, #20]
 8004224:	f7fe ff48 	bl	80030b8 <CTRL_getIab_in_addr>
 8004228:	4605      	mov	r5, r0
 800422a:	6978      	ldr	r0, [r7, #20]
 800422c:	f7fe ff78 	bl	8003120 <CTRL_getIdq_in_addr>
 8004230:	4603      	mov	r3, r0
 8004232:	4620      	mov	r0, r4
 8004234:	4629      	mov	r1, r5
 8004236:	461a      	mov	r2, r3
 8004238:	f7fe f974 	bl	8002524 <PARK_run>


	// when appropriate, run the PID speed controller
	if(CTRL_doSpeedCtrl(handle))
 800423c:	6978      	ldr	r0, [r7, #20]
 800423e:	f7ff fc73 	bl	8003b28 <CTRL_doSpeedCtrl>
 8004242:	4603      	mov	r3, r0
 8004244:	2b00      	cmp	r3, #0
 8004246:	d05d      	beq.n	8004304 <CTRL_runOnLine_User+0x18c>
	{
//		float_t refValue = TRAJ_getIntValue(obj->trajHandle_spd);
//		float_t fbackValue = EST_getFm_pu(obj->estHandle);
//		float_t outMax = TRAJ_getIntValue(obj->trajHandle_spdMax);
//		float_t outMin = -outMax;
		float_t refValue = CTRL_getSpd_ref_pu(obj);
 8004248:	6e38      	ldr	r0, [r7, #96]	; 0x60
 800424a:	f7ff f827 	bl	800329c <CTRL_getSpd_ref_pu>
 800424e:	ed87 0a15 	vstr	s0, [r7, #84]	; 0x54
		float_t fbackValue = (0.0f);
 8004252:	f04f 0300 	mov.w	r3, #0
 8004256:	653b      	str	r3, [r7, #80]	; 0x50
		float_t outMax = (0.04f);
 8004258:	4ba4      	ldr	r3, [pc, #656]	; (80044ec <CTRL_runOnLine_User+0x374>)
 800425a:	64fb      	str	r3, [r7, #76]	; 0x4c
		float_t outMin = -outMax;
 800425c:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
 8004260:	eef1 7a67 	vneg.f32	s15, s15
 8004264:	edc7 7a12 	vstr	s15, [r7, #72]	; 0x48
		float_t Kp_Spd = CTRL_getKp(handle,CTRL_Type_PID_spd);
 8004268:	6978      	ldr	r0, [r7, #20]
 800426a:	2100      	movs	r1, #0
 800426c:	f7fe ffb8 	bl	80031e0 <CTRL_getKp>
 8004270:	ed87 0a11 	vstr	s0, [r7, #68]	; 0x44
		float_t Ki_Spd = CTRL_getKi(handle,CTRL_Type_PID_spd);
 8004274:	6978      	ldr	r0, [r7, #20]
 8004276:	2100      	movs	r1, #0
 8004278:	f7fe ff86 	bl	8003188 <CTRL_getKi>
 800427c:	ed87 0a10 	vstr	s0, [r7, #64]	; 0x40

		// reset the speed count
		CTRL_resetCounter_speed(handle);
 8004280:	6978      	ldr	r0, [r7, #20]
 8004282:	f7ff f8fd 	bl	8003480 <CTRL_resetCounter_speed>

		Speed_SetElecTheta(obj->Speed_handle, angle_pu);
 8004286:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004288:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 800428c:	4618      	mov	r0, r3
 800428e:	ed97 0a16 	vldr	s0, [r7, #88]	; 0x58
 8004292:	f7fe fe45 	bl	8002f20 <Speed_SetElecTheta>
		Speed_Run(obj->Speed_handle);
 8004296:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004298:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 800429c:	4618      	mov	r0, r3
 800429e:	f7fd ffb3 	bl	8002208 <Speed_Run>
		fbackValue = Speed_GetElecSpeed(obj->Speed_handle);
 80042a2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80042a4:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 80042a8:	4618      	mov	r0, r3
 80042aa:	f7fe fe7f 	bl	8002fac <Speed_GetElecSpeed>
 80042ae:	ed87 0a14 	vstr	s0, [r7, #80]	; 0x50

		PID_setKp(obj->pidHandle_spd,Kp_Spd);
 80042b2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80042b4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80042b8:	4618      	mov	r0, r3
 80042ba:	ed97 0a11 	vldr	s0, [r7, #68]	; 0x44
 80042be:	f7fe fb1b 	bl	80028f8 <PID_setKp>
		PID_setKi(obj->pidHandle_spd,Ki_Spd);
 80042c2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80042c4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80042c8:	4618      	mov	r0, r3
 80042ca:	ed97 0a10 	vldr	s0, [r7, #64]	; 0x40
 80042ce:	f7fe fb01 	bl	80028d4 <PID_setKi>

		PID_setMinMax(obj->pidHandle_spd,outMin,outMax);
 80042d2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80042d4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80042d8:	4618      	mov	r0, r3
 80042da:	ed97 0a12 	vldr	s0, [r7, #72]	; 0x48
 80042de:	edd7 0a13 	vldr	s1, [r7, #76]	; 0x4c
 80042e2:	f7fe fb1b 	bl	800291c <PID_setMinMax>

		PID_run_spd(obj->pidHandle_spd,refValue,fbackValue,CTRL_getSpd_out_addr(handle));
 80042e6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80042e8:	f8d3 4084 	ldr.w	r4, [r3, #132]	; 0x84
 80042ec:	6978      	ldr	r0, [r7, #20]
 80042ee:	f7fe ffb3 	bl	8003258 <CTRL_getSpd_out_addr>
 80042f2:	4603      	mov	r3, r0
 80042f4:	4620      	mov	r0, r4
 80042f6:	ed97 0a15 	vldr	s0, [r7, #84]	; 0x54
 80042fa:	edd7 0a14 	vldr	s1, [r7, #80]	; 0x50
 80042fe:	4619      	mov	r1, r3
 8004300:	f7fe fa6c 	bl	80027dc <PID_run_spd>
	}


	// when appropriate, run the PID Id and Iq controllers
	if(CTRL_doCurrentCtrl(handle))
 8004304:	6978      	ldr	r0, [r7, #20]
 8004306:	f7ff fbf1 	bl	8003aec <CTRL_doCurrentCtrl>
 800430a:	4603      	mov	r3, r0
 800430c:	2b00      	cmp	r3, #0
 800430e:	f000 8097 	beq.w	8004440 <CTRL_runOnLine_User+0x2c8>
	{
		float_t Kp_Id = CTRL_getKp(handle,CTRL_Type_PID_Id);
 8004312:	6978      	ldr	r0, [r7, #20]
 8004314:	2101      	movs	r1, #1
 8004316:	f7fe ff63 	bl	80031e0 <CTRL_getKp>
 800431a:	ed87 0a0f 	vstr	s0, [r7, #60]	; 0x3c
		float_t Kp_Iq = CTRL_getKp(handle,CTRL_Type_PID_Iq);
 800431e:	6978      	ldr	r0, [r7, #20]
 8004320:	2102      	movs	r1, #2
 8004322:	f7fe ff5d 	bl	80031e0 <CTRL_getKp>
 8004326:	ed87 0a0e 	vstr	s0, [r7, #56]	; 0x38
		float_t Ki_Id = CTRL_getKi(handle,CTRL_Type_PID_Id);
 800432a:	6978      	ldr	r0, [r7, #20]
 800432c:	2101      	movs	r1, #1
 800432e:	f7fe ff2b 	bl	8003188 <CTRL_getKi>
 8004332:	ed87 0a0d 	vstr	s0, [r7, #52]	; 0x34
		float_t Ki_Iq = CTRL_getKi(handle,CTRL_Type_PID_Iq);
 8004336:	6978      	ldr	r0, [r7, #20]
 8004338:	2102      	movs	r1, #2
 800433a:	f7fe ff25 	bl	8003188 <CTRL_getKi>
 800433e:	ed87 0a0c 	vstr	s0, [r7, #48]	; 0x30
		float_t outMin,outMax;


//		// read max voltage vector to set proper limits to current controllers
//		float_t maxVsMag = CTRL_getMaxVsMag_pu(handle);
		float_t maxVsMag = (0.2f);
 8004342:	4b6b      	ldr	r3, [pc, #428]	; (80044f0 <CTRL_runOnLine_User+0x378>)
 8004344:	62fb      	str	r3, [r7, #44]	; 0x2c


		// reset the current count
		CTRL_resetCounter_current(handle);
 8004346:	6978      	ldr	r0, [r7, #20]
 8004348:	f7ff f87a 	bl	8003440 <CTRL_resetCounter_current>
//		if(CTRL_getFlag_enableDcBusComp(handle))
//		{
//			Kp_Id = (Kp_Id*EST_getOneOverDcBus_pu(obj->estHandle));
//		}

		PID_setKp(obj->pidHandle_Id,Kp_Id);
 800434c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800434e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004350:	4618      	mov	r0, r3
 8004352:	ed97 0a0f 	vldr	s0, [r7, #60]	; 0x3c
 8004356:	f7fe facf 	bl	80028f8 <PID_setKp>
		PID_setKi(obj->pidHandle_Id,Ki_Id);
 800435a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800435c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800435e:	4618      	mov	r0, r3
 8004360:	ed97 0a0d 	vldr	s0, [r7, #52]	; 0x34
 8004364:	f7fe fab6 	bl	80028d4 <PID_setKi>

//		// compute the reference value
//		refValue = TRAJ_getIntValue(obj->trajHandle_Id) + CTRL_getId_ref_pu(handle);
		refValue = CTRL_getId_ref_pu(handle);
 8004368:	6978      	ldr	r0, [r7, #20]
 800436a:	f7fe fec7 	bl	80030fc <CTRL_getId_ref_pu>
 800436e:	ed87 0a19 	vstr	s0, [r7, #100]	; 0x64

//		// update the Id reference value
//		EST_updateId_ref_pu(obj->estHandle,&refValue);

		// get the feedback value
		fbackValue = CTRL_getId_in_pu(handle);
 8004372:	6978      	ldr	r0, [r7, #20]
 8004374:	f7fe feb0 	bl	80030d8 <CTRL_getId_in_pu>
 8004378:	ed87 0a0a 	vstr	s0, [r7, #40]	; 0x28

		// set minimum and maximum for Id controller output
		outMax = maxVsMag;
 800437c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800437e:	627b      	str	r3, [r7, #36]	; 0x24
		outMin = -outMax;
 8004380:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8004384:	eef1 7a67 	vneg.f32	s15, s15
 8004388:	edc7 7a08 	vstr	s15, [r7, #32]

		// set the minimum and maximum values
		PID_setMinMax(obj->pidHandle_Id,outMin,outMax);
 800438c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800438e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004390:	4618      	mov	r0, r3
 8004392:	ed97 0a08 	vldr	s0, [r7, #32]
 8004396:	edd7 0a09 	vldr	s1, [r7, #36]	; 0x24
 800439a:	f7fe fabf 	bl	800291c <PID_setMinMax>

		// run the Id PID controller
		PID_run(obj->pidHandle_Id,refValue,fbackValue,CTRL_getVd_out_addr(handle));
 800439e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80043a0:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 80043a2:	6978      	ldr	r0, [r7, #20]
 80043a4:	f7fe ffaa 	bl	80032fc <CTRL_getVd_out_addr>
 80043a8:	4603      	mov	r3, r0
 80043aa:	4620      	mov	r0, r4
 80043ac:	ed97 0a19 	vldr	s0, [r7, #100]	; 0x64
 80043b0:	edd7 0a0a 	vldr	s1, [r7, #40]	; 0x28
 80043b4:	4619      	mov	r1, r3
 80043b6:	f7fe f9b1 	bl	800271c <PID_run>
//		if(CTRL_getFlag_enableDcBusComp(handle))
//		{
//			Kp_Iq = (Kp_Iq*EST_getOneOverDcBus_pu(obj->estHandle));
//		}

		PID_setKp(obj->pidHandle_Iq,Kp_Iq);
 80043ba:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80043bc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80043be:	4618      	mov	r0, r3
 80043c0:	ed97 0a0e 	vldr	s0, [r7, #56]	; 0x38
 80043c4:	f7fe fa98 	bl	80028f8 <PID_setKp>
		PID_setKi(obj->pidHandle_Iq,Ki_Iq);
 80043c8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80043ca:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80043cc:	4618      	mov	r0, r3
 80043ce:	ed97 0a0c 	vldr	s0, [r7, #48]	; 0x30
 80043d2:	f7fe fa7f 	bl	80028d4 <PID_setKi>

		// get the reference value
		if(CTRL_getFlag_enableSpeedCtrl(handle))
 80043d6:	6978      	ldr	r0, [r7, #20]
 80043d8:	f7fe fe5e 	bl	8003098 <CTRL_getFlag_enableSpeedCtrl>
 80043dc:	4603      	mov	r3, r0
 80043de:	2b00      	cmp	r3, #0
 80043e0:	d005      	beq.n	80043ee <CTRL_runOnLine_User+0x276>
		{
			refValue = CTRL_getSpd_out_pu(handle);
 80043e2:	6978      	ldr	r0, [r7, #20]
 80043e4:	f7fe ff48 	bl	8003278 <CTRL_getSpd_out_pu>
 80043e8:	ed87 0a19 	vstr	s0, [r7, #100]	; 0x64
 80043ec:	e004      	b.n	80043f8 <CTRL_runOnLine_User+0x280>
		}
		else
		{
		// get the Iq reference value
			refValue = CTRL_getIq_ref_pu(handle);
 80043ee:	6978      	ldr	r0, [r7, #20]
 80043f0:	f7fe feb8 	bl	8003164 <CTRL_getIq_ref_pu>
 80043f4:	ed87 0a19 	vstr	s0, [r7, #100]	; 0x64
		}

		// get the feedback value
		fbackValue = CTRL_getIq_in_pu(handle);
 80043f8:	6978      	ldr	r0, [r7, #20]
 80043fa:	f7fe fea1 	bl	8003140 <CTRL_getIq_in_pu>
 80043fe:	ed87 0a0a 	vstr	s0, [r7, #40]	; 0x28

//		// set minimum and maximum for Id controller output
//		outMax = sqrtf((maxVsMag*maxVsMag) - (CTRL_getVd_out_pu(handle)*CTRL_getVd_out_pu(handle)));
//		outMin = -outMax;
		outMax = (0.2f);
 8004402:	4b3b      	ldr	r3, [pc, #236]	; (80044f0 <CTRL_runOnLine_User+0x378>)
 8004404:	627b      	str	r3, [r7, #36]	; 0x24
		outMin = -outMax;
 8004406:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 800440a:	eef1 7a67 	vneg.f32	s15, s15
 800440e:	edc7 7a08 	vstr	s15, [r7, #32]

		// set the minimum and maximum values
		PID_setMinMax(obj->pidHandle_Iq,outMin,outMax);
 8004412:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004414:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004416:	4618      	mov	r0, r3
 8004418:	ed97 0a08 	vldr	s0, [r7, #32]
 800441c:	edd7 0a09 	vldr	s1, [r7, #36]	; 0x24
 8004420:	f7fe fa7c 	bl	800291c <PID_setMinMax>

		// run the Iq PID controller
		PID_run(obj->pidHandle_Iq,refValue,fbackValue,CTRL_getVq_out_addr(handle));
 8004424:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004426:	6e1c      	ldr	r4, [r3, #96]	; 0x60
 8004428:	6978      	ldr	r0, [r7, #20]
 800442a:	f7fe ff87 	bl	800333c <CTRL_getVq_out_addr>
 800442e:	4603      	mov	r3, r0
 8004430:	4620      	mov	r0, r4
 8004432:	ed97 0a19 	vldr	s0, [r7, #100]	; 0x64
 8004436:	edd7 0a0a 	vldr	s1, [r7, #40]	; 0x28
 800443a:	4619      	mov	r1, r3
 800443c:	f7fe f96e 	bl	800271c <PID_run>
//		CTRL_computePhasor(angleComp_pu * MATH_TWO_PI,&phasor);
//	}


	// set the phasor in the inverse Park transform
	IPARK_setPhasor(obj->iparkHandle,&phasor);
 8004440:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004442:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
 8004446:	f107 0318 	add.w	r3, r7, #24
 800444a:	4610      	mov	r0, r2
 800444c:	4619      	mov	r1, r3
 800444e:	f7fe f8f7 	bl	8002640 <IPARK_setPhasor>


	// run the inverse Park module
	IPARK_run(obj->iparkHandle,CTRL_getVdq_out_addr(handle),CTRL_getVab_out_addr(handle));
 8004452:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004454:	f8d3 40a8 	ldr.w	r4, [r3, #168]	; 0xa8
 8004458:	6978      	ldr	r0, [r7, #20]
 800445a:	f7fe ff5f 	bl	800331c <CTRL_getVdq_out_addr>
 800445e:	4605      	mov	r5, r0
 8004460:	6978      	ldr	r0, [r7, #20]
 8004462:	f7fe ff3b 	bl	80032dc <CTRL_getVab_out_addr>
 8004466:	4603      	mov	r3, r0
 8004468:	4620      	mov	r0, r4
 800446a:	4629      	mov	r1, r5
 800446c:	461a      	mov	r2, r3
 800446e:	f7fe f8ab 	bl	80025c8 <IPARK_run>


	// run the space Vector Generator (SVGEN) module
	SVGEN_run(obj->svgenHandle,CTRL_getVab_out_addr(handle),&(pPwmData->Tabc));
 8004472:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004474:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8004478:	6978      	ldr	r0, [r7, #20]
 800447a:	f7fe ff2f 	bl	80032dc <CTRL_getVab_out_addr>
 800447e:	4602      	mov	r2, r0
 8004480:	68bb      	ldr	r3, [r7, #8]
 8004482:	4620      	mov	r0, r4
 8004484:	4611      	mov	r1, r2
 8004486:	461a      	mov	r2, r3
 8004488:	f7fe fa70 	bl	800296c <SVGEN_run>


	obj->Tabc.value[0]=pPwmData->Tabc.value[0];
 800448c:	68bb      	ldr	r3, [r7, #8]
 800448e:	681a      	ldr	r2, [r3, #0]
 8004490:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004492:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
	obj->Tabc.value[1]=pPwmData->Tabc.value[1];
 8004496:	68bb      	ldr	r3, [r7, #8]
 8004498:	685a      	ldr	r2, [r3, #4]
 800449a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800449c:	f8c3 230c 	str.w	r2, [r3, #780]	; 0x30c
	obj->Tabc.value[2]=pPwmData->Tabc.value[2];
 80044a0:	68bb      	ldr	r3, [r7, #8]
 80044a2:	689a      	ldr	r2, [r3, #8]
 80044a4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80044a6:	f8c3 2310 	str.w	r2, [r3, #784]	; 0x310
	//	DATA_LOG_Run(obj->datalog_handle);

	obj->MntValue.value[0] = Speed_GetElecSpeed(obj->Speed_handle);
 80044aa:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80044ac:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 80044b0:	4618      	mov	r0, r3
 80044b2:	f7fe fd7b 	bl	8002fac <Speed_GetElecSpeed>
 80044b6:	eef0 7a40 	vmov.f32	s15, s0
 80044ba:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80044bc:	edc3 7ac8 	vstr	s15, [r3, #800]	; 0x320
	obj->MntValue.value[1] = angle_pu;
 80044c0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80044c2:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80044c4:	f8c3 2324 	str.w	r2, [r3, #804]	; 0x324
	obj->MntValue.value[2] = CTRL_getVq_out_pu(handle);
 80044c8:	6978      	ldr	r0, [r7, #20]
 80044ca:	f7fe ff47 	bl	800335c <CTRL_getVq_out_pu>
 80044ce:	eef0 7a40 	vmov.f32	s15, s0
 80044d2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80044d4:	edc3 7aca 	vstr	s15, [r3, #808]	; 0x328

return;
 80044d8:	bf00      	nop
} // end of CTRL_runOnLine_User() function
 80044da:	3768      	adds	r7, #104	; 0x68
 80044dc:	46bd      	mov	sp, r7
 80044de:	bdb0      	pop	{r4, r5, r7, pc}
 80044e0:	47000000 	.word	0x47000000
 80044e4:	37ffda40 	.word	0x37ffda40
 80044e8:	40c90fdb 	.word	0x40c90fdb
 80044ec:	3d23d70a 	.word	0x3d23d70a
 80044f0:	3e4ccccd 	.word	0x3e4ccccd

080044f4 <CTRL_run>:

void CTRL_run(CTRL_Handle handle,HAL_Handle halHandle,
              const HAL_AdcData_t *pAdcData,
              HAL_PwmData_t *pPwmData,
							HAL_QepData_t *pQepData)
{
 80044f4:	b580      	push	{r7, lr}
 80044f6:	b088      	sub	sp, #32
 80044f8:	af02      	add	r7, sp, #8
 80044fa:	60f8      	str	r0, [r7, #12]
 80044fc:	60b9      	str	r1, [r7, #8]
 80044fe:	607a      	str	r2, [r7, #4]
 8004500:	603b      	str	r3, [r7, #0]
      CTRL_incrCounter_isr(handle);
    }
*/

	//! \Mod By Dl.K
	uint_least16_t count_isr = CTRL_getCount_isr(handle);
 8004502:	68f8      	ldr	r0, [r7, #12]
 8004504:	f7fe fda8 	bl	8003058 <CTRL_getCount_isr>
 8004508:	4603      	mov	r3, r0
 800450a:	82fb      	strh	r3, [r7, #22]
	uint_least16_t numIsrTicksPerCtrlTick = CTRL_getNumIsrTicksPerCtrlTick(handle);
 800450c:	68f8      	ldr	r0, [r7, #12]
 800450e:	f7fe fe93 	bl	8003238 <CTRL_getNumIsrTicksPerCtrlTick>
 8004512:	4603      	mov	r3, r0
 8004514:	82bb      	strh	r3, [r7, #20]

	// if needed, run the controller
	if(count_isr >= numIsrTicksPerCtrlTick)
 8004516:	8afa      	ldrh	r2, [r7, #22]
 8004518:	8abb      	ldrh	r3, [r7, #20]
 800451a:	429a      	cmp	r2, r3
 800451c:	d37c      	bcc.n	8004618 <CTRL_run+0x124>
	{
		CTRL_State_e ctrlState = CTRL_getState(handle);
 800451e:	68f8      	ldr	r0, [r7, #12]
 8004520:	f7fe fece 	bl	80032c0 <CTRL_getState>
 8004524:	4603      	mov	r3, r0
 8004526:	74fb      	strb	r3, [r7, #19]

		// reset the isr count
		CTRL_resetCounter_isr(handle);
 8004528:	68f8      	ldr	r0, [r7, #12]
 800452a:	f7fe ff99 	bl	8003460 <CTRL_resetCounter_isr>

		// increment the state counter
		//CTRL_incrCounter_state(handle);

		// increment the trajectory count
		CTRL_incrCounter_traj(handle);
 800452e:	68f8      	ldr	r0, [r7, #12]
 8004530:	f7fe ff6e 	bl	8003410 <CTRL_incrCounter_traj>
		// run the appropriate controller
		if(ctrlState == CTRL_State_Error)
 8004534:	7cfb      	ldrb	r3, [r7, #19]
 8004536:	2b00      	cmp	r3, #0
 8004538:	d06d      	beq.n	8004616 <CTRL_run+0x122>
		{
			// run the Error controller
			
		}
		else if(ctrlState == CTRL_State_Idle)
 800453a:	7cfb      	ldrb	r3, [r7, #19]
 800453c:	2b01      	cmp	r3, #1
 800453e:	d108      	bne.n	8004552 <CTRL_run+0x5e>
		{
			// run the Idle controller
			CTRL_runOffLine(handle,halHandle,pAdcData,pPwmData,pQepData);
 8004540:	6a3b      	ldr	r3, [r7, #32]
 8004542:	9300      	str	r3, [sp, #0]
 8004544:	68f8      	ldr	r0, [r7, #12]
 8004546:	68b9      	ldr	r1, [r7, #8]
 8004548:	687a      	ldr	r2, [r7, #4]
 800454a:	683b      	ldr	r3, [r7, #0]
 800454c:	f7ff fb06 	bl	8003b5c <CTRL_runOffLine>
 8004550:	e061      	b.n	8004616 <CTRL_run+0x122>
		}
		else if(ctrlState == CTRL_State_OffLine)
 8004552:	7cfb      	ldrb	r3, [r7, #19]
 8004554:	2b02      	cmp	r3, #2
 8004556:	d108      	bne.n	800456a <CTRL_run+0x76>
		{
			// run the offline controller
			CTRL_runOffLine(handle,halHandle,pAdcData,pPwmData,pQepData);
 8004558:	6a3b      	ldr	r3, [r7, #32]
 800455a:	9300      	str	r3, [sp, #0]
 800455c:	68f8      	ldr	r0, [r7, #12]
 800455e:	68b9      	ldr	r1, [r7, #8]
 8004560:	687a      	ldr	r2, [r7, #4]
 8004562:	683b      	ldr	r3, [r7, #0]
 8004564:	f7ff fafa 	bl	8003b5c <CTRL_runOffLine>
 8004568:	e055      	b.n	8004616 <CTRL_run+0x122>
		}
		else if(ctrlState == CTRL_State_InitDete)
 800456a:	7cfb      	ldrb	r3, [r7, #19]
 800456c:	2b04      	cmp	r3, #4
 800456e:	d108      	bne.n	8004582 <CTRL_run+0x8e>
		{
			// run the InitDete controller
			CTRL_runInitDete_User(handle,halHandle,pAdcData,pPwmData,pQepData);
 8004570:	6a3b      	ldr	r3, [r7, #32]
 8004572:	9300      	str	r3, [sp, #0]
 8004574:	68f8      	ldr	r0, [r7, #12]
 8004576:	68b9      	ldr	r1, [r7, #8]
 8004578:	687a      	ldr	r2, [r7, #4]
 800457a:	683b      	ldr	r3, [r7, #0]
 800457c:	f7ff fb28 	bl	8003bd0 <CTRL_runInitDete_User>
 8004580:	e049      	b.n	8004616 <CTRL_run+0x122>
		}
		else if(ctrlState == CTRL_State_StaticStatorInitDete)
 8004582:	7cfb      	ldrb	r3, [r7, #19]
 8004584:	2b05      	cmp	r3, #5
 8004586:	d108      	bne.n	800459a <CTRL_run+0xa6>
		{
			// run the StaticStatorInitDete controller
			CTRL_runStaticStatorInitDete_User(handle,halHandle,pAdcData,pPwmData,pQepData);
 8004588:	6a3b      	ldr	r3, [r7, #32]
 800458a:	9300      	str	r3, [sp, #0]
 800458c:	68f8      	ldr	r0, [r7, #12]
 800458e:	68b9      	ldr	r1, [r7, #8]
 8004590:	687a      	ldr	r2, [r7, #4]
 8004592:	683b      	ldr	r3, [r7, #0]
 8004594:	f7ff fbd0 	bl	8003d38 <CTRL_runStaticStatorInitDete_User>
 8004598:	e03d      	b.n	8004616 <CTRL_run+0x122>
		}
		else if(ctrlState == CTRL_State_OpenLoop)
 800459a:	7cfb      	ldrb	r3, [r7, #19]
 800459c:	2b06      	cmp	r3, #6
 800459e:	d10b      	bne.n	80045b8 <CTRL_run+0xc4>
		{
			// increment the speed count
			CTRL_incrCounter_speed(handle);
 80045a0:	68f8      	ldr	r0, [r7, #12]
 80045a2:	f7fe ff1d 	bl	80033e0 <CTRL_incrCounter_speed>

			CTRL_runOpenLoop_User(handle,halHandle,pAdcData,pPwmData,pQepData);
 80045a6:	6a3b      	ldr	r3, [r7, #32]
 80045a8:	9300      	str	r3, [sp, #0]
 80045aa:	68f8      	ldr	r0, [r7, #12]
 80045ac:	68b9      	ldr	r1, [r7, #8]
 80045ae:	687a      	ldr	r2, [r7, #4]
 80045b0:	683b      	ldr	r3, [r7, #0]
 80045b2:	f7ff fce7 	bl	8003f84 <CTRL_runOpenLoop_User>
 80045b6:	e02e      	b.n	8004616 <CTRL_run+0x122>
		}
		else if(ctrlState == CTRL_State_OnLine || ctrlState == CTRL_State_CurrentCloseLoop || ctrlState == CTRL_State_SpeedCloseLoop )
 80045b8:	7cfb      	ldrb	r3, [r7, #19]
 80045ba:	2b07      	cmp	r3, #7
 80045bc:	d005      	beq.n	80045ca <CTRL_run+0xd6>
 80045be:	7cfb      	ldrb	r3, [r7, #19]
 80045c0:	2b08      	cmp	r3, #8
 80045c2:	d002      	beq.n	80045ca <CTRL_run+0xd6>
 80045c4:	7cfb      	ldrb	r3, [r7, #19]
 80045c6:	2b09      	cmp	r3, #9
 80045c8:	d125      	bne.n	8004616 <CTRL_run+0x122>
		{
			//CTRL_Obj *obj = (CTRL_Obj *)handle;

			// increment the current count
			CTRL_incrCounter_current(handle);
 80045ca:	68f8      	ldr	r0, [r7, #12]
 80045cc:	f7fe fed8 	bl	8003380 <CTRL_incrCounter_current>

			// increment the speed count
			CTRL_incrCounter_speed(handle);
 80045d0:	68f8      	ldr	r0, [r7, #12]
 80045d2:	f7fe ff05 	bl	80033e0 <CTRL_incrCounter_speed>

			if( ctrlState == CTRL_State_CurrentCloseLoop )
 80045d6:	7cfb      	ldrb	r3, [r7, #19]
 80045d8:	2b08      	cmp	r3, #8
 80045da:	d108      	bne.n	80045ee <CTRL_run+0xfa>
			{
				CTRL_setFlag_enableCurrentCtrl(handle,true);
 80045dc:	68f8      	ldr	r0, [r7, #12]
 80045de:	2101      	movs	r1, #1
 80045e0:	f7fe ffd0 	bl	8003584 <CTRL_setFlag_enableCurrentCtrl>
				CTRL_setFlag_enableSpeedCtrl(handle,false);
 80045e4:	68f8      	ldr	r0, [r7, #12]
 80045e6:	2100      	movs	r1, #0
 80045e8:	f7ff f814 	bl	8003614 <CTRL_setFlag_enableSpeedCtrl>
 80045ec:	e00a      	b.n	8004604 <CTRL_run+0x110>
			}
			else if( ctrlState == CTRL_State_SpeedCloseLoop )
 80045ee:	7cfb      	ldrb	r3, [r7, #19]
 80045f0:	2b09      	cmp	r3, #9
 80045f2:	d107      	bne.n	8004604 <CTRL_run+0x110>
			{
				CTRL_setFlag_enableCurrentCtrl(handle,true);
 80045f4:	68f8      	ldr	r0, [r7, #12]
 80045f6:	2101      	movs	r1, #1
 80045f8:	f7fe ffc4 	bl	8003584 <CTRL_setFlag_enableCurrentCtrl>
				CTRL_setFlag_enableSpeedCtrl(handle,true);
 80045fc:	68f8      	ldr	r0, [r7, #12]
 80045fe:	2101      	movs	r1, #1
 8004600:	f7ff f808 	bl	8003614 <CTRL_setFlag_enableSpeedCtrl>
			}
			//if(EST_getState(obj->estHandle) >= EST_State_MotorIdentified)
			//{
				// run the online controller
				CTRL_runOnLine_User(handle,halHandle,pAdcData,pPwmData,pQepData);
 8004604:	6a3b      	ldr	r3, [r7, #32]
 8004606:	9300      	str	r3, [sp, #0]
 8004608:	68f8      	ldr	r0, [r7, #12]
 800460a:	68b9      	ldr	r1, [r7, #8]
 800460c:	687a      	ldr	r2, [r7, #4]
 800460e:	683b      	ldr	r3, [r7, #0]
 8004610:	f7ff fdb2 	bl	8004178 <CTRL_runOnLine_User>
 8004614:	e003      	b.n	800461e <CTRL_run+0x12a>
 8004616:	e002      	b.n	800461e <CTRL_run+0x12a>

	}
	else
	{
		// increment the isr count
		CTRL_incrCounter_isr(handle);
 8004618:	68f8      	ldr	r0, [r7, #12]
 800461a:	f7fe fec9 	bl	80033b0 <CTRL_incrCounter_isr>
	}

  return;
 800461e:	bf00      	nop
} // end of CTRL_run() function
 8004620:	3718      	adds	r7, #24
 8004622:	46bd      	mov	sp, r7
 8004624:	bd80      	pop	{r7, pc}
 8004626:	bf00      	nop

08004628 <CTRL_setGains>:


void CTRL_setGains(CTRL_Handle handle,const CTRL_Type_e ctrlType,
                   const float_t Kp,const float_t Ki,const float_t Kd)
{
 8004628:	b580      	push	{r7, lr}
 800462a:	b086      	sub	sp, #24
 800462c:	af00      	add	r7, sp, #0
 800462e:	6178      	str	r0, [r7, #20]
 8004630:	460b      	mov	r3, r1
 8004632:	ed87 0a03 	vstr	s0, [r7, #12]
 8004636:	edc7 0a02 	vstr	s1, [r7, #8]
 800463a:	ed87 1a01 	vstr	s2, [r7, #4]
 800463e:	74fb      	strb	r3, [r7, #19]

  CTRL_setKp(handle,ctrlType,Kp);
 8004640:	7cfb      	ldrb	r3, [r7, #19]
 8004642:	6978      	ldr	r0, [r7, #20]
 8004644:	4619      	mov	r1, r3
 8004646:	ed97 0a03 	vldr	s0, [r7, #12]
 800464a:	f7ff f8b1 	bl	80037b0 <CTRL_setKp>
  CTRL_setKi(handle,ctrlType,Ki);
 800464e:	7cfb      	ldrb	r3, [r7, #19]
 8004650:	6978      	ldr	r0, [r7, #20]
 8004652:	4619      	mov	r1, r3
 8004654:	ed97 0a02 	vldr	s0, [r7, #8]
 8004658:	f7ff f882 	bl	8003760 <CTRL_setKi>
  CTRL_setKd(handle,ctrlType,Kd);
 800465c:	7cfb      	ldrb	r3, [r7, #19]
 800465e:	6978      	ldr	r0, [r7, #20]
 8004660:	4619      	mov	r1, r3
 8004662:	ed97 0a01 	vldr	s0, [r7, #4]
 8004666:	f7ff f853 	bl	8003710 <CTRL_setKd>

  return;    
 800466a:	bf00      	nop
} // end of CTRL_setGains() function
 800466c:	3718      	adds	r7, #24
 800466e:	46bd      	mov	sp, r7
 8004670:	bd80      	pop	{r7, pc}
 8004672:	bf00      	nop

08004674 <CTRL_init>:
  return;    
} // end of CTRL_setMaximumSpeed_pu() function


CTRL_Handle CTRL_init(void *pMemory, const size_t numBytes)
{
 8004674:	b580      	push	{r7, lr}
 8004676:	b084      	sub	sp, #16
 8004678:	af00      	add	r7, sp, #0
 800467a:	6078      	str	r0, [r7, #4]
 800467c:	6039      	str	r1, [r7, #0]
	CTRL_Handle handle;
	CTRL_Obj *obj;


	if (numBytes < sizeof(CTRL_Obj))
 800467e:	683b      	ldr	r3, [r7, #0]
 8004680:	f5b3 7f4b 	cmp.w	r3, #812	; 0x32c
 8004684:	d201      	bcs.n	800468a <CTRL_init+0x16>
		return((CTRL_Handle)NULL);
 8004686:	2300      	movs	r3, #0
 8004688:	e0a4      	b.n	80047d4 <CTRL_init+0x160>


	// assign the handle
	handle = (CTRL_Handle)pMemory;
 800468a:	687b      	ldr	r3, [r7, #4]
 800468c:	60fb      	str	r3, [r7, #12]


	// assign the object
	obj = (CTRL_Obj *)handle;
 800468e:	68fb      	ldr	r3, [r7, #12]
 8004690:	60bb      	str	r3, [r7, #8]


	obj->clarkeHandle_I = CLARKE_init(&obj->clarke_I, sizeof(obj->clarke_I));
 8004692:	68bb      	ldr	r3, [r7, #8]
 8004694:	3310      	adds	r3, #16
 8004696:	4618      	mov	r0, r3
 8004698:	210c      	movs	r1, #12
 800469a:	f7fd fe5f 	bl	800235c <CLARKE_init>
 800469e:	4602      	mov	r2, r0
 80046a0:	68bb      	ldr	r3, [r7, #8]
 80046a2:	60da      	str	r2, [r3, #12]
	obj->clarkeHandle_V = CLARKE_init(&obj->clarke_V, sizeof(obj->clarke_V));
 80046a4:	68bb      	ldr	r3, [r7, #8]
 80046a6:	3320      	adds	r3, #32
 80046a8:	4618      	mov	r0, r3
 80046aa:	210c      	movs	r1, #12
 80046ac:	f7fd fe56 	bl	800235c <CLARKE_init>
 80046b0:	4602      	mov	r2, r0
 80046b2:	68bb      	ldr	r3, [r7, #8]
 80046b4:	61da      	str	r2, [r3, #28]


	obj->parkHandle = PARK_init(&obj->park, sizeof(obj->park));
 80046b6:	68bb      	ldr	r3, [r7, #8]
 80046b8:	3334      	adds	r3, #52	; 0x34
 80046ba:	4618      	mov	r0, r3
 80046bc:	2108      	movs	r1, #8
 80046be:	f001 fb19 	bl	8005cf4 <PARK_init>
 80046c2:	4602      	mov	r2, r0
 80046c4:	68bb      	ldr	r3, [r7, #8]
 80046c6:	631a      	str	r2, [r3, #48]	; 0x30


	// initialize the Id PI controller module
	obj->pidHandle_Id = PID_init(&obj->pid_Id, sizeof(obj->pid_Id));
 80046c8:	68bb      	ldr	r3, [r7, #8]
 80046ca:	3340      	adds	r3, #64	; 0x40
 80046cc:	4618      	mov	r0, r3
 80046ce:	2120      	movs	r1, #32
 80046d0:	f001 fb5a 	bl	8005d88 <PID_init>
 80046d4:	4602      	mov	r2, r0
 80046d6:	68bb      	ldr	r3, [r7, #8]
 80046d8:	63da      	str	r2, [r3, #60]	; 0x3c


	// initialize the Iq PI controller module
	obj->pidHandle_Iq = PID_init(&obj->pid_Iq, sizeof(obj->pid_Iq));
 80046da:	68bb      	ldr	r3, [r7, #8]
 80046dc:	3364      	adds	r3, #100	; 0x64
 80046de:	4618      	mov	r0, r3
 80046e0:	2120      	movs	r1, #32
 80046e2:	f001 fb51 	bl	8005d88 <PID_init>
 80046e6:	4602      	mov	r2, r0
 80046e8:	68bb      	ldr	r3, [r7, #8]
 80046ea:	661a      	str	r2, [r3, #96]	; 0x60


	// initialize the speed PI controller module
	obj->pidHandle_spd = PID_init(&obj->pid_spd, sizeof(obj->pid_spd));
 80046ec:	68bb      	ldr	r3, [r7, #8]
 80046ee:	3388      	adds	r3, #136	; 0x88
 80046f0:	4618      	mov	r0, r3
 80046f2:	2120      	movs	r1, #32
 80046f4:	f001 fb48 	bl	8005d88 <PID_init>
 80046f8:	4602      	mov	r2, r0
 80046fa:	68bb      	ldr	r3, [r7, #8]
 80046fc:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

	
	obj->iparkHandle = IPARK_init(&obj->ipark, sizeof(obj->ipark));
 8004700:	68bb      	ldr	r3, [r7, #8]
 8004702:	33ac      	adds	r3, #172	; 0xac
 8004704:	4618      	mov	r0, r3
 8004706:	2108      	movs	r1, #8
 8004708:	f001 fa70 	bl	8005bec <IPARK_init>
 800470c:	4602      	mov	r2, r0
 800470e:	68bb      	ldr	r3, [r7, #8]
 8004710:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8


	obj->svgenHandle = SVGEN_init(&obj->svgen, sizeof(obj->svgen)); 
 8004714:	68bb      	ldr	r3, [r7, #8]
 8004716:	33b8      	adds	r3, #184	; 0xb8
 8004718:	4618      	mov	r0, r3
 800471a:	2104      	movs	r1, #4
 800471c:	f001 fbb0 	bl	8005e80 <SVGEN_init>
 8004720:	4602      	mov	r2, r0
 8004722:	68bb      	ldr	r3, [r7, #8]
 8004724:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4


	obj->trajHandle_Id = TRAJ_init(&obj->traj_Id, sizeof(obj->traj_Id));
 8004728:	68bb      	ldr	r3, [r7, #8]
 800472a:	33c0      	adds	r3, #192	; 0xc0
 800472c:	4618      	mov	r0, r3
 800472e:	2114      	movs	r1, #20
 8004730:	f001 fbba 	bl	8005ea8 <TRAJ_init>
 8004734:	4602      	mov	r2, r0
 8004736:	68bb      	ldr	r3, [r7, #8]
 8004738:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc


	obj->trajHandle_spd = TRAJ_init(&obj->traj_spd, sizeof(obj->traj_spd));
 800473c:	68bb      	ldr	r3, [r7, #8]
 800473e:	33d8      	adds	r3, #216	; 0xd8
 8004740:	4618      	mov	r0, r3
 8004742:	2114      	movs	r1, #20
 8004744:	f001 fbb0 	bl	8005ea8 <TRAJ_init>
 8004748:	4602      	mov	r2, r0
 800474a:	68bb      	ldr	r3, [r7, #8]
 800474c:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4


	obj->trajHandle_spdMax = TRAJ_init(&obj->traj_spdMax, sizeof(obj->traj_spdMax));
 8004750:	68bb      	ldr	r3, [r7, #8]
 8004752:	33f0      	adds	r3, #240	; 0xf0
 8004754:	4618      	mov	r0, r3
 8004756:	2114      	movs	r1, #20
 8004758:	f001 fba6 	bl	8005ea8 <TRAJ_init>
 800475c:	4602      	mov	r2, r0
 800475e:	68bb      	ldr	r3, [r7, #8]
 8004760:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec


	obj->rmpcntl_handle = RMP_CNTL_Init(&obj->rmpcntl, sizeof(obj->rmpcntl));
 8004764:	68bb      	ldr	r3, [r7, #8]
 8004766:	f503 730a 	add.w	r3, r3, #552	; 0x228
 800476a:	4618      	mov	r0, r3
 800476c:	211c      	movs	r1, #28
 800476e:	f001 fb59 	bl	8005e24 <RMP_CNTL_Init>
 8004772:	4602      	mov	r2, r0
 8004774:	68bb      	ldr	r3, [r7, #8]
 8004776:	f8c3 2224 	str.w	r2, [r3, #548]	; 0x224


	obj->rampgen_handle = RAMPGEN_Init(&obj->rampgen, sizeof(obj->rampgen));
 800477a:	68bb      	ldr	r3, [r7, #8]
 800477c:	f503 7312 	add.w	r3, r3, #584	; 0x248
 8004780:	4618      	mov	r0, r3
 8004782:	2118      	movs	r1, #24
 8004784:	f001 fb22 	bl	8005dcc <RAMPGEN_Init>
 8004788:	4602      	mov	r2, r0
 800478a:	68bb      	ldr	r3, [r7, #8]
 800478c:	f8c3 2244 	str.w	r2, [r3, #580]	; 0x244


	obj->data_rtxd_handle = DATA_RTXD_Init(&obj->data_rtxd, sizeof(obj->data_rtxd));
 8004790:	68bb      	ldr	r3, [r7, #8]
 8004792:	f503 7319 	add.w	r3, r3, #612	; 0x264
 8004796:	4618      	mov	r0, r3
 8004798:	211e      	movs	r1, #30
 800479a:	f000 fb9f 	bl	8004edc <DATA_RTXD_Init>
 800479e:	4602      	mov	r2, r0
 80047a0:	68bb      	ldr	r3, [r7, #8]
 80047a2:	f8c3 2260 	str.w	r2, [r3, #608]	; 0x260


	obj->InitPosDet_handle = INITPOSDET_Init(&obj->InitPosDet, sizeof(obj->InitPosDet));
 80047a6:	68bb      	ldr	r3, [r7, #8]
 80047a8:	f503 7322 	add.w	r3, r3, #648	; 0x288
 80047ac:	4618      	mov	r0, r3
 80047ae:	2160      	movs	r1, #96	; 0x60
 80047b0:	f7fc ff2a 	bl	8001608 <INITPOSDET_Init>
 80047b4:	4602      	mov	r2, r0
 80047b6:	68bb      	ldr	r3, [r7, #8]
 80047b8:	f8c3 2284 	str.w	r2, [r3, #644]	; 0x284


	obj->Speed_handle = Speed_Init(&obj->Speed, sizeof(obj->Speed));
 80047bc:	68bb      	ldr	r3, [r7, #8]
 80047be:	f503 733b 	add.w	r3, r3, #748	; 0x2ec
 80047c2:	4618      	mov	r0, r3
 80047c4:	211c      	movs	r1, #28
 80047c6:	f7fd fcef 	bl	80021a8 <Speed_Init>
 80047ca:	4602      	mov	r2, r0
 80047cc:	68bb      	ldr	r3, [r7, #8]
 80047ce:	f8c3 22e8 	str.w	r2, [r3, #744]	; 0x2e8


	return(handle);
 80047d2:	68fb      	ldr	r3, [r7, #12]
} // end of CTRL_init() function
 80047d4:	4618      	mov	r0, r3
 80047d6:	3710      	adds	r7, #16
 80047d8:	46bd      	mov	sp, r7
 80047da:	bd80      	pop	{r7, pc}

080047dc <CTRL_setParams>:


void CTRL_setParams(CTRL_Handle handle,USER_Params *pUserParams)
{
 80047dc:	b580      	push	{r7, lr}
 80047de:	b096      	sub	sp, #88	; 0x58
 80047e0:	af00      	add	r7, sp, #0
 80047e2:	6078      	str	r0, [r7, #4]
 80047e4:	6039      	str	r1, [r7, #0]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 80047e6:	687b      	ldr	r3, [r7, #4]
 80047e8:	657b      	str	r3, [r7, #84]	; 0x54

  float_t Kp,Ki,Kd;
  float_t outMin,outMax;
  float_t maxModulation;

  MATH_vec2 Iab_out_pu = {(0.0f),(0.0f)};
 80047ea:	f04f 0300 	mov.w	r3, #0
 80047ee:	637b      	str	r3, [r7, #52]	; 0x34
 80047f0:	f04f 0300 	mov.w	r3, #0
 80047f4:	63bb      	str	r3, [r7, #56]	; 0x38
  MATH_vec2 Idq_out_pu = {(0.0f),(0.0f)};
 80047f6:	f04f 0300 	mov.w	r3, #0
 80047fa:	62fb      	str	r3, [r7, #44]	; 0x2c
 80047fc:	f04f 0300 	mov.w	r3, #0
 8004800:	633b      	str	r3, [r7, #48]	; 0x30
  MATH_vec2 Idq_ref_pu = {(0.0f),(0.0f)};
 8004802:	f04f 0300 	mov.w	r3, #0
 8004806:	627b      	str	r3, [r7, #36]	; 0x24
 8004808:	f04f 0300 	mov.w	r3, #0
 800480c:	62bb      	str	r3, [r7, #40]	; 0x28
  MATH_vec2 Vab_in_pu  = {(0.0f),(0.0f)};
 800480e:	f04f 0300 	mov.w	r3, #0
 8004812:	61fb      	str	r3, [r7, #28]
 8004814:	f04f 0300 	mov.w	r3, #0
 8004818:	623b      	str	r3, [r7, #32]
  MATH_vec2 Vab_out_pu = {(0.0f),(0.0f)};
 800481a:	f04f 0300 	mov.w	r3, #0
 800481e:	617b      	str	r3, [r7, #20]
 8004820:	f04f 0300 	mov.w	r3, #0
 8004824:	61bb      	str	r3, [r7, #24]
  MATH_vec2 Vdq_out_pu = {(0.0f),(0.0f)};
 8004826:	f04f 0300 	mov.w	r3, #0
 800482a:	60fb      	str	r3, [r7, #12]
 800482c:	f04f 0300 	mov.w	r3, #0
 8004830:	613b      	str	r3, [r7, #16]


  // assign the motor type
  CTRL_setMotorParams(handle,pUserParams->motor_type,
 8004832:	683b      	ldr	r3, [r7, #0]
 8004834:	f893 1064 	ldrb.w	r1, [r3, #100]	; 0x64
 8004838:	683b      	ldr	r3, [r7, #0]
 800483a:	f8b3 2066 	ldrh.w	r2, [r3, #102]	; 0x66
 800483e:	683b      	ldr	r3, [r7, #0]
 8004840:	edd3 5a1a 	vldr	s11, [r3, #104]	; 0x68
 8004844:	683b      	ldr	r3, [r7, #0]
 8004846:	ed93 6a1d 	vldr	s12, [r3, #116]	; 0x74
 800484a:	683b      	ldr	r3, [r7, #0]
 800484c:	edd3 6a1e 	vldr	s13, [r3, #120]	; 0x78
 8004850:	683b      	ldr	r3, [r7, #0]
 8004852:	ed93 7a1b 	vldr	s14, [r3, #108]	; 0x6c
 8004856:	683b      	ldr	r3, [r7, #0]
 8004858:	edd3 7a1c 	vldr	s15, [r3, #112]	; 0x70
 800485c:	6878      	ldr	r0, [r7, #4]
 800485e:	eeb0 0a65 	vmov.f32	s0, s11
 8004862:	eef0 0a46 	vmov.f32	s1, s12
 8004866:	eeb0 1a66 	vmov.f32	s2, s13
 800486a:	eef0 1a47 	vmov.f32	s3, s14
 800486e:	eeb0 2a67 	vmov.f32	s4, s15
 8004872:	f7fe ffe9 	bl	8003848 <CTRL_setMotorParams>
                      pUserParams->motor_Rr,
                      pUserParams->motor_Rs);


  // assign other controller parameters
  CTRL_setNumIsrTicksPerCtrlTick(handle,pUserParams->numIsrTicksPerCtrlTick);
 8004876:	683b      	ldr	r3, [r7, #0]
 8004878:	899b      	ldrh	r3, [r3, #12]
 800487a:	6878      	ldr	r0, [r7, #4]
 800487c:	4619      	mov	r1, r3
 800487e:	f7ff f84f 	bl	8003920 <CTRL_setNumIsrTicksPerCtrlTick>
  CTRL_setNumCtrlTicksPerCurrentTick(handle,pUserParams->numCtrlTicksPerCurrentTick);
 8004882:	683b      	ldr	r3, [r7, #0]
 8004884:	89db      	ldrh	r3, [r3, #14]
 8004886:	6878      	ldr	r0, [r7, #4]
 8004888:	4619      	mov	r1, r3
 800488a:	f7ff f813 	bl	80038b4 <CTRL_setNumCtrlTicksPerCurrentTick>
  CTRL_setNumCtrlTicksPerSpeedTick(handle,pUserParams->numCtrlTicksPerSpeedTick);
 800488e:	683b      	ldr	r3, [r7, #0]
 8004890:	8a5b      	ldrh	r3, [r3, #18]
 8004892:	6878      	ldr	r0, [r7, #4]
 8004894:	4619      	mov	r1, r3
 8004896:	f7ff f81f 	bl	80038d8 <CTRL_setNumCtrlTicksPerSpeedTick>
  CTRL_setNumCtrlTicksPerTrajTick(handle,pUserParams->numCtrlTicksPerTrajTick);
 800489a:	683b      	ldr	r3, [r7, #0]
 800489c:	8a9b      	ldrh	r3, [r3, #20]
 800489e:	6878      	ldr	r0, [r7, #4]
 80048a0:	4619      	mov	r1, r3
 80048a2:	f7ff f82b 	bl	80038fc <CTRL_setNumCtrlTicksPerTrajTick>

  CTRL_setCtrlFreq_Hz(handle,pUserParams->ctrlFreq_Hz);
 80048a6:	683b      	ldr	r3, [r7, #0]
 80048a8:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 80048ac:	6878      	ldr	r0, [r7, #4]
 80048ae:	4619      	mov	r1, r3
 80048b0:	f7fe fe16 	bl	80034e0 <CTRL_setCtrlFreq_Hz>
  CTRL_setTrajFreq_Hz(handle,pUserParams->trajFreq_Hz);
 80048b4:	683b      	ldr	r3, [r7, #0]
 80048b6:	edd3 7a57 	vldr	s15, [r3, #348]	; 0x15c
 80048ba:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80048be:	6878      	ldr	r0, [r7, #4]
 80048c0:	ee17 1a90 	vmov	r1, s15
 80048c4:	f7ff f88a 	bl	80039dc <CTRL_setTrajFreq_Hz>
  CTRL_setTrajPeriod_sec(handle,(1.0/pUserParams->trajFreq_Hz));
 80048c8:	683b      	ldr	r3, [r7, #0]
 80048ca:	edd3 7a57 	vldr	s15, [r3, #348]	; 0x15c
 80048ce:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 80048d2:	eec7 7a27 	vdiv.f32	s15, s14, s15
 80048d6:	6878      	ldr	r0, [r7, #4]
 80048d8:	eeb0 0a67 	vmov.f32	s0, s15
 80048dc:	f7ff f890 	bl	8003a00 <CTRL_setTrajPeriod_sec>

  CTRL_setCtrlPeriod_sec(handle,pUserParams->ctrlPeriod_sec);
 80048e0:	683b      	ldr	r3, [r7, #0]
 80048e2:	edd3 7a58 	vldr	s15, [r3, #352]	; 0x160
 80048e6:	6878      	ldr	r0, [r7, #4]
 80048e8:	eeb0 0a67 	vmov.f32	s0, s15
 80048ec:	f7fe fe0a 	bl	8003504 <CTRL_setCtrlPeriod_sec>

  CTRL_setMaxVsMag_pu(handle,(pUserParams->maxVsMag_pu));
 80048f0:	683b      	ldr	r3, [r7, #0]
 80048f2:	edd3 7a17 	vldr	s15, [r3, #92]	; 0x5c
 80048f6:	6878      	ldr	r0, [r7, #4]
 80048f8:	eeb0 0a67 	vmov.f32	s0, s15
 80048fc:	f7fe ff92 	bl	8003824 <CTRL_setMaxVsMag_pu>

  CTRL_setIab_in_pu(handle,&Iab_out_pu);
 8004900:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8004904:	6878      	ldr	r0, [r7, #4]
 8004906:	4619      	mov	r1, r3
 8004908:	f7fe fea8 	bl	800365c <CTRL_setIab_in_pu>
  CTRL_setIdq_in_pu(handle,&Idq_out_pu);
 800490c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8004910:	6878      	ldr	r0, [r7, #4]
 8004912:	4619      	mov	r1, r3
 8004914:	f7fe feba 	bl	800368c <CTRL_setIdq_in_pu>
  CTRL_setIdq_ref_pu(handle,&Idq_ref_pu);
 8004918:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800491c:	6878      	ldr	r0, [r7, #4]
 800491e:	4619      	mov	r1, r3
 8004920:	f7fe fecc 	bl	80036bc <CTRL_setIdq_ref_pu>

  CTRL_setIdRated_pu(handle,(pUserParams->IdRated/pUserParams->iqFullScaleCurrent_A));
 8004924:	683b      	ldr	r3, [r7, #0]
 8004926:	ed93 7a24 	vldr	s14, [r3, #144]	; 0x90
 800492a:	683b      	ldr	r3, [r7, #0]
 800492c:	edd3 7a00 	vldr	s15, [r3]
 8004930:	eec7 7a27 	vdiv.f32	s15, s14, s15
 8004934:	6878      	ldr	r0, [r7, #4]
 8004936:	eeb0 0a67 	vmov.f32	s0, s15
 800493a:	f7fe fed7 	bl	80036ec <CTRL_setIdRated_pu>

  CTRL_setVab_in_pu(handle,&Vab_in_pu);
 800493e:	f107 031c 	add.w	r3, r7, #28
 8004942:	6878      	ldr	r0, [r7, #4]
 8004944:	4619      	mov	r1, r3
 8004946:	f7ff f86d 	bl	8003a24 <CTRL_setVab_in_pu>
  CTRL_setVab_out_pu(handle,&Vab_out_pu);
 800494a:	f107 0314 	add.w	r3, r7, #20
 800494e:	6878      	ldr	r0, [r7, #4]
 8004950:	4619      	mov	r1, r3
 8004952:	f7ff f87f 	bl	8003a54 <CTRL_setVab_out_pu>
  CTRL_setVdq_out_pu(handle,&Vdq_out_pu);
 8004956:	f107 030c 	add.w	r3, r7, #12
 800495a:	6878      	ldr	r0, [r7, #4]
 800495c:	4619      	mov	r1, r3
 800495e:	f7ff f891 	bl	8003a84 <CTRL_setVdq_out_pu>

  CTRL_setSpd_out_pu(handle,(0.0f));
 8004962:	6878      	ldr	r0, [r7, #4]
 8004964:	ed9f 0ace 	vldr	s0, [pc, #824]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004968:	f7ff f810 	bl	800398c <CTRL_setSpd_out_pu>

  CTRL_setRhf(handle,0.0f);
 800496c:	6878      	ldr	r0, [r7, #4]
 800496e:	ed9f 0acc 	vldr	s0, [pc, #816]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004972:	f7fe ffe7 	bl	8003944 <CTRL_setRhf>
  CTRL_setLhf(handle,0.0f);
 8004976:	6878      	ldr	r0, [r7, #4]
 8004978:	ed9f 0ac9 	vldr	s0, [pc, #804]	; 8004ca0 <CTRL_setParams+0x4c4>
 800497c:	f7fe ff40 	bl	8003800 <CTRL_setLhf>
  CTRL_setRoverL(handle,0.0f);
 8004980:	6878      	ldr	r0, [r7, #4]
 8004982:	ed9f 0ac7 	vldr	s0, [pc, #796]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004986:	f7fe ffef 	bl	8003968 <CTRL_setRoverL>


  // reset the counters
  CTRL_resetCounter_current(handle);
 800498a:	6878      	ldr	r0, [r7, #4]
 800498c:	f7fe fd58 	bl	8003440 <CTRL_resetCounter_current>
  CTRL_resetCounter_isr(handle);
 8004990:	6878      	ldr	r0, [r7, #4]
 8004992:	f7fe fd65 	bl	8003460 <CTRL_resetCounter_isr>
  CTRL_resetCounter_speed(handle);
 8004996:	6878      	ldr	r0, [r7, #4]
 8004998:	f7fe fd72 	bl	8003480 <CTRL_resetCounter_speed>
  CTRL_resetCounter_state(handle);
 800499c:	6878      	ldr	r0, [r7, #4]
 800499e:	f7fe fd7f 	bl	80034a0 <CTRL_resetCounter_state>
  CTRL_resetCounter_traj(handle);
 80049a2:	6878      	ldr	r0, [r7, #4]
 80049a4:	f7fe fd8c 	bl	80034c0 <CTRL_resetCounter_traj>


  // set the wait times for each state
  CTRL_setWaitTimes(handle,&pUserParams->ctrlWaitTime[0]);
 80049a8:	683b      	ldr	r3, [r7, #0]
 80049aa:	33a4      	adds	r3, #164	; 0xa4
 80049ac:	6878      	ldr	r0, [r7, #4]
 80049ae:	4619      	mov	r1, r3
 80049b0:	f000 fa74 	bl	8004e9c <CTRL_setWaitTimes>


  // set flags
  CTRL_setFlag_enablePowerWarp(handle,false);
 80049b4:	6878      	ldr	r0, [r7, #4]
 80049b6:	2100      	movs	r1, #0
 80049b8:	f7fe fe08 	bl	80035cc <CTRL_setFlag_enablePowerWarp>
  CTRL_setFlag_enableCtrl(handle,false);
 80049bc:	6878      	ldr	r0, [r7, #4]
 80049be:	2100      	movs	r1, #0
 80049c0:	f7fe fdce 	bl	8003560 <CTRL_setFlag_enableCtrl>
  CTRL_setFlag_enableOffset(handle,true);
 80049c4:	6878      	ldr	r0, [r7, #4]
 80049c6:	2101      	movs	r1, #1
 80049c8:	f7fe fe12 	bl	80035f0 <CTRL_setFlag_enableOffset>
  CTRL_setFlag_enableSpeedCtrl(handle,false);
 80049cc:	6878      	ldr	r0, [r7, #4]
 80049ce:	2100      	movs	r1, #0
 80049d0:	f7fe fe20 	bl	8003614 <CTRL_setFlag_enableSpeedCtrl>
  CTRL_setFlag_enableCurrentCtrl(handle,false);
 80049d4:	6878      	ldr	r0, [r7, #4]
 80049d6:	2100      	movs	r1, #0
 80049d8:	f7fe fdd4 	bl	8003584 <CTRL_setFlag_enableCurrentCtrl>
  CTRL_setFlag_enableUserMotorParams(handle,false);
 80049dc:	6878      	ldr	r0, [r7, #4]
 80049de:	2100      	movs	r1, #0
 80049e0:	f7fe fe2a 	bl	8003638 <CTRL_setFlag_enableUserMotorParams>
  CTRL_setFlag_enableDcBusComp(handle,true);
 80049e4:	6878      	ldr	r0, [r7, #4]
 80049e6:	2101      	movs	r1, #1
 80049e8:	f7fe fdde 	bl	80035a8 <CTRL_setFlag_enableDcBusComp>


  // initialize the controller error code
  CTRL_setErrorCode(handle,CTRL_ErrorCode_NoError);
 80049ec:	6878      	ldr	r0, [r7, #4]
 80049ee:	2100      	movs	r1, #0
 80049f0:	f7fe fd9a 	bl	8003528 <CTRL_setErrorCode>


  // set the default controller state
  CTRL_setState(handle,CTRL_State_OnLine);
 80049f4:	6878      	ldr	r0, [r7, #4]
 80049f6:	2107      	movs	r1, #7
 80049f8:	f7fe ffda 	bl	80039b0 <CTRL_setState>


  // set the number of current sensors
  CTRL_setupClarke_I(handle,pUserParams->numCurrentSensors);
 80049fc:	683b      	ldr	r3, [r7, #0]
 80049fe:	7d9b      	ldrb	r3, [r3, #22]
 8004a00:	6878      	ldr	r0, [r7, #4]
 8004a02:	4619      	mov	r1, r3
 8004a04:	f000 f9e4 	bl	8004dd0 <CTRL_setupClarke_I>


  // set the number of voltage sensors
  CTRL_setupClarke_V(handle,pUserParams->numVoltageSensors);
 8004a08:	683b      	ldr	r3, [r7, #0]
 8004a0a:	7ddb      	ldrb	r3, [r3, #23]
 8004a0c:	6878      	ldr	r0, [r7, #4]
 8004a0e:	4619      	mov	r1, r3
 8004a10:	f000 fa16 	bl	8004e40 <CTRL_setupClarke_V>


  // set the default Id PID controller parameters
  Kp = 1.0f;//(0.1f);
 8004a14:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8004a18:	653b      	str	r3, [r7, #80]	; 0x50
  Ki = 0.2f;//(pUserParams->ctrlPeriod_sec/0.004f);
 8004a1a:	4ba2      	ldr	r3, [pc, #648]	; (8004ca4 <CTRL_setParams+0x4c8>)
 8004a1c:	64fb      	str	r3, [r7, #76]	; 0x4c
  Kd = (0.0f);
 8004a1e:	f04f 0300 	mov.w	r3, #0
 8004a22:	64bb      	str	r3, [r7, #72]	; 0x48
  outMin = (-0.95f);
 8004a24:	4ba0      	ldr	r3, [pc, #640]	; (8004ca8 <CTRL_setParams+0x4cc>)
 8004a26:	647b      	str	r3, [r7, #68]	; 0x44
  outMax = (0.95f);
 8004a28:	4ba0      	ldr	r3, [pc, #640]	; (8004cac <CTRL_setParams+0x4d0>)
 8004a2a:	643b      	str	r3, [r7, #64]	; 0x40

  PID_setGains(obj->pidHandle_Id,Kp,Ki,Kd);
 8004a2c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004a2e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004a30:	4618      	mov	r0, r3
 8004a32:	ed97 0a14 	vldr	s0, [r7, #80]	; 0x50
 8004a36:	edd7 0a13 	vldr	s1, [r7, #76]	; 0x4c
 8004a3a:	ed97 1a12 	vldr	s2, [r7, #72]	; 0x48
 8004a3e:	f7fd ff2d 	bl	800289c <PID_setGains>
  PID_setUi(obj->pidHandle_Id,(0.0f));
 8004a42:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004a44:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004a46:	4618      	mov	r0, r3
 8004a48:	ed9f 0a95 	vldr	s0, [pc, #596]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004a4c:	f7fd ff7c 	bl	8002948 <PID_setUi>
  PID_setMinMax(obj->pidHandle_Id,outMin,outMax);
 8004a50:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004a52:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004a54:	4618      	mov	r0, r3
 8004a56:	ed97 0a11 	vldr	s0, [r7, #68]	; 0x44
 8004a5a:	edd7 0a10 	vldr	s1, [r7, #64]	; 0x40
 8004a5e:	f7fd ff5d 	bl	800291c <PID_setMinMax>
  CTRL_setGains(handle,CTRL_Type_PID_Id,Kp,Ki,Kd);
 8004a62:	6878      	ldr	r0, [r7, #4]
 8004a64:	2101      	movs	r1, #1
 8004a66:	ed97 0a14 	vldr	s0, [r7, #80]	; 0x50
 8004a6a:	edd7 0a13 	vldr	s1, [r7, #76]	; 0x4c
 8004a6e:	ed97 1a12 	vldr	s2, [r7, #72]	; 0x48
 8004a72:	f7ff fdd9 	bl	8004628 <CTRL_setGains>


  // set the default the Iq PID controller parameters
  Kp = 1.0f;//(0.1f);
 8004a76:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8004a7a:	653b      	str	r3, [r7, #80]	; 0x50
  Ki = 0.2f;//(pUserParams->ctrlPeriod_sec/0.004f);
 8004a7c:	4b89      	ldr	r3, [pc, #548]	; (8004ca4 <CTRL_setParams+0x4c8>)
 8004a7e:	64fb      	str	r3, [r7, #76]	; 0x4c
  Kd = (0.0f);
 8004a80:	f04f 0300 	mov.w	r3, #0
 8004a84:	64bb      	str	r3, [r7, #72]	; 0x48
  outMin = (-0.95f);
 8004a86:	4b88      	ldr	r3, [pc, #544]	; (8004ca8 <CTRL_setParams+0x4cc>)
 8004a88:	647b      	str	r3, [r7, #68]	; 0x44
  outMax = (0.95f);
 8004a8a:	4b88      	ldr	r3, [pc, #544]	; (8004cac <CTRL_setParams+0x4d0>)
 8004a8c:	643b      	str	r3, [r7, #64]	; 0x40

  PID_setGains(obj->pidHandle_Iq,Kp,Ki,Kd);
 8004a8e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004a90:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004a92:	4618      	mov	r0, r3
 8004a94:	ed97 0a14 	vldr	s0, [r7, #80]	; 0x50
 8004a98:	edd7 0a13 	vldr	s1, [r7, #76]	; 0x4c
 8004a9c:	ed97 1a12 	vldr	s2, [r7, #72]	; 0x48
 8004aa0:	f7fd fefc 	bl	800289c <PID_setGains>
  PID_setUi(obj->pidHandle_Iq,(0.0f));
 8004aa4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004aa6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004aa8:	4618      	mov	r0, r3
 8004aaa:	ed9f 0a7d 	vldr	s0, [pc, #500]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004aae:	f7fd ff4b 	bl	8002948 <PID_setUi>
  PID_setMinMax(obj->pidHandle_Iq,outMin,outMax);
 8004ab2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004ab4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004ab6:	4618      	mov	r0, r3
 8004ab8:	ed97 0a11 	vldr	s0, [r7, #68]	; 0x44
 8004abc:	edd7 0a10 	vldr	s1, [r7, #64]	; 0x40
 8004ac0:	f7fd ff2c 	bl	800291c <PID_setMinMax>
  CTRL_setGains(handle,CTRL_Type_PID_Iq,Kp,Ki,Kd);
 8004ac4:	6878      	ldr	r0, [r7, #4]
 8004ac6:	2102      	movs	r1, #2
 8004ac8:	ed97 0a14 	vldr	s0, [r7, #80]	; 0x50
 8004acc:	edd7 0a13 	vldr	s1, [r7, #76]	; 0x4c
 8004ad0:	ed97 1a12 	vldr	s2, [r7, #72]	; 0x48
 8004ad4:	f7ff fda8 	bl	8004628 <CTRL_setGains>


  // set the default speed PID controller parameters
  Kp = 2.0f;//(0.02f*pUserParams->maxCurrent*pUserParams->iqFullScaleFreq_Hz/pUserParams->iqFullScaleCurrent_A);
 8004ad8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004adc:	653b      	str	r3, [r7, #80]	; 0x50
  Ki = 0.00001f;//(2.0f*pUserParams->maxCurrent*pUserParams->iqFullScaleFreq_Hz*pUserParams->ctrlPeriod_sec/pUserParams->iqFullScaleCurrent_A);
 8004ade:	4b74      	ldr	r3, [pc, #464]	; (8004cb0 <CTRL_setParams+0x4d4>)
 8004ae0:	64fb      	str	r3, [r7, #76]	; 0x4c
  Kd = (0.0f);
 8004ae2:	f04f 0300 	mov.w	r3, #0
 8004ae6:	64bb      	str	r3, [r7, #72]	; 0x48
  outMin = (-1.0f);
 8004ae8:	4b72      	ldr	r3, [pc, #456]	; (8004cb4 <CTRL_setParams+0x4d8>)
 8004aea:	647b      	str	r3, [r7, #68]	; 0x44
  outMax = (1.0f);
 8004aec:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8004af0:	643b      	str	r3, [r7, #64]	; 0x40

  PID_setGains(obj->pidHandle_spd,Kp,Ki,Kd);
 8004af2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004af4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8004af8:	4618      	mov	r0, r3
 8004afa:	ed97 0a14 	vldr	s0, [r7, #80]	; 0x50
 8004afe:	edd7 0a13 	vldr	s1, [r7, #76]	; 0x4c
 8004b02:	ed97 1a12 	vldr	s2, [r7, #72]	; 0x48
 8004b06:	f7fd fec9 	bl	800289c <PID_setGains>
  PID_setUi(obj->pidHandle_spd,(0.0f));
 8004b0a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004b0c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8004b10:	4618      	mov	r0, r3
 8004b12:	ed9f 0a63 	vldr	s0, [pc, #396]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004b16:	f7fd ff17 	bl	8002948 <PID_setUi>
  PID_setMinMax(obj->pidHandle_spd,outMin,outMax);
 8004b1a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004b1c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8004b20:	4618      	mov	r0, r3
 8004b22:	ed97 0a11 	vldr	s0, [r7, #68]	; 0x44
 8004b26:	edd7 0a10 	vldr	s1, [r7, #64]	; 0x40
 8004b2a:	f7fd fef7 	bl	800291c <PID_setMinMax>
  CTRL_setGains(handle,CTRL_Type_PID_spd,Kp,Ki,Kd);
 8004b2e:	6878      	ldr	r0, [r7, #4]
 8004b30:	2100      	movs	r1, #0
 8004b32:	ed97 0a14 	vldr	s0, [r7, #80]	; 0x50
 8004b36:	edd7 0a13 	vldr	s1, [r7, #76]	; 0x4c
 8004b3a:	ed97 1a12 	vldr	s2, [r7, #72]	; 0x48
 8004b3e:	f7ff fd73 	bl	8004628 <CTRL_setGains>


  // set the speed reference
  CTRL_setSpd_ref_pu(handle,(0.00f));
 8004b42:	6878      	ldr	r0, [r7, #4]
 8004b44:	ed9f 0a56 	vldr	s0, [pc, #344]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004b48:	f000 f930 	bl	8004dac <CTRL_setSpd_ref_pu>


  // set the default Id current trajectory module parameters
  TRAJ_setIntValue(obj->trajHandle_Id,(0.0f));
 8004b4c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004b4e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8004b52:	4618      	mov	r0, r3
 8004b54:	ed9f 0a52 	vldr	s0, [pc, #328]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004b58:	f7fd ffc2 	bl	8002ae0 <TRAJ_setIntValue>
  TRAJ_setTargetValue(obj->trajHandle_Id,(0.0f));
 8004b5c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004b5e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8004b62:	4618      	mov	r0, r3
 8004b64:	ed9f 0a4e 	vldr	s0, [pc, #312]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004b68:	f7fe f802 	bl	8002b70 <TRAJ_setTargetValue>
  TRAJ_setMinValue(obj->trajHandle_Id,(0.0f));
 8004b6c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004b6e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8004b72:	4618      	mov	r0, r3
 8004b74:	ed9f 0a4a 	vldr	s0, [pc, #296]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004b78:	f7fd ffe8 	bl	8002b4c <TRAJ_setMinValue>
  TRAJ_setMaxValue(obj->trajHandle_Id,(0.0f));
 8004b7c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004b7e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8004b82:	4618      	mov	r0, r3
 8004b84:	ed9f 0a46 	vldr	s0, [pc, #280]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004b88:	f7fd ffce 	bl	8002b28 <TRAJ_setMaxValue>
  TRAJ_setMaxDelta(obj->trajHandle_Id,(0.0f));
 8004b8c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004b8e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8004b92:	4618      	mov	r0, r3
 8004b94:	ed9f 0a42 	vldr	s0, [pc, #264]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004b98:	f7fd ffb4 	bl	8002b04 <TRAJ_setMaxDelta>


  // set the default the speed trajectory module parameters
  TRAJ_setIntValue(obj->trajHandle_spd,(0.0f));
 8004b9c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004b9e:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8004ba2:	4618      	mov	r0, r3
 8004ba4:	ed9f 0a3e 	vldr	s0, [pc, #248]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004ba8:	f7fd ff9a 	bl	8002ae0 <TRAJ_setIntValue>
  TRAJ_setTargetValue(obj->trajHandle_spd,(0.0f));
 8004bac:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004bae:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8004bb2:	4618      	mov	r0, r3
 8004bb4:	ed9f 0a3a 	vldr	s0, [pc, #232]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004bb8:	f7fd ffda 	bl	8002b70 <TRAJ_setTargetValue>
  TRAJ_setMinValue(obj->trajHandle_spd,(0.0f));
 8004bbc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004bbe:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8004bc2:	4618      	mov	r0, r3
 8004bc4:	ed9f 0a36 	vldr	s0, [pc, #216]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004bc8:	f7fd ffc0 	bl	8002b4c <TRAJ_setMinValue>
  TRAJ_setMaxValue(obj->trajHandle_spd,(0.0f));
 8004bcc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004bce:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8004bd2:	4618      	mov	r0, r3
 8004bd4:	ed9f 0a32 	vldr	s0, [pc, #200]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004bd8:	f7fd ffa6 	bl	8002b28 <TRAJ_setMaxValue>
  TRAJ_setMaxDelta(obj->trajHandle_spd,(0.0f));
 8004bdc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004bde:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8004be2:	4618      	mov	r0, r3
 8004be4:	ed9f 0a2e 	vldr	s0, [pc, #184]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004be8:	f7fd ff8c 	bl	8002b04 <TRAJ_setMaxDelta>


  // set the default maximum speed trajectory module parameters
  TRAJ_setIntValue(obj->trajHandle_spdMax,(0.0f));
 8004bec:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004bee:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 8004bf2:	4618      	mov	r0, r3
 8004bf4:	ed9f 0a2a 	vldr	s0, [pc, #168]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004bf8:	f7fd ff72 	bl	8002ae0 <TRAJ_setIntValue>
  TRAJ_setTargetValue(obj->trajHandle_spdMax,(0.0f));
 8004bfc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004bfe:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 8004c02:	4618      	mov	r0, r3
 8004c04:	ed9f 0a26 	vldr	s0, [pc, #152]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004c08:	f7fd ffb2 	bl	8002b70 <TRAJ_setTargetValue>
  TRAJ_setMinValue(obj->trajHandle_spdMax,(0.0f)); // not used
 8004c0c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004c0e:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 8004c12:	4618      	mov	r0, r3
 8004c14:	ed9f 0a22 	vldr	s0, [pc, #136]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004c18:	f7fd ff98 	bl	8002b4c <TRAJ_setMinValue>
  TRAJ_setMaxValue(obj->trajHandle_spdMax,(0.0f)); // not used
 8004c1c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004c1e:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 8004c22:	4618      	mov	r0, r3
 8004c24:	ed9f 0a1e 	vldr	s0, [pc, #120]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004c28:	f7fd ff7e 	bl	8002b28 <TRAJ_setMaxValue>
  TRAJ_setMaxDelta(obj->trajHandle_spdMax,(0.0f)); // not used
 8004c2c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004c2e:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 8004c32:	4618      	mov	r0, r3
 8004c34:	ed9f 0a1a 	vldr	s0, [pc, #104]	; 8004ca0 <CTRL_setParams+0x4c4>
 8004c38:	f7fd ff64 	bl	8002b04 <TRAJ_setMaxDelta>

  
  // set the default estimator parameters
  CTRL_setEstParams(obj->estHandle,pUserParams);
 8004c3c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004c3e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004c40:	4618      	mov	r0, r3
 8004c42:	6839      	ldr	r1, [r7, #0]
 8004c44:	f7fe fc82 	bl	800354c <CTRL_setEstParams>


  // set the maximum modulation for the SVGEN module
  maxModulation = SVGEN_4_OVER_3;
 8004c48:	4b1b      	ldr	r3, [pc, #108]	; (8004cb8 <CTRL_setParams+0x4dc>)
 8004c4a:	63fb      	str	r3, [r7, #60]	; 0x3c
  SVGEN_setMaxModulation(obj->svgenHandle,maxModulation);
 8004c4c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004c4e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8004c52:	4618      	mov	r0, r3
 8004c54:	ed97 0a0f 	vldr	s0, [r7, #60]	; 0x3c
 8004c58:	f7fd ff14 	bl	8002a84 <SVGEN_setMaxModulation>

	obj->angle_offset_pu = 0.0f;
 8004c5c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004c5e:	f04f 0200 	mov.w	r2, #0
 8004c62:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c

  //! \Mod By Dl.K
  RMP_CNTL_SetRampDelayMax(obj->rmpcntl_handle, 600);
 8004c66:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004c68:	f8d3 3224 	ldr.w	r3, [r3, #548]	; 0x224
 8004c6c:	4618      	mov	r0, r3
 8004c6e:	f44f 7116 	mov.w	r1, #600	; 0x258
 8004c72:	f7fd ff8f 	bl	8002b94 <RMP_CNTL_SetRampDelayMax>

  RAMPGEN_SetStepAngleMax(obj->rampgen_handle,(pUserParams->ctrlPeriod_sec*pUserParams->iqFullScaleFreq_Hz));
 8004c76:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004c78:	f8d3 2244 	ldr.w	r2, [r3, #580]	; 0x244
 8004c7c:	683b      	ldr	r3, [r7, #0]
 8004c7e:	ed93 7a58 	vldr	s14, [r3, #352]	; 0x160
 8004c82:	683b      	ldr	r3, [r7, #0]
 8004c84:	edd3 7a02 	vldr	s15, [r3, #8]
 8004c88:	ee67 7a27 	vmul.f32	s15, s14, s15
 8004c8c:	4610      	mov	r0, r2
 8004c8e:	eeb0 0a67 	vmov.f32	s0, s15
 8004c92:	f7fe f84f 	bl	8002d34 <RAMPGEN_SetStepAngleMax>
  RAMPGEN_SetAngleOffset(obj->rampgen_handle,(0.75f));
 8004c96:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004c98:	f8d3 3244 	ldr.w	r3, [r3, #580]	; 0x244
 8004c9c:	4618      	mov	r0, r3
 8004c9e:	e00f      	b.n	8004cc0 <CTRL_setParams+0x4e4>
 8004ca0:	00000000 	.word	0x00000000
 8004ca4:	3e4ccccd 	.word	0x3e4ccccd
 8004ca8:	bf733333 	.word	0xbf733333
 8004cac:	3f733333 	.word	0x3f733333
 8004cb0:	3727c5ac 	.word	0x3727c5ac
 8004cb4:	bf800000 	.word	0xbf800000
 8004cb8:	3faaaaab 	.word	0x3faaaaab
 8004cbc:	441d0000 	.word	0x441d0000
 8004cc0:	eeb6 0a08 	vmov.f32	s0, #104	; 0x68
 8004cc4:	f7fe f848 	bl	8002d58 <RAMPGEN_SetAngleOffset>

	// fc100Hz=>Need:FreqRespose10HzORTimeRespose100ms:0~1.0f(800Hz)
  Speed_SetElecFilterSpeedRatio(obj->Speed_handle, ( 1.0f/(1.0f+2.0f*3.14f*100.0f*pUserParams->numCtrlTicksPerSpeedTick/pUserParams->ctrlFreq_Hz) ) );
 8004cc8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004cca:	f8d3 22e8 	ldr.w	r2, [r3, #744]	; 0x2e8
 8004cce:	683b      	ldr	r3, [r7, #0]
 8004cd0:	8a5b      	ldrh	r3, [r3, #18]
 8004cd2:	ee07 3a90 	vmov	s15, r3
 8004cd6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8004cda:	ed1f 7a08 	vldr	s14, [pc, #-32]	; 8004cbc <CTRL_setParams+0x4e0>
 8004cde:	ee27 7a87 	vmul.f32	s14, s15, s14
 8004ce2:	683b      	ldr	r3, [r7, #0]
 8004ce4:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 8004ce8:	ee07 3a90 	vmov	s15, r3
 8004cec:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8004cf0:	eec7 7a27 	vdiv.f32	s15, s14, s15
 8004cf4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8004cf8:	ee77 7a87 	vadd.f32	s15, s15, s14
 8004cfc:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8004d00:	eec7 7a27 	vdiv.f32	s15, s14, s15
 8004d04:	4610      	mov	r0, r2
 8004d06:	eeb0 0a67 	vmov.f32	s0, s15
 8004d0a:	f7fe f91b 	bl	8002f44 <Speed_SetElecFilterSpeedRatio>
  Speed_SetElecThetaChagTimeRatio( obj->Speed_handle, ( pUserParams->ctrlFreq_Hz/( pUserParams->iqFullScaleFreq_Hz*pUserParams->numCtrlTicksPerSpeedTick) ) );
 8004d0e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004d10:	f8d3 22e8 	ldr.w	r2, [r3, #744]	; 0x2e8
 8004d14:	683b      	ldr	r3, [r7, #0]
 8004d16:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 8004d1a:	ee07 3a90 	vmov	s15, r3
 8004d1e:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8004d22:	683b      	ldr	r3, [r7, #0]
 8004d24:	edd3 6a02 	vldr	s13, [r3, #8]
 8004d28:	683b      	ldr	r3, [r7, #0]
 8004d2a:	8a5b      	ldrh	r3, [r3, #18]
 8004d2c:	ee07 3a90 	vmov	s15, r3
 8004d30:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8004d34:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8004d38:	eec7 7a27 	vdiv.f32	s15, s14, s15
 8004d3c:	4610      	mov	r0, r2
 8004d3e:	eeb0 0a67 	vmov.f32	s0, s15
 8004d42:	f7fe f911 	bl	8002f68 <Speed_SetElecThetaChagTimeRatio>

  obj->Tabc.value[0]=(0.0f);
 8004d46:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004d48:	f04f 0200 	mov.w	r2, #0
 8004d4c:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
  obj->Tabc.value[1]=(0.0f);
 8004d50:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004d52:	f04f 0200 	mov.w	r2, #0
 8004d56:	f8c3 230c 	str.w	r2, [r3, #780]	; 0x30c
  obj->Tabc.value[2]=(0.0f);
 8004d5a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004d5c:	f04f 0200 	mov.w	r2, #0
 8004d60:	f8c3 2310 	str.w	r2, [r3, #784]	; 0x310

  obj->VdqRef.value[0]=(0.0f);
 8004d64:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004d66:	f04f 0200 	mov.w	r2, #0
 8004d6a:	f8c3 2314 	str.w	r2, [r3, #788]	; 0x314
  obj->VdqRef.value[1]=(0.0f);
 8004d6e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004d70:	f04f 0200 	mov.w	r2, #0
 8004d74:	f8c3 2318 	str.w	r2, [r3, #792]	; 0x318

  obj->AngleRef=(-0.25f);
 8004d78:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004d7a:	4a0b      	ldr	r2, [pc, #44]	; (8004da8 <CTRL_setParams+0x5cc>)
 8004d7c:	f8c3 231c 	str.w	r2, [r3, #796]	; 0x31c

  obj->MntValue.value[0]=(0.0f);
 8004d80:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004d82:	f04f 0200 	mov.w	r2, #0
 8004d86:	f8c3 2320 	str.w	r2, [r3, #800]	; 0x320
  obj->MntValue.value[1]=(0.0f);
 8004d8a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004d8c:	f04f 0200 	mov.w	r2, #0
 8004d90:	f8c3 2324 	str.w	r2, [r3, #804]	; 0x324
  obj->MntValue.value[2]=(0.0f);
 8004d94:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004d96:	f04f 0200 	mov.w	r2, #0
 8004d9a:	f8c3 2328 	str.w	r2, [r3, #808]	; 0x328
  //! \Mod By Dl.K

  return;
 8004d9e:	bf00      	nop
} // end of CTRL_setParams() function
 8004da0:	3758      	adds	r7, #88	; 0x58
 8004da2:	46bd      	mov	sp, r7
 8004da4:	bd80      	pop	{r7, pc}
 8004da6:	bf00      	nop
 8004da8:	be800000 	.word	0xbe800000

08004dac <CTRL_setSpd_ref_pu>:


void CTRL_setSpd_ref_pu(CTRL_Handle handle,const float_t spd_ref_pu)
{
 8004dac:	b480      	push	{r7}
 8004dae:	b085      	sub	sp, #20
 8004db0:	af00      	add	r7, sp, #0
 8004db2:	6078      	str	r0, [r7, #4]
 8004db4:	ed87 0a00 	vstr	s0, [r7]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8004db8:	687b      	ldr	r3, [r7, #4]
 8004dba:	60fb      	str	r3, [r7, #12]

  obj->spd_ref = spd_ref_pu;
 8004dbc:	68fb      	ldr	r3, [r7, #12]
 8004dbe:	683a      	ldr	r2, [r7, #0]
 8004dc0:	f8c3 21e4 	str.w	r2, [r3, #484]	; 0x1e4

  return;
 8004dc4:	bf00      	nop
} // end of CTRL_setSpd_ref_pu() function
 8004dc6:	3714      	adds	r7, #20
 8004dc8:	46bd      	mov	sp, r7
 8004dca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004dce:	4770      	bx	lr

08004dd0 <CTRL_setupClarke_I>:
  return;
} // end of CTRL_setup() function


void CTRL_setupClarke_I(CTRL_Handle handle,uint_least8_t numCurrentSensors)
{
 8004dd0:	b580      	push	{r7, lr}
 8004dd2:	b086      	sub	sp, #24
 8004dd4:	af00      	add	r7, sp, #0
 8004dd6:	6078      	str	r0, [r7, #4]
 8004dd8:	460b      	mov	r3, r1
 8004dda:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8004ddc:	687b      	ldr	r3, [r7, #4]
 8004dde:	60fb      	str	r3, [r7, #12]
  float_t alpha_sf,beta_sf;
  

  // initialize the Clarke transform module for current
  if(numCurrentSensors == 3)
 8004de0:	78fb      	ldrb	r3, [r7, #3]
 8004de2:	2b03      	cmp	r3, #3
 8004de4:	d104      	bne.n	8004df0 <CTRL_setupClarke_I+0x20>
    {
      alpha_sf = (MATH_ONE_OVER_THREE);
 8004de6:	4b14      	ldr	r3, [pc, #80]	; (8004e38 <CTRL_setupClarke_I+0x68>)
 8004de8:	617b      	str	r3, [r7, #20]
      beta_sf = (MATH_ONE_OVER_SQRT_THREE);
 8004dea:	4b14      	ldr	r3, [pc, #80]	; (8004e3c <CTRL_setupClarke_I+0x6c>)
 8004dec:	613b      	str	r3, [r7, #16]
 8004dee:	e00e      	b.n	8004e0e <CTRL_setupClarke_I+0x3e>
    }
  else if(numCurrentSensors == 2)
 8004df0:	78fb      	ldrb	r3, [r7, #3]
 8004df2:	2b02      	cmp	r3, #2
 8004df4:	d105      	bne.n	8004e02 <CTRL_setupClarke_I+0x32>
    {
      alpha_sf = (1.0);
 8004df6:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8004dfa:	617b      	str	r3, [r7, #20]
      beta_sf = (MATH_ONE_OVER_SQRT_THREE);
 8004dfc:	4b0f      	ldr	r3, [pc, #60]	; (8004e3c <CTRL_setupClarke_I+0x6c>)
 8004dfe:	613b      	str	r3, [r7, #16]
 8004e00:	e005      	b.n	8004e0e <CTRL_setupClarke_I+0x3e>
    }
  else 
    {
      alpha_sf = (0.0);
 8004e02:	f04f 0300 	mov.w	r3, #0
 8004e06:	617b      	str	r3, [r7, #20]
      beta_sf = (0.0);
 8004e08:	f04f 0300 	mov.w	r3, #0
 8004e0c:	613b      	str	r3, [r7, #16]
    }

  // set the parameters
  CLARKE_setScaleFactors(obj->clarkeHandle_I,alpha_sf,beta_sf);
 8004e0e:	68fb      	ldr	r3, [r7, #12]
 8004e10:	68db      	ldr	r3, [r3, #12]
 8004e12:	4618      	mov	r0, r3
 8004e14:	ed97 0a05 	vldr	s0, [r7, #20]
 8004e18:	edd7 0a04 	vldr	s1, [r7, #16]
 8004e1c:	f7fd fb6c 	bl	80024f8 <CLARKE_setScaleFactors>
  CLARKE_setNumSensors(obj->clarkeHandle_I,numCurrentSensors);
 8004e20:	68fb      	ldr	r3, [r7, #12]
 8004e22:	68da      	ldr	r2, [r3, #12]
 8004e24:	78fb      	ldrb	r3, [r7, #3]
 8004e26:	4610      	mov	r0, r2
 8004e28:	4619      	mov	r1, r3
 8004e2a:	f7fd fb53 	bl	80024d4 <CLARKE_setNumSensors>

  return;
 8004e2e:	bf00      	nop
} // end of CTRL_setupClarke_I() function
 8004e30:	3718      	adds	r7, #24
 8004e32:	46bd      	mov	sp, r7
 8004e34:	bd80      	pop	{r7, pc}
 8004e36:	bf00      	nop
 8004e38:	3eaaaaab 	.word	0x3eaaaaab
 8004e3c:	3f13cd3a 	.word	0x3f13cd3a

08004e40 <CTRL_setupClarke_V>:


void CTRL_setupClarke_V(CTRL_Handle handle,uint_least8_t numVoltageSensors)
{
 8004e40:	b580      	push	{r7, lr}
 8004e42:	b086      	sub	sp, #24
 8004e44:	af00      	add	r7, sp, #0
 8004e46:	6078      	str	r0, [r7, #4]
 8004e48:	460b      	mov	r3, r1
 8004e4a:	70fb      	strb	r3, [r7, #3]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8004e4c:	687b      	ldr	r3, [r7, #4]
 8004e4e:	60fb      	str	r3, [r7, #12]
  float_t alpha_sf,beta_sf;
  

  // initialize the Clarke transform module for current
  if(numVoltageSensors == 3)
 8004e50:	78fb      	ldrb	r3, [r7, #3]
 8004e52:	2b03      	cmp	r3, #3
 8004e54:	d104      	bne.n	8004e60 <CTRL_setupClarke_V+0x20>
    {
      alpha_sf = (MATH_ONE_OVER_THREE);
 8004e56:	4b0f      	ldr	r3, [pc, #60]	; (8004e94 <CTRL_setupClarke_V+0x54>)
 8004e58:	617b      	str	r3, [r7, #20]
      beta_sf = (MATH_ONE_OVER_SQRT_THREE);
 8004e5a:	4b0f      	ldr	r3, [pc, #60]	; (8004e98 <CTRL_setupClarke_V+0x58>)
 8004e5c:	613b      	str	r3, [r7, #16]
 8004e5e:	e005      	b.n	8004e6c <CTRL_setupClarke_V+0x2c>
    }
 else 
    {
      alpha_sf = (0.0);
 8004e60:	f04f 0300 	mov.w	r3, #0
 8004e64:	617b      	str	r3, [r7, #20]
      beta_sf = (0.0);
 8004e66:	f04f 0300 	mov.w	r3, #0
 8004e6a:	613b      	str	r3, [r7, #16]
    }

  // set the parameters
  CLARKE_setScaleFactors(obj->clarkeHandle_V,alpha_sf,beta_sf);
 8004e6c:	68fb      	ldr	r3, [r7, #12]
 8004e6e:	69db      	ldr	r3, [r3, #28]
 8004e70:	4618      	mov	r0, r3
 8004e72:	ed97 0a05 	vldr	s0, [r7, #20]
 8004e76:	edd7 0a04 	vldr	s1, [r7, #16]
 8004e7a:	f7fd fb3d 	bl	80024f8 <CLARKE_setScaleFactors>
  CLARKE_setNumSensors(obj->clarkeHandle_V,numVoltageSensors);
 8004e7e:	68fb      	ldr	r3, [r7, #12]
 8004e80:	69da      	ldr	r2, [r3, #28]
 8004e82:	78fb      	ldrb	r3, [r7, #3]
 8004e84:	4610      	mov	r0, r2
 8004e86:	4619      	mov	r1, r3
 8004e88:	f7fd fb24 	bl	80024d4 <CLARKE_setNumSensors>

  return;
 8004e8c:	bf00      	nop
} // end of CTRL_setupClarke_V() function
 8004e8e:	3718      	adds	r7, #24
 8004e90:	46bd      	mov	sp, r7
 8004e92:	bd80      	pop	{r7, pc}
 8004e94:	3eaaaaab 	.word	0x3eaaaaab
 8004e98:	3f13cd3a 	.word	0x3f13cd3a

08004e9c <CTRL_setWaitTimes>:
  return;
} // end of CTRL_setup_user() function


void CTRL_setWaitTimes(CTRL_Handle handle,const uint_least32_t *pWaitTimes)
{
 8004e9c:	b480      	push	{r7}
 8004e9e:	b085      	sub	sp, #20
 8004ea0:	af00      	add	r7, sp, #0
 8004ea2:	6078      	str	r0, [r7, #4]
 8004ea4:	6039      	str	r1, [r7, #0]
  CTRL_Obj *obj = (CTRL_Obj *)handle;
 8004ea6:	687b      	ldr	r3, [r7, #4]
 8004ea8:	60bb      	str	r3, [r7, #8]
  uint_least16_t stateCnt;

  for(stateCnt=0;stateCnt<CTRL_numStates;stateCnt++)
 8004eaa:	2300      	movs	r3, #0
 8004eac:	81fb      	strh	r3, [r7, #14]
 8004eae:	e00c      	b.n	8004eca <CTRL_setWaitTimes+0x2e>
    {
      obj->waitTimes[stateCnt] = pWaitTimes[stateCnt];
 8004eb0:	89fa      	ldrh	r2, [r7, #14]
 8004eb2:	89fb      	ldrh	r3, [r7, #14]
 8004eb4:	009b      	lsls	r3, r3, #2
 8004eb6:	6839      	ldr	r1, [r7, #0]
 8004eb8:	440b      	add	r3, r1
 8004eba:	6819      	ldr	r1, [r3, #0]
 8004ebc:	68bb      	ldr	r3, [r7, #8]
 8004ebe:	3248      	adds	r2, #72	; 0x48
 8004ec0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
void CTRL_setWaitTimes(CTRL_Handle handle,const uint_least32_t *pWaitTimes)
{
  CTRL_Obj *obj = (CTRL_Obj *)handle;
  uint_least16_t stateCnt;

  for(stateCnt=0;stateCnt<CTRL_numStates;stateCnt++)
 8004ec4:	89fb      	ldrh	r3, [r7, #14]
 8004ec6:	3301      	adds	r3, #1
 8004ec8:	81fb      	strh	r3, [r7, #14]
 8004eca:	89fb      	ldrh	r3, [r7, #14]
 8004ecc:	2b09      	cmp	r3, #9
 8004ece:	d9ef      	bls.n	8004eb0 <CTRL_setWaitTimes+0x14>
    {
      obj->waitTimes[stateCnt] = pWaitTimes[stateCnt];
    }

  return;
 8004ed0:	bf00      	nop
} // end of CTRL_setWaitTimes() function
 8004ed2:	3714      	adds	r7, #20
 8004ed4:	46bd      	mov	sp, r7
 8004ed6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004eda:	4770      	bx	lr

08004edc <DATA_RTXD_Init>:
-------------------------------------------------------------------------------------*/

#include "modules/data_rtxd/data_rtxd.h"

DATA_RTXD_Handle DATA_RTXD_Init(void *pMemory, const size_t numBytes)
{
 8004edc:	b480      	push	{r7}
 8004ede:	b085      	sub	sp, #20
 8004ee0:	af00      	add	r7, sp, #0
 8004ee2:	6078      	str	r0, [r7, #4]
 8004ee4:	6039      	str	r1, [r7, #0]
	DATA_RTXD_Handle handle;
	uint8_t i;

	if (numBytes < sizeof(DATA_RTXD_Obj))
 8004ee6:	683b      	ldr	r3, [r7, #0]
 8004ee8:	2b1d      	cmp	r3, #29
 8004eea:	d801      	bhi.n	8004ef0 <DATA_RTXD_Init+0x14>
		return((DATA_RTXD_Handle)NULL);
 8004eec:	2300      	movs	r3, #0
 8004eee:	e027      	b.n	8004f40 <DATA_RTXD_Init+0x64>

	// assign the handle
	handle = (DATA_RTXD_Handle)pMemory;
 8004ef0:	687b      	ldr	r3, [r7, #4]
 8004ef2:	60bb      	str	r3, [r7, #8]

	handle->data_rxd_num = 0;
 8004ef4:	68bb      	ldr	r3, [r7, #8]
 8004ef6:	2200      	movs	r2, #0
 8004ef8:	701a      	strb	r2, [r3, #0]
	for (i = 0; i<DATA_RXD_SIZE; i++)
 8004efa:	2300      	movs	r3, #0
 8004efc:	73fb      	strb	r3, [r7, #15]
 8004efe:	e007      	b.n	8004f10 <DATA_RTXD_Init+0x34>
	{
		handle->data_rxd[i] = 0;
 8004f00:	7bfb      	ldrb	r3, [r7, #15]
 8004f02:	68ba      	ldr	r2, [r7, #8]
 8004f04:	4413      	add	r3, r2
 8004f06:	2200      	movs	r2, #0
 8004f08:	705a      	strb	r2, [r3, #1]

	// assign the handle
	handle = (DATA_RTXD_Handle)pMemory;

	handle->data_rxd_num = 0;
	for (i = 0; i<DATA_RXD_SIZE; i++)
 8004f0a:	7bfb      	ldrb	r3, [r7, #15]
 8004f0c:	3301      	adds	r3, #1
 8004f0e:	73fb      	strb	r3, [r7, #15]
 8004f10:	7bfb      	ldrb	r3, [r7, #15]
 8004f12:	2b0c      	cmp	r3, #12
 8004f14:	d9f4      	bls.n	8004f00 <DATA_RTXD_Init+0x24>
	{
		handle->data_rxd[i] = 0;
	}

	handle->data_txd_num = DATA_TXD_SIZE;
 8004f16:	68bb      	ldr	r3, [r7, #8]
 8004f18:	220d      	movs	r2, #13
 8004f1a:	739a      	strb	r2, [r3, #14]
	for (i = 0; i<DATA_TXD_SIZE; i++)
 8004f1c:	2300      	movs	r3, #0
 8004f1e:	73fb      	strb	r3, [r7, #15]
 8004f20:	e007      	b.n	8004f32 <DATA_RTXD_Init+0x56>
	{
		handle->data_txd[i] = 0;
 8004f22:	7bfb      	ldrb	r3, [r7, #15]
 8004f24:	68ba      	ldr	r2, [r7, #8]
 8004f26:	4413      	add	r3, r2
 8004f28:	2200      	movs	r2, #0
 8004f2a:	73da      	strb	r2, [r3, #15]
	{
		handle->data_rxd[i] = 0;
	}

	handle->data_txd_num = DATA_TXD_SIZE;
	for (i = 0; i<DATA_TXD_SIZE; i++)
 8004f2c:	7bfb      	ldrb	r3, [r7, #15]
 8004f2e:	3301      	adds	r3, #1
 8004f30:	73fb      	strb	r3, [r7, #15]
 8004f32:	7bfb      	ldrb	r3, [r7, #15]
 8004f34:	2b0c      	cmp	r3, #12
 8004f36:	d9f4      	bls.n	8004f22 <DATA_RTXD_Init+0x46>
	{
		handle->data_txd[i] = 0;
	}

	handle->time = 0;
 8004f38:	68bb      	ldr	r3, [r7, #8]
 8004f3a:	2200      	movs	r2, #0
 8004f3c:	839a      	strh	r2, [r3, #28]

	return(handle);
 8004f3e:	68bb      	ldr	r3, [r7, #8]

}
 8004f40:	4618      	mov	r0, r3
 8004f42:	3714      	adds	r7, #20
 8004f44:	46bd      	mov	sp, r7
 8004f46:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004f4a:	4770      	bx	lr

08004f4c <Reset_DATA_RXD>:
// the functions

extern DATA_RTXD_Handle DATA_RTXD_Init(void *pMemory, const size_t numBytes);

static inline void Reset_DATA_RXD(DATA_RTXD_Handle handle)
{
 8004f4c:	b480      	push	{r7}
 8004f4e:	b085      	sub	sp, #20
 8004f50:	af00      	add	r7, sp, #0
 8004f52:	6078      	str	r0, [r7, #4]
	DATA_RTXD_Obj *obj = (DATA_RTXD_Obj *)handle;
 8004f54:	687b      	ldr	r3, [r7, #4]
 8004f56:	60fb      	str	r3, [r7, #12]

	obj->data_rxd_num = 0;
 8004f58:	68fb      	ldr	r3, [r7, #12]
 8004f5a:	2200      	movs	r2, #0
 8004f5c:	701a      	strb	r2, [r3, #0]
	
	return;
 8004f5e:	bf00      	nop
}
 8004f60:	3714      	adds	r7, #20
 8004f62:	46bd      	mov	sp, r7
 8004f64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004f68:	4770      	bx	lr
 8004f6a:	bf00      	nop

08004f6c <Reset_DATA_TXD>:

static inline void Reset_DATA_TXD(DATA_RTXD_Handle handle)
{
 8004f6c:	b480      	push	{r7}
 8004f6e:	b085      	sub	sp, #20
 8004f70:	af00      	add	r7, sp, #0
 8004f72:	6078      	str	r0, [r7, #4]
	DATA_RTXD_Obj *obj = (DATA_RTXD_Obj *)handle;
 8004f74:	687b      	ldr	r3, [r7, #4]
 8004f76:	60fb      	str	r3, [r7, #12]

	obj->data_txd_num = 0;
 8004f78:	68fb      	ldr	r3, [r7, #12]
 8004f7a:	2200      	movs	r2, #0
 8004f7c:	739a      	strb	r2, [r3, #14]
	
	return;
 8004f7e:	bf00      	nop
}
 8004f80:	3714      	adds	r7, #20
 8004f82:	46bd      	mov	sp, r7
 8004f84:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004f88:	4770      	bx	lr
 8004f8a:	bf00      	nop

08004f8c <DATA_RXD_Status>:

static inline uint8_t DATA_RXD_Status(DATA_RTXD_Handle handle)
{
 8004f8c:	b480      	push	{r7}
 8004f8e:	b085      	sub	sp, #20
 8004f90:	af00      	add	r7, sp, #0
 8004f92:	6078      	str	r0, [r7, #4]
	DATA_RTXD_Obj *obj = (DATA_RTXD_Obj *)handle;
 8004f94:	687b      	ldr	r3, [r7, #4]
 8004f96:	60fb      	str	r3, [r7, #12]

	if( obj->data_rxd_num == DATA_RXD_SIZE )
 8004f98:	68fb      	ldr	r3, [r7, #12]
 8004f9a:	781b      	ldrb	r3, [r3, #0]
 8004f9c:	2b0d      	cmp	r3, #13
 8004f9e:	d101      	bne.n	8004fa4 <DATA_RXD_Status+0x18>
	{
		return false;
 8004fa0:	2300      	movs	r3, #0
 8004fa2:	e000      	b.n	8004fa6 <DATA_RXD_Status+0x1a>
	}
	else return true;
 8004fa4:	2301      	movs	r3, #1
}
 8004fa6:	4618      	mov	r0, r3
 8004fa8:	3714      	adds	r7, #20
 8004faa:	46bd      	mov	sp, r7
 8004fac:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004fb0:	4770      	bx	lr
 8004fb2:	bf00      	nop

08004fb4 <DATA_Select>:
}DATA_e;

// **************************************************************************
// the functions
static inline int16_t DATA_Select(CTRL_Handle handle, HAL_Handle halHandle, const HAL_AdcData_t *pAdcData, const HAL_QepData_t *pQepData, DATA_e data_e)
{
 8004fb4:	b480      	push	{r7}
 8004fb6:	b08b      	sub	sp, #44	; 0x2c
 8004fb8:	af00      	add	r7, sp, #0
 8004fba:	6178      	str	r0, [r7, #20]
 8004fbc:	6139      	str	r1, [r7, #16]
 8004fbe:	60fa      	str	r2, [r7, #12]
 8004fc0:	60bb      	str	r3, [r7, #8]
	CTRL_Obj *obj = (CTRL_Obj *)handle;
 8004fc2:	697b      	ldr	r3, [r7, #20]
 8004fc4:	623b      	str	r3, [r7, #32]
	OFFSET_Obj *offset_obj = (OFFSET_Obj *)(halHandle->offsetHandle_I[0]);
 8004fc6:	693b      	ldr	r3, [r7, #16]
 8004fc8:	681b      	ldr	r3, [r3, #0]
 8004fca:	61fb      	str	r3, [r7, #28]
	int16_t value;

	switch(data_e)
 8004fcc:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8004fd0:	3b01      	subs	r3, #1
 8004fd2:	2b35      	cmp	r3, #53	; 0x35
 8004fd4:	f200 81ee 	bhi.w	80053b4 <DATA_Select+0x400>
 8004fd8:	a201      	add	r2, pc, #4	; (adr r2, 8004fe0 <DATA_Select+0x2c>)
 8004fda:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8004fde:	bf00      	nop
 8004fe0:	080050b9 	.word	0x080050b9
 8004fe4:	080050d5 	.word	0x080050d5
 8004fe8:	080050f1 	.word	0x080050f1
 8004fec:	0800510d 	.word	0x0800510d
 8004ff0:	08005129 	.word	0x08005129
 8004ff4:	08005145 	.word	0x08005145
 8004ff8:	08005161 	.word	0x08005161
 8004ffc:	0800517d 	.word	0x0800517d
 8005000:	080053b5 	.word	0x080053b5
 8005004:	080053b5 	.word	0x080053b5
 8005008:	08005199 	.word	0x08005199
 800500c:	080051b5 	.word	0x080051b5
 8005010:	080051d1 	.word	0x080051d1
 8005014:	080051ed 	.word	0x080051ed
 8005018:	08005209 	.word	0x08005209
 800501c:	08005225 	.word	0x08005225
 8005020:	0800522b 	.word	0x0800522b
 8005024:	08005231 	.word	0x08005231
 8005028:	080053b5 	.word	0x080053b5
 800502c:	080053b5 	.word	0x080053b5
 8005030:	0800524d 	.word	0x0800524d
 8005034:	08005269 	.word	0x08005269
 8005038:	08005295 	.word	0x08005295
 800503c:	080052b5 	.word	0x080052b5
 8005040:	080053b5 	.word	0x080053b5
 8005044:	080053b5 	.word	0x080053b5
 8005048:	080053b5 	.word	0x080053b5
 800504c:	080053b5 	.word	0x080053b5
 8005050:	080053b5 	.word	0x080053b5
 8005054:	080053b5 	.word	0x080053b5
 8005058:	080052d5 	.word	0x080052d5
 800505c:	080053b5 	.word	0x080053b5
 8005060:	080053b5 	.word	0x080053b5
 8005064:	080053b5 	.word	0x080053b5
 8005068:	080053b5 	.word	0x080053b5
 800506c:	080053b5 	.word	0x080053b5
 8005070:	080053b5 	.word	0x080053b5
 8005074:	080053b5 	.word	0x080053b5
 8005078:	080053b5 	.word	0x080053b5
 800507c:	080053b5 	.word	0x080053b5
 8005080:	080052f1 	.word	0x080052f1
 8005084:	0800530d 	.word	0x0800530d
 8005088:	08005329 	.word	0x08005329
 800508c:	080053b5 	.word	0x080053b5
 8005090:	080053b5 	.word	0x080053b5
 8005094:	080053b5 	.word	0x080053b5
 8005098:	080053b5 	.word	0x080053b5
 800509c:	080053b5 	.word	0x080053b5
 80050a0:	080053b5 	.word	0x080053b5
 80050a4:	080053b5 	.word	0x080053b5
 80050a8:	08005345 	.word	0x08005345
 80050ac:	08005361 	.word	0x08005361
 80050b0:	0800537d 	.word	0x0800537d
 80050b4:	08005399 	.word	0x08005399
	{
		case IA_DATA:
			value = 32768.0f*(pAdcData->I.value[0]);
 80050b8:	68fb      	ldr	r3, [r7, #12]
 80050ba:	edd3 7a00 	vldr	s15, [r3]
 80050be:	ed9f 7ac2 	vldr	s14, [pc, #776]	; 80053c8 <DATA_Select+0x414>
 80050c2:	ee67 7a87 	vmul.f32	s15, s15, s14
 80050c6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80050ca:	edc7 7a01 	vstr	s15, [r7, #4]
 80050ce:	88bb      	ldrh	r3, [r7, #4]
 80050d0:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 80050d2:	e170      	b.n	80053b6 <DATA_Select+0x402>
		case IB_DATA:
			value = 32768.0f*(pAdcData->I.value[1]);
 80050d4:	68fb      	ldr	r3, [r7, #12]
 80050d6:	edd3 7a01 	vldr	s15, [r3, #4]
 80050da:	ed9f 7abb 	vldr	s14, [pc, #748]	; 80053c8 <DATA_Select+0x414>
 80050de:	ee67 7a87 	vmul.f32	s15, s15, s14
 80050e2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80050e6:	edc7 7a01 	vstr	s15, [r7, #4]
 80050ea:	88bb      	ldrh	r3, [r7, #4]
 80050ec:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 80050ee:	e162      	b.n	80053b6 <DATA_Select+0x402>
		case IC_DATA:
			value = 32768.0f*(pAdcData->I.value[2]);
 80050f0:	68fb      	ldr	r3, [r7, #12]
 80050f2:	edd3 7a02 	vldr	s15, [r3, #8]
 80050f6:	ed9f 7ab4 	vldr	s14, [pc, #720]	; 80053c8 <DATA_Select+0x414>
 80050fa:	ee67 7a87 	vmul.f32	s15, s15, s14
 80050fe:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005102:	edc7 7a01 	vstr	s15, [r7, #4]
 8005106:	88bb      	ldrh	r3, [r7, #4]
 8005108:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 800510a:	e154      	b.n	80053b6 <DATA_Select+0x402>
		case IALPHA_DATA:
			value = 32768.0f*(obj->Iab_in.value[0]);
 800510c:	6a3b      	ldr	r3, [r7, #32]
 800510e:	edd3 7a5a 	vldr	s15, [r3, #360]	; 0x168
 8005112:	ed9f 7aad 	vldr	s14, [pc, #692]	; 80053c8 <DATA_Select+0x414>
 8005116:	ee67 7a87 	vmul.f32	s15, s15, s14
 800511a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800511e:	edc7 7a01 	vstr	s15, [r7, #4]
 8005122:	88bb      	ldrh	r3, [r7, #4]
 8005124:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005126:	e146      	b.n	80053b6 <DATA_Select+0x402>
		case IBETA_DATA:
			value = 32768.0f*(obj->Iab_in.value[1]);
 8005128:	6a3b      	ldr	r3, [r7, #32]
 800512a:	edd3 7a5b 	vldr	s15, [r3, #364]	; 0x16c
 800512e:	ed9f 7aa6 	vldr	s14, [pc, #664]	; 80053c8 <DATA_Select+0x414>
 8005132:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005136:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800513a:	edc7 7a01 	vstr	s15, [r7, #4]
 800513e:	88bb      	ldrh	r3, [r7, #4]
 8005140:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005142:	e138      	b.n	80053b6 <DATA_Select+0x402>
		case ID_DATA:
			value = 32768.0f*(obj->Idq_in.value[0]);
 8005144:	6a3b      	ldr	r3, [r7, #32]
 8005146:	edd3 7a5e 	vldr	s15, [r3, #376]	; 0x178
 800514a:	ed9f 7a9f 	vldr	s14, [pc, #636]	; 80053c8 <DATA_Select+0x414>
 800514e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005152:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005156:	edc7 7a01 	vstr	s15, [r7, #4]
 800515a:	88bb      	ldrh	r3, [r7, #4]
 800515c:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 800515e:	e12a      	b.n	80053b6 <DATA_Select+0x402>
		case IQ_DATA:
			value = 32768.0f*(obj->Idq_in.value[1]);
 8005160:	6a3b      	ldr	r3, [r7, #32]
 8005162:	edd3 7a5f 	vldr	s15, [r3, #380]	; 0x17c
 8005166:	ed9f 7a98 	vldr	s14, [pc, #608]	; 80053c8 <DATA_Select+0x414>
 800516a:	ee67 7a87 	vmul.f32	s15, s15, s14
 800516e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005172:	edc7 7a01 	vstr	s15, [r7, #4]
 8005176:	88bb      	ldrh	r3, [r7, #4]
 8005178:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 800517a:	e11c      	b.n	80053b6 <DATA_Select+0x402>
		case IDC_DATA:
			value = 32768.0f*(pAdcData->IdcBus);
 800517c:	68fb      	ldr	r3, [r7, #12]
 800517e:	edd3 7a07 	vldr	s15, [r3, #28]
 8005182:	ed9f 7a91 	vldr	s14, [pc, #580]	; 80053c8 <DATA_Select+0x414>
 8005186:	ee67 7a87 	vmul.f32	s15, s15, s14
 800518a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800518e:	edc7 7a01 	vstr	s15, [r7, #4]
 8005192:	88bb      	ldrh	r3, [r7, #4]
 8005194:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005196:	e10e      	b.n	80053b6 <DATA_Select+0x402>

		case VA_DATA:
			value = 32768.0f*(pAdcData->V.value[0]);
 8005198:	68fb      	ldr	r3, [r7, #12]
 800519a:	edd3 7a03 	vldr	s15, [r3, #12]
 800519e:	ed9f 7a8a 	vldr	s14, [pc, #552]	; 80053c8 <DATA_Select+0x414>
 80051a2:	ee67 7a87 	vmul.f32	s15, s15, s14
 80051a6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80051aa:	edc7 7a01 	vstr	s15, [r7, #4]
 80051ae:	88bb      	ldrh	r3, [r7, #4]
 80051b0:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 80051b2:	e100      	b.n	80053b6 <DATA_Select+0x402>
		case VB_DATA:
			value = 32768.0f*(pAdcData->V.value[1]);
 80051b4:	68fb      	ldr	r3, [r7, #12]
 80051b6:	edd3 7a04 	vldr	s15, [r3, #16]
 80051ba:	ed9f 7a83 	vldr	s14, [pc, #524]	; 80053c8 <DATA_Select+0x414>
 80051be:	ee67 7a87 	vmul.f32	s15, s15, s14
 80051c2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80051c6:	edc7 7a01 	vstr	s15, [r7, #4]
 80051ca:	88bb      	ldrh	r3, [r7, #4]
 80051cc:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 80051ce:	e0f2      	b.n	80053b6 <DATA_Select+0x402>
		case VC_DATA:
			value = 32768.0f*(pAdcData->V.value[2]);
 80051d0:	68fb      	ldr	r3, [r7, #12]
 80051d2:	edd3 7a05 	vldr	s15, [r3, #20]
 80051d6:	ed9f 7a7c 	vldr	s14, [pc, #496]	; 80053c8 <DATA_Select+0x414>
 80051da:	ee67 7a87 	vmul.f32	s15, s15, s14
 80051de:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80051e2:	edc7 7a01 	vstr	s15, [r7, #4]
 80051e6:	88bb      	ldrh	r3, [r7, #4]
 80051e8:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 80051ea:	e0e4      	b.n	80053b6 <DATA_Select+0x402>
		case VALPHA_DATA:
			value = 32768.0f*(obj->Vab_in.value[0]);
 80051ec:	6a3b      	ldr	r3, [r7, #32]
 80051ee:	edd3 7a60 	vldr	s15, [r3, #384]	; 0x180
 80051f2:	ed9f 7a75 	vldr	s14, [pc, #468]	; 80053c8 <DATA_Select+0x414>
 80051f6:	ee67 7a87 	vmul.f32	s15, s15, s14
 80051fa:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80051fe:	edc7 7a01 	vstr	s15, [r7, #4]
 8005202:	88bb      	ldrh	r3, [r7, #4]
 8005204:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005206:	e0d6      	b.n	80053b6 <DATA_Select+0x402>
		case VBETA_DATA:
			value = 32768.0f*(obj->Vab_in.value[1]);
 8005208:	6a3b      	ldr	r3, [r7, #32]
 800520a:	edd3 7a61 	vldr	s15, [r3, #388]	; 0x184
 800520e:	ed9f 7a6e 	vldr	s14, [pc, #440]	; 80053c8 <DATA_Select+0x414>
 8005212:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005216:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800521a:	edc7 7a01 	vstr	s15, [r7, #4]
 800521e:	88bb      	ldrh	r3, [r7, #4]
 8005220:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005222:	e0c8      	b.n	80053b6 <DATA_Select+0x402>
		case VD_DATA:
			value = 4;
 8005224:	2304      	movs	r3, #4
 8005226:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005228:	e0c5      	b.n	80053b6 <DATA_Select+0x402>
		case VQ_DATA:
			value = 5;
 800522a:	2305      	movs	r3, #5
 800522c:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 800522e:	e0c2      	b.n	80053b6 <DATA_Select+0x402>
		case VDC_DATA:
			value = 32768.0f*(pAdcData->VdcBus);
 8005230:	68fb      	ldr	r3, [r7, #12]
 8005232:	edd3 7a06 	vldr	s15, [r3, #24]
 8005236:	ed9f 7a64 	vldr	s14, [pc, #400]	; 80053c8 <DATA_Select+0x414>
 800523a:	ee67 7a87 	vmul.f32	s15, s15, s14
 800523e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005242:	edc7 7a01 	vstr	s15, [r7, #4]
 8005246:	88bb      	ldrh	r3, [r7, #4]
 8005248:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 800524a:	e0b4      	b.n	80053b6 <DATA_Select+0x402>

		case QEP_DATA:
			value = 32768.0f*pQepData->qep_cnt;
 800524c:	68bb      	ldr	r3, [r7, #8]
 800524e:	edd3 7a00 	vldr	s15, [r3]
 8005252:	ed9f 7a5d 	vldr	s14, [pc, #372]	; 80053c8 <DATA_Select+0x414>
 8005256:	ee67 7a87 	vmul.f32	s15, s15, s14
 800525a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800525e:	edc7 7a01 	vstr	s15, [r7, #4]
 8005262:	88bb      	ldrh	r3, [r7, #4]
 8005264:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005266:	e0a6      	b.n	80053b6 <DATA_Select+0x402>

		case ANGLE_DATA:
			value = 32768.0f*pQepData->qep_cnt*USER_MOTOR_NUM_POLE_PAIRS;
 8005268:	68bb      	ldr	r3, [r7, #8]
 800526a:	edd3 7a00 	vldr	s15, [r3]
 800526e:	ed9f 7a56 	vldr	s14, [pc, #344]	; 80053c8 <DATA_Select+0x414>
 8005272:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005276:	eeb1 7a00 	vmov.f32	s14, #16
 800527a:	ee67 7a87 	vmul.f32	s15, s15, s14
 800527e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005282:	edc7 7a01 	vstr	s15, [r7, #4]
 8005286:	88bb      	ldrh	r3, [r7, #4]
 8005288:	84fb      	strh	r3, [r7, #38]	; 0x26
			value &= 0x7FFF;
 800528a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800528c:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8005290:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005292:	e090      	b.n	80053b6 <DATA_Select+0x402>

		case SPEED_DATA:
			value = 32768.0f*(obj->Speed_handle->ElecSpeed);;
 8005294:	6a3b      	ldr	r3, [r7, #32]
 8005296:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 800529a:	edd3 7a03 	vldr	s15, [r3, #12]
 800529e:	ed9f 7a4a 	vldr	s14, [pc, #296]	; 80053c8 <DATA_Select+0x414>
 80052a2:	ee67 7a87 	vmul.f32	s15, s15, s14
 80052a6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80052aa:	edc7 7a01 	vstr	s15, [r7, #4]
 80052ae:	88bb      	ldrh	r3, [r7, #4]
 80052b0:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 80052b2:	e080      	b.n	80053b6 <DATA_Select+0x402>

		case FILTER_SPEED_DATA:
			value = 32768.0f*(obj->Speed_handle->ElecFilterSpeed);;
 80052b4:	6a3b      	ldr	r3, [r7, #32]
 80052b6:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
 80052ba:	edd3 7a06 	vldr	s15, [r3, #24]
 80052be:	ed9f 7a42 	vldr	s14, [pc, #264]	; 80053c8 <DATA_Select+0x414>
 80052c2:	ee67 7a87 	vmul.f32	s15, s15, s14
 80052c6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80052ca:	edc7 7a01 	vstr	s15, [r7, #4]
 80052ce:	88bb      	ldrh	r3, [r7, #4]
 80052d0:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 80052d2:	e070      	b.n	80053b6 <DATA_Select+0x402>

		case IA_OFFSET_DATA:
			value = 32768.0f*(offset_obj->value);
 80052d4:	69fb      	ldr	r3, [r7, #28]
 80052d6:	edd3 7a00 	vldr	s15, [r3]
 80052da:	ed9f 7a3b 	vldr	s14, [pc, #236]	; 80053c8 <DATA_Select+0x414>
 80052de:	ee67 7a87 	vmul.f32	s15, s15, s14
 80052e2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80052e6:	edc7 7a01 	vstr	s15, [r7, #4]
 80052ea:	88bb      	ldrh	r3, [r7, #4]
 80052ec:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 80052ee:	e062      	b.n	80053b6 <DATA_Select+0x402>

		case TA_DATA:
			value = 32768.0f*(obj->Tabc.value[0]);
 80052f0:	6a3b      	ldr	r3, [r7, #32]
 80052f2:	edd3 7ac2 	vldr	s15, [r3, #776]	; 0x308
 80052f6:	ed9f 7a34 	vldr	s14, [pc, #208]	; 80053c8 <DATA_Select+0x414>
 80052fa:	ee67 7a87 	vmul.f32	s15, s15, s14
 80052fe:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005302:	edc7 7a01 	vstr	s15, [r7, #4]
 8005306:	88bb      	ldrh	r3, [r7, #4]
 8005308:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 800530a:	e054      	b.n	80053b6 <DATA_Select+0x402>

		case TB_DATA:
			value = 32768.0f*(obj->Tabc.value[1]);
 800530c:	6a3b      	ldr	r3, [r7, #32]
 800530e:	edd3 7ac3 	vldr	s15, [r3, #780]	; 0x30c
 8005312:	ed9f 7a2d 	vldr	s14, [pc, #180]	; 80053c8 <DATA_Select+0x414>
 8005316:	ee67 7a87 	vmul.f32	s15, s15, s14
 800531a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800531e:	edc7 7a01 	vstr	s15, [r7, #4]
 8005322:	88bb      	ldrh	r3, [r7, #4]
 8005324:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005326:	e046      	b.n	80053b6 <DATA_Select+0x402>

		case TC_DATA:
			value = 32768.0f*(obj->Tabc.value[2]);
 8005328:	6a3b      	ldr	r3, [r7, #32]
 800532a:	edd3 7ac4 	vldr	s15, [r3, #784]	; 0x310
 800532e:	ed9f 7a26 	vldr	s14, [pc, #152]	; 80053c8 <DATA_Select+0x414>
 8005332:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005336:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800533a:	edc7 7a01 	vstr	s15, [r7, #4]
 800533e:	88bb      	ldrh	r3, [r7, #4]
 8005340:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005342:	e038      	b.n	80053b6 <DATA_Select+0x402>

		case MNT_VALUE_1_DATA:
			value = 32768.0f*(obj->MntValue.value[0]);
 8005344:	6a3b      	ldr	r3, [r7, #32]
 8005346:	edd3 7ac8 	vldr	s15, [r3, #800]	; 0x320
 800534a:	ed9f 7a1f 	vldr	s14, [pc, #124]	; 80053c8 <DATA_Select+0x414>
 800534e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005352:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005356:	edc7 7a01 	vstr	s15, [r7, #4]
 800535a:	88bb      	ldrh	r3, [r7, #4]
 800535c:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 800535e:	e02a      	b.n	80053b6 <DATA_Select+0x402>

		case MNT_VALUE_2_DATA:
			value = 32768.0f*(obj->MntValue.value[1]);
 8005360:	6a3b      	ldr	r3, [r7, #32]
 8005362:	edd3 7ac9 	vldr	s15, [r3, #804]	; 0x324
 8005366:	ed9f 7a18 	vldr	s14, [pc, #96]	; 80053c8 <DATA_Select+0x414>
 800536a:	ee67 7a87 	vmul.f32	s15, s15, s14
 800536e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005372:	edc7 7a01 	vstr	s15, [r7, #4]
 8005376:	88bb      	ldrh	r3, [r7, #4]
 8005378:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 800537a:	e01c      	b.n	80053b6 <DATA_Select+0x402>

		case MNT_VALUE_3_DATA:
			value = 32768.0f*(obj->MntValue.value[2]);
 800537c:	6a3b      	ldr	r3, [r7, #32]
 800537e:	edd3 7aca 	vldr	s15, [r3, #808]	; 0x328
 8005382:	ed9f 7a11 	vldr	s14, [pc, #68]	; 80053c8 <DATA_Select+0x414>
 8005386:	ee67 7a87 	vmul.f32	s15, s15, s14
 800538a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800538e:	edc7 7a01 	vstr	s15, [r7, #4]
 8005392:	88bb      	ldrh	r3, [r7, #4]
 8005394:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 8005396:	e00e      	b.n	80053b6 <DATA_Select+0x402>

		case MNT_VALUE_4_DATA:
			value = 32768.0f*(obj->InitPosDet.IdEvgTmp);
 8005398:	6a3b      	ldr	r3, [r7, #32]
 800539a:	edd3 7ab9 	vldr	s15, [r3, #740]	; 0x2e4
 800539e:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 80053c8 <DATA_Select+0x414>
 80053a2:	ee67 7a87 	vmul.f32	s15, s15, s14
 80053a6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80053aa:	edc7 7a01 	vstr	s15, [r7, #4]
 80053ae:	88bb      	ldrh	r3, [r7, #4]
 80053b0:	84fb      	strh	r3, [r7, #38]	; 0x26
			break;
 80053b2:	e000      	b.n	80053b6 <DATA_Select+0x402>

		default:
			break;
 80053b4:	bf00      	nop
	}

	return value;
 80053b6:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80053b8:	b21b      	sxth	r3, r3
}
 80053ba:	4618      	mov	r0, r3
 80053bc:	372c      	adds	r7, #44	; 0x2c
 80053be:	46bd      	mov	sp, r7
 80053c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80053c4:	4770      	bx	lr
 80053c6:	bf00      	nop
 80053c8:	47000000 	.word	0x47000000

080053cc <DATA_RTXD_Run>:
#include "modules/data_select/data_select.h"

DATA_e gData_e[DATA_TXD_SIZE/2-1]={STA_DATA,IA_DATA,IA_DATA,IA_DATA,IA_DATA};

void DATA_RTXD_Run(CTRL_Handle handle, HAL_Handle halHandle, const HAL_AdcData_t *pAdcData, const HAL_QepData_t *pQepData)
{
 80053cc:	b580      	push	{r7, lr}
 80053ce:	b08a      	sub	sp, #40	; 0x28
 80053d0:	af02      	add	r7, sp, #8
 80053d2:	60f8      	str	r0, [r7, #12]
 80053d4:	60b9      	str	r1, [r7, #8]
 80053d6:	607a      	str	r2, [r7, #4]
 80053d8:	603b      	str	r3, [r7, #0]
	DATA_RTXD_Obj *obj = (DATA_RTXD_Obj *)(handle->data_rtxd_handle);
 80053da:	68fb      	ldr	r3, [r7, #12]
 80053dc:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
 80053e0:	61bb      	str	r3, [r7, #24]
	uint8_t i;
	int16_t value;
	obj->data_txd[0] = 0x11;
 80053e2:	69bb      	ldr	r3, [r7, #24]
 80053e4:	2211      	movs	r2, #17
 80053e6:	73da      	strb	r2, [r3, #15]
	obj->data_txd[1] = 0xEB;
 80053e8:	69bb      	ldr	r3, [r7, #24]
 80053ea:	22eb      	movs	r2, #235	; 0xeb
 80053ec:	741a      	strb	r2, [r3, #16]

	obj->data_txd[2] = (uint8_t)( obj->time & (uint16_t)0x00FF );
 80053ee:	69bb      	ldr	r3, [r7, #24]
 80053f0:	8b9b      	ldrh	r3, [r3, #28]
 80053f2:	b2da      	uxtb	r2, r3
 80053f4:	69bb      	ldr	r3, [r7, #24]
 80053f6:	745a      	strb	r2, [r3, #17]
	obj->data_txd[3] = (uint8_t)( ((obj->time)>>8) & (uint16_t)0x00FF );
 80053f8:	69bb      	ldr	r3, [r7, #24]
 80053fa:	8b9b      	ldrh	r3, [r3, #28]
 80053fc:	0a1b      	lsrs	r3, r3, #8
 80053fe:	b29b      	uxth	r3, r3
 8005400:	b2da      	uxtb	r2, r3
 8005402:	69bb      	ldr	r3, [r7, #24]
 8005404:	749a      	strb	r2, [r3, #18]
	obj->time++;
 8005406:	69bb      	ldr	r3, [r7, #24]
 8005408:	8b9b      	ldrh	r3, [r3, #28]
 800540a:	3301      	adds	r3, #1
 800540c:	b29a      	uxth	r2, r3
 800540e:	69bb      	ldr	r3, [r7, #24]
 8005410:	839a      	strh	r2, [r3, #28]

	obj->data_txd[DATA_TXD_SIZE-1] = 0;
 8005412:	69bb      	ldr	r3, [r7, #24]
 8005414:	2200      	movs	r2, #0
 8005416:	76da      	strb	r2, [r3, #27]
	obj->data_txd[DATA_TXD_SIZE-1] += obj->data_txd[0] + obj->data_txd[1] + obj->data_txd[2] + obj->data_txd[3];
 8005418:	69bb      	ldr	r3, [r7, #24]
 800541a:	7eda      	ldrb	r2, [r3, #27]
 800541c:	69bb      	ldr	r3, [r7, #24]
 800541e:	7bd9      	ldrb	r1, [r3, #15]
 8005420:	69bb      	ldr	r3, [r7, #24]
 8005422:	7c1b      	ldrb	r3, [r3, #16]
 8005424:	440b      	add	r3, r1
 8005426:	b2d9      	uxtb	r1, r3
 8005428:	69bb      	ldr	r3, [r7, #24]
 800542a:	7c5b      	ldrb	r3, [r3, #17]
 800542c:	440b      	add	r3, r1
 800542e:	b2d9      	uxtb	r1, r3
 8005430:	69bb      	ldr	r3, [r7, #24]
 8005432:	7c9b      	ldrb	r3, [r3, #18]
 8005434:	440b      	add	r3, r1
 8005436:	b2db      	uxtb	r3, r3
 8005438:	4413      	add	r3, r2
 800543a:	b2da      	uxtb	r2, r3
 800543c:	69bb      	ldr	r3, [r7, #24]
 800543e:	76da      	strb	r2, [r3, #27]

	for(i=2;i<DATA_TXD_SIZE/2;i++)
 8005440:	2302      	movs	r3, #2
 8005442:	77fb      	strb	r3, [r7, #31]
 8005444:	e03a      	b.n	80054bc <DATA_RTXD_Run+0xf0>
	{
		value = DATA_Select(handle, halHandle, pAdcData, pQepData, gData_e[i-1]);
 8005446:	7ffb      	ldrb	r3, [r7, #31]
 8005448:	3b01      	subs	r3, #1
 800544a:	4a21      	ldr	r2, [pc, #132]	; (80054d0 <DATA_RTXD_Run+0x104>)
 800544c:	5cd3      	ldrb	r3, [r2, r3]
 800544e:	9300      	str	r3, [sp, #0]
 8005450:	68f8      	ldr	r0, [r7, #12]
 8005452:	68b9      	ldr	r1, [r7, #8]
 8005454:	687a      	ldr	r2, [r7, #4]
 8005456:	683b      	ldr	r3, [r7, #0]
 8005458:	f7ff fdac 	bl	8004fb4 <DATA_Select>
 800545c:	4603      	mov	r3, r0
 800545e:	82fb      	strh	r3, [r7, #22]
		obj->data_txd[i+i] = (uint8_t)( value & (uint16_t)0x00FF );
 8005460:	7ffa      	ldrb	r2, [r7, #31]
 8005462:	7ffb      	ldrb	r3, [r7, #31]
 8005464:	4413      	add	r3, r2
 8005466:	8afa      	ldrh	r2, [r7, #22]
 8005468:	b2d1      	uxtb	r1, r2
 800546a:	69ba      	ldr	r2, [r7, #24]
 800546c:	4413      	add	r3, r2
 800546e:	460a      	mov	r2, r1
 8005470:	73da      	strb	r2, [r3, #15]
		obj->data_txd[i+i+1] = (uint8_t)( (value>>8) & (uint16_t)0x00FF );
 8005472:	7ffa      	ldrb	r2, [r7, #31]
 8005474:	7ffb      	ldrb	r3, [r7, #31]
 8005476:	4413      	add	r3, r2
 8005478:	3301      	adds	r3, #1
 800547a:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 800547e:	1212      	asrs	r2, r2, #8
 8005480:	b292      	uxth	r2, r2
 8005482:	b2d1      	uxtb	r1, r2
 8005484:	69ba      	ldr	r2, [r7, #24]
 8005486:	4413      	add	r3, r2
 8005488:	460a      	mov	r2, r1
 800548a:	73da      	strb	r2, [r3, #15]
		obj->data_txd[DATA_TXD_SIZE-1] += obj->data_txd[i+i] + obj->data_txd[i+i+1];
 800548c:	69bb      	ldr	r3, [r7, #24]
 800548e:	7eda      	ldrb	r2, [r3, #27]
 8005490:	7ff9      	ldrb	r1, [r7, #31]
 8005492:	7ffb      	ldrb	r3, [r7, #31]
 8005494:	440b      	add	r3, r1
 8005496:	69b9      	ldr	r1, [r7, #24]
 8005498:	440b      	add	r3, r1
 800549a:	7bd9      	ldrb	r1, [r3, #15]
 800549c:	7ff8      	ldrb	r0, [r7, #31]
 800549e:	7ffb      	ldrb	r3, [r7, #31]
 80054a0:	4403      	add	r3, r0
 80054a2:	3301      	adds	r3, #1
 80054a4:	69b8      	ldr	r0, [r7, #24]
 80054a6:	4403      	add	r3, r0
 80054a8:	7bdb      	ldrb	r3, [r3, #15]
 80054aa:	440b      	add	r3, r1
 80054ac:	b2db      	uxtb	r3, r3
 80054ae:	4413      	add	r3, r2
 80054b0:	b2da      	uxtb	r2, r3
 80054b2:	69bb      	ldr	r3, [r7, #24]
 80054b4:	76da      	strb	r2, [r3, #27]
	obj->time++;

	obj->data_txd[DATA_TXD_SIZE-1] = 0;
	obj->data_txd[DATA_TXD_SIZE-1] += obj->data_txd[0] + obj->data_txd[1] + obj->data_txd[2] + obj->data_txd[3];

	for(i=2;i<DATA_TXD_SIZE/2;i++)
 80054b6:	7ffb      	ldrb	r3, [r7, #31]
 80054b8:	3301      	adds	r3, #1
 80054ba:	77fb      	strb	r3, [r7, #31]
 80054bc:	7ffb      	ldrb	r3, [r7, #31]
 80054be:	2b05      	cmp	r3, #5
 80054c0:	d9c1      	bls.n	8005446 <DATA_RTXD_Run+0x7a>
//	for(i=0;i<DATA_TXD_SIZE;i++)
//	{
//		obj->data_txd[i]=i;
//	}
	
	Reset_DATA_TXD(obj);
 80054c2:	69b8      	ldr	r0, [r7, #24]
 80054c4:	f7ff fd52 	bl	8004f6c <Reset_DATA_TXD>

}
 80054c8:	3720      	adds	r7, #32
 80054ca:	46bd      	mov	sp, r7
 80054cc:	bd80      	pop	{r7, pc}
 80054ce:	bf00      	nop
 80054d0:	2001000c 	.word	0x2001000c

080054d4 <DATA_RTXD_Decode>:

void DATA_RTXD_Decode(CTRL_Handle handle, HAL_Handle halHandle)
{
 80054d4:	b580      	push	{r7, lr}
 80054d6:	b086      	sub	sp, #24
 80054d8:	af00      	add	r7, sp, #0
 80054da:	6078      	str	r0, [r7, #4]
 80054dc:	6039      	str	r1, [r7, #0]
	DATA_RTXD_Obj *obj = (DATA_RTXD_Obj *)(handle->data_rtxd_handle);
 80054de:	687b      	ldr	r3, [r7, #4]
 80054e0:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
 80054e4:	60fb      	str	r3, [r7, #12]
	uint8_t i,value=0;
 80054e6:	2300      	movs	r3, #0
 80054e8:	75bb      	strb	r3, [r7, #22]
	float_t value1=0.0f;
 80054ea:	f04f 0300 	mov.w	r3, #0
 80054ee:	613b      	str	r3, [r7, #16]

	if(!(DATA_RXD_Status(handle->data_rtxd_handle)))
 80054f0:	687b      	ldr	r3, [r7, #4]
 80054f2:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
 80054f6:	4618      	mov	r0, r3
 80054f8:	f7ff fd48 	bl	8004f8c <DATA_RXD_Status>
 80054fc:	4603      	mov	r3, r0
 80054fe:	2b00      	cmp	r3, #0
 8005500:	f040 80df 	bne.w	80056c2 <DATA_RTXD_Decode+0x1ee>
	{
		for(i=0;i<DATA_RXD_SIZE-1;i++)
 8005504:	2300      	movs	r3, #0
 8005506:	75fb      	strb	r3, [r7, #23]
 8005508:	e009      	b.n	800551e <DATA_RTXD_Decode+0x4a>
		{
//			if(obj->data_rxd[i]>=32)
//			{
//				obj->data_rxd[i] -= 32;//0x20:32
				value += obj->data_rxd[i];
 800550a:	7dfb      	ldrb	r3, [r7, #23]
 800550c:	68fa      	ldr	r2, [r7, #12]
 800550e:	4413      	add	r3, r2
 8005510:	785a      	ldrb	r2, [r3, #1]
 8005512:	7dbb      	ldrb	r3, [r7, #22]
 8005514:	4413      	add	r3, r2
 8005516:	75bb      	strb	r3, [r7, #22]
	uint8_t i,value=0;
	float_t value1=0.0f;

	if(!(DATA_RXD_Status(handle->data_rtxd_handle)))
	{
		for(i=0;i<DATA_RXD_SIZE-1;i++)
 8005518:	7dfb      	ldrb	r3, [r7, #23]
 800551a:	3301      	adds	r3, #1
 800551c:	75fb      	strb	r3, [r7, #23]
 800551e:	7dfb      	ldrb	r3, [r7, #23]
 8005520:	2b0b      	cmp	r3, #11
 8005522:	d9f2      	bls.n	800550a <DATA_RTXD_Decode+0x36>
//				obj->data_rxd[i] -= 32;//0x20:32
				value += obj->data_rxd[i];
//			}
		}
//		obj->data_rxd[DATA_RXD_SIZE-1] -= 32;//0x20:32
		if( obj->data_rxd[0]==0x01 && obj->data_rxd[1]==0x0E && value== obj->data_rxd[DATA_RXD_SIZE-1] )
 8005524:	68fb      	ldr	r3, [r7, #12]
 8005526:	785b      	ldrb	r3, [r3, #1]
 8005528:	2b01      	cmp	r3, #1
 800552a:	f040 80c7 	bne.w	80056bc <DATA_RTXD_Decode+0x1e8>
 800552e:	68fb      	ldr	r3, [r7, #12]
 8005530:	789b      	ldrb	r3, [r3, #2]
 8005532:	2b0e      	cmp	r3, #14
 8005534:	f040 80c2 	bne.w	80056bc <DATA_RTXD_Decode+0x1e8>
 8005538:	68fb      	ldr	r3, [r7, #12]
 800553a:	7b5b      	ldrb	r3, [r3, #13]
 800553c:	7dba      	ldrb	r2, [r7, #22]
 800553e:	429a      	cmp	r2, r3
 8005540:	f040 80bc 	bne.w	80056bc <DATA_RTXD_Decode+0x1e8>
		{
			for(i=2;i<DATA_RXD_SIZE-1;i++)
 8005544:	2302      	movs	r3, #2
 8005546:	75fb      	strb	r3, [r7, #23]
 8005548:	e0b4      	b.n	80056b4 <DATA_RTXD_Decode+0x1e0>
			{
				if( i<DATA_RXD_SIZE/2 && obj->data_rxd[i]>STA_DATA && obj->data_rxd[i]<END_DATA )
 800554a:	7dfb      	ldrb	r3, [r7, #23]
 800554c:	2b05      	cmp	r3, #5
 800554e:	d814      	bhi.n	800557a <DATA_RTXD_Decode+0xa6>
 8005550:	7dfb      	ldrb	r3, [r7, #23]
 8005552:	68fa      	ldr	r2, [r7, #12]
 8005554:	4413      	add	r3, r2
 8005556:	785b      	ldrb	r3, [r3, #1]
 8005558:	2b00      	cmp	r3, #0
 800555a:	d00e      	beq.n	800557a <DATA_RTXD_Decode+0xa6>
 800555c:	7dfb      	ldrb	r3, [r7, #23]
 800555e:	68fa      	ldr	r2, [r7, #12]
 8005560:	4413      	add	r3, r2
 8005562:	785b      	ldrb	r3, [r3, #1]
 8005564:	2b36      	cmp	r3, #54	; 0x36
 8005566:	d808      	bhi.n	800557a <DATA_RTXD_Decode+0xa6>
				{
					gData_e[i-1] = (DATA_e)obj->data_rxd[i];
 8005568:	7dfb      	ldrb	r3, [r7, #23]
 800556a:	3b01      	subs	r3, #1
 800556c:	7dfa      	ldrb	r2, [r7, #23]
 800556e:	68f9      	ldr	r1, [r7, #12]
 8005570:	440a      	add	r2, r1
 8005572:	7851      	ldrb	r1, [r2, #1]
 8005574:	4a55      	ldr	r2, [pc, #340]	; (80056cc <DATA_RTXD_Decode+0x1f8>)
 8005576:	54d1      	strb	r1, [r2, r3]
 8005578:	e099      	b.n	80056ae <DATA_RTXD_Decode+0x1da>
				}
				else if( i<DATA_RXD_SIZE/2+1 && obj->data_rxd[i]>CTRL_State_Error && obj->data_rxd[i]<CTRL_numStates)
 800557a:	7dfb      	ldrb	r3, [r7, #23]
 800557c:	2b06      	cmp	r3, #6
 800557e:	d816      	bhi.n	80055ae <DATA_RTXD_Decode+0xda>
 8005580:	7dfb      	ldrb	r3, [r7, #23]
 8005582:	68fa      	ldr	r2, [r7, #12]
 8005584:	4413      	add	r3, r2
 8005586:	785b      	ldrb	r3, [r3, #1]
 8005588:	2b00      	cmp	r3, #0
 800558a:	d010      	beq.n	80055ae <DATA_RTXD_Decode+0xda>
 800558c:	7dfb      	ldrb	r3, [r7, #23]
 800558e:	68fa      	ldr	r2, [r7, #12]
 8005590:	4413      	add	r3, r2
 8005592:	785b      	ldrb	r3, [r3, #1]
 8005594:	2b09      	cmp	r3, #9
 8005596:	d80a      	bhi.n	80055ae <DATA_RTXD_Decode+0xda>
				{
					handle->prevState = handle->state;
 8005598:	687b      	ldr	r3, [r7, #4]
 800559a:	7a1a      	ldrb	r2, [r3, #8]
 800559c:	687b      	ldr	r3, [r7, #4]
 800559e:	725a      	strb	r2, [r3, #9]
					handle->state = (CTRL_State_e)obj->data_rxd[i];
 80055a0:	7dfb      	ldrb	r3, [r7, #23]
 80055a2:	68fa      	ldr	r2, [r7, #12]
 80055a4:	4413      	add	r3, r2
 80055a6:	785a      	ldrb	r2, [r3, #1]
 80055a8:	687b      	ldr	r3, [r7, #4]
 80055aa:	721a      	strb	r2, [r3, #8]
 80055ac:	e07f      	b.n	80056ae <DATA_RTXD_Decode+0x1da>
				}
				else if(  i<DATA_RXD_SIZE/2+2 && obj->data_rxd[i]>USER_Motor_Cmd_Err && obj->data_rxd[i]<USER_Motor_Cmd_Num )
 80055ae:	7dfb      	ldrb	r3, [r7, #23]
 80055b0:	2b07      	cmp	r3, #7
 80055b2:	d87c      	bhi.n	80056ae <DATA_RTXD_Decode+0x1da>
 80055b4:	7dfb      	ldrb	r3, [r7, #23]
 80055b6:	68fa      	ldr	r2, [r7, #12]
 80055b8:	4413      	add	r3, r2
 80055ba:	785b      	ldrb	r3, [r3, #1]
 80055bc:	2b00      	cmp	r3, #0
 80055be:	d076      	beq.n	80056ae <DATA_RTXD_Decode+0x1da>
 80055c0:	7dfb      	ldrb	r3, [r7, #23]
 80055c2:	68fa      	ldr	r2, [r7, #12]
 80055c4:	4413      	add	r3, r2
 80055c6:	785b      	ldrb	r3, [r3, #1]
 80055c8:	2b06      	cmp	r3, #6
 80055ca:	d870      	bhi.n	80056ae <DATA_RTXD_Decode+0x1da>
				{
					value1 = obj->data_rxd[i+1] + obj->data_rxd[i+2]*256.0f;
 80055cc:	7dfb      	ldrb	r3, [r7, #23]
 80055ce:	3301      	adds	r3, #1
 80055d0:	68fa      	ldr	r2, [r7, #12]
 80055d2:	4413      	add	r3, r2
 80055d4:	785b      	ldrb	r3, [r3, #1]
 80055d6:	ee07 3a90 	vmov	s15, r3
 80055da:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 80055de:	7dfb      	ldrb	r3, [r7, #23]
 80055e0:	3302      	adds	r3, #2
 80055e2:	68fa      	ldr	r2, [r7, #12]
 80055e4:	4413      	add	r3, r2
 80055e6:	785b      	ldrb	r3, [r3, #1]
 80055e8:	ee07 3a90 	vmov	s15, r3
 80055ec:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80055f0:	eddf 6a37 	vldr	s13, [pc, #220]	; 80056d0 <DATA_RTXD_Decode+0x1fc>
 80055f4:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80055f8:	ee77 7a27 	vadd.f32	s15, s14, s15
 80055fc:	edc7 7a04 	vstr	s15, [r7, #16]
					if( value1 > 32767.0f )
 8005600:	edd7 7a04 	vldr	s15, [r7, #16]
 8005604:	ed9f 7a33 	vldr	s14, [pc, #204]	; 80056d4 <DATA_RTXD_Decode+0x200>
 8005608:	eef4 7ac7 	vcmpe.f32	s15, s14
 800560c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005610:	dd07      	ble.n	8005622 <DATA_RTXD_Decode+0x14e>
					{
						value1 -= 65536.0f;
 8005612:	edd7 7a04 	vldr	s15, [r7, #16]
 8005616:	ed9f 7a30 	vldr	s14, [pc, #192]	; 80056d8 <DATA_RTXD_Decode+0x204>
 800561a:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800561e:	edc7 7a04 	vstr	s15, [r7, #16]
					}
					value1 *= 0.00004f;
 8005622:	edd7 7a04 	vldr	s15, [r7, #16]
 8005626:	ed9f 7a2d 	vldr	s14, [pc, #180]	; 80056dc <DATA_RTXD_Decode+0x208>
 800562a:	ee67 7a87 	vmul.f32	s15, s15, s14
 800562e:	edc7 7a04 	vstr	s15, [r7, #16]
					switch(obj->data_rxd[i])
 8005632:	7dfb      	ldrb	r3, [r7, #23]
 8005634:	68fa      	ldr	r2, [r7, #12]
 8005636:	4413      	add	r3, r2
 8005638:	785b      	ldrb	r3, [r3, #1]
 800563a:	3b01      	subs	r3, #1
 800563c:	2b05      	cmp	r3, #5
 800563e:	d835      	bhi.n	80056ac <DATA_RTXD_Decode+0x1d8>
 8005640:	a201      	add	r2, pc, #4	; (adr r2, 8005648 <DATA_RTXD_Decode+0x174>)
 8005642:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005646:	bf00      	nop
 8005648:	08005661 	.word	0x08005661
 800564c:	0800566b 	.word	0x0800566b
 8005650:	08005675 	.word	0x08005675
 8005654:	0800567f 	.word	0x0800567f
 8005658:	08005689 	.word	0x08005689
 800565c:	0800569b 	.word	0x0800569b
					{
						case USER_Motor_Speed_Ref:
							handle->spd_ref = value1;
 8005660:	687b      	ldr	r3, [r7, #4]
 8005662:	693a      	ldr	r2, [r7, #16]
 8005664:	f8c3 21e4 	str.w	r2, [r3, #484]	; 0x1e4
							break;
 8005668:	e021      	b.n	80056ae <DATA_RTXD_Decode+0x1da>
						case USER_Motor_Speed_P:
							handle->Kp_spd = value1;
 800566a:	687b      	ldr	r3, [r7, #4]
 800566c:	693a      	ldr	r2, [r7, #16]
 800566e:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
							break;
 8005672:	e01c      	b.n	80056ae <DATA_RTXD_Decode+0x1da>
						case USER_Motor_Speed_I:
							handle->Ki_spd = value1;
 8005674:	687b      	ldr	r3, [r7, #4]
 8005676:	693a      	ldr	r2, [r7, #16]
 8005678:	f8c3 21bc 	str.w	r2, [r3, #444]	; 0x1bc
							break;
 800567c:	e017      	b.n	80056ae <DATA_RTXD_Decode+0x1da>
						case USER_Motor_Iq_Ref:
							handle->Idq_ref.value[1] = value1;
 800567e:	687b      	ldr	r3, [r7, #4]
 8005680:	693a      	ldr	r2, [r7, #16]
 8005682:	f8c3 21dc 	str.w	r2, [r3, #476]	; 0x1dc
							break;
 8005686:	e012      	b.n	80056ae <DATA_RTXD_Decode+0x1da>
						case USER_Motor_Iq_P:
							handle->Kp_Id = value1;
 8005688:	687b      	ldr	r3, [r7, #4]
 800568a:	693a      	ldr	r2, [r7, #16]
 800568c:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
							handle->Kp_Iq = value1;
 8005690:	687b      	ldr	r3, [r7, #4]
 8005692:	693a      	ldr	r2, [r7, #16]
 8005694:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
							break;
 8005698:	e009      	b.n	80056ae <DATA_RTXD_Decode+0x1da>
						case USER_Motor_Iq_I:
							handle->Ki_Id = value1;
 800569a:	687b      	ldr	r3, [r7, #4]
 800569c:	693a      	ldr	r2, [r7, #16]
 800569e:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
							handle->Ki_Iq = value1;
 80056a2:	687b      	ldr	r3, [r7, #4]
 80056a4:	693a      	ldr	r2, [r7, #16]
 80056a6:	f8c3 21b8 	str.w	r2, [r3, #440]	; 0x1b8
							break;
 80056aa:	e000      	b.n	80056ae <DATA_RTXD_Decode+0x1da>
						default:
							break;
 80056ac:	bf00      	nop
//			}
		}
//		obj->data_rxd[DATA_RXD_SIZE-1] -= 32;//0x20:32
		if( obj->data_rxd[0]==0x01 && obj->data_rxd[1]==0x0E && value== obj->data_rxd[DATA_RXD_SIZE-1] )
		{
			for(i=2;i<DATA_RXD_SIZE-1;i++)
 80056ae:	7dfb      	ldrb	r3, [r7, #23]
 80056b0:	3301      	adds	r3, #1
 80056b2:	75fb      	strb	r3, [r7, #23]
 80056b4:	7dfb      	ldrb	r3, [r7, #23]
 80056b6:	2b0b      	cmp	r3, #11
 80056b8:	f67f af47 	bls.w	800554a <DATA_RTXD_Decode+0x76>
							break;
					}
				}
			}
		}
		Reset_DATA_RXD(obj);
 80056bc:	68f8      	ldr	r0, [r7, #12]
 80056be:	f7ff fc45 	bl	8004f4c <Reset_DATA_RXD>
	}

	return;
 80056c2:	bf00      	nop
}
 80056c4:	3718      	adds	r7, #24
 80056c6:	46bd      	mov	sp, r7
 80056c8:	bd80      	pop	{r7, pc}
 80056ca:	bf00      	nop
 80056cc:	2001000c 	.word	0x2001000c
 80056d0:	43800000 	.word	0x43800000
 80056d4:	46fffe00 	.word	0x46fffe00
 80056d8:	47800000 	.word	0x47800000
 80056dc:	3827c5ac 	.word	0x3827c5ac

080056e0 <FILTER_FO_init>:
  return;
} // end of FILTER_FO_getNumCoeffs() function


FILTER_FO_Handle FILTER_FO_init(void *pMemory,const size_t numBytes)
{
 80056e0:	b480      	push	{r7}
 80056e2:	b085      	sub	sp, #20
 80056e4:	af00      	add	r7, sp, #0
 80056e6:	6078      	str	r0, [r7, #4]
 80056e8:	6039      	str	r1, [r7, #0]
  FILTER_FO_Handle handle;


  if(numBytes < sizeof(FILTER_FO_Obj))
 80056ea:	683b      	ldr	r3, [r7, #0]
 80056ec:	2b13      	cmp	r3, #19
 80056ee:	d801      	bhi.n	80056f4 <FILTER_FO_init+0x14>
    return((FILTER_FO_Handle)NULL);
 80056f0:	2300      	movs	r3, #0
 80056f2:	e002      	b.n	80056fa <FILTER_FO_init+0x1a>

  // assign the handle
  handle = (FILTER_FO_Handle)pMemory;
 80056f4:	687b      	ldr	r3, [r7, #4]
 80056f6:	60fb      	str	r3, [r7, #12]

  return(handle);
 80056f8:	68fb      	ldr	r3, [r7, #12]
} // end of FILTER_FO_init() function
 80056fa:	4618      	mov	r0, r3
 80056fc:	3714      	adds	r7, #20
 80056fe:	46bd      	mov	sp, r7
 8005700:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005704:	4770      	bx	lr
 8005706:	bf00      	nop

08005708 <FILTER_FO_setDenCoeffs>:


void FILTER_FO_setDenCoeffs(FILTER_FO_Handle handle,const float_t a1)
{
 8005708:	b480      	push	{r7}
 800570a:	b085      	sub	sp, #20
 800570c:	af00      	add	r7, sp, #0
 800570e:	6078      	str	r0, [r7, #4]
 8005710:	ed87 0a00 	vstr	s0, [r7]
  FILTER_FO_Obj *obj = (FILTER_FO_Obj *)handle;
 8005714:	687b      	ldr	r3, [r7, #4]
 8005716:	60fb      	str	r3, [r7, #12]


  obj->a1 = a1;
 8005718:	68fb      	ldr	r3, [r7, #12]
 800571a:	683a      	ldr	r2, [r7, #0]
 800571c:	601a      	str	r2, [r3, #0]

  return;
 800571e:	bf00      	nop
} // end of FILTER_FO_setDenCoeffs() function
 8005720:	3714      	adds	r7, #20
 8005722:	46bd      	mov	sp, r7
 8005724:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005728:	4770      	bx	lr
 800572a:	bf00      	nop

0800572c <FILTER_FO_setInitialConditions>:


void FILTER_FO_setInitialConditions(FILTER_FO_Handle handle,const float_t x1,const float_t y1)
{
 800572c:	b480      	push	{r7}
 800572e:	b087      	sub	sp, #28
 8005730:	af00      	add	r7, sp, #0
 8005732:	60f8      	str	r0, [r7, #12]
 8005734:	ed87 0a02 	vstr	s0, [r7, #8]
 8005738:	edc7 0a01 	vstr	s1, [r7, #4]
  FILTER_FO_Obj *obj = (FILTER_FO_Obj *)handle;
 800573c:	68fb      	ldr	r3, [r7, #12]
 800573e:	617b      	str	r3, [r7, #20]


  obj->x1 = x1;
 8005740:	697b      	ldr	r3, [r7, #20]
 8005742:	68ba      	ldr	r2, [r7, #8]
 8005744:	60da      	str	r2, [r3, #12]

  obj->y1 = y1;
 8005746:	697b      	ldr	r3, [r7, #20]
 8005748:	687a      	ldr	r2, [r7, #4]
 800574a:	611a      	str	r2, [r3, #16]

  return;
 800574c:	bf00      	nop
} // end of FILTER_FO_setInitialConditions() function
 800574e:	371c      	adds	r7, #28
 8005750:	46bd      	mov	sp, r7
 8005752:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005756:	4770      	bx	lr

08005758 <FILTER_FO_setNumCoeffs>:


void FILTER_FO_setNumCoeffs(FILTER_FO_Handle handle,const float_t b0,const float_t b1)
{
 8005758:	b480      	push	{r7}
 800575a:	b087      	sub	sp, #28
 800575c:	af00      	add	r7, sp, #0
 800575e:	60f8      	str	r0, [r7, #12]
 8005760:	ed87 0a02 	vstr	s0, [r7, #8]
 8005764:	edc7 0a01 	vstr	s1, [r7, #4]
  FILTER_FO_Obj *obj = (FILTER_FO_Obj *)handle;
 8005768:	68fb      	ldr	r3, [r7, #12]
 800576a:	617b      	str	r3, [r7, #20]


  obj->b0 = b0;
 800576c:	697b      	ldr	r3, [r7, #20]
 800576e:	68ba      	ldr	r2, [r7, #8]
 8005770:	605a      	str	r2, [r3, #4]
  obj->b1 = b1;
 8005772:	697b      	ldr	r3, [r7, #20]
 8005774:	687a      	ldr	r2, [r7, #4]
 8005776:	609a      	str	r2, [r3, #8]

  return;
 8005778:	bf00      	nop
} // end of FILTER_FO_setNumCoeffs() function
 800577a:	371c      	adds	r7, #28
 800577c:	46bd      	mov	sp, r7
 800577e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005782:	4770      	bx	lr

08005784 <HAL_getNumCurrentSensors>:

//! \brief     Gets the number of current sensors
//! \param[in] handle  The hardware abstraction layer (HAL) handle
//! \return    The number of current sensors
static inline uint_least8_t HAL_getNumCurrentSensors(HAL_Handle handle)
{
 8005784:	b480      	push	{r7}
 8005786:	b085      	sub	sp, #20
 8005788:	af00      	add	r7, sp, #0
 800578a:	6078      	str	r0, [r7, #4]
  HAL_Obj *obj = (HAL_Obj *)handle;
 800578c:	687b      	ldr	r3, [r7, #4]
 800578e:	60fb      	str	r3, [r7, #12]
  

  return(obj->numCurrentSensors);
 8005790:	68fb      	ldr	r3, [r7, #12]
 8005792:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
} // end of HAL_getNumCurrentSensors() function
 8005796:	4618      	mov	r0, r3
 8005798:	3714      	adds	r7, #20
 800579a:	46bd      	mov	sp, r7
 800579c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80057a0:	4770      	bx	lr
 80057a2:	bf00      	nop

080057a4 <HAL_getNumVoltageSensors>:

//! \brief     Gets the number of voltage sensors
//! \param[in] handle  The hardware abstraction layer (HAL) handle
//! \return    The number of voltage sensors
static inline uint_least8_t HAL_getNumVoltageSensors(HAL_Handle handle)
{
 80057a4:	b480      	push	{r7}
 80057a6:	b085      	sub	sp, #20
 80057a8:	af00      	add	r7, sp, #0
 80057aa:	6078      	str	r0, [r7, #4]
  HAL_Obj *obj = (HAL_Obj *)handle;
 80057ac:	687b      	ldr	r3, [r7, #4]
 80057ae:	60fb      	str	r3, [r7, #12]
  

  return(obj->numVoltageSensors);
 80057b0:	68fb      	ldr	r3, [r7, #12]
 80057b2:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
} // end of HAL_getNumVoltageSensors() function
 80057b6:	4618      	mov	r0, r3
 80057b8:	3714      	adds	r7, #20
 80057ba:	46bd      	mov	sp, r7
 80057bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80057c0:	4770      	bx	lr
 80057c2:	bf00      	nop

080057c4 <HAL_setBias>:
//! \param[in] bias          The ADC bias value
static inline void HAL_setBias(HAL_Handle handle,
                               const HAL_SensorType_e sensorType,
                               uint_least8_t sensorNumber,
                               const float_t bias)//! \Mod By Dl.K
{
 80057c4:	b480      	push	{r7}
 80057c6:	b087      	sub	sp, #28
 80057c8:	af00      	add	r7, sp, #0
 80057ca:	60f8      	str	r0, [r7, #12]
 80057cc:	460b      	mov	r3, r1
 80057ce:	ed87 0a01 	vstr	s0, [r7, #4]
 80057d2:	72fb      	strb	r3, [r7, #11]
 80057d4:	4613      	mov	r3, r2
 80057d6:	72bb      	strb	r3, [r7, #10]
  HAL_Obj *obj = (HAL_Obj *)handle;
 80057d8:	68fb      	ldr	r3, [r7, #12]
 80057da:	617b      	str	r3, [r7, #20]


  if(sensorType == HAL_SensorType_Current)
 80057dc:	7afb      	ldrb	r3, [r7, #11]
 80057de:	2b00      	cmp	r3, #0
 80057e0:	d107      	bne.n	80057f2 <HAL_setBias+0x2e>
    {
      obj->adcBias.I.value[sensorNumber] = bias;
 80057e2:	7abb      	ldrb	r3, [r7, #10]
 80057e4:	697a      	ldr	r2, [r7, #20]
 80057e6:	3336      	adds	r3, #54	; 0x36
 80057e8:	009b      	lsls	r3, r3, #2
 80057ea:	4413      	add	r3, r2
 80057ec:	687a      	ldr	r2, [r7, #4]
 80057ee:	601a      	str	r2, [r3, #0]
 80057f0:	e009      	b.n	8005806 <HAL_setBias+0x42>
    }
  else if(sensorType == HAL_SensorType_Voltage)
 80057f2:	7afb      	ldrb	r3, [r7, #11]
 80057f4:	2b01      	cmp	r3, #1
 80057f6:	d106      	bne.n	8005806 <HAL_setBias+0x42>
    {
      obj->adcBias.V.value[sensorNumber] = bias;
 80057f8:	7abb      	ldrb	r3, [r7, #10]
 80057fa:	697a      	ldr	r2, [r7, #20]
 80057fc:	3338      	adds	r3, #56	; 0x38
 80057fe:	009b      	lsls	r3, r3, #2
 8005800:	4413      	add	r3, r2
 8005802:	687a      	ldr	r2, [r7, #4]
 8005804:	605a      	str	r2, [r3, #4]
    }

  return;
 8005806:	bf00      	nop
} // end of HAL_setBias() function
 8005808:	371c      	adds	r7, #28
 800580a:	46bd      	mov	sp, r7
 800580c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005810:	4770      	bx	lr
 8005812:	bf00      	nop

08005814 <HAL_setCurrentScaleFactor>:

//! \brief     Sets the current scale factor in the hardware abstraction layer
//! \param[in] handle      The hardware abstraction layer (HAL) handle
//! \param[in] current_sf  The current scale factor
static inline void HAL_setCurrentScaleFactor(HAL_Handle handle,const float_t current_sf)//! \Mod By Dl.K
{
 8005814:	b480      	push	{r7}
 8005816:	b085      	sub	sp, #20
 8005818:	af00      	add	r7, sp, #0
 800581a:	6078      	str	r0, [r7, #4]
 800581c:	ed87 0a00 	vstr	s0, [r7]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8005820:	687b      	ldr	r3, [r7, #4]
 8005822:	60fb      	str	r3, [r7, #12]
  

  obj->current_sf = current_sf;
 8005824:	68fb      	ldr	r3, [r7, #12]
 8005826:	683a      	ldr	r2, [r7, #0]
 8005828:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8

  return;
 800582c:	bf00      	nop
} // end of HAL_setCurrentScaleFactor() function
 800582e:	3714      	adds	r7, #20
 8005830:	46bd      	mov	sp, r7
 8005832:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005836:	4770      	bx	lr

08005838 <HAL_setNumCurrentSensors>:

//! \brief     Sets the number of current sensors
//! \param[in] handle             The hardware abstraction layer (HAL) handle
//! \param[in] numCurrentSensors  The number of current sensors
static inline void HAL_setNumCurrentSensors(HAL_Handle handle,const uint_least8_t numCurrentSensors)
{
 8005838:	b480      	push	{r7}
 800583a:	b085      	sub	sp, #20
 800583c:	af00      	add	r7, sp, #0
 800583e:	6078      	str	r0, [r7, #4]
 8005840:	460b      	mov	r3, r1
 8005842:	70fb      	strb	r3, [r7, #3]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8005844:	687b      	ldr	r3, [r7, #4]
 8005846:	60fb      	str	r3, [r7, #12]
  

  obj->numCurrentSensors = numCurrentSensors;
 8005848:	68fb      	ldr	r3, [r7, #12]
 800584a:	78fa      	ldrb	r2, [r7, #3]
 800584c:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100

  return;
 8005850:	bf00      	nop
} // end of HAL_setNumCurrentSensors() function
 8005852:	3714      	adds	r7, #20
 8005854:	46bd      	mov	sp, r7
 8005856:	f85d 7b04 	ldr.w	r7, [sp], #4
 800585a:	4770      	bx	lr

0800585c <HAL_setNumVoltageSensors>:

//! \brief     Sets the number of voltage sensors
//! \param[in] handle             The hardware abstraction layer (HAL) handle
//! \param[in] numVoltageSensors  The number of voltage sensors
static inline void HAL_setNumVoltageSensors(HAL_Handle handle,const uint_least8_t numVoltageSensors)
{
 800585c:	b480      	push	{r7}
 800585e:	b085      	sub	sp, #20
 8005860:	af00      	add	r7, sp, #0
 8005862:	6078      	str	r0, [r7, #4]
 8005864:	460b      	mov	r3, r1
 8005866:	70fb      	strb	r3, [r7, #3]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8005868:	687b      	ldr	r3, [r7, #4]
 800586a:	60fb      	str	r3, [r7, #12]
  

  obj->numVoltageSensors = numVoltageSensors;
 800586c:	68fb      	ldr	r3, [r7, #12]
 800586e:	78fa      	ldrb	r2, [r7, #3]
 8005870:	f883 2101 	strb.w	r2, [r3, #257]	; 0x101

  return;
 8005874:	bf00      	nop
} // end of HAL_setNumVoltageSensors() function
 8005876:	3714      	adds	r7, #20
 8005878:	46bd      	mov	sp, r7
 800587a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800587e:	4770      	bx	lr

08005880 <HAL_setOffsetBeta_lp_pu>:
//! \param[in] beta_lp_pu    The value used to set the low pass filter pole, pu
static inline void HAL_setOffsetBeta_lp_pu(HAL_Handle handle,
                                           const HAL_SensorType_e sensorType,
                                           const uint_least8_t sensorNumber,
                                           const float_t beta_lp_pu)//! \Mod By Dl.K
{
 8005880:	b580      	push	{r7, lr}
 8005882:	b086      	sub	sp, #24
 8005884:	af00      	add	r7, sp, #0
 8005886:	60f8      	str	r0, [r7, #12]
 8005888:	460b      	mov	r3, r1
 800588a:	ed87 0a01 	vstr	s0, [r7, #4]
 800588e:	72fb      	strb	r3, [r7, #11]
 8005890:	4613      	mov	r3, r2
 8005892:	72bb      	strb	r3, [r7, #10]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8005894:	68fb      	ldr	r3, [r7, #12]
 8005896:	617b      	str	r3, [r7, #20]

  if(sensorType == HAL_SensorType_Current)
 8005898:	7afb      	ldrb	r3, [r7, #11]
 800589a:	2b00      	cmp	r3, #0
 800589c:	d109      	bne.n	80058b2 <HAL_setOffsetBeta_lp_pu+0x32>
    {
      OFFSET_setBeta(obj->offsetHandle_I[sensorNumber],beta_lp_pu);
 800589e:	7aba      	ldrb	r2, [r7, #10]
 80058a0:	697b      	ldr	r3, [r7, #20]
 80058a2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80058a6:	4618      	mov	r0, r3
 80058a8:	ed97 0a01 	vldr	s0, [r7, #4]
 80058ac:	f000 f9ce 	bl	8005c4c <OFFSET_setBeta>
 80058b0:	e00d      	b.n	80058ce <HAL_setOffsetBeta_lp_pu+0x4e>
    }
  else if(sensorType == HAL_SensorType_Voltage)
 80058b2:	7afb      	ldrb	r3, [r7, #11]
 80058b4:	2b01      	cmp	r3, #1
 80058b6:	d10a      	bne.n	80058ce <HAL_setOffsetBeta_lp_pu+0x4e>
    {
      OFFSET_setBeta(obj->offsetHandle_V[sensorNumber],beta_lp_pu);
 80058b8:	7abb      	ldrb	r3, [r7, #10]
 80058ba:	697a      	ldr	r2, [r7, #20]
 80058bc:	331a      	adds	r3, #26
 80058be:	009b      	lsls	r3, r3, #2
 80058c0:	4413      	add	r3, r2
 80058c2:	685b      	ldr	r3, [r3, #4]
 80058c4:	4618      	mov	r0, r3
 80058c6:	ed97 0a01 	vldr	s0, [r7, #4]
 80058ca:	f000 f9bf 	bl	8005c4c <OFFSET_setBeta>
    }

  return;
 80058ce:	bf00      	nop
} // end of HAL_setOffsetBeta_lp_pu() function
 80058d0:	3718      	adds	r7, #24
 80058d2:	46bd      	mov	sp, r7
 80058d4:	bd80      	pop	{r7, pc}
 80058d6:	bf00      	nop

080058d8 <HAL_setOffsetInitCond>:
//! \param[in] initCond      The initial condition value
static inline void HAL_setOffsetInitCond(HAL_Handle handle,
                                         const HAL_SensorType_e sensorType,
                                         const uint_least8_t sensorNumber,
                                         const float_t initCond)//! \Mod By Dl.K
{
 80058d8:	b580      	push	{r7, lr}
 80058da:	b086      	sub	sp, #24
 80058dc:	af00      	add	r7, sp, #0
 80058de:	60f8      	str	r0, [r7, #12]
 80058e0:	460b      	mov	r3, r1
 80058e2:	ed87 0a01 	vstr	s0, [r7, #4]
 80058e6:	72fb      	strb	r3, [r7, #11]
 80058e8:	4613      	mov	r3, r2
 80058ea:	72bb      	strb	r3, [r7, #10]
  HAL_Obj *obj = (HAL_Obj *)handle;
 80058ec:	68fb      	ldr	r3, [r7, #12]
 80058ee:	617b      	str	r3, [r7, #20]

  if(sensorType == HAL_SensorType_Current)
 80058f0:	7afb      	ldrb	r3, [r7, #11]
 80058f2:	2b00      	cmp	r3, #0
 80058f4:	d109      	bne.n	800590a <HAL_setOffsetInitCond+0x32>
    {
      OFFSET_setInitCond(obj->offsetHandle_I[sensorNumber],initCond);
 80058f6:	7aba      	ldrb	r2, [r7, #10]
 80058f8:	697b      	ldr	r3, [r7, #20]
 80058fa:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80058fe:	4618      	mov	r0, r3
 8005900:	ed97 0a01 	vldr	s0, [r7, #4]
 8005904:	f000 f9cc 	bl	8005ca0 <OFFSET_setInitCond>
 8005908:	e00d      	b.n	8005926 <HAL_setOffsetInitCond+0x4e>
    }
  else if(sensorType == HAL_SensorType_Voltage)
 800590a:	7afb      	ldrb	r3, [r7, #11]
 800590c:	2b01      	cmp	r3, #1
 800590e:	d10a      	bne.n	8005926 <HAL_setOffsetInitCond+0x4e>
    {
      OFFSET_setInitCond(obj->offsetHandle_V[sensorNumber],initCond);
 8005910:	7abb      	ldrb	r3, [r7, #10]
 8005912:	697a      	ldr	r2, [r7, #20]
 8005914:	331a      	adds	r3, #26
 8005916:	009b      	lsls	r3, r3, #2
 8005918:	4413      	add	r3, r2
 800591a:	685b      	ldr	r3, [r3, #4]
 800591c:	4618      	mov	r0, r3
 800591e:	ed97 0a01 	vldr	s0, [r7, #4]
 8005922:	f000 f9bd 	bl	8005ca0 <OFFSET_setInitCond>
    }

  return;
 8005926:	bf00      	nop
} // end of HAL_setOffsetInitCond() function
 8005928:	3718      	adds	r7, #24
 800592a:	46bd      	mov	sp, r7
 800592c:	bd80      	pop	{r7, pc}
 800592e:	bf00      	nop

08005930 <HAL_setOffsetValue>:
//! \param[in] value         The initial offset value
static inline void HAL_setOffsetValue(HAL_Handle handle,
                                      const HAL_SensorType_e sensorType,
                                      const uint_least8_t sensorNumber,
                                      const float_t value)//! \Mod By Dl.K
{
 8005930:	b580      	push	{r7, lr}
 8005932:	b086      	sub	sp, #24
 8005934:	af00      	add	r7, sp, #0
 8005936:	60f8      	str	r0, [r7, #12]
 8005938:	460b      	mov	r3, r1
 800593a:	ed87 0a01 	vstr	s0, [r7, #4]
 800593e:	72fb      	strb	r3, [r7, #11]
 8005940:	4613      	mov	r3, r2
 8005942:	72bb      	strb	r3, [r7, #10]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8005944:	68fb      	ldr	r3, [r7, #12]
 8005946:	617b      	str	r3, [r7, #20]

  if(sensorType == HAL_SensorType_Current)
 8005948:	7afb      	ldrb	r3, [r7, #11]
 800594a:	2b00      	cmp	r3, #0
 800594c:	d109      	bne.n	8005962 <HAL_setOffsetValue+0x32>
    {
      OFFSET_setOffset(obj->offsetHandle_I[sensorNumber],value);
 800594e:	7aba      	ldrb	r2, [r7, #10]
 8005950:	697b      	ldr	r3, [r7, #20]
 8005952:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8005956:	4618      	mov	r0, r3
 8005958:	ed97 0a01 	vldr	s0, [r7, #4]
 800595c:	f000 f9b8 	bl	8005cd0 <OFFSET_setOffset>
 8005960:	e00d      	b.n	800597e <HAL_setOffsetValue+0x4e>
    }
  else if(sensorType == HAL_SensorType_Voltage)
 8005962:	7afb      	ldrb	r3, [r7, #11]
 8005964:	2b01      	cmp	r3, #1
 8005966:	d10a      	bne.n	800597e <HAL_setOffsetValue+0x4e>
    {
      OFFSET_setOffset(obj->offsetHandle_V[sensorNumber],value);
 8005968:	7abb      	ldrb	r3, [r7, #10]
 800596a:	697a      	ldr	r2, [r7, #20]
 800596c:	331a      	adds	r3, #26
 800596e:	009b      	lsls	r3, r3, #2
 8005970:	4413      	add	r3, r2
 8005972:	685b      	ldr	r3, [r3, #4]
 8005974:	4618      	mov	r0, r3
 8005976:	ed97 0a01 	vldr	s0, [r7, #4]
 800597a:	f000 f9a9 	bl	8005cd0 <OFFSET_setOffset>
    }

  return;
 800597e:	bf00      	nop
} // end of HAL_setOffsetValue() function
 8005980:	3718      	adds	r7, #24
 8005982:	46bd      	mov	sp, r7
 8005984:	bd80      	pop	{r7, pc}
 8005986:	bf00      	nop

08005988 <HAL_setVoltageScaleFactor>:

//! \brief     Sets the voltage scale factor in the hardware abstraction layer
//! \param[in] handle      The hardware abstraction layer (HAL) handle
//! \param[in] voltage_sf  The voltage scale factor
static inline void HAL_setVoltageScaleFactor(HAL_Handle handle,const float_t voltage_sf)//! \Mod By Dl.K
{
 8005988:	b480      	push	{r7}
 800598a:	b085      	sub	sp, #20
 800598c:	af00      	add	r7, sp, #0
 800598e:	6078      	str	r0, [r7, #4]
 8005990:	ed87 0a00 	vstr	s0, [r7]
  HAL_Obj *obj = (HAL_Obj *)handle;
 8005994:	687b      	ldr	r3, [r7, #4]
 8005996:	60fb      	str	r3, [r7, #12]
  
  obj->voltage_sf = voltage_sf;
 8005998:	68fb      	ldr	r3, [r7, #12]
 800599a:	683a      	ldr	r2, [r7, #0]
 800599c:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc

  return;
 80059a0:	bf00      	nop
} // end of HAL_setVoltageScaleFactor() function
 80059a2:	3714      	adds	r7, #20
 80059a4:	46bd      	mov	sp, r7
 80059a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80059aa:	4770      	bx	lr

080059ac <HAL_init>:

// **************************************************************************
// the functions

HAL_Handle HAL_init(void *pMemory,const size_t numBytes)
{
 80059ac:	b590      	push	{r4, r7, lr}
 80059ae:	b087      	sub	sp, #28
 80059b0:	af00      	add	r7, sp, #0
 80059b2:	6078      	str	r0, [r7, #4]
 80059b4:	6039      	str	r1, [r7, #0]
  uint_least8_t cnt;
  HAL_Handle handle;
  HAL_Obj *obj;


  if(numBytes < sizeof(HAL_Obj))
 80059b6:	683b      	ldr	r3, [r7, #0]
 80059b8:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 80059bc:	d201      	bcs.n	80059c2 <HAL_init+0x16>
    return((HAL_Handle)NULL);
 80059be:	2300      	movs	r3, #0
 80059c0:	e036      	b.n	8005a30 <HAL_init+0x84>


  // assign the handle
  handle = (HAL_Handle)pMemory;
 80059c2:	687b      	ldr	r3, [r7, #4]
 80059c4:	613b      	str	r3, [r7, #16]


  // assign the object
  obj = (HAL_Obj *)handle;
 80059c6:	693b      	ldr	r3, [r7, #16]
 80059c8:	60fb      	str	r3, [r7, #12]

  // initialize the current offset estimator handles
  for(cnt=0;cnt<USER_NUM_CURRENT_SENSORS;cnt++)
 80059ca:	2300      	movs	r3, #0
 80059cc:	75fb      	strb	r3, [r7, #23]
 80059ce:	e011      	b.n	80059f4 <HAL_init+0x48>
    {
      obj->offsetHandle_I[cnt] = OFFSET_init(&obj->offset_I[cnt],sizeof(obj->offset_I[cnt]));
 80059d0:	7dfc      	ldrb	r4, [r7, #23]
 80059d2:	7dfb      	ldrb	r3, [r7, #23]
 80059d4:	015b      	lsls	r3, r3, #5
 80059d6:	3308      	adds	r3, #8
 80059d8:	68fa      	ldr	r2, [r7, #12]
 80059da:	4413      	add	r3, r2
 80059dc:	3304      	adds	r3, #4
 80059de:	4618      	mov	r0, r3
 80059e0:	2120      	movs	r1, #32
 80059e2:	f000 f917 	bl	8005c14 <OFFSET_init>
 80059e6:	4602      	mov	r2, r0
 80059e8:	68fb      	ldr	r3, [r7, #12]
 80059ea:	f843 2024 	str.w	r2, [r3, r4, lsl #2]

  // assign the object
  obj = (HAL_Obj *)handle;

  // initialize the current offset estimator handles
  for(cnt=0;cnt<USER_NUM_CURRENT_SENSORS;cnt++)
 80059ee:	7dfb      	ldrb	r3, [r7, #23]
 80059f0:	3301      	adds	r3, #1
 80059f2:	75fb      	strb	r3, [r7, #23]
 80059f4:	7dfb      	ldrb	r3, [r7, #23]
 80059f6:	2b02      	cmp	r3, #2
 80059f8:	d9ea      	bls.n	80059d0 <HAL_init+0x24>
      obj->offsetHandle_I[cnt] = OFFSET_init(&obj->offset_I[cnt],sizeof(obj->offset_I[cnt]));
    }


  // initialize the voltage offset estimator handles
  for(cnt=0;cnt<USER_NUM_VOLTAGE_SENSORS;cnt++)
 80059fa:	2300      	movs	r3, #0
 80059fc:	75fb      	strb	r3, [r7, #23]
 80059fe:	e013      	b.n	8005a28 <HAL_init+0x7c>
    {
      obj->offsetHandle_V[cnt] = OFFSET_init(&obj->offset_V[cnt],sizeof(obj->offset_V[cnt]));
 8005a00:	7dfc      	ldrb	r4, [r7, #23]
 8005a02:	7dfb      	ldrb	r3, [r7, #23]
 8005a04:	015b      	lsls	r3, r3, #5
 8005a06:	3378      	adds	r3, #120	; 0x78
 8005a08:	68fa      	ldr	r2, [r7, #12]
 8005a0a:	4413      	add	r3, r2
 8005a0c:	4618      	mov	r0, r3
 8005a0e:	2120      	movs	r1, #32
 8005a10:	f000 f900 	bl	8005c14 <OFFSET_init>
 8005a14:	4601      	mov	r1, r0
 8005a16:	68fa      	ldr	r2, [r7, #12]
 8005a18:	f104 031a 	add.w	r3, r4, #26
 8005a1c:	009b      	lsls	r3, r3, #2
 8005a1e:	4413      	add	r3, r2
 8005a20:	6059      	str	r1, [r3, #4]
      obj->offsetHandle_I[cnt] = OFFSET_init(&obj->offset_I[cnt],sizeof(obj->offset_I[cnt]));
    }


  // initialize the voltage offset estimator handles
  for(cnt=0;cnt<USER_NUM_VOLTAGE_SENSORS;cnt++)
 8005a22:	7dfb      	ldrb	r3, [r7, #23]
 8005a24:	3301      	adds	r3, #1
 8005a26:	75fb      	strb	r3, [r7, #23]
 8005a28:	7dfb      	ldrb	r3, [r7, #23]
 8005a2a:	2b02      	cmp	r3, #2
 8005a2c:	d9e8      	bls.n	8005a00 <HAL_init+0x54>
    {
      obj->offsetHandle_V[cnt] = OFFSET_init(&obj->offset_V[cnt],sizeof(obj->offset_V[cnt]));
    }


  return(handle);
 8005a2e:	693b      	ldr	r3, [r7, #16]
} // end of HAL_init() function
 8005a30:	4618      	mov	r0, r3
 8005a32:	371c      	adds	r7, #28
 8005a34:	46bd      	mov	sp, r7
 8005a36:	bd90      	pop	{r4, r7, pc}

08005a38 <HAL_setParams>:


void HAL_setParams(HAL_Handle handle,const USER_Params *pUserParams)
{
 8005a38:	b580      	push	{r7, lr}
 8005a3a:	b086      	sub	sp, #24
 8005a3c:	af00      	add	r7, sp, #0
 8005a3e:	6078      	str	r0, [r7, #4]
 8005a40:	6039      	str	r1, [r7, #0]
  uint_least8_t cnt;
//  HAL_Obj *obj = (HAL_Obj *)handle;
	float_t beta_lp_pu = (pUserParams->offsetPole_rps/(float_t)pUserParams->ctrlFreq_Hz);//! \Mod By Dl.K
 8005a42:	683b      	ldr	r3, [r7, #0]
 8005a44:	ed93 7a06 	vldr	s14, [r3, #24]
 8005a48:	683b      	ldr	r3, [r7, #0]
 8005a4a:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 8005a4e:	ee07 3a90 	vmov	s15, r3
 8005a52:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005a56:	eec7 7a27 	vdiv.f32	s15, s14, s15
 8005a5a:	edc7 7a04 	vstr	s15, [r7, #16]

  HAL_setNumCurrentSensors(handle,pUserParams->numCurrentSensors);
 8005a5e:	683b      	ldr	r3, [r7, #0]
 8005a60:	7d9b      	ldrb	r3, [r3, #22]
 8005a62:	6878      	ldr	r0, [r7, #4]
 8005a64:	4619      	mov	r1, r3
 8005a66:	f7ff fee7 	bl	8005838 <HAL_setNumCurrentSensors>
  HAL_setNumVoltageSensors(handle,pUserParams->numVoltageSensors);
 8005a6a:	683b      	ldr	r3, [r7, #0]
 8005a6c:	7ddb      	ldrb	r3, [r3, #23]
 8005a6e:	6878      	ldr	r0, [r7, #4]
 8005a70:	4619      	mov	r1, r3
 8005a72:	f7ff fef3 	bl	800585c <HAL_setNumVoltageSensors>


  for(cnt=0;cnt<HAL_getNumCurrentSensors(handle);cnt++)
 8005a76:	2300      	movs	r3, #0
 8005a78:	75fb      	strb	r3, [r7, #23]
 8005a7a:	e01a      	b.n	8005ab2 <HAL_setParams+0x7a>
	{
	  HAL_setOffsetBeta_lp_pu(handle,HAL_SensorType_Current,cnt,beta_lp_pu);
 8005a7c:	7dfb      	ldrb	r3, [r7, #23]
 8005a7e:	6878      	ldr	r0, [r7, #4]
 8005a80:	2100      	movs	r1, #0
 8005a82:	461a      	mov	r2, r3
 8005a84:	ed97 0a04 	vldr	s0, [r7, #16]
 8005a88:	f7ff fefa 	bl	8005880 <HAL_setOffsetBeta_lp_pu>
	  HAL_setOffsetInitCond(handle,HAL_SensorType_Current,cnt,(0.0f));
 8005a8c:	7dfb      	ldrb	r3, [r7, #23]
 8005a8e:	6878      	ldr	r0, [r7, #4]
 8005a90:	2100      	movs	r1, #0
 8005a92:	461a      	mov	r2, r3
 8005a94:	ed9f 0a52 	vldr	s0, [pc, #328]	; 8005be0 <HAL_setParams+0x1a8>
 8005a98:	f7ff ff1e 	bl	80058d8 <HAL_setOffsetInitCond>
	  HAL_setOffsetValue(handle,HAL_SensorType_Current,cnt,(0.0f));
 8005a9c:	7dfb      	ldrb	r3, [r7, #23]
 8005a9e:	6878      	ldr	r0, [r7, #4]
 8005aa0:	2100      	movs	r1, #0
 8005aa2:	461a      	mov	r2, r3
 8005aa4:	ed9f 0a4e 	vldr	s0, [pc, #312]	; 8005be0 <HAL_setParams+0x1a8>
 8005aa8:	f7ff ff42 	bl	8005930 <HAL_setOffsetValue>

  HAL_setNumCurrentSensors(handle,pUserParams->numCurrentSensors);
  HAL_setNumVoltageSensors(handle,pUserParams->numVoltageSensors);


  for(cnt=0;cnt<HAL_getNumCurrentSensors(handle);cnt++)
 8005aac:	7dfb      	ldrb	r3, [r7, #23]
 8005aae:	3301      	adds	r3, #1
 8005ab0:	75fb      	strb	r3, [r7, #23]
 8005ab2:	6878      	ldr	r0, [r7, #4]
 8005ab4:	f7ff fe66 	bl	8005784 <HAL_getNumCurrentSensors>
 8005ab8:	4603      	mov	r3, r0
 8005aba:	461a      	mov	r2, r3
 8005abc:	7dfb      	ldrb	r3, [r7, #23]
 8005abe:	4293      	cmp	r3, r2
 8005ac0:	d3dc      	bcc.n	8005a7c <HAL_setParams+0x44>
	  HAL_setOffsetInitCond(handle,HAL_SensorType_Current,cnt,(0.0f));
	  HAL_setOffsetValue(handle,HAL_SensorType_Current,cnt,(0.0f));
	}//! \Mod By Dl.K


  for(cnt=0;cnt<HAL_getNumVoltageSensors(handle);cnt++)
 8005ac2:	2300      	movs	r3, #0
 8005ac4:	75fb      	strb	r3, [r7, #23]
 8005ac6:	e01a      	b.n	8005afe <HAL_setParams+0xc6>
    {
      HAL_setOffsetBeta_lp_pu(handle,HAL_SensorType_Voltage,cnt,beta_lp_pu);
 8005ac8:	7dfb      	ldrb	r3, [r7, #23]
 8005aca:	6878      	ldr	r0, [r7, #4]
 8005acc:	2101      	movs	r1, #1
 8005ace:	461a      	mov	r2, r3
 8005ad0:	ed97 0a04 	vldr	s0, [r7, #16]
 8005ad4:	f7ff fed4 	bl	8005880 <HAL_setOffsetBeta_lp_pu>
      HAL_setOffsetInitCond(handle,HAL_SensorType_Voltage,cnt,(0.0f));
 8005ad8:	7dfb      	ldrb	r3, [r7, #23]
 8005ada:	6878      	ldr	r0, [r7, #4]
 8005adc:	2101      	movs	r1, #1
 8005ade:	461a      	mov	r2, r3
 8005ae0:	ed9f 0a3f 	vldr	s0, [pc, #252]	; 8005be0 <HAL_setParams+0x1a8>
 8005ae4:	f7ff fef8 	bl	80058d8 <HAL_setOffsetInitCond>
      HAL_setOffsetValue(handle,HAL_SensorType_Voltage,cnt,(0.0f));
 8005ae8:	7dfb      	ldrb	r3, [r7, #23]
 8005aea:	6878      	ldr	r0, [r7, #4]
 8005aec:	2101      	movs	r1, #1
 8005aee:	461a      	mov	r2, r3
 8005af0:	ed9f 0a3b 	vldr	s0, [pc, #236]	; 8005be0 <HAL_setParams+0x1a8>
 8005af4:	f7ff ff1c 	bl	8005930 <HAL_setOffsetValue>
	  HAL_setOffsetInitCond(handle,HAL_SensorType_Current,cnt,(0.0f));
	  HAL_setOffsetValue(handle,HAL_SensorType_Current,cnt,(0.0f));
	}//! \Mod By Dl.K


  for(cnt=0;cnt<HAL_getNumVoltageSensors(handle);cnt++)
 8005af8:	7dfb      	ldrb	r3, [r7, #23]
 8005afa:	3301      	adds	r3, #1
 8005afc:	75fb      	strb	r3, [r7, #23]
 8005afe:	6878      	ldr	r0, [r7, #4]
 8005b00:	f7ff fe50 	bl	80057a4 <HAL_getNumVoltageSensors>
 8005b04:	4603      	mov	r3, r0
 8005b06:	461a      	mov	r2, r3
 8005b08:	7dfb      	ldrb	r3, [r7, #23]
 8005b0a:	4293      	cmp	r3, r2
 8005b0c:	d3dc      	bcc.n	8005ac8 <HAL_setParams+0x90>
      HAL_setOffsetBeta_lp_pu(handle,HAL_SensorType_Voltage,cnt,beta_lp_pu);
      HAL_setOffsetInitCond(handle,HAL_SensorType_Voltage,cnt,(0.0f));
      HAL_setOffsetValue(handle,HAL_SensorType_Voltage,cnt,(0.0f));
    }//! \Mod By Dl.K

	  HAL_setBias(handle,HAL_SensorType_Current,0,((I_A_offset)*(pUserParams->current_sf)));
 8005b0e:	683b      	ldr	r3, [r7, #0]
 8005b10:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 8005b14:	ed9f 7a33 	vldr	s14, [pc, #204]	; 8005be4 <HAL_setParams+0x1ac>
 8005b18:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005b1c:	6878      	ldr	r0, [r7, #4]
 8005b1e:	2100      	movs	r1, #0
 8005b20:	2200      	movs	r2, #0
 8005b22:	eeb0 0a67 	vmov.f32	s0, s15
 8005b26:	f7ff fe4d 	bl	80057c4 <HAL_setBias>
	  HAL_setBias(handle,HAL_SensorType_Current,1,((I_B_offset)*(pUserParams->current_sf)));
 8005b2a:	683b      	ldr	r3, [r7, #0]
 8005b2c:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 8005b30:	ed9f 7a2c 	vldr	s14, [pc, #176]	; 8005be4 <HAL_setParams+0x1ac>
 8005b34:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005b38:	6878      	ldr	r0, [r7, #4]
 8005b3a:	2100      	movs	r1, #0
 8005b3c:	2201      	movs	r2, #1
 8005b3e:	eeb0 0a67 	vmov.f32	s0, s15
 8005b42:	f7ff fe3f 	bl	80057c4 <HAL_setBias>
	  HAL_setBias(handle,HAL_SensorType_Current,2,((I_C_offset)*(pUserParams->current_sf)));
 8005b46:	683b      	ldr	r3, [r7, #0]
 8005b48:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 8005b4c:	ed9f 7a25 	vldr	s14, [pc, #148]	; 8005be4 <HAL_setParams+0x1ac>
 8005b50:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005b54:	6878      	ldr	r0, [r7, #4]
 8005b56:	2100      	movs	r1, #0
 8005b58:	2202      	movs	r2, #2
 8005b5a:	eeb0 0a67 	vmov.f32	s0, s15
 8005b5e:	f7ff fe31 	bl	80057c4 <HAL_setBias>


   float_t current_sf = (pUserParams->current_sf);//! \Mod By Dl.K
 8005b62:	683b      	ldr	r3, [r7, #0]
 8005b64:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005b66:	60fb      	str	r3, [r7, #12]
  HAL_setCurrentScaleFactor(handle,current_sf);
 8005b68:	6878      	ldr	r0, [r7, #4]
 8005b6a:	ed97 0a03 	vldr	s0, [r7, #12]
 8005b6e:	f7ff fe51 	bl	8005814 <HAL_setCurrentScaleFactor>
 

	  HAL_setBias(handle,HAL_SensorType_Voltage,0,((V_A_offset)*(pUserParams->voltage_sf)));
 8005b72:	683b      	ldr	r3, [r7, #0]
 8005b74:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 8005b78:	ed9f 7a1b 	vldr	s14, [pc, #108]	; 8005be8 <HAL_setParams+0x1b0>
 8005b7c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005b80:	6878      	ldr	r0, [r7, #4]
 8005b82:	2101      	movs	r1, #1
 8005b84:	2200      	movs	r2, #0
 8005b86:	eeb0 0a67 	vmov.f32	s0, s15
 8005b8a:	f7ff fe1b 	bl	80057c4 <HAL_setBias>
	  HAL_setBias(handle,HAL_SensorType_Voltage,1,((V_B_offset)*(pUserParams->voltage_sf)));
 8005b8e:	683b      	ldr	r3, [r7, #0]
 8005b90:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 8005b94:	ed9f 7a14 	vldr	s14, [pc, #80]	; 8005be8 <HAL_setParams+0x1b0>
 8005b98:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005b9c:	6878      	ldr	r0, [r7, #4]
 8005b9e:	2101      	movs	r1, #1
 8005ba0:	2201      	movs	r2, #1
 8005ba2:	eeb0 0a67 	vmov.f32	s0, s15
 8005ba6:	f7ff fe0d 	bl	80057c4 <HAL_setBias>
	  HAL_setBias(handle,HAL_SensorType_Voltage,2,((V_C_offset)*(pUserParams->voltage_sf)));
 8005baa:	683b      	ldr	r3, [r7, #0]
 8005bac:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 8005bb0:	ed9f 7a0d 	vldr	s14, [pc, #52]	; 8005be8 <HAL_setParams+0x1b0>
 8005bb4:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005bb8:	6878      	ldr	r0, [r7, #4]
 8005bba:	2101      	movs	r1, #1
 8005bbc:	2202      	movs	r2, #2
 8005bbe:	eeb0 0a67 	vmov.f32	s0, s15
 8005bc2:	f7ff fdff 	bl	80057c4 <HAL_setBias>


	float_t voltage_sf = (pUserParams->voltage_sf);//! \Mod By Dl.K
 8005bc6:	683b      	ldr	r3, [r7, #0]
 8005bc8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8005bca:	60bb      	str	r3, [r7, #8]
  HAL_setVoltageScaleFactor(handle,voltage_sf);
 8005bcc:	6878      	ldr	r0, [r7, #4]
 8005bce:	ed97 0a02 	vldr	s0, [r7, #8]
 8005bd2:	f7ff fed9 	bl	8005988 <HAL_setVoltageScaleFactor>
 
 return;
 8005bd6:	bf00      	nop
} // end of HAL_setParams() function
 8005bd8:	3718      	adds	r7, #24
 8005bda:	46bd      	mov	sp, r7
 8005bdc:	bd80      	pop	{r7, pc}
 8005bde:	bf00      	nop
 8005be0:	00000000 	.word	0x00000000
 8005be4:	3f41f06f 	.word	0x3f41f06f
 8005be8:	3f14f206 	.word	0x3f14f206

08005bec <IPARK_init>:

// **************************************************************************
// the functions

IPARK_Handle IPARK_init(void *pMemory,const size_t numBytes)
{
 8005bec:	b480      	push	{r7}
 8005bee:	b085      	sub	sp, #20
 8005bf0:	af00      	add	r7, sp, #0
 8005bf2:	6078      	str	r0, [r7, #4]
 8005bf4:	6039      	str	r1, [r7, #0]
  IPARK_Handle handle;

  if(numBytes < sizeof(IPARK_Obj))
 8005bf6:	683b      	ldr	r3, [r7, #0]
 8005bf8:	2b07      	cmp	r3, #7
 8005bfa:	d801      	bhi.n	8005c00 <IPARK_init+0x14>
    return((IPARK_Handle)NULL);
 8005bfc:	2300      	movs	r3, #0
 8005bfe:	e002      	b.n	8005c06 <IPARK_init+0x1a>

  // assign the handle
  handle = (IPARK_Handle)pMemory;
 8005c00:	687b      	ldr	r3, [r7, #4]
 8005c02:	60fb      	str	r3, [r7, #12]

  return(handle);
 8005c04:	68fb      	ldr	r3, [r7, #12]
} // end of IPARK_init() function
 8005c06:	4618      	mov	r0, r3
 8005c08:	3714      	adds	r7, #20
 8005c0a:	46bd      	mov	sp, r7
 8005c0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005c10:	4770      	bx	lr
 8005c12:	bf00      	nop

08005c14 <OFFSET_init>:
  return(b0);
} // end of OFFSET_getBeta() function


OFFSET_Handle OFFSET_init(void *pMemory,const size_t numBytes)
{
 8005c14:	b580      	push	{r7, lr}
 8005c16:	b084      	sub	sp, #16
 8005c18:	af00      	add	r7, sp, #0
 8005c1a:	6078      	str	r0, [r7, #4]
 8005c1c:	6039      	str	r1, [r7, #0]
  OFFSET_Handle handle;
  OFFSET_Obj *obj;

  if(numBytes < sizeof(OFFSET_Obj))
 8005c1e:	683b      	ldr	r3, [r7, #0]
 8005c20:	2b1f      	cmp	r3, #31
 8005c22:	d801      	bhi.n	8005c28 <OFFSET_init+0x14>
    return((OFFSET_Handle)NULL);
 8005c24:	2300      	movs	r3, #0
 8005c26:	e00d      	b.n	8005c44 <OFFSET_init+0x30>

  // assign the handle
  handle = (OFFSET_Handle)pMemory;
 8005c28:	687b      	ldr	r3, [r7, #4]
 8005c2a:	60fb      	str	r3, [r7, #12]
  obj = (OFFSET_Obj *)handle;
 8005c2c:	68fb      	ldr	r3, [r7, #12]
 8005c2e:	60bb      	str	r3, [r7, #8]

  obj->filterHandle = FILTER_FO_init(&(obj->filter),sizeof(obj->filter));
 8005c30:	68bb      	ldr	r3, [r7, #8]
 8005c32:	3308      	adds	r3, #8
 8005c34:	4618      	mov	r0, r3
 8005c36:	2114      	movs	r1, #20
 8005c38:	f7ff fd52 	bl	80056e0 <FILTER_FO_init>
 8005c3c:	4602      	mov	r2, r0
 8005c3e:	68bb      	ldr	r3, [r7, #8]
 8005c40:	61da      	str	r2, [r3, #28]

  return(handle);
 8005c42:	68fb      	ldr	r3, [r7, #12]
} // end of OFFSET_init() function
 8005c44:	4618      	mov	r0, r3
 8005c46:	3710      	adds	r7, #16
 8005c48:	46bd      	mov	sp, r7
 8005c4a:	bd80      	pop	{r7, pc}

08005c4c <OFFSET_setBeta>:


void OFFSET_setBeta(OFFSET_Handle handle,const float_t beta)
{
 8005c4c:	b580      	push	{r7, lr}
 8005c4e:	b086      	sub	sp, #24
 8005c50:	af00      	add	r7, sp, #0
 8005c52:	6078      	str	r0, [r7, #4]
 8005c54:	ed87 0a00 	vstr	s0, [r7]
  OFFSET_Obj *obj = (OFFSET_Obj *)handle;
 8005c58:	687b      	ldr	r3, [r7, #4]
 8005c5a:	617b      	str	r3, [r7, #20]
  float_t a1 = (beta - (1.0f));
 8005c5c:	edd7 7a00 	vldr	s15, [r7]
 8005c60:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8005c64:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8005c68:	edc7 7a04 	vstr	s15, [r7, #16]
  float_t b0 = beta;
 8005c6c:	683b      	ldr	r3, [r7, #0]
 8005c6e:	60fb      	str	r3, [r7, #12]
  float_t b1 = 0;
 8005c70:	f04f 0300 	mov.w	r3, #0
 8005c74:	60bb      	str	r3, [r7, #8]

  FILTER_FO_setDenCoeffs(obj->filterHandle,a1);
 8005c76:	697b      	ldr	r3, [r7, #20]
 8005c78:	69db      	ldr	r3, [r3, #28]
 8005c7a:	4618      	mov	r0, r3
 8005c7c:	ed97 0a04 	vldr	s0, [r7, #16]
 8005c80:	f7ff fd42 	bl	8005708 <FILTER_FO_setDenCoeffs>
  FILTER_FO_setNumCoeffs(obj->filterHandle,b0,b1);
 8005c84:	697b      	ldr	r3, [r7, #20]
 8005c86:	69db      	ldr	r3, [r3, #28]
 8005c88:	4618      	mov	r0, r3
 8005c8a:	ed97 0a03 	vldr	s0, [r7, #12]
 8005c8e:	edd7 0a02 	vldr	s1, [r7, #8]
 8005c92:	f7ff fd61 	bl	8005758 <FILTER_FO_setNumCoeffs>

  return;
 8005c96:	bf00      	nop
} // end of OFFSET_setBeta() function
 8005c98:	3718      	adds	r7, #24
 8005c9a:	46bd      	mov	sp, r7
 8005c9c:	bd80      	pop	{r7, pc}
 8005c9e:	bf00      	nop

08005ca0 <OFFSET_setInitCond>:


void OFFSET_setInitCond(OFFSET_Handle handle,const float_t initCond)
{
 8005ca0:	b580      	push	{r7, lr}
 8005ca2:	b084      	sub	sp, #16
 8005ca4:	af00      	add	r7, sp, #0
 8005ca6:	6078      	str	r0, [r7, #4]
 8005ca8:	ed87 0a00 	vstr	s0, [r7]
  OFFSET_Obj *obj = (OFFSET_Obj *)handle;
 8005cac:	687b      	ldr	r3, [r7, #4]
 8005cae:	60fb      	str	r3, [r7, #12]

  FILTER_FO_setInitialConditions(obj->filterHandle,initCond,initCond);
 8005cb0:	68fb      	ldr	r3, [r7, #12]
 8005cb2:	69db      	ldr	r3, [r3, #28]
 8005cb4:	4618      	mov	r0, r3
 8005cb6:	ed97 0a00 	vldr	s0, [r7]
 8005cba:	edd7 0a00 	vldr	s1, [r7]
 8005cbe:	f7ff fd35 	bl	800572c <FILTER_FO_setInitialConditions>
  obj->value = initCond;
 8005cc2:	68fb      	ldr	r3, [r7, #12]
 8005cc4:	683a      	ldr	r2, [r7, #0]
 8005cc6:	601a      	str	r2, [r3, #0]

  return;
 8005cc8:	bf00      	nop
} // end of OFFSET_setInitCond() function
 8005cca:	3710      	adds	r7, #16
 8005ccc:	46bd      	mov	sp, r7
 8005cce:	bd80      	pop	{r7, pc}

08005cd0 <OFFSET_setOffset>:


void OFFSET_setOffset(OFFSET_Handle handle, float_t offsetValue)
{
 8005cd0:	b480      	push	{r7}
 8005cd2:	b085      	sub	sp, #20
 8005cd4:	af00      	add	r7, sp, #0
 8005cd6:	6078      	str	r0, [r7, #4]
 8005cd8:	ed87 0a00 	vstr	s0, [r7]
  OFFSET_Obj *obj = (OFFSET_Obj *)handle;
 8005cdc:	687b      	ldr	r3, [r7, #4]
 8005cde:	60fb      	str	r3, [r7, #12]

  obj->value = offsetValue;
 8005ce0:	68fb      	ldr	r3, [r7, #12]
 8005ce2:	683a      	ldr	r2, [r7, #0]
 8005ce4:	601a      	str	r2, [r3, #0]

  return;
 8005ce6:	bf00      	nop
} // end of OFFSET_setOffset() function
 8005ce8:	3714      	adds	r7, #20
 8005cea:	46bd      	mov	sp, r7
 8005cec:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005cf0:	4770      	bx	lr
 8005cf2:	bf00      	nop

08005cf4 <PARK_init>:

// **************************************************************************
// the functions

PARK_Handle PARK_init(void *pMemory,const size_t numBytes)
{
 8005cf4:	b480      	push	{r7}
 8005cf6:	b085      	sub	sp, #20
 8005cf8:	af00      	add	r7, sp, #0
 8005cfa:	6078      	str	r0, [r7, #4]
 8005cfc:	6039      	str	r1, [r7, #0]
  PARK_Handle handle;

  if(numBytes < sizeof(PARK_Obj))
 8005cfe:	683b      	ldr	r3, [r7, #0]
 8005d00:	2b07      	cmp	r3, #7
 8005d02:	d801      	bhi.n	8005d08 <PARK_init+0x14>
    return((PARK_Handle)NULL);
 8005d04:	2300      	movs	r3, #0
 8005d06:	e002      	b.n	8005d0e <PARK_init+0x1a>

  // assign the handle
  handle = (PARK_Handle)pMemory;
 8005d08:	687b      	ldr	r3, [r7, #4]
 8005d0a:	60fb      	str	r3, [r7, #12]

  return(handle);
 8005d0c:	68fb      	ldr	r3, [r7, #12]
} // end of PARK_init() function
 8005d0e:	4618      	mov	r0, r3
 8005d10:	3714      	adds	r7, #20
 8005d12:	46bd      	mov	sp, r7
 8005d14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005d18:	4770      	bx	lr
 8005d1a:	bf00      	nop

08005d1c <PID_setFbackValue>:

//! \brief     Sets the feedback value in the PID controller
//! \param[in] handle      The PID controller handle
//! \param[in] fbackValue  The feedback value
static inline void PID_setFbackValue(PID_Handle handle,const float_t fbackValue)//! \Mod By Dl.K
{
 8005d1c:	b480      	push	{r7}
 8005d1e:	b085      	sub	sp, #20
 8005d20:	af00      	add	r7, sp, #0
 8005d22:	6078      	str	r0, [r7, #4]
 8005d24:	ed87 0a00 	vstr	s0, [r7]
  PID_Obj *obj = (PID_Obj *)handle;
 8005d28:	687b      	ldr	r3, [r7, #4]
 8005d2a:	60fb      	str	r3, [r7, #12]

  obj->fbackValue = fbackValue;
 8005d2c:	68fb      	ldr	r3, [r7, #12]
 8005d2e:	683a      	ldr	r2, [r7, #0]
 8005d30:	615a      	str	r2, [r3, #20]

  return;
 8005d32:	bf00      	nop
} // end of PID_setFbackValue() function
 8005d34:	3714      	adds	r7, #20
 8005d36:	46bd      	mov	sp, r7
 8005d38:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005d3c:	4770      	bx	lr
 8005d3e:	bf00      	nop

08005d40 <PID_setRefValue>:

//! \brief     Sets the reference value in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] refValue   The reference value
static inline void PID_setRefValue(PID_Handle handle,const float_t refValue)//! \Mod By Dl.K
{
 8005d40:	b480      	push	{r7}
 8005d42:	b085      	sub	sp, #20
 8005d44:	af00      	add	r7, sp, #0
 8005d46:	6078      	str	r0, [r7, #4]
 8005d48:	ed87 0a00 	vstr	s0, [r7]
  PID_Obj *obj = (PID_Obj *)handle;
 8005d4c:	687b      	ldr	r3, [r7, #4]
 8005d4e:	60fb      	str	r3, [r7, #12]

  obj->refValue = refValue;
 8005d50:	68fb      	ldr	r3, [r7, #12]
 8005d52:	683a      	ldr	r2, [r7, #0]
 8005d54:	611a      	str	r2, [r3, #16]

  return;
 8005d56:	bf00      	nop
} // end of PID_setRefValue() function
 8005d58:	3714      	adds	r7, #20
 8005d5a:	46bd      	mov	sp, r7
 8005d5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005d60:	4770      	bx	lr
 8005d62:	bf00      	nop

08005d64 <PID_setUi>:

//! \brief     Sets the integrator start value in the PID controller
//! \param[in] handle  The PID controller handle
//! \param[in] Ui         The integral start value for the PID controller
static inline void PID_setUi(PID_Handle handle,const float_t Ui)//! \Mod By Dl.K
{
 8005d64:	b480      	push	{r7}
 8005d66:	b085      	sub	sp, #20
 8005d68:	af00      	add	r7, sp, #0
 8005d6a:	6078      	str	r0, [r7, #4]
 8005d6c:	ed87 0a00 	vstr	s0, [r7]
  PID_Obj *obj = (PID_Obj *)handle;
 8005d70:	687b      	ldr	r3, [r7, #4]
 8005d72:	60fb      	str	r3, [r7, #12]

  obj->Ui = Ui;
 8005d74:	68fb      	ldr	r3, [r7, #12]
 8005d76:	683a      	ldr	r2, [r7, #0]
 8005d78:	60da      	str	r2, [r3, #12]

  return;
 8005d7a:	bf00      	nop
} // end of PID_setUi() function
 8005d7c:	3714      	adds	r7, #20
 8005d7e:	46bd      	mov	sp, r7
 8005d80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005d84:	4770      	bx	lr
 8005d86:	bf00      	nop

08005d88 <PID_init>:

// **************************************************************************
// the functions

PID_Handle PID_init(void *pMemory,const size_t numBytes)
{
 8005d88:	b580      	push	{r7, lr}
 8005d8a:	b084      	sub	sp, #16
 8005d8c:	af00      	add	r7, sp, #0
 8005d8e:	6078      	str	r0, [r7, #4]
 8005d90:	6039      	str	r1, [r7, #0]
  PID_Handle handle;


  if(numBytes < sizeof(PID_Obj))
 8005d92:	683b      	ldr	r3, [r7, #0]
 8005d94:	2b1f      	cmp	r3, #31
 8005d96:	d801      	bhi.n	8005d9c <PID_init+0x14>
    return((PID_Handle)NULL);
 8005d98:	2300      	movs	r3, #0
 8005d9a:	e011      	b.n	8005dc0 <PID_init+0x38>

  // assign the handle
  handle = (PID_Handle)pMemory;
 8005d9c:	687b      	ldr	r3, [r7, #4]
 8005d9e:	60fb      	str	r3, [r7, #12]

  // set some defaults
  PID_setUi(handle,(0.0f));
 8005da0:	68f8      	ldr	r0, [r7, #12]
 8005da2:	ed9f 0a09 	vldr	s0, [pc, #36]	; 8005dc8 <PID_init+0x40>
 8005da6:	f7ff ffdd 	bl	8005d64 <PID_setUi>
  PID_setRefValue(handle,(0.0f));
 8005daa:	68f8      	ldr	r0, [r7, #12]
 8005dac:	ed9f 0a06 	vldr	s0, [pc, #24]	; 8005dc8 <PID_init+0x40>
 8005db0:	f7ff ffc6 	bl	8005d40 <PID_setRefValue>
  PID_setFbackValue(handle,(0.0f));
 8005db4:	68f8      	ldr	r0, [r7, #12]
 8005db6:	ed9f 0a04 	vldr	s0, [pc, #16]	; 8005dc8 <PID_init+0x40>
 8005dba:	f7ff ffaf 	bl	8005d1c <PID_setFbackValue>

  return(handle);
 8005dbe:	68fb      	ldr	r3, [r7, #12]
} // end of PID_init() function
 8005dc0:	4618      	mov	r0, r3
 8005dc2:	3710      	adds	r7, #16
 8005dc4:	46bd      	mov	sp, r7
 8005dc6:	bd80      	pop	{r7, pc}
 8005dc8:	00000000 	.word	0x00000000

08005dcc <RAMPGEN_Init>:
-------------------------------------------------------------------------------------*/

#include "modules/rampgen/rampgen.h"

RAMPGEN_Handle RAMPGEN_Init(void *pMemory, const size_t numBytes)//! \Mod By Dl.K
{
 8005dcc:	b480      	push	{r7}
 8005dce:	b085      	sub	sp, #20
 8005dd0:	af00      	add	r7, sp, #0
 8005dd2:	6078      	str	r0, [r7, #4]
 8005dd4:	6039      	str	r1, [r7, #0]
	RAMPGEN_Handle handle;

	if (numBytes < sizeof(RAMPGEN_Obj))
 8005dd6:	683b      	ldr	r3, [r7, #0]
 8005dd8:	2b17      	cmp	r3, #23
 8005dda:	d801      	bhi.n	8005de0 <RAMPGEN_Init+0x14>
		return((RAMPGEN_Handle)NULL);
 8005ddc:	2300      	movs	r3, #0
 8005dde:	e01a      	b.n	8005e16 <RAMPGEN_Init+0x4a>

	// assign the handle
	handle = (RAMPGEN_Handle)pMemory;
 8005de0:	687b      	ldr	r3, [r7, #4]
 8005de2:	60fb      	str	r3, [r7, #12]

	handle->Freq = (0.0);
 8005de4:	68fb      	ldr	r3, [r7, #12]
 8005de6:	f04f 0200 	mov.w	r2, #0
 8005dea:	601a      	str	r2, [r3, #0]
	handle->StepAngleMax = (0.0);
 8005dec:	68fb      	ldr	r3, [r7, #12]
 8005dee:	f04f 0200 	mov.w	r2, #0
 8005df2:	605a      	str	r2, [r3, #4]
	handle->Angle = (0.0);
 8005df4:	68fb      	ldr	r3, [r7, #12]
 8005df6:	f04f 0200 	mov.w	r2, #0
 8005dfa:	609a      	str	r2, [r3, #8]
	handle->Gain = (1.0);
 8005dfc:	68fb      	ldr	r3, [r7, #12]
 8005dfe:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8005e02:	60da      	str	r2, [r3, #12]
	handle->Out = (0.0);
 8005e04:	68fb      	ldr	r3, [r7, #12]
 8005e06:	f04f 0200 	mov.w	r2, #0
 8005e0a:	611a      	str	r2, [r3, #16]
	handle->Offset = (0.75);
 8005e0c:	68fb      	ldr	r3, [r7, #12]
 8005e0e:	f04f 527d 	mov.w	r2, #1061158912	; 0x3f400000
 8005e12:	615a      	str	r2, [r3, #20]

	return(handle);
 8005e14:	68fb      	ldr	r3, [r7, #12]
}
 8005e16:	4618      	mov	r0, r3
 8005e18:	3714      	adds	r7, #20
 8005e1a:	46bd      	mov	sp, r7
 8005e1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005e20:	4770      	bx	lr
 8005e22:	bf00      	nop

08005e24 <RMP_CNTL_Init>:
-------------------------------------------------------------------------------------*/

#include "modules/rmp_cntl/rmp_cntl.h"

RMPCNTL_Handle RMP_CNTL_Init(void *pMemory, const size_t numBytes)//! \Mod By Dl.K
{
 8005e24:	b480      	push	{r7}
 8005e26:	b085      	sub	sp, #20
 8005e28:	af00      	add	r7, sp, #0
 8005e2a:	6078      	str	r0, [r7, #4]
 8005e2c:	6039      	str	r1, [r7, #0]
	RMPCNTL_Handle handle;

	if (numBytes < sizeof(RMPCNTL_Obj))
 8005e2e:	683b      	ldr	r3, [r7, #0]
 8005e30:	2b1b      	cmp	r3, #27
 8005e32:	d801      	bhi.n	8005e38 <RMP_CNTL_Init+0x14>
		return((RMPCNTL_Handle)NULL);
 8005e34:	2300      	movs	r3, #0
 8005e36:	e01a      	b.n	8005e6e <RMP_CNTL_Init+0x4a>

	// assign the handle
	handle = (RMPCNTL_Handle)pMemory;
 8005e38:	687b      	ldr	r3, [r7, #4]
 8005e3a:	60fb      	str	r3, [r7, #12]

	handle->TargetValue = (0.0f);
 8005e3c:	68fb      	ldr	r3, [r7, #12]
 8005e3e:	f04f 0200 	mov.w	r2, #0
 8005e42:	601a      	str	r2, [r3, #0]
	handle->RampDelayMax = 150;
 8005e44:	68fb      	ldr	r3, [r7, #12]
 8005e46:	2296      	movs	r2, #150	; 0x96
 8005e48:	605a      	str	r2, [r3, #4]
	handle->RampLowLimit = (-1.0f);
 8005e4a:	68fb      	ldr	r3, [r7, #12]
 8005e4c:	4a0b      	ldr	r2, [pc, #44]	; (8005e7c <RMP_CNTL_Init+0x58>)
 8005e4e:	609a      	str	r2, [r3, #8]
	handle->RampHighLimit = (1.0f);
 8005e50:	68fb      	ldr	r3, [r7, #12]
 8005e52:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8005e56:	60da      	str	r2, [r3, #12]
	handle->RampDelayCount = 0;
 8005e58:	68fb      	ldr	r3, [r7, #12]
 8005e5a:	2200      	movs	r2, #0
 8005e5c:	611a      	str	r2, [r3, #16]
	handle->SetpointValue = (0.0f);
 8005e5e:	68fb      	ldr	r3, [r7, #12]
 8005e60:	f04f 0200 	mov.w	r2, #0
 8005e64:	615a      	str	r2, [r3, #20]
	handle->EqualFlag = 0;
 8005e66:	68fb      	ldr	r3, [r7, #12]
 8005e68:	2200      	movs	r2, #0
 8005e6a:	619a      	str	r2, [r3, #24]

	return(handle);
 8005e6c:	68fb      	ldr	r3, [r7, #12]
}
 8005e6e:	4618      	mov	r0, r3
 8005e70:	3714      	adds	r7, #20
 8005e72:	46bd      	mov	sp, r7
 8005e74:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005e78:	4770      	bx	lr
 8005e7a:	bf00      	nop
 8005e7c:	bf800000 	.word	0xbf800000

08005e80 <SVGEN_init>:

// **************************************************************************
// the functions

SVGEN_Handle SVGEN_init(void *pMemory,const size_t numBytes)
{
 8005e80:	b480      	push	{r7}
 8005e82:	b085      	sub	sp, #20
 8005e84:	af00      	add	r7, sp, #0
 8005e86:	6078      	str	r0, [r7, #4]
 8005e88:	6039      	str	r1, [r7, #0]
  SVGEN_Handle svgenHandle;


  if(numBytes < sizeof(SVGEN_Obj))
 8005e8a:	683b      	ldr	r3, [r7, #0]
 8005e8c:	2b03      	cmp	r3, #3
 8005e8e:	d801      	bhi.n	8005e94 <SVGEN_init+0x14>
    return((SVGEN_Handle)NULL);
 8005e90:	2300      	movs	r3, #0
 8005e92:	e002      	b.n	8005e9a <SVGEN_init+0x1a>

  // assign the handle
  svgenHandle = (SVGEN_Handle)pMemory;
 8005e94:	687b      	ldr	r3, [r7, #4]
 8005e96:	60fb      	str	r3, [r7, #12]

  return(svgenHandle);
 8005e98:	68fb      	ldr	r3, [r7, #12]
} // end of SVGEN_init() function
 8005e9a:	4618      	mov	r0, r3
 8005e9c:	3714      	adds	r7, #20
 8005e9e:	46bd      	mov	sp, r7
 8005ea0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005ea4:	4770      	bx	lr
 8005ea6:	bf00      	nop

08005ea8 <TRAJ_init>:

// **************************************************************************
// the functions

TRAJ_Handle TRAJ_init(void *pMemory,const size_t numBytes)
{
 8005ea8:	b480      	push	{r7}
 8005eaa:	b085      	sub	sp, #20
 8005eac:	af00      	add	r7, sp, #0
 8005eae:	6078      	str	r0, [r7, #4]
 8005eb0:	6039      	str	r1, [r7, #0]
  TRAJ_Handle handle;


  if(numBytes < sizeof(TRAJ_Obj))
 8005eb2:	683b      	ldr	r3, [r7, #0]
 8005eb4:	2b13      	cmp	r3, #19
 8005eb6:	d801      	bhi.n	8005ebc <TRAJ_init+0x14>
    return((TRAJ_Handle)NULL);
 8005eb8:	2300      	movs	r3, #0
 8005eba:	e002      	b.n	8005ec2 <TRAJ_init+0x1a>

  // assign the handle
  handle = (TRAJ_Handle)pMemory;
 8005ebc:	687b      	ldr	r3, [r7, #4]
 8005ebe:	60fb      	str	r3, [r7, #12]

  return(handle);
 8005ec0:	68fb      	ldr	r3, [r7, #12]
} // end of TRAJ_init() function
 8005ec2:	4618      	mov	r0, r3
 8005ec4:	3714      	adds	r7, #20
 8005ec6:	46bd      	mov	sp, r7
 8005ec8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005ecc:	4770      	bx	lr
 8005ece:	bf00      	nop

08005ed0 <USER_setParams>:
// **************************************************************************
// the functions


void USER_setParams(USER_Params *pUserParams)
{
 8005ed0:	b480      	push	{r7}
 8005ed2:	b083      	sub	sp, #12
 8005ed4:	af00      	add	r7, sp, #0
 8005ed6:	6078      	str	r0, [r7, #4]
  pUserParams->iqFullScaleCurrent_A = USER_IQ_FULL_SCALE_CURRENT_A;
 8005ed8:	687b      	ldr	r3, [r7, #4]
 8005eda:	4aae      	ldr	r2, [pc, #696]	; (8006194 <USER_setParams+0x2c4>)
 8005edc:	601a      	str	r2, [r3, #0]
  pUserParams->iqFullScaleVoltage_V = USER_IQ_FULL_SCALE_VOLTAGE_V;
 8005ede:	687b      	ldr	r3, [r7, #4]
 8005ee0:	4aad      	ldr	r2, [pc, #692]	; (8006198 <USER_setParams+0x2c8>)
 8005ee2:	605a      	str	r2, [r3, #4]

  pUserParams->iqFullScaleFreq_Hz = USER_IQ_FULL_SCALE_FREQ_Hz;
 8005ee4:	687b      	ldr	r3, [r7, #4]
 8005ee6:	4aad      	ldr	r2, [pc, #692]	; (800619c <USER_setParams+0x2cc>)
 8005ee8:	609a      	str	r2, [r3, #8]

  pUserParams->numIsrTicksPerCtrlTick = USER_NUM_ISR_TICKS_PER_CTRL_TICK;
 8005eea:	687b      	ldr	r3, [r7, #4]
 8005eec:	2201      	movs	r2, #1
 8005eee:	819a      	strh	r2, [r3, #12]
  pUserParams->numCtrlTicksPerCurrentTick = USER_NUM_CTRL_TICKS_PER_CURRENT_TICK;
 8005ef0:	687b      	ldr	r3, [r7, #4]
 8005ef2:	2201      	movs	r2, #1
 8005ef4:	81da      	strh	r2, [r3, #14]
  pUserParams->numCtrlTicksPerEstTick = USER_NUM_CTRL_TICKS_PER_EST_TICK;
 8005ef6:	687b      	ldr	r3, [r7, #4]
 8005ef8:	2201      	movs	r2, #1
 8005efa:	821a      	strh	r2, [r3, #16]
  pUserParams->numCtrlTicksPerSpeedTick = USER_NUM_CTRL_TICKS_PER_SPEED_TICK;
 8005efc:	687b      	ldr	r3, [r7, #4]
 8005efe:	2232      	movs	r2, #50	; 0x32
 8005f00:	825a      	strh	r2, [r3, #18]
  pUserParams->numCtrlTicksPerTrajTick = USER_NUM_CTRL_TICKS_PER_TRAJ_TICK;
 8005f02:	687b      	ldr	r3, [r7, #4]
 8005f04:	220a      	movs	r2, #10
 8005f06:	829a      	strh	r2, [r3, #20]

  pUserParams->numCurrentSensors = USER_NUM_CURRENT_SENSORS;
 8005f08:	687b      	ldr	r3, [r7, #4]
 8005f0a:	2203      	movs	r2, #3
 8005f0c:	759a      	strb	r2, [r3, #22]
  pUserParams->numVoltageSensors = USER_NUM_VOLTAGE_SENSORS;
 8005f0e:	687b      	ldr	r3, [r7, #4]
 8005f10:	2203      	movs	r2, #3
 8005f12:	75da      	strb	r2, [r3, #23]

  pUserParams->offsetPole_rps = USER_OFFSET_POLE_rps;
 8005f14:	687b      	ldr	r3, [r7, #4]
 8005f16:	4aa2      	ldr	r2, [pc, #648]	; (80061a0 <USER_setParams+0x2d0>)
 8005f18:	619a      	str	r2, [r3, #24]
  pUserParams->fluxPole_rps = USER_FLUX_POLE_rps;
 8005f1a:	687b      	ldr	r3, [r7, #4]
 8005f1c:	4aa1      	ldr	r2, [pc, #644]	; (80061a4 <USER_setParams+0x2d4>)
 8005f1e:	61da      	str	r2, [r3, #28]

  pUserParams->zeroSpeedLimit = USER_ZEROSPEEDLIMIT;
 8005f20:	687b      	ldr	r3, [r7, #4]
 8005f22:	4aa1      	ldr	r2, [pc, #644]	; (80061a8 <USER_setParams+0x2d8>)
 8005f24:	621a      	str	r2, [r3, #32]

  pUserParams->forceAngleFreq_Hz = USER_FORCE_ANGLE_FREQ_Hz;
 8005f26:	687b      	ldr	r3, [r7, #4]
 8005f28:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8005f2c:	625a      	str	r2, [r3, #36]	; 0x24

  pUserParams->maxAccel_Hzps = USER_MAX_ACCEL_Hzps;
 8005f2e:	687b      	ldr	r3, [r7, #4]
 8005f30:	4a9b      	ldr	r2, [pc, #620]	; (80061a0 <USER_setParams+0x2d0>)
 8005f32:	629a      	str	r2, [r3, #40]	; 0x28

  pUserParams->maxAccel_est_Hzps = USER_MAX_ACCEL_EST_Hzps;
 8005f34:	687b      	ldr	r3, [r7, #4]
 8005f36:	4a9d      	ldr	r2, [pc, #628]	; (80061ac <USER_setParams+0x2dc>)
 8005f38:	62da      	str	r2, [r3, #44]	; 0x2c

  pUserParams->directionPole_rps = USER_DIRECTION_POLE_rps;
 8005f3a:	687b      	ldr	r3, [r7, #4]
 8005f3c:	4a9c      	ldr	r2, [pc, #624]	; (80061b0 <USER_setParams+0x2e0>)
 8005f3e:	631a      	str	r2, [r3, #48]	; 0x30

  pUserParams->speedPole_rps = USER_SPEED_POLE_rps;
 8005f40:	687b      	ldr	r3, [r7, #4]
 8005f42:	4a98      	ldr	r2, [pc, #608]	; (80061a4 <USER_setParams+0x2d4>)
 8005f44:	635a      	str	r2, [r3, #52]	; 0x34

  pUserParams->dcBusPole_rps = USER_DCBUS_POLE_rps;
 8005f46:	687b      	ldr	r3, [r7, #4]
 8005f48:	4a96      	ldr	r2, [pc, #600]	; (80061a4 <USER_setParams+0x2d4>)
 8005f4a:	639a      	str	r2, [r3, #56]	; 0x38

  pUserParams->fluxFraction = USER_FLUX_FRACTION;
 8005f4c:	687b      	ldr	r3, [r7, #4]
 8005f4e:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8005f52:	63da      	str	r2, [r3, #60]	; 0x3c

  pUserParams->indEst_speedMaxFraction = USER_SPEEDMAX_FRACTION_FOR_L_IDENT;
 8005f54:	687b      	ldr	r3, [r7, #4]
 8005f56:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8005f5a:	641a      	str	r2, [r3, #64]	; 0x40

  pUserParams->powerWarpGain = USER_POWERWARP_GAIN;
 8005f5c:	687b      	ldr	r3, [r7, #4]
 8005f5e:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8005f62:	645a      	str	r2, [r3, #68]	; 0x44

  pUserParams->systemFreq_MHz = USER_SYSTEM_FREQ_MHz;
 8005f64:	687b      	ldr	r3, [r7, #4]
 8005f66:	225a      	movs	r2, #90	; 0x5a
 8005f68:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48

  pUserParams->pwmPeriod_usec = USER_PWM_PERIOD_usec;
 8005f6c:	687b      	ldr	r3, [r7, #4]
 8005f6e:	4a91      	ldr	r2, [pc, #580]	; (80061b4 <USER_setParams+0x2e4>)
 8005f70:	64da      	str	r2, [r3, #76]	; 0x4c

  pUserParams->voltage_sf = USER_VOLTAGE_SF;
 8005f72:	687b      	ldr	r3, [r7, #4]
 8005f74:	4a90      	ldr	r2, [pc, #576]	; (80061b8 <USER_setParams+0x2e8>)
 8005f76:	651a      	str	r2, [r3, #80]	; 0x50

  pUserParams->current_sf = USER_CURRENT_SF;
 8005f78:	687b      	ldr	r3, [r7, #4]
 8005f7a:	4a90      	ldr	r2, [pc, #576]	; (80061bc <USER_setParams+0x2ec>)
 8005f7c:	655a      	str	r2, [r3, #84]	; 0x54

  pUserParams->voltageFilterPole_rps = USER_VOLTAGE_FILTER_POLE_rps;
 8005f7e:	687b      	ldr	r3, [r7, #4]
 8005f80:	4a8f      	ldr	r2, [pc, #572]	; (80061c0 <USER_setParams+0x2f0>)
 8005f82:	659a      	str	r2, [r3, #88]	; 0x58

  pUserParams->maxVsMag_pu = USER_MAX_VS_MAG_PU;
 8005f84:	687b      	ldr	r3, [r7, #4]
 8005f86:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8005f8a:	65da      	str	r2, [r3, #92]	; 0x5c

  pUserParams->estKappa = USER_EST_KAPPAQ;
 8005f8c:	687b      	ldr	r3, [r7, #4]
 8005f8e:	f04f 527f 	mov.w	r2, #1069547520	; 0x3fc00000
 8005f92:	661a      	str	r2, [r3, #96]	; 0x60

  pUserParams->motor_type = USER_MOTOR_TYPE;
 8005f94:	687b      	ldr	r3, [r7, #4]
 8005f96:	2201      	movs	r2, #1
 8005f98:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
  pUserParams->motor_numPolePairs = USER_MOTOR_NUM_POLE_PAIRS;
 8005f9c:	687b      	ldr	r3, [r7, #4]
 8005f9e:	2204      	movs	r2, #4
 8005fa0:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
  pUserParams->motor_ratedFlux = USER_MOTOR_RATED_FLUX;
 8005fa4:	687b      	ldr	r3, [r7, #4]
 8005fa6:	4a87      	ldr	r2, [pc, #540]	; (80061c4 <USER_setParams+0x2f4>)
 8005fa8:	669a      	str	r2, [r3, #104]	; 0x68
  pUserParams->motor_Rr = USER_MOTOR_Rr;
 8005faa:	687b      	ldr	r3, [r7, #4]
 8005fac:	f04f 0200 	mov.w	r2, #0
 8005fb0:	66da      	str	r2, [r3, #108]	; 0x6c
  pUserParams->motor_Rs = USER_MOTOR_Rs;
 8005fb2:	687b      	ldr	r3, [r7, #4]
 8005fb4:	4a84      	ldr	r2, [pc, #528]	; (80061c8 <USER_setParams+0x2f8>)
 8005fb6:	671a      	str	r2, [r3, #112]	; 0x70
  pUserParams->motor_Ls_d = USER_MOTOR_Ls_d;
 8005fb8:	687b      	ldr	r3, [r7, #4]
 8005fba:	4a84      	ldr	r2, [pc, #528]	; (80061cc <USER_setParams+0x2fc>)
 8005fbc:	675a      	str	r2, [r3, #116]	; 0x74
  pUserParams->motor_Ls_q = USER_MOTOR_Ls_q;
 8005fbe:	687b      	ldr	r3, [r7, #4]
 8005fc0:	4a83      	ldr	r2, [pc, #524]	; (80061d0 <USER_setParams+0x300>)
 8005fc2:	679a      	str	r2, [r3, #120]	; 0x78

  pUserParams->maxCurrent_resEst = USER_MOTOR_RES_EST_CURRENT;
 8005fc4:	687b      	ldr	r3, [r7, #4]
 8005fc6:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8005fca:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  pUserParams->maxCurrent_indEst = USER_MOTOR_IND_EST_CURRENT;
 8005fce:	687b      	ldr	r3, [r7, #4]
 8005fd0:	4a80      	ldr	r2, [pc, #512]	; (80061d4 <USER_setParams+0x304>)
 8005fd2:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  pUserParams->maxCurrent = USER_MOTOR_MAX_CURRENT;
 8005fd6:	687b      	ldr	r3, [r7, #4]
 8005fd8:	4a71      	ldr	r2, [pc, #452]	; (80061a0 <USER_setParams+0x2d0>)
 8005fda:	67da      	str	r2, [r3, #124]	; 0x7c

  pUserParams->maxCurrentSlope = USER_MAX_CURRENT_SLOPE;
 8005fdc:	687b      	ldr	r3, [r7, #4]
 8005fde:	4a7e      	ldr	r2, [pc, #504]	; (80061d8 <USER_setParams+0x308>)
 8005fe0:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  pUserParams->maxCurrentSlope_powerWarp = USER_MAX_CURRENT_SLOPE_POWERWARP;
 8005fe4:	687b      	ldr	r3, [r7, #4]
 8005fe6:	4a7d      	ldr	r2, [pc, #500]	; (80061dc <USER_setParams+0x30c>)
 8005fe8:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

  pUserParams->IdRated = USER_MOTOR_MAGNETIZING_CURRENT;
 8005fec:	687b      	ldr	r3, [r7, #4]
 8005fee:	f04f 0200 	mov.w	r2, #0
 8005ff2:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  pUserParams->IdRatedFraction_ratedFlux = USER_IDRATED_FRACTION_FOR_RATED_FLUX;
 8005ff6:	687b      	ldr	r3, [r7, #4]
 8005ff8:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8005ffc:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  pUserParams->IdRatedFraction_indEst = USER_IDRATED_FRACTION_FOR_L_IDENT;
 8006000:	687b      	ldr	r3, [r7, #4]
 8006002:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8006006:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  pUserParams->IdRated_delta = USER_IDRATED_DELTA;
 800600a:	687b      	ldr	r3, [r7, #4]
 800600c:	4a74      	ldr	r2, [pc, #464]	; (80061e0 <USER_setParams+0x310>)
 800600e:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c

  pUserParams->fluxEstFreq_Hz = USER_MOTOR_FLUX_EST_FREQ_Hz;
 8006012:	687b      	ldr	r3, [r7, #4]
 8006014:	4a62      	ldr	r2, [pc, #392]	; (80061a0 <USER_setParams+0x2d0>)
 8006016:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

  pUserParams->ctrlWaitTime[CTRL_State_Error]         = 0;
 800601a:	687b      	ldr	r3, [r7, #4]
 800601c:	2200      	movs	r2, #0
 800601e:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
  pUserParams->ctrlWaitTime[CTRL_State_Idle]          = 0;
 8006022:	687b      	ldr	r3, [r7, #4]
 8006024:	2200      	movs	r2, #0
 8006026:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
  pUserParams->ctrlWaitTime[CTRL_State_OffLine]       = (uint_least32_t)( 5.0f * USER_CTRL_FREQ_Hz);
 800602a:	687b      	ldr	r3, [r7, #4]
 800602c:	4a6d      	ldr	r2, [pc, #436]	; (80061e4 <USER_setParams+0x314>)
 800602e:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
  pUserParams->ctrlWaitTime[CTRL_State_OnLine]        = 0;
 8006032:	687b      	ldr	r3, [r7, #4]
 8006034:	2200      	movs	r2, #0
 8006036:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0

  pUserParams->estWaitTime[EST_State_Error]           = 0;
 800603a:	687b      	ldr	r3, [r7, #4]
 800603c:	2200      	movs	r2, #0
 800603e:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
  pUserParams->estWaitTime[EST_State_Idle]            = 0;
 8006042:	687b      	ldr	r3, [r7, #4]
 8006044:	2200      	movs	r2, #0
 8006046:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
  pUserParams->estWaitTime[EST_State_RoverL]          = (uint_least32_t)( 8.0f * USER_EST_FREQ_Hz);
 800604a:	687b      	ldr	r3, [r7, #4]
 800604c:	4a66      	ldr	r2, [pc, #408]	; (80061e8 <USER_setParams+0x318>)
 800604e:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  pUserParams->estWaitTime[EST_State_Rs]              = 0;
 8006052:	687b      	ldr	r3, [r7, #4]
 8006054:	2200      	movs	r2, #0
 8006056:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
  pUserParams->estWaitTime[EST_State_RampUp]          = (uint_least32_t)((5.0f + USER_MOTOR_FLUX_EST_FREQ_Hz / USER_MAX_ACCEL_EST_Hzps) * USER_EST_FREQ_Hz);
 800605a:	687b      	ldr	r3, [r7, #4]
 800605c:	4a63      	ldr	r2, [pc, #396]	; (80061ec <USER_setParams+0x31c>)
 800605e:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
  pUserParams->estWaitTime[EST_State_IdRated]         = (uint_least32_t)(30.0f * USER_EST_FREQ_Hz);
 8006062:	687b      	ldr	r3, [r7, #4]
 8006064:	4a62      	ldr	r2, [pc, #392]	; (80061f0 <USER_setParams+0x320>)
 8006066:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
  pUserParams->estWaitTime[EST_State_RatedFlux_OL]    = (uint_least32_t)( 0.2f * USER_EST_FREQ_Hz);
 800606a:	687b      	ldr	r3, [r7, #4]
 800606c:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
 8006070:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
  pUserParams->estWaitTime[EST_State_RatedFlux]       = 0;
 8006074:	687b      	ldr	r3, [r7, #4]
 8006076:	2200      	movs	r2, #0
 8006078:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
  pUserParams->estWaitTime[EST_State_RampDown]        = (uint_least32_t)( 2.0f * USER_EST_FREQ_Hz);
 800607c:	687b      	ldr	r3, [r7, #4]
 800607e:	f649 4240 	movw	r2, #40000	; 0x9c40
 8006082:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
  pUserParams->estWaitTime[EST_State_LockRotor]       = 0;
 8006086:	687b      	ldr	r3, [r7, #4]
 8006088:	2200      	movs	r2, #0
 800608a:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
  pUserParams->estWaitTime[EST_State_Ls]              = 0;
 800608e:	687b      	ldr	r3, [r7, #4]
 8006090:	2200      	movs	r2, #0
 8006092:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
  pUserParams->estWaitTime[EST_State_Rr]              = (uint_least32_t)(20.0f * USER_EST_FREQ_Hz);
 8006096:	687b      	ldr	r3, [r7, #4]
 8006098:	4a56      	ldr	r2, [pc, #344]	; (80061f4 <USER_setParams+0x324>)
 800609a:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
  pUserParams->estWaitTime[EST_State_MotorIdentified] = 0;
 800609e:	687b      	ldr	r3, [r7, #4]
 80060a0:	2200      	movs	r2, #0
 80060a2:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
  pUserParams->estWaitTime[EST_State_OnLine]          = 0;
 80060a6:	687b      	ldr	r3, [r7, #4]
 80060a8:	2200      	movs	r2, #0
 80060aa:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100

  pUserParams->FluxWaitTime[EST_Flux_State_Error]     = 0;
 80060ae:	687b      	ldr	r3, [r7, #4]
 80060b0:	2200      	movs	r2, #0
 80060b2:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  pUserParams->FluxWaitTime[EST_Flux_State_Idle]      = 0;
 80060b6:	687b      	ldr	r3, [r7, #4]
 80060b8:	2200      	movs	r2, #0
 80060ba:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
  pUserParams->FluxWaitTime[EST_Flux_State_CL1]       = (uint_least32_t)(10.0f * USER_EST_FREQ_Hz);
 80060be:	687b      	ldr	r3, [r7, #4]
 80060c0:	4a4d      	ldr	r2, [pc, #308]	; (80061f8 <USER_setParams+0x328>)
 80060c2:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
  pUserParams->FluxWaitTime[EST_Flux_State_CL2]       = (uint_least32_t)( 0.2f * USER_EST_FREQ_Hz);
 80060c6:	687b      	ldr	r3, [r7, #4]
 80060c8:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
 80060cc:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
  pUserParams->FluxWaitTime[EST_Flux_State_Fine]      = (uint_least32_t)( 4.0f * USER_EST_FREQ_Hz);
 80060d0:	687b      	ldr	r3, [r7, #4]
 80060d2:	4a4a      	ldr	r2, [pc, #296]	; (80061fc <USER_setParams+0x32c>)
 80060d4:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
  pUserParams->FluxWaitTime[EST_Flux_State_Done]      = 0;
 80060d8:	687b      	ldr	r3, [r7, #4]
 80060da:	2200      	movs	r2, #0
 80060dc:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118

  pUserParams->LsWaitTime[EST_Ls_State_Error]        = 0;
 80060e0:	687b      	ldr	r3, [r7, #4]
 80060e2:	2200      	movs	r2, #0
 80060e4:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
  pUserParams->LsWaitTime[EST_Ls_State_Idle]         = 0;
 80060e8:	687b      	ldr	r3, [r7, #4]
 80060ea:	2200      	movs	r2, #0
 80060ec:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
  pUserParams->LsWaitTime[EST_Ls_State_RampUp]       = (uint_least32_t)( 3.0f * USER_EST_FREQ_Hz);
 80060f0:	687b      	ldr	r3, [r7, #4]
 80060f2:	f64e 2260 	movw	r2, #60000	; 0xea60
 80060f6:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
  pUserParams->LsWaitTime[EST_Ls_State_Init]         = (uint_least32_t)( 3.0f * USER_EST_FREQ_Hz);
 80060fa:	687b      	ldr	r3, [r7, #4]
 80060fc:	f64e 2260 	movw	r2, #60000	; 0xea60
 8006100:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
  pUserParams->LsWaitTime[EST_Ls_State_Coarse]       = (uint_least32_t)( 0.2f * USER_EST_FREQ_Hz);
 8006104:	687b      	ldr	r3, [r7, #4]
 8006106:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
 800610a:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c
  pUserParams->LsWaitTime[EST_Ls_State_Fine]         = (uint_least32_t)(30.0f * USER_EST_FREQ_Hz);
 800610e:	687b      	ldr	r3, [r7, #4]
 8006110:	4a37      	ldr	r2, [pc, #220]	; (80061f0 <USER_setParams+0x320>)
 8006112:	f8c3 2130 	str.w	r2, [r3, #304]	; 0x130
  pUserParams->LsWaitTime[EST_Ls_State_Done]         = 0;
 8006116:	687b      	ldr	r3, [r7, #4]
 8006118:	2200      	movs	r2, #0
 800611a:	f8c3 2134 	str.w	r2, [r3, #308]	; 0x134

  pUserParams->RsWaitTime[EST_Rs_State_Error]        = 0;
 800611e:	687b      	ldr	r3, [r7, #4]
 8006120:	2200      	movs	r2, #0
 8006122:	f8c3 2138 	str.w	r2, [r3, #312]	; 0x138
  pUserParams->RsWaitTime[EST_Rs_State_Idle]         = 0;
 8006126:	687b      	ldr	r3, [r7, #4]
 8006128:	2200      	movs	r2, #0
 800612a:	f8c3 213c 	str.w	r2, [r3, #316]	; 0x13c
  pUserParams->RsWaitTime[EST_Rs_State_RampUp]       = (uint_least32_t)( 1.0f * USER_EST_FREQ_Hz);
 800612e:	687b      	ldr	r3, [r7, #4]
 8006130:	f644 6220 	movw	r2, #20000	; 0x4e20
 8006134:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
  pUserParams->RsWaitTime[EST_Rs_State_Coarse]       = (uint_least32_t)( 2.0f * USER_EST_FREQ_Hz);
 8006138:	687b      	ldr	r3, [r7, #4]
 800613a:	f649 4240 	movw	r2, #40000	; 0x9c40
 800613e:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
  pUserParams->RsWaitTime[EST_Rs_State_Fine]         = (uint_least32_t)( 7.0f * USER_EST_FREQ_Hz);
 8006142:	687b      	ldr	r3, [r7, #4]
 8006144:	4a2e      	ldr	r2, [pc, #184]	; (8006200 <USER_setParams+0x330>)
 8006146:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
  pUserParams->RsWaitTime[EST_Rs_State_Done]         = 0;
 800614a:	687b      	ldr	r3, [r7, #4]
 800614c:	2200      	movs	r2, #0
 800614e:	f8c3 214c 	str.w	r2, [r3, #332]	; 0x14c

  pUserParams->ctrlFreq_Hz = USER_CTRL_FREQ_Hz;
 8006152:	687b      	ldr	r3, [r7, #4]
 8006154:	f644 6220 	movw	r2, #20000	; 0x4e20
 8006158:	f8c3 2150 	str.w	r2, [r3, #336]	; 0x150

  pUserParams->estFreq_Hz = USER_EST_FREQ_Hz;
 800615c:	687b      	ldr	r3, [r7, #4]
 800615e:	f644 6220 	movw	r2, #20000	; 0x4e20
 8006162:	f8c3 2154 	str.w	r2, [r3, #340]	; 0x154

  pUserParams->RoverL_estFreq_Hz = USER_R_OVER_L_EST_FREQ_Hz;
 8006166:	687b      	ldr	r3, [r7, #4]
 8006168:	f44f 7296 	mov.w	r2, #300	; 0x12c
 800616c:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158

  pUserParams->trajFreq_Hz = USER_TRAJ_FREQ_Hz;
 8006170:	687b      	ldr	r3, [r7, #4]
 8006172:	4a24      	ldr	r2, [pc, #144]	; (8006204 <USER_setParams+0x334>)
 8006174:	f8c3 215c 	str.w	r2, [r3, #348]	; 0x15c

  pUserParams->ctrlPeriod_sec = USER_CTRL_PERIOD_sec;
 8006178:	687b      	ldr	r3, [r7, #4]
 800617a:	4a23      	ldr	r2, [pc, #140]	; (8006208 <USER_setParams+0x338>)
 800617c:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160

  pUserParams->maxNegativeIdCurrent_a = USER_MAX_NEGATIVE_ID_REF_CURRENT_A;
 8006180:	687b      	ldr	r3, [r7, #4]
 8006182:	4a22      	ldr	r2, [pc, #136]	; (800620c <USER_setParams+0x33c>)
 8006184:	f8c3 2164 	str.w	r2, [r3, #356]	; 0x164

  return;
 8006188:	bf00      	nop
} // end of USER_setParams() function
 800618a:	370c      	adds	r7, #12
 800618c:	46bd      	mov	sp, r7
 800618e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006192:	4770      	bx	lr
 8006194:	43480000 	.word	0x43480000
 8006198:	44c80000 	.word	0x44c80000
 800619c:	44480000 	.word	0x44480000
 80061a0:	41a00000 	.word	0x41a00000
 80061a4:	42c80000 	.word	0x42c80000
 80061a8:	3aa3d70a 	.word	0x3aa3d70a
 80061ac:	40a00000 	.word	0x40a00000
 80061b0:	40c00000 	.word	0x40c00000
 80061b4:	42480000 	.word	0x42480000
 80061b8:	3facae6f 	.word	0x3facae6f
 80061bc:	3f840000 	.word	0x3f840000
 80061c0:	458e1e15 	.word	0x458e1e15
 80061c4:	3dc0ebee 	.word	0x3dc0ebee
 80061c8:	3c5b02f0 	.word	0x3c5b02f0
 80061cc:	391eeec3 	.word	0x391eeec3
 80061d0:	3a16d3c2 	.word	0x3a16d3c2
 80061d4:	bf800000 	.word	0xbf800000
 80061d8:	3627c5ac 	.word	0x3627c5ac
 80061dc:	3549539c 	.word	0x3549539c
 80061e0:	37a7c5ac 	.word	0x37a7c5ac
 80061e4:	000186a0 	.word	0x000186a0
 80061e8:	00027100 	.word	0x00027100
 80061ec:	0002bf20 	.word	0x0002bf20
 80061f0:	000927c0 	.word	0x000927c0
 80061f4:	00061a80 	.word	0x00061a80
 80061f8:	00030d40 	.word	0x00030d40
 80061fc:	00013880 	.word	0x00013880
 8006200:	000222e0 	.word	0x000222e0
 8006204:	44fa0000 	.word	0x44fa0000
 8006208:	3851b717 	.word	0x3851b717
 800620c:	c1200000 	.word	0xc1200000

08006210 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8006210:	b580      	push	{r7, lr}
 8006212:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch and Instruction cache through ART accelerator */ 
#if (ART_ACCLERATOR_ENABLE != 0)
   __HAL_FLASH_ART_ENABLE();
 8006214:	4a08      	ldr	r2, [pc, #32]	; (8006238 <HAL_Init+0x28>)
 8006216:	4b08      	ldr	r3, [pc, #32]	; (8006238 <HAL_Init+0x28>)
 8006218:	681b      	ldr	r3, [r3, #0]
 800621a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800621e:	6013      	str	r3, [r2, #0]
#endif /* ART_ACCLERATOR_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP);
 8006220:	2003      	movs	r0, #3
 8006222:	f002 f821 	bl	8008268 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(SYSTICK_IRQ_PREEMPT);
 8006226:	200f      	movs	r0, #15
 8006228:	f00c f824 	bl	8012274 <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 800622c:	f006 ffd2 	bl	800d1d4 <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
 8006230:	2300      	movs	r3, #0
}
 8006232:	4618      	mov	r0, r3
 8006234:	bd80      	pop	{r7, pc}
 8006236:	bf00      	nop
 8006238:	40023c00 	.word	0x40023c00

0800623c <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 800623c:	b480      	push	{r7}
 800623e:	af00      	add	r7, sp, #0
  uwTick++;
 8006240:	4b04      	ldr	r3, [pc, #16]	; (8006254 <HAL_IncTick+0x18>)
 8006242:	681b      	ldr	r3, [r3, #0]
 8006244:	3301      	adds	r3, #1
 8006246:	4a03      	ldr	r2, [pc, #12]	; (8006254 <HAL_IncTick+0x18>)
 8006248:	6013      	str	r3, [r2, #0]
}
 800624a:	46bd      	mov	sp, r7
 800624c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006250:	4770      	bx	lr
 8006252:	bf00      	nop
 8006254:	200107ec 	.word	0x200107ec

08006258 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8006258:	b480      	push	{r7}
 800625a:	af00      	add	r7, sp, #0
  return uwTick;
 800625c:	4b03      	ldr	r3, [pc, #12]	; (800626c <HAL_GetTick+0x14>)
 800625e:	681b      	ldr	r3, [r3, #0]
}
 8006260:	4618      	mov	r0, r3
 8006262:	46bd      	mov	sp, r7
 8006264:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006268:	4770      	bx	lr
 800626a:	bf00      	nop
 800626c:	200107ec 	.word	0x200107ec

08006270 <HAL_ADC_Init>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
 8006270:	b580      	push	{r7, lr}
 8006272:	b082      	sub	sp, #8
 8006274:	af00      	add	r7, sp, #0
 8006276:	6078      	str	r0, [r7, #4]
  /* Check ADC handle */
  if(hadc == NULL)
 8006278:	687b      	ldr	r3, [r7, #4]
 800627a:	2b00      	cmp	r3, #0
 800627c:	d101      	bne.n	8006282 <HAL_ADC_Init+0x12>
  {
     return HAL_ERROR;
 800627e:	2301      	movs	r3, #1
 8006280:	e01f      	b.n	80062c2 <HAL_ADC_Init+0x52>
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
  {
    assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
  }

  if(hadc->State == HAL_ADC_STATE_RESET)
 8006282:	687b      	ldr	r3, [r7, #4]
 8006284:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8006288:	b2db      	uxtb	r3, r3
 800628a:	2b00      	cmp	r3, #0
 800628c:	d106      	bne.n	800629c <HAL_ADC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hadc->Lock = HAL_UNLOCKED;
 800628e:	687b      	ldr	r3, [r7, #4]
 8006290:	2200      	movs	r2, #0
 8006292:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 8006296:	6878      	ldr	r0, [r7, #4]
 8006298:	f00c fc92 	bl	8012bc0 <HAL_ADC_MspInit>
  }

  /* Initialize the ADC state */
  hadc->State = HAL_ADC_STATE_BUSY;
 800629c:	687b      	ldr	r3, [r7, #4]
 800629e:	2202      	movs	r2, #2
 80062a0:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Set ADC parameters */
  ADC_Init(hadc);
 80062a4:	6878      	ldr	r0, [r7, #4]
 80062a6:	f000 fb41 	bl	800692c <ADC_Init>
  
  /* Set ADC error code to none */
  hadc->ErrorCode = HAL_ADC_ERROR_NONE;
 80062aa:	687b      	ldr	r3, [r7, #4]
 80062ac:	2200      	movs	r2, #0
 80062ae:	641a      	str	r2, [r3, #64]	; 0x40
  
  /* Initialize the ADC state */
  hadc->State = HAL_ADC_STATE_READY;
 80062b0:	687b      	ldr	r3, [r7, #4]
 80062b2:	2201      	movs	r2, #1
 80062b4:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(hadc);
 80062b8:	687b      	ldr	r3, [r7, #4]
 80062ba:	2200      	movs	r2, #0
 80062bc:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Return function status */
  return HAL_OK;
 80062c0:	2300      	movs	r3, #0
}
 80062c2:	4618      	mov	r0, r3
 80062c4:	3708      	adds	r7, #8
 80062c6:	46bd      	mov	sp, r7
 80062c8:	bd80      	pop	{r7, pc}
 80062ca:	bf00      	nop

080062cc <HAL_ADC_DeInit>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_DeInit(ADC_HandleTypeDef* hadc)
{
 80062cc:	b580      	push	{r7, lr}
 80062ce:	b082      	sub	sp, #8
 80062d0:	af00      	add	r7, sp, #0
 80062d2:	6078      	str	r0, [r7, #4]
  /* Check ADC handle */
  if(hadc == NULL)
 80062d4:	687b      	ldr	r3, [r7, #4]
 80062d6:	2b00      	cmp	r3, #0
 80062d8:	d101      	bne.n	80062de <HAL_ADC_DeInit+0x12>
  {
     return HAL_ERROR;
 80062da:	2301      	movs	r3, #1
 80062dc:	e00e      	b.n	80062fc <HAL_ADC_DeInit+0x30>
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_BUSY;
 80062de:	687b      	ldr	r3, [r7, #4]
 80062e0:	2202      	movs	r2, #2
 80062e2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* DeInit the low level hardware */
  HAL_ADC_MspDeInit(hadc);
 80062e6:	6878      	ldr	r0, [r7, #4]
 80062e8:	f00c feb2 	bl	8013050 <HAL_ADC_MspDeInit>
  
  /* Set ADC error code to none */
  hadc->ErrorCode = HAL_ADC_ERROR_NONE;
 80062ec:	687b      	ldr	r3, [r7, #4]
 80062ee:	2200      	movs	r2, #0
 80062f0:	641a      	str	r2, [r3, #64]	; 0x40
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_RESET;
 80062f2:	687b      	ldr	r3, [r7, #4]
 80062f4:	2200      	movs	r2, #0
 80062f6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Return function status */
  return HAL_OK;
 80062fa:	2300      	movs	r3, #0
}
 80062fc:	4618      	mov	r0, r3
 80062fe:	3708      	adds	r7, #8
 8006300:	46bd      	mov	sp, r7
 8006302:	bd80      	pop	{r7, pc}

08006304 <HAL_ADC_Start>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc)
{
 8006304:	b480      	push	{r7}
 8006306:	b085      	sub	sp, #20
 8006308:	af00      	add	r7, sp, #0
 800630a:	6078      	str	r0, [r7, #4]
  __IO uint32_t counter = 0;
 800630c:	2300      	movs	r3, #0
 800630e:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
  assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge)); 
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8006310:	687b      	ldr	r3, [r7, #4]
 8006312:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8006316:	2b01      	cmp	r3, #1
 8006318:	d101      	bne.n	800631e <HAL_ADC_Start+0x1a>
 800631a:	2302      	movs	r3, #2
 800631c:	e061      	b.n	80063e2 <HAL_ADC_Start+0xde>
 800631e:	687b      	ldr	r3, [r7, #4]
 8006320:	2201      	movs	r2, #1
 8006322:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Check if an injected conversion is ongoing */
  if(hadc->State == HAL_ADC_STATE_BUSY_INJ)
 8006326:	687b      	ldr	r3, [r7, #4]
 8006328:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800632c:	b2db      	uxtb	r3, r3
 800632e:	2b22      	cmp	r3, #34	; 0x22
 8006330:	d104      	bne.n	800633c <HAL_ADC_Start+0x38>
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_INJ_REG;  
 8006332:	687b      	ldr	r3, [r7, #4]
 8006334:	2232      	movs	r2, #50	; 0x32
 8006336:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 800633a:	e003      	b.n	8006344 <HAL_ADC_Start+0x40>
  }
  else
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_REG;
 800633c:	687b      	ldr	r3, [r7, #4]
 800633e:	2212      	movs	r2, #18
 8006340:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  } 
    
  /* Check if ADC peripheral is disabled in order to enable it and wait during 
  Tstab time the ADC's stabilization */
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 8006344:	687b      	ldr	r3, [r7, #4]
 8006346:	681b      	ldr	r3, [r3, #0]
 8006348:	689b      	ldr	r3, [r3, #8]
 800634a:	f003 0301 	and.w	r3, r3, #1
 800634e:	2b00      	cmp	r3, #0
 8006350:	d118      	bne.n	8006384 <HAL_ADC_Start+0x80>
  {  
    /* Enable the Peripheral */
    __HAL_ADC_ENABLE(hadc);
 8006352:	687b      	ldr	r3, [r7, #4]
 8006354:	681b      	ldr	r3, [r3, #0]
 8006356:	687a      	ldr	r2, [r7, #4]
 8006358:	6812      	ldr	r2, [r2, #0]
 800635a:	6892      	ldr	r2, [r2, #8]
 800635c:	f042 0201 	orr.w	r2, r2, #1
 8006360:	609a      	str	r2, [r3, #8]
    
    /* Delay for ADC stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 8006362:	4b23      	ldr	r3, [pc, #140]	; (80063f0 <HAL_ADC_Start+0xec>)
 8006364:	681b      	ldr	r3, [r3, #0]
 8006366:	4a23      	ldr	r2, [pc, #140]	; (80063f4 <HAL_ADC_Start+0xf0>)
 8006368:	fba2 2303 	umull	r2, r3, r2, r3
 800636c:	0c9a      	lsrs	r2, r3, #18
 800636e:	4613      	mov	r3, r2
 8006370:	005b      	lsls	r3, r3, #1
 8006372:	4413      	add	r3, r2
 8006374:	60fb      	str	r3, [r7, #12]
    while(counter != 0)
 8006376:	e002      	b.n	800637e <HAL_ADC_Start+0x7a>
    {
      counter--;
 8006378:	68fb      	ldr	r3, [r7, #12]
 800637a:	3b01      	subs	r3, #1
 800637c:	60fb      	str	r3, [r7, #12]
    __HAL_ADC_ENABLE(hadc);
    
    /* Delay for ADC stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
    while(counter != 0)
 800637e:	68fb      	ldr	r3, [r7, #12]
 8006380:	2b00      	cmp	r3, #0
 8006382:	d1f9      	bne.n	8006378 <HAL_ADC_Start+0x74>
      counter--;
    }
  }
	
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8006384:	687b      	ldr	r3, [r7, #4]
 8006386:	2200      	movs	r2, #0
 8006388:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Check if Multimode enabled */
  if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
 800638c:	4b1a      	ldr	r3, [pc, #104]	; (80063f8 <HAL_ADC_Start+0xf4>)
 800638e:	685b      	ldr	r3, [r3, #4]
 8006390:	f003 031f 	and.w	r3, r3, #31
 8006394:	2b00      	cmp	r3, #0
 8006396:	d10f      	bne.n	80063b8 <HAL_ADC_Start+0xb4>
  {
    /* if no external trigger present enable software conversion of regular channels */
    if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET)
 8006398:	687b      	ldr	r3, [r7, #4]
 800639a:	681b      	ldr	r3, [r3, #0]
 800639c:	689b      	ldr	r3, [r3, #8]
 800639e:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 80063a2:	2b00      	cmp	r3, #0
 80063a4:	d11c      	bne.n	80063e0 <HAL_ADC_Start+0xdc>
    {
      /* Enable the selected ADC software conversion for regular group */
      hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 80063a6:	687b      	ldr	r3, [r7, #4]
 80063a8:	681b      	ldr	r3, [r3, #0]
 80063aa:	687a      	ldr	r2, [r7, #4]
 80063ac:	6812      	ldr	r2, [r2, #0]
 80063ae:	6892      	ldr	r2, [r2, #8]
 80063b0:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 80063b4:	609a      	str	r2, [r3, #8]
 80063b6:	e013      	b.n	80063e0 <HAL_ADC_Start+0xdc>
    }
  }
  else
  {
    /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
    if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 80063b8:	687b      	ldr	r3, [r7, #4]
 80063ba:	681b      	ldr	r3, [r3, #0]
 80063bc:	4a0f      	ldr	r2, [pc, #60]	; (80063fc <HAL_ADC_Start+0xf8>)
 80063be:	4293      	cmp	r3, r2
 80063c0:	d10e      	bne.n	80063e0 <HAL_ADC_Start+0xdc>
 80063c2:	687b      	ldr	r3, [r7, #4]
 80063c4:	681b      	ldr	r3, [r3, #0]
 80063c6:	689b      	ldr	r3, [r3, #8]
 80063c8:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 80063cc:	2b00      	cmp	r3, #0
 80063ce:	d107      	bne.n	80063e0 <HAL_ADC_Start+0xdc>
    {
      /* Enable the selected ADC software conversion for regular group */
        hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 80063d0:	687b      	ldr	r3, [r7, #4]
 80063d2:	681b      	ldr	r3, [r3, #0]
 80063d4:	687a      	ldr	r2, [r7, #4]
 80063d6:	6812      	ldr	r2, [r2, #0]
 80063d8:	6892      	ldr	r2, [r2, #8]
 80063da:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 80063de:	609a      	str	r2, [r3, #8]
    }
  }
  
  /* Return function status */
  return HAL_OK;
 80063e0:	2300      	movs	r3, #0
}
 80063e2:	4618      	mov	r0, r3
 80063e4:	3714      	adds	r7, #20
 80063e6:	46bd      	mov	sp, r7
 80063e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80063ec:	4770      	bx	lr
 80063ee:	bf00      	nop
 80063f0:	20010014 	.word	0x20010014
 80063f4:	431bde83 	.word	0x431bde83
 80063f8:	40012300 	.word	0x40012300
 80063fc:	40012000 	.word	0x40012000

08006400 <HAL_ADC_Stop>:
  *         the configuration information for the specified ADC.
  *
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc)
{
 8006400:	b480      	push	{r7}
 8006402:	b083      	sub	sp, #12
 8006404:	af00      	add	r7, sp, #0
 8006406:	6078      	str	r0, [r7, #4]
  /* Disable the Peripheral */
  __HAL_ADC_DISABLE(hadc);
 8006408:	687b      	ldr	r3, [r7, #4]
 800640a:	681b      	ldr	r3, [r3, #0]
 800640c:	687a      	ldr	r2, [r7, #4]
 800640e:	6812      	ldr	r2, [r2, #0]
 8006410:	6892      	ldr	r2, [r2, #8]
 8006412:	f022 0201 	bic.w	r2, r2, #1
 8006416:	609a      	str	r2, [r3, #8]
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_READY;
 8006418:	687b      	ldr	r3, [r7, #4]
 800641a:	2201      	movs	r2, #1
 800641c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Return function status */
  return HAL_OK;
 8006420:	2300      	movs	r3, #0
}
 8006422:	4618      	mov	r0, r3
 8006424:	370c      	adds	r7, #12
 8006426:	46bd      	mov	sp, r7
 8006428:	f85d 7b04 	ldr.w	r7, [sp], #4
 800642c:	4770      	bx	lr
 800642e:	bf00      	nop

08006430 <HAL_ADC_IRQHandler>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */
void HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc)
{
 8006430:	b580      	push	{r7, lr}
 8006432:	b084      	sub	sp, #16
 8006434:	af00      	add	r7, sp, #0
 8006436:	6078      	str	r0, [r7, #4]
  uint32_t tmp1 = 0, tmp2 = 0;
 8006438:	2300      	movs	r3, #0
 800643a:	60fb      	str	r3, [r7, #12]
 800643c:	2300      	movs	r3, #0
 800643e:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
  assert_param(IS_ADC_REGULAR_LENGTH(hadc->Init.NbrOfConversion));
  assert_param(IS_ADC_EOCSelection(hadc->Init.EOCSelection));
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC);
 8006440:	687b      	ldr	r3, [r7, #4]
 8006442:	681b      	ldr	r3, [r3, #0]
 8006444:	681b      	ldr	r3, [r3, #0]
 8006446:	f003 0302 	and.w	r3, r3, #2
 800644a:	2b00      	cmp	r3, #0
 800644c:	bf14      	ite	ne
 800644e:	2301      	movne	r3, #1
 8006450:	2300      	moveq	r3, #0
 8006452:	b2db      	uxtb	r3, r3
 8006454:	60fb      	str	r3, [r7, #12]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC);
 8006456:	687b      	ldr	r3, [r7, #4]
 8006458:	681b      	ldr	r3, [r3, #0]
 800645a:	685b      	ldr	r3, [r3, #4]
 800645c:	f003 0320 	and.w	r3, r3, #32
 8006460:	2b00      	cmp	r3, #0
 8006462:	bf14      	ite	ne
 8006464:	2301      	movne	r3, #1
 8006466:	2300      	moveq	r3, #0
 8006468:	b2db      	uxtb	r3, r3
 800646a:	60bb      	str	r3, [r7, #8]
  /* Check End of conversion flag for regular channels */
  if(tmp1 && tmp2)
 800646c:	68fb      	ldr	r3, [r7, #12]
 800646e:	2b00      	cmp	r3, #0
 8006470:	d05a      	beq.n	8006528 <HAL_ADC_IRQHandler+0xf8>
 8006472:	68bb      	ldr	r3, [r7, #8]
 8006474:	2b00      	cmp	r3, #0
 8006476:	d057      	beq.n	8006528 <HAL_ADC_IRQHandler+0xf8>
  {
    /* Check if an injected conversion is ready */
    if(hadc->State == HAL_ADC_STATE_EOC_INJ)
 8006478:	687b      	ldr	r3, [r7, #4]
 800647a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800647e:	b2db      	uxtb	r3, r3
 8006480:	2b25      	cmp	r3, #37	; 0x25
 8006482:	d104      	bne.n	800648e <HAL_ADC_IRQHandler+0x5e>
    {
      /* Change ADC state */
      hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
 8006484:	687b      	ldr	r3, [r7, #4]
 8006486:	2235      	movs	r2, #53	; 0x35
 8006488:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 800648c:	e003      	b.n	8006496 <HAL_ADC_IRQHandler+0x66>
    }
    else
    {
      /* Change ADC state */
      hadc->State = HAL_ADC_STATE_EOC_REG;
 800648e:	687b      	ldr	r3, [r7, #4]
 8006490:	2215      	movs	r2, #21
 8006492:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    }

    if((hadc->Init.ContinuousConvMode == DISABLE) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 8006496:	687b      	ldr	r3, [r7, #4]
 8006498:	699b      	ldr	r3, [r3, #24]
 800649a:	2b00      	cmp	r3, #0
 800649c:	d13c      	bne.n	8006518 <HAL_ADC_IRQHandler+0xe8>
 800649e:	687b      	ldr	r3, [r7, #4]
 80064a0:	681b      	ldr	r3, [r3, #0]
 80064a2:	689b      	ldr	r3, [r3, #8]
 80064a4:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 80064a8:	2b00      	cmp	r3, #0
 80064aa:	d135      	bne.n	8006518 <HAL_ADC_IRQHandler+0xe8>
    {
      if(hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 80064ac:	687b      	ldr	r3, [r7, #4]
 80064ae:	695b      	ldr	r3, [r3, #20]
 80064b0:	2b00      	cmp	r3, #0
 80064b2:	d110      	bne.n	80064d6 <HAL_ADC_IRQHandler+0xa6>
      { 
        /* DISABLE the ADC end of conversion interrupt for regular group */
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 80064b4:	687b      	ldr	r3, [r7, #4]
 80064b6:	681b      	ldr	r3, [r3, #0]
 80064b8:	687a      	ldr	r2, [r7, #4]
 80064ba:	6812      	ldr	r2, [r2, #0]
 80064bc:	6852      	ldr	r2, [r2, #4]
 80064be:	f022 0220 	bic.w	r2, r2, #32
 80064c2:	605a      	str	r2, [r3, #4]
        
        /* DISABLE the ADC overrun interrupt */
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
 80064c4:	687b      	ldr	r3, [r7, #4]
 80064c6:	681b      	ldr	r3, [r3, #0]
 80064c8:	687a      	ldr	r2, [r7, #4]
 80064ca:	6812      	ldr	r2, [r2, #0]
 80064cc:	6852      	ldr	r2, [r2, #4]
 80064ce:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 80064d2:	605a      	str	r2, [r3, #4]
 80064d4:	e020      	b.n	8006518 <HAL_ADC_IRQHandler+0xe8>
      }
      else
      {
        if (hadc->NbrOfCurrentConversionRank == 0)
 80064d6:	687b      	ldr	r3, [r7, #4]
 80064d8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80064da:	2b00      	cmp	r3, #0
 80064dc:	d103      	bne.n	80064e6 <HAL_ADC_IRQHandler+0xb6>
        {
          hadc->NbrOfCurrentConversionRank = hadc->Init.NbrOfConversion;
 80064de:	687b      	ldr	r3, [r7, #4]
 80064e0:	6a1a      	ldr	r2, [r3, #32]
 80064e2:	687b      	ldr	r3, [r7, #4]
 80064e4:	635a      	str	r2, [r3, #52]	; 0x34
        }
        
        /* Decrement the number of conversion when an interrupt occurs */
        hadc->NbrOfCurrentConversionRank--;
 80064e6:	687b      	ldr	r3, [r7, #4]
 80064e8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80064ea:	1e5a      	subs	r2, r3, #1
 80064ec:	687b      	ldr	r3, [r7, #4]
 80064ee:	635a      	str	r2, [r3, #52]	; 0x34
        
        /* Check if all conversions are finished */
        if(hadc->NbrOfCurrentConversionRank == 0)
 80064f0:	687b      	ldr	r3, [r7, #4]
 80064f2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80064f4:	2b00      	cmp	r3, #0
 80064f6:	d10f      	bne.n	8006518 <HAL_ADC_IRQHandler+0xe8>
        {
          /* DISABLE the ADC end of conversion interrupt for regular group */
          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 80064f8:	687b      	ldr	r3, [r7, #4]
 80064fa:	681b      	ldr	r3, [r3, #0]
 80064fc:	687a      	ldr	r2, [r7, #4]
 80064fe:	6812      	ldr	r2, [r2, #0]
 8006500:	6852      	ldr	r2, [r2, #4]
 8006502:	f022 0220 	bic.w	r2, r2, #32
 8006506:	605a      	str	r2, [r3, #4]
          
          /* DISABLE the ADC overrun interrupt */
          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
 8006508:	687b      	ldr	r3, [r7, #4]
 800650a:	681b      	ldr	r3, [r3, #0]
 800650c:	687a      	ldr	r2, [r7, #4]
 800650e:	6812      	ldr	r2, [r2, #0]
 8006510:	6852      	ldr	r2, [r2, #4]
 8006512:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8006516:	605a      	str	r2, [r3, #4]
        }
      }
    }
    
    /* Conversion complete callback */ 
    HAL_ADC_ConvCpltCallback(hadc);
 8006518:	6878      	ldr	r0, [r7, #4]
 800651a:	f000 f8c7 	bl	80066ac <HAL_ADC_ConvCpltCallback>
    
   /* Clear the ADCx flag for regular end of conversion */
    __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 800651e:	687b      	ldr	r3, [r7, #4]
 8006520:	681b      	ldr	r3, [r3, #0]
 8006522:	f06f 0202 	mvn.w	r2, #2
 8006526:	601a      	str	r2, [r3, #0]
  }
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC);
 8006528:	687b      	ldr	r3, [r7, #4]
 800652a:	681b      	ldr	r3, [r3, #0]
 800652c:	681b      	ldr	r3, [r3, #0]
 800652e:	f003 0304 	and.w	r3, r3, #4
 8006532:	2b00      	cmp	r3, #0
 8006534:	bf14      	ite	ne
 8006536:	2301      	movne	r3, #1
 8006538:	2300      	moveq	r3, #0
 800653a:	b2db      	uxtb	r3, r3
 800653c:	60fb      	str	r3, [r7, #12]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC);                               
 800653e:	687b      	ldr	r3, [r7, #4]
 8006540:	681b      	ldr	r3, [r3, #0]
 8006542:	685b      	ldr	r3, [r3, #4]
 8006544:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006548:	2b00      	cmp	r3, #0
 800654a:	bf14      	ite	ne
 800654c:	2301      	movne	r3, #1
 800654e:	2300      	moveq	r3, #0
 8006550:	b2db      	uxtb	r3, r3
 8006552:	60bb      	str	r3, [r7, #8]
  /* Check End of conversion flag for injected channels */
  if(tmp1 && tmp2)
 8006554:	68fb      	ldr	r3, [r7, #12]
 8006556:	2b00      	cmp	r3, #0
 8006558:	d041      	beq.n	80065de <HAL_ADC_IRQHandler+0x1ae>
 800655a:	68bb      	ldr	r3, [r7, #8]
 800655c:	2b00      	cmp	r3, #0
 800655e:	d03e      	beq.n	80065de <HAL_ADC_IRQHandler+0x1ae>
  {
    /* Check if a regular conversion is ready */
    if(hadc->State == HAL_ADC_STATE_EOC_REG)
 8006560:	687b      	ldr	r3, [r7, #4]
 8006562:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8006566:	b2db      	uxtb	r3, r3
 8006568:	2b15      	cmp	r3, #21
 800656a:	d104      	bne.n	8006576 <HAL_ADC_IRQHandler+0x146>
    {
      /* Change ADC state */
      hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
 800656c:	687b      	ldr	r3, [r7, #4]
 800656e:	2235      	movs	r2, #53	; 0x35
 8006570:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8006574:	e003      	b.n	800657e <HAL_ADC_IRQHandler+0x14e>
    }
    else
    {
      /* Change ADC state */
      hadc->State = HAL_ADC_STATE_EOC_INJ;
 8006576:	687b      	ldr	r3, [r7, #4]
 8006578:	2225      	movs	r2, #37	; 0x25
 800657a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    }
    
    tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
 800657e:	687b      	ldr	r3, [r7, #4]
 8006580:	681b      	ldr	r3, [r3, #0]
 8006582:	685b      	ldr	r3, [r3, #4]
 8006584:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8006588:	2b00      	cmp	r3, #0
 800658a:	bf0c      	ite	eq
 800658c:	2301      	moveq	r3, #1
 800658e:	2300      	movne	r3, #0
 8006590:	b2db      	uxtb	r3, r3
 8006592:	60fb      	str	r3, [r7, #12]
    tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
 8006594:	687b      	ldr	r3, [r7, #4]
 8006596:	681b      	ldr	r3, [r3, #0]
 8006598:	689b      	ldr	r3, [r3, #8]
 800659a:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 800659e:	2b00      	cmp	r3, #0
 80065a0:	bf0c      	ite	eq
 80065a2:	2301      	moveq	r3, #1
 80065a4:	2300      	movne	r3, #0
 80065a6:	b2db      	uxtb	r3, r3
 80065a8:	60bb      	str	r3, [r7, #8]
    if(((hadc->Init.ContinuousConvMode == DISABLE) || tmp1) && tmp2)
 80065aa:	687b      	ldr	r3, [r7, #4]
 80065ac:	699b      	ldr	r3, [r3, #24]
 80065ae:	2b00      	cmp	r3, #0
 80065b0:	d002      	beq.n	80065b8 <HAL_ADC_IRQHandler+0x188>
 80065b2:	68fb      	ldr	r3, [r7, #12]
 80065b4:	2b00      	cmp	r3, #0
 80065b6:	d00a      	beq.n	80065ce <HAL_ADC_IRQHandler+0x19e>
 80065b8:	68bb      	ldr	r3, [r7, #8]
 80065ba:	2b00      	cmp	r3, #0
 80065bc:	d007      	beq.n	80065ce <HAL_ADC_IRQHandler+0x19e>
    {
      /* DISABLE the ADC end of conversion interrupt for injected group */
      __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
 80065be:	687b      	ldr	r3, [r7, #4]
 80065c0:	681b      	ldr	r3, [r3, #0]
 80065c2:	687a      	ldr	r2, [r7, #4]
 80065c4:	6812      	ldr	r2, [r2, #0]
 80065c6:	6852      	ldr	r2, [r2, #4]
 80065c8:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80065cc:	605a      	str	r2, [r3, #4]
    }
    
    /* Conversion complete callback */ 
    HAL_ADCEx_InjectedConvCpltCallback(hadc);
 80065ce:	6878      	ldr	r0, [r7, #4]
 80065d0:	f00c f99e 	bl	8012910 <HAL_ADCEx_InjectedConvCpltCallback>
    
   /* Clear the ADCx flag for injected end of conversion */
    __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_JEOC);
 80065d4:	687b      	ldr	r3, [r7, #4]
 80065d6:	681b      	ldr	r3, [r3, #0]
 80065d8:	f06f 0204 	mvn.w	r2, #4
 80065dc:	601a      	str	r2, [r3, #0]
  }
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD);
 80065de:	687b      	ldr	r3, [r7, #4]
 80065e0:	681b      	ldr	r3, [r3, #0]
 80065e2:	681b      	ldr	r3, [r3, #0]
 80065e4:	f003 0301 	and.w	r3, r3, #1
 80065e8:	2b00      	cmp	r3, #0
 80065ea:	bf14      	ite	ne
 80065ec:	2301      	movne	r3, #1
 80065ee:	2300      	moveq	r3, #0
 80065f0:	b2db      	uxtb	r3, r3
 80065f2:	60fb      	str	r3, [r7, #12]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD);                          
 80065f4:	687b      	ldr	r3, [r7, #4]
 80065f6:	681b      	ldr	r3, [r3, #0]
 80065f8:	685b      	ldr	r3, [r3, #4]
 80065fa:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80065fe:	2b00      	cmp	r3, #0
 8006600:	bf14      	ite	ne
 8006602:	2301      	movne	r3, #1
 8006604:	2300      	moveq	r3, #0
 8006606:	b2db      	uxtb	r3, r3
 8006608:	60bb      	str	r3, [r7, #8]
  /* Check Analog watchdog flag */
  if(tmp1 && tmp2)
 800660a:	68fb      	ldr	r3, [r7, #12]
 800660c:	2b00      	cmp	r3, #0
 800660e:	d00e      	beq.n	800662e <HAL_ADC_IRQHandler+0x1fe>
 8006610:	68bb      	ldr	r3, [r7, #8]
 8006612:	2b00      	cmp	r3, #0
 8006614:	d00b      	beq.n	800662e <HAL_ADC_IRQHandler+0x1fe>
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_AWD;
 8006616:	687b      	ldr	r3, [r7, #4]
 8006618:	2206      	movs	r2, #6
 800661a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
      
    /* Clear the ADCx's Analog watchdog flag */
    __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_AWD);
 800661e:	687b      	ldr	r3, [r7, #4]
 8006620:	681b      	ldr	r3, [r3, #0]
 8006622:	f06f 0201 	mvn.w	r2, #1
 8006626:	601a      	str	r2, [r3, #0]
    
    /* Level out of window callback */ 
    HAL_ADC_LevelOutOfWindowCallback(hadc);
 8006628:	6878      	ldr	r0, [r7, #4]
 800662a:	f000 f849 	bl	80066c0 <HAL_ADC_LevelOutOfWindowCallback>
  }
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_OVR);
 800662e:	687b      	ldr	r3, [r7, #4]
 8006630:	681b      	ldr	r3, [r3, #0]
 8006632:	681b      	ldr	r3, [r3, #0]
 8006634:	f003 0320 	and.w	r3, r3, #32
 8006638:	2b00      	cmp	r3, #0
 800663a:	bf14      	ite	ne
 800663c:	2301      	movne	r3, #1
 800663e:	2300      	moveq	r3, #0
 8006640:	b2db      	uxtb	r3, r3
 8006642:	60fb      	str	r3, [r7, #12]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_OVR);
 8006644:	687b      	ldr	r3, [r7, #4]
 8006646:	681b      	ldr	r3, [r3, #0]
 8006648:	685b      	ldr	r3, [r3, #4]
 800664a:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 800664e:	2b00      	cmp	r3, #0
 8006650:	bf14      	ite	ne
 8006652:	2301      	movne	r3, #1
 8006654:	2300      	moveq	r3, #0
 8006656:	b2db      	uxtb	r3, r3
 8006658:	60bb      	str	r3, [r7, #8]
  /* Check Overrun flag */
  if(tmp1 && tmp2)
 800665a:	68fb      	ldr	r3, [r7, #12]
 800665c:	2b00      	cmp	r3, #0
 800665e:	d014      	beq.n	800668a <HAL_ADC_IRQHandler+0x25a>
 8006660:	68bb      	ldr	r3, [r7, #8]
 8006662:	2b00      	cmp	r3, #0
 8006664:	d011      	beq.n	800668a <HAL_ADC_IRQHandler+0x25a>
  {
    /* Change ADC state to overrun state */
    hadc->State = HAL_ADC_STATE_ERROR;
 8006666:	687b      	ldr	r3, [r7, #4]
 8006668:	2204      	movs	r2, #4
 800666a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    
    /* Set ADC error code to overrun */
    hadc->ErrorCode |= HAL_ADC_ERROR_OVR;
 800666e:	687b      	ldr	r3, [r7, #4]
 8006670:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006672:	f043 0201 	orr.w	r2, r3, #1
 8006676:	687b      	ldr	r3, [r7, #4]
 8006678:	641a      	str	r2, [r3, #64]	; 0x40
    
    /* Clear the Overrun flag */
    __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_OVR);
 800667a:	687b      	ldr	r3, [r7, #4]
 800667c:	681b      	ldr	r3, [r3, #0]
 800667e:	f06f 0220 	mvn.w	r2, #32
 8006682:	601a      	str	r2, [r3, #0]
    
    /* Error callback */ 
    HAL_ADC_ErrorCallback(hadc);
 8006684:	6878      	ldr	r0, [r7, #4]
 8006686:	f000 f825 	bl	80066d4 <HAL_ADC_ErrorCallback>
  }
}
 800668a:	3710      	adds	r7, #16
 800668c:	46bd      	mov	sp, r7
 800668e:	bd80      	pop	{r7, pc}

08006690 <HAL_ADC_GetValue>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval Converted value
  */
uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc)
{       
 8006690:	b480      	push	{r7}
 8006692:	b083      	sub	sp, #12
 8006694:	af00      	add	r7, sp, #0
 8006696:	6078      	str	r0, [r7, #4]
  /* Return the selected ADC converted value */ 
  return hadc->Instance->DR;
 8006698:	687b      	ldr	r3, [r7, #4]
 800669a:	681b      	ldr	r3, [r3, #0]
 800669c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
 800669e:	4618      	mov	r0, r3
 80066a0:	370c      	adds	r7, #12
 80066a2:	46bd      	mov	sp, r7
 80066a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80066a8:	4770      	bx	lr
 80066aa:	bf00      	nop

080066ac <HAL_ADC_ConvCpltCallback>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */
__weak void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
{
 80066ac:	b480      	push	{r7}
 80066ae:	b083      	sub	sp, #12
 80066b0:	af00      	add	r7, sp, #0
 80066b2:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_ConvCpltCallback could be implemented in the user file
   */
}
 80066b4:	370c      	adds	r7, #12
 80066b6:	46bd      	mov	sp, r7
 80066b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80066bc:	4770      	bx	lr
 80066be:	bf00      	nop

080066c0 <HAL_ADC_LevelOutOfWindowCallback>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */
__weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc)
{
 80066c0:	b480      	push	{r7}
 80066c2:	b083      	sub	sp, #12
 80066c4:	af00      	add	r7, sp, #0
 80066c6:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_LevelOoutOfWindowCallback could be implemented in the user file
   */
}
 80066c8:	370c      	adds	r7, #12
 80066ca:	46bd      	mov	sp, r7
 80066cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80066d0:	4770      	bx	lr
 80066d2:	bf00      	nop

080066d4 <HAL_ADC_ErrorCallback>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */
__weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
{
 80066d4:	b480      	push	{r7}
 80066d6:	b083      	sub	sp, #12
 80066d8:	af00      	add	r7, sp, #0
 80066da:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_ErrorCallback could be implemented in the user file
   */
}
 80066dc:	370c      	adds	r7, #12
 80066de:	46bd      	mov	sp, r7
 80066e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80066e4:	4770      	bx	lr
 80066e6:	bf00      	nop

080066e8 <HAL_ADC_ConfigChannel>:
  *         the configuration information for the specified ADC.
  * @param  sConfig: ADC configuration structure. 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{
 80066e8:	b490      	push	{r4, r7}
 80066ea:	b084      	sub	sp, #16
 80066ec:	af00      	add	r7, sp, #0
 80066ee:	6078      	str	r0, [r7, #4]
 80066f0:	6039      	str	r1, [r7, #0]
  __IO uint32_t counter = 0;
 80066f2:	2300      	movs	r3, #0
 80066f4:	60fb      	str	r3, [r7, #12]
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 80066f6:	687b      	ldr	r3, [r7, #4]
 80066f8:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80066fc:	2b01      	cmp	r3, #1
 80066fe:	d101      	bne.n	8006704 <HAL_ADC_ConfigChannel+0x1c>
 8006700:	2302      	movs	r3, #2
 8006702:	e105      	b.n	8006910 <HAL_ADC_ConfigChannel+0x228>
 8006704:	687b      	ldr	r3, [r7, #4]
 8006706:	2201      	movs	r2, #1
 8006708:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (sConfig->Channel > ADC_CHANNEL_9)
 800670c:	683b      	ldr	r3, [r7, #0]
 800670e:	681b      	ldr	r3, [r3, #0]
 8006710:	2b09      	cmp	r3, #9
 8006712:	d926      	bls.n	8006762 <HAL_ADC_ConfigChannel+0x7a>
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 8006714:	687b      	ldr	r3, [r7, #4]
 8006716:	681a      	ldr	r2, [r3, #0]
 8006718:	687b      	ldr	r3, [r7, #4]
 800671a:	681b      	ldr	r3, [r3, #0]
 800671c:	68d9      	ldr	r1, [r3, #12]
 800671e:	683b      	ldr	r3, [r7, #0]
 8006720:	681b      	ldr	r3, [r3, #0]
 8006722:	b29b      	uxth	r3, r3
 8006724:	4618      	mov	r0, r3
 8006726:	4603      	mov	r3, r0
 8006728:	005b      	lsls	r3, r3, #1
 800672a:	4403      	add	r3, r0
 800672c:	3b1e      	subs	r3, #30
 800672e:	4618      	mov	r0, r3
 8006730:	2307      	movs	r3, #7
 8006732:	4083      	lsls	r3, r0
 8006734:	43db      	mvns	r3, r3
 8006736:	400b      	ands	r3, r1
 8006738:	60d3      	str	r3, [r2, #12]
    
    /* Set the new sample time */
    hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
 800673a:	687b      	ldr	r3, [r7, #4]
 800673c:	681a      	ldr	r2, [r3, #0]
 800673e:	687b      	ldr	r3, [r7, #4]
 8006740:	681b      	ldr	r3, [r3, #0]
 8006742:	68d9      	ldr	r1, [r3, #12]
 8006744:	683b      	ldr	r3, [r7, #0]
 8006746:	6898      	ldr	r0, [r3, #8]
 8006748:	683b      	ldr	r3, [r7, #0]
 800674a:	681b      	ldr	r3, [r3, #0]
 800674c:	b29b      	uxth	r3, r3
 800674e:	461c      	mov	r4, r3
 8006750:	4623      	mov	r3, r4
 8006752:	005b      	lsls	r3, r3, #1
 8006754:	4423      	add	r3, r4
 8006756:	3b1e      	subs	r3, #30
 8006758:	fa00 f303 	lsl.w	r3, r0, r3
 800675c:	430b      	orrs	r3, r1
 800675e:	60d3      	str	r3, [r2, #12]
 8006760:	e023      	b.n	80067aa <HAL_ADC_ConfigChannel+0xc2>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
 8006762:	687b      	ldr	r3, [r7, #4]
 8006764:	681a      	ldr	r2, [r3, #0]
 8006766:	687b      	ldr	r3, [r7, #4]
 8006768:	681b      	ldr	r3, [r3, #0]
 800676a:	6919      	ldr	r1, [r3, #16]
 800676c:	683b      	ldr	r3, [r7, #0]
 800676e:	681b      	ldr	r3, [r3, #0]
 8006770:	b29b      	uxth	r3, r3
 8006772:	4618      	mov	r0, r3
 8006774:	4603      	mov	r3, r0
 8006776:	005b      	lsls	r3, r3, #1
 8006778:	4403      	add	r3, r0
 800677a:	4618      	mov	r0, r3
 800677c:	2307      	movs	r3, #7
 800677e:	4083      	lsls	r3, r0
 8006780:	43db      	mvns	r3, r3
 8006782:	400b      	ands	r3, r1
 8006784:	6113      	str	r3, [r2, #16]
    
    /* Set the new sample time */
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
 8006786:	687b      	ldr	r3, [r7, #4]
 8006788:	681a      	ldr	r2, [r3, #0]
 800678a:	687b      	ldr	r3, [r7, #4]
 800678c:	681b      	ldr	r3, [r3, #0]
 800678e:	6919      	ldr	r1, [r3, #16]
 8006790:	683b      	ldr	r3, [r7, #0]
 8006792:	6898      	ldr	r0, [r3, #8]
 8006794:	683b      	ldr	r3, [r7, #0]
 8006796:	681b      	ldr	r3, [r3, #0]
 8006798:	b29b      	uxth	r3, r3
 800679a:	461c      	mov	r4, r3
 800679c:	4623      	mov	r3, r4
 800679e:	005b      	lsls	r3, r3, #1
 80067a0:	4423      	add	r3, r4
 80067a2:	fa00 f303 	lsl.w	r3, r0, r3
 80067a6:	430b      	orrs	r3, r1
 80067a8:	6113      	str	r3, [r2, #16]
  }
  
  /* For Rank 1 to 6 */
  if (sConfig->Rank < 7)
 80067aa:	683b      	ldr	r3, [r7, #0]
 80067ac:	685b      	ldr	r3, [r3, #4]
 80067ae:	2b06      	cmp	r3, #6
 80067b0:	d824      	bhi.n	80067fc <HAL_ADC_ConfigChannel+0x114>
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 80067b2:	687b      	ldr	r3, [r7, #4]
 80067b4:	6819      	ldr	r1, [r3, #0]
 80067b6:	687b      	ldr	r3, [r7, #4]
 80067b8:	681b      	ldr	r3, [r3, #0]
 80067ba:	6b58      	ldr	r0, [r3, #52]	; 0x34
 80067bc:	683b      	ldr	r3, [r7, #0]
 80067be:	685a      	ldr	r2, [r3, #4]
 80067c0:	4613      	mov	r3, r2
 80067c2:	009b      	lsls	r3, r3, #2
 80067c4:	4413      	add	r3, r2
 80067c6:	3b05      	subs	r3, #5
 80067c8:	461a      	mov	r2, r3
 80067ca:	231f      	movs	r3, #31
 80067cc:	4093      	lsls	r3, r2
 80067ce:	43db      	mvns	r3, r3
 80067d0:	4003      	ands	r3, r0
 80067d2:	634b      	str	r3, [r1, #52]	; 0x34
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
 80067d4:	687b      	ldr	r3, [r7, #4]
 80067d6:	6819      	ldr	r1, [r3, #0]
 80067d8:	687b      	ldr	r3, [r7, #4]
 80067da:	681b      	ldr	r3, [r3, #0]
 80067dc:	6b58      	ldr	r0, [r3, #52]	; 0x34
 80067de:	683b      	ldr	r3, [r7, #0]
 80067e0:	681b      	ldr	r3, [r3, #0]
 80067e2:	b29b      	uxth	r3, r3
 80067e4:	461c      	mov	r4, r3
 80067e6:	683b      	ldr	r3, [r7, #0]
 80067e8:	685a      	ldr	r2, [r3, #4]
 80067ea:	4613      	mov	r3, r2
 80067ec:	009b      	lsls	r3, r3, #2
 80067ee:	4413      	add	r3, r2
 80067f0:	3b05      	subs	r3, #5
 80067f2:	fa04 f303 	lsl.w	r3, r4, r3
 80067f6:	4303      	orrs	r3, r0
 80067f8:	634b      	str	r3, [r1, #52]	; 0x34
 80067fa:	e04c      	b.n	8006896 <HAL_ADC_ConfigChannel+0x1ae>
  }
  /* For Rank 7 to 12 */
  else if (sConfig->Rank < 13)
 80067fc:	683b      	ldr	r3, [r7, #0]
 80067fe:	685b      	ldr	r3, [r3, #4]
 8006800:	2b0c      	cmp	r3, #12
 8006802:	d824      	bhi.n	800684e <HAL_ADC_ConfigChannel+0x166>
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
 8006804:	687b      	ldr	r3, [r7, #4]
 8006806:	6819      	ldr	r1, [r3, #0]
 8006808:	687b      	ldr	r3, [r7, #4]
 800680a:	681b      	ldr	r3, [r3, #0]
 800680c:	6b18      	ldr	r0, [r3, #48]	; 0x30
 800680e:	683b      	ldr	r3, [r7, #0]
 8006810:	685a      	ldr	r2, [r3, #4]
 8006812:	4613      	mov	r3, r2
 8006814:	009b      	lsls	r3, r3, #2
 8006816:	4413      	add	r3, r2
 8006818:	3b23      	subs	r3, #35	; 0x23
 800681a:	461a      	mov	r2, r3
 800681c:	231f      	movs	r3, #31
 800681e:	4093      	lsls	r3, r2
 8006820:	43db      	mvns	r3, r3
 8006822:	4003      	ands	r3, r0
 8006824:	630b      	str	r3, [r1, #48]	; 0x30
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 8006826:	687b      	ldr	r3, [r7, #4]
 8006828:	6819      	ldr	r1, [r3, #0]
 800682a:	687b      	ldr	r3, [r7, #4]
 800682c:	681b      	ldr	r3, [r3, #0]
 800682e:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8006830:	683b      	ldr	r3, [r7, #0]
 8006832:	681b      	ldr	r3, [r3, #0]
 8006834:	b29b      	uxth	r3, r3
 8006836:	461c      	mov	r4, r3
 8006838:	683b      	ldr	r3, [r7, #0]
 800683a:	685a      	ldr	r2, [r3, #4]
 800683c:	4613      	mov	r3, r2
 800683e:	009b      	lsls	r3, r3, #2
 8006840:	4413      	add	r3, r2
 8006842:	3b23      	subs	r3, #35	; 0x23
 8006844:	fa04 f303 	lsl.w	r3, r4, r3
 8006848:	4303      	orrs	r3, r0
 800684a:	630b      	str	r3, [r1, #48]	; 0x30
 800684c:	e023      	b.n	8006896 <HAL_ADC_ConfigChannel+0x1ae>
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
 800684e:	687b      	ldr	r3, [r7, #4]
 8006850:	6819      	ldr	r1, [r3, #0]
 8006852:	687b      	ldr	r3, [r7, #4]
 8006854:	681b      	ldr	r3, [r3, #0]
 8006856:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8006858:	683b      	ldr	r3, [r7, #0]
 800685a:	685a      	ldr	r2, [r3, #4]
 800685c:	4613      	mov	r3, r2
 800685e:	009b      	lsls	r3, r3, #2
 8006860:	4413      	add	r3, r2
 8006862:	3b41      	subs	r3, #65	; 0x41
 8006864:	461a      	mov	r2, r3
 8006866:	231f      	movs	r3, #31
 8006868:	4093      	lsls	r3, r2
 800686a:	43db      	mvns	r3, r3
 800686c:	4003      	ands	r3, r0
 800686e:	62cb      	str	r3, [r1, #44]	; 0x2c
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
 8006870:	687b      	ldr	r3, [r7, #4]
 8006872:	6819      	ldr	r1, [r3, #0]
 8006874:	687b      	ldr	r3, [r7, #4]
 8006876:	681b      	ldr	r3, [r3, #0]
 8006878:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 800687a:	683b      	ldr	r3, [r7, #0]
 800687c:	681b      	ldr	r3, [r3, #0]
 800687e:	b29b      	uxth	r3, r3
 8006880:	461c      	mov	r4, r3
 8006882:	683b      	ldr	r3, [r7, #0]
 8006884:	685a      	ldr	r2, [r3, #4]
 8006886:	4613      	mov	r3, r2
 8006888:	009b      	lsls	r3, r3, #2
 800688a:	4413      	add	r3, r2
 800688c:	3b41      	subs	r3, #65	; 0x41
 800688e:	fa04 f303 	lsl.w	r3, r4, r3
 8006892:	4303      	orrs	r3, r0
 8006894:	62cb      	str	r3, [r1, #44]	; 0x2c
  }
  
  /* if ADC1 Channel_18 is selected enable VBAT Channel */
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 8006896:	687b      	ldr	r3, [r7, #4]
 8006898:	681b      	ldr	r3, [r3, #0]
 800689a:	4a20      	ldr	r2, [pc, #128]	; (800691c <HAL_ADC_ConfigChannel+0x234>)
 800689c:	4293      	cmp	r3, r2
 800689e:	d109      	bne.n	80068b4 <HAL_ADC_ConfigChannel+0x1cc>
 80068a0:	683b      	ldr	r3, [r7, #0]
 80068a2:	681b      	ldr	r3, [r3, #0]
 80068a4:	2b12      	cmp	r3, #18
 80068a6:	d105      	bne.n	80068b4 <HAL_ADC_ConfigChannel+0x1cc>
  {
    /* Enable the VBAT channel*/
    ADC->CCR |= ADC_CCR_VBATE;
 80068a8:	4a1d      	ldr	r2, [pc, #116]	; (8006920 <HAL_ADC_ConfigChannel+0x238>)
 80068aa:	4b1d      	ldr	r3, [pc, #116]	; (8006920 <HAL_ADC_ConfigChannel+0x238>)
 80068ac:	685b      	ldr	r3, [r3, #4]
 80068ae:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80068b2:	6053      	str	r3, [r2, #4]
  }
  
  /* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
 80068b4:	687b      	ldr	r3, [r7, #4]
 80068b6:	681b      	ldr	r3, [r3, #0]
 80068b8:	4a18      	ldr	r2, [pc, #96]	; (800691c <HAL_ADC_ConfigChannel+0x234>)
 80068ba:	4293      	cmp	r3, r2
 80068bc:	d123      	bne.n	8006906 <HAL_ADC_ConfigChannel+0x21e>
 80068be:	683b      	ldr	r3, [r7, #0]
 80068c0:	681b      	ldr	r3, [r3, #0]
 80068c2:	2b10      	cmp	r3, #16
 80068c4:	d003      	beq.n	80068ce <HAL_ADC_ConfigChannel+0x1e6>
 80068c6:	683b      	ldr	r3, [r7, #0]
 80068c8:	681b      	ldr	r3, [r3, #0]
 80068ca:	2b11      	cmp	r3, #17
 80068cc:	d11b      	bne.n	8006906 <HAL_ADC_ConfigChannel+0x21e>
  {
    /* Enable the TSVREFE channel*/
    ADC->CCR |= ADC_CCR_TSVREFE;
 80068ce:	4a14      	ldr	r2, [pc, #80]	; (8006920 <HAL_ADC_ConfigChannel+0x238>)
 80068d0:	4b13      	ldr	r3, [pc, #76]	; (8006920 <HAL_ADC_ConfigChannel+0x238>)
 80068d2:	685b      	ldr	r3, [r3, #4]
 80068d4:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80068d8:	6053      	str	r3, [r2, #4]

    if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
 80068da:	683b      	ldr	r3, [r7, #0]
 80068dc:	681b      	ldr	r3, [r3, #0]
 80068de:	2b10      	cmp	r3, #16
 80068e0:	d111      	bne.n	8006906 <HAL_ADC_ConfigChannel+0x21e>
    {
      /* Delay for temperature sensor stabilization time */
      /* Compute number of CPU cycles to wait for */
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
 80068e2:	4b10      	ldr	r3, [pc, #64]	; (8006924 <HAL_ADC_ConfigChannel+0x23c>)
 80068e4:	681b      	ldr	r3, [r3, #0]
 80068e6:	4a10      	ldr	r2, [pc, #64]	; (8006928 <HAL_ADC_ConfigChannel+0x240>)
 80068e8:	fba2 2303 	umull	r2, r3, r2, r3
 80068ec:	0c9a      	lsrs	r2, r3, #18
 80068ee:	4613      	mov	r3, r2
 80068f0:	009b      	lsls	r3, r3, #2
 80068f2:	4413      	add	r3, r2
 80068f4:	005b      	lsls	r3, r3, #1
 80068f6:	60fb      	str	r3, [r7, #12]
      while(counter != 0)
 80068f8:	e002      	b.n	8006900 <HAL_ADC_ConfigChannel+0x218>
      {
        counter--;
 80068fa:	68fb      	ldr	r3, [r7, #12]
 80068fc:	3b01      	subs	r3, #1
 80068fe:	60fb      	str	r3, [r7, #12]
    if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
    {
      /* Delay for temperature sensor stabilization time */
      /* Compute number of CPU cycles to wait for */
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
      while(counter != 0)
 8006900:	68fb      	ldr	r3, [r7, #12]
 8006902:	2b00      	cmp	r3, #0
 8006904:	d1f9      	bne.n	80068fa <HAL_ADC_ConfigChannel+0x212>
      }
    }
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8006906:	687b      	ldr	r3, [r7, #4]
 8006908:	2200      	movs	r2, #0
 800690a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 800690e:	2300      	movs	r3, #0
}
 8006910:	4618      	mov	r0, r3
 8006912:	3710      	adds	r7, #16
 8006914:	46bd      	mov	sp, r7
 8006916:	bc90      	pop	{r4, r7}
 8006918:	4770      	bx	lr
 800691a:	bf00      	nop
 800691c:	40012000 	.word	0x40012000
 8006920:	40012300 	.word	0x40012300
 8006924:	20010014 	.word	0x20010014
 8006928:	431bde83 	.word	0x431bde83

0800692c <ADC_Init>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval None
  */
static void ADC_Init(ADC_HandleTypeDef* hadc)
{
 800692c:	b480      	push	{r7}
 800692e:	b085      	sub	sp, #20
 8006930:	af00      	add	r7, sp, #0
 8006932:	6078      	str	r0, [r7, #4]
  /* Set ADC parameters */
  /* Set the ADC clock prescaler */
  ADC->CCR &= ~(ADC_CCR_ADCPRE);
 8006934:	4a7c      	ldr	r2, [pc, #496]	; (8006b28 <ADC_Init+0x1fc>)
 8006936:	4b7c      	ldr	r3, [pc, #496]	; (8006b28 <ADC_Init+0x1fc>)
 8006938:	685b      	ldr	r3, [r3, #4]
 800693a:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 800693e:	6053      	str	r3, [r2, #4]
  ADC->CCR |=  hadc->Init.ClockPrescaler;
 8006940:	4979      	ldr	r1, [pc, #484]	; (8006b28 <ADC_Init+0x1fc>)
 8006942:	4b79      	ldr	r3, [pc, #484]	; (8006b28 <ADC_Init+0x1fc>)
 8006944:	685a      	ldr	r2, [r3, #4]
 8006946:	687b      	ldr	r3, [r7, #4]
 8006948:	685b      	ldr	r3, [r3, #4]
 800694a:	4313      	orrs	r3, r2
 800694c:	604b      	str	r3, [r1, #4]
  
  /* Set ADC scan mode */
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 800694e:	687b      	ldr	r3, [r7, #4]
 8006950:	681b      	ldr	r3, [r3, #0]
 8006952:	687a      	ldr	r2, [r7, #4]
 8006954:	6812      	ldr	r2, [r2, #0]
 8006956:	6852      	ldr	r2, [r2, #4]
 8006958:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800695c:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 800695e:	687b      	ldr	r3, [r7, #4]
 8006960:	681b      	ldr	r3, [r3, #0]
 8006962:	687a      	ldr	r2, [r7, #4]
 8006964:	6812      	ldr	r2, [r2, #0]
 8006966:	6851      	ldr	r1, [r2, #4]
 8006968:	687a      	ldr	r2, [r7, #4]
 800696a:	6912      	ldr	r2, [r2, #16]
 800696c:	0212      	lsls	r2, r2, #8
 800696e:	430a      	orrs	r2, r1
 8006970:	605a      	str	r2, [r3, #4]
  
  /* Set ADC resolution */
  hadc->Instance->CR1 &= ~(ADC_CR1_RES);
 8006972:	687b      	ldr	r3, [r7, #4]
 8006974:	681b      	ldr	r3, [r3, #0]
 8006976:	687a      	ldr	r2, [r7, #4]
 8006978:	6812      	ldr	r2, [r2, #0]
 800697a:	6852      	ldr	r2, [r2, #4]
 800697c:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 8006980:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 8006982:	687b      	ldr	r3, [r7, #4]
 8006984:	681b      	ldr	r3, [r3, #0]
 8006986:	687a      	ldr	r2, [r7, #4]
 8006988:	6812      	ldr	r2, [r2, #0]
 800698a:	6851      	ldr	r1, [r2, #4]
 800698c:	687a      	ldr	r2, [r7, #4]
 800698e:	6892      	ldr	r2, [r2, #8]
 8006990:	430a      	orrs	r2, r1
 8006992:	605a      	str	r2, [r3, #4]
  
  /* Set ADC data alignment */
  hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
 8006994:	687b      	ldr	r3, [r7, #4]
 8006996:	681b      	ldr	r3, [r3, #0]
 8006998:	687a      	ldr	r2, [r7, #4]
 800699a:	6812      	ldr	r2, [r2, #0]
 800699c:	6892      	ldr	r2, [r2, #8]
 800699e:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80069a2:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 80069a4:	687b      	ldr	r3, [r7, #4]
 80069a6:	681b      	ldr	r3, [r3, #0]
 80069a8:	687a      	ldr	r2, [r7, #4]
 80069aa:	6812      	ldr	r2, [r2, #0]
 80069ac:	6891      	ldr	r1, [r2, #8]
 80069ae:	687a      	ldr	r2, [r7, #4]
 80069b0:	68d2      	ldr	r2, [r2, #12]
 80069b2:	430a      	orrs	r2, r1
 80069b4:	609a      	str	r2, [r3, #8]
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 80069b6:	687b      	ldr	r3, [r7, #4]
 80069b8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80069ba:	4a5c      	ldr	r2, [pc, #368]	; (8006b2c <ADC_Init+0x200>)
 80069bc:	4293      	cmp	r3, r2
 80069be:	d022      	beq.n	8006a06 <ADC_Init+0xda>
  {
    /* Select external trigger to start conversion */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 80069c0:	687b      	ldr	r3, [r7, #4]
 80069c2:	681b      	ldr	r3, [r3, #0]
 80069c4:	687a      	ldr	r2, [r7, #4]
 80069c6:	6812      	ldr	r2, [r2, #0]
 80069c8:	6892      	ldr	r2, [r2, #8]
 80069ca:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 80069ce:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
 80069d0:	687b      	ldr	r3, [r7, #4]
 80069d2:	681b      	ldr	r3, [r3, #0]
 80069d4:	687a      	ldr	r2, [r7, #4]
 80069d6:	6812      	ldr	r2, [r2, #0]
 80069d8:	6891      	ldr	r1, [r2, #8]
 80069da:	687a      	ldr	r2, [r7, #4]
 80069dc:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80069de:	430a      	orrs	r2, r1
 80069e0:	609a      	str	r2, [r3, #8]
    
    /* Select external trigger polarity */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 80069e2:	687b      	ldr	r3, [r7, #4]
 80069e4:	681b      	ldr	r3, [r3, #0]
 80069e6:	687a      	ldr	r2, [r7, #4]
 80069e8:	6812      	ldr	r2, [r2, #0]
 80069ea:	6892      	ldr	r2, [r2, #8]
 80069ec:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 80069f0:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
 80069f2:	687b      	ldr	r3, [r7, #4]
 80069f4:	681b      	ldr	r3, [r3, #0]
 80069f6:	687a      	ldr	r2, [r7, #4]
 80069f8:	6812      	ldr	r2, [r2, #0]
 80069fa:	6891      	ldr	r1, [r2, #8]
 80069fc:	687a      	ldr	r2, [r7, #4]
 80069fe:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8006a00:	430a      	orrs	r2, r1
 8006a02:	609a      	str	r2, [r3, #8]
 8006a04:	e00f      	b.n	8006a26 <ADC_Init+0xfa>
  }
  else
  {
    /* Reset the external trigger */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 8006a06:	687b      	ldr	r3, [r7, #4]
 8006a08:	681b      	ldr	r3, [r3, #0]
 8006a0a:	687a      	ldr	r2, [r7, #4]
 8006a0c:	6812      	ldr	r2, [r2, #0]
 8006a0e:	6892      	ldr	r2, [r2, #8]
 8006a10:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 8006a14:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 8006a16:	687b      	ldr	r3, [r7, #4]
 8006a18:	681b      	ldr	r3, [r3, #0]
 8006a1a:	687a      	ldr	r2, [r7, #4]
 8006a1c:	6812      	ldr	r2, [r2, #0]
 8006a1e:	6892      	ldr	r2, [r2, #8]
 8006a20:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 8006a24:	609a      	str	r2, [r3, #8]
  }
  
  /* Enable or disable ADC continuous conversion mode */
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 8006a26:	687b      	ldr	r3, [r7, #4]
 8006a28:	681b      	ldr	r3, [r3, #0]
 8006a2a:	687a      	ldr	r2, [r7, #4]
 8006a2c:	6812      	ldr	r2, [r2, #0]
 8006a2e:	6892      	ldr	r2, [r2, #8]
 8006a30:	f022 0202 	bic.w	r2, r2, #2
 8006a34:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode);
 8006a36:	687b      	ldr	r3, [r7, #4]
 8006a38:	681b      	ldr	r3, [r3, #0]
 8006a3a:	687a      	ldr	r2, [r7, #4]
 8006a3c:	6812      	ldr	r2, [r2, #0]
 8006a3e:	6891      	ldr	r1, [r2, #8]
 8006a40:	687a      	ldr	r2, [r7, #4]
 8006a42:	6992      	ldr	r2, [r2, #24]
 8006a44:	0052      	lsls	r2, r2, #1
 8006a46:	430a      	orrs	r2, r1
 8006a48:	609a      	str	r2, [r3, #8]
  
  if(hadc->Init.DiscontinuousConvMode != DISABLE)
 8006a4a:	687b      	ldr	r3, [r7, #4]
 8006a4c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006a4e:	2b00      	cmp	r3, #0
 8006a50:	d025      	beq.n	8006a9e <ADC_Init+0x172>
  {
    assert_param(IS_ADC_REGULAR_DISC_NUMBER(hadc->Init.NbrOfDiscConversion));
  
    /* Enable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 8006a52:	687b      	ldr	r3, [r7, #4]
 8006a54:	681b      	ldr	r3, [r3, #0]
 8006a56:	687a      	ldr	r2, [r7, #4]
 8006a58:	6812      	ldr	r2, [r2, #0]
 8006a5a:	6852      	ldr	r2, [r2, #4]
 8006a5c:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8006a60:	605a      	str	r2, [r3, #4]
    
    /* Set the number of channels to be converted in discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
 8006a62:	687b      	ldr	r3, [r7, #4]
 8006a64:	681b      	ldr	r3, [r3, #0]
 8006a66:	687a      	ldr	r2, [r7, #4]
 8006a68:	6812      	ldr	r2, [r2, #0]
 8006a6a:	6852      	ldr	r2, [r2, #4]
 8006a6c:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 8006a70:	605a      	str	r2, [r3, #4]
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 8006a72:	687b      	ldr	r3, [r7, #4]
 8006a74:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006a76:	1e5a      	subs	r2, r3, #1
 8006a78:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 8006a7c:	60fb      	str	r3, [r7, #12]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006a7e:	68fb      	ldr	r3, [r7, #12]
 8006a80:	fa93 f3a3 	rbit	r3, r3
 8006a84:	60bb      	str	r3, [r7, #8]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 8006a86:	68bb      	ldr	r3, [r7, #8]
 8006a88:	fab3 f383 	clz	r3, r3
 8006a8c:	409a      	lsls	r2, r3
 8006a8e:	687b      	ldr	r3, [r7, #4]
 8006a90:	681b      	ldr	r3, [r3, #0]
 8006a92:	6879      	ldr	r1, [r7, #4]
 8006a94:	6809      	ldr	r1, [r1, #0]
 8006a96:	6849      	ldr	r1, [r1, #4]
 8006a98:	430a      	orrs	r2, r1
 8006a9a:	605a      	str	r2, [r3, #4]
 8006a9c:	e007      	b.n	8006aae <ADC_Init+0x182>
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
 8006a9e:	687b      	ldr	r3, [r7, #4]
 8006aa0:	681b      	ldr	r3, [r3, #0]
 8006aa2:	687a      	ldr	r2, [r7, #4]
 8006aa4:	6812      	ldr	r2, [r2, #0]
 8006aa6:	6852      	ldr	r2, [r2, #4]
 8006aa8:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8006aac:	605a      	str	r2, [r3, #4]
  }
  
  /* Set ADC number of conversion */
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 8006aae:	687b      	ldr	r3, [r7, #4]
 8006ab0:	681b      	ldr	r3, [r3, #0]
 8006ab2:	687a      	ldr	r2, [r7, #4]
 8006ab4:	6812      	ldr	r2, [r2, #0]
 8006ab6:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8006ab8:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
 8006abc:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 8006abe:	687b      	ldr	r3, [r7, #4]
 8006ac0:	681b      	ldr	r3, [r3, #0]
 8006ac2:	687a      	ldr	r2, [r7, #4]
 8006ac4:	6812      	ldr	r2, [r2, #0]
 8006ac6:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8006ac8:	687a      	ldr	r2, [r7, #4]
 8006aca:	6a12      	ldr	r2, [r2, #32]
 8006acc:	3a01      	subs	r2, #1
 8006ace:	0512      	lsls	r2, r2, #20
 8006ad0:	430a      	orrs	r2, r1
 8006ad2:	62da      	str	r2, [r3, #44]	; 0x2c
  
  /* Enable or disable ADC DMA continuous request */
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
 8006ad4:	687b      	ldr	r3, [r7, #4]
 8006ad6:	681b      	ldr	r3, [r3, #0]
 8006ad8:	687a      	ldr	r2, [r7, #4]
 8006ada:	6812      	ldr	r2, [r2, #0]
 8006adc:	6892      	ldr	r2, [r2, #8]
 8006ade:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8006ae2:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq(hadc->Init.DMAContinuousRequests);
 8006ae4:	687b      	ldr	r3, [r7, #4]
 8006ae6:	681b      	ldr	r3, [r3, #0]
 8006ae8:	687a      	ldr	r2, [r7, #4]
 8006aea:	6812      	ldr	r2, [r2, #0]
 8006aec:	6891      	ldr	r1, [r2, #8]
 8006aee:	687a      	ldr	r2, [r7, #4]
 8006af0:	69d2      	ldr	r2, [r2, #28]
 8006af2:	0252      	lsls	r2, r2, #9
 8006af4:	430a      	orrs	r2, r1
 8006af6:	609a      	str	r2, [r3, #8]
  
  /* Enable or disable ADC end of conversion selection */
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
 8006af8:	687b      	ldr	r3, [r7, #4]
 8006afa:	681b      	ldr	r3, [r3, #0]
 8006afc:	687a      	ldr	r2, [r7, #4]
 8006afe:	6812      	ldr	r2, [r2, #0]
 8006b00:	6892      	ldr	r2, [r2, #8]
 8006b02:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8006b06:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 8006b08:	687b      	ldr	r3, [r7, #4]
 8006b0a:	681b      	ldr	r3, [r3, #0]
 8006b0c:	687a      	ldr	r2, [r7, #4]
 8006b0e:	6812      	ldr	r2, [r2, #0]
 8006b10:	6891      	ldr	r1, [r2, #8]
 8006b12:	687a      	ldr	r2, [r7, #4]
 8006b14:	6952      	ldr	r2, [r2, #20]
 8006b16:	0292      	lsls	r2, r2, #10
 8006b18:	430a      	orrs	r2, r1
 8006b1a:	609a      	str	r2, [r3, #8]
}
 8006b1c:	3714      	adds	r7, #20
 8006b1e:	46bd      	mov	sp, r7
 8006b20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006b24:	4770      	bx	lr
 8006b26:	bf00      	nop
 8006b28:	40012300 	.word	0x40012300
 8006b2c:	0f000001 	.word	0x0f000001

08006b30 <HAL_ADCEx_InjectedStart_IT>:
  *         the configuration information for the specified ADC.
  *
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedStart_IT(ADC_HandleTypeDef* hadc)
{
 8006b30:	b480      	push	{r7}
 8006b32:	b087      	sub	sp, #28
 8006b34:	af00      	add	r7, sp, #0
 8006b36:	6078      	str	r0, [r7, #4]
  __IO uint32_t counter = 0;
 8006b38:	2300      	movs	r3, #0
 8006b3a:	60fb      	str	r3, [r7, #12]
  uint32_t tmp1 = 0, tmp2 =0;
 8006b3c:	2300      	movs	r3, #0
 8006b3e:	617b      	str	r3, [r7, #20]
 8006b40:	2300      	movs	r3, #0
 8006b42:	613b      	str	r3, [r7, #16]
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8006b44:	687b      	ldr	r3, [r7, #4]
 8006b46:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8006b4a:	2b01      	cmp	r3, #1
 8006b4c:	d101      	bne.n	8006b52 <HAL_ADCEx_InjectedStart_IT+0x22>
 8006b4e:	2302      	movs	r3, #2
 8006b50:	e09e      	b.n	8006c90 <HAL_ADCEx_InjectedStart_IT+0x160>
 8006b52:	687b      	ldr	r3, [r7, #4]
 8006b54:	2201      	movs	r2, #1
 8006b56:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Check if a regular conversion is ongoing */
  if(hadc->State == HAL_ADC_STATE_BUSY_REG)
 8006b5a:	687b      	ldr	r3, [r7, #4]
 8006b5c:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8006b60:	b2db      	uxtb	r3, r3
 8006b62:	2b12      	cmp	r3, #18
 8006b64:	d104      	bne.n	8006b70 <HAL_ADCEx_InjectedStart_IT+0x40>
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_INJ_REG;  
 8006b66:	687b      	ldr	r3, [r7, #4]
 8006b68:	2232      	movs	r2, #50	; 0x32
 8006b6a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8006b6e:	e003      	b.n	8006b78 <HAL_ADCEx_InjectedStart_IT+0x48>
  }
  else
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_INJ;
 8006b70:	687b      	ldr	r3, [r7, #4]
 8006b72:	2222      	movs	r2, #34	; 0x22
 8006b74:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  }
  
  /* Set ADC error code to none */
  hadc->ErrorCode = HAL_ADC_ERROR_NONE;
 8006b78:	687b      	ldr	r3, [r7, #4]
 8006b7a:	2200      	movs	r2, #0
 8006b7c:	641a      	str	r2, [r3, #64]	; 0x40
  
  /* Check if ADC peripheral is disabled in order to enable it and wait during 
     Tstab time the ADC's stabilization */
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 8006b7e:	687b      	ldr	r3, [r7, #4]
 8006b80:	681b      	ldr	r3, [r3, #0]
 8006b82:	689b      	ldr	r3, [r3, #8]
 8006b84:	f003 0301 	and.w	r3, r3, #1
 8006b88:	2b00      	cmp	r3, #0
 8006b8a:	d118      	bne.n	8006bbe <HAL_ADCEx_InjectedStart_IT+0x8e>
  {  
    /* Enable the Peripheral */
    __HAL_ADC_ENABLE(hadc);
 8006b8c:	687b      	ldr	r3, [r7, #4]
 8006b8e:	681b      	ldr	r3, [r3, #0]
 8006b90:	687a      	ldr	r2, [r7, #4]
 8006b92:	6812      	ldr	r2, [r2, #0]
 8006b94:	6892      	ldr	r2, [r2, #8]
 8006b96:	f042 0201 	orr.w	r2, r2, #1
 8006b9a:	609a      	str	r2, [r3, #8]
    
    /* Delay for temperature sensor stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 8006b9c:	4b3f      	ldr	r3, [pc, #252]	; (8006c9c <HAL_ADCEx_InjectedStart_IT+0x16c>)
 8006b9e:	681b      	ldr	r3, [r3, #0]
 8006ba0:	4a3f      	ldr	r2, [pc, #252]	; (8006ca0 <HAL_ADCEx_InjectedStart_IT+0x170>)
 8006ba2:	fba2 2303 	umull	r2, r3, r2, r3
 8006ba6:	0c9a      	lsrs	r2, r3, #18
 8006ba8:	4613      	mov	r3, r2
 8006baa:	005b      	lsls	r3, r3, #1
 8006bac:	4413      	add	r3, r2
 8006bae:	60fb      	str	r3, [r7, #12]
    while(counter != 0)
 8006bb0:	e002      	b.n	8006bb8 <HAL_ADCEx_InjectedStart_IT+0x88>
    {
      counter--;
 8006bb2:	68fb      	ldr	r3, [r7, #12]
 8006bb4:	3b01      	subs	r3, #1
 8006bb6:	60fb      	str	r3, [r7, #12]
    __HAL_ADC_ENABLE(hadc);
    
    /* Delay for temperature sensor stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
    while(counter != 0)
 8006bb8:	68fb      	ldr	r3, [r7, #12]
 8006bba:	2b00      	cmp	r3, #0
 8006bbc:	d1f9      	bne.n	8006bb2 <HAL_ADCEx_InjectedStart_IT+0x82>
      counter--;
    }
  }
  
  /* Enable the ADC end of conversion interrupt for injected group */
  __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
 8006bbe:	687b      	ldr	r3, [r7, #4]
 8006bc0:	681b      	ldr	r3, [r3, #0]
 8006bc2:	687a      	ldr	r2, [r7, #4]
 8006bc4:	6812      	ldr	r2, [r2, #0]
 8006bc6:	6852      	ldr	r2, [r2, #4]
 8006bc8:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8006bcc:	605a      	str	r2, [r3, #4]
  
  /* Enable the ADC overrun interrupt */
  __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 8006bce:	687b      	ldr	r3, [r7, #4]
 8006bd0:	681b      	ldr	r3, [r3, #0]
 8006bd2:	687a      	ldr	r2, [r7, #4]
 8006bd4:	6812      	ldr	r2, [r2, #0]
 8006bd6:	6852      	ldr	r2, [r2, #4]
 8006bd8:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8006bdc:	605a      	str	r2, [r3, #4]
  
  /* Check if Multimode enabled */
  if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
 8006bde:	4b31      	ldr	r3, [pc, #196]	; (8006ca4 <HAL_ADCEx_InjectedStart_IT+0x174>)
 8006be0:	685b      	ldr	r3, [r3, #4]
 8006be2:	f003 031f 	and.w	r3, r3, #31
 8006be6:	2b00      	cmp	r3, #0
 8006be8:	d124      	bne.n	8006c34 <HAL_ADCEx_InjectedStart_IT+0x104>
  {
    tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
 8006bea:	687b      	ldr	r3, [r7, #4]
 8006bec:	681b      	ldr	r3, [r3, #0]
 8006bee:	689b      	ldr	r3, [r3, #8]
 8006bf0:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 8006bf4:	2b00      	cmp	r3, #0
 8006bf6:	bf0c      	ite	eq
 8006bf8:	2301      	moveq	r3, #1
 8006bfa:	2300      	movne	r3, #0
 8006bfc:	b2db      	uxtb	r3, r3
 8006bfe:	617b      	str	r3, [r7, #20]
    tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
 8006c00:	687b      	ldr	r3, [r7, #4]
 8006c02:	681b      	ldr	r3, [r3, #0]
 8006c04:	685b      	ldr	r3, [r3, #4]
 8006c06:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8006c0a:	2b00      	cmp	r3, #0
 8006c0c:	bf0c      	ite	eq
 8006c0e:	2301      	moveq	r3, #1
 8006c10:	2300      	movne	r3, #0
 8006c12:	b2db      	uxtb	r3, r3
 8006c14:	613b      	str	r3, [r7, #16]
    if(tmp1 && tmp2)
 8006c16:	697b      	ldr	r3, [r7, #20]
 8006c18:	2b00      	cmp	r3, #0
 8006c1a:	d034      	beq.n	8006c86 <HAL_ADCEx_InjectedStart_IT+0x156>
 8006c1c:	693b      	ldr	r3, [r7, #16]
 8006c1e:	2b00      	cmp	r3, #0
 8006c20:	d031      	beq.n	8006c86 <HAL_ADCEx_InjectedStart_IT+0x156>
    {
      /* Enable the selected ADC software conversion for injected group */
      hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
 8006c22:	687b      	ldr	r3, [r7, #4]
 8006c24:	681b      	ldr	r3, [r3, #0]
 8006c26:	687a      	ldr	r2, [r7, #4]
 8006c28:	6812      	ldr	r2, [r2, #0]
 8006c2a:	6892      	ldr	r2, [r2, #8]
 8006c2c:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8006c30:	609a      	str	r2, [r3, #8]
 8006c32:	e028      	b.n	8006c86 <HAL_ADCEx_InjectedStart_IT+0x156>
    }
  }
  else
  {
    tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
 8006c34:	687b      	ldr	r3, [r7, #4]
 8006c36:	681b      	ldr	r3, [r3, #0]
 8006c38:	689b      	ldr	r3, [r3, #8]
 8006c3a:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 8006c3e:	2b00      	cmp	r3, #0
 8006c40:	bf0c      	ite	eq
 8006c42:	2301      	moveq	r3, #1
 8006c44:	2300      	movne	r3, #0
 8006c46:	b2db      	uxtb	r3, r3
 8006c48:	617b      	str	r3, [r7, #20]
    tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
 8006c4a:	687b      	ldr	r3, [r7, #4]
 8006c4c:	681b      	ldr	r3, [r3, #0]
 8006c4e:	685b      	ldr	r3, [r3, #4]
 8006c50:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8006c54:	2b00      	cmp	r3, #0
 8006c56:	bf0c      	ite	eq
 8006c58:	2301      	moveq	r3, #1
 8006c5a:	2300      	movne	r3, #0
 8006c5c:	b2db      	uxtb	r3, r3
 8006c5e:	613b      	str	r3, [r7, #16]
    if((hadc->Instance == ADC1) && tmp1 && tmp2)  
 8006c60:	687b      	ldr	r3, [r7, #4]
 8006c62:	681b      	ldr	r3, [r3, #0]
 8006c64:	4a10      	ldr	r2, [pc, #64]	; (8006ca8 <HAL_ADCEx_InjectedStart_IT+0x178>)
 8006c66:	4293      	cmp	r3, r2
 8006c68:	d10d      	bne.n	8006c86 <HAL_ADCEx_InjectedStart_IT+0x156>
 8006c6a:	697b      	ldr	r3, [r7, #20]
 8006c6c:	2b00      	cmp	r3, #0
 8006c6e:	d00a      	beq.n	8006c86 <HAL_ADCEx_InjectedStart_IT+0x156>
 8006c70:	693b      	ldr	r3, [r7, #16]
 8006c72:	2b00      	cmp	r3, #0
 8006c74:	d007      	beq.n	8006c86 <HAL_ADCEx_InjectedStart_IT+0x156>
    {
      /* Enable the selected ADC software conversion for injected group */
      hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
 8006c76:	687b      	ldr	r3, [r7, #4]
 8006c78:	681b      	ldr	r3, [r3, #0]
 8006c7a:	687a      	ldr	r2, [r7, #4]
 8006c7c:	6812      	ldr	r2, [r2, #0]
 8006c7e:	6892      	ldr	r2, [r2, #8]
 8006c80:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8006c84:	609a      	str	r2, [r3, #8]
    }
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8006c86:	687b      	ldr	r3, [r7, #4]
 8006c88:	2200      	movs	r2, #0
 8006c8a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 8006c8e:	2300      	movs	r3, #0
}
 8006c90:	4618      	mov	r0, r3
 8006c92:	371c      	adds	r7, #28
 8006c94:	46bd      	mov	sp, r7
 8006c96:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006c9a:	4770      	bx	lr
 8006c9c:	20010014 	.word	0x20010014
 8006ca0:	431bde83 	.word	0x431bde83
 8006ca4:	40012300 	.word	0x40012300
 8006ca8:	40012000 	.word	0x40012000

08006cac <HAL_ADCEx_InjectedStop_IT>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedStop_IT(ADC_HandleTypeDef* hadc)
{
 8006cac:	b480      	push	{r7}
 8006cae:	b083      	sub	sp, #12
 8006cb0:	af00      	add	r7, sp, #0
 8006cb2:	6078      	str	r0, [r7, #4]
  /* Disable the ADC end of conversion interrupt for regular group */
  __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 8006cb4:	687b      	ldr	r3, [r7, #4]
 8006cb6:	681b      	ldr	r3, [r3, #0]
 8006cb8:	687a      	ldr	r2, [r7, #4]
 8006cba:	6812      	ldr	r2, [r2, #0]
 8006cbc:	6852      	ldr	r2, [r2, #4]
 8006cbe:	f022 0220 	bic.w	r2, r2, #32
 8006cc2:	605a      	str	r2, [r3, #4]
  
  /* Disable the ADC end of conversion interrupt for injected group */
  __HAL_ADC_DISABLE_IT(hadc, ADC_CR1_JEOCIE);
 8006cc4:	687b      	ldr	r3, [r7, #4]
 8006cc6:	681b      	ldr	r3, [r3, #0]
 8006cc8:	687a      	ldr	r2, [r7, #4]
 8006cca:	6812      	ldr	r2, [r2, #0]
 8006ccc:	6852      	ldr	r2, [r2, #4]
 8006cce:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8006cd2:	605a      	str	r2, [r3, #4]
  
  /* Enable the Peripheral */
  __HAL_ADC_DISABLE(hadc);
 8006cd4:	687b      	ldr	r3, [r7, #4]
 8006cd6:	681b      	ldr	r3, [r3, #0]
 8006cd8:	687a      	ldr	r2, [r7, #4]
 8006cda:	6812      	ldr	r2, [r2, #0]
 8006cdc:	6892      	ldr	r2, [r2, #8]
 8006cde:	f022 0201 	bic.w	r2, r2, #1
 8006ce2:	609a      	str	r2, [r3, #8]
  
  /* Change ADC state */
  hadc->State = HAL_ADC_STATE_READY;
 8006ce4:	687b      	ldr	r3, [r7, #4]
 8006ce6:	2201      	movs	r2, #1
 8006ce8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  
  /* Return function status */
  return HAL_OK;
 8006cec:	2300      	movs	r3, #0
}
 8006cee:	4618      	mov	r0, r3
 8006cf0:	370c      	adds	r7, #12
 8006cf2:	46bd      	mov	sp, r7
 8006cf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006cf8:	4770      	bx	lr
 8006cfa:	bf00      	nop

08006cfc <HAL_ADCEx_InjectedGetValue>:
  *            @arg ADC_INJECTED_RANK_3: Injected Channel3 selected
  *            @arg ADC_INJECTED_RANK_4: Injected Channel4 selected
  * @retval None
  */
uint32_t HAL_ADCEx_InjectedGetValue(ADC_HandleTypeDef* hadc, uint32_t InjectedRank)
{
 8006cfc:	b480      	push	{r7}
 8006cfe:	b085      	sub	sp, #20
 8006d00:	af00      	add	r7, sp, #0
 8006d02:	6078      	str	r0, [r7, #4]
 8006d04:	6039      	str	r1, [r7, #0]
  __IO uint32_t tmp = 0;
 8006d06:	2300      	movs	r3, #0
 8006d08:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_ADC_INJECTED_RANK(InjectedRank));
  
   /* Clear the ADCx's flag for injected end of conversion */
   __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_JEOC);
 8006d0a:	687b      	ldr	r3, [r7, #4]
 8006d0c:	681b      	ldr	r3, [r3, #0]
 8006d0e:	f06f 0204 	mvn.w	r2, #4
 8006d12:	601a      	str	r2, [r3, #0]
  
  /* Return the selected ADC converted value */ 
  switch(InjectedRank)
 8006d14:	683b      	ldr	r3, [r7, #0]
 8006d16:	3b01      	subs	r3, #1
 8006d18:	2b03      	cmp	r3, #3
 8006d1a:	d81f      	bhi.n	8006d5c <HAL_ADCEx_InjectedGetValue+0x60>
 8006d1c:	a201      	add	r2, pc, #4	; (adr r2, 8006d24 <HAL_ADCEx_InjectedGetValue+0x28>)
 8006d1e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006d22:	bf00      	nop
 8006d24:	08006d53 	.word	0x08006d53
 8006d28:	08006d49 	.word	0x08006d49
 8006d2c:	08006d3f 	.word	0x08006d3f
 8006d30:	08006d35 	.word	0x08006d35
  {  
    case ADC_INJECTED_RANK_4:
    {
      tmp =  hadc->Instance->JDR4;
 8006d34:	687b      	ldr	r3, [r7, #4]
 8006d36:	681b      	ldr	r3, [r3, #0]
 8006d38:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8006d3a:	60fb      	str	r3, [r7, #12]
    }  
    break;
 8006d3c:	e00f      	b.n	8006d5e <HAL_ADCEx_InjectedGetValue+0x62>
    case ADC_INJECTED_RANK_3: 
    {  
      tmp =  hadc->Instance->JDR3;
 8006d3e:	687b      	ldr	r3, [r7, #4]
 8006d40:	681b      	ldr	r3, [r3, #0]
 8006d42:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8006d44:	60fb      	str	r3, [r7, #12]
    }  
    break;
 8006d46:	e00a      	b.n	8006d5e <HAL_ADCEx_InjectedGetValue+0x62>
    case ADC_INJECTED_RANK_2: 
    {  
      tmp =  hadc->Instance->JDR2;
 8006d48:	687b      	ldr	r3, [r7, #4]
 8006d4a:	681b      	ldr	r3, [r3, #0]
 8006d4c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006d4e:	60fb      	str	r3, [r7, #12]
    }
    break;
 8006d50:	e005      	b.n	8006d5e <HAL_ADCEx_InjectedGetValue+0x62>
    case ADC_INJECTED_RANK_1:
    {
      tmp =  hadc->Instance->JDR1;
 8006d52:	687b      	ldr	r3, [r7, #4]
 8006d54:	681b      	ldr	r3, [r3, #0]
 8006d56:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006d58:	60fb      	str	r3, [r7, #12]
    }
    break;
 8006d5a:	e000      	b.n	8006d5e <HAL_ADCEx_InjectedGetValue+0x62>
    default:
    break;  
 8006d5c:	bf00      	nop
  }
  return tmp;
 8006d5e:	68fb      	ldr	r3, [r7, #12]
}
 8006d60:	4618      	mov	r0, r3
 8006d62:	3714      	adds	r7, #20
 8006d64:	46bd      	mov	sp, r7
 8006d66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006d6a:	4770      	bx	lr

08006d6c <HAL_ADCEx_InjectedConfigChannel>:
  *         the configuration information for the specified ADC.
  * @param  sConfigInjected: ADC configuration structure for injected channel. 
  * @retval None
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef* hadc, ADC_InjectionConfTypeDef* sConfigInjected)
{
 8006d6c:	b490      	push	{r4, r7}
 8006d6e:	b082      	sub	sp, #8
 8006d70:	af00      	add	r7, sp, #0
 8006d72:	6078      	str	r0, [r7, #4]
 8006d74:	6039      	str	r1, [r7, #0]
  tmp = ADC_GET_RESOLUTION(hadc);
  assert_param(IS_ADC_RANGE(tmp, sConfigInjected->InjectedOffset));
#endif /* USE_FULL_ASSERT  */

  /* Process locked */
  __HAL_LOCK(hadc);
 8006d76:	687b      	ldr	r3, [r7, #4]
 8006d78:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8006d7c:	2b01      	cmp	r3, #1
 8006d7e:	d101      	bne.n	8006d84 <HAL_ADCEx_InjectedConfigChannel+0x18>
 8006d80:	2302      	movs	r3, #2
 8006d82:	e15c      	b.n	800703e <HAL_ADCEx_InjectedConfigChannel+0x2d2>
 8006d84:	687b      	ldr	r3, [r7, #4]
 8006d86:	2201      	movs	r2, #1
 8006d88:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (sConfigInjected->InjectedChannel > ADC_CHANNEL_9)
 8006d8c:	683b      	ldr	r3, [r7, #0]
 8006d8e:	681b      	ldr	r3, [r3, #0]
 8006d90:	2b09      	cmp	r3, #9
 8006d92:	d926      	bls.n	8006de2 <HAL_ADCEx_InjectedConfigChannel+0x76>
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfigInjected->InjectedChannel);
 8006d94:	687b      	ldr	r3, [r7, #4]
 8006d96:	681a      	ldr	r2, [r3, #0]
 8006d98:	687b      	ldr	r3, [r7, #4]
 8006d9a:	681b      	ldr	r3, [r3, #0]
 8006d9c:	68d9      	ldr	r1, [r3, #12]
 8006d9e:	683b      	ldr	r3, [r7, #0]
 8006da0:	681b      	ldr	r3, [r3, #0]
 8006da2:	b29b      	uxth	r3, r3
 8006da4:	4618      	mov	r0, r3
 8006da6:	4603      	mov	r3, r0
 8006da8:	005b      	lsls	r3, r3, #1
 8006daa:	4403      	add	r3, r0
 8006dac:	3b1e      	subs	r3, #30
 8006dae:	4618      	mov	r0, r3
 8006db0:	2307      	movs	r3, #7
 8006db2:	4083      	lsls	r3, r0
 8006db4:	43db      	mvns	r3, r3
 8006db6:	400b      	ands	r3, r1
 8006db8:	60d3      	str	r3, [r2, #12]
    
    /* Set the new sample time */
    hadc->Instance->SMPR1 |= ADC_SMPR1(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel);
 8006dba:	687b      	ldr	r3, [r7, #4]
 8006dbc:	681a      	ldr	r2, [r3, #0]
 8006dbe:	687b      	ldr	r3, [r7, #4]
 8006dc0:	681b      	ldr	r3, [r3, #0]
 8006dc2:	68d9      	ldr	r1, [r3, #12]
 8006dc4:	683b      	ldr	r3, [r7, #0]
 8006dc6:	6898      	ldr	r0, [r3, #8]
 8006dc8:	683b      	ldr	r3, [r7, #0]
 8006dca:	681b      	ldr	r3, [r3, #0]
 8006dcc:	b29b      	uxth	r3, r3
 8006dce:	461c      	mov	r4, r3
 8006dd0:	4623      	mov	r3, r4
 8006dd2:	005b      	lsls	r3, r3, #1
 8006dd4:	4423      	add	r3, r4
 8006dd6:	3b1e      	subs	r3, #30
 8006dd8:	fa00 f303 	lsl.w	r3, r0, r3
 8006ddc:	430b      	orrs	r3, r1
 8006dde:	60d3      	str	r3, [r2, #12]
 8006de0:	e023      	b.n	8006e2a <HAL_ADCEx_InjectedConfigChannel+0xbe>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfigInjected->InjectedChannel);
 8006de2:	687b      	ldr	r3, [r7, #4]
 8006de4:	681a      	ldr	r2, [r3, #0]
 8006de6:	687b      	ldr	r3, [r7, #4]
 8006de8:	681b      	ldr	r3, [r3, #0]
 8006dea:	6919      	ldr	r1, [r3, #16]
 8006dec:	683b      	ldr	r3, [r7, #0]
 8006dee:	681b      	ldr	r3, [r3, #0]
 8006df0:	b29b      	uxth	r3, r3
 8006df2:	4618      	mov	r0, r3
 8006df4:	4603      	mov	r3, r0
 8006df6:	005b      	lsls	r3, r3, #1
 8006df8:	4403      	add	r3, r0
 8006dfa:	4618      	mov	r0, r3
 8006dfc:	2307      	movs	r3, #7
 8006dfe:	4083      	lsls	r3, r0
 8006e00:	43db      	mvns	r3, r3
 8006e02:	400b      	ands	r3, r1
 8006e04:	6113      	str	r3, [r2, #16]
    
    /* Set the new sample time */
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel);
 8006e06:	687b      	ldr	r3, [r7, #4]
 8006e08:	681a      	ldr	r2, [r3, #0]
 8006e0a:	687b      	ldr	r3, [r7, #4]
 8006e0c:	681b      	ldr	r3, [r3, #0]
 8006e0e:	6919      	ldr	r1, [r3, #16]
 8006e10:	683b      	ldr	r3, [r7, #0]
 8006e12:	6898      	ldr	r0, [r3, #8]
 8006e14:	683b      	ldr	r3, [r7, #0]
 8006e16:	681b      	ldr	r3, [r3, #0]
 8006e18:	b29b      	uxth	r3, r3
 8006e1a:	461c      	mov	r4, r3
 8006e1c:	4623      	mov	r3, r4
 8006e1e:	005b      	lsls	r3, r3, #1
 8006e20:	4423      	add	r3, r4
 8006e22:	fa00 f303 	lsl.w	r3, r0, r3
 8006e26:	430b      	orrs	r3, r1
 8006e28:	6113      	str	r3, [r2, #16]
  }
  
  /*---------------------------- ADCx JSQR Configuration -----------------*/
  hadc->Instance->JSQR &= ~(ADC_JSQR_JL);
 8006e2a:	687b      	ldr	r3, [r7, #4]
 8006e2c:	681b      	ldr	r3, [r3, #0]
 8006e2e:	687a      	ldr	r2, [r7, #4]
 8006e30:	6812      	ldr	r2, [r2, #0]
 8006e32:	6b92      	ldr	r2, [r2, #56]	; 0x38
 8006e34:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8006e38:	639a      	str	r2, [r3, #56]	; 0x38
  hadc->Instance->JSQR |=  ADC_SQR1(sConfigInjected->InjectedNbrOfConversion);
 8006e3a:	687b      	ldr	r3, [r7, #4]
 8006e3c:	681b      	ldr	r3, [r3, #0]
 8006e3e:	687a      	ldr	r2, [r7, #4]
 8006e40:	6812      	ldr	r2, [r2, #0]
 8006e42:	6b91      	ldr	r1, [r2, #56]	; 0x38
 8006e44:	683a      	ldr	r2, [r7, #0]
 8006e46:	6912      	ldr	r2, [r2, #16]
 8006e48:	3a01      	subs	r2, #1
 8006e4a:	0512      	lsls	r2, r2, #20
 8006e4c:	430a      	orrs	r2, r1
 8006e4e:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* Rank configuration */
  
  /* Clear the old SQx bits for the selected rank */
  hadc->Instance->JSQR &= ~ADC_JSQR(ADC_JSQR_JSQ1, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
 8006e50:	687b      	ldr	r3, [r7, #4]
 8006e52:	681a      	ldr	r2, [r3, #0]
 8006e54:	687b      	ldr	r3, [r7, #4]
 8006e56:	681b      	ldr	r3, [r3, #0]
 8006e58:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8006e5a:	683b      	ldr	r3, [r7, #0]
 8006e5c:	685b      	ldr	r3, [r3, #4]
 8006e5e:	b2d8      	uxtb	r0, r3
 8006e60:	683b      	ldr	r3, [r7, #0]
 8006e62:	691b      	ldr	r3, [r3, #16]
 8006e64:	b2db      	uxtb	r3, r3
 8006e66:	1ac3      	subs	r3, r0, r3
 8006e68:	b2db      	uxtb	r3, r3
 8006e6a:	3303      	adds	r3, #3
 8006e6c:	b2db      	uxtb	r3, r3
 8006e6e:	4618      	mov	r0, r3
 8006e70:	4603      	mov	r3, r0
 8006e72:	009b      	lsls	r3, r3, #2
 8006e74:	4403      	add	r3, r0
 8006e76:	201f      	movs	r0, #31
 8006e78:	fa00 f303 	lsl.w	r3, r0, r3
 8006e7c:	43db      	mvns	r3, r3
 8006e7e:	400b      	ands	r3, r1
 8006e80:	6393      	str	r3, [r2, #56]	; 0x38
   
  /* Set the SQx bits for the selected rank */
  hadc->Instance->JSQR |= ADC_JSQR(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
 8006e82:	687b      	ldr	r3, [r7, #4]
 8006e84:	681a      	ldr	r2, [r3, #0]
 8006e86:	687b      	ldr	r3, [r7, #4]
 8006e88:	681b      	ldr	r3, [r3, #0]
 8006e8a:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8006e8c:	683b      	ldr	r3, [r7, #0]
 8006e8e:	681b      	ldr	r3, [r3, #0]
 8006e90:	b29b      	uxth	r3, r3
 8006e92:	461c      	mov	r4, r3
 8006e94:	683b      	ldr	r3, [r7, #0]
 8006e96:	685b      	ldr	r3, [r3, #4]
 8006e98:	b2d8      	uxtb	r0, r3
 8006e9a:	683b      	ldr	r3, [r7, #0]
 8006e9c:	691b      	ldr	r3, [r3, #16]
 8006e9e:	b2db      	uxtb	r3, r3
 8006ea0:	1ac3      	subs	r3, r0, r3
 8006ea2:	b2db      	uxtb	r3, r3
 8006ea4:	3303      	adds	r3, #3
 8006ea6:	b2db      	uxtb	r3, r3
 8006ea8:	4618      	mov	r0, r3
 8006eaa:	4603      	mov	r3, r0
 8006eac:	009b      	lsls	r3, r3, #2
 8006eae:	4403      	add	r3, r0
 8006eb0:	fa04 f303 	lsl.w	r3, r4, r3
 8006eb4:	430b      	orrs	r3, r1
 8006eb6:	6393      	str	r3, [r2, #56]	; 0x38

  /* Select external trigger to start conversion */
  hadc->Instance->CR2 &= ~(ADC_CR2_JEXTSEL);
 8006eb8:	687b      	ldr	r3, [r7, #4]
 8006eba:	681b      	ldr	r3, [r3, #0]
 8006ebc:	687a      	ldr	r2, [r7, #4]
 8006ebe:	6812      	ldr	r2, [r2, #0]
 8006ec0:	6892      	ldr	r2, [r2, #8]
 8006ec2:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
 8006ec6:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |=  sConfigInjected->ExternalTrigInjecConv;
 8006ec8:	687b      	ldr	r3, [r7, #4]
 8006eca:	681b      	ldr	r3, [r3, #0]
 8006ecc:	687a      	ldr	r2, [r7, #4]
 8006ece:	6812      	ldr	r2, [r2, #0]
 8006ed0:	6891      	ldr	r1, [r2, #8]
 8006ed2:	683a      	ldr	r2, [r7, #0]
 8006ed4:	6a12      	ldr	r2, [r2, #32]
 8006ed6:	430a      	orrs	r2, r1
 8006ed8:	609a      	str	r2, [r3, #8]
  
  /* Select external trigger polarity */
  hadc->Instance->CR2 &= ~(ADC_CR2_JEXTEN);
 8006eda:	687b      	ldr	r3, [r7, #4]
 8006edc:	681b      	ldr	r3, [r3, #0]
 8006ede:	687a      	ldr	r2, [r7, #4]
 8006ee0:	6812      	ldr	r2, [r2, #0]
 8006ee2:	6892      	ldr	r2, [r2, #8]
 8006ee4:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8006ee8:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= sConfigInjected->ExternalTrigInjecConvEdge;
 8006eea:	687b      	ldr	r3, [r7, #4]
 8006eec:	681b      	ldr	r3, [r3, #0]
 8006eee:	687a      	ldr	r2, [r7, #4]
 8006ef0:	6812      	ldr	r2, [r2, #0]
 8006ef2:	6891      	ldr	r1, [r2, #8]
 8006ef4:	683a      	ldr	r2, [r7, #0]
 8006ef6:	69d2      	ldr	r2, [r2, #28]
 8006ef8:	430a      	orrs	r2, r1
 8006efa:	609a      	str	r2, [r3, #8]
  
  if (sConfigInjected->AutoInjectedConv != DISABLE)
 8006efc:	683b      	ldr	r3, [r7, #0]
 8006efe:	695b      	ldr	r3, [r3, #20]
 8006f00:	2b00      	cmp	r3, #0
 8006f02:	d008      	beq.n	8006f16 <HAL_ADCEx_InjectedConfigChannel+0x1aa>
  {
    /* Enable the selected ADC automatic injected group conversion */
    hadc->Instance->CR1 |= ADC_CR1_JAUTO;
 8006f04:	687b      	ldr	r3, [r7, #4]
 8006f06:	681b      	ldr	r3, [r3, #0]
 8006f08:	687a      	ldr	r2, [r7, #4]
 8006f0a:	6812      	ldr	r2, [r2, #0]
 8006f0c:	6852      	ldr	r2, [r2, #4]
 8006f0e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8006f12:	605a      	str	r2, [r3, #4]
 8006f14:	e007      	b.n	8006f26 <HAL_ADCEx_InjectedConfigChannel+0x1ba>
  }
  else
  {
    /* Disable the selected ADC automatic injected group conversion */
    hadc->Instance->CR1 &= ~(ADC_CR1_JAUTO);
 8006f16:	687b      	ldr	r3, [r7, #4]
 8006f18:	681b      	ldr	r3, [r3, #0]
 8006f1a:	687a      	ldr	r2, [r7, #4]
 8006f1c:	6812      	ldr	r2, [r2, #0]
 8006f1e:	6852      	ldr	r2, [r2, #4]
 8006f20:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8006f24:	605a      	str	r2, [r3, #4]
  }
  
  if (sConfigInjected->InjectedDiscontinuousConvMode != DISABLE)
 8006f26:	683b      	ldr	r3, [r7, #0]
 8006f28:	699b      	ldr	r3, [r3, #24]
 8006f2a:	2b00      	cmp	r3, #0
 8006f2c:	d008      	beq.n	8006f40 <HAL_ADCEx_InjectedConfigChannel+0x1d4>
  {
    /* Enable the selected ADC injected discontinuous mode */
    hadc->Instance->CR1 |= ADC_CR1_JDISCEN;
 8006f2e:	687b      	ldr	r3, [r7, #4]
 8006f30:	681b      	ldr	r3, [r3, #0]
 8006f32:	687a      	ldr	r2, [r7, #4]
 8006f34:	6812      	ldr	r2, [r2, #0]
 8006f36:	6852      	ldr	r2, [r2, #4]
 8006f38:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8006f3c:	605a      	str	r2, [r3, #4]
 8006f3e:	e007      	b.n	8006f50 <HAL_ADCEx_InjectedConfigChannel+0x1e4>
  }
  else
  {
    /* Disable the selected ADC injected discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_JDISCEN);
 8006f40:	687b      	ldr	r3, [r7, #4]
 8006f42:	681b      	ldr	r3, [r3, #0]
 8006f44:	687a      	ldr	r2, [r7, #4]
 8006f46:	6812      	ldr	r2, [r2, #0]
 8006f48:	6852      	ldr	r2, [r2, #4]
 8006f4a:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8006f4e:	605a      	str	r2, [r3, #4]
  }
  
  switch(sConfigInjected->InjectedRank)
 8006f50:	683b      	ldr	r3, [r7, #0]
 8006f52:	685b      	ldr	r3, [r3, #4]
 8006f54:	2b02      	cmp	r3, #2
 8006f56:	d015      	beq.n	8006f84 <HAL_ADCEx_InjectedConfigChannel+0x218>
 8006f58:	2b03      	cmp	r3, #3
 8006f5a:	d025      	beq.n	8006fa8 <HAL_ADCEx_InjectedConfigChannel+0x23c>
 8006f5c:	2b01      	cmp	r3, #1
 8006f5e:	d135      	bne.n	8006fcc <HAL_ADCEx_InjectedConfigChannel+0x260>
  {
    case 1:
      /* Set injected channel 1 offset */
      hadc->Instance->JOFR1 &= ~(ADC_JOFR1_JOFFSET1);
 8006f60:	687b      	ldr	r3, [r7, #4]
 8006f62:	681a      	ldr	r2, [r3, #0]
 8006f64:	687b      	ldr	r3, [r7, #4]
 8006f66:	681b      	ldr	r3, [r3, #0]
 8006f68:	6959      	ldr	r1, [r3, #20]
 8006f6a:	4b37      	ldr	r3, [pc, #220]	; (8007048 <HAL_ADCEx_InjectedConfigChannel+0x2dc>)
 8006f6c:	400b      	ands	r3, r1
 8006f6e:	6153      	str	r3, [r2, #20]
      hadc->Instance->JOFR1 |= sConfigInjected->InjectedOffset;
 8006f70:	687b      	ldr	r3, [r7, #4]
 8006f72:	681b      	ldr	r3, [r3, #0]
 8006f74:	687a      	ldr	r2, [r7, #4]
 8006f76:	6812      	ldr	r2, [r2, #0]
 8006f78:	6951      	ldr	r1, [r2, #20]
 8006f7a:	683a      	ldr	r2, [r7, #0]
 8006f7c:	68d2      	ldr	r2, [r2, #12]
 8006f7e:	430a      	orrs	r2, r1
 8006f80:	615a      	str	r2, [r3, #20]
      break;
 8006f82:	e035      	b.n	8006ff0 <HAL_ADCEx_InjectedConfigChannel+0x284>
    case 2:
      /* Set injected channel 2 offset */
      hadc->Instance->JOFR2 &= ~(ADC_JOFR2_JOFFSET2);
 8006f84:	687b      	ldr	r3, [r7, #4]
 8006f86:	681a      	ldr	r2, [r3, #0]
 8006f88:	687b      	ldr	r3, [r7, #4]
 8006f8a:	681b      	ldr	r3, [r3, #0]
 8006f8c:	6999      	ldr	r1, [r3, #24]
 8006f8e:	4b2e      	ldr	r3, [pc, #184]	; (8007048 <HAL_ADCEx_InjectedConfigChannel+0x2dc>)
 8006f90:	400b      	ands	r3, r1
 8006f92:	6193      	str	r3, [r2, #24]
      hadc->Instance->JOFR2 |= sConfigInjected->InjectedOffset;
 8006f94:	687b      	ldr	r3, [r7, #4]
 8006f96:	681b      	ldr	r3, [r3, #0]
 8006f98:	687a      	ldr	r2, [r7, #4]
 8006f9a:	6812      	ldr	r2, [r2, #0]
 8006f9c:	6991      	ldr	r1, [r2, #24]
 8006f9e:	683a      	ldr	r2, [r7, #0]
 8006fa0:	68d2      	ldr	r2, [r2, #12]
 8006fa2:	430a      	orrs	r2, r1
 8006fa4:	619a      	str	r2, [r3, #24]
      break;
 8006fa6:	e023      	b.n	8006ff0 <HAL_ADCEx_InjectedConfigChannel+0x284>
    case 3:
      /* Set injected channel 3 offset */
      hadc->Instance->JOFR3 &= ~(ADC_JOFR3_JOFFSET3);
 8006fa8:	687b      	ldr	r3, [r7, #4]
 8006faa:	681a      	ldr	r2, [r3, #0]
 8006fac:	687b      	ldr	r3, [r7, #4]
 8006fae:	681b      	ldr	r3, [r3, #0]
 8006fb0:	69d9      	ldr	r1, [r3, #28]
 8006fb2:	4b25      	ldr	r3, [pc, #148]	; (8007048 <HAL_ADCEx_InjectedConfigChannel+0x2dc>)
 8006fb4:	400b      	ands	r3, r1
 8006fb6:	61d3      	str	r3, [r2, #28]
      hadc->Instance->JOFR3 |= sConfigInjected->InjectedOffset;
 8006fb8:	687b      	ldr	r3, [r7, #4]
 8006fba:	681b      	ldr	r3, [r3, #0]
 8006fbc:	687a      	ldr	r2, [r7, #4]
 8006fbe:	6812      	ldr	r2, [r2, #0]
 8006fc0:	69d1      	ldr	r1, [r2, #28]
 8006fc2:	683a      	ldr	r2, [r7, #0]
 8006fc4:	68d2      	ldr	r2, [r2, #12]
 8006fc6:	430a      	orrs	r2, r1
 8006fc8:	61da      	str	r2, [r3, #28]
      break;
 8006fca:	e011      	b.n	8006ff0 <HAL_ADCEx_InjectedConfigChannel+0x284>
    default:
      /* Set injected channel 4 offset */
      hadc->Instance->JOFR4 &= ~(ADC_JOFR4_JOFFSET4);
 8006fcc:	687b      	ldr	r3, [r7, #4]
 8006fce:	681a      	ldr	r2, [r3, #0]
 8006fd0:	687b      	ldr	r3, [r7, #4]
 8006fd2:	681b      	ldr	r3, [r3, #0]
 8006fd4:	6a19      	ldr	r1, [r3, #32]
 8006fd6:	4b1c      	ldr	r3, [pc, #112]	; (8007048 <HAL_ADCEx_InjectedConfigChannel+0x2dc>)
 8006fd8:	400b      	ands	r3, r1
 8006fda:	6213      	str	r3, [r2, #32]
      hadc->Instance->JOFR4 |= sConfigInjected->InjectedOffset;
 8006fdc:	687b      	ldr	r3, [r7, #4]
 8006fde:	681b      	ldr	r3, [r3, #0]
 8006fe0:	687a      	ldr	r2, [r7, #4]
 8006fe2:	6812      	ldr	r2, [r2, #0]
 8006fe4:	6a11      	ldr	r1, [r2, #32]
 8006fe6:	683a      	ldr	r2, [r7, #0]
 8006fe8:	68d2      	ldr	r2, [r2, #12]
 8006fea:	430a      	orrs	r2, r1
 8006fec:	621a      	str	r2, [r3, #32]
      break;
 8006fee:	bf00      	nop
  }
  
  /* if ADC1 Channel_18 is selected enable VBAT Channel */
  if ((hadc->Instance == ADC1) && (sConfigInjected->InjectedChannel == ADC_CHANNEL_VBAT))
 8006ff0:	687b      	ldr	r3, [r7, #4]
 8006ff2:	681b      	ldr	r3, [r3, #0]
 8006ff4:	4a15      	ldr	r2, [pc, #84]	; (800704c <HAL_ADCEx_InjectedConfigChannel+0x2e0>)
 8006ff6:	4293      	cmp	r3, r2
 8006ff8:	d109      	bne.n	800700e <HAL_ADCEx_InjectedConfigChannel+0x2a2>
 8006ffa:	683b      	ldr	r3, [r7, #0]
 8006ffc:	681b      	ldr	r3, [r3, #0]
 8006ffe:	2b12      	cmp	r3, #18
 8007000:	d105      	bne.n	800700e <HAL_ADCEx_InjectedConfigChannel+0x2a2>
  {
    /* Enable the VBAT channel*/
    ADC->CCR |= ADC_CCR_VBATE;
 8007002:	4a13      	ldr	r2, [pc, #76]	; (8007050 <HAL_ADCEx_InjectedConfigChannel+0x2e4>)
 8007004:	4b12      	ldr	r3, [pc, #72]	; (8007050 <HAL_ADCEx_InjectedConfigChannel+0x2e4>)
 8007006:	685b      	ldr	r3, [r3, #4]
 8007008:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800700c:	6053      	str	r3, [r2, #4]
  }
  
  /* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
  if ((hadc->Instance == ADC1) && ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR) || (sConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT)))
 800700e:	687b      	ldr	r3, [r7, #4]
 8007010:	681b      	ldr	r3, [r3, #0]
 8007012:	4a0e      	ldr	r2, [pc, #56]	; (800704c <HAL_ADCEx_InjectedConfigChannel+0x2e0>)
 8007014:	4293      	cmp	r3, r2
 8007016:	d10d      	bne.n	8007034 <HAL_ADCEx_InjectedConfigChannel+0x2c8>
 8007018:	683b      	ldr	r3, [r7, #0]
 800701a:	681b      	ldr	r3, [r3, #0]
 800701c:	2b10      	cmp	r3, #16
 800701e:	d003      	beq.n	8007028 <HAL_ADCEx_InjectedConfigChannel+0x2bc>
 8007020:	683b      	ldr	r3, [r7, #0]
 8007022:	681b      	ldr	r3, [r3, #0]
 8007024:	2b11      	cmp	r3, #17
 8007026:	d105      	bne.n	8007034 <HAL_ADCEx_InjectedConfigChannel+0x2c8>
  {
    /* Enable the TSVREFE channel*/
    ADC->CCR |= ADC_CCR_TSVREFE;
 8007028:	4a09      	ldr	r2, [pc, #36]	; (8007050 <HAL_ADCEx_InjectedConfigChannel+0x2e4>)
 800702a:	4b09      	ldr	r3, [pc, #36]	; (8007050 <HAL_ADCEx_InjectedConfigChannel+0x2e4>)
 800702c:	685b      	ldr	r3, [r3, #4]
 800702e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8007032:	6053      	str	r3, [r2, #4]
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8007034:	687b      	ldr	r3, [r7, #4]
 8007036:	2200      	movs	r2, #0
 8007038:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 800703c:	2300      	movs	r3, #0
}
 800703e:	4618      	mov	r0, r3
 8007040:	3708      	adds	r7, #8
 8007042:	46bd      	mov	sp, r7
 8007044:	bc90      	pop	{r4, r7}
 8007046:	4770      	bx	lr
 8007048:	fffff000 	.word	0xfffff000
 800704c:	40012000 	.word	0x40012000
 8007050:	40012300 	.word	0x40012300

08007054 <HAL_ADCEx_MultiModeConfigChannel>:
  * @param  multimode : pointer to an ADC_MultiModeTypeDef structure that contains 
  *                     the configuration information for  multimode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef* hadc, ADC_MultiModeTypeDef* multimode)
{
 8007054:	b480      	push	{r7}
 8007056:	b083      	sub	sp, #12
 8007058:	af00      	add	r7, sp, #0
 800705a:	6078      	str	r0, [r7, #4]
 800705c:	6039      	str	r1, [r7, #0]
  assert_param(IS_ADC_MODE(multimode->Mode));
  assert_param(IS_ADC_DMA_ACCESS_MODE(multimode->DMAAccessMode));
  assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 800705e:	687b      	ldr	r3, [r7, #4]
 8007060:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8007064:	2b01      	cmp	r3, #1
 8007066:	d101      	bne.n	800706c <HAL_ADCEx_MultiModeConfigChannel+0x18>
 8007068:	2302      	movs	r3, #2
 800706a:	e02f      	b.n	80070cc <HAL_ADCEx_MultiModeConfigChannel+0x78>
 800706c:	687b      	ldr	r3, [r7, #4]
 800706e:	2201      	movs	r2, #1
 8007070:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Set ADC mode */
  ADC->CCR &= ~(ADC_CCR_MULTI);
 8007074:	4a18      	ldr	r2, [pc, #96]	; (80070d8 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 8007076:	4b18      	ldr	r3, [pc, #96]	; (80070d8 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 8007078:	685b      	ldr	r3, [r3, #4]
 800707a:	f023 031f 	bic.w	r3, r3, #31
 800707e:	6053      	str	r3, [r2, #4]
  ADC->CCR |= multimode->Mode;
 8007080:	4915      	ldr	r1, [pc, #84]	; (80070d8 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 8007082:	4b15      	ldr	r3, [pc, #84]	; (80070d8 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 8007084:	685a      	ldr	r2, [r3, #4]
 8007086:	683b      	ldr	r3, [r7, #0]
 8007088:	681b      	ldr	r3, [r3, #0]
 800708a:	4313      	orrs	r3, r2
 800708c:	604b      	str	r3, [r1, #4]
  
  /* Set the ADC DMA access mode */
  ADC->CCR &= ~(ADC_CCR_DMA);
 800708e:	4a12      	ldr	r2, [pc, #72]	; (80070d8 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 8007090:	4b11      	ldr	r3, [pc, #68]	; (80070d8 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 8007092:	685b      	ldr	r3, [r3, #4]
 8007094:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8007098:	6053      	str	r3, [r2, #4]
  ADC->CCR |= multimode->DMAAccessMode;
 800709a:	490f      	ldr	r1, [pc, #60]	; (80070d8 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 800709c:	4b0e      	ldr	r3, [pc, #56]	; (80070d8 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 800709e:	685a      	ldr	r2, [r3, #4]
 80070a0:	683b      	ldr	r3, [r7, #0]
 80070a2:	685b      	ldr	r3, [r3, #4]
 80070a4:	4313      	orrs	r3, r2
 80070a6:	604b      	str	r3, [r1, #4]
  
  /* Set delay between two sampling phases */
  ADC->CCR &= ~(ADC_CCR_DELAY);
 80070a8:	4a0b      	ldr	r2, [pc, #44]	; (80070d8 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 80070aa:	4b0b      	ldr	r3, [pc, #44]	; (80070d8 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 80070ac:	685b      	ldr	r3, [r3, #4]
 80070ae:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 80070b2:	6053      	str	r3, [r2, #4]
  ADC->CCR |= multimode->TwoSamplingDelay;
 80070b4:	4908      	ldr	r1, [pc, #32]	; (80070d8 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 80070b6:	4b08      	ldr	r3, [pc, #32]	; (80070d8 <HAL_ADCEx_MultiModeConfigChannel+0x84>)
 80070b8:	685a      	ldr	r2, [r3, #4]
 80070ba:	683b      	ldr	r3, [r7, #0]
 80070bc:	689b      	ldr	r3, [r3, #8]
 80070be:	4313      	orrs	r3, r2
 80070c0:	604b      	str	r3, [r1, #4]
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80070c2:	687b      	ldr	r3, [r7, #4]
 80070c4:	2200      	movs	r2, #0
 80070c6:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 80070ca:	2300      	movs	r3, #0
}
 80070cc:	4618      	mov	r0, r3
 80070ce:	370c      	adds	r7, #12
 80070d0:	46bd      	mov	sp, r7
 80070d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80070d6:	4770      	bx	lr
 80070d8:	40012300 	.word	0x40012300

080070dc <HAL_CAN_Init>:
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Init(CAN_HandleTypeDef* hcan)
{
 80070dc:	b580      	push	{r7, lr}
 80070de:	b084      	sub	sp, #16
 80070e0:	af00      	add	r7, sp, #0
 80070e2:	6078      	str	r0, [r7, #4]
  uint32_t InitStatus = 3;
 80070e4:	2303      	movs	r3, #3
 80070e6:	60fb      	str	r3, [r7, #12]
  uint32_t tickstart = 0;
 80070e8:	2300      	movs	r3, #0
 80070ea:	60bb      	str	r3, [r7, #8]
  
  /* Check CAN handle */
  if(hcan == NULL)
 80070ec:	687b      	ldr	r3, [r7, #4]
 80070ee:	2b00      	cmp	r3, #0
 80070f0:	d101      	bne.n	80070f6 <HAL_CAN_Init+0x1a>
  {
     return HAL_ERROR;
 80070f2:	2301      	movs	r3, #1
 80070f4:	e117      	b.n	8007326 <HAL_CAN_Init+0x24a>
  assert_param(IS_CAN_BS1(hcan->Init.BS1));
  assert_param(IS_CAN_BS2(hcan->Init.BS2));
  assert_param(IS_CAN_PRESCALER(hcan->Init.Prescaler));
  

  if(hcan->State == HAL_CAN_STATE_RESET)
 80070f6:	687b      	ldr	r3, [r7, #4]
 80070f8:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 80070fc:	b2db      	uxtb	r3, r3
 80070fe:	2b00      	cmp	r3, #0
 8007100:	d106      	bne.n	8007110 <HAL_CAN_Init+0x34>
  {
    /* Allocate lock resource and initialize it */
    hcan->Lock = HAL_UNLOCKED;
 8007102:	687b      	ldr	r3, [r7, #4]
 8007104:	2200      	movs	r2, #0
 8007106:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    /* Init the low level hardware */
    HAL_CAN_MspInit(hcan);
 800710a:	6878      	ldr	r0, [r7, #4]
 800710c:	f00a fcc6 	bl	8011a9c <HAL_CAN_MspInit>
  }
  
  /* Initialize the CAN state*/
  hcan->State = HAL_CAN_STATE_BUSY;
 8007110:	687b      	ldr	r3, [r7, #4]
 8007112:	2202      	movs	r2, #2
 8007114:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  /* Exit from sleep mode */
  hcan->Instance->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
 8007118:	687b      	ldr	r3, [r7, #4]
 800711a:	681b      	ldr	r3, [r3, #0]
 800711c:	687a      	ldr	r2, [r7, #4]
 800711e:	6812      	ldr	r2, [r2, #0]
 8007120:	6812      	ldr	r2, [r2, #0]
 8007122:	f022 0202 	bic.w	r2, r2, #2
 8007126:	601a      	str	r2, [r3, #0]

  /* Request initialisation */
  hcan->Instance->MCR |= CAN_MCR_INRQ ;
 8007128:	687b      	ldr	r3, [r7, #4]
 800712a:	681b      	ldr	r3, [r3, #0]
 800712c:	687a      	ldr	r2, [r7, #4]
 800712e:	6812      	ldr	r2, [r2, #0]
 8007130:	6812      	ldr	r2, [r2, #0]
 8007132:	f042 0201 	orr.w	r2, r2, #1
 8007136:	601a      	str	r2, [r3, #0]
  
  /* Get tick */
  tickstart = HAL_GetTick();
 8007138:	f7ff f88e 	bl	8006258 <HAL_GetTick>
 800713c:	60b8      	str	r0, [r7, #8]

  /* Wait the acknowledge */
  while((hcan->Instance->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
 800713e:	e010      	b.n	8007162 <HAL_CAN_Init+0x86>
  {
    if((HAL_GetTick() - tickstart ) > CAN_TIMEOUT_VALUE)
 8007140:	f7ff f88a 	bl	8006258 <HAL_GetTick>
 8007144:	4602      	mov	r2, r0
 8007146:	68bb      	ldr	r3, [r7, #8]
 8007148:	1ad3      	subs	r3, r2, r3
 800714a:	2b0a      	cmp	r3, #10
 800714c:	d909      	bls.n	8007162 <HAL_CAN_Init+0x86>
    {
      hcan->State= HAL_CAN_STATE_TIMEOUT;
 800714e:	687b      	ldr	r3, [r7, #4]
 8007150:	2203      	movs	r2, #3
 8007152:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
      /* Process unlocked */
      __HAL_UNLOCK(hcan);
 8007156:	687b      	ldr	r3, [r7, #4]
 8007158:	2200      	movs	r2, #0
 800715a:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
      return HAL_TIMEOUT;
 800715e:	2303      	movs	r3, #3
 8007160:	e0e1      	b.n	8007326 <HAL_CAN_Init+0x24a>
  
  /* Get tick */
  tickstart = HAL_GetTick();

  /* Wait the acknowledge */
  while((hcan->Instance->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
 8007162:	687b      	ldr	r3, [r7, #4]
 8007164:	681b      	ldr	r3, [r3, #0]
 8007166:	685b      	ldr	r3, [r3, #4]
 8007168:	f003 0301 	and.w	r3, r3, #1
 800716c:	2b00      	cmp	r3, #0
 800716e:	d0e7      	beq.n	8007140 <HAL_CAN_Init+0x64>
      return HAL_TIMEOUT;
    }
  }

  /* Check acknowledge */
  if ((hcan->Instance->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
 8007170:	687b      	ldr	r3, [r7, #4]
 8007172:	681b      	ldr	r3, [r3, #0]
 8007174:	685b      	ldr	r3, [r3, #4]
 8007176:	f003 0301 	and.w	r3, r3, #1
 800717a:	2b00      	cmp	r3, #0
 800717c:	d102      	bne.n	8007184 <HAL_CAN_Init+0xa8>
  {
    InitStatus = CAN_INITSTATUS_FAILED;
 800717e:	2300      	movs	r3, #0
 8007180:	60fb      	str	r3, [r7, #12]
 8007182:	e0bf      	b.n	8007304 <HAL_CAN_Init+0x228>
  }
  else 
  {
    /* Set the time triggered communication mode */
    if (hcan->Init.TTCM == ENABLE)
 8007184:	687b      	ldr	r3, [r7, #4]
 8007186:	699b      	ldr	r3, [r3, #24]
 8007188:	2b01      	cmp	r3, #1
 800718a:	d108      	bne.n	800719e <HAL_CAN_Init+0xc2>
    {
      hcan->Instance->MCR |= CAN_MCR_TTCM;
 800718c:	687b      	ldr	r3, [r7, #4]
 800718e:	681b      	ldr	r3, [r3, #0]
 8007190:	687a      	ldr	r2, [r7, #4]
 8007192:	6812      	ldr	r2, [r2, #0]
 8007194:	6812      	ldr	r2, [r2, #0]
 8007196:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800719a:	601a      	str	r2, [r3, #0]
 800719c:	e007      	b.n	80071ae <HAL_CAN_Init+0xd2>
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TTCM;
 800719e:	687b      	ldr	r3, [r7, #4]
 80071a0:	681b      	ldr	r3, [r3, #0]
 80071a2:	687a      	ldr	r2, [r7, #4]
 80071a4:	6812      	ldr	r2, [r2, #0]
 80071a6:	6812      	ldr	r2, [r2, #0]
 80071a8:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80071ac:	601a      	str	r2, [r3, #0]
    }

    /* Set the automatic bus-off management */
    if (hcan->Init.ABOM == ENABLE)
 80071ae:	687b      	ldr	r3, [r7, #4]
 80071b0:	69db      	ldr	r3, [r3, #28]
 80071b2:	2b01      	cmp	r3, #1
 80071b4:	d108      	bne.n	80071c8 <HAL_CAN_Init+0xec>
    {
      hcan->Instance->MCR |= CAN_MCR_ABOM;
 80071b6:	687b      	ldr	r3, [r7, #4]
 80071b8:	681b      	ldr	r3, [r3, #0]
 80071ba:	687a      	ldr	r2, [r7, #4]
 80071bc:	6812      	ldr	r2, [r2, #0]
 80071be:	6812      	ldr	r2, [r2, #0]
 80071c0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80071c4:	601a      	str	r2, [r3, #0]
 80071c6:	e007      	b.n	80071d8 <HAL_CAN_Init+0xfc>
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_ABOM;
 80071c8:	687b      	ldr	r3, [r7, #4]
 80071ca:	681b      	ldr	r3, [r3, #0]
 80071cc:	687a      	ldr	r2, [r7, #4]
 80071ce:	6812      	ldr	r2, [r2, #0]
 80071d0:	6812      	ldr	r2, [r2, #0]
 80071d2:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80071d6:	601a      	str	r2, [r3, #0]
    }

    /* Set the automatic wake-up mode */
    if (hcan->Init.AWUM == ENABLE)
 80071d8:	687b      	ldr	r3, [r7, #4]
 80071da:	6a1b      	ldr	r3, [r3, #32]
 80071dc:	2b01      	cmp	r3, #1
 80071de:	d108      	bne.n	80071f2 <HAL_CAN_Init+0x116>
    {
      hcan->Instance->MCR |= CAN_MCR_AWUM;
 80071e0:	687b      	ldr	r3, [r7, #4]
 80071e2:	681b      	ldr	r3, [r3, #0]
 80071e4:	687a      	ldr	r2, [r7, #4]
 80071e6:	6812      	ldr	r2, [r2, #0]
 80071e8:	6812      	ldr	r2, [r2, #0]
 80071ea:	f042 0220 	orr.w	r2, r2, #32
 80071ee:	601a      	str	r2, [r3, #0]
 80071f0:	e007      	b.n	8007202 <HAL_CAN_Init+0x126>
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_AWUM;
 80071f2:	687b      	ldr	r3, [r7, #4]
 80071f4:	681b      	ldr	r3, [r3, #0]
 80071f6:	687a      	ldr	r2, [r7, #4]
 80071f8:	6812      	ldr	r2, [r2, #0]
 80071fa:	6812      	ldr	r2, [r2, #0]
 80071fc:	f022 0220 	bic.w	r2, r2, #32
 8007200:	601a      	str	r2, [r3, #0]
    }

    /* Set the no automatic retransmission */
    if (hcan->Init.NART == ENABLE)
 8007202:	687b      	ldr	r3, [r7, #4]
 8007204:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007206:	2b01      	cmp	r3, #1
 8007208:	d108      	bne.n	800721c <HAL_CAN_Init+0x140>
    {
      hcan->Instance->MCR |= CAN_MCR_NART;
 800720a:	687b      	ldr	r3, [r7, #4]
 800720c:	681b      	ldr	r3, [r3, #0]
 800720e:	687a      	ldr	r2, [r7, #4]
 8007210:	6812      	ldr	r2, [r2, #0]
 8007212:	6812      	ldr	r2, [r2, #0]
 8007214:	f042 0210 	orr.w	r2, r2, #16
 8007218:	601a      	str	r2, [r3, #0]
 800721a:	e007      	b.n	800722c <HAL_CAN_Init+0x150>
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_NART;
 800721c:	687b      	ldr	r3, [r7, #4]
 800721e:	681b      	ldr	r3, [r3, #0]
 8007220:	687a      	ldr	r2, [r7, #4]
 8007222:	6812      	ldr	r2, [r2, #0]
 8007224:	6812      	ldr	r2, [r2, #0]
 8007226:	f022 0210 	bic.w	r2, r2, #16
 800722a:	601a      	str	r2, [r3, #0]
    }

    /* Set the receive FIFO locked mode */
    if (hcan->Init.RFLM == ENABLE)
 800722c:	687b      	ldr	r3, [r7, #4]
 800722e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8007230:	2b01      	cmp	r3, #1
 8007232:	d108      	bne.n	8007246 <HAL_CAN_Init+0x16a>
    {
      hcan->Instance->MCR |= CAN_MCR_RFLM;
 8007234:	687b      	ldr	r3, [r7, #4]
 8007236:	681b      	ldr	r3, [r3, #0]
 8007238:	687a      	ldr	r2, [r7, #4]
 800723a:	6812      	ldr	r2, [r2, #0]
 800723c:	6812      	ldr	r2, [r2, #0]
 800723e:	f042 0208 	orr.w	r2, r2, #8
 8007242:	601a      	str	r2, [r3, #0]
 8007244:	e007      	b.n	8007256 <HAL_CAN_Init+0x17a>
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_RFLM;
 8007246:	687b      	ldr	r3, [r7, #4]
 8007248:	681b      	ldr	r3, [r3, #0]
 800724a:	687a      	ldr	r2, [r7, #4]
 800724c:	6812      	ldr	r2, [r2, #0]
 800724e:	6812      	ldr	r2, [r2, #0]
 8007250:	f022 0208 	bic.w	r2, r2, #8
 8007254:	601a      	str	r2, [r3, #0]
    }

    /* Set the transmit FIFO priority */
    if (hcan->Init.TXFP == ENABLE)
 8007256:	687b      	ldr	r3, [r7, #4]
 8007258:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800725a:	2b01      	cmp	r3, #1
 800725c:	d108      	bne.n	8007270 <HAL_CAN_Init+0x194>
    {
      hcan->Instance->MCR |= CAN_MCR_TXFP;
 800725e:	687b      	ldr	r3, [r7, #4]
 8007260:	681b      	ldr	r3, [r3, #0]
 8007262:	687a      	ldr	r2, [r7, #4]
 8007264:	6812      	ldr	r2, [r2, #0]
 8007266:	6812      	ldr	r2, [r2, #0]
 8007268:	f042 0204 	orr.w	r2, r2, #4
 800726c:	601a      	str	r2, [r3, #0]
 800726e:	e007      	b.n	8007280 <HAL_CAN_Init+0x1a4>
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TXFP;
 8007270:	687b      	ldr	r3, [r7, #4]
 8007272:	681b      	ldr	r3, [r3, #0]
 8007274:	687a      	ldr	r2, [r7, #4]
 8007276:	6812      	ldr	r2, [r2, #0]
 8007278:	6812      	ldr	r2, [r2, #0]
 800727a:	f022 0204 	bic.w	r2, r2, #4
 800727e:	601a      	str	r2, [r3, #0]
    }

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
 8007280:	687b      	ldr	r3, [r7, #4]
 8007282:	681b      	ldr	r3, [r3, #0]
 8007284:	687a      	ldr	r2, [r7, #4]
 8007286:	6891      	ldr	r1, [r2, #8]
                ((uint32_t)hcan->Init.SJW) | \
 8007288:	687a      	ldr	r2, [r7, #4]
 800728a:	68d2      	ldr	r2, [r2, #12]
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    }

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
 800728c:	4311      	orrs	r1, r2
                ((uint32_t)hcan->Init.SJW) | \
                ((uint32_t)hcan->Init.BS1) | \
 800728e:	687a      	ldr	r2, [r7, #4]
 8007290:	6912      	ldr	r2, [r2, #16]
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    }

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
                ((uint32_t)hcan->Init.SJW) | \
 8007292:	4311      	orrs	r1, r2
                ((uint32_t)hcan->Init.BS1) | \
                ((uint32_t)hcan->Init.BS2) | \
 8007294:	687a      	ldr	r2, [r7, #4]
 8007296:	6952      	ldr	r2, [r2, #20]
    }

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
                ((uint32_t)hcan->Init.SJW) | \
                ((uint32_t)hcan->Init.BS1) | \
 8007298:	4311      	orrs	r1, r2
                ((uint32_t)hcan->Init.BS2) | \
               ((uint32_t)hcan->Init.Prescaler - 1);
 800729a:	687a      	ldr	r2, [r7, #4]
 800729c:	6852      	ldr	r2, [r2, #4]
 800729e:	3a01      	subs	r2, #1

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
                ((uint32_t)hcan->Init.SJW) | \
                ((uint32_t)hcan->Init.BS1) | \
                ((uint32_t)hcan->Init.BS2) | \
 80072a0:	430a      	orrs	r2, r1
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    }

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
 80072a2:	61da      	str	r2, [r3, #28]
                ((uint32_t)hcan->Init.BS1) | \
                ((uint32_t)hcan->Init.BS2) | \
               ((uint32_t)hcan->Init.Prescaler - 1);

    /* Request leave initialisation */
    hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_INRQ;
 80072a4:	687b      	ldr	r3, [r7, #4]
 80072a6:	681b      	ldr	r3, [r3, #0]
 80072a8:	687a      	ldr	r2, [r7, #4]
 80072aa:	6812      	ldr	r2, [r2, #0]
 80072ac:	6812      	ldr	r2, [r2, #0]
 80072ae:	f022 0201 	bic.w	r2, r2, #1
 80072b2:	601a      	str	r2, [r3, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 80072b4:	f7fe ffd0 	bl	8006258 <HAL_GetTick>
 80072b8:	60b8      	str	r0, [r7, #8]

   /* Wait the acknowledge */
   while((hcan->Instance->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
 80072ba:	e010      	b.n	80072de <HAL_CAN_Init+0x202>
   {
    if((HAL_GetTick() - tickstart ) > CAN_TIMEOUT_VALUE)
 80072bc:	f7fe ffcc 	bl	8006258 <HAL_GetTick>
 80072c0:	4602      	mov	r2, r0
 80072c2:	68bb      	ldr	r3, [r7, #8]
 80072c4:	1ad3      	subs	r3, r2, r3
 80072c6:	2b0a      	cmp	r3, #10
 80072c8:	d909      	bls.n	80072de <HAL_CAN_Init+0x202>
     {
       hcan->State= HAL_CAN_STATE_TIMEOUT;
 80072ca:	687b      	ldr	r3, [r7, #4]
 80072cc:	2203      	movs	r2, #3
 80072ce:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
       /* Process unlocked */
       __HAL_UNLOCK(hcan);
 80072d2:	687b      	ldr	r3, [r7, #4]
 80072d4:	2200      	movs	r2, #0
 80072d6:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
       return HAL_TIMEOUT;
 80072da:	2303      	movs	r3, #3
 80072dc:	e023      	b.n	8007326 <HAL_CAN_Init+0x24a>

  /* Get tick */
  tickstart = HAL_GetTick();

   /* Wait the acknowledge */
   while((hcan->Instance->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
 80072de:	687b      	ldr	r3, [r7, #4]
 80072e0:	681b      	ldr	r3, [r3, #0]
 80072e2:	685b      	ldr	r3, [r3, #4]
 80072e4:	f003 0301 	and.w	r3, r3, #1
 80072e8:	2b00      	cmp	r3, #0
 80072ea:	d1e7      	bne.n	80072bc <HAL_CAN_Init+0x1e0>
       return HAL_TIMEOUT;
     }
   }

    /* Check acknowledged */
    if ((hcan->Instance->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
 80072ec:	687b      	ldr	r3, [r7, #4]
 80072ee:	681b      	ldr	r3, [r3, #0]
 80072f0:	685b      	ldr	r3, [r3, #4]
 80072f2:	f003 0301 	and.w	r3, r3, #1
 80072f6:	2b00      	cmp	r3, #0
 80072f8:	d002      	beq.n	8007300 <HAL_CAN_Init+0x224>
    {
      InitStatus = CAN_INITSTATUS_FAILED;
 80072fa:	2300      	movs	r3, #0
 80072fc:	60fb      	str	r3, [r7, #12]
 80072fe:	e001      	b.n	8007304 <HAL_CAN_Init+0x228>
    }
    else
    {
      InitStatus = CAN_INITSTATUS_SUCCESS;
 8007300:	2301      	movs	r3, #1
 8007302:	60fb      	str	r3, [r7, #12]
    }
  }
 
  if(InitStatus == CAN_INITSTATUS_SUCCESS)
 8007304:	68fb      	ldr	r3, [r7, #12]
 8007306:	2b01      	cmp	r3, #1
 8007308:	d108      	bne.n	800731c <HAL_CAN_Init+0x240>
  {
    /* Set CAN error code to none */
    hcan->ErrorCode = HAL_CAN_ERROR_NONE;
 800730a:	687b      	ldr	r3, [r7, #4]
 800730c:	2200      	movs	r2, #0
 800730e:	63da      	str	r2, [r3, #60]	; 0x3c
    
    /* Initialize the CAN state */
    hcan->State = HAL_CAN_STATE_READY;
 8007310:	687b      	ldr	r3, [r7, #4]
 8007312:	2201      	movs	r2, #1
 8007314:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
    /* Return function status */
    return HAL_OK;
 8007318:	2300      	movs	r3, #0
 800731a:	e004      	b.n	8007326 <HAL_CAN_Init+0x24a>
  }
  else
  {
    /* Initialize the CAN state */
    hcan->State = HAL_CAN_STATE_ERROR;
 800731c:	687b      	ldr	r3, [r7, #4]
 800731e:	2204      	movs	r2, #4
 8007320:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    
    /* Return function status */
    return HAL_ERROR;
 8007324:	2301      	movs	r3, #1
  }
}
 8007326:	4618      	mov	r0, r3
 8007328:	3710      	adds	r7, #16
 800732a:	46bd      	mov	sp, r7
 800732c:	bd80      	pop	{r7, pc}
 800732e:	bf00      	nop

08007330 <HAL_CAN_ConfigFilter>:
  * @param  sFilterConfig: pointer to a CAN_FilterConfTypeDef structure that
  *         contains the filter configuration information.
  * @retval None
  */
HAL_StatusTypeDef HAL_CAN_ConfigFilter(CAN_HandleTypeDef* hcan, CAN_FilterConfTypeDef* sFilterConfig)
{
 8007330:	b480      	push	{r7}
 8007332:	b085      	sub	sp, #20
 8007334:	af00      	add	r7, sp, #0
 8007336:	6078      	str	r0, [r7, #4]
 8007338:	6039      	str	r1, [r7, #0]
  uint32_t filternbrbitpos = 0;
 800733a:	2300      	movs	r3, #0
 800733c:	60fb      	str	r3, [r7, #12]
  assert_param(IS_CAN_FILTER_SCALE(sFilterConfig->FilterScale));
  assert_param(IS_CAN_FILTER_FIFO(sFilterConfig->FilterFIFOAssignment));
  assert_param(IS_FUNCTIONAL_STATE(sFilterConfig->FilterActivation));
  assert_param(IS_CAN_BANKNUMBER(sFilterConfig->BankNumber));
  
  filternbrbitpos = ((uint32_t)1) << sFilterConfig->FilterNumber;
 800733e:	683b      	ldr	r3, [r7, #0]
 8007340:	695b      	ldr	r3, [r3, #20]
 8007342:	461a      	mov	r2, r3
 8007344:	2301      	movs	r3, #1
 8007346:	4093      	lsls	r3, r2
 8007348:	60fb      	str	r3, [r7, #12]

  /* Initialisation mode for the filter */
  CAN1->FMR |= (uint32_t)CAN_FMR_FINIT;
 800734a:	4a5e      	ldr	r2, [pc, #376]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 800734c:	4b5d      	ldr	r3, [pc, #372]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 800734e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8007352:	f043 0301 	orr.w	r3, r3, #1
 8007356:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
  
  /* Select the start slave bank */
  CAN1->FMR &= ~((uint32_t)CAN_FMR_CAN2SB);
 800735a:	4a5a      	ldr	r2, [pc, #360]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 800735c:	4b59      	ldr	r3, [pc, #356]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 800735e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8007362:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
 8007366:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
  CAN1->FMR |= (uint32_t)(sFilterConfig->BankNumber << 8);
 800736a:	4956      	ldr	r1, [pc, #344]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 800736c:	4b55      	ldr	r3, [pc, #340]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 800736e:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 8007372:	683b      	ldr	r3, [r7, #0]
 8007374:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007376:	021b      	lsls	r3, r3, #8
 8007378:	4313      	orrs	r3, r2
 800737a:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
     
  /* Filter Deactivation */
  CAN1->FA1R &= ~(uint32_t)filternbrbitpos;
 800737e:	4951      	ldr	r1, [pc, #324]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 8007380:	4b50      	ldr	r3, [pc, #320]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 8007382:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 8007386:	68fb      	ldr	r3, [r7, #12]
 8007388:	43db      	mvns	r3, r3
 800738a:	4013      	ands	r3, r2
 800738c:	f8c1 321c 	str.w	r3, [r1, #540]	; 0x21c

  /* Filter Scale */
  if (sFilterConfig->FilterScale == CAN_FILTERSCALE_16BIT)
 8007390:	683b      	ldr	r3, [r7, #0]
 8007392:	69db      	ldr	r3, [r3, #28]
 8007394:	2b00      	cmp	r3, #0
 8007396:	d123      	bne.n	80073e0 <HAL_CAN_ConfigFilter+0xb0>
  {
    /* 16-bit scale for the filter */
    CAN1->FS1R &= ~(uint32_t)filternbrbitpos;
 8007398:	494a      	ldr	r1, [pc, #296]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 800739a:	4b4a      	ldr	r3, [pc, #296]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 800739c:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 80073a0:	68fb      	ldr	r3, [r7, #12]
 80073a2:	43db      	mvns	r3, r3
 80073a4:	4013      	ands	r3, r2
 80073a6:	f8c1 320c 	str.w	r3, [r1, #524]	; 0x20c

    /* First 16-bit identifier and First 16-bit mask */
    /* Or First 16-bit identifier and Second 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
 80073aa:	4846      	ldr	r0, [pc, #280]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 80073ac:	683b      	ldr	r3, [r7, #0]
 80073ae:	695b      	ldr	r3, [r3, #20]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16) |
 80073b0:	683a      	ldr	r2, [r7, #0]
 80073b2:	68d2      	ldr	r2, [r2, #12]
 80073b4:	0411      	lsls	r1, r2, #16
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
 80073b6:	683a      	ldr	r2, [r7, #0]
 80073b8:	6852      	ldr	r2, [r2, #4]
 80073ba:	b292      	uxth	r2, r2
    CAN1->FS1R &= ~(uint32_t)filternbrbitpos;

    /* First 16-bit identifier and First 16-bit mask */
    /* Or First 16-bit identifier and Second 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16) |
 80073bc:	430a      	orrs	r2, r1
    /* 16-bit scale for the filter */
    CAN1->FS1R &= ~(uint32_t)filternbrbitpos;

    /* First 16-bit identifier and First 16-bit mask */
    /* Or First 16-bit identifier and Second 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
 80073be:	3348      	adds	r3, #72	; 0x48
 80073c0:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);

    /* Second 16-bit identifier and Second 16-bit mask */
    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
 80073c4:	483f      	ldr	r0, [pc, #252]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 80073c6:	683b      	ldr	r3, [r7, #0]
 80073c8:	695b      	ldr	r3, [r3, #20]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
 80073ca:	683a      	ldr	r2, [r7, #0]
 80073cc:	6892      	ldr	r2, [r2, #8]
 80073ce:	0411      	lsls	r1, r2, #16
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh);
 80073d0:	683a      	ldr	r2, [r7, #0]
 80073d2:	6812      	ldr	r2, [r2, #0]
 80073d4:	b292      	uxth	r2, r2
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);

    /* Second 16-bit identifier and Second 16-bit mask */
    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
 80073d6:	430a      	orrs	r2, r1
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);

    /* Second 16-bit identifier and Second 16-bit mask */
    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
 80073d8:	3348      	adds	r3, #72	; 0x48
 80073da:	00db      	lsls	r3, r3, #3
 80073dc:	4403      	add	r3, r0
 80073de:	605a      	str	r2, [r3, #4]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh);
  }

  if (sFilterConfig->FilterScale == CAN_FILTERSCALE_32BIT)
 80073e0:	683b      	ldr	r3, [r7, #0]
 80073e2:	69db      	ldr	r3, [r3, #28]
 80073e4:	2b01      	cmp	r3, #1
 80073e6:	d122      	bne.n	800742e <HAL_CAN_ConfigFilter+0xfe>
  {
    /* 32-bit scale for the filter */
    CAN1->FS1R |= filternbrbitpos;
 80073e8:	4936      	ldr	r1, [pc, #216]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 80073ea:	4b36      	ldr	r3, [pc, #216]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 80073ec:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 80073f0:	68fb      	ldr	r3, [r7, #12]
 80073f2:	4313      	orrs	r3, r2
 80073f4:	f8c1 320c 	str.w	r3, [r1, #524]	; 0x20c
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
 80073f8:	4832      	ldr	r0, [pc, #200]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 80073fa:	683b      	ldr	r3, [r7, #0]
 80073fc:	695b      	ldr	r3, [r3, #20]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
 80073fe:	683a      	ldr	r2, [r7, #0]
 8007400:	6812      	ldr	r2, [r2, #0]
 8007402:	0411      	lsls	r1, r2, #16
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
 8007404:	683a      	ldr	r2, [r7, #0]
 8007406:	6852      	ldr	r2, [r2, #4]
 8007408:	b292      	uxth	r2, r2
  {
    /* 32-bit scale for the filter */
    CAN1->FS1R |= filternbrbitpos;
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
 800740a:	430a      	orrs	r2, r1
  if (sFilterConfig->FilterScale == CAN_FILTERSCALE_32BIT)
  {
    /* 32-bit scale for the filter */
    CAN1->FS1R |= filternbrbitpos;
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
 800740c:	3348      	adds	r3, #72	; 0x48
 800740e:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
    /* 32-bit mask or Second 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
 8007412:	482c      	ldr	r0, [pc, #176]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 8007414:	683b      	ldr	r3, [r7, #0]
 8007416:	695b      	ldr	r3, [r3, #20]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
 8007418:	683a      	ldr	r2, [r7, #0]
 800741a:	6892      	ldr	r2, [r2, #8]
 800741c:	0411      	lsls	r1, r2, #16
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow);
 800741e:	683a      	ldr	r2, [r7, #0]
 8007420:	68d2      	ldr	r2, [r2, #12]
 8007422:	b292      	uxth	r2, r2
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
    /* 32-bit mask or Second 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
 8007424:	430a      	orrs	r2, r1
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
    /* 32-bit mask or Second 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
 8007426:	3348      	adds	r3, #72	; 0x48
 8007428:	00db      	lsls	r3, r3, #3
 800742a:	4403      	add	r3, r0
 800742c:	605a      	str	r2, [r3, #4]
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow);
  }

  /* Filter Mode */
  if (sFilterConfig->FilterMode == CAN_FILTERMODE_IDMASK)
 800742e:	683b      	ldr	r3, [r7, #0]
 8007430:	699b      	ldr	r3, [r3, #24]
 8007432:	2b00      	cmp	r3, #0
 8007434:	d109      	bne.n	800744a <HAL_CAN_ConfigFilter+0x11a>
  {
    /*Id/Mask mode for the filter*/
    CAN1->FM1R &= ~(uint32_t)filternbrbitpos;
 8007436:	4923      	ldr	r1, [pc, #140]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 8007438:	4b22      	ldr	r3, [pc, #136]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 800743a:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 800743e:	68fb      	ldr	r3, [r7, #12]
 8007440:	43db      	mvns	r3, r3
 8007442:	4013      	ands	r3, r2
 8007444:	f8c1 3204 	str.w	r3, [r1, #516]	; 0x204
 8007448:	e007      	b.n	800745a <HAL_CAN_ConfigFilter+0x12a>
  }
  else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
  {
    /*Identifier list mode for the filter*/
    CAN1->FM1R |= (uint32_t)filternbrbitpos;
 800744a:	491e      	ldr	r1, [pc, #120]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 800744c:	4b1d      	ldr	r3, [pc, #116]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 800744e:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 8007452:	68fb      	ldr	r3, [r7, #12]
 8007454:	4313      	orrs	r3, r2
 8007456:	f8c1 3204 	str.w	r3, [r1, #516]	; 0x204
  }

  /* Filter FIFO assignment */
  if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO0)
 800745a:	683b      	ldr	r3, [r7, #0]
 800745c:	691b      	ldr	r3, [r3, #16]
 800745e:	2b00      	cmp	r3, #0
 8007460:	d108      	bne.n	8007474 <HAL_CAN_ConfigFilter+0x144>
  {
    /* FIFO 0 assignation for the filter */
    CAN1->FFA1R &= ~(uint32_t)filternbrbitpos;
 8007462:	4918      	ldr	r1, [pc, #96]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 8007464:	4b17      	ldr	r3, [pc, #92]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 8007466:	f8d3 2214 	ldr.w	r2, [r3, #532]	; 0x214
 800746a:	68fb      	ldr	r3, [r7, #12]
 800746c:	43db      	mvns	r3, r3
 800746e:	4013      	ands	r3, r2
 8007470:	f8c1 3214 	str.w	r3, [r1, #532]	; 0x214
  }

  if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO1)
 8007474:	683b      	ldr	r3, [r7, #0]
 8007476:	691b      	ldr	r3, [r3, #16]
 8007478:	2b01      	cmp	r3, #1
 800747a:	d107      	bne.n	800748c <HAL_CAN_ConfigFilter+0x15c>
  {
    /* FIFO 1 assignation for the filter */
    CAN1->FFA1R |= (uint32_t)filternbrbitpos;
 800747c:	4911      	ldr	r1, [pc, #68]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 800747e:	4b11      	ldr	r3, [pc, #68]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 8007480:	f8d3 2214 	ldr.w	r2, [r3, #532]	; 0x214
 8007484:	68fb      	ldr	r3, [r7, #12]
 8007486:	4313      	orrs	r3, r2
 8007488:	f8c1 3214 	str.w	r3, [r1, #532]	; 0x214
  }
  
  /* Filter activation */
  if (sFilterConfig->FilterActivation == ENABLE)
 800748c:	683b      	ldr	r3, [r7, #0]
 800748e:	6a1b      	ldr	r3, [r3, #32]
 8007490:	2b01      	cmp	r3, #1
 8007492:	d107      	bne.n	80074a4 <HAL_CAN_ConfigFilter+0x174>
  {
    CAN1->FA1R |= filternbrbitpos;
 8007494:	490b      	ldr	r1, [pc, #44]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 8007496:	4b0b      	ldr	r3, [pc, #44]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 8007498:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 800749c:	68fb      	ldr	r3, [r7, #12]
 800749e:	4313      	orrs	r3, r2
 80074a0:	f8c1 321c 	str.w	r3, [r1, #540]	; 0x21c
  }

  /* Leave the initialisation mode for the filter */
  CAN1->FMR &= ~((uint32_t)CAN_FMR_FINIT);
 80074a4:	4a07      	ldr	r2, [pc, #28]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 80074a6:	4b07      	ldr	r3, [pc, #28]	; (80074c4 <HAL_CAN_ConfigFilter+0x194>)
 80074a8:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 80074ac:	f023 0301 	bic.w	r3, r3, #1
 80074b0:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
  
  /* Return function status */
  return HAL_OK;
 80074b4:	2300      	movs	r3, #0
}
 80074b6:	4618      	mov	r0, r3
 80074b8:	3714      	adds	r7, #20
 80074ba:	46bd      	mov	sp, r7
 80074bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80074c0:	4770      	bx	lr
 80074c2:	bf00      	nop
 80074c4:	40006400 	.word	0x40006400

080074c8 <HAL_CAN_DeInit>:
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_DeInit(CAN_HandleTypeDef* hcan)
{
 80074c8:	b580      	push	{r7, lr}
 80074ca:	b082      	sub	sp, #8
 80074cc:	af00      	add	r7, sp, #0
 80074ce:	6078      	str	r0, [r7, #4]
  /* Check CAN handle */
  if(hcan == NULL)
 80074d0:	687b      	ldr	r3, [r7, #4]
 80074d2:	2b00      	cmp	r3, #0
 80074d4:	d101      	bne.n	80074da <HAL_CAN_DeInit+0x12>
  {
     return HAL_ERROR;
 80074d6:	2301      	movs	r3, #1
 80074d8:	e00f      	b.n	80074fa <HAL_CAN_DeInit+0x32>
  
  /* Check the parameters */
  assert_param(IS_CAN_ALL_INSTANCE(hcan->Instance));
  
  /* Change CAN state */
  hcan->State = HAL_CAN_STATE_BUSY;
 80074da:	687b      	ldr	r3, [r7, #4]
 80074dc:	2202      	movs	r2, #2
 80074de:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  /* DeInit the low level hardware */
  HAL_CAN_MspDeInit(hcan);
 80074e2:	6878      	ldr	r0, [r7, #4]
 80074e4:	f000 f80e 	bl	8007504 <HAL_CAN_MspDeInit>
  
  /* Change CAN state */
  hcan->State = HAL_CAN_STATE_RESET;
 80074e8:	687b      	ldr	r3, [r7, #4]
 80074ea:	2200      	movs	r2, #0
 80074ec:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  /* Release Lock */
  __HAL_UNLOCK(hcan);
 80074f0:	687b      	ldr	r3, [r7, #4]
 80074f2:	2200      	movs	r2, #0
 80074f4:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  /* Return function status */
  return HAL_OK;
 80074f8:	2300      	movs	r3, #0
}
 80074fa:	4618      	mov	r0, r3
 80074fc:	3708      	adds	r7, #8
 80074fe:	46bd      	mov	sp, r7
 8007500:	bd80      	pop	{r7, pc}
 8007502:	bf00      	nop

08007504 <HAL_CAN_MspDeInit>:
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.  
  * @retval None
  */
__weak void HAL_CAN_MspDeInit(CAN_HandleTypeDef* hcan)
{
 8007504:	b480      	push	{r7}
 8007506:	b083      	sub	sp, #12
 8007508:	af00      	add	r7, sp, #0
 800750a:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_MspDeInit could be implemented in the user file
   */ 
}
 800750c:	370c      	adds	r7, #12
 800750e:	46bd      	mov	sp, r7
 8007510:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007514:	4770      	bx	lr
 8007516:	bf00      	nop

08007518 <HAL_CAN_Transmit>:
  *         the configuration information for the specified CAN.  
  * @param  Timeout: Specify Timeout value   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Transmit(CAN_HandleTypeDef* hcan, uint32_t Timeout)
{
 8007518:	b580      	push	{r7, lr}
 800751a:	b084      	sub	sp, #16
 800751c:	af00      	add	r7, sp, #0
 800751e:	6078      	str	r0, [r7, #4]
 8007520:	6039      	str	r1, [r7, #0]
  uint32_t  transmitmailbox = 5;
 8007522:	2305      	movs	r3, #5
 8007524:	60fb      	str	r3, [r7, #12]
  uint32_t tickstart = 0;
 8007526:	2300      	movs	r3, #0
 8007528:	60bb      	str	r3, [r7, #8]
  assert_param(IS_CAN_IDTYPE(hcan->pTxMsg->IDE));
  assert_param(IS_CAN_RTR(hcan->pTxMsg->RTR));
  assert_param(IS_CAN_DLC(hcan->pTxMsg->DLC));
  
  /* Process locked */
  __HAL_LOCK(hcan);
 800752a:	687b      	ldr	r3, [r7, #4]
 800752c:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 8007530:	2b01      	cmp	r3, #1
 8007532:	d101      	bne.n	8007538 <HAL_CAN_Transmit+0x20>
 8007534:	2302      	movs	r3, #2
 8007536:	e156      	b.n	80077e6 <HAL_CAN_Transmit+0x2ce>
 8007538:	687b      	ldr	r3, [r7, #4]
 800753a:	2201      	movs	r2, #1
 800753c:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  if(hcan->State == HAL_CAN_STATE_BUSY_RX) 
 8007540:	687b      	ldr	r3, [r7, #4]
 8007542:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8007546:	b2db      	uxtb	r3, r3
 8007548:	2b22      	cmp	r3, #34	; 0x22
 800754a:	d104      	bne.n	8007556 <HAL_CAN_Transmit+0x3e>
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_TX_RX;
 800754c:	687b      	ldr	r3, [r7, #4]
 800754e:	2232      	movs	r2, #50	; 0x32
 8007550:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
 8007554:	e003      	b.n	800755e <HAL_CAN_Transmit+0x46>
  }
  else
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_TX;
 8007556:	687b      	ldr	r3, [r7, #4]
 8007558:	2212      	movs	r2, #18
 800755a:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  }
  
  /* Select one empty transmit mailbox */
  if ((hcan->Instance->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
 800755e:	687b      	ldr	r3, [r7, #4]
 8007560:	681b      	ldr	r3, [r3, #0]
 8007562:	689b      	ldr	r3, [r3, #8]
 8007564:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8007568:	2b00      	cmp	r3, #0
 800756a:	d002      	beq.n	8007572 <HAL_CAN_Transmit+0x5a>
  {
    transmitmailbox = 0;
 800756c:	2300      	movs	r3, #0
 800756e:	60fb      	str	r3, [r7, #12]
 8007570:	e015      	b.n	800759e <HAL_CAN_Transmit+0x86>
  }
  else if ((hcan->Instance->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
 8007572:	687b      	ldr	r3, [r7, #4]
 8007574:	681b      	ldr	r3, [r3, #0]
 8007576:	689b      	ldr	r3, [r3, #8]
 8007578:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 800757c:	2b00      	cmp	r3, #0
 800757e:	d002      	beq.n	8007586 <HAL_CAN_Transmit+0x6e>
  {
    transmitmailbox = 1;
 8007580:	2301      	movs	r3, #1
 8007582:	60fb      	str	r3, [r7, #12]
 8007584:	e00b      	b.n	800759e <HAL_CAN_Transmit+0x86>
  }
  else if ((hcan->Instance->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
 8007586:	687b      	ldr	r3, [r7, #4]
 8007588:	681b      	ldr	r3, [r3, #0]
 800758a:	689b      	ldr	r3, [r3, #8]
 800758c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8007590:	2b00      	cmp	r3, #0
 8007592:	d002      	beq.n	800759a <HAL_CAN_Transmit+0x82>
  {
    transmitmailbox = 2;
 8007594:	2302      	movs	r3, #2
 8007596:	60fb      	str	r3, [r7, #12]
 8007598:	e001      	b.n	800759e <HAL_CAN_Transmit+0x86>
  }
  else
  {
    transmitmailbox = CAN_TXSTATUS_NOMAILBOX;
 800759a:	2304      	movs	r3, #4
 800759c:	60fb      	str	r3, [r7, #12]
  }

  if (transmitmailbox != CAN_TXSTATUS_NOMAILBOX)
 800759e:	68fb      	ldr	r3, [r7, #12]
 80075a0:	2b04      	cmp	r3, #4
 80075a2:	f000 8117 	beq.w	80077d4 <HAL_CAN_Transmit+0x2bc>
  {
    /* Set up the Id */
    hcan->Instance->sTxMailBox[transmitmailbox].TIR &= CAN_TI0R_TXRQ;
 80075a6:	687b      	ldr	r3, [r7, #4]
 80075a8:	6819      	ldr	r1, [r3, #0]
 80075aa:	687b      	ldr	r3, [r7, #4]
 80075ac:	681a      	ldr	r2, [r3, #0]
 80075ae:	68fb      	ldr	r3, [r7, #12]
 80075b0:	3318      	adds	r3, #24
 80075b2:	011b      	lsls	r3, r3, #4
 80075b4:	4413      	add	r3, r2
 80075b6:	681b      	ldr	r3, [r3, #0]
 80075b8:	f003 0201 	and.w	r2, r3, #1
 80075bc:	68fb      	ldr	r3, [r7, #12]
 80075be:	3318      	adds	r3, #24
 80075c0:	011b      	lsls	r3, r3, #4
 80075c2:	440b      	add	r3, r1
 80075c4:	601a      	str	r2, [r3, #0]
    if (hcan->pTxMsg->IDE == CAN_ID_STD)
 80075c6:	687b      	ldr	r3, [r7, #4]
 80075c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80075ca:	689b      	ldr	r3, [r3, #8]
 80075cc:	2b00      	cmp	r3, #0
 80075ce:	d117      	bne.n	8007600 <HAL_CAN_Transmit+0xe8>
    {
      assert_param(IS_CAN_STDID(hcan->pTxMsg->StdId));  
      hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->StdId << 21) | \
 80075d0:	687b      	ldr	r3, [r7, #4]
 80075d2:	6819      	ldr	r1, [r3, #0]
 80075d4:	687b      	ldr	r3, [r7, #4]
 80075d6:	681a      	ldr	r2, [r3, #0]
 80075d8:	68fb      	ldr	r3, [r7, #12]
 80075da:	3318      	adds	r3, #24
 80075dc:	011b      	lsls	r3, r3, #4
 80075de:	4413      	add	r3, r2
 80075e0:	681a      	ldr	r2, [r3, #0]
 80075e2:	687b      	ldr	r3, [r7, #4]
 80075e4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80075e6:	681b      	ldr	r3, [r3, #0]
 80075e8:	0558      	lsls	r0, r3, #21
                                                  hcan->pTxMsg->RTR);
 80075ea:	687b      	ldr	r3, [r7, #4]
 80075ec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80075ee:	68db      	ldr	r3, [r3, #12]
    /* Set up the Id */
    hcan->Instance->sTxMailBox[transmitmailbox].TIR &= CAN_TI0R_TXRQ;
    if (hcan->pTxMsg->IDE == CAN_ID_STD)
    {
      assert_param(IS_CAN_STDID(hcan->pTxMsg->StdId));  
      hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->StdId << 21) | \
 80075f0:	4303      	orrs	r3, r0
 80075f2:	431a      	orrs	r2, r3
 80075f4:	68fb      	ldr	r3, [r7, #12]
 80075f6:	3318      	adds	r3, #24
 80075f8:	011b      	lsls	r3, r3, #4
 80075fa:	440b      	add	r3, r1
 80075fc:	601a      	str	r2, [r3, #0]
 80075fe:	e01a      	b.n	8007636 <HAL_CAN_Transmit+0x11e>
                                                  hcan->pTxMsg->RTR);
    }
    else
    {
      assert_param(IS_CAN_EXTID(hcan->pTxMsg->ExtId));
      hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->ExtId << 3) | \
 8007600:	687b      	ldr	r3, [r7, #4]
 8007602:	6819      	ldr	r1, [r3, #0]
 8007604:	687b      	ldr	r3, [r7, #4]
 8007606:	681a      	ldr	r2, [r3, #0]
 8007608:	68fb      	ldr	r3, [r7, #12]
 800760a:	3318      	adds	r3, #24
 800760c:	011b      	lsls	r3, r3, #4
 800760e:	4413      	add	r3, r2
 8007610:	681a      	ldr	r2, [r3, #0]
 8007612:	687b      	ldr	r3, [r7, #4]
 8007614:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007616:	685b      	ldr	r3, [r3, #4]
 8007618:	00d8      	lsls	r0, r3, #3
                                                  hcan->pTxMsg->IDE | \
 800761a:	687b      	ldr	r3, [r7, #4]
 800761c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800761e:	689b      	ldr	r3, [r3, #8]
                                                  hcan->pTxMsg->RTR);
    }
    else
    {
      assert_param(IS_CAN_EXTID(hcan->pTxMsg->ExtId));
      hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->ExtId << 3) | \
 8007620:	4318      	orrs	r0, r3
                                                  hcan->pTxMsg->IDE | \
                                                  hcan->pTxMsg->RTR);
 8007622:	687b      	ldr	r3, [r7, #4]
 8007624:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007626:	68db      	ldr	r3, [r3, #12]
    }
    else
    {
      assert_param(IS_CAN_EXTID(hcan->pTxMsg->ExtId));
      hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->ExtId << 3) | \
                                                  hcan->pTxMsg->IDE | \
 8007628:	4303      	orrs	r3, r0
                                                  hcan->pTxMsg->RTR);
    }
    else
    {
      assert_param(IS_CAN_EXTID(hcan->pTxMsg->ExtId));
      hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->ExtId << 3) | \
 800762a:	431a      	orrs	r2, r3
 800762c:	68fb      	ldr	r3, [r7, #12]
 800762e:	3318      	adds	r3, #24
 8007630:	011b      	lsls	r3, r3, #4
 8007632:	440b      	add	r3, r1
 8007634:	601a      	str	r2, [r3, #0]
                                                  hcan->pTxMsg->IDE | \
                                                  hcan->pTxMsg->RTR);
    }
    
    /* Set up the DLC */
    hcan->pTxMsg->DLC &= (uint8_t)0x0000000F;
 8007636:	687b      	ldr	r3, [r7, #4]
 8007638:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800763a:	687a      	ldr	r2, [r7, #4]
 800763c:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800763e:	6912      	ldr	r2, [r2, #16]
 8007640:	f002 020f 	and.w	r2, r2, #15
 8007644:	611a      	str	r2, [r3, #16]
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR &= (uint32_t)0xFFFFFFF0;
 8007646:	687b      	ldr	r3, [r7, #4]
 8007648:	6819      	ldr	r1, [r3, #0]
 800764a:	687b      	ldr	r3, [r7, #4]
 800764c:	681a      	ldr	r2, [r3, #0]
 800764e:	68fb      	ldr	r3, [r7, #12]
 8007650:	3318      	adds	r3, #24
 8007652:	011b      	lsls	r3, r3, #4
 8007654:	4413      	add	r3, r2
 8007656:	685b      	ldr	r3, [r3, #4]
 8007658:	f023 020f 	bic.w	r2, r3, #15
 800765c:	68fb      	ldr	r3, [r7, #12]
 800765e:	3318      	adds	r3, #24
 8007660:	011b      	lsls	r3, r3, #4
 8007662:	440b      	add	r3, r1
 8007664:	605a      	str	r2, [r3, #4]
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR |= hcan->pTxMsg->DLC;
 8007666:	687b      	ldr	r3, [r7, #4]
 8007668:	6819      	ldr	r1, [r3, #0]
 800766a:	687b      	ldr	r3, [r7, #4]
 800766c:	681a      	ldr	r2, [r3, #0]
 800766e:	68fb      	ldr	r3, [r7, #12]
 8007670:	3318      	adds	r3, #24
 8007672:	011b      	lsls	r3, r3, #4
 8007674:	4413      	add	r3, r2
 8007676:	685a      	ldr	r2, [r3, #4]
 8007678:	687b      	ldr	r3, [r7, #4]
 800767a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800767c:	691b      	ldr	r3, [r3, #16]
 800767e:	431a      	orrs	r2, r3
 8007680:	68fb      	ldr	r3, [r7, #12]
 8007682:	3318      	adds	r3, #24
 8007684:	011b      	lsls	r3, r3, #4
 8007686:	440b      	add	r3, r1
 8007688:	605a      	str	r2, [r3, #4]

    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
 800768a:	687b      	ldr	r3, [r7, #4]
 800768c:	6819      	ldr	r1, [r3, #0]
 800768e:	687b      	ldr	r3, [r7, #4]
 8007690:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007692:	7ddb      	ldrb	r3, [r3, #23]
 8007694:	061a      	lsls	r2, r3, #24
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
 8007696:	687b      	ldr	r3, [r7, #4]
 8007698:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800769a:	7d9b      	ldrb	r3, [r3, #22]
 800769c:	041b      	lsls	r3, r3, #16
    hcan->pTxMsg->DLC &= (uint8_t)0x0000000F;
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR &= (uint32_t)0xFFFFFFF0;
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR |= hcan->pTxMsg->DLC;

    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
 800769e:	431a      	orrs	r2, r3
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
 80076a0:	687b      	ldr	r3, [r7, #4]
 80076a2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80076a4:	7d5b      	ldrb	r3, [r3, #21]
 80076a6:	021b      	lsls	r3, r3, #8
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR &= (uint32_t)0xFFFFFFF0;
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR |= hcan->pTxMsg->DLC;

    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
 80076a8:	4313      	orrs	r3, r2
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
                                             ((uint32_t)hcan->pTxMsg->Data[0]));
 80076aa:	687a      	ldr	r2, [r7, #4]
 80076ac:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80076ae:	7d12      	ldrb	r2, [r2, #20]
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR |= hcan->pTxMsg->DLC;

    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
 80076b0:	431a      	orrs	r2, r3
    hcan->pTxMsg->DLC &= (uint8_t)0x0000000F;
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR &= (uint32_t)0xFFFFFFF0;
    hcan->Instance->sTxMailBox[transmitmailbox].TDTR |= hcan->pTxMsg->DLC;

    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
 80076b2:	68fb      	ldr	r3, [r7, #12]
 80076b4:	011b      	lsls	r3, r3, #4
 80076b6:	440b      	add	r3, r1
 80076b8:	f503 73c4 	add.w	r3, r3, #392	; 0x188
 80076bc:	601a      	str	r2, [r3, #0]
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
                                             ((uint32_t)hcan->pTxMsg->Data[0]));
    hcan->Instance->sTxMailBox[transmitmailbox].TDHR = (((uint32_t)hcan->pTxMsg->Data[7] << 24) | 
 80076be:	687b      	ldr	r3, [r7, #4]
 80076c0:	6819      	ldr	r1, [r3, #0]
 80076c2:	687b      	ldr	r3, [r7, #4]
 80076c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80076c6:	7edb      	ldrb	r3, [r3, #27]
 80076c8:	061a      	lsls	r2, r3, #24
                                             ((uint32_t)hcan->pTxMsg->Data[6] << 16) |
 80076ca:	687b      	ldr	r3, [r7, #4]
 80076cc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80076ce:	7e9b      	ldrb	r3, [r3, #26]
 80076d0:	041b      	lsls	r3, r3, #16
    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
                                             ((uint32_t)hcan->pTxMsg->Data[0]));
    hcan->Instance->sTxMailBox[transmitmailbox].TDHR = (((uint32_t)hcan->pTxMsg->Data[7] << 24) | 
 80076d2:	431a      	orrs	r2, r3
                                             ((uint32_t)hcan->pTxMsg->Data[6] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[5] << 8) |
 80076d4:	687b      	ldr	r3, [r7, #4]
 80076d6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80076d8:	7e5b      	ldrb	r3, [r3, #25]
 80076da:	021b      	lsls	r3, r3, #8
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
                                             ((uint32_t)hcan->pTxMsg->Data[0]));
    hcan->Instance->sTxMailBox[transmitmailbox].TDHR = (((uint32_t)hcan->pTxMsg->Data[7] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[6] << 16) |
 80076dc:	4313      	orrs	r3, r2
                                             ((uint32_t)hcan->pTxMsg->Data[5] << 8) |
                                             ((uint32_t)hcan->pTxMsg->Data[4]));
 80076de:	687a      	ldr	r2, [r7, #4]
 80076e0:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80076e2:	7e12      	ldrb	r2, [r2, #24]
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
                                             ((uint32_t)hcan->pTxMsg->Data[0]));
    hcan->Instance->sTxMailBox[transmitmailbox].TDHR = (((uint32_t)hcan->pTxMsg->Data[7] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[6] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[5] << 8) |
 80076e4:	431a      	orrs	r2, r3
    /* Set up the data field */
    hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
                                             ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
                                             ((uint32_t)hcan->pTxMsg->Data[0]));
    hcan->Instance->sTxMailBox[transmitmailbox].TDHR = (((uint32_t)hcan->pTxMsg->Data[7] << 24) | 
 80076e6:	68fb      	ldr	r3, [r7, #12]
 80076e8:	011b      	lsls	r3, r3, #4
 80076ea:	440b      	add	r3, r1
 80076ec:	f503 73c4 	add.w	r3, r3, #392	; 0x188
 80076f0:	605a      	str	r2, [r3, #4]
                                             ((uint32_t)hcan->pTxMsg->Data[6] << 16) |
                                             ((uint32_t)hcan->pTxMsg->Data[5] << 8) |
                                             ((uint32_t)hcan->pTxMsg->Data[4]));
    /* Request transmission */
    hcan->Instance->sTxMailBox[transmitmailbox].TIR |= CAN_TI0R_TXRQ;
 80076f2:	687b      	ldr	r3, [r7, #4]
 80076f4:	6819      	ldr	r1, [r3, #0]
 80076f6:	687b      	ldr	r3, [r7, #4]
 80076f8:	681a      	ldr	r2, [r3, #0]
 80076fa:	68fb      	ldr	r3, [r7, #12]
 80076fc:	3318      	adds	r3, #24
 80076fe:	011b      	lsls	r3, r3, #4
 8007700:	4413      	add	r3, r2
 8007702:	681b      	ldr	r3, [r3, #0]
 8007704:	f043 0201 	orr.w	r2, r3, #1
 8007708:	68fb      	ldr	r3, [r7, #12]
 800770a:	3318      	adds	r3, #24
 800770c:	011b      	lsls	r3, r3, #4
 800770e:	440b      	add	r3, r1
 8007710:	601a      	str	r2, [r3, #0]
  
  /* Get tick */ 
  tickstart = HAL_GetTick();
 8007712:	f7fe fda1 	bl	8006258 <HAL_GetTick>
 8007716:	60b8      	str	r0, [r7, #8]
  
    /* Check End of transmission flag */
    while(!(__HAL_CAN_TRANSMIT_STATUS(hcan, transmitmailbox)))
 8007718:	e018      	b.n	800774c <HAL_CAN_Transmit+0x234>
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 800771a:	683b      	ldr	r3, [r7, #0]
 800771c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007720:	d014      	beq.n	800774c <HAL_CAN_Transmit+0x234>
      {
       if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8007722:	683b      	ldr	r3, [r7, #0]
 8007724:	2b00      	cmp	r3, #0
 8007726:	d007      	beq.n	8007738 <HAL_CAN_Transmit+0x220>
 8007728:	f7fe fd96 	bl	8006258 <HAL_GetTick>
 800772c:	4602      	mov	r2, r0
 800772e:	68bb      	ldr	r3, [r7, #8]
 8007730:	1ad2      	subs	r2, r2, r3
 8007732:	683b      	ldr	r3, [r7, #0]
 8007734:	429a      	cmp	r2, r3
 8007736:	d909      	bls.n	800774c <HAL_CAN_Transmit+0x234>
       {
         hcan->State = HAL_CAN_STATE_TIMEOUT;
 8007738:	687b      	ldr	r3, [r7, #4]
 800773a:	2203      	movs	r2, #3
 800773c:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
         /* Process unlocked */
         __HAL_UNLOCK(hcan);
 8007740:	687b      	ldr	r3, [r7, #4]
 8007742:	2200      	movs	r2, #0
 8007744:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
         return HAL_TIMEOUT;
 8007748:	2303      	movs	r3, #3
 800774a:	e04c      	b.n	80077e6 <HAL_CAN_Transmit+0x2ce>
  
  /* Get tick */ 
  tickstart = HAL_GetTick();
  
    /* Check End of transmission flag */
    while(!(__HAL_CAN_TRANSMIT_STATUS(hcan, transmitmailbox)))
 800774c:	68fb      	ldr	r3, [r7, #12]
 800774e:	2b00      	cmp	r3, #0
 8007750:	d10b      	bne.n	800776a <HAL_CAN_Transmit+0x252>
 8007752:	687b      	ldr	r3, [r7, #4]
 8007754:	681b      	ldr	r3, [r3, #0]
 8007756:	689a      	ldr	r2, [r3, #8]
 8007758:	4b25      	ldr	r3, [pc, #148]	; (80077f0 <HAL_CAN_Transmit+0x2d8>)
 800775a:	4013      	ands	r3, r2
 800775c:	4a24      	ldr	r2, [pc, #144]	; (80077f0 <HAL_CAN_Transmit+0x2d8>)
 800775e:	4293      	cmp	r3, r2
 8007760:	bf14      	ite	ne
 8007762:	2301      	movne	r3, #1
 8007764:	2300      	moveq	r3, #0
 8007766:	b2db      	uxtb	r3, r3
 8007768:	e019      	b.n	800779e <HAL_CAN_Transmit+0x286>
 800776a:	68fb      	ldr	r3, [r7, #12]
 800776c:	2b01      	cmp	r3, #1
 800776e:	d10b      	bne.n	8007788 <HAL_CAN_Transmit+0x270>
 8007770:	687b      	ldr	r3, [r7, #4]
 8007772:	681b      	ldr	r3, [r3, #0]
 8007774:	689a      	ldr	r2, [r3, #8]
 8007776:	4b1f      	ldr	r3, [pc, #124]	; (80077f4 <HAL_CAN_Transmit+0x2dc>)
 8007778:	4013      	ands	r3, r2
 800777a:	4a1e      	ldr	r2, [pc, #120]	; (80077f4 <HAL_CAN_Transmit+0x2dc>)
 800777c:	4293      	cmp	r3, r2
 800777e:	bf14      	ite	ne
 8007780:	2301      	movne	r3, #1
 8007782:	2300      	moveq	r3, #0
 8007784:	b2db      	uxtb	r3, r3
 8007786:	e00a      	b.n	800779e <HAL_CAN_Transmit+0x286>
 8007788:	687b      	ldr	r3, [r7, #4]
 800778a:	681b      	ldr	r3, [r3, #0]
 800778c:	689a      	ldr	r2, [r3, #8]
 800778e:	4b1a      	ldr	r3, [pc, #104]	; (80077f8 <HAL_CAN_Transmit+0x2e0>)
 8007790:	4013      	ands	r3, r2
 8007792:	4a19      	ldr	r2, [pc, #100]	; (80077f8 <HAL_CAN_Transmit+0x2e0>)
 8007794:	4293      	cmp	r3, r2
 8007796:	bf14      	ite	ne
 8007798:	2301      	movne	r3, #1
 800779a:	2300      	moveq	r3, #0
 800779c:	b2db      	uxtb	r3, r3
 800779e:	2b00      	cmp	r3, #0
 80077a0:	d1bb      	bne.n	800771a <HAL_CAN_Transmit+0x202>
         __HAL_UNLOCK(hcan);
         return HAL_TIMEOUT;
        }
      }
    }
    if(hcan->State == HAL_CAN_STATE_BUSY_TX_RX) 
 80077a2:	687b      	ldr	r3, [r7, #4]
 80077a4:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 80077a8:	b2db      	uxtb	r3, r3
 80077aa:	2b32      	cmp	r3, #50	; 0x32
 80077ac:	d108      	bne.n	80077c0 <HAL_CAN_Transmit+0x2a8>
    {
      /* Change CAN state */
      hcan->State = HAL_CAN_STATE_BUSY_RX;
 80077ae:	687b      	ldr	r3, [r7, #4]
 80077b0:	2222      	movs	r2, #34	; 0x22
 80077b2:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
      
      /* Process unlocked */
      __HAL_UNLOCK(hcan);
 80077b6:	687b      	ldr	r3, [r7, #4]
 80077b8:	2200      	movs	r2, #0
 80077ba:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
 80077be:	e007      	b.n	80077d0 <HAL_CAN_Transmit+0x2b8>
    }
    else
    {
      /* Change CAN state */
      hcan->State = HAL_CAN_STATE_READY;
 80077c0:	687b      	ldr	r3, [r7, #4]
 80077c2:	2201      	movs	r2, #1
 80077c4:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
      
      /* Process unlocked */
      __HAL_UNLOCK(hcan);
 80077c8:	687b      	ldr	r3, [r7, #4]
 80077ca:	2200      	movs	r2, #0
 80077cc:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    }
    
    /* Return function status */
    return HAL_OK;
 80077d0:	2300      	movs	r3, #0
 80077d2:	e008      	b.n	80077e6 <HAL_CAN_Transmit+0x2ce>
  }
  else
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_ERROR;
 80077d4:	687b      	ldr	r3, [r7, #4]
 80077d6:	2204      	movs	r2, #4
 80077d8:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

    /* Process unlocked */
    __HAL_UNLOCK(hcan);
 80077dc:	687b      	ldr	r3, [r7, #4]
 80077de:	2200      	movs	r2, #0
 80077e0:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

    /* Return function status */
    return HAL_ERROR;
 80077e4:	2301      	movs	r3, #1
  }
}
 80077e6:	4618      	mov	r0, r3
 80077e8:	3710      	adds	r7, #16
 80077ea:	46bd      	mov	sp, r7
 80077ec:	bd80      	pop	{r7, pc}
 80077ee:	bf00      	nop
 80077f0:	04000003 	.word	0x04000003
 80077f4:	08000300 	.word	0x08000300
 80077f8:	10030000 	.word	0x10030000

080077fc <HAL_CAN_Receive>:
  * @param  FIFONumber: FIFO Number value
  * @param  Timeout: Specify Timeout value 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Receive(CAN_HandleTypeDef* hcan, uint8_t FIFONumber, uint32_t Timeout)
{
 80077fc:	b580      	push	{r7, lr}
 80077fe:	b086      	sub	sp, #24
 8007800:	af00      	add	r7, sp, #0
 8007802:	60f8      	str	r0, [r7, #12]
 8007804:	460b      	mov	r3, r1
 8007806:	607a      	str	r2, [r7, #4]
 8007808:	72fb      	strb	r3, [r7, #11]
  uint32_t tickstart = 0;
 800780a:	2300      	movs	r3, #0
 800780c:	617b      	str	r3, [r7, #20]
   
  /* Check the parameters */
  assert_param(IS_CAN_FIFO(FIFONumber));
  
  /* Process locked */
  __HAL_LOCK(hcan);
 800780e:	68fb      	ldr	r3, [r7, #12]
 8007810:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 8007814:	2b01      	cmp	r3, #1
 8007816:	d101      	bne.n	800781c <HAL_CAN_Receive+0x20>
 8007818:	2302      	movs	r3, #2
 800781a:	e129      	b.n	8007a70 <HAL_CAN_Receive+0x274>
 800781c:	68fb      	ldr	r3, [r7, #12]
 800781e:	2201      	movs	r2, #1
 8007820:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  if(hcan->State == HAL_CAN_STATE_BUSY_TX) 
 8007824:	68fb      	ldr	r3, [r7, #12]
 8007826:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 800782a:	b2db      	uxtb	r3, r3
 800782c:	2b12      	cmp	r3, #18
 800782e:	d104      	bne.n	800783a <HAL_CAN_Receive+0x3e>
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_TX_RX;
 8007830:	68fb      	ldr	r3, [r7, #12]
 8007832:	2232      	movs	r2, #50	; 0x32
 8007834:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
 8007838:	e003      	b.n	8007842 <HAL_CAN_Receive+0x46>
  }
  else
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_RX;
 800783a:	68fb      	ldr	r3, [r7, #12]
 800783c:	2222      	movs	r2, #34	; 0x22
 800783e:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  }
    
  /* Get tick */ 
  tickstart = HAL_GetTick();
 8007842:	f7fe fd09 	bl	8006258 <HAL_GetTick>
 8007846:	6178      	str	r0, [r7, #20]
  
  /* Check pending message */
  while(__HAL_CAN_MSG_PENDING(hcan, FIFONumber) == 0)
 8007848:	e018      	b.n	800787c <HAL_CAN_Receive+0x80>
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 800784a:	687b      	ldr	r3, [r7, #4]
 800784c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007850:	d014      	beq.n	800787c <HAL_CAN_Receive+0x80>
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8007852:	687b      	ldr	r3, [r7, #4]
 8007854:	2b00      	cmp	r3, #0
 8007856:	d007      	beq.n	8007868 <HAL_CAN_Receive+0x6c>
 8007858:	f7fe fcfe 	bl	8006258 <HAL_GetTick>
 800785c:	4602      	mov	r2, r0
 800785e:	697b      	ldr	r3, [r7, #20]
 8007860:	1ad2      	subs	r2, r2, r3
 8007862:	687b      	ldr	r3, [r7, #4]
 8007864:	429a      	cmp	r2, r3
 8007866:	d909      	bls.n	800787c <HAL_CAN_Receive+0x80>
      {
        hcan->State = HAL_CAN_STATE_TIMEOUT;
 8007868:	68fb      	ldr	r3, [r7, #12]
 800786a:	2203      	movs	r2, #3
 800786c:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
        /* Process unlocked */
        __HAL_UNLOCK(hcan);
 8007870:	68fb      	ldr	r3, [r7, #12]
 8007872:	2200      	movs	r2, #0
 8007874:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
        return HAL_TIMEOUT;
 8007878:	2303      	movs	r3, #3
 800787a:	e0f9      	b.n	8007a70 <HAL_CAN_Receive+0x274>
    
  /* Get tick */ 
  tickstart = HAL_GetTick();
  
  /* Check pending message */
  while(__HAL_CAN_MSG_PENDING(hcan, FIFONumber) == 0)
 800787c:	7afb      	ldrb	r3, [r7, #11]
 800787e:	2b00      	cmp	r3, #0
 8007880:	d10b      	bne.n	800789a <HAL_CAN_Receive+0x9e>
 8007882:	68fb      	ldr	r3, [r7, #12]
 8007884:	681b      	ldr	r3, [r3, #0]
 8007886:	68db      	ldr	r3, [r3, #12]
 8007888:	b2db      	uxtb	r3, r3
 800788a:	f003 0303 	and.w	r3, r3, #3
 800788e:	2b00      	cmp	r3, #0
 8007890:	bf0c      	ite	eq
 8007892:	2301      	moveq	r3, #1
 8007894:	2300      	movne	r3, #0
 8007896:	b2db      	uxtb	r3, r3
 8007898:	e00a      	b.n	80078b0 <HAL_CAN_Receive+0xb4>
 800789a:	68fb      	ldr	r3, [r7, #12]
 800789c:	681b      	ldr	r3, [r3, #0]
 800789e:	691b      	ldr	r3, [r3, #16]
 80078a0:	b2db      	uxtb	r3, r3
 80078a2:	f003 0303 	and.w	r3, r3, #3
 80078a6:	2b00      	cmp	r3, #0
 80078a8:	bf0c      	ite	eq
 80078aa:	2301      	moveq	r3, #1
 80078ac:	2300      	movne	r3, #0
 80078ae:	b2db      	uxtb	r3, r3
 80078b0:	2b00      	cmp	r3, #0
 80078b2:	d1ca      	bne.n	800784a <HAL_CAN_Receive+0x4e>
      }
    }
  }
  
  /* Get the Id */
  hcan->pRxMsg->IDE = (uint8_t)0x04 & hcan->Instance->sFIFOMailBox[FIFONumber].RIR;
 80078b4:	68fb      	ldr	r3, [r7, #12]
 80078b6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80078b8:	68fa      	ldr	r2, [r7, #12]
 80078ba:	6811      	ldr	r1, [r2, #0]
 80078bc:	7afa      	ldrb	r2, [r7, #11]
 80078be:	321b      	adds	r2, #27
 80078c0:	0112      	lsls	r2, r2, #4
 80078c2:	440a      	add	r2, r1
 80078c4:	6812      	ldr	r2, [r2, #0]
 80078c6:	f002 0204 	and.w	r2, r2, #4
 80078ca:	609a      	str	r2, [r3, #8]
  if (hcan->pRxMsg->IDE == CAN_ID_STD)
 80078cc:	68fb      	ldr	r3, [r7, #12]
 80078ce:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80078d0:	689b      	ldr	r3, [r3, #8]
 80078d2:	2b00      	cmp	r3, #0
 80078d4:	d10b      	bne.n	80078ee <HAL_CAN_Receive+0xf2>
  {
    hcan->pRxMsg->StdId = (uint32_t)0x000007FF & (hcan->Instance->sFIFOMailBox[FIFONumber].RIR >> 21);
 80078d6:	68fb      	ldr	r3, [r7, #12]
 80078d8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80078da:	68fa      	ldr	r2, [r7, #12]
 80078dc:	6811      	ldr	r1, [r2, #0]
 80078de:	7afa      	ldrb	r2, [r7, #11]
 80078e0:	321b      	adds	r2, #27
 80078e2:	0112      	lsls	r2, r2, #4
 80078e4:	440a      	add	r2, r1
 80078e6:	6812      	ldr	r2, [r2, #0]
 80078e8:	0d52      	lsrs	r2, r2, #21
 80078ea:	601a      	str	r2, [r3, #0]
 80078ec:	e00a      	b.n	8007904 <HAL_CAN_Receive+0x108>
  }
  else
  {
    hcan->pRxMsg->ExtId = (uint32_t)0x1FFFFFFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RIR >> 3);
 80078ee:	68fb      	ldr	r3, [r7, #12]
 80078f0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80078f2:	68fa      	ldr	r2, [r7, #12]
 80078f4:	6811      	ldr	r1, [r2, #0]
 80078f6:	7afa      	ldrb	r2, [r7, #11]
 80078f8:	321b      	adds	r2, #27
 80078fa:	0112      	lsls	r2, r2, #4
 80078fc:	440a      	add	r2, r1
 80078fe:	6812      	ldr	r2, [r2, #0]
 8007900:	08d2      	lsrs	r2, r2, #3
 8007902:	605a      	str	r2, [r3, #4]
  }
  
  hcan->pRxMsg->RTR = (uint8_t)0x02 & hcan->Instance->sFIFOMailBox[FIFONumber].RIR;
 8007904:	68fb      	ldr	r3, [r7, #12]
 8007906:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007908:	68fa      	ldr	r2, [r7, #12]
 800790a:	6811      	ldr	r1, [r2, #0]
 800790c:	7afa      	ldrb	r2, [r7, #11]
 800790e:	321b      	adds	r2, #27
 8007910:	0112      	lsls	r2, r2, #4
 8007912:	440a      	add	r2, r1
 8007914:	6812      	ldr	r2, [r2, #0]
 8007916:	f002 0202 	and.w	r2, r2, #2
 800791a:	60da      	str	r2, [r3, #12]
  /* Get the DLC */
  hcan->pRxMsg->DLC = (uint8_t)0x0F & hcan->Instance->sFIFOMailBox[FIFONumber].RDTR;
 800791c:	68fb      	ldr	r3, [r7, #12]
 800791e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007920:	68fa      	ldr	r2, [r7, #12]
 8007922:	6811      	ldr	r1, [r2, #0]
 8007924:	7afa      	ldrb	r2, [r7, #11]
 8007926:	321b      	adds	r2, #27
 8007928:	0112      	lsls	r2, r2, #4
 800792a:	440a      	add	r2, r1
 800792c:	6852      	ldr	r2, [r2, #4]
 800792e:	f002 020f 	and.w	r2, r2, #15
 8007932:	611a      	str	r2, [r3, #16]
  /* Get the FMI */
  hcan->pRxMsg->FMI = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDTR >> 8);
 8007934:	68fb      	ldr	r3, [r7, #12]
 8007936:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007938:	68fa      	ldr	r2, [r7, #12]
 800793a:	6811      	ldr	r1, [r2, #0]
 800793c:	7afa      	ldrb	r2, [r7, #11]
 800793e:	321b      	adds	r2, #27
 8007940:	0112      	lsls	r2, r2, #4
 8007942:	440a      	add	r2, r1
 8007944:	6852      	ldr	r2, [r2, #4]
 8007946:	0a12      	lsrs	r2, r2, #8
 8007948:	b2d2      	uxtb	r2, r2
 800794a:	61da      	str	r2, [r3, #28]
  /* Get the data field */
  hcan->pRxMsg->Data[0] = (uint8_t)0xFF & hcan->Instance->sFIFOMailBox[FIFONumber].RDLR;
 800794c:	68fb      	ldr	r3, [r7, #12]
 800794e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007950:	68fa      	ldr	r2, [r7, #12]
 8007952:	6811      	ldr	r1, [r2, #0]
 8007954:	7afa      	ldrb	r2, [r7, #11]
 8007956:	0112      	lsls	r2, r2, #4
 8007958:	440a      	add	r2, r1
 800795a:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 800795e:	6812      	ldr	r2, [r2, #0]
 8007960:	b2d2      	uxtb	r2, r2
 8007962:	751a      	strb	r2, [r3, #20]
  hcan->pRxMsg->Data[1] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 8);
 8007964:	68fb      	ldr	r3, [r7, #12]
 8007966:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007968:	68fa      	ldr	r2, [r7, #12]
 800796a:	6811      	ldr	r1, [r2, #0]
 800796c:	7afa      	ldrb	r2, [r7, #11]
 800796e:	0112      	lsls	r2, r2, #4
 8007970:	440a      	add	r2, r1
 8007972:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8007976:	6812      	ldr	r2, [r2, #0]
 8007978:	0a12      	lsrs	r2, r2, #8
 800797a:	b2d2      	uxtb	r2, r2
 800797c:	755a      	strb	r2, [r3, #21]
  hcan->pRxMsg->Data[2] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 16);
 800797e:	68fb      	ldr	r3, [r7, #12]
 8007980:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007982:	68fa      	ldr	r2, [r7, #12]
 8007984:	6811      	ldr	r1, [r2, #0]
 8007986:	7afa      	ldrb	r2, [r7, #11]
 8007988:	0112      	lsls	r2, r2, #4
 800798a:	440a      	add	r2, r1
 800798c:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8007990:	6812      	ldr	r2, [r2, #0]
 8007992:	0c12      	lsrs	r2, r2, #16
 8007994:	b2d2      	uxtb	r2, r2
 8007996:	759a      	strb	r2, [r3, #22]
  hcan->pRxMsg->Data[3] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 24);
 8007998:	68fb      	ldr	r3, [r7, #12]
 800799a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800799c:	68fa      	ldr	r2, [r7, #12]
 800799e:	6811      	ldr	r1, [r2, #0]
 80079a0:	7afa      	ldrb	r2, [r7, #11]
 80079a2:	0112      	lsls	r2, r2, #4
 80079a4:	440a      	add	r2, r1
 80079a6:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 80079aa:	6812      	ldr	r2, [r2, #0]
 80079ac:	0e12      	lsrs	r2, r2, #24
 80079ae:	b2d2      	uxtb	r2, r2
 80079b0:	75da      	strb	r2, [r3, #23]
  hcan->pRxMsg->Data[4] = (uint8_t)0xFF & hcan->Instance->sFIFOMailBox[FIFONumber].RDHR;
 80079b2:	68fb      	ldr	r3, [r7, #12]
 80079b4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80079b6:	68fa      	ldr	r2, [r7, #12]
 80079b8:	6811      	ldr	r1, [r2, #0]
 80079ba:	7afa      	ldrb	r2, [r7, #11]
 80079bc:	0112      	lsls	r2, r2, #4
 80079be:	440a      	add	r2, r1
 80079c0:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 80079c4:	6852      	ldr	r2, [r2, #4]
 80079c6:	b2d2      	uxtb	r2, r2
 80079c8:	761a      	strb	r2, [r3, #24]
  hcan->pRxMsg->Data[5] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 8);
 80079ca:	68fb      	ldr	r3, [r7, #12]
 80079cc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80079ce:	68fa      	ldr	r2, [r7, #12]
 80079d0:	6811      	ldr	r1, [r2, #0]
 80079d2:	7afa      	ldrb	r2, [r7, #11]
 80079d4:	0112      	lsls	r2, r2, #4
 80079d6:	440a      	add	r2, r1
 80079d8:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 80079dc:	6852      	ldr	r2, [r2, #4]
 80079de:	0a12      	lsrs	r2, r2, #8
 80079e0:	b2d2      	uxtb	r2, r2
 80079e2:	765a      	strb	r2, [r3, #25]
  hcan->pRxMsg->Data[6] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 16);
 80079e4:	68fb      	ldr	r3, [r7, #12]
 80079e6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80079e8:	68fa      	ldr	r2, [r7, #12]
 80079ea:	6811      	ldr	r1, [r2, #0]
 80079ec:	7afa      	ldrb	r2, [r7, #11]
 80079ee:	0112      	lsls	r2, r2, #4
 80079f0:	440a      	add	r2, r1
 80079f2:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 80079f6:	6852      	ldr	r2, [r2, #4]
 80079f8:	0c12      	lsrs	r2, r2, #16
 80079fa:	b2d2      	uxtb	r2, r2
 80079fc:	769a      	strb	r2, [r3, #26]
  hcan->pRxMsg->Data[7] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 24);
 80079fe:	68fb      	ldr	r3, [r7, #12]
 8007a00:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007a02:	68fa      	ldr	r2, [r7, #12]
 8007a04:	6811      	ldr	r1, [r2, #0]
 8007a06:	7afa      	ldrb	r2, [r7, #11]
 8007a08:	0112      	lsls	r2, r2, #4
 8007a0a:	440a      	add	r2, r1
 8007a0c:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8007a10:	6852      	ldr	r2, [r2, #4]
 8007a12:	0e12      	lsrs	r2, r2, #24
 8007a14:	b2d2      	uxtb	r2, r2
 8007a16:	76da      	strb	r2, [r3, #27]
  
  /* Release the FIFO */
  if(FIFONumber == CAN_FIFO0)
 8007a18:	7afb      	ldrb	r3, [r7, #11]
 8007a1a:	2b00      	cmp	r3, #0
 8007a1c:	d108      	bne.n	8007a30 <HAL_CAN_Receive+0x234>
  {
    /* Release FIFO0 */
    __HAL_CAN_FIFO_RELEASE(hcan, CAN_FIFO0);
 8007a1e:	68fb      	ldr	r3, [r7, #12]
 8007a20:	681b      	ldr	r3, [r3, #0]
 8007a22:	68fa      	ldr	r2, [r7, #12]
 8007a24:	6812      	ldr	r2, [r2, #0]
 8007a26:	68d2      	ldr	r2, [r2, #12]
 8007a28:	f042 0220 	orr.w	r2, r2, #32
 8007a2c:	60da      	str	r2, [r3, #12]
 8007a2e:	e007      	b.n	8007a40 <HAL_CAN_Receive+0x244>
  }
  else /* FIFONumber == CAN_FIFO1 */
  {
    /* Release FIFO1 */
    __HAL_CAN_FIFO_RELEASE(hcan, CAN_FIFO1);
 8007a30:	68fb      	ldr	r3, [r7, #12]
 8007a32:	681b      	ldr	r3, [r3, #0]
 8007a34:	68fa      	ldr	r2, [r7, #12]
 8007a36:	6812      	ldr	r2, [r2, #0]
 8007a38:	6912      	ldr	r2, [r2, #16]
 8007a3a:	f042 0220 	orr.w	r2, r2, #32
 8007a3e:	611a      	str	r2, [r3, #16]
  }
  
  if(hcan->State == HAL_CAN_STATE_BUSY_TX_RX) 
 8007a40:	68fb      	ldr	r3, [r7, #12]
 8007a42:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8007a46:	b2db      	uxtb	r3, r3
 8007a48:	2b32      	cmp	r3, #50	; 0x32
 8007a4a:	d108      	bne.n	8007a5e <HAL_CAN_Receive+0x262>
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_TX;
 8007a4c:	68fb      	ldr	r3, [r7, #12]
 8007a4e:	2212      	movs	r2, #18
 8007a50:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    
    /* Process unlocked */
    __HAL_UNLOCK(hcan);
 8007a54:	68fb      	ldr	r3, [r7, #12]
 8007a56:	2200      	movs	r2, #0
 8007a58:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
 8007a5c:	e007      	b.n	8007a6e <HAL_CAN_Receive+0x272>
  }
  else
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_READY;
 8007a5e:	68fb      	ldr	r3, [r7, #12]
 8007a60:	2201      	movs	r2, #1
 8007a62:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    
    /* Process unlocked */
    __HAL_UNLOCK(hcan);
 8007a66:	68fb      	ldr	r3, [r7, #12]
 8007a68:	2200      	movs	r2, #0
 8007a6a:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  }
  
  /* Return function status */
  return HAL_OK;
 8007a6e:	2300      	movs	r3, #0
}
 8007a70:	4618      	mov	r0, r3
 8007a72:	3718      	adds	r7, #24
 8007a74:	46bd      	mov	sp, r7
 8007a76:	bd80      	pop	{r7, pc}

08007a78 <HAL_CAN_IRQHandler>:
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
void HAL_CAN_IRQHandler(CAN_HandleTypeDef* hcan)
{
 8007a78:	b580      	push	{r7, lr}
 8007a7a:	b086      	sub	sp, #24
 8007a7c:	af00      	add	r7, sp, #0
 8007a7e:	6078      	str	r0, [r7, #4]
  uint32_t tmp1 = 0, tmp2 = 0, tmp3 = 0;
 8007a80:	2300      	movs	r3, #0
 8007a82:	617b      	str	r3, [r7, #20]
 8007a84:	2300      	movs	r3, #0
 8007a86:	613b      	str	r3, [r7, #16]
 8007a88:	2300      	movs	r3, #0
 8007a8a:	60fb      	str	r3, [r7, #12]
  
  /* Check End of transmission flag */
  if(__HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_TME))
 8007a8c:	687b      	ldr	r3, [r7, #4]
 8007a8e:	681b      	ldr	r3, [r3, #0]
 8007a90:	695b      	ldr	r3, [r3, #20]
 8007a92:	f003 0301 	and.w	r3, r3, #1
 8007a96:	2b00      	cmp	r3, #0
 8007a98:	d037      	beq.n	8007b0a <HAL_CAN_IRQHandler+0x92>
  {
    tmp1 = __HAL_CAN_TRANSMIT_STATUS(hcan, CAN_TXMAILBOX_0);
 8007a9a:	687b      	ldr	r3, [r7, #4]
 8007a9c:	681b      	ldr	r3, [r3, #0]
 8007a9e:	689a      	ldr	r2, [r3, #8]
 8007aa0:	4b15      	ldr	r3, [pc, #84]	; (8007af8 <HAL_CAN_IRQHandler+0x80>)
 8007aa2:	4013      	ands	r3, r2
 8007aa4:	4a14      	ldr	r2, [pc, #80]	; (8007af8 <HAL_CAN_IRQHandler+0x80>)
 8007aa6:	4293      	cmp	r3, r2
 8007aa8:	bf0c      	ite	eq
 8007aaa:	2301      	moveq	r3, #1
 8007aac:	2300      	movne	r3, #0
 8007aae:	b2db      	uxtb	r3, r3
 8007ab0:	617b      	str	r3, [r7, #20]
    tmp2 = __HAL_CAN_TRANSMIT_STATUS(hcan, CAN_TXMAILBOX_1);
 8007ab2:	687b      	ldr	r3, [r7, #4]
 8007ab4:	681b      	ldr	r3, [r3, #0]
 8007ab6:	689a      	ldr	r2, [r3, #8]
 8007ab8:	4b10      	ldr	r3, [pc, #64]	; (8007afc <HAL_CAN_IRQHandler+0x84>)
 8007aba:	4013      	ands	r3, r2
 8007abc:	4a0f      	ldr	r2, [pc, #60]	; (8007afc <HAL_CAN_IRQHandler+0x84>)
 8007abe:	4293      	cmp	r3, r2
 8007ac0:	bf0c      	ite	eq
 8007ac2:	2301      	moveq	r3, #1
 8007ac4:	2300      	movne	r3, #0
 8007ac6:	b2db      	uxtb	r3, r3
 8007ac8:	613b      	str	r3, [r7, #16]
    tmp3 = __HAL_CAN_TRANSMIT_STATUS(hcan, CAN_TXMAILBOX_2);
 8007aca:	687b      	ldr	r3, [r7, #4]
 8007acc:	681b      	ldr	r3, [r3, #0]
 8007ace:	689a      	ldr	r2, [r3, #8]
 8007ad0:	4b0b      	ldr	r3, [pc, #44]	; (8007b00 <HAL_CAN_IRQHandler+0x88>)
 8007ad2:	4013      	ands	r3, r2
 8007ad4:	4a0a      	ldr	r2, [pc, #40]	; (8007b00 <HAL_CAN_IRQHandler+0x88>)
 8007ad6:	4293      	cmp	r3, r2
 8007ad8:	bf0c      	ite	eq
 8007ada:	2301      	moveq	r3, #1
 8007adc:	2300      	movne	r3, #0
 8007ade:	b2db      	uxtb	r3, r3
 8007ae0:	60fb      	str	r3, [r7, #12]
    if(tmp1 || tmp2 || tmp3)  
 8007ae2:	697b      	ldr	r3, [r7, #20]
 8007ae4:	2b00      	cmp	r3, #0
 8007ae6:	d10d      	bne.n	8007b04 <HAL_CAN_IRQHandler+0x8c>
 8007ae8:	693b      	ldr	r3, [r7, #16]
 8007aea:	2b00      	cmp	r3, #0
 8007aec:	d10a      	bne.n	8007b04 <HAL_CAN_IRQHandler+0x8c>
 8007aee:	68fb      	ldr	r3, [r7, #12]
 8007af0:	2b00      	cmp	r3, #0
 8007af2:	d00a      	beq.n	8007b0a <HAL_CAN_IRQHandler+0x92>
 8007af4:	e006      	b.n	8007b04 <HAL_CAN_IRQHandler+0x8c>
 8007af6:	bf00      	nop
 8007af8:	04000003 	.word	0x04000003
 8007afc:	08000300 	.word	0x08000300
 8007b00:	10030000 	.word	0x10030000
    {
      /* Call transmit function */
      CAN_Transmit_IT(hcan);
 8007b04:	6878      	ldr	r0, [r7, #4]
 8007b06:	f000 f959 	bl	8007dbc <CAN_Transmit_IT>
    }
  }
  tmp1 = __HAL_CAN_MSG_PENDING(hcan, CAN_FIFO0);
 8007b0a:	687b      	ldr	r3, [r7, #4]
 8007b0c:	681b      	ldr	r3, [r3, #0]
 8007b0e:	68db      	ldr	r3, [r3, #12]
 8007b10:	b2db      	uxtb	r3, r3
 8007b12:	f003 0303 	and.w	r3, r3, #3
 8007b16:	617b      	str	r3, [r7, #20]
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_FMP0);
 8007b18:	687b      	ldr	r3, [r7, #4]
 8007b1a:	681b      	ldr	r3, [r3, #0]
 8007b1c:	695b      	ldr	r3, [r3, #20]
 8007b1e:	f003 0302 	and.w	r3, r3, #2
 8007b22:	2b00      	cmp	r3, #0
 8007b24:	bf14      	ite	ne
 8007b26:	2301      	movne	r3, #1
 8007b28:	2300      	moveq	r3, #0
 8007b2a:	b2db      	uxtb	r3, r3
 8007b2c:	613b      	str	r3, [r7, #16]
  /* Check End of reception flag for FIFO0 */
  if((tmp1 != 0) && tmp2)
 8007b2e:	697b      	ldr	r3, [r7, #20]
 8007b30:	2b00      	cmp	r3, #0
 8007b32:	d006      	beq.n	8007b42 <HAL_CAN_IRQHandler+0xca>
 8007b34:	693b      	ldr	r3, [r7, #16]
 8007b36:	2b00      	cmp	r3, #0
 8007b38:	d003      	beq.n	8007b42 <HAL_CAN_IRQHandler+0xca>
  {
    /* Call receive function */
    CAN_Receive_IT(hcan, CAN_FIFO0);
 8007b3a:	6878      	ldr	r0, [r7, #4]
 8007b3c:	2100      	movs	r1, #0
 8007b3e:	f000 f98f 	bl	8007e60 <CAN_Receive_IT>
  }
  
  tmp1 = __HAL_CAN_MSG_PENDING(hcan, CAN_FIFO1);
 8007b42:	687b      	ldr	r3, [r7, #4]
 8007b44:	681b      	ldr	r3, [r3, #0]
 8007b46:	691b      	ldr	r3, [r3, #16]
 8007b48:	b2db      	uxtb	r3, r3
 8007b4a:	f003 0303 	and.w	r3, r3, #3
 8007b4e:	617b      	str	r3, [r7, #20]
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_FMP1);
 8007b50:	687b      	ldr	r3, [r7, #4]
 8007b52:	681b      	ldr	r3, [r3, #0]
 8007b54:	695b      	ldr	r3, [r3, #20]
 8007b56:	f003 0310 	and.w	r3, r3, #16
 8007b5a:	2b00      	cmp	r3, #0
 8007b5c:	bf14      	ite	ne
 8007b5e:	2301      	movne	r3, #1
 8007b60:	2300      	moveq	r3, #0
 8007b62:	b2db      	uxtb	r3, r3
 8007b64:	613b      	str	r3, [r7, #16]
  /* Check End of reception flag for FIFO1 */
  if((tmp1 != 0) && tmp2)
 8007b66:	697b      	ldr	r3, [r7, #20]
 8007b68:	2b00      	cmp	r3, #0
 8007b6a:	d006      	beq.n	8007b7a <HAL_CAN_IRQHandler+0x102>
 8007b6c:	693b      	ldr	r3, [r7, #16]
 8007b6e:	2b00      	cmp	r3, #0
 8007b70:	d003      	beq.n	8007b7a <HAL_CAN_IRQHandler+0x102>
  {
    /* Call receive function */
    CAN_Receive_IT(hcan, CAN_FIFO1);
 8007b72:	6878      	ldr	r0, [r7, #4]
 8007b74:	2101      	movs	r1, #1
 8007b76:	f000 f973 	bl	8007e60 <CAN_Receive_IT>
  }
  
  tmp1 = __HAL_CAN_GET_FLAG(hcan, CAN_FLAG_EWG);
 8007b7a:	687b      	ldr	r3, [r7, #4]
 8007b7c:	681b      	ldr	r3, [r3, #0]
 8007b7e:	699b      	ldr	r3, [r3, #24]
 8007b80:	f003 0301 	and.w	r3, r3, #1
 8007b84:	2b00      	cmp	r3, #0
 8007b86:	bf14      	ite	ne
 8007b88:	2301      	movne	r3, #1
 8007b8a:	2300      	moveq	r3, #0
 8007b8c:	b2db      	uxtb	r3, r3
 8007b8e:	617b      	str	r3, [r7, #20]
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_EWG);
 8007b90:	687b      	ldr	r3, [r7, #4]
 8007b92:	681b      	ldr	r3, [r3, #0]
 8007b94:	695b      	ldr	r3, [r3, #20]
 8007b96:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8007b9a:	2b00      	cmp	r3, #0
 8007b9c:	bf14      	ite	ne
 8007b9e:	2301      	movne	r3, #1
 8007ba0:	2300      	moveq	r3, #0
 8007ba2:	b2db      	uxtb	r3, r3
 8007ba4:	613b      	str	r3, [r7, #16]
  tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR);
 8007ba6:	687b      	ldr	r3, [r7, #4]
 8007ba8:	681b      	ldr	r3, [r3, #0]
 8007baa:	695b      	ldr	r3, [r3, #20]
 8007bac:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8007bb0:	2b00      	cmp	r3, #0
 8007bb2:	bf14      	ite	ne
 8007bb4:	2301      	movne	r3, #1
 8007bb6:	2300      	moveq	r3, #0
 8007bb8:	b2db      	uxtb	r3, r3
 8007bba:	60fb      	str	r3, [r7, #12]
  /* Check Error Warning Flag */
  if(tmp1 && tmp2 && tmp3)
 8007bbc:	697b      	ldr	r3, [r7, #20]
 8007bbe:	2b00      	cmp	r3, #0
 8007bc0:	d010      	beq.n	8007be4 <HAL_CAN_IRQHandler+0x16c>
 8007bc2:	693b      	ldr	r3, [r7, #16]
 8007bc4:	2b00      	cmp	r3, #0
 8007bc6:	d00d      	beq.n	8007be4 <HAL_CAN_IRQHandler+0x16c>
 8007bc8:	68fb      	ldr	r3, [r7, #12]
 8007bca:	2b00      	cmp	r3, #0
 8007bcc:	d00a      	beq.n	8007be4 <HAL_CAN_IRQHandler+0x16c>
  {
    /* Set CAN error code to EWG error */
    hcan->ErrorCode |= HAL_CAN_ERROR_EWG;
 8007bce:	687b      	ldr	r3, [r7, #4]
 8007bd0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007bd2:	f043 0201 	orr.w	r2, r3, #1
 8007bd6:	687b      	ldr	r3, [r7, #4]
 8007bd8:	63da      	str	r2, [r3, #60]	; 0x3c
    /* Clear Error Warning Flag */ 
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_EWG);
 8007bda:	687b      	ldr	r3, [r7, #4]
 8007bdc:	681b      	ldr	r3, [r3, #0]
 8007bde:	f06f 0201 	mvn.w	r2, #1
 8007be2:	619a      	str	r2, [r3, #24]
  }
  
  tmp1 = __HAL_CAN_GET_FLAG(hcan, CAN_FLAG_EPV);
 8007be4:	687b      	ldr	r3, [r7, #4]
 8007be6:	681b      	ldr	r3, [r3, #0]
 8007be8:	699b      	ldr	r3, [r3, #24]
 8007bea:	f003 0302 	and.w	r3, r3, #2
 8007bee:	2b00      	cmp	r3, #0
 8007bf0:	bf14      	ite	ne
 8007bf2:	2301      	movne	r3, #1
 8007bf4:	2300      	moveq	r3, #0
 8007bf6:	b2db      	uxtb	r3, r3
 8007bf8:	617b      	str	r3, [r7, #20]
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_EPV);
 8007bfa:	687b      	ldr	r3, [r7, #4]
 8007bfc:	681b      	ldr	r3, [r3, #0]
 8007bfe:	695b      	ldr	r3, [r3, #20]
 8007c00:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8007c04:	2b00      	cmp	r3, #0
 8007c06:	bf14      	ite	ne
 8007c08:	2301      	movne	r3, #1
 8007c0a:	2300      	moveq	r3, #0
 8007c0c:	b2db      	uxtb	r3, r3
 8007c0e:	613b      	str	r3, [r7, #16]
  tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR); 
 8007c10:	687b      	ldr	r3, [r7, #4]
 8007c12:	681b      	ldr	r3, [r3, #0]
 8007c14:	695b      	ldr	r3, [r3, #20]
 8007c16:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8007c1a:	2b00      	cmp	r3, #0
 8007c1c:	bf14      	ite	ne
 8007c1e:	2301      	movne	r3, #1
 8007c20:	2300      	moveq	r3, #0
 8007c22:	b2db      	uxtb	r3, r3
 8007c24:	60fb      	str	r3, [r7, #12]
  /* Check Error Passive Flag */
  if(tmp1 && tmp2 && tmp3)
 8007c26:	697b      	ldr	r3, [r7, #20]
 8007c28:	2b00      	cmp	r3, #0
 8007c2a:	d010      	beq.n	8007c4e <HAL_CAN_IRQHandler+0x1d6>
 8007c2c:	693b      	ldr	r3, [r7, #16]
 8007c2e:	2b00      	cmp	r3, #0
 8007c30:	d00d      	beq.n	8007c4e <HAL_CAN_IRQHandler+0x1d6>
 8007c32:	68fb      	ldr	r3, [r7, #12]
 8007c34:	2b00      	cmp	r3, #0
 8007c36:	d00a      	beq.n	8007c4e <HAL_CAN_IRQHandler+0x1d6>
  {
    /* Set CAN error code to EPV error */
    hcan->ErrorCode |= HAL_CAN_ERROR_EPV;
 8007c38:	687b      	ldr	r3, [r7, #4]
 8007c3a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007c3c:	f043 0202 	orr.w	r2, r3, #2
 8007c40:	687b      	ldr	r3, [r7, #4]
 8007c42:	63da      	str	r2, [r3, #60]	; 0x3c
    /* Clear Error Passive Flag */ 
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_EPV);
 8007c44:	687b      	ldr	r3, [r7, #4]
 8007c46:	681b      	ldr	r3, [r3, #0]
 8007c48:	f06f 0202 	mvn.w	r2, #2
 8007c4c:	619a      	str	r2, [r3, #24]
  }
  
  tmp1 = __HAL_CAN_GET_FLAG(hcan, CAN_FLAG_BOF);
 8007c4e:	687b      	ldr	r3, [r7, #4]
 8007c50:	681b      	ldr	r3, [r3, #0]
 8007c52:	699b      	ldr	r3, [r3, #24]
 8007c54:	f003 0304 	and.w	r3, r3, #4
 8007c58:	2b00      	cmp	r3, #0
 8007c5a:	bf14      	ite	ne
 8007c5c:	2301      	movne	r3, #1
 8007c5e:	2300      	moveq	r3, #0
 8007c60:	b2db      	uxtb	r3, r3
 8007c62:	617b      	str	r3, [r7, #20]
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_BOF);
 8007c64:	687b      	ldr	r3, [r7, #4]
 8007c66:	681b      	ldr	r3, [r3, #0]
 8007c68:	695b      	ldr	r3, [r3, #20]
 8007c6a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8007c6e:	2b00      	cmp	r3, #0
 8007c70:	bf14      	ite	ne
 8007c72:	2301      	movne	r3, #1
 8007c74:	2300      	moveq	r3, #0
 8007c76:	b2db      	uxtb	r3, r3
 8007c78:	613b      	str	r3, [r7, #16]
  tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR);  
 8007c7a:	687b      	ldr	r3, [r7, #4]
 8007c7c:	681b      	ldr	r3, [r3, #0]
 8007c7e:	695b      	ldr	r3, [r3, #20]
 8007c80:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8007c84:	2b00      	cmp	r3, #0
 8007c86:	bf14      	ite	ne
 8007c88:	2301      	movne	r3, #1
 8007c8a:	2300      	moveq	r3, #0
 8007c8c:	b2db      	uxtb	r3, r3
 8007c8e:	60fb      	str	r3, [r7, #12]
  /* Check Bus-Off Flag */
  if(tmp1 && tmp2 && tmp3)
 8007c90:	697b      	ldr	r3, [r7, #20]
 8007c92:	2b00      	cmp	r3, #0
 8007c94:	d010      	beq.n	8007cb8 <HAL_CAN_IRQHandler+0x240>
 8007c96:	693b      	ldr	r3, [r7, #16]
 8007c98:	2b00      	cmp	r3, #0
 8007c9a:	d00d      	beq.n	8007cb8 <HAL_CAN_IRQHandler+0x240>
 8007c9c:	68fb      	ldr	r3, [r7, #12]
 8007c9e:	2b00      	cmp	r3, #0
 8007ca0:	d00a      	beq.n	8007cb8 <HAL_CAN_IRQHandler+0x240>
  {
    /* Set CAN error code to BOF error */
    hcan->ErrorCode |= HAL_CAN_ERROR_BOF;
 8007ca2:	687b      	ldr	r3, [r7, #4]
 8007ca4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007ca6:	f043 0204 	orr.w	r2, r3, #4
 8007caa:	687b      	ldr	r3, [r7, #4]
 8007cac:	63da      	str	r2, [r3, #60]	; 0x3c
    /* Clear Bus-Off Flag */ 
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_BOF);
 8007cae:	687b      	ldr	r3, [r7, #4]
 8007cb0:	681b      	ldr	r3, [r3, #0]
 8007cb2:	f06f 0204 	mvn.w	r2, #4
 8007cb6:	619a      	str	r2, [r3, #24]
  }
  
  tmp1 = HAL_IS_BIT_CLR(hcan->Instance->ESR, CAN_ESR_LEC);
 8007cb8:	687b      	ldr	r3, [r7, #4]
 8007cba:	681b      	ldr	r3, [r3, #0]
 8007cbc:	699b      	ldr	r3, [r3, #24]
 8007cbe:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8007cc2:	2b00      	cmp	r3, #0
 8007cc4:	bf0c      	ite	eq
 8007cc6:	2301      	moveq	r3, #1
 8007cc8:	2300      	movne	r3, #0
 8007cca:	b2db      	uxtb	r3, r3
 8007ccc:	617b      	str	r3, [r7, #20]
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_LEC);
 8007cce:	687b      	ldr	r3, [r7, #4]
 8007cd0:	681b      	ldr	r3, [r3, #0]
 8007cd2:	695b      	ldr	r3, [r3, #20]
 8007cd4:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8007cd8:	2b00      	cmp	r3, #0
 8007cda:	bf14      	ite	ne
 8007cdc:	2301      	movne	r3, #1
 8007cde:	2300      	moveq	r3, #0
 8007ce0:	b2db      	uxtb	r3, r3
 8007ce2:	613b      	str	r3, [r7, #16]
  tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR);
 8007ce4:	687b      	ldr	r3, [r7, #4]
 8007ce6:	681b      	ldr	r3, [r3, #0]
 8007ce8:	695b      	ldr	r3, [r3, #20]
 8007cea:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8007cee:	2b00      	cmp	r3, #0
 8007cf0:	bf14      	ite	ne
 8007cf2:	2301      	movne	r3, #1
 8007cf4:	2300      	moveq	r3, #0
 8007cf6:	b2db      	uxtb	r3, r3
 8007cf8:	60fb      	str	r3, [r7, #12]
  /* Check Last error code Flag */
  if((!tmp1) && tmp2 && tmp3)
 8007cfa:	697b      	ldr	r3, [r7, #20]
 8007cfc:	2b00      	cmp	r3, #0
 8007cfe:	d14e      	bne.n	8007d9e <HAL_CAN_IRQHandler+0x326>
 8007d00:	693b      	ldr	r3, [r7, #16]
 8007d02:	2b00      	cmp	r3, #0
 8007d04:	d04b      	beq.n	8007d9e <HAL_CAN_IRQHandler+0x326>
 8007d06:	68fb      	ldr	r3, [r7, #12]
 8007d08:	2b00      	cmp	r3, #0
 8007d0a:	d048      	beq.n	8007d9e <HAL_CAN_IRQHandler+0x326>
  {
    tmp1 = (hcan->Instance->ESR) & CAN_ESR_LEC;
 8007d0c:	687b      	ldr	r3, [r7, #4]
 8007d0e:	681b      	ldr	r3, [r3, #0]
 8007d10:	699b      	ldr	r3, [r3, #24]
 8007d12:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8007d16:	617b      	str	r3, [r7, #20]
    switch(tmp1)
 8007d18:	697b      	ldr	r3, [r7, #20]
 8007d1a:	2b30      	cmp	r3, #48	; 0x30
 8007d1c:	d01b      	beq.n	8007d56 <HAL_CAN_IRQHandler+0x2de>
 8007d1e:	2b30      	cmp	r3, #48	; 0x30
 8007d20:	d804      	bhi.n	8007d2c <HAL_CAN_IRQHandler+0x2b4>
 8007d22:	2b10      	cmp	r3, #16
 8007d24:	d009      	beq.n	8007d3a <HAL_CAN_IRQHandler+0x2c2>
 8007d26:	2b20      	cmp	r3, #32
 8007d28:	d00e      	beq.n	8007d48 <HAL_CAN_IRQHandler+0x2d0>
      case(CAN_ESR_LEC_2 | CAN_ESR_LEC_1):
          /* Set CAN error code to CRC error */
          hcan->ErrorCode |= HAL_CAN_ERROR_CRC;
          break;
      default:
          break;
 8007d2a:	e030      	b.n	8007d8e <HAL_CAN_IRQHandler+0x316>
  tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR);
  /* Check Last error code Flag */
  if((!tmp1) && tmp2 && tmp3)
  {
    tmp1 = (hcan->Instance->ESR) & CAN_ESR_LEC;
    switch(tmp1)
 8007d2c:	2b50      	cmp	r3, #80	; 0x50
 8007d2e:	d020      	beq.n	8007d72 <HAL_CAN_IRQHandler+0x2fa>
 8007d30:	2b60      	cmp	r3, #96	; 0x60
 8007d32:	d025      	beq.n	8007d80 <HAL_CAN_IRQHandler+0x308>
 8007d34:	2b40      	cmp	r3, #64	; 0x40
 8007d36:	d015      	beq.n	8007d64 <HAL_CAN_IRQHandler+0x2ec>
      case(CAN_ESR_LEC_2 | CAN_ESR_LEC_1):
          /* Set CAN error code to CRC error */
          hcan->ErrorCode |= HAL_CAN_ERROR_CRC;
          break;
      default:
          break;
 8007d38:	e029      	b.n	8007d8e <HAL_CAN_IRQHandler+0x316>
    tmp1 = (hcan->Instance->ESR) & CAN_ESR_LEC;
    switch(tmp1)
    {
      case(CAN_ESR_LEC_0):
          /* Set CAN error code to STF error */
          hcan->ErrorCode |= HAL_CAN_ERROR_STF;
 8007d3a:	687b      	ldr	r3, [r7, #4]
 8007d3c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007d3e:	f043 0208 	orr.w	r2, r3, #8
 8007d42:	687b      	ldr	r3, [r7, #4]
 8007d44:	63da      	str	r2, [r3, #60]	; 0x3c
          break;
 8007d46:	e022      	b.n	8007d8e <HAL_CAN_IRQHandler+0x316>
      case(CAN_ESR_LEC_1):
          /* Set CAN error code to FOR error */
          hcan->ErrorCode |= HAL_CAN_ERROR_FOR;
 8007d48:	687b      	ldr	r3, [r7, #4]
 8007d4a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007d4c:	f043 0210 	orr.w	r2, r3, #16
 8007d50:	687b      	ldr	r3, [r7, #4]
 8007d52:	63da      	str	r2, [r3, #60]	; 0x3c
          break;
 8007d54:	e01b      	b.n	8007d8e <HAL_CAN_IRQHandler+0x316>
      case(CAN_ESR_LEC_1 | CAN_ESR_LEC_0):
          /* Set CAN error code to ACK error */
          hcan->ErrorCode |= HAL_CAN_ERROR_ACK;
 8007d56:	687b      	ldr	r3, [r7, #4]
 8007d58:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007d5a:	f043 0220 	orr.w	r2, r3, #32
 8007d5e:	687b      	ldr	r3, [r7, #4]
 8007d60:	63da      	str	r2, [r3, #60]	; 0x3c
          break;
 8007d62:	e014      	b.n	8007d8e <HAL_CAN_IRQHandler+0x316>
      case(CAN_ESR_LEC_2):
          /* Set CAN error code to BR error */
          hcan->ErrorCode |= HAL_CAN_ERROR_BR;
 8007d64:	687b      	ldr	r3, [r7, #4]
 8007d66:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007d68:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8007d6c:	687b      	ldr	r3, [r7, #4]
 8007d6e:	63da      	str	r2, [r3, #60]	; 0x3c
          break;
 8007d70:	e00d      	b.n	8007d8e <HAL_CAN_IRQHandler+0x316>
      case(CAN_ESR_LEC_2 | CAN_ESR_LEC_0):
          /* Set CAN error code to BD error */
          hcan->ErrorCode |= HAL_CAN_ERROR_BD;
 8007d72:	687b      	ldr	r3, [r7, #4]
 8007d74:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007d76:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 8007d7a:	687b      	ldr	r3, [r7, #4]
 8007d7c:	63da      	str	r2, [r3, #60]	; 0x3c
          break;
 8007d7e:	e006      	b.n	8007d8e <HAL_CAN_IRQHandler+0x316>
      case(CAN_ESR_LEC_2 | CAN_ESR_LEC_1):
          /* Set CAN error code to CRC error */
          hcan->ErrorCode |= HAL_CAN_ERROR_CRC;
 8007d80:	687b      	ldr	r3, [r7, #4]
 8007d82:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007d84:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 8007d88:	687b      	ldr	r3, [r7, #4]
 8007d8a:	63da      	str	r2, [r3, #60]	; 0x3c
          break;
 8007d8c:	bf00      	nop
      default:
          break;
    }

    /* Clear Last error code Flag */ 
    hcan->Instance->ESR &= ~(CAN_ESR_LEC);
 8007d8e:	687b      	ldr	r3, [r7, #4]
 8007d90:	681b      	ldr	r3, [r3, #0]
 8007d92:	687a      	ldr	r2, [r7, #4]
 8007d94:	6812      	ldr	r2, [r2, #0]
 8007d96:	6992      	ldr	r2, [r2, #24]
 8007d98:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8007d9c:	619a      	str	r2, [r3, #24]
  }

  /* Call the Error call Back in case of Errors */
  if(hcan->ErrorCode != HAL_CAN_ERROR_NONE)
 8007d9e:	687b      	ldr	r3, [r7, #4]
 8007da0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007da2:	2b00      	cmp	r3, #0
 8007da4:	d006      	beq.n	8007db4 <HAL_CAN_IRQHandler+0x33c>
  {
    /* Set the CAN state ready to be able to start again the process */
    hcan->State = HAL_CAN_STATE_READY;
 8007da6:	687b      	ldr	r3, [r7, #4]
 8007da8:	2201      	movs	r2, #1
 8007daa:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    /* Call Error callback function */
    HAL_CAN_ErrorCallback(hcan);
 8007dae:	6878      	ldr	r0, [r7, #4]
 8007db0:	f009 fdfc 	bl	80119ac <HAL_CAN_ErrorCallback>
  }  
}
 8007db4:	3718      	adds	r7, #24
 8007db6:	46bd      	mov	sp, r7
 8007db8:	bd80      	pop	{r7, pc}
 8007dba:	bf00      	nop

08007dbc <CAN_Transmit_IT>:
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.  
  * @retval HAL status
  */
static HAL_StatusTypeDef CAN_Transmit_IT(CAN_HandleTypeDef* hcan)
{
 8007dbc:	b580      	push	{r7, lr}
 8007dbe:	b082      	sub	sp, #8
 8007dc0:	af00      	add	r7, sp, #0
 8007dc2:	6078      	str	r0, [r7, #4]
  /* Disable Transmit mailbox empty Interrupt */
  __HAL_CAN_DISABLE_IT(hcan, CAN_IT_TME);
 8007dc4:	687b      	ldr	r3, [r7, #4]
 8007dc6:	681b      	ldr	r3, [r3, #0]
 8007dc8:	687a      	ldr	r2, [r7, #4]
 8007dca:	6812      	ldr	r2, [r2, #0]
 8007dcc:	6952      	ldr	r2, [r2, #20]
 8007dce:	f022 0201 	bic.w	r2, r2, #1
 8007dd2:	615a      	str	r2, [r3, #20]
  
  if(hcan->State == HAL_CAN_STATE_BUSY_TX)
 8007dd4:	687b      	ldr	r3, [r7, #4]
 8007dd6:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8007dda:	b2db      	uxtb	r3, r3
 8007ddc:	2b12      	cmp	r3, #18
 8007dde:	d127      	bne.n	8007e30 <CAN_Transmit_IT+0x74>
  {   
    /* Disable Error warning Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_EWG);
 8007de0:	687b      	ldr	r3, [r7, #4]
 8007de2:	681b      	ldr	r3, [r3, #0]
 8007de4:	687a      	ldr	r2, [r7, #4]
 8007de6:	6812      	ldr	r2, [r2, #0]
 8007de8:	6952      	ldr	r2, [r2, #20]
 8007dea:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8007dee:	615a      	str	r2, [r3, #20]
    
    /* Disable Error passive Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_EPV);
 8007df0:	687b      	ldr	r3, [r7, #4]
 8007df2:	681b      	ldr	r3, [r3, #0]
 8007df4:	687a      	ldr	r2, [r7, #4]
 8007df6:	6812      	ldr	r2, [r2, #0]
 8007df8:	6952      	ldr	r2, [r2, #20]
 8007dfa:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8007dfe:	615a      	str	r2, [r3, #20]
    
    /* Disable Bus-off Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_BOF);
 8007e00:	687b      	ldr	r3, [r7, #4]
 8007e02:	681b      	ldr	r3, [r3, #0]
 8007e04:	687a      	ldr	r2, [r7, #4]
 8007e06:	6812      	ldr	r2, [r2, #0]
 8007e08:	6952      	ldr	r2, [r2, #20]
 8007e0a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8007e0e:	615a      	str	r2, [r3, #20]
    
    /* Disable Last error code Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_LEC);
 8007e10:	687b      	ldr	r3, [r7, #4]
 8007e12:	681b      	ldr	r3, [r3, #0]
 8007e14:	687a      	ldr	r2, [r7, #4]
 8007e16:	6812      	ldr	r2, [r2, #0]
 8007e18:	6952      	ldr	r2, [r2, #20]
 8007e1a:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8007e1e:	615a      	str	r2, [r3, #20]
    
    /* Disable Error Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_ERR);
 8007e20:	687b      	ldr	r3, [r7, #4]
 8007e22:	681b      	ldr	r3, [r3, #0]
 8007e24:	687a      	ldr	r2, [r7, #4]
 8007e26:	6812      	ldr	r2, [r2, #0]
 8007e28:	6952      	ldr	r2, [r2, #20]
 8007e2a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8007e2e:	615a      	str	r2, [r3, #20]
  }
  
  if(hcan->State == HAL_CAN_STATE_BUSY_TX_RX) 
 8007e30:	687b      	ldr	r3, [r7, #4]
 8007e32:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8007e36:	b2db      	uxtb	r3, r3
 8007e38:	2b32      	cmp	r3, #50	; 0x32
 8007e3a:	d104      	bne.n	8007e46 <CAN_Transmit_IT+0x8a>
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_RX;
 8007e3c:	687b      	ldr	r3, [r7, #4]
 8007e3e:	2222      	movs	r2, #34	; 0x22
 8007e40:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
 8007e44:	e003      	b.n	8007e4e <CAN_Transmit_IT+0x92>
  }
  else
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_READY;
 8007e46:	687b      	ldr	r3, [r7, #4]
 8007e48:	2201      	movs	r2, #1
 8007e4a:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  }
  
  /* Transmission complete callback */ 
  HAL_CAN_TxCpltCallback(hcan);
 8007e4e:	6878      	ldr	r0, [r7, #4]
 8007e50:	f009 fd62 	bl	8011918 <HAL_CAN_TxCpltCallback>
  
  return HAL_OK;
 8007e54:	2300      	movs	r3, #0
}
 8007e56:	4618      	mov	r0, r3
 8007e58:	3708      	adds	r7, #8
 8007e5a:	46bd      	mov	sp, r7
 8007e5c:	bd80      	pop	{r7, pc}
 8007e5e:	bf00      	nop

08007e60 <CAN_Receive_IT>:
  * @param  FIFONumber: Specify the FIFO number    
  * @retval HAL status
  * @retval None
  */
static HAL_StatusTypeDef CAN_Receive_IT(CAN_HandleTypeDef* hcan, uint8_t FIFONumber)
{
 8007e60:	b580      	push	{r7, lr}
 8007e62:	b082      	sub	sp, #8
 8007e64:	af00      	add	r7, sp, #0
 8007e66:	6078      	str	r0, [r7, #4]
 8007e68:	460b      	mov	r3, r1
 8007e6a:	70fb      	strb	r3, [r7, #3]
  /* Get the Id */
  hcan->pRxMsg->IDE = (uint8_t)0x04 & hcan->Instance->sFIFOMailBox[FIFONumber].RIR;
 8007e6c:	687b      	ldr	r3, [r7, #4]
 8007e6e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007e70:	687a      	ldr	r2, [r7, #4]
 8007e72:	6811      	ldr	r1, [r2, #0]
 8007e74:	78fa      	ldrb	r2, [r7, #3]
 8007e76:	321b      	adds	r2, #27
 8007e78:	0112      	lsls	r2, r2, #4
 8007e7a:	440a      	add	r2, r1
 8007e7c:	6812      	ldr	r2, [r2, #0]
 8007e7e:	f002 0204 	and.w	r2, r2, #4
 8007e82:	609a      	str	r2, [r3, #8]
  if (hcan->pRxMsg->IDE == CAN_ID_STD)
 8007e84:	687b      	ldr	r3, [r7, #4]
 8007e86:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007e88:	689b      	ldr	r3, [r3, #8]
 8007e8a:	2b00      	cmp	r3, #0
 8007e8c:	d10b      	bne.n	8007ea6 <CAN_Receive_IT+0x46>
  {
    hcan->pRxMsg->StdId = (uint32_t)0x000007FF & (hcan->Instance->sFIFOMailBox[FIFONumber].RIR >> 21);
 8007e8e:	687b      	ldr	r3, [r7, #4]
 8007e90:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007e92:	687a      	ldr	r2, [r7, #4]
 8007e94:	6811      	ldr	r1, [r2, #0]
 8007e96:	78fa      	ldrb	r2, [r7, #3]
 8007e98:	321b      	adds	r2, #27
 8007e9a:	0112      	lsls	r2, r2, #4
 8007e9c:	440a      	add	r2, r1
 8007e9e:	6812      	ldr	r2, [r2, #0]
 8007ea0:	0d52      	lsrs	r2, r2, #21
 8007ea2:	601a      	str	r2, [r3, #0]
 8007ea4:	e00a      	b.n	8007ebc <CAN_Receive_IT+0x5c>
  }
  else
  {
    hcan->pRxMsg->ExtId = (uint32_t)0x1FFFFFFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RIR >> 3);
 8007ea6:	687b      	ldr	r3, [r7, #4]
 8007ea8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007eaa:	687a      	ldr	r2, [r7, #4]
 8007eac:	6811      	ldr	r1, [r2, #0]
 8007eae:	78fa      	ldrb	r2, [r7, #3]
 8007eb0:	321b      	adds	r2, #27
 8007eb2:	0112      	lsls	r2, r2, #4
 8007eb4:	440a      	add	r2, r1
 8007eb6:	6812      	ldr	r2, [r2, #0]
 8007eb8:	08d2      	lsrs	r2, r2, #3
 8007eba:	605a      	str	r2, [r3, #4]
  }
  
  hcan->pRxMsg->RTR = (uint8_t)0x02 & hcan->Instance->sFIFOMailBox[FIFONumber].RIR;
 8007ebc:	687b      	ldr	r3, [r7, #4]
 8007ebe:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007ec0:	687a      	ldr	r2, [r7, #4]
 8007ec2:	6811      	ldr	r1, [r2, #0]
 8007ec4:	78fa      	ldrb	r2, [r7, #3]
 8007ec6:	321b      	adds	r2, #27
 8007ec8:	0112      	lsls	r2, r2, #4
 8007eca:	440a      	add	r2, r1
 8007ecc:	6812      	ldr	r2, [r2, #0]
 8007ece:	f002 0202 	and.w	r2, r2, #2
 8007ed2:	60da      	str	r2, [r3, #12]
  /* Get the DLC */
  hcan->pRxMsg->DLC = (uint8_t)0x0F & hcan->Instance->sFIFOMailBox[FIFONumber].RDTR;
 8007ed4:	687b      	ldr	r3, [r7, #4]
 8007ed6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007ed8:	687a      	ldr	r2, [r7, #4]
 8007eda:	6811      	ldr	r1, [r2, #0]
 8007edc:	78fa      	ldrb	r2, [r7, #3]
 8007ede:	321b      	adds	r2, #27
 8007ee0:	0112      	lsls	r2, r2, #4
 8007ee2:	440a      	add	r2, r1
 8007ee4:	6852      	ldr	r2, [r2, #4]
 8007ee6:	f002 020f 	and.w	r2, r2, #15
 8007eea:	611a      	str	r2, [r3, #16]
  /* Get the FMI */
  hcan->pRxMsg->FMI = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDTR >> 8);
 8007eec:	687b      	ldr	r3, [r7, #4]
 8007eee:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007ef0:	687a      	ldr	r2, [r7, #4]
 8007ef2:	6811      	ldr	r1, [r2, #0]
 8007ef4:	78fa      	ldrb	r2, [r7, #3]
 8007ef6:	321b      	adds	r2, #27
 8007ef8:	0112      	lsls	r2, r2, #4
 8007efa:	440a      	add	r2, r1
 8007efc:	6852      	ldr	r2, [r2, #4]
 8007efe:	0a12      	lsrs	r2, r2, #8
 8007f00:	b2d2      	uxtb	r2, r2
 8007f02:	61da      	str	r2, [r3, #28]
  /* Get the data field */
  hcan->pRxMsg->Data[0] = (uint8_t)0xFF & hcan->Instance->sFIFOMailBox[FIFONumber].RDLR;
 8007f04:	687b      	ldr	r3, [r7, #4]
 8007f06:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007f08:	687a      	ldr	r2, [r7, #4]
 8007f0a:	6811      	ldr	r1, [r2, #0]
 8007f0c:	78fa      	ldrb	r2, [r7, #3]
 8007f0e:	0112      	lsls	r2, r2, #4
 8007f10:	440a      	add	r2, r1
 8007f12:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8007f16:	6812      	ldr	r2, [r2, #0]
 8007f18:	b2d2      	uxtb	r2, r2
 8007f1a:	751a      	strb	r2, [r3, #20]
  hcan->pRxMsg->Data[1] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 8);
 8007f1c:	687b      	ldr	r3, [r7, #4]
 8007f1e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007f20:	687a      	ldr	r2, [r7, #4]
 8007f22:	6811      	ldr	r1, [r2, #0]
 8007f24:	78fa      	ldrb	r2, [r7, #3]
 8007f26:	0112      	lsls	r2, r2, #4
 8007f28:	440a      	add	r2, r1
 8007f2a:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8007f2e:	6812      	ldr	r2, [r2, #0]
 8007f30:	0a12      	lsrs	r2, r2, #8
 8007f32:	b2d2      	uxtb	r2, r2
 8007f34:	755a      	strb	r2, [r3, #21]
  hcan->pRxMsg->Data[2] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 16);
 8007f36:	687b      	ldr	r3, [r7, #4]
 8007f38:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007f3a:	687a      	ldr	r2, [r7, #4]
 8007f3c:	6811      	ldr	r1, [r2, #0]
 8007f3e:	78fa      	ldrb	r2, [r7, #3]
 8007f40:	0112      	lsls	r2, r2, #4
 8007f42:	440a      	add	r2, r1
 8007f44:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8007f48:	6812      	ldr	r2, [r2, #0]
 8007f4a:	0c12      	lsrs	r2, r2, #16
 8007f4c:	b2d2      	uxtb	r2, r2
 8007f4e:	759a      	strb	r2, [r3, #22]
  hcan->pRxMsg->Data[3] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 24);
 8007f50:	687b      	ldr	r3, [r7, #4]
 8007f52:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007f54:	687a      	ldr	r2, [r7, #4]
 8007f56:	6811      	ldr	r1, [r2, #0]
 8007f58:	78fa      	ldrb	r2, [r7, #3]
 8007f5a:	0112      	lsls	r2, r2, #4
 8007f5c:	440a      	add	r2, r1
 8007f5e:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8007f62:	6812      	ldr	r2, [r2, #0]
 8007f64:	0e12      	lsrs	r2, r2, #24
 8007f66:	b2d2      	uxtb	r2, r2
 8007f68:	75da      	strb	r2, [r3, #23]
  hcan->pRxMsg->Data[4] = (uint8_t)0xFF & hcan->Instance->sFIFOMailBox[FIFONumber].RDHR;
 8007f6a:	687b      	ldr	r3, [r7, #4]
 8007f6c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007f6e:	687a      	ldr	r2, [r7, #4]
 8007f70:	6811      	ldr	r1, [r2, #0]
 8007f72:	78fa      	ldrb	r2, [r7, #3]
 8007f74:	0112      	lsls	r2, r2, #4
 8007f76:	440a      	add	r2, r1
 8007f78:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8007f7c:	6852      	ldr	r2, [r2, #4]
 8007f7e:	b2d2      	uxtb	r2, r2
 8007f80:	761a      	strb	r2, [r3, #24]
  hcan->pRxMsg->Data[5] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 8);
 8007f82:	687b      	ldr	r3, [r7, #4]
 8007f84:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007f86:	687a      	ldr	r2, [r7, #4]
 8007f88:	6811      	ldr	r1, [r2, #0]
 8007f8a:	78fa      	ldrb	r2, [r7, #3]
 8007f8c:	0112      	lsls	r2, r2, #4
 8007f8e:	440a      	add	r2, r1
 8007f90:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8007f94:	6852      	ldr	r2, [r2, #4]
 8007f96:	0a12      	lsrs	r2, r2, #8
 8007f98:	b2d2      	uxtb	r2, r2
 8007f9a:	765a      	strb	r2, [r3, #25]
  hcan->pRxMsg->Data[6] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 16);
 8007f9c:	687b      	ldr	r3, [r7, #4]
 8007f9e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007fa0:	687a      	ldr	r2, [r7, #4]
 8007fa2:	6811      	ldr	r1, [r2, #0]
 8007fa4:	78fa      	ldrb	r2, [r7, #3]
 8007fa6:	0112      	lsls	r2, r2, #4
 8007fa8:	440a      	add	r2, r1
 8007faa:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8007fae:	6852      	ldr	r2, [r2, #4]
 8007fb0:	0c12      	lsrs	r2, r2, #16
 8007fb2:	b2d2      	uxtb	r2, r2
 8007fb4:	769a      	strb	r2, [r3, #26]
  hcan->pRxMsg->Data[7] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 24);
 8007fb6:	687b      	ldr	r3, [r7, #4]
 8007fb8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007fba:	687a      	ldr	r2, [r7, #4]
 8007fbc:	6811      	ldr	r1, [r2, #0]
 8007fbe:	78fa      	ldrb	r2, [r7, #3]
 8007fc0:	0112      	lsls	r2, r2, #4
 8007fc2:	440a      	add	r2, r1
 8007fc4:	f502 72dc 	add.w	r2, r2, #440	; 0x1b8
 8007fc8:	6852      	ldr	r2, [r2, #4]
 8007fca:	0e12      	lsrs	r2, r2, #24
 8007fcc:	b2d2      	uxtb	r2, r2
 8007fce:	76da      	strb	r2, [r3, #27]
  /* Release the FIFO */
  /* Release FIFO0 */
  if (FIFONumber == CAN_FIFO0)
 8007fd0:	78fb      	ldrb	r3, [r7, #3]
 8007fd2:	2b00      	cmp	r3, #0
 8007fd4:	d110      	bne.n	8007ff8 <CAN_Receive_IT+0x198>
  {
    __HAL_CAN_FIFO_RELEASE(hcan, CAN_FIFO0);
 8007fd6:	687b      	ldr	r3, [r7, #4]
 8007fd8:	681b      	ldr	r3, [r3, #0]
 8007fda:	687a      	ldr	r2, [r7, #4]
 8007fdc:	6812      	ldr	r2, [r2, #0]
 8007fde:	68d2      	ldr	r2, [r2, #12]
 8007fe0:	f042 0220 	orr.w	r2, r2, #32
 8007fe4:	60da      	str	r2, [r3, #12]
    
    /* Disable FIFO 0 message pending Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_FMP0);
 8007fe6:	687b      	ldr	r3, [r7, #4]
 8007fe8:	681b      	ldr	r3, [r3, #0]
 8007fea:	687a      	ldr	r2, [r7, #4]
 8007fec:	6812      	ldr	r2, [r2, #0]
 8007fee:	6952      	ldr	r2, [r2, #20]
 8007ff0:	f022 0202 	bic.w	r2, r2, #2
 8007ff4:	615a      	str	r2, [r3, #20]
 8007ff6:	e00f      	b.n	8008018 <CAN_Receive_IT+0x1b8>
  }
  /* Release FIFO1 */
  else /* FIFONumber == CAN_FIFO1 */
  {
    __HAL_CAN_FIFO_RELEASE(hcan, CAN_FIFO1);
 8007ff8:	687b      	ldr	r3, [r7, #4]
 8007ffa:	681b      	ldr	r3, [r3, #0]
 8007ffc:	687a      	ldr	r2, [r7, #4]
 8007ffe:	6812      	ldr	r2, [r2, #0]
 8008000:	6912      	ldr	r2, [r2, #16]
 8008002:	f042 0220 	orr.w	r2, r2, #32
 8008006:	611a      	str	r2, [r3, #16]
    
    /* Disable FIFO 1 message pending Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_FMP1);
 8008008:	687b      	ldr	r3, [r7, #4]
 800800a:	681b      	ldr	r3, [r3, #0]
 800800c:	687a      	ldr	r2, [r7, #4]
 800800e:	6812      	ldr	r2, [r2, #0]
 8008010:	6952      	ldr	r2, [r2, #20]
 8008012:	f022 0210 	bic.w	r2, r2, #16
 8008016:	615a      	str	r2, [r3, #20]
  }
  
  if(hcan->State == HAL_CAN_STATE_BUSY_RX)
 8008018:	687b      	ldr	r3, [r7, #4]
 800801a:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 800801e:	b2db      	uxtb	r3, r3
 8008020:	2b22      	cmp	r3, #34	; 0x22
 8008022:	d127      	bne.n	8008074 <CAN_Receive_IT+0x214>
  {   
    /* Disable Error warning Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_EWG);
 8008024:	687b      	ldr	r3, [r7, #4]
 8008026:	681b      	ldr	r3, [r3, #0]
 8008028:	687a      	ldr	r2, [r7, #4]
 800802a:	6812      	ldr	r2, [r2, #0]
 800802c:	6952      	ldr	r2, [r2, #20]
 800802e:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8008032:	615a      	str	r2, [r3, #20]
    
    /* Disable Error passive Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_EPV);
 8008034:	687b      	ldr	r3, [r7, #4]
 8008036:	681b      	ldr	r3, [r3, #0]
 8008038:	687a      	ldr	r2, [r7, #4]
 800803a:	6812      	ldr	r2, [r2, #0]
 800803c:	6952      	ldr	r2, [r2, #20]
 800803e:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8008042:	615a      	str	r2, [r3, #20]
    
    /* Disable Bus-off Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_BOF);
 8008044:	687b      	ldr	r3, [r7, #4]
 8008046:	681b      	ldr	r3, [r3, #0]
 8008048:	687a      	ldr	r2, [r7, #4]
 800804a:	6812      	ldr	r2, [r2, #0]
 800804c:	6952      	ldr	r2, [r2, #20]
 800804e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8008052:	615a      	str	r2, [r3, #20]
    
    /* Disable Last error code Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_LEC);
 8008054:	687b      	ldr	r3, [r7, #4]
 8008056:	681b      	ldr	r3, [r3, #0]
 8008058:	687a      	ldr	r2, [r7, #4]
 800805a:	6812      	ldr	r2, [r2, #0]
 800805c:	6952      	ldr	r2, [r2, #20]
 800805e:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8008062:	615a      	str	r2, [r3, #20]
    
    /* Disable Error Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_ERR);
 8008064:	687b      	ldr	r3, [r7, #4]
 8008066:	681b      	ldr	r3, [r3, #0]
 8008068:	687a      	ldr	r2, [r7, #4]
 800806a:	6812      	ldr	r2, [r2, #0]
 800806c:	6952      	ldr	r2, [r2, #20]
 800806e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8008072:	615a      	str	r2, [r3, #20]
  }
  
  if(hcan->State == HAL_CAN_STATE_BUSY_TX_RX) 
 8008074:	687b      	ldr	r3, [r7, #4]
 8008076:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 800807a:	b2db      	uxtb	r3, r3
 800807c:	2b32      	cmp	r3, #50	; 0x32
 800807e:	d104      	bne.n	800808a <CAN_Receive_IT+0x22a>
  {
    /* Disable CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_TX;
 8008080:	687b      	ldr	r3, [r7, #4]
 8008082:	2212      	movs	r2, #18
 8008084:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
 8008088:	e003      	b.n	8008092 <CAN_Receive_IT+0x232>
  }
  else
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_READY;
 800808a:	687b      	ldr	r3, [r7, #4]
 800808c:	2201      	movs	r2, #1
 800808e:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  }

  /* Receive complete callback */ 
  HAL_CAN_RxCpltCallback(hcan);
 8008092:	6878      	ldr	r0, [r7, #4]
 8008094:	f009 fc5c 	bl	8011950 <HAL_CAN_RxCpltCallback>

  /* Return function status */
  return HAL_OK;
 8008098:	2300      	movs	r3, #0
}
 800809a:	4618      	mov	r0, r3
 800809c:	3708      	adds	r7, #8
 800809e:	46bd      	mov	sp, r7
 80080a0:	bd80      	pop	{r7, pc}
 80080a2:	bf00      	nop

080080a4 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80080a4:	b480      	push	{r7}
 80080a6:	b085      	sub	sp, #20
 80080a8:	af00      	add	r7, sp, #0
 80080aa:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 80080ac:	687b      	ldr	r3, [r7, #4]
 80080ae:	f003 0307 	and.w	r3, r3, #7
 80080b2:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80080b4:	4b0b      	ldr	r3, [pc, #44]	; (80080e4 <NVIC_SetPriorityGrouping+0x40>)
 80080b6:	68db      	ldr	r3, [r3, #12]
 80080b8:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 80080ba:	68ba      	ldr	r2, [r7, #8]
 80080bc:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 80080c0:	4013      	ands	r3, r2
 80080c2:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
 80080c4:	68fb      	ldr	r3, [r7, #12]
 80080c6:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80080c8:	68bb      	ldr	r3, [r7, #8]
 80080ca:	431a      	orrs	r2, r3
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 80080cc:	4b06      	ldr	r3, [pc, #24]	; (80080e8 <NVIC_SetPriorityGrouping+0x44>)
 80080ce:	4313      	orrs	r3, r2
 80080d0:	60bb      	str	r3, [r7, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80080d2:	4a04      	ldr	r2, [pc, #16]	; (80080e4 <NVIC_SetPriorityGrouping+0x40>)
 80080d4:	68bb      	ldr	r3, [r7, #8]
 80080d6:	60d3      	str	r3, [r2, #12]
}
 80080d8:	3714      	adds	r7, #20
 80080da:	46bd      	mov	sp, r7
 80080dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80080e0:	4770      	bx	lr
 80080e2:	bf00      	nop
 80080e4:	e000ed00 	.word	0xe000ed00
 80080e8:	05fa0000 	.word	0x05fa0000

080080ec <NVIC_GetPriorityGrouping>:
  The function reads the priority grouping field from the NVIC Interrupt Controller.

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
 80080ec:	b480      	push	{r7}
 80080ee:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80080f0:	4b04      	ldr	r3, [pc, #16]	; (8008104 <NVIC_GetPriorityGrouping+0x18>)
 80080f2:	68db      	ldr	r3, [r3, #12]
 80080f4:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 80080f8:	0a1b      	lsrs	r3, r3, #8
}
 80080fa:	4618      	mov	r0, r3
 80080fc:	46bd      	mov	sp, r7
 80080fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008102:	4770      	bx	lr
 8008104:	e000ed00 	.word	0xe000ed00

08008108 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8008108:	b480      	push	{r7}
 800810a:	b083      	sub	sp, #12
 800810c:	af00      	add	r7, sp, #0
 800810e:	4603      	mov	r3, r0
 8008110:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8008112:	4908      	ldr	r1, [pc, #32]	; (8008134 <NVIC_EnableIRQ+0x2c>)
 8008114:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8008118:	095b      	lsrs	r3, r3, #5
 800811a:	79fa      	ldrb	r2, [r7, #7]
 800811c:	f002 021f 	and.w	r2, r2, #31
 8008120:	2001      	movs	r0, #1
 8008122:	fa00 f202 	lsl.w	r2, r0, r2
 8008126:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 800812a:	370c      	adds	r7, #12
 800812c:	46bd      	mov	sp, r7
 800812e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008132:	4770      	bx	lr
 8008134:	e000e100 	.word	0xe000e100

08008138 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
 8008138:	b480      	push	{r7}
 800813a:	b083      	sub	sp, #12
 800813c:	af00      	add	r7, sp, #0
 800813e:	4603      	mov	r3, r0
 8008140:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8008142:	4909      	ldr	r1, [pc, #36]	; (8008168 <NVIC_DisableIRQ+0x30>)
 8008144:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8008148:	095b      	lsrs	r3, r3, #5
 800814a:	79fa      	ldrb	r2, [r7, #7]
 800814c:	f002 021f 	and.w	r2, r2, #31
 8008150:	2001      	movs	r0, #1
 8008152:	fa00 f202 	lsl.w	r2, r0, r2
 8008156:	3320      	adds	r3, #32
 8008158:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 800815c:	370c      	adds	r7, #12
 800815e:	46bd      	mov	sp, r7
 8008160:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008164:	4770      	bx	lr
 8008166:	bf00      	nop
 8008168:	e000e100 	.word	0xe000e100

0800816c <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800816c:	b480      	push	{r7}
 800816e:	b083      	sub	sp, #12
 8008170:	af00      	add	r7, sp, #0
 8008172:	4603      	mov	r3, r0
 8008174:	6039      	str	r1, [r7, #0]
 8008176:	71fb      	strb	r3, [r7, #7]
  if((int32_t)IRQn < 0) {
 8008178:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800817c:	2b00      	cmp	r3, #0
 800817e:	da0b      	bge.n	8008198 <NVIC_SetPriority+0x2c>
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8008180:	490d      	ldr	r1, [pc, #52]	; (80081b8 <NVIC_SetPriority+0x4c>)
 8008182:	79fb      	ldrb	r3, [r7, #7]
 8008184:	f003 030f 	and.w	r3, r3, #15
 8008188:	3b04      	subs	r3, #4
 800818a:	683a      	ldr	r2, [r7, #0]
 800818c:	b2d2      	uxtb	r2, r2
 800818e:	0112      	lsls	r2, r2, #4
 8008190:	b2d2      	uxtb	r2, r2
 8008192:	440b      	add	r3, r1
 8008194:	761a      	strb	r2, [r3, #24]
 8008196:	e009      	b.n	80081ac <NVIC_SetPriority+0x40>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]                = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8008198:	4908      	ldr	r1, [pc, #32]	; (80081bc <NVIC_SetPriority+0x50>)
 800819a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800819e:	683a      	ldr	r2, [r7, #0]
 80081a0:	b2d2      	uxtb	r2, r2
 80081a2:	0112      	lsls	r2, r2, #4
 80081a4:	b2d2      	uxtb	r2, r2
 80081a6:	440b      	add	r3, r1
 80081a8:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 80081ac:	370c      	adds	r7, #12
 80081ae:	46bd      	mov	sp, r7
 80081b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80081b4:	4770      	bx	lr
 80081b6:	bf00      	nop
 80081b8:	e000ed00 	.word	0xe000ed00
 80081bc:	e000e100 	.word	0xe000e100

080081c0 <NVIC_EncodePriority>:
    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
    \param [in]       SubPriority  Subpriority value (starting from 0).
    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80081c0:	b480      	push	{r7}
 80081c2:	b089      	sub	sp, #36	; 0x24
 80081c4:	af00      	add	r7, sp, #0
 80081c6:	60f8      	str	r0, [r7, #12]
 80081c8:	60b9      	str	r1, [r7, #8]
 80081ca:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 80081cc:	68fb      	ldr	r3, [r7, #12]
 80081ce:	f003 0307 	and.w	r3, r3, #7
 80081d2:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80081d4:	69fb      	ldr	r3, [r7, #28]
 80081d6:	f1c3 0307 	rsb	r3, r3, #7
 80081da:	2b04      	cmp	r3, #4
 80081dc:	bf28      	it	cs
 80081de:	2304      	movcs	r3, #4
 80081e0:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80081e2:	69fb      	ldr	r3, [r7, #28]
 80081e4:	3304      	adds	r3, #4
 80081e6:	2b06      	cmp	r3, #6
 80081e8:	d902      	bls.n	80081f0 <NVIC_EncodePriority+0x30>
 80081ea:	69fb      	ldr	r3, [r7, #28]
 80081ec:	3b03      	subs	r3, #3
 80081ee:	e000      	b.n	80081f2 <NVIC_EncodePriority+0x32>
 80081f0:	2300      	movs	r3, #0
 80081f2:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80081f4:	69bb      	ldr	r3, [r7, #24]
 80081f6:	2201      	movs	r2, #1
 80081f8:	fa02 f303 	lsl.w	r3, r2, r3
 80081fc:	1e5a      	subs	r2, r3, #1
 80081fe:	68bb      	ldr	r3, [r7, #8]
 8008200:	401a      	ands	r2, r3
 8008202:	697b      	ldr	r3, [r7, #20]
 8008204:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8008206:	697b      	ldr	r3, [r7, #20]
 8008208:	2101      	movs	r1, #1
 800820a:	fa01 f303 	lsl.w	r3, r1, r3
 800820e:	1e59      	subs	r1, r3, #1
 8008210:	687b      	ldr	r3, [r7, #4]
 8008212:	400b      	ands	r3, r1
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8008214:	4313      	orrs	r3, r2
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
         );
}
 8008216:	4618      	mov	r0, r3
 8008218:	3724      	adds	r7, #36	; 0x24
 800821a:	46bd      	mov	sp, r7
 800821c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008220:	4770      	bx	lr
 8008222:	bf00      	nop

08008224 <SysTick_Config>:
    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8008224:	b580      	push	{r7, lr}
 8008226:	b082      	sub	sp, #8
 8008228:	af00      	add	r7, sp, #0
 800822a:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
 800822c:	687b      	ldr	r3, [r7, #4]
 800822e:	3b01      	subs	r3, #1
 8008230:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8008234:	d301      	bcc.n	800823a <SysTick_Config+0x16>
 8008236:	2301      	movs	r3, #1
 8008238:	e00f      	b.n	800825a <SysTick_Config+0x36>

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800823a:	4a0a      	ldr	r2, [pc, #40]	; (8008264 <SysTick_Config+0x40>)
 800823c:	687b      	ldr	r3, [r7, #4]
 800823e:	3b01      	subs	r3, #1
 8008240:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8008242:	f04f 30ff 	mov.w	r0, #4294967295
 8008246:	210f      	movs	r1, #15
 8008248:	f7ff ff90 	bl	800816c <NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800824c:	4b05      	ldr	r3, [pc, #20]	; (8008264 <SysTick_Config+0x40>)
 800824e:	2200      	movs	r2, #0
 8008250:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8008252:	4b04      	ldr	r3, [pc, #16]	; (8008264 <SysTick_Config+0x40>)
 8008254:	2207      	movs	r2, #7
 8008256:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8008258:	2300      	movs	r3, #0
}
 800825a:	4618      	mov	r0, r3
 800825c:	3708      	adds	r7, #8
 800825e:	46bd      	mov	sp, r7
 8008260:	bd80      	pop	{r7, pc}
 8008262:	bf00      	nop
 8008264:	e000e010 	.word	0xe000e010

08008268 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8008268:	b580      	push	{r7, lr}
 800826a:	b082      	sub	sp, #8
 800826c:	af00      	add	r7, sp, #0
 800826e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8008270:	6878      	ldr	r0, [r7, #4]
 8008272:	f7ff ff17 	bl	80080a4 <NVIC_SetPriorityGrouping>
}
 8008276:	3708      	adds	r7, #8
 8008278:	46bd      	mov	sp, r7
 800827a:	bd80      	pop	{r7, pc}

0800827c <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800827c:	b580      	push	{r7, lr}
 800827e:	b086      	sub	sp, #24
 8008280:	af00      	add	r7, sp, #0
 8008282:	4603      	mov	r3, r0
 8008284:	60b9      	str	r1, [r7, #8]
 8008286:	607a      	str	r2, [r7, #4]
 8008288:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00;
 800828a:	2300      	movs	r3, #0
 800828c:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 800828e:	f7ff ff2d 	bl	80080ec <NVIC_GetPriorityGrouping>
 8008292:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8008294:	6978      	ldr	r0, [r7, #20]
 8008296:	68b9      	ldr	r1, [r7, #8]
 8008298:	687a      	ldr	r2, [r7, #4]
 800829a:	f7ff ff91 	bl	80081c0 <NVIC_EncodePriority>
 800829e:	4602      	mov	r2, r0
 80082a0:	f997 300f 	ldrsb.w	r3, [r7, #15]
 80082a4:	4618      	mov	r0, r3
 80082a6:	4611      	mov	r1, r2
 80082a8:	f7ff ff60 	bl	800816c <NVIC_SetPriority>
}
 80082ac:	3718      	adds	r7, #24
 80082ae:	46bd      	mov	sp, r7
 80082b0:	bd80      	pop	{r7, pc}
 80082b2:	bf00      	nop

080082b4 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80082b4:	b580      	push	{r7, lr}
 80082b6:	b082      	sub	sp, #8
 80082b8:	af00      	add	r7, sp, #0
 80082ba:	4603      	mov	r3, r0
 80082bc:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 80082be:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80082c2:	4618      	mov	r0, r3
 80082c4:	f7ff ff20 	bl	8008108 <NVIC_EnableIRQ>
}
 80082c8:	3708      	adds	r7, #8
 80082ca:	46bd      	mov	sp, r7
 80082cc:	bd80      	pop	{r7, pc}
 80082ce:	bf00      	nop

080082d0 <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
 80082d0:	b580      	push	{r7, lr}
 80082d2:	b082      	sub	sp, #8
 80082d4:	af00      	add	r7, sp, #0
 80082d6:	4603      	mov	r3, r0
 80082d8:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
 80082da:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80082de:	4618      	mov	r0, r3
 80082e0:	f7ff ff2a 	bl	8008138 <NVIC_DisableIRQ>
}
 80082e4:	3708      	adds	r7, #8
 80082e6:	46bd      	mov	sp, r7
 80082e8:	bd80      	pop	{r7, pc}
 80082ea:	bf00      	nop

080082ec <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 80082ec:	b580      	push	{r7, lr}
 80082ee:	b082      	sub	sp, #8
 80082f0:	af00      	add	r7, sp, #0
 80082f2:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 80082f4:	6878      	ldr	r0, [r7, #4]
 80082f6:	f7ff ff95 	bl	8008224 <SysTick_Config>
 80082fa:	4603      	mov	r3, r0
}
 80082fc:	4618      	mov	r0, r3
 80082fe:	3708      	adds	r7, #8
 8008300:	46bd      	mov	sp, r7
 8008302:	bd80      	pop	{r7, pc}

08008304 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init: Pointer to a MPU_Region_InitTypeDef structure that contains
  *                the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
 8008304:	b480      	push	{r7}
 8008306:	b083      	sub	sp, #12
 8008308:	af00      	add	r7, sp, #0
 800830a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
 800830c:	4a1d      	ldr	r2, [pc, #116]	; (8008384 <HAL_MPU_ConfigRegion+0x80>)
 800830e:	687b      	ldr	r3, [r7, #4]
 8008310:	785b      	ldrb	r3, [r3, #1]
 8008312:	6093      	str	r3, [r2, #8]

  if ((MPU_Init->Enable) != RESET)
 8008314:	687b      	ldr	r3, [r7, #4]
 8008316:	781b      	ldrb	r3, [r3, #0]
 8008318:	2b00      	cmp	r3, #0
 800831a:	d028      	beq.n	800836e <HAL_MPU_ConfigRegion+0x6a>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
 800831c:	4a19      	ldr	r2, [pc, #100]	; (8008384 <HAL_MPU_ConfigRegion+0x80>)
 800831e:	687b      	ldr	r3, [r7, #4]
 8008320:	685b      	ldr	r3, [r3, #4]
 8008322:	60d3      	str	r3, [r2, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8008324:	4917      	ldr	r1, [pc, #92]	; (8008384 <HAL_MPU_ConfigRegion+0x80>)
 8008326:	687b      	ldr	r3, [r7, #4]
 8008328:	7b1b      	ldrb	r3, [r3, #12]
 800832a:	071a      	lsls	r2, r3, #28
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 800832c:	687b      	ldr	r3, [r7, #4]
 800832e:	7adb      	ldrb	r3, [r3, #11]
 8008330:	061b      	lsls	r3, r3, #24
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8008332:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 8008334:	687b      	ldr	r3, [r7, #4]
 8008336:	7a9b      	ldrb	r3, [r3, #10]
 8008338:	04db      	lsls	r3, r3, #19
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 800833a:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 800833c:	687b      	ldr	r3, [r7, #4]
 800833e:	7b5b      	ldrb	r3, [r3, #13]
 8008340:	049b      	lsls	r3, r3, #18
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 8008342:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 8008344:	687b      	ldr	r3, [r7, #4]
 8008346:	7b9b      	ldrb	r3, [r3, #14]
 8008348:	045b      	lsls	r3, r3, #17
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 800834a:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 800834c:	687b      	ldr	r3, [r7, #4]
 800834e:	7bdb      	ldrb	r3, [r3, #15]
 8008350:	041b      	lsls	r3, r3, #16
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 8008352:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 8008354:	687b      	ldr	r3, [r7, #4]
 8008356:	7a5b      	ldrb	r3, [r3, #9]
 8008358:	021b      	lsls	r3, r3, #8
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 800835a:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 800835c:	687b      	ldr	r3, [r7, #4]
 800835e:	7a1b      	ldrb	r3, [r3, #8]
 8008360:	005b      	lsls	r3, r3, #1
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 8008362:	4313      	orrs	r3, r2
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
 8008364:	687a      	ldr	r2, [r7, #4]
 8008366:	7812      	ldrb	r2, [r2, #0]
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8008368:	4313      	orrs	r3, r2
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 800836a:	610b      	str	r3, [r1, #16]
 800836c:	e005      	b.n	800837a <HAL_MPU_ConfigRegion+0x76>
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
  }
  else
  {
    MPU->RBAR = 0x00;
 800836e:	4b05      	ldr	r3, [pc, #20]	; (8008384 <HAL_MPU_ConfigRegion+0x80>)
 8008370:	2200      	movs	r2, #0
 8008372:	60da      	str	r2, [r3, #12]
    MPU->RASR = 0x00;
 8008374:	4b03      	ldr	r3, [pc, #12]	; (8008384 <HAL_MPU_ConfigRegion+0x80>)
 8008376:	2200      	movs	r2, #0
 8008378:	611a      	str	r2, [r3, #16]
  }
}
 800837a:	370c      	adds	r7, #12
 800837c:	46bd      	mov	sp, r7
 800837e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008382:	4770      	bx	lr
 8008384:	e000ed90 	.word	0xe000ed90

08008388 <DMA_SetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8008388:	b480      	push	{r7}
 800838a:	b085      	sub	sp, #20
 800838c:	af00      	add	r7, sp, #0
 800838e:	60f8      	str	r0, [r7, #12]
 8008390:	60b9      	str	r1, [r7, #8]
 8008392:	607a      	str	r2, [r7, #4]
 8008394:	603b      	str	r3, [r7, #0]
  /* Clear DBM bit */
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8008396:	68fb      	ldr	r3, [r7, #12]
 8008398:	681b      	ldr	r3, [r3, #0]
 800839a:	68fa      	ldr	r2, [r7, #12]
 800839c:	6812      	ldr	r2, [r2, #0]
 800839e:	6812      	ldr	r2, [r2, #0]
 80083a0:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80083a4:	601a      	str	r2, [r3, #0]
	
  /* Configure DMA Stream data length */
  hdma->Instance->NDTR = DataLength;
 80083a6:	68fb      	ldr	r3, [r7, #12]
 80083a8:	681b      	ldr	r3, [r3, #0]
 80083aa:	683a      	ldr	r2, [r7, #0]
 80083ac:	605a      	str	r2, [r3, #4]

  /* Peripheral to Memory */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 80083ae:	68fb      	ldr	r3, [r7, #12]
 80083b0:	689b      	ldr	r3, [r3, #8]
 80083b2:	2b40      	cmp	r3, #64	; 0x40
 80083b4:	d108      	bne.n	80083c8 <DMA_SetConfig+0x40>
  {
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;
 80083b6:	68fb      	ldr	r3, [r7, #12]
 80083b8:	681b      	ldr	r3, [r3, #0]
 80083ba:	687a      	ldr	r2, [r7, #4]
 80083bc:	609a      	str	r2, [r3, #8]

    /* Configure DMA Stream source address */
    hdma->Instance->M0AR = SrcAddress;
 80083be:	68fb      	ldr	r3, [r7, #12]
 80083c0:	681b      	ldr	r3, [r3, #0]
 80083c2:	68ba      	ldr	r2, [r7, #8]
 80083c4:	60da      	str	r2, [r3, #12]
 80083c6:	e007      	b.n	80083d8 <DMA_SetConfig+0x50>
  }
  /* Memory to Peripheral */
  else
  {
    /* Configure DMA Stream source address */
    hdma->Instance->PAR = SrcAddress;
 80083c8:	68fb      	ldr	r3, [r7, #12]
 80083ca:	681b      	ldr	r3, [r3, #0]
 80083cc:	68ba      	ldr	r2, [r7, #8]
 80083ce:	609a      	str	r2, [r3, #8]
    
    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
 80083d0:	68fb      	ldr	r3, [r7, #12]
 80083d2:	681b      	ldr	r3, [r3, #0]
 80083d4:	687a      	ldr	r2, [r7, #4]
 80083d6:	60da      	str	r2, [r3, #12]
  }
}
 80083d8:	3714      	adds	r7, #20
 80083da:	46bd      	mov	sp, r7
 80083dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80083e0:	4770      	bx	lr
 80083e2:	bf00      	nop

080083e4 <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{ 
 80083e4:	b480      	push	{r7}
 80083e6:	b085      	sub	sp, #20
 80083e8:	af00      	add	r7, sp, #0
 80083ea:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0;
 80083ec:	2300      	movs	r3, #0
 80083ee:	60fb      	str	r3, [r7, #12]
  
  /* Check the DMA peripheral state */
  if(hdma == NULL)
 80083f0:	687b      	ldr	r3, [r7, #4]
 80083f2:	2b00      	cmp	r3, #0
 80083f4:	d101      	bne.n	80083fa <HAL_DMA_Init+0x16>
  {
    return HAL_ERROR;
 80083f6:	2301      	movs	r3, #1
 80083f8:	e057      	b.n	80084aa <HAL_DMA_Init+0xc6>
    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
  }

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 80083fa:	687b      	ldr	r3, [r7, #4]
 80083fc:	2202      	movs	r2, #2
 80083fe:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  /* Get the CR register value */
  tmp = hdma->Instance->CR;
 8008402:	687b      	ldr	r3, [r7, #4]
 8008404:	681b      	ldr	r3, [r3, #0]
 8008406:	681b      	ldr	r3, [r3, #0]
 8008408:	60fb      	str	r3, [r7, #12]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 800840a:	68fa      	ldr	r2, [r7, #12]
 800840c:	4b2a      	ldr	r3, [pc, #168]	; (80084b8 <HAL_DMA_Init+0xd4>)
 800840e:	4013      	ands	r3, r2
 8008410:	60fb      	str	r3, [r7, #12]
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8008412:	687b      	ldr	r3, [r7, #4]
 8008414:	685a      	ldr	r2, [r3, #4]
 8008416:	687b      	ldr	r3, [r7, #4]
 8008418:	689b      	ldr	r3, [r3, #8]
 800841a:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800841c:	687b      	ldr	r3, [r7, #4]
 800841e:	68db      	ldr	r3, [r3, #12]
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8008420:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8008422:	687b      	ldr	r3, [r7, #4]
 8008424:	691b      	ldr	r3, [r3, #16]
 8008426:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8008428:	687b      	ldr	r3, [r7, #4]
 800842a:	695b      	ldr	r3, [r3, #20]
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800842c:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800842e:	687b      	ldr	r3, [r7, #4]
 8008430:	699b      	ldr	r3, [r3, #24]
 8008432:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 8008434:	687b      	ldr	r3, [r7, #4]
 8008436:	69db      	ldr	r3, [r3, #28]
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8008438:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 800843a:	687b      	ldr	r3, [r7, #4]
 800843c:	6a1b      	ldr	r3, [r3, #32]
 800843e:	4313      	orrs	r3, r2
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8008440:	68fa      	ldr	r2, [r7, #12]
 8008442:	4313      	orrs	r3, r2
 8008444:	60fb      	str	r3, [r7, #12]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
          hdma->Init.Mode                | hdma->Init.Priority;

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8008446:	687b      	ldr	r3, [r7, #4]
 8008448:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800844a:	2b04      	cmp	r3, #4
 800844c:	d107      	bne.n	800845e <HAL_DMA_Init+0x7a>
  {
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 800844e:	687b      	ldr	r3, [r7, #4]
 8008450:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8008452:	687b      	ldr	r3, [r7, #4]
 8008454:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008456:	4313      	orrs	r3, r2
 8008458:	68fa      	ldr	r2, [r7, #12]
 800845a:	4313      	orrs	r3, r2
 800845c:	60fb      	str	r3, [r7, #12]
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 800845e:	687b      	ldr	r3, [r7, #4]
 8008460:	681b      	ldr	r3, [r3, #0]
 8008462:	68fa      	ldr	r2, [r7, #12]
 8008464:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 8008466:	687b      	ldr	r3, [r7, #4]
 8008468:	681b      	ldr	r3, [r3, #0]
 800846a:	695b      	ldr	r3, [r3, #20]
 800846c:	60fb      	str	r3, [r7, #12]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 800846e:	68fb      	ldr	r3, [r7, #12]
 8008470:	f023 0307 	bic.w	r3, r3, #7
 8008474:	60fb      	str	r3, [r7, #12]

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 8008476:	687b      	ldr	r3, [r7, #4]
 8008478:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800847a:	68fa      	ldr	r2, [r7, #12]
 800847c:	4313      	orrs	r3, r2
 800847e:	60fb      	str	r3, [r7, #12]

  /* the FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8008480:	687b      	ldr	r3, [r7, #4]
 8008482:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8008484:	2b04      	cmp	r3, #4
 8008486:	d104      	bne.n	8008492 <HAL_DMA_Init+0xae>
  {
    /* Get the FIFO threshold */
    tmp |= hdma->Init.FIFOThreshold;
 8008488:	687b      	ldr	r3, [r7, #4]
 800848a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800848c:	68fa      	ldr	r2, [r7, #12]
 800848e:	4313      	orrs	r3, r2
 8008490:	60fb      	str	r3, [r7, #12]
  }
  
  /* Write to DMA Stream FCR */
  hdma->Instance->FCR = tmp;
 8008492:	687b      	ldr	r3, [r7, #4]
 8008494:	681b      	ldr	r3, [r3, #0]
 8008496:	68fa      	ldr	r2, [r7, #12]
 8008498:	615a      	str	r2, [r3, #20]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800849a:	687b      	ldr	r3, [r7, #4]
 800849c:	2200      	movs	r2, #0
 800849e:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 80084a0:	687b      	ldr	r3, [r7, #4]
 80084a2:	2201      	movs	r2, #1
 80084a4:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
 80084a8:	2300      	movs	r3, #0
}
 80084aa:	4618      	mov	r0, r3
 80084ac:	3714      	adds	r7, #20
 80084ae:	46bd      	mov	sp, r7
 80084b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80084b4:	4770      	bx	lr
 80084b6:	bf00      	nop
 80084b8:	f010803f 	.word	0xf010803f

080084bc <HAL_DMA_DeInit>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
 80084bc:	b480      	push	{r7}
 80084be:	b083      	sub	sp, #12
 80084c0:	af00      	add	r7, sp, #0
 80084c2:	6078      	str	r0, [r7, #4]
  /* Check the DMA peripheral state */
  if(hdma == NULL)
 80084c4:	687b      	ldr	r3, [r7, #4]
 80084c6:	2b00      	cmp	r3, #0
 80084c8:	d102      	bne.n	80084d0 <HAL_DMA_DeInit+0x14>
  {
    return HAL_ERROR;
 80084ca:	2301      	movs	r3, #1
 80084cc:	f001 b9f5 	b.w	80098ba <HAL_DMA_DeInit+0x13fe>
  }
  
  /* Check the DMA peripheral state */
  if(hdma->State == HAL_DMA_STATE_BUSY)
 80084d0:	687b      	ldr	r3, [r7, #4]
 80084d2:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 80084d6:	b2db      	uxtb	r3, r3
 80084d8:	2b02      	cmp	r3, #2
 80084da:	d102      	bne.n	80084e2 <HAL_DMA_DeInit+0x26>
  {
     return HAL_ERROR;
 80084dc:	2301      	movs	r3, #1
 80084de:	f001 b9ec 	b.w	80098ba <HAL_DMA_DeInit+0x13fe>
  }

  /* Disable the selected DMA Streamx */
  __HAL_DMA_DISABLE(hdma);
 80084e2:	687b      	ldr	r3, [r7, #4]
 80084e4:	681b      	ldr	r3, [r3, #0]
 80084e6:	687a      	ldr	r2, [r7, #4]
 80084e8:	6812      	ldr	r2, [r2, #0]
 80084ea:	6812      	ldr	r2, [r2, #0]
 80084ec:	f022 0201 	bic.w	r2, r2, #1
 80084f0:	601a      	str	r2, [r3, #0]

  /* Reset DMA Streamx control register */
  hdma->Instance->CR   = 0;
 80084f2:	687b      	ldr	r3, [r7, #4]
 80084f4:	681b      	ldr	r3, [r3, #0]
 80084f6:	2200      	movs	r2, #0
 80084f8:	601a      	str	r2, [r3, #0]

  /* Reset DMA Streamx number of data to transfer register */
  hdma->Instance->NDTR = 0;
 80084fa:	687b      	ldr	r3, [r7, #4]
 80084fc:	681b      	ldr	r3, [r3, #0]
 80084fe:	2200      	movs	r2, #0
 8008500:	605a      	str	r2, [r3, #4]

  /* Reset DMA Streamx peripheral address register */
  hdma->Instance->PAR  = 0;
 8008502:	687b      	ldr	r3, [r7, #4]
 8008504:	681b      	ldr	r3, [r3, #0]
 8008506:	2200      	movs	r2, #0
 8008508:	609a      	str	r2, [r3, #8]

  /* Reset DMA Streamx memory 0 address register */
  hdma->Instance->M0AR = 0;
 800850a:	687b      	ldr	r3, [r7, #4]
 800850c:	681b      	ldr	r3, [r3, #0]
 800850e:	2200      	movs	r2, #0
 8008510:	60da      	str	r2, [r3, #12]

  /* Reset DMA Streamx memory 1 address register */
  hdma->Instance->M1AR = 0;
 8008512:	687b      	ldr	r3, [r7, #4]
 8008514:	681b      	ldr	r3, [r3, #0]
 8008516:	2200      	movs	r2, #0
 8008518:	611a      	str	r2, [r3, #16]

  /* Reset DMA Streamx FIFO control register */
  hdma->Instance->FCR  = (uint32_t)0x00000021;
 800851a:	687b      	ldr	r3, [r7, #4]
 800851c:	681b      	ldr	r3, [r3, #0]
 800851e:	2221      	movs	r2, #33	; 0x21
 8008520:	615a      	str	r2, [r3, #20]

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8008522:	687b      	ldr	r3, [r7, #4]
 8008524:	681b      	ldr	r3, [r3, #0]
 8008526:	461a      	mov	r2, r3
 8008528:	4b9c      	ldr	r3, [pc, #624]	; (800879c <HAL_DMA_DeInit+0x2e0>)
 800852a:	429a      	cmp	r2, r3
 800852c:	d96c      	bls.n	8008608 <HAL_DMA_DeInit+0x14c>
 800852e:	4a9c      	ldr	r2, [pc, #624]	; (80087a0 <HAL_DMA_DeInit+0x2e4>)
 8008530:	687b      	ldr	r3, [r7, #4]
 8008532:	681b      	ldr	r3, [r3, #0]
 8008534:	4619      	mov	r1, r3
 8008536:	4b9b      	ldr	r3, [pc, #620]	; (80087a4 <HAL_DMA_DeInit+0x2e8>)
 8008538:	4299      	cmp	r1, r3
 800853a:	d062      	beq.n	8008602 <HAL_DMA_DeInit+0x146>
 800853c:	687b      	ldr	r3, [r7, #4]
 800853e:	681b      	ldr	r3, [r3, #0]
 8008540:	4619      	mov	r1, r3
 8008542:	4b99      	ldr	r3, [pc, #612]	; (80087a8 <HAL_DMA_DeInit+0x2ec>)
 8008544:	4299      	cmp	r1, r3
 8008546:	d05a      	beq.n	80085fe <HAL_DMA_DeInit+0x142>
 8008548:	687b      	ldr	r3, [r7, #4]
 800854a:	681b      	ldr	r3, [r3, #0]
 800854c:	4619      	mov	r1, r3
 800854e:	4b97      	ldr	r3, [pc, #604]	; (80087ac <HAL_DMA_DeInit+0x2f0>)
 8008550:	4299      	cmp	r1, r3
 8008552:	d052      	beq.n	80085fa <HAL_DMA_DeInit+0x13e>
 8008554:	687b      	ldr	r3, [r7, #4]
 8008556:	681b      	ldr	r3, [r3, #0]
 8008558:	4619      	mov	r1, r3
 800855a:	4b95      	ldr	r3, [pc, #596]	; (80087b0 <HAL_DMA_DeInit+0x2f4>)
 800855c:	4299      	cmp	r1, r3
 800855e:	d04a      	beq.n	80085f6 <HAL_DMA_DeInit+0x13a>
 8008560:	687b      	ldr	r3, [r7, #4]
 8008562:	681b      	ldr	r3, [r3, #0]
 8008564:	4619      	mov	r1, r3
 8008566:	4b93      	ldr	r3, [pc, #588]	; (80087b4 <HAL_DMA_DeInit+0x2f8>)
 8008568:	4299      	cmp	r1, r3
 800856a:	d041      	beq.n	80085f0 <HAL_DMA_DeInit+0x134>
 800856c:	687b      	ldr	r3, [r7, #4]
 800856e:	681b      	ldr	r3, [r3, #0]
 8008570:	4619      	mov	r1, r3
 8008572:	4b91      	ldr	r3, [pc, #580]	; (80087b8 <HAL_DMA_DeInit+0x2fc>)
 8008574:	4299      	cmp	r1, r3
 8008576:	d038      	beq.n	80085ea <HAL_DMA_DeInit+0x12e>
 8008578:	687b      	ldr	r3, [r7, #4]
 800857a:	681b      	ldr	r3, [r3, #0]
 800857c:	4619      	mov	r1, r3
 800857e:	4b8f      	ldr	r3, [pc, #572]	; (80087bc <HAL_DMA_DeInit+0x300>)
 8008580:	4299      	cmp	r1, r3
 8008582:	d02f      	beq.n	80085e4 <HAL_DMA_DeInit+0x128>
 8008584:	687b      	ldr	r3, [r7, #4]
 8008586:	681b      	ldr	r3, [r3, #0]
 8008588:	4619      	mov	r1, r3
 800858a:	4b8d      	ldr	r3, [pc, #564]	; (80087c0 <HAL_DMA_DeInit+0x304>)
 800858c:	4299      	cmp	r1, r3
 800858e:	d026      	beq.n	80085de <HAL_DMA_DeInit+0x122>
 8008590:	687b      	ldr	r3, [r7, #4]
 8008592:	681b      	ldr	r3, [r3, #0]
 8008594:	4619      	mov	r1, r3
 8008596:	4b8b      	ldr	r3, [pc, #556]	; (80087c4 <HAL_DMA_DeInit+0x308>)
 8008598:	4299      	cmp	r1, r3
 800859a:	d01d      	beq.n	80085d8 <HAL_DMA_DeInit+0x11c>
 800859c:	687b      	ldr	r3, [r7, #4]
 800859e:	681b      	ldr	r3, [r3, #0]
 80085a0:	4619      	mov	r1, r3
 80085a2:	4b89      	ldr	r3, [pc, #548]	; (80087c8 <HAL_DMA_DeInit+0x30c>)
 80085a4:	4299      	cmp	r1, r3
 80085a6:	d014      	beq.n	80085d2 <HAL_DMA_DeInit+0x116>
 80085a8:	687b      	ldr	r3, [r7, #4]
 80085aa:	681b      	ldr	r3, [r3, #0]
 80085ac:	4619      	mov	r1, r3
 80085ae:	4b87      	ldr	r3, [pc, #540]	; (80087cc <HAL_DMA_DeInit+0x310>)
 80085b0:	4299      	cmp	r1, r3
 80085b2:	d00b      	beq.n	80085cc <HAL_DMA_DeInit+0x110>
 80085b4:	687b      	ldr	r3, [r7, #4]
 80085b6:	681b      	ldr	r3, [r3, #0]
 80085b8:	4619      	mov	r1, r3
 80085ba:	4b85      	ldr	r3, [pc, #532]	; (80087d0 <HAL_DMA_DeInit+0x314>)
 80085bc:	4299      	cmp	r1, r3
 80085be:	d102      	bne.n	80085c6 <HAL_DMA_DeInit+0x10a>
 80085c0:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80085c4:	e01e      	b.n	8008604 <HAL_DMA_DeInit+0x148>
 80085c6:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80085ca:	e01b      	b.n	8008604 <HAL_DMA_DeInit+0x148>
 80085cc:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80085d0:	e018      	b.n	8008604 <HAL_DMA_DeInit+0x148>
 80085d2:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80085d6:	e015      	b.n	8008604 <HAL_DMA_DeInit+0x148>
 80085d8:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80085dc:	e012      	b.n	8008604 <HAL_DMA_DeInit+0x148>
 80085de:	f44f 7380 	mov.w	r3, #256	; 0x100
 80085e2:	e00f      	b.n	8008604 <HAL_DMA_DeInit+0x148>
 80085e4:	f44f 7380 	mov.w	r3, #256	; 0x100
 80085e8:	e00c      	b.n	8008604 <HAL_DMA_DeInit+0x148>
 80085ea:	f44f 7380 	mov.w	r3, #256	; 0x100
 80085ee:	e009      	b.n	8008604 <HAL_DMA_DeInit+0x148>
 80085f0:	f44f 7380 	mov.w	r3, #256	; 0x100
 80085f4:	e006      	b.n	8008604 <HAL_DMA_DeInit+0x148>
 80085f6:	4b77      	ldr	r3, [pc, #476]	; (80087d4 <HAL_DMA_DeInit+0x318>)
 80085f8:	e004      	b.n	8008604 <HAL_DMA_DeInit+0x148>
 80085fa:	4b76      	ldr	r3, [pc, #472]	; (80087d4 <HAL_DMA_DeInit+0x318>)
 80085fc:	e002      	b.n	8008604 <HAL_DMA_DeInit+0x148>
 80085fe:	4b75      	ldr	r3, [pc, #468]	; (80087d4 <HAL_DMA_DeInit+0x318>)
 8008600:	e000      	b.n	8008604 <HAL_DMA_DeInit+0x148>
 8008602:	4b74      	ldr	r3, [pc, #464]	; (80087d4 <HAL_DMA_DeInit+0x318>)
 8008604:	60d3      	str	r3, [r2, #12]
 8008606:	e177      	b.n	80088f8 <HAL_DMA_DeInit+0x43c>
 8008608:	687b      	ldr	r3, [r7, #4]
 800860a:	681b      	ldr	r3, [r3, #0]
 800860c:	461a      	mov	r2, r3
 800860e:	4b72      	ldr	r3, [pc, #456]	; (80087d8 <HAL_DMA_DeInit+0x31c>)
 8008610:	429a      	cmp	r2, r3
 8008612:	d96c      	bls.n	80086ee <HAL_DMA_DeInit+0x232>
 8008614:	4a62      	ldr	r2, [pc, #392]	; (80087a0 <HAL_DMA_DeInit+0x2e4>)
 8008616:	687b      	ldr	r3, [r7, #4]
 8008618:	681b      	ldr	r3, [r3, #0]
 800861a:	4619      	mov	r1, r3
 800861c:	4b61      	ldr	r3, [pc, #388]	; (80087a4 <HAL_DMA_DeInit+0x2e8>)
 800861e:	4299      	cmp	r1, r3
 8008620:	d062      	beq.n	80086e8 <HAL_DMA_DeInit+0x22c>
 8008622:	687b      	ldr	r3, [r7, #4]
 8008624:	681b      	ldr	r3, [r3, #0]
 8008626:	4619      	mov	r1, r3
 8008628:	4b5f      	ldr	r3, [pc, #380]	; (80087a8 <HAL_DMA_DeInit+0x2ec>)
 800862a:	4299      	cmp	r1, r3
 800862c:	d05a      	beq.n	80086e4 <HAL_DMA_DeInit+0x228>
 800862e:	687b      	ldr	r3, [r7, #4]
 8008630:	681b      	ldr	r3, [r3, #0]
 8008632:	4619      	mov	r1, r3
 8008634:	4b5d      	ldr	r3, [pc, #372]	; (80087ac <HAL_DMA_DeInit+0x2f0>)
 8008636:	4299      	cmp	r1, r3
 8008638:	d052      	beq.n	80086e0 <HAL_DMA_DeInit+0x224>
 800863a:	687b      	ldr	r3, [r7, #4]
 800863c:	681b      	ldr	r3, [r3, #0]
 800863e:	4619      	mov	r1, r3
 8008640:	4b5b      	ldr	r3, [pc, #364]	; (80087b0 <HAL_DMA_DeInit+0x2f4>)
 8008642:	4299      	cmp	r1, r3
 8008644:	d04a      	beq.n	80086dc <HAL_DMA_DeInit+0x220>
 8008646:	687b      	ldr	r3, [r7, #4]
 8008648:	681b      	ldr	r3, [r3, #0]
 800864a:	4619      	mov	r1, r3
 800864c:	4b59      	ldr	r3, [pc, #356]	; (80087b4 <HAL_DMA_DeInit+0x2f8>)
 800864e:	4299      	cmp	r1, r3
 8008650:	d041      	beq.n	80086d6 <HAL_DMA_DeInit+0x21a>
 8008652:	687b      	ldr	r3, [r7, #4]
 8008654:	681b      	ldr	r3, [r3, #0]
 8008656:	4619      	mov	r1, r3
 8008658:	4b57      	ldr	r3, [pc, #348]	; (80087b8 <HAL_DMA_DeInit+0x2fc>)
 800865a:	4299      	cmp	r1, r3
 800865c:	d038      	beq.n	80086d0 <HAL_DMA_DeInit+0x214>
 800865e:	687b      	ldr	r3, [r7, #4]
 8008660:	681b      	ldr	r3, [r3, #0]
 8008662:	4619      	mov	r1, r3
 8008664:	4b55      	ldr	r3, [pc, #340]	; (80087bc <HAL_DMA_DeInit+0x300>)
 8008666:	4299      	cmp	r1, r3
 8008668:	d02f      	beq.n	80086ca <HAL_DMA_DeInit+0x20e>
 800866a:	687b      	ldr	r3, [r7, #4]
 800866c:	681b      	ldr	r3, [r3, #0]
 800866e:	4619      	mov	r1, r3
 8008670:	4b53      	ldr	r3, [pc, #332]	; (80087c0 <HAL_DMA_DeInit+0x304>)
 8008672:	4299      	cmp	r1, r3
 8008674:	d026      	beq.n	80086c4 <HAL_DMA_DeInit+0x208>
 8008676:	687b      	ldr	r3, [r7, #4]
 8008678:	681b      	ldr	r3, [r3, #0]
 800867a:	4619      	mov	r1, r3
 800867c:	4b51      	ldr	r3, [pc, #324]	; (80087c4 <HAL_DMA_DeInit+0x308>)
 800867e:	4299      	cmp	r1, r3
 8008680:	d01d      	beq.n	80086be <HAL_DMA_DeInit+0x202>
 8008682:	687b      	ldr	r3, [r7, #4]
 8008684:	681b      	ldr	r3, [r3, #0]
 8008686:	4619      	mov	r1, r3
 8008688:	4b4f      	ldr	r3, [pc, #316]	; (80087c8 <HAL_DMA_DeInit+0x30c>)
 800868a:	4299      	cmp	r1, r3
 800868c:	d014      	beq.n	80086b8 <HAL_DMA_DeInit+0x1fc>
 800868e:	687b      	ldr	r3, [r7, #4]
 8008690:	681b      	ldr	r3, [r3, #0]
 8008692:	4619      	mov	r1, r3
 8008694:	4b4d      	ldr	r3, [pc, #308]	; (80087cc <HAL_DMA_DeInit+0x310>)
 8008696:	4299      	cmp	r1, r3
 8008698:	d00b      	beq.n	80086b2 <HAL_DMA_DeInit+0x1f6>
 800869a:	687b      	ldr	r3, [r7, #4]
 800869c:	681b      	ldr	r3, [r3, #0]
 800869e:	4619      	mov	r1, r3
 80086a0:	4b4b      	ldr	r3, [pc, #300]	; (80087d0 <HAL_DMA_DeInit+0x314>)
 80086a2:	4299      	cmp	r1, r3
 80086a4:	d102      	bne.n	80086ac <HAL_DMA_DeInit+0x1f0>
 80086a6:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80086aa:	e01e      	b.n	80086ea <HAL_DMA_DeInit+0x22e>
 80086ac:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80086b0:	e01b      	b.n	80086ea <HAL_DMA_DeInit+0x22e>
 80086b2:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80086b6:	e018      	b.n	80086ea <HAL_DMA_DeInit+0x22e>
 80086b8:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80086bc:	e015      	b.n	80086ea <HAL_DMA_DeInit+0x22e>
 80086be:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80086c2:	e012      	b.n	80086ea <HAL_DMA_DeInit+0x22e>
 80086c4:	f44f 7380 	mov.w	r3, #256	; 0x100
 80086c8:	e00f      	b.n	80086ea <HAL_DMA_DeInit+0x22e>
 80086ca:	f44f 7380 	mov.w	r3, #256	; 0x100
 80086ce:	e00c      	b.n	80086ea <HAL_DMA_DeInit+0x22e>
 80086d0:	f44f 7380 	mov.w	r3, #256	; 0x100
 80086d4:	e009      	b.n	80086ea <HAL_DMA_DeInit+0x22e>
 80086d6:	f44f 7380 	mov.w	r3, #256	; 0x100
 80086da:	e006      	b.n	80086ea <HAL_DMA_DeInit+0x22e>
 80086dc:	4b3d      	ldr	r3, [pc, #244]	; (80087d4 <HAL_DMA_DeInit+0x318>)
 80086de:	e004      	b.n	80086ea <HAL_DMA_DeInit+0x22e>
 80086e0:	4b3c      	ldr	r3, [pc, #240]	; (80087d4 <HAL_DMA_DeInit+0x318>)
 80086e2:	e002      	b.n	80086ea <HAL_DMA_DeInit+0x22e>
 80086e4:	4b3b      	ldr	r3, [pc, #236]	; (80087d4 <HAL_DMA_DeInit+0x318>)
 80086e6:	e000      	b.n	80086ea <HAL_DMA_DeInit+0x22e>
 80086e8:	4b3a      	ldr	r3, [pc, #232]	; (80087d4 <HAL_DMA_DeInit+0x318>)
 80086ea:	6093      	str	r3, [r2, #8]
 80086ec:	e104      	b.n	80088f8 <HAL_DMA_DeInit+0x43c>
 80086ee:	687b      	ldr	r3, [r7, #4]
 80086f0:	681b      	ldr	r3, [r3, #0]
 80086f2:	461a      	mov	r2, r3
 80086f4:	4b39      	ldr	r3, [pc, #228]	; (80087dc <HAL_DMA_DeInit+0x320>)
 80086f6:	429a      	cmp	r2, r3
 80086f8:	f240 8092 	bls.w	8008820 <HAL_DMA_DeInit+0x364>
 80086fc:	4a38      	ldr	r2, [pc, #224]	; (80087e0 <HAL_DMA_DeInit+0x324>)
 80086fe:	687b      	ldr	r3, [r7, #4]
 8008700:	681b      	ldr	r3, [r3, #0]
 8008702:	4619      	mov	r1, r3
 8008704:	4b27      	ldr	r3, [pc, #156]	; (80087a4 <HAL_DMA_DeInit+0x2e8>)
 8008706:	4299      	cmp	r1, r3
 8008708:	f000 8087 	beq.w	800881a <HAL_DMA_DeInit+0x35e>
 800870c:	687b      	ldr	r3, [r7, #4]
 800870e:	681b      	ldr	r3, [r3, #0]
 8008710:	4619      	mov	r1, r3
 8008712:	4b25      	ldr	r3, [pc, #148]	; (80087a8 <HAL_DMA_DeInit+0x2ec>)
 8008714:	4299      	cmp	r1, r3
 8008716:	d07e      	beq.n	8008816 <HAL_DMA_DeInit+0x35a>
 8008718:	687b      	ldr	r3, [r7, #4]
 800871a:	681b      	ldr	r3, [r3, #0]
 800871c:	4619      	mov	r1, r3
 800871e:	4b23      	ldr	r3, [pc, #140]	; (80087ac <HAL_DMA_DeInit+0x2f0>)
 8008720:	4299      	cmp	r1, r3
 8008722:	d076      	beq.n	8008812 <HAL_DMA_DeInit+0x356>
 8008724:	687b      	ldr	r3, [r7, #4]
 8008726:	681b      	ldr	r3, [r3, #0]
 8008728:	4619      	mov	r1, r3
 800872a:	4b21      	ldr	r3, [pc, #132]	; (80087b0 <HAL_DMA_DeInit+0x2f4>)
 800872c:	4299      	cmp	r1, r3
 800872e:	d06e      	beq.n	800880e <HAL_DMA_DeInit+0x352>
 8008730:	687b      	ldr	r3, [r7, #4]
 8008732:	681b      	ldr	r3, [r3, #0]
 8008734:	4619      	mov	r1, r3
 8008736:	4b1f      	ldr	r3, [pc, #124]	; (80087b4 <HAL_DMA_DeInit+0x2f8>)
 8008738:	4299      	cmp	r1, r3
 800873a:	d065      	beq.n	8008808 <HAL_DMA_DeInit+0x34c>
 800873c:	687b      	ldr	r3, [r7, #4]
 800873e:	681b      	ldr	r3, [r3, #0]
 8008740:	4619      	mov	r1, r3
 8008742:	4b1d      	ldr	r3, [pc, #116]	; (80087b8 <HAL_DMA_DeInit+0x2fc>)
 8008744:	4299      	cmp	r1, r3
 8008746:	d05c      	beq.n	8008802 <HAL_DMA_DeInit+0x346>
 8008748:	687b      	ldr	r3, [r7, #4]
 800874a:	681b      	ldr	r3, [r3, #0]
 800874c:	4619      	mov	r1, r3
 800874e:	4b1b      	ldr	r3, [pc, #108]	; (80087bc <HAL_DMA_DeInit+0x300>)
 8008750:	4299      	cmp	r1, r3
 8008752:	d053      	beq.n	80087fc <HAL_DMA_DeInit+0x340>
 8008754:	687b      	ldr	r3, [r7, #4]
 8008756:	681b      	ldr	r3, [r3, #0]
 8008758:	4619      	mov	r1, r3
 800875a:	4b19      	ldr	r3, [pc, #100]	; (80087c0 <HAL_DMA_DeInit+0x304>)
 800875c:	4299      	cmp	r1, r3
 800875e:	d04a      	beq.n	80087f6 <HAL_DMA_DeInit+0x33a>
 8008760:	687b      	ldr	r3, [r7, #4]
 8008762:	681b      	ldr	r3, [r3, #0]
 8008764:	4619      	mov	r1, r3
 8008766:	4b17      	ldr	r3, [pc, #92]	; (80087c4 <HAL_DMA_DeInit+0x308>)
 8008768:	4299      	cmp	r1, r3
 800876a:	d041      	beq.n	80087f0 <HAL_DMA_DeInit+0x334>
 800876c:	687b      	ldr	r3, [r7, #4]
 800876e:	681b      	ldr	r3, [r3, #0]
 8008770:	4619      	mov	r1, r3
 8008772:	4b15      	ldr	r3, [pc, #84]	; (80087c8 <HAL_DMA_DeInit+0x30c>)
 8008774:	4299      	cmp	r1, r3
 8008776:	d038      	beq.n	80087ea <HAL_DMA_DeInit+0x32e>
 8008778:	687b      	ldr	r3, [r7, #4]
 800877a:	681b      	ldr	r3, [r3, #0]
 800877c:	4619      	mov	r1, r3
 800877e:	4b13      	ldr	r3, [pc, #76]	; (80087cc <HAL_DMA_DeInit+0x310>)
 8008780:	4299      	cmp	r1, r3
 8008782:	d02f      	beq.n	80087e4 <HAL_DMA_DeInit+0x328>
 8008784:	687b      	ldr	r3, [r7, #4]
 8008786:	681b      	ldr	r3, [r3, #0]
 8008788:	4619      	mov	r1, r3
 800878a:	4b11      	ldr	r3, [pc, #68]	; (80087d0 <HAL_DMA_DeInit+0x314>)
 800878c:	4299      	cmp	r1, r3
 800878e:	d102      	bne.n	8008796 <HAL_DMA_DeInit+0x2da>
 8008790:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8008794:	e042      	b.n	800881c <HAL_DMA_DeInit+0x360>
 8008796:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800879a:	e03f      	b.n	800881c <HAL_DMA_DeInit+0x360>
 800879c:	40026458 	.word	0x40026458
 80087a0:	40026400 	.word	0x40026400
 80087a4:	40026010 	.word	0x40026010
 80087a8:	40026410 	.word	0x40026410
 80087ac:	40026070 	.word	0x40026070
 80087b0:	40026470 	.word	0x40026470
 80087b4:	40026028 	.word	0x40026028
 80087b8:	40026428 	.word	0x40026428
 80087bc:	40026088 	.word	0x40026088
 80087c0:	40026488 	.word	0x40026488
 80087c4:	40026040 	.word	0x40026040
 80087c8:	40026440 	.word	0x40026440
 80087cc:	400260a0 	.word	0x400260a0
 80087d0:	400264a0 	.word	0x400264a0
 80087d4:	00800004 	.word	0x00800004
 80087d8:	400260b8 	.word	0x400260b8
 80087dc:	40026058 	.word	0x40026058
 80087e0:	40026000 	.word	0x40026000
 80087e4:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80087e8:	e018      	b.n	800881c <HAL_DMA_DeInit+0x360>
 80087ea:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80087ee:	e015      	b.n	800881c <HAL_DMA_DeInit+0x360>
 80087f0:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80087f4:	e012      	b.n	800881c <HAL_DMA_DeInit+0x360>
 80087f6:	f44f 7380 	mov.w	r3, #256	; 0x100
 80087fa:	e00f      	b.n	800881c <HAL_DMA_DeInit+0x360>
 80087fc:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008800:	e00c      	b.n	800881c <HAL_DMA_DeInit+0x360>
 8008802:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008806:	e009      	b.n	800881c <HAL_DMA_DeInit+0x360>
 8008808:	f44f 7380 	mov.w	r3, #256	; 0x100
 800880c:	e006      	b.n	800881c <HAL_DMA_DeInit+0x360>
 800880e:	4b74      	ldr	r3, [pc, #464]	; (80089e0 <HAL_DMA_DeInit+0x524>)
 8008810:	e004      	b.n	800881c <HAL_DMA_DeInit+0x360>
 8008812:	4b73      	ldr	r3, [pc, #460]	; (80089e0 <HAL_DMA_DeInit+0x524>)
 8008814:	e002      	b.n	800881c <HAL_DMA_DeInit+0x360>
 8008816:	4b72      	ldr	r3, [pc, #456]	; (80089e0 <HAL_DMA_DeInit+0x524>)
 8008818:	e000      	b.n	800881c <HAL_DMA_DeInit+0x360>
 800881a:	4b71      	ldr	r3, [pc, #452]	; (80089e0 <HAL_DMA_DeInit+0x524>)
 800881c:	60d3      	str	r3, [r2, #12]
 800881e:	e06b      	b.n	80088f8 <HAL_DMA_DeInit+0x43c>
 8008820:	4a70      	ldr	r2, [pc, #448]	; (80089e4 <HAL_DMA_DeInit+0x528>)
 8008822:	687b      	ldr	r3, [r7, #4]
 8008824:	681b      	ldr	r3, [r3, #0]
 8008826:	4619      	mov	r1, r3
 8008828:	4b6f      	ldr	r3, [pc, #444]	; (80089e8 <HAL_DMA_DeInit+0x52c>)
 800882a:	4299      	cmp	r1, r3
 800882c:	d062      	beq.n	80088f4 <HAL_DMA_DeInit+0x438>
 800882e:	687b      	ldr	r3, [r7, #4]
 8008830:	681b      	ldr	r3, [r3, #0]
 8008832:	4619      	mov	r1, r3
 8008834:	4b6d      	ldr	r3, [pc, #436]	; (80089ec <HAL_DMA_DeInit+0x530>)
 8008836:	4299      	cmp	r1, r3
 8008838:	d05a      	beq.n	80088f0 <HAL_DMA_DeInit+0x434>
 800883a:	687b      	ldr	r3, [r7, #4]
 800883c:	681b      	ldr	r3, [r3, #0]
 800883e:	4619      	mov	r1, r3
 8008840:	4b6b      	ldr	r3, [pc, #428]	; (80089f0 <HAL_DMA_DeInit+0x534>)
 8008842:	4299      	cmp	r1, r3
 8008844:	d052      	beq.n	80088ec <HAL_DMA_DeInit+0x430>
 8008846:	687b      	ldr	r3, [r7, #4]
 8008848:	681b      	ldr	r3, [r3, #0]
 800884a:	4619      	mov	r1, r3
 800884c:	4b69      	ldr	r3, [pc, #420]	; (80089f4 <HAL_DMA_DeInit+0x538>)
 800884e:	4299      	cmp	r1, r3
 8008850:	d04a      	beq.n	80088e8 <HAL_DMA_DeInit+0x42c>
 8008852:	687b      	ldr	r3, [r7, #4]
 8008854:	681b      	ldr	r3, [r3, #0]
 8008856:	4619      	mov	r1, r3
 8008858:	4b67      	ldr	r3, [pc, #412]	; (80089f8 <HAL_DMA_DeInit+0x53c>)
 800885a:	4299      	cmp	r1, r3
 800885c:	d041      	beq.n	80088e2 <HAL_DMA_DeInit+0x426>
 800885e:	687b      	ldr	r3, [r7, #4]
 8008860:	681b      	ldr	r3, [r3, #0]
 8008862:	4619      	mov	r1, r3
 8008864:	4b65      	ldr	r3, [pc, #404]	; (80089fc <HAL_DMA_DeInit+0x540>)
 8008866:	4299      	cmp	r1, r3
 8008868:	d038      	beq.n	80088dc <HAL_DMA_DeInit+0x420>
 800886a:	687b      	ldr	r3, [r7, #4]
 800886c:	681b      	ldr	r3, [r3, #0]
 800886e:	4619      	mov	r1, r3
 8008870:	4b63      	ldr	r3, [pc, #396]	; (8008a00 <HAL_DMA_DeInit+0x544>)
 8008872:	4299      	cmp	r1, r3
 8008874:	d02f      	beq.n	80088d6 <HAL_DMA_DeInit+0x41a>
 8008876:	687b      	ldr	r3, [r7, #4]
 8008878:	681b      	ldr	r3, [r3, #0]
 800887a:	4619      	mov	r1, r3
 800887c:	4b61      	ldr	r3, [pc, #388]	; (8008a04 <HAL_DMA_DeInit+0x548>)
 800887e:	4299      	cmp	r1, r3
 8008880:	d026      	beq.n	80088d0 <HAL_DMA_DeInit+0x414>
 8008882:	687b      	ldr	r3, [r7, #4]
 8008884:	681b      	ldr	r3, [r3, #0]
 8008886:	4619      	mov	r1, r3
 8008888:	4b5f      	ldr	r3, [pc, #380]	; (8008a08 <HAL_DMA_DeInit+0x54c>)
 800888a:	4299      	cmp	r1, r3
 800888c:	d01d      	beq.n	80088ca <HAL_DMA_DeInit+0x40e>
 800888e:	687b      	ldr	r3, [r7, #4]
 8008890:	681b      	ldr	r3, [r3, #0]
 8008892:	4619      	mov	r1, r3
 8008894:	4b5d      	ldr	r3, [pc, #372]	; (8008a0c <HAL_DMA_DeInit+0x550>)
 8008896:	4299      	cmp	r1, r3
 8008898:	d014      	beq.n	80088c4 <HAL_DMA_DeInit+0x408>
 800889a:	687b      	ldr	r3, [r7, #4]
 800889c:	681b      	ldr	r3, [r3, #0]
 800889e:	4619      	mov	r1, r3
 80088a0:	4b5b      	ldr	r3, [pc, #364]	; (8008a10 <HAL_DMA_DeInit+0x554>)
 80088a2:	4299      	cmp	r1, r3
 80088a4:	d00b      	beq.n	80088be <HAL_DMA_DeInit+0x402>
 80088a6:	687b      	ldr	r3, [r7, #4]
 80088a8:	681b      	ldr	r3, [r3, #0]
 80088aa:	4619      	mov	r1, r3
 80088ac:	4b59      	ldr	r3, [pc, #356]	; (8008a14 <HAL_DMA_DeInit+0x558>)
 80088ae:	4299      	cmp	r1, r3
 80088b0:	d102      	bne.n	80088b8 <HAL_DMA_DeInit+0x3fc>
 80088b2:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80088b6:	e01e      	b.n	80088f6 <HAL_DMA_DeInit+0x43a>
 80088b8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80088bc:	e01b      	b.n	80088f6 <HAL_DMA_DeInit+0x43a>
 80088be:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80088c2:	e018      	b.n	80088f6 <HAL_DMA_DeInit+0x43a>
 80088c4:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80088c8:	e015      	b.n	80088f6 <HAL_DMA_DeInit+0x43a>
 80088ca:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80088ce:	e012      	b.n	80088f6 <HAL_DMA_DeInit+0x43a>
 80088d0:	f44f 7380 	mov.w	r3, #256	; 0x100
 80088d4:	e00f      	b.n	80088f6 <HAL_DMA_DeInit+0x43a>
 80088d6:	f44f 7380 	mov.w	r3, #256	; 0x100
 80088da:	e00c      	b.n	80088f6 <HAL_DMA_DeInit+0x43a>
 80088dc:	f44f 7380 	mov.w	r3, #256	; 0x100
 80088e0:	e009      	b.n	80088f6 <HAL_DMA_DeInit+0x43a>
 80088e2:	f44f 7380 	mov.w	r3, #256	; 0x100
 80088e6:	e006      	b.n	80088f6 <HAL_DMA_DeInit+0x43a>
 80088e8:	4b3d      	ldr	r3, [pc, #244]	; (80089e0 <HAL_DMA_DeInit+0x524>)
 80088ea:	e004      	b.n	80088f6 <HAL_DMA_DeInit+0x43a>
 80088ec:	4b3c      	ldr	r3, [pc, #240]	; (80089e0 <HAL_DMA_DeInit+0x524>)
 80088ee:	e002      	b.n	80088f6 <HAL_DMA_DeInit+0x43a>
 80088f0:	4b3b      	ldr	r3, [pc, #236]	; (80089e0 <HAL_DMA_DeInit+0x524>)
 80088f2:	e000      	b.n	80088f6 <HAL_DMA_DeInit+0x43a>
 80088f4:	4b3a      	ldr	r3, [pc, #232]	; (80089e0 <HAL_DMA_DeInit+0x524>)
 80088f6:	6093      	str	r3, [r2, #8]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80088f8:	687b      	ldr	r3, [r7, #4]
 80088fa:	681b      	ldr	r3, [r3, #0]
 80088fc:	461a      	mov	r2, r3
 80088fe:	4b46      	ldr	r3, [pc, #280]	; (8008a18 <HAL_DMA_DeInit+0x55c>)
 8008900:	429a      	cmp	r2, r3
 8008902:	f240 808d 	bls.w	8008a20 <HAL_DMA_DeInit+0x564>
 8008906:	4a45      	ldr	r2, [pc, #276]	; (8008a1c <HAL_DMA_DeInit+0x560>)
 8008908:	687b      	ldr	r3, [r7, #4]
 800890a:	681b      	ldr	r3, [r3, #0]
 800890c:	4619      	mov	r1, r3
 800890e:	4b36      	ldr	r3, [pc, #216]	; (80089e8 <HAL_DMA_DeInit+0x52c>)
 8008910:	4299      	cmp	r1, r3
 8008912:	d062      	beq.n	80089da <HAL_DMA_DeInit+0x51e>
 8008914:	687b      	ldr	r3, [r7, #4]
 8008916:	681b      	ldr	r3, [r3, #0]
 8008918:	4619      	mov	r1, r3
 800891a:	4b34      	ldr	r3, [pc, #208]	; (80089ec <HAL_DMA_DeInit+0x530>)
 800891c:	4299      	cmp	r1, r3
 800891e:	d05a      	beq.n	80089d6 <HAL_DMA_DeInit+0x51a>
 8008920:	687b      	ldr	r3, [r7, #4]
 8008922:	681b      	ldr	r3, [r3, #0]
 8008924:	4619      	mov	r1, r3
 8008926:	4b32      	ldr	r3, [pc, #200]	; (80089f0 <HAL_DMA_DeInit+0x534>)
 8008928:	4299      	cmp	r1, r3
 800892a:	d052      	beq.n	80089d2 <HAL_DMA_DeInit+0x516>
 800892c:	687b      	ldr	r3, [r7, #4]
 800892e:	681b      	ldr	r3, [r3, #0]
 8008930:	4619      	mov	r1, r3
 8008932:	4b30      	ldr	r3, [pc, #192]	; (80089f4 <HAL_DMA_DeInit+0x538>)
 8008934:	4299      	cmp	r1, r3
 8008936:	d04a      	beq.n	80089ce <HAL_DMA_DeInit+0x512>
 8008938:	687b      	ldr	r3, [r7, #4]
 800893a:	681b      	ldr	r3, [r3, #0]
 800893c:	4619      	mov	r1, r3
 800893e:	4b2e      	ldr	r3, [pc, #184]	; (80089f8 <HAL_DMA_DeInit+0x53c>)
 8008940:	4299      	cmp	r1, r3
 8008942:	d041      	beq.n	80089c8 <HAL_DMA_DeInit+0x50c>
 8008944:	687b      	ldr	r3, [r7, #4]
 8008946:	681b      	ldr	r3, [r3, #0]
 8008948:	4619      	mov	r1, r3
 800894a:	4b2c      	ldr	r3, [pc, #176]	; (80089fc <HAL_DMA_DeInit+0x540>)
 800894c:	4299      	cmp	r1, r3
 800894e:	d038      	beq.n	80089c2 <HAL_DMA_DeInit+0x506>
 8008950:	687b      	ldr	r3, [r7, #4]
 8008952:	681b      	ldr	r3, [r3, #0]
 8008954:	4619      	mov	r1, r3
 8008956:	4b2a      	ldr	r3, [pc, #168]	; (8008a00 <HAL_DMA_DeInit+0x544>)
 8008958:	4299      	cmp	r1, r3
 800895a:	d02f      	beq.n	80089bc <HAL_DMA_DeInit+0x500>
 800895c:	687b      	ldr	r3, [r7, #4]
 800895e:	681b      	ldr	r3, [r3, #0]
 8008960:	4619      	mov	r1, r3
 8008962:	4b28      	ldr	r3, [pc, #160]	; (8008a04 <HAL_DMA_DeInit+0x548>)
 8008964:	4299      	cmp	r1, r3
 8008966:	d026      	beq.n	80089b6 <HAL_DMA_DeInit+0x4fa>
 8008968:	687b      	ldr	r3, [r7, #4]
 800896a:	681b      	ldr	r3, [r3, #0]
 800896c:	4619      	mov	r1, r3
 800896e:	4b26      	ldr	r3, [pc, #152]	; (8008a08 <HAL_DMA_DeInit+0x54c>)
 8008970:	4299      	cmp	r1, r3
 8008972:	d01d      	beq.n	80089b0 <HAL_DMA_DeInit+0x4f4>
 8008974:	687b      	ldr	r3, [r7, #4]
 8008976:	681b      	ldr	r3, [r3, #0]
 8008978:	4619      	mov	r1, r3
 800897a:	4b24      	ldr	r3, [pc, #144]	; (8008a0c <HAL_DMA_DeInit+0x550>)
 800897c:	4299      	cmp	r1, r3
 800897e:	d014      	beq.n	80089aa <HAL_DMA_DeInit+0x4ee>
 8008980:	687b      	ldr	r3, [r7, #4]
 8008982:	681b      	ldr	r3, [r3, #0]
 8008984:	4619      	mov	r1, r3
 8008986:	4b22      	ldr	r3, [pc, #136]	; (8008a10 <HAL_DMA_DeInit+0x554>)
 8008988:	4299      	cmp	r1, r3
 800898a:	d00b      	beq.n	80089a4 <HAL_DMA_DeInit+0x4e8>
 800898c:	687b      	ldr	r3, [r7, #4]
 800898e:	681b      	ldr	r3, [r3, #0]
 8008990:	4619      	mov	r1, r3
 8008992:	4b20      	ldr	r3, [pc, #128]	; (8008a14 <HAL_DMA_DeInit+0x558>)
 8008994:	4299      	cmp	r1, r3
 8008996:	d102      	bne.n	800899e <HAL_DMA_DeInit+0x4e2>
 8008998:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800899c:	e01e      	b.n	80089dc <HAL_DMA_DeInit+0x520>
 800899e:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80089a2:	e01b      	b.n	80089dc <HAL_DMA_DeInit+0x520>
 80089a4:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80089a8:	e018      	b.n	80089dc <HAL_DMA_DeInit+0x520>
 80089aa:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80089ae:	e015      	b.n	80089dc <HAL_DMA_DeInit+0x520>
 80089b0:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80089b4:	e012      	b.n	80089dc <HAL_DMA_DeInit+0x520>
 80089b6:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80089ba:	e00f      	b.n	80089dc <HAL_DMA_DeInit+0x520>
 80089bc:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80089c0:	e00c      	b.n	80089dc <HAL_DMA_DeInit+0x520>
 80089c2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80089c6:	e009      	b.n	80089dc <HAL_DMA_DeInit+0x520>
 80089c8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80089cc:	e006      	b.n	80089dc <HAL_DMA_DeInit+0x520>
 80089ce:	2320      	movs	r3, #32
 80089d0:	e004      	b.n	80089dc <HAL_DMA_DeInit+0x520>
 80089d2:	2320      	movs	r3, #32
 80089d4:	e002      	b.n	80089dc <HAL_DMA_DeInit+0x520>
 80089d6:	2320      	movs	r3, #32
 80089d8:	e000      	b.n	80089dc <HAL_DMA_DeInit+0x520>
 80089da:	2320      	movs	r3, #32
 80089dc:	60d3      	str	r3, [r2, #12]
 80089de:	e192      	b.n	8008d06 <HAL_DMA_DeInit+0x84a>
 80089e0:	00800004 	.word	0x00800004
 80089e4:	40026000 	.word	0x40026000
 80089e8:	40026010 	.word	0x40026010
 80089ec:	40026410 	.word	0x40026410
 80089f0:	40026070 	.word	0x40026070
 80089f4:	40026470 	.word	0x40026470
 80089f8:	40026028 	.word	0x40026028
 80089fc:	40026428 	.word	0x40026428
 8008a00:	40026088 	.word	0x40026088
 8008a04:	40026488 	.word	0x40026488
 8008a08:	40026040 	.word	0x40026040
 8008a0c:	40026440 	.word	0x40026440
 8008a10:	400260a0 	.word	0x400260a0
 8008a14:	400264a0 	.word	0x400264a0
 8008a18:	40026458 	.word	0x40026458
 8008a1c:	40026400 	.word	0x40026400
 8008a20:	687b      	ldr	r3, [r7, #4]
 8008a22:	681b      	ldr	r3, [r3, #0]
 8008a24:	461a      	mov	r2, r3
 8008a26:	4b9f      	ldr	r3, [pc, #636]	; (8008ca4 <HAL_DMA_DeInit+0x7e8>)
 8008a28:	429a      	cmp	r2, r3
 8008a2a:	d96c      	bls.n	8008b06 <HAL_DMA_DeInit+0x64a>
 8008a2c:	4a9e      	ldr	r2, [pc, #632]	; (8008ca8 <HAL_DMA_DeInit+0x7ec>)
 8008a2e:	687b      	ldr	r3, [r7, #4]
 8008a30:	681b      	ldr	r3, [r3, #0]
 8008a32:	4619      	mov	r1, r3
 8008a34:	4b9d      	ldr	r3, [pc, #628]	; (8008cac <HAL_DMA_DeInit+0x7f0>)
 8008a36:	4299      	cmp	r1, r3
 8008a38:	d062      	beq.n	8008b00 <HAL_DMA_DeInit+0x644>
 8008a3a:	687b      	ldr	r3, [r7, #4]
 8008a3c:	681b      	ldr	r3, [r3, #0]
 8008a3e:	4619      	mov	r1, r3
 8008a40:	4b9b      	ldr	r3, [pc, #620]	; (8008cb0 <HAL_DMA_DeInit+0x7f4>)
 8008a42:	4299      	cmp	r1, r3
 8008a44:	d05a      	beq.n	8008afc <HAL_DMA_DeInit+0x640>
 8008a46:	687b      	ldr	r3, [r7, #4]
 8008a48:	681b      	ldr	r3, [r3, #0]
 8008a4a:	4619      	mov	r1, r3
 8008a4c:	4b99      	ldr	r3, [pc, #612]	; (8008cb4 <HAL_DMA_DeInit+0x7f8>)
 8008a4e:	4299      	cmp	r1, r3
 8008a50:	d052      	beq.n	8008af8 <HAL_DMA_DeInit+0x63c>
 8008a52:	687b      	ldr	r3, [r7, #4]
 8008a54:	681b      	ldr	r3, [r3, #0]
 8008a56:	4619      	mov	r1, r3
 8008a58:	4b97      	ldr	r3, [pc, #604]	; (8008cb8 <HAL_DMA_DeInit+0x7fc>)
 8008a5a:	4299      	cmp	r1, r3
 8008a5c:	d04a      	beq.n	8008af4 <HAL_DMA_DeInit+0x638>
 8008a5e:	687b      	ldr	r3, [r7, #4]
 8008a60:	681b      	ldr	r3, [r3, #0]
 8008a62:	4619      	mov	r1, r3
 8008a64:	4b95      	ldr	r3, [pc, #596]	; (8008cbc <HAL_DMA_DeInit+0x800>)
 8008a66:	4299      	cmp	r1, r3
 8008a68:	d041      	beq.n	8008aee <HAL_DMA_DeInit+0x632>
 8008a6a:	687b      	ldr	r3, [r7, #4]
 8008a6c:	681b      	ldr	r3, [r3, #0]
 8008a6e:	4619      	mov	r1, r3
 8008a70:	4b93      	ldr	r3, [pc, #588]	; (8008cc0 <HAL_DMA_DeInit+0x804>)
 8008a72:	4299      	cmp	r1, r3
 8008a74:	d038      	beq.n	8008ae8 <HAL_DMA_DeInit+0x62c>
 8008a76:	687b      	ldr	r3, [r7, #4]
 8008a78:	681b      	ldr	r3, [r3, #0]
 8008a7a:	4619      	mov	r1, r3
 8008a7c:	4b91      	ldr	r3, [pc, #580]	; (8008cc4 <HAL_DMA_DeInit+0x808>)
 8008a7e:	4299      	cmp	r1, r3
 8008a80:	d02f      	beq.n	8008ae2 <HAL_DMA_DeInit+0x626>
 8008a82:	687b      	ldr	r3, [r7, #4]
 8008a84:	681b      	ldr	r3, [r3, #0]
 8008a86:	4619      	mov	r1, r3
 8008a88:	4b8f      	ldr	r3, [pc, #572]	; (8008cc8 <HAL_DMA_DeInit+0x80c>)
 8008a8a:	4299      	cmp	r1, r3
 8008a8c:	d026      	beq.n	8008adc <HAL_DMA_DeInit+0x620>
 8008a8e:	687b      	ldr	r3, [r7, #4]
 8008a90:	681b      	ldr	r3, [r3, #0]
 8008a92:	4619      	mov	r1, r3
 8008a94:	4b8d      	ldr	r3, [pc, #564]	; (8008ccc <HAL_DMA_DeInit+0x810>)
 8008a96:	4299      	cmp	r1, r3
 8008a98:	d01d      	beq.n	8008ad6 <HAL_DMA_DeInit+0x61a>
 8008a9a:	687b      	ldr	r3, [r7, #4]
 8008a9c:	681b      	ldr	r3, [r3, #0]
 8008a9e:	4619      	mov	r1, r3
 8008aa0:	4b8b      	ldr	r3, [pc, #556]	; (8008cd0 <HAL_DMA_DeInit+0x814>)
 8008aa2:	4299      	cmp	r1, r3
 8008aa4:	d014      	beq.n	8008ad0 <HAL_DMA_DeInit+0x614>
 8008aa6:	687b      	ldr	r3, [r7, #4]
 8008aa8:	681b      	ldr	r3, [r3, #0]
 8008aaa:	4619      	mov	r1, r3
 8008aac:	4b89      	ldr	r3, [pc, #548]	; (8008cd4 <HAL_DMA_DeInit+0x818>)
 8008aae:	4299      	cmp	r1, r3
 8008ab0:	d00b      	beq.n	8008aca <HAL_DMA_DeInit+0x60e>
 8008ab2:	687b      	ldr	r3, [r7, #4]
 8008ab4:	681b      	ldr	r3, [r3, #0]
 8008ab6:	4619      	mov	r1, r3
 8008ab8:	4b87      	ldr	r3, [pc, #540]	; (8008cd8 <HAL_DMA_DeInit+0x81c>)
 8008aba:	4299      	cmp	r1, r3
 8008abc:	d102      	bne.n	8008ac4 <HAL_DMA_DeInit+0x608>
 8008abe:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8008ac2:	e01e      	b.n	8008b02 <HAL_DMA_DeInit+0x646>
 8008ac4:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8008ac8:	e01b      	b.n	8008b02 <HAL_DMA_DeInit+0x646>
 8008aca:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8008ace:	e018      	b.n	8008b02 <HAL_DMA_DeInit+0x646>
 8008ad0:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8008ad4:	e015      	b.n	8008b02 <HAL_DMA_DeInit+0x646>
 8008ad6:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8008ada:	e012      	b.n	8008b02 <HAL_DMA_DeInit+0x646>
 8008adc:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8008ae0:	e00f      	b.n	8008b02 <HAL_DMA_DeInit+0x646>
 8008ae2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8008ae6:	e00c      	b.n	8008b02 <HAL_DMA_DeInit+0x646>
 8008ae8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8008aec:	e009      	b.n	8008b02 <HAL_DMA_DeInit+0x646>
 8008aee:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8008af2:	e006      	b.n	8008b02 <HAL_DMA_DeInit+0x646>
 8008af4:	2320      	movs	r3, #32
 8008af6:	e004      	b.n	8008b02 <HAL_DMA_DeInit+0x646>
 8008af8:	2320      	movs	r3, #32
 8008afa:	e002      	b.n	8008b02 <HAL_DMA_DeInit+0x646>
 8008afc:	2320      	movs	r3, #32
 8008afe:	e000      	b.n	8008b02 <HAL_DMA_DeInit+0x646>
 8008b00:	2320      	movs	r3, #32
 8008b02:	6093      	str	r3, [r2, #8]
 8008b04:	e0ff      	b.n	8008d06 <HAL_DMA_DeInit+0x84a>
 8008b06:	687b      	ldr	r3, [r7, #4]
 8008b08:	681b      	ldr	r3, [r3, #0]
 8008b0a:	461a      	mov	r2, r3
 8008b0c:	4b73      	ldr	r3, [pc, #460]	; (8008cdc <HAL_DMA_DeInit+0x820>)
 8008b0e:	429a      	cmp	r2, r3
 8008b10:	d96c      	bls.n	8008bec <HAL_DMA_DeInit+0x730>
 8008b12:	4a73      	ldr	r2, [pc, #460]	; (8008ce0 <HAL_DMA_DeInit+0x824>)
 8008b14:	687b      	ldr	r3, [r7, #4]
 8008b16:	681b      	ldr	r3, [r3, #0]
 8008b18:	4619      	mov	r1, r3
 8008b1a:	4b64      	ldr	r3, [pc, #400]	; (8008cac <HAL_DMA_DeInit+0x7f0>)
 8008b1c:	4299      	cmp	r1, r3
 8008b1e:	d062      	beq.n	8008be6 <HAL_DMA_DeInit+0x72a>
 8008b20:	687b      	ldr	r3, [r7, #4]
 8008b22:	681b      	ldr	r3, [r3, #0]
 8008b24:	4619      	mov	r1, r3
 8008b26:	4b62      	ldr	r3, [pc, #392]	; (8008cb0 <HAL_DMA_DeInit+0x7f4>)
 8008b28:	4299      	cmp	r1, r3
 8008b2a:	d05a      	beq.n	8008be2 <HAL_DMA_DeInit+0x726>
 8008b2c:	687b      	ldr	r3, [r7, #4]
 8008b2e:	681b      	ldr	r3, [r3, #0]
 8008b30:	4619      	mov	r1, r3
 8008b32:	4b60      	ldr	r3, [pc, #384]	; (8008cb4 <HAL_DMA_DeInit+0x7f8>)
 8008b34:	4299      	cmp	r1, r3
 8008b36:	d052      	beq.n	8008bde <HAL_DMA_DeInit+0x722>
 8008b38:	687b      	ldr	r3, [r7, #4]
 8008b3a:	681b      	ldr	r3, [r3, #0]
 8008b3c:	4619      	mov	r1, r3
 8008b3e:	4b5e      	ldr	r3, [pc, #376]	; (8008cb8 <HAL_DMA_DeInit+0x7fc>)
 8008b40:	4299      	cmp	r1, r3
 8008b42:	d04a      	beq.n	8008bda <HAL_DMA_DeInit+0x71e>
 8008b44:	687b      	ldr	r3, [r7, #4]
 8008b46:	681b      	ldr	r3, [r3, #0]
 8008b48:	4619      	mov	r1, r3
 8008b4a:	4b5c      	ldr	r3, [pc, #368]	; (8008cbc <HAL_DMA_DeInit+0x800>)
 8008b4c:	4299      	cmp	r1, r3
 8008b4e:	d041      	beq.n	8008bd4 <HAL_DMA_DeInit+0x718>
 8008b50:	687b      	ldr	r3, [r7, #4]
 8008b52:	681b      	ldr	r3, [r3, #0]
 8008b54:	4619      	mov	r1, r3
 8008b56:	4b5a      	ldr	r3, [pc, #360]	; (8008cc0 <HAL_DMA_DeInit+0x804>)
 8008b58:	4299      	cmp	r1, r3
 8008b5a:	d038      	beq.n	8008bce <HAL_DMA_DeInit+0x712>
 8008b5c:	687b      	ldr	r3, [r7, #4]
 8008b5e:	681b      	ldr	r3, [r3, #0]
 8008b60:	4619      	mov	r1, r3
 8008b62:	4b58      	ldr	r3, [pc, #352]	; (8008cc4 <HAL_DMA_DeInit+0x808>)
 8008b64:	4299      	cmp	r1, r3
 8008b66:	d02f      	beq.n	8008bc8 <HAL_DMA_DeInit+0x70c>
 8008b68:	687b      	ldr	r3, [r7, #4]
 8008b6a:	681b      	ldr	r3, [r3, #0]
 8008b6c:	4619      	mov	r1, r3
 8008b6e:	4b56      	ldr	r3, [pc, #344]	; (8008cc8 <HAL_DMA_DeInit+0x80c>)
 8008b70:	4299      	cmp	r1, r3
 8008b72:	d026      	beq.n	8008bc2 <HAL_DMA_DeInit+0x706>
 8008b74:	687b      	ldr	r3, [r7, #4]
 8008b76:	681b      	ldr	r3, [r3, #0]
 8008b78:	4619      	mov	r1, r3
 8008b7a:	4b54      	ldr	r3, [pc, #336]	; (8008ccc <HAL_DMA_DeInit+0x810>)
 8008b7c:	4299      	cmp	r1, r3
 8008b7e:	d01d      	beq.n	8008bbc <HAL_DMA_DeInit+0x700>
 8008b80:	687b      	ldr	r3, [r7, #4]
 8008b82:	681b      	ldr	r3, [r3, #0]
 8008b84:	4619      	mov	r1, r3
 8008b86:	4b52      	ldr	r3, [pc, #328]	; (8008cd0 <HAL_DMA_DeInit+0x814>)
 8008b88:	4299      	cmp	r1, r3
 8008b8a:	d014      	beq.n	8008bb6 <HAL_DMA_DeInit+0x6fa>
 8008b8c:	687b      	ldr	r3, [r7, #4]
 8008b8e:	681b      	ldr	r3, [r3, #0]
 8008b90:	4619      	mov	r1, r3
 8008b92:	4b50      	ldr	r3, [pc, #320]	; (8008cd4 <HAL_DMA_DeInit+0x818>)
 8008b94:	4299      	cmp	r1, r3
 8008b96:	d00b      	beq.n	8008bb0 <HAL_DMA_DeInit+0x6f4>
 8008b98:	687b      	ldr	r3, [r7, #4]
 8008b9a:	681b      	ldr	r3, [r3, #0]
 8008b9c:	4619      	mov	r1, r3
 8008b9e:	4b4e      	ldr	r3, [pc, #312]	; (8008cd8 <HAL_DMA_DeInit+0x81c>)
 8008ba0:	4299      	cmp	r1, r3
 8008ba2:	d102      	bne.n	8008baa <HAL_DMA_DeInit+0x6ee>
 8008ba4:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8008ba8:	e01e      	b.n	8008be8 <HAL_DMA_DeInit+0x72c>
 8008baa:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8008bae:	e01b      	b.n	8008be8 <HAL_DMA_DeInit+0x72c>
 8008bb0:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8008bb4:	e018      	b.n	8008be8 <HAL_DMA_DeInit+0x72c>
 8008bb6:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8008bba:	e015      	b.n	8008be8 <HAL_DMA_DeInit+0x72c>
 8008bbc:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8008bc0:	e012      	b.n	8008be8 <HAL_DMA_DeInit+0x72c>
 8008bc2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8008bc6:	e00f      	b.n	8008be8 <HAL_DMA_DeInit+0x72c>
 8008bc8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8008bcc:	e00c      	b.n	8008be8 <HAL_DMA_DeInit+0x72c>
 8008bce:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8008bd2:	e009      	b.n	8008be8 <HAL_DMA_DeInit+0x72c>
 8008bd4:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8008bd8:	e006      	b.n	8008be8 <HAL_DMA_DeInit+0x72c>
 8008bda:	2320      	movs	r3, #32
 8008bdc:	e004      	b.n	8008be8 <HAL_DMA_DeInit+0x72c>
 8008bde:	2320      	movs	r3, #32
 8008be0:	e002      	b.n	8008be8 <HAL_DMA_DeInit+0x72c>
 8008be2:	2320      	movs	r3, #32
 8008be4:	e000      	b.n	8008be8 <HAL_DMA_DeInit+0x72c>
 8008be6:	2320      	movs	r3, #32
 8008be8:	60d3      	str	r3, [r2, #12]
 8008bea:	e08c      	b.n	8008d06 <HAL_DMA_DeInit+0x84a>
 8008bec:	4a3c      	ldr	r2, [pc, #240]	; (8008ce0 <HAL_DMA_DeInit+0x824>)
 8008bee:	687b      	ldr	r3, [r7, #4]
 8008bf0:	681b      	ldr	r3, [r3, #0]
 8008bf2:	4619      	mov	r1, r3
 8008bf4:	4b2d      	ldr	r3, [pc, #180]	; (8008cac <HAL_DMA_DeInit+0x7f0>)
 8008bf6:	4299      	cmp	r1, r3
 8008bf8:	f000 8083 	beq.w	8008d02 <HAL_DMA_DeInit+0x846>
 8008bfc:	687b      	ldr	r3, [r7, #4]
 8008bfe:	681b      	ldr	r3, [r3, #0]
 8008c00:	4619      	mov	r1, r3
 8008c02:	4b2b      	ldr	r3, [pc, #172]	; (8008cb0 <HAL_DMA_DeInit+0x7f4>)
 8008c04:	4299      	cmp	r1, r3
 8008c06:	d07a      	beq.n	8008cfe <HAL_DMA_DeInit+0x842>
 8008c08:	687b      	ldr	r3, [r7, #4]
 8008c0a:	681b      	ldr	r3, [r3, #0]
 8008c0c:	4619      	mov	r1, r3
 8008c0e:	4b29      	ldr	r3, [pc, #164]	; (8008cb4 <HAL_DMA_DeInit+0x7f8>)
 8008c10:	4299      	cmp	r1, r3
 8008c12:	d072      	beq.n	8008cfa <HAL_DMA_DeInit+0x83e>
 8008c14:	687b      	ldr	r3, [r7, #4]
 8008c16:	681b      	ldr	r3, [r3, #0]
 8008c18:	4619      	mov	r1, r3
 8008c1a:	4b27      	ldr	r3, [pc, #156]	; (8008cb8 <HAL_DMA_DeInit+0x7fc>)
 8008c1c:	4299      	cmp	r1, r3
 8008c1e:	d06a      	beq.n	8008cf6 <HAL_DMA_DeInit+0x83a>
 8008c20:	687b      	ldr	r3, [r7, #4]
 8008c22:	681b      	ldr	r3, [r3, #0]
 8008c24:	4619      	mov	r1, r3
 8008c26:	4b25      	ldr	r3, [pc, #148]	; (8008cbc <HAL_DMA_DeInit+0x800>)
 8008c28:	4299      	cmp	r1, r3
 8008c2a:	d061      	beq.n	8008cf0 <HAL_DMA_DeInit+0x834>
 8008c2c:	687b      	ldr	r3, [r7, #4]
 8008c2e:	681b      	ldr	r3, [r3, #0]
 8008c30:	4619      	mov	r1, r3
 8008c32:	4b23      	ldr	r3, [pc, #140]	; (8008cc0 <HAL_DMA_DeInit+0x804>)
 8008c34:	4299      	cmp	r1, r3
 8008c36:	d058      	beq.n	8008cea <HAL_DMA_DeInit+0x82e>
 8008c38:	687b      	ldr	r3, [r7, #4]
 8008c3a:	681b      	ldr	r3, [r3, #0]
 8008c3c:	4619      	mov	r1, r3
 8008c3e:	4b21      	ldr	r3, [pc, #132]	; (8008cc4 <HAL_DMA_DeInit+0x808>)
 8008c40:	4299      	cmp	r1, r3
 8008c42:	d04f      	beq.n	8008ce4 <HAL_DMA_DeInit+0x828>
 8008c44:	687b      	ldr	r3, [r7, #4]
 8008c46:	681b      	ldr	r3, [r3, #0]
 8008c48:	4619      	mov	r1, r3
 8008c4a:	4b1f      	ldr	r3, [pc, #124]	; (8008cc8 <HAL_DMA_DeInit+0x80c>)
 8008c4c:	4299      	cmp	r1, r3
 8008c4e:	d026      	beq.n	8008c9e <HAL_DMA_DeInit+0x7e2>
 8008c50:	687b      	ldr	r3, [r7, #4]
 8008c52:	681b      	ldr	r3, [r3, #0]
 8008c54:	4619      	mov	r1, r3
 8008c56:	4b1d      	ldr	r3, [pc, #116]	; (8008ccc <HAL_DMA_DeInit+0x810>)
 8008c58:	4299      	cmp	r1, r3
 8008c5a:	d01d      	beq.n	8008c98 <HAL_DMA_DeInit+0x7dc>
 8008c5c:	687b      	ldr	r3, [r7, #4]
 8008c5e:	681b      	ldr	r3, [r3, #0]
 8008c60:	4619      	mov	r1, r3
 8008c62:	4b1b      	ldr	r3, [pc, #108]	; (8008cd0 <HAL_DMA_DeInit+0x814>)
 8008c64:	4299      	cmp	r1, r3
 8008c66:	d014      	beq.n	8008c92 <HAL_DMA_DeInit+0x7d6>
 8008c68:	687b      	ldr	r3, [r7, #4]
 8008c6a:	681b      	ldr	r3, [r3, #0]
 8008c6c:	4619      	mov	r1, r3
 8008c6e:	4b19      	ldr	r3, [pc, #100]	; (8008cd4 <HAL_DMA_DeInit+0x818>)
 8008c70:	4299      	cmp	r1, r3
 8008c72:	d00b      	beq.n	8008c8c <HAL_DMA_DeInit+0x7d0>
 8008c74:	687b      	ldr	r3, [r7, #4]
 8008c76:	681b      	ldr	r3, [r3, #0]
 8008c78:	4619      	mov	r1, r3
 8008c7a:	4b17      	ldr	r3, [pc, #92]	; (8008cd8 <HAL_DMA_DeInit+0x81c>)
 8008c7c:	4299      	cmp	r1, r3
 8008c7e:	d102      	bne.n	8008c86 <HAL_DMA_DeInit+0x7ca>
 8008c80:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8008c84:	e03e      	b.n	8008d04 <HAL_DMA_DeInit+0x848>
 8008c86:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8008c8a:	e03b      	b.n	8008d04 <HAL_DMA_DeInit+0x848>
 8008c8c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8008c90:	e038      	b.n	8008d04 <HAL_DMA_DeInit+0x848>
 8008c92:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8008c96:	e035      	b.n	8008d04 <HAL_DMA_DeInit+0x848>
 8008c98:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8008c9c:	e032      	b.n	8008d04 <HAL_DMA_DeInit+0x848>
 8008c9e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8008ca2:	e02f      	b.n	8008d04 <HAL_DMA_DeInit+0x848>
 8008ca4:	400260b8 	.word	0x400260b8
 8008ca8:	40026400 	.word	0x40026400
 8008cac:	40026010 	.word	0x40026010
 8008cb0:	40026410 	.word	0x40026410
 8008cb4:	40026070 	.word	0x40026070
 8008cb8:	40026470 	.word	0x40026470
 8008cbc:	40026028 	.word	0x40026028
 8008cc0:	40026428 	.word	0x40026428
 8008cc4:	40026088 	.word	0x40026088
 8008cc8:	40026488 	.word	0x40026488
 8008ccc:	40026040 	.word	0x40026040
 8008cd0:	40026440 	.word	0x40026440
 8008cd4:	400260a0 	.word	0x400260a0
 8008cd8:	400264a0 	.word	0x400264a0
 8008cdc:	40026058 	.word	0x40026058
 8008ce0:	40026000 	.word	0x40026000
 8008ce4:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8008ce8:	e00c      	b.n	8008d04 <HAL_DMA_DeInit+0x848>
 8008cea:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8008cee:	e009      	b.n	8008d04 <HAL_DMA_DeInit+0x848>
 8008cf0:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8008cf4:	e006      	b.n	8008d04 <HAL_DMA_DeInit+0x848>
 8008cf6:	2320      	movs	r3, #32
 8008cf8:	e004      	b.n	8008d04 <HAL_DMA_DeInit+0x848>
 8008cfa:	2320      	movs	r3, #32
 8008cfc:	e002      	b.n	8008d04 <HAL_DMA_DeInit+0x848>
 8008cfe:	2320      	movs	r3, #32
 8008d00:	e000      	b.n	8008d04 <HAL_DMA_DeInit+0x848>
 8008d02:	2320      	movs	r3, #32
 8008d04:	6093      	str	r3, [r2, #8]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8008d06:	687b      	ldr	r3, [r7, #4]
 8008d08:	681b      	ldr	r3, [r3, #0]
 8008d0a:	461a      	mov	r2, r3
 8008d0c:	4b9f      	ldr	r3, [pc, #636]	; (8008f8c <HAL_DMA_DeInit+0xad0>)
 8008d0e:	429a      	cmp	r2, r3
 8008d10:	d96c      	bls.n	8008dec <HAL_DMA_DeInit+0x930>
 8008d12:	4a9f      	ldr	r2, [pc, #636]	; (8008f90 <HAL_DMA_DeInit+0xad4>)
 8008d14:	687b      	ldr	r3, [r7, #4]
 8008d16:	681b      	ldr	r3, [r3, #0]
 8008d18:	4619      	mov	r1, r3
 8008d1a:	4b9e      	ldr	r3, [pc, #632]	; (8008f94 <HAL_DMA_DeInit+0xad8>)
 8008d1c:	4299      	cmp	r1, r3
 8008d1e:	d062      	beq.n	8008de6 <HAL_DMA_DeInit+0x92a>
 8008d20:	687b      	ldr	r3, [r7, #4]
 8008d22:	681b      	ldr	r3, [r3, #0]
 8008d24:	4619      	mov	r1, r3
 8008d26:	4b9c      	ldr	r3, [pc, #624]	; (8008f98 <HAL_DMA_DeInit+0xadc>)
 8008d28:	4299      	cmp	r1, r3
 8008d2a:	d05a      	beq.n	8008de2 <HAL_DMA_DeInit+0x926>
 8008d2c:	687b      	ldr	r3, [r7, #4]
 8008d2e:	681b      	ldr	r3, [r3, #0]
 8008d30:	4619      	mov	r1, r3
 8008d32:	4b9a      	ldr	r3, [pc, #616]	; (8008f9c <HAL_DMA_DeInit+0xae0>)
 8008d34:	4299      	cmp	r1, r3
 8008d36:	d052      	beq.n	8008dde <HAL_DMA_DeInit+0x922>
 8008d38:	687b      	ldr	r3, [r7, #4]
 8008d3a:	681b      	ldr	r3, [r3, #0]
 8008d3c:	4619      	mov	r1, r3
 8008d3e:	4b98      	ldr	r3, [pc, #608]	; (8008fa0 <HAL_DMA_DeInit+0xae4>)
 8008d40:	4299      	cmp	r1, r3
 8008d42:	d04a      	beq.n	8008dda <HAL_DMA_DeInit+0x91e>
 8008d44:	687b      	ldr	r3, [r7, #4]
 8008d46:	681b      	ldr	r3, [r3, #0]
 8008d48:	4619      	mov	r1, r3
 8008d4a:	4b96      	ldr	r3, [pc, #600]	; (8008fa4 <HAL_DMA_DeInit+0xae8>)
 8008d4c:	4299      	cmp	r1, r3
 8008d4e:	d041      	beq.n	8008dd4 <HAL_DMA_DeInit+0x918>
 8008d50:	687b      	ldr	r3, [r7, #4]
 8008d52:	681b      	ldr	r3, [r3, #0]
 8008d54:	4619      	mov	r1, r3
 8008d56:	4b94      	ldr	r3, [pc, #592]	; (8008fa8 <HAL_DMA_DeInit+0xaec>)
 8008d58:	4299      	cmp	r1, r3
 8008d5a:	d038      	beq.n	8008dce <HAL_DMA_DeInit+0x912>
 8008d5c:	687b      	ldr	r3, [r7, #4]
 8008d5e:	681b      	ldr	r3, [r3, #0]
 8008d60:	4619      	mov	r1, r3
 8008d62:	4b92      	ldr	r3, [pc, #584]	; (8008fac <HAL_DMA_DeInit+0xaf0>)
 8008d64:	4299      	cmp	r1, r3
 8008d66:	d02f      	beq.n	8008dc8 <HAL_DMA_DeInit+0x90c>
 8008d68:	687b      	ldr	r3, [r7, #4]
 8008d6a:	681b      	ldr	r3, [r3, #0]
 8008d6c:	4619      	mov	r1, r3
 8008d6e:	4b90      	ldr	r3, [pc, #576]	; (8008fb0 <HAL_DMA_DeInit+0xaf4>)
 8008d70:	4299      	cmp	r1, r3
 8008d72:	d026      	beq.n	8008dc2 <HAL_DMA_DeInit+0x906>
 8008d74:	687b      	ldr	r3, [r7, #4]
 8008d76:	681b      	ldr	r3, [r3, #0]
 8008d78:	4619      	mov	r1, r3
 8008d7a:	4b8e      	ldr	r3, [pc, #568]	; (8008fb4 <HAL_DMA_DeInit+0xaf8>)
 8008d7c:	4299      	cmp	r1, r3
 8008d7e:	d01d      	beq.n	8008dbc <HAL_DMA_DeInit+0x900>
 8008d80:	687b      	ldr	r3, [r7, #4]
 8008d82:	681b      	ldr	r3, [r3, #0]
 8008d84:	4619      	mov	r1, r3
 8008d86:	4b8c      	ldr	r3, [pc, #560]	; (8008fb8 <HAL_DMA_DeInit+0xafc>)
 8008d88:	4299      	cmp	r1, r3
 8008d8a:	d014      	beq.n	8008db6 <HAL_DMA_DeInit+0x8fa>
 8008d8c:	687b      	ldr	r3, [r7, #4]
 8008d8e:	681b      	ldr	r3, [r3, #0]
 8008d90:	4619      	mov	r1, r3
 8008d92:	4b8a      	ldr	r3, [pc, #552]	; (8008fbc <HAL_DMA_DeInit+0xb00>)
 8008d94:	4299      	cmp	r1, r3
 8008d96:	d00b      	beq.n	8008db0 <HAL_DMA_DeInit+0x8f4>
 8008d98:	687b      	ldr	r3, [r7, #4]
 8008d9a:	681b      	ldr	r3, [r3, #0]
 8008d9c:	4619      	mov	r1, r3
 8008d9e:	4b88      	ldr	r3, [pc, #544]	; (8008fc0 <HAL_DMA_DeInit+0xb04>)
 8008da0:	4299      	cmp	r1, r3
 8008da2:	d102      	bne.n	8008daa <HAL_DMA_DeInit+0x8ee>
 8008da4:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8008da8:	e01e      	b.n	8008de8 <HAL_DMA_DeInit+0x92c>
 8008daa:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8008dae:	e01b      	b.n	8008de8 <HAL_DMA_DeInit+0x92c>
 8008db0:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8008db4:	e018      	b.n	8008de8 <HAL_DMA_DeInit+0x92c>
 8008db6:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8008dba:	e015      	b.n	8008de8 <HAL_DMA_DeInit+0x92c>
 8008dbc:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8008dc0:	e012      	b.n	8008de8 <HAL_DMA_DeInit+0x92c>
 8008dc2:	f44f 7300 	mov.w	r3, #512	; 0x200
 8008dc6:	e00f      	b.n	8008de8 <HAL_DMA_DeInit+0x92c>
 8008dc8:	f44f 7300 	mov.w	r3, #512	; 0x200
 8008dcc:	e00c      	b.n	8008de8 <HAL_DMA_DeInit+0x92c>
 8008dce:	f44f 7300 	mov.w	r3, #512	; 0x200
 8008dd2:	e009      	b.n	8008de8 <HAL_DMA_DeInit+0x92c>
 8008dd4:	f44f 7300 	mov.w	r3, #512	; 0x200
 8008dd8:	e006      	b.n	8008de8 <HAL_DMA_DeInit+0x92c>
 8008dda:	2308      	movs	r3, #8
 8008ddc:	e004      	b.n	8008de8 <HAL_DMA_DeInit+0x92c>
 8008dde:	2308      	movs	r3, #8
 8008de0:	e002      	b.n	8008de8 <HAL_DMA_DeInit+0x92c>
 8008de2:	2308      	movs	r3, #8
 8008de4:	e000      	b.n	8008de8 <HAL_DMA_DeInit+0x92c>
 8008de6:	2308      	movs	r3, #8
 8008de8:	60d3      	str	r3, [r2, #12]
 8008dea:	e175      	b.n	80090d8 <HAL_DMA_DeInit+0xc1c>
 8008dec:	687b      	ldr	r3, [r7, #4]
 8008dee:	681b      	ldr	r3, [r3, #0]
 8008df0:	461a      	mov	r2, r3
 8008df2:	4b74      	ldr	r3, [pc, #464]	; (8008fc4 <HAL_DMA_DeInit+0xb08>)
 8008df4:	429a      	cmp	r2, r3
 8008df6:	d96c      	bls.n	8008ed2 <HAL_DMA_DeInit+0xa16>
 8008df8:	4a65      	ldr	r2, [pc, #404]	; (8008f90 <HAL_DMA_DeInit+0xad4>)
 8008dfa:	687b      	ldr	r3, [r7, #4]
 8008dfc:	681b      	ldr	r3, [r3, #0]
 8008dfe:	4619      	mov	r1, r3
 8008e00:	4b64      	ldr	r3, [pc, #400]	; (8008f94 <HAL_DMA_DeInit+0xad8>)
 8008e02:	4299      	cmp	r1, r3
 8008e04:	d062      	beq.n	8008ecc <HAL_DMA_DeInit+0xa10>
 8008e06:	687b      	ldr	r3, [r7, #4]
 8008e08:	681b      	ldr	r3, [r3, #0]
 8008e0a:	4619      	mov	r1, r3
 8008e0c:	4b62      	ldr	r3, [pc, #392]	; (8008f98 <HAL_DMA_DeInit+0xadc>)
 8008e0e:	4299      	cmp	r1, r3
 8008e10:	d05a      	beq.n	8008ec8 <HAL_DMA_DeInit+0xa0c>
 8008e12:	687b      	ldr	r3, [r7, #4]
 8008e14:	681b      	ldr	r3, [r3, #0]
 8008e16:	4619      	mov	r1, r3
 8008e18:	4b60      	ldr	r3, [pc, #384]	; (8008f9c <HAL_DMA_DeInit+0xae0>)
 8008e1a:	4299      	cmp	r1, r3
 8008e1c:	d052      	beq.n	8008ec4 <HAL_DMA_DeInit+0xa08>
 8008e1e:	687b      	ldr	r3, [r7, #4]
 8008e20:	681b      	ldr	r3, [r3, #0]
 8008e22:	4619      	mov	r1, r3
 8008e24:	4b5e      	ldr	r3, [pc, #376]	; (8008fa0 <HAL_DMA_DeInit+0xae4>)
 8008e26:	4299      	cmp	r1, r3
 8008e28:	d04a      	beq.n	8008ec0 <HAL_DMA_DeInit+0xa04>
 8008e2a:	687b      	ldr	r3, [r7, #4]
 8008e2c:	681b      	ldr	r3, [r3, #0]
 8008e2e:	4619      	mov	r1, r3
 8008e30:	4b5c      	ldr	r3, [pc, #368]	; (8008fa4 <HAL_DMA_DeInit+0xae8>)
 8008e32:	4299      	cmp	r1, r3
 8008e34:	d041      	beq.n	8008eba <HAL_DMA_DeInit+0x9fe>
 8008e36:	687b      	ldr	r3, [r7, #4]
 8008e38:	681b      	ldr	r3, [r3, #0]
 8008e3a:	4619      	mov	r1, r3
 8008e3c:	4b5a      	ldr	r3, [pc, #360]	; (8008fa8 <HAL_DMA_DeInit+0xaec>)
 8008e3e:	4299      	cmp	r1, r3
 8008e40:	d038      	beq.n	8008eb4 <HAL_DMA_DeInit+0x9f8>
 8008e42:	687b      	ldr	r3, [r7, #4]
 8008e44:	681b      	ldr	r3, [r3, #0]
 8008e46:	4619      	mov	r1, r3
 8008e48:	4b58      	ldr	r3, [pc, #352]	; (8008fac <HAL_DMA_DeInit+0xaf0>)
 8008e4a:	4299      	cmp	r1, r3
 8008e4c:	d02f      	beq.n	8008eae <HAL_DMA_DeInit+0x9f2>
 8008e4e:	687b      	ldr	r3, [r7, #4]
 8008e50:	681b      	ldr	r3, [r3, #0]
 8008e52:	4619      	mov	r1, r3
 8008e54:	4b56      	ldr	r3, [pc, #344]	; (8008fb0 <HAL_DMA_DeInit+0xaf4>)
 8008e56:	4299      	cmp	r1, r3
 8008e58:	d026      	beq.n	8008ea8 <HAL_DMA_DeInit+0x9ec>
 8008e5a:	687b      	ldr	r3, [r7, #4]
 8008e5c:	681b      	ldr	r3, [r3, #0]
 8008e5e:	4619      	mov	r1, r3
 8008e60:	4b54      	ldr	r3, [pc, #336]	; (8008fb4 <HAL_DMA_DeInit+0xaf8>)
 8008e62:	4299      	cmp	r1, r3
 8008e64:	d01d      	beq.n	8008ea2 <HAL_DMA_DeInit+0x9e6>
 8008e66:	687b      	ldr	r3, [r7, #4]
 8008e68:	681b      	ldr	r3, [r3, #0]
 8008e6a:	4619      	mov	r1, r3
 8008e6c:	4b52      	ldr	r3, [pc, #328]	; (8008fb8 <HAL_DMA_DeInit+0xafc>)
 8008e6e:	4299      	cmp	r1, r3
 8008e70:	d014      	beq.n	8008e9c <HAL_DMA_DeInit+0x9e0>
 8008e72:	687b      	ldr	r3, [r7, #4]
 8008e74:	681b      	ldr	r3, [r3, #0]
 8008e76:	4619      	mov	r1, r3
 8008e78:	4b50      	ldr	r3, [pc, #320]	; (8008fbc <HAL_DMA_DeInit+0xb00>)
 8008e7a:	4299      	cmp	r1, r3
 8008e7c:	d00b      	beq.n	8008e96 <HAL_DMA_DeInit+0x9da>
 8008e7e:	687b      	ldr	r3, [r7, #4]
 8008e80:	681b      	ldr	r3, [r3, #0]
 8008e82:	4619      	mov	r1, r3
 8008e84:	4b4e      	ldr	r3, [pc, #312]	; (8008fc0 <HAL_DMA_DeInit+0xb04>)
 8008e86:	4299      	cmp	r1, r3
 8008e88:	d102      	bne.n	8008e90 <HAL_DMA_DeInit+0x9d4>
 8008e8a:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8008e8e:	e01e      	b.n	8008ece <HAL_DMA_DeInit+0xa12>
 8008e90:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8008e94:	e01b      	b.n	8008ece <HAL_DMA_DeInit+0xa12>
 8008e96:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8008e9a:	e018      	b.n	8008ece <HAL_DMA_DeInit+0xa12>
 8008e9c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8008ea0:	e015      	b.n	8008ece <HAL_DMA_DeInit+0xa12>
 8008ea2:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8008ea6:	e012      	b.n	8008ece <HAL_DMA_DeInit+0xa12>
 8008ea8:	f44f 7300 	mov.w	r3, #512	; 0x200
 8008eac:	e00f      	b.n	8008ece <HAL_DMA_DeInit+0xa12>
 8008eae:	f44f 7300 	mov.w	r3, #512	; 0x200
 8008eb2:	e00c      	b.n	8008ece <HAL_DMA_DeInit+0xa12>
 8008eb4:	f44f 7300 	mov.w	r3, #512	; 0x200
 8008eb8:	e009      	b.n	8008ece <HAL_DMA_DeInit+0xa12>
 8008eba:	f44f 7300 	mov.w	r3, #512	; 0x200
 8008ebe:	e006      	b.n	8008ece <HAL_DMA_DeInit+0xa12>
 8008ec0:	2308      	movs	r3, #8
 8008ec2:	e004      	b.n	8008ece <HAL_DMA_DeInit+0xa12>
 8008ec4:	2308      	movs	r3, #8
 8008ec6:	e002      	b.n	8008ece <HAL_DMA_DeInit+0xa12>
 8008ec8:	2308      	movs	r3, #8
 8008eca:	e000      	b.n	8008ece <HAL_DMA_DeInit+0xa12>
 8008ecc:	2308      	movs	r3, #8
 8008ece:	6093      	str	r3, [r2, #8]
 8008ed0:	e102      	b.n	80090d8 <HAL_DMA_DeInit+0xc1c>
 8008ed2:	687b      	ldr	r3, [r7, #4]
 8008ed4:	681b      	ldr	r3, [r3, #0]
 8008ed6:	461a      	mov	r2, r3
 8008ed8:	4b3b      	ldr	r3, [pc, #236]	; (8008fc8 <HAL_DMA_DeInit+0xb0c>)
 8008eda:	429a      	cmp	r2, r3
 8008edc:	f240 8090 	bls.w	8009000 <HAL_DMA_DeInit+0xb44>
 8008ee0:	4a3a      	ldr	r2, [pc, #232]	; (8008fcc <HAL_DMA_DeInit+0xb10>)
 8008ee2:	687b      	ldr	r3, [r7, #4]
 8008ee4:	681b      	ldr	r3, [r3, #0]
 8008ee6:	4619      	mov	r1, r3
 8008ee8:	4b2a      	ldr	r3, [pc, #168]	; (8008f94 <HAL_DMA_DeInit+0xad8>)
 8008eea:	4299      	cmp	r1, r3
 8008eec:	f000 8085 	beq.w	8008ffa <HAL_DMA_DeInit+0xb3e>
 8008ef0:	687b      	ldr	r3, [r7, #4]
 8008ef2:	681b      	ldr	r3, [r3, #0]
 8008ef4:	4619      	mov	r1, r3
 8008ef6:	4b28      	ldr	r3, [pc, #160]	; (8008f98 <HAL_DMA_DeInit+0xadc>)
 8008ef8:	4299      	cmp	r1, r3
 8008efa:	d07c      	beq.n	8008ff6 <HAL_DMA_DeInit+0xb3a>
 8008efc:	687b      	ldr	r3, [r7, #4]
 8008efe:	681b      	ldr	r3, [r3, #0]
 8008f00:	4619      	mov	r1, r3
 8008f02:	4b26      	ldr	r3, [pc, #152]	; (8008f9c <HAL_DMA_DeInit+0xae0>)
 8008f04:	4299      	cmp	r1, r3
 8008f06:	d074      	beq.n	8008ff2 <HAL_DMA_DeInit+0xb36>
 8008f08:	687b      	ldr	r3, [r7, #4]
 8008f0a:	681b      	ldr	r3, [r3, #0]
 8008f0c:	4619      	mov	r1, r3
 8008f0e:	4b24      	ldr	r3, [pc, #144]	; (8008fa0 <HAL_DMA_DeInit+0xae4>)
 8008f10:	4299      	cmp	r1, r3
 8008f12:	d06c      	beq.n	8008fee <HAL_DMA_DeInit+0xb32>
 8008f14:	687b      	ldr	r3, [r7, #4]
 8008f16:	681b      	ldr	r3, [r3, #0]
 8008f18:	4619      	mov	r1, r3
 8008f1a:	4b22      	ldr	r3, [pc, #136]	; (8008fa4 <HAL_DMA_DeInit+0xae8>)
 8008f1c:	4299      	cmp	r1, r3
 8008f1e:	d063      	beq.n	8008fe8 <HAL_DMA_DeInit+0xb2c>
 8008f20:	687b      	ldr	r3, [r7, #4]
 8008f22:	681b      	ldr	r3, [r3, #0]
 8008f24:	4619      	mov	r1, r3
 8008f26:	4b20      	ldr	r3, [pc, #128]	; (8008fa8 <HAL_DMA_DeInit+0xaec>)
 8008f28:	4299      	cmp	r1, r3
 8008f2a:	d05a      	beq.n	8008fe2 <HAL_DMA_DeInit+0xb26>
 8008f2c:	687b      	ldr	r3, [r7, #4]
 8008f2e:	681b      	ldr	r3, [r3, #0]
 8008f30:	4619      	mov	r1, r3
 8008f32:	4b1e      	ldr	r3, [pc, #120]	; (8008fac <HAL_DMA_DeInit+0xaf0>)
 8008f34:	4299      	cmp	r1, r3
 8008f36:	d051      	beq.n	8008fdc <HAL_DMA_DeInit+0xb20>
 8008f38:	687b      	ldr	r3, [r7, #4]
 8008f3a:	681b      	ldr	r3, [r3, #0]
 8008f3c:	4619      	mov	r1, r3
 8008f3e:	4b1c      	ldr	r3, [pc, #112]	; (8008fb0 <HAL_DMA_DeInit+0xaf4>)
 8008f40:	4299      	cmp	r1, r3
 8008f42:	d048      	beq.n	8008fd6 <HAL_DMA_DeInit+0xb1a>
 8008f44:	687b      	ldr	r3, [r7, #4]
 8008f46:	681b      	ldr	r3, [r3, #0]
 8008f48:	4619      	mov	r1, r3
 8008f4a:	4b1a      	ldr	r3, [pc, #104]	; (8008fb4 <HAL_DMA_DeInit+0xaf8>)
 8008f4c:	4299      	cmp	r1, r3
 8008f4e:	d03f      	beq.n	8008fd0 <HAL_DMA_DeInit+0xb14>
 8008f50:	687b      	ldr	r3, [r7, #4]
 8008f52:	681b      	ldr	r3, [r3, #0]
 8008f54:	4619      	mov	r1, r3
 8008f56:	4b18      	ldr	r3, [pc, #96]	; (8008fb8 <HAL_DMA_DeInit+0xafc>)
 8008f58:	4299      	cmp	r1, r3
 8008f5a:	d014      	beq.n	8008f86 <HAL_DMA_DeInit+0xaca>
 8008f5c:	687b      	ldr	r3, [r7, #4]
 8008f5e:	681b      	ldr	r3, [r3, #0]
 8008f60:	4619      	mov	r1, r3
 8008f62:	4b16      	ldr	r3, [pc, #88]	; (8008fbc <HAL_DMA_DeInit+0xb00>)
 8008f64:	4299      	cmp	r1, r3
 8008f66:	d00b      	beq.n	8008f80 <HAL_DMA_DeInit+0xac4>
 8008f68:	687b      	ldr	r3, [r7, #4]
 8008f6a:	681b      	ldr	r3, [r3, #0]
 8008f6c:	4619      	mov	r1, r3
 8008f6e:	4b14      	ldr	r3, [pc, #80]	; (8008fc0 <HAL_DMA_DeInit+0xb04>)
 8008f70:	4299      	cmp	r1, r3
 8008f72:	d102      	bne.n	8008f7a <HAL_DMA_DeInit+0xabe>
 8008f74:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8008f78:	e040      	b.n	8008ffc <HAL_DMA_DeInit+0xb40>
 8008f7a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8008f7e:	e03d      	b.n	8008ffc <HAL_DMA_DeInit+0xb40>
 8008f80:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8008f84:	e03a      	b.n	8008ffc <HAL_DMA_DeInit+0xb40>
 8008f86:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8008f8a:	e037      	b.n	8008ffc <HAL_DMA_DeInit+0xb40>
 8008f8c:	40026458 	.word	0x40026458
 8008f90:	40026400 	.word	0x40026400
 8008f94:	40026010 	.word	0x40026010
 8008f98:	40026410 	.word	0x40026410
 8008f9c:	40026070 	.word	0x40026070
 8008fa0:	40026470 	.word	0x40026470
 8008fa4:	40026028 	.word	0x40026028
 8008fa8:	40026428 	.word	0x40026428
 8008fac:	40026088 	.word	0x40026088
 8008fb0:	40026488 	.word	0x40026488
 8008fb4:	40026040 	.word	0x40026040
 8008fb8:	40026440 	.word	0x40026440
 8008fbc:	400260a0 	.word	0x400260a0
 8008fc0:	400264a0 	.word	0x400264a0
 8008fc4:	400260b8 	.word	0x400260b8
 8008fc8:	40026058 	.word	0x40026058
 8008fcc:	40026000 	.word	0x40026000
 8008fd0:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8008fd4:	e012      	b.n	8008ffc <HAL_DMA_DeInit+0xb40>
 8008fd6:	f44f 7300 	mov.w	r3, #512	; 0x200
 8008fda:	e00f      	b.n	8008ffc <HAL_DMA_DeInit+0xb40>
 8008fdc:	f44f 7300 	mov.w	r3, #512	; 0x200
 8008fe0:	e00c      	b.n	8008ffc <HAL_DMA_DeInit+0xb40>
 8008fe2:	f44f 7300 	mov.w	r3, #512	; 0x200
 8008fe6:	e009      	b.n	8008ffc <HAL_DMA_DeInit+0xb40>
 8008fe8:	f44f 7300 	mov.w	r3, #512	; 0x200
 8008fec:	e006      	b.n	8008ffc <HAL_DMA_DeInit+0xb40>
 8008fee:	2308      	movs	r3, #8
 8008ff0:	e004      	b.n	8008ffc <HAL_DMA_DeInit+0xb40>
 8008ff2:	2308      	movs	r3, #8
 8008ff4:	e002      	b.n	8008ffc <HAL_DMA_DeInit+0xb40>
 8008ff6:	2308      	movs	r3, #8
 8008ff8:	e000      	b.n	8008ffc <HAL_DMA_DeInit+0xb40>
 8008ffa:	2308      	movs	r3, #8
 8008ffc:	60d3      	str	r3, [r2, #12]
 8008ffe:	e06b      	b.n	80090d8 <HAL_DMA_DeInit+0xc1c>
 8009000:	4a9e      	ldr	r2, [pc, #632]	; (800927c <HAL_DMA_DeInit+0xdc0>)
 8009002:	687b      	ldr	r3, [r7, #4]
 8009004:	681b      	ldr	r3, [r3, #0]
 8009006:	4619      	mov	r1, r3
 8009008:	4b9d      	ldr	r3, [pc, #628]	; (8009280 <HAL_DMA_DeInit+0xdc4>)
 800900a:	4299      	cmp	r1, r3
 800900c:	d062      	beq.n	80090d4 <HAL_DMA_DeInit+0xc18>
 800900e:	687b      	ldr	r3, [r7, #4]
 8009010:	681b      	ldr	r3, [r3, #0]
 8009012:	4619      	mov	r1, r3
 8009014:	4b9b      	ldr	r3, [pc, #620]	; (8009284 <HAL_DMA_DeInit+0xdc8>)
 8009016:	4299      	cmp	r1, r3
 8009018:	d05a      	beq.n	80090d0 <HAL_DMA_DeInit+0xc14>
 800901a:	687b      	ldr	r3, [r7, #4]
 800901c:	681b      	ldr	r3, [r3, #0]
 800901e:	4619      	mov	r1, r3
 8009020:	4b99      	ldr	r3, [pc, #612]	; (8009288 <HAL_DMA_DeInit+0xdcc>)
 8009022:	4299      	cmp	r1, r3
 8009024:	d052      	beq.n	80090cc <HAL_DMA_DeInit+0xc10>
 8009026:	687b      	ldr	r3, [r7, #4]
 8009028:	681b      	ldr	r3, [r3, #0]
 800902a:	4619      	mov	r1, r3
 800902c:	4b97      	ldr	r3, [pc, #604]	; (800928c <HAL_DMA_DeInit+0xdd0>)
 800902e:	4299      	cmp	r1, r3
 8009030:	d04a      	beq.n	80090c8 <HAL_DMA_DeInit+0xc0c>
 8009032:	687b      	ldr	r3, [r7, #4]
 8009034:	681b      	ldr	r3, [r3, #0]
 8009036:	4619      	mov	r1, r3
 8009038:	4b95      	ldr	r3, [pc, #596]	; (8009290 <HAL_DMA_DeInit+0xdd4>)
 800903a:	4299      	cmp	r1, r3
 800903c:	d041      	beq.n	80090c2 <HAL_DMA_DeInit+0xc06>
 800903e:	687b      	ldr	r3, [r7, #4]
 8009040:	681b      	ldr	r3, [r3, #0]
 8009042:	4619      	mov	r1, r3
 8009044:	4b93      	ldr	r3, [pc, #588]	; (8009294 <HAL_DMA_DeInit+0xdd8>)
 8009046:	4299      	cmp	r1, r3
 8009048:	d038      	beq.n	80090bc <HAL_DMA_DeInit+0xc00>
 800904a:	687b      	ldr	r3, [r7, #4]
 800904c:	681b      	ldr	r3, [r3, #0]
 800904e:	4619      	mov	r1, r3
 8009050:	4b91      	ldr	r3, [pc, #580]	; (8009298 <HAL_DMA_DeInit+0xddc>)
 8009052:	4299      	cmp	r1, r3
 8009054:	d02f      	beq.n	80090b6 <HAL_DMA_DeInit+0xbfa>
 8009056:	687b      	ldr	r3, [r7, #4]
 8009058:	681b      	ldr	r3, [r3, #0]
 800905a:	4619      	mov	r1, r3
 800905c:	4b8f      	ldr	r3, [pc, #572]	; (800929c <HAL_DMA_DeInit+0xde0>)
 800905e:	4299      	cmp	r1, r3
 8009060:	d026      	beq.n	80090b0 <HAL_DMA_DeInit+0xbf4>
 8009062:	687b      	ldr	r3, [r7, #4]
 8009064:	681b      	ldr	r3, [r3, #0]
 8009066:	4619      	mov	r1, r3
 8009068:	4b8d      	ldr	r3, [pc, #564]	; (80092a0 <HAL_DMA_DeInit+0xde4>)
 800906a:	4299      	cmp	r1, r3
 800906c:	d01d      	beq.n	80090aa <HAL_DMA_DeInit+0xbee>
 800906e:	687b      	ldr	r3, [r7, #4]
 8009070:	681b      	ldr	r3, [r3, #0]
 8009072:	4619      	mov	r1, r3
 8009074:	4b8b      	ldr	r3, [pc, #556]	; (80092a4 <HAL_DMA_DeInit+0xde8>)
 8009076:	4299      	cmp	r1, r3
 8009078:	d014      	beq.n	80090a4 <HAL_DMA_DeInit+0xbe8>
 800907a:	687b      	ldr	r3, [r7, #4]
 800907c:	681b      	ldr	r3, [r3, #0]
 800907e:	4619      	mov	r1, r3
 8009080:	4b89      	ldr	r3, [pc, #548]	; (80092a8 <HAL_DMA_DeInit+0xdec>)
 8009082:	4299      	cmp	r1, r3
 8009084:	d00b      	beq.n	800909e <HAL_DMA_DeInit+0xbe2>
 8009086:	687b      	ldr	r3, [r7, #4]
 8009088:	681b      	ldr	r3, [r3, #0]
 800908a:	4619      	mov	r1, r3
 800908c:	4b87      	ldr	r3, [pc, #540]	; (80092ac <HAL_DMA_DeInit+0xdf0>)
 800908e:	4299      	cmp	r1, r3
 8009090:	d102      	bne.n	8009098 <HAL_DMA_DeInit+0xbdc>
 8009092:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009096:	e01e      	b.n	80090d6 <HAL_DMA_DeInit+0xc1a>
 8009098:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800909c:	e01b      	b.n	80090d6 <HAL_DMA_DeInit+0xc1a>
 800909e:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80090a2:	e018      	b.n	80090d6 <HAL_DMA_DeInit+0xc1a>
 80090a4:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80090a8:	e015      	b.n	80090d6 <HAL_DMA_DeInit+0xc1a>
 80090aa:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80090ae:	e012      	b.n	80090d6 <HAL_DMA_DeInit+0xc1a>
 80090b0:	f44f 7300 	mov.w	r3, #512	; 0x200
 80090b4:	e00f      	b.n	80090d6 <HAL_DMA_DeInit+0xc1a>
 80090b6:	f44f 7300 	mov.w	r3, #512	; 0x200
 80090ba:	e00c      	b.n	80090d6 <HAL_DMA_DeInit+0xc1a>
 80090bc:	f44f 7300 	mov.w	r3, #512	; 0x200
 80090c0:	e009      	b.n	80090d6 <HAL_DMA_DeInit+0xc1a>
 80090c2:	f44f 7300 	mov.w	r3, #512	; 0x200
 80090c6:	e006      	b.n	80090d6 <HAL_DMA_DeInit+0xc1a>
 80090c8:	2308      	movs	r3, #8
 80090ca:	e004      	b.n	80090d6 <HAL_DMA_DeInit+0xc1a>
 80090cc:	2308      	movs	r3, #8
 80090ce:	e002      	b.n	80090d6 <HAL_DMA_DeInit+0xc1a>
 80090d0:	2308      	movs	r3, #8
 80090d2:	e000      	b.n	80090d6 <HAL_DMA_DeInit+0xc1a>
 80090d4:	2308      	movs	r3, #8
 80090d6:	6093      	str	r3, [r2, #8]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 80090d8:	687b      	ldr	r3, [r7, #4]
 80090da:	681b      	ldr	r3, [r3, #0]
 80090dc:	461a      	mov	r2, r3
 80090de:	4b74      	ldr	r3, [pc, #464]	; (80092b0 <HAL_DMA_DeInit+0xdf4>)
 80090e0:	429a      	cmp	r2, r3
 80090e2:	d968      	bls.n	80091b6 <HAL_DMA_DeInit+0xcfa>
 80090e4:	4a73      	ldr	r2, [pc, #460]	; (80092b4 <HAL_DMA_DeInit+0xdf8>)
 80090e6:	687b      	ldr	r3, [r7, #4]
 80090e8:	681b      	ldr	r3, [r3, #0]
 80090ea:	4619      	mov	r1, r3
 80090ec:	4b64      	ldr	r3, [pc, #400]	; (8009280 <HAL_DMA_DeInit+0xdc4>)
 80090ee:	4299      	cmp	r1, r3
 80090f0:	d05e      	beq.n	80091b0 <HAL_DMA_DeInit+0xcf4>
 80090f2:	687b      	ldr	r3, [r7, #4]
 80090f4:	681b      	ldr	r3, [r3, #0]
 80090f6:	4619      	mov	r1, r3
 80090f8:	4b62      	ldr	r3, [pc, #392]	; (8009284 <HAL_DMA_DeInit+0xdc8>)
 80090fa:	4299      	cmp	r1, r3
 80090fc:	d056      	beq.n	80091ac <HAL_DMA_DeInit+0xcf0>
 80090fe:	687b      	ldr	r3, [r7, #4]
 8009100:	681b      	ldr	r3, [r3, #0]
 8009102:	4619      	mov	r1, r3
 8009104:	4b60      	ldr	r3, [pc, #384]	; (8009288 <HAL_DMA_DeInit+0xdcc>)
 8009106:	4299      	cmp	r1, r3
 8009108:	d04e      	beq.n	80091a8 <HAL_DMA_DeInit+0xcec>
 800910a:	687b      	ldr	r3, [r7, #4]
 800910c:	681b      	ldr	r3, [r3, #0]
 800910e:	4619      	mov	r1, r3
 8009110:	4b5e      	ldr	r3, [pc, #376]	; (800928c <HAL_DMA_DeInit+0xdd0>)
 8009112:	4299      	cmp	r1, r3
 8009114:	d046      	beq.n	80091a4 <HAL_DMA_DeInit+0xce8>
 8009116:	687b      	ldr	r3, [r7, #4]
 8009118:	681b      	ldr	r3, [r3, #0]
 800911a:	4619      	mov	r1, r3
 800911c:	4b5c      	ldr	r3, [pc, #368]	; (8009290 <HAL_DMA_DeInit+0xdd4>)
 800911e:	4299      	cmp	r1, r3
 8009120:	d03e      	beq.n	80091a0 <HAL_DMA_DeInit+0xce4>
 8009122:	687b      	ldr	r3, [r7, #4]
 8009124:	681b      	ldr	r3, [r3, #0]
 8009126:	4619      	mov	r1, r3
 8009128:	4b5a      	ldr	r3, [pc, #360]	; (8009294 <HAL_DMA_DeInit+0xdd8>)
 800912a:	4299      	cmp	r1, r3
 800912c:	d036      	beq.n	800919c <HAL_DMA_DeInit+0xce0>
 800912e:	687b      	ldr	r3, [r7, #4]
 8009130:	681b      	ldr	r3, [r3, #0]
 8009132:	4619      	mov	r1, r3
 8009134:	4b58      	ldr	r3, [pc, #352]	; (8009298 <HAL_DMA_DeInit+0xddc>)
 8009136:	4299      	cmp	r1, r3
 8009138:	d02e      	beq.n	8009198 <HAL_DMA_DeInit+0xcdc>
 800913a:	687b      	ldr	r3, [r7, #4]
 800913c:	681b      	ldr	r3, [r3, #0]
 800913e:	4619      	mov	r1, r3
 8009140:	4b56      	ldr	r3, [pc, #344]	; (800929c <HAL_DMA_DeInit+0xde0>)
 8009142:	4299      	cmp	r1, r3
 8009144:	d026      	beq.n	8009194 <HAL_DMA_DeInit+0xcd8>
 8009146:	687b      	ldr	r3, [r7, #4]
 8009148:	681b      	ldr	r3, [r3, #0]
 800914a:	4619      	mov	r1, r3
 800914c:	4b54      	ldr	r3, [pc, #336]	; (80092a0 <HAL_DMA_DeInit+0xde4>)
 800914e:	4299      	cmp	r1, r3
 8009150:	d01d      	beq.n	800918e <HAL_DMA_DeInit+0xcd2>
 8009152:	687b      	ldr	r3, [r7, #4]
 8009154:	681b      	ldr	r3, [r3, #0]
 8009156:	4619      	mov	r1, r3
 8009158:	4b52      	ldr	r3, [pc, #328]	; (80092a4 <HAL_DMA_DeInit+0xde8>)
 800915a:	4299      	cmp	r1, r3
 800915c:	d014      	beq.n	8009188 <HAL_DMA_DeInit+0xccc>
 800915e:	687b      	ldr	r3, [r7, #4]
 8009160:	681b      	ldr	r3, [r3, #0]
 8009162:	4619      	mov	r1, r3
 8009164:	4b50      	ldr	r3, [pc, #320]	; (80092a8 <HAL_DMA_DeInit+0xdec>)
 8009166:	4299      	cmp	r1, r3
 8009168:	d00b      	beq.n	8009182 <HAL_DMA_DeInit+0xcc6>
 800916a:	687b      	ldr	r3, [r7, #4]
 800916c:	681b      	ldr	r3, [r3, #0]
 800916e:	4619      	mov	r1, r3
 8009170:	4b4e      	ldr	r3, [pc, #312]	; (80092ac <HAL_DMA_DeInit+0xdf0>)
 8009172:	4299      	cmp	r1, r3
 8009174:	d102      	bne.n	800917c <HAL_DMA_DeInit+0xcc0>
 8009176:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800917a:	e01a      	b.n	80091b2 <HAL_DMA_DeInit+0xcf6>
 800917c:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8009180:	e017      	b.n	80091b2 <HAL_DMA_DeInit+0xcf6>
 8009182:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009186:	e014      	b.n	80091b2 <HAL_DMA_DeInit+0xcf6>
 8009188:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800918c:	e011      	b.n	80091b2 <HAL_DMA_DeInit+0xcf6>
 800918e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009192:	e00e      	b.n	80091b2 <HAL_DMA_DeInit+0xcf6>
 8009194:	2340      	movs	r3, #64	; 0x40
 8009196:	e00c      	b.n	80091b2 <HAL_DMA_DeInit+0xcf6>
 8009198:	2340      	movs	r3, #64	; 0x40
 800919a:	e00a      	b.n	80091b2 <HAL_DMA_DeInit+0xcf6>
 800919c:	2340      	movs	r3, #64	; 0x40
 800919e:	e008      	b.n	80091b2 <HAL_DMA_DeInit+0xcf6>
 80091a0:	2340      	movs	r3, #64	; 0x40
 80091a2:	e006      	b.n	80091b2 <HAL_DMA_DeInit+0xcf6>
 80091a4:	4b44      	ldr	r3, [pc, #272]	; (80092b8 <HAL_DMA_DeInit+0xdfc>)
 80091a6:	e004      	b.n	80091b2 <HAL_DMA_DeInit+0xcf6>
 80091a8:	4b43      	ldr	r3, [pc, #268]	; (80092b8 <HAL_DMA_DeInit+0xdfc>)
 80091aa:	e002      	b.n	80091b2 <HAL_DMA_DeInit+0xcf6>
 80091ac:	4b42      	ldr	r3, [pc, #264]	; (80092b8 <HAL_DMA_DeInit+0xdfc>)
 80091ae:	e000      	b.n	80091b2 <HAL_DMA_DeInit+0xcf6>
 80091b0:	4b41      	ldr	r3, [pc, #260]	; (80092b8 <HAL_DMA_DeInit+0xdfc>)
 80091b2:	60d3      	str	r3, [r2, #12]
 80091b4:	e16a      	b.n	800948c <HAL_DMA_DeInit+0xfd0>
 80091b6:	687b      	ldr	r3, [r7, #4]
 80091b8:	681b      	ldr	r3, [r3, #0]
 80091ba:	461a      	mov	r2, r3
 80091bc:	4b3f      	ldr	r3, [pc, #252]	; (80092bc <HAL_DMA_DeInit+0xe00>)
 80091be:	429a      	cmp	r2, r3
 80091c0:	f240 808d 	bls.w	80092de <HAL_DMA_DeInit+0xe22>
 80091c4:	4a3b      	ldr	r2, [pc, #236]	; (80092b4 <HAL_DMA_DeInit+0xdf8>)
 80091c6:	687b      	ldr	r3, [r7, #4]
 80091c8:	681b      	ldr	r3, [r3, #0]
 80091ca:	4619      	mov	r1, r3
 80091cc:	4b2c      	ldr	r3, [pc, #176]	; (8009280 <HAL_DMA_DeInit+0xdc4>)
 80091ce:	4299      	cmp	r1, r3
 80091d0:	f000 8082 	beq.w	80092d8 <HAL_DMA_DeInit+0xe1c>
 80091d4:	687b      	ldr	r3, [r7, #4]
 80091d6:	681b      	ldr	r3, [r3, #0]
 80091d8:	4619      	mov	r1, r3
 80091da:	4b2a      	ldr	r3, [pc, #168]	; (8009284 <HAL_DMA_DeInit+0xdc8>)
 80091dc:	4299      	cmp	r1, r3
 80091de:	d079      	beq.n	80092d4 <HAL_DMA_DeInit+0xe18>
 80091e0:	687b      	ldr	r3, [r7, #4]
 80091e2:	681b      	ldr	r3, [r3, #0]
 80091e4:	4619      	mov	r1, r3
 80091e6:	4b28      	ldr	r3, [pc, #160]	; (8009288 <HAL_DMA_DeInit+0xdcc>)
 80091e8:	4299      	cmp	r1, r3
 80091ea:	d071      	beq.n	80092d0 <HAL_DMA_DeInit+0xe14>
 80091ec:	687b      	ldr	r3, [r7, #4]
 80091ee:	681b      	ldr	r3, [r3, #0]
 80091f0:	4619      	mov	r1, r3
 80091f2:	4b26      	ldr	r3, [pc, #152]	; (800928c <HAL_DMA_DeInit+0xdd0>)
 80091f4:	4299      	cmp	r1, r3
 80091f6:	d069      	beq.n	80092cc <HAL_DMA_DeInit+0xe10>
 80091f8:	687b      	ldr	r3, [r7, #4]
 80091fa:	681b      	ldr	r3, [r3, #0]
 80091fc:	4619      	mov	r1, r3
 80091fe:	4b24      	ldr	r3, [pc, #144]	; (8009290 <HAL_DMA_DeInit+0xdd4>)
 8009200:	4299      	cmp	r1, r3
 8009202:	d061      	beq.n	80092c8 <HAL_DMA_DeInit+0xe0c>
 8009204:	687b      	ldr	r3, [r7, #4]
 8009206:	681b      	ldr	r3, [r3, #0]
 8009208:	4619      	mov	r1, r3
 800920a:	4b22      	ldr	r3, [pc, #136]	; (8009294 <HAL_DMA_DeInit+0xdd8>)
 800920c:	4299      	cmp	r1, r3
 800920e:	d059      	beq.n	80092c4 <HAL_DMA_DeInit+0xe08>
 8009210:	687b      	ldr	r3, [r7, #4]
 8009212:	681b      	ldr	r3, [r3, #0]
 8009214:	4619      	mov	r1, r3
 8009216:	4b20      	ldr	r3, [pc, #128]	; (8009298 <HAL_DMA_DeInit+0xddc>)
 8009218:	4299      	cmp	r1, r3
 800921a:	d051      	beq.n	80092c0 <HAL_DMA_DeInit+0xe04>
 800921c:	687b      	ldr	r3, [r7, #4]
 800921e:	681b      	ldr	r3, [r3, #0]
 8009220:	4619      	mov	r1, r3
 8009222:	4b1e      	ldr	r3, [pc, #120]	; (800929c <HAL_DMA_DeInit+0xde0>)
 8009224:	4299      	cmp	r1, r3
 8009226:	d026      	beq.n	8009276 <HAL_DMA_DeInit+0xdba>
 8009228:	687b      	ldr	r3, [r7, #4]
 800922a:	681b      	ldr	r3, [r3, #0]
 800922c:	4619      	mov	r1, r3
 800922e:	4b1c      	ldr	r3, [pc, #112]	; (80092a0 <HAL_DMA_DeInit+0xde4>)
 8009230:	4299      	cmp	r1, r3
 8009232:	d01d      	beq.n	8009270 <HAL_DMA_DeInit+0xdb4>
 8009234:	687b      	ldr	r3, [r7, #4]
 8009236:	681b      	ldr	r3, [r3, #0]
 8009238:	4619      	mov	r1, r3
 800923a:	4b1a      	ldr	r3, [pc, #104]	; (80092a4 <HAL_DMA_DeInit+0xde8>)
 800923c:	4299      	cmp	r1, r3
 800923e:	d014      	beq.n	800926a <HAL_DMA_DeInit+0xdae>
 8009240:	687b      	ldr	r3, [r7, #4]
 8009242:	681b      	ldr	r3, [r3, #0]
 8009244:	4619      	mov	r1, r3
 8009246:	4b18      	ldr	r3, [pc, #96]	; (80092a8 <HAL_DMA_DeInit+0xdec>)
 8009248:	4299      	cmp	r1, r3
 800924a:	d00b      	beq.n	8009264 <HAL_DMA_DeInit+0xda8>
 800924c:	687b      	ldr	r3, [r7, #4]
 800924e:	681b      	ldr	r3, [r3, #0]
 8009250:	4619      	mov	r1, r3
 8009252:	4b16      	ldr	r3, [pc, #88]	; (80092ac <HAL_DMA_DeInit+0xdf0>)
 8009254:	4299      	cmp	r1, r3
 8009256:	d102      	bne.n	800925e <HAL_DMA_DeInit+0xda2>
 8009258:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800925c:	e03d      	b.n	80092da <HAL_DMA_DeInit+0xe1e>
 800925e:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8009262:	e03a      	b.n	80092da <HAL_DMA_DeInit+0xe1e>
 8009264:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009268:	e037      	b.n	80092da <HAL_DMA_DeInit+0xe1e>
 800926a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800926e:	e034      	b.n	80092da <HAL_DMA_DeInit+0xe1e>
 8009270:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009274:	e031      	b.n	80092da <HAL_DMA_DeInit+0xe1e>
 8009276:	2340      	movs	r3, #64	; 0x40
 8009278:	e02f      	b.n	80092da <HAL_DMA_DeInit+0xe1e>
 800927a:	bf00      	nop
 800927c:	40026000 	.word	0x40026000
 8009280:	40026010 	.word	0x40026010
 8009284:	40026410 	.word	0x40026410
 8009288:	40026070 	.word	0x40026070
 800928c:	40026470 	.word	0x40026470
 8009290:	40026028 	.word	0x40026028
 8009294:	40026428 	.word	0x40026428
 8009298:	40026088 	.word	0x40026088
 800929c:	40026488 	.word	0x40026488
 80092a0:	40026040 	.word	0x40026040
 80092a4:	40026440 	.word	0x40026440
 80092a8:	400260a0 	.word	0x400260a0
 80092ac:	400264a0 	.word	0x400264a0
 80092b0:	40026458 	.word	0x40026458
 80092b4:	40026400 	.word	0x40026400
 80092b8:	00800001 	.word	0x00800001
 80092bc:	400260b8 	.word	0x400260b8
 80092c0:	2340      	movs	r3, #64	; 0x40
 80092c2:	e00a      	b.n	80092da <HAL_DMA_DeInit+0xe1e>
 80092c4:	2340      	movs	r3, #64	; 0x40
 80092c6:	e008      	b.n	80092da <HAL_DMA_DeInit+0xe1e>
 80092c8:	2340      	movs	r3, #64	; 0x40
 80092ca:	e006      	b.n	80092da <HAL_DMA_DeInit+0xe1e>
 80092cc:	4b99      	ldr	r3, [pc, #612]	; (8009534 <HAL_DMA_DeInit+0x1078>)
 80092ce:	e004      	b.n	80092da <HAL_DMA_DeInit+0xe1e>
 80092d0:	4b98      	ldr	r3, [pc, #608]	; (8009534 <HAL_DMA_DeInit+0x1078>)
 80092d2:	e002      	b.n	80092da <HAL_DMA_DeInit+0xe1e>
 80092d4:	4b97      	ldr	r3, [pc, #604]	; (8009534 <HAL_DMA_DeInit+0x1078>)
 80092d6:	e000      	b.n	80092da <HAL_DMA_DeInit+0xe1e>
 80092d8:	4b96      	ldr	r3, [pc, #600]	; (8009534 <HAL_DMA_DeInit+0x1078>)
 80092da:	6093      	str	r3, [r2, #8]
 80092dc:	e0d6      	b.n	800948c <HAL_DMA_DeInit+0xfd0>
 80092de:	687b      	ldr	r3, [r7, #4]
 80092e0:	681b      	ldr	r3, [r3, #0]
 80092e2:	461a      	mov	r2, r3
 80092e4:	4b94      	ldr	r3, [pc, #592]	; (8009538 <HAL_DMA_DeInit+0x107c>)
 80092e6:	429a      	cmp	r2, r3
 80092e8:	d968      	bls.n	80093bc <HAL_DMA_DeInit+0xf00>
 80092ea:	4a94      	ldr	r2, [pc, #592]	; (800953c <HAL_DMA_DeInit+0x1080>)
 80092ec:	687b      	ldr	r3, [r7, #4]
 80092ee:	681b      	ldr	r3, [r3, #0]
 80092f0:	4619      	mov	r1, r3
 80092f2:	4b93      	ldr	r3, [pc, #588]	; (8009540 <HAL_DMA_DeInit+0x1084>)
 80092f4:	4299      	cmp	r1, r3
 80092f6:	d05e      	beq.n	80093b6 <HAL_DMA_DeInit+0xefa>
 80092f8:	687b      	ldr	r3, [r7, #4]
 80092fa:	681b      	ldr	r3, [r3, #0]
 80092fc:	4619      	mov	r1, r3
 80092fe:	4b91      	ldr	r3, [pc, #580]	; (8009544 <HAL_DMA_DeInit+0x1088>)
 8009300:	4299      	cmp	r1, r3
 8009302:	d056      	beq.n	80093b2 <HAL_DMA_DeInit+0xef6>
 8009304:	687b      	ldr	r3, [r7, #4]
 8009306:	681b      	ldr	r3, [r3, #0]
 8009308:	4619      	mov	r1, r3
 800930a:	4b8f      	ldr	r3, [pc, #572]	; (8009548 <HAL_DMA_DeInit+0x108c>)
 800930c:	4299      	cmp	r1, r3
 800930e:	d04e      	beq.n	80093ae <HAL_DMA_DeInit+0xef2>
 8009310:	687b      	ldr	r3, [r7, #4]
 8009312:	681b      	ldr	r3, [r3, #0]
 8009314:	4619      	mov	r1, r3
 8009316:	4b8d      	ldr	r3, [pc, #564]	; (800954c <HAL_DMA_DeInit+0x1090>)
 8009318:	4299      	cmp	r1, r3
 800931a:	d046      	beq.n	80093aa <HAL_DMA_DeInit+0xeee>
 800931c:	687b      	ldr	r3, [r7, #4]
 800931e:	681b      	ldr	r3, [r3, #0]
 8009320:	4619      	mov	r1, r3
 8009322:	4b8b      	ldr	r3, [pc, #556]	; (8009550 <HAL_DMA_DeInit+0x1094>)
 8009324:	4299      	cmp	r1, r3
 8009326:	d03e      	beq.n	80093a6 <HAL_DMA_DeInit+0xeea>
 8009328:	687b      	ldr	r3, [r7, #4]
 800932a:	681b      	ldr	r3, [r3, #0]
 800932c:	4619      	mov	r1, r3
 800932e:	4b89      	ldr	r3, [pc, #548]	; (8009554 <HAL_DMA_DeInit+0x1098>)
 8009330:	4299      	cmp	r1, r3
 8009332:	d036      	beq.n	80093a2 <HAL_DMA_DeInit+0xee6>
 8009334:	687b      	ldr	r3, [r7, #4]
 8009336:	681b      	ldr	r3, [r3, #0]
 8009338:	4619      	mov	r1, r3
 800933a:	4b87      	ldr	r3, [pc, #540]	; (8009558 <HAL_DMA_DeInit+0x109c>)
 800933c:	4299      	cmp	r1, r3
 800933e:	d02e      	beq.n	800939e <HAL_DMA_DeInit+0xee2>
 8009340:	687b      	ldr	r3, [r7, #4]
 8009342:	681b      	ldr	r3, [r3, #0]
 8009344:	4619      	mov	r1, r3
 8009346:	4b85      	ldr	r3, [pc, #532]	; (800955c <HAL_DMA_DeInit+0x10a0>)
 8009348:	4299      	cmp	r1, r3
 800934a:	d026      	beq.n	800939a <HAL_DMA_DeInit+0xede>
 800934c:	687b      	ldr	r3, [r7, #4]
 800934e:	681b      	ldr	r3, [r3, #0]
 8009350:	4619      	mov	r1, r3
 8009352:	4b83      	ldr	r3, [pc, #524]	; (8009560 <HAL_DMA_DeInit+0x10a4>)
 8009354:	4299      	cmp	r1, r3
 8009356:	d01d      	beq.n	8009394 <HAL_DMA_DeInit+0xed8>
 8009358:	687b      	ldr	r3, [r7, #4]
 800935a:	681b      	ldr	r3, [r3, #0]
 800935c:	4619      	mov	r1, r3
 800935e:	4b81      	ldr	r3, [pc, #516]	; (8009564 <HAL_DMA_DeInit+0x10a8>)
 8009360:	4299      	cmp	r1, r3
 8009362:	d014      	beq.n	800938e <HAL_DMA_DeInit+0xed2>
 8009364:	687b      	ldr	r3, [r7, #4]
 8009366:	681b      	ldr	r3, [r3, #0]
 8009368:	4619      	mov	r1, r3
 800936a:	4b7f      	ldr	r3, [pc, #508]	; (8009568 <HAL_DMA_DeInit+0x10ac>)
 800936c:	4299      	cmp	r1, r3
 800936e:	d00b      	beq.n	8009388 <HAL_DMA_DeInit+0xecc>
 8009370:	687b      	ldr	r3, [r7, #4]
 8009372:	681b      	ldr	r3, [r3, #0]
 8009374:	4619      	mov	r1, r3
 8009376:	4b7d      	ldr	r3, [pc, #500]	; (800956c <HAL_DMA_DeInit+0x10b0>)
 8009378:	4299      	cmp	r1, r3
 800937a:	d102      	bne.n	8009382 <HAL_DMA_DeInit+0xec6>
 800937c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009380:	e01a      	b.n	80093b8 <HAL_DMA_DeInit+0xefc>
 8009382:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8009386:	e017      	b.n	80093b8 <HAL_DMA_DeInit+0xefc>
 8009388:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800938c:	e014      	b.n	80093b8 <HAL_DMA_DeInit+0xefc>
 800938e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009392:	e011      	b.n	80093b8 <HAL_DMA_DeInit+0xefc>
 8009394:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009398:	e00e      	b.n	80093b8 <HAL_DMA_DeInit+0xefc>
 800939a:	2340      	movs	r3, #64	; 0x40
 800939c:	e00c      	b.n	80093b8 <HAL_DMA_DeInit+0xefc>
 800939e:	2340      	movs	r3, #64	; 0x40
 80093a0:	e00a      	b.n	80093b8 <HAL_DMA_DeInit+0xefc>
 80093a2:	2340      	movs	r3, #64	; 0x40
 80093a4:	e008      	b.n	80093b8 <HAL_DMA_DeInit+0xefc>
 80093a6:	2340      	movs	r3, #64	; 0x40
 80093a8:	e006      	b.n	80093b8 <HAL_DMA_DeInit+0xefc>
 80093aa:	4b62      	ldr	r3, [pc, #392]	; (8009534 <HAL_DMA_DeInit+0x1078>)
 80093ac:	e004      	b.n	80093b8 <HAL_DMA_DeInit+0xefc>
 80093ae:	4b61      	ldr	r3, [pc, #388]	; (8009534 <HAL_DMA_DeInit+0x1078>)
 80093b0:	e002      	b.n	80093b8 <HAL_DMA_DeInit+0xefc>
 80093b2:	4b60      	ldr	r3, [pc, #384]	; (8009534 <HAL_DMA_DeInit+0x1078>)
 80093b4:	e000      	b.n	80093b8 <HAL_DMA_DeInit+0xefc>
 80093b6:	4b5f      	ldr	r3, [pc, #380]	; (8009534 <HAL_DMA_DeInit+0x1078>)
 80093b8:	60d3      	str	r3, [r2, #12]
 80093ba:	e067      	b.n	800948c <HAL_DMA_DeInit+0xfd0>
 80093bc:	4a5f      	ldr	r2, [pc, #380]	; (800953c <HAL_DMA_DeInit+0x1080>)
 80093be:	687b      	ldr	r3, [r7, #4]
 80093c0:	681b      	ldr	r3, [r3, #0]
 80093c2:	4619      	mov	r1, r3
 80093c4:	4b5e      	ldr	r3, [pc, #376]	; (8009540 <HAL_DMA_DeInit+0x1084>)
 80093c6:	4299      	cmp	r1, r3
 80093c8:	d05e      	beq.n	8009488 <HAL_DMA_DeInit+0xfcc>
 80093ca:	687b      	ldr	r3, [r7, #4]
 80093cc:	681b      	ldr	r3, [r3, #0]
 80093ce:	4619      	mov	r1, r3
 80093d0:	4b5c      	ldr	r3, [pc, #368]	; (8009544 <HAL_DMA_DeInit+0x1088>)
 80093d2:	4299      	cmp	r1, r3
 80093d4:	d056      	beq.n	8009484 <HAL_DMA_DeInit+0xfc8>
 80093d6:	687b      	ldr	r3, [r7, #4]
 80093d8:	681b      	ldr	r3, [r3, #0]
 80093da:	4619      	mov	r1, r3
 80093dc:	4b5a      	ldr	r3, [pc, #360]	; (8009548 <HAL_DMA_DeInit+0x108c>)
 80093de:	4299      	cmp	r1, r3
 80093e0:	d04e      	beq.n	8009480 <HAL_DMA_DeInit+0xfc4>
 80093e2:	687b      	ldr	r3, [r7, #4]
 80093e4:	681b      	ldr	r3, [r3, #0]
 80093e6:	4619      	mov	r1, r3
 80093e8:	4b58      	ldr	r3, [pc, #352]	; (800954c <HAL_DMA_DeInit+0x1090>)
 80093ea:	4299      	cmp	r1, r3
 80093ec:	d046      	beq.n	800947c <HAL_DMA_DeInit+0xfc0>
 80093ee:	687b      	ldr	r3, [r7, #4]
 80093f0:	681b      	ldr	r3, [r3, #0]
 80093f2:	4619      	mov	r1, r3
 80093f4:	4b56      	ldr	r3, [pc, #344]	; (8009550 <HAL_DMA_DeInit+0x1094>)
 80093f6:	4299      	cmp	r1, r3
 80093f8:	d03e      	beq.n	8009478 <HAL_DMA_DeInit+0xfbc>
 80093fa:	687b      	ldr	r3, [r7, #4]
 80093fc:	681b      	ldr	r3, [r3, #0]
 80093fe:	4619      	mov	r1, r3
 8009400:	4b54      	ldr	r3, [pc, #336]	; (8009554 <HAL_DMA_DeInit+0x1098>)
 8009402:	4299      	cmp	r1, r3
 8009404:	d036      	beq.n	8009474 <HAL_DMA_DeInit+0xfb8>
 8009406:	687b      	ldr	r3, [r7, #4]
 8009408:	681b      	ldr	r3, [r3, #0]
 800940a:	4619      	mov	r1, r3
 800940c:	4b52      	ldr	r3, [pc, #328]	; (8009558 <HAL_DMA_DeInit+0x109c>)
 800940e:	4299      	cmp	r1, r3
 8009410:	d02e      	beq.n	8009470 <HAL_DMA_DeInit+0xfb4>
 8009412:	687b      	ldr	r3, [r7, #4]
 8009414:	681b      	ldr	r3, [r3, #0]
 8009416:	4619      	mov	r1, r3
 8009418:	4b50      	ldr	r3, [pc, #320]	; (800955c <HAL_DMA_DeInit+0x10a0>)
 800941a:	4299      	cmp	r1, r3
 800941c:	d026      	beq.n	800946c <HAL_DMA_DeInit+0xfb0>
 800941e:	687b      	ldr	r3, [r7, #4]
 8009420:	681b      	ldr	r3, [r3, #0]
 8009422:	4619      	mov	r1, r3
 8009424:	4b4e      	ldr	r3, [pc, #312]	; (8009560 <HAL_DMA_DeInit+0x10a4>)
 8009426:	4299      	cmp	r1, r3
 8009428:	d01d      	beq.n	8009466 <HAL_DMA_DeInit+0xfaa>
 800942a:	687b      	ldr	r3, [r7, #4]
 800942c:	681b      	ldr	r3, [r3, #0]
 800942e:	4619      	mov	r1, r3
 8009430:	4b4c      	ldr	r3, [pc, #304]	; (8009564 <HAL_DMA_DeInit+0x10a8>)
 8009432:	4299      	cmp	r1, r3
 8009434:	d014      	beq.n	8009460 <HAL_DMA_DeInit+0xfa4>
 8009436:	687b      	ldr	r3, [r7, #4]
 8009438:	681b      	ldr	r3, [r3, #0]
 800943a:	4619      	mov	r1, r3
 800943c:	4b4a      	ldr	r3, [pc, #296]	; (8009568 <HAL_DMA_DeInit+0x10ac>)
 800943e:	4299      	cmp	r1, r3
 8009440:	d00b      	beq.n	800945a <HAL_DMA_DeInit+0xf9e>
 8009442:	687b      	ldr	r3, [r7, #4]
 8009444:	681b      	ldr	r3, [r3, #0]
 8009446:	4619      	mov	r1, r3
 8009448:	4b48      	ldr	r3, [pc, #288]	; (800956c <HAL_DMA_DeInit+0x10b0>)
 800944a:	4299      	cmp	r1, r3
 800944c:	d102      	bne.n	8009454 <HAL_DMA_DeInit+0xf98>
 800944e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009452:	e01a      	b.n	800948a <HAL_DMA_DeInit+0xfce>
 8009454:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8009458:	e017      	b.n	800948a <HAL_DMA_DeInit+0xfce>
 800945a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800945e:	e014      	b.n	800948a <HAL_DMA_DeInit+0xfce>
 8009460:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009464:	e011      	b.n	800948a <HAL_DMA_DeInit+0xfce>
 8009466:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800946a:	e00e      	b.n	800948a <HAL_DMA_DeInit+0xfce>
 800946c:	2340      	movs	r3, #64	; 0x40
 800946e:	e00c      	b.n	800948a <HAL_DMA_DeInit+0xfce>
 8009470:	2340      	movs	r3, #64	; 0x40
 8009472:	e00a      	b.n	800948a <HAL_DMA_DeInit+0xfce>
 8009474:	2340      	movs	r3, #64	; 0x40
 8009476:	e008      	b.n	800948a <HAL_DMA_DeInit+0xfce>
 8009478:	2340      	movs	r3, #64	; 0x40
 800947a:	e006      	b.n	800948a <HAL_DMA_DeInit+0xfce>
 800947c:	4b2d      	ldr	r3, [pc, #180]	; (8009534 <HAL_DMA_DeInit+0x1078>)
 800947e:	e004      	b.n	800948a <HAL_DMA_DeInit+0xfce>
 8009480:	4b2c      	ldr	r3, [pc, #176]	; (8009534 <HAL_DMA_DeInit+0x1078>)
 8009482:	e002      	b.n	800948a <HAL_DMA_DeInit+0xfce>
 8009484:	4b2b      	ldr	r3, [pc, #172]	; (8009534 <HAL_DMA_DeInit+0x1078>)
 8009486:	e000      	b.n	800948a <HAL_DMA_DeInit+0xfce>
 8009488:	4b2a      	ldr	r3, [pc, #168]	; (8009534 <HAL_DMA_DeInit+0x1078>)
 800948a:	6093      	str	r3, [r2, #8]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 800948c:	687b      	ldr	r3, [r7, #4]
 800948e:	681b      	ldr	r3, [r3, #0]
 8009490:	461a      	mov	r2, r3
 8009492:	4b37      	ldr	r3, [pc, #220]	; (8009570 <HAL_DMA_DeInit+0x10b4>)
 8009494:	429a      	cmp	r2, r3
 8009496:	f240 8090 	bls.w	80095ba <HAL_DMA_DeInit+0x10fe>
 800949a:	4a36      	ldr	r2, [pc, #216]	; (8009574 <HAL_DMA_DeInit+0x10b8>)
 800949c:	687b      	ldr	r3, [r7, #4]
 800949e:	681b      	ldr	r3, [r3, #0]
 80094a0:	4619      	mov	r1, r3
 80094a2:	4b27      	ldr	r3, [pc, #156]	; (8009540 <HAL_DMA_DeInit+0x1084>)
 80094a4:	4299      	cmp	r1, r3
 80094a6:	f000 8085 	beq.w	80095b4 <HAL_DMA_DeInit+0x10f8>
 80094aa:	687b      	ldr	r3, [r7, #4]
 80094ac:	681b      	ldr	r3, [r3, #0]
 80094ae:	4619      	mov	r1, r3
 80094b0:	4b24      	ldr	r3, [pc, #144]	; (8009544 <HAL_DMA_DeInit+0x1088>)
 80094b2:	4299      	cmp	r1, r3
 80094b4:	d07c      	beq.n	80095b0 <HAL_DMA_DeInit+0x10f4>
 80094b6:	687b      	ldr	r3, [r7, #4]
 80094b8:	681b      	ldr	r3, [r3, #0]
 80094ba:	4619      	mov	r1, r3
 80094bc:	4b22      	ldr	r3, [pc, #136]	; (8009548 <HAL_DMA_DeInit+0x108c>)
 80094be:	4299      	cmp	r1, r3
 80094c0:	d074      	beq.n	80095ac <HAL_DMA_DeInit+0x10f0>
 80094c2:	687b      	ldr	r3, [r7, #4]
 80094c4:	681b      	ldr	r3, [r3, #0]
 80094c6:	4619      	mov	r1, r3
 80094c8:	4b20      	ldr	r3, [pc, #128]	; (800954c <HAL_DMA_DeInit+0x1090>)
 80094ca:	4299      	cmp	r1, r3
 80094cc:	d06c      	beq.n	80095a8 <HAL_DMA_DeInit+0x10ec>
 80094ce:	687b      	ldr	r3, [r7, #4]
 80094d0:	681b      	ldr	r3, [r3, #0]
 80094d2:	4619      	mov	r1, r3
 80094d4:	4b1e      	ldr	r3, [pc, #120]	; (8009550 <HAL_DMA_DeInit+0x1094>)
 80094d6:	4299      	cmp	r1, r3
 80094d8:	d063      	beq.n	80095a2 <HAL_DMA_DeInit+0x10e6>
 80094da:	687b      	ldr	r3, [r7, #4]
 80094dc:	681b      	ldr	r3, [r3, #0]
 80094de:	4619      	mov	r1, r3
 80094e0:	4b1c      	ldr	r3, [pc, #112]	; (8009554 <HAL_DMA_DeInit+0x1098>)
 80094e2:	4299      	cmp	r1, r3
 80094e4:	d05a      	beq.n	800959c <HAL_DMA_DeInit+0x10e0>
 80094e6:	687b      	ldr	r3, [r7, #4]
 80094e8:	681b      	ldr	r3, [r3, #0]
 80094ea:	4619      	mov	r1, r3
 80094ec:	4b1a      	ldr	r3, [pc, #104]	; (8009558 <HAL_DMA_DeInit+0x109c>)
 80094ee:	4299      	cmp	r1, r3
 80094f0:	d051      	beq.n	8009596 <HAL_DMA_DeInit+0x10da>
 80094f2:	687b      	ldr	r3, [r7, #4]
 80094f4:	681b      	ldr	r3, [r3, #0]
 80094f6:	4619      	mov	r1, r3
 80094f8:	4b18      	ldr	r3, [pc, #96]	; (800955c <HAL_DMA_DeInit+0x10a0>)
 80094fa:	4299      	cmp	r1, r3
 80094fc:	d048      	beq.n	8009590 <HAL_DMA_DeInit+0x10d4>
 80094fe:	687b      	ldr	r3, [r7, #4]
 8009500:	681b      	ldr	r3, [r3, #0]
 8009502:	4619      	mov	r1, r3
 8009504:	4b16      	ldr	r3, [pc, #88]	; (8009560 <HAL_DMA_DeInit+0x10a4>)
 8009506:	4299      	cmp	r1, r3
 8009508:	d03f      	beq.n	800958a <HAL_DMA_DeInit+0x10ce>
 800950a:	687b      	ldr	r3, [r7, #4]
 800950c:	681b      	ldr	r3, [r3, #0]
 800950e:	4619      	mov	r1, r3
 8009510:	4b14      	ldr	r3, [pc, #80]	; (8009564 <HAL_DMA_DeInit+0x10a8>)
 8009512:	4299      	cmp	r1, r3
 8009514:	d036      	beq.n	8009584 <HAL_DMA_DeInit+0x10c8>
 8009516:	687b      	ldr	r3, [r7, #4]
 8009518:	681b      	ldr	r3, [r3, #0]
 800951a:	4619      	mov	r1, r3
 800951c:	4b12      	ldr	r3, [pc, #72]	; (8009568 <HAL_DMA_DeInit+0x10ac>)
 800951e:	4299      	cmp	r1, r3
 8009520:	d02d      	beq.n	800957e <HAL_DMA_DeInit+0x10c2>
 8009522:	687b      	ldr	r3, [r7, #4]
 8009524:	681b      	ldr	r3, [r3, #0]
 8009526:	4619      	mov	r1, r3
 8009528:	4b10      	ldr	r3, [pc, #64]	; (800956c <HAL_DMA_DeInit+0x10b0>)
 800952a:	4299      	cmp	r1, r3
 800952c:	d124      	bne.n	8009578 <HAL_DMA_DeInit+0x10bc>
 800952e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009532:	e040      	b.n	80095b6 <HAL_DMA_DeInit+0x10fa>
 8009534:	00800001 	.word	0x00800001
 8009538:	40026058 	.word	0x40026058
 800953c:	40026000 	.word	0x40026000
 8009540:	40026010 	.word	0x40026010
 8009544:	40026410 	.word	0x40026410
 8009548:	40026070 	.word	0x40026070
 800954c:	40026470 	.word	0x40026470
 8009550:	40026028 	.word	0x40026028
 8009554:	40026428 	.word	0x40026428
 8009558:	40026088 	.word	0x40026088
 800955c:	40026488 	.word	0x40026488
 8009560:	40026040 	.word	0x40026040
 8009564:	40026440 	.word	0x40026440
 8009568:	400260a0 	.word	0x400260a0
 800956c:	400264a0 	.word	0x400264a0
 8009570:	40026458 	.word	0x40026458
 8009574:	40026400 	.word	0x40026400
 8009578:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800957c:	e01b      	b.n	80095b6 <HAL_DMA_DeInit+0x10fa>
 800957e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009582:	e018      	b.n	80095b6 <HAL_DMA_DeInit+0x10fa>
 8009584:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009588:	e015      	b.n	80095b6 <HAL_DMA_DeInit+0x10fa>
 800958a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800958e:	e012      	b.n	80095b6 <HAL_DMA_DeInit+0x10fa>
 8009590:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009594:	e00f      	b.n	80095b6 <HAL_DMA_DeInit+0x10fa>
 8009596:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800959a:	e00c      	b.n	80095b6 <HAL_DMA_DeInit+0x10fa>
 800959c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80095a0:	e009      	b.n	80095b6 <HAL_DMA_DeInit+0x10fa>
 80095a2:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80095a6:	e006      	b.n	80095b6 <HAL_DMA_DeInit+0x10fa>
 80095a8:	2310      	movs	r3, #16
 80095aa:	e004      	b.n	80095b6 <HAL_DMA_DeInit+0x10fa>
 80095ac:	2310      	movs	r3, #16
 80095ae:	e002      	b.n	80095b6 <HAL_DMA_DeInit+0x10fa>
 80095b0:	2310      	movs	r3, #16
 80095b2:	e000      	b.n	80095b6 <HAL_DMA_DeInit+0x10fa>
 80095b4:	2310      	movs	r3, #16
 80095b6:	60d3      	str	r3, [r2, #12]
 80095b8:	e173      	b.n	80098a2 <HAL_DMA_DeInit+0x13e6>
 80095ba:	687b      	ldr	r3, [r7, #4]
 80095bc:	681b      	ldr	r3, [r3, #0]
 80095be:	461a      	mov	r2, r3
 80095c0:	4b9f      	ldr	r3, [pc, #636]	; (8009840 <HAL_DMA_DeInit+0x1384>)
 80095c2:	429a      	cmp	r2, r3
 80095c4:	d96c      	bls.n	80096a0 <HAL_DMA_DeInit+0x11e4>
 80095c6:	4a9f      	ldr	r2, [pc, #636]	; (8009844 <HAL_DMA_DeInit+0x1388>)
 80095c8:	687b      	ldr	r3, [r7, #4]
 80095ca:	681b      	ldr	r3, [r3, #0]
 80095cc:	4619      	mov	r1, r3
 80095ce:	4b9e      	ldr	r3, [pc, #632]	; (8009848 <HAL_DMA_DeInit+0x138c>)
 80095d0:	4299      	cmp	r1, r3
 80095d2:	d062      	beq.n	800969a <HAL_DMA_DeInit+0x11de>
 80095d4:	687b      	ldr	r3, [r7, #4]
 80095d6:	681b      	ldr	r3, [r3, #0]
 80095d8:	4619      	mov	r1, r3
 80095da:	4b9c      	ldr	r3, [pc, #624]	; (800984c <HAL_DMA_DeInit+0x1390>)
 80095dc:	4299      	cmp	r1, r3
 80095de:	d05a      	beq.n	8009696 <HAL_DMA_DeInit+0x11da>
 80095e0:	687b      	ldr	r3, [r7, #4]
 80095e2:	681b      	ldr	r3, [r3, #0]
 80095e4:	4619      	mov	r1, r3
 80095e6:	4b9a      	ldr	r3, [pc, #616]	; (8009850 <HAL_DMA_DeInit+0x1394>)
 80095e8:	4299      	cmp	r1, r3
 80095ea:	d052      	beq.n	8009692 <HAL_DMA_DeInit+0x11d6>
 80095ec:	687b      	ldr	r3, [r7, #4]
 80095ee:	681b      	ldr	r3, [r3, #0]
 80095f0:	4619      	mov	r1, r3
 80095f2:	4b98      	ldr	r3, [pc, #608]	; (8009854 <HAL_DMA_DeInit+0x1398>)
 80095f4:	4299      	cmp	r1, r3
 80095f6:	d04a      	beq.n	800968e <HAL_DMA_DeInit+0x11d2>
 80095f8:	687b      	ldr	r3, [r7, #4]
 80095fa:	681b      	ldr	r3, [r3, #0]
 80095fc:	4619      	mov	r1, r3
 80095fe:	4b96      	ldr	r3, [pc, #600]	; (8009858 <HAL_DMA_DeInit+0x139c>)
 8009600:	4299      	cmp	r1, r3
 8009602:	d041      	beq.n	8009688 <HAL_DMA_DeInit+0x11cc>
 8009604:	687b      	ldr	r3, [r7, #4]
 8009606:	681b      	ldr	r3, [r3, #0]
 8009608:	4619      	mov	r1, r3
 800960a:	4b94      	ldr	r3, [pc, #592]	; (800985c <HAL_DMA_DeInit+0x13a0>)
 800960c:	4299      	cmp	r1, r3
 800960e:	d038      	beq.n	8009682 <HAL_DMA_DeInit+0x11c6>
 8009610:	687b      	ldr	r3, [r7, #4]
 8009612:	681b      	ldr	r3, [r3, #0]
 8009614:	4619      	mov	r1, r3
 8009616:	4b92      	ldr	r3, [pc, #584]	; (8009860 <HAL_DMA_DeInit+0x13a4>)
 8009618:	4299      	cmp	r1, r3
 800961a:	d02f      	beq.n	800967c <HAL_DMA_DeInit+0x11c0>
 800961c:	687b      	ldr	r3, [r7, #4]
 800961e:	681b      	ldr	r3, [r3, #0]
 8009620:	4619      	mov	r1, r3
 8009622:	4b90      	ldr	r3, [pc, #576]	; (8009864 <HAL_DMA_DeInit+0x13a8>)
 8009624:	4299      	cmp	r1, r3
 8009626:	d026      	beq.n	8009676 <HAL_DMA_DeInit+0x11ba>
 8009628:	687b      	ldr	r3, [r7, #4]
 800962a:	681b      	ldr	r3, [r3, #0]
 800962c:	4619      	mov	r1, r3
 800962e:	4b8e      	ldr	r3, [pc, #568]	; (8009868 <HAL_DMA_DeInit+0x13ac>)
 8009630:	4299      	cmp	r1, r3
 8009632:	d01d      	beq.n	8009670 <HAL_DMA_DeInit+0x11b4>
 8009634:	687b      	ldr	r3, [r7, #4]
 8009636:	681b      	ldr	r3, [r3, #0]
 8009638:	4619      	mov	r1, r3
 800963a:	4b8c      	ldr	r3, [pc, #560]	; (800986c <HAL_DMA_DeInit+0x13b0>)
 800963c:	4299      	cmp	r1, r3
 800963e:	d014      	beq.n	800966a <HAL_DMA_DeInit+0x11ae>
 8009640:	687b      	ldr	r3, [r7, #4]
 8009642:	681b      	ldr	r3, [r3, #0]
 8009644:	4619      	mov	r1, r3
 8009646:	4b8a      	ldr	r3, [pc, #552]	; (8009870 <HAL_DMA_DeInit+0x13b4>)
 8009648:	4299      	cmp	r1, r3
 800964a:	d00b      	beq.n	8009664 <HAL_DMA_DeInit+0x11a8>
 800964c:	687b      	ldr	r3, [r7, #4]
 800964e:	681b      	ldr	r3, [r3, #0]
 8009650:	4619      	mov	r1, r3
 8009652:	4b88      	ldr	r3, [pc, #544]	; (8009874 <HAL_DMA_DeInit+0x13b8>)
 8009654:	4299      	cmp	r1, r3
 8009656:	d102      	bne.n	800965e <HAL_DMA_DeInit+0x11a2>
 8009658:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800965c:	e01e      	b.n	800969c <HAL_DMA_DeInit+0x11e0>
 800965e:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8009662:	e01b      	b.n	800969c <HAL_DMA_DeInit+0x11e0>
 8009664:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009668:	e018      	b.n	800969c <HAL_DMA_DeInit+0x11e0>
 800966a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800966e:	e015      	b.n	800969c <HAL_DMA_DeInit+0x11e0>
 8009670:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009674:	e012      	b.n	800969c <HAL_DMA_DeInit+0x11e0>
 8009676:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800967a:	e00f      	b.n	800969c <HAL_DMA_DeInit+0x11e0>
 800967c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009680:	e00c      	b.n	800969c <HAL_DMA_DeInit+0x11e0>
 8009682:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009686:	e009      	b.n	800969c <HAL_DMA_DeInit+0x11e0>
 8009688:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800968c:	e006      	b.n	800969c <HAL_DMA_DeInit+0x11e0>
 800968e:	2310      	movs	r3, #16
 8009690:	e004      	b.n	800969c <HAL_DMA_DeInit+0x11e0>
 8009692:	2310      	movs	r3, #16
 8009694:	e002      	b.n	800969c <HAL_DMA_DeInit+0x11e0>
 8009696:	2310      	movs	r3, #16
 8009698:	e000      	b.n	800969c <HAL_DMA_DeInit+0x11e0>
 800969a:	2310      	movs	r3, #16
 800969c:	6093      	str	r3, [r2, #8]
 800969e:	e100      	b.n	80098a2 <HAL_DMA_DeInit+0x13e6>
 80096a0:	687b      	ldr	r3, [r7, #4]
 80096a2:	681b      	ldr	r3, [r3, #0]
 80096a4:	461a      	mov	r2, r3
 80096a6:	4b74      	ldr	r3, [pc, #464]	; (8009878 <HAL_DMA_DeInit+0x13bc>)
 80096a8:	429a      	cmp	r2, r3
 80096aa:	d96c      	bls.n	8009786 <HAL_DMA_DeInit+0x12ca>
 80096ac:	4a73      	ldr	r2, [pc, #460]	; (800987c <HAL_DMA_DeInit+0x13c0>)
 80096ae:	687b      	ldr	r3, [r7, #4]
 80096b0:	681b      	ldr	r3, [r3, #0]
 80096b2:	4619      	mov	r1, r3
 80096b4:	4b64      	ldr	r3, [pc, #400]	; (8009848 <HAL_DMA_DeInit+0x138c>)
 80096b6:	4299      	cmp	r1, r3
 80096b8:	d062      	beq.n	8009780 <HAL_DMA_DeInit+0x12c4>
 80096ba:	687b      	ldr	r3, [r7, #4]
 80096bc:	681b      	ldr	r3, [r3, #0]
 80096be:	4619      	mov	r1, r3
 80096c0:	4b62      	ldr	r3, [pc, #392]	; (800984c <HAL_DMA_DeInit+0x1390>)
 80096c2:	4299      	cmp	r1, r3
 80096c4:	d05a      	beq.n	800977c <HAL_DMA_DeInit+0x12c0>
 80096c6:	687b      	ldr	r3, [r7, #4]
 80096c8:	681b      	ldr	r3, [r3, #0]
 80096ca:	4619      	mov	r1, r3
 80096cc:	4b60      	ldr	r3, [pc, #384]	; (8009850 <HAL_DMA_DeInit+0x1394>)
 80096ce:	4299      	cmp	r1, r3
 80096d0:	d052      	beq.n	8009778 <HAL_DMA_DeInit+0x12bc>
 80096d2:	687b      	ldr	r3, [r7, #4]
 80096d4:	681b      	ldr	r3, [r3, #0]
 80096d6:	4619      	mov	r1, r3
 80096d8:	4b5e      	ldr	r3, [pc, #376]	; (8009854 <HAL_DMA_DeInit+0x1398>)
 80096da:	4299      	cmp	r1, r3
 80096dc:	d04a      	beq.n	8009774 <HAL_DMA_DeInit+0x12b8>
 80096de:	687b      	ldr	r3, [r7, #4]
 80096e0:	681b      	ldr	r3, [r3, #0]
 80096e2:	4619      	mov	r1, r3
 80096e4:	4b5c      	ldr	r3, [pc, #368]	; (8009858 <HAL_DMA_DeInit+0x139c>)
 80096e6:	4299      	cmp	r1, r3
 80096e8:	d041      	beq.n	800976e <HAL_DMA_DeInit+0x12b2>
 80096ea:	687b      	ldr	r3, [r7, #4]
 80096ec:	681b      	ldr	r3, [r3, #0]
 80096ee:	4619      	mov	r1, r3
 80096f0:	4b5a      	ldr	r3, [pc, #360]	; (800985c <HAL_DMA_DeInit+0x13a0>)
 80096f2:	4299      	cmp	r1, r3
 80096f4:	d038      	beq.n	8009768 <HAL_DMA_DeInit+0x12ac>
 80096f6:	687b      	ldr	r3, [r7, #4]
 80096f8:	681b      	ldr	r3, [r3, #0]
 80096fa:	4619      	mov	r1, r3
 80096fc:	4b58      	ldr	r3, [pc, #352]	; (8009860 <HAL_DMA_DeInit+0x13a4>)
 80096fe:	4299      	cmp	r1, r3
 8009700:	d02f      	beq.n	8009762 <HAL_DMA_DeInit+0x12a6>
 8009702:	687b      	ldr	r3, [r7, #4]
 8009704:	681b      	ldr	r3, [r3, #0]
 8009706:	4619      	mov	r1, r3
 8009708:	4b56      	ldr	r3, [pc, #344]	; (8009864 <HAL_DMA_DeInit+0x13a8>)
 800970a:	4299      	cmp	r1, r3
 800970c:	d026      	beq.n	800975c <HAL_DMA_DeInit+0x12a0>
 800970e:	687b      	ldr	r3, [r7, #4]
 8009710:	681b      	ldr	r3, [r3, #0]
 8009712:	4619      	mov	r1, r3
 8009714:	4b54      	ldr	r3, [pc, #336]	; (8009868 <HAL_DMA_DeInit+0x13ac>)
 8009716:	4299      	cmp	r1, r3
 8009718:	d01d      	beq.n	8009756 <HAL_DMA_DeInit+0x129a>
 800971a:	687b      	ldr	r3, [r7, #4]
 800971c:	681b      	ldr	r3, [r3, #0]
 800971e:	4619      	mov	r1, r3
 8009720:	4b52      	ldr	r3, [pc, #328]	; (800986c <HAL_DMA_DeInit+0x13b0>)
 8009722:	4299      	cmp	r1, r3
 8009724:	d014      	beq.n	8009750 <HAL_DMA_DeInit+0x1294>
 8009726:	687b      	ldr	r3, [r7, #4]
 8009728:	681b      	ldr	r3, [r3, #0]
 800972a:	4619      	mov	r1, r3
 800972c:	4b50      	ldr	r3, [pc, #320]	; (8009870 <HAL_DMA_DeInit+0x13b4>)
 800972e:	4299      	cmp	r1, r3
 8009730:	d00b      	beq.n	800974a <HAL_DMA_DeInit+0x128e>
 8009732:	687b      	ldr	r3, [r7, #4]
 8009734:	681b      	ldr	r3, [r3, #0]
 8009736:	4619      	mov	r1, r3
 8009738:	4b4e      	ldr	r3, [pc, #312]	; (8009874 <HAL_DMA_DeInit+0x13b8>)
 800973a:	4299      	cmp	r1, r3
 800973c:	d102      	bne.n	8009744 <HAL_DMA_DeInit+0x1288>
 800973e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009742:	e01e      	b.n	8009782 <HAL_DMA_DeInit+0x12c6>
 8009744:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8009748:	e01b      	b.n	8009782 <HAL_DMA_DeInit+0x12c6>
 800974a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800974e:	e018      	b.n	8009782 <HAL_DMA_DeInit+0x12c6>
 8009750:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009754:	e015      	b.n	8009782 <HAL_DMA_DeInit+0x12c6>
 8009756:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800975a:	e012      	b.n	8009782 <HAL_DMA_DeInit+0x12c6>
 800975c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009760:	e00f      	b.n	8009782 <HAL_DMA_DeInit+0x12c6>
 8009762:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009766:	e00c      	b.n	8009782 <HAL_DMA_DeInit+0x12c6>
 8009768:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800976c:	e009      	b.n	8009782 <HAL_DMA_DeInit+0x12c6>
 800976e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009772:	e006      	b.n	8009782 <HAL_DMA_DeInit+0x12c6>
 8009774:	2310      	movs	r3, #16
 8009776:	e004      	b.n	8009782 <HAL_DMA_DeInit+0x12c6>
 8009778:	2310      	movs	r3, #16
 800977a:	e002      	b.n	8009782 <HAL_DMA_DeInit+0x12c6>
 800977c:	2310      	movs	r3, #16
 800977e:	e000      	b.n	8009782 <HAL_DMA_DeInit+0x12c6>
 8009780:	2310      	movs	r3, #16
 8009782:	60d3      	str	r3, [r2, #12]
 8009784:	e08d      	b.n	80098a2 <HAL_DMA_DeInit+0x13e6>
 8009786:	4a3d      	ldr	r2, [pc, #244]	; (800987c <HAL_DMA_DeInit+0x13c0>)
 8009788:	687b      	ldr	r3, [r7, #4]
 800978a:	681b      	ldr	r3, [r3, #0]
 800978c:	4619      	mov	r1, r3
 800978e:	4b2e      	ldr	r3, [pc, #184]	; (8009848 <HAL_DMA_DeInit+0x138c>)
 8009790:	4299      	cmp	r1, r3
 8009792:	f000 8084 	beq.w	800989e <HAL_DMA_DeInit+0x13e2>
 8009796:	687b      	ldr	r3, [r7, #4]
 8009798:	681b      	ldr	r3, [r3, #0]
 800979a:	4619      	mov	r1, r3
 800979c:	4b2b      	ldr	r3, [pc, #172]	; (800984c <HAL_DMA_DeInit+0x1390>)
 800979e:	4299      	cmp	r1, r3
 80097a0:	d07b      	beq.n	800989a <HAL_DMA_DeInit+0x13de>
 80097a2:	687b      	ldr	r3, [r7, #4]
 80097a4:	681b      	ldr	r3, [r3, #0]
 80097a6:	4619      	mov	r1, r3
 80097a8:	4b29      	ldr	r3, [pc, #164]	; (8009850 <HAL_DMA_DeInit+0x1394>)
 80097aa:	4299      	cmp	r1, r3
 80097ac:	d073      	beq.n	8009896 <HAL_DMA_DeInit+0x13da>
 80097ae:	687b      	ldr	r3, [r7, #4]
 80097b0:	681b      	ldr	r3, [r3, #0]
 80097b2:	4619      	mov	r1, r3
 80097b4:	4b27      	ldr	r3, [pc, #156]	; (8009854 <HAL_DMA_DeInit+0x1398>)
 80097b6:	4299      	cmp	r1, r3
 80097b8:	d06b      	beq.n	8009892 <HAL_DMA_DeInit+0x13d6>
 80097ba:	687b      	ldr	r3, [r7, #4]
 80097bc:	681b      	ldr	r3, [r3, #0]
 80097be:	4619      	mov	r1, r3
 80097c0:	4b25      	ldr	r3, [pc, #148]	; (8009858 <HAL_DMA_DeInit+0x139c>)
 80097c2:	4299      	cmp	r1, r3
 80097c4:	d062      	beq.n	800988c <HAL_DMA_DeInit+0x13d0>
 80097c6:	687b      	ldr	r3, [r7, #4]
 80097c8:	681b      	ldr	r3, [r3, #0]
 80097ca:	4619      	mov	r1, r3
 80097cc:	4b23      	ldr	r3, [pc, #140]	; (800985c <HAL_DMA_DeInit+0x13a0>)
 80097ce:	4299      	cmp	r1, r3
 80097d0:	d059      	beq.n	8009886 <HAL_DMA_DeInit+0x13ca>
 80097d2:	687b      	ldr	r3, [r7, #4]
 80097d4:	681b      	ldr	r3, [r3, #0]
 80097d6:	4619      	mov	r1, r3
 80097d8:	4b21      	ldr	r3, [pc, #132]	; (8009860 <HAL_DMA_DeInit+0x13a4>)
 80097da:	4299      	cmp	r1, r3
 80097dc:	d050      	beq.n	8009880 <HAL_DMA_DeInit+0x13c4>
 80097de:	687b      	ldr	r3, [r7, #4]
 80097e0:	681b      	ldr	r3, [r3, #0]
 80097e2:	4619      	mov	r1, r3
 80097e4:	4b1f      	ldr	r3, [pc, #124]	; (8009864 <HAL_DMA_DeInit+0x13a8>)
 80097e6:	4299      	cmp	r1, r3
 80097e8:	d026      	beq.n	8009838 <HAL_DMA_DeInit+0x137c>
 80097ea:	687b      	ldr	r3, [r7, #4]
 80097ec:	681b      	ldr	r3, [r3, #0]
 80097ee:	4619      	mov	r1, r3
 80097f0:	4b1d      	ldr	r3, [pc, #116]	; (8009868 <HAL_DMA_DeInit+0x13ac>)
 80097f2:	4299      	cmp	r1, r3
 80097f4:	d01d      	beq.n	8009832 <HAL_DMA_DeInit+0x1376>
 80097f6:	687b      	ldr	r3, [r7, #4]
 80097f8:	681b      	ldr	r3, [r3, #0]
 80097fa:	4619      	mov	r1, r3
 80097fc:	4b1b      	ldr	r3, [pc, #108]	; (800986c <HAL_DMA_DeInit+0x13b0>)
 80097fe:	4299      	cmp	r1, r3
 8009800:	d014      	beq.n	800982c <HAL_DMA_DeInit+0x1370>
 8009802:	687b      	ldr	r3, [r7, #4]
 8009804:	681b      	ldr	r3, [r3, #0]
 8009806:	4619      	mov	r1, r3
 8009808:	4b19      	ldr	r3, [pc, #100]	; (8009870 <HAL_DMA_DeInit+0x13b4>)
 800980a:	4299      	cmp	r1, r3
 800980c:	d00b      	beq.n	8009826 <HAL_DMA_DeInit+0x136a>
 800980e:	687b      	ldr	r3, [r7, #4]
 8009810:	681b      	ldr	r3, [r3, #0]
 8009812:	4619      	mov	r1, r3
 8009814:	4b17      	ldr	r3, [pc, #92]	; (8009874 <HAL_DMA_DeInit+0x13b8>)
 8009816:	4299      	cmp	r1, r3
 8009818:	d102      	bne.n	8009820 <HAL_DMA_DeInit+0x1364>
 800981a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800981e:	e03f      	b.n	80098a0 <HAL_DMA_DeInit+0x13e4>
 8009820:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8009824:	e03c      	b.n	80098a0 <HAL_DMA_DeInit+0x13e4>
 8009826:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800982a:	e039      	b.n	80098a0 <HAL_DMA_DeInit+0x13e4>
 800982c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009830:	e036      	b.n	80098a0 <HAL_DMA_DeInit+0x13e4>
 8009832:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8009836:	e033      	b.n	80098a0 <HAL_DMA_DeInit+0x13e4>
 8009838:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800983c:	e030      	b.n	80098a0 <HAL_DMA_DeInit+0x13e4>
 800983e:	bf00      	nop
 8009840:	400260b8 	.word	0x400260b8
 8009844:	40026400 	.word	0x40026400
 8009848:	40026010 	.word	0x40026010
 800984c:	40026410 	.word	0x40026410
 8009850:	40026070 	.word	0x40026070
 8009854:	40026470 	.word	0x40026470
 8009858:	40026028 	.word	0x40026028
 800985c:	40026428 	.word	0x40026428
 8009860:	40026088 	.word	0x40026088
 8009864:	40026488 	.word	0x40026488
 8009868:	40026040 	.word	0x40026040
 800986c:	40026440 	.word	0x40026440
 8009870:	400260a0 	.word	0x400260a0
 8009874:	400264a0 	.word	0x400264a0
 8009878:	40026058 	.word	0x40026058
 800987c:	40026000 	.word	0x40026000
 8009880:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009884:	e00c      	b.n	80098a0 <HAL_DMA_DeInit+0x13e4>
 8009886:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800988a:	e009      	b.n	80098a0 <HAL_DMA_DeInit+0x13e4>
 800988c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009890:	e006      	b.n	80098a0 <HAL_DMA_DeInit+0x13e4>
 8009892:	2310      	movs	r3, #16
 8009894:	e004      	b.n	80098a0 <HAL_DMA_DeInit+0x13e4>
 8009896:	2310      	movs	r3, #16
 8009898:	e002      	b.n	80098a0 <HAL_DMA_DeInit+0x13e4>
 800989a:	2310      	movs	r3, #16
 800989c:	e000      	b.n	80098a0 <HAL_DMA_DeInit+0x13e4>
 800989e:	2310      	movs	r3, #16
 80098a0:	6093      	str	r3, [r2, #8]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80098a2:	687b      	ldr	r3, [r7, #4]
 80098a4:	2200      	movs	r2, #0
 80098a6:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;
 80098a8:	687b      	ldr	r3, [r7, #4]
 80098aa:	2200      	movs	r2, #0
 80098ac:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  /* Release Lock */
  __HAL_UNLOCK(hdma);
 80098b0:	687b      	ldr	r3, [r7, #4]
 80098b2:	2200      	movs	r2, #0
 80098b4:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return HAL_OK;
 80098b8:	2300      	movs	r3, #0
}
 80098ba:	4618      	mov	r0, r3
 80098bc:	370c      	adds	r7, #12
 80098be:	46bd      	mov	sp, r7
 80098c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80098c4:	4770      	bx	lr
 80098c6:	bf00      	nop

080098c8 <HAL_DMA_Start_IT>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 80098c8:	b580      	push	{r7, lr}
 80098ca:	b084      	sub	sp, #16
 80098cc:	af00      	add	r7, sp, #0
 80098ce:	60f8      	str	r0, [r7, #12]
 80098d0:	60b9      	str	r1, [r7, #8]
 80098d2:	607a      	str	r2, [r7, #4]
 80098d4:	603b      	str	r3, [r7, #0]
  /* Process locked */
  __HAL_LOCK(hdma);
 80098d6:	68fb      	ldr	r3, [r7, #12]
 80098d8:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 80098dc:	2b01      	cmp	r3, #1
 80098de:	d101      	bne.n	80098e4 <HAL_DMA_Start_IT+0x1c>
 80098e0:	2302      	movs	r3, #2
 80098e2:	e046      	b.n	8009972 <HAL_DMA_Start_IT+0xaa>
 80098e4:	68fb      	ldr	r3, [r7, #12]
 80098e6:	2201      	movs	r2, #1
 80098e8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 80098ec:	68fb      	ldr	r3, [r7, #12]
 80098ee:	2202      	movs	r2, #2
 80098f0:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

   /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 80098f4:	68fb      	ldr	r3, [r7, #12]
 80098f6:	681b      	ldr	r3, [r3, #0]
 80098f8:	68fa      	ldr	r2, [r7, #12]
 80098fa:	6812      	ldr	r2, [r2, #0]
 80098fc:	6812      	ldr	r2, [r2, #0]
 80098fe:	f022 0201 	bic.w	r2, r2, #1
 8009902:	601a      	str	r2, [r3, #0]

  /* Configure the source, destination address and the data length */
  DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 8009904:	68f8      	ldr	r0, [r7, #12]
 8009906:	68b9      	ldr	r1, [r7, #8]
 8009908:	687a      	ldr	r2, [r7, #4]
 800990a:	683b      	ldr	r3, [r7, #0]
 800990c:	f7fe fd3c 	bl	8008388 <DMA_SetConfig>

  /* Enable the transfer complete interrupt */
  __HAL_DMA_ENABLE_IT(hdma, DMA_IT_TC);
 8009910:	68fb      	ldr	r3, [r7, #12]
 8009912:	681b      	ldr	r3, [r3, #0]
 8009914:	68fa      	ldr	r2, [r7, #12]
 8009916:	6812      	ldr	r2, [r2, #0]
 8009918:	6812      	ldr	r2, [r2, #0]
 800991a:	f042 0210 	orr.w	r2, r2, #16
 800991e:	601a      	str	r2, [r3, #0]

  /* Enable the Half transfer complete interrupt */
  __HAL_DMA_ENABLE_IT(hdma, DMA_IT_HT);  
 8009920:	68fb      	ldr	r3, [r7, #12]
 8009922:	681b      	ldr	r3, [r3, #0]
 8009924:	68fa      	ldr	r2, [r7, #12]
 8009926:	6812      	ldr	r2, [r2, #0]
 8009928:	6812      	ldr	r2, [r2, #0]
 800992a:	f042 0208 	orr.w	r2, r2, #8
 800992e:	601a      	str	r2, [r3, #0]

  /* Enable the transfer Error interrupt */
  __HAL_DMA_ENABLE_IT(hdma, DMA_IT_TE);
 8009930:	68fb      	ldr	r3, [r7, #12]
 8009932:	681b      	ldr	r3, [r3, #0]
 8009934:	68fa      	ldr	r2, [r7, #12]
 8009936:	6812      	ldr	r2, [r2, #0]
 8009938:	6812      	ldr	r2, [r2, #0]
 800993a:	f042 0204 	orr.w	r2, r2, #4
 800993e:	601a      	str	r2, [r3, #0]

  /* Enable the FIFO Error interrupt */
  __HAL_DMA_ENABLE_IT(hdma, DMA_IT_FE);
 8009940:	68fb      	ldr	r3, [r7, #12]
 8009942:	681b      	ldr	r3, [r3, #0]
 8009944:	68fa      	ldr	r2, [r7, #12]
 8009946:	6812      	ldr	r2, [r2, #0]
 8009948:	6952      	ldr	r2, [r2, #20]
 800994a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800994e:	615a      	str	r2, [r3, #20]

  /* Enable the direct mode Error interrupt */
  __HAL_DMA_ENABLE_IT(hdma, DMA_IT_DME);
 8009950:	68fb      	ldr	r3, [r7, #12]
 8009952:	681b      	ldr	r3, [r3, #0]
 8009954:	68fa      	ldr	r2, [r7, #12]
 8009956:	6812      	ldr	r2, [r2, #0]
 8009958:	6812      	ldr	r2, [r2, #0]
 800995a:	f042 0202 	orr.w	r2, r2, #2
 800995e:	601a      	str	r2, [r3, #0]

   /* Enable the Peripheral */
  __HAL_DMA_ENABLE(hdma);
 8009960:	68fb      	ldr	r3, [r7, #12]
 8009962:	681b      	ldr	r3, [r3, #0]
 8009964:	68fa      	ldr	r2, [r7, #12]
 8009966:	6812      	ldr	r2, [r2, #0]
 8009968:	6812      	ldr	r2, [r2, #0]
 800996a:	f042 0201 	orr.w	r2, r2, #1
 800996e:	601a      	str	r2, [r3, #0]

  return HAL_OK;
 8009970:	2300      	movs	r3, #0
} 
 8009972:	4618      	mov	r0, r3
 8009974:	3710      	adds	r7, #16
 8009976:	46bd      	mov	sp, r7
 8009978:	bd80      	pop	{r7, pc}
 800997a:	bf00      	nop

0800997c <HAL_DMA_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 800997c:	b580      	push	{r7, lr}
 800997e:	b082      	sub	sp, #8
 8009980:	af00      	add	r7, sp, #0
 8009982:	6078      	str	r0, [r7, #4]
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8009984:	687b      	ldr	r3, [r7, #4]
 8009986:	681b      	ldr	r3, [r3, #0]
 8009988:	461a      	mov	r2, r3
 800998a:	4b78      	ldr	r3, [pc, #480]	; (8009b6c <HAL_DMA_IRQHandler+0x1f0>)
 800998c:	429a      	cmp	r2, r3
 800998e:	d972      	bls.n	8009a76 <HAL_DMA_IRQHandler+0xfa>
 8009990:	4b77      	ldr	r3, [pc, #476]	; (8009b70 <HAL_DMA_IRQHandler+0x1f4>)
 8009992:	685a      	ldr	r2, [r3, #4]
 8009994:	687b      	ldr	r3, [r7, #4]
 8009996:	681b      	ldr	r3, [r3, #0]
 8009998:	4619      	mov	r1, r3
 800999a:	4b76      	ldr	r3, [pc, #472]	; (8009b74 <HAL_DMA_IRQHandler+0x1f8>)
 800999c:	4299      	cmp	r1, r3
 800999e:	d062      	beq.n	8009a66 <HAL_DMA_IRQHandler+0xea>
 80099a0:	687b      	ldr	r3, [r7, #4]
 80099a2:	681b      	ldr	r3, [r3, #0]
 80099a4:	4619      	mov	r1, r3
 80099a6:	4b74      	ldr	r3, [pc, #464]	; (8009b78 <HAL_DMA_IRQHandler+0x1fc>)
 80099a8:	4299      	cmp	r1, r3
 80099aa:	d05a      	beq.n	8009a62 <HAL_DMA_IRQHandler+0xe6>
 80099ac:	687b      	ldr	r3, [r7, #4]
 80099ae:	681b      	ldr	r3, [r3, #0]
 80099b0:	4619      	mov	r1, r3
 80099b2:	4b72      	ldr	r3, [pc, #456]	; (8009b7c <HAL_DMA_IRQHandler+0x200>)
 80099b4:	4299      	cmp	r1, r3
 80099b6:	d052      	beq.n	8009a5e <HAL_DMA_IRQHandler+0xe2>
 80099b8:	687b      	ldr	r3, [r7, #4]
 80099ba:	681b      	ldr	r3, [r3, #0]
 80099bc:	4619      	mov	r1, r3
 80099be:	4b70      	ldr	r3, [pc, #448]	; (8009b80 <HAL_DMA_IRQHandler+0x204>)
 80099c0:	4299      	cmp	r1, r3
 80099c2:	d04a      	beq.n	8009a5a <HAL_DMA_IRQHandler+0xde>
 80099c4:	687b      	ldr	r3, [r7, #4]
 80099c6:	681b      	ldr	r3, [r3, #0]
 80099c8:	4619      	mov	r1, r3
 80099ca:	4b6e      	ldr	r3, [pc, #440]	; (8009b84 <HAL_DMA_IRQHandler+0x208>)
 80099cc:	4299      	cmp	r1, r3
 80099ce:	d041      	beq.n	8009a54 <HAL_DMA_IRQHandler+0xd8>
 80099d0:	687b      	ldr	r3, [r7, #4]
 80099d2:	681b      	ldr	r3, [r3, #0]
 80099d4:	4619      	mov	r1, r3
 80099d6:	4b6c      	ldr	r3, [pc, #432]	; (8009b88 <HAL_DMA_IRQHandler+0x20c>)
 80099d8:	4299      	cmp	r1, r3
 80099da:	d038      	beq.n	8009a4e <HAL_DMA_IRQHandler+0xd2>
 80099dc:	687b      	ldr	r3, [r7, #4]
 80099de:	681b      	ldr	r3, [r3, #0]
 80099e0:	4619      	mov	r1, r3
 80099e2:	4b6a      	ldr	r3, [pc, #424]	; (8009b8c <HAL_DMA_IRQHandler+0x210>)
 80099e4:	4299      	cmp	r1, r3
 80099e6:	d02f      	beq.n	8009a48 <HAL_DMA_IRQHandler+0xcc>
 80099e8:	687b      	ldr	r3, [r7, #4]
 80099ea:	681b      	ldr	r3, [r3, #0]
 80099ec:	4619      	mov	r1, r3
 80099ee:	4b68      	ldr	r3, [pc, #416]	; (8009b90 <HAL_DMA_IRQHandler+0x214>)
 80099f0:	4299      	cmp	r1, r3
 80099f2:	d026      	beq.n	8009a42 <HAL_DMA_IRQHandler+0xc6>
 80099f4:	687b      	ldr	r3, [r7, #4]
 80099f6:	681b      	ldr	r3, [r3, #0]
 80099f8:	4619      	mov	r1, r3
 80099fa:	4b66      	ldr	r3, [pc, #408]	; (8009b94 <HAL_DMA_IRQHandler+0x218>)
 80099fc:	4299      	cmp	r1, r3
 80099fe:	d01d      	beq.n	8009a3c <HAL_DMA_IRQHandler+0xc0>
 8009a00:	687b      	ldr	r3, [r7, #4]
 8009a02:	681b      	ldr	r3, [r3, #0]
 8009a04:	4619      	mov	r1, r3
 8009a06:	4b64      	ldr	r3, [pc, #400]	; (8009b98 <HAL_DMA_IRQHandler+0x21c>)
 8009a08:	4299      	cmp	r1, r3
 8009a0a:	d014      	beq.n	8009a36 <HAL_DMA_IRQHandler+0xba>
 8009a0c:	687b      	ldr	r3, [r7, #4]
 8009a0e:	681b      	ldr	r3, [r3, #0]
 8009a10:	4619      	mov	r1, r3
 8009a12:	4b62      	ldr	r3, [pc, #392]	; (8009b9c <HAL_DMA_IRQHandler+0x220>)
 8009a14:	4299      	cmp	r1, r3
 8009a16:	d00b      	beq.n	8009a30 <HAL_DMA_IRQHandler+0xb4>
 8009a18:	687b      	ldr	r3, [r7, #4]
 8009a1a:	681b      	ldr	r3, [r3, #0]
 8009a1c:	4619      	mov	r1, r3
 8009a1e:	4b60      	ldr	r3, [pc, #384]	; (8009ba0 <HAL_DMA_IRQHandler+0x224>)
 8009a20:	4299      	cmp	r1, r3
 8009a22:	d102      	bne.n	8009a2a <HAL_DMA_IRQHandler+0xae>
 8009a24:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009a28:	e01e      	b.n	8009a68 <HAL_DMA_IRQHandler+0xec>
 8009a2a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8009a2e:	e01b      	b.n	8009a68 <HAL_DMA_IRQHandler+0xec>
 8009a30:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009a34:	e018      	b.n	8009a68 <HAL_DMA_IRQHandler+0xec>
 8009a36:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009a3a:	e015      	b.n	8009a68 <HAL_DMA_IRQHandler+0xec>
 8009a3c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009a40:	e012      	b.n	8009a68 <HAL_DMA_IRQHandler+0xec>
 8009a42:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009a46:	e00f      	b.n	8009a68 <HAL_DMA_IRQHandler+0xec>
 8009a48:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009a4c:	e00c      	b.n	8009a68 <HAL_DMA_IRQHandler+0xec>
 8009a4e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009a52:	e009      	b.n	8009a68 <HAL_DMA_IRQHandler+0xec>
 8009a54:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009a58:	e006      	b.n	8009a68 <HAL_DMA_IRQHandler+0xec>
 8009a5a:	2308      	movs	r3, #8
 8009a5c:	e004      	b.n	8009a68 <HAL_DMA_IRQHandler+0xec>
 8009a5e:	2308      	movs	r3, #8
 8009a60:	e002      	b.n	8009a68 <HAL_DMA_IRQHandler+0xec>
 8009a62:	2308      	movs	r3, #8
 8009a64:	e000      	b.n	8009a68 <HAL_DMA_IRQHandler+0xec>
 8009a66:	2308      	movs	r3, #8
 8009a68:	4013      	ands	r3, r2
 8009a6a:	2b00      	cmp	r3, #0
 8009a6c:	bf14      	ite	ne
 8009a6e:	2301      	movne	r3, #1
 8009a70:	2300      	moveq	r3, #0
 8009a72:	b2db      	uxtb	r3, r3
 8009a74:	e19f      	b.n	8009db6 <HAL_DMA_IRQHandler+0x43a>
 8009a76:	687b      	ldr	r3, [r7, #4]
 8009a78:	681b      	ldr	r3, [r3, #0]
 8009a7a:	461a      	mov	r2, r3
 8009a7c:	4b49      	ldr	r3, [pc, #292]	; (8009ba4 <HAL_DMA_IRQHandler+0x228>)
 8009a7e:	429a      	cmp	r2, r3
 8009a80:	f240 8092 	bls.w	8009ba8 <HAL_DMA_IRQHandler+0x22c>
 8009a84:	4b3a      	ldr	r3, [pc, #232]	; (8009b70 <HAL_DMA_IRQHandler+0x1f4>)
 8009a86:	681a      	ldr	r2, [r3, #0]
 8009a88:	687b      	ldr	r3, [r7, #4]
 8009a8a:	681b      	ldr	r3, [r3, #0]
 8009a8c:	4619      	mov	r1, r3
 8009a8e:	4b39      	ldr	r3, [pc, #228]	; (8009b74 <HAL_DMA_IRQHandler+0x1f8>)
 8009a90:	4299      	cmp	r1, r3
 8009a92:	d062      	beq.n	8009b5a <HAL_DMA_IRQHandler+0x1de>
 8009a94:	687b      	ldr	r3, [r7, #4]
 8009a96:	681b      	ldr	r3, [r3, #0]
 8009a98:	4619      	mov	r1, r3
 8009a9a:	4b37      	ldr	r3, [pc, #220]	; (8009b78 <HAL_DMA_IRQHandler+0x1fc>)
 8009a9c:	4299      	cmp	r1, r3
 8009a9e:	d05a      	beq.n	8009b56 <HAL_DMA_IRQHandler+0x1da>
 8009aa0:	687b      	ldr	r3, [r7, #4]
 8009aa2:	681b      	ldr	r3, [r3, #0]
 8009aa4:	4619      	mov	r1, r3
 8009aa6:	4b35      	ldr	r3, [pc, #212]	; (8009b7c <HAL_DMA_IRQHandler+0x200>)
 8009aa8:	4299      	cmp	r1, r3
 8009aaa:	d052      	beq.n	8009b52 <HAL_DMA_IRQHandler+0x1d6>
 8009aac:	687b      	ldr	r3, [r7, #4]
 8009aae:	681b      	ldr	r3, [r3, #0]
 8009ab0:	4619      	mov	r1, r3
 8009ab2:	4b33      	ldr	r3, [pc, #204]	; (8009b80 <HAL_DMA_IRQHandler+0x204>)
 8009ab4:	4299      	cmp	r1, r3
 8009ab6:	d04a      	beq.n	8009b4e <HAL_DMA_IRQHandler+0x1d2>
 8009ab8:	687b      	ldr	r3, [r7, #4]
 8009aba:	681b      	ldr	r3, [r3, #0]
 8009abc:	4619      	mov	r1, r3
 8009abe:	4b31      	ldr	r3, [pc, #196]	; (8009b84 <HAL_DMA_IRQHandler+0x208>)
 8009ac0:	4299      	cmp	r1, r3
 8009ac2:	d041      	beq.n	8009b48 <HAL_DMA_IRQHandler+0x1cc>
 8009ac4:	687b      	ldr	r3, [r7, #4]
 8009ac6:	681b      	ldr	r3, [r3, #0]
 8009ac8:	4619      	mov	r1, r3
 8009aca:	4b2f      	ldr	r3, [pc, #188]	; (8009b88 <HAL_DMA_IRQHandler+0x20c>)
 8009acc:	4299      	cmp	r1, r3
 8009ace:	d038      	beq.n	8009b42 <HAL_DMA_IRQHandler+0x1c6>
 8009ad0:	687b      	ldr	r3, [r7, #4]
 8009ad2:	681b      	ldr	r3, [r3, #0]
 8009ad4:	4619      	mov	r1, r3
 8009ad6:	4b2d      	ldr	r3, [pc, #180]	; (8009b8c <HAL_DMA_IRQHandler+0x210>)
 8009ad8:	4299      	cmp	r1, r3
 8009ada:	d02f      	beq.n	8009b3c <HAL_DMA_IRQHandler+0x1c0>
 8009adc:	687b      	ldr	r3, [r7, #4]
 8009ade:	681b      	ldr	r3, [r3, #0]
 8009ae0:	4619      	mov	r1, r3
 8009ae2:	4b2b      	ldr	r3, [pc, #172]	; (8009b90 <HAL_DMA_IRQHandler+0x214>)
 8009ae4:	4299      	cmp	r1, r3
 8009ae6:	d026      	beq.n	8009b36 <HAL_DMA_IRQHandler+0x1ba>
 8009ae8:	687b      	ldr	r3, [r7, #4]
 8009aea:	681b      	ldr	r3, [r3, #0]
 8009aec:	4619      	mov	r1, r3
 8009aee:	4b29      	ldr	r3, [pc, #164]	; (8009b94 <HAL_DMA_IRQHandler+0x218>)
 8009af0:	4299      	cmp	r1, r3
 8009af2:	d01d      	beq.n	8009b30 <HAL_DMA_IRQHandler+0x1b4>
 8009af4:	687b      	ldr	r3, [r7, #4]
 8009af6:	681b      	ldr	r3, [r3, #0]
 8009af8:	4619      	mov	r1, r3
 8009afa:	4b27      	ldr	r3, [pc, #156]	; (8009b98 <HAL_DMA_IRQHandler+0x21c>)
 8009afc:	4299      	cmp	r1, r3
 8009afe:	d014      	beq.n	8009b2a <HAL_DMA_IRQHandler+0x1ae>
 8009b00:	687b      	ldr	r3, [r7, #4]
 8009b02:	681b      	ldr	r3, [r3, #0]
 8009b04:	4619      	mov	r1, r3
 8009b06:	4b25      	ldr	r3, [pc, #148]	; (8009b9c <HAL_DMA_IRQHandler+0x220>)
 8009b08:	4299      	cmp	r1, r3
 8009b0a:	d00b      	beq.n	8009b24 <HAL_DMA_IRQHandler+0x1a8>
 8009b0c:	687b      	ldr	r3, [r7, #4]
 8009b0e:	681b      	ldr	r3, [r3, #0]
 8009b10:	4619      	mov	r1, r3
 8009b12:	4b23      	ldr	r3, [pc, #140]	; (8009ba0 <HAL_DMA_IRQHandler+0x224>)
 8009b14:	4299      	cmp	r1, r3
 8009b16:	d102      	bne.n	8009b1e <HAL_DMA_IRQHandler+0x1a2>
 8009b18:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009b1c:	e01e      	b.n	8009b5c <HAL_DMA_IRQHandler+0x1e0>
 8009b1e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8009b22:	e01b      	b.n	8009b5c <HAL_DMA_IRQHandler+0x1e0>
 8009b24:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009b28:	e018      	b.n	8009b5c <HAL_DMA_IRQHandler+0x1e0>
 8009b2a:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009b2e:	e015      	b.n	8009b5c <HAL_DMA_IRQHandler+0x1e0>
 8009b30:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009b34:	e012      	b.n	8009b5c <HAL_DMA_IRQHandler+0x1e0>
 8009b36:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009b3a:	e00f      	b.n	8009b5c <HAL_DMA_IRQHandler+0x1e0>
 8009b3c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009b40:	e00c      	b.n	8009b5c <HAL_DMA_IRQHandler+0x1e0>
 8009b42:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009b46:	e009      	b.n	8009b5c <HAL_DMA_IRQHandler+0x1e0>
 8009b48:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009b4c:	e006      	b.n	8009b5c <HAL_DMA_IRQHandler+0x1e0>
 8009b4e:	2308      	movs	r3, #8
 8009b50:	e004      	b.n	8009b5c <HAL_DMA_IRQHandler+0x1e0>
 8009b52:	2308      	movs	r3, #8
 8009b54:	e002      	b.n	8009b5c <HAL_DMA_IRQHandler+0x1e0>
 8009b56:	2308      	movs	r3, #8
 8009b58:	e000      	b.n	8009b5c <HAL_DMA_IRQHandler+0x1e0>
 8009b5a:	2308      	movs	r3, #8
 8009b5c:	4013      	ands	r3, r2
 8009b5e:	2b00      	cmp	r3, #0
 8009b60:	bf14      	ite	ne
 8009b62:	2301      	movne	r3, #1
 8009b64:	2300      	moveq	r3, #0
 8009b66:	b2db      	uxtb	r3, r3
 8009b68:	e125      	b.n	8009db6 <HAL_DMA_IRQHandler+0x43a>
 8009b6a:	bf00      	nop
 8009b6c:	40026458 	.word	0x40026458
 8009b70:	40026400 	.word	0x40026400
 8009b74:	40026010 	.word	0x40026010
 8009b78:	40026410 	.word	0x40026410
 8009b7c:	40026070 	.word	0x40026070
 8009b80:	40026470 	.word	0x40026470
 8009b84:	40026028 	.word	0x40026028
 8009b88:	40026428 	.word	0x40026428
 8009b8c:	40026088 	.word	0x40026088
 8009b90:	40026488 	.word	0x40026488
 8009b94:	40026040 	.word	0x40026040
 8009b98:	40026440 	.word	0x40026440
 8009b9c:	400260a0 	.word	0x400260a0
 8009ba0:	400264a0 	.word	0x400264a0
 8009ba4:	400260b8 	.word	0x400260b8
 8009ba8:	687b      	ldr	r3, [r7, #4]
 8009baa:	681b      	ldr	r3, [r3, #0]
 8009bac:	461a      	mov	r2, r3
 8009bae:	4b70      	ldr	r3, [pc, #448]	; (8009d70 <HAL_DMA_IRQHandler+0x3f4>)
 8009bb0:	429a      	cmp	r2, r3
 8009bb2:	d972      	bls.n	8009c9a <HAL_DMA_IRQHandler+0x31e>
 8009bb4:	4b6f      	ldr	r3, [pc, #444]	; (8009d74 <HAL_DMA_IRQHandler+0x3f8>)
 8009bb6:	685a      	ldr	r2, [r3, #4]
 8009bb8:	687b      	ldr	r3, [r7, #4]
 8009bba:	681b      	ldr	r3, [r3, #0]
 8009bbc:	4619      	mov	r1, r3
 8009bbe:	4b6e      	ldr	r3, [pc, #440]	; (8009d78 <HAL_DMA_IRQHandler+0x3fc>)
 8009bc0:	4299      	cmp	r1, r3
 8009bc2:	d062      	beq.n	8009c8a <HAL_DMA_IRQHandler+0x30e>
 8009bc4:	687b      	ldr	r3, [r7, #4]
 8009bc6:	681b      	ldr	r3, [r3, #0]
 8009bc8:	4619      	mov	r1, r3
 8009bca:	4b6c      	ldr	r3, [pc, #432]	; (8009d7c <HAL_DMA_IRQHandler+0x400>)
 8009bcc:	4299      	cmp	r1, r3
 8009bce:	d05a      	beq.n	8009c86 <HAL_DMA_IRQHandler+0x30a>
 8009bd0:	687b      	ldr	r3, [r7, #4]
 8009bd2:	681b      	ldr	r3, [r3, #0]
 8009bd4:	4619      	mov	r1, r3
 8009bd6:	4b6a      	ldr	r3, [pc, #424]	; (8009d80 <HAL_DMA_IRQHandler+0x404>)
 8009bd8:	4299      	cmp	r1, r3
 8009bda:	d052      	beq.n	8009c82 <HAL_DMA_IRQHandler+0x306>
 8009bdc:	687b      	ldr	r3, [r7, #4]
 8009bde:	681b      	ldr	r3, [r3, #0]
 8009be0:	4619      	mov	r1, r3
 8009be2:	4b68      	ldr	r3, [pc, #416]	; (8009d84 <HAL_DMA_IRQHandler+0x408>)
 8009be4:	4299      	cmp	r1, r3
 8009be6:	d04a      	beq.n	8009c7e <HAL_DMA_IRQHandler+0x302>
 8009be8:	687b      	ldr	r3, [r7, #4]
 8009bea:	681b      	ldr	r3, [r3, #0]
 8009bec:	4619      	mov	r1, r3
 8009bee:	4b66      	ldr	r3, [pc, #408]	; (8009d88 <HAL_DMA_IRQHandler+0x40c>)
 8009bf0:	4299      	cmp	r1, r3
 8009bf2:	d041      	beq.n	8009c78 <HAL_DMA_IRQHandler+0x2fc>
 8009bf4:	687b      	ldr	r3, [r7, #4]
 8009bf6:	681b      	ldr	r3, [r3, #0]
 8009bf8:	4619      	mov	r1, r3
 8009bfa:	4b64      	ldr	r3, [pc, #400]	; (8009d8c <HAL_DMA_IRQHandler+0x410>)
 8009bfc:	4299      	cmp	r1, r3
 8009bfe:	d038      	beq.n	8009c72 <HAL_DMA_IRQHandler+0x2f6>
 8009c00:	687b      	ldr	r3, [r7, #4]
 8009c02:	681b      	ldr	r3, [r3, #0]
 8009c04:	4619      	mov	r1, r3
 8009c06:	4b62      	ldr	r3, [pc, #392]	; (8009d90 <HAL_DMA_IRQHandler+0x414>)
 8009c08:	4299      	cmp	r1, r3
 8009c0a:	d02f      	beq.n	8009c6c <HAL_DMA_IRQHandler+0x2f0>
 8009c0c:	687b      	ldr	r3, [r7, #4]
 8009c0e:	681b      	ldr	r3, [r3, #0]
 8009c10:	4619      	mov	r1, r3
 8009c12:	4b60      	ldr	r3, [pc, #384]	; (8009d94 <HAL_DMA_IRQHandler+0x418>)
 8009c14:	4299      	cmp	r1, r3
 8009c16:	d026      	beq.n	8009c66 <HAL_DMA_IRQHandler+0x2ea>
 8009c18:	687b      	ldr	r3, [r7, #4]
 8009c1a:	681b      	ldr	r3, [r3, #0]
 8009c1c:	4619      	mov	r1, r3
 8009c1e:	4b5e      	ldr	r3, [pc, #376]	; (8009d98 <HAL_DMA_IRQHandler+0x41c>)
 8009c20:	4299      	cmp	r1, r3
 8009c22:	d01d      	beq.n	8009c60 <HAL_DMA_IRQHandler+0x2e4>
 8009c24:	687b      	ldr	r3, [r7, #4]
 8009c26:	681b      	ldr	r3, [r3, #0]
 8009c28:	4619      	mov	r1, r3
 8009c2a:	4b5c      	ldr	r3, [pc, #368]	; (8009d9c <HAL_DMA_IRQHandler+0x420>)
 8009c2c:	4299      	cmp	r1, r3
 8009c2e:	d014      	beq.n	8009c5a <HAL_DMA_IRQHandler+0x2de>
 8009c30:	687b      	ldr	r3, [r7, #4]
 8009c32:	681b      	ldr	r3, [r3, #0]
 8009c34:	4619      	mov	r1, r3
 8009c36:	4b5a      	ldr	r3, [pc, #360]	; (8009da0 <HAL_DMA_IRQHandler+0x424>)
 8009c38:	4299      	cmp	r1, r3
 8009c3a:	d00b      	beq.n	8009c54 <HAL_DMA_IRQHandler+0x2d8>
 8009c3c:	687b      	ldr	r3, [r7, #4]
 8009c3e:	681b      	ldr	r3, [r3, #0]
 8009c40:	4619      	mov	r1, r3
 8009c42:	4b58      	ldr	r3, [pc, #352]	; (8009da4 <HAL_DMA_IRQHandler+0x428>)
 8009c44:	4299      	cmp	r1, r3
 8009c46:	d102      	bne.n	8009c4e <HAL_DMA_IRQHandler+0x2d2>
 8009c48:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009c4c:	e01e      	b.n	8009c8c <HAL_DMA_IRQHandler+0x310>
 8009c4e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8009c52:	e01b      	b.n	8009c8c <HAL_DMA_IRQHandler+0x310>
 8009c54:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009c58:	e018      	b.n	8009c8c <HAL_DMA_IRQHandler+0x310>
 8009c5a:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009c5e:	e015      	b.n	8009c8c <HAL_DMA_IRQHandler+0x310>
 8009c60:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009c64:	e012      	b.n	8009c8c <HAL_DMA_IRQHandler+0x310>
 8009c66:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009c6a:	e00f      	b.n	8009c8c <HAL_DMA_IRQHandler+0x310>
 8009c6c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009c70:	e00c      	b.n	8009c8c <HAL_DMA_IRQHandler+0x310>
 8009c72:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009c76:	e009      	b.n	8009c8c <HAL_DMA_IRQHandler+0x310>
 8009c78:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009c7c:	e006      	b.n	8009c8c <HAL_DMA_IRQHandler+0x310>
 8009c7e:	2308      	movs	r3, #8
 8009c80:	e004      	b.n	8009c8c <HAL_DMA_IRQHandler+0x310>
 8009c82:	2308      	movs	r3, #8
 8009c84:	e002      	b.n	8009c8c <HAL_DMA_IRQHandler+0x310>
 8009c86:	2308      	movs	r3, #8
 8009c88:	e000      	b.n	8009c8c <HAL_DMA_IRQHandler+0x310>
 8009c8a:	2308      	movs	r3, #8
 8009c8c:	4013      	ands	r3, r2
 8009c8e:	2b00      	cmp	r3, #0
 8009c90:	bf14      	ite	ne
 8009c92:	2301      	movne	r3, #1
 8009c94:	2300      	moveq	r3, #0
 8009c96:	b2db      	uxtb	r3, r3
 8009c98:	e08d      	b.n	8009db6 <HAL_DMA_IRQHandler+0x43a>
 8009c9a:	4b36      	ldr	r3, [pc, #216]	; (8009d74 <HAL_DMA_IRQHandler+0x3f8>)
 8009c9c:	681a      	ldr	r2, [r3, #0]
 8009c9e:	687b      	ldr	r3, [r7, #4]
 8009ca0:	681b      	ldr	r3, [r3, #0]
 8009ca2:	4619      	mov	r1, r3
 8009ca4:	4b34      	ldr	r3, [pc, #208]	; (8009d78 <HAL_DMA_IRQHandler+0x3fc>)
 8009ca6:	4299      	cmp	r1, r3
 8009ca8:	d07e      	beq.n	8009da8 <HAL_DMA_IRQHandler+0x42c>
 8009caa:	687b      	ldr	r3, [r7, #4]
 8009cac:	681b      	ldr	r3, [r3, #0]
 8009cae:	4619      	mov	r1, r3
 8009cb0:	4b32      	ldr	r3, [pc, #200]	; (8009d7c <HAL_DMA_IRQHandler+0x400>)
 8009cb2:	4299      	cmp	r1, r3
 8009cb4:	d05a      	beq.n	8009d6c <HAL_DMA_IRQHandler+0x3f0>
 8009cb6:	687b      	ldr	r3, [r7, #4]
 8009cb8:	681b      	ldr	r3, [r3, #0]
 8009cba:	4619      	mov	r1, r3
 8009cbc:	4b30      	ldr	r3, [pc, #192]	; (8009d80 <HAL_DMA_IRQHandler+0x404>)
 8009cbe:	4299      	cmp	r1, r3
 8009cc0:	d052      	beq.n	8009d68 <HAL_DMA_IRQHandler+0x3ec>
 8009cc2:	687b      	ldr	r3, [r7, #4]
 8009cc4:	681b      	ldr	r3, [r3, #0]
 8009cc6:	4619      	mov	r1, r3
 8009cc8:	4b2e      	ldr	r3, [pc, #184]	; (8009d84 <HAL_DMA_IRQHandler+0x408>)
 8009cca:	4299      	cmp	r1, r3
 8009ccc:	d04a      	beq.n	8009d64 <HAL_DMA_IRQHandler+0x3e8>
 8009cce:	687b      	ldr	r3, [r7, #4]
 8009cd0:	681b      	ldr	r3, [r3, #0]
 8009cd2:	4619      	mov	r1, r3
 8009cd4:	4b2c      	ldr	r3, [pc, #176]	; (8009d88 <HAL_DMA_IRQHandler+0x40c>)
 8009cd6:	4299      	cmp	r1, r3
 8009cd8:	d041      	beq.n	8009d5e <HAL_DMA_IRQHandler+0x3e2>
 8009cda:	687b      	ldr	r3, [r7, #4]
 8009cdc:	681b      	ldr	r3, [r3, #0]
 8009cde:	4619      	mov	r1, r3
 8009ce0:	4b2a      	ldr	r3, [pc, #168]	; (8009d8c <HAL_DMA_IRQHandler+0x410>)
 8009ce2:	4299      	cmp	r1, r3
 8009ce4:	d038      	beq.n	8009d58 <HAL_DMA_IRQHandler+0x3dc>
 8009ce6:	687b      	ldr	r3, [r7, #4]
 8009ce8:	681b      	ldr	r3, [r3, #0]
 8009cea:	4619      	mov	r1, r3
 8009cec:	4b28      	ldr	r3, [pc, #160]	; (8009d90 <HAL_DMA_IRQHandler+0x414>)
 8009cee:	4299      	cmp	r1, r3
 8009cf0:	d02f      	beq.n	8009d52 <HAL_DMA_IRQHandler+0x3d6>
 8009cf2:	687b      	ldr	r3, [r7, #4]
 8009cf4:	681b      	ldr	r3, [r3, #0]
 8009cf6:	4619      	mov	r1, r3
 8009cf8:	4b26      	ldr	r3, [pc, #152]	; (8009d94 <HAL_DMA_IRQHandler+0x418>)
 8009cfa:	4299      	cmp	r1, r3
 8009cfc:	d026      	beq.n	8009d4c <HAL_DMA_IRQHandler+0x3d0>
 8009cfe:	687b      	ldr	r3, [r7, #4]
 8009d00:	681b      	ldr	r3, [r3, #0]
 8009d02:	4619      	mov	r1, r3
 8009d04:	4b24      	ldr	r3, [pc, #144]	; (8009d98 <HAL_DMA_IRQHandler+0x41c>)
 8009d06:	4299      	cmp	r1, r3
 8009d08:	d01d      	beq.n	8009d46 <HAL_DMA_IRQHandler+0x3ca>
 8009d0a:	687b      	ldr	r3, [r7, #4]
 8009d0c:	681b      	ldr	r3, [r3, #0]
 8009d0e:	4619      	mov	r1, r3
 8009d10:	4b22      	ldr	r3, [pc, #136]	; (8009d9c <HAL_DMA_IRQHandler+0x420>)
 8009d12:	4299      	cmp	r1, r3
 8009d14:	d014      	beq.n	8009d40 <HAL_DMA_IRQHandler+0x3c4>
 8009d16:	687b      	ldr	r3, [r7, #4]
 8009d18:	681b      	ldr	r3, [r3, #0]
 8009d1a:	4619      	mov	r1, r3
 8009d1c:	4b20      	ldr	r3, [pc, #128]	; (8009da0 <HAL_DMA_IRQHandler+0x424>)
 8009d1e:	4299      	cmp	r1, r3
 8009d20:	d00b      	beq.n	8009d3a <HAL_DMA_IRQHandler+0x3be>
 8009d22:	687b      	ldr	r3, [r7, #4]
 8009d24:	681b      	ldr	r3, [r3, #0]
 8009d26:	4619      	mov	r1, r3
 8009d28:	4b1e      	ldr	r3, [pc, #120]	; (8009da4 <HAL_DMA_IRQHandler+0x428>)
 8009d2a:	4299      	cmp	r1, r3
 8009d2c:	d102      	bne.n	8009d34 <HAL_DMA_IRQHandler+0x3b8>
 8009d2e:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009d32:	e03a      	b.n	8009daa <HAL_DMA_IRQHandler+0x42e>
 8009d34:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8009d38:	e037      	b.n	8009daa <HAL_DMA_IRQHandler+0x42e>
 8009d3a:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009d3e:	e034      	b.n	8009daa <HAL_DMA_IRQHandler+0x42e>
 8009d40:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009d44:	e031      	b.n	8009daa <HAL_DMA_IRQHandler+0x42e>
 8009d46:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009d4a:	e02e      	b.n	8009daa <HAL_DMA_IRQHandler+0x42e>
 8009d4c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009d50:	e02b      	b.n	8009daa <HAL_DMA_IRQHandler+0x42e>
 8009d52:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009d56:	e028      	b.n	8009daa <HAL_DMA_IRQHandler+0x42e>
 8009d58:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009d5c:	e025      	b.n	8009daa <HAL_DMA_IRQHandler+0x42e>
 8009d5e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009d62:	e022      	b.n	8009daa <HAL_DMA_IRQHandler+0x42e>
 8009d64:	2308      	movs	r3, #8
 8009d66:	e020      	b.n	8009daa <HAL_DMA_IRQHandler+0x42e>
 8009d68:	2308      	movs	r3, #8
 8009d6a:	e01e      	b.n	8009daa <HAL_DMA_IRQHandler+0x42e>
 8009d6c:	2308      	movs	r3, #8
 8009d6e:	e01c      	b.n	8009daa <HAL_DMA_IRQHandler+0x42e>
 8009d70:	40026058 	.word	0x40026058
 8009d74:	40026000 	.word	0x40026000
 8009d78:	40026010 	.word	0x40026010
 8009d7c:	40026410 	.word	0x40026410
 8009d80:	40026070 	.word	0x40026070
 8009d84:	40026470 	.word	0x40026470
 8009d88:	40026028 	.word	0x40026028
 8009d8c:	40026428 	.word	0x40026428
 8009d90:	40026088 	.word	0x40026088
 8009d94:	40026488 	.word	0x40026488
 8009d98:	40026040 	.word	0x40026040
 8009d9c:	40026440 	.word	0x40026440
 8009da0:	400260a0 	.word	0x400260a0
 8009da4:	400264a0 	.word	0x400264a0
 8009da8:	2308      	movs	r3, #8
 8009daa:	4013      	ands	r3, r2
 8009dac:	2b00      	cmp	r3, #0
 8009dae:	bf14      	ite	ne
 8009db0:	2301      	movne	r3, #1
 8009db2:	2300      	moveq	r3, #0
 8009db4:	b2db      	uxtb	r3, r3
 8009db6:	2b00      	cmp	r3, #0
 8009db8:	f000 8210 	beq.w	800a1dc <HAL_DMA_IRQHandler+0x860>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8009dbc:	687b      	ldr	r3, [r7, #4]
 8009dbe:	681b      	ldr	r3, [r3, #0]
 8009dc0:	681b      	ldr	r3, [r3, #0]
 8009dc2:	f003 0304 	and.w	r3, r3, #4
 8009dc6:	2b00      	cmp	r3, #0
 8009dc8:	f000 8208 	beq.w	800a1dc <HAL_DMA_IRQHandler+0x860>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
 8009dcc:	687b      	ldr	r3, [r7, #4]
 8009dce:	681b      	ldr	r3, [r3, #0]
 8009dd0:	687a      	ldr	r2, [r7, #4]
 8009dd2:	6812      	ldr	r2, [r2, #0]
 8009dd4:	6812      	ldr	r2, [r2, #0]
 8009dd6:	f022 0204 	bic.w	r2, r2, #4
 8009dda:	601a      	str	r2, [r3, #0]

      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8009ddc:	687b      	ldr	r3, [r7, #4]
 8009dde:	681b      	ldr	r3, [r3, #0]
 8009de0:	461a      	mov	r2, r3
 8009de2:	4ba0      	ldr	r3, [pc, #640]	; (800a064 <HAL_DMA_IRQHandler+0x6e8>)
 8009de4:	429a      	cmp	r2, r3
 8009de6:	d96c      	bls.n	8009ec2 <HAL_DMA_IRQHandler+0x546>
 8009de8:	4a9f      	ldr	r2, [pc, #636]	; (800a068 <HAL_DMA_IRQHandler+0x6ec>)
 8009dea:	687b      	ldr	r3, [r7, #4]
 8009dec:	681b      	ldr	r3, [r3, #0]
 8009dee:	4619      	mov	r1, r3
 8009df0:	4b9e      	ldr	r3, [pc, #632]	; (800a06c <HAL_DMA_IRQHandler+0x6f0>)
 8009df2:	4299      	cmp	r1, r3
 8009df4:	d062      	beq.n	8009ebc <HAL_DMA_IRQHandler+0x540>
 8009df6:	687b      	ldr	r3, [r7, #4]
 8009df8:	681b      	ldr	r3, [r3, #0]
 8009dfa:	4619      	mov	r1, r3
 8009dfc:	4b9c      	ldr	r3, [pc, #624]	; (800a070 <HAL_DMA_IRQHandler+0x6f4>)
 8009dfe:	4299      	cmp	r1, r3
 8009e00:	d05a      	beq.n	8009eb8 <HAL_DMA_IRQHandler+0x53c>
 8009e02:	687b      	ldr	r3, [r7, #4]
 8009e04:	681b      	ldr	r3, [r3, #0]
 8009e06:	4619      	mov	r1, r3
 8009e08:	4b9a      	ldr	r3, [pc, #616]	; (800a074 <HAL_DMA_IRQHandler+0x6f8>)
 8009e0a:	4299      	cmp	r1, r3
 8009e0c:	d052      	beq.n	8009eb4 <HAL_DMA_IRQHandler+0x538>
 8009e0e:	687b      	ldr	r3, [r7, #4]
 8009e10:	681b      	ldr	r3, [r3, #0]
 8009e12:	4619      	mov	r1, r3
 8009e14:	4b98      	ldr	r3, [pc, #608]	; (800a078 <HAL_DMA_IRQHandler+0x6fc>)
 8009e16:	4299      	cmp	r1, r3
 8009e18:	d04a      	beq.n	8009eb0 <HAL_DMA_IRQHandler+0x534>
 8009e1a:	687b      	ldr	r3, [r7, #4]
 8009e1c:	681b      	ldr	r3, [r3, #0]
 8009e1e:	4619      	mov	r1, r3
 8009e20:	4b96      	ldr	r3, [pc, #600]	; (800a07c <HAL_DMA_IRQHandler+0x700>)
 8009e22:	4299      	cmp	r1, r3
 8009e24:	d041      	beq.n	8009eaa <HAL_DMA_IRQHandler+0x52e>
 8009e26:	687b      	ldr	r3, [r7, #4]
 8009e28:	681b      	ldr	r3, [r3, #0]
 8009e2a:	4619      	mov	r1, r3
 8009e2c:	4b94      	ldr	r3, [pc, #592]	; (800a080 <HAL_DMA_IRQHandler+0x704>)
 8009e2e:	4299      	cmp	r1, r3
 8009e30:	d038      	beq.n	8009ea4 <HAL_DMA_IRQHandler+0x528>
 8009e32:	687b      	ldr	r3, [r7, #4]
 8009e34:	681b      	ldr	r3, [r3, #0]
 8009e36:	4619      	mov	r1, r3
 8009e38:	4b92      	ldr	r3, [pc, #584]	; (800a084 <HAL_DMA_IRQHandler+0x708>)
 8009e3a:	4299      	cmp	r1, r3
 8009e3c:	d02f      	beq.n	8009e9e <HAL_DMA_IRQHandler+0x522>
 8009e3e:	687b      	ldr	r3, [r7, #4]
 8009e40:	681b      	ldr	r3, [r3, #0]
 8009e42:	4619      	mov	r1, r3
 8009e44:	4b90      	ldr	r3, [pc, #576]	; (800a088 <HAL_DMA_IRQHandler+0x70c>)
 8009e46:	4299      	cmp	r1, r3
 8009e48:	d026      	beq.n	8009e98 <HAL_DMA_IRQHandler+0x51c>
 8009e4a:	687b      	ldr	r3, [r7, #4]
 8009e4c:	681b      	ldr	r3, [r3, #0]
 8009e4e:	4619      	mov	r1, r3
 8009e50:	4b8e      	ldr	r3, [pc, #568]	; (800a08c <HAL_DMA_IRQHandler+0x710>)
 8009e52:	4299      	cmp	r1, r3
 8009e54:	d01d      	beq.n	8009e92 <HAL_DMA_IRQHandler+0x516>
 8009e56:	687b      	ldr	r3, [r7, #4]
 8009e58:	681b      	ldr	r3, [r3, #0]
 8009e5a:	4619      	mov	r1, r3
 8009e5c:	4b8c      	ldr	r3, [pc, #560]	; (800a090 <HAL_DMA_IRQHandler+0x714>)
 8009e5e:	4299      	cmp	r1, r3
 8009e60:	d014      	beq.n	8009e8c <HAL_DMA_IRQHandler+0x510>
 8009e62:	687b      	ldr	r3, [r7, #4]
 8009e64:	681b      	ldr	r3, [r3, #0]
 8009e66:	4619      	mov	r1, r3
 8009e68:	4b8a      	ldr	r3, [pc, #552]	; (800a094 <HAL_DMA_IRQHandler+0x718>)
 8009e6a:	4299      	cmp	r1, r3
 8009e6c:	d00b      	beq.n	8009e86 <HAL_DMA_IRQHandler+0x50a>
 8009e6e:	687b      	ldr	r3, [r7, #4]
 8009e70:	681b      	ldr	r3, [r3, #0]
 8009e72:	4619      	mov	r1, r3
 8009e74:	4b88      	ldr	r3, [pc, #544]	; (800a098 <HAL_DMA_IRQHandler+0x71c>)
 8009e76:	4299      	cmp	r1, r3
 8009e78:	d102      	bne.n	8009e80 <HAL_DMA_IRQHandler+0x504>
 8009e7a:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009e7e:	e01e      	b.n	8009ebe <HAL_DMA_IRQHandler+0x542>
 8009e80:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8009e84:	e01b      	b.n	8009ebe <HAL_DMA_IRQHandler+0x542>
 8009e86:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009e8a:	e018      	b.n	8009ebe <HAL_DMA_IRQHandler+0x542>
 8009e8c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009e90:	e015      	b.n	8009ebe <HAL_DMA_IRQHandler+0x542>
 8009e92:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009e96:	e012      	b.n	8009ebe <HAL_DMA_IRQHandler+0x542>
 8009e98:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009e9c:	e00f      	b.n	8009ebe <HAL_DMA_IRQHandler+0x542>
 8009e9e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009ea2:	e00c      	b.n	8009ebe <HAL_DMA_IRQHandler+0x542>
 8009ea4:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009ea8:	e009      	b.n	8009ebe <HAL_DMA_IRQHandler+0x542>
 8009eaa:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009eae:	e006      	b.n	8009ebe <HAL_DMA_IRQHandler+0x542>
 8009eb0:	2308      	movs	r3, #8
 8009eb2:	e004      	b.n	8009ebe <HAL_DMA_IRQHandler+0x542>
 8009eb4:	2308      	movs	r3, #8
 8009eb6:	e002      	b.n	8009ebe <HAL_DMA_IRQHandler+0x542>
 8009eb8:	2308      	movs	r3, #8
 8009eba:	e000      	b.n	8009ebe <HAL_DMA_IRQHandler+0x542>
 8009ebc:	2308      	movs	r3, #8
 8009ebe:	60d3      	str	r3, [r2, #12]
 8009ec0:	e176      	b.n	800a1b0 <HAL_DMA_IRQHandler+0x834>
 8009ec2:	687b      	ldr	r3, [r7, #4]
 8009ec4:	681b      	ldr	r3, [r3, #0]
 8009ec6:	461a      	mov	r2, r3
 8009ec8:	4b74      	ldr	r3, [pc, #464]	; (800a09c <HAL_DMA_IRQHandler+0x720>)
 8009eca:	429a      	cmp	r2, r3
 8009ecc:	d96c      	bls.n	8009fa8 <HAL_DMA_IRQHandler+0x62c>
 8009ece:	4a66      	ldr	r2, [pc, #408]	; (800a068 <HAL_DMA_IRQHandler+0x6ec>)
 8009ed0:	687b      	ldr	r3, [r7, #4]
 8009ed2:	681b      	ldr	r3, [r3, #0]
 8009ed4:	4619      	mov	r1, r3
 8009ed6:	4b65      	ldr	r3, [pc, #404]	; (800a06c <HAL_DMA_IRQHandler+0x6f0>)
 8009ed8:	4299      	cmp	r1, r3
 8009eda:	d062      	beq.n	8009fa2 <HAL_DMA_IRQHandler+0x626>
 8009edc:	687b      	ldr	r3, [r7, #4]
 8009ede:	681b      	ldr	r3, [r3, #0]
 8009ee0:	4619      	mov	r1, r3
 8009ee2:	4b63      	ldr	r3, [pc, #396]	; (800a070 <HAL_DMA_IRQHandler+0x6f4>)
 8009ee4:	4299      	cmp	r1, r3
 8009ee6:	d05a      	beq.n	8009f9e <HAL_DMA_IRQHandler+0x622>
 8009ee8:	687b      	ldr	r3, [r7, #4]
 8009eea:	681b      	ldr	r3, [r3, #0]
 8009eec:	4619      	mov	r1, r3
 8009eee:	4b61      	ldr	r3, [pc, #388]	; (800a074 <HAL_DMA_IRQHandler+0x6f8>)
 8009ef0:	4299      	cmp	r1, r3
 8009ef2:	d052      	beq.n	8009f9a <HAL_DMA_IRQHandler+0x61e>
 8009ef4:	687b      	ldr	r3, [r7, #4]
 8009ef6:	681b      	ldr	r3, [r3, #0]
 8009ef8:	4619      	mov	r1, r3
 8009efa:	4b5f      	ldr	r3, [pc, #380]	; (800a078 <HAL_DMA_IRQHandler+0x6fc>)
 8009efc:	4299      	cmp	r1, r3
 8009efe:	d04a      	beq.n	8009f96 <HAL_DMA_IRQHandler+0x61a>
 8009f00:	687b      	ldr	r3, [r7, #4]
 8009f02:	681b      	ldr	r3, [r3, #0]
 8009f04:	4619      	mov	r1, r3
 8009f06:	4b5d      	ldr	r3, [pc, #372]	; (800a07c <HAL_DMA_IRQHandler+0x700>)
 8009f08:	4299      	cmp	r1, r3
 8009f0a:	d041      	beq.n	8009f90 <HAL_DMA_IRQHandler+0x614>
 8009f0c:	687b      	ldr	r3, [r7, #4]
 8009f0e:	681b      	ldr	r3, [r3, #0]
 8009f10:	4619      	mov	r1, r3
 8009f12:	4b5b      	ldr	r3, [pc, #364]	; (800a080 <HAL_DMA_IRQHandler+0x704>)
 8009f14:	4299      	cmp	r1, r3
 8009f16:	d038      	beq.n	8009f8a <HAL_DMA_IRQHandler+0x60e>
 8009f18:	687b      	ldr	r3, [r7, #4]
 8009f1a:	681b      	ldr	r3, [r3, #0]
 8009f1c:	4619      	mov	r1, r3
 8009f1e:	4b59      	ldr	r3, [pc, #356]	; (800a084 <HAL_DMA_IRQHandler+0x708>)
 8009f20:	4299      	cmp	r1, r3
 8009f22:	d02f      	beq.n	8009f84 <HAL_DMA_IRQHandler+0x608>
 8009f24:	687b      	ldr	r3, [r7, #4]
 8009f26:	681b      	ldr	r3, [r3, #0]
 8009f28:	4619      	mov	r1, r3
 8009f2a:	4b57      	ldr	r3, [pc, #348]	; (800a088 <HAL_DMA_IRQHandler+0x70c>)
 8009f2c:	4299      	cmp	r1, r3
 8009f2e:	d026      	beq.n	8009f7e <HAL_DMA_IRQHandler+0x602>
 8009f30:	687b      	ldr	r3, [r7, #4]
 8009f32:	681b      	ldr	r3, [r3, #0]
 8009f34:	4619      	mov	r1, r3
 8009f36:	4b55      	ldr	r3, [pc, #340]	; (800a08c <HAL_DMA_IRQHandler+0x710>)
 8009f38:	4299      	cmp	r1, r3
 8009f3a:	d01d      	beq.n	8009f78 <HAL_DMA_IRQHandler+0x5fc>
 8009f3c:	687b      	ldr	r3, [r7, #4]
 8009f3e:	681b      	ldr	r3, [r3, #0]
 8009f40:	4619      	mov	r1, r3
 8009f42:	4b53      	ldr	r3, [pc, #332]	; (800a090 <HAL_DMA_IRQHandler+0x714>)
 8009f44:	4299      	cmp	r1, r3
 8009f46:	d014      	beq.n	8009f72 <HAL_DMA_IRQHandler+0x5f6>
 8009f48:	687b      	ldr	r3, [r7, #4]
 8009f4a:	681b      	ldr	r3, [r3, #0]
 8009f4c:	4619      	mov	r1, r3
 8009f4e:	4b51      	ldr	r3, [pc, #324]	; (800a094 <HAL_DMA_IRQHandler+0x718>)
 8009f50:	4299      	cmp	r1, r3
 8009f52:	d00b      	beq.n	8009f6c <HAL_DMA_IRQHandler+0x5f0>
 8009f54:	687b      	ldr	r3, [r7, #4]
 8009f56:	681b      	ldr	r3, [r3, #0]
 8009f58:	4619      	mov	r1, r3
 8009f5a:	4b4f      	ldr	r3, [pc, #316]	; (800a098 <HAL_DMA_IRQHandler+0x71c>)
 8009f5c:	4299      	cmp	r1, r3
 8009f5e:	d102      	bne.n	8009f66 <HAL_DMA_IRQHandler+0x5ea>
 8009f60:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009f64:	e01e      	b.n	8009fa4 <HAL_DMA_IRQHandler+0x628>
 8009f66:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8009f6a:	e01b      	b.n	8009fa4 <HAL_DMA_IRQHandler+0x628>
 8009f6c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009f70:	e018      	b.n	8009fa4 <HAL_DMA_IRQHandler+0x628>
 8009f72:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009f76:	e015      	b.n	8009fa4 <HAL_DMA_IRQHandler+0x628>
 8009f78:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8009f7c:	e012      	b.n	8009fa4 <HAL_DMA_IRQHandler+0x628>
 8009f7e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009f82:	e00f      	b.n	8009fa4 <HAL_DMA_IRQHandler+0x628>
 8009f84:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009f88:	e00c      	b.n	8009fa4 <HAL_DMA_IRQHandler+0x628>
 8009f8a:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009f8e:	e009      	b.n	8009fa4 <HAL_DMA_IRQHandler+0x628>
 8009f90:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009f94:	e006      	b.n	8009fa4 <HAL_DMA_IRQHandler+0x628>
 8009f96:	2308      	movs	r3, #8
 8009f98:	e004      	b.n	8009fa4 <HAL_DMA_IRQHandler+0x628>
 8009f9a:	2308      	movs	r3, #8
 8009f9c:	e002      	b.n	8009fa4 <HAL_DMA_IRQHandler+0x628>
 8009f9e:	2308      	movs	r3, #8
 8009fa0:	e000      	b.n	8009fa4 <HAL_DMA_IRQHandler+0x628>
 8009fa2:	2308      	movs	r3, #8
 8009fa4:	6093      	str	r3, [r2, #8]
 8009fa6:	e103      	b.n	800a1b0 <HAL_DMA_IRQHandler+0x834>
 8009fa8:	687b      	ldr	r3, [r7, #4]
 8009faa:	681b      	ldr	r3, [r3, #0]
 8009fac:	461a      	mov	r2, r3
 8009fae:	4b3c      	ldr	r3, [pc, #240]	; (800a0a0 <HAL_DMA_IRQHandler+0x724>)
 8009fb0:	429a      	cmp	r2, r3
 8009fb2:	f240 8091 	bls.w	800a0d8 <HAL_DMA_IRQHandler+0x75c>
 8009fb6:	4a3b      	ldr	r2, [pc, #236]	; (800a0a4 <HAL_DMA_IRQHandler+0x728>)
 8009fb8:	687b      	ldr	r3, [r7, #4]
 8009fba:	681b      	ldr	r3, [r3, #0]
 8009fbc:	4619      	mov	r1, r3
 8009fbe:	4b2b      	ldr	r3, [pc, #172]	; (800a06c <HAL_DMA_IRQHandler+0x6f0>)
 8009fc0:	4299      	cmp	r1, r3
 8009fc2:	f000 8086 	beq.w	800a0d2 <HAL_DMA_IRQHandler+0x756>
 8009fc6:	687b      	ldr	r3, [r7, #4]
 8009fc8:	681b      	ldr	r3, [r3, #0]
 8009fca:	4619      	mov	r1, r3
 8009fcc:	4b28      	ldr	r3, [pc, #160]	; (800a070 <HAL_DMA_IRQHandler+0x6f4>)
 8009fce:	4299      	cmp	r1, r3
 8009fd0:	d07d      	beq.n	800a0ce <HAL_DMA_IRQHandler+0x752>
 8009fd2:	687b      	ldr	r3, [r7, #4]
 8009fd4:	681b      	ldr	r3, [r3, #0]
 8009fd6:	4619      	mov	r1, r3
 8009fd8:	4b26      	ldr	r3, [pc, #152]	; (800a074 <HAL_DMA_IRQHandler+0x6f8>)
 8009fda:	4299      	cmp	r1, r3
 8009fdc:	d075      	beq.n	800a0ca <HAL_DMA_IRQHandler+0x74e>
 8009fde:	687b      	ldr	r3, [r7, #4]
 8009fe0:	681b      	ldr	r3, [r3, #0]
 8009fe2:	4619      	mov	r1, r3
 8009fe4:	4b24      	ldr	r3, [pc, #144]	; (800a078 <HAL_DMA_IRQHandler+0x6fc>)
 8009fe6:	4299      	cmp	r1, r3
 8009fe8:	d06d      	beq.n	800a0c6 <HAL_DMA_IRQHandler+0x74a>
 8009fea:	687b      	ldr	r3, [r7, #4]
 8009fec:	681b      	ldr	r3, [r3, #0]
 8009fee:	4619      	mov	r1, r3
 8009ff0:	4b22      	ldr	r3, [pc, #136]	; (800a07c <HAL_DMA_IRQHandler+0x700>)
 8009ff2:	4299      	cmp	r1, r3
 8009ff4:	d064      	beq.n	800a0c0 <HAL_DMA_IRQHandler+0x744>
 8009ff6:	687b      	ldr	r3, [r7, #4]
 8009ff8:	681b      	ldr	r3, [r3, #0]
 8009ffa:	4619      	mov	r1, r3
 8009ffc:	4b20      	ldr	r3, [pc, #128]	; (800a080 <HAL_DMA_IRQHandler+0x704>)
 8009ffe:	4299      	cmp	r1, r3
 800a000:	d05b      	beq.n	800a0ba <HAL_DMA_IRQHandler+0x73e>
 800a002:	687b      	ldr	r3, [r7, #4]
 800a004:	681b      	ldr	r3, [r3, #0]
 800a006:	4619      	mov	r1, r3
 800a008:	4b1e      	ldr	r3, [pc, #120]	; (800a084 <HAL_DMA_IRQHandler+0x708>)
 800a00a:	4299      	cmp	r1, r3
 800a00c:	d052      	beq.n	800a0b4 <HAL_DMA_IRQHandler+0x738>
 800a00e:	687b      	ldr	r3, [r7, #4]
 800a010:	681b      	ldr	r3, [r3, #0]
 800a012:	4619      	mov	r1, r3
 800a014:	4b1c      	ldr	r3, [pc, #112]	; (800a088 <HAL_DMA_IRQHandler+0x70c>)
 800a016:	4299      	cmp	r1, r3
 800a018:	d049      	beq.n	800a0ae <HAL_DMA_IRQHandler+0x732>
 800a01a:	687b      	ldr	r3, [r7, #4]
 800a01c:	681b      	ldr	r3, [r3, #0]
 800a01e:	4619      	mov	r1, r3
 800a020:	4b1a      	ldr	r3, [pc, #104]	; (800a08c <HAL_DMA_IRQHandler+0x710>)
 800a022:	4299      	cmp	r1, r3
 800a024:	d040      	beq.n	800a0a8 <HAL_DMA_IRQHandler+0x72c>
 800a026:	687b      	ldr	r3, [r7, #4]
 800a028:	681b      	ldr	r3, [r3, #0]
 800a02a:	4619      	mov	r1, r3
 800a02c:	4b18      	ldr	r3, [pc, #96]	; (800a090 <HAL_DMA_IRQHandler+0x714>)
 800a02e:	4299      	cmp	r1, r3
 800a030:	d014      	beq.n	800a05c <HAL_DMA_IRQHandler+0x6e0>
 800a032:	687b      	ldr	r3, [r7, #4]
 800a034:	681b      	ldr	r3, [r3, #0]
 800a036:	4619      	mov	r1, r3
 800a038:	4b16      	ldr	r3, [pc, #88]	; (800a094 <HAL_DMA_IRQHandler+0x718>)
 800a03a:	4299      	cmp	r1, r3
 800a03c:	d00b      	beq.n	800a056 <HAL_DMA_IRQHandler+0x6da>
 800a03e:	687b      	ldr	r3, [r7, #4]
 800a040:	681b      	ldr	r3, [r3, #0]
 800a042:	4619      	mov	r1, r3
 800a044:	4b14      	ldr	r3, [pc, #80]	; (800a098 <HAL_DMA_IRQHandler+0x71c>)
 800a046:	4299      	cmp	r1, r3
 800a048:	d102      	bne.n	800a050 <HAL_DMA_IRQHandler+0x6d4>
 800a04a:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a04e:	e041      	b.n	800a0d4 <HAL_DMA_IRQHandler+0x758>
 800a050:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800a054:	e03e      	b.n	800a0d4 <HAL_DMA_IRQHandler+0x758>
 800a056:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a05a:	e03b      	b.n	800a0d4 <HAL_DMA_IRQHandler+0x758>
 800a05c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a060:	e038      	b.n	800a0d4 <HAL_DMA_IRQHandler+0x758>
 800a062:	bf00      	nop
 800a064:	40026458 	.word	0x40026458
 800a068:	40026400 	.word	0x40026400
 800a06c:	40026010 	.word	0x40026010
 800a070:	40026410 	.word	0x40026410
 800a074:	40026070 	.word	0x40026070
 800a078:	40026470 	.word	0x40026470
 800a07c:	40026028 	.word	0x40026028
 800a080:	40026428 	.word	0x40026428
 800a084:	40026088 	.word	0x40026088
 800a088:	40026488 	.word	0x40026488
 800a08c:	40026040 	.word	0x40026040
 800a090:	40026440 	.word	0x40026440
 800a094:	400260a0 	.word	0x400260a0
 800a098:	400264a0 	.word	0x400264a0
 800a09c:	400260b8 	.word	0x400260b8
 800a0a0:	40026058 	.word	0x40026058
 800a0a4:	40026000 	.word	0x40026000
 800a0a8:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a0ac:	e012      	b.n	800a0d4 <HAL_DMA_IRQHandler+0x758>
 800a0ae:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a0b2:	e00f      	b.n	800a0d4 <HAL_DMA_IRQHandler+0x758>
 800a0b4:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a0b8:	e00c      	b.n	800a0d4 <HAL_DMA_IRQHandler+0x758>
 800a0ba:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a0be:	e009      	b.n	800a0d4 <HAL_DMA_IRQHandler+0x758>
 800a0c0:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a0c4:	e006      	b.n	800a0d4 <HAL_DMA_IRQHandler+0x758>
 800a0c6:	2308      	movs	r3, #8
 800a0c8:	e004      	b.n	800a0d4 <HAL_DMA_IRQHandler+0x758>
 800a0ca:	2308      	movs	r3, #8
 800a0cc:	e002      	b.n	800a0d4 <HAL_DMA_IRQHandler+0x758>
 800a0ce:	2308      	movs	r3, #8
 800a0d0:	e000      	b.n	800a0d4 <HAL_DMA_IRQHandler+0x758>
 800a0d2:	2308      	movs	r3, #8
 800a0d4:	60d3      	str	r3, [r2, #12]
 800a0d6:	e06b      	b.n	800a1b0 <HAL_DMA_IRQHandler+0x834>
 800a0d8:	4a7b      	ldr	r2, [pc, #492]	; (800a2c8 <HAL_DMA_IRQHandler+0x94c>)
 800a0da:	687b      	ldr	r3, [r7, #4]
 800a0dc:	681b      	ldr	r3, [r3, #0]
 800a0de:	4619      	mov	r1, r3
 800a0e0:	4b7a      	ldr	r3, [pc, #488]	; (800a2cc <HAL_DMA_IRQHandler+0x950>)
 800a0e2:	4299      	cmp	r1, r3
 800a0e4:	d062      	beq.n	800a1ac <HAL_DMA_IRQHandler+0x830>
 800a0e6:	687b      	ldr	r3, [r7, #4]
 800a0e8:	681b      	ldr	r3, [r3, #0]
 800a0ea:	4619      	mov	r1, r3
 800a0ec:	4b78      	ldr	r3, [pc, #480]	; (800a2d0 <HAL_DMA_IRQHandler+0x954>)
 800a0ee:	4299      	cmp	r1, r3
 800a0f0:	d05a      	beq.n	800a1a8 <HAL_DMA_IRQHandler+0x82c>
 800a0f2:	687b      	ldr	r3, [r7, #4]
 800a0f4:	681b      	ldr	r3, [r3, #0]
 800a0f6:	4619      	mov	r1, r3
 800a0f8:	4b76      	ldr	r3, [pc, #472]	; (800a2d4 <HAL_DMA_IRQHandler+0x958>)
 800a0fa:	4299      	cmp	r1, r3
 800a0fc:	d052      	beq.n	800a1a4 <HAL_DMA_IRQHandler+0x828>
 800a0fe:	687b      	ldr	r3, [r7, #4]
 800a100:	681b      	ldr	r3, [r3, #0]
 800a102:	4619      	mov	r1, r3
 800a104:	4b74      	ldr	r3, [pc, #464]	; (800a2d8 <HAL_DMA_IRQHandler+0x95c>)
 800a106:	4299      	cmp	r1, r3
 800a108:	d04a      	beq.n	800a1a0 <HAL_DMA_IRQHandler+0x824>
 800a10a:	687b      	ldr	r3, [r7, #4]
 800a10c:	681b      	ldr	r3, [r3, #0]
 800a10e:	4619      	mov	r1, r3
 800a110:	4b72      	ldr	r3, [pc, #456]	; (800a2dc <HAL_DMA_IRQHandler+0x960>)
 800a112:	4299      	cmp	r1, r3
 800a114:	d041      	beq.n	800a19a <HAL_DMA_IRQHandler+0x81e>
 800a116:	687b      	ldr	r3, [r7, #4]
 800a118:	681b      	ldr	r3, [r3, #0]
 800a11a:	4619      	mov	r1, r3
 800a11c:	4b70      	ldr	r3, [pc, #448]	; (800a2e0 <HAL_DMA_IRQHandler+0x964>)
 800a11e:	4299      	cmp	r1, r3
 800a120:	d038      	beq.n	800a194 <HAL_DMA_IRQHandler+0x818>
 800a122:	687b      	ldr	r3, [r7, #4]
 800a124:	681b      	ldr	r3, [r3, #0]
 800a126:	4619      	mov	r1, r3
 800a128:	4b6e      	ldr	r3, [pc, #440]	; (800a2e4 <HAL_DMA_IRQHandler+0x968>)
 800a12a:	4299      	cmp	r1, r3
 800a12c:	d02f      	beq.n	800a18e <HAL_DMA_IRQHandler+0x812>
 800a12e:	687b      	ldr	r3, [r7, #4]
 800a130:	681b      	ldr	r3, [r3, #0]
 800a132:	4619      	mov	r1, r3
 800a134:	4b6c      	ldr	r3, [pc, #432]	; (800a2e8 <HAL_DMA_IRQHandler+0x96c>)
 800a136:	4299      	cmp	r1, r3
 800a138:	d026      	beq.n	800a188 <HAL_DMA_IRQHandler+0x80c>
 800a13a:	687b      	ldr	r3, [r7, #4]
 800a13c:	681b      	ldr	r3, [r3, #0]
 800a13e:	4619      	mov	r1, r3
 800a140:	4b6a      	ldr	r3, [pc, #424]	; (800a2ec <HAL_DMA_IRQHandler+0x970>)
 800a142:	4299      	cmp	r1, r3
 800a144:	d01d      	beq.n	800a182 <HAL_DMA_IRQHandler+0x806>
 800a146:	687b      	ldr	r3, [r7, #4]
 800a148:	681b      	ldr	r3, [r3, #0]
 800a14a:	4619      	mov	r1, r3
 800a14c:	4b68      	ldr	r3, [pc, #416]	; (800a2f0 <HAL_DMA_IRQHandler+0x974>)
 800a14e:	4299      	cmp	r1, r3
 800a150:	d014      	beq.n	800a17c <HAL_DMA_IRQHandler+0x800>
 800a152:	687b      	ldr	r3, [r7, #4]
 800a154:	681b      	ldr	r3, [r3, #0]
 800a156:	4619      	mov	r1, r3
 800a158:	4b66      	ldr	r3, [pc, #408]	; (800a2f4 <HAL_DMA_IRQHandler+0x978>)
 800a15a:	4299      	cmp	r1, r3
 800a15c:	d00b      	beq.n	800a176 <HAL_DMA_IRQHandler+0x7fa>
 800a15e:	687b      	ldr	r3, [r7, #4]
 800a160:	681b      	ldr	r3, [r3, #0]
 800a162:	4619      	mov	r1, r3
 800a164:	4b64      	ldr	r3, [pc, #400]	; (800a2f8 <HAL_DMA_IRQHandler+0x97c>)
 800a166:	4299      	cmp	r1, r3
 800a168:	d102      	bne.n	800a170 <HAL_DMA_IRQHandler+0x7f4>
 800a16a:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a16e:	e01e      	b.n	800a1ae <HAL_DMA_IRQHandler+0x832>
 800a170:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800a174:	e01b      	b.n	800a1ae <HAL_DMA_IRQHandler+0x832>
 800a176:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a17a:	e018      	b.n	800a1ae <HAL_DMA_IRQHandler+0x832>
 800a17c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a180:	e015      	b.n	800a1ae <HAL_DMA_IRQHandler+0x832>
 800a182:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800a186:	e012      	b.n	800a1ae <HAL_DMA_IRQHandler+0x832>
 800a188:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a18c:	e00f      	b.n	800a1ae <HAL_DMA_IRQHandler+0x832>
 800a18e:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a192:	e00c      	b.n	800a1ae <HAL_DMA_IRQHandler+0x832>
 800a194:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a198:	e009      	b.n	800a1ae <HAL_DMA_IRQHandler+0x832>
 800a19a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a19e:	e006      	b.n	800a1ae <HAL_DMA_IRQHandler+0x832>
 800a1a0:	2308      	movs	r3, #8
 800a1a2:	e004      	b.n	800a1ae <HAL_DMA_IRQHandler+0x832>
 800a1a4:	2308      	movs	r3, #8
 800a1a6:	e002      	b.n	800a1ae <HAL_DMA_IRQHandler+0x832>
 800a1a8:	2308      	movs	r3, #8
 800a1aa:	e000      	b.n	800a1ae <HAL_DMA_IRQHandler+0x832>
 800a1ac:	2308      	movs	r3, #8
 800a1ae:	6093      	str	r3, [r2, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 800a1b0:	687b      	ldr	r3, [r7, #4]
 800a1b2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800a1b4:	f043 0201 	orr.w	r2, r3, #1
 800a1b8:	687b      	ldr	r3, [r7, #4]
 800a1ba:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
 800a1bc:	687b      	ldr	r3, [r7, #4]
 800a1be:	2204      	movs	r2, #4
 800a1c0:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma); 
 800a1c4:	687b      	ldr	r3, [r7, #4]
 800a1c6:	2200      	movs	r2, #0
 800a1c8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      if(hdma->XferErrorCallback != NULL)
 800a1cc:	687b      	ldr	r3, [r7, #4]
 800a1ce:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a1d0:	2b00      	cmp	r3, #0
 800a1d2:	d003      	beq.n	800a1dc <HAL_DMA_IRQHandler+0x860>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 800a1d4:	687b      	ldr	r3, [r7, #4]
 800a1d6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a1d8:	6878      	ldr	r0, [r7, #4]
 800a1da:	4798      	blx	r3
      }
    }
  }
  /* FIFO Error Interrupt management ******************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 800a1dc:	687b      	ldr	r3, [r7, #4]
 800a1de:	681b      	ldr	r3, [r3, #0]
 800a1e0:	461a      	mov	r2, r3
 800a1e2:	4b46      	ldr	r3, [pc, #280]	; (800a2fc <HAL_DMA_IRQHandler+0x980>)
 800a1e4:	429a      	cmp	r2, r3
 800a1e6:	f240 808f 	bls.w	800a308 <HAL_DMA_IRQHandler+0x98c>
 800a1ea:	4b45      	ldr	r3, [pc, #276]	; (800a300 <HAL_DMA_IRQHandler+0x984>)
 800a1ec:	685a      	ldr	r2, [r3, #4]
 800a1ee:	687b      	ldr	r3, [r7, #4]
 800a1f0:	681b      	ldr	r3, [r3, #0]
 800a1f2:	4619      	mov	r1, r3
 800a1f4:	4b35      	ldr	r3, [pc, #212]	; (800a2cc <HAL_DMA_IRQHandler+0x950>)
 800a1f6:	4299      	cmp	r1, r3
 800a1f8:	d05e      	beq.n	800a2b8 <HAL_DMA_IRQHandler+0x93c>
 800a1fa:	687b      	ldr	r3, [r7, #4]
 800a1fc:	681b      	ldr	r3, [r3, #0]
 800a1fe:	4619      	mov	r1, r3
 800a200:	4b33      	ldr	r3, [pc, #204]	; (800a2d0 <HAL_DMA_IRQHandler+0x954>)
 800a202:	4299      	cmp	r1, r3
 800a204:	d056      	beq.n	800a2b4 <HAL_DMA_IRQHandler+0x938>
 800a206:	687b      	ldr	r3, [r7, #4]
 800a208:	681b      	ldr	r3, [r3, #0]
 800a20a:	4619      	mov	r1, r3
 800a20c:	4b31      	ldr	r3, [pc, #196]	; (800a2d4 <HAL_DMA_IRQHandler+0x958>)
 800a20e:	4299      	cmp	r1, r3
 800a210:	d04e      	beq.n	800a2b0 <HAL_DMA_IRQHandler+0x934>
 800a212:	687b      	ldr	r3, [r7, #4]
 800a214:	681b      	ldr	r3, [r3, #0]
 800a216:	4619      	mov	r1, r3
 800a218:	4b2f      	ldr	r3, [pc, #188]	; (800a2d8 <HAL_DMA_IRQHandler+0x95c>)
 800a21a:	4299      	cmp	r1, r3
 800a21c:	d046      	beq.n	800a2ac <HAL_DMA_IRQHandler+0x930>
 800a21e:	687b      	ldr	r3, [r7, #4]
 800a220:	681b      	ldr	r3, [r3, #0]
 800a222:	4619      	mov	r1, r3
 800a224:	4b2d      	ldr	r3, [pc, #180]	; (800a2dc <HAL_DMA_IRQHandler+0x960>)
 800a226:	4299      	cmp	r1, r3
 800a228:	d03e      	beq.n	800a2a8 <HAL_DMA_IRQHandler+0x92c>
 800a22a:	687b      	ldr	r3, [r7, #4]
 800a22c:	681b      	ldr	r3, [r3, #0]
 800a22e:	4619      	mov	r1, r3
 800a230:	4b2b      	ldr	r3, [pc, #172]	; (800a2e0 <HAL_DMA_IRQHandler+0x964>)
 800a232:	4299      	cmp	r1, r3
 800a234:	d036      	beq.n	800a2a4 <HAL_DMA_IRQHandler+0x928>
 800a236:	687b      	ldr	r3, [r7, #4]
 800a238:	681b      	ldr	r3, [r3, #0]
 800a23a:	4619      	mov	r1, r3
 800a23c:	4b29      	ldr	r3, [pc, #164]	; (800a2e4 <HAL_DMA_IRQHandler+0x968>)
 800a23e:	4299      	cmp	r1, r3
 800a240:	d02e      	beq.n	800a2a0 <HAL_DMA_IRQHandler+0x924>
 800a242:	687b      	ldr	r3, [r7, #4]
 800a244:	681b      	ldr	r3, [r3, #0]
 800a246:	4619      	mov	r1, r3
 800a248:	4b27      	ldr	r3, [pc, #156]	; (800a2e8 <HAL_DMA_IRQHandler+0x96c>)
 800a24a:	4299      	cmp	r1, r3
 800a24c:	d026      	beq.n	800a29c <HAL_DMA_IRQHandler+0x920>
 800a24e:	687b      	ldr	r3, [r7, #4]
 800a250:	681b      	ldr	r3, [r3, #0]
 800a252:	4619      	mov	r1, r3
 800a254:	4b25      	ldr	r3, [pc, #148]	; (800a2ec <HAL_DMA_IRQHandler+0x970>)
 800a256:	4299      	cmp	r1, r3
 800a258:	d01d      	beq.n	800a296 <HAL_DMA_IRQHandler+0x91a>
 800a25a:	687b      	ldr	r3, [r7, #4]
 800a25c:	681b      	ldr	r3, [r3, #0]
 800a25e:	4619      	mov	r1, r3
 800a260:	4b23      	ldr	r3, [pc, #140]	; (800a2f0 <HAL_DMA_IRQHandler+0x974>)
 800a262:	4299      	cmp	r1, r3
 800a264:	d014      	beq.n	800a290 <HAL_DMA_IRQHandler+0x914>
 800a266:	687b      	ldr	r3, [r7, #4]
 800a268:	681b      	ldr	r3, [r3, #0]
 800a26a:	4619      	mov	r1, r3
 800a26c:	4b21      	ldr	r3, [pc, #132]	; (800a2f4 <HAL_DMA_IRQHandler+0x978>)
 800a26e:	4299      	cmp	r1, r3
 800a270:	d00b      	beq.n	800a28a <HAL_DMA_IRQHandler+0x90e>
 800a272:	687b      	ldr	r3, [r7, #4]
 800a274:	681b      	ldr	r3, [r3, #0]
 800a276:	4619      	mov	r1, r3
 800a278:	4b1f      	ldr	r3, [pc, #124]	; (800a2f8 <HAL_DMA_IRQHandler+0x97c>)
 800a27a:	4299      	cmp	r1, r3
 800a27c:	d102      	bne.n	800a284 <HAL_DMA_IRQHandler+0x908>
 800a27e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a282:	e01a      	b.n	800a2ba <HAL_DMA_IRQHandler+0x93e>
 800a284:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800a288:	e017      	b.n	800a2ba <HAL_DMA_IRQHandler+0x93e>
 800a28a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a28e:	e014      	b.n	800a2ba <HAL_DMA_IRQHandler+0x93e>
 800a290:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a294:	e011      	b.n	800a2ba <HAL_DMA_IRQHandler+0x93e>
 800a296:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a29a:	e00e      	b.n	800a2ba <HAL_DMA_IRQHandler+0x93e>
 800a29c:	2340      	movs	r3, #64	; 0x40
 800a29e:	e00c      	b.n	800a2ba <HAL_DMA_IRQHandler+0x93e>
 800a2a0:	2340      	movs	r3, #64	; 0x40
 800a2a2:	e00a      	b.n	800a2ba <HAL_DMA_IRQHandler+0x93e>
 800a2a4:	2340      	movs	r3, #64	; 0x40
 800a2a6:	e008      	b.n	800a2ba <HAL_DMA_IRQHandler+0x93e>
 800a2a8:	2340      	movs	r3, #64	; 0x40
 800a2aa:	e006      	b.n	800a2ba <HAL_DMA_IRQHandler+0x93e>
 800a2ac:	4b15      	ldr	r3, [pc, #84]	; (800a304 <HAL_DMA_IRQHandler+0x988>)
 800a2ae:	e004      	b.n	800a2ba <HAL_DMA_IRQHandler+0x93e>
 800a2b0:	4b14      	ldr	r3, [pc, #80]	; (800a304 <HAL_DMA_IRQHandler+0x988>)
 800a2b2:	e002      	b.n	800a2ba <HAL_DMA_IRQHandler+0x93e>
 800a2b4:	4b13      	ldr	r3, [pc, #76]	; (800a304 <HAL_DMA_IRQHandler+0x988>)
 800a2b6:	e000      	b.n	800a2ba <HAL_DMA_IRQHandler+0x93e>
 800a2b8:	4b12      	ldr	r3, [pc, #72]	; (800a304 <HAL_DMA_IRQHandler+0x988>)
 800a2ba:	4013      	ands	r3, r2
 800a2bc:	2b00      	cmp	r3, #0
 800a2be:	bf14      	ite	ne
 800a2c0:	2301      	movne	r3, #1
 800a2c2:	2300      	moveq	r3, #0
 800a2c4:	b2db      	uxtb	r3, r3
 800a2c6:	e19a      	b.n	800a5fe <HAL_DMA_IRQHandler+0xc82>
 800a2c8:	40026000 	.word	0x40026000
 800a2cc:	40026010 	.word	0x40026010
 800a2d0:	40026410 	.word	0x40026410
 800a2d4:	40026070 	.word	0x40026070
 800a2d8:	40026470 	.word	0x40026470
 800a2dc:	40026028 	.word	0x40026028
 800a2e0:	40026428 	.word	0x40026428
 800a2e4:	40026088 	.word	0x40026088
 800a2e8:	40026488 	.word	0x40026488
 800a2ec:	40026040 	.word	0x40026040
 800a2f0:	40026440 	.word	0x40026440
 800a2f4:	400260a0 	.word	0x400260a0
 800a2f8:	400264a0 	.word	0x400264a0
 800a2fc:	40026458 	.word	0x40026458
 800a300:	40026400 	.word	0x40026400
 800a304:	00800001 	.word	0x00800001
 800a308:	687b      	ldr	r3, [r7, #4]
 800a30a:	681b      	ldr	r3, [r3, #0]
 800a30c:	461a      	mov	r2, r3
 800a30e:	4b9a      	ldr	r3, [pc, #616]	; (800a578 <HAL_DMA_IRQHandler+0xbfc>)
 800a310:	429a      	cmp	r2, r3
 800a312:	d96e      	bls.n	800a3f2 <HAL_DMA_IRQHandler+0xa76>
 800a314:	4b99      	ldr	r3, [pc, #612]	; (800a57c <HAL_DMA_IRQHandler+0xc00>)
 800a316:	681a      	ldr	r2, [r3, #0]
 800a318:	687b      	ldr	r3, [r7, #4]
 800a31a:	681b      	ldr	r3, [r3, #0]
 800a31c:	4619      	mov	r1, r3
 800a31e:	4b98      	ldr	r3, [pc, #608]	; (800a580 <HAL_DMA_IRQHandler+0xc04>)
 800a320:	4299      	cmp	r1, r3
 800a322:	d05e      	beq.n	800a3e2 <HAL_DMA_IRQHandler+0xa66>
 800a324:	687b      	ldr	r3, [r7, #4]
 800a326:	681b      	ldr	r3, [r3, #0]
 800a328:	4619      	mov	r1, r3
 800a32a:	4b96      	ldr	r3, [pc, #600]	; (800a584 <HAL_DMA_IRQHandler+0xc08>)
 800a32c:	4299      	cmp	r1, r3
 800a32e:	d056      	beq.n	800a3de <HAL_DMA_IRQHandler+0xa62>
 800a330:	687b      	ldr	r3, [r7, #4]
 800a332:	681b      	ldr	r3, [r3, #0]
 800a334:	4619      	mov	r1, r3
 800a336:	4b94      	ldr	r3, [pc, #592]	; (800a588 <HAL_DMA_IRQHandler+0xc0c>)
 800a338:	4299      	cmp	r1, r3
 800a33a:	d04e      	beq.n	800a3da <HAL_DMA_IRQHandler+0xa5e>
 800a33c:	687b      	ldr	r3, [r7, #4]
 800a33e:	681b      	ldr	r3, [r3, #0]
 800a340:	4619      	mov	r1, r3
 800a342:	4b92      	ldr	r3, [pc, #584]	; (800a58c <HAL_DMA_IRQHandler+0xc10>)
 800a344:	4299      	cmp	r1, r3
 800a346:	d046      	beq.n	800a3d6 <HAL_DMA_IRQHandler+0xa5a>
 800a348:	687b      	ldr	r3, [r7, #4]
 800a34a:	681b      	ldr	r3, [r3, #0]
 800a34c:	4619      	mov	r1, r3
 800a34e:	4b90      	ldr	r3, [pc, #576]	; (800a590 <HAL_DMA_IRQHandler+0xc14>)
 800a350:	4299      	cmp	r1, r3
 800a352:	d03e      	beq.n	800a3d2 <HAL_DMA_IRQHandler+0xa56>
 800a354:	687b      	ldr	r3, [r7, #4]
 800a356:	681b      	ldr	r3, [r3, #0]
 800a358:	4619      	mov	r1, r3
 800a35a:	4b8e      	ldr	r3, [pc, #568]	; (800a594 <HAL_DMA_IRQHandler+0xc18>)
 800a35c:	4299      	cmp	r1, r3
 800a35e:	d036      	beq.n	800a3ce <HAL_DMA_IRQHandler+0xa52>
 800a360:	687b      	ldr	r3, [r7, #4]
 800a362:	681b      	ldr	r3, [r3, #0]
 800a364:	4619      	mov	r1, r3
 800a366:	4b8c      	ldr	r3, [pc, #560]	; (800a598 <HAL_DMA_IRQHandler+0xc1c>)
 800a368:	4299      	cmp	r1, r3
 800a36a:	d02e      	beq.n	800a3ca <HAL_DMA_IRQHandler+0xa4e>
 800a36c:	687b      	ldr	r3, [r7, #4]
 800a36e:	681b      	ldr	r3, [r3, #0]
 800a370:	4619      	mov	r1, r3
 800a372:	4b8a      	ldr	r3, [pc, #552]	; (800a59c <HAL_DMA_IRQHandler+0xc20>)
 800a374:	4299      	cmp	r1, r3
 800a376:	d026      	beq.n	800a3c6 <HAL_DMA_IRQHandler+0xa4a>
 800a378:	687b      	ldr	r3, [r7, #4]
 800a37a:	681b      	ldr	r3, [r3, #0]
 800a37c:	4619      	mov	r1, r3
 800a37e:	4b88      	ldr	r3, [pc, #544]	; (800a5a0 <HAL_DMA_IRQHandler+0xc24>)
 800a380:	4299      	cmp	r1, r3
 800a382:	d01d      	beq.n	800a3c0 <HAL_DMA_IRQHandler+0xa44>
 800a384:	687b      	ldr	r3, [r7, #4]
 800a386:	681b      	ldr	r3, [r3, #0]
 800a388:	4619      	mov	r1, r3
 800a38a:	4b86      	ldr	r3, [pc, #536]	; (800a5a4 <HAL_DMA_IRQHandler+0xc28>)
 800a38c:	4299      	cmp	r1, r3
 800a38e:	d014      	beq.n	800a3ba <HAL_DMA_IRQHandler+0xa3e>
 800a390:	687b      	ldr	r3, [r7, #4]
 800a392:	681b      	ldr	r3, [r3, #0]
 800a394:	4619      	mov	r1, r3
 800a396:	4b84      	ldr	r3, [pc, #528]	; (800a5a8 <HAL_DMA_IRQHandler+0xc2c>)
 800a398:	4299      	cmp	r1, r3
 800a39a:	d00b      	beq.n	800a3b4 <HAL_DMA_IRQHandler+0xa38>
 800a39c:	687b      	ldr	r3, [r7, #4]
 800a39e:	681b      	ldr	r3, [r3, #0]
 800a3a0:	4619      	mov	r1, r3
 800a3a2:	4b82      	ldr	r3, [pc, #520]	; (800a5ac <HAL_DMA_IRQHandler+0xc30>)
 800a3a4:	4299      	cmp	r1, r3
 800a3a6:	d102      	bne.n	800a3ae <HAL_DMA_IRQHandler+0xa32>
 800a3a8:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a3ac:	e01a      	b.n	800a3e4 <HAL_DMA_IRQHandler+0xa68>
 800a3ae:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800a3b2:	e017      	b.n	800a3e4 <HAL_DMA_IRQHandler+0xa68>
 800a3b4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a3b8:	e014      	b.n	800a3e4 <HAL_DMA_IRQHandler+0xa68>
 800a3ba:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a3be:	e011      	b.n	800a3e4 <HAL_DMA_IRQHandler+0xa68>
 800a3c0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a3c4:	e00e      	b.n	800a3e4 <HAL_DMA_IRQHandler+0xa68>
 800a3c6:	2340      	movs	r3, #64	; 0x40
 800a3c8:	e00c      	b.n	800a3e4 <HAL_DMA_IRQHandler+0xa68>
 800a3ca:	2340      	movs	r3, #64	; 0x40
 800a3cc:	e00a      	b.n	800a3e4 <HAL_DMA_IRQHandler+0xa68>
 800a3ce:	2340      	movs	r3, #64	; 0x40
 800a3d0:	e008      	b.n	800a3e4 <HAL_DMA_IRQHandler+0xa68>
 800a3d2:	2340      	movs	r3, #64	; 0x40
 800a3d4:	e006      	b.n	800a3e4 <HAL_DMA_IRQHandler+0xa68>
 800a3d6:	4b76      	ldr	r3, [pc, #472]	; (800a5b0 <HAL_DMA_IRQHandler+0xc34>)
 800a3d8:	e004      	b.n	800a3e4 <HAL_DMA_IRQHandler+0xa68>
 800a3da:	4b75      	ldr	r3, [pc, #468]	; (800a5b0 <HAL_DMA_IRQHandler+0xc34>)
 800a3dc:	e002      	b.n	800a3e4 <HAL_DMA_IRQHandler+0xa68>
 800a3de:	4b74      	ldr	r3, [pc, #464]	; (800a5b0 <HAL_DMA_IRQHandler+0xc34>)
 800a3e0:	e000      	b.n	800a3e4 <HAL_DMA_IRQHandler+0xa68>
 800a3e2:	4b73      	ldr	r3, [pc, #460]	; (800a5b0 <HAL_DMA_IRQHandler+0xc34>)
 800a3e4:	4013      	ands	r3, r2
 800a3e6:	2b00      	cmp	r3, #0
 800a3e8:	bf14      	ite	ne
 800a3ea:	2301      	movne	r3, #1
 800a3ec:	2300      	moveq	r3, #0
 800a3ee:	b2db      	uxtb	r3, r3
 800a3f0:	e105      	b.n	800a5fe <HAL_DMA_IRQHandler+0xc82>
 800a3f2:	687b      	ldr	r3, [r7, #4]
 800a3f4:	681b      	ldr	r3, [r3, #0]
 800a3f6:	461a      	mov	r2, r3
 800a3f8:	4b6e      	ldr	r3, [pc, #440]	; (800a5b4 <HAL_DMA_IRQHandler+0xc38>)
 800a3fa:	429a      	cmp	r2, r3
 800a3fc:	d96e      	bls.n	800a4dc <HAL_DMA_IRQHandler+0xb60>
 800a3fe:	4b6e      	ldr	r3, [pc, #440]	; (800a5b8 <HAL_DMA_IRQHandler+0xc3c>)
 800a400:	685a      	ldr	r2, [r3, #4]
 800a402:	687b      	ldr	r3, [r7, #4]
 800a404:	681b      	ldr	r3, [r3, #0]
 800a406:	4619      	mov	r1, r3
 800a408:	4b5d      	ldr	r3, [pc, #372]	; (800a580 <HAL_DMA_IRQHandler+0xc04>)
 800a40a:	4299      	cmp	r1, r3
 800a40c:	d05e      	beq.n	800a4cc <HAL_DMA_IRQHandler+0xb50>
 800a40e:	687b      	ldr	r3, [r7, #4]
 800a410:	681b      	ldr	r3, [r3, #0]
 800a412:	4619      	mov	r1, r3
 800a414:	4b5b      	ldr	r3, [pc, #364]	; (800a584 <HAL_DMA_IRQHandler+0xc08>)
 800a416:	4299      	cmp	r1, r3
 800a418:	d056      	beq.n	800a4c8 <HAL_DMA_IRQHandler+0xb4c>
 800a41a:	687b      	ldr	r3, [r7, #4]
 800a41c:	681b      	ldr	r3, [r3, #0]
 800a41e:	4619      	mov	r1, r3
 800a420:	4b59      	ldr	r3, [pc, #356]	; (800a588 <HAL_DMA_IRQHandler+0xc0c>)
 800a422:	4299      	cmp	r1, r3
 800a424:	d04e      	beq.n	800a4c4 <HAL_DMA_IRQHandler+0xb48>
 800a426:	687b      	ldr	r3, [r7, #4]
 800a428:	681b      	ldr	r3, [r3, #0]
 800a42a:	4619      	mov	r1, r3
 800a42c:	4b57      	ldr	r3, [pc, #348]	; (800a58c <HAL_DMA_IRQHandler+0xc10>)
 800a42e:	4299      	cmp	r1, r3
 800a430:	d046      	beq.n	800a4c0 <HAL_DMA_IRQHandler+0xb44>
 800a432:	687b      	ldr	r3, [r7, #4]
 800a434:	681b      	ldr	r3, [r3, #0]
 800a436:	4619      	mov	r1, r3
 800a438:	4b55      	ldr	r3, [pc, #340]	; (800a590 <HAL_DMA_IRQHandler+0xc14>)
 800a43a:	4299      	cmp	r1, r3
 800a43c:	d03e      	beq.n	800a4bc <HAL_DMA_IRQHandler+0xb40>
 800a43e:	687b      	ldr	r3, [r7, #4]
 800a440:	681b      	ldr	r3, [r3, #0]
 800a442:	4619      	mov	r1, r3
 800a444:	4b53      	ldr	r3, [pc, #332]	; (800a594 <HAL_DMA_IRQHandler+0xc18>)
 800a446:	4299      	cmp	r1, r3
 800a448:	d036      	beq.n	800a4b8 <HAL_DMA_IRQHandler+0xb3c>
 800a44a:	687b      	ldr	r3, [r7, #4]
 800a44c:	681b      	ldr	r3, [r3, #0]
 800a44e:	4619      	mov	r1, r3
 800a450:	4b51      	ldr	r3, [pc, #324]	; (800a598 <HAL_DMA_IRQHandler+0xc1c>)
 800a452:	4299      	cmp	r1, r3
 800a454:	d02e      	beq.n	800a4b4 <HAL_DMA_IRQHandler+0xb38>
 800a456:	687b      	ldr	r3, [r7, #4]
 800a458:	681b      	ldr	r3, [r3, #0]
 800a45a:	4619      	mov	r1, r3
 800a45c:	4b4f      	ldr	r3, [pc, #316]	; (800a59c <HAL_DMA_IRQHandler+0xc20>)
 800a45e:	4299      	cmp	r1, r3
 800a460:	d026      	beq.n	800a4b0 <HAL_DMA_IRQHandler+0xb34>
 800a462:	687b      	ldr	r3, [r7, #4]
 800a464:	681b      	ldr	r3, [r3, #0]
 800a466:	4619      	mov	r1, r3
 800a468:	4b4d      	ldr	r3, [pc, #308]	; (800a5a0 <HAL_DMA_IRQHandler+0xc24>)
 800a46a:	4299      	cmp	r1, r3
 800a46c:	d01d      	beq.n	800a4aa <HAL_DMA_IRQHandler+0xb2e>
 800a46e:	687b      	ldr	r3, [r7, #4]
 800a470:	681b      	ldr	r3, [r3, #0]
 800a472:	4619      	mov	r1, r3
 800a474:	4b4b      	ldr	r3, [pc, #300]	; (800a5a4 <HAL_DMA_IRQHandler+0xc28>)
 800a476:	4299      	cmp	r1, r3
 800a478:	d014      	beq.n	800a4a4 <HAL_DMA_IRQHandler+0xb28>
 800a47a:	687b      	ldr	r3, [r7, #4]
 800a47c:	681b      	ldr	r3, [r3, #0]
 800a47e:	4619      	mov	r1, r3
 800a480:	4b49      	ldr	r3, [pc, #292]	; (800a5a8 <HAL_DMA_IRQHandler+0xc2c>)
 800a482:	4299      	cmp	r1, r3
 800a484:	d00b      	beq.n	800a49e <HAL_DMA_IRQHandler+0xb22>
 800a486:	687b      	ldr	r3, [r7, #4]
 800a488:	681b      	ldr	r3, [r3, #0]
 800a48a:	4619      	mov	r1, r3
 800a48c:	4b47      	ldr	r3, [pc, #284]	; (800a5ac <HAL_DMA_IRQHandler+0xc30>)
 800a48e:	4299      	cmp	r1, r3
 800a490:	d102      	bne.n	800a498 <HAL_DMA_IRQHandler+0xb1c>
 800a492:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a496:	e01a      	b.n	800a4ce <HAL_DMA_IRQHandler+0xb52>
 800a498:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800a49c:	e017      	b.n	800a4ce <HAL_DMA_IRQHandler+0xb52>
 800a49e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a4a2:	e014      	b.n	800a4ce <HAL_DMA_IRQHandler+0xb52>
 800a4a4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a4a8:	e011      	b.n	800a4ce <HAL_DMA_IRQHandler+0xb52>
 800a4aa:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a4ae:	e00e      	b.n	800a4ce <HAL_DMA_IRQHandler+0xb52>
 800a4b0:	2340      	movs	r3, #64	; 0x40
 800a4b2:	e00c      	b.n	800a4ce <HAL_DMA_IRQHandler+0xb52>
 800a4b4:	2340      	movs	r3, #64	; 0x40
 800a4b6:	e00a      	b.n	800a4ce <HAL_DMA_IRQHandler+0xb52>
 800a4b8:	2340      	movs	r3, #64	; 0x40
 800a4ba:	e008      	b.n	800a4ce <HAL_DMA_IRQHandler+0xb52>
 800a4bc:	2340      	movs	r3, #64	; 0x40
 800a4be:	e006      	b.n	800a4ce <HAL_DMA_IRQHandler+0xb52>
 800a4c0:	4b3b      	ldr	r3, [pc, #236]	; (800a5b0 <HAL_DMA_IRQHandler+0xc34>)
 800a4c2:	e004      	b.n	800a4ce <HAL_DMA_IRQHandler+0xb52>
 800a4c4:	4b3a      	ldr	r3, [pc, #232]	; (800a5b0 <HAL_DMA_IRQHandler+0xc34>)
 800a4c6:	e002      	b.n	800a4ce <HAL_DMA_IRQHandler+0xb52>
 800a4c8:	4b39      	ldr	r3, [pc, #228]	; (800a5b0 <HAL_DMA_IRQHandler+0xc34>)
 800a4ca:	e000      	b.n	800a4ce <HAL_DMA_IRQHandler+0xb52>
 800a4cc:	4b38      	ldr	r3, [pc, #224]	; (800a5b0 <HAL_DMA_IRQHandler+0xc34>)
 800a4ce:	4013      	ands	r3, r2
 800a4d0:	2b00      	cmp	r3, #0
 800a4d2:	bf14      	ite	ne
 800a4d4:	2301      	movne	r3, #1
 800a4d6:	2300      	moveq	r3, #0
 800a4d8:	b2db      	uxtb	r3, r3
 800a4da:	e090      	b.n	800a5fe <HAL_DMA_IRQHandler+0xc82>
 800a4dc:	4b36      	ldr	r3, [pc, #216]	; (800a5b8 <HAL_DMA_IRQHandler+0xc3c>)
 800a4de:	681a      	ldr	r2, [r3, #0]
 800a4e0:	687b      	ldr	r3, [r7, #4]
 800a4e2:	681b      	ldr	r3, [r3, #0]
 800a4e4:	4619      	mov	r1, r3
 800a4e6:	4b26      	ldr	r3, [pc, #152]	; (800a580 <HAL_DMA_IRQHandler+0xc04>)
 800a4e8:	4299      	cmp	r1, r3
 800a4ea:	f000 8081 	beq.w	800a5f0 <HAL_DMA_IRQHandler+0xc74>
 800a4ee:	687b      	ldr	r3, [r7, #4]
 800a4f0:	681b      	ldr	r3, [r3, #0]
 800a4f2:	4619      	mov	r1, r3
 800a4f4:	4b23      	ldr	r3, [pc, #140]	; (800a584 <HAL_DMA_IRQHandler+0xc08>)
 800a4f6:	4299      	cmp	r1, r3
 800a4f8:	d078      	beq.n	800a5ec <HAL_DMA_IRQHandler+0xc70>
 800a4fa:	687b      	ldr	r3, [r7, #4]
 800a4fc:	681b      	ldr	r3, [r3, #0]
 800a4fe:	4619      	mov	r1, r3
 800a500:	4b21      	ldr	r3, [pc, #132]	; (800a588 <HAL_DMA_IRQHandler+0xc0c>)
 800a502:	4299      	cmp	r1, r3
 800a504:	d070      	beq.n	800a5e8 <HAL_DMA_IRQHandler+0xc6c>
 800a506:	687b      	ldr	r3, [r7, #4]
 800a508:	681b      	ldr	r3, [r3, #0]
 800a50a:	4619      	mov	r1, r3
 800a50c:	4b1f      	ldr	r3, [pc, #124]	; (800a58c <HAL_DMA_IRQHandler+0xc10>)
 800a50e:	4299      	cmp	r1, r3
 800a510:	d068      	beq.n	800a5e4 <HAL_DMA_IRQHandler+0xc68>
 800a512:	687b      	ldr	r3, [r7, #4]
 800a514:	681b      	ldr	r3, [r3, #0]
 800a516:	4619      	mov	r1, r3
 800a518:	4b1d      	ldr	r3, [pc, #116]	; (800a590 <HAL_DMA_IRQHandler+0xc14>)
 800a51a:	4299      	cmp	r1, r3
 800a51c:	d060      	beq.n	800a5e0 <HAL_DMA_IRQHandler+0xc64>
 800a51e:	687b      	ldr	r3, [r7, #4]
 800a520:	681b      	ldr	r3, [r3, #0]
 800a522:	4619      	mov	r1, r3
 800a524:	4b1b      	ldr	r3, [pc, #108]	; (800a594 <HAL_DMA_IRQHandler+0xc18>)
 800a526:	4299      	cmp	r1, r3
 800a528:	d058      	beq.n	800a5dc <HAL_DMA_IRQHandler+0xc60>
 800a52a:	687b      	ldr	r3, [r7, #4]
 800a52c:	681b      	ldr	r3, [r3, #0]
 800a52e:	4619      	mov	r1, r3
 800a530:	4b19      	ldr	r3, [pc, #100]	; (800a598 <HAL_DMA_IRQHandler+0xc1c>)
 800a532:	4299      	cmp	r1, r3
 800a534:	d050      	beq.n	800a5d8 <HAL_DMA_IRQHandler+0xc5c>
 800a536:	687b      	ldr	r3, [r7, #4]
 800a538:	681b      	ldr	r3, [r3, #0]
 800a53a:	4619      	mov	r1, r3
 800a53c:	4b17      	ldr	r3, [pc, #92]	; (800a59c <HAL_DMA_IRQHandler+0xc20>)
 800a53e:	4299      	cmp	r1, r3
 800a540:	d048      	beq.n	800a5d4 <HAL_DMA_IRQHandler+0xc58>
 800a542:	687b      	ldr	r3, [r7, #4]
 800a544:	681b      	ldr	r3, [r3, #0]
 800a546:	4619      	mov	r1, r3
 800a548:	4b15      	ldr	r3, [pc, #84]	; (800a5a0 <HAL_DMA_IRQHandler+0xc24>)
 800a54a:	4299      	cmp	r1, r3
 800a54c:	d03f      	beq.n	800a5ce <HAL_DMA_IRQHandler+0xc52>
 800a54e:	687b      	ldr	r3, [r7, #4]
 800a550:	681b      	ldr	r3, [r3, #0]
 800a552:	4619      	mov	r1, r3
 800a554:	4b13      	ldr	r3, [pc, #76]	; (800a5a4 <HAL_DMA_IRQHandler+0xc28>)
 800a556:	4299      	cmp	r1, r3
 800a558:	d036      	beq.n	800a5c8 <HAL_DMA_IRQHandler+0xc4c>
 800a55a:	687b      	ldr	r3, [r7, #4]
 800a55c:	681b      	ldr	r3, [r3, #0]
 800a55e:	4619      	mov	r1, r3
 800a560:	4b11      	ldr	r3, [pc, #68]	; (800a5a8 <HAL_DMA_IRQHandler+0xc2c>)
 800a562:	4299      	cmp	r1, r3
 800a564:	d02d      	beq.n	800a5c2 <HAL_DMA_IRQHandler+0xc46>
 800a566:	687b      	ldr	r3, [r7, #4]
 800a568:	681b      	ldr	r3, [r3, #0]
 800a56a:	4619      	mov	r1, r3
 800a56c:	4b0f      	ldr	r3, [pc, #60]	; (800a5ac <HAL_DMA_IRQHandler+0xc30>)
 800a56e:	4299      	cmp	r1, r3
 800a570:	d124      	bne.n	800a5bc <HAL_DMA_IRQHandler+0xc40>
 800a572:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a576:	e03c      	b.n	800a5f2 <HAL_DMA_IRQHandler+0xc76>
 800a578:	400260b8 	.word	0x400260b8
 800a57c:	40026400 	.word	0x40026400
 800a580:	40026010 	.word	0x40026010
 800a584:	40026410 	.word	0x40026410
 800a588:	40026070 	.word	0x40026070
 800a58c:	40026470 	.word	0x40026470
 800a590:	40026028 	.word	0x40026028
 800a594:	40026428 	.word	0x40026428
 800a598:	40026088 	.word	0x40026088
 800a59c:	40026488 	.word	0x40026488
 800a5a0:	40026040 	.word	0x40026040
 800a5a4:	40026440 	.word	0x40026440
 800a5a8:	400260a0 	.word	0x400260a0
 800a5ac:	400264a0 	.word	0x400264a0
 800a5b0:	00800001 	.word	0x00800001
 800a5b4:	40026058 	.word	0x40026058
 800a5b8:	40026000 	.word	0x40026000
 800a5bc:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800a5c0:	e017      	b.n	800a5f2 <HAL_DMA_IRQHandler+0xc76>
 800a5c2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a5c6:	e014      	b.n	800a5f2 <HAL_DMA_IRQHandler+0xc76>
 800a5c8:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a5cc:	e011      	b.n	800a5f2 <HAL_DMA_IRQHandler+0xc76>
 800a5ce:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a5d2:	e00e      	b.n	800a5f2 <HAL_DMA_IRQHandler+0xc76>
 800a5d4:	2340      	movs	r3, #64	; 0x40
 800a5d6:	e00c      	b.n	800a5f2 <HAL_DMA_IRQHandler+0xc76>
 800a5d8:	2340      	movs	r3, #64	; 0x40
 800a5da:	e00a      	b.n	800a5f2 <HAL_DMA_IRQHandler+0xc76>
 800a5dc:	2340      	movs	r3, #64	; 0x40
 800a5de:	e008      	b.n	800a5f2 <HAL_DMA_IRQHandler+0xc76>
 800a5e0:	2340      	movs	r3, #64	; 0x40
 800a5e2:	e006      	b.n	800a5f2 <HAL_DMA_IRQHandler+0xc76>
 800a5e4:	4b7f      	ldr	r3, [pc, #508]	; (800a7e4 <HAL_DMA_IRQHandler+0xe68>)
 800a5e6:	e004      	b.n	800a5f2 <HAL_DMA_IRQHandler+0xc76>
 800a5e8:	4b7e      	ldr	r3, [pc, #504]	; (800a7e4 <HAL_DMA_IRQHandler+0xe68>)
 800a5ea:	e002      	b.n	800a5f2 <HAL_DMA_IRQHandler+0xc76>
 800a5ec:	4b7d      	ldr	r3, [pc, #500]	; (800a7e4 <HAL_DMA_IRQHandler+0xe68>)
 800a5ee:	e000      	b.n	800a5f2 <HAL_DMA_IRQHandler+0xc76>
 800a5f0:	4b7c      	ldr	r3, [pc, #496]	; (800a7e4 <HAL_DMA_IRQHandler+0xe68>)
 800a5f2:	4013      	ands	r3, r2
 800a5f4:	2b00      	cmp	r3, #0
 800a5f6:	bf14      	ite	ne
 800a5f8:	2301      	movne	r3, #1
 800a5fa:	2300      	moveq	r3, #0
 800a5fc:	b2db      	uxtb	r3, r3
 800a5fe:	2b00      	cmp	r3, #0
 800a600:	f000 821c 	beq.w	800aa3c <HAL_DMA_IRQHandler+0x10c0>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 800a604:	687b      	ldr	r3, [r7, #4]
 800a606:	681b      	ldr	r3, [r3, #0]
 800a608:	695b      	ldr	r3, [r3, #20]
 800a60a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800a60e:	2b00      	cmp	r3, #0
 800a610:	f000 8214 	beq.w	800aa3c <HAL_DMA_IRQHandler+0x10c0>
    {
      /* Disable the FIFO Error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_FE);
 800a614:	687b      	ldr	r3, [r7, #4]
 800a616:	681b      	ldr	r3, [r3, #0]
 800a618:	687a      	ldr	r2, [r7, #4]
 800a61a:	6812      	ldr	r2, [r2, #0]
 800a61c:	6952      	ldr	r2, [r2, #20]
 800a61e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800a622:	615a      	str	r2, [r3, #20]

      /* Clear the FIFO error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 800a624:	687b      	ldr	r3, [r7, #4]
 800a626:	681b      	ldr	r3, [r3, #0]
 800a628:	461a      	mov	r2, r3
 800a62a:	4b6f      	ldr	r3, [pc, #444]	; (800a7e8 <HAL_DMA_IRQHandler+0xe6c>)
 800a62c:	429a      	cmp	r2, r3
 800a62e:	d968      	bls.n	800a702 <HAL_DMA_IRQHandler+0xd86>
 800a630:	4a6e      	ldr	r2, [pc, #440]	; (800a7ec <HAL_DMA_IRQHandler+0xe70>)
 800a632:	687b      	ldr	r3, [r7, #4]
 800a634:	681b      	ldr	r3, [r3, #0]
 800a636:	4619      	mov	r1, r3
 800a638:	4b6d      	ldr	r3, [pc, #436]	; (800a7f0 <HAL_DMA_IRQHandler+0xe74>)
 800a63a:	4299      	cmp	r1, r3
 800a63c:	d05e      	beq.n	800a6fc <HAL_DMA_IRQHandler+0xd80>
 800a63e:	687b      	ldr	r3, [r7, #4]
 800a640:	681b      	ldr	r3, [r3, #0]
 800a642:	4619      	mov	r1, r3
 800a644:	4b6b      	ldr	r3, [pc, #428]	; (800a7f4 <HAL_DMA_IRQHandler+0xe78>)
 800a646:	4299      	cmp	r1, r3
 800a648:	d056      	beq.n	800a6f8 <HAL_DMA_IRQHandler+0xd7c>
 800a64a:	687b      	ldr	r3, [r7, #4]
 800a64c:	681b      	ldr	r3, [r3, #0]
 800a64e:	4619      	mov	r1, r3
 800a650:	4b69      	ldr	r3, [pc, #420]	; (800a7f8 <HAL_DMA_IRQHandler+0xe7c>)
 800a652:	4299      	cmp	r1, r3
 800a654:	d04e      	beq.n	800a6f4 <HAL_DMA_IRQHandler+0xd78>
 800a656:	687b      	ldr	r3, [r7, #4]
 800a658:	681b      	ldr	r3, [r3, #0]
 800a65a:	4619      	mov	r1, r3
 800a65c:	4b67      	ldr	r3, [pc, #412]	; (800a7fc <HAL_DMA_IRQHandler+0xe80>)
 800a65e:	4299      	cmp	r1, r3
 800a660:	d046      	beq.n	800a6f0 <HAL_DMA_IRQHandler+0xd74>
 800a662:	687b      	ldr	r3, [r7, #4]
 800a664:	681b      	ldr	r3, [r3, #0]
 800a666:	4619      	mov	r1, r3
 800a668:	4b65      	ldr	r3, [pc, #404]	; (800a800 <HAL_DMA_IRQHandler+0xe84>)
 800a66a:	4299      	cmp	r1, r3
 800a66c:	d03e      	beq.n	800a6ec <HAL_DMA_IRQHandler+0xd70>
 800a66e:	687b      	ldr	r3, [r7, #4]
 800a670:	681b      	ldr	r3, [r3, #0]
 800a672:	4619      	mov	r1, r3
 800a674:	4b63      	ldr	r3, [pc, #396]	; (800a804 <HAL_DMA_IRQHandler+0xe88>)
 800a676:	4299      	cmp	r1, r3
 800a678:	d036      	beq.n	800a6e8 <HAL_DMA_IRQHandler+0xd6c>
 800a67a:	687b      	ldr	r3, [r7, #4]
 800a67c:	681b      	ldr	r3, [r3, #0]
 800a67e:	4619      	mov	r1, r3
 800a680:	4b61      	ldr	r3, [pc, #388]	; (800a808 <HAL_DMA_IRQHandler+0xe8c>)
 800a682:	4299      	cmp	r1, r3
 800a684:	d02e      	beq.n	800a6e4 <HAL_DMA_IRQHandler+0xd68>
 800a686:	687b      	ldr	r3, [r7, #4]
 800a688:	681b      	ldr	r3, [r3, #0]
 800a68a:	4619      	mov	r1, r3
 800a68c:	4b5f      	ldr	r3, [pc, #380]	; (800a80c <HAL_DMA_IRQHandler+0xe90>)
 800a68e:	4299      	cmp	r1, r3
 800a690:	d026      	beq.n	800a6e0 <HAL_DMA_IRQHandler+0xd64>
 800a692:	687b      	ldr	r3, [r7, #4]
 800a694:	681b      	ldr	r3, [r3, #0]
 800a696:	4619      	mov	r1, r3
 800a698:	4b5d      	ldr	r3, [pc, #372]	; (800a810 <HAL_DMA_IRQHandler+0xe94>)
 800a69a:	4299      	cmp	r1, r3
 800a69c:	d01d      	beq.n	800a6da <HAL_DMA_IRQHandler+0xd5e>
 800a69e:	687b      	ldr	r3, [r7, #4]
 800a6a0:	681b      	ldr	r3, [r3, #0]
 800a6a2:	4619      	mov	r1, r3
 800a6a4:	4b5b      	ldr	r3, [pc, #364]	; (800a814 <HAL_DMA_IRQHandler+0xe98>)
 800a6a6:	4299      	cmp	r1, r3
 800a6a8:	d014      	beq.n	800a6d4 <HAL_DMA_IRQHandler+0xd58>
 800a6aa:	687b      	ldr	r3, [r7, #4]
 800a6ac:	681b      	ldr	r3, [r3, #0]
 800a6ae:	4619      	mov	r1, r3
 800a6b0:	4b59      	ldr	r3, [pc, #356]	; (800a818 <HAL_DMA_IRQHandler+0xe9c>)
 800a6b2:	4299      	cmp	r1, r3
 800a6b4:	d00b      	beq.n	800a6ce <HAL_DMA_IRQHandler+0xd52>
 800a6b6:	687b      	ldr	r3, [r7, #4]
 800a6b8:	681b      	ldr	r3, [r3, #0]
 800a6ba:	4619      	mov	r1, r3
 800a6bc:	4b57      	ldr	r3, [pc, #348]	; (800a81c <HAL_DMA_IRQHandler+0xea0>)
 800a6be:	4299      	cmp	r1, r3
 800a6c0:	d102      	bne.n	800a6c8 <HAL_DMA_IRQHandler+0xd4c>
 800a6c2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a6c6:	e01a      	b.n	800a6fe <HAL_DMA_IRQHandler+0xd82>
 800a6c8:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800a6cc:	e017      	b.n	800a6fe <HAL_DMA_IRQHandler+0xd82>
 800a6ce:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a6d2:	e014      	b.n	800a6fe <HAL_DMA_IRQHandler+0xd82>
 800a6d4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a6d8:	e011      	b.n	800a6fe <HAL_DMA_IRQHandler+0xd82>
 800a6da:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a6de:	e00e      	b.n	800a6fe <HAL_DMA_IRQHandler+0xd82>
 800a6e0:	2340      	movs	r3, #64	; 0x40
 800a6e2:	e00c      	b.n	800a6fe <HAL_DMA_IRQHandler+0xd82>
 800a6e4:	2340      	movs	r3, #64	; 0x40
 800a6e6:	e00a      	b.n	800a6fe <HAL_DMA_IRQHandler+0xd82>
 800a6e8:	2340      	movs	r3, #64	; 0x40
 800a6ea:	e008      	b.n	800a6fe <HAL_DMA_IRQHandler+0xd82>
 800a6ec:	2340      	movs	r3, #64	; 0x40
 800a6ee:	e006      	b.n	800a6fe <HAL_DMA_IRQHandler+0xd82>
 800a6f0:	4b3c      	ldr	r3, [pc, #240]	; (800a7e4 <HAL_DMA_IRQHandler+0xe68>)
 800a6f2:	e004      	b.n	800a6fe <HAL_DMA_IRQHandler+0xd82>
 800a6f4:	4b3b      	ldr	r3, [pc, #236]	; (800a7e4 <HAL_DMA_IRQHandler+0xe68>)
 800a6f6:	e002      	b.n	800a6fe <HAL_DMA_IRQHandler+0xd82>
 800a6f8:	4b3a      	ldr	r3, [pc, #232]	; (800a7e4 <HAL_DMA_IRQHandler+0xe68>)
 800a6fa:	e000      	b.n	800a6fe <HAL_DMA_IRQHandler+0xd82>
 800a6fc:	4b39      	ldr	r3, [pc, #228]	; (800a7e4 <HAL_DMA_IRQHandler+0xe68>)
 800a6fe:	60d3      	str	r3, [r2, #12]
 800a700:	e186      	b.n	800aa10 <HAL_DMA_IRQHandler+0x1094>
 800a702:	687b      	ldr	r3, [r7, #4]
 800a704:	681b      	ldr	r3, [r3, #0]
 800a706:	461a      	mov	r2, r3
 800a708:	4b45      	ldr	r3, [pc, #276]	; (800a820 <HAL_DMA_IRQHandler+0xea4>)
 800a70a:	429a      	cmp	r2, r3
 800a70c:	f240 808a 	bls.w	800a824 <HAL_DMA_IRQHandler+0xea8>
 800a710:	4a36      	ldr	r2, [pc, #216]	; (800a7ec <HAL_DMA_IRQHandler+0xe70>)
 800a712:	687b      	ldr	r3, [r7, #4]
 800a714:	681b      	ldr	r3, [r3, #0]
 800a716:	4619      	mov	r1, r3
 800a718:	4b35      	ldr	r3, [pc, #212]	; (800a7f0 <HAL_DMA_IRQHandler+0xe74>)
 800a71a:	4299      	cmp	r1, r3
 800a71c:	d05e      	beq.n	800a7dc <HAL_DMA_IRQHandler+0xe60>
 800a71e:	687b      	ldr	r3, [r7, #4]
 800a720:	681b      	ldr	r3, [r3, #0]
 800a722:	4619      	mov	r1, r3
 800a724:	4b33      	ldr	r3, [pc, #204]	; (800a7f4 <HAL_DMA_IRQHandler+0xe78>)
 800a726:	4299      	cmp	r1, r3
 800a728:	d056      	beq.n	800a7d8 <HAL_DMA_IRQHandler+0xe5c>
 800a72a:	687b      	ldr	r3, [r7, #4]
 800a72c:	681b      	ldr	r3, [r3, #0]
 800a72e:	4619      	mov	r1, r3
 800a730:	4b31      	ldr	r3, [pc, #196]	; (800a7f8 <HAL_DMA_IRQHandler+0xe7c>)
 800a732:	4299      	cmp	r1, r3
 800a734:	d04e      	beq.n	800a7d4 <HAL_DMA_IRQHandler+0xe58>
 800a736:	687b      	ldr	r3, [r7, #4]
 800a738:	681b      	ldr	r3, [r3, #0]
 800a73a:	4619      	mov	r1, r3
 800a73c:	4b2f      	ldr	r3, [pc, #188]	; (800a7fc <HAL_DMA_IRQHandler+0xe80>)
 800a73e:	4299      	cmp	r1, r3
 800a740:	d046      	beq.n	800a7d0 <HAL_DMA_IRQHandler+0xe54>
 800a742:	687b      	ldr	r3, [r7, #4]
 800a744:	681b      	ldr	r3, [r3, #0]
 800a746:	4619      	mov	r1, r3
 800a748:	4b2d      	ldr	r3, [pc, #180]	; (800a800 <HAL_DMA_IRQHandler+0xe84>)
 800a74a:	4299      	cmp	r1, r3
 800a74c:	d03e      	beq.n	800a7cc <HAL_DMA_IRQHandler+0xe50>
 800a74e:	687b      	ldr	r3, [r7, #4]
 800a750:	681b      	ldr	r3, [r3, #0]
 800a752:	4619      	mov	r1, r3
 800a754:	4b2b      	ldr	r3, [pc, #172]	; (800a804 <HAL_DMA_IRQHandler+0xe88>)
 800a756:	4299      	cmp	r1, r3
 800a758:	d036      	beq.n	800a7c8 <HAL_DMA_IRQHandler+0xe4c>
 800a75a:	687b      	ldr	r3, [r7, #4]
 800a75c:	681b      	ldr	r3, [r3, #0]
 800a75e:	4619      	mov	r1, r3
 800a760:	4b29      	ldr	r3, [pc, #164]	; (800a808 <HAL_DMA_IRQHandler+0xe8c>)
 800a762:	4299      	cmp	r1, r3
 800a764:	d02e      	beq.n	800a7c4 <HAL_DMA_IRQHandler+0xe48>
 800a766:	687b      	ldr	r3, [r7, #4]
 800a768:	681b      	ldr	r3, [r3, #0]
 800a76a:	4619      	mov	r1, r3
 800a76c:	4b27      	ldr	r3, [pc, #156]	; (800a80c <HAL_DMA_IRQHandler+0xe90>)
 800a76e:	4299      	cmp	r1, r3
 800a770:	d026      	beq.n	800a7c0 <HAL_DMA_IRQHandler+0xe44>
 800a772:	687b      	ldr	r3, [r7, #4]
 800a774:	681b      	ldr	r3, [r3, #0]
 800a776:	4619      	mov	r1, r3
 800a778:	4b25      	ldr	r3, [pc, #148]	; (800a810 <HAL_DMA_IRQHandler+0xe94>)
 800a77a:	4299      	cmp	r1, r3
 800a77c:	d01d      	beq.n	800a7ba <HAL_DMA_IRQHandler+0xe3e>
 800a77e:	687b      	ldr	r3, [r7, #4]
 800a780:	681b      	ldr	r3, [r3, #0]
 800a782:	4619      	mov	r1, r3
 800a784:	4b23      	ldr	r3, [pc, #140]	; (800a814 <HAL_DMA_IRQHandler+0xe98>)
 800a786:	4299      	cmp	r1, r3
 800a788:	d014      	beq.n	800a7b4 <HAL_DMA_IRQHandler+0xe38>
 800a78a:	687b      	ldr	r3, [r7, #4]
 800a78c:	681b      	ldr	r3, [r3, #0]
 800a78e:	4619      	mov	r1, r3
 800a790:	4b21      	ldr	r3, [pc, #132]	; (800a818 <HAL_DMA_IRQHandler+0xe9c>)
 800a792:	4299      	cmp	r1, r3
 800a794:	d00b      	beq.n	800a7ae <HAL_DMA_IRQHandler+0xe32>
 800a796:	687b      	ldr	r3, [r7, #4]
 800a798:	681b      	ldr	r3, [r3, #0]
 800a79a:	4619      	mov	r1, r3
 800a79c:	4b1f      	ldr	r3, [pc, #124]	; (800a81c <HAL_DMA_IRQHandler+0xea0>)
 800a79e:	4299      	cmp	r1, r3
 800a7a0:	d102      	bne.n	800a7a8 <HAL_DMA_IRQHandler+0xe2c>
 800a7a2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a7a6:	e01a      	b.n	800a7de <HAL_DMA_IRQHandler+0xe62>
 800a7a8:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800a7ac:	e017      	b.n	800a7de <HAL_DMA_IRQHandler+0xe62>
 800a7ae:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a7b2:	e014      	b.n	800a7de <HAL_DMA_IRQHandler+0xe62>
 800a7b4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a7b8:	e011      	b.n	800a7de <HAL_DMA_IRQHandler+0xe62>
 800a7ba:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a7be:	e00e      	b.n	800a7de <HAL_DMA_IRQHandler+0xe62>
 800a7c0:	2340      	movs	r3, #64	; 0x40
 800a7c2:	e00c      	b.n	800a7de <HAL_DMA_IRQHandler+0xe62>
 800a7c4:	2340      	movs	r3, #64	; 0x40
 800a7c6:	e00a      	b.n	800a7de <HAL_DMA_IRQHandler+0xe62>
 800a7c8:	2340      	movs	r3, #64	; 0x40
 800a7ca:	e008      	b.n	800a7de <HAL_DMA_IRQHandler+0xe62>
 800a7cc:	2340      	movs	r3, #64	; 0x40
 800a7ce:	e006      	b.n	800a7de <HAL_DMA_IRQHandler+0xe62>
 800a7d0:	4b04      	ldr	r3, [pc, #16]	; (800a7e4 <HAL_DMA_IRQHandler+0xe68>)
 800a7d2:	e004      	b.n	800a7de <HAL_DMA_IRQHandler+0xe62>
 800a7d4:	4b03      	ldr	r3, [pc, #12]	; (800a7e4 <HAL_DMA_IRQHandler+0xe68>)
 800a7d6:	e002      	b.n	800a7de <HAL_DMA_IRQHandler+0xe62>
 800a7d8:	4b02      	ldr	r3, [pc, #8]	; (800a7e4 <HAL_DMA_IRQHandler+0xe68>)
 800a7da:	e000      	b.n	800a7de <HAL_DMA_IRQHandler+0xe62>
 800a7dc:	4b01      	ldr	r3, [pc, #4]	; (800a7e4 <HAL_DMA_IRQHandler+0xe68>)
 800a7de:	6093      	str	r3, [r2, #8]
 800a7e0:	e116      	b.n	800aa10 <HAL_DMA_IRQHandler+0x1094>
 800a7e2:	bf00      	nop
 800a7e4:	00800001 	.word	0x00800001
 800a7e8:	40026458 	.word	0x40026458
 800a7ec:	40026400 	.word	0x40026400
 800a7f0:	40026010 	.word	0x40026010
 800a7f4:	40026410 	.word	0x40026410
 800a7f8:	40026070 	.word	0x40026070
 800a7fc:	40026470 	.word	0x40026470
 800a800:	40026028 	.word	0x40026028
 800a804:	40026428 	.word	0x40026428
 800a808:	40026088 	.word	0x40026088
 800a80c:	40026488 	.word	0x40026488
 800a810:	40026040 	.word	0x40026040
 800a814:	40026440 	.word	0x40026440
 800a818:	400260a0 	.word	0x400260a0
 800a81c:	400264a0 	.word	0x400264a0
 800a820:	400260b8 	.word	0x400260b8
 800a824:	687b      	ldr	r3, [r7, #4]
 800a826:	681b      	ldr	r3, [r3, #0]
 800a828:	461a      	mov	r2, r3
 800a82a:	4b69      	ldr	r3, [pc, #420]	; (800a9d0 <HAL_DMA_IRQHandler+0x1054>)
 800a82c:	429a      	cmp	r2, r3
 800a82e:	d968      	bls.n	800a902 <HAL_DMA_IRQHandler+0xf86>
 800a830:	4a68      	ldr	r2, [pc, #416]	; (800a9d4 <HAL_DMA_IRQHandler+0x1058>)
 800a832:	687b      	ldr	r3, [r7, #4]
 800a834:	681b      	ldr	r3, [r3, #0]
 800a836:	4619      	mov	r1, r3
 800a838:	4b67      	ldr	r3, [pc, #412]	; (800a9d8 <HAL_DMA_IRQHandler+0x105c>)
 800a83a:	4299      	cmp	r1, r3
 800a83c:	d05e      	beq.n	800a8fc <HAL_DMA_IRQHandler+0xf80>
 800a83e:	687b      	ldr	r3, [r7, #4]
 800a840:	681b      	ldr	r3, [r3, #0]
 800a842:	4619      	mov	r1, r3
 800a844:	4b65      	ldr	r3, [pc, #404]	; (800a9dc <HAL_DMA_IRQHandler+0x1060>)
 800a846:	4299      	cmp	r1, r3
 800a848:	d056      	beq.n	800a8f8 <HAL_DMA_IRQHandler+0xf7c>
 800a84a:	687b      	ldr	r3, [r7, #4]
 800a84c:	681b      	ldr	r3, [r3, #0]
 800a84e:	4619      	mov	r1, r3
 800a850:	4b63      	ldr	r3, [pc, #396]	; (800a9e0 <HAL_DMA_IRQHandler+0x1064>)
 800a852:	4299      	cmp	r1, r3
 800a854:	d04e      	beq.n	800a8f4 <HAL_DMA_IRQHandler+0xf78>
 800a856:	687b      	ldr	r3, [r7, #4]
 800a858:	681b      	ldr	r3, [r3, #0]
 800a85a:	4619      	mov	r1, r3
 800a85c:	4b61      	ldr	r3, [pc, #388]	; (800a9e4 <HAL_DMA_IRQHandler+0x1068>)
 800a85e:	4299      	cmp	r1, r3
 800a860:	d046      	beq.n	800a8f0 <HAL_DMA_IRQHandler+0xf74>
 800a862:	687b      	ldr	r3, [r7, #4]
 800a864:	681b      	ldr	r3, [r3, #0]
 800a866:	4619      	mov	r1, r3
 800a868:	4b5f      	ldr	r3, [pc, #380]	; (800a9e8 <HAL_DMA_IRQHandler+0x106c>)
 800a86a:	4299      	cmp	r1, r3
 800a86c:	d03e      	beq.n	800a8ec <HAL_DMA_IRQHandler+0xf70>
 800a86e:	687b      	ldr	r3, [r7, #4]
 800a870:	681b      	ldr	r3, [r3, #0]
 800a872:	4619      	mov	r1, r3
 800a874:	4b5d      	ldr	r3, [pc, #372]	; (800a9ec <HAL_DMA_IRQHandler+0x1070>)
 800a876:	4299      	cmp	r1, r3
 800a878:	d036      	beq.n	800a8e8 <HAL_DMA_IRQHandler+0xf6c>
 800a87a:	687b      	ldr	r3, [r7, #4]
 800a87c:	681b      	ldr	r3, [r3, #0]
 800a87e:	4619      	mov	r1, r3
 800a880:	4b5b      	ldr	r3, [pc, #364]	; (800a9f0 <HAL_DMA_IRQHandler+0x1074>)
 800a882:	4299      	cmp	r1, r3
 800a884:	d02e      	beq.n	800a8e4 <HAL_DMA_IRQHandler+0xf68>
 800a886:	687b      	ldr	r3, [r7, #4]
 800a888:	681b      	ldr	r3, [r3, #0]
 800a88a:	4619      	mov	r1, r3
 800a88c:	4b59      	ldr	r3, [pc, #356]	; (800a9f4 <HAL_DMA_IRQHandler+0x1078>)
 800a88e:	4299      	cmp	r1, r3
 800a890:	d026      	beq.n	800a8e0 <HAL_DMA_IRQHandler+0xf64>
 800a892:	687b      	ldr	r3, [r7, #4]
 800a894:	681b      	ldr	r3, [r3, #0]
 800a896:	4619      	mov	r1, r3
 800a898:	4b57      	ldr	r3, [pc, #348]	; (800a9f8 <HAL_DMA_IRQHandler+0x107c>)
 800a89a:	4299      	cmp	r1, r3
 800a89c:	d01d      	beq.n	800a8da <HAL_DMA_IRQHandler+0xf5e>
 800a89e:	687b      	ldr	r3, [r7, #4]
 800a8a0:	681b      	ldr	r3, [r3, #0]
 800a8a2:	4619      	mov	r1, r3
 800a8a4:	4b55      	ldr	r3, [pc, #340]	; (800a9fc <HAL_DMA_IRQHandler+0x1080>)
 800a8a6:	4299      	cmp	r1, r3
 800a8a8:	d014      	beq.n	800a8d4 <HAL_DMA_IRQHandler+0xf58>
 800a8aa:	687b      	ldr	r3, [r7, #4]
 800a8ac:	681b      	ldr	r3, [r3, #0]
 800a8ae:	4619      	mov	r1, r3
 800a8b0:	4b53      	ldr	r3, [pc, #332]	; (800aa00 <HAL_DMA_IRQHandler+0x1084>)
 800a8b2:	4299      	cmp	r1, r3
 800a8b4:	d00b      	beq.n	800a8ce <HAL_DMA_IRQHandler+0xf52>
 800a8b6:	687b      	ldr	r3, [r7, #4]
 800a8b8:	681b      	ldr	r3, [r3, #0]
 800a8ba:	4619      	mov	r1, r3
 800a8bc:	4b51      	ldr	r3, [pc, #324]	; (800aa04 <HAL_DMA_IRQHandler+0x1088>)
 800a8be:	4299      	cmp	r1, r3
 800a8c0:	d102      	bne.n	800a8c8 <HAL_DMA_IRQHandler+0xf4c>
 800a8c2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a8c6:	e01a      	b.n	800a8fe <HAL_DMA_IRQHandler+0xf82>
 800a8c8:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800a8cc:	e017      	b.n	800a8fe <HAL_DMA_IRQHandler+0xf82>
 800a8ce:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a8d2:	e014      	b.n	800a8fe <HAL_DMA_IRQHandler+0xf82>
 800a8d4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a8d8:	e011      	b.n	800a8fe <HAL_DMA_IRQHandler+0xf82>
 800a8da:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a8de:	e00e      	b.n	800a8fe <HAL_DMA_IRQHandler+0xf82>
 800a8e0:	2340      	movs	r3, #64	; 0x40
 800a8e2:	e00c      	b.n	800a8fe <HAL_DMA_IRQHandler+0xf82>
 800a8e4:	2340      	movs	r3, #64	; 0x40
 800a8e6:	e00a      	b.n	800a8fe <HAL_DMA_IRQHandler+0xf82>
 800a8e8:	2340      	movs	r3, #64	; 0x40
 800a8ea:	e008      	b.n	800a8fe <HAL_DMA_IRQHandler+0xf82>
 800a8ec:	2340      	movs	r3, #64	; 0x40
 800a8ee:	e006      	b.n	800a8fe <HAL_DMA_IRQHandler+0xf82>
 800a8f0:	4b45      	ldr	r3, [pc, #276]	; (800aa08 <HAL_DMA_IRQHandler+0x108c>)
 800a8f2:	e004      	b.n	800a8fe <HAL_DMA_IRQHandler+0xf82>
 800a8f4:	4b44      	ldr	r3, [pc, #272]	; (800aa08 <HAL_DMA_IRQHandler+0x108c>)
 800a8f6:	e002      	b.n	800a8fe <HAL_DMA_IRQHandler+0xf82>
 800a8f8:	4b43      	ldr	r3, [pc, #268]	; (800aa08 <HAL_DMA_IRQHandler+0x108c>)
 800a8fa:	e000      	b.n	800a8fe <HAL_DMA_IRQHandler+0xf82>
 800a8fc:	4b42      	ldr	r3, [pc, #264]	; (800aa08 <HAL_DMA_IRQHandler+0x108c>)
 800a8fe:	60d3      	str	r3, [r2, #12]
 800a900:	e086      	b.n	800aa10 <HAL_DMA_IRQHandler+0x1094>
 800a902:	4a34      	ldr	r2, [pc, #208]	; (800a9d4 <HAL_DMA_IRQHandler+0x1058>)
 800a904:	687b      	ldr	r3, [r7, #4]
 800a906:	681b      	ldr	r3, [r3, #0]
 800a908:	4619      	mov	r1, r3
 800a90a:	4b33      	ldr	r3, [pc, #204]	; (800a9d8 <HAL_DMA_IRQHandler+0x105c>)
 800a90c:	4299      	cmp	r1, r3
 800a90e:	d07d      	beq.n	800aa0c <HAL_DMA_IRQHandler+0x1090>
 800a910:	687b      	ldr	r3, [r7, #4]
 800a912:	681b      	ldr	r3, [r3, #0]
 800a914:	4619      	mov	r1, r3
 800a916:	4b31      	ldr	r3, [pc, #196]	; (800a9dc <HAL_DMA_IRQHandler+0x1060>)
 800a918:	4299      	cmp	r1, r3
 800a91a:	d056      	beq.n	800a9ca <HAL_DMA_IRQHandler+0x104e>
 800a91c:	687b      	ldr	r3, [r7, #4]
 800a91e:	681b      	ldr	r3, [r3, #0]
 800a920:	4619      	mov	r1, r3
 800a922:	4b2f      	ldr	r3, [pc, #188]	; (800a9e0 <HAL_DMA_IRQHandler+0x1064>)
 800a924:	4299      	cmp	r1, r3
 800a926:	d04e      	beq.n	800a9c6 <HAL_DMA_IRQHandler+0x104a>
 800a928:	687b      	ldr	r3, [r7, #4]
 800a92a:	681b      	ldr	r3, [r3, #0]
 800a92c:	4619      	mov	r1, r3
 800a92e:	4b2d      	ldr	r3, [pc, #180]	; (800a9e4 <HAL_DMA_IRQHandler+0x1068>)
 800a930:	4299      	cmp	r1, r3
 800a932:	d046      	beq.n	800a9c2 <HAL_DMA_IRQHandler+0x1046>
 800a934:	687b      	ldr	r3, [r7, #4]
 800a936:	681b      	ldr	r3, [r3, #0]
 800a938:	4619      	mov	r1, r3
 800a93a:	4b2b      	ldr	r3, [pc, #172]	; (800a9e8 <HAL_DMA_IRQHandler+0x106c>)
 800a93c:	4299      	cmp	r1, r3
 800a93e:	d03e      	beq.n	800a9be <HAL_DMA_IRQHandler+0x1042>
 800a940:	687b      	ldr	r3, [r7, #4]
 800a942:	681b      	ldr	r3, [r3, #0]
 800a944:	4619      	mov	r1, r3
 800a946:	4b29      	ldr	r3, [pc, #164]	; (800a9ec <HAL_DMA_IRQHandler+0x1070>)
 800a948:	4299      	cmp	r1, r3
 800a94a:	d036      	beq.n	800a9ba <HAL_DMA_IRQHandler+0x103e>
 800a94c:	687b      	ldr	r3, [r7, #4]
 800a94e:	681b      	ldr	r3, [r3, #0]
 800a950:	4619      	mov	r1, r3
 800a952:	4b27      	ldr	r3, [pc, #156]	; (800a9f0 <HAL_DMA_IRQHandler+0x1074>)
 800a954:	4299      	cmp	r1, r3
 800a956:	d02e      	beq.n	800a9b6 <HAL_DMA_IRQHandler+0x103a>
 800a958:	687b      	ldr	r3, [r7, #4]
 800a95a:	681b      	ldr	r3, [r3, #0]
 800a95c:	4619      	mov	r1, r3
 800a95e:	4b25      	ldr	r3, [pc, #148]	; (800a9f4 <HAL_DMA_IRQHandler+0x1078>)
 800a960:	4299      	cmp	r1, r3
 800a962:	d026      	beq.n	800a9b2 <HAL_DMA_IRQHandler+0x1036>
 800a964:	687b      	ldr	r3, [r7, #4]
 800a966:	681b      	ldr	r3, [r3, #0]
 800a968:	4619      	mov	r1, r3
 800a96a:	4b23      	ldr	r3, [pc, #140]	; (800a9f8 <HAL_DMA_IRQHandler+0x107c>)
 800a96c:	4299      	cmp	r1, r3
 800a96e:	d01d      	beq.n	800a9ac <HAL_DMA_IRQHandler+0x1030>
 800a970:	687b      	ldr	r3, [r7, #4]
 800a972:	681b      	ldr	r3, [r3, #0]
 800a974:	4619      	mov	r1, r3
 800a976:	4b21      	ldr	r3, [pc, #132]	; (800a9fc <HAL_DMA_IRQHandler+0x1080>)
 800a978:	4299      	cmp	r1, r3
 800a97a:	d014      	beq.n	800a9a6 <HAL_DMA_IRQHandler+0x102a>
 800a97c:	687b      	ldr	r3, [r7, #4]
 800a97e:	681b      	ldr	r3, [r3, #0]
 800a980:	4619      	mov	r1, r3
 800a982:	4b1f      	ldr	r3, [pc, #124]	; (800aa00 <HAL_DMA_IRQHandler+0x1084>)
 800a984:	4299      	cmp	r1, r3
 800a986:	d00b      	beq.n	800a9a0 <HAL_DMA_IRQHandler+0x1024>
 800a988:	687b      	ldr	r3, [r7, #4]
 800a98a:	681b      	ldr	r3, [r3, #0]
 800a98c:	4619      	mov	r1, r3
 800a98e:	4b1d      	ldr	r3, [pc, #116]	; (800aa04 <HAL_DMA_IRQHandler+0x1088>)
 800a990:	4299      	cmp	r1, r3
 800a992:	d102      	bne.n	800a99a <HAL_DMA_IRQHandler+0x101e>
 800a994:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a998:	e039      	b.n	800aa0e <HAL_DMA_IRQHandler+0x1092>
 800a99a:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800a99e:	e036      	b.n	800aa0e <HAL_DMA_IRQHandler+0x1092>
 800a9a0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a9a4:	e033      	b.n	800aa0e <HAL_DMA_IRQHandler+0x1092>
 800a9a6:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a9aa:	e030      	b.n	800aa0e <HAL_DMA_IRQHandler+0x1092>
 800a9ac:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a9b0:	e02d      	b.n	800aa0e <HAL_DMA_IRQHandler+0x1092>
 800a9b2:	2340      	movs	r3, #64	; 0x40
 800a9b4:	e02b      	b.n	800aa0e <HAL_DMA_IRQHandler+0x1092>
 800a9b6:	2340      	movs	r3, #64	; 0x40
 800a9b8:	e029      	b.n	800aa0e <HAL_DMA_IRQHandler+0x1092>
 800a9ba:	2340      	movs	r3, #64	; 0x40
 800a9bc:	e027      	b.n	800aa0e <HAL_DMA_IRQHandler+0x1092>
 800a9be:	2340      	movs	r3, #64	; 0x40
 800a9c0:	e025      	b.n	800aa0e <HAL_DMA_IRQHandler+0x1092>
 800a9c2:	4b11      	ldr	r3, [pc, #68]	; (800aa08 <HAL_DMA_IRQHandler+0x108c>)
 800a9c4:	e023      	b.n	800aa0e <HAL_DMA_IRQHandler+0x1092>
 800a9c6:	4b10      	ldr	r3, [pc, #64]	; (800aa08 <HAL_DMA_IRQHandler+0x108c>)
 800a9c8:	e021      	b.n	800aa0e <HAL_DMA_IRQHandler+0x1092>
 800a9ca:	4b0f      	ldr	r3, [pc, #60]	; (800aa08 <HAL_DMA_IRQHandler+0x108c>)
 800a9cc:	e01f      	b.n	800aa0e <HAL_DMA_IRQHandler+0x1092>
 800a9ce:	bf00      	nop
 800a9d0:	40026058 	.word	0x40026058
 800a9d4:	40026000 	.word	0x40026000
 800a9d8:	40026010 	.word	0x40026010
 800a9dc:	40026410 	.word	0x40026410
 800a9e0:	40026070 	.word	0x40026070
 800a9e4:	40026470 	.word	0x40026470
 800a9e8:	40026028 	.word	0x40026028
 800a9ec:	40026428 	.word	0x40026428
 800a9f0:	40026088 	.word	0x40026088
 800a9f4:	40026488 	.word	0x40026488
 800a9f8:	40026040 	.word	0x40026040
 800a9fc:	40026440 	.word	0x40026440
 800aa00:	400260a0 	.word	0x400260a0
 800aa04:	400264a0 	.word	0x400264a0
 800aa08:	00800001 	.word	0x00800001
 800aa0c:	4b85      	ldr	r3, [pc, #532]	; (800ac24 <HAL_DMA_IRQHandler+0x12a8>)
 800aa0e:	6093      	str	r3, [r2, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 800aa10:	687b      	ldr	r3, [r7, #4]
 800aa12:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800aa14:	f043 0202 	orr.w	r2, r3, #2
 800aa18:	687b      	ldr	r3, [r7, #4]
 800aa1a:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
 800aa1c:	687b      	ldr	r3, [r7, #4]
 800aa1e:	2204      	movs	r2, #4
 800aa20:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 800aa24:	687b      	ldr	r3, [r7, #4]
 800aa26:	2200      	movs	r2, #0
 800aa28:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      if(hdma->XferErrorCallback != NULL)
 800aa2c:	687b      	ldr	r3, [r7, #4]
 800aa2e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800aa30:	2b00      	cmp	r3, #0
 800aa32:	d003      	beq.n	800aa3c <HAL_DMA_IRQHandler+0x10c0>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 800aa34:	687b      	ldr	r3, [r7, #4]
 800aa36:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800aa38:	6878      	ldr	r0, [r7, #4]
 800aa3a:	4798      	blx	r3
      }
    }
  }
  /* Direct Mode Error Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 800aa3c:	687b      	ldr	r3, [r7, #4]
 800aa3e:	681b      	ldr	r3, [r3, #0]
 800aa40:	461a      	mov	r2, r3
 800aa42:	4b79      	ldr	r3, [pc, #484]	; (800ac28 <HAL_DMA_IRQHandler+0x12ac>)
 800aa44:	429a      	cmp	r2, r3
 800aa46:	d972      	bls.n	800ab2e <HAL_DMA_IRQHandler+0x11b2>
 800aa48:	4b78      	ldr	r3, [pc, #480]	; (800ac2c <HAL_DMA_IRQHandler+0x12b0>)
 800aa4a:	685a      	ldr	r2, [r3, #4]
 800aa4c:	687b      	ldr	r3, [r7, #4]
 800aa4e:	681b      	ldr	r3, [r3, #0]
 800aa50:	4619      	mov	r1, r3
 800aa52:	4b77      	ldr	r3, [pc, #476]	; (800ac30 <HAL_DMA_IRQHandler+0x12b4>)
 800aa54:	4299      	cmp	r1, r3
 800aa56:	d062      	beq.n	800ab1e <HAL_DMA_IRQHandler+0x11a2>
 800aa58:	687b      	ldr	r3, [r7, #4]
 800aa5a:	681b      	ldr	r3, [r3, #0]
 800aa5c:	4619      	mov	r1, r3
 800aa5e:	4b75      	ldr	r3, [pc, #468]	; (800ac34 <HAL_DMA_IRQHandler+0x12b8>)
 800aa60:	4299      	cmp	r1, r3
 800aa62:	d05a      	beq.n	800ab1a <HAL_DMA_IRQHandler+0x119e>
 800aa64:	687b      	ldr	r3, [r7, #4]
 800aa66:	681b      	ldr	r3, [r3, #0]
 800aa68:	4619      	mov	r1, r3
 800aa6a:	4b73      	ldr	r3, [pc, #460]	; (800ac38 <HAL_DMA_IRQHandler+0x12bc>)
 800aa6c:	4299      	cmp	r1, r3
 800aa6e:	d052      	beq.n	800ab16 <HAL_DMA_IRQHandler+0x119a>
 800aa70:	687b      	ldr	r3, [r7, #4]
 800aa72:	681b      	ldr	r3, [r3, #0]
 800aa74:	4619      	mov	r1, r3
 800aa76:	4b71      	ldr	r3, [pc, #452]	; (800ac3c <HAL_DMA_IRQHandler+0x12c0>)
 800aa78:	4299      	cmp	r1, r3
 800aa7a:	d04a      	beq.n	800ab12 <HAL_DMA_IRQHandler+0x1196>
 800aa7c:	687b      	ldr	r3, [r7, #4]
 800aa7e:	681b      	ldr	r3, [r3, #0]
 800aa80:	4619      	mov	r1, r3
 800aa82:	4b6f      	ldr	r3, [pc, #444]	; (800ac40 <HAL_DMA_IRQHandler+0x12c4>)
 800aa84:	4299      	cmp	r1, r3
 800aa86:	d041      	beq.n	800ab0c <HAL_DMA_IRQHandler+0x1190>
 800aa88:	687b      	ldr	r3, [r7, #4]
 800aa8a:	681b      	ldr	r3, [r3, #0]
 800aa8c:	4619      	mov	r1, r3
 800aa8e:	4b6d      	ldr	r3, [pc, #436]	; (800ac44 <HAL_DMA_IRQHandler+0x12c8>)
 800aa90:	4299      	cmp	r1, r3
 800aa92:	d038      	beq.n	800ab06 <HAL_DMA_IRQHandler+0x118a>
 800aa94:	687b      	ldr	r3, [r7, #4]
 800aa96:	681b      	ldr	r3, [r3, #0]
 800aa98:	4619      	mov	r1, r3
 800aa9a:	4b6b      	ldr	r3, [pc, #428]	; (800ac48 <HAL_DMA_IRQHandler+0x12cc>)
 800aa9c:	4299      	cmp	r1, r3
 800aa9e:	d02f      	beq.n	800ab00 <HAL_DMA_IRQHandler+0x1184>
 800aaa0:	687b      	ldr	r3, [r7, #4]
 800aaa2:	681b      	ldr	r3, [r3, #0]
 800aaa4:	4619      	mov	r1, r3
 800aaa6:	4b69      	ldr	r3, [pc, #420]	; (800ac4c <HAL_DMA_IRQHandler+0x12d0>)
 800aaa8:	4299      	cmp	r1, r3
 800aaaa:	d026      	beq.n	800aafa <HAL_DMA_IRQHandler+0x117e>
 800aaac:	687b      	ldr	r3, [r7, #4]
 800aaae:	681b      	ldr	r3, [r3, #0]
 800aab0:	4619      	mov	r1, r3
 800aab2:	4b67      	ldr	r3, [pc, #412]	; (800ac50 <HAL_DMA_IRQHandler+0x12d4>)
 800aab4:	4299      	cmp	r1, r3
 800aab6:	d01d      	beq.n	800aaf4 <HAL_DMA_IRQHandler+0x1178>
 800aab8:	687b      	ldr	r3, [r7, #4]
 800aaba:	681b      	ldr	r3, [r3, #0]
 800aabc:	4619      	mov	r1, r3
 800aabe:	4b65      	ldr	r3, [pc, #404]	; (800ac54 <HAL_DMA_IRQHandler+0x12d8>)
 800aac0:	4299      	cmp	r1, r3
 800aac2:	d014      	beq.n	800aaee <HAL_DMA_IRQHandler+0x1172>
 800aac4:	687b      	ldr	r3, [r7, #4]
 800aac6:	681b      	ldr	r3, [r3, #0]
 800aac8:	4619      	mov	r1, r3
 800aaca:	4b63      	ldr	r3, [pc, #396]	; (800ac58 <HAL_DMA_IRQHandler+0x12dc>)
 800aacc:	4299      	cmp	r1, r3
 800aace:	d00b      	beq.n	800aae8 <HAL_DMA_IRQHandler+0x116c>
 800aad0:	687b      	ldr	r3, [r7, #4]
 800aad2:	681b      	ldr	r3, [r3, #0]
 800aad4:	4619      	mov	r1, r3
 800aad6:	4b61      	ldr	r3, [pc, #388]	; (800ac5c <HAL_DMA_IRQHandler+0x12e0>)
 800aad8:	4299      	cmp	r1, r3
 800aada:	d102      	bne.n	800aae2 <HAL_DMA_IRQHandler+0x1166>
 800aadc:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800aae0:	e01e      	b.n	800ab20 <HAL_DMA_IRQHandler+0x11a4>
 800aae2:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800aae6:	e01b      	b.n	800ab20 <HAL_DMA_IRQHandler+0x11a4>
 800aae8:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800aaec:	e018      	b.n	800ab20 <HAL_DMA_IRQHandler+0x11a4>
 800aaee:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800aaf2:	e015      	b.n	800ab20 <HAL_DMA_IRQHandler+0x11a4>
 800aaf4:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800aaf8:	e012      	b.n	800ab20 <HAL_DMA_IRQHandler+0x11a4>
 800aafa:	f44f 7380 	mov.w	r3, #256	; 0x100
 800aafe:	e00f      	b.n	800ab20 <HAL_DMA_IRQHandler+0x11a4>
 800ab00:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ab04:	e00c      	b.n	800ab20 <HAL_DMA_IRQHandler+0x11a4>
 800ab06:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ab0a:	e009      	b.n	800ab20 <HAL_DMA_IRQHandler+0x11a4>
 800ab0c:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ab10:	e006      	b.n	800ab20 <HAL_DMA_IRQHandler+0x11a4>
 800ab12:	4b53      	ldr	r3, [pc, #332]	; (800ac60 <HAL_DMA_IRQHandler+0x12e4>)
 800ab14:	e004      	b.n	800ab20 <HAL_DMA_IRQHandler+0x11a4>
 800ab16:	4b52      	ldr	r3, [pc, #328]	; (800ac60 <HAL_DMA_IRQHandler+0x12e4>)
 800ab18:	e002      	b.n	800ab20 <HAL_DMA_IRQHandler+0x11a4>
 800ab1a:	4b51      	ldr	r3, [pc, #324]	; (800ac60 <HAL_DMA_IRQHandler+0x12e4>)
 800ab1c:	e000      	b.n	800ab20 <HAL_DMA_IRQHandler+0x11a4>
 800ab1e:	4b50      	ldr	r3, [pc, #320]	; (800ac60 <HAL_DMA_IRQHandler+0x12e4>)
 800ab20:	4013      	ands	r3, r2
 800ab22:	2b00      	cmp	r3, #0
 800ab24:	bf14      	ite	ne
 800ab26:	2301      	movne	r3, #1
 800ab28:	2300      	moveq	r3, #0
 800ab2a:	b2db      	uxtb	r3, r3
 800ab2c:	e1a7      	b.n	800ae7e <HAL_DMA_IRQHandler+0x1502>
 800ab2e:	687b      	ldr	r3, [r7, #4]
 800ab30:	681b      	ldr	r3, [r3, #0]
 800ab32:	461a      	mov	r2, r3
 800ab34:	4b4b      	ldr	r3, [pc, #300]	; (800ac64 <HAL_DMA_IRQHandler+0x12e8>)
 800ab36:	429a      	cmp	r2, r3
 800ab38:	f240 8096 	bls.w	800ac68 <HAL_DMA_IRQHandler+0x12ec>
 800ab3c:	4b3b      	ldr	r3, [pc, #236]	; (800ac2c <HAL_DMA_IRQHandler+0x12b0>)
 800ab3e:	681a      	ldr	r2, [r3, #0]
 800ab40:	687b      	ldr	r3, [r7, #4]
 800ab42:	681b      	ldr	r3, [r3, #0]
 800ab44:	4619      	mov	r1, r3
 800ab46:	4b3a      	ldr	r3, [pc, #232]	; (800ac30 <HAL_DMA_IRQHandler+0x12b4>)
 800ab48:	4299      	cmp	r1, r3
 800ab4a:	d062      	beq.n	800ac12 <HAL_DMA_IRQHandler+0x1296>
 800ab4c:	687b      	ldr	r3, [r7, #4]
 800ab4e:	681b      	ldr	r3, [r3, #0]
 800ab50:	4619      	mov	r1, r3
 800ab52:	4b38      	ldr	r3, [pc, #224]	; (800ac34 <HAL_DMA_IRQHandler+0x12b8>)
 800ab54:	4299      	cmp	r1, r3
 800ab56:	d05a      	beq.n	800ac0e <HAL_DMA_IRQHandler+0x1292>
 800ab58:	687b      	ldr	r3, [r7, #4]
 800ab5a:	681b      	ldr	r3, [r3, #0]
 800ab5c:	4619      	mov	r1, r3
 800ab5e:	4b36      	ldr	r3, [pc, #216]	; (800ac38 <HAL_DMA_IRQHandler+0x12bc>)
 800ab60:	4299      	cmp	r1, r3
 800ab62:	d052      	beq.n	800ac0a <HAL_DMA_IRQHandler+0x128e>
 800ab64:	687b      	ldr	r3, [r7, #4]
 800ab66:	681b      	ldr	r3, [r3, #0]
 800ab68:	4619      	mov	r1, r3
 800ab6a:	4b34      	ldr	r3, [pc, #208]	; (800ac3c <HAL_DMA_IRQHandler+0x12c0>)
 800ab6c:	4299      	cmp	r1, r3
 800ab6e:	d04a      	beq.n	800ac06 <HAL_DMA_IRQHandler+0x128a>
 800ab70:	687b      	ldr	r3, [r7, #4]
 800ab72:	681b      	ldr	r3, [r3, #0]
 800ab74:	4619      	mov	r1, r3
 800ab76:	4b32      	ldr	r3, [pc, #200]	; (800ac40 <HAL_DMA_IRQHandler+0x12c4>)
 800ab78:	4299      	cmp	r1, r3
 800ab7a:	d041      	beq.n	800ac00 <HAL_DMA_IRQHandler+0x1284>
 800ab7c:	687b      	ldr	r3, [r7, #4]
 800ab7e:	681b      	ldr	r3, [r3, #0]
 800ab80:	4619      	mov	r1, r3
 800ab82:	4b30      	ldr	r3, [pc, #192]	; (800ac44 <HAL_DMA_IRQHandler+0x12c8>)
 800ab84:	4299      	cmp	r1, r3
 800ab86:	d038      	beq.n	800abfa <HAL_DMA_IRQHandler+0x127e>
 800ab88:	687b      	ldr	r3, [r7, #4]
 800ab8a:	681b      	ldr	r3, [r3, #0]
 800ab8c:	4619      	mov	r1, r3
 800ab8e:	4b2e      	ldr	r3, [pc, #184]	; (800ac48 <HAL_DMA_IRQHandler+0x12cc>)
 800ab90:	4299      	cmp	r1, r3
 800ab92:	d02f      	beq.n	800abf4 <HAL_DMA_IRQHandler+0x1278>
 800ab94:	687b      	ldr	r3, [r7, #4]
 800ab96:	681b      	ldr	r3, [r3, #0]
 800ab98:	4619      	mov	r1, r3
 800ab9a:	4b2c      	ldr	r3, [pc, #176]	; (800ac4c <HAL_DMA_IRQHandler+0x12d0>)
 800ab9c:	4299      	cmp	r1, r3
 800ab9e:	d026      	beq.n	800abee <HAL_DMA_IRQHandler+0x1272>
 800aba0:	687b      	ldr	r3, [r7, #4]
 800aba2:	681b      	ldr	r3, [r3, #0]
 800aba4:	4619      	mov	r1, r3
 800aba6:	4b2a      	ldr	r3, [pc, #168]	; (800ac50 <HAL_DMA_IRQHandler+0x12d4>)
 800aba8:	4299      	cmp	r1, r3
 800abaa:	d01d      	beq.n	800abe8 <HAL_DMA_IRQHandler+0x126c>
 800abac:	687b      	ldr	r3, [r7, #4]
 800abae:	681b      	ldr	r3, [r3, #0]
 800abb0:	4619      	mov	r1, r3
 800abb2:	4b28      	ldr	r3, [pc, #160]	; (800ac54 <HAL_DMA_IRQHandler+0x12d8>)
 800abb4:	4299      	cmp	r1, r3
 800abb6:	d014      	beq.n	800abe2 <HAL_DMA_IRQHandler+0x1266>
 800abb8:	687b      	ldr	r3, [r7, #4]
 800abba:	681b      	ldr	r3, [r3, #0]
 800abbc:	4619      	mov	r1, r3
 800abbe:	4b26      	ldr	r3, [pc, #152]	; (800ac58 <HAL_DMA_IRQHandler+0x12dc>)
 800abc0:	4299      	cmp	r1, r3
 800abc2:	d00b      	beq.n	800abdc <HAL_DMA_IRQHandler+0x1260>
 800abc4:	687b      	ldr	r3, [r7, #4]
 800abc6:	681b      	ldr	r3, [r3, #0]
 800abc8:	4619      	mov	r1, r3
 800abca:	4b24      	ldr	r3, [pc, #144]	; (800ac5c <HAL_DMA_IRQHandler+0x12e0>)
 800abcc:	4299      	cmp	r1, r3
 800abce:	d102      	bne.n	800abd6 <HAL_DMA_IRQHandler+0x125a>
 800abd0:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800abd4:	e01e      	b.n	800ac14 <HAL_DMA_IRQHandler+0x1298>
 800abd6:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800abda:	e01b      	b.n	800ac14 <HAL_DMA_IRQHandler+0x1298>
 800abdc:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800abe0:	e018      	b.n	800ac14 <HAL_DMA_IRQHandler+0x1298>
 800abe2:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800abe6:	e015      	b.n	800ac14 <HAL_DMA_IRQHandler+0x1298>
 800abe8:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800abec:	e012      	b.n	800ac14 <HAL_DMA_IRQHandler+0x1298>
 800abee:	f44f 7380 	mov.w	r3, #256	; 0x100
 800abf2:	e00f      	b.n	800ac14 <HAL_DMA_IRQHandler+0x1298>
 800abf4:	f44f 7380 	mov.w	r3, #256	; 0x100
 800abf8:	e00c      	b.n	800ac14 <HAL_DMA_IRQHandler+0x1298>
 800abfa:	f44f 7380 	mov.w	r3, #256	; 0x100
 800abfe:	e009      	b.n	800ac14 <HAL_DMA_IRQHandler+0x1298>
 800ac00:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ac04:	e006      	b.n	800ac14 <HAL_DMA_IRQHandler+0x1298>
 800ac06:	4b16      	ldr	r3, [pc, #88]	; (800ac60 <HAL_DMA_IRQHandler+0x12e4>)
 800ac08:	e004      	b.n	800ac14 <HAL_DMA_IRQHandler+0x1298>
 800ac0a:	4b15      	ldr	r3, [pc, #84]	; (800ac60 <HAL_DMA_IRQHandler+0x12e4>)
 800ac0c:	e002      	b.n	800ac14 <HAL_DMA_IRQHandler+0x1298>
 800ac0e:	4b14      	ldr	r3, [pc, #80]	; (800ac60 <HAL_DMA_IRQHandler+0x12e4>)
 800ac10:	e000      	b.n	800ac14 <HAL_DMA_IRQHandler+0x1298>
 800ac12:	4b13      	ldr	r3, [pc, #76]	; (800ac60 <HAL_DMA_IRQHandler+0x12e4>)
 800ac14:	4013      	ands	r3, r2
 800ac16:	2b00      	cmp	r3, #0
 800ac18:	bf14      	ite	ne
 800ac1a:	2301      	movne	r3, #1
 800ac1c:	2300      	moveq	r3, #0
 800ac1e:	b2db      	uxtb	r3, r3
 800ac20:	e12d      	b.n	800ae7e <HAL_DMA_IRQHandler+0x1502>
 800ac22:	bf00      	nop
 800ac24:	00800001 	.word	0x00800001
 800ac28:	40026458 	.word	0x40026458
 800ac2c:	40026400 	.word	0x40026400
 800ac30:	40026010 	.word	0x40026010
 800ac34:	40026410 	.word	0x40026410
 800ac38:	40026070 	.word	0x40026070
 800ac3c:	40026470 	.word	0x40026470
 800ac40:	40026028 	.word	0x40026028
 800ac44:	40026428 	.word	0x40026428
 800ac48:	40026088 	.word	0x40026088
 800ac4c:	40026488 	.word	0x40026488
 800ac50:	40026040 	.word	0x40026040
 800ac54:	40026440 	.word	0x40026440
 800ac58:	400260a0 	.word	0x400260a0
 800ac5c:	400264a0 	.word	0x400264a0
 800ac60:	00800004 	.word	0x00800004
 800ac64:	400260b8 	.word	0x400260b8
 800ac68:	687b      	ldr	r3, [r7, #4]
 800ac6a:	681b      	ldr	r3, [r3, #0]
 800ac6c:	461a      	mov	r2, r3
 800ac6e:	4b71      	ldr	r3, [pc, #452]	; (800ae34 <HAL_DMA_IRQHandler+0x14b8>)
 800ac70:	429a      	cmp	r2, r3
 800ac72:	d972      	bls.n	800ad5a <HAL_DMA_IRQHandler+0x13de>
 800ac74:	4b70      	ldr	r3, [pc, #448]	; (800ae38 <HAL_DMA_IRQHandler+0x14bc>)
 800ac76:	685a      	ldr	r2, [r3, #4]
 800ac78:	687b      	ldr	r3, [r7, #4]
 800ac7a:	681b      	ldr	r3, [r3, #0]
 800ac7c:	4619      	mov	r1, r3
 800ac7e:	4b6f      	ldr	r3, [pc, #444]	; (800ae3c <HAL_DMA_IRQHandler+0x14c0>)
 800ac80:	4299      	cmp	r1, r3
 800ac82:	d062      	beq.n	800ad4a <HAL_DMA_IRQHandler+0x13ce>
 800ac84:	687b      	ldr	r3, [r7, #4]
 800ac86:	681b      	ldr	r3, [r3, #0]
 800ac88:	4619      	mov	r1, r3
 800ac8a:	4b6d      	ldr	r3, [pc, #436]	; (800ae40 <HAL_DMA_IRQHandler+0x14c4>)
 800ac8c:	4299      	cmp	r1, r3
 800ac8e:	d05a      	beq.n	800ad46 <HAL_DMA_IRQHandler+0x13ca>
 800ac90:	687b      	ldr	r3, [r7, #4]
 800ac92:	681b      	ldr	r3, [r3, #0]
 800ac94:	4619      	mov	r1, r3
 800ac96:	4b6b      	ldr	r3, [pc, #428]	; (800ae44 <HAL_DMA_IRQHandler+0x14c8>)
 800ac98:	4299      	cmp	r1, r3
 800ac9a:	d052      	beq.n	800ad42 <HAL_DMA_IRQHandler+0x13c6>
 800ac9c:	687b      	ldr	r3, [r7, #4]
 800ac9e:	681b      	ldr	r3, [r3, #0]
 800aca0:	4619      	mov	r1, r3
 800aca2:	4b69      	ldr	r3, [pc, #420]	; (800ae48 <HAL_DMA_IRQHandler+0x14cc>)
 800aca4:	4299      	cmp	r1, r3
 800aca6:	d04a      	beq.n	800ad3e <HAL_DMA_IRQHandler+0x13c2>
 800aca8:	687b      	ldr	r3, [r7, #4]
 800acaa:	681b      	ldr	r3, [r3, #0]
 800acac:	4619      	mov	r1, r3
 800acae:	4b67      	ldr	r3, [pc, #412]	; (800ae4c <HAL_DMA_IRQHandler+0x14d0>)
 800acb0:	4299      	cmp	r1, r3
 800acb2:	d041      	beq.n	800ad38 <HAL_DMA_IRQHandler+0x13bc>
 800acb4:	687b      	ldr	r3, [r7, #4]
 800acb6:	681b      	ldr	r3, [r3, #0]
 800acb8:	4619      	mov	r1, r3
 800acba:	4b65      	ldr	r3, [pc, #404]	; (800ae50 <HAL_DMA_IRQHandler+0x14d4>)
 800acbc:	4299      	cmp	r1, r3
 800acbe:	d038      	beq.n	800ad32 <HAL_DMA_IRQHandler+0x13b6>
 800acc0:	687b      	ldr	r3, [r7, #4]
 800acc2:	681b      	ldr	r3, [r3, #0]
 800acc4:	4619      	mov	r1, r3
 800acc6:	4b63      	ldr	r3, [pc, #396]	; (800ae54 <HAL_DMA_IRQHandler+0x14d8>)
 800acc8:	4299      	cmp	r1, r3
 800acca:	d02f      	beq.n	800ad2c <HAL_DMA_IRQHandler+0x13b0>
 800accc:	687b      	ldr	r3, [r7, #4]
 800acce:	681b      	ldr	r3, [r3, #0]
 800acd0:	4619      	mov	r1, r3
 800acd2:	4b61      	ldr	r3, [pc, #388]	; (800ae58 <HAL_DMA_IRQHandler+0x14dc>)
 800acd4:	4299      	cmp	r1, r3
 800acd6:	d026      	beq.n	800ad26 <HAL_DMA_IRQHandler+0x13aa>
 800acd8:	687b      	ldr	r3, [r7, #4]
 800acda:	681b      	ldr	r3, [r3, #0]
 800acdc:	4619      	mov	r1, r3
 800acde:	4b5f      	ldr	r3, [pc, #380]	; (800ae5c <HAL_DMA_IRQHandler+0x14e0>)
 800ace0:	4299      	cmp	r1, r3
 800ace2:	d01d      	beq.n	800ad20 <HAL_DMA_IRQHandler+0x13a4>
 800ace4:	687b      	ldr	r3, [r7, #4]
 800ace6:	681b      	ldr	r3, [r3, #0]
 800ace8:	4619      	mov	r1, r3
 800acea:	4b5d      	ldr	r3, [pc, #372]	; (800ae60 <HAL_DMA_IRQHandler+0x14e4>)
 800acec:	4299      	cmp	r1, r3
 800acee:	d014      	beq.n	800ad1a <HAL_DMA_IRQHandler+0x139e>
 800acf0:	687b      	ldr	r3, [r7, #4]
 800acf2:	681b      	ldr	r3, [r3, #0]
 800acf4:	4619      	mov	r1, r3
 800acf6:	4b5b      	ldr	r3, [pc, #364]	; (800ae64 <HAL_DMA_IRQHandler+0x14e8>)
 800acf8:	4299      	cmp	r1, r3
 800acfa:	d00b      	beq.n	800ad14 <HAL_DMA_IRQHandler+0x1398>
 800acfc:	687b      	ldr	r3, [r7, #4]
 800acfe:	681b      	ldr	r3, [r3, #0]
 800ad00:	4619      	mov	r1, r3
 800ad02:	4b59      	ldr	r3, [pc, #356]	; (800ae68 <HAL_DMA_IRQHandler+0x14ec>)
 800ad04:	4299      	cmp	r1, r3
 800ad06:	d102      	bne.n	800ad0e <HAL_DMA_IRQHandler+0x1392>
 800ad08:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800ad0c:	e01e      	b.n	800ad4c <HAL_DMA_IRQHandler+0x13d0>
 800ad0e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800ad12:	e01b      	b.n	800ad4c <HAL_DMA_IRQHandler+0x13d0>
 800ad14:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800ad18:	e018      	b.n	800ad4c <HAL_DMA_IRQHandler+0x13d0>
 800ad1a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800ad1e:	e015      	b.n	800ad4c <HAL_DMA_IRQHandler+0x13d0>
 800ad20:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800ad24:	e012      	b.n	800ad4c <HAL_DMA_IRQHandler+0x13d0>
 800ad26:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ad2a:	e00f      	b.n	800ad4c <HAL_DMA_IRQHandler+0x13d0>
 800ad2c:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ad30:	e00c      	b.n	800ad4c <HAL_DMA_IRQHandler+0x13d0>
 800ad32:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ad36:	e009      	b.n	800ad4c <HAL_DMA_IRQHandler+0x13d0>
 800ad38:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ad3c:	e006      	b.n	800ad4c <HAL_DMA_IRQHandler+0x13d0>
 800ad3e:	4b4b      	ldr	r3, [pc, #300]	; (800ae6c <HAL_DMA_IRQHandler+0x14f0>)
 800ad40:	e004      	b.n	800ad4c <HAL_DMA_IRQHandler+0x13d0>
 800ad42:	4b4a      	ldr	r3, [pc, #296]	; (800ae6c <HAL_DMA_IRQHandler+0x14f0>)
 800ad44:	e002      	b.n	800ad4c <HAL_DMA_IRQHandler+0x13d0>
 800ad46:	4b49      	ldr	r3, [pc, #292]	; (800ae6c <HAL_DMA_IRQHandler+0x14f0>)
 800ad48:	e000      	b.n	800ad4c <HAL_DMA_IRQHandler+0x13d0>
 800ad4a:	4b48      	ldr	r3, [pc, #288]	; (800ae6c <HAL_DMA_IRQHandler+0x14f0>)
 800ad4c:	4013      	ands	r3, r2
 800ad4e:	2b00      	cmp	r3, #0
 800ad50:	bf14      	ite	ne
 800ad52:	2301      	movne	r3, #1
 800ad54:	2300      	moveq	r3, #0
 800ad56:	b2db      	uxtb	r3, r3
 800ad58:	e091      	b.n	800ae7e <HAL_DMA_IRQHandler+0x1502>
 800ad5a:	4b37      	ldr	r3, [pc, #220]	; (800ae38 <HAL_DMA_IRQHandler+0x14bc>)
 800ad5c:	681a      	ldr	r2, [r3, #0]
 800ad5e:	687b      	ldr	r3, [r7, #4]
 800ad60:	681b      	ldr	r3, [r3, #0]
 800ad62:	4619      	mov	r1, r3
 800ad64:	4b35      	ldr	r3, [pc, #212]	; (800ae3c <HAL_DMA_IRQHandler+0x14c0>)
 800ad66:	4299      	cmp	r1, r3
 800ad68:	f000 8082 	beq.w	800ae70 <HAL_DMA_IRQHandler+0x14f4>
 800ad6c:	687b      	ldr	r3, [r7, #4]
 800ad6e:	681b      	ldr	r3, [r3, #0]
 800ad70:	4619      	mov	r1, r3
 800ad72:	4b33      	ldr	r3, [pc, #204]	; (800ae40 <HAL_DMA_IRQHandler+0x14c4>)
 800ad74:	4299      	cmp	r1, r3
 800ad76:	d05a      	beq.n	800ae2e <HAL_DMA_IRQHandler+0x14b2>
 800ad78:	687b      	ldr	r3, [r7, #4]
 800ad7a:	681b      	ldr	r3, [r3, #0]
 800ad7c:	4619      	mov	r1, r3
 800ad7e:	4b31      	ldr	r3, [pc, #196]	; (800ae44 <HAL_DMA_IRQHandler+0x14c8>)
 800ad80:	4299      	cmp	r1, r3
 800ad82:	d052      	beq.n	800ae2a <HAL_DMA_IRQHandler+0x14ae>
 800ad84:	687b      	ldr	r3, [r7, #4]
 800ad86:	681b      	ldr	r3, [r3, #0]
 800ad88:	4619      	mov	r1, r3
 800ad8a:	4b2f      	ldr	r3, [pc, #188]	; (800ae48 <HAL_DMA_IRQHandler+0x14cc>)
 800ad8c:	4299      	cmp	r1, r3
 800ad8e:	d04a      	beq.n	800ae26 <HAL_DMA_IRQHandler+0x14aa>
 800ad90:	687b      	ldr	r3, [r7, #4]
 800ad92:	681b      	ldr	r3, [r3, #0]
 800ad94:	4619      	mov	r1, r3
 800ad96:	4b2d      	ldr	r3, [pc, #180]	; (800ae4c <HAL_DMA_IRQHandler+0x14d0>)
 800ad98:	4299      	cmp	r1, r3
 800ad9a:	d041      	beq.n	800ae20 <HAL_DMA_IRQHandler+0x14a4>
 800ad9c:	687b      	ldr	r3, [r7, #4]
 800ad9e:	681b      	ldr	r3, [r3, #0]
 800ada0:	4619      	mov	r1, r3
 800ada2:	4b2b      	ldr	r3, [pc, #172]	; (800ae50 <HAL_DMA_IRQHandler+0x14d4>)
 800ada4:	4299      	cmp	r1, r3
 800ada6:	d038      	beq.n	800ae1a <HAL_DMA_IRQHandler+0x149e>
 800ada8:	687b      	ldr	r3, [r7, #4]
 800adaa:	681b      	ldr	r3, [r3, #0]
 800adac:	4619      	mov	r1, r3
 800adae:	4b29      	ldr	r3, [pc, #164]	; (800ae54 <HAL_DMA_IRQHandler+0x14d8>)
 800adb0:	4299      	cmp	r1, r3
 800adb2:	d02f      	beq.n	800ae14 <HAL_DMA_IRQHandler+0x1498>
 800adb4:	687b      	ldr	r3, [r7, #4]
 800adb6:	681b      	ldr	r3, [r3, #0]
 800adb8:	4619      	mov	r1, r3
 800adba:	4b27      	ldr	r3, [pc, #156]	; (800ae58 <HAL_DMA_IRQHandler+0x14dc>)
 800adbc:	4299      	cmp	r1, r3
 800adbe:	d026      	beq.n	800ae0e <HAL_DMA_IRQHandler+0x1492>
 800adc0:	687b      	ldr	r3, [r7, #4]
 800adc2:	681b      	ldr	r3, [r3, #0]
 800adc4:	4619      	mov	r1, r3
 800adc6:	4b25      	ldr	r3, [pc, #148]	; (800ae5c <HAL_DMA_IRQHandler+0x14e0>)
 800adc8:	4299      	cmp	r1, r3
 800adca:	d01d      	beq.n	800ae08 <HAL_DMA_IRQHandler+0x148c>
 800adcc:	687b      	ldr	r3, [r7, #4]
 800adce:	681b      	ldr	r3, [r3, #0]
 800add0:	4619      	mov	r1, r3
 800add2:	4b23      	ldr	r3, [pc, #140]	; (800ae60 <HAL_DMA_IRQHandler+0x14e4>)
 800add4:	4299      	cmp	r1, r3
 800add6:	d014      	beq.n	800ae02 <HAL_DMA_IRQHandler+0x1486>
 800add8:	687b      	ldr	r3, [r7, #4]
 800adda:	681b      	ldr	r3, [r3, #0]
 800addc:	4619      	mov	r1, r3
 800adde:	4b21      	ldr	r3, [pc, #132]	; (800ae64 <HAL_DMA_IRQHandler+0x14e8>)
 800ade0:	4299      	cmp	r1, r3
 800ade2:	d00b      	beq.n	800adfc <HAL_DMA_IRQHandler+0x1480>
 800ade4:	687b      	ldr	r3, [r7, #4]
 800ade6:	681b      	ldr	r3, [r3, #0]
 800ade8:	4619      	mov	r1, r3
 800adea:	4b1f      	ldr	r3, [pc, #124]	; (800ae68 <HAL_DMA_IRQHandler+0x14ec>)
 800adec:	4299      	cmp	r1, r3
 800adee:	d102      	bne.n	800adf6 <HAL_DMA_IRQHandler+0x147a>
 800adf0:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800adf4:	e03d      	b.n	800ae72 <HAL_DMA_IRQHandler+0x14f6>
 800adf6:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800adfa:	e03a      	b.n	800ae72 <HAL_DMA_IRQHandler+0x14f6>
 800adfc:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800ae00:	e037      	b.n	800ae72 <HAL_DMA_IRQHandler+0x14f6>
 800ae02:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800ae06:	e034      	b.n	800ae72 <HAL_DMA_IRQHandler+0x14f6>
 800ae08:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800ae0c:	e031      	b.n	800ae72 <HAL_DMA_IRQHandler+0x14f6>
 800ae0e:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ae12:	e02e      	b.n	800ae72 <HAL_DMA_IRQHandler+0x14f6>
 800ae14:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ae18:	e02b      	b.n	800ae72 <HAL_DMA_IRQHandler+0x14f6>
 800ae1a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ae1e:	e028      	b.n	800ae72 <HAL_DMA_IRQHandler+0x14f6>
 800ae20:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ae24:	e025      	b.n	800ae72 <HAL_DMA_IRQHandler+0x14f6>
 800ae26:	4b11      	ldr	r3, [pc, #68]	; (800ae6c <HAL_DMA_IRQHandler+0x14f0>)
 800ae28:	e023      	b.n	800ae72 <HAL_DMA_IRQHandler+0x14f6>
 800ae2a:	4b10      	ldr	r3, [pc, #64]	; (800ae6c <HAL_DMA_IRQHandler+0x14f0>)
 800ae2c:	e021      	b.n	800ae72 <HAL_DMA_IRQHandler+0x14f6>
 800ae2e:	4b0f      	ldr	r3, [pc, #60]	; (800ae6c <HAL_DMA_IRQHandler+0x14f0>)
 800ae30:	e01f      	b.n	800ae72 <HAL_DMA_IRQHandler+0x14f6>
 800ae32:	bf00      	nop
 800ae34:	40026058 	.word	0x40026058
 800ae38:	40026000 	.word	0x40026000
 800ae3c:	40026010 	.word	0x40026010
 800ae40:	40026410 	.word	0x40026410
 800ae44:	40026070 	.word	0x40026070
 800ae48:	40026470 	.word	0x40026470
 800ae4c:	40026028 	.word	0x40026028
 800ae50:	40026428 	.word	0x40026428
 800ae54:	40026088 	.word	0x40026088
 800ae58:	40026488 	.word	0x40026488
 800ae5c:	40026040 	.word	0x40026040
 800ae60:	40026440 	.word	0x40026440
 800ae64:	400260a0 	.word	0x400260a0
 800ae68:	400264a0 	.word	0x400264a0
 800ae6c:	00800004 	.word	0x00800004
 800ae70:	4b80      	ldr	r3, [pc, #512]	; (800b074 <HAL_DMA_IRQHandler+0x16f8>)
 800ae72:	4013      	ands	r3, r2
 800ae74:	2b00      	cmp	r3, #0
 800ae76:	bf14      	ite	ne
 800ae78:	2301      	movne	r3, #1
 800ae7a:	2300      	moveq	r3, #0
 800ae7c:	b2db      	uxtb	r3, r3
 800ae7e:	2b00      	cmp	r3, #0
 800ae80:	f000 822c 	beq.w	800b2dc <HAL_DMA_IRQHandler+0x1960>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 800ae84:	687b      	ldr	r3, [r7, #4]
 800ae86:	681b      	ldr	r3, [r3, #0]
 800ae88:	681b      	ldr	r3, [r3, #0]
 800ae8a:	f003 0302 	and.w	r3, r3, #2
 800ae8e:	2b00      	cmp	r3, #0
 800ae90:	f000 8224 	beq.w	800b2dc <HAL_DMA_IRQHandler+0x1960>
    {
      /* Disable the direct mode Error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_DME);
 800ae94:	687b      	ldr	r3, [r7, #4]
 800ae96:	681b      	ldr	r3, [r3, #0]
 800ae98:	687a      	ldr	r2, [r7, #4]
 800ae9a:	6812      	ldr	r2, [r2, #0]
 800ae9c:	6812      	ldr	r2, [r2, #0]
 800ae9e:	f022 0202 	bic.w	r2, r2, #2
 800aea2:	601a      	str	r2, [r3, #0]

      /* Clear the direct mode error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 800aea4:	687b      	ldr	r3, [r7, #4]
 800aea6:	681b      	ldr	r3, [r3, #0]
 800aea8:	461a      	mov	r2, r3
 800aeaa:	4b73      	ldr	r3, [pc, #460]	; (800b078 <HAL_DMA_IRQHandler+0x16fc>)
 800aeac:	429a      	cmp	r2, r3
 800aeae:	d96c      	bls.n	800af8a <HAL_DMA_IRQHandler+0x160e>
 800aeb0:	4a72      	ldr	r2, [pc, #456]	; (800b07c <HAL_DMA_IRQHandler+0x1700>)
 800aeb2:	687b      	ldr	r3, [r7, #4]
 800aeb4:	681b      	ldr	r3, [r3, #0]
 800aeb6:	4619      	mov	r1, r3
 800aeb8:	4b71      	ldr	r3, [pc, #452]	; (800b080 <HAL_DMA_IRQHandler+0x1704>)
 800aeba:	4299      	cmp	r1, r3
 800aebc:	d062      	beq.n	800af84 <HAL_DMA_IRQHandler+0x1608>
 800aebe:	687b      	ldr	r3, [r7, #4]
 800aec0:	681b      	ldr	r3, [r3, #0]
 800aec2:	4619      	mov	r1, r3
 800aec4:	4b6f      	ldr	r3, [pc, #444]	; (800b084 <HAL_DMA_IRQHandler+0x1708>)
 800aec6:	4299      	cmp	r1, r3
 800aec8:	d05a      	beq.n	800af80 <HAL_DMA_IRQHandler+0x1604>
 800aeca:	687b      	ldr	r3, [r7, #4]
 800aecc:	681b      	ldr	r3, [r3, #0]
 800aece:	4619      	mov	r1, r3
 800aed0:	4b6d      	ldr	r3, [pc, #436]	; (800b088 <HAL_DMA_IRQHandler+0x170c>)
 800aed2:	4299      	cmp	r1, r3
 800aed4:	d052      	beq.n	800af7c <HAL_DMA_IRQHandler+0x1600>
 800aed6:	687b      	ldr	r3, [r7, #4]
 800aed8:	681b      	ldr	r3, [r3, #0]
 800aeda:	4619      	mov	r1, r3
 800aedc:	4b6b      	ldr	r3, [pc, #428]	; (800b08c <HAL_DMA_IRQHandler+0x1710>)
 800aede:	4299      	cmp	r1, r3
 800aee0:	d04a      	beq.n	800af78 <HAL_DMA_IRQHandler+0x15fc>
 800aee2:	687b      	ldr	r3, [r7, #4]
 800aee4:	681b      	ldr	r3, [r3, #0]
 800aee6:	4619      	mov	r1, r3
 800aee8:	4b69      	ldr	r3, [pc, #420]	; (800b090 <HAL_DMA_IRQHandler+0x1714>)
 800aeea:	4299      	cmp	r1, r3
 800aeec:	d041      	beq.n	800af72 <HAL_DMA_IRQHandler+0x15f6>
 800aeee:	687b      	ldr	r3, [r7, #4]
 800aef0:	681b      	ldr	r3, [r3, #0]
 800aef2:	4619      	mov	r1, r3
 800aef4:	4b67      	ldr	r3, [pc, #412]	; (800b094 <HAL_DMA_IRQHandler+0x1718>)
 800aef6:	4299      	cmp	r1, r3
 800aef8:	d038      	beq.n	800af6c <HAL_DMA_IRQHandler+0x15f0>
 800aefa:	687b      	ldr	r3, [r7, #4]
 800aefc:	681b      	ldr	r3, [r3, #0]
 800aefe:	4619      	mov	r1, r3
 800af00:	4b65      	ldr	r3, [pc, #404]	; (800b098 <HAL_DMA_IRQHandler+0x171c>)
 800af02:	4299      	cmp	r1, r3
 800af04:	d02f      	beq.n	800af66 <HAL_DMA_IRQHandler+0x15ea>
 800af06:	687b      	ldr	r3, [r7, #4]
 800af08:	681b      	ldr	r3, [r3, #0]
 800af0a:	4619      	mov	r1, r3
 800af0c:	4b63      	ldr	r3, [pc, #396]	; (800b09c <HAL_DMA_IRQHandler+0x1720>)
 800af0e:	4299      	cmp	r1, r3
 800af10:	d026      	beq.n	800af60 <HAL_DMA_IRQHandler+0x15e4>
 800af12:	687b      	ldr	r3, [r7, #4]
 800af14:	681b      	ldr	r3, [r3, #0]
 800af16:	4619      	mov	r1, r3
 800af18:	4b61      	ldr	r3, [pc, #388]	; (800b0a0 <HAL_DMA_IRQHandler+0x1724>)
 800af1a:	4299      	cmp	r1, r3
 800af1c:	d01d      	beq.n	800af5a <HAL_DMA_IRQHandler+0x15de>
 800af1e:	687b      	ldr	r3, [r7, #4]
 800af20:	681b      	ldr	r3, [r3, #0]
 800af22:	4619      	mov	r1, r3
 800af24:	4b5f      	ldr	r3, [pc, #380]	; (800b0a4 <HAL_DMA_IRQHandler+0x1728>)
 800af26:	4299      	cmp	r1, r3
 800af28:	d014      	beq.n	800af54 <HAL_DMA_IRQHandler+0x15d8>
 800af2a:	687b      	ldr	r3, [r7, #4]
 800af2c:	681b      	ldr	r3, [r3, #0]
 800af2e:	4619      	mov	r1, r3
 800af30:	4b5d      	ldr	r3, [pc, #372]	; (800b0a8 <HAL_DMA_IRQHandler+0x172c>)
 800af32:	4299      	cmp	r1, r3
 800af34:	d00b      	beq.n	800af4e <HAL_DMA_IRQHandler+0x15d2>
 800af36:	687b      	ldr	r3, [r7, #4]
 800af38:	681b      	ldr	r3, [r3, #0]
 800af3a:	4619      	mov	r1, r3
 800af3c:	4b5b      	ldr	r3, [pc, #364]	; (800b0ac <HAL_DMA_IRQHandler+0x1730>)
 800af3e:	4299      	cmp	r1, r3
 800af40:	d102      	bne.n	800af48 <HAL_DMA_IRQHandler+0x15cc>
 800af42:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800af46:	e01e      	b.n	800af86 <HAL_DMA_IRQHandler+0x160a>
 800af48:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800af4c:	e01b      	b.n	800af86 <HAL_DMA_IRQHandler+0x160a>
 800af4e:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800af52:	e018      	b.n	800af86 <HAL_DMA_IRQHandler+0x160a>
 800af54:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800af58:	e015      	b.n	800af86 <HAL_DMA_IRQHandler+0x160a>
 800af5a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800af5e:	e012      	b.n	800af86 <HAL_DMA_IRQHandler+0x160a>
 800af60:	f44f 7380 	mov.w	r3, #256	; 0x100
 800af64:	e00f      	b.n	800af86 <HAL_DMA_IRQHandler+0x160a>
 800af66:	f44f 7380 	mov.w	r3, #256	; 0x100
 800af6a:	e00c      	b.n	800af86 <HAL_DMA_IRQHandler+0x160a>
 800af6c:	f44f 7380 	mov.w	r3, #256	; 0x100
 800af70:	e009      	b.n	800af86 <HAL_DMA_IRQHandler+0x160a>
 800af72:	f44f 7380 	mov.w	r3, #256	; 0x100
 800af76:	e006      	b.n	800af86 <HAL_DMA_IRQHandler+0x160a>
 800af78:	4b3e      	ldr	r3, [pc, #248]	; (800b074 <HAL_DMA_IRQHandler+0x16f8>)
 800af7a:	e004      	b.n	800af86 <HAL_DMA_IRQHandler+0x160a>
 800af7c:	4b3d      	ldr	r3, [pc, #244]	; (800b074 <HAL_DMA_IRQHandler+0x16f8>)
 800af7e:	e002      	b.n	800af86 <HAL_DMA_IRQHandler+0x160a>
 800af80:	4b3c      	ldr	r3, [pc, #240]	; (800b074 <HAL_DMA_IRQHandler+0x16f8>)
 800af82:	e000      	b.n	800af86 <HAL_DMA_IRQHandler+0x160a>
 800af84:	4b3b      	ldr	r3, [pc, #236]	; (800b074 <HAL_DMA_IRQHandler+0x16f8>)
 800af86:	60d3      	str	r3, [r2, #12]
 800af88:	e192      	b.n	800b2b0 <HAL_DMA_IRQHandler+0x1934>
 800af8a:	687b      	ldr	r3, [r7, #4]
 800af8c:	681b      	ldr	r3, [r3, #0]
 800af8e:	461a      	mov	r2, r3
 800af90:	4b47      	ldr	r3, [pc, #284]	; (800b0b0 <HAL_DMA_IRQHandler+0x1734>)
 800af92:	429a      	cmp	r2, r3
 800af94:	f240 808e 	bls.w	800b0b4 <HAL_DMA_IRQHandler+0x1738>
 800af98:	4a38      	ldr	r2, [pc, #224]	; (800b07c <HAL_DMA_IRQHandler+0x1700>)
 800af9a:	687b      	ldr	r3, [r7, #4]
 800af9c:	681b      	ldr	r3, [r3, #0]
 800af9e:	4619      	mov	r1, r3
 800afa0:	4b37      	ldr	r3, [pc, #220]	; (800b080 <HAL_DMA_IRQHandler+0x1704>)
 800afa2:	4299      	cmp	r1, r3
 800afa4:	d062      	beq.n	800b06c <HAL_DMA_IRQHandler+0x16f0>
 800afa6:	687b      	ldr	r3, [r7, #4]
 800afa8:	681b      	ldr	r3, [r3, #0]
 800afaa:	4619      	mov	r1, r3
 800afac:	4b35      	ldr	r3, [pc, #212]	; (800b084 <HAL_DMA_IRQHandler+0x1708>)
 800afae:	4299      	cmp	r1, r3
 800afb0:	d05a      	beq.n	800b068 <HAL_DMA_IRQHandler+0x16ec>
 800afb2:	687b      	ldr	r3, [r7, #4]
 800afb4:	681b      	ldr	r3, [r3, #0]
 800afb6:	4619      	mov	r1, r3
 800afb8:	4b33      	ldr	r3, [pc, #204]	; (800b088 <HAL_DMA_IRQHandler+0x170c>)
 800afba:	4299      	cmp	r1, r3
 800afbc:	d052      	beq.n	800b064 <HAL_DMA_IRQHandler+0x16e8>
 800afbe:	687b      	ldr	r3, [r7, #4]
 800afc0:	681b      	ldr	r3, [r3, #0]
 800afc2:	4619      	mov	r1, r3
 800afc4:	4b31      	ldr	r3, [pc, #196]	; (800b08c <HAL_DMA_IRQHandler+0x1710>)
 800afc6:	4299      	cmp	r1, r3
 800afc8:	d04a      	beq.n	800b060 <HAL_DMA_IRQHandler+0x16e4>
 800afca:	687b      	ldr	r3, [r7, #4]
 800afcc:	681b      	ldr	r3, [r3, #0]
 800afce:	4619      	mov	r1, r3
 800afd0:	4b2f      	ldr	r3, [pc, #188]	; (800b090 <HAL_DMA_IRQHandler+0x1714>)
 800afd2:	4299      	cmp	r1, r3
 800afd4:	d041      	beq.n	800b05a <HAL_DMA_IRQHandler+0x16de>
 800afd6:	687b      	ldr	r3, [r7, #4]
 800afd8:	681b      	ldr	r3, [r3, #0]
 800afda:	4619      	mov	r1, r3
 800afdc:	4b2d      	ldr	r3, [pc, #180]	; (800b094 <HAL_DMA_IRQHandler+0x1718>)
 800afde:	4299      	cmp	r1, r3
 800afe0:	d038      	beq.n	800b054 <HAL_DMA_IRQHandler+0x16d8>
 800afe2:	687b      	ldr	r3, [r7, #4]
 800afe4:	681b      	ldr	r3, [r3, #0]
 800afe6:	4619      	mov	r1, r3
 800afe8:	4b2b      	ldr	r3, [pc, #172]	; (800b098 <HAL_DMA_IRQHandler+0x171c>)
 800afea:	4299      	cmp	r1, r3
 800afec:	d02f      	beq.n	800b04e <HAL_DMA_IRQHandler+0x16d2>
 800afee:	687b      	ldr	r3, [r7, #4]
 800aff0:	681b      	ldr	r3, [r3, #0]
 800aff2:	4619      	mov	r1, r3
 800aff4:	4b29      	ldr	r3, [pc, #164]	; (800b09c <HAL_DMA_IRQHandler+0x1720>)
 800aff6:	4299      	cmp	r1, r3
 800aff8:	d026      	beq.n	800b048 <HAL_DMA_IRQHandler+0x16cc>
 800affa:	687b      	ldr	r3, [r7, #4]
 800affc:	681b      	ldr	r3, [r3, #0]
 800affe:	4619      	mov	r1, r3
 800b000:	4b27      	ldr	r3, [pc, #156]	; (800b0a0 <HAL_DMA_IRQHandler+0x1724>)
 800b002:	4299      	cmp	r1, r3
 800b004:	d01d      	beq.n	800b042 <HAL_DMA_IRQHandler+0x16c6>
 800b006:	687b      	ldr	r3, [r7, #4]
 800b008:	681b      	ldr	r3, [r3, #0]
 800b00a:	4619      	mov	r1, r3
 800b00c:	4b25      	ldr	r3, [pc, #148]	; (800b0a4 <HAL_DMA_IRQHandler+0x1728>)
 800b00e:	4299      	cmp	r1, r3
 800b010:	d014      	beq.n	800b03c <HAL_DMA_IRQHandler+0x16c0>
 800b012:	687b      	ldr	r3, [r7, #4]
 800b014:	681b      	ldr	r3, [r3, #0]
 800b016:	4619      	mov	r1, r3
 800b018:	4b23      	ldr	r3, [pc, #140]	; (800b0a8 <HAL_DMA_IRQHandler+0x172c>)
 800b01a:	4299      	cmp	r1, r3
 800b01c:	d00b      	beq.n	800b036 <HAL_DMA_IRQHandler+0x16ba>
 800b01e:	687b      	ldr	r3, [r7, #4]
 800b020:	681b      	ldr	r3, [r3, #0]
 800b022:	4619      	mov	r1, r3
 800b024:	4b21      	ldr	r3, [pc, #132]	; (800b0ac <HAL_DMA_IRQHandler+0x1730>)
 800b026:	4299      	cmp	r1, r3
 800b028:	d102      	bne.n	800b030 <HAL_DMA_IRQHandler+0x16b4>
 800b02a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b02e:	e01e      	b.n	800b06e <HAL_DMA_IRQHandler+0x16f2>
 800b030:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800b034:	e01b      	b.n	800b06e <HAL_DMA_IRQHandler+0x16f2>
 800b036:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b03a:	e018      	b.n	800b06e <HAL_DMA_IRQHandler+0x16f2>
 800b03c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b040:	e015      	b.n	800b06e <HAL_DMA_IRQHandler+0x16f2>
 800b042:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b046:	e012      	b.n	800b06e <HAL_DMA_IRQHandler+0x16f2>
 800b048:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b04c:	e00f      	b.n	800b06e <HAL_DMA_IRQHandler+0x16f2>
 800b04e:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b052:	e00c      	b.n	800b06e <HAL_DMA_IRQHandler+0x16f2>
 800b054:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b058:	e009      	b.n	800b06e <HAL_DMA_IRQHandler+0x16f2>
 800b05a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b05e:	e006      	b.n	800b06e <HAL_DMA_IRQHandler+0x16f2>
 800b060:	4b04      	ldr	r3, [pc, #16]	; (800b074 <HAL_DMA_IRQHandler+0x16f8>)
 800b062:	e004      	b.n	800b06e <HAL_DMA_IRQHandler+0x16f2>
 800b064:	4b03      	ldr	r3, [pc, #12]	; (800b074 <HAL_DMA_IRQHandler+0x16f8>)
 800b066:	e002      	b.n	800b06e <HAL_DMA_IRQHandler+0x16f2>
 800b068:	4b02      	ldr	r3, [pc, #8]	; (800b074 <HAL_DMA_IRQHandler+0x16f8>)
 800b06a:	e000      	b.n	800b06e <HAL_DMA_IRQHandler+0x16f2>
 800b06c:	4b01      	ldr	r3, [pc, #4]	; (800b074 <HAL_DMA_IRQHandler+0x16f8>)
 800b06e:	6093      	str	r3, [r2, #8]
 800b070:	e11e      	b.n	800b2b0 <HAL_DMA_IRQHandler+0x1934>
 800b072:	bf00      	nop
 800b074:	00800004 	.word	0x00800004
 800b078:	40026458 	.word	0x40026458
 800b07c:	40026400 	.word	0x40026400
 800b080:	40026010 	.word	0x40026010
 800b084:	40026410 	.word	0x40026410
 800b088:	40026070 	.word	0x40026070
 800b08c:	40026470 	.word	0x40026470
 800b090:	40026028 	.word	0x40026028
 800b094:	40026428 	.word	0x40026428
 800b098:	40026088 	.word	0x40026088
 800b09c:	40026488 	.word	0x40026488
 800b0a0:	40026040 	.word	0x40026040
 800b0a4:	40026440 	.word	0x40026440
 800b0a8:	400260a0 	.word	0x400260a0
 800b0ac:	400264a0 	.word	0x400264a0
 800b0b0:	400260b8 	.word	0x400260b8
 800b0b4:	687b      	ldr	r3, [r7, #4]
 800b0b6:	681b      	ldr	r3, [r3, #0]
 800b0b8:	461a      	mov	r2, r3
 800b0ba:	4b6d      	ldr	r3, [pc, #436]	; (800b270 <HAL_DMA_IRQHandler+0x18f4>)
 800b0bc:	429a      	cmp	r2, r3
 800b0be:	d96c      	bls.n	800b19a <HAL_DMA_IRQHandler+0x181e>
 800b0c0:	4a6c      	ldr	r2, [pc, #432]	; (800b274 <HAL_DMA_IRQHandler+0x18f8>)
 800b0c2:	687b      	ldr	r3, [r7, #4]
 800b0c4:	681b      	ldr	r3, [r3, #0]
 800b0c6:	4619      	mov	r1, r3
 800b0c8:	4b6b      	ldr	r3, [pc, #428]	; (800b278 <HAL_DMA_IRQHandler+0x18fc>)
 800b0ca:	4299      	cmp	r1, r3
 800b0cc:	d062      	beq.n	800b194 <HAL_DMA_IRQHandler+0x1818>
 800b0ce:	687b      	ldr	r3, [r7, #4]
 800b0d0:	681b      	ldr	r3, [r3, #0]
 800b0d2:	4619      	mov	r1, r3
 800b0d4:	4b69      	ldr	r3, [pc, #420]	; (800b27c <HAL_DMA_IRQHandler+0x1900>)
 800b0d6:	4299      	cmp	r1, r3
 800b0d8:	d05a      	beq.n	800b190 <HAL_DMA_IRQHandler+0x1814>
 800b0da:	687b      	ldr	r3, [r7, #4]
 800b0dc:	681b      	ldr	r3, [r3, #0]
 800b0de:	4619      	mov	r1, r3
 800b0e0:	4b67      	ldr	r3, [pc, #412]	; (800b280 <HAL_DMA_IRQHandler+0x1904>)
 800b0e2:	4299      	cmp	r1, r3
 800b0e4:	d052      	beq.n	800b18c <HAL_DMA_IRQHandler+0x1810>
 800b0e6:	687b      	ldr	r3, [r7, #4]
 800b0e8:	681b      	ldr	r3, [r3, #0]
 800b0ea:	4619      	mov	r1, r3
 800b0ec:	4b65      	ldr	r3, [pc, #404]	; (800b284 <HAL_DMA_IRQHandler+0x1908>)
 800b0ee:	4299      	cmp	r1, r3
 800b0f0:	d04a      	beq.n	800b188 <HAL_DMA_IRQHandler+0x180c>
 800b0f2:	687b      	ldr	r3, [r7, #4]
 800b0f4:	681b      	ldr	r3, [r3, #0]
 800b0f6:	4619      	mov	r1, r3
 800b0f8:	4b63      	ldr	r3, [pc, #396]	; (800b288 <HAL_DMA_IRQHandler+0x190c>)
 800b0fa:	4299      	cmp	r1, r3
 800b0fc:	d041      	beq.n	800b182 <HAL_DMA_IRQHandler+0x1806>
 800b0fe:	687b      	ldr	r3, [r7, #4]
 800b100:	681b      	ldr	r3, [r3, #0]
 800b102:	4619      	mov	r1, r3
 800b104:	4b61      	ldr	r3, [pc, #388]	; (800b28c <HAL_DMA_IRQHandler+0x1910>)
 800b106:	4299      	cmp	r1, r3
 800b108:	d038      	beq.n	800b17c <HAL_DMA_IRQHandler+0x1800>
 800b10a:	687b      	ldr	r3, [r7, #4]
 800b10c:	681b      	ldr	r3, [r3, #0]
 800b10e:	4619      	mov	r1, r3
 800b110:	4b5f      	ldr	r3, [pc, #380]	; (800b290 <HAL_DMA_IRQHandler+0x1914>)
 800b112:	4299      	cmp	r1, r3
 800b114:	d02f      	beq.n	800b176 <HAL_DMA_IRQHandler+0x17fa>
 800b116:	687b      	ldr	r3, [r7, #4]
 800b118:	681b      	ldr	r3, [r3, #0]
 800b11a:	4619      	mov	r1, r3
 800b11c:	4b5d      	ldr	r3, [pc, #372]	; (800b294 <HAL_DMA_IRQHandler+0x1918>)
 800b11e:	4299      	cmp	r1, r3
 800b120:	d026      	beq.n	800b170 <HAL_DMA_IRQHandler+0x17f4>
 800b122:	687b      	ldr	r3, [r7, #4]
 800b124:	681b      	ldr	r3, [r3, #0]
 800b126:	4619      	mov	r1, r3
 800b128:	4b5b      	ldr	r3, [pc, #364]	; (800b298 <HAL_DMA_IRQHandler+0x191c>)
 800b12a:	4299      	cmp	r1, r3
 800b12c:	d01d      	beq.n	800b16a <HAL_DMA_IRQHandler+0x17ee>
 800b12e:	687b      	ldr	r3, [r7, #4]
 800b130:	681b      	ldr	r3, [r3, #0]
 800b132:	4619      	mov	r1, r3
 800b134:	4b59      	ldr	r3, [pc, #356]	; (800b29c <HAL_DMA_IRQHandler+0x1920>)
 800b136:	4299      	cmp	r1, r3
 800b138:	d014      	beq.n	800b164 <HAL_DMA_IRQHandler+0x17e8>
 800b13a:	687b      	ldr	r3, [r7, #4]
 800b13c:	681b      	ldr	r3, [r3, #0]
 800b13e:	4619      	mov	r1, r3
 800b140:	4b57      	ldr	r3, [pc, #348]	; (800b2a0 <HAL_DMA_IRQHandler+0x1924>)
 800b142:	4299      	cmp	r1, r3
 800b144:	d00b      	beq.n	800b15e <HAL_DMA_IRQHandler+0x17e2>
 800b146:	687b      	ldr	r3, [r7, #4]
 800b148:	681b      	ldr	r3, [r3, #0]
 800b14a:	4619      	mov	r1, r3
 800b14c:	4b55      	ldr	r3, [pc, #340]	; (800b2a4 <HAL_DMA_IRQHandler+0x1928>)
 800b14e:	4299      	cmp	r1, r3
 800b150:	d102      	bne.n	800b158 <HAL_DMA_IRQHandler+0x17dc>
 800b152:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b156:	e01e      	b.n	800b196 <HAL_DMA_IRQHandler+0x181a>
 800b158:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800b15c:	e01b      	b.n	800b196 <HAL_DMA_IRQHandler+0x181a>
 800b15e:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b162:	e018      	b.n	800b196 <HAL_DMA_IRQHandler+0x181a>
 800b164:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b168:	e015      	b.n	800b196 <HAL_DMA_IRQHandler+0x181a>
 800b16a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b16e:	e012      	b.n	800b196 <HAL_DMA_IRQHandler+0x181a>
 800b170:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b174:	e00f      	b.n	800b196 <HAL_DMA_IRQHandler+0x181a>
 800b176:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b17a:	e00c      	b.n	800b196 <HAL_DMA_IRQHandler+0x181a>
 800b17c:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b180:	e009      	b.n	800b196 <HAL_DMA_IRQHandler+0x181a>
 800b182:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b186:	e006      	b.n	800b196 <HAL_DMA_IRQHandler+0x181a>
 800b188:	4b47      	ldr	r3, [pc, #284]	; (800b2a8 <HAL_DMA_IRQHandler+0x192c>)
 800b18a:	e004      	b.n	800b196 <HAL_DMA_IRQHandler+0x181a>
 800b18c:	4b46      	ldr	r3, [pc, #280]	; (800b2a8 <HAL_DMA_IRQHandler+0x192c>)
 800b18e:	e002      	b.n	800b196 <HAL_DMA_IRQHandler+0x181a>
 800b190:	4b45      	ldr	r3, [pc, #276]	; (800b2a8 <HAL_DMA_IRQHandler+0x192c>)
 800b192:	e000      	b.n	800b196 <HAL_DMA_IRQHandler+0x181a>
 800b194:	4b44      	ldr	r3, [pc, #272]	; (800b2a8 <HAL_DMA_IRQHandler+0x192c>)
 800b196:	60d3      	str	r3, [r2, #12]
 800b198:	e08a      	b.n	800b2b0 <HAL_DMA_IRQHandler+0x1934>
 800b19a:	4a36      	ldr	r2, [pc, #216]	; (800b274 <HAL_DMA_IRQHandler+0x18f8>)
 800b19c:	687b      	ldr	r3, [r7, #4]
 800b19e:	681b      	ldr	r3, [r3, #0]
 800b1a0:	4619      	mov	r1, r3
 800b1a2:	4b35      	ldr	r3, [pc, #212]	; (800b278 <HAL_DMA_IRQHandler+0x18fc>)
 800b1a4:	4299      	cmp	r1, r3
 800b1a6:	f000 8081 	beq.w	800b2ac <HAL_DMA_IRQHandler+0x1930>
 800b1aa:	687b      	ldr	r3, [r7, #4]
 800b1ac:	681b      	ldr	r3, [r3, #0]
 800b1ae:	4619      	mov	r1, r3
 800b1b0:	4b32      	ldr	r3, [pc, #200]	; (800b27c <HAL_DMA_IRQHandler+0x1900>)
 800b1b2:	4299      	cmp	r1, r3
 800b1b4:	d05a      	beq.n	800b26c <HAL_DMA_IRQHandler+0x18f0>
 800b1b6:	687b      	ldr	r3, [r7, #4]
 800b1b8:	681b      	ldr	r3, [r3, #0]
 800b1ba:	4619      	mov	r1, r3
 800b1bc:	4b30      	ldr	r3, [pc, #192]	; (800b280 <HAL_DMA_IRQHandler+0x1904>)
 800b1be:	4299      	cmp	r1, r3
 800b1c0:	d052      	beq.n	800b268 <HAL_DMA_IRQHandler+0x18ec>
 800b1c2:	687b      	ldr	r3, [r7, #4]
 800b1c4:	681b      	ldr	r3, [r3, #0]
 800b1c6:	4619      	mov	r1, r3
 800b1c8:	4b2e      	ldr	r3, [pc, #184]	; (800b284 <HAL_DMA_IRQHandler+0x1908>)
 800b1ca:	4299      	cmp	r1, r3
 800b1cc:	d04a      	beq.n	800b264 <HAL_DMA_IRQHandler+0x18e8>
 800b1ce:	687b      	ldr	r3, [r7, #4]
 800b1d0:	681b      	ldr	r3, [r3, #0]
 800b1d2:	4619      	mov	r1, r3
 800b1d4:	4b2c      	ldr	r3, [pc, #176]	; (800b288 <HAL_DMA_IRQHandler+0x190c>)
 800b1d6:	4299      	cmp	r1, r3
 800b1d8:	d041      	beq.n	800b25e <HAL_DMA_IRQHandler+0x18e2>
 800b1da:	687b      	ldr	r3, [r7, #4]
 800b1dc:	681b      	ldr	r3, [r3, #0]
 800b1de:	4619      	mov	r1, r3
 800b1e0:	4b2a      	ldr	r3, [pc, #168]	; (800b28c <HAL_DMA_IRQHandler+0x1910>)
 800b1e2:	4299      	cmp	r1, r3
 800b1e4:	d038      	beq.n	800b258 <HAL_DMA_IRQHandler+0x18dc>
 800b1e6:	687b      	ldr	r3, [r7, #4]
 800b1e8:	681b      	ldr	r3, [r3, #0]
 800b1ea:	4619      	mov	r1, r3
 800b1ec:	4b28      	ldr	r3, [pc, #160]	; (800b290 <HAL_DMA_IRQHandler+0x1914>)
 800b1ee:	4299      	cmp	r1, r3
 800b1f0:	d02f      	beq.n	800b252 <HAL_DMA_IRQHandler+0x18d6>
 800b1f2:	687b      	ldr	r3, [r7, #4]
 800b1f4:	681b      	ldr	r3, [r3, #0]
 800b1f6:	4619      	mov	r1, r3
 800b1f8:	4b26      	ldr	r3, [pc, #152]	; (800b294 <HAL_DMA_IRQHandler+0x1918>)
 800b1fa:	4299      	cmp	r1, r3
 800b1fc:	d026      	beq.n	800b24c <HAL_DMA_IRQHandler+0x18d0>
 800b1fe:	687b      	ldr	r3, [r7, #4]
 800b200:	681b      	ldr	r3, [r3, #0]
 800b202:	4619      	mov	r1, r3
 800b204:	4b24      	ldr	r3, [pc, #144]	; (800b298 <HAL_DMA_IRQHandler+0x191c>)
 800b206:	4299      	cmp	r1, r3
 800b208:	d01d      	beq.n	800b246 <HAL_DMA_IRQHandler+0x18ca>
 800b20a:	687b      	ldr	r3, [r7, #4]
 800b20c:	681b      	ldr	r3, [r3, #0]
 800b20e:	4619      	mov	r1, r3
 800b210:	4b22      	ldr	r3, [pc, #136]	; (800b29c <HAL_DMA_IRQHandler+0x1920>)
 800b212:	4299      	cmp	r1, r3
 800b214:	d014      	beq.n	800b240 <HAL_DMA_IRQHandler+0x18c4>
 800b216:	687b      	ldr	r3, [r7, #4]
 800b218:	681b      	ldr	r3, [r3, #0]
 800b21a:	4619      	mov	r1, r3
 800b21c:	4b20      	ldr	r3, [pc, #128]	; (800b2a0 <HAL_DMA_IRQHandler+0x1924>)
 800b21e:	4299      	cmp	r1, r3
 800b220:	d00b      	beq.n	800b23a <HAL_DMA_IRQHandler+0x18be>
 800b222:	687b      	ldr	r3, [r7, #4]
 800b224:	681b      	ldr	r3, [r3, #0]
 800b226:	4619      	mov	r1, r3
 800b228:	4b1e      	ldr	r3, [pc, #120]	; (800b2a4 <HAL_DMA_IRQHandler+0x1928>)
 800b22a:	4299      	cmp	r1, r3
 800b22c:	d102      	bne.n	800b234 <HAL_DMA_IRQHandler+0x18b8>
 800b22e:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b232:	e03c      	b.n	800b2ae <HAL_DMA_IRQHandler+0x1932>
 800b234:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800b238:	e039      	b.n	800b2ae <HAL_DMA_IRQHandler+0x1932>
 800b23a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b23e:	e036      	b.n	800b2ae <HAL_DMA_IRQHandler+0x1932>
 800b240:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b244:	e033      	b.n	800b2ae <HAL_DMA_IRQHandler+0x1932>
 800b246:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b24a:	e030      	b.n	800b2ae <HAL_DMA_IRQHandler+0x1932>
 800b24c:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b250:	e02d      	b.n	800b2ae <HAL_DMA_IRQHandler+0x1932>
 800b252:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b256:	e02a      	b.n	800b2ae <HAL_DMA_IRQHandler+0x1932>
 800b258:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b25c:	e027      	b.n	800b2ae <HAL_DMA_IRQHandler+0x1932>
 800b25e:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b262:	e024      	b.n	800b2ae <HAL_DMA_IRQHandler+0x1932>
 800b264:	4b10      	ldr	r3, [pc, #64]	; (800b2a8 <HAL_DMA_IRQHandler+0x192c>)
 800b266:	e022      	b.n	800b2ae <HAL_DMA_IRQHandler+0x1932>
 800b268:	4b0f      	ldr	r3, [pc, #60]	; (800b2a8 <HAL_DMA_IRQHandler+0x192c>)
 800b26a:	e020      	b.n	800b2ae <HAL_DMA_IRQHandler+0x1932>
 800b26c:	4b0e      	ldr	r3, [pc, #56]	; (800b2a8 <HAL_DMA_IRQHandler+0x192c>)
 800b26e:	e01e      	b.n	800b2ae <HAL_DMA_IRQHandler+0x1932>
 800b270:	40026058 	.word	0x40026058
 800b274:	40026000 	.word	0x40026000
 800b278:	40026010 	.word	0x40026010
 800b27c:	40026410 	.word	0x40026410
 800b280:	40026070 	.word	0x40026070
 800b284:	40026470 	.word	0x40026470
 800b288:	40026028 	.word	0x40026028
 800b28c:	40026428 	.word	0x40026428
 800b290:	40026088 	.word	0x40026088
 800b294:	40026488 	.word	0x40026488
 800b298:	40026040 	.word	0x40026040
 800b29c:	40026440 	.word	0x40026440
 800b2a0:	400260a0 	.word	0x400260a0
 800b2a4:	400264a0 	.word	0x400264a0
 800b2a8:	00800004 	.word	0x00800004
 800b2ac:	4b85      	ldr	r3, [pc, #532]	; (800b4c4 <HAL_DMA_IRQHandler+0x1b48>)
 800b2ae:	6093      	str	r3, [r2, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 800b2b0:	687b      	ldr	r3, [r7, #4]
 800b2b2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800b2b4:	f043 0204 	orr.w	r2, r3, #4
 800b2b8:	687b      	ldr	r3, [r7, #4]
 800b2ba:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
 800b2bc:	687b      	ldr	r3, [r7, #4]
 800b2be:	2204      	movs	r2, #4
 800b2c0:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 800b2c4:	687b      	ldr	r3, [r7, #4]
 800b2c6:	2200      	movs	r2, #0
 800b2c8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      if(hdma->XferErrorCallback != NULL)
 800b2cc:	687b      	ldr	r3, [r7, #4]
 800b2ce:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800b2d0:	2b00      	cmp	r3, #0
 800b2d2:	d003      	beq.n	800b2dc <HAL_DMA_IRQHandler+0x1960>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 800b2d4:	687b      	ldr	r3, [r7, #4]
 800b2d6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800b2d8:	6878      	ldr	r0, [r7, #4]
 800b2da:	4798      	blx	r3
      }
    }
  }
  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 800b2dc:	687b      	ldr	r3, [r7, #4]
 800b2de:	681b      	ldr	r3, [r3, #0]
 800b2e0:	461a      	mov	r2, r3
 800b2e2:	4b79      	ldr	r3, [pc, #484]	; (800b4c8 <HAL_DMA_IRQHandler+0x1b4c>)
 800b2e4:	429a      	cmp	r2, r3
 800b2e6:	d972      	bls.n	800b3ce <HAL_DMA_IRQHandler+0x1a52>
 800b2e8:	4b78      	ldr	r3, [pc, #480]	; (800b4cc <HAL_DMA_IRQHandler+0x1b50>)
 800b2ea:	685a      	ldr	r2, [r3, #4]
 800b2ec:	687b      	ldr	r3, [r7, #4]
 800b2ee:	681b      	ldr	r3, [r3, #0]
 800b2f0:	4619      	mov	r1, r3
 800b2f2:	4b77      	ldr	r3, [pc, #476]	; (800b4d0 <HAL_DMA_IRQHandler+0x1b54>)
 800b2f4:	4299      	cmp	r1, r3
 800b2f6:	d062      	beq.n	800b3be <HAL_DMA_IRQHandler+0x1a42>
 800b2f8:	687b      	ldr	r3, [r7, #4]
 800b2fa:	681b      	ldr	r3, [r3, #0]
 800b2fc:	4619      	mov	r1, r3
 800b2fe:	4b75      	ldr	r3, [pc, #468]	; (800b4d4 <HAL_DMA_IRQHandler+0x1b58>)
 800b300:	4299      	cmp	r1, r3
 800b302:	d05a      	beq.n	800b3ba <HAL_DMA_IRQHandler+0x1a3e>
 800b304:	687b      	ldr	r3, [r7, #4]
 800b306:	681b      	ldr	r3, [r3, #0]
 800b308:	4619      	mov	r1, r3
 800b30a:	4b73      	ldr	r3, [pc, #460]	; (800b4d8 <HAL_DMA_IRQHandler+0x1b5c>)
 800b30c:	4299      	cmp	r1, r3
 800b30e:	d052      	beq.n	800b3b6 <HAL_DMA_IRQHandler+0x1a3a>
 800b310:	687b      	ldr	r3, [r7, #4]
 800b312:	681b      	ldr	r3, [r3, #0]
 800b314:	4619      	mov	r1, r3
 800b316:	4b71      	ldr	r3, [pc, #452]	; (800b4dc <HAL_DMA_IRQHandler+0x1b60>)
 800b318:	4299      	cmp	r1, r3
 800b31a:	d04a      	beq.n	800b3b2 <HAL_DMA_IRQHandler+0x1a36>
 800b31c:	687b      	ldr	r3, [r7, #4]
 800b31e:	681b      	ldr	r3, [r3, #0]
 800b320:	4619      	mov	r1, r3
 800b322:	4b6f      	ldr	r3, [pc, #444]	; (800b4e0 <HAL_DMA_IRQHandler+0x1b64>)
 800b324:	4299      	cmp	r1, r3
 800b326:	d041      	beq.n	800b3ac <HAL_DMA_IRQHandler+0x1a30>
 800b328:	687b      	ldr	r3, [r7, #4]
 800b32a:	681b      	ldr	r3, [r3, #0]
 800b32c:	4619      	mov	r1, r3
 800b32e:	4b6d      	ldr	r3, [pc, #436]	; (800b4e4 <HAL_DMA_IRQHandler+0x1b68>)
 800b330:	4299      	cmp	r1, r3
 800b332:	d038      	beq.n	800b3a6 <HAL_DMA_IRQHandler+0x1a2a>
 800b334:	687b      	ldr	r3, [r7, #4]
 800b336:	681b      	ldr	r3, [r3, #0]
 800b338:	4619      	mov	r1, r3
 800b33a:	4b6b      	ldr	r3, [pc, #428]	; (800b4e8 <HAL_DMA_IRQHandler+0x1b6c>)
 800b33c:	4299      	cmp	r1, r3
 800b33e:	d02f      	beq.n	800b3a0 <HAL_DMA_IRQHandler+0x1a24>
 800b340:	687b      	ldr	r3, [r7, #4]
 800b342:	681b      	ldr	r3, [r3, #0]
 800b344:	4619      	mov	r1, r3
 800b346:	4b69      	ldr	r3, [pc, #420]	; (800b4ec <HAL_DMA_IRQHandler+0x1b70>)
 800b348:	4299      	cmp	r1, r3
 800b34a:	d026      	beq.n	800b39a <HAL_DMA_IRQHandler+0x1a1e>
 800b34c:	687b      	ldr	r3, [r7, #4]
 800b34e:	681b      	ldr	r3, [r3, #0]
 800b350:	4619      	mov	r1, r3
 800b352:	4b67      	ldr	r3, [pc, #412]	; (800b4f0 <HAL_DMA_IRQHandler+0x1b74>)
 800b354:	4299      	cmp	r1, r3
 800b356:	d01d      	beq.n	800b394 <HAL_DMA_IRQHandler+0x1a18>
 800b358:	687b      	ldr	r3, [r7, #4]
 800b35a:	681b      	ldr	r3, [r3, #0]
 800b35c:	4619      	mov	r1, r3
 800b35e:	4b65      	ldr	r3, [pc, #404]	; (800b4f4 <HAL_DMA_IRQHandler+0x1b78>)
 800b360:	4299      	cmp	r1, r3
 800b362:	d014      	beq.n	800b38e <HAL_DMA_IRQHandler+0x1a12>
 800b364:	687b      	ldr	r3, [r7, #4]
 800b366:	681b      	ldr	r3, [r3, #0]
 800b368:	4619      	mov	r1, r3
 800b36a:	4b63      	ldr	r3, [pc, #396]	; (800b4f8 <HAL_DMA_IRQHandler+0x1b7c>)
 800b36c:	4299      	cmp	r1, r3
 800b36e:	d00b      	beq.n	800b388 <HAL_DMA_IRQHandler+0x1a0c>
 800b370:	687b      	ldr	r3, [r7, #4]
 800b372:	681b      	ldr	r3, [r3, #0]
 800b374:	4619      	mov	r1, r3
 800b376:	4b61      	ldr	r3, [pc, #388]	; (800b4fc <HAL_DMA_IRQHandler+0x1b80>)
 800b378:	4299      	cmp	r1, r3
 800b37a:	d102      	bne.n	800b382 <HAL_DMA_IRQHandler+0x1a06>
 800b37c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b380:	e01e      	b.n	800b3c0 <HAL_DMA_IRQHandler+0x1a44>
 800b382:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800b386:	e01b      	b.n	800b3c0 <HAL_DMA_IRQHandler+0x1a44>
 800b388:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b38c:	e018      	b.n	800b3c0 <HAL_DMA_IRQHandler+0x1a44>
 800b38e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b392:	e015      	b.n	800b3c0 <HAL_DMA_IRQHandler+0x1a44>
 800b394:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b398:	e012      	b.n	800b3c0 <HAL_DMA_IRQHandler+0x1a44>
 800b39a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b39e:	e00f      	b.n	800b3c0 <HAL_DMA_IRQHandler+0x1a44>
 800b3a0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b3a4:	e00c      	b.n	800b3c0 <HAL_DMA_IRQHandler+0x1a44>
 800b3a6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b3aa:	e009      	b.n	800b3c0 <HAL_DMA_IRQHandler+0x1a44>
 800b3ac:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b3b0:	e006      	b.n	800b3c0 <HAL_DMA_IRQHandler+0x1a44>
 800b3b2:	2310      	movs	r3, #16
 800b3b4:	e004      	b.n	800b3c0 <HAL_DMA_IRQHandler+0x1a44>
 800b3b6:	2310      	movs	r3, #16
 800b3b8:	e002      	b.n	800b3c0 <HAL_DMA_IRQHandler+0x1a44>
 800b3ba:	2310      	movs	r3, #16
 800b3bc:	e000      	b.n	800b3c0 <HAL_DMA_IRQHandler+0x1a44>
 800b3be:	2310      	movs	r3, #16
 800b3c0:	4013      	ands	r3, r2
 800b3c2:	2b00      	cmp	r3, #0
 800b3c4:	bf14      	ite	ne
 800b3c6:	2301      	movne	r3, #1
 800b3c8:	2300      	moveq	r3, #0
 800b3ca:	b2db      	uxtb	r3, r3
 800b3cc:	e1a1      	b.n	800b712 <HAL_DMA_IRQHandler+0x1d96>
 800b3ce:	687b      	ldr	r3, [r7, #4]
 800b3d0:	681b      	ldr	r3, [r3, #0]
 800b3d2:	461a      	mov	r2, r3
 800b3d4:	4b4a      	ldr	r3, [pc, #296]	; (800b500 <HAL_DMA_IRQHandler+0x1b84>)
 800b3d6:	429a      	cmp	r2, r3
 800b3d8:	f240 8094 	bls.w	800b504 <HAL_DMA_IRQHandler+0x1b88>
 800b3dc:	4b3b      	ldr	r3, [pc, #236]	; (800b4cc <HAL_DMA_IRQHandler+0x1b50>)
 800b3de:	681a      	ldr	r2, [r3, #0]
 800b3e0:	687b      	ldr	r3, [r7, #4]
 800b3e2:	681b      	ldr	r3, [r3, #0]
 800b3e4:	4619      	mov	r1, r3
 800b3e6:	4b3a      	ldr	r3, [pc, #232]	; (800b4d0 <HAL_DMA_IRQHandler+0x1b54>)
 800b3e8:	4299      	cmp	r1, r3
 800b3ea:	d062      	beq.n	800b4b2 <HAL_DMA_IRQHandler+0x1b36>
 800b3ec:	687b      	ldr	r3, [r7, #4]
 800b3ee:	681b      	ldr	r3, [r3, #0]
 800b3f0:	4619      	mov	r1, r3
 800b3f2:	4b38      	ldr	r3, [pc, #224]	; (800b4d4 <HAL_DMA_IRQHandler+0x1b58>)
 800b3f4:	4299      	cmp	r1, r3
 800b3f6:	d05a      	beq.n	800b4ae <HAL_DMA_IRQHandler+0x1b32>
 800b3f8:	687b      	ldr	r3, [r7, #4]
 800b3fa:	681b      	ldr	r3, [r3, #0]
 800b3fc:	4619      	mov	r1, r3
 800b3fe:	4b36      	ldr	r3, [pc, #216]	; (800b4d8 <HAL_DMA_IRQHandler+0x1b5c>)
 800b400:	4299      	cmp	r1, r3
 800b402:	d052      	beq.n	800b4aa <HAL_DMA_IRQHandler+0x1b2e>
 800b404:	687b      	ldr	r3, [r7, #4]
 800b406:	681b      	ldr	r3, [r3, #0]
 800b408:	4619      	mov	r1, r3
 800b40a:	4b34      	ldr	r3, [pc, #208]	; (800b4dc <HAL_DMA_IRQHandler+0x1b60>)
 800b40c:	4299      	cmp	r1, r3
 800b40e:	d04a      	beq.n	800b4a6 <HAL_DMA_IRQHandler+0x1b2a>
 800b410:	687b      	ldr	r3, [r7, #4]
 800b412:	681b      	ldr	r3, [r3, #0]
 800b414:	4619      	mov	r1, r3
 800b416:	4b32      	ldr	r3, [pc, #200]	; (800b4e0 <HAL_DMA_IRQHandler+0x1b64>)
 800b418:	4299      	cmp	r1, r3
 800b41a:	d041      	beq.n	800b4a0 <HAL_DMA_IRQHandler+0x1b24>
 800b41c:	687b      	ldr	r3, [r7, #4]
 800b41e:	681b      	ldr	r3, [r3, #0]
 800b420:	4619      	mov	r1, r3
 800b422:	4b30      	ldr	r3, [pc, #192]	; (800b4e4 <HAL_DMA_IRQHandler+0x1b68>)
 800b424:	4299      	cmp	r1, r3
 800b426:	d038      	beq.n	800b49a <HAL_DMA_IRQHandler+0x1b1e>
 800b428:	687b      	ldr	r3, [r7, #4]
 800b42a:	681b      	ldr	r3, [r3, #0]
 800b42c:	4619      	mov	r1, r3
 800b42e:	4b2e      	ldr	r3, [pc, #184]	; (800b4e8 <HAL_DMA_IRQHandler+0x1b6c>)
 800b430:	4299      	cmp	r1, r3
 800b432:	d02f      	beq.n	800b494 <HAL_DMA_IRQHandler+0x1b18>
 800b434:	687b      	ldr	r3, [r7, #4]
 800b436:	681b      	ldr	r3, [r3, #0]
 800b438:	4619      	mov	r1, r3
 800b43a:	4b2c      	ldr	r3, [pc, #176]	; (800b4ec <HAL_DMA_IRQHandler+0x1b70>)
 800b43c:	4299      	cmp	r1, r3
 800b43e:	d026      	beq.n	800b48e <HAL_DMA_IRQHandler+0x1b12>
 800b440:	687b      	ldr	r3, [r7, #4]
 800b442:	681b      	ldr	r3, [r3, #0]
 800b444:	4619      	mov	r1, r3
 800b446:	4b2a      	ldr	r3, [pc, #168]	; (800b4f0 <HAL_DMA_IRQHandler+0x1b74>)
 800b448:	4299      	cmp	r1, r3
 800b44a:	d01d      	beq.n	800b488 <HAL_DMA_IRQHandler+0x1b0c>
 800b44c:	687b      	ldr	r3, [r7, #4]
 800b44e:	681b      	ldr	r3, [r3, #0]
 800b450:	4619      	mov	r1, r3
 800b452:	4b28      	ldr	r3, [pc, #160]	; (800b4f4 <HAL_DMA_IRQHandler+0x1b78>)
 800b454:	4299      	cmp	r1, r3
 800b456:	d014      	beq.n	800b482 <HAL_DMA_IRQHandler+0x1b06>
 800b458:	687b      	ldr	r3, [r7, #4]
 800b45a:	681b      	ldr	r3, [r3, #0]
 800b45c:	4619      	mov	r1, r3
 800b45e:	4b26      	ldr	r3, [pc, #152]	; (800b4f8 <HAL_DMA_IRQHandler+0x1b7c>)
 800b460:	4299      	cmp	r1, r3
 800b462:	d00b      	beq.n	800b47c <HAL_DMA_IRQHandler+0x1b00>
 800b464:	687b      	ldr	r3, [r7, #4]
 800b466:	681b      	ldr	r3, [r3, #0]
 800b468:	4619      	mov	r1, r3
 800b46a:	4b24      	ldr	r3, [pc, #144]	; (800b4fc <HAL_DMA_IRQHandler+0x1b80>)
 800b46c:	4299      	cmp	r1, r3
 800b46e:	d102      	bne.n	800b476 <HAL_DMA_IRQHandler+0x1afa>
 800b470:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b474:	e01e      	b.n	800b4b4 <HAL_DMA_IRQHandler+0x1b38>
 800b476:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800b47a:	e01b      	b.n	800b4b4 <HAL_DMA_IRQHandler+0x1b38>
 800b47c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b480:	e018      	b.n	800b4b4 <HAL_DMA_IRQHandler+0x1b38>
 800b482:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b486:	e015      	b.n	800b4b4 <HAL_DMA_IRQHandler+0x1b38>
 800b488:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b48c:	e012      	b.n	800b4b4 <HAL_DMA_IRQHandler+0x1b38>
 800b48e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b492:	e00f      	b.n	800b4b4 <HAL_DMA_IRQHandler+0x1b38>
 800b494:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b498:	e00c      	b.n	800b4b4 <HAL_DMA_IRQHandler+0x1b38>
 800b49a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b49e:	e009      	b.n	800b4b4 <HAL_DMA_IRQHandler+0x1b38>
 800b4a0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b4a4:	e006      	b.n	800b4b4 <HAL_DMA_IRQHandler+0x1b38>
 800b4a6:	2310      	movs	r3, #16
 800b4a8:	e004      	b.n	800b4b4 <HAL_DMA_IRQHandler+0x1b38>
 800b4aa:	2310      	movs	r3, #16
 800b4ac:	e002      	b.n	800b4b4 <HAL_DMA_IRQHandler+0x1b38>
 800b4ae:	2310      	movs	r3, #16
 800b4b0:	e000      	b.n	800b4b4 <HAL_DMA_IRQHandler+0x1b38>
 800b4b2:	2310      	movs	r3, #16
 800b4b4:	4013      	ands	r3, r2
 800b4b6:	2b00      	cmp	r3, #0
 800b4b8:	bf14      	ite	ne
 800b4ba:	2301      	movne	r3, #1
 800b4bc:	2300      	moveq	r3, #0
 800b4be:	b2db      	uxtb	r3, r3
 800b4c0:	e127      	b.n	800b712 <HAL_DMA_IRQHandler+0x1d96>
 800b4c2:	bf00      	nop
 800b4c4:	00800004 	.word	0x00800004
 800b4c8:	40026458 	.word	0x40026458
 800b4cc:	40026400 	.word	0x40026400
 800b4d0:	40026010 	.word	0x40026010
 800b4d4:	40026410 	.word	0x40026410
 800b4d8:	40026070 	.word	0x40026070
 800b4dc:	40026470 	.word	0x40026470
 800b4e0:	40026028 	.word	0x40026028
 800b4e4:	40026428 	.word	0x40026428
 800b4e8:	40026088 	.word	0x40026088
 800b4ec:	40026488 	.word	0x40026488
 800b4f0:	40026040 	.word	0x40026040
 800b4f4:	40026440 	.word	0x40026440
 800b4f8:	400260a0 	.word	0x400260a0
 800b4fc:	400264a0 	.word	0x400264a0
 800b500:	400260b8 	.word	0x400260b8
 800b504:	687b      	ldr	r3, [r7, #4]
 800b506:	681b      	ldr	r3, [r3, #0]
 800b508:	461a      	mov	r2, r3
 800b50a:	4b70      	ldr	r3, [pc, #448]	; (800b6cc <HAL_DMA_IRQHandler+0x1d50>)
 800b50c:	429a      	cmp	r2, r3
 800b50e:	d972      	bls.n	800b5f6 <HAL_DMA_IRQHandler+0x1c7a>
 800b510:	4b6f      	ldr	r3, [pc, #444]	; (800b6d0 <HAL_DMA_IRQHandler+0x1d54>)
 800b512:	685a      	ldr	r2, [r3, #4]
 800b514:	687b      	ldr	r3, [r7, #4]
 800b516:	681b      	ldr	r3, [r3, #0]
 800b518:	4619      	mov	r1, r3
 800b51a:	4b6e      	ldr	r3, [pc, #440]	; (800b6d4 <HAL_DMA_IRQHandler+0x1d58>)
 800b51c:	4299      	cmp	r1, r3
 800b51e:	d062      	beq.n	800b5e6 <HAL_DMA_IRQHandler+0x1c6a>
 800b520:	687b      	ldr	r3, [r7, #4]
 800b522:	681b      	ldr	r3, [r3, #0]
 800b524:	4619      	mov	r1, r3
 800b526:	4b6c      	ldr	r3, [pc, #432]	; (800b6d8 <HAL_DMA_IRQHandler+0x1d5c>)
 800b528:	4299      	cmp	r1, r3
 800b52a:	d05a      	beq.n	800b5e2 <HAL_DMA_IRQHandler+0x1c66>
 800b52c:	687b      	ldr	r3, [r7, #4]
 800b52e:	681b      	ldr	r3, [r3, #0]
 800b530:	4619      	mov	r1, r3
 800b532:	4b6a      	ldr	r3, [pc, #424]	; (800b6dc <HAL_DMA_IRQHandler+0x1d60>)
 800b534:	4299      	cmp	r1, r3
 800b536:	d052      	beq.n	800b5de <HAL_DMA_IRQHandler+0x1c62>
 800b538:	687b      	ldr	r3, [r7, #4]
 800b53a:	681b      	ldr	r3, [r3, #0]
 800b53c:	4619      	mov	r1, r3
 800b53e:	4b68      	ldr	r3, [pc, #416]	; (800b6e0 <HAL_DMA_IRQHandler+0x1d64>)
 800b540:	4299      	cmp	r1, r3
 800b542:	d04a      	beq.n	800b5da <HAL_DMA_IRQHandler+0x1c5e>
 800b544:	687b      	ldr	r3, [r7, #4]
 800b546:	681b      	ldr	r3, [r3, #0]
 800b548:	4619      	mov	r1, r3
 800b54a:	4b66      	ldr	r3, [pc, #408]	; (800b6e4 <HAL_DMA_IRQHandler+0x1d68>)
 800b54c:	4299      	cmp	r1, r3
 800b54e:	d041      	beq.n	800b5d4 <HAL_DMA_IRQHandler+0x1c58>
 800b550:	687b      	ldr	r3, [r7, #4]
 800b552:	681b      	ldr	r3, [r3, #0]
 800b554:	4619      	mov	r1, r3
 800b556:	4b64      	ldr	r3, [pc, #400]	; (800b6e8 <HAL_DMA_IRQHandler+0x1d6c>)
 800b558:	4299      	cmp	r1, r3
 800b55a:	d038      	beq.n	800b5ce <HAL_DMA_IRQHandler+0x1c52>
 800b55c:	687b      	ldr	r3, [r7, #4]
 800b55e:	681b      	ldr	r3, [r3, #0]
 800b560:	4619      	mov	r1, r3
 800b562:	4b62      	ldr	r3, [pc, #392]	; (800b6ec <HAL_DMA_IRQHandler+0x1d70>)
 800b564:	4299      	cmp	r1, r3
 800b566:	d02f      	beq.n	800b5c8 <HAL_DMA_IRQHandler+0x1c4c>
 800b568:	687b      	ldr	r3, [r7, #4]
 800b56a:	681b      	ldr	r3, [r3, #0]
 800b56c:	4619      	mov	r1, r3
 800b56e:	4b60      	ldr	r3, [pc, #384]	; (800b6f0 <HAL_DMA_IRQHandler+0x1d74>)
 800b570:	4299      	cmp	r1, r3
 800b572:	d026      	beq.n	800b5c2 <HAL_DMA_IRQHandler+0x1c46>
 800b574:	687b      	ldr	r3, [r7, #4]
 800b576:	681b      	ldr	r3, [r3, #0]
 800b578:	4619      	mov	r1, r3
 800b57a:	4b5e      	ldr	r3, [pc, #376]	; (800b6f4 <HAL_DMA_IRQHandler+0x1d78>)
 800b57c:	4299      	cmp	r1, r3
 800b57e:	d01d      	beq.n	800b5bc <HAL_DMA_IRQHandler+0x1c40>
 800b580:	687b      	ldr	r3, [r7, #4]
 800b582:	681b      	ldr	r3, [r3, #0]
 800b584:	4619      	mov	r1, r3
 800b586:	4b5c      	ldr	r3, [pc, #368]	; (800b6f8 <HAL_DMA_IRQHandler+0x1d7c>)
 800b588:	4299      	cmp	r1, r3
 800b58a:	d014      	beq.n	800b5b6 <HAL_DMA_IRQHandler+0x1c3a>
 800b58c:	687b      	ldr	r3, [r7, #4]
 800b58e:	681b      	ldr	r3, [r3, #0]
 800b590:	4619      	mov	r1, r3
 800b592:	4b5a      	ldr	r3, [pc, #360]	; (800b6fc <HAL_DMA_IRQHandler+0x1d80>)
 800b594:	4299      	cmp	r1, r3
 800b596:	d00b      	beq.n	800b5b0 <HAL_DMA_IRQHandler+0x1c34>
 800b598:	687b      	ldr	r3, [r7, #4]
 800b59a:	681b      	ldr	r3, [r3, #0]
 800b59c:	4619      	mov	r1, r3
 800b59e:	4b58      	ldr	r3, [pc, #352]	; (800b700 <HAL_DMA_IRQHandler+0x1d84>)
 800b5a0:	4299      	cmp	r1, r3
 800b5a2:	d102      	bne.n	800b5aa <HAL_DMA_IRQHandler+0x1c2e>
 800b5a4:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b5a8:	e01e      	b.n	800b5e8 <HAL_DMA_IRQHandler+0x1c6c>
 800b5aa:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800b5ae:	e01b      	b.n	800b5e8 <HAL_DMA_IRQHandler+0x1c6c>
 800b5b0:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b5b4:	e018      	b.n	800b5e8 <HAL_DMA_IRQHandler+0x1c6c>
 800b5b6:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b5ba:	e015      	b.n	800b5e8 <HAL_DMA_IRQHandler+0x1c6c>
 800b5bc:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b5c0:	e012      	b.n	800b5e8 <HAL_DMA_IRQHandler+0x1c6c>
 800b5c2:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b5c6:	e00f      	b.n	800b5e8 <HAL_DMA_IRQHandler+0x1c6c>
 800b5c8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b5cc:	e00c      	b.n	800b5e8 <HAL_DMA_IRQHandler+0x1c6c>
 800b5ce:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b5d2:	e009      	b.n	800b5e8 <HAL_DMA_IRQHandler+0x1c6c>
 800b5d4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b5d8:	e006      	b.n	800b5e8 <HAL_DMA_IRQHandler+0x1c6c>
 800b5da:	2310      	movs	r3, #16
 800b5dc:	e004      	b.n	800b5e8 <HAL_DMA_IRQHandler+0x1c6c>
 800b5de:	2310      	movs	r3, #16
 800b5e0:	e002      	b.n	800b5e8 <HAL_DMA_IRQHandler+0x1c6c>
 800b5e2:	2310      	movs	r3, #16
 800b5e4:	e000      	b.n	800b5e8 <HAL_DMA_IRQHandler+0x1c6c>
 800b5e6:	2310      	movs	r3, #16
 800b5e8:	4013      	ands	r3, r2
 800b5ea:	2b00      	cmp	r3, #0
 800b5ec:	bf14      	ite	ne
 800b5ee:	2301      	movne	r3, #1
 800b5f0:	2300      	moveq	r3, #0
 800b5f2:	b2db      	uxtb	r3, r3
 800b5f4:	e08d      	b.n	800b712 <HAL_DMA_IRQHandler+0x1d96>
 800b5f6:	4b36      	ldr	r3, [pc, #216]	; (800b6d0 <HAL_DMA_IRQHandler+0x1d54>)
 800b5f8:	681a      	ldr	r2, [r3, #0]
 800b5fa:	687b      	ldr	r3, [r7, #4]
 800b5fc:	681b      	ldr	r3, [r3, #0]
 800b5fe:	4619      	mov	r1, r3
 800b600:	4b34      	ldr	r3, [pc, #208]	; (800b6d4 <HAL_DMA_IRQHandler+0x1d58>)
 800b602:	4299      	cmp	r1, r3
 800b604:	d07e      	beq.n	800b704 <HAL_DMA_IRQHandler+0x1d88>
 800b606:	687b      	ldr	r3, [r7, #4]
 800b608:	681b      	ldr	r3, [r3, #0]
 800b60a:	4619      	mov	r1, r3
 800b60c:	4b32      	ldr	r3, [pc, #200]	; (800b6d8 <HAL_DMA_IRQHandler+0x1d5c>)
 800b60e:	4299      	cmp	r1, r3
 800b610:	d05a      	beq.n	800b6c8 <HAL_DMA_IRQHandler+0x1d4c>
 800b612:	687b      	ldr	r3, [r7, #4]
 800b614:	681b      	ldr	r3, [r3, #0]
 800b616:	4619      	mov	r1, r3
 800b618:	4b30      	ldr	r3, [pc, #192]	; (800b6dc <HAL_DMA_IRQHandler+0x1d60>)
 800b61a:	4299      	cmp	r1, r3
 800b61c:	d052      	beq.n	800b6c4 <HAL_DMA_IRQHandler+0x1d48>
 800b61e:	687b      	ldr	r3, [r7, #4]
 800b620:	681b      	ldr	r3, [r3, #0]
 800b622:	4619      	mov	r1, r3
 800b624:	4b2e      	ldr	r3, [pc, #184]	; (800b6e0 <HAL_DMA_IRQHandler+0x1d64>)
 800b626:	4299      	cmp	r1, r3
 800b628:	d04a      	beq.n	800b6c0 <HAL_DMA_IRQHandler+0x1d44>
 800b62a:	687b      	ldr	r3, [r7, #4]
 800b62c:	681b      	ldr	r3, [r3, #0]
 800b62e:	4619      	mov	r1, r3
 800b630:	4b2c      	ldr	r3, [pc, #176]	; (800b6e4 <HAL_DMA_IRQHandler+0x1d68>)
 800b632:	4299      	cmp	r1, r3
 800b634:	d041      	beq.n	800b6ba <HAL_DMA_IRQHandler+0x1d3e>
 800b636:	687b      	ldr	r3, [r7, #4]
 800b638:	681b      	ldr	r3, [r3, #0]
 800b63a:	4619      	mov	r1, r3
 800b63c:	4b2a      	ldr	r3, [pc, #168]	; (800b6e8 <HAL_DMA_IRQHandler+0x1d6c>)
 800b63e:	4299      	cmp	r1, r3
 800b640:	d038      	beq.n	800b6b4 <HAL_DMA_IRQHandler+0x1d38>
 800b642:	687b      	ldr	r3, [r7, #4]
 800b644:	681b      	ldr	r3, [r3, #0]
 800b646:	4619      	mov	r1, r3
 800b648:	4b28      	ldr	r3, [pc, #160]	; (800b6ec <HAL_DMA_IRQHandler+0x1d70>)
 800b64a:	4299      	cmp	r1, r3
 800b64c:	d02f      	beq.n	800b6ae <HAL_DMA_IRQHandler+0x1d32>
 800b64e:	687b      	ldr	r3, [r7, #4]
 800b650:	681b      	ldr	r3, [r3, #0]
 800b652:	4619      	mov	r1, r3
 800b654:	4b26      	ldr	r3, [pc, #152]	; (800b6f0 <HAL_DMA_IRQHandler+0x1d74>)
 800b656:	4299      	cmp	r1, r3
 800b658:	d026      	beq.n	800b6a8 <HAL_DMA_IRQHandler+0x1d2c>
 800b65a:	687b      	ldr	r3, [r7, #4]
 800b65c:	681b      	ldr	r3, [r3, #0]
 800b65e:	4619      	mov	r1, r3
 800b660:	4b24      	ldr	r3, [pc, #144]	; (800b6f4 <HAL_DMA_IRQHandler+0x1d78>)
 800b662:	4299      	cmp	r1, r3
 800b664:	d01d      	beq.n	800b6a2 <HAL_DMA_IRQHandler+0x1d26>
 800b666:	687b      	ldr	r3, [r7, #4]
 800b668:	681b      	ldr	r3, [r3, #0]
 800b66a:	4619      	mov	r1, r3
 800b66c:	4b22      	ldr	r3, [pc, #136]	; (800b6f8 <HAL_DMA_IRQHandler+0x1d7c>)
 800b66e:	4299      	cmp	r1, r3
 800b670:	d014      	beq.n	800b69c <HAL_DMA_IRQHandler+0x1d20>
 800b672:	687b      	ldr	r3, [r7, #4]
 800b674:	681b      	ldr	r3, [r3, #0]
 800b676:	4619      	mov	r1, r3
 800b678:	4b20      	ldr	r3, [pc, #128]	; (800b6fc <HAL_DMA_IRQHandler+0x1d80>)
 800b67a:	4299      	cmp	r1, r3
 800b67c:	d00b      	beq.n	800b696 <HAL_DMA_IRQHandler+0x1d1a>
 800b67e:	687b      	ldr	r3, [r7, #4]
 800b680:	681b      	ldr	r3, [r3, #0]
 800b682:	4619      	mov	r1, r3
 800b684:	4b1e      	ldr	r3, [pc, #120]	; (800b700 <HAL_DMA_IRQHandler+0x1d84>)
 800b686:	4299      	cmp	r1, r3
 800b688:	d102      	bne.n	800b690 <HAL_DMA_IRQHandler+0x1d14>
 800b68a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b68e:	e03a      	b.n	800b706 <HAL_DMA_IRQHandler+0x1d8a>
 800b690:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800b694:	e037      	b.n	800b706 <HAL_DMA_IRQHandler+0x1d8a>
 800b696:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b69a:	e034      	b.n	800b706 <HAL_DMA_IRQHandler+0x1d8a>
 800b69c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b6a0:	e031      	b.n	800b706 <HAL_DMA_IRQHandler+0x1d8a>
 800b6a2:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b6a6:	e02e      	b.n	800b706 <HAL_DMA_IRQHandler+0x1d8a>
 800b6a8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b6ac:	e02b      	b.n	800b706 <HAL_DMA_IRQHandler+0x1d8a>
 800b6ae:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b6b2:	e028      	b.n	800b706 <HAL_DMA_IRQHandler+0x1d8a>
 800b6b4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b6b8:	e025      	b.n	800b706 <HAL_DMA_IRQHandler+0x1d8a>
 800b6ba:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b6be:	e022      	b.n	800b706 <HAL_DMA_IRQHandler+0x1d8a>
 800b6c0:	2310      	movs	r3, #16
 800b6c2:	e020      	b.n	800b706 <HAL_DMA_IRQHandler+0x1d8a>
 800b6c4:	2310      	movs	r3, #16
 800b6c6:	e01e      	b.n	800b706 <HAL_DMA_IRQHandler+0x1d8a>
 800b6c8:	2310      	movs	r3, #16
 800b6ca:	e01c      	b.n	800b706 <HAL_DMA_IRQHandler+0x1d8a>
 800b6cc:	40026058 	.word	0x40026058
 800b6d0:	40026000 	.word	0x40026000
 800b6d4:	40026010 	.word	0x40026010
 800b6d8:	40026410 	.word	0x40026410
 800b6dc:	40026070 	.word	0x40026070
 800b6e0:	40026470 	.word	0x40026470
 800b6e4:	40026028 	.word	0x40026028
 800b6e8:	40026428 	.word	0x40026428
 800b6ec:	40026088 	.word	0x40026088
 800b6f0:	40026488 	.word	0x40026488
 800b6f4:	40026040 	.word	0x40026040
 800b6f8:	40026440 	.word	0x40026440
 800b6fc:	400260a0 	.word	0x400260a0
 800b700:	400264a0 	.word	0x400264a0
 800b704:	2310      	movs	r3, #16
 800b706:	4013      	ands	r3, r2
 800b708:	2b00      	cmp	r3, #0
 800b70a:	bf14      	ite	ne
 800b70c:	2301      	movne	r3, #1
 800b70e:	2300      	moveq	r3, #0
 800b710:	b2db      	uxtb	r3, r3
 800b712:	2b00      	cmp	r3, #0
 800b714:	f000 8433 	beq.w	800bf7e <HAL_DMA_IRQHandler+0x2602>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 800b718:	687b      	ldr	r3, [r7, #4]
 800b71a:	681b      	ldr	r3, [r3, #0]
 800b71c:	681b      	ldr	r3, [r3, #0]
 800b71e:	f003 0308 	and.w	r3, r3, #8
 800b722:	2b00      	cmp	r3, #0
 800b724:	f000 842b 	beq.w	800bf7e <HAL_DMA_IRQHandler+0x2602>
    { 
      /* Multi_Buffering mode enabled */
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
 800b728:	687b      	ldr	r3, [r7, #4]
 800b72a:	681b      	ldr	r3, [r3, #0]
 800b72c:	681b      	ldr	r3, [r3, #0]
 800b72e:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800b732:	2b00      	cmp	r3, #0
 800b734:	f000 8203 	beq.w	800bb3e <HAL_DMA_IRQHandler+0x21c2>
      {
        /* Clear the half transfer complete flag */
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 800b738:	687b      	ldr	r3, [r7, #4]
 800b73a:	681b      	ldr	r3, [r3, #0]
 800b73c:	461a      	mov	r2, r3
 800b73e:	4ba0      	ldr	r3, [pc, #640]	; (800b9c0 <HAL_DMA_IRQHandler+0x2044>)
 800b740:	429a      	cmp	r2, r3
 800b742:	d96c      	bls.n	800b81e <HAL_DMA_IRQHandler+0x1ea2>
 800b744:	4a9f      	ldr	r2, [pc, #636]	; (800b9c4 <HAL_DMA_IRQHandler+0x2048>)
 800b746:	687b      	ldr	r3, [r7, #4]
 800b748:	681b      	ldr	r3, [r3, #0]
 800b74a:	4619      	mov	r1, r3
 800b74c:	4b9e      	ldr	r3, [pc, #632]	; (800b9c8 <HAL_DMA_IRQHandler+0x204c>)
 800b74e:	4299      	cmp	r1, r3
 800b750:	d062      	beq.n	800b818 <HAL_DMA_IRQHandler+0x1e9c>
 800b752:	687b      	ldr	r3, [r7, #4]
 800b754:	681b      	ldr	r3, [r3, #0]
 800b756:	4619      	mov	r1, r3
 800b758:	4b9c      	ldr	r3, [pc, #624]	; (800b9cc <HAL_DMA_IRQHandler+0x2050>)
 800b75a:	4299      	cmp	r1, r3
 800b75c:	d05a      	beq.n	800b814 <HAL_DMA_IRQHandler+0x1e98>
 800b75e:	687b      	ldr	r3, [r7, #4]
 800b760:	681b      	ldr	r3, [r3, #0]
 800b762:	4619      	mov	r1, r3
 800b764:	4b9a      	ldr	r3, [pc, #616]	; (800b9d0 <HAL_DMA_IRQHandler+0x2054>)
 800b766:	4299      	cmp	r1, r3
 800b768:	d052      	beq.n	800b810 <HAL_DMA_IRQHandler+0x1e94>
 800b76a:	687b      	ldr	r3, [r7, #4]
 800b76c:	681b      	ldr	r3, [r3, #0]
 800b76e:	4619      	mov	r1, r3
 800b770:	4b98      	ldr	r3, [pc, #608]	; (800b9d4 <HAL_DMA_IRQHandler+0x2058>)
 800b772:	4299      	cmp	r1, r3
 800b774:	d04a      	beq.n	800b80c <HAL_DMA_IRQHandler+0x1e90>
 800b776:	687b      	ldr	r3, [r7, #4]
 800b778:	681b      	ldr	r3, [r3, #0]
 800b77a:	4619      	mov	r1, r3
 800b77c:	4b96      	ldr	r3, [pc, #600]	; (800b9d8 <HAL_DMA_IRQHandler+0x205c>)
 800b77e:	4299      	cmp	r1, r3
 800b780:	d041      	beq.n	800b806 <HAL_DMA_IRQHandler+0x1e8a>
 800b782:	687b      	ldr	r3, [r7, #4]
 800b784:	681b      	ldr	r3, [r3, #0]
 800b786:	4619      	mov	r1, r3
 800b788:	4b94      	ldr	r3, [pc, #592]	; (800b9dc <HAL_DMA_IRQHandler+0x2060>)
 800b78a:	4299      	cmp	r1, r3
 800b78c:	d038      	beq.n	800b800 <HAL_DMA_IRQHandler+0x1e84>
 800b78e:	687b      	ldr	r3, [r7, #4]
 800b790:	681b      	ldr	r3, [r3, #0]
 800b792:	4619      	mov	r1, r3
 800b794:	4b92      	ldr	r3, [pc, #584]	; (800b9e0 <HAL_DMA_IRQHandler+0x2064>)
 800b796:	4299      	cmp	r1, r3
 800b798:	d02f      	beq.n	800b7fa <HAL_DMA_IRQHandler+0x1e7e>
 800b79a:	687b      	ldr	r3, [r7, #4]
 800b79c:	681b      	ldr	r3, [r3, #0]
 800b79e:	4619      	mov	r1, r3
 800b7a0:	4b90      	ldr	r3, [pc, #576]	; (800b9e4 <HAL_DMA_IRQHandler+0x2068>)
 800b7a2:	4299      	cmp	r1, r3
 800b7a4:	d026      	beq.n	800b7f4 <HAL_DMA_IRQHandler+0x1e78>
 800b7a6:	687b      	ldr	r3, [r7, #4]
 800b7a8:	681b      	ldr	r3, [r3, #0]
 800b7aa:	4619      	mov	r1, r3
 800b7ac:	4b8e      	ldr	r3, [pc, #568]	; (800b9e8 <HAL_DMA_IRQHandler+0x206c>)
 800b7ae:	4299      	cmp	r1, r3
 800b7b0:	d01d      	beq.n	800b7ee <HAL_DMA_IRQHandler+0x1e72>
 800b7b2:	687b      	ldr	r3, [r7, #4]
 800b7b4:	681b      	ldr	r3, [r3, #0]
 800b7b6:	4619      	mov	r1, r3
 800b7b8:	4b8c      	ldr	r3, [pc, #560]	; (800b9ec <HAL_DMA_IRQHandler+0x2070>)
 800b7ba:	4299      	cmp	r1, r3
 800b7bc:	d014      	beq.n	800b7e8 <HAL_DMA_IRQHandler+0x1e6c>
 800b7be:	687b      	ldr	r3, [r7, #4]
 800b7c0:	681b      	ldr	r3, [r3, #0]
 800b7c2:	4619      	mov	r1, r3
 800b7c4:	4b8a      	ldr	r3, [pc, #552]	; (800b9f0 <HAL_DMA_IRQHandler+0x2074>)
 800b7c6:	4299      	cmp	r1, r3
 800b7c8:	d00b      	beq.n	800b7e2 <HAL_DMA_IRQHandler+0x1e66>
 800b7ca:	687b      	ldr	r3, [r7, #4]
 800b7cc:	681b      	ldr	r3, [r3, #0]
 800b7ce:	4619      	mov	r1, r3
 800b7d0:	4b88      	ldr	r3, [pc, #544]	; (800b9f4 <HAL_DMA_IRQHandler+0x2078>)
 800b7d2:	4299      	cmp	r1, r3
 800b7d4:	d102      	bne.n	800b7dc <HAL_DMA_IRQHandler+0x1e60>
 800b7d6:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b7da:	e01e      	b.n	800b81a <HAL_DMA_IRQHandler+0x1e9e>
 800b7dc:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800b7e0:	e01b      	b.n	800b81a <HAL_DMA_IRQHandler+0x1e9e>
 800b7e2:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b7e6:	e018      	b.n	800b81a <HAL_DMA_IRQHandler+0x1e9e>
 800b7e8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b7ec:	e015      	b.n	800b81a <HAL_DMA_IRQHandler+0x1e9e>
 800b7ee:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b7f2:	e012      	b.n	800b81a <HAL_DMA_IRQHandler+0x1e9e>
 800b7f4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b7f8:	e00f      	b.n	800b81a <HAL_DMA_IRQHandler+0x1e9e>
 800b7fa:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b7fe:	e00c      	b.n	800b81a <HAL_DMA_IRQHandler+0x1e9e>
 800b800:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b804:	e009      	b.n	800b81a <HAL_DMA_IRQHandler+0x1e9e>
 800b806:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b80a:	e006      	b.n	800b81a <HAL_DMA_IRQHandler+0x1e9e>
 800b80c:	2310      	movs	r3, #16
 800b80e:	e004      	b.n	800b81a <HAL_DMA_IRQHandler+0x1e9e>
 800b810:	2310      	movs	r3, #16
 800b812:	e002      	b.n	800b81a <HAL_DMA_IRQHandler+0x1e9e>
 800b814:	2310      	movs	r3, #16
 800b816:	e000      	b.n	800b81a <HAL_DMA_IRQHandler+0x1e9e>
 800b818:	2310      	movs	r3, #16
 800b81a:	60d3      	str	r3, [r2, #12]
 800b81c:	e176      	b.n	800bb0c <HAL_DMA_IRQHandler+0x2190>
 800b81e:	687b      	ldr	r3, [r7, #4]
 800b820:	681b      	ldr	r3, [r3, #0]
 800b822:	461a      	mov	r2, r3
 800b824:	4b74      	ldr	r3, [pc, #464]	; (800b9f8 <HAL_DMA_IRQHandler+0x207c>)
 800b826:	429a      	cmp	r2, r3
 800b828:	d96c      	bls.n	800b904 <HAL_DMA_IRQHandler+0x1f88>
 800b82a:	4a66      	ldr	r2, [pc, #408]	; (800b9c4 <HAL_DMA_IRQHandler+0x2048>)
 800b82c:	687b      	ldr	r3, [r7, #4]
 800b82e:	681b      	ldr	r3, [r3, #0]
 800b830:	4619      	mov	r1, r3
 800b832:	4b65      	ldr	r3, [pc, #404]	; (800b9c8 <HAL_DMA_IRQHandler+0x204c>)
 800b834:	4299      	cmp	r1, r3
 800b836:	d062      	beq.n	800b8fe <HAL_DMA_IRQHandler+0x1f82>
 800b838:	687b      	ldr	r3, [r7, #4]
 800b83a:	681b      	ldr	r3, [r3, #0]
 800b83c:	4619      	mov	r1, r3
 800b83e:	4b63      	ldr	r3, [pc, #396]	; (800b9cc <HAL_DMA_IRQHandler+0x2050>)
 800b840:	4299      	cmp	r1, r3
 800b842:	d05a      	beq.n	800b8fa <HAL_DMA_IRQHandler+0x1f7e>
 800b844:	687b      	ldr	r3, [r7, #4]
 800b846:	681b      	ldr	r3, [r3, #0]
 800b848:	4619      	mov	r1, r3
 800b84a:	4b61      	ldr	r3, [pc, #388]	; (800b9d0 <HAL_DMA_IRQHandler+0x2054>)
 800b84c:	4299      	cmp	r1, r3
 800b84e:	d052      	beq.n	800b8f6 <HAL_DMA_IRQHandler+0x1f7a>
 800b850:	687b      	ldr	r3, [r7, #4]
 800b852:	681b      	ldr	r3, [r3, #0]
 800b854:	4619      	mov	r1, r3
 800b856:	4b5f      	ldr	r3, [pc, #380]	; (800b9d4 <HAL_DMA_IRQHandler+0x2058>)
 800b858:	4299      	cmp	r1, r3
 800b85a:	d04a      	beq.n	800b8f2 <HAL_DMA_IRQHandler+0x1f76>
 800b85c:	687b      	ldr	r3, [r7, #4]
 800b85e:	681b      	ldr	r3, [r3, #0]
 800b860:	4619      	mov	r1, r3
 800b862:	4b5d      	ldr	r3, [pc, #372]	; (800b9d8 <HAL_DMA_IRQHandler+0x205c>)
 800b864:	4299      	cmp	r1, r3
 800b866:	d041      	beq.n	800b8ec <HAL_DMA_IRQHandler+0x1f70>
 800b868:	687b      	ldr	r3, [r7, #4]
 800b86a:	681b      	ldr	r3, [r3, #0]
 800b86c:	4619      	mov	r1, r3
 800b86e:	4b5b      	ldr	r3, [pc, #364]	; (800b9dc <HAL_DMA_IRQHandler+0x2060>)
 800b870:	4299      	cmp	r1, r3
 800b872:	d038      	beq.n	800b8e6 <HAL_DMA_IRQHandler+0x1f6a>
 800b874:	687b      	ldr	r3, [r7, #4]
 800b876:	681b      	ldr	r3, [r3, #0]
 800b878:	4619      	mov	r1, r3
 800b87a:	4b59      	ldr	r3, [pc, #356]	; (800b9e0 <HAL_DMA_IRQHandler+0x2064>)
 800b87c:	4299      	cmp	r1, r3
 800b87e:	d02f      	beq.n	800b8e0 <HAL_DMA_IRQHandler+0x1f64>
 800b880:	687b      	ldr	r3, [r7, #4]
 800b882:	681b      	ldr	r3, [r3, #0]
 800b884:	4619      	mov	r1, r3
 800b886:	4b57      	ldr	r3, [pc, #348]	; (800b9e4 <HAL_DMA_IRQHandler+0x2068>)
 800b888:	4299      	cmp	r1, r3
 800b88a:	d026      	beq.n	800b8da <HAL_DMA_IRQHandler+0x1f5e>
 800b88c:	687b      	ldr	r3, [r7, #4]
 800b88e:	681b      	ldr	r3, [r3, #0]
 800b890:	4619      	mov	r1, r3
 800b892:	4b55      	ldr	r3, [pc, #340]	; (800b9e8 <HAL_DMA_IRQHandler+0x206c>)
 800b894:	4299      	cmp	r1, r3
 800b896:	d01d      	beq.n	800b8d4 <HAL_DMA_IRQHandler+0x1f58>
 800b898:	687b      	ldr	r3, [r7, #4]
 800b89a:	681b      	ldr	r3, [r3, #0]
 800b89c:	4619      	mov	r1, r3
 800b89e:	4b53      	ldr	r3, [pc, #332]	; (800b9ec <HAL_DMA_IRQHandler+0x2070>)
 800b8a0:	4299      	cmp	r1, r3
 800b8a2:	d014      	beq.n	800b8ce <HAL_DMA_IRQHandler+0x1f52>
 800b8a4:	687b      	ldr	r3, [r7, #4]
 800b8a6:	681b      	ldr	r3, [r3, #0]
 800b8a8:	4619      	mov	r1, r3
 800b8aa:	4b51      	ldr	r3, [pc, #324]	; (800b9f0 <HAL_DMA_IRQHandler+0x2074>)
 800b8ac:	4299      	cmp	r1, r3
 800b8ae:	d00b      	beq.n	800b8c8 <HAL_DMA_IRQHandler+0x1f4c>
 800b8b0:	687b      	ldr	r3, [r7, #4]
 800b8b2:	681b      	ldr	r3, [r3, #0]
 800b8b4:	4619      	mov	r1, r3
 800b8b6:	4b4f      	ldr	r3, [pc, #316]	; (800b9f4 <HAL_DMA_IRQHandler+0x2078>)
 800b8b8:	4299      	cmp	r1, r3
 800b8ba:	d102      	bne.n	800b8c2 <HAL_DMA_IRQHandler+0x1f46>
 800b8bc:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b8c0:	e01e      	b.n	800b900 <HAL_DMA_IRQHandler+0x1f84>
 800b8c2:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800b8c6:	e01b      	b.n	800b900 <HAL_DMA_IRQHandler+0x1f84>
 800b8c8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b8cc:	e018      	b.n	800b900 <HAL_DMA_IRQHandler+0x1f84>
 800b8ce:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b8d2:	e015      	b.n	800b900 <HAL_DMA_IRQHandler+0x1f84>
 800b8d4:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b8d8:	e012      	b.n	800b900 <HAL_DMA_IRQHandler+0x1f84>
 800b8da:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b8de:	e00f      	b.n	800b900 <HAL_DMA_IRQHandler+0x1f84>
 800b8e0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b8e4:	e00c      	b.n	800b900 <HAL_DMA_IRQHandler+0x1f84>
 800b8e6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b8ea:	e009      	b.n	800b900 <HAL_DMA_IRQHandler+0x1f84>
 800b8ec:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b8f0:	e006      	b.n	800b900 <HAL_DMA_IRQHandler+0x1f84>
 800b8f2:	2310      	movs	r3, #16
 800b8f4:	e004      	b.n	800b900 <HAL_DMA_IRQHandler+0x1f84>
 800b8f6:	2310      	movs	r3, #16
 800b8f8:	e002      	b.n	800b900 <HAL_DMA_IRQHandler+0x1f84>
 800b8fa:	2310      	movs	r3, #16
 800b8fc:	e000      	b.n	800b900 <HAL_DMA_IRQHandler+0x1f84>
 800b8fe:	2310      	movs	r3, #16
 800b900:	6093      	str	r3, [r2, #8]
 800b902:	e103      	b.n	800bb0c <HAL_DMA_IRQHandler+0x2190>
 800b904:	687b      	ldr	r3, [r7, #4]
 800b906:	681b      	ldr	r3, [r3, #0]
 800b908:	461a      	mov	r2, r3
 800b90a:	4b3c      	ldr	r3, [pc, #240]	; (800b9fc <HAL_DMA_IRQHandler+0x2080>)
 800b90c:	429a      	cmp	r2, r3
 800b90e:	f240 8091 	bls.w	800ba34 <HAL_DMA_IRQHandler+0x20b8>
 800b912:	4a3b      	ldr	r2, [pc, #236]	; (800ba00 <HAL_DMA_IRQHandler+0x2084>)
 800b914:	687b      	ldr	r3, [r7, #4]
 800b916:	681b      	ldr	r3, [r3, #0]
 800b918:	4619      	mov	r1, r3
 800b91a:	4b2b      	ldr	r3, [pc, #172]	; (800b9c8 <HAL_DMA_IRQHandler+0x204c>)
 800b91c:	4299      	cmp	r1, r3
 800b91e:	f000 8086 	beq.w	800ba2e <HAL_DMA_IRQHandler+0x20b2>
 800b922:	687b      	ldr	r3, [r7, #4]
 800b924:	681b      	ldr	r3, [r3, #0]
 800b926:	4619      	mov	r1, r3
 800b928:	4b28      	ldr	r3, [pc, #160]	; (800b9cc <HAL_DMA_IRQHandler+0x2050>)
 800b92a:	4299      	cmp	r1, r3
 800b92c:	d07d      	beq.n	800ba2a <HAL_DMA_IRQHandler+0x20ae>
 800b92e:	687b      	ldr	r3, [r7, #4]
 800b930:	681b      	ldr	r3, [r3, #0]
 800b932:	4619      	mov	r1, r3
 800b934:	4b26      	ldr	r3, [pc, #152]	; (800b9d0 <HAL_DMA_IRQHandler+0x2054>)
 800b936:	4299      	cmp	r1, r3
 800b938:	d075      	beq.n	800ba26 <HAL_DMA_IRQHandler+0x20aa>
 800b93a:	687b      	ldr	r3, [r7, #4]
 800b93c:	681b      	ldr	r3, [r3, #0]
 800b93e:	4619      	mov	r1, r3
 800b940:	4b24      	ldr	r3, [pc, #144]	; (800b9d4 <HAL_DMA_IRQHandler+0x2058>)
 800b942:	4299      	cmp	r1, r3
 800b944:	d06d      	beq.n	800ba22 <HAL_DMA_IRQHandler+0x20a6>
 800b946:	687b      	ldr	r3, [r7, #4]
 800b948:	681b      	ldr	r3, [r3, #0]
 800b94a:	4619      	mov	r1, r3
 800b94c:	4b22      	ldr	r3, [pc, #136]	; (800b9d8 <HAL_DMA_IRQHandler+0x205c>)
 800b94e:	4299      	cmp	r1, r3
 800b950:	d064      	beq.n	800ba1c <HAL_DMA_IRQHandler+0x20a0>
 800b952:	687b      	ldr	r3, [r7, #4]
 800b954:	681b      	ldr	r3, [r3, #0]
 800b956:	4619      	mov	r1, r3
 800b958:	4b20      	ldr	r3, [pc, #128]	; (800b9dc <HAL_DMA_IRQHandler+0x2060>)
 800b95a:	4299      	cmp	r1, r3
 800b95c:	d05b      	beq.n	800ba16 <HAL_DMA_IRQHandler+0x209a>
 800b95e:	687b      	ldr	r3, [r7, #4]
 800b960:	681b      	ldr	r3, [r3, #0]
 800b962:	4619      	mov	r1, r3
 800b964:	4b1e      	ldr	r3, [pc, #120]	; (800b9e0 <HAL_DMA_IRQHandler+0x2064>)
 800b966:	4299      	cmp	r1, r3
 800b968:	d052      	beq.n	800ba10 <HAL_DMA_IRQHandler+0x2094>
 800b96a:	687b      	ldr	r3, [r7, #4]
 800b96c:	681b      	ldr	r3, [r3, #0]
 800b96e:	4619      	mov	r1, r3
 800b970:	4b1c      	ldr	r3, [pc, #112]	; (800b9e4 <HAL_DMA_IRQHandler+0x2068>)
 800b972:	4299      	cmp	r1, r3
 800b974:	d049      	beq.n	800ba0a <HAL_DMA_IRQHandler+0x208e>
 800b976:	687b      	ldr	r3, [r7, #4]
 800b978:	681b      	ldr	r3, [r3, #0]
 800b97a:	4619      	mov	r1, r3
 800b97c:	4b1a      	ldr	r3, [pc, #104]	; (800b9e8 <HAL_DMA_IRQHandler+0x206c>)
 800b97e:	4299      	cmp	r1, r3
 800b980:	d040      	beq.n	800ba04 <HAL_DMA_IRQHandler+0x2088>
 800b982:	687b      	ldr	r3, [r7, #4]
 800b984:	681b      	ldr	r3, [r3, #0]
 800b986:	4619      	mov	r1, r3
 800b988:	4b18      	ldr	r3, [pc, #96]	; (800b9ec <HAL_DMA_IRQHandler+0x2070>)
 800b98a:	4299      	cmp	r1, r3
 800b98c:	d014      	beq.n	800b9b8 <HAL_DMA_IRQHandler+0x203c>
 800b98e:	687b      	ldr	r3, [r7, #4]
 800b990:	681b      	ldr	r3, [r3, #0]
 800b992:	4619      	mov	r1, r3
 800b994:	4b16      	ldr	r3, [pc, #88]	; (800b9f0 <HAL_DMA_IRQHandler+0x2074>)
 800b996:	4299      	cmp	r1, r3
 800b998:	d00b      	beq.n	800b9b2 <HAL_DMA_IRQHandler+0x2036>
 800b99a:	687b      	ldr	r3, [r7, #4]
 800b99c:	681b      	ldr	r3, [r3, #0]
 800b99e:	4619      	mov	r1, r3
 800b9a0:	4b14      	ldr	r3, [pc, #80]	; (800b9f4 <HAL_DMA_IRQHandler+0x2078>)
 800b9a2:	4299      	cmp	r1, r3
 800b9a4:	d102      	bne.n	800b9ac <HAL_DMA_IRQHandler+0x2030>
 800b9a6:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b9aa:	e041      	b.n	800ba30 <HAL_DMA_IRQHandler+0x20b4>
 800b9ac:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800b9b0:	e03e      	b.n	800ba30 <HAL_DMA_IRQHandler+0x20b4>
 800b9b2:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b9b6:	e03b      	b.n	800ba30 <HAL_DMA_IRQHandler+0x20b4>
 800b9b8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b9bc:	e038      	b.n	800ba30 <HAL_DMA_IRQHandler+0x20b4>
 800b9be:	bf00      	nop
 800b9c0:	40026458 	.word	0x40026458
 800b9c4:	40026400 	.word	0x40026400
 800b9c8:	40026010 	.word	0x40026010
 800b9cc:	40026410 	.word	0x40026410
 800b9d0:	40026070 	.word	0x40026070
 800b9d4:	40026470 	.word	0x40026470
 800b9d8:	40026028 	.word	0x40026028
 800b9dc:	40026428 	.word	0x40026428
 800b9e0:	40026088 	.word	0x40026088
 800b9e4:	40026488 	.word	0x40026488
 800b9e8:	40026040 	.word	0x40026040
 800b9ec:	40026440 	.word	0x40026440
 800b9f0:	400260a0 	.word	0x400260a0
 800b9f4:	400264a0 	.word	0x400264a0
 800b9f8:	400260b8 	.word	0x400260b8
 800b9fc:	40026058 	.word	0x40026058
 800ba00:	40026000 	.word	0x40026000
 800ba04:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800ba08:	e012      	b.n	800ba30 <HAL_DMA_IRQHandler+0x20b4>
 800ba0a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800ba0e:	e00f      	b.n	800ba30 <HAL_DMA_IRQHandler+0x20b4>
 800ba10:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800ba14:	e00c      	b.n	800ba30 <HAL_DMA_IRQHandler+0x20b4>
 800ba16:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800ba1a:	e009      	b.n	800ba30 <HAL_DMA_IRQHandler+0x20b4>
 800ba1c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800ba20:	e006      	b.n	800ba30 <HAL_DMA_IRQHandler+0x20b4>
 800ba22:	2310      	movs	r3, #16
 800ba24:	e004      	b.n	800ba30 <HAL_DMA_IRQHandler+0x20b4>
 800ba26:	2310      	movs	r3, #16
 800ba28:	e002      	b.n	800ba30 <HAL_DMA_IRQHandler+0x20b4>
 800ba2a:	2310      	movs	r3, #16
 800ba2c:	e000      	b.n	800ba30 <HAL_DMA_IRQHandler+0x20b4>
 800ba2e:	2310      	movs	r3, #16
 800ba30:	60d3      	str	r3, [r2, #12]
 800ba32:	e06b      	b.n	800bb0c <HAL_DMA_IRQHandler+0x2190>
 800ba34:	4a83      	ldr	r2, [pc, #524]	; (800bc44 <HAL_DMA_IRQHandler+0x22c8>)
 800ba36:	687b      	ldr	r3, [r7, #4]
 800ba38:	681b      	ldr	r3, [r3, #0]
 800ba3a:	4619      	mov	r1, r3
 800ba3c:	4b82      	ldr	r3, [pc, #520]	; (800bc48 <HAL_DMA_IRQHandler+0x22cc>)
 800ba3e:	4299      	cmp	r1, r3
 800ba40:	d062      	beq.n	800bb08 <HAL_DMA_IRQHandler+0x218c>
 800ba42:	687b      	ldr	r3, [r7, #4]
 800ba44:	681b      	ldr	r3, [r3, #0]
 800ba46:	4619      	mov	r1, r3
 800ba48:	4b80      	ldr	r3, [pc, #512]	; (800bc4c <HAL_DMA_IRQHandler+0x22d0>)
 800ba4a:	4299      	cmp	r1, r3
 800ba4c:	d05a      	beq.n	800bb04 <HAL_DMA_IRQHandler+0x2188>
 800ba4e:	687b      	ldr	r3, [r7, #4]
 800ba50:	681b      	ldr	r3, [r3, #0]
 800ba52:	4619      	mov	r1, r3
 800ba54:	4b7e      	ldr	r3, [pc, #504]	; (800bc50 <HAL_DMA_IRQHandler+0x22d4>)
 800ba56:	4299      	cmp	r1, r3
 800ba58:	d052      	beq.n	800bb00 <HAL_DMA_IRQHandler+0x2184>
 800ba5a:	687b      	ldr	r3, [r7, #4]
 800ba5c:	681b      	ldr	r3, [r3, #0]
 800ba5e:	4619      	mov	r1, r3
 800ba60:	4b7c      	ldr	r3, [pc, #496]	; (800bc54 <HAL_DMA_IRQHandler+0x22d8>)
 800ba62:	4299      	cmp	r1, r3
 800ba64:	d04a      	beq.n	800bafc <HAL_DMA_IRQHandler+0x2180>
 800ba66:	687b      	ldr	r3, [r7, #4]
 800ba68:	681b      	ldr	r3, [r3, #0]
 800ba6a:	4619      	mov	r1, r3
 800ba6c:	4b7a      	ldr	r3, [pc, #488]	; (800bc58 <HAL_DMA_IRQHandler+0x22dc>)
 800ba6e:	4299      	cmp	r1, r3
 800ba70:	d041      	beq.n	800baf6 <HAL_DMA_IRQHandler+0x217a>
 800ba72:	687b      	ldr	r3, [r7, #4]
 800ba74:	681b      	ldr	r3, [r3, #0]
 800ba76:	4619      	mov	r1, r3
 800ba78:	4b78      	ldr	r3, [pc, #480]	; (800bc5c <HAL_DMA_IRQHandler+0x22e0>)
 800ba7a:	4299      	cmp	r1, r3
 800ba7c:	d038      	beq.n	800baf0 <HAL_DMA_IRQHandler+0x2174>
 800ba7e:	687b      	ldr	r3, [r7, #4]
 800ba80:	681b      	ldr	r3, [r3, #0]
 800ba82:	4619      	mov	r1, r3
 800ba84:	4b76      	ldr	r3, [pc, #472]	; (800bc60 <HAL_DMA_IRQHandler+0x22e4>)
 800ba86:	4299      	cmp	r1, r3
 800ba88:	d02f      	beq.n	800baea <HAL_DMA_IRQHandler+0x216e>
 800ba8a:	687b      	ldr	r3, [r7, #4]
 800ba8c:	681b      	ldr	r3, [r3, #0]
 800ba8e:	4619      	mov	r1, r3
 800ba90:	4b74      	ldr	r3, [pc, #464]	; (800bc64 <HAL_DMA_IRQHandler+0x22e8>)
 800ba92:	4299      	cmp	r1, r3
 800ba94:	d026      	beq.n	800bae4 <HAL_DMA_IRQHandler+0x2168>
 800ba96:	687b      	ldr	r3, [r7, #4]
 800ba98:	681b      	ldr	r3, [r3, #0]
 800ba9a:	4619      	mov	r1, r3
 800ba9c:	4b72      	ldr	r3, [pc, #456]	; (800bc68 <HAL_DMA_IRQHandler+0x22ec>)
 800ba9e:	4299      	cmp	r1, r3
 800baa0:	d01d      	beq.n	800bade <HAL_DMA_IRQHandler+0x2162>
 800baa2:	687b      	ldr	r3, [r7, #4]
 800baa4:	681b      	ldr	r3, [r3, #0]
 800baa6:	4619      	mov	r1, r3
 800baa8:	4b70      	ldr	r3, [pc, #448]	; (800bc6c <HAL_DMA_IRQHandler+0x22f0>)
 800baaa:	4299      	cmp	r1, r3
 800baac:	d014      	beq.n	800bad8 <HAL_DMA_IRQHandler+0x215c>
 800baae:	687b      	ldr	r3, [r7, #4]
 800bab0:	681b      	ldr	r3, [r3, #0]
 800bab2:	4619      	mov	r1, r3
 800bab4:	4b6e      	ldr	r3, [pc, #440]	; (800bc70 <HAL_DMA_IRQHandler+0x22f4>)
 800bab6:	4299      	cmp	r1, r3
 800bab8:	d00b      	beq.n	800bad2 <HAL_DMA_IRQHandler+0x2156>
 800baba:	687b      	ldr	r3, [r7, #4]
 800babc:	681b      	ldr	r3, [r3, #0]
 800babe:	4619      	mov	r1, r3
 800bac0:	4b6c      	ldr	r3, [pc, #432]	; (800bc74 <HAL_DMA_IRQHandler+0x22f8>)
 800bac2:	4299      	cmp	r1, r3
 800bac4:	d102      	bne.n	800bacc <HAL_DMA_IRQHandler+0x2150>
 800bac6:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800baca:	e01e      	b.n	800bb0a <HAL_DMA_IRQHandler+0x218e>
 800bacc:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800bad0:	e01b      	b.n	800bb0a <HAL_DMA_IRQHandler+0x218e>
 800bad2:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bad6:	e018      	b.n	800bb0a <HAL_DMA_IRQHandler+0x218e>
 800bad8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800badc:	e015      	b.n	800bb0a <HAL_DMA_IRQHandler+0x218e>
 800bade:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bae2:	e012      	b.n	800bb0a <HAL_DMA_IRQHandler+0x218e>
 800bae4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bae8:	e00f      	b.n	800bb0a <HAL_DMA_IRQHandler+0x218e>
 800baea:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800baee:	e00c      	b.n	800bb0a <HAL_DMA_IRQHandler+0x218e>
 800baf0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800baf4:	e009      	b.n	800bb0a <HAL_DMA_IRQHandler+0x218e>
 800baf6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bafa:	e006      	b.n	800bb0a <HAL_DMA_IRQHandler+0x218e>
 800bafc:	2310      	movs	r3, #16
 800bafe:	e004      	b.n	800bb0a <HAL_DMA_IRQHandler+0x218e>
 800bb00:	2310      	movs	r3, #16
 800bb02:	e002      	b.n	800bb0a <HAL_DMA_IRQHandler+0x218e>
 800bb04:	2310      	movs	r3, #16
 800bb06:	e000      	b.n	800bb0a <HAL_DMA_IRQHandler+0x218e>
 800bb08:	2310      	movs	r3, #16
 800bb0a:	6093      	str	r3, [r2, #8]

        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
 800bb0c:	687b      	ldr	r3, [r7, #4]
 800bb0e:	681b      	ldr	r3, [r3, #0]
 800bb10:	681b      	ldr	r3, [r3, #0]
 800bb12:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800bb16:	2b00      	cmp	r3, #0
 800bb18:	d104      	bne.n	800bb24 <HAL_DMA_IRQHandler+0x21a8>
        {
          /* Change DMA peripheral state */
          hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
 800bb1a:	687b      	ldr	r3, [r7, #4]
 800bb1c:	2231      	movs	r2, #49	; 0x31
 800bb1e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 800bb22:	e224      	b.n	800bf6e <HAL_DMA_IRQHandler+0x25f2>
        }
        /* Current memory buffer used is Memory 1 */
        else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
 800bb24:	687b      	ldr	r3, [r7, #4]
 800bb26:	681b      	ldr	r3, [r3, #0]
 800bb28:	681b      	ldr	r3, [r3, #0]
 800bb2a:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800bb2e:	2b00      	cmp	r3, #0
 800bb30:	f000 821d 	beq.w	800bf6e <HAL_DMA_IRQHandler+0x25f2>
        {
          /* Change DMA peripheral state */
          hdma->State = HAL_DMA_STATE_READY_HALF_MEM1;
 800bb34:	687b      	ldr	r3, [r7, #4]
 800bb36:	2241      	movs	r2, #65	; 0x41
 800bb38:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 800bb3c:	e217      	b.n	800bf6e <HAL_DMA_IRQHandler+0x25f2>
        }
      }
      else
      {
        /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 800bb3e:	687b      	ldr	r3, [r7, #4]
 800bb40:	681b      	ldr	r3, [r3, #0]
 800bb42:	681b      	ldr	r3, [r3, #0]
 800bb44:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800bb48:	2b00      	cmp	r3, #0
 800bb4a:	d107      	bne.n	800bb5c <HAL_DMA_IRQHandler+0x21e0>
        {
          /* Disable the half transfer interrupt */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 800bb4c:	687b      	ldr	r3, [r7, #4]
 800bb4e:	681b      	ldr	r3, [r3, #0]
 800bb50:	687a      	ldr	r2, [r7, #4]
 800bb52:	6812      	ldr	r2, [r2, #0]
 800bb54:	6812      	ldr	r2, [r2, #0]
 800bb56:	f022 0208 	bic.w	r2, r2, #8
 800bb5a:	601a      	str	r2, [r3, #0]
        }
        /* Clear the half transfer complete flag */
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 800bb5c:	687b      	ldr	r3, [r7, #4]
 800bb5e:	681b      	ldr	r3, [r3, #0]
 800bb60:	461a      	mov	r2, r3
 800bb62:	4b45      	ldr	r3, [pc, #276]	; (800bc78 <HAL_DMA_IRQHandler+0x22fc>)
 800bb64:	429a      	cmp	r2, r3
 800bb66:	f240 808b 	bls.w	800bc80 <HAL_DMA_IRQHandler+0x2304>
 800bb6a:	4a44      	ldr	r2, [pc, #272]	; (800bc7c <HAL_DMA_IRQHandler+0x2300>)
 800bb6c:	687b      	ldr	r3, [r7, #4]
 800bb6e:	681b      	ldr	r3, [r3, #0]
 800bb70:	4619      	mov	r1, r3
 800bb72:	4b35      	ldr	r3, [pc, #212]	; (800bc48 <HAL_DMA_IRQHandler+0x22cc>)
 800bb74:	4299      	cmp	r1, r3
 800bb76:	d062      	beq.n	800bc3e <HAL_DMA_IRQHandler+0x22c2>
 800bb78:	687b      	ldr	r3, [r7, #4]
 800bb7a:	681b      	ldr	r3, [r3, #0]
 800bb7c:	4619      	mov	r1, r3
 800bb7e:	4b33      	ldr	r3, [pc, #204]	; (800bc4c <HAL_DMA_IRQHandler+0x22d0>)
 800bb80:	4299      	cmp	r1, r3
 800bb82:	d05a      	beq.n	800bc3a <HAL_DMA_IRQHandler+0x22be>
 800bb84:	687b      	ldr	r3, [r7, #4]
 800bb86:	681b      	ldr	r3, [r3, #0]
 800bb88:	4619      	mov	r1, r3
 800bb8a:	4b31      	ldr	r3, [pc, #196]	; (800bc50 <HAL_DMA_IRQHandler+0x22d4>)
 800bb8c:	4299      	cmp	r1, r3
 800bb8e:	d052      	beq.n	800bc36 <HAL_DMA_IRQHandler+0x22ba>
 800bb90:	687b      	ldr	r3, [r7, #4]
 800bb92:	681b      	ldr	r3, [r3, #0]
 800bb94:	4619      	mov	r1, r3
 800bb96:	4b2f      	ldr	r3, [pc, #188]	; (800bc54 <HAL_DMA_IRQHandler+0x22d8>)
 800bb98:	4299      	cmp	r1, r3
 800bb9a:	d04a      	beq.n	800bc32 <HAL_DMA_IRQHandler+0x22b6>
 800bb9c:	687b      	ldr	r3, [r7, #4]
 800bb9e:	681b      	ldr	r3, [r3, #0]
 800bba0:	4619      	mov	r1, r3
 800bba2:	4b2d      	ldr	r3, [pc, #180]	; (800bc58 <HAL_DMA_IRQHandler+0x22dc>)
 800bba4:	4299      	cmp	r1, r3
 800bba6:	d041      	beq.n	800bc2c <HAL_DMA_IRQHandler+0x22b0>
 800bba8:	687b      	ldr	r3, [r7, #4]
 800bbaa:	681b      	ldr	r3, [r3, #0]
 800bbac:	4619      	mov	r1, r3
 800bbae:	4b2b      	ldr	r3, [pc, #172]	; (800bc5c <HAL_DMA_IRQHandler+0x22e0>)
 800bbb0:	4299      	cmp	r1, r3
 800bbb2:	d038      	beq.n	800bc26 <HAL_DMA_IRQHandler+0x22aa>
 800bbb4:	687b      	ldr	r3, [r7, #4]
 800bbb6:	681b      	ldr	r3, [r3, #0]
 800bbb8:	4619      	mov	r1, r3
 800bbba:	4b29      	ldr	r3, [pc, #164]	; (800bc60 <HAL_DMA_IRQHandler+0x22e4>)
 800bbbc:	4299      	cmp	r1, r3
 800bbbe:	d02f      	beq.n	800bc20 <HAL_DMA_IRQHandler+0x22a4>
 800bbc0:	687b      	ldr	r3, [r7, #4]
 800bbc2:	681b      	ldr	r3, [r3, #0]
 800bbc4:	4619      	mov	r1, r3
 800bbc6:	4b27      	ldr	r3, [pc, #156]	; (800bc64 <HAL_DMA_IRQHandler+0x22e8>)
 800bbc8:	4299      	cmp	r1, r3
 800bbca:	d026      	beq.n	800bc1a <HAL_DMA_IRQHandler+0x229e>
 800bbcc:	687b      	ldr	r3, [r7, #4]
 800bbce:	681b      	ldr	r3, [r3, #0]
 800bbd0:	4619      	mov	r1, r3
 800bbd2:	4b25      	ldr	r3, [pc, #148]	; (800bc68 <HAL_DMA_IRQHandler+0x22ec>)
 800bbd4:	4299      	cmp	r1, r3
 800bbd6:	d01d      	beq.n	800bc14 <HAL_DMA_IRQHandler+0x2298>
 800bbd8:	687b      	ldr	r3, [r7, #4]
 800bbda:	681b      	ldr	r3, [r3, #0]
 800bbdc:	4619      	mov	r1, r3
 800bbde:	4b23      	ldr	r3, [pc, #140]	; (800bc6c <HAL_DMA_IRQHandler+0x22f0>)
 800bbe0:	4299      	cmp	r1, r3
 800bbe2:	d014      	beq.n	800bc0e <HAL_DMA_IRQHandler+0x2292>
 800bbe4:	687b      	ldr	r3, [r7, #4]
 800bbe6:	681b      	ldr	r3, [r3, #0]
 800bbe8:	4619      	mov	r1, r3
 800bbea:	4b21      	ldr	r3, [pc, #132]	; (800bc70 <HAL_DMA_IRQHandler+0x22f4>)
 800bbec:	4299      	cmp	r1, r3
 800bbee:	d00b      	beq.n	800bc08 <HAL_DMA_IRQHandler+0x228c>
 800bbf0:	687b      	ldr	r3, [r7, #4]
 800bbf2:	681b      	ldr	r3, [r3, #0]
 800bbf4:	4619      	mov	r1, r3
 800bbf6:	4b1f      	ldr	r3, [pc, #124]	; (800bc74 <HAL_DMA_IRQHandler+0x22f8>)
 800bbf8:	4299      	cmp	r1, r3
 800bbfa:	d102      	bne.n	800bc02 <HAL_DMA_IRQHandler+0x2286>
 800bbfc:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bc00:	e01e      	b.n	800bc40 <HAL_DMA_IRQHandler+0x22c4>
 800bc02:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800bc06:	e01b      	b.n	800bc40 <HAL_DMA_IRQHandler+0x22c4>
 800bc08:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bc0c:	e018      	b.n	800bc40 <HAL_DMA_IRQHandler+0x22c4>
 800bc0e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bc12:	e015      	b.n	800bc40 <HAL_DMA_IRQHandler+0x22c4>
 800bc14:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bc18:	e012      	b.n	800bc40 <HAL_DMA_IRQHandler+0x22c4>
 800bc1a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bc1e:	e00f      	b.n	800bc40 <HAL_DMA_IRQHandler+0x22c4>
 800bc20:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bc24:	e00c      	b.n	800bc40 <HAL_DMA_IRQHandler+0x22c4>
 800bc26:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bc2a:	e009      	b.n	800bc40 <HAL_DMA_IRQHandler+0x22c4>
 800bc2c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bc30:	e006      	b.n	800bc40 <HAL_DMA_IRQHandler+0x22c4>
 800bc32:	2310      	movs	r3, #16
 800bc34:	e004      	b.n	800bc40 <HAL_DMA_IRQHandler+0x22c4>
 800bc36:	2310      	movs	r3, #16
 800bc38:	e002      	b.n	800bc40 <HAL_DMA_IRQHandler+0x22c4>
 800bc3a:	2310      	movs	r3, #16
 800bc3c:	e000      	b.n	800bc40 <HAL_DMA_IRQHandler+0x22c4>
 800bc3e:	2310      	movs	r3, #16
 800bc40:	60d3      	str	r3, [r2, #12]
 800bc42:	e190      	b.n	800bf66 <HAL_DMA_IRQHandler+0x25ea>
 800bc44:	40026000 	.word	0x40026000
 800bc48:	40026010 	.word	0x40026010
 800bc4c:	40026410 	.word	0x40026410
 800bc50:	40026070 	.word	0x40026070
 800bc54:	40026470 	.word	0x40026470
 800bc58:	40026028 	.word	0x40026028
 800bc5c:	40026428 	.word	0x40026428
 800bc60:	40026088 	.word	0x40026088
 800bc64:	40026488 	.word	0x40026488
 800bc68:	40026040 	.word	0x40026040
 800bc6c:	40026440 	.word	0x40026440
 800bc70:	400260a0 	.word	0x400260a0
 800bc74:	400264a0 	.word	0x400264a0
 800bc78:	40026458 	.word	0x40026458
 800bc7c:	40026400 	.word	0x40026400
 800bc80:	687b      	ldr	r3, [r7, #4]
 800bc82:	681b      	ldr	r3, [r3, #0]
 800bc84:	461a      	mov	r2, r3
 800bc86:	4b9f      	ldr	r3, [pc, #636]	; (800bf04 <HAL_DMA_IRQHandler+0x2588>)
 800bc88:	429a      	cmp	r2, r3
 800bc8a:	d96c      	bls.n	800bd66 <HAL_DMA_IRQHandler+0x23ea>
 800bc8c:	4a9e      	ldr	r2, [pc, #632]	; (800bf08 <HAL_DMA_IRQHandler+0x258c>)
 800bc8e:	687b      	ldr	r3, [r7, #4]
 800bc90:	681b      	ldr	r3, [r3, #0]
 800bc92:	4619      	mov	r1, r3
 800bc94:	4b9d      	ldr	r3, [pc, #628]	; (800bf0c <HAL_DMA_IRQHandler+0x2590>)
 800bc96:	4299      	cmp	r1, r3
 800bc98:	d062      	beq.n	800bd60 <HAL_DMA_IRQHandler+0x23e4>
 800bc9a:	687b      	ldr	r3, [r7, #4]
 800bc9c:	681b      	ldr	r3, [r3, #0]
 800bc9e:	4619      	mov	r1, r3
 800bca0:	4b9b      	ldr	r3, [pc, #620]	; (800bf10 <HAL_DMA_IRQHandler+0x2594>)
 800bca2:	4299      	cmp	r1, r3
 800bca4:	d05a      	beq.n	800bd5c <HAL_DMA_IRQHandler+0x23e0>
 800bca6:	687b      	ldr	r3, [r7, #4]
 800bca8:	681b      	ldr	r3, [r3, #0]
 800bcaa:	4619      	mov	r1, r3
 800bcac:	4b99      	ldr	r3, [pc, #612]	; (800bf14 <HAL_DMA_IRQHandler+0x2598>)
 800bcae:	4299      	cmp	r1, r3
 800bcb0:	d052      	beq.n	800bd58 <HAL_DMA_IRQHandler+0x23dc>
 800bcb2:	687b      	ldr	r3, [r7, #4]
 800bcb4:	681b      	ldr	r3, [r3, #0]
 800bcb6:	4619      	mov	r1, r3
 800bcb8:	4b97      	ldr	r3, [pc, #604]	; (800bf18 <HAL_DMA_IRQHandler+0x259c>)
 800bcba:	4299      	cmp	r1, r3
 800bcbc:	d04a      	beq.n	800bd54 <HAL_DMA_IRQHandler+0x23d8>
 800bcbe:	687b      	ldr	r3, [r7, #4]
 800bcc0:	681b      	ldr	r3, [r3, #0]
 800bcc2:	4619      	mov	r1, r3
 800bcc4:	4b95      	ldr	r3, [pc, #596]	; (800bf1c <HAL_DMA_IRQHandler+0x25a0>)
 800bcc6:	4299      	cmp	r1, r3
 800bcc8:	d041      	beq.n	800bd4e <HAL_DMA_IRQHandler+0x23d2>
 800bcca:	687b      	ldr	r3, [r7, #4]
 800bccc:	681b      	ldr	r3, [r3, #0]
 800bcce:	4619      	mov	r1, r3
 800bcd0:	4b93      	ldr	r3, [pc, #588]	; (800bf20 <HAL_DMA_IRQHandler+0x25a4>)
 800bcd2:	4299      	cmp	r1, r3
 800bcd4:	d038      	beq.n	800bd48 <HAL_DMA_IRQHandler+0x23cc>
 800bcd6:	687b      	ldr	r3, [r7, #4]
 800bcd8:	681b      	ldr	r3, [r3, #0]
 800bcda:	4619      	mov	r1, r3
 800bcdc:	4b91      	ldr	r3, [pc, #580]	; (800bf24 <HAL_DMA_IRQHandler+0x25a8>)
 800bcde:	4299      	cmp	r1, r3
 800bce0:	d02f      	beq.n	800bd42 <HAL_DMA_IRQHandler+0x23c6>
 800bce2:	687b      	ldr	r3, [r7, #4]
 800bce4:	681b      	ldr	r3, [r3, #0]
 800bce6:	4619      	mov	r1, r3
 800bce8:	4b8f      	ldr	r3, [pc, #572]	; (800bf28 <HAL_DMA_IRQHandler+0x25ac>)
 800bcea:	4299      	cmp	r1, r3
 800bcec:	d026      	beq.n	800bd3c <HAL_DMA_IRQHandler+0x23c0>
 800bcee:	687b      	ldr	r3, [r7, #4]
 800bcf0:	681b      	ldr	r3, [r3, #0]
 800bcf2:	4619      	mov	r1, r3
 800bcf4:	4b8d      	ldr	r3, [pc, #564]	; (800bf2c <HAL_DMA_IRQHandler+0x25b0>)
 800bcf6:	4299      	cmp	r1, r3
 800bcf8:	d01d      	beq.n	800bd36 <HAL_DMA_IRQHandler+0x23ba>
 800bcfa:	687b      	ldr	r3, [r7, #4]
 800bcfc:	681b      	ldr	r3, [r3, #0]
 800bcfe:	4619      	mov	r1, r3
 800bd00:	4b8b      	ldr	r3, [pc, #556]	; (800bf30 <HAL_DMA_IRQHandler+0x25b4>)
 800bd02:	4299      	cmp	r1, r3
 800bd04:	d014      	beq.n	800bd30 <HAL_DMA_IRQHandler+0x23b4>
 800bd06:	687b      	ldr	r3, [r7, #4]
 800bd08:	681b      	ldr	r3, [r3, #0]
 800bd0a:	4619      	mov	r1, r3
 800bd0c:	4b89      	ldr	r3, [pc, #548]	; (800bf34 <HAL_DMA_IRQHandler+0x25b8>)
 800bd0e:	4299      	cmp	r1, r3
 800bd10:	d00b      	beq.n	800bd2a <HAL_DMA_IRQHandler+0x23ae>
 800bd12:	687b      	ldr	r3, [r7, #4]
 800bd14:	681b      	ldr	r3, [r3, #0]
 800bd16:	4619      	mov	r1, r3
 800bd18:	4b87      	ldr	r3, [pc, #540]	; (800bf38 <HAL_DMA_IRQHandler+0x25bc>)
 800bd1a:	4299      	cmp	r1, r3
 800bd1c:	d102      	bne.n	800bd24 <HAL_DMA_IRQHandler+0x23a8>
 800bd1e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bd22:	e01e      	b.n	800bd62 <HAL_DMA_IRQHandler+0x23e6>
 800bd24:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800bd28:	e01b      	b.n	800bd62 <HAL_DMA_IRQHandler+0x23e6>
 800bd2a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bd2e:	e018      	b.n	800bd62 <HAL_DMA_IRQHandler+0x23e6>
 800bd30:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bd34:	e015      	b.n	800bd62 <HAL_DMA_IRQHandler+0x23e6>
 800bd36:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bd3a:	e012      	b.n	800bd62 <HAL_DMA_IRQHandler+0x23e6>
 800bd3c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bd40:	e00f      	b.n	800bd62 <HAL_DMA_IRQHandler+0x23e6>
 800bd42:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bd46:	e00c      	b.n	800bd62 <HAL_DMA_IRQHandler+0x23e6>
 800bd48:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bd4c:	e009      	b.n	800bd62 <HAL_DMA_IRQHandler+0x23e6>
 800bd4e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bd52:	e006      	b.n	800bd62 <HAL_DMA_IRQHandler+0x23e6>
 800bd54:	2310      	movs	r3, #16
 800bd56:	e004      	b.n	800bd62 <HAL_DMA_IRQHandler+0x23e6>
 800bd58:	2310      	movs	r3, #16
 800bd5a:	e002      	b.n	800bd62 <HAL_DMA_IRQHandler+0x23e6>
 800bd5c:	2310      	movs	r3, #16
 800bd5e:	e000      	b.n	800bd62 <HAL_DMA_IRQHandler+0x23e6>
 800bd60:	2310      	movs	r3, #16
 800bd62:	6093      	str	r3, [r2, #8]
 800bd64:	e0ff      	b.n	800bf66 <HAL_DMA_IRQHandler+0x25ea>
 800bd66:	687b      	ldr	r3, [r7, #4]
 800bd68:	681b      	ldr	r3, [r3, #0]
 800bd6a:	461a      	mov	r2, r3
 800bd6c:	4b73      	ldr	r3, [pc, #460]	; (800bf3c <HAL_DMA_IRQHandler+0x25c0>)
 800bd6e:	429a      	cmp	r2, r3
 800bd70:	d96c      	bls.n	800be4c <HAL_DMA_IRQHandler+0x24d0>
 800bd72:	4a73      	ldr	r2, [pc, #460]	; (800bf40 <HAL_DMA_IRQHandler+0x25c4>)
 800bd74:	687b      	ldr	r3, [r7, #4]
 800bd76:	681b      	ldr	r3, [r3, #0]
 800bd78:	4619      	mov	r1, r3
 800bd7a:	4b64      	ldr	r3, [pc, #400]	; (800bf0c <HAL_DMA_IRQHandler+0x2590>)
 800bd7c:	4299      	cmp	r1, r3
 800bd7e:	d062      	beq.n	800be46 <HAL_DMA_IRQHandler+0x24ca>
 800bd80:	687b      	ldr	r3, [r7, #4]
 800bd82:	681b      	ldr	r3, [r3, #0]
 800bd84:	4619      	mov	r1, r3
 800bd86:	4b62      	ldr	r3, [pc, #392]	; (800bf10 <HAL_DMA_IRQHandler+0x2594>)
 800bd88:	4299      	cmp	r1, r3
 800bd8a:	d05a      	beq.n	800be42 <HAL_DMA_IRQHandler+0x24c6>
 800bd8c:	687b      	ldr	r3, [r7, #4]
 800bd8e:	681b      	ldr	r3, [r3, #0]
 800bd90:	4619      	mov	r1, r3
 800bd92:	4b60      	ldr	r3, [pc, #384]	; (800bf14 <HAL_DMA_IRQHandler+0x2598>)
 800bd94:	4299      	cmp	r1, r3
 800bd96:	d052      	beq.n	800be3e <HAL_DMA_IRQHandler+0x24c2>
 800bd98:	687b      	ldr	r3, [r7, #4]
 800bd9a:	681b      	ldr	r3, [r3, #0]
 800bd9c:	4619      	mov	r1, r3
 800bd9e:	4b5e      	ldr	r3, [pc, #376]	; (800bf18 <HAL_DMA_IRQHandler+0x259c>)
 800bda0:	4299      	cmp	r1, r3
 800bda2:	d04a      	beq.n	800be3a <HAL_DMA_IRQHandler+0x24be>
 800bda4:	687b      	ldr	r3, [r7, #4]
 800bda6:	681b      	ldr	r3, [r3, #0]
 800bda8:	4619      	mov	r1, r3
 800bdaa:	4b5c      	ldr	r3, [pc, #368]	; (800bf1c <HAL_DMA_IRQHandler+0x25a0>)
 800bdac:	4299      	cmp	r1, r3
 800bdae:	d041      	beq.n	800be34 <HAL_DMA_IRQHandler+0x24b8>
 800bdb0:	687b      	ldr	r3, [r7, #4]
 800bdb2:	681b      	ldr	r3, [r3, #0]
 800bdb4:	4619      	mov	r1, r3
 800bdb6:	4b5a      	ldr	r3, [pc, #360]	; (800bf20 <HAL_DMA_IRQHandler+0x25a4>)
 800bdb8:	4299      	cmp	r1, r3
 800bdba:	d038      	beq.n	800be2e <HAL_DMA_IRQHandler+0x24b2>
 800bdbc:	687b      	ldr	r3, [r7, #4]
 800bdbe:	681b      	ldr	r3, [r3, #0]
 800bdc0:	4619      	mov	r1, r3
 800bdc2:	4b58      	ldr	r3, [pc, #352]	; (800bf24 <HAL_DMA_IRQHandler+0x25a8>)
 800bdc4:	4299      	cmp	r1, r3
 800bdc6:	d02f      	beq.n	800be28 <HAL_DMA_IRQHandler+0x24ac>
 800bdc8:	687b      	ldr	r3, [r7, #4]
 800bdca:	681b      	ldr	r3, [r3, #0]
 800bdcc:	4619      	mov	r1, r3
 800bdce:	4b56      	ldr	r3, [pc, #344]	; (800bf28 <HAL_DMA_IRQHandler+0x25ac>)
 800bdd0:	4299      	cmp	r1, r3
 800bdd2:	d026      	beq.n	800be22 <HAL_DMA_IRQHandler+0x24a6>
 800bdd4:	687b      	ldr	r3, [r7, #4]
 800bdd6:	681b      	ldr	r3, [r3, #0]
 800bdd8:	4619      	mov	r1, r3
 800bdda:	4b54      	ldr	r3, [pc, #336]	; (800bf2c <HAL_DMA_IRQHandler+0x25b0>)
 800bddc:	4299      	cmp	r1, r3
 800bdde:	d01d      	beq.n	800be1c <HAL_DMA_IRQHandler+0x24a0>
 800bde0:	687b      	ldr	r3, [r7, #4]
 800bde2:	681b      	ldr	r3, [r3, #0]
 800bde4:	4619      	mov	r1, r3
 800bde6:	4b52      	ldr	r3, [pc, #328]	; (800bf30 <HAL_DMA_IRQHandler+0x25b4>)
 800bde8:	4299      	cmp	r1, r3
 800bdea:	d014      	beq.n	800be16 <HAL_DMA_IRQHandler+0x249a>
 800bdec:	687b      	ldr	r3, [r7, #4]
 800bdee:	681b      	ldr	r3, [r3, #0]
 800bdf0:	4619      	mov	r1, r3
 800bdf2:	4b50      	ldr	r3, [pc, #320]	; (800bf34 <HAL_DMA_IRQHandler+0x25b8>)
 800bdf4:	4299      	cmp	r1, r3
 800bdf6:	d00b      	beq.n	800be10 <HAL_DMA_IRQHandler+0x2494>
 800bdf8:	687b      	ldr	r3, [r7, #4]
 800bdfa:	681b      	ldr	r3, [r3, #0]
 800bdfc:	4619      	mov	r1, r3
 800bdfe:	4b4e      	ldr	r3, [pc, #312]	; (800bf38 <HAL_DMA_IRQHandler+0x25bc>)
 800be00:	4299      	cmp	r1, r3
 800be02:	d102      	bne.n	800be0a <HAL_DMA_IRQHandler+0x248e>
 800be04:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800be08:	e01e      	b.n	800be48 <HAL_DMA_IRQHandler+0x24cc>
 800be0a:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800be0e:	e01b      	b.n	800be48 <HAL_DMA_IRQHandler+0x24cc>
 800be10:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800be14:	e018      	b.n	800be48 <HAL_DMA_IRQHandler+0x24cc>
 800be16:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800be1a:	e015      	b.n	800be48 <HAL_DMA_IRQHandler+0x24cc>
 800be1c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800be20:	e012      	b.n	800be48 <HAL_DMA_IRQHandler+0x24cc>
 800be22:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800be26:	e00f      	b.n	800be48 <HAL_DMA_IRQHandler+0x24cc>
 800be28:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800be2c:	e00c      	b.n	800be48 <HAL_DMA_IRQHandler+0x24cc>
 800be2e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800be32:	e009      	b.n	800be48 <HAL_DMA_IRQHandler+0x24cc>
 800be34:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800be38:	e006      	b.n	800be48 <HAL_DMA_IRQHandler+0x24cc>
 800be3a:	2310      	movs	r3, #16
 800be3c:	e004      	b.n	800be48 <HAL_DMA_IRQHandler+0x24cc>
 800be3e:	2310      	movs	r3, #16
 800be40:	e002      	b.n	800be48 <HAL_DMA_IRQHandler+0x24cc>
 800be42:	2310      	movs	r3, #16
 800be44:	e000      	b.n	800be48 <HAL_DMA_IRQHandler+0x24cc>
 800be46:	2310      	movs	r3, #16
 800be48:	60d3      	str	r3, [r2, #12]
 800be4a:	e08c      	b.n	800bf66 <HAL_DMA_IRQHandler+0x25ea>
 800be4c:	4a3c      	ldr	r2, [pc, #240]	; (800bf40 <HAL_DMA_IRQHandler+0x25c4>)
 800be4e:	687b      	ldr	r3, [r7, #4]
 800be50:	681b      	ldr	r3, [r3, #0]
 800be52:	4619      	mov	r1, r3
 800be54:	4b2d      	ldr	r3, [pc, #180]	; (800bf0c <HAL_DMA_IRQHandler+0x2590>)
 800be56:	4299      	cmp	r1, r3
 800be58:	f000 8083 	beq.w	800bf62 <HAL_DMA_IRQHandler+0x25e6>
 800be5c:	687b      	ldr	r3, [r7, #4]
 800be5e:	681b      	ldr	r3, [r3, #0]
 800be60:	4619      	mov	r1, r3
 800be62:	4b2b      	ldr	r3, [pc, #172]	; (800bf10 <HAL_DMA_IRQHandler+0x2594>)
 800be64:	4299      	cmp	r1, r3
 800be66:	d07a      	beq.n	800bf5e <HAL_DMA_IRQHandler+0x25e2>
 800be68:	687b      	ldr	r3, [r7, #4]
 800be6a:	681b      	ldr	r3, [r3, #0]
 800be6c:	4619      	mov	r1, r3
 800be6e:	4b29      	ldr	r3, [pc, #164]	; (800bf14 <HAL_DMA_IRQHandler+0x2598>)
 800be70:	4299      	cmp	r1, r3
 800be72:	d072      	beq.n	800bf5a <HAL_DMA_IRQHandler+0x25de>
 800be74:	687b      	ldr	r3, [r7, #4]
 800be76:	681b      	ldr	r3, [r3, #0]
 800be78:	4619      	mov	r1, r3
 800be7a:	4b27      	ldr	r3, [pc, #156]	; (800bf18 <HAL_DMA_IRQHandler+0x259c>)
 800be7c:	4299      	cmp	r1, r3
 800be7e:	d06a      	beq.n	800bf56 <HAL_DMA_IRQHandler+0x25da>
 800be80:	687b      	ldr	r3, [r7, #4]
 800be82:	681b      	ldr	r3, [r3, #0]
 800be84:	4619      	mov	r1, r3
 800be86:	4b25      	ldr	r3, [pc, #148]	; (800bf1c <HAL_DMA_IRQHandler+0x25a0>)
 800be88:	4299      	cmp	r1, r3
 800be8a:	d061      	beq.n	800bf50 <HAL_DMA_IRQHandler+0x25d4>
 800be8c:	687b      	ldr	r3, [r7, #4]
 800be8e:	681b      	ldr	r3, [r3, #0]
 800be90:	4619      	mov	r1, r3
 800be92:	4b23      	ldr	r3, [pc, #140]	; (800bf20 <HAL_DMA_IRQHandler+0x25a4>)
 800be94:	4299      	cmp	r1, r3
 800be96:	d058      	beq.n	800bf4a <HAL_DMA_IRQHandler+0x25ce>
 800be98:	687b      	ldr	r3, [r7, #4]
 800be9a:	681b      	ldr	r3, [r3, #0]
 800be9c:	4619      	mov	r1, r3
 800be9e:	4b21      	ldr	r3, [pc, #132]	; (800bf24 <HAL_DMA_IRQHandler+0x25a8>)
 800bea0:	4299      	cmp	r1, r3
 800bea2:	d04f      	beq.n	800bf44 <HAL_DMA_IRQHandler+0x25c8>
 800bea4:	687b      	ldr	r3, [r7, #4]
 800bea6:	681b      	ldr	r3, [r3, #0]
 800bea8:	4619      	mov	r1, r3
 800beaa:	4b1f      	ldr	r3, [pc, #124]	; (800bf28 <HAL_DMA_IRQHandler+0x25ac>)
 800beac:	4299      	cmp	r1, r3
 800beae:	d026      	beq.n	800befe <HAL_DMA_IRQHandler+0x2582>
 800beb0:	687b      	ldr	r3, [r7, #4]
 800beb2:	681b      	ldr	r3, [r3, #0]
 800beb4:	4619      	mov	r1, r3
 800beb6:	4b1d      	ldr	r3, [pc, #116]	; (800bf2c <HAL_DMA_IRQHandler+0x25b0>)
 800beb8:	4299      	cmp	r1, r3
 800beba:	d01d      	beq.n	800bef8 <HAL_DMA_IRQHandler+0x257c>
 800bebc:	687b      	ldr	r3, [r7, #4]
 800bebe:	681b      	ldr	r3, [r3, #0]
 800bec0:	4619      	mov	r1, r3
 800bec2:	4b1b      	ldr	r3, [pc, #108]	; (800bf30 <HAL_DMA_IRQHandler+0x25b4>)
 800bec4:	4299      	cmp	r1, r3
 800bec6:	d014      	beq.n	800bef2 <HAL_DMA_IRQHandler+0x2576>
 800bec8:	687b      	ldr	r3, [r7, #4]
 800beca:	681b      	ldr	r3, [r3, #0]
 800becc:	4619      	mov	r1, r3
 800bece:	4b19      	ldr	r3, [pc, #100]	; (800bf34 <HAL_DMA_IRQHandler+0x25b8>)
 800bed0:	4299      	cmp	r1, r3
 800bed2:	d00b      	beq.n	800beec <HAL_DMA_IRQHandler+0x2570>
 800bed4:	687b      	ldr	r3, [r7, #4]
 800bed6:	681b      	ldr	r3, [r3, #0]
 800bed8:	4619      	mov	r1, r3
 800beda:	4b17      	ldr	r3, [pc, #92]	; (800bf38 <HAL_DMA_IRQHandler+0x25bc>)
 800bedc:	4299      	cmp	r1, r3
 800bede:	d102      	bne.n	800bee6 <HAL_DMA_IRQHandler+0x256a>
 800bee0:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bee4:	e03e      	b.n	800bf64 <HAL_DMA_IRQHandler+0x25e8>
 800bee6:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800beea:	e03b      	b.n	800bf64 <HAL_DMA_IRQHandler+0x25e8>
 800beec:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bef0:	e038      	b.n	800bf64 <HAL_DMA_IRQHandler+0x25e8>
 800bef2:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bef6:	e035      	b.n	800bf64 <HAL_DMA_IRQHandler+0x25e8>
 800bef8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800befc:	e032      	b.n	800bf64 <HAL_DMA_IRQHandler+0x25e8>
 800befe:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bf02:	e02f      	b.n	800bf64 <HAL_DMA_IRQHandler+0x25e8>
 800bf04:	400260b8 	.word	0x400260b8
 800bf08:	40026400 	.word	0x40026400
 800bf0c:	40026010 	.word	0x40026010
 800bf10:	40026410 	.word	0x40026410
 800bf14:	40026070 	.word	0x40026070
 800bf18:	40026470 	.word	0x40026470
 800bf1c:	40026028 	.word	0x40026028
 800bf20:	40026428 	.word	0x40026428
 800bf24:	40026088 	.word	0x40026088
 800bf28:	40026488 	.word	0x40026488
 800bf2c:	40026040 	.word	0x40026040
 800bf30:	40026440 	.word	0x40026440
 800bf34:	400260a0 	.word	0x400260a0
 800bf38:	400264a0 	.word	0x400264a0
 800bf3c:	40026058 	.word	0x40026058
 800bf40:	40026000 	.word	0x40026000
 800bf44:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bf48:	e00c      	b.n	800bf64 <HAL_DMA_IRQHandler+0x25e8>
 800bf4a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bf4e:	e009      	b.n	800bf64 <HAL_DMA_IRQHandler+0x25e8>
 800bf50:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bf54:	e006      	b.n	800bf64 <HAL_DMA_IRQHandler+0x25e8>
 800bf56:	2310      	movs	r3, #16
 800bf58:	e004      	b.n	800bf64 <HAL_DMA_IRQHandler+0x25e8>
 800bf5a:	2310      	movs	r3, #16
 800bf5c:	e002      	b.n	800bf64 <HAL_DMA_IRQHandler+0x25e8>
 800bf5e:	2310      	movs	r3, #16
 800bf60:	e000      	b.n	800bf64 <HAL_DMA_IRQHandler+0x25e8>
 800bf62:	2310      	movs	r3, #16
 800bf64:	6093      	str	r3, [r2, #8]

        /* Change DMA peripheral state */
        hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
 800bf66:	687b      	ldr	r3, [r7, #4]
 800bf68:	2231      	movs	r2, #49	; 0x31
 800bf6a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
      }

      if(hdma->XferHalfCpltCallback != NULL)
 800bf6e:	687b      	ldr	r3, [r7, #4]
 800bf70:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800bf72:	2b00      	cmp	r3, #0
 800bf74:	d003      	beq.n	800bf7e <HAL_DMA_IRQHandler+0x2602>
      {
        /* Half transfer callback */
        hdma->XferHalfCpltCallback(hdma);
 800bf76:	687b      	ldr	r3, [r7, #4]
 800bf78:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800bf7a:	6878      	ldr	r0, [r7, #4]
 800bf7c:	4798      	blx	r3
      }
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 800bf7e:	687b      	ldr	r3, [r7, #4]
 800bf80:	681b      	ldr	r3, [r3, #0]
 800bf82:	461a      	mov	r2, r3
 800bf84:	4b77      	ldr	r3, [pc, #476]	; (800c164 <HAL_DMA_IRQHandler+0x27e8>)
 800bf86:	429a      	cmp	r2, r3
 800bf88:	d972      	bls.n	800c070 <HAL_DMA_IRQHandler+0x26f4>
 800bf8a:	4b77      	ldr	r3, [pc, #476]	; (800c168 <HAL_DMA_IRQHandler+0x27ec>)
 800bf8c:	685a      	ldr	r2, [r3, #4]
 800bf8e:	687b      	ldr	r3, [r7, #4]
 800bf90:	681b      	ldr	r3, [r3, #0]
 800bf92:	4619      	mov	r1, r3
 800bf94:	4b75      	ldr	r3, [pc, #468]	; (800c16c <HAL_DMA_IRQHandler+0x27f0>)
 800bf96:	4299      	cmp	r1, r3
 800bf98:	d062      	beq.n	800c060 <HAL_DMA_IRQHandler+0x26e4>
 800bf9a:	687b      	ldr	r3, [r7, #4]
 800bf9c:	681b      	ldr	r3, [r3, #0]
 800bf9e:	4619      	mov	r1, r3
 800bfa0:	4b73      	ldr	r3, [pc, #460]	; (800c170 <HAL_DMA_IRQHandler+0x27f4>)
 800bfa2:	4299      	cmp	r1, r3
 800bfa4:	d05a      	beq.n	800c05c <HAL_DMA_IRQHandler+0x26e0>
 800bfa6:	687b      	ldr	r3, [r7, #4]
 800bfa8:	681b      	ldr	r3, [r3, #0]
 800bfaa:	4619      	mov	r1, r3
 800bfac:	4b71      	ldr	r3, [pc, #452]	; (800c174 <HAL_DMA_IRQHandler+0x27f8>)
 800bfae:	4299      	cmp	r1, r3
 800bfb0:	d052      	beq.n	800c058 <HAL_DMA_IRQHandler+0x26dc>
 800bfb2:	687b      	ldr	r3, [r7, #4]
 800bfb4:	681b      	ldr	r3, [r3, #0]
 800bfb6:	4619      	mov	r1, r3
 800bfb8:	4b6f      	ldr	r3, [pc, #444]	; (800c178 <HAL_DMA_IRQHandler+0x27fc>)
 800bfba:	4299      	cmp	r1, r3
 800bfbc:	d04a      	beq.n	800c054 <HAL_DMA_IRQHandler+0x26d8>
 800bfbe:	687b      	ldr	r3, [r7, #4]
 800bfc0:	681b      	ldr	r3, [r3, #0]
 800bfc2:	4619      	mov	r1, r3
 800bfc4:	4b6d      	ldr	r3, [pc, #436]	; (800c17c <HAL_DMA_IRQHandler+0x2800>)
 800bfc6:	4299      	cmp	r1, r3
 800bfc8:	d041      	beq.n	800c04e <HAL_DMA_IRQHandler+0x26d2>
 800bfca:	687b      	ldr	r3, [r7, #4]
 800bfcc:	681b      	ldr	r3, [r3, #0]
 800bfce:	4619      	mov	r1, r3
 800bfd0:	4b6b      	ldr	r3, [pc, #428]	; (800c180 <HAL_DMA_IRQHandler+0x2804>)
 800bfd2:	4299      	cmp	r1, r3
 800bfd4:	d038      	beq.n	800c048 <HAL_DMA_IRQHandler+0x26cc>
 800bfd6:	687b      	ldr	r3, [r7, #4]
 800bfd8:	681b      	ldr	r3, [r3, #0]
 800bfda:	4619      	mov	r1, r3
 800bfdc:	4b69      	ldr	r3, [pc, #420]	; (800c184 <HAL_DMA_IRQHandler+0x2808>)
 800bfde:	4299      	cmp	r1, r3
 800bfe0:	d02f      	beq.n	800c042 <HAL_DMA_IRQHandler+0x26c6>
 800bfe2:	687b      	ldr	r3, [r7, #4]
 800bfe4:	681b      	ldr	r3, [r3, #0]
 800bfe6:	4619      	mov	r1, r3
 800bfe8:	4b67      	ldr	r3, [pc, #412]	; (800c188 <HAL_DMA_IRQHandler+0x280c>)
 800bfea:	4299      	cmp	r1, r3
 800bfec:	d026      	beq.n	800c03c <HAL_DMA_IRQHandler+0x26c0>
 800bfee:	687b      	ldr	r3, [r7, #4]
 800bff0:	681b      	ldr	r3, [r3, #0]
 800bff2:	4619      	mov	r1, r3
 800bff4:	4b65      	ldr	r3, [pc, #404]	; (800c18c <HAL_DMA_IRQHandler+0x2810>)
 800bff6:	4299      	cmp	r1, r3
 800bff8:	d01d      	beq.n	800c036 <HAL_DMA_IRQHandler+0x26ba>
 800bffa:	687b      	ldr	r3, [r7, #4]
 800bffc:	681b      	ldr	r3, [r3, #0]
 800bffe:	4619      	mov	r1, r3
 800c000:	4b63      	ldr	r3, [pc, #396]	; (800c190 <HAL_DMA_IRQHandler+0x2814>)
 800c002:	4299      	cmp	r1, r3
 800c004:	d014      	beq.n	800c030 <HAL_DMA_IRQHandler+0x26b4>
 800c006:	687b      	ldr	r3, [r7, #4]
 800c008:	681b      	ldr	r3, [r3, #0]
 800c00a:	4619      	mov	r1, r3
 800c00c:	4b61      	ldr	r3, [pc, #388]	; (800c194 <HAL_DMA_IRQHandler+0x2818>)
 800c00e:	4299      	cmp	r1, r3
 800c010:	d00b      	beq.n	800c02a <HAL_DMA_IRQHandler+0x26ae>
 800c012:	687b      	ldr	r3, [r7, #4]
 800c014:	681b      	ldr	r3, [r3, #0]
 800c016:	4619      	mov	r1, r3
 800c018:	4b5f      	ldr	r3, [pc, #380]	; (800c198 <HAL_DMA_IRQHandler+0x281c>)
 800c01a:	4299      	cmp	r1, r3
 800c01c:	d102      	bne.n	800c024 <HAL_DMA_IRQHandler+0x26a8>
 800c01e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c022:	e01e      	b.n	800c062 <HAL_DMA_IRQHandler+0x26e6>
 800c024:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800c028:	e01b      	b.n	800c062 <HAL_DMA_IRQHandler+0x26e6>
 800c02a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c02e:	e018      	b.n	800c062 <HAL_DMA_IRQHandler+0x26e6>
 800c030:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c034:	e015      	b.n	800c062 <HAL_DMA_IRQHandler+0x26e6>
 800c036:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c03a:	e012      	b.n	800c062 <HAL_DMA_IRQHandler+0x26e6>
 800c03c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c040:	e00f      	b.n	800c062 <HAL_DMA_IRQHandler+0x26e6>
 800c042:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c046:	e00c      	b.n	800c062 <HAL_DMA_IRQHandler+0x26e6>
 800c048:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c04c:	e009      	b.n	800c062 <HAL_DMA_IRQHandler+0x26e6>
 800c04e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c052:	e006      	b.n	800c062 <HAL_DMA_IRQHandler+0x26e6>
 800c054:	2320      	movs	r3, #32
 800c056:	e004      	b.n	800c062 <HAL_DMA_IRQHandler+0x26e6>
 800c058:	2320      	movs	r3, #32
 800c05a:	e002      	b.n	800c062 <HAL_DMA_IRQHandler+0x26e6>
 800c05c:	2320      	movs	r3, #32
 800c05e:	e000      	b.n	800c062 <HAL_DMA_IRQHandler+0x26e6>
 800c060:	2320      	movs	r3, #32
 800c062:	4013      	ands	r3, r2
 800c064:	2b00      	cmp	r3, #0
 800c066:	bf14      	ite	ne
 800c068:	2301      	movne	r3, #1
 800c06a:	2300      	moveq	r3, #0
 800c06c:	b2db      	uxtb	r3, r3
 800c06e:	e19e      	b.n	800c3ae <HAL_DMA_IRQHandler+0x2a32>
 800c070:	687b      	ldr	r3, [r7, #4]
 800c072:	681b      	ldr	r3, [r3, #0]
 800c074:	461a      	mov	r2, r3
 800c076:	4b49      	ldr	r3, [pc, #292]	; (800c19c <HAL_DMA_IRQHandler+0x2820>)
 800c078:	429a      	cmp	r2, r3
 800c07a:	f240 8091 	bls.w	800c1a0 <HAL_DMA_IRQHandler+0x2824>
 800c07e:	4b3a      	ldr	r3, [pc, #232]	; (800c168 <HAL_DMA_IRQHandler+0x27ec>)
 800c080:	681a      	ldr	r2, [r3, #0]
 800c082:	687b      	ldr	r3, [r7, #4]
 800c084:	681b      	ldr	r3, [r3, #0]
 800c086:	4619      	mov	r1, r3
 800c088:	4b38      	ldr	r3, [pc, #224]	; (800c16c <HAL_DMA_IRQHandler+0x27f0>)
 800c08a:	4299      	cmp	r1, r3
 800c08c:	d062      	beq.n	800c154 <HAL_DMA_IRQHandler+0x27d8>
 800c08e:	687b      	ldr	r3, [r7, #4]
 800c090:	681b      	ldr	r3, [r3, #0]
 800c092:	4619      	mov	r1, r3
 800c094:	4b36      	ldr	r3, [pc, #216]	; (800c170 <HAL_DMA_IRQHandler+0x27f4>)
 800c096:	4299      	cmp	r1, r3
 800c098:	d05a      	beq.n	800c150 <HAL_DMA_IRQHandler+0x27d4>
 800c09a:	687b      	ldr	r3, [r7, #4]
 800c09c:	681b      	ldr	r3, [r3, #0]
 800c09e:	4619      	mov	r1, r3
 800c0a0:	4b34      	ldr	r3, [pc, #208]	; (800c174 <HAL_DMA_IRQHandler+0x27f8>)
 800c0a2:	4299      	cmp	r1, r3
 800c0a4:	d052      	beq.n	800c14c <HAL_DMA_IRQHandler+0x27d0>
 800c0a6:	687b      	ldr	r3, [r7, #4]
 800c0a8:	681b      	ldr	r3, [r3, #0]
 800c0aa:	4619      	mov	r1, r3
 800c0ac:	4b32      	ldr	r3, [pc, #200]	; (800c178 <HAL_DMA_IRQHandler+0x27fc>)
 800c0ae:	4299      	cmp	r1, r3
 800c0b0:	d04a      	beq.n	800c148 <HAL_DMA_IRQHandler+0x27cc>
 800c0b2:	687b      	ldr	r3, [r7, #4]
 800c0b4:	681b      	ldr	r3, [r3, #0]
 800c0b6:	4619      	mov	r1, r3
 800c0b8:	4b30      	ldr	r3, [pc, #192]	; (800c17c <HAL_DMA_IRQHandler+0x2800>)
 800c0ba:	4299      	cmp	r1, r3
 800c0bc:	d041      	beq.n	800c142 <HAL_DMA_IRQHandler+0x27c6>
 800c0be:	687b      	ldr	r3, [r7, #4]
 800c0c0:	681b      	ldr	r3, [r3, #0]
 800c0c2:	4619      	mov	r1, r3
 800c0c4:	4b2e      	ldr	r3, [pc, #184]	; (800c180 <HAL_DMA_IRQHandler+0x2804>)
 800c0c6:	4299      	cmp	r1, r3
 800c0c8:	d038      	beq.n	800c13c <HAL_DMA_IRQHandler+0x27c0>
 800c0ca:	687b      	ldr	r3, [r7, #4]
 800c0cc:	681b      	ldr	r3, [r3, #0]
 800c0ce:	4619      	mov	r1, r3
 800c0d0:	4b2c      	ldr	r3, [pc, #176]	; (800c184 <HAL_DMA_IRQHandler+0x2808>)
 800c0d2:	4299      	cmp	r1, r3
 800c0d4:	d02f      	beq.n	800c136 <HAL_DMA_IRQHandler+0x27ba>
 800c0d6:	687b      	ldr	r3, [r7, #4]
 800c0d8:	681b      	ldr	r3, [r3, #0]
 800c0da:	4619      	mov	r1, r3
 800c0dc:	4b2a      	ldr	r3, [pc, #168]	; (800c188 <HAL_DMA_IRQHandler+0x280c>)
 800c0de:	4299      	cmp	r1, r3
 800c0e0:	d026      	beq.n	800c130 <HAL_DMA_IRQHandler+0x27b4>
 800c0e2:	687b      	ldr	r3, [r7, #4]
 800c0e4:	681b      	ldr	r3, [r3, #0]
 800c0e6:	4619      	mov	r1, r3
 800c0e8:	4b28      	ldr	r3, [pc, #160]	; (800c18c <HAL_DMA_IRQHandler+0x2810>)
 800c0ea:	4299      	cmp	r1, r3
 800c0ec:	d01d      	beq.n	800c12a <HAL_DMA_IRQHandler+0x27ae>
 800c0ee:	687b      	ldr	r3, [r7, #4]
 800c0f0:	681b      	ldr	r3, [r3, #0]
 800c0f2:	4619      	mov	r1, r3
 800c0f4:	4b26      	ldr	r3, [pc, #152]	; (800c190 <HAL_DMA_IRQHandler+0x2814>)
 800c0f6:	4299      	cmp	r1, r3
 800c0f8:	d014      	beq.n	800c124 <HAL_DMA_IRQHandler+0x27a8>
 800c0fa:	687b      	ldr	r3, [r7, #4]
 800c0fc:	681b      	ldr	r3, [r3, #0]
 800c0fe:	4619      	mov	r1, r3
 800c100:	4b24      	ldr	r3, [pc, #144]	; (800c194 <HAL_DMA_IRQHandler+0x2818>)
 800c102:	4299      	cmp	r1, r3
 800c104:	d00b      	beq.n	800c11e <HAL_DMA_IRQHandler+0x27a2>
 800c106:	687b      	ldr	r3, [r7, #4]
 800c108:	681b      	ldr	r3, [r3, #0]
 800c10a:	4619      	mov	r1, r3
 800c10c:	4b22      	ldr	r3, [pc, #136]	; (800c198 <HAL_DMA_IRQHandler+0x281c>)
 800c10e:	4299      	cmp	r1, r3
 800c110:	d102      	bne.n	800c118 <HAL_DMA_IRQHandler+0x279c>
 800c112:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c116:	e01e      	b.n	800c156 <HAL_DMA_IRQHandler+0x27da>
 800c118:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800c11c:	e01b      	b.n	800c156 <HAL_DMA_IRQHandler+0x27da>
 800c11e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c122:	e018      	b.n	800c156 <HAL_DMA_IRQHandler+0x27da>
 800c124:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c128:	e015      	b.n	800c156 <HAL_DMA_IRQHandler+0x27da>
 800c12a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c12e:	e012      	b.n	800c156 <HAL_DMA_IRQHandler+0x27da>
 800c130:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c134:	e00f      	b.n	800c156 <HAL_DMA_IRQHandler+0x27da>
 800c136:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c13a:	e00c      	b.n	800c156 <HAL_DMA_IRQHandler+0x27da>
 800c13c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c140:	e009      	b.n	800c156 <HAL_DMA_IRQHandler+0x27da>
 800c142:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c146:	e006      	b.n	800c156 <HAL_DMA_IRQHandler+0x27da>
 800c148:	2320      	movs	r3, #32
 800c14a:	e004      	b.n	800c156 <HAL_DMA_IRQHandler+0x27da>
 800c14c:	2320      	movs	r3, #32
 800c14e:	e002      	b.n	800c156 <HAL_DMA_IRQHandler+0x27da>
 800c150:	2320      	movs	r3, #32
 800c152:	e000      	b.n	800c156 <HAL_DMA_IRQHandler+0x27da>
 800c154:	2320      	movs	r3, #32
 800c156:	4013      	ands	r3, r2
 800c158:	2b00      	cmp	r3, #0
 800c15a:	bf14      	ite	ne
 800c15c:	2301      	movne	r3, #1
 800c15e:	2300      	moveq	r3, #0
 800c160:	b2db      	uxtb	r3, r3
 800c162:	e124      	b.n	800c3ae <HAL_DMA_IRQHandler+0x2a32>
 800c164:	40026458 	.word	0x40026458
 800c168:	40026400 	.word	0x40026400
 800c16c:	40026010 	.word	0x40026010
 800c170:	40026410 	.word	0x40026410
 800c174:	40026070 	.word	0x40026070
 800c178:	40026470 	.word	0x40026470
 800c17c:	40026028 	.word	0x40026028
 800c180:	40026428 	.word	0x40026428
 800c184:	40026088 	.word	0x40026088
 800c188:	40026488 	.word	0x40026488
 800c18c:	40026040 	.word	0x40026040
 800c190:	40026440 	.word	0x40026440
 800c194:	400260a0 	.word	0x400260a0
 800c198:	400264a0 	.word	0x400264a0
 800c19c:	400260b8 	.word	0x400260b8
 800c1a0:	687b      	ldr	r3, [r7, #4]
 800c1a2:	681b      	ldr	r3, [r3, #0]
 800c1a4:	461a      	mov	r2, r3
 800c1a6:	4b70      	ldr	r3, [pc, #448]	; (800c368 <HAL_DMA_IRQHandler+0x29ec>)
 800c1a8:	429a      	cmp	r2, r3
 800c1aa:	d972      	bls.n	800c292 <HAL_DMA_IRQHandler+0x2916>
 800c1ac:	4b6f      	ldr	r3, [pc, #444]	; (800c36c <HAL_DMA_IRQHandler+0x29f0>)
 800c1ae:	685a      	ldr	r2, [r3, #4]
 800c1b0:	687b      	ldr	r3, [r7, #4]
 800c1b2:	681b      	ldr	r3, [r3, #0]
 800c1b4:	4619      	mov	r1, r3
 800c1b6:	4b6e      	ldr	r3, [pc, #440]	; (800c370 <HAL_DMA_IRQHandler+0x29f4>)
 800c1b8:	4299      	cmp	r1, r3
 800c1ba:	d062      	beq.n	800c282 <HAL_DMA_IRQHandler+0x2906>
 800c1bc:	687b      	ldr	r3, [r7, #4]
 800c1be:	681b      	ldr	r3, [r3, #0]
 800c1c0:	4619      	mov	r1, r3
 800c1c2:	4b6c      	ldr	r3, [pc, #432]	; (800c374 <HAL_DMA_IRQHandler+0x29f8>)
 800c1c4:	4299      	cmp	r1, r3
 800c1c6:	d05a      	beq.n	800c27e <HAL_DMA_IRQHandler+0x2902>
 800c1c8:	687b      	ldr	r3, [r7, #4]
 800c1ca:	681b      	ldr	r3, [r3, #0]
 800c1cc:	4619      	mov	r1, r3
 800c1ce:	4b6a      	ldr	r3, [pc, #424]	; (800c378 <HAL_DMA_IRQHandler+0x29fc>)
 800c1d0:	4299      	cmp	r1, r3
 800c1d2:	d052      	beq.n	800c27a <HAL_DMA_IRQHandler+0x28fe>
 800c1d4:	687b      	ldr	r3, [r7, #4]
 800c1d6:	681b      	ldr	r3, [r3, #0]
 800c1d8:	4619      	mov	r1, r3
 800c1da:	4b68      	ldr	r3, [pc, #416]	; (800c37c <HAL_DMA_IRQHandler+0x2a00>)
 800c1dc:	4299      	cmp	r1, r3
 800c1de:	d04a      	beq.n	800c276 <HAL_DMA_IRQHandler+0x28fa>
 800c1e0:	687b      	ldr	r3, [r7, #4]
 800c1e2:	681b      	ldr	r3, [r3, #0]
 800c1e4:	4619      	mov	r1, r3
 800c1e6:	4b66      	ldr	r3, [pc, #408]	; (800c380 <HAL_DMA_IRQHandler+0x2a04>)
 800c1e8:	4299      	cmp	r1, r3
 800c1ea:	d041      	beq.n	800c270 <HAL_DMA_IRQHandler+0x28f4>
 800c1ec:	687b      	ldr	r3, [r7, #4]
 800c1ee:	681b      	ldr	r3, [r3, #0]
 800c1f0:	4619      	mov	r1, r3
 800c1f2:	4b64      	ldr	r3, [pc, #400]	; (800c384 <HAL_DMA_IRQHandler+0x2a08>)
 800c1f4:	4299      	cmp	r1, r3
 800c1f6:	d038      	beq.n	800c26a <HAL_DMA_IRQHandler+0x28ee>
 800c1f8:	687b      	ldr	r3, [r7, #4]
 800c1fa:	681b      	ldr	r3, [r3, #0]
 800c1fc:	4619      	mov	r1, r3
 800c1fe:	4b62      	ldr	r3, [pc, #392]	; (800c388 <HAL_DMA_IRQHandler+0x2a0c>)
 800c200:	4299      	cmp	r1, r3
 800c202:	d02f      	beq.n	800c264 <HAL_DMA_IRQHandler+0x28e8>
 800c204:	687b      	ldr	r3, [r7, #4]
 800c206:	681b      	ldr	r3, [r3, #0]
 800c208:	4619      	mov	r1, r3
 800c20a:	4b60      	ldr	r3, [pc, #384]	; (800c38c <HAL_DMA_IRQHandler+0x2a10>)
 800c20c:	4299      	cmp	r1, r3
 800c20e:	d026      	beq.n	800c25e <HAL_DMA_IRQHandler+0x28e2>
 800c210:	687b      	ldr	r3, [r7, #4]
 800c212:	681b      	ldr	r3, [r3, #0]
 800c214:	4619      	mov	r1, r3
 800c216:	4b5e      	ldr	r3, [pc, #376]	; (800c390 <HAL_DMA_IRQHandler+0x2a14>)
 800c218:	4299      	cmp	r1, r3
 800c21a:	d01d      	beq.n	800c258 <HAL_DMA_IRQHandler+0x28dc>
 800c21c:	687b      	ldr	r3, [r7, #4]
 800c21e:	681b      	ldr	r3, [r3, #0]
 800c220:	4619      	mov	r1, r3
 800c222:	4b5c      	ldr	r3, [pc, #368]	; (800c394 <HAL_DMA_IRQHandler+0x2a18>)
 800c224:	4299      	cmp	r1, r3
 800c226:	d014      	beq.n	800c252 <HAL_DMA_IRQHandler+0x28d6>
 800c228:	687b      	ldr	r3, [r7, #4]
 800c22a:	681b      	ldr	r3, [r3, #0]
 800c22c:	4619      	mov	r1, r3
 800c22e:	4b5a      	ldr	r3, [pc, #360]	; (800c398 <HAL_DMA_IRQHandler+0x2a1c>)
 800c230:	4299      	cmp	r1, r3
 800c232:	d00b      	beq.n	800c24c <HAL_DMA_IRQHandler+0x28d0>
 800c234:	687b      	ldr	r3, [r7, #4]
 800c236:	681b      	ldr	r3, [r3, #0]
 800c238:	4619      	mov	r1, r3
 800c23a:	4b58      	ldr	r3, [pc, #352]	; (800c39c <HAL_DMA_IRQHandler+0x2a20>)
 800c23c:	4299      	cmp	r1, r3
 800c23e:	d102      	bne.n	800c246 <HAL_DMA_IRQHandler+0x28ca>
 800c240:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c244:	e01e      	b.n	800c284 <HAL_DMA_IRQHandler+0x2908>
 800c246:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800c24a:	e01b      	b.n	800c284 <HAL_DMA_IRQHandler+0x2908>
 800c24c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c250:	e018      	b.n	800c284 <HAL_DMA_IRQHandler+0x2908>
 800c252:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c256:	e015      	b.n	800c284 <HAL_DMA_IRQHandler+0x2908>
 800c258:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c25c:	e012      	b.n	800c284 <HAL_DMA_IRQHandler+0x2908>
 800c25e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c262:	e00f      	b.n	800c284 <HAL_DMA_IRQHandler+0x2908>
 800c264:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c268:	e00c      	b.n	800c284 <HAL_DMA_IRQHandler+0x2908>
 800c26a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c26e:	e009      	b.n	800c284 <HAL_DMA_IRQHandler+0x2908>
 800c270:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c274:	e006      	b.n	800c284 <HAL_DMA_IRQHandler+0x2908>
 800c276:	2320      	movs	r3, #32
 800c278:	e004      	b.n	800c284 <HAL_DMA_IRQHandler+0x2908>
 800c27a:	2320      	movs	r3, #32
 800c27c:	e002      	b.n	800c284 <HAL_DMA_IRQHandler+0x2908>
 800c27e:	2320      	movs	r3, #32
 800c280:	e000      	b.n	800c284 <HAL_DMA_IRQHandler+0x2908>
 800c282:	2320      	movs	r3, #32
 800c284:	4013      	ands	r3, r2
 800c286:	2b00      	cmp	r3, #0
 800c288:	bf14      	ite	ne
 800c28a:	2301      	movne	r3, #1
 800c28c:	2300      	moveq	r3, #0
 800c28e:	b2db      	uxtb	r3, r3
 800c290:	e08d      	b.n	800c3ae <HAL_DMA_IRQHandler+0x2a32>
 800c292:	4b36      	ldr	r3, [pc, #216]	; (800c36c <HAL_DMA_IRQHandler+0x29f0>)
 800c294:	681a      	ldr	r2, [r3, #0]
 800c296:	687b      	ldr	r3, [r7, #4]
 800c298:	681b      	ldr	r3, [r3, #0]
 800c29a:	4619      	mov	r1, r3
 800c29c:	4b34      	ldr	r3, [pc, #208]	; (800c370 <HAL_DMA_IRQHandler+0x29f4>)
 800c29e:	4299      	cmp	r1, r3
 800c2a0:	d07e      	beq.n	800c3a0 <HAL_DMA_IRQHandler+0x2a24>
 800c2a2:	687b      	ldr	r3, [r7, #4]
 800c2a4:	681b      	ldr	r3, [r3, #0]
 800c2a6:	4619      	mov	r1, r3
 800c2a8:	4b32      	ldr	r3, [pc, #200]	; (800c374 <HAL_DMA_IRQHandler+0x29f8>)
 800c2aa:	4299      	cmp	r1, r3
 800c2ac:	d05a      	beq.n	800c364 <HAL_DMA_IRQHandler+0x29e8>
 800c2ae:	687b      	ldr	r3, [r7, #4]
 800c2b0:	681b      	ldr	r3, [r3, #0]
 800c2b2:	4619      	mov	r1, r3
 800c2b4:	4b30      	ldr	r3, [pc, #192]	; (800c378 <HAL_DMA_IRQHandler+0x29fc>)
 800c2b6:	4299      	cmp	r1, r3
 800c2b8:	d052      	beq.n	800c360 <HAL_DMA_IRQHandler+0x29e4>
 800c2ba:	687b      	ldr	r3, [r7, #4]
 800c2bc:	681b      	ldr	r3, [r3, #0]
 800c2be:	4619      	mov	r1, r3
 800c2c0:	4b2e      	ldr	r3, [pc, #184]	; (800c37c <HAL_DMA_IRQHandler+0x2a00>)
 800c2c2:	4299      	cmp	r1, r3
 800c2c4:	d04a      	beq.n	800c35c <HAL_DMA_IRQHandler+0x29e0>
 800c2c6:	687b      	ldr	r3, [r7, #4]
 800c2c8:	681b      	ldr	r3, [r3, #0]
 800c2ca:	4619      	mov	r1, r3
 800c2cc:	4b2c      	ldr	r3, [pc, #176]	; (800c380 <HAL_DMA_IRQHandler+0x2a04>)
 800c2ce:	4299      	cmp	r1, r3
 800c2d0:	d041      	beq.n	800c356 <HAL_DMA_IRQHandler+0x29da>
 800c2d2:	687b      	ldr	r3, [r7, #4]
 800c2d4:	681b      	ldr	r3, [r3, #0]
 800c2d6:	4619      	mov	r1, r3
 800c2d8:	4b2a      	ldr	r3, [pc, #168]	; (800c384 <HAL_DMA_IRQHandler+0x2a08>)
 800c2da:	4299      	cmp	r1, r3
 800c2dc:	d038      	beq.n	800c350 <HAL_DMA_IRQHandler+0x29d4>
 800c2de:	687b      	ldr	r3, [r7, #4]
 800c2e0:	681b      	ldr	r3, [r3, #0]
 800c2e2:	4619      	mov	r1, r3
 800c2e4:	4b28      	ldr	r3, [pc, #160]	; (800c388 <HAL_DMA_IRQHandler+0x2a0c>)
 800c2e6:	4299      	cmp	r1, r3
 800c2e8:	d02f      	beq.n	800c34a <HAL_DMA_IRQHandler+0x29ce>
 800c2ea:	687b      	ldr	r3, [r7, #4]
 800c2ec:	681b      	ldr	r3, [r3, #0]
 800c2ee:	4619      	mov	r1, r3
 800c2f0:	4b26      	ldr	r3, [pc, #152]	; (800c38c <HAL_DMA_IRQHandler+0x2a10>)
 800c2f2:	4299      	cmp	r1, r3
 800c2f4:	d026      	beq.n	800c344 <HAL_DMA_IRQHandler+0x29c8>
 800c2f6:	687b      	ldr	r3, [r7, #4]
 800c2f8:	681b      	ldr	r3, [r3, #0]
 800c2fa:	4619      	mov	r1, r3
 800c2fc:	4b24      	ldr	r3, [pc, #144]	; (800c390 <HAL_DMA_IRQHandler+0x2a14>)
 800c2fe:	4299      	cmp	r1, r3
 800c300:	d01d      	beq.n	800c33e <HAL_DMA_IRQHandler+0x29c2>
 800c302:	687b      	ldr	r3, [r7, #4]
 800c304:	681b      	ldr	r3, [r3, #0]
 800c306:	4619      	mov	r1, r3
 800c308:	4b22      	ldr	r3, [pc, #136]	; (800c394 <HAL_DMA_IRQHandler+0x2a18>)
 800c30a:	4299      	cmp	r1, r3
 800c30c:	d014      	beq.n	800c338 <HAL_DMA_IRQHandler+0x29bc>
 800c30e:	687b      	ldr	r3, [r7, #4]
 800c310:	681b      	ldr	r3, [r3, #0]
 800c312:	4619      	mov	r1, r3
 800c314:	4b20      	ldr	r3, [pc, #128]	; (800c398 <HAL_DMA_IRQHandler+0x2a1c>)
 800c316:	4299      	cmp	r1, r3
 800c318:	d00b      	beq.n	800c332 <HAL_DMA_IRQHandler+0x29b6>
 800c31a:	687b      	ldr	r3, [r7, #4]
 800c31c:	681b      	ldr	r3, [r3, #0]
 800c31e:	4619      	mov	r1, r3
 800c320:	4b1e      	ldr	r3, [pc, #120]	; (800c39c <HAL_DMA_IRQHandler+0x2a20>)
 800c322:	4299      	cmp	r1, r3
 800c324:	d102      	bne.n	800c32c <HAL_DMA_IRQHandler+0x29b0>
 800c326:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c32a:	e03a      	b.n	800c3a2 <HAL_DMA_IRQHandler+0x2a26>
 800c32c:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800c330:	e037      	b.n	800c3a2 <HAL_DMA_IRQHandler+0x2a26>
 800c332:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c336:	e034      	b.n	800c3a2 <HAL_DMA_IRQHandler+0x2a26>
 800c338:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c33c:	e031      	b.n	800c3a2 <HAL_DMA_IRQHandler+0x2a26>
 800c33e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c342:	e02e      	b.n	800c3a2 <HAL_DMA_IRQHandler+0x2a26>
 800c344:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c348:	e02b      	b.n	800c3a2 <HAL_DMA_IRQHandler+0x2a26>
 800c34a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c34e:	e028      	b.n	800c3a2 <HAL_DMA_IRQHandler+0x2a26>
 800c350:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c354:	e025      	b.n	800c3a2 <HAL_DMA_IRQHandler+0x2a26>
 800c356:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c35a:	e022      	b.n	800c3a2 <HAL_DMA_IRQHandler+0x2a26>
 800c35c:	2320      	movs	r3, #32
 800c35e:	e020      	b.n	800c3a2 <HAL_DMA_IRQHandler+0x2a26>
 800c360:	2320      	movs	r3, #32
 800c362:	e01e      	b.n	800c3a2 <HAL_DMA_IRQHandler+0x2a26>
 800c364:	2320      	movs	r3, #32
 800c366:	e01c      	b.n	800c3a2 <HAL_DMA_IRQHandler+0x2a26>
 800c368:	40026058 	.word	0x40026058
 800c36c:	40026000 	.word	0x40026000
 800c370:	40026010 	.word	0x40026010
 800c374:	40026410 	.word	0x40026410
 800c378:	40026070 	.word	0x40026070
 800c37c:	40026470 	.word	0x40026470
 800c380:	40026028 	.word	0x40026028
 800c384:	40026428 	.word	0x40026428
 800c388:	40026088 	.word	0x40026088
 800c38c:	40026488 	.word	0x40026488
 800c390:	40026040 	.word	0x40026040
 800c394:	40026440 	.word	0x40026440
 800c398:	400260a0 	.word	0x400260a0
 800c39c:	400264a0 	.word	0x400264a0
 800c3a0:	2320      	movs	r3, #32
 800c3a2:	4013      	ands	r3, r2
 800c3a4:	2b00      	cmp	r3, #0
 800c3a6:	bf14      	ite	ne
 800c3a8:	2301      	movne	r3, #1
 800c3aa:	2300      	moveq	r3, #0
 800c3ac:	b2db      	uxtb	r3, r3
 800c3ae:	2b00      	cmp	r3, #0
 800c3b0:	f000 8445 	beq.w	800cc3e <HAL_DMA_IRQHandler+0x32c2>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 800c3b4:	687b      	ldr	r3, [r7, #4]
 800c3b6:	681b      	ldr	r3, [r3, #0]
 800c3b8:	681b      	ldr	r3, [r3, #0]
 800c3ba:	f003 0310 	and.w	r3, r3, #16
 800c3be:	2b00      	cmp	r3, #0
 800c3c0:	f000 843d 	beq.w	800cc3e <HAL_DMA_IRQHandler+0x32c2>
    {
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
 800c3c4:	687b      	ldr	r3, [r7, #4]
 800c3c6:	681b      	ldr	r3, [r3, #0]
 800c3c8:	681b      	ldr	r3, [r3, #0]
 800c3ca:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800c3ce:	2b00      	cmp	r3, #0
 800c3d0:	f000 820d 	beq.w	800c7ee <HAL_DMA_IRQHandler+0x2e72>
      {
        /* Clear the transfer complete flag */
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 800c3d4:	687b      	ldr	r3, [r7, #4]
 800c3d6:	681b      	ldr	r3, [r3, #0]
 800c3d8:	461a      	mov	r2, r3
 800c3da:	4ba0      	ldr	r3, [pc, #640]	; (800c65c <HAL_DMA_IRQHandler+0x2ce0>)
 800c3dc:	429a      	cmp	r2, r3
 800c3de:	d96c      	bls.n	800c4ba <HAL_DMA_IRQHandler+0x2b3e>
 800c3e0:	4a9f      	ldr	r2, [pc, #636]	; (800c660 <HAL_DMA_IRQHandler+0x2ce4>)
 800c3e2:	687b      	ldr	r3, [r7, #4]
 800c3e4:	681b      	ldr	r3, [r3, #0]
 800c3e6:	4619      	mov	r1, r3
 800c3e8:	4b9e      	ldr	r3, [pc, #632]	; (800c664 <HAL_DMA_IRQHandler+0x2ce8>)
 800c3ea:	4299      	cmp	r1, r3
 800c3ec:	d062      	beq.n	800c4b4 <HAL_DMA_IRQHandler+0x2b38>
 800c3ee:	687b      	ldr	r3, [r7, #4]
 800c3f0:	681b      	ldr	r3, [r3, #0]
 800c3f2:	4619      	mov	r1, r3
 800c3f4:	4b9c      	ldr	r3, [pc, #624]	; (800c668 <HAL_DMA_IRQHandler+0x2cec>)
 800c3f6:	4299      	cmp	r1, r3
 800c3f8:	d05a      	beq.n	800c4b0 <HAL_DMA_IRQHandler+0x2b34>
 800c3fa:	687b      	ldr	r3, [r7, #4]
 800c3fc:	681b      	ldr	r3, [r3, #0]
 800c3fe:	4619      	mov	r1, r3
 800c400:	4b9a      	ldr	r3, [pc, #616]	; (800c66c <HAL_DMA_IRQHandler+0x2cf0>)
 800c402:	4299      	cmp	r1, r3
 800c404:	d052      	beq.n	800c4ac <HAL_DMA_IRQHandler+0x2b30>
 800c406:	687b      	ldr	r3, [r7, #4]
 800c408:	681b      	ldr	r3, [r3, #0]
 800c40a:	4619      	mov	r1, r3
 800c40c:	4b98      	ldr	r3, [pc, #608]	; (800c670 <HAL_DMA_IRQHandler+0x2cf4>)
 800c40e:	4299      	cmp	r1, r3
 800c410:	d04a      	beq.n	800c4a8 <HAL_DMA_IRQHandler+0x2b2c>
 800c412:	687b      	ldr	r3, [r7, #4]
 800c414:	681b      	ldr	r3, [r3, #0]
 800c416:	4619      	mov	r1, r3
 800c418:	4b96      	ldr	r3, [pc, #600]	; (800c674 <HAL_DMA_IRQHandler+0x2cf8>)
 800c41a:	4299      	cmp	r1, r3
 800c41c:	d041      	beq.n	800c4a2 <HAL_DMA_IRQHandler+0x2b26>
 800c41e:	687b      	ldr	r3, [r7, #4]
 800c420:	681b      	ldr	r3, [r3, #0]
 800c422:	4619      	mov	r1, r3
 800c424:	4b94      	ldr	r3, [pc, #592]	; (800c678 <HAL_DMA_IRQHandler+0x2cfc>)
 800c426:	4299      	cmp	r1, r3
 800c428:	d038      	beq.n	800c49c <HAL_DMA_IRQHandler+0x2b20>
 800c42a:	687b      	ldr	r3, [r7, #4]
 800c42c:	681b      	ldr	r3, [r3, #0]
 800c42e:	4619      	mov	r1, r3
 800c430:	4b92      	ldr	r3, [pc, #584]	; (800c67c <HAL_DMA_IRQHandler+0x2d00>)
 800c432:	4299      	cmp	r1, r3
 800c434:	d02f      	beq.n	800c496 <HAL_DMA_IRQHandler+0x2b1a>
 800c436:	687b      	ldr	r3, [r7, #4]
 800c438:	681b      	ldr	r3, [r3, #0]
 800c43a:	4619      	mov	r1, r3
 800c43c:	4b90      	ldr	r3, [pc, #576]	; (800c680 <HAL_DMA_IRQHandler+0x2d04>)
 800c43e:	4299      	cmp	r1, r3
 800c440:	d026      	beq.n	800c490 <HAL_DMA_IRQHandler+0x2b14>
 800c442:	687b      	ldr	r3, [r7, #4]
 800c444:	681b      	ldr	r3, [r3, #0]
 800c446:	4619      	mov	r1, r3
 800c448:	4b8e      	ldr	r3, [pc, #568]	; (800c684 <HAL_DMA_IRQHandler+0x2d08>)
 800c44a:	4299      	cmp	r1, r3
 800c44c:	d01d      	beq.n	800c48a <HAL_DMA_IRQHandler+0x2b0e>
 800c44e:	687b      	ldr	r3, [r7, #4]
 800c450:	681b      	ldr	r3, [r3, #0]
 800c452:	4619      	mov	r1, r3
 800c454:	4b8c      	ldr	r3, [pc, #560]	; (800c688 <HAL_DMA_IRQHandler+0x2d0c>)
 800c456:	4299      	cmp	r1, r3
 800c458:	d014      	beq.n	800c484 <HAL_DMA_IRQHandler+0x2b08>
 800c45a:	687b      	ldr	r3, [r7, #4]
 800c45c:	681b      	ldr	r3, [r3, #0]
 800c45e:	4619      	mov	r1, r3
 800c460:	4b8a      	ldr	r3, [pc, #552]	; (800c68c <HAL_DMA_IRQHandler+0x2d10>)
 800c462:	4299      	cmp	r1, r3
 800c464:	d00b      	beq.n	800c47e <HAL_DMA_IRQHandler+0x2b02>
 800c466:	687b      	ldr	r3, [r7, #4]
 800c468:	681b      	ldr	r3, [r3, #0]
 800c46a:	4619      	mov	r1, r3
 800c46c:	4b88      	ldr	r3, [pc, #544]	; (800c690 <HAL_DMA_IRQHandler+0x2d14>)
 800c46e:	4299      	cmp	r1, r3
 800c470:	d102      	bne.n	800c478 <HAL_DMA_IRQHandler+0x2afc>
 800c472:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c476:	e01e      	b.n	800c4b6 <HAL_DMA_IRQHandler+0x2b3a>
 800c478:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800c47c:	e01b      	b.n	800c4b6 <HAL_DMA_IRQHandler+0x2b3a>
 800c47e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c482:	e018      	b.n	800c4b6 <HAL_DMA_IRQHandler+0x2b3a>
 800c484:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c488:	e015      	b.n	800c4b6 <HAL_DMA_IRQHandler+0x2b3a>
 800c48a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c48e:	e012      	b.n	800c4b6 <HAL_DMA_IRQHandler+0x2b3a>
 800c490:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c494:	e00f      	b.n	800c4b6 <HAL_DMA_IRQHandler+0x2b3a>
 800c496:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c49a:	e00c      	b.n	800c4b6 <HAL_DMA_IRQHandler+0x2b3a>
 800c49c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c4a0:	e009      	b.n	800c4b6 <HAL_DMA_IRQHandler+0x2b3a>
 800c4a2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c4a6:	e006      	b.n	800c4b6 <HAL_DMA_IRQHandler+0x2b3a>
 800c4a8:	2320      	movs	r3, #32
 800c4aa:	e004      	b.n	800c4b6 <HAL_DMA_IRQHandler+0x2b3a>
 800c4ac:	2320      	movs	r3, #32
 800c4ae:	e002      	b.n	800c4b6 <HAL_DMA_IRQHandler+0x2b3a>
 800c4b0:	2320      	movs	r3, #32
 800c4b2:	e000      	b.n	800c4b6 <HAL_DMA_IRQHandler+0x2b3a>
 800c4b4:	2320      	movs	r3, #32
 800c4b6:	60d3      	str	r3, [r2, #12]
 800c4b8:	e176      	b.n	800c7a8 <HAL_DMA_IRQHandler+0x2e2c>
 800c4ba:	687b      	ldr	r3, [r7, #4]
 800c4bc:	681b      	ldr	r3, [r3, #0]
 800c4be:	461a      	mov	r2, r3
 800c4c0:	4b74      	ldr	r3, [pc, #464]	; (800c694 <HAL_DMA_IRQHandler+0x2d18>)
 800c4c2:	429a      	cmp	r2, r3
 800c4c4:	d96c      	bls.n	800c5a0 <HAL_DMA_IRQHandler+0x2c24>
 800c4c6:	4a66      	ldr	r2, [pc, #408]	; (800c660 <HAL_DMA_IRQHandler+0x2ce4>)
 800c4c8:	687b      	ldr	r3, [r7, #4]
 800c4ca:	681b      	ldr	r3, [r3, #0]
 800c4cc:	4619      	mov	r1, r3
 800c4ce:	4b65      	ldr	r3, [pc, #404]	; (800c664 <HAL_DMA_IRQHandler+0x2ce8>)
 800c4d0:	4299      	cmp	r1, r3
 800c4d2:	d062      	beq.n	800c59a <HAL_DMA_IRQHandler+0x2c1e>
 800c4d4:	687b      	ldr	r3, [r7, #4]
 800c4d6:	681b      	ldr	r3, [r3, #0]
 800c4d8:	4619      	mov	r1, r3
 800c4da:	4b63      	ldr	r3, [pc, #396]	; (800c668 <HAL_DMA_IRQHandler+0x2cec>)
 800c4dc:	4299      	cmp	r1, r3
 800c4de:	d05a      	beq.n	800c596 <HAL_DMA_IRQHandler+0x2c1a>
 800c4e0:	687b      	ldr	r3, [r7, #4]
 800c4e2:	681b      	ldr	r3, [r3, #0]
 800c4e4:	4619      	mov	r1, r3
 800c4e6:	4b61      	ldr	r3, [pc, #388]	; (800c66c <HAL_DMA_IRQHandler+0x2cf0>)
 800c4e8:	4299      	cmp	r1, r3
 800c4ea:	d052      	beq.n	800c592 <HAL_DMA_IRQHandler+0x2c16>
 800c4ec:	687b      	ldr	r3, [r7, #4]
 800c4ee:	681b      	ldr	r3, [r3, #0]
 800c4f0:	4619      	mov	r1, r3
 800c4f2:	4b5f      	ldr	r3, [pc, #380]	; (800c670 <HAL_DMA_IRQHandler+0x2cf4>)
 800c4f4:	4299      	cmp	r1, r3
 800c4f6:	d04a      	beq.n	800c58e <HAL_DMA_IRQHandler+0x2c12>
 800c4f8:	687b      	ldr	r3, [r7, #4]
 800c4fa:	681b      	ldr	r3, [r3, #0]
 800c4fc:	4619      	mov	r1, r3
 800c4fe:	4b5d      	ldr	r3, [pc, #372]	; (800c674 <HAL_DMA_IRQHandler+0x2cf8>)
 800c500:	4299      	cmp	r1, r3
 800c502:	d041      	beq.n	800c588 <HAL_DMA_IRQHandler+0x2c0c>
 800c504:	687b      	ldr	r3, [r7, #4]
 800c506:	681b      	ldr	r3, [r3, #0]
 800c508:	4619      	mov	r1, r3
 800c50a:	4b5b      	ldr	r3, [pc, #364]	; (800c678 <HAL_DMA_IRQHandler+0x2cfc>)
 800c50c:	4299      	cmp	r1, r3
 800c50e:	d038      	beq.n	800c582 <HAL_DMA_IRQHandler+0x2c06>
 800c510:	687b      	ldr	r3, [r7, #4]
 800c512:	681b      	ldr	r3, [r3, #0]
 800c514:	4619      	mov	r1, r3
 800c516:	4b59      	ldr	r3, [pc, #356]	; (800c67c <HAL_DMA_IRQHandler+0x2d00>)
 800c518:	4299      	cmp	r1, r3
 800c51a:	d02f      	beq.n	800c57c <HAL_DMA_IRQHandler+0x2c00>
 800c51c:	687b      	ldr	r3, [r7, #4]
 800c51e:	681b      	ldr	r3, [r3, #0]
 800c520:	4619      	mov	r1, r3
 800c522:	4b57      	ldr	r3, [pc, #348]	; (800c680 <HAL_DMA_IRQHandler+0x2d04>)
 800c524:	4299      	cmp	r1, r3
 800c526:	d026      	beq.n	800c576 <HAL_DMA_IRQHandler+0x2bfa>
 800c528:	687b      	ldr	r3, [r7, #4]
 800c52a:	681b      	ldr	r3, [r3, #0]
 800c52c:	4619      	mov	r1, r3
 800c52e:	4b55      	ldr	r3, [pc, #340]	; (800c684 <HAL_DMA_IRQHandler+0x2d08>)
 800c530:	4299      	cmp	r1, r3
 800c532:	d01d      	beq.n	800c570 <HAL_DMA_IRQHandler+0x2bf4>
 800c534:	687b      	ldr	r3, [r7, #4]
 800c536:	681b      	ldr	r3, [r3, #0]
 800c538:	4619      	mov	r1, r3
 800c53a:	4b53      	ldr	r3, [pc, #332]	; (800c688 <HAL_DMA_IRQHandler+0x2d0c>)
 800c53c:	4299      	cmp	r1, r3
 800c53e:	d014      	beq.n	800c56a <HAL_DMA_IRQHandler+0x2bee>
 800c540:	687b      	ldr	r3, [r7, #4]
 800c542:	681b      	ldr	r3, [r3, #0]
 800c544:	4619      	mov	r1, r3
 800c546:	4b51      	ldr	r3, [pc, #324]	; (800c68c <HAL_DMA_IRQHandler+0x2d10>)
 800c548:	4299      	cmp	r1, r3
 800c54a:	d00b      	beq.n	800c564 <HAL_DMA_IRQHandler+0x2be8>
 800c54c:	687b      	ldr	r3, [r7, #4]
 800c54e:	681b      	ldr	r3, [r3, #0]
 800c550:	4619      	mov	r1, r3
 800c552:	4b4f      	ldr	r3, [pc, #316]	; (800c690 <HAL_DMA_IRQHandler+0x2d14>)
 800c554:	4299      	cmp	r1, r3
 800c556:	d102      	bne.n	800c55e <HAL_DMA_IRQHandler+0x2be2>
 800c558:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c55c:	e01e      	b.n	800c59c <HAL_DMA_IRQHandler+0x2c20>
 800c55e:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800c562:	e01b      	b.n	800c59c <HAL_DMA_IRQHandler+0x2c20>
 800c564:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c568:	e018      	b.n	800c59c <HAL_DMA_IRQHandler+0x2c20>
 800c56a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c56e:	e015      	b.n	800c59c <HAL_DMA_IRQHandler+0x2c20>
 800c570:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c574:	e012      	b.n	800c59c <HAL_DMA_IRQHandler+0x2c20>
 800c576:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c57a:	e00f      	b.n	800c59c <HAL_DMA_IRQHandler+0x2c20>
 800c57c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c580:	e00c      	b.n	800c59c <HAL_DMA_IRQHandler+0x2c20>
 800c582:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c586:	e009      	b.n	800c59c <HAL_DMA_IRQHandler+0x2c20>
 800c588:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c58c:	e006      	b.n	800c59c <HAL_DMA_IRQHandler+0x2c20>
 800c58e:	2320      	movs	r3, #32
 800c590:	e004      	b.n	800c59c <HAL_DMA_IRQHandler+0x2c20>
 800c592:	2320      	movs	r3, #32
 800c594:	e002      	b.n	800c59c <HAL_DMA_IRQHandler+0x2c20>
 800c596:	2320      	movs	r3, #32
 800c598:	e000      	b.n	800c59c <HAL_DMA_IRQHandler+0x2c20>
 800c59a:	2320      	movs	r3, #32
 800c59c:	6093      	str	r3, [r2, #8]
 800c59e:	e103      	b.n	800c7a8 <HAL_DMA_IRQHandler+0x2e2c>
 800c5a0:	687b      	ldr	r3, [r7, #4]
 800c5a2:	681b      	ldr	r3, [r3, #0]
 800c5a4:	461a      	mov	r2, r3
 800c5a6:	4b3c      	ldr	r3, [pc, #240]	; (800c698 <HAL_DMA_IRQHandler+0x2d1c>)
 800c5a8:	429a      	cmp	r2, r3
 800c5aa:	f240 8091 	bls.w	800c6d0 <HAL_DMA_IRQHandler+0x2d54>
 800c5ae:	4a3b      	ldr	r2, [pc, #236]	; (800c69c <HAL_DMA_IRQHandler+0x2d20>)
 800c5b0:	687b      	ldr	r3, [r7, #4]
 800c5b2:	681b      	ldr	r3, [r3, #0]
 800c5b4:	4619      	mov	r1, r3
 800c5b6:	4b2b      	ldr	r3, [pc, #172]	; (800c664 <HAL_DMA_IRQHandler+0x2ce8>)
 800c5b8:	4299      	cmp	r1, r3
 800c5ba:	f000 8086 	beq.w	800c6ca <HAL_DMA_IRQHandler+0x2d4e>
 800c5be:	687b      	ldr	r3, [r7, #4]
 800c5c0:	681b      	ldr	r3, [r3, #0]
 800c5c2:	4619      	mov	r1, r3
 800c5c4:	4b28      	ldr	r3, [pc, #160]	; (800c668 <HAL_DMA_IRQHandler+0x2cec>)
 800c5c6:	4299      	cmp	r1, r3
 800c5c8:	d07d      	beq.n	800c6c6 <HAL_DMA_IRQHandler+0x2d4a>
 800c5ca:	687b      	ldr	r3, [r7, #4]
 800c5cc:	681b      	ldr	r3, [r3, #0]
 800c5ce:	4619      	mov	r1, r3
 800c5d0:	4b26      	ldr	r3, [pc, #152]	; (800c66c <HAL_DMA_IRQHandler+0x2cf0>)
 800c5d2:	4299      	cmp	r1, r3
 800c5d4:	d075      	beq.n	800c6c2 <HAL_DMA_IRQHandler+0x2d46>
 800c5d6:	687b      	ldr	r3, [r7, #4]
 800c5d8:	681b      	ldr	r3, [r3, #0]
 800c5da:	4619      	mov	r1, r3
 800c5dc:	4b24      	ldr	r3, [pc, #144]	; (800c670 <HAL_DMA_IRQHandler+0x2cf4>)
 800c5de:	4299      	cmp	r1, r3
 800c5e0:	d06d      	beq.n	800c6be <HAL_DMA_IRQHandler+0x2d42>
 800c5e2:	687b      	ldr	r3, [r7, #4]
 800c5e4:	681b      	ldr	r3, [r3, #0]
 800c5e6:	4619      	mov	r1, r3
 800c5e8:	4b22      	ldr	r3, [pc, #136]	; (800c674 <HAL_DMA_IRQHandler+0x2cf8>)
 800c5ea:	4299      	cmp	r1, r3
 800c5ec:	d064      	beq.n	800c6b8 <HAL_DMA_IRQHandler+0x2d3c>
 800c5ee:	687b      	ldr	r3, [r7, #4]
 800c5f0:	681b      	ldr	r3, [r3, #0]
 800c5f2:	4619      	mov	r1, r3
 800c5f4:	4b20      	ldr	r3, [pc, #128]	; (800c678 <HAL_DMA_IRQHandler+0x2cfc>)
 800c5f6:	4299      	cmp	r1, r3
 800c5f8:	d05b      	beq.n	800c6b2 <HAL_DMA_IRQHandler+0x2d36>
 800c5fa:	687b      	ldr	r3, [r7, #4]
 800c5fc:	681b      	ldr	r3, [r3, #0]
 800c5fe:	4619      	mov	r1, r3
 800c600:	4b1e      	ldr	r3, [pc, #120]	; (800c67c <HAL_DMA_IRQHandler+0x2d00>)
 800c602:	4299      	cmp	r1, r3
 800c604:	d052      	beq.n	800c6ac <HAL_DMA_IRQHandler+0x2d30>
 800c606:	687b      	ldr	r3, [r7, #4]
 800c608:	681b      	ldr	r3, [r3, #0]
 800c60a:	4619      	mov	r1, r3
 800c60c:	4b1c      	ldr	r3, [pc, #112]	; (800c680 <HAL_DMA_IRQHandler+0x2d04>)
 800c60e:	4299      	cmp	r1, r3
 800c610:	d049      	beq.n	800c6a6 <HAL_DMA_IRQHandler+0x2d2a>
 800c612:	687b      	ldr	r3, [r7, #4]
 800c614:	681b      	ldr	r3, [r3, #0]
 800c616:	4619      	mov	r1, r3
 800c618:	4b1a      	ldr	r3, [pc, #104]	; (800c684 <HAL_DMA_IRQHandler+0x2d08>)
 800c61a:	4299      	cmp	r1, r3
 800c61c:	d040      	beq.n	800c6a0 <HAL_DMA_IRQHandler+0x2d24>
 800c61e:	687b      	ldr	r3, [r7, #4]
 800c620:	681b      	ldr	r3, [r3, #0]
 800c622:	4619      	mov	r1, r3
 800c624:	4b18      	ldr	r3, [pc, #96]	; (800c688 <HAL_DMA_IRQHandler+0x2d0c>)
 800c626:	4299      	cmp	r1, r3
 800c628:	d014      	beq.n	800c654 <HAL_DMA_IRQHandler+0x2cd8>
 800c62a:	687b      	ldr	r3, [r7, #4]
 800c62c:	681b      	ldr	r3, [r3, #0]
 800c62e:	4619      	mov	r1, r3
 800c630:	4b16      	ldr	r3, [pc, #88]	; (800c68c <HAL_DMA_IRQHandler+0x2d10>)
 800c632:	4299      	cmp	r1, r3
 800c634:	d00b      	beq.n	800c64e <HAL_DMA_IRQHandler+0x2cd2>
 800c636:	687b      	ldr	r3, [r7, #4]
 800c638:	681b      	ldr	r3, [r3, #0]
 800c63a:	4619      	mov	r1, r3
 800c63c:	4b14      	ldr	r3, [pc, #80]	; (800c690 <HAL_DMA_IRQHandler+0x2d14>)
 800c63e:	4299      	cmp	r1, r3
 800c640:	d102      	bne.n	800c648 <HAL_DMA_IRQHandler+0x2ccc>
 800c642:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c646:	e041      	b.n	800c6cc <HAL_DMA_IRQHandler+0x2d50>
 800c648:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800c64c:	e03e      	b.n	800c6cc <HAL_DMA_IRQHandler+0x2d50>
 800c64e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c652:	e03b      	b.n	800c6cc <HAL_DMA_IRQHandler+0x2d50>
 800c654:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c658:	e038      	b.n	800c6cc <HAL_DMA_IRQHandler+0x2d50>
 800c65a:	bf00      	nop
 800c65c:	40026458 	.word	0x40026458
 800c660:	40026400 	.word	0x40026400
 800c664:	40026010 	.word	0x40026010
 800c668:	40026410 	.word	0x40026410
 800c66c:	40026070 	.word	0x40026070
 800c670:	40026470 	.word	0x40026470
 800c674:	40026028 	.word	0x40026028
 800c678:	40026428 	.word	0x40026428
 800c67c:	40026088 	.word	0x40026088
 800c680:	40026488 	.word	0x40026488
 800c684:	40026040 	.word	0x40026040
 800c688:	40026440 	.word	0x40026440
 800c68c:	400260a0 	.word	0x400260a0
 800c690:	400264a0 	.word	0x400264a0
 800c694:	400260b8 	.word	0x400260b8
 800c698:	40026058 	.word	0x40026058
 800c69c:	40026000 	.word	0x40026000
 800c6a0:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c6a4:	e012      	b.n	800c6cc <HAL_DMA_IRQHandler+0x2d50>
 800c6a6:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c6aa:	e00f      	b.n	800c6cc <HAL_DMA_IRQHandler+0x2d50>
 800c6ac:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c6b0:	e00c      	b.n	800c6cc <HAL_DMA_IRQHandler+0x2d50>
 800c6b2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c6b6:	e009      	b.n	800c6cc <HAL_DMA_IRQHandler+0x2d50>
 800c6b8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c6bc:	e006      	b.n	800c6cc <HAL_DMA_IRQHandler+0x2d50>
 800c6be:	2320      	movs	r3, #32
 800c6c0:	e004      	b.n	800c6cc <HAL_DMA_IRQHandler+0x2d50>
 800c6c2:	2320      	movs	r3, #32
 800c6c4:	e002      	b.n	800c6cc <HAL_DMA_IRQHandler+0x2d50>
 800c6c6:	2320      	movs	r3, #32
 800c6c8:	e000      	b.n	800c6cc <HAL_DMA_IRQHandler+0x2d50>
 800c6ca:	2320      	movs	r3, #32
 800c6cc:	60d3      	str	r3, [r2, #12]
 800c6ce:	e06b      	b.n	800c7a8 <HAL_DMA_IRQHandler+0x2e2c>
 800c6d0:	4a88      	ldr	r2, [pc, #544]	; (800c8f4 <HAL_DMA_IRQHandler+0x2f78>)
 800c6d2:	687b      	ldr	r3, [r7, #4]
 800c6d4:	681b      	ldr	r3, [r3, #0]
 800c6d6:	4619      	mov	r1, r3
 800c6d8:	4b87      	ldr	r3, [pc, #540]	; (800c8f8 <HAL_DMA_IRQHandler+0x2f7c>)
 800c6da:	4299      	cmp	r1, r3
 800c6dc:	d062      	beq.n	800c7a4 <HAL_DMA_IRQHandler+0x2e28>
 800c6de:	687b      	ldr	r3, [r7, #4]
 800c6e0:	681b      	ldr	r3, [r3, #0]
 800c6e2:	4619      	mov	r1, r3
 800c6e4:	4b85      	ldr	r3, [pc, #532]	; (800c8fc <HAL_DMA_IRQHandler+0x2f80>)
 800c6e6:	4299      	cmp	r1, r3
 800c6e8:	d05a      	beq.n	800c7a0 <HAL_DMA_IRQHandler+0x2e24>
 800c6ea:	687b      	ldr	r3, [r7, #4]
 800c6ec:	681b      	ldr	r3, [r3, #0]
 800c6ee:	4619      	mov	r1, r3
 800c6f0:	4b83      	ldr	r3, [pc, #524]	; (800c900 <HAL_DMA_IRQHandler+0x2f84>)
 800c6f2:	4299      	cmp	r1, r3
 800c6f4:	d052      	beq.n	800c79c <HAL_DMA_IRQHandler+0x2e20>
 800c6f6:	687b      	ldr	r3, [r7, #4]
 800c6f8:	681b      	ldr	r3, [r3, #0]
 800c6fa:	4619      	mov	r1, r3
 800c6fc:	4b81      	ldr	r3, [pc, #516]	; (800c904 <HAL_DMA_IRQHandler+0x2f88>)
 800c6fe:	4299      	cmp	r1, r3
 800c700:	d04a      	beq.n	800c798 <HAL_DMA_IRQHandler+0x2e1c>
 800c702:	687b      	ldr	r3, [r7, #4]
 800c704:	681b      	ldr	r3, [r3, #0]
 800c706:	4619      	mov	r1, r3
 800c708:	4b7f      	ldr	r3, [pc, #508]	; (800c908 <HAL_DMA_IRQHandler+0x2f8c>)
 800c70a:	4299      	cmp	r1, r3
 800c70c:	d041      	beq.n	800c792 <HAL_DMA_IRQHandler+0x2e16>
 800c70e:	687b      	ldr	r3, [r7, #4]
 800c710:	681b      	ldr	r3, [r3, #0]
 800c712:	4619      	mov	r1, r3
 800c714:	4b7d      	ldr	r3, [pc, #500]	; (800c90c <HAL_DMA_IRQHandler+0x2f90>)
 800c716:	4299      	cmp	r1, r3
 800c718:	d038      	beq.n	800c78c <HAL_DMA_IRQHandler+0x2e10>
 800c71a:	687b      	ldr	r3, [r7, #4]
 800c71c:	681b      	ldr	r3, [r3, #0]
 800c71e:	4619      	mov	r1, r3
 800c720:	4b7b      	ldr	r3, [pc, #492]	; (800c910 <HAL_DMA_IRQHandler+0x2f94>)
 800c722:	4299      	cmp	r1, r3
 800c724:	d02f      	beq.n	800c786 <HAL_DMA_IRQHandler+0x2e0a>
 800c726:	687b      	ldr	r3, [r7, #4]
 800c728:	681b      	ldr	r3, [r3, #0]
 800c72a:	4619      	mov	r1, r3
 800c72c:	4b79      	ldr	r3, [pc, #484]	; (800c914 <HAL_DMA_IRQHandler+0x2f98>)
 800c72e:	4299      	cmp	r1, r3
 800c730:	d026      	beq.n	800c780 <HAL_DMA_IRQHandler+0x2e04>
 800c732:	687b      	ldr	r3, [r7, #4]
 800c734:	681b      	ldr	r3, [r3, #0]
 800c736:	4619      	mov	r1, r3
 800c738:	4b77      	ldr	r3, [pc, #476]	; (800c918 <HAL_DMA_IRQHandler+0x2f9c>)
 800c73a:	4299      	cmp	r1, r3
 800c73c:	d01d      	beq.n	800c77a <HAL_DMA_IRQHandler+0x2dfe>
 800c73e:	687b      	ldr	r3, [r7, #4]
 800c740:	681b      	ldr	r3, [r3, #0]
 800c742:	4619      	mov	r1, r3
 800c744:	4b75      	ldr	r3, [pc, #468]	; (800c91c <HAL_DMA_IRQHandler+0x2fa0>)
 800c746:	4299      	cmp	r1, r3
 800c748:	d014      	beq.n	800c774 <HAL_DMA_IRQHandler+0x2df8>
 800c74a:	687b      	ldr	r3, [r7, #4]
 800c74c:	681b      	ldr	r3, [r3, #0]
 800c74e:	4619      	mov	r1, r3
 800c750:	4b73      	ldr	r3, [pc, #460]	; (800c920 <HAL_DMA_IRQHandler+0x2fa4>)
 800c752:	4299      	cmp	r1, r3
 800c754:	d00b      	beq.n	800c76e <HAL_DMA_IRQHandler+0x2df2>
 800c756:	687b      	ldr	r3, [r7, #4]
 800c758:	681b      	ldr	r3, [r3, #0]
 800c75a:	4619      	mov	r1, r3
 800c75c:	4b71      	ldr	r3, [pc, #452]	; (800c924 <HAL_DMA_IRQHandler+0x2fa8>)
 800c75e:	4299      	cmp	r1, r3
 800c760:	d102      	bne.n	800c768 <HAL_DMA_IRQHandler+0x2dec>
 800c762:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c766:	e01e      	b.n	800c7a6 <HAL_DMA_IRQHandler+0x2e2a>
 800c768:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800c76c:	e01b      	b.n	800c7a6 <HAL_DMA_IRQHandler+0x2e2a>
 800c76e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c772:	e018      	b.n	800c7a6 <HAL_DMA_IRQHandler+0x2e2a>
 800c774:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c778:	e015      	b.n	800c7a6 <HAL_DMA_IRQHandler+0x2e2a>
 800c77a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c77e:	e012      	b.n	800c7a6 <HAL_DMA_IRQHandler+0x2e2a>
 800c780:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c784:	e00f      	b.n	800c7a6 <HAL_DMA_IRQHandler+0x2e2a>
 800c786:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c78a:	e00c      	b.n	800c7a6 <HAL_DMA_IRQHandler+0x2e2a>
 800c78c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c790:	e009      	b.n	800c7a6 <HAL_DMA_IRQHandler+0x2e2a>
 800c792:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c796:	e006      	b.n	800c7a6 <HAL_DMA_IRQHandler+0x2e2a>
 800c798:	2320      	movs	r3, #32
 800c79a:	e004      	b.n	800c7a6 <HAL_DMA_IRQHandler+0x2e2a>
 800c79c:	2320      	movs	r3, #32
 800c79e:	e002      	b.n	800c7a6 <HAL_DMA_IRQHandler+0x2e2a>
 800c7a0:	2320      	movs	r3, #32
 800c7a2:	e000      	b.n	800c7a6 <HAL_DMA_IRQHandler+0x2e2a>
 800c7a4:	2320      	movs	r3, #32
 800c7a6:	6093      	str	r3, [r2, #8]

        /* Current memory buffer used is Memory 1 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
 800c7a8:	687b      	ldr	r3, [r7, #4]
 800c7aa:	681b      	ldr	r3, [r3, #0]
 800c7ac:	681b      	ldr	r3, [r3, #0]
 800c7ae:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800c7b2:	2b00      	cmp	r3, #0
 800c7b4:	d109      	bne.n	800c7ca <HAL_DMA_IRQHandler+0x2e4e>
        {
          if(hdma->XferM1CpltCallback != NULL)
 800c7b6:	687b      	ldr	r3, [r7, #4]
 800c7b8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c7ba:	2b00      	cmp	r3, #0
 800c7bc:	f000 823f 	beq.w	800cc3e <HAL_DMA_IRQHandler+0x32c2>
          {
            /* Transfer complete Callback for memory1 */
            hdma->XferM1CpltCallback(hdma);
 800c7c0:	687b      	ldr	r3, [r7, #4]
 800c7c2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c7c4:	6878      	ldr	r0, [r7, #4]
 800c7c6:	4798      	blx	r3
 800c7c8:	e239      	b.n	800cc3e <HAL_DMA_IRQHandler+0x32c2>
          }
        }
        /* Current memory buffer used is Memory 0 */
        else if((hdma->Instance->CR & DMA_SxCR_CT) != 0) 
 800c7ca:	687b      	ldr	r3, [r7, #4]
 800c7cc:	681b      	ldr	r3, [r3, #0]
 800c7ce:	681b      	ldr	r3, [r3, #0]
 800c7d0:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800c7d4:	2b00      	cmp	r3, #0
 800c7d6:	f000 8232 	beq.w	800cc3e <HAL_DMA_IRQHandler+0x32c2>
        {
          if(hdma->XferCpltCallback != NULL)
 800c7da:	687b      	ldr	r3, [r7, #4]
 800c7dc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c7de:	2b00      	cmp	r3, #0
 800c7e0:	f000 822d 	beq.w	800cc3e <HAL_DMA_IRQHandler+0x32c2>
          {
            /* Transfer complete Callback for memory0 */
            hdma->XferCpltCallback(hdma);
 800c7e4:	687b      	ldr	r3, [r7, #4]
 800c7e6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c7e8:	6878      	ldr	r0, [r7, #4]
 800c7ea:	4798      	blx	r3
 800c7ec:	e227      	b.n	800cc3e <HAL_DMA_IRQHandler+0x32c2>
        }
      }
      /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
      else
      {
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 800c7ee:	687b      	ldr	r3, [r7, #4]
 800c7f0:	681b      	ldr	r3, [r3, #0]
 800c7f2:	681b      	ldr	r3, [r3, #0]
 800c7f4:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800c7f8:	2b00      	cmp	r3, #0
 800c7fa:	d107      	bne.n	800c80c <HAL_DMA_IRQHandler+0x2e90>
        {
          /* Disable the transfer complete interrupt */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
 800c7fc:	687b      	ldr	r3, [r7, #4]
 800c7fe:	681b      	ldr	r3, [r3, #0]
 800c800:	687a      	ldr	r2, [r7, #4]
 800c802:	6812      	ldr	r2, [r2, #0]
 800c804:	6812      	ldr	r2, [r2, #0]
 800c806:	f022 0210 	bic.w	r2, r2, #16
 800c80a:	601a      	str	r2, [r3, #0]
        }
        /* Clear the transfer complete flag */
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 800c80c:	687b      	ldr	r3, [r7, #4]
 800c80e:	681b      	ldr	r3, [r3, #0]
 800c810:	461a      	mov	r2, r3
 800c812:	4b45      	ldr	r3, [pc, #276]	; (800c928 <HAL_DMA_IRQHandler+0x2fac>)
 800c814:	429a      	cmp	r2, r3
 800c816:	f240 808b 	bls.w	800c930 <HAL_DMA_IRQHandler+0x2fb4>
 800c81a:	4a44      	ldr	r2, [pc, #272]	; (800c92c <HAL_DMA_IRQHandler+0x2fb0>)
 800c81c:	687b      	ldr	r3, [r7, #4]
 800c81e:	681b      	ldr	r3, [r3, #0]
 800c820:	4619      	mov	r1, r3
 800c822:	4b35      	ldr	r3, [pc, #212]	; (800c8f8 <HAL_DMA_IRQHandler+0x2f7c>)
 800c824:	4299      	cmp	r1, r3
 800c826:	d062      	beq.n	800c8ee <HAL_DMA_IRQHandler+0x2f72>
 800c828:	687b      	ldr	r3, [r7, #4]
 800c82a:	681b      	ldr	r3, [r3, #0]
 800c82c:	4619      	mov	r1, r3
 800c82e:	4b33      	ldr	r3, [pc, #204]	; (800c8fc <HAL_DMA_IRQHandler+0x2f80>)
 800c830:	4299      	cmp	r1, r3
 800c832:	d05a      	beq.n	800c8ea <HAL_DMA_IRQHandler+0x2f6e>
 800c834:	687b      	ldr	r3, [r7, #4]
 800c836:	681b      	ldr	r3, [r3, #0]
 800c838:	4619      	mov	r1, r3
 800c83a:	4b31      	ldr	r3, [pc, #196]	; (800c900 <HAL_DMA_IRQHandler+0x2f84>)
 800c83c:	4299      	cmp	r1, r3
 800c83e:	d052      	beq.n	800c8e6 <HAL_DMA_IRQHandler+0x2f6a>
 800c840:	687b      	ldr	r3, [r7, #4]
 800c842:	681b      	ldr	r3, [r3, #0]
 800c844:	4619      	mov	r1, r3
 800c846:	4b2f      	ldr	r3, [pc, #188]	; (800c904 <HAL_DMA_IRQHandler+0x2f88>)
 800c848:	4299      	cmp	r1, r3
 800c84a:	d04a      	beq.n	800c8e2 <HAL_DMA_IRQHandler+0x2f66>
 800c84c:	687b      	ldr	r3, [r7, #4]
 800c84e:	681b      	ldr	r3, [r3, #0]
 800c850:	4619      	mov	r1, r3
 800c852:	4b2d      	ldr	r3, [pc, #180]	; (800c908 <HAL_DMA_IRQHandler+0x2f8c>)
 800c854:	4299      	cmp	r1, r3
 800c856:	d041      	beq.n	800c8dc <HAL_DMA_IRQHandler+0x2f60>
 800c858:	687b      	ldr	r3, [r7, #4]
 800c85a:	681b      	ldr	r3, [r3, #0]
 800c85c:	4619      	mov	r1, r3
 800c85e:	4b2b      	ldr	r3, [pc, #172]	; (800c90c <HAL_DMA_IRQHandler+0x2f90>)
 800c860:	4299      	cmp	r1, r3
 800c862:	d038      	beq.n	800c8d6 <HAL_DMA_IRQHandler+0x2f5a>
 800c864:	687b      	ldr	r3, [r7, #4]
 800c866:	681b      	ldr	r3, [r3, #0]
 800c868:	4619      	mov	r1, r3
 800c86a:	4b29      	ldr	r3, [pc, #164]	; (800c910 <HAL_DMA_IRQHandler+0x2f94>)
 800c86c:	4299      	cmp	r1, r3
 800c86e:	d02f      	beq.n	800c8d0 <HAL_DMA_IRQHandler+0x2f54>
 800c870:	687b      	ldr	r3, [r7, #4]
 800c872:	681b      	ldr	r3, [r3, #0]
 800c874:	4619      	mov	r1, r3
 800c876:	4b27      	ldr	r3, [pc, #156]	; (800c914 <HAL_DMA_IRQHandler+0x2f98>)
 800c878:	4299      	cmp	r1, r3
 800c87a:	d026      	beq.n	800c8ca <HAL_DMA_IRQHandler+0x2f4e>
 800c87c:	687b      	ldr	r3, [r7, #4]
 800c87e:	681b      	ldr	r3, [r3, #0]
 800c880:	4619      	mov	r1, r3
 800c882:	4b25      	ldr	r3, [pc, #148]	; (800c918 <HAL_DMA_IRQHandler+0x2f9c>)
 800c884:	4299      	cmp	r1, r3
 800c886:	d01d      	beq.n	800c8c4 <HAL_DMA_IRQHandler+0x2f48>
 800c888:	687b      	ldr	r3, [r7, #4]
 800c88a:	681b      	ldr	r3, [r3, #0]
 800c88c:	4619      	mov	r1, r3
 800c88e:	4b23      	ldr	r3, [pc, #140]	; (800c91c <HAL_DMA_IRQHandler+0x2fa0>)
 800c890:	4299      	cmp	r1, r3
 800c892:	d014      	beq.n	800c8be <HAL_DMA_IRQHandler+0x2f42>
 800c894:	687b      	ldr	r3, [r7, #4]
 800c896:	681b      	ldr	r3, [r3, #0]
 800c898:	4619      	mov	r1, r3
 800c89a:	4b21      	ldr	r3, [pc, #132]	; (800c920 <HAL_DMA_IRQHandler+0x2fa4>)
 800c89c:	4299      	cmp	r1, r3
 800c89e:	d00b      	beq.n	800c8b8 <HAL_DMA_IRQHandler+0x2f3c>
 800c8a0:	687b      	ldr	r3, [r7, #4]
 800c8a2:	681b      	ldr	r3, [r3, #0]
 800c8a4:	4619      	mov	r1, r3
 800c8a6:	4b1f      	ldr	r3, [pc, #124]	; (800c924 <HAL_DMA_IRQHandler+0x2fa8>)
 800c8a8:	4299      	cmp	r1, r3
 800c8aa:	d102      	bne.n	800c8b2 <HAL_DMA_IRQHandler+0x2f36>
 800c8ac:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c8b0:	e01e      	b.n	800c8f0 <HAL_DMA_IRQHandler+0x2f74>
 800c8b2:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800c8b6:	e01b      	b.n	800c8f0 <HAL_DMA_IRQHandler+0x2f74>
 800c8b8:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c8bc:	e018      	b.n	800c8f0 <HAL_DMA_IRQHandler+0x2f74>
 800c8be:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c8c2:	e015      	b.n	800c8f0 <HAL_DMA_IRQHandler+0x2f74>
 800c8c4:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c8c8:	e012      	b.n	800c8f0 <HAL_DMA_IRQHandler+0x2f74>
 800c8ca:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c8ce:	e00f      	b.n	800c8f0 <HAL_DMA_IRQHandler+0x2f74>
 800c8d0:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c8d4:	e00c      	b.n	800c8f0 <HAL_DMA_IRQHandler+0x2f74>
 800c8d6:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c8da:	e009      	b.n	800c8f0 <HAL_DMA_IRQHandler+0x2f74>
 800c8dc:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c8e0:	e006      	b.n	800c8f0 <HAL_DMA_IRQHandler+0x2f74>
 800c8e2:	2320      	movs	r3, #32
 800c8e4:	e004      	b.n	800c8f0 <HAL_DMA_IRQHandler+0x2f74>
 800c8e6:	2320      	movs	r3, #32
 800c8e8:	e002      	b.n	800c8f0 <HAL_DMA_IRQHandler+0x2f74>
 800c8ea:	2320      	movs	r3, #32
 800c8ec:	e000      	b.n	800c8f0 <HAL_DMA_IRQHandler+0x2f74>
 800c8ee:	2320      	movs	r3, #32
 800c8f0:	60d3      	str	r3, [r2, #12]
 800c8f2:	e190      	b.n	800cc16 <HAL_DMA_IRQHandler+0x329a>
 800c8f4:	40026000 	.word	0x40026000
 800c8f8:	40026010 	.word	0x40026010
 800c8fc:	40026410 	.word	0x40026410
 800c900:	40026070 	.word	0x40026070
 800c904:	40026470 	.word	0x40026470
 800c908:	40026028 	.word	0x40026028
 800c90c:	40026428 	.word	0x40026428
 800c910:	40026088 	.word	0x40026088
 800c914:	40026488 	.word	0x40026488
 800c918:	40026040 	.word	0x40026040
 800c91c:	40026440 	.word	0x40026440
 800c920:	400260a0 	.word	0x400260a0
 800c924:	400264a0 	.word	0x400264a0
 800c928:	40026458 	.word	0x40026458
 800c92c:	40026400 	.word	0x40026400
 800c930:	687b      	ldr	r3, [r7, #4]
 800c932:	681b      	ldr	r3, [r3, #0]
 800c934:	461a      	mov	r2, r3
 800c936:	4b9f      	ldr	r3, [pc, #636]	; (800cbb4 <HAL_DMA_IRQHandler+0x3238>)
 800c938:	429a      	cmp	r2, r3
 800c93a:	d96c      	bls.n	800ca16 <HAL_DMA_IRQHandler+0x309a>
 800c93c:	4a9e      	ldr	r2, [pc, #632]	; (800cbb8 <HAL_DMA_IRQHandler+0x323c>)
 800c93e:	687b      	ldr	r3, [r7, #4]
 800c940:	681b      	ldr	r3, [r3, #0]
 800c942:	4619      	mov	r1, r3
 800c944:	4b9d      	ldr	r3, [pc, #628]	; (800cbbc <HAL_DMA_IRQHandler+0x3240>)
 800c946:	4299      	cmp	r1, r3
 800c948:	d062      	beq.n	800ca10 <HAL_DMA_IRQHandler+0x3094>
 800c94a:	687b      	ldr	r3, [r7, #4]
 800c94c:	681b      	ldr	r3, [r3, #0]
 800c94e:	4619      	mov	r1, r3
 800c950:	4b9b      	ldr	r3, [pc, #620]	; (800cbc0 <HAL_DMA_IRQHandler+0x3244>)
 800c952:	4299      	cmp	r1, r3
 800c954:	d05a      	beq.n	800ca0c <HAL_DMA_IRQHandler+0x3090>
 800c956:	687b      	ldr	r3, [r7, #4]
 800c958:	681b      	ldr	r3, [r3, #0]
 800c95a:	4619      	mov	r1, r3
 800c95c:	4b99      	ldr	r3, [pc, #612]	; (800cbc4 <HAL_DMA_IRQHandler+0x3248>)
 800c95e:	4299      	cmp	r1, r3
 800c960:	d052      	beq.n	800ca08 <HAL_DMA_IRQHandler+0x308c>
 800c962:	687b      	ldr	r3, [r7, #4]
 800c964:	681b      	ldr	r3, [r3, #0]
 800c966:	4619      	mov	r1, r3
 800c968:	4b97      	ldr	r3, [pc, #604]	; (800cbc8 <HAL_DMA_IRQHandler+0x324c>)
 800c96a:	4299      	cmp	r1, r3
 800c96c:	d04a      	beq.n	800ca04 <HAL_DMA_IRQHandler+0x3088>
 800c96e:	687b      	ldr	r3, [r7, #4]
 800c970:	681b      	ldr	r3, [r3, #0]
 800c972:	4619      	mov	r1, r3
 800c974:	4b95      	ldr	r3, [pc, #596]	; (800cbcc <HAL_DMA_IRQHandler+0x3250>)
 800c976:	4299      	cmp	r1, r3
 800c978:	d041      	beq.n	800c9fe <HAL_DMA_IRQHandler+0x3082>
 800c97a:	687b      	ldr	r3, [r7, #4]
 800c97c:	681b      	ldr	r3, [r3, #0]
 800c97e:	4619      	mov	r1, r3
 800c980:	4b93      	ldr	r3, [pc, #588]	; (800cbd0 <HAL_DMA_IRQHandler+0x3254>)
 800c982:	4299      	cmp	r1, r3
 800c984:	d038      	beq.n	800c9f8 <HAL_DMA_IRQHandler+0x307c>
 800c986:	687b      	ldr	r3, [r7, #4]
 800c988:	681b      	ldr	r3, [r3, #0]
 800c98a:	4619      	mov	r1, r3
 800c98c:	4b91      	ldr	r3, [pc, #580]	; (800cbd4 <HAL_DMA_IRQHandler+0x3258>)
 800c98e:	4299      	cmp	r1, r3
 800c990:	d02f      	beq.n	800c9f2 <HAL_DMA_IRQHandler+0x3076>
 800c992:	687b      	ldr	r3, [r7, #4]
 800c994:	681b      	ldr	r3, [r3, #0]
 800c996:	4619      	mov	r1, r3
 800c998:	4b8f      	ldr	r3, [pc, #572]	; (800cbd8 <HAL_DMA_IRQHandler+0x325c>)
 800c99a:	4299      	cmp	r1, r3
 800c99c:	d026      	beq.n	800c9ec <HAL_DMA_IRQHandler+0x3070>
 800c99e:	687b      	ldr	r3, [r7, #4]
 800c9a0:	681b      	ldr	r3, [r3, #0]
 800c9a2:	4619      	mov	r1, r3
 800c9a4:	4b8d      	ldr	r3, [pc, #564]	; (800cbdc <HAL_DMA_IRQHandler+0x3260>)
 800c9a6:	4299      	cmp	r1, r3
 800c9a8:	d01d      	beq.n	800c9e6 <HAL_DMA_IRQHandler+0x306a>
 800c9aa:	687b      	ldr	r3, [r7, #4]
 800c9ac:	681b      	ldr	r3, [r3, #0]
 800c9ae:	4619      	mov	r1, r3
 800c9b0:	4b8b      	ldr	r3, [pc, #556]	; (800cbe0 <HAL_DMA_IRQHandler+0x3264>)
 800c9b2:	4299      	cmp	r1, r3
 800c9b4:	d014      	beq.n	800c9e0 <HAL_DMA_IRQHandler+0x3064>
 800c9b6:	687b      	ldr	r3, [r7, #4]
 800c9b8:	681b      	ldr	r3, [r3, #0]
 800c9ba:	4619      	mov	r1, r3
 800c9bc:	4b89      	ldr	r3, [pc, #548]	; (800cbe4 <HAL_DMA_IRQHandler+0x3268>)
 800c9be:	4299      	cmp	r1, r3
 800c9c0:	d00b      	beq.n	800c9da <HAL_DMA_IRQHandler+0x305e>
 800c9c2:	687b      	ldr	r3, [r7, #4]
 800c9c4:	681b      	ldr	r3, [r3, #0]
 800c9c6:	4619      	mov	r1, r3
 800c9c8:	4b87      	ldr	r3, [pc, #540]	; (800cbe8 <HAL_DMA_IRQHandler+0x326c>)
 800c9ca:	4299      	cmp	r1, r3
 800c9cc:	d102      	bne.n	800c9d4 <HAL_DMA_IRQHandler+0x3058>
 800c9ce:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c9d2:	e01e      	b.n	800ca12 <HAL_DMA_IRQHandler+0x3096>
 800c9d4:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800c9d8:	e01b      	b.n	800ca12 <HAL_DMA_IRQHandler+0x3096>
 800c9da:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c9de:	e018      	b.n	800ca12 <HAL_DMA_IRQHandler+0x3096>
 800c9e0:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c9e4:	e015      	b.n	800ca12 <HAL_DMA_IRQHandler+0x3096>
 800c9e6:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c9ea:	e012      	b.n	800ca12 <HAL_DMA_IRQHandler+0x3096>
 800c9ec:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c9f0:	e00f      	b.n	800ca12 <HAL_DMA_IRQHandler+0x3096>
 800c9f2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c9f6:	e00c      	b.n	800ca12 <HAL_DMA_IRQHandler+0x3096>
 800c9f8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c9fc:	e009      	b.n	800ca12 <HAL_DMA_IRQHandler+0x3096>
 800c9fe:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800ca02:	e006      	b.n	800ca12 <HAL_DMA_IRQHandler+0x3096>
 800ca04:	2320      	movs	r3, #32
 800ca06:	e004      	b.n	800ca12 <HAL_DMA_IRQHandler+0x3096>
 800ca08:	2320      	movs	r3, #32
 800ca0a:	e002      	b.n	800ca12 <HAL_DMA_IRQHandler+0x3096>
 800ca0c:	2320      	movs	r3, #32
 800ca0e:	e000      	b.n	800ca12 <HAL_DMA_IRQHandler+0x3096>
 800ca10:	2320      	movs	r3, #32
 800ca12:	6093      	str	r3, [r2, #8]
 800ca14:	e0ff      	b.n	800cc16 <HAL_DMA_IRQHandler+0x329a>
 800ca16:	687b      	ldr	r3, [r7, #4]
 800ca18:	681b      	ldr	r3, [r3, #0]
 800ca1a:	461a      	mov	r2, r3
 800ca1c:	4b73      	ldr	r3, [pc, #460]	; (800cbec <HAL_DMA_IRQHandler+0x3270>)
 800ca1e:	429a      	cmp	r2, r3
 800ca20:	d96c      	bls.n	800cafc <HAL_DMA_IRQHandler+0x3180>
 800ca22:	4a73      	ldr	r2, [pc, #460]	; (800cbf0 <HAL_DMA_IRQHandler+0x3274>)
 800ca24:	687b      	ldr	r3, [r7, #4]
 800ca26:	681b      	ldr	r3, [r3, #0]
 800ca28:	4619      	mov	r1, r3
 800ca2a:	4b64      	ldr	r3, [pc, #400]	; (800cbbc <HAL_DMA_IRQHandler+0x3240>)
 800ca2c:	4299      	cmp	r1, r3
 800ca2e:	d062      	beq.n	800caf6 <HAL_DMA_IRQHandler+0x317a>
 800ca30:	687b      	ldr	r3, [r7, #4]
 800ca32:	681b      	ldr	r3, [r3, #0]
 800ca34:	4619      	mov	r1, r3
 800ca36:	4b62      	ldr	r3, [pc, #392]	; (800cbc0 <HAL_DMA_IRQHandler+0x3244>)
 800ca38:	4299      	cmp	r1, r3
 800ca3a:	d05a      	beq.n	800caf2 <HAL_DMA_IRQHandler+0x3176>
 800ca3c:	687b      	ldr	r3, [r7, #4]
 800ca3e:	681b      	ldr	r3, [r3, #0]
 800ca40:	4619      	mov	r1, r3
 800ca42:	4b60      	ldr	r3, [pc, #384]	; (800cbc4 <HAL_DMA_IRQHandler+0x3248>)
 800ca44:	4299      	cmp	r1, r3
 800ca46:	d052      	beq.n	800caee <HAL_DMA_IRQHandler+0x3172>
 800ca48:	687b      	ldr	r3, [r7, #4]
 800ca4a:	681b      	ldr	r3, [r3, #0]
 800ca4c:	4619      	mov	r1, r3
 800ca4e:	4b5e      	ldr	r3, [pc, #376]	; (800cbc8 <HAL_DMA_IRQHandler+0x324c>)
 800ca50:	4299      	cmp	r1, r3
 800ca52:	d04a      	beq.n	800caea <HAL_DMA_IRQHandler+0x316e>
 800ca54:	687b      	ldr	r3, [r7, #4]
 800ca56:	681b      	ldr	r3, [r3, #0]
 800ca58:	4619      	mov	r1, r3
 800ca5a:	4b5c      	ldr	r3, [pc, #368]	; (800cbcc <HAL_DMA_IRQHandler+0x3250>)
 800ca5c:	4299      	cmp	r1, r3
 800ca5e:	d041      	beq.n	800cae4 <HAL_DMA_IRQHandler+0x3168>
 800ca60:	687b      	ldr	r3, [r7, #4]
 800ca62:	681b      	ldr	r3, [r3, #0]
 800ca64:	4619      	mov	r1, r3
 800ca66:	4b5a      	ldr	r3, [pc, #360]	; (800cbd0 <HAL_DMA_IRQHandler+0x3254>)
 800ca68:	4299      	cmp	r1, r3
 800ca6a:	d038      	beq.n	800cade <HAL_DMA_IRQHandler+0x3162>
 800ca6c:	687b      	ldr	r3, [r7, #4]
 800ca6e:	681b      	ldr	r3, [r3, #0]
 800ca70:	4619      	mov	r1, r3
 800ca72:	4b58      	ldr	r3, [pc, #352]	; (800cbd4 <HAL_DMA_IRQHandler+0x3258>)
 800ca74:	4299      	cmp	r1, r3
 800ca76:	d02f      	beq.n	800cad8 <HAL_DMA_IRQHandler+0x315c>
 800ca78:	687b      	ldr	r3, [r7, #4]
 800ca7a:	681b      	ldr	r3, [r3, #0]
 800ca7c:	4619      	mov	r1, r3
 800ca7e:	4b56      	ldr	r3, [pc, #344]	; (800cbd8 <HAL_DMA_IRQHandler+0x325c>)
 800ca80:	4299      	cmp	r1, r3
 800ca82:	d026      	beq.n	800cad2 <HAL_DMA_IRQHandler+0x3156>
 800ca84:	687b      	ldr	r3, [r7, #4]
 800ca86:	681b      	ldr	r3, [r3, #0]
 800ca88:	4619      	mov	r1, r3
 800ca8a:	4b54      	ldr	r3, [pc, #336]	; (800cbdc <HAL_DMA_IRQHandler+0x3260>)
 800ca8c:	4299      	cmp	r1, r3
 800ca8e:	d01d      	beq.n	800cacc <HAL_DMA_IRQHandler+0x3150>
 800ca90:	687b      	ldr	r3, [r7, #4]
 800ca92:	681b      	ldr	r3, [r3, #0]
 800ca94:	4619      	mov	r1, r3
 800ca96:	4b52      	ldr	r3, [pc, #328]	; (800cbe0 <HAL_DMA_IRQHandler+0x3264>)
 800ca98:	4299      	cmp	r1, r3
 800ca9a:	d014      	beq.n	800cac6 <HAL_DMA_IRQHandler+0x314a>
 800ca9c:	687b      	ldr	r3, [r7, #4]
 800ca9e:	681b      	ldr	r3, [r3, #0]
 800caa0:	4619      	mov	r1, r3
 800caa2:	4b50      	ldr	r3, [pc, #320]	; (800cbe4 <HAL_DMA_IRQHandler+0x3268>)
 800caa4:	4299      	cmp	r1, r3
 800caa6:	d00b      	beq.n	800cac0 <HAL_DMA_IRQHandler+0x3144>
 800caa8:	687b      	ldr	r3, [r7, #4]
 800caaa:	681b      	ldr	r3, [r3, #0]
 800caac:	4619      	mov	r1, r3
 800caae:	4b4e      	ldr	r3, [pc, #312]	; (800cbe8 <HAL_DMA_IRQHandler+0x326c>)
 800cab0:	4299      	cmp	r1, r3
 800cab2:	d102      	bne.n	800caba <HAL_DMA_IRQHandler+0x313e>
 800cab4:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cab8:	e01e      	b.n	800caf8 <HAL_DMA_IRQHandler+0x317c>
 800caba:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800cabe:	e01b      	b.n	800caf8 <HAL_DMA_IRQHandler+0x317c>
 800cac0:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cac4:	e018      	b.n	800caf8 <HAL_DMA_IRQHandler+0x317c>
 800cac6:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800caca:	e015      	b.n	800caf8 <HAL_DMA_IRQHandler+0x317c>
 800cacc:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cad0:	e012      	b.n	800caf8 <HAL_DMA_IRQHandler+0x317c>
 800cad2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cad6:	e00f      	b.n	800caf8 <HAL_DMA_IRQHandler+0x317c>
 800cad8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cadc:	e00c      	b.n	800caf8 <HAL_DMA_IRQHandler+0x317c>
 800cade:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cae2:	e009      	b.n	800caf8 <HAL_DMA_IRQHandler+0x317c>
 800cae4:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cae8:	e006      	b.n	800caf8 <HAL_DMA_IRQHandler+0x317c>
 800caea:	2320      	movs	r3, #32
 800caec:	e004      	b.n	800caf8 <HAL_DMA_IRQHandler+0x317c>
 800caee:	2320      	movs	r3, #32
 800caf0:	e002      	b.n	800caf8 <HAL_DMA_IRQHandler+0x317c>
 800caf2:	2320      	movs	r3, #32
 800caf4:	e000      	b.n	800caf8 <HAL_DMA_IRQHandler+0x317c>
 800caf6:	2320      	movs	r3, #32
 800caf8:	60d3      	str	r3, [r2, #12]
 800cafa:	e08c      	b.n	800cc16 <HAL_DMA_IRQHandler+0x329a>
 800cafc:	4a3c      	ldr	r2, [pc, #240]	; (800cbf0 <HAL_DMA_IRQHandler+0x3274>)
 800cafe:	687b      	ldr	r3, [r7, #4]
 800cb00:	681b      	ldr	r3, [r3, #0]
 800cb02:	4619      	mov	r1, r3
 800cb04:	4b2d      	ldr	r3, [pc, #180]	; (800cbbc <HAL_DMA_IRQHandler+0x3240>)
 800cb06:	4299      	cmp	r1, r3
 800cb08:	f000 8083 	beq.w	800cc12 <HAL_DMA_IRQHandler+0x3296>
 800cb0c:	687b      	ldr	r3, [r7, #4]
 800cb0e:	681b      	ldr	r3, [r3, #0]
 800cb10:	4619      	mov	r1, r3
 800cb12:	4b2b      	ldr	r3, [pc, #172]	; (800cbc0 <HAL_DMA_IRQHandler+0x3244>)
 800cb14:	4299      	cmp	r1, r3
 800cb16:	d07a      	beq.n	800cc0e <HAL_DMA_IRQHandler+0x3292>
 800cb18:	687b      	ldr	r3, [r7, #4]
 800cb1a:	681b      	ldr	r3, [r3, #0]
 800cb1c:	4619      	mov	r1, r3
 800cb1e:	4b29      	ldr	r3, [pc, #164]	; (800cbc4 <HAL_DMA_IRQHandler+0x3248>)
 800cb20:	4299      	cmp	r1, r3
 800cb22:	d072      	beq.n	800cc0a <HAL_DMA_IRQHandler+0x328e>
 800cb24:	687b      	ldr	r3, [r7, #4]
 800cb26:	681b      	ldr	r3, [r3, #0]
 800cb28:	4619      	mov	r1, r3
 800cb2a:	4b27      	ldr	r3, [pc, #156]	; (800cbc8 <HAL_DMA_IRQHandler+0x324c>)
 800cb2c:	4299      	cmp	r1, r3
 800cb2e:	d06a      	beq.n	800cc06 <HAL_DMA_IRQHandler+0x328a>
 800cb30:	687b      	ldr	r3, [r7, #4]
 800cb32:	681b      	ldr	r3, [r3, #0]
 800cb34:	4619      	mov	r1, r3
 800cb36:	4b25      	ldr	r3, [pc, #148]	; (800cbcc <HAL_DMA_IRQHandler+0x3250>)
 800cb38:	4299      	cmp	r1, r3
 800cb3a:	d061      	beq.n	800cc00 <HAL_DMA_IRQHandler+0x3284>
 800cb3c:	687b      	ldr	r3, [r7, #4]
 800cb3e:	681b      	ldr	r3, [r3, #0]
 800cb40:	4619      	mov	r1, r3
 800cb42:	4b23      	ldr	r3, [pc, #140]	; (800cbd0 <HAL_DMA_IRQHandler+0x3254>)
 800cb44:	4299      	cmp	r1, r3
 800cb46:	d058      	beq.n	800cbfa <HAL_DMA_IRQHandler+0x327e>
 800cb48:	687b      	ldr	r3, [r7, #4]
 800cb4a:	681b      	ldr	r3, [r3, #0]
 800cb4c:	4619      	mov	r1, r3
 800cb4e:	4b21      	ldr	r3, [pc, #132]	; (800cbd4 <HAL_DMA_IRQHandler+0x3258>)
 800cb50:	4299      	cmp	r1, r3
 800cb52:	d04f      	beq.n	800cbf4 <HAL_DMA_IRQHandler+0x3278>
 800cb54:	687b      	ldr	r3, [r7, #4]
 800cb56:	681b      	ldr	r3, [r3, #0]
 800cb58:	4619      	mov	r1, r3
 800cb5a:	4b1f      	ldr	r3, [pc, #124]	; (800cbd8 <HAL_DMA_IRQHandler+0x325c>)
 800cb5c:	4299      	cmp	r1, r3
 800cb5e:	d026      	beq.n	800cbae <HAL_DMA_IRQHandler+0x3232>
 800cb60:	687b      	ldr	r3, [r7, #4]
 800cb62:	681b      	ldr	r3, [r3, #0]
 800cb64:	4619      	mov	r1, r3
 800cb66:	4b1d      	ldr	r3, [pc, #116]	; (800cbdc <HAL_DMA_IRQHandler+0x3260>)
 800cb68:	4299      	cmp	r1, r3
 800cb6a:	d01d      	beq.n	800cba8 <HAL_DMA_IRQHandler+0x322c>
 800cb6c:	687b      	ldr	r3, [r7, #4]
 800cb6e:	681b      	ldr	r3, [r3, #0]
 800cb70:	4619      	mov	r1, r3
 800cb72:	4b1b      	ldr	r3, [pc, #108]	; (800cbe0 <HAL_DMA_IRQHandler+0x3264>)
 800cb74:	4299      	cmp	r1, r3
 800cb76:	d014      	beq.n	800cba2 <HAL_DMA_IRQHandler+0x3226>
 800cb78:	687b      	ldr	r3, [r7, #4]
 800cb7a:	681b      	ldr	r3, [r3, #0]
 800cb7c:	4619      	mov	r1, r3
 800cb7e:	4b19      	ldr	r3, [pc, #100]	; (800cbe4 <HAL_DMA_IRQHandler+0x3268>)
 800cb80:	4299      	cmp	r1, r3
 800cb82:	d00b      	beq.n	800cb9c <HAL_DMA_IRQHandler+0x3220>
 800cb84:	687b      	ldr	r3, [r7, #4]
 800cb86:	681b      	ldr	r3, [r3, #0]
 800cb88:	4619      	mov	r1, r3
 800cb8a:	4b17      	ldr	r3, [pc, #92]	; (800cbe8 <HAL_DMA_IRQHandler+0x326c>)
 800cb8c:	4299      	cmp	r1, r3
 800cb8e:	d102      	bne.n	800cb96 <HAL_DMA_IRQHandler+0x321a>
 800cb90:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cb94:	e03e      	b.n	800cc14 <HAL_DMA_IRQHandler+0x3298>
 800cb96:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800cb9a:	e03b      	b.n	800cc14 <HAL_DMA_IRQHandler+0x3298>
 800cb9c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cba0:	e038      	b.n	800cc14 <HAL_DMA_IRQHandler+0x3298>
 800cba2:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cba6:	e035      	b.n	800cc14 <HAL_DMA_IRQHandler+0x3298>
 800cba8:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800cbac:	e032      	b.n	800cc14 <HAL_DMA_IRQHandler+0x3298>
 800cbae:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cbb2:	e02f      	b.n	800cc14 <HAL_DMA_IRQHandler+0x3298>
 800cbb4:	400260b8 	.word	0x400260b8
 800cbb8:	40026400 	.word	0x40026400
 800cbbc:	40026010 	.word	0x40026010
 800cbc0:	40026410 	.word	0x40026410
 800cbc4:	40026070 	.word	0x40026070
 800cbc8:	40026470 	.word	0x40026470
 800cbcc:	40026028 	.word	0x40026028
 800cbd0:	40026428 	.word	0x40026428
 800cbd4:	40026088 	.word	0x40026088
 800cbd8:	40026488 	.word	0x40026488
 800cbdc:	40026040 	.word	0x40026040
 800cbe0:	40026440 	.word	0x40026440
 800cbe4:	400260a0 	.word	0x400260a0
 800cbe8:	400264a0 	.word	0x400264a0
 800cbec:	40026058 	.word	0x40026058
 800cbf0:	40026000 	.word	0x40026000
 800cbf4:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cbf8:	e00c      	b.n	800cc14 <HAL_DMA_IRQHandler+0x3298>
 800cbfa:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cbfe:	e009      	b.n	800cc14 <HAL_DMA_IRQHandler+0x3298>
 800cc00:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800cc04:	e006      	b.n	800cc14 <HAL_DMA_IRQHandler+0x3298>
 800cc06:	2320      	movs	r3, #32
 800cc08:	e004      	b.n	800cc14 <HAL_DMA_IRQHandler+0x3298>
 800cc0a:	2320      	movs	r3, #32
 800cc0c:	e002      	b.n	800cc14 <HAL_DMA_IRQHandler+0x3298>
 800cc0e:	2320      	movs	r3, #32
 800cc10:	e000      	b.n	800cc14 <HAL_DMA_IRQHandler+0x3298>
 800cc12:	2320      	movs	r3, #32
 800cc14:	6093      	str	r3, [r2, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_NONE;
 800cc16:	687b      	ldr	r3, [r7, #4]
 800cc18:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800cc1a:	687b      	ldr	r3, [r7, #4]
 800cc1c:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY_MEM0;
 800cc1e:	687b      	ldr	r3, [r7, #4]
 800cc20:	2211      	movs	r2, #17
 800cc22:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);      
 800cc26:	687b      	ldr	r3, [r7, #4]
 800cc28:	2200      	movs	r2, #0
 800cc2a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        if(hdma->XferCpltCallback != NULL)
 800cc2e:	687b      	ldr	r3, [r7, #4]
 800cc30:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800cc32:	2b00      	cmp	r3, #0
 800cc34:	d003      	beq.n	800cc3e <HAL_DMA_IRQHandler+0x32c2>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
 800cc36:	687b      	ldr	r3, [r7, #4]
 800cc38:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800cc3a:	6878      	ldr	r0, [r7, #4]
 800cc3c:	4798      	blx	r3
        }
      }
    }
  }
}
 800cc3e:	3708      	adds	r7, #8
 800cc40:	46bd      	mov	sp, r7
 800cc42:	bd80      	pop	{r7, pc}

0800cc44 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800cc44:	b480      	push	{r7}
 800cc46:	b089      	sub	sp, #36	; 0x24
 800cc48:	af00      	add	r7, sp, #0
 800cc4a:	6078      	str	r0, [r7, #4]
 800cc4c:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00;
 800cc4e:	2300      	movs	r3, #0
 800cc50:	61fb      	str	r3, [r7, #28]
  uint32_t ioposition = 0x00;
 800cc52:	2300      	movs	r3, #0
 800cc54:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00;
 800cc56:	2300      	movs	r3, #0
 800cc58:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00;
 800cc5a:	2300      	movs	r3, #0
 800cc5c:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 800cc5e:	2300      	movs	r3, #0
 800cc60:	61fb      	str	r3, [r7, #28]
 800cc62:	e171      	b.n	800cf48 <HAL_GPIO_Init+0x304>
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 800cc64:	69fb      	ldr	r3, [r7, #28]
 800cc66:	2201      	movs	r2, #1
 800cc68:	fa02 f303 	lsl.w	r3, r2, r3
 800cc6c:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 800cc6e:	683b      	ldr	r3, [r7, #0]
 800cc70:	681a      	ldr	r2, [r3, #0]
 800cc72:	697b      	ldr	r3, [r7, #20]
 800cc74:	4013      	ands	r3, r2
 800cc76:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
 800cc78:	693a      	ldr	r2, [r7, #16]
 800cc7a:	697b      	ldr	r3, [r7, #20]
 800cc7c:	429a      	cmp	r2, r3
 800cc7e:	f040 8160 	bne.w	800cf42 <HAL_GPIO_Init+0x2fe>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800cc82:	683b      	ldr	r3, [r7, #0]
 800cc84:	685b      	ldr	r3, [r3, #4]
 800cc86:	2b02      	cmp	r3, #2
 800cc88:	d003      	beq.n	800cc92 <HAL_GPIO_Init+0x4e>
 800cc8a:	683b      	ldr	r3, [r7, #0]
 800cc8c:	685b      	ldr	r3, [r3, #4]
 800cc8e:	2b12      	cmp	r3, #18
 800cc90:	d122      	bne.n	800ccd8 <HAL_GPIO_Init+0x94>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 800cc92:	69fb      	ldr	r3, [r7, #28]
 800cc94:	08da      	lsrs	r2, r3, #3
 800cc96:	687b      	ldr	r3, [r7, #4]
 800cc98:	3208      	adds	r2, #8
 800cc9a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800cc9e:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 800cca0:	69fb      	ldr	r3, [r7, #28]
 800cca2:	f003 0307 	and.w	r3, r3, #7
 800cca6:	009b      	lsls	r3, r3, #2
 800cca8:	461a      	mov	r2, r3
 800ccaa:	230f      	movs	r3, #15
 800ccac:	4093      	lsls	r3, r2
 800ccae:	43db      	mvns	r3, r3
 800ccb0:	69ba      	ldr	r2, [r7, #24]
 800ccb2:	4013      	ands	r3, r2
 800ccb4:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 800ccb6:	683b      	ldr	r3, [r7, #0]
 800ccb8:	691b      	ldr	r3, [r3, #16]
 800ccba:	69fa      	ldr	r2, [r7, #28]
 800ccbc:	f002 0207 	and.w	r2, r2, #7
 800ccc0:	0092      	lsls	r2, r2, #2
 800ccc2:	4093      	lsls	r3, r2
 800ccc4:	69ba      	ldr	r2, [r7, #24]
 800ccc6:	4313      	orrs	r3, r2
 800ccc8:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3] = temp;
 800ccca:	69fb      	ldr	r3, [r7, #28]
 800cccc:	08da      	lsrs	r2, r3, #3
 800ccce:	687b      	ldr	r3, [r7, #4]
 800ccd0:	3208      	adds	r2, #8
 800ccd2:	69b9      	ldr	r1, [r7, #24]
 800ccd4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800ccd8:	687b      	ldr	r3, [r7, #4]
 800ccda:	681b      	ldr	r3, [r3, #0]
 800ccdc:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 800ccde:	69fb      	ldr	r3, [r7, #28]
 800cce0:	005b      	lsls	r3, r3, #1
 800cce2:	461a      	mov	r2, r3
 800cce4:	2303      	movs	r3, #3
 800cce6:	4093      	lsls	r3, r2
 800cce8:	43db      	mvns	r3, r3
 800ccea:	69ba      	ldr	r2, [r7, #24]
 800ccec:	4013      	ands	r3, r2
 800ccee:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 800ccf0:	683b      	ldr	r3, [r7, #0]
 800ccf2:	685b      	ldr	r3, [r3, #4]
 800ccf4:	f003 0303 	and.w	r3, r3, #3
 800ccf8:	69fa      	ldr	r2, [r7, #28]
 800ccfa:	0052      	lsls	r2, r2, #1
 800ccfc:	4093      	lsls	r3, r2
 800ccfe:	69ba      	ldr	r2, [r7, #24]
 800cd00:	4313      	orrs	r3, r2
 800cd02:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 800cd04:	687b      	ldr	r3, [r7, #4]
 800cd06:	69ba      	ldr	r2, [r7, #24]
 800cd08:	601a      	str	r2, [r3, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800cd0a:	683b      	ldr	r3, [r7, #0]
 800cd0c:	685b      	ldr	r3, [r3, #4]
 800cd0e:	2b01      	cmp	r3, #1
 800cd10:	d00b      	beq.n	800cd2a <HAL_GPIO_Init+0xe6>
 800cd12:	683b      	ldr	r3, [r7, #0]
 800cd14:	685b      	ldr	r3, [r3, #4]
 800cd16:	2b02      	cmp	r3, #2
 800cd18:	d007      	beq.n	800cd2a <HAL_GPIO_Init+0xe6>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800cd1a:	683b      	ldr	r3, [r7, #0]
 800cd1c:	685b      	ldr	r3, [r3, #4]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800cd1e:	2b11      	cmp	r3, #17
 800cd20:	d003      	beq.n	800cd2a <HAL_GPIO_Init+0xe6>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800cd22:	683b      	ldr	r3, [r7, #0]
 800cd24:	685b      	ldr	r3, [r3, #4]
 800cd26:	2b12      	cmp	r3, #18
 800cd28:	d12f      	bne.n	800cd8a <HAL_GPIO_Init+0x146>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 800cd2a:	687b      	ldr	r3, [r7, #4]
 800cd2c:	689b      	ldr	r3, [r3, #8]
 800cd2e:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 800cd30:	69fb      	ldr	r3, [r7, #28]
 800cd32:	005b      	lsls	r3, r3, #1
 800cd34:	461a      	mov	r2, r3
 800cd36:	2303      	movs	r3, #3
 800cd38:	4093      	lsls	r3, r2
 800cd3a:	43db      	mvns	r3, r3
 800cd3c:	69ba      	ldr	r2, [r7, #24]
 800cd3e:	4013      	ands	r3, r2
 800cd40:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2));
 800cd42:	683b      	ldr	r3, [r7, #0]
 800cd44:	68db      	ldr	r3, [r3, #12]
 800cd46:	69fa      	ldr	r2, [r7, #28]
 800cd48:	0052      	lsls	r2, r2, #1
 800cd4a:	4093      	lsls	r3, r2
 800cd4c:	69ba      	ldr	r2, [r7, #24]
 800cd4e:	4313      	orrs	r3, r2
 800cd50:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 800cd52:	687b      	ldr	r3, [r7, #4]
 800cd54:	69ba      	ldr	r2, [r7, #24]
 800cd56:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 800cd58:	687b      	ldr	r3, [r7, #4]
 800cd5a:	685b      	ldr	r3, [r3, #4]
 800cd5c:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 800cd5e:	69fb      	ldr	r3, [r7, #28]
 800cd60:	2201      	movs	r2, #1
 800cd62:	fa02 f303 	lsl.w	r3, r2, r3
 800cd66:	43db      	mvns	r3, r3
 800cd68:	69ba      	ldr	r2, [r7, #24]
 800cd6a:	4013      	ands	r3, r2
 800cd6c:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 800cd6e:	683b      	ldr	r3, [r7, #0]
 800cd70:	685b      	ldr	r3, [r3, #4]
 800cd72:	f003 0310 	and.w	r3, r3, #16
 800cd76:	091a      	lsrs	r2, r3, #4
 800cd78:	69fb      	ldr	r3, [r7, #28]
 800cd7a:	fa02 f303 	lsl.w	r3, r2, r3
 800cd7e:	69ba      	ldr	r2, [r7, #24]
 800cd80:	4313      	orrs	r3, r2
 800cd82:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 800cd84:	687b      	ldr	r3, [r7, #4]
 800cd86:	69ba      	ldr	r2, [r7, #24]
 800cd88:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 800cd8a:	687b      	ldr	r3, [r7, #4]
 800cd8c:	68db      	ldr	r3, [r3, #12]
 800cd8e:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 800cd90:	69fb      	ldr	r3, [r7, #28]
 800cd92:	005b      	lsls	r3, r3, #1
 800cd94:	461a      	mov	r2, r3
 800cd96:	2303      	movs	r3, #3
 800cd98:	4093      	lsls	r3, r2
 800cd9a:	43db      	mvns	r3, r3
 800cd9c:	69ba      	ldr	r2, [r7, #24]
 800cd9e:	4013      	ands	r3, r2
 800cda0:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2));
 800cda2:	683b      	ldr	r3, [r7, #0]
 800cda4:	689b      	ldr	r3, [r3, #8]
 800cda6:	69fa      	ldr	r2, [r7, #28]
 800cda8:	0052      	lsls	r2, r2, #1
 800cdaa:	4093      	lsls	r3, r2
 800cdac:	69ba      	ldr	r2, [r7, #24]
 800cdae:	4313      	orrs	r3, r2
 800cdb0:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
 800cdb2:	687b      	ldr	r3, [r7, #4]
 800cdb4:	69ba      	ldr	r2, [r7, #24]
 800cdb6:	60da      	str	r2, [r3, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800cdb8:	683b      	ldr	r3, [r7, #0]
 800cdba:	685b      	ldr	r3, [r3, #4]
 800cdbc:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800cdc0:	2b00      	cmp	r3, #0
 800cdc2:	f000 80be 	beq.w	800cf42 <HAL_GPIO_Init+0x2fe>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800cdc6:	4a65      	ldr	r2, [pc, #404]	; (800cf5c <HAL_GPIO_Init+0x318>)
 800cdc8:	4b64      	ldr	r3, [pc, #400]	; (800cf5c <HAL_GPIO_Init+0x318>)
 800cdca:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800cdcc:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800cdd0:	6453      	str	r3, [r2, #68]	; 0x44
 800cdd2:	4b62      	ldr	r3, [pc, #392]	; (800cf5c <HAL_GPIO_Init+0x318>)
 800cdd4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800cdd6:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800cdda:	60fb      	str	r3, [r7, #12]
 800cddc:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2];
 800cdde:	4a60      	ldr	r2, [pc, #384]	; (800cf60 <HAL_GPIO_Init+0x31c>)
 800cde0:	69fb      	ldr	r3, [r7, #28]
 800cde2:	089b      	lsrs	r3, r3, #2
 800cde4:	3302      	adds	r3, #2
 800cde6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800cdea:	61bb      	str	r3, [r7, #24]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 800cdec:	69fb      	ldr	r3, [r7, #28]
 800cdee:	f003 0303 	and.w	r3, r3, #3
 800cdf2:	009b      	lsls	r3, r3, #2
 800cdf4:	461a      	mov	r2, r3
 800cdf6:	230f      	movs	r3, #15
 800cdf8:	4093      	lsls	r3, r2
 800cdfa:	43db      	mvns	r3, r3
 800cdfc:	69ba      	ldr	r2, [r7, #24]
 800cdfe:	4013      	ands	r3, r2
 800ce00:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 800ce02:	687b      	ldr	r3, [r7, #4]
 800ce04:	4a57      	ldr	r2, [pc, #348]	; (800cf64 <HAL_GPIO_Init+0x320>)
 800ce06:	4293      	cmp	r3, r2
 800ce08:	d037      	beq.n	800ce7a <HAL_GPIO_Init+0x236>
 800ce0a:	687b      	ldr	r3, [r7, #4]
 800ce0c:	4a56      	ldr	r2, [pc, #344]	; (800cf68 <HAL_GPIO_Init+0x324>)
 800ce0e:	4293      	cmp	r3, r2
 800ce10:	d031      	beq.n	800ce76 <HAL_GPIO_Init+0x232>
 800ce12:	687b      	ldr	r3, [r7, #4]
 800ce14:	4a55      	ldr	r2, [pc, #340]	; (800cf6c <HAL_GPIO_Init+0x328>)
 800ce16:	4293      	cmp	r3, r2
 800ce18:	d02b      	beq.n	800ce72 <HAL_GPIO_Init+0x22e>
 800ce1a:	687b      	ldr	r3, [r7, #4]
 800ce1c:	4a54      	ldr	r2, [pc, #336]	; (800cf70 <HAL_GPIO_Init+0x32c>)
 800ce1e:	4293      	cmp	r3, r2
 800ce20:	d025      	beq.n	800ce6e <HAL_GPIO_Init+0x22a>
 800ce22:	687b      	ldr	r3, [r7, #4]
 800ce24:	4a53      	ldr	r2, [pc, #332]	; (800cf74 <HAL_GPIO_Init+0x330>)
 800ce26:	4293      	cmp	r3, r2
 800ce28:	d01f      	beq.n	800ce6a <HAL_GPIO_Init+0x226>
 800ce2a:	687b      	ldr	r3, [r7, #4]
 800ce2c:	4a52      	ldr	r2, [pc, #328]	; (800cf78 <HAL_GPIO_Init+0x334>)
 800ce2e:	4293      	cmp	r3, r2
 800ce30:	d019      	beq.n	800ce66 <HAL_GPIO_Init+0x222>
 800ce32:	687b      	ldr	r3, [r7, #4]
 800ce34:	4a51      	ldr	r2, [pc, #324]	; (800cf7c <HAL_GPIO_Init+0x338>)
 800ce36:	4293      	cmp	r3, r2
 800ce38:	d013      	beq.n	800ce62 <HAL_GPIO_Init+0x21e>
 800ce3a:	687b      	ldr	r3, [r7, #4]
 800ce3c:	4a50      	ldr	r2, [pc, #320]	; (800cf80 <HAL_GPIO_Init+0x33c>)
 800ce3e:	4293      	cmp	r3, r2
 800ce40:	d00d      	beq.n	800ce5e <HAL_GPIO_Init+0x21a>
 800ce42:	687b      	ldr	r3, [r7, #4]
 800ce44:	4a4f      	ldr	r2, [pc, #316]	; (800cf84 <HAL_GPIO_Init+0x340>)
 800ce46:	4293      	cmp	r3, r2
 800ce48:	d007      	beq.n	800ce5a <HAL_GPIO_Init+0x216>
 800ce4a:	687b      	ldr	r3, [r7, #4]
 800ce4c:	4a4e      	ldr	r2, [pc, #312]	; (800cf88 <HAL_GPIO_Init+0x344>)
 800ce4e:	4293      	cmp	r3, r2
 800ce50:	d101      	bne.n	800ce56 <HAL_GPIO_Init+0x212>
 800ce52:	2309      	movs	r3, #9
 800ce54:	e012      	b.n	800ce7c <HAL_GPIO_Init+0x238>
 800ce56:	230a      	movs	r3, #10
 800ce58:	e010      	b.n	800ce7c <HAL_GPIO_Init+0x238>
 800ce5a:	2308      	movs	r3, #8
 800ce5c:	e00e      	b.n	800ce7c <HAL_GPIO_Init+0x238>
 800ce5e:	2307      	movs	r3, #7
 800ce60:	e00c      	b.n	800ce7c <HAL_GPIO_Init+0x238>
 800ce62:	2306      	movs	r3, #6
 800ce64:	e00a      	b.n	800ce7c <HAL_GPIO_Init+0x238>
 800ce66:	2305      	movs	r3, #5
 800ce68:	e008      	b.n	800ce7c <HAL_GPIO_Init+0x238>
 800ce6a:	2304      	movs	r3, #4
 800ce6c:	e006      	b.n	800ce7c <HAL_GPIO_Init+0x238>
 800ce6e:	2303      	movs	r3, #3
 800ce70:	e004      	b.n	800ce7c <HAL_GPIO_Init+0x238>
 800ce72:	2302      	movs	r3, #2
 800ce74:	e002      	b.n	800ce7c <HAL_GPIO_Init+0x238>
 800ce76:	2301      	movs	r3, #1
 800ce78:	e000      	b.n	800ce7c <HAL_GPIO_Init+0x238>
 800ce7a:	2300      	movs	r3, #0
 800ce7c:	69fa      	ldr	r2, [r7, #28]
 800ce7e:	f002 0203 	and.w	r2, r2, #3
 800ce82:	0092      	lsls	r2, r2, #2
 800ce84:	4093      	lsls	r3, r2
 800ce86:	69ba      	ldr	r2, [r7, #24]
 800ce88:	4313      	orrs	r3, r2
 800ce8a:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2] = temp;
 800ce8c:	4934      	ldr	r1, [pc, #208]	; (800cf60 <HAL_GPIO_Init+0x31c>)
 800ce8e:	69fb      	ldr	r3, [r7, #28]
 800ce90:	089b      	lsrs	r3, r3, #2
 800ce92:	3302      	adds	r3, #2
 800ce94:	69ba      	ldr	r2, [r7, #24]
 800ce96:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 800ce9a:	4b3c      	ldr	r3, [pc, #240]	; (800cf8c <HAL_GPIO_Init+0x348>)
 800ce9c:	681b      	ldr	r3, [r3, #0]
 800ce9e:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800cea0:	693b      	ldr	r3, [r7, #16]
 800cea2:	43db      	mvns	r3, r3
 800cea4:	69ba      	ldr	r2, [r7, #24]
 800cea6:	4013      	ands	r3, r2
 800cea8:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800ceaa:	683b      	ldr	r3, [r7, #0]
 800ceac:	685b      	ldr	r3, [r3, #4]
 800ceae:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800ceb2:	2b00      	cmp	r3, #0
 800ceb4:	d003      	beq.n	800cebe <HAL_GPIO_Init+0x27a>
        {
          temp |= iocurrent;
 800ceb6:	69ba      	ldr	r2, [r7, #24]
 800ceb8:	693b      	ldr	r3, [r7, #16]
 800ceba:	4313      	orrs	r3, r2
 800cebc:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
 800cebe:	4a33      	ldr	r2, [pc, #204]	; (800cf8c <HAL_GPIO_Init+0x348>)
 800cec0:	69bb      	ldr	r3, [r7, #24]
 800cec2:	6013      	str	r3, [r2, #0]

        temp = EXTI->EMR;
 800cec4:	4b31      	ldr	r3, [pc, #196]	; (800cf8c <HAL_GPIO_Init+0x348>)
 800cec6:	685b      	ldr	r3, [r3, #4]
 800cec8:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800ceca:	693b      	ldr	r3, [r7, #16]
 800cecc:	43db      	mvns	r3, r3
 800cece:	69ba      	ldr	r2, [r7, #24]
 800ced0:	4013      	ands	r3, r2
 800ced2:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800ced4:	683b      	ldr	r3, [r7, #0]
 800ced6:	685b      	ldr	r3, [r3, #4]
 800ced8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800cedc:	2b00      	cmp	r3, #0
 800cede:	d003      	beq.n	800cee8 <HAL_GPIO_Init+0x2a4>
        {
          temp |= iocurrent;
 800cee0:	69ba      	ldr	r2, [r7, #24]
 800cee2:	693b      	ldr	r3, [r7, #16]
 800cee4:	4313      	orrs	r3, r2
 800cee6:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
 800cee8:	4a28      	ldr	r2, [pc, #160]	; (800cf8c <HAL_GPIO_Init+0x348>)
 800ceea:	69bb      	ldr	r3, [r7, #24]
 800ceec:	6053      	str	r3, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800ceee:	4b27      	ldr	r3, [pc, #156]	; (800cf8c <HAL_GPIO_Init+0x348>)
 800cef0:	689b      	ldr	r3, [r3, #8]
 800cef2:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800cef4:	693b      	ldr	r3, [r7, #16]
 800cef6:	43db      	mvns	r3, r3
 800cef8:	69ba      	ldr	r2, [r7, #24]
 800cefa:	4013      	ands	r3, r2
 800cefc:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800cefe:	683b      	ldr	r3, [r7, #0]
 800cf00:	685b      	ldr	r3, [r3, #4]
 800cf02:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800cf06:	2b00      	cmp	r3, #0
 800cf08:	d003      	beq.n	800cf12 <HAL_GPIO_Init+0x2ce>
        {
          temp |= iocurrent;
 800cf0a:	69ba      	ldr	r2, [r7, #24]
 800cf0c:	693b      	ldr	r3, [r7, #16]
 800cf0e:	4313      	orrs	r3, r2
 800cf10:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
 800cf12:	4a1e      	ldr	r2, [pc, #120]	; (800cf8c <HAL_GPIO_Init+0x348>)
 800cf14:	69bb      	ldr	r3, [r7, #24]
 800cf16:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 800cf18:	4b1c      	ldr	r3, [pc, #112]	; (800cf8c <HAL_GPIO_Init+0x348>)
 800cf1a:	68db      	ldr	r3, [r3, #12]
 800cf1c:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800cf1e:	693b      	ldr	r3, [r7, #16]
 800cf20:	43db      	mvns	r3, r3
 800cf22:	69ba      	ldr	r2, [r7, #24]
 800cf24:	4013      	ands	r3, r2
 800cf26:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800cf28:	683b      	ldr	r3, [r7, #0]
 800cf2a:	685b      	ldr	r3, [r3, #4]
 800cf2c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800cf30:	2b00      	cmp	r3, #0
 800cf32:	d003      	beq.n	800cf3c <HAL_GPIO_Init+0x2f8>
        {
          temp |= iocurrent;
 800cf34:	69ba      	ldr	r2, [r7, #24]
 800cf36:	693b      	ldr	r3, [r7, #16]
 800cf38:	4313      	orrs	r3, r2
 800cf3a:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
 800cf3c:	4a13      	ldr	r2, [pc, #76]	; (800cf8c <HAL_GPIO_Init+0x348>)
 800cf3e:	69bb      	ldr	r3, [r7, #24]
 800cf40:	60d3      	str	r3, [r2, #12]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 800cf42:	69fb      	ldr	r3, [r7, #28]
 800cf44:	3301      	adds	r3, #1
 800cf46:	61fb      	str	r3, [r7, #28]
 800cf48:	69fb      	ldr	r3, [r7, #28]
 800cf4a:	2b0f      	cmp	r3, #15
 800cf4c:	f67f ae8a 	bls.w	800cc64 <HAL_GPIO_Init+0x20>
        }
        EXTI->FTSR = temp;
      }
    }
  }
}
 800cf50:	3724      	adds	r7, #36	; 0x24
 800cf52:	46bd      	mov	sp, r7
 800cf54:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf58:	4770      	bx	lr
 800cf5a:	bf00      	nop
 800cf5c:	40023800 	.word	0x40023800
 800cf60:	40013800 	.word	0x40013800
 800cf64:	40020000 	.word	0x40020000
 800cf68:	40020400 	.word	0x40020400
 800cf6c:	40020800 	.word	0x40020800
 800cf70:	40020c00 	.word	0x40020c00
 800cf74:	40021000 	.word	0x40021000
 800cf78:	40021400 	.word	0x40021400
 800cf7c:	40021800 	.word	0x40021800
 800cf80:	40021c00 	.word	0x40021c00
 800cf84:	40022000 	.word	0x40022000
 800cf88:	40022400 	.word	0x40022400
 800cf8c:	40013c00 	.word	0x40013c00

0800cf90 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 800cf90:	b480      	push	{r7}
 800cf92:	b087      	sub	sp, #28
 800cf94:	af00      	add	r7, sp, #0
 800cf96:	6078      	str	r0, [r7, #4]
 800cf98:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00;
 800cf9a:	2300      	movs	r3, #0
 800cf9c:	613b      	str	r3, [r7, #16]
  uint32_t iocurrent = 0x00;
 800cf9e:	2300      	movs	r3, #0
 800cfa0:	60fb      	str	r3, [r7, #12]
  uint32_t tmp = 0x00;
 800cfa2:	2300      	movs	r3, #0
 800cfa4:	60bb      	str	r3, [r7, #8]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  
  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 800cfa6:	2300      	movs	r3, #0
 800cfa8:	617b      	str	r3, [r7, #20]
 800cfaa:	e0da      	b.n	800d162 <HAL_GPIO_DeInit+0x1d2>
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 800cfac:	697b      	ldr	r3, [r7, #20]
 800cfae:	2201      	movs	r2, #1
 800cfb0:	fa02 f303 	lsl.w	r3, r2, r3
 800cfb4:	613b      	str	r3, [r7, #16]
    /* Get the current IO position */
    iocurrent = (GPIO_Pin) & ioposition;
 800cfb6:	683a      	ldr	r2, [r7, #0]
 800cfb8:	693b      	ldr	r3, [r7, #16]
 800cfba:	4013      	ands	r3, r2
 800cfbc:	60fb      	str	r3, [r7, #12]

    if(iocurrent == ioposition)
 800cfbe:	68fa      	ldr	r2, [r7, #12]
 800cfc0:	693b      	ldr	r3, [r7, #16]
 800cfc2:	429a      	cmp	r2, r3
 800cfc4:	f040 80ca 	bne.w	800d15c <HAL_GPIO_DeInit+0x1cc>
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO Direction in Input Floating Mode */
      GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2));
 800cfc8:	687b      	ldr	r3, [r7, #4]
 800cfca:	681a      	ldr	r2, [r3, #0]
 800cfcc:	697b      	ldr	r3, [r7, #20]
 800cfce:	005b      	lsls	r3, r3, #1
 800cfd0:	4619      	mov	r1, r3
 800cfd2:	2303      	movs	r3, #3
 800cfd4:	408b      	lsls	r3, r1
 800cfd6:	43db      	mvns	r3, r3
 800cfd8:	401a      	ands	r2, r3
 800cfda:	687b      	ldr	r3, [r7, #4]
 800cfdc:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 800cfde:	697b      	ldr	r3, [r7, #20]
 800cfe0:	08da      	lsrs	r2, r3, #3
 800cfe2:	697b      	ldr	r3, [r7, #20]
 800cfe4:	08d9      	lsrs	r1, r3, #3
 800cfe6:	687b      	ldr	r3, [r7, #4]
 800cfe8:	3108      	adds	r1, #8
 800cfea:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 800cfee:	697b      	ldr	r3, [r7, #20]
 800cff0:	f003 0307 	and.w	r3, r3, #7
 800cff4:	009b      	lsls	r3, r3, #2
 800cff6:	4618      	mov	r0, r3
 800cff8:	230f      	movs	r3, #15
 800cffa:	4083      	lsls	r3, r0
 800cffc:	43db      	mvns	r3, r3
 800cffe:	4019      	ands	r1, r3
 800d000:	687b      	ldr	r3, [r7, #4]
 800d002:	3208      	adds	r2, #8
 800d004:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 800d008:	687b      	ldr	r3, [r7, #4]
 800d00a:	689a      	ldr	r2, [r3, #8]
 800d00c:	697b      	ldr	r3, [r7, #20]
 800d00e:	005b      	lsls	r3, r3, #1
 800d010:	4619      	mov	r1, r3
 800d012:	2303      	movs	r3, #3
 800d014:	408b      	lsls	r3, r1
 800d016:	43db      	mvns	r3, r3
 800d018:	401a      	ands	r2, r3
 800d01a:	687b      	ldr	r3, [r7, #4]
 800d01c:	609a      	str	r2, [r3, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
 800d01e:	687b      	ldr	r3, [r7, #4]
 800d020:	685a      	ldr	r2, [r3, #4]
 800d022:	697b      	ldr	r3, [r7, #20]
 800d024:	2101      	movs	r1, #1
 800d026:	fa01 f303 	lsl.w	r3, r1, r3
 800d02a:	43db      	mvns	r3, r3
 800d02c:	401a      	ands	r2, r3
 800d02e:	687b      	ldr	r3, [r7, #4]
 800d030:	605a      	str	r2, [r3, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 800d032:	687b      	ldr	r3, [r7, #4]
 800d034:	68da      	ldr	r2, [r3, #12]
 800d036:	697b      	ldr	r3, [r7, #20]
 800d038:	005b      	lsls	r3, r3, #1
 800d03a:	4619      	mov	r1, r3
 800d03c:	2303      	movs	r3, #3
 800d03e:	408b      	lsls	r3, r1
 800d040:	43db      	mvns	r3, r3
 800d042:	401a      	ands	r2, r3
 800d044:	687b      	ldr	r3, [r7, #4]
 800d046:	60da      	str	r2, [r3, #12]

      /*------------------------- EXTI Mode Configuration --------------------*/
      tmp = SYSCFG->EXTICR[position >> 2];
 800d048:	4a4a      	ldr	r2, [pc, #296]	; (800d174 <HAL_GPIO_DeInit+0x1e4>)
 800d04a:	697b      	ldr	r3, [r7, #20]
 800d04c:	089b      	lsrs	r3, r3, #2
 800d04e:	3302      	adds	r3, #2
 800d050:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800d054:	60bb      	str	r3, [r7, #8]
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 800d056:	697b      	ldr	r3, [r7, #20]
 800d058:	f003 0303 	and.w	r3, r3, #3
 800d05c:	009b      	lsls	r3, r3, #2
 800d05e:	461a      	mov	r2, r3
 800d060:	230f      	movs	r3, #15
 800d062:	4093      	lsls	r3, r2
 800d064:	68ba      	ldr	r2, [r7, #8]
 800d066:	4013      	ands	r3, r2
 800d068:	60bb      	str	r3, [r7, #8]
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03))))
 800d06a:	687b      	ldr	r3, [r7, #4]
 800d06c:	4a42      	ldr	r2, [pc, #264]	; (800d178 <HAL_GPIO_DeInit+0x1e8>)
 800d06e:	4293      	cmp	r3, r2
 800d070:	d037      	beq.n	800d0e2 <HAL_GPIO_DeInit+0x152>
 800d072:	687b      	ldr	r3, [r7, #4]
 800d074:	4a41      	ldr	r2, [pc, #260]	; (800d17c <HAL_GPIO_DeInit+0x1ec>)
 800d076:	4293      	cmp	r3, r2
 800d078:	d031      	beq.n	800d0de <HAL_GPIO_DeInit+0x14e>
 800d07a:	687b      	ldr	r3, [r7, #4]
 800d07c:	4a40      	ldr	r2, [pc, #256]	; (800d180 <HAL_GPIO_DeInit+0x1f0>)
 800d07e:	4293      	cmp	r3, r2
 800d080:	d02b      	beq.n	800d0da <HAL_GPIO_DeInit+0x14a>
 800d082:	687b      	ldr	r3, [r7, #4]
 800d084:	4a3f      	ldr	r2, [pc, #252]	; (800d184 <HAL_GPIO_DeInit+0x1f4>)
 800d086:	4293      	cmp	r3, r2
 800d088:	d025      	beq.n	800d0d6 <HAL_GPIO_DeInit+0x146>
 800d08a:	687b      	ldr	r3, [r7, #4]
 800d08c:	4a3e      	ldr	r2, [pc, #248]	; (800d188 <HAL_GPIO_DeInit+0x1f8>)
 800d08e:	4293      	cmp	r3, r2
 800d090:	d01f      	beq.n	800d0d2 <HAL_GPIO_DeInit+0x142>
 800d092:	687b      	ldr	r3, [r7, #4]
 800d094:	4a3d      	ldr	r2, [pc, #244]	; (800d18c <HAL_GPIO_DeInit+0x1fc>)
 800d096:	4293      	cmp	r3, r2
 800d098:	d019      	beq.n	800d0ce <HAL_GPIO_DeInit+0x13e>
 800d09a:	687b      	ldr	r3, [r7, #4]
 800d09c:	4a3c      	ldr	r2, [pc, #240]	; (800d190 <HAL_GPIO_DeInit+0x200>)
 800d09e:	4293      	cmp	r3, r2
 800d0a0:	d013      	beq.n	800d0ca <HAL_GPIO_DeInit+0x13a>
 800d0a2:	687b      	ldr	r3, [r7, #4]
 800d0a4:	4a3b      	ldr	r2, [pc, #236]	; (800d194 <HAL_GPIO_DeInit+0x204>)
 800d0a6:	4293      	cmp	r3, r2
 800d0a8:	d00d      	beq.n	800d0c6 <HAL_GPIO_DeInit+0x136>
 800d0aa:	687b      	ldr	r3, [r7, #4]
 800d0ac:	4a3a      	ldr	r2, [pc, #232]	; (800d198 <HAL_GPIO_DeInit+0x208>)
 800d0ae:	4293      	cmp	r3, r2
 800d0b0:	d007      	beq.n	800d0c2 <HAL_GPIO_DeInit+0x132>
 800d0b2:	687b      	ldr	r3, [r7, #4]
 800d0b4:	4a39      	ldr	r2, [pc, #228]	; (800d19c <HAL_GPIO_DeInit+0x20c>)
 800d0b6:	4293      	cmp	r3, r2
 800d0b8:	d101      	bne.n	800d0be <HAL_GPIO_DeInit+0x12e>
 800d0ba:	2309      	movs	r3, #9
 800d0bc:	e012      	b.n	800d0e4 <HAL_GPIO_DeInit+0x154>
 800d0be:	230a      	movs	r3, #10
 800d0c0:	e010      	b.n	800d0e4 <HAL_GPIO_DeInit+0x154>
 800d0c2:	2308      	movs	r3, #8
 800d0c4:	e00e      	b.n	800d0e4 <HAL_GPIO_DeInit+0x154>
 800d0c6:	2307      	movs	r3, #7
 800d0c8:	e00c      	b.n	800d0e4 <HAL_GPIO_DeInit+0x154>
 800d0ca:	2306      	movs	r3, #6
 800d0cc:	e00a      	b.n	800d0e4 <HAL_GPIO_DeInit+0x154>
 800d0ce:	2305      	movs	r3, #5
 800d0d0:	e008      	b.n	800d0e4 <HAL_GPIO_DeInit+0x154>
 800d0d2:	2304      	movs	r3, #4
 800d0d4:	e006      	b.n	800d0e4 <HAL_GPIO_DeInit+0x154>
 800d0d6:	2303      	movs	r3, #3
 800d0d8:	e004      	b.n	800d0e4 <HAL_GPIO_DeInit+0x154>
 800d0da:	2302      	movs	r3, #2
 800d0dc:	e002      	b.n	800d0e4 <HAL_GPIO_DeInit+0x154>
 800d0de:	2301      	movs	r3, #1
 800d0e0:	e000      	b.n	800d0e4 <HAL_GPIO_DeInit+0x154>
 800d0e2:	2300      	movs	r3, #0
 800d0e4:	697a      	ldr	r2, [r7, #20]
 800d0e6:	f002 0203 	and.w	r2, r2, #3
 800d0ea:	0092      	lsls	r2, r2, #2
 800d0ec:	fa03 f202 	lsl.w	r2, r3, r2
 800d0f0:	68bb      	ldr	r3, [r7, #8]
 800d0f2:	429a      	cmp	r2, r3
 800d0f4:	d132      	bne.n	800d15c <HAL_GPIO_DeInit+0x1cc>
      {
        /* Configure the External Interrupt or event for the current IO */
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
 800d0f6:	697b      	ldr	r3, [r7, #20]
 800d0f8:	f003 0303 	and.w	r3, r3, #3
 800d0fc:	009b      	lsls	r3, r3, #2
 800d0fe:	461a      	mov	r2, r3
 800d100:	230f      	movs	r3, #15
 800d102:	4093      	lsls	r3, r2
 800d104:	60bb      	str	r3, [r7, #8]
        SYSCFG->EXTICR[position >> 2] &= ~tmp;
 800d106:	481b      	ldr	r0, [pc, #108]	; (800d174 <HAL_GPIO_DeInit+0x1e4>)
 800d108:	697b      	ldr	r3, [r7, #20]
 800d10a:	089b      	lsrs	r3, r3, #2
 800d10c:	4919      	ldr	r1, [pc, #100]	; (800d174 <HAL_GPIO_DeInit+0x1e4>)
 800d10e:	697a      	ldr	r2, [r7, #20]
 800d110:	0892      	lsrs	r2, r2, #2
 800d112:	3202      	adds	r2, #2
 800d114:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
 800d118:	68ba      	ldr	r2, [r7, #8]
 800d11a:	43d2      	mvns	r2, r2
 800d11c:	400a      	ands	r2, r1
 800d11e:	3302      	adds	r3, #2
 800d120:	f840 2023 	str.w	r2, [r0, r3, lsl #2]

        /* Clear EXTI line configuration */
        EXTI->IMR &= ~((uint32_t)iocurrent);
 800d124:	491e      	ldr	r1, [pc, #120]	; (800d1a0 <HAL_GPIO_DeInit+0x210>)
 800d126:	4b1e      	ldr	r3, [pc, #120]	; (800d1a0 <HAL_GPIO_DeInit+0x210>)
 800d128:	681a      	ldr	r2, [r3, #0]
 800d12a:	68fb      	ldr	r3, [r7, #12]
 800d12c:	43db      	mvns	r3, r3
 800d12e:	4013      	ands	r3, r2
 800d130:	600b      	str	r3, [r1, #0]
        EXTI->EMR &= ~((uint32_t)iocurrent);
 800d132:	491b      	ldr	r1, [pc, #108]	; (800d1a0 <HAL_GPIO_DeInit+0x210>)
 800d134:	4b1a      	ldr	r3, [pc, #104]	; (800d1a0 <HAL_GPIO_DeInit+0x210>)
 800d136:	685a      	ldr	r2, [r3, #4]
 800d138:	68fb      	ldr	r3, [r7, #12]
 800d13a:	43db      	mvns	r3, r3
 800d13c:	4013      	ands	r3, r2
 800d13e:	604b      	str	r3, [r1, #4]

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR &= ~((uint32_t)iocurrent);
 800d140:	4917      	ldr	r1, [pc, #92]	; (800d1a0 <HAL_GPIO_DeInit+0x210>)
 800d142:	4b17      	ldr	r3, [pc, #92]	; (800d1a0 <HAL_GPIO_DeInit+0x210>)
 800d144:	689a      	ldr	r2, [r3, #8]
 800d146:	68fb      	ldr	r3, [r7, #12]
 800d148:	43db      	mvns	r3, r3
 800d14a:	4013      	ands	r3, r2
 800d14c:	608b      	str	r3, [r1, #8]
        EXTI->FTSR &= ~((uint32_t)iocurrent);
 800d14e:	4914      	ldr	r1, [pc, #80]	; (800d1a0 <HAL_GPIO_DeInit+0x210>)
 800d150:	4b13      	ldr	r3, [pc, #76]	; (800d1a0 <HAL_GPIO_DeInit+0x210>)
 800d152:	68da      	ldr	r2, [r3, #12]
 800d154:	68fb      	ldr	r3, [r7, #12]
 800d156:	43db      	mvns	r3, r3
 800d158:	4013      	ands	r3, r2
 800d15a:	60cb      	str	r3, [r1, #12]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  
  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 800d15c:	697b      	ldr	r3, [r7, #20]
 800d15e:	3301      	adds	r3, #1
 800d160:	617b      	str	r3, [r7, #20]
 800d162:	697b      	ldr	r3, [r7, #20]
 800d164:	2b0f      	cmp	r3, #15
 800d166:	f67f af21 	bls.w	800cfac <HAL_GPIO_DeInit+0x1c>
        EXTI->RTSR &= ~((uint32_t)iocurrent);
        EXTI->FTSR &= ~((uint32_t)iocurrent);
	  }
    }
  }
}
 800d16a:	371c      	adds	r7, #28
 800d16c:	46bd      	mov	sp, r7
 800d16e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d172:	4770      	bx	lr
 800d174:	40013800 	.word	0x40013800
 800d178:	40020000 	.word	0x40020000
 800d17c:	40020400 	.word	0x40020400
 800d180:	40020800 	.word	0x40020800
 800d184:	40020c00 	.word	0x40020c00
 800d188:	40021000 	.word	0x40021000
 800d18c:	40021400 	.word	0x40021400
 800d190:	40021800 	.word	0x40021800
 800d194:	40021c00 	.word	0x40021c00
 800d198:	40022000 	.word	0x40022000
 800d19c:	40022400 	.word	0x40022400
 800d1a0:	40013c00 	.word	0x40013c00

0800d1a4 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 800d1a4:	b480      	push	{r7}
 800d1a6:	b083      	sub	sp, #12
 800d1a8:	af00      	add	r7, sp, #0
 800d1aa:	6078      	str	r0, [r7, #4]
 800d1ac:	460b      	mov	r3, r1
 800d1ae:	807b      	strh	r3, [r7, #2]
 800d1b0:	4613      	mov	r3, r2
 800d1b2:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 800d1b4:	787b      	ldrb	r3, [r7, #1]
 800d1b6:	2b00      	cmp	r3, #0
 800d1b8:	d003      	beq.n	800d1c2 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 800d1ba:	887a      	ldrh	r2, [r7, #2]
 800d1bc:	687b      	ldr	r3, [r7, #4]
 800d1be:	619a      	str	r2, [r3, #24]
 800d1c0:	e003      	b.n	800d1ca <HAL_GPIO_WritePin+0x26>
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 800d1c2:	887b      	ldrh	r3, [r7, #2]
 800d1c4:	041a      	lsls	r2, r3, #16
 800d1c6:	687b      	ldr	r3, [r7, #4]
 800d1c8:	619a      	str	r2, [r3, #24]
  }
}
 800d1ca:	370c      	adds	r7, #12
 800d1cc:	46bd      	mov	sp, r7
 800d1ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d1d2:	4770      	bx	lr

0800d1d4 <HAL_MspInit>:
/**
  * @brief  Initializes the Global MSP.
  * @retval None
  */
void HAL_MspInit(void)
{
 800d1d4:	b480      	push	{r7}
 800d1d6:	af00      	add	r7, sp, #0
  /* NOTE : This function is generated automatically by STM32CubeMX and eventually  
            modified by the user
   */ 
}
 800d1d8:	46bd      	mov	sp, r7
 800d1da:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d1de:	4770      	bx	lr

0800d1e0 <HAL_PWREx_EnableOverDrive>:
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
 800d1e0:	b580      	push	{r7, lr}
 800d1e2:	b082      	sub	sp, #8
 800d1e4:	af00      	add	r7, sp, #0
  uint32_t tickstart = 0;
 800d1e6:	2300      	movs	r3, #0
 800d1e8:	607b      	str	r3, [r7, #4]

  __HAL_RCC_PWR_CLK_ENABLE();
 800d1ea:	4a22      	ldr	r2, [pc, #136]	; (800d274 <HAL_PWREx_EnableOverDrive+0x94>)
 800d1ec:	4b21      	ldr	r3, [pc, #132]	; (800d274 <HAL_PWREx_EnableOverDrive+0x94>)
 800d1ee:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d1f0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800d1f4:	6413      	str	r3, [r2, #64]	; 0x40
 800d1f6:	4b1f      	ldr	r3, [pc, #124]	; (800d274 <HAL_PWREx_EnableOverDrive+0x94>)
 800d1f8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d1fa:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800d1fe:	603b      	str	r3, [r7, #0]
 800d200:	683b      	ldr	r3, [r7, #0]
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 800d202:	4a1d      	ldr	r2, [pc, #116]	; (800d278 <HAL_PWREx_EnableOverDrive+0x98>)
 800d204:	4b1c      	ldr	r3, [pc, #112]	; (800d278 <HAL_PWREx_EnableOverDrive+0x98>)
 800d206:	681b      	ldr	r3, [r3, #0]
 800d208:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800d20c:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 800d20e:	f7f9 f823 	bl	8006258 <HAL_GetTick>
 800d212:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 800d214:	e009      	b.n	800d22a <HAL_PWREx_EnableOverDrive+0x4a>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 800d216:	f7f9 f81f 	bl	8006258 <HAL_GetTick>
 800d21a:	4602      	mov	r2, r0
 800d21c:	687b      	ldr	r3, [r7, #4]
 800d21e:	1ad3      	subs	r3, r2, r3
 800d220:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800d224:	d901      	bls.n	800d22a <HAL_PWREx_EnableOverDrive+0x4a>
    {
      return HAL_TIMEOUT;
 800d226:	2303      	movs	r3, #3
 800d228:	e020      	b.n	800d26c <HAL_PWREx_EnableOverDrive+0x8c>
  __HAL_PWR_OVERDRIVE_ENABLE();

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 800d22a:	4b13      	ldr	r3, [pc, #76]	; (800d278 <HAL_PWREx_EnableOverDrive+0x98>)
 800d22c:	685b      	ldr	r3, [r3, #4]
 800d22e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800d232:	2b00      	cmp	r3, #0
 800d234:	d0ef      	beq.n	800d216 <HAL_PWREx_EnableOverDrive+0x36>
      return HAL_TIMEOUT;
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 800d236:	4a10      	ldr	r2, [pc, #64]	; (800d278 <HAL_PWREx_EnableOverDrive+0x98>)
 800d238:	4b0f      	ldr	r3, [pc, #60]	; (800d278 <HAL_PWREx_EnableOverDrive+0x98>)
 800d23a:	681b      	ldr	r3, [r3, #0]
 800d23c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800d240:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 800d242:	f7f9 f809 	bl	8006258 <HAL_GetTick>
 800d246:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 800d248:	e009      	b.n	800d25e <HAL_PWREx_EnableOverDrive+0x7e>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 800d24a:	f7f9 f805 	bl	8006258 <HAL_GetTick>
 800d24e:	4602      	mov	r2, r0
 800d250:	687b      	ldr	r3, [r7, #4]
 800d252:	1ad3      	subs	r3, r2, r3
 800d254:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800d258:	d901      	bls.n	800d25e <HAL_PWREx_EnableOverDrive+0x7e>
    {
      return HAL_TIMEOUT;
 800d25a:	2303      	movs	r3, #3
 800d25c:	e006      	b.n	800d26c <HAL_PWREx_EnableOverDrive+0x8c>
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 800d25e:	4b06      	ldr	r3, [pc, #24]	; (800d278 <HAL_PWREx_EnableOverDrive+0x98>)
 800d260:	685b      	ldr	r3, [r3, #4]
 800d262:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d266:	2b00      	cmp	r3, #0
 800d268:	d0ef      	beq.n	800d24a <HAL_PWREx_EnableOverDrive+0x6a>
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
 800d26a:	2300      	movs	r3, #0
}
 800d26c:	4618      	mov	r0, r3
 800d26e:	3708      	adds	r7, #8
 800d270:	46bd      	mov	sp, r7
 800d272:	bd80      	pop	{r7, pc}
 800d274:	40023800 	.word	0x40023800
 800d278:	40007000 	.word	0x40007000

0800d27c <HAL_RCC_OscConfig>:
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800d27c:	b580      	push	{r7, lr}
 800d27e:	b08e      	sub	sp, #56	; 0x38
 800d280:	af00      	add	r7, sp, #0
 800d282:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0;  
 800d284:	2300      	movs	r3, #0
 800d286:	637b      	str	r3, [r7, #52]	; 0x34
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800d288:	687b      	ldr	r3, [r7, #4]
 800d28a:	681b      	ldr	r3, [r3, #0]
 800d28c:	f003 0301 	and.w	r3, r3, #1
 800d290:	2b00      	cmp	r3, #0
 800d292:	f000 80ab 	beq.w	800d3ec <HAL_RCC_OscConfig+0x170>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 800d296:	4ba6      	ldr	r3, [pc, #664]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d298:	689b      	ldr	r3, [r3, #8]
 800d29a:	f003 030c 	and.w	r3, r3, #12
 800d29e:	2b04      	cmp	r3, #4
 800d2a0:	d00b      	beq.n	800d2ba <HAL_RCC_OscConfig+0x3e>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800d2a2:	4ba3      	ldr	r3, [pc, #652]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d2a4:	689b      	ldr	r3, [r3, #8]
 800d2a6:	f003 030c 	and.w	r3, r3, #12
 800d2aa:	2b08      	cmp	r3, #8
 800d2ac:	d112      	bne.n	800d2d4 <HAL_RCC_OscConfig+0x58>
 800d2ae:	4ba0      	ldr	r3, [pc, #640]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d2b0:	685b      	ldr	r3, [r3, #4]
 800d2b2:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800d2b6:	2b00      	cmp	r3, #0
 800d2b8:	d00c      	beq.n	800d2d4 <HAL_RCC_OscConfig+0x58>
    {
	  if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800d2ba:	4b9d      	ldr	r3, [pc, #628]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d2bc:	681b      	ldr	r3, [r3, #0]
 800d2be:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d2c2:	2b00      	cmp	r3, #0
 800d2c4:	d005      	beq.n	800d2d2 <HAL_RCC_OscConfig+0x56>
 800d2c6:	687b      	ldr	r3, [r7, #4]
 800d2c8:	685b      	ldr	r3, [r3, #4]
 800d2ca:	2b00      	cmp	r3, #0
 800d2cc:	d101      	bne.n	800d2d2 <HAL_RCC_OscConfig+0x56>
      {
        return HAL_ERROR;
 800d2ce:	2301      	movs	r3, #1
 800d2d0:	e2a3      	b.n	800d81a <HAL_RCC_OscConfig+0x59e>
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
    {
	  if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800d2d2:	e08b      	b.n	800d3ec <HAL_RCC_OscConfig+0x170>
      }
    }
    else
    {
      /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 800d2d4:	4a96      	ldr	r2, [pc, #600]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d2d6:	4b96      	ldr	r3, [pc, #600]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d2d8:	681b      	ldr	r3, [r3, #0]
 800d2da:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800d2de:	6013      	str	r3, [r2, #0]
 800d2e0:	4a93      	ldr	r2, [pc, #588]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d2e2:	4b93      	ldr	r3, [pc, #588]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d2e4:	681b      	ldr	r3, [r3, #0]
 800d2e6:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800d2ea:	6013      	str	r3, [r2, #0]
 800d2ec:	4a90      	ldr	r2, [pc, #576]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d2ee:	4b90      	ldr	r3, [pc, #576]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d2f0:	681b      	ldr	r3, [r3, #0]
 800d2f2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800d2f6:	6013      	str	r3, [r2, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800d2f8:	f7f8 ffae 	bl	8006258 <HAL_GetTick>
 800d2fc:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800d2fe:	e00a      	b.n	800d316 <HAL_RCC_OscConfig+0x9a>
      {
        if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800d300:	f7f8 ffaa 	bl	8006258 <HAL_GetTick>
 800d304:	4602      	mov	r2, r0
 800d306:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d308:	1ad3      	subs	r3, r2, r3
 800d30a:	f241 3288 	movw	r2, #5000	; 0x1388
 800d30e:	4293      	cmp	r3, r2
 800d310:	d901      	bls.n	800d316 <HAL_RCC_OscConfig+0x9a>
        {
          return HAL_TIMEOUT;
 800d312:	2303      	movs	r3, #3
 800d314:	e281      	b.n	800d81a <HAL_RCC_OscConfig+0x59e>
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800d316:	4b86      	ldr	r3, [pc, #536]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d318:	681b      	ldr	r3, [r3, #0]
 800d31a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d31e:	2b00      	cmp	r3, #0
 800d320:	d1ee      	bne.n	800d300 <HAL_RCC_OscConfig+0x84>
          return HAL_TIMEOUT;
        }
      }
      
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800d322:	4a83      	ldr	r2, [pc, #524]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d324:	4b82      	ldr	r3, [pc, #520]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d326:	681b      	ldr	r3, [r3, #0]
 800d328:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800d32c:	6013      	str	r3, [r2, #0]
 800d32e:	687b      	ldr	r3, [r7, #4]
 800d330:	685b      	ldr	r3, [r3, #4]
 800d332:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800d336:	d10c      	bne.n	800d352 <HAL_RCC_OscConfig+0xd6>
 800d338:	4a7d      	ldr	r2, [pc, #500]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d33a:	4b7d      	ldr	r3, [pc, #500]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d33c:	681b      	ldr	r3, [r3, #0]
 800d33e:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800d342:	6013      	str	r3, [r2, #0]
 800d344:	4a7a      	ldr	r2, [pc, #488]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d346:	4b7a      	ldr	r3, [pc, #488]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d348:	681b      	ldr	r3, [r3, #0]
 800d34a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800d34e:	6013      	str	r3, [r2, #0]
 800d350:	e01d      	b.n	800d38e <HAL_RCC_OscConfig+0x112>
 800d352:	687b      	ldr	r3, [r7, #4]
 800d354:	685b      	ldr	r3, [r3, #4]
 800d356:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 800d35a:	d10c      	bne.n	800d376 <HAL_RCC_OscConfig+0xfa>
 800d35c:	4a74      	ldr	r2, [pc, #464]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d35e:	4b74      	ldr	r3, [pc, #464]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d360:	681b      	ldr	r3, [r3, #0]
 800d362:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800d366:	6013      	str	r3, [r2, #0]
 800d368:	4a71      	ldr	r2, [pc, #452]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d36a:	4b71      	ldr	r3, [pc, #452]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d36c:	681b      	ldr	r3, [r3, #0]
 800d36e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800d372:	6013      	str	r3, [r2, #0]
 800d374:	e00b      	b.n	800d38e <HAL_RCC_OscConfig+0x112>
 800d376:	4a6e      	ldr	r2, [pc, #440]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d378:	4b6d      	ldr	r3, [pc, #436]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d37a:	681b      	ldr	r3, [r3, #0]
 800d37c:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800d380:	6013      	str	r3, [r2, #0]
 800d382:	4a6b      	ldr	r2, [pc, #428]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d384:	4b6a      	ldr	r3, [pc, #424]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d386:	681b      	ldr	r3, [r3, #0]
 800d388:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800d38c:	6013      	str	r3, [r2, #0]
      
      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800d38e:	687b      	ldr	r3, [r7, #4]
 800d390:	685b      	ldr	r3, [r3, #4]
 800d392:	2b00      	cmp	r3, #0
 800d394:	d015      	beq.n	800d3c2 <HAL_RCC_OscConfig+0x146>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d396:	f7f8 ff5f 	bl	8006258 <HAL_GetTick>
 800d39a:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800d39c:	e00a      	b.n	800d3b4 <HAL_RCC_OscConfig+0x138>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800d39e:	f7f8 ff5b 	bl	8006258 <HAL_GetTick>
 800d3a2:	4602      	mov	r2, r0
 800d3a4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d3a6:	1ad3      	subs	r3, r2, r3
 800d3a8:	f241 3288 	movw	r2, #5000	; 0x1388
 800d3ac:	4293      	cmp	r3, r2
 800d3ae:	d901      	bls.n	800d3b4 <HAL_RCC_OscConfig+0x138>
          {
            return HAL_TIMEOUT;
 800d3b0:	2303      	movs	r3, #3
 800d3b2:	e232      	b.n	800d81a <HAL_RCC_OscConfig+0x59e>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800d3b4:	4b5e      	ldr	r3, [pc, #376]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d3b6:	681b      	ldr	r3, [r3, #0]
 800d3b8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d3bc:	2b00      	cmp	r3, #0
 800d3be:	d0ee      	beq.n	800d39e <HAL_RCC_OscConfig+0x122>
 800d3c0:	e014      	b.n	800d3ec <HAL_RCC_OscConfig+0x170>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d3c2:	f7f8 ff49 	bl	8006258 <HAL_GetTick>
 800d3c6:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800d3c8:	e00a      	b.n	800d3e0 <HAL_RCC_OscConfig+0x164>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800d3ca:	f7f8 ff45 	bl	8006258 <HAL_GetTick>
 800d3ce:	4602      	mov	r2, r0
 800d3d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d3d2:	1ad3      	subs	r3, r2, r3
 800d3d4:	f241 3288 	movw	r2, #5000	; 0x1388
 800d3d8:	4293      	cmp	r3, r2
 800d3da:	d901      	bls.n	800d3e0 <HAL_RCC_OscConfig+0x164>
          {
            return HAL_TIMEOUT;
 800d3dc:	2303      	movs	r3, #3
 800d3de:	e21c      	b.n	800d81a <HAL_RCC_OscConfig+0x59e>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800d3e0:	4b53      	ldr	r3, [pc, #332]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d3e2:	681b      	ldr	r3, [r3, #0]
 800d3e4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d3e8:	2b00      	cmp	r3, #0
 800d3ea:	d1ee      	bne.n	800d3ca <HAL_RCC_OscConfig+0x14e>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800d3ec:	687b      	ldr	r3, [r7, #4]
 800d3ee:	681b      	ldr	r3, [r3, #0]
 800d3f0:	f003 0302 	and.w	r3, r3, #2
 800d3f4:	2b00      	cmp	r3, #0
 800d3f6:	d07d      	beq.n	800d4f4 <HAL_RCC_OscConfig+0x278>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 800d3f8:	4b4d      	ldr	r3, [pc, #308]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d3fa:	689b      	ldr	r3, [r3, #8]
 800d3fc:	f003 030c 	and.w	r3, r3, #12
 800d400:	2b00      	cmp	r3, #0
 800d402:	d00b      	beq.n	800d41c <HAL_RCC_OscConfig+0x1a0>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800d404:	4b4a      	ldr	r3, [pc, #296]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d406:	689b      	ldr	r3, [r3, #8]
 800d408:	f003 030c 	and.w	r3, r3, #12
 800d40c:	2b08      	cmp	r3, #8
 800d40e:	d126      	bne.n	800d45e <HAL_RCC_OscConfig+0x1e2>
 800d410:	4b47      	ldr	r3, [pc, #284]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d412:	685b      	ldr	r3, [r3, #4]
 800d414:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800d418:	2b00      	cmp	r3, #0
 800d41a:	d120      	bne.n	800d45e <HAL_RCC_OscConfig+0x1e2>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800d41c:	4b44      	ldr	r3, [pc, #272]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d41e:	681b      	ldr	r3, [r3, #0]
 800d420:	f003 0302 	and.w	r3, r3, #2
 800d424:	2b00      	cmp	r3, #0
 800d426:	d005      	beq.n	800d434 <HAL_RCC_OscConfig+0x1b8>
 800d428:	687b      	ldr	r3, [r7, #4]
 800d42a:	68db      	ldr	r3, [r3, #12]
 800d42c:	2b01      	cmp	r3, #1
 800d42e:	d001      	beq.n	800d434 <HAL_RCC_OscConfig+0x1b8>
      {
        return HAL_ERROR;
 800d430:	2301      	movs	r3, #1
 800d432:	e1f2      	b.n	800d81a <HAL_RCC_OscConfig+0x59e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800d434:	483e      	ldr	r0, [pc, #248]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d436:	4b3e      	ldr	r3, [pc, #248]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d438:	681b      	ldr	r3, [r3, #0]
 800d43a:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 800d43e:	687b      	ldr	r3, [r7, #4]
 800d440:	6919      	ldr	r1, [r3, #16]
 800d442:	23f8      	movs	r3, #248	; 0xf8
 800d444:	633b      	str	r3, [r7, #48]	; 0x30
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800d446:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d448:	fa93 f3a3 	rbit	r3, r3
 800d44c:	62fb      	str	r3, [r7, #44]	; 0x2c
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800d44e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d450:	fab3 f383 	clz	r3, r3
 800d454:	fa01 f303 	lsl.w	r3, r1, r3
 800d458:	4313      	orrs	r3, r2
 800d45a:	6003      	str	r3, [r0, #0]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800d45c:	e04a      	b.n	800d4f4 <HAL_RCC_OscConfig+0x278>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 800d45e:	687b      	ldr	r3, [r7, #4]
 800d460:	68db      	ldr	r3, [r3, #12]
 800d462:	2b00      	cmp	r3, #0
 800d464:	d02d      	beq.n	800d4c2 <HAL_RCC_OscConfig+0x246>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800d466:	4a32      	ldr	r2, [pc, #200]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d468:	4b31      	ldr	r3, [pc, #196]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d46a:	681b      	ldr	r3, [r3, #0]
 800d46c:	f043 0301 	orr.w	r3, r3, #1
 800d470:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d472:	f7f8 fef1 	bl	8006258 <HAL_GetTick>
 800d476:	6378      	str	r0, [r7, #52]	; 0x34

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800d478:	e008      	b.n	800d48c <HAL_RCC_OscConfig+0x210>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800d47a:	f7f8 feed 	bl	8006258 <HAL_GetTick>
 800d47e:	4602      	mov	r2, r0
 800d480:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d482:	1ad3      	subs	r3, r2, r3
 800d484:	2b64      	cmp	r3, #100	; 0x64
 800d486:	d901      	bls.n	800d48c <HAL_RCC_OscConfig+0x210>
          {
            return HAL_TIMEOUT;
 800d488:	2303      	movs	r3, #3
 800d48a:	e1c6      	b.n	800d81a <HAL_RCC_OscConfig+0x59e>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800d48c:	4b28      	ldr	r3, [pc, #160]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d48e:	681b      	ldr	r3, [r3, #0]
 800d490:	f003 0302 	and.w	r3, r3, #2
 800d494:	2b00      	cmp	r3, #0
 800d496:	d0f0      	beq.n	800d47a <HAL_RCC_OscConfig+0x1fe>
            return HAL_TIMEOUT;
          }
        }
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800d498:	4825      	ldr	r0, [pc, #148]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d49a:	4b25      	ldr	r3, [pc, #148]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d49c:	681b      	ldr	r3, [r3, #0]
 800d49e:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 800d4a2:	687b      	ldr	r3, [r7, #4]
 800d4a4:	6919      	ldr	r1, [r3, #16]
 800d4a6:	23f8      	movs	r3, #248	; 0xf8
 800d4a8:	62bb      	str	r3, [r7, #40]	; 0x28
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800d4aa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d4ac:	fa93 f3a3 	rbit	r3, r3
 800d4b0:	627b      	str	r3, [r7, #36]	; 0x24
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800d4b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d4b4:	fab3 f383 	clz	r3, r3
 800d4b8:	fa01 f303 	lsl.w	r3, r1, r3
 800d4bc:	4313      	orrs	r3, r2
 800d4be:	6003      	str	r3, [r0, #0]
 800d4c0:	e018      	b.n	800d4f4 <HAL_RCC_OscConfig+0x278>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800d4c2:	4a1b      	ldr	r2, [pc, #108]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d4c4:	4b1a      	ldr	r3, [pc, #104]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d4c6:	681b      	ldr	r3, [r3, #0]
 800d4c8:	f023 0301 	bic.w	r3, r3, #1
 800d4cc:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d4ce:	f7f8 fec3 	bl	8006258 <HAL_GetTick>
 800d4d2:	6378      	str	r0, [r7, #52]	; 0x34
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800d4d4:	e008      	b.n	800d4e8 <HAL_RCC_OscConfig+0x26c>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800d4d6:	f7f8 febf 	bl	8006258 <HAL_GetTick>
 800d4da:	4602      	mov	r2, r0
 800d4dc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d4de:	1ad3      	subs	r3, r2, r3
 800d4e0:	2b64      	cmp	r3, #100	; 0x64
 800d4e2:	d901      	bls.n	800d4e8 <HAL_RCC_OscConfig+0x26c>
          {
            return HAL_TIMEOUT;
 800d4e4:	2303      	movs	r3, #3
 800d4e6:	e198      	b.n	800d81a <HAL_RCC_OscConfig+0x59e>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800d4e8:	4b11      	ldr	r3, [pc, #68]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d4ea:	681b      	ldr	r3, [r3, #0]
 800d4ec:	f003 0302 	and.w	r3, r3, #2
 800d4f0:	2b00      	cmp	r3, #0
 800d4f2:	d1f0      	bne.n	800d4d6 <HAL_RCC_OscConfig+0x25a>
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800d4f4:	687b      	ldr	r3, [r7, #4]
 800d4f6:	681b      	ldr	r3, [r3, #0]
 800d4f8:	f003 0308 	and.w	r3, r3, #8
 800d4fc:	2b00      	cmp	r3, #0
 800d4fe:	d039      	beq.n	800d574 <HAL_RCC_OscConfig+0x2f8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 800d500:	687b      	ldr	r3, [r7, #4]
 800d502:	695b      	ldr	r3, [r3, #20]
 800d504:	2b00      	cmp	r3, #0
 800d506:	d01c      	beq.n	800d542 <HAL_RCC_OscConfig+0x2c6>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800d508:	4a09      	ldr	r2, [pc, #36]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d50a:	4b09      	ldr	r3, [pc, #36]	; (800d530 <HAL_RCC_OscConfig+0x2b4>)
 800d50c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800d50e:	f043 0301 	orr.w	r3, r3, #1
 800d512:	6753      	str	r3, [r2, #116]	; 0x74
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800d514:	f7f8 fea0 	bl	8006258 <HAL_GetTick>
 800d518:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800d51a:	e00b      	b.n	800d534 <HAL_RCC_OscConfig+0x2b8>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800d51c:	f7f8 fe9c 	bl	8006258 <HAL_GetTick>
 800d520:	4602      	mov	r2, r0
 800d522:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d524:	1ad3      	subs	r3, r2, r3
 800d526:	2b64      	cmp	r3, #100	; 0x64
 800d528:	d904      	bls.n	800d534 <HAL_RCC_OscConfig+0x2b8>
        {
          return HAL_TIMEOUT;
 800d52a:	2303      	movs	r3, #3
 800d52c:	e175      	b.n	800d81a <HAL_RCC_OscConfig+0x59e>
 800d52e:	bf00      	nop
 800d530:	40023800 	.word	0x40023800
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800d534:	4ba8      	ldr	r3, [pc, #672]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d536:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800d538:	f003 0302 	and.w	r3, r3, #2
 800d53c:	2b00      	cmp	r3, #0
 800d53e:	d0ed      	beq.n	800d51c <HAL_RCC_OscConfig+0x2a0>
 800d540:	e018      	b.n	800d574 <HAL_RCC_OscConfig+0x2f8>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 800d542:	4aa5      	ldr	r2, [pc, #660]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d544:	4ba4      	ldr	r3, [pc, #656]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d546:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800d548:	f023 0301 	bic.w	r3, r3, #1
 800d54c:	6753      	str	r3, [r2, #116]	; 0x74
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800d54e:	f7f8 fe83 	bl	8006258 <HAL_GetTick>
 800d552:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800d554:	e008      	b.n	800d568 <HAL_RCC_OscConfig+0x2ec>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800d556:	f7f8 fe7f 	bl	8006258 <HAL_GetTick>
 800d55a:	4602      	mov	r2, r0
 800d55c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d55e:	1ad3      	subs	r3, r2, r3
 800d560:	2b64      	cmp	r3, #100	; 0x64
 800d562:	d901      	bls.n	800d568 <HAL_RCC_OscConfig+0x2ec>
        {
          return HAL_TIMEOUT;
 800d564:	2303      	movs	r3, #3
 800d566:	e158      	b.n	800d81a <HAL_RCC_OscConfig+0x59e>
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800d568:	4b9b      	ldr	r3, [pc, #620]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d56a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800d56c:	f003 0302 	and.w	r3, r3, #2
 800d570:	2b00      	cmp	r3, #0
 800d572:	d1f0      	bne.n	800d556 <HAL_RCC_OscConfig+0x2da>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800d574:	687b      	ldr	r3, [r7, #4]
 800d576:	681b      	ldr	r3, [r3, #0]
 800d578:	f003 0304 	and.w	r3, r3, #4
 800d57c:	2b00      	cmp	r3, #0
 800d57e:	f000 80af 	beq.w	800d6e0 <HAL_RCC_OscConfig+0x464>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 800d582:	4a95      	ldr	r2, [pc, #596]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d584:	4b94      	ldr	r3, [pc, #592]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d586:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d588:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800d58c:	6413      	str	r3, [r2, #64]	; 0x40
 800d58e:	4b92      	ldr	r3, [pc, #584]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d590:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d592:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800d596:	60bb      	str	r3, [r7, #8]
 800d598:	68bb      	ldr	r3, [r7, #8]
    
    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 800d59a:	4a90      	ldr	r2, [pc, #576]	; (800d7dc <HAL_RCC_OscConfig+0x560>)
 800d59c:	4b8f      	ldr	r3, [pc, #572]	; (800d7dc <HAL_RCC_OscConfig+0x560>)
 800d59e:	681b      	ldr	r3, [r3, #0]
 800d5a0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800d5a4:	6013      	str	r3, [r2, #0]
    
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 800d5a6:	f7f8 fe57 	bl	8006258 <HAL_GetTick>
 800d5aa:	6378      	str	r0, [r7, #52]	; 0x34
    
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 800d5ac:	e008      	b.n	800d5c0 <HAL_RCC_OscConfig+0x344>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 800d5ae:	f7f8 fe53 	bl	8006258 <HAL_GetTick>
 800d5b2:	4602      	mov	r2, r0
 800d5b4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d5b6:	1ad3      	subs	r3, r2, r3
 800d5b8:	2b64      	cmp	r3, #100	; 0x64
 800d5ba:	d901      	bls.n	800d5c0 <HAL_RCC_OscConfig+0x344>
      {
        return HAL_TIMEOUT;
 800d5bc:	2303      	movs	r3, #3
 800d5be:	e12c      	b.n	800d81a <HAL_RCC_OscConfig+0x59e>
    PWR->CR1 |= PWR_CR1_DBP;
    
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 800d5c0:	4b86      	ldr	r3, [pc, #536]	; (800d7dc <HAL_RCC_OscConfig+0x560>)
 800d5c2:	681b      	ldr	r3, [r3, #0]
 800d5c4:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800d5c8:	2b00      	cmp	r3, #0
 800d5ca:	d0f0      	beq.n	800d5ae <HAL_RCC_OscConfig+0x332>
        return HAL_TIMEOUT;
      }      
    }
    
    /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 800d5cc:	4a82      	ldr	r2, [pc, #520]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d5ce:	4b82      	ldr	r3, [pc, #520]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d5d0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d5d2:	f023 0301 	bic.w	r3, r3, #1
 800d5d6:	6713      	str	r3, [r2, #112]	; 0x70
 800d5d8:	4a7f      	ldr	r2, [pc, #508]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d5da:	4b7f      	ldr	r3, [pc, #508]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d5dc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d5de:	f023 0304 	bic.w	r3, r3, #4
 800d5e2:	6713      	str	r3, [r2, #112]	; 0x70
 800d5e4:	4a7c      	ldr	r2, [pc, #496]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d5e6:	4b7c      	ldr	r3, [pc, #496]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d5e8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d5ea:	f023 0301 	bic.w	r3, r3, #1
 800d5ee:	6713      	str	r3, [r2, #112]	; 0x70
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800d5f0:	f7f8 fe32 	bl	8006258 <HAL_GetTick>
 800d5f4:	6378      	str	r0, [r7, #52]	; 0x34
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800d5f6:	e00a      	b.n	800d60e <HAL_RCC_OscConfig+0x392>
    {
      if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800d5f8:	f7f8 fe2e 	bl	8006258 <HAL_GetTick>
 800d5fc:	4602      	mov	r2, r0
 800d5fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d600:	1ad3      	subs	r3, r2, r3
 800d602:	f241 3288 	movw	r2, #5000	; 0x1388
 800d606:	4293      	cmp	r3, r2
 800d608:	d901      	bls.n	800d60e <HAL_RCC_OscConfig+0x392>
      {
        return HAL_TIMEOUT;
 800d60a:	2303      	movs	r3, #3
 800d60c:	e105      	b.n	800d81a <HAL_RCC_OscConfig+0x59e>
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800d60e:	4b72      	ldr	r3, [pc, #456]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d610:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d612:	f003 0302 	and.w	r3, r3, #2
 800d616:	2b00      	cmp	r3, #0
 800d618:	d1ee      	bne.n	800d5f8 <HAL_RCC_OscConfig+0x37c>
        return HAL_TIMEOUT;
      }    
    } 
    
    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800d61a:	4a6f      	ldr	r2, [pc, #444]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d61c:	4b6e      	ldr	r3, [pc, #440]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d61e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d620:	f023 0301 	bic.w	r3, r3, #1
 800d624:	6713      	str	r3, [r2, #112]	; 0x70
 800d626:	687b      	ldr	r3, [r7, #4]
 800d628:	689b      	ldr	r3, [r3, #8]
 800d62a:	2b01      	cmp	r3, #1
 800d62c:	d10c      	bne.n	800d648 <HAL_RCC_OscConfig+0x3cc>
 800d62e:	4a6a      	ldr	r2, [pc, #424]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d630:	4b69      	ldr	r3, [pc, #420]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d632:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d634:	f023 0304 	bic.w	r3, r3, #4
 800d638:	6713      	str	r3, [r2, #112]	; 0x70
 800d63a:	4a67      	ldr	r2, [pc, #412]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d63c:	4b66      	ldr	r3, [pc, #408]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d63e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d640:	f043 0301 	orr.w	r3, r3, #1
 800d644:	6713      	str	r3, [r2, #112]	; 0x70
 800d646:	e01c      	b.n	800d682 <HAL_RCC_OscConfig+0x406>
 800d648:	687b      	ldr	r3, [r7, #4]
 800d64a:	689b      	ldr	r3, [r3, #8]
 800d64c:	2b05      	cmp	r3, #5
 800d64e:	d10c      	bne.n	800d66a <HAL_RCC_OscConfig+0x3ee>
 800d650:	4a61      	ldr	r2, [pc, #388]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d652:	4b61      	ldr	r3, [pc, #388]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d654:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d656:	f043 0304 	orr.w	r3, r3, #4
 800d65a:	6713      	str	r3, [r2, #112]	; 0x70
 800d65c:	4a5e      	ldr	r2, [pc, #376]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d65e:	4b5e      	ldr	r3, [pc, #376]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d660:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d662:	f043 0301 	orr.w	r3, r3, #1
 800d666:	6713      	str	r3, [r2, #112]	; 0x70
 800d668:	e00b      	b.n	800d682 <HAL_RCC_OscConfig+0x406>
 800d66a:	4a5b      	ldr	r2, [pc, #364]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d66c:	4b5a      	ldr	r3, [pc, #360]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d66e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d670:	f023 0304 	bic.w	r3, r3, #4
 800d674:	6713      	str	r3, [r2, #112]	; 0x70
 800d676:	4a58      	ldr	r2, [pc, #352]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d678:	4b57      	ldr	r3, [pc, #348]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d67a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d67c:	f023 0301 	bic.w	r3, r3, #1
 800d680:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 800d682:	687b      	ldr	r3, [r7, #4]
 800d684:	689b      	ldr	r3, [r3, #8]
 800d686:	2b00      	cmp	r3, #0
 800d688:	d015      	beq.n	800d6b6 <HAL_RCC_OscConfig+0x43a>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800d68a:	f7f8 fde5 	bl	8006258 <HAL_GetTick>
 800d68e:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800d690:	e00a      	b.n	800d6a8 <HAL_RCC_OscConfig+0x42c>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800d692:	f7f8 fde1 	bl	8006258 <HAL_GetTick>
 800d696:	4602      	mov	r2, r0
 800d698:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d69a:	1ad3      	subs	r3, r2, r3
 800d69c:	f241 3288 	movw	r2, #5000	; 0x1388
 800d6a0:	4293      	cmp	r3, r2
 800d6a2:	d901      	bls.n	800d6a8 <HAL_RCC_OscConfig+0x42c>
        {
          return HAL_TIMEOUT;
 800d6a4:	2303      	movs	r3, #3
 800d6a6:	e0b8      	b.n	800d81a <HAL_RCC_OscConfig+0x59e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800d6a8:	4b4b      	ldr	r3, [pc, #300]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d6aa:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d6ac:	f003 0302 	and.w	r3, r3, #2
 800d6b0:	2b00      	cmp	r3, #0
 800d6b2:	d0ee      	beq.n	800d692 <HAL_RCC_OscConfig+0x416>
 800d6b4:	e014      	b.n	800d6e0 <HAL_RCC_OscConfig+0x464>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800d6b6:	f7f8 fdcf 	bl	8006258 <HAL_GetTick>
 800d6ba:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800d6bc:	e00a      	b.n	800d6d4 <HAL_RCC_OscConfig+0x458>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800d6be:	f7f8 fdcb 	bl	8006258 <HAL_GetTick>
 800d6c2:	4602      	mov	r2, r0
 800d6c4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d6c6:	1ad3      	subs	r3, r2, r3
 800d6c8:	f241 3288 	movw	r2, #5000	; 0x1388
 800d6cc:	4293      	cmp	r3, r2
 800d6ce:	d901      	bls.n	800d6d4 <HAL_RCC_OscConfig+0x458>
        {
          return HAL_TIMEOUT;
 800d6d0:	2303      	movs	r3, #3
 800d6d2:	e0a2      	b.n	800d81a <HAL_RCC_OscConfig+0x59e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800d6d4:	4b40      	ldr	r3, [pc, #256]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d6d6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d6d8:	f003 0302 	and.w	r3, r3, #2
 800d6dc:	2b00      	cmp	r3, #0
 800d6de:	d1ee      	bne.n	800d6be <HAL_RCC_OscConfig+0x442>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800d6e0:	687b      	ldr	r3, [r7, #4]
 800d6e2:	699b      	ldr	r3, [r3, #24]
 800d6e4:	2b00      	cmp	r3, #0
 800d6e6:	f000 8097 	beq.w	800d818 <HAL_RCC_OscConfig+0x59c>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800d6ea:	4b3b      	ldr	r3, [pc, #236]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d6ec:	689b      	ldr	r3, [r3, #8]
 800d6ee:	f003 030c 	and.w	r3, r3, #12
 800d6f2:	2b08      	cmp	r3, #8
 800d6f4:	f000 808e 	beq.w	800d814 <HAL_RCC_OscConfig+0x598>
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800d6f8:	687b      	ldr	r3, [r7, #4]
 800d6fa:	699b      	ldr	r3, [r3, #24]
 800d6fc:	2b02      	cmp	r3, #2
 800d6fe:	d16f      	bne.n	800d7e0 <HAL_RCC_OscConfig+0x564>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800d700:	4a35      	ldr	r2, [pc, #212]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d702:	4b35      	ldr	r3, [pc, #212]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d704:	681b      	ldr	r3, [r3, #0]
 800d706:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800d70a:	6013      	str	r3, [r2, #0]
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d70c:	f7f8 fda4 	bl	8006258 <HAL_GetTick>
 800d710:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800d712:	e008      	b.n	800d726 <HAL_RCC_OscConfig+0x4aa>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800d714:	f7f8 fda0 	bl	8006258 <HAL_GetTick>
 800d718:	4602      	mov	r2, r0
 800d71a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d71c:	1ad3      	subs	r3, r2, r3
 800d71e:	2b64      	cmp	r3, #100	; 0x64
 800d720:	d901      	bls.n	800d726 <HAL_RCC_OscConfig+0x4aa>
          {
            return HAL_TIMEOUT;
 800d722:	2303      	movs	r3, #3
 800d724:	e079      	b.n	800d81a <HAL_RCC_OscConfig+0x59e>
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800d726:	4b2c      	ldr	r3, [pc, #176]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d728:	681b      	ldr	r3, [r3, #0]
 800d72a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800d72e:	2b00      	cmp	r3, #0
 800d730:	d1f0      	bne.n	800d714 <HAL_RCC_OscConfig+0x498>
            return HAL_TIMEOUT;
          }
        }
        
        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800d732:	4829      	ldr	r0, [pc, #164]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d734:	687b      	ldr	r3, [r7, #4]
 800d736:	6a1a      	ldr	r2, [r3, #32]
 800d738:	687b      	ldr	r3, [r7, #4]
 800d73a:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800d73c:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800d740:	623b      	str	r3, [r7, #32]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800d742:	6a3b      	ldr	r3, [r7, #32]
 800d744:	fa93 f3a3 	rbit	r3, r3
 800d748:	61fb      	str	r3, [r7, #28]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800d74a:	69fb      	ldr	r3, [r7, #28]
 800d74c:	fab3 f383 	clz	r3, r3
 800d750:	fa01 f303 	lsl.w	r3, r1, r3
 800d754:	431a      	orrs	r2, r3
 800d756:	687b      	ldr	r3, [r7, #4]
 800d758:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d75a:	085b      	lsrs	r3, r3, #1
 800d75c:	1e59      	subs	r1, r3, #1
 800d75e:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 800d762:	61bb      	str	r3, [r7, #24]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800d764:	69bb      	ldr	r3, [r7, #24]
 800d766:	fa93 f3a3 	rbit	r3, r3
 800d76a:	617b      	str	r3, [r7, #20]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800d76c:	697b      	ldr	r3, [r7, #20]
 800d76e:	fab3 f383 	clz	r3, r3
 800d772:	fa01 f303 	lsl.w	r3, r1, r3
 800d776:	431a      	orrs	r2, r3
 800d778:	687b      	ldr	r3, [r7, #4]
 800d77a:	69db      	ldr	r3, [r3, #28]
 800d77c:	431a      	orrs	r2, r3
 800d77e:	687b      	ldr	r3, [r7, #4]
 800d780:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 800d782:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
 800d786:	613b      	str	r3, [r7, #16]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800d788:	693b      	ldr	r3, [r7, #16]
 800d78a:	fa93 f3a3 	rbit	r3, r3
 800d78e:	60fb      	str	r3, [r7, #12]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800d790:	68fb      	ldr	r3, [r7, #12]
 800d792:	fab3 f383 	clz	r3, r3
 800d796:	fa01 f303 	lsl.w	r3, r1, r3
 800d79a:	4313      	orrs	r3, r2
 800d79c:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800d7a0:	6043      	str	r3, [r0, #4]
                             RCC_OscInitStruct->PLL.PLLM,
                             RCC_OscInitStruct->PLL.PLLN,
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800d7a2:	4a0d      	ldr	r2, [pc, #52]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d7a4:	4b0c      	ldr	r3, [pc, #48]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d7a6:	681b      	ldr	r3, [r3, #0]
 800d7a8:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800d7ac:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d7ae:	f7f8 fd53 	bl	8006258 <HAL_GetTick>
 800d7b2:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800d7b4:	e008      	b.n	800d7c8 <HAL_RCC_OscConfig+0x54c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800d7b6:	f7f8 fd4f 	bl	8006258 <HAL_GetTick>
 800d7ba:	4602      	mov	r2, r0
 800d7bc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d7be:	1ad3      	subs	r3, r2, r3
 800d7c0:	2b64      	cmp	r3, #100	; 0x64
 800d7c2:	d901      	bls.n	800d7c8 <HAL_RCC_OscConfig+0x54c>
          {
            return HAL_TIMEOUT;
 800d7c4:	2303      	movs	r3, #3
 800d7c6:	e028      	b.n	800d81a <HAL_RCC_OscConfig+0x59e>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800d7c8:	4b03      	ldr	r3, [pc, #12]	; (800d7d8 <HAL_RCC_OscConfig+0x55c>)
 800d7ca:	681b      	ldr	r3, [r3, #0]
 800d7cc:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800d7d0:	2b00      	cmp	r3, #0
 800d7d2:	d0f0      	beq.n	800d7b6 <HAL_RCC_OscConfig+0x53a>
 800d7d4:	e020      	b.n	800d818 <HAL_RCC_OscConfig+0x59c>
 800d7d6:	bf00      	nop
 800d7d8:	40023800 	.word	0x40023800
 800d7dc:	40007000 	.word	0x40007000
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800d7e0:	4a10      	ldr	r2, [pc, #64]	; (800d824 <HAL_RCC_OscConfig+0x5a8>)
 800d7e2:	4b10      	ldr	r3, [pc, #64]	; (800d824 <HAL_RCC_OscConfig+0x5a8>)
 800d7e4:	681b      	ldr	r3, [r3, #0]
 800d7e6:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800d7ea:	6013      	str	r3, [r2, #0]
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d7ec:	f7f8 fd34 	bl	8006258 <HAL_GetTick>
 800d7f0:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800d7f2:	e008      	b.n	800d806 <HAL_RCC_OscConfig+0x58a>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800d7f4:	f7f8 fd30 	bl	8006258 <HAL_GetTick>
 800d7f8:	4602      	mov	r2, r0
 800d7fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d7fc:	1ad3      	subs	r3, r2, r3
 800d7fe:	2b64      	cmp	r3, #100	; 0x64
 800d800:	d901      	bls.n	800d806 <HAL_RCC_OscConfig+0x58a>
          {
            return HAL_TIMEOUT;
 800d802:	2303      	movs	r3, #3
 800d804:	e009      	b.n	800d81a <HAL_RCC_OscConfig+0x59e>
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800d806:	4b07      	ldr	r3, [pc, #28]	; (800d824 <HAL_RCC_OscConfig+0x5a8>)
 800d808:	681b      	ldr	r3, [r3, #0]
 800d80a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800d80e:	2b00      	cmp	r3, #0
 800d810:	d1f0      	bne.n	800d7f4 <HAL_RCC_OscConfig+0x578>
 800d812:	e001      	b.n	800d818 <HAL_RCC_OscConfig+0x59c>
        }
      }
    }
    else
    {
      return HAL_ERROR;
 800d814:	2301      	movs	r3, #1
 800d816:	e000      	b.n	800d81a <HAL_RCC_OscConfig+0x59e>
    }
  }
  return HAL_OK;
 800d818:	2300      	movs	r3, #0
}
 800d81a:	4618      	mov	r0, r3
 800d81c:	3738      	adds	r7, #56	; 0x38
 800d81e:	46bd      	mov	sp, r7
 800d820:	bd80      	pop	{r7, pc}
 800d822:	bf00      	nop
 800d824:	40023800 	.word	0x40023800

0800d828 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800d828:	b580      	push	{r7, lr}
 800d82a:	b084      	sub	sp, #16
 800d82c:	af00      	add	r7, sp, #0
 800d82e:	6078      	str	r0, [r7, #4]
 800d830:	6039      	str	r1, [r7, #0]
  uint32_t tickstart = 0;
 800d832:	2300      	movs	r3, #0
 800d834:	60fb      	str	r3, [r7, #12]
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
     must be correctly programmed according to the frequency of the CPU clock 
     (HCLK) and the supply voltage of the device. */
  
  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 800d836:	4b97      	ldr	r3, [pc, #604]	; (800da94 <HAL_RCC_ClockConfig+0x26c>)
 800d838:	681b      	ldr	r3, [r3, #0]
 800d83a:	f003 020f 	and.w	r2, r3, #15
 800d83e:	683b      	ldr	r3, [r7, #0]
 800d840:	429a      	cmp	r2, r3
 800d842:	f080 8094 	bcs.w	800d96e <HAL_RCC_ClockConfig+0x146>
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800d846:	4993      	ldr	r1, [pc, #588]	; (800da94 <HAL_RCC_ClockConfig+0x26c>)
 800d848:	4b92      	ldr	r3, [pc, #584]	; (800da94 <HAL_RCC_ClockConfig+0x26c>)
 800d84a:	681b      	ldr	r3, [r3, #0]
 800d84c:	f023 020f 	bic.w	r2, r3, #15
 800d850:	683b      	ldr	r3, [r7, #0]
 800d852:	4313      	orrs	r3, r2
 800d854:	600b      	str	r3, [r1, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 800d856:	4b8f      	ldr	r3, [pc, #572]	; (800da94 <HAL_RCC_ClockConfig+0x26c>)
 800d858:	681b      	ldr	r3, [r3, #0]
 800d85a:	f003 020f 	and.w	r2, r3, #15
 800d85e:	683b      	ldr	r3, [r7, #0]
 800d860:	429a      	cmp	r2, r3
 800d862:	d001      	beq.n	800d868 <HAL_RCC_ClockConfig+0x40>
    {
      return HAL_ERROR;
 800d864:	2301      	movs	r3, #1
 800d866:	e13c      	b.n	800dae2 <HAL_RCC_ClockConfig+0x2ba>
    }

    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800d868:	687b      	ldr	r3, [r7, #4]
 800d86a:	681b      	ldr	r3, [r3, #0]
 800d86c:	f003 0302 	and.w	r3, r3, #2
 800d870:	2b00      	cmp	r3, #0
 800d872:	d008      	beq.n	800d886 <HAL_RCC_ClockConfig+0x5e>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800d874:	4988      	ldr	r1, [pc, #544]	; (800da98 <HAL_RCC_ClockConfig+0x270>)
 800d876:	4b88      	ldr	r3, [pc, #544]	; (800da98 <HAL_RCC_ClockConfig+0x270>)
 800d878:	689b      	ldr	r3, [r3, #8]
 800d87a:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 800d87e:	687b      	ldr	r3, [r7, #4]
 800d880:	689b      	ldr	r3, [r3, #8]
 800d882:	4313      	orrs	r3, r2
 800d884:	608b      	str	r3, [r1, #8]
    }

    /*------------------------- SYSCLK Configuration ---------------------------*/ 
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800d886:	687b      	ldr	r3, [r7, #4]
 800d888:	681b      	ldr	r3, [r3, #0]
 800d88a:	f003 0301 	and.w	r3, r3, #1
 800d88e:	2b00      	cmp	r3, #0
 800d890:	f000 8104 	beq.w	800da9c <HAL_RCC_ClockConfig+0x274>
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800d894:	687b      	ldr	r3, [r7, #4]
 800d896:	685b      	ldr	r3, [r3, #4]
 800d898:	2b01      	cmp	r3, #1
 800d89a:	d107      	bne.n	800d8ac <HAL_RCC_ClockConfig+0x84>
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800d89c:	4b7e      	ldr	r3, [pc, #504]	; (800da98 <HAL_RCC_ClockConfig+0x270>)
 800d89e:	681b      	ldr	r3, [r3, #0]
 800d8a0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d8a4:	2b00      	cmp	r3, #0
 800d8a6:	d115      	bne.n	800d8d4 <HAL_RCC_ClockConfig+0xac>
        {
          return HAL_ERROR;
 800d8a8:	2301      	movs	r3, #1
 800d8aa:	e11a      	b.n	800dae2 <HAL_RCC_ClockConfig+0x2ba>
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800d8ac:	687b      	ldr	r3, [r7, #4]
 800d8ae:	685b      	ldr	r3, [r3, #4]
 800d8b0:	2b02      	cmp	r3, #2
 800d8b2:	d107      	bne.n	800d8c4 <HAL_RCC_ClockConfig+0x9c>
      {
        /* Check the PLL ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800d8b4:	4b78      	ldr	r3, [pc, #480]	; (800da98 <HAL_RCC_ClockConfig+0x270>)
 800d8b6:	681b      	ldr	r3, [r3, #0]
 800d8b8:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800d8bc:	2b00      	cmp	r3, #0
 800d8be:	d109      	bne.n	800d8d4 <HAL_RCC_ClockConfig+0xac>
        {
          return HAL_ERROR;
 800d8c0:	2301      	movs	r3, #1
 800d8c2:	e10e      	b.n	800dae2 <HAL_RCC_ClockConfig+0x2ba>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800d8c4:	4b74      	ldr	r3, [pc, #464]	; (800da98 <HAL_RCC_ClockConfig+0x270>)
 800d8c6:	681b      	ldr	r3, [r3, #0]
 800d8c8:	f003 0302 	and.w	r3, r3, #2
 800d8cc:	2b00      	cmp	r3, #0
 800d8ce:	d101      	bne.n	800d8d4 <HAL_RCC_ClockConfig+0xac>
        {
          return HAL_ERROR;
 800d8d0:	2301      	movs	r3, #1
 800d8d2:	e106      	b.n	800dae2 <HAL_RCC_ClockConfig+0x2ba>
        }
      }

      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800d8d4:	4970      	ldr	r1, [pc, #448]	; (800da98 <HAL_RCC_ClockConfig+0x270>)
 800d8d6:	4b70      	ldr	r3, [pc, #448]	; (800da98 <HAL_RCC_ClockConfig+0x270>)
 800d8d8:	689b      	ldr	r3, [r3, #8]
 800d8da:	f023 0203 	bic.w	r2, r3, #3
 800d8de:	687b      	ldr	r3, [r7, #4]
 800d8e0:	685b      	ldr	r3, [r3, #4]
 800d8e2:	4313      	orrs	r3, r2
 800d8e4:	608b      	str	r3, [r1, #8]
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800d8e6:	f7f8 fcb7 	bl	8006258 <HAL_GetTick>
 800d8ea:	60f8      	str	r0, [r7, #12]
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800d8ec:	687b      	ldr	r3, [r7, #4]
 800d8ee:	685b      	ldr	r3, [r3, #4]
 800d8f0:	2b01      	cmp	r3, #1
 800d8f2:	d112      	bne.n	800d91a <HAL_RCC_ClockConfig+0xf2>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800d8f4:	e00a      	b.n	800d90c <HAL_RCC_ClockConfig+0xe4>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800d8f6:	f7f8 fcaf 	bl	8006258 <HAL_GetTick>
 800d8fa:	4602      	mov	r2, r0
 800d8fc:	68fb      	ldr	r3, [r7, #12]
 800d8fe:	1ad3      	subs	r3, r2, r3
 800d900:	f241 3288 	movw	r2, #5000	; 0x1388
 800d904:	4293      	cmp	r3, r2
 800d906:	d901      	bls.n	800d90c <HAL_RCC_ClockConfig+0xe4>
          {
            return HAL_TIMEOUT;
 800d908:	2303      	movs	r3, #3
 800d90a:	e0ea      	b.n	800dae2 <HAL_RCC_ClockConfig+0x2ba>
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800d90c:	4b62      	ldr	r3, [pc, #392]	; (800da98 <HAL_RCC_ClockConfig+0x270>)
 800d90e:	689b      	ldr	r3, [r3, #8]
 800d910:	f003 030c 	and.w	r3, r3, #12
 800d914:	2b04      	cmp	r3, #4
 800d916:	d1ee      	bne.n	800d8f6 <HAL_RCC_ClockConfig+0xce>
 800d918:	e0c0      	b.n	800da9c <HAL_RCC_ClockConfig+0x274>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800d91a:	687b      	ldr	r3, [r7, #4]
 800d91c:	685b      	ldr	r3, [r3, #4]
 800d91e:	2b02      	cmp	r3, #2
 800d920:	d112      	bne.n	800d948 <HAL_RCC_ClockConfig+0x120>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800d922:	e00a      	b.n	800d93a <HAL_RCC_ClockConfig+0x112>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800d924:	f7f8 fc98 	bl	8006258 <HAL_GetTick>
 800d928:	4602      	mov	r2, r0
 800d92a:	68fb      	ldr	r3, [r7, #12]
 800d92c:	1ad3      	subs	r3, r2, r3
 800d92e:	f241 3288 	movw	r2, #5000	; 0x1388
 800d932:	4293      	cmp	r3, r2
 800d934:	d901      	bls.n	800d93a <HAL_RCC_ClockConfig+0x112>
          {
            return HAL_TIMEOUT;
 800d936:	2303      	movs	r3, #3
 800d938:	e0d3      	b.n	800dae2 <HAL_RCC_ClockConfig+0x2ba>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800d93a:	4b57      	ldr	r3, [pc, #348]	; (800da98 <HAL_RCC_ClockConfig+0x270>)
 800d93c:	689b      	ldr	r3, [r3, #8]
 800d93e:	f003 030c 	and.w	r3, r3, #12
 800d942:	2b08      	cmp	r3, #8
 800d944:	d1ee      	bne.n	800d924 <HAL_RCC_ClockConfig+0xfc>
 800d946:	e0a9      	b.n	800da9c <HAL_RCC_ClockConfig+0x274>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800d948:	e00a      	b.n	800d960 <HAL_RCC_ClockConfig+0x138>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800d94a:	f7f8 fc85 	bl	8006258 <HAL_GetTick>
 800d94e:	4602      	mov	r2, r0
 800d950:	68fb      	ldr	r3, [r7, #12]
 800d952:	1ad3      	subs	r3, r2, r3
 800d954:	f241 3288 	movw	r2, #5000	; 0x1388
 800d958:	4293      	cmp	r3, r2
 800d95a:	d901      	bls.n	800d960 <HAL_RCC_ClockConfig+0x138>
          {
            return HAL_TIMEOUT;
 800d95c:	2303      	movs	r3, #3
 800d95e:	e0c0      	b.n	800dae2 <HAL_RCC_ClockConfig+0x2ba>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800d960:	4b4d      	ldr	r3, [pc, #308]	; (800da98 <HAL_RCC_ClockConfig+0x270>)
 800d962:	689b      	ldr	r3, [r3, #8]
 800d964:	f003 030c 	and.w	r3, r3, #12
 800d968:	2b00      	cmp	r3, #0
 800d96a:	d1ee      	bne.n	800d94a <HAL_RCC_ClockConfig+0x122>
 800d96c:	e096      	b.n	800da9c <HAL_RCC_ClockConfig+0x274>
  }
  /* Decreasing the CPU frequency */
  else
  {
    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800d96e:	687b      	ldr	r3, [r7, #4]
 800d970:	681b      	ldr	r3, [r3, #0]
 800d972:	f003 0302 	and.w	r3, r3, #2
 800d976:	2b00      	cmp	r3, #0
 800d978:	d008      	beq.n	800d98c <HAL_RCC_ClockConfig+0x164>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800d97a:	4947      	ldr	r1, [pc, #284]	; (800da98 <HAL_RCC_ClockConfig+0x270>)
 800d97c:	4b46      	ldr	r3, [pc, #280]	; (800da98 <HAL_RCC_ClockConfig+0x270>)
 800d97e:	689b      	ldr	r3, [r3, #8]
 800d980:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 800d984:	687b      	ldr	r3, [r7, #4]
 800d986:	689b      	ldr	r3, [r3, #8]
 800d988:	4313      	orrs	r3, r2
 800d98a:	608b      	str	r3, [r1, #8]
    }

    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800d98c:	687b      	ldr	r3, [r7, #4]
 800d98e:	681b      	ldr	r3, [r3, #0]
 800d990:	f003 0301 	and.w	r3, r3, #1
 800d994:	2b00      	cmp	r3, #0
 800d996:	d06b      	beq.n	800da70 <HAL_RCC_ClockConfig+0x248>
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800d998:	687b      	ldr	r3, [r7, #4]
 800d99a:	685b      	ldr	r3, [r3, #4]
 800d99c:	2b01      	cmp	r3, #1
 800d99e:	d107      	bne.n	800d9b0 <HAL_RCC_ClockConfig+0x188>
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800d9a0:	4b3d      	ldr	r3, [pc, #244]	; (800da98 <HAL_RCC_ClockConfig+0x270>)
 800d9a2:	681b      	ldr	r3, [r3, #0]
 800d9a4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d9a8:	2b00      	cmp	r3, #0
 800d9aa:	d115      	bne.n	800d9d8 <HAL_RCC_ClockConfig+0x1b0>
        {
          return HAL_ERROR;
 800d9ac:	2301      	movs	r3, #1
 800d9ae:	e098      	b.n	800dae2 <HAL_RCC_ClockConfig+0x2ba>
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800d9b0:	687b      	ldr	r3, [r7, #4]
 800d9b2:	685b      	ldr	r3, [r3, #4]
 800d9b4:	2b02      	cmp	r3, #2
 800d9b6:	d107      	bne.n	800d9c8 <HAL_RCC_ClockConfig+0x1a0>
      {
        /* Check the PLL ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800d9b8:	4b37      	ldr	r3, [pc, #220]	; (800da98 <HAL_RCC_ClockConfig+0x270>)
 800d9ba:	681b      	ldr	r3, [r3, #0]
 800d9bc:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800d9c0:	2b00      	cmp	r3, #0
 800d9c2:	d109      	bne.n	800d9d8 <HAL_RCC_ClockConfig+0x1b0>
        {
          return HAL_ERROR;
 800d9c4:	2301      	movs	r3, #1
 800d9c6:	e08c      	b.n	800dae2 <HAL_RCC_ClockConfig+0x2ba>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800d9c8:	4b33      	ldr	r3, [pc, #204]	; (800da98 <HAL_RCC_ClockConfig+0x270>)
 800d9ca:	681b      	ldr	r3, [r3, #0]
 800d9cc:	f003 0302 	and.w	r3, r3, #2
 800d9d0:	2b00      	cmp	r3, #0
 800d9d2:	d101      	bne.n	800d9d8 <HAL_RCC_ClockConfig+0x1b0>
        {
          return HAL_ERROR;
 800d9d4:	2301      	movs	r3, #1
 800d9d6:	e084      	b.n	800dae2 <HAL_RCC_ClockConfig+0x2ba>
        }
      }
      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800d9d8:	492f      	ldr	r1, [pc, #188]	; (800da98 <HAL_RCC_ClockConfig+0x270>)
 800d9da:	4b2f      	ldr	r3, [pc, #188]	; (800da98 <HAL_RCC_ClockConfig+0x270>)
 800d9dc:	689b      	ldr	r3, [r3, #8]
 800d9de:	f023 0203 	bic.w	r2, r3, #3
 800d9e2:	687b      	ldr	r3, [r7, #4]
 800d9e4:	685b      	ldr	r3, [r3, #4]
 800d9e6:	4313      	orrs	r3, r2
 800d9e8:	608b      	str	r3, [r1, #8]
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800d9ea:	f7f8 fc35 	bl	8006258 <HAL_GetTick>
 800d9ee:	60f8      	str	r0, [r7, #12]
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800d9f0:	687b      	ldr	r3, [r7, #4]
 800d9f2:	685b      	ldr	r3, [r3, #4]
 800d9f4:	2b01      	cmp	r3, #1
 800d9f6:	d112      	bne.n	800da1e <HAL_RCC_ClockConfig+0x1f6>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800d9f8:	e00a      	b.n	800da10 <HAL_RCC_ClockConfig+0x1e8>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800d9fa:	f7f8 fc2d 	bl	8006258 <HAL_GetTick>
 800d9fe:	4602      	mov	r2, r0
 800da00:	68fb      	ldr	r3, [r7, #12]
 800da02:	1ad3      	subs	r3, r2, r3
 800da04:	f241 3288 	movw	r2, #5000	; 0x1388
 800da08:	4293      	cmp	r3, r2
 800da0a:	d901      	bls.n	800da10 <HAL_RCC_ClockConfig+0x1e8>
          {
            return HAL_TIMEOUT;
 800da0c:	2303      	movs	r3, #3
 800da0e:	e068      	b.n	800dae2 <HAL_RCC_ClockConfig+0x2ba>
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800da10:	4b21      	ldr	r3, [pc, #132]	; (800da98 <HAL_RCC_ClockConfig+0x270>)
 800da12:	689b      	ldr	r3, [r3, #8]
 800da14:	f003 030c 	and.w	r3, r3, #12
 800da18:	2b04      	cmp	r3, #4
 800da1a:	d1ee      	bne.n	800d9fa <HAL_RCC_ClockConfig+0x1d2>
 800da1c:	e028      	b.n	800da70 <HAL_RCC_ClockConfig+0x248>
          {
            return HAL_TIMEOUT;
          } 
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800da1e:	687b      	ldr	r3, [r7, #4]
 800da20:	685b      	ldr	r3, [r3, #4]
 800da22:	2b02      	cmp	r3, #2
 800da24:	d112      	bne.n	800da4c <HAL_RCC_ClockConfig+0x224>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800da26:	e00a      	b.n	800da3e <HAL_RCC_ClockConfig+0x216>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800da28:	f7f8 fc16 	bl	8006258 <HAL_GetTick>
 800da2c:	4602      	mov	r2, r0
 800da2e:	68fb      	ldr	r3, [r7, #12]
 800da30:	1ad3      	subs	r3, r2, r3
 800da32:	f241 3288 	movw	r2, #5000	; 0x1388
 800da36:	4293      	cmp	r3, r2
 800da38:	d901      	bls.n	800da3e <HAL_RCC_ClockConfig+0x216>
          {
            return HAL_TIMEOUT;
 800da3a:	2303      	movs	r3, #3
 800da3c:	e051      	b.n	800dae2 <HAL_RCC_ClockConfig+0x2ba>
          } 
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800da3e:	4b16      	ldr	r3, [pc, #88]	; (800da98 <HAL_RCC_ClockConfig+0x270>)
 800da40:	689b      	ldr	r3, [r3, #8]
 800da42:	f003 030c 	and.w	r3, r3, #12
 800da46:	2b08      	cmp	r3, #8
 800da48:	d1ee      	bne.n	800da28 <HAL_RCC_ClockConfig+0x200>
 800da4a:	e011      	b.n	800da70 <HAL_RCC_ClockConfig+0x248>
          } 
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800da4c:	e00a      	b.n	800da64 <HAL_RCC_ClockConfig+0x23c>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800da4e:	f7f8 fc03 	bl	8006258 <HAL_GetTick>
 800da52:	4602      	mov	r2, r0
 800da54:	68fb      	ldr	r3, [r7, #12]
 800da56:	1ad3      	subs	r3, r2, r3
 800da58:	f241 3288 	movw	r2, #5000	; 0x1388
 800da5c:	4293      	cmp	r3, r2
 800da5e:	d901      	bls.n	800da64 <HAL_RCC_ClockConfig+0x23c>
          {
            return HAL_TIMEOUT;
 800da60:	2303      	movs	r3, #3
 800da62:	e03e      	b.n	800dae2 <HAL_RCC_ClockConfig+0x2ba>
          } 
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800da64:	4b0c      	ldr	r3, [pc, #48]	; (800da98 <HAL_RCC_ClockConfig+0x270>)
 800da66:	689b      	ldr	r3, [r3, #8]
 800da68:	f003 030c 	and.w	r3, r3, #12
 800da6c:	2b00      	cmp	r3, #0
 800da6e:	d1ee      	bne.n	800da4e <HAL_RCC_ClockConfig+0x226>
        }
      }
    }
    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800da70:	4908      	ldr	r1, [pc, #32]	; (800da94 <HAL_RCC_ClockConfig+0x26c>)
 800da72:	4b08      	ldr	r3, [pc, #32]	; (800da94 <HAL_RCC_ClockConfig+0x26c>)
 800da74:	681b      	ldr	r3, [r3, #0]
 800da76:	f023 020f 	bic.w	r2, r3, #15
 800da7a:	683b      	ldr	r3, [r7, #0]
 800da7c:	4313      	orrs	r3, r2
 800da7e:	600b      	str	r3, [r1, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 800da80:	4b04      	ldr	r3, [pc, #16]	; (800da94 <HAL_RCC_ClockConfig+0x26c>)
 800da82:	681b      	ldr	r3, [r3, #0]
 800da84:	f003 020f 	and.w	r2, r3, #15
 800da88:	683b      	ldr	r3, [r7, #0]
 800da8a:	429a      	cmp	r2, r3
 800da8c:	d006      	beq.n	800da9c <HAL_RCC_ClockConfig+0x274>
    {
      return HAL_ERROR;
 800da8e:	2301      	movs	r3, #1
 800da90:	e027      	b.n	800dae2 <HAL_RCC_ClockConfig+0x2ba>
 800da92:	bf00      	nop
 800da94:	40023c00 	.word	0x40023c00
 800da98:	40023800 	.word	0x40023800
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800da9c:	687b      	ldr	r3, [r7, #4]
 800da9e:	681b      	ldr	r3, [r3, #0]
 800daa0:	f003 0304 	and.w	r3, r3, #4
 800daa4:	2b00      	cmp	r3, #0
 800daa6:	d008      	beq.n	800daba <HAL_RCC_ClockConfig+0x292>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800daa8:	4910      	ldr	r1, [pc, #64]	; (800daec <HAL_RCC_ClockConfig+0x2c4>)
 800daaa:	4b10      	ldr	r3, [pc, #64]	; (800daec <HAL_RCC_ClockConfig+0x2c4>)
 800daac:	689b      	ldr	r3, [r3, #8]
 800daae:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 800dab2:	687b      	ldr	r3, [r7, #4]
 800dab4:	68db      	ldr	r3, [r3, #12]
 800dab6:	4313      	orrs	r3, r2
 800dab8:	608b      	str	r3, [r1, #8]
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800daba:	687b      	ldr	r3, [r7, #4]
 800dabc:	681b      	ldr	r3, [r3, #0]
 800dabe:	f003 0308 	and.w	r3, r3, #8
 800dac2:	2b00      	cmp	r3, #0
 800dac4:	d009      	beq.n	800dada <HAL_RCC_ClockConfig+0x2b2>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 800dac6:	4909      	ldr	r1, [pc, #36]	; (800daec <HAL_RCC_ClockConfig+0x2c4>)
 800dac8:	4b08      	ldr	r3, [pc, #32]	; (800daec <HAL_RCC_ClockConfig+0x2c4>)
 800daca:	689b      	ldr	r3, [r3, #8]
 800dacc:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 800dad0:	687b      	ldr	r3, [r7, #4]
 800dad2:	691b      	ldr	r3, [r3, #16]
 800dad4:	00db      	lsls	r3, r3, #3
 800dad6:	4313      	orrs	r3, r2
 800dad8:	608b      	str	r3, [r1, #8]
  }

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 800dada:	200f      	movs	r0, #15
 800dadc:	f004 fbca 	bl	8012274 <HAL_InitTick>
  
  return HAL_OK;
 800dae0:	2300      	movs	r3, #0
}
 800dae2:	4618      	mov	r0, r3
 800dae4:	3710      	adds	r7, #16
 800dae6:	46bd      	mov	sp, r7
 800dae8:	bd80      	pop	{r7, pc}
 800daea:	bf00      	nop
 800daec:	40023800 	.word	0x40023800

0800daf0 <HAL_RCC_GetSysClockFreq>:
  *         
  *               
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800daf0:	b480      	push	{r7}
 800daf2:	b08b      	sub	sp, #44	; 0x2c
 800daf4:	af00      	add	r7, sp, #0
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
 800daf6:	2300      	movs	r3, #0
 800daf8:	61fb      	str	r3, [r7, #28]
 800dafa:	2300      	movs	r3, #0
 800dafc:	627b      	str	r3, [r7, #36]	; 0x24
 800dafe:	2300      	movs	r3, #0
 800db00:	61bb      	str	r3, [r7, #24]
  uint32_t sysclockfreq = 0;
 800db02:	2300      	movs	r3, #0
 800db04:	623b      	str	r3, [r7, #32]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800db06:	4b36      	ldr	r3, [pc, #216]	; (800dbe0 <HAL_RCC_GetSysClockFreq+0xf0>)
 800db08:	689b      	ldr	r3, [r3, #8]
 800db0a:	f003 030c 	and.w	r3, r3, #12
 800db0e:	2b04      	cmp	r3, #4
 800db10:	d006      	beq.n	800db20 <HAL_RCC_GetSysClockFreq+0x30>
 800db12:	2b08      	cmp	r3, #8
 800db14:	d007      	beq.n	800db26 <HAL_RCC_GetSysClockFreq+0x36>
 800db16:	2b00      	cmp	r3, #0
 800db18:	d158      	bne.n	800dbcc <HAL_RCC_GetSysClockFreq+0xdc>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 800db1a:	4b32      	ldr	r3, [pc, #200]	; (800dbe4 <HAL_RCC_GetSysClockFreq+0xf4>)
 800db1c:	623b      	str	r3, [r7, #32]
       break;
 800db1e:	e058      	b.n	800dbd2 <HAL_RCC_GetSysClockFreq+0xe2>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 800db20:	4b31      	ldr	r3, [pc, #196]	; (800dbe8 <HAL_RCC_GetSysClockFreq+0xf8>)
 800db22:	623b      	str	r3, [r7, #32]
      break;
 800db24:	e055      	b.n	800dbd2 <HAL_RCC_GetSysClockFreq+0xe2>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800db26:	4b2e      	ldr	r3, [pc, #184]	; (800dbe0 <HAL_RCC_GetSysClockFreq+0xf0>)
 800db28:	685b      	ldr	r3, [r3, #4]
 800db2a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800db2e:	61fb      	str	r3, [r7, #28]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 800db30:	4b2b      	ldr	r3, [pc, #172]	; (800dbe0 <HAL_RCC_GetSysClockFreq+0xf0>)
 800db32:	685b      	ldr	r3, [r3, #4]
 800db34:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800db38:	2b00      	cmp	r3, #0
 800db3a:	d017      	beq.n	800db6c <HAL_RCC_GetSysClockFreq+0x7c>
      {
        /* HSE used as PLL clock source */
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 800db3c:	4a2a      	ldr	r2, [pc, #168]	; (800dbe8 <HAL_RCC_GetSysClockFreq+0xf8>)
 800db3e:	69fb      	ldr	r3, [r7, #28]
 800db40:	fbb2 f2f3 	udiv	r2, r2, r3
 800db44:	4b26      	ldr	r3, [pc, #152]	; (800dbe0 <HAL_RCC_GetSysClockFreq+0xf0>)
 800db46:	6859      	ldr	r1, [r3, #4]
 800db48:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800db4c:	400b      	ands	r3, r1
 800db4e:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 800db52:	6179      	str	r1, [r7, #20]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800db54:	6979      	ldr	r1, [r7, #20]
 800db56:	fa91 f1a1 	rbit	r1, r1
 800db5a:	6139      	str	r1, [r7, #16]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800db5c:	6939      	ldr	r1, [r7, #16]
 800db5e:	fab1 f181 	clz	r1, r1
 800db62:	40cb      	lsrs	r3, r1
 800db64:	fb03 f302 	mul.w	r3, r3, r2
 800db68:	627b      	str	r3, [r7, #36]	; 0x24
 800db6a:	e016      	b.n	800db9a <HAL_RCC_GetSysClockFreq+0xaa>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 800db6c:	4a1d      	ldr	r2, [pc, #116]	; (800dbe4 <HAL_RCC_GetSysClockFreq+0xf4>)
 800db6e:	69fb      	ldr	r3, [r7, #28]
 800db70:	fbb2 f2f3 	udiv	r2, r2, r3
 800db74:	4b1a      	ldr	r3, [pc, #104]	; (800dbe0 <HAL_RCC_GetSysClockFreq+0xf0>)
 800db76:	6859      	ldr	r1, [r3, #4]
 800db78:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800db7c:	400b      	ands	r3, r1
 800db7e:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 800db82:	60f9      	str	r1, [r7, #12]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800db84:	68f9      	ldr	r1, [r7, #12]
 800db86:	fa91 f1a1 	rbit	r1, r1
 800db8a:	60b9      	str	r1, [r7, #8]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800db8c:	68b9      	ldr	r1, [r7, #8]
 800db8e:	fab1 f181 	clz	r1, r1
 800db92:	40cb      	lsrs	r3, r1
 800db94:	fb03 f302 	mul.w	r3, r3, r2
 800db98:	627b      	str	r3, [r7, #36]	; 0x24
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1 ) *2);
 800db9a:	4b11      	ldr	r3, [pc, #68]	; (800dbe0 <HAL_RCC_GetSysClockFreq+0xf0>)
 800db9c:	685b      	ldr	r3, [r3, #4]
 800db9e:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 800dba2:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 800dba6:	607b      	str	r3, [r7, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800dba8:	687b      	ldr	r3, [r7, #4]
 800dbaa:	fa93 f3a3 	rbit	r3, r3
 800dbae:	603b      	str	r3, [r7, #0]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800dbb0:	683b      	ldr	r3, [r7, #0]
 800dbb2:	fab3 f383 	clz	r3, r3
 800dbb6:	fa22 f303 	lsr.w	r3, r2, r3
 800dbba:	3301      	adds	r3, #1
 800dbbc:	005b      	lsls	r3, r3, #1
 800dbbe:	61bb      	str	r3, [r7, #24]
      
      sysclockfreq = pllvco/pllp;
 800dbc0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800dbc2:	69bb      	ldr	r3, [r7, #24]
 800dbc4:	fbb2 f3f3 	udiv	r3, r2, r3
 800dbc8:	623b      	str	r3, [r7, #32]
      break;
 800dbca:	e002      	b.n	800dbd2 <HAL_RCC_GetSysClockFreq+0xe2>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 800dbcc:	4b05      	ldr	r3, [pc, #20]	; (800dbe4 <HAL_RCC_GetSysClockFreq+0xf4>)
 800dbce:	623b      	str	r3, [r7, #32]
      break;
 800dbd0:	bf00      	nop
    }
  }
  return sysclockfreq;
 800dbd2:	6a3b      	ldr	r3, [r7, #32]
}
 800dbd4:	4618      	mov	r0, r3
 800dbd6:	372c      	adds	r7, #44	; 0x2c
 800dbd8:	46bd      	mov	sp, r7
 800dbda:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dbde:	4770      	bx	lr
 800dbe0:	40023800 	.word	0x40023800
 800dbe4:	00f42400 	.word	0x00f42400
 800dbe8:	017d7840 	.word	0x017d7840

0800dbec <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800dbec:	b580      	push	{r7, lr}
 800dbee:	b082      	sub	sp, #8
 800dbf0:	af00      	add	r7, sp, #0
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 800dbf2:	f7ff ff7d 	bl	800daf0 <HAL_RCC_GetSysClockFreq>
 800dbf6:	4601      	mov	r1, r0
 800dbf8:	4b0d      	ldr	r3, [pc, #52]	; (800dc30 <HAL_RCC_GetHCLKFreq+0x44>)
 800dbfa:	689b      	ldr	r3, [r3, #8]
 800dbfc:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 800dc00:	23f0      	movs	r3, #240	; 0xf0
 800dc02:	607b      	str	r3, [r7, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800dc04:	687b      	ldr	r3, [r7, #4]
 800dc06:	fa93 f3a3 	rbit	r3, r3
 800dc0a:	603b      	str	r3, [r7, #0]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800dc0c:	683b      	ldr	r3, [r7, #0]
 800dc0e:	fab3 f383 	clz	r3, r3
 800dc12:	fa22 f303 	lsr.w	r3, r2, r3
 800dc16:	4a07      	ldr	r2, [pc, #28]	; (800dc34 <HAL_RCC_GetHCLKFreq+0x48>)
 800dc18:	5cd3      	ldrb	r3, [r2, r3]
 800dc1a:	fa21 f303 	lsr.w	r3, r1, r3
 800dc1e:	4a06      	ldr	r2, [pc, #24]	; (800dc38 <HAL_RCC_GetHCLKFreq+0x4c>)
 800dc20:	6013      	str	r3, [r2, #0]
  return SystemCoreClock;
 800dc22:	4b05      	ldr	r3, [pc, #20]	; (800dc38 <HAL_RCC_GetHCLKFreq+0x4c>)
 800dc24:	681b      	ldr	r3, [r3, #0]
}
 800dc26:	4618      	mov	r0, r3
 800dc28:	3708      	adds	r7, #8
 800dc2a:	46bd      	mov	sp, r7
 800dc2c:	bd80      	pop	{r7, pc}
 800dc2e:	bf00      	nop
 800dc30:	40023800 	.word	0x40023800
 800dc34:	0802a4fc 	.word	0x0802a4fc
 800dc38:	20010014 	.word	0x20010014

0800dc3c <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{  
 800dc3c:	b580      	push	{r7, lr}
 800dc3e:	b082      	sub	sp, #8
 800dc40:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 800dc42:	f7ff ffd3 	bl	800dbec <HAL_RCC_GetHCLKFreq>
 800dc46:	4601      	mov	r1, r0
 800dc48:	4b0b      	ldr	r3, [pc, #44]	; (800dc78 <HAL_RCC_GetPCLK1Freq+0x3c>)
 800dc4a:	689b      	ldr	r3, [r3, #8]
 800dc4c:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
 800dc50:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 800dc54:	607b      	str	r3, [r7, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800dc56:	687b      	ldr	r3, [r7, #4]
 800dc58:	fa93 f3a3 	rbit	r3, r3
 800dc5c:	603b      	str	r3, [r7, #0]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800dc5e:	683b      	ldr	r3, [r7, #0]
 800dc60:	fab3 f383 	clz	r3, r3
 800dc64:	fa22 f303 	lsr.w	r3, r2, r3
 800dc68:	4a04      	ldr	r2, [pc, #16]	; (800dc7c <HAL_RCC_GetPCLK1Freq+0x40>)
 800dc6a:	5cd3      	ldrb	r3, [r2, r3]
 800dc6c:	fa21 f303 	lsr.w	r3, r1, r3
}
 800dc70:	4618      	mov	r0, r3
 800dc72:	3708      	adds	r7, #8
 800dc74:	46bd      	mov	sp, r7
 800dc76:	bd80      	pop	{r7, pc}
 800dc78:	40023800 	.word	0x40023800
 800dc7c:	0802a4fc 	.word	0x0802a4fc

0800dc80 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800dc80:	b580      	push	{r7, lr}
 800dc82:	b082      	sub	sp, #8
 800dc84:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
 800dc86:	f7ff ffb1 	bl	800dbec <HAL_RCC_GetHCLKFreq>
 800dc8a:	4601      	mov	r1, r0
 800dc8c:	4b0b      	ldr	r3, [pc, #44]	; (800dcbc <HAL_RCC_GetPCLK2Freq+0x3c>)
 800dc8e:	689b      	ldr	r3, [r3, #8]
 800dc90:	f403 4260 	and.w	r2, r3, #57344	; 0xe000
 800dc94:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 800dc98:	607b      	str	r3, [r7, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800dc9a:	687b      	ldr	r3, [r7, #4]
 800dc9c:	fa93 f3a3 	rbit	r3, r3
 800dca0:	603b      	str	r3, [r7, #0]
    result |= value & 1;
    s--;
  }
  result <<= s;                       // shift when v's highest bits are zero
#endif
  return(result);
 800dca2:	683b      	ldr	r3, [r7, #0]
 800dca4:	fab3 f383 	clz	r3, r3
 800dca8:	fa22 f303 	lsr.w	r3, r2, r3
 800dcac:	4a04      	ldr	r2, [pc, #16]	; (800dcc0 <HAL_RCC_GetPCLK2Freq+0x40>)
 800dcae:	5cd3      	ldrb	r3, [r2, r3]
 800dcb0:	fa21 f303 	lsr.w	r3, r1, r3
} 
 800dcb4:	4618      	mov	r0, r3
 800dcb6:	3708      	adds	r7, #8
 800dcb8:	46bd      	mov	sp, r7
 800dcba:	bd80      	pop	{r7, pc}
 800dcbc:	40023800 	.word	0x40023800
 800dcc0:	0802a4fc 	.word	0x0802a4fc

0800dcc4 <HAL_SDRAM_Init>:
  *                the configuration information for SDRAM module.
  * @param  Timing: Pointer to SDRAM control timing structure 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{   
 800dcc4:	b580      	push	{r7, lr}
 800dcc6:	b082      	sub	sp, #8
 800dcc8:	af00      	add	r7, sp, #0
 800dcca:	6078      	str	r0, [r7, #4]
 800dccc:	6039      	str	r1, [r7, #0]
  /* Check the SDRAM handle parameter */
  if(hsdram == NULL)
 800dcce:	687b      	ldr	r3, [r7, #4]
 800dcd0:	2b00      	cmp	r3, #0
 800dcd2:	d101      	bne.n	800dcd8 <HAL_SDRAM_Init+0x14>
  {
    return HAL_ERROR;
 800dcd4:	2301      	movs	r3, #1
 800dcd6:	e026      	b.n	800dd26 <HAL_SDRAM_Init+0x62>
  }
  
  if(hsdram->State == HAL_SDRAM_STATE_RESET)
 800dcd8:	687b      	ldr	r3, [r7, #4]
 800dcda:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800dcde:	b2db      	uxtb	r3, r3
 800dce0:	2b00      	cmp	r3, #0
 800dce2:	d106      	bne.n	800dcf2 <HAL_SDRAM_Init+0x2e>
  {  
    /* Allocate lock resource and initialize it */
    hsdram->Lock = HAL_UNLOCKED;
 800dce4:	687b      	ldr	r3, [r7, #4]
 800dce6:	2200      	movs	r2, #0
 800dce8:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    /* Initialize the low level hardware (MSP) */
    HAL_SDRAM_MspInit(hsdram);
 800dcec:	6878      	ldr	r0, [r7, #4]
 800dcee:	f000 f81f 	bl	800dd30 <HAL_SDRAM_MspInit>
  }
  
  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 800dcf2:	687b      	ldr	r3, [r7, #4]
 800dcf4:	2202      	movs	r2, #2
 800dcf6:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Initialize SDRAM control Interface */
  FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 800dcfa:	687b      	ldr	r3, [r7, #4]
 800dcfc:	681a      	ldr	r2, [r3, #0]
 800dcfe:	687b      	ldr	r3, [r7, #4]
 800dd00:	3304      	adds	r3, #4
 800dd02:	4610      	mov	r0, r2
 800dd04:	4619      	mov	r1, r3
 800dd06:	f001 fe01 	bl	800f90c <FMC_SDRAM_Init>
  
  /* Initialize SDRAM timing Interface */
  FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank); 
 800dd0a:	687b      	ldr	r3, [r7, #4]
 800dd0c:	681a      	ldr	r2, [r3, #0]
 800dd0e:	687b      	ldr	r3, [r7, #4]
 800dd10:	685b      	ldr	r3, [r3, #4]
 800dd12:	4610      	mov	r0, r2
 800dd14:	6839      	ldr	r1, [r7, #0]
 800dd16:	461a      	mov	r2, r3
 800dd18:	f001 fe6a 	bl	800f9f0 <FMC_SDRAM_Timing_Init>
  
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 800dd1c:	687b      	ldr	r3, [r7, #4]
 800dd1e:	2201      	movs	r2, #1
 800dd20:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  return HAL_OK;
 800dd24:	2300      	movs	r3, #0
}
 800dd26:	4618      	mov	r0, r3
 800dd28:	3708      	adds	r7, #8
 800dd2a:	46bd      	mov	sp, r7
 800dd2c:	bd80      	pop	{r7, pc}
 800dd2e:	bf00      	nop

0800dd30 <HAL_SDRAM_MspInit>:
  * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval None
  */
__weak void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef *hsdram)
{
 800dd30:	b480      	push	{r7}
 800dd32:	b083      	sub	sp, #12
 800dd34:	af00      	add	r7, sp, #0
 800dd36:	6078      	str	r0, [r7, #4]
  /* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_MspInit could be implemented in the user file
   */ 
}
 800dd38:	370c      	adds	r7, #12
 800dd3a:	46bd      	mov	sp, r7
 800dd3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dd40:	4770      	bx	lr
 800dd42:	bf00      	nop

0800dd44 <HAL_SDRAM_SendCommand>:
  * @param  Command: SDRAM command structure
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */  
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 800dd44:	b580      	push	{r7, lr}
 800dd46:	b084      	sub	sp, #16
 800dd48:	af00      	add	r7, sp, #0
 800dd4a:	60f8      	str	r0, [r7, #12]
 800dd4c:	60b9      	str	r1, [r7, #8]
 800dd4e:	607a      	str	r2, [r7, #4]
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 800dd50:	68fb      	ldr	r3, [r7, #12]
 800dd52:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800dd56:	b2db      	uxtb	r3, r3
 800dd58:	2b02      	cmp	r3, #2
 800dd5a:	d101      	bne.n	800dd60 <HAL_SDRAM_SendCommand+0x1c>
  {
    return HAL_BUSY;
 800dd5c:	2302      	movs	r3, #2
 800dd5e:	e018      	b.n	800dd92 <HAL_SDRAM_SendCommand+0x4e>
  }
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 800dd60:	68fb      	ldr	r3, [r7, #12]
 800dd62:	2202      	movs	r2, #2
 800dd64:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Send SDRAM command */
  FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 800dd68:	68fb      	ldr	r3, [r7, #12]
 800dd6a:	681b      	ldr	r3, [r3, #0]
 800dd6c:	4618      	mov	r0, r3
 800dd6e:	68b9      	ldr	r1, [r7, #8]
 800dd70:	687a      	ldr	r2, [r7, #4]
 800dd72:	f001 febb 	bl	800faec <FMC_SDRAM_SendCommand>
  
  /* Update the SDRAM controller state state */
  if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
 800dd76:	68bb      	ldr	r3, [r7, #8]
 800dd78:	681b      	ldr	r3, [r3, #0]
 800dd7a:	2b02      	cmp	r3, #2
 800dd7c:	d104      	bne.n	800dd88 <HAL_SDRAM_SendCommand+0x44>
  {
    hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
 800dd7e:	68fb      	ldr	r3, [r7, #12]
 800dd80:	2205      	movs	r2, #5
 800dd82:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
 800dd86:	e003      	b.n	800dd90 <HAL_SDRAM_SendCommand+0x4c>
  }
  else
  {
    hsdram->State = HAL_SDRAM_STATE_READY;
 800dd88:	68fb      	ldr	r3, [r7, #12]
 800dd8a:	2201      	movs	r2, #1
 800dd8c:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  }
  
  return HAL_OK;  
 800dd90:	2300      	movs	r3, #0
}
 800dd92:	4618      	mov	r0, r3
 800dd94:	3710      	adds	r7, #16
 800dd96:	46bd      	mov	sp, r7
 800dd98:	bd80      	pop	{r7, pc}
 800dd9a:	bf00      	nop

0800dd9c <HAL_SDRAM_ProgramRefreshRate>:
  *                the configuration information for SDRAM module.  
  * @param  RefreshRate: The SDRAM refresh rate value       
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
 800dd9c:	b580      	push	{r7, lr}
 800dd9e:	b082      	sub	sp, #8
 800dda0:	af00      	add	r7, sp, #0
 800dda2:	6078      	str	r0, [r7, #4]
 800dda4:	6039      	str	r1, [r7, #0]
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 800dda6:	687b      	ldr	r3, [r7, #4]
 800dda8:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800ddac:	b2db      	uxtb	r3, r3
 800ddae:	2b02      	cmp	r3, #2
 800ddb0:	d101      	bne.n	800ddb6 <HAL_SDRAM_ProgramRefreshRate+0x1a>
  {
    return HAL_BUSY;
 800ddb2:	2302      	movs	r3, #2
 800ddb4:	e00e      	b.n	800ddd4 <HAL_SDRAM_ProgramRefreshRate+0x38>
  } 
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 800ddb6:	687b      	ldr	r3, [r7, #4]
 800ddb8:	2202      	movs	r2, #2
 800ddba:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Program the refresh rate */
  FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
 800ddbe:	687b      	ldr	r3, [r7, #4]
 800ddc0:	681b      	ldr	r3, [r3, #0]
 800ddc2:	4618      	mov	r0, r3
 800ddc4:	6839      	ldr	r1, [r7, #0]
 800ddc6:	f001 fecf 	bl	800fb68 <FMC_SDRAM_ProgramRefreshRate>
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 800ddca:	687b      	ldr	r3, [r7, #4]
 800ddcc:	2201      	movs	r2, #1
 800ddce:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  return HAL_OK;   
 800ddd2:	2300      	movs	r3, #0
}
 800ddd4:	4618      	mov	r0, r3
 800ddd6:	3708      	adds	r7, #8
 800ddd8:	46bd      	mov	sp, r7
 800ddda:	bd80      	pop	{r7, pc}

0800dddc <HAL_TIM_Base_DeInit>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
{  
 800dddc:	b580      	push	{r7, lr}
 800ddde:	b082      	sub	sp, #8
 800dde0:	af00      	add	r7, sp, #0
 800dde2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  htim->State = HAL_TIM_STATE_BUSY;
 800dde4:	687b      	ldr	r3, [r7, #4]
 800dde6:	2202      	movs	r2, #2
 800dde8:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
   
  /* Disable the TIM Peripheral Clock */
  __HAL_TIM_DISABLE(htim);
 800ddec:	687b      	ldr	r3, [r7, #4]
 800ddee:	681b      	ldr	r3, [r3, #0]
 800ddf0:	6a1a      	ldr	r2, [r3, #32]
 800ddf2:	f241 1311 	movw	r3, #4369	; 0x1111
 800ddf6:	4013      	ands	r3, r2
 800ddf8:	2b00      	cmp	r3, #0
 800ddfa:	d10f      	bne.n	800de1c <HAL_TIM_Base_DeInit+0x40>
 800ddfc:	687b      	ldr	r3, [r7, #4]
 800ddfe:	681b      	ldr	r3, [r3, #0]
 800de00:	6a1a      	ldr	r2, [r3, #32]
 800de02:	f240 4344 	movw	r3, #1092	; 0x444
 800de06:	4013      	ands	r3, r2
 800de08:	2b00      	cmp	r3, #0
 800de0a:	d107      	bne.n	800de1c <HAL_TIM_Base_DeInit+0x40>
 800de0c:	687b      	ldr	r3, [r7, #4]
 800de0e:	681b      	ldr	r3, [r3, #0]
 800de10:	687a      	ldr	r2, [r7, #4]
 800de12:	6812      	ldr	r2, [r2, #0]
 800de14:	6812      	ldr	r2, [r2, #0]
 800de16:	f022 0201 	bic.w	r2, r2, #1
 800de1a:	601a      	str	r2, [r3, #0]
    
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_TIM_Base_MspDeInit(htim);
 800de1c:	6878      	ldr	r0, [r7, #4]
 800de1e:	f000 f80d 	bl	800de3c <HAL_TIM_Base_MspDeInit>
  
  /* Change TIM state */  
  htim->State = HAL_TIM_STATE_RESET; 
 800de22:	687b      	ldr	r3, [r7, #4]
 800de24:	2200      	movs	r2, #0
 800de26:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  /* Release Lock */
  __HAL_UNLOCK(htim);
 800de2a:	687b      	ldr	r3, [r7, #4]
 800de2c:	2200      	movs	r2, #0
 800de2e:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  return HAL_OK;
 800de32:	2300      	movs	r3, #0
}
 800de34:	4618      	mov	r0, r3
 800de36:	3708      	adds	r7, #8
 800de38:	46bd      	mov	sp, r7
 800de3a:	bd80      	pop	{r7, pc}

0800de3c <HAL_TIM_Base_MspDeInit>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
{
 800de3c:	b480      	push	{r7}
 800de3e:	b083      	sub	sp, #12
 800de40:	af00      	add	r7, sp, #0
 800de42:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspDeInit could be implemented in the user file
   */
}
 800de44:	370c      	adds	r7, #12
 800de46:	46bd      	mov	sp, r7
 800de48:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de4c:	4770      	bx	lr
 800de4e:	bf00      	nop

0800de50 <HAL_TIM_PWM_Init>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
 800de50:	b580      	push	{r7, lr}
 800de52:	b082      	sub	sp, #8
 800de54:	af00      	add	r7, sp, #0
 800de56:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if(htim == NULL)
 800de58:	687b      	ldr	r3, [r7, #4]
 800de5a:	2b00      	cmp	r3, #0
 800de5c:	d101      	bne.n	800de62 <HAL_TIM_PWM_Init+0x12>
  {
    return HAL_ERROR;
 800de5e:	2301      	movs	r3, #1
 800de60:	e01d      	b.n	800de9e <HAL_TIM_PWM_Init+0x4e>
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));

  if(htim->State == HAL_TIM_STATE_RESET)
 800de62:	687b      	ldr	r3, [r7, #4]
 800de64:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 800de68:	b2db      	uxtb	r3, r3
 800de6a:	2b00      	cmp	r3, #0
 800de6c:	d106      	bne.n	800de7c <HAL_TIM_PWM_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;  
 800de6e:	687b      	ldr	r3, [r7, #4]
 800de70:	2200      	movs	r2, #0
 800de72:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_PWM_MspInit(htim);
 800de76:	6878      	ldr	r0, [r7, #4]
 800de78:	f005 fd76 	bl	8013968 <HAL_TIM_PWM_MspInit>
  }

  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;  
 800de7c:	687b      	ldr	r3, [r7, #4]
 800de7e:	2202      	movs	r2, #2
 800de80:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  /* Init the base time for the PWM */  
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
 800de84:	687b      	ldr	r3, [r7, #4]
 800de86:	681a      	ldr	r2, [r3, #0]
 800de88:	687b      	ldr	r3, [r7, #4]
 800de8a:	3304      	adds	r3, #4
 800de8c:	4610      	mov	r0, r2
 800de8e:	4619      	mov	r1, r3
 800de90:	f000 faea 	bl	800e468 <TIM_Base_SetConfig>
   
  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 800de94:	687b      	ldr	r3, [r7, #4]
 800de96:	2201      	movs	r2, #1
 800de98:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  return HAL_OK;
 800de9c:	2300      	movs	r3, #0
}  
 800de9e:	4618      	mov	r0, r3
 800dea0:	3708      	adds	r7, #8
 800dea2:	46bd      	mov	sp, r7
 800dea4:	bd80      	pop	{r7, pc}
 800dea6:	bf00      	nop

0800dea8 <HAL_TIM_PWM_DeInit>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
{
 800dea8:	b580      	push	{r7, lr}
 800deaa:	b082      	sub	sp, #8
 800deac:	af00      	add	r7, sp, #0
 800deae:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  
  htim->State = HAL_TIM_STATE_BUSY;
 800deb0:	687b      	ldr	r3, [r7, #4]
 800deb2:	2202      	movs	r2, #2
 800deb4:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  /* Disable the TIM Peripheral Clock */
  __HAL_TIM_DISABLE(htim);
 800deb8:	687b      	ldr	r3, [r7, #4]
 800deba:	681b      	ldr	r3, [r3, #0]
 800debc:	6a1a      	ldr	r2, [r3, #32]
 800debe:	f241 1311 	movw	r3, #4369	; 0x1111
 800dec2:	4013      	ands	r3, r2
 800dec4:	2b00      	cmp	r3, #0
 800dec6:	d10f      	bne.n	800dee8 <HAL_TIM_PWM_DeInit+0x40>
 800dec8:	687b      	ldr	r3, [r7, #4]
 800deca:	681b      	ldr	r3, [r3, #0]
 800decc:	6a1a      	ldr	r2, [r3, #32]
 800dece:	f240 4344 	movw	r3, #1092	; 0x444
 800ded2:	4013      	ands	r3, r2
 800ded4:	2b00      	cmp	r3, #0
 800ded6:	d107      	bne.n	800dee8 <HAL_TIM_PWM_DeInit+0x40>
 800ded8:	687b      	ldr	r3, [r7, #4]
 800deda:	681b      	ldr	r3, [r3, #0]
 800dedc:	687a      	ldr	r2, [r7, #4]
 800dede:	6812      	ldr	r2, [r2, #0]
 800dee0:	6812      	ldr	r2, [r2, #0]
 800dee2:	f022 0201 	bic.w	r2, r2, #1
 800dee6:	601a      	str	r2, [r3, #0]
    
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
  HAL_TIM_PWM_MspDeInit(htim);
 800dee8:	6878      	ldr	r0, [r7, #4]
 800deea:	f005 fddf 	bl	8013aac <HAL_TIM_PWM_MspDeInit>
    
  /* Change TIM state */  
  htim->State = HAL_TIM_STATE_RESET; 
 800deee:	687b      	ldr	r3, [r7, #4]
 800def0:	2200      	movs	r2, #0
 800def2:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  /* Release Lock */
  __HAL_UNLOCK(htim);
 800def6:	687b      	ldr	r3, [r7, #4]
 800def8:	2200      	movs	r2, #0
 800defa:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  return HAL_OK;
 800defe:	2300      	movs	r3, #0
}
 800df00:	4618      	mov	r0, r3
 800df02:	3708      	adds	r7, #8
 800df04:	46bd      	mov	sp, r7
 800df06:	bd80      	pop	{r7, pc}

0800df08 <HAL_TIM_PWM_Start>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 800df08:	b580      	push	{r7, lr}
 800df0a:	b082      	sub	sp, #8
 800df0c:	af00      	add	r7, sp, #0
 800df0e:	6078      	str	r0, [r7, #4]
 800df10:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Enable the Capture compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 800df12:	687b      	ldr	r3, [r7, #4]
 800df14:	681b      	ldr	r3, [r3, #0]
 800df16:	4618      	mov	r0, r3
 800df18:	6839      	ldr	r1, [r7, #0]
 800df1a:	2201      	movs	r2, #1
 800df1c:	f000 fd14 	bl	800e948 <TIM_CCxChannelCmd>
  
  if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
 800df20:	687b      	ldr	r3, [r7, #4]
 800df22:	681b      	ldr	r3, [r3, #0]
 800df24:	4a10      	ldr	r2, [pc, #64]	; (800df68 <HAL_TIM_PWM_Start+0x60>)
 800df26:	4293      	cmp	r3, r2
 800df28:	d004      	beq.n	800df34 <HAL_TIM_PWM_Start+0x2c>
 800df2a:	687b      	ldr	r3, [r7, #4]
 800df2c:	681b      	ldr	r3, [r3, #0]
 800df2e:	4a0f      	ldr	r2, [pc, #60]	; (800df6c <HAL_TIM_PWM_Start+0x64>)
 800df30:	4293      	cmp	r3, r2
 800df32:	d101      	bne.n	800df38 <HAL_TIM_PWM_Start+0x30>
 800df34:	2301      	movs	r3, #1
 800df36:	e000      	b.n	800df3a <HAL_TIM_PWM_Start+0x32>
 800df38:	2300      	movs	r3, #0
 800df3a:	2b00      	cmp	r3, #0
 800df3c:	d007      	beq.n	800df4e <HAL_TIM_PWM_Start+0x46>
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
 800df3e:	687b      	ldr	r3, [r7, #4]
 800df40:	681b      	ldr	r3, [r3, #0]
 800df42:	687a      	ldr	r2, [r7, #4]
 800df44:	6812      	ldr	r2, [r2, #0]
 800df46:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800df48:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800df4c:	645a      	str	r2, [r3, #68]	; 0x44
  }
    
  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 800df4e:	687b      	ldr	r3, [r7, #4]
 800df50:	681b      	ldr	r3, [r3, #0]
 800df52:	687a      	ldr	r2, [r7, #4]
 800df54:	6812      	ldr	r2, [r2, #0]
 800df56:	6812      	ldr	r2, [r2, #0]
 800df58:	f042 0201 	orr.w	r2, r2, #1
 800df5c:	601a      	str	r2, [r3, #0]
  
  /* Return function status */
  return HAL_OK;
 800df5e:	2300      	movs	r3, #0
} 
 800df60:	4618      	mov	r0, r3
 800df62:	3708      	adds	r7, #8
 800df64:	46bd      	mov	sp, r7
 800df66:	bd80      	pop	{r7, pc}
 800df68:	40010000 	.word	0x40010000
 800df6c:	40010400 	.word	0x40010400

0800df70 <HAL_TIM_IC_Init>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
{
 800df70:	b580      	push	{r7, lr}
 800df72:	b082      	sub	sp, #8
 800df74:	af00      	add	r7, sp, #0
 800df76:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if(htim == NULL)
 800df78:	687b      	ldr	r3, [r7, #4]
 800df7a:	2b00      	cmp	r3, #0
 800df7c:	d101      	bne.n	800df82 <HAL_TIM_IC_Init+0x12>
  {
    return HAL_ERROR;
 800df7e:	2301      	movs	r3, #1
 800df80:	e01d      	b.n	800dfbe <HAL_TIM_IC_Init+0x4e>
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision)); 

  if(htim->State == HAL_TIM_STATE_RESET)
 800df82:	687b      	ldr	r3, [r7, #4]
 800df84:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 800df88:	b2db      	uxtb	r3, r3
 800df8a:	2b00      	cmp	r3, #0
 800df8c:	d106      	bne.n	800df9c <HAL_TIM_IC_Init+0x2c>
  { 
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;   
 800df8e:	687b      	ldr	r3, [r7, #4]
 800df90:	2200      	movs	r2, #0
 800df92:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_IC_MspInit(htim);
 800df96:	6878      	ldr	r0, [r7, #4]
 800df98:	f000 f816 	bl	800dfc8 <HAL_TIM_IC_MspInit>
  }
  
  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;   
 800df9c:	687b      	ldr	r3, [r7, #4]
 800df9e:	2202      	movs	r2, #2
 800dfa0:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  /* Init the base time for the input capture */  
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
 800dfa4:	687b      	ldr	r3, [r7, #4]
 800dfa6:	681a      	ldr	r2, [r3, #0]
 800dfa8:	687b      	ldr	r3, [r7, #4]
 800dfaa:	3304      	adds	r3, #4
 800dfac:	4610      	mov	r0, r2
 800dfae:	4619      	mov	r1, r3
 800dfb0:	f000 fa5a 	bl	800e468 <TIM_Base_SetConfig>
   
  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 800dfb4:	687b      	ldr	r3, [r7, #4]
 800dfb6:	2201      	movs	r2, #1
 800dfb8:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  return HAL_OK;
 800dfbc:	2300      	movs	r3, #0
}
 800dfbe:	4618      	mov	r0, r3
 800dfc0:	3708      	adds	r7, #8
 800dfc2:	46bd      	mov	sp, r7
 800dfc4:	bd80      	pop	{r7, pc}
 800dfc6:	bf00      	nop

0800dfc8 <HAL_TIM_IC_MspInit>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
{
 800dfc8:	b480      	push	{r7}
 800dfca:	b083      	sub	sp, #12
 800dfcc:	af00      	add	r7, sp, #0
 800dfce:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIM_IC_MspInit could be implemented in the user file
   */
}
 800dfd0:	370c      	adds	r7, #12
 800dfd2:	46bd      	mov	sp, r7
 800dfd4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dfd8:	4770      	bx	lr
 800dfda:	bf00      	nop

0800dfdc <HAL_TIM_Encoder_Init>:
  *                the configuration information for TIM module.
  * @param  sConfig: TIM Encoder Interface configuration structure
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
{
 800dfdc:	b580      	push	{r7, lr}
 800dfde:	b086      	sub	sp, #24
 800dfe0:	af00      	add	r7, sp, #0
 800dfe2:	6078      	str	r0, [r7, #4]
 800dfe4:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr = 0;
 800dfe6:	2300      	movs	r3, #0
 800dfe8:	617b      	str	r3, [r7, #20]
  uint32_t tmpccmr1 = 0;
 800dfea:	2300      	movs	r3, #0
 800dfec:	613b      	str	r3, [r7, #16]
  uint32_t tmpccer = 0;
 800dfee:	2300      	movs	r3, #0
 800dff0:	60fb      	str	r3, [r7, #12]
  
  /* Check the TIM handle allocation */
  if(htim == NULL)
 800dff2:	687b      	ldr	r3, [r7, #4]
 800dff4:	2b00      	cmp	r3, #0
 800dff6:	d101      	bne.n	800dffc <HAL_TIM_Encoder_Init+0x20>
  {
    return HAL_ERROR;
 800dff8:	2301      	movs	r3, #1
 800dffa:	e07b      	b.n	800e0f4 <HAL_TIM_Encoder_Init+0x118>
  assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
  assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
  assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
  assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));

  if(htim->State == HAL_TIM_STATE_RESET)
 800dffc:	687b      	ldr	r3, [r7, #4]
 800dffe:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 800e002:	b2db      	uxtb	r3, r3
 800e004:	2b00      	cmp	r3, #0
 800e006:	d106      	bne.n	800e016 <HAL_TIM_Encoder_Init+0x3a>
  { 
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;  
 800e008:	687b      	ldr	r3, [r7, #4]
 800e00a:	2200      	movs	r2, #0
 800e00c:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_Encoder_MspInit(htim);
 800e010:	6878      	ldr	r0, [r7, #4]
 800e012:	f005 f8eb 	bl	80131ec <HAL_TIM_Encoder_MspInit>
  }
  
  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;   
 800e016:	687b      	ldr	r3, [r7, #4]
 800e018:	2202      	movs	r2, #2
 800e01a:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    
  /* Reset the SMS bits */
  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
 800e01e:	687b      	ldr	r3, [r7, #4]
 800e020:	681a      	ldr	r2, [r3, #0]
 800e022:	687b      	ldr	r3, [r7, #4]
 800e024:	681b      	ldr	r3, [r3, #0]
 800e026:	6899      	ldr	r1, [r3, #8]
 800e028:	4b34      	ldr	r3, [pc, #208]	; (800e0fc <HAL_TIM_Encoder_Init+0x120>)
 800e02a:	400b      	ands	r3, r1
 800e02c:	6093      	str	r3, [r2, #8]
  
  /* Configure the Time base in the Encoder Mode */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);  
 800e02e:	687b      	ldr	r3, [r7, #4]
 800e030:	681a      	ldr	r2, [r3, #0]
 800e032:	687b      	ldr	r3, [r7, #4]
 800e034:	3304      	adds	r3, #4
 800e036:	4610      	mov	r0, r2
 800e038:	4619      	mov	r1, r3
 800e03a:	f000 fa15 	bl	800e468 <TIM_Base_SetConfig>
  
  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 800e03e:	687b      	ldr	r3, [r7, #4]
 800e040:	681b      	ldr	r3, [r3, #0]
 800e042:	689b      	ldr	r3, [r3, #8]
 800e044:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = htim->Instance->CCMR1;
 800e046:	687b      	ldr	r3, [r7, #4]
 800e048:	681b      	ldr	r3, [r3, #0]
 800e04a:	699b      	ldr	r3, [r3, #24]
 800e04c:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCER register value */
  tmpccer = htim->Instance->CCER;
 800e04e:	687b      	ldr	r3, [r7, #4]
 800e050:	681b      	ldr	r3, [r3, #0]
 800e052:	6a1b      	ldr	r3, [r3, #32]
 800e054:	60fb      	str	r3, [r7, #12]

  /* Set the encoder Mode */
  tmpsmcr |= sConfig->EncoderMode;
 800e056:	683b      	ldr	r3, [r7, #0]
 800e058:	681b      	ldr	r3, [r3, #0]
 800e05a:	697a      	ldr	r2, [r7, #20]
 800e05c:	4313      	orrs	r3, r2
 800e05e:	617b      	str	r3, [r7, #20]

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
 800e060:	693a      	ldr	r2, [r7, #16]
 800e062:	4b27      	ldr	r3, [pc, #156]	; (800e100 <HAL_TIM_Encoder_Init+0x124>)
 800e064:	4013      	ands	r3, r2
 800e066:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
 800e068:	683b      	ldr	r3, [r7, #0]
 800e06a:	689a      	ldr	r2, [r3, #8]
 800e06c:	683b      	ldr	r3, [r7, #0]
 800e06e:	699b      	ldr	r3, [r3, #24]
 800e070:	021b      	lsls	r3, r3, #8
 800e072:	4313      	orrs	r3, r2
 800e074:	693a      	ldr	r2, [r7, #16]
 800e076:	4313      	orrs	r3, r2
 800e078:	613b      	str	r3, [r7, #16]
  
  /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
  tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
 800e07a:	693a      	ldr	r2, [r7, #16]
 800e07c:	4b21      	ldr	r3, [pc, #132]	; (800e104 <HAL_TIM_Encoder_Init+0x128>)
 800e07e:	4013      	ands	r3, r2
 800e080:	613b      	str	r3, [r7, #16]
  tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
 800e082:	693a      	ldr	r2, [r7, #16]
 800e084:	4b20      	ldr	r3, [pc, #128]	; (800e108 <HAL_TIM_Encoder_Init+0x12c>)
 800e086:	4013      	ands	r3, r2
 800e088:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8);
 800e08a:	683b      	ldr	r3, [r7, #0]
 800e08c:	68da      	ldr	r2, [r3, #12]
 800e08e:	683b      	ldr	r3, [r7, #0]
 800e090:	69db      	ldr	r3, [r3, #28]
 800e092:	021b      	lsls	r3, r3, #8
 800e094:	4313      	orrs	r3, r2
 800e096:	693a      	ldr	r2, [r7, #16]
 800e098:	4313      	orrs	r3, r2
 800e09a:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
 800e09c:	683b      	ldr	r3, [r7, #0]
 800e09e:	691b      	ldr	r3, [r3, #16]
 800e0a0:	011a      	lsls	r2, r3, #4
 800e0a2:	683b      	ldr	r3, [r7, #0]
 800e0a4:	6a1b      	ldr	r3, [r3, #32]
 800e0a6:	031b      	lsls	r3, r3, #12
 800e0a8:	4313      	orrs	r3, r2
 800e0aa:	693a      	ldr	r2, [r7, #16]
 800e0ac:	4313      	orrs	r3, r2
 800e0ae:	613b      	str	r3, [r7, #16]

  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
 800e0b0:	68fb      	ldr	r3, [r7, #12]
 800e0b2:	f023 0322 	bic.w	r3, r3, #34	; 0x22
 800e0b6:	60fb      	str	r3, [r7, #12]
  tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
 800e0b8:	68fb      	ldr	r3, [r7, #12]
 800e0ba:	f023 0388 	bic.w	r3, r3, #136	; 0x88
 800e0be:	60fb      	str	r3, [r7, #12]
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
 800e0c0:	683b      	ldr	r3, [r7, #0]
 800e0c2:	685a      	ldr	r2, [r3, #4]
 800e0c4:	683b      	ldr	r3, [r7, #0]
 800e0c6:	695b      	ldr	r3, [r3, #20]
 800e0c8:	011b      	lsls	r3, r3, #4
 800e0ca:	4313      	orrs	r3, r2
 800e0cc:	68fa      	ldr	r2, [r7, #12]
 800e0ce:	4313      	orrs	r3, r2
 800e0d0:	60fb      	str	r3, [r7, #12]
  
  /* Write to TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;
 800e0d2:	687b      	ldr	r3, [r7, #4]
 800e0d4:	681b      	ldr	r3, [r3, #0]
 800e0d6:	697a      	ldr	r2, [r7, #20]
 800e0d8:	609a      	str	r2, [r3, #8]

  /* Write to TIMx CCMR1 */
  htim->Instance->CCMR1 = tmpccmr1;
 800e0da:	687b      	ldr	r3, [r7, #4]
 800e0dc:	681b      	ldr	r3, [r3, #0]
 800e0de:	693a      	ldr	r2, [r7, #16]
 800e0e0:	619a      	str	r2, [r3, #24]

  /* Write to TIMx CCER */
  htim->Instance->CCER = tmpccer;
 800e0e2:	687b      	ldr	r3, [r7, #4]
 800e0e4:	681b      	ldr	r3, [r3, #0]
 800e0e6:	68fa      	ldr	r2, [r7, #12]
 800e0e8:	621a      	str	r2, [r3, #32]
  
  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 800e0ea:	687b      	ldr	r3, [r7, #4]
 800e0ec:	2201      	movs	r2, #1
 800e0ee:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  return HAL_OK;
 800e0f2:	2300      	movs	r3, #0
}
 800e0f4:	4618      	mov	r0, r3
 800e0f6:	3718      	adds	r7, #24
 800e0f8:	46bd      	mov	sp, r7
 800e0fa:	bd80      	pop	{r7, pc}
 800e0fc:	fffefff8 	.word	0xfffefff8
 800e100:	fffffcfc 	.word	0xfffffcfc
 800e104:	fffff3f3 	.word	0xfffff3f3
 800e108:	ffff0f0f 	.word	0xffff0f0f

0800e10c <HAL_TIM_Encoder_DeInit>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
{
 800e10c:	b580      	push	{r7, lr}
 800e10e:	b082      	sub	sp, #8
 800e110:	af00      	add	r7, sp, #0
 800e112:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  
  htim->State = HAL_TIM_STATE_BUSY;
 800e114:	687b      	ldr	r3, [r7, #4]
 800e116:	2202      	movs	r2, #2
 800e118:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  /* Disable the TIM Peripheral Clock */
  __HAL_TIM_DISABLE(htim);
 800e11c:	687b      	ldr	r3, [r7, #4]
 800e11e:	681b      	ldr	r3, [r3, #0]
 800e120:	6a1a      	ldr	r2, [r3, #32]
 800e122:	f241 1311 	movw	r3, #4369	; 0x1111
 800e126:	4013      	ands	r3, r2
 800e128:	2b00      	cmp	r3, #0
 800e12a:	d10f      	bne.n	800e14c <HAL_TIM_Encoder_DeInit+0x40>
 800e12c:	687b      	ldr	r3, [r7, #4]
 800e12e:	681b      	ldr	r3, [r3, #0]
 800e130:	6a1a      	ldr	r2, [r3, #32]
 800e132:	f240 4344 	movw	r3, #1092	; 0x444
 800e136:	4013      	ands	r3, r2
 800e138:	2b00      	cmp	r3, #0
 800e13a:	d107      	bne.n	800e14c <HAL_TIM_Encoder_DeInit+0x40>
 800e13c:	687b      	ldr	r3, [r7, #4]
 800e13e:	681b      	ldr	r3, [r3, #0]
 800e140:	687a      	ldr	r2, [r7, #4]
 800e142:	6812      	ldr	r2, [r2, #0]
 800e144:	6812      	ldr	r2, [r2, #0]
 800e146:	f022 0201 	bic.w	r2, r2, #1
 800e14a:	601a      	str	r2, [r3, #0]
  
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_TIM_Encoder_MspDeInit(htim);
 800e14c:	6878      	ldr	r0, [r7, #4]
 800e14e:	f005 f88b 	bl	8013268 <HAL_TIM_Encoder_MspDeInit>
    
  /* Change TIM state */  
  htim->State = HAL_TIM_STATE_RESET;
 800e152:	687b      	ldr	r3, [r7, #4]
 800e154:	2200      	movs	r2, #0
 800e156:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
 
  /* Release Lock */
  __HAL_UNLOCK(htim);
 800e15a:	687b      	ldr	r3, [r7, #4]
 800e15c:	2200      	movs	r2, #0
 800e15e:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  return HAL_OK;
 800e162:	2300      	movs	r3, #0
}
 800e164:	4618      	mov	r0, r3
 800e166:	3708      	adds	r7, #8
 800e168:	46bd      	mov	sp, r7
 800e16a:	bd80      	pop	{r7, pc}

0800e16c <HAL_TIM_Encoder_Start>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 800e16c:	b580      	push	{r7, lr}
 800e16e:	b082      	sub	sp, #8
 800e170:	af00      	add	r7, sp, #0
 800e172:	6078      	str	r0, [r7, #4]
 800e174:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
  
  /* Enable the encoder interface channels */
  switch (Channel)
 800e176:	683b      	ldr	r3, [r7, #0]
 800e178:	2b00      	cmp	r3, #0
 800e17a:	d002      	beq.n	800e182 <HAL_TIM_Encoder_Start+0x16>
 800e17c:	2b04      	cmp	r3, #4
 800e17e:	d008      	beq.n	800e192 <HAL_TIM_Encoder_Start+0x26>
 800e180:	e00f      	b.n	800e1a2 <HAL_TIM_Encoder_Start+0x36>
  {
    case TIM_CHANNEL_1:
    {
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
 800e182:	687b      	ldr	r3, [r7, #4]
 800e184:	681b      	ldr	r3, [r3, #0]
 800e186:	4618      	mov	r0, r3
 800e188:	2100      	movs	r1, #0
 800e18a:	2201      	movs	r2, #1
 800e18c:	f000 fbdc 	bl	800e948 <TIM_CCxChannelCmd>
      break; 
 800e190:	e016      	b.n	800e1c0 <HAL_TIM_Encoder_Start+0x54>
    }
    case TIM_CHANNEL_2:
    { 
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
 800e192:	687b      	ldr	r3, [r7, #4]
 800e194:	681b      	ldr	r3, [r3, #0]
 800e196:	4618      	mov	r0, r3
 800e198:	2104      	movs	r1, #4
 800e19a:	2201      	movs	r2, #1
 800e19c:	f000 fbd4 	bl	800e948 <TIM_CCxChannelCmd>
      break;
 800e1a0:	e00e      	b.n	800e1c0 <HAL_TIM_Encoder_Start+0x54>
    }  
    default :
    {
     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
 800e1a2:	687b      	ldr	r3, [r7, #4]
 800e1a4:	681b      	ldr	r3, [r3, #0]
 800e1a6:	4618      	mov	r0, r3
 800e1a8:	2100      	movs	r1, #0
 800e1aa:	2201      	movs	r2, #1
 800e1ac:	f000 fbcc 	bl	800e948 <TIM_CCxChannelCmd>
     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
 800e1b0:	687b      	ldr	r3, [r7, #4]
 800e1b2:	681b      	ldr	r3, [r3, #0]
 800e1b4:	4618      	mov	r0, r3
 800e1b6:	2104      	movs	r1, #4
 800e1b8:	2201      	movs	r2, #1
 800e1ba:	f000 fbc5 	bl	800e948 <TIM_CCxChannelCmd>
     break; 
 800e1be:	bf00      	nop
    }
  }  
  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 800e1c0:	687b      	ldr	r3, [r7, #4]
 800e1c2:	681b      	ldr	r3, [r3, #0]
 800e1c4:	687a      	ldr	r2, [r7, #4]
 800e1c6:	6812      	ldr	r2, [r2, #0]
 800e1c8:	6812      	ldr	r2, [r2, #0]
 800e1ca:	f042 0201 	orr.w	r2, r2, #1
 800e1ce:	601a      	str	r2, [r3, #0]
  
  /* Return function status */
  return HAL_OK;
 800e1d0:	2300      	movs	r3, #0
}
 800e1d2:	4618      	mov	r0, r3
 800e1d4:	3708      	adds	r7, #8
 800e1d6:	46bd      	mov	sp, r7
 800e1d8:	bd80      	pop	{r7, pc}
 800e1da:	bf00      	nop

0800e1dc <HAL_TIM_IRQHandler>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 800e1dc:	b580      	push	{r7, lr}
 800e1de:	b082      	sub	sp, #8
 800e1e0:	af00      	add	r7, sp, #0
 800e1e2:	6078      	str	r0, [r7, #4]
  /* Capture compare 1 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 800e1e4:	687b      	ldr	r3, [r7, #4]
 800e1e6:	681b      	ldr	r3, [r3, #0]
 800e1e8:	691b      	ldr	r3, [r3, #16]
 800e1ea:	f003 0302 	and.w	r3, r3, #2
 800e1ee:	2b00      	cmp	r3, #0
 800e1f0:	d022      	beq.n	800e238 <HAL_TIM_IRQHandler+0x5c>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
 800e1f2:	687b      	ldr	r3, [r7, #4]
 800e1f4:	681b      	ldr	r3, [r3, #0]
 800e1f6:	68db      	ldr	r3, [r3, #12]
 800e1f8:	f003 0302 	and.w	r3, r3, #2
 800e1fc:	2b00      	cmp	r3, #0
 800e1fe:	d01b      	beq.n	800e238 <HAL_TIM_IRQHandler+0x5c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 800e200:	687b      	ldr	r3, [r7, #4]
 800e202:	681b      	ldr	r3, [r3, #0]
 800e204:	f06f 0202 	mvn.w	r2, #2
 800e208:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800e20a:	687b      	ldr	r3, [r7, #4]
 800e20c:	2201      	movs	r2, #1
 800e20e:	761a      	strb	r2, [r3, #24]
        
        /* Input capture event */
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
 800e210:	687b      	ldr	r3, [r7, #4]
 800e212:	681b      	ldr	r3, [r3, #0]
 800e214:	699b      	ldr	r3, [r3, #24]
 800e216:	f003 0303 	and.w	r3, r3, #3
 800e21a:	2b00      	cmp	r3, #0
 800e21c:	d003      	beq.n	800e226 <HAL_TIM_IRQHandler+0x4a>
        {
          HAL_TIM_IC_CaptureCallback(htim);
 800e21e:	6878      	ldr	r0, [r7, #4]
 800e220:	f000 f904 	bl	800e42c <HAL_TIM_IC_CaptureCallback>
 800e224:	e005      	b.n	800e232 <HAL_TIM_IRQHandler+0x56>
        }
        /* Output compare event */
        else
        {
          HAL_TIM_OC_DelayElapsedCallback(htim);
 800e226:	6878      	ldr	r0, [r7, #4]
 800e228:	f000 f8f6 	bl	800e418 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 800e22c:	6878      	ldr	r0, [r7, #4]
 800e22e:	f000 f907 	bl	800e440 <HAL_TIM_PWM_PulseFinishedCallback>
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800e232:	687b      	ldr	r3, [r7, #4]
 800e234:	2200      	movs	r2, #0
 800e236:	761a      	strb	r2, [r3, #24]
      }
    }
  }
  /* Capture compare 2 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 800e238:	687b      	ldr	r3, [r7, #4]
 800e23a:	681b      	ldr	r3, [r3, #0]
 800e23c:	691b      	ldr	r3, [r3, #16]
 800e23e:	f003 0304 	and.w	r3, r3, #4
 800e242:	2b00      	cmp	r3, #0
 800e244:	d022      	beq.n	800e28c <HAL_TIM_IRQHandler+0xb0>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
 800e246:	687b      	ldr	r3, [r7, #4]
 800e248:	681b      	ldr	r3, [r3, #0]
 800e24a:	68db      	ldr	r3, [r3, #12]
 800e24c:	f003 0304 	and.w	r3, r3, #4
 800e250:	2b00      	cmp	r3, #0
 800e252:	d01b      	beq.n	800e28c <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 800e254:	687b      	ldr	r3, [r7, #4]
 800e256:	681b      	ldr	r3, [r3, #0]
 800e258:	f06f 0204 	mvn.w	r2, #4
 800e25c:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800e25e:	687b      	ldr	r3, [r7, #4]
 800e260:	2202      	movs	r2, #2
 800e262:	761a      	strb	r2, [r3, #24]
      /* Input capture event */
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
 800e264:	687b      	ldr	r3, [r7, #4]
 800e266:	681b      	ldr	r3, [r3, #0]
 800e268:	699b      	ldr	r3, [r3, #24]
 800e26a:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800e26e:	2b00      	cmp	r3, #0
 800e270:	d003      	beq.n	800e27a <HAL_TIM_IRQHandler+0x9e>
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 800e272:	6878      	ldr	r0, [r7, #4]
 800e274:	f000 f8da 	bl	800e42c <HAL_TIM_IC_CaptureCallback>
 800e278:	e005      	b.n	800e286 <HAL_TIM_IRQHandler+0xaa>
      }
      /* Output compare event */
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800e27a:	6878      	ldr	r0, [r7, #4]
 800e27c:	f000 f8cc 	bl	800e418 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800e280:	6878      	ldr	r0, [r7, #4]
 800e282:	f000 f8dd 	bl	800e440 <HAL_TIM_PWM_PulseFinishedCallback>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800e286:	687b      	ldr	r3, [r7, #4]
 800e288:	2200      	movs	r2, #0
 800e28a:	761a      	strb	r2, [r3, #24]
    }
  }
  /* Capture compare 3 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 800e28c:	687b      	ldr	r3, [r7, #4]
 800e28e:	681b      	ldr	r3, [r3, #0]
 800e290:	691b      	ldr	r3, [r3, #16]
 800e292:	f003 0308 	and.w	r3, r3, #8
 800e296:	2b00      	cmp	r3, #0
 800e298:	d022      	beq.n	800e2e0 <HAL_TIM_IRQHandler+0x104>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
 800e29a:	687b      	ldr	r3, [r7, #4]
 800e29c:	681b      	ldr	r3, [r3, #0]
 800e29e:	68db      	ldr	r3, [r3, #12]
 800e2a0:	f003 0308 	and.w	r3, r3, #8
 800e2a4:	2b00      	cmp	r3, #0
 800e2a6:	d01b      	beq.n	800e2e0 <HAL_TIM_IRQHandler+0x104>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 800e2a8:	687b      	ldr	r3, [r7, #4]
 800e2aa:	681b      	ldr	r3, [r3, #0]
 800e2ac:	f06f 0208 	mvn.w	r2, #8
 800e2b0:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800e2b2:	687b      	ldr	r3, [r7, #4]
 800e2b4:	2204      	movs	r2, #4
 800e2b6:	761a      	strb	r2, [r3, #24]
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
 800e2b8:	687b      	ldr	r3, [r7, #4]
 800e2ba:	681b      	ldr	r3, [r3, #0]
 800e2bc:	69db      	ldr	r3, [r3, #28]
 800e2be:	f003 0303 	and.w	r3, r3, #3
 800e2c2:	2b00      	cmp	r3, #0
 800e2c4:	d003      	beq.n	800e2ce <HAL_TIM_IRQHandler+0xf2>
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 800e2c6:	6878      	ldr	r0, [r7, #4]
 800e2c8:	f000 f8b0 	bl	800e42c <HAL_TIM_IC_CaptureCallback>
 800e2cc:	e005      	b.n	800e2da <HAL_TIM_IRQHandler+0xfe>
      }
      /* Output compare event */
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800e2ce:	6878      	ldr	r0, [r7, #4]
 800e2d0:	f000 f8a2 	bl	800e418 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim); 
 800e2d4:	6878      	ldr	r0, [r7, #4]
 800e2d6:	f000 f8b3 	bl	800e440 <HAL_TIM_PWM_PulseFinishedCallback>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800e2da:	687b      	ldr	r3, [r7, #4]
 800e2dc:	2200      	movs	r2, #0
 800e2de:	761a      	strb	r2, [r3, #24]
    }
  }
  /* Capture compare 4 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 800e2e0:	687b      	ldr	r3, [r7, #4]
 800e2e2:	681b      	ldr	r3, [r3, #0]
 800e2e4:	691b      	ldr	r3, [r3, #16]
 800e2e6:	f003 0310 	and.w	r3, r3, #16
 800e2ea:	2b00      	cmp	r3, #0
 800e2ec:	d022      	beq.n	800e334 <HAL_TIM_IRQHandler+0x158>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
 800e2ee:	687b      	ldr	r3, [r7, #4]
 800e2f0:	681b      	ldr	r3, [r3, #0]
 800e2f2:	68db      	ldr	r3, [r3, #12]
 800e2f4:	f003 0310 	and.w	r3, r3, #16
 800e2f8:	2b00      	cmp	r3, #0
 800e2fa:	d01b      	beq.n	800e334 <HAL_TIM_IRQHandler+0x158>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 800e2fc:	687b      	ldr	r3, [r7, #4]
 800e2fe:	681b      	ldr	r3, [r3, #0]
 800e300:	f06f 0210 	mvn.w	r2, #16
 800e304:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800e306:	687b      	ldr	r3, [r7, #4]
 800e308:	2208      	movs	r2, #8
 800e30a:	761a      	strb	r2, [r3, #24]
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
 800e30c:	687b      	ldr	r3, [r7, #4]
 800e30e:	681b      	ldr	r3, [r3, #0]
 800e310:	69db      	ldr	r3, [r3, #28]
 800e312:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800e316:	2b00      	cmp	r3, #0
 800e318:	d003      	beq.n	800e322 <HAL_TIM_IRQHandler+0x146>
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 800e31a:	6878      	ldr	r0, [r7, #4]
 800e31c:	f000 f886 	bl	800e42c <HAL_TIM_IC_CaptureCallback>
 800e320:	e005      	b.n	800e32e <HAL_TIM_IRQHandler+0x152>
      }
      /* Output compare event */
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800e322:	6878      	ldr	r0, [r7, #4]
 800e324:	f000 f878 	bl	800e418 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800e328:	6878      	ldr	r0, [r7, #4]
 800e32a:	f000 f889 	bl	800e440 <HAL_TIM_PWM_PulseFinishedCallback>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800e32e:	687b      	ldr	r3, [r7, #4]
 800e330:	2200      	movs	r2, #0
 800e332:	761a      	strb	r2, [r3, #24]
    }
  }
  /* TIM Update event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 800e334:	687b      	ldr	r3, [r7, #4]
 800e336:	681b      	ldr	r3, [r3, #0]
 800e338:	691b      	ldr	r3, [r3, #16]
 800e33a:	f003 0301 	and.w	r3, r3, #1
 800e33e:	2b00      	cmp	r3, #0
 800e340:	d00e      	beq.n	800e360 <HAL_TIM_IRQHandler+0x184>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
 800e342:	687b      	ldr	r3, [r7, #4]
 800e344:	681b      	ldr	r3, [r3, #0]
 800e346:	68db      	ldr	r3, [r3, #12]
 800e348:	f003 0301 	and.w	r3, r3, #1
 800e34c:	2b00      	cmp	r3, #0
 800e34e:	d007      	beq.n	800e360 <HAL_TIM_IRQHandler+0x184>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 800e350:	687b      	ldr	r3, [r7, #4]
 800e352:	681b      	ldr	r3, [r3, #0]
 800e354:	f06f 0201 	mvn.w	r2, #1
 800e358:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 800e35a:	6878      	ldr	r0, [r7, #4]
 800e35c:	f004 ff0c 	bl	8013178 <HAL_TIM_PeriodElapsedCallback>
    }
  }
  /* TIM Break input event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 800e360:	687b      	ldr	r3, [r7, #4]
 800e362:	681b      	ldr	r3, [r3, #0]
 800e364:	691b      	ldr	r3, [r3, #16]
 800e366:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800e36a:	2b00      	cmp	r3, #0
 800e36c:	d00e      	beq.n	800e38c <HAL_TIM_IRQHandler+0x1b0>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
 800e36e:	687b      	ldr	r3, [r7, #4]
 800e370:	681b      	ldr	r3, [r3, #0]
 800e372:	68db      	ldr	r3, [r3, #12]
 800e374:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800e378:	2b00      	cmp	r3, #0
 800e37a:	d007      	beq.n	800e38c <HAL_TIM_IRQHandler+0x1b0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 800e37c:	687b      	ldr	r3, [r7, #4]
 800e37e:	681b      	ldr	r3, [r3, #0]
 800e380:	f06f 0280 	mvn.w	r2, #128	; 0x80
 800e384:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 800e386:	6878      	ldr	r0, [r7, #4]
 800e388:	f005 fa4e 	bl	8013828 <HAL_TIMEx_BreakCallback>
    }
  }
  
    /* TIM Break input event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 800e38c:	687b      	ldr	r3, [r7, #4]
 800e38e:	681b      	ldr	r3, [r3, #0]
 800e390:	691b      	ldr	r3, [r3, #16]
 800e392:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800e396:	2b00      	cmp	r3, #0
 800e398:	d00e      	beq.n	800e3b8 <HAL_TIM_IRQHandler+0x1dc>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
 800e39a:	687b      	ldr	r3, [r7, #4]
 800e39c:	681b      	ldr	r3, [r3, #0]
 800e39e:	68db      	ldr	r3, [r3, #12]
 800e3a0:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800e3a4:	2b00      	cmp	r3, #0
 800e3a6:	d007      	beq.n	800e3b8 <HAL_TIM_IRQHandler+0x1dc>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 800e3a8:	687b      	ldr	r3, [r7, #4]
 800e3aa:	681b      	ldr	r3, [r3, #0]
 800e3ac:	f06f 0280 	mvn.w	r2, #128	; 0x80
 800e3b0:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 800e3b2:	6878      	ldr	r0, [r7, #4]
 800e3b4:	f005 fa38 	bl	8013828 <HAL_TIMEx_BreakCallback>
    }
  }

  /* TIM Trigger detection event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 800e3b8:	687b      	ldr	r3, [r7, #4]
 800e3ba:	681b      	ldr	r3, [r3, #0]
 800e3bc:	691b      	ldr	r3, [r3, #16]
 800e3be:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800e3c2:	2b00      	cmp	r3, #0
 800e3c4:	d00e      	beq.n	800e3e4 <HAL_TIM_IRQHandler+0x208>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
 800e3c6:	687b      	ldr	r3, [r7, #4]
 800e3c8:	681b      	ldr	r3, [r3, #0]
 800e3ca:	68db      	ldr	r3, [r3, #12]
 800e3cc:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800e3d0:	2b00      	cmp	r3, #0
 800e3d2:	d007      	beq.n	800e3e4 <HAL_TIM_IRQHandler+0x208>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 800e3d4:	687b      	ldr	r3, [r7, #4]
 800e3d6:	681b      	ldr	r3, [r3, #0]
 800e3d8:	f06f 0240 	mvn.w	r2, #64	; 0x40
 800e3dc:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 800e3de:	6878      	ldr	r0, [r7, #4]
 800e3e0:	f000 f838 	bl	800e454 <HAL_TIM_TriggerCallback>
    }
  }
  /* TIM commutation event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 800e3e4:	687b      	ldr	r3, [r7, #4]
 800e3e6:	681b      	ldr	r3, [r3, #0]
 800e3e8:	691b      	ldr	r3, [r3, #16]
 800e3ea:	f003 0320 	and.w	r3, r3, #32
 800e3ee:	2b00      	cmp	r3, #0
 800e3f0:	d00e      	beq.n	800e410 <HAL_TIM_IRQHandler+0x234>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
 800e3f2:	687b      	ldr	r3, [r7, #4]
 800e3f4:	681b      	ldr	r3, [r3, #0]
 800e3f6:	68db      	ldr	r3, [r3, #12]
 800e3f8:	f003 0320 	and.w	r3, r3, #32
 800e3fc:	2b00      	cmp	r3, #0
 800e3fe:	d007      	beq.n	800e410 <HAL_TIM_IRQHandler+0x234>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 800e400:	687b      	ldr	r3, [r7, #4]
 800e402:	681b      	ldr	r3, [r3, #0]
 800e404:	f06f 0220 	mvn.w	r2, #32
 800e408:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutationCallback(htim);
 800e40a:	6878      	ldr	r0, [r7, #4]
 800e40c:	f000 fc8c 	bl	800ed28 <HAL_TIMEx_CommutationCallback>
    }
  }
}
 800e410:	3708      	adds	r7, #8
 800e412:	46bd      	mov	sp, r7
 800e414:	bd80      	pop	{r7, pc}
 800e416:	bf00      	nop

0800e418 <HAL_TIM_OC_DelayElapsedCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 800e418:	b480      	push	{r7}
 800e41a:	b083      	sub	sp, #12
 800e41c:	af00      	add	r7, sp, #0
 800e41e:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 800e420:	370c      	adds	r7, #12
 800e422:	46bd      	mov	sp, r7
 800e424:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e428:	4770      	bx	lr
 800e42a:	bf00      	nop

0800e42c <HAL_TIM_IC_CaptureCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 800e42c:	b480      	push	{r7}
 800e42e:	b083      	sub	sp, #12
 800e430:	af00      	add	r7, sp, #0
 800e432:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 800e434:	370c      	adds	r7, #12
 800e436:	46bd      	mov	sp, r7
 800e438:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e43c:	4770      	bx	lr
 800e43e:	bf00      	nop

0800e440 <HAL_TIM_PWM_PulseFinishedCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 800e440:	b480      	push	{r7}
 800e442:	b083      	sub	sp, #12
 800e444:	af00      	add	r7, sp, #0
 800e446:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 800e448:	370c      	adds	r7, #12
 800e44a:	46bd      	mov	sp, r7
 800e44c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e450:	4770      	bx	lr
 800e452:	bf00      	nop

0800e454 <HAL_TIM_TriggerCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 800e454:	b480      	push	{r7}
 800e456:	b083      	sub	sp, #12
 800e458:	af00      	add	r7, sp, #0
 800e45a:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 800e45c:	370c      	adds	r7, #12
 800e45e:	46bd      	mov	sp, r7
 800e460:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e464:	4770      	bx	lr
 800e466:	bf00      	nop

0800e468 <TIM_Base_SetConfig>:
  * @param  TIMx: TIM peripheral
  * @param  Structure: pointer on TIM Time Base required parameters  
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 800e468:	b480      	push	{r7}
 800e46a:	b085      	sub	sp, #20
 800e46c:	af00      	add	r7, sp, #0
 800e46e:	6078      	str	r0, [r7, #4]
 800e470:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1 = 0;
 800e472:	2300      	movs	r3, #0
 800e474:	60fb      	str	r3, [r7, #12]
  tmpcr1 = TIMx->CR1;
 800e476:	687b      	ldr	r3, [r7, #4]
 800e478:	681b      	ldr	r3, [r3, #0]
 800e47a:	60fb      	str	r3, [r7, #12]
  
  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
 800e47c:	687b      	ldr	r3, [r7, #4]
 800e47e:	4a43      	ldr	r2, [pc, #268]	; (800e58c <TIM_Base_SetConfig+0x124>)
 800e480:	4293      	cmp	r3, r2
 800e482:	d013      	beq.n	800e4ac <TIM_Base_SetConfig+0x44>
 800e484:	687b      	ldr	r3, [r7, #4]
 800e486:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800e48a:	d00f      	beq.n	800e4ac <TIM_Base_SetConfig+0x44>
 800e48c:	687b      	ldr	r3, [r7, #4]
 800e48e:	4a40      	ldr	r2, [pc, #256]	; (800e590 <TIM_Base_SetConfig+0x128>)
 800e490:	4293      	cmp	r3, r2
 800e492:	d00b      	beq.n	800e4ac <TIM_Base_SetConfig+0x44>
 800e494:	687b      	ldr	r3, [r7, #4]
 800e496:	4a3f      	ldr	r2, [pc, #252]	; (800e594 <TIM_Base_SetConfig+0x12c>)
 800e498:	4293      	cmp	r3, r2
 800e49a:	d007      	beq.n	800e4ac <TIM_Base_SetConfig+0x44>
 800e49c:	687b      	ldr	r3, [r7, #4]
 800e49e:	4a3e      	ldr	r2, [pc, #248]	; (800e598 <TIM_Base_SetConfig+0x130>)
 800e4a0:	4293      	cmp	r3, r2
 800e4a2:	d003      	beq.n	800e4ac <TIM_Base_SetConfig+0x44>
 800e4a4:	687b      	ldr	r3, [r7, #4]
 800e4a6:	4a3d      	ldr	r2, [pc, #244]	; (800e59c <TIM_Base_SetConfig+0x134>)
 800e4a8:	4293      	cmp	r3, r2
 800e4aa:	d101      	bne.n	800e4b0 <TIM_Base_SetConfig+0x48>
 800e4ac:	2301      	movs	r3, #1
 800e4ae:	e000      	b.n	800e4b2 <TIM_Base_SetConfig+0x4a>
 800e4b0:	2300      	movs	r3, #0
 800e4b2:	2b00      	cmp	r3, #0
 800e4b4:	d008      	beq.n	800e4c8 <TIM_Base_SetConfig+0x60>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800e4b6:	68fb      	ldr	r3, [r7, #12]
 800e4b8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800e4bc:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 800e4be:	683b      	ldr	r3, [r7, #0]
 800e4c0:	685b      	ldr	r3, [r3, #4]
 800e4c2:	68fa      	ldr	r2, [r7, #12]
 800e4c4:	4313      	orrs	r3, r2
 800e4c6:	60fb      	str	r3, [r7, #12]
  }
 
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
 800e4c8:	687b      	ldr	r3, [r7, #4]
 800e4ca:	4a30      	ldr	r2, [pc, #192]	; (800e58c <TIM_Base_SetConfig+0x124>)
 800e4cc:	4293      	cmp	r3, r2
 800e4ce:	d02b      	beq.n	800e528 <TIM_Base_SetConfig+0xc0>
 800e4d0:	687b      	ldr	r3, [r7, #4]
 800e4d2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800e4d6:	d027      	beq.n	800e528 <TIM_Base_SetConfig+0xc0>
 800e4d8:	687b      	ldr	r3, [r7, #4]
 800e4da:	4a2d      	ldr	r2, [pc, #180]	; (800e590 <TIM_Base_SetConfig+0x128>)
 800e4dc:	4293      	cmp	r3, r2
 800e4de:	d023      	beq.n	800e528 <TIM_Base_SetConfig+0xc0>
 800e4e0:	687b      	ldr	r3, [r7, #4]
 800e4e2:	4a2c      	ldr	r2, [pc, #176]	; (800e594 <TIM_Base_SetConfig+0x12c>)
 800e4e4:	4293      	cmp	r3, r2
 800e4e6:	d01f      	beq.n	800e528 <TIM_Base_SetConfig+0xc0>
 800e4e8:	687b      	ldr	r3, [r7, #4]
 800e4ea:	4a2b      	ldr	r2, [pc, #172]	; (800e598 <TIM_Base_SetConfig+0x130>)
 800e4ec:	4293      	cmp	r3, r2
 800e4ee:	d01b      	beq.n	800e528 <TIM_Base_SetConfig+0xc0>
 800e4f0:	687b      	ldr	r3, [r7, #4]
 800e4f2:	4a2a      	ldr	r2, [pc, #168]	; (800e59c <TIM_Base_SetConfig+0x134>)
 800e4f4:	4293      	cmp	r3, r2
 800e4f6:	d017      	beq.n	800e528 <TIM_Base_SetConfig+0xc0>
 800e4f8:	687b      	ldr	r3, [r7, #4]
 800e4fa:	4a29      	ldr	r2, [pc, #164]	; (800e5a0 <TIM_Base_SetConfig+0x138>)
 800e4fc:	4293      	cmp	r3, r2
 800e4fe:	d013      	beq.n	800e528 <TIM_Base_SetConfig+0xc0>
 800e500:	687b      	ldr	r3, [r7, #4]
 800e502:	4a28      	ldr	r2, [pc, #160]	; (800e5a4 <TIM_Base_SetConfig+0x13c>)
 800e504:	4293      	cmp	r3, r2
 800e506:	d00f      	beq.n	800e528 <TIM_Base_SetConfig+0xc0>
 800e508:	687b      	ldr	r3, [r7, #4]
 800e50a:	4a27      	ldr	r2, [pc, #156]	; (800e5a8 <TIM_Base_SetConfig+0x140>)
 800e50c:	4293      	cmp	r3, r2
 800e50e:	d00b      	beq.n	800e528 <TIM_Base_SetConfig+0xc0>
 800e510:	687b      	ldr	r3, [r7, #4]
 800e512:	4a26      	ldr	r2, [pc, #152]	; (800e5ac <TIM_Base_SetConfig+0x144>)
 800e514:	4293      	cmp	r3, r2
 800e516:	d007      	beq.n	800e528 <TIM_Base_SetConfig+0xc0>
 800e518:	687b      	ldr	r3, [r7, #4]
 800e51a:	4a25      	ldr	r2, [pc, #148]	; (800e5b0 <TIM_Base_SetConfig+0x148>)
 800e51c:	4293      	cmp	r3, r2
 800e51e:	d003      	beq.n	800e528 <TIM_Base_SetConfig+0xc0>
 800e520:	687b      	ldr	r3, [r7, #4]
 800e522:	4a24      	ldr	r2, [pc, #144]	; (800e5b4 <TIM_Base_SetConfig+0x14c>)
 800e524:	4293      	cmp	r3, r2
 800e526:	d101      	bne.n	800e52c <TIM_Base_SetConfig+0xc4>
 800e528:	2301      	movs	r3, #1
 800e52a:	e000      	b.n	800e52e <TIM_Base_SetConfig+0xc6>
 800e52c:	2300      	movs	r3, #0
 800e52e:	2b00      	cmp	r3, #0
 800e530:	d008      	beq.n	800e544 <TIM_Base_SetConfig+0xdc>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 800e532:	68fb      	ldr	r3, [r7, #12]
 800e534:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800e538:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800e53a:	683b      	ldr	r3, [r7, #0]
 800e53c:	68db      	ldr	r3, [r3, #12]
 800e53e:	68fa      	ldr	r2, [r7, #12]
 800e540:	4313      	orrs	r3, r2
 800e542:	60fb      	str	r3, [r7, #12]
  }

  TIMx->CR1 = tmpcr1;
 800e544:	687b      	ldr	r3, [r7, #4]
 800e546:	68fa      	ldr	r2, [r7, #12]
 800e548:	601a      	str	r2, [r3, #0]

  /* Set the Auto-reload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 800e54a:	683b      	ldr	r3, [r7, #0]
 800e54c:	689a      	ldr	r2, [r3, #8]
 800e54e:	687b      	ldr	r3, [r7, #4]
 800e550:	62da      	str	r2, [r3, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 800e552:	683b      	ldr	r3, [r7, #0]
 800e554:	681a      	ldr	r2, [r3, #0]
 800e556:	687b      	ldr	r3, [r7, #4]
 800e558:	629a      	str	r2, [r3, #40]	; 0x28
    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
 800e55a:	687b      	ldr	r3, [r7, #4]
 800e55c:	4a0b      	ldr	r2, [pc, #44]	; (800e58c <TIM_Base_SetConfig+0x124>)
 800e55e:	4293      	cmp	r3, r2
 800e560:	d003      	beq.n	800e56a <TIM_Base_SetConfig+0x102>
 800e562:	687b      	ldr	r3, [r7, #4]
 800e564:	4a0d      	ldr	r2, [pc, #52]	; (800e59c <TIM_Base_SetConfig+0x134>)
 800e566:	4293      	cmp	r3, r2
 800e568:	d101      	bne.n	800e56e <TIM_Base_SetConfig+0x106>
 800e56a:	2301      	movs	r3, #1
 800e56c:	e000      	b.n	800e570 <TIM_Base_SetConfig+0x108>
 800e56e:	2300      	movs	r3, #0
 800e570:	2b00      	cmp	r3, #0
 800e572:	d003      	beq.n	800e57c <TIM_Base_SetConfig+0x114>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 800e574:	683b      	ldr	r3, [r7, #0]
 800e576:	691a      	ldr	r2, [r3, #16]
 800e578:	687b      	ldr	r3, [r7, #4]
 800e57a:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 800e57c:	687b      	ldr	r3, [r7, #4]
 800e57e:	2201      	movs	r2, #1
 800e580:	615a      	str	r2, [r3, #20]
}
 800e582:	3714      	adds	r7, #20
 800e584:	46bd      	mov	sp, r7
 800e586:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e58a:	4770      	bx	lr
 800e58c:	40010000 	.word	0x40010000
 800e590:	40000400 	.word	0x40000400
 800e594:	40000800 	.word	0x40000800
 800e598:	40000c00 	.word	0x40000c00
 800e59c:	40010400 	.word	0x40010400
 800e5a0:	40014000 	.word	0x40014000
 800e5a4:	40014400 	.word	0x40014400
 800e5a8:	40014800 	.word	0x40014800
 800e5ac:	40001800 	.word	0x40001800
 800e5b0:	40001c00 	.word	0x40001c00
 800e5b4:	40002000 	.word	0x40002000

0800e5b8 <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800e5b8:	b480      	push	{r7}
 800e5ba:	b087      	sub	sp, #28
 800e5bc:	af00      	add	r7, sp, #0
 800e5be:	6078      	str	r0, [r7, #4]
 800e5c0:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0;
 800e5c2:	2300      	movs	r3, #0
 800e5c4:	60fb      	str	r3, [r7, #12]
  uint32_t tmpccer = 0;
 800e5c6:	2300      	movs	r3, #0
 800e5c8:	617b      	str	r3, [r7, #20]
  uint32_t tmpcr2 = 0;  
 800e5ca:	2300      	movs	r3, #0
 800e5cc:	613b      	str	r3, [r7, #16]

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800e5ce:	687b      	ldr	r3, [r7, #4]
 800e5d0:	6a1b      	ldr	r3, [r3, #32]
 800e5d2:	f023 0201 	bic.w	r2, r3, #1
 800e5d6:	687b      	ldr	r3, [r7, #4]
 800e5d8:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800e5da:	687b      	ldr	r3, [r7, #4]
 800e5dc:	6a1b      	ldr	r3, [r3, #32]
 800e5de:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 800e5e0:	687b      	ldr	r3, [r7, #4]
 800e5e2:	685b      	ldr	r3, [r3, #4]
 800e5e4:	613b      	str	r3, [r7, #16]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800e5e6:	687b      	ldr	r3, [r7, #4]
 800e5e8:	699b      	ldr	r3, [r3, #24]
 800e5ea:	60fb      	str	r3, [r7, #12]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
 800e5ec:	68fa      	ldr	r2, [r7, #12]
 800e5ee:	4b29      	ldr	r3, [pc, #164]	; (800e694 <TIM_OC1_SetConfig+0xdc>)
 800e5f0:	4013      	ands	r3, r2
 800e5f2:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 800e5f4:	68fb      	ldr	r3, [r7, #12]
 800e5f6:	f023 0303 	bic.w	r3, r3, #3
 800e5fa:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800e5fc:	683b      	ldr	r3, [r7, #0]
 800e5fe:	681b      	ldr	r3, [r3, #0]
 800e600:	68fa      	ldr	r2, [r7, #12]
 800e602:	4313      	orrs	r3, r2
 800e604:	60fb      	str	r3, [r7, #12]
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 800e606:	697b      	ldr	r3, [r7, #20]
 800e608:	f023 0302 	bic.w	r3, r3, #2
 800e60c:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 800e60e:	683b      	ldr	r3, [r7, #0]
 800e610:	689b      	ldr	r3, [r3, #8]
 800e612:	697a      	ldr	r2, [r7, #20]
 800e614:	4313      	orrs	r3, r2
 800e616:	617b      	str	r3, [r7, #20]

    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 800e618:	687b      	ldr	r3, [r7, #4]
 800e61a:	4a1f      	ldr	r2, [pc, #124]	; (800e698 <TIM_OC1_SetConfig+0xe0>)
 800e61c:	4293      	cmp	r3, r2
 800e61e:	d003      	beq.n	800e628 <TIM_OC1_SetConfig+0x70>
 800e620:	687b      	ldr	r3, [r7, #4]
 800e622:	4a1e      	ldr	r2, [pc, #120]	; (800e69c <TIM_OC1_SetConfig+0xe4>)
 800e624:	4293      	cmp	r3, r2
 800e626:	d101      	bne.n	800e62c <TIM_OC1_SetConfig+0x74>
 800e628:	2301      	movs	r3, #1
 800e62a:	e000      	b.n	800e62e <TIM_OC1_SetConfig+0x76>
 800e62c:	2300      	movs	r3, #0
 800e62e:	2b00      	cmp	r3, #0
 800e630:	d01e      	beq.n	800e670 <TIM_OC1_SetConfig+0xb8>
  {   
    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 800e632:	697b      	ldr	r3, [r7, #20]
 800e634:	f023 0308 	bic.w	r3, r3, #8
 800e638:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 800e63a:	683b      	ldr	r3, [r7, #0]
 800e63c:	68db      	ldr	r3, [r3, #12]
 800e63e:	697a      	ldr	r2, [r7, #20]
 800e640:	4313      	orrs	r3, r2
 800e642:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 800e644:	697b      	ldr	r3, [r7, #20]
 800e646:	f023 0304 	bic.w	r3, r3, #4
 800e64a:	617b      	str	r3, [r7, #20]
    
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
 800e64c:	693b      	ldr	r3, [r7, #16]
 800e64e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800e652:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 800e654:	693b      	ldr	r3, [r7, #16]
 800e656:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800e65a:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
 800e65c:	683b      	ldr	r3, [r7, #0]
 800e65e:	695b      	ldr	r3, [r3, #20]
 800e660:	693a      	ldr	r2, [r7, #16]
 800e662:	4313      	orrs	r3, r2
 800e664:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 800e666:	683b      	ldr	r3, [r7, #0]
 800e668:	699b      	ldr	r3, [r3, #24]
 800e66a:	693a      	ldr	r2, [r7, #16]
 800e66c:	4313      	orrs	r3, r2
 800e66e:	613b      	str	r3, [r7, #16]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800e670:	687b      	ldr	r3, [r7, #4]
 800e672:	693a      	ldr	r2, [r7, #16]
 800e674:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800e676:	687b      	ldr	r3, [r7, #4]
 800e678:	68fa      	ldr	r2, [r7, #12]
 800e67a:	619a      	str	r2, [r3, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 800e67c:	683b      	ldr	r3, [r7, #0]
 800e67e:	685a      	ldr	r2, [r3, #4]
 800e680:	687b      	ldr	r3, [r7, #4]
 800e682:	635a      	str	r2, [r3, #52]	; 0x34
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;  
 800e684:	687b      	ldr	r3, [r7, #4]
 800e686:	697a      	ldr	r2, [r7, #20]
 800e688:	621a      	str	r2, [r3, #32]
} 
 800e68a:	371c      	adds	r7, #28
 800e68c:	46bd      	mov	sp, r7
 800e68e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e692:	4770      	bx	lr
 800e694:	fffeff8f 	.word	0xfffeff8f
 800e698:	40010000 	.word	0x40010000
 800e69c:	40010400 	.word	0x40010400

0800e6a0 <TIM_OC2_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800e6a0:	b480      	push	{r7}
 800e6a2:	b087      	sub	sp, #28
 800e6a4:	af00      	add	r7, sp, #0
 800e6a6:	6078      	str	r0, [r7, #4]
 800e6a8:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0;
 800e6aa:	2300      	movs	r3, #0
 800e6ac:	60fb      	str	r3, [r7, #12]
  uint32_t tmpccer = 0;
 800e6ae:	2300      	movs	r3, #0
 800e6b0:	617b      	str	r3, [r7, #20]
  uint32_t tmpcr2 = 0;
 800e6b2:	2300      	movs	r3, #0
 800e6b4:	613b      	str	r3, [r7, #16]
   
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800e6b6:	687b      	ldr	r3, [r7, #4]
 800e6b8:	6a1b      	ldr	r3, [r3, #32]
 800e6ba:	f023 0210 	bic.w	r2, r3, #16
 800e6be:	687b      	ldr	r3, [r7, #4]
 800e6c0:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
 800e6c2:	687b      	ldr	r3, [r7, #4]
 800e6c4:	6a1b      	ldr	r3, [r3, #32]
 800e6c6:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 800e6c8:	687b      	ldr	r3, [r7, #4]
 800e6ca:	685b      	ldr	r3, [r3, #4]
 800e6cc:	613b      	str	r3, [r7, #16]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800e6ce:	687b      	ldr	r3, [r7, #4]
 800e6d0:	699b      	ldr	r3, [r3, #24]
 800e6d2:	60fb      	str	r3, [r7, #12]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
 800e6d4:	68fa      	ldr	r2, [r7, #12]
 800e6d6:	4b2c      	ldr	r3, [pc, #176]	; (800e788 <TIM_OC2_SetConfig+0xe8>)
 800e6d8:	4013      	ands	r3, r2
 800e6da:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 800e6dc:	68fb      	ldr	r3, [r7, #12]
 800e6de:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800e6e2:	60fb      	str	r3, [r7, #12]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 800e6e4:	683b      	ldr	r3, [r7, #0]
 800e6e6:	681b      	ldr	r3, [r3, #0]
 800e6e8:	021b      	lsls	r3, r3, #8
 800e6ea:	68fa      	ldr	r2, [r7, #12]
 800e6ec:	4313      	orrs	r3, r2
 800e6ee:	60fb      	str	r3, [r7, #12]
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
 800e6f0:	697b      	ldr	r3, [r7, #20]
 800e6f2:	f023 0320 	bic.w	r3, r3, #32
 800e6f6:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4);
 800e6f8:	683b      	ldr	r3, [r7, #0]
 800e6fa:	689b      	ldr	r3, [r3, #8]
 800e6fc:	011b      	lsls	r3, r3, #4
 800e6fe:	697a      	ldr	r2, [r7, #20]
 800e700:	4313      	orrs	r3, r2
 800e702:	617b      	str	r3, [r7, #20]
    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 800e704:	687b      	ldr	r3, [r7, #4]
 800e706:	4a21      	ldr	r2, [pc, #132]	; (800e78c <TIM_OC2_SetConfig+0xec>)
 800e708:	4293      	cmp	r3, r2
 800e70a:	d003      	beq.n	800e714 <TIM_OC2_SetConfig+0x74>
 800e70c:	687b      	ldr	r3, [r7, #4]
 800e70e:	4a20      	ldr	r2, [pc, #128]	; (800e790 <TIM_OC2_SetConfig+0xf0>)
 800e710:	4293      	cmp	r3, r2
 800e712:	d101      	bne.n	800e718 <TIM_OC2_SetConfig+0x78>
 800e714:	2301      	movs	r3, #1
 800e716:	e000      	b.n	800e71a <TIM_OC2_SetConfig+0x7a>
 800e718:	2300      	movs	r3, #0
 800e71a:	2b00      	cmp	r3, #0
 800e71c:	d021      	beq.n	800e762 <TIM_OC2_SetConfig+0xc2>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
 800e71e:	697b      	ldr	r3, [r7, #20]
 800e720:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800e724:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4);
 800e726:	683b      	ldr	r3, [r7, #0]
 800e728:	68db      	ldr	r3, [r3, #12]
 800e72a:	011b      	lsls	r3, r3, #4
 800e72c:	697a      	ldr	r2, [r7, #20]
 800e72e:	4313      	orrs	r3, r2
 800e730:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC2NE;
 800e732:	697b      	ldr	r3, [r7, #20]
 800e734:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800e738:	617b      	str	r3, [r7, #20]
    
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
 800e73a:	693b      	ldr	r3, [r7, #16]
 800e73c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800e740:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 800e742:	693b      	ldr	r3, [r7, #16]
 800e744:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800e748:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2);
 800e74a:	683b      	ldr	r3, [r7, #0]
 800e74c:	695b      	ldr	r3, [r3, #20]
 800e74e:	009b      	lsls	r3, r3, #2
 800e750:	693a      	ldr	r2, [r7, #16]
 800e752:	4313      	orrs	r3, r2
 800e754:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2);
 800e756:	683b      	ldr	r3, [r7, #0]
 800e758:	699b      	ldr	r3, [r3, #24]
 800e75a:	009b      	lsls	r3, r3, #2
 800e75c:	693a      	ldr	r2, [r7, #16]
 800e75e:	4313      	orrs	r3, r2
 800e760:	613b      	str	r3, [r7, #16]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800e762:	687b      	ldr	r3, [r7, #4]
 800e764:	693a      	ldr	r2, [r7, #16]
 800e766:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800e768:	687b      	ldr	r3, [r7, #4]
 800e76a:	68fa      	ldr	r2, [r7, #12]
 800e76c:	619a      	str	r2, [r3, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 800e76e:	683b      	ldr	r3, [r7, #0]
 800e770:	685a      	ldr	r2, [r3, #4]
 800e772:	687b      	ldr	r3, [r7, #4]
 800e774:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800e776:	687b      	ldr	r3, [r7, #4]
 800e778:	697a      	ldr	r2, [r7, #20]
 800e77a:	621a      	str	r2, [r3, #32]
}
 800e77c:	371c      	adds	r7, #28
 800e77e:	46bd      	mov	sp, r7
 800e780:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e784:	4770      	bx	lr
 800e786:	bf00      	nop
 800e788:	feff8fff 	.word	0xfeff8fff
 800e78c:	40010000 	.word	0x40010000
 800e790:	40010400 	.word	0x40010400

0800e794 <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800e794:	b480      	push	{r7}
 800e796:	b087      	sub	sp, #28
 800e798:	af00      	add	r7, sp, #0
 800e79a:	6078      	str	r0, [r7, #4]
 800e79c:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0;
 800e79e:	2300      	movs	r3, #0
 800e7a0:	60fb      	str	r3, [r7, #12]
  uint32_t tmpccer = 0;
 800e7a2:	2300      	movs	r3, #0
 800e7a4:	617b      	str	r3, [r7, #20]
  uint32_t tmpcr2 = 0;   
 800e7a6:	2300      	movs	r3, #0
 800e7a8:	613b      	str	r3, [r7, #16]

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 800e7aa:	687b      	ldr	r3, [r7, #4]
 800e7ac:	6a1b      	ldr	r3, [r3, #32]
 800e7ae:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 800e7b2:	687b      	ldr	r3, [r7, #4]
 800e7b4:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800e7b6:	687b      	ldr	r3, [r7, #4]
 800e7b8:	6a1b      	ldr	r3, [r3, #32]
 800e7ba:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 800e7bc:	687b      	ldr	r3, [r7, #4]
 800e7be:	685b      	ldr	r3, [r3, #4]
 800e7c0:	613b      	str	r3, [r7, #16]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800e7c2:	687b      	ldr	r3, [r7, #4]
 800e7c4:	69db      	ldr	r3, [r3, #28]
 800e7c6:	60fb      	str	r3, [r7, #12]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
 800e7c8:	68fa      	ldr	r2, [r7, #12]
 800e7ca:	4b2b      	ldr	r3, [pc, #172]	; (800e878 <TIM_OC3_SetConfig+0xe4>)
 800e7cc:	4013      	ands	r3, r2
 800e7ce:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC3S;  
 800e7d0:	68fb      	ldr	r3, [r7, #12]
 800e7d2:	f023 0303 	bic.w	r3, r3, #3
 800e7d6:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800e7d8:	683b      	ldr	r3, [r7, #0]
 800e7da:	681b      	ldr	r3, [r3, #0]
 800e7dc:	68fa      	ldr	r2, [r7, #12]
 800e7de:	4313      	orrs	r3, r2
 800e7e0:	60fb      	str	r3, [r7, #12]
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 800e7e2:	697b      	ldr	r3, [r7, #20]
 800e7e4:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800e7e8:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8);
 800e7ea:	683b      	ldr	r3, [r7, #0]
 800e7ec:	689b      	ldr	r3, [r3, #8]
 800e7ee:	021b      	lsls	r3, r3, #8
 800e7f0:	697a      	ldr	r2, [r7, #20]
 800e7f2:	4313      	orrs	r3, r2
 800e7f4:	617b      	str	r3, [r7, #20]
    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 800e7f6:	687b      	ldr	r3, [r7, #4]
 800e7f8:	4a20      	ldr	r2, [pc, #128]	; (800e87c <TIM_OC3_SetConfig+0xe8>)
 800e7fa:	4293      	cmp	r3, r2
 800e7fc:	d003      	beq.n	800e806 <TIM_OC3_SetConfig+0x72>
 800e7fe:	687b      	ldr	r3, [r7, #4]
 800e800:	4a1f      	ldr	r2, [pc, #124]	; (800e880 <TIM_OC3_SetConfig+0xec>)
 800e802:	4293      	cmp	r3, r2
 800e804:	d101      	bne.n	800e80a <TIM_OC3_SetConfig+0x76>
 800e806:	2301      	movs	r3, #1
 800e808:	e000      	b.n	800e80c <TIM_OC3_SetConfig+0x78>
 800e80a:	2300      	movs	r3, #0
 800e80c:	2b00      	cmp	r3, #0
 800e80e:	d021      	beq.n	800e854 <TIM_OC3_SetConfig+0xc0>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 800e810:	697b      	ldr	r3, [r7, #20]
 800e812:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800e816:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8);
 800e818:	683b      	ldr	r3, [r7, #0]
 800e81a:	68db      	ldr	r3, [r3, #12]
 800e81c:	021b      	lsls	r3, r3, #8
 800e81e:	697a      	ldr	r2, [r7, #20]
 800e820:	4313      	orrs	r3, r2
 800e822:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 800e824:	697b      	ldr	r3, [r7, #20]
 800e826:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800e82a:	617b      	str	r3, [r7, #20]
    
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
 800e82c:	693b      	ldr	r3, [r7, #16]
 800e82e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800e832:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 800e834:	693b      	ldr	r3, [r7, #16]
 800e836:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800e83a:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4);
 800e83c:	683b      	ldr	r3, [r7, #0]
 800e83e:	695b      	ldr	r3, [r3, #20]
 800e840:	011b      	lsls	r3, r3, #4
 800e842:	693a      	ldr	r2, [r7, #16]
 800e844:	4313      	orrs	r3, r2
 800e846:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4);
 800e848:	683b      	ldr	r3, [r7, #0]
 800e84a:	699b      	ldr	r3, [r3, #24]
 800e84c:	011b      	lsls	r3, r3, #4
 800e84e:	693a      	ldr	r2, [r7, #16]
 800e850:	4313      	orrs	r3, r2
 800e852:	613b      	str	r3, [r7, #16]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800e854:	687b      	ldr	r3, [r7, #4]
 800e856:	693a      	ldr	r2, [r7, #16]
 800e858:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 800e85a:	687b      	ldr	r3, [r7, #4]
 800e85c:	68fa      	ldr	r2, [r7, #12]
 800e85e:	61da      	str	r2, [r3, #28]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 800e860:	683b      	ldr	r3, [r7, #0]
 800e862:	685a      	ldr	r2, [r3, #4]
 800e864:	687b      	ldr	r3, [r7, #4]
 800e866:	63da      	str	r2, [r3, #60]	; 0x3c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800e868:	687b      	ldr	r3, [r7, #4]
 800e86a:	697a      	ldr	r2, [r7, #20]
 800e86c:	621a      	str	r2, [r3, #32]
}
 800e86e:	371c      	adds	r7, #28
 800e870:	46bd      	mov	sp, r7
 800e872:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e876:	4770      	bx	lr
 800e878:	fffeff8f 	.word	0xfffeff8f
 800e87c:	40010000 	.word	0x40010000
 800e880:	40010400 	.word	0x40010400

0800e884 <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800e884:	b480      	push	{r7}
 800e886:	b087      	sub	sp, #28
 800e888:	af00      	add	r7, sp, #0
 800e88a:	6078      	str	r0, [r7, #4]
 800e88c:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0;
 800e88e:	2300      	movs	r3, #0
 800e890:	613b      	str	r3, [r7, #16]
  uint32_t tmpccer = 0;
 800e892:	2300      	movs	r3, #0
 800e894:	60fb      	str	r3, [r7, #12]
  uint32_t tmpcr2 = 0;
 800e896:	2300      	movs	r3, #0
 800e898:	617b      	str	r3, [r7, #20]

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 800e89a:	687b      	ldr	r3, [r7, #4]
 800e89c:	6a1b      	ldr	r3, [r3, #32]
 800e89e:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 800e8a2:	687b      	ldr	r3, [r7, #4]
 800e8a4:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800e8a6:	687b      	ldr	r3, [r7, #4]
 800e8a8:	6a1b      	ldr	r3, [r3, #32]
 800e8aa:	60fb      	str	r3, [r7, #12]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 800e8ac:	687b      	ldr	r3, [r7, #4]
 800e8ae:	685b      	ldr	r3, [r3, #4]
 800e8b0:	617b      	str	r3, [r7, #20]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800e8b2:	687b      	ldr	r3, [r7, #4]
 800e8b4:	69db      	ldr	r3, [r3, #28]
 800e8b6:	613b      	str	r3, [r7, #16]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
 800e8b8:	693a      	ldr	r2, [r7, #16]
 800e8ba:	4b20      	ldr	r3, [pc, #128]	; (800e93c <TIM_OC4_SetConfig+0xb8>)
 800e8bc:	4013      	ands	r3, r2
 800e8be:	613b      	str	r3, [r7, #16]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 800e8c0:	693b      	ldr	r3, [r7, #16]
 800e8c2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800e8c6:	613b      	str	r3, [r7, #16]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 800e8c8:	683b      	ldr	r3, [r7, #0]
 800e8ca:	681b      	ldr	r3, [r3, #0]
 800e8cc:	021b      	lsls	r3, r3, #8
 800e8ce:	693a      	ldr	r2, [r7, #16]
 800e8d0:	4313      	orrs	r3, r2
 800e8d2:	613b      	str	r3, [r7, #16]
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 800e8d4:	68fb      	ldr	r3, [r7, #12]
 800e8d6:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800e8da:	60fb      	str	r3, [r7, #12]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12);
 800e8dc:	683b      	ldr	r3, [r7, #0]
 800e8de:	689b      	ldr	r3, [r3, #8]
 800e8e0:	031b      	lsls	r3, r3, #12
 800e8e2:	68fa      	ldr	r2, [r7, #12]
 800e8e4:	4313      	orrs	r3, r2
 800e8e6:	60fb      	str	r3, [r7, #12]
   
  /*if((TIMx == TIM1) || (TIMx == TIM8))*/
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 800e8e8:	687b      	ldr	r3, [r7, #4]
 800e8ea:	4a15      	ldr	r2, [pc, #84]	; (800e940 <TIM_OC4_SetConfig+0xbc>)
 800e8ec:	4293      	cmp	r3, r2
 800e8ee:	d003      	beq.n	800e8f8 <TIM_OC4_SetConfig+0x74>
 800e8f0:	687b      	ldr	r3, [r7, #4]
 800e8f2:	4a14      	ldr	r2, [pc, #80]	; (800e944 <TIM_OC4_SetConfig+0xc0>)
 800e8f4:	4293      	cmp	r3, r2
 800e8f6:	d101      	bne.n	800e8fc <TIM_OC4_SetConfig+0x78>
 800e8f8:	2301      	movs	r3, #1
 800e8fa:	e000      	b.n	800e8fe <TIM_OC4_SetConfig+0x7a>
 800e8fc:	2300      	movs	r3, #0
 800e8fe:	2b00      	cmp	r3, #0
 800e900:	d009      	beq.n	800e916 <TIM_OC4_SetConfig+0x92>
  {
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 800e902:	697b      	ldr	r3, [r7, #20]
 800e904:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800e908:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6);
 800e90a:	683b      	ldr	r3, [r7, #0]
 800e90c:	695b      	ldr	r3, [r3, #20]
 800e90e:	019b      	lsls	r3, r3, #6
 800e910:	697a      	ldr	r2, [r7, #20]
 800e912:	4313      	orrs	r3, r2
 800e914:	617b      	str	r3, [r7, #20]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800e916:	687b      	ldr	r3, [r7, #4]
 800e918:	697a      	ldr	r2, [r7, #20]
 800e91a:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
 800e91c:	687b      	ldr	r3, [r7, #4]
 800e91e:	693a      	ldr	r2, [r7, #16]
 800e920:	61da      	str	r2, [r3, #28]
    
  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 800e922:	683b      	ldr	r3, [r7, #0]
 800e924:	685a      	ldr	r2, [r3, #4]
 800e926:	687b      	ldr	r3, [r7, #4]
 800e928:	641a      	str	r2, [r3, #64]	; 0x40
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800e92a:	687b      	ldr	r3, [r7, #4]
 800e92c:	68fa      	ldr	r2, [r7, #12]
 800e92e:	621a      	str	r2, [r3, #32]
}
 800e930:	371c      	adds	r7, #28
 800e932:	46bd      	mov	sp, r7
 800e934:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e938:	4770      	bx	lr
 800e93a:	bf00      	nop
 800e93c:	feff8fff 	.word	0xfeff8fff
 800e940:	40010000 	.word	0x40010000
 800e944:	40010400 	.word	0x40010400

0800e948 <TIM_CCxChannelCmd>:
  * @param  ChannelState: specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_Disable. 
  * @retval None
  */
void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
{
 800e948:	b480      	push	{r7}
 800e94a:	b087      	sub	sp, #28
 800e94c:	af00      	add	r7, sp, #0
 800e94e:	60f8      	str	r0, [r7, #12]
 800e950:	60b9      	str	r1, [r7, #8]
 800e952:	607a      	str	r2, [r7, #4]
  uint32_t tmp = 0;
 800e954:	2300      	movs	r3, #0
 800e956:	617b      	str	r3, [r7, #20]

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx)); 
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << Channel;
 800e958:	68bb      	ldr	r3, [r7, #8]
 800e95a:	2201      	movs	r2, #1
 800e95c:	fa02 f303 	lsl.w	r3, r2, r3
 800e960:	617b      	str	r3, [r7, #20]

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 800e962:	68fb      	ldr	r3, [r7, #12]
 800e964:	6a1a      	ldr	r2, [r3, #32]
 800e966:	697b      	ldr	r3, [r7, #20]
 800e968:	43db      	mvns	r3, r3
 800e96a:	401a      	ands	r2, r3
 800e96c:	68fb      	ldr	r3, [r7, #12]
 800e96e:	621a      	str	r2, [r3, #32]

  /* Set or reset the CCxE Bit */ 
  TIMx->CCER |= (uint32_t)(ChannelState << Channel);
 800e970:	68fb      	ldr	r3, [r7, #12]
 800e972:	6a1a      	ldr	r2, [r3, #32]
 800e974:	68bb      	ldr	r3, [r7, #8]
 800e976:	6879      	ldr	r1, [r7, #4]
 800e978:	fa01 f303 	lsl.w	r3, r1, r3
 800e97c:	431a      	orrs	r2, r3
 800e97e:	68fb      	ldr	r3, [r7, #12]
 800e980:	621a      	str	r2, [r3, #32]
}
 800e982:	371c      	adds	r7, #28
 800e984:	46bd      	mov	sp, r7
 800e986:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e98a:	4770      	bx	lr

0800e98c <HAL_TIM_PWM_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, 
                                            TIM_OC_InitTypeDef* sConfig, 
                                            uint32_t Channel)
{
 800e98c:	b580      	push	{r7, lr}
 800e98e:	b084      	sub	sp, #16
 800e990:	af00      	add	r7, sp, #0
 800e992:	60f8      	str	r0, [r7, #12]
 800e994:	60b9      	str	r1, [r7, #8]
 800e996:	607a      	str	r2, [r7, #4]
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
  assert_param(IS_TIM_OCNIDLE_STATE(sConfig->OCNIdleState));
  assert_param(IS_TIM_OCIDLE_STATE(sConfig->OCIdleState));
  
  /* Check input state */
  __HAL_LOCK(htim);
 800e998:	68fb      	ldr	r3, [r7, #12]
 800e99a:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 800e99e:	2b01      	cmp	r3, #1
 800e9a0:	d101      	bne.n	800e9a6 <HAL_TIM_PWM_ConfigChannel+0x1a>
 800e9a2:	2302      	movs	r3, #2
 800e9a4:	e105      	b.n	800ebb2 <HAL_TIM_PWM_ConfigChannel+0x226>
 800e9a6:	68fb      	ldr	r3, [r7, #12]
 800e9a8:	2201      	movs	r2, #1
 800e9aa:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  htim->State = HAL_TIM_STATE_BUSY;
 800e9ae:	68fb      	ldr	r3, [r7, #12]
 800e9b0:	2202      	movs	r2, #2
 800e9b2:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    
  switch (Channel)
 800e9b6:	687b      	ldr	r3, [r7, #4]
 800e9b8:	2b14      	cmp	r3, #20
 800e9ba:	f200 80f0 	bhi.w	800eb9e <HAL_TIM_PWM_ConfigChannel+0x212>
 800e9be:	a201      	add	r2, pc, #4	; (adr r2, 800e9c4 <HAL_TIM_PWM_ConfigChannel+0x38>)
 800e9c0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e9c4:	0800ea19 	.word	0x0800ea19
 800e9c8:	0800eb9f 	.word	0x0800eb9f
 800e9cc:	0800eb9f 	.word	0x0800eb9f
 800e9d0:	0800eb9f 	.word	0x0800eb9f
 800e9d4:	0800ea59 	.word	0x0800ea59
 800e9d8:	0800eb9f 	.word	0x0800eb9f
 800e9dc:	0800eb9f 	.word	0x0800eb9f
 800e9e0:	0800eb9f 	.word	0x0800eb9f
 800e9e4:	0800ea9b 	.word	0x0800ea9b
 800e9e8:	0800eb9f 	.word	0x0800eb9f
 800e9ec:	0800eb9f 	.word	0x0800eb9f
 800e9f0:	0800eb9f 	.word	0x0800eb9f
 800e9f4:	0800eadb 	.word	0x0800eadb
 800e9f8:	0800eb9f 	.word	0x0800eb9f
 800e9fc:	0800eb9f 	.word	0x0800eb9f
 800ea00:	0800eb9f 	.word	0x0800eb9f
 800ea04:	0800eb1d 	.word	0x0800eb1d
 800ea08:	0800eb9f 	.word	0x0800eb9f
 800ea0c:	0800eb9f 	.word	0x0800eb9f
 800ea10:	0800eb9f 	.word	0x0800eb9f
 800ea14:	0800eb5d 	.word	0x0800eb5d
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance)); 
      
      /* Configure the Channel 1 in PWM mode */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 800ea18:	68fb      	ldr	r3, [r7, #12]
 800ea1a:	681b      	ldr	r3, [r3, #0]
 800ea1c:	4618      	mov	r0, r3
 800ea1e:	68b9      	ldr	r1, [r7, #8]
 800ea20:	f7ff fdca 	bl	800e5b8 <TIM_OC1_SetConfig>
      
      /* Set the Preload enable bit for channel1 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 800ea24:	68fb      	ldr	r3, [r7, #12]
 800ea26:	681b      	ldr	r3, [r3, #0]
 800ea28:	68fa      	ldr	r2, [r7, #12]
 800ea2a:	6812      	ldr	r2, [r2, #0]
 800ea2c:	6992      	ldr	r2, [r2, #24]
 800ea2e:	f042 0208 	orr.w	r2, r2, #8
 800ea32:	619a      	str	r2, [r3, #24]
      
      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 800ea34:	68fb      	ldr	r3, [r7, #12]
 800ea36:	681b      	ldr	r3, [r3, #0]
 800ea38:	68fa      	ldr	r2, [r7, #12]
 800ea3a:	6812      	ldr	r2, [r2, #0]
 800ea3c:	6992      	ldr	r2, [r2, #24]
 800ea3e:	f022 0204 	bic.w	r2, r2, #4
 800ea42:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 800ea44:	68fb      	ldr	r3, [r7, #12]
 800ea46:	681b      	ldr	r3, [r3, #0]
 800ea48:	68fa      	ldr	r2, [r7, #12]
 800ea4a:	6812      	ldr	r2, [r2, #0]
 800ea4c:	6991      	ldr	r1, [r2, #24]
 800ea4e:	68ba      	ldr	r2, [r7, #8]
 800ea50:	6912      	ldr	r2, [r2, #16]
 800ea52:	430a      	orrs	r2, r1
 800ea54:	619a      	str	r2, [r3, #24]
    }
    break;
 800ea56:	e0a3      	b.n	800eba0 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
      
      /* Configure the Channel 2 in PWM mode */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 800ea58:	68fb      	ldr	r3, [r7, #12]
 800ea5a:	681b      	ldr	r3, [r3, #0]
 800ea5c:	4618      	mov	r0, r3
 800ea5e:	68b9      	ldr	r1, [r7, #8]
 800ea60:	f7ff fe1e 	bl	800e6a0 <TIM_OC2_SetConfig>
      
      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 800ea64:	68fb      	ldr	r3, [r7, #12]
 800ea66:	681b      	ldr	r3, [r3, #0]
 800ea68:	68fa      	ldr	r2, [r7, #12]
 800ea6a:	6812      	ldr	r2, [r2, #0]
 800ea6c:	6992      	ldr	r2, [r2, #24]
 800ea6e:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800ea72:	619a      	str	r2, [r3, #24]
      
      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 800ea74:	68fb      	ldr	r3, [r7, #12]
 800ea76:	681b      	ldr	r3, [r3, #0]
 800ea78:	68fa      	ldr	r2, [r7, #12]
 800ea7a:	6812      	ldr	r2, [r2, #0]
 800ea7c:	6992      	ldr	r2, [r2, #24]
 800ea7e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800ea82:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
 800ea84:	68fb      	ldr	r3, [r7, #12]
 800ea86:	681b      	ldr	r3, [r3, #0]
 800ea88:	68fa      	ldr	r2, [r7, #12]
 800ea8a:	6812      	ldr	r2, [r2, #0]
 800ea8c:	6991      	ldr	r1, [r2, #24]
 800ea8e:	68ba      	ldr	r2, [r7, #8]
 800ea90:	6912      	ldr	r2, [r2, #16]
 800ea92:	0212      	lsls	r2, r2, #8
 800ea94:	430a      	orrs	r2, r1
 800ea96:	619a      	str	r2, [r3, #24]
    }
    break;
 800ea98:	e082      	b.n	800eba0 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance)); 
      
      /* Configure the Channel 3 in PWM mode */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 800ea9a:	68fb      	ldr	r3, [r7, #12]
 800ea9c:	681b      	ldr	r3, [r3, #0]
 800ea9e:	4618      	mov	r0, r3
 800eaa0:	68b9      	ldr	r1, [r7, #8]
 800eaa2:	f7ff fe77 	bl	800e794 <TIM_OC3_SetConfig>
      
      /* Set the Preload enable bit for channel3 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 800eaa6:	68fb      	ldr	r3, [r7, #12]
 800eaa8:	681b      	ldr	r3, [r3, #0]
 800eaaa:	68fa      	ldr	r2, [r7, #12]
 800eaac:	6812      	ldr	r2, [r2, #0]
 800eaae:	69d2      	ldr	r2, [r2, #28]
 800eab0:	f042 0208 	orr.w	r2, r2, #8
 800eab4:	61da      	str	r2, [r3, #28]
      
     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 800eab6:	68fb      	ldr	r3, [r7, #12]
 800eab8:	681b      	ldr	r3, [r3, #0]
 800eaba:	68fa      	ldr	r2, [r7, #12]
 800eabc:	6812      	ldr	r2, [r2, #0]
 800eabe:	69d2      	ldr	r2, [r2, #28]
 800eac0:	f022 0204 	bic.w	r2, r2, #4
 800eac4:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;  
 800eac6:	68fb      	ldr	r3, [r7, #12]
 800eac8:	681b      	ldr	r3, [r3, #0]
 800eaca:	68fa      	ldr	r2, [r7, #12]
 800eacc:	6812      	ldr	r2, [r2, #0]
 800eace:	69d1      	ldr	r1, [r2, #28]
 800ead0:	68ba      	ldr	r2, [r7, #8]
 800ead2:	6912      	ldr	r2, [r2, #16]
 800ead4:	430a      	orrs	r2, r1
 800ead6:	61da      	str	r2, [r3, #28]
    }
    break;
 800ead8:	e062      	b.n	800eba0 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance)); 
      
      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 800eada:	68fb      	ldr	r3, [r7, #12]
 800eadc:	681b      	ldr	r3, [r3, #0]
 800eade:	4618      	mov	r0, r3
 800eae0:	68b9      	ldr	r1, [r7, #8]
 800eae2:	f7ff fecf 	bl	800e884 <TIM_OC4_SetConfig>
      
      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 800eae6:	68fb      	ldr	r3, [r7, #12]
 800eae8:	681b      	ldr	r3, [r3, #0]
 800eaea:	68fa      	ldr	r2, [r7, #12]
 800eaec:	6812      	ldr	r2, [r2, #0]
 800eaee:	69d2      	ldr	r2, [r2, #28]
 800eaf0:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800eaf4:	61da      	str	r2, [r3, #28]
      
     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 800eaf6:	68fb      	ldr	r3, [r7, #12]
 800eaf8:	681b      	ldr	r3, [r3, #0]
 800eafa:	68fa      	ldr	r2, [r7, #12]
 800eafc:	6812      	ldr	r2, [r2, #0]
 800eafe:	69d2      	ldr	r2, [r2, #28]
 800eb00:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800eb04:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  
 800eb06:	68fb      	ldr	r3, [r7, #12]
 800eb08:	681b      	ldr	r3, [r3, #0]
 800eb0a:	68fa      	ldr	r2, [r7, #12]
 800eb0c:	6812      	ldr	r2, [r2, #0]
 800eb0e:	69d1      	ldr	r1, [r2, #28]
 800eb10:	68ba      	ldr	r2, [r7, #8]
 800eb12:	6912      	ldr	r2, [r2, #16]
 800eb14:	0212      	lsls	r2, r2, #8
 800eb16:	430a      	orrs	r2, r1
 800eb18:	61da      	str	r2, [r3, #28]
    }
    break;
 800eb1a:	e041      	b.n	800eba0 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
       /* Check the parameters */
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance)); 
      
     /* Configure the Channel 5 in PWM mode */
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 800eb1c:	68fb      	ldr	r3, [r7, #12]
 800eb1e:	681b      	ldr	r3, [r3, #0]
 800eb20:	4618      	mov	r0, r3
 800eb22:	68b9      	ldr	r1, [r7, #8]
 800eb24:	f000 f90a 	bl	800ed3c <TIM_OC5_SetConfig>
      
      /* Set the Preload enable bit for channel5*/
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 800eb28:	68fb      	ldr	r3, [r7, #12]
 800eb2a:	681b      	ldr	r3, [r3, #0]
 800eb2c:	68fa      	ldr	r2, [r7, #12]
 800eb2e:	6812      	ldr	r2, [r2, #0]
 800eb30:	6d52      	ldr	r2, [r2, #84]	; 0x54
 800eb32:	f042 0208 	orr.w	r2, r2, #8
 800eb36:	655a      	str	r2, [r3, #84]	; 0x54
      
     /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 800eb38:	68fb      	ldr	r3, [r7, #12]
 800eb3a:	681b      	ldr	r3, [r3, #0]
 800eb3c:	68fa      	ldr	r2, [r7, #12]
 800eb3e:	6812      	ldr	r2, [r2, #0]
 800eb40:	6d52      	ldr	r2, [r2, #84]	; 0x54
 800eb42:	f022 0204 	bic.w	r2, r2, #4
 800eb46:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;  
 800eb48:	68fb      	ldr	r3, [r7, #12]
 800eb4a:	681b      	ldr	r3, [r3, #0]
 800eb4c:	68fa      	ldr	r2, [r7, #12]
 800eb4e:	6812      	ldr	r2, [r2, #0]
 800eb50:	6d51      	ldr	r1, [r2, #84]	; 0x54
 800eb52:	68ba      	ldr	r2, [r7, #8]
 800eb54:	6912      	ldr	r2, [r2, #16]
 800eb56:	430a      	orrs	r2, r1
 800eb58:	655a      	str	r2, [r3, #84]	; 0x54
    }
    break;
 800eb5a:	e021      	b.n	800eba0 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
       /* Check the parameters */
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance)); 
      
     /* Configure the Channel 5 in PWM mode */
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 800eb5c:	68fb      	ldr	r3, [r7, #12]
 800eb5e:	681b      	ldr	r3, [r3, #0]
 800eb60:	4618      	mov	r0, r3
 800eb62:	68b9      	ldr	r1, [r7, #8]
 800eb64:	f000 f942 	bl	800edec <TIM_OC6_SetConfig>
      
      /* Set the Preload enable bit for channel6 */
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 800eb68:	68fb      	ldr	r3, [r7, #12]
 800eb6a:	681b      	ldr	r3, [r3, #0]
 800eb6c:	68fa      	ldr	r2, [r7, #12]
 800eb6e:	6812      	ldr	r2, [r2, #0]
 800eb70:	6d52      	ldr	r2, [r2, #84]	; 0x54
 800eb72:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800eb76:	655a      	str	r2, [r3, #84]	; 0x54
      
     /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 800eb78:	68fb      	ldr	r3, [r7, #12]
 800eb7a:	681b      	ldr	r3, [r3, #0]
 800eb7c:	68fa      	ldr	r2, [r7, #12]
 800eb7e:	6812      	ldr	r2, [r2, #0]
 800eb80:	6d52      	ldr	r2, [r2, #84]	; 0x54
 800eb82:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800eb86:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8;  
 800eb88:	68fb      	ldr	r3, [r7, #12]
 800eb8a:	681b      	ldr	r3, [r3, #0]
 800eb8c:	68fa      	ldr	r2, [r7, #12]
 800eb8e:	6812      	ldr	r2, [r2, #0]
 800eb90:	6d51      	ldr	r1, [r2, #84]	; 0x54
 800eb92:	68ba      	ldr	r2, [r7, #8]
 800eb94:	6912      	ldr	r2, [r2, #16]
 800eb96:	0212      	lsls	r2, r2, #8
 800eb98:	430a      	orrs	r2, r1
 800eb9a:	655a      	str	r2, [r3, #84]	; 0x54
    }
    break;
 800eb9c:	e000      	b.n	800eba0 <HAL_TIM_PWM_ConfigChannel+0x214>
    
    default:
    break;    
 800eb9e:	bf00      	nop
  }
  
  htim->State = HAL_TIM_STATE_READY;
 800eba0:	68fb      	ldr	r3, [r7, #12]
 800eba2:	2201      	movs	r2, #1
 800eba4:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    
  __HAL_UNLOCK(htim);
 800eba8:	68fb      	ldr	r3, [r7, #12]
 800ebaa:	2200      	movs	r2, #0
 800ebac:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  return HAL_OK;
 800ebb0:	2300      	movs	r3, #0
}
 800ebb2:	4618      	mov	r0, r3
 800ebb4:	3710      	adds	r7, #16
 800ebb6:	46bd      	mov	sp, r7
 800ebb8:	bd80      	pop	{r7, pc}
 800ebba:	bf00      	nop

0800ebbc <HAL_TIMEx_MasterConfigSynchronization>:
  *         contains the selected trigger output (TRGO) and the Master/Slave 
  *         mode. 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef * sMasterConfig)
{
 800ebbc:	b480      	push	{r7}
 800ebbe:	b085      	sub	sp, #20
 800ebc0:	af00      	add	r7, sp, #0
 800ebc2:	6078      	str	r0, [r7, #4]
 800ebc4:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
  
  /* Check input state */
  __HAL_LOCK(htim);
 800ebc6:	687b      	ldr	r3, [r7, #4]
 800ebc8:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 800ebcc:	2b01      	cmp	r3, #1
 800ebce:	d101      	bne.n	800ebd4 <HAL_TIMEx_MasterConfigSynchronization+0x18>
 800ebd0:	2302      	movs	r3, #2
 800ebd2:	e03d      	b.n	800ec50 <HAL_TIMEx_MasterConfigSynchronization+0x94>
 800ebd4:	687b      	ldr	r3, [r7, #4]
 800ebd6:	2201      	movs	r2, #1
 800ebd8:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

 /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 800ebdc:	687b      	ldr	r3, [r7, #4]
 800ebde:	681b      	ldr	r3, [r3, #0]
 800ebe0:	685b      	ldr	r3, [r3, #4]
 800ebe2:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 800ebe4:	687b      	ldr	r3, [r7, #4]
 800ebe6:	681b      	ldr	r3, [r3, #0]
 800ebe8:	689b      	ldr	r3, [r3, #8]
 800ebea:	60bb      	str	r3, [r7, #8]

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 800ebec:	687b      	ldr	r3, [r7, #4]
 800ebee:	681b      	ldr	r3, [r3, #0]
 800ebf0:	4a1a      	ldr	r2, [pc, #104]	; (800ec5c <HAL_TIMEx_MasterConfigSynchronization+0xa0>)
 800ebf2:	4293      	cmp	r3, r2
 800ebf4:	d004      	beq.n	800ec00 <HAL_TIMEx_MasterConfigSynchronization+0x44>
 800ebf6:	687b      	ldr	r3, [r7, #4]
 800ebf8:	681b      	ldr	r3, [r3, #0]
 800ebfa:	4a19      	ldr	r2, [pc, #100]	; (800ec60 <HAL_TIMEx_MasterConfigSynchronization+0xa4>)
 800ebfc:	4293      	cmp	r3, r2
 800ebfe:	d108      	bne.n	800ec12 <HAL_TIMEx_MasterConfigSynchronization+0x56>
  {
    /* Check the parameters */
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));
    
    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
 800ec00:	68fb      	ldr	r3, [r7, #12]
 800ec02:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 800ec06:	60fb      	str	r3, [r7, #12]
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 800ec08:	683b      	ldr	r3, [r7, #0]
 800ec0a:	685b      	ldr	r3, [r3, #4]
 800ec0c:	68fa      	ldr	r2, [r7, #12]
 800ec0e:	4313      	orrs	r3, r2
 800ec10:	60fb      	str	r3, [r7, #12]
  }
  
  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 800ec12:	68fb      	ldr	r3, [r7, #12]
 800ec14:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800ec18:	60fb      	str	r3, [r7, #12]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800ec1a:	683b      	ldr	r3, [r7, #0]
 800ec1c:	681b      	ldr	r3, [r3, #0]
 800ec1e:	68fa      	ldr	r2, [r7, #12]
 800ec20:	4313      	orrs	r3, r2
 800ec22:	60fb      	str	r3, [r7, #12]

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
 800ec24:	68bb      	ldr	r3, [r7, #8]
 800ec26:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800ec2a:	60bb      	str	r3, [r7, #8]
  /* Set master mode */
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 800ec2c:	683b      	ldr	r3, [r7, #0]
 800ec2e:	689b      	ldr	r3, [r3, #8]
 800ec30:	68ba      	ldr	r2, [r7, #8]
 800ec32:	4313      	orrs	r3, r2
 800ec34:	60bb      	str	r3, [r7, #8]
  
  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 800ec36:	687b      	ldr	r3, [r7, #4]
 800ec38:	681b      	ldr	r3, [r3, #0]
 800ec3a:	68fa      	ldr	r2, [r7, #12]
 800ec3c:	605a      	str	r2, [r3, #4]
  
  /* Update TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;
 800ec3e:	687b      	ldr	r3, [r7, #4]
 800ec40:	681b      	ldr	r3, [r3, #0]
 800ec42:	68ba      	ldr	r2, [r7, #8]
 800ec44:	609a      	str	r2, [r3, #8]

  __HAL_UNLOCK(htim);
 800ec46:	687b      	ldr	r3, [r7, #4]
 800ec48:	2200      	movs	r2, #0
 800ec4a:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  return HAL_OK;
 800ec4e:	2300      	movs	r3, #0
} 
 800ec50:	4618      	mov	r0, r3
 800ec52:	3714      	adds	r7, #20
 800ec54:	46bd      	mov	sp, r7
 800ec56:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ec5a:	4770      	bx	lr
 800ec5c:	40010000 	.word	0x40010000
 800ec60:	40010400 	.word	0x40010400

0800ec64 <HAL_TIMEx_ConfigBreakDeadTime>:
  *         contains the BDTR Register configuration  information for the TIM peripheral. 
  * @retval HAL status
  */    
HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim, 
                                              TIM_BreakDeadTimeConfigTypeDef * sBreakDeadTimeConfig)
{
 800ec64:	b480      	push	{r7}
 800ec66:	b085      	sub	sp, #20
 800ec68:	af00      	add	r7, sp, #0
 800ec6a:	6078      	str	r0, [r7, #4]
 800ec6c:	6039      	str	r1, [r7, #0]
  uint32_t tmpbdtr = 0;
 800ec6e:	2300      	movs	r3, #0
 800ec70:	60fb      	str	r3, [r7, #12]
  assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig->Break2State));
  assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig->Break2Polarity));
  assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->Break2Filter));
  
  /* Check input state */
  __HAL_LOCK(htim);
 800ec72:	687b      	ldr	r3, [r7, #4]
 800ec74:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 800ec78:	2b01      	cmp	r3, #1
 800ec7a:	d101      	bne.n	800ec80 <HAL_TIMEx_ConfigBreakDeadTime+0x1c>
 800ec7c:	2302      	movs	r3, #2
 800ec7e:	e04d      	b.n	800ed1c <HAL_TIMEx_ConfigBreakDeadTime+0xb8>
 800ec80:	687b      	ldr	r3, [r7, #4]
 800ec82:	2201      	movs	r2, #1
 800ec84:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  htim->State = HAL_TIM_STATE_BUSY;
 800ec88:	687b      	ldr	r3, [r7, #4]
 800ec8a:	2202      	movs	r2, #2
 800ec8c:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
    
  /* Clear the BDTR bits */
  tmpbdtr &= ~(TIM_BDTR_DTG | TIM_BDTR_LOCK |  TIM_BDTR_OSSI | 
 800ec90:	68fb      	ldr	r3, [r7, #12]
 800ec92:	f003 437c 	and.w	r3, r3, #4227858432	; 0xfc000000
 800ec96:	60fb      	str	r3, [r7, #12]
               TIM_BDTR_OSSR | TIM_BDTR_BKE | TIM_BDTR_BKP | 
               TIM_BDTR_AOE | TIM_BDTR_MOE | TIM_BDTR_BKF |
               TIM_BDTR_BK2F | TIM_BDTR_BK2E | TIM_BDTR_BK2P);

  /* Set the BDTR bits */
  tmpbdtr |= sBreakDeadTimeConfig->DeadTime;
 800ec98:	683b      	ldr	r3, [r7, #0]
 800ec9a:	68db      	ldr	r3, [r3, #12]
 800ec9c:	68fa      	ldr	r2, [r7, #12]
 800ec9e:	4313      	orrs	r3, r2
 800eca0:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->LockLevel;
 800eca2:	683b      	ldr	r3, [r7, #0]
 800eca4:	689b      	ldr	r3, [r3, #8]
 800eca6:	68fa      	ldr	r2, [r7, #12]
 800eca8:	4313      	orrs	r3, r2
 800ecaa:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->OffStateIDLEMode;
 800ecac:	683b      	ldr	r3, [r7, #0]
 800ecae:	685b      	ldr	r3, [r3, #4]
 800ecb0:	68fa      	ldr	r2, [r7, #12]
 800ecb2:	4313      	orrs	r3, r2
 800ecb4:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->OffStateRunMode;
 800ecb6:	683b      	ldr	r3, [r7, #0]
 800ecb8:	681b      	ldr	r3, [r3, #0]
 800ecba:	68fa      	ldr	r2, [r7, #12]
 800ecbc:	4313      	orrs	r3, r2
 800ecbe:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->BreakState;
 800ecc0:	683b      	ldr	r3, [r7, #0]
 800ecc2:	691b      	ldr	r3, [r3, #16]
 800ecc4:	68fa      	ldr	r2, [r7, #12]
 800ecc6:	4313      	orrs	r3, r2
 800ecc8:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->BreakPolarity;
 800ecca:	683b      	ldr	r3, [r7, #0]
 800eccc:	695b      	ldr	r3, [r3, #20]
 800ecce:	68fa      	ldr	r2, [r7, #12]
 800ecd0:	4313      	orrs	r3, r2
 800ecd2:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->AutomaticOutput;
 800ecd4:	683b      	ldr	r3, [r7, #0]
 800ecd6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ecd8:	68fa      	ldr	r2, [r7, #12]
 800ecda:	4313      	orrs	r3, r2
 800ecdc:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= (sBreakDeadTimeConfig->BreakFilter << BDTR_BKF_SHIFT);
 800ecde:	683b      	ldr	r3, [r7, #0]
 800ece0:	699b      	ldr	r3, [r3, #24]
 800ece2:	041b      	lsls	r3, r3, #16
 800ece4:	68fa      	ldr	r2, [r7, #12]
 800ece6:	4313      	orrs	r3, r2
 800ece8:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= (sBreakDeadTimeConfig->Break2Filter << BDTR_BK2F_SHIFT);
 800ecea:	683b      	ldr	r3, [r7, #0]
 800ecec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ecee:	051b      	lsls	r3, r3, #20
 800ecf0:	68fa      	ldr	r2, [r7, #12]
 800ecf2:	4313      	orrs	r3, r2
 800ecf4:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->Break2State;
 800ecf6:	683b      	ldr	r3, [r7, #0]
 800ecf8:	69db      	ldr	r3, [r3, #28]
 800ecfa:	68fa      	ldr	r2, [r7, #12]
 800ecfc:	4313      	orrs	r3, r2
 800ecfe:	60fb      	str	r3, [r7, #12]
  tmpbdtr |= sBreakDeadTimeConfig->Break2Polarity;
 800ed00:	683b      	ldr	r3, [r7, #0]
 800ed02:	6a1b      	ldr	r3, [r3, #32]
 800ed04:	68fa      	ldr	r2, [r7, #12]
 800ed06:	4313      	orrs	r3, r2
 800ed08:	60fb      	str	r3, [r7, #12]
  
  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;
 800ed0a:	687b      	ldr	r3, [r7, #4]
 800ed0c:	681b      	ldr	r3, [r3, #0]
 800ed0e:	68fa      	ldr	r2, [r7, #12]
 800ed10:	645a      	str	r2, [r3, #68]	; 0x44
  
  __HAL_UNLOCK(htim);
 800ed12:	687b      	ldr	r3, [r7, #4]
 800ed14:	2200      	movs	r2, #0
 800ed16:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  return HAL_OK;
 800ed1a:	2300      	movs	r3, #0
}
 800ed1c:	4618      	mov	r0, r3
 800ed1e:	3714      	adds	r7, #20
 800ed20:	46bd      	mov	sp, r7
 800ed22:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ed26:	4770      	bx	lr

0800ed28 <HAL_TIMEx_CommutationCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef *htim)
{
 800ed28:	b480      	push	{r7}
 800ed2a:	b083      	sub	sp, #12
 800ed2c:	af00      	add	r7, sp, #0
 800ed2e:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutationCallback could be implemented in the user file
   */
}
 800ed30:	370c      	adds	r7, #12
 800ed32:	46bd      	mov	sp, r7
 800ed34:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ed38:	4770      	bx	lr
 800ed3a:	bf00      	nop

0800ed3c <TIM_OC5_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800ed3c:	b480      	push	{r7}
 800ed3e:	b087      	sub	sp, #28
 800ed40:	af00      	add	r7, sp, #0
 800ed42:	6078      	str	r0, [r7, #4]
 800ed44:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0;
 800ed46:	2300      	movs	r3, #0
 800ed48:	613b      	str	r3, [r7, #16]
  uint32_t tmpccer = 0;
 800ed4a:	2300      	movs	r3, #0
 800ed4c:	60fb      	str	r3, [r7, #12]
  uint32_t tmpcr2 = 0; 
 800ed4e:	2300      	movs	r3, #0
 800ed50:	617b      	str	r3, [r7, #20]

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
 800ed52:	687b      	ldr	r3, [r7, #4]
 800ed54:	6a1b      	ldr	r3, [r3, #32]
 800ed56:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 800ed5a:	687b      	ldr	r3, [r7, #4]
 800ed5c:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800ed5e:	687b      	ldr	r3, [r7, #4]
 800ed60:	6a1b      	ldr	r3, [r3, #32]
 800ed62:	60fb      	str	r3, [r7, #12]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2; 
 800ed64:	687b      	ldr	r3, [r7, #4]
 800ed66:	685b      	ldr	r3, [r3, #4]
 800ed68:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 800ed6a:	687b      	ldr	r3, [r7, #4]
 800ed6c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ed6e:	613b      	str	r3, [r7, #16]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 800ed70:	693a      	ldr	r2, [r7, #16]
 800ed72:	4b1b      	ldr	r3, [pc, #108]	; (800ede0 <TIM_OC5_SetConfig+0xa4>)
 800ed74:	4013      	ands	r3, r2
 800ed76:	613b      	str	r3, [r7, #16]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800ed78:	683b      	ldr	r3, [r7, #0]
 800ed7a:	681b      	ldr	r3, [r3, #0]
 800ed7c:	693a      	ldr	r2, [r7, #16]
 800ed7e:	4313      	orrs	r3, r2
 800ed80:	613b      	str	r3, [r7, #16]
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
 800ed82:	68fb      	ldr	r3, [r7, #12]
 800ed84:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 800ed88:	60fb      	str	r3, [r7, #12]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16);
 800ed8a:	683b      	ldr	r3, [r7, #0]
 800ed8c:	689b      	ldr	r3, [r3, #8]
 800ed8e:	041b      	lsls	r3, r3, #16
 800ed90:	68fa      	ldr	r2, [r7, #12]
 800ed92:	4313      	orrs	r3, r2
 800ed94:	60fb      	str	r3, [r7, #12]

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 800ed96:	687b      	ldr	r3, [r7, #4]
 800ed98:	4a12      	ldr	r2, [pc, #72]	; (800ede4 <TIM_OC5_SetConfig+0xa8>)
 800ed9a:	4293      	cmp	r3, r2
 800ed9c:	d003      	beq.n	800eda6 <TIM_OC5_SetConfig+0x6a>
 800ed9e:	687b      	ldr	r3, [r7, #4]
 800eda0:	4a11      	ldr	r2, [pc, #68]	; (800ede8 <TIM_OC5_SetConfig+0xac>)
 800eda2:	4293      	cmp	r3, r2
 800eda4:	d109      	bne.n	800edba <TIM_OC5_SetConfig+0x7e>
  {   
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
 800eda6:	697b      	ldr	r3, [r7, #20]
 800eda8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800edac:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8);
 800edae:	683b      	ldr	r3, [r7, #0]
 800edb0:	695b      	ldr	r3, [r3, #20]
 800edb2:	021b      	lsls	r3, r3, #8
 800edb4:	697a      	ldr	r2, [r7, #20]
 800edb6:	4313      	orrs	r3, r2
 800edb8:	617b      	str	r3, [r7, #20]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800edba:	687b      	ldr	r3, [r7, #4]
 800edbc:	697a      	ldr	r2, [r7, #20]
 800edbe:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 800edc0:	687b      	ldr	r3, [r7, #4]
 800edc2:	693a      	ldr	r2, [r7, #16]
 800edc4:	655a      	str	r2, [r3, #84]	; 0x54
  
  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
 800edc6:	683b      	ldr	r3, [r7, #0]
 800edc8:	685a      	ldr	r2, [r3, #4]
 800edca:	687b      	ldr	r3, [r7, #4]
 800edcc:	659a      	str	r2, [r3, #88]	; 0x58
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;  
 800edce:	687b      	ldr	r3, [r7, #4]
 800edd0:	68fa      	ldr	r2, [r7, #12]
 800edd2:	621a      	str	r2, [r3, #32]
}
 800edd4:	371c      	adds	r7, #28
 800edd6:	46bd      	mov	sp, r7
 800edd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eddc:	4770      	bx	lr
 800edde:	bf00      	nop
 800ede0:	fffeff8f 	.word	0xfffeff8f
 800ede4:	40010000 	.word	0x40010000
 800ede8:	40010400 	.word	0x40010400

0800edec <TIM_OC6_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800edec:	b480      	push	{r7}
 800edee:	b087      	sub	sp, #28
 800edf0:	af00      	add	r7, sp, #0
 800edf2:	6078      	str	r0, [r7, #4]
 800edf4:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0;
 800edf6:	2300      	movs	r3, #0
 800edf8:	613b      	str	r3, [r7, #16]
  uint32_t tmpccer = 0;
 800edfa:	2300      	movs	r3, #0
 800edfc:	60fb      	str	r3, [r7, #12]
  uint32_t tmpcr2 = 0; 
 800edfe:	2300      	movs	r3, #0
 800ee00:	617b      	str	r3, [r7, #20]

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
 800ee02:	687b      	ldr	r3, [r7, #4]
 800ee04:	6a1b      	ldr	r3, [r3, #32]
 800ee06:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
 800ee0a:	687b      	ldr	r3, [r7, #4]
 800ee0c:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800ee0e:	687b      	ldr	r3, [r7, #4]
 800ee10:	6a1b      	ldr	r3, [r3, #32]
 800ee12:	60fb      	str	r3, [r7, #12]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2; 
 800ee14:	687b      	ldr	r3, [r7, #4]
 800ee16:	685b      	ldr	r3, [r3, #4]
 800ee18:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 800ee1a:	687b      	ldr	r3, [r7, #4]
 800ee1c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ee1e:	613b      	str	r3, [r7, #16]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 800ee20:	693a      	ldr	r2, [r7, #16]
 800ee22:	4b1b      	ldr	r3, [pc, #108]	; (800ee90 <TIM_OC6_SetConfig+0xa4>)
 800ee24:	4013      	ands	r3, r2
 800ee26:	613b      	str	r3, [r7, #16]
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 800ee28:	683b      	ldr	r3, [r7, #0]
 800ee2a:	681b      	ldr	r3, [r3, #0]
 800ee2c:	021b      	lsls	r3, r3, #8
 800ee2e:	693a      	ldr	r2, [r7, #16]
 800ee30:	4313      	orrs	r3, r2
 800ee32:	613b      	str	r3, [r7, #16]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 800ee34:	68fb      	ldr	r3, [r7, #12]
 800ee36:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800ee3a:	60fb      	str	r3, [r7, #12]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20);
 800ee3c:	683b      	ldr	r3, [r7, #0]
 800ee3e:	689b      	ldr	r3, [r3, #8]
 800ee40:	051b      	lsls	r3, r3, #20
 800ee42:	68fa      	ldr	r2, [r7, #12]
 800ee44:	4313      	orrs	r3, r2
 800ee46:	60fb      	str	r3, [r7, #12]

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 800ee48:	687b      	ldr	r3, [r7, #4]
 800ee4a:	4a12      	ldr	r2, [pc, #72]	; (800ee94 <TIM_OC6_SetConfig+0xa8>)
 800ee4c:	4293      	cmp	r3, r2
 800ee4e:	d003      	beq.n	800ee58 <TIM_OC6_SetConfig+0x6c>
 800ee50:	687b      	ldr	r3, [r7, #4]
 800ee52:	4a11      	ldr	r2, [pc, #68]	; (800ee98 <TIM_OC6_SetConfig+0xac>)
 800ee54:	4293      	cmp	r3, r2
 800ee56:	d109      	bne.n	800ee6c <TIM_OC6_SetConfig+0x80>
  {   
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
 800ee58:	697b      	ldr	r3, [r7, #20]
 800ee5a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800ee5e:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10);
 800ee60:	683b      	ldr	r3, [r7, #0]
 800ee62:	695b      	ldr	r3, [r3, #20]
 800ee64:	029b      	lsls	r3, r3, #10
 800ee66:	697a      	ldr	r2, [r7, #20]
 800ee68:	4313      	orrs	r3, r2
 800ee6a:	617b      	str	r3, [r7, #20]
  }
  
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800ee6c:	687b      	ldr	r3, [r7, #4]
 800ee6e:	697a      	ldr	r2, [r7, #20]
 800ee70:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 800ee72:	687b      	ldr	r3, [r7, #4]
 800ee74:	693a      	ldr	r2, [r7, #16]
 800ee76:	655a      	str	r2, [r3, #84]	; 0x54
  
  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 800ee78:	683b      	ldr	r3, [r7, #0]
 800ee7a:	685a      	ldr	r2, [r3, #4]
 800ee7c:	687b      	ldr	r3, [r7, #4]
 800ee7e:	65da      	str	r2, [r3, #92]	; 0x5c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;  
 800ee80:	687b      	ldr	r3, [r7, #4]
 800ee82:	68fa      	ldr	r2, [r7, #12]
 800ee84:	621a      	str	r2, [r3, #32]
} 
 800ee86:	371c      	adds	r7, #28
 800ee88:	46bd      	mov	sp, r7
 800ee8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ee8e:	4770      	bx	lr
 800ee90:	feff8fff 	.word	0xfeff8fff
 800ee94:	40010000 	.word	0x40010000
 800ee98:	40010400 	.word	0x40010400

0800ee9c <HAL_UART_Init>:
  *         parameters in the UART_InitTypeDef and creates the associated handle .
  * @param huart: uart handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 800ee9c:	b580      	push	{r7, lr}
 800ee9e:	b082      	sub	sp, #8
 800eea0:	af00      	add	r7, sp, #0
 800eea2:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if(huart == NULL)
 800eea4:	687b      	ldr	r3, [r7, #4]
 800eea6:	2b00      	cmp	r3, #0
 800eea8:	d101      	bne.n	800eeae <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 800eeaa:	2301      	movs	r3, #1
 800eeac:	e043      	b.n	800ef36 <HAL_UART_Init+0x9a>
  {
    /* Check the parameters */
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }
  
  if(huart->State == HAL_UART_STATE_RESET)
 800eeae:	687b      	ldr	r3, [r7, #4]
 800eeb0:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
 800eeb4:	b2db      	uxtb	r3, r3
 800eeb6:	2b00      	cmp	r3, #0
 800eeb8:	d106      	bne.n	800eec8 <HAL_UART_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 800eeba:	687b      	ldr	r3, [r7, #4]
 800eebc:	2200      	movs	r2, #0
 800eebe:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68

    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 800eec2:	6878      	ldr	r0, [r7, #4]
 800eec4:	f005 f9de 	bl	8014284 <HAL_UART_MspInit>
  }

  huart->State = HAL_UART_STATE_BUSY;
 800eec8:	687b      	ldr	r3, [r7, #4]
 800eeca:	2202      	movs	r2, #2
 800eecc:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69

  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
 800eed0:	687b      	ldr	r3, [r7, #4]
 800eed2:	681b      	ldr	r3, [r3, #0]
 800eed4:	687a      	ldr	r2, [r7, #4]
 800eed6:	6812      	ldr	r2, [r2, #0]
 800eed8:	6812      	ldr	r2, [r2, #0]
 800eeda:	f022 0201 	bic.w	r2, r2, #1
 800eede:	601a      	str	r2, [r3, #0]
  
  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 800eee0:	6878      	ldr	r0, [r7, #4]
 800eee2:	f000 f9e9 	bl	800f2b8 <UART_SetConfig>
 800eee6:	4603      	mov	r3, r0
 800eee8:	2b01      	cmp	r3, #1
 800eeea:	d101      	bne.n	800eef0 <HAL_UART_Init+0x54>
  {
    return HAL_ERROR;
 800eeec:	2301      	movs	r3, #1
 800eeee:	e022      	b.n	800ef36 <HAL_UART_Init+0x9a>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800eef0:	687b      	ldr	r3, [r7, #4]
 800eef2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800eef4:	2b00      	cmp	r3, #0
 800eef6:	d002      	beq.n	800eefe <HAL_UART_Init+0x62>
  {
    UART_AdvFeatureConfig(huart);
 800eef8:	6878      	ldr	r0, [r7, #4]
 800eefa:	f000 fc29 	bl	800f750 <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
 800eefe:	687b      	ldr	r3, [r7, #4]
 800ef00:	681b      	ldr	r3, [r3, #0]
 800ef02:	687a      	ldr	r2, [r7, #4]
 800ef04:	6812      	ldr	r2, [r2, #0]
 800ef06:	6852      	ldr	r2, [r2, #4]
 800ef08:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 800ef0c:	605a      	str	r2, [r3, #4]
  huart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
 800ef0e:	687b      	ldr	r3, [r7, #4]
 800ef10:	681b      	ldr	r3, [r3, #0]
 800ef12:	687a      	ldr	r2, [r7, #4]
 800ef14:	6812      	ldr	r2, [r2, #0]
 800ef16:	6892      	ldr	r2, [r2, #8]
 800ef18:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 800ef1c:	609a      	str	r2, [r3, #8]

  /* Enable the Peripheral */
  __HAL_UART_ENABLE(huart);
 800ef1e:	687b      	ldr	r3, [r7, #4]
 800ef20:	681b      	ldr	r3, [r3, #0]
 800ef22:	687a      	ldr	r2, [r7, #4]
 800ef24:	6812      	ldr	r2, [r2, #0]
 800ef26:	6812      	ldr	r2, [r2, #0]
 800ef28:	f042 0201 	orr.w	r2, r2, #1
 800ef2c:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->State to Ready */
  return (UART_CheckIdleState(huart));
 800ef2e:	6878      	ldr	r0, [r7, #4]
 800ef30:	f000 fcb0 	bl	800f894 <UART_CheckIdleState>
 800ef34:	4603      	mov	r3, r0
}
 800ef36:	4618      	mov	r0, r3
 800ef38:	3708      	adds	r7, #8
 800ef3a:	46bd      	mov	sp, r7
 800ef3c:	bd80      	pop	{r7, pc}
 800ef3e:	bf00      	nop

0800ef40 <HAL_UART_DeInit>:
  * @brief DeInitializes the UART peripheral 
  * @param huart: uart handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
{
 800ef40:	b580      	push	{r7, lr}
 800ef42:	b082      	sub	sp, #8
 800ef44:	af00      	add	r7, sp, #0
 800ef46:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if(huart == NULL)
 800ef48:	687b      	ldr	r3, [r7, #4]
 800ef4a:	2b00      	cmp	r3, #0
 800ef4c:	d101      	bne.n	800ef52 <HAL_UART_DeInit+0x12>
  {
    return HAL_ERROR;
 800ef4e:	2301      	movs	r3, #1
 800ef50:	e026      	b.n	800efa0 <HAL_UART_DeInit+0x60>
  }
  
  /* Check the parameters */
  assert_param(IS_UART_INSTANCE(huart->Instance));

  huart->State = HAL_UART_STATE_BUSY;
 800ef52:	687b      	ldr	r3, [r7, #4]
 800ef54:	2202      	movs	r2, #2
 800ef56:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
  
  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
 800ef5a:	687b      	ldr	r3, [r7, #4]
 800ef5c:	681b      	ldr	r3, [r3, #0]
 800ef5e:	687a      	ldr	r2, [r7, #4]
 800ef60:	6812      	ldr	r2, [r2, #0]
 800ef62:	6812      	ldr	r2, [r2, #0]
 800ef64:	f022 0201 	bic.w	r2, r2, #1
 800ef68:	601a      	str	r2, [r3, #0]
  
  huart->Instance->CR1 = 0x0;
 800ef6a:	687b      	ldr	r3, [r7, #4]
 800ef6c:	681b      	ldr	r3, [r3, #0]
 800ef6e:	2200      	movs	r2, #0
 800ef70:	601a      	str	r2, [r3, #0]
  huart->Instance->CR2 = 0x0;
 800ef72:	687b      	ldr	r3, [r7, #4]
 800ef74:	681b      	ldr	r3, [r3, #0]
 800ef76:	2200      	movs	r2, #0
 800ef78:	605a      	str	r2, [r3, #4]
  huart->Instance->CR3 = 0x0;
 800ef7a:	687b      	ldr	r3, [r7, #4]
 800ef7c:	681b      	ldr	r3, [r3, #0]
 800ef7e:	2200      	movs	r2, #0
 800ef80:	609a      	str	r2, [r3, #8]
  
  /* DeInit the low level hardware */
  HAL_UART_MspDeInit(huart);
 800ef82:	6878      	ldr	r0, [r7, #4]
 800ef84:	f005 fa2a 	bl	80143dc <HAL_UART_MspDeInit>

  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800ef88:	687b      	ldr	r3, [r7, #4]
 800ef8a:	2200      	movs	r2, #0
 800ef8c:	66da      	str	r2, [r3, #108]	; 0x6c
  huart->State = HAL_UART_STATE_RESET;
 800ef8e:	687b      	ldr	r3, [r7, #4]
 800ef90:	2200      	movs	r2, #0
 800ef92:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
  
  /* Process Unlock */
  __HAL_UNLOCK(huart);
 800ef96:	687b      	ldr	r3, [r7, #4]
 800ef98:	2200      	movs	r2, #0
 800ef9a:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
  
  return HAL_OK;
 800ef9e:	2300      	movs	r3, #0
}
 800efa0:	4618      	mov	r0, r3
 800efa2:	3708      	adds	r7, #8
 800efa4:	46bd      	mov	sp, r7
 800efa6:	bd80      	pop	{r7, pc}

0800efa8 <HAL_UART_Receive_DMA>:
  * @note   When the UART parity is enabled (PCE = 1), the received data contain 
  *         the parity bit (MSB position)     
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 800efa8:	b590      	push	{r4, r7, lr}
 800efaa:	b087      	sub	sp, #28
 800efac:	af00      	add	r7, sp, #0
 800efae:	60f8      	str	r0, [r7, #12]
 800efb0:	60b9      	str	r1, [r7, #8]
 800efb2:	4613      	mov	r3, r2
 800efb4:	80fb      	strh	r3, [r7, #6]
  uint32_t *tmp;
  
  if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_TX))
 800efb6:	68fb      	ldr	r3, [r7, #12]
 800efb8:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
 800efbc:	b2db      	uxtb	r3, r3
 800efbe:	2b01      	cmp	r3, #1
 800efc0:	d005      	beq.n	800efce <HAL_UART_Receive_DMA+0x26>
 800efc2:	68fb      	ldr	r3, [r7, #12]
 800efc4:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
 800efc8:	b2db      	uxtb	r3, r3
 800efca:	2b12      	cmp	r3, #18
 800efcc:	d155      	bne.n	800f07a <HAL_UART_Receive_DMA+0xd2>
  {
    if((pData == NULL ) || (Size == 0)) 
 800efce:	68bb      	ldr	r3, [r7, #8]
 800efd0:	2b00      	cmp	r3, #0
 800efd2:	d002      	beq.n	800efda <HAL_UART_Receive_DMA+0x32>
 800efd4:	88fb      	ldrh	r3, [r7, #6]
 800efd6:	2b00      	cmp	r3, #0
 800efd8:	d101      	bne.n	800efde <HAL_UART_Receive_DMA+0x36>
    {
      return HAL_ERROR;
 800efda:	2301      	movs	r3, #1
 800efdc:	e04e      	b.n	800f07c <HAL_UART_Receive_DMA+0xd4>
    }
    
    /* Process Locked */
    __HAL_LOCK(huart);
 800efde:	68fb      	ldr	r3, [r7, #12]
 800efe0:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
 800efe4:	2b01      	cmp	r3, #1
 800efe6:	d101      	bne.n	800efec <HAL_UART_Receive_DMA+0x44>
 800efe8:	2302      	movs	r3, #2
 800efea:	e047      	b.n	800f07c <HAL_UART_Receive_DMA+0xd4>
 800efec:	68fb      	ldr	r3, [r7, #12]
 800efee:	2201      	movs	r2, #1
 800eff0:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
    
    huart->pRxBuffPtr = pData;
 800eff4:	68ba      	ldr	r2, [r7, #8]
 800eff6:	68fb      	ldr	r3, [r7, #12]
 800eff8:	655a      	str	r2, [r3, #84]	; 0x54
    huart->RxXferSize = Size;
 800effa:	68fb      	ldr	r3, [r7, #12]
 800effc:	88fa      	ldrh	r2, [r7, #6]
 800effe:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
    
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800f002:	68fb      	ldr	r3, [r7, #12]
 800f004:	2200      	movs	r2, #0
 800f006:	66da      	str	r2, [r3, #108]	; 0x6c
    /* Check if a transmit process is ongoing or not */
    if(huart->State == HAL_UART_STATE_BUSY_TX) 
 800f008:	68fb      	ldr	r3, [r7, #12]
 800f00a:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
 800f00e:	b2db      	uxtb	r3, r3
 800f010:	2b12      	cmp	r3, #18
 800f012:	d104      	bne.n	800f01e <HAL_UART_Receive_DMA+0x76>
    {
      huart->State = HAL_UART_STATE_BUSY_TX_RX;
 800f014:	68fb      	ldr	r3, [r7, #12]
 800f016:	2232      	movs	r2, #50	; 0x32
 800f018:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
 800f01c:	e003      	b.n	800f026 <HAL_UART_Receive_DMA+0x7e>
    }
    else
    {
      huart->State = HAL_UART_STATE_BUSY_RX;
 800f01e:	68fb      	ldr	r3, [r7, #12]
 800f020:	2222      	movs	r2, #34	; 0x22
 800f022:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
    }
    
    /* Set the UART DMA transfer complete callback */
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 800f026:	68fb      	ldr	r3, [r7, #12]
 800f028:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800f02a:	4a16      	ldr	r2, [pc, #88]	; (800f084 <HAL_UART_Receive_DMA+0xdc>)
 800f02c:	63da      	str	r2, [r3, #60]	; 0x3c
    
    /* Set the UART DMA Half transfer complete callback */
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 800f02e:	68fb      	ldr	r3, [r7, #12]
 800f030:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800f032:	4a15      	ldr	r2, [pc, #84]	; (800f088 <HAL_UART_Receive_DMA+0xe0>)
 800f034:	641a      	str	r2, [r3, #64]	; 0x40
    
    /* Set the DMA error callback */
    huart->hdmarx->XferErrorCallback = UART_DMAError;
 800f036:	68fb      	ldr	r3, [r7, #12]
 800f038:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800f03a:	4a14      	ldr	r2, [pc, #80]	; (800f08c <HAL_UART_Receive_DMA+0xe4>)
 800f03c:	649a      	str	r2, [r3, #72]	; 0x48

    /* Enable the DMA channel */
    tmp = (uint32_t*)&pData;
 800f03e:	f107 0308 	add.w	r3, r7, #8
 800f042:	617b      	str	r3, [r7, #20]
    HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, *(uint32_t*)tmp, Size);
 800f044:	68fb      	ldr	r3, [r7, #12]
 800f046:	6e59      	ldr	r1, [r3, #100]	; 0x64
 800f048:	68fb      	ldr	r3, [r7, #12]
 800f04a:	681b      	ldr	r3, [r3, #0]
 800f04c:	3324      	adds	r3, #36	; 0x24
 800f04e:	461c      	mov	r4, r3
 800f050:	697b      	ldr	r3, [r7, #20]
 800f052:	681a      	ldr	r2, [r3, #0]
 800f054:	88fb      	ldrh	r3, [r7, #6]
 800f056:	4608      	mov	r0, r1
 800f058:	4621      	mov	r1, r4
 800f05a:	f7fa fc35 	bl	80098c8 <HAL_DMA_Start_IT>

    /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
       in the UART CR3 register */
     huart->Instance->CR3 |= USART_CR3_DMAR;
 800f05e:	68fb      	ldr	r3, [r7, #12]
 800f060:	681b      	ldr	r3, [r3, #0]
 800f062:	68fa      	ldr	r2, [r7, #12]
 800f064:	6812      	ldr	r2, [r2, #0]
 800f066:	6892      	ldr	r2, [r2, #8]
 800f068:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800f06c:	609a      	str	r2, [r3, #8]
    
     /* Process Unlocked */
     __HAL_UNLOCK(huart);
 800f06e:	68fb      	ldr	r3, [r7, #12]
 800f070:	2200      	movs	r2, #0
 800f072:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
     
    return HAL_OK;
 800f076:	2300      	movs	r3, #0
 800f078:	e000      	b.n	800f07c <HAL_UART_Receive_DMA+0xd4>
  }
  else
  {
    return HAL_BUSY; 
 800f07a:	2302      	movs	r3, #2
  }
}
 800f07c:	4618      	mov	r0, r3
 800f07e:	371c      	adds	r7, #28
 800f080:	46bd      	mov	sp, r7
 800f082:	bd90      	pop	{r4, r7, pc}
 800f084:	0800f1c1 	.word	0x0800f1c1
 800f088:	0800f221 	.word	0x0800f221
 800f08c:	0800f23d 	.word	0x0800f23d

0800f090 <UART_WaitOnFlagUntilTimeout>:
  * @param  Status: The new Flag status (SET or RESET).
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
{
 800f090:	b580      	push	{r7, lr}
 800f092:	b086      	sub	sp, #24
 800f094:	af00      	add	r7, sp, #0
 800f096:	60f8      	str	r0, [r7, #12]
 800f098:	60b9      	str	r1, [r7, #8]
 800f09a:	603b      	str	r3, [r7, #0]
 800f09c:	4613      	mov	r3, r2
 800f09e:	71fb      	strb	r3, [r7, #7]
  uint32_t tickstart = HAL_GetTick();
 800f0a0:	f7f7 f8da 	bl	8006258 <HAL_GetTick>
 800f0a4:	6178      	str	r0, [r7, #20]
  
  /* Wait until flag is set */
  if(Status == RESET)
 800f0a6:	79fb      	ldrb	r3, [r7, #7]
 800f0a8:	2b00      	cmp	r3, #0
 800f0aa:	d142      	bne.n	800f132 <UART_WaitOnFlagUntilTimeout+0xa2>
  {    
    while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
 800f0ac:	e038      	b.n	800f120 <UART_WaitOnFlagUntilTimeout+0x90>
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 800f0ae:	683b      	ldr	r3, [r7, #0]
 800f0b0:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f0b4:	d034      	beq.n	800f120 <UART_WaitOnFlagUntilTimeout+0x90>
      {
        if((Timeout == 0)||((HAL_GetTick()-tickstart) >=  Timeout))
 800f0b6:	683b      	ldr	r3, [r7, #0]
 800f0b8:	2b00      	cmp	r3, #0
 800f0ba:	d007      	beq.n	800f0cc <UART_WaitOnFlagUntilTimeout+0x3c>
 800f0bc:	f7f7 f8cc 	bl	8006258 <HAL_GetTick>
 800f0c0:	4602      	mov	r2, r0
 800f0c2:	697b      	ldr	r3, [r7, #20]
 800f0c4:	1ad2      	subs	r2, r2, r3
 800f0c6:	683b      	ldr	r3, [r7, #0]
 800f0c8:	429a      	cmp	r2, r3
 800f0ca:	d329      	bcc.n	800f120 <UART_WaitOnFlagUntilTimeout+0x90>
        {
          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
          __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 800f0cc:	68fb      	ldr	r3, [r7, #12]
 800f0ce:	681b      	ldr	r3, [r3, #0]
 800f0d0:	68fa      	ldr	r2, [r7, #12]
 800f0d2:	6812      	ldr	r2, [r2, #0]
 800f0d4:	6812      	ldr	r2, [r2, #0]
 800f0d6:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800f0da:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 800f0dc:	68fb      	ldr	r3, [r7, #12]
 800f0de:	681b      	ldr	r3, [r3, #0]
 800f0e0:	68fa      	ldr	r2, [r7, #12]
 800f0e2:	6812      	ldr	r2, [r2, #0]
 800f0e4:	6812      	ldr	r2, [r2, #0]
 800f0e6:	f022 0220 	bic.w	r2, r2, #32
 800f0ea:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 800f0ec:	68fb      	ldr	r3, [r7, #12]
 800f0ee:	681b      	ldr	r3, [r3, #0]
 800f0f0:	68fa      	ldr	r2, [r7, #12]
 800f0f2:	6812      	ldr	r2, [r2, #0]
 800f0f4:	6812      	ldr	r2, [r2, #0]
 800f0f6:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800f0fa:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 800f0fc:	68fb      	ldr	r3, [r7, #12]
 800f0fe:	681b      	ldr	r3, [r3, #0]
 800f100:	68fa      	ldr	r2, [r7, #12]
 800f102:	6812      	ldr	r2, [r2, #0]
 800f104:	6892      	ldr	r2, [r2, #8]
 800f106:	f022 0201 	bic.w	r2, r2, #1
 800f10a:	609a      	str	r2, [r3, #8]
          
          huart->State= HAL_UART_STATE_READY;
 800f10c:	68fb      	ldr	r3, [r7, #12]
 800f10e:	2201      	movs	r2, #1
 800f110:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
          
          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 800f114:	68fb      	ldr	r3, [r7, #12]
 800f116:	2200      	movs	r2, #0
 800f118:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
          
          return HAL_TIMEOUT;
 800f11c:	2303      	movs	r3, #3
 800f11e:	e04b      	b.n	800f1b8 <UART_WaitOnFlagUntilTimeout+0x128>
  uint32_t tickstart = HAL_GetTick();
  
  /* Wait until flag is set */
  if(Status == RESET)
  {    
    while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
 800f120:	68fb      	ldr	r3, [r7, #12]
 800f122:	681b      	ldr	r3, [r3, #0]
 800f124:	69da      	ldr	r2, [r3, #28]
 800f126:	68bb      	ldr	r3, [r7, #8]
 800f128:	401a      	ands	r2, r3
 800f12a:	68bb      	ldr	r3, [r7, #8]
 800f12c:	429a      	cmp	r2, r3
 800f12e:	d1be      	bne.n	800f0ae <UART_WaitOnFlagUntilTimeout+0x1e>
 800f130:	e041      	b.n	800f1b6 <UART_WaitOnFlagUntilTimeout+0x126>
      }
    }
  }
  else
  {
    while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
 800f132:	e038      	b.n	800f1a6 <UART_WaitOnFlagUntilTimeout+0x116>
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 800f134:	683b      	ldr	r3, [r7, #0]
 800f136:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f13a:	d034      	beq.n	800f1a6 <UART_WaitOnFlagUntilTimeout+0x116>
      {
        if((Timeout == 0)||((HAL_GetTick()-tickstart) >=  Timeout))
 800f13c:	683b      	ldr	r3, [r7, #0]
 800f13e:	2b00      	cmp	r3, #0
 800f140:	d007      	beq.n	800f152 <UART_WaitOnFlagUntilTimeout+0xc2>
 800f142:	f7f7 f889 	bl	8006258 <HAL_GetTick>
 800f146:	4602      	mov	r2, r0
 800f148:	697b      	ldr	r3, [r7, #20]
 800f14a:	1ad2      	subs	r2, r2, r3
 800f14c:	683b      	ldr	r3, [r7, #0]
 800f14e:	429a      	cmp	r2, r3
 800f150:	d329      	bcc.n	800f1a6 <UART_WaitOnFlagUntilTimeout+0x116>
        {
          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
          __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 800f152:	68fb      	ldr	r3, [r7, #12]
 800f154:	681b      	ldr	r3, [r3, #0]
 800f156:	68fa      	ldr	r2, [r7, #12]
 800f158:	6812      	ldr	r2, [r2, #0]
 800f15a:	6812      	ldr	r2, [r2, #0]
 800f15c:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800f160:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 800f162:	68fb      	ldr	r3, [r7, #12]
 800f164:	681b      	ldr	r3, [r3, #0]
 800f166:	68fa      	ldr	r2, [r7, #12]
 800f168:	6812      	ldr	r2, [r2, #0]
 800f16a:	6812      	ldr	r2, [r2, #0]
 800f16c:	f022 0220 	bic.w	r2, r2, #32
 800f170:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 800f172:	68fb      	ldr	r3, [r7, #12]
 800f174:	681b      	ldr	r3, [r3, #0]
 800f176:	68fa      	ldr	r2, [r7, #12]
 800f178:	6812      	ldr	r2, [r2, #0]
 800f17a:	6812      	ldr	r2, [r2, #0]
 800f17c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800f180:	601a      	str	r2, [r3, #0]
          __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 800f182:	68fb      	ldr	r3, [r7, #12]
 800f184:	681b      	ldr	r3, [r3, #0]
 800f186:	68fa      	ldr	r2, [r7, #12]
 800f188:	6812      	ldr	r2, [r2, #0]
 800f18a:	6892      	ldr	r2, [r2, #8]
 800f18c:	f022 0201 	bic.w	r2, r2, #1
 800f190:	609a      	str	r2, [r3, #8]
          
          huart->State= HAL_UART_STATE_READY;
 800f192:	68fb      	ldr	r3, [r7, #12]
 800f194:	2201      	movs	r2, #1
 800f196:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
          
          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 800f19a:	68fb      	ldr	r3, [r7, #12]
 800f19c:	2200      	movs	r2, #0
 800f19e:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
          
          return HAL_TIMEOUT;
 800f1a2:	2303      	movs	r3, #3
 800f1a4:	e008      	b.n	800f1b8 <UART_WaitOnFlagUntilTimeout+0x128>
      }
    }
  }
  else
  {
    while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
 800f1a6:	68fb      	ldr	r3, [r7, #12]
 800f1a8:	681b      	ldr	r3, [r3, #0]
 800f1aa:	69da      	ldr	r2, [r3, #28]
 800f1ac:	68bb      	ldr	r3, [r7, #8]
 800f1ae:	401a      	ands	r2, r3
 800f1b0:	68bb      	ldr	r3, [r7, #8]
 800f1b2:	429a      	cmp	r2, r3
 800f1b4:	d0be      	beq.n	800f134 <UART_WaitOnFlagUntilTimeout+0xa4>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;      
 800f1b6:	2300      	movs	r3, #0
}
 800f1b8:	4618      	mov	r0, r3
 800f1ba:	3718      	adds	r7, #24
 800f1bc:	46bd      	mov	sp, r7
 800f1be:	bd80      	pop	{r7, pc}

0800f1c0 <UART_DMAReceiveCplt>:
  * @brief DMA UART receive process complete callback 
  * @param hdma: DMA handle
  * @retval None
  */
static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)  
{
 800f1c0:	b580      	push	{r7, lr}
 800f1c2:	b084      	sub	sp, #16
 800f1c4:	af00      	add	r7, sp, #0
 800f1c6:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800f1c8:	687b      	ldr	r3, [r7, #4]
 800f1ca:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800f1cc:	60fb      	str	r3, [r7, #12]
  
  /* DMA Normal mode */
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 800f1ce:	687b      	ldr	r3, [r7, #4]
 800f1d0:	681b      	ldr	r3, [r3, #0]
 800f1d2:	681b      	ldr	r3, [r3, #0]
 800f1d4:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800f1d8:	2b00      	cmp	r3, #0
 800f1da:	d11a      	bne.n	800f212 <UART_DMAReceiveCplt+0x52>
  { 
    huart->RxXferCount = 0;
 800f1dc:	68fb      	ldr	r3, [r7, #12]
 800f1de:	2200      	movs	r2, #0
 800f1e0:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a
    
    /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
    in the UART CR3 register */
    huart->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DMAR);
 800f1e4:	68fb      	ldr	r3, [r7, #12]
 800f1e6:	681b      	ldr	r3, [r3, #0]
 800f1e8:	68fa      	ldr	r2, [r7, #12]
 800f1ea:	6812      	ldr	r2, [r2, #0]
 800f1ec:	6892      	ldr	r2, [r2, #8]
 800f1ee:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800f1f2:	609a      	str	r2, [r3, #8]
    
    /* Check if a transmit Process is ongoing or not */
    if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
 800f1f4:	68fb      	ldr	r3, [r7, #12]
 800f1f6:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
 800f1fa:	b2db      	uxtb	r3, r3
 800f1fc:	2b32      	cmp	r3, #50	; 0x32
 800f1fe:	d104      	bne.n	800f20a <UART_DMAReceiveCplt+0x4a>
    {
      huart->State = HAL_UART_STATE_BUSY_TX;
 800f200:	68fb      	ldr	r3, [r7, #12]
 800f202:	2212      	movs	r2, #18
 800f204:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
 800f208:	e003      	b.n	800f212 <UART_DMAReceiveCplt+0x52>
    }
    else
    {
      huart->State = HAL_UART_STATE_READY;
 800f20a:	68fb      	ldr	r3, [r7, #12]
 800f20c:	2201      	movs	r2, #1
 800f20e:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
    }
  }
  HAL_UART_RxCpltCallback(huart);
 800f212:	68f8      	ldr	r0, [r7, #12]
 800f214:	f000 f832 	bl	800f27c <HAL_UART_RxCpltCallback>
}
 800f218:	3710      	adds	r7, #16
 800f21a:	46bd      	mov	sp, r7
 800f21c:	bd80      	pop	{r7, pc}
 800f21e:	bf00      	nop

0800f220 <UART_DMARxHalfCplt>:
  * @brief DMA UART receive process half complete callback 
  * @param hdma : DMA handle
  * @retval None
  */
static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
 800f220:	b580      	push	{r7, lr}
 800f222:	b084      	sub	sp, #16
 800f224:	af00      	add	r7, sp, #0
 800f226:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
 800f228:	687b      	ldr	r3, [r7, #4]
 800f22a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800f22c:	60fb      	str	r3, [r7, #12]

  HAL_UART_RxHalfCpltCallback(huart); 
 800f22e:	68f8      	ldr	r0, [r7, #12]
 800f230:	f000 f82e 	bl	800f290 <HAL_UART_RxHalfCpltCallback>
}
 800f234:	3710      	adds	r7, #16
 800f236:	46bd      	mov	sp, r7
 800f238:	bd80      	pop	{r7, pc}
 800f23a:	bf00      	nop

0800f23c <UART_DMAError>:
  * @brief DMA UART communication error callback 
  * @param hdma: DMA handle
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)   
{
 800f23c:	b580      	push	{r7, lr}
 800f23e:	b084      	sub	sp, #16
 800f240:	af00      	add	r7, sp, #0
 800f242:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800f244:	687b      	ldr	r3, [r7, #4]
 800f246:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800f248:	60fb      	str	r3, [r7, #12]
  huart->RxXferCount = 0;
 800f24a:	68fb      	ldr	r3, [r7, #12]
 800f24c:	2200      	movs	r2, #0
 800f24e:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a
  huart->TxXferCount = 0;
 800f252:	68fb      	ldr	r3, [r7, #12]
 800f254:	2200      	movs	r2, #0
 800f256:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
  huart->State= HAL_UART_STATE_READY;
 800f25a:	68fb      	ldr	r3, [r7, #12]
 800f25c:	2201      	movs	r2, #1
 800f25e:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 800f262:	68fb      	ldr	r3, [r7, #12]
 800f264:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800f266:	f043 0210 	orr.w	r2, r3, #16
 800f26a:	68fb      	ldr	r3, [r7, #12]
 800f26c:	66da      	str	r2, [r3, #108]	; 0x6c
  HAL_UART_ErrorCallback(huart);
 800f26e:	68f8      	ldr	r0, [r7, #12]
 800f270:	f000 f818 	bl	800f2a4 <HAL_UART_ErrorCallback>
}
 800f274:	3710      	adds	r7, #16
 800f276:	46bd      	mov	sp, r7
 800f278:	bd80      	pop	{r7, pc}
 800f27a:	bf00      	nop

0800f27c <HAL_UART_RxCpltCallback>:
  * @brief Rx Transfer completed callbacks
  * @param huart: uart handle
  * @retval None
  */
__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
 800f27c:	b480      	push	{r7}
 800f27e:	b083      	sub	sp, #12
 800f280:	af00      	add	r7, sp, #0
 800f282:	6078      	str	r0, [r7, #4]
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_RxCpltCallback can be implemented in the user file
   */
}
 800f284:	370c      	adds	r7, #12
 800f286:	46bd      	mov	sp, r7
 800f288:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f28c:	4770      	bx	lr
 800f28e:	bf00      	nop

0800f290 <HAL_UART_RxHalfCpltCallback>:
  * @brief  Rx Half Transfer completed callbacks.
  * @param  huart: UART handle
  * @retval None
  */
__weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
{
 800f290:	b480      	push	{r7}
 800f292:	b083      	sub	sp, #12
 800f294:	af00      	add	r7, sp, #0
 800f296:	6078      	str	r0, [r7, #4]
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_RxHalfCpltCallback can be implemented in the user file
   */
}
 800f298:	370c      	adds	r7, #12
 800f29a:	46bd      	mov	sp, r7
 800f29c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f2a0:	4770      	bx	lr
 800f2a2:	bf00      	nop

0800f2a4 <HAL_UART_ErrorCallback>:
  * @brief UART error callbacks
  * @param huart: uart handle
  * @retval None
  */
 __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 800f2a4:	b480      	push	{r7}
 800f2a6:	b083      	sub	sp, #12
 800f2a8:	af00      	add	r7, sp, #0
 800f2aa:	6078      	str	r0, [r7, #4]
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_ErrorCallback can be implemented in the user file
   */ 
}
 800f2ac:	370c      	adds	r7, #12
 800f2ae:	46bd      	mov	sp, r7
 800f2b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f2b4:	4770      	bx	lr
 800f2b6:	bf00      	nop

0800f2b8 <UART_SetConfig>:
  * @brief Configure the UART peripheral 
  * @param huart: uart handle
  * @retval None
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 800f2b8:	b590      	push	{r4, r7, lr}
 800f2ba:	b087      	sub	sp, #28
 800f2bc:	af00      	add	r7, sp, #0
 800f2be:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg                     = 0x00000000;
 800f2c0:	2300      	movs	r3, #0
 800f2c2:	60fb      	str	r3, [r7, #12]
  UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
 800f2c4:	2310      	movs	r3, #16
 800f2c6:	75fb      	strb	r3, [r7, #23]
  uint16_t brrtemp                    = 0x0000;
 800f2c8:	2300      	movs	r3, #0
 800f2ca:	817b      	strh	r3, [r7, #10]
  uint16_t usartdiv                   = 0x0000;
 800f2cc:	2300      	movs	r3, #0
 800f2ce:	82bb      	strh	r3, [r7, #20]
  HAL_StatusTypeDef ret               = HAL_OK;  
 800f2d0:	2300      	movs	r3, #0
 800f2d2:	74fb      	strb	r3, [r7, #19]
   *  the UART Word Length, Parity, Mode and oversampling: 
   *  set the M bits according to huart->Init.WordLength value 
   *  set PCE and PS bits according to huart->Init.Parity value
   *  set TE and RE bits according to huart->Init.Mode value
   *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800f2d4:	687b      	ldr	r3, [r7, #4]
 800f2d6:	689a      	ldr	r2, [r3, #8]
 800f2d8:	687b      	ldr	r3, [r7, #4]
 800f2da:	691b      	ldr	r3, [r3, #16]
 800f2dc:	431a      	orrs	r2, r3
 800f2de:	687b      	ldr	r3, [r7, #4]
 800f2e0:	695b      	ldr	r3, [r3, #20]
 800f2e2:	431a      	orrs	r2, r3
 800f2e4:	687b      	ldr	r3, [r7, #4]
 800f2e6:	69db      	ldr	r3, [r3, #28]
 800f2e8:	4313      	orrs	r3, r2
 800f2ea:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 800f2ec:	687b      	ldr	r3, [r7, #4]
 800f2ee:	681a      	ldr	r2, [r3, #0]
 800f2f0:	687b      	ldr	r3, [r7, #4]
 800f2f2:	681b      	ldr	r3, [r3, #0]
 800f2f4:	6819      	ldr	r1, [r3, #0]
 800f2f6:	4bac      	ldr	r3, [pc, #688]	; (800f5a8 <UART_SetConfig+0x2f0>)
 800f2f8:	400b      	ands	r3, r1
 800f2fa:	68f9      	ldr	r1, [r7, #12]
 800f2fc:	430b      	orrs	r3, r1
 800f2fe:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
   * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800f300:	687b      	ldr	r3, [r7, #4]
 800f302:	681b      	ldr	r3, [r3, #0]
 800f304:	687a      	ldr	r2, [r7, #4]
 800f306:	6812      	ldr	r2, [r2, #0]
 800f308:	6852      	ldr	r2, [r2, #4]
 800f30a:	f422 5140 	bic.w	r1, r2, #12288	; 0x3000
 800f30e:	687a      	ldr	r2, [r7, #4]
 800f310:	68d2      	ldr	r2, [r2, #12]
 800f312:	430a      	orrs	r2, r1
 800f314:	605a      	str	r2, [r3, #4]
  /* Configure 
   * - UART HardWare Flow Control: set CTSE and RTSE bits according 
   *   to huart->Init.HwFlowCtl value 
   * - one-bit sampling method versus three samples' majority rule according
   *   to huart->Init.OneBitSampling */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 800f316:	687b      	ldr	r3, [r7, #4]
 800f318:	699a      	ldr	r2, [r3, #24]
 800f31a:	687b      	ldr	r3, [r7, #4]
 800f31c:	6a1b      	ldr	r3, [r3, #32]
 800f31e:	4313      	orrs	r3, r2
 800f320:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 800f322:	687b      	ldr	r3, [r7, #4]
 800f324:	681b      	ldr	r3, [r3, #0]
 800f326:	687a      	ldr	r2, [r7, #4]
 800f328:	6812      	ldr	r2, [r2, #0]
 800f32a:	6892      	ldr	r2, [r2, #8]
 800f32c:	f422 6130 	bic.w	r1, r2, #2816	; 0xb00
 800f330:	68fa      	ldr	r2, [r7, #12]
 800f332:	430a      	orrs	r2, r1
 800f334:	609a      	str	r2, [r3, #8]
  
  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 800f336:	687b      	ldr	r3, [r7, #4]
 800f338:	681b      	ldr	r3, [r3, #0]
 800f33a:	4a9c      	ldr	r2, [pc, #624]	; (800f5ac <UART_SetConfig+0x2f4>)
 800f33c:	4293      	cmp	r3, r2
 800f33e:	d11e      	bne.n	800f37e <UART_SetConfig+0xc6>
 800f340:	4b9b      	ldr	r3, [pc, #620]	; (800f5b0 <UART_SetConfig+0x2f8>)
 800f342:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800f346:	f003 0303 	and.w	r3, r3, #3
 800f34a:	2b03      	cmp	r3, #3
 800f34c:	d815      	bhi.n	800f37a <UART_SetConfig+0xc2>
 800f34e:	a201      	add	r2, pc, #4	; (adr r2, 800f354 <UART_SetConfig+0x9c>)
 800f350:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800f354:	0800f365 	.word	0x0800f365
 800f358:	0800f371 	.word	0x0800f371
 800f35c:	0800f36b 	.word	0x0800f36b
 800f360:	0800f377 	.word	0x0800f377
 800f364:	2301      	movs	r3, #1
 800f366:	75fb      	strb	r3, [r7, #23]
 800f368:	e007      	b.n	800f37a <UART_SetConfig+0xc2>
 800f36a:	2302      	movs	r3, #2
 800f36c:	75fb      	strb	r3, [r7, #23]
 800f36e:	e004      	b.n	800f37a <UART_SetConfig+0xc2>
 800f370:	2304      	movs	r3, #4
 800f372:	75fb      	strb	r3, [r7, #23]
 800f374:	e001      	b.n	800f37a <UART_SetConfig+0xc2>
 800f376:	2308      	movs	r3, #8
 800f378:	75fb      	strb	r3, [r7, #23]
 800f37a:	bf00      	nop
 800f37c:	e12b      	b.n	800f5d6 <UART_SetConfig+0x31e>
 800f37e:	687b      	ldr	r3, [r7, #4]
 800f380:	681b      	ldr	r3, [r3, #0]
 800f382:	4a8c      	ldr	r2, [pc, #560]	; (800f5b4 <UART_SetConfig+0x2fc>)
 800f384:	4293      	cmp	r3, r2
 800f386:	d130      	bne.n	800f3ea <UART_SetConfig+0x132>
 800f388:	4b89      	ldr	r3, [pc, #548]	; (800f5b0 <UART_SetConfig+0x2f8>)
 800f38a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800f38e:	f003 030c 	and.w	r3, r3, #12
 800f392:	2b0c      	cmp	r3, #12
 800f394:	d827      	bhi.n	800f3e6 <UART_SetConfig+0x12e>
 800f396:	a201      	add	r2, pc, #4	; (adr r2, 800f39c <UART_SetConfig+0xe4>)
 800f398:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800f39c:	0800f3d1 	.word	0x0800f3d1
 800f3a0:	0800f3e7 	.word	0x0800f3e7
 800f3a4:	0800f3e7 	.word	0x0800f3e7
 800f3a8:	0800f3e7 	.word	0x0800f3e7
 800f3ac:	0800f3dd 	.word	0x0800f3dd
 800f3b0:	0800f3e7 	.word	0x0800f3e7
 800f3b4:	0800f3e7 	.word	0x0800f3e7
 800f3b8:	0800f3e7 	.word	0x0800f3e7
 800f3bc:	0800f3d7 	.word	0x0800f3d7
 800f3c0:	0800f3e7 	.word	0x0800f3e7
 800f3c4:	0800f3e7 	.word	0x0800f3e7
 800f3c8:	0800f3e7 	.word	0x0800f3e7
 800f3cc:	0800f3e3 	.word	0x0800f3e3
 800f3d0:	2300      	movs	r3, #0
 800f3d2:	75fb      	strb	r3, [r7, #23]
 800f3d4:	e007      	b.n	800f3e6 <UART_SetConfig+0x12e>
 800f3d6:	2302      	movs	r3, #2
 800f3d8:	75fb      	strb	r3, [r7, #23]
 800f3da:	e004      	b.n	800f3e6 <UART_SetConfig+0x12e>
 800f3dc:	2304      	movs	r3, #4
 800f3de:	75fb      	strb	r3, [r7, #23]
 800f3e0:	e001      	b.n	800f3e6 <UART_SetConfig+0x12e>
 800f3e2:	2308      	movs	r3, #8
 800f3e4:	75fb      	strb	r3, [r7, #23]
 800f3e6:	bf00      	nop
 800f3e8:	e0f5      	b.n	800f5d6 <UART_SetConfig+0x31e>
 800f3ea:	687b      	ldr	r3, [r7, #4]
 800f3ec:	681b      	ldr	r3, [r3, #0]
 800f3ee:	4a72      	ldr	r2, [pc, #456]	; (800f5b8 <UART_SetConfig+0x300>)
 800f3f0:	4293      	cmp	r3, r2
 800f3f2:	d11d      	bne.n	800f430 <UART_SetConfig+0x178>
 800f3f4:	4b6e      	ldr	r3, [pc, #440]	; (800f5b0 <UART_SetConfig+0x2f8>)
 800f3f6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800f3fa:	f003 0330 	and.w	r3, r3, #48	; 0x30
 800f3fe:	2b10      	cmp	r3, #16
 800f400:	d00f      	beq.n	800f422 <UART_SetConfig+0x16a>
 800f402:	2b10      	cmp	r3, #16
 800f404:	d802      	bhi.n	800f40c <UART_SetConfig+0x154>
 800f406:	2b00      	cmp	r3, #0
 800f408:	d005      	beq.n	800f416 <UART_SetConfig+0x15e>
 800f40a:	e00f      	b.n	800f42c <UART_SetConfig+0x174>
 800f40c:	2b20      	cmp	r3, #32
 800f40e:	d005      	beq.n	800f41c <UART_SetConfig+0x164>
 800f410:	2b30      	cmp	r3, #48	; 0x30
 800f412:	d009      	beq.n	800f428 <UART_SetConfig+0x170>
 800f414:	e00a      	b.n	800f42c <UART_SetConfig+0x174>
 800f416:	2300      	movs	r3, #0
 800f418:	75fb      	strb	r3, [r7, #23]
 800f41a:	e007      	b.n	800f42c <UART_SetConfig+0x174>
 800f41c:	2302      	movs	r3, #2
 800f41e:	75fb      	strb	r3, [r7, #23]
 800f420:	e004      	b.n	800f42c <UART_SetConfig+0x174>
 800f422:	2304      	movs	r3, #4
 800f424:	75fb      	strb	r3, [r7, #23]
 800f426:	e001      	b.n	800f42c <UART_SetConfig+0x174>
 800f428:	2308      	movs	r3, #8
 800f42a:	75fb      	strb	r3, [r7, #23]
 800f42c:	bf00      	nop
 800f42e:	e0d2      	b.n	800f5d6 <UART_SetConfig+0x31e>
 800f430:	687b      	ldr	r3, [r7, #4]
 800f432:	681b      	ldr	r3, [r3, #0]
 800f434:	4a61      	ldr	r2, [pc, #388]	; (800f5bc <UART_SetConfig+0x304>)
 800f436:	4293      	cmp	r3, r2
 800f438:	d11d      	bne.n	800f476 <UART_SetConfig+0x1be>
 800f43a:	4b5d      	ldr	r3, [pc, #372]	; (800f5b0 <UART_SetConfig+0x2f8>)
 800f43c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800f440:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 800f444:	2b40      	cmp	r3, #64	; 0x40
 800f446:	d00f      	beq.n	800f468 <UART_SetConfig+0x1b0>
 800f448:	2b40      	cmp	r3, #64	; 0x40
 800f44a:	d802      	bhi.n	800f452 <UART_SetConfig+0x19a>
 800f44c:	2b00      	cmp	r3, #0
 800f44e:	d005      	beq.n	800f45c <UART_SetConfig+0x1a4>
 800f450:	e00f      	b.n	800f472 <UART_SetConfig+0x1ba>
 800f452:	2b80      	cmp	r3, #128	; 0x80
 800f454:	d005      	beq.n	800f462 <UART_SetConfig+0x1aa>
 800f456:	2bc0      	cmp	r3, #192	; 0xc0
 800f458:	d009      	beq.n	800f46e <UART_SetConfig+0x1b6>
 800f45a:	e00a      	b.n	800f472 <UART_SetConfig+0x1ba>
 800f45c:	2300      	movs	r3, #0
 800f45e:	75fb      	strb	r3, [r7, #23]
 800f460:	e007      	b.n	800f472 <UART_SetConfig+0x1ba>
 800f462:	2302      	movs	r3, #2
 800f464:	75fb      	strb	r3, [r7, #23]
 800f466:	e004      	b.n	800f472 <UART_SetConfig+0x1ba>
 800f468:	2304      	movs	r3, #4
 800f46a:	75fb      	strb	r3, [r7, #23]
 800f46c:	e001      	b.n	800f472 <UART_SetConfig+0x1ba>
 800f46e:	2308      	movs	r3, #8
 800f470:	75fb      	strb	r3, [r7, #23]
 800f472:	bf00      	nop
 800f474:	e0af      	b.n	800f5d6 <UART_SetConfig+0x31e>
 800f476:	687b      	ldr	r3, [r7, #4]
 800f478:	681b      	ldr	r3, [r3, #0]
 800f47a:	4a51      	ldr	r2, [pc, #324]	; (800f5c0 <UART_SetConfig+0x308>)
 800f47c:	4293      	cmp	r3, r2
 800f47e:	d121      	bne.n	800f4c4 <UART_SetConfig+0x20c>
 800f480:	4b4b      	ldr	r3, [pc, #300]	; (800f5b0 <UART_SetConfig+0x2f8>)
 800f482:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800f486:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800f48a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800f48e:	d012      	beq.n	800f4b6 <UART_SetConfig+0x1fe>
 800f490:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800f494:	d802      	bhi.n	800f49c <UART_SetConfig+0x1e4>
 800f496:	2b00      	cmp	r3, #0
 800f498:	d007      	beq.n	800f4aa <UART_SetConfig+0x1f2>
 800f49a:	e011      	b.n	800f4c0 <UART_SetConfig+0x208>
 800f49c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800f4a0:	d006      	beq.n	800f4b0 <UART_SetConfig+0x1f8>
 800f4a2:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800f4a6:	d009      	beq.n	800f4bc <UART_SetConfig+0x204>
 800f4a8:	e00a      	b.n	800f4c0 <UART_SetConfig+0x208>
 800f4aa:	2300      	movs	r3, #0
 800f4ac:	75fb      	strb	r3, [r7, #23]
 800f4ae:	e007      	b.n	800f4c0 <UART_SetConfig+0x208>
 800f4b0:	2302      	movs	r3, #2
 800f4b2:	75fb      	strb	r3, [r7, #23]
 800f4b4:	e004      	b.n	800f4c0 <UART_SetConfig+0x208>
 800f4b6:	2304      	movs	r3, #4
 800f4b8:	75fb      	strb	r3, [r7, #23]
 800f4ba:	e001      	b.n	800f4c0 <UART_SetConfig+0x208>
 800f4bc:	2308      	movs	r3, #8
 800f4be:	75fb      	strb	r3, [r7, #23]
 800f4c0:	bf00      	nop
 800f4c2:	e088      	b.n	800f5d6 <UART_SetConfig+0x31e>
 800f4c4:	687b      	ldr	r3, [r7, #4]
 800f4c6:	681b      	ldr	r3, [r3, #0]
 800f4c8:	4a3e      	ldr	r2, [pc, #248]	; (800f5c4 <UART_SetConfig+0x30c>)
 800f4ca:	4293      	cmp	r3, r2
 800f4cc:	d121      	bne.n	800f512 <UART_SetConfig+0x25a>
 800f4ce:	4b38      	ldr	r3, [pc, #224]	; (800f5b0 <UART_SetConfig+0x2f8>)
 800f4d0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800f4d4:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 800f4d8:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800f4dc:	d012      	beq.n	800f504 <UART_SetConfig+0x24c>
 800f4de:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800f4e2:	d802      	bhi.n	800f4ea <UART_SetConfig+0x232>
 800f4e4:	2b00      	cmp	r3, #0
 800f4e6:	d007      	beq.n	800f4f8 <UART_SetConfig+0x240>
 800f4e8:	e011      	b.n	800f50e <UART_SetConfig+0x256>
 800f4ea:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800f4ee:	d006      	beq.n	800f4fe <UART_SetConfig+0x246>
 800f4f0:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800f4f4:	d009      	beq.n	800f50a <UART_SetConfig+0x252>
 800f4f6:	e00a      	b.n	800f50e <UART_SetConfig+0x256>
 800f4f8:	2301      	movs	r3, #1
 800f4fa:	75fb      	strb	r3, [r7, #23]
 800f4fc:	e007      	b.n	800f50e <UART_SetConfig+0x256>
 800f4fe:	2302      	movs	r3, #2
 800f500:	75fb      	strb	r3, [r7, #23]
 800f502:	e004      	b.n	800f50e <UART_SetConfig+0x256>
 800f504:	2304      	movs	r3, #4
 800f506:	75fb      	strb	r3, [r7, #23]
 800f508:	e001      	b.n	800f50e <UART_SetConfig+0x256>
 800f50a:	2308      	movs	r3, #8
 800f50c:	75fb      	strb	r3, [r7, #23]
 800f50e:	bf00      	nop
 800f510:	e061      	b.n	800f5d6 <UART_SetConfig+0x31e>
 800f512:	687b      	ldr	r3, [r7, #4]
 800f514:	681b      	ldr	r3, [r3, #0]
 800f516:	4a2c      	ldr	r2, [pc, #176]	; (800f5c8 <UART_SetConfig+0x310>)
 800f518:	4293      	cmp	r3, r2
 800f51a:	d121      	bne.n	800f560 <UART_SetConfig+0x2a8>
 800f51c:	4b24      	ldr	r3, [pc, #144]	; (800f5b0 <UART_SetConfig+0x2f8>)
 800f51e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800f522:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 800f526:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800f52a:	d012      	beq.n	800f552 <UART_SetConfig+0x29a>
 800f52c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800f530:	d802      	bhi.n	800f538 <UART_SetConfig+0x280>
 800f532:	2b00      	cmp	r3, #0
 800f534:	d007      	beq.n	800f546 <UART_SetConfig+0x28e>
 800f536:	e011      	b.n	800f55c <UART_SetConfig+0x2a4>
 800f538:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800f53c:	d006      	beq.n	800f54c <UART_SetConfig+0x294>
 800f53e:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 800f542:	d009      	beq.n	800f558 <UART_SetConfig+0x2a0>
 800f544:	e00a      	b.n	800f55c <UART_SetConfig+0x2a4>
 800f546:	2300      	movs	r3, #0
 800f548:	75fb      	strb	r3, [r7, #23]
 800f54a:	e007      	b.n	800f55c <UART_SetConfig+0x2a4>
 800f54c:	2302      	movs	r3, #2
 800f54e:	75fb      	strb	r3, [r7, #23]
 800f550:	e004      	b.n	800f55c <UART_SetConfig+0x2a4>
 800f552:	2304      	movs	r3, #4
 800f554:	75fb      	strb	r3, [r7, #23]
 800f556:	e001      	b.n	800f55c <UART_SetConfig+0x2a4>
 800f558:	2308      	movs	r3, #8
 800f55a:	75fb      	strb	r3, [r7, #23]
 800f55c:	bf00      	nop
 800f55e:	e03a      	b.n	800f5d6 <UART_SetConfig+0x31e>
 800f560:	687b      	ldr	r3, [r7, #4]
 800f562:	681b      	ldr	r3, [r3, #0]
 800f564:	4a19      	ldr	r2, [pc, #100]	; (800f5cc <UART_SetConfig+0x314>)
 800f566:	4293      	cmp	r3, r2
 800f568:	d135      	bne.n	800f5d6 <UART_SetConfig+0x31e>
 800f56a:	4b11      	ldr	r3, [pc, #68]	; (800f5b0 <UART_SetConfig+0x2f8>)
 800f56c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800f570:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 800f574:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800f578:	d012      	beq.n	800f5a0 <UART_SetConfig+0x2e8>
 800f57a:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800f57e:	d802      	bhi.n	800f586 <UART_SetConfig+0x2ce>
 800f580:	2b00      	cmp	r3, #0
 800f582:	d007      	beq.n	800f594 <UART_SetConfig+0x2dc>
 800f584:	e026      	b.n	800f5d4 <UART_SetConfig+0x31c>
 800f586:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800f58a:	d006      	beq.n	800f59a <UART_SetConfig+0x2e2>
 800f58c:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 800f590:	d01e      	beq.n	800f5d0 <UART_SetConfig+0x318>
 800f592:	e01f      	b.n	800f5d4 <UART_SetConfig+0x31c>
 800f594:	2300      	movs	r3, #0
 800f596:	75fb      	strb	r3, [r7, #23]
 800f598:	e01c      	b.n	800f5d4 <UART_SetConfig+0x31c>
 800f59a:	2302      	movs	r3, #2
 800f59c:	75fb      	strb	r3, [r7, #23]
 800f59e:	e019      	b.n	800f5d4 <UART_SetConfig+0x31c>
 800f5a0:	2304      	movs	r3, #4
 800f5a2:	75fb      	strb	r3, [r7, #23]
 800f5a4:	e016      	b.n	800f5d4 <UART_SetConfig+0x31c>
 800f5a6:	bf00      	nop
 800f5a8:	efff69f3 	.word	0xefff69f3
 800f5ac:	40011000 	.word	0x40011000
 800f5b0:	40023800 	.word	0x40023800
 800f5b4:	40004400 	.word	0x40004400
 800f5b8:	40004800 	.word	0x40004800
 800f5bc:	40004c00 	.word	0x40004c00
 800f5c0:	40005000 	.word	0x40005000
 800f5c4:	40011400 	.word	0x40011400
 800f5c8:	40007800 	.word	0x40007800
 800f5cc:	40007c00 	.word	0x40007c00
 800f5d0:	2308      	movs	r3, #8
 800f5d2:	75fb      	strb	r3, [r7, #23]
 800f5d4:	bf00      	nop

  /* Check UART Over Sampling to set Baud Rate Register */
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800f5d6:	687b      	ldr	r3, [r7, #4]
 800f5d8:	69db      	ldr	r3, [r3, #28]
 800f5da:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800f5de:	d158      	bne.n	800f692 <UART_SetConfig+0x3da>
  { 
    switch (clocksource)
 800f5e0:	7dfb      	ldrb	r3, [r7, #23]
 800f5e2:	2b08      	cmp	r3, #8
 800f5e4:	d841      	bhi.n	800f66a <UART_SetConfig+0x3b2>
 800f5e6:	a201      	add	r2, pc, #4	; (adr r2, 800f5ec <UART_SetConfig+0x334>)
 800f5e8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800f5ec:	0800f611 	.word	0x0800f611
 800f5f0:	0800f625 	.word	0x0800f625
 800f5f4:	0800f639 	.word	0x0800f639
 800f5f8:	0800f66b 	.word	0x0800f66b
 800f5fc:	0800f647 	.word	0x0800f647
 800f600:	0800f66b 	.word	0x0800f66b
 800f604:	0800f66b 	.word	0x0800f66b
 800f608:	0800f66b 	.word	0x0800f66b
 800f60c:	0800f65b 	.word	0x0800f65b
    {
    case UART_CLOCKSOURCE_PCLK1:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 800f610:	f7fe fb14 	bl	800dc3c <HAL_RCC_GetPCLK1Freq>
 800f614:	4603      	mov	r3, r0
 800f616:	005a      	lsls	r2, r3, #1
 800f618:	687b      	ldr	r3, [r7, #4]
 800f61a:	685b      	ldr	r3, [r3, #4]
 800f61c:	fbb2 f3f3 	udiv	r3, r2, r3
 800f620:	82bb      	strh	r3, [r7, #20]
      break;
 800f622:	e025      	b.n	800f670 <UART_SetConfig+0x3b8>
    case UART_CLOCKSOURCE_PCLK2:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 800f624:	f7fe fb2c 	bl	800dc80 <HAL_RCC_GetPCLK2Freq>
 800f628:	4603      	mov	r3, r0
 800f62a:	005a      	lsls	r2, r3, #1
 800f62c:	687b      	ldr	r3, [r7, #4]
 800f62e:	685b      	ldr	r3, [r3, #4]
 800f630:	fbb2 f3f3 	udiv	r3, r2, r3
 800f634:	82bb      	strh	r3, [r7, #20]
      break;
 800f636:	e01b      	b.n	800f670 <UART_SetConfig+0x3b8>
    case UART_CLOCKSOURCE_HSI:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate)); 
 800f638:	687b      	ldr	r3, [r7, #4]
 800f63a:	685b      	ldr	r3, [r3, #4]
 800f63c:	4a42      	ldr	r2, [pc, #264]	; (800f748 <UART_SetConfig+0x490>)
 800f63e:	fbb2 f3f3 	udiv	r3, r2, r3
 800f642:	82bb      	strh	r3, [r7, #20]
      break;
 800f644:	e014      	b.n	800f670 <UART_SetConfig+0x3b8>
    case UART_CLOCKSOURCE_SYSCLK:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800f646:	f7fe fa53 	bl	800daf0 <HAL_RCC_GetSysClockFreq>
 800f64a:	4603      	mov	r3, r0
 800f64c:	005a      	lsls	r2, r3, #1
 800f64e:	687b      	ldr	r3, [r7, #4]
 800f650:	685b      	ldr	r3, [r3, #4]
 800f652:	fbb2 f3f3 	udiv	r3, r2, r3
 800f656:	82bb      	strh	r3, [r7, #20]
      break;
 800f658:	e00a      	b.n	800f670 <UART_SetConfig+0x3b8>
    case UART_CLOCKSOURCE_LSE:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate)); 
 800f65a:	687b      	ldr	r3, [r7, #4]
 800f65c:	685b      	ldr	r3, [r3, #4]
 800f65e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800f662:	fbb2 f3f3 	udiv	r3, r2, r3
 800f666:	82bb      	strh	r3, [r7, #20]
      break;
 800f668:	e002      	b.n	800f670 <UART_SetConfig+0x3b8>
      case UART_CLOCKSOURCE_UNDEFINED:                
    default:
        ret = HAL_ERROR; 
 800f66a:	2301      	movs	r3, #1
 800f66c:	74fb      	strb	r3, [r7, #19]
      break;
 800f66e:	bf00      	nop
    }
    
    brrtemp = usartdiv & 0xFFF0;
 800f670:	8abb      	ldrh	r3, [r7, #20]
 800f672:	f023 030f 	bic.w	r3, r3, #15
 800f676:	817b      	strh	r3, [r7, #10]
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000F) >> 1U);
 800f678:	8abb      	ldrh	r3, [r7, #20]
 800f67a:	f003 030f 	and.w	r3, r3, #15
 800f67e:	105b      	asrs	r3, r3, #1
 800f680:	b29a      	uxth	r2, r3
 800f682:	897b      	ldrh	r3, [r7, #10]
 800f684:	4313      	orrs	r3, r2
 800f686:	817b      	strh	r3, [r7, #10]
    huart->Instance->BRR = brrtemp;
 800f688:	687b      	ldr	r3, [r7, #4]
 800f68a:	681b      	ldr	r3, [r3, #0]
 800f68c:	897a      	ldrh	r2, [r7, #10]
 800f68e:	60da      	str	r2, [r3, #12]
 800f690:	e054      	b.n	800f73c <UART_SetConfig+0x484>
  }
  else
  {
    switch (clocksource)
 800f692:	7dfb      	ldrb	r3, [r7, #23]
 800f694:	2b08      	cmp	r3, #8
 800f696:	d84e      	bhi.n	800f736 <UART_SetConfig+0x47e>
 800f698:	a201      	add	r2, pc, #4	; (adr r2, 800f6a0 <UART_SetConfig+0x3e8>)
 800f69a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800f69e:	bf00      	nop
 800f6a0:	0800f6c5 	.word	0x0800f6c5
 800f6a4:	0800f6dd 	.word	0x0800f6dd
 800f6a8:	0800f6f5 	.word	0x0800f6f5
 800f6ac:	0800f737 	.word	0x0800f737
 800f6b0:	0800f709 	.word	0x0800f709
 800f6b4:	0800f737 	.word	0x0800f737
 800f6b8:	0800f737 	.word	0x0800f737
 800f6bc:	0800f737 	.word	0x0800f737
 800f6c0:	0800f721 	.word	0x0800f721
    {
    case UART_CLOCKSOURCE_PCLK1: 
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 800f6c4:	687b      	ldr	r3, [r7, #4]
 800f6c6:	681c      	ldr	r4, [r3, #0]
 800f6c8:	f7fe fab8 	bl	800dc3c <HAL_RCC_GetPCLK1Freq>
 800f6cc:	4602      	mov	r2, r0
 800f6ce:	687b      	ldr	r3, [r7, #4]
 800f6d0:	685b      	ldr	r3, [r3, #4]
 800f6d2:	fbb2 f3f3 	udiv	r3, r2, r3
 800f6d6:	b29b      	uxth	r3, r3
 800f6d8:	60e3      	str	r3, [r4, #12]
      break;
 800f6da:	e02f      	b.n	800f73c <UART_SetConfig+0x484>
    case UART_CLOCKSOURCE_PCLK2: 
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 800f6dc:	687b      	ldr	r3, [r7, #4]
 800f6de:	681c      	ldr	r4, [r3, #0]
 800f6e0:	f7fe face 	bl	800dc80 <HAL_RCC_GetPCLK2Freq>
 800f6e4:	4602      	mov	r2, r0
 800f6e6:	687b      	ldr	r3, [r7, #4]
 800f6e8:	685b      	ldr	r3, [r3, #4]
 800f6ea:	fbb2 f3f3 	udiv	r3, r2, r3
 800f6ee:	b29b      	uxth	r3, r3
 800f6f0:	60e3      	str	r3, [r4, #12]
      break;
 800f6f2:	e023      	b.n	800f73c <UART_SetConfig+0x484>
    case UART_CLOCKSOURCE_HSI: 
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate)); 
 800f6f4:	687b      	ldr	r3, [r7, #4]
 800f6f6:	681b      	ldr	r3, [r3, #0]
 800f6f8:	687a      	ldr	r2, [r7, #4]
 800f6fa:	6852      	ldr	r2, [r2, #4]
 800f6fc:	4913      	ldr	r1, [pc, #76]	; (800f74c <UART_SetConfig+0x494>)
 800f6fe:	fbb1 f2f2 	udiv	r2, r1, r2
 800f702:	b292      	uxth	r2, r2
 800f704:	60da      	str	r2, [r3, #12]
      break; 
 800f706:	e019      	b.n	800f73c <UART_SetConfig+0x484>
    case UART_CLOCKSOURCE_SYSCLK:  
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800f708:	687b      	ldr	r3, [r7, #4]
 800f70a:	681c      	ldr	r4, [r3, #0]
 800f70c:	f7fe f9f0 	bl	800daf0 <HAL_RCC_GetSysClockFreq>
 800f710:	4602      	mov	r2, r0
 800f712:	687b      	ldr	r3, [r7, #4]
 800f714:	685b      	ldr	r3, [r3, #4]
 800f716:	fbb2 f3f3 	udiv	r3, r2, r3
 800f71a:	b29b      	uxth	r3, r3
 800f71c:	60e3      	str	r3, [r4, #12]
      break;  
 800f71e:	e00d      	b.n	800f73c <UART_SetConfig+0x484>
    case UART_CLOCKSOURCE_LSE:
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate)); 
 800f720:	687b      	ldr	r3, [r7, #4]
 800f722:	681b      	ldr	r3, [r3, #0]
 800f724:	687a      	ldr	r2, [r7, #4]
 800f726:	6852      	ldr	r2, [r2, #4]
 800f728:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800f72c:	fbb1 f2f2 	udiv	r2, r1, r2
 800f730:	b292      	uxth	r2, r2
 800f732:	60da      	str	r2, [r3, #12]
      break;
 800f734:	e002      	b.n	800f73c <UART_SetConfig+0x484>
      case UART_CLOCKSOURCE_UNDEFINED:                
    default:
        ret = HAL_ERROR; 
 800f736:	2301      	movs	r3, #1
 800f738:	74fb      	strb	r3, [r7, #19]
      break;
 800f73a:	bf00      	nop
    }
  }

  return ret;   
 800f73c:	7cfb      	ldrb	r3, [r7, #19]

}
 800f73e:	4618      	mov	r0, r3
 800f740:	371c      	adds	r7, #28
 800f742:	46bd      	mov	sp, r7
 800f744:	bd90      	pop	{r4, r7, pc}
 800f746:	bf00      	nop
 800f748:	01e84800 	.word	0x01e84800
 800f74c:	00f42400 	.word	0x00f42400

0800f750 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features 
  * @param huart: uart handle  
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 800f750:	b480      	push	{r7}
 800f752:	b083      	sub	sp, #12
 800f754:	af00      	add	r7, sp, #0
 800f756:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */ 
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
  
  /* if required, configure TX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800f758:	687b      	ldr	r3, [r7, #4]
 800f75a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f75c:	f003 0301 	and.w	r3, r3, #1
 800f760:	2b00      	cmp	r3, #0
 800f762:	d00a      	beq.n	800f77a <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 800f764:	687b      	ldr	r3, [r7, #4]
 800f766:	681b      	ldr	r3, [r3, #0]
 800f768:	687a      	ldr	r2, [r7, #4]
 800f76a:	6812      	ldr	r2, [r2, #0]
 800f76c:	6852      	ldr	r2, [r2, #4]
 800f76e:	f422 3100 	bic.w	r1, r2, #131072	; 0x20000
 800f772:	687a      	ldr	r2, [r7, #4]
 800f774:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800f776:	430a      	orrs	r2, r1
 800f778:	605a      	str	r2, [r3, #4]
  }
  
  /* if required, configure RX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800f77a:	687b      	ldr	r3, [r7, #4]
 800f77c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f77e:	f003 0302 	and.w	r3, r3, #2
 800f782:	2b00      	cmp	r3, #0
 800f784:	d00a      	beq.n	800f79c <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800f786:	687b      	ldr	r3, [r7, #4]
 800f788:	681b      	ldr	r3, [r3, #0]
 800f78a:	687a      	ldr	r2, [r7, #4]
 800f78c:	6812      	ldr	r2, [r2, #0]
 800f78e:	6852      	ldr	r2, [r2, #4]
 800f790:	f422 3180 	bic.w	r1, r2, #65536	; 0x10000
 800f794:	687a      	ldr	r2, [r7, #4]
 800f796:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800f798:	430a      	orrs	r2, r1
 800f79a:	605a      	str	r2, [r3, #4]
  }
  
  /* if required, configure data inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800f79c:	687b      	ldr	r3, [r7, #4]
 800f79e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f7a0:	f003 0304 	and.w	r3, r3, #4
 800f7a4:	2b00      	cmp	r3, #0
 800f7a6:	d00a      	beq.n	800f7be <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800f7a8:	687b      	ldr	r3, [r7, #4]
 800f7aa:	681b      	ldr	r3, [r3, #0]
 800f7ac:	687a      	ldr	r2, [r7, #4]
 800f7ae:	6812      	ldr	r2, [r2, #0]
 800f7b0:	6852      	ldr	r2, [r2, #4]
 800f7b2:	f422 2180 	bic.w	r1, r2, #262144	; 0x40000
 800f7b6:	687a      	ldr	r2, [r7, #4]
 800f7b8:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800f7ba:	430a      	orrs	r2, r1
 800f7bc:	605a      	str	r2, [r3, #4]
  }
  
  /* if required, configure RX/TX pins swap */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800f7be:	687b      	ldr	r3, [r7, #4]
 800f7c0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f7c2:	f003 0308 	and.w	r3, r3, #8
 800f7c6:	2b00      	cmp	r3, #0
 800f7c8:	d00a      	beq.n	800f7e0 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800f7ca:	687b      	ldr	r3, [r7, #4]
 800f7cc:	681b      	ldr	r3, [r3, #0]
 800f7ce:	687a      	ldr	r2, [r7, #4]
 800f7d0:	6812      	ldr	r2, [r2, #0]
 800f7d2:	6852      	ldr	r2, [r2, #4]
 800f7d4:	f422 4100 	bic.w	r1, r2, #32768	; 0x8000
 800f7d8:	687a      	ldr	r2, [r7, #4]
 800f7da:	6b52      	ldr	r2, [r2, #52]	; 0x34
 800f7dc:	430a      	orrs	r2, r1
 800f7de:	605a      	str	r2, [r3, #4]
  }
  
  /* if required, configure RX overrun detection disabling */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800f7e0:	687b      	ldr	r3, [r7, #4]
 800f7e2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f7e4:	f003 0310 	and.w	r3, r3, #16
 800f7e8:	2b00      	cmp	r3, #0
 800f7ea:	d00a      	beq.n	800f802 <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));  
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800f7ec:	687b      	ldr	r3, [r7, #4]
 800f7ee:	681b      	ldr	r3, [r3, #0]
 800f7f0:	687a      	ldr	r2, [r7, #4]
 800f7f2:	6812      	ldr	r2, [r2, #0]
 800f7f4:	6892      	ldr	r2, [r2, #8]
 800f7f6:	f422 5180 	bic.w	r1, r2, #4096	; 0x1000
 800f7fa:	687a      	ldr	r2, [r7, #4]
 800f7fc:	6b92      	ldr	r2, [r2, #56]	; 0x38
 800f7fe:	430a      	orrs	r2, r1
 800f800:	609a      	str	r2, [r3, #8]
  }
  
  /* if required, configure DMA disabling on reception error */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800f802:	687b      	ldr	r3, [r7, #4]
 800f804:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f806:	f003 0320 	and.w	r3, r3, #32
 800f80a:	2b00      	cmp	r3, #0
 800f80c:	d00a      	beq.n	800f824 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));   
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800f80e:	687b      	ldr	r3, [r7, #4]
 800f810:	681b      	ldr	r3, [r3, #0]
 800f812:	687a      	ldr	r2, [r7, #4]
 800f814:	6812      	ldr	r2, [r2, #0]
 800f816:	6892      	ldr	r2, [r2, #8]
 800f818:	f422 5100 	bic.w	r1, r2, #8192	; 0x2000
 800f81c:	687a      	ldr	r2, [r7, #4]
 800f81e:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 800f820:	430a      	orrs	r2, r1
 800f822:	609a      	str	r2, [r3, #8]
  }
  
  /* if required, configure auto Baud rate detection scheme */              
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800f824:	687b      	ldr	r3, [r7, #4]
 800f826:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f828:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800f82c:	2b00      	cmp	r3, #0
 800f82e:	d01a      	beq.n	800f866 <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800f830:	687b      	ldr	r3, [r7, #4]
 800f832:	681b      	ldr	r3, [r3, #0]
 800f834:	687a      	ldr	r2, [r7, #4]
 800f836:	6812      	ldr	r2, [r2, #0]
 800f838:	6852      	ldr	r2, [r2, #4]
 800f83a:	f422 1180 	bic.w	r1, r2, #1048576	; 0x100000
 800f83e:	687a      	ldr	r2, [r7, #4]
 800f840:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800f842:	430a      	orrs	r2, r1
 800f844:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800f846:	687b      	ldr	r3, [r7, #4]
 800f848:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f84a:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800f84e:	d10a      	bne.n	800f866 <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800f850:	687b      	ldr	r3, [r7, #4]
 800f852:	681b      	ldr	r3, [r3, #0]
 800f854:	687a      	ldr	r2, [r7, #4]
 800f856:	6812      	ldr	r2, [r2, #0]
 800f858:	6852      	ldr	r2, [r2, #4]
 800f85a:	f422 01c0 	bic.w	r1, r2, #6291456	; 0x600000
 800f85e:	687a      	ldr	r2, [r7, #4]
 800f860:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800f862:	430a      	orrs	r2, r1
 800f864:	605a      	str	r2, [r3, #4]
    }
  }
  
  /* if required, configure MSB first on communication line */  
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800f866:	687b      	ldr	r3, [r7, #4]
 800f868:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f86a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800f86e:	2b00      	cmp	r3, #0
 800f870:	d00a      	beq.n	800f888 <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));   
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800f872:	687b      	ldr	r3, [r7, #4]
 800f874:	681b      	ldr	r3, [r3, #0]
 800f876:	687a      	ldr	r2, [r7, #4]
 800f878:	6812      	ldr	r2, [r2, #0]
 800f87a:	6852      	ldr	r2, [r2, #4]
 800f87c:	f422 2100 	bic.w	r1, r2, #524288	; 0x80000
 800f880:	687a      	ldr	r2, [r7, #4]
 800f882:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800f884:	430a      	orrs	r2, r1
 800f886:	605a      	str	r2, [r3, #4]
  }
}
 800f888:	370c      	adds	r7, #12
 800f88a:	46bd      	mov	sp, r7
 800f88c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f890:	4770      	bx	lr
 800f892:	bf00      	nop

0800f894 <UART_CheckIdleState>:
  * @brief Check the UART Idle State
  * @param huart: uart handle
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 800f894:	b580      	push	{r7, lr}
 800f896:	b082      	sub	sp, #8
 800f898:	af00      	add	r7, sp, #0
 800f89a:	6078      	str	r0, [r7, #4]
  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800f89c:	687b      	ldr	r3, [r7, #4]
 800f89e:	2200      	movs	r2, #0
 800f8a0:	66da      	str	r2, [r3, #108]	; 0x6c
  
  /* Check if the Transmitter is enabled */
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800f8a2:	687b      	ldr	r3, [r7, #4]
 800f8a4:	681b      	ldr	r3, [r3, #0]
 800f8a6:	681b      	ldr	r3, [r3, #0]
 800f8a8:	f003 0308 	and.w	r3, r3, #8
 800f8ac:	2b00      	cmp	r3, #0
 800f8ae:	d00c      	beq.n	800f8ca <UART_CheckIdleState+0x36>
  {
    /* Wait until TEACK flag is set */
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, HAL_UART_TIMEOUT_VALUE) != HAL_OK)  
 800f8b0:	6878      	ldr	r0, [r7, #4]
 800f8b2:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 800f8b6:	2200      	movs	r2, #0
 800f8b8:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 800f8bc:	f7ff fbe8 	bl	800f090 <UART_WaitOnFlagUntilTimeout>
 800f8c0:	4603      	mov	r3, r0
 800f8c2:	2b00      	cmp	r3, #0
 800f8c4:	d001      	beq.n	800f8ca <UART_CheckIdleState+0x36>
    {
      /* Timeout Occurred */
      return HAL_TIMEOUT;
 800f8c6:	2303      	movs	r3, #3
 800f8c8:	e01c      	b.n	800f904 <UART_CheckIdleState+0x70>
    }
  }
  /* Check if the Receiver is enabled */
  if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 800f8ca:	687b      	ldr	r3, [r7, #4]
 800f8cc:	681b      	ldr	r3, [r3, #0]
 800f8ce:	681b      	ldr	r3, [r3, #0]
 800f8d0:	f003 0304 	and.w	r3, r3, #4
 800f8d4:	2b00      	cmp	r3, #0
 800f8d6:	d00c      	beq.n	800f8f2 <UART_CheckIdleState+0x5e>
  {
    /* Wait until REACK flag is set */
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET,  HAL_UART_TIMEOUT_VALUE) != HAL_OK)  
 800f8d8:	6878      	ldr	r0, [r7, #4]
 800f8da:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 800f8de:	2200      	movs	r2, #0
 800f8e0:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 800f8e4:	f7ff fbd4 	bl	800f090 <UART_WaitOnFlagUntilTimeout>
 800f8e8:	4603      	mov	r3, r0
 800f8ea:	2b00      	cmp	r3, #0
 800f8ec:	d001      	beq.n	800f8f2 <UART_CheckIdleState+0x5e>
    { 
      /* Timeout Occurred */
      return HAL_TIMEOUT;
 800f8ee:	2303      	movs	r3, #3
 800f8f0:	e008      	b.n	800f904 <UART_CheckIdleState+0x70>
    }
  }
  
  /* Initialize the UART State */
  huart->State= HAL_UART_STATE_READY;
 800f8f2:	687b      	ldr	r3, [r7, #4]
 800f8f4:	2201      	movs	r2, #1
 800f8f6:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
    
  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 800f8fa:	687b      	ldr	r3, [r7, #4]
 800f8fc:	2200      	movs	r2, #0
 800f8fe:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
  
  return HAL_OK;
 800f902:	2300      	movs	r3, #0
}
 800f904:	4618      	mov	r0, r3
 800f906:	3708      	adds	r7, #8
 800f908:	46bd      	mov	sp, r7
 800f90a:	bd80      	pop	{r7, pc}

0800f90c <FMC_SDRAM_Init>:
  * @param  Device: Pointer to SDRAM device instance
  * @param  Init: Pointer to SDRAM Initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
 800f90c:	b480      	push	{r7}
 800f90e:	b085      	sub	sp, #20
 800f910:	af00      	add	r7, sp, #0
 800f912:	6078      	str	r0, [r7, #4]
 800f914:	6039      	str	r1, [r7, #0]
  uint32_t tmpr1 = 0;
 800f916:	2300      	movs	r3, #0
 800f918:	60fb      	str	r3, [r7, #12]
  uint32_t tmpr2 = 0;
 800f91a:	2300      	movs	r3, #0
 800f91c:	60bb      	str	r3, [r7, #8]
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));   

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank != FMC_SDRAM_BANK2) 
 800f91e:	683b      	ldr	r3, [r7, #0]
 800f920:	681b      	ldr	r3, [r3, #0]
 800f922:	2b01      	cmp	r3, #1
 800f924:	d027      	beq.n	800f976 <FMC_SDRAM_Init+0x6a>
  { 
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
 800f926:	687b      	ldr	r3, [r7, #4]
 800f928:	681b      	ldr	r3, [r3, #0]
 800f92a:	60fb      	str	r3, [r7, #12]
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 800f92c:	68fa      	ldr	r2, [r7, #12]
 800f92e:	4b2f      	ldr	r3, [pc, #188]	; (800f9ec <FMC_SDRAM_Init+0xe0>)
 800f930:	4013      	ands	r3, r2
 800f932:	60fb      	str	r3, [r7, #12]
                         FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800f934:	683b      	ldr	r3, [r7, #0]
 800f936:	685a      	ldr	r2, [r3, #4]
                        Init->RowBitsNumber      |\
 800f938:	683b      	ldr	r3, [r7, #0]
 800f93a:	689b      	ldr	r3, [r3, #8]
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                         FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800f93c:	431a      	orrs	r2, r3
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
 800f93e:	683b      	ldr	r3, [r7, #0]
 800f940:	68db      	ldr	r3, [r3, #12]
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                         FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
                        Init->RowBitsNumber      |\
 800f942:	431a      	orrs	r2, r3
                        Init->MemoryDataWidth    |\
                        Init->InternalBankNumber |\
 800f944:	683b      	ldr	r3, [r7, #0]
 800f946:	691b      	ldr	r3, [r3, #16]
                         FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
 800f948:	431a      	orrs	r2, r3
                        Init->InternalBankNumber |\
                        Init->CASLatency         |\
 800f94a:	683b      	ldr	r3, [r7, #0]
 800f94c:	695b      	ldr	r3, [r3, #20]
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
                        Init->InternalBankNumber |\
 800f94e:	431a      	orrs	r2, r3
                        Init->CASLatency         |\
                        Init->WriteProtection    |\
 800f950:	683b      	ldr	r3, [r7, #0]
 800f952:	699b      	ldr	r3, [r3, #24]

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
                        Init->InternalBankNumber |\
                        Init->CASLatency         |\
 800f954:	431a      	orrs	r2, r3
                        Init->WriteProtection    |\
                        Init->SDClockPeriod      |\
 800f956:	683b      	ldr	r3, [r7, #0]
 800f958:	69db      	ldr	r3, [r3, #28]
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
                        Init->InternalBankNumber |\
                        Init->CASLatency         |\
                        Init->WriteProtection    |\
 800f95a:	431a      	orrs	r2, r3
                        Init->SDClockPeriod      |\
                        Init->ReadBurst          |\
 800f95c:	683b      	ldr	r3, [r7, #0]
 800f95e:	6a1b      	ldr	r3, [r3, #32]
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
                        Init->InternalBankNumber |\
                        Init->CASLatency         |\
                        Init->WriteProtection    |\
                        Init->SDClockPeriod      |\
 800f960:	431a      	orrs	r2, r3
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay
 800f962:	683b      	ldr	r3, [r7, #0]
 800f964:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                         FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800f966:	4313      	orrs	r3, r2
 800f968:	68fa      	ldr	r2, [r7, #12]
 800f96a:	4313      	orrs	r3, r2
 800f96c:	60fb      	str	r3, [r7, #12]
                        Init->WriteProtection    |\
                        Init->SDClockPeriod      |\
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay
                        );                                      
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 800f96e:	687b      	ldr	r3, [r7, #4]
 800f970:	68fa      	ldr	r2, [r7, #12]
 800f972:	601a      	str	r2, [r3, #0]
 800f974:	e032      	b.n	800f9dc <FMC_SDRAM_Init+0xd0>
  }
  else /* FMC_Bank2_SDRAM */                      
  {
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
 800f976:	687b      	ldr	r3, [r7, #4]
 800f978:	681b      	ldr	r3, [r3, #0]
 800f97a:	60fb      	str	r3, [r7, #12]
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 800f97c:	68fa      	ldr	r2, [r7, #12]
 800f97e:	4b1b      	ldr	r3, [pc, #108]	; (800f9ec <FMC_SDRAM_Init+0xe0>)
 800f980:	4013      	ands	r3, r2
 800f982:	60fb      	str	r3, [r7, #12]
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
    
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 800f984:	683b      	ldr	r3, [r7, #0]
 800f986:	69da      	ldr	r2, [r3, #28]
                        Init->ReadBurst          |\
 800f988:	683b      	ldr	r3, [r7, #0]
 800f98a:	6a1b      	ldr	r3, [r3, #32]
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
    
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 800f98c:	431a      	orrs	r2, r3
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay);  
 800f98e:	683b      	ldr	r3, [r7, #0]
 800f990:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
    
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 800f992:	4313      	orrs	r3, r2
 800f994:	68fa      	ldr	r2, [r7, #12]
 800f996:	4313      	orrs	r3, r2
 800f998:	60fb      	str	r3, [r7, #12]
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay);  
    
    tmpr2 = Device->SDCR[FMC_SDRAM_BANK2];
 800f99a:	687b      	ldr	r3, [r7, #4]
 800f99c:	685b      	ldr	r3, [r3, #4]
 800f99e:	60bb      	str	r3, [r7, #8]
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 800f9a0:	68ba      	ldr	r2, [r7, #8]
 800f9a2:	4b12      	ldr	r3, [pc, #72]	; (800f9ec <FMC_SDRAM_Init+0xe0>)
 800f9a4:	4013      	ands	r3, r2
 800f9a6:	60bb      	str	r3, [r7, #8]
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800f9a8:	683b      	ldr	r3, [r7, #0]
 800f9aa:	685a      	ldr	r2, [r3, #4]
                       Init->RowBitsNumber      |\
 800f9ac:	683b      	ldr	r3, [r7, #0]
 800f9ae:	689b      	ldr	r3, [r3, #8]
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800f9b0:	431a      	orrs	r2, r3
                       Init->RowBitsNumber      |\
                       Init->MemoryDataWidth    |\
 800f9b2:	683b      	ldr	r3, [r7, #0]
 800f9b4:	68db      	ldr	r3, [r3, #12]
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
                       Init->RowBitsNumber      |\
 800f9b6:	431a      	orrs	r2, r3
                       Init->MemoryDataWidth    |\
                       Init->InternalBankNumber |\
 800f9b8:	683b      	ldr	r3, [r7, #0]
 800f9ba:	691b      	ldr	r3, [r3, #16]
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
                       Init->RowBitsNumber      |\
                       Init->MemoryDataWidth    |\
 800f9bc:	431a      	orrs	r2, r3
                       Init->InternalBankNumber |\
                       Init->CASLatency         |\
 800f9be:	683b      	ldr	r3, [r7, #0]
 800f9c0:	695b      	ldr	r3, [r3, #20]
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
                       Init->RowBitsNumber      |\
                       Init->MemoryDataWidth    |\
                       Init->InternalBankNumber |\
 800f9c2:	431a      	orrs	r2, r3
                       Init->CASLatency         |\
                       Init->WriteProtection);
 800f9c4:	683b      	ldr	r3, [r7, #0]
 800f9c6:	699b      	ldr	r3, [r3, #24]
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800f9c8:	4313      	orrs	r3, r2
 800f9ca:	68ba      	ldr	r2, [r7, #8]
 800f9cc:	4313      	orrs	r3, r2
 800f9ce:	60bb      	str	r3, [r7, #8]
                       Init->MemoryDataWidth    |\
                       Init->InternalBankNumber |\
                       Init->CASLatency         |\
                       Init->WriteProtection);

    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 800f9d0:	687b      	ldr	r3, [r7, #4]
 800f9d2:	68fa      	ldr	r2, [r7, #12]
 800f9d4:	601a      	str	r2, [r3, #0]
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
 800f9d6:	687b      	ldr	r3, [r7, #4]
 800f9d8:	68ba      	ldr	r2, [r7, #8]
 800f9da:	605a      	str	r2, [r3, #4]
  }  
  
  return HAL_OK;
 800f9dc:	2300      	movs	r3, #0
}
 800f9de:	4618      	mov	r0, r3
 800f9e0:	3714      	adds	r7, #20
 800f9e2:	46bd      	mov	sp, r7
 800f9e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f9e8:	4770      	bx	lr
 800f9ea:	bf00      	nop
 800f9ec:	ffff8000 	.word	0xffff8000

0800f9f0 <FMC_SDRAM_Timing_Init>:
  * @param  Timing: Pointer to SDRAM Timing structure
  * @param  Bank: SDRAM bank number   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
{
 800f9f0:	b480      	push	{r7}
 800f9f2:	b087      	sub	sp, #28
 800f9f4:	af00      	add	r7, sp, #0
 800f9f6:	60f8      	str	r0, [r7, #12]
 800f9f8:	60b9      	str	r1, [r7, #8]
 800f9fa:	607a      	str	r2, [r7, #4]
  uint32_t tmpr1 = 0;
 800f9fc:	2300      	movs	r3, #0
 800f9fe:	617b      	str	r3, [r7, #20]
  uint32_t tmpr2 = 0;
 800fa00:	2300      	movs	r3, #0
 800fa02:	613b      	str	r3, [r7, #16]
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
  assert_param(IS_FMC_SDRAM_BANK(Bank));
  
  /* Set SDRAM device timing parameters */ 
  if (Bank != FMC_SDRAM_BANK2) 
 800fa04:	687b      	ldr	r3, [r7, #4]
 800fa06:	2b01      	cmp	r3, #1
 800fa08:	d02e      	beq.n	800fa68 <FMC_SDRAM_Timing_Init+0x78>
  { 
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
 800fa0a:	68fb      	ldr	r3, [r7, #12]
 800fa0c:	689b      	ldr	r3, [r3, #8]
 800fa0e:	617b      	str	r3, [r7, #20]
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 800fa10:	697b      	ldr	r3, [r7, #20]
 800fa12:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 800fa16:	617b      	str	r3, [r7, #20]
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 800fa18:	68bb      	ldr	r3, [r7, #8]
 800fa1a:	681b      	ldr	r3, [r3, #0]
 800fa1c:	1e5a      	subs	r2, r3, #1
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 800fa1e:	68bb      	ldr	r3, [r7, #8]
 800fa20:	685b      	ldr	r3, [r3, #4]
 800fa22:	3b01      	subs	r3, #1
 800fa24:	011b      	lsls	r3, r3, #4
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 800fa26:	431a      	orrs	r2, r3
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 800fa28:	68bb      	ldr	r3, [r7, #8]
 800fa2a:	689b      	ldr	r3, [r3, #8]
 800fa2c:	3b01      	subs	r3, #1
 800fa2e:	021b      	lsls	r3, r3, #8
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 800fa30:	431a      	orrs	r2, r3
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->RowCycleDelay)-1) << 12)       |\
 800fa32:	68bb      	ldr	r3, [r7, #8]
 800fa34:	68db      	ldr	r3, [r3, #12]
 800fa36:	3b01      	subs	r3, #1
 800fa38:	031b      	lsls	r3, r3, #12
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 800fa3a:	431a      	orrs	r2, r3
                       (((Timing->RowCycleDelay)-1) << 12)       |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
 800fa3c:	68bb      	ldr	r3, [r7, #8]
 800fa3e:	691b      	ldr	r3, [r3, #16]
 800fa40:	3b01      	subs	r3, #1
 800fa42:	041b      	lsls	r3, r3, #16
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->RowCycleDelay)-1) << 12)       |\
 800fa44:	431a      	orrs	r2, r3
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
                       (((Timing->RPDelay)-1) << 20)             |\
 800fa46:	68bb      	ldr	r3, [r7, #8]
 800fa48:	695b      	ldr	r3, [r3, #20]
 800fa4a:	3b01      	subs	r3, #1
 800fa4c:	051b      	lsls	r3, r3, #20
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->RowCycleDelay)-1) << 12)       |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
 800fa4e:	431a      	orrs	r2, r3
                       (((Timing->RPDelay)-1) << 20)             |\
                       (((Timing->RCDDelay)-1) << 24));
 800fa50:	68bb      	ldr	r3, [r7, #8]
 800fa52:	699b      	ldr	r3, [r3, #24]
 800fa54:	3b01      	subs	r3, #1
 800fa56:	061b      	lsls	r3, r3, #24
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 800fa58:	4313      	orrs	r3, r2
 800fa5a:	697a      	ldr	r2, [r7, #20]
 800fa5c:	4313      	orrs	r3, r2
 800fa5e:	617b      	str	r3, [r7, #20]
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->RowCycleDelay)-1) << 12)       |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
                       (((Timing->RPDelay)-1) << 20)             |\
                       (((Timing->RCDDelay)-1) << 24));
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
 800fa60:	68fb      	ldr	r3, [r7, #12]
 800fa62:	697a      	ldr	r2, [r7, #20]
 800fa64:	609a      	str	r2, [r3, #8]
 800fa66:	e039      	b.n	800fadc <FMC_SDRAM_Timing_Init+0xec>
  }
  else /* FMC_Bank2_SDRAM */
  {  
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK2];
 800fa68:	68fb      	ldr	r3, [r7, #12]
 800fa6a:	68db      	ldr	r3, [r3, #12]
 800fa6c:	617b      	str	r3, [r7, #20]
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 800fa6e:	697b      	ldr	r3, [r7, #20]
 800fa70:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 800fa74:	617b      	str	r3, [r7, #20]
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 800fa76:	68bb      	ldr	r3, [r7, #8]
 800fa78:	681b      	ldr	r3, [r3, #0]
 800fa7a:	1e5a      	subs	r2, r3, #1
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 800fa7c:	68bb      	ldr	r3, [r7, #8]
 800fa7e:	685b      	ldr	r3, [r3, #4]
 800fa80:	3b01      	subs	r3, #1
 800fa82:	011b      	lsls	r3, r3, #4
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 800fa84:	431a      	orrs	r2, r3
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 800fa86:	68bb      	ldr	r3, [r7, #8]
 800fa88:	689b      	ldr	r3, [r3, #8]
 800fa8a:	3b01      	subs	r3, #1
 800fa8c:	021b      	lsls	r3, r3, #8
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 800fa8e:	431a      	orrs	r2, r3
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
 800fa90:	68bb      	ldr	r3, [r7, #8]
 800fa92:	691b      	ldr	r3, [r3, #16]
 800fa94:	3b01      	subs	r3, #1
 800fa96:	041b      	lsls	r3, r3, #16
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 800fa98:	431a      	orrs	r2, r3
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
                       (((Timing->RCDDelay)-1) << 24));   
 800fa9a:	68bb      	ldr	r3, [r7, #8]
 800fa9c:	699b      	ldr	r3, [r3, #24]
 800fa9e:	3b01      	subs	r3, #1
 800faa0:	061b      	lsls	r3, r3, #24
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 800faa2:	4313      	orrs	r3, r2
 800faa4:	697a      	ldr	r2, [r7, #20]
 800faa6:	4313      	orrs	r3, r2
 800faa8:	617b      	str	r3, [r7, #20]
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
                       (((Timing->RCDDelay)-1) << 24));   
    
    tmpr2 = Device->SDTR[FMC_SDRAM_BANK1];
 800faaa:	68fb      	ldr	r3, [r7, #12]
 800faac:	689b      	ldr	r3, [r3, #8]
 800faae:	613b      	str	r3, [r7, #16]
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 800fab0:	693b      	ldr	r3, [r7, #16]
 800fab2:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 800fab6:	613b      	str	r3, [r7, #16]
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    tmpr2 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 800fab8:	68bb      	ldr	r3, [r7, #8]
 800faba:	68db      	ldr	r3, [r3, #12]
 800fabc:	3b01      	subs	r3, #1
 800fabe:	031a      	lsls	r2, r3, #12
                        (((Timing->RPDelay)-1) << 20)); 
 800fac0:	68bb      	ldr	r3, [r7, #8]
 800fac2:	695b      	ldr	r3, [r3, #20]
 800fac4:	3b01      	subs	r3, #1
 800fac6:	051b      	lsls	r3, r3, #20
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    tmpr2 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 800fac8:	4313      	orrs	r3, r2
 800faca:	693a      	ldr	r2, [r7, #16]
 800facc:	4313      	orrs	r3, r2
 800face:	613b      	str	r3, [r7, #16]
                        (((Timing->RPDelay)-1) << 20)); 

    Device->SDTR[FMC_SDRAM_BANK2] = tmpr1;
 800fad0:	68fb      	ldr	r3, [r7, #12]
 800fad2:	697a      	ldr	r2, [r7, #20]
 800fad4:	60da      	str	r2, [r3, #12]
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr2;
 800fad6:	68fb      	ldr	r3, [r7, #12]
 800fad8:	693a      	ldr	r2, [r7, #16]
 800fada:	609a      	str	r2, [r3, #8]
  }   
  
  return HAL_OK;
 800fadc:	2300      	movs	r3, #0
}
 800fade:	4618      	mov	r0, r3
 800fae0:	371c      	adds	r7, #28
 800fae2:	46bd      	mov	sp, r7
 800fae4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fae8:	4770      	bx	lr
 800faea:	bf00      	nop

0800faec <FMC_SDRAM_SendCommand>:
  * @param  Timing: Pointer to SDRAM Timing structure
  * @param  Timeout: Timeout wait value
  * @retval HAL state
  */  
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 800faec:	b580      	push	{r7, lr}
 800faee:	b086      	sub	sp, #24
 800faf0:	af00      	add	r7, sp, #0
 800faf2:	60f8      	str	r0, [r7, #12]
 800faf4:	60b9      	str	r1, [r7, #8]
 800faf6:	607a      	str	r2, [r7, #4]
  __IO uint32_t tmpr = 0;
 800faf8:	2300      	movs	r3, #0
 800fafa:	613b      	str	r3, [r7, #16]
  uint32_t tickstart = 0;
 800fafc:	2300      	movs	r3, #0
 800fafe:	617b      	str	r3, [r7, #20]
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 800fb00:	68bb      	ldr	r3, [r7, #8]
 800fb02:	681a      	ldr	r2, [r3, #0]
                    (Command->CommandTarget)                |\
 800fb04:	68bb      	ldr	r3, [r7, #8]
 800fb06:	685b      	ldr	r3, [r3, #4]
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 800fb08:	431a      	orrs	r2, r3
                    (Command->CommandTarget)                |\
                    (((Command->AutoRefreshNumber)-1) << 5) |\
 800fb0a:	68bb      	ldr	r3, [r7, #8]
 800fb0c:	689b      	ldr	r3, [r3, #8]
 800fb0e:	3b01      	subs	r3, #1
 800fb10:	015b      	lsls	r3, r3, #5
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  tmpr = (uint32_t)((Command->CommandMode)                  |\
                    (Command->CommandTarget)                |\
 800fb12:	431a      	orrs	r2, r3
                    (((Command->AutoRefreshNumber)-1) << 5) |\
                    ((Command->ModeRegisterDefinition) << 9)
 800fb14:	68bb      	ldr	r3, [r7, #8]
 800fb16:	68db      	ldr	r3, [r3, #12]
 800fb18:	025b      	lsls	r3, r3, #9
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 800fb1a:	4313      	orrs	r3, r2
 800fb1c:	613b      	str	r3, [r7, #16]
                    (Command->CommandTarget)                |\
                    (((Command->AutoRefreshNumber)-1) << 5) |\
                    ((Command->ModeRegisterDefinition) << 9)
                    );
    
  Device->SDCMR = tmpr;
 800fb1e:	693a      	ldr	r2, [r7, #16]
 800fb20:	68fb      	ldr	r3, [r7, #12]
 800fb22:	611a      	str	r2, [r3, #16]

  /* Get tick */ 
  tickstart = HAL_GetTick();
 800fb24:	f7f6 fb98 	bl	8006258 <HAL_GetTick>
 800fb28:	6178      	str	r0, [r7, #20]

  /* wait until command is send */
  while(HAL_IS_BIT_SET(Device->SDSR, FMC_SDSR_BUSY))
 800fb2a:	bf00      	nop
 800fb2c:	68fb      	ldr	r3, [r7, #12]
 800fb2e:	699b      	ldr	r3, [r3, #24]
 800fb30:	f003 0320 	and.w	r3, r3, #32
 800fb34:	2b00      	cmp	r3, #0
 800fb36:	d012      	beq.n	800fb5e <FMC_SDRAM_SendCommand+0x72>
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 800fb38:	687b      	ldr	r3, [r7, #4]
 800fb3a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800fb3e:	d00c      	beq.n	800fb5a <FMC_SDRAM_SendCommand+0x6e>
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 800fb40:	687b      	ldr	r3, [r7, #4]
 800fb42:	2b00      	cmp	r3, #0
 800fb44:	d007      	beq.n	800fb56 <FMC_SDRAM_SendCommand+0x6a>
 800fb46:	f7f6 fb87 	bl	8006258 <HAL_GetTick>
 800fb4a:	4602      	mov	r2, r0
 800fb4c:	697b      	ldr	r3, [r7, #20]
 800fb4e:	1ad2      	subs	r2, r2, r3
 800fb50:	687b      	ldr	r3, [r7, #4]
 800fb52:	429a      	cmp	r2, r3
 800fb54:	d901      	bls.n	800fb5a <FMC_SDRAM_SendCommand+0x6e>
      {
        return HAL_TIMEOUT;
 800fb56:	2303      	movs	r3, #3
 800fb58:	e002      	b.n	800fb60 <FMC_SDRAM_SendCommand+0x74>
      }
    }     
    
    return HAL_ERROR;
 800fb5a:	2301      	movs	r3, #1
 800fb5c:	e000      	b.n	800fb60 <FMC_SDRAM_SendCommand+0x74>
  }
  
  return HAL_OK;  
 800fb5e:	2300      	movs	r3, #0
}
 800fb60:	4618      	mov	r0, r3
 800fb62:	3718      	adds	r7, #24
 800fb64:	46bd      	mov	sp, r7
 800fb66:	bd80      	pop	{r7, pc}

0800fb68 <FMC_SDRAM_ProgramRefreshRate>:
  * @param  Device: Pointer to SDRAM device instance  
  * @param  RefreshRate: The SDRAM refresh rate value.       
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
{
 800fb68:	b480      	push	{r7}
 800fb6a:	b083      	sub	sp, #12
 800fb6c:	af00      	add	r7, sp, #0
 800fb6e:	6078      	str	r0, [r7, #4]
 800fb70:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));
  
  /* Set the refresh rate in command register */
  Device->SDRTR |= (RefreshRate<<1);
 800fb72:	687b      	ldr	r3, [r7, #4]
 800fb74:	695a      	ldr	r2, [r3, #20]
 800fb76:	683b      	ldr	r3, [r7, #0]
 800fb78:	005b      	lsls	r3, r3, #1
 800fb7a:	431a      	orrs	r2, r3
 800fb7c:	687b      	ldr	r3, [r7, #4]
 800fb7e:	615a      	str	r2, [r3, #20]
  
  return HAL_OK;   
 800fb80:	2300      	movs	r3, #0
}
 800fb82:	4618      	mov	r0, r3
 800fb84:	370c      	adds	r7, #12
 800fb86:	46bd      	mov	sp, r7
 800fb88:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fb8c:	4770      	bx	lr
 800fb8e:	bf00      	nop

0800fb90 <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 800fb90:	b480      	push	{r7}
 800fb92:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800fb94:	4a15      	ldr	r2, [pc, #84]	; (800fbec <SystemInit+0x5c>)
 800fb96:	4b15      	ldr	r3, [pc, #84]	; (800fbec <SystemInit+0x5c>)
 800fb98:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800fb9c:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800fba0:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800fba4:	4a12      	ldr	r2, [pc, #72]	; (800fbf0 <SystemInit+0x60>)
 800fba6:	4b12      	ldr	r3, [pc, #72]	; (800fbf0 <SystemInit+0x60>)
 800fba8:	681b      	ldr	r3, [r3, #0]
 800fbaa:	f043 0301 	orr.w	r3, r3, #1
 800fbae:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800fbb0:	4b0f      	ldr	r3, [pc, #60]	; (800fbf0 <SystemInit+0x60>)
 800fbb2:	2200      	movs	r2, #0
 800fbb4:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 800fbb6:	490e      	ldr	r1, [pc, #56]	; (800fbf0 <SystemInit+0x60>)
 800fbb8:	4b0d      	ldr	r3, [pc, #52]	; (800fbf0 <SystemInit+0x60>)
 800fbba:	681a      	ldr	r2, [r3, #0]
 800fbbc:	4b0d      	ldr	r3, [pc, #52]	; (800fbf4 <SystemInit+0x64>)
 800fbbe:	4013      	ands	r3, r2
 800fbc0:	600b      	str	r3, [r1, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 800fbc2:	4b0b      	ldr	r3, [pc, #44]	; (800fbf0 <SystemInit+0x60>)
 800fbc4:	4a0c      	ldr	r2, [pc, #48]	; (800fbf8 <SystemInit+0x68>)
 800fbc6:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800fbc8:	4a09      	ldr	r2, [pc, #36]	; (800fbf0 <SystemInit+0x60>)
 800fbca:	4b09      	ldr	r3, [pc, #36]	; (800fbf0 <SystemInit+0x60>)
 800fbcc:	681b      	ldr	r3, [r3, #0]
 800fbce:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800fbd2:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 800fbd4:	4b06      	ldr	r3, [pc, #24]	; (800fbf0 <SystemInit+0x60>)
 800fbd6:	2200      	movs	r2, #0
 800fbd8:	60da      	str	r2, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800fbda:	4b04      	ldr	r3, [pc, #16]	; (800fbec <SystemInit+0x5c>)
 800fbdc:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800fbe0:	609a      	str	r2, [r3, #8]
#endif
}
 800fbe2:	46bd      	mov	sp, r7
 800fbe4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fbe8:	4770      	bx	lr
 800fbea:	bf00      	nop
 800fbec:	e000ed00 	.word	0xe000ed00
 800fbf0:	40023800 	.word	0x40023800
 800fbf4:	fef6ffff 	.word	0xfef6ffff
 800fbf8:	24003010 	.word	0x24003010

0800fbfc <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 800fbfc:	f8df d034 	ldr.w	sp, [pc, #52]	; 800fc34 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 800fc00:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800fc02:	e003      	b.n	800fc0c <LoopCopyDataInit>

0800fc04 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800fc04:	4b0c      	ldr	r3, [pc, #48]	; (800fc38 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 800fc06:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800fc08:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800fc0a:	3104      	adds	r1, #4

0800fc0c <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800fc0c:	480b      	ldr	r0, [pc, #44]	; (800fc3c <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 800fc0e:	4b0c      	ldr	r3, [pc, #48]	; (800fc40 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 800fc10:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800fc12:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800fc14:	d3f6      	bcc.n	800fc04 <CopyDataInit>
  ldr  r2, =_sbss
 800fc16:	4a0b      	ldr	r2, [pc, #44]	; (800fc44 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 800fc18:	e002      	b.n	800fc20 <LoopFillZerobss>

0800fc1a <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 800fc1a:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800fc1c:	f842 3b04 	str.w	r3, [r2], #4

0800fc20 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800fc20:	4b09      	ldr	r3, [pc, #36]	; (800fc48 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 800fc22:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800fc24:	d3f9      	bcc.n	800fc1a <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 800fc26:	f7ff ffb3 	bl	800fb90 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800fc2a:	f009 fba1 	bl	8019370 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800fc2e:	f005 f97f 	bl	8014f30 <main>
  bx  lr    
 800fc32:	4770      	bx	lr

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 800fc34:	200107ec 	.word	0x200107ec
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 800fc38:	0802c0f8 	.word	0x0802c0f8
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800fc3c:	20010000 	.word	0x20010000
  ldr  r3, =_edata
 800fc40:	200105ec 	.word	0x200105ec
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 800fc44:	200107ec 	.word	0x200107ec
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800fc48:	20012ff4 	.word	0x20012ff4

0800fc4c <CAN2_RX0_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800fc4c:	e7fe      	b.n	800fc4c <CAN2_RX0_IRQHandler>
	...

0800fc50 <j1939_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
static __inline void j1939_list_insert_before(struct list_node *l, struct list_node *n)
{
 800fc50:	b480      	push	{r7}
 800fc52:	b083      	sub	sp, #12
 800fc54:	af00      	add	r7, sp, #0
 800fc56:	6078      	str	r0, [r7, #4]
 800fc58:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 800fc5a:	687b      	ldr	r3, [r7, #4]
 800fc5c:	685b      	ldr	r3, [r3, #4]
 800fc5e:	683a      	ldr	r2, [r7, #0]
 800fc60:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 800fc62:	687b      	ldr	r3, [r7, #4]
 800fc64:	685a      	ldr	r2, [r3, #4]
 800fc66:	683b      	ldr	r3, [r7, #0]
 800fc68:	605a      	str	r2, [r3, #4]

    l->prev = n;
 800fc6a:	687b      	ldr	r3, [r7, #4]
 800fc6c:	683a      	ldr	r2, [r7, #0]
 800fc6e:	605a      	str	r2, [r3, #4]
    n->next = l;
 800fc70:	683b      	ldr	r3, [r7, #0]
 800fc72:	687a      	ldr	r2, [r7, #4]
 800fc74:	601a      	str	r2, [r3, #0]
}
 800fc76:	370c      	adds	r7, #12
 800fc78:	46bd      	mov	sp, r7
 800fc7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fc7e:	4770      	bx	lr

0800fc80 <list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
static __inline void list_init(struct list_node *l)
{
 800fc80:	b480      	push	{r7}
 800fc82:	b083      	sub	sp, #12
 800fc84:	af00      	add	r7, sp, #0
 800fc86:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 800fc88:	687b      	ldr	r3, [r7, #4]
 800fc8a:	687a      	ldr	r2, [r7, #4]
 800fc8c:	605a      	str	r2, [r3, #4]
 800fc8e:	687b      	ldr	r3, [r7, #4]
 800fc90:	685a      	ldr	r2, [r3, #4]
 800fc92:	687b      	ldr	r3, [r7, #4]
 800fc94:	601a      	str	r2, [r3, #0]
}
 800fc96:	370c      	adds	r7, #12
 800fc98:	46bd      	mov	sp, r7
 800fc9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fc9e:	4770      	bx	lr

0800fca0 <inttoch>:


#define Q_MAX_MSG 10;


char inttoch(int val) {
 800fca0:	b480      	push	{r7}
 800fca2:	b083      	sub	sp, #12
 800fca4:	af00      	add	r7, sp, #0
 800fca6:	6078      	str	r0, [r7, #4]
  if (val<10) return (char)('0'+val);
 800fca8:	687b      	ldr	r3, [r7, #4]
 800fcaa:	2b09      	cmp	r3, #9
 800fcac:	dc04      	bgt.n	800fcb8 <inttoch+0x18>
 800fcae:	687b      	ldr	r3, [r7, #4]
 800fcb0:	b2db      	uxtb	r3, r3
 800fcb2:	3330      	adds	r3, #48	; 0x30
 800fcb4:	b2db      	uxtb	r3, r3
 800fcb6:	e003      	b.n	800fcc0 <inttoch+0x20>
  return (char)('A'+val-10);
 800fcb8:	687b      	ldr	r3, [r7, #4]
 800fcba:	b2db      	uxtb	r3, r3
 800fcbc:	3337      	adds	r3, #55	; 0x37
 800fcbe:	b2db      	uxtb	r3, r3
}
 800fcc0:	4618      	mov	r0, r3
 800fcc2:	370c      	adds	r7, #12
 800fcc4:	46bd      	mov	sp, r7
 800fcc6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fcca:	4770      	bx	lr

0800fccc <inttostring>:

void inttostring(int vals,char *str,unsigned int base)
{
 800fccc:	b590      	push	{r4, r7, lr}
 800fcce:	b089      	sub	sp, #36	; 0x24
 800fcd0:	af00      	add	r7, sp, #0
 800fcd2:	60f8      	str	r0, [r7, #12]
 800fcd4:	60b9      	str	r1, [r7, #8]
 800fcd6:	607a      	str	r2, [r7, #4]
	unsigned int val;
	if (vals<0) {
 800fcd8:	68fb      	ldr	r3, [r7, #12]
 800fcda:	2b00      	cmp	r3, #0
 800fcdc:	da08      	bge.n	800fcf0 <inttostring+0x24>
	  *(str++)='-';
 800fcde:	68bb      	ldr	r3, [r7, #8]
 800fce0:	1c5a      	adds	r2, r3, #1
 800fce2:	60ba      	str	r2, [r7, #8]
 800fce4:	222d      	movs	r2, #45	; 0x2d
 800fce6:	701a      	strb	r2, [r3, #0]
	  val = (unsigned int)(-vals);
 800fce8:	68fb      	ldr	r3, [r7, #12]
 800fcea:	425b      	negs	r3, r3
 800fcec:	61fb      	str	r3, [r7, #28]
 800fcee:	e001      	b.n	800fcf4 <inttostring+0x28>
	} else {
	  val = (unsigned int)vals;
 800fcf0:	68fb      	ldr	r3, [r7, #12]
 800fcf2:	61fb      	str	r3, [r7, #28]
	}
	unsigned int d = 1;
 800fcf4:	2301      	movs	r3, #1
 800fcf6:	61bb      	str	r3, [r7, #24]
	while (d*base <= val) d*=base;
 800fcf8:	e004      	b.n	800fd04 <inttostring+0x38>
 800fcfa:	69bb      	ldr	r3, [r7, #24]
 800fcfc:	687a      	ldr	r2, [r7, #4]
 800fcfe:	fb02 f303 	mul.w	r3, r2, r3
 800fd02:	61bb      	str	r3, [r7, #24]
 800fd04:	69bb      	ldr	r3, [r7, #24]
 800fd06:	687a      	ldr	r2, [r7, #4]
 800fd08:	fb02 f203 	mul.w	r2, r2, r3
 800fd0c:	69fb      	ldr	r3, [r7, #28]
 800fd0e:	429a      	cmp	r2, r3
 800fd10:	d9f3      	bls.n	800fcfa <inttostring+0x2e>
	while (d > 1) {
 800fd12:	e019      	b.n	800fd48 <inttostring+0x7c>
	  unsigned int v = (unsigned int)(val / d);
 800fd14:	69fa      	ldr	r2, [r7, #28]
 800fd16:	69bb      	ldr	r3, [r7, #24]
 800fd18:	fbb2 f3f3 	udiv	r3, r2, r3
 800fd1c:	617b      	str	r3, [r7, #20]
	  val -= v*d;
 800fd1e:	697b      	ldr	r3, [r7, #20]
 800fd20:	69ba      	ldr	r2, [r7, #24]
 800fd22:	fb02 f303 	mul.w	r3, r2, r3
 800fd26:	69fa      	ldr	r2, [r7, #28]
 800fd28:	1ad3      	subs	r3, r2, r3
 800fd2a:	61fb      	str	r3, [r7, #28]
	  *(str++) = inttoch((int)v);
 800fd2c:	68bc      	ldr	r4, [r7, #8]
 800fd2e:	1c63      	adds	r3, r4, #1
 800fd30:	60bb      	str	r3, [r7, #8]
 800fd32:	697b      	ldr	r3, [r7, #20]
 800fd34:	4618      	mov	r0, r3
 800fd36:	f7ff ffb3 	bl	800fca0 <inttoch>
 800fd3a:	4603      	mov	r3, r0
 800fd3c:	7023      	strb	r3, [r4, #0]
	  d /= base;
 800fd3e:	69ba      	ldr	r2, [r7, #24]
 800fd40:	687b      	ldr	r3, [r7, #4]
 800fd42:	fbb2 f3f3 	udiv	r3, r2, r3
 800fd46:	61bb      	str	r3, [r7, #24]
	} else {
	  val = (unsigned int)vals;
	}
	unsigned int d = 1;
	while (d*base <= val) d*=base;
	while (d > 1) {
 800fd48:	69bb      	ldr	r3, [r7, #24]
 800fd4a:	2b01      	cmp	r3, #1
 800fd4c:	d8e2      	bhi.n	800fd14 <inttostring+0x48>
	  unsigned int v = (unsigned int)(val / d);
	  val -= v*d;
	  *(str++) = inttoch((int)v);
	  d /= base;
	}
	*(str++)=inttoch((int)val);
 800fd4e:	68bc      	ldr	r4, [r7, #8]
 800fd50:	1c63      	adds	r3, r4, #1
 800fd52:	60bb      	str	r3, [r7, #8]
 800fd54:	69fb      	ldr	r3, [r7, #28]
 800fd56:	4618      	mov	r0, r3
 800fd58:	f7ff ffa2 	bl	800fca0 <inttoch>
 800fd5c:	4603      	mov	r3, r0
 800fd5e:	7023      	strb	r3, [r4, #0]
	*(str++)=0;
 800fd60:	68bb      	ldr	r3, [r7, #8]
 800fd62:	1c5a      	adds	r2, r3, #1
 800fd64:	60ba      	str	r2, [r7, #8]
 800fd66:	2200      	movs	r2, #0
 800fd68:	701a      	strb	r2, [r3, #0]

}
 800fd6a:	3724      	adds	r7, #36	; 0x24
 800fd6c:	46bd      	mov	sp, r7
 800fd6e:	bd90      	pop	{r4, r7, pc}

0800fd70 <J1939_CA_register>:

unsigned char J1939_CA_register(CA_Msg_t ca_msg)
{
 800fd70:	b580      	push	{r7, lr}
 800fd72:	b08a      	sub	sp, #40	; 0x28
 800fd74:	af00      	add	r7, sp, #0
 800fd76:	6078      	str	r0, [r7, #4]
	unsigned char result = RC_SUCCESS;
 800fd78:	2300      	movs	r3, #0
 800fd7a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	struct CA_node * canode;
	struct os_messageQ_def queue_def;
	char str1[5];
	
	if((CA_FindAddress(&calist,ca_msg)) != 254)
 800fd7e:	4841      	ldr	r0, [pc, #260]	; (800fe84 <J1939_CA_register+0x114>)
 800fd80:	6879      	ldr	r1, [r7, #4]
 800fd82:	f001 facd 	bl	8011320 <CA_FindAddress>
 800fd86:	4603      	mov	r3, r0
 800fd88:	2bfe      	cmp	r3, #254	; 0xfe
 800fd8a:	d001      	beq.n	800fd90 <J1939_CA_register+0x20>
		return RC_ERROR;
 800fd8c:	2301      	movs	r3, #1
 800fd8e:	e075      	b.n	800fe7c <J1939_CA_register+0x10c>
	
	inttostring(ca_msg->CAname->FunInstance,str1,10);
 800fd90:	687b      	ldr	r3, [r7, #4]
 800fd92:	681b      	ldr	r3, [r3, #0]
 800fd94:	791b      	ldrb	r3, [r3, #4]
 800fd96:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 800fd9a:	b2db      	uxtb	r3, r3
 800fd9c:	461a      	mov	r2, r3
 800fd9e:	f107 0308 	add.w	r3, r7, #8
 800fda2:	4610      	mov	r0, r2
 800fda4:	4619      	mov	r1, r3
 800fda6:	220a      	movs	r2, #10
 800fda8:	f7ff ff90 	bl	800fccc <inttostring>
	strcat(str1,"tx");
 800fdac:	f107 0308 	add.w	r3, r7, #8
 800fdb0:	4618      	mov	r0, r3
 800fdb2:	f013 f8f5 	bl	8022fa0 <strlen>
 800fdb6:	4603      	mov	r3, r0
 800fdb8:	461a      	mov	r2, r3
 800fdba:	f107 0308 	add.w	r3, r7, #8
 800fdbe:	4413      	add	r3, r2
 800fdc0:	4a31      	ldr	r2, [pc, #196]	; (800fe88 <J1939_CA_register+0x118>)
 800fdc2:	8811      	ldrh	r1, [r2, #0]
 800fdc4:	7892      	ldrb	r2, [r2, #2]
 800fdc6:	8019      	strh	r1, [r3, #0]
 800fdc8:	709a      	strb	r2, [r3, #2]
	queue_def.name = str1;
 800fdca:	f107 0308 	add.w	r3, r7, #8
 800fdce:	613b      	str	r3, [r7, #16]
	rt_kprintf("%s\r\n",queue_def.name );
 800fdd0:	693b      	ldr	r3, [r7, #16]
 800fdd2:	482e      	ldr	r0, [pc, #184]	; (800fe8c <J1939_CA_register+0x11c>)
 800fdd4:	4619      	mov	r1, r3
 800fdd6:	f007 f99b 	bl	8017110 <rt_kprintf>
	queue_def.msg_size = sizeof(struct q_Message);
 800fdda:	2306      	movs	r3, #6
 800fddc:	61bb      	str	r3, [r7, #24]
	queue_def.max_msgs = Q_MAX_MSG;
 800fdde:	230a      	movs	r3, #10
 800fde0:	617b      	str	r3, [r7, #20]
	queue_def.flag = IPC_FLAG_FIFO;
 800fde2:	2300      	movs	r3, #0
 800fde4:	773b      	strb	r3, [r7, #28]
	ca_msg->txq = osMessageCreate(&queue_def,NULL);
 800fde6:	f107 0310 	add.w	r3, r7, #16
 800fdea:	4618      	mov	r0, r3
 800fdec:	2100      	movs	r1, #0
 800fdee:	f009 fb1f 	bl	8019430 <osMessageCreate>
 800fdf2:	4602      	mov	r2, r0
 800fdf4:	687b      	ldr	r3, [r7, #4]
 800fdf6:	65da      	str	r2, [r3, #92]	; 0x5c
	
	inttostring(ca_msg->CAname->FunInstance,str1,10);
 800fdf8:	687b      	ldr	r3, [r7, #4]
 800fdfa:	681b      	ldr	r3, [r3, #0]
 800fdfc:	791b      	ldrb	r3, [r3, #4]
 800fdfe:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 800fe02:	b2db      	uxtb	r3, r3
 800fe04:	461a      	mov	r2, r3
 800fe06:	f107 0308 	add.w	r3, r7, #8
 800fe0a:	4610      	mov	r0, r2
 800fe0c:	4619      	mov	r1, r3
 800fe0e:	220a      	movs	r2, #10
 800fe10:	f7ff ff5c 	bl	800fccc <inttostring>
	strcat(str1,"rx");
 800fe14:	f107 0308 	add.w	r3, r7, #8
 800fe18:	4618      	mov	r0, r3
 800fe1a:	f013 f8c1 	bl	8022fa0 <strlen>
 800fe1e:	4603      	mov	r3, r0
 800fe20:	461a      	mov	r2, r3
 800fe22:	f107 0308 	add.w	r3, r7, #8
 800fe26:	4413      	add	r3, r2
 800fe28:	4a19      	ldr	r2, [pc, #100]	; (800fe90 <J1939_CA_register+0x120>)
 800fe2a:	8811      	ldrh	r1, [r2, #0]
 800fe2c:	7892      	ldrb	r2, [r2, #2]
 800fe2e:	8019      	strh	r1, [r3, #0]
 800fe30:	709a      	strb	r2, [r3, #2]
	queue_def.name = str1;
 800fe32:	f107 0308 	add.w	r3, r7, #8
 800fe36:	613b      	str	r3, [r7, #16]
	queue_def.msg_size = sizeof(struct rx_Message);
 800fe38:	230c      	movs	r3, #12
 800fe3a:	61bb      	str	r3, [r7, #24]
	queue_def.max_msgs = Q_MAX_MSG;
 800fe3c:	230a      	movs	r3, #10
 800fe3e:	617b      	str	r3, [r7, #20]
	queue_def.flag = IPC_FLAG_FIFO;
 800fe40:	2300      	movs	r3, #0
 800fe42:	773b      	strb	r3, [r7, #28]
	ca_msg->rxq = osMessageCreate(&queue_def,NULL);
 800fe44:	f107 0310 	add.w	r3, r7, #16
 800fe48:	4618      	mov	r0, r3
 800fe4a:	2100      	movs	r1, #0
 800fe4c:	f009 faf0 	bl	8019430 <osMessageCreate>
 800fe50:	4602      	mov	r2, r0
 800fe52:	687b      	ldr	r3, [r7, #4]
 800fe54:	661a      	str	r2, [r3, #96]	; 0x60

	canode = (struct CA_node * )malloc(sizeof(struct CA_node));
 800fe56:	200c      	movs	r0, #12
 800fe58:	f012 fc00 	bl	802265c <malloc>
 800fe5c:	4603      	mov	r3, r0
 800fe5e:	623b      	str	r3, [r7, #32]
	canode->ca_msg = ca_msg;
 800fe60:	6a3b      	ldr	r3, [r7, #32]
 800fe62:	687a      	ldr	r2, [r7, #4]
 800fe64:	601a      	str	r2, [r3, #0]
	j1939_list_insert_before(&(calist.head),&(canode->node));
 800fe66:	6a3b      	ldr	r3, [r7, #32]
 800fe68:	3304      	adds	r3, #4
 800fe6a:	480a      	ldr	r0, [pc, #40]	; (800fe94 <J1939_CA_register+0x124>)
 800fe6c:	4619      	mov	r1, r3
 800fe6e:	f7ff feef 	bl	800fc50 <j1939_list_insert_before>

	initAddr(ca_msg);
 800fe72:	6878      	ldr	r0, [r7, #4]
 800fe74:	f001 fc06 	bl	8011684 <initAddr>
	return result;
 800fe78:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
 800fe7c:	4618      	mov	r0, r3
 800fe7e:	3728      	adds	r7, #40	; 0x28
 800fe80:	46bd      	mov	sp, r7
 800fe82:	bd80      	pop	{r7, pc}
 800fe84:	200127a0 	.word	0x200127a0
 800fe88:	080286fc 	.word	0x080286fc
 800fe8c:	08028700 	.word	0x08028700
 800fe90:	08028708 	.word	0x08028708
 800fe94:	200127a4 	.word	0x200127a4

0800fe98 <sendData>:

unsigned char sendData(CA_Msg_t CA_msg, unsigned char *data)
{
 800fe98:	b580      	push	{r7, lr}
 800fe9a:	b08e      	sub	sp, #56	; 0x38
 800fe9c:	af00      	add	r7, sp, #0
 800fe9e:	6078      	str	r0, [r7, #4]
 800fea0:	6039      	str	r1, [r7, #0]
	unsigned char result = RC_SUCCESS;
 800fea2:	2300      	movs	r3, #0
 800fea4:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
	osEvent event;
	struct J1939_msg j1939_msg;
	unsigned short i;
	q_Message_t qmsg;

	j1939_msg.DataPage = 0;
 800fea8:	7b3b      	ldrb	r3, [r7, #12]
 800feaa:	f36f 03c3 	bfc	r3, #3, #1
 800feae:	733b      	strb	r3, [r7, #12]
	j1939_msg.edp = 0;
 800feb0:	7b3b      	ldrb	r3, [r7, #12]
 800feb2:	f36f 1304 	bfc	r3, #4, #1
 800feb6:	733b      	strb	r3, [r7, #12]
	j1939_msg.PDUFormat = J1939_PF_DT;
 800feb8:	23eb      	movs	r3, #235	; 0xeb
 800feba:	737b      	strb	r3, [r7, #13]
		j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
	else
		j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
	#endif
	
	j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
 800febc:	687b      	ldr	r3, [r7, #4]
 800febe:	799b      	ldrb	r3, [r3, #6]
 800fec0:	73bb      	strb	r3, [r7, #14]
	j1939_msg.DataLength = 8;
 800fec2:	7c3b      	ldrb	r3, [r7, #16]
 800fec4:	2208      	movs	r2, #8
 800fec6:	f362 0303 	bfi	r3, r2, #0, #4
 800feca:	743b      	strb	r3, [r7, #16]
	j1939_msg.Priority = 7;
 800fecc:	7b3b      	ldrb	r3, [r7, #12]
 800fece:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 800fed2:	733b      	strb	r3, [r7, #12]
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
 800fed4:	687b      	ldr	r3, [r7, #4]
 800fed6:	79db      	ldrb	r3, [r3, #7]
 800fed8:	73fb      	strb	r3, [r7, #15]
sendmsg:
	for(i = CA_msg->cm.nextnum; i < (CA_msg->cm.sendnum + CA_msg->cm.nextnum);i++)
 800feda:	687b      	ldr	r3, [r7, #4]
 800fedc:	8b1b      	ldrh	r3, [r3, #24]
 800fede:	86fb      	strh	r3, [r7, #54]	; 0x36
 800fee0:	e040      	b.n	800ff64 <sendData+0xcc>
	{
		unsigned short j;
		j1939_msg.Data[0] = i;
 800fee2:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 800fee4:	b2db      	uxtb	r3, r3
 800fee6:	747b      	strb	r3, [r7, #17]
		for(j = 1; j<8;j++)
 800fee8:	2301      	movs	r3, #1
 800feea:	86bb      	strh	r3, [r7, #52]	; 0x34
 800feec:	e026      	b.n	800ff3c <sendData+0xa4>
		{
			unsigned short k;
			k = (i-1)*7+j-1;
 800feee:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 800fef0:	3b01      	subs	r3, #1
 800fef2:	b29b      	uxth	r3, r3
 800fef4:	461a      	mov	r2, r3
 800fef6:	00d2      	lsls	r2, r2, #3
 800fef8:	1ad3      	subs	r3, r2, r3
 800fefa:	b29a      	uxth	r2, r3
 800fefc:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 800fefe:	4413      	add	r3, r2
 800ff00:	b29b      	uxth	r3, r3
 800ff02:	3b01      	subs	r3, #1
 800ff04:	857b      	strh	r3, [r7, #42]	; 0x2a
			if(k < (CA_msg->sendbytes+3))
 800ff06:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
 800ff08:	687b      	ldr	r3, [r7, #4]
 800ff0a:	8a9b      	ldrh	r3, [r3, #20]
 800ff0c:	3303      	adds	r3, #3
 800ff0e:	429a      	cmp	r2, r3
 800ff10:	da0a      	bge.n	800ff28 <sendData+0x90>
				j1939_msg.Data[j] = data[k];
 800ff12:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 800ff14:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
 800ff16:	6839      	ldr	r1, [r7, #0]
 800ff18:	440a      	add	r2, r1
 800ff1a:	7812      	ldrb	r2, [r2, #0]
 800ff1c:	f107 0138 	add.w	r1, r7, #56	; 0x38
 800ff20:	440b      	add	r3, r1
 800ff22:	f803 2c27 	strb.w	r2, [r3, #-39]
 800ff26:	e006      	b.n	800ff36 <sendData+0x9e>
			else
				j1939_msg.Data[j] = 0xff;
 800ff28:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 800ff2a:	f107 0238 	add.w	r2, r7, #56	; 0x38
 800ff2e:	4413      	add	r3, r2
 800ff30:	22ff      	movs	r2, #255	; 0xff
 800ff32:	f803 2c27 	strb.w	r2, [r3, #-39]
sendmsg:
	for(i = CA_msg->cm.nextnum; i < (CA_msg->cm.sendnum + CA_msg->cm.nextnum);i++)
	{
		unsigned short j;
		j1939_msg.Data[0] = i;
		for(j = 1; j<8;j++)
 800ff36:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 800ff38:	3301      	adds	r3, #1
 800ff3a:	86bb      	strh	r3, [r7, #52]	; 0x34
 800ff3c:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 800ff3e:	2b07      	cmp	r3, #7
 800ff40:	d9d5      	bls.n	800feee <sendData+0x56>
				j1939_msg.Data[j] = data[k];
			else
				j1939_msg.Data[j] = 0xff;
		}
		
		if(writeCan(&j1939_msg)!= RC_SUCCESS)
 800ff42:	f107 030c 	add.w	r3, r7, #12
 800ff46:	4618      	mov	r0, r3
 800ff48:	f001 fbae 	bl	80116a8 <writeCan>
 800ff4c:	4603      	mov	r3, r0
 800ff4e:	2b00      	cmp	r3, #0
 800ff50:	d005      	beq.n	800ff5e <sendData+0xc6>
		{
			return result = RC_CANNOTTRANSMIT;
 800ff52:	230a      	movs	r3, #10
 800ff54:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800ff58:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800ff5c:	e049      	b.n	800fff2 <sendData+0x15a>
	j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
	j1939_msg.DataLength = 8;
	j1939_msg.Priority = 7;
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
sendmsg:
	for(i = CA_msg->cm.nextnum; i < (CA_msg->cm.sendnum + CA_msg->cm.nextnum);i++)
 800ff5e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 800ff60:	3301      	adds	r3, #1
 800ff62:	86fb      	strh	r3, [r7, #54]	; 0x36
 800ff64:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 800ff66:	687b      	ldr	r3, [r7, #4]
 800ff68:	8b5b      	ldrh	r3, [r3, #26]
 800ff6a:	4619      	mov	r1, r3
 800ff6c:	687b      	ldr	r3, [r7, #4]
 800ff6e:	8b1b      	ldrh	r3, [r3, #24]
 800ff70:	440b      	add	r3, r1
 800ff72:	429a      	cmp	r2, r3
 800ff74:	dbb5      	blt.n	800fee2 <sendData+0x4a>
		if(writeCan(&j1939_msg)!= RC_SUCCESS)
		{
			return result = RC_CANNOTTRANSMIT;
		}
	}
	if(i > CA_msg->cm.sendpackets)
 800ff76:	687b      	ldr	r3, [r7, #4]
 800ff78:	8adb      	ldrh	r3, [r3, #22]
 800ff7a:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 800ff7c:	429a      	cmp	r2, r3
 800ff7e:	d904      	bls.n	800ff8a <sendData+0xf2>
	{
		CA_msg->cm.sendcomp = 1;
 800ff80:	687b      	ldr	r3, [r7, #4]
 800ff82:	2201      	movs	r2, #1
 800ff84:	775a      	strb	r2, [r3, #29]
		//rt_kprintf("sendData success\r\n");
		return RC_SUCCESS;
 800ff86:	2300      	movs	r3, #0
 800ff88:	e033      	b.n	800fff2 <sendData+0x15a>
	}
	CA_msg->cm.t3.value = T3TIMEOUT;
 800ff8a:	687b      	ldr	r3, [r7, #4]
 800ff8c:	f240 42e2 	movw	r2, #1250	; 0x4e2
 800ff90:	85da      	strh	r2, [r3, #46]	; 0x2e
	CA_msg->cm.t3.en = 1;
 800ff92:	687b      	ldr	r3, [r7, #4]
 800ff94:	2201      	movs	r2, #1
 800ff96:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
	CA_msg->cm.t3.release = 0;
 800ff9a:	687b      	ldr	r3, [r7, #4]
 800ff9c:	2200      	movs	r2, #0
 800ff9e:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
	event = osMessageGet(CA_msg->txq,WAITFOREVER);
 800ffa2:	687b      	ldr	r3, [r7, #4]
 800ffa4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800ffa6:	f107 021c 	add.w	r2, r7, #28
 800ffaa:	4610      	mov	r0, r2
 800ffac:	4619      	mov	r1, r3
 800ffae:	f04f 32ff 	mov.w	r2, #4294967295
 800ffb2:	f009 fa69 	bl	8019488 <osMessageGet>
	qmsg = event.value.p;
 800ffb6:	6a3b      	ldr	r3, [r7, #32]
 800ffb8:	62fb      	str	r3, [r7, #44]	; 0x2c
	if(qmsg->timeout == 0)
 800ffba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ffbc:	889b      	ldrh	r3, [r3, #4]
 800ffbe:	2b00      	cmp	r3, #0
 800ffc0:	d112      	bne.n	800ffe8 <sendData+0x150>
	{
	
		CA_msg->cm.nextnum = qmsg->nextnum;
 800ffc2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ffc4:	881a      	ldrh	r2, [r3, #0]
 800ffc6:	687b      	ldr	r3, [r7, #4]
 800ffc8:	831a      	strh	r2, [r3, #24]
		CA_msg->cm.sendnum = qmsg->sendnum;
 800ffca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ffcc:	885a      	ldrh	r2, [r3, #2]
 800ffce:	687b      	ldr	r3, [r7, #4]
 800ffd0:	835a      	strh	r2, [r3, #26]
		if(CA_msg->cm.nextnum != 0)
 800ffd2:	687b      	ldr	r3, [r7, #4]
 800ffd4:	8b1b      	ldrh	r3, [r3, #24]
 800ffd6:	2b00      	cmp	r3, #0
 800ffd8:	d000      	beq.n	800ffdc <sendData+0x144>
			goto sendmsg;
 800ffda:	e77e      	b.n	800feda <sendData+0x42>
		else
			return result = RC_SUCCESS;
 800ffdc:	2300      	movs	r3, #0
 800ffde:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800ffe2:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800ffe6:	e004      	b.n	800fff2 <sendData+0x15a>
	}
	else
		return result = RC_TIMEOUT;
 800ffe8:	230b      	movs	r3, #11
 800ffea:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800ffee:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
	
}
 800fff2:	4618      	mov	r0, r3
 800fff4:	3738      	adds	r7, #56	; 0x38
 800fff6:	46bd      	mov	sp, r7
 800fff8:	bd80      	pop	{r7, pc}
 800fffa:	bf00      	nop

0800fffc <sendBAM>:


unsigned char sendBAM(CA_Msg_t CA_msg, unsigned char *data)
{
 800fffc:	b580      	push	{r7, lr}
 800fffe:	b088      	sub	sp, #32
 8010000:	af00      	add	r7, sp, #0
 8010002:	6078      	str	r0, [r7, #4]
 8010004:	6039      	str	r1, [r7, #0]
	
	unsigned char result = RC_SUCCESS;
 8010006:	2300      	movs	r3, #0
 8010008:	76fb      	strb	r3, [r7, #27]
	struct J1939_msg j1939_msg;
	unsigned char i;

	j1939_msg.Data[0] = J1939_BAM_CONTROL_BYTE;
 801000a:	2320      	movs	r3, #32
 801000c:	737b      	strb	r3, [r7, #13]
	j1939_msg.Data[1] = (CA_msg->sendbytes+3+CA_msg->cm.sendpackets)%256;
 801000e:	687b      	ldr	r3, [r7, #4]
 8010010:	8a9b      	ldrh	r3, [r3, #20]
 8010012:	3303      	adds	r3, #3
 8010014:	687a      	ldr	r2, [r7, #4]
 8010016:	8ad2      	ldrh	r2, [r2, #22]
 8010018:	441a      	add	r2, r3
 801001a:	4b5b      	ldr	r3, [pc, #364]	; (8010188 <sendBAM+0x18c>)
 801001c:	4013      	ands	r3, r2
 801001e:	2b00      	cmp	r3, #0
 8010020:	da03      	bge.n	801002a <sendBAM+0x2e>
 8010022:	3b01      	subs	r3, #1
 8010024:	f063 03ff 	orn	r3, r3, #255	; 0xff
 8010028:	3301      	adds	r3, #1
 801002a:	b2db      	uxtb	r3, r3
 801002c:	73bb      	strb	r3, [r7, #14]
	j1939_msg.Data[2] = (CA_msg->sendbytes+3+CA_msg->cm.sendpackets)/256;
 801002e:	687b      	ldr	r3, [r7, #4]
 8010030:	8a9b      	ldrh	r3, [r3, #20]
 8010032:	3303      	adds	r3, #3
 8010034:	687a      	ldr	r2, [r7, #4]
 8010036:	8ad2      	ldrh	r2, [r2, #22]
 8010038:	4413      	add	r3, r2
 801003a:	2b00      	cmp	r3, #0
 801003c:	da00      	bge.n	8010040 <sendBAM+0x44>
 801003e:	33ff      	adds	r3, #255	; 0xff
 8010040:	121b      	asrs	r3, r3, #8
 8010042:	b2db      	uxtb	r3, r3
 8010044:	73fb      	strb	r3, [r7, #15]
	j1939_msg.Data[3] = CA_msg->cm.sendpackets;
 8010046:	687b      	ldr	r3, [r7, #4]
 8010048:	8adb      	ldrh	r3, [r3, #22]
 801004a:	b2db      	uxtb	r3, r3
 801004c:	743b      	strb	r3, [r7, #16]
	j1939_msg.Data[4] = 0xff;     /*don't support maxium number of packets*/
 801004e:	23ff      	movs	r3, #255	; 0xff
 8010050:	747b      	strb	r3, [r7, #17]
	j1939_msg.Data[5] = CA_msg->msg.PDUSpecific;
 8010052:	687b      	ldr	r3, [r7, #4]
 8010054:	799b      	ldrb	r3, [r3, #6]
 8010056:	74bb      	strb	r3, [r7, #18]
	j1939_msg.Data[6] = CA_msg->msg.PDUFormat;
 8010058:	687b      	ldr	r3, [r7, #4]
 801005a:	795b      	ldrb	r3, [r3, #5]
 801005c:	74fb      	strb	r3, [r7, #19]
	j1939_msg.Data[7] = CA_msg->msg.DataPage;
 801005e:	687b      	ldr	r3, [r7, #4]
 8010060:	791b      	ldrb	r3, [r3, #4]
 8010062:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8010066:	b2db      	uxtb	r3, r3
 8010068:	753b      	strb	r3, [r7, #20]
	j1939_msg.DataLength = 8;
 801006a:	7b3b      	ldrb	r3, [r7, #12]
 801006c:	2208      	movs	r2, #8
 801006e:	f362 0303 	bfi	r3, r2, #0, #4
 8010072:	733b      	strb	r3, [r7, #12]
	j1939_msg.DataPage = 0;
 8010074:	7a3b      	ldrb	r3, [r7, #8]
 8010076:	f36f 03c3 	bfc	r3, #3, #1
 801007a:	723b      	strb	r3, [r7, #8]
	j1939_msg.edp = 0;
 801007c:	7a3b      	ldrb	r3, [r7, #8]
 801007e:	f36f 1304 	bfc	r3, #4, #1
 8010082:	723b      	strb	r3, [r7, #8]
	j1939_msg.PDUFormat = J1939_PF_TP_CM;
 8010084:	23ec      	movs	r3, #236	; 0xec
 8010086:	727b      	strb	r3, [r7, #9]
	j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
 8010088:	23ff      	movs	r3, #255	; 0xff
 801008a:	72bb      	strb	r3, [r7, #10]
	j1939_msg.Priority = 7;
 801008c:	7a3b      	ldrb	r3, [r7, #8]
 801008e:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 8010092:	723b      	strb	r3, [r7, #8]
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
 8010094:	687b      	ldr	r3, [r7, #4]
 8010096:	79db      	ldrb	r3, [r3, #7]
 8010098:	72fb      	strb	r3, [r7, #11]
	if(writeCan(&j1939_msg)!= RC_SUCCESS)
 801009a:	f107 0308 	add.w	r3, r7, #8
 801009e:	4618      	mov	r0, r3
 80100a0:	f001 fb02 	bl	80116a8 <writeCan>
 80100a4:	4603      	mov	r3, r0
 80100a6:	2b00      	cmp	r3, #0
 80100a8:	d001      	beq.n	80100ae <sendBAM+0xb2>
		return RC_ERROR;
 80100aa:	2301      	movs	r3, #1
 80100ac:	e067      	b.n	801017e <sendBAM+0x182>
	
	j1939_msg.DataPage = 0;
 80100ae:	7a3b      	ldrb	r3, [r7, #8]
 80100b0:	f36f 03c3 	bfc	r3, #3, #1
 80100b4:	723b      	strb	r3, [r7, #8]
	j1939_msg.edp = 0;
 80100b6:	7a3b      	ldrb	r3, [r7, #8]
 80100b8:	f36f 1304 	bfc	r3, #4, #1
 80100bc:	723b      	strb	r3, [r7, #8]
	j1939_msg.PDUFormat = J1939_PF_DT;
 80100be:	23eb      	movs	r3, #235	; 0xeb
 80100c0:	727b      	strb	r3, [r7, #9]
		j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
	else
		j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
	#endif
	
	j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
 80100c2:	23ff      	movs	r3, #255	; 0xff
 80100c4:	72bb      	strb	r3, [r7, #10]
	j1939_msg.DataLength = 8;
 80100c6:	7b3b      	ldrb	r3, [r7, #12]
 80100c8:	2208      	movs	r2, #8
 80100ca:	f362 0303 	bfi	r3, r2, #0, #4
 80100ce:	733b      	strb	r3, [r7, #12]
	j1939_msg.Priority = 7;
 80100d0:	7a3b      	ldrb	r3, [r7, #8]
 80100d2:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 80100d6:	723b      	strb	r3, [r7, #8]
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
 80100d8:	687b      	ldr	r3, [r7, #4]
 80100da:	79db      	ldrb	r3, [r3, #7]
 80100dc:	72fb      	strb	r3, [r7, #11]
	
	for(i = 1; (i <= CA_msg->cm.sendpackets) && (i != 0);i++)
 80100de:	2301      	movs	r3, #1
 80100e0:	77fb      	strb	r3, [r7, #31]
 80100e2:	e040      	b.n	8010166 <sendBAM+0x16a>
	{
		unsigned short j;
		j1939_msg.Data[0] = i;
 80100e4:	7ffb      	ldrb	r3, [r7, #31]
 80100e6:	737b      	strb	r3, [r7, #13]
		for(j = 1; j<8;j++)
 80100e8:	2301      	movs	r3, #1
 80100ea:	83bb      	strh	r3, [r7, #28]
 80100ec:	e026      	b.n	801013c <sendBAM+0x140>
		{
			unsigned short k;
			k = (i-1)*7+j-1;
 80100ee:	7ffb      	ldrb	r3, [r7, #31]
 80100f0:	3b01      	subs	r3, #1
 80100f2:	b29b      	uxth	r3, r3
 80100f4:	461a      	mov	r2, r3
 80100f6:	00d2      	lsls	r2, r2, #3
 80100f8:	1ad3      	subs	r3, r2, r3
 80100fa:	b29a      	uxth	r2, r3
 80100fc:	8bbb      	ldrh	r3, [r7, #28]
 80100fe:	4413      	add	r3, r2
 8010100:	b29b      	uxth	r3, r3
 8010102:	3b01      	subs	r3, #1
 8010104:	833b      	strh	r3, [r7, #24]
			if(k < (CA_msg->sendbytes+3))
 8010106:	8b3a      	ldrh	r2, [r7, #24]
 8010108:	687b      	ldr	r3, [r7, #4]
 801010a:	8a9b      	ldrh	r3, [r3, #20]
 801010c:	3303      	adds	r3, #3
 801010e:	429a      	cmp	r2, r3
 8010110:	da0a      	bge.n	8010128 <sendBAM+0x12c>
				j1939_msg.Data[j] = data[k];
 8010112:	8bbb      	ldrh	r3, [r7, #28]
 8010114:	8b3a      	ldrh	r2, [r7, #24]
 8010116:	6839      	ldr	r1, [r7, #0]
 8010118:	440a      	add	r2, r1
 801011a:	7812      	ldrb	r2, [r2, #0]
 801011c:	f107 0120 	add.w	r1, r7, #32
 8010120:	440b      	add	r3, r1
 8010122:	f803 2c13 	strb.w	r2, [r3, #-19]
 8010126:	e006      	b.n	8010136 <sendBAM+0x13a>
			else
				j1939_msg.Data[j] = 0xff;
 8010128:	8bbb      	ldrh	r3, [r7, #28]
 801012a:	f107 0220 	add.w	r2, r7, #32
 801012e:	4413      	add	r3, r2
 8010130:	22ff      	movs	r2, #255	; 0xff
 8010132:	f803 2c13 	strb.w	r2, [r3, #-19]
	
	for(i = 1; (i <= CA_msg->cm.sendpackets) && (i != 0);i++)
	{
		unsigned short j;
		j1939_msg.Data[0] = i;
		for(j = 1; j<8;j++)
 8010136:	8bbb      	ldrh	r3, [r7, #28]
 8010138:	3301      	adds	r3, #1
 801013a:	83bb      	strh	r3, [r7, #28]
 801013c:	8bbb      	ldrh	r3, [r7, #28]
 801013e:	2b07      	cmp	r3, #7
 8010140:	d9d5      	bls.n	80100ee <sendBAM+0xf2>
			if(k < (CA_msg->sendbytes+3))
				j1939_msg.Data[j] = data[k];
			else
				j1939_msg.Data[j] = 0xff;
		}
		osDelay(BAMDTTIME);
 8010142:	2037      	movs	r0, #55	; 0x37
 8010144:	f009 f91a 	bl	801937c <osDelay>
		if(writeCan(&j1939_msg)!= RC_SUCCESS)
 8010148:	f107 0308 	add.w	r3, r7, #8
 801014c:	4618      	mov	r0, r3
 801014e:	f001 faab 	bl	80116a8 <writeCan>
 8010152:	4603      	mov	r3, r0
 8010154:	2b00      	cmp	r3, #0
 8010156:	d003      	beq.n	8010160 <sendBAM+0x164>
		{


			return result = RC_CANNOTTRANSMIT;
 8010158:	230a      	movs	r3, #10
 801015a:	76fb      	strb	r3, [r7, #27]
 801015c:	7efb      	ldrb	r3, [r7, #27]
 801015e:	e00e      	b.n	801017e <sendBAM+0x182>
	j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
	j1939_msg.DataLength = 8;
	j1939_msg.Priority = 7;
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
	
	for(i = 1; (i <= CA_msg->cm.sendpackets) && (i != 0);i++)
 8010160:	7ffb      	ldrb	r3, [r7, #31]
 8010162:	3301      	adds	r3, #1
 8010164:	77fb      	strb	r3, [r7, #31]
 8010166:	7ffb      	ldrb	r3, [r7, #31]
 8010168:	b29a      	uxth	r2, r3
 801016a:	687b      	ldr	r3, [r7, #4]
 801016c:	8adb      	ldrh	r3, [r3, #22]
 801016e:	429a      	cmp	r2, r3
 8010170:	d802      	bhi.n	8010178 <sendBAM+0x17c>
 8010172:	7ffb      	ldrb	r3, [r7, #31]
 8010174:	2b00      	cmp	r3, #0
 8010176:	d1b5      	bne.n	80100e4 <sendBAM+0xe8>

			return result = RC_CANNOTTRANSMIT;
		}
	}
	
	return result = RC_SUCCESS;
 8010178:	2300      	movs	r3, #0
 801017a:	76fb      	strb	r3, [r7, #27]
 801017c:	7efb      	ldrb	r3, [r7, #27]
}
 801017e:	4618      	mov	r0, r3
 8010180:	3720      	adds	r7, #32
 8010182:	46bd      	mov	sp, r7
 8010184:	bd80      	pop	{r7, pc}
 8010186:	bf00      	nop
 8010188:	800000ff 	.word	0x800000ff

0801018c <sendRTS>:

unsigned char sendRTS(CA_Msg_t CA_msg)
{
 801018c:	b580      	push	{r7, lr}
 801018e:	b08c      	sub	sp, #48	; 0x30
 8010190:	af00      	add	r7, sp, #0
 8010192:	6078      	str	r0, [r7, #4]
	q_Message_t qmsg;
	unsigned char result = RC_SUCCESS;
 8010194:	2300      	movs	r3, #0
 8010196:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	osEvent event;
	struct J1939_msg j1939_msg;
	j1939_msg.Data[0] = J1939_RTS_CONTROL_BYTE;
 801019a:	2310      	movs	r3, #16
 801019c:	747b      	strb	r3, [r7, #17]
	j1939_msg.Data[1] = (CA_msg->sendbytes+3+CA_msg->cm.sendpackets)%256;
 801019e:	687b      	ldr	r3, [r7, #4]
 80101a0:	8a9b      	ldrh	r3, [r3, #20]
 80101a2:	3303      	adds	r3, #3
 80101a4:	687a      	ldr	r2, [r7, #4]
 80101a6:	8ad2      	ldrh	r2, [r2, #22]
 80101a8:	441a      	add	r2, r3
 80101aa:	4b42      	ldr	r3, [pc, #264]	; (80102b4 <sendRTS+0x128>)
 80101ac:	4013      	ands	r3, r2
 80101ae:	2b00      	cmp	r3, #0
 80101b0:	da03      	bge.n	80101ba <sendRTS+0x2e>
 80101b2:	3b01      	subs	r3, #1
 80101b4:	f063 03ff 	orn	r3, r3, #255	; 0xff
 80101b8:	3301      	adds	r3, #1
 80101ba:	b2db      	uxtb	r3, r3
 80101bc:	74bb      	strb	r3, [r7, #18]
	j1939_msg.Data[2] = (CA_msg->sendbytes+3+CA_msg->cm.sendpackets)/256;
 80101be:	687b      	ldr	r3, [r7, #4]
 80101c0:	8a9b      	ldrh	r3, [r3, #20]
 80101c2:	3303      	adds	r3, #3
 80101c4:	687a      	ldr	r2, [r7, #4]
 80101c6:	8ad2      	ldrh	r2, [r2, #22]
 80101c8:	4413      	add	r3, r2
 80101ca:	2b00      	cmp	r3, #0
 80101cc:	da00      	bge.n	80101d0 <sendRTS+0x44>
 80101ce:	33ff      	adds	r3, #255	; 0xff
 80101d0:	121b      	asrs	r3, r3, #8
 80101d2:	b2db      	uxtb	r3, r3
 80101d4:	74fb      	strb	r3, [r7, #19]
	j1939_msg.Data[3] = CA_msg->cm.sendpackets;
 80101d6:	687b      	ldr	r3, [r7, #4]
 80101d8:	8adb      	ldrh	r3, [r3, #22]
 80101da:	b2db      	uxtb	r3, r3
 80101dc:	753b      	strb	r3, [r7, #20]
	j1939_msg.Data[4] = 0xff;     /*don't support maxium number of packets*/
 80101de:	23ff      	movs	r3, #255	; 0xff
 80101e0:	757b      	strb	r3, [r7, #21]
	j1939_msg.Data[5] = CA_msg->msg.PDUSpecific;
 80101e2:	687b      	ldr	r3, [r7, #4]
 80101e4:	799b      	ldrb	r3, [r3, #6]
 80101e6:	75bb      	strb	r3, [r7, #22]
	j1939_msg.Data[6] = CA_msg->msg.PDUFormat;
 80101e8:	687b      	ldr	r3, [r7, #4]
 80101ea:	795b      	ldrb	r3, [r3, #5]
 80101ec:	75fb      	strb	r3, [r7, #23]
	j1939_msg.Data[7] = CA_msg->msg.DataPage;
 80101ee:	687b      	ldr	r3, [r7, #4]
 80101f0:	791b      	ldrb	r3, [r3, #4]
 80101f2:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 80101f6:	b2db      	uxtb	r3, r3
 80101f8:	763b      	strb	r3, [r7, #24]
	j1939_msg.DataLength = 8;
 80101fa:	7c3b      	ldrb	r3, [r7, #16]
 80101fc:	2208      	movs	r2, #8
 80101fe:	f362 0303 	bfi	r3, r2, #0, #4
 8010202:	743b      	strb	r3, [r7, #16]
	j1939_msg.DataPage = 0;
 8010204:	7b3b      	ldrb	r3, [r7, #12]
 8010206:	f36f 03c3 	bfc	r3, #3, #1
 801020a:	733b      	strb	r3, [r7, #12]
	j1939_msg.edp = 0;
 801020c:	7b3b      	ldrb	r3, [r7, #12]
 801020e:	f36f 1304 	bfc	r3, #4, #1
 8010212:	733b      	strb	r3, [r7, #12]
	j1939_msg.PDUFormat = J1939_PF_TP_CM;
 8010214:	23ec      	movs	r3, #236	; 0xec
 8010216:	737b      	strb	r3, [r7, #13]
	j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
 8010218:	687b      	ldr	r3, [r7, #4]
 801021a:	799b      	ldrb	r3, [r3, #6]
 801021c:	73bb      	strb	r3, [r7, #14]
	j1939_msg.Priority = 7;
 801021e:	7b3b      	ldrb	r3, [r7, #12]
 8010220:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 8010224:	733b      	strb	r3, [r7, #12]
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
 8010226:	687b      	ldr	r3, [r7, #4]
 8010228:	79db      	ldrb	r3, [r3, #7]
 801022a:	73fb      	strb	r3, [r7, #15]
	if(writeCan(&j1939_msg)== RC_SUCCESS)
 801022c:	f107 030c 	add.w	r3, r7, #12
 8010230:	4618      	mov	r0, r3
 8010232:	f001 fa39 	bl	80116a8 <writeCan>
 8010236:	4603      	mov	r3, r0
 8010238:	2b00      	cmp	r3, #0
 801023a:	d132      	bne.n	80102a2 <sendRTS+0x116>
	{

		CA_msg->cm.t3.value = T3TIMEOUT;
 801023c:	687b      	ldr	r3, [r7, #4]
 801023e:	f240 42e2 	movw	r2, #1250	; 0x4e2
 8010242:	85da      	strh	r2, [r3, #46]	; 0x2e
		CA_msg->cm.t3.en = 1;
 8010244:	687b      	ldr	r3, [r7, #4]
 8010246:	2201      	movs	r2, #1
 8010248:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
		CA_msg->cm.t3.release = 0;
 801024c:	687b      	ldr	r3, [r7, #4]
 801024e:	2200      	movs	r2, #0
 8010250:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
		event = osMessageGet(CA_msg->txq,WAITFOREVER);
 8010254:	687b      	ldr	r3, [r7, #4]
 8010256:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8010258:	f107 021c 	add.w	r2, r7, #28
 801025c:	4610      	mov	r0, r2
 801025e:	4619      	mov	r1, r3
 8010260:	f04f 32ff 	mov.w	r2, #4294967295
 8010264:	f009 f910 	bl	8019488 <osMessageGet>
		qmsg = (q_Message_t)event.value.p;
 8010268:	6a3b      	ldr	r3, [r7, #32]
 801026a:	62bb      	str	r3, [r7, #40]	; 0x28
		if(qmsg->timeout == 0)
 801026c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801026e:	889b      	ldrh	r3, [r3, #4]
 8010270:	2b00      	cmp	r3, #0
 8010272:	d110      	bne.n	8010296 <sendRTS+0x10a>
		{
			CA_msg->cm.nextnum = qmsg->nextnum;
 8010274:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010276:	881a      	ldrh	r2, [r3, #0]
 8010278:	687b      	ldr	r3, [r7, #4]
 801027a:	831a      	strh	r2, [r3, #24]
			CA_msg->cm.sendnum = qmsg->sendnum;
 801027c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801027e:	885a      	ldrh	r2, [r3, #2]
 8010280:	687b      	ldr	r3, [r7, #4]
 8010282:	835a      	strh	r2, [r3, #26]
			CA_msg->cm.cm_lock = 1;
 8010284:	687b      	ldr	r3, [r7, #4]
 8010286:	2201      	movs	r2, #1
 8010288:	771a      	strb	r2, [r3, #28]
			return result = RC_SUCCESS;
 801028a:	2300      	movs	r3, #0
 801028c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8010290:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8010294:	e00a      	b.n	80102ac <sendRTS+0x120>
		}
		else
		{
			return result = RC_TIMEOUT;
 8010296:	230b      	movs	r3, #11
 8010298:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 801029c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 80102a0:	e004      	b.n	80102ac <sendRTS+0x120>
		}
	}
	else
		return result = RC_CANNOTTRANSMIT;
 80102a2:	230a      	movs	r3, #10
 80102a4:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 80102a8:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
}
 80102ac:	4618      	mov	r0, r3
 80102ae:	3730      	adds	r7, #48	; 0x30
 80102b0:	46bd      	mov	sp, r7
 80102b2:	bd80      	pop	{r7, pc}
 80102b4:	800000ff 	.word	0x800000ff

080102b8 <sendAbort>:

unsigned char sendAbort(CA_Msg_t CA_msg,unsigned char reason)
{
 80102b8:	b580      	push	{r7, lr}
 80102ba:	b088      	sub	sp, #32
 80102bc:	af00      	add	r7, sp, #0
 80102be:	6078      	str	r0, [r7, #4]
 80102c0:	460b      	mov	r3, r1
 80102c2:	70fb      	strb	r3, [r7, #3]
	unsigned char result = RC_SUCCESS;
 80102c4:	2300      	movs	r3, #0
 80102c6:	77fb      	strb	r3, [r7, #31]
	struct J1939_msg j1939_msg;
	struct J1939_CM *tempCm;

	
	j1939_msg.Data[0] = J1939_CONNABORT_CONTROL_BYTE;
 80102c8:	23ff      	movs	r3, #255	; 0xff
 80102ca:	737b      	strb	r3, [r7, #13]
	j1939_msg.Data[1] = reason;
 80102cc:	78fb      	ldrb	r3, [r7, #3]
 80102ce:	73bb      	strb	r3, [r7, #14]
	j1939_msg.Data[2] = 0xff;
 80102d0:	23ff      	movs	r3, #255	; 0xff
 80102d2:	73fb      	strb	r3, [r7, #15]
	j1939_msg.Data[3] = 0xff;
 80102d4:	23ff      	movs	r3, #255	; 0xff
 80102d6:	743b      	strb	r3, [r7, #16]
	j1939_msg.Data[4] = 0xff;     /*don't support maxium number of packets*/
 80102d8:	23ff      	movs	r3, #255	; 0xff
 80102da:	747b      	strb	r3, [r7, #17]
	j1939_msg.Data[5] = CA_msg->msg.PDUSpecific;
 80102dc:	687b      	ldr	r3, [r7, #4]
 80102de:	799b      	ldrb	r3, [r3, #6]
 80102e0:	74bb      	strb	r3, [r7, #18]
	j1939_msg.Data[6] = CA_msg->msg.PDUFormat;
 80102e2:	687b      	ldr	r3, [r7, #4]
 80102e4:	795b      	ldrb	r3, [r3, #5]
 80102e6:	74fb      	strb	r3, [r7, #19]
	j1939_msg.Data[7] = CA_msg->msg.DataPage;
 80102e8:	687b      	ldr	r3, [r7, #4]
 80102ea:	791b      	ldrb	r3, [r3, #4]
 80102ec:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 80102f0:	b2db      	uxtb	r3, r3
 80102f2:	753b      	strb	r3, [r7, #20]
	j1939_msg.DataLength = 8;
 80102f4:	7b3b      	ldrb	r3, [r7, #12]
 80102f6:	2208      	movs	r2, #8
 80102f8:	f362 0303 	bfi	r3, r2, #0, #4
 80102fc:	733b      	strb	r3, [r7, #12]
	j1939_msg.DataPage = 0;
 80102fe:	7a3b      	ldrb	r3, [r7, #8]
 8010300:	f36f 03c3 	bfc	r3, #3, #1
 8010304:	723b      	strb	r3, [r7, #8]
	j1939_msg.edp = 0;
 8010306:	7a3b      	ldrb	r3, [r7, #8]
 8010308:	f36f 1304 	bfc	r3, #4, #1
 801030c:	723b      	strb	r3, [r7, #8]
	j1939_msg.PDUFormat = J1939_PF_TP_CM;
 801030e:	23ec      	movs	r3, #236	; 0xec
 8010310:	727b      	strb	r3, [r7, #9]
	j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
 8010312:	687b      	ldr	r3, [r7, #4]
 8010314:	799b      	ldrb	r3, [r3, #6]
 8010316:	72bb      	strb	r3, [r7, #10]
	j1939_msg.Priority = 7;
 8010318:	7a3b      	ldrb	r3, [r7, #8]
 801031a:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 801031e:	723b      	strb	r3, [r7, #8]
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;
 8010320:	687b      	ldr	r3, [r7, #4]
 8010322:	79db      	ldrb	r3, [r3, #7]
 8010324:	72fb      	strb	r3, [r7, #11]
	CA_msg->cm.cm_lock = 0;
 8010326:	687b      	ldr	r3, [r7, #4]
 8010328:	2200      	movs	r2, #0
 801032a:	771a      	strb	r2, [r3, #28]
	
	if(writeCan(&j1939_msg)!= RC_SUCCESS)
 801032c:	f107 0308 	add.w	r3, r7, #8
 8010330:	4618      	mov	r0, r3
 8010332:	f001 f9b9 	bl	80116a8 <writeCan>
 8010336:	4603      	mov	r3, r0
 8010338:	2b00      	cmp	r3, #0
 801033a:	d017      	beq.n	801036c <sendAbort+0xb4>
	{
		
		if(CA_msg->rcvdata != NULL)
 801033c:	687b      	ldr	r3, [r7, #4]
 801033e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010340:	2b00      	cmp	r3, #0
 8010342:	d007      	beq.n	8010354 <sendAbort+0x9c>
		{
			free(CA_msg->rcvdata);
 8010344:	687b      	ldr	r3, [r7, #4]
 8010346:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010348:	4618      	mov	r0, r3
 801034a:	f012 f98f 	bl	802266c <free>
			CA_msg -> rcvdata = NULL;
 801034e:	687b      	ldr	r3, [r7, #4]
 8010350:	2200      	movs	r2, #0
 8010352:	655a      	str	r2, [r3, #84]	; 0x54
		}
		tempCm = &(CA_msg->cm);
 8010354:	687b      	ldr	r3, [r7, #4]
 8010356:	3316      	adds	r3, #22
 8010358:	61bb      	str	r3, [r7, #24]
		memset(tempCm,0,sizeof(struct J1939_CM));
 801035a:	69b8      	ldr	r0, [r7, #24]
 801035c:	2100      	movs	r1, #0
 801035e:	222a      	movs	r2, #42	; 0x2a
 8010360:	f012 f98c 	bl	802267c <memset>
		return result = RC_CANNOTTRANSMIT;
 8010364:	230a      	movs	r3, #10
 8010366:	77fb      	strb	r3, [r7, #31]
 8010368:	7ffb      	ldrb	r3, [r7, #31]
 801036a:	e016      	b.n	801039a <sendAbort+0xe2>
	}
	else 
	{
		if(CA_msg->rcvdata != NULL)
 801036c:	687b      	ldr	r3, [r7, #4]
 801036e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010370:	2b00      	cmp	r3, #0
 8010372:	d007      	beq.n	8010384 <sendAbort+0xcc>
		{
			free(CA_msg->rcvdata);
 8010374:	687b      	ldr	r3, [r7, #4]
 8010376:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010378:	4618      	mov	r0, r3
 801037a:	f012 f977 	bl	802266c <free>
			CA_msg->rcvdata = NULL;
 801037e:	687b      	ldr	r3, [r7, #4]
 8010380:	2200      	movs	r2, #0
 8010382:	655a      	str	r2, [r3, #84]	; 0x54
		}
		tempCm = &(CA_msg->cm);
 8010384:	687b      	ldr	r3, [r7, #4]
 8010386:	3316      	adds	r3, #22
 8010388:	61bb      	str	r3, [r7, #24]
		memset(tempCm,0,sizeof(struct J1939_CM));
 801038a:	69b8      	ldr	r0, [r7, #24]
 801038c:	2100      	movs	r1, #0
 801038e:	222a      	movs	r2, #42	; 0x2a
 8010390:	f012 f974 	bl	802267c <memset>

		return result = RC_SUCCESS;
 8010394:	2300      	movs	r3, #0
 8010396:	77fb      	strb	r3, [r7, #31]
 8010398:	7ffb      	ldrb	r3, [r7, #31]
	}
}
 801039a:	4618      	mov	r0, r3
 801039c:	3720      	adds	r7, #32
 801039e:	46bd      	mov	sp, r7
 80103a0:	bd80      	pop	{r7, pc}
 80103a2:	bf00      	nop

080103a4 <sendMessage>:

unsigned char sendMessage(CA_Msg_t CA_msg, unsigned char *data)
{
 80103a4:	b580      	push	{r7, lr}
 80103a6:	b08c      	sub	sp, #48	; 0x30
 80103a8:	af00      	add	r7, sp, #0
 80103aa:	60f8      	str	r0, [r7, #12]
 80103ac:	60b9      	str	r1, [r7, #8]
	unsigned char i;
	struct J1939_msg j1939_msg;
	unsigned char sa;
	unsigned char result;
	if((sa = CA_FindAddress(&calist,CA_msg)) == 254)
 80103ae:	488a      	ldr	r0, [pc, #552]	; (80105d8 <sendMessage+0x234>)
 80103b0:	68f9      	ldr	r1, [r7, #12]
 80103b2:	f000 ffb5 	bl	8011320 <CA_FindAddress>
 80103b6:	4603      	mov	r3, r0
 80103b8:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
 80103bc:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 80103c0:	2bfe      	cmp	r3, #254	; 0xfe
 80103c2:	d101      	bne.n	80103c8 <sendMessage+0x24>
		return RC_ERROR;
 80103c4:	2301      	movs	r3, #1
 80103c6:	e103      	b.n	80105d0 <sendMessage+0x22c>
	if (CA_msg->sendbytes <= 8)
 80103c8:	68fb      	ldr	r3, [r7, #12]
 80103ca:	8a9b      	ldrh	r3, [r3, #20]
 80103cc:	2b08      	cmp	r3, #8
 80103ce:	d850      	bhi.n	8010472 <sendMessage+0xce>
	{
		j1939_msg.DataLength = CA_msg->sendbytes;
 80103d0:	68fb      	ldr	r3, [r7, #12]
 80103d2:	8a9b      	ldrh	r3, [r3, #20]
 80103d4:	b2db      	uxtb	r3, r3
 80103d6:	f003 030f 	and.w	r3, r3, #15
 80103da:	b2da      	uxtb	r2, r3
 80103dc:	7e3b      	ldrb	r3, [r7, #24]
 80103de:	f362 0303 	bfi	r3, r2, #0, #4
 80103e2:	763b      	strb	r3, [r7, #24]
		j1939_msg.DataPage = CA_msg->msg.DataPage;
 80103e4:	68fb      	ldr	r3, [r7, #12]
 80103e6:	791b      	ldrb	r3, [r3, #4]
 80103e8:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 80103ec:	b2da      	uxtb	r2, r3
 80103ee:	7d3b      	ldrb	r3, [r7, #20]
 80103f0:	f362 03c3 	bfi	r3, r2, #3, #1
 80103f4:	753b      	strb	r3, [r7, #20]
		j1939_msg.edp = CA_msg->msg.edp;
 80103f6:	68fb      	ldr	r3, [r7, #12]
 80103f8:	791b      	ldrb	r3, [r3, #4]
 80103fa:	f3c3 1300 	ubfx	r3, r3, #4, #1
 80103fe:	b2da      	uxtb	r2, r3
 8010400:	7d3b      	ldrb	r3, [r7, #20]
 8010402:	f362 1304 	bfi	r3, r2, #4, #1
 8010406:	753b      	strb	r3, [r7, #20]
		j1939_msg.PDUFormat = CA_msg->msg.PDUFormat;
 8010408:	68fb      	ldr	r3, [r7, #12]
 801040a:	795b      	ldrb	r3, [r3, #5]
 801040c:	757b      	strb	r3, [r7, #21]
		j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
 801040e:	68fb      	ldr	r3, [r7, #12]
 8010410:	799b      	ldrb	r3, [r3, #6]
 8010412:	75bb      	strb	r3, [r7, #22]
		j1939_msg.Priority = CA_msg->msg.Priority;
 8010414:	68fb      	ldr	r3, [r7, #12]
 8010416:	791b      	ldrb	r3, [r3, #4]
 8010418:	f3c3 1342 	ubfx	r3, r3, #5, #3
 801041c:	b2da      	uxtb	r2, r3
 801041e:	7d3b      	ldrb	r3, [r7, #20]
 8010420:	f362 1347 	bfi	r3, r2, #5, #3
 8010424:	753b      	strb	r3, [r7, #20]
		j1939_msg.SourceAddress = sa;
 8010426:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 801042a:	75fb      	strb	r3, [r7, #23]
		for (i = 0;i < CA_msg->sendbytes;i++)
 801042c:	2300      	movs	r3, #0
 801042e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8010432:	e010      	b.n	8010456 <sendMessage+0xb2>
			j1939_msg.Data[i] = data[i];
 8010434:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8010438:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
 801043c:	68b9      	ldr	r1, [r7, #8]
 801043e:	440a      	add	r2, r1
 8010440:	7812      	ldrb	r2, [r2, #0]
 8010442:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8010446:	440b      	add	r3, r1
 8010448:	f803 2c17 	strb.w	r2, [r3, #-23]
		j1939_msg.edp = CA_msg->msg.edp;
		j1939_msg.PDUFormat = CA_msg->msg.PDUFormat;
		j1939_msg.PDUSpecific = CA_msg->msg.PDUSpecific;
		j1939_msg.Priority = CA_msg->msg.Priority;
		j1939_msg.SourceAddress = sa;
		for (i = 0;i < CA_msg->sendbytes;i++)
 801044c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8010450:	3301      	adds	r3, #1
 8010452:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8010456:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801045a:	b29a      	uxth	r2, r3
 801045c:	68fb      	ldr	r3, [r7, #12]
 801045e:	8a9b      	ldrh	r3, [r3, #20]
 8010460:	429a      	cmp	r2, r3
 8010462:	d3e7      	bcc.n	8010434 <sendMessage+0x90>
			j1939_msg.Data[i] = data[i];
		return writeCan(&j1939_msg);
 8010464:	f107 0314 	add.w	r3, r7, #20
 8010468:	4618      	mov	r0, r3
 801046a:	f001 f91d 	bl	80116a8 <writeCan>
 801046e:	4603      	mov	r3, r0
 8010470:	e0ae      	b.n	80105d0 <sendMessage+0x22c>
	else
	{
		unsigned char *tmp;
		unsigned short j,k;
		
		j = ceil(((double)CA_msg->sendbytes + 3)/7);
 8010472:	68fb      	ldr	r3, [r7, #12]
 8010474:	8a9b      	ldrh	r3, [r3, #20]
 8010476:	ee07 3a90 	vmov	s15, r3
 801047a:	eeb8 7b67 	vcvt.f64.u32	d7, s15
 801047e:	eeb0 6b08 	vmov.f64	d6, #8
 8010482:	ee37 7b06 	vadd.f64	d7, d7, d6
 8010486:	eeb1 6b0c 	vmov.f64	d6, #28
 801048a:	ee87 7b06 	vdiv.f64	d7, d7, d6
 801048e:	eeb0 0b47 	vmov.f64	d0, d7
 8010492:	f017 fa65 	bl	8027960 <ceil>
 8010496:	eeb0 7b40 	vmov.f64	d7, d0
 801049a:	eefc 7bc7 	vcvt.u32.f64	s15, d7
 801049e:	edc7 7a01 	vstr	s15, [r7, #4]
 80104a2:	88bb      	ldrh	r3, [r7, #4]
 80104a4:	853b      	strh	r3, [r7, #40]	; 0x28
		CA_msg->cm.sendpackets = j;
 80104a6:	68fb      	ldr	r3, [r7, #12]
 80104a8:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 80104aa:	82da      	strh	r2, [r3, #22]
		tmp = (unsigned char *)malloc((CA_msg->sendbytes+3) * sizeof(char));
 80104ac:	68fb      	ldr	r3, [r7, #12]
 80104ae:	8a9b      	ldrh	r3, [r3, #20]
 80104b0:	3303      	adds	r3, #3
 80104b2:	4618      	mov	r0, r3
 80104b4:	f012 f8d2 	bl	802265c <malloc>
 80104b8:	4603      	mov	r3, r0
 80104ba:	627b      	str	r3, [r7, #36]	; 0x24
		for(k=0;k < (CA_msg->sendbytes);k++)
 80104bc:	2300      	movs	r3, #0
 80104be:	85bb      	strh	r3, [r7, #44]	; 0x2c
 80104c0:	e00a      	b.n	80104d8 <sendMessage+0x134>
		{
				tmp[k] = data[k];
 80104c2:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 80104c4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80104c6:	4413      	add	r3, r2
 80104c8:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
 80104ca:	68b9      	ldr	r1, [r7, #8]
 80104cc:	440a      	add	r2, r1
 80104ce:	7812      	ldrb	r2, [r2, #0]
 80104d0:	701a      	strb	r2, [r3, #0]
		unsigned short j,k;
		
		j = ceil(((double)CA_msg->sendbytes + 3)/7);
		CA_msg->cm.sendpackets = j;
		tmp = (unsigned char *)malloc((CA_msg->sendbytes+3) * sizeof(char));
		for(k=0;k < (CA_msg->sendbytes);k++)
 80104d2:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 80104d4:	3301      	adds	r3, #1
 80104d6:	85bb      	strh	r3, [r7, #44]	; 0x2c
 80104d8:	68fb      	ldr	r3, [r7, #12]
 80104da:	8a9b      	ldrh	r3, [r3, #20]
 80104dc:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
 80104de:	429a      	cmp	r2, r3
 80104e0:	d3ef      	bcc.n	80104c2 <sendMessage+0x11e>
		{
				tmp[k] = data[k];
		}
		tmp[k] = CA_msg->msg.PDUSpecific;
 80104e2:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 80104e4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80104e6:	4413      	add	r3, r2
 80104e8:	68fa      	ldr	r2, [r7, #12]
 80104ea:	7992      	ldrb	r2, [r2, #6]
 80104ec:	701a      	strb	r2, [r3, #0]
		tmp[k+1] = CA_msg->msg.PDUFormat;
 80104ee:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 80104f0:	3301      	adds	r3, #1
 80104f2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80104f4:	4413      	add	r3, r2
 80104f6:	68fa      	ldr	r2, [r7, #12]
 80104f8:	7952      	ldrb	r2, [r2, #5]
 80104fa:	701a      	strb	r2, [r3, #0]
		tmp[k+2] = CA_msg->msg.DataPage;
 80104fc:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 80104fe:	3302      	adds	r3, #2
 8010500:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8010502:	4413      	add	r3, r2
 8010504:	68fa      	ldr	r2, [r7, #12]
 8010506:	7912      	ldrb	r2, [r2, #4]
 8010508:	f3c2 02c0 	ubfx	r2, r2, #3, #1
 801050c:	b2d2      	uxtb	r2, r2
 801050e:	701a      	strb	r2, [r3, #0]
		CA_msg->msg.SourceAddress = sa;
 8010510:	68fb      	ldr	r3, [r7, #12]
 8010512:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
 8010516:	71da      	strb	r2, [r3, #7]
		if(CA_msg->msg.PDUSpecific== J1939_GLOBAL_ADDRESS)
 8010518:	68fb      	ldr	r3, [r7, #12]
 801051a:	799b      	ldrb	r3, [r3, #6]
 801051c:	2bff      	cmp	r3, #255	; 0xff
 801051e:	d107      	bne.n	8010530 <sendMessage+0x18c>
			result = sendBAM(CA_msg,tmp);
 8010520:	68f8      	ldr	r0, [r7, #12]
 8010522:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8010524:	f7ff fd6a 	bl	800fffc <sendBAM>
 8010528:	4603      	mov	r3, r0
 801052a:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
 801052e:	e045      	b.n	80105bc <sendMessage+0x218>
		else
		{
			
			result = sendRTS(CA_msg);
 8010530:	68f8      	ldr	r0, [r7, #12]
 8010532:	f7ff fe2b 	bl	801018c <sendRTS>
 8010536:	4603      	mov	r3, r0
 8010538:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
			if(result == RC_SUCCESS)
 801053c:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8010540:	2b00      	cmp	r3, #0
 8010542:	d119      	bne.n	8010578 <sendMessage+0x1d4>
			{
				result = sendData(CA_msg, tmp);
 8010544:	68f8      	ldr	r0, [r7, #12]
 8010546:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8010548:	f7ff fca6 	bl	800fe98 <sendData>
 801054c:	4603      	mov	r3, r0
 801054e:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
				if(result != RC_SUCCESS )
 8010552:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8010556:	2b00      	cmp	r3, #0
 8010558:	d003      	beq.n	8010562 <sendMessage+0x1be>
					sendAbort(CA_msg, 0);
 801055a:	68f8      	ldr	r0, [r7, #12]
 801055c:	2100      	movs	r1, #0
 801055e:	f7ff feab 	bl	80102b8 <sendAbort>
				if(tmp != NULL)
 8010562:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010564:	2b00      	cmp	r3, #0
 8010566:	d004      	beq.n	8010572 <sendMessage+0x1ce>
				{
					free(tmp);
 8010568:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801056a:	f012 f87f 	bl	802266c <free>
					tmp = NULL;
 801056e:	2300      	movs	r3, #0
 8010570:	627b      	str	r3, [r7, #36]	; 0x24
				}
				return result;
 8010572:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8010576:	e02b      	b.n	80105d0 <sendMessage+0x22c>
			}
			else if(result == RC_TIMEOUT)
 8010578:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 801057c:	2b0b      	cmp	r3, #11
 801057e:	d10e      	bne.n	801059e <sendMessage+0x1fa>
			{
				if(tmp != NULL)
 8010580:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010582:	2b00      	cmp	r3, #0
 8010584:	d004      	beq.n	8010590 <sendMessage+0x1ec>
				{
					free(tmp);
 8010586:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010588:	f012 f870 	bl	802266c <free>
					tmp = NULL;
 801058c:	2300      	movs	r3, #0
 801058e:	627b      	str	r3, [r7, #36]	; 0x24
				}
				sendAbort(CA_msg,0);
 8010590:	68f8      	ldr	r0, [r7, #12]
 8010592:	2100      	movs	r1, #0
 8010594:	f7ff fe90 	bl	80102b8 <sendAbort>
				return result;
 8010598:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 801059c:	e018      	b.n	80105d0 <sendMessage+0x22c>
			}
			else if(result == RC_CANNOTTRANSMIT)
 801059e:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 80105a2:	2b0a      	cmp	r3, #10
 80105a4:	d10a      	bne.n	80105bc <sendMessage+0x218>
			{
				if(tmp != NULL)
 80105a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80105a8:	2b00      	cmp	r3, #0
 80105aa:	d004      	beq.n	80105b6 <sendMessage+0x212>
				{
					free(tmp);
 80105ac:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80105ae:	f012 f85d 	bl	802266c <free>
					tmp = NULL;
 80105b2:	2300      	movs	r3, #0
 80105b4:	627b      	str	r3, [r7, #36]	; 0x24
				}
				return result;
 80105b6:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 80105ba:	e009      	b.n	80105d0 <sendMessage+0x22c>
			}
		}

		if(tmp != NULL)
 80105bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80105be:	2b00      	cmp	r3, #0
 80105c0:	d004      	beq.n	80105cc <sendMessage+0x228>
		{
			free(tmp);
 80105c2:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80105c4:	f012 f852 	bl	802266c <free>
			tmp = NULL;
 80105c8:	2300      	movs	r3, #0
 80105ca:	627b      	str	r3, [r7, #36]	; 0x24
		}
	}
	return result;
 80105cc:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
}
 80105d0:	4618      	mov	r0, r3
 80105d2:	3730      	adds	r7, #48	; 0x30
 80105d4:	46bd      	mov	sp, r7
 80105d6:	bd80      	pop	{r7, pc}
 80105d8:	200127a0 	.word	0x200127a0

080105dc <checkRes>:


unsigned char checkRes()
{
 80105dc:	b480      	push	{r7}
 80105de:	af00      	add	r7, sp, #0
	return RC_SUCCESS;
 80105e0:	2300      	movs	r3, #0
}
 80105e2:	4618      	mov	r0, r3
 80105e4:	46bd      	mov	sp, r7
 80105e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80105ea:	4770      	bx	lr

080105ec <sendCTS>:

unsigned char sendCTS(J1939_msg_t j1939_msg,CA_Msg_t CA_msg,unsigned int startnum,unsigned int num)
{
 80105ec:	b580      	push	{r7, lr}
 80105ee:	b08a      	sub	sp, #40	; 0x28
 80105f0:	af00      	add	r7, sp, #0
 80105f2:	60f8      	str	r0, [r7, #12]
 80105f4:	60b9      	str	r1, [r7, #8]
 80105f6:	607a      	str	r2, [r7, #4]
 80105f8:	603b      	str	r3, [r7, #0]
	struct J1939_msg temp_msg;
	unsigned char result;
	temp_msg.DataLength = j1939_msg->DataLength;
 80105fa:	68fb      	ldr	r3, [r7, #12]
 80105fc:	791b      	ldrb	r3, [r3, #4]
 80105fe:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8010602:	b2da      	uxtb	r2, r3
 8010604:	7e3b      	ldrb	r3, [r7, #24]
 8010606:	f362 0303 	bfi	r3, r2, #0, #4
 801060a:	763b      	strb	r3, [r7, #24]
	temp_msg.DataPage = j1939_msg->DataPage;
 801060c:	68fb      	ldr	r3, [r7, #12]
 801060e:	781b      	ldrb	r3, [r3, #0]
 8010610:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8010614:	b2da      	uxtb	r2, r3
 8010616:	7d3b      	ldrb	r3, [r7, #20]
 8010618:	f362 03c3 	bfi	r3, r2, #3, #1
 801061c:	753b      	strb	r3, [r7, #20]
	temp_msg.edp = j1939_msg->edp;
 801061e:	68fb      	ldr	r3, [r7, #12]
 8010620:	781b      	ldrb	r3, [r3, #0]
 8010622:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8010626:	b2da      	uxtb	r2, r3
 8010628:	7d3b      	ldrb	r3, [r7, #20]
 801062a:	f362 1304 	bfi	r3, r2, #4, #1
 801062e:	753b      	strb	r3, [r7, #20]
	temp_msg.PDUFormat = j1939_msg->PDUFormat;
 8010630:	68fb      	ldr	r3, [r7, #12]
 8010632:	785b      	ldrb	r3, [r3, #1]
 8010634:	757b      	strb	r3, [r7, #21]
	temp_msg.PDUSpecific = j1939_msg->SourceAddress;
 8010636:	68fb      	ldr	r3, [r7, #12]
 8010638:	78db      	ldrb	r3, [r3, #3]
 801063a:	75bb      	strb	r3, [r7, #22]
	temp_msg.Priority = j1939_msg->Priority;
 801063c:	68fb      	ldr	r3, [r7, #12]
 801063e:	781b      	ldrb	r3, [r3, #0]
 8010640:	f3c3 1342 	ubfx	r3, r3, #5, #3
 8010644:	b2da      	uxtb	r2, r3
 8010646:	7d3b      	ldrb	r3, [r7, #20]
 8010648:	f362 1347 	bfi	r3, r2, #5, #3
 801064c:	753b      	strb	r3, [r7, #20]
	temp_msg.SourceAddress = j1939_msg->PDUSpecific;
 801064e:	68fb      	ldr	r3, [r7, #12]
 8010650:	789b      	ldrb	r3, [r3, #2]
 8010652:	75fb      	strb	r3, [r7, #23]
	temp_msg.Data[0] = J1939_CTS_CONTROL_BYTE;
 8010654:	2311      	movs	r3, #17
 8010656:	767b      	strb	r3, [r7, #25]
	if(j1939_msg->Data[4] < j1939_msg->Data[3])
		temp_msg.Data[1] = j1939_msg->Data[4];
	else
		temp_msg.Data[1] = j1939_msg->Data[3];
#endif
	temp_msg.Data[1] = num;
 8010658:	683b      	ldr	r3, [r7, #0]
 801065a:	b2db      	uxtb	r3, r3
 801065c:	76bb      	strb	r3, [r7, #26]
	temp_msg.Data[2] = startnum;
 801065e:	687b      	ldr	r3, [r7, #4]
 8010660:	b2db      	uxtb	r3, r3
 8010662:	76fb      	strb	r3, [r7, #27]
	temp_msg.Data[3] = 0xff;
 8010664:	23ff      	movs	r3, #255	; 0xff
 8010666:	773b      	strb	r3, [r7, #28]
	temp_msg.Data[4] = 0xff;
 8010668:	23ff      	movs	r3, #255	; 0xff
 801066a:	777b      	strb	r3, [r7, #29]
	temp_msg.Data[5] = CA_msg->cm.DTPS;
 801066c:	68bb      	ldr	r3, [r7, #8]
 801066e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8010672:	77bb      	strb	r3, [r7, #30]
	temp_msg.Data[6] = CA_msg->cm.DTPF;
 8010674:	68bb      	ldr	r3, [r7, #8]
 8010676:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 801067a:	77fb      	strb	r3, [r7, #31]
	temp_msg.Data[7] = CA_msg->cm.DTDP;
 801067c:	68bb      	ldr	r3, [r7, #8]
 801067e:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 8010682:	f887 3020 	strb.w	r3, [r7, #32]
	
	if(writeCan(&temp_msg) == RC_SUCCESS)
 8010686:	f107 0314 	add.w	r3, r7, #20
 801068a:	4618      	mov	r0, r3
 801068c:	f001 f80c 	bl	80116a8 <writeCan>
 8010690:	4603      	mov	r3, r0
 8010692:	2b00      	cmp	r3, #0
 8010694:	d111      	bne.n	80106ba <sendCTS+0xce>
	{
		CA_msg->cm.t2.en = 1;
 8010696:	68bb      	ldr	r3, [r7, #8]
 8010698:	2201      	movs	r2, #1
 801069a:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
		CA_msg->cm.t2.release = 0;
 801069e:	68bb      	ldr	r3, [r7, #8]
 80106a0:	2200      	movs	r2, #0
 80106a2:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
		CA_msg->cm.t2.value = T2TIMEOUT;
 80106a6:	68bb      	ldr	r3, [r7, #8]
 80106a8:	f240 42e2 	movw	r2, #1250	; 0x4e2
 80106ac:	855a      	strh	r2, [r3, #42]	; 0x2a
		return result = RC_SUCCESS;
 80106ae:	2300      	movs	r3, #0
 80106b0:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 80106b4:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80106b8:	e004      	b.n	80106c4 <sendCTS+0xd8>
	}
	else
		return result = RC_CANNOTTRANSMIT;
 80106ba:	230a      	movs	r3, #10
 80106bc:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 80106c0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
 80106c4:	4618      	mov	r0, r3
 80106c6:	3728      	adds	r7, #40	; 0x28
 80106c8:	46bd      	mov	sp, r7
 80106ca:	bd80      	pop	{r7, pc}

080106cc <response_RTS>:

unsigned char response_RTS(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 80106cc:	b580      	push	{r7, lr}
 80106ce:	b084      	sub	sp, #16
 80106d0:	af00      	add	r7, sp, #0
 80106d2:	6078      	str	r0, [r7, #4]
 80106d4:	6039      	str	r1, [r7, #0]
	unsigned char result = RC_SUCCESS;
 80106d6:	2300      	movs	r3, #0
 80106d8:	73fb      	strb	r3, [r7, #15]
	
	if(j1939_msg->PDUSpecific == J1939_GLOBAL_ADDRESS)
 80106da:	687b      	ldr	r3, [r7, #4]
 80106dc:	789b      	ldrb	r3, [r3, #2]
 80106de:	2bff      	cmp	r3, #255	; 0xff
 80106e0:	d103      	bne.n	80106ea <response_RTS+0x1e>
		return result = RC_ERROR;
 80106e2:	2301      	movs	r3, #1
 80106e4:	73fb      	strb	r3, [r7, #15]
 80106e6:	7bfb      	ldrb	r3, [r7, #15]
 80106e8:	e04f      	b.n	801078a <response_RTS+0xbe>
	if(checkRes() == RC_SUCCESS && CA_msg->cm.cm_lock == 0)
 80106ea:	f7ff ff77 	bl	80105dc <checkRes>
 80106ee:	4603      	mov	r3, r0
 80106f0:	2b00      	cmp	r3, #0
 80106f2:	d147      	bne.n	8010784 <response_RTS+0xb8>
 80106f4:	683b      	ldr	r3, [r7, #0]
 80106f6:	7f1b      	ldrb	r3, [r3, #28]
 80106f8:	2b00      	cmp	r3, #0
 80106fa:	d143      	bne.n	8010784 <response_RTS+0xb8>
	{
		rt_kprintf("receive rts packets = %d\r\n", j1939_msg->Data[3]);
 80106fc:	687b      	ldr	r3, [r7, #4]
 80106fe:	7a1b      	ldrb	r3, [r3, #8]
 8010700:	4824      	ldr	r0, [pc, #144]	; (8010794 <response_RTS+0xc8>)
 8010702:	4619      	mov	r1, r3
 8010704:	f006 fd04 	bl	8017110 <rt_kprintf>
		CA_msg->cm.rcvpackets = j1939_msg->Data[3];
 8010708:	687b      	ldr	r3, [r7, #4]
 801070a:	7a1b      	ldrb	r3, [r3, #8]
 801070c:	b29a      	uxth	r2, r3
 801070e:	683b      	ldr	r3, [r7, #0]
 8010710:	86da      	strh	r2, [r3, #54]	; 0x36
		CA_msg->cm.rcvbytes = j1939_msg->Data[2]*256+j1939_msg->Data[1];
 8010712:	687b      	ldr	r3, [r7, #4]
 8010714:	79db      	ldrb	r3, [r3, #7]
 8010716:	b29b      	uxth	r3, r3
 8010718:	021b      	lsls	r3, r3, #8
 801071a:	b29a      	uxth	r2, r3
 801071c:	687b      	ldr	r3, [r7, #4]
 801071e:	799b      	ldrb	r3, [r3, #6]
 8010720:	b29b      	uxth	r3, r3
 8010722:	4413      	add	r3, r2
 8010724:	b29a      	uxth	r2, r3
 8010726:	683b      	ldr	r3, [r7, #0]
 8010728:	871a      	strh	r2, [r3, #56]	; 0x38
		CA_msg->rcvdata = (unsigned char *)malloc(7 * CA_msg->cm.rcvpackets);
 801072a:	683b      	ldr	r3, [r7, #0]
 801072c:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 801072e:	461a      	mov	r2, r3
 8010730:	4613      	mov	r3, r2
 8010732:	00db      	lsls	r3, r3, #3
 8010734:	1a9b      	subs	r3, r3, r2
 8010736:	4618      	mov	r0, r3
 8010738:	f011 ff90 	bl	802265c <malloc>
 801073c:	4603      	mov	r3, r0
 801073e:	461a      	mov	r2, r3
 8010740:	683b      	ldr	r3, [r7, #0]
 8010742:	655a      	str	r2, [r3, #84]	; 0x54
		CA_msg->cm.DTDP = j1939_msg->DataPage;
 8010744:	687b      	ldr	r3, [r7, #4]
 8010746:	781b      	ldrb	r3, [r3, #0]
 8010748:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 801074c:	b2db      	uxtb	r3, r3
 801074e:	461a      	mov	r2, r3
 8010750:	683b      	ldr	r3, [r7, #0]
 8010752:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
		CA_msg->cm.DTPF = j1939_msg->PDUFormat;
 8010756:	687b      	ldr	r3, [r7, #4]
 8010758:	785a      	ldrb	r2, [r3, #1]
 801075a:	683b      	ldr	r3, [r7, #0]
 801075c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
		CA_msg->cm.DTPS = j1939_msg->PDUSpecific;
 8010760:	687b      	ldr	r3, [r7, #4]
 8010762:	789a      	ldrb	r2, [r3, #2]
 8010764:	683b      	ldr	r3, [r7, #0]
 8010766:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
				sendCTS(j1939_msg,CA_msg,1,j1939_msg->Data[3] );
			else 
				sendCTS(j1939_msg,CA_msg,1,8);
		#endif 
		
		sendCTS(j1939_msg,CA_msg,1,1);
 801076a:	6878      	ldr	r0, [r7, #4]
 801076c:	6839      	ldr	r1, [r7, #0]
 801076e:	2201      	movs	r2, #1
 8010770:	2301      	movs	r3, #1
 8010772:	f7ff ff3b 	bl	80105ec <sendCTS>
		CA_msg->cm.cm_lock = 1;
 8010776:	683b      	ldr	r3, [r7, #0]
 8010778:	2201      	movs	r2, #1
 801077a:	771a      	strb	r2, [r3, #28]
		return result = RC_SUCCESS;
 801077c:	2300      	movs	r3, #0
 801077e:	73fb      	strb	r3, [r7, #15]
 8010780:	7bfb      	ldrb	r3, [r7, #15]
 8010782:	e002      	b.n	801078a <response_RTS+0xbe>
	}
	return result = RC_ERROR;
 8010784:	2301      	movs	r3, #1
 8010786:	73fb      	strb	r3, [r7, #15]
 8010788:	7bfb      	ldrb	r3, [r7, #15]
}
 801078a:	4618      	mov	r0, r3
 801078c:	3710      	adds	r7, #16
 801078e:	46bd      	mov	sp, r7
 8010790:	bd80      	pop	{r7, pc}
 8010792:	bf00      	nop
 8010794:	0802870c 	.word	0x0802870c

08010798 <response_CTS>:


unsigned char response_CTS(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 8010798:	b580      	push	{r7, lr}
 801079a:	b084      	sub	sp, #16
 801079c:	af00      	add	r7, sp, #0
 801079e:	6078      	str	r0, [r7, #4]
 80107a0:	6039      	str	r1, [r7, #0]
	unsigned char result = RC_SUCCESS;
 80107a2:	2300      	movs	r3, #0
 80107a4:	73fb      	strb	r3, [r7, #15]
	static struct q_Message q_msg;
	if(j1939_msg->PDUSpecific == J1939_GLOBAL_ADDRESS)
 80107a6:	687b      	ldr	r3, [r7, #4]
 80107a8:	789b      	ldrb	r3, [r3, #2]
 80107aa:	2bff      	cmp	r3, #255	; 0xff
 80107ac:	d103      	bne.n	80107b6 <response_CTS+0x1e>
		return result = RC_ERROR;
 80107ae:	2301      	movs	r3, #1
 80107b0:	73fb      	strb	r3, [r7, #15]
 80107b2:	7bfb      	ldrb	r3, [r7, #15]
 80107b4:	e045      	b.n	8010842 <response_CTS+0xaa>
	if(CA_msg->cm.t3.en == 0 && CA_msg->cm.t4.en == 0)
 80107b6:	683b      	ldr	r3, [r7, #0]
 80107b8:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 80107bc:	2b00      	cmp	r3, #0
 80107be:	d108      	bne.n	80107d2 <response_CTS+0x3a>
 80107c0:	683b      	ldr	r3, [r7, #0]
 80107c2:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 80107c6:	2b00      	cmp	r3, #0
 80107c8:	d103      	bne.n	80107d2 <response_CTS+0x3a>
		return result = RC_ERROR;
 80107ca:	2301      	movs	r3, #1
 80107cc:	73fb      	strb	r3, [r7, #15]
 80107ce:	7bfb      	ldrb	r3, [r7, #15]
 80107d0:	e037      	b.n	8010842 <response_CTS+0xaa>
	CA_msg->cm.t3.release = 1;
 80107d2:	683b      	ldr	r3, [r7, #0]
 80107d4:	2201      	movs	r2, #1
 80107d6:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
	CA_msg->cm.t4.release = 1;
 80107da:	683b      	ldr	r3, [r7, #0]
 80107dc:	2201      	movs	r2, #1
 80107de:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
	if(j1939_msg->Data[1] == 0 && j1939_msg->Data[2] == 255)
 80107e2:	687b      	ldr	r3, [r7, #4]
 80107e4:	799b      	ldrb	r3, [r3, #6]
 80107e6:	2b00      	cmp	r3, #0
 80107e8:	d113      	bne.n	8010812 <response_CTS+0x7a>
 80107ea:	687b      	ldr	r3, [r7, #4]
 80107ec:	79db      	ldrb	r3, [r3, #7]
 80107ee:	2bff      	cmp	r3, #255	; 0xff
 80107f0:	d10f      	bne.n	8010812 <response_CTS+0x7a>
	{
		CA_msg->cm.t4.en = 1;
 80107f2:	683b      	ldr	r3, [r7, #0]
 80107f4:	2201      	movs	r2, #1
 80107f6:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
		CA_msg->cm.t4.release = 0;
 80107fa:	683b      	ldr	r3, [r7, #0]
 80107fc:	2200      	movs	r2, #0
 80107fe:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
		CA_msg->cm.t4.value = 1050;
 8010802:	683b      	ldr	r3, [r7, #0]
 8010804:	f240 421a 	movw	r2, #1050	; 0x41a
 8010808:	865a      	strh	r2, [r3, #50]	; 0x32
		return result = RC_ERROR;
 801080a:	2301      	movs	r3, #1
 801080c:	73fb      	strb	r3, [r7, #15]
 801080e:	7bfb      	ldrb	r3, [r7, #15]
 8010810:	e017      	b.n	8010842 <response_CTS+0xaa>
	}
	else
	{
		q_msg.nextnum = j1939_msg->Data[2];
 8010812:	687b      	ldr	r3, [r7, #4]
 8010814:	79db      	ldrb	r3, [r3, #7]
 8010816:	b29a      	uxth	r2, r3
 8010818:	4b0c      	ldr	r3, [pc, #48]	; (801084c <response_CTS+0xb4>)
 801081a:	801a      	strh	r2, [r3, #0]
		q_msg.sendnum = j1939_msg->Data[1];
 801081c:	687b      	ldr	r3, [r7, #4]
 801081e:	799b      	ldrb	r3, [r3, #6]
 8010820:	b29a      	uxth	r2, r3
 8010822:	4b0a      	ldr	r3, [pc, #40]	; (801084c <response_CTS+0xb4>)
 8010824:	805a      	strh	r2, [r3, #2]
		q_msg.timeout = 0;
 8010826:	4b09      	ldr	r3, [pc, #36]	; (801084c <response_CTS+0xb4>)
 8010828:	2200      	movs	r2, #0
 801082a:	809a      	strh	r2, [r3, #4]
		osMessagePut(CA_msg->txq,(unsigned long)&q_msg, 0);
 801082c:	683b      	ldr	r3, [r7, #0]
 801082e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8010830:	4a06      	ldr	r2, [pc, #24]	; (801084c <response_CTS+0xb4>)
 8010832:	4618      	mov	r0, r3
 8010834:	4611      	mov	r1, r2
 8010836:	2200      	movs	r2, #0
 8010838:	f008 fe0e 	bl	8019458 <osMessagePut>
		return result = RC_SUCCESS;
 801083c:	2300      	movs	r3, #0
 801083e:	73fb      	strb	r3, [r7, #15]
 8010840:	7bfb      	ldrb	r3, [r7, #15]
	}
}
 8010842:	4618      	mov	r0, r3
 8010844:	3710      	adds	r7, #16
 8010846:	46bd      	mov	sp, r7
 8010848:	bd80      	pop	{r7, pc}
 801084a:	bf00      	nop
 801084c:	200107f0 	.word	0x200107f0

08010850 <sendEndofMsgACK>:
unsigned char sendEndofMsgACK(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 8010850:	b580      	push	{r7, lr}
 8010852:	b088      	sub	sp, #32
 8010854:	af00      	add	r7, sp, #0
 8010856:	6078      	str	r0, [r7, #4]
 8010858:	6039      	str	r1, [r7, #0]
	struct J1939_msg temp_j1939;
	struct J1939_CM *tempCm;
	
	temp_j1939.DataLength = 8;
 801085a:	7c3b      	ldrb	r3, [r7, #16]
 801085c:	2208      	movs	r2, #8
 801085e:	f362 0303 	bfi	r3, r2, #0, #4
 8010862:	743b      	strb	r3, [r7, #16]
	temp_j1939.DataPage = 0;
 8010864:	7b3b      	ldrb	r3, [r7, #12]
 8010866:	f36f 03c3 	bfc	r3, #3, #1
 801086a:	733b      	strb	r3, [r7, #12]
	temp_j1939.edp = 0;
 801086c:	7b3b      	ldrb	r3, [r7, #12]
 801086e:	f36f 1304 	bfc	r3, #4, #1
 8010872:	733b      	strb	r3, [r7, #12]
	temp_j1939.PDUFormat = J1939_PF_TP_CM;
 8010874:	23ec      	movs	r3, #236	; 0xec
 8010876:	737b      	strb	r3, [r7, #13]
	temp_j1939.PDUSpecific = j1939_msg->SourceAddress;
 8010878:	687b      	ldr	r3, [r7, #4]
 801087a:	78db      	ldrb	r3, [r3, #3]
 801087c:	73bb      	strb	r3, [r7, #14]
	temp_j1939.Priority = 7;
 801087e:	7b3b      	ldrb	r3, [r7, #12]
 8010880:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 8010884:	733b      	strb	r3, [r7, #12]
	temp_j1939.SourceAddress = j1939_msg->PDUSpecific;
 8010886:	687b      	ldr	r3, [r7, #4]
 8010888:	789b      	ldrb	r3, [r3, #2]
 801088a:	73fb      	strb	r3, [r7, #15]
	temp_j1939.Data[0] = J1939_EOMACK_CONTROL_BYTE;
 801088c:	2313      	movs	r3, #19
 801088e:	747b      	strb	r3, [r7, #17]
	temp_j1939.Data[1] = CA_msg->cm.rcvbytes % 256;
 8010890:	683b      	ldr	r3, [r7, #0]
 8010892:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8010894:	b2db      	uxtb	r3, r3
 8010896:	74bb      	strb	r3, [r7, #18]
	temp_j1939.Data[2] = CA_msg->cm.rcvbytes / 256;
 8010898:	683b      	ldr	r3, [r7, #0]
 801089a:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 801089c:	0a1b      	lsrs	r3, r3, #8
 801089e:	b29b      	uxth	r3, r3
 80108a0:	b2db      	uxtb	r3, r3
 80108a2:	74fb      	strb	r3, [r7, #19]
	temp_j1939.Data[3] = CA_msg->cm.rcvpackets;
 80108a4:	683b      	ldr	r3, [r7, #0]
 80108a6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 80108a8:	b2db      	uxtb	r3, r3
 80108aa:	753b      	strb	r3, [r7, #20]
	temp_j1939.Data[4] = 0xff;
 80108ac:	23ff      	movs	r3, #255	; 0xff
 80108ae:	757b      	strb	r3, [r7, #21]
	temp_j1939.Data[5] = j1939_msg->Data[5];
 80108b0:	687b      	ldr	r3, [r7, #4]
 80108b2:	7a9b      	ldrb	r3, [r3, #10]
 80108b4:	75bb      	strb	r3, [r7, #22]
	temp_j1939.Data[6] = j1939_msg->Data[6];
 80108b6:	687b      	ldr	r3, [r7, #4]
 80108b8:	7adb      	ldrb	r3, [r3, #11]
 80108ba:	75fb      	strb	r3, [r7, #23]
	temp_j1939.Data[7] = j1939_msg->Data[7];
 80108bc:	687b      	ldr	r3, [r7, #4]
 80108be:	7b1b      	ldrb	r3, [r3, #12]
 80108c0:	763b      	strb	r3, [r7, #24]
	CA_msg->cm.cm_lock = 0;
 80108c2:	683b      	ldr	r3, [r7, #0]
 80108c4:	2200      	movs	r2, #0
 80108c6:	771a      	strb	r2, [r3, #28]
	if(CA_msg->rcvdata != NULL)
 80108c8:	683b      	ldr	r3, [r7, #0]
 80108ca:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80108cc:	2b00      	cmp	r3, #0
 80108ce:	d007      	beq.n	80108e0 <sendEndofMsgACK+0x90>
	{
		free(CA_msg->rcvdata);
 80108d0:	683b      	ldr	r3, [r7, #0]
 80108d2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80108d4:	4618      	mov	r0, r3
 80108d6:	f011 fec9 	bl	802266c <free>
		CA_msg->rcvdata = NULL;
 80108da:	683b      	ldr	r3, [r7, #0]
 80108dc:	2200      	movs	r2, #0
 80108de:	655a      	str	r2, [r3, #84]	; 0x54
	}
	tempCm = &(CA_msg->cm);
 80108e0:	683b      	ldr	r3, [r7, #0]
 80108e2:	3316      	adds	r3, #22
 80108e4:	61fb      	str	r3, [r7, #28]
	memset(tempCm,0,sizeof(struct J1939_CM));
 80108e6:	69f8      	ldr	r0, [r7, #28]
 80108e8:	2100      	movs	r1, #0
 80108ea:	222a      	movs	r2, #42	; 0x2a
 80108ec:	f011 fec6 	bl	802267c <memset>
	return writeCan(&temp_j1939);
 80108f0:	f107 030c 	add.w	r3, r7, #12
 80108f4:	4618      	mov	r0, r3
 80108f6:	f000 fed7 	bl	80116a8 <writeCan>
 80108fa:	4603      	mov	r3, r0
}
 80108fc:	4618      	mov	r0, r3
 80108fe:	3720      	adds	r7, #32
 8010900:	46bd      	mov	sp, r7
 8010902:	bd80      	pop	{r7, pc}

08010904 <receiveData>:

void receiveData(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 8010904:	b580      	push	{r7, lr}
 8010906:	b084      	sub	sp, #16
 8010908:	af00      	add	r7, sp, #0
 801090a:	6078      	str	r0, [r7, #4]
 801090c:	6039      	str	r1, [r7, #0]
	unsigned char i;
	static struct rx_Message rxmsg,bamrxmsg;
	unsigned short j;
	if((j1939_msg->PDUSpecific == J1939_GLOBAL_ADDRESS) )
 801090e:	687b      	ldr	r3, [r7, #4]
 8010910:	789b      	ldrb	r3, [r3, #2]
 8010912:	2bff      	cmp	r3, #255	; 0xff
 8010914:	f040 8092 	bne.w	8010a3c <receiveData+0x138>
	{
		if((CA_msg->bam.cm_lock == 1) && (CA_msg->bamrcvdata != NULL))
 8010918:	683b      	ldr	r3, [r7, #0]
 801091a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 801091e:	2b01      	cmp	r3, #1
 8010920:	f040 8143 	bne.w	8010baa <receiveData+0x2a6>
 8010924:	683b      	ldr	r3, [r7, #0]
 8010926:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8010928:	2b00      	cmp	r3, #0
 801092a:	f000 813e 	beq.w	8010baa <receiveData+0x2a6>
		{
			CA_msg->bam.t1.en = 1;
 801092e:	683b      	ldr	r3, [r7, #0]
 8010930:	2201      	movs	r2, #1
 8010932:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
			CA_msg->bam.t1.release = 1;
 8010936:	683b      	ldr	r3, [r7, #0]
 8010938:	2201      	movs	r2, #1
 801093a:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			CA_msg->bam.t1.value = 0;
 801093e:	683b      	ldr	r3, [r7, #0]
 8010940:	2200      	movs	r2, #0
 8010942:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42

				
			for(i=1;i<j1939_msg->DataLength;i++)
 8010946:	2301      	movs	r3, #1
 8010948:	73fb      	strb	r3, [r7, #15]
 801094a:	e013      	b.n	8010974 <receiveData+0x70>
			{
				CA_msg->bamrcvdata[7*(j1939_msg->Data[0]-1)+i-1] = j1939_msg->Data[i];
 801094c:	683b      	ldr	r3, [r7, #0]
 801094e:	6d99      	ldr	r1, [r3, #88]	; 0x58
 8010950:	687b      	ldr	r3, [r7, #4]
 8010952:	795b      	ldrb	r3, [r3, #5]
 8010954:	1e5a      	subs	r2, r3, #1
 8010956:	4613      	mov	r3, r2
 8010958:	00db      	lsls	r3, r3, #3
 801095a:	1a9a      	subs	r2, r3, r2
 801095c:	7bfb      	ldrb	r3, [r7, #15]
 801095e:	4413      	add	r3, r2
 8010960:	3b01      	subs	r3, #1
 8010962:	440b      	add	r3, r1
 8010964:	7bfa      	ldrb	r2, [r7, #15]
 8010966:	6879      	ldr	r1, [r7, #4]
 8010968:	440a      	add	r2, r1
 801096a:	7952      	ldrb	r2, [r2, #5]
 801096c:	701a      	strb	r2, [r3, #0]
			CA_msg->bam.t1.en = 1;
			CA_msg->bam.t1.release = 1;
			CA_msg->bam.t1.value = 0;

				
			for(i=1;i<j1939_msg->DataLength;i++)
 801096e:	7bfb      	ldrb	r3, [r7, #15]
 8010970:	3301      	adds	r3, #1
 8010972:	73fb      	strb	r3, [r7, #15]
 8010974:	7bfb      	ldrb	r3, [r7, #15]
 8010976:	687a      	ldr	r2, [r7, #4]
 8010978:	7912      	ldrb	r2, [r2, #4]
 801097a:	f3c2 0203 	ubfx	r2, r2, #0, #4
 801097e:	b2d2      	uxtb	r2, r2
 8010980:	4293      	cmp	r3, r2
 8010982:	dbe3      	blt.n	801094c <receiveData+0x48>
			{
				CA_msg->bamrcvdata[7*(j1939_msg->Data[0]-1)+i-1] = j1939_msg->Data[i];
			}
			
			if(j1939_msg->Data[0] >= CA_msg->bam.rcvpackets)
 8010984:	687b      	ldr	r3, [r7, #4]
 8010986:	795b      	ldrb	r3, [r3, #5]
 8010988:	b29a      	uxth	r2, r3
 801098a:	683b      	ldr	r3, [r7, #0]
 801098c:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 8010990:	429a      	cmp	r2, r3
 8010992:	d345      	bcc.n	8010a20 <receiveData+0x11c>
			{
				bamrxmsg.data = CA_msg->bamrcvdata;
 8010994:	683b      	ldr	r3, [r7, #0]
 8010996:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8010998:	4a85      	ldr	r2, [pc, #532]	; (8010bb0 <receiveData+0x2ac>)
 801099a:	6013      	str	r3, [r2, #0]
				j = 7 * CA_msg->bam.rcvpackets - 1;
 801099c:	683b      	ldr	r3, [r7, #0]
 801099e:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 80109a2:	461a      	mov	r2, r3
 80109a4:	00d2      	lsls	r2, r2, #3
 80109a6:	1ad3      	subs	r3, r2, r3
 80109a8:	b29b      	uxth	r3, r3
 80109aa:	3b01      	subs	r3, #1
 80109ac:	81bb      	strh	r3, [r7, #12]
				while(bamrxmsg.data[j] == 0xff)
 80109ae:	e002      	b.n	80109b6 <receiveData+0xb2>
					j--;
 80109b0:	89bb      	ldrh	r3, [r7, #12]
 80109b2:	3b01      	subs	r3, #1
 80109b4:	81bb      	strh	r3, [r7, #12]
			
			if(j1939_msg->Data[0] >= CA_msg->bam.rcvpackets)
			{
				bamrxmsg.data = CA_msg->bamrcvdata;
				j = 7 * CA_msg->bam.rcvpackets - 1;
				while(bamrxmsg.data[j] == 0xff)
 80109b6:	4b7e      	ldr	r3, [pc, #504]	; (8010bb0 <receiveData+0x2ac>)
 80109b8:	681a      	ldr	r2, [r3, #0]
 80109ba:	89bb      	ldrh	r3, [r7, #12]
 80109bc:	4413      	add	r3, r2
 80109be:	781b      	ldrb	r3, [r3, #0]
 80109c0:	2bff      	cmp	r3, #255	; 0xff
 80109c2:	d0f5      	beq.n	80109b0 <receiveData+0xac>
					j--;
				bamrxmsg.dp = bamrxmsg.data[j];
 80109c4:	4b7a      	ldr	r3, [pc, #488]	; (8010bb0 <receiveData+0x2ac>)
 80109c6:	681a      	ldr	r2, [r3, #0]
 80109c8:	89bb      	ldrh	r3, [r7, #12]
 80109ca:	4413      	add	r3, r2
 80109cc:	781a      	ldrb	r2, [r3, #0]
 80109ce:	4b78      	ldr	r3, [pc, #480]	; (8010bb0 <receiveData+0x2ac>)
 80109d0:	721a      	strb	r2, [r3, #8]
				bamrxmsg.PF = bamrxmsg.data[j-1];
 80109d2:	4b77      	ldr	r3, [pc, #476]	; (8010bb0 <receiveData+0x2ac>)
 80109d4:	681a      	ldr	r2, [r3, #0]
 80109d6:	89bb      	ldrh	r3, [r7, #12]
 80109d8:	3b01      	subs	r3, #1
 80109da:	4413      	add	r3, r2
 80109dc:	781a      	ldrb	r2, [r3, #0]
 80109de:	4b74      	ldr	r3, [pc, #464]	; (8010bb0 <receiveData+0x2ac>)
 80109e0:	71da      	strb	r2, [r3, #7]
				bamrxmsg.PS = bamrxmsg.data[j-2];
 80109e2:	4b73      	ldr	r3, [pc, #460]	; (8010bb0 <receiveData+0x2ac>)
 80109e4:	681a      	ldr	r2, [r3, #0]
 80109e6:	89bb      	ldrh	r3, [r7, #12]
 80109e8:	3b02      	subs	r3, #2
 80109ea:	4413      	add	r3, r2
 80109ec:	781a      	ldrb	r2, [r3, #0]
 80109ee:	4b70      	ldr	r3, [pc, #448]	; (8010bb0 <receiveData+0x2ac>)
 80109f0:	719a      	strb	r2, [r3, #6]
				bamrxmsg.size = j-2;
 80109f2:	89bb      	ldrh	r3, [r7, #12]
 80109f4:	3b02      	subs	r3, #2
 80109f6:	b29a      	uxth	r2, r3
 80109f8:	4b6d      	ldr	r3, [pc, #436]	; (8010bb0 <receiveData+0x2ac>)
 80109fa:	809a      	strh	r2, [r3, #4]
				rt_kprintf("\nbam receive %d data:\r\n", bamrxmsg.size);
 80109fc:	4b6c      	ldr	r3, [pc, #432]	; (8010bb0 <receiveData+0x2ac>)
 80109fe:	889b      	ldrh	r3, [r3, #4]
 8010a00:	486c      	ldr	r0, [pc, #432]	; (8010bb4 <receiveData+0x2b0>)
 8010a02:	4619      	mov	r1, r3
 8010a04:	f006 fb84 	bl	8017110 <rt_kprintf>
				bamAbort(CA_msg);
 8010a08:	6838      	ldr	r0, [r7, #0]
 8010a0a:	f000 fa37 	bl	8010e7c <bamAbort>
				osMessagePut(CA_msg->rxq, (unsigned long)&bamrxmsg, 0);
 8010a0e:	683b      	ldr	r3, [r7, #0]
 8010a10:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8010a12:	4a67      	ldr	r2, [pc, #412]	; (8010bb0 <receiveData+0x2ac>)
 8010a14:	4618      	mov	r0, r3
 8010a16:	4611      	mov	r1, r2
 8010a18:	2200      	movs	r2, #0
 8010a1a:	f008 fd1d 	bl	8019458 <osMessagePut>
 8010a1e:	e0c4      	b.n	8010baa <receiveData+0x2a6>
				*/

			}
			else
			{
					CA_msg->bam.t1.en = 1;
 8010a20:	683b      	ldr	r3, [r7, #0]
 8010a22:	2201      	movs	r2, #1
 8010a24:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
					CA_msg->bam.t1.release = 0;
 8010a28:	683b      	ldr	r3, [r7, #0]
 8010a2a:	2200      	movs	r2, #0
 8010a2c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
					CA_msg->bam.t1.value = T1TIMEOUT;
 8010a30:	683b      	ldr	r3, [r7, #0]
 8010a32:	f240 22ee 	movw	r2, #750	; 0x2ee
 8010a36:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
 8010a3a:	e0b6      	b.n	8010baa <receiveData+0x2a6>
		}

	}
	else
	{
		if((CA_msg->cm.cm_lock == 1) &&  (CA_msg->rcvdata != NULL))
 8010a3c:	683b      	ldr	r3, [r7, #0]
 8010a3e:	7f1b      	ldrb	r3, [r3, #28]
 8010a40:	2b01      	cmp	r3, #1
 8010a42:	f040 80b2 	bne.w	8010baa <receiveData+0x2a6>
 8010a46:	683b      	ldr	r3, [r7, #0]
 8010a48:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010a4a:	2b00      	cmp	r3, #0
 8010a4c:	f000 80ad 	beq.w	8010baa <receiveData+0x2a6>
		{
		
			CA_msg->cm.t1.en = 1;
 8010a50:	683b      	ldr	r3, [r7, #0]
 8010a52:	2201      	movs	r2, #1
 8010a54:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
			CA_msg->cm.t1.release = 1;
 8010a58:	683b      	ldr	r3, [r7, #0]
 8010a5a:	2201      	movs	r2, #1
 8010a5c:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
			CA_msg->cm.t1.value = 0;
 8010a60:	683b      	ldr	r3, [r7, #0]
 8010a62:	2200      	movs	r2, #0
 8010a64:	84da      	strh	r2, [r3, #38]	; 0x26


			CA_msg->cm.t2.en = 1;
 8010a66:	683b      	ldr	r3, [r7, #0]
 8010a68:	2201      	movs	r2, #1
 8010a6a:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
			CA_msg->cm.t2.release = 1;
 8010a6e:	683b      	ldr	r3, [r7, #0]
 8010a70:	2201      	movs	r2, #1
 8010a72:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
			CA_msg->cm.t2.value = 0;
 8010a76:	683b      	ldr	r3, [r7, #0]
 8010a78:	2200      	movs	r2, #0
 8010a7a:	855a      	strh	r2, [r3, #42]	; 0x2a



			for(i=1;i<j1939_msg->DataLength;i++)
 8010a7c:	2301      	movs	r3, #1
 8010a7e:	73fb      	strb	r3, [r7, #15]
 8010a80:	e013      	b.n	8010aaa <receiveData+0x1a6>
			{
				CA_msg->rcvdata[7*(j1939_msg->Data[0]-1)+i-1] = j1939_msg->Data[i];
 8010a82:	683b      	ldr	r3, [r7, #0]
 8010a84:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8010a86:	687b      	ldr	r3, [r7, #4]
 8010a88:	795b      	ldrb	r3, [r3, #5]
 8010a8a:	1e5a      	subs	r2, r3, #1
 8010a8c:	4613      	mov	r3, r2
 8010a8e:	00db      	lsls	r3, r3, #3
 8010a90:	1a9a      	subs	r2, r3, r2
 8010a92:	7bfb      	ldrb	r3, [r7, #15]
 8010a94:	4413      	add	r3, r2
 8010a96:	3b01      	subs	r3, #1
 8010a98:	440b      	add	r3, r1
 8010a9a:	7bfa      	ldrb	r2, [r7, #15]
 8010a9c:	6879      	ldr	r1, [r7, #4]
 8010a9e:	440a      	add	r2, r1
 8010aa0:	7952      	ldrb	r2, [r2, #5]
 8010aa2:	701a      	strb	r2, [r3, #0]
			CA_msg->cm.t2.release = 1;
			CA_msg->cm.t2.value = 0;



			for(i=1;i<j1939_msg->DataLength;i++)
 8010aa4:	7bfb      	ldrb	r3, [r7, #15]
 8010aa6:	3301      	adds	r3, #1
 8010aa8:	73fb      	strb	r3, [r7, #15]
 8010aaa:	7bfb      	ldrb	r3, [r7, #15]
 8010aac:	687a      	ldr	r2, [r7, #4]
 8010aae:	7912      	ldrb	r2, [r2, #4]
 8010ab0:	f3c2 0203 	ubfx	r2, r2, #0, #4
 8010ab4:	b2d2      	uxtb	r2, r2
 8010ab6:	4293      	cmp	r3, r2
 8010ab8:	dbe3      	blt.n	8010a82 <receiveData+0x17e>
			{
				CA_msg->rcvdata[7*(j1939_msg->Data[0]-1)+i-1] = j1939_msg->Data[i];
			}

			rt_kprintf("Data[0] = %d, rcvpackets = %d\r\n", j1939_msg->Data[0], CA_msg->cm.rcvpackets);
 8010aba:	687b      	ldr	r3, [r7, #4]
 8010abc:	795b      	ldrb	r3, [r3, #5]
 8010abe:	461a      	mov	r2, r3
 8010ac0:	683b      	ldr	r3, [r7, #0]
 8010ac2:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8010ac4:	483c      	ldr	r0, [pc, #240]	; (8010bb8 <receiveData+0x2b4>)
 8010ac6:	4611      	mov	r1, r2
 8010ac8:	461a      	mov	r2, r3
 8010aca:	f006 fb21 	bl	8017110 <rt_kprintf>


			if(j1939_msg->Data[0] >= CA_msg->cm.rcvpackets)
 8010ace:	687b      	ldr	r3, [r7, #4]
 8010ad0:	795b      	ldrb	r3, [r3, #5]
 8010ad2:	b29a      	uxth	r2, r3
 8010ad4:	683b      	ldr	r3, [r7, #0]
 8010ad6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8010ad8:	429a      	cmp	r2, r3
 8010ada:	d345      	bcc.n	8010b68 <receiveData+0x264>
			{
				rxmsg.data = CA_msg->rcvdata;
 8010adc:	683b      	ldr	r3, [r7, #0]
 8010ade:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010ae0:	4a36      	ldr	r2, [pc, #216]	; (8010bbc <receiveData+0x2b8>)
 8010ae2:	6013      	str	r3, [r2, #0]
				j = 7 * CA_msg->cm.rcvpackets - 1;
 8010ae4:	683b      	ldr	r3, [r7, #0]
 8010ae6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8010ae8:	461a      	mov	r2, r3
 8010aea:	00d2      	lsls	r2, r2, #3
 8010aec:	1ad3      	subs	r3, r2, r3
 8010aee:	b29b      	uxth	r3, r3
 8010af0:	3b01      	subs	r3, #1
 8010af2:	81bb      	strh	r3, [r7, #12]
				while(rxmsg.data[j] == 0xff)
 8010af4:	e002      	b.n	8010afc <receiveData+0x1f8>
					j--;
 8010af6:	89bb      	ldrh	r3, [r7, #12]
 8010af8:	3b01      	subs	r3, #1
 8010afa:	81bb      	strh	r3, [r7, #12]

			if(j1939_msg->Data[0] >= CA_msg->cm.rcvpackets)
			{
				rxmsg.data = CA_msg->rcvdata;
				j = 7 * CA_msg->cm.rcvpackets - 1;
				while(rxmsg.data[j] == 0xff)
 8010afc:	4b2f      	ldr	r3, [pc, #188]	; (8010bbc <receiveData+0x2b8>)
 8010afe:	681a      	ldr	r2, [r3, #0]
 8010b00:	89bb      	ldrh	r3, [r7, #12]
 8010b02:	4413      	add	r3, r2
 8010b04:	781b      	ldrb	r3, [r3, #0]
 8010b06:	2bff      	cmp	r3, #255	; 0xff
 8010b08:	d0f5      	beq.n	8010af6 <receiveData+0x1f2>
					j--;
				rxmsg.dp = rxmsg.data[j];
 8010b0a:	4b2c      	ldr	r3, [pc, #176]	; (8010bbc <receiveData+0x2b8>)
 8010b0c:	681a      	ldr	r2, [r3, #0]
 8010b0e:	89bb      	ldrh	r3, [r7, #12]
 8010b10:	4413      	add	r3, r2
 8010b12:	781a      	ldrb	r2, [r3, #0]
 8010b14:	4b29      	ldr	r3, [pc, #164]	; (8010bbc <receiveData+0x2b8>)
 8010b16:	721a      	strb	r2, [r3, #8]
				rxmsg.PF = rxmsg.data[j-1];
 8010b18:	4b28      	ldr	r3, [pc, #160]	; (8010bbc <receiveData+0x2b8>)
 8010b1a:	681a      	ldr	r2, [r3, #0]
 8010b1c:	89bb      	ldrh	r3, [r7, #12]
 8010b1e:	3b01      	subs	r3, #1
 8010b20:	4413      	add	r3, r2
 8010b22:	781a      	ldrb	r2, [r3, #0]
 8010b24:	4b25      	ldr	r3, [pc, #148]	; (8010bbc <receiveData+0x2b8>)
 8010b26:	71da      	strb	r2, [r3, #7]
				rxmsg.PS = rxmsg.data[j-2];
 8010b28:	4b24      	ldr	r3, [pc, #144]	; (8010bbc <receiveData+0x2b8>)
 8010b2a:	681a      	ldr	r2, [r3, #0]
 8010b2c:	89bb      	ldrh	r3, [r7, #12]
 8010b2e:	3b02      	subs	r3, #2
 8010b30:	4413      	add	r3, r2
 8010b32:	781a      	ldrb	r2, [r3, #0]
 8010b34:	4b21      	ldr	r3, [pc, #132]	; (8010bbc <receiveData+0x2b8>)
 8010b36:	719a      	strb	r2, [r3, #6]
				rxmsg.size = j-2;
 8010b38:	89bb      	ldrh	r3, [r7, #12]
 8010b3a:	3b02      	subs	r3, #2
 8010b3c:	b29a      	uxth	r2, r3
 8010b3e:	4b1f      	ldr	r3, [pc, #124]	; (8010bbc <receiveData+0x2b8>)
 8010b40:	809a      	strh	r2, [r3, #4]
				rt_kprintf("\nDT receive %d data:\r\n", rxmsg.size);
 8010b42:	4b1e      	ldr	r3, [pc, #120]	; (8010bbc <receiveData+0x2b8>)
 8010b44:	889b      	ldrh	r3, [r3, #4]
 8010b46:	481e      	ldr	r0, [pc, #120]	; (8010bc0 <receiveData+0x2bc>)
 8010b48:	4619      	mov	r1, r3
 8010b4a:	f006 fae1 	bl	8017110 <rt_kprintf>
				osMessagePut(CA_msg->rxq, (unsigned long)&rxmsg, 0);
 8010b4e:	683b      	ldr	r3, [r7, #0]
 8010b50:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8010b52:	4a1a      	ldr	r2, [pc, #104]	; (8010bbc <receiveData+0x2b8>)
 8010b54:	4618      	mov	r0, r3
 8010b56:	4611      	mov	r1, r2
 8010b58:	2200      	movs	r2, #0
 8010b5a:	f008 fc7d 	bl	8019458 <osMessagePut>
				
				//if(j1939_msg->PDUSpecific != J1939_GLOBAL_ADDRESS)
				//{
				sendEndofMsgACK(j1939_msg ,CA_msg);
 8010b5e:	6878      	ldr	r0, [r7, #4]
 8010b60:	6839      	ldr	r1, [r7, #0]
 8010b62:	f7ff fe75 	bl	8010850 <sendEndofMsgACK>
 8010b66:	e020      	b.n	8010baa <receiveData+0x2a6>
				//}
			}
			else 
			{
				j1939_msg->PDUFormat = J1939_PF_TP_CM;
 8010b68:	687b      	ldr	r3, [r7, #4]
 8010b6a:	22ec      	movs	r2, #236	; 0xec
 8010b6c:	705a      	strb	r2, [r3, #1]
				j1939_msg->Priority = 7;
 8010b6e:	687a      	ldr	r2, [r7, #4]
 8010b70:	7813      	ldrb	r3, [r2, #0]
 8010b72:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 8010b76:	7013      	strb	r3, [r2, #0]
				j1939_msg->DataPage = 0;
 8010b78:	687a      	ldr	r2, [r7, #4]
 8010b7a:	7813      	ldrb	r3, [r2, #0]
 8010b7c:	f36f 03c3 	bfc	r3, #3, #1
 8010b80:	7013      	strb	r3, [r2, #0]
				j1939_msg->edp = 0;
 8010b82:	687a      	ldr	r2, [r7, #4]
 8010b84:	7813      	ldrb	r3, [r2, #0]
 8010b86:	f36f 1304 	bfc	r3, #4, #1
 8010b8a:	7013      	strb	r3, [r2, #0]
				j1939_msg->DataLength = 8;
 8010b8c:	687a      	ldr	r2, [r7, #4]
 8010b8e:	7913      	ldrb	r3, [r2, #4]
 8010b90:	2108      	movs	r1, #8
 8010b92:	f361 0303 	bfi	r3, r1, #0, #4
 8010b96:	7113      	strb	r3, [r2, #4]
		
				sendCTS(j1939_msg,CA_msg,j1939_msg->Data[0]+1,1);
 8010b98:	687b      	ldr	r3, [r7, #4]
 8010b9a:	795b      	ldrb	r3, [r3, #5]
 8010b9c:	3301      	adds	r3, #1
 8010b9e:	6878      	ldr	r0, [r7, #4]
 8010ba0:	6839      	ldr	r1, [r7, #0]
 8010ba2:	461a      	mov	r2, r3
 8010ba4:	2301      	movs	r3, #1
 8010ba6:	f7ff fd21 	bl	80105ec <sendCTS>
			}
		}
		#endif
		}
	}
}
 8010baa:	3710      	adds	r7, #16
 8010bac:	46bd      	mov	sp, r7
 8010bae:	bd80      	pop	{r7, pc}
 8010bb0:	200107f8 	.word	0x200107f8
 8010bb4:	08028728 	.word	0x08028728
 8010bb8:	08028740 	.word	0x08028740
 8010bbc:	20010804 	.word	0x20010804
 8010bc0:	08028760 	.word	0x08028760

08010bc4 <responseEndofMsgACK>:

void responseEndofMsgACK(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 8010bc4:	b580      	push	{r7, lr}
 8010bc6:	b082      	sub	sp, #8
 8010bc8:	af00      	add	r7, sp, #0
 8010bca:	6078      	str	r0, [r7, #4]
 8010bcc:	6039      	str	r1, [r7, #0]
	//if(CA_msg->cm.sendcomp == 1)
	//{
		rt_kprintf("receive endOfMsgAck\r\n");
 8010bce:	4810      	ldr	r0, [pc, #64]	; (8010c10 <responseEndofMsgACK+0x4c>)
 8010bd0:	f006 fa9e 	bl	8017110 <rt_kprintf>
		//osEnter_critical();
		if(CA_msg->rcvdata != NULL)
 8010bd4:	683b      	ldr	r3, [r7, #0]
 8010bd6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010bd8:	2b00      	cmp	r3, #0
 8010bda:	d007      	beq.n	8010bec <responseEndofMsgACK+0x28>
		{
			free(CA_msg->rcvdata);
 8010bdc:	683b      	ldr	r3, [r7, #0]
 8010bde:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010be0:	4618      	mov	r0, r3
 8010be2:	f011 fd43 	bl	802266c <free>
			CA_msg->rcvdata = NULL;
 8010be6:	683b      	ldr	r3, [r7, #0]
 8010be8:	2200      	movs	r2, #0
 8010bea:	655a      	str	r2, [r3, #84]	; 0x54
		}
		//osExit_critical();
		CA_msg->cm.cm_lock = 0;
 8010bec:	683b      	ldr	r3, [r7, #0]
 8010bee:	2200      	movs	r2, #0
 8010bf0:	771a      	strb	r2, [r3, #28]
		CA_msg->cm.nextnum = 0;
 8010bf2:	683b      	ldr	r3, [r7, #0]
 8010bf4:	2200      	movs	r2, #0
 8010bf6:	831a      	strh	r2, [r3, #24]
		CA_msg->cm.sendcomp = 0;
 8010bf8:	683b      	ldr	r3, [r7, #0]
 8010bfa:	2200      	movs	r2, #0
 8010bfc:	775a      	strb	r2, [r3, #29]
		CA_msg->cm.sendpackets = 0;
 8010bfe:	683b      	ldr	r3, [r7, #0]
 8010c00:	2200      	movs	r2, #0
 8010c02:	82da      	strh	r2, [r3, #22]
		CA_msg->sendbytes = 0;
 8010c04:	683b      	ldr	r3, [r7, #0]
 8010c06:	2200      	movs	r2, #0
 8010c08:	829a      	strh	r2, [r3, #20]
	//}
}
 8010c0a:	3708      	adds	r7, #8
 8010c0c:	46bd      	mov	sp, r7
 8010c0e:	bd80      	pop	{r7, pc}
 8010c10:	08028778 	.word	0x08028778

08010c14 <responseBAM>:
void responseBAM(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 8010c14:	b580      	push	{r7, lr}
 8010c16:	b082      	sub	sp, #8
 8010c18:	af00      	add	r7, sp, #0
 8010c1a:	6078      	str	r0, [r7, #4]
 8010c1c:	6039      	str	r1, [r7, #0]
	if(j1939_msg->PDUSpecific == J1939_GLOBAL_ADDRESS)
 8010c1e:	687b      	ldr	r3, [r7, #4]
 8010c20:	789b      	ldrb	r3, [r3, #2]
 8010c22:	2bff      	cmp	r3, #255	; 0xff
 8010c24:	d13e      	bne.n	8010ca4 <responseBAM+0x90>
	{
		rt_kprintf("receive bam\r\n");
 8010c26:	4821      	ldr	r0, [pc, #132]	; (8010cac <responseBAM+0x98>)
 8010c28:	f006 fa72 	bl	8017110 <rt_kprintf>
		if(checkRes() == RC_SUCCESS && CA_msg->bam.cm_lock == 0)
 8010c2c:	f7ff fcd6 	bl	80105dc <checkRes>
 8010c30:	4603      	mov	r3, r0
 8010c32:	2b00      	cmp	r3, #0
 8010c34:	d136      	bne.n	8010ca4 <responseBAM+0x90>
 8010c36:	683b      	ldr	r3, [r7, #0]
 8010c38:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 8010c3c:	2b00      	cmp	r3, #0
 8010c3e:	d131      	bne.n	8010ca4 <responseBAM+0x90>
		{
			CA_msg->bam.rcvpackets = j1939_msg->Data[3];
 8010c40:	687b      	ldr	r3, [r7, #4]
 8010c42:	7a1b      	ldrb	r3, [r3, #8]
 8010c44:	b29a      	uxth	r2, r3
 8010c46:	683b      	ldr	r3, [r7, #0]
 8010c48:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
			CA_msg->bam.rcvbytes = j1939_msg->Data[2]*256+j1939_msg->Data[1];
 8010c4c:	687b      	ldr	r3, [r7, #4]
 8010c4e:	79db      	ldrb	r3, [r3, #7]
 8010c50:	b29b      	uxth	r3, r3
 8010c52:	021b      	lsls	r3, r3, #8
 8010c54:	b29a      	uxth	r2, r3
 8010c56:	687b      	ldr	r3, [r7, #4]
 8010c58:	799b      	ldrb	r3, [r3, #6]
 8010c5a:	b29b      	uxth	r3, r3
 8010c5c:	4413      	add	r3, r2
 8010c5e:	b29a      	uxth	r2, r3
 8010c60:	683b      	ldr	r3, [r7, #0]
 8010c62:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
			CA_msg->bamrcvdata = (unsigned char *)malloc(7 * CA_msg->bam.rcvpackets );
 8010c66:	683b      	ldr	r3, [r7, #0]
 8010c68:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 8010c6c:	461a      	mov	r2, r3
 8010c6e:	4613      	mov	r3, r2
 8010c70:	00db      	lsls	r3, r3, #3
 8010c72:	1a9b      	subs	r3, r3, r2
 8010c74:	4618      	mov	r0, r3
 8010c76:	f011 fcf1 	bl	802265c <malloc>
 8010c7a:	4603      	mov	r3, r0
 8010c7c:	461a      	mov	r2, r3
 8010c7e:	683b      	ldr	r3, [r7, #0]
 8010c80:	659a      	str	r2, [r3, #88]	; 0x58
			CA_msg->bam.cm_lock = 1;
 8010c82:	683b      	ldr	r3, [r7, #0]
 8010c84:	2201      	movs	r2, #1
 8010c86:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
			CA_msg->bam.t1.en = 1;
 8010c8a:	683b      	ldr	r3, [r7, #0]
 8010c8c:	2201      	movs	r2, #1
 8010c8e:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
			CA_msg->bam.t1.release = 0;
 8010c92:	683b      	ldr	r3, [r7, #0]
 8010c94:	2200      	movs	r2, #0
 8010c96:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			CA_msg->bam.t1.value = T1TIMEOUT;
 8010c9a:	683b      	ldr	r3, [r7, #0]
 8010c9c:	f240 22ee 	movw	r2, #750	; 0x2ee
 8010ca0:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
		}
	}
}
 8010ca4:	3708      	adds	r7, #8
 8010ca6:	46bd      	mov	sp, r7
 8010ca8:	bd80      	pop	{r7, pc}
 8010caa:	bf00      	nop
 8010cac:	08028790 	.word	0x08028790

08010cb0 <responseAbort>:

unsigned char responseAbort(J1939_msg_t j1939_msg ,CA_Msg_t CA_msg)
{
 8010cb0:	b580      	push	{r7, lr}
 8010cb2:	b084      	sub	sp, #16
 8010cb4:	af00      	add	r7, sp, #0
 8010cb6:	6078      	str	r0, [r7, #4]
 8010cb8:	6039      	str	r1, [r7, #0]
	struct J1939_CM *tempCm;
	
	if(CA_msg->rcvdata != NULL)
 8010cba:	683b      	ldr	r3, [r7, #0]
 8010cbc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010cbe:	2b00      	cmp	r3, #0
 8010cc0:	d007      	beq.n	8010cd2 <responseAbort+0x22>
	{
		free(CA_msg->rcvdata);
 8010cc2:	683b      	ldr	r3, [r7, #0]
 8010cc4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010cc6:	4618      	mov	r0, r3
 8010cc8:	f011 fcd0 	bl	802266c <free>
		CA_msg->rcvdata = NULL;
 8010ccc:	683b      	ldr	r3, [r7, #0]
 8010cce:	2200      	movs	r2, #0
 8010cd0:	655a      	str	r2, [r3, #84]	; 0x54
	}
	tempCm = &(CA_msg->cm);
 8010cd2:	683b      	ldr	r3, [r7, #0]
 8010cd4:	3316      	adds	r3, #22
 8010cd6:	60fb      	str	r3, [r7, #12]
	memset(tempCm,0,sizeof(struct J1939_CM));
 8010cd8:	68f8      	ldr	r0, [r7, #12]
 8010cda:	2100      	movs	r1, #0
 8010cdc:	222a      	movs	r2, #42	; 0x2a
 8010cde:	f011 fccd 	bl	802267c <memset>
	
	return RC_SUCCESS;
 8010ce2:	2300      	movs	r3, #0
}
 8010ce4:	4618      	mov	r0, r3
 8010ce6:	3710      	adds	r7, #16
 8010ce8:	46bd      	mov	sp, r7
 8010cea:	bd80      	pop	{r7, pc}

08010cec <receiveMessage>:
void receiveMessage()
{
 8010cec:	b580      	push	{r7, lr}
 8010cee:	b084      	sub	sp, #16
 8010cf0:	af00      	add	r7, sp, #0
	static struct rx_Message rxmsg;
	struct CA_node *canode;
	list_node_t node;
	int i;

	while(readCan(&j1939_msg) == RC_SUCCESS)
 8010cf2:	e0ae      	b.n	8010e52 <receiveMessage+0x166>
	{
		if(j1939_msg.PDUFormat <240)
 8010cf4:	4b5c      	ldr	r3, [pc, #368]	; (8010e68 <receiveMessage+0x17c>)
 8010cf6:	785b      	ldrb	r3, [r3, #1]
 8010cf8:	2bef      	cmp	r3, #239	; 0xef
 8010cfa:	f200 809b 	bhi.w	8010e34 <receiveMessage+0x148>
		{
			if (j1939_msg.PDUSpecific == J1939_GLOBAL_ADDRESS) 
 8010cfe:	4b5a      	ldr	r3, [pc, #360]	; (8010e68 <receiveMessage+0x17c>)
 8010d00:	789b      	ldrb	r3, [r3, #2]
 8010d02:	2bff      	cmp	r3, #255	; 0xff
 8010d04:	d10e      	bne.n	8010d24 <receiveMessage+0x38>
			{
				node = calist.head.next;
 8010d06:	4b59      	ldr	r3, [pc, #356]	; (8010e6c <receiveMessage+0x180>)
 8010d08:	685b      	ldr	r3, [r3, #4]
 8010d0a:	60bb      	str	r3, [r7, #8]
				if(node != &(calist.head))
 8010d0c:	68bb      	ldr	r3, [r7, #8]
 8010d0e:	4a58      	ldr	r2, [pc, #352]	; (8010e70 <receiveMessage+0x184>)
 8010d10:	4293      	cmp	r3, r2
 8010d12:	d006      	beq.n	8010d22 <receiveMessage+0x36>
				{
					canode = rt_list_entry(node, struct CA_node, node);
 8010d14:	68bb      	ldr	r3, [r7, #8]
 8010d16:	3b04      	subs	r3, #4
 8010d18:	607b      	str	r3, [r7, #4]
					CA_msg = canode->ca_msg;
 8010d1a:	687b      	ldr	r3, [r7, #4]
 8010d1c:	681b      	ldr	r3, [r3, #0]
 8010d1e:	60fb      	str	r3, [r7, #12]
 8010d20:	e00b      	b.n	8010d3a <receiveMessage+0x4e>
				}
				else 
					break;
 8010d22:	e09d      	b.n	8010e60 <receiveMessage+0x174>
			}
			else if ((CA_msg = Addr_FindCA(&calist,j1939_msg.PDUSpecific)) != NULL)
 8010d24:	4b50      	ldr	r3, [pc, #320]	; (8010e68 <receiveMessage+0x17c>)
 8010d26:	789b      	ldrb	r3, [r3, #2]
 8010d28:	4850      	ldr	r0, [pc, #320]	; (8010e6c <receiveMessage+0x180>)
 8010d2a:	4619      	mov	r1, r3
 8010d2c:	f000 fb24 	bl	8011378 <Addr_FindCA>
 8010d30:	60f8      	str	r0, [r7, #12]
 8010d32:	68fb      	ldr	r3, [r7, #12]
 8010d34:	2b00      	cmp	r3, #0
 8010d36:	d100      	bne.n	8010d3a <receiveMessage+0x4e>
			{
			}
			else
				continue;
 8010d38:	e08b      	b.n	8010e52 <receiveMessage+0x166>

			switch (j1939_msg.PDUFormat)
 8010d3a:	4b4b      	ldr	r3, [pc, #300]	; (8010e68 <receiveMessage+0x17c>)
 8010d3c:	785b      	ldrb	r3, [r3, #1]
 8010d3e:	3bea      	subs	r3, #234	; 0xea
 8010d40:	2b04      	cmp	r3, #4
 8010d42:	d852      	bhi.n	8010dea <receiveMessage+0xfe>
 8010d44:	a201      	add	r2, pc, #4	; (adr r2, 8010d4c <receiveMessage+0x60>)
 8010d46:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8010d4a:	bf00      	nop
 8010d4c:	08010dbf 	.word	0x08010dbf
 8010d50:	08010db5 	.word	0x08010db5
 8010d54:	08010d61 	.word	0x08010d61
 8010d58:	08010deb 	.word	0x08010deb
 8010d5c:	08010de1 	.word	0x08010de1
			{
				case J1939_PF_TP_CM:
					switch (j1939_msg.Data[0])
 8010d60:	4b41      	ldr	r3, [pc, #260]	; (8010e68 <receiveMessage+0x17c>)
 8010d62:	795b      	ldrb	r3, [r3, #5]
 8010d64:	2b13      	cmp	r3, #19
 8010d66:	d015      	beq.n	8010d94 <receiveMessage+0xa8>
 8010d68:	2b13      	cmp	r3, #19
 8010d6a:	dc04      	bgt.n	8010d76 <receiveMessage+0x8a>
 8010d6c:	2b10      	cmp	r3, #16
 8010d6e:	d007      	beq.n	8010d80 <receiveMessage+0x94>
 8010d70:	2b11      	cmp	r3, #17
 8010d72:	d00a      	beq.n	8010d8a <receiveMessage+0x9e>
							break;
						case J1939_CONNABORT_CONTROL_BYTE:
							responseAbort(&j1939_msg,CA_msg);
							break;
						default:
							goto sendmsg;
 8010d74:	e039      	b.n	8010dea <receiveMessage+0xfe>
				continue;

			switch (j1939_msg.PDUFormat)
			{
				case J1939_PF_TP_CM:
					switch (j1939_msg.Data[0])
 8010d76:	2b20      	cmp	r3, #32
 8010d78:	d011      	beq.n	8010d9e <receiveMessage+0xb2>
 8010d7a:	2bff      	cmp	r3, #255	; 0xff
 8010d7c:	d014      	beq.n	8010da8 <receiveMessage+0xbc>
							break;
						case J1939_CONNABORT_CONTROL_BYTE:
							responseAbort(&j1939_msg,CA_msg);
							break;
						default:
							goto sendmsg;
 8010d7e:	e034      	b.n	8010dea <receiveMessage+0xfe>
			{
				case J1939_PF_TP_CM:
					switch (j1939_msg.Data[0])
					{
						case J1939_RTS_CONTROL_BYTE:
							response_RTS(&j1939_msg,CA_msg);
 8010d80:	4839      	ldr	r0, [pc, #228]	; (8010e68 <receiveMessage+0x17c>)
 8010d82:	68f9      	ldr	r1, [r7, #12]
 8010d84:	f7ff fca2 	bl	80106cc <response_RTS>
							break;
 8010d88:	e013      	b.n	8010db2 <receiveMessage+0xc6>
						case J1939_CTS_CONTROL_BYTE:
							response_CTS(&j1939_msg,CA_msg);
 8010d8a:	4837      	ldr	r0, [pc, #220]	; (8010e68 <receiveMessage+0x17c>)
 8010d8c:	68f9      	ldr	r1, [r7, #12]
 8010d8e:	f7ff fd03 	bl	8010798 <response_CTS>
							break;
 8010d92:	e00e      	b.n	8010db2 <receiveMessage+0xc6>
						case J1939_EOMACK_CONTROL_BYTE:
							responseEndofMsgACK(&j1939_msg,CA_msg);
 8010d94:	4834      	ldr	r0, [pc, #208]	; (8010e68 <receiveMessage+0x17c>)
 8010d96:	68f9      	ldr	r1, [r7, #12]
 8010d98:	f7ff ff14 	bl	8010bc4 <responseEndofMsgACK>
							break;
 8010d9c:	e009      	b.n	8010db2 <receiveMessage+0xc6>
						case J1939_BAM_CONTROL_BYTE:
							responseBAM(&j1939_msg,CA_msg);
 8010d9e:	4832      	ldr	r0, [pc, #200]	; (8010e68 <receiveMessage+0x17c>)
 8010da0:	68f9      	ldr	r1, [r7, #12]
 8010da2:	f7ff ff37 	bl	8010c14 <responseBAM>
							break;
 8010da6:	e004      	b.n	8010db2 <receiveMessage+0xc6>
						case J1939_CONNABORT_CONTROL_BYTE:
							responseAbort(&j1939_msg,CA_msg);
 8010da8:	482f      	ldr	r0, [pc, #188]	; (8010e68 <receiveMessage+0x17c>)
 8010daa:	68f9      	ldr	r1, [r7, #12]
 8010dac:	f7ff ff80 	bl	8010cb0 <responseAbort>
							break;
 8010db0:	bf00      	nop
						default:
							goto sendmsg;
					}
					break;
 8010db2:	e03e      	b.n	8010e32 <receiveMessage+0x146>
				case J1939_PF_DT:
					receiveData(&j1939_msg,CA_msg);
 8010db4:	482c      	ldr	r0, [pc, #176]	; (8010e68 <receiveMessage+0x17c>)
 8010db6:	68f9      	ldr	r1, [r7, #12]
 8010db8:	f7ff fda4 	bl	8010904 <receiveData>
					break;
 8010dbc:	e039      	b.n	8010e32 <receiveMessage+0x146>
				case J1939_PF_REQUEST:
					if ((j1939_msg.Data[0] == J1939_PGN0_REQ_ADDRESS_CLAIM) &&
 8010dbe:	4b2a      	ldr	r3, [pc, #168]	; (8010e68 <receiveMessage+0x17c>)
 8010dc0:	795b      	ldrb	r3, [r3, #5]
 8010dc2:	2b00      	cmp	r3, #0
 8010dc4:	d111      	bne.n	8010dea <receiveMessage+0xfe>
						(j1939_msg.Data[1] == J1939_PGN1_REQ_ADDRESS_CLAIM) &&
 8010dc6:	4b28      	ldr	r3, [pc, #160]	; (8010e68 <receiveMessage+0x17c>)
 8010dc8:	799b      	ldrb	r3, [r3, #6]
					break;
				case J1939_PF_DT:
					receiveData(&j1939_msg,CA_msg);
					break;
				case J1939_PF_REQUEST:
					if ((j1939_msg.Data[0] == J1939_PGN0_REQ_ADDRESS_CLAIM) &&
 8010dca:	2bee      	cmp	r3, #238	; 0xee
 8010dcc:	d10d      	bne.n	8010dea <receiveMessage+0xfe>
						(j1939_msg.Data[1] == J1939_PGN1_REQ_ADDRESS_CLAIM) &&
						(j1939_msg.Data[2] == J1939_PGN2_REQ_ADDRESS_CLAIM))
 8010dce:	4b26      	ldr	r3, [pc, #152]	; (8010e68 <receiveMessage+0x17c>)
 8010dd0:	79db      	ldrb	r3, [r3, #7]
				case J1939_PF_DT:
					receiveData(&j1939_msg,CA_msg);
					break;
				case J1939_PF_REQUEST:
					if ((j1939_msg.Data[0] == J1939_PGN0_REQ_ADDRESS_CLAIM) &&
						(j1939_msg.Data[1] == J1939_PGN1_REQ_ADDRESS_CLAIM) &&
 8010dd2:	2b00      	cmp	r3, #0
 8010dd4:	d109      	bne.n	8010dea <receiveMessage+0xfe>
						(j1939_msg.Data[2] == J1939_PGN2_REQ_ADDRESS_CLAIM))
						J1939_RequestForAddressClaimHandling(&j1939_msg,CA_msg);
 8010dd6:	4824      	ldr	r0, [pc, #144]	; (8010e68 <receiveMessage+0x17c>)
 8010dd8:	68f9      	ldr	r1, [r7, #12]
 8010dda:	f000 fafb 	bl	80113d4 <J1939_RequestForAddressClaimHandling>
					else 
						goto sendmsg;
					break;
 8010dde:	e028      	b.n	8010e32 <receiveMessage+0x146>
				case J1939_PF_ADDRESS_CLAIMED:
					J1939_AddressClaimHandling( &j1939_msg,CA_msg );
 8010de0:	4821      	ldr	r0, [pc, #132]	; (8010e68 <receiveMessage+0x17c>)
 8010de2:	68f9      	ldr	r1, [r7, #12]
 8010de4:	f000 fb6c 	bl	80114c0 <J1939_AddressClaimHandling>
					break;
 8010de8:	e023      	b.n	8010e32 <receiveMessage+0x146>

				default:
	sendmsg:
				
				rxmsg.data = &j1939_msg.Data;
 8010dea:	4b22      	ldr	r3, [pc, #136]	; (8010e74 <receiveMessage+0x188>)
 8010dec:	4a22      	ldr	r2, [pc, #136]	; (8010e78 <receiveMessage+0x18c>)
 8010dee:	601a      	str	r2, [r3, #0]
				rxmsg.size = j1939_msg.DataLength;
 8010df0:	4b1d      	ldr	r3, [pc, #116]	; (8010e68 <receiveMessage+0x17c>)
 8010df2:	791b      	ldrb	r3, [r3, #4]
 8010df4:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8010df8:	b2db      	uxtb	r3, r3
 8010dfa:	b29a      	uxth	r2, r3
 8010dfc:	4b1d      	ldr	r3, [pc, #116]	; (8010e74 <receiveMessage+0x188>)
 8010dfe:	809a      	strh	r2, [r3, #4]
				rxmsg.dp = j1939_msg.DataPage;
 8010e00:	4b19      	ldr	r3, [pc, #100]	; (8010e68 <receiveMessage+0x17c>)
 8010e02:	781b      	ldrb	r3, [r3, #0]
 8010e04:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8010e08:	b2db      	uxtb	r3, r3
 8010e0a:	461a      	mov	r2, r3
 8010e0c:	4b19      	ldr	r3, [pc, #100]	; (8010e74 <receiveMessage+0x188>)
 8010e0e:	721a      	strb	r2, [r3, #8]
				rxmsg.PF = j1939_msg.PDUFormat;
 8010e10:	4b15      	ldr	r3, [pc, #84]	; (8010e68 <receiveMessage+0x17c>)
 8010e12:	785a      	ldrb	r2, [r3, #1]
 8010e14:	4b17      	ldr	r3, [pc, #92]	; (8010e74 <receiveMessage+0x188>)
 8010e16:	71da      	strb	r2, [r3, #7]
				rxmsg.PS = j1939_msg.PDUSpecific;
 8010e18:	4b13      	ldr	r3, [pc, #76]	; (8010e68 <receiveMessage+0x17c>)
 8010e1a:	789a      	ldrb	r2, [r3, #2]
 8010e1c:	4b15      	ldr	r3, [pc, #84]	; (8010e74 <receiveMessage+0x188>)
 8010e1e:	719a      	strb	r2, [r3, #6]
				
				osMessagePut(CA_msg->rxq, (unsigned long)&rxmsg, 0);
 8010e20:	68fb      	ldr	r3, [r7, #12]
 8010e22:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8010e24:	4a13      	ldr	r2, [pc, #76]	; (8010e74 <receiveMessage+0x188>)
 8010e26:	4618      	mov	r0, r3
 8010e28:	4611      	mov	r1, r2
 8010e2a:	2200      	movs	r2, #0
 8010e2c:	f008 fb14 	bl	8019458 <osMessagePut>
				break;
 8010e30:	bf00      	nop
 8010e32:	e00e      	b.n	8010e52 <receiveMessage+0x166>
			}
		}
		else 
		{
			
			node = calist.head.next;
 8010e34:	4b0d      	ldr	r3, [pc, #52]	; (8010e6c <receiveMessage+0x180>)
 8010e36:	685b      	ldr	r3, [r3, #4]
 8010e38:	60bb      	str	r3, [r7, #8]
			if(node != &(calist.head))
 8010e3a:	68bb      	ldr	r3, [r7, #8]
 8010e3c:	4a0c      	ldr	r2, [pc, #48]	; (8010e70 <receiveMessage+0x184>)
 8010e3e:	4293      	cmp	r3, r2
 8010e40:	d006      	beq.n	8010e50 <receiveMessage+0x164>
			{
				canode = rt_list_entry(node, struct CA_node, node);
 8010e42:	68bb      	ldr	r3, [r7, #8]
 8010e44:	3b04      	subs	r3, #4
 8010e46:	607b      	str	r3, [r7, #4]
				CA_msg = canode->ca_msg;
 8010e48:	687b      	ldr	r3, [r7, #4]
 8010e4a:	681b      	ldr	r3, [r3, #0]
 8010e4c:	60fb      	str	r3, [r7, #12]
			}
			else 
				break;
			
			goto sendmsg;
 8010e4e:	e7cc      	b.n	8010dea <receiveMessage+0xfe>
			{
				canode = rt_list_entry(node, struct CA_node, node);
				CA_msg = canode->ca_msg;
			}
			else 
				break;
 8010e50:	e006      	b.n	8010e60 <receiveMessage+0x174>
	static struct rx_Message rxmsg;
	struct CA_node *canode;
	list_node_t node;
	int i;

	while(readCan(&j1939_msg) == RC_SUCCESS)
 8010e52:	4805      	ldr	r0, [pc, #20]	; (8010e68 <receiveMessage+0x17c>)
 8010e54:	f000 fc92 	bl	801177c <readCan>
 8010e58:	4603      	mov	r3, r0
 8010e5a:	2b00      	cmp	r3, #0
 8010e5c:	f43f af4a 	beq.w	8010cf4 <receiveMessage+0x8>
				break;
			
			goto sendmsg;
		}
	}
}
 8010e60:	3710      	adds	r7, #16
 8010e62:	46bd      	mov	sp, r7
 8010e64:	bd80      	pop	{r7, pc}
 8010e66:	bf00      	nop
 8010e68:	20010810 	.word	0x20010810
 8010e6c:	200127a0 	.word	0x200127a0
 8010e70:	200127a4 	.word	0x200127a4
 8010e74:	20010820 	.word	0x20010820
 8010e78:	20010815 	.word	0x20010815

08010e7c <bamAbort>:

void bamAbort(CA_Msg_t CA_msg)
{
 8010e7c:	b580      	push	{r7, lr}
 8010e7e:	b084      	sub	sp, #16
 8010e80:	af00      	add	r7, sp, #0
 8010e82:	6078      	str	r0, [r7, #4]
	struct J1939_BAM *tempbam;
	
	if(CA_msg->bamrcvdata != NULL)
 8010e84:	687b      	ldr	r3, [r7, #4]
 8010e86:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8010e88:	2b00      	cmp	r3, #0
 8010e8a:	d007      	beq.n	8010e9c <bamAbort+0x20>
	{
		free(CA_msg->bamrcvdata);
 8010e8c:	687b      	ldr	r3, [r7, #4]
 8010e8e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8010e90:	4618      	mov	r0, r3
 8010e92:	f011 fbeb 	bl	802266c <free>
		CA_msg->bamrcvdata = NULL;
 8010e96:	687b      	ldr	r3, [r7, #4]
 8010e98:	2200      	movs	r2, #0
 8010e9a:	659a      	str	r2, [r3, #88]	; 0x58
	}
	tempbam = &(CA_msg->bam);
 8010e9c:	687b      	ldr	r3, [r7, #4]
 8010e9e:	3340      	adds	r3, #64	; 0x40
 8010ea0:	60fb      	str	r3, [r7, #12]
	memset(tempbam,0,sizeof(struct J1939_BAM));
 8010ea2:	68f8      	ldr	r0, [r7, #12]
 8010ea4:	2100      	movs	r1, #0
 8010ea6:	220c      	movs	r2, #12
 8010ea8:	f011 fbe8 	bl	802267c <memset>
}
 8010eac:	3710      	adds	r7, #16
 8010eae:	46bd      	mov	sp, r7
 8010eb0:	bd80      	pop	{r7, pc}
 8010eb2:	bf00      	nop

08010eb4 <timerJ1939func>:

static void timerJ1939func(void* parameter)
{
 8010eb4:	b580      	push	{r7, lr}
 8010eb6:	b086      	sub	sp, #24
 8010eb8:	af00      	add	r7, sp, #0
 8010eba:	6078      	str	r0, [r7, #4]
	CA_Msg_t tmp_ca_msg;
	struct list_node *node;
	static struct q_Message q_msg;
	struct CA_node *canode;
	for(node = calist.head.next; node != &(calist.head); node = node->next)
 8010ebc:	4b93      	ldr	r3, [pc, #588]	; (801110c <timerJ1939func+0x258>)
 8010ebe:	685b      	ldr	r3, [r3, #4]
 8010ec0:	617b      	str	r3, [r7, #20]
 8010ec2:	e1c5      	b.n	8011250 <timerJ1939func+0x39c>
	{
		canode = rt_list_entry(node, struct CA_node, node);
 8010ec4:	697b      	ldr	r3, [r7, #20]
 8010ec6:	3b04      	subs	r3, #4
 8010ec8:	613b      	str	r3, [r7, #16]
		tmp_ca_msg = canode->ca_msg;
 8010eca:	693b      	ldr	r3, [r7, #16]
 8010ecc:	681b      	ldr	r3, [r3, #0]
 8010ece:	60fb      	str	r3, [r7, #12]

		if((tmp_ca_msg->bam.t1.en) == 1)
 8010ed0:	68fb      	ldr	r3, [r7, #12]
 8010ed2:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8010ed6:	2b01      	cmp	r3, #1
 8010ed8:	d12a      	bne.n	8010f30 <timerJ1939func+0x7c>
		{
			if((tmp_ca_msg->bam.t1.release) == 1)
 8010eda:	68fb      	ldr	r3, [r7, #12]
 8010edc:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8010ee0:	2b01      	cmp	r3, #1
 8010ee2:	d10c      	bne.n	8010efe <timerJ1939func+0x4a>
			{
				tmp_ca_msg->bam.t1.en = 0;
 8010ee4:	68fb      	ldr	r3, [r7, #12]
 8010ee6:	2200      	movs	r2, #0
 8010ee8:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
				tmp_ca_msg->bam.t1.value = 0;
 8010eec:	68fb      	ldr	r3, [r7, #12]
 8010eee:	2200      	movs	r2, #0
 8010ef0:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
				tmp_ca_msg->bam.t1.release = 0;
 8010ef4:	68fb      	ldr	r3, [r7, #12]
 8010ef6:	2200      	movs	r2, #0
 8010ef8:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 8010efc:	e018      	b.n	8010f30 <timerJ1939func+0x7c>
			}
			else
			{
				if((tmp_ca_msg->bam.t1.value)-- == 0)
 8010efe:	68fb      	ldr	r3, [r7, #12]
 8010f00:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 8010f04:	1e5a      	subs	r2, r3, #1
 8010f06:	b291      	uxth	r1, r2
 8010f08:	68fa      	ldr	r2, [r7, #12]
 8010f0a:	f8a2 1042 	strh.w	r1, [r2, #66]	; 0x42
 8010f0e:	2b00      	cmp	r3, #0
 8010f10:	d10e      	bne.n	8010f30 <timerJ1939func+0x7c>
				{
					tmp_ca_msg->bam.t1.en = 0;
 8010f12:	68fb      	ldr	r3, [r7, #12]
 8010f14:	2200      	movs	r2, #0
 8010f16:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
					tmp_ca_msg->bam.t1.value = 0;
 8010f1a:	68fb      	ldr	r3, [r7, #12]
 8010f1c:	2200      	movs	r2, #0
 8010f1e:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
					tmp_ca_msg->bam.t1.release = 0;
 8010f22:	68fb      	ldr	r3, [r7, #12]
 8010f24:	2200      	movs	r2, #0
 8010f26:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
				//	osMessagePut(tmp_ca_msg->cm.txq, &q_msg, NULL);
					//sendAbort(tmp_ca_msg,0);

			bamAbort(tmp_ca_msg);
 8010f2a:	68f8      	ldr	r0, [r7, #12]
 8010f2c:	f7ff ffa6 	bl	8010e7c <bamAbort>

				}
			}
		}

		if((tmp_ca_msg->cm.t1.en) == 1)
 8010f30:	68fb      	ldr	r3, [r7, #12]
 8010f32:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8010f36:	2b01      	cmp	r3, #1
 8010f38:	d127      	bne.n	8010f8a <timerJ1939func+0xd6>
		{
			if((tmp_ca_msg->cm.t1.release) == 1)
 8010f3a:	68fb      	ldr	r3, [r7, #12]
 8010f3c:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8010f40:	2b01      	cmp	r3, #1
 8010f42:	d10b      	bne.n	8010f5c <timerJ1939func+0xa8>
			{
				tmp_ca_msg->cm.t1.en = 0;
 8010f44:	68fb      	ldr	r3, [r7, #12]
 8010f46:	2200      	movs	r2, #0
 8010f48:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
				tmp_ca_msg->cm.t1.value = 0;
 8010f4c:	68fb      	ldr	r3, [r7, #12]
 8010f4e:	2200      	movs	r2, #0
 8010f50:	84da      	strh	r2, [r3, #38]	; 0x26
				tmp_ca_msg->cm.t1.release = 0;
 8010f52:	68fb      	ldr	r3, [r7, #12]
 8010f54:	2200      	movs	r2, #0
 8010f56:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
 8010f5a:	e016      	b.n	8010f8a <timerJ1939func+0xd6>
			}
			else
			{
				if((tmp_ca_msg->cm.t1.value)-- == 0)
 8010f5c:	68fb      	ldr	r3, [r7, #12]
 8010f5e:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 8010f60:	1e5a      	subs	r2, r3, #1
 8010f62:	b291      	uxth	r1, r2
 8010f64:	68fa      	ldr	r2, [r7, #12]
 8010f66:	84d1      	strh	r1, [r2, #38]	; 0x26
 8010f68:	2b00      	cmp	r3, #0
 8010f6a:	d10e      	bne.n	8010f8a <timerJ1939func+0xd6>
				{
					tmp_ca_msg->cm.t1.en = 0;
 8010f6c:	68fb      	ldr	r3, [r7, #12]
 8010f6e:	2200      	movs	r2, #0
 8010f70:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
					tmp_ca_msg->cm.t1.value = 0;
 8010f74:	68fb      	ldr	r3, [r7, #12]
 8010f76:	2200      	movs	r2, #0
 8010f78:	84da      	strh	r2, [r3, #38]	; 0x26
					tmp_ca_msg->cm.t1.release = 0;
 8010f7a:	68fb      	ldr	r3, [r7, #12]
 8010f7c:	2200      	movs	r2, #0
 8010f7e:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
				//	osMessagePut(tmp_ca_msg->cm.txq, &q_msg, NULL);
					sendAbort(tmp_ca_msg,0);
 8010f82:	68f8      	ldr	r0, [r7, #12]
 8010f84:	2100      	movs	r1, #0
 8010f86:	f7ff f997 	bl	80102b8 <sendAbort>
				}
			}
		}
		if((tmp_ca_msg->cm.t2.en) == 1)
 8010f8a:	68fb      	ldr	r3, [r7, #12]
 8010f8c:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8010f90:	2b01      	cmp	r3, #1
 8010f92:	d130      	bne.n	8010ff6 <timerJ1939func+0x142>
		{
			if((tmp_ca_msg->cm.t2.release) == 1)
 8010f94:	68fb      	ldr	r3, [r7, #12]
 8010f96:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 8010f9a:	2b01      	cmp	r3, #1
 8010f9c:	d10b      	bne.n	8010fb6 <timerJ1939func+0x102>
			{
				tmp_ca_msg->cm.t2.en = 0;
 8010f9e:	68fb      	ldr	r3, [r7, #12]
 8010fa0:	2200      	movs	r2, #0
 8010fa2:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
				tmp_ca_msg->cm.t2.value = 0;
 8010fa6:	68fb      	ldr	r3, [r7, #12]
 8010fa8:	2200      	movs	r2, #0
 8010faa:	855a      	strh	r2, [r3, #42]	; 0x2a
				tmp_ca_msg->cm.t2.release = 0;
 8010fac:	68fb      	ldr	r3, [r7, #12]
 8010fae:	2200      	movs	r2, #0
 8010fb0:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
 8010fb4:	e01f      	b.n	8010ff6 <timerJ1939func+0x142>
			}
			else
			{
				if((tmp_ca_msg->cm.t2.value)-- == 0)
 8010fb6:	68fb      	ldr	r3, [r7, #12]
 8010fb8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8010fba:	1e5a      	subs	r2, r3, #1
 8010fbc:	b291      	uxth	r1, r2
 8010fbe:	68fa      	ldr	r2, [r7, #12]
 8010fc0:	8551      	strh	r1, [r2, #42]	; 0x2a
 8010fc2:	2b00      	cmp	r3, #0
 8010fc4:	d117      	bne.n	8010ff6 <timerJ1939func+0x142>
				{
					q_msg.timeout = 1;
 8010fc6:	4b52      	ldr	r3, [pc, #328]	; (8011110 <timerJ1939func+0x25c>)
 8010fc8:	2201      	movs	r2, #1
 8010fca:	809a      	strh	r2, [r3, #4]
					q_msg.nextnum = 0;
 8010fcc:	4b50      	ldr	r3, [pc, #320]	; (8011110 <timerJ1939func+0x25c>)
 8010fce:	2200      	movs	r2, #0
 8010fd0:	801a      	strh	r2, [r3, #0]
					q_msg.sendnum = 0;
 8010fd2:	4b4f      	ldr	r3, [pc, #316]	; (8011110 <timerJ1939func+0x25c>)
 8010fd4:	2200      	movs	r2, #0
 8010fd6:	805a      	strh	r2, [r3, #2]
					tmp_ca_msg->cm.t2.en = 0;
 8010fd8:	68fb      	ldr	r3, [r7, #12]
 8010fda:	2200      	movs	r2, #0
 8010fdc:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
					tmp_ca_msg->cm.t2.value = 0;
 8010fe0:	68fb      	ldr	r3, [r7, #12]
 8010fe2:	2200      	movs	r2, #0
 8010fe4:	855a      	strh	r2, [r3, #42]	; 0x2a
					tmp_ca_msg->cm.t2.release = 0;
 8010fe6:	68fb      	ldr	r3, [r7, #12]
 8010fe8:	2200      	movs	r2, #0
 8010fea:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
				//	osMessagePut(tmp_ca_msg->cm.txq, &q_msg, NULL);
					sendAbort(tmp_ca_msg,0);
 8010fee:	68f8      	ldr	r0, [r7, #12]
 8010ff0:	2100      	movs	r1, #0
 8010ff2:	f7ff f961 	bl	80102b8 <sendAbort>
				}
			}
		}
		if((tmp_ca_msg->cm.t3.en) == 1)
 8010ff6:	68fb      	ldr	r3, [r7, #12]
 8010ff8:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8010ffc:	2b01      	cmp	r3, #1
 8010ffe:	d134      	bne.n	801106a <timerJ1939func+0x1b6>
		{
			if((tmp_ca_msg->cm.t3.release) == 1)
 8011000:	68fb      	ldr	r3, [r7, #12]
 8011002:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8011006:	2b01      	cmp	r3, #1
 8011008:	d10b      	bne.n	8011022 <timerJ1939func+0x16e>
			{
				tmp_ca_msg->cm.t3.en = 0;
 801100a:	68fb      	ldr	r3, [r7, #12]
 801100c:	2200      	movs	r2, #0
 801100e:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
				tmp_ca_msg->cm.t3.value = 0;
 8011012:	68fb      	ldr	r3, [r7, #12]
 8011014:	2200      	movs	r2, #0
 8011016:	85da      	strh	r2, [r3, #46]	; 0x2e
				tmp_ca_msg->cm.t3.release = 0;
 8011018:	68fb      	ldr	r3, [r7, #12]
 801101a:	2200      	movs	r2, #0
 801101c:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
 8011020:	e023      	b.n	801106a <timerJ1939func+0x1b6>
			}
			else
			{
				if((tmp_ca_msg->cm.t3.value)-- == 0)
 8011022:	68fb      	ldr	r3, [r7, #12]
 8011024:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 8011026:	1e5a      	subs	r2, r3, #1
 8011028:	b291      	uxth	r1, r2
 801102a:	68fa      	ldr	r2, [r7, #12]
 801102c:	85d1      	strh	r1, [r2, #46]	; 0x2e
 801102e:	2b00      	cmp	r3, #0
 8011030:	d11b      	bne.n	801106a <timerJ1939func+0x1b6>
				{
					q_msg.timeout = 1;
 8011032:	4b37      	ldr	r3, [pc, #220]	; (8011110 <timerJ1939func+0x25c>)
 8011034:	2201      	movs	r2, #1
 8011036:	809a      	strh	r2, [r3, #4]
					q_msg.nextnum = 0;
 8011038:	4b35      	ldr	r3, [pc, #212]	; (8011110 <timerJ1939func+0x25c>)
 801103a:	2200      	movs	r2, #0
 801103c:	801a      	strh	r2, [r3, #0]
					q_msg.sendnum = 0;
 801103e:	4b34      	ldr	r3, [pc, #208]	; (8011110 <timerJ1939func+0x25c>)
 8011040:	2200      	movs	r2, #0
 8011042:	805a      	strh	r2, [r3, #2]
					tmp_ca_msg->cm.t3.en = 0;
 8011044:	68fb      	ldr	r3, [r7, #12]
 8011046:	2200      	movs	r2, #0
 8011048:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
					tmp_ca_msg->cm.t3.value = 0;
 801104c:	68fb      	ldr	r3, [r7, #12]
 801104e:	2200      	movs	r2, #0
 8011050:	85da      	strh	r2, [r3, #46]	; 0x2e
					tmp_ca_msg->cm.t3.release = 0;
 8011052:	68fb      	ldr	r3, [r7, #12]
 8011054:	2200      	movs	r2, #0
 8011056:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
					osMessagePut(tmp_ca_msg->txq, (unsigned long)&q_msg, 0);
 801105a:	68fb      	ldr	r3, [r7, #12]
 801105c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 801105e:	4a2c      	ldr	r2, [pc, #176]	; (8011110 <timerJ1939func+0x25c>)
 8011060:	4618      	mov	r0, r3
 8011062:	4611      	mov	r1, r2
 8011064:	2200      	movs	r2, #0
 8011066:	f008 f9f7 	bl	8019458 <osMessagePut>
				}
			}
		}
		if((tmp_ca_msg->cm.t4.en) == 1)
 801106a:	68fb      	ldr	r3, [r7, #12]
 801106c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8011070:	2b01      	cmp	r3, #1
 8011072:	d134      	bne.n	80110de <timerJ1939func+0x22a>
		{
			if((tmp_ca_msg->cm.t4.release) == 1)
 8011074:	68fb      	ldr	r3, [r7, #12]
 8011076:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 801107a:	2b01      	cmp	r3, #1
 801107c:	d10b      	bne.n	8011096 <timerJ1939func+0x1e2>
			{
				tmp_ca_msg->cm.t4.en = 0;
 801107e:	68fb      	ldr	r3, [r7, #12]
 8011080:	2200      	movs	r2, #0
 8011082:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
				tmp_ca_msg->cm.t4.value = 0;
 8011086:	68fb      	ldr	r3, [r7, #12]
 8011088:	2200      	movs	r2, #0
 801108a:	865a      	strh	r2, [r3, #50]	; 0x32
				tmp_ca_msg->cm.t4.release = 0;
 801108c:	68fb      	ldr	r3, [r7, #12]
 801108e:	2200      	movs	r2, #0
 8011090:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 8011094:	e023      	b.n	80110de <timerJ1939func+0x22a>
			}
			else
			{
				if((tmp_ca_msg->cm.t4.value)-- == 0)
 8011096:	68fb      	ldr	r3, [r7, #12]
 8011098:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 801109a:	1e5a      	subs	r2, r3, #1
 801109c:	b291      	uxth	r1, r2
 801109e:	68fa      	ldr	r2, [r7, #12]
 80110a0:	8651      	strh	r1, [r2, #50]	; 0x32
 80110a2:	2b00      	cmp	r3, #0
 80110a4:	d11b      	bne.n	80110de <timerJ1939func+0x22a>
				{
					q_msg.timeout = 1;
 80110a6:	4b1a      	ldr	r3, [pc, #104]	; (8011110 <timerJ1939func+0x25c>)
 80110a8:	2201      	movs	r2, #1
 80110aa:	809a      	strh	r2, [r3, #4]
					q_msg.nextnum = 0;
 80110ac:	4b18      	ldr	r3, [pc, #96]	; (8011110 <timerJ1939func+0x25c>)
 80110ae:	2200      	movs	r2, #0
 80110b0:	801a      	strh	r2, [r3, #0]
					q_msg.sendnum = 0;
 80110b2:	4b17      	ldr	r3, [pc, #92]	; (8011110 <timerJ1939func+0x25c>)
 80110b4:	2200      	movs	r2, #0
 80110b6:	805a      	strh	r2, [r3, #2]
					tmp_ca_msg->cm.t4.en = 0;
 80110b8:	68fb      	ldr	r3, [r7, #12]
 80110ba:	2200      	movs	r2, #0
 80110bc:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
					tmp_ca_msg->cm.t4.value = 0;
 80110c0:	68fb      	ldr	r3, [r7, #12]
 80110c2:	2200      	movs	r2, #0
 80110c4:	865a      	strh	r2, [r3, #50]	; 0x32
					tmp_ca_msg->cm.t4.release = 0;
 80110c6:	68fb      	ldr	r3, [r7, #12]
 80110c8:	2200      	movs	r2, #0
 80110ca:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
					osMessagePut(tmp_ca_msg->txq, (unsigned long)&q_msg, 0);
 80110ce:	68fb      	ldr	r3, [r7, #12]
 80110d0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80110d2:	4a0f      	ldr	r2, [pc, #60]	; (8011110 <timerJ1939func+0x25c>)
 80110d4:	4618      	mov	r0, r3
 80110d6:	4611      	mov	r1, r2
 80110d8:	2200      	movs	r2, #0
 80110da:	f008 f9bd 	bl	8019458 <osMessagePut>
				}
			}
		}
		if((tmp_ca_msg->cm.tr.en) == 1)
 80110de:	68fb      	ldr	r3, [r7, #12]
 80110e0:	f893 3020 	ldrb.w	r3, [r3, #32]
 80110e4:	2b01      	cmp	r3, #1
 80110e6:	d139      	bne.n	801115c <timerJ1939func+0x2a8>
		{
			if((tmp_ca_msg->cm.tr.release) == 1)
 80110e8:	68fb      	ldr	r3, [r7, #12]
 80110ea:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 80110ee:	2b01      	cmp	r3, #1
 80110f0:	d110      	bne.n	8011114 <timerJ1939func+0x260>
			{
				tmp_ca_msg->cm.tr.en = 0;
 80110f2:	68fb      	ldr	r3, [r7, #12]
 80110f4:	2200      	movs	r2, #0
 80110f6:	f883 2020 	strb.w	r2, [r3, #32]
				tmp_ca_msg->cm.tr.value = 0;
 80110fa:	68fb      	ldr	r3, [r7, #12]
 80110fc:	2200      	movs	r2, #0
 80110fe:	83da      	strh	r2, [r3, #30]
				tmp_ca_msg->cm.tr.release = 0;
 8011100:	68fb      	ldr	r3, [r7, #12]
 8011102:	2200      	movs	r2, #0
 8011104:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
 8011108:	e028      	b.n	801115c <timerJ1939func+0x2a8>
 801110a:	bf00      	nop
 801110c:	200127a0 	.word	0x200127a0
 8011110:	2001082c 	.word	0x2001082c
			}
			else
			{
				if((tmp_ca_msg->cm.tr.value)-- == 0)
 8011114:	68fb      	ldr	r3, [r7, #12]
 8011116:	8bdb      	ldrh	r3, [r3, #30]
 8011118:	1e5a      	subs	r2, r3, #1
 801111a:	b291      	uxth	r1, r2
 801111c:	68fa      	ldr	r2, [r7, #12]
 801111e:	83d1      	strh	r1, [r2, #30]
 8011120:	2b00      	cmp	r3, #0
 8011122:	d11b      	bne.n	801115c <timerJ1939func+0x2a8>
				{
					q_msg.timeout = 1;
 8011124:	4b4e      	ldr	r3, [pc, #312]	; (8011260 <timerJ1939func+0x3ac>)
 8011126:	2201      	movs	r2, #1
 8011128:	809a      	strh	r2, [r3, #4]
					q_msg.nextnum = 0;
 801112a:	4b4d      	ldr	r3, [pc, #308]	; (8011260 <timerJ1939func+0x3ac>)
 801112c:	2200      	movs	r2, #0
 801112e:	801a      	strh	r2, [r3, #0]
					q_msg.sendnum = 0;
 8011130:	4b4b      	ldr	r3, [pc, #300]	; (8011260 <timerJ1939func+0x3ac>)
 8011132:	2200      	movs	r2, #0
 8011134:	805a      	strh	r2, [r3, #2]
					tmp_ca_msg->cm.tr.en = 0;
 8011136:	68fb      	ldr	r3, [r7, #12]
 8011138:	2200      	movs	r2, #0
 801113a:	f883 2020 	strb.w	r2, [r3, #32]
					tmp_ca_msg->cm.tr.value = 0;
 801113e:	68fb      	ldr	r3, [r7, #12]
 8011140:	2200      	movs	r2, #0
 8011142:	83da      	strh	r2, [r3, #30]
					tmp_ca_msg->cm.tr.release = 0;
 8011144:	68fb      	ldr	r3, [r7, #12]
 8011146:	2200      	movs	r2, #0
 8011148:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
					osMessagePut(tmp_ca_msg->txq, (unsigned long)&q_msg,0);
 801114c:	68fb      	ldr	r3, [r7, #12]
 801114e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8011150:	4a43      	ldr	r2, [pc, #268]	; (8011260 <timerJ1939func+0x3ac>)
 8011152:	4618      	mov	r0, r3
 8011154:	4611      	mov	r1, r2
 8011156:	2200      	movs	r2, #0
 8011158:	f008 f97e 	bl	8019458 <osMessagePut>
				}
			}
		}
		if((tmp_ca_msg->cm.th.en) == 1)
 801115c:	68fb      	ldr	r3, [r7, #12]
 801115e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8011162:	2b01      	cmp	r3, #1
 8011164:	d134      	bne.n	80111d0 <timerJ1939func+0x31c>
		{
			if((tmp_ca_msg->cm.th.release) == 1)
 8011166:	68fb      	ldr	r3, [r7, #12]
 8011168:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 801116c:	2b01      	cmp	r3, #1
 801116e:	d10b      	bne.n	8011188 <timerJ1939func+0x2d4>
			{
				tmp_ca_msg->cm.th.en = 0;
 8011170:	68fb      	ldr	r3, [r7, #12]
 8011172:	2200      	movs	r2, #0
 8011174:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
				tmp_ca_msg->cm.th.value = 0;
 8011178:	68fb      	ldr	r3, [r7, #12]
 801117a:	2200      	movs	r2, #0
 801117c:	845a      	strh	r2, [r3, #34]	; 0x22
				tmp_ca_msg->cm.th.release = 0;
 801117e:	68fb      	ldr	r3, [r7, #12]
 8011180:	2200      	movs	r2, #0
 8011182:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
 8011186:	e023      	b.n	80111d0 <timerJ1939func+0x31c>
			}
			else
			{
				if((tmp_ca_msg->cm.th.value)-- == 0)
 8011188:	68fb      	ldr	r3, [r7, #12]
 801118a:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 801118c:	1e5a      	subs	r2, r3, #1
 801118e:	b291      	uxth	r1, r2
 8011190:	68fa      	ldr	r2, [r7, #12]
 8011192:	8451      	strh	r1, [r2, #34]	; 0x22
 8011194:	2b00      	cmp	r3, #0
 8011196:	d11b      	bne.n	80111d0 <timerJ1939func+0x31c>
				{
					q_msg.timeout = 1;
 8011198:	4b31      	ldr	r3, [pc, #196]	; (8011260 <timerJ1939func+0x3ac>)
 801119a:	2201      	movs	r2, #1
 801119c:	809a      	strh	r2, [r3, #4]
					q_msg.nextnum = 0;
 801119e:	4b30      	ldr	r3, [pc, #192]	; (8011260 <timerJ1939func+0x3ac>)
 80111a0:	2200      	movs	r2, #0
 80111a2:	801a      	strh	r2, [r3, #0]
					q_msg.sendnum = 0;
 80111a4:	4b2e      	ldr	r3, [pc, #184]	; (8011260 <timerJ1939func+0x3ac>)
 80111a6:	2200      	movs	r2, #0
 80111a8:	805a      	strh	r2, [r3, #2]
					tmp_ca_msg->cm.th.en = 0;
 80111aa:	68fb      	ldr	r3, [r7, #12]
 80111ac:	2200      	movs	r2, #0
 80111ae:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
					tmp_ca_msg->cm.th.value = 0;
 80111b2:	68fb      	ldr	r3, [r7, #12]
 80111b4:	2200      	movs	r2, #0
 80111b6:	845a      	strh	r2, [r3, #34]	; 0x22
					tmp_ca_msg->cm.th.release = 0;
 80111b8:	68fb      	ldr	r3, [r7, #12]
 80111ba:	2200      	movs	r2, #0
 80111bc:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
					osMessagePut(tmp_ca_msg->txq, (unsigned long)&q_msg, 0);
 80111c0:	68fb      	ldr	r3, [r7, #12]
 80111c2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80111c4:	4a26      	ldr	r2, [pc, #152]	; (8011260 <timerJ1939func+0x3ac>)
 80111c6:	4618      	mov	r0, r3
 80111c8:	4611      	mov	r1, r2
 80111ca:	2200      	movs	r2, #0
 80111cc:	f008 f944 	bl	8019458 <osMessagePut>
				}
			}
		}
			#if 1
		if(tmp_ca_msg->nm.t250.en == 1)
 80111d0:	68fb      	ldr	r3, [r7, #12]
 80111d2:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 80111d6:	2b01      	cmp	r3, #1
 80111d8:	d137      	bne.n	801124a <timerJ1939func+0x396>
		{
			if(tmp_ca_msg->nm.t250.release == 1)
 80111da:	68fb      	ldr	r3, [r7, #12]
 80111dc:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 80111e0:	2b01      	cmp	r3, #1
 80111e2:	d114      	bne.n	801120e <timerJ1939func+0x35a>
			{
				tmp_ca_msg->nm.cannotClaimAddr = 1;
 80111e4:	68fb      	ldr	r3, [r7, #12]
 80111e6:	2201      	movs	r2, #1
 80111e8:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
				tmp_ca_msg->nm.WaitingForAddressClaimContention = 0;
 80111ec:	68fb      	ldr	r3, [r7, #12]
 80111ee:	2200      	movs	r2, #0
 80111f0:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
				tmp_ca_msg->nm.t250.en = 0;
 80111f4:	68fb      	ldr	r3, [r7, #12]
 80111f6:	2200      	movs	r2, #0
 80111f8:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
				tmp_ca_msg->nm.t250.value = 0;
 80111fc:	68fb      	ldr	r3, [r7, #12]
 80111fe:	2200      	movs	r2, #0
 8011200:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
				tmp_ca_msg->nm.t250.release = 0;
 8011204:	68fb      	ldr	r3, [r7, #12]
 8011206:	2200      	movs	r2, #0
 8011208:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
 801120c:	e01d      	b.n	801124a <timerJ1939func+0x396>
			}
			else
			{
				if(tmp_ca_msg->nm.t250.value-- == 0)
 801120e:	68fb      	ldr	r3, [r7, #12]
 8011210:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
 8011214:	1e5a      	subs	r2, r3, #1
 8011216:	b291      	uxth	r1, r2
 8011218:	68fa      	ldr	r2, [r7, #12]
 801121a:	f8a2 104e 	strh.w	r1, [r2, #78]	; 0x4e
 801121e:	2b00      	cmp	r3, #0
 8011220:	d113      	bne.n	801124a <timerJ1939func+0x396>
				{
					tmp_ca_msg->nm.cannotClaimAddr = 0;
 8011222:	68fb      	ldr	r3, [r7, #12]
 8011224:	2200      	movs	r2, #0
 8011226:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
					tmp_ca_msg->nm.WaitingForAddressClaimContention = 0;
 801122a:	68fb      	ldr	r3, [r7, #12]
 801122c:	2200      	movs	r2, #0
 801122e:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
					tmp_ca_msg->nm.t250.en = 0;
 8011232:	68fb      	ldr	r3, [r7, #12]
 8011234:	2200      	movs	r2, #0
 8011236:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
					tmp_ca_msg->nm.t250.value = 0;
 801123a:	68fb      	ldr	r3, [r7, #12]
 801123c:	2200      	movs	r2, #0
 801123e:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
					tmp_ca_msg->nm.t250.release = 0;
 8011242:	68fb      	ldr	r3, [r7, #12]
 8011244:	2200      	movs	r2, #0
 8011246:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
{
	CA_Msg_t tmp_ca_msg;
	struct list_node *node;
	static struct q_Message q_msg;
	struct CA_node *canode;
	for(node = calist.head.next; node != &(calist.head); node = node->next)
 801124a:	697b      	ldr	r3, [r7, #20]
 801124c:	681b      	ldr	r3, [r3, #0]
 801124e:	617b      	str	r3, [r7, #20]
 8011250:	697b      	ldr	r3, [r7, #20]
 8011252:	4a04      	ldr	r2, [pc, #16]	; (8011264 <timerJ1939func+0x3b0>)
 8011254:	4293      	cmp	r3, r2
 8011256:	f47f ae35 	bne.w	8010ec4 <timerJ1939func+0x10>
				}
			}
		}
			#endif
	}
}
 801125a:	3718      	adds	r7, #24
 801125c:	46bd      	mov	sp, r7
 801125e:	bd80      	pop	{r7, pc}
 8011260:	2001082c 	.word	0x2001082c
 8011264:	200127a4 	.word	0x200127a4

08011268 <initJ1939>:


 unsigned char initJ1939()
{
 8011268:	b580      	push	{r7, lr}
 801126a:	b088      	sub	sp, #32
 801126c:	af00      	add	r7, sp, #0
	unsigned char result = RC_SUCCESS;
 801126e:	2300      	movs	r3, #0
 8011270:	77fb      	strb	r3, [r7, #31]
	osTimerId timerid;
	struct os_timer_def timer_def;
	
	list_init(&(calist.head));
 8011272:	4810      	ldr	r0, [pc, #64]	; (80112b4 <initJ1939+0x4c>)
 8011274:	f7fe fd04 	bl	800fc80 <list_init>

	timer_def.flag = osTimerPeriodic;
 8011278:	2301      	movs	r3, #1
 801127a:	753b      	strb	r3, [r7, #20]
	timer_def.name = "J1939timer";
 801127c:	4b0e      	ldr	r3, [pc, #56]	; (80112b8 <initJ1939+0x50>)
 801127e:	607b      	str	r3, [r7, #4]
	timer_def.parameter = NULL;
 8011280:	2300      	movs	r3, #0
 8011282:	60fb      	str	r3, [r7, #12]
	timer_def.time = 1;
 8011284:	2301      	movs	r3, #1
 8011286:	613b      	str	r3, [r7, #16]
	timer_def.timeout = timerJ1939func;
 8011288:	4b0c      	ldr	r3, [pc, #48]	; (80112bc <initJ1939+0x54>)
 801128a:	60bb      	str	r3, [r7, #8]
	timerid = osTimerCreate(&timer_def, osTimerPeriodic, NULL);
 801128c:	1d3b      	adds	r3, r7, #4
 801128e:	4618      	mov	r0, r3
 8011290:	2101      	movs	r1, #1
 8011292:	2200      	movs	r2, #0
 8011294:	f008 f888 	bl	80193a8 <osTimerCreate>
 8011298:	61b8      	str	r0, [r7, #24]
	if(timerid != NULL) 
 801129a:	69bb      	ldr	r3, [r7, #24]
 801129c:	2b00      	cmp	r3, #0
 801129e:	d004      	beq.n	80112aa <initJ1939+0x42>
		osTimerStart(timerid,timer_def.time);
 80112a0:	693b      	ldr	r3, [r7, #16]
 80112a2:	69b8      	ldr	r0, [r7, #24]
 80112a4:	4619      	mov	r1, r3
 80112a6:	f008 f8a3 	bl	80193f0 <osTimerStart>
	return result;
 80112aa:	7ffb      	ldrb	r3, [r7, #31]
}
 80112ac:	4618      	mov	r0, r3
 80112ae:	3720      	adds	r7, #32
 80112b0:	46bd      	mov	sp, r7
 80112b2:	bd80      	pop	{r7, pc}
 80112b4:	200127a4 	.word	0x200127a4
 80112b8:	080287a0 	.word	0x080287a0
 80112bc:	08010eb5 	.word	0x08010eb5

080112c0 <j1939strncmp>:

#include "SAEJ1939.h"

static signed char j1939strncmp(const char *cs, const char *ct, unsigned long count)
{
 80112c0:	b480      	push	{r7}
 80112c2:	b087      	sub	sp, #28
 80112c4:	af00      	add	r7, sp, #0
 80112c6:	60f8      	str	r0, [r7, #12]
 80112c8:	60b9      	str	r1, [r7, #8]
 80112ca:	607a      	str	r2, [r7, #4]
    signed char __res = 0;
 80112cc:	2300      	movs	r3, #0
 80112ce:	75fb      	strb	r3, [r7, #23]
	
	if((cs == NULL) || (ct == NULL))
 80112d0:	68fb      	ldr	r3, [r7, #12]
 80112d2:	2b00      	cmp	r3, #0
 80112d4:	d002      	beq.n	80112dc <j1939strncmp+0x1c>
 80112d6:	68bb      	ldr	r3, [r7, #8]
 80112d8:	2b00      	cmp	r3, #0
 80112da:	d101      	bne.n	80112e0 <j1939strncmp+0x20>
	{
		return 1;
 80112dc:	2301      	movs	r3, #1
 80112de:	e017      	b.n	8011310 <j1939strncmp+0x50>
	}
    while (count)
 80112e0:	e012      	b.n	8011308 <j1939strncmp+0x48>
    {
        if ((__res = *cs++ - *ct++) != 0 )
 80112e2:	68fb      	ldr	r3, [r7, #12]
 80112e4:	1c5a      	adds	r2, r3, #1
 80112e6:	60fa      	str	r2, [r7, #12]
 80112e8:	781a      	ldrb	r2, [r3, #0]
 80112ea:	68bb      	ldr	r3, [r7, #8]
 80112ec:	1c59      	adds	r1, r3, #1
 80112ee:	60b9      	str	r1, [r7, #8]
 80112f0:	781b      	ldrb	r3, [r3, #0]
 80112f2:	1ad3      	subs	r3, r2, r3
 80112f4:	b2db      	uxtb	r3, r3
 80112f6:	75fb      	strb	r3, [r7, #23]
 80112f8:	f997 3017 	ldrsb.w	r3, [r7, #23]
 80112fc:	2b00      	cmp	r3, #0
 80112fe:	d000      	beq.n	8011302 <j1939strncmp+0x42>
            break;
 8011300:	e005      	b.n	801130e <j1939strncmp+0x4e>
        count --;
 8011302:	687b      	ldr	r3, [r7, #4]
 8011304:	3b01      	subs	r3, #1
 8011306:	607b      	str	r3, [r7, #4]
	
	if((cs == NULL) || (ct == NULL))
	{
		return 1;
	}
    while (count)
 8011308:	687b      	ldr	r3, [r7, #4]
 801130a:	2b00      	cmp	r3, #0
 801130c:	d1e9      	bne.n	80112e2 <j1939strncmp+0x22>
        if ((__res = *cs++ - *ct++) != 0 )
            break;
        count --;
    }

    return __res;
 801130e:	7dfb      	ldrb	r3, [r7, #23]
 8011310:	b25b      	sxtb	r3, r3
}
 8011312:	4618      	mov	r0, r3
 8011314:	371c      	adds	r7, #28
 8011316:	46bd      	mov	sp, r7
 8011318:	f85d 7b04 	ldr.w	r7, [sp], #4
 801131c:	4770      	bx	lr
 801131e:	bf00      	nop

08011320 <CA_FindAddress>:

unsigned char CA_FindAddress(CA_list_t calist,CA_Msg_t ca_msg)
{
 8011320:	b580      	push	{r7, lr}
 8011322:	b086      	sub	sp, #24
 8011324:	af00      	add	r7, sp, #0
 8011326:	6078      	str	r0, [r7, #4]
 8011328:	6039      	str	r1, [r7, #0]
	list_node_t node;
	struct CA_node *canode;
	J1939_CAname_t CAname = ca_msg->CAname;
 801132a:	683b      	ldr	r3, [r7, #0]
 801132c:	681b      	ldr	r3, [r3, #0]
 801132e:	613b      	str	r3, [r7, #16]
	CA_Msg_t tmp_ca_msg;
	
	for(node = calist->head.next; node != &(calist->head); node = node->next)
 8011330:	687b      	ldr	r3, [r7, #4]
 8011332:	685b      	ldr	r3, [r3, #4]
 8011334:	617b      	str	r3, [r7, #20]
 8011336:	e015      	b.n	8011364 <CA_FindAddress+0x44>
	{
		canode = rt_list_entry(node, struct CA_node, node);
 8011338:	697b      	ldr	r3, [r7, #20]
 801133a:	3b04      	subs	r3, #4
 801133c:	60fb      	str	r3, [r7, #12]
		tmp_ca_msg = canode->ca_msg;
 801133e:	68fb      	ldr	r3, [r7, #12]
 8011340:	681b      	ldr	r3, [r3, #0]
 8011342:	60bb      	str	r3, [r7, #8]
		if(j1939strncmp((char *)CAname,(char *)tmp_ca_msg->CAname,sizeof(struct J1939_CAname)) == 0)
 8011344:	68bb      	ldr	r3, [r7, #8]
 8011346:	681b      	ldr	r3, [r3, #0]
 8011348:	6938      	ldr	r0, [r7, #16]
 801134a:	4619      	mov	r1, r3
 801134c:	2208      	movs	r2, #8
 801134e:	f7ff ffb7 	bl	80112c0 <j1939strncmp>
 8011352:	4603      	mov	r3, r0
 8011354:	2b00      	cmp	r3, #0
 8011356:	d102      	bne.n	801135e <CA_FindAddress+0x3e>
		{
			return (tmp_ca_msg->msg.SourceAddress);
 8011358:	68bb      	ldr	r3, [r7, #8]
 801135a:	79db      	ldrb	r3, [r3, #7]
 801135c:	e008      	b.n	8011370 <CA_FindAddress+0x50>
	list_node_t node;
	struct CA_node *canode;
	J1939_CAname_t CAname = ca_msg->CAname;
	CA_Msg_t tmp_ca_msg;
	
	for(node = calist->head.next; node != &(calist->head); node = node->next)
 801135e:	697b      	ldr	r3, [r7, #20]
 8011360:	681b      	ldr	r3, [r3, #0]
 8011362:	617b      	str	r3, [r7, #20]
 8011364:	687b      	ldr	r3, [r7, #4]
 8011366:	1d1a      	adds	r2, r3, #4
 8011368:	697b      	ldr	r3, [r7, #20]
 801136a:	429a      	cmp	r2, r3
 801136c:	d1e4      	bne.n	8011338 <CA_FindAddress+0x18>
		{
			return (tmp_ca_msg->msg.SourceAddress);
		}
	}
	
	return 254;
 801136e:	23fe      	movs	r3, #254	; 0xfe
}
 8011370:	4618      	mov	r0, r3
 8011372:	3718      	adds	r7, #24
 8011374:	46bd      	mov	sp, r7
 8011376:	bd80      	pop	{r7, pc}

08011378 <Addr_FindCA>:
CA_Msg_t Addr_FindCA(CA_list_t calist, unsigned char addr)
{
 8011378:	b480      	push	{r7}
 801137a:	b087      	sub	sp, #28
 801137c:	af00      	add	r7, sp, #0
 801137e:	6078      	str	r0, [r7, #4]
 8011380:	460b      	mov	r3, r1
 8011382:	70fb      	strb	r3, [r7, #3]
	list_node_t node;
	struct CA_node *canode;
	CA_Msg_t tmp_ca_msg;

	for(node = calist->head.next; node != &(calist->head); node = node->next)
 8011384:	687b      	ldr	r3, [r7, #4]
 8011386:	685b      	ldr	r3, [r3, #4]
 8011388:	617b      	str	r3, [r7, #20]
 801138a:	e010      	b.n	80113ae <Addr_FindCA+0x36>
	{
		unsigned char i=0;
 801138c:	2300      	movs	r3, #0
 801138e:	73fb      	strb	r3, [r7, #15]
		canode = rt_list_entry(node, struct CA_node, node);
 8011390:	697b      	ldr	r3, [r7, #20]
 8011392:	3b04      	subs	r3, #4
 8011394:	60bb      	str	r3, [r7, #8]
		tmp_ca_msg = canode->ca_msg;
 8011396:	68bb      	ldr	r3, [r7, #8]
 8011398:	681b      	ldr	r3, [r3, #0]
 801139a:	613b      	str	r3, [r7, #16]
		if(tmp_ca_msg->msg.SourceAddress == addr)
 801139c:	693b      	ldr	r3, [r7, #16]
 801139e:	79db      	ldrb	r3, [r3, #7]
 80113a0:	78fa      	ldrb	r2, [r7, #3]
 80113a2:	429a      	cmp	r2, r3
 80113a4:	d100      	bne.n	80113a8 <Addr_FindCA+0x30>
			break;
 80113a6:	e007      	b.n	80113b8 <Addr_FindCA+0x40>
{
	list_node_t node;
	struct CA_node *canode;
	CA_Msg_t tmp_ca_msg;

	for(node = calist->head.next; node != &(calist->head); node = node->next)
 80113a8:	697b      	ldr	r3, [r7, #20]
 80113aa:	681b      	ldr	r3, [r3, #0]
 80113ac:	617b      	str	r3, [r7, #20]
 80113ae:	687b      	ldr	r3, [r7, #4]
 80113b0:	1d1a      	adds	r2, r3, #4
 80113b2:	697b      	ldr	r3, [r7, #20]
 80113b4:	429a      	cmp	r2, r3
 80113b6:	d1e9      	bne.n	801138c <Addr_FindCA+0x14>
		canode = rt_list_entry(node, struct CA_node, node);
		tmp_ca_msg = canode->ca_msg;
		if(tmp_ca_msg->msg.SourceAddress == addr)
			break;
	}
	if(node == &(calist->head) )
 80113b8:	687b      	ldr	r3, [r7, #4]
 80113ba:	1d1a      	adds	r2, r3, #4
 80113bc:	697b      	ldr	r3, [r7, #20]
 80113be:	429a      	cmp	r2, r3
 80113c0:	d101      	bne.n	80113c6 <Addr_FindCA+0x4e>
		return NULL;
 80113c2:	2300      	movs	r3, #0
 80113c4:	e000      	b.n	80113c8 <Addr_FindCA+0x50>
	else
		return tmp_ca_msg;
 80113c6:	693b      	ldr	r3, [r7, #16]

}
 80113c8:	4618      	mov	r0, r3
 80113ca:	371c      	adds	r7, #28
 80113cc:	46bd      	mov	sp, r7
 80113ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80113d2:	4770      	bx	lr

080113d4 <J1939_RequestForAddressClaimHandling>:

unsigned char J1939_RequestForAddressClaimHandling( J1939_msg_t j1939_msg ,CA_Msg_t CA_msg )
{
 80113d4:	b580      	push	{r7, lr}
 80113d6:	b084      	sub	sp, #16
 80113d8:	af00      	add	r7, sp, #0
 80113da:	6078      	str	r0, [r7, #4]
 80113dc:	6039      	str	r1, [r7, #0]
	unsigned char i;
	unsigned char *CA_Name = (unsigned char *)(CA_msg->CAname);
 80113de:	683b      	ldr	r3, [r7, #0]
 80113e0:	681b      	ldr	r3, [r3, #0]
 80113e2:	60bb      	str	r3, [r7, #8]

	if (CA_msg->nm.cannotClaimAddr)
 80113e4:	683b      	ldr	r3, [r7, #0]
 80113e6:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 80113ea:	2b00      	cmp	r3, #0
 80113ec:	d003      	beq.n	80113f6 <J1939_RequestForAddressClaimHandling+0x22>
		j1939_msg->SourceAddress = J1939_NULL_ADDRESS;	// Send Cannot Claim Address message
 80113ee:	687b      	ldr	r3, [r7, #4]
 80113f0:	22fe      	movs	r2, #254	; 0xfe
 80113f2:	70da      	strb	r2, [r3, #3]
 80113f4:	e003      	b.n	80113fe <J1939_RequestForAddressClaimHandling+0x2a>
	else
		j1939_msg->SourceAddress = CA_msg->msg.SourceAddress;		// Send Address Claim for current address
 80113f6:	683b      	ldr	r3, [r7, #0]
 80113f8:	79da      	ldrb	r2, [r3, #7]
 80113fa:	687b      	ldr	r3, [r7, #4]
 80113fc:	70da      	strb	r2, [r3, #3]

	j1939_msg->Priority = 6;
 80113fe:	687a      	ldr	r2, [r7, #4]
 8011400:	7813      	ldrb	r3, [r2, #0]
 8011402:	2106      	movs	r1, #6
 8011404:	f361 1347 	bfi	r3, r1, #5, #3
 8011408:	7013      	strb	r3, [r2, #0]
	j1939_msg->PDUFormat = J1939_PF_ADDRESS_CLAIMED;	// Same as J1939_PF_CANNOT_CLAIM_ADDRESS
 801140a:	687b      	ldr	r3, [r7, #4]
 801140c:	22ee      	movs	r2, #238	; 0xee
 801140e:	705a      	strb	r2, [r3, #1]
	j1939_msg->PDUSpecific = J1939_GLOBAL_ADDRESS;
 8011410:	687b      	ldr	r3, [r7, #4]
 8011412:	22ff      	movs	r2, #255	; 0xff
 8011414:	709a      	strb	r2, [r3, #2]
	j1939_msg->DataLength = J1939_DATA_LENGTH;
 8011416:	687a      	ldr	r2, [r7, #4]
 8011418:	7913      	ldrb	r3, [r2, #4]
 801141a:	2108      	movs	r1, #8
 801141c:	f361 0303 	bfi	r3, r1, #0, #4
 8011420:	7113      	strb	r3, [r2, #4]

	for (i=0; i<J1939_DATA_LENGTH; i++)
 8011422:	2300      	movs	r3, #0
 8011424:	73fb      	strb	r3, [r7, #15]
 8011426:	e00b      	b.n	8011440 <J1939_RequestForAddressClaimHandling+0x6c>
		j1939_msg->Data[i] = CA_Name[i];
 8011428:	7bfb      	ldrb	r3, [r7, #15]
 801142a:	7bfa      	ldrb	r2, [r7, #15]
 801142c:	68b9      	ldr	r1, [r7, #8]
 801142e:	440a      	add	r2, r1
 8011430:	7811      	ldrb	r1, [r2, #0]
 8011432:	687a      	ldr	r2, [r7, #4]
 8011434:	4413      	add	r3, r2
 8011436:	460a      	mov	r2, r1
 8011438:	715a      	strb	r2, [r3, #5]
	j1939_msg->Priority = 6;
	j1939_msg->PDUFormat = J1939_PF_ADDRESS_CLAIMED;	// Same as J1939_PF_CANNOT_CLAIM_ADDRESS
	j1939_msg->PDUSpecific = J1939_GLOBAL_ADDRESS;
	j1939_msg->DataLength = J1939_DATA_LENGTH;

	for (i=0; i<J1939_DATA_LENGTH; i++)
 801143a:	7bfb      	ldrb	r3, [r7, #15]
 801143c:	3301      	adds	r3, #1
 801143e:	73fb      	strb	r3, [r7, #15]
 8011440:	7bfb      	ldrb	r3, [r7, #15]
 8011442:	2b07      	cmp	r3, #7
 8011444:	d9f0      	bls.n	8011428 <J1939_RequestForAddressClaimHandling+0x54>
		j1939_msg->Data[i] = CA_Name[i];
	
	return writeCan(j1939_msg);
 8011446:	6878      	ldr	r0, [r7, #4]
 8011448:	f000 f92e 	bl	80116a8 <writeCan>
 801144c:	4603      	mov	r3, r0
}
 801144e:	4618      	mov	r0, r3
 8011450:	3710      	adds	r7, #16
 8011452:	46bd      	mov	sp, r7
 8011454:	bd80      	pop	{r7, pc}
 8011456:	bf00      	nop

08011458 <CompareName>:

signed char CompareName( unsigned char *OtherName,CA_Msg_t CA_msg  )
{
 8011458:	b480      	push	{r7}
 801145a:	b085      	sub	sp, #20
 801145c:	af00      	add	r7, sp, #0
 801145e:	6078      	str	r0, [r7, #4]
 8011460:	6039      	str	r1, [r7, #0]
	unsigned char	i;
	unsigned char *CA_Name = (unsigned char *)(CA_msg->CAname);
 8011462:	683b      	ldr	r3, [r7, #0]
 8011464:	681b      	ldr	r3, [r3, #0]
 8011466:	60bb      	str	r3, [r7, #8]
	
	for (i = 0; (i<J1939_DATA_LENGTH) && (OtherName[i] == CA_Name[i]); i++);
 8011468:	2300      	movs	r3, #0
 801146a:	73fb      	strb	r3, [r7, #15]
 801146c:	e002      	b.n	8011474 <CompareName+0x1c>
 801146e:	7bfb      	ldrb	r3, [r7, #15]
 8011470:	3301      	adds	r3, #1
 8011472:	73fb      	strb	r3, [r7, #15]
 8011474:	7bfb      	ldrb	r3, [r7, #15]
 8011476:	2b07      	cmp	r3, #7
 8011478:	d809      	bhi.n	801148e <CompareName+0x36>
 801147a:	7bfb      	ldrb	r3, [r7, #15]
 801147c:	687a      	ldr	r2, [r7, #4]
 801147e:	4413      	add	r3, r2
 8011480:	781a      	ldrb	r2, [r3, #0]
 8011482:	7bfb      	ldrb	r3, [r7, #15]
 8011484:	68b9      	ldr	r1, [r7, #8]
 8011486:	440b      	add	r3, r1
 8011488:	781b      	ldrb	r3, [r3, #0]
 801148a:	429a      	cmp	r2, r3
 801148c:	d0ef      	beq.n	801146e <CompareName+0x16>

	if (i == J1939_DATA_LENGTH)
 801148e:	7bfb      	ldrb	r3, [r7, #15]
 8011490:	2b08      	cmp	r3, #8
 8011492:	d101      	bne.n	8011498 <CompareName+0x40>
		return 0;
 8011494:	2300      	movs	r3, #0
 8011496:	e00c      	b.n	80114b2 <CompareName+0x5a>
	else if (CA_Name[i] < OtherName[i] )
 8011498:	7bfb      	ldrb	r3, [r7, #15]
 801149a:	68ba      	ldr	r2, [r7, #8]
 801149c:	4413      	add	r3, r2
 801149e:	781a      	ldrb	r2, [r3, #0]
 80114a0:	7bfb      	ldrb	r3, [r7, #15]
 80114a2:	6879      	ldr	r1, [r7, #4]
 80114a4:	440b      	add	r3, r1
 80114a6:	781b      	ldrb	r3, [r3, #0]
 80114a8:	429a      	cmp	r2, r3
 80114aa:	d201      	bcs.n	80114b0 <CompareName+0x58>
		return -1;
 80114ac:	23ff      	movs	r3, #255	; 0xff
 80114ae:	e000      	b.n	80114b2 <CompareName+0x5a>
	else
		return 1;
 80114b0:	2301      	movs	r3, #1
 80114b2:	b25b      	sxtb	r3, r3
}
 80114b4:	4618      	mov	r0, r3
 80114b6:	3714      	adds	r7, #20
 80114b8:	46bd      	mov	sp, r7
 80114ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80114be:	4770      	bx	lr

080114c0 <J1939_AddressClaimHandling>:

unsigned char J1939_AddressClaimHandling(  J1939_msg_t j1939_msg ,CA_Msg_t CA_msg  )
{
 80114c0:	b580      	push	{r7, lr}
 80114c2:	b084      	sub	sp, #16
 80114c4:	af00      	add	r7, sp, #0
 80114c6:	6078      	str	r0, [r7, #4]
 80114c8:	6039      	str	r1, [r7, #0]

	unsigned char i;
	unsigned char *CA_Name = (unsigned char *)(CA_msg->CAname);
 80114ca:	683b      	ldr	r3, [r7, #0]
 80114cc:	681b      	ldr	r3, [r3, #0]
 80114ce:	60bb      	str	r3, [r7, #8]
	
	j1939_msg->Priority = 6;
 80114d0:	687a      	ldr	r2, [r7, #4]
 80114d2:	7813      	ldrb	r3, [r2, #0]
 80114d4:	2106      	movs	r1, #6
 80114d6:	f361 1347 	bfi	r3, r1, #5, #3
 80114da:	7013      	strb	r3, [r2, #0]
	j1939_msg->PDUFormat = J1939_PF_ADDRESS_CLAIMED;
 80114dc:	687b      	ldr	r3, [r7, #4]
 80114de:	22ee      	movs	r2, #238	; 0xee
 80114e0:	705a      	strb	r2, [r3, #1]
	j1939_msg->PDUSpecific = J1939_GLOBAL_ADDRESS;
 80114e2:	687b      	ldr	r3, [r7, #4]
 80114e4:	22ff      	movs	r2, #255	; 0xff
 80114e6:	709a      	strb	r2, [r3, #2]
	j1939_msg->DataLength = J1939_DATA_LENGTH;
 80114e8:	687a      	ldr	r2, [r7, #4]
 80114ea:	7913      	ldrb	r3, [r2, #4]
 80114ec:	2108      	movs	r1, #8
 80114ee:	f361 0303 	bfi	r3, r1, #0, #4
 80114f2:	7113      	strb	r3, [r2, #4]


	//if (j1939_msg->SourceAddress != CA_msg->msg.SourceAddress)
	//	return RC_ERROR;

	if (CompareName( j1939_msg->Data,CA_msg ) != -1) // Our CA_Name is not less
 80114f4:	687b      	ldr	r3, [r7, #4]
 80114f6:	3305      	adds	r3, #5
 80114f8:	4618      	mov	r0, r3
 80114fa:	6839      	ldr	r1, [r7, #0]
 80114fc:	f7ff ffac 	bl	8011458 <CompareName>
 8011500:	4603      	mov	r3, r0
 8011502:	f1b3 3fff 	cmp.w	r3, #4294967295
 8011506:	d022      	beq.n	801154e <J1939_AddressClaimHandling+0x8e>
	{

		for (i=0; i<J1939_DATA_LENGTH; i++)
 8011508:	2300      	movs	r3, #0
 801150a:	73fb      	strb	r3, [r7, #15]
 801150c:	e00b      	b.n	8011526 <J1939_AddressClaimHandling+0x66>
			j1939_msg->Data[i] = CA_Name[i];
 801150e:	7bfb      	ldrb	r3, [r7, #15]
 8011510:	7bfa      	ldrb	r2, [r7, #15]
 8011512:	68b9      	ldr	r1, [r7, #8]
 8011514:	440a      	add	r2, r1
 8011516:	7811      	ldrb	r1, [r2, #0]
 8011518:	687a      	ldr	r2, [r7, #4]
 801151a:	4413      	add	r3, r2
 801151c:	460a      	mov	r2, r1
 801151e:	715a      	strb	r2, [r3, #5]
	//	return RC_ERROR;

	if (CompareName( j1939_msg->Data,CA_msg ) != -1) // Our CA_Name is not less
	{

		for (i=0; i<J1939_DATA_LENGTH; i++)
 8011520:	7bfb      	ldrb	r3, [r7, #15]
 8011522:	3301      	adds	r3, #1
 8011524:	73fb      	strb	r3, [r7, #15]
 8011526:	7bfb      	ldrb	r3, [r7, #15]
 8011528:	2b07      	cmp	r3, #7
 801152a:	d9f0      	bls.n	801150e <J1939_AddressClaimHandling+0x4e>
			j1939_msg->Data[i] = CA_Name[i];
		
		j1939_msg->SourceAddress = J1939_NULL_ADDRESS;
 801152c:	687b      	ldr	r3, [r7, #4]
 801152e:	22fe      	movs	r2, #254	; 0xfe
 8011530:	70da      	strb	r2, [r3, #3]
		if(writeCan(j1939_msg)== RC_SUCCESS)
 8011532:	6878      	ldr	r0, [r7, #4]
 8011534:	f000 f8b8 	bl	80116a8 <writeCan>
 8011538:	4603      	mov	r3, r0
 801153a:	2b00      	cmp	r3, #0
 801153c:	d105      	bne.n	801154a <J1939_AddressClaimHandling+0x8a>
		{
			CA_msg->nm.t250.release = 1;
 801153e:	683b      	ldr	r3, [r7, #0]
 8011540:	2201      	movs	r2, #1
 8011542:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
			return RC_SUCCESS;
 8011546:	2300      	movs	r3, #0
 8011548:	e042      	b.n	80115d0 <J1939_AddressClaimHandling+0x110>
		}
		else 
			return RC_CANNOTTRANSMIT;
 801154a:	230a      	movs	r3, #10
 801154c:	e040      	b.n	80115d0 <J1939_AddressClaimHandling+0x110>
	}
	
	for (i=0; i<J1939_DATA_LENGTH; i++)
 801154e:	2300      	movs	r3, #0
 8011550:	73fb      	strb	r3, [r7, #15]
 8011552:	e00b      	b.n	801156c <J1939_AddressClaimHandling+0xac>
		j1939_msg->Data[i] = CA_Name[i];
 8011554:	7bfb      	ldrb	r3, [r7, #15]
 8011556:	7bfa      	ldrb	r2, [r7, #15]
 8011558:	68b9      	ldr	r1, [r7, #8]
 801155a:	440a      	add	r2, r1
 801155c:	7811      	ldrb	r1, [r2, #0]
 801155e:	687a      	ldr	r2, [r7, #4]
 8011560:	4413      	add	r3, r2
 8011562:	460a      	mov	r2, r1
 8011564:	715a      	strb	r2, [r3, #5]
		}
		else 
			return RC_CANNOTTRANSMIT;
	}
	
	for (i=0; i<J1939_DATA_LENGTH; i++)
 8011566:	7bfb      	ldrb	r3, [r7, #15]
 8011568:	3301      	adds	r3, #1
 801156a:	73fb      	strb	r3, [r7, #15]
 801156c:	7bfb      	ldrb	r3, [r7, #15]
 801156e:	2b07      	cmp	r3, #7
 8011570:	d9f0      	bls.n	8011554 <J1939_AddressClaimHandling+0x94>
		j1939_msg->Data[i] = CA_Name[i];

	j1939_msg->SourceAddress = CA_msg->msg.SourceAddress;
 8011572:	683b      	ldr	r3, [r7, #0]
 8011574:	79da      	ldrb	r2, [r3, #7]
 8011576:	687b      	ldr	r3, [r7, #4]
 8011578:	70da      	strb	r2, [r3, #3]
	
	if (writeCan(j1939_msg ) == RC_SUCCESS)
 801157a:	6878      	ldr	r0, [r7, #4]
 801157c:	f000 f894 	bl	80116a8 <writeCan>
 8011580:	4603      	mov	r3, r0
 8011582:	2b00      	cmp	r3, #0
 8011584:	d121      	bne.n	80115ca <J1939_AddressClaimHandling+0x10a>
	{
		if ((( CA_msg->msg.SourceAddress & 0x80) == 0) ||			// Addresses 0-127
 8011586:	683b      	ldr	r3, [r7, #0]
 8011588:	79db      	ldrb	r3, [r3, #7]
 801158a:	b2db      	uxtb	r3, r3
 801158c:	b25b      	sxtb	r3, r3
 801158e:	2b00      	cmp	r3, #0
 8011590:	da05      	bge.n	801159e <J1939_AddressClaimHandling+0xde>
			(( CA_msg->msg.SourceAddress & 0xF8) == 0xF8))		// Addresses 248-253 (254,255 illegal)
 8011592:	683b      	ldr	r3, [r7, #0]
 8011594:	79db      	ldrb	r3, [r3, #7]
 8011596:	f003 03f8 	and.w	r3, r3, #248	; 0xf8

	j1939_msg->SourceAddress = CA_msg->msg.SourceAddress;
	
	if (writeCan(j1939_msg ) == RC_SUCCESS)
	{
		if ((( CA_msg->msg.SourceAddress & 0x80) == 0) ||			// Addresses 0-127
 801159a:	2bf8      	cmp	r3, #248	; 0xf8
 801159c:	d104      	bne.n	80115a8 <J1939_AddressClaimHandling+0xe8>
			(( CA_msg->msg.SourceAddress & 0xF8) == 0xF8))		// Addresses 248-253 (254,255 illegal)
		{
			CA_msg->nm.cannotClaimAddr = 0;
 801159e:	683b      	ldr	r3, [r7, #0]
 80115a0:	2200      	movs	r2, #0
 80115a2:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 80115a6:	e012      	b.n	80115ce <J1939_AddressClaimHandling+0x10e>
		}
		else
		{
			// We don't have a proprietary address, so we need to wait.
	 		CA_msg->nm.WaitingForAddressClaimContention = 1;
 80115a8:	683b      	ldr	r3, [r7, #0]
 80115aa:	2201      	movs	r2, #1
 80115ac:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
	 		//if (CA_msg->nm.WaitingForAddressClaimContention == 0)
	 		//{
			//	CA_msg->nm.cannotClaimAddr = 0;
	 		//}
			#if 1
			CA_msg->nm.t250.value = 250;
 80115b0:	683b      	ldr	r3, [r7, #0]
 80115b2:	22fa      	movs	r2, #250	; 0xfa
 80115b4:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
			CA_msg->nm.t250.en = 1;
 80115b8:	683b      	ldr	r3, [r7, #0]
 80115ba:	2201      	movs	r2, #1
 80115bc:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
			CA_msg->nm.t250.release = 0;
 80115c0:	683b      	ldr	r3, [r7, #0]
 80115c2:	2200      	movs	r2, #0
 80115c4:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
 80115c8:	e001      	b.n	80115ce <J1939_AddressClaimHandling+0x10e>
			#endif
		}
	}
	else 
		return RC_CANNOTTRANSMIT;
 80115ca:	230a      	movs	r3, #10
 80115cc:	e000      	b.n	80115d0 <J1939_AddressClaimHandling+0x110>
	return RC_SUCCESS;
 80115ce:	2300      	movs	r3, #0
}
 80115d0:	4618      	mov	r0, r3
 80115d2:	3710      	adds	r7, #16
 80115d4:	46bd      	mov	sp, r7
 80115d6:	bd80      	pop	{r7, pc}

080115d8 <sendAddrClaimed>:

unsigned char sendAddrClaimed(CA_Msg_t CA_msg)
{
 80115d8:	b580      	push	{r7, lr}
 80115da:	b088      	sub	sp, #32
 80115dc:	af00      	add	r7, sp, #0
 80115de:	6078      	str	r0, [r7, #4]
	struct J1939_msg j1939_msg;
	unsigned char *CA_Name = (unsigned char *)(CA_msg->CAname);
 80115e0:	687b      	ldr	r3, [r7, #4]
 80115e2:	681b      	ldr	r3, [r3, #0]
 80115e4:	61bb      	str	r3, [r7, #24]
	unsigned char i;
	
	CA_msg->nm.cannotClaimAddr = 1;
 80115e6:	687b      	ldr	r3, [r7, #4]
 80115e8:	2201      	movs	r2, #1
 80115ea:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
	
	j1939_msg.SourceAddress = CA_msg->msg.SourceAddress;		// Send Address Claim for current address
 80115ee:	687b      	ldr	r3, [r7, #4]
 80115f0:	79db      	ldrb	r3, [r3, #7]
 80115f2:	72fb      	strb	r3, [r7, #11]
	j1939_msg.Priority = 6;
 80115f4:	7a3b      	ldrb	r3, [r7, #8]
 80115f6:	2206      	movs	r2, #6
 80115f8:	f362 1347 	bfi	r3, r2, #5, #3
 80115fc:	723b      	strb	r3, [r7, #8]
	j1939_msg.edp = 0;
 80115fe:	7a3b      	ldrb	r3, [r7, #8]
 8011600:	f36f 1304 	bfc	r3, #4, #1
 8011604:	723b      	strb	r3, [r7, #8]
	j1939_msg.DataPage = 0;
 8011606:	7a3b      	ldrb	r3, [r7, #8]
 8011608:	f36f 03c3 	bfc	r3, #3, #1
 801160c:	723b      	strb	r3, [r7, #8]
	j1939_msg.PDUFormat = J1939_PF_ADDRESS_CLAIMED;	// Same as J1939_PF_CANNOT_CLAIM_ADDRESS
 801160e:	23ee      	movs	r3, #238	; 0xee
 8011610:	727b      	strb	r3, [r7, #9]
	j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
 8011612:	23ff      	movs	r3, #255	; 0xff
 8011614:	72bb      	strb	r3, [r7, #10]
	j1939_msg.DataLength = J1939_DATA_LENGTH;
 8011616:	7b3b      	ldrb	r3, [r7, #12]
 8011618:	2208      	movs	r2, #8
 801161a:	f362 0303 	bfi	r3, r2, #0, #4
 801161e:	733b      	strb	r3, [r7, #12]

	for (i=0; i<J1939_DATA_LENGTH; i++)
 8011620:	2300      	movs	r3, #0
 8011622:	77fb      	strb	r3, [r7, #31]
 8011624:	e00c      	b.n	8011640 <sendAddrClaimed+0x68>
		j1939_msg.Data[i] = CA_Name[i];
 8011626:	7ffb      	ldrb	r3, [r7, #31]
 8011628:	7ffa      	ldrb	r2, [r7, #31]
 801162a:	69b9      	ldr	r1, [r7, #24]
 801162c:	440a      	add	r2, r1
 801162e:	7812      	ldrb	r2, [r2, #0]
 8011630:	f107 0120 	add.w	r1, r7, #32
 8011634:	440b      	add	r3, r1
 8011636:	f803 2c13 	strb.w	r2, [r3, #-19]
	j1939_msg.DataPage = 0;
	j1939_msg.PDUFormat = J1939_PF_ADDRESS_CLAIMED;	// Same as J1939_PF_CANNOT_CLAIM_ADDRESS
	j1939_msg.PDUSpecific = J1939_GLOBAL_ADDRESS;
	j1939_msg.DataLength = J1939_DATA_LENGTH;

	for (i=0; i<J1939_DATA_LENGTH; i++)
 801163a:	7ffb      	ldrb	r3, [r7, #31]
 801163c:	3301      	adds	r3, #1
 801163e:	77fb      	strb	r3, [r7, #31]
 8011640:	7ffb      	ldrb	r3, [r7, #31]
 8011642:	2b07      	cmp	r3, #7
 8011644:	d9ef      	bls.n	8011626 <sendAddrClaimed+0x4e>
		j1939_msg.Data[i] = CA_Name[i];
	
	if(writeCan(&j1939_msg)==RC_SUCCESS)
 8011646:	f107 0308 	add.w	r3, r7, #8
 801164a:	4618      	mov	r0, r3
 801164c:	f000 f82c 	bl	80116a8 <writeCan>
 8011650:	4603      	mov	r3, r0
 8011652:	2b00      	cmp	r3, #0
 8011654:	d111      	bne.n	801167a <sendAddrClaimed+0xa2>
	{
		// We don't have a proprietary address, so we need to wait.
		CA_msg->nm.WaitingForAddressClaimContention = 1;
 8011656:	687b      	ldr	r3, [r7, #4]
 8011658:	2201      	movs	r2, #1
 801165a:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
		//if (CA_msg->nm.WaitingForAddressClaimContention == 0)
		//{
		//	CA_msg->nm.cannotClaimAddr = 0;
		//}
		#if 1
		CA_msg->nm.t250.value = 250;
 801165e:	687b      	ldr	r3, [r7, #4]
 8011660:	22fa      	movs	r2, #250	; 0xfa
 8011662:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
		CA_msg->nm.t250.en = 1;
 8011666:	687b      	ldr	r3, [r7, #4]
 8011668:	2201      	movs	r2, #1
 801166a:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
		CA_msg->nm.t250.release = 0;
 801166e:	687b      	ldr	r3, [r7, #4]
 8011670:	2200      	movs	r2, #0
 8011672:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
		#endif

		return RC_SUCCESS;
 8011676:	2300      	movs	r3, #0
 8011678:	e000      	b.n	801167c <sendAddrClaimed+0xa4>
	}
	return RC_CANNOTTRANSMIT;
 801167a:	230a      	movs	r3, #10
}
 801167c:	4618      	mov	r0, r3
 801167e:	3720      	adds	r7, #32
 8011680:	46bd      	mov	sp, r7
 8011682:	bd80      	pop	{r7, pc}

08011684 <initAddr>:


unsigned char initAddr(CA_Msg_t ca_msg)
{
 8011684:	b580      	push	{r7, lr}
 8011686:	b082      	sub	sp, #8
 8011688:	af00      	add	r7, sp, #0
 801168a:	6078      	str	r0, [r7, #4]
	if(ca_msg->msg.SourceAddress != 254)
 801168c:	687b      	ldr	r3, [r7, #4]
 801168e:	79db      	ldrb	r3, [r3, #7]
 8011690:	2bfe      	cmp	r3, #254	; 0xfe
 8011692:	d004      	beq.n	801169e <initAddr+0x1a>
	{
		return sendAddrClaimed(ca_msg);
 8011694:	6878      	ldr	r0, [r7, #4]
 8011696:	f7ff ff9f 	bl	80115d8 <sendAddrClaimed>
 801169a:	4603      	mov	r3, r0
 801169c:	e000      	b.n	80116a0 <initAddr+0x1c>
	}
	return RC_ERROR;
 801169e:	2301      	movs	r3, #1
}
 80116a0:	4618      	mov	r0, r3
 80116a2:	3708      	adds	r7, #8
 80116a4:	46bd      	mov	sp, r7
 80116a6:	bd80      	pop	{r7, pc}

080116a8 <writeCan>:
#include "finsh.h"
#include <rtdevice.h>
#include "SAEJ1939.h"

unsigned char writeCan(J1939_msg_t j1939_msg)
{
 80116a8:	b580      	push	{r7, lr}
 80116aa:	b088      	sub	sp, #32
 80116ac:	af00      	add	r7, sp, #0
 80116ae:	6078      	str	r0, [r7, #4]
	rt_device_t device;
	device = rt_device_find("can1");
 80116b0:	4831      	ldr	r0, [pc, #196]	; (8011778 <writeCan+0xd0>)
 80116b2:	f003 fe9f 	bl	80153f4 <rt_device_find>
 80116b6:	61f8      	str	r0, [r7, #28]
	struct rt_can_msg tmpmsg;
	unsigned long tmp;
	
	if(device != NULL)
 80116b8:	69fb      	ldr	r3, [r7, #28]
 80116ba:	2b00      	cmp	r3, #0
 80116bc:	d057      	beq.n	801176e <writeCan+0xc6>
	{
		tmpmsg.data[7] = j1939_msg->Data[7];
 80116be:	687b      	ldr	r3, [r7, #4]
 80116c0:	7b1b      	ldrb	r3, [r3, #12]
 80116c2:	75fb      	strb	r3, [r7, #23]
		tmpmsg.data[6] = j1939_msg->Data[6];
 80116c4:	687b      	ldr	r3, [r7, #4]
 80116c6:	7adb      	ldrb	r3, [r3, #11]
 80116c8:	75bb      	strb	r3, [r7, #22]
		tmpmsg.data[5] = j1939_msg->Data[5];
 80116ca:	687b      	ldr	r3, [r7, #4]
 80116cc:	7a9b      	ldrb	r3, [r3, #10]
 80116ce:	757b      	strb	r3, [r7, #21]
		tmpmsg.data[4] = j1939_msg->Data[4];
 80116d0:	687b      	ldr	r3, [r7, #4]
 80116d2:	7a5b      	ldrb	r3, [r3, #9]
 80116d4:	753b      	strb	r3, [r7, #20]
		tmpmsg.data[3] = j1939_msg->Data[3];
 80116d6:	687b      	ldr	r3, [r7, #4]
 80116d8:	7a1b      	ldrb	r3, [r3, #8]
 80116da:	74fb      	strb	r3, [r7, #19]
		tmpmsg.data[2] = j1939_msg->Data[2];
 80116dc:	687b      	ldr	r3, [r7, #4]
 80116de:	79db      	ldrb	r3, [r3, #7]
 80116e0:	74bb      	strb	r3, [r7, #18]
		tmpmsg.data[1] = j1939_msg->Data[1];
 80116e2:	687b      	ldr	r3, [r7, #4]
 80116e4:	799b      	ldrb	r3, [r3, #6]
 80116e6:	747b      	strb	r3, [r7, #17]
		tmpmsg.data[0] = j1939_msg->Data[0];
 80116e8:	687b      	ldr	r3, [r7, #4]
 80116ea:	795b      	ldrb	r3, [r3, #5]
 80116ec:	743b      	strb	r3, [r7, #16]
		tmp = (unsigned long)(j1939_msg->Priority)<<26 			| 	\
 80116ee:	687b      	ldr	r3, [r7, #4]
 80116f0:	781b      	ldrb	r3, [r3, #0]
 80116f2:	f3c3 1342 	ubfx	r3, r3, #5, #3
 80116f6:	b2db      	uxtb	r3, r3
 80116f8:	069a      	lsls	r2, r3, #26
				(unsigned long)(j1939_msg->edp)<<25				|  	\
 80116fa:	687b      	ldr	r3, [r7, #4]
 80116fc:	781b      	ldrb	r3, [r3, #0]
 80116fe:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8011702:	b2db      	uxtb	r3, r3
 8011704:	065b      	lsls	r3, r3, #25
		tmpmsg.data[4] = j1939_msg->Data[4];
		tmpmsg.data[3] = j1939_msg->Data[3];
		tmpmsg.data[2] = j1939_msg->Data[2];
		tmpmsg.data[1] = j1939_msg->Data[1];
		tmpmsg.data[0] = j1939_msg->Data[0];
		tmp = (unsigned long)(j1939_msg->Priority)<<26 			| 	\
 8011706:	431a      	orrs	r2, r3
				(unsigned long)(j1939_msg->edp)<<25				|  	\
				(unsigned long)(j1939_msg->DataPage)<<24				|  	\
 8011708:	687b      	ldr	r3, [r7, #4]
 801170a:	781b      	ldrb	r3, [r3, #0]
 801170c:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8011710:	b2db      	uxtb	r3, r3
 8011712:	061b      	lsls	r3, r3, #24
		tmpmsg.data[3] = j1939_msg->Data[3];
		tmpmsg.data[2] = j1939_msg->Data[2];
		tmpmsg.data[1] = j1939_msg->Data[1];
		tmpmsg.data[0] = j1939_msg->Data[0];
		tmp = (unsigned long)(j1939_msg->Priority)<<26 			| 	\
				(unsigned long)(j1939_msg->edp)<<25				|  	\
 8011714:	431a      	orrs	r2, r3
				(unsigned long)(j1939_msg->DataPage)<<24				|  	\
				(unsigned long)(j1939_msg->PDUFormat)<<16		|  	\
 8011716:	687b      	ldr	r3, [r7, #4]
 8011718:	785b      	ldrb	r3, [r3, #1]
 801171a:	041b      	lsls	r3, r3, #16
		tmpmsg.data[2] = j1939_msg->Data[2];
		tmpmsg.data[1] = j1939_msg->Data[1];
		tmpmsg.data[0] = j1939_msg->Data[0];
		tmp = (unsigned long)(j1939_msg->Priority)<<26 			| 	\
				(unsigned long)(j1939_msg->edp)<<25				|  	\
				(unsigned long)(j1939_msg->DataPage)<<24				|  	\
 801171c:	431a      	orrs	r2, r3
				(unsigned long)(j1939_msg->PDUFormat)<<16		|  	\
				(unsigned long)(j1939_msg->PDUSpecific)<<8		|	\
 801171e:	687b      	ldr	r3, [r7, #4]
 8011720:	789b      	ldrb	r3, [r3, #2]
 8011722:	021b      	lsls	r3, r3, #8
		tmpmsg.data[1] = j1939_msg->Data[1];
		tmpmsg.data[0] = j1939_msg->Data[0];
		tmp = (unsigned long)(j1939_msg->Priority)<<26 			| 	\
				(unsigned long)(j1939_msg->edp)<<25				|  	\
				(unsigned long)(j1939_msg->DataPage)<<24				|  	\
				(unsigned long)(j1939_msg->PDUFormat)<<16		|  	\
 8011724:	4313      	orrs	r3, r2
				(unsigned long)(j1939_msg->PDUSpecific)<<8		|	\
				(unsigned long)(j1939_msg->SourceAddress);		
 8011726:	687a      	ldr	r2, [r7, #4]
 8011728:	78d2      	ldrb	r2, [r2, #3]
		tmpmsg.data[4] = j1939_msg->Data[4];
		tmpmsg.data[3] = j1939_msg->Data[3];
		tmpmsg.data[2] = j1939_msg->Data[2];
		tmpmsg.data[1] = j1939_msg->Data[1];
		tmpmsg.data[0] = j1939_msg->Data[0];
		tmp = (unsigned long)(j1939_msg->Priority)<<26 			| 	\
 801172a:	4313      	orrs	r3, r2
 801172c:	61bb      	str	r3, [r7, #24]
				(unsigned long)(j1939_msg->edp)<<25				|  	\
				(unsigned long)(j1939_msg->DataPage)<<24				|  	\
				(unsigned long)(j1939_msg->PDUFormat)<<16		|  	\
				(unsigned long)(j1939_msg->PDUSpecific)<<8		|	\
				(unsigned long)(j1939_msg->SourceAddress);		
		tmpmsg.id = tmp;
 801172e:	69bb      	ldr	r3, [r7, #24]
 8011730:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
 8011734:	68bb      	ldr	r3, [r7, #8]
 8011736:	f362 031c 	bfi	r3, r2, #0, #29
 801173a:	60bb      	str	r3, [r7, #8]
		tmpmsg.ide = 1;
 801173c:	7afb      	ldrb	r3, [r7, #11]
 801173e:	f043 0320 	orr.w	r3, r3, #32
 8011742:	72fb      	strb	r3, [r7, #11]
		tmpmsg.len = j1939_msg->DataLength;
 8011744:	687b      	ldr	r3, [r7, #4]
 8011746:	791b      	ldrb	r3, [r3, #4]
 8011748:	f3c3 0303 	ubfx	r3, r3, #0, #4
 801174c:	b2db      	uxtb	r3, r3
 801174e:	733b      	strb	r3, [r7, #12]
		tmpmsg.rtr = 0;
 8011750:	7afb      	ldrb	r3, [r7, #11]
 8011752:	f36f 1386 	bfc	r3, #6, #1
 8011756:	72fb      	strb	r3, [r7, #11]
		
		return rt_device_write(device, 0, &tmpmsg,1);
 8011758:	f107 0308 	add.w	r3, r7, #8
 801175c:	69f8      	ldr	r0, [r7, #28]
 801175e:	2100      	movs	r1, #0
 8011760:	461a      	mov	r2, r3
 8011762:	2301      	movs	r3, #1
 8011764:	f003 ff68 	bl	8015638 <rt_device_write>
 8011768:	4603      	mov	r3, r0
 801176a:	b2db      	uxtb	r3, r3
 801176c:	e000      	b.n	8011770 <writeCan+0xc8>
	}
	return RC_ERROR;
 801176e:	2301      	movs	r3, #1
}
 8011770:	4618      	mov	r0, r3
 8011772:	3720      	adds	r7, #32
 8011774:	46bd      	mov	sp, r7
 8011776:	bd80      	pop	{r7, pc}
 8011778:	080287ac 	.word	0x080287ac

0801177c <readCan>:

unsigned char readCan(J1939_msg_t j1939_msg)
{
 801177c:	b580      	push	{r7, lr}
 801177e:	b08a      	sub	sp, #40	; 0x28
 8011780:	af00      	add	r7, sp, #0
 8011782:	6078      	str	r0, [r7, #4]
	rt_device_t device;
	device = rt_device_find("can1");
 8011784:	4841      	ldr	r0, [pc, #260]	; (801188c <readCan+0x110>)
 8011786:	f003 fe35 	bl	80153f4 <rt_device_find>
 801178a:	6238      	str	r0, [r7, #32]
	struct rt_can_msg tmpmsg;
	unsigned char i,size;
	unsigned char result;
	
	if(device != NULL)
 801178c:	6a3b      	ldr	r3, [r7, #32]
 801178e:	2b00      	cmp	r3, #0
 8011790:	d077      	beq.n	8011882 <readCan+0x106>
	{
		size = rt_device_read(device,0,&tmpmsg,sizeof(struct rt_can_msg));
 8011792:	f107 030c 	add.w	r3, r7, #12
 8011796:	6a38      	ldr	r0, [r7, #32]
 8011798:	2100      	movs	r1, #0
 801179a:	461a      	mov	r2, r3
 801179c:	2310      	movs	r3, #16
 801179e:	f003 ff17 	bl	80155d0 <rt_device_read>
 80117a2:	4603      	mov	r3, r0
 80117a4:	77fb      	strb	r3, [r7, #31]
		if (size != 0)
 80117a6:	7ffb      	ldrb	r3, [r7, #31]
 80117a8:	2b00      	cmp	r3, #0
 80117aa:	d066      	beq.n	801187a <readCan+0xfe>
		{
			j1939_msg->Priority = tmpmsg.id >> 26;
 80117ac:	68fb      	ldr	r3, [r7, #12]
 80117ae:	f3c3 031c 	ubfx	r3, r3, #0, #29
 80117b2:	169b      	asrs	r3, r3, #26
 80117b4:	b2db      	uxtb	r3, r3
 80117b6:	f003 0307 	and.w	r3, r3, #7
 80117ba:	b2d9      	uxtb	r1, r3
 80117bc:	687a      	ldr	r2, [r7, #4]
 80117be:	7813      	ldrb	r3, [r2, #0]
 80117c0:	f361 1347 	bfi	r3, r1, #5, #3
 80117c4:	7013      	strb	r3, [r2, #0]
			j1939_msg->edp = tmpmsg.id >> 25;
 80117c6:	68fb      	ldr	r3, [r7, #12]
 80117c8:	f3c3 031c 	ubfx	r3, r3, #0, #29
 80117cc:	165b      	asrs	r3, r3, #25
 80117ce:	b2db      	uxtb	r3, r3
 80117d0:	f003 0301 	and.w	r3, r3, #1
 80117d4:	b2d9      	uxtb	r1, r3
 80117d6:	687a      	ldr	r2, [r7, #4]
 80117d8:	7813      	ldrb	r3, [r2, #0]
 80117da:	f361 1304 	bfi	r3, r1, #4, #1
 80117de:	7013      	strb	r3, [r2, #0]
			j1939_msg->DataPage = tmpmsg.id >> 24;
 80117e0:	68fb      	ldr	r3, [r7, #12]
 80117e2:	f3c3 031c 	ubfx	r3, r3, #0, #29
 80117e6:	161b      	asrs	r3, r3, #24
 80117e8:	b2db      	uxtb	r3, r3
 80117ea:	f003 0301 	and.w	r3, r3, #1
 80117ee:	b2d9      	uxtb	r1, r3
 80117f0:	687a      	ldr	r2, [r7, #4]
 80117f2:	7813      	ldrb	r3, [r2, #0]
 80117f4:	f361 03c3 	bfi	r3, r1, #3, #1
 80117f8:	7013      	strb	r3, [r2, #0]
			j1939_msg->PDUFormat = tmpmsg.id >> 16;
 80117fa:	68fb      	ldr	r3, [r7, #12]
 80117fc:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8011800:	141b      	asrs	r3, r3, #16
 8011802:	b2da      	uxtb	r2, r3
 8011804:	687b      	ldr	r3, [r7, #4]
 8011806:	705a      	strb	r2, [r3, #1]
			j1939_msg->PDUSpecific = tmpmsg.id >> 8;
 8011808:	68fb      	ldr	r3, [r7, #12]
 801180a:	f3c3 031c 	ubfx	r3, r3, #0, #29
 801180e:	121b      	asrs	r3, r3, #8
 8011810:	b2da      	uxtb	r2, r3
 8011812:	687b      	ldr	r3, [r7, #4]
 8011814:	709a      	strb	r2, [r3, #2]
			j1939_msg->SourceAddress = tmpmsg.id;
 8011816:	68fb      	ldr	r3, [r7, #12]
 8011818:	f3c3 031c 	ubfx	r3, r3, #0, #29
 801181c:	b2da      	uxtb	r2, r3
 801181e:	687b      	ldr	r3, [r7, #4]
 8011820:	70da      	strb	r2, [r3, #3]
			j1939_msg->DataLength = tmpmsg.len;
 8011822:	7c3b      	ldrb	r3, [r7, #16]
 8011824:	f003 030f 	and.w	r3, r3, #15
 8011828:	b2d9      	uxtb	r1, r3
 801182a:	687a      	ldr	r2, [r7, #4]
 801182c:	7913      	ldrb	r3, [r2, #4]
 801182e:	f361 0303 	bfi	r3, r1, #0, #4
 8011832:	7113      	strb	r3, [r2, #4]
			for(i=0;i<j1939_msg->DataLength;i++)
 8011834:	2300      	movs	r3, #0
 8011836:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 801183a:	e011      	b.n	8011860 <readCan+0xe4>
			{
				j1939_msg->Data[i] = tmpmsg.data[i];
 801183c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8011840:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 8011844:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8011848:	440a      	add	r2, r1
 801184a:	f812 1c14 	ldrb.w	r1, [r2, #-20]
 801184e:	687a      	ldr	r2, [r7, #4]
 8011850:	4413      	add	r3, r2
 8011852:	460a      	mov	r2, r1
 8011854:	715a      	strb	r2, [r3, #5]
			j1939_msg->DataPage = tmpmsg.id >> 24;
			j1939_msg->PDUFormat = tmpmsg.id >> 16;
			j1939_msg->PDUSpecific = tmpmsg.id >> 8;
			j1939_msg->SourceAddress = tmpmsg.id;
			j1939_msg->DataLength = tmpmsg.len;
			for(i=0;i<j1939_msg->DataLength;i++)
 8011856:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801185a:	3301      	adds	r3, #1
 801185c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8011860:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8011864:	687a      	ldr	r2, [r7, #4]
 8011866:	7912      	ldrb	r2, [r2, #4]
 8011868:	f3c2 0203 	ubfx	r2, r2, #0, #4
 801186c:	b2d2      	uxtb	r2, r2
 801186e:	4293      	cmp	r3, r2
 8011870:	dbe4      	blt.n	801183c <readCan+0xc0>
			{
				j1939_msg->Data[i] = tmpmsg.data[i];
			}
			return result = RC_SUCCESS;
 8011872:	2300      	movs	r3, #0
 8011874:	77bb      	strb	r3, [r7, #30]
 8011876:	7fbb      	ldrb	r3, [r7, #30]
 8011878:	e004      	b.n	8011884 <readCan+0x108>
		}
		else
			return result = RC_QUEUEEMPTY;
 801187a:	2309      	movs	r3, #9
 801187c:	77bb      	strb	r3, [r7, #30]
 801187e:	7fbb      	ldrb	r3, [r7, #30]
 8011880:	e000      	b.n	8011884 <readCan+0x108>
	}
	return RC_ERROR;
 8011882:	2301      	movs	r3, #1
}
 8011884:	4618      	mov	r0, r3
 8011886:	3728      	adds	r7, #40	; 0x28
 8011888:	46bd      	mov	sp, r7
 801188a:	bd80      	pop	{r7, pc}
 801188c:	080287ac 	.word	0x080287ac

08011890 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 8011890:	b480      	push	{r7}
 8011892:	b083      	sub	sp, #12
 8011894:	af00      	add	r7, sp, #0
 8011896:	6078      	str	r0, [r7, #4]
 8011898:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 801189a:	687b      	ldr	r3, [r7, #4]
 801189c:	685b      	ldr	r3, [r3, #4]
 801189e:	683a      	ldr	r2, [r7, #0]
 80118a0:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 80118a2:	687b      	ldr	r3, [r7, #4]
 80118a4:	685a      	ldr	r2, [r3, #4]
 80118a6:	683b      	ldr	r3, [r7, #0]
 80118a8:	605a      	str	r2, [r3, #4]

    l->prev = n;
 80118aa:	687b      	ldr	r3, [r7, #4]
 80118ac:	683a      	ldr	r2, [r7, #0]
 80118ae:	605a      	str	r2, [r3, #4]
    n->next = l;
 80118b0:	683b      	ldr	r3, [r7, #0]
 80118b2:	687a      	ldr	r2, [r7, #4]
 80118b4:	601a      	str	r2, [r3, #0]
}
 80118b6:	370c      	adds	r7, #12
 80118b8:	46bd      	mov	sp, r7
 80118ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80118be:	4770      	bx	lr

080118c0 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 80118c0:	b480      	push	{r7}
 80118c2:	b083      	sub	sp, #12
 80118c4:	af00      	add	r7, sp, #0
 80118c6:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 80118c8:	687b      	ldr	r3, [r7, #4]
 80118ca:	681b      	ldr	r3, [r3, #0]
 80118cc:	687a      	ldr	r2, [r7, #4]
 80118ce:	6852      	ldr	r2, [r2, #4]
 80118d0:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 80118d2:	687b      	ldr	r3, [r7, #4]
 80118d4:	685b      	ldr	r3, [r3, #4]
 80118d6:	687a      	ldr	r2, [r7, #4]
 80118d8:	6812      	ldr	r2, [r2, #0]
 80118da:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 80118dc:	687b      	ldr	r3, [r7, #4]
 80118de:	687a      	ldr	r2, [r7, #4]
 80118e0:	605a      	str	r2, [r3, #4]
 80118e2:	687b      	ldr	r3, [r7, #4]
 80118e4:	685a      	ldr	r2, [r3, #4]
 80118e6:	687b      	ldr	r3, [r7, #4]
 80118e8:	601a      	str	r2, [r3, #0]
}
 80118ea:	370c      	adds	r7, #12
 80118ec:	46bd      	mov	sp, r7
 80118ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80118f2:	4770      	bx	lr

080118f4 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 80118f4:	b480      	push	{r7}
 80118f6:	b083      	sub	sp, #12
 80118f8:	af00      	add	r7, sp, #0
 80118fa:	6078      	str	r0, [r7, #4]
    return l->next == l;
 80118fc:	687b      	ldr	r3, [r7, #4]
 80118fe:	681a      	ldr	r2, [r3, #0]
 8011900:	687b      	ldr	r3, [r7, #4]
 8011902:	429a      	cmp	r2, r3
 8011904:	bf0c      	ite	eq
 8011906:	2301      	moveq	r3, #1
 8011908:	2300      	movne	r3, #0
 801190a:	b2db      	uxtb	r3, r3
}
 801190c:	4618      	mov	r0, r3
 801190e:	370c      	adds	r7, #12
 8011910:	46bd      	mov	sp, r7
 8011912:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011916:	4770      	bx	lr

08011918 <HAL_CAN_TxCpltCallback>:

struct rt_can_device canDevice1;
stm32_canTypeDef can1;

void HAL_CAN_TxCpltCallback(CAN_HandleTypeDef* hcan)
{
 8011918:	b480      	push	{r7}
 801191a:	b083      	sub	sp, #12
 801191c:	af00      	add	r7, sp, #0
 801191e:	6078      	str	r0, [r7, #4]
	//rt_kprintf("tx complete\r\n");
}
 8011920:	370c      	adds	r7, #12
 8011922:	46bd      	mov	sp, r7
 8011924:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011928:	4770      	bx	lr
 801192a:	bf00      	nop

0801192c <CAN1_TX_IRQHandler>:

void CAN1_TX_IRQHandler(void)
{
 801192c:	b580      	push	{r7, lr}
 801192e:	b090      	sub	sp, #64	; 0x40
 8011930:	af00      	add	r7, sp, #0
	CAN_HandleTypeDef hcan;
	/* enter interrupt */
    rt_interrupt_enter();
 8011932:	f004 fddd 	bl	80164f0 <rt_interrupt_enter>

	hcan.Instance = CAN1;
 8011936:	4b05      	ldr	r3, [pc, #20]	; (801194c <CAN1_TX_IRQHandler+0x20>)
 8011938:	603b      	str	r3, [r7, #0]
	HAL_CAN_IRQHandler(&hcan);
 801193a:	463b      	mov	r3, r7
 801193c:	4618      	mov	r0, r3
 801193e:	f7f6 f89b 	bl	8007a78 <HAL_CAN_IRQHandler>

    /* leave interrupt */
    rt_interrupt_leave();
 8011942:	f004 fdeb 	bl	801651c <rt_interrupt_leave>

}
 8011946:	3740      	adds	r7, #64	; 0x40
 8011948:	46bd      	mov	sp, r7
 801194a:	bd80      	pop	{r7, pc}
 801194c:	40006400 	.word	0x40006400

08011950 <HAL_CAN_RxCpltCallback>:

void HAL_CAN_RxCpltCallback(CAN_HandleTypeDef* hcan)
{
 8011950:	b480      	push	{r7}
 8011952:	b083      	sub	sp, #12
 8011954:	af00      	add	r7, sp, #0
 8011956:	6078      	str	r0, [r7, #4]
	{
		rt_kprintf("0x%x ", hcan->pRxMsg->Data[i]);
	}
	rt_kprintf("\r\n");
	#endif
}
 8011958:	370c      	adds	r7, #12
 801195a:	46bd      	mov	sp, r7
 801195c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011960:	4770      	bx	lr
 8011962:	bf00      	nop

08011964 <CAN1_RX0_IRQHandler>:

void CAN1_RX0_IRQHandler(void)
{
 8011964:	b580      	push	{r7, lr}
 8011966:	b090      	sub	sp, #64	; 0x40
 8011968:	af00      	add	r7, sp, #0
	
	CAN_HandleTypeDef hcan;
	/* enter interrupt */
	
    rt_interrupt_enter();
 801196a:	f004 fdc1 	bl	80164f0 <rt_interrupt_enter>
	hcan.Instance = CAN1;
 801196e:	4b05      	ldr	r3, [pc, #20]	; (8011984 <CAN1_RX0_IRQHandler+0x20>)
 8011970:	603b      	str	r3, [r7, #0]
	
	HAL_CAN_IRQHandler(&hcan);
 8011972:	463b      	mov	r3, r7
 8011974:	4618      	mov	r0, r3
 8011976:	f7f6 f87f 	bl	8007a78 <HAL_CAN_IRQHandler>

    /* leave interrupt */
    rt_interrupt_leave();
 801197a:	f004 fdcf 	bl	801651c <rt_interrupt_leave>

}
 801197e:	3740      	adds	r7, #64	; 0x40
 8011980:	46bd      	mov	sp, r7
 8011982:	bd80      	pop	{r7, pc}
 8011984:	40006400 	.word	0x40006400

08011988 <CAN1_RX1_IRQHandler>:

void CAN1_RX1_IRQHandler(void)
{
 8011988:	b580      	push	{r7, lr}
 801198a:	b090      	sub	sp, #64	; 0x40
 801198c:	af00      	add	r7, sp, #0
	
	CAN_HandleTypeDef hcan;
	/* enter interrupt */
	rt_interrupt_enter();
 801198e:	f004 fdaf 	bl	80164f0 <rt_interrupt_enter>

	hcan.Instance = CAN1;
 8011992:	4b05      	ldr	r3, [pc, #20]	; (80119a8 <CAN1_RX1_IRQHandler+0x20>)
 8011994:	603b      	str	r3, [r7, #0]
	HAL_CAN_IRQHandler(&hcan);
 8011996:	463b      	mov	r3, r7
 8011998:	4618      	mov	r0, r3
 801199a:	f7f6 f86d 	bl	8007a78 <HAL_CAN_IRQHandler>

	/* leave interrupt */
	rt_interrupt_leave();
 801199e:	f004 fdbd 	bl	801651c <rt_interrupt_leave>

}
 80119a2:	3740      	adds	r7, #64	; 0x40
 80119a4:	46bd      	mov	sp, r7
 80119a6:	bd80      	pop	{r7, pc}
 80119a8:	40006400 	.word	0x40006400

080119ac <HAL_CAN_ErrorCallback>:

void HAL_CAN_ErrorCallback(CAN_HandleTypeDef *hcan)
{
 80119ac:	b580      	push	{r7, lr}
 80119ae:	b082      	sub	sp, #8
 80119b0:	af00      	add	r7, sp, #0
 80119b2:	6078      	str	r0, [r7, #4]
	
	if((hcan->ErrorCode & HAL_CAN_ERROR_EWG) == HAL_CAN_ERROR_EWG)
 80119b4:	687b      	ldr	r3, [r7, #4]
 80119b6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80119b8:	f003 0301 	and.w	r3, r3, #1
 80119bc:	2b00      	cmp	r3, #0
 80119be:	d002      	beq.n	80119c6 <HAL_CAN_ErrorCallback+0x1a>
		rt_kprintf("ewg error\r\n");
 80119c0:	4826      	ldr	r0, [pc, #152]	; (8011a5c <HAL_CAN_ErrorCallback+0xb0>)
 80119c2:	f005 fba5 	bl	8017110 <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_EPV) == HAL_CAN_ERROR_EPV)
 80119c6:	687b      	ldr	r3, [r7, #4]
 80119c8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80119ca:	f003 0302 	and.w	r3, r3, #2
 80119ce:	2b00      	cmp	r3, #0
 80119d0:	d002      	beq.n	80119d8 <HAL_CAN_ErrorCallback+0x2c>
		rt_kprintf("epv error\r\n");
 80119d2:	4823      	ldr	r0, [pc, #140]	; (8011a60 <HAL_CAN_ErrorCallback+0xb4>)
 80119d4:	f005 fb9c 	bl	8017110 <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_BOF) == HAL_CAN_ERROR_BOF)
 80119d8:	687b      	ldr	r3, [r7, #4]
 80119da:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80119dc:	f003 0304 	and.w	r3, r3, #4
 80119e0:	2b00      	cmp	r3, #0
 80119e2:	d002      	beq.n	80119ea <HAL_CAN_ErrorCallback+0x3e>
		rt_kprintf("bof error\r\n");
 80119e4:	481f      	ldr	r0, [pc, #124]	; (8011a64 <HAL_CAN_ErrorCallback+0xb8>)
 80119e6:	f005 fb93 	bl	8017110 <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_STF) == HAL_CAN_ERROR_STF)
 80119ea:	687b      	ldr	r3, [r7, #4]
 80119ec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80119ee:	f003 0308 	and.w	r3, r3, #8
 80119f2:	2b00      	cmp	r3, #0
 80119f4:	d002      	beq.n	80119fc <HAL_CAN_ErrorCallback+0x50>
		rt_kprintf("stf error\r\n");
 80119f6:	481c      	ldr	r0, [pc, #112]	; (8011a68 <HAL_CAN_ErrorCallback+0xbc>)
 80119f8:	f005 fb8a 	bl	8017110 <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_FOR) == HAL_CAN_ERROR_FOR)
 80119fc:	687b      	ldr	r3, [r7, #4]
 80119fe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8011a00:	f003 0310 	and.w	r3, r3, #16
 8011a04:	2b00      	cmp	r3, #0
 8011a06:	d002      	beq.n	8011a0e <HAL_CAN_ErrorCallback+0x62>
		rt_kprintf("for error\r\n");
 8011a08:	4818      	ldr	r0, [pc, #96]	; (8011a6c <HAL_CAN_ErrorCallback+0xc0>)
 8011a0a:	f005 fb81 	bl	8017110 <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_ACK) == HAL_CAN_ERROR_ACK)
 8011a0e:	687b      	ldr	r3, [r7, #4]
 8011a10:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8011a12:	f003 0320 	and.w	r3, r3, #32
 8011a16:	2b00      	cmp	r3, #0
 8011a18:	d002      	beq.n	8011a20 <HAL_CAN_ErrorCallback+0x74>
		rt_kprintf("ack error\r\n");
 8011a1a:	4815      	ldr	r0, [pc, #84]	; (8011a70 <HAL_CAN_ErrorCallback+0xc4>)
 8011a1c:	f005 fb78 	bl	8017110 <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_BR) == HAL_CAN_ERROR_BR)
 8011a20:	687b      	ldr	r3, [r7, #4]
 8011a22:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8011a24:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8011a28:	2b00      	cmp	r3, #0
 8011a2a:	d002      	beq.n	8011a32 <HAL_CAN_ErrorCallback+0x86>
		rt_kprintf("br error\r\n");
 8011a2c:	4811      	ldr	r0, [pc, #68]	; (8011a74 <HAL_CAN_ErrorCallback+0xc8>)
 8011a2e:	f005 fb6f 	bl	8017110 <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_BD) == HAL_CAN_ERROR_BD)
 8011a32:	687b      	ldr	r3, [r7, #4]
 8011a34:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8011a36:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8011a3a:	2b00      	cmp	r3, #0
 8011a3c:	d002      	beq.n	8011a44 <HAL_CAN_ErrorCallback+0x98>
		rt_kprintf("bd error\r\n");
 8011a3e:	480e      	ldr	r0, [pc, #56]	; (8011a78 <HAL_CAN_ErrorCallback+0xcc>)
 8011a40:	f005 fb66 	bl	8017110 <rt_kprintf>
	if ((hcan->ErrorCode & HAL_CAN_ERROR_CRC) == HAL_CAN_ERROR_CRC)
 8011a44:	687b      	ldr	r3, [r7, #4]
 8011a46:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8011a48:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8011a4c:	2b00      	cmp	r3, #0
 8011a4e:	d002      	beq.n	8011a56 <HAL_CAN_ErrorCallback+0xaa>
		rt_kprintf("crc error\r\n");
 8011a50:	480a      	ldr	r0, [pc, #40]	; (8011a7c <HAL_CAN_ErrorCallback+0xd0>)
 8011a52:	f005 fb5d 	bl	8017110 <rt_kprintf>
	
	//HAL_NVIC_DisableIRQ(CAN1_SCE_IRQn);
}
 8011a56:	3708      	adds	r7, #8
 8011a58:	46bd      	mov	sp, r7
 8011a5a:	bd80      	pop	{r7, pc}
 8011a5c:	080287b4 	.word	0x080287b4
 8011a60:	080287c0 	.word	0x080287c0
 8011a64:	080287cc 	.word	0x080287cc
 8011a68:	080287d8 	.word	0x080287d8
 8011a6c:	080287e4 	.word	0x080287e4
 8011a70:	080287f0 	.word	0x080287f0
 8011a74:	080287fc 	.word	0x080287fc
 8011a78:	08028808 	.word	0x08028808
 8011a7c:	08028814 	.word	0x08028814

08011a80 <CAN1_SCE_IRQHandler>:

void CAN1_SCE_IRQHandler(void)
{
 8011a80:	b580      	push	{r7, lr}
 8011a82:	b090      	sub	sp, #64	; 0x40
 8011a84:	af00      	add	r7, sp, #0
	CAN_HandleTypeDef hcan;

	/* enter interrupt */
	rt_interrupt_enter();
 8011a86:	f004 fd33 	bl	80164f0 <rt_interrupt_enter>

	HAL_CAN_IRQHandler(&hcan);
 8011a8a:	463b      	mov	r3, r7
 8011a8c:	4618      	mov	r0, r3
 8011a8e:	f7f5 fff3 	bl	8007a78 <HAL_CAN_IRQHandler>

	/* leave interrupt */
	rt_interrupt_leave();
 8011a92:	f004 fd43 	bl	801651c <rt_interrupt_leave>

}
 8011a96:	3740      	adds	r7, #64	; 0x40
 8011a98:	46bd      	mov	sp, r7
 8011a9a:	bd80      	pop	{r7, pc}

08011a9c <HAL_CAN_MspInit>:



void HAL_CAN_MspInit(CAN_HandleTypeDef* hcan)
{
 8011a9c:	b580      	push	{r7, lr}
 8011a9e:	b08a      	sub	sp, #40	; 0x28
 8011aa0:	af00      	add	r7, sp, #0
 8011aa2:	6078      	str	r0, [r7, #4]
    GPIO_InitTypeDef  GPIO_InitStruct;
	
	CAN1_CLK_ENABLE();
 8011aa4:	4a2b      	ldr	r2, [pc, #172]	; (8011b54 <HAL_CAN_MspInit+0xb8>)
 8011aa6:	4b2b      	ldr	r3, [pc, #172]	; (8011b54 <HAL_CAN_MspInit+0xb8>)
 8011aa8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8011aaa:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8011aae:	6413      	str	r3, [r2, #64]	; 0x40
 8011ab0:	4b28      	ldr	r3, [pc, #160]	; (8011b54 <HAL_CAN_MspInit+0xb8>)
 8011ab2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8011ab4:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8011ab8:	613b      	str	r3, [r7, #16]
 8011aba:	693b      	ldr	r3, [r7, #16]
	CAN1_GPIOB_CLK_ENABLE();
 8011abc:	4a25      	ldr	r2, [pc, #148]	; (8011b54 <HAL_CAN_MspInit+0xb8>)
 8011abe:	4b25      	ldr	r3, [pc, #148]	; (8011b54 <HAL_CAN_MspInit+0xb8>)
 8011ac0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011ac2:	f043 0302 	orr.w	r3, r3, #2
 8011ac6:	6313      	str	r3, [r2, #48]	; 0x30
 8011ac8:	4b22      	ldr	r3, [pc, #136]	; (8011b54 <HAL_CAN_MspInit+0xb8>)
 8011aca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011acc:	f003 0302 	and.w	r3, r3, #2
 8011ad0:	60fb      	str	r3, [r7, #12]
 8011ad2:	68fb      	ldr	r3, [r7, #12]

	GPIO_InitStruct.Alternate = GPIO_AF9_CAN1;
 8011ad4:	2309      	movs	r3, #9
 8011ad6:	627b      	str	r3, [r7, #36]	; 0x24
	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011ad8:	2302      	movs	r3, #2
 8011ada:	61bb      	str	r3, [r7, #24]
	GPIO_InitStruct.Pin = CAN1_TX_PIN;
 8011adc:	f44f 7300 	mov.w	r3, #512	; 0x200
 8011ae0:	617b      	str	r3, [r7, #20]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011ae2:	2300      	movs	r3, #0
 8011ae4:	61fb      	str	r3, [r7, #28]
	GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8011ae6:	2303      	movs	r3, #3
 8011ae8:	623b      	str	r3, [r7, #32]
	HAL_GPIO_Init(CAN1_TX_PORT, &GPIO_InitStruct);	
 8011aea:	f107 0314 	add.w	r3, r7, #20
 8011aee:	481a      	ldr	r0, [pc, #104]	; (8011b58 <HAL_CAN_MspInit+0xbc>)
 8011af0:	4619      	mov	r1, r3
 8011af2:	f7fb f8a7 	bl	800cc44 <HAL_GPIO_Init>
	
	GPIO_InitStruct.Pin = CAN1_RX_PIN;
 8011af6:	f44f 7380 	mov.w	r3, #256	; 0x100
 8011afa:	617b      	str	r3, [r7, #20]
	GPIO_InitStruct.Pull = GPIO_PULLUP;
 8011afc:	2301      	movs	r3, #1
 8011afe:	61fb      	str	r3, [r7, #28]
	HAL_GPIO_Init(CAN1_RX_PORT, &GPIO_InitStruct);	
 8011b00:	f107 0314 	add.w	r3, r7, #20
 8011b04:	4814      	ldr	r0, [pc, #80]	; (8011b58 <HAL_CAN_MspInit+0xbc>)
 8011b06:	4619      	mov	r1, r3
 8011b08:	f7fb f89c 	bl	800cc44 <HAL_GPIO_Init>
	
	HAL_NVIC_SetPriority(CAN1_TX_IRQn,CAN1_TX_IRQ_PREEMPT,CAN1_TX_TRQ_SUB);
 8011b0c:	2013      	movs	r0, #19
 8011b0e:	210f      	movs	r1, #15
 8011b10:	2200      	movs	r2, #0
 8011b12:	f7f6 fbb3 	bl	800827c <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(CAN1_TX_IRQn);
 8011b16:	2013      	movs	r0, #19
 8011b18:	f7f6 fbcc 	bl	80082b4 <HAL_NVIC_EnableIRQ>
	
	HAL_NVIC_SetPriority(CAN1_RX0_IRQn,CAN1_RX0_IRQ_PREEMPT,CAN1_RX0_TRQ_SUB);
 8011b1c:	2014      	movs	r0, #20
 8011b1e:	210f      	movs	r1, #15
 8011b20:	2200      	movs	r2, #0
 8011b22:	f7f6 fbab 	bl	800827c <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(CAN1_RX0_IRQn);
 8011b26:	2014      	movs	r0, #20
 8011b28:	f7f6 fbc4 	bl	80082b4 <HAL_NVIC_EnableIRQ>

	HAL_NVIC_SetPriority(CAN1_RX1_IRQn,CAN1_RX1_IRQ_PREEMPT,CAN1_RX1_TRQ_SUB);
 8011b2c:	2015      	movs	r0, #21
 8011b2e:	210f      	movs	r1, #15
 8011b30:	2200      	movs	r2, #0
 8011b32:	f7f6 fba3 	bl	800827c <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(CAN1_RX1_IRQn);
 8011b36:	2015      	movs	r0, #21
 8011b38:	f7f6 fbbc 	bl	80082b4 <HAL_NVIC_EnableIRQ>

	HAL_NVIC_SetPriority(CAN1_SCE_IRQn,CAN1_SCE_IRQ_PREEMPT,CAN1_SCE_IRQ_SUB);
 8011b3c:	2016      	movs	r0, #22
 8011b3e:	210f      	movs	r1, #15
 8011b40:	2200      	movs	r2, #0
 8011b42:	f7f6 fb9b 	bl	800827c <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(CAN1_SCE_IRQn);
 8011b46:	2016      	movs	r0, #22
 8011b48:	f7f6 fbb4 	bl	80082b4 <HAL_NVIC_EnableIRQ>
}
 8011b4c:	3728      	adds	r7, #40	; 0x28
 8011b4e:	46bd      	mov	sp, r7
 8011b50:	bd80      	pop	{r7, pc}
 8011b52:	bf00      	nop
 8011b54:	40023800 	.word	0x40023800
 8011b58:	40020400 	.word	0x40020400

08011b5c <stm32_CANcontrol>:




rt_err_t stm32_CANcontrol(struct rt_can_device *can, int cmd, void *arg)
{
 8011b5c:	b480      	push	{r7}
 8011b5e:	b087      	sub	sp, #28
 8011b60:	af00      	add	r7, sp, #0
 8011b62:	60f8      	str	r0, [r7, #12]
 8011b64:	60b9      	str	r1, [r7, #8]
 8011b66:	607a      	str	r2, [r7, #4]
	stm32_canTypeDef *stcan;
	stcan = (stm32_canTypeDef *)can->parent.user_data;
 8011b68:	68fb      	ldr	r3, [r7, #12]
 8011b6a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8011b6c:	617b      	str	r3, [r7, #20]
	rt_err_t result = RT_EOK;
 8011b6e:	2300      	movs	r3, #0
 8011b70:	613b      	str	r3, [r7, #16]
	switch(cmd)
 8011b72:	68bb      	ldr	r3, [r7, #8]
 8011b74:	2b10      	cmp	r3, #16
 8011b76:	d00b      	beq.n	8011b90 <stm32_CANcontrol+0x34>
 8011b78:	2b11      	cmp	r3, #17
 8011b7a:	d000      	beq.n	8011b7e <stm32_CANcontrol+0x22>
			break;
		case (RT_DEVICE_CTRL_SET_INT):
			__HAL_CAN_ENABLE_IT(&(stcan->hcan), CAN_IT_ERR);
			break;
		default:
			break;
 8011b7c:	e011      	b.n	8011ba2 <stm32_CANcontrol+0x46>
	stcan = (stm32_canTypeDef *)can->parent.user_data;
	rt_err_t result = RT_EOK;
	switch(cmd)
	{
		case (RT_DEVICE_CTRL_CLR_INT):
			__HAL_CAN_DISABLE_IT(&(stcan->hcan), CAN_IT_ERR);
 8011b7e:	697b      	ldr	r3, [r7, #20]
 8011b80:	681b      	ldr	r3, [r3, #0]
 8011b82:	697a      	ldr	r2, [r7, #20]
 8011b84:	6812      	ldr	r2, [r2, #0]
 8011b86:	6952      	ldr	r2, [r2, #20]
 8011b88:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8011b8c:	615a      	str	r2, [r3, #20]
			break;
 8011b8e:	e008      	b.n	8011ba2 <stm32_CANcontrol+0x46>
		case (RT_DEVICE_CTRL_SET_INT):
			__HAL_CAN_ENABLE_IT(&(stcan->hcan), CAN_IT_ERR);
 8011b90:	697b      	ldr	r3, [r7, #20]
 8011b92:	681b      	ldr	r3, [r3, #0]
 8011b94:	697a      	ldr	r2, [r7, #20]
 8011b96:	6812      	ldr	r2, [r2, #0]
 8011b98:	6952      	ldr	r2, [r2, #20]
 8011b9a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8011b9e:	615a      	str	r2, [r3, #20]
			break;
 8011ba0:	bf00      	nop
		default:
			break;
	}	
	return result;
 8011ba2:	693b      	ldr	r3, [r7, #16]
}
 8011ba4:	4618      	mov	r0, r3
 8011ba6:	371c      	adds	r7, #28
 8011ba8:	46bd      	mov	sp, r7
 8011baa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011bae:	4770      	bx	lr

08011bb0 <stm32_CANsendmsg>:

int stm32_CANsendmsg(struct rt_can_device *can, const void *buf, rt_uint32_t boxno)
{
 8011bb0:	b580      	push	{r7, lr}
 8011bb2:	b08a      	sub	sp, #40	; 0x28
 8011bb4:	af00      	add	r7, sp, #0
 8011bb6:	60f8      	str	r0, [r7, #12]
 8011bb8:	60b9      	str	r1, [r7, #8]
 8011bba:	607a      	str	r2, [r7, #4]
	stm32_canTypeDef *stcan;
	struct rt_can_msg *tmpmsg = (struct rt_can_msg *)buf;
 8011bbc:	68bb      	ldr	r3, [r7, #8]
 8011bbe:	623b      	str	r3, [r7, #32]
	stcan = (stm32_canTypeDef *)can->parent.user_data;
 8011bc0:	68fb      	ldr	r3, [r7, #12]
 8011bc2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8011bc4:	61fb      	str	r3, [r7, #28]
	rt_err_t result = RT_EOK;
 8011bc6:	2300      	movs	r3, #0
 8011bc8:	61bb      	str	r3, [r7, #24]
	unsigned char i;
	unsigned char ecode;
	if((stcan->hcan.pTxMsg != NULL))
 8011bca:	69fb      	ldr	r3, [r7, #28]
 8011bcc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011bce:	2b00      	cmp	r3, #0
 8011bd0:	d053      	beq.n	8011c7a <stm32_CANsendmsg+0xca>
	{
		//rt_kprintf(" TX malloc success\r\n");
		stcan->hcan.pTxMsg->ExtId =  tmpmsg->id;
 8011bd2:	69fb      	ldr	r3, [r7, #28]
 8011bd4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011bd6:	6a3a      	ldr	r2, [r7, #32]
 8011bd8:	6812      	ldr	r2, [r2, #0]
 8011bda:	f3c2 021c 	ubfx	r2, r2, #0, #29
 8011bde:	605a      	str	r2, [r3, #4]
		if(tmpmsg->ide)
 8011be0:	6a3b      	ldr	r3, [r7, #32]
 8011be2:	78db      	ldrb	r3, [r3, #3]
 8011be4:	f003 0320 	and.w	r3, r3, #32
 8011be8:	b2db      	uxtb	r3, r3
 8011bea:	2b00      	cmp	r3, #0
 8011bec:	d004      	beq.n	8011bf8 <stm32_CANsendmsg+0x48>
			stcan->hcan.pTxMsg->IDE = CAN_ID_EXT;
 8011bee:	69fb      	ldr	r3, [r7, #28]
 8011bf0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011bf2:	2204      	movs	r2, #4
 8011bf4:	609a      	str	r2, [r3, #8]
 8011bf6:	e003      	b.n	8011c00 <stm32_CANsendmsg+0x50>
		else
			stcan->hcan.pTxMsg->IDE = CAN_ID_STD;
 8011bf8:	69fb      	ldr	r3, [r7, #28]
 8011bfa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011bfc:	2200      	movs	r2, #0
 8011bfe:	609a      	str	r2, [r3, #8]
		if(tmpmsg->rtr)
 8011c00:	6a3b      	ldr	r3, [r7, #32]
 8011c02:	78db      	ldrb	r3, [r3, #3]
 8011c04:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8011c08:	b2db      	uxtb	r3, r3
 8011c0a:	2b00      	cmp	r3, #0
 8011c0c:	d004      	beq.n	8011c18 <stm32_CANsendmsg+0x68>
			stcan->hcan.pTxMsg->RTR = CAN_RTR_REMOTE;
 8011c0e:	69fb      	ldr	r3, [r7, #28]
 8011c10:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011c12:	2202      	movs	r2, #2
 8011c14:	60da      	str	r2, [r3, #12]
 8011c16:	e003      	b.n	8011c20 <stm32_CANsendmsg+0x70>
		else 
			stcan->hcan.pTxMsg->RTR = CAN_RTR_DATA;
 8011c18:	69fb      	ldr	r3, [r7, #28]
 8011c1a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011c1c:	2200      	movs	r2, #0
 8011c1e:	60da      	str	r2, [r3, #12]
		stcan->hcan.pTxMsg->DLC = tmpmsg->len;
 8011c20:	69fb      	ldr	r3, [r7, #28]
 8011c22:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011c24:	6a3a      	ldr	r2, [r7, #32]
 8011c26:	7912      	ldrb	r2, [r2, #4]
 8011c28:	611a      	str	r2, [r3, #16]
		for(i=0;i<8;i++)
 8011c2a:	2300      	movs	r3, #0
 8011c2c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8011c30:	e010      	b.n	8011c54 <stm32_CANsendmsg+0xa4>
		{
			stcan->hcan.pTxMsg->Data[i] = tmpmsg->data[i];
 8011c32:	69fb      	ldr	r3, [r7, #28]
 8011c34:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8011c36:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8011c3a:	f897 1027 	ldrb.w	r1, [r7, #39]	; 0x27
 8011c3e:	6a38      	ldr	r0, [r7, #32]
 8011c40:	4401      	add	r1, r0
 8011c42:	7a09      	ldrb	r1, [r1, #8]
 8011c44:	4413      	add	r3, r2
 8011c46:	460a      	mov	r2, r1
 8011c48:	751a      	strb	r2, [r3, #20]
		if(tmpmsg->rtr)
			stcan->hcan.pTxMsg->RTR = CAN_RTR_REMOTE;
		else 
			stcan->hcan.pTxMsg->RTR = CAN_RTR_DATA;
		stcan->hcan.pTxMsg->DLC = tmpmsg->len;
		for(i=0;i<8;i++)
 8011c4a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8011c4e:	3301      	adds	r3, #1
 8011c50:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8011c54:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8011c58:	2b07      	cmp	r3, #7
 8011c5a:	d9ea      	bls.n	8011c32 <stm32_CANsendmsg+0x82>
		{
			stcan->hcan.pTxMsg->Data[i] = tmpmsg->data[i];
		}
		if ((ecode = HAL_CAN_Transmit(&(stcan->hcan),100)) == HAL_OK)
 8011c5c:	69fb      	ldr	r3, [r7, #28]
 8011c5e:	4618      	mov	r0, r3
 8011c60:	2164      	movs	r1, #100	; 0x64
 8011c62:	f7f5 fc59 	bl	8007518 <HAL_CAN_Transmit>
 8011c66:	4603      	mov	r3, r0
 8011c68:	75fb      	strb	r3, [r7, #23]
 8011c6a:	7dfb      	ldrb	r3, [r7, #23]
 8011c6c:	2b00      	cmp	r3, #0
 8011c6e:	d004      	beq.n	8011c7a <stm32_CANsendmsg+0xca>
		{
			//rt_kprintf("CAN tx success %x\r\n", stcan->hcan.Instance->ESR);
		}
		else
		{
			rt_kprintf("CAN tx fail! %x\r\n", ecode);
 8011c70:	7dfb      	ldrb	r3, [r7, #23]
 8011c72:	4804      	ldr	r0, [pc, #16]	; (8011c84 <stm32_CANsendmsg+0xd4>)
 8011c74:	4619      	mov	r1, r3
 8011c76:	f005 fa4b 	bl	8017110 <rt_kprintf>
		}
		//rt_free(hcan.pTxMsg);
	}
	return result;
 8011c7a:	69bb      	ldr	r3, [r7, #24]
}
 8011c7c:	4618      	mov	r0, r3
 8011c7e:	3728      	adds	r7, #40	; 0x28
 8011c80:	46bd      	mov	sp, r7
 8011c82:	bd80      	pop	{r7, pc}
 8011c84:	08028820 	.word	0x08028820

08011c88 <stm32_CANrecvmsg>:
int stm32_CANrecvmsg(struct rt_can_device *can, void *buf, rt_uint32_t boxno)
{
 8011c88:	b580      	push	{r7, lr}
 8011c8a:	b08e      	sub	sp, #56	; 0x38
 8011c8c:	af00      	add	r7, sp, #0
 8011c8e:	60f8      	str	r0, [r7, #12]
 8011c90:	60b9      	str	r1, [r7, #8]
 8011c92:	607a      	str	r2, [r7, #4]
	stm32_canTypeDef *stcan;
	stcan = (stm32_canTypeDef *)can->parent.user_data;
 8011c94:	68fb      	ldr	r3, [r7, #12]
 8011c96:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8011c98:	633b      	str	r3, [r7, #48]	; 0x30
	rt_err_t result = RT_EOK;
 8011c9a:	2300      	movs	r3, #0
 8011c9c:	62fb      	str	r3, [r7, #44]	; 0x2c

	while((uint8_t)(stcan->hcan.Instance->RF0R&(uint32_t)0x03))
 8011c9e:	e0cf      	b.n	8011e40 <stm32_CANrecvmsg+0x1b8>
	{
		if (HAL_CAN_Receive(&(stcan->hcan),CAN_FIFO0,0) == HAL_OK)
 8011ca0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011ca2:	4618      	mov	r0, r3
 8011ca4:	2100      	movs	r1, #0
 8011ca6:	2200      	movs	r2, #0
 8011ca8:	f7f5 fda8 	bl	80077fc <HAL_CAN_Receive>
 8011cac:	4603      	mov	r3, r0
 8011cae:	2b00      	cmp	r3, #0
 8011cb0:	f040 80c6 	bne.w	8011e40 <stm32_CANrecvmsg+0x1b8>
		{
			rt_kprintf("receive can\r\n");
 8011cb4:	4869      	ldr	r0, [pc, #420]	; (8011e5c <stm32_CANrecvmsg+0x1d4>)
 8011cb6:	f005 fa2b 	bl	8017110 <rt_kprintf>
			struct rt_can_msg tmpmsg;
			struct rt_can_rx_fifo *rx_fifo;
			struct rt_can_msg_list *listmsg = RT_NULL;
 8011cba:	2300      	movs	r3, #0
 8011cbc:	637b      	str	r3, [r7, #52]	; 0x34
					rt_kprintf("0x%x ", stcan->hcan.pRxMsg->Data[i]);
				}
				rt_kprintf("\r\n");
			}
			#endif
			rx_fifo = (struct rt_can_rx_fifo *)can->can_rx;
 8011cbe:	68fb      	ldr	r3, [r7, #12]
 8011cc0:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8011cc4:	62bb      	str	r3, [r7, #40]	; 0x28
			RT_ASSERT(rx_fifo != RT_NULL);
 8011cc6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011cc8:	2b00      	cmp	r3, #0
 8011cca:	d104      	bne.n	8011cd6 <stm32_CANrecvmsg+0x4e>
 8011ccc:	4864      	ldr	r0, [pc, #400]	; (8011e60 <stm32_CANrecvmsg+0x1d8>)
 8011cce:	4965      	ldr	r1, [pc, #404]	; (8011e64 <stm32_CANrecvmsg+0x1dc>)
 8011cd0:	22f4      	movs	r2, #244	; 0xf4
 8011cd2:	f005 fa97 	bl	8017204 <rt_assert_handler>
	
			//no = event >> 8;
			//ch = can->ops->recvmsg(can, &tmpmsg, no);
			//if (ch == -1) break;
	
			tmpmsg.id = stcan->hcan.pRxMsg->ExtId;
 8011cd6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011cd8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011cda:	685b      	ldr	r3, [r3, #4]
 8011cdc:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
 8011ce0:	693b      	ldr	r3, [r7, #16]
 8011ce2:	f362 031c 	bfi	r3, r2, #0, #29
 8011ce6:	613b      	str	r3, [r7, #16]
			tmpmsg.ide = stcan->hcan.pRxMsg->IDE;
 8011ce8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011cea:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011cec:	689b      	ldr	r3, [r3, #8]
 8011cee:	b2db      	uxtb	r3, r3
 8011cf0:	f003 0301 	and.w	r3, r3, #1
 8011cf4:	b2da      	uxtb	r2, r3
 8011cf6:	7cfb      	ldrb	r3, [r7, #19]
 8011cf8:	f362 1345 	bfi	r3, r2, #5, #1
 8011cfc:	74fb      	strb	r3, [r7, #19]
			tmpmsg.rtr = stcan->hcan.pRxMsg->RTR;
 8011cfe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011d00:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011d02:	68db      	ldr	r3, [r3, #12]
 8011d04:	b2db      	uxtb	r3, r3
 8011d06:	f003 0301 	and.w	r3, r3, #1
 8011d0a:	b2da      	uxtb	r2, r3
 8011d0c:	7cfb      	ldrb	r3, [r7, #19]
 8011d0e:	f362 1386 	bfi	r3, r2, #6, #1
 8011d12:	74fb      	strb	r3, [r7, #19]
			tmpmsg.len = stcan->hcan.pRxMsg->DLC;
 8011d14:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011d16:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011d18:	691b      	ldr	r3, [r3, #16]
 8011d1a:	b2db      	uxtb	r3, r3
 8011d1c:	753b      	strb	r3, [r7, #20]
			tmpmsg.data[0] = stcan->hcan.pRxMsg->Data[0];
 8011d1e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011d20:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011d22:	7d1b      	ldrb	r3, [r3, #20]
 8011d24:	763b      	strb	r3, [r7, #24]
			tmpmsg.data[1] = stcan->hcan.pRxMsg->Data[1];
 8011d26:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011d28:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011d2a:	7d5b      	ldrb	r3, [r3, #21]
 8011d2c:	767b      	strb	r3, [r7, #25]
			tmpmsg.data[2] = stcan->hcan.pRxMsg->Data[2];
 8011d2e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011d30:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011d32:	7d9b      	ldrb	r3, [r3, #22]
 8011d34:	76bb      	strb	r3, [r7, #26]
			tmpmsg.data[3] = stcan->hcan.pRxMsg->Data[3];
 8011d36:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011d38:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011d3a:	7ddb      	ldrb	r3, [r3, #23]
 8011d3c:	76fb      	strb	r3, [r7, #27]
			tmpmsg.data[4] = stcan->hcan.pRxMsg->Data[4];
 8011d3e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011d40:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011d42:	7e1b      	ldrb	r3, [r3, #24]
 8011d44:	773b      	strb	r3, [r7, #28]
			tmpmsg.data[5] = stcan->hcan.pRxMsg->Data[5];
 8011d46:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011d48:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011d4a:	7e5b      	ldrb	r3, [r3, #25]
 8011d4c:	777b      	strb	r3, [r7, #29]
			tmpmsg.data[6] = stcan->hcan.pRxMsg->Data[6];
 8011d4e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011d50:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011d52:	7e9b      	ldrb	r3, [r3, #26]
 8011d54:	77bb      	strb	r3, [r7, #30]
			tmpmsg.data[7] = stcan->hcan.pRxMsg->Data[7];
 8011d56:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011d58:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011d5a:	7edb      	ldrb	r3, [r3, #27]
 8011d5c:	77fb      	strb	r3, [r7, #31]

			/* disable interrupt */
			level = rt_hw_interrupt_disable();
 8011d5e:	f7ee fa35 	bl	80001cc <rt_hw_interrupt_disable>
 8011d62:	6278      	str	r0, [r7, #36]	; 0x24
			can->status.rcvpkg++;
 8011d64:	68fb      	ldr	r3, [r7, #12]
 8011d66:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8011d68:	1c5a      	adds	r2, r3, #1
 8011d6a:	68fb      	ldr	r3, [r7, #12]
 8011d6c:	665a      	str	r2, [r3, #100]	; 0x64
			can->status.rcvchange = 1;
 8011d6e:	68fb      	ldr	r3, [r7, #12]
 8011d70:	2201      	movs	r2, #1
 8011d72:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
			if (!rt_list_isempty(&rx_fifo->freelist))
 8011d76:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011d78:	3308      	adds	r3, #8
 8011d7a:	4618      	mov	r0, r3
 8011d7c:	f7ff fdba 	bl	80118f4 <rt_list_isempty>
 8011d80:	4603      	mov	r3, r0
 8011d82:	2b00      	cmp	r3, #0
 8011d84:	d116      	bne.n	8011db4 <stm32_CANrecvmsg+0x12c>
			{
				listmsg = rt_list_entry(rx_fifo->freelist.next, struct rt_can_msg_list, list);
 8011d86:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011d88:	689b      	ldr	r3, [r3, #8]
 8011d8a:	637b      	str	r3, [r7, #52]	; 0x34
				rt_list_remove(&listmsg->list);
 8011d8c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011d8e:	4618      	mov	r0, r3
 8011d90:	f7ff fd96 	bl	80118c0 <rt_list_remove>
				RT_ASSERT(rx_fifo->freenumbers > 0);
 8011d94:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011d96:	685b      	ldr	r3, [r3, #4]
 8011d98:	2b00      	cmp	r3, #0
 8011d9a:	d105      	bne.n	8011da8 <stm32_CANrecvmsg+0x120>
 8011d9c:	4832      	ldr	r0, [pc, #200]	; (8011e68 <stm32_CANrecvmsg+0x1e0>)
 8011d9e:	4931      	ldr	r1, [pc, #196]	; (8011e64 <stm32_CANrecvmsg+0x1dc>)
 8011da0:	f240 1211 	movw	r2, #273	; 0x111
 8011da4:	f005 fa2e 	bl	8017204 <rt_assert_handler>
				rx_fifo->freenumbers--;
 8011da8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011daa:	685b      	ldr	r3, [r3, #4]
 8011dac:	1e5a      	subs	r2, r3, #1
 8011dae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011db0:	605a      	str	r2, [r3, #4]
 8011db2:	e013      	b.n	8011ddc <stm32_CANrecvmsg+0x154>
			}
			else if (!rt_list_isempty(&rx_fifo->uselist))
 8011db4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011db6:	3310      	adds	r3, #16
 8011db8:	4618      	mov	r0, r3
 8011dba:	f7ff fd9b 	bl	80118f4 <rt_list_isempty>
 8011dbe:	4603      	mov	r3, r0
 8011dc0:	2b00      	cmp	r3, #0
 8011dc2:	d10b      	bne.n	8011ddc <stm32_CANrecvmsg+0x154>
			{
				listmsg = rt_list_entry(rx_fifo->uselist.next, struct rt_can_msg_list, list);
 8011dc4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011dc6:	691b      	ldr	r3, [r3, #16]
 8011dc8:	637b      	str	r3, [r7, #52]	; 0x34
				can->status.dropedrcvpkg++;
 8011dca:	68fb      	ldr	r3, [r7, #12]
 8011dcc:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8011dce:	1c5a      	adds	r2, r3, #1
 8011dd0:	68fb      	ldr	r3, [r7, #12]
 8011dd2:	669a      	str	r2, [r3, #104]	; 0x68
				rt_list_remove(&listmsg->list);
 8011dd4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011dd6:	4618      	mov	r0, r3
 8011dd8:	f7ff fd72 	bl	80118c0 <rt_list_remove>
			}
			/* enable interrupt */
			rt_hw_interrupt_enable(level);
 8011ddc:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8011dde:	f7ee f9f9 	bl	80001d4 <rt_hw_interrupt_enable>
	
			if (listmsg != RT_NULL)
 8011de2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011de4:	2b00      	cmp	r3, #0
 8011de6:	d017      	beq.n	8011e18 <stm32_CANrecvmsg+0x190>
			{
				rt_memcpy(&listmsg->data, &tmpmsg, sizeof(struct rt_can_msg));
 8011de8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011dea:	f103 0208 	add.w	r2, r3, #8
 8011dee:	f107 0310 	add.w	r3, r7, #16
 8011df2:	4610      	mov	r0, r2
 8011df4:	4619      	mov	r1, r3
 8011df6:	2210      	movs	r2, #16
 8011df8:	f004 fc2e 	bl	8016658 <rt_memcpy>
				level = rt_hw_interrupt_disable();
 8011dfc:	f7ee f9e6 	bl	80001cc <rt_hw_interrupt_disable>
 8011e00:	6278      	str	r0, [r7, #36]	; 0x24
				rt_list_insert_before(&rx_fifo->uselist, &listmsg->list);
 8011e02:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011e04:	f103 0210 	add.w	r2, r3, #16
 8011e08:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011e0a:	4610      	mov	r0, r2
 8011e0c:	4619      	mov	r1, r3
 8011e0e:	f7ff fd3f 	bl	8011890 <rt_list_insert_before>
				rt_hw_interrupt_enable(level);
 8011e12:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8011e14:	f7ee f9de 	bl	80001d4 <rt_hw_interrupt_enable>
			}
			
			if (can->parent.rx_indicate != RT_NULL)
 8011e18:	68fb      	ldr	r3, [r7, #12]
 8011e1a:	69db      	ldr	r3, [r3, #28]
 8011e1c:	2b00      	cmp	r3, #0
 8011e1e:	d00f      	beq.n	8011e40 <stm32_CANrecvmsg+0x1b8>
            {
                rt_size_t rx_length;

                level = rt_hw_interrupt_disable();
 8011e20:	f7ee f9d4 	bl	80001cc <rt_hw_interrupt_disable>
 8011e24:	6278      	str	r0, [r7, #36]	; 0x24
                /* get rx length */
                rx_length = rx_fifo->freenumbers * sizeof(struct rt_can_msg);
 8011e26:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011e28:	685b      	ldr	r3, [r3, #4]
 8011e2a:	011b      	lsls	r3, r3, #4
 8011e2c:	623b      	str	r3, [r7, #32]
                rt_hw_interrupt_enable(level);
 8011e2e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8011e30:	f7ee f9d0 	bl	80001d4 <rt_hw_interrupt_enable>

                can->parent.rx_indicate(&can->parent, rx_length);
 8011e34:	68fb      	ldr	r3, [r7, #12]
 8011e36:	69db      	ldr	r3, [r3, #28]
 8011e38:	68fa      	ldr	r2, [r7, #12]
 8011e3a:	4610      	mov	r0, r2
 8011e3c:	6a39      	ldr	r1, [r7, #32]
 8011e3e:	4798      	blx	r3
{
	stm32_canTypeDef *stcan;
	stcan = (stm32_canTypeDef *)can->parent.user_data;
	rt_err_t result = RT_EOK;

	while((uint8_t)(stcan->hcan.Instance->RF0R&(uint32_t)0x03))
 8011e40:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011e42:	681b      	ldr	r3, [r3, #0]
 8011e44:	68db      	ldr	r3, [r3, #12]
 8011e46:	b2db      	uxtb	r3, r3
 8011e48:	f003 0303 	and.w	r3, r3, #3
 8011e4c:	2b00      	cmp	r3, #0
 8011e4e:	f47f af27 	bne.w	8011ca0 <stm32_CANrecvmsg+0x18>
                can->parent.rx_indicate(&can->parent, rx_length);
            }

		}
	}
	return result;
 8011e52:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 8011e54:	4618      	mov	r0, r3
 8011e56:	3738      	adds	r7, #56	; 0x38
 8011e58:	46bd      	mov	sp, r7
 8011e5a:	bd80      	pop	{r7, pc}
 8011e5c:	08028834 	.word	0x08028834
 8011e60:	08028844 	.word	0x08028844
 8011e64:	0802a51c 	.word	0x0802a51c
 8011e68:	08028858 	.word	0x08028858

08011e6c <timerCanrxfunc>:

static void timerCanrxfunc(void* parameter)
{
 8011e6c:	b580      	push	{r7, lr}
 8011e6e:	b082      	sub	sp, #8
 8011e70:	af00      	add	r7, sp, #0
 8011e72:	6078      	str	r0, [r7, #4]
	stm32_CANrecvmsg(&canDevice1,NULL,0);
 8011e74:	4803      	ldr	r0, [pc, #12]	; (8011e84 <timerCanrxfunc+0x18>)
 8011e76:	2100      	movs	r1, #0
 8011e78:	2200      	movs	r2, #0
 8011e7a:	f7ff ff05 	bl	8011c88 <stm32_CANrecvmsg>
}
 8011e7e:	3708      	adds	r7, #8
 8011e80:	46bd      	mov	sp, r7
 8011e82:	bd80      	pop	{r7, pc}
 8011e84:	200127ac 	.word	0x200127ac

08011e88 <stm32_CANconfigure>:



rt_err_t stm32_CANconfigure(struct rt_can_device *can, struct can_configure *cfg)
{
 8011e88:	b580      	push	{r7, lr}
 8011e8a:	b090      	sub	sp, #64	; 0x40
 8011e8c:	af02      	add	r7, sp, #8
 8011e8e:	6078      	str	r0, [r7, #4]
 8011e90:	6039      	str	r1, [r7, #0]
	stm32_canTypeDef *stcan;
	stcan = (stm32_canTypeDef *)can->parent.user_data;
 8011e92:	687b      	ldr	r3, [r7, #4]
 8011e94:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8011e96:	637b      	str	r3, [r7, #52]	; 0x34
	rt_err_t result = RT_EOK;
 8011e98:	2300      	movs	r3, #0
 8011e9a:	633b      	str	r3, [r7, #48]	; 0x30
	static rt_timer_t timerCanrx;
	
	switch (cfg->baud_rate)
 8011e9c:	683b      	ldr	r3, [r7, #0]
 8011e9e:	681b      	ldr	r3, [r3, #0]
 8011ea0:	2bfa      	cmp	r3, #250	; 0xfa
 8011ea2:	f040 8086 	bne.w	8011fb2 <stm32_CANconfigure+0x12a>
	{
		case (250) :
			if(HAL_CAN_DeInit(&(stcan->hcan))!= HAL_OK)
 8011ea6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011ea8:	4618      	mov	r0, r3
 8011eaa:	f7f5 fb0d 	bl	80074c8 <HAL_CAN_DeInit>
 8011eae:	4603      	mov	r3, r0
 8011eb0:	2b00      	cmp	r3, #0
 8011eb2:	d004      	beq.n	8011ebe <stm32_CANconfigure+0x36>
			{
				rt_kprintf("error deinit can\r\n");
 8011eb4:	4841      	ldr	r0, [pc, #260]	; (8011fbc <stm32_CANconfigure+0x134>)
 8011eb6:	f005 f92b 	bl	8017110 <rt_kprintf>
				return RT_ERROR;
 8011eba:	2301      	movs	r3, #1
 8011ebc:	e07a      	b.n	8011fb4 <stm32_CANconfigure+0x12c>
			}
			stcan->hcan.Init.ABOM = DISABLE;
 8011ebe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011ec0:	2200      	movs	r2, #0
 8011ec2:	61da      	str	r2, [r3, #28]
			stcan->hcan.Init.AWUM = DISABLE;
 8011ec4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011ec6:	2200      	movs	r2, #0
 8011ec8:	621a      	str	r2, [r3, #32]
			#if 1
			stcan->hcan.Init.BS1 = CAN_BS1_8TQ;
 8011eca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011ecc:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
 8011ed0:	611a      	str	r2, [r3, #16]
			stcan->hcan.Init.BS2 = CAN_BS2_3TQ;
 8011ed2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011ed4:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 8011ed8:	615a      	str	r2, [r3, #20]
			stcan->hcan.Init.Prescaler = 16;
 8011eda:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011edc:	2210      	movs	r2, #16
 8011ede:	605a      	str	r2, [r3, #4]
			#endif
			stcan->hcan.Init.Mode = CAN_MODE_NORMAL;
 8011ee0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011ee2:	2200      	movs	r2, #0
 8011ee4:	609a      	str	r2, [r3, #8]
			stcan->hcan.Init.NART = DISABLE;
 8011ee6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011ee8:	2200      	movs	r2, #0
 8011eea:	625a      	str	r2, [r3, #36]	; 0x24
			stcan->hcan.Init.RFLM = DISABLE;
 8011eec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011eee:	2200      	movs	r2, #0
 8011ef0:	629a      	str	r2, [r3, #40]	; 0x28
			stcan->hcan.Init.SJW = CAN_SJW_2TQ;
 8011ef2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011ef4:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8011ef8:	60da      	str	r2, [r3, #12]
			stcan->hcan.Init.TTCM = DISABLE;
 8011efa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011efc:	2200      	movs	r2, #0
 8011efe:	619a      	str	r2, [r3, #24]
			stcan->hcan.Init.TXFP = DISABLE;
 8011f00:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011f02:	2200      	movs	r2, #0
 8011f04:	62da      	str	r2, [r3, #44]	; 0x2c
			
			if(HAL_CAN_Init(&(stcan->hcan))!= HAL_OK)
 8011f06:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011f08:	4618      	mov	r0, r3
 8011f0a:	f7f5 f8e7 	bl	80070dc <HAL_CAN_Init>
 8011f0e:	4603      	mov	r3, r0
 8011f10:	2b00      	cmp	r3, #0
 8011f12:	d004      	beq.n	8011f1e <stm32_CANconfigure+0x96>
			{
				rt_kprintf("error init can\r\n");
 8011f14:	482a      	ldr	r0, [pc, #168]	; (8011fc0 <stm32_CANconfigure+0x138>)
 8011f16:	f005 f8fb 	bl	8017110 <rt_kprintf>
				return RT_ERROR;
 8011f1a:	2301      	movs	r3, #1
 8011f1c:	e04a      	b.n	8011fb4 <stm32_CANconfigure+0x12c>
			}	
			
			CAN_FilterConfTypeDef sFilterConfig;
			sFilterConfig.BankNumber = 0;
 8011f1e:	2300      	movs	r3, #0
 8011f20:	62fb      	str	r3, [r7, #44]	; 0x2c
			sFilterConfig.FilterActivation = ENABLE;
 8011f22:	2301      	movs	r3, #1
 8011f24:	62bb      	str	r3, [r7, #40]	; 0x28
			sFilterConfig.FilterFIFOAssignment = CAN_FILTER_FIFO0;
 8011f26:	2300      	movs	r3, #0
 8011f28:	61bb      	str	r3, [r7, #24]
			sFilterConfig.FilterIdHigh = 0x0000;
 8011f2a:	2300      	movs	r3, #0
 8011f2c:	60bb      	str	r3, [r7, #8]
			sFilterConfig.FilterIdLow = 0x0000;
 8011f2e:	2300      	movs	r3, #0
 8011f30:	60fb      	str	r3, [r7, #12]
			sFilterConfig.FilterMaskIdHigh = 0x0000;
 8011f32:	2300      	movs	r3, #0
 8011f34:	613b      	str	r3, [r7, #16]
			sFilterConfig.FilterMaskIdLow = 0x0000;
 8011f36:	2300      	movs	r3, #0
 8011f38:	617b      	str	r3, [r7, #20]
			sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
 8011f3a:	2300      	movs	r3, #0
 8011f3c:	623b      	str	r3, [r7, #32]
			sFilterConfig.FilterNumber = 0;
 8011f3e:	2300      	movs	r3, #0
 8011f40:	61fb      	str	r3, [r7, #28]
			sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
 8011f42:	2301      	movs	r3, #1
 8011f44:	627b      	str	r3, [r7, #36]	; 0x24
			HAL_CAN_ConfigFilter(&(stcan->hcan),&sFilterConfig);
 8011f46:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011f48:	f107 0308 	add.w	r3, r7, #8
 8011f4c:	4610      	mov	r0, r2
 8011f4e:	4619      	mov	r1, r3
 8011f50:	f7f5 f9ee 	bl	8007330 <HAL_CAN_ConfigFilter>
			stcan->hcan.pTxMsg = (CanTxMsgTypeDef*)rt_malloc(sizeof(CanTxMsgTypeDef));
 8011f54:	201c      	movs	r0, #28
 8011f56:	f005 fa89 	bl	801746c <rt_malloc>
 8011f5a:	4602      	mov	r2, r0
 8011f5c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011f5e:	631a      	str	r2, [r3, #48]	; 0x30
			stcan->hcan.pRxMsg = (CanRxMsgTypeDef*)rt_malloc(sizeof(CanRxMsgTypeDef));
 8011f60:	2024      	movs	r0, #36	; 0x24
 8011f62:	f005 fa83 	bl	801746c <rt_malloc>
 8011f66:	4602      	mov	r2, r0
 8011f68:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011f6a:	635a      	str	r2, [r3, #52]	; 0x34
			if(stcan->hcan.pTxMsg == NULL || stcan->hcan.pRxMsg == NULL)
 8011f6c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011f6e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011f70:	2b00      	cmp	r3, #0
 8011f72:	d003      	beq.n	8011f7c <stm32_CANconfigure+0xf4>
 8011f74:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011f76:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011f78:	2b00      	cmp	r3, #0
 8011f7a:	d104      	bne.n	8011f86 <stm32_CANconfigure+0xfe>
			{
				rt_kprintf("malloc fail\r\n");
 8011f7c:	4811      	ldr	r0, [pc, #68]	; (8011fc4 <stm32_CANconfigure+0x13c>)
 8011f7e:	f005 f8c7 	bl	8017110 <rt_kprintf>
				return RT_ERROR;
 8011f82:	2301      	movs	r3, #1
 8011f84:	e016      	b.n	8011fb4 <stm32_CANconfigure+0x12c>
			}
			#if 1
			timerCanrx = rt_timer_create("timerCanrx",timerCanrxfunc,RT_NULL,20,RT_TIMER_FLAG_PERIODIC);
 8011f86:	2302      	movs	r3, #2
 8011f88:	9300      	str	r3, [sp, #0]
 8011f8a:	480f      	ldr	r0, [pc, #60]	; (8011fc8 <stm32_CANconfigure+0x140>)
 8011f8c:	490f      	ldr	r1, [pc, #60]	; (8011fcc <stm32_CANconfigure+0x144>)
 8011f8e:	2200      	movs	r2, #0
 8011f90:	2314      	movs	r3, #20
 8011f92:	f006 fd9b 	bl	8018acc <rt_timer_create>
 8011f96:	4602      	mov	r2, r0
 8011f98:	4b0d      	ldr	r3, [pc, #52]	; (8011fd0 <stm32_CANconfigure+0x148>)
 8011f9a:	601a      	str	r2, [r3, #0]
			if (timerCanrx != RT_NULL) rt_timer_start(timerCanrx);
 8011f9c:	4b0c      	ldr	r3, [pc, #48]	; (8011fd0 <stm32_CANconfigure+0x148>)
 8011f9e:	681b      	ldr	r3, [r3, #0]
 8011fa0:	2b00      	cmp	r3, #0
 8011fa2:	d004      	beq.n	8011fae <stm32_CANconfigure+0x126>
 8011fa4:	4b0a      	ldr	r3, [pc, #40]	; (8011fd0 <stm32_CANconfigure+0x148>)
 8011fa6:	681b      	ldr	r3, [r3, #0]
 8011fa8:	4618      	mov	r0, r3
 8011faa:	f006 fdaf 	bl	8018b0c <rt_timer_start>
			break;
		default:
			return RT_ERROR;
			break;
	}
	return result;
 8011fae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011fb0:	e000      	b.n	8011fb4 <stm32_CANconfigure+0x12c>
			HAL_CAN_Receive_IT(&stcan->hcan,CAN_FIFO1);
			#endif
			/* Enable Error Interrupt */
			break;
		default:
			return RT_ERROR;
 8011fb2:	2301      	movs	r3, #1
			break;
	}
	return result;
}
 8011fb4:	4618      	mov	r0, r3
 8011fb6:	3738      	adds	r7, #56	; 0x38
 8011fb8:	46bd      	mov	sp, r7
 8011fba:	bd80      	pop	{r7, pc}
 8011fbc:	08028874 	.word	0x08028874
 8011fc0:	08028888 	.word	0x08028888
 8011fc4:	0802889c 	.word	0x0802889c
 8011fc8:	080288ac 	.word	0x080288ac
 8011fcc:	08011e6d 	.word	0x08011e6d
 8011fd0:	20010834 	.word	0x20010834

08011fd4 <Can_hw_init>:
	stm32_CANsendmsg,    
	stm32_CANrecvmsg,    
};

int Can_hw_init(void)
{
 8011fd4:	b5b0      	push	{r4, r5, r7, lr}
 8011fd6:	b086      	sub	sp, #24
 8011fd8:	af00      	add	r7, sp, #0
	stm32_canTypeDef *can;
    struct can_configure config = CAN1_CONFIG;
 8011fda:	4b0f      	ldr	r3, [pc, #60]	; (8012018 <Can_hw_init+0x44>)
 8011fdc:	463c      	mov	r4, r7
 8011fde:	461d      	mov	r5, r3
 8011fe0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8011fe2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8011fe4:	682b      	ldr	r3, [r5, #0]
 8011fe6:	6023      	str	r3, [r4, #0]
	
	canDevice1.config = config;
 8011fe8:	4b0c      	ldr	r3, [pc, #48]	; (801201c <Can_hw_init+0x48>)
 8011fea:	f103 0444 	add.w	r4, r3, #68	; 0x44
 8011fee:	463d      	mov	r5, r7
 8011ff0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8011ff2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8011ff4:	682b      	ldr	r3, [r5, #0]
 8011ff6:	6023      	str	r3, [r4, #0]

	can = &can1;
 8011ff8:	4b09      	ldr	r3, [pc, #36]	; (8012020 <Can_hw_init+0x4c>)
 8011ffa:	617b      	str	r3, [r7, #20]
	can->hcan.Instance = CAN1;
 8011ffc:	697b      	ldr	r3, [r7, #20]
 8011ffe:	4a09      	ldr	r2, [pc, #36]	; (8012024 <Can_hw_init+0x50>)
 8012000:	601a      	str	r2, [r3, #0]

	rt_hw_can_register(&canDevice1,"can1",&stm32_can_ops,can);
 8012002:	4806      	ldr	r0, [pc, #24]	; (801201c <Can_hw_init+0x48>)
 8012004:	4908      	ldr	r1, [pc, #32]	; (8012028 <Can_hw_init+0x54>)
 8012006:	4a09      	ldr	r2, [pc, #36]	; (801202c <Can_hw_init+0x58>)
 8012008:	697b      	ldr	r3, [r7, #20]
 801200a:	f009 fd01 	bl	801ba10 <rt_hw_can_register>
	//HAL_CAN_Receive_IT(&hcan,CAN_FIFO1);
	
	/* Enable Error Interrupt */
	__HAL_CAN_ENABLE_IT(&hcan, CAN_IT_ERR);
	#endif
	return 0;
 801200e:	2300      	movs	r3, #0
	
}
 8012010:	4618      	mov	r0, r3
 8012012:	3718      	adds	r7, #24
 8012014:	46bd      	mov	sp, r7
 8012016:	bdb0      	pop	{r4, r5, r7, pc}
 8012018:	080288c0 	.word	0x080288c0
 801201c:	200127ac 	.word	0x200127ac
 8012020:	200128a4 	.word	0x200128a4
 8012024:	40006400 	.word	0x40006400
 8012028:	080288b8 	.word	0x080288b8
 801202c:	0802a50c 	.word	0x0802a50c

08012030 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8012030:	b480      	push	{r7}
 8012032:	b083      	sub	sp, #12
 8012034:	af00      	add	r7, sp, #0
 8012036:	4603      	mov	r3, r0
 8012038:	6039      	str	r1, [r7, #0]
 801203a:	71fb      	strb	r3, [r7, #7]
  if((int32_t)IRQn < 0) {
 801203c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8012040:	2b00      	cmp	r3, #0
 8012042:	da0b      	bge.n	801205c <NVIC_SetPriority+0x2c>
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8012044:	490d      	ldr	r1, [pc, #52]	; (801207c <NVIC_SetPriority+0x4c>)
 8012046:	79fb      	ldrb	r3, [r7, #7]
 8012048:	f003 030f 	and.w	r3, r3, #15
 801204c:	3b04      	subs	r3, #4
 801204e:	683a      	ldr	r2, [r7, #0]
 8012050:	b2d2      	uxtb	r2, r2
 8012052:	0112      	lsls	r2, r2, #4
 8012054:	b2d2      	uxtb	r2, r2
 8012056:	440b      	add	r3, r1
 8012058:	761a      	strb	r2, [r3, #24]
 801205a:	e009      	b.n	8012070 <NVIC_SetPriority+0x40>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]                = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 801205c:	4908      	ldr	r1, [pc, #32]	; (8012080 <NVIC_SetPriority+0x50>)
 801205e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8012062:	683a      	ldr	r2, [r7, #0]
 8012064:	b2d2      	uxtb	r2, r2
 8012066:	0112      	lsls	r2, r2, #4
 8012068:	b2d2      	uxtb	r2, r2
 801206a:	440b      	add	r3, r1
 801206c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 8012070:	370c      	adds	r7, #12
 8012072:	46bd      	mov	sp, r7
 8012074:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012078:	4770      	bx	lr
 801207a:	bf00      	nop
 801207c:	e000ed00 	.word	0xe000ed00
 8012080:	e000e100 	.word	0xe000e100

08012084 <SCB_EnableICache>:
/** \brief Enable I-Cache

    The function turns on I-Cache
  */
__STATIC_INLINE void SCB_EnableICache (void)
{
 8012084:	b480      	push	{r7}
 8012086:	af00      	add	r7, sp, #0
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8012088:	f3bf 8f4f 	dsb	sy
    so that all instructions following the ISB are fetched from cache or
    memory, after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 801208c:	f3bf 8f6f 	isb	sy
  #if (__ICACHE_PRESENT == 1)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     // invalidate I-Cache
 8012090:	4b08      	ldr	r3, [pc, #32]	; (80120b4 <SCB_EnableICache+0x30>)
 8012092:	2200      	movs	r2, #0
 8012094:	f8c3 2250 	str.w	r2, [r3, #592]	; 0x250
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  // enable I-Cache
 8012098:	4a06      	ldr	r2, [pc, #24]	; (80120b4 <SCB_EnableICache+0x30>)
 801209a:	4b06      	ldr	r3, [pc, #24]	; (80120b4 <SCB_EnableICache+0x30>)
 801209c:	695b      	ldr	r3, [r3, #20]
 801209e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80120a2:	6153      	str	r3, [r2, #20]
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80120a4:	f3bf 8f4f 	dsb	sy
    so that all instructions following the ISB are fetched from cache or
    memory, after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 80120a8:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
  #endif
}
 80120ac:	46bd      	mov	sp, r7
 80120ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80120b2:	4770      	bx	lr
 80120b4:	e000ed00 	.word	0xe000ed00

080120b8 <SCB_EnableDCache>:
/** \brief Enable D-Cache

    The function turns on D-Cache
  */
__STATIC_INLINE void SCB_EnableDCache (void)
{
 80120b8:	b480      	push	{r7}
 80120ba:	b089      	sub	sp, #36	; 0x24
 80120bc:	af00      	add	r7, sp, #0
  #if (__DCACHE_PRESENT == 1)
    uint32_t ccsidr, sshift, wshift, sw;
    uint32_t sets, ways;

    SCB->CSSELR = (0UL << 1) | 0UL;         // Level 1 data cache
 80120be:	4b25      	ldr	r3, [pc, #148]	; (8012154 <SCB_EnableDCache+0x9c>)
 80120c0:	2200      	movs	r2, #0
 80120c2:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    ccsidr  = SCB->CCSIDR;
 80120c6:	4b23      	ldr	r3, [pc, #140]	; (8012154 <SCB_EnableDCache+0x9c>)
 80120c8:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80120cc:	617b      	str	r3, [r7, #20]
    sets    = (uint32_t)(CCSIDR_SETS(ccsidr));
 80120ce:	697a      	ldr	r2, [r7, #20]
 80120d0:	4b21      	ldr	r3, [pc, #132]	; (8012158 <SCB_EnableDCache+0xa0>)
 80120d2:	4013      	ands	r3, r2
 80120d4:	0b5b      	lsrs	r3, r3, #13
 80120d6:	61fb      	str	r3, [r7, #28]
    sshift  = (uint32_t)(CCSIDR_LSSHIFT(ccsidr) + 4UL);
 80120d8:	697b      	ldr	r3, [r7, #20]
 80120da:	f003 0307 	and.w	r3, r3, #7
 80120de:	3304      	adds	r3, #4
 80120e0:	613b      	str	r3, [r7, #16]
    ways    = (uint32_t)(CCSIDR_WAYS(ccsidr));
 80120e2:	697a      	ldr	r2, [r7, #20]
 80120e4:	f641 73f8 	movw	r3, #8184	; 0x1ff8
 80120e8:	4013      	ands	r3, r2
 80120ea:	08db      	lsrs	r3, r3, #3
 80120ec:	60fb      	str	r3, [r7, #12]
    wshift  = (uint32_t)((uint32_t)__CLZ(ways) & 0x1FUL);
 80120ee:	68fb      	ldr	r3, [r7, #12]
 80120f0:	fab3 f383 	clz	r3, r3
 80120f4:	f003 031f 	and.w	r3, r3, #31
 80120f8:	60bb      	str	r3, [r7, #8]
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80120fa:	f3bf 8f4f 	dsb	sy

    __DSB();

    do {                                   // invalidate D-Cache
         uint32_t tmpways = ways;
 80120fe:	68fb      	ldr	r3, [r7, #12]
 8012100:	61bb      	str	r3, [r7, #24]
         do {
              sw = ((tmpways << wshift) | (sets << sshift));
 8012102:	68bb      	ldr	r3, [r7, #8]
 8012104:	69ba      	ldr	r2, [r7, #24]
 8012106:	409a      	lsls	r2, r3
 8012108:	693b      	ldr	r3, [r7, #16]
 801210a:	69f9      	ldr	r1, [r7, #28]
 801210c:	fa01 f303 	lsl.w	r3, r1, r3
 8012110:	4313      	orrs	r3, r2
 8012112:	607b      	str	r3, [r7, #4]
              SCB->DCISW = sw;
 8012114:	4a0f      	ldr	r2, [pc, #60]	; (8012154 <SCB_EnableDCache+0x9c>)
 8012116:	687b      	ldr	r3, [r7, #4]
 8012118:	f8c2 3260 	str.w	r3, [r2, #608]	; 0x260
            } while(tmpways--);
 801211c:	69bb      	ldr	r3, [r7, #24]
 801211e:	1e5a      	subs	r2, r3, #1
 8012120:	61ba      	str	r2, [r7, #24]
 8012122:	2b00      	cmp	r3, #0
 8012124:	d1ed      	bne.n	8012102 <SCB_EnableDCache+0x4a>
        } while(sets--);
 8012126:	69fb      	ldr	r3, [r7, #28]
 8012128:	1e5a      	subs	r2, r3, #1
 801212a:	61fa      	str	r2, [r7, #28]
 801212c:	2b00      	cmp	r3, #0
 801212e:	d1e6      	bne.n	80120fe <SCB_EnableDCache+0x46>
 8012130:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;   // enable D-Cache
 8012134:	4a07      	ldr	r2, [pc, #28]	; (8012154 <SCB_EnableDCache+0x9c>)
 8012136:	4b07      	ldr	r3, [pc, #28]	; (8012154 <SCB_EnableDCache+0x9c>)
 8012138:	695b      	ldr	r3, [r3, #20]
 801213a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 801213e:	6153      	str	r3, [r2, #20]
 8012140:	f3bf 8f4f 	dsb	sy
    so that all instructions following the ISB are fetched from cache or
    memory, after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 8012144:	f3bf 8f6f 	isb	sy

    __DSB();
    __ISB();
  #endif
}
 8012148:	3724      	adds	r7, #36	; 0x24
 801214a:	46bd      	mov	sp, r7
 801214c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012150:	4770      	bx	lr
 8012152:	bf00      	nop
 8012154:	e000ed00 	.word	0xe000ed00
 8012158:	0fffe000 	.word	0x0fffe000

0801215c <SysTick_Config>:
    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 801215c:	b580      	push	{r7, lr}
 801215e:	b082      	sub	sp, #8
 8012160:	af00      	add	r7, sp, #0
 8012162:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
 8012164:	687b      	ldr	r3, [r7, #4]
 8012166:	3b01      	subs	r3, #1
 8012168:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 801216c:	d301      	bcc.n	8012172 <SysTick_Config+0x16>
 801216e:	2301      	movs	r3, #1
 8012170:	e00f      	b.n	8012192 <SysTick_Config+0x36>

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8012172:	4a0a      	ldr	r2, [pc, #40]	; (801219c <SysTick_Config+0x40>)
 8012174:	687b      	ldr	r3, [r7, #4]
 8012176:	3b01      	subs	r3, #1
 8012178:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 801217a:	f04f 30ff 	mov.w	r0, #4294967295
 801217e:	210f      	movs	r1, #15
 8012180:	f7ff ff56 	bl	8012030 <NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8012184:	4b05      	ldr	r3, [pc, #20]	; (801219c <SysTick_Config+0x40>)
 8012186:	2200      	movs	r2, #0
 8012188:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 801218a:	4b04      	ldr	r3, [pc, #16]	; (801219c <SysTick_Config+0x40>)
 801218c:	2207      	movs	r2, #7
 801218e:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8012190:	2300      	movs	r3, #0
}
 8012192:	4618      	mov	r0, r3
 8012194:	3708      	adds	r7, #8
 8012196:	46bd      	mov	sp, r7
 8012198:	bd80      	pop	{r7, pc}
 801219a:	bf00      	nop
 801219c:	e000e010 	.word	0xe000e010

080121a0 <SystemClock_Config>:
  *            Flash Latency(WS)              = 6
  * @param  None
  * @retval None
  */
static void SystemClock_Config(void)
{
 80121a0:	b580      	push	{r7, lr}
 80121a2:	b092      	sub	sp, #72	; 0x48
 80121a4:	af00      	add	r7, sp, #0
    RCC_ClkInitTypeDef RCC_ClkInitStruct;
    RCC_OscInitTypeDef RCC_OscInitStruct;
    HAL_StatusTypeDef ret = HAL_OK;
 80121a6:	2300      	movs	r3, #0
 80121a8:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47

    /* Enable HSE Oscillator and activate PLL with HSE as source 
	PLLCLK= (HSE*N)/(M*P) */
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80121ac:	2301      	movs	r3, #1
 80121ae:	603b      	str	r3, [r7, #0]
    RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 80121b0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80121b4:	607b      	str	r3, [r7, #4]
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80121b6:	2302      	movs	r3, #2
 80121b8:	61bb      	str	r3, [r7, #24]
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80121ba:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 80121be:	61fb      	str	r3, [r7, #28]
    RCC_OscInitStruct.PLL.PLLM = 25;
 80121c0:	2319      	movs	r3, #25
 80121c2:	623b      	str	r3, [r7, #32]
    RCC_OscInitStruct.PLL.PLLN = 400;
 80121c4:	f44f 73c8 	mov.w	r3, #400	; 0x190
 80121c8:	627b      	str	r3, [r7, #36]	; 0x24
    RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 80121ca:	2302      	movs	r3, #2
 80121cc:	62bb      	str	r3, [r7, #40]	; 0x28
    RCC_OscInitStruct.PLL.PLLQ = 8;
 80121ce:	2308      	movs	r3, #8
 80121d0:	62fb      	str	r3, [r7, #44]	; 0x2c
    
    ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
 80121d2:	463b      	mov	r3, r7
 80121d4:	4618      	mov	r0, r3
 80121d6:	f7fb f851 	bl	800d27c <HAL_RCC_OscConfig>
 80121da:	4603      	mov	r3, r0
 80121dc:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
    if(ret != HAL_OK)
 80121e0:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80121e4:	2b00      	cmp	r3, #0
 80121e6:	d000      	beq.n	80121ea <SystemClock_Config+0x4a>
    {
        while(1) { ; }
 80121e8:	e7fe      	b.n	80121e8 <SystemClock_Config+0x48>
    }

    ret = HAL_PWREx_EnableOverDrive();
 80121ea:	f7fa fff9 	bl	800d1e0 <HAL_PWREx_EnableOverDrive>
 80121ee:	4603      	mov	r3, r0
 80121f0:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
    if (ret != HAL_OK)
 80121f4:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80121f8:	2b00      	cmp	r3, #0
 80121fa:	d000      	beq.n	80121fe <SystemClock_Config+0x5e>
    {
        while (1) { ; }
 80121fc:	e7fe      	b.n	80121fc <SystemClock_Config+0x5c>
    /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
       clocks dividers 
       PCLK1  = 50MHz
       PCLK2 = 100MHz
       TIM1CLK = 100MHz */
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
 80121fe:	230f      	movs	r3, #15
 8012200:	633b      	str	r3, [r7, #48]	; 0x30
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8012202:	2302      	movs	r3, #2
 8012204:	637b      	str	r3, [r7, #52]	; 0x34
    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8012206:	2300      	movs	r3, #0
 8012208:	63bb      	str	r3, [r7, #56]	; 0x38
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 801220a:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 801220e:	63fb      	str	r3, [r7, #60]	; 0x3c
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8012210:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8012214:	643b      	str	r3, [r7, #64]	; 0x40
    ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6);
 8012216:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801221a:	4618      	mov	r0, r3
 801221c:	2106      	movs	r1, #6
 801221e:	f7fb fb03 	bl	800d828 <HAL_RCC_ClockConfig>
 8012222:	4603      	mov	r3, r0
 8012224:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
    if (ret != HAL_OK)
 8012228:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801222c:	2b00      	cmp	r3, #0
 801222e:	d000      	beq.n	8012232 <SystemClock_Config+0x92>
    {
        while (1) { ; }
 8012230:	e7fe      	b.n	8012230 <SystemClock_Config+0x90>
    }
}
 8012232:	3748      	adds	r7, #72	; 0x48
 8012234:	46bd      	mov	sp, r7
 8012236:	bd80      	pop	{r7, pc}

08012238 <CPU_CACHE_Enable>:
  * @brief  CPU L1-Cache enable.
  * @param  None
  * @retval None
  */
static void CPU_CACHE_Enable(void)
{
 8012238:	b580      	push	{r7, lr}
 801223a:	af00      	add	r7, sp, #0
    /* Enable branch prediction */
    SCB->CCR |= (1 << 18);
 801223c:	4a06      	ldr	r2, [pc, #24]	; (8012258 <CPU_CACHE_Enable+0x20>)
 801223e:	4b06      	ldr	r3, [pc, #24]	; (8012258 <CPU_CACHE_Enable+0x20>)
 8012240:	695b      	ldr	r3, [r3, #20]
 8012242:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8012246:	6153      	str	r3, [r2, #20]
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8012248:	f3bf 8f4f 	dsb	sy
    __DSB();

    /* Enable I-Cache */
    SCB_EnableICache();
 801224c:	f7ff ff1a 	bl	8012084 <SCB_EnableICache>

    /* Enable D-Cache */
    SCB_EnableDCache();
 8012250:	f7ff ff32 	bl	80120b8 <SCB_EnableDCache>
}
 8012254:	bd80      	pop	{r7, pc}
 8012256:	bf00      	nop
 8012258:	e000ed00 	.word	0xe000ed00

0801225c <SysTick_Handler>:
/**
 * This is the timer interrupt service routine.
 *
 */
void SysTick_Handler(void)
{
 801225c:	b580      	push	{r7, lr}
 801225e:	af00      	add	r7, sp, #0
    /* enter interrupt */
    rt_interrupt_enter();
 8012260:	f004 f946 	bl	80164f0 <rt_interrupt_enter>

    /* tick for HAL Library */
    HAL_IncTick();
 8012264:	f7f3 ffea 	bl	800623c <HAL_IncTick>
	#ifdef USER_USING_MOTORCONTROL
	MC_SysTickHandler();
	#endif
    rt_tick_increase();
 8012268:	f003 f81a 	bl	80152a0 <rt_tick_increase>
    /* leave interrupt */
    rt_interrupt_leave();
 801226c:	f004 f956 	bl	801651c <rt_interrupt_leave>
}
 8012270:	bd80      	pop	{r7, pc}
 8012272:	bf00      	nop

08012274 <HAL_InitTick>:

/* re-implementat tick interface for STM32 HAL */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8012274:	b580      	push	{r7, lr}
 8012276:	b082      	sub	sp, #8
 8012278:	af00      	add	r7, sp, #0
 801227a:	6078      	str	r0, [r7, #4]
    /*Configure the SysTick to have interrupt in 1ms time basis*/
    HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/RT_TICK_PER_SECOND);
 801227c:	f7fb fcb6 	bl	800dbec <HAL_RCC_GetHCLKFreq>
 8012280:	4602      	mov	r2, r0
 8012282:	4b09      	ldr	r3, [pc, #36]	; (80122a8 <HAL_InitTick+0x34>)
 8012284:	fba3 2302 	umull	r2, r3, r3, r2
 8012288:	09db      	lsrs	r3, r3, #7
 801228a:	4618      	mov	r0, r3
 801228c:	f7f6 f82e 	bl	80082ec <HAL_SYSTICK_Config>

    /*Configure the SysTick IRQ priority */
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 8012290:	f04f 30ff 	mov.w	r0, #4294967295
 8012294:	6879      	ldr	r1, [r7, #4]
 8012296:	2200      	movs	r2, #0
 8012298:	f7f5 fff0 	bl	800827c <HAL_NVIC_SetPriority>

    /* Return function status */
    return HAL_OK;
 801229c:	2300      	movs	r3, #0
}
 801229e:	4618      	mov	r0, r3
 80122a0:	3708      	adds	r7, #8
 80122a2:	46bd      	mov	sp, r7
 80122a4:	bd80      	pop	{r7, pc}
 80122a6:	bf00      	nop
 80122a8:	10624dd3 	.word	0x10624dd3

080122ac <rt_hw_board_init>:

/**
 * This function will initial STM32 board.
 */
void rt_hw_board_init()
{
 80122ac:	b580      	push	{r7, lr}
 80122ae:	af00      	add	r7, sp, #0
    /* Configure the MPU attributes as Write Through */
    mpu_init();
 80122b0:	f001 f896 	bl	80133e0 <mpu_init>

    /* Enable the CPU Cache */
    CPU_CACHE_Enable();
 80122b4:	f7ff ffc0 	bl	8012238 <CPU_CACHE_Enable>
    - Configure the Flash ART accelerator on ITCM interface
    - Configure the Systick to generate an interrupt each 1 msec
    - Set NVIC Group Priority to 4
    - Global MSP (MCU Support Package) initialization
    */
    HAL_Init();
 80122b8:	f7f3 ffaa 	bl	8006210 <HAL_Init>
    /* Configure the system clock @ 200 Mhz */
    SystemClock_Config();
 80122bc:	f7ff ff70 	bl	80121a0 <SystemClock_Config>
    /* init systick */
    SysTick_Config(SystemCoreClock / RT_TICK_PER_SECOND);
 80122c0:	4b09      	ldr	r3, [pc, #36]	; (80122e8 <rt_hw_board_init+0x3c>)
 80122c2:	681b      	ldr	r3, [r3, #0]
 80122c4:	4a09      	ldr	r2, [pc, #36]	; (80122ec <rt_hw_board_init+0x40>)
 80122c6:	fba2 2303 	umull	r2, r3, r2, r3
 80122ca:	09db      	lsrs	r3, r3, #7
 80122cc:	4618      	mov	r0, r3
 80122ce:	f7ff ff45 	bl	801215c <SysTick_Config>
    /* set pend exception priority */
    NVIC_SetPriority(PendSV_IRQn, (1 << __NVIC_PRIO_BITS) - 1);
 80122d2:	f06f 0001 	mvn.w	r0, #1
 80122d6:	210f      	movs	r1, #15
 80122d8:	f7ff feaa 	bl	8012030 <NVIC_SetPriority>

    rt_components_board_init();
 80122dc:	f003 f832 	bl	8015344 <rt_components_board_init>

#ifdef RT_USING_CONSOLE
    rt_console_set_device(RT_CONSOLE_DEVICE_NAME);
 80122e0:	4803      	ldr	r0, [pc, #12]	; (80122f0 <rt_hw_board_init+0x44>)
 80122e2:	f004 fee5 	bl	80170b0 <rt_console_set_device>
#endif
}
 80122e6:	bd80      	pop	{r7, pc}
 80122e8:	20010014 	.word	0x20010014
 80122ec:	10624dd3 	.word	0x10624dd3
 80122f0:	080288d4 	.word	0x080288d4

080122f4 <QIEMW_ADC_init>:

QIEMW_ADC_HandleTypeDef Global_User_ADC;


void QIEMW_ADC_init(QIEMW_ADC_HandleTypeDef *QIEMW_ADC_Handle)
{
 80122f4:	b480      	push	{r7}
 80122f6:	b083      	sub	sp, #12
 80122f8:	af00      	add	r7, sp, #0
 80122fa:	6078      	str	r0, [r7, #4]
	QIEMW_ADC_Handle->PhaseA.qI1_offset= 0;
 80122fc:	687b      	ldr	r3, [r7, #4]
 80122fe:	2200      	movs	r2, #0
 8012300:	809a      	strh	r2, [r3, #4]
	QIEMW_ADC_Handle->PhaseA.qI2_offset= 0;
 8012302:	687b      	ldr	r3, [r7, #4]
 8012304:	2200      	movs	r2, #0
 8012306:	811a      	strh	r2, [r3, #8]
	QIEMW_ADC_Handle->PhaseA.qV_offset= 0;
 8012308:	687b      	ldr	r3, [r7, #4]
 801230a:	2200      	movs	r2, #0
 801230c:	819a      	strh	r2, [r3, #12]
	QIEMW_ADC_Handle->PhaseB.qI1_offset = 0;
 801230e:	687b      	ldr	r3, [r7, #4]
 8012310:	2200      	movs	r2, #0
 8012312:	825a      	strh	r2, [r3, #18]
	QIEMW_ADC_Handle->PhaseB.qI2_offset = 0;
 8012314:	687b      	ldr	r3, [r7, #4]
 8012316:	2200      	movs	r2, #0
 8012318:	82da      	strh	r2, [r3, #22]
	QIEMW_ADC_Handle->PhaseB.qV_offset = 0;
 801231a:	687b      	ldr	r3, [r7, #4]
 801231c:	2200      	movs	r2, #0
 801231e:	835a      	strh	r2, [r3, #26]
	QIEMW_ADC_Handle->PhaseC.qI1_offset = 0;
 8012320:	687b      	ldr	r3, [r7, #4]
 8012322:	2200      	movs	r2, #0
 8012324:	841a      	strh	r2, [r3, #32]
	QIEMW_ADC_Handle->PhaseC.qI2_offset = 0;
 8012326:	687b      	ldr	r3, [r7, #4]
 8012328:	2200      	movs	r2, #0
 801232a:	849a      	strh	r2, [r3, #36]	; 0x24
	QIEMW_ADC_Handle->PhaseC.qV_offset = 0;
 801232c:	687b      	ldr	r3, [r7, #4]
 801232e:	2200      	movs	r2, #0
 8012330:	851a      	strh	r2, [r3, #40]	; 0x28
	QIEMW_ADC_Handle->BUS.qV_offset = 0;
 8012332:	687b      	ldr	r3, [r7, #4]
 8012334:	2200      	movs	r2, #0
 8012336:	861a      	strh	r2, [r3, #48]	; 0x30
	QIEMW_ADC_Handle->BUS.qI_offset = 0;
 8012338:	687b      	ldr	r3, [r7, #4]
 801233a:	2200      	movs	r2, #0
 801233c:	859a      	strh	r2, [r3, #44]	; 0x2c
	QIEMW_ADC_Handle->UR.qV_offset = 0;
 801233e:	687b      	ldr	r3, [r7, #4]
 8012340:	2200      	movs	r2, #0
 8012342:	87da      	strh	r2, [r3, #62]	; 0x3e
	QIEMW_ADC_Handle->US.qV_offset = 0;
 8012344:	687b      	ldr	r3, [r7, #4]
 8012346:	2200      	movs	r2, #0
 8012348:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
	QIEMW_ADC_Handle->UT.qV_offset = 0;
 801234c:	687b      	ldr	r3, [r7, #4]
 801234e:	2200      	movs	r2, #0
 8012350:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a
	QIEMW_ADC_Handle->Temp.TEMP_offset = 0;
 8012354:	687b      	ldr	r3, [r7, #4]
 8012356:	2200      	movs	r2, #0
 8012358:	f8a3 205e 	strh.w	r2, [r3, #94]	; 0x5e
	

	QIEMW_ADC_Handle->PhaseA.qI_value = 0;
 801235c:	687b      	ldr	r3, [r7, #4]
 801235e:	2200      	movs	r2, #0
 8012360:	805a      	strh	r2, [r3, #2]
	QIEMW_ADC_Handle->PhaseA.qI1_value = 0;
 8012362:	687b      	ldr	r3, [r7, #4]
 8012364:	2200      	movs	r2, #0
 8012366:	801a      	strh	r2, [r3, #0]
	QIEMW_ADC_Handle->PhaseA.qI2_value = 0;
 8012368:	687b      	ldr	r3, [r7, #4]
 801236a:	2200      	movs	r2, #0
 801236c:	80da      	strh	r2, [r3, #6]
	QIEMW_ADC_Handle->PhaseA.qV_value = 0;
 801236e:	687b      	ldr	r3, [r7, #4]
 8012370:	2200      	movs	r2, #0
 8012372:	815a      	strh	r2, [r3, #10]
	QIEMW_ADC_Handle->PhaseB.qI_value = 0;
 8012374:	687b      	ldr	r3, [r7, #4]
 8012376:	2200      	movs	r2, #0
 8012378:	821a      	strh	r2, [r3, #16]
	QIEMW_ADC_Handle->PhaseB.qI1_value = 0;
 801237a:	687b      	ldr	r3, [r7, #4]
 801237c:	2200      	movs	r2, #0
 801237e:	81da      	strh	r2, [r3, #14]
	QIEMW_ADC_Handle->PhaseB.qI2_value = 0;
 8012380:	687b      	ldr	r3, [r7, #4]
 8012382:	2200      	movs	r2, #0
 8012384:	829a      	strh	r2, [r3, #20]
	QIEMW_ADC_Handle->PhaseB.qV_value = 0;
 8012386:	687b      	ldr	r3, [r7, #4]
 8012388:	2200      	movs	r2, #0
 801238a:	831a      	strh	r2, [r3, #24]
	QIEMW_ADC_Handle->PhaseC.qI1_value = 0;
 801238c:	687b      	ldr	r3, [r7, #4]
 801238e:	2200      	movs	r2, #0
 8012390:	839a      	strh	r2, [r3, #28]
	QIEMW_ADC_Handle->PhaseC.qI2_value = 0;
 8012392:	687b      	ldr	r3, [r7, #4]
 8012394:	2200      	movs	r2, #0
 8012396:	845a      	strh	r2, [r3, #34]	; 0x22
	QIEMW_ADC_Handle->PhaseC.qI_value = 0;
 8012398:	687b      	ldr	r3, [r7, #4]
 801239a:	2200      	movs	r2, #0
 801239c:	83da      	strh	r2, [r3, #30]
	QIEMW_ADC_Handle->PhaseC.qV_value = 0;
 801239e:	687b      	ldr	r3, [r7, #4]
 80123a0:	2200      	movs	r2, #0
 80123a2:	84da      	strh	r2, [r3, #38]	; 0x26
	QIEMW_ADC_Handle->BUS.qV_value = 0;
 80123a4:	687b      	ldr	r3, [r7, #4]
 80123a6:	2200      	movs	r2, #0
 80123a8:	85da      	strh	r2, [r3, #46]	; 0x2e
	QIEMW_ADC_Handle->BUS.qI_value = 0;
 80123aa:	687b      	ldr	r3, [r7, #4]
 80123ac:	2200      	movs	r2, #0
 80123ae:	855a      	strh	r2, [r3, #42]	; 0x2a
	QIEMW_ADC_Handle->UR.qV_value = 0;
 80123b0:	687b      	ldr	r3, [r7, #4]
 80123b2:	2200      	movs	r2, #0
 80123b4:	879a      	strh	r2, [r3, #60]	; 0x3c
	QIEMW_ADC_Handle->US.qV_value = 0;
 80123b6:	687b      	ldr	r3, [r7, #4]
 80123b8:	2200      	movs	r2, #0
 80123ba:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
	QIEMW_ADC_Handle->UT.qV_value = 0;
 80123be:	687b      	ldr	r3, [r7, #4]
 80123c0:	2200      	movs	r2, #0
 80123c2:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
	QIEMW_ADC_Handle->Temp.TEMP_value = 0;
 80123c6:	687b      	ldr	r3, [r7, #4]
 80123c8:	2200      	movs	r2, #0
 80123ca:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
}
 80123ce:	370c      	adds	r7, #12
 80123d0:	46bd      	mov	sp, r7
 80123d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80123d6:	4770      	bx	lr

080123d8 <ADC_Calibration>:

void ADC_Calibration(ADC_HandleTypeDef* hadc,QIEMW_ADC_HandleTypeDef *QIEMW_ADC_Handle)
{
 80123d8:	b580      	push	{r7, lr}
 80123da:	b088      	sub	sp, #32
 80123dc:	af00      	add	r7, sp, #0
 80123de:	6078      	str	r0, [r7, #4]
 80123e0:	6039      	str	r1, [r7, #0]
	u8 bIndex;
	
	ADC_ChannelConfTypeDef sConfig;
	HAL_NVIC_DisableIRQ(ADC_IRQn);
 80123e2:	2012      	movs	r0, #18
 80123e4:	f7f5 ff74 	bl	80082d0 <HAL_NVIC_DisableIRQ>
	HAL_ADCEx_InjectedStop_IT(hadc);
 80123e8:	6878      	ldr	r0, [r7, #4]
 80123ea:	f7f4 fc5f 	bl	8006cac <HAL_ADCEx_InjectedStop_IT>
	
	if(hadc->Instance == ADC1)
 80123ee:	687b      	ldr	r3, [r7, #4]
 80123f0:	681b      	ldr	r3, [r3, #0]
 80123f2:	4aab      	ldr	r2, [pc, #684]	; (80126a0 <ADC_Calibration+0x2c8>)
 80123f4:	4293      	cmp	r3, r2
 80123f6:	f040 80d2 	bne.w	801259e <ADC_Calibration+0x1c6>
	{
		
		sConfig.Channel = PHASE_C1_CURRENT_CHANNEL;
 80123fa:	2306      	movs	r3, #6
 80123fc:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 80123fe:	2301      	movs	r3, #1
 8012400:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 8012402:	2302      	movs	r3, #2
 8012404:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 8012406:	f107 030c 	add.w	r3, r7, #12
 801240a:	6878      	ldr	r0, [r7, #4]
 801240c:	4619      	mov	r1, r3
 801240e:	f7f4 f96b 	bl	80066e8 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012412:	2310      	movs	r3, #16
 8012414:	77fb      	strb	r3, [r7, #31]
 8012416:	e021      	b.n	801245c <ADC_Calibration+0x84>
		{
			HAL_ADC_Start(hadc);
 8012418:	6878      	ldr	r0, [r7, #4]
 801241a:	f7f3 ff73 	bl	8006304 <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 801241e:	bf00      	nop
 8012420:	687b      	ldr	r3, [r7, #4]
 8012422:	681b      	ldr	r3, [r3, #0]
 8012424:	681b      	ldr	r3, [r3, #0]
 8012426:	f003 0302 	and.w	r3, r3, #2
 801242a:	2b00      	cmp	r3, #0
 801242c:	d0f8      	beq.n	8012420 <ADC_Calibration+0x48>
			QIEMW_ADC_Handle->PhaseC.qI1_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 801242e:	6878      	ldr	r0, [r7, #4]
 8012430:	f7f4 f92e 	bl	8006690 <HAL_ADC_GetValue>
 8012434:	4603      	mov	r3, r0
 8012436:	b29b      	uxth	r3, r3
 8012438:	091b      	lsrs	r3, r3, #4
 801243a:	b29b      	uxth	r3, r3
 801243c:	4619      	mov	r1, r3
 801243e:	683b      	ldr	r3, [r7, #0]
 8012440:	8c1a      	ldrh	r2, [r3, #32]
 8012442:	b28b      	uxth	r3, r1
 8012444:	4413      	add	r3, r2
 8012446:	b29a      	uxth	r2, r3
 8012448:	683b      	ldr	r3, [r7, #0]
 801244a:	841a      	strh	r2, [r3, #32]
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 801244c:	687b      	ldr	r3, [r7, #4]
 801244e:	681b      	ldr	r3, [r3, #0]
 8012450:	f06f 0202 	mvn.w	r2, #2
 8012454:	601a      	str	r2, [r3, #0]
		
		sConfig.Channel = PHASE_C1_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012456:	7ffb      	ldrb	r3, [r7, #31]
 8012458:	3b01      	subs	r3, #1
 801245a:	77fb      	strb	r3, [r7, #31]
 801245c:	7ffb      	ldrb	r3, [r7, #31]
 801245e:	2b00      	cmp	r3, #0
 8012460:	d1da      	bne.n	8012418 <ADC_Calibration+0x40>
			HAL_ADC_Start(hadc);
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
			QIEMW_ADC_Handle->PhaseC.qI1_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_C2_CURRENT_CHANNEL;
 8012462:	2309      	movs	r3, #9
 8012464:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 8012466:	2301      	movs	r3, #1
 8012468:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 801246a:	2302      	movs	r3, #2
 801246c:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 801246e:	f107 030c 	add.w	r3, r7, #12
 8012472:	6878      	ldr	r0, [r7, #4]
 8012474:	4619      	mov	r1, r3
 8012476:	f7f4 f937 	bl	80066e8 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 801247a:	2310      	movs	r3, #16
 801247c:	77fb      	strb	r3, [r7, #31]
 801247e:	e021      	b.n	80124c4 <ADC_Calibration+0xec>
		{
			HAL_ADC_Start(hadc);
 8012480:	6878      	ldr	r0, [r7, #4]
 8012482:	f7f3 ff3f 	bl	8006304 <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 8012486:	bf00      	nop
 8012488:	687b      	ldr	r3, [r7, #4]
 801248a:	681b      	ldr	r3, [r3, #0]
 801248c:	681b      	ldr	r3, [r3, #0]
 801248e:	f003 0302 	and.w	r3, r3, #2
 8012492:	2b00      	cmp	r3, #0
 8012494:	d0f8      	beq.n	8012488 <ADC_Calibration+0xb0>
			QIEMW_ADC_Handle->PhaseC.qI2_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 8012496:	6878      	ldr	r0, [r7, #4]
 8012498:	f7f4 f8fa 	bl	8006690 <HAL_ADC_GetValue>
 801249c:	4603      	mov	r3, r0
 801249e:	b29b      	uxth	r3, r3
 80124a0:	091b      	lsrs	r3, r3, #4
 80124a2:	b29b      	uxth	r3, r3
 80124a4:	4619      	mov	r1, r3
 80124a6:	683b      	ldr	r3, [r7, #0]
 80124a8:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 80124aa:	b28b      	uxth	r3, r1
 80124ac:	4413      	add	r3, r2
 80124ae:	b29a      	uxth	r2, r3
 80124b0:	683b      	ldr	r3, [r7, #0]
 80124b2:	849a      	strh	r2, [r3, #36]	; 0x24
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 80124b4:	687b      	ldr	r3, [r7, #4]
 80124b6:	681b      	ldr	r3, [r3, #0]
 80124b8:	f06f 0202 	mvn.w	r2, #2
 80124bc:	601a      	str	r2, [r3, #0]
		}
		sConfig.Channel = PHASE_C2_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 80124be:	7ffb      	ldrb	r3, [r7, #31]
 80124c0:	3b01      	subs	r3, #1
 80124c2:	77fb      	strb	r3, [r7, #31]
 80124c4:	7ffb      	ldrb	r3, [r7, #31]
 80124c6:	2b00      	cmp	r3, #0
 80124c8:	d1da      	bne.n	8012480 <ADC_Calibration+0xa8>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
			QIEMW_ADC_Handle->PhaseC.qI2_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_C_VOLTAGE_CHANNEL;
 80124ca:	2305      	movs	r3, #5
 80124cc:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 80124ce:	2301      	movs	r3, #1
 80124d0:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 80124d2:	2302      	movs	r3, #2
 80124d4:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 80124d6:	f107 030c 	add.w	r3, r7, #12
 80124da:	6878      	ldr	r0, [r7, #4]
 80124dc:	4619      	mov	r1, r3
 80124de:	f7f4 f903 	bl	80066e8 <HAL_ADC_ConfigChannel>
		
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 80124e2:	2310      	movs	r3, #16
 80124e4:	77fb      	strb	r3, [r7, #31]
 80124e6:	e021      	b.n	801252c <ADC_Calibration+0x154>
		{
			HAL_ADC_Start(hadc);
 80124e8:	6878      	ldr	r0, [r7, #4]
 80124ea:	f7f3 ff0b 	bl	8006304 <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 80124ee:	bf00      	nop
 80124f0:	687b      	ldr	r3, [r7, #4]
 80124f2:	681b      	ldr	r3, [r3, #0]
 80124f4:	681b      	ldr	r3, [r3, #0]
 80124f6:	f003 0302 	and.w	r3, r3, #2
 80124fa:	2b00      	cmp	r3, #0
 80124fc:	d0f8      	beq.n	80124f0 <ADC_Calibration+0x118>
			QIEMW_ADC_Handle->PhaseC.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 80124fe:	6878      	ldr	r0, [r7, #4]
 8012500:	f7f4 f8c6 	bl	8006690 <HAL_ADC_GetValue>
 8012504:	4603      	mov	r3, r0
 8012506:	b29b      	uxth	r3, r3
 8012508:	091b      	lsrs	r3, r3, #4
 801250a:	b29b      	uxth	r3, r3
 801250c:	4619      	mov	r1, r3
 801250e:	683b      	ldr	r3, [r7, #0]
 8012510:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8012512:	b28b      	uxth	r3, r1
 8012514:	4413      	add	r3, r2
 8012516:	b29a      	uxth	r2, r3
 8012518:	683b      	ldr	r3, [r7, #0]
 801251a:	851a      	strh	r2, [r3, #40]	; 0x28
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 801251c:	687b      	ldr	r3, [r7, #4]
 801251e:	681b      	ldr	r3, [r3, #0]
 8012520:	f06f 0202 	mvn.w	r2, #2
 8012524:	601a      	str	r2, [r3, #0]
		sConfig.Channel = PHASE_C_VOLTAGE_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012526:	7ffb      	ldrb	r3, [r7, #31]
 8012528:	3b01      	subs	r3, #1
 801252a:	77fb      	strb	r3, [r7, #31]
 801252c:	7ffb      	ldrb	r3, [r7, #31]
 801252e:	2b00      	cmp	r3, #0
 8012530:	d1da      	bne.n	80124e8 <ADC_Calibration+0x110>
			QIEMW_ADC_Handle->PhaseC.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}

		sConfig.Channel = PHASE_TEMP_CHANNEL;
 8012532:	2308      	movs	r3, #8
 8012534:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 8012536:	2301      	movs	r3, #1
 8012538:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 801253a:	2302      	movs	r3, #2
 801253c:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 801253e:	f107 030c 	add.w	r3, r7, #12
 8012542:	6878      	ldr	r0, [r7, #4]
 8012544:	4619      	mov	r1, r3
 8012546:	f7f4 f8cf 	bl	80066e8 <HAL_ADC_ConfigChannel>
		
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 801254a:	2310      	movs	r3, #16
 801254c:	77fb      	strb	r3, [r7, #31]
 801254e:	e023      	b.n	8012598 <ADC_Calibration+0x1c0>
		{
			HAL_ADC_Start(hadc);
 8012550:	6878      	ldr	r0, [r7, #4]
 8012552:	f7f3 fed7 	bl	8006304 <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 8012556:	bf00      	nop
 8012558:	687b      	ldr	r3, [r7, #4]
 801255a:	681b      	ldr	r3, [r3, #0]
 801255c:	681b      	ldr	r3, [r3, #0]
 801255e:	f003 0302 	and.w	r3, r3, #2
 8012562:	2b00      	cmp	r3, #0
 8012564:	d0f8      	beq.n	8012558 <ADC_Calibration+0x180>
			QIEMW_ADC_Handle->Temp.TEMP_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 8012566:	6878      	ldr	r0, [r7, #4]
 8012568:	f7f4 f892 	bl	8006690 <HAL_ADC_GetValue>
 801256c:	4603      	mov	r3, r0
 801256e:	b29b      	uxth	r3, r3
 8012570:	091b      	lsrs	r3, r3, #4
 8012572:	b29b      	uxth	r3, r3
 8012574:	4619      	mov	r1, r3
 8012576:	683b      	ldr	r3, [r7, #0]
 8012578:	f8b3 205e 	ldrh.w	r2, [r3, #94]	; 0x5e
 801257c:	b28b      	uxth	r3, r1
 801257e:	4413      	add	r3, r2
 8012580:	b29a      	uxth	r2, r3
 8012582:	683b      	ldr	r3, [r7, #0]
 8012584:	f8a3 205e 	strh.w	r2, [r3, #94]	; 0x5e
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 8012588:	687b      	ldr	r3, [r7, #4]
 801258a:	681b      	ldr	r3, [r3, #0]
 801258c:	f06f 0202 	mvn.w	r2, #2
 8012590:	601a      	str	r2, [r3, #0]
		sConfig.Channel = PHASE_TEMP_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012592:	7ffb      	ldrb	r3, [r7, #31]
 8012594:	3b01      	subs	r3, #1
 8012596:	77fb      	strb	r3, [r7, #31]
 8012598:	7ffb      	ldrb	r3, [r7, #31]
 801259a:	2b00      	cmp	r3, #0
 801259c:	d1d8      	bne.n	8012550 <ADC_Calibration+0x178>
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
	}

	if(hadc->Instance == ADC2)
 801259e:	687b      	ldr	r3, [r7, #4]
 80125a0:	681b      	ldr	r3, [r3, #0]
 80125a2:	4a40      	ldr	r2, [pc, #256]	; (80126a4 <ADC_Calibration+0x2cc>)
 80125a4:	4293      	cmp	r3, r2
 80125a6:	f040 80d8 	bne.w	801275a <ADC_Calibration+0x382>
	{
		sConfig.Channel = PHASE_B1_CURRENT_CHANNEL;
 80125aa:	2303      	movs	r3, #3
 80125ac:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 80125ae:	2301      	movs	r3, #1
 80125b0:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 80125b2:	2302      	movs	r3, #2
 80125b4:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 80125b6:	f107 030c 	add.w	r3, r7, #12
 80125ba:	6878      	ldr	r0, [r7, #4]
 80125bc:	4619      	mov	r1, r3
 80125be:	f7f4 f893 	bl	80066e8 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 80125c2:	2310      	movs	r3, #16
 80125c4:	77fb      	strb	r3, [r7, #31]
 80125c6:	e021      	b.n	801260c <ADC_Calibration+0x234>
		{
			HAL_ADC_Start(hadc);
 80125c8:	6878      	ldr	r0, [r7, #4]
 80125ca:	f7f3 fe9b 	bl	8006304 <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 80125ce:	bf00      	nop
 80125d0:	687b      	ldr	r3, [r7, #4]
 80125d2:	681b      	ldr	r3, [r3, #0]
 80125d4:	681b      	ldr	r3, [r3, #0]
 80125d6:	f003 0302 	and.w	r3, r3, #2
 80125da:	2b00      	cmp	r3, #0
 80125dc:	d0f8      	beq.n	80125d0 <ADC_Calibration+0x1f8>
			QIEMW_ADC_Handle->PhaseB.qI1_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 80125de:	6878      	ldr	r0, [r7, #4]
 80125e0:	f7f4 f856 	bl	8006690 <HAL_ADC_GetValue>
 80125e4:	4603      	mov	r3, r0
 80125e6:	b29b      	uxth	r3, r3
 80125e8:	091b      	lsrs	r3, r3, #4
 80125ea:	b29b      	uxth	r3, r3
 80125ec:	4619      	mov	r1, r3
 80125ee:	683b      	ldr	r3, [r7, #0]
 80125f0:	8a5a      	ldrh	r2, [r3, #18]
 80125f2:	b28b      	uxth	r3, r1
 80125f4:	4413      	add	r3, r2
 80125f6:	b29a      	uxth	r2, r3
 80125f8:	683b      	ldr	r3, [r7, #0]
 80125fa:	825a      	strh	r2, [r3, #18]
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 80125fc:	687b      	ldr	r3, [r7, #4]
 80125fe:	681b      	ldr	r3, [r3, #0]
 8012600:	f06f 0202 	mvn.w	r2, #2
 8012604:	601a      	str	r2, [r3, #0]
	{
		sConfig.Channel = PHASE_B1_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012606:	7ffb      	ldrb	r3, [r7, #31]
 8012608:	3b01      	subs	r3, #1
 801260a:	77fb      	strb	r3, [r7, #31]
 801260c:	7ffb      	ldrb	r3, [r7, #31]
 801260e:	2b00      	cmp	r3, #0
 8012610:	d1da      	bne.n	80125c8 <ADC_Calibration+0x1f0>
			HAL_ADC_Start(hadc);
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
			QIEMW_ADC_Handle->PhaseB.qI1_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		HAL_ADC_Stop(hadc);
 8012612:	6878      	ldr	r0, [r7, #4]
 8012614:	f7f3 fef4 	bl	8006400 <HAL_ADC_Stop>
		
		sConfig.Channel = PHASE_B2_CURRENT_CHANNEL;
 8012618:	230c      	movs	r3, #12
 801261a:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 801261c:	2301      	movs	r3, #1
 801261e:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 8012620:	2302      	movs	r3, #2
 8012622:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 8012624:	f107 030c 	add.w	r3, r7, #12
 8012628:	6878      	ldr	r0, [r7, #4]
 801262a:	4619      	mov	r1, r3
 801262c:	f7f4 f85c 	bl	80066e8 <HAL_ADC_ConfigChannel>

		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012630:	2310      	movs	r3, #16
 8012632:	77fb      	strb	r3, [r7, #31]
 8012634:	e021      	b.n	801267a <ADC_Calibration+0x2a2>
		{
			HAL_ADC_Start(hadc);
 8012636:	6878      	ldr	r0, [r7, #4]
 8012638:	f7f3 fe64 	bl	8006304 <HAL_ADC_Start>
			
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 801263c:	bf00      	nop
 801263e:	687b      	ldr	r3, [r7, #4]
 8012640:	681b      	ldr	r3, [r3, #0]
 8012642:	681b      	ldr	r3, [r3, #0]
 8012644:	f003 0302 	and.w	r3, r3, #2
 8012648:	2b00      	cmp	r3, #0
 801264a:	d0f8      	beq.n	801263e <ADC_Calibration+0x266>
			
			QIEMW_ADC_Handle->PhaseB.qI2_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 801264c:	6878      	ldr	r0, [r7, #4]
 801264e:	f7f4 f81f 	bl	8006690 <HAL_ADC_GetValue>
 8012652:	4603      	mov	r3, r0
 8012654:	b29b      	uxth	r3, r3
 8012656:	091b      	lsrs	r3, r3, #4
 8012658:	b29b      	uxth	r3, r3
 801265a:	4619      	mov	r1, r3
 801265c:	683b      	ldr	r3, [r7, #0]
 801265e:	8ada      	ldrh	r2, [r3, #22]
 8012660:	b28b      	uxth	r3, r1
 8012662:	4413      	add	r3, r2
 8012664:	b29a      	uxth	r2, r3
 8012666:	683b      	ldr	r3, [r7, #0]
 8012668:	82da      	strh	r2, [r3, #22]
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 801266a:	687b      	ldr	r3, [r7, #4]
 801266c:	681b      	ldr	r3, [r3, #0]
 801266e:	f06f 0202 	mvn.w	r2, #2
 8012672:	601a      	str	r2, [r3, #0]
		sConfig.Channel = PHASE_B2_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);

		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012674:	7ffb      	ldrb	r3, [r7, #31]
 8012676:	3b01      	subs	r3, #1
 8012678:	77fb      	strb	r3, [r7, #31]
 801267a:	7ffb      	ldrb	r3, [r7, #31]
 801267c:	2b00      	cmp	r3, #0
 801267e:	d1da      	bne.n	8012636 <ADC_Calibration+0x25e>
			
			QIEMW_ADC_Handle->PhaseB.qI2_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_B_VOLTAGE_CHANNEL;
 8012680:	2304      	movs	r3, #4
 8012682:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 8012684:	2301      	movs	r3, #1
 8012686:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 8012688:	2302      	movs	r3, #2
 801268a:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 801268c:	f107 030c 	add.w	r3, r7, #12
 8012690:	6878      	ldr	r0, [r7, #4]
 8012692:	4619      	mov	r1, r3
 8012694:	f7f4 f828 	bl	80066e8 <HAL_ADC_ConfigChannel>

		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012698:	2310      	movs	r3, #16
 801269a:	77fb      	strb	r3, [r7, #31]
 801269c:	e026      	b.n	80126ec <ADC_Calibration+0x314>
 801269e:	bf00      	nop
 80126a0:	40012000 	.word	0x40012000
 80126a4:	40012100 	.word	0x40012100
		{
			HAL_ADC_Start(hadc);
 80126a8:	6878      	ldr	r0, [r7, #4]
 80126aa:	f7f3 fe2b 	bl	8006304 <HAL_ADC_Start>
			
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 80126ae:	bf00      	nop
 80126b0:	687b      	ldr	r3, [r7, #4]
 80126b2:	681b      	ldr	r3, [r3, #0]
 80126b4:	681b      	ldr	r3, [r3, #0]
 80126b6:	f003 0302 	and.w	r3, r3, #2
 80126ba:	2b00      	cmp	r3, #0
 80126bc:	d0f8      	beq.n	80126b0 <ADC_Calibration+0x2d8>
			
			QIEMW_ADC_Handle->PhaseB.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 80126be:	6878      	ldr	r0, [r7, #4]
 80126c0:	f7f3 ffe6 	bl	8006690 <HAL_ADC_GetValue>
 80126c4:	4603      	mov	r3, r0
 80126c6:	b29b      	uxth	r3, r3
 80126c8:	091b      	lsrs	r3, r3, #4
 80126ca:	b29b      	uxth	r3, r3
 80126cc:	4619      	mov	r1, r3
 80126ce:	683b      	ldr	r3, [r7, #0]
 80126d0:	8b5a      	ldrh	r2, [r3, #26]
 80126d2:	b28b      	uxth	r3, r1
 80126d4:	4413      	add	r3, r2
 80126d6:	b29a      	uxth	r2, r3
 80126d8:	683b      	ldr	r3, [r7, #0]
 80126da:	835a      	strh	r2, [r3, #26]
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 80126dc:	687b      	ldr	r3, [r7, #4]
 80126de:	681b      	ldr	r3, [r3, #0]
 80126e0:	f06f 0202 	mvn.w	r2, #2
 80126e4:	601a      	str	r2, [r3, #0]
		sConfig.Channel = PHASE_B_VOLTAGE_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);

		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 80126e6:	7ffb      	ldrb	r3, [r7, #31]
 80126e8:	3b01      	subs	r3, #1
 80126ea:	77fb      	strb	r3, [r7, #31]
 80126ec:	7ffb      	ldrb	r3, [r7, #31]
 80126ee:	2b00      	cmp	r3, #0
 80126f0:	d1da      	bne.n	80126a8 <ADC_Calibration+0x2d0>
			
			QIEMW_ADC_Handle->PhaseB.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_BUS_CURRENT_CHANNEL;
 80126f2:	230a      	movs	r3, #10
 80126f4:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 80126f6:	2301      	movs	r3, #1
 80126f8:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 80126fa:	2302      	movs	r3, #2
 80126fc:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 80126fe:	f107 030c 	add.w	r3, r7, #12
 8012702:	6878      	ldr	r0, [r7, #4]
 8012704:	4619      	mov	r1, r3
 8012706:	f7f3 ffef 	bl	80066e8 <HAL_ADC_ConfigChannel>

		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 801270a:	2310      	movs	r3, #16
 801270c:	77fb      	strb	r3, [r7, #31]
 801270e:	e021      	b.n	8012754 <ADC_Calibration+0x37c>
		{
			HAL_ADC_Start(hadc);
 8012710:	6878      	ldr	r0, [r7, #4]
 8012712:	f7f3 fdf7 	bl	8006304 <HAL_ADC_Start>
			
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 8012716:	bf00      	nop
 8012718:	687b      	ldr	r3, [r7, #4]
 801271a:	681b      	ldr	r3, [r3, #0]
 801271c:	681b      	ldr	r3, [r3, #0]
 801271e:	f003 0302 	and.w	r3, r3, #2
 8012722:	2b00      	cmp	r3, #0
 8012724:	d0f8      	beq.n	8012718 <ADC_Calibration+0x340>
			QIEMW_ADC_Handle->BUS.qI_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 8012726:	6878      	ldr	r0, [r7, #4]
 8012728:	f7f3 ffb2 	bl	8006690 <HAL_ADC_GetValue>
 801272c:	4603      	mov	r3, r0
 801272e:	b29b      	uxth	r3, r3
 8012730:	091b      	lsrs	r3, r3, #4
 8012732:	b29b      	uxth	r3, r3
 8012734:	4619      	mov	r1, r3
 8012736:	683b      	ldr	r3, [r7, #0]
 8012738:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 801273a:	b28b      	uxth	r3, r1
 801273c:	4413      	add	r3, r2
 801273e:	b29a      	uxth	r2, r3
 8012740:	683b      	ldr	r3, [r7, #0]
 8012742:	859a      	strh	r2, [r3, #44]	; 0x2c
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 8012744:	687b      	ldr	r3, [r7, #4]
 8012746:	681b      	ldr	r3, [r3, #0]
 8012748:	f06f 0202 	mvn.w	r2, #2
 801274c:	601a      	str	r2, [r3, #0]
		sConfig.Channel = PHASE_BUS_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);

		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 801274e:	7ffb      	ldrb	r3, [r7, #31]
 8012750:	3b01      	subs	r3, #1
 8012752:	77fb      	strb	r3, [r7, #31]
 8012754:	7ffb      	ldrb	r3, [r7, #31]
 8012756:	2b00      	cmp	r3, #0
 8012758:	d1da      	bne.n	8012710 <ADC_Calibration+0x338>
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
	}

	if(hadc->Instance == ADC3)
 801275a:	687b      	ldr	r3, [r7, #4]
 801275c:	681b      	ldr	r3, [r3, #0]
 801275e:	4a6b      	ldr	r2, [pc, #428]	; (801290c <ADC_Calibration+0x534>)
 8012760:	4293      	cmp	r3, r2
 8012762:	f040 80d0 	bne.w	8012906 <ADC_Calibration+0x52e>
	{
		sConfig.Channel = PHASE_A1_CURRENT_CHANNEL;
 8012766:	2305      	movs	r3, #5
 8012768:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 801276a:	2301      	movs	r3, #1
 801276c:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 801276e:	2302      	movs	r3, #2
 8012770:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 8012772:	f107 030c 	add.w	r3, r7, #12
 8012776:	6878      	ldr	r0, [r7, #4]
 8012778:	4619      	mov	r1, r3
 801277a:	f7f3 ffb5 	bl	80066e8 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 801277e:	2310      	movs	r3, #16
 8012780:	77fb      	strb	r3, [r7, #31]
 8012782:	e021      	b.n	80127c8 <ADC_Calibration+0x3f0>
		{
			HAL_ADC_Start(hadc);
 8012784:	6878      	ldr	r0, [r7, #4]
 8012786:	f7f3 fdbd 	bl	8006304 <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 801278a:	bf00      	nop
 801278c:	687b      	ldr	r3, [r7, #4]
 801278e:	681b      	ldr	r3, [r3, #0]
 8012790:	681b      	ldr	r3, [r3, #0]
 8012792:	f003 0302 	and.w	r3, r3, #2
 8012796:	2b00      	cmp	r3, #0
 8012798:	d0f8      	beq.n	801278c <ADC_Calibration+0x3b4>
			QIEMW_ADC_Handle->PhaseA.qI1_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 801279a:	6878      	ldr	r0, [r7, #4]
 801279c:	f7f3 ff78 	bl	8006690 <HAL_ADC_GetValue>
 80127a0:	4603      	mov	r3, r0
 80127a2:	b29b      	uxth	r3, r3
 80127a4:	091b      	lsrs	r3, r3, #4
 80127a6:	b29b      	uxth	r3, r3
 80127a8:	4619      	mov	r1, r3
 80127aa:	683b      	ldr	r3, [r7, #0]
 80127ac:	889a      	ldrh	r2, [r3, #4]
 80127ae:	b28b      	uxth	r3, r1
 80127b0:	4413      	add	r3, r2
 80127b2:	b29a      	uxth	r2, r3
 80127b4:	683b      	ldr	r3, [r7, #0]
 80127b6:	809a      	strh	r2, [r3, #4]
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 80127b8:	687b      	ldr	r3, [r7, #4]
 80127ba:	681b      	ldr	r3, [r3, #0]
 80127bc:	f06f 0202 	mvn.w	r2, #2
 80127c0:	601a      	str	r2, [r3, #0]
	{
		sConfig.Channel = PHASE_A1_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 80127c2:	7ffb      	ldrb	r3, [r7, #31]
 80127c4:	3b01      	subs	r3, #1
 80127c6:	77fb      	strb	r3, [r7, #31]
 80127c8:	7ffb      	ldrb	r3, [r7, #31]
 80127ca:	2b00      	cmp	r3, #0
 80127cc:	d1da      	bne.n	8012784 <ADC_Calibration+0x3ac>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
			QIEMW_ADC_Handle->PhaseA.qI1_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_A2_CURRENT_CHANNEL;
 80127ce:	2306      	movs	r3, #6
 80127d0:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 80127d2:	2301      	movs	r3, #1
 80127d4:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 80127d6:	2302      	movs	r3, #2
 80127d8:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 80127da:	f107 030c 	add.w	r3, r7, #12
 80127de:	6878      	ldr	r0, [r7, #4]
 80127e0:	4619      	mov	r1, r3
 80127e2:	f7f3 ff81 	bl	80066e8 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 80127e6:	2310      	movs	r3, #16
 80127e8:	77fb      	strb	r3, [r7, #31]
 80127ea:	e021      	b.n	8012830 <ADC_Calibration+0x458>
		{
			HAL_ADC_Start(hadc);
 80127ec:	6878      	ldr	r0, [r7, #4]
 80127ee:	f7f3 fd89 	bl	8006304 <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 80127f2:	bf00      	nop
 80127f4:	687b      	ldr	r3, [r7, #4]
 80127f6:	681b      	ldr	r3, [r3, #0]
 80127f8:	681b      	ldr	r3, [r3, #0]
 80127fa:	f003 0302 	and.w	r3, r3, #2
 80127fe:	2b00      	cmp	r3, #0
 8012800:	d0f8      	beq.n	80127f4 <ADC_Calibration+0x41c>
			QIEMW_ADC_Handle->PhaseA.qI2_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 8012802:	6878      	ldr	r0, [r7, #4]
 8012804:	f7f3 ff44 	bl	8006690 <HAL_ADC_GetValue>
 8012808:	4603      	mov	r3, r0
 801280a:	b29b      	uxth	r3, r3
 801280c:	091b      	lsrs	r3, r3, #4
 801280e:	b29b      	uxth	r3, r3
 8012810:	4619      	mov	r1, r3
 8012812:	683b      	ldr	r3, [r7, #0]
 8012814:	891a      	ldrh	r2, [r3, #8]
 8012816:	b28b      	uxth	r3, r1
 8012818:	4413      	add	r3, r2
 801281a:	b29a      	uxth	r2, r3
 801281c:	683b      	ldr	r3, [r7, #0]
 801281e:	811a      	strh	r2, [r3, #8]
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 8012820:	687b      	ldr	r3, [r7, #4]
 8012822:	681b      	ldr	r3, [r3, #0]
 8012824:	f06f 0202 	mvn.w	r2, #2
 8012828:	601a      	str	r2, [r3, #0]
		}
		sConfig.Channel = PHASE_A2_CURRENT_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 801282a:	7ffb      	ldrb	r3, [r7, #31]
 801282c:	3b01      	subs	r3, #1
 801282e:	77fb      	strb	r3, [r7, #31]
 8012830:	7ffb      	ldrb	r3, [r7, #31]
 8012832:	2b00      	cmp	r3, #0
 8012834:	d1da      	bne.n	80127ec <ADC_Calibration+0x414>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
			QIEMW_ADC_Handle->PhaseA.qI2_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_A_VOLTAGE_CHANNEL;
 8012836:	2307      	movs	r3, #7
 8012838:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 801283a:	2301      	movs	r3, #1
 801283c:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 801283e:	2302      	movs	r3, #2
 8012840:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 8012842:	f107 030c 	add.w	r3, r7, #12
 8012846:	6878      	ldr	r0, [r7, #4]
 8012848:	4619      	mov	r1, r3
 801284a:	f7f3 ff4d 	bl	80066e8 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 801284e:	2310      	movs	r3, #16
 8012850:	77fb      	strb	r3, [r7, #31]
 8012852:	e021      	b.n	8012898 <ADC_Calibration+0x4c0>
		{
			HAL_ADC_Start(hadc);
 8012854:	6878      	ldr	r0, [r7, #4]
 8012856:	f7f3 fd55 	bl	8006304 <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 801285a:	bf00      	nop
 801285c:	687b      	ldr	r3, [r7, #4]
 801285e:	681b      	ldr	r3, [r3, #0]
 8012860:	681b      	ldr	r3, [r3, #0]
 8012862:	f003 0302 	and.w	r3, r3, #2
 8012866:	2b00      	cmp	r3, #0
 8012868:	d0f8      	beq.n	801285c <ADC_Calibration+0x484>
			QIEMW_ADC_Handle->PhaseA.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 801286a:	6878      	ldr	r0, [r7, #4]
 801286c:	f7f3 ff10 	bl	8006690 <HAL_ADC_GetValue>
 8012870:	4603      	mov	r3, r0
 8012872:	b29b      	uxth	r3, r3
 8012874:	091b      	lsrs	r3, r3, #4
 8012876:	b29b      	uxth	r3, r3
 8012878:	4619      	mov	r1, r3
 801287a:	683b      	ldr	r3, [r7, #0]
 801287c:	899a      	ldrh	r2, [r3, #12]
 801287e:	b28b      	uxth	r3, r1
 8012880:	4413      	add	r3, r2
 8012882:	b29a      	uxth	r2, r3
 8012884:	683b      	ldr	r3, [r7, #0]
 8012886:	819a      	strh	r2, [r3, #12]
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 8012888:	687b      	ldr	r3, [r7, #4]
 801288a:	681b      	ldr	r3, [r3, #0]
 801288c:	f06f 0202 	mvn.w	r2, #2
 8012890:	601a      	str	r2, [r3, #0]
		}
		sConfig.Channel = PHASE_A_VOLTAGE_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 8012892:	7ffb      	ldrb	r3, [r7, #31]
 8012894:	3b01      	subs	r3, #1
 8012896:	77fb      	strb	r3, [r7, #31]
 8012898:	7ffb      	ldrb	r3, [r7, #31]
 801289a:	2b00      	cmp	r3, #0
 801289c:	d1da      	bne.n	8012854 <ADC_Calibration+0x47c>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
			QIEMW_ADC_Handle->PhaseA.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
		sConfig.Channel = PHASE_BUS_VOLTAGE_CHANNEL;
 801289e:	2304      	movs	r3, #4
 80128a0:	60fb      	str	r3, [r7, #12]
		sConfig.Rank = 1;
 80128a2:	2301      	movs	r3, #1
 80128a4:	613b      	str	r3, [r7, #16]
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
 80128a6:	2302      	movs	r3, #2
 80128a8:	617b      	str	r3, [r7, #20]
		HAL_ADC_ConfigChannel(hadc, &sConfig);
 80128aa:	f107 030c 	add.w	r3, r7, #12
 80128ae:	6878      	ldr	r0, [r7, #4]
 80128b0:	4619      	mov	r1, r3
 80128b2:	f7f3 ff19 	bl	80066e8 <HAL_ADC_ConfigChannel>
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 80128b6:	2310      	movs	r3, #16
 80128b8:	77fb      	strb	r3, [r7, #31]
 80128ba:	e021      	b.n	8012900 <ADC_Calibration+0x528>
		{
			HAL_ADC_Start(hadc);
 80128bc:	6878      	ldr	r0, [r7, #4]
 80128be:	f7f3 fd21 	bl	8006304 <HAL_ADC_Start>
			while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))) { }
 80128c2:	bf00      	nop
 80128c4:	687b      	ldr	r3, [r7, #4]
 80128c6:	681b      	ldr	r3, [r3, #0]
 80128c8:	681b      	ldr	r3, [r3, #0]
 80128ca:	f003 0302 	and.w	r3, r3, #2
 80128ce:	2b00      	cmp	r3, #0
 80128d0:	d0f8      	beq.n	80128c4 <ADC_Calibration+0x4ec>
			QIEMW_ADC_Handle->BUS.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
 80128d2:	6878      	ldr	r0, [r7, #4]
 80128d4:	f7f3 fedc 	bl	8006690 <HAL_ADC_GetValue>
 80128d8:	4603      	mov	r3, r0
 80128da:	b29b      	uxth	r3, r3
 80128dc:	091b      	lsrs	r3, r3, #4
 80128de:	b29b      	uxth	r3, r3
 80128e0:	4619      	mov	r1, r3
 80128e2:	683b      	ldr	r3, [r7, #0]
 80128e4:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
 80128e6:	b28b      	uxth	r3, r1
 80128e8:	4413      	add	r3, r2
 80128ea:	b29a      	uxth	r2, r3
 80128ec:	683b      	ldr	r3, [r7, #0]
 80128ee:	861a      	strh	r2, [r3, #48]	; 0x30
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 80128f0:	687b      	ldr	r3, [r7, #4]
 80128f2:	681b      	ldr	r3, [r3, #0]
 80128f4:	f06f 0202 	mvn.w	r2, #2
 80128f8:	601a      	str	r2, [r3, #0]
		}
		sConfig.Channel = PHASE_BUS_VOLTAGE_CHANNEL;
		sConfig.Rank = 1;
		sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
		HAL_ADC_ConfigChannel(hadc, &sConfig);
		for(bIndex=NB_CONVERSIONS; bIndex != 0; bIndex--)
 80128fa:	7ffb      	ldrb	r3, [r7, #31]
 80128fc:	3b01      	subs	r3, #1
 80128fe:	77fb      	strb	r3, [r7, #31]
 8012900:	7ffb      	ldrb	r3, [r7, #31]
 8012902:	2b00      	cmp	r3, #0
 8012904:	d1da      	bne.n	80128bc <ADC_Calibration+0x4e4>
			QIEMW_ADC_Handle->BUS.qV_offset += ((u16)HAL_ADC_GetValue(hadc)>>ADC_RIGHT_ALIGNMENT);
			
			__HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
		}
	}
}
 8012906:	3720      	adds	r7, #32
 8012908:	46bd      	mov	sp, r7
 801290a:	bd80      	pop	{r7, pc}
 801290c:	40012200 	.word	0x40012200

08012910 <HAL_ADCEx_InjectedConvCpltCallback>:



void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef* hadc)
{
 8012910:	b580      	push	{r7, lr}
 8012912:	b082      	sub	sp, #8
 8012914:	af00      	add	r7, sp, #0
 8012916:	6078      	str	r0, [r7, #4]
	hadc->Instance = ADC1;
 8012918:	687b      	ldr	r3, [r7, #4]
 801291a:	4a8f      	ldr	r2, [pc, #572]	; (8012b58 <HAL_ADCEx_InjectedConvCpltCallback+0x248>)
 801291c:	601a      	str	r2, [r3, #0]
	Global_User_ADC.PhaseC.qI1_value = (s16)(HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_1));
 801291e:	6878      	ldr	r0, [r7, #4]
 8012920:	2101      	movs	r1, #1
 8012922:	f7f4 f9eb 	bl	8006cfc <HAL_ADCEx_InjectedGetValue>
 8012926:	4603      	mov	r3, r0
 8012928:	b29a      	uxth	r2, r3
 801292a:	4b8c      	ldr	r3, [pc, #560]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 801292c:	839a      	strh	r2, [r3, #28]
	Global_User_ADC.PhaseC.qI2_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_2);
 801292e:	6878      	ldr	r0, [r7, #4]
 8012930:	2102      	movs	r1, #2
 8012932:	f7f4 f9e3 	bl	8006cfc <HAL_ADCEx_InjectedGetValue>
 8012936:	4603      	mov	r3, r0
 8012938:	b29a      	uxth	r2, r3
 801293a:	4b88      	ldr	r3, [pc, #544]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 801293c:	845a      	strh	r2, [r3, #34]	; 0x22
	Global_User_ADC.PhaseC.qV_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_3);
 801293e:	6878      	ldr	r0, [r7, #4]
 8012940:	2103      	movs	r1, #3
 8012942:	f7f4 f9db 	bl	8006cfc <HAL_ADCEx_InjectedGetValue>
 8012946:	4603      	mov	r3, r0
 8012948:	b29a      	uxth	r2, r3
 801294a:	4b84      	ldr	r3, [pc, #528]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 801294c:	84da      	strh	r2, [r3, #38]	; 0x26
	Global_User_ADC.Temp.TEMP_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_4);
 801294e:	6878      	ldr	r0, [r7, #4]
 8012950:	2104      	movs	r1, #4
 8012952:	f7f4 f9d3 	bl	8006cfc <HAL_ADCEx_InjectedGetValue>
 8012956:	4603      	mov	r3, r0
 8012958:	b29a      	uxth	r2, r3
 801295a:	4b80      	ldr	r3, [pc, #512]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 801295c:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
	hadc->Instance = ADC2;
 8012960:	687b      	ldr	r3, [r7, #4]
 8012962:	4a7f      	ldr	r2, [pc, #508]	; (8012b60 <HAL_ADCEx_InjectedConvCpltCallback+0x250>)
 8012964:	601a      	str	r2, [r3, #0]
	Global_User_ADC.PhaseB.qI1_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_1);
 8012966:	6878      	ldr	r0, [r7, #4]
 8012968:	2101      	movs	r1, #1
 801296a:	f7f4 f9c7 	bl	8006cfc <HAL_ADCEx_InjectedGetValue>
 801296e:	4603      	mov	r3, r0
 8012970:	b29a      	uxth	r2, r3
 8012972:	4b7a      	ldr	r3, [pc, #488]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8012974:	81da      	strh	r2, [r3, #14]
	Global_User_ADC.PhaseB.qI2_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_2);
 8012976:	6878      	ldr	r0, [r7, #4]
 8012978:	2102      	movs	r1, #2
 801297a:	f7f4 f9bf 	bl	8006cfc <HAL_ADCEx_InjectedGetValue>
 801297e:	4603      	mov	r3, r0
 8012980:	b29a      	uxth	r2, r3
 8012982:	4b76      	ldr	r3, [pc, #472]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8012984:	829a      	strh	r2, [r3, #20]
	Global_User_ADC.PhaseB.qV_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_3);
 8012986:	6878      	ldr	r0, [r7, #4]
 8012988:	2103      	movs	r1, #3
 801298a:	f7f4 f9b7 	bl	8006cfc <HAL_ADCEx_InjectedGetValue>
 801298e:	4603      	mov	r3, r0
 8012990:	b29a      	uxth	r2, r3
 8012992:	4b72      	ldr	r3, [pc, #456]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8012994:	831a      	strh	r2, [r3, #24]
	Global_User_ADC.BUS.qI_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_4);
 8012996:	6878      	ldr	r0, [r7, #4]
 8012998:	2104      	movs	r1, #4
 801299a:	f7f4 f9af 	bl	8006cfc <HAL_ADCEx_InjectedGetValue>
 801299e:	4603      	mov	r3, r0
 80129a0:	b29a      	uxth	r2, r3
 80129a2:	4b6e      	ldr	r3, [pc, #440]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 80129a4:	855a      	strh	r2, [r3, #42]	; 0x2a
	hadc->Instance = ADC3;
 80129a6:	687b      	ldr	r3, [r7, #4]
 80129a8:	4a6e      	ldr	r2, [pc, #440]	; (8012b64 <HAL_ADCEx_InjectedConvCpltCallback+0x254>)
 80129aa:	601a      	str	r2, [r3, #0]
	Global_User_ADC.PhaseA.qI1_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_1);
 80129ac:	6878      	ldr	r0, [r7, #4]
 80129ae:	2101      	movs	r1, #1
 80129b0:	f7f4 f9a4 	bl	8006cfc <HAL_ADCEx_InjectedGetValue>
 80129b4:	4603      	mov	r3, r0
 80129b6:	b29a      	uxth	r2, r3
 80129b8:	4b68      	ldr	r3, [pc, #416]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 80129ba:	801a      	strh	r2, [r3, #0]
	Global_User_ADC.PhaseA.qI2_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_2);
 80129bc:	6878      	ldr	r0, [r7, #4]
 80129be:	2102      	movs	r1, #2
 80129c0:	f7f4 f99c 	bl	8006cfc <HAL_ADCEx_InjectedGetValue>
 80129c4:	4603      	mov	r3, r0
 80129c6:	b29a      	uxth	r2, r3
 80129c8:	4b64      	ldr	r3, [pc, #400]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 80129ca:	80da      	strh	r2, [r3, #6]
	Global_User_ADC.PhaseA.qV_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_3);
 80129cc:	6878      	ldr	r0, [r7, #4]
 80129ce:	2103      	movs	r1, #3
 80129d0:	f7f4 f994 	bl	8006cfc <HAL_ADCEx_InjectedGetValue>
 80129d4:	4603      	mov	r3, r0
 80129d6:	b29a      	uxth	r2, r3
 80129d8:	4b60      	ldr	r3, [pc, #384]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 80129da:	815a      	strh	r2, [r3, #10]
	Global_User_ADC.BUS.qV_value = (s16)HAL_ADCEx_InjectedGetValue(hadc, ADC_INJECTED_RANK_4);
 80129dc:	6878      	ldr	r0, [r7, #4]
 80129de:	2104      	movs	r1, #4
 80129e0:	f7f4 f98c 	bl	8006cfc <HAL_ADCEx_InjectedGetValue>
 80129e4:	4603      	mov	r3, r0
 80129e6:	b29a      	uxth	r2, r3
 80129e8:	4b5c      	ldr	r3, [pc, #368]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 80129ea:	85da      	strh	r2, [r3, #46]	; 0x2e

	Global_User_ADC.PhaseC.qI_value = (s16)(((s32)Global_User_ADC.PhaseC.qI1_value + (s32)Global_User_ADC.PhaseC.qI2_value) >> 1);
 80129ec:	4b5b      	ldr	r3, [pc, #364]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 80129ee:	8b9b      	ldrh	r3, [r3, #28]
 80129f0:	b21a      	sxth	r2, r3
 80129f2:	4b5a      	ldr	r3, [pc, #360]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 80129f4:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 80129f6:	b21b      	sxth	r3, r3
 80129f8:	4413      	add	r3, r2
 80129fa:	105b      	asrs	r3, r3, #1
 80129fc:	b29a      	uxth	r2, r3
 80129fe:	4b57      	ldr	r3, [pc, #348]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8012a00:	83da      	strh	r2, [r3, #30]
	Global_User_ADC.PhaseB.qI_value = (s16)(((s32)Global_User_ADC.PhaseB.qI1_value + (s32)Global_User_ADC.PhaseB.qI2_value) >> 1);
 8012a02:	4b56      	ldr	r3, [pc, #344]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8012a04:	89db      	ldrh	r3, [r3, #14]
 8012a06:	b21a      	sxth	r2, r3
 8012a08:	4b54      	ldr	r3, [pc, #336]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8012a0a:	8a9b      	ldrh	r3, [r3, #20]
 8012a0c:	b21b      	sxth	r3, r3
 8012a0e:	4413      	add	r3, r2
 8012a10:	105b      	asrs	r3, r3, #1
 8012a12:	b29a      	uxth	r2, r3
 8012a14:	4b51      	ldr	r3, [pc, #324]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8012a16:	821a      	strh	r2, [r3, #16]
	Global_User_ADC.PhaseA.qI_value = (s16)(((s32)Global_User_ADC.PhaseA.qI1_value + (s32)Global_User_ADC.PhaseA.qI2_value) >> 1);
 8012a18:	4b50      	ldr	r3, [pc, #320]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8012a1a:	881b      	ldrh	r3, [r3, #0]
 8012a1c:	b21a      	sxth	r2, r3
 8012a1e:	4b4f      	ldr	r3, [pc, #316]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8012a20:	88db      	ldrh	r3, [r3, #6]
 8012a22:	b21b      	sxth	r3, r3
 8012a24:	4413      	add	r3, r2
 8012a26:	105b      	asrs	r3, r3, #1
 8012a28:	b29a      	uxth	r2, r3
 8012a2a:	4b4c      	ldr	r3, [pc, #304]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8012a2c:	805a      	strh	r2, [r3, #2]
	
	//! \Add By Dl.K
	static HAL_AdcData_t sHal_AdcData;
	static HAL_PwmData_t sHal_PwmData;
	static HAL_QepData_t sHal_QepData;
	sHal_AdcData.I.value[0] = Global_User_ADC.PhaseA.qI_value;
 8012a2e:	4b4b      	ldr	r3, [pc, #300]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8012a30:	885b      	ldrh	r3, [r3, #2]
 8012a32:	b21b      	sxth	r3, r3
 8012a34:	ee07 3a90 	vmov	s15, r3
 8012a38:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8012a3c:	4b4a      	ldr	r3, [pc, #296]	; (8012b68 <HAL_ADCEx_InjectedConvCpltCallback+0x258>)
 8012a3e:	edc3 7a00 	vstr	s15, [r3]
	sHal_AdcData.I.value[1] = Global_User_ADC.PhaseB.qI_value;
 8012a42:	4b46      	ldr	r3, [pc, #280]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8012a44:	8a1b      	ldrh	r3, [r3, #16]
 8012a46:	b21b      	sxth	r3, r3
 8012a48:	ee07 3a90 	vmov	s15, r3
 8012a4c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8012a50:	4b45      	ldr	r3, [pc, #276]	; (8012b68 <HAL_ADCEx_InjectedConvCpltCallback+0x258>)
 8012a52:	edc3 7a01 	vstr	s15, [r3, #4]
	sHal_AdcData.I.value[2] = Global_User_ADC.PhaseC.qI_value;
 8012a56:	4b41      	ldr	r3, [pc, #260]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8012a58:	8bdb      	ldrh	r3, [r3, #30]
 8012a5a:	b21b      	sxth	r3, r3
 8012a5c:	ee07 3a90 	vmov	s15, r3
 8012a60:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8012a64:	4b40      	ldr	r3, [pc, #256]	; (8012b68 <HAL_ADCEx_InjectedConvCpltCallback+0x258>)
 8012a66:	edc3 7a02 	vstr	s15, [r3, #8]
	sHal_AdcData.IdcBus = Global_User_ADC.BUS.qI_value;
 8012a6a:	4b3c      	ldr	r3, [pc, #240]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8012a6c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8012a6e:	b21b      	sxth	r3, r3
 8012a70:	ee07 3a90 	vmov	s15, r3
 8012a74:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8012a78:	4b3b      	ldr	r3, [pc, #236]	; (8012b68 <HAL_ADCEx_InjectedConvCpltCallback+0x258>)
 8012a7a:	edc3 7a07 	vstr	s15, [r3, #28]
	sHal_AdcData.V.value[0] = Global_User_ADC.PhaseA.qV_value;
 8012a7e:	4b37      	ldr	r3, [pc, #220]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8012a80:	895b      	ldrh	r3, [r3, #10]
 8012a82:	b21b      	sxth	r3, r3
 8012a84:	ee07 3a90 	vmov	s15, r3
 8012a88:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8012a8c:	4b36      	ldr	r3, [pc, #216]	; (8012b68 <HAL_ADCEx_InjectedConvCpltCallback+0x258>)
 8012a8e:	edc3 7a03 	vstr	s15, [r3, #12]
	sHal_AdcData.V.value[1] = Global_User_ADC.PhaseB.qV_value;
 8012a92:	4b32      	ldr	r3, [pc, #200]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8012a94:	8b1b      	ldrh	r3, [r3, #24]
 8012a96:	b21b      	sxth	r3, r3
 8012a98:	ee07 3a90 	vmov	s15, r3
 8012a9c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8012aa0:	4b31      	ldr	r3, [pc, #196]	; (8012b68 <HAL_ADCEx_InjectedConvCpltCallback+0x258>)
 8012aa2:	edc3 7a04 	vstr	s15, [r3, #16]
	sHal_AdcData.V.value[2] = Global_User_ADC.PhaseC.qV_value;
 8012aa6:	4b2d      	ldr	r3, [pc, #180]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8012aa8:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 8012aaa:	b21b      	sxth	r3, r3
 8012aac:	ee07 3a90 	vmov	s15, r3
 8012ab0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8012ab4:	4b2c      	ldr	r3, [pc, #176]	; (8012b68 <HAL_ADCEx_InjectedConvCpltCallback+0x258>)
 8012ab6:	edc3 7a05 	vstr	s15, [r3, #20]
	sHal_AdcData.VdcBus = Global_User_ADC.BUS.qV_value;
 8012aba:	4b28      	ldr	r3, [pc, #160]	; (8012b5c <HAL_ADCEx_InjectedConvCpltCallback+0x24c>)
 8012abc:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 8012abe:	b21b      	sxth	r3, r3
 8012ac0:	ee07 3a90 	vmov	s15, r3
 8012ac4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8012ac8:	4b27      	ldr	r3, [pc, #156]	; (8012b68 <HAL_ADCEx_InjectedConvCpltCallback+0x258>)
 8012aca:	edc3 7a06 	vstr	s15, [r3, #24]
	sHal_QepData.qep_cnt = (float_t)(4*4*ENCODER_PPR-1-GetCounterValue(TIM5))/(4.0f*ENCODER_PPR*4.0f);
 8012ace:	4827      	ldr	r0, [pc, #156]	; (8012b6c <HAL_ADCEx_InjectedConvCpltCallback+0x25c>)
 8012ad0:	f000 fb7e 	bl	80131d0 <GetCounterValue>
 8012ad4:	4603      	mov	r3, r0
 8012ad6:	461a      	mov	r2, r3
 8012ad8:	f643 73ff 	movw	r3, #16383	; 0x3fff
 8012adc:	1a9b      	subs	r3, r3, r2
 8012ade:	ee07 3a90 	vmov	s15, r3
 8012ae2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8012ae6:	ed9f 7a22 	vldr	s14, [pc, #136]	; 8012b70 <HAL_ADCEx_InjectedConvCpltCallback+0x260>
 8012aea:	eec7 7a87 	vdiv.f32	s15, s15, s14
 8012aee:	4b21      	ldr	r3, [pc, #132]	; (8012b74 <HAL_ADCEx_InjectedConvCpltCallback+0x264>)
 8012af0:	edc3 7a00 	vstr	s15, [r3]
	Motor_Ctrl_Run(&sHal_AdcData, &sHal_PwmData, &sHal_QepData);
 8012af4:	481c      	ldr	r0, [pc, #112]	; (8012b68 <HAL_ADCEx_InjectedConvCpltCallback+0x258>)
 8012af6:	4920      	ldr	r1, [pc, #128]	; (8012b78 <HAL_ADCEx_InjectedConvCpltCallback+0x268>)
 8012af8:	4a1e      	ldr	r2, [pc, #120]	; (8012b74 <HAL_ADCEx_InjectedConvCpltCallback+0x264>)
 8012afa:	f7ef fab5 	bl	8002068 <Motor_Ctrl_Run>
	SetDutyCycles(TIM8, sHal_PwmData.Tabc.value[0]*(float)PWM_PERIOD, 
 8012afe:	4b1e      	ldr	r3, [pc, #120]	; (8012b78 <HAL_ADCEx_InjectedConvCpltCallback+0x268>)
 8012b00:	edd3 7a00 	vldr	s15, [r3]
 8012b04:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 8012b7c <HAL_ADCEx_InjectedConvCpltCallback+0x26c>
 8012b08:	ee67 7a87 	vmul.f32	s15, s15, s14
 8012b0c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8012b10:	edc7 7a00 	vstr	s15, [r7]
 8012b14:	883b      	ldrh	r3, [r7, #0]
 8012b16:	b299      	uxth	r1, r3
											sHal_PwmData.Tabc.value[1]*(float)PWM_PERIOD, 
 8012b18:	4b17      	ldr	r3, [pc, #92]	; (8012b78 <HAL_ADCEx_InjectedConvCpltCallback+0x268>)
 8012b1a:	edd3 7a01 	vldr	s15, [r3, #4]
 8012b1e:	ed9f 7a17 	vldr	s14, [pc, #92]	; 8012b7c <HAL_ADCEx_InjectedConvCpltCallback+0x26c>
 8012b22:	ee67 7a87 	vmul.f32	s15, s15, s14
	sHal_AdcData.V.value[1] = Global_User_ADC.PhaseB.qV_value;
	sHal_AdcData.V.value[2] = Global_User_ADC.PhaseC.qV_value;
	sHal_AdcData.VdcBus = Global_User_ADC.BUS.qV_value;
	sHal_QepData.qep_cnt = (float_t)(4*4*ENCODER_PPR-1-GetCounterValue(TIM5))/(4.0f*ENCODER_PPR*4.0f);
	Motor_Ctrl_Run(&sHal_AdcData, &sHal_PwmData, &sHal_QepData);
	SetDutyCycles(TIM8, sHal_PwmData.Tabc.value[0]*(float)PWM_PERIOD, 
 8012b26:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8012b2a:	edc7 7a00 	vstr	s15, [r7]
 8012b2e:	883b      	ldrh	r3, [r7, #0]
 8012b30:	b29a      	uxth	r2, r3
											sHal_PwmData.Tabc.value[1]*(float)PWM_PERIOD, 
											sHal_PwmData.Tabc.value[2]*(float)PWM_PERIOD);
 8012b32:	4b11      	ldr	r3, [pc, #68]	; (8012b78 <HAL_ADCEx_InjectedConvCpltCallback+0x268>)
 8012b34:	edd3 7a02 	vldr	s15, [r3, #8]
 8012b38:	ed9f 7a10 	vldr	s14, [pc, #64]	; 8012b7c <HAL_ADCEx_InjectedConvCpltCallback+0x26c>
 8012b3c:	ee67 7a87 	vmul.f32	s15, s15, s14
	sHal_AdcData.V.value[1] = Global_User_ADC.PhaseB.qV_value;
	sHal_AdcData.V.value[2] = Global_User_ADC.PhaseC.qV_value;
	sHal_AdcData.VdcBus = Global_User_ADC.BUS.qV_value;
	sHal_QepData.qep_cnt = (float_t)(4*4*ENCODER_PPR-1-GetCounterValue(TIM5))/(4.0f*ENCODER_PPR*4.0f);
	Motor_Ctrl_Run(&sHal_AdcData, &sHal_PwmData, &sHal_QepData);
	SetDutyCycles(TIM8, sHal_PwmData.Tabc.value[0]*(float)PWM_PERIOD, 
 8012b40:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8012b44:	edc7 7a00 	vstr	s15, [r7]
 8012b48:	883b      	ldrh	r3, [r7, #0]
 8012b4a:	b29b      	uxth	r3, r3
 8012b4c:	480c      	ldr	r0, [pc, #48]	; (8012b80 <HAL_ADCEx_InjectedConvCpltCallback+0x270>)
 8012b4e:	f000 fec1 	bl	80138d4 <SetDutyCycles>
	{
		i = 0;
		myprintf("123456789012\r\n", 15);
	}
	#endif
}
 8012b52:	3708      	adds	r7, #8
 8012b54:	46bd      	mov	sp, r7
 8012b56:	bd80      	pop	{r7, pc}
 8012b58:	40012000 	.word	0x40012000
 8012b5c:	200128e4 	.word	0x200128e4
 8012b60:	40012100 	.word	0x40012100
 8012b64:	40012200 	.word	0x40012200
 8012b68:	20010838 	.word	0x20010838
 8012b6c:	40000c00 	.word	0x40000c00
 8012b70:	46800000 	.word	0x46800000
 8012b74:	20010858 	.word	0x20010858
 8012b78:	2001085c 	.word	0x2001085c
 8012b7c:	46160000 	.word	0x46160000
 8012b80:	40010400 	.word	0x40010400

08012b84 <ADC_IRQHandler>:
{
	HAL_GPIO_WritePin(GPIOI,GPIO_PIN_3, GPIO_PIN_RESET);
}
*/
void ADC_IRQHandler(void)
{
 8012b84:	b580      	push	{r7, lr}
 8012b86:	b092      	sub	sp, #72	; 0x48
 8012b88:	af00      	add	r7, sp, #0
	ADC_HandleTypeDef ADC_handle;

    /* enter interrupt */
    rt_interrupt_enter();
 8012b8a:	f003 fcb1 	bl	80164f0 <rt_interrupt_enter>
	
	HAL_GPIO_WritePin(GPIOI,GPIO_PIN_3, GPIO_PIN_SET); /* idle 30usmax; online 40us max 20160822*/
 8012b8e:	480a      	ldr	r0, [pc, #40]	; (8012bb8 <ADC_IRQHandler+0x34>)
 8012b90:	2108      	movs	r1, #8
 8012b92:	2201      	movs	r2, #1
 8012b94:	f7fa fb06 	bl	800d1a4 <HAL_GPIO_WritePin>
	
	ADC_handle.Instance = ADC1;
 8012b98:	4b08      	ldr	r3, [pc, #32]	; (8012bbc <ADC_IRQHandler+0x38>)
 8012b9a:	607b      	str	r3, [r7, #4]
	HAL_ADC_IRQHandler(&ADC_handle);
 8012b9c:	1d3b      	adds	r3, r7, #4
 8012b9e:	4618      	mov	r0, r3
 8012ba0:	f7f3 fc46 	bl	8006430 <HAL_ADC_IRQHandler>
	
	HAL_GPIO_WritePin(GPIOI,GPIO_PIN_3, GPIO_PIN_RESET);
 8012ba4:	4804      	ldr	r0, [pc, #16]	; (8012bb8 <ADC_IRQHandler+0x34>)
 8012ba6:	2108      	movs	r1, #8
 8012ba8:	2200      	movs	r2, #0
 8012baa:	f7fa fafb 	bl	800d1a4 <HAL_GPIO_WritePin>
    /* leave interrupt */
    rt_interrupt_leave();
 8012bae:	f003 fcb5 	bl	801651c <rt_interrupt_leave>
}
 8012bb2:	3748      	adds	r7, #72	; 0x48
 8012bb4:	46bd      	mov	sp, r7
 8012bb6:	bd80      	pop	{r7, pc}
 8012bb8:	40022000 	.word	0x40022000
 8012bbc:	40012000 	.word	0x40012000

08012bc0 <HAL_ADC_MspInit>:
  *           - NVIC configuration for UART interrupt request enable
  * @param huart: UART handle pointer
  * @retval None
  */
	void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 8012bc0:	b580      	push	{r7, lr}
 8012bc2:	b090      	sub	sp, #64	; 0x40
 8012bc4:	af00      	add	r7, sp, #0
 8012bc6:	6078      	str	r0, [r7, #4]
    GPIO_InitTypeDef  GPIO_InitStruct;
    if (hadc->Instance == ADC1)
 8012bc8:	687b      	ldr	r3, [r7, #4]
 8012bca:	681b      	ldr	r3, [r3, #0]
 8012bcc:	4a90      	ldr	r2, [pc, #576]	; (8012e10 <HAL_ADC_MspInit+0x250>)
 8012bce:	4293      	cmp	r3, r2
 8012bd0:	d153      	bne.n	8012c7a <HAL_ADC_MspInit+0xba>
    {
 		ADC1_CLK_ENABLE();
 8012bd2:	4a90      	ldr	r2, [pc, #576]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012bd4:	4b8f      	ldr	r3, [pc, #572]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012bd6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8012bd8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8012bdc:	6453      	str	r3, [r2, #68]	; 0x44
 8012bde:	4b8d      	ldr	r3, [pc, #564]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012be0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8012be2:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8012be6:	62bb      	str	r3, [r7, #40]	; 0x28
 8012be8:	6abb      	ldr	r3, [r7, #40]	; 0x28
		ADC_GPIOA_CLK_ENABLE();
 8012bea:	4a8a      	ldr	r2, [pc, #552]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012bec:	4b89      	ldr	r3, [pc, #548]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012bee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012bf0:	f043 0301 	orr.w	r3, r3, #1
 8012bf4:	6313      	str	r3, [r2, #48]	; 0x30
 8012bf6:	4b87      	ldr	r3, [pc, #540]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012bf8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012bfa:	f003 0301 	and.w	r3, r3, #1
 8012bfe:	627b      	str	r3, [r7, #36]	; 0x24
 8012c00:	6a7b      	ldr	r3, [r7, #36]	; 0x24
		ADC_GPIOC_CLK_ENABLE();
 8012c02:	4a84      	ldr	r2, [pc, #528]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012c04:	4b83      	ldr	r3, [pc, #524]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012c06:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012c08:	f043 0304 	orr.w	r3, r3, #4
 8012c0c:	6313      	str	r3, [r2, #48]	; 0x30
 8012c0e:	4b81      	ldr	r3, [pc, #516]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012c10:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012c12:	f003 0304 	and.w	r3, r3, #4
 8012c16:	623b      	str	r3, [r7, #32]
 8012c18:	6a3b      	ldr	r3, [r7, #32]

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8012c1a:	2303      	movs	r3, #3
 8012c1c:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_C1_CURRENT_PIN;
 8012c1e:	2340      	movs	r3, #64	; 0x40
 8012c20:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012c22:	2300      	movs	r3, #0
 8012c24:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_C1_CURRENT_PORT, &GPIO_InitStruct);		
 8012c26:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8012c2a:	487b      	ldr	r0, [pc, #492]	; (8012e18 <HAL_ADC_MspInit+0x258>)
 8012c2c:	4619      	mov	r1, r3
 8012c2e:	f7fa f809 	bl	800cc44 <HAL_GPIO_Init>

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8012c32:	2303      	movs	r3, #3
 8012c34:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_C2_CURRENT_PIN;
 8012c36:	2302      	movs	r3, #2
 8012c38:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012c3a:	2300      	movs	r3, #0
 8012c3c:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_C2_CURRENT_PORT, &GPIO_InitStruct);		
 8012c3e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8012c42:	4876      	ldr	r0, [pc, #472]	; (8012e1c <HAL_ADC_MspInit+0x25c>)
 8012c44:	4619      	mov	r1, r3
 8012c46:	f7f9 fffd 	bl	800cc44 <HAL_GPIO_Init>
		
		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8012c4a:	2303      	movs	r3, #3
 8012c4c:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_C_VOLTAGE_PIN;
 8012c4e:	2320      	movs	r3, #32
 8012c50:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012c52:	2300      	movs	r3, #0
 8012c54:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_C_VOLTAGE_PORT, &GPIO_InitStruct);		
 8012c56:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8012c5a:	486f      	ldr	r0, [pc, #444]	; (8012e18 <HAL_ADC_MspInit+0x258>)
 8012c5c:	4619      	mov	r1, r3
 8012c5e:	f7f9 fff1 	bl	800cc44 <HAL_GPIO_Init>
		
		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8012c62:	2303      	movs	r3, #3
 8012c64:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_TEMP_PIN;
 8012c66:	2301      	movs	r3, #1
 8012c68:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012c6a:	2300      	movs	r3, #0
 8012c6c:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_TEMP_PORT, &GPIO_InitStruct);		
 8012c6e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8012c72:	486a      	ldr	r0, [pc, #424]	; (8012e1c <HAL_ADC_MspInit+0x25c>)
 8012c74:	4619      	mov	r1, r3
 8012c76:	f7f9 ffe5 	bl	800cc44 <HAL_GPIO_Init>
    }

	if (hadc->Instance == ADC2)
 8012c7a:	687b      	ldr	r3, [r7, #4]
 8012c7c:	681b      	ldr	r3, [r3, #0]
 8012c7e:	4a68      	ldr	r2, [pc, #416]	; (8012e20 <HAL_ADC_MspInit+0x260>)
 8012c80:	4293      	cmp	r3, r2
 8012c82:	d153      	bne.n	8012d2c <HAL_ADC_MspInit+0x16c>
    {
 		ADC2_CLK_ENABLE();
 8012c84:	4a63      	ldr	r2, [pc, #396]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012c86:	4b63      	ldr	r3, [pc, #396]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012c88:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8012c8a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8012c8e:	6453      	str	r3, [r2, #68]	; 0x44
 8012c90:	4b60      	ldr	r3, [pc, #384]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012c92:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8012c94:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8012c98:	61fb      	str	r3, [r7, #28]
 8012c9a:	69fb      	ldr	r3, [r7, #28]
		ADC_GPIOA_CLK_ENABLE();
 8012c9c:	4a5d      	ldr	r2, [pc, #372]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012c9e:	4b5d      	ldr	r3, [pc, #372]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012ca0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012ca2:	f043 0301 	orr.w	r3, r3, #1
 8012ca6:	6313      	str	r3, [r2, #48]	; 0x30
 8012ca8:	4b5a      	ldr	r3, [pc, #360]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012caa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012cac:	f003 0301 	and.w	r3, r3, #1
 8012cb0:	61bb      	str	r3, [r7, #24]
 8012cb2:	69bb      	ldr	r3, [r7, #24]
		ADC_GPIOC_CLK_ENABLE();
 8012cb4:	4a57      	ldr	r2, [pc, #348]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012cb6:	4b57      	ldr	r3, [pc, #348]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012cb8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012cba:	f043 0304 	orr.w	r3, r3, #4
 8012cbe:	6313      	str	r3, [r2, #48]	; 0x30
 8012cc0:	4b54      	ldr	r3, [pc, #336]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012cc2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012cc4:	f003 0304 	and.w	r3, r3, #4
 8012cc8:	617b      	str	r3, [r7, #20]
 8012cca:	697b      	ldr	r3, [r7, #20]

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8012ccc:	2303      	movs	r3, #3
 8012cce:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_B1_CURRENT_PIN;
 8012cd0:	2308      	movs	r3, #8
 8012cd2:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012cd4:	2300      	movs	r3, #0
 8012cd6:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_B1_CURRENT_PORT, &GPIO_InitStruct);		
 8012cd8:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8012cdc:	484e      	ldr	r0, [pc, #312]	; (8012e18 <HAL_ADC_MspInit+0x258>)
 8012cde:	4619      	mov	r1, r3
 8012ce0:	f7f9 ffb0 	bl	800cc44 <HAL_GPIO_Init>

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8012ce4:	2303      	movs	r3, #3
 8012ce6:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_B2_CURRENT_PIN;
 8012ce8:	2304      	movs	r3, #4
 8012cea:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012cec:	2300      	movs	r3, #0
 8012cee:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_B2_CURRENT_PORT, &GPIO_InitStruct);		
 8012cf0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8012cf4:	484b      	ldr	r0, [pc, #300]	; (8012e24 <HAL_ADC_MspInit+0x264>)
 8012cf6:	4619      	mov	r1, r3
 8012cf8:	f7f9 ffa4 	bl	800cc44 <HAL_GPIO_Init>

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8012cfc:	2303      	movs	r3, #3
 8012cfe:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_B_VOLTAGE_PIN;
 8012d00:	2310      	movs	r3, #16
 8012d02:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012d04:	2300      	movs	r3, #0
 8012d06:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_B_VOLTAGE_PORT, &GPIO_InitStruct);	
 8012d08:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8012d0c:	4842      	ldr	r0, [pc, #264]	; (8012e18 <HAL_ADC_MspInit+0x258>)
 8012d0e:	4619      	mov	r1, r3
 8012d10:	f7f9 ff98 	bl	800cc44 <HAL_GPIO_Init>
		
		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8012d14:	2303      	movs	r3, #3
 8012d16:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_BUS_CURRENT_PIN;
 8012d18:	2301      	movs	r3, #1
 8012d1a:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012d1c:	2300      	movs	r3, #0
 8012d1e:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_BUS_CURRENT_PORT, &GPIO_InitStruct);		
 8012d20:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8012d24:	483f      	ldr	r0, [pc, #252]	; (8012e24 <HAL_ADC_MspInit+0x264>)
 8012d26:	4619      	mov	r1, r3
 8012d28:	f7f9 ff8c 	bl	800cc44 <HAL_GPIO_Init>
    }

	
	if (hadc->Instance == ADC3)
 8012d2c:	687b      	ldr	r3, [r7, #4]
 8012d2e:	681b      	ldr	r3, [r3, #0]
 8012d30:	4a3d      	ldr	r2, [pc, #244]	; (8012e28 <HAL_ADC_MspInit+0x268>)
 8012d32:	4293      	cmp	r3, r2
 8012d34:	d155      	bne.n	8012de2 <HAL_ADC_MspInit+0x222>
    {
 		ADC3_CLK_ENABLE();
 8012d36:	4a37      	ldr	r2, [pc, #220]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012d38:	4b36      	ldr	r3, [pc, #216]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012d3a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8012d3c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8012d40:	6453      	str	r3, [r2, #68]	; 0x44
 8012d42:	4b34      	ldr	r3, [pc, #208]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012d44:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8012d46:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8012d4a:	613b      	str	r3, [r7, #16]
 8012d4c:	693b      	ldr	r3, [r7, #16]
		ADC_GPIOA_CLK_ENABLE();
 8012d4e:	4a31      	ldr	r2, [pc, #196]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012d50:	4b30      	ldr	r3, [pc, #192]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012d52:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012d54:	f043 0301 	orr.w	r3, r3, #1
 8012d58:	6313      	str	r3, [r2, #48]	; 0x30
 8012d5a:	4b2e      	ldr	r3, [pc, #184]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012d5c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012d5e:	f003 0301 	and.w	r3, r3, #1
 8012d62:	60fb      	str	r3, [r7, #12]
 8012d64:	68fb      	ldr	r3, [r7, #12]
		ADC_GPIOF_CLK_ENABLE();
 8012d66:	4a2b      	ldr	r2, [pc, #172]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012d68:	4b2a      	ldr	r3, [pc, #168]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012d6a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012d6c:	f043 0320 	orr.w	r3, r3, #32
 8012d70:	6313      	str	r3, [r2, #48]	; 0x30
 8012d72:	4b28      	ldr	r3, [pc, #160]	; (8012e14 <HAL_ADC_MspInit+0x254>)
 8012d74:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012d76:	f003 0320 	and.w	r3, r3, #32
 8012d7a:	60bb      	str	r3, [r7, #8]
 8012d7c:	68bb      	ldr	r3, [r7, #8]

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8012d7e:	2303      	movs	r3, #3
 8012d80:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_A1_CURRENT_PIN;
 8012d82:	2380      	movs	r3, #128	; 0x80
 8012d84:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012d86:	2300      	movs	r3, #0
 8012d88:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_A1_CURRENT_PORT, &GPIO_InitStruct);		
 8012d8a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8012d8e:	4827      	ldr	r0, [pc, #156]	; (8012e2c <HAL_ADC_MspInit+0x26c>)
 8012d90:	4619      	mov	r1, r3
 8012d92:	f7f9 ff57 	bl	800cc44 <HAL_GPIO_Init>

		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8012d96:	2303      	movs	r3, #3
 8012d98:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_A2_CURRENT_PIN;
 8012d9a:	f44f 7380 	mov.w	r3, #256	; 0x100
 8012d9e:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012da0:	2300      	movs	r3, #0
 8012da2:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_A2_CURRENT_PORT, &GPIO_InitStruct);		
 8012da4:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8012da8:	4820      	ldr	r0, [pc, #128]	; (8012e2c <HAL_ADC_MspInit+0x26c>)
 8012daa:	4619      	mov	r1, r3
 8012dac:	f7f9 ff4a 	bl	800cc44 <HAL_GPIO_Init>
		
		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8012db0:	2303      	movs	r3, #3
 8012db2:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_A_VOLTAGE_PIN;
 8012db4:	f44f 7300 	mov.w	r3, #512	; 0x200
 8012db8:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012dba:	2300      	movs	r3, #0
 8012dbc:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_A_VOLTAGE_PORT, &GPIO_InitStruct);		
 8012dbe:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8012dc2:	481a      	ldr	r0, [pc, #104]	; (8012e2c <HAL_ADC_MspInit+0x26c>)
 8012dc4:	4619      	mov	r1, r3
 8012dc6:	f7f9 ff3d 	bl	800cc44 <HAL_GPIO_Init>
		
		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8012dca:	2303      	movs	r3, #3
 8012dcc:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_InitStruct.Pin = PHASE_BUS_VOLTAGE_PIN;
 8012dce:	2340      	movs	r3, #64	; 0x40
 8012dd0:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012dd2:	2300      	movs	r3, #0
 8012dd4:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PHASE_BUS_VOLTAGE_PORT, &GPIO_InitStruct);		
 8012dd6:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8012dda:	4814      	ldr	r0, [pc, #80]	; (8012e2c <HAL_ADC_MspInit+0x26c>)
 8012ddc:	4619      	mov	r1, r3
 8012dde:	f7f9 ff31 	bl	800cc44 <HAL_GPIO_Init>
    }

	/*************************test pin************************/
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8012de2:	2301      	movs	r3, #1
 8012de4:	633b      	str	r3, [r7, #48]	; 0x30
	GPIO_InitStruct.Pin = GPIO_PIN_3;
 8012de6:	2308      	movs	r3, #8
 8012de8:	62fb      	str	r3, [r7, #44]	; 0x2c
	GPIO_InitStruct.Pull = GPIO_PULLUP;
 8012dea:	2301      	movs	r3, #1
 8012dec:	637b      	str	r3, [r7, #52]	; 0x34
	HAL_GPIO_Init(GPIOI, &GPIO_InitStruct); 	
 8012dee:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8012df2:	480f      	ldr	r0, [pc, #60]	; (8012e30 <HAL_ADC_MspInit+0x270>)
 8012df4:	4619      	mov	r1, r3
 8012df6:	f7f9 ff25 	bl	800cc44 <HAL_GPIO_Init>
	
	HAL_NVIC_SetPriority(ADC_IRQn,ADC_IRQ_PREEMPT,ADC_IRQ_SUB);
 8012dfa:	2012      	movs	r0, #18
 8012dfc:	2100      	movs	r1, #0
 8012dfe:	2200      	movs	r2, #0
 8012e00:	f7f5 fa3c 	bl	800827c <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(ADC_IRQn);
 8012e04:	2012      	movs	r0, #18
 8012e06:	f7f5 fa55 	bl	80082b4 <HAL_NVIC_EnableIRQ>
}
 8012e0a:	3740      	adds	r7, #64	; 0x40
 8012e0c:	46bd      	mov	sp, r7
 8012e0e:	bd80      	pop	{r7, pc}
 8012e10:	40012000 	.word	0x40012000
 8012e14:	40023800 	.word	0x40023800
 8012e18:	40020000 	.word	0x40020000
 8012e1c:	40020400 	.word	0x40020400
 8012e20:	40012100 	.word	0x40012100
 8012e24:	40020800 	.word	0x40020800
 8012e28:	40012200 	.word	0x40012200
 8012e2c:	40021400 	.word	0x40021400
 8012e30:	40022000 	.word	0x40022000

08012e34 <ADC_CalibrationAll>:



extern void ADC_CalibrationAll(void)
{
 8012e34:	b580      	push	{r7, lr}
 8012e36:	b0c0      	sub	sp, #256	; 0x100
 8012e38:	af00      	add	r7, sp, #0
	ADC_HandleTypeDef ADC1_handle,ADC2_handle,ADC3_handle;
	ADC_InjectionConfTypeDef ADCConfigInjected;
	ADC_MultiModeTypeDef ADCMultiMode;

	QIEMW_ADC_init(&Global_User_ADC);
 8012e3a:	4881      	ldr	r0, [pc, #516]	; (8013040 <ADC_CalibrationAll+0x20c>)
 8012e3c:	f7ff fa5a 	bl	80122f4 <QIEMW_ADC_init>
	ADC1_handle.Instance = ADC1;
 8012e40:	4b80      	ldr	r3, [pc, #512]	; (8013044 <ADC_CalibrationAll+0x210>)
 8012e42:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
	ADC2_handle.Instance = ADC2;
 8012e46:	4b80      	ldr	r3, [pc, #512]	; (8013048 <ADC_CalibrationAll+0x214>)
 8012e48:	67bb      	str	r3, [r7, #120]	; 0x78
	ADC3_handle.Instance = ADC3;
 8012e4a:	4b80      	ldr	r3, [pc, #512]	; (801304c <ADC_CalibrationAll+0x218>)
 8012e4c:	637b      	str	r3, [r7, #52]	; 0x34
	#if 1
	ADC_Calibration(&ADC1_handle,&Global_User_ADC);
 8012e4e:	f107 03bc 	add.w	r3, r7, #188	; 0xbc
 8012e52:	4618      	mov	r0, r3
 8012e54:	497a      	ldr	r1, [pc, #488]	; (8013040 <ADC_CalibrationAll+0x20c>)
 8012e56:	f7ff fabf 	bl	80123d8 <ADC_Calibration>
	ADC_Calibration(&ADC2_handle,&Global_User_ADC);
 8012e5a:	f107 0378 	add.w	r3, r7, #120	; 0x78
 8012e5e:	4618      	mov	r0, r3
 8012e60:	4977      	ldr	r1, [pc, #476]	; (8013040 <ADC_CalibrationAll+0x20c>)
 8012e62:	f7ff fab9 	bl	80123d8 <ADC_Calibration>
	ADC_Calibration(&ADC3_handle,&Global_User_ADC);
 8012e66:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8012e6a:	4618      	mov	r0, r3
 8012e6c:	4974      	ldr	r1, [pc, #464]	; (8013040 <ADC_CalibrationAll+0x20c>)
 8012e6e:	f7ff fab3 	bl	80123d8 <ADC_Calibration>
	#endif
	ADCConfigInjected.AutoInjectedConv = DISABLE;
 8012e72:	2300      	movs	r3, #0
 8012e74:	627b      	str	r3, [r7, #36]	; 0x24
	ADCConfigInjected.ExternalTrigInjecConv = ADC_EXTERNALTRIGINJECCONV_T8_TRGO2;
 8012e76:	f44f 2320 	mov.w	r3, #655360	; 0xa0000
 8012e7a:	633b      	str	r3, [r7, #48]	; 0x30
	ADCConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONVEDGE_RISINGFALLING;
 8012e7c:	f44f 1340 	mov.w	r3, #3145728	; 0x300000
 8012e80:	62fb      	str	r3, [r7, #44]	; 0x2c
	ADCConfigInjected.InjectedChannel = PHASE_C1_CURRENT_CHANNEL;
 8012e82:	2306      	movs	r3, #6
 8012e84:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedDiscontinuousConvMode = DISABLE;
 8012e86:	2300      	movs	r3, #0
 8012e88:	62bb      	str	r3, [r7, #40]	; 0x28
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 8012e8a:	2304      	movs	r3, #4
 8012e8c:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 1;
 8012e8e:	2301      	movs	r3, #1
 8012e90:	617b      	str	r3, [r7, #20]
	ADCConfigInjected.InjectedSamplingTime = ADC_SAMPLETIME_28CYCLES;
 8012e92:	2302      	movs	r3, #2
 8012e94:	61bb      	str	r3, [r7, #24]
	#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseC.qI1_offset>>4;
	#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseC.qI1_offset;
	ADCConfigInjected.InjectedOffset = 0;
 8012e96:	2300      	movs	r3, #0
 8012e98:	61fb      	str	r3, [r7, #28]
	#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC1_handle,&ADCConfigInjected);
 8012e9a:	f107 02bc 	add.w	r2, r7, #188	; 0xbc
 8012e9e:	f107 0310 	add.w	r3, r7, #16
 8012ea2:	4610      	mov	r0, r2
 8012ea4:	4619      	mov	r1, r3
 8012ea6:	f7f3 ff61 	bl	8006d6c <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_C2_CURRENT_CHANNEL;
 8012eaa:	2309      	movs	r3, #9
 8012eac:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 8012eae:	2304      	movs	r3, #4
 8012eb0:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 2;
 8012eb2:	2302      	movs	r3, #2
 8012eb4:	617b      	str	r3, [r7, #20]
	
	#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseC.qI2_offset>>4;
	#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseC.qI2_offset;
	ADCConfigInjected.InjectedOffset = 0;
 8012eb6:	2300      	movs	r3, #0
 8012eb8:	61fb      	str	r3, [r7, #28]
	#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC1_handle,&ADCConfigInjected);
 8012eba:	f107 02bc 	add.w	r2, r7, #188	; 0xbc
 8012ebe:	f107 0310 	add.w	r3, r7, #16
 8012ec2:	4610      	mov	r0, r2
 8012ec4:	4619      	mov	r1, r3
 8012ec6:	f7f3 ff51 	bl	8006d6c <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_C_VOLTAGE_CHANNEL;
 8012eca:	2305      	movs	r3, #5
 8012ecc:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 8012ece:	2304      	movs	r3, #4
 8012ed0:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 3;
 8012ed2:	2303      	movs	r3, #3
 8012ed4:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseC.qV_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseC.qV_offset;
	ADCConfigInjected.InjectedOffset = 0;
 8012ed6:	2300      	movs	r3, #0
 8012ed8:	61fb      	str	r3, [r7, #28]

#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC1_handle,&ADCConfigInjected);
 8012eda:	f107 02bc 	add.w	r2, r7, #188	; 0xbc
 8012ede:	f107 0310 	add.w	r3, r7, #16
 8012ee2:	4610      	mov	r0, r2
 8012ee4:	4619      	mov	r1, r3
 8012ee6:	f7f3 ff41 	bl	8006d6c <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_TEMP_CHANNEL;
 8012eea:	2308      	movs	r3, #8
 8012eec:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 8012eee:	2304      	movs	r3, #4
 8012ef0:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 4;
 8012ef2:	2304      	movs	r3, #4
 8012ef4:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.Temp.TEMP_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.Temp.TEMP_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 8012ef6:	2300      	movs	r3, #0
 8012ef8:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC1_handle,&ADCConfigInjected);
 8012efa:	f107 02bc 	add.w	r2, r7, #188	; 0xbc
 8012efe:	f107 0310 	add.w	r3, r7, #16
 8012f02:	4610      	mov	r0, r2
 8012f04:	4619      	mov	r1, r3
 8012f06:	f7f3 ff31 	bl	8006d6c <HAL_ADCEx_InjectedConfigChannel>
	
	
	ADCConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONVEDGE_NONE;
 8012f0a:	2300      	movs	r3, #0
 8012f0c:	62fb      	str	r3, [r7, #44]	; 0x2c
	ADCConfigInjected.InjectedChannel = PHASE_B1_CURRENT_CHANNEL;
 8012f0e:	2303      	movs	r3, #3
 8012f10:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 8012f12:	2304      	movs	r3, #4
 8012f14:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 1;
 8012f16:	2301      	movs	r3, #1
 8012f18:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseB.qI1_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseB.qI1_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 8012f1a:	2300      	movs	r3, #0
 8012f1c:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC2_handle,&ADCConfigInjected);
 8012f1e:	f107 0278 	add.w	r2, r7, #120	; 0x78
 8012f22:	f107 0310 	add.w	r3, r7, #16
 8012f26:	4610      	mov	r0, r2
 8012f28:	4619      	mov	r1, r3
 8012f2a:	f7f3 ff1f 	bl	8006d6c <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_B2_CURRENT_CHANNEL;
 8012f2e:	230c      	movs	r3, #12
 8012f30:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 8012f32:	2304      	movs	r3, #4
 8012f34:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 2;
 8012f36:	2302      	movs	r3, #2
 8012f38:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseB.qI2_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseB.qI2_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 8012f3a:	2300      	movs	r3, #0
 8012f3c:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC2_handle,&ADCConfigInjected);
 8012f3e:	f107 0278 	add.w	r2, r7, #120	; 0x78
 8012f42:	f107 0310 	add.w	r3, r7, #16
 8012f46:	4610      	mov	r0, r2
 8012f48:	4619      	mov	r1, r3
 8012f4a:	f7f3 ff0f 	bl	8006d6c <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_B_VOLTAGE_CHANNEL;
 8012f4e:	2304      	movs	r3, #4
 8012f50:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 8012f52:	2304      	movs	r3, #4
 8012f54:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 3;
 8012f56:	2303      	movs	r3, #3
 8012f58:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseB.qV_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseB.qV_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 8012f5a:	2300      	movs	r3, #0
 8012f5c:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC2_handle,&ADCConfigInjected);
 8012f5e:	f107 0278 	add.w	r2, r7, #120	; 0x78
 8012f62:	f107 0310 	add.w	r3, r7, #16
 8012f66:	4610      	mov	r0, r2
 8012f68:	4619      	mov	r1, r3
 8012f6a:	f7f3 feff 	bl	8006d6c <HAL_ADCEx_InjectedConfigChannel>
	
	ADCConfigInjected.InjectedChannel = PHASE_BUS_CURRENT_CHANNEL;
 8012f6e:	230a      	movs	r3, #10
 8012f70:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 8012f72:	2304      	movs	r3, #4
 8012f74:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 4;
 8012f76:	2304      	movs	r3, #4
 8012f78:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.BUS.qI_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.BUS.qI_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 8012f7a:	2300      	movs	r3, #0
 8012f7c:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC2_handle,&ADCConfigInjected);
 8012f7e:	f107 0278 	add.w	r2, r7, #120	; 0x78
 8012f82:	f107 0310 	add.w	r3, r7, #16
 8012f86:	4610      	mov	r0, r2
 8012f88:	4619      	mov	r1, r3
 8012f8a:	f7f3 feef 	bl	8006d6c <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_A1_CURRENT_CHANNEL;
 8012f8e:	2305      	movs	r3, #5
 8012f90:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 8012f92:	2304      	movs	r3, #4
 8012f94:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 1;
 8012f96:	2301      	movs	r3, #1
 8012f98:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseA.qI1_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseA.qI1_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 8012f9a:	2300      	movs	r3, #0
 8012f9c:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC3_handle,&ADCConfigInjected);
 8012f9e:	f107 0234 	add.w	r2, r7, #52	; 0x34
 8012fa2:	f107 0310 	add.w	r3, r7, #16
 8012fa6:	4610      	mov	r0, r2
 8012fa8:	4619      	mov	r1, r3
 8012faa:	f7f3 fedf 	bl	8006d6c <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_A2_CURRENT_CHANNEL;
 8012fae:	2306      	movs	r3, #6
 8012fb0:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 8012fb2:	2304      	movs	r3, #4
 8012fb4:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 2;
 8012fb6:	2302      	movs	r3, #2
 8012fb8:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseA.qI2_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseA.qI2_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 8012fba:	2300      	movs	r3, #0
 8012fbc:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC3_handle,&ADCConfigInjected);
 8012fbe:	f107 0234 	add.w	r2, r7, #52	; 0x34
 8012fc2:	f107 0310 	add.w	r3, r7, #16
 8012fc6:	4610      	mov	r0, r2
 8012fc8:	4619      	mov	r1, r3
 8012fca:	f7f3 fecf 	bl	8006d6c <HAL_ADCEx_InjectedConfigChannel>

	ADCConfigInjected.InjectedChannel = PHASE_A_VOLTAGE_CHANNEL;
 8012fce:	2307      	movs	r3, #7
 8012fd0:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 8012fd2:	2304      	movs	r3, #4
 8012fd4:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 3;
 8012fd6:	2303      	movs	r3, #3
 8012fd8:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseA.qV_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.PhaseA.qV_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 8012fda:	2300      	movs	r3, #0
 8012fdc:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC3_handle,&ADCConfigInjected);
 8012fde:	f107 0234 	add.w	r2, r7, #52	; 0x34
 8012fe2:	f107 0310 	add.w	r3, r7, #16
 8012fe6:	4610      	mov	r0, r2
 8012fe8:	4619      	mov	r1, r3
 8012fea:	f7f3 febf 	bl	8006d6c <HAL_ADCEx_InjectedConfigChannel>
	
	ADCConfigInjected.InjectedChannel = PHASE_BUS_VOLTAGE_CHANNEL;
 8012fee:	2304      	movs	r3, #4
 8012ff0:	613b      	str	r3, [r7, #16]
	ADCConfigInjected.InjectedNbrOfConversion = 4;
 8012ff2:	2304      	movs	r3, #4
 8012ff4:	623b      	str	r3, [r7, #32]
	ADCConfigInjected.InjectedRank = 4;
 8012ff6:	2304      	movs	r3, #4
 8012ff8:	617b      	str	r3, [r7, #20]
#ifdef DATAALIGN_LEFT
	ADCConfigInjected.InjectedOffset = Global_User_ADC.BUS.qV_offset>>4;
#else
	//ADCConfigInjected.InjectedOffset = Global_User_ADC.BUS.qV_offset;
	
	ADCConfigInjected.InjectedOffset = 0;
 8012ffa:	2300      	movs	r3, #0
 8012ffc:	61fb      	str	r3, [r7, #28]
#endif
	HAL_ADCEx_InjectedConfigChannel(&ADC3_handle,&ADCConfigInjected);
 8012ffe:	f107 0234 	add.w	r2, r7, #52	; 0x34
 8013002:	f107 0310 	add.w	r3, r7, #16
 8013006:	4610      	mov	r0, r2
 8013008:	4619      	mov	r1, r3
 801300a:	f7f3 feaf 	bl	8006d6c <HAL_ADCEx_InjectedConfigChannel>

	ADCMultiMode.DMAAccessMode = ADC_DMAACCESSMODE_DISABLED;
 801300e:	2300      	movs	r3, #0
 8013010:	60bb      	str	r3, [r7, #8]
	ADCMultiMode.Mode = ADC_TRIPLEMODE_INJECSIMULT;
 8013012:	2315      	movs	r3, #21
 8013014:	607b      	str	r3, [r7, #4]
	ADCMultiMode.TwoSamplingDelay = ADC_TWOSAMPLINGDELAY_5CYCLES;
 8013016:	2300      	movs	r3, #0
 8013018:	60fb      	str	r3, [r7, #12]
	HAL_ADCEx_MultiModeConfigChannel(&ADC1_handle, &ADCMultiMode);
 801301a:	f107 02bc 	add.w	r2, r7, #188	; 0xbc
 801301e:	1d3b      	adds	r3, r7, #4
 8013020:	4610      	mov	r0, r2
 8013022:	4619      	mov	r1, r3
 8013024:	f7f4 f816 	bl	8007054 <HAL_ADCEx_MultiModeConfigChannel>
	HAL_NVIC_EnableIRQ(ADC_IRQn);
 8013028:	2012      	movs	r0, #18
 801302a:	f7f5 f943 	bl	80082b4 <HAL_NVIC_EnableIRQ>
	HAL_ADCEx_InjectedStart_IT(&ADC1_handle);
 801302e:	f107 03bc 	add.w	r3, r7, #188	; 0xbc
 8013032:	4618      	mov	r0, r3
 8013034:	f7f3 fd7c 	bl	8006b30 <HAL_ADCEx_InjectedStart_IT>
}
 8013038:	f507 7780 	add.w	r7, r7, #256	; 0x100
 801303c:	46bd      	mov	sp, r7
 801303e:	bd80      	pop	{r7, pc}
 8013040:	200128e4 	.word	0x200128e4
 8013044:	40012000 	.word	0x40012000
 8013048:	40012100 	.word	0x40012100
 801304c:	40012200 	.word	0x40012200

08013050 <HAL_ADC_MspDeInit>:
  *          - Revert GPIO and NVIC configuration to their default state
  * @param huart: UART handle pointer
  * @retval None
  */
	void HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc)
{
 8013050:	b480      	push	{r7}
 8013052:	b083      	sub	sp, #12
 8013054:	af00      	add	r7, sp, #0
 8013056:	6078      	str	r0, [r7, #4]
   
}
 8013058:	370c      	adds	r7, #12
 801305a:	46bd      	mov	sp, r7
 801305c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013060:	4770      	bx	lr
 8013062:	bf00      	nop

08013064 <stm32_hw_ADC_init>:

extern int stm32_hw_ADC_init(void)
{
 8013064:	b580      	push	{r7, lr}
 8013066:	b0b4      	sub	sp, #208	; 0xd0
 8013068:	af00      	add	r7, sp, #0
	ADC_HandleTypeDef ADC1_handle,ADC2_handle,ADC3_handle;

	QIEMW_ADC_init(&Global_User_ADC);
 801306a:	483e      	ldr	r0, [pc, #248]	; (8013164 <stm32_hw_ADC_init+0x100>)
 801306c:	f7ff f942 	bl	80122f4 <QIEMW_ADC_init>
	ADC1_handle.Instance = ADC1;
 8013070:	4b3d      	ldr	r3, [pc, #244]	; (8013168 <stm32_hw_ADC_init+0x104>)
 8013072:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
	HAL_ADC_DeInit(&ADC1_handle);
 8013076:	f107 038c 	add.w	r3, r7, #140	; 0x8c
 801307a:	4618      	mov	r0, r3
 801307c:	f7f3 f926 	bl	80062cc <HAL_ADC_DeInit>
	ADC1_handle.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8; /* 96M/8 */
 8013080:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 8013084:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
	ADC1_handle.Init.ContinuousConvMode = DISABLE;
 8013088:	2300      	movs	r3, #0
 801308a:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
	#ifdef DATAALIGN_LEFT
	ADC1_handle.Init.DataAlign = ADC_DATAALIGN_LEFT;
	#else
	ADC1_handle.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 801308e:	2300      	movs	r3, #0
 8013090:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
	#endif
	#if 1
	ADC1_handle.Init.DiscontinuousConvMode = DISABLE;
 8013094:	2300      	movs	r3, #0
 8013096:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
	ADC1_handle.Init.DMAContinuousRequests = DISABLE;
 801309a:	2300      	movs	r3, #0
 801309c:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
	ADC1_handle.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 80130a0:	2300      	movs	r3, #0
 80130a2:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
	ADC1_handle.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 80130a6:	4b31      	ldr	r3, [pc, #196]	; (801316c <stm32_hw_ADC_init+0x108>)
 80130a8:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
	ADC1_handle.Init.NbrOfConversion = 1;
 80130ac:	2301      	movs	r3, #1
 80130ae:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
	ADC1_handle.Init.NbrOfDiscConversion = 0;
 80130b2:	2300      	movs	r3, #0
 80130b4:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
	#endif
	ADC1_handle.Init.Resolution = ADC_RESOLUTION_12B;
 80130b8:	2300      	movs	r3, #0
 80130ba:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
	ADC1_handle.Init.ScanConvMode = ENABLE;
 80130be:	2301      	movs	r3, #1
 80130c0:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
	HAL_ADC_Init(&ADC1_handle);
 80130c4:	f107 038c 	add.w	r3, r7, #140	; 0x8c
 80130c8:	4618      	mov	r0, r3
 80130ca:	f7f3 f8d1 	bl	8006270 <HAL_ADC_Init>
	
	ADC2_handle.Instance = ADC2;
 80130ce:	4b28      	ldr	r3, [pc, #160]	; (8013170 <stm32_hw_ADC_init+0x10c>)
 80130d0:	64bb      	str	r3, [r7, #72]	; 0x48
	HAL_ADC_DeInit(&ADC2_handle);
 80130d2:	f107 0348 	add.w	r3, r7, #72	; 0x48
 80130d6:	4618      	mov	r0, r3
 80130d8:	f7f3 f8f8 	bl	80062cc <HAL_ADC_DeInit>

	
	ADC2_handle.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8; /* 96M/8 */
 80130dc:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 80130e0:	64fb      	str	r3, [r7, #76]	; 0x4c
	ADC2_handle.Init.ContinuousConvMode = DISABLE;
 80130e2:	2300      	movs	r3, #0
 80130e4:	663b      	str	r3, [r7, #96]	; 0x60
	
#ifdef DATAALIGN_LEFT
	ADC2_handle.Init.DataAlign = ADC_DATAALIGN_LEFT;
#else
	ADC2_handle.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 80130e6:	2300      	movs	r3, #0
 80130e8:	657b      	str	r3, [r7, #84]	; 0x54
#endif
#if 1
	ADC2_handle.Init.DiscontinuousConvMode = DISABLE;
 80130ea:	2300      	movs	r3, #0
 80130ec:	66fb      	str	r3, [r7, #108]	; 0x6c
	ADC2_handle.Init.DMAContinuousRequests = DISABLE;
 80130ee:	2300      	movs	r3, #0
 80130f0:	667b      	str	r3, [r7, #100]	; 0x64
	ADC2_handle.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 80130f2:	2300      	movs	r3, #0
 80130f4:	65fb      	str	r3, [r7, #92]	; 0x5c
	ADC2_handle.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 80130f6:	4b1d      	ldr	r3, [pc, #116]	; (801316c <stm32_hw_ADC_init+0x108>)
 80130f8:	677b      	str	r3, [r7, #116]	; 0x74
	ADC2_handle.Init.NbrOfConversion = 1;
 80130fa:	2301      	movs	r3, #1
 80130fc:	66bb      	str	r3, [r7, #104]	; 0x68
	ADC2_handle.Init.NbrOfDiscConversion = 0;
 80130fe:	2300      	movs	r3, #0
 8013100:	673b      	str	r3, [r7, #112]	; 0x70
	#endif
	ADC2_handle.Init.Resolution = ADC_RESOLUTION_12B;
 8013102:	2300      	movs	r3, #0
 8013104:	653b      	str	r3, [r7, #80]	; 0x50
	ADC2_handle.Init.ScanConvMode = ENABLE;
 8013106:	2301      	movs	r3, #1
 8013108:	65bb      	str	r3, [r7, #88]	; 0x58
	HAL_ADC_Init(&ADC2_handle);
 801310a:	f107 0348 	add.w	r3, r7, #72	; 0x48
 801310e:	4618      	mov	r0, r3
 8013110:	f7f3 f8ae 	bl	8006270 <HAL_ADC_Init>
	
	ADC3_handle.Instance = ADC3;
 8013114:	4b17      	ldr	r3, [pc, #92]	; (8013174 <stm32_hw_ADC_init+0x110>)
 8013116:	607b      	str	r3, [r7, #4]
	HAL_ADC_DeInit(&ADC3_handle);
 8013118:	1d3b      	adds	r3, r7, #4
 801311a:	4618      	mov	r0, r3
 801311c:	f7f3 f8d6 	bl	80062cc <HAL_ADC_DeInit>
	ADC3_handle.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8; /* 96M/8 */
 8013120:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 8013124:	60bb      	str	r3, [r7, #8]
	ADC3_handle.Init.ContinuousConvMode = DISABLE;
 8013126:	2300      	movs	r3, #0
 8013128:	61fb      	str	r3, [r7, #28]
	
#ifdef DATAALIGN_LEFT
	ADC3_handle.Init.DataAlign = ADC_DATAALIGN_LEFT;
#else
	ADC3_handle.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 801312a:	2300      	movs	r3, #0
 801312c:	613b      	str	r3, [r7, #16]
#endif
#if 1
	ADC3_handle.Init.DiscontinuousConvMode = DISABLE;
 801312e:	2300      	movs	r3, #0
 8013130:	62bb      	str	r3, [r7, #40]	; 0x28
	ADC3_handle.Init.DMAContinuousRequests = DISABLE;
 8013132:	2300      	movs	r3, #0
 8013134:	623b      	str	r3, [r7, #32]
	ADC3_handle.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 8013136:	2300      	movs	r3, #0
 8013138:	61bb      	str	r3, [r7, #24]
	ADC3_handle.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 801313a:	4b0c      	ldr	r3, [pc, #48]	; (801316c <stm32_hw_ADC_init+0x108>)
 801313c:	633b      	str	r3, [r7, #48]	; 0x30
	ADC3_handle.Init.NbrOfConversion = 1;
 801313e:	2301      	movs	r3, #1
 8013140:	627b      	str	r3, [r7, #36]	; 0x24
	ADC3_handle.Init.NbrOfDiscConversion = 0;
 8013142:	2300      	movs	r3, #0
 8013144:	62fb      	str	r3, [r7, #44]	; 0x2c
	#endif
	ADC3_handle.Init.Resolution = ADC_RESOLUTION_12B;
 8013146:	2300      	movs	r3, #0
 8013148:	60fb      	str	r3, [r7, #12]
	ADC3_handle.Init.ScanConvMode = ENABLE;
 801314a:	2301      	movs	r3, #1
 801314c:	617b      	str	r3, [r7, #20]
	HAL_ADC_Init(&ADC3_handle);
 801314e:	1d3b      	adds	r3, r7, #4
 8013150:	4618      	mov	r0, r3
 8013152:	f7f3 f88d 	bl	8006270 <HAL_ADC_Init>

	ADC_CalibrationAll();
 8013156:	f7ff fe6d 	bl	8012e34 <ADC_CalibrationAll>
	return 1;
 801315a:	2301      	movs	r3, #1
}
 801315c:	4618      	mov	r0, r3
 801315e:	37d0      	adds	r7, #208	; 0xd0
 8013160:	46bd      	mov	sp, r7
 8013162:	bd80      	pop	{r7, pc}
 8013164:	200128e4 	.word	0x200128e4
 8013168:	40012000 	.word	0x40012000
 801316c:	0f000001 	.word	0x0f000001
 8013170:	40012100 	.word	0x40012100
 8013174:	40012200 	.word	0x40012200

08013178 <HAL_TIM_PeriodElapsedCallback>:


#elif defined(TIMER5_HANDLES_ENCODER)

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 8013178:	b480      	push	{r7}
 801317a:	b083      	sub	sp, #12
 801317c:	af00      	add	r7, sp, #0
 801317e:	6078      	str	r0, [r7, #4]
	if (hEncoder_Timer_Overflow != U16_MAX)	
 8013180:	4b09      	ldr	r3, [pc, #36]	; (80131a8 <HAL_TIM_PeriodElapsedCallback+0x30>)
 8013182:	881b      	ldrh	r3, [r3, #0]
 8013184:	b29b      	uxth	r3, r3
 8013186:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801318a:	4293      	cmp	r3, r2
 801318c:	d006      	beq.n	801319c <HAL_TIM_PeriodElapsedCallback+0x24>
	{
	   hEncoder_Timer_Overflow++;
 801318e:	4b06      	ldr	r3, [pc, #24]	; (80131a8 <HAL_TIM_PeriodElapsedCallback+0x30>)
 8013190:	881b      	ldrh	r3, [r3, #0]
 8013192:	b29b      	uxth	r3, r3
 8013194:	3301      	adds	r3, #1
 8013196:	b29a      	uxth	r2, r3
 8013198:	4b03      	ldr	r3, [pc, #12]	; (80131a8 <HAL_TIM_PeriodElapsedCallback+0x30>)
 801319a:	801a      	strh	r2, [r3, #0]
	}
}
 801319c:	370c      	adds	r7, #12
 801319e:	46bd      	mov	sp, r7
 80131a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80131a4:	4770      	bx	lr
 80131a6:	bf00      	nop
 80131a8:	20010868 	.word	0x20010868

080131ac <TIM5_IRQHandler>:

void TIM5_IRQHandler(void)
{
 80131ac:	b580      	push	{r7, lr}
 80131ae:	b090      	sub	sp, #64	; 0x40
 80131b0:	af00      	add	r7, sp, #0
	TIM_HandleTypeDef htim; 
	
	rt_interrupt_enter();
 80131b2:	f003 f99d 	bl	80164f0 <rt_interrupt_enter>
	htim.Instance = TIM5;
 80131b6:	4b05      	ldr	r3, [pc, #20]	; (80131cc <TIM5_IRQHandler+0x20>)
 80131b8:	607b      	str	r3, [r7, #4]
	HAL_TIM_IRQHandler(&htim);
 80131ba:	1d3b      	adds	r3, r7, #4
 80131bc:	4618      	mov	r0, r3
 80131be:	f7fb f80d 	bl	800e1dc <HAL_TIM_IRQHandler>
	rt_interrupt_leave();
 80131c2:	f003 f9ab 	bl	801651c <rt_interrupt_leave>
}
 80131c6:	3740      	adds	r7, #64	; 0x40
 80131c8:	46bd      	mov	sp, r7
 80131ca:	bd80      	pop	{r7, pc}
 80131cc:	40000c00 	.word	0x40000c00

080131d0 <GetCounterValue>:




extern u16 GetCounterValue(TIM_TypeDef *TIMx)
{
 80131d0:	b480      	push	{r7}
 80131d2:	b083      	sub	sp, #12
 80131d4:	af00      	add	r7, sp, #0
 80131d6:	6078      	str	r0, [r7, #4]
	return(TIMx->CNT);
 80131d8:	687b      	ldr	r3, [r7, #4]
 80131da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80131dc:	b29b      	uxth	r3, r3
}
 80131de:	4618      	mov	r0, r3
 80131e0:	370c      	adds	r7, #12
 80131e2:	46bd      	mov	sp, r7
 80131e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80131e8:	4770      	bx	lr
 80131ea:	bf00      	nop

080131ec <HAL_TIM_Encoder_MspInit>:
  *           - NVIC configuration for UART interrupt request enable
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
{
 80131ec:	b580      	push	{r7, lr}
 80131ee:	b08a      	sub	sp, #40	; 0x28
 80131f0:	af00      	add	r7, sp, #0
 80131f2:	6078      	str	r0, [r7, #4]
	GPIO_InitTypeDef GPIO_Init;

    /* Enable GPIO clock */
	TIM5_GPIOH_CLK_ENABLE();
 80131f4:	4a19      	ldr	r2, [pc, #100]	; (801325c <HAL_TIM_Encoder_MspInit+0x70>)
 80131f6:	4b19      	ldr	r3, [pc, #100]	; (801325c <HAL_TIM_Encoder_MspInit+0x70>)
 80131f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80131fa:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80131fe:	6313      	str	r3, [r2, #48]	; 0x30
 8013200:	4b16      	ldr	r3, [pc, #88]	; (801325c <HAL_TIM_Encoder_MspInit+0x70>)
 8013202:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013204:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8013208:	613b      	str	r3, [r7, #16]
 801320a:	693b      	ldr	r3, [r7, #16]
    /* Enable TIMx clock */
    TIM5_CLK_ENABLE();
 801320c:	4a13      	ldr	r2, [pc, #76]	; (801325c <HAL_TIM_Encoder_MspInit+0x70>)
 801320e:	4b13      	ldr	r3, [pc, #76]	; (801325c <HAL_TIM_Encoder_MspInit+0x70>)
 8013210:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8013212:	f043 0308 	orr.w	r3, r3, #8
 8013216:	6413      	str	r3, [r2, #64]	; 0x40
 8013218:	4b10      	ldr	r3, [pc, #64]	; (801325c <HAL_TIM_Encoder_MspInit+0x70>)
 801321a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801321c:	f003 0308 	and.w	r3, r3, #8
 8013220:	60fb      	str	r3, [r7, #12]
 8013222:	68fb      	ldr	r3, [r7, #12]

    /* GPIO pin configuration  */
 	GPIO_Init.Pin = QEP1_PIN;
 8013224:	2301      	movs	r3, #1
 8013226:	617b      	str	r3, [r7, #20]
	GPIO_Init.Mode = GPIO_MODE_AF_PP;
 8013228:	2302      	movs	r3, #2
 801322a:	61bb      	str	r3, [r7, #24]
	GPIO_Init.Pull = GPIO_PULLUP;
 801322c:	2301      	movs	r3, #1
 801322e:	61fb      	str	r3, [r7, #28]
	GPIO_Init.Speed = GPIO_SPEED_HIGH;
 8013230:	2303      	movs	r3, #3
 8013232:	623b      	str	r3, [r7, #32]
	GPIO_Init.Alternate = QEP1_AF;
 8013234:	2302      	movs	r3, #2
 8013236:	627b      	str	r3, [r7, #36]	; 0x24
	HAL_GPIO_Init(QEP1_GPIO_PORT,&GPIO_Init);
 8013238:	f107 0314 	add.w	r3, r7, #20
 801323c:	4808      	ldr	r0, [pc, #32]	; (8013260 <HAL_TIM_Encoder_MspInit+0x74>)
 801323e:	4619      	mov	r1, r3
 8013240:	f7f9 fd00 	bl	800cc44 <HAL_GPIO_Init>

	GPIO_Init.Pin = QEP2_PIN;
 8013244:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8013248:	617b      	str	r3, [r7, #20]
	HAL_GPIO_Init(QEP2_GPIO_PORT,&GPIO_Init);
 801324a:	f107 0314 	add.w	r3, r7, #20
 801324e:	4805      	ldr	r0, [pc, #20]	; (8013264 <HAL_TIM_Encoder_MspInit+0x78>)
 8013250:	4619      	mov	r1, r3
 8013252:	f7f9 fcf7 	bl	800cc44 <HAL_GPIO_Init>
}
 8013256:	3728      	adds	r7, #40	; 0x28
 8013258:	46bd      	mov	sp, r7
 801325a:	bd80      	pop	{r7, pc}
 801325c:	40023800 	.word	0x40023800
 8013260:	40020000 	.word	0x40020000
 8013264:	40021c00 	.word	0x40021c00

08013268 <HAL_TIM_Encoder_MspDeInit>:
  *          - Revert GPIO and NVIC configuration to their default state
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
{
 8013268:	b580      	push	{r7, lr}
 801326a:	b082      	sub	sp, #8
 801326c:	af00      	add	r7, sp, #0
 801326e:	6078      	str	r0, [r7, #4]
    /* Reset peripherals */
    TIM5_FORCE_RESET();
 8013270:	4a0f      	ldr	r2, [pc, #60]	; (80132b0 <HAL_TIM_Encoder_MspDeInit+0x48>)
 8013272:	4b0f      	ldr	r3, [pc, #60]	; (80132b0 <HAL_TIM_Encoder_MspDeInit+0x48>)
 8013274:	6a1b      	ldr	r3, [r3, #32]
 8013276:	f043 0308 	orr.w	r3, r3, #8
 801327a:	6213      	str	r3, [r2, #32]
    TIM5_RELEASE_RESET();
 801327c:	4a0c      	ldr	r2, [pc, #48]	; (80132b0 <HAL_TIM_Encoder_MspDeInit+0x48>)
 801327e:	4b0c      	ldr	r3, [pc, #48]	; (80132b0 <HAL_TIM_Encoder_MspDeInit+0x48>)
 8013280:	6a1b      	ldr	r3, [r3, #32]
 8013282:	f023 0308 	bic.w	r3, r3, #8
 8013286:	6213      	str	r3, [r2, #32]

    /* Disable peripherals and GPIO Clocks */
    HAL_GPIO_DeInit(QEP1_GPIO_PORT, QEP1_PIN);
 8013288:	480a      	ldr	r0, [pc, #40]	; (80132b4 <HAL_TIM_Encoder_MspDeInit+0x4c>)
 801328a:	2101      	movs	r1, #1
 801328c:	f7f9 fe80 	bl	800cf90 <HAL_GPIO_DeInit>
    HAL_GPIO_DeInit(QEP2_GPIO_PORT, QEP2_PIN);
 8013290:	4809      	ldr	r0, [pc, #36]	; (80132b8 <HAL_TIM_Encoder_MspDeInit+0x50>)
 8013292:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8013296:	f7f9 fe7b 	bl	800cf90 <HAL_GPIO_DeInit>
	
	HAL_NVIC_SetPriority(TIM5_IRQn, TIM5_IRQ_PREEMPT,TIM5_IRQ_SUB);
 801329a:	2032      	movs	r0, #50	; 0x32
 801329c:	2101      	movs	r1, #1
 801329e:	2200      	movs	r2, #0
 80132a0:	f7f4 ffec 	bl	800827c <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(TIM5_IRQn);
 80132a4:	2032      	movs	r0, #50	; 0x32
 80132a6:	f7f5 f805 	bl	80082b4 <HAL_NVIC_EnableIRQ>
}
 80132aa:	3708      	adds	r7, #8
 80132ac:	46bd      	mov	sp, r7
 80132ae:	bd80      	pop	{r7, pc}
 80132b0:	40023800 	.word	0x40023800
 80132b4:	40020000 	.word	0x40020000
 80132b8:	40021c00 	.word	0x40021c00

080132bc <stm32_hw_QEP_init>:


#define POLENUM (5)
extern int stm32_hw_QEP_init(void)
{
 80132bc:	b580      	push	{r7, lr}
 80132be:	b09a      	sub	sp, #104	; 0x68
 80132c0:	af00      	add	r7, sp, #0
	TIM_HandleTypeDef htim;  
	TIM_Encoder_InitTypeDef sConfig;
	
	htim.Instance = TIM5;
 80132c2:	4b2e      	ldr	r3, [pc, #184]	; (801337c <stm32_hw_QEP_init+0xc0>)
 80132c4:	62fb      	str	r3, [r7, #44]	; 0x2c
	HAL_TIM_Base_DeInit(&htim);
 80132c6:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80132ca:	4618      	mov	r0, r3
 80132cc:	f7fa fd86 	bl	800dddc <HAL_TIM_Base_DeInit>
	HAL_TIM_Encoder_DeInit(&htim);
 80132d0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80132d4:	4618      	mov	r0, r3
 80132d6:	f7fa ff19 	bl	800e10c <HAL_TIM_Encoder_DeInit>
    TIM5_CLK_ENABLE();
 80132da:	4a29      	ldr	r2, [pc, #164]	; (8013380 <stm32_hw_QEP_init+0xc4>)
 80132dc:	4b28      	ldr	r3, [pc, #160]	; (8013380 <stm32_hw_QEP_init+0xc4>)
 80132de:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80132e0:	f043 0308 	orr.w	r3, r3, #8
 80132e4:	6413      	str	r3, [r2, #64]	; 0x40
 80132e6:	4b26      	ldr	r3, [pc, #152]	; (8013380 <stm32_hw_QEP_init+0xc4>)
 80132e8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80132ea:	f003 0308 	and.w	r3, r3, #8
 80132ee:	607b      	str	r3, [r7, #4]
 80132f0:	687b      	ldr	r3, [r7, #4]
	HAL_TIM_Encoder_MspInit(&htim);
 80132f2:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80132f6:	4618      	mov	r0, r3
 80132f8:	f7ff ff78 	bl	80131ec <HAL_TIM_Encoder_MspInit>
	#if 1
	htim.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80132fc:	2300      	movs	r3, #0
 80132fe:	63fb      	str	r3, [r7, #60]	; 0x3c
	htim.Init.CounterMode = TIM_COUNTERMODE_UP;
 8013300:	2300      	movs	r3, #0
 8013302:	637b      	str	r3, [r7, #52]	; 0x34
	htim.Init.Period = (POLENUM*(4*ENCODER_PPR))-1;
 8013304:	f644 73ff 	movw	r3, #20479	; 0x4fff
 8013308:	63bb      	str	r3, [r7, #56]	; 0x38
	htim.Init.Prescaler = 0x0;
 801330a:	2300      	movs	r3, #0
 801330c:	633b      	str	r3, [r7, #48]	; 0x30
	HAL_TIM_IC_Init(&htim);	
 801330e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8013312:	4618      	mov	r0, r3
 8013314:	f7fa fe2c 	bl	800df70 <HAL_TIM_IC_Init>
	
	sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
 8013318:	2303      	movs	r3, #3
 801331a:	60bb      	str	r3, [r7, #8]
	sConfig.IC1Filter = ICx_FILTER;
 801331c:	2308      	movs	r3, #8
 801331e:	61bb      	str	r3, [r7, #24]
	sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
 8013320:	2300      	movs	r3, #0
 8013322:	60fb      	str	r3, [r7, #12]
	sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
 8013324:	2300      	movs	r3, #0
 8013326:	617b      	str	r3, [r7, #20]
	sConfig.IC1Selection = TIM_CCMR1_CC1S_0;//????
 8013328:	2301      	movs	r3, #1
 801332a:	613b      	str	r3, [r7, #16]
	sConfig.IC2Filter = ICx_FILTER;
 801332c:	2308      	movs	r3, #8
 801332e:	62bb      	str	r3, [r7, #40]	; 0x28
	sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
 8013330:	2300      	movs	r3, #0
 8013332:	61fb      	str	r3, [r7, #28]
	sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
 8013334:	2300      	movs	r3, #0
 8013336:	627b      	str	r3, [r7, #36]	; 0x24
	sConfig.IC2Selection = TIM_CCMR1_CC1S_0;
 8013338:	2301      	movs	r3, #1
 801333a:	623b      	str	r3, [r7, #32]
	HAL_TIM_Encoder_Init(&htim,  &sConfig);
 801333c:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 8013340:	f107 0308 	add.w	r3, r7, #8
 8013344:	4610      	mov	r0, r2
 8013346:	4619      	mov	r1, r3
 8013348:	f7fa fe48 	bl	800dfdc <HAL_TIM_Encoder_Init>
	#endif
	__HAL_TIM_ENABLE_IT(&htim, TIM_IT_UPDATE);
 801334c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801334e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8013350:	68d2      	ldr	r2, [r2, #12]
 8013352:	f042 0201 	orr.w	r2, r2, #1
 8013356:	60da      	str	r2, [r3, #12]
	
	HAL_TIM_Encoder_Start(&htim, TIM_CHANNEL_1);
 8013358:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801335c:	4618      	mov	r0, r3
 801335e:	2100      	movs	r1, #0
 8013360:	f7fa ff04 	bl	800e16c <HAL_TIM_Encoder_Start>
	HAL_TIM_Encoder_Start(&htim, TIM_CHANNEL_2);
 8013364:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8013368:	4618      	mov	r0, r3
 801336a:	2104      	movs	r1, #4
 801336c:	f7fa fefe 	bl	800e16c <HAL_TIM_Encoder_Start>
	
    return 0;
 8013370:	2300      	movs	r3, #0
}
 8013372:	4618      	mov	r0, r3
 8013374:	3768      	adds	r7, #104	; 0x68
 8013376:	46bd      	mov	sp, r7
 8013378:	bd80      	pop	{r7, pc}
 801337a:	bf00      	nop
 801337c:	40000c00 	.word	0x40000c00
 8013380:	40023800 	.word	0x40023800

08013384 <HAL_MPU_Disable>:
/**
  * @brief  Disables the MPU
  * @retval None
  */
__STATIC_INLINE void HAL_MPU_Disable(void)
{
 8013384:	b480      	push	{r7}
 8013386:	af00      	add	r7, sp, #0
  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 8013388:	4a07      	ldr	r2, [pc, #28]	; (80133a8 <HAL_MPU_Disable+0x24>)
 801338a:	4b07      	ldr	r3, [pc, #28]	; (80133a8 <HAL_MPU_Disable+0x24>)
 801338c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801338e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8013392:	6253      	str	r3, [r2, #36]	; 0x24
  
  /* Disable the MPU */
  MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;
 8013394:	4a05      	ldr	r2, [pc, #20]	; (80133ac <HAL_MPU_Disable+0x28>)
 8013396:	4b05      	ldr	r3, [pc, #20]	; (80133ac <HAL_MPU_Disable+0x28>)
 8013398:	685b      	ldr	r3, [r3, #4]
 801339a:	f023 0301 	bic.w	r3, r3, #1
 801339e:	6053      	str	r3, [r2, #4]
}
 80133a0:	46bd      	mov	sp, r7
 80133a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80133a6:	4770      	bx	lr
 80133a8:	e000ed00 	.word	0xe000ed00
 80133ac:	e000ed90 	.word	0xe000ed90

080133b0 <HAL_MPU_Enable>:
  *            @arg MPU_PRIVILEGED_DEFAULT
  *            @arg MPU_HFNMI_PRIVDEF
  * @retval None
  */
__STATIC_INLINE void HAL_MPU_Enable(uint32_t MPU_Control)
{
 80133b0:	b480      	push	{r7}
 80133b2:	b083      	sub	sp, #12
 80133b4:	af00      	add	r7, sp, #0
 80133b6:	6078      	str	r0, [r7, #4]
  /* Enable the MPU */
  MPU->CTRL   = MPU_Control | MPU_CTRL_ENABLE_Msk;
 80133b8:	4a07      	ldr	r2, [pc, #28]	; (80133d8 <HAL_MPU_Enable+0x28>)
 80133ba:	687b      	ldr	r3, [r7, #4]
 80133bc:	f043 0301 	orr.w	r3, r3, #1
 80133c0:	6053      	str	r3, [r2, #4]
  
  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 80133c2:	4a06      	ldr	r2, [pc, #24]	; (80133dc <HAL_MPU_Enable+0x2c>)
 80133c4:	4b05      	ldr	r3, [pc, #20]	; (80133dc <HAL_MPU_Enable+0x2c>)
 80133c6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80133c8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80133cc:	6253      	str	r3, [r2, #36]	; 0x24
}
 80133ce:	370c      	adds	r7, #12
 80133d0:	46bd      	mov	sp, r7
 80133d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80133d6:	4770      	bx	lr
 80133d8:	e000ed90 	.word	0xe000ed90
 80133dc:	e000ed00 	.word	0xe000ed00

080133e0 <mpu_init>:

#include "drv_mpu.h"


void mpu_init(void)
{
 80133e0:	b580      	push	{r7, lr}
 80133e2:	b084      	sub	sp, #16
 80133e4:	af00      	add	r7, sp, #0
  MPU_Region_InitTypeDef MPU_InitStruct;
  
  /* Disable the MPU */
  HAL_MPU_Disable();
 80133e6:	f7ff ffcd 	bl	8013384 <HAL_MPU_Disable>

  /* Configure the MPU attributes as WT for SRAM */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 80133ea:	2301      	movs	r3, #1
 80133ec:	703b      	strb	r3, [r7, #0]
  MPU_InitStruct.BaseAddress = 0x20010000;
 80133ee:	4b29      	ldr	r3, [pc, #164]	; (8013494 <mpu_init+0xb4>)
 80133f0:	607b      	str	r3, [r7, #4]
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
 80133f2:	2311      	movs	r3, #17
 80133f4:	723b      	strb	r3, [r7, #8]
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
 80133f6:	2303      	movs	r3, #3
 80133f8:	72fb      	strb	r3, [r7, #11]
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
 80133fa:	2300      	movs	r3, #0
 80133fc:	73fb      	strb	r3, [r7, #15]
  MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
 80133fe:	2301      	movs	r3, #1
 8013400:	73bb      	strb	r3, [r7, #14]
  MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
 8013402:	2300      	movs	r3, #0
 8013404:	737b      	strb	r3, [r7, #13]
  MPU_InitStruct.Number = MPU_REGION_NUMBER0;
 8013406:	2300      	movs	r3, #0
 8013408:	707b      	strb	r3, [r7, #1]
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 801340a:	2300      	movs	r3, #0
 801340c:	72bb      	strb	r3, [r7, #10]
  MPU_InitStruct.SubRegionDisable = 0x00;
 801340e:	2300      	movs	r3, #0
 8013410:	727b      	strb	r3, [r7, #9]
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
 8013412:	2300      	movs	r3, #0
 8013414:	733b      	strb	r3, [r7, #12]

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 8013416:	463b      	mov	r3, r7
 8013418:	4618      	mov	r0, r3
 801341a:	f7f4 ff73 	bl	8008304 <HAL_MPU_ConfigRegion>

  /* Configure the MPU attributes as WB for SDRAM */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 801341e:	2301      	movs	r3, #1
 8013420:	703b      	strb	r3, [r7, #0]
  MPU_InitStruct.BaseAddress = 0xC0000000;
 8013422:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
 8013426:	607b      	str	r3, [r7, #4]
  MPU_InitStruct.Size = MPU_REGION_SIZE_8MB;
 8013428:	2316      	movs	r3, #22
 801342a:	723b      	strb	r3, [r7, #8]
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
 801342c:	2303      	movs	r3, #3
 801342e:	72fb      	strb	r3, [r7, #11]
  MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
 8013430:	2301      	movs	r3, #1
 8013432:	73fb      	strb	r3, [r7, #15]
  MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
 8013434:	2301      	movs	r3, #1
 8013436:	73bb      	strb	r3, [r7, #14]
  MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
 8013438:	2300      	movs	r3, #0
 801343a:	737b      	strb	r3, [r7, #13]
  MPU_InitStruct.Number = MPU_REGION_NUMBER1;
 801343c:	2301      	movs	r3, #1
 801343e:	707b      	strb	r3, [r7, #1]
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 8013440:	2300      	movs	r3, #0
 8013442:	72bb      	strb	r3, [r7, #10]
  MPU_InitStruct.SubRegionDisable = 0x00;
 8013444:	2300      	movs	r3, #0
 8013446:	727b      	strb	r3, [r7, #9]
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
 8013448:	2300      	movs	r3, #0
 801344a:	733b      	strb	r3, [r7, #12]

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 801344c:	463b      	mov	r3, r7
 801344e:	4618      	mov	r0, r3
 8013450:	f7f4 ff58 	bl	8008304 <HAL_MPU_ConfigRegion>

  /* Configure the MPU attributes as none-cache for 1MB SDRAM */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 8013454:	2301      	movs	r3, #1
 8013456:	703b      	strb	r3, [r7, #0]
  MPU_InitStruct.BaseAddress = 0xC0100000;
 8013458:	4b0f      	ldr	r3, [pc, #60]	; (8013498 <mpu_init+0xb8>)
 801345a:	607b      	str	r3, [r7, #4]
  MPU_InitStruct.Size = MPU_REGION_SIZE_1MB;
 801345c:	2313      	movs	r3, #19
 801345e:	723b      	strb	r3, [r7, #8]
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
 8013460:	2303      	movs	r3, #3
 8013462:	72fb      	strb	r3, [r7, #11]
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
 8013464:	2300      	movs	r3, #0
 8013466:	73fb      	strb	r3, [r7, #15]
  MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
 8013468:	2300      	movs	r3, #0
 801346a:	73bb      	strb	r3, [r7, #14]
  MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
 801346c:	2300      	movs	r3, #0
 801346e:	737b      	strb	r3, [r7, #13]
  MPU_InitStruct.Number = MPU_REGION_NUMBER2;
 8013470:	2302      	movs	r3, #2
 8013472:	707b      	strb	r3, [r7, #1]
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 8013474:	2300      	movs	r3, #0
 8013476:	72bb      	strb	r3, [r7, #10]
  MPU_InitStruct.SubRegionDisable = 0x00;
 8013478:	2300      	movs	r3, #0
 801347a:	727b      	strb	r3, [r7, #9]
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
 801347c:	2300      	movs	r3, #0
 801347e:	733b      	strb	r3, [r7, #12]

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 8013480:	463b      	mov	r3, r7
 8013482:	4618      	mov	r0, r3
 8013484:	f7f4 ff3e 	bl	8008304 <HAL_MPU_ConfigRegion>
    
  /* Enable the MPU */
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
 8013488:	2004      	movs	r0, #4
 801348a:	f7ff ff91 	bl	80133b0 <HAL_MPU_Enable>
}
 801348e:	3710      	adds	r7, #16
 8013490:	46bd      	mov	sp, r7
 8013492:	bd80      	pop	{r7, pc}
 8013494:	20010000 	.word	0x20010000
 8013498:	c0100000 	.word	0xc0100000

0801349c <SDRAM_MspInit>:
  * @param  hsdram: SDRAM handle
  * @param  Params
  * @retval None
  */
static void SDRAM_MspInit(SDRAM_HandleTypeDef  *hsdram, void *Params)
{  
 801349c:	b580      	push	{r7, lr}
 801349e:	b090      	sub	sp, #64	; 0x40
 80134a0:	af00      	add	r7, sp, #0
 80134a2:	6078      	str	r0, [r7, #4]
 80134a4:	6039      	str	r1, [r7, #0]
  static DMA_HandleTypeDef dma_handle;
  GPIO_InitTypeDef gpio_init_structure;
  
  /* Enable FMC clock */
  __HAL_RCC_FMC_CLK_ENABLE();
 80134a6:	4a6f      	ldr	r2, [pc, #444]	; (8013664 <SDRAM_MspInit+0x1c8>)
 80134a8:	4b6e      	ldr	r3, [pc, #440]	; (8013664 <SDRAM_MspInit+0x1c8>)
 80134aa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80134ac:	f043 0301 	orr.w	r3, r3, #1
 80134b0:	6393      	str	r3, [r2, #56]	; 0x38
 80134b2:	4b6c      	ldr	r3, [pc, #432]	; (8013664 <SDRAM_MspInit+0x1c8>)
 80134b4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80134b6:	f003 0301 	and.w	r3, r3, #1
 80134ba:	62bb      	str	r3, [r7, #40]	; 0x28
 80134bc:	6abb      	ldr	r3, [r7, #40]	; 0x28
  
  /* Enable chosen DMAx clock */
  SDRAM_DMA_CLK_ENABLE();
 80134be:	4a69      	ldr	r2, [pc, #420]	; (8013664 <SDRAM_MspInit+0x1c8>)
 80134c0:	4b68      	ldr	r3, [pc, #416]	; (8013664 <SDRAM_MspInit+0x1c8>)
 80134c2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80134c4:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80134c8:	6313      	str	r3, [r2, #48]	; 0x30
 80134ca:	4b66      	ldr	r3, [pc, #408]	; (8013664 <SDRAM_MspInit+0x1c8>)
 80134cc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80134ce:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80134d2:	627b      	str	r3, [r7, #36]	; 0x24
 80134d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24

  /* Enable GPIOs clock */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80134d6:	4a63      	ldr	r2, [pc, #396]	; (8013664 <SDRAM_MspInit+0x1c8>)
 80134d8:	4b62      	ldr	r3, [pc, #392]	; (8013664 <SDRAM_MspInit+0x1c8>)
 80134da:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80134dc:	f043 0304 	orr.w	r3, r3, #4
 80134e0:	6313      	str	r3, [r2, #48]	; 0x30
 80134e2:	4b60      	ldr	r3, [pc, #384]	; (8013664 <SDRAM_MspInit+0x1c8>)
 80134e4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80134e6:	f003 0304 	and.w	r3, r3, #4
 80134ea:	623b      	str	r3, [r7, #32]
 80134ec:	6a3b      	ldr	r3, [r7, #32]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80134ee:	4a5d      	ldr	r2, [pc, #372]	; (8013664 <SDRAM_MspInit+0x1c8>)
 80134f0:	4b5c      	ldr	r3, [pc, #368]	; (8013664 <SDRAM_MspInit+0x1c8>)
 80134f2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80134f4:	f043 0308 	orr.w	r3, r3, #8
 80134f8:	6313      	str	r3, [r2, #48]	; 0x30
 80134fa:	4b5a      	ldr	r3, [pc, #360]	; (8013664 <SDRAM_MspInit+0x1c8>)
 80134fc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80134fe:	f003 0308 	and.w	r3, r3, #8
 8013502:	61fb      	str	r3, [r7, #28]
 8013504:	69fb      	ldr	r3, [r7, #28]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8013506:	4a57      	ldr	r2, [pc, #348]	; (8013664 <SDRAM_MspInit+0x1c8>)
 8013508:	4b56      	ldr	r3, [pc, #344]	; (8013664 <SDRAM_MspInit+0x1c8>)
 801350a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801350c:	f043 0310 	orr.w	r3, r3, #16
 8013510:	6313      	str	r3, [r2, #48]	; 0x30
 8013512:	4b54      	ldr	r3, [pc, #336]	; (8013664 <SDRAM_MspInit+0x1c8>)
 8013514:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013516:	f003 0310 	and.w	r3, r3, #16
 801351a:	61bb      	str	r3, [r7, #24]
 801351c:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 801351e:	4a51      	ldr	r2, [pc, #324]	; (8013664 <SDRAM_MspInit+0x1c8>)
 8013520:	4b50      	ldr	r3, [pc, #320]	; (8013664 <SDRAM_MspInit+0x1c8>)
 8013522:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013524:	f043 0320 	orr.w	r3, r3, #32
 8013528:	6313      	str	r3, [r2, #48]	; 0x30
 801352a:	4b4e      	ldr	r3, [pc, #312]	; (8013664 <SDRAM_MspInit+0x1c8>)
 801352c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801352e:	f003 0320 	and.w	r3, r3, #32
 8013532:	617b      	str	r3, [r7, #20]
 8013534:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 8013536:	4a4b      	ldr	r2, [pc, #300]	; (8013664 <SDRAM_MspInit+0x1c8>)
 8013538:	4b4a      	ldr	r3, [pc, #296]	; (8013664 <SDRAM_MspInit+0x1c8>)
 801353a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801353c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8013540:	6313      	str	r3, [r2, #48]	; 0x30
 8013542:	4b48      	ldr	r3, [pc, #288]	; (8013664 <SDRAM_MspInit+0x1c8>)
 8013544:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013546:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801354a:	613b      	str	r3, [r7, #16]
 801354c:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 801354e:	4a45      	ldr	r2, [pc, #276]	; (8013664 <SDRAM_MspInit+0x1c8>)
 8013550:	4b44      	ldr	r3, [pc, #272]	; (8013664 <SDRAM_MspInit+0x1c8>)
 8013552:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013554:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8013558:	6313      	str	r3, [r2, #48]	; 0x30
 801355a:	4b42      	ldr	r3, [pc, #264]	; (8013664 <SDRAM_MspInit+0x1c8>)
 801355c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801355e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8013562:	60fb      	str	r3, [r7, #12]
 8013564:	68fb      	ldr	r3, [r7, #12]
  
  /* Common GPIO configuration */
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 8013566:	2302      	movs	r3, #2
 8013568:	633b      	str	r3, [r7, #48]	; 0x30
  gpio_init_structure.Pull      = GPIO_PULLUP;
 801356a:	2301      	movs	r3, #1
 801356c:	637b      	str	r3, [r7, #52]	; 0x34
  gpio_init_structure.Speed     = GPIO_SPEED_FAST;
 801356e:	2302      	movs	r3, #2
 8013570:	63bb      	str	r3, [r7, #56]	; 0x38
  gpio_init_structure.Alternate = GPIO_AF12_FMC;
 8013572:	230c      	movs	r3, #12
 8013574:	63fb      	str	r3, [r7, #60]	; 0x3c
  
  /* GPIOC configuration */
  gpio_init_structure.Pin   = GPIO_PIN_3;
 8013576:	2308      	movs	r3, #8
 8013578:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_GPIO_Init(GPIOC, &gpio_init_structure);
 801357a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801357e:	483a      	ldr	r0, [pc, #232]	; (8013668 <SDRAM_MspInit+0x1cc>)
 8013580:	4619      	mov	r1, r3
 8013582:	f7f9 fb5f 	bl	800cc44 <HAL_GPIO_Init>

  /* GPIOD configuration */
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_3 | GPIO_PIN_8 | GPIO_PIN_9 |
 8013586:	f24c 730b 	movw	r3, #50955	; 0xc70b
 801358a:	62fb      	str	r3, [r7, #44]	; 0x2c
                              GPIO_PIN_10 | GPIO_PIN_14 | GPIO_PIN_15;
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
 801358c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8013590:	4836      	ldr	r0, [pc, #216]	; (801366c <SDRAM_MspInit+0x1d0>)
 8013592:	4619      	mov	r1, r3
 8013594:	f7f9 fb56 	bl	800cc44 <HAL_GPIO_Init>

  /* GPIOE configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_7| GPIO_PIN_8 | GPIO_PIN_9 |\
 8013598:	f64f 7383 	movw	r3, #65411	; 0xff83
 801359c:	62fb      	str	r3, [r7, #44]	; 0x2c
                              GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 |\
                              GPIO_PIN_15;
  HAL_GPIO_Init(GPIOE, &gpio_init_structure);
 801359e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80135a2:	4833      	ldr	r0, [pc, #204]	; (8013670 <SDRAM_MspInit+0x1d4>)
 80135a4:	4619      	mov	r1, r3
 80135a6:	f7f9 fb4d 	bl	800cc44 <HAL_GPIO_Init>
  
  /* GPIOF configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2| GPIO_PIN_3 | GPIO_PIN_4 |\
 80135aa:	f64f 033f 	movw	r3, #63551	; 0xf83f
 80135ae:	62fb      	str	r3, [r7, #44]	; 0x2c
                              GPIO_PIN_5 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 |\
                              GPIO_PIN_15;
  HAL_GPIO_Init(GPIOF, &gpio_init_structure);
 80135b0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80135b4:	482f      	ldr	r0, [pc, #188]	; (8013674 <SDRAM_MspInit+0x1d8>)
 80135b6:	4619      	mov	r1, r3
 80135b8:	f7f9 fb44 	bl	800cc44 <HAL_GPIO_Init>
  
  /* GPIOG configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4| GPIO_PIN_5 | GPIO_PIN_8 |\
 80135bc:	f248 1333 	movw	r3, #33075	; 0x8133
 80135c0:	62fb      	str	r3, [r7, #44]	; 0x2c
                              GPIO_PIN_15;
  HAL_GPIO_Init(GPIOG, &gpio_init_structure);
 80135c2:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80135c6:	482c      	ldr	r0, [pc, #176]	; (8013678 <SDRAM_MspInit+0x1dc>)
 80135c8:	4619      	mov	r1, r3
 80135ca:	f7f9 fb3b 	bl	800cc44 <HAL_GPIO_Init>

  /* GPIOH configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_3 | GPIO_PIN_5;
 80135ce:	2328      	movs	r3, #40	; 0x28
 80135d0:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_GPIO_Init(GPIOH, &gpio_init_structure); 
 80135d2:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80135d6:	4829      	ldr	r0, [pc, #164]	; (801367c <SDRAM_MspInit+0x1e0>)
 80135d8:	4619      	mov	r1, r3
 80135da:	f7f9 fb33 	bl	800cc44 <HAL_GPIO_Init>
  
  /* Configure common DMA parameters */
  dma_handle.Init.Channel             = SDRAM_DMA_CHANNEL;
 80135de:	4b28      	ldr	r3, [pc, #160]	; (8013680 <SDRAM_MspInit+0x1e4>)
 80135e0:	2200      	movs	r2, #0
 80135e2:	605a      	str	r2, [r3, #4]
  dma_handle.Init.Direction           = DMA_MEMORY_TO_MEMORY;
 80135e4:	4b26      	ldr	r3, [pc, #152]	; (8013680 <SDRAM_MspInit+0x1e4>)
 80135e6:	2280      	movs	r2, #128	; 0x80
 80135e8:	609a      	str	r2, [r3, #8]
  dma_handle.Init.PeriphInc           = DMA_PINC_ENABLE;
 80135ea:	4b25      	ldr	r3, [pc, #148]	; (8013680 <SDRAM_MspInit+0x1e4>)
 80135ec:	f44f 7200 	mov.w	r2, #512	; 0x200
 80135f0:	60da      	str	r2, [r3, #12]
  dma_handle.Init.MemInc              = DMA_MINC_ENABLE;
 80135f2:	4b23      	ldr	r3, [pc, #140]	; (8013680 <SDRAM_MspInit+0x1e4>)
 80135f4:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80135f8:	611a      	str	r2, [r3, #16]
  dma_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 80135fa:	4b21      	ldr	r3, [pc, #132]	; (8013680 <SDRAM_MspInit+0x1e4>)
 80135fc:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8013600:	615a      	str	r2, [r3, #20]
  dma_handle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
 8013602:	4b1f      	ldr	r3, [pc, #124]	; (8013680 <SDRAM_MspInit+0x1e4>)
 8013604:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8013608:	619a      	str	r2, [r3, #24]
  dma_handle.Init.Mode                = DMA_NORMAL;
 801360a:	4b1d      	ldr	r3, [pc, #116]	; (8013680 <SDRAM_MspInit+0x1e4>)
 801360c:	2200      	movs	r2, #0
 801360e:	61da      	str	r2, [r3, #28]
  dma_handle.Init.Priority            = DMA_PRIORITY_HIGH;
 8013610:	4b1b      	ldr	r3, [pc, #108]	; (8013680 <SDRAM_MspInit+0x1e4>)
 8013612:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8013616:	621a      	str	r2, [r3, #32]
  dma_handle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;         
 8013618:	4b19      	ldr	r3, [pc, #100]	; (8013680 <SDRAM_MspInit+0x1e4>)
 801361a:	2200      	movs	r2, #0
 801361c:	625a      	str	r2, [r3, #36]	; 0x24
  dma_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
 801361e:	4b18      	ldr	r3, [pc, #96]	; (8013680 <SDRAM_MspInit+0x1e4>)
 8013620:	2203      	movs	r2, #3
 8013622:	629a      	str	r2, [r3, #40]	; 0x28
  dma_handle.Init.MemBurst            = DMA_MBURST_SINGLE;
 8013624:	4b16      	ldr	r3, [pc, #88]	; (8013680 <SDRAM_MspInit+0x1e4>)
 8013626:	2200      	movs	r2, #0
 8013628:	62da      	str	r2, [r3, #44]	; 0x2c
  dma_handle.Init.PeriphBurst         = DMA_PBURST_SINGLE; 
 801362a:	4b15      	ldr	r3, [pc, #84]	; (8013680 <SDRAM_MspInit+0x1e4>)
 801362c:	2200      	movs	r2, #0
 801362e:	631a      	str	r2, [r3, #48]	; 0x30
  
  dma_handle.Instance = SDRAM_DMA_STREAM;
 8013630:	4b13      	ldr	r3, [pc, #76]	; (8013680 <SDRAM_MspInit+0x1e4>)
 8013632:	4a14      	ldr	r2, [pc, #80]	; (8013684 <SDRAM_MspInit+0x1e8>)
 8013634:	601a      	str	r2, [r3, #0]
  
   /* Associate the DMA handle */
  __HAL_LINKDMA(hsdram, hdma, dma_handle);
 8013636:	687b      	ldr	r3, [r7, #4]
 8013638:	4a11      	ldr	r2, [pc, #68]	; (8013680 <SDRAM_MspInit+0x1e4>)
 801363a:	631a      	str	r2, [r3, #48]	; 0x30
 801363c:	4a10      	ldr	r2, [pc, #64]	; (8013680 <SDRAM_MspInit+0x1e4>)
 801363e:	687b      	ldr	r3, [r7, #4]
 8013640:	6393      	str	r3, [r2, #56]	; 0x38
  
  /* Deinitialize the stream for new transfer */
  HAL_DMA_DeInit(&dma_handle);
 8013642:	480f      	ldr	r0, [pc, #60]	; (8013680 <SDRAM_MspInit+0x1e4>)
 8013644:	f7f4 ff3a 	bl	80084bc <HAL_DMA_DeInit>
  
  /* Configure the DMA stream */
  HAL_DMA_Init(&dma_handle); 
 8013648:	480d      	ldr	r0, [pc, #52]	; (8013680 <SDRAM_MspInit+0x1e4>)
 801364a:	f7f4 fecb 	bl	80083e4 <HAL_DMA_Init>
  
  /* NVIC configuration for DMA transfer complete interrupt */
  HAL_NVIC_SetPriority(SDRAM_DMA_IRQn, SDRAM_DMA_IRQ_PREEMPT, SDRAM_DMA_IRQ_SUB);
 801364e:	2038      	movs	r0, #56	; 0x38
 8013650:	2105      	movs	r1, #5
 8013652:	2200      	movs	r2, #0
 8013654:	f7f4 fe12 	bl	800827c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SDRAM_DMA_IRQn);
 8013658:	2038      	movs	r0, #56	; 0x38
 801365a:	f7f4 fe2b 	bl	80082b4 <HAL_NVIC_EnableIRQ>
}
 801365e:	3740      	adds	r7, #64	; 0x40
 8013660:	46bd      	mov	sp, r7
 8013662:	bd80      	pop	{r7, pc}
 8013664:	40023800 	.word	0x40023800
 8013668:	40020800 	.word	0x40020800
 801366c:	40020c00 	.word	0x40020c00
 8013670:	40021000 	.word	0x40021000
 8013674:	40021400 	.word	0x40021400
 8013678:	40021800 	.word	0x40021800
 801367c:	40021c00 	.word	0x40021c00
 8013680:	200108cc 	.word	0x200108cc
 8013684:	40026410 	.word	0x40026410

08013688 <SDRAM_InitializationSequence>:
  * @brief  Programs the SDRAM device.
  * @param  RefreshCount: SDRAM refresh counter value 
  * @retval None
  */
static void SDRAM_InitializationSequence(uint32_t RefreshCount)
{
 8013688:	b580      	push	{r7, lr}
 801368a:	b084      	sub	sp, #16
 801368c:	af00      	add	r7, sp, #0
 801368e:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpmrd = 0;
 8013690:	2300      	movs	r3, #0
 8013692:	60fb      	str	r3, [r7, #12]
  
  /* Step 1: Configure a clock configuration enable command */
  Command.CommandMode            = FMC_SDRAM_CMD_CLK_ENABLE;
 8013694:	4b2d      	ldr	r3, [pc, #180]	; (801374c <SDRAM_InitializationSequence+0xc4>)
 8013696:	2201      	movs	r2, #1
 8013698:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 801369a:	4b2c      	ldr	r3, [pc, #176]	; (801374c <SDRAM_InitializationSequence+0xc4>)
 801369c:	2210      	movs	r2, #16
 801369e:	605a      	str	r2, [r3, #4]
  Command.AutoRefreshNumber      = 1;
 80136a0:	4b2a      	ldr	r3, [pc, #168]	; (801374c <SDRAM_InitializationSequence+0xc4>)
 80136a2:	2201      	movs	r2, #1
 80136a4:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = 0;
 80136a6:	4b29      	ldr	r3, [pc, #164]	; (801374c <SDRAM_InitializationSequence+0xc4>)
 80136a8:	2200      	movs	r2, #0
 80136aa:	60da      	str	r2, [r3, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 80136ac:	4828      	ldr	r0, [pc, #160]	; (8013750 <SDRAM_InitializationSequence+0xc8>)
 80136ae:	4927      	ldr	r1, [pc, #156]	; (801374c <SDRAM_InitializationSequence+0xc4>)
 80136b0:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80136b4:	f7fa fb46 	bl	800dd44 <HAL_SDRAM_SendCommand>

  /* Step 2: Insert 100 us minimum delay */ 
  /* Inserted delay is equal to 1 ms due to systick time base unit (ms) */
  // HAL_Delay(1);
	/* interrupt is not enable, just to delay some time. */
	for (tmpmrd = 0; tmpmrd < 0xfffff; tmpmrd ++)
 80136b8:	2300      	movs	r3, #0
 80136ba:	60fb      	str	r3, [r7, #12]
 80136bc:	e002      	b.n	80136c4 <SDRAM_InitializationSequence+0x3c>
 80136be:	68fb      	ldr	r3, [r7, #12]
 80136c0:	3301      	adds	r3, #1
 80136c2:	60fb      	str	r3, [r7, #12]
 80136c4:	68fb      	ldr	r3, [r7, #12]
 80136c6:	4a23      	ldr	r2, [pc, #140]	; (8013754 <SDRAM_InitializationSequence+0xcc>)
 80136c8:	4293      	cmp	r3, r2
 80136ca:	d9f8      	bls.n	80136be <SDRAM_InitializationSequence+0x36>
		;

  /* Step 3: Configure a PALL (precharge all) command */ 
  Command.CommandMode            = FMC_SDRAM_CMD_PALL;
 80136cc:	4b1f      	ldr	r3, [pc, #124]	; (801374c <SDRAM_InitializationSequence+0xc4>)
 80136ce:	2202      	movs	r2, #2
 80136d0:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 80136d2:	4b1e      	ldr	r3, [pc, #120]	; (801374c <SDRAM_InitializationSequence+0xc4>)
 80136d4:	2210      	movs	r2, #16
 80136d6:	605a      	str	r2, [r3, #4]
  Command.AutoRefreshNumber      = 1;
 80136d8:	4b1c      	ldr	r3, [pc, #112]	; (801374c <SDRAM_InitializationSequence+0xc4>)
 80136da:	2201      	movs	r2, #1
 80136dc:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = 0;
 80136de:	4b1b      	ldr	r3, [pc, #108]	; (801374c <SDRAM_InitializationSequence+0xc4>)
 80136e0:	2200      	movs	r2, #0
 80136e2:	60da      	str	r2, [r3, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);  
 80136e4:	481a      	ldr	r0, [pc, #104]	; (8013750 <SDRAM_InitializationSequence+0xc8>)
 80136e6:	4919      	ldr	r1, [pc, #100]	; (801374c <SDRAM_InitializationSequence+0xc4>)
 80136e8:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80136ec:	f7fa fb2a 	bl	800dd44 <HAL_SDRAM_SendCommand>
  
  /* Step 4: Configure an Auto Refresh command */ 
  Command.CommandMode            = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 80136f0:	4b16      	ldr	r3, [pc, #88]	; (801374c <SDRAM_InitializationSequence+0xc4>)
 80136f2:	2203      	movs	r2, #3
 80136f4:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 80136f6:	4b15      	ldr	r3, [pc, #84]	; (801374c <SDRAM_InitializationSequence+0xc4>)
 80136f8:	2210      	movs	r2, #16
 80136fa:	605a      	str	r2, [r3, #4]
  Command.AutoRefreshNumber      = 8;
 80136fc:	4b13      	ldr	r3, [pc, #76]	; (801374c <SDRAM_InitializationSequence+0xc4>)
 80136fe:	2208      	movs	r2, #8
 8013700:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = 0;
 8013702:	4b12      	ldr	r3, [pc, #72]	; (801374c <SDRAM_InitializationSequence+0xc4>)
 8013704:	2200      	movs	r2, #0
 8013706:	60da      	str	r2, [r3, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 8013708:	4811      	ldr	r0, [pc, #68]	; (8013750 <SDRAM_InitializationSequence+0xc8>)
 801370a:	4910      	ldr	r1, [pc, #64]	; (801374c <SDRAM_InitializationSequence+0xc4>)
 801370c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8013710:	f7fa fb18 	bl	800dd44 <HAL_SDRAM_SendCommand>
  
  /* Step 5: Program the external memory mode register */
  tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1          |\
 8013714:	f44f 7308 	mov.w	r3, #544	; 0x220
 8013718:	60fb      	str	r3, [r7, #12]
                     SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL   |\
                     SDRAM_MODEREG_CAS_LATENCY_2           |\
                     SDRAM_MODEREG_OPERATING_MODE_STANDARD |\
                     SDRAM_MODEREG_WRITEBURST_MODE_SINGLE;
  
  Command.CommandMode            = FMC_SDRAM_CMD_LOAD_MODE;
 801371a:	4b0c      	ldr	r3, [pc, #48]	; (801374c <SDRAM_InitializationSequence+0xc4>)
 801371c:	2204      	movs	r2, #4
 801371e:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 8013720:	4b0a      	ldr	r3, [pc, #40]	; (801374c <SDRAM_InitializationSequence+0xc4>)
 8013722:	2210      	movs	r2, #16
 8013724:	605a      	str	r2, [r3, #4]
  Command.AutoRefreshNumber      = 1;
 8013726:	4b09      	ldr	r3, [pc, #36]	; (801374c <SDRAM_InitializationSequence+0xc4>)
 8013728:	2201      	movs	r2, #1
 801372a:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = tmpmrd;
 801372c:	68fb      	ldr	r3, [r7, #12]
 801372e:	4a07      	ldr	r2, [pc, #28]	; (801374c <SDRAM_InitializationSequence+0xc4>)
 8013730:	60d3      	str	r3, [r2, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 8013732:	4807      	ldr	r0, [pc, #28]	; (8013750 <SDRAM_InitializationSequence+0xc8>)
 8013734:	4905      	ldr	r1, [pc, #20]	; (801374c <SDRAM_InitializationSequence+0xc4>)
 8013736:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801373a:	f7fa fb03 	bl	800dd44 <HAL_SDRAM_SendCommand>
  
  /* Step 6: Set the refresh rate counter */
  /* Set the device refresh rate */
  HAL_SDRAM_ProgramRefreshRate(&sdramHandle, RefreshCount); 
 801373e:	4804      	ldr	r0, [pc, #16]	; (8013750 <SDRAM_InitializationSequence+0xc8>)
 8013740:	6879      	ldr	r1, [r7, #4]
 8013742:	f7fa fb2b 	bl	800dd9c <HAL_SDRAM_ProgramRefreshRate>
}
 8013746:	3710      	adds	r7, #16
 8013748:	46bd      	mov	sp, r7
 801374a:	bd80      	pop	{r7, pc}
 801374c:	200108bc 	.word	0x200108bc
 8013750:	2001086c 	.word	0x2001086c
 8013754:	000ffffe 	.word	0x000ffffe

08013758 <sdram_hw_init>:
/**
  * @brief  Initializes the SDRAM device.
  * @retval SDRAM status
  */
rt_err_t sdram_hw_init(void)
{ 
 8013758:	b580      	push	{r7, lr}
 801375a:	af00      	add	r7, sp, #0
  static uint8_t sdramstatus = RT_ERROR;
  /* SDRAM device configuration */
  sdramHandle.Instance = FMC_SDRAM_DEVICE;
 801375c:	4b29      	ldr	r3, [pc, #164]	; (8013804 <sdram_hw_init+0xac>)
 801375e:	4a2a      	ldr	r2, [pc, #168]	; (8013808 <sdram_hw_init+0xb0>)
 8013760:	601a      	str	r2, [r3, #0]
    
  /* Timing configuration for 100Mhz as SD clock frequency (System clock is up to 200Mhz) */
  Timing.LoadToActiveDelay    = 2;
 8013762:	4b2a      	ldr	r3, [pc, #168]	; (801380c <sdram_hw_init+0xb4>)
 8013764:	2202      	movs	r2, #2
 8013766:	601a      	str	r2, [r3, #0]
  Timing.ExitSelfRefreshDelay = 7;
 8013768:	4b28      	ldr	r3, [pc, #160]	; (801380c <sdram_hw_init+0xb4>)
 801376a:	2207      	movs	r2, #7
 801376c:	605a      	str	r2, [r3, #4]
  Timing.SelfRefreshTime      = 4;
 801376e:	4b27      	ldr	r3, [pc, #156]	; (801380c <sdram_hw_init+0xb4>)
 8013770:	2204      	movs	r2, #4
 8013772:	609a      	str	r2, [r3, #8]
  Timing.RowCycleDelay        = 7;
 8013774:	4b25      	ldr	r3, [pc, #148]	; (801380c <sdram_hw_init+0xb4>)
 8013776:	2207      	movs	r2, #7
 8013778:	60da      	str	r2, [r3, #12]
  Timing.WriteRecoveryTime    = 2;
 801377a:	4b24      	ldr	r3, [pc, #144]	; (801380c <sdram_hw_init+0xb4>)
 801377c:	2202      	movs	r2, #2
 801377e:	611a      	str	r2, [r3, #16]
  Timing.RPDelay              = 2;
 8013780:	4b22      	ldr	r3, [pc, #136]	; (801380c <sdram_hw_init+0xb4>)
 8013782:	2202      	movs	r2, #2
 8013784:	615a      	str	r2, [r3, #20]
  Timing.RCDDelay             = 2;
 8013786:	4b21      	ldr	r3, [pc, #132]	; (801380c <sdram_hw_init+0xb4>)
 8013788:	2202      	movs	r2, #2
 801378a:	619a      	str	r2, [r3, #24]
  
  sdramHandle.Init.SDBank             = FMC_SDRAM_BANK1;
 801378c:	4b1d      	ldr	r3, [pc, #116]	; (8013804 <sdram_hw_init+0xac>)
 801378e:	2200      	movs	r2, #0
 8013790:	605a      	str	r2, [r3, #4]
  sdramHandle.Init.ColumnBitsNumber   = FMC_SDRAM_COLUMN_BITS_NUM_8;
 8013792:	4b1c      	ldr	r3, [pc, #112]	; (8013804 <sdram_hw_init+0xac>)
 8013794:	2200      	movs	r2, #0
 8013796:	609a      	str	r2, [r3, #8]
  sdramHandle.Init.RowBitsNumber      = FMC_SDRAM_ROW_BITS_NUM_12;
 8013798:	4b1a      	ldr	r3, [pc, #104]	; (8013804 <sdram_hw_init+0xac>)
 801379a:	2204      	movs	r2, #4
 801379c:	60da      	str	r2, [r3, #12]
  sdramHandle.Init.MemoryDataWidth    = SDRAM_MEMORY_WIDTH;
 801379e:	4b19      	ldr	r3, [pc, #100]	; (8013804 <sdram_hw_init+0xac>)
 80137a0:	2210      	movs	r2, #16
 80137a2:	611a      	str	r2, [r3, #16]
  sdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 80137a4:	4b17      	ldr	r3, [pc, #92]	; (8013804 <sdram_hw_init+0xac>)
 80137a6:	2240      	movs	r2, #64	; 0x40
 80137a8:	615a      	str	r2, [r3, #20]
  sdramHandle.Init.CASLatency         = FMC_SDRAM_CAS_LATENCY_2;
 80137aa:	4b16      	ldr	r3, [pc, #88]	; (8013804 <sdram_hw_init+0xac>)
 80137ac:	f44f 7280 	mov.w	r2, #256	; 0x100
 80137b0:	619a      	str	r2, [r3, #24]
  sdramHandle.Init.WriteProtection    = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
 80137b2:	4b14      	ldr	r3, [pc, #80]	; (8013804 <sdram_hw_init+0xac>)
 80137b4:	2200      	movs	r2, #0
 80137b6:	61da      	str	r2, [r3, #28]
  sdramHandle.Init.SDClockPeriod      = SDCLOCK_PERIOD;
 80137b8:	4b12      	ldr	r3, [pc, #72]	; (8013804 <sdram_hw_init+0xac>)
 80137ba:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80137be:	621a      	str	r2, [r3, #32]
  sdramHandle.Init.ReadBurst          = FMC_SDRAM_RBURST_ENABLE;
 80137c0:	4b10      	ldr	r3, [pc, #64]	; (8013804 <sdram_hw_init+0xac>)
 80137c2:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80137c6:	625a      	str	r2, [r3, #36]	; 0x24
  sdramHandle.Init.ReadPipeDelay      = FMC_SDRAM_RPIPE_DELAY_0;
 80137c8:	4b0e      	ldr	r3, [pc, #56]	; (8013804 <sdram_hw_init+0xac>)
 80137ca:	2200      	movs	r2, #0
 80137cc:	629a      	str	r2, [r3, #40]	; 0x28
  
  /* SDRAM controller initialization */

  SDRAM_MspInit(&sdramHandle, NULL); /* __weak function can be rewritten by the application */
 80137ce:	480d      	ldr	r0, [pc, #52]	; (8013804 <sdram_hw_init+0xac>)
 80137d0:	2100      	movs	r1, #0
 80137d2:	f7ff fe63 	bl	801349c <SDRAM_MspInit>

  if(HAL_SDRAM_Init(&sdramHandle, &Timing) != HAL_OK)
 80137d6:	480b      	ldr	r0, [pc, #44]	; (8013804 <sdram_hw_init+0xac>)
 80137d8:	490c      	ldr	r1, [pc, #48]	; (801380c <sdram_hw_init+0xb4>)
 80137da:	f7fa fa73 	bl	800dcc4 <HAL_SDRAM_Init>
 80137de:	4603      	mov	r3, r0
 80137e0:	2b00      	cmp	r3, #0
 80137e2:	d003      	beq.n	80137ec <sdram_hw_init+0x94>
  {
    sdramstatus = RT_ERROR;
 80137e4:	4b0a      	ldr	r3, [pc, #40]	; (8013810 <sdram_hw_init+0xb8>)
 80137e6:	2201      	movs	r2, #1
 80137e8:	701a      	strb	r2, [r3, #0]
 80137ea:	e002      	b.n	80137f2 <sdram_hw_init+0x9a>
  }
  else
  {
    sdramstatus = RT_EOK;
 80137ec:	4b08      	ldr	r3, [pc, #32]	; (8013810 <sdram_hw_init+0xb8>)
 80137ee:	2200      	movs	r2, #0
 80137f0:	701a      	strb	r2, [r3, #0]
  }
  
  /* SDRAM initialization sequence */
  SDRAM_InitializationSequence(REFRESH_COUNT);
 80137f2:	f240 6003 	movw	r0, #1539	; 0x603
 80137f6:	f7ff ff47 	bl	8013688 <SDRAM_InitializationSequence>
  
  return sdramstatus;
 80137fa:	4b05      	ldr	r3, [pc, #20]	; (8013810 <sdram_hw_init+0xb8>)
 80137fc:	781b      	ldrb	r3, [r3, #0]
}
 80137fe:	4618      	mov	r0, r3
 8013800:	bd80      	pop	{r7, pc}
 8013802:	bf00      	nop
 8013804:	2001086c 	.word	0x2001086c
 8013808:	a0000140 	.word	0xa0000140
 801380c:	200108a0 	.word	0x200108a0
 8013810:	20010018 	.word	0x20010018

08013814 <DMA2_Stream0_IRQHandler>:
/**
  * @brief  Handles SDRAM DMA transfer interrupt request.
  * @retval None
  */
void SDRAM_DMA_IRQHandler(void)
{
 8013814:	b580      	push	{r7, lr}
 8013816:	af00      	add	r7, sp, #0
  HAL_DMA_IRQHandler(sdramHandle.hdma); 
 8013818:	4b02      	ldr	r3, [pc, #8]	; (8013824 <DMA2_Stream0_IRQHandler+0x10>)
 801381a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801381c:	4618      	mov	r0, r3
 801381e:	f7f6 f8ad 	bl	800997c <HAL_DMA_IRQHandler>
}
 8013822:	bd80      	pop	{r7, pc}
 8013824:	2001086c 	.word	0x2001086c

08013828 <HAL_TIMEx_BreakCallback>:
#include "MC_Globals.h"

#define ENC_COUNTER_RESET   (u8) 0

void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 8013828:	b580      	push	{r7, lr}
 801382a:	b082      	sub	sp, #8
 801382c:	af00      	add	r7, sp, #0
 801382e:	6078      	str	r0, [r7, #4]
	if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8013830:	687b      	ldr	r3, [r7, #4]
 8013832:	681b      	ldr	r3, [r3, #0]
 8013834:	691b      	ldr	r3, [r3, #16]
 8013836:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801383a:	2b00      	cmp	r3, #0
 801383c:	d003      	beq.n	8013846 <HAL_TIMEx_BreakCallback+0x1e>
	{
		rt_kprintf(" BREAK1 is triggered\r\n");
 801383e:	480a      	ldr	r0, [pc, #40]	; (8013868 <HAL_TIMEx_BreakCallback+0x40>)
 8013840:	f003 fc66 	bl	8017110 <rt_kprintf>
 8013844:	e00d      	b.n	8013862 <HAL_TIMEx_BreakCallback+0x3a>
		  //MCL_SetFault(OVER_CURRENT);
	}
	else if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8013846:	687b      	ldr	r3, [r7, #4]
 8013848:	681b      	ldr	r3, [r3, #0]
 801384a:	691b      	ldr	r3, [r3, #16]
 801384c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8013850:	2b00      	cmp	r3, #0
 8013852:	d003      	beq.n	801385c <HAL_TIMEx_BreakCallback+0x34>
	{
		rt_kprintf(" BREAK2 is triggered\r\n");
 8013854:	4805      	ldr	r0, [pc, #20]	; (801386c <HAL_TIMEx_BreakCallback+0x44>)
 8013856:	f003 fc5b 	bl	8017110 <rt_kprintf>
 801385a:	e002      	b.n	8013862 <HAL_TIMEx_BreakCallback+0x3a>
		  //MCL_SetFault(OVER_CURRENT);
	}
	else 
	{
		rt_kprintf("TIM8 is triggered\r\n");
 801385c:	4804      	ldr	r0, [pc, #16]	; (8013870 <HAL_TIMEx_BreakCallback+0x48>)
 801385e:	f003 fc57 	bl	8017110 <rt_kprintf>
	}

}
 8013862:	3708      	adds	r7, #8
 8013864:	46bd      	mov	sp, r7
 8013866:	bd80      	pop	{r7, pc}
 8013868:	080288dc 	.word	0x080288dc
 801386c:	080288f4 	.word	0x080288f4
 8013870:	0802890c 	.word	0x0802890c

08013874 <TIM8_BRK_TIM12_IRQHandler>:


void TIM8_BRK_TIM12_IRQHandler(void)
{
 8013874:	b580      	push	{r7, lr}
 8013876:	b090      	sub	sp, #64	; 0x40
 8013878:	af00      	add	r7, sp, #0
	TIM_HandleTypeDef	 TimHandle;
	
	/* Set TIMx instance */
	
	/*enter interrupt */
	rt_interrupt_enter();
 801387a:	f002 fe39 	bl	80164f0 <rt_interrupt_enter>
	
	TimHandle.Instance = TIM8;
 801387e:	4b05      	ldr	r3, [pc, #20]	; (8013894 <TIM8_BRK_TIM12_IRQHandler+0x20>)
 8013880:	607b      	str	r3, [r7, #4]
	HAL_TIM_IRQHandler(&TimHandle);
 8013882:	1d3b      	adds	r3, r7, #4
 8013884:	4618      	mov	r0, r3
 8013886:	f7fa fca9 	bl	800e1dc <HAL_TIM_IRQHandler>
		
    /* leave interrupt */
    rt_interrupt_leave();
 801388a:	f002 fe47 	bl	801651c <rt_interrupt_leave>

}
 801388e:	3740      	adds	r7, #64	; 0x40
 8013890:	46bd      	mov	sp, r7
 8013892:	bd80      	pop	{r7, pc}
 8013894:	40010400 	.word	0x40010400

08013898 <TIM8_UP_TIM13_IRQHandler>:

void TIM8_UP_TIM13_IRQHandler(void)
{
 8013898:	b580      	push	{r7, lr}
 801389a:	b090      	sub	sp, #64	; 0x40
 801389c:	af00      	add	r7, sp, #0
	TIM_HandleTypeDef	 TimHandle;
	rt_interrupt_enter();
 801389e:	f002 fe27 	bl	80164f0 <rt_interrupt_enter>
	HAL_GPIO_WritePin(GPIOI,GPIO_PIN_3, GPIO_PIN_SET);
 80138a2:	480a      	ldr	r0, [pc, #40]	; (80138cc <TIM8_UP_TIM13_IRQHandler+0x34>)
 80138a4:	2108      	movs	r1, #8
 80138a6:	2201      	movs	r2, #1
 80138a8:	f7f9 fc7c 	bl	800d1a4 <HAL_GPIO_WritePin>
	TimHandle.Instance = TIM8;
 80138ac:	4b08      	ldr	r3, [pc, #32]	; (80138d0 <TIM8_UP_TIM13_IRQHandler+0x38>)
 80138ae:	607b      	str	r3, [r7, #4]
	HAL_TIM_IRQHandler(&TimHandle);
 80138b0:	1d3b      	adds	r3, r7, #4
 80138b2:	4618      	mov	r0, r3
 80138b4:	f7fa fc92 	bl	800e1dc <HAL_TIM_IRQHandler>
	HAL_GPIO_WritePin(GPIOI,GPIO_PIN_3, GPIO_PIN_RESET);
 80138b8:	4804      	ldr	r0, [pc, #16]	; (80138cc <TIM8_UP_TIM13_IRQHandler+0x34>)
 80138ba:	2108      	movs	r1, #8
 80138bc:	2200      	movs	r2, #0
 80138be:	f7f9 fc71 	bl	800d1a4 <HAL_GPIO_WritePin>
    /* leave interrupt */
    rt_interrupt_leave();
 80138c2:	f002 fe2b 	bl	801651c <rt_interrupt_leave>
}
 80138c6:	3740      	adds	r7, #64	; 0x40
 80138c8:	46bd      	mov	sp, r7
 80138ca:	bd80      	pop	{r7, pc}
 80138cc:	40022000 	.word	0x40022000
 80138d0:	40010400 	.word	0x40010400

080138d4 <SetDutyCycles>:
	TIMx->CNT = ENC_COUNTER_RESET;

}

extern void SetDutyCycles(TIM_TypeDef *TIMx, u16 hTimePhA, u16 hTimePhB, u16 hTimePhC)
{
 80138d4:	b480      	push	{r7}
 80138d6:	b085      	sub	sp, #20
 80138d8:	af00      	add	r7, sp, #0
 80138da:	60f8      	str	r0, [r7, #12]
 80138dc:	4608      	mov	r0, r1
 80138de:	4611      	mov	r1, r2
 80138e0:	461a      	mov	r2, r3
 80138e2:	4603      	mov	r3, r0
 80138e4:	817b      	strh	r3, [r7, #10]
 80138e6:	460b      	mov	r3, r1
 80138e8:	813b      	strh	r3, [r7, #8]
 80138ea:	4613      	mov	r3, r2
 80138ec:	80fb      	strh	r3, [r7, #6]
	TIMx->CCR1 = hTimePhA;
 80138ee:	897a      	ldrh	r2, [r7, #10]
 80138f0:	68fb      	ldr	r3, [r7, #12]
 80138f2:	635a      	str	r2, [r3, #52]	; 0x34
	TIMx->CCR2 = hTimePhB;
 80138f4:	893a      	ldrh	r2, [r7, #8]
 80138f6:	68fb      	ldr	r3, [r7, #12]
 80138f8:	639a      	str	r2, [r3, #56]	; 0x38
	TIMx->CCR3 = hTimePhC;
 80138fa:	88fa      	ldrh	r2, [r7, #6]
 80138fc:	68fb      	ldr	r3, [r7, #12]
 80138fe:	63da      	str	r2, [r3, #60]	; 0x3c
}
 8013900:	3714      	adds	r7, #20
 8013902:	46bd      	mov	sp, r7
 8013904:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013908:	4770      	bx	lr
 801390a:	bf00      	nop

0801390c <PWMOutputsEnable>:


extern void PWMOutputsEnable(TIM_TypeDef *TIMx)
{
 801390c:	b580      	push	{r7, lr}
 801390e:	b082      	sub	sp, #8
 8013910:	af00      	add	r7, sp, #0
 8013912:	6078      	str	r0, [r7, #4]
	TIMx->BDTR |= TIM_BDTR_MOE;
 8013914:	687b      	ldr	r3, [r7, #4]
 8013916:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8013918:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
 801391c:	687b      	ldr	r3, [r7, #4]
 801391e:	645a      	str	r2, [r3, #68]	; 0x44
	HAL_GPIO_WritePin(OCDRELEASE_PORT,OCDRELEASE_PIN,GPIO_PIN_SET);
 8013920:	4808      	ldr	r0, [pc, #32]	; (8013944 <PWMOutputsEnable+0x38>)
 8013922:	f44f 7180 	mov.w	r1, #256	; 0x100
 8013926:	2201      	movs	r2, #1
 8013928:	f7f9 fc3c 	bl	800d1a4 <HAL_GPIO_WritePin>
	rt_thread_delay(20);
 801392c:	2014      	movs	r0, #20
 801392e:	f004 fed3 	bl	80186d8 <rt_thread_delay>
	HAL_GPIO_WritePin(OCDRELEASE_PORT,OCDRELEASE_PIN,GPIO_PIN_RESET);
 8013932:	4804      	ldr	r0, [pc, #16]	; (8013944 <PWMOutputsEnable+0x38>)
 8013934:	f44f 7180 	mov.w	r1, #256	; 0x100
 8013938:	2200      	movs	r2, #0
 801393a:	f7f9 fc33 	bl	800d1a4 <HAL_GPIO_WritePin>
}
 801393e:	3708      	adds	r7, #8
 8013940:	46bd      	mov	sp, r7
 8013942:	bd80      	pop	{r7, pc}
 8013944:	40020000 	.word	0x40020000

08013948 <PWMOutputsDisable>:


extern void PWMOutputsDisable(TIM_TypeDef *TIMx)
{
 8013948:	b480      	push	{r7}
 801394a:	b083      	sub	sp, #12
 801394c:	af00      	add	r7, sp, #0
 801394e:	6078      	str	r0, [r7, #4]
	TIMx->BDTR &= (~TIM_BDTR_MOE);
 8013950:	687b      	ldr	r3, [r7, #4]
 8013952:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8013954:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
 8013958:	687b      	ldr	r3, [r7, #4]
 801395a:	645a      	str	r2, [r3, #68]	; 0x44
}
 801395c:	370c      	adds	r7, #12
 801395e:	46bd      	mov	sp, r7
 8013960:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013964:	4770      	bx	lr
 8013966:	bf00      	nop

08013968 <HAL_TIM_PWM_MspInit>:
  *           - NVIC configuration for UART interrupt request enable
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
{
 8013968:	b580      	push	{r7, lr}
 801396a:	b08e      	sub	sp, #56	; 0x38
 801396c:	af00      	add	r7, sp, #0
 801396e:	6078      	str	r0, [r7, #4]
	GPIO_InitTypeDef GPIO_Init;
    if (htim->Instance == TIM8)
 8013970:	687b      	ldr	r3, [r7, #4]
 8013972:	681b      	ldr	r3, [r3, #0]
 8013974:	4a47      	ldr	r2, [pc, #284]	; (8013a94 <HAL_TIM_PWM_MspInit+0x12c>)
 8013976:	4293      	cmp	r3, r2
 8013978:	f040 8089 	bne.w	8013a8e <HAL_TIM_PWM_MspInit+0x126>
    {
        /* Enable GPIO clock */
        TIM8_GPIOA_CLK_ENABLE();
 801397c:	4a46      	ldr	r2, [pc, #280]	; (8013a98 <HAL_TIM_PWM_MspInit+0x130>)
 801397e:	4b46      	ldr	r3, [pc, #280]	; (8013a98 <HAL_TIM_PWM_MspInit+0x130>)
 8013980:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013982:	f043 0301 	orr.w	r3, r3, #1
 8013986:	6313      	str	r3, [r2, #48]	; 0x30
 8013988:	4b43      	ldr	r3, [pc, #268]	; (8013a98 <HAL_TIM_PWM_MspInit+0x130>)
 801398a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801398c:	f003 0301 	and.w	r3, r3, #1
 8013990:	623b      	str	r3, [r7, #32]
 8013992:	6a3b      	ldr	r3, [r7, #32]
        TIM8_GPIOB_CLK_ENABLE();
 8013994:	4a40      	ldr	r2, [pc, #256]	; (8013a98 <HAL_TIM_PWM_MspInit+0x130>)
 8013996:	4b40      	ldr	r3, [pc, #256]	; (8013a98 <HAL_TIM_PWM_MspInit+0x130>)
 8013998:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801399a:	f043 0302 	orr.w	r3, r3, #2
 801399e:	6313      	str	r3, [r2, #48]	; 0x30
 80139a0:	4b3d      	ldr	r3, [pc, #244]	; (8013a98 <HAL_TIM_PWM_MspInit+0x130>)
 80139a2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80139a4:	f003 0302 	and.w	r3, r3, #2
 80139a8:	61fb      	str	r3, [r7, #28]
 80139aa:	69fb      	ldr	r3, [r7, #28]
		TIM8_GPIOC_CLK_ENABLE();
 80139ac:	4a3a      	ldr	r2, [pc, #232]	; (8013a98 <HAL_TIM_PWM_MspInit+0x130>)
 80139ae:	4b3a      	ldr	r3, [pc, #232]	; (8013a98 <HAL_TIM_PWM_MspInit+0x130>)
 80139b0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80139b2:	f043 0304 	orr.w	r3, r3, #4
 80139b6:	6313      	str	r3, [r2, #48]	; 0x30
 80139b8:	4b37      	ldr	r3, [pc, #220]	; (8013a98 <HAL_TIM_PWM_MspInit+0x130>)
 80139ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80139bc:	f003 0304 	and.w	r3, r3, #4
 80139c0:	61bb      	str	r3, [r7, #24]
 80139c2:	69bb      	ldr	r3, [r7, #24]
        TIM8_GPIOH_CLK_ENABLE();
 80139c4:	4a34      	ldr	r2, [pc, #208]	; (8013a98 <HAL_TIM_PWM_MspInit+0x130>)
 80139c6:	4b34      	ldr	r3, [pc, #208]	; (8013a98 <HAL_TIM_PWM_MspInit+0x130>)
 80139c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80139ca:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80139ce:	6313      	str	r3, [r2, #48]	; 0x30
 80139d0:	4b31      	ldr	r3, [pc, #196]	; (8013a98 <HAL_TIM_PWM_MspInit+0x130>)
 80139d2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80139d4:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80139d8:	617b      	str	r3, [r7, #20]
 80139da:	697b      	ldr	r3, [r7, #20]
		TIM8_GPIOI_CLK_ENABLE();
 80139dc:	4a2e      	ldr	r2, [pc, #184]	; (8013a98 <HAL_TIM_PWM_MspInit+0x130>)
 80139de:	4b2e      	ldr	r3, [pc, #184]	; (8013a98 <HAL_TIM_PWM_MspInit+0x130>)
 80139e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80139e2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80139e6:	6313      	str	r3, [r2, #48]	; 0x30
 80139e8:	4b2b      	ldr	r3, [pc, #172]	; (8013a98 <HAL_TIM_PWM_MspInit+0x130>)
 80139ea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80139ec:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80139f0:	613b      	str	r3, [r7, #16]
 80139f2:	693b      	ldr	r3, [r7, #16]

        /* Enable TIMx clock */
        TIM8_CLK_ENABLE();
 80139f4:	4a28      	ldr	r2, [pc, #160]	; (8013a98 <HAL_TIM_PWM_MspInit+0x130>)
 80139f6:	4b28      	ldr	r3, [pc, #160]	; (8013a98 <HAL_TIM_PWM_MspInit+0x130>)
 80139f8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80139fa:	f043 0302 	orr.w	r3, r3, #2
 80139fe:	6453      	str	r3, [r2, #68]	; 0x44
 8013a00:	4b25      	ldr	r3, [pc, #148]	; (8013a98 <HAL_TIM_PWM_MspInit+0x130>)
 8013a02:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8013a04:	f003 0302 	and.w	r3, r3, #2
 8013a08:	60fb      	str	r3, [r7, #12]
 8013a0a:	68fb      	ldr	r3, [r7, #12]

        /* GPIO pin configuration  */
	 	GPIO_Init.Pin = PWMWP_PIN | PWMVP_PIN | PWMBREAK_PIN;
 8013a0c:	f44f 7330 	mov.w	r3, #704	; 0x2c0
 8013a10:	627b      	str	r3, [r7, #36]	; 0x24
		GPIO_Init.Mode = GPIO_MODE_AF_PP;
 8013a12:	2302      	movs	r3, #2
 8013a14:	62bb      	str	r3, [r7, #40]	; 0x28
		GPIO_Init.Pull = GPIO_PULLUP;
 8013a16:	2301      	movs	r3, #1
 8013a18:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_Init.Speed = GPIO_SPEED_LOW;
 8013a1a:	2300      	movs	r3, #0
 8013a1c:	633b      	str	r3, [r7, #48]	; 0x30
		GPIO_Init.Alternate = PWMWP_AF;
 8013a1e:	2303      	movs	r3, #3
 8013a20:	637b      	str	r3, [r7, #52]	; 0x34
		HAL_GPIO_Init(PWMWP_GPIO_PORT,&GPIO_Init);
 8013a22:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8013a26:	481d      	ldr	r0, [pc, #116]	; (8013a9c <HAL_TIM_PWM_MspInit+0x134>)
 8013a28:	4619      	mov	r1, r3
 8013a2a:	f7f9 f90b 	bl	800cc44 <HAL_GPIO_Init>
		
	 	GPIO_Init.Pin = PWMUP_PIN;
 8013a2e:	2380      	movs	r3, #128	; 0x80
 8013a30:	627b      	str	r3, [r7, #36]	; 0x24
		HAL_GPIO_Init(PWMUP_GPIO_PORT,&GPIO_Init);
 8013a32:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8013a36:	481a      	ldr	r0, [pc, #104]	; (8013aa0 <HAL_TIM_PWM_MspInit+0x138>)
 8013a38:	4619      	mov	r1, r3
 8013a3a:	f7f9 f903 	bl	800cc44 <HAL_GPIO_Init>

		GPIO_Init.Pin = PWMWN_PIN | PWMVN_PIN | PWMUN_PIN;
 8013a3e:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 8013a42:	627b      	str	r3, [r7, #36]	; 0x24
		HAL_GPIO_Init(PWMWN_GPIO_PORT,&GPIO_Init);
 8013a44:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8013a48:	4816      	ldr	r0, [pc, #88]	; (8013aa4 <HAL_TIM_PWM_MspInit+0x13c>)
 8013a4a:	4619      	mov	r1, r3
 8013a4c:	f7f9 f8fa 	bl	800cc44 <HAL_GPIO_Init>

		GPIO_Init.Pin = FAULT1_PIN | FAULT2_PIN;
 8013a50:	2312      	movs	r3, #18
 8013a52:	627b      	str	r3, [r7, #36]	; 0x24
		HAL_GPIO_Init(FAULT1_GPIO_PORT,&GPIO_Init);
 8013a54:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8013a58:	4811      	ldr	r0, [pc, #68]	; (8013aa0 <HAL_TIM_PWM_MspInit+0x138>)
 8013a5a:	4619      	mov	r1, r3
 8013a5c:	f7f9 f8f2 	bl	800cc44 <HAL_GPIO_Init>

		GPIO_Init.Pin = OCDRELEASE_PIN;
 8013a60:	f44f 7380 	mov.w	r3, #256	; 0x100
 8013a64:	627b      	str	r3, [r7, #36]	; 0x24
		GPIO_Init.Mode = GPIO_MODE_OUTPUT_PP;
 8013a66:	2301      	movs	r3, #1
 8013a68:	62bb      	str	r3, [r7, #40]	; 0x28
		GPIO_Init.Pull = GPIO_PULLUP;
 8013a6a:	2301      	movs	r3, #1
 8013a6c:	62fb      	str	r3, [r7, #44]	; 0x2c
		GPIO_Init.Speed = GPIO_SPEED_LOW;
 8013a6e:	2300      	movs	r3, #0
 8013a70:	633b      	str	r3, [r7, #48]	; 0x30
		HAL_GPIO_Init(OCDRELEASE_PORT,&GPIO_Init);
 8013a72:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8013a76:	480c      	ldr	r0, [pc, #48]	; (8013aa8 <HAL_TIM_PWM_MspInit+0x140>)
 8013a78:	4619      	mov	r1, r3
 8013a7a:	f7f9 f8e3 	bl	800cc44 <HAL_GPIO_Init>
        /* NVIC for BRK */
        HAL_NVIC_SetPriority(TIM8_BRK_TIM12_IRQn, TIM8_BRK_TIM12_IRQ_PREEMPT, TIM8_BRK_TIM12_IRQ_SUB );
 8013a7e:	202b      	movs	r0, #43	; 0x2b
 8013a80:	2100      	movs	r1, #0
 8013a82:	2200      	movs	r2, #0
 8013a84:	f7f4 fbfa 	bl	800827c <HAL_NVIC_SetPriority>
        HAL_NVIC_EnableIRQ(TIM8_BRK_TIM12_IRQn);
 8013a88:	202b      	movs	r0, #43	; 0x2b
 8013a8a:	f7f4 fc13 	bl	80082b4 <HAL_NVIC_EnableIRQ>
		#ifdef TIM8UPDATEITENABLE
		HAL_NVIC_SetPriority(TIM8_UP_TIM13_IRQn, TIM8_BRK_TIM12_IRQ_PREEMPT, TIM8_BRK_TIM12_IRQ_SUB );
        HAL_NVIC_EnableIRQ(TIM8_UP_TIM13_IRQn);
		#endif
    }
}
 8013a8e:	3738      	adds	r7, #56	; 0x38
 8013a90:	46bd      	mov	sp, r7
 8013a92:	bd80      	pop	{r7, pc}
 8013a94:	40010400 	.word	0x40010400
 8013a98:	40023800 	.word	0x40023800
 8013a9c:	40020800 	.word	0x40020800
 8013aa0:	40022000 	.word	0x40022000
 8013aa4:	40021c00 	.word	0x40021c00
 8013aa8:	40020000 	.word	0x40020000

08013aac <HAL_TIM_PWM_MspDeInit>:
  *          - Revert GPIO and NVIC configuration to their default state
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
{
 8013aac:	b580      	push	{r7, lr}
 8013aae:	b082      	sub	sp, #8
 8013ab0:	af00      	add	r7, sp, #0
 8013ab2:	6078      	str	r0, [r7, #4]
    if (htim->Instance == TIM8)
 8013ab4:	687b      	ldr	r3, [r7, #4]
 8013ab6:	681b      	ldr	r3, [r3, #0]
 8013ab8:	4a11      	ldr	r2, [pc, #68]	; (8013b00 <HAL_TIM_PWM_MspDeInit+0x54>)
 8013aba:	4293      	cmp	r3, r2
 8013abc:	d11c      	bne.n	8013af8 <HAL_TIM_PWM_MspDeInit+0x4c>
    {
        /* Reset peripherals */
        TIM8_FORCE_RESET();
 8013abe:	4a11      	ldr	r2, [pc, #68]	; (8013b04 <HAL_TIM_PWM_MspDeInit+0x58>)
 8013ac0:	4b10      	ldr	r3, [pc, #64]	; (8013b04 <HAL_TIM_PWM_MspDeInit+0x58>)
 8013ac2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013ac4:	f043 0302 	orr.w	r3, r3, #2
 8013ac8:	6253      	str	r3, [r2, #36]	; 0x24
        TIM8_RELEASE_RESET();
 8013aca:	4a0e      	ldr	r2, [pc, #56]	; (8013b04 <HAL_TIM_PWM_MspDeInit+0x58>)
 8013acc:	4b0d      	ldr	r3, [pc, #52]	; (8013b04 <HAL_TIM_PWM_MspDeInit+0x58>)
 8013ace:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013ad0:	f023 0302 	bic.w	r3, r3, #2
 8013ad4:	6253      	str	r3, [r2, #36]	; 0x24

        /* Disable peripherals and GPIO Clocks */
        HAL_GPIO_DeInit(PWMWP_GPIO_PORT, PWMWP_PIN | PWMVP_PIN | PWMUP_PIN | PWMBREAK_PIN);
 8013ad6:	480c      	ldr	r0, [pc, #48]	; (8013b08 <HAL_TIM_PWM_MspDeInit+0x5c>)
 8013ad8:	f44f 7130 	mov.w	r1, #704	; 0x2c0
 8013adc:	f7f9 fa58 	bl	800cf90 <HAL_GPIO_DeInit>
        HAL_GPIO_DeInit(PWMWN_GPIO_PORT, PWMWN_PIN | PWMVN_PIN | PWMUN_PIN);
 8013ae0:	480a      	ldr	r0, [pc, #40]	; (8013b0c <HAL_TIM_PWM_MspDeInit+0x60>)
 8013ae2:	f44f 4160 	mov.w	r1, #57344	; 0xe000
 8013ae6:	f7f9 fa53 	bl	800cf90 <HAL_GPIO_DeInit>
        HAL_GPIO_DeInit(FAULT1_GPIO_PORT, FAULT1_PIN | FAULT2_PIN);
 8013aea:	4809      	ldr	r0, [pc, #36]	; (8013b10 <HAL_TIM_PWM_MspDeInit+0x64>)
 8013aec:	2112      	movs	r1, #18
 8013aee:	f7f9 fa4f 	bl	800cf90 <HAL_GPIO_DeInit>
		
        HAL_NVIC_DisableIRQ(TIM8_BRK_TIM12_IRQn);
 8013af2:	202b      	movs	r0, #43	; 0x2b
 8013af4:	f7f4 fbec 	bl	80082d0 <HAL_NVIC_DisableIRQ>
		
		#ifdef TIM8UPDATEITENABLE
        HAL_NVIC_DisableIRQ(TIM8_UP_TIM13_IRQn);
		#endif
    }
}
 8013af8:	3708      	adds	r7, #8
 8013afa:	46bd      	mov	sp, r7
 8013afc:	bd80      	pop	{r7, pc}
 8013afe:	bf00      	nop
 8013b00:	40010400 	.word	0x40010400
 8013b04:	40023800 	.word	0x40023800
 8013b08:	40020800 	.word	0x40020800
 8013b0c:	40021c00 	.word	0x40021c00
 8013b10:	40022000 	.word	0x40022000

08013b14 <stm32_hw_tim8_init>:


extern int stm32_hw_tim8_init(void)
{
 8013b14:	b580      	push	{r7, lr}
 8013b16:	b0a6      	sub	sp, #152	; 0x98
 8013b18:	af00      	add	r7, sp, #0
	TIM_OC_InitTypeDef PwmConfig;
	TIM_BreakDeadTimeConfigTypeDef PwmBDTRconfig;
	TIM_MasterConfigTypeDef TIM8MasterConfig;
	char deadtime;
	/* Set TIMx instance */
	TimHandle.Instance = TIM8;
 8013b1a:	4b65      	ldr	r3, [pc, #404]	; (8013cb0 <stm32_hw_tim8_init+0x19c>)
 8013b1c:	65bb      	str	r3, [r7, #88]	; 0x58

	HAL_TIM_PWM_DeInit(&TimHandle);
 8013b1e:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8013b22:	4618      	mov	r0, r3
 8013b24:	f7fa f9c0 	bl	800dea8 <HAL_TIM_PWM_DeInit>

	/* Initialize TIMx peripheral	*/
	TimHandle.Init.Period            = PWM_PERIOD;
 8013b28:	f44f 5316 	mov.w	r3, #9600	; 0x2580
 8013b2c:	667b      	str	r3, [r7, #100]	; 0x64
	TimHandle.Init.Prescaler         = PWM_PRSC;
 8013b2e:	2300      	movs	r3, #0
 8013b30:	65fb      	str	r3, [r7, #92]	; 0x5c
	TimHandle.Init.ClockDivision     = TIM_CLOCKDIVISION_DIV2;
 8013b32:	f44f 7380 	mov.w	r3, #256	; 0x100
 8013b36:	66bb      	str	r3, [r7, #104]	; 0x68
	TimHandle.Init.CounterMode       = TIM_COUNTERMODE_CENTERALIGNED1;
 8013b38:	2320      	movs	r3, #32
 8013b3a:	663b      	str	r3, [r7, #96]	; 0x60
	TimHandle.Init.RepetitionCounter = REP_RATE;
 8013b3c:	2301      	movs	r3, #1
 8013b3e:	66fb      	str	r3, [r7, #108]	; 0x6c
	if (HAL_TIM_PWM_Init(&TimHandle) != HAL_OK)
 8013b40:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8013b44:	4618      	mov	r0, r3
 8013b46:	f7fa f983 	bl	800de50 <HAL_TIM_PWM_Init>
	{
	  /* Initialization Error */
	  /*Error_Handler(); */
	}
	PwmConfig.OCMode = TIM_OCMODE_PWM1;
 8013b4a:	2360      	movs	r3, #96	; 0x60
 8013b4c:	63fb      	str	r3, [r7, #60]	; 0x3c
	PwmConfig.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 8013b4e:	2300      	movs	r3, #0
 8013b50:	64bb      	str	r3, [r7, #72]	; 0x48
	PwmConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
 8013b52:	2300      	movs	r3, #0
 8013b54:	647b      	str	r3, [r7, #68]	; 0x44
	PwmConfig.OCIdleState = TIM_OCIDLESTATE_RESET;
 8013b56:	2300      	movs	r3, #0
 8013b58:	653b      	str	r3, [r7, #80]	; 0x50
	PwmConfig.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 8013b5a:	2300      	movs	r3, #0
 8013b5c:	657b      	str	r3, [r7, #84]	; 0x54
	PwmConfig.Pulse = PWM_PERIOD/2;
 8013b5e:	f44f 5396 	mov.w	r3, #4800	; 0x12c0
 8013b62:	643b      	str	r3, [r7, #64]	; 0x40
	PwmConfig.OCFastMode = TIM_OCFAST_DISABLE;
 8013b64:	2300      	movs	r3, #0
 8013b66:	64fb      	str	r3, [r7, #76]	; 0x4c
	HAL_TIM_PWM_ConfigChannel(&TimHandle,&PwmConfig, TIM_CHANNEL_1);
 8013b68:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8013b6c:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 8013b70:	4610      	mov	r0, r2
 8013b72:	4619      	mov	r1, r3
 8013b74:	2200      	movs	r2, #0
 8013b76:	f7fa ff09 	bl	800e98c <HAL_TIM_PWM_ConfigChannel>
	HAL_TIM_PWM_ConfigChannel(&TimHandle,&PwmConfig, TIM_CHANNEL_2);
 8013b7a:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8013b7e:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 8013b82:	4610      	mov	r0, r2
 8013b84:	4619      	mov	r1, r3
 8013b86:	2204      	movs	r2, #4
 8013b88:	f7fa ff00 	bl	800e98c <HAL_TIM_PWM_ConfigChannel>
	HAL_TIM_PWM_ConfigChannel(&TimHandle,&PwmConfig, TIM_CHANNEL_3);
 8013b8c:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8013b90:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 8013b94:	4610      	mov	r0, r2
 8013b96:	4619      	mov	r1, r3
 8013b98:	2208      	movs	r2, #8
 8013b9a:	f7fa fef7 	bl	800e98c <HAL_TIM_PWM_ConfigChannel>
	HAL_TIM_PWM_ConfigChannel(&TimHandle,&PwmConfig, TIM_CHANNEL_3);
 8013b9e:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8013ba2:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 8013ba6:	4610      	mov	r0, r2
 8013ba8:	4619      	mov	r1, r3
 8013baa:	2208      	movs	r2, #8
 8013bac:	f7fa feee 	bl	800e98c <HAL_TIM_PWM_ConfigChannel>

	TIM_OC1_SetConfig(TIM8,&PwmConfig);
 8013bb0:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 8013bb4:	483e      	ldr	r0, [pc, #248]	; (8013cb0 <stm32_hw_tim8_init+0x19c>)
 8013bb6:	4619      	mov	r1, r3
 8013bb8:	f7fa fcfe 	bl	800e5b8 <TIM_OC1_SetConfig>
	TIM_OC2_SetConfig(TIM8,&PwmConfig);
 8013bbc:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 8013bc0:	483b      	ldr	r0, [pc, #236]	; (8013cb0 <stm32_hw_tim8_init+0x19c>)
 8013bc2:	4619      	mov	r1, r3
 8013bc4:	f7fa fd6c 	bl	800e6a0 <TIM_OC2_SetConfig>
	TIM_OC3_SetConfig(TIM8,&PwmConfig);
 8013bc8:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 8013bcc:	4838      	ldr	r0, [pc, #224]	; (8013cb0 <stm32_hw_tim8_init+0x19c>)
 8013bce:	4619      	mov	r1, r3
 8013bd0:	f7fa fde0 	bl	800e794 <TIM_OC3_SetConfig>
	TIM_OC4_SetConfig(TIM8,&PwmConfig);
 8013bd4:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 8013bd8:	4835      	ldr	r0, [pc, #212]	; (8013cb0 <stm32_hw_tim8_init+0x19c>)
 8013bda:	4619      	mov	r1, r3
 8013bdc:	f7fa fe52 	bl	800e884 <TIM_OC4_SetConfig>

	if (DEADTIME1 < 128)
		deadtime = DEADTIME1;
	else if( DEADTIME2 <64)
		deadtime  = DEADTIME2 | 0x80;
 8013be0:	238c      	movs	r3, #140	; 0x8c
 8013be2:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
	else if( DEADTIME3 < 32)
		deadtime = DEADTIME3 | 0xC0;
	else
		deadtime = DEADTIME4 | 0xE0;
	PwmBDTRconfig.DeadTime  = deadtime;
 8013be6:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 8013bea:	61fb      	str	r3, [r7, #28]
	PwmBDTRconfig.LockLevel = TIM_LOCKLEVEL_1;
 8013bec:	f44f 7380 	mov.w	r3, #256	; 0x100
 8013bf0:	61bb      	str	r3, [r7, #24]
	PwmBDTRconfig.OffStateRunMode = TIM_OSSR_ENABLE;
 8013bf2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8013bf6:	613b      	str	r3, [r7, #16]
	PwmBDTRconfig.OffStateIDLEMode = TIM_OSSI_ENABLE;
 8013bf8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8013bfc:	617b      	str	r3, [r7, #20]
	PwmBDTRconfig.Break2State = TIM_BREAK2_ENABLE;
 8013bfe:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8013c02:	62fb      	str	r3, [r7, #44]	; 0x2c
	PwmBDTRconfig.Break2Polarity = TIM_BREAK2POLARITY_LOW;
 8013c04:	2300      	movs	r3, #0
 8013c06:	633b      	str	r3, [r7, #48]	; 0x30
	PwmBDTRconfig.Break2Filter = 0x0;
 8013c08:	2300      	movs	r3, #0
 8013c0a:	637b      	str	r3, [r7, #52]	; 0x34
	PwmBDTRconfig.BreakState = TIM_BREAK_ENABLE;
 8013c0c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8013c10:	623b      	str	r3, [r7, #32]
	PwmBDTRconfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 8013c12:	2300      	movs	r3, #0
 8013c14:	63bb      	str	r3, [r7, #56]	; 0x38
	PwmBDTRconfig.BreakPolarity = TIM_BREAKPOLARITY_LOW;
 8013c16:	2300      	movs	r3, #0
 8013c18:	627b      	str	r3, [r7, #36]	; 0x24
	PwmBDTRconfig.BreakFilter = 0x0;
 8013c1a:	2300      	movs	r3, #0
 8013c1c:	62bb      	str	r3, [r7, #40]	; 0x28
	HAL_TIMEx_ConfigBreakDeadTime(&TimHandle,&PwmBDTRconfig);
 8013c1e:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8013c22:	f107 0310 	add.w	r3, r7, #16
 8013c26:	4610      	mov	r0, r2
 8013c28:	4619      	mov	r1, r3
 8013c2a:	f7fb f81b 	bl	800ec64 <HAL_TIMEx_ConfigBreakDeadTime>

	TIM8MasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8013c2e:	2300      	movs	r3, #0
 8013c30:	607b      	str	r3, [r7, #4]
	TIM8MasterConfig.MasterOutputTrigger2 = TIM_TRGO2_UPDATE;
 8013c32:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8013c36:	60bb      	str	r3, [r7, #8]
	TIM8MasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_ENABLE;
 8013c38:	2380      	movs	r3, #128	; 0x80
 8013c3a:	60fb      	str	r3, [r7, #12]
	HAL_TIMEx_MasterConfigSynchronization(&TimHandle,&TIM8MasterConfig);
 8013c3c:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8013c40:	1d3b      	adds	r3, r7, #4
 8013c42:	4610      	mov	r0, r2
 8013c44:	4619      	mov	r1, r3
 8013c46:	f7fa ffb9 	bl	800ebbc <HAL_TIMEx_MasterConfigSynchronization>
	
	TIM8->CCER |= TIM_CCER_CC3E | TIM_CCER_CC3NE | TIM_CCER_CC2E | \
 8013c4a:	4919      	ldr	r1, [pc, #100]	; (8013cb0 <stm32_hw_tim8_init+0x19c>)
 8013c4c:	4b18      	ldr	r3, [pc, #96]	; (8013cb0 <stm32_hw_tim8_init+0x19c>)
 8013c4e:	6a1a      	ldr	r2, [r3, #32]
 8013c50:	f241 5355 	movw	r3, #5461	; 0x1555
 8013c54:	4313      	orrs	r3, r2
 8013c56:	620b      	str	r3, [r1, #32]
					TIM_CCER_CC2NE | TIM_CCER_CC1E | TIM_CCER_CC1NE | TIM_CCER_CC4E;
	TIM8->BDTR |= TIM_BDTR_OSSI | TIM_BDTR_OSSR;
 8013c58:	4a15      	ldr	r2, [pc, #84]	; (8013cb0 <stm32_hw_tim8_init+0x19c>)
 8013c5a:	4b15      	ldr	r3, [pc, #84]	; (8013cb0 <stm32_hw_tim8_init+0x19c>)
 8013c5c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8013c5e:	f443 6340 	orr.w	r3, r3, #3072	; 0xc00
 8013c62:	6453      	str	r3, [r2, #68]	; 0x44

	
	HAL_TIM_PWM_Start(&TimHandle,TIM_CHANNEL_1);
 8013c64:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8013c68:	4618      	mov	r0, r3
 8013c6a:	2100      	movs	r1, #0
 8013c6c:	f7fa f94c 	bl	800df08 <HAL_TIM_PWM_Start>
	HAL_TIM_PWM_Start(&TimHandle,TIM_CHANNEL_2);
 8013c70:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8013c74:	4618      	mov	r0, r3
 8013c76:	2104      	movs	r1, #4
 8013c78:	f7fa f946 	bl	800df08 <HAL_TIM_PWM_Start>
	HAL_TIM_PWM_Start(&TimHandle,TIM_CHANNEL_3);
 8013c7c:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8013c80:	4618      	mov	r0, r3
 8013c82:	2108      	movs	r1, #8
 8013c84:	f7fa f940 	bl	800df08 <HAL_TIM_PWM_Start>
	HAL_TIM_PWM_Start(&TimHandle,TIM_CHANNEL_4);
 8013c88:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8013c8c:	4618      	mov	r0, r3
 8013c8e:	210c      	movs	r1, #12
 8013c90:	f7fa f93a 	bl	800df08 <HAL_TIM_PWM_Start>
	
	__HAL_TIM_ENABLE_IT(&TimHandle, TIM_IT_BREAK);
 8013c94:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8013c96:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8013c98:	68d2      	ldr	r2, [r2, #12]
 8013c9a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8013c9e:	60da      	str	r2, [r3, #12]
	#ifdef TIM8UPDATEITENABLE
	__HAL_TIM_ENABLE_IT(&TimHandle, TIM_IT_UPDATE);
	#endif
	PWMOutputsDisable(TIM8);
 8013ca0:	4803      	ldr	r0, [pc, #12]	; (8013cb0 <stm32_hw_tim8_init+0x19c>)
 8013ca2:	f7ff fe51 	bl	8013948 <PWMOutputsDisable>
    return 0;
 8013ca6:	2300      	movs	r3, #0
}
 8013ca8:	4618      	mov	r0, r3
 8013caa:	3798      	adds	r7, #152	; 0x98
 8013cac:	46bd      	mov	sp, r7
 8013cae:	bd80      	pop	{r7, pc}
 8013cb0:	40010400 	.word	0x40010400

08013cb4 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8013cb4:	b480      	push	{r7}
 8013cb6:	b083      	sub	sp, #12
 8013cb8:	af00      	add	r7, sp, #0
 8013cba:	4603      	mov	r3, r0
 8013cbc:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8013cbe:	4908      	ldr	r1, [pc, #32]	; (8013ce0 <NVIC_EnableIRQ+0x2c>)
 8013cc0:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8013cc4:	095b      	lsrs	r3, r3, #5
 8013cc6:	79fa      	ldrb	r2, [r7, #7]
 8013cc8:	f002 021f 	and.w	r2, r2, #31
 8013ccc:	2001      	movs	r0, #1
 8013cce:	fa00 f202 	lsl.w	r2, r0, r2
 8013cd2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8013cd6:	370c      	adds	r7, #12
 8013cd8:	46bd      	mov	sp, r7
 8013cda:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013cde:	4770      	bx	lr
 8013ce0:	e000e100 	.word	0xe000e100

08013ce4 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
 8013ce4:	b480      	push	{r7}
 8013ce6:	b083      	sub	sp, #12
 8013ce8:	af00      	add	r7, sp, #0
 8013cea:	4603      	mov	r3, r0
 8013cec:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8013cee:	4909      	ldr	r1, [pc, #36]	; (8013d14 <NVIC_DisableIRQ+0x30>)
 8013cf0:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8013cf4:	095b      	lsrs	r3, r3, #5
 8013cf6:	79fa      	ldrb	r2, [r7, #7]
 8013cf8:	f002 021f 	and.w	r2, r2, #31
 8013cfc:	2001      	movs	r0, #1
 8013cfe:	fa00 f202 	lsl.w	r2, r0, r2
 8013d02:	3320      	adds	r3, #32
 8013d04:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8013d08:	370c      	adds	r7, #12
 8013d0a:	46bd      	mov	sp, r7
 8013d0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013d10:	4770      	bx	lr
 8013d12:	bf00      	nop
 8013d14:	e000e100 	.word	0xe000e100

08013d18 <stm32_configure>:
    UART_HandleTypeDef UartHandle;
    IRQn_Type irq;
};

static rt_err_t stm32_configure(struct rt_serial_device *serial, struct serial_configure *cfg)
{
 8013d18:	b580      	push	{r7, lr}
 8013d1a:	b084      	sub	sp, #16
 8013d1c:	af00      	add	r7, sp, #0
 8013d1e:	6078      	str	r0, [r7, #4]
 8013d20:	6039      	str	r1, [r7, #0]
    struct stm32_uart *uart;

    RT_ASSERT(serial != RT_NULL);
 8013d22:	687b      	ldr	r3, [r7, #4]
 8013d24:	2b00      	cmp	r3, #0
 8013d26:	d104      	bne.n	8013d32 <stm32_configure+0x1a>
 8013d28:	487f      	ldr	r0, [pc, #508]	; (8013f28 <stm32_configure+0x210>)
 8013d2a:	4980      	ldr	r1, [pc, #512]	; (8013f2c <stm32_configure+0x214>)
 8013d2c:	224c      	movs	r2, #76	; 0x4c
 8013d2e:	f003 fa69 	bl	8017204 <rt_assert_handler>
    RT_ASSERT(cfg != RT_NULL);
 8013d32:	683b      	ldr	r3, [r7, #0]
 8013d34:	2b00      	cmp	r3, #0
 8013d36:	d104      	bne.n	8013d42 <stm32_configure+0x2a>
 8013d38:	487d      	ldr	r0, [pc, #500]	; (8013f30 <stm32_configure+0x218>)
 8013d3a:	497c      	ldr	r1, [pc, #496]	; (8013f2c <stm32_configure+0x214>)
 8013d3c:	224d      	movs	r2, #77	; 0x4d
 8013d3e:	f003 fa61 	bl	8017204 <rt_assert_handler>

    uart = (struct stm32_uart *)serial->parent.user_data;
 8013d42:	687b      	ldr	r3, [r7, #4]
 8013d44:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8013d46:	60fb      	str	r3, [r7, #12]
	if(uart->UartHandle.Instance == USART1)
 8013d48:	68fb      	ldr	r3, [r7, #12]
 8013d4a:	681b      	ldr	r3, [r3, #0]
 8013d4c:	4a79      	ldr	r2, [pc, #484]	; (8013f34 <stm32_configure+0x21c>)
 8013d4e:	4293      	cmp	r3, r2
 8013d50:	d16f      	bne.n	8013e32 <stm32_configure+0x11a>
	{
	    uart->UartHandle.Init.BaudRate   = cfg->baud_rate;
 8013d52:	683b      	ldr	r3, [r7, #0]
 8013d54:	681a      	ldr	r2, [r3, #0]
 8013d56:	68fb      	ldr	r3, [r7, #12]
 8013d58:	605a      	str	r2, [r3, #4]
	    uart->UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
 8013d5a:	68fb      	ldr	r3, [r7, #12]
 8013d5c:	2200      	movs	r2, #0
 8013d5e:	619a      	str	r2, [r3, #24]
	    uart->UartHandle.Init.Mode       = UART_MODE_TX_RX;
 8013d60:	68fb      	ldr	r3, [r7, #12]
 8013d62:	220c      	movs	r2, #12
 8013d64:	615a      	str	r2, [r3, #20]
	    uart->UartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8013d66:	68fb      	ldr	r3, [r7, #12]
 8013d68:	2200      	movs	r2, #0
 8013d6a:	625a      	str	r2, [r3, #36]	; 0x24

	    switch (cfg->data_bits)
 8013d6c:	683b      	ldr	r3, [r7, #0]
 8013d6e:	791b      	ldrb	r3, [r3, #4]
 8013d70:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8013d74:	b2db      	uxtb	r3, r3
 8013d76:	2b08      	cmp	r3, #8
 8013d78:	d008      	beq.n	8013d8c <stm32_configure+0x74>
 8013d7a:	2b09      	cmp	r3, #9
 8013d7c:	d00a      	beq.n	8013d94 <stm32_configure+0x7c>
 8013d7e:	2b07      	cmp	r3, #7
 8013d80:	d10d      	bne.n	8013d9e <stm32_configure+0x86>
	    {
	    case DATA_BITS_7:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_7B;
 8013d82:	68fb      	ldr	r3, [r7, #12]
 8013d84:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8013d88:	609a      	str	r2, [r3, #8]
	        break;
 8013d8a:	e00c      	b.n	8013da6 <stm32_configure+0x8e>
	    case DATA_BITS_8:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 8013d8c:	68fb      	ldr	r3, [r7, #12]
 8013d8e:	2200      	movs	r2, #0
 8013d90:	609a      	str	r2, [r3, #8]
	        break;
 8013d92:	e008      	b.n	8013da6 <stm32_configure+0x8e>
	    case DATA_BITS_9:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_9B;
 8013d94:	68fb      	ldr	r3, [r7, #12]
 8013d96:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8013d9a:	609a      	str	r2, [r3, #8]
	        break;
 8013d9c:	e003      	b.n	8013da6 <stm32_configure+0x8e>
	    default:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 8013d9e:	68fb      	ldr	r3, [r7, #12]
 8013da0:	2200      	movs	r2, #0
 8013da2:	609a      	str	r2, [r3, #8]
	        break;
 8013da4:	bf00      	nop
	    }
	    switch (cfg->stop_bits)
 8013da6:	683b      	ldr	r3, [r7, #0]
 8013da8:	791b      	ldrb	r3, [r3, #4]
 8013daa:	f3c3 1301 	ubfx	r3, r3, #4, #2
 8013dae:	b2db      	uxtb	r3, r3
 8013db0:	2b00      	cmp	r3, #0
 8013db2:	d002      	beq.n	8013dba <stm32_configure+0xa2>
 8013db4:	2b01      	cmp	r3, #1
 8013db6:	d004      	beq.n	8013dc2 <stm32_configure+0xaa>
 8013db8:	e008      	b.n	8013dcc <stm32_configure+0xb4>
	    {
	    case STOP_BITS_1:
	        uart->UartHandle.Init.StopBits   = UART_STOPBITS_1;
 8013dba:	68fb      	ldr	r3, [r7, #12]
 8013dbc:	2200      	movs	r2, #0
 8013dbe:	60da      	str	r2, [r3, #12]
	        break;
 8013dc0:	e008      	b.n	8013dd4 <stm32_configure+0xbc>
	    case STOP_BITS_2:
	        uart->UartHandle.Init.StopBits   = UART_STOPBITS_2;
 8013dc2:	68fb      	ldr	r3, [r7, #12]
 8013dc4:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8013dc8:	60da      	str	r2, [r3, #12]
	        break;
 8013dca:	e003      	b.n	8013dd4 <stm32_configure+0xbc>
	    default:
	        uart->UartHandle.Init.StopBits   = UART_STOPBITS_1;
 8013dcc:	68fb      	ldr	r3, [r7, #12]
 8013dce:	2200      	movs	r2, #0
 8013dd0:	60da      	str	r2, [r3, #12]
	        break;
 8013dd2:	bf00      	nop
	    }
	    switch (cfg->parity)
 8013dd4:	683b      	ldr	r3, [r7, #0]
 8013dd6:	791b      	ldrb	r3, [r3, #4]
 8013dd8:	f3c3 1381 	ubfx	r3, r3, #6, #2
 8013ddc:	b2db      	uxtb	r3, r3
 8013dde:	2b01      	cmp	r3, #1
 8013de0:	d007      	beq.n	8013df2 <stm32_configure+0xda>
 8013de2:	2b02      	cmp	r3, #2
 8013de4:	d00a      	beq.n	8013dfc <stm32_configure+0xe4>
 8013de6:	2b00      	cmp	r3, #0
 8013de8:	d10d      	bne.n	8013e06 <stm32_configure+0xee>
	    {
	    case PARITY_NONE:
	        uart->UartHandle.Init.Parity     = UART_PARITY_NONE;
 8013dea:	68fb      	ldr	r3, [r7, #12]
 8013dec:	2200      	movs	r2, #0
 8013dee:	611a      	str	r2, [r3, #16]
	        break;
 8013df0:	e00d      	b.n	8013e0e <stm32_configure+0xf6>
	    case PARITY_ODD:
	        uart->UartHandle.Init.Parity     = UART_PARITY_ODD;
 8013df2:	68fb      	ldr	r3, [r7, #12]
 8013df4:	f44f 62c0 	mov.w	r2, #1536	; 0x600
 8013df8:	611a      	str	r2, [r3, #16]
	        break;
 8013dfa:	e008      	b.n	8013e0e <stm32_configure+0xf6>
	    case PARITY_EVEN:
	        uart->UartHandle.Init.Parity     = UART_PARITY_EVEN;
 8013dfc:	68fb      	ldr	r3, [r7, #12]
 8013dfe:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8013e02:	611a      	str	r2, [r3, #16]
	        break;
 8013e04:	e003      	b.n	8013e0e <stm32_configure+0xf6>
	    default:
	        uart->UartHandle.Init.Parity     = UART_PARITY_NONE;
 8013e06:	68fb      	ldr	r3, [r7, #12]
 8013e08:	2200      	movs	r2, #0
 8013e0a:	611a      	str	r2, [r3, #16]
	        break;
 8013e0c:	bf00      	nop
	    }
	    if (HAL_UART_DeInit(&uart->UartHandle) != HAL_OK)
 8013e0e:	68fb      	ldr	r3, [r7, #12]
 8013e10:	4618      	mov	r0, r3
 8013e12:	f7fb f895 	bl	800ef40 <HAL_UART_DeInit>
 8013e16:	4603      	mov	r3, r0
 8013e18:	2b00      	cmp	r3, #0
 8013e1a:	d001      	beq.n	8013e20 <stm32_configure+0x108>
	    {
	        return RT_ERROR;
 8013e1c:	2301      	movs	r3, #1
 8013e1e:	e07e      	b.n	8013f1e <stm32_configure+0x206>
	    }
	    if (HAL_UART_Init(&uart->UartHandle) != HAL_OK)
 8013e20:	68fb      	ldr	r3, [r7, #12]
 8013e22:	4618      	mov	r0, r3
 8013e24:	f7fb f83a 	bl	800ee9c <HAL_UART_Init>
 8013e28:	4603      	mov	r3, r0
 8013e2a:	2b00      	cmp	r3, #0
 8013e2c:	d001      	beq.n	8013e32 <stm32_configure+0x11a>
	    {
	        return RT_ERROR;
 8013e2e:	2301      	movs	r3, #1
 8013e30:	e075      	b.n	8013f1e <stm32_configure+0x206>
	    }
	}

	if(uart->UartHandle.Instance == USART3)
 8013e32:	68fb      	ldr	r3, [r7, #12]
 8013e34:	681b      	ldr	r3, [r3, #0]
 8013e36:	4a40      	ldr	r2, [pc, #256]	; (8013f38 <stm32_configure+0x220>)
 8013e38:	4293      	cmp	r3, r2
 8013e3a:	d16f      	bne.n	8013f1c <stm32_configure+0x204>
	{
	    uart->UartHandle.Init.BaudRate   = cfg->baud_rate;
 8013e3c:	683b      	ldr	r3, [r7, #0]
 8013e3e:	681a      	ldr	r2, [r3, #0]
 8013e40:	68fb      	ldr	r3, [r7, #12]
 8013e42:	605a      	str	r2, [r3, #4]
	    uart->UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
 8013e44:	68fb      	ldr	r3, [r7, #12]
 8013e46:	2200      	movs	r2, #0
 8013e48:	619a      	str	r2, [r3, #24]
	    uart->UartHandle.Init.Mode       = UART_MODE_TX_RX;
 8013e4a:	68fb      	ldr	r3, [r7, #12]
 8013e4c:	220c      	movs	r2, #12
 8013e4e:	615a      	str	r2, [r3, #20]
	    uart->UartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8013e50:	68fb      	ldr	r3, [r7, #12]
 8013e52:	2200      	movs	r2, #0
 8013e54:	625a      	str	r2, [r3, #36]	; 0x24

	    switch (cfg->data_bits)
 8013e56:	683b      	ldr	r3, [r7, #0]
 8013e58:	791b      	ldrb	r3, [r3, #4]
 8013e5a:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8013e5e:	b2db      	uxtb	r3, r3
 8013e60:	2b08      	cmp	r3, #8
 8013e62:	d008      	beq.n	8013e76 <stm32_configure+0x15e>
 8013e64:	2b09      	cmp	r3, #9
 8013e66:	d00a      	beq.n	8013e7e <stm32_configure+0x166>
 8013e68:	2b07      	cmp	r3, #7
 8013e6a:	d10d      	bne.n	8013e88 <stm32_configure+0x170>
	    {
	    case DATA_BITS_7:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_7B;
 8013e6c:	68fb      	ldr	r3, [r7, #12]
 8013e6e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8013e72:	609a      	str	r2, [r3, #8]
	        break;
 8013e74:	e00c      	b.n	8013e90 <stm32_configure+0x178>
	    case DATA_BITS_8:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 8013e76:	68fb      	ldr	r3, [r7, #12]
 8013e78:	2200      	movs	r2, #0
 8013e7a:	609a      	str	r2, [r3, #8]
	        break;
 8013e7c:	e008      	b.n	8013e90 <stm32_configure+0x178>
	    case DATA_BITS_9:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_9B;
 8013e7e:	68fb      	ldr	r3, [r7, #12]
 8013e80:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8013e84:	609a      	str	r2, [r3, #8]
	        break;
 8013e86:	e003      	b.n	8013e90 <stm32_configure+0x178>
	    default:
	        uart->UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 8013e88:	68fb      	ldr	r3, [r7, #12]
 8013e8a:	2200      	movs	r2, #0
 8013e8c:	609a      	str	r2, [r3, #8]
	        break;
 8013e8e:	bf00      	nop
	    }
	    switch (cfg->stop_bits)
 8013e90:	683b      	ldr	r3, [r7, #0]
 8013e92:	791b      	ldrb	r3, [r3, #4]
 8013e94:	f3c3 1301 	ubfx	r3, r3, #4, #2
 8013e98:	b2db      	uxtb	r3, r3
 8013e9a:	2b00      	cmp	r3, #0
 8013e9c:	d002      	beq.n	8013ea4 <stm32_configure+0x18c>
 8013e9e:	2b01      	cmp	r3, #1
 8013ea0:	d004      	beq.n	8013eac <stm32_configure+0x194>
 8013ea2:	e008      	b.n	8013eb6 <stm32_configure+0x19e>
	    {
	    case STOP_BITS_1:
	        uart->UartHandle.Init.StopBits   = UART_STOPBITS_1;
 8013ea4:	68fb      	ldr	r3, [r7, #12]
 8013ea6:	2200      	movs	r2, #0
 8013ea8:	60da      	str	r2, [r3, #12]
	        break;
 8013eaa:	e008      	b.n	8013ebe <stm32_configure+0x1a6>
	    case STOP_BITS_2:
	        uart->UartHandle.Init.StopBits   = UART_STOPBITS_2;
 8013eac:	68fb      	ldr	r3, [r7, #12]
 8013eae:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8013eb2:	60da      	str	r2, [r3, #12]
	        break;
 8013eb4:	e003      	b.n	8013ebe <stm32_configure+0x1a6>
	    default:
	        uart->UartHandle.Init.StopBits   = UART_STOPBITS_1;
 8013eb6:	68fb      	ldr	r3, [r7, #12]
 8013eb8:	2200      	movs	r2, #0
 8013eba:	60da      	str	r2, [r3, #12]
	        break;
 8013ebc:	bf00      	nop
	    }
	    switch (cfg->parity)
 8013ebe:	683b      	ldr	r3, [r7, #0]
 8013ec0:	791b      	ldrb	r3, [r3, #4]
 8013ec2:	f3c3 1381 	ubfx	r3, r3, #6, #2
 8013ec6:	b2db      	uxtb	r3, r3
 8013ec8:	2b01      	cmp	r3, #1
 8013eca:	d007      	beq.n	8013edc <stm32_configure+0x1c4>
 8013ecc:	2b02      	cmp	r3, #2
 8013ece:	d00a      	beq.n	8013ee6 <stm32_configure+0x1ce>
 8013ed0:	2b00      	cmp	r3, #0
 8013ed2:	d10d      	bne.n	8013ef0 <stm32_configure+0x1d8>
	    {
	    case PARITY_NONE:
	        uart->UartHandle.Init.Parity     = UART_PARITY_NONE;
 8013ed4:	68fb      	ldr	r3, [r7, #12]
 8013ed6:	2200      	movs	r2, #0
 8013ed8:	611a      	str	r2, [r3, #16]
	        break;
 8013eda:	e00d      	b.n	8013ef8 <stm32_configure+0x1e0>
	    case PARITY_ODD:
	        uart->UartHandle.Init.Parity     = UART_PARITY_ODD;
 8013edc:	68fb      	ldr	r3, [r7, #12]
 8013ede:	f44f 62c0 	mov.w	r2, #1536	; 0x600
 8013ee2:	611a      	str	r2, [r3, #16]
	        break;
 8013ee4:	e008      	b.n	8013ef8 <stm32_configure+0x1e0>
	    case PARITY_EVEN:
	        uart->UartHandle.Init.Parity     = UART_PARITY_EVEN;
 8013ee6:	68fb      	ldr	r3, [r7, #12]
 8013ee8:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8013eec:	611a      	str	r2, [r3, #16]
	        break;
 8013eee:	e003      	b.n	8013ef8 <stm32_configure+0x1e0>
	    default:
	        uart->UartHandle.Init.Parity     = UART_PARITY_NONE;
 8013ef0:	68fb      	ldr	r3, [r7, #12]
 8013ef2:	2200      	movs	r2, #0
 8013ef4:	611a      	str	r2, [r3, #16]
	        break;
 8013ef6:	bf00      	nop
	    }
	    if (HAL_UART_DeInit(&uart->UartHandle) != HAL_OK)
 8013ef8:	68fb      	ldr	r3, [r7, #12]
 8013efa:	4618      	mov	r0, r3
 8013efc:	f7fb f820 	bl	800ef40 <HAL_UART_DeInit>
 8013f00:	4603      	mov	r3, r0
 8013f02:	2b00      	cmp	r3, #0
 8013f04:	d001      	beq.n	8013f0a <stm32_configure+0x1f2>
	    {
	        return RT_ERROR;
 8013f06:	2301      	movs	r3, #1
 8013f08:	e009      	b.n	8013f1e <stm32_configure+0x206>
	    }
	    if (HAL_UART_Init(&uart->UartHandle) != HAL_OK)
 8013f0a:	68fb      	ldr	r3, [r7, #12]
 8013f0c:	4618      	mov	r0, r3
 8013f0e:	f7fa ffc5 	bl	800ee9c <HAL_UART_Init>
 8013f12:	4603      	mov	r3, r0
 8013f14:	2b00      	cmp	r3, #0
 8013f16:	d001      	beq.n	8013f1c <stm32_configure+0x204>
	    {
	        return RT_ERROR;
 8013f18:	2301      	movs	r3, #1
 8013f1a:	e000      	b.n	8013f1e <stm32_configure+0x206>
	    }

	}
    return RT_EOK;
 8013f1c:	2300      	movs	r3, #0
}
 8013f1e:	4618      	mov	r0, r3
 8013f20:	3710      	adds	r7, #16
 8013f22:	46bd      	mov	sp, r7
 8013f24:	bd80      	pop	{r7, pc}
 8013f26:	bf00      	nop
 8013f28:	08028920 	.word	0x08028920
 8013f2c:	0802a544 	.word	0x0802a544
 8013f30:	08028934 	.word	0x08028934
 8013f34:	40011000 	.word	0x40011000
 8013f38:	40004800 	.word	0x40004800

08013f3c <stm32_control>:
{
	rt_hw_serial_isr(&serial3, RT_SERIAL_EVENT_RX_DMADONE | 0x100);
}

static rt_err_t stm32_control(struct rt_serial_device *serial, int cmd, void *arg)
{
 8013f3c:	b580      	push	{r7, lr}
 8013f3e:	b086      	sub	sp, #24
 8013f40:	af00      	add	r7, sp, #0
 8013f42:	60f8      	str	r0, [r7, #12]
 8013f44:	60b9      	str	r1, [r7, #8]
 8013f46:	607a      	str	r2, [r7, #4]
    struct stm32_uart *uart;
	static DMA_HandleTypeDef hdma_rx;

    RT_ASSERT(serial != RT_NULL);
 8013f48:	68fb      	ldr	r3, [r7, #12]
 8013f4a:	2b00      	cmp	r3, #0
 8013f4c:	d104      	bne.n	8013f58 <stm32_control+0x1c>
 8013f4e:	4856      	ldr	r0, [pc, #344]	; (80140a8 <stm32_control+0x16c>)
 8013f50:	4956      	ldr	r1, [pc, #344]	; (80140ac <stm32_control+0x170>)
 8013f52:	22d8      	movs	r2, #216	; 0xd8
 8013f54:	f003 f956 	bl	8017204 <rt_assert_handler>
    uart = (struct stm32_uart *)serial->parent.user_data;
 8013f58:	68fb      	ldr	r3, [r7, #12]
 8013f5a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8013f5c:	617b      	str	r3, [r7, #20]

    switch (cmd)
 8013f5e:	68bb      	ldr	r3, [r7, #8]
 8013f60:	2b11      	cmp	r3, #17
 8013f62:	d004      	beq.n	8013f6e <stm32_control+0x32>
 8013f64:	2b14      	cmp	r3, #20
 8013f66:	d022      	beq.n	8013fae <stm32_control+0x72>
 8013f68:	2b10      	cmp	r3, #16
 8013f6a:	d010      	beq.n	8013f8e <stm32_control+0x52>
 8013f6c:	e097      	b.n	801409e <stm32_control+0x162>
    {
    case RT_DEVICE_CTRL_CLR_INT:
        /* disable rx irq */
        UART_DISABLE_IRQ(uart->irq);
 8013f6e:	697b      	ldr	r3, [r7, #20]
 8013f70:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
 8013f74:	b25b      	sxtb	r3, r3
 8013f76:	4618      	mov	r0, r3
 8013f78:	f7ff feb4 	bl	8013ce4 <NVIC_DisableIRQ>
        /* disable interrupt */
        __HAL_UART_DISABLE_IT(&uart->UartHandle, UART_IT_RXNE);
 8013f7c:	697b      	ldr	r3, [r7, #20]
 8013f7e:	681b      	ldr	r3, [r3, #0]
 8013f80:	697a      	ldr	r2, [r7, #20]
 8013f82:	6812      	ldr	r2, [r2, #0]
 8013f84:	6812      	ldr	r2, [r2, #0]
 8013f86:	f022 0220 	bic.w	r2, r2, #32
 8013f8a:	601a      	str	r2, [r3, #0]
        break;
 8013f8c:	e087      	b.n	801409e <stm32_control+0x162>
    case RT_DEVICE_CTRL_SET_INT:
        /* enable rx irq */
        UART_ENABLE_IRQ(uart->irq);
 8013f8e:	697b      	ldr	r3, [r7, #20]
 8013f90:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
 8013f94:	b25b      	sxtb	r3, r3
 8013f96:	4618      	mov	r0, r3
 8013f98:	f7ff fe8c 	bl	8013cb4 <NVIC_EnableIRQ>
        /* enable interrupt */
        __HAL_UART_ENABLE_IT(&uart->UartHandle, UART_IT_RXNE);
 8013f9c:	697b      	ldr	r3, [r7, #20]
 8013f9e:	681b      	ldr	r3, [r3, #0]
 8013fa0:	697a      	ldr	r2, [r7, #20]
 8013fa2:	6812      	ldr	r2, [r2, #0]
 8013fa4:	6812      	ldr	r2, [r2, #0]
 8013fa6:	f042 0220 	orr.w	r2, r2, #32
 8013faa:	601a      	str	r2, [r3, #0]
        break;
 8013fac:	e077      	b.n	801409e <stm32_control+0x162>
    case RT_DEVICE_CTRL_SET_DMARX:

#if 1
		rt_kprintf("in the control\r\n");
 8013fae:	4840      	ldr	r0, [pc, #256]	; (80140b0 <stm32_control+0x174>)
 8013fb0:	f003 f8ae 	bl	8017110 <rt_kprintf>
		__HAL_RCC_DMA1_CLK_ENABLE();
 8013fb4:	4a3f      	ldr	r2, [pc, #252]	; (80140b4 <stm32_control+0x178>)
 8013fb6:	4b3f      	ldr	r3, [pc, #252]	; (80140b4 <stm32_control+0x178>)
 8013fb8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013fba:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8013fbe:	6313      	str	r3, [r2, #48]	; 0x30
 8013fc0:	4b3c      	ldr	r3, [pc, #240]	; (80140b4 <stm32_control+0x178>)
 8013fc2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013fc4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8013fc8:	613b      	str	r3, [r7, #16]
 8013fca:	693b      	ldr	r3, [r7, #16]
		
		hdma_rx.Instance = DMA1_Stream1;
 8013fcc:	4b3a      	ldr	r3, [pc, #232]	; (80140b8 <stm32_control+0x17c>)
 8013fce:	4a3b      	ldr	r2, [pc, #236]	; (80140bc <stm32_control+0x180>)
 8013fd0:	601a      	str	r2, [r3, #0]
		uart->UartHandle.RxXferSize = 1;
 8013fd2:	697b      	ldr	r3, [r7, #20]
 8013fd4:	2201      	movs	r2, #1
 8013fd6:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
		uart->UartHandle.Instance->CR3 |= USART_CR3_DMAR;
 8013fda:	697b      	ldr	r3, [r7, #20]
 8013fdc:	681b      	ldr	r3, [r3, #0]
 8013fde:	697a      	ldr	r2, [r7, #20]
 8013fe0:	6812      	ldr	r2, [r2, #0]
 8013fe2:	6892      	ldr	r2, [r2, #8]
 8013fe4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8013fe8:	609a      	str	r2, [r3, #8]
		
		hdma_rx.Init.Channel = DMA_CHANNEL_4;
 8013fea:	4b33      	ldr	r3, [pc, #204]	; (80140b8 <stm32_control+0x17c>)
 8013fec:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8013ff0:	605a      	str	r2, [r3, #4]
		hdma_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8013ff2:	4b31      	ldr	r3, [pc, #196]	; (80140b8 <stm32_control+0x17c>)
 8013ff4:	2200      	movs	r2, #0
 8013ff6:	609a      	str	r2, [r3, #8]
		hdma_rx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 8013ff8:	4b2f      	ldr	r3, [pc, #188]	; (80140b8 <stm32_control+0x17c>)
 8013ffa:	2204      	movs	r2, #4
 8013ffc:	625a      	str	r2, [r3, #36]	; 0x24
		hdma_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_HALFFULL;
 8013ffe:	4b2e      	ldr	r3, [pc, #184]	; (80140b8 <stm32_control+0x17c>)
 8014000:	2201      	movs	r2, #1
 8014002:	629a      	str	r2, [r3, #40]	; 0x28
		hdma_rx.Init.MemBurst = DMA_MBURST_SINGLE;
 8014004:	4b2c      	ldr	r3, [pc, #176]	; (80140b8 <stm32_control+0x17c>)
 8014006:	2200      	movs	r2, #0
 8014008:	62da      	str	r2, [r3, #44]	; 0x2c
		hdma_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 801400a:	4b2b      	ldr	r3, [pc, #172]	; (80140b8 <stm32_control+0x17c>)
 801400c:	2200      	movs	r2, #0
 801400e:	619a      	str	r2, [r3, #24]
		hdma_rx.Init.MemInc = DMA_MINC_ENABLE;
 8014010:	4b29      	ldr	r3, [pc, #164]	; (80140b8 <stm32_control+0x17c>)
 8014012:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8014016:	611a      	str	r2, [r3, #16]
		hdma_rx.Init.Mode = DMA_NORMAL;
 8014018:	4b27      	ldr	r3, [pc, #156]	; (80140b8 <stm32_control+0x17c>)
 801401a:	2200      	movs	r2, #0
 801401c:	61da      	str	r2, [r3, #28]
		hdma_rx.Init.PeriphBurst = DMA_PBURST_SINGLE;
 801401e:	4b26      	ldr	r3, [pc, #152]	; (80140b8 <stm32_control+0x17c>)
 8014020:	2200      	movs	r2, #0
 8014022:	631a      	str	r2, [r3, #48]	; 0x30
		hdma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8014024:	4b24      	ldr	r3, [pc, #144]	; (80140b8 <stm32_control+0x17c>)
 8014026:	2200      	movs	r2, #0
 8014028:	615a      	str	r2, [r3, #20]
		hdma_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 801402a:	4b23      	ldr	r3, [pc, #140]	; (80140b8 <stm32_control+0x17c>)
 801402c:	2200      	movs	r2, #0
 801402e:	60da      	str	r2, [r3, #12]
		hdma_rx.Init.Priority = DMA_PRIORITY_MEDIUM;
 8014030:	4b21      	ldr	r3, [pc, #132]	; (80140b8 <stm32_control+0x17c>)
 8014032:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8014036:	621a      	str	r2, [r3, #32]
		
		
		if (HAL_DMA_DeInit(&hdma_rx) != HAL_OK)
 8014038:	481f      	ldr	r0, [pc, #124]	; (80140b8 <stm32_control+0x17c>)
 801403a:	f7f4 fa3f 	bl	80084bc <HAL_DMA_DeInit>
 801403e:	4603      	mov	r3, r0
 8014040:	2b00      	cmp	r3, #0
 8014042:	d001      	beq.n	8014048 <stm32_control+0x10c>
		{
			return RT_ERROR;
 8014044:	2301      	movs	r3, #1
 8014046:	e02b      	b.n	80140a0 <stm32_control+0x164>
		}
		if (HAL_DMA_Init(&hdma_rx) != HAL_OK)
 8014048:	481b      	ldr	r0, [pc, #108]	; (80140b8 <stm32_control+0x17c>)
 801404a:	f7f4 f9cb 	bl	80083e4 <HAL_DMA_Init>
 801404e:	4603      	mov	r3, r0
 8014050:	2b00      	cmp	r3, #0
 8014052:	d001      	beq.n	8014058 <stm32_control+0x11c>
		{
			return RT_ERROR;
 8014054:	2301      	movs	r3, #1
 8014056:	e023      	b.n	80140a0 <stm32_control+0x164>
		}
		__HAL_LINKDMA(&uart->UartHandle, hdmarx, hdma_rx);
 8014058:	697b      	ldr	r3, [r7, #20]
 801405a:	4a17      	ldr	r2, [pc, #92]	; (80140b8 <stm32_control+0x17c>)
 801405c:	665a      	str	r2, [r3, #100]	; 0x64
 801405e:	697b      	ldr	r3, [r7, #20]
 8014060:	4a15      	ldr	r2, [pc, #84]	; (80140b8 <stm32_control+0x17c>)
 8014062:	6393      	str	r3, [r2, #56]	; 0x38
		uart->UartHandle.pRxBuffPtr = (uint8_t *)rt_malloc((uart->UartHandle.RxXferSize)*sizeof(uint8_t));
 8014064:	697b      	ldr	r3, [r7, #20]
 8014066:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 801406a:	4618      	mov	r0, r3
 801406c:	f003 f9fe 	bl	801746c <rt_malloc>
 8014070:	4602      	mov	r2, r0
 8014072:	697b      	ldr	r3, [r7, #20]
 8014074:	655a      	str	r2, [r3, #84]	; 0x54
		  /* NVIC configuration for DMA transfer complete interrupt (USART6_RX) */
 		HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, DMA1STREAM1_IRQ_PREEMPT, DMA1STREAM1_IRQ_SUB);
 8014076:	200c      	movs	r0, #12
 8014078:	210f      	movs	r1, #15
 801407a:	2200      	movs	r2, #0
 801407c:	f7f4 f8fe 	bl	800827c <HAL_NVIC_SetPriority>
 		HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
 8014080:	200c      	movs	r0, #12
 8014082:	f7f4 f917 	bl	80082b4 <HAL_NVIC_EnableIRQ>
		HAL_UART_Receive_DMA(&uart->UartHandle,(uint8_t *)uart->UartHandle.pRxBuffPtr, uart->UartHandle.RxXferSize);
 8014086:	6979      	ldr	r1, [r7, #20]
 8014088:	697b      	ldr	r3, [r7, #20]
 801408a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801408c:	697b      	ldr	r3, [r7, #20]
 801408e:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 8014092:	4608      	mov	r0, r1
 8014094:	4611      	mov	r1, r2
 8014096:	461a      	mov	r2, r3
 8014098:	f7fa ff86 	bl	800efa8 <HAL_UART_Receive_DMA>
#endif
		
	    break;
 801409c:	bf00      	nop
    }

    return RT_EOK;
 801409e:	2300      	movs	r3, #0
}
 80140a0:	4618      	mov	r0, r3
 80140a2:	3718      	adds	r7, #24
 80140a4:	46bd      	mov	sp, r7
 80140a6:	bd80      	pop	{r7, pc}
 80140a8:	08028920 	.word	0x08028920
 80140ac:	0802a554 	.word	0x0802a554
 80140b0:	08028944 	.word	0x08028944
 80140b4:	40023800 	.word	0x40023800
 80140b8:	20010a04 	.word	0x20010a04
 80140bc:	40026028 	.word	0x40026028

080140c0 <stm32_putc>:

static int stm32_putc(struct rt_serial_device *serial, char c)
{
 80140c0:	b580      	push	{r7, lr}
 80140c2:	b084      	sub	sp, #16
 80140c4:	af00      	add	r7, sp, #0
 80140c6:	6078      	str	r0, [r7, #4]
 80140c8:	460b      	mov	r3, r1
 80140ca:	70fb      	strb	r3, [r7, #3]
    struct stm32_uart *uart;

    RT_ASSERT(serial != RT_NULL);
 80140cc:	687b      	ldr	r3, [r7, #4]
 80140ce:	2b00      	cmp	r3, #0
 80140d0:	d105      	bne.n	80140de <stm32_putc+0x1e>
 80140d2:	480d      	ldr	r0, [pc, #52]	; (8014108 <stm32_putc+0x48>)
 80140d4:	490d      	ldr	r1, [pc, #52]	; (801410c <stm32_putc+0x4c>)
 80140d6:	f240 121b 	movw	r2, #283	; 0x11b
 80140da:	f003 f893 	bl	8017204 <rt_assert_handler>
    uart = (struct stm32_uart *)serial->parent.user_data;
 80140de:	687b      	ldr	r3, [r7, #4]
 80140e0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80140e2:	60fb      	str	r3, [r7, #12]

    while (!(uart->UartHandle.Instance->ISR & UART_FLAG_TXE));
 80140e4:	bf00      	nop
 80140e6:	68fb      	ldr	r3, [r7, #12]
 80140e8:	681b      	ldr	r3, [r3, #0]
 80140ea:	69db      	ldr	r3, [r3, #28]
 80140ec:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80140f0:	2b00      	cmp	r3, #0
 80140f2:	d0f8      	beq.n	80140e6 <stm32_putc+0x26>
    uart->UartHandle.Instance->TDR = c;
 80140f4:	68fb      	ldr	r3, [r7, #12]
 80140f6:	681b      	ldr	r3, [r3, #0]
 80140f8:	78fa      	ldrb	r2, [r7, #3]
 80140fa:	629a      	str	r2, [r3, #40]	; 0x28

    return 1;
 80140fc:	2301      	movs	r3, #1
}
 80140fe:	4618      	mov	r0, r3
 8014100:	3710      	adds	r7, #16
 8014102:	46bd      	mov	sp, r7
 8014104:	bd80      	pop	{r7, pc}
 8014106:	bf00      	nop
 8014108:	08028920 	.word	0x08028920
 801410c:	0802a564 	.word	0x0802a564

08014110 <stm32_getc>:
/*test code by he*/


static int stm32_getc(struct rt_serial_device *serial)
{
 8014110:	b580      	push	{r7, lr}
 8014112:	b084      	sub	sp, #16
 8014114:	af00      	add	r7, sp, #0
 8014116:	6078      	str	r0, [r7, #4]
    int ch;
    struct stm32_uart *uart;

    RT_ASSERT(serial != RT_NULL);
 8014118:	687b      	ldr	r3, [r7, #4]
 801411a:	2b00      	cmp	r3, #0
 801411c:	d105      	bne.n	801412a <stm32_getc+0x1a>
 801411e:	480e      	ldr	r0, [pc, #56]	; (8014158 <stm32_getc+0x48>)
 8014120:	490e      	ldr	r1, [pc, #56]	; (801415c <stm32_getc+0x4c>)
 8014122:	f240 122b 	movw	r2, #299	; 0x12b
 8014126:	f003 f86d 	bl	8017204 <rt_assert_handler>
    uart = (struct stm32_uart *)serial->parent.user_data;
 801412a:	687b      	ldr	r3, [r7, #4]
 801412c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801412e:	60bb      	str	r3, [r7, #8]

    ch = -1;
 8014130:	f04f 33ff 	mov.w	r3, #4294967295
 8014134:	60fb      	str	r3, [r7, #12]
    if (uart->UartHandle.Instance->ISR & UART_FLAG_RXNE)
 8014136:	68bb      	ldr	r3, [r7, #8]
 8014138:	681b      	ldr	r3, [r3, #0]
 801413a:	69db      	ldr	r3, [r3, #28]
 801413c:	f003 0320 	and.w	r3, r3, #32
 8014140:	2b00      	cmp	r3, #0
 8014142:	d004      	beq.n	801414e <stm32_getc+0x3e>
    {
        ch = uart->UartHandle.Instance->RDR & 0xff;
 8014144:	68bb      	ldr	r3, [r7, #8]
 8014146:	681b      	ldr	r3, [r3, #0]
 8014148:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801414a:	b2db      	uxtb	r3, r3
 801414c:	60fb      	str	r3, [r7, #12]
    }
	/*test code by he*/
    return ch;
 801414e:	68fb      	ldr	r3, [r7, #12]
}
 8014150:	4618      	mov	r0, r3
 8014152:	3710      	adds	r7, #16
 8014154:	46bd      	mov	sp, r7
 8014156:	bd80      	pop	{r7, pc}
 8014158:	08028920 	.word	0x08028920
 801415c:	0802a570 	.word	0x0802a570

08014160 <stm32_dma_transmit>:

static rt_size_t stm32_dma_transmit(struct rt_serial_device *serial, rt_uint8_t *buf, rt_size_t size, int direction)
{
 8014160:	b580      	push	{r7, lr}
 8014162:	b088      	sub	sp, #32
 8014164:	af00      	add	r7, sp, #0
 8014166:	60f8      	str	r0, [r7, #12]
 8014168:	60b9      	str	r1, [r7, #8]
 801416a:	607a      	str	r2, [r7, #4]
 801416c:	603b      	str	r3, [r7, #0]
	rt_uint8_t                  *pRxPtr, *data;
	struct stm32_uart *uart;
	
    RT_ASSERT(serial != RT_NULL);
 801416e:	68fb      	ldr	r3, [r7, #12]
 8014170:	2b00      	cmp	r3, #0
 8014172:	d105      	bne.n	8014180 <stm32_dma_transmit+0x20>
 8014174:	480d      	ldr	r0, [pc, #52]	; (80141ac <stm32_dma_transmit+0x4c>)
 8014176:	490e      	ldr	r1, [pc, #56]	; (80141b0 <stm32_dma_transmit+0x50>)
 8014178:	f44f 729e 	mov.w	r2, #316	; 0x13c
 801417c:	f003 f842 	bl	8017204 <rt_assert_handler>
    uart = (struct stm32_uart *)serial->parent.user_data;
 8014180:	68fb      	ldr	r3, [r7, #12]
 8014182:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8014184:	61fb      	str	r3, [r7, #28]
	if (direction == RT_SERIAL_DMA_RX)
 8014186:	683b      	ldr	r3, [r7, #0]
 8014188:	2b01      	cmp	r3, #1
 801418a:	d10b      	bne.n	80141a4 <stm32_dma_transmit+0x44>
	{
		pRxPtr = uart->UartHandle.pRxBuffPtr;
 801418c:	69fb      	ldr	r3, [r7, #28]
 801418e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8014190:	61bb      	str	r3, [r7, #24]
		data = buf;
 8014192:	68bb      	ldr	r3, [r7, #8]
 8014194:	617b      	str	r3, [r7, #20]
		*data = 0;
 8014196:	697b      	ldr	r3, [r7, #20]
 8014198:	2200      	movs	r2, #0
 801419a:	701a      	strb	r2, [r3, #0]
			size--;
			if (i>=uart->UartHandle.RxXferSize)
			i = 0;
		}
		#endif
		*data = *pRxPtr;
 801419c:	69bb      	ldr	r3, [r7, #24]
 801419e:	781a      	ldrb	r2, [r3, #0]
 80141a0:	697b      	ldr	r3, [r7, #20]
 80141a2:	701a      	strb	r2, [r3, #0]
	}
}
 80141a4:	4618      	mov	r0, r3
 80141a6:	3720      	adds	r7, #32
 80141a8:	46bd      	mov	sp, r7
 80141aa:	bd80      	pop	{r7, pc}
 80141ac:	08028920 	.word	0x08028920
 80141b0:	0802a57c 	.word	0x0802a57c

080141b4 <USART1_IRQHandler>:




void USART1_IRQHandler(void)
{
 80141b4:	b580      	push	{r7, lr}
 80141b6:	b082      	sub	sp, #8
 80141b8:	af00      	add	r7, sp, #0
    struct stm32_uart *uart;

    uart = &uart1;
 80141ba:	4b11      	ldr	r3, [pc, #68]	; (8014200 <USART1_IRQHandler+0x4c>)
 80141bc:	607b      	str	r3, [r7, #4]

    /* enter interrupt */
    rt_interrupt_enter();
 80141be:	f002 f997 	bl	80164f0 <rt_interrupt_enter>

    /* UART in mode Receiver ---------------------------------------------------*/
    if ((__HAL_UART_GET_IT(&uart->UartHandle, UART_IT_RXNE) != RESET) && (__HAL_UART_GET_IT_SOURCE(&uart->UartHandle, UART_IT_RXNE) != RESET))
 80141c2:	687b      	ldr	r3, [r7, #4]
 80141c4:	681b      	ldr	r3, [r3, #0]
 80141c6:	69db      	ldr	r3, [r3, #28]
 80141c8:	f003 0320 	and.w	r3, r3, #32
 80141cc:	2b00      	cmp	r3, #0
 80141ce:	d012      	beq.n	80141f6 <USART1_IRQHandler+0x42>
 80141d0:	687b      	ldr	r3, [r7, #4]
 80141d2:	681b      	ldr	r3, [r3, #0]
 80141d4:	681b      	ldr	r3, [r3, #0]
 80141d6:	f003 0320 	and.w	r3, r3, #32
 80141da:	2b00      	cmp	r3, #0
 80141dc:	d00b      	beq.n	80141f6 <USART1_IRQHandler+0x42>
    {
        rt_hw_serial_isr(&serial1, RT_SERIAL_EVENT_RX_IND);
 80141de:	4809      	ldr	r0, [pc, #36]	; (8014204 <USART1_IRQHandler+0x50>)
 80141e0:	2101      	movs	r1, #1
 80141e2:	f006 fd19 	bl	801ac18 <rt_hw_serial_isr>
        /* Clear RXNE interrupt flag */
        __HAL_UART_SEND_REQ(&uart->UartHandle, UART_RXDATA_FLUSH_REQUEST);
 80141e6:	687b      	ldr	r3, [r7, #4]
 80141e8:	681b      	ldr	r3, [r3, #0]
 80141ea:	687a      	ldr	r2, [r7, #4]
 80141ec:	6812      	ldr	r2, [r2, #0]
 80141ee:	6992      	ldr	r2, [r2, #24]
 80141f0:	f042 0208 	orr.w	r2, r2, #8
 80141f4:	619a      	str	r2, [r3, #24]
    }
    /* leave interrupt */
    rt_interrupt_leave();
 80141f6:	f002 f991 	bl	801651c <rt_interrupt_leave>
}
 80141fa:	3708      	adds	r7, #8
 80141fc:	46bd      	mov	sp, r7
 80141fe:	bd80      	pop	{r7, pc}
 8014200:	2001091c 	.word	0x2001091c
 8014204:	20012944 	.word	0x20012944

08014208 <USART3_IRQHandler>:
#if defined(RT_USING_UART3)
/* UART1 device driver structure */


void USART3_IRQHandler(void)
{
 8014208:	b580      	push	{r7, lr}
 801420a:	b082      	sub	sp, #8
 801420c:	af00      	add	r7, sp, #0
    struct stm32_uart *uart;
    uart = &uart3;
 801420e:	4b11      	ldr	r3, [pc, #68]	; (8014254 <USART3_IRQHandler+0x4c>)
 8014210:	607b      	str	r3, [r7, #4]

    /* enter interrupt */
    rt_interrupt_enter();
 8014212:	f002 f96d 	bl	80164f0 <rt_interrupt_enter>
	
    /* UART in mode Receiver ---------------------------------------------------*/
    if ((__HAL_UART_GET_IT(&uart->UartHandle, UART_IT_RXNE) != RESET) && (__HAL_UART_GET_IT_SOURCE(&uart->UartHandle, UART_IT_RXNE) != RESET))
 8014216:	687b      	ldr	r3, [r7, #4]
 8014218:	681b      	ldr	r3, [r3, #0]
 801421a:	69db      	ldr	r3, [r3, #28]
 801421c:	f003 0320 	and.w	r3, r3, #32
 8014220:	2b00      	cmp	r3, #0
 8014222:	d012      	beq.n	801424a <USART3_IRQHandler+0x42>
 8014224:	687b      	ldr	r3, [r7, #4]
 8014226:	681b      	ldr	r3, [r3, #0]
 8014228:	681b      	ldr	r3, [r3, #0]
 801422a:	f003 0320 	and.w	r3, r3, #32
 801422e:	2b00      	cmp	r3, #0
 8014230:	d00b      	beq.n	801424a <USART3_IRQHandler+0x42>
    {
        rt_hw_serial_isr(&serial3, RT_SERIAL_EVENT_RX_IND);
 8014232:	4809      	ldr	r0, [pc, #36]	; (8014258 <USART3_IRQHandler+0x50>)
 8014234:	2101      	movs	r1, #1
 8014236:	f006 fcef 	bl	801ac18 <rt_hw_serial_isr>
        /* Clear RXNE interrupt flag */
        __HAL_UART_SEND_REQ(&uart->UartHandle, UART_RXDATA_FLUSH_REQUEST);
 801423a:	687b      	ldr	r3, [r7, #4]
 801423c:	681b      	ldr	r3, [r3, #0]
 801423e:	687a      	ldr	r2, [r7, #4]
 8014240:	6812      	ldr	r2, [r2, #0]
 8014242:	6992      	ldr	r2, [r2, #24]
 8014244:	f042 0208 	orr.w	r2, r2, #8
 8014248:	619a      	str	r2, [r3, #24]
    }
	
    /* leave interrupt */
    rt_interrupt_leave();
 801424a:	f002 f967 	bl	801651c <rt_interrupt_leave>
}
 801424e:	3708      	adds	r7, #8
 8014250:	46bd      	mov	sp, r7
 8014252:	bd80      	pop	{r7, pc}
 8014254:	20010990 	.word	0x20010990
 8014258:	20012998 	.word	0x20012998

0801425c <DMA1_Stream1_IRQHandler>:
#endif /* RT_USING_UART3 */

void DMA1_Stream1_IRQHandler(void)
{
 801425c:	b580      	push	{r7, lr}
 801425e:	b082      	sub	sp, #8
 8014260:	af00      	add	r7, sp, #0
	
    struct stm32_uart *uart;
	
	/* enter interrupt */
    rt_interrupt_enter();
 8014262:	f002 f945 	bl	80164f0 <rt_interrupt_enter>
    uart = &uart3;
 8014266:	4b06      	ldr	r3, [pc, #24]	; (8014280 <DMA1_Stream1_IRQHandler+0x24>)
 8014268:	607b      	str	r3, [r7, #4]
	
	HAL_DMA_IRQHandler((uart->UartHandle.hdmarx));
 801426a:	687b      	ldr	r3, [r7, #4]
 801426c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 801426e:	4618      	mov	r0, r3
 8014270:	f7f5 fb84 	bl	800997c <HAL_DMA_IRQHandler>
		
	/* leave interrupt */
	rt_interrupt_leave();
 8014274:	f002 f952 	bl	801651c <rt_interrupt_leave>
}
 8014278:	3708      	adds	r7, #8
 801427a:	46bd      	mov	sp, r7
 801427c:	bd80      	pop	{r7, pc}
 801427e:	bf00      	nop
 8014280:	20010990 	.word	0x20010990

08014284 <HAL_UART_MspInit>:
  *           - NVIC configuration for UART interrupt request enable
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
 8014284:	b580      	push	{r7, lr}
 8014286:	b08e      	sub	sp, #56	; 0x38
 8014288:	af00      	add	r7, sp, #0
 801428a:	6078      	str	r0, [r7, #4]
    GPIO_InitTypeDef  GPIO_InitStruct;
    if (huart->Instance == USART1)
 801428c:	687b      	ldr	r3, [r7, #4]
 801428e:	681b      	ldr	r3, [r3, #0]
 8014290:	4a4d      	ldr	r2, [pc, #308]	; (80143c8 <HAL_UART_MspInit+0x144>)
 8014292:	4293      	cmp	r3, r2
 8014294:	d147      	bne.n	8014326 <HAL_UART_MspInit+0xa2>
    {
		/* Enable GPIO TX/RX clock */
        USART1_TX_GPIO_CLK_ENABLE();
 8014296:	4a4d      	ldr	r2, [pc, #308]	; (80143cc <HAL_UART_MspInit+0x148>)
 8014298:	4b4c      	ldr	r3, [pc, #304]	; (80143cc <HAL_UART_MspInit+0x148>)
 801429a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801429c:	f043 0301 	orr.w	r3, r3, #1
 80142a0:	6313      	str	r3, [r2, #48]	; 0x30
 80142a2:	4b4a      	ldr	r3, [pc, #296]	; (80143cc <HAL_UART_MspInit+0x148>)
 80142a4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80142a6:	f003 0301 	and.w	r3, r3, #1
 80142aa:	623b      	str	r3, [r7, #32]
 80142ac:	6a3b      	ldr	r3, [r7, #32]
        USART1_RX_GPIO_CLK_ENABLE();
 80142ae:	4a47      	ldr	r2, [pc, #284]	; (80143cc <HAL_UART_MspInit+0x148>)
 80142b0:	4b46      	ldr	r3, [pc, #280]	; (80143cc <HAL_UART_MspInit+0x148>)
 80142b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80142b4:	f043 0302 	orr.w	r3, r3, #2
 80142b8:	6313      	str	r3, [r2, #48]	; 0x30
 80142ba:	4b44      	ldr	r3, [pc, #272]	; (80143cc <HAL_UART_MspInit+0x148>)
 80142bc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80142be:	f003 0302 	and.w	r3, r3, #2
 80142c2:	61fb      	str	r3, [r7, #28]
 80142c4:	69fb      	ldr	r3, [r7, #28]
        /* Enable USARTx clock */
        USART1_CLK_ENABLE();
 80142c6:	4a41      	ldr	r2, [pc, #260]	; (80143cc <HAL_UART_MspInit+0x148>)
 80142c8:	4b40      	ldr	r3, [pc, #256]	; (80143cc <HAL_UART_MspInit+0x148>)
 80142ca:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80142cc:	f043 0310 	orr.w	r3, r3, #16
 80142d0:	6453      	str	r3, [r2, #68]	; 0x44
 80142d2:	4b3e      	ldr	r3, [pc, #248]	; (80143cc <HAL_UART_MspInit+0x148>)
 80142d4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80142d6:	f003 0310 	and.w	r3, r3, #16
 80142da:	61bb      	str	r3, [r7, #24]
 80142dc:	69bb      	ldr	r3, [r7, #24]

        /* UART TX GPIO pin configuration  */
        GPIO_InitStruct.Pin       = USART1_TX_PIN;
 80142de:	f44f 7300 	mov.w	r3, #512	; 0x200
 80142e2:	627b      	str	r3, [r7, #36]	; 0x24
        GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 80142e4:	2302      	movs	r3, #2
 80142e6:	62bb      	str	r3, [r7, #40]	; 0x28
        GPIO_InitStruct.Pull      = GPIO_PULLUP;
 80142e8:	2301      	movs	r3, #1
 80142ea:	62fb      	str	r3, [r7, #44]	; 0x2c
        GPIO_InitStruct.Speed     = GPIO_SPEED_HIGH;
 80142ec:	2303      	movs	r3, #3
 80142ee:	633b      	str	r3, [r7, #48]	; 0x30
        GPIO_InitStruct.Alternate = USART1_TX_AF;
 80142f0:	2307      	movs	r3, #7
 80142f2:	637b      	str	r3, [r7, #52]	; 0x34
        HAL_GPIO_Init(USART1_TX_GPIO_PORT, &GPIO_InitStruct);
 80142f4:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80142f8:	4835      	ldr	r0, [pc, #212]	; (80143d0 <HAL_UART_MspInit+0x14c>)
 80142fa:	4619      	mov	r1, r3
 80142fc:	f7f8 fca2 	bl	800cc44 <HAL_GPIO_Init>

        /* UART RX GPIO pin configuration  */
        GPIO_InitStruct.Pin = USART1_RX_PIN;
 8014300:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8014304:	627b      	str	r3, [r7, #36]	; 0x24
        GPIO_InitStruct.Alternate = USART1_RX_AF;
 8014306:	2307      	movs	r3, #7
 8014308:	637b      	str	r3, [r7, #52]	; 0x34
        HAL_GPIO_Init(USART1_RX_GPIO_PORT, &GPIO_InitStruct);
 801430a:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801430e:	4830      	ldr	r0, [pc, #192]	; (80143d0 <HAL_UART_MspInit+0x14c>)
 8014310:	4619      	mov	r1, r3
 8014312:	f7f8 fc97 	bl	800cc44 <HAL_GPIO_Init>

        /* NVIC for USART */
        HAL_NVIC_SetPriority(USART1_IRQn, USART1_IRQ_PREEMPT ,USART1_TRQ_SUB);
 8014316:	2025      	movs	r0, #37	; 0x25
 8014318:	210f      	movs	r1, #15
 801431a:	2200      	movs	r2, #0
 801431c:	f7f3 ffae 	bl	800827c <HAL_NVIC_SetPriority>
       HAL_NVIC_EnableIRQ(USART1_IRQn);
 8014320:	2025      	movs	r0, #37	; 0x25
 8014322:	f7f3 ffc7 	bl	80082b4 <HAL_NVIC_EnableIRQ>
	   //HAL_UART3_MspInit(huart);
    }
	
    if (huart->Instance == USART3)
 8014326:	687b      	ldr	r3, [r7, #4]
 8014328:	681b      	ldr	r3, [r3, #0]
 801432a:	4a2a      	ldr	r2, [pc, #168]	; (80143d4 <HAL_UART_MspInit+0x150>)
 801432c:	4293      	cmp	r3, r2
 801432e:	d147      	bne.n	80143c0 <HAL_UART_MspInit+0x13c>
    {
		/* Enable GPIO TX/RX clock */
        USART3_TX_GPIO_CLK_ENABLE();
 8014330:	4a26      	ldr	r2, [pc, #152]	; (80143cc <HAL_UART_MspInit+0x148>)
 8014332:	4b26      	ldr	r3, [pc, #152]	; (80143cc <HAL_UART_MspInit+0x148>)
 8014334:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014336:	f043 0304 	orr.w	r3, r3, #4
 801433a:	6313      	str	r3, [r2, #48]	; 0x30
 801433c:	4b23      	ldr	r3, [pc, #140]	; (80143cc <HAL_UART_MspInit+0x148>)
 801433e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014340:	f003 0304 	and.w	r3, r3, #4
 8014344:	617b      	str	r3, [r7, #20]
 8014346:	697b      	ldr	r3, [r7, #20]
        USART3_RX_GPIO_CLK_ENABLE();
 8014348:	4a20      	ldr	r2, [pc, #128]	; (80143cc <HAL_UART_MspInit+0x148>)
 801434a:	4b20      	ldr	r3, [pc, #128]	; (80143cc <HAL_UART_MspInit+0x148>)
 801434c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801434e:	f043 0304 	orr.w	r3, r3, #4
 8014352:	6313      	str	r3, [r2, #48]	; 0x30
 8014354:	4b1d      	ldr	r3, [pc, #116]	; (80143cc <HAL_UART_MspInit+0x148>)
 8014356:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014358:	f003 0304 	and.w	r3, r3, #4
 801435c:	613b      	str	r3, [r7, #16]
 801435e:	693b      	ldr	r3, [r7, #16]
        /* Enable USARTx clock */
        USART3_CLK_ENABLE();
 8014360:	4a1a      	ldr	r2, [pc, #104]	; (80143cc <HAL_UART_MspInit+0x148>)
 8014362:	4b1a      	ldr	r3, [pc, #104]	; (80143cc <HAL_UART_MspInit+0x148>)
 8014364:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8014366:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 801436a:	6413      	str	r3, [r2, #64]	; 0x40
 801436c:	4b17      	ldr	r3, [pc, #92]	; (80143cc <HAL_UART_MspInit+0x148>)
 801436e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8014370:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8014374:	60fb      	str	r3, [r7, #12]
 8014376:	68fb      	ldr	r3, [r7, #12]

        /* UART TX GPIO pin configuration  */
        GPIO_InitStruct.Pin       = USART3_TX_PIN;
 8014378:	f44f 6380 	mov.w	r3, #1024	; 0x400
 801437c:	627b      	str	r3, [r7, #36]	; 0x24
        GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 801437e:	2302      	movs	r3, #2
 8014380:	62bb      	str	r3, [r7, #40]	; 0x28
        GPIO_InitStruct.Pull      = GPIO_PULLUP;
 8014382:	2301      	movs	r3, #1
 8014384:	62fb      	str	r3, [r7, #44]	; 0x2c
        GPIO_InitStruct.Speed     = GPIO_SPEED_HIGH;
 8014386:	2303      	movs	r3, #3
 8014388:	633b      	str	r3, [r7, #48]	; 0x30
        GPIO_InitStruct.Alternate = USART3_TX_AF;
 801438a:	2307      	movs	r3, #7
 801438c:	637b      	str	r3, [r7, #52]	; 0x34
        HAL_GPIO_Init(USART3_TX_GPIO_PORT, &GPIO_InitStruct);
 801438e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8014392:	4811      	ldr	r0, [pc, #68]	; (80143d8 <HAL_UART_MspInit+0x154>)
 8014394:	4619      	mov	r1, r3
 8014396:	f7f8 fc55 	bl	800cc44 <HAL_GPIO_Init>

        /* UART RX GPIO pin configuration  */
        GPIO_InitStruct.Pin = USART3_RX_PIN;
 801439a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 801439e:	627b      	str	r3, [r7, #36]	; 0x24
        GPIO_InitStruct.Alternate = USART3_RX_AF;
 80143a0:	2307      	movs	r3, #7
 80143a2:	637b      	str	r3, [r7, #52]	; 0x34
        HAL_GPIO_Init(USART3_RX_GPIO_PORT, &GPIO_InitStruct);
 80143a4:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80143a8:	480b      	ldr	r0, [pc, #44]	; (80143d8 <HAL_UART_MspInit+0x154>)
 80143aa:	4619      	mov	r1, r3
 80143ac:	f7f8 fc4a 	bl	800cc44 <HAL_GPIO_Init>

        /* NVIC for USART */
        HAL_NVIC_SetPriority(USART3_IRQn, USART3_IRQ_PREEMPT ,USART3_TRQ_SUB);
 80143b0:	2027      	movs	r0, #39	; 0x27
 80143b2:	210f      	movs	r1, #15
 80143b4:	2200      	movs	r2, #0
 80143b6:	f7f3 ff61 	bl	800827c <HAL_NVIC_SetPriority>
      	HAL_NVIC_EnableIRQ(USART3_IRQn);
 80143ba:	2027      	movs	r0, #39	; 0x27
 80143bc:	f7f3 ff7a 	bl	80082b4 <HAL_NVIC_EnableIRQ>
    }
}
 80143c0:	3738      	adds	r7, #56	; 0x38
 80143c2:	46bd      	mov	sp, r7
 80143c4:	bd80      	pop	{r7, pc}
 80143c6:	bf00      	nop
 80143c8:	40011000 	.word	0x40011000
 80143cc:	40023800 	.word	0x40023800
 80143d0:	40020000 	.word	0x40020000
 80143d4:	40004800 	.word	0x40004800
 80143d8:	40020800 	.word	0x40020800

080143dc <HAL_UART_MspDeInit>:
  *          - Revert GPIO and NVIC configuration to their default state
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
{
 80143dc:	b580      	push	{r7, lr}
 80143de:	b082      	sub	sp, #8
 80143e0:	af00      	add	r7, sp, #0
 80143e2:	6078      	str	r0, [r7, #4]
    if (huart->Instance == USART1)
 80143e4:	687b      	ldr	r3, [r7, #4]
 80143e6:	681b      	ldr	r3, [r3, #0]
 80143e8:	4a1e      	ldr	r2, [pc, #120]	; (8014464 <HAL_UART_MspDeInit+0x88>)
 80143ea:	4293      	cmp	r3, r2
 80143ec:	d118      	bne.n	8014420 <HAL_UART_MspDeInit+0x44>
    {
        /* Reset peripherals */
        USART1_FORCE_RESET();
 80143ee:	4a1e      	ldr	r2, [pc, #120]	; (8014468 <HAL_UART_MspDeInit+0x8c>)
 80143f0:	4b1d      	ldr	r3, [pc, #116]	; (8014468 <HAL_UART_MspDeInit+0x8c>)
 80143f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80143f4:	f043 0310 	orr.w	r3, r3, #16
 80143f8:	6253      	str	r3, [r2, #36]	; 0x24
        USART1_RELEASE_RESET();
 80143fa:	4a1b      	ldr	r2, [pc, #108]	; (8014468 <HAL_UART_MspDeInit+0x8c>)
 80143fc:	4b1a      	ldr	r3, [pc, #104]	; (8014468 <HAL_UART_MspDeInit+0x8c>)
 80143fe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014400:	f023 0310 	bic.w	r3, r3, #16
 8014404:	6253      	str	r3, [r2, #36]	; 0x24

        /* Disable peripherals and GPIO Clocks */
        /* Configure UART Tx as alternate function  */
        HAL_GPIO_DeInit(USART1_TX_GPIO_PORT, USART1_TX_PIN);
 8014406:	4819      	ldr	r0, [pc, #100]	; (801446c <HAL_UART_MspDeInit+0x90>)
 8014408:	f44f 7100 	mov.w	r1, #512	; 0x200
 801440c:	f7f8 fdc0 	bl	800cf90 <HAL_GPIO_DeInit>
        /* Configure UART Rx as alternate function  */
        HAL_GPIO_DeInit(USART1_RX_GPIO_PORT, USART1_RX_PIN);
 8014410:	4816      	ldr	r0, [pc, #88]	; (801446c <HAL_UART_MspDeInit+0x90>)
 8014412:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8014416:	f7f8 fdbb 	bl	800cf90 <HAL_GPIO_DeInit>

        /* Disable the NVIC for UART */
        HAL_NVIC_DisableIRQ(USART1_IRQn);
 801441a:	2025      	movs	r0, #37	; 0x25
 801441c:	f7f3 ff58 	bl	80082d0 <HAL_NVIC_DisableIRQ>
    }
	//HAL_UART3_MspDeInit(huart);
	
    if (huart->Instance == USART3)
 8014420:	687b      	ldr	r3, [r7, #4]
 8014422:	681b      	ldr	r3, [r3, #0]
 8014424:	4a12      	ldr	r2, [pc, #72]	; (8014470 <HAL_UART_MspDeInit+0x94>)
 8014426:	4293      	cmp	r3, r2
 8014428:	d118      	bne.n	801445c <HAL_UART_MspDeInit+0x80>
    {
        /* Reset peripherals */
        USART3_FORCE_RESET();
 801442a:	4a0f      	ldr	r2, [pc, #60]	; (8014468 <HAL_UART_MspDeInit+0x8c>)
 801442c:	4b0e      	ldr	r3, [pc, #56]	; (8014468 <HAL_UART_MspDeInit+0x8c>)
 801442e:	6a1b      	ldr	r3, [r3, #32]
 8014430:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8014434:	6213      	str	r3, [r2, #32]
        USART3_RELEASE_RESET();
 8014436:	4a0c      	ldr	r2, [pc, #48]	; (8014468 <HAL_UART_MspDeInit+0x8c>)
 8014438:	4b0b      	ldr	r3, [pc, #44]	; (8014468 <HAL_UART_MspDeInit+0x8c>)
 801443a:	6a1b      	ldr	r3, [r3, #32]
 801443c:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8014440:	6213      	str	r3, [r2, #32]

        /* Disable peripherals and GPIO Clocks */
        /* Configure UART Tx as alternate function  */
        HAL_GPIO_DeInit(USART3_TX_GPIO_PORT, USART3_TX_PIN);
 8014442:	480c      	ldr	r0, [pc, #48]	; (8014474 <HAL_UART_MspDeInit+0x98>)
 8014444:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8014448:	f7f8 fda2 	bl	800cf90 <HAL_GPIO_DeInit>
        /* Configure UART Rx as alternate function  */
        HAL_GPIO_DeInit(USART3_RX_GPIO_PORT, USART3_RX_PIN);
 801444c:	4809      	ldr	r0, [pc, #36]	; (8014474 <HAL_UART_MspDeInit+0x98>)
 801444e:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8014452:	f7f8 fd9d 	bl	800cf90 <HAL_GPIO_DeInit>

        /* Disable the NVIC for UART */
        HAL_NVIC_DisableIRQ(USART3_IRQn);
 8014456:	2027      	movs	r0, #39	; 0x27
 8014458:	f7f3 ff3a 	bl	80082d0 <HAL_NVIC_DisableIRQ>
    }
}
 801445c:	3708      	adds	r7, #8
 801445e:	46bd      	mov	sp, r7
 8014460:	bd80      	pop	{r7, pc}
 8014462:	bf00      	nop
 8014464:	40011000 	.word	0x40011000
 8014468:	40023800 	.word	0x40023800
 801446c:	40020000 	.word	0x40020000
 8014470:	40004800 	.word	0x40004800
 8014474:	40020800 	.word	0x40020800

08014478 <stm32_hw_usart_init>:

int stm32_hw_usart_init(void)
{
 8014478:	b580      	push	{r7, lr}
 801447a:	b086      	sub	sp, #24
 801447c:	af00      	add	r7, sp, #0
    struct stm32_uart *uart;
    struct serial_configure config = RT_SERIAL_CONFIG_DEFAULT;
 801447e:	4a1f      	ldr	r2, [pc, #124]	; (80144fc <stm32_hw_usart_init+0x84>)
 8014480:	f107 030c 	add.w	r3, r7, #12
 8014484:	e892 0003 	ldmia.w	r2, {r0, r1}
 8014488:	e883 0003 	stmia.w	r3, {r0, r1}

#ifdef RT_USING_UART1
    uart = &uart1;
 801448c:	4b1c      	ldr	r3, [pc, #112]	; (8014500 <stm32_hw_usart_init+0x88>)
 801448e:	617b      	str	r3, [r7, #20]
    uart->UartHandle.Instance = USART1;
 8014490:	697b      	ldr	r3, [r7, #20]
 8014492:	4a1c      	ldr	r2, [pc, #112]	; (8014504 <stm32_hw_usart_init+0x8c>)
 8014494:	601a      	str	r2, [r3, #0]

    serial1.ops    = &stm32_uart_ops;
 8014496:	4b1c      	ldr	r3, [pc, #112]	; (8014508 <stm32_hw_usart_init+0x90>)
 8014498:	4a1c      	ldr	r2, [pc, #112]	; (801450c <stm32_hw_usart_init+0x94>)
 801449a:	641a      	str	r2, [r3, #64]	; 0x40
    serial1.config = config;
 801449c:	4b1a      	ldr	r3, [pc, #104]	; (8014508 <stm32_hw_usart_init+0x90>)
 801449e:	3344      	adds	r3, #68	; 0x44
 80144a0:	f107 020c 	add.w	r2, r7, #12
 80144a4:	e892 0003 	ldmia.w	r2, {r0, r1}
 80144a8:	e883 0003 	stmia.w	r3, {r0, r1}

    /* register UART1 device */
    rt_hw_serial_register(&serial1, "uart1",
 80144ac:	4816      	ldr	r0, [pc, #88]	; (8014508 <stm32_hw_usart_init+0x90>)
 80144ae:	4918      	ldr	r1, [pc, #96]	; (8014510 <stm32_hw_usart_init+0x98>)
 80144b0:	f240 1203 	movw	r2, #259	; 0x103
 80144b4:	697b      	ldr	r3, [r7, #20]
 80144b6:	f006 fb63 	bl	801ab80 <rt_hw_serial_register>
                          RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX,
                          uart);
#endif /* RT_USING_UART1 */

#ifdef RT_USING_UART3
		uart = &uart3;
 80144ba:	4b16      	ldr	r3, [pc, #88]	; (8014514 <stm32_hw_usart_init+0x9c>)
 80144bc:	617b      	str	r3, [r7, #20]
		uart->UartHandle.Instance = USART3;
 80144be:	697b      	ldr	r3, [r7, #20]
 80144c0:	4a15      	ldr	r2, [pc, #84]	; (8014518 <stm32_hw_usart_init+0xa0>)
 80144c2:	601a      	str	r2, [r3, #0]
		struct serial_configure config_uart3 = RT_SERIAL_CONFIG_UART3;
 80144c4:	4a15      	ldr	r2, [pc, #84]	; (801451c <stm32_hw_usart_init+0xa4>)
 80144c6:	1d3b      	adds	r3, r7, #4
 80144c8:	e892 0003 	ldmia.w	r2, {r0, r1}
 80144cc:	e883 0003 	stmia.w	r3, {r0, r1}
		
		serial3.ops    = &stm32_uart_ops;
 80144d0:	4b13      	ldr	r3, [pc, #76]	; (8014520 <stm32_hw_usart_init+0xa8>)
 80144d2:	4a0e      	ldr	r2, [pc, #56]	; (801450c <stm32_hw_usart_init+0x94>)
 80144d4:	641a      	str	r2, [r3, #64]	; 0x40
		serial3.config = config_uart3;
 80144d6:	4b12      	ldr	r3, [pc, #72]	; (8014520 <stm32_hw_usart_init+0xa8>)
 80144d8:	3344      	adds	r3, #68	; 0x44
 80144da:	1d3a      	adds	r2, r7, #4
 80144dc:	e892 0003 	ldmia.w	r2, {r0, r1}
 80144e0:	e883 0003 	stmia.w	r3, {r0, r1}
	
		/* register UART1 device */
		rt_hw_serial_register(&serial3, "uart3",
 80144e4:	480e      	ldr	r0, [pc, #56]	; (8014520 <stm32_hw_usart_init+0xa8>)
 80144e6:	490f      	ldr	r1, [pc, #60]	; (8014524 <stm32_hw_usart_init+0xac>)
 80144e8:	f240 1203 	movw	r2, #259	; 0x103
 80144ec:	697b      	ldr	r3, [r7, #20]
 80144ee:	f006 fb47 	bl	801ab80 <rt_hw_serial_register>
							  RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX,
							  uart);
#endif /* RT_USING_UART3 */


    return 0;
 80144f2:	2300      	movs	r3, #0
}
 80144f4:	4618      	mov	r0, r3
 80144f6:	3718      	adds	r7, #24
 80144f8:	46bd      	mov	sp, r7
 80144fa:	bd80      	pop	{r7, pc}
 80144fc:	08028968 	.word	0x08028968
 8014500:	2001091c 	.word	0x2001091c
 8014504:	40011000 	.word	0x40011000
 8014508:	20012944 	.word	0x20012944
 801450c:	0802a530 	.word	0x0802a530
 8014510:	08028958 	.word	0x08028958
 8014514:	20010990 	.word	0x20010990
 8014518:	40004800 	.word	0x40004800
 801451c:	08028970 	.word	0x08028970
 8014520:	20012998 	.word	0x20012998
 8014524:	08028960 	.word	0x08028960

08014528 <NMI_Handler>:
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 8014528:	b480      	push	{r7}
 801452a:	af00      	add	r7, sp, #0
}
 801452c:	46bd      	mov	sp, r7
 801452e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014532:	4770      	bx	lr

08014534 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 8014534:	b480      	push	{r7}
 8014536:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
  {
  }
 8014538:	e7fe      	b.n	8014538 <BusFault_Handler+0x4>
 801453a:	bf00      	nop

0801453c <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 801453c:	b480      	push	{r7}
 801453e:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
  {
  }
 8014540:	e7fe      	b.n	8014540 <UsageFault_Handler+0x4>
 8014542:	bf00      	nop

08014544 <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 8014544:	b480      	push	{r7}
 8014546:	af00      	add	r7, sp, #0
}
 8014548:	46bd      	mov	sp, r7
 801454a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801454e:	4770      	bx	lr

08014550 <J1939_TxdTask_entry>:
unsigned char *data;

#if 1

void J1939_TxdTask_entry(void *parameter)
{
 8014550:	b580      	push	{r7, lr}
 8014552:	b084      	sub	sp, #16
 8014554:	af00      	add	r7, sp, #0
 8014556:	6078      	str	r0, [r7, #4]
    rt_thread_t tid;
	
	//ca_msg.CAname = &caname;
	//ca_msg.msg.SourceAddress = DEFAULTADDRCA1;
	
	if(ca_msg != NULL)
 8014558:	4b0d      	ldr	r3, [pc, #52]	; (8014590 <J1939_TxdTask_entry+0x40>)
 801455a:	681b      	ldr	r3, [r3, #0]
 801455c:	2b00      	cmp	r3, #0
 801455e:	d00d      	beq.n	801457c <J1939_TxdTask_entry+0x2c>
	{
		if (sendMessage(ca_msg,data)== RC_ERROR)
 8014560:	4b0b      	ldr	r3, [pc, #44]	; (8014590 <J1939_TxdTask_entry+0x40>)
 8014562:	681a      	ldr	r2, [r3, #0]
 8014564:	4b0b      	ldr	r3, [pc, #44]	; (8014594 <J1939_TxdTask_entry+0x44>)
 8014566:	681b      	ldr	r3, [r3, #0]
 8014568:	4610      	mov	r0, r2
 801456a:	4619      	mov	r1, r3
 801456c:	f7fb ff1a 	bl	80103a4 <sendMessage>
 8014570:	4603      	mov	r3, r0
 8014572:	2b01      	cmp	r3, #1
 8014574:	d102      	bne.n	801457c <J1939_TxdTask_entry+0x2c>
			rt_kprintf("rc_error\r\n");
 8014576:	4808      	ldr	r0, [pc, #32]	; (8014598 <J1939_TxdTask_entry+0x48>)
 8014578:	f002 fdca 	bl	8017110 <rt_kprintf>
	}
	tid = rt_thread_self();
 801457c:	f003 ff8c 	bl	8018498 <rt_thread_self>
 8014580:	60f8      	str	r0, [r7, #12]
	rt_thread_delete(tid);
 8014582:	68f8      	ldr	r0, [r7, #12]
 8014584:	f004 f804 	bl	8018590 <rt_thread_delete>

}
 8014588:	3710      	adds	r7, #16
 801458a:	46bd      	mov	sp, r7
 801458c:	bd80      	pop	{r7, pc}
 801458e:	bf00      	nop
 8014590:	200129f0 	.word	0x200129f0
 8014594:	200129ec 	.word	0x200129ec
 8014598:	08028978 	.word	0x08028978

0801459c <CANtx>:

void CANtx(int argc,char**argv)
{
 801459c:	b590      	push	{r4, r7, lr}
 801459e:	b089      	sub	sp, #36	; 0x24
 80145a0:	af02      	add	r7, sp, #8
 80145a2:	6078      	str	r0, [r7, #4]
 80145a4:	6039      	str	r1, [r7, #0]
		data[i] = 0x55;
	}
	sendMessage(&CA_msg,data);
	#endif
    rt_thread_t tid;
	unsigned int sendsize = atoi(argv[1]);
 80145a6:	683b      	ldr	r3, [r7, #0]
 80145a8:	3304      	adds	r3, #4
 80145aa:	681b      	ldr	r3, [r3, #0]
 80145ac:	4618      	mov	r0, r3
 80145ae:	f00d ff17 	bl	80223e0 <atoi>
 80145b2:	4603      	mov	r3, r0
 80145b4:	613b      	str	r3, [r7, #16]
	unsigned int i;
	if(data != NULL)
 80145b6:	4b36      	ldr	r3, [pc, #216]	; (8014690 <CANtx+0xf4>)
 80145b8:	681b      	ldr	r3, [r3, #0]
 80145ba:	2b00      	cmp	r3, #0
 80145bc:	d006      	beq.n	80145cc <CANtx+0x30>
		data = (unsigned char *)malloc(sendsize * sizeof(char));
 80145be:	6938      	ldr	r0, [r7, #16]
 80145c0:	f00e f84c 	bl	802265c <malloc>
 80145c4:	4603      	mov	r3, r0
 80145c6:	461a      	mov	r2, r3
 80145c8:	4b31      	ldr	r3, [pc, #196]	; (8014690 <CANtx+0xf4>)
 80145ca:	601a      	str	r2, [r3, #0]

	ca_msg->sendbytes = sendsize;
 80145cc:	4b31      	ldr	r3, [pc, #196]	; (8014694 <CANtx+0xf8>)
 80145ce:	681b      	ldr	r3, [r3, #0]
 80145d0:	693a      	ldr	r2, [r7, #16]
 80145d2:	b292      	uxth	r2, r2
 80145d4:	829a      	strh	r2, [r3, #20]
	ca_msg->msg.DataPage = 0;
 80145d6:	4b2f      	ldr	r3, [pc, #188]	; (8014694 <CANtx+0xf8>)
 80145d8:	681a      	ldr	r2, [r3, #0]
 80145da:	7913      	ldrb	r3, [r2, #4]
 80145dc:	f36f 03c3 	bfc	r3, #3, #1
 80145e0:	7113      	strb	r3, [r2, #4]
	ca_msg->msg.edp =0;
 80145e2:	4b2c      	ldr	r3, [pc, #176]	; (8014694 <CANtx+0xf8>)
 80145e4:	681a      	ldr	r2, [r3, #0]
 80145e6:	7913      	ldrb	r3, [r2, #4]
 80145e8:	f36f 1304 	bfc	r3, #4, #1
 80145ec:	7113      	strb	r3, [r2, #4]
	ca_msg->msg.PDUFormat = atoi(argv[2]);
 80145ee:	4b29      	ldr	r3, [pc, #164]	; (8014694 <CANtx+0xf8>)
 80145f0:	681c      	ldr	r4, [r3, #0]
 80145f2:	683b      	ldr	r3, [r7, #0]
 80145f4:	3308      	adds	r3, #8
 80145f6:	681b      	ldr	r3, [r3, #0]
 80145f8:	4618      	mov	r0, r3
 80145fa:	f00d fef1 	bl	80223e0 <atoi>
 80145fe:	4603      	mov	r3, r0
 8014600:	b2db      	uxtb	r3, r3
 8014602:	7163      	strb	r3, [r4, #5]
	ca_msg->msg.PDUSpecific = atoi(argv[3]);
 8014604:	4b23      	ldr	r3, [pc, #140]	; (8014694 <CANtx+0xf8>)
 8014606:	681c      	ldr	r4, [r3, #0]
 8014608:	683b      	ldr	r3, [r7, #0]
 801460a:	330c      	adds	r3, #12
 801460c:	681b      	ldr	r3, [r3, #0]
 801460e:	4618      	mov	r0, r3
 8014610:	f00d fee6 	bl	80223e0 <atoi>
 8014614:	4603      	mov	r3, r0
 8014616:	b2db      	uxtb	r3, r3
 8014618:	71a3      	strb	r3, [r4, #6]
	ca_msg->msg.Priority = 6;
 801461a:	4b1e      	ldr	r3, [pc, #120]	; (8014694 <CANtx+0xf8>)
 801461c:	681a      	ldr	r2, [r3, #0]
 801461e:	7913      	ldrb	r3, [r2, #4]
 8014620:	2106      	movs	r1, #6
 8014622:	f361 1347 	bfi	r3, r1, #5, #3
 8014626:	7113      	strb	r3, [r2, #4]
	
	for(i=0;i<sendsize;i++)
 8014628:	2300      	movs	r3, #0
 801462a:	617b      	str	r3, [r7, #20]
 801462c:	e00b      	b.n	8014646 <CANtx+0xaa>
		data[i] = i+1;
 801462e:	4b18      	ldr	r3, [pc, #96]	; (8014690 <CANtx+0xf4>)
 8014630:	681a      	ldr	r2, [r3, #0]
 8014632:	697b      	ldr	r3, [r7, #20]
 8014634:	4413      	add	r3, r2
 8014636:	697a      	ldr	r2, [r7, #20]
 8014638:	b2d2      	uxtb	r2, r2
 801463a:	3201      	adds	r2, #1
 801463c:	b2d2      	uxtb	r2, r2
 801463e:	701a      	strb	r2, [r3, #0]
	ca_msg->msg.edp =0;
	ca_msg->msg.PDUFormat = atoi(argv[2]);
	ca_msg->msg.PDUSpecific = atoi(argv[3]);
	ca_msg->msg.Priority = 6;
	
	for(i=0;i<sendsize;i++)
 8014640:	697b      	ldr	r3, [r7, #20]
 8014642:	3301      	adds	r3, #1
 8014644:	617b      	str	r3, [r7, #20]
 8014646:	697a      	ldr	r2, [r7, #20]
 8014648:	693b      	ldr	r3, [r7, #16]
 801464a:	429a      	cmp	r2, r3
 801464c:	d3ef      	bcc.n	801462e <CANtx+0x92>
		data[i] = i+1;

	tid = rt_thread_create("J1939txd",						
 801464e:	230a      	movs	r3, #10
 8014650:	9300      	str	r3, [sp, #0]
 8014652:	2314      	movs	r3, #20
 8014654:	9301      	str	r3, [sp, #4]
 8014656:	4810      	ldr	r0, [pc, #64]	; (8014698 <CANtx+0xfc>)
 8014658:	4910      	ldr	r1, [pc, #64]	; (801469c <CANtx+0x100>)
 801465a:	2200      	movs	r2, #0
 801465c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8014660:	f003 ff64 	bl	801852c <rt_thread_create>
 8014664:	60f8      	str	r0, [r7, #12]
                          J1939_TxdTask_entry, RT_NULL,
                           1024, J1939_TXDTASK_PRIORITY, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 8014666:	68fb      	ldr	r3, [r7, #12]
 8014668:	2b00      	cmp	r3, #0
 801466a:	d002      	beq.n	8014672 <CANtx+0xd6>
 801466c:	68f8      	ldr	r0, [r7, #12]
 801466e:	f003 ff1f 	bl	80184b0 <rt_thread_startup>
	if(data != NULL)
 8014672:	4b07      	ldr	r3, [pc, #28]	; (8014690 <CANtx+0xf4>)
 8014674:	681b      	ldr	r3, [r3, #0]
 8014676:	2b00      	cmp	r3, #0
 8014678:	d007      	beq.n	801468a <CANtx+0xee>
	{
		free(data);
 801467a:	4b05      	ldr	r3, [pc, #20]	; (8014690 <CANtx+0xf4>)
 801467c:	681b      	ldr	r3, [r3, #0]
 801467e:	4618      	mov	r0, r3
 8014680:	f00d fff4 	bl	802266c <free>
		data = NULL;
 8014684:	4b02      	ldr	r3, [pc, #8]	; (8014690 <CANtx+0xf4>)
 8014686:	2200      	movs	r2, #0
 8014688:	601a      	str	r2, [r3, #0]
	}
}
 801468a:	371c      	adds	r7, #28
 801468c:	46bd      	mov	sp, r7
 801468e:	bd90      	pop	{r4, r7, pc}
 8014690:	200129ec 	.word	0x200129ec
 8014694:	200129f0 	.word	0x200129f0
 8014698:	08028984 	.word	0x08028984
 801469c:	08014551 	.word	0x08014551

080146a0 <USER_CanTask_entry>:
#endif



void USER_CanTask_entry(void *parameter)
{
 80146a0:	b580      	push	{r7, lr}
 80146a2:	b08a      	sub	sp, #40	; 0x28
 80146a4:	af00      	add	r7, sp, #0
 80146a6:	6078      	str	r0, [r7, #4]
			rt_kprintf("\r\n");
		}
		rt_thread_delay(20);
	}
	#endif
	struct J1939_CAname caname = CA1;
 80146a8:	4a3e      	ldr	r2, [pc, #248]	; (80147a4 <USER_CanTask_entry+0x104>)
 80146aa:	f107 0314 	add.w	r3, r7, #20
 80146ae:	e892 0003 	ldmia.w	r2, {r0, r1}
 80146b2:	e883 0003 	stmia.w	r3, {r0, r1}
	rt_size_t size;
	
    osEvent event;
	struct rx_Message *rxmsg;
	
	device = rt_device_find("can1");
 80146b6:	483c      	ldr	r0, [pc, #240]	; (80147a8 <USER_CanTask_entry+0x108>)
 80146b8:	f000 fe9c 	bl	80153f4 <rt_device_find>
 80146bc:	6238      	str	r0, [r7, #32]
	
	if(device != RT_NULL)
 80146be:	6a3b      	ldr	r3, [r7, #32]
 80146c0:	2b00      	cmp	r3, #0
 80146c2:	d00a      	beq.n	80146da <USER_CanTask_entry+0x3a>
		if (rt_device_open (device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_INT_RX) != RT_EOK)
 80146c4:	6a38      	ldr	r0, [r7, #32]
 80146c6:	f240 1103 	movw	r1, #259	; 0x103
 80146ca:	f000 fecf 	bl	801546c <rt_device_open>
 80146ce:	4603      	mov	r3, r0
 80146d0:	2b00      	cmp	r3, #0
 80146d2:	d002      	beq.n	80146da <USER_CanTask_entry+0x3a>
		{
			rt_kprintf("open error\r\n");
 80146d4:	4835      	ldr	r0, [pc, #212]	; (80147ac <USER_CanTask_entry+0x10c>)
 80146d6:	f002 fd1b 	bl	8017110 <rt_kprintf>
		}
	
	initJ1939();
 80146da:	f7fc fdc5 	bl	8011268 <initJ1939>
	ca_msg = (CA_Msg_t)malloc(sizeof(struct CA_Msg));
 80146de:	2064      	movs	r0, #100	; 0x64
 80146e0:	f00d ffbc 	bl	802265c <malloc>
 80146e4:	4603      	mov	r3, r0
 80146e6:	461a      	mov	r2, r3
 80146e8:	4b31      	ldr	r3, [pc, #196]	; (80147b0 <USER_CanTask_entry+0x110>)
 80146ea:	601a      	str	r2, [r3, #0]
	if(ca_msg != NULL)
 80146ec:	4b30      	ldr	r3, [pc, #192]	; (80147b0 <USER_CanTask_entry+0x110>)
 80146ee:	681b      	ldr	r3, [r3, #0]
 80146f0:	2b00      	cmp	r3, #0
 80146f2:	d014      	beq.n	801471e <USER_CanTask_entry+0x7e>
	{
		
		memset(ca_msg,0,sizeof(struct CA_Msg));
 80146f4:	4b2e      	ldr	r3, [pc, #184]	; (80147b0 <USER_CanTask_entry+0x110>)
 80146f6:	681b      	ldr	r3, [r3, #0]
 80146f8:	4618      	mov	r0, r3
 80146fa:	2100      	movs	r1, #0
 80146fc:	2264      	movs	r2, #100	; 0x64
 80146fe:	f00d ffbd 	bl	802267c <memset>
		ca_msg->CAname = &caname;
 8014702:	4b2b      	ldr	r3, [pc, #172]	; (80147b0 <USER_CanTask_entry+0x110>)
 8014704:	681b      	ldr	r3, [r3, #0]
 8014706:	f107 0214 	add.w	r2, r7, #20
 801470a:	601a      	str	r2, [r3, #0]
		ca_msg->msg.SourceAddress = DEFAULTADDRCA1;
 801470c:	4b28      	ldr	r3, [pc, #160]	; (80147b0 <USER_CanTask_entry+0x110>)
 801470e:	681b      	ldr	r3, [r3, #0]
 8014710:	2223      	movs	r2, #35	; 0x23
 8014712:	71da      	strb	r2, [r3, #7]

		J1939_CA_register(ca_msg);
 8014714:	4b26      	ldr	r3, [pc, #152]	; (80147b0 <USER_CanTask_entry+0x110>)
 8014716:	681b      	ldr	r3, [r3, #0]
 8014718:	4618      	mov	r0, r3
 801471a:	f7fb fb29 	bl	800fd70 <J1939_CA_register>
		ca_msg->msg.PDUSpecific = 0x23;
		ca_msg->msg.Priority = 6;
		if (sendMessage(ca_msg,data)== RC_ERROR)
			rt_kprintf("rc_error\r\n");
		#endif
		event = osMessageGet(ca_msg->rxq, 20);
 801471e:	4b24      	ldr	r3, [pc, #144]	; (80147b0 <USER_CanTask_entry+0x110>)
 8014720:	681b      	ldr	r3, [r3, #0]
 8014722:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8014724:	f107 0208 	add.w	r2, r7, #8
 8014728:	4610      	mov	r0, r2
 801472a:	4619      	mov	r1, r3
 801472c:	2214      	movs	r2, #20
 801472e:	f004 feab 	bl	8019488 <osMessageGet>
		if(event.status == osEventMessage)
 8014732:	68bb      	ldr	r3, [r7, #8]
 8014734:	2b10      	cmp	r3, #16
 8014736:	d134      	bne.n	80147a2 <USER_CanTask_entry+0x102>
		{
			unsigned short i;

			rxmsg = event.value.p;
 8014738:	68fb      	ldr	r3, [r7, #12]
 801473a:	61fb      	str	r3, [r7, #28]
			if(rxmsg == NULL)
 801473c:	69fb      	ldr	r3, [r7, #28]
 801473e:	2b00      	cmp	r3, #0
 8014740:	d103      	bne.n	801474a <USER_CanTask_entry+0xaa>
			{
				rt_kprintf("val null\r\n");
 8014742:	481c      	ldr	r0, [pc, #112]	; (80147b4 <USER_CanTask_entry+0x114>)
 8014744:	f002 fce4 	bl	8017110 <rt_kprintf>
 8014748:	e02b      	b.n	80147a2 <USER_CanTask_entry+0x102>
			}
			else
			{
				rt_kprintf(" dp: %x\r\n", rxmsg->dp);
 801474a:	69fb      	ldr	r3, [r7, #28]
 801474c:	7a1b      	ldrb	r3, [r3, #8]
 801474e:	481a      	ldr	r0, [pc, #104]	; (80147b8 <USER_CanTask_entry+0x118>)
 8014750:	4619      	mov	r1, r3
 8014752:	f002 fcdd 	bl	8017110 <rt_kprintf>
				rt_kprintf("pf: %x \r\n", rxmsg->PF);
 8014756:	69fb      	ldr	r3, [r7, #28]
 8014758:	79db      	ldrb	r3, [r3, #7]
 801475a:	4818      	ldr	r0, [pc, #96]	; (80147bc <USER_CanTask_entry+0x11c>)
 801475c:	4619      	mov	r1, r3
 801475e:	f002 fcd7 	bl	8017110 <rt_kprintf>
				rt_kprintf("ps: %x \r\n", rxmsg->PS);
 8014762:	69fb      	ldr	r3, [r7, #28]
 8014764:	799b      	ldrb	r3, [r3, #6]
 8014766:	4816      	ldr	r0, [pc, #88]	; (80147c0 <USER_CanTask_entry+0x120>)
 8014768:	4619      	mov	r1, r3
 801476a:	f002 fcd1 	bl	8017110 <rt_kprintf>
				rt_kprintf("rcv data: ");
 801476e:	4815      	ldr	r0, [pc, #84]	; (80147c4 <USER_CanTask_entry+0x124>)
 8014770:	f002 fcce 	bl	8017110 <rt_kprintf>
				for(i = 0;i<rxmsg->size;i++)
 8014774:	2300      	movs	r3, #0
 8014776:	84fb      	strh	r3, [r7, #38]	; 0x26
 8014778:	e00b      	b.n	8014792 <USER_CanTask_entry+0xf2>
				{
					rt_kprintf("%x ", rxmsg->data[i]);
 801477a:	69fb      	ldr	r3, [r7, #28]
 801477c:	681a      	ldr	r2, [r3, #0]
 801477e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8014780:	4413      	add	r3, r2
 8014782:	781b      	ldrb	r3, [r3, #0]
 8014784:	4810      	ldr	r0, [pc, #64]	; (80147c8 <USER_CanTask_entry+0x128>)
 8014786:	4619      	mov	r1, r3
 8014788:	f002 fcc2 	bl	8017110 <rt_kprintf>
			{
				rt_kprintf(" dp: %x\r\n", rxmsg->dp);
				rt_kprintf("pf: %x \r\n", rxmsg->PF);
				rt_kprintf("ps: %x \r\n", rxmsg->PS);
				rt_kprintf("rcv data: ");
				for(i = 0;i<rxmsg->size;i++)
 801478c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801478e:	3301      	adds	r3, #1
 8014790:	84fb      	strh	r3, [r7, #38]	; 0x26
 8014792:	69fb      	ldr	r3, [r7, #28]
 8014794:	889b      	ldrh	r3, [r3, #4]
 8014796:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8014798:	429a      	cmp	r2, r3
 801479a:	d3ee      	bcc.n	801477a <USER_CanTask_entry+0xda>
				{
					rt_kprintf("%x ", rxmsg->data[i]);
				}
				rt_kprintf("\r\n");
 801479c:	480b      	ldr	r0, [pc, #44]	; (80147cc <USER_CanTask_entry+0x12c>)
 801479e:	f002 fcb7 	bl	8017110 <rt_kprintf>
			}
		}
		//rt_thread_delay(20);
	}
 80147a2:	e7bc      	b.n	801471e <USER_CanTask_entry+0x7e>
 80147a4:	080289ec 	.word	0x080289ec
 80147a8:	08028990 	.word	0x08028990
 80147ac:	08028998 	.word	0x08028998
 80147b0:	200129f0 	.word	0x200129f0
 80147b4:	080289a8 	.word	0x080289a8
 80147b8:	080289b4 	.word	0x080289b4
 80147bc:	080289c0 	.word	0x080289c0
 80147c0:	080289cc 	.word	0x080289cc
 80147c4:	080289d8 	.word	0x080289d8
 80147c8:	080289e4 	.word	0x080289e4
 80147cc:	080289e8 	.word	0x080289e8

080147d0 <USER_CanTask_init>:
}


int USER_CanTask_init()
{
 80147d0:	b580      	push	{r7, lr}
 80147d2:	b084      	sub	sp, #16
 80147d4:	af02      	add	r7, sp, #8
    rt_thread_t tid;
	
	tid = rt_thread_create("Can",						
 80147d6:	2309      	movs	r3, #9
 80147d8:	9300      	str	r3, [sp, #0]
 80147da:	2314      	movs	r3, #20
 80147dc:	9301      	str	r3, [sp, #4]
 80147de:	4809      	ldr	r0, [pc, #36]	; (8014804 <USER_CanTask_init+0x34>)
 80147e0:	4909      	ldr	r1, [pc, #36]	; (8014808 <USER_CanTask_init+0x38>)
 80147e2:	2200      	movs	r2, #0
 80147e4:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80147e8:	f003 fea0 	bl	801852c <rt_thread_create>
 80147ec:	6078      	str	r0, [r7, #4]
                           USER_CanTask_entry, RT_NULL,
                           2048, USER_CANTASK_PRIORITY, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 80147ee:	687b      	ldr	r3, [r7, #4]
 80147f0:	2b00      	cmp	r3, #0
 80147f2:	d002      	beq.n	80147fa <USER_CanTask_init+0x2a>
 80147f4:	6878      	ldr	r0, [r7, #4]
 80147f6:	f003 fe5b 	bl	80184b0 <rt_thread_startup>

    return 0;
 80147fa:	2300      	movs	r3, #0
}
 80147fc:	4618      	mov	r0, r3
 80147fe:	3708      	adds	r7, #8
 8014800:	46bd      	mov	sp, r7
 8014802:	bd80      	pop	{r7, pc}
 8014804:	080289f4 	.word	0x080289f4
 8014808:	080146a1 	.word	0x080146a1

0801480c <can_input>:
INIT_APP_EXPORT(USER_CanTask_init);

static rt_sem_t can_rx_sem;

static rt_err_t can_input(rt_device_t dev, rt_size_t size)
{
 801480c:	b580      	push	{r7, lr}
 801480e:	b082      	sub	sp, #8
 8014810:	af00      	add	r7, sp, #0
 8014812:	6078      	str	r0, [r7, #4]
 8014814:	6039      	str	r1, [r7, #0]
	rt_sem_release(can_rx_sem);
 8014816:	4b05      	ldr	r3, [pc, #20]	; (801482c <can_input+0x20>)
 8014818:	681b      	ldr	r3, [r3, #0]
 801481a:	4618      	mov	r0, r3
 801481c:	f001 fa08 	bl	8015c30 <rt_sem_release>
	return RT_EOK;
 8014820:	2300      	movs	r3, #0
}
 8014822:	4618      	mov	r0, r3
 8014824:	3708      	adds	r7, #8
 8014826:	46bd      	mov	sp, r7
 8014828:	bd80      	pop	{r7, pc}
 801482a:	bf00      	nop
 801482c:	20010a54 	.word	0x20010a54

08014830 <J1939_RcvTask_entry>:


void J1939_RcvTask_entry(void *parameter)
{
 8014830:	b580      	push	{r7, lr}
 8014832:	b084      	sub	sp, #16
 8014834:	af00      	add	r7, sp, #0
 8014836:	6078      	str	r0, [r7, #4]
	rt_device_t device;
	rt_err_t result;
	device = rt_device_find("can1");
 8014838:	480c      	ldr	r0, [pc, #48]	; (801486c <J1939_RcvTask_entry+0x3c>)
 801483a:	f000 fddb 	bl	80153f4 <rt_device_find>
 801483e:	60f8      	str	r0, [r7, #12]
	
	if ( device != RT_NULL )
 8014840:	68fb      	ldr	r3, [r7, #12]
 8014842:	2b00      	cmp	r3, #0
 8014844:	d003      	beq.n	801484e <J1939_RcvTask_entry+0x1e>
	{
		rt_device_set_rx_indicate(device, can_input);
 8014846:	68f8      	ldr	r0, [r7, #12]
 8014848:	4909      	ldr	r1, [pc, #36]	; (8014870 <J1939_RcvTask_entry+0x40>)
 801484a:	f000 ff4f 	bl	80156ec <rt_device_set_rx_indicate>
		#endif
	}

	while(1)
	{
		result = rt_sem_take(can_rx_sem, RT_WAITING_FOREVER);
 801484e:	4b09      	ldr	r3, [pc, #36]	; (8014874 <J1939_RcvTask_entry+0x44>)
 8014850:	681b      	ldr	r3, [r3, #0]
 8014852:	4618      	mov	r0, r3
 8014854:	f04f 31ff 	mov.w	r1, #4294967295
 8014858:	f001 f946 	bl	8015ae8 <rt_sem_take>
 801485c:	60b8      	str	r0, [r7, #8]
		if (result == RT_EOK)
 801485e:	68bb      	ldr	r3, [r7, #8]
 8014860:	2b00      	cmp	r3, #0
 8014862:	d101      	bne.n	8014868 <J1939_RcvTask_entry+0x38>
		{
			receiveMessage();
 8014864:	f7fc fa42 	bl	8010cec <receiveMessage>
		}
	}
 8014868:	e7f1      	b.n	801484e <J1939_RcvTask_entry+0x1e>
 801486a:	bf00      	nop
 801486c:	08028990 	.word	0x08028990
 8014870:	0801480d 	.word	0x0801480d
 8014874:	20010a54 	.word	0x20010a54

08014878 <J1939_RcvTask_init>:
}

int J1939_RcvTask_init()
{
 8014878:	b580      	push	{r7, lr}
 801487a:	b084      	sub	sp, #16
 801487c:	af02      	add	r7, sp, #8
    rt_thread_t tid;

	
	if ((can_rx_sem = rt_sem_create("J1939rcv", 0, RT_IPC_FLAG_FIFO)) == RT_NULL)
 801487e:	4813      	ldr	r0, [pc, #76]	; (80148cc <J1939_RcvTask_init+0x54>)
 8014880:	2100      	movs	r1, #0
 8014882:	2200      	movs	r2, #0
 8014884:	f001 f8f4 	bl	8015a70 <rt_sem_create>
 8014888:	4602      	mov	r2, r0
 801488a:	4b11      	ldr	r3, [pc, #68]	; (80148d0 <J1939_RcvTask_init+0x58>)
 801488c:	601a      	str	r2, [r3, #0]
 801488e:	4b10      	ldr	r3, [pc, #64]	; (80148d0 <J1939_RcvTask_init+0x58>)
 8014890:	681b      	ldr	r3, [r3, #0]
 8014892:	2b00      	cmp	r3, #0
 8014894:	d102      	bne.n	801489c <J1939_RcvTask_init+0x24>
	{
		rt_kprintf("can_rx_sem create error\r\n");
 8014896:	480f      	ldr	r0, [pc, #60]	; (80148d4 <J1939_RcvTask_init+0x5c>)
 8014898:	f002 fc3a 	bl	8017110 <rt_kprintf>
	}
	
	tid = rt_thread_create("J1939Rcv",						
 801489c:	230a      	movs	r3, #10
 801489e:	9300      	str	r3, [sp, #0]
 80148a0:	2314      	movs	r3, #20
 80148a2:	9301      	str	r3, [sp, #4]
 80148a4:	480c      	ldr	r0, [pc, #48]	; (80148d8 <J1939_RcvTask_init+0x60>)
 80148a6:	490d      	ldr	r1, [pc, #52]	; (80148dc <J1939_RcvTask_init+0x64>)
 80148a8:	2200      	movs	r2, #0
 80148aa:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80148ae:	f003 fe3d 	bl	801852c <rt_thread_create>
 80148b2:	6078      	str	r0, [r7, #4]
                          J1939_RcvTask_entry, RT_NULL,
                           1024, J1939_RCVTASK_PRIORITY, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 80148b4:	687b      	ldr	r3, [r7, #4]
 80148b6:	2b00      	cmp	r3, #0
 80148b8:	d002      	beq.n	80148c0 <J1939_RcvTask_init+0x48>
 80148ba:	6878      	ldr	r0, [r7, #4]
 80148bc:	f003 fdf8 	bl	80184b0 <rt_thread_startup>

    return 0;
 80148c0:	2300      	movs	r3, #0
}
 80148c2:	4618      	mov	r0, r3
 80148c4:	3708      	adds	r7, #8
 80148c6:	46bd      	mov	sp, r7
 80148c8:	bd80      	pop	{r7, pc}
 80148ca:	bf00      	nop
 80148cc:	080289f8 	.word	0x080289f8
 80148d0:	20010a54 	.word	0x20010a54
 80148d4:	08028a04 	.word	0x08028a04
 80148d8:	08028a20 	.word	0x08028a20
 80148dc:	08014831 	.word	0x08014831

080148e0 <USER_MotorTask_entry>:
//	//rt_kprintf("a=%s\r\n", a);
//}
//MSH_CMD_EXPORT(Set,Set parameter);

void USER_MotorTask_entry(void *parameter)
{
 80148e0:	b580      	push	{r7, lr}
 80148e2:	b082      	sub	sp, #8
 80148e4:	af00      	add	r7, sp, #0
 80148e6:	6078      	str	r0, [r7, #4]
//	
//	 rt_thread_delay(SLEEPTIME(500));
//  }

	//! \Add By Dl.K
	Motor_Ctrl_Init();
 80148e8:	f7ed fb92 	bl	8002010 <Motor_Ctrl_Init>
 	stm32_hw_tim8_init();
 80148ec:	f7ff f912 	bl	8013b14 <stm32_hw_tim8_init>
	stm32_hw_ADC_init();
 80148f0:	f7fe fbb8 	bl	8013064 <stm32_hw_ADC_init>
	stm32_hw_QEP_init();
 80148f4:	f7fe fce2 	bl	80132bc <stm32_hw_QEP_init>
		//rt_thread_delay(SLEEPTIME(20));
//		rt_kprintf("temp= 0x%x \r\n", Global_User_ADC.Temp.TEMP_value);
//		rt_kprintf("Ia= 0x%x \r\n", Global_User_ADC.PhaseA.qI_value);
//		rt_kprintf("Ib= 0x%x \r\n", Global_User_ADC.PhaseB.qI_value);
//		rt_kprintf("Ic= 0x%x \r\n", Global_User_ADC.PhaseC.qI_value);
	}
 80148f8:	e7fe      	b.n	80148f8 <USER_MotorTask_entry+0x18>
 80148fa:	bf00      	nop

080148fc <USER_Motor_Mspinit>:
}


void USER_Motor_Mspinit(void)
{
 80148fc:	b580      	push	{r7, lr}
 80148fe:	b088      	sub	sp, #32
 8014900:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_Init;
    /* Enable GPIO clock */
	FAN_GPIOE_CLK_ENABLE();
 8014902:	4a30      	ldr	r2, [pc, #192]	; (80149c4 <USER_Motor_Mspinit+0xc8>)
 8014904:	4b2f      	ldr	r3, [pc, #188]	; (80149c4 <USER_Motor_Mspinit+0xc8>)
 8014906:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014908:	f043 0310 	orr.w	r3, r3, #16
 801490c:	6313      	str	r3, [r2, #48]	; 0x30
 801490e:	4b2d      	ldr	r3, [pc, #180]	; (80149c4 <USER_Motor_Mspinit+0xc8>)
 8014910:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014912:	f003 0310 	and.w	r3, r3, #16
 8014916:	60bb      	str	r3, [r7, #8]
 8014918:	68bb      	ldr	r3, [r7, #8]

    /* GPIO pin configuration  */
 	GPIO_Init.Pin = FAN_PIN;
 801491a:	2340      	movs	r3, #64	; 0x40
 801491c:	60fb      	str	r3, [r7, #12]
	GPIO_Init.Mode = FAN_MODE;
 801491e:	2301      	movs	r3, #1
 8014920:	613b      	str	r3, [r7, #16]
	GPIO_Init.Pull = GPIO_PULLUP;
 8014922:	2301      	movs	r3, #1
 8014924:	617b      	str	r3, [r7, #20]
	GPIO_Init.Speed = GPIO_SPEED_LOW;
 8014926:	2300      	movs	r3, #0
 8014928:	61bb      	str	r3, [r7, #24]
	HAL_GPIO_Init(FAN_GPIO_PORT,&GPIO_Init);	
 801492a:	f107 030c 	add.w	r3, r7, #12
 801492e:	4826      	ldr	r0, [pc, #152]	; (80149c8 <USER_Motor_Mspinit+0xcc>)
 8014930:	4619      	mov	r1, r3
 8014932:	f7f8 f987 	bl	800cc44 <HAL_GPIO_Init>
	
	HAL_GPIO_WritePin(FAN_GPIO_PORT,FAN_PIN, GPIO_PIN_SET);
 8014936:	4824      	ldr	r0, [pc, #144]	; (80149c8 <USER_Motor_Mspinit+0xcc>)
 8014938:	2140      	movs	r1, #64	; 0x40
 801493a:	2201      	movs	r2, #1
 801493c:	f7f8 fc32 	bl	800d1a4 <HAL_GPIO_WritePin>

    /* Enable GPIO clock */
	TS0_GPIOE_CLK_ENABLE();
 8014940:	4a20      	ldr	r2, [pc, #128]	; (80149c4 <USER_Motor_Mspinit+0xc8>)
 8014942:	4b20      	ldr	r3, [pc, #128]	; (80149c4 <USER_Motor_Mspinit+0xc8>)
 8014944:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014946:	f043 0310 	orr.w	r3, r3, #16
 801494a:	6313      	str	r3, [r2, #48]	; 0x30
 801494c:	4b1d      	ldr	r3, [pc, #116]	; (80149c4 <USER_Motor_Mspinit+0xc8>)
 801494e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014950:	f003 0310 	and.w	r3, r3, #16
 8014954:	607b      	str	r3, [r7, #4]
 8014956:	687b      	ldr	r3, [r7, #4]
	TS1_GPIOE_CLK_ENABLE();
 8014958:	4a1a      	ldr	r2, [pc, #104]	; (80149c4 <USER_Motor_Mspinit+0xc8>)
 801495a:	4b1a      	ldr	r3, [pc, #104]	; (80149c4 <USER_Motor_Mspinit+0xc8>)
 801495c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801495e:	f043 0310 	orr.w	r3, r3, #16
 8014962:	6313      	str	r3, [r2, #48]	; 0x30
 8014964:	4b17      	ldr	r3, [pc, #92]	; (80149c4 <USER_Motor_Mspinit+0xc8>)
 8014966:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014968:	f003 0310 	and.w	r3, r3, #16
 801496c:	603b      	str	r3, [r7, #0]
 801496e:	683b      	ldr	r3, [r7, #0]
	
    /* GPIO pin configuration  */
 	GPIO_Init.Pin = TS0_PIN;
 8014970:	2308      	movs	r3, #8
 8014972:	60fb      	str	r3, [r7, #12]
	GPIO_Init.Mode = TS0_MODE;
 8014974:	2301      	movs	r3, #1
 8014976:	613b      	str	r3, [r7, #16]
	GPIO_Init.Pull = GPIO_PULLUP;
 8014978:	2301      	movs	r3, #1
 801497a:	617b      	str	r3, [r7, #20]
	GPIO_Init.Speed = GPIO_SPEED_LOW;
 801497c:	2300      	movs	r3, #0
 801497e:	61bb      	str	r3, [r7, #24]
	HAL_GPIO_Init(TS0_GPIO_PORT,&GPIO_Init);
 8014980:	f107 030c 	add.w	r3, r7, #12
 8014984:	4810      	ldr	r0, [pc, #64]	; (80149c8 <USER_Motor_Mspinit+0xcc>)
 8014986:	4619      	mov	r1, r3
 8014988:	f7f8 f95c 	bl	800cc44 <HAL_GPIO_Init>
	HAL_GPIO_WritePin(TS0_GPIO_PORT,TS0_PIN, GPIO_PIN_SET);
 801498c:	480e      	ldr	r0, [pc, #56]	; (80149c8 <USER_Motor_Mspinit+0xcc>)
 801498e:	2108      	movs	r1, #8
 8014990:	2201      	movs	r2, #1
 8014992:	f7f8 fc07 	bl	800d1a4 <HAL_GPIO_WritePin>
	
	/* GPIO pin configuration  */
 	GPIO_Init.Pin = TS1_PIN;
 8014996:	2320      	movs	r3, #32
 8014998:	60fb      	str	r3, [r7, #12]
	GPIO_Init.Mode = TS1_MODE;
 801499a:	2301      	movs	r3, #1
 801499c:	613b      	str	r3, [r7, #16]
	GPIO_Init.Pull = GPIO_PULLUP;
 801499e:	2301      	movs	r3, #1
 80149a0:	617b      	str	r3, [r7, #20]
	GPIO_Init.Speed = GPIO_SPEED_LOW;
 80149a2:	2300      	movs	r3, #0
 80149a4:	61bb      	str	r3, [r7, #24]
	HAL_GPIO_Init(TS1_GPIO_PORT,&GPIO_Init);
 80149a6:	f107 030c 	add.w	r3, r7, #12
 80149aa:	4807      	ldr	r0, [pc, #28]	; (80149c8 <USER_Motor_Mspinit+0xcc>)
 80149ac:	4619      	mov	r1, r3
 80149ae:	f7f8 f949 	bl	800cc44 <HAL_GPIO_Init>
	HAL_GPIO_WritePin(TS1_GPIO_PORT,TS1_PIN, GPIO_PIN_SET);
 80149b2:	4805      	ldr	r0, [pc, #20]	; (80149c8 <USER_Motor_Mspinit+0xcc>)
 80149b4:	2120      	movs	r1, #32
 80149b6:	2201      	movs	r2, #1
 80149b8:	f7f8 fbf4 	bl	800d1a4 <HAL_GPIO_WritePin>
}
 80149bc:	3720      	adds	r7, #32
 80149be:	46bd      	mov	sp, r7
 80149c0:	bd80      	pop	{r7, pc}
 80149c2:	bf00      	nop
 80149c4:	40023800 	.word	0x40023800
 80149c8:	40021000 	.word	0x40021000

080149cc <USER_Motor_hwinit>:

int USER_Motor_hwinit(void)
{
 80149cc:	b580      	push	{r7, lr}
 80149ce:	af00      	add	r7, sp, #0
USER_Motor_Mspinit();
 80149d0:	f7ff ff94 	bl	80148fc <USER_Motor_Mspinit>
return 0;
 80149d4:	2300      	movs	r3, #0
}
 80149d6:	4618      	mov	r0, r3
 80149d8:	bd80      	pop	{r7, pc}
 80149da:	bf00      	nop

080149dc <TempSeltest>:

INIT_BOARD_EXPORT(USER_Motor_hwinit);


void TempSeltest(int argc,char **argv)
{
 80149dc:	b580      	push	{r7, lr}
 80149de:	b082      	sub	sp, #8
 80149e0:	af00      	add	r7, sp, #0
 80149e2:	6078      	str	r0, [r7, #4]
 80149e4:	6039      	str	r1, [r7, #0]
	if(strcmp(argv[1],"0")==0){
 80149e6:	683b      	ldr	r3, [r7, #0]
 80149e8:	3304      	adds	r3, #4
 80149ea:	681b      	ldr	r3, [r3, #0]
 80149ec:	4618      	mov	r0, r3
 80149ee:	492b      	ldr	r1, [pc, #172]	; (8014a9c <TempSeltest+0xc0>)
 80149f0:	f7eb fd1a 	bl	8000428 <strcmp>
 80149f4:	4603      	mov	r3, r0
 80149f6:	2b00      	cmp	r3, #0
 80149f8:	d10a      	bne.n	8014a10 <TempSeltest+0x34>
		HAL_GPIO_WritePin(TS0_GPIO_PORT,TS0_PIN,GPIO_PIN_RESET);
 80149fa:	4829      	ldr	r0, [pc, #164]	; (8014aa0 <TempSeltest+0xc4>)
 80149fc:	2108      	movs	r1, #8
 80149fe:	2200      	movs	r2, #0
 8014a00:	f7f8 fbd0 	bl	800d1a4 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(TS1_GPIO_PORT,TS1_PIN,GPIO_PIN_RESET);
 8014a04:	4826      	ldr	r0, [pc, #152]	; (8014aa0 <TempSeltest+0xc4>)
 8014a06:	2120      	movs	r1, #32
 8014a08:	2200      	movs	r2, #0
 8014a0a:	f7f8 fbcb 	bl	800d1a4 <HAL_GPIO_WritePin>
 8014a0e:	e041      	b.n	8014a94 <TempSeltest+0xb8>
	}else if (strcmp(argv[1],"1")==0){
 8014a10:	683b      	ldr	r3, [r7, #0]
 8014a12:	3304      	adds	r3, #4
 8014a14:	681b      	ldr	r3, [r3, #0]
 8014a16:	4618      	mov	r0, r3
 8014a18:	4922      	ldr	r1, [pc, #136]	; (8014aa4 <TempSeltest+0xc8>)
 8014a1a:	f7eb fd05 	bl	8000428 <strcmp>
 8014a1e:	4603      	mov	r3, r0
 8014a20:	2b00      	cmp	r3, #0
 8014a22:	d10a      	bne.n	8014a3a <TempSeltest+0x5e>
		HAL_GPIO_WritePin(TS0_GPIO_PORT,TS0_PIN,GPIO_PIN_SET);
 8014a24:	481e      	ldr	r0, [pc, #120]	; (8014aa0 <TempSeltest+0xc4>)
 8014a26:	2108      	movs	r1, #8
 8014a28:	2201      	movs	r2, #1
 8014a2a:	f7f8 fbbb 	bl	800d1a4 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(TS1_GPIO_PORT,TS1_PIN,GPIO_PIN_RESET);
 8014a2e:	481c      	ldr	r0, [pc, #112]	; (8014aa0 <TempSeltest+0xc4>)
 8014a30:	2120      	movs	r1, #32
 8014a32:	2200      	movs	r2, #0
 8014a34:	f7f8 fbb6 	bl	800d1a4 <HAL_GPIO_WritePin>
 8014a38:	e02c      	b.n	8014a94 <TempSeltest+0xb8>
	}else if(strcmp(argv[1],"2")==0) {
 8014a3a:	683b      	ldr	r3, [r7, #0]
 8014a3c:	3304      	adds	r3, #4
 8014a3e:	681b      	ldr	r3, [r3, #0]
 8014a40:	4618      	mov	r0, r3
 8014a42:	4919      	ldr	r1, [pc, #100]	; (8014aa8 <TempSeltest+0xcc>)
 8014a44:	f7eb fcf0 	bl	8000428 <strcmp>
 8014a48:	4603      	mov	r3, r0
 8014a4a:	2b00      	cmp	r3, #0
 8014a4c:	d10a      	bne.n	8014a64 <TempSeltest+0x88>
		HAL_GPIO_WritePin(TS0_GPIO_PORT,TS0_PIN,GPIO_PIN_RESET);
 8014a4e:	4814      	ldr	r0, [pc, #80]	; (8014aa0 <TempSeltest+0xc4>)
 8014a50:	2108      	movs	r1, #8
 8014a52:	2200      	movs	r2, #0
 8014a54:	f7f8 fba6 	bl	800d1a4 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(TS1_GPIO_PORT,TS1_PIN,GPIO_PIN_SET);
 8014a58:	4811      	ldr	r0, [pc, #68]	; (8014aa0 <TempSeltest+0xc4>)
 8014a5a:	2120      	movs	r1, #32
 8014a5c:	2201      	movs	r2, #1
 8014a5e:	f7f8 fba1 	bl	800d1a4 <HAL_GPIO_WritePin>
 8014a62:	e017      	b.n	8014a94 <TempSeltest+0xb8>
	}else if(strcmp(argv[1],"3")==0) {
 8014a64:	683b      	ldr	r3, [r7, #0]
 8014a66:	3304      	adds	r3, #4
 8014a68:	681b      	ldr	r3, [r3, #0]
 8014a6a:	4618      	mov	r0, r3
 8014a6c:	490f      	ldr	r1, [pc, #60]	; (8014aac <TempSeltest+0xd0>)
 8014a6e:	f7eb fcdb 	bl	8000428 <strcmp>
 8014a72:	4603      	mov	r3, r0
 8014a74:	2b00      	cmp	r3, #0
 8014a76:	d10a      	bne.n	8014a8e <TempSeltest+0xb2>
		HAL_GPIO_WritePin(TS0_GPIO_PORT,TS0_PIN,GPIO_PIN_SET);
 8014a78:	4809      	ldr	r0, [pc, #36]	; (8014aa0 <TempSeltest+0xc4>)
 8014a7a:	2108      	movs	r1, #8
 8014a7c:	2201      	movs	r2, #1
 8014a7e:	f7f8 fb91 	bl	800d1a4 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(TS1_GPIO_PORT,TS1_PIN,GPIO_PIN_SET);
 8014a82:	4807      	ldr	r0, [pc, #28]	; (8014aa0 <TempSeltest+0xc4>)
 8014a84:	2120      	movs	r1, #32
 8014a86:	2201      	movs	r2, #1
 8014a88:	f7f8 fb8c 	bl	800d1a4 <HAL_GPIO_WritePin>
 8014a8c:	e002      	b.n	8014a94 <TempSeltest+0xb8>
	}else{
		rt_kprintf("unknown parameter\r\n");
 8014a8e:	4808      	ldr	r0, [pc, #32]	; (8014ab0 <TempSeltest+0xd4>)
 8014a90:	f002 fb3e 	bl	8017110 <rt_kprintf>
	}
}
 8014a94:	3708      	adds	r7, #8
 8014a96:	46bd      	mov	sp, r7
 8014a98:	bd80      	pop	{r7, pc}
 8014a9a:	bf00      	nop
 8014a9c:	08028a2c 	.word	0x08028a2c
 8014aa0:	40021000 	.word	0x40021000
 8014aa4:	08028a30 	.word	0x08028a30
 8014aa8:	08028a34 	.word	0x08028a34
 8014aac:	08028a38 	.word	0x08028a38
 8014ab0:	08028a3c 	.word	0x08028a3c

08014ab4 <FANtest>:
MSH_CMD_EXPORT_ALIAS(TempSeltest,TS,TS 0 or TS 1 or TS 2 or TS 3);


void FANtest(int argc,char**argv)
{
 8014ab4:	b580      	push	{r7, lr}
 8014ab6:	b082      	sub	sp, #8
 8014ab8:	af00      	add	r7, sp, #0
 8014aba:	6078      	str	r0, [r7, #4]
 8014abc:	6039      	str	r1, [r7, #0]
	if (strcmp(argv[1], "on") == 0)
 8014abe:	683b      	ldr	r3, [r7, #0]
 8014ac0:	3304      	adds	r3, #4
 8014ac2:	681b      	ldr	r3, [r3, #0]
 8014ac4:	4618      	mov	r0, r3
 8014ac6:	4911      	ldr	r1, [pc, #68]	; (8014b0c <FANtest+0x58>)
 8014ac8:	f7eb fcae 	bl	8000428 <strcmp>
 8014acc:	4603      	mov	r3, r0
 8014ace:	2b00      	cmp	r3, #0
 8014ad0:	d105      	bne.n	8014ade <FANtest+0x2a>
		HAL_GPIO_WritePin(FAN_GPIO_PORT,FAN_PIN, GPIO_PIN_RESET);
 8014ad2:	480f      	ldr	r0, [pc, #60]	; (8014b10 <FANtest+0x5c>)
 8014ad4:	2140      	movs	r1, #64	; 0x40
 8014ad6:	2200      	movs	r2, #0
 8014ad8:	f7f8 fb64 	bl	800d1a4 <HAL_GPIO_WritePin>
 8014adc:	e012      	b.n	8014b04 <FANtest+0x50>
	else if(strcmp(argv[1], "off") == 0)
 8014ade:	683b      	ldr	r3, [r7, #0]
 8014ae0:	3304      	adds	r3, #4
 8014ae2:	681b      	ldr	r3, [r3, #0]
 8014ae4:	4618      	mov	r0, r3
 8014ae6:	490b      	ldr	r1, [pc, #44]	; (8014b14 <FANtest+0x60>)
 8014ae8:	f7eb fc9e 	bl	8000428 <strcmp>
 8014aec:	4603      	mov	r3, r0
 8014aee:	2b00      	cmp	r3, #0
 8014af0:	d105      	bne.n	8014afe <FANtest+0x4a>
		HAL_GPIO_WritePin(FAN_GPIO_PORT,FAN_PIN, GPIO_PIN_SET);
 8014af2:	4807      	ldr	r0, [pc, #28]	; (8014b10 <FANtest+0x5c>)
 8014af4:	2140      	movs	r1, #64	; 0x40
 8014af6:	2201      	movs	r2, #1
 8014af8:	f7f8 fb54 	bl	800d1a4 <HAL_GPIO_WritePin>
 8014afc:	e002      	b.n	8014b04 <FANtest+0x50>
	else
		rt_kprintf("unknown parameter\r\n");
 8014afe:	4806      	ldr	r0, [pc, #24]	; (8014b18 <FANtest+0x64>)
 8014b00:	f002 fb06 	bl	8017110 <rt_kprintf>
}
 8014b04:	3708      	adds	r7, #8
 8014b06:	46bd      	mov	sp, r7
 8014b08:	bd80      	pop	{r7, pc}
 8014b0a:	bf00      	nop
 8014b0c:	08028a50 	.word	0x08028a50
 8014b10:	40021000 	.word	0x40021000
 8014b14:	08028a54 	.word	0x08028a54
 8014b18:	08028a3c 	.word	0x08028a3c

08014b1c <ADCtest>:
MSH_CMD_EXPORT(FANtest,FANtest on or FANtest off);

void ADCtest(int argc,char**argv)
{
 8014b1c:	b580      	push	{r7, lr}
 8014b1e:	b082      	sub	sp, #8
 8014b20:	af00      	add	r7, sp, #0
 8014b22:	6078      	str	r0, [r7, #4]
 8014b24:	6039      	str	r1, [r7, #0]
	rt_kprintf("temp= 0x%x \r\n", Global_User_ADC.Temp.TEMP_value);
 8014b26:	4b50      	ldr	r3, [pc, #320]	; (8014c68 <ADCtest+0x14c>)
 8014b28:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 8014b2c:	b21b      	sxth	r3, r3
 8014b2e:	484f      	ldr	r0, [pc, #316]	; (8014c6c <ADCtest+0x150>)
 8014b30:	4619      	mov	r1, r3
 8014b32:	f002 faed 	bl	8017110 <rt_kprintf>
	rt_kprintf("BUS V= 0x%x \r\n", Global_User_ADC.BUS.qV_value);
 8014b36:	4b4c      	ldr	r3, [pc, #304]	; (8014c68 <ADCtest+0x14c>)
 8014b38:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 8014b3a:	b21b      	sxth	r3, r3
 8014b3c:	484c      	ldr	r0, [pc, #304]	; (8014c70 <ADCtest+0x154>)
 8014b3e:	4619      	mov	r1, r3
 8014b40:	f002 fae6 	bl	8017110 <rt_kprintf>
	rt_kprintf("BUS I= 0x%x \r\n", Global_User_ADC.BUS.qI_value);
 8014b44:	4b48      	ldr	r3, [pc, #288]	; (8014c68 <ADCtest+0x14c>)
 8014b46:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8014b48:	b21b      	sxth	r3, r3
 8014b4a:	484a      	ldr	r0, [pc, #296]	; (8014c74 <ADCtest+0x158>)
 8014b4c:	4619      	mov	r1, r3
 8014b4e:	f002 fadf 	bl	8017110 <rt_kprintf>
	rt_kprintf("VOLTAGE C= 0x%x \r\n", Global_User_ADC.PhaseC.qV_value);
 8014b52:	4b45      	ldr	r3, [pc, #276]	; (8014c68 <ADCtest+0x14c>)
 8014b54:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 8014b56:	b21b      	sxth	r3, r3
 8014b58:	4847      	ldr	r0, [pc, #284]	; (8014c78 <ADCtest+0x15c>)
 8014b5a:	4619      	mov	r1, r3
 8014b5c:	f002 fad8 	bl	8017110 <rt_kprintf>
	rt_kprintf("VOLTAGE B= 0x%x \r\n", Global_User_ADC.PhaseB.qV_value);
 8014b60:	4b41      	ldr	r3, [pc, #260]	; (8014c68 <ADCtest+0x14c>)
 8014b62:	8b1b      	ldrh	r3, [r3, #24]
 8014b64:	b21b      	sxth	r3, r3
 8014b66:	4845      	ldr	r0, [pc, #276]	; (8014c7c <ADCtest+0x160>)
 8014b68:	4619      	mov	r1, r3
 8014b6a:	f002 fad1 	bl	8017110 <rt_kprintf>
	rt_kprintf("VOLTAGE A= 0x%x \r\n", Global_User_ADC.PhaseA.qV_value);
 8014b6e:	4b3e      	ldr	r3, [pc, #248]	; (8014c68 <ADCtest+0x14c>)
 8014b70:	895b      	ldrh	r3, [r3, #10]
 8014b72:	b21b      	sxth	r3, r3
 8014b74:	4842      	ldr	r0, [pc, #264]	; (8014c80 <ADCtest+0x164>)
 8014b76:	4619      	mov	r1, r3
 8014b78:	f002 faca 	bl	8017110 <rt_kprintf>
	rt_kprintf("current C2= 0x%x \r\n", Global_User_ADC.PhaseC.qI2_value);
 8014b7c:	4b3a      	ldr	r3, [pc, #232]	; (8014c68 <ADCtest+0x14c>)
 8014b7e:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 8014b80:	b21b      	sxth	r3, r3
 8014b82:	4840      	ldr	r0, [pc, #256]	; (8014c84 <ADCtest+0x168>)
 8014b84:	4619      	mov	r1, r3
 8014b86:	f002 fac3 	bl	8017110 <rt_kprintf>
	rt_kprintf("current C1= 0x%x \r\n", Global_User_ADC.PhaseC.qI1_value);
 8014b8a:	4b37      	ldr	r3, [pc, #220]	; (8014c68 <ADCtest+0x14c>)
 8014b8c:	8b9b      	ldrh	r3, [r3, #28]
 8014b8e:	b21b      	sxth	r3, r3
 8014b90:	483d      	ldr	r0, [pc, #244]	; (8014c88 <ADCtest+0x16c>)
 8014b92:	4619      	mov	r1, r3
 8014b94:	f002 fabc 	bl	8017110 <rt_kprintf>
	rt_kprintf("current B2= 0x%x \r\n", Global_User_ADC.PhaseB.qI2_value);
 8014b98:	4b33      	ldr	r3, [pc, #204]	; (8014c68 <ADCtest+0x14c>)
 8014b9a:	8a9b      	ldrh	r3, [r3, #20]
 8014b9c:	b21b      	sxth	r3, r3
 8014b9e:	483b      	ldr	r0, [pc, #236]	; (8014c8c <ADCtest+0x170>)
 8014ba0:	4619      	mov	r1, r3
 8014ba2:	f002 fab5 	bl	8017110 <rt_kprintf>
	rt_kprintf("current B1= 0x%x \r\n", Global_User_ADC.PhaseB.qI1_value);
 8014ba6:	4b30      	ldr	r3, [pc, #192]	; (8014c68 <ADCtest+0x14c>)
 8014ba8:	89db      	ldrh	r3, [r3, #14]
 8014baa:	b21b      	sxth	r3, r3
 8014bac:	4838      	ldr	r0, [pc, #224]	; (8014c90 <ADCtest+0x174>)
 8014bae:	4619      	mov	r1, r3
 8014bb0:	f002 faae 	bl	8017110 <rt_kprintf>
	rt_kprintf("current A2= 0x%x \r\n", Global_User_ADC.PhaseA.qI2_value);
 8014bb4:	4b2c      	ldr	r3, [pc, #176]	; (8014c68 <ADCtest+0x14c>)
 8014bb6:	88db      	ldrh	r3, [r3, #6]
 8014bb8:	b21b      	sxth	r3, r3
 8014bba:	4836      	ldr	r0, [pc, #216]	; (8014c94 <ADCtest+0x178>)
 8014bbc:	4619      	mov	r1, r3
 8014bbe:	f002 faa7 	bl	8017110 <rt_kprintf>
	rt_kprintf("current A1= 0x%x \r\n", Global_User_ADC.PhaseA.qI1_value);
 8014bc2:	4b29      	ldr	r3, [pc, #164]	; (8014c68 <ADCtest+0x14c>)
 8014bc4:	881b      	ldrh	r3, [r3, #0]
 8014bc6:	b21b      	sxth	r3, r3
 8014bc8:	4833      	ldr	r0, [pc, #204]	; (8014c98 <ADCtest+0x17c>)
 8014bca:	4619      	mov	r1, r3
 8014bcc:	f002 faa0 	bl	8017110 <rt_kprintf>

	
	rt_kprintf("temp offset= 0x%x \r\n", Global_User_ADC.Temp.TEMP_offset);
 8014bd0:	4b25      	ldr	r3, [pc, #148]	; (8014c68 <ADCtest+0x14c>)
 8014bd2:	f8b3 305e 	ldrh.w	r3, [r3, #94]	; 0x5e
 8014bd6:	4831      	ldr	r0, [pc, #196]	; (8014c9c <ADCtest+0x180>)
 8014bd8:	4619      	mov	r1, r3
 8014bda:	f002 fa99 	bl	8017110 <rt_kprintf>
	rt_kprintf("BUS V  offset= 0x%x \r\n", Global_User_ADC.BUS.qV_offset);
 8014bde:	4b22      	ldr	r3, [pc, #136]	; (8014c68 <ADCtest+0x14c>)
 8014be0:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 8014be2:	482f      	ldr	r0, [pc, #188]	; (8014ca0 <ADCtest+0x184>)
 8014be4:	4619      	mov	r1, r3
 8014be6:	f002 fa93 	bl	8017110 <rt_kprintf>
	rt_kprintf("BUS I offset= 0x%x \r\n", Global_User_ADC.BUS.qI_offset);
 8014bea:	4b1f      	ldr	r3, [pc, #124]	; (8014c68 <ADCtest+0x14c>)
 8014bec:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 8014bee:	482d      	ldr	r0, [pc, #180]	; (8014ca4 <ADCtest+0x188>)
 8014bf0:	4619      	mov	r1, r3
 8014bf2:	f002 fa8d 	bl	8017110 <rt_kprintf>
	rt_kprintf("VOLTAGE C offset= 0x%x \r\n", Global_User_ADC.PhaseC.qV_offset);
 8014bf6:	4b1c      	ldr	r3, [pc, #112]	; (8014c68 <ADCtest+0x14c>)
 8014bf8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8014bfa:	482b      	ldr	r0, [pc, #172]	; (8014ca8 <ADCtest+0x18c>)
 8014bfc:	4619      	mov	r1, r3
 8014bfe:	f002 fa87 	bl	8017110 <rt_kprintf>
	rt_kprintf("VOLTAGE B offset= 0x%x \r\n", Global_User_ADC.PhaseB.qV_offset);
 8014c02:	4b19      	ldr	r3, [pc, #100]	; (8014c68 <ADCtest+0x14c>)
 8014c04:	8b5b      	ldrh	r3, [r3, #26]
 8014c06:	4829      	ldr	r0, [pc, #164]	; (8014cac <ADCtest+0x190>)
 8014c08:	4619      	mov	r1, r3
 8014c0a:	f002 fa81 	bl	8017110 <rt_kprintf>
	rt_kprintf("VOLTAGE A offset= 0x%x \r\n", Global_User_ADC.PhaseA.qV_offset);
 8014c0e:	4b16      	ldr	r3, [pc, #88]	; (8014c68 <ADCtest+0x14c>)
 8014c10:	899b      	ldrh	r3, [r3, #12]
 8014c12:	4827      	ldr	r0, [pc, #156]	; (8014cb0 <ADCtest+0x194>)
 8014c14:	4619      	mov	r1, r3
 8014c16:	f002 fa7b 	bl	8017110 <rt_kprintf>
	rt_kprintf("current C2 offset= 0x%x \r\n", Global_User_ADC.PhaseC.qI2_offset);
 8014c1a:	4b13      	ldr	r3, [pc, #76]	; (8014c68 <ADCtest+0x14c>)
 8014c1c:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8014c1e:	4825      	ldr	r0, [pc, #148]	; (8014cb4 <ADCtest+0x198>)
 8014c20:	4619      	mov	r1, r3
 8014c22:	f002 fa75 	bl	8017110 <rt_kprintf>
	rt_kprintf("current C1 offset= 0x%x \r\n", Global_User_ADC.PhaseC.qI1_offset);
 8014c26:	4b10      	ldr	r3, [pc, #64]	; (8014c68 <ADCtest+0x14c>)
 8014c28:	8c1b      	ldrh	r3, [r3, #32]
 8014c2a:	4823      	ldr	r0, [pc, #140]	; (8014cb8 <ADCtest+0x19c>)
 8014c2c:	4619      	mov	r1, r3
 8014c2e:	f002 fa6f 	bl	8017110 <rt_kprintf>
	rt_kprintf("current B2 offset= 0x%x \r\n", Global_User_ADC.PhaseB.qI2_offset);
 8014c32:	4b0d      	ldr	r3, [pc, #52]	; (8014c68 <ADCtest+0x14c>)
 8014c34:	8adb      	ldrh	r3, [r3, #22]
 8014c36:	4821      	ldr	r0, [pc, #132]	; (8014cbc <ADCtest+0x1a0>)
 8014c38:	4619      	mov	r1, r3
 8014c3a:	f002 fa69 	bl	8017110 <rt_kprintf>
	rt_kprintf("current B1 offset= 0x%x \r\n", Global_User_ADC.PhaseB.qI1_offset);
 8014c3e:	4b0a      	ldr	r3, [pc, #40]	; (8014c68 <ADCtest+0x14c>)
 8014c40:	8a5b      	ldrh	r3, [r3, #18]
 8014c42:	481f      	ldr	r0, [pc, #124]	; (8014cc0 <ADCtest+0x1a4>)
 8014c44:	4619      	mov	r1, r3
 8014c46:	f002 fa63 	bl	8017110 <rt_kprintf>
	rt_kprintf("current A2 offset= 0x%x \r\n", Global_User_ADC.PhaseA.qI2_offset);
 8014c4a:	4b07      	ldr	r3, [pc, #28]	; (8014c68 <ADCtest+0x14c>)
 8014c4c:	891b      	ldrh	r3, [r3, #8]
 8014c4e:	481d      	ldr	r0, [pc, #116]	; (8014cc4 <ADCtest+0x1a8>)
 8014c50:	4619      	mov	r1, r3
 8014c52:	f002 fa5d 	bl	8017110 <rt_kprintf>
	rt_kprintf("current A1 offset= 0x%x \r\n", Global_User_ADC.PhaseA.qI1_offset);
 8014c56:	4b04      	ldr	r3, [pc, #16]	; (8014c68 <ADCtest+0x14c>)
 8014c58:	889b      	ldrh	r3, [r3, #4]
 8014c5a:	481b      	ldr	r0, [pc, #108]	; (8014cc8 <ADCtest+0x1ac>)
 8014c5c:	4619      	mov	r1, r3
 8014c5e:	f002 fa57 	bl	8017110 <rt_kprintf>
}
 8014c62:	3708      	adds	r7, #8
 8014c64:	46bd      	mov	sp, r7
 8014c66:	bd80      	pop	{r7, pc}
 8014c68:	200128e4 	.word	0x200128e4
 8014c6c:	08028a58 	.word	0x08028a58
 8014c70:	08028a68 	.word	0x08028a68
 8014c74:	08028a78 	.word	0x08028a78
 8014c78:	08028a88 	.word	0x08028a88
 8014c7c:	08028a9c 	.word	0x08028a9c
 8014c80:	08028ab0 	.word	0x08028ab0
 8014c84:	08028ac4 	.word	0x08028ac4
 8014c88:	08028ad8 	.word	0x08028ad8
 8014c8c:	08028aec 	.word	0x08028aec
 8014c90:	08028b00 	.word	0x08028b00
 8014c94:	08028b14 	.word	0x08028b14
 8014c98:	08028b28 	.word	0x08028b28
 8014c9c:	08028b3c 	.word	0x08028b3c
 8014ca0:	08028b54 	.word	0x08028b54
 8014ca4:	08028b6c 	.word	0x08028b6c
 8014ca8:	08028b84 	.word	0x08028b84
 8014cac:	08028ba0 	.word	0x08028ba0
 8014cb0:	08028bbc 	.word	0x08028bbc
 8014cb4:	08028bd8 	.word	0x08028bd8
 8014cb8:	08028bf4 	.word	0x08028bf4
 8014cbc:	08028c10 	.word	0x08028c10
 8014cc0:	08028c2c 	.word	0x08028c2c
 8014cc4:	08028c48 	.word	0x08028c48
 8014cc8:	08028c64 	.word	0x08028c64

08014ccc <out>:
#include<stdlib.h>
#include<stdio.h>


void out(double d)
{
 8014ccc:	b480      	push	{r7}
 8014cce:	b083      	sub	sp, #12
 8014cd0:	af00      	add	r7, sp, #0
 8014cd2:	ed87 0b00 	vstr	d0, [r7]

}
 8014cd6:	370c      	adds	r7, #12
 8014cd8:	46bd      	mov	sp, r7
 8014cda:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014cde:	4770      	bx	lr

08014ce0 <floatmul>:

void floatmul(int argc,char**argv)
{
 8014ce0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014ce2:	b08d      	sub	sp, #52	; 0x34
 8014ce4:	af04      	add	r7, sp, #16
 8014ce6:	6078      	str	r0, [r7, #4]
 8014ce8:	6039      	str	r1, [r7, #0]
	double d0,d1,result;
	d0 = atof(argv[1]);
 8014cea:	683b      	ldr	r3, [r7, #0]
 8014cec:	3304      	adds	r3, #4
 8014cee:	681b      	ldr	r3, [r3, #0]
 8014cf0:	4618      	mov	r0, r3
 8014cf2:	f00d fb71 	bl	80223d8 <atof>
 8014cf6:	eeb0 7b40 	vmov.f64	d7, d0
 8014cfa:	ed87 7b04 	vstr	d7, [r7, #16]
	d1 = atof(argv[2]);
 8014cfe:	683b      	ldr	r3, [r7, #0]
 8014d00:	3308      	adds	r3, #8
 8014d02:	681b      	ldr	r3, [r3, #0]
 8014d04:	4618      	mov	r0, r3
 8014d06:	f00d fb67 	bl	80223d8 <atof>
 8014d0a:	eeb0 7b40 	vmov.f64	d7, d0
 8014d0e:	ed87 7b02 	vstr	d7, [r7, #8]
	result = mymul(d0,d1);
 8014d12:	ed97 6b04 	vldr	d6, [r7, #16]
 8014d16:	ed97 7b02 	vldr	d7, [r7, #8]
 8014d1a:	eeb0 0b46 	vmov.f64	d0, d6
 8014d1e:	eeb0 1b47 	vmov.f64	d1, d7
 8014d22:	f7eb fa51 	bl	80001c8 <mymul>
 8014d26:	ee07 0a90 	vmov	s15, r0
 8014d2a:	eeb8 7be7 	vcvt.f64.s32	d7, s15
 8014d2e:	ed87 7b06 	vstr	d7, [r7, #24]
	result = d0*d1;
 8014d32:	ed97 6b04 	vldr	d6, [r7, #16]
 8014d36:	ed97 7b02 	vldr	d7, [r7, #8]
 8014d3a:	ee26 7b07 	vmul.f64	d7, d6, d7
 8014d3e:	ed87 7b06 	vstr	d7, [r7, #24]
	out(d0);
 8014d42:	ed97 7b04 	vldr	d7, [r7, #16]
 8014d46:	eeb0 0b47 	vmov.f64	d0, d7
 8014d4a:	f7ff ffbf 	bl	8014ccc <out>
	rt_kprintf("d0:\r\n%x = %x\r\n%x = %x\r\n",&d0,*(&d0),d0,d0);
 8014d4e:	e9d7 4504 	ldrd	r4, r5, [r7, #16]
 8014d52:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8014d56:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8014d5a:	f107 0610 	add.w	r6, r7, #16
 8014d5e:	e9cd 0100 	strd	r0, r1, [sp]
 8014d62:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8014d66:	480d      	ldr	r0, [pc, #52]	; (8014d9c <floatmul+0xbc>)
 8014d68:	4631      	mov	r1, r6
 8014d6a:	4622      	mov	r2, r4
 8014d6c:	462b      	mov	r3, r5
 8014d6e:	f002 f9cf 	bl	8017110 <rt_kprintf>
	rt_kprintf("d1:\r\n%x = %x\r\n%x = %x\r\n",&d1,*(&d1),d1,d1);
 8014d72:	e9d7 4502 	ldrd	r4, r5, [r7, #8]
 8014d76:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 8014d7a:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8014d7e:	f107 0608 	add.w	r6, r7, #8
 8014d82:	e9cd 0100 	strd	r0, r1, [sp]
 8014d86:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8014d8a:	4805      	ldr	r0, [pc, #20]	; (8014da0 <floatmul+0xc0>)
 8014d8c:	4631      	mov	r1, r6
 8014d8e:	4622      	mov	r2, r4
 8014d90:	462b      	mov	r3, r5
 8014d92:	f002 f9bd 	bl	8017110 <rt_kprintf>
}
 8014d96:	3724      	adds	r7, #36	; 0x24
 8014d98:	46bd      	mov	sp, r7
 8014d9a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8014d9c:	08028c80 	.word	0x08028c80
 8014da0:	08028c98 	.word	0x08028c98

08014da4 <MCctrl>:
MSH_CMD_EXPORT(floatmul,floatmul d1 d2);


void MCctrl(int argc,char**argv)
{
 8014da4:	b580      	push	{r7, lr}
 8014da6:	b082      	sub	sp, #8
 8014da8:	af00      	add	r7, sp, #0
 8014daa:	6078      	str	r0, [r7, #4]
 8014dac:	6039      	str	r1, [r7, #0]
	if (strcmp(argv[1], "on") == 0)
 8014dae:	683b      	ldr	r3, [r7, #0]
 8014db0:	3304      	adds	r3, #4
 8014db2:	681b      	ldr	r3, [r3, #0]
 8014db4:	4618      	mov	r0, r3
 8014db6:	4910      	ldr	r1, [pc, #64]	; (8014df8 <MCctrl+0x54>)
 8014db8:	f7eb fb36 	bl	8000428 <strcmp>
 8014dbc:	4603      	mov	r3, r0
 8014dbe:	2b00      	cmp	r3, #0
 8014dc0:	d106      	bne.n	8014dd0 <MCctrl+0x2c>
	{
//		State = INIT;
		PWMOutputsEnable(TIM8);
 8014dc2:	480e      	ldr	r0, [pc, #56]	; (8014dfc <MCctrl+0x58>)
 8014dc4:	f7fe fda2 	bl	801390c <PWMOutputsEnable>

		rt_kprintf("Motor is started\r\n");
 8014dc8:	480d      	ldr	r0, [pc, #52]	; (8014e00 <MCctrl+0x5c>)
 8014dca:	f002 f9a1 	bl	8017110 <rt_kprintf>
 8014dce:	e00f      	b.n	8014df0 <MCctrl+0x4c>
	}
	else if(strcmp(argv[1], "off") == 0)
 8014dd0:	683b      	ldr	r3, [r7, #0]
 8014dd2:	3304      	adds	r3, #4
 8014dd4:	681b      	ldr	r3, [r3, #0]
 8014dd6:	4618      	mov	r0, r3
 8014dd8:	490a      	ldr	r1, [pc, #40]	; (8014e04 <MCctrl+0x60>)
 8014dda:	f7eb fb25 	bl	8000428 <strcmp>
 8014dde:	4603      	mov	r3, r0
 8014de0:	2b00      	cmp	r3, #0
 8014de2:	d105      	bne.n	8014df0 <MCctrl+0x4c>
	{
//		State = STOP;
		PWMOutputsDisable(TIM8);
 8014de4:	4805      	ldr	r0, [pc, #20]	; (8014dfc <MCctrl+0x58>)
 8014de6:	f7fe fdaf 	bl	8013948 <PWMOutputsDisable>
		rt_kprintf("Motor is stopped\r\n");
 8014dea:	4807      	ldr	r0, [pc, #28]	; (8014e08 <MCctrl+0x64>)
 8014dec:	f002 f990 	bl	8017110 <rt_kprintf>
	}
}
 8014df0:	3708      	adds	r7, #8
 8014df2:	46bd      	mov	sp, r7
 8014df4:	bd80      	pop	{r7, pc}
 8014df6:	bf00      	nop
 8014df8:	08028a50 	.word	0x08028a50
 8014dfc:	40010400 	.word	0x40010400
 8014e00:	08028cb0 	.word	0x08028cb0
 8014e04:	08028a54 	.word	0x08028a54
 8014e08:	08028cc4 	.word	0x08028cc4

08014e0c <QEPtest>:
MSH_CMD_EXPORT(MCctrl,MCctrl on or MCctrl off);

#ifdef ENCODER
void QEPtest(int argc,char**argv)
{
 8014e0c:	b580      	push	{r7, lr}
 8014e0e:	b082      	sub	sp, #8
 8014e10:	af00      	add	r7, sp, #0
 8014e12:	6078      	str	r0, [r7, #4]
 8014e14:	6039      	str	r1, [r7, #0]
	rt_kprintf("TIM5 CNT =%x\r\n",GetCounterValue(TIM5) );
 8014e16:	4805      	ldr	r0, [pc, #20]	; (8014e2c <QEPtest+0x20>)
 8014e18:	f7fe f9da 	bl	80131d0 <GetCounterValue>
 8014e1c:	4603      	mov	r3, r0
 8014e1e:	4804      	ldr	r0, [pc, #16]	; (8014e30 <QEPtest+0x24>)
 8014e20:	4619      	mov	r1, r3
 8014e22:	f002 f975 	bl	8017110 <rt_kprintf>
}
 8014e26:	3708      	adds	r7, #8
 8014e28:	46bd      	mov	sp, r7
 8014e2a:	bd80      	pop	{r7, pc}
 8014e2c:	40000c00 	.word	0x40000c00
 8014e30:	08028cd8 	.word	0x08028cd8

08014e34 <USER_MotorTask_init>:
MSH_CMD_EXPORT(QEPtest,QEPtest);
#endif

int USER_MotorTask_init()
{
 8014e34:	b580      	push	{r7, lr}
 8014e36:	b084      	sub	sp, #16
 8014e38:	af02      	add	r7, sp, #8
    rt_thread_t tid;
	
	tid = rt_thread_create("Motor",
 8014e3a:	230a      	movs	r3, #10
 8014e3c:	9300      	str	r3, [sp, #0]
 8014e3e:	2314      	movs	r3, #20
 8014e40:	9301      	str	r3, [sp, #4]
 8014e42:	4809      	ldr	r0, [pc, #36]	; (8014e68 <USER_MotorTask_init+0x34>)
 8014e44:	4909      	ldr	r1, [pc, #36]	; (8014e6c <USER_MotorTask_init+0x38>)
 8014e46:	2200      	movs	r2, #0
 8014e48:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8014e4c:	f003 fb6e 	bl	801852c <rt_thread_create>
 8014e50:	6078      	str	r0, [r7, #4]
                           USER_MotorTask_entry, RT_NULL,
                           1024, USER_MOTORTASK_PRIORITY, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 8014e52:	687b      	ldr	r3, [r7, #4]
 8014e54:	2b00      	cmp	r3, #0
 8014e56:	d002      	beq.n	8014e5e <USER_MotorTask_init+0x2a>
 8014e58:	6878      	ldr	r0, [r7, #4]
 8014e5a:	f003 fb29 	bl	80184b0 <rt_thread_startup>

    return 0;
 8014e5e:	2300      	movs	r3, #0
}
 8014e60:	4618      	mov	r0, r3
 8014e62:	3708      	adds	r7, #8
 8014e64:	46bd      	mov	sp, r7
 8014e66:	bd80      	pop	{r7, pc}
 8014e68:	08028ce8 	.word	0x08028ce8
 8014e6c:	080148e1 	.word	0x080148e1

08014e70 <rt_init_thread_entry>:

#include <rtthread.h>
#include <components.h>

void rt_init_thread_entry(void *parameter)
{
 8014e70:	b580      	push	{r7, lr}
 8014e72:	b082      	sub	sp, #8
 8014e74:	af00      	add	r7, sp, #0
 8014e76:	6078      	str	r0, [r7, #4]
    rt_components_init();
 8014e78:	f000 fa7c 	bl	8015374 <rt_components_init>
}
 8014e7c:	3708      	adds	r7, #8
 8014e7e:	46bd      	mov	sp, r7
 8014e80:	bd80      	pop	{r7, pc}
 8014e82:	bf00      	nop

08014e84 <rt_application_init>:

int rt_application_init()
{
 8014e84:	b580      	push	{r7, lr}
 8014e86:	b084      	sub	sp, #16
 8014e88:	af02      	add	r7, sp, #8
    rt_thread_t tid;

    tid = rt_thread_create("init",
 8014e8a:	230a      	movs	r3, #10
 8014e8c:	9300      	str	r3, [sp, #0]
 8014e8e:	2314      	movs	r3, #20
 8014e90:	9301      	str	r3, [sp, #4]
 8014e92:	4809      	ldr	r0, [pc, #36]	; (8014eb8 <rt_application_init+0x34>)
 8014e94:	4909      	ldr	r1, [pc, #36]	; (8014ebc <rt_application_init+0x38>)
 8014e96:	2200      	movs	r2, #0
 8014e98:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8014e9c:	f003 fb46 	bl	801852c <rt_thread_create>
 8014ea0:	6078      	str	r0, [r7, #4]
                           rt_init_thread_entry, RT_NULL,
                           2048, RT_THREAD_PRIORITY_MAX / 3, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 8014ea2:	687b      	ldr	r3, [r7, #4]
 8014ea4:	2b00      	cmp	r3, #0
 8014ea6:	d002      	beq.n	8014eae <rt_application_init+0x2a>
 8014ea8:	6878      	ldr	r0, [r7, #4]
 8014eaa:	f003 fb01 	bl	80184b0 <rt_thread_startup>

    return 0;
 8014eae:	2300      	movs	r3, #0
}
 8014eb0:	4618      	mov	r0, r3
 8014eb2:	3708      	adds	r7, #8
 8014eb4:	46bd      	mov	sp, r7
 8014eb6:	bd80      	pop	{r7, pc}
 8014eb8:	08028cf0 	.word	0x08028cf0
 8014ebc:	08014e71 	.word	0x08014e71

08014ec0 <sram_init>:

#ifdef RT_USING_EXT_SDRAM
struct rt_memheap system_heap;

void sram_init(void)
{
 8014ec0:	b580      	push	{r7, lr}
 8014ec2:	af00      	add	r7, sp, #0
    /* initialize the built-in SRAM as a memory heap */
    rt_memheap_init(&system_heap,
                    "system",
                    (void *)HEAP_BEGIN,
                    (rt_uint32_t)HEAP_END - (rt_uint32_t)HEAP_BEGIN);
 8014ec4:	4a04      	ldr	r2, [pc, #16]	; (8014ed8 <sram_init+0x18>)
struct rt_memheap system_heap;

void sram_init(void)
{
    /* initialize the built-in SRAM as a memory heap */
    rt_memheap_init(&system_heap,
 8014ec6:	4b05      	ldr	r3, [pc, #20]	; (8014edc <sram_init+0x1c>)
 8014ec8:	1a9b      	subs	r3, r3, r2
 8014eca:	4805      	ldr	r0, [pc, #20]	; (8014ee0 <sram_init+0x20>)
 8014ecc:	4905      	ldr	r1, [pc, #20]	; (8014ee4 <sram_init+0x24>)
 8014ece:	4a02      	ldr	r2, [pc, #8]	; (8014ed8 <sram_init+0x18>)
 8014ed0:	f002 fdd8 	bl	8017a84 <rt_memheap_init>
                    "system",
                    (void *)HEAP_BEGIN,
                    (rt_uint32_t)HEAP_END - (rt_uint32_t)HEAP_BEGIN);
}
 8014ed4:	bd80      	pop	{r7, pc}
 8014ed6:	bf00      	nop
 8014ed8:	20012ff4 	.word	0x20012ff4
 8014edc:	20050000 	.word	0x20050000
 8014ee0:	200129f4 	.word	0x200129f4
 8014ee4:	08028cf8 	.word	0x08028cf8

08014ee8 <rtthread_startup>:

/**
 * This function will startup RT-Thread RTOS.
 */
void rtthread_startup(void)
{
 8014ee8:	b580      	push	{r7, lr}
 8014eea:	af00      	add	r7, sp, #0
    /* init board */
    rt_hw_board_init();
 8014eec:	f7fd f9de 	bl	80122ac <rt_hw_board_init>

    /* show version */
    rt_show_version();
 8014ef0:	f001 fcce 	bl	8016890 <rt_show_version>

    /* init tick */
    rt_system_tick_init();
 8014ef4:	f000 f9c2 	bl	801527c <rt_system_tick_init>

    /* init kernel object */
    rt_system_object_init();
 8014ef8:	f002 fe98 	bl	8017c2c <rt_system_object_init>

    /* init timer system */
    rt_system_timer_init();
 8014efc:	f004 f876 	bl	8018fec <rt_system_timer_init>

#ifdef RT_USING_EXT_SDRAM
    sdram_hw_init();
 8014f00:	f7fe fc2a 	bl	8013758 <sdram_hw_init>
    rt_system_heap_init((void*)EXT_SDRAM_BEGIN, (void*)EXT_SDRAM_END);
 8014f04:	f04f 4040 	mov.w	r0, #3221225472	; 0xc0000000
 8014f08:	4908      	ldr	r1, [pc, #32]	; (8014f2c <rtthread_startup+0x44>)
 8014f0a:	f002 fa21 	bl	8017350 <rt_system_heap_init>
    sram_init();
 8014f0e:	f7ff ffd7 	bl	8014ec0 <sram_init>
#else
    rt_system_heap_init((void*)HEAP_BEGIN, (void*)HEAP_END);
#endif

    /* init scheduler system */
    rt_system_scheduler_init();
 8014f12:	f003 f83d 	bl	8017f90 <rt_system_scheduler_init>

    /* init application */
    rt_application_init();
 8014f16:	f7ff ffb5 	bl	8014e84 <rt_application_init>

    /* init timer thread */
    rt_system_timer_thread_init();
 8014f1a:	f004 f87f 	bl	801901c <rt_system_timer_thread_init>

    /* init idle thread */
    rt_thread_idle_init();
 8014f1e:	f000 fc99 	bl	8015854 <rt_thread_idle_init>
    /* start scheduler */
    rt_system_scheduler_start();
 8014f22:	f003 f85f 	bl	8017fe4 <rt_system_scheduler_start>

    /* never reach here */
    return ;
 8014f26:	bf00      	nop
}
 8014f28:	bd80      	pop	{r7, pc}
 8014f2a:	bf00      	nop
 8014f2c:	c0100000 	.word	0xc0100000

08014f30 <main>:

int main(void)
{
 8014f30:	b580      	push	{r7, lr}
 8014f32:	af00      	add	r7, sp, #0
    /* disable interrupt first */
    rt_hw_interrupt_disable();
 8014f34:	f7eb f94a 	bl	80001cc <rt_hw_interrupt_disable>

    /* startup RT-Thread RTOS */
    rtthread_startup();
 8014f38:	f7ff ffd6 	bl	8014ee8 <rtthread_startup>

    return 0;
 8014f3c:	2300      	movs	r3, #0
}
 8014f3e:	4618      	mov	r0, r3
 8014f40:	bd80      	pop	{r7, pc}
 8014f42:	bf00      	nop

08014f44 <myprintf>:
	char size;
};

static rt_mq_t rx_mq;
rt_err_t myprintf(char *buf, uint8_t size)
{
 8014f44:	b580      	push	{r7, lr}
 8014f46:	b086      	sub	sp, #24
 8014f48:	af00      	add	r7, sp, #0
 8014f4a:	6078      	str	r0, [r7, #4]
 8014f4c:	460b      	mov	r3, r1
 8014f4e:	70fb      	strb	r3, [r7, #3]
	struct tx_msg txmsg;
	rt_err_t result = RT_EOK;
 8014f50:	2300      	movs	r3, #0
 8014f52:	617b      	str	r3, [r7, #20]
	
	if(tx_mq == RT_NULL || txfifo == RT_NULL || buf == RT_NULL)
 8014f54:	4b22      	ldr	r3, [pc, #136]	; (8014fe0 <myprintf+0x9c>)
 8014f56:	681b      	ldr	r3, [r3, #0]
 8014f58:	2b00      	cmp	r3, #0
 8014f5a:	d006      	beq.n	8014f6a <myprintf+0x26>
 8014f5c:	4b21      	ldr	r3, [pc, #132]	; (8014fe4 <myprintf+0xa0>)
 8014f5e:	681b      	ldr	r3, [r3, #0]
 8014f60:	2b00      	cmp	r3, #0
 8014f62:	d002      	beq.n	8014f6a <myprintf+0x26>
 8014f64:	687b      	ldr	r3, [r7, #4]
 8014f66:	2b00      	cmp	r3, #0
 8014f68:	d103      	bne.n	8014f72 <myprintf+0x2e>
		return (result = RT_ERROR);
 8014f6a:	2301      	movs	r3, #1
 8014f6c:	617b      	str	r3, [r7, #20]
 8014f6e:	697b      	ldr	r3, [r7, #20]
 8014f70:	e032      	b.n	8014fd8 <myprintf+0x94>
	txmsg.size = size;
 8014f72:	78fb      	ldrb	r3, [r7, #3]
 8014f74:	613b      	str	r3, [r7, #16]
	txmsg.data = buf;
 8014f76:	687b      	ldr	r3, [r7, #4]
 8014f78:	60fb      	str	r3, [r7, #12]
	txfifo->txmsg[txfifo->index] = txmsg;
 8014f7a:	4b1a      	ldr	r3, [pc, #104]	; (8014fe4 <myprintf+0xa0>)
 8014f7c:	681b      	ldr	r3, [r3, #0]
 8014f7e:	681a      	ldr	r2, [r3, #0]
 8014f80:	4b18      	ldr	r3, [pc, #96]	; (8014fe4 <myprintf+0xa0>)
 8014f82:	681b      	ldr	r3, [r3, #0]
 8014f84:	791b      	ldrb	r3, [r3, #4]
 8014f86:	00db      	lsls	r3, r3, #3
 8014f88:	4413      	add	r3, r2
 8014f8a:	461a      	mov	r2, r3
 8014f8c:	f107 030c 	add.w	r3, r7, #12
 8014f90:	e893 0003 	ldmia.w	r3, {r0, r1}
 8014f94:	e882 0003 	stmia.w	r2, {r0, r1}
	result = rt_mq_send(tx_mq,&(txfifo->txmsg[txfifo->index]),sizeof(struct tx_msg));
 8014f98:	4b11      	ldr	r3, [pc, #68]	; (8014fe0 <myprintf+0x9c>)
 8014f9a:	6819      	ldr	r1, [r3, #0]
 8014f9c:	4b11      	ldr	r3, [pc, #68]	; (8014fe4 <myprintf+0xa0>)
 8014f9e:	681b      	ldr	r3, [r3, #0]
 8014fa0:	681a      	ldr	r2, [r3, #0]
 8014fa2:	4b10      	ldr	r3, [pc, #64]	; (8014fe4 <myprintf+0xa0>)
 8014fa4:	681b      	ldr	r3, [r3, #0]
 8014fa6:	791b      	ldrb	r3, [r3, #4]
 8014fa8:	00db      	lsls	r3, r3, #3
 8014faa:	4413      	add	r3, r2
 8014fac:	4608      	mov	r0, r1
 8014fae:	4619      	mov	r1, r3
 8014fb0:	2208      	movs	r2, #8
 8014fb2:	f001 f8e7 	bl	8016184 <rt_mq_send>
 8014fb6:	6178      	str	r0, [r7, #20]
	txfifo->index++;
 8014fb8:	4b0a      	ldr	r3, [pc, #40]	; (8014fe4 <myprintf+0xa0>)
 8014fba:	681b      	ldr	r3, [r3, #0]
 8014fbc:	791a      	ldrb	r2, [r3, #4]
 8014fbe:	3201      	adds	r2, #1
 8014fc0:	b2d2      	uxtb	r2, r2
 8014fc2:	711a      	strb	r2, [r3, #4]
	if(txfifo->index > UART3TXFIFOLENGTH)
 8014fc4:	4b07      	ldr	r3, [pc, #28]	; (8014fe4 <myprintf+0xa0>)
 8014fc6:	681b      	ldr	r3, [r3, #0]
 8014fc8:	791b      	ldrb	r3, [r3, #4]
 8014fca:	2b03      	cmp	r3, #3
 8014fcc:	d903      	bls.n	8014fd6 <myprintf+0x92>
	{
		txfifo->index = 0;
 8014fce:	4b05      	ldr	r3, [pc, #20]	; (8014fe4 <myprintf+0xa0>)
 8014fd0:	681b      	ldr	r3, [r3, #0]
 8014fd2:	2200      	movs	r2, #0
 8014fd4:	711a      	strb	r2, [r3, #4]
	}
	return result;
 8014fd6:	697b      	ldr	r3, [r7, #20]
}
 8014fd8:	4618      	mov	r0, r3
 8014fda:	3718      	adds	r7, #24
 8014fdc:	46bd      	mov	sp, r7
 8014fde:	bd80      	pop	{r7, pc}
 8014fe0:	20010a58 	.word	0x20010a58
 8014fe4:	20012a58 	.word	0x20012a58

08014fe8 <USER_Usart3txTask_entry>:

void USER_Usart3txTask_entry(void *parameter)
{
 8014fe8:	b580      	push	{r7, lr}
 8014fea:	b086      	sub	sp, #24
 8014fec:	af00      	add	r7, sp, #0
 8014fee:	6078      	str	r0, [r7, #4]
	
	rt_device_t device;
	device = rt_device_find("uart3");
 8014ff0:	4813      	ldr	r0, [pc, #76]	; (8015040 <USER_Usart3txTask_entry+0x58>)
 8014ff2:	f000 f9ff 	bl	80153f4 <rt_device_find>
 8014ff6:	6178      	str	r0, [r7, #20]
	rt_err_t result = RT_EOK;
 8014ff8:	2300      	movs	r3, #0
 8014ffa:	613b      	str	r3, [r7, #16]
	
	struct tx_msg txmsg;
	if ( device != RT_NULL )
 8014ffc:	697b      	ldr	r3, [r7, #20]
 8014ffe:	2b00      	cmp	r3, #0
 8015000:	d00a      	beq.n	8015018 <USER_Usart3txTask_entry+0x30>
	{
		
		
		if (rt_device_open (device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_INT_RX) != RT_EOK)
 8015002:	6978      	ldr	r0, [r7, #20]
 8015004:	f240 1103 	movw	r1, #259	; 0x103
 8015008:	f000 fa30 	bl	801546c <rt_device_open>
 801500c:	4603      	mov	r3, r0
 801500e:	2b00      	cmp	r3, #0
 8015010:	d002      	beq.n	8015018 <USER_Usart3txTask_entry+0x30>
		{
			rt_kprintf("open error\r\n");
 8015012:	480c      	ldr	r0, [pc, #48]	; (8015044 <USER_Usart3txTask_entry+0x5c>)
 8015014:	f002 f87c 	bl	8017110 <rt_kprintf>
		}
	}
	
	while(1)
	{
		rt_mq_recv(tx_mq,&txmsg,sizeof(struct tx_msg),50);
 8015018:	4b0b      	ldr	r3, [pc, #44]	; (8015048 <USER_Usart3txTask_entry+0x60>)
 801501a:	681a      	ldr	r2, [r3, #0]
 801501c:	f107 0308 	add.w	r3, r7, #8
 8015020:	4610      	mov	r0, r2
 8015022:	4619      	mov	r1, r3
 8015024:	2208      	movs	r2, #8
 8015026:	2332      	movs	r3, #50	; 0x32
 8015028:	f001 f946 	bl	80162b8 <rt_mq_recv>
		
		if (result == RT_EOK)
 801502c:	693b      	ldr	r3, [r7, #16]
 801502e:	2b00      	cmp	r3, #0
 8015030:	d105      	bne.n	801503e <USER_Usart3txTask_entry+0x56>
		{
			rt_device_write(device, 0,txmsg.data,txmsg.size);
 8015032:	68ba      	ldr	r2, [r7, #8]
 8015034:	68fb      	ldr	r3, [r7, #12]
 8015036:	6978      	ldr	r0, [r7, #20]
 8015038:	2100      	movs	r1, #0
 801503a:	f000 fafd 	bl	8015638 <rt_device_write>
		}
	}
 801503e:	e7eb      	b.n	8015018 <USER_Usart3txTask_entry+0x30>
 8015040:	08028d00 	.word	0x08028d00
 8015044:	08028d08 	.word	0x08028d08
 8015048:	20010a58 	.word	0x20010a58

0801504c <USER_Usart3txTask_init>:
	
}


int USER_Usart3txTask_init()
{
 801504c:	b580      	push	{r7, lr}
 801504e:	b084      	sub	sp, #16
 8015050:	af02      	add	r7, sp, #8
    rt_thread_t tid;

	
	if ((tx_mq = rt_mq_create("usart3tx", sizeof(struct tx_msg),UART3TXFIFOLENGTH,RT_IPC_FLAG_FIFO)) == RT_NULL)
 8015052:	4821      	ldr	r0, [pc, #132]	; (80150d8 <USER_Usart3txTask_init+0x8c>)
 8015054:	2108      	movs	r1, #8
 8015056:	2203      	movs	r2, #3
 8015058:	2300      	movs	r3, #0
 801505a:	f000 ffd5 	bl	8016008 <rt_mq_create>
 801505e:	4602      	mov	r2, r0
 8015060:	4b1e      	ldr	r3, [pc, #120]	; (80150dc <USER_Usart3txTask_init+0x90>)
 8015062:	601a      	str	r2, [r3, #0]
 8015064:	4b1d      	ldr	r3, [pc, #116]	; (80150dc <USER_Usart3txTask_init+0x90>)
 8015066:	681b      	ldr	r3, [r3, #0]
 8015068:	2b00      	cmp	r3, #0
 801506a:	d102      	bne.n	8015072 <USER_Usart3txTask_init+0x26>
	{
		rt_kprintf("sem create error\r\n");
 801506c:	481c      	ldr	r0, [pc, #112]	; (80150e0 <USER_Usart3txTask_init+0x94>)
 801506e:	f002 f84f 	bl	8017110 <rt_kprintf>
	}
	
	txfifo = (struct Txfifo *)rt_malloc(sizeof(struct Txfifo)+UART3TXFIFOLENGTH*sizeof(struct tx_msg));
 8015072:	2020      	movs	r0, #32
 8015074:	f002 f9fa 	bl	801746c <rt_malloc>
 8015078:	4602      	mov	r2, r0
 801507a:	4b1a      	ldr	r3, [pc, #104]	; (80150e4 <USER_Usart3txTask_init+0x98>)
 801507c:	601a      	str	r2, [r3, #0]
	if(txfifo != RT_NULL)
 801507e:	4b19      	ldr	r3, [pc, #100]	; (80150e4 <USER_Usart3txTask_init+0x98>)
 8015080:	681b      	ldr	r3, [r3, #0]
 8015082:	2b00      	cmp	r3, #0
 8015084:	d011      	beq.n	80150aa <USER_Usart3txTask_init+0x5e>
	{
		txfifo->txmsg = (struct tx_msg *)(txfifo+1);
 8015086:	4b17      	ldr	r3, [pc, #92]	; (80150e4 <USER_Usart3txTask_init+0x98>)
 8015088:	681b      	ldr	r3, [r3, #0]
 801508a:	4a16      	ldr	r2, [pc, #88]	; (80150e4 <USER_Usart3txTask_init+0x98>)
 801508c:	6812      	ldr	r2, [r2, #0]
 801508e:	3208      	adds	r2, #8
 8015090:	601a      	str	r2, [r3, #0]
		rt_memset(txfifo->txmsg,0,UART3TXFIFOLENGTH*sizeof(struct tx_msg));
 8015092:	4b14      	ldr	r3, [pc, #80]	; (80150e4 <USER_Usart3txTask_init+0x98>)
 8015094:	681b      	ldr	r3, [r3, #0]
 8015096:	681b      	ldr	r3, [r3, #0]
 8015098:	4618      	mov	r0, r3
 801509a:	2100      	movs	r1, #0
 801509c:	2218      	movs	r2, #24
 801509e:	f001 fa7f 	bl	80165a0 <rt_memset>
		txfifo->index = 0;
 80150a2:	4b10      	ldr	r3, [pc, #64]	; (80150e4 <USER_Usart3txTask_init+0x98>)
 80150a4:	681b      	ldr	r3, [r3, #0]
 80150a6:	2200      	movs	r2, #0
 80150a8:	711a      	strb	r2, [r3, #4]
	}
	
	tid = rt_thread_create("usart3tx",						
 80150aa:	2309      	movs	r3, #9
 80150ac:	9300      	str	r3, [sp, #0]
 80150ae:	2314      	movs	r3, #20
 80150b0:	9301      	str	r3, [sp, #4]
 80150b2:	4809      	ldr	r0, [pc, #36]	; (80150d8 <USER_Usart3txTask_init+0x8c>)
 80150b4:	490c      	ldr	r1, [pc, #48]	; (80150e8 <USER_Usart3txTask_init+0x9c>)
 80150b6:	2200      	movs	r2, #0
 80150b8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80150bc:	f003 fa36 	bl	801852c <rt_thread_create>
 80150c0:	6078      	str	r0, [r7, #4]
                           USER_Usart3txTask_entry, RT_NULL,
                           1024, USER_Usart3txTask_PRIORITY, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 80150c2:	687b      	ldr	r3, [r7, #4]
 80150c4:	2b00      	cmp	r3, #0
 80150c6:	d002      	beq.n	80150ce <USER_Usart3txTask_init+0x82>
 80150c8:	6878      	ldr	r0, [r7, #4]
 80150ca:	f003 f9f1 	bl	80184b0 <rt_thread_startup>

    return 0;
 80150ce:	2300      	movs	r3, #0
}
 80150d0:	4618      	mov	r0, r3
 80150d2:	3708      	adds	r7, #8
 80150d4:	46bd      	mov	sp, r7
 80150d6:	bd80      	pop	{r7, pc}
 80150d8:	08028d18 	.word	0x08028d18
 80150dc:	20010a58 	.word	0x20010a58
 80150e0:	08028d24 	.word	0x08028d24
 80150e4:	20012a58 	.word	0x20012a58
 80150e8:	08014fe9 	.word	0x08014fe9

080150ec <uart_input>:
		buf[i] = '\0';
	}
	return result;
}
static rt_err_t uart_input(rt_device_t dev, rt_size_t size)
{
 80150ec:	b580      	push	{r7, lr}
 80150ee:	b082      	sub	sp, #8
 80150f0:	af00      	add	r7, sp, #0
 80150f2:	6078      	str	r0, [r7, #4]
 80150f4:	6039      	str	r1, [r7, #0]
	rt_sem_release(rx_sem);
 80150f6:	4b05      	ldr	r3, [pc, #20]	; (801510c <uart_input+0x20>)
 80150f8:	681b      	ldr	r3, [r3, #0]
 80150fa:	4618      	mov	r0, r3
 80150fc:	f000 fd98 	bl	8015c30 <rt_sem_release>
	return RT_EOK;
 8015100:	2300      	movs	r3, #0
}
 8015102:	4618      	mov	r0, r3
 8015104:	3708      	adds	r7, #8
 8015106:	46bd      	mov	sp, r7
 8015108:	bd80      	pop	{r7, pc}
 801510a:	bf00      	nop
 801510c:	20010a60 	.word	0x20010a60

08015110 <USER_Usart3rxTask_entry>:

void USER_Usart3rxTask_entry(void *parameter)
{
 8015110:	b580      	push	{r7, lr}
 8015112:	b08c      	sub	sp, #48	; 0x30
 8015114:	af00      	add	r7, sp, #0
 8015116:	6078      	str	r0, [r7, #4]

	rt_device_t device;
	rt_err_t result = RT_EOK;
 8015118:	2300      	movs	r3, #0
 801511a:	62fb      	str	r3, [r7, #44]	; 0x2c
	static char i = 0;
	char rcvdata[RCVLENTH];
	struct rx_msg rx_msg;
	
	
	device = rt_device_find("uart3");
 801511c:	482b      	ldr	r0, [pc, #172]	; (80151cc <USER_Usart3rxTask_entry+0xbc>)
 801511e:	f000 f969 	bl	80153f4 <rt_device_find>
 8015122:	62b8      	str	r0, [r7, #40]	; 0x28
	
	if ( device != RT_NULL )
 8015124:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015126:	2b00      	cmp	r3, #0
 8015128:	d00e      	beq.n	8015148 <USER_Usart3rxTask_entry+0x38>
	{
		rt_device_set_rx_indicate(device, uart_input);
 801512a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801512c:	4928      	ldr	r1, [pc, #160]	; (80151d0 <USER_Usart3rxTask_entry+0xc0>)
 801512e:	f000 fadd 	bl	80156ec <rt_device_set_rx_indicate>
		if (rt_device_open (device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_INT_RX ) != RT_EOK)
 8015132:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8015134:	f240 1103 	movw	r1, #259	; 0x103
 8015138:	f000 f998 	bl	801546c <rt_device_open>
 801513c:	4603      	mov	r3, r0
 801513e:	2b00      	cmp	r3, #0
 8015140:	d002      	beq.n	8015148 <USER_Usart3rxTask_entry+0x38>
		{
			rt_kprintf("open error\r\n");
 8015142:	4824      	ldr	r0, [pc, #144]	; (80151d4 <USER_Usart3rxTask_entry+0xc4>)
 8015144:	f001 ffe4 	bl	8017110 <rt_kprintf>
	}
	while(1)
	{
		//struct rx_msg msg;
		//rt_device_write(device, 0,buf,130);
		result = rt_sem_take(rx_sem, RT_WAITING_FOREVER);
 8015148:	4b23      	ldr	r3, [pc, #140]	; (80151d8 <USER_Usart3rxTask_entry+0xc8>)
 801514a:	681b      	ldr	r3, [r3, #0]
 801514c:	4618      	mov	r0, r3
 801514e:	f04f 31ff 	mov.w	r1, #4294967295
 8015152:	f000 fcc9 	bl	8015ae8 <rt_sem_take>
 8015156:	62f8      	str	r0, [r7, #44]	; 0x2c
		if (result == RT_EOK)
 8015158:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801515a:	2b00      	cmp	r3, #0
 801515c:	d134      	bne.n	80151c8 <USER_Usart3rxTask_entry+0xb8>
		{
			rt_uint32_t rx_length;
			rx_length = rt_device_read(device, 0, &ch,1);
 801515e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8015160:	2100      	movs	r1, #0
 8015162:	4a1e      	ldr	r2, [pc, #120]	; (80151dc <USER_Usart3rxTask_entry+0xcc>)
 8015164:	2301      	movs	r3, #1
 8015166:	f000 fa33 	bl	80155d0 <rt_device_read>
 801516a:	6278      	str	r0, [r7, #36]	; 0x24
			if(rx_length != 0)
 801516c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801516e:	2b00      	cmp	r3, #0
 8015170:	d02a      	beq.n	80151c8 <USER_Usart3rxTask_entry+0xb8>
			{
				rcvdata[i++] = ch;
 8015172:	4b1b      	ldr	r3, [pc, #108]	; (80151e0 <USER_Usart3rxTask_entry+0xd0>)
 8015174:	781b      	ldrb	r3, [r3, #0]
 8015176:	1c5a      	adds	r2, r3, #1
 8015178:	b2d1      	uxtb	r1, r2
 801517a:	4a19      	ldr	r2, [pc, #100]	; (80151e0 <USER_Usart3rxTask_entry+0xd0>)
 801517c:	7011      	strb	r1, [r2, #0]
 801517e:	4619      	mov	r1, r3
 8015180:	4b16      	ldr	r3, [pc, #88]	; (80151dc <USER_Usart3rxTask_entry+0xcc>)
 8015182:	781a      	ldrb	r2, [r3, #0]
 8015184:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8015188:	440b      	add	r3, r1
 801518a:	f803 2c1c 	strb.w	r2, [r3, #-28]
				if(ch == 0x0d)
 801518e:	4b13      	ldr	r3, [pc, #76]	; (80151dc <USER_Usart3rxTask_entry+0xcc>)
 8015190:	781b      	ldrb	r3, [r3, #0]
 8015192:	2b0d      	cmp	r3, #13
 8015194:	d111      	bne.n	80151ba <USER_Usart3rxTask_entry+0xaa>
				{
					rx_msg.size = i;
 8015196:	4b12      	ldr	r3, [pc, #72]	; (80151e0 <USER_Usart3rxTask_entry+0xd0>)
 8015198:	781b      	ldrb	r3, [r3, #0]
 801519a:	743b      	strb	r3, [r7, #16]
					i = 0;
 801519c:	4b10      	ldr	r3, [pc, #64]	; (80151e0 <USER_Usart3rxTask_entry+0xd0>)
 801519e:	2200      	movs	r2, #0
 80151a0:	701a      	strb	r2, [r3, #0]
					rx_msg.data = rcvdata;
 80151a2:	f107 0314 	add.w	r3, r7, #20
 80151a6:	60fb      	str	r3, [r7, #12]
					rt_mq_send(rx_mq,&rx_msg,sizeof(struct rx_msg));
 80151a8:	4b0e      	ldr	r3, [pc, #56]	; (80151e4 <USER_Usart3rxTask_entry+0xd4>)
 80151aa:	681a      	ldr	r2, [r3, #0]
 80151ac:	f107 030c 	add.w	r3, r7, #12
 80151b0:	4610      	mov	r0, r2
 80151b2:	4619      	mov	r1, r3
 80151b4:	2208      	movs	r2, #8
 80151b6:	f000 ffe5 	bl	8016184 <rt_mq_send>
				}
				
				if(i >= RCVLENTH)
 80151ba:	4b09      	ldr	r3, [pc, #36]	; (80151e0 <USER_Usart3rxTask_entry+0xd0>)
 80151bc:	781b      	ldrb	r3, [r3, #0]
 80151be:	2b0d      	cmp	r3, #13
 80151c0:	d902      	bls.n	80151c8 <USER_Usart3rxTask_entry+0xb8>
					i = 0;
 80151c2:	4b07      	ldr	r3, [pc, #28]	; (80151e0 <USER_Usart3rxTask_entry+0xd0>)
 80151c4:	2200      	movs	r2, #0
 80151c6:	701a      	strb	r2, [r3, #0]
			}
		}
	}
 80151c8:	e7be      	b.n	8015148 <USER_Usart3rxTask_entry+0x38>
 80151ca:	bf00      	nop
 80151cc:	08028d00 	.word	0x08028d00
 80151d0:	080150ed 	.word	0x080150ed
 80151d4:	08028d08 	.word	0x08028d08
 80151d8:	20010a60 	.word	0x20010a60
 80151dc:	20010a5c 	.word	0x20010a5c
 80151e0:	20010a68 	.word	0x20010a68
 80151e4:	20010a64 	.word	0x20010a64

080151e8 <USER_Usart3rxTask_init>:




int USER_Usart3rxTask_init()
{
 80151e8:	b580      	push	{r7, lr}
 80151ea:	b084      	sub	sp, #16
 80151ec:	af02      	add	r7, sp, #8
    rt_thread_t tid;
	rt_device_t device;

	if ((rx_sem = rt_sem_create("usart3rcv", 0, RT_IPC_FLAG_FIFO)) == RT_NULL)
 80151ee:	481b      	ldr	r0, [pc, #108]	; (801525c <USER_Usart3rxTask_init+0x74>)
 80151f0:	2100      	movs	r1, #0
 80151f2:	2200      	movs	r2, #0
 80151f4:	f000 fc3c 	bl	8015a70 <rt_sem_create>
 80151f8:	4602      	mov	r2, r0
 80151fa:	4b19      	ldr	r3, [pc, #100]	; (8015260 <USER_Usart3rxTask_init+0x78>)
 80151fc:	601a      	str	r2, [r3, #0]
 80151fe:	4b18      	ldr	r3, [pc, #96]	; (8015260 <USER_Usart3rxTask_init+0x78>)
 8015200:	681b      	ldr	r3, [r3, #0]
 8015202:	2b00      	cmp	r3, #0
 8015204:	d102      	bne.n	801520c <USER_Usart3rxTask_init+0x24>
	{
		rt_kprintf("sem create error\r\n");
 8015206:	4817      	ldr	r0, [pc, #92]	; (8015264 <USER_Usart3rxTask_init+0x7c>)
 8015208:	f001 ff82 	bl	8017110 <rt_kprintf>
	}
	if ((rx_mq = rt_mq_create("usart3rxmq", sizeof(struct rx_msg),RXMQSIZE,RT_IPC_FLAG_FIFO)) == RT_NULL)
 801520c:	4816      	ldr	r0, [pc, #88]	; (8015268 <USER_Usart3rxTask_init+0x80>)
 801520e:	2108      	movs	r1, #8
 8015210:	2203      	movs	r2, #3
 8015212:	2300      	movs	r3, #0
 8015214:	f000 fef8 	bl	8016008 <rt_mq_create>
 8015218:	4602      	mov	r2, r0
 801521a:	4b14      	ldr	r3, [pc, #80]	; (801526c <USER_Usart3rxTask_init+0x84>)
 801521c:	601a      	str	r2, [r3, #0]
 801521e:	4b13      	ldr	r3, [pc, #76]	; (801526c <USER_Usart3rxTask_init+0x84>)
 8015220:	681b      	ldr	r3, [r3, #0]
 8015222:	2b00      	cmp	r3, #0
 8015224:	d102      	bne.n	801522c <USER_Usart3rxTask_init+0x44>
	{
		rt_kprintf("rx_mq create error\r\n");
 8015226:	4812      	ldr	r0, [pc, #72]	; (8015270 <USER_Usart3rxTask_init+0x88>)
 8015228:	f001 ff72 	bl	8017110 <rt_kprintf>
	}
	
	tid = rt_thread_create("usart3rx",						
 801522c:	2309      	movs	r3, #9
 801522e:	9300      	str	r3, [sp, #0]
 8015230:	2314      	movs	r3, #20
 8015232:	9301      	str	r3, [sp, #4]
 8015234:	480f      	ldr	r0, [pc, #60]	; (8015274 <USER_Usart3rxTask_init+0x8c>)
 8015236:	4910      	ldr	r1, [pc, #64]	; (8015278 <USER_Usart3rxTask_init+0x90>)
 8015238:	2200      	movs	r2, #0
 801523a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 801523e:	f003 f975 	bl	801852c <rt_thread_create>
 8015242:	6078      	str	r0, [r7, #4]
                           USER_Usart3rxTask_entry, RT_NULL,
                           1024, USER_Usart3rxTask_PRIORITY, 20);
    if (tid != RT_NULL) rt_thread_startup(tid);
 8015244:	687b      	ldr	r3, [r7, #4]
 8015246:	2b00      	cmp	r3, #0
 8015248:	d002      	beq.n	8015250 <USER_Usart3rxTask_init+0x68>
 801524a:	6878      	ldr	r0, [r7, #4]
 801524c:	f003 f930 	bl	80184b0 <rt_thread_startup>

    return 0;
 8015250:	2300      	movs	r3, #0
}
 8015252:	4618      	mov	r0, r3
 8015254:	3708      	adds	r7, #8
 8015256:	46bd      	mov	sp, r7
 8015258:	bd80      	pop	{r7, pc}
 801525a:	bf00      	nop
 801525c:	08028d38 	.word	0x08028d38
 8015260:	20010a60 	.word	0x20010a60
 8015264:	08028d24 	.word	0x08028d24
 8015268:	08028d44 	.word	0x08028d44
 801526c:	20010a64 	.word	0x20010a64
 8015270:	08028d50 	.word	0x08028d50
 8015274:	08028d68 	.word	0x08028d68
 8015278:	08015111 	.word	0x08015111

0801527c <rt_system_tick_init>:
 *
 * @deprecated since 1.1.0, this function does not need to be invoked
 * in the system initialization.
 */
void rt_system_tick_init(void)
{
 801527c:	b480      	push	{r7}
 801527e:	af00      	add	r7, sp, #0
}
 8015280:	46bd      	mov	sp, r7
 8015282:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015286:	4770      	bx	lr

08015288 <rt_tick_get>:
 * This function will return current tick from operating system startup
 *
 * @return current tick
 */
rt_tick_t rt_tick_get(void)
{
 8015288:	b480      	push	{r7}
 801528a:	af00      	add	r7, sp, #0
    /* return the global tick */
    return rt_tick;
 801528c:	4b03      	ldr	r3, [pc, #12]	; (801529c <rt_tick_get+0x14>)
 801528e:	681b      	ldr	r3, [r3, #0]
}
 8015290:	4618      	mov	r0, r3
 8015292:	46bd      	mov	sp, r7
 8015294:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015298:	4770      	bx	lr
 801529a:	bf00      	nop
 801529c:	20010a6c 	.word	0x20010a6c

080152a0 <rt_tick_increase>:
/**
 * This function will notify kernel there is one tick passed. Normally,
 * this function is invoked by clock ISR.
 */
void rt_tick_increase(void)
{
 80152a0:	b580      	push	{r7, lr}
 80152a2:	b082      	sub	sp, #8
 80152a4:	af00      	add	r7, sp, #0
    struct rt_thread *thread;

    /* increase the global tick */
    ++ rt_tick;
 80152a6:	4b0e      	ldr	r3, [pc, #56]	; (80152e0 <rt_tick_increase+0x40>)
 80152a8:	681b      	ldr	r3, [r3, #0]
 80152aa:	3301      	adds	r3, #1
 80152ac:	4a0c      	ldr	r2, [pc, #48]	; (80152e0 <rt_tick_increase+0x40>)
 80152ae:	6013      	str	r3, [r2, #0]

    /* check time slice */
    thread = rt_thread_self();
 80152b0:	f003 f8f2 	bl	8018498 <rt_thread_self>
 80152b4:	6078      	str	r0, [r7, #4]

    -- thread->remaining_tick;
 80152b6:	687b      	ldr	r3, [r7, #4]
 80152b8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80152ba:	1e5a      	subs	r2, r3, #1
 80152bc:	687b      	ldr	r3, [r7, #4]
 80152be:	649a      	str	r2, [r3, #72]	; 0x48
    if (thread->remaining_tick == 0)
 80152c0:	687b      	ldr	r3, [r7, #4]
 80152c2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80152c4:	2b00      	cmp	r3, #0
 80152c6:	d105      	bne.n	80152d4 <rt_tick_increase+0x34>
    {
        /* change to initialized tick */
        thread->remaining_tick = thread->init_tick;
 80152c8:	687b      	ldr	r3, [r7, #4]
 80152ca:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80152cc:	687b      	ldr	r3, [r7, #4]
 80152ce:	649a      	str	r2, [r3, #72]	; 0x48

        /* yield */
        rt_thread_yield();
 80152d0:	f003 f98e 	bl	80185f0 <rt_thread_yield>
    }

    /* check timer */
    rt_timer_check();
 80152d4:	f003 fda2 	bl	8018e1c <rt_timer_check>
}
 80152d8:	3708      	adds	r7, #8
 80152da:	46bd      	mov	sp, r7
 80152dc:	bd80      	pop	{r7, pc}
 80152de:	bf00      	nop
 80152e0:	20010a6c 	.word	0x20010a6c

080152e4 <rt_tick_from_millisecond>:
 * @param ms the specified millisecond
 *
 * @return the calculated tick
 */
rt_tick_t rt_tick_from_millisecond(rt_uint32_t ms)
{
 80152e4:	b480      	push	{r7}
 80152e6:	b083      	sub	sp, #12
 80152e8:	af00      	add	r7, sp, #0
 80152ea:	6078      	str	r0, [r7, #4]
    /* return the calculated tick */
    return (RT_TICK_PER_SECOND * ms + 999) / 1000;
 80152ec:	687b      	ldr	r3, [r7, #4]
 80152ee:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 80152f2:	fb02 f303 	mul.w	r3, r2, r3
 80152f6:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
 80152fa:	4a05      	ldr	r2, [pc, #20]	; (8015310 <rt_tick_from_millisecond+0x2c>)
 80152fc:	fba2 2303 	umull	r2, r3, r2, r3
 8015300:	099b      	lsrs	r3, r3, #6
}
 8015302:	4618      	mov	r0, r3
 8015304:	370c      	adds	r7, #12
 8015306:	46bd      	mov	sp, r7
 8015308:	f85d 7b04 	ldr.w	r7, [sp], #4
 801530c:	4770      	bx	lr
 801530e:	bf00      	nop
 8015310:	10624dd3 	.word	0x10624dd3

08015314 <rti_start>:
 * ...
 * INIT_APP_EXPORT(fn);
 * etc. 
 */
static int rti_start(void)
{
 8015314:	b480      	push	{r7}
 8015316:	af00      	add	r7, sp, #0
    return 0;
 8015318:	2300      	movs	r3, #0
}
 801531a:	4618      	mov	r0, r3
 801531c:	46bd      	mov	sp, r7
 801531e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015322:	4770      	bx	lr

08015324 <rti_board_end>:
INIT_EXPORT(rti_start, "0");

static int rti_board_end(void)
{
 8015324:	b480      	push	{r7}
 8015326:	af00      	add	r7, sp, #0
    return 0;
 8015328:	2300      	movs	r3, #0
}
 801532a:	4618      	mov	r0, r3
 801532c:	46bd      	mov	sp, r7
 801532e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015332:	4770      	bx	lr

08015334 <rti_end>:
INIT_EXPORT(rti_board_end, "1.end");

static int rti_end(void)
{
 8015334:	b480      	push	{r7}
 8015336:	af00      	add	r7, sp, #0
	return 0;
 8015338:	2300      	movs	r3, #0
}
 801533a:	4618      	mov	r0, r3
 801533c:	46bd      	mov	sp, r7
 801533e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015342:	4770      	bx	lr

08015344 <rt_components_board_init>:

/**
 * RT-Thread Components Initialization for board
 */
void rt_components_board_init(void)
{
 8015344:	b580      	push	{r7, lr}
 8015346:	b082      	sub	sp, #8
 8015348:	af00      	add	r7, sp, #0
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_start; fn_ptr < &__rt_init_rti_board_end; fn_ptr++)
 801534a:	4b08      	ldr	r3, [pc, #32]	; (801536c <rt_components_board_init+0x28>)
 801534c:	607b      	str	r3, [r7, #4]
 801534e:	e005      	b.n	801535c <rt_components_board_init+0x18>
    {
        (*fn_ptr)();
 8015350:	687b      	ldr	r3, [r7, #4]
 8015352:	681b      	ldr	r3, [r3, #0]
 8015354:	4798      	blx	r3
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_start; fn_ptr < &__rt_init_rti_board_end; fn_ptr++)
 8015356:	687b      	ldr	r3, [r7, #4]
 8015358:	3304      	adds	r3, #4
 801535a:	607b      	str	r3, [r7, #4]
 801535c:	687b      	ldr	r3, [r7, #4]
 801535e:	4a04      	ldr	r2, [pc, #16]	; (8015370 <rt_components_board_init+0x2c>)
 8015360:	4293      	cmp	r3, r2
 8015362:	d3f5      	bcc.n	8015350 <rt_components_board_init+0xc>
    {
        (*fn_ptr)();
    }
#endif
}
 8015364:	3708      	adds	r7, #8
 8015366:	46bd      	mov	sp, r7
 8015368:	bd80      	pop	{r7, pc}
 801536a:	bf00      	nop
 801536c:	0802c0b8 	.word	0x0802c0b8
 8015370:	0802c0c8 	.word	0x0802c0c8

08015374 <rt_components_init>:

/**
 * RT-Thread Components Initialization
 */
void rt_components_init(void)
{
 8015374:	b580      	push	{r7, lr}
 8015376:	b082      	sub	sp, #8
 8015378:	af00      	add	r7, sp, #0
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_board_end; fn_ptr < &__rt_init_rti_end; fn_ptr ++)
 801537a:	4b08      	ldr	r3, [pc, #32]	; (801539c <rt_components_init+0x28>)
 801537c:	607b      	str	r3, [r7, #4]
 801537e:	e005      	b.n	801538c <rt_components_init+0x18>
    {
        (*fn_ptr)();
 8015380:	687b      	ldr	r3, [r7, #4]
 8015382:	681b      	ldr	r3, [r3, #0]
 8015384:	4798      	blx	r3
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_board_end; fn_ptr < &__rt_init_rti_end; fn_ptr ++)
 8015386:	687b      	ldr	r3, [r7, #4]
 8015388:	3304      	adds	r3, #4
 801538a:	607b      	str	r3, [r7, #4]
 801538c:	687b      	ldr	r3, [r7, #4]
 801538e:	4a04      	ldr	r2, [pc, #16]	; (80153a0 <rt_components_init+0x2c>)
 8015390:	4293      	cmp	r3, r2
 8015392:	d3f5      	bcc.n	8015380 <rt_components_init+0xc>
			}
		}
	}
#endif

}
 8015394:	3708      	adds	r7, #8
 8015396:	46bd      	mov	sp, r7
 8015398:	bd80      	pop	{r7, pc}
 801539a:	bf00      	nop
 801539c:	0802c0c8 	.word	0x0802c0c8
 80153a0:	0802c0ec 	.word	0x0802c0ec

080153a4 <rt_device_register>:
 * @return the error code, RT_EOK on initialization successfully.
 */
rt_err_t rt_device_register(rt_device_t dev,
                            const char *name,
                            rt_uint16_t flags)
{
 80153a4:	b580      	push	{r7, lr}
 80153a6:	b084      	sub	sp, #16
 80153a8:	af00      	add	r7, sp, #0
 80153aa:	60f8      	str	r0, [r7, #12]
 80153ac:	60b9      	str	r1, [r7, #8]
 80153ae:	4613      	mov	r3, r2
 80153b0:	80fb      	strh	r3, [r7, #6]
    if (dev == RT_NULL)
 80153b2:	68fb      	ldr	r3, [r7, #12]
 80153b4:	2b00      	cmp	r3, #0
 80153b6:	d102      	bne.n	80153be <rt_device_register+0x1a>
        return -RT_ERROR;
 80153b8:	f04f 33ff 	mov.w	r3, #4294967295
 80153bc:	e015      	b.n	80153ea <rt_device_register+0x46>

    if (rt_device_find(name) != RT_NULL)
 80153be:	68b8      	ldr	r0, [r7, #8]
 80153c0:	f000 f818 	bl	80153f4 <rt_device_find>
 80153c4:	4603      	mov	r3, r0
 80153c6:	2b00      	cmp	r3, #0
 80153c8:	d002      	beq.n	80153d0 <rt_device_register+0x2c>
        return -RT_ERROR;
 80153ca:	f04f 33ff 	mov.w	r3, #4294967295
 80153ce:	e00c      	b.n	80153ea <rt_device_register+0x46>

    rt_object_init(&(dev->parent), RT_Object_Class_Device, name);
 80153d0:	68fb      	ldr	r3, [r7, #12]
 80153d2:	4618      	mov	r0, r3
 80153d4:	2108      	movs	r1, #8
 80153d6:	68ba      	ldr	r2, [r7, #8]
 80153d8:	f002 fc2e 	bl	8017c38 <rt_object_init>
    dev->flag = flags;
 80153dc:	68fb      	ldr	r3, [r7, #12]
 80153de:	88fa      	ldrh	r2, [r7, #6]
 80153e0:	82da      	strh	r2, [r3, #22]
    dev->ref_count = 0;
 80153e2:	68fb      	ldr	r3, [r7, #12]
 80153e4:	2200      	movs	r2, #0
 80153e6:	769a      	strb	r2, [r3, #26]

    return RT_EOK;
 80153e8:	2300      	movs	r3, #0
}
 80153ea:	4618      	mov	r0, r3
 80153ec:	3710      	adds	r7, #16
 80153ee:	46bd      	mov	sp, r7
 80153f0:	bd80      	pop	{r7, pc}
 80153f2:	bf00      	nop

080153f4 <rt_device_find>:
 * @param name the device driver's name
 *
 * @return the registered device driver on successful, or RT_NULL on failure.
 */
rt_device_t rt_device_find(const char *name)
{
 80153f4:	b580      	push	{r7, lr}
 80153f6:	b086      	sub	sp, #24
 80153f8:	af00      	add	r7, sp, #0
 80153fa:	6078      	str	r0, [r7, #4]
    struct rt_object_information *information;

    extern struct rt_object_information rt_object_container[];

    /* enter critical */
    if (rt_thread_self() != RT_NULL)
 80153fc:	f003 f84c 	bl	8018498 <rt_thread_self>
 8015400:	4603      	mov	r3, r0
 8015402:	2b00      	cmp	r3, #0
 8015404:	d001      	beq.n	801540a <rt_device_find+0x16>
        rt_enter_critical();
 8015406:	f002 fed7 	bl	80181b8 <rt_enter_critical>

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
 801540a:	4b17      	ldr	r3, [pc, #92]	; (8015468 <rt_device_find+0x74>)
 801540c:	613b      	str	r3, [r7, #16]
    for (node  = information->object_list.next;
 801540e:	693b      	ldr	r3, [r7, #16]
 8015410:	685b      	ldr	r3, [r3, #4]
 8015412:	617b      	str	r3, [r7, #20]
 8015414:	e017      	b.n	8015446 <rt_device_find+0x52>
         node != &(information->object_list);
         node  = node->next)
    {
        object = rt_list_entry(node, struct rt_object, list);
 8015416:	697b      	ldr	r3, [r7, #20]
 8015418:	3b0c      	subs	r3, #12
 801541a:	60fb      	str	r3, [r7, #12]
        if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
 801541c:	68fb      	ldr	r3, [r7, #12]
 801541e:	4618      	mov	r0, r3
 8015420:	6879      	ldr	r1, [r7, #4]
 8015422:	2208      	movs	r2, #8
 8015424:	f001 f9f6 	bl	8016814 <rt_strncmp>
 8015428:	4603      	mov	r3, r0
 801542a:	2b00      	cmp	r3, #0
 801542c:	d108      	bne.n	8015440 <rt_device_find+0x4c>
        {
            /* leave critical */
            if (rt_thread_self() != RT_NULL)
 801542e:	f003 f833 	bl	8018498 <rt_thread_self>
 8015432:	4603      	mov	r3, r0
 8015434:	2b00      	cmp	r3, #0
 8015436:	d001      	beq.n	801543c <rt_device_find+0x48>
                rt_exit_critical();
 8015438:	f002 fed2 	bl	80181e0 <rt_exit_critical>

            return (rt_device_t)object;
 801543c:	68fb      	ldr	r3, [r7, #12]
 801543e:	e00f      	b.n	8015460 <rt_device_find+0x6c>

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
    for (node  = information->object_list.next;
         node != &(information->object_list);
         node  = node->next)
 8015440:	697b      	ldr	r3, [r7, #20]
 8015442:	681b      	ldr	r3, [r3, #0]
 8015444:	617b      	str	r3, [r7, #20]
        rt_enter_critical();

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
    for (node  = information->object_list.next;
         node != &(information->object_list);
 8015446:	693b      	ldr	r3, [r7, #16]
 8015448:	1d1a      	adds	r2, r3, #4
    if (rt_thread_self() != RT_NULL)
        rt_enter_critical();

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
    for (node  = information->object_list.next;
 801544a:	697b      	ldr	r3, [r7, #20]
 801544c:	429a      	cmp	r2, r3
 801544e:	d1e2      	bne.n	8015416 <rt_device_find+0x22>
            return (rt_device_t)object;
        }
    }

    /* leave critical */
    if (rt_thread_self() != RT_NULL)
 8015450:	f003 f822 	bl	8018498 <rt_thread_self>
 8015454:	4603      	mov	r3, r0
 8015456:	2b00      	cmp	r3, #0
 8015458:	d001      	beq.n	801545e <rt_device_find+0x6a>
        rt_exit_critical();
 801545a:	f002 fec1 	bl	80181e0 <rt_exit_critical>

    /* not found */
    return RT_NULL;
 801545e:	2300      	movs	r3, #0
}
 8015460:	4618      	mov	r0, r3
 8015462:	3718      	adds	r7, #24
 8015464:	46bd      	mov	sp, r7
 8015466:	bd80      	pop	{r7, pc}
 8015468:	2001009c 	.word	0x2001009c

0801546c <rt_device_open>:
 * @param oflag the flags for device open
 *
 * @return the result
 */
rt_err_t rt_device_open(rt_device_t dev, rt_uint16_t oflag)
{
 801546c:	b580      	push	{r7, lr}
 801546e:	b084      	sub	sp, #16
 8015470:	af00      	add	r7, sp, #0
 8015472:	6078      	str	r0, [r7, #4]
 8015474:	460b      	mov	r3, r1
 8015476:	807b      	strh	r3, [r7, #2]
    rt_err_t result = RT_EOK;
 8015478:	2300      	movs	r3, #0
 801547a:	60fb      	str	r3, [r7, #12]

    RT_ASSERT(dev != RT_NULL);
 801547c:	687b      	ldr	r3, [r7, #4]
 801547e:	2b00      	cmp	r3, #0
 8015480:	d104      	bne.n	801548c <rt_device_open+0x20>
 8015482:	4830      	ldr	r0, [pc, #192]	; (8015544 <rt_device_open+0xd8>)
 8015484:	4930      	ldr	r1, [pc, #192]	; (8015548 <rt_device_open+0xdc>)
 8015486:	22b6      	movs	r2, #182	; 0xb6
 8015488:	f001 febc 	bl	8017204 <rt_assert_handler>

    /* if device is not initialized, initialize it. */
    if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
 801548c:	687b      	ldr	r3, [r7, #4]
 801548e:	8adb      	ldrh	r3, [r3, #22]
 8015490:	f003 0310 	and.w	r3, r3, #16
 8015494:	2b00      	cmp	r3, #0
 8015496:	d11a      	bne.n	80154ce <rt_device_open+0x62>
    {
        if (dev->init != RT_NULL)
 8015498:	687b      	ldr	r3, [r7, #4]
 801549a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801549c:	2b00      	cmp	r3, #0
 801549e:	d00f      	beq.n	80154c0 <rt_device_open+0x54>
        {
            result = dev->init(dev);
 80154a0:	687b      	ldr	r3, [r7, #4]
 80154a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80154a4:	6878      	ldr	r0, [r7, #4]
 80154a6:	4798      	blx	r3
 80154a8:	60f8      	str	r0, [r7, #12]
            if (result != RT_EOK)
 80154aa:	68fb      	ldr	r3, [r7, #12]
 80154ac:	2b00      	cmp	r3, #0
 80154ae:	d007      	beq.n	80154c0 <rt_device_open+0x54>
            {
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
                           dev->parent.name, result);
 80154b0:	687b      	ldr	r3, [r7, #4]
        if (dev->init != RT_NULL)
        {
            result = dev->init(dev);
            if (result != RT_EOK)
            {
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
 80154b2:	4826      	ldr	r0, [pc, #152]	; (801554c <rt_device_open+0xe0>)
 80154b4:	4619      	mov	r1, r3
 80154b6:	68fa      	ldr	r2, [r7, #12]
 80154b8:	f001 fe2a 	bl	8017110 <rt_kprintf>
                           dev->parent.name, result);

                return result;
 80154bc:	68fb      	ldr	r3, [r7, #12]
 80154be:	e03d      	b.n	801553c <rt_device_open+0xd0>
            }
        }

        dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
 80154c0:	687b      	ldr	r3, [r7, #4]
 80154c2:	8adb      	ldrh	r3, [r3, #22]
 80154c4:	f043 0310 	orr.w	r3, r3, #16
 80154c8:	b29a      	uxth	r2, r3
 80154ca:	687b      	ldr	r3, [r7, #4]
 80154cc:	82da      	strh	r2, [r3, #22]
    }

    /* device is a stand alone device and opened */
    if ((dev->flag & RT_DEVICE_FLAG_STANDALONE) &&
 80154ce:	687b      	ldr	r3, [r7, #4]
 80154d0:	8adb      	ldrh	r3, [r3, #22]
 80154d2:	f003 0308 	and.w	r3, r3, #8
 80154d6:	2b00      	cmp	r3, #0
 80154d8:	d008      	beq.n	80154ec <rt_device_open+0x80>
        (dev->open_flag & RT_DEVICE_OFLAG_OPEN))
 80154da:	687b      	ldr	r3, [r7, #4]
 80154dc:	8b1b      	ldrh	r3, [r3, #24]
 80154de:	f003 0308 	and.w	r3, r3, #8

        dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
    }

    /* device is a stand alone device and opened */
    if ((dev->flag & RT_DEVICE_FLAG_STANDALONE) &&
 80154e2:	2b00      	cmp	r3, #0
 80154e4:	d002      	beq.n	80154ec <rt_device_open+0x80>
        (dev->open_flag & RT_DEVICE_OFLAG_OPEN))
    {
        return -RT_EBUSY;
 80154e6:	f06f 0306 	mvn.w	r3, #6
 80154ea:	e027      	b.n	801553c <rt_device_open+0xd0>
    }

    /* call device open interface */
    if (dev->open != RT_NULL)
 80154ec:	687b      	ldr	r3, [r7, #4]
 80154ee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80154f0:	2b00      	cmp	r3, #0
 80154f2:	d006      	beq.n	8015502 <rt_device_open+0x96>
    {
        result = dev->open(dev, oflag);
 80154f4:	687b      	ldr	r3, [r7, #4]
 80154f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80154f8:	887a      	ldrh	r2, [r7, #2]
 80154fa:	6878      	ldr	r0, [r7, #4]
 80154fc:	4611      	mov	r1, r2
 80154fe:	4798      	blx	r3
 8015500:	60f8      	str	r0, [r7, #12]
    }

    /* set open flag */
    if (result == RT_EOK || result == -RT_ENOSYS)
 8015502:	68fb      	ldr	r3, [r7, #12]
 8015504:	2b00      	cmp	r3, #0
 8015506:	d003      	beq.n	8015510 <rt_device_open+0xa4>
 8015508:	68fb      	ldr	r3, [r7, #12]
 801550a:	f113 0f06 	cmn.w	r3, #6
 801550e:	d114      	bne.n	801553a <rt_device_open+0xce>
    {
        dev->open_flag = oflag | RT_DEVICE_OFLAG_OPEN;
 8015510:	887b      	ldrh	r3, [r7, #2]
 8015512:	f043 0308 	orr.w	r3, r3, #8
 8015516:	b29a      	uxth	r2, r3
 8015518:	687b      	ldr	r3, [r7, #4]
 801551a:	831a      	strh	r2, [r3, #24]

        dev->ref_count++;
 801551c:	687b      	ldr	r3, [r7, #4]
 801551e:	7e9b      	ldrb	r3, [r3, #26]
 8015520:	3301      	adds	r3, #1
 8015522:	b2da      	uxtb	r2, r3
 8015524:	687b      	ldr	r3, [r7, #4]
 8015526:	769a      	strb	r2, [r3, #26]
        /* don't let bad things happen silently. If you are bitten by this assert,
         * please set the ref_count to a bigger type. */
        RT_ASSERT(dev->ref_count != 0);
 8015528:	687b      	ldr	r3, [r7, #4]
 801552a:	7e9b      	ldrb	r3, [r3, #26]
 801552c:	2b00      	cmp	r3, #0
 801552e:	d104      	bne.n	801553a <rt_device_open+0xce>
 8015530:	4807      	ldr	r0, [pc, #28]	; (8015550 <rt_device_open+0xe4>)
 8015532:	4905      	ldr	r1, [pc, #20]	; (8015548 <rt_device_open+0xdc>)
 8015534:	22df      	movs	r2, #223	; 0xdf
 8015536:	f001 fe65 	bl	8017204 <rt_assert_handler>
    }

    return result;
 801553a:	68fb      	ldr	r3, [r7, #12]
}
 801553c:	4618      	mov	r0, r3
 801553e:	3710      	adds	r7, #16
 8015540:	46bd      	mov	sp, r7
 8015542:	bd80      	pop	{r7, pc}
 8015544:	08028d74 	.word	0x08028d74
 8015548:	0802a694 	.word	0x0802a694
 801554c:	08028d84 	.word	0x08028d84
 8015550:	08028dbc 	.word	0x08028dbc

08015554 <rt_device_close>:
 * @param dev the pointer of device driver structure
 *
 * @return the result
 */
rt_err_t rt_device_close(rt_device_t dev)
{
 8015554:	b580      	push	{r7, lr}
 8015556:	b084      	sub	sp, #16
 8015558:	af00      	add	r7, sp, #0
 801555a:	6078      	str	r0, [r7, #4]
    rt_err_t result = RT_EOK;
 801555c:	2300      	movs	r3, #0
 801555e:	60fb      	str	r3, [r7, #12]

    RT_ASSERT(dev != RT_NULL);
 8015560:	687b      	ldr	r3, [r7, #4]
 8015562:	2b00      	cmp	r3, #0
 8015564:	d104      	bne.n	8015570 <rt_device_close+0x1c>
 8015566:	4818      	ldr	r0, [pc, #96]	; (80155c8 <rt_device_close+0x74>)
 8015568:	4918      	ldr	r1, [pc, #96]	; (80155cc <rt_device_close+0x78>)
 801556a:	22f1      	movs	r2, #241	; 0xf1
 801556c:	f001 fe4a 	bl	8017204 <rt_assert_handler>

    if (dev->ref_count == 0)
 8015570:	687b      	ldr	r3, [r7, #4]
 8015572:	7e9b      	ldrb	r3, [r3, #26]
 8015574:	2b00      	cmp	r3, #0
 8015576:	d102      	bne.n	801557e <rt_device_close+0x2a>
        return -RT_ERROR;
 8015578:	f04f 33ff 	mov.w	r3, #4294967295
 801557c:	e01f      	b.n	80155be <rt_device_close+0x6a>

    dev->ref_count--;
 801557e:	687b      	ldr	r3, [r7, #4]
 8015580:	7e9b      	ldrb	r3, [r3, #26]
 8015582:	3b01      	subs	r3, #1
 8015584:	b2da      	uxtb	r2, r3
 8015586:	687b      	ldr	r3, [r7, #4]
 8015588:	769a      	strb	r2, [r3, #26]

    if (dev->ref_count != 0)
 801558a:	687b      	ldr	r3, [r7, #4]
 801558c:	7e9b      	ldrb	r3, [r3, #26]
 801558e:	2b00      	cmp	r3, #0
 8015590:	d001      	beq.n	8015596 <rt_device_close+0x42>
        return RT_EOK;
 8015592:	2300      	movs	r3, #0
 8015594:	e013      	b.n	80155be <rt_device_close+0x6a>

    /* call device close interface */
    if (dev->close != RT_NULL)
 8015596:	687b      	ldr	r3, [r7, #4]
 8015598:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801559a:	2b00      	cmp	r3, #0
 801559c:	d004      	beq.n	80155a8 <rt_device_close+0x54>
    {
        result = dev->close(dev);
 801559e:	687b      	ldr	r3, [r7, #4]
 80155a0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80155a2:	6878      	ldr	r0, [r7, #4]
 80155a4:	4798      	blx	r3
 80155a6:	60f8      	str	r0, [r7, #12]
    }

    /* set open flag */
    if (result == RT_EOK || result == -RT_ENOSYS)
 80155a8:	68fb      	ldr	r3, [r7, #12]
 80155aa:	2b00      	cmp	r3, #0
 80155ac:	d003      	beq.n	80155b6 <rt_device_close+0x62>
 80155ae:	68fb      	ldr	r3, [r7, #12]
 80155b0:	f113 0f06 	cmn.w	r3, #6
 80155b4:	d102      	bne.n	80155bc <rt_device_close+0x68>
        dev->open_flag = RT_DEVICE_OFLAG_CLOSE;
 80155b6:	687b      	ldr	r3, [r7, #4]
 80155b8:	2200      	movs	r2, #0
 80155ba:	831a      	strh	r2, [r3, #24]

    return result;
 80155bc:	68fb      	ldr	r3, [r7, #12]
}
 80155be:	4618      	mov	r0, r3
 80155c0:	3710      	adds	r7, #16
 80155c2:	46bd      	mov	sp, r7
 80155c4:	bd80      	pop	{r7, pc}
 80155c6:	bf00      	nop
 80155c8:	08028d74 	.word	0x08028d74
 80155cc:	0802a6a4 	.word	0x0802a6a4

080155d0 <rt_device_read>:
 */
rt_size_t rt_device_read(rt_device_t dev,
                         rt_off_t    pos,
                         void       *buffer,
                         rt_size_t   size)
{
 80155d0:	b590      	push	{r4, r7, lr}
 80155d2:	b085      	sub	sp, #20
 80155d4:	af00      	add	r7, sp, #0
 80155d6:	60f8      	str	r0, [r7, #12]
 80155d8:	60b9      	str	r1, [r7, #8]
 80155da:	607a      	str	r2, [r7, #4]
 80155dc:	603b      	str	r3, [r7, #0]
    RT_ASSERT(dev != RT_NULL);
 80155de:	68fb      	ldr	r3, [r7, #12]
 80155e0:	2b00      	cmp	r3, #0
 80155e2:	d105      	bne.n	80155f0 <rt_device_read+0x20>
 80155e4:	4812      	ldr	r0, [pc, #72]	; (8015630 <rt_device_read+0x60>)
 80155e6:	4913      	ldr	r1, [pc, #76]	; (8015634 <rt_device_read+0x64>)
 80155e8:	f44f 728d 	mov.w	r2, #282	; 0x11a
 80155ec:	f001 fe0a 	bl	8017204 <rt_assert_handler>

    if (dev->ref_count == 0)
 80155f0:	68fb      	ldr	r3, [r7, #12]
 80155f2:	7e9b      	ldrb	r3, [r3, #26]
 80155f4:	2b00      	cmp	r3, #0
 80155f6:	d105      	bne.n	8015604 <rt_device_read+0x34>
    {
        rt_set_errno(-RT_ERROR);
 80155f8:	f04f 30ff 	mov.w	r0, #4294967295
 80155fc:	f000 ffb0 	bl	8016560 <rt_set_errno>
        return 0;
 8015600:	2300      	movs	r3, #0
 8015602:	e011      	b.n	8015628 <rt_device_read+0x58>
    }

    /* call device read interface */
    if (dev->read != RT_NULL)
 8015604:	68fb      	ldr	r3, [r7, #12]
 8015606:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015608:	2b00      	cmp	r3, #0
 801560a:	d008      	beq.n	801561e <rt_device_read+0x4e>
    {
        return dev->read(dev, pos, buffer, size);
 801560c:	68fb      	ldr	r3, [r7, #12]
 801560e:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 8015610:	68f8      	ldr	r0, [r7, #12]
 8015612:	68b9      	ldr	r1, [r7, #8]
 8015614:	687a      	ldr	r2, [r7, #4]
 8015616:	683b      	ldr	r3, [r7, #0]
 8015618:	47a0      	blx	r4
 801561a:	4603      	mov	r3, r0
 801561c:	e004      	b.n	8015628 <rt_device_read+0x58>
    }

    /* set error code */
    rt_set_errno(-RT_ENOSYS);
 801561e:	f06f 0005 	mvn.w	r0, #5
 8015622:	f000 ff9d 	bl	8016560 <rt_set_errno>

    return 0;
 8015626:	2300      	movs	r3, #0
}
 8015628:	4618      	mov	r0, r3
 801562a:	3714      	adds	r7, #20
 801562c:	46bd      	mov	sp, r7
 801562e:	bd90      	pop	{r4, r7, pc}
 8015630:	08028d74 	.word	0x08028d74
 8015634:	0802a6b4 	.word	0x0802a6b4

08015638 <rt_device_write>:
 */
rt_size_t rt_device_write(rt_device_t dev,
                          rt_off_t    pos,
                          const void *buffer,
                          rt_size_t   size)
{
 8015638:	b590      	push	{r4, r7, lr}
 801563a:	b085      	sub	sp, #20
 801563c:	af00      	add	r7, sp, #0
 801563e:	60f8      	str	r0, [r7, #12]
 8015640:	60b9      	str	r1, [r7, #8]
 8015642:	607a      	str	r2, [r7, #4]
 8015644:	603b      	str	r3, [r7, #0]
    RT_ASSERT(dev != RT_NULL);
 8015646:	68fb      	ldr	r3, [r7, #12]
 8015648:	2b00      	cmp	r3, #0
 801564a:	d105      	bne.n	8015658 <rt_device_write+0x20>
 801564c:	4812      	ldr	r0, [pc, #72]	; (8015698 <rt_device_write+0x60>)
 801564e:	4913      	ldr	r1, [pc, #76]	; (801569c <rt_device_write+0x64>)
 8015650:	f44f 72a0 	mov.w	r2, #320	; 0x140
 8015654:	f001 fdd6 	bl	8017204 <rt_assert_handler>

    if (dev->ref_count == 0)
 8015658:	68fb      	ldr	r3, [r7, #12]
 801565a:	7e9b      	ldrb	r3, [r3, #26]
 801565c:	2b00      	cmp	r3, #0
 801565e:	d105      	bne.n	801566c <rt_device_write+0x34>
    {
        rt_set_errno(-RT_ERROR);
 8015660:	f04f 30ff 	mov.w	r0, #4294967295
 8015664:	f000 ff7c 	bl	8016560 <rt_set_errno>
        return 0;
 8015668:	2300      	movs	r3, #0
 801566a:	e011      	b.n	8015690 <rt_device_write+0x58>
    }

    /* call device write interface */
    if (dev->write != RT_NULL)
 801566c:	68fb      	ldr	r3, [r7, #12]
 801566e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015670:	2b00      	cmp	r3, #0
 8015672:	d008      	beq.n	8015686 <rt_device_write+0x4e>
    {
        return dev->write(dev, pos, buffer, size);
 8015674:	68fb      	ldr	r3, [r7, #12]
 8015676:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 8015678:	68f8      	ldr	r0, [r7, #12]
 801567a:	68b9      	ldr	r1, [r7, #8]
 801567c:	687a      	ldr	r2, [r7, #4]
 801567e:	683b      	ldr	r3, [r7, #0]
 8015680:	47a0      	blx	r4
 8015682:	4603      	mov	r3, r0
 8015684:	e004      	b.n	8015690 <rt_device_write+0x58>
    }

    /* set error code */
    rt_set_errno(-RT_ENOSYS);
 8015686:	f06f 0005 	mvn.w	r0, #5
 801568a:	f000 ff69 	bl	8016560 <rt_set_errno>

    return 0;
 801568e:	2300      	movs	r3, #0
}
 8015690:	4618      	mov	r0, r3
 8015692:	3714      	adds	r7, #20
 8015694:	46bd      	mov	sp, r7
 8015696:	bd90      	pop	{r4, r7, pc}
 8015698:	08028d74 	.word	0x08028d74
 801569c:	0802a6c4 	.word	0x0802a6c4

080156a0 <rt_device_control>:
 * @param arg the argument of command
 *
 * @return the result
 */
rt_err_t rt_device_control(rt_device_t dev, rt_uint8_t cmd, void *arg)
{
 80156a0:	b580      	push	{r7, lr}
 80156a2:	b084      	sub	sp, #16
 80156a4:	af00      	add	r7, sp, #0
 80156a6:	60f8      	str	r0, [r7, #12]
 80156a8:	460b      	mov	r3, r1
 80156aa:	607a      	str	r2, [r7, #4]
 80156ac:	72fb      	strb	r3, [r7, #11]
    RT_ASSERT(dev != RT_NULL);
 80156ae:	68fb      	ldr	r3, [r7, #12]
 80156b0:	2b00      	cmp	r3, #0
 80156b2:	d105      	bne.n	80156c0 <rt_device_control+0x20>
 80156b4:	480b      	ldr	r0, [pc, #44]	; (80156e4 <rt_device_control+0x44>)
 80156b6:	490c      	ldr	r1, [pc, #48]	; (80156e8 <rt_device_control+0x48>)
 80156b8:	f44f 72b0 	mov.w	r2, #352	; 0x160
 80156bc:	f001 fda2 	bl	8017204 <rt_assert_handler>

    /* call device write interface */
    if (dev->control != RT_NULL)
 80156c0:	68fb      	ldr	r3, [r7, #12]
 80156c2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80156c4:	2b00      	cmp	r3, #0
 80156c6:	d008      	beq.n	80156da <rt_device_control+0x3a>
    {
        return dev->control(dev, cmd, arg);
 80156c8:	68fb      	ldr	r3, [r7, #12]
 80156ca:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80156cc:	7afa      	ldrb	r2, [r7, #11]
 80156ce:	68f8      	ldr	r0, [r7, #12]
 80156d0:	4611      	mov	r1, r2
 80156d2:	687a      	ldr	r2, [r7, #4]
 80156d4:	4798      	blx	r3
 80156d6:	4603      	mov	r3, r0
 80156d8:	e000      	b.n	80156dc <rt_device_control+0x3c>
    }

    return RT_EOK;
 80156da:	2300      	movs	r3, #0
}
 80156dc:	4618      	mov	r0, r3
 80156de:	3710      	adds	r7, #16
 80156e0:	46bd      	mov	sp, r7
 80156e2:	bd80      	pop	{r7, pc}
 80156e4:	08028d74 	.word	0x08028d74
 80156e8:	0802a6d4 	.word	0x0802a6d4

080156ec <rt_device_set_rx_indicate>:
 * @return RT_EOK
 */
rt_err_t
rt_device_set_rx_indicate(rt_device_t dev,
                          rt_err_t (*rx_ind)(rt_device_t dev, rt_size_t size))
{
 80156ec:	b580      	push	{r7, lr}
 80156ee:	b082      	sub	sp, #8
 80156f0:	af00      	add	r7, sp, #0
 80156f2:	6078      	str	r0, [r7, #4]
 80156f4:	6039      	str	r1, [r7, #0]
    RT_ASSERT(dev != RT_NULL);
 80156f6:	687b      	ldr	r3, [r7, #4]
 80156f8:	2b00      	cmp	r3, #0
 80156fa:	d105      	bne.n	8015708 <rt_device_set_rx_indicate+0x1c>
 80156fc:	4806      	ldr	r0, [pc, #24]	; (8015718 <rt_device_set_rx_indicate+0x2c>)
 80156fe:	4907      	ldr	r1, [pc, #28]	; (801571c <rt_device_set_rx_indicate+0x30>)
 8015700:	f240 1279 	movw	r2, #377	; 0x179
 8015704:	f001 fd7e 	bl	8017204 <rt_assert_handler>

    dev->rx_indicate = rx_ind;
 8015708:	687b      	ldr	r3, [r7, #4]
 801570a:	683a      	ldr	r2, [r7, #0]
 801570c:	61da      	str	r2, [r3, #28]

    return RT_EOK;
 801570e:	2300      	movs	r3, #0
}
 8015710:	4618      	mov	r0, r3
 8015712:	3708      	adds	r7, #8
 8015714:	46bd      	mov	sp, r7
 8015716:	bd80      	pop	{r7, pc}
 8015718:	08028d74 	.word	0x08028d74
 801571c:	0802a6e8 	.word	0x0802a6e8

08015720 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 8015720:	b480      	push	{r7}
 8015722:	b083      	sub	sp, #12
 8015724:	af00      	add	r7, sp, #0
 8015726:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 8015728:	687b      	ldr	r3, [r7, #4]
 801572a:	681b      	ldr	r3, [r3, #0]
 801572c:	687a      	ldr	r2, [r7, #4]
 801572e:	6852      	ldr	r2, [r2, #4]
 8015730:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 8015732:	687b      	ldr	r3, [r7, #4]
 8015734:	685b      	ldr	r3, [r3, #4]
 8015736:	687a      	ldr	r2, [r7, #4]
 8015738:	6812      	ldr	r2, [r2, #0]
 801573a:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 801573c:	687b      	ldr	r3, [r7, #4]
 801573e:	687a      	ldr	r2, [r7, #4]
 8015740:	605a      	str	r2, [r3, #4]
 8015742:	687b      	ldr	r3, [r7, #4]
 8015744:	685a      	ldr	r2, [r3, #4]
 8015746:	687b      	ldr	r3, [r7, #4]
 8015748:	601a      	str	r2, [r3, #0]
}
 801574a:	370c      	adds	r7, #12
 801574c:	46bd      	mov	sp, r7
 801574e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015752:	4770      	bx	lr

08015754 <_has_defunct_thread>:
}
#endif

/* Return whether there is defunctional thread to be deleted. */
rt_inline int _has_defunct_thread(void)
{
 8015754:	b480      	push	{r7}
 8015756:	b083      	sub	sp, #12
 8015758:	af00      	add	r7, sp, #0
     * So the compiler has a good reason that the rt_thread_defunct list does
     * not change within rt_thread_idle_excute thus optimize the "while" loop
     * into a "if".
     *
     * So add the volatile qualifier here. */
    const volatile rt_list_t *l = (const volatile rt_list_t*)&rt_thread_defunct;
 801575a:	4b08      	ldr	r3, [pc, #32]	; (801577c <_has_defunct_thread+0x28>)
 801575c:	607b      	str	r3, [r7, #4]

    return l->next != l;
 801575e:	687b      	ldr	r3, [r7, #4]
 8015760:	681a      	ldr	r2, [r3, #0]
 8015762:	687b      	ldr	r3, [r7, #4]
 8015764:	429a      	cmp	r2, r3
 8015766:	bf14      	ite	ne
 8015768:	2301      	movne	r3, #1
 801576a:	2300      	moveq	r3, #0
 801576c:	b2db      	uxtb	r3, r3
}
 801576e:	4618      	mov	r0, r3
 8015770:	370c      	adds	r7, #12
 8015772:	46bd      	mov	sp, r7
 8015774:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015778:	4770      	bx	lr
 801577a:	bf00      	nop
 801577c:	20012b7c 	.word	0x20012b7c

08015780 <rt_thread_idle_excute>:
 * @ingroup Thread
 *
 * This function will perform system background job when system idle.
 */
void rt_thread_idle_excute(void)
{
 8015780:	b580      	push	{r7, lr}
 8015782:	b084      	sub	sp, #16
 8015784:	af00      	add	r7, sp, #0
    /* Loop until there is no dead thread. So one call to rt_thread_idle_excute
     * will do all the cleanups. */
    while (_has_defunct_thread())
 8015786:	e045      	b.n	8015814 <rt_thread_idle_excute+0x94>
        rt_base_t lock;
        rt_thread_t thread;
#ifdef RT_USING_MODULE
        rt_module_t module = RT_NULL;
#endif
        RT_DEBUG_NOT_IN_INTERRUPT;
 8015788:	f7ea fd20 	bl	80001cc <rt_hw_interrupt_disable>
 801578c:	60f8      	str	r0, [r7, #12]
 801578e:	f000 fedb 	bl	8016548 <rt_interrupt_get_nest>
 8015792:	4603      	mov	r3, r0
 8015794:	2b00      	cmp	r3, #0
 8015796:	d008      	beq.n	80157aa <rt_thread_idle_excute+0x2a>
 8015798:	4822      	ldr	r0, [pc, #136]	; (8015824 <rt_thread_idle_excute+0xa4>)
 801579a:	4923      	ldr	r1, [pc, #140]	; (8015828 <rt_thread_idle_excute+0xa8>)
 801579c:	f001 fcb8 	bl	8017110 <rt_kprintf>
 80157a0:	4822      	ldr	r0, [pc, #136]	; (801582c <rt_thread_idle_excute+0xac>)
 80157a2:	4921      	ldr	r1, [pc, #132]	; (8015828 <rt_thread_idle_excute+0xa8>)
 80157a4:	225e      	movs	r2, #94	; 0x5e
 80157a6:	f001 fd2d 	bl	8017204 <rt_assert_handler>
 80157aa:	68f8      	ldr	r0, [r7, #12]
 80157ac:	f7ea fd12 	bl	80001d4 <rt_hw_interrupt_enable>

        /* disable interrupt */
        lock = rt_hw_interrupt_disable();
 80157b0:	f7ea fd0c 	bl	80001cc <rt_hw_interrupt_disable>
 80157b4:	60b8      	str	r0, [r7, #8]

        /* re-check whether list is empty */
        if (_has_defunct_thread())
 80157b6:	f7ff ffcd 	bl	8015754 <_has_defunct_thread>
 80157ba:	4603      	mov	r3, r0
 80157bc:	2b00      	cmp	r3, #0
 80157be:	d01a      	beq.n	80157f6 <rt_thread_idle_excute+0x76>
        {
            /* get defunct thread */
            thread = rt_list_entry(rt_thread_defunct.next,
 80157c0:	4b1b      	ldr	r3, [pc, #108]	; (8015830 <rt_thread_idle_excute+0xb0>)
 80157c2:	681b      	ldr	r3, [r3, #0]
 80157c4:	3b14      	subs	r3, #20
 80157c6:	607b      	str	r3, [r7, #4]
                /* detach module's main thread */
                module->module_thread = RT_NULL;
            }
#endif
            /* remove defunct thread */
            rt_list_remove(&(thread->tlist));
 80157c8:	687b      	ldr	r3, [r7, #4]
 80157ca:	3314      	adds	r3, #20
 80157cc:	4618      	mov	r0, r3
 80157ce:	f7ff ffa7 	bl	8015720 <rt_list_remove>
            /* invoke thread cleanup */
            if (thread->cleanup != RT_NULL)
 80157d2:	687b      	ldr	r3, [r7, #4]
 80157d4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80157d6:	2b00      	cmp	r3, #0
 80157d8:	d003      	beq.n	80157e2 <rt_thread_idle_excute+0x62>
                thread->cleanup(thread);
 80157da:	687b      	ldr	r3, [r7, #4]
 80157dc:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80157de:	6878      	ldr	r0, [r7, #4]
 80157e0:	4798      	blx	r3

            /* if it's a system object, not delete it */
            if (rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE)
 80157e2:	6878      	ldr	r0, [r7, #4]
 80157e4:	f002 fb1c 	bl	8017e20 <rt_object_is_systemobject>
 80157e8:	4603      	mov	r3, r0
 80157ea:	2b01      	cmp	r3, #1
 80157ec:	d107      	bne.n	80157fe <rt_thread_idle_excute+0x7e>
            {
                /* enable interrupt */
                rt_hw_interrupt_enable(lock);
 80157ee:	68b8      	ldr	r0, [r7, #8]
 80157f0:	f7ea fcf0 	bl	80001d4 <rt_hw_interrupt_enable>

                return;
 80157f4:	e013      	b.n	801581e <rt_thread_idle_excute+0x9e>
            }
        }
        else
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(lock);
 80157f6:	68b8      	ldr	r0, [r7, #8]
 80157f8:	f7ea fcec 	bl	80001d4 <rt_hw_interrupt_enable>

            /* may the defunct thread list is removed by others, just return */
            return;
 80157fc:	e00f      	b.n	801581e <rt_thread_idle_excute+0x9e>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(lock);
 80157fe:	68b8      	ldr	r0, [r7, #8]
 8015800:	f7ea fce8 	bl	80001d4 <rt_hw_interrupt_enable>
        if (thread->flags & RT_OBJECT_FLAG_MODULE)
            rt_module_free((rt_module_t)thread->module_id, thread->stack_addr);
        else
#endif
        /* release thread's stack */
        RT_KERNEL_FREE(thread->stack_addr);
 8015804:	687b      	ldr	r3, [r7, #4]
 8015806:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015808:	4618      	mov	r0, r3
 801580a:	f002 f873 	bl	80178f4 <rt_free>
        /* delete thread object */
        rt_object_delete((rt_object_t)thread);
 801580e:	6878      	ldr	r0, [r7, #4]
 8015810:	f002 facc 	bl	8017dac <rt_object_delete>
 */
void rt_thread_idle_excute(void)
{
    /* Loop until there is no dead thread. So one call to rt_thread_idle_excute
     * will do all the cleanups. */
    while (_has_defunct_thread())
 8015814:	f7ff ff9e 	bl	8015754 <_has_defunct_thread>
 8015818:	4603      	mov	r3, r0
 801581a:	2b00      	cmp	r3, #0
 801581c:	d1b4      	bne.n	8015788 <rt_thread_idle_excute+0x8>
            if (module->nref == 0)
                rt_module_destroy(module);
        }
#endif
    }
}
 801581e:	3710      	adds	r7, #16
 8015820:	46bd      	mov	sp, r7
 8015822:	bd80      	pop	{r7, pc}
 8015824:	08028dd0 	.word	0x08028dd0
 8015828:	0802a704 	.word	0x0802a704
 801582c:	08028df4 	.word	0x08028df4
 8015830:	20012b7c 	.word	0x20012b7c

08015834 <rt_thread_idle_entry>:

static void rt_thread_idle_entry(void *parameter)
{
 8015834:	b580      	push	{r7, lr}
 8015836:	b082      	sub	sp, #8
 8015838:	af00      	add	r7, sp, #0
 801583a:	6078      	str	r0, [r7, #4]
    while (1)
    {
        #ifdef RT_USING_HOOK
        if (rt_thread_idle_hook != RT_NULL)
 801583c:	4b04      	ldr	r3, [pc, #16]	; (8015850 <rt_thread_idle_entry+0x1c>)
 801583e:	681b      	ldr	r3, [r3, #0]
 8015840:	2b00      	cmp	r3, #0
 8015842:	d002      	beq.n	801584a <rt_thread_idle_entry+0x16>
            rt_thread_idle_hook();
 8015844:	4b02      	ldr	r3, [pc, #8]	; (8015850 <rt_thread_idle_entry+0x1c>)
 8015846:	681b      	ldr	r3, [r3, #0]
 8015848:	4798      	blx	r3
        #endif

        rt_thread_idle_excute();
 801584a:	f7ff ff99 	bl	8015780 <rt_thread_idle_excute>
    }
 801584e:	e7f5      	b.n	801583c <rt_thread_idle_entry+0x8>
 8015850:	20010cf0 	.word	0x20010cf0

08015854 <rt_thread_idle_init>:
 * This function will initialize idle thread, then start it.
 *
 * @note this function must be invoked when system init.
 */
void rt_thread_idle_init(void)
{
 8015854:	b580      	push	{r7, lr}
 8015856:	b084      	sub	sp, #16
 8015858:	af04      	add	r7, sp, #16
    /* initialize thread */
    rt_thread_init(&idle,
 801585a:	4b0a      	ldr	r3, [pc, #40]	; (8015884 <rt_thread_idle_init+0x30>)
 801585c:	9300      	str	r3, [sp, #0]
 801585e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8015862:	9301      	str	r3, [sp, #4]
 8015864:	231f      	movs	r3, #31
 8015866:	9302      	str	r3, [sp, #8]
 8015868:	2320      	movs	r3, #32
 801586a:	9303      	str	r3, [sp, #12]
 801586c:	4806      	ldr	r0, [pc, #24]	; (8015888 <rt_thread_idle_init+0x34>)
 801586e:	4907      	ldr	r1, [pc, #28]	; (801588c <rt_thread_idle_init+0x38>)
 8015870:	4a07      	ldr	r2, [pc, #28]	; (8015890 <rt_thread_idle_init+0x3c>)
 8015872:	2300      	movs	r3, #0
 8015874:	f002 fdda 	bl	801842c <rt_thread_init>
                   sizeof(rt_thread_stack),
                   RT_THREAD_PRIORITY_MAX - 1,
                   32);

    /* startup */
    rt_thread_startup(&idle);
 8015878:	4803      	ldr	r0, [pc, #12]	; (8015888 <rt_thread_idle_init+0x34>)
 801587a:	f002 fe19 	bl	80184b0 <rt_thread_startup>
}
 801587e:	46bd      	mov	sp, r7
 8015880:	bd80      	pop	{r7, pc}
 8015882:	bf00      	nop
 8015884:	20010af0 	.word	0x20010af0
 8015888:	20010a70 	.word	0x20010a70
 801588c:	08028df8 	.word	0x08028df8
 8015890:	08015835 	.word	0x08015835

08015894 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 8015894:	b480      	push	{r7}
 8015896:	b083      	sub	sp, #12
 8015898:	af00      	add	r7, sp, #0
 801589a:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 801589c:	687b      	ldr	r3, [r7, #4]
 801589e:	687a      	ldr	r2, [r7, #4]
 80158a0:	605a      	str	r2, [r3, #4]
 80158a2:	687b      	ldr	r3, [r7, #4]
 80158a4:	685a      	ldr	r2, [r3, #4]
 80158a6:	687b      	ldr	r3, [r7, #4]
 80158a8:	601a      	str	r2, [r3, #0]
}
 80158aa:	370c      	adds	r7, #12
 80158ac:	46bd      	mov	sp, r7
 80158ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80158b2:	4770      	bx	lr

080158b4 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 80158b4:	b480      	push	{r7}
 80158b6:	b083      	sub	sp, #12
 80158b8:	af00      	add	r7, sp, #0
 80158ba:	6078      	str	r0, [r7, #4]
 80158bc:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 80158be:	687b      	ldr	r3, [r7, #4]
 80158c0:	685b      	ldr	r3, [r3, #4]
 80158c2:	683a      	ldr	r2, [r7, #0]
 80158c4:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 80158c6:	687b      	ldr	r3, [r7, #4]
 80158c8:	685a      	ldr	r2, [r3, #4]
 80158ca:	683b      	ldr	r3, [r7, #0]
 80158cc:	605a      	str	r2, [r3, #4]

    l->prev = n;
 80158ce:	687b      	ldr	r3, [r7, #4]
 80158d0:	683a      	ldr	r2, [r7, #0]
 80158d2:	605a      	str	r2, [r3, #4]
    n->next = l;
 80158d4:	683b      	ldr	r3, [r7, #0]
 80158d6:	687a      	ldr	r2, [r7, #4]
 80158d8:	601a      	str	r2, [r3, #0]
}
 80158da:	370c      	adds	r7, #12
 80158dc:	46bd      	mov	sp, r7
 80158de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80158e2:	4770      	bx	lr

080158e4 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 80158e4:	b480      	push	{r7}
 80158e6:	b083      	sub	sp, #12
 80158e8:	af00      	add	r7, sp, #0
 80158ea:	6078      	str	r0, [r7, #4]
    return l->next == l;
 80158ec:	687b      	ldr	r3, [r7, #4]
 80158ee:	681a      	ldr	r2, [r3, #0]
 80158f0:	687b      	ldr	r3, [r7, #4]
 80158f2:	429a      	cmp	r2, r3
 80158f4:	bf0c      	ite	eq
 80158f6:	2301      	moveq	r3, #1
 80158f8:	2300      	movne	r3, #0
 80158fa:	b2db      	uxtb	r3, r3
}
 80158fc:	4618      	mov	r0, r3
 80158fe:	370c      	adds	r7, #12
 8015900:	46bd      	mov	sp, r7
 8015902:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015906:	4770      	bx	lr

08015908 <rt_ipc_object_init>:
 * @param ipc the IPC object
 *
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_object_init(struct rt_ipc_object *ipc)
{
 8015908:	b580      	push	{r7, lr}
 801590a:	b082      	sub	sp, #8
 801590c:	af00      	add	r7, sp, #0
 801590e:	6078      	str	r0, [r7, #4]
    /* init ipc object */
    rt_list_init(&(ipc->suspend_thread));
 8015910:	687b      	ldr	r3, [r7, #4]
 8015912:	3314      	adds	r3, #20
 8015914:	4618      	mov	r0, r3
 8015916:	f7ff ffbd 	bl	8015894 <rt_list_init>

    return RT_EOK;
 801591a:	2300      	movs	r3, #0
}
 801591c:	4618      	mov	r0, r3
 801591e:	3708      	adds	r7, #8
 8015920:	46bd      	mov	sp, r7
 8015922:	bd80      	pop	{r7, pc}

08015924 <rt_ipc_list_suspend>:
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_list_suspend(rt_list_t        *list,
                                       struct rt_thread *thread,
                                       rt_uint8_t        flag)
{
 8015924:	b580      	push	{r7, lr}
 8015926:	b086      	sub	sp, #24
 8015928:	af00      	add	r7, sp, #0
 801592a:	60f8      	str	r0, [r7, #12]
 801592c:	60b9      	str	r1, [r7, #8]
 801592e:	4613      	mov	r3, r2
 8015930:	71fb      	strb	r3, [r7, #7]
    /* suspend thread */
    rt_thread_suspend(thread);
 8015932:	68b8      	ldr	r0, [r7, #8]
 8015934:	f002 ff36 	bl	80187a4 <rt_thread_suspend>

    switch (flag)
 8015938:	79fb      	ldrb	r3, [r7, #7]
 801593a:	2b00      	cmp	r3, #0
 801593c:	d002      	beq.n	8015944 <rt_ipc_list_suspend+0x20>
 801593e:	2b01      	cmp	r3, #1
 8015940:	d007      	beq.n	8015952 <rt_ipc_list_suspend+0x2e>
 8015942:	e032      	b.n	80159aa <rt_ipc_list_suspend+0x86>
    {
    case RT_IPC_FLAG_FIFO:
        rt_list_insert_before(list, &(thread->tlist));
 8015944:	68bb      	ldr	r3, [r7, #8]
 8015946:	3314      	adds	r3, #20
 8015948:	68f8      	ldr	r0, [r7, #12]
 801594a:	4619      	mov	r1, r3
 801594c:	f7ff ffb2 	bl	80158b4 <rt_list_insert_before>
        break;
 8015950:	e02b      	b.n	80159aa <rt_ipc_list_suspend+0x86>
        {
            struct rt_list_node *n;
            struct rt_thread *sthread;

            /* find a suitable position */
            for (n = list->next; n != list; n = n->next)
 8015952:	68fb      	ldr	r3, [r7, #12]
 8015954:	681b      	ldr	r3, [r3, #0]
 8015956:	617b      	str	r3, [r7, #20]
 8015958:	e017      	b.n	801598a <rt_ipc_list_suspend+0x66>
            {
                sthread = rt_list_entry(n, struct rt_thread, tlist);
 801595a:	697b      	ldr	r3, [r7, #20]
 801595c:	3b14      	subs	r3, #20
 801595e:	613b      	str	r3, [r7, #16]

                /* find out */
                if (thread->current_priority < sthread->current_priority)
 8015960:	68bb      	ldr	r3, [r7, #8]
 8015962:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
 8015966:	693b      	ldr	r3, [r7, #16]
 8015968:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 801596c:	429a      	cmp	r2, r3
 801596e:	d209      	bcs.n	8015984 <rt_ipc_list_suspend+0x60>
                {
                    /* insert this thread before the sthread */
                    rt_list_insert_before(&(sthread->tlist), &(thread->tlist));
 8015970:	693b      	ldr	r3, [r7, #16]
 8015972:	f103 0214 	add.w	r2, r3, #20
 8015976:	68bb      	ldr	r3, [r7, #8]
 8015978:	3314      	adds	r3, #20
 801597a:	4610      	mov	r0, r2
 801597c:	4619      	mov	r1, r3
 801597e:	f7ff ff99 	bl	80158b4 <rt_list_insert_before>
                    break;
 8015982:	e006      	b.n	8015992 <rt_ipc_list_suspend+0x6e>
        {
            struct rt_list_node *n;
            struct rt_thread *sthread;

            /* find a suitable position */
            for (n = list->next; n != list; n = n->next)
 8015984:	697b      	ldr	r3, [r7, #20]
 8015986:	681b      	ldr	r3, [r3, #0]
 8015988:	617b      	str	r3, [r7, #20]
 801598a:	697a      	ldr	r2, [r7, #20]
 801598c:	68fb      	ldr	r3, [r7, #12]
 801598e:	429a      	cmp	r2, r3
 8015990:	d1e3      	bne.n	801595a <rt_ipc_list_suspend+0x36>

            /*
             * not found a suitable position,
             * append to the end of suspend_thread list
             */
            if (n == list)
 8015992:	697a      	ldr	r2, [r7, #20]
 8015994:	68fb      	ldr	r3, [r7, #12]
 8015996:	429a      	cmp	r2, r3
 8015998:	d106      	bne.n	80159a8 <rt_ipc_list_suspend+0x84>
                rt_list_insert_before(list, &(thread->tlist));
 801599a:	68bb      	ldr	r3, [r7, #8]
 801599c:	3314      	adds	r3, #20
 801599e:	68f8      	ldr	r0, [r7, #12]
 80159a0:	4619      	mov	r1, r3
 80159a2:	f7ff ff87 	bl	80158b4 <rt_list_insert_before>
        }
        break;
 80159a6:	e7ff      	b.n	80159a8 <rt_ipc_list_suspend+0x84>
 80159a8:	bf00      	nop
    }

    return RT_EOK;
 80159aa:	2300      	movs	r3, #0
}
 80159ac:	4618      	mov	r0, r3
 80159ae:	3718      	adds	r7, #24
 80159b0:	46bd      	mov	sp, r7
 80159b2:	bd80      	pop	{r7, pc}

080159b4 <rt_ipc_list_resume>:
 * @param list the thread list
 *
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_list_resume(rt_list_t *list)
{
 80159b4:	b580      	push	{r7, lr}
 80159b6:	b084      	sub	sp, #16
 80159b8:	af00      	add	r7, sp, #0
 80159ba:	6078      	str	r0, [r7, #4]
    struct rt_thread *thread;

    /* get thread entry */
    thread = rt_list_entry(list->next, struct rt_thread, tlist);
 80159bc:	687b      	ldr	r3, [r7, #4]
 80159be:	681b      	ldr	r3, [r3, #0]
 80159c0:	3b14      	subs	r3, #20
 80159c2:	60fb      	str	r3, [r7, #12]

    RT_DEBUG_LOG(RT_DEBUG_IPC, ("resume thread:%s\n", thread->name));

    /* resume it */
    rt_thread_resume(thread);
 80159c4:	68f8      	ldr	r0, [r7, #12]
 80159c6:	f002 ff1d 	bl	8018804 <rt_thread_resume>

    return RT_EOK;
 80159ca:	2300      	movs	r3, #0
}
 80159cc:	4618      	mov	r0, r3
 80159ce:	3710      	adds	r7, #16
 80159d0:	46bd      	mov	sp, r7
 80159d2:	bd80      	pop	{r7, pc}

080159d4 <rt_ipc_list_resume_all>:
 * @param list of the threads to resume
 *
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_list_resume_all(rt_list_t *list)
{
 80159d4:	b590      	push	{r4, r7, lr}
 80159d6:	b085      	sub	sp, #20
 80159d8:	af00      	add	r7, sp, #0
 80159da:	6078      	str	r0, [r7, #4]
    struct rt_thread *thread;
    register rt_ubase_t temp;

    /* wakeup all suspend threads */
    while (!rt_list_isempty(list))
 80159dc:	e012      	b.n	8015a04 <rt_ipc_list_resume_all+0x30>
    {
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
 80159de:	f7ea fbf5 	bl	80001cc <rt_hw_interrupt_disable>
 80159e2:	4603      	mov	r3, r0
 80159e4:	461c      	mov	r4, r3

        /* get next suspend thread */
        thread = rt_list_entry(list->next, struct rt_thread, tlist);
 80159e6:	687b      	ldr	r3, [r7, #4]
 80159e8:	681b      	ldr	r3, [r3, #0]
 80159ea:	3b14      	subs	r3, #20
 80159ec:	60fb      	str	r3, [r7, #12]
        /* set error code to RT_ERROR */
        thread->error = -RT_ERROR;
 80159ee:	68fb      	ldr	r3, [r7, #12]
 80159f0:	f04f 32ff 	mov.w	r2, #4294967295
 80159f4:	631a      	str	r2, [r3, #48]	; 0x30
        /*
         * resume thread
         * In rt_thread_resume function, it will remove current thread from
         * suspend list
         */
        rt_thread_resume(thread);
 80159f6:	68f8      	ldr	r0, [r7, #12]
 80159f8:	f002 ff04 	bl	8018804 <rt_thread_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 80159fc:	4623      	mov	r3, r4
 80159fe:	4618      	mov	r0, r3
 8015a00:	f7ea fbe8 	bl	80001d4 <rt_hw_interrupt_enable>
{
    struct rt_thread *thread;
    register rt_ubase_t temp;

    /* wakeup all suspend threads */
    while (!rt_list_isempty(list))
 8015a04:	6878      	ldr	r0, [r7, #4]
 8015a06:	f7ff ff6d 	bl	80158e4 <rt_list_isempty>
 8015a0a:	4603      	mov	r3, r0
 8015a0c:	2b00      	cmp	r3, #0
 8015a0e:	d0e6      	beq.n	80159de <rt_ipc_list_resume_all+0xa>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    }

    return RT_EOK;
 8015a10:	2300      	movs	r3, #0
}
 8015a12:	4618      	mov	r0, r3
 8015a14:	3714      	adds	r7, #20
 8015a16:	46bd      	mov	sp, r7
 8015a18:	bd90      	pop	{r4, r7, pc}
 8015a1a:	bf00      	nop

08015a1c <rt_sem_init>:
 */
rt_err_t rt_sem_init(rt_sem_t    sem,
                     const char *name,
                     rt_uint32_t value,
                     rt_uint8_t  flag)
{
 8015a1c:	b580      	push	{r7, lr}
 8015a1e:	b084      	sub	sp, #16
 8015a20:	af00      	add	r7, sp, #0
 8015a22:	60f8      	str	r0, [r7, #12]
 8015a24:	60b9      	str	r1, [r7, #8]
 8015a26:	607a      	str	r2, [r7, #4]
 8015a28:	70fb      	strb	r3, [r7, #3]
    RT_ASSERT(sem != RT_NULL);
 8015a2a:	68fb      	ldr	r3, [r7, #12]
 8015a2c:	2b00      	cmp	r3, #0
 8015a2e:	d104      	bne.n	8015a3a <rt_sem_init+0x1e>
 8015a30:	480d      	ldr	r0, [pc, #52]	; (8015a68 <rt_sem_init+0x4c>)
 8015a32:	490e      	ldr	r1, [pc, #56]	; (8015a6c <rt_sem_init+0x50>)
 8015a34:	22d8      	movs	r2, #216	; 0xd8
 8015a36:	f001 fbe5 	bl	8017204 <rt_assert_handler>

    /* init object */
    rt_object_init(&(sem->parent.parent), RT_Object_Class_Semaphore, name);
 8015a3a:	68fb      	ldr	r3, [r7, #12]
 8015a3c:	4618      	mov	r0, r3
 8015a3e:	2101      	movs	r1, #1
 8015a40:	68ba      	ldr	r2, [r7, #8]
 8015a42:	f002 f8f9 	bl	8017c38 <rt_object_init>

    /* init ipc object */
    rt_ipc_object_init(&(sem->parent));
 8015a46:	68fb      	ldr	r3, [r7, #12]
 8015a48:	4618      	mov	r0, r3
 8015a4a:	f7ff ff5d 	bl	8015908 <rt_ipc_object_init>

    /* set init value */
    sem->value = value;
 8015a4e:	687b      	ldr	r3, [r7, #4]
 8015a50:	b29a      	uxth	r2, r3
 8015a52:	68fb      	ldr	r3, [r7, #12]
 8015a54:	839a      	strh	r2, [r3, #28]

    /* set parent */
    sem->parent.parent.flag = flag;
 8015a56:	68fb      	ldr	r3, [r7, #12]
 8015a58:	78fa      	ldrb	r2, [r7, #3]
 8015a5a:	725a      	strb	r2, [r3, #9]

    return RT_EOK;
 8015a5c:	2300      	movs	r3, #0
}
 8015a5e:	4618      	mov	r0, r3
 8015a60:	3710      	adds	r7, #16
 8015a62:	46bd      	mov	sp, r7
 8015a64:	bd80      	pop	{r7, pc}
 8015a66:	bf00      	nop
 8015a68:	08028e00 	.word	0x08028e00
 8015a6c:	0802a71c 	.word	0x0802a71c

08015a70 <rt_sem_create>:
 * @return the created semaphore, RT_NULL on error happen
 *
 * @see rt_sem_init
 */
rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag)
{
 8015a70:	b580      	push	{r7, lr}
 8015a72:	b086      	sub	sp, #24
 8015a74:	af00      	add	r7, sp, #0
 8015a76:	60f8      	str	r0, [r7, #12]
 8015a78:	60b9      	str	r1, [r7, #8]
 8015a7a:	4613      	mov	r3, r2
 8015a7c:	71fb      	strb	r3, [r7, #7]
    rt_sem_t sem;

    RT_DEBUG_NOT_IN_INTERRUPT;
 8015a7e:	f7ea fba5 	bl	80001cc <rt_hw_interrupt_disable>
 8015a82:	6178      	str	r0, [r7, #20]
 8015a84:	f000 fd60 	bl	8016548 <rt_interrupt_get_nest>
 8015a88:	4603      	mov	r3, r0
 8015a8a:	2b00      	cmp	r3, #0
 8015a8c:	d009      	beq.n	8015aa2 <rt_sem_create+0x32>
 8015a8e:	4813      	ldr	r0, [pc, #76]	; (8015adc <rt_sem_create+0x6c>)
 8015a90:	4913      	ldr	r1, [pc, #76]	; (8015ae0 <rt_sem_create+0x70>)
 8015a92:	f001 fb3d 	bl	8017110 <rt_kprintf>
 8015a96:	4813      	ldr	r0, [pc, #76]	; (8015ae4 <rt_sem_create+0x74>)
 8015a98:	4911      	ldr	r1, [pc, #68]	; (8015ae0 <rt_sem_create+0x70>)
 8015a9a:	f240 1211 	movw	r2, #273	; 0x111
 8015a9e:	f001 fbb1 	bl	8017204 <rt_assert_handler>
 8015aa2:	6978      	ldr	r0, [r7, #20]
 8015aa4:	f7ea fb96 	bl	80001d4 <rt_hw_interrupt_enable>

    /* allocate object */
    sem = (rt_sem_t)rt_object_allocate(RT_Object_Class_Semaphore, name);
 8015aa8:	2001      	movs	r0, #1
 8015aaa:	68f9      	ldr	r1, [r7, #12]
 8015aac:	f002 f922 	bl	8017cf4 <rt_object_allocate>
 8015ab0:	6138      	str	r0, [r7, #16]
    if (sem == RT_NULL)
 8015ab2:	693b      	ldr	r3, [r7, #16]
 8015ab4:	2b00      	cmp	r3, #0
 8015ab6:	d101      	bne.n	8015abc <rt_sem_create+0x4c>
        return sem;
 8015ab8:	693b      	ldr	r3, [r7, #16]
 8015aba:	e00b      	b.n	8015ad4 <rt_sem_create+0x64>

    /* init ipc object */
    rt_ipc_object_init(&(sem->parent));
 8015abc:	693b      	ldr	r3, [r7, #16]
 8015abe:	4618      	mov	r0, r3
 8015ac0:	f7ff ff22 	bl	8015908 <rt_ipc_object_init>

    /* set init value */
    sem->value = value;
 8015ac4:	68bb      	ldr	r3, [r7, #8]
 8015ac6:	b29a      	uxth	r2, r3
 8015ac8:	693b      	ldr	r3, [r7, #16]
 8015aca:	839a      	strh	r2, [r3, #28]

    /* set parent */
    sem->parent.parent.flag = flag;
 8015acc:	693b      	ldr	r3, [r7, #16]
 8015ace:	79fa      	ldrb	r2, [r7, #7]
 8015ad0:	725a      	strb	r2, [r3, #9]

    return sem;
 8015ad2:	693b      	ldr	r3, [r7, #16]
}
 8015ad4:	4618      	mov	r0, r3
 8015ad6:	3718      	adds	r7, #24
 8015ad8:	46bd      	mov	sp, r7
 8015ada:	bd80      	pop	{r7, pc}
 8015adc:	08028e10 	.word	0x08028e10
 8015ae0:	0802a728 	.word	0x0802a728
 8015ae4:	08028e34 	.word	0x08028e34

08015ae8 <rt_sem_take>:
 * @param time the waiting time
 *
 * @return the error code
 */
rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time)
{
 8015ae8:	b590      	push	{r4, r7, lr}
 8015aea:	b087      	sub	sp, #28
 8015aec:	af00      	add	r7, sp, #0
 8015aee:	6078      	str	r0, [r7, #4]
 8015af0:	6039      	str	r1, [r7, #0]
    register rt_base_t temp;
    struct rt_thread *thread;

    RT_ASSERT(sem != RT_NULL);
 8015af2:	687b      	ldr	r3, [r7, #4]
 8015af4:	2b00      	cmp	r3, #0
 8015af6:	d105      	bne.n	8015b04 <rt_sem_take+0x1c>
 8015af8:	4846      	ldr	r0, [pc, #280]	; (8015c14 <rt_sem_take+0x12c>)
 8015afa:	4947      	ldr	r1, [pc, #284]	; (8015c18 <rt_sem_take+0x130>)
 8015afc:	f240 124d 	movw	r2, #333	; 0x14d
 8015b00:	f001 fb80 	bl	8017204 <rt_assert_handler>

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(sem->parent.parent)));
 8015b04:	4b45      	ldr	r3, [pc, #276]	; (8015c1c <rt_sem_take+0x134>)
 8015b06:	681b      	ldr	r3, [r3, #0]
 8015b08:	2b00      	cmp	r3, #0
 8015b0a:	d004      	beq.n	8015b16 <rt_sem_take+0x2e>
 8015b0c:	4b43      	ldr	r3, [pc, #268]	; (8015c1c <rt_sem_take+0x134>)
 8015b0e:	681b      	ldr	r3, [r3, #0]
 8015b10:	687a      	ldr	r2, [r7, #4]
 8015b12:	4610      	mov	r0, r2
 8015b14:	4798      	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8015b16:	f7ea fb59 	bl	80001cc <rt_hw_interrupt_disable>
 8015b1a:	4604      	mov	r4, r0
    RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s take sem:%s, which value is: %d\n",
                                rt_thread_self()->name,
                                ((struct rt_object *)sem)->name,
                                sem->value));

    if (sem->value > 0)
 8015b1c:	687b      	ldr	r3, [r7, #4]
 8015b1e:	8b9b      	ldrh	r3, [r3, #28]
 8015b20:	2b00      	cmp	r3, #0
 8015b22:	d009      	beq.n	8015b38 <rt_sem_take+0x50>
    {
        /* semaphore is available */
        sem->value --;
 8015b24:	687b      	ldr	r3, [r7, #4]
 8015b26:	8b9b      	ldrh	r3, [r3, #28]
 8015b28:	3b01      	subs	r3, #1
 8015b2a:	b29a      	uxth	r2, r3
 8015b2c:	687b      	ldr	r3, [r7, #4]
 8015b2e:	839a      	strh	r2, [r3, #28]

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 8015b30:	4620      	mov	r0, r4
 8015b32:	f7ea fb4f 	bl	80001d4 <rt_hw_interrupt_enable>
 8015b36:	e05f      	b.n	8015bf8 <rt_sem_take+0x110>
    }
    else
    {
        /* no waiting, return with timeout */
        if (time == 0)
 8015b38:	683b      	ldr	r3, [r7, #0]
 8015b3a:	2b00      	cmp	r3, #0
 8015b3c:	d105      	bne.n	8015b4a <rt_sem_take+0x62>
        {
            rt_hw_interrupt_enable(temp);
 8015b3e:	4620      	mov	r0, r4
 8015b40:	f7ea fb48 	bl	80001d4 <rt_hw_interrupt_enable>

            return -RT_ETIMEOUT;
 8015b44:	f06f 0301 	mvn.w	r3, #1
 8015b48:	e060      	b.n	8015c0c <rt_sem_take+0x124>
        }
        else
        {
            /* current context checking */
            RT_DEBUG_IN_THREAD_CONTEXT;
 8015b4a:	f7ea fb3f 	bl	80001cc <rt_hw_interrupt_disable>
 8015b4e:	6178      	str	r0, [r7, #20]
 8015b50:	f002 fca2 	bl	8018498 <rt_thread_self>
 8015b54:	4603      	mov	r3, r0
 8015b56:	2b00      	cmp	r3, #0
 8015b58:	d109      	bne.n	8015b6e <rt_sem_take+0x86>
 8015b5a:	4831      	ldr	r0, [pc, #196]	; (8015c20 <rt_sem_take+0x138>)
 8015b5c:	492e      	ldr	r1, [pc, #184]	; (8015c18 <rt_sem_take+0x130>)
 8015b5e:	f001 fad7 	bl	8017110 <rt_kprintf>
 8015b62:	4830      	ldr	r0, [pc, #192]	; (8015c24 <rt_sem_take+0x13c>)
 8015b64:	492c      	ldr	r1, [pc, #176]	; (8015c18 <rt_sem_take+0x130>)
 8015b66:	f240 126d 	movw	r2, #365	; 0x16d
 8015b6a:	f001 fb4b 	bl	8017204 <rt_assert_handler>
 8015b6e:	f7ea fb2d 	bl	80001cc <rt_hw_interrupt_disable>
 8015b72:	6138      	str	r0, [r7, #16]
 8015b74:	f000 fce8 	bl	8016548 <rt_interrupt_get_nest>
 8015b78:	4603      	mov	r3, r0
 8015b7a:	2b00      	cmp	r3, #0
 8015b7c:	d009      	beq.n	8015b92 <rt_sem_take+0xaa>
 8015b7e:	482a      	ldr	r0, [pc, #168]	; (8015c28 <rt_sem_take+0x140>)
 8015b80:	4925      	ldr	r1, [pc, #148]	; (8015c18 <rt_sem_take+0x130>)
 8015b82:	f001 fac5 	bl	8017110 <rt_kprintf>
 8015b86:	4827      	ldr	r0, [pc, #156]	; (8015c24 <rt_sem_take+0x13c>)
 8015b88:	4923      	ldr	r1, [pc, #140]	; (8015c18 <rt_sem_take+0x130>)
 8015b8a:	f240 126d 	movw	r2, #365	; 0x16d
 8015b8e:	f001 fb39 	bl	8017204 <rt_assert_handler>
 8015b92:	6938      	ldr	r0, [r7, #16]
 8015b94:	f7ea fb1e 	bl	80001d4 <rt_hw_interrupt_enable>
 8015b98:	6978      	ldr	r0, [r7, #20]
 8015b9a:	f7ea fb1b 	bl	80001d4 <rt_hw_interrupt_enable>

            /* semaphore is unavailable, push to suspend list */
            /* get current thread */
            thread = rt_thread_self();
 8015b9e:	f002 fc7b 	bl	8018498 <rt_thread_self>
 8015ba2:	60f8      	str	r0, [r7, #12]

            /* reset thread error number */
            thread->error = RT_EOK;
 8015ba4:	68fb      	ldr	r3, [r7, #12]
 8015ba6:	2200      	movs	r2, #0
 8015ba8:	631a      	str	r2, [r3, #48]	; 0x30

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("sem take: suspend thread - %s\n",
                                        thread->name));

            /* suspend thread */
            rt_ipc_list_suspend(&(sem->parent.suspend_thread),
 8015baa:	687b      	ldr	r3, [r7, #4]
 8015bac:	f103 0214 	add.w	r2, r3, #20
 8015bb0:	687b      	ldr	r3, [r7, #4]
 8015bb2:	7a5b      	ldrb	r3, [r3, #9]
 8015bb4:	4610      	mov	r0, r2
 8015bb6:	68f9      	ldr	r1, [r7, #12]
 8015bb8:	461a      	mov	r2, r3
 8015bba:	f7ff feb3 	bl	8015924 <rt_ipc_list_suspend>
                                thread,
                                sem->parent.parent.flag);

            /* has waiting time, start thread timer */
            if (time > 0)
 8015bbe:	683b      	ldr	r3, [r7, #0]
 8015bc0:	2b00      	cmp	r3, #0
 8015bc2:	dd0d      	ble.n	8015be0 <rt_sem_take+0xf8>
            {
                RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
                                            thread->name));

                /* reset the timeout of thread timer and start it */
                rt_timer_control(&(thread->thread_timer),
 8015bc4:	68fb      	ldr	r3, [r7, #12]
 8015bc6:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 8015bca:	463b      	mov	r3, r7
 8015bcc:	4610      	mov	r0, r2
 8015bce:	2100      	movs	r1, #0
 8015bd0:	461a      	mov	r2, r3
 8015bd2:	f003 f8e1 	bl	8018d98 <rt_timer_control>
                                 RT_TIMER_CTRL_SET_TIME,
                                 &time);
                rt_timer_start(&(thread->thread_timer));
 8015bd6:	68fb      	ldr	r3, [r7, #12]
 8015bd8:	334c      	adds	r3, #76	; 0x4c
 8015bda:	4618      	mov	r0, r3
 8015bdc:	f002 ff96 	bl	8018b0c <rt_timer_start>
            }

            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
 8015be0:	4620      	mov	r0, r4
 8015be2:	f7ea faf7 	bl	80001d4 <rt_hw_interrupt_enable>

            /* do schedule */
            rt_schedule();
 8015be6:	f002 fa1b 	bl	8018020 <rt_schedule>

            if (thread->error != RT_EOK)
 8015bea:	68fb      	ldr	r3, [r7, #12]
 8015bec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015bee:	2b00      	cmp	r3, #0
 8015bf0:	d002      	beq.n	8015bf8 <rt_sem_take+0x110>
            {
                return thread->error;
 8015bf2:	68fb      	ldr	r3, [r7, #12]
 8015bf4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015bf6:	e009      	b.n	8015c0c <rt_sem_take+0x124>
            }
        }
    }

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(sem->parent.parent)));
 8015bf8:	4b0c      	ldr	r3, [pc, #48]	; (8015c2c <rt_sem_take+0x144>)
 8015bfa:	681b      	ldr	r3, [r3, #0]
 8015bfc:	2b00      	cmp	r3, #0
 8015bfe:	d004      	beq.n	8015c0a <rt_sem_take+0x122>
 8015c00:	4b0a      	ldr	r3, [pc, #40]	; (8015c2c <rt_sem_take+0x144>)
 8015c02:	681b      	ldr	r3, [r3, #0]
 8015c04:	687a      	ldr	r2, [r7, #4]
 8015c06:	4610      	mov	r0, r2
 8015c08:	4798      	blx	r3

    return RT_EOK;
 8015c0a:	2300      	movs	r3, #0
}
 8015c0c:	4618      	mov	r0, r3
 8015c0e:	371c      	adds	r7, #28
 8015c10:	46bd      	mov	sp, r7
 8015c12:	bd90      	pop	{r4, r7, pc}
 8015c14:	08028e00 	.word	0x08028e00
 8015c18:	0802a738 	.word	0x0802a738
 8015c1c:	20012a6c 	.word	0x20012a6c
 8015c20:	08028e38 	.word	0x08028e38
 8015c24:	08028e34 	.word	0x08028e34
 8015c28:	08028e10 	.word	0x08028e10
 8015c2c:	20012a68 	.word	0x20012a68

08015c30 <rt_sem_release>:
 * @param sem the semaphore object
 *
 * @return the error code
 */
rt_err_t rt_sem_release(rt_sem_t sem)
{
 8015c30:	b5b0      	push	{r4, r5, r7, lr}
 8015c32:	b082      	sub	sp, #8
 8015c34:	af00      	add	r7, sp, #0
 8015c36:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;
    register rt_bool_t need_schedule;

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(sem->parent.parent)));
 8015c38:	4b16      	ldr	r3, [pc, #88]	; (8015c94 <rt_sem_release+0x64>)
 8015c3a:	681b      	ldr	r3, [r3, #0]
 8015c3c:	2b00      	cmp	r3, #0
 8015c3e:	d004      	beq.n	8015c4a <rt_sem_release+0x1a>
 8015c40:	4b14      	ldr	r3, [pc, #80]	; (8015c94 <rt_sem_release+0x64>)
 8015c42:	681b      	ldr	r3, [r3, #0]
 8015c44:	687a      	ldr	r2, [r7, #4]
 8015c46:	4610      	mov	r0, r2
 8015c48:	4798      	blx	r3

    need_schedule = RT_FALSE;
 8015c4a:	2400      	movs	r4, #0

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8015c4c:	f7ea fabe 	bl	80001cc <rt_hw_interrupt_disable>
 8015c50:	4605      	mov	r5, r0
    RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s releases sem:%s, which value is: %d\n",
                                rt_thread_self()->name,
                                ((struct rt_object *)sem)->name,
                                sem->value));

    if (!rt_list_isempty(&sem->parent.suspend_thread))
 8015c52:	687b      	ldr	r3, [r7, #4]
 8015c54:	3314      	adds	r3, #20
 8015c56:	4618      	mov	r0, r3
 8015c58:	f7ff fe44 	bl	80158e4 <rt_list_isempty>
 8015c5c:	4603      	mov	r3, r0
 8015c5e:	2b00      	cmp	r3, #0
 8015c60:	d106      	bne.n	8015c70 <rt_sem_release+0x40>
    {
        /* resume the suspended thread */
        rt_ipc_list_resume(&(sem->parent.suspend_thread));
 8015c62:	687b      	ldr	r3, [r7, #4]
 8015c64:	3314      	adds	r3, #20
 8015c66:	4618      	mov	r0, r3
 8015c68:	f7ff fea4 	bl	80159b4 <rt_ipc_list_resume>
        need_schedule = RT_TRUE;
 8015c6c:	2401      	movs	r4, #1
 8015c6e:	e005      	b.n	8015c7c <rt_sem_release+0x4c>
    }
    else
        sem->value ++; /* increase value */
 8015c70:	687b      	ldr	r3, [r7, #4]
 8015c72:	8b9b      	ldrh	r3, [r3, #28]
 8015c74:	3301      	adds	r3, #1
 8015c76:	b29a      	uxth	r2, r3
 8015c78:	687b      	ldr	r3, [r7, #4]
 8015c7a:	839a      	strh	r2, [r3, #28]

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8015c7c:	4628      	mov	r0, r5
 8015c7e:	f7ea faa9 	bl	80001d4 <rt_hw_interrupt_enable>

    /* resume a thread, re-schedule */
    if (need_schedule == RT_TRUE)
 8015c82:	2c01      	cmp	r4, #1
 8015c84:	d101      	bne.n	8015c8a <rt_sem_release+0x5a>
        rt_schedule();
 8015c86:	f002 f9cb 	bl	8018020 <rt_schedule>

    return RT_EOK;
 8015c8a:	2300      	movs	r3, #0
}
 8015c8c:	4618      	mov	r0, r3
 8015c8e:	3708      	adds	r7, #8
 8015c90:	46bd      	mov	sp, r7
 8015c92:	bdb0      	pop	{r4, r5, r7, pc}
 8015c94:	20012a64 	.word	0x20012a64

08015c98 <rt_mutex_init>:
 * @param flag the flag of mutex
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag)
{
 8015c98:	b580      	push	{r7, lr}
 8015c9a:	b084      	sub	sp, #16
 8015c9c:	af00      	add	r7, sp, #0
 8015c9e:	60f8      	str	r0, [r7, #12]
 8015ca0:	60b9      	str	r1, [r7, #8]
 8015ca2:	4613      	mov	r3, r2
 8015ca4:	71fb      	strb	r3, [r7, #7]
    RT_ASSERT(mutex != RT_NULL);
 8015ca6:	68fb      	ldr	r3, [r7, #12]
 8015ca8:	2b00      	cmp	r3, #0
 8015caa:	d105      	bne.n	8015cb8 <rt_mutex_init+0x20>
 8015cac:	4811      	ldr	r0, [pc, #68]	; (8015cf4 <rt_mutex_init+0x5c>)
 8015cae:	4912      	ldr	r1, [pc, #72]	; (8015cf8 <rt_mutex_init+0x60>)
 8015cb0:	f240 220f 	movw	r2, #527	; 0x20f
 8015cb4:	f001 faa6 	bl	8017204 <rt_assert_handler>

    /* init object */
    rt_object_init(&(mutex->parent.parent), RT_Object_Class_Mutex, name);
 8015cb8:	68fb      	ldr	r3, [r7, #12]
 8015cba:	4618      	mov	r0, r3
 8015cbc:	2102      	movs	r1, #2
 8015cbe:	68ba      	ldr	r2, [r7, #8]
 8015cc0:	f001 ffba 	bl	8017c38 <rt_object_init>

    /* init ipc object */
    rt_ipc_object_init(&(mutex->parent));
 8015cc4:	68fb      	ldr	r3, [r7, #12]
 8015cc6:	4618      	mov	r0, r3
 8015cc8:	f7ff fe1e 	bl	8015908 <rt_ipc_object_init>

    mutex->value = 1;
 8015ccc:	68fb      	ldr	r3, [r7, #12]
 8015cce:	2201      	movs	r2, #1
 8015cd0:	839a      	strh	r2, [r3, #28]
    mutex->owner = RT_NULL;
 8015cd2:	68fb      	ldr	r3, [r7, #12]
 8015cd4:	2200      	movs	r2, #0
 8015cd6:	621a      	str	r2, [r3, #32]
    mutex->original_priority = 0xFF;
 8015cd8:	68fb      	ldr	r3, [r7, #12]
 8015cda:	22ff      	movs	r2, #255	; 0xff
 8015cdc:	779a      	strb	r2, [r3, #30]
    mutex->hold  = 0;
 8015cde:	68fb      	ldr	r3, [r7, #12]
 8015ce0:	2200      	movs	r2, #0
 8015ce2:	77da      	strb	r2, [r3, #31]

    /* set flag */
    mutex->parent.parent.flag = flag;
 8015ce4:	68fb      	ldr	r3, [r7, #12]
 8015ce6:	79fa      	ldrb	r2, [r7, #7]
 8015ce8:	725a      	strb	r2, [r3, #9]

    return RT_EOK;
 8015cea:	2300      	movs	r3, #0
}
 8015cec:	4618      	mov	r0, r3
 8015cee:	3710      	adds	r7, #16
 8015cf0:	46bd      	mov	sp, r7
 8015cf2:	bd80      	pop	{r7, pc}
 8015cf4:	08028e70 	.word	0x08028e70
 8015cf8:	0802a744 	.word	0x0802a744

08015cfc <rt_mutex_take>:
 * @param time the waiting time
 *
 * @return the error code
 */
rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time)
{
 8015cfc:	b590      	push	{r4, r7, lr}
 8015cfe:	b087      	sub	sp, #28
 8015d00:	af00      	add	r7, sp, #0
 8015d02:	6078      	str	r0, [r7, #4]
 8015d04:	6039      	str	r1, [r7, #0]
    register rt_base_t temp;
    struct rt_thread *thread;

    /* this function must not be used in interrupt even if time = 0 */
    RT_DEBUG_IN_THREAD_CONTEXT;
 8015d06:	f7ea fa61 	bl	80001cc <rt_hw_interrupt_disable>
 8015d0a:	6178      	str	r0, [r7, #20]
 8015d0c:	f002 fbc4 	bl	8018498 <rt_thread_self>
 8015d10:	4603      	mov	r3, r0
 8015d12:	2b00      	cmp	r3, #0
 8015d14:	d109      	bne.n	8015d2a <rt_mutex_take+0x2e>
 8015d16:	485e      	ldr	r0, [pc, #376]	; (8015e90 <rt_mutex_take+0x194>)
 8015d18:	495e      	ldr	r1, [pc, #376]	; (8015e94 <rt_mutex_take+0x198>)
 8015d1a:	f001 f9f9 	bl	8017110 <rt_kprintf>
 8015d1e:	485e      	ldr	r0, [pc, #376]	; (8015e98 <rt_mutex_take+0x19c>)
 8015d20:	495c      	ldr	r1, [pc, #368]	; (8015e94 <rt_mutex_take+0x198>)
 8015d22:	f44f 7222 	mov.w	r2, #648	; 0x288
 8015d26:	f001 fa6d 	bl	8017204 <rt_assert_handler>
 8015d2a:	f7ea fa4f 	bl	80001cc <rt_hw_interrupt_disable>
 8015d2e:	6138      	str	r0, [r7, #16]
 8015d30:	f000 fc0a 	bl	8016548 <rt_interrupt_get_nest>
 8015d34:	4603      	mov	r3, r0
 8015d36:	2b00      	cmp	r3, #0
 8015d38:	d009      	beq.n	8015d4e <rt_mutex_take+0x52>
 8015d3a:	4858      	ldr	r0, [pc, #352]	; (8015e9c <rt_mutex_take+0x1a0>)
 8015d3c:	4955      	ldr	r1, [pc, #340]	; (8015e94 <rt_mutex_take+0x198>)
 8015d3e:	f001 f9e7 	bl	8017110 <rt_kprintf>
 8015d42:	4855      	ldr	r0, [pc, #340]	; (8015e98 <rt_mutex_take+0x19c>)
 8015d44:	4953      	ldr	r1, [pc, #332]	; (8015e94 <rt_mutex_take+0x198>)
 8015d46:	f44f 7222 	mov.w	r2, #648	; 0x288
 8015d4a:	f001 fa5b 	bl	8017204 <rt_assert_handler>
 8015d4e:	6938      	ldr	r0, [r7, #16]
 8015d50:	f7ea fa40 	bl	80001d4 <rt_hw_interrupt_enable>
 8015d54:	6978      	ldr	r0, [r7, #20]
 8015d56:	f7ea fa3d 	bl	80001d4 <rt_hw_interrupt_enable>

    RT_ASSERT(mutex != RT_NULL);
 8015d5a:	687b      	ldr	r3, [r7, #4]
 8015d5c:	2b00      	cmp	r3, #0
 8015d5e:	d105      	bne.n	8015d6c <rt_mutex_take+0x70>
 8015d60:	484f      	ldr	r0, [pc, #316]	; (8015ea0 <rt_mutex_take+0x1a4>)
 8015d62:	494c      	ldr	r1, [pc, #304]	; (8015e94 <rt_mutex_take+0x198>)
 8015d64:	f240 228a 	movw	r2, #650	; 0x28a
 8015d68:	f001 fa4c 	bl	8017204 <rt_assert_handler>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8015d6c:	f7ea fa2e 	bl	80001cc <rt_hw_interrupt_disable>
 8015d70:	4604      	mov	r4, r0

    /* get current thread */
    thread = rt_thread_self();
 8015d72:	f002 fb91 	bl	8018498 <rt_thread_self>
 8015d76:	60f8      	str	r0, [r7, #12]

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mutex->parent.parent)));
 8015d78:	4b4a      	ldr	r3, [pc, #296]	; (8015ea4 <rt_mutex_take+0x1a8>)
 8015d7a:	681b      	ldr	r3, [r3, #0]
 8015d7c:	2b00      	cmp	r3, #0
 8015d7e:	d004      	beq.n	8015d8a <rt_mutex_take+0x8e>
 8015d80:	4b48      	ldr	r3, [pc, #288]	; (8015ea4 <rt_mutex_take+0x1a8>)
 8015d82:	681b      	ldr	r3, [r3, #0]
 8015d84:	687a      	ldr	r2, [r7, #4]
 8015d86:	4610      	mov	r0, r2
 8015d88:	4798      	blx	r3
    RT_DEBUG_LOG(RT_DEBUG_IPC,
                 ("mutex_take: current thread %s, mutex value: %d, hold: %d\n",
                  thread->name, mutex->value, mutex->hold));

    /* reset thread error */
    thread->error = RT_EOK;
 8015d8a:	68fb      	ldr	r3, [r7, #12]
 8015d8c:	2200      	movs	r2, #0
 8015d8e:	631a      	str	r2, [r3, #48]	; 0x30

    if (mutex->owner == thread)
 8015d90:	687b      	ldr	r3, [r7, #4]
 8015d92:	6a1a      	ldr	r2, [r3, #32]
 8015d94:	68fb      	ldr	r3, [r7, #12]
 8015d96:	429a      	cmp	r2, r3
 8015d98:	d106      	bne.n	8015da8 <rt_mutex_take+0xac>
    {
        /* it's the same thread */
        mutex->hold ++;
 8015d9a:	687b      	ldr	r3, [r7, #4]
 8015d9c:	7fdb      	ldrb	r3, [r3, #31]
 8015d9e:	3301      	adds	r3, #1
 8015da0:	b2da      	uxtb	r2, r3
 8015da2:	687b      	ldr	r3, [r7, #4]
 8015da4:	77da      	strb	r2, [r3, #31]
 8015da6:	e061      	b.n	8015e6c <rt_mutex_take+0x170>
    else
    {
        /* The value of mutex is 1 in initial status. Therefore, if the
         * value is great than 0, it indicates the mutex is avaible.
         */
        if (mutex->value > 0)
 8015da8:	687b      	ldr	r3, [r7, #4]
 8015daa:	8b9b      	ldrh	r3, [r3, #28]
 8015dac:	2b00      	cmp	r3, #0
 8015dae:	d014      	beq.n	8015dda <rt_mutex_take+0xde>
        {
            /* mutex is available */
            mutex->value --;
 8015db0:	687b      	ldr	r3, [r7, #4]
 8015db2:	8b9b      	ldrh	r3, [r3, #28]
 8015db4:	3b01      	subs	r3, #1
 8015db6:	b29a      	uxth	r2, r3
 8015db8:	687b      	ldr	r3, [r7, #4]
 8015dba:	839a      	strh	r2, [r3, #28]

            /* set mutex owner and original priority */
            mutex->owner             = thread;
 8015dbc:	687b      	ldr	r3, [r7, #4]
 8015dbe:	68fa      	ldr	r2, [r7, #12]
 8015dc0:	621a      	str	r2, [r3, #32]
            mutex->original_priority = thread->current_priority;
 8015dc2:	68fb      	ldr	r3, [r7, #12]
 8015dc4:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
 8015dc8:	687b      	ldr	r3, [r7, #4]
 8015dca:	779a      	strb	r2, [r3, #30]
            mutex->hold ++;
 8015dcc:	687b      	ldr	r3, [r7, #4]
 8015dce:	7fdb      	ldrb	r3, [r3, #31]
 8015dd0:	3301      	adds	r3, #1
 8015dd2:	b2da      	uxtb	r2, r3
 8015dd4:	687b      	ldr	r3, [r7, #4]
 8015dd6:	77da      	strb	r2, [r3, #31]
 8015dd8:	e048      	b.n	8015e6c <rt_mutex_take+0x170>
        }
        else
        {
            /* no waiting, return with timeout */
            if (time == 0)
 8015dda:	683b      	ldr	r3, [r7, #0]
 8015ddc:	2b00      	cmp	r3, #0
 8015dde:	d109      	bne.n	8015df4 <rt_mutex_take+0xf8>
            {
                /* set error as timeout */
                thread->error = -RT_ETIMEOUT;
 8015de0:	68fb      	ldr	r3, [r7, #12]
 8015de2:	f06f 0201 	mvn.w	r2, #1
 8015de6:	631a      	str	r2, [r3, #48]	; 0x30

                /* enable interrupt */
                rt_hw_interrupt_enable(temp);
 8015de8:	4620      	mov	r0, r4
 8015dea:	f7ea f9f3 	bl	80001d4 <rt_hw_interrupt_enable>

                return -RT_ETIMEOUT;
 8015dee:	f06f 0301 	mvn.w	r3, #1
 8015df2:	e048      	b.n	8015e86 <rt_mutex_take+0x18a>
                /* mutex is unavailable, push to suspend list */
                RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_take: suspend thread: %s\n",
                                            thread->name));

                /* change the owner thread priority of mutex */
                if (thread->current_priority < mutex->owner->current_priority)
 8015df4:	68fb      	ldr	r3, [r7, #12]
 8015df6:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
 8015dfa:	687b      	ldr	r3, [r7, #4]
 8015dfc:	6a1b      	ldr	r3, [r3, #32]
 8015dfe:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8015e02:	429a      	cmp	r2, r3
 8015e04:	d208      	bcs.n	8015e18 <rt_mutex_take+0x11c>
                {
                    /* change the owner thread priority */
                    rt_thread_control(mutex->owner,
 8015e06:	687b      	ldr	r3, [r7, #4]
 8015e08:	6a1a      	ldr	r2, [r3, #32]
                                      RT_THREAD_CTRL_CHANGE_PRIORITY,
                                      &thread->current_priority);
 8015e0a:	68fb      	ldr	r3, [r7, #12]
 8015e0c:	3335      	adds	r3, #53	; 0x35

                /* change the owner thread priority of mutex */
                if (thread->current_priority < mutex->owner->current_priority)
                {
                    /* change the owner thread priority */
                    rt_thread_control(mutex->owner,
 8015e0e:	4610      	mov	r0, r2
 8015e10:	2102      	movs	r1, #2
 8015e12:	461a      	mov	r2, r3
 8015e14:	f002 fc6c 	bl	80186f0 <rt_thread_control>
                                      RT_THREAD_CTRL_CHANGE_PRIORITY,
                                      &thread->current_priority);
                }

                /* suspend current thread */
                rt_ipc_list_suspend(&(mutex->parent.suspend_thread),
 8015e18:	687b      	ldr	r3, [r7, #4]
 8015e1a:	f103 0214 	add.w	r2, r3, #20
 8015e1e:	687b      	ldr	r3, [r7, #4]
 8015e20:	7a5b      	ldrb	r3, [r3, #9]
 8015e22:	4610      	mov	r0, r2
 8015e24:	68f9      	ldr	r1, [r7, #12]
 8015e26:	461a      	mov	r2, r3
 8015e28:	f7ff fd7c 	bl	8015924 <rt_ipc_list_suspend>
                                    thread,
                                    mutex->parent.parent.flag);

                /* has waiting time, start thread timer */
                if (time > 0)
 8015e2c:	683b      	ldr	r3, [r7, #0]
 8015e2e:	2b00      	cmp	r3, #0
 8015e30:	dd0d      	ble.n	8015e4e <rt_mutex_take+0x152>
                    RT_DEBUG_LOG(RT_DEBUG_IPC,
                                 ("mutex_take: start the timer of thread:%s\n",
                                  thread->name));

                    /* reset the timeout of thread timer and start it */
                    rt_timer_control(&(thread->thread_timer),
 8015e32:	68fb      	ldr	r3, [r7, #12]
 8015e34:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 8015e38:	463b      	mov	r3, r7
 8015e3a:	4610      	mov	r0, r2
 8015e3c:	2100      	movs	r1, #0
 8015e3e:	461a      	mov	r2, r3
 8015e40:	f002 ffaa 	bl	8018d98 <rt_timer_control>
                                     RT_TIMER_CTRL_SET_TIME,
                                     &time);
                    rt_timer_start(&(thread->thread_timer));
 8015e44:	68fb      	ldr	r3, [r7, #12]
 8015e46:	334c      	adds	r3, #76	; 0x4c
 8015e48:	4618      	mov	r0, r3
 8015e4a:	f002 fe5f 	bl	8018b0c <rt_timer_start>
                }

                /* enable interrupt */
                rt_hw_interrupt_enable(temp);
 8015e4e:	4620      	mov	r0, r4
 8015e50:	f7ea f9c0 	bl	80001d4 <rt_hw_interrupt_enable>

                /* do schedule */
                rt_schedule();
 8015e54:	f002 f8e4 	bl	8018020 <rt_schedule>

                if (thread->error != RT_EOK)
 8015e58:	68fb      	ldr	r3, [r7, #12]
 8015e5a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015e5c:	2b00      	cmp	r3, #0
 8015e5e:	d002      	beq.n	8015e66 <rt_mutex_take+0x16a>
                {
                    /* return error */
                    return thread->error;
 8015e60:	68fb      	ldr	r3, [r7, #12]
 8015e62:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015e64:	e00f      	b.n	8015e86 <rt_mutex_take+0x18a>
                }
                else
                {
                    /* the mutex is taken successfully. */
                    /* disable interrupt */
                    temp = rt_hw_interrupt_disable();
 8015e66:	f7ea f9b1 	bl	80001cc <rt_hw_interrupt_disable>
 8015e6a:	4604      	mov	r4, r0
            }
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8015e6c:	4620      	mov	r0, r4
 8015e6e:	f7ea f9b1 	bl	80001d4 <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mutex->parent.parent)));
 8015e72:	4b0d      	ldr	r3, [pc, #52]	; (8015ea8 <rt_mutex_take+0x1ac>)
 8015e74:	681b      	ldr	r3, [r3, #0]
 8015e76:	2b00      	cmp	r3, #0
 8015e78:	d004      	beq.n	8015e84 <rt_mutex_take+0x188>
 8015e7a:	4b0b      	ldr	r3, [pc, #44]	; (8015ea8 <rt_mutex_take+0x1ac>)
 8015e7c:	681b      	ldr	r3, [r3, #0]
 8015e7e:	687a      	ldr	r2, [r7, #4]
 8015e80:	4610      	mov	r0, r2
 8015e82:	4798      	blx	r3

    return RT_EOK;
 8015e84:	2300      	movs	r3, #0
}
 8015e86:	4618      	mov	r0, r3
 8015e88:	371c      	adds	r7, #28
 8015e8a:	46bd      	mov	sp, r7
 8015e8c:	bd90      	pop	{r4, r7, pc}
 8015e8e:	bf00      	nop
 8015e90:	08028e38 	.word	0x08028e38
 8015e94:	0802a754 	.word	0x0802a754
 8015e98:	08028e34 	.word	0x08028e34
 8015e9c:	08028e10 	.word	0x08028e10
 8015ea0:	08028e70 	.word	0x08028e70
 8015ea4:	20012a6c 	.word	0x20012a6c
 8015ea8:	20012a68 	.word	0x20012a68

08015eac <rt_mutex_release>:
 * @param mutex the mutex object
 *
 * @return the error code
 */
rt_err_t rt_mutex_release(rt_mutex_t mutex)
{
 8015eac:	b590      	push	{r4, r7, lr}
 8015eae:	b087      	sub	sp, #28
 8015eb0:	af00      	add	r7, sp, #0
 8015eb2:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;
    struct rt_thread *thread;
    rt_bool_t need_schedule;

    need_schedule = RT_FALSE;
 8015eb4:	2300      	movs	r3, #0
 8015eb6:	617b      	str	r3, [r7, #20]

    /* only thread could release mutex because we need test the ownership */
    RT_DEBUG_IN_THREAD_CONTEXT;
 8015eb8:	f7ea f988 	bl	80001cc <rt_hw_interrupt_disable>
 8015ebc:	6138      	str	r0, [r7, #16]
 8015ebe:	f002 faeb 	bl	8018498 <rt_thread_self>
 8015ec2:	4603      	mov	r3, r0
 8015ec4:	2b00      	cmp	r3, #0
 8015ec6:	d109      	bne.n	8015edc <rt_mutex_release+0x30>
 8015ec8:	484a      	ldr	r0, [pc, #296]	; (8015ff4 <rt_mutex_release+0x148>)
 8015eca:	494b      	ldr	r1, [pc, #300]	; (8015ff8 <rt_mutex_release+0x14c>)
 8015ecc:	f001 f920 	bl	8017110 <rt_kprintf>
 8015ed0:	484a      	ldr	r0, [pc, #296]	; (8015ffc <rt_mutex_release+0x150>)
 8015ed2:	4949      	ldr	r1, [pc, #292]	; (8015ff8 <rt_mutex_release+0x14c>)
 8015ed4:	f240 320d 	movw	r2, #781	; 0x30d
 8015ed8:	f001 f994 	bl	8017204 <rt_assert_handler>
 8015edc:	f7ea f976 	bl	80001cc <rt_hw_interrupt_disable>
 8015ee0:	60f8      	str	r0, [r7, #12]
 8015ee2:	f000 fb31 	bl	8016548 <rt_interrupt_get_nest>
 8015ee6:	4603      	mov	r3, r0
 8015ee8:	2b00      	cmp	r3, #0
 8015eea:	d009      	beq.n	8015f00 <rt_mutex_release+0x54>
 8015eec:	4844      	ldr	r0, [pc, #272]	; (8016000 <rt_mutex_release+0x154>)
 8015eee:	4942      	ldr	r1, [pc, #264]	; (8015ff8 <rt_mutex_release+0x14c>)
 8015ef0:	f001 f90e 	bl	8017110 <rt_kprintf>
 8015ef4:	4841      	ldr	r0, [pc, #260]	; (8015ffc <rt_mutex_release+0x150>)
 8015ef6:	4940      	ldr	r1, [pc, #256]	; (8015ff8 <rt_mutex_release+0x14c>)
 8015ef8:	f240 320d 	movw	r2, #781	; 0x30d
 8015efc:	f001 f982 	bl	8017204 <rt_assert_handler>
 8015f00:	68f8      	ldr	r0, [r7, #12]
 8015f02:	f7ea f967 	bl	80001d4 <rt_hw_interrupt_enable>
 8015f06:	6938      	ldr	r0, [r7, #16]
 8015f08:	f7ea f964 	bl	80001d4 <rt_hw_interrupt_enable>

    /* get current thread */
    thread = rt_thread_self();
 8015f0c:	f002 fac4 	bl	8018498 <rt_thread_self>
 8015f10:	60b8      	str	r0, [r7, #8]

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8015f12:	f7ea f95b 	bl	80001cc <rt_hw_interrupt_disable>
 8015f16:	4604      	mov	r4, r0

    RT_DEBUG_LOG(RT_DEBUG_IPC,
                 ("mutex_release:current thread %s, mutex value: %d, hold: %d\n",
                  thread->name, mutex->value, mutex->hold));

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mutex->parent.parent)));
 8015f18:	4b3a      	ldr	r3, [pc, #232]	; (8016004 <rt_mutex_release+0x158>)
 8015f1a:	681b      	ldr	r3, [r3, #0]
 8015f1c:	2b00      	cmp	r3, #0
 8015f1e:	d004      	beq.n	8015f2a <rt_mutex_release+0x7e>
 8015f20:	4b38      	ldr	r3, [pc, #224]	; (8016004 <rt_mutex_release+0x158>)
 8015f22:	681b      	ldr	r3, [r3, #0]
 8015f24:	687a      	ldr	r2, [r7, #4]
 8015f26:	4610      	mov	r0, r2
 8015f28:	4798      	blx	r3

    /* mutex only can be released by owner */
    if (thread != mutex->owner)
 8015f2a:	687b      	ldr	r3, [r7, #4]
 8015f2c:	6a1a      	ldr	r2, [r3, #32]
 8015f2e:	68bb      	ldr	r3, [r7, #8]
 8015f30:	429a      	cmp	r2, r3
 8015f32:	d009      	beq.n	8015f48 <rt_mutex_release+0x9c>
    {
        thread->error = -RT_ERROR;
 8015f34:	68bb      	ldr	r3, [r7, #8]
 8015f36:	f04f 32ff 	mov.w	r2, #4294967295
 8015f3a:	631a      	str	r2, [r3, #48]	; 0x30

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 8015f3c:	4620      	mov	r0, r4
 8015f3e:	f7ea f949 	bl	80001d4 <rt_hw_interrupt_enable>

        return -RT_ERROR;
 8015f42:	f04f 33ff 	mov.w	r3, #4294967295
 8015f46:	e051      	b.n	8015fec <rt_mutex_release+0x140>
    }

    /* decrease hold */
    mutex->hold --;
 8015f48:	687b      	ldr	r3, [r7, #4]
 8015f4a:	7fdb      	ldrb	r3, [r3, #31]
 8015f4c:	3b01      	subs	r3, #1
 8015f4e:	b2da      	uxtb	r2, r3
 8015f50:	687b      	ldr	r3, [r7, #4]
 8015f52:	77da      	strb	r2, [r3, #31]
    /* if no hold */
    if (mutex->hold == 0)
 8015f54:	687b      	ldr	r3, [r7, #4]
 8015f56:	7fdb      	ldrb	r3, [r3, #31]
 8015f58:	2b00      	cmp	r3, #0
 8015f5a:	d13e      	bne.n	8015fda <rt_mutex_release+0x12e>
    {
        /* change the owner thread to original priority */
        if (mutex->original_priority != mutex->owner->current_priority)
 8015f5c:	687b      	ldr	r3, [r7, #4]
 8015f5e:	7f9a      	ldrb	r2, [r3, #30]
 8015f60:	687b      	ldr	r3, [r7, #4]
 8015f62:	6a1b      	ldr	r3, [r3, #32]
 8015f64:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8015f68:	429a      	cmp	r2, r3
 8015f6a:	d008      	beq.n	8015f7e <rt_mutex_release+0xd2>
        {
            rt_thread_control(mutex->owner,
 8015f6c:	687b      	ldr	r3, [r7, #4]
 8015f6e:	6a1a      	ldr	r2, [r3, #32]
                              RT_THREAD_CTRL_CHANGE_PRIORITY,
                              &(mutex->original_priority));
 8015f70:	687b      	ldr	r3, [r7, #4]
 8015f72:	331e      	adds	r3, #30
    if (mutex->hold == 0)
    {
        /* change the owner thread to original priority */
        if (mutex->original_priority != mutex->owner->current_priority)
        {
            rt_thread_control(mutex->owner,
 8015f74:	4610      	mov	r0, r2
 8015f76:	2102      	movs	r1, #2
 8015f78:	461a      	mov	r2, r3
 8015f7a:	f002 fbb9 	bl	80186f0 <rt_thread_control>
                              RT_THREAD_CTRL_CHANGE_PRIORITY,
                              &(mutex->original_priority));
        }

        /* wakeup suspended thread */
        if (!rt_list_isempty(&mutex->parent.suspend_thread))
 8015f7e:	687b      	ldr	r3, [r7, #4]
 8015f80:	3314      	adds	r3, #20
 8015f82:	4618      	mov	r0, r3
 8015f84:	f7ff fcae 	bl	80158e4 <rt_list_isempty>
 8015f88:	4603      	mov	r3, r0
 8015f8a:	2b00      	cmp	r3, #0
 8015f8c:	d119      	bne.n	8015fc2 <rt_mutex_release+0x116>
        {
            /* get suspended thread */
            thread = rt_list_entry(mutex->parent.suspend_thread.next,
 8015f8e:	687b      	ldr	r3, [r7, #4]
 8015f90:	695b      	ldr	r3, [r3, #20]
 8015f92:	3b14      	subs	r3, #20
 8015f94:	60bb      	str	r3, [r7, #8]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_release: resume thread: %s\n",
                                        thread->name));

            /* set new owner and priority */
            mutex->owner             = thread;
 8015f96:	687b      	ldr	r3, [r7, #4]
 8015f98:	68ba      	ldr	r2, [r7, #8]
 8015f9a:	621a      	str	r2, [r3, #32]
            mutex->original_priority = thread->current_priority;
 8015f9c:	68bb      	ldr	r3, [r7, #8]
 8015f9e:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
 8015fa2:	687b      	ldr	r3, [r7, #4]
 8015fa4:	779a      	strb	r2, [r3, #30]
            mutex->hold ++;
 8015fa6:	687b      	ldr	r3, [r7, #4]
 8015fa8:	7fdb      	ldrb	r3, [r3, #31]
 8015faa:	3301      	adds	r3, #1
 8015fac:	b2da      	uxtb	r2, r3
 8015fae:	687b      	ldr	r3, [r7, #4]
 8015fb0:	77da      	strb	r2, [r3, #31]

            /* resume thread */
            rt_ipc_list_resume(&(mutex->parent.suspend_thread));
 8015fb2:	687b      	ldr	r3, [r7, #4]
 8015fb4:	3314      	adds	r3, #20
 8015fb6:	4618      	mov	r0, r3
 8015fb8:	f7ff fcfc 	bl	80159b4 <rt_ipc_list_resume>

            need_schedule = RT_TRUE;
 8015fbc:	2301      	movs	r3, #1
 8015fbe:	617b      	str	r3, [r7, #20]
 8015fc0:	e00b      	b.n	8015fda <rt_mutex_release+0x12e>
        }
        else
        {
            /* increase value */
            mutex->value ++;
 8015fc2:	687b      	ldr	r3, [r7, #4]
 8015fc4:	8b9b      	ldrh	r3, [r3, #28]
 8015fc6:	3301      	adds	r3, #1
 8015fc8:	b29a      	uxth	r2, r3
 8015fca:	687b      	ldr	r3, [r7, #4]
 8015fcc:	839a      	strh	r2, [r3, #28]

            /* clear owner */
            mutex->owner             = RT_NULL;
 8015fce:	687b      	ldr	r3, [r7, #4]
 8015fd0:	2200      	movs	r2, #0
 8015fd2:	621a      	str	r2, [r3, #32]
            mutex->original_priority = 0xff;
 8015fd4:	687b      	ldr	r3, [r7, #4]
 8015fd6:	22ff      	movs	r2, #255	; 0xff
 8015fd8:	779a      	strb	r2, [r3, #30]
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8015fda:	4620      	mov	r0, r4
 8015fdc:	f7ea f8fa 	bl	80001d4 <rt_hw_interrupt_enable>

    /* perform a schedule */
    if (need_schedule == RT_TRUE)
 8015fe0:	697b      	ldr	r3, [r7, #20]
 8015fe2:	2b01      	cmp	r3, #1
 8015fe4:	d101      	bne.n	8015fea <rt_mutex_release+0x13e>
        rt_schedule();
 8015fe6:	f002 f81b 	bl	8018020 <rt_schedule>

    return RT_EOK;
 8015fea:	2300      	movs	r3, #0
}
 8015fec:	4618      	mov	r0, r3
 8015fee:	371c      	adds	r7, #28
 8015ff0:	46bd      	mov	sp, r7
 8015ff2:	bd90      	pop	{r4, r7, pc}
 8015ff4:	08028e38 	.word	0x08028e38
 8015ff8:	0802a764 	.word	0x0802a764
 8015ffc:	08028e34 	.word	0x08028e34
 8016000:	08028e10 	.word	0x08028e10
 8016004:	20012a64 	.word	0x20012a64

08016008 <rt_mq_create>:
 */
rt_mq_t rt_mq_create(const char *name,
                     rt_size_t   msg_size,
                     rt_size_t   max_msgs,
                     rt_uint8_t  flag)
{
 8016008:	b590      	push	{r4, r7, lr}
 801600a:	b089      	sub	sp, #36	; 0x24
 801600c:	af00      	add	r7, sp, #0
 801600e:	60f8      	str	r0, [r7, #12]
 8016010:	60b9      	str	r1, [r7, #8]
 8016012:	607a      	str	r2, [r7, #4]
 8016014:	70fb      	strb	r3, [r7, #3]
    struct rt_messagequeue *mq;
    struct rt_mq_message *head;
    register rt_base_t temp;

    RT_DEBUG_NOT_IN_INTERRUPT;
 8016016:	f7ea f8d9 	bl	80001cc <rt_hw_interrupt_disable>
 801601a:	61f8      	str	r0, [r7, #28]
 801601c:	f000 fa94 	bl	8016548 <rt_interrupt_get_nest>
 8016020:	4603      	mov	r3, r0
 8016022:	2b00      	cmp	r3, #0
 8016024:	d009      	beq.n	801603a <rt_mq_create+0x32>
 8016026:	4835      	ldr	r0, [pc, #212]	; (80160fc <rt_mq_create+0xf4>)
 8016028:	4935      	ldr	r1, [pc, #212]	; (8016100 <rt_mq_create+0xf8>)
 801602a:	f001 f871 	bl	8017110 <rt_kprintf>
 801602e:	4835      	ldr	r0, [pc, #212]	; (8016104 <rt_mq_create+0xfc>)
 8016030:	4933      	ldr	r1, [pc, #204]	; (8016100 <rt_mq_create+0xf8>)
 8016032:	f240 7226 	movw	r2, #1830	; 0x726
 8016036:	f001 f8e5 	bl	8017204 <rt_assert_handler>
 801603a:	69f8      	ldr	r0, [r7, #28]
 801603c:	f7ea f8ca 	bl	80001d4 <rt_hw_interrupt_enable>

    /* allocate object */
    mq = (rt_mq_t)rt_object_allocate(RT_Object_Class_MessageQueue, name);
 8016040:	2005      	movs	r0, #5
 8016042:	68f9      	ldr	r1, [r7, #12]
 8016044:	f001 fe56 	bl	8017cf4 <rt_object_allocate>
 8016048:	61b8      	str	r0, [r7, #24]
    if (mq == RT_NULL)
 801604a:	69bb      	ldr	r3, [r7, #24]
 801604c:	2b00      	cmp	r3, #0
 801604e:	d101      	bne.n	8016054 <rt_mq_create+0x4c>
        return mq;
 8016050:	69bb      	ldr	r3, [r7, #24]
 8016052:	e04e      	b.n	80160f2 <rt_mq_create+0xea>

    /* set parent */
    mq->parent.parent.flag = flag;
 8016054:	69bb      	ldr	r3, [r7, #24]
 8016056:	78fa      	ldrb	r2, [r7, #3]
 8016058:	725a      	strb	r2, [r3, #9]

    /* init ipc object */
    rt_ipc_object_init(&(mq->parent));
 801605a:	69bb      	ldr	r3, [r7, #24]
 801605c:	4618      	mov	r0, r3
 801605e:	f7ff fc53 	bl	8015908 <rt_ipc_object_init>

    /* init message queue */

    /* get correct message size */
    mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
 8016062:	68bb      	ldr	r3, [r7, #8]
 8016064:	b29b      	uxth	r3, r3
 8016066:	3303      	adds	r3, #3
 8016068:	b29b      	uxth	r3, r3
 801606a:	f023 0303 	bic.w	r3, r3, #3
 801606e:	b29a      	uxth	r2, r3
 8016070:	69bb      	ldr	r3, [r7, #24]
 8016072:	841a      	strh	r2, [r3, #32]
    mq->max_msgs = max_msgs;
 8016074:	687b      	ldr	r3, [r7, #4]
 8016076:	b29a      	uxth	r2, r3
 8016078:	69bb      	ldr	r3, [r7, #24]
 801607a:	845a      	strh	r2, [r3, #34]	; 0x22

    /* allocate message pool */
    mq->msg_pool = RT_KERNEL_MALLOC((mq->msg_size + sizeof(struct rt_mq_message))* mq->max_msgs);
 801607c:	69bb      	ldr	r3, [r7, #24]
 801607e:	8c1b      	ldrh	r3, [r3, #32]
 8016080:	3304      	adds	r3, #4
 8016082:	69ba      	ldr	r2, [r7, #24]
 8016084:	8c52      	ldrh	r2, [r2, #34]	; 0x22
 8016086:	fb02 f303 	mul.w	r3, r2, r3
 801608a:	4618      	mov	r0, r3
 801608c:	f001 f9ee 	bl	801746c <rt_malloc>
 8016090:	4602      	mov	r2, r0
 8016092:	69bb      	ldr	r3, [r7, #24]
 8016094:	61da      	str	r2, [r3, #28]
    if (mq->msg_pool == RT_NULL)
 8016096:	69bb      	ldr	r3, [r7, #24]
 8016098:	69db      	ldr	r3, [r3, #28]
 801609a:	2b00      	cmp	r3, #0
 801609c:	d104      	bne.n	80160a8 <rt_mq_create+0xa0>
    {
        rt_mq_delete(mq);
 801609e:	69b8      	ldr	r0, [r7, #24]
 80160a0:	f000 f832 	bl	8016108 <rt_mq_delete>

        return RT_NULL;
 80160a4:	2300      	movs	r3, #0
 80160a6:	e024      	b.n	80160f2 <rt_mq_create+0xea>
    }

    /* init message list */
    mq->msg_queue_head = RT_NULL;
 80160a8:	69bb      	ldr	r3, [r7, #24]
 80160aa:	2200      	movs	r2, #0
 80160ac:	629a      	str	r2, [r3, #40]	; 0x28
    mq->msg_queue_tail = RT_NULL;
 80160ae:	69bb      	ldr	r3, [r7, #24]
 80160b0:	2200      	movs	r2, #0
 80160b2:	62da      	str	r2, [r3, #44]	; 0x2c

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
 80160b4:	69bb      	ldr	r3, [r7, #24]
 80160b6:	2200      	movs	r2, #0
 80160b8:	631a      	str	r2, [r3, #48]	; 0x30
    for (temp = 0; temp < mq->max_msgs; temp ++)
 80160ba:	2400      	movs	r4, #0
 80160bc:	e011      	b.n	80160e2 <rt_mq_create+0xda>
    {
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
 80160be:	69bb      	ldr	r3, [r7, #24]
 80160c0:	69da      	ldr	r2, [r3, #28]
               temp * (mq->msg_size + sizeof(struct rt_mq_message)));
 80160c2:	69bb      	ldr	r3, [r7, #24]
 80160c4:	8c1b      	ldrh	r3, [r3, #32]
 80160c6:	3304      	adds	r3, #4

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
    for (temp = 0; temp < mq->max_msgs; temp ++)
    {
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
 80160c8:	4621      	mov	r1, r4
 80160ca:	fb01 f303 	mul.w	r3, r1, r3
 80160ce:	4413      	add	r3, r2
 80160d0:	617b      	str	r3, [r7, #20]
               temp * (mq->msg_size + sizeof(struct rt_mq_message)));
        head->next = mq->msg_queue_free;
 80160d2:	69bb      	ldr	r3, [r7, #24]
 80160d4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80160d6:	697b      	ldr	r3, [r7, #20]
 80160d8:	601a      	str	r2, [r3, #0]
        mq->msg_queue_free = head;
 80160da:	69bb      	ldr	r3, [r7, #24]
 80160dc:	697a      	ldr	r2, [r7, #20]
 80160de:	631a      	str	r2, [r3, #48]	; 0x30
    mq->msg_queue_head = RT_NULL;
    mq->msg_queue_tail = RT_NULL;

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
    for (temp = 0; temp < mq->max_msgs; temp ++)
 80160e0:	3401      	adds	r4, #1
 80160e2:	69bb      	ldr	r3, [r7, #24]
 80160e4:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 80160e6:	42a3      	cmp	r3, r4
 80160e8:	dce9      	bgt.n	80160be <rt_mq_create+0xb6>
        head->next = mq->msg_queue_free;
        mq->msg_queue_free = head;
    }

    /* the initial entry is zero */
    mq->entry = 0;
 80160ea:	69bb      	ldr	r3, [r7, #24]
 80160ec:	2200      	movs	r2, #0
 80160ee:	849a      	strh	r2, [r3, #36]	; 0x24

    return mq;
 80160f0:	69bb      	ldr	r3, [r7, #24]
}
 80160f2:	4618      	mov	r0, r3
 80160f4:	3724      	adds	r7, #36	; 0x24
 80160f6:	46bd      	mov	sp, r7
 80160f8:	bd90      	pop	{r4, r7, pc}
 80160fa:	bf00      	nop
 80160fc:	08028e10 	.word	0x08028e10
 8016100:	0802a778 	.word	0x0802a778
 8016104:	08028e34 	.word	0x08028e34

08016108 <rt_mq_delete>:
 * @param mq the message queue object
 *
 * @return the error code
 */
rt_err_t rt_mq_delete(rt_mq_t mq)
{
 8016108:	b580      	push	{r7, lr}
 801610a:	b084      	sub	sp, #16
 801610c:	af00      	add	r7, sp, #0
 801610e:	6078      	str	r0, [r7, #4]
    RT_DEBUG_NOT_IN_INTERRUPT;
 8016110:	f7ea f85c 	bl	80001cc <rt_hw_interrupt_disable>
 8016114:	60f8      	str	r0, [r7, #12]
 8016116:	f000 fa17 	bl	8016548 <rt_interrupt_get_nest>
 801611a:	4603      	mov	r3, r0
 801611c:	2b00      	cmp	r3, #0
 801611e:	d009      	beq.n	8016134 <rt_mq_delete+0x2c>
 8016120:	4814      	ldr	r0, [pc, #80]	; (8016174 <rt_mq_delete+0x6c>)
 8016122:	4915      	ldr	r1, [pc, #84]	; (8016178 <rt_mq_delete+0x70>)
 8016124:	f000 fff4 	bl	8017110 <rt_kprintf>
 8016128:	4814      	ldr	r0, [pc, #80]	; (801617c <rt_mq_delete+0x74>)
 801612a:	4913      	ldr	r1, [pc, #76]	; (8016178 <rt_mq_delete+0x70>)
 801612c:	f44f 62ec 	mov.w	r2, #1888	; 0x760
 8016130:	f001 f868 	bl	8017204 <rt_assert_handler>
 8016134:	68f8      	ldr	r0, [r7, #12]
 8016136:	f7ea f84d 	bl	80001d4 <rt_hw_interrupt_enable>

    /* parameter check */
    RT_ASSERT(mq != RT_NULL);
 801613a:	687b      	ldr	r3, [r7, #4]
 801613c:	2b00      	cmp	r3, #0
 801613e:	d105      	bne.n	801614c <rt_mq_delete+0x44>
 8016140:	480f      	ldr	r0, [pc, #60]	; (8016180 <rt_mq_delete+0x78>)
 8016142:	490d      	ldr	r1, [pc, #52]	; (8016178 <rt_mq_delete+0x70>)
 8016144:	f240 7263 	movw	r2, #1891	; 0x763
 8016148:	f001 f85c 	bl	8017204 <rt_assert_handler>

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&(mq->parent.suspend_thread));
 801614c:	687b      	ldr	r3, [r7, #4]
 801614e:	3314      	adds	r3, #20
 8016150:	4618      	mov	r0, r3
 8016152:	f7ff fc3f 	bl	80159d4 <rt_ipc_list_resume_all>
        rt_module_free(mq->parent.parent.module_id, mq->msg_pool);
    else
#endif

    /* free message queue pool */
    RT_KERNEL_FREE(mq->msg_pool);
 8016156:	687b      	ldr	r3, [r7, #4]
 8016158:	69db      	ldr	r3, [r3, #28]
 801615a:	4618      	mov	r0, r3
 801615c:	f001 fbca 	bl	80178f4 <rt_free>

    /* delete message queue object */
    rt_object_delete(&(mq->parent.parent));
 8016160:	687b      	ldr	r3, [r7, #4]
 8016162:	4618      	mov	r0, r3
 8016164:	f001 fe22 	bl	8017dac <rt_object_delete>

    return RT_EOK;
 8016168:	2300      	movs	r3, #0
}
 801616a:	4618      	mov	r0, r3
 801616c:	3710      	adds	r7, #16
 801616e:	46bd      	mov	sp, r7
 8016170:	bd80      	pop	{r7, pc}
 8016172:	bf00      	nop
 8016174:	08028e10 	.word	0x08028e10
 8016178:	0802a788 	.word	0x0802a788
 801617c:	08028e34 	.word	0x08028e34
 8016180:	08028ea8 	.word	0x08028ea8

08016184 <rt_mq_send>:
 * @param size the size of buffer
 *
 * @return the error code
 */
rt_err_t rt_mq_send(rt_mq_t mq, void *buffer, rt_size_t size)
{
 8016184:	b590      	push	{r4, r7, lr}
 8016186:	b087      	sub	sp, #28
 8016188:	af00      	add	r7, sp, #0
 801618a:	60f8      	str	r0, [r7, #12]
 801618c:	60b9      	str	r1, [r7, #8]
 801618e:	607a      	str	r2, [r7, #4]
    register rt_ubase_t temp;
    struct rt_mq_message *msg;

    RT_ASSERT(mq != RT_NULL);
 8016190:	68fb      	ldr	r3, [r7, #12]
 8016192:	2b00      	cmp	r3, #0
 8016194:	d105      	bne.n	80161a2 <rt_mq_send+0x1e>
 8016196:	4843      	ldr	r0, [pc, #268]	; (80162a4 <rt_mq_send+0x120>)
 8016198:	4943      	ldr	r1, [pc, #268]	; (80162a8 <rt_mq_send+0x124>)
 801619a:	f240 7289 	movw	r2, #1929	; 0x789
 801619e:	f001 f831 	bl	8017204 <rt_assert_handler>
    RT_ASSERT(buffer != RT_NULL);
 80161a2:	68bb      	ldr	r3, [r7, #8]
 80161a4:	2b00      	cmp	r3, #0
 80161a6:	d105      	bne.n	80161b4 <rt_mq_send+0x30>
 80161a8:	4840      	ldr	r0, [pc, #256]	; (80162ac <rt_mq_send+0x128>)
 80161aa:	493f      	ldr	r1, [pc, #252]	; (80162a8 <rt_mq_send+0x124>)
 80161ac:	f240 728a 	movw	r2, #1930	; 0x78a
 80161b0:	f001 f828 	bl	8017204 <rt_assert_handler>
    RT_ASSERT(size != 0);
 80161b4:	687b      	ldr	r3, [r7, #4]
 80161b6:	2b00      	cmp	r3, #0
 80161b8:	d105      	bne.n	80161c6 <rt_mq_send+0x42>
 80161ba:	483d      	ldr	r0, [pc, #244]	; (80162b0 <rt_mq_send+0x12c>)
 80161bc:	493a      	ldr	r1, [pc, #232]	; (80162a8 <rt_mq_send+0x124>)
 80161be:	f240 728b 	movw	r2, #1931	; 0x78b
 80161c2:	f001 f81f 	bl	8017204 <rt_assert_handler>

    /* greater than one message size */
    if (size > mq->msg_size)
 80161c6:	68fb      	ldr	r3, [r7, #12]
 80161c8:	8c1b      	ldrh	r3, [r3, #32]
 80161ca:	461a      	mov	r2, r3
 80161cc:	687b      	ldr	r3, [r7, #4]
 80161ce:	429a      	cmp	r2, r3
 80161d0:	d202      	bcs.n	80161d8 <rt_mq_send+0x54>
        return -RT_ERROR;
 80161d2:	f04f 33ff 	mov.w	r3, #4294967295
 80161d6:	e061      	b.n	801629c <rt_mq_send+0x118>

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
 80161d8:	4b36      	ldr	r3, [pc, #216]	; (80162b4 <rt_mq_send+0x130>)
 80161da:	681b      	ldr	r3, [r3, #0]
 80161dc:	2b00      	cmp	r3, #0
 80161de:	d004      	beq.n	80161ea <rt_mq_send+0x66>
 80161e0:	4b34      	ldr	r3, [pc, #208]	; (80162b4 <rt_mq_send+0x130>)
 80161e2:	681b      	ldr	r3, [r3, #0]
 80161e4:	68fa      	ldr	r2, [r7, #12]
 80161e6:	4610      	mov	r0, r2
 80161e8:	4798      	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 80161ea:	f7e9 ffef 	bl	80001cc <rt_hw_interrupt_disable>
 80161ee:	4603      	mov	r3, r0
 80161f0:	461c      	mov	r4, r3

    /* get a free list, there must be an empty item */
    msg = (struct rt_mq_message*)mq->msg_queue_free;
 80161f2:	68fb      	ldr	r3, [r7, #12]
 80161f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80161f6:	617b      	str	r3, [r7, #20]
    /* message queue is full */
    if (msg == RT_NULL)
 80161f8:	697b      	ldr	r3, [r7, #20]
 80161fa:	2b00      	cmp	r3, #0
 80161fc:	d106      	bne.n	801620c <rt_mq_send+0x88>
    {
        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 80161fe:	4623      	mov	r3, r4
 8016200:	4618      	mov	r0, r3
 8016202:	f7e9 ffe7 	bl	80001d4 <rt_hw_interrupt_enable>

        return -RT_EFULL;
 8016206:	f06f 0302 	mvn.w	r3, #2
 801620a:	e047      	b.n	801629c <rt_mq_send+0x118>
    }
    /* move free list pointer */
    mq->msg_queue_free = msg->next;
 801620c:	697b      	ldr	r3, [r7, #20]
 801620e:	681a      	ldr	r2, [r3, #0]
 8016210:	68fb      	ldr	r3, [r7, #12]
 8016212:	631a      	str	r2, [r3, #48]	; 0x30

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8016214:	4623      	mov	r3, r4
 8016216:	4618      	mov	r0, r3
 8016218:	f7e9 ffdc 	bl	80001d4 <rt_hw_interrupt_enable>

    /* the msg is the new tailer of list, the next shall be NULL */
    msg->next = RT_NULL;
 801621c:	697b      	ldr	r3, [r7, #20]
 801621e:	2200      	movs	r2, #0
 8016220:	601a      	str	r2, [r3, #0]
    /* copy buffer */
    rt_memcpy(msg + 1, buffer, size);
 8016222:	697b      	ldr	r3, [r7, #20]
 8016224:	3304      	adds	r3, #4
 8016226:	4618      	mov	r0, r3
 8016228:	68b9      	ldr	r1, [r7, #8]
 801622a:	687a      	ldr	r2, [r7, #4]
 801622c:	f000 fa14 	bl	8016658 <rt_memcpy>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8016230:	f7e9 ffcc 	bl	80001cc <rt_hw_interrupt_disable>
 8016234:	4603      	mov	r3, r0
 8016236:	461c      	mov	r4, r3
    /* link msg to message queue */
    if (mq->msg_queue_tail != RT_NULL)
 8016238:	68fb      	ldr	r3, [r7, #12]
 801623a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801623c:	2b00      	cmp	r3, #0
 801623e:	d003      	beq.n	8016248 <rt_mq_send+0xc4>
    {
        /* if the tail exists, */
        ((struct rt_mq_message *)mq->msg_queue_tail)->next = msg;
 8016240:	68fb      	ldr	r3, [r7, #12]
 8016242:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8016244:	697a      	ldr	r2, [r7, #20]
 8016246:	601a      	str	r2, [r3, #0]
    }

    /* set new tail */
    mq->msg_queue_tail = msg;
 8016248:	68fb      	ldr	r3, [r7, #12]
 801624a:	697a      	ldr	r2, [r7, #20]
 801624c:	62da      	str	r2, [r3, #44]	; 0x2c
    /* if the head is empty, set head */
    if (mq->msg_queue_head == RT_NULL)
 801624e:	68fb      	ldr	r3, [r7, #12]
 8016250:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8016252:	2b00      	cmp	r3, #0
 8016254:	d102      	bne.n	801625c <rt_mq_send+0xd8>
        mq->msg_queue_head = msg;
 8016256:	68fb      	ldr	r3, [r7, #12]
 8016258:	697a      	ldr	r2, [r7, #20]
 801625a:	629a      	str	r2, [r3, #40]	; 0x28

    /* increase message entry */
    mq->entry ++;
 801625c:	68fb      	ldr	r3, [r7, #12]
 801625e:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8016260:	3301      	adds	r3, #1
 8016262:	b29a      	uxth	r2, r3
 8016264:	68fb      	ldr	r3, [r7, #12]
 8016266:	849a      	strh	r2, [r3, #36]	; 0x24

    /* resume suspended thread */
    if (!rt_list_isempty(&mq->parent.suspend_thread))
 8016268:	68fb      	ldr	r3, [r7, #12]
 801626a:	3314      	adds	r3, #20
 801626c:	4618      	mov	r0, r3
 801626e:	f7ff fb39 	bl	80158e4 <rt_list_isempty>
 8016272:	4603      	mov	r3, r0
 8016274:	2b00      	cmp	r3, #0
 8016276:	d10c      	bne.n	8016292 <rt_mq_send+0x10e>
    {
        rt_ipc_list_resume(&(mq->parent.suspend_thread));
 8016278:	68fb      	ldr	r3, [r7, #12]
 801627a:	3314      	adds	r3, #20
 801627c:	4618      	mov	r0, r3
 801627e:	f7ff fb99 	bl	80159b4 <rt_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 8016282:	4623      	mov	r3, r4
 8016284:	4618      	mov	r0, r3
 8016286:	f7e9 ffa5 	bl	80001d4 <rt_hw_interrupt_enable>

        rt_schedule();
 801628a:	f001 fec9 	bl	8018020 <rt_schedule>

        return RT_EOK;
 801628e:	2300      	movs	r3, #0
 8016290:	e004      	b.n	801629c <rt_mq_send+0x118>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8016292:	4623      	mov	r3, r4
 8016294:	4618      	mov	r0, r3
 8016296:	f7e9 ff9d 	bl	80001d4 <rt_hw_interrupt_enable>

    return RT_EOK;
 801629a:	2300      	movs	r3, #0
}
 801629c:	4618      	mov	r0, r3
 801629e:	371c      	adds	r7, #28
 80162a0:	46bd      	mov	sp, r7
 80162a2:	bd90      	pop	{r4, r7, pc}
 80162a4:	08028ea8 	.word	0x08028ea8
 80162a8:	0802a798 	.word	0x0802a798
 80162ac:	08028eb8 	.word	0x08028eb8
 80162b0:	08028ecc 	.word	0x08028ecc
 80162b4:	20012a64 	.word	0x20012a64

080162b8 <rt_mq_recv>:
 */
rt_err_t rt_mq_recv(rt_mq_t    mq,
                    void      *buffer,
                    rt_size_t  size,
                    rt_int32_t timeout)
{
 80162b8:	b590      	push	{r4, r7, lr}
 80162ba:	b08b      	sub	sp, #44	; 0x2c
 80162bc:	af00      	add	r7, sp, #0
 80162be:	60f8      	str	r0, [r7, #12]
 80162c0:	60b9      	str	r1, [r7, #8]
 80162c2:	607a      	str	r2, [r7, #4]
 80162c4:	603b      	str	r3, [r7, #0]
    struct rt_thread *thread;
    register rt_ubase_t temp;
    struct rt_mq_message *msg;
    rt_uint32_t tick_delta;

    RT_ASSERT(mq != RT_NULL);
 80162c6:	68fb      	ldr	r3, [r7, #12]
 80162c8:	2b00      	cmp	r3, #0
 80162ca:	d105      	bne.n	80162d8 <rt_mq_recv+0x20>
 80162cc:	487f      	ldr	r0, [pc, #508]	; (80164cc <rt_mq_recv+0x214>)
 80162ce:	4980      	ldr	r1, [pc, #512]	; (80164d0 <rt_mq_recv+0x218>)
 80162d0:	f640 0239 	movw	r2, #2105	; 0x839
 80162d4:	f000 ff96 	bl	8017204 <rt_assert_handler>
    RT_ASSERT(buffer != RT_NULL);
 80162d8:	68bb      	ldr	r3, [r7, #8]
 80162da:	2b00      	cmp	r3, #0
 80162dc:	d105      	bne.n	80162ea <rt_mq_recv+0x32>
 80162de:	487d      	ldr	r0, [pc, #500]	; (80164d4 <rt_mq_recv+0x21c>)
 80162e0:	497b      	ldr	r1, [pc, #492]	; (80164d0 <rt_mq_recv+0x218>)
 80162e2:	f640 023a 	movw	r2, #2106	; 0x83a
 80162e6:	f000 ff8d 	bl	8017204 <rt_assert_handler>
    RT_ASSERT(size != 0);
 80162ea:	687b      	ldr	r3, [r7, #4]
 80162ec:	2b00      	cmp	r3, #0
 80162ee:	d105      	bne.n	80162fc <rt_mq_recv+0x44>
 80162f0:	4879      	ldr	r0, [pc, #484]	; (80164d8 <rt_mq_recv+0x220>)
 80162f2:	4977      	ldr	r1, [pc, #476]	; (80164d0 <rt_mq_recv+0x218>)
 80162f4:	f640 023b 	movw	r2, #2107	; 0x83b
 80162f8:	f000 ff84 	bl	8017204 <rt_assert_handler>

    /* initialize delta tick */
    tick_delta = 0;
 80162fc:	2300      	movs	r3, #0
 80162fe:	627b      	str	r3, [r7, #36]	; 0x24
    /* get current thread */
    thread = rt_thread_self();
 8016300:	f002 f8ca 	bl	8018498 <rt_thread_self>
 8016304:	6238      	str	r0, [r7, #32]
    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mq->parent.parent)));
 8016306:	4b75      	ldr	r3, [pc, #468]	; (80164dc <rt_mq_recv+0x224>)
 8016308:	681b      	ldr	r3, [r3, #0]
 801630a:	2b00      	cmp	r3, #0
 801630c:	d004      	beq.n	8016318 <rt_mq_recv+0x60>
 801630e:	4b73      	ldr	r3, [pc, #460]	; (80164dc <rt_mq_recv+0x224>)
 8016310:	681b      	ldr	r3, [r3, #0]
 8016312:	68fa      	ldr	r2, [r7, #12]
 8016314:	4610      	mov	r0, r2
 8016316:	4798      	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8016318:	f7e9 ff58 	bl	80001cc <rt_hw_interrupt_disable>
 801631c:	4603      	mov	r3, r0
 801631e:	461c      	mov	r4, r3

    /* for non-blocking call */
    if (mq->entry == 0 && timeout == 0)
 8016320:	68fb      	ldr	r3, [r7, #12]
 8016322:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8016324:	2b00      	cmp	r3, #0
 8016326:	d109      	bne.n	801633c <rt_mq_recv+0x84>
 8016328:	683b      	ldr	r3, [r7, #0]
 801632a:	2b00      	cmp	r3, #0
 801632c:	d106      	bne.n	801633c <rt_mq_recv+0x84>
    {
        rt_hw_interrupt_enable(temp);
 801632e:	4623      	mov	r3, r4
 8016330:	4618      	mov	r0, r3
 8016332:	f7e9 ff4f 	bl	80001d4 <rt_hw_interrupt_enable>

        return -RT_ETIMEOUT;
 8016336:	f06f 0301 	mvn.w	r3, #1
 801633a:	e0c2      	b.n	80164c2 <rt_mq_recv+0x20a>
    }

    /* message queue is empty */
    while (mq->entry == 0)
 801633c:	e07c      	b.n	8016438 <rt_mq_recv+0x180>
    {
        RT_DEBUG_IN_THREAD_CONTEXT;
 801633e:	f7e9 ff45 	bl	80001cc <rt_hw_interrupt_disable>
 8016342:	61f8      	str	r0, [r7, #28]
 8016344:	f002 f8a8 	bl	8018498 <rt_thread_self>
 8016348:	4603      	mov	r3, r0
 801634a:	2b00      	cmp	r3, #0
 801634c:	d109      	bne.n	8016362 <rt_mq_recv+0xaa>
 801634e:	4864      	ldr	r0, [pc, #400]	; (80164e0 <rt_mq_recv+0x228>)
 8016350:	495f      	ldr	r1, [pc, #380]	; (80164d0 <rt_mq_recv+0x218>)
 8016352:	f000 fedd 	bl	8017110 <rt_kprintf>
 8016356:	4863      	ldr	r0, [pc, #396]	; (80164e4 <rt_mq_recv+0x22c>)
 8016358:	495d      	ldr	r1, [pc, #372]	; (80164d0 <rt_mq_recv+0x218>)
 801635a:	f640 0251 	movw	r2, #2129	; 0x851
 801635e:	f000 ff51 	bl	8017204 <rt_assert_handler>
 8016362:	f7e9 ff33 	bl	80001cc <rt_hw_interrupt_disable>
 8016366:	61b8      	str	r0, [r7, #24]
 8016368:	f000 f8ee 	bl	8016548 <rt_interrupt_get_nest>
 801636c:	4603      	mov	r3, r0
 801636e:	2b00      	cmp	r3, #0
 8016370:	d009      	beq.n	8016386 <rt_mq_recv+0xce>
 8016372:	485d      	ldr	r0, [pc, #372]	; (80164e8 <rt_mq_recv+0x230>)
 8016374:	4956      	ldr	r1, [pc, #344]	; (80164d0 <rt_mq_recv+0x218>)
 8016376:	f000 fecb 	bl	8017110 <rt_kprintf>
 801637a:	485a      	ldr	r0, [pc, #360]	; (80164e4 <rt_mq_recv+0x22c>)
 801637c:	4954      	ldr	r1, [pc, #336]	; (80164d0 <rt_mq_recv+0x218>)
 801637e:	f640 0251 	movw	r2, #2129	; 0x851
 8016382:	f000 ff3f 	bl	8017204 <rt_assert_handler>
 8016386:	69b8      	ldr	r0, [r7, #24]
 8016388:	f7e9 ff24 	bl	80001d4 <rt_hw_interrupt_enable>
 801638c:	69f8      	ldr	r0, [r7, #28]
 801638e:	f7e9 ff21 	bl	80001d4 <rt_hw_interrupt_enable>

        /* reset error number in thread */
        thread->error = RT_EOK;
 8016392:	6a3b      	ldr	r3, [r7, #32]
 8016394:	2200      	movs	r2, #0
 8016396:	631a      	str	r2, [r3, #48]	; 0x30

        /* no waiting, return timeout */
        if (timeout == 0)
 8016398:	683b      	ldr	r3, [r7, #0]
 801639a:	2b00      	cmp	r3, #0
 801639c:	d10a      	bne.n	80163b4 <rt_mq_recv+0xfc>
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
 801639e:	4623      	mov	r3, r4
 80163a0:	4618      	mov	r0, r3
 80163a2:	f7e9 ff17 	bl	80001d4 <rt_hw_interrupt_enable>

            thread->error = -RT_ETIMEOUT;
 80163a6:	6a3b      	ldr	r3, [r7, #32]
 80163a8:	f06f 0201 	mvn.w	r2, #1
 80163ac:	631a      	str	r2, [r3, #48]	; 0x30

            return -RT_ETIMEOUT;
 80163ae:	f06f 0301 	mvn.w	r3, #1
 80163b2:	e086      	b.n	80164c2 <rt_mq_recv+0x20a>
        }

        /* suspend current thread */
        rt_ipc_list_suspend(&(mq->parent.suspend_thread),
 80163b4:	68fb      	ldr	r3, [r7, #12]
 80163b6:	f103 0214 	add.w	r2, r3, #20
 80163ba:	68fb      	ldr	r3, [r7, #12]
 80163bc:	7a5b      	ldrb	r3, [r3, #9]
 80163be:	4610      	mov	r0, r2
 80163c0:	6a39      	ldr	r1, [r7, #32]
 80163c2:	461a      	mov	r2, r3
 80163c4:	f7ff faae 	bl	8015924 <rt_ipc_list_suspend>
                            thread,
                            mq->parent.parent.flag);

        /* has waiting time, start thread timer */
        if (timeout > 0)
 80163c8:	683b      	ldr	r3, [r7, #0]
 80163ca:	2b00      	cmp	r3, #0
 80163cc:	dd10      	ble.n	80163f0 <rt_mq_recv+0x138>
        {
            /* get the start tick of timer */
            tick_delta = rt_tick_get();
 80163ce:	f7fe ff5b 	bl	8015288 <rt_tick_get>
 80163d2:	6278      	str	r0, [r7, #36]	; 0x24

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
                                        thread->name));

            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
 80163d4:	6a3b      	ldr	r3, [r7, #32]
 80163d6:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 80163da:	463b      	mov	r3, r7
 80163dc:	4610      	mov	r0, r2
 80163de:	2100      	movs	r1, #0
 80163e0:	461a      	mov	r2, r3
 80163e2:	f002 fcd9 	bl	8018d98 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
 80163e6:	6a3b      	ldr	r3, [r7, #32]
 80163e8:	334c      	adds	r3, #76	; 0x4c
 80163ea:	4618      	mov	r0, r3
 80163ec:	f002 fb8e 	bl	8018b0c <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 80163f0:	4623      	mov	r3, r4
 80163f2:	4618      	mov	r0, r3
 80163f4:	f7e9 feee 	bl	80001d4 <rt_hw_interrupt_enable>

        /* re-schedule */
        rt_schedule();
 80163f8:	f001 fe12 	bl	8018020 <rt_schedule>

        /* recv message */
        if (thread->error != RT_EOK)
 80163fc:	6a3b      	ldr	r3, [r7, #32]
 80163fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8016400:	2b00      	cmp	r3, #0
 8016402:	d002      	beq.n	801640a <rt_mq_recv+0x152>
        {
            /* return error */
            return thread->error;
 8016404:	6a3b      	ldr	r3, [r7, #32]
 8016406:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8016408:	e05b      	b.n	80164c2 <rt_mq_recv+0x20a>
        }

        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
 801640a:	f7e9 fedf 	bl	80001cc <rt_hw_interrupt_disable>
 801640e:	4603      	mov	r3, r0
 8016410:	461c      	mov	r4, r3

        /* if it's not waiting forever and then re-calculate timeout tick */
        if (timeout > 0)
 8016412:	683b      	ldr	r3, [r7, #0]
 8016414:	2b00      	cmp	r3, #0
 8016416:	dd0f      	ble.n	8016438 <rt_mq_recv+0x180>
        {
            tick_delta = rt_tick_get() - tick_delta;
 8016418:	f7fe ff36 	bl	8015288 <rt_tick_get>
 801641c:	4602      	mov	r2, r0
 801641e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016420:	1ad3      	subs	r3, r2, r3
 8016422:	627b      	str	r3, [r7, #36]	; 0x24
            timeout -= tick_delta;
 8016424:	683b      	ldr	r3, [r7, #0]
 8016426:	461a      	mov	r2, r3
 8016428:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801642a:	1ad3      	subs	r3, r2, r3
 801642c:	603b      	str	r3, [r7, #0]
            if (timeout < 0)
 801642e:	683b      	ldr	r3, [r7, #0]
 8016430:	2b00      	cmp	r3, #0
 8016432:	da01      	bge.n	8016438 <rt_mq_recv+0x180>
                timeout = 0;
 8016434:	2300      	movs	r3, #0
 8016436:	603b      	str	r3, [r7, #0]

        return -RT_ETIMEOUT;
    }

    /* message queue is empty */
    while (mq->entry == 0)
 8016438:	68fb      	ldr	r3, [r7, #12]
 801643a:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801643c:	2b00      	cmp	r3, #0
 801643e:	f43f af7e 	beq.w	801633e <rt_mq_recv+0x86>
                timeout = 0;
        }
    }

    /* get message from queue */
    msg = (struct rt_mq_message *)mq->msg_queue_head;
 8016442:	68fb      	ldr	r3, [r7, #12]
 8016444:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8016446:	617b      	str	r3, [r7, #20]
	
    /* move message queue head */
    mq->msg_queue_head = msg->next;
 8016448:	697b      	ldr	r3, [r7, #20]
 801644a:	681a      	ldr	r2, [r3, #0]
 801644c:	68fb      	ldr	r3, [r7, #12]
 801644e:	629a      	str	r2, [r3, #40]	; 0x28
    /* reach queue tail, set to NULL */
    if (mq->msg_queue_tail == msg)
 8016450:	68fb      	ldr	r3, [r7, #12]
 8016452:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8016454:	697b      	ldr	r3, [r7, #20]
 8016456:	429a      	cmp	r2, r3
 8016458:	d102      	bne.n	8016460 <rt_mq_recv+0x1a8>
        mq->msg_queue_tail = RT_NULL;
 801645a:	68fb      	ldr	r3, [r7, #12]
 801645c:	2200      	movs	r2, #0
 801645e:	62da      	str	r2, [r3, #44]	; 0x2c

    /* decrease message entry */
    mq->entry --;
 8016460:	68fb      	ldr	r3, [r7, #12]
 8016462:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8016464:	3b01      	subs	r3, #1
 8016466:	b29a      	uxth	r2, r3
 8016468:	68fb      	ldr	r3, [r7, #12]
 801646a:	849a      	strh	r2, [r3, #36]	; 0x24

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 801646c:	4623      	mov	r3, r4
 801646e:	4618      	mov	r0, r3
 8016470:	f7e9 feb0 	bl	80001d4 <rt_hw_interrupt_enable>

    /* copy message */
    rt_memcpy(buffer, msg + 1, size > mq->msg_size ? mq->msg_size : size);
 8016474:	697b      	ldr	r3, [r7, #20]
 8016476:	1d1a      	adds	r2, r3, #4
 8016478:	68fb      	ldr	r3, [r7, #12]
 801647a:	8c1b      	ldrh	r3, [r3, #32]
 801647c:	4619      	mov	r1, r3
 801647e:	687b      	ldr	r3, [r7, #4]
 8016480:	428b      	cmp	r3, r1
 8016482:	bf28      	it	cs
 8016484:	460b      	movcs	r3, r1
 8016486:	68b8      	ldr	r0, [r7, #8]
 8016488:	4611      	mov	r1, r2
 801648a:	461a      	mov	r2, r3
 801648c:	f000 f8e4 	bl	8016658 <rt_memcpy>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8016490:	f7e9 fe9c 	bl	80001cc <rt_hw_interrupt_disable>
 8016494:	4603      	mov	r3, r0
 8016496:	461c      	mov	r4, r3
    /* put message to free list */
    msg->next = (struct rt_mq_message *)mq->msg_queue_free;
 8016498:	68fb      	ldr	r3, [r7, #12]
 801649a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801649c:	697b      	ldr	r3, [r7, #20]
 801649e:	601a      	str	r2, [r3, #0]
    mq->msg_queue_free = msg;
 80164a0:	68fb      	ldr	r3, [r7, #12]
 80164a2:	697a      	ldr	r2, [r7, #20]
 80164a4:	631a      	str	r2, [r3, #48]	; 0x30
    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 80164a6:	4623      	mov	r3, r4
 80164a8:	4618      	mov	r0, r3
 80164aa:	f7e9 fe93 	bl	80001d4 <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mq->parent.parent)));
 80164ae:	4b0f      	ldr	r3, [pc, #60]	; (80164ec <rt_mq_recv+0x234>)
 80164b0:	681b      	ldr	r3, [r3, #0]
 80164b2:	2b00      	cmp	r3, #0
 80164b4:	d004      	beq.n	80164c0 <rt_mq_recv+0x208>
 80164b6:	4b0d      	ldr	r3, [pc, #52]	; (80164ec <rt_mq_recv+0x234>)
 80164b8:	681b      	ldr	r3, [r3, #0]
 80164ba:	68fa      	ldr	r2, [r7, #12]
 80164bc:	4610      	mov	r0, r2
 80164be:	4798      	blx	r3

    return RT_EOK;
 80164c0:	2300      	movs	r3, #0
}
 80164c2:	4618      	mov	r0, r3
 80164c4:	372c      	adds	r7, #44	; 0x2c
 80164c6:	46bd      	mov	sp, r7
 80164c8:	bd90      	pop	{r4, r7, pc}
 80164ca:	bf00      	nop
 80164cc:	08028ea8 	.word	0x08028ea8
 80164d0:	0802a7a4 	.word	0x0802a7a4
 80164d4:	08028eb8 	.word	0x08028eb8
 80164d8:	08028ecc 	.word	0x08028ecc
 80164dc:	20012a6c 	.word	0x20012a6c
 80164e0:	08028e38 	.word	0x08028e38
 80164e4:	08028e34 	.word	0x08028e34
 80164e8:	08028e10 	.word	0x08028e10
 80164ec:	20012a68 	.word	0x20012a68

080164f0 <rt_interrupt_enter>:
 * @note please don't invoke this routine in application
 *
 * @see rt_interrupt_leave
 */
void rt_interrupt_enter(void)
{
 80164f0:	b580      	push	{r7, lr}
 80164f2:	b082      	sub	sp, #8
 80164f4:	af00      	add	r7, sp, #0
    rt_base_t level;

    RT_DEBUG_LOG(RT_DEBUG_IRQ, ("irq coming..., irq nest:%d\n",
                                rt_interrupt_nest));

    level = rt_hw_interrupt_disable();
 80164f6:	f7e9 fe69 	bl	80001cc <rt_hw_interrupt_disable>
 80164fa:	6078      	str	r0, [r7, #4]
    rt_interrupt_nest ++;
 80164fc:	4b06      	ldr	r3, [pc, #24]	; (8016518 <rt_interrupt_enter+0x28>)
 80164fe:	781b      	ldrb	r3, [r3, #0]
 8016500:	b2db      	uxtb	r3, r3
 8016502:	3301      	adds	r3, #1
 8016504:	b2da      	uxtb	r2, r3
 8016506:	4b04      	ldr	r3, [pc, #16]	; (8016518 <rt_interrupt_enter+0x28>)
 8016508:	701a      	strb	r2, [r3, #0]
    rt_hw_interrupt_enable(level);
 801650a:	6878      	ldr	r0, [r7, #4]
 801650c:	f7e9 fe62 	bl	80001d4 <rt_hw_interrupt_enable>
}
 8016510:	3708      	adds	r7, #8
 8016512:	46bd      	mov	sp, r7
 8016514:	bd80      	pop	{r7, pc}
 8016516:	bf00      	nop
 8016518:	20012a5c 	.word	0x20012a5c

0801651c <rt_interrupt_leave>:
 * @note please don't invoke this routine in application
 *
 * @see rt_interrupt_enter
 */
void rt_interrupt_leave(void)
{
 801651c:	b580      	push	{r7, lr}
 801651e:	b082      	sub	sp, #8
 8016520:	af00      	add	r7, sp, #0
    rt_base_t level;

    RT_DEBUG_LOG(RT_DEBUG_IRQ, ("irq leave, irq nest:%d\n",
                                rt_interrupt_nest));

    level = rt_hw_interrupt_disable();
 8016522:	f7e9 fe53 	bl	80001cc <rt_hw_interrupt_disable>
 8016526:	6078      	str	r0, [r7, #4]
    rt_interrupt_nest --;
 8016528:	4b06      	ldr	r3, [pc, #24]	; (8016544 <rt_interrupt_leave+0x28>)
 801652a:	781b      	ldrb	r3, [r3, #0]
 801652c:	b2db      	uxtb	r3, r3
 801652e:	3b01      	subs	r3, #1
 8016530:	b2da      	uxtb	r2, r3
 8016532:	4b04      	ldr	r3, [pc, #16]	; (8016544 <rt_interrupt_leave+0x28>)
 8016534:	701a      	strb	r2, [r3, #0]
    rt_hw_interrupt_enable(level);
 8016536:	6878      	ldr	r0, [r7, #4]
 8016538:	f7e9 fe4c 	bl	80001d4 <rt_hw_interrupt_enable>
}
 801653c:	3708      	adds	r7, #8
 801653e:	46bd      	mov	sp, r7
 8016540:	bd80      	pop	{r7, pc}
 8016542:	bf00      	nop
 8016544:	20012a5c 	.word	0x20012a5c

08016548 <rt_interrupt_get_nest>:
 * context is interrupt context.
 *
 * @return the number of nested interrupts.
 */
rt_uint8_t rt_interrupt_get_nest(void)
{
 8016548:	b480      	push	{r7}
 801654a:	af00      	add	r7, sp, #0
    return rt_interrupt_nest;
 801654c:	4b03      	ldr	r3, [pc, #12]	; (801655c <rt_interrupt_get_nest+0x14>)
 801654e:	781b      	ldrb	r3, [r3, #0]
 8016550:	b2db      	uxtb	r3, r3
}
 8016552:	4618      	mov	r0, r3
 8016554:	46bd      	mov	sp, r7
 8016556:	f85d 7b04 	ldr.w	r7, [sp], #4
 801655a:	4770      	bx	lr
 801655c:	20012a5c 	.word	0x20012a5c

08016560 <rt_set_errno>:
 * This function will set errno
 *
 * @param error the errno shall be set
 */
void rt_set_errno(rt_err_t error)
{
 8016560:	b580      	push	{r7, lr}
 8016562:	b084      	sub	sp, #16
 8016564:	af00      	add	r7, sp, #0
 8016566:	6078      	str	r0, [r7, #4]
    rt_thread_t tid;

    if (rt_interrupt_get_nest() != 0)
 8016568:	f7ff ffee 	bl	8016548 <rt_interrupt_get_nest>
 801656c:	4603      	mov	r3, r0
 801656e:	2b00      	cmp	r3, #0
 8016570:	d003      	beq.n	801657a <rt_set_errno+0x1a>
    {
        /* it's in interrupt context */
        _errno = error;
 8016572:	4a0a      	ldr	r2, [pc, #40]	; (801659c <rt_set_errno+0x3c>)
 8016574:	687b      	ldr	r3, [r7, #4]
 8016576:	6013      	str	r3, [r2, #0]

        return;
 8016578:	e00c      	b.n	8016594 <rt_set_errno+0x34>
    }

    tid = rt_thread_self();
 801657a:	f001 ff8d 	bl	8018498 <rt_thread_self>
 801657e:	60f8      	str	r0, [r7, #12]
    if (tid == RT_NULL)
 8016580:	68fb      	ldr	r3, [r7, #12]
 8016582:	2b00      	cmp	r3, #0
 8016584:	d103      	bne.n	801658e <rt_set_errno+0x2e>
    {
        _errno = error;
 8016586:	4a05      	ldr	r2, [pc, #20]	; (801659c <rt_set_errno+0x3c>)
 8016588:	687b      	ldr	r3, [r7, #4]
 801658a:	6013      	str	r3, [r2, #0]

        return;
 801658c:	e002      	b.n	8016594 <rt_set_errno+0x34>
    }

    tid->error = error;
 801658e:	68fb      	ldr	r3, [r7, #12]
 8016590:	687a      	ldr	r2, [r7, #4]
 8016592:	631a      	str	r2, [r3, #48]	; 0x30
}
 8016594:	3710      	adds	r7, #16
 8016596:	46bd      	mov	sp, r7
 8016598:	bd80      	pop	{r7, pc}
 801659a:	bf00      	nop
 801659c:	20010cf4 	.word	0x20010cf4

080165a0 <rt_memset>:
 * @param count the copied length
 *
 * @return the address of source memory
 */
void *rt_memset(void *s, int c, rt_ubase_t count)
{
 80165a0:	b480      	push	{r7}
 80165a2:	b089      	sub	sp, #36	; 0x24
 80165a4:	af00      	add	r7, sp, #0
 80165a6:	60f8      	str	r0, [r7, #12]
 80165a8:	60b9      	str	r1, [r7, #8]
 80165aa:	607a      	str	r2, [r7, #4]
#define LBLOCKSIZE      (sizeof(rt_int32_t))
#define UNALIGNED(X)    ((rt_int32_t)X & (LBLOCKSIZE - 1))
#define TOO_SMALL(LEN)  ((LEN) < LBLOCKSIZE)

    int i;
    char *m = (char *)s;
 80165ac:	68fb      	ldr	r3, [r7, #12]
 80165ae:	61fb      	str	r3, [r7, #28]
    rt_uint32_t buffer;
    rt_uint32_t *aligned_addr;
    rt_uint32_t d = c & 0xff;
 80165b0:	68bb      	ldr	r3, [r7, #8]
 80165b2:	b2db      	uxtb	r3, r3
 80165b4:	617b      	str	r3, [r7, #20]

    if (!TOO_SMALL(count) && !UNALIGNED(s))
 80165b6:	687b      	ldr	r3, [r7, #4]
 80165b8:	2b03      	cmp	r3, #3
 80165ba:	d939      	bls.n	8016630 <rt_memset+0x90>
 80165bc:	68fb      	ldr	r3, [r7, #12]
 80165be:	f003 0303 	and.w	r3, r3, #3
 80165c2:	2b00      	cmp	r3, #0
 80165c4:	d134      	bne.n	8016630 <rt_memset+0x90>
    {
        /* If we get this far, we know that n is large and m is word-aligned. */
        aligned_addr = (rt_uint32_t *)s;
 80165c6:	68fb      	ldr	r3, [r7, #12]
 80165c8:	61bb      	str	r3, [r7, #24]
        /* Store D into each char sized location in BUFFER so that
         * we can set large blocks quickly.
         */
        if (LBLOCKSIZE == 4)
        {
            buffer = (d << 8) | d;
 80165ca:	697b      	ldr	r3, [r7, #20]
 80165cc:	021a      	lsls	r2, r3, #8
 80165ce:	697b      	ldr	r3, [r7, #20]
 80165d0:	4313      	orrs	r3, r2
 80165d2:	613b      	str	r3, [r7, #16]
            buffer |= (buffer << 16);
 80165d4:	693b      	ldr	r3, [r7, #16]
 80165d6:	041b      	lsls	r3, r3, #16
 80165d8:	693a      	ldr	r2, [r7, #16]
 80165da:	4313      	orrs	r3, r2
 80165dc:	613b      	str	r3, [r7, #16]
            buffer = 0;
            for (i = 0; i < LBLOCKSIZE; i ++)
                buffer = (buffer << 8) | d;
        }

        while (count >= LBLOCKSIZE * 4)
 80165de:	e016      	b.n	801660e <rt_memset+0x6e>
        {
            *aligned_addr++ = buffer;
 80165e0:	69bb      	ldr	r3, [r7, #24]
 80165e2:	1d1a      	adds	r2, r3, #4
 80165e4:	61ba      	str	r2, [r7, #24]
 80165e6:	693a      	ldr	r2, [r7, #16]
 80165e8:	601a      	str	r2, [r3, #0]
            *aligned_addr++ = buffer;
 80165ea:	69bb      	ldr	r3, [r7, #24]
 80165ec:	1d1a      	adds	r2, r3, #4
 80165ee:	61ba      	str	r2, [r7, #24]
 80165f0:	693a      	ldr	r2, [r7, #16]
 80165f2:	601a      	str	r2, [r3, #0]
            *aligned_addr++ = buffer;
 80165f4:	69bb      	ldr	r3, [r7, #24]
 80165f6:	1d1a      	adds	r2, r3, #4
 80165f8:	61ba      	str	r2, [r7, #24]
 80165fa:	693a      	ldr	r2, [r7, #16]
 80165fc:	601a      	str	r2, [r3, #0]
            *aligned_addr++ = buffer;
 80165fe:	69bb      	ldr	r3, [r7, #24]
 8016600:	1d1a      	adds	r2, r3, #4
 8016602:	61ba      	str	r2, [r7, #24]
 8016604:	693a      	ldr	r2, [r7, #16]
 8016606:	601a      	str	r2, [r3, #0]
            count -= 4 * LBLOCKSIZE;
 8016608:	687b      	ldr	r3, [r7, #4]
 801660a:	3b10      	subs	r3, #16
 801660c:	607b      	str	r3, [r7, #4]
            buffer = 0;
            for (i = 0; i < LBLOCKSIZE; i ++)
                buffer = (buffer << 8) | d;
        }

        while (count >= LBLOCKSIZE * 4)
 801660e:	687b      	ldr	r3, [r7, #4]
 8016610:	2b0f      	cmp	r3, #15
 8016612:	d8e5      	bhi.n	80165e0 <rt_memset+0x40>
            *aligned_addr++ = buffer;
            *aligned_addr++ = buffer;
            count -= 4 * LBLOCKSIZE;
        }

        while (count >= LBLOCKSIZE)
 8016614:	e007      	b.n	8016626 <rt_memset+0x86>
        {
            *aligned_addr++ = buffer;
 8016616:	69bb      	ldr	r3, [r7, #24]
 8016618:	1d1a      	adds	r2, r3, #4
 801661a:	61ba      	str	r2, [r7, #24]
 801661c:	693a      	ldr	r2, [r7, #16]
 801661e:	601a      	str	r2, [r3, #0]
            count -= LBLOCKSIZE;
 8016620:	687b      	ldr	r3, [r7, #4]
 8016622:	3b04      	subs	r3, #4
 8016624:	607b      	str	r3, [r7, #4]
            *aligned_addr++ = buffer;
            *aligned_addr++ = buffer;
            count -= 4 * LBLOCKSIZE;
        }

        while (count >= LBLOCKSIZE)
 8016626:	687b      	ldr	r3, [r7, #4]
 8016628:	2b03      	cmp	r3, #3
 801662a:	d8f4      	bhi.n	8016616 <rt_memset+0x76>
            *aligned_addr++ = buffer;
            count -= LBLOCKSIZE;
        }

        /* Pick up the remainder with a bytewise loop. */
        m = (char *)aligned_addr;
 801662c:	69bb      	ldr	r3, [r7, #24]
 801662e:	61fb      	str	r3, [r7, #28]
    }

    while (count--)
 8016630:	e005      	b.n	801663e <rt_memset+0x9e>
    {
        *m++ = (char)d;
 8016632:	69fb      	ldr	r3, [r7, #28]
 8016634:	1c5a      	adds	r2, r3, #1
 8016636:	61fa      	str	r2, [r7, #28]
 8016638:	697a      	ldr	r2, [r7, #20]
 801663a:	b2d2      	uxtb	r2, r2
 801663c:	701a      	strb	r2, [r3, #0]

        /* Pick up the remainder with a bytewise loop. */
        m = (char *)aligned_addr;
    }

    while (count--)
 801663e:	687b      	ldr	r3, [r7, #4]
 8016640:	1e5a      	subs	r2, r3, #1
 8016642:	607a      	str	r2, [r7, #4]
 8016644:	2b00      	cmp	r3, #0
 8016646:	d1f4      	bne.n	8016632 <rt_memset+0x92>
    {
        *m++ = (char)d;
    }

    return s;
 8016648:	68fb      	ldr	r3, [r7, #12]

#undef LBLOCKSIZE
#undef UNALIGNED
#undef TOO_SMALL
#endif
}
 801664a:	4618      	mov	r0, r3
 801664c:	3724      	adds	r7, #36	; 0x24
 801664e:	46bd      	mov	sp, r7
 8016650:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016654:	4770      	bx	lr
 8016656:	bf00      	nop

08016658 <rt_memcpy>:
 * @param count the copied length
 *
 * @return the address of destination memory
 */
void *rt_memcpy(void *dst, const void *src, rt_ubase_t count)
{
 8016658:	b480      	push	{r7}
 801665a:	b08b      	sub	sp, #44	; 0x2c
 801665c:	af00      	add	r7, sp, #0
 801665e:	60f8      	str	r0, [r7, #12]
 8016660:	60b9      	str	r1, [r7, #8]
 8016662:	607a      	str	r2, [r7, #4]
                         ((rt_int32_t)Y & (sizeof(rt_int32_t) - 1)))
#define BIGBLOCKSIZE    (sizeof(rt_int32_t) << 2)
#define LITTLEBLOCKSIZE (sizeof(rt_int32_t))
#define TOO_SMALL(LEN)  ((LEN) < BIGBLOCKSIZE)

    char *dst_ptr = (char *)dst;
 8016664:	68fb      	ldr	r3, [r7, #12]
 8016666:	627b      	str	r3, [r7, #36]	; 0x24
    char *src_ptr = (char *)src;
 8016668:	68bb      	ldr	r3, [r7, #8]
 801666a:	623b      	str	r3, [r7, #32]
    rt_int32_t *aligned_dst;
    rt_int32_t *aligned_src;
    int len = count;
 801666c:	687b      	ldr	r3, [r7, #4]
 801666e:	617b      	str	r3, [r7, #20]

    /* If the size is small, or either SRC or DST is unaligned,
    then punt into the byte copy loop.  This should be rare. */
    if (!TOO_SMALL(len) && !UNALIGNED(src_ptr, dst_ptr))
 8016670:	697b      	ldr	r3, [r7, #20]
 8016672:	2b0f      	cmp	r3, #15
 8016674:	d944      	bls.n	8016700 <rt_memcpy+0xa8>
 8016676:	6a3a      	ldr	r2, [r7, #32]
 8016678:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801667a:	4313      	orrs	r3, r2
 801667c:	f003 0303 	and.w	r3, r3, #3
 8016680:	2b00      	cmp	r3, #0
 8016682:	d13d      	bne.n	8016700 <rt_memcpy+0xa8>
    {
        aligned_dst = (rt_int32_t *)dst_ptr;
 8016684:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016686:	61fb      	str	r3, [r7, #28]
        aligned_src = (rt_int32_t *)src_ptr;
 8016688:	6a3b      	ldr	r3, [r7, #32]
 801668a:	61bb      	str	r3, [r7, #24]

        /* Copy 4X long words at a time if possible. */
        while (len >= BIGBLOCKSIZE)
 801668c:	e022      	b.n	80166d4 <rt_memcpy+0x7c>
        {
            *aligned_dst++ = *aligned_src++;
 801668e:	69fb      	ldr	r3, [r7, #28]
 8016690:	1d1a      	adds	r2, r3, #4
 8016692:	61fa      	str	r2, [r7, #28]
 8016694:	69ba      	ldr	r2, [r7, #24]
 8016696:	1d11      	adds	r1, r2, #4
 8016698:	61b9      	str	r1, [r7, #24]
 801669a:	6812      	ldr	r2, [r2, #0]
 801669c:	601a      	str	r2, [r3, #0]
            *aligned_dst++ = *aligned_src++;
 801669e:	69fb      	ldr	r3, [r7, #28]
 80166a0:	1d1a      	adds	r2, r3, #4
 80166a2:	61fa      	str	r2, [r7, #28]
 80166a4:	69ba      	ldr	r2, [r7, #24]
 80166a6:	1d11      	adds	r1, r2, #4
 80166a8:	61b9      	str	r1, [r7, #24]
 80166aa:	6812      	ldr	r2, [r2, #0]
 80166ac:	601a      	str	r2, [r3, #0]
            *aligned_dst++ = *aligned_src++;
 80166ae:	69fb      	ldr	r3, [r7, #28]
 80166b0:	1d1a      	adds	r2, r3, #4
 80166b2:	61fa      	str	r2, [r7, #28]
 80166b4:	69ba      	ldr	r2, [r7, #24]
 80166b6:	1d11      	adds	r1, r2, #4
 80166b8:	61b9      	str	r1, [r7, #24]
 80166ba:	6812      	ldr	r2, [r2, #0]
 80166bc:	601a      	str	r2, [r3, #0]
            *aligned_dst++ = *aligned_src++;
 80166be:	69fb      	ldr	r3, [r7, #28]
 80166c0:	1d1a      	adds	r2, r3, #4
 80166c2:	61fa      	str	r2, [r7, #28]
 80166c4:	69ba      	ldr	r2, [r7, #24]
 80166c6:	1d11      	adds	r1, r2, #4
 80166c8:	61b9      	str	r1, [r7, #24]
 80166ca:	6812      	ldr	r2, [r2, #0]
 80166cc:	601a      	str	r2, [r3, #0]
            len -= BIGBLOCKSIZE;
 80166ce:	697b      	ldr	r3, [r7, #20]
 80166d0:	3b10      	subs	r3, #16
 80166d2:	617b      	str	r3, [r7, #20]
    {
        aligned_dst = (rt_int32_t *)dst_ptr;
        aligned_src = (rt_int32_t *)src_ptr;

        /* Copy 4X long words at a time if possible. */
        while (len >= BIGBLOCKSIZE)
 80166d4:	697b      	ldr	r3, [r7, #20]
 80166d6:	2b0f      	cmp	r3, #15
 80166d8:	d8d9      	bhi.n	801668e <rt_memcpy+0x36>
            *aligned_dst++ = *aligned_src++;
            len -= BIGBLOCKSIZE;
        }

        /* Copy one long word at a time if possible. */
        while (len >= LITTLEBLOCKSIZE)
 80166da:	e00a      	b.n	80166f2 <rt_memcpy+0x9a>
        {
            *aligned_dst++ = *aligned_src++;
 80166dc:	69fb      	ldr	r3, [r7, #28]
 80166de:	1d1a      	adds	r2, r3, #4
 80166e0:	61fa      	str	r2, [r7, #28]
 80166e2:	69ba      	ldr	r2, [r7, #24]
 80166e4:	1d11      	adds	r1, r2, #4
 80166e6:	61b9      	str	r1, [r7, #24]
 80166e8:	6812      	ldr	r2, [r2, #0]
 80166ea:	601a      	str	r2, [r3, #0]
            len -= LITTLEBLOCKSIZE;
 80166ec:	697b      	ldr	r3, [r7, #20]
 80166ee:	3b04      	subs	r3, #4
 80166f0:	617b      	str	r3, [r7, #20]
            *aligned_dst++ = *aligned_src++;
            len -= BIGBLOCKSIZE;
        }

        /* Copy one long word at a time if possible. */
        while (len >= LITTLEBLOCKSIZE)
 80166f2:	697b      	ldr	r3, [r7, #20]
 80166f4:	2b03      	cmp	r3, #3
 80166f6:	d8f1      	bhi.n	80166dc <rt_memcpy+0x84>
            *aligned_dst++ = *aligned_src++;
            len -= LITTLEBLOCKSIZE;
        }

        /* Pick up any residual with a byte copier. */
        dst_ptr = (char *)aligned_dst;
 80166f8:	69fb      	ldr	r3, [r7, #28]
 80166fa:	627b      	str	r3, [r7, #36]	; 0x24
        src_ptr = (char *)aligned_src;
 80166fc:	69bb      	ldr	r3, [r7, #24]
 80166fe:	623b      	str	r3, [r7, #32]
    }

    while (len--)
 8016700:	e007      	b.n	8016712 <rt_memcpy+0xba>
        *dst_ptr++ = *src_ptr++;
 8016702:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016704:	1c5a      	adds	r2, r3, #1
 8016706:	627a      	str	r2, [r7, #36]	; 0x24
 8016708:	6a3a      	ldr	r2, [r7, #32]
 801670a:	1c51      	adds	r1, r2, #1
 801670c:	6239      	str	r1, [r7, #32]
 801670e:	7812      	ldrb	r2, [r2, #0]
 8016710:	701a      	strb	r2, [r3, #0]
        /* Pick up any residual with a byte copier. */
        dst_ptr = (char *)aligned_dst;
        src_ptr = (char *)aligned_src;
    }

    while (len--)
 8016712:	697b      	ldr	r3, [r7, #20]
 8016714:	1e5a      	subs	r2, r3, #1
 8016716:	617a      	str	r2, [r7, #20]
 8016718:	2b00      	cmp	r3, #0
 801671a:	d1f2      	bne.n	8016702 <rt_memcpy+0xaa>
        *dst_ptr++ = *src_ptr++;

    return dst;
 801671c:	68fb      	ldr	r3, [r7, #12]
#undef UNALIGNED
#undef BIGBLOCKSIZE
#undef LITTLEBLOCKSIZE
#undef TOO_SMALL
#endif
}
 801671e:	4618      	mov	r0, r3
 8016720:	372c      	adds	r7, #44	; 0x2c
 8016722:	46bd      	mov	sp, r7
 8016724:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016728:	4770      	bx	lr
 801672a:	bf00      	nop

0801672c <rt_memmove>:
 * @param n the copied length
 *
 * @return the address of destination memory
 */
void *rt_memmove(void *dest, const void *src, rt_ubase_t n)
{
 801672c:	b480      	push	{r7}
 801672e:	b087      	sub	sp, #28
 8016730:	af00      	add	r7, sp, #0
 8016732:	60f8      	str	r0, [r7, #12]
 8016734:	60b9      	str	r1, [r7, #8]
 8016736:	607a      	str	r2, [r7, #4]
    char *tmp = (char *)dest, *s = (char *)src;
 8016738:	68fb      	ldr	r3, [r7, #12]
 801673a:	617b      	str	r3, [r7, #20]
 801673c:	68bb      	ldr	r3, [r7, #8]
 801673e:	613b      	str	r3, [r7, #16]

    if (s < tmp && tmp < s + n)
 8016740:	693a      	ldr	r2, [r7, #16]
 8016742:	697b      	ldr	r3, [r7, #20]
 8016744:	429a      	cmp	r2, r3
 8016746:	d21e      	bcs.n	8016786 <rt_memmove+0x5a>
 8016748:	693a      	ldr	r2, [r7, #16]
 801674a:	687b      	ldr	r3, [r7, #4]
 801674c:	441a      	add	r2, r3
 801674e:	697b      	ldr	r3, [r7, #20]
 8016750:	429a      	cmp	r2, r3
 8016752:	d918      	bls.n	8016786 <rt_memmove+0x5a>
    {
        tmp += n;
 8016754:	697a      	ldr	r2, [r7, #20]
 8016756:	687b      	ldr	r3, [r7, #4]
 8016758:	4413      	add	r3, r2
 801675a:	617b      	str	r3, [r7, #20]
        s += n;
 801675c:	693a      	ldr	r2, [r7, #16]
 801675e:	687b      	ldr	r3, [r7, #4]
 8016760:	4413      	add	r3, r2
 8016762:	613b      	str	r3, [r7, #16]

        while (n--)
 8016764:	e009      	b.n	801677a <rt_memmove+0x4e>
            *(--tmp) = *(--s);
 8016766:	697b      	ldr	r3, [r7, #20]
 8016768:	3b01      	subs	r3, #1
 801676a:	617b      	str	r3, [r7, #20]
 801676c:	693b      	ldr	r3, [r7, #16]
 801676e:	3b01      	subs	r3, #1
 8016770:	613b      	str	r3, [r7, #16]
 8016772:	693b      	ldr	r3, [r7, #16]
 8016774:	781a      	ldrb	r2, [r3, #0]
 8016776:	697b      	ldr	r3, [r7, #20]
 8016778:	701a      	strb	r2, [r3, #0]
    if (s < tmp && tmp < s + n)
    {
        tmp += n;
        s += n;

        while (n--)
 801677a:	687b      	ldr	r3, [r7, #4]
 801677c:	1e5a      	subs	r2, r3, #1
 801677e:	607a      	str	r2, [r7, #4]
 8016780:	2b00      	cmp	r3, #0
 8016782:	d1f0      	bne.n	8016766 <rt_memmove+0x3a>
 */
void *rt_memmove(void *dest, const void *src, rt_ubase_t n)
{
    char *tmp = (char *)dest, *s = (char *)src;

    if (s < tmp && tmp < s + n)
 8016784:	e00d      	b.n	80167a2 <rt_memmove+0x76>
        while (n--)
            *(--tmp) = *(--s);
    }
    else
    {
        while (n--)
 8016786:	e007      	b.n	8016798 <rt_memmove+0x6c>
            *tmp++ = *s++;
 8016788:	697b      	ldr	r3, [r7, #20]
 801678a:	1c5a      	adds	r2, r3, #1
 801678c:	617a      	str	r2, [r7, #20]
 801678e:	693a      	ldr	r2, [r7, #16]
 8016790:	1c51      	adds	r1, r2, #1
 8016792:	6139      	str	r1, [r7, #16]
 8016794:	7812      	ldrb	r2, [r2, #0]
 8016796:	701a      	strb	r2, [r3, #0]
        while (n--)
            *(--tmp) = *(--s);
    }
    else
    {
        while (n--)
 8016798:	687b      	ldr	r3, [r7, #4]
 801679a:	1e5a      	subs	r2, r3, #1
 801679c:	607a      	str	r2, [r7, #4]
 801679e:	2b00      	cmp	r3, #0
 80167a0:	d1f2      	bne.n	8016788 <rt_memmove+0x5c>
            *tmp++ = *s++;
    }

    return dest;
 80167a2:	68fb      	ldr	r3, [r7, #12]
}
 80167a4:	4618      	mov	r0, r3
 80167a6:	371c      	adds	r7, #28
 80167a8:	46bd      	mov	sp, r7
 80167aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80167ae:	4770      	bx	lr

080167b0 <rt_strncpy>:
 * @param n the maximum copied length
 *
 * @return the result
 */
char *rt_strncpy(char *dst, const char *src, rt_ubase_t n)
{
 80167b0:	b480      	push	{r7}
 80167b2:	b087      	sub	sp, #28
 80167b4:	af00      	add	r7, sp, #0
 80167b6:	60f8      	str	r0, [r7, #12]
 80167b8:	60b9      	str	r1, [r7, #8]
 80167ba:	607a      	str	r2, [r7, #4]
    if (n != 0)
 80167bc:	687b      	ldr	r3, [r7, #4]
 80167be:	2b00      	cmp	r3, #0
 80167c0:	d021      	beq.n	8016806 <rt_strncpy+0x56>
    {
        char *d = dst;
 80167c2:	68fb      	ldr	r3, [r7, #12]
 80167c4:	617b      	str	r3, [r7, #20]
        const char *s = src;
 80167c6:	68bb      	ldr	r3, [r7, #8]
 80167c8:	613b      	str	r3, [r7, #16]

        do
        {
            if ((*d++ = *s++) == 0)
 80167ca:	697b      	ldr	r3, [r7, #20]
 80167cc:	1c5a      	adds	r2, r3, #1
 80167ce:	617a      	str	r2, [r7, #20]
 80167d0:	693a      	ldr	r2, [r7, #16]
 80167d2:	1c51      	adds	r1, r2, #1
 80167d4:	6139      	str	r1, [r7, #16]
 80167d6:	7812      	ldrb	r2, [r2, #0]
 80167d8:	701a      	strb	r2, [r3, #0]
 80167da:	781b      	ldrb	r3, [r3, #0]
 80167dc:	2b00      	cmp	r3, #0
 80167de:	d10c      	bne.n	80167fa <rt_strncpy+0x4a>
            {
                /* NUL pad the remaining n-1 bytes */
                while (--n != 0)
 80167e0:	e004      	b.n	80167ec <rt_strncpy+0x3c>
                    *d++ = 0;
 80167e2:	697b      	ldr	r3, [r7, #20]
 80167e4:	1c5a      	adds	r2, r3, #1
 80167e6:	617a      	str	r2, [r7, #20]
 80167e8:	2200      	movs	r2, #0
 80167ea:	701a      	strb	r2, [r3, #0]
        do
        {
            if ((*d++ = *s++) == 0)
            {
                /* NUL pad the remaining n-1 bytes */
                while (--n != 0)
 80167ec:	687b      	ldr	r3, [r7, #4]
 80167ee:	3b01      	subs	r3, #1
 80167f0:	607b      	str	r3, [r7, #4]
 80167f2:	687b      	ldr	r3, [r7, #4]
 80167f4:	2b00      	cmp	r3, #0
 80167f6:	d1f4      	bne.n	80167e2 <rt_strncpy+0x32>
                    *d++ = 0;
                break;
 80167f8:	e005      	b.n	8016806 <rt_strncpy+0x56>
            }
        } while (--n != 0);
 80167fa:	687b      	ldr	r3, [r7, #4]
 80167fc:	3b01      	subs	r3, #1
 80167fe:	607b      	str	r3, [r7, #4]
 8016800:	687b      	ldr	r3, [r7, #4]
 8016802:	2b00      	cmp	r3, #0
 8016804:	d1e1      	bne.n	80167ca <rt_strncpy+0x1a>
    }

    return (dst);
 8016806:	68fb      	ldr	r3, [r7, #12]
}
 8016808:	4618      	mov	r0, r3
 801680a:	371c      	adds	r7, #28
 801680c:	46bd      	mov	sp, r7
 801680e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016812:	4770      	bx	lr

08016814 <rt_strncmp>:
 * @param count the maximum compare length
 *
 * @return the result
 */
rt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count)
{
 8016814:	b490      	push	{r4, r7}
 8016816:	b084      	sub	sp, #16
 8016818:	af00      	add	r7, sp, #0
 801681a:	60f8      	str	r0, [r7, #12]
 801681c:	60b9      	str	r1, [r7, #8]
 801681e:	607a      	str	r2, [r7, #4]
    register signed char __res = 0;
 8016820:	2400      	movs	r4, #0

    while (count)
 8016822:	e013      	b.n	801684c <rt_strncmp+0x38>
    {
        if ((__res = *cs - *ct++) != 0 || !*cs++)
 8016824:	68fb      	ldr	r3, [r7, #12]
 8016826:	781a      	ldrb	r2, [r3, #0]
 8016828:	68bb      	ldr	r3, [r7, #8]
 801682a:	1c59      	adds	r1, r3, #1
 801682c:	60b9      	str	r1, [r7, #8]
 801682e:	781b      	ldrb	r3, [r3, #0]
 8016830:	1ad3      	subs	r3, r2, r3
 8016832:	b2db      	uxtb	r3, r3
 8016834:	b2dc      	uxtb	r4, r3
 8016836:	2c00      	cmp	r4, #0
 8016838:	d10b      	bne.n	8016852 <rt_strncmp+0x3e>
 801683a:	68fb      	ldr	r3, [r7, #12]
 801683c:	1c5a      	adds	r2, r3, #1
 801683e:	60fa      	str	r2, [r7, #12]
 8016840:	781b      	ldrb	r3, [r3, #0]
 8016842:	2b00      	cmp	r3, #0
 8016844:	d005      	beq.n	8016852 <rt_strncmp+0x3e>
            break;
        count --;
 8016846:	687b      	ldr	r3, [r7, #4]
 8016848:	3b01      	subs	r3, #1
 801684a:	607b      	str	r3, [r7, #4]
 */
rt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count)
{
    register signed char __res = 0;

    while (count)
 801684c:	687b      	ldr	r3, [r7, #4]
 801684e:	2b00      	cmp	r3, #0
 8016850:	d1e8      	bne.n	8016824 <rt_strncmp+0x10>
        if ((__res = *cs - *ct++) != 0 || !*cs++)
            break;
        count --;
    }

    return __res;
 8016852:	b263      	sxtb	r3, r4
}
 8016854:	4618      	mov	r0, r3
 8016856:	3710      	adds	r7, #16
 8016858:	46bd      	mov	sp, r7
 801685a:	bc90      	pop	{r4, r7}
 801685c:	4770      	bx	lr
 801685e:	bf00      	nop

08016860 <rt_strlen>:
 * @param s the string
 *
 * @return the length of string
 */
rt_size_t rt_strlen(const char *s)
{
 8016860:	b480      	push	{r7}
 8016862:	b085      	sub	sp, #20
 8016864:	af00      	add	r7, sp, #0
 8016866:	6078      	str	r0, [r7, #4]
    const char *sc;

    for (sc = s; *sc != '\0'; ++sc) /* nothing */
 8016868:	687b      	ldr	r3, [r7, #4]
 801686a:	60fb      	str	r3, [r7, #12]
 801686c:	e002      	b.n	8016874 <rt_strlen+0x14>
 801686e:	68fb      	ldr	r3, [r7, #12]
 8016870:	3301      	adds	r3, #1
 8016872:	60fb      	str	r3, [r7, #12]
 8016874:	68fb      	ldr	r3, [r7, #12]
 8016876:	781b      	ldrb	r3, [r3, #0]
 8016878:	2b00      	cmp	r3, #0
 801687a:	d1f8      	bne.n	801686e <rt_strlen+0xe>
        ;

    return sc - s;
 801687c:	68fa      	ldr	r2, [r7, #12]
 801687e:	687b      	ldr	r3, [r7, #4]
 8016880:	1ad3      	subs	r3, r2, r3
}
 8016882:	4618      	mov	r0, r3
 8016884:	3714      	adds	r7, #20
 8016886:	46bd      	mov	sp, r7
 8016888:	f85d 7b04 	ldr.w	r7, [sp], #4
 801688c:	4770      	bx	lr
 801688e:	bf00      	nop

08016890 <rt_show_version>:

/**
 * This function will show the version of rt-thread rtos
 */
void rt_show_version(void)
{
 8016890:	b580      	push	{r7, lr}
 8016892:	b082      	sub	sp, #8
 8016894:	af02      	add	r7, sp, #8
	//while(1)
		{
			rt_kprintf("\n \\ | /\n");
 8016896:	4809      	ldr	r0, [pc, #36]	; (80168bc <rt_show_version+0x2c>)
 8016898:	f000 fc3a 	bl	8017110 <rt_kprintf>
		    rt_kprintf("- RT -     Thread Operating System\n");
 801689c:	4808      	ldr	r0, [pc, #32]	; (80168c0 <rt_show_version+0x30>)
 801689e:	f000 fc37 	bl	8017110 <rt_kprintf>
		    rt_kprintf(" / | \\     %d.%d.%d build %s\n",
 80168a2:	4b08      	ldr	r3, [pc, #32]	; (80168c4 <rt_show_version+0x34>)
 80168a4:	9300      	str	r3, [sp, #0]
 80168a6:	4808      	ldr	r0, [pc, #32]	; (80168c8 <rt_show_version+0x38>)
 80168a8:	2102      	movs	r1, #2
 80168aa:	2201      	movs	r2, #1
 80168ac:	2300      	movs	r3, #0
 80168ae:	f000 fc2f 	bl	8017110 <rt_kprintf>
		               RT_VERSION, RT_SUBVERSION, RT_REVISION, __DATE__);
		    rt_kprintf(" 2006 - 2015 Copyright by rt-thread team\n");
 80168b2:	4806      	ldr	r0, [pc, #24]	; (80168cc <rt_show_version+0x3c>)
 80168b4:	f000 fc2c 	bl	8017110 <rt_kprintf>
		}
}
 80168b8:	46bd      	mov	sp, r7
 80168ba:	bd80      	pop	{r7, pc}
 80168bc:	08028ed8 	.word	0x08028ed8
 80168c0:	08028ee4 	.word	0x08028ee4
 80168c4:	08028f28 	.word	0x08028f28
 80168c8:	08028f08 	.word	0x08028f08
 80168cc:	08028f34 	.word	0x08028f34

080168d0 <divide>:

/* private function */
#define isdigit(c)  ((unsigned)((c) - '0') < 10)

rt_inline rt_int32_t divide(rt_int32_t *n, rt_int32_t base)
{
 80168d0:	b480      	push	{r7}
 80168d2:	b085      	sub	sp, #20
 80168d4:	af00      	add	r7, sp, #0
 80168d6:	6078      	str	r0, [r7, #4]
 80168d8:	6039      	str	r1, [r7, #0]
    rt_int32_t res;

    /* optimized for processor which does not support divide instructions. */
    if (base == 10)
 80168da:	683b      	ldr	r3, [r7, #0]
 80168dc:	2b0a      	cmp	r3, #10
 80168de:	d117      	bne.n	8016910 <divide+0x40>
    {
        res = ((rt_uint32_t)*n) % 10U;
 80168e0:	687b      	ldr	r3, [r7, #4]
 80168e2:	681b      	ldr	r3, [r3, #0]
 80168e4:	4619      	mov	r1, r3
 80168e6:	4b13      	ldr	r3, [pc, #76]	; (8016934 <divide+0x64>)
 80168e8:	fba3 2301 	umull	r2, r3, r3, r1
 80168ec:	08da      	lsrs	r2, r3, #3
 80168ee:	4613      	mov	r3, r2
 80168f0:	009b      	lsls	r3, r3, #2
 80168f2:	4413      	add	r3, r2
 80168f4:	005b      	lsls	r3, r3, #1
 80168f6:	1aca      	subs	r2, r1, r3
 80168f8:	60fa      	str	r2, [r7, #12]
        *n = ((rt_uint32_t)*n) / 10U;
 80168fa:	687b      	ldr	r3, [r7, #4]
 80168fc:	681b      	ldr	r3, [r3, #0]
 80168fe:	461a      	mov	r2, r3
 8016900:	4b0c      	ldr	r3, [pc, #48]	; (8016934 <divide+0x64>)
 8016902:	fba3 2302 	umull	r2, r3, r3, r2
 8016906:	08db      	lsrs	r3, r3, #3
 8016908:	461a      	mov	r2, r3
 801690a:	687b      	ldr	r3, [r7, #4]
 801690c:	601a      	str	r2, [r3, #0]
 801690e:	e00a      	b.n	8016926 <divide+0x56>
    }
    else
    {
        res = ((rt_uint32_t)*n) % 16U;
 8016910:	687b      	ldr	r3, [r7, #4]
 8016912:	681b      	ldr	r3, [r3, #0]
 8016914:	f003 030f 	and.w	r3, r3, #15
 8016918:	60fb      	str	r3, [r7, #12]
        *n = ((rt_uint32_t)*n) / 16U;
 801691a:	687b      	ldr	r3, [r7, #4]
 801691c:	681b      	ldr	r3, [r3, #0]
 801691e:	091b      	lsrs	r3, r3, #4
 8016920:	461a      	mov	r2, r3
 8016922:	687b      	ldr	r3, [r7, #4]
 8016924:	601a      	str	r2, [r3, #0]
    }

    return res;
 8016926:	68fb      	ldr	r3, [r7, #12]
}
 8016928:	4618      	mov	r0, r3
 801692a:	3714      	adds	r7, #20
 801692c:	46bd      	mov	sp, r7
 801692e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016932:	4770      	bx	lr
 8016934:	cccccccd 	.word	0xcccccccd

08016938 <skip_atoi>:

rt_inline int skip_atoi(const char **s)
{
 8016938:	b490      	push	{r4, r7}
 801693a:	b082      	sub	sp, #8
 801693c:	af00      	add	r7, sp, #0
 801693e:	6078      	str	r0, [r7, #4]
    register int i=0;
 8016940:	2400      	movs	r4, #0
    while (isdigit(**s))
 8016942:	e00d      	b.n	8016960 <skip_atoi+0x28>
        i = i * 10 + *((*s)++) - '0';
 8016944:	4623      	mov	r3, r4
 8016946:	009b      	lsls	r3, r3, #2
 8016948:	4423      	add	r3, r4
 801694a:	005b      	lsls	r3, r3, #1
 801694c:	4618      	mov	r0, r3
 801694e:	687b      	ldr	r3, [r7, #4]
 8016950:	681b      	ldr	r3, [r3, #0]
 8016952:	1c59      	adds	r1, r3, #1
 8016954:	687a      	ldr	r2, [r7, #4]
 8016956:	6011      	str	r1, [r2, #0]
 8016958:	781b      	ldrb	r3, [r3, #0]
 801695a:	4403      	add	r3, r0
 801695c:	f1a3 0430 	sub.w	r4, r3, #48	; 0x30
}

rt_inline int skip_atoi(const char **s)
{
    register int i=0;
    while (isdigit(**s))
 8016960:	687b      	ldr	r3, [r7, #4]
 8016962:	681b      	ldr	r3, [r3, #0]
 8016964:	781b      	ldrb	r3, [r3, #0]
 8016966:	3b30      	subs	r3, #48	; 0x30
 8016968:	2b09      	cmp	r3, #9
 801696a:	d9eb      	bls.n	8016944 <skip_atoi+0xc>
        i = i * 10 + *((*s)++) - '0';

    return i;
 801696c:	4623      	mov	r3, r4
}
 801696e:	4618      	mov	r0, r3
 8016970:	3708      	adds	r7, #8
 8016972:	46bd      	mov	sp, r7
 8016974:	bc90      	pop	{r4, r7}
 8016976:	4770      	bx	lr

08016978 <print_number>:
                          long  num,
                          int   base,
                          int   s,
                          int   type)
#endif
{
 8016978:	b5f0      	push	{r4, r5, r6, r7, lr}
 801697a:	b08d      	sub	sp, #52	; 0x34
 801697c:	af00      	add	r7, sp, #0
 801697e:	60f8      	str	r0, [r7, #12]
 8016980:	60b9      	str	r1, [r7, #8]
 8016982:	607a      	str	r2, [r7, #4]
 8016984:	603b      	str	r3, [r7, #0]
    static const char small_digits[] = "0123456789abcdef";
    static const char large_digits[] = "0123456789ABCDEF";
    register int i;
    register int size;

    size = s;
 8016986:	6cbc      	ldr	r4, [r7, #72]	; 0x48

    digits = (type & LARGE) ? large_digits : small_digits;
 8016988:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801698a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801698e:	2b00      	cmp	r3, #0
 8016990:	d001      	beq.n	8016996 <print_number+0x1e>
 8016992:	4b6c      	ldr	r3, [pc, #432]	; (8016b44 <print_number+0x1cc>)
 8016994:	e000      	b.n	8016998 <print_number+0x20>
 8016996:	4b6c      	ldr	r3, [pc, #432]	; (8016b48 <print_number+0x1d0>)
 8016998:	62bb      	str	r3, [r7, #40]	; 0x28
    if (type & LEFT)
 801699a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801699c:	f003 0310 	and.w	r3, r3, #16
 80169a0:	2b00      	cmp	r3, #0
 80169a2:	d003      	beq.n	80169ac <print_number+0x34>
        type &= ~ZEROPAD;
 80169a4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80169a6:	f023 0301 	bic.w	r3, r3, #1
 80169aa:	653b      	str	r3, [r7, #80]	; 0x50

    c = (type & ZEROPAD) ? '0' : ' ';
 80169ac:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80169ae:	f003 0301 	and.w	r3, r3, #1
 80169b2:	2b00      	cmp	r3, #0
 80169b4:	d001      	beq.n	80169ba <print_number+0x42>
 80169b6:	2330      	movs	r3, #48	; 0x30
 80169b8:	e000      	b.n	80169bc <print_number+0x44>
 80169ba:	2320      	movs	r3, #32
 80169bc:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

    /* get sign */
    sign = 0;
 80169c0:	2300      	movs	r3, #0
 80169c2:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    if (type & SIGN)
 80169c6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80169c8:	f003 0302 	and.w	r3, r3, #2
 80169cc:	2b00      	cmp	r3, #0
 80169ce:	d01a      	beq.n	8016a06 <print_number+0x8e>
    {
        if (num < 0)
 80169d0:	687b      	ldr	r3, [r7, #4]
 80169d2:	2b00      	cmp	r3, #0
 80169d4:	da06      	bge.n	80169e4 <print_number+0x6c>
        {
            sign = '-';
 80169d6:	232d      	movs	r3, #45	; 0x2d
 80169d8:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
            num = -num;
 80169dc:	687b      	ldr	r3, [r7, #4]
 80169de:	425b      	negs	r3, r3
 80169e0:	607b      	str	r3, [r7, #4]
 80169e2:	e010      	b.n	8016a06 <print_number+0x8e>
        }
        else if (type & PLUS)
 80169e4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80169e6:	f003 0304 	and.w	r3, r3, #4
 80169ea:	2b00      	cmp	r3, #0
 80169ec:	d003      	beq.n	80169f6 <print_number+0x7e>
            sign = '+';
 80169ee:	232b      	movs	r3, #43	; 0x2b
 80169f0:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 80169f4:	e007      	b.n	8016a06 <print_number+0x8e>
        else if (type & SPACE)
 80169f6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80169f8:	f003 0308 	and.w	r3, r3, #8
 80169fc:	2b00      	cmp	r3, #0
 80169fe:	d002      	beq.n	8016a06 <print_number+0x8e>
            sign = ' ';
 8016a00:	2320      	movs	r3, #32
 8016a02:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
        else if (base == 8)
            size--;
    }
#endif

    i = 0;
 8016a06:	2500      	movs	r5, #0
    if (num == 0)
 8016a08:	687b      	ldr	r3, [r7, #4]
 8016a0a:	2b00      	cmp	r3, #0
 8016a0c:	d108      	bne.n	8016a20 <print_number+0xa8>
        tmp[i++]='0';
 8016a0e:	462b      	mov	r3, r5
 8016a10:	1c5d      	adds	r5, r3, #1
 8016a12:	f107 0230 	add.w	r2, r7, #48	; 0x30
 8016a16:	4413      	add	r3, r2
 8016a18:	2230      	movs	r2, #48	; 0x30
 8016a1a:	f803 2c1c 	strb.w	r2, [r3, #-28]
 8016a1e:	e014      	b.n	8016a4a <print_number+0xd2>
    else
    {
        while (num != 0)
 8016a20:	e010      	b.n	8016a44 <print_number+0xcc>
            tmp[i++] = digits[divide(&num, base)];
 8016a22:	462e      	mov	r6, r5
 8016a24:	1c75      	adds	r5, r6, #1
 8016a26:	1d3b      	adds	r3, r7, #4
 8016a28:	4618      	mov	r0, r3
 8016a2a:	6839      	ldr	r1, [r7, #0]
 8016a2c:	f7ff ff50 	bl	80168d0 <divide>
 8016a30:	4603      	mov	r3, r0
 8016a32:	461a      	mov	r2, r3
 8016a34:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016a36:	4413      	add	r3, r2
 8016a38:	781a      	ldrb	r2, [r3, #0]
 8016a3a:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8016a3e:	4433      	add	r3, r6
 8016a40:	f803 2c1c 	strb.w	r2, [r3, #-28]
    i = 0;
    if (num == 0)
        tmp[i++]='0';
    else
    {
        while (num != 0)
 8016a44:	687b      	ldr	r3, [r7, #4]
 8016a46:	2b00      	cmp	r3, #0
 8016a48:	d1eb      	bne.n	8016a22 <print_number+0xaa>
            tmp[i++] = digits[divide(&num, base)];
    }

#ifdef RT_PRINTF_PRECISION
    if (i > precision)
 8016a4a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016a4c:	429d      	cmp	r5, r3
 8016a4e:	dd00      	ble.n	8016a52 <print_number+0xda>
        precision = i;
 8016a50:	64fd      	str	r5, [r7, #76]	; 0x4c
    size -= precision;
 8016a52:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016a54:	1ae4      	subs	r4, r4, r3
#else
    size -= i;
#endif

    if (!(type&(ZEROPAD | LEFT)))
 8016a56:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016a58:	f003 0311 	and.w	r3, r3, #17
 8016a5c:	2b00      	cmp	r3, #0
 8016a5e:	d115      	bne.n	8016a8c <print_number+0x114>
    {
        if ((sign)&&(size>0))
 8016a60:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8016a64:	2b00      	cmp	r3, #0
 8016a66:	d002      	beq.n	8016a6e <print_number+0xf6>
 8016a68:	2c00      	cmp	r4, #0
 8016a6a:	dd00      	ble.n	8016a6e <print_number+0xf6>
            size--;
 8016a6c:	3c01      	subs	r4, #1

        while (size-->0)
 8016a6e:	e009      	b.n	8016a84 <print_number+0x10c>
        {
            if (buf <= end)
 8016a70:	68fa      	ldr	r2, [r7, #12]
 8016a72:	68bb      	ldr	r3, [r7, #8]
 8016a74:	429a      	cmp	r2, r3
 8016a76:	d802      	bhi.n	8016a7e <print_number+0x106>
                *buf = ' ';
 8016a78:	68fb      	ldr	r3, [r7, #12]
 8016a7a:	2220      	movs	r2, #32
 8016a7c:	701a      	strb	r2, [r3, #0]
            ++ buf;
 8016a7e:	68fb      	ldr	r3, [r7, #12]
 8016a80:	3301      	adds	r3, #1
 8016a82:	60fb      	str	r3, [r7, #12]
    if (!(type&(ZEROPAD | LEFT)))
    {
        if ((sign)&&(size>0))
            size--;

        while (size-->0)
 8016a84:	4623      	mov	r3, r4
 8016a86:	1e5c      	subs	r4, r3, #1
 8016a88:	2b00      	cmp	r3, #0
 8016a8a:	dcf1      	bgt.n	8016a70 <print_number+0xf8>
                *buf = ' ';
            ++ buf;
        }
    }

    if (sign)
 8016a8c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8016a90:	2b00      	cmp	r3, #0
 8016a92:	d00b      	beq.n	8016aac <print_number+0x134>
    {
        if (buf <= end)
 8016a94:	68fa      	ldr	r2, [r7, #12]
 8016a96:	68bb      	ldr	r3, [r7, #8]
 8016a98:	429a      	cmp	r2, r3
 8016a9a:	d804      	bhi.n	8016aa6 <print_number+0x12e>
        {
            *buf = sign;
 8016a9c:	68fb      	ldr	r3, [r7, #12]
 8016a9e:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
 8016aa2:	701a      	strb	r2, [r3, #0]
            -- size;
 8016aa4:	3c01      	subs	r4, #1
        }
        ++ buf;
 8016aa6:	68fb      	ldr	r3, [r7, #12]
 8016aa8:	3301      	adds	r3, #1
 8016aaa:	60fb      	str	r3, [r7, #12]
        }
    }
#endif

    /* no align to the left */
    if (!(type & LEFT))
 8016aac:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016aae:	f003 0310 	and.w	r3, r3, #16
 8016ab2:	2b00      	cmp	r3, #0
 8016ab4:	d10f      	bne.n	8016ad6 <print_number+0x15e>
    {
        while (size-- > 0)
 8016ab6:	e00a      	b.n	8016ace <print_number+0x156>
        {
            if (buf <= end)
 8016ab8:	68fa      	ldr	r2, [r7, #12]
 8016aba:	68bb      	ldr	r3, [r7, #8]
 8016abc:	429a      	cmp	r2, r3
 8016abe:	d803      	bhi.n	8016ac8 <print_number+0x150>
                *buf = c;
 8016ac0:	68fb      	ldr	r3, [r7, #12]
 8016ac2:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 8016ac6:	701a      	strb	r2, [r3, #0]
            ++ buf;
 8016ac8:	68fb      	ldr	r3, [r7, #12]
 8016aca:	3301      	adds	r3, #1
 8016acc:	60fb      	str	r3, [r7, #12]
#endif

    /* no align to the left */
    if (!(type & LEFT))
    {
        while (size-- > 0)
 8016ace:	4623      	mov	r3, r4
 8016ad0:	1e5c      	subs	r4, r3, #1
 8016ad2:	2b00      	cmp	r3, #0
 8016ad4:	dcf0      	bgt.n	8016ab8 <print_number+0x140>
            ++ buf;
        }
    }

#ifdef RT_PRINTF_PRECISION
    while (i < precision--)
 8016ad6:	e009      	b.n	8016aec <print_number+0x174>
    {
        if (buf <= end)
 8016ad8:	68fa      	ldr	r2, [r7, #12]
 8016ada:	68bb      	ldr	r3, [r7, #8]
 8016adc:	429a      	cmp	r2, r3
 8016ade:	d802      	bhi.n	8016ae6 <print_number+0x16e>
            *buf = '0';
 8016ae0:	68fb      	ldr	r3, [r7, #12]
 8016ae2:	2230      	movs	r2, #48	; 0x30
 8016ae4:	701a      	strb	r2, [r3, #0]
        ++ buf;
 8016ae6:	68fb      	ldr	r3, [r7, #12]
 8016ae8:	3301      	adds	r3, #1
 8016aea:	60fb      	str	r3, [r7, #12]
            ++ buf;
        }
    }

#ifdef RT_PRINTF_PRECISION
    while (i < precision--)
 8016aec:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016aee:	1e5a      	subs	r2, r3, #1
 8016af0:	64fa      	str	r2, [r7, #76]	; 0x4c
 8016af2:	42ab      	cmp	r3, r5
 8016af4:	dcf0      	bgt.n	8016ad8 <print_number+0x160>
        ++ buf;
    }
#endif

    /* put number in the temporary buffer */
    while (i-- > 0)
 8016af6:	e00d      	b.n	8016b14 <print_number+0x19c>
    {
        if (buf <= end)
 8016af8:	68fa      	ldr	r2, [r7, #12]
 8016afa:	68bb      	ldr	r3, [r7, #8]
 8016afc:	429a      	cmp	r2, r3
 8016afe:	d806      	bhi.n	8016b0e <print_number+0x196>
            *buf = tmp[i];
 8016b00:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8016b04:	442b      	add	r3, r5
 8016b06:	f813 2c1c 	ldrb.w	r2, [r3, #-28]
 8016b0a:	68fb      	ldr	r3, [r7, #12]
 8016b0c:	701a      	strb	r2, [r3, #0]
        ++ buf;
 8016b0e:	68fb      	ldr	r3, [r7, #12]
 8016b10:	3301      	adds	r3, #1
 8016b12:	60fb      	str	r3, [r7, #12]
        ++ buf;
    }
#endif

    /* put number in the temporary buffer */
    while (i-- > 0)
 8016b14:	462b      	mov	r3, r5
 8016b16:	1e5d      	subs	r5, r3, #1
 8016b18:	2b00      	cmp	r3, #0
 8016b1a:	dced      	bgt.n	8016af8 <print_number+0x180>
        if (buf <= end)
            *buf = tmp[i];
        ++ buf;
    }

    while (size-- > 0)
 8016b1c:	e009      	b.n	8016b32 <print_number+0x1ba>
    {
        if (buf <= end)
 8016b1e:	68fa      	ldr	r2, [r7, #12]
 8016b20:	68bb      	ldr	r3, [r7, #8]
 8016b22:	429a      	cmp	r2, r3
 8016b24:	d802      	bhi.n	8016b2c <print_number+0x1b4>
            *buf = ' ';
 8016b26:	68fb      	ldr	r3, [r7, #12]
 8016b28:	2220      	movs	r2, #32
 8016b2a:	701a      	strb	r2, [r3, #0]
        ++ buf;
 8016b2c:	68fb      	ldr	r3, [r7, #12]
 8016b2e:	3301      	adds	r3, #1
 8016b30:	60fb      	str	r3, [r7, #12]
        if (buf <= end)
            *buf = tmp[i];
        ++ buf;
    }

    while (size-- > 0)
 8016b32:	4623      	mov	r3, r4
 8016b34:	1e5c      	subs	r4, r3, #1
 8016b36:	2b00      	cmp	r3, #0
 8016b38:	dcf1      	bgt.n	8016b1e <print_number+0x1a6>
        if (buf <= end)
            *buf = ' ';
        ++ buf;
    }

    return buf;
 8016b3a:	68fb      	ldr	r3, [r7, #12]
}
 8016b3c:	4618      	mov	r0, r3
 8016b3e:	3734      	adds	r7, #52	; 0x34
 8016b40:	46bd      	mov	sp, r7
 8016b42:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8016b44:	0802a8b0 	.word	0x0802a8b0
 8016b48:	0802a8c4 	.word	0x0802a8c4

08016b4c <rt_vsnprintf>:

rt_int32_t rt_vsnprintf(char       *buf,
                        rt_size_t   size,
                        const char *fmt,
                        va_list     args)
{
 8016b4c:	b5b0      	push	{r4, r5, r7, lr}
 8016b4e:	b092      	sub	sp, #72	; 0x48
 8016b50:	af04      	add	r7, sp, #16
 8016b52:	60f8      	str	r0, [r7, #12]
 8016b54:	60b9      	str	r1, [r7, #8]
 8016b56:	607a      	str	r2, [r7, #4]
 8016b58:	603b      	str	r3, [r7, #0]

#ifdef RT_PRINTF_PRECISION
    int precision;      /* min. # of digits for integers and max for a string */
#endif

    str = buf;
 8016b5a:	68fb      	ldr	r3, [r7, #12]
 8016b5c:	62bb      	str	r3, [r7, #40]	; 0x28
    end = buf + size - 1;
 8016b5e:	68bb      	ldr	r3, [r7, #8]
 8016b60:	3b01      	subs	r3, #1
 8016b62:	68fa      	ldr	r2, [r7, #12]
 8016b64:	4413      	add	r3, r2
 8016b66:	627b      	str	r3, [r7, #36]	; 0x24

    /* Make sure end is always >= buf */
    if (end < buf)
 8016b68:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016b6a:	68fb      	ldr	r3, [r7, #12]
 8016b6c:	429a      	cmp	r2, r3
 8016b6e:	d206      	bcs.n	8016b7e <rt_vsnprintf+0x32>
    {
        end  = ((char *)-1);
 8016b70:	f04f 33ff 	mov.w	r3, #4294967295
 8016b74:	627b      	str	r3, [r7, #36]	; 0x24
        size = end - buf;
 8016b76:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016b78:	68fb      	ldr	r3, [r7, #12]
 8016b7a:	1ad3      	subs	r3, r2, r3
 8016b7c:	60bb      	str	r3, [r7, #8]
    }

    for (; *fmt ; ++fmt)
 8016b7e:	e271      	b.n	8017064 <rt_vsnprintf+0x518>
    {
        if (*fmt != '%')
 8016b80:	687b      	ldr	r3, [r7, #4]
 8016b82:	781b      	ldrb	r3, [r3, #0]
 8016b84:	2b25      	cmp	r3, #37	; 0x25
 8016b86:	d00b      	beq.n	8016ba0 <rt_vsnprintf+0x54>
        {
            if (str <= end)
 8016b88:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016b8a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016b8c:	429a      	cmp	r2, r3
 8016b8e:	d803      	bhi.n	8016b98 <rt_vsnprintf+0x4c>
                *str = *fmt;
 8016b90:	687b      	ldr	r3, [r7, #4]
 8016b92:	781a      	ldrb	r2, [r3, #0]
 8016b94:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016b96:	701a      	strb	r2, [r3, #0]
            ++ str;
 8016b98:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016b9a:	3301      	adds	r3, #1
 8016b9c:	62bb      	str	r3, [r7, #40]	; 0x28
            continue;
 8016b9e:	e25e      	b.n	801705e <rt_vsnprintf+0x512>
        }

        /* process flags */
        flags = 0;
 8016ba0:	2300      	movs	r3, #0
 8016ba2:	77bb      	strb	r3, [r7, #30]

        while (1)
        {
            /* skips the first '%' also */
            ++ fmt;
 8016ba4:	687b      	ldr	r3, [r7, #4]
 8016ba6:	3301      	adds	r3, #1
 8016ba8:	607b      	str	r3, [r7, #4]
            if (*fmt == '-') flags |= LEFT;
 8016baa:	687b      	ldr	r3, [r7, #4]
 8016bac:	781b      	ldrb	r3, [r3, #0]
 8016bae:	2b2d      	cmp	r3, #45	; 0x2d
 8016bb0:	d104      	bne.n	8016bbc <rt_vsnprintf+0x70>
 8016bb2:	7fbb      	ldrb	r3, [r7, #30]
 8016bb4:	f043 0310 	orr.w	r3, r3, #16
 8016bb8:	77bb      	strb	r3, [r7, #30]
 8016bba:	e02d      	b.n	8016c18 <rt_vsnprintf+0xcc>
            else if (*fmt == '+') flags |= PLUS;
 8016bbc:	687b      	ldr	r3, [r7, #4]
 8016bbe:	781b      	ldrb	r3, [r3, #0]
 8016bc0:	2b2b      	cmp	r3, #43	; 0x2b
 8016bc2:	d104      	bne.n	8016bce <rt_vsnprintf+0x82>
 8016bc4:	7fbb      	ldrb	r3, [r7, #30]
 8016bc6:	f043 0304 	orr.w	r3, r3, #4
 8016bca:	77bb      	strb	r3, [r7, #30]
 8016bcc:	e024      	b.n	8016c18 <rt_vsnprintf+0xcc>
            else if (*fmt == ' ') flags |= SPACE;
 8016bce:	687b      	ldr	r3, [r7, #4]
 8016bd0:	781b      	ldrb	r3, [r3, #0]
 8016bd2:	2b20      	cmp	r3, #32
 8016bd4:	d104      	bne.n	8016be0 <rt_vsnprintf+0x94>
 8016bd6:	7fbb      	ldrb	r3, [r7, #30]
 8016bd8:	f043 0308 	orr.w	r3, r3, #8
 8016bdc:	77bb      	strb	r3, [r7, #30]
 8016bde:	e01b      	b.n	8016c18 <rt_vsnprintf+0xcc>
            else if (*fmt == '#') flags |= SPECIAL;
 8016be0:	687b      	ldr	r3, [r7, #4]
 8016be2:	781b      	ldrb	r3, [r3, #0]
 8016be4:	2b23      	cmp	r3, #35	; 0x23
 8016be6:	d104      	bne.n	8016bf2 <rt_vsnprintf+0xa6>
 8016be8:	7fbb      	ldrb	r3, [r7, #30]
 8016bea:	f043 0320 	orr.w	r3, r3, #32
 8016bee:	77bb      	strb	r3, [r7, #30]
 8016bf0:	e012      	b.n	8016c18 <rt_vsnprintf+0xcc>
            else if (*fmt == '0') flags |= ZEROPAD;
 8016bf2:	687b      	ldr	r3, [r7, #4]
 8016bf4:	781b      	ldrb	r3, [r3, #0]
 8016bf6:	2b30      	cmp	r3, #48	; 0x30
 8016bf8:	d104      	bne.n	8016c04 <rt_vsnprintf+0xb8>
 8016bfa:	7fbb      	ldrb	r3, [r7, #30]
 8016bfc:	f043 0301 	orr.w	r3, r3, #1
 8016c00:	77bb      	strb	r3, [r7, #30]
 8016c02:	e009      	b.n	8016c18 <rt_vsnprintf+0xcc>
            else break;
 8016c04:	bf00      	nop
        }

        /* get field width */
        field_width = -1;
 8016c06:	f04f 33ff 	mov.w	r3, #4294967295
 8016c0a:	61bb      	str	r3, [r7, #24]
        if (isdigit(*fmt)) field_width = skip_atoi(&fmt);
 8016c0c:	687b      	ldr	r3, [r7, #4]
 8016c0e:	781b      	ldrb	r3, [r3, #0]
 8016c10:	3b30      	subs	r3, #48	; 0x30
 8016c12:	2b09      	cmp	r3, #9
 8016c14:	d807      	bhi.n	8016c26 <rt_vsnprintf+0xda>
 8016c16:	e000      	b.n	8016c1a <rt_vsnprintf+0xce>
            else if (*fmt == '+') flags |= PLUS;
            else if (*fmt == ' ') flags |= SPACE;
            else if (*fmt == '#') flags |= SPECIAL;
            else if (*fmt == '0') flags |= ZEROPAD;
            else break;
        }
 8016c18:	e7c4      	b.n	8016ba4 <rt_vsnprintf+0x58>

        /* get field width */
        field_width = -1;
        if (isdigit(*fmt)) field_width = skip_atoi(&fmt);
 8016c1a:	1d3b      	adds	r3, r7, #4
 8016c1c:	4618      	mov	r0, r3
 8016c1e:	f7ff fe8b 	bl	8016938 <skip_atoi>
 8016c22:	61b8      	str	r0, [r7, #24]
 8016c24:	e015      	b.n	8016c52 <rt_vsnprintf+0x106>
        else if (*fmt == '*')
 8016c26:	687b      	ldr	r3, [r7, #4]
 8016c28:	781b      	ldrb	r3, [r3, #0]
 8016c2a:	2b2a      	cmp	r3, #42	; 0x2a
 8016c2c:	d111      	bne.n	8016c52 <rt_vsnprintf+0x106>
        {
            ++ fmt;
 8016c2e:	687b      	ldr	r3, [r7, #4]
 8016c30:	3301      	adds	r3, #1
 8016c32:	607b      	str	r3, [r7, #4]
            /* it's the next argument */
            field_width = va_arg(args, int);
 8016c34:	683b      	ldr	r3, [r7, #0]
 8016c36:	1d1a      	adds	r2, r3, #4
 8016c38:	603a      	str	r2, [r7, #0]
 8016c3a:	681b      	ldr	r3, [r3, #0]
 8016c3c:	61bb      	str	r3, [r7, #24]
            if (field_width < 0)
 8016c3e:	69bb      	ldr	r3, [r7, #24]
 8016c40:	2b00      	cmp	r3, #0
 8016c42:	da06      	bge.n	8016c52 <rt_vsnprintf+0x106>
            {
                field_width = -field_width;
 8016c44:	69bb      	ldr	r3, [r7, #24]
 8016c46:	425b      	negs	r3, r3
 8016c48:	61bb      	str	r3, [r7, #24]
                flags |= LEFT;
 8016c4a:	7fbb      	ldrb	r3, [r7, #30]
 8016c4c:	f043 0310 	orr.w	r3, r3, #16
 8016c50:	77bb      	strb	r3, [r7, #30]
            }
        }

#ifdef RT_PRINTF_PRECISION
        /* get the precision */
        precision = -1;
 8016c52:	f04f 33ff 	mov.w	r3, #4294967295
 8016c56:	617b      	str	r3, [r7, #20]
        if (*fmt == '.')
 8016c58:	687b      	ldr	r3, [r7, #4]
 8016c5a:	781b      	ldrb	r3, [r3, #0]
 8016c5c:	2b2e      	cmp	r3, #46	; 0x2e
 8016c5e:	d11e      	bne.n	8016c9e <rt_vsnprintf+0x152>
        {
            ++ fmt;
 8016c60:	687b      	ldr	r3, [r7, #4]
 8016c62:	3301      	adds	r3, #1
 8016c64:	607b      	str	r3, [r7, #4]
            if (isdigit(*fmt)) precision = skip_atoi(&fmt);
 8016c66:	687b      	ldr	r3, [r7, #4]
 8016c68:	781b      	ldrb	r3, [r3, #0]
 8016c6a:	3b30      	subs	r3, #48	; 0x30
 8016c6c:	2b09      	cmp	r3, #9
 8016c6e:	d805      	bhi.n	8016c7c <rt_vsnprintf+0x130>
 8016c70:	1d3b      	adds	r3, r7, #4
 8016c72:	4618      	mov	r0, r3
 8016c74:	f7ff fe60 	bl	8016938 <skip_atoi>
 8016c78:	6178      	str	r0, [r7, #20]
 8016c7a:	e00b      	b.n	8016c94 <rt_vsnprintf+0x148>
            else if (*fmt == '*')
 8016c7c:	687b      	ldr	r3, [r7, #4]
 8016c7e:	781b      	ldrb	r3, [r3, #0]
 8016c80:	2b2a      	cmp	r3, #42	; 0x2a
 8016c82:	d107      	bne.n	8016c94 <rt_vsnprintf+0x148>
            {
                ++ fmt;
 8016c84:	687b      	ldr	r3, [r7, #4]
 8016c86:	3301      	adds	r3, #1
 8016c88:	607b      	str	r3, [r7, #4]
                /* it's the next argument */
                precision = va_arg(args, int);
 8016c8a:	683b      	ldr	r3, [r7, #0]
 8016c8c:	1d1a      	adds	r2, r3, #4
 8016c8e:	603a      	str	r2, [r7, #0]
 8016c90:	681b      	ldr	r3, [r3, #0]
 8016c92:	617b      	str	r3, [r7, #20]
            }
            if (precision < 0) precision = 0;
 8016c94:	697b      	ldr	r3, [r7, #20]
 8016c96:	2b00      	cmp	r3, #0
 8016c98:	da01      	bge.n	8016c9e <rt_vsnprintf+0x152>
 8016c9a:	2300      	movs	r3, #0
 8016c9c:	617b      	str	r3, [r7, #20]
        }
#endif
        /* get the conversion qualifier */
        qualifier = 0;
 8016c9e:	2300      	movs	r3, #0
 8016ca0:	777b      	strb	r3, [r7, #29]
#ifdef RT_PRINTF_LONGLONG
        if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L')
#else
        if (*fmt == 'h' || *fmt == 'l')
 8016ca2:	687b      	ldr	r3, [r7, #4]
 8016ca4:	781b      	ldrb	r3, [r3, #0]
 8016ca6:	2b68      	cmp	r3, #104	; 0x68
 8016ca8:	d003      	beq.n	8016cb2 <rt_vsnprintf+0x166>
 8016caa:	687b      	ldr	r3, [r7, #4]
 8016cac:	781b      	ldrb	r3, [r3, #0]
 8016cae:	2b6c      	cmp	r3, #108	; 0x6c
 8016cb0:	d105      	bne.n	8016cbe <rt_vsnprintf+0x172>
#endif
        {
            qualifier = *fmt;
 8016cb2:	687b      	ldr	r3, [r7, #4]
 8016cb4:	781b      	ldrb	r3, [r3, #0]
 8016cb6:	777b      	strb	r3, [r7, #29]
            ++ fmt;
 8016cb8:	687b      	ldr	r3, [r7, #4]
 8016cba:	3301      	adds	r3, #1
 8016cbc:	607b      	str	r3, [r7, #4]
            }
#endif
        }

        /* the default base */
        base = 10;
 8016cbe:	230a      	movs	r3, #10
 8016cc0:	77fb      	strb	r3, [r7, #31]

        switch (*fmt)
 8016cc2:	687b      	ldr	r3, [r7, #4]
 8016cc4:	781b      	ldrb	r3, [r3, #0]
 8016cc6:	3b25      	subs	r3, #37	; 0x25
 8016cc8:	2b53      	cmp	r3, #83	; 0x53
 8016cca:	f200 8171 	bhi.w	8016fb0 <rt_vsnprintf+0x464>
 8016cce:	a201      	add	r2, pc, #4	; (adr r2, 8016cd4 <rt_vsnprintf+0x188>)
 8016cd0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8016cd4:	08016f7d 	.word	0x08016f7d
 8016cd8:	08016fb1 	.word	0x08016fb1
 8016cdc:	08016fb1 	.word	0x08016fb1
 8016ce0:	08016fb1 	.word	0x08016fb1
 8016ce4:	08016fb1 	.word	0x08016fb1
 8016ce8:	08016fb1 	.word	0x08016fb1
 8016cec:	08016fb1 	.word	0x08016fb1
 8016cf0:	08016fb1 	.word	0x08016fb1
 8016cf4:	08016fb1 	.word	0x08016fb1
 8016cf8:	08016fb1 	.word	0x08016fb1
 8016cfc:	08016fb1 	.word	0x08016fb1
 8016d00:	08016fb1 	.word	0x08016fb1
 8016d04:	08016fb1 	.word	0x08016fb1
 8016d08:	08016fb1 	.word	0x08016fb1
 8016d0c:	08016fb1 	.word	0x08016fb1
 8016d10:	08016fb1 	.word	0x08016fb1
 8016d14:	08016fb1 	.word	0x08016fb1
 8016d18:	08016fb1 	.word	0x08016fb1
 8016d1c:	08016fb1 	.word	0x08016fb1
 8016d20:	08016fb1 	.word	0x08016fb1
 8016d24:	08016fb1 	.word	0x08016fb1
 8016d28:	08016fb1 	.word	0x08016fb1
 8016d2c:	08016fb1 	.word	0x08016fb1
 8016d30:	08016fb1 	.word	0x08016fb1
 8016d34:	08016fb1 	.word	0x08016fb1
 8016d38:	08016fb1 	.word	0x08016fb1
 8016d3c:	08016fb1 	.word	0x08016fb1
 8016d40:	08016fb1 	.word	0x08016fb1
 8016d44:	08016fb1 	.word	0x08016fb1
 8016d48:	08016fb1 	.word	0x08016fb1
 8016d4c:	08016fb1 	.word	0x08016fb1
 8016d50:	08016fb1 	.word	0x08016fb1
 8016d54:	08016fb1 	.word	0x08016fb1
 8016d58:	08016fb1 	.word	0x08016fb1
 8016d5c:	08016fb1 	.word	0x08016fb1
 8016d60:	08016fb1 	.word	0x08016fb1
 8016d64:	08016fb1 	.word	0x08016fb1
 8016d68:	08016fb1 	.word	0x08016fb1
 8016d6c:	08016fb1 	.word	0x08016fb1
 8016d70:	08016fb1 	.word	0x08016fb1
 8016d74:	08016fb1 	.word	0x08016fb1
 8016d78:	08016fb1 	.word	0x08016fb1
 8016d7c:	08016fb1 	.word	0x08016fb1
 8016d80:	08016fb1 	.word	0x08016fb1
 8016d84:	08016fb1 	.word	0x08016fb1
 8016d88:	08016fb1 	.word	0x08016fb1
 8016d8c:	08016fb1 	.word	0x08016fb1
 8016d90:	08016fb1 	.word	0x08016fb1
 8016d94:	08016fb1 	.word	0x08016fb1
 8016d98:	08016fb1 	.word	0x08016fb1
 8016d9c:	08016fb1 	.word	0x08016fb1
 8016da0:	08016f99 	.word	0x08016f99
 8016da4:	08016fb1 	.word	0x08016fb1
 8016da8:	08016fb1 	.word	0x08016fb1
 8016dac:	08016fb1 	.word	0x08016fb1
 8016db0:	08016fb1 	.word	0x08016fb1
 8016db4:	08016fb1 	.word	0x08016fb1
 8016db8:	08016fb1 	.word	0x08016fb1
 8016dbc:	08016fb1 	.word	0x08016fb1
 8016dc0:	08016fb1 	.word	0x08016fb1
 8016dc4:	08016fb1 	.word	0x08016fb1
 8016dc8:	08016fb1 	.word	0x08016fb1
 8016dcc:	08016e25 	.word	0x08016e25
 8016dd0:	08016fa7 	.word	0x08016fa7
 8016dd4:	08016fb1 	.word	0x08016fb1
 8016dd8:	08016fb1 	.word	0x08016fb1
 8016ddc:	08016fb1 	.word	0x08016fb1
 8016de0:	08016fb1 	.word	0x08016fb1
 8016de4:	08016fa7 	.word	0x08016fa7
 8016de8:	08016fb1 	.word	0x08016fb1
 8016dec:	08016fb1 	.word	0x08016fb1
 8016df0:	08016fb1 	.word	0x08016fb1
 8016df4:	08016fb1 	.word	0x08016fb1
 8016df8:	08016fb1 	.word	0x08016fb1
 8016dfc:	08016f93 	.word	0x08016f93
 8016e00:	08016f43 	.word	0x08016f43
 8016e04:	08016fb1 	.word	0x08016fb1
 8016e08:	08016fb1 	.word	0x08016fb1
 8016e0c:	08016e93 	.word	0x08016e93
 8016e10:	08016fb1 	.word	0x08016fb1
 8016e14:	08016fed 	.word	0x08016fed
 8016e18:	08016fb1 	.word	0x08016fb1
 8016e1c:	08016fb1 	.word	0x08016fb1
 8016e20:	08016fa1 	.word	0x08016fa1
        {
        case 'c':
            if (!(flags & LEFT))
 8016e24:	7fbb      	ldrb	r3, [r7, #30]
 8016e26:	f003 0310 	and.w	r3, r3, #16
 8016e2a:	2b00      	cmp	r3, #0
 8016e2c:	d110      	bne.n	8016e50 <rt_vsnprintf+0x304>
            {
                while (--field_width > 0)
 8016e2e:	e009      	b.n	8016e44 <rt_vsnprintf+0x2f8>
                {
                    if (str <= end) *str = ' ';
 8016e30:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016e32:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016e34:	429a      	cmp	r2, r3
 8016e36:	d802      	bhi.n	8016e3e <rt_vsnprintf+0x2f2>
 8016e38:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016e3a:	2220      	movs	r2, #32
 8016e3c:	701a      	strb	r2, [r3, #0]
                    ++ str;
 8016e3e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016e40:	3301      	adds	r3, #1
 8016e42:	62bb      	str	r3, [r7, #40]	; 0x28
        switch (*fmt)
        {
        case 'c':
            if (!(flags & LEFT))
            {
                while (--field_width > 0)
 8016e44:	69bb      	ldr	r3, [r7, #24]
 8016e46:	3b01      	subs	r3, #1
 8016e48:	61bb      	str	r3, [r7, #24]
 8016e4a:	69bb      	ldr	r3, [r7, #24]
 8016e4c:	2b00      	cmp	r3, #0
 8016e4e:	dcef      	bgt.n	8016e30 <rt_vsnprintf+0x2e4>
                    ++ str;
                }
            }

            /* get character */
            c = (rt_uint8_t)va_arg(args, int);
 8016e50:	683b      	ldr	r3, [r7, #0]
 8016e52:	1d1a      	adds	r2, r3, #4
 8016e54:	603a      	str	r2, [r7, #0]
 8016e56:	681b      	ldr	r3, [r3, #0]
 8016e58:	74fb      	strb	r3, [r7, #19]
            if (str <= end) *str = c;
 8016e5a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016e5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016e5e:	429a      	cmp	r2, r3
 8016e60:	d802      	bhi.n	8016e68 <rt_vsnprintf+0x31c>
 8016e62:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016e64:	7cfa      	ldrb	r2, [r7, #19]
 8016e66:	701a      	strb	r2, [r3, #0]
            ++ str;
 8016e68:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016e6a:	3301      	adds	r3, #1
 8016e6c:	62bb      	str	r3, [r7, #40]	; 0x28

            /* put width */
            while (--field_width > 0)
 8016e6e:	e009      	b.n	8016e84 <rt_vsnprintf+0x338>
            {
                if (str <= end) *str = ' ';
 8016e70:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016e72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016e74:	429a      	cmp	r2, r3
 8016e76:	d802      	bhi.n	8016e7e <rt_vsnprintf+0x332>
 8016e78:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016e7a:	2220      	movs	r2, #32
 8016e7c:	701a      	strb	r2, [r3, #0]
                ++ str;
 8016e7e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016e80:	3301      	adds	r3, #1
 8016e82:	62bb      	str	r3, [r7, #40]	; 0x28
            c = (rt_uint8_t)va_arg(args, int);
            if (str <= end) *str = c;
            ++ str;

            /* put width */
            while (--field_width > 0)
 8016e84:	69bb      	ldr	r3, [r7, #24]
 8016e86:	3b01      	subs	r3, #1
 8016e88:	61bb      	str	r3, [r7, #24]
 8016e8a:	69bb      	ldr	r3, [r7, #24]
 8016e8c:	2b00      	cmp	r3, #0
 8016e8e:	dcef      	bgt.n	8016e70 <rt_vsnprintf+0x324>
            {
                if (str <= end) *str = ' ';
                ++ str;
            }
            continue;
 8016e90:	e0e5      	b.n	801705e <rt_vsnprintf+0x512>

        case 's':
            s = va_arg(args, char *);
 8016e92:	683b      	ldr	r3, [r7, #0]
 8016e94:	1d1a      	adds	r2, r3, #4
 8016e96:	603a      	str	r2, [r7, #0]
 8016e98:	681b      	ldr	r3, [r3, #0]
 8016e9a:	623b      	str	r3, [r7, #32]
            if (!s) s = "(NULL)";
 8016e9c:	6a3b      	ldr	r3, [r7, #32]
 8016e9e:	2b00      	cmp	r3, #0
 8016ea0:	d101      	bne.n	8016ea6 <rt_vsnprintf+0x35a>
 8016ea2:	4b7c      	ldr	r3, [pc, #496]	; (8017094 <rt_vsnprintf+0x548>)
 8016ea4:	623b      	str	r3, [r7, #32]

            len = rt_strlen(s);
 8016ea6:	6a38      	ldr	r0, [r7, #32]
 8016ea8:	f7ff fcda 	bl	8016860 <rt_strlen>
 8016eac:	4603      	mov	r3, r0
 8016eae:	62fb      	str	r3, [r7, #44]	; 0x2c
#ifdef RT_PRINTF_PRECISION
            if (precision > 0 && len > precision) len = precision;
 8016eb0:	697b      	ldr	r3, [r7, #20]
 8016eb2:	2b00      	cmp	r3, #0
 8016eb4:	dd05      	ble.n	8016ec2 <rt_vsnprintf+0x376>
 8016eb6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016eb8:	697b      	ldr	r3, [r7, #20]
 8016eba:	429a      	cmp	r2, r3
 8016ebc:	dd01      	ble.n	8016ec2 <rt_vsnprintf+0x376>
 8016ebe:	697b      	ldr	r3, [r7, #20]
 8016ec0:	62fb      	str	r3, [r7, #44]	; 0x2c
#endif

            if (!(flags & LEFT))
 8016ec2:	7fbb      	ldrb	r3, [r7, #30]
 8016ec4:	f003 0310 	and.w	r3, r3, #16
 8016ec8:	2b00      	cmp	r3, #0
 8016eca:	d110      	bne.n	8016eee <rt_vsnprintf+0x3a2>
            {
                while (len < field_width--)
 8016ecc:	e009      	b.n	8016ee2 <rt_vsnprintf+0x396>
                {
                    if (str <= end) *str = ' ';
 8016ece:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016ed0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016ed2:	429a      	cmp	r2, r3
 8016ed4:	d802      	bhi.n	8016edc <rt_vsnprintf+0x390>
 8016ed6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016ed8:	2220      	movs	r2, #32
 8016eda:	701a      	strb	r2, [r3, #0]
                    ++ str;
 8016edc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016ede:	3301      	adds	r3, #1
 8016ee0:	62bb      	str	r3, [r7, #40]	; 0x28
            if (precision > 0 && len > precision) len = precision;
#endif

            if (!(flags & LEFT))
            {
                while (len < field_width--)
 8016ee2:	69bb      	ldr	r3, [r7, #24]
 8016ee4:	1e5a      	subs	r2, r3, #1
 8016ee6:	61ba      	str	r2, [r7, #24]
 8016ee8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016eea:	4293      	cmp	r3, r2
 8016eec:	dcef      	bgt.n	8016ece <rt_vsnprintf+0x382>
                    if (str <= end) *str = ' ';
                    ++ str;
                }
            }

            for (i = 0; i < len; ++i)
 8016eee:	2300      	movs	r3, #0
 8016ef0:	633b      	str	r3, [r7, #48]	; 0x30
 8016ef2:	e010      	b.n	8016f16 <rt_vsnprintf+0x3ca>
            {
                if (str <= end) *str = *s;
 8016ef4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016ef6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016ef8:	429a      	cmp	r2, r3
 8016efa:	d803      	bhi.n	8016f04 <rt_vsnprintf+0x3b8>
 8016efc:	6a3b      	ldr	r3, [r7, #32]
 8016efe:	781a      	ldrb	r2, [r3, #0]
 8016f00:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016f02:	701a      	strb	r2, [r3, #0]
                ++ str;
 8016f04:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016f06:	3301      	adds	r3, #1
 8016f08:	62bb      	str	r3, [r7, #40]	; 0x28
                ++ s;
 8016f0a:	6a3b      	ldr	r3, [r7, #32]
 8016f0c:	3301      	adds	r3, #1
 8016f0e:	623b      	str	r3, [r7, #32]
                    if (str <= end) *str = ' ';
                    ++ str;
                }
            }

            for (i = 0; i < len; ++i)
 8016f10:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016f12:	3301      	adds	r3, #1
 8016f14:	633b      	str	r3, [r7, #48]	; 0x30
 8016f16:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8016f18:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016f1a:	429a      	cmp	r2, r3
 8016f1c:	dbea      	blt.n	8016ef4 <rt_vsnprintf+0x3a8>
                if (str <= end) *str = *s;
                ++ str;
                ++ s;
            }

            while (len < field_width--)
 8016f1e:	e009      	b.n	8016f34 <rt_vsnprintf+0x3e8>
            {
                if (str <= end) *str = ' ';
 8016f20:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016f22:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016f24:	429a      	cmp	r2, r3
 8016f26:	d802      	bhi.n	8016f2e <rt_vsnprintf+0x3e2>
 8016f28:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016f2a:	2220      	movs	r2, #32
 8016f2c:	701a      	strb	r2, [r3, #0]
                ++ str;
 8016f2e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016f30:	3301      	adds	r3, #1
 8016f32:	62bb      	str	r3, [r7, #40]	; 0x28
                if (str <= end) *str = *s;
                ++ str;
                ++ s;
            }

            while (len < field_width--)
 8016f34:	69bb      	ldr	r3, [r7, #24]
 8016f36:	1e5a      	subs	r2, r3, #1
 8016f38:	61ba      	str	r2, [r7, #24]
 8016f3a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016f3c:	4293      	cmp	r3, r2
 8016f3e:	dcef      	bgt.n	8016f20 <rt_vsnprintf+0x3d4>
            {
                if (str <= end) *str = ' ';
                ++ str;
            }
            continue;
 8016f40:	e08d      	b.n	801705e <rt_vsnprintf+0x512>

        case 'p':
            if (field_width == -1)
 8016f42:	69bb      	ldr	r3, [r7, #24]
 8016f44:	f1b3 3fff 	cmp.w	r3, #4294967295
 8016f48:	d105      	bne.n	8016f56 <rt_vsnprintf+0x40a>
            {
                field_width = sizeof(void *) << 1;
 8016f4a:	2308      	movs	r3, #8
 8016f4c:	61bb      	str	r3, [r7, #24]
                flags |= ZEROPAD;
 8016f4e:	7fbb      	ldrb	r3, [r7, #30]
 8016f50:	f043 0301 	orr.w	r3, r3, #1
 8016f54:	77bb      	strb	r3, [r7, #30]
            }
#ifdef RT_PRINTF_PRECISION
            str = print_number(str, end,
                               (long)va_arg(args, void *),
 8016f56:	683b      	ldr	r3, [r7, #0]
 8016f58:	1d1a      	adds	r2, r3, #4
 8016f5a:	603a      	str	r2, [r7, #0]
 8016f5c:	681b      	ldr	r3, [r3, #0]
            {
                field_width = sizeof(void *) << 1;
                flags |= ZEROPAD;
            }
#ifdef RT_PRINTF_PRECISION
            str = print_number(str, end,
 8016f5e:	461c      	mov	r4, r3
 8016f60:	7fbb      	ldrb	r3, [r7, #30]
 8016f62:	69ba      	ldr	r2, [r7, #24]
 8016f64:	9200      	str	r2, [sp, #0]
 8016f66:	697a      	ldr	r2, [r7, #20]
 8016f68:	9201      	str	r2, [sp, #4]
 8016f6a:	9302      	str	r3, [sp, #8]
 8016f6c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8016f6e:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8016f70:	4622      	mov	r2, r4
 8016f72:	2310      	movs	r3, #16
 8016f74:	f7ff fd00 	bl	8016978 <print_number>
 8016f78:	62b8      	str	r0, [r7, #40]	; 0x28
#else
            str = print_number(str, end,
                               (long)va_arg(args, void *),
                               16, field_width, flags);
#endif
            continue;
 8016f7a:	e070      	b.n	801705e <rt_vsnprintf+0x512>

        case '%':
            if (str <= end) *str = '%';
 8016f7c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016f7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016f80:	429a      	cmp	r2, r3
 8016f82:	d802      	bhi.n	8016f8a <rt_vsnprintf+0x43e>
 8016f84:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016f86:	2225      	movs	r2, #37	; 0x25
 8016f88:	701a      	strb	r2, [r3, #0]
            ++ str;
 8016f8a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016f8c:	3301      	adds	r3, #1
 8016f8e:	62bb      	str	r3, [r7, #40]	; 0x28
            continue;
 8016f90:	e065      	b.n	801705e <rt_vsnprintf+0x512>

            /* integer number formats - set up the flags and "break" */
        case 'o':
            base = 8;
 8016f92:	2308      	movs	r3, #8
 8016f94:	77fb      	strb	r3, [r7, #31]
            break;
 8016f96:	e02a      	b.n	8016fee <rt_vsnprintf+0x4a2>

        case 'X':
            flags |= LARGE;
 8016f98:	7fbb      	ldrb	r3, [r7, #30]
 8016f9a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8016f9e:	77bb      	strb	r3, [r7, #30]
        case 'x':
            base = 16;
 8016fa0:	2310      	movs	r3, #16
 8016fa2:	77fb      	strb	r3, [r7, #31]
            break;
 8016fa4:	e023      	b.n	8016fee <rt_vsnprintf+0x4a2>

        case 'd':
        case 'i':
            flags |= SIGN;
 8016fa6:	7fbb      	ldrb	r3, [r7, #30]
 8016fa8:	f043 0302 	orr.w	r3, r3, #2
 8016fac:	77bb      	strb	r3, [r7, #30]
        case 'u':
            break;
 8016fae:	e01d      	b.n	8016fec <rt_vsnprintf+0x4a0>

        default:
            if (str <= end) *str = '%';
 8016fb0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016fb2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016fb4:	429a      	cmp	r2, r3
 8016fb6:	d802      	bhi.n	8016fbe <rt_vsnprintf+0x472>
 8016fb8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016fba:	2225      	movs	r2, #37	; 0x25
 8016fbc:	701a      	strb	r2, [r3, #0]
            ++ str;
 8016fbe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016fc0:	3301      	adds	r3, #1
 8016fc2:	62bb      	str	r3, [r7, #40]	; 0x28

            if (*fmt)
 8016fc4:	687b      	ldr	r3, [r7, #4]
 8016fc6:	781b      	ldrb	r3, [r3, #0]
 8016fc8:	2b00      	cmp	r3, #0
 8016fca:	d00b      	beq.n	8016fe4 <rt_vsnprintf+0x498>
            {
                if (str <= end) *str = *fmt;
 8016fcc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016fce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016fd0:	429a      	cmp	r2, r3
 8016fd2:	d803      	bhi.n	8016fdc <rt_vsnprintf+0x490>
 8016fd4:	687b      	ldr	r3, [r7, #4]
 8016fd6:	781a      	ldrb	r2, [r3, #0]
 8016fd8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016fda:	701a      	strb	r2, [r3, #0]
                ++ str;
 8016fdc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016fde:	3301      	adds	r3, #1
 8016fe0:	62bb      	str	r3, [r7, #40]	; 0x28
            }
            else
            {
                -- fmt;
            }
            continue;
 8016fe2:	e03c      	b.n	801705e <rt_vsnprintf+0x512>
                if (str <= end) *str = *fmt;
                ++ str;
            }
            else
            {
                -- fmt;
 8016fe4:	687b      	ldr	r3, [r7, #4]
 8016fe6:	3b01      	subs	r3, #1
 8016fe8:	607b      	str	r3, [r7, #4]
            }
            continue;
 8016fea:	e038      	b.n	801705e <rt_vsnprintf+0x512>

        case 'd':
        case 'i':
            flags |= SIGN;
        case 'u':
            break;
 8016fec:	bf00      	nop

#ifdef RT_PRINTF_LONGLONG
        if (qualifier == 'L') num = va_arg(args, long long);
        else if (qualifier == 'l')
#else
        if (qualifier == 'l')
 8016fee:	7f7b      	ldrb	r3, [r7, #29]
 8016ff0:	2b6c      	cmp	r3, #108	; 0x6c
 8016ff2:	d109      	bne.n	8017008 <rt_vsnprintf+0x4bc>
#endif
        {
            num = va_arg(args, rt_uint32_t);
 8016ff4:	683b      	ldr	r3, [r7, #0]
 8016ff6:	1d1a      	adds	r2, r3, #4
 8016ff8:	603a      	str	r2, [r7, #0]
 8016ffa:	681b      	ldr	r3, [r3, #0]
 8016ffc:	637b      	str	r3, [r7, #52]	; 0x34
            if (flags & SIGN) num = (rt_int32_t)num;
 8016ffe:	7fbb      	ldrb	r3, [r7, #30]
 8017000:	f003 0302 	and.w	r3, r3, #2
 8017004:	2b00      	cmp	r3, #0
 8017006:	e01b      	b.n	8017040 <rt_vsnprintf+0x4f4>
        }
        else if (qualifier == 'h')
 8017008:	7f7b      	ldrb	r3, [r7, #29]
 801700a:	2b68      	cmp	r3, #104	; 0x68
 801700c:	d10f      	bne.n	801702e <rt_vsnprintf+0x4e2>
        {
            num = (rt_uint16_t)va_arg(args, rt_int32_t);
 801700e:	683b      	ldr	r3, [r7, #0]
 8017010:	1d1a      	adds	r2, r3, #4
 8017012:	603a      	str	r2, [r7, #0]
 8017014:	681b      	ldr	r3, [r3, #0]
 8017016:	b29b      	uxth	r3, r3
 8017018:	637b      	str	r3, [r7, #52]	; 0x34
            if (flags & SIGN) num = (rt_int16_t)num;
 801701a:	7fbb      	ldrb	r3, [r7, #30]
 801701c:	f003 0302 	and.w	r3, r3, #2
 8017020:	2b00      	cmp	r3, #0
 8017022:	d00d      	beq.n	8017040 <rt_vsnprintf+0x4f4>
 8017024:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017026:	b29b      	uxth	r3, r3
 8017028:	b21b      	sxth	r3, r3
 801702a:	637b      	str	r3, [r7, #52]	; 0x34
 801702c:	e008      	b.n	8017040 <rt_vsnprintf+0x4f4>
        }
        else
        {
            num = va_arg(args, rt_uint32_t);
 801702e:	683b      	ldr	r3, [r7, #0]
 8017030:	1d1a      	adds	r2, r3, #4
 8017032:	603a      	str	r2, [r7, #0]
 8017034:	681b      	ldr	r3, [r3, #0]
 8017036:	637b      	str	r3, [r7, #52]	; 0x34
            if (flags & SIGN) num = (rt_int32_t)num;
 8017038:	7fbb      	ldrb	r3, [r7, #30]
 801703a:	f003 0302 	and.w	r3, r3, #2
 801703e:	2b00      	cmp	r3, #0
        }
#ifdef RT_PRINTF_PRECISION
        str = print_number(str, end, num, base, field_width, precision, flags);
 8017040:	6b7d      	ldr	r5, [r7, #52]	; 0x34
 8017042:	7ffc      	ldrb	r4, [r7, #31]
 8017044:	7fbb      	ldrb	r3, [r7, #30]
 8017046:	69ba      	ldr	r2, [r7, #24]
 8017048:	9200      	str	r2, [sp, #0]
 801704a:	697a      	ldr	r2, [r7, #20]
 801704c:	9201      	str	r2, [sp, #4]
 801704e:	9302      	str	r3, [sp, #8]
 8017050:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8017052:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8017054:	462a      	mov	r2, r5
 8017056:	4623      	mov	r3, r4
 8017058:	f7ff fc8e 	bl	8016978 <print_number>
 801705c:	62b8      	str	r0, [r7, #40]	; 0x28
    {
        end  = ((char *)-1);
        size = end - buf;
    }

    for (; *fmt ; ++fmt)
 801705e:	687b      	ldr	r3, [r7, #4]
 8017060:	3301      	adds	r3, #1
 8017062:	607b      	str	r3, [r7, #4]
 8017064:	687b      	ldr	r3, [r7, #4]
 8017066:	781b      	ldrb	r3, [r3, #0]
 8017068:	2b00      	cmp	r3, #0
 801706a:	f47f ad89 	bne.w	8016b80 <rt_vsnprintf+0x34>
#else
        str = print_number(str, end, num, base, field_width, flags);
#endif
    }

    if (str <= end) *str = '\0';
 801706e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8017070:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017072:	429a      	cmp	r2, r3
 8017074:	d803      	bhi.n	801707e <rt_vsnprintf+0x532>
 8017076:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017078:	2200      	movs	r2, #0
 801707a:	701a      	strb	r2, [r3, #0]
 801707c:	e002      	b.n	8017084 <rt_vsnprintf+0x538>
    else *end = '\0';
 801707e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017080:	2200      	movs	r2, #0
 8017082:	701a      	strb	r2, [r3, #0]

    /* the trailing null byte doesn't count towards the total
    * ++str;
    */
    return str - buf;
 8017084:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8017086:	68fb      	ldr	r3, [r7, #12]
 8017088:	1ad3      	subs	r3, r2, r3
}
 801708a:	4618      	mov	r0, r3
 801708c:	3738      	adds	r7, #56	; 0x38
 801708e:	46bd      	mov	sp, r7
 8017090:	bdb0      	pop	{r4, r5, r7, pc}
 8017092:	bf00      	nop
 8017094:	08028f60 	.word	0x08028f60

08017098 <rt_console_get_device>:
 * This function returns the device using in console.
 *
 * @return the device using in console or RT_NULL
 */
rt_device_t rt_console_get_device(void)
{
 8017098:	b480      	push	{r7}
 801709a:	af00      	add	r7, sp, #0
    return _console_device;
 801709c:	4b03      	ldr	r3, [pc, #12]	; (80170ac <rt_console_get_device+0x14>)
 801709e:	681b      	ldr	r3, [r3, #0]
}
 80170a0:	4618      	mov	r0, r3
 80170a2:	46bd      	mov	sp, r7
 80170a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80170a8:	4770      	bx	lr
 80170aa:	bf00      	nop
 80170ac:	20010cf8 	.word	0x20010cf8

080170b0 <rt_console_set_device>:
 * @param name the name of new console device
 *
 * @return the old console device handler
 */
rt_device_t rt_console_set_device(const char *name)
{
 80170b0:	b580      	push	{r7, lr}
 80170b2:	b084      	sub	sp, #16
 80170b4:	af00      	add	r7, sp, #0
 80170b6:	6078      	str	r0, [r7, #4]
    rt_device_t new, old;

    /* save old device */
    old = _console_device;
 80170b8:	4b0f      	ldr	r3, [pc, #60]	; (80170f8 <rt_console_set_device+0x48>)
 80170ba:	681b      	ldr	r3, [r3, #0]
 80170bc:	60fb      	str	r3, [r7, #12]

    /* find new console device */
    new = rt_device_find(name);
 80170be:	6878      	ldr	r0, [r7, #4]
 80170c0:	f7fe f998 	bl	80153f4 <rt_device_find>
 80170c4:	60b8      	str	r0, [r7, #8]
    if (new != RT_NULL)
 80170c6:	68bb      	ldr	r3, [r7, #8]
 80170c8:	2b00      	cmp	r3, #0
 80170ca:	d00f      	beq.n	80170ec <rt_console_set_device+0x3c>
    {
        if (_console_device != RT_NULL)
 80170cc:	4b0a      	ldr	r3, [pc, #40]	; (80170f8 <rt_console_set_device+0x48>)
 80170ce:	681b      	ldr	r3, [r3, #0]
 80170d0:	2b00      	cmp	r3, #0
 80170d2:	d004      	beq.n	80170de <rt_console_set_device+0x2e>
        {
            /* close old console device */
            rt_device_close(_console_device);
 80170d4:	4b08      	ldr	r3, [pc, #32]	; (80170f8 <rt_console_set_device+0x48>)
 80170d6:	681b      	ldr	r3, [r3, #0]
 80170d8:	4618      	mov	r0, r3
 80170da:	f7fe fa3b 	bl	8015554 <rt_device_close>
        }

        /* set new console device */
        rt_device_open(new, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);
 80170de:	68b8      	ldr	r0, [r7, #8]
 80170e0:	2143      	movs	r1, #67	; 0x43
 80170e2:	f7fe f9c3 	bl	801546c <rt_device_open>
        _console_device = new;
 80170e6:	4a04      	ldr	r2, [pc, #16]	; (80170f8 <rt_console_set_device+0x48>)
 80170e8:	68bb      	ldr	r3, [r7, #8]
 80170ea:	6013      	str	r3, [r2, #0]
    }

    return old;
 80170ec:	68fb      	ldr	r3, [r7, #12]
}
 80170ee:	4618      	mov	r0, r3
 80170f0:	3710      	adds	r7, #16
 80170f2:	46bd      	mov	sp, r7
 80170f4:	bd80      	pop	{r7, pc}
 80170f6:	bf00      	nop
 80170f8:	20010cf8 	.word	0x20010cf8

080170fc <rt_hw_console_output>:
RTM_EXPORT(rt_console_set_device);
#endif

WEAK void rt_hw_console_output(const char *str)
{
 80170fc:	b480      	push	{r7}
 80170fe:	b083      	sub	sp, #12
 8017100:	af00      	add	r7, sp, #0
 8017102:	6078      	str	r0, [r7, #4]
    /* empty console output */
}
 8017104:	370c      	adds	r7, #12
 8017106:	46bd      	mov	sp, r7
 8017108:	f85d 7b04 	ldr.w	r7, [sp], #4
 801710c:	4770      	bx	lr
 801710e:	bf00      	nop

08017110 <rt_kprintf>:
 * This function will print a formatted string on system console
 *
 * @param fmt the format
 */
void rt_kprintf(const char *fmt, ...)
{
 8017110:	b40f      	push	{r0, r1, r2, r3}
 8017112:	b580      	push	{r7, lr}
 8017114:	b084      	sub	sp, #16
 8017116:	af00      	add	r7, sp, #0
    va_list args;
    rt_size_t length;
    static char rt_log_buf[RT_CONSOLEBUF_SIZE];

    va_start(args, fmt);
 8017118:	f107 031c 	add.w	r3, r7, #28
 801711c:	607b      	str	r3, [r7, #4]
    /* the return value of vsnprintf is the number of bytes that would be
     * written to buffer had if the size of the buffer been sufficiently
     * large excluding the terminating null byte. If the output string
     * would be larger than the rt_log_buf, we have to adjust the output
     * length. */
    length = rt_vsnprintf(rt_log_buf, sizeof(rt_log_buf) - 1, fmt, args);
 801711e:	481a      	ldr	r0, [pc, #104]	; (8017188 <rt_kprintf+0x78>)
 8017120:	217f      	movs	r1, #127	; 0x7f
 8017122:	69ba      	ldr	r2, [r7, #24]
 8017124:	687b      	ldr	r3, [r7, #4]
 8017126:	f7ff fd11 	bl	8016b4c <rt_vsnprintf>
 801712a:	4603      	mov	r3, r0
 801712c:	60fb      	str	r3, [r7, #12]
    if (length > RT_CONSOLEBUF_SIZE - 1)
 801712e:	68fb      	ldr	r3, [r7, #12]
 8017130:	2b7f      	cmp	r3, #127	; 0x7f
 8017132:	d901      	bls.n	8017138 <rt_kprintf+0x28>
        length = RT_CONSOLEBUF_SIZE - 1;
 8017134:	237f      	movs	r3, #127	; 0x7f
 8017136:	60fb      	str	r3, [r7, #12]
#ifdef RT_USING_DEVICE
    if (_console_device == RT_NULL)
 8017138:	4b14      	ldr	r3, [pc, #80]	; (801718c <rt_kprintf+0x7c>)
 801713a:	681b      	ldr	r3, [r3, #0]
 801713c:	2b00      	cmp	r3, #0
 801713e:	d103      	bne.n	8017148 <rt_kprintf+0x38>
    {
        rt_hw_console_output(rt_log_buf);
 8017140:	4811      	ldr	r0, [pc, #68]	; (8017188 <rt_kprintf+0x78>)
 8017142:	f7ff ffdb 	bl	80170fc <rt_hw_console_output>
 8017146:	e018      	b.n	801717a <rt_kprintf+0x6a>
    }
    else
    {
        rt_uint16_t old_flag = _console_device->open_flag;
 8017148:	4b10      	ldr	r3, [pc, #64]	; (801718c <rt_kprintf+0x7c>)
 801714a:	681b      	ldr	r3, [r3, #0]
 801714c:	8b1b      	ldrh	r3, [r3, #24]
 801714e:	817b      	strh	r3, [r7, #10]

        _console_device->open_flag |= RT_DEVICE_FLAG_STREAM;
 8017150:	4b0e      	ldr	r3, [pc, #56]	; (801718c <rt_kprintf+0x7c>)
 8017152:	681b      	ldr	r3, [r3, #0]
 8017154:	4a0d      	ldr	r2, [pc, #52]	; (801718c <rt_kprintf+0x7c>)
 8017156:	6812      	ldr	r2, [r2, #0]
 8017158:	8b12      	ldrh	r2, [r2, #24]
 801715a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 801715e:	b292      	uxth	r2, r2
 8017160:	831a      	strh	r2, [r3, #24]
        rt_device_write(_console_device, 0, rt_log_buf, length);
 8017162:	4b0a      	ldr	r3, [pc, #40]	; (801718c <rt_kprintf+0x7c>)
 8017164:	681b      	ldr	r3, [r3, #0]
 8017166:	4618      	mov	r0, r3
 8017168:	2100      	movs	r1, #0
 801716a:	4a07      	ldr	r2, [pc, #28]	; (8017188 <rt_kprintf+0x78>)
 801716c:	68fb      	ldr	r3, [r7, #12]
 801716e:	f7fe fa63 	bl	8015638 <rt_device_write>
        _console_device->open_flag = old_flag;
 8017172:	4b06      	ldr	r3, [pc, #24]	; (801718c <rt_kprintf+0x7c>)
 8017174:	681b      	ldr	r3, [r3, #0]
 8017176:	897a      	ldrh	r2, [r7, #10]
 8017178:	831a      	strh	r2, [r3, #24]
    }
#else
    rt_hw_console_output(rt_log_buf);
#endif
    va_end(args);
}
 801717a:	3710      	adds	r7, #16
 801717c:	46bd      	mov	sp, r7
 801717e:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8017182:	b004      	add	sp, #16
 8017184:	4770      	bx	lr
 8017186:	bf00      	nop
 8017188:	20010cfc 	.word	0x20010cfc
 801718c:	20010cf8 	.word	0x20010cf8

08017190 <__rt_ffs>:
 *
 * @return return the index of the first bit set. If value is 0, then this function
 * shall return 0.
 */
int __rt_ffs(int value)
{
 8017190:	b480      	push	{r7}
 8017192:	b083      	sub	sp, #12
 8017194:	af00      	add	r7, sp, #0
 8017196:	6078      	str	r0, [r7, #4]
    if (value == 0) return 0;
 8017198:	687b      	ldr	r3, [r7, #4]
 801719a:	2b00      	cmp	r3, #0
 801719c:	d101      	bne.n	80171a2 <__rt_ffs+0x12>
 801719e:	2300      	movs	r3, #0
 80171a0:	e028      	b.n	80171f4 <__rt_ffs+0x64>

    if (value & 0xff)
 80171a2:	687b      	ldr	r3, [r7, #4]
 80171a4:	b2db      	uxtb	r3, r3
 80171a6:	2b00      	cmp	r3, #0
 80171a8:	d005      	beq.n	80171b6 <__rt_ffs+0x26>
        return __lowest_bit_bitmap[value & 0xff] + 1;
 80171aa:	687b      	ldr	r3, [r7, #4]
 80171ac:	b2db      	uxtb	r3, r3
 80171ae:	4a14      	ldr	r2, [pc, #80]	; (8017200 <__rt_ffs+0x70>)
 80171b0:	5cd3      	ldrb	r3, [r2, r3]
 80171b2:	3301      	adds	r3, #1
 80171b4:	e01e      	b.n	80171f4 <__rt_ffs+0x64>

    if (value & 0xff00)
 80171b6:	687b      	ldr	r3, [r7, #4]
 80171b8:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 80171bc:	2b00      	cmp	r3, #0
 80171be:	d007      	beq.n	80171d0 <__rt_ffs+0x40>
        return __lowest_bit_bitmap[(value & 0xff00) >> 8] + 9;
 80171c0:	687b      	ldr	r3, [r7, #4]
 80171c2:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 80171c6:	121b      	asrs	r3, r3, #8
 80171c8:	4a0d      	ldr	r2, [pc, #52]	; (8017200 <__rt_ffs+0x70>)
 80171ca:	5cd3      	ldrb	r3, [r2, r3]
 80171cc:	3309      	adds	r3, #9
 80171ce:	e011      	b.n	80171f4 <__rt_ffs+0x64>

    if (value & 0xff0000)
 80171d0:	687b      	ldr	r3, [r7, #4]
 80171d2:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 80171d6:	2b00      	cmp	r3, #0
 80171d8:	d007      	beq.n	80171ea <__rt_ffs+0x5a>
        return __lowest_bit_bitmap[(value & 0xff0000) >> 16] + 17;
 80171da:	687b      	ldr	r3, [r7, #4]
 80171dc:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 80171e0:	141b      	asrs	r3, r3, #16
 80171e2:	4a07      	ldr	r2, [pc, #28]	; (8017200 <__rt_ffs+0x70>)
 80171e4:	5cd3      	ldrb	r3, [r2, r3]
 80171e6:	3311      	adds	r3, #17
 80171e8:	e004      	b.n	80171f4 <__rt_ffs+0x64>

    return __lowest_bit_bitmap[(value & 0xff000000) >> 24] + 25;
 80171ea:	687b      	ldr	r3, [r7, #4]
 80171ec:	0e1b      	lsrs	r3, r3, #24
 80171ee:	4a04      	ldr	r2, [pc, #16]	; (8017200 <__rt_ffs+0x70>)
 80171f0:	5cd3      	ldrb	r3, [r2, r3]
 80171f2:	3319      	adds	r3, #25
}
 80171f4:	4618      	mov	r0, r3
 80171f6:	370c      	adds	r7, #12
 80171f8:	46bd      	mov	sp, r7
 80171fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80171fe:	4770      	bx	lr
 8017200:	0802a7b0 	.word	0x0802a7b0

08017204 <rt_assert_handler>:
 * @param ex the assertion condition string
 * @param func the function name when assertion.
 * @param line the file line number when assertion.
 */
void rt_assert_handler(const char* ex_string, const char* func, rt_size_t line)
{
 8017204:	b580      	push	{r7, lr}
 8017206:	b086      	sub	sp, #24
 8017208:	af00      	add	r7, sp, #0
 801720a:	60f8      	str	r0, [r7, #12]
 801720c:	60b9      	str	r1, [r7, #8]
 801720e:	607a      	str	r2, [r7, #4]
    volatile char dummy = 0;
 8017210:	2300      	movs	r3, #0
 8017212:	75fb      	strb	r3, [r7, #23]

    if (rt_assert_hook == RT_NULL)
 8017214:	4b0c      	ldr	r3, [pc, #48]	; (8017248 <rt_assert_handler+0x44>)
 8017216:	681b      	ldr	r3, [r3, #0]
 8017218:	2b00      	cmp	r3, #0
 801721a:	d10b      	bne.n	8017234 <rt_assert_handler+0x30>
			rt_schedule();
		}
		else
#endif
		{
	        rt_kprintf("(%s) assertion failed at function:%s, line number:%d \n", ex_string, func, line);
 801721c:	480b      	ldr	r0, [pc, #44]	; (801724c <rt_assert_handler+0x48>)
 801721e:	68f9      	ldr	r1, [r7, #12]
 8017220:	68ba      	ldr	r2, [r7, #8]
 8017222:	687b      	ldr	r3, [r7, #4]
 8017224:	f7ff ff74 	bl	8017110 <rt_kprintf>
	        while (dummy == 0);
 8017228:	bf00      	nop
 801722a:	7dfb      	ldrb	r3, [r7, #23]
 801722c:	b2db      	uxtb	r3, r3
 801722e:	2b00      	cmp	r3, #0
 8017230:	d0fb      	beq.n	801722a <rt_assert_handler+0x26>
 8017232:	e005      	b.n	8017240 <rt_assert_handler+0x3c>
		}
    }
	else
	{
        rt_assert_hook(ex_string, func, line);
 8017234:	4b04      	ldr	r3, [pc, #16]	; (8017248 <rt_assert_handler+0x44>)
 8017236:	681b      	ldr	r3, [r3, #0]
 8017238:	68f8      	ldr	r0, [r7, #12]
 801723a:	68b9      	ldr	r1, [r7, #8]
 801723c:	687a      	ldr	r2, [r7, #4]
 801723e:	4798      	blx	r3
    }                                                                     
}
 8017240:	3718      	adds	r7, #24
 8017242:	46bd      	mov	sp, r7
 8017244:	bd80      	pop	{r7, pc}
 8017246:	bf00      	nop
 8017248:	20012a60 	.word	0x20012a60
 801724c:	08028f68 	.word	0x08028f68

08017250 <plug_holes>:
#ifdef RT_MEM_STATS
static rt_size_t used_mem, max_mem;
#endif

static void plug_holes(struct heap_mem *mem)
{
 8017250:	b580      	push	{r7, lr}
 8017252:	b084      	sub	sp, #16
 8017254:	af00      	add	r7, sp, #0
 8017256:	6078      	str	r0, [r7, #4]
    struct heap_mem *nmem;
    struct heap_mem *pmem;

    RT_ASSERT((rt_uint8_t *)mem >= heap_ptr);
 8017258:	4b36      	ldr	r3, [pc, #216]	; (8017334 <plug_holes+0xe4>)
 801725a:	681b      	ldr	r3, [r3, #0]
 801725c:	687a      	ldr	r2, [r7, #4]
 801725e:	429a      	cmp	r2, r3
 8017260:	d204      	bcs.n	801726c <plug_holes+0x1c>
 8017262:	4835      	ldr	r0, [pc, #212]	; (8017338 <plug_holes+0xe8>)
 8017264:	4935      	ldr	r1, [pc, #212]	; (801733c <plug_holes+0xec>)
 8017266:	228d      	movs	r2, #141	; 0x8d
 8017268:	f7ff ffcc 	bl	8017204 <rt_assert_handler>
    RT_ASSERT((rt_uint8_t *)mem < (rt_uint8_t *)heap_end);
 801726c:	4b34      	ldr	r3, [pc, #208]	; (8017340 <plug_holes+0xf0>)
 801726e:	681b      	ldr	r3, [r3, #0]
 8017270:	687a      	ldr	r2, [r7, #4]
 8017272:	429a      	cmp	r2, r3
 8017274:	d304      	bcc.n	8017280 <plug_holes+0x30>
 8017276:	4833      	ldr	r0, [pc, #204]	; (8017344 <plug_holes+0xf4>)
 8017278:	4930      	ldr	r1, [pc, #192]	; (801733c <plug_holes+0xec>)
 801727a:	228e      	movs	r2, #142	; 0x8e
 801727c:	f7ff ffc2 	bl	8017204 <rt_assert_handler>
    RT_ASSERT(mem->used == 0);
 8017280:	687b      	ldr	r3, [r7, #4]
 8017282:	885b      	ldrh	r3, [r3, #2]
 8017284:	2b00      	cmp	r3, #0
 8017286:	d004      	beq.n	8017292 <plug_holes+0x42>
 8017288:	482f      	ldr	r0, [pc, #188]	; (8017348 <plug_holes+0xf8>)
 801728a:	492c      	ldr	r1, [pc, #176]	; (801733c <plug_holes+0xec>)
 801728c:	228f      	movs	r2, #143	; 0x8f
 801728e:	f7ff ffb9 	bl	8017204 <rt_assert_handler>

    /* plug hole forward */
    nmem = (struct heap_mem *)&heap_ptr[mem->next];
 8017292:	4b28      	ldr	r3, [pc, #160]	; (8017334 <plug_holes+0xe4>)
 8017294:	681a      	ldr	r2, [r3, #0]
 8017296:	687b      	ldr	r3, [r7, #4]
 8017298:	685b      	ldr	r3, [r3, #4]
 801729a:	4413      	add	r3, r2
 801729c:	60fb      	str	r3, [r7, #12]
    if (mem != nmem &&
 801729e:	687a      	ldr	r2, [r7, #4]
 80172a0:	68fb      	ldr	r3, [r7, #12]
 80172a2:	429a      	cmp	r2, r3
 80172a4:	d01e      	beq.n	80172e4 <plug_holes+0x94>
        nmem->used == 0 &&
 80172a6:	68fb      	ldr	r3, [r7, #12]
 80172a8:	885b      	ldrh	r3, [r3, #2]
    RT_ASSERT((rt_uint8_t *)mem < (rt_uint8_t *)heap_end);
    RT_ASSERT(mem->used == 0);

    /* plug hole forward */
    nmem = (struct heap_mem *)&heap_ptr[mem->next];
    if (mem != nmem &&
 80172aa:	2b00      	cmp	r3, #0
 80172ac:	d11a      	bne.n	80172e4 <plug_holes+0x94>
        nmem->used == 0 &&
        (rt_uint8_t *)nmem != (rt_uint8_t *)heap_end)
 80172ae:	4b24      	ldr	r3, [pc, #144]	; (8017340 <plug_holes+0xf0>)
 80172b0:	681b      	ldr	r3, [r3, #0]
    RT_ASSERT(mem->used == 0);

    /* plug hole forward */
    nmem = (struct heap_mem *)&heap_ptr[mem->next];
    if (mem != nmem &&
        nmem->used == 0 &&
 80172b2:	68fa      	ldr	r2, [r7, #12]
 80172b4:	429a      	cmp	r2, r3
 80172b6:	d015      	beq.n	80172e4 <plug_holes+0x94>
        (rt_uint8_t *)nmem != (rt_uint8_t *)heap_end)
    {
        /* if mem->next is unused and not end of heap_ptr,
         * combine mem and mem->next
         */
        if (lfree == nmem)
 80172b8:	4b24      	ldr	r3, [pc, #144]	; (801734c <plug_holes+0xfc>)
 80172ba:	681a      	ldr	r2, [r3, #0]
 80172bc:	68fb      	ldr	r3, [r7, #12]
 80172be:	429a      	cmp	r2, r3
 80172c0:	d102      	bne.n	80172c8 <plug_holes+0x78>
        {
            lfree = mem;
 80172c2:	4a22      	ldr	r2, [pc, #136]	; (801734c <plug_holes+0xfc>)
 80172c4:	687b      	ldr	r3, [r7, #4]
 80172c6:	6013      	str	r3, [r2, #0]
        }
        mem->next = nmem->next;
 80172c8:	68fb      	ldr	r3, [r7, #12]
 80172ca:	685a      	ldr	r2, [r3, #4]
 80172cc:	687b      	ldr	r3, [r7, #4]
 80172ce:	605a      	str	r2, [r3, #4]
        ((struct heap_mem *)&heap_ptr[nmem->next])->prev = (rt_uint8_t *)mem - heap_ptr;
 80172d0:	4b18      	ldr	r3, [pc, #96]	; (8017334 <plug_holes+0xe4>)
 80172d2:	681a      	ldr	r2, [r3, #0]
 80172d4:	68fb      	ldr	r3, [r7, #12]
 80172d6:	685b      	ldr	r3, [r3, #4]
 80172d8:	4413      	add	r3, r2
 80172da:	687a      	ldr	r2, [r7, #4]
 80172dc:	4915      	ldr	r1, [pc, #84]	; (8017334 <plug_holes+0xe4>)
 80172de:	6809      	ldr	r1, [r1, #0]
 80172e0:	1a52      	subs	r2, r2, r1
 80172e2:	609a      	str	r2, [r3, #8]
    }

    /* plug hole backward */
    pmem = (struct heap_mem *)&heap_ptr[mem->prev];
 80172e4:	4b13      	ldr	r3, [pc, #76]	; (8017334 <plug_holes+0xe4>)
 80172e6:	681a      	ldr	r2, [r3, #0]
 80172e8:	687b      	ldr	r3, [r7, #4]
 80172ea:	689b      	ldr	r3, [r3, #8]
 80172ec:	4413      	add	r3, r2
 80172ee:	60bb      	str	r3, [r7, #8]
    if (pmem != mem && pmem->used == 0)
 80172f0:	68ba      	ldr	r2, [r7, #8]
 80172f2:	687b      	ldr	r3, [r7, #4]
 80172f4:	429a      	cmp	r2, r3
 80172f6:	d019      	beq.n	801732c <plug_holes+0xdc>
 80172f8:	68bb      	ldr	r3, [r7, #8]
 80172fa:	885b      	ldrh	r3, [r3, #2]
 80172fc:	2b00      	cmp	r3, #0
 80172fe:	d115      	bne.n	801732c <plug_holes+0xdc>
    {
        /* if mem->prev is unused, combine mem and mem->prev */
        if (lfree == mem)
 8017300:	4b12      	ldr	r3, [pc, #72]	; (801734c <plug_holes+0xfc>)
 8017302:	681a      	ldr	r2, [r3, #0]
 8017304:	687b      	ldr	r3, [r7, #4]
 8017306:	429a      	cmp	r2, r3
 8017308:	d102      	bne.n	8017310 <plug_holes+0xc0>
        {
            lfree = pmem;
 801730a:	4a10      	ldr	r2, [pc, #64]	; (801734c <plug_holes+0xfc>)
 801730c:	68bb      	ldr	r3, [r7, #8]
 801730e:	6013      	str	r3, [r2, #0]
        }
        pmem->next = mem->next;
 8017310:	687b      	ldr	r3, [r7, #4]
 8017312:	685a      	ldr	r2, [r3, #4]
 8017314:	68bb      	ldr	r3, [r7, #8]
 8017316:	605a      	str	r2, [r3, #4]
        ((struct heap_mem *)&heap_ptr[mem->next])->prev = (rt_uint8_t *)pmem - heap_ptr;
 8017318:	4b06      	ldr	r3, [pc, #24]	; (8017334 <plug_holes+0xe4>)
 801731a:	681a      	ldr	r2, [r3, #0]
 801731c:	687b      	ldr	r3, [r7, #4]
 801731e:	685b      	ldr	r3, [r3, #4]
 8017320:	4413      	add	r3, r2
 8017322:	68ba      	ldr	r2, [r7, #8]
 8017324:	4903      	ldr	r1, [pc, #12]	; (8017334 <plug_holes+0xe4>)
 8017326:	6809      	ldr	r1, [r1, #0]
 8017328:	1a52      	subs	r2, r2, r1
 801732a:	609a      	str	r2, [r3, #8]
    }
}
 801732c:	3710      	adds	r7, #16
 801732e:	46bd      	mov	sp, r7
 8017330:	bd80      	pop	{r7, pc}
 8017332:	bf00      	nop
 8017334:	20010d84 	.word	0x20010d84
 8017338:	08028fa0 	.word	0x08028fa0
 801733c:	0802a904 	.word	0x0802a904
 8017340:	20010d88 	.word	0x20010d88
 8017344:	08028fc0 	.word	0x08028fc0
 8017348:	08028fec 	.word	0x08028fec
 801734c:	20010d8c 	.word	0x20010d8c

08017350 <rt_system_heap_init>:
 *
 * @param begin_addr the beginning address of system heap memory.
 * @param end_addr the end address of system heap memory.
 */
void rt_system_heap_init(void *begin_addr, void *end_addr)
{
 8017350:	b580      	push	{r7, lr}
 8017352:	b086      	sub	sp, #24
 8017354:	af00      	add	r7, sp, #0
 8017356:	6078      	str	r0, [r7, #4]
 8017358:	6039      	str	r1, [r7, #0]
    struct heap_mem *mem;
    rt_uint32_t begin_align = RT_ALIGN((rt_uint32_t)begin_addr, RT_ALIGN_SIZE);
 801735a:	687b      	ldr	r3, [r7, #4]
 801735c:	3303      	adds	r3, #3
 801735e:	f023 0303 	bic.w	r3, r3, #3
 8017362:	617b      	str	r3, [r7, #20]
    rt_uint32_t end_align = RT_ALIGN_DOWN((rt_uint32_t)end_addr, RT_ALIGN_SIZE);
 8017364:	683b      	ldr	r3, [r7, #0]
 8017366:	f023 0303 	bic.w	r3, r3, #3
 801736a:	613b      	str	r3, [r7, #16]

    RT_DEBUG_NOT_IN_INTERRUPT;
 801736c:	f7e8 ff2e 	bl	80001cc <rt_hw_interrupt_disable>
 8017370:	60f8      	str	r0, [r7, #12]
 8017372:	f7ff f8e9 	bl	8016548 <rt_interrupt_get_nest>
 8017376:	4603      	mov	r3, r0
 8017378:	2b00      	cmp	r3, #0
 801737a:	d008      	beq.n	801738e <rt_system_heap_init+0x3e>
 801737c:	4831      	ldr	r0, [pc, #196]	; (8017444 <rt_system_heap_init+0xf4>)
 801737e:	4932      	ldr	r1, [pc, #200]	; (8017448 <rt_system_heap_init+0xf8>)
 8017380:	f7ff fec6 	bl	8017110 <rt_kprintf>
 8017384:	4831      	ldr	r0, [pc, #196]	; (801744c <rt_system_heap_init+0xfc>)
 8017386:	4930      	ldr	r1, [pc, #192]	; (8017448 <rt_system_heap_init+0xf8>)
 8017388:	22be      	movs	r2, #190	; 0xbe
 801738a:	f7ff ff3b 	bl	8017204 <rt_assert_handler>
 801738e:	68f8      	ldr	r0, [r7, #12]
 8017390:	f7e8 ff20 	bl	80001d4 <rt_hw_interrupt_enable>

    /* alignment addr */
    if ((end_align > (2 * SIZEOF_STRUCT_MEM)) &&
 8017394:	693b      	ldr	r3, [r7, #16]
 8017396:	2b18      	cmp	r3, #24
 8017398:	d948      	bls.n	801742c <rt_system_heap_init+0xdc>
        ((end_align - 2 * SIZEOF_STRUCT_MEM) >= begin_align))
 801739a:	693b      	ldr	r3, [r7, #16]
 801739c:	f1a3 0218 	sub.w	r2, r3, #24
    rt_uint32_t end_align = RT_ALIGN_DOWN((rt_uint32_t)end_addr, RT_ALIGN_SIZE);

    RT_DEBUG_NOT_IN_INTERRUPT;

    /* alignment addr */
    if ((end_align > (2 * SIZEOF_STRUCT_MEM)) &&
 80173a0:	697b      	ldr	r3, [r7, #20]
 80173a2:	429a      	cmp	r2, r3
 80173a4:	d342      	bcc.n	801742c <rt_system_heap_init+0xdc>
        ((end_align - 2 * SIZEOF_STRUCT_MEM) >= begin_align))
    {
        /* calculate the aligned memory size */
        mem_size_aligned = end_align - begin_align - 2 * SIZEOF_STRUCT_MEM;
 80173a6:	693a      	ldr	r2, [r7, #16]
 80173a8:	697b      	ldr	r3, [r7, #20]
 80173aa:	1ad3      	subs	r3, r2, r3
 80173ac:	3b18      	subs	r3, #24
 80173ae:	4a28      	ldr	r2, [pc, #160]	; (8017450 <rt_system_heap_init+0x100>)
 80173b0:	6013      	str	r3, [r2, #0]

        return;
    }

    /* point to begin address of heap */
    heap_ptr = (rt_uint8_t *)begin_align;
 80173b2:	697b      	ldr	r3, [r7, #20]
 80173b4:	4a27      	ldr	r2, [pc, #156]	; (8017454 <rt_system_heap_init+0x104>)
 80173b6:	6013      	str	r3, [r2, #0]

    RT_DEBUG_LOG(RT_DEBUG_MEM, ("mem init, heap begin address 0x%x, size %d\n",
                                (rt_uint32_t)heap_ptr, mem_size_aligned));

    /* initialize the start of the heap */
    mem        = (struct heap_mem *)heap_ptr;
 80173b8:	4b26      	ldr	r3, [pc, #152]	; (8017454 <rt_system_heap_init+0x104>)
 80173ba:	681b      	ldr	r3, [r3, #0]
 80173bc:	60bb      	str	r3, [r7, #8]
    mem->magic = HEAP_MAGIC;
 80173be:	68bb      	ldr	r3, [r7, #8]
 80173c0:	f44f 52f5 	mov.w	r2, #7840	; 0x1ea0
 80173c4:	801a      	strh	r2, [r3, #0]
    mem->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
 80173c6:	4b22      	ldr	r3, [pc, #136]	; (8017450 <rt_system_heap_init+0x100>)
 80173c8:	681b      	ldr	r3, [r3, #0]
 80173ca:	f103 020c 	add.w	r2, r3, #12
 80173ce:	68bb      	ldr	r3, [r7, #8]
 80173d0:	605a      	str	r2, [r3, #4]
    mem->prev  = 0;
 80173d2:	68bb      	ldr	r3, [r7, #8]
 80173d4:	2200      	movs	r2, #0
 80173d6:	609a      	str	r2, [r3, #8]
    mem->used  = 0;
 80173d8:	68bb      	ldr	r3, [r7, #8]
 80173da:	2200      	movs	r2, #0
 80173dc:	805a      	strh	r2, [r3, #2]

    /* initialize the end of the heap */
    heap_end        = (struct heap_mem *)&heap_ptr[mem->next];
 80173de:	4b1d      	ldr	r3, [pc, #116]	; (8017454 <rt_system_heap_init+0x104>)
 80173e0:	681a      	ldr	r2, [r3, #0]
 80173e2:	68bb      	ldr	r3, [r7, #8]
 80173e4:	685b      	ldr	r3, [r3, #4]
 80173e6:	4413      	add	r3, r2
 80173e8:	4a1b      	ldr	r2, [pc, #108]	; (8017458 <rt_system_heap_init+0x108>)
 80173ea:	6013      	str	r3, [r2, #0]
    heap_end->magic = HEAP_MAGIC;
 80173ec:	4b1a      	ldr	r3, [pc, #104]	; (8017458 <rt_system_heap_init+0x108>)
 80173ee:	681b      	ldr	r3, [r3, #0]
 80173f0:	f44f 52f5 	mov.w	r2, #7840	; 0x1ea0
 80173f4:	801a      	strh	r2, [r3, #0]
    heap_end->used  = 1;
 80173f6:	4b18      	ldr	r3, [pc, #96]	; (8017458 <rt_system_heap_init+0x108>)
 80173f8:	681b      	ldr	r3, [r3, #0]
 80173fa:	2201      	movs	r2, #1
 80173fc:	805a      	strh	r2, [r3, #2]
    heap_end->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
 80173fe:	4b16      	ldr	r3, [pc, #88]	; (8017458 <rt_system_heap_init+0x108>)
 8017400:	681b      	ldr	r3, [r3, #0]
 8017402:	4a13      	ldr	r2, [pc, #76]	; (8017450 <rt_system_heap_init+0x100>)
 8017404:	6812      	ldr	r2, [r2, #0]
 8017406:	320c      	adds	r2, #12
 8017408:	605a      	str	r2, [r3, #4]
    heap_end->prev  = mem_size_aligned + SIZEOF_STRUCT_MEM;
 801740a:	4b13      	ldr	r3, [pc, #76]	; (8017458 <rt_system_heap_init+0x108>)
 801740c:	681b      	ldr	r3, [r3, #0]
 801740e:	4a10      	ldr	r2, [pc, #64]	; (8017450 <rt_system_heap_init+0x100>)
 8017410:	6812      	ldr	r2, [r2, #0]
 8017412:	320c      	adds	r2, #12
 8017414:	609a      	str	r2, [r3, #8]

    rt_sem_init(&heap_sem, "heap", 1, RT_IPC_FLAG_FIFO);
 8017416:	4811      	ldr	r0, [pc, #68]	; (801745c <rt_system_heap_init+0x10c>)
 8017418:	4911      	ldr	r1, [pc, #68]	; (8017460 <rt_system_heap_init+0x110>)
 801741a:	2201      	movs	r2, #1
 801741c:	2300      	movs	r3, #0
 801741e:	f7fe fafd 	bl	8015a1c <rt_sem_init>

    /* initialize the lowest-free pointer to the start of the heap */
    lfree = (struct heap_mem *)heap_ptr;
 8017422:	4b0c      	ldr	r3, [pc, #48]	; (8017454 <rt_system_heap_init+0x104>)
 8017424:	681b      	ldr	r3, [r3, #0]
 8017426:	4a0f      	ldr	r2, [pc, #60]	; (8017464 <rt_system_heap_init+0x114>)
 8017428:	6013      	str	r3, [r2, #0]
 801742a:	e007      	b.n	801743c <rt_system_heap_init+0xec>
        /* calculate the aligned memory size */
        mem_size_aligned = end_align - begin_align - 2 * SIZEOF_STRUCT_MEM;
    }
    else
    {
        rt_kprintf("mem init, error begin address 0x%x, and end address 0x%x\n",
 801742c:	687a      	ldr	r2, [r7, #4]
 801742e:	683b      	ldr	r3, [r7, #0]
 8017430:	480d      	ldr	r0, [pc, #52]	; (8017468 <rt_system_heap_init+0x118>)
 8017432:	4611      	mov	r1, r2
 8017434:	461a      	mov	r2, r3
 8017436:	f7ff fe6b 	bl	8017110 <rt_kprintf>
                   (rt_uint32_t)begin_addr, (rt_uint32_t)end_addr);

        return;
 801743a:	bf00      	nop

    rt_sem_init(&heap_sem, "heap", 1, RT_IPC_FLAG_FIFO);

    /* initialize the lowest-free pointer to the start of the heap */
    lfree = (struct heap_mem *)heap_ptr;
}
 801743c:	3718      	adds	r7, #24
 801743e:	46bd      	mov	sp, r7
 8017440:	bd80      	pop	{r7, pc}
 8017442:	bf00      	nop
 8017444:	08028ffc 	.word	0x08028ffc
 8017448:	0802a910 	.word	0x0802a910
 801744c:	08029020 	.word	0x08029020
 8017450:	20010db0 	.word	0x20010db0
 8017454:	20010d84 	.word	0x20010d84
 8017458:	20010d88 	.word	0x20010d88
 801745c:	20010d90 	.word	0x20010d90
 8017460:	08029060 	.word	0x08029060
 8017464:	20010d8c 	.word	0x20010d8c
 8017468:	08029024 	.word	0x08029024

0801746c <rt_malloc>:
 * @param size is the minimum size of the requested block in bytes.
 *
 * @return pointer to allocated memory or NULL if no free memory was found.
 */
void *rt_malloc(rt_size_t size)
{
 801746c:	b580      	push	{r7, lr}
 801746e:	b088      	sub	sp, #32
 8017470:	af00      	add	r7, sp, #0
 8017472:	6078      	str	r0, [r7, #4]
    rt_size_t ptr, ptr2;
    struct heap_mem *mem, *mem2;

    RT_DEBUG_NOT_IN_INTERRUPT;
 8017474:	f7e8 feaa 	bl	80001cc <rt_hw_interrupt_disable>
 8017478:	61b8      	str	r0, [r7, #24]
 801747a:	f7ff f865 	bl	8016548 <rt_interrupt_get_nest>
 801747e:	4603      	mov	r3, r0
 8017480:	2b00      	cmp	r3, #0
 8017482:	d008      	beq.n	8017496 <rt_malloc+0x2a>
 8017484:	488d      	ldr	r0, [pc, #564]	; (80176bc <rt_malloc+0x250>)
 8017486:	498e      	ldr	r1, [pc, #568]	; (80176c0 <rt_malloc+0x254>)
 8017488:	f7ff fe42 	bl	8017110 <rt_kprintf>
 801748c:	488d      	ldr	r0, [pc, #564]	; (80176c4 <rt_malloc+0x258>)
 801748e:	498c      	ldr	r1, [pc, #560]	; (80176c0 <rt_malloc+0x254>)
 8017490:	22fb      	movs	r2, #251	; 0xfb
 8017492:	f7ff feb7 	bl	8017204 <rt_assert_handler>
 8017496:	69b8      	ldr	r0, [r7, #24]
 8017498:	f7e8 fe9c 	bl	80001d4 <rt_hw_interrupt_enable>

    if (size == 0)
 801749c:	687b      	ldr	r3, [r7, #4]
 801749e:	2b00      	cmp	r3, #0
 80174a0:	d101      	bne.n	80174a6 <rt_malloc+0x3a>
        return RT_NULL;
 80174a2:	2300      	movs	r3, #0
 80174a4:	e105      	b.n	80176b2 <rt_malloc+0x246>
                                    size, RT_ALIGN(size, RT_ALIGN_SIZE)));
    else
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("malloc size %d\n", size));

    /* alignment size */
    size = RT_ALIGN(size, RT_ALIGN_SIZE);
 80174a6:	687b      	ldr	r3, [r7, #4]
 80174a8:	3303      	adds	r3, #3
 80174aa:	f023 0303 	bic.w	r3, r3, #3
 80174ae:	607b      	str	r3, [r7, #4]

    if (size > mem_size_aligned)
 80174b0:	4b85      	ldr	r3, [pc, #532]	; (80176c8 <rt_malloc+0x25c>)
 80174b2:	681b      	ldr	r3, [r3, #0]
 80174b4:	687a      	ldr	r2, [r7, #4]
 80174b6:	429a      	cmp	r2, r3
 80174b8:	d901      	bls.n	80174be <rt_malloc+0x52>
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("no memory\n"));

        return RT_NULL;
 80174ba:	2300      	movs	r3, #0
 80174bc:	e0f9      	b.n	80176b2 <rt_malloc+0x246>
    }

    /* every data block must be at least MIN_SIZE_ALIGNED long */
    if (size < MIN_SIZE_ALIGNED)
 80174be:	687b      	ldr	r3, [r7, #4]
 80174c0:	2b0b      	cmp	r3, #11
 80174c2:	d801      	bhi.n	80174c8 <rt_malloc+0x5c>
        size = MIN_SIZE_ALIGNED;
 80174c4:	230c      	movs	r3, #12
 80174c6:	607b      	str	r3, [r7, #4]

    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
 80174c8:	4880      	ldr	r0, [pc, #512]	; (80176cc <rt_malloc+0x260>)
 80174ca:	f04f 31ff 	mov.w	r1, #4294967295
 80174ce:	f7fe fb0b 	bl	8015ae8 <rt_sem_take>

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
 80174d2:	4b7f      	ldr	r3, [pc, #508]	; (80176d0 <rt_malloc+0x264>)
 80174d4:	681b      	ldr	r3, [r3, #0]
 80174d6:	461a      	mov	r2, r3
 80174d8:	4b7e      	ldr	r3, [pc, #504]	; (80176d4 <rt_malloc+0x268>)
 80174da:	681b      	ldr	r3, [r3, #0]
 80174dc:	1ad3      	subs	r3, r2, r3
 80174de:	61fb      	str	r3, [r7, #28]
 80174e0:	e0db      	b.n	801769a <rt_malloc+0x22e>
         ptr < mem_size_aligned - size;
         ptr = ((struct heap_mem *)&heap_ptr[ptr])->next)
    {
        mem = (struct heap_mem *)&heap_ptr[ptr];
 80174e2:	4b7c      	ldr	r3, [pc, #496]	; (80176d4 <rt_malloc+0x268>)
 80174e4:	681a      	ldr	r2, [r3, #0]
 80174e6:	69fb      	ldr	r3, [r7, #28]
 80174e8:	4413      	add	r3, r2
 80174ea:	617b      	str	r3, [r7, #20]

        if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size)
 80174ec:	697b      	ldr	r3, [r7, #20]
 80174ee:	885b      	ldrh	r3, [r3, #2]
 80174f0:	2b00      	cmp	r3, #0
 80174f2:	f040 80cc 	bne.w	801768e <rt_malloc+0x222>
 80174f6:	697b      	ldr	r3, [r7, #20]
 80174f8:	685a      	ldr	r2, [r3, #4]
 80174fa:	69fb      	ldr	r3, [r7, #28]
 80174fc:	1ad3      	subs	r3, r2, r3
 80174fe:	f1a3 020c 	sub.w	r2, r3, #12
 8017502:	687b      	ldr	r3, [r7, #4]
 8017504:	429a      	cmp	r2, r3
 8017506:	f0c0 80c2 	bcc.w	801768e <rt_malloc+0x222>
        {
            /* mem is not used and at least perfect fit is possible:
             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >=
 801750a:	697b      	ldr	r3, [r7, #20]
 801750c:	685a      	ldr	r2, [r3, #4]
 801750e:	69fb      	ldr	r3, [r7, #28]
 8017510:	1ad3      	subs	r3, r2, r3
 8017512:	f1a3 020c 	sub.w	r2, r3, #12
                (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))
 8017516:	687b      	ldr	r3, [r7, #4]
 8017518:	3318      	adds	r3, #24
        if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size)
        {
            /* mem is not used and at least perfect fit is possible:
             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >=
 801751a:	429a      	cmp	r2, r3
 801751c:	d339      	bcc.n	8017592 <rt_malloc+0x126>
                 * struct heap_mem would fit in but no data between mem2 and mem2->next
                 * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
                 *       region that couldn't hold data, but when mem->next gets freed,
                 *       the 2 regions would be combined, resulting in more free memory
                 */
                ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 801751e:	69fa      	ldr	r2, [r7, #28]
 8017520:	687b      	ldr	r3, [r7, #4]
 8017522:	4413      	add	r3, r2
 8017524:	330c      	adds	r3, #12
 8017526:	613b      	str	r3, [r7, #16]

                /* create mem2 struct */
                mem2       = (struct heap_mem *)&heap_ptr[ptr2];
 8017528:	4b6a      	ldr	r3, [pc, #424]	; (80176d4 <rt_malloc+0x268>)
 801752a:	681a      	ldr	r2, [r3, #0]
 801752c:	693b      	ldr	r3, [r7, #16]
 801752e:	4413      	add	r3, r2
 8017530:	60fb      	str	r3, [r7, #12]
                mem2->used = 0;
 8017532:	68fb      	ldr	r3, [r7, #12]
 8017534:	2200      	movs	r2, #0
 8017536:	805a      	strh	r2, [r3, #2]
                mem2->next = mem->next;
 8017538:	697b      	ldr	r3, [r7, #20]
 801753a:	685a      	ldr	r2, [r3, #4]
 801753c:	68fb      	ldr	r3, [r7, #12]
 801753e:	605a      	str	r2, [r3, #4]
                mem2->prev = ptr;
 8017540:	68fb      	ldr	r3, [r7, #12]
 8017542:	69fa      	ldr	r2, [r7, #28]
 8017544:	609a      	str	r2, [r3, #8]

                /* and insert it between mem and mem->next */
                mem->next = ptr2;
 8017546:	697b      	ldr	r3, [r7, #20]
 8017548:	693a      	ldr	r2, [r7, #16]
 801754a:	605a      	str	r2, [r3, #4]
                mem->used = 1;
 801754c:	697b      	ldr	r3, [r7, #20]
 801754e:	2201      	movs	r2, #1
 8017550:	805a      	strh	r2, [r3, #2]

                if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
 8017552:	68fb      	ldr	r3, [r7, #12]
 8017554:	685a      	ldr	r2, [r3, #4]
 8017556:	4b5c      	ldr	r3, [pc, #368]	; (80176c8 <rt_malloc+0x25c>)
 8017558:	681b      	ldr	r3, [r3, #0]
 801755a:	330c      	adds	r3, #12
 801755c:	429a      	cmp	r2, r3
 801755e:	d006      	beq.n	801756e <rt_malloc+0x102>
                {
                    ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
 8017560:	4b5c      	ldr	r3, [pc, #368]	; (80176d4 <rt_malloc+0x268>)
 8017562:	681a      	ldr	r2, [r3, #0]
 8017564:	68fb      	ldr	r3, [r7, #12]
 8017566:	685b      	ldr	r3, [r3, #4]
 8017568:	4413      	add	r3, r2
 801756a:	693a      	ldr	r2, [r7, #16]
 801756c:	609a      	str	r2, [r3, #8]
                }
#ifdef RT_MEM_STATS
                used_mem += (size + SIZEOF_STRUCT_MEM);
 801756e:	4b5a      	ldr	r3, [pc, #360]	; (80176d8 <rt_malloc+0x26c>)
 8017570:	681a      	ldr	r2, [r3, #0]
 8017572:	687b      	ldr	r3, [r7, #4]
 8017574:	4413      	add	r3, r2
 8017576:	330c      	adds	r3, #12
 8017578:	4a57      	ldr	r2, [pc, #348]	; (80176d8 <rt_malloc+0x26c>)
 801757a:	6013      	str	r3, [r2, #0]
                if (max_mem < used_mem)
 801757c:	4b57      	ldr	r3, [pc, #348]	; (80176dc <rt_malloc+0x270>)
 801757e:	681a      	ldr	r2, [r3, #0]
 8017580:	4b55      	ldr	r3, [pc, #340]	; (80176d8 <rt_malloc+0x26c>)
 8017582:	681b      	ldr	r3, [r3, #0]
 8017584:	429a      	cmp	r2, r3
 8017586:	d21e      	bcs.n	80175c6 <rt_malloc+0x15a>
                    max_mem = used_mem;
 8017588:	4b53      	ldr	r3, [pc, #332]	; (80176d8 <rt_malloc+0x26c>)
 801758a:	681b      	ldr	r3, [r3, #0]
 801758c:	4a53      	ldr	r2, [pc, #332]	; (80176dc <rt_malloc+0x270>)
 801758e:	6013      	str	r3, [r2, #0]
 8017590:	e019      	b.n	80175c6 <rt_malloc+0x15a>
                 * take care of this).
                 * -> near fit or excact fit: do not split, no mem2 creation
                 * also can't move mem->next directly behind mem, since mem->next
                 * will always be used at this point!
                 */
                mem->used = 1;
 8017592:	697b      	ldr	r3, [r7, #20]
 8017594:	2201      	movs	r2, #1
 8017596:	805a      	strh	r2, [r3, #2]
#ifdef RT_MEM_STATS
                used_mem += mem->next - ((rt_uint8_t*)mem - heap_ptr);
 8017598:	697b      	ldr	r3, [r7, #20]
 801759a:	685b      	ldr	r3, [r3, #4]
 801759c:	4a4d      	ldr	r2, [pc, #308]	; (80176d4 <rt_malloc+0x268>)
 801759e:	6812      	ldr	r2, [r2, #0]
 80175a0:	4611      	mov	r1, r2
 80175a2:	697a      	ldr	r2, [r7, #20]
 80175a4:	1a8a      	subs	r2, r1, r2
 80175a6:	441a      	add	r2, r3
 80175a8:	4b4b      	ldr	r3, [pc, #300]	; (80176d8 <rt_malloc+0x26c>)
 80175aa:	681b      	ldr	r3, [r3, #0]
 80175ac:	4413      	add	r3, r2
 80175ae:	4a4a      	ldr	r2, [pc, #296]	; (80176d8 <rt_malloc+0x26c>)
 80175b0:	6013      	str	r3, [r2, #0]
                if (max_mem < used_mem)
 80175b2:	4b4a      	ldr	r3, [pc, #296]	; (80176dc <rt_malloc+0x270>)
 80175b4:	681a      	ldr	r2, [r3, #0]
 80175b6:	4b48      	ldr	r3, [pc, #288]	; (80176d8 <rt_malloc+0x26c>)
 80175b8:	681b      	ldr	r3, [r3, #0]
 80175ba:	429a      	cmp	r2, r3
 80175bc:	d203      	bcs.n	80175c6 <rt_malloc+0x15a>
                    max_mem = used_mem;
 80175be:	4b46      	ldr	r3, [pc, #280]	; (80176d8 <rt_malloc+0x26c>)
 80175c0:	681b      	ldr	r3, [r3, #0]
 80175c2:	4a46      	ldr	r2, [pc, #280]	; (80176dc <rt_malloc+0x270>)
 80175c4:	6013      	str	r3, [r2, #0]
#endif
            }
            /* set memory block magic */
            mem->magic = HEAP_MAGIC;
 80175c6:	697b      	ldr	r3, [r7, #20]
 80175c8:	f44f 52f5 	mov.w	r2, #7840	; 0x1ea0
 80175cc:	801a      	strh	r2, [r3, #0]

            if (mem == lfree)
 80175ce:	4b40      	ldr	r3, [pc, #256]	; (80176d0 <rt_malloc+0x264>)
 80175d0:	681b      	ldr	r3, [r3, #0]
 80175d2:	697a      	ldr	r2, [r7, #20]
 80175d4:	429a      	cmp	r2, r3
 80175d6:	d124      	bne.n	8017622 <rt_malloc+0x1b6>
            {
                /* Find next free block after mem and update lowest free pointer */
                while (lfree->used && lfree != heap_end)
 80175d8:	e007      	b.n	80175ea <rt_malloc+0x17e>
                    lfree = (struct heap_mem *)&heap_ptr[lfree->next];
 80175da:	4b3e      	ldr	r3, [pc, #248]	; (80176d4 <rt_malloc+0x268>)
 80175dc:	681a      	ldr	r2, [r3, #0]
 80175de:	4b3c      	ldr	r3, [pc, #240]	; (80176d0 <rt_malloc+0x264>)
 80175e0:	681b      	ldr	r3, [r3, #0]
 80175e2:	685b      	ldr	r3, [r3, #4]
 80175e4:	4413      	add	r3, r2
 80175e6:	4a3a      	ldr	r2, [pc, #232]	; (80176d0 <rt_malloc+0x264>)
 80175e8:	6013      	str	r3, [r2, #0]
            mem->magic = HEAP_MAGIC;

            if (mem == lfree)
            {
                /* Find next free block after mem and update lowest free pointer */
                while (lfree->used && lfree != heap_end)
 80175ea:	4b39      	ldr	r3, [pc, #228]	; (80176d0 <rt_malloc+0x264>)
 80175ec:	681b      	ldr	r3, [r3, #0]
 80175ee:	885b      	ldrh	r3, [r3, #2]
 80175f0:	2b00      	cmp	r3, #0
 80175f2:	d005      	beq.n	8017600 <rt_malloc+0x194>
 80175f4:	4b36      	ldr	r3, [pc, #216]	; (80176d0 <rt_malloc+0x264>)
 80175f6:	681a      	ldr	r2, [r3, #0]
 80175f8:	4b39      	ldr	r3, [pc, #228]	; (80176e0 <rt_malloc+0x274>)
 80175fa:	681b      	ldr	r3, [r3, #0]
 80175fc:	429a      	cmp	r2, r3
 80175fe:	d1ec      	bne.n	80175da <rt_malloc+0x16e>
                    lfree = (struct heap_mem *)&heap_ptr[lfree->next];

                RT_ASSERT(((lfree == heap_end) || (!lfree->used)));
 8017600:	4b33      	ldr	r3, [pc, #204]	; (80176d0 <rt_malloc+0x264>)
 8017602:	681a      	ldr	r2, [r3, #0]
 8017604:	4b36      	ldr	r3, [pc, #216]	; (80176e0 <rt_malloc+0x274>)
 8017606:	681b      	ldr	r3, [r3, #0]
 8017608:	429a      	cmp	r2, r3
 801760a:	d00a      	beq.n	8017622 <rt_malloc+0x1b6>
 801760c:	4b30      	ldr	r3, [pc, #192]	; (80176d0 <rt_malloc+0x264>)
 801760e:	681b      	ldr	r3, [r3, #0]
 8017610:	885b      	ldrh	r3, [r3, #2]
 8017612:	2b00      	cmp	r3, #0
 8017614:	d005      	beq.n	8017622 <rt_malloc+0x1b6>
 8017616:	4833      	ldr	r0, [pc, #204]	; (80176e4 <rt_malloc+0x278>)
 8017618:	4929      	ldr	r1, [pc, #164]	; (80176c0 <rt_malloc+0x254>)
 801761a:	f44f 72af 	mov.w	r2, #350	; 0x15e
 801761e:	f7ff fdf1 	bl	8017204 <rt_assert_handler>
            }

            rt_sem_release(&heap_sem);
 8017622:	482a      	ldr	r0, [pc, #168]	; (80176cc <rt_malloc+0x260>)
 8017624:	f7fe fb04 	bl	8015c30 <rt_sem_release>
            RT_ASSERT((rt_uint32_t)mem + SIZEOF_STRUCT_MEM + size <= (rt_uint32_t)heap_end);
 8017628:	697a      	ldr	r2, [r7, #20]
 801762a:	687b      	ldr	r3, [r7, #4]
 801762c:	4413      	add	r3, r2
 801762e:	330c      	adds	r3, #12
 8017630:	4a2b      	ldr	r2, [pc, #172]	; (80176e0 <rt_malloc+0x274>)
 8017632:	6812      	ldr	r2, [r2, #0]
 8017634:	4293      	cmp	r3, r2
 8017636:	d905      	bls.n	8017644 <rt_malloc+0x1d8>
 8017638:	482b      	ldr	r0, [pc, #172]	; (80176e8 <rt_malloc+0x27c>)
 801763a:	4921      	ldr	r1, [pc, #132]	; (80176c0 <rt_malloc+0x254>)
 801763c:	f44f 72b1 	mov.w	r2, #354	; 0x162
 8017640:	f7ff fde0 	bl	8017204 <rt_assert_handler>
            RT_ASSERT((rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM) % RT_ALIGN_SIZE == 0);
 8017644:	697b      	ldr	r3, [r7, #20]
 8017646:	330c      	adds	r3, #12
 8017648:	f003 0303 	and.w	r3, r3, #3
 801764c:	2b00      	cmp	r3, #0
 801764e:	d005      	beq.n	801765c <rt_malloc+0x1f0>
 8017650:	4826      	ldr	r0, [pc, #152]	; (80176ec <rt_malloc+0x280>)
 8017652:	491b      	ldr	r1, [pc, #108]	; (80176c0 <rt_malloc+0x254>)
 8017654:	f240 1263 	movw	r2, #355	; 0x163
 8017658:	f7ff fdd4 	bl	8017204 <rt_assert_handler>
            RT_ASSERT((((rt_uint32_t)mem) & (RT_ALIGN_SIZE-1)) == 0);
 801765c:	697b      	ldr	r3, [r7, #20]
 801765e:	f003 0303 	and.w	r3, r3, #3
 8017662:	2b00      	cmp	r3, #0
 8017664:	d005      	beq.n	8017672 <rt_malloc+0x206>
 8017666:	4822      	ldr	r0, [pc, #136]	; (80176f0 <rt_malloc+0x284>)
 8017668:	4915      	ldr	r1, [pc, #84]	; (80176c0 <rt_malloc+0x254>)
 801766a:	f44f 72b2 	mov.w	r2, #356	; 0x164
 801766e:	f7ff fdc9 	bl	8017204 <rt_assert_handler>
            RT_DEBUG_LOG(RT_DEBUG_MEM,
                         ("allocate memory at 0x%x, size: %d\n",
                          (rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM),
                          (rt_uint32_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));

            RT_OBJECT_HOOK_CALL(rt_malloc_hook,
 8017672:	4b20      	ldr	r3, [pc, #128]	; (80176f4 <rt_malloc+0x288>)
 8017674:	681b      	ldr	r3, [r3, #0]
 8017676:	2b00      	cmp	r3, #0
 8017678:	d006      	beq.n	8017688 <rt_malloc+0x21c>
 801767a:	4b1e      	ldr	r3, [pc, #120]	; (80176f4 <rt_malloc+0x288>)
 801767c:	681b      	ldr	r3, [r3, #0]
 801767e:	697a      	ldr	r2, [r7, #20]
 8017680:	320c      	adds	r2, #12
 8017682:	4610      	mov	r0, r2
 8017684:	6879      	ldr	r1, [r7, #4]
 8017686:	4798      	blx	r3
                                (((void *)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM)), size));

            /* return the memory data except mem struct */
            return (rt_uint8_t *)mem + SIZEOF_STRUCT_MEM;
 8017688:	697b      	ldr	r3, [r7, #20]
 801768a:	330c      	adds	r3, #12
 801768c:	e011      	b.n	80176b2 <rt_malloc+0x246>
    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
         ptr < mem_size_aligned - size;
         ptr = ((struct heap_mem *)&heap_ptr[ptr])->next)
 801768e:	4b11      	ldr	r3, [pc, #68]	; (80176d4 <rt_malloc+0x268>)
 8017690:	681a      	ldr	r2, [r3, #0]
 8017692:	69fb      	ldr	r3, [r7, #28]
 8017694:	4413      	add	r3, r2
 8017696:	685b      	ldr	r3, [r3, #4]
 8017698:	61fb      	str	r3, [r7, #28]

    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
         ptr < mem_size_aligned - size;
 801769a:	4b0b      	ldr	r3, [pc, #44]	; (80176c8 <rt_malloc+0x25c>)
 801769c:	681a      	ldr	r2, [r3, #0]
 801769e:	687b      	ldr	r3, [r7, #4]
 80176a0:	1ad2      	subs	r2, r2, r3
        size = MIN_SIZE_ALIGNED;

    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
 80176a2:	69fb      	ldr	r3, [r7, #28]
 80176a4:	429a      	cmp	r2, r3
 80176a6:	f63f af1c 	bhi.w	80174e2 <rt_malloc+0x76>
            /* return the memory data except mem struct */
            return (rt_uint8_t *)mem + SIZEOF_STRUCT_MEM;
        }
    }

    rt_sem_release(&heap_sem);
 80176aa:	4808      	ldr	r0, [pc, #32]	; (80176cc <rt_malloc+0x260>)
 80176ac:	f7fe fac0 	bl	8015c30 <rt_sem_release>

    return RT_NULL;
 80176b0:	2300      	movs	r3, #0
}
 80176b2:	4618      	mov	r0, r3
 80176b4:	3720      	adds	r7, #32
 80176b6:	46bd      	mov	sp, r7
 80176b8:	bd80      	pop	{r7, pc}
 80176ba:	bf00      	nop
 80176bc:	08028ffc 	.word	0x08028ffc
 80176c0:	0802a924 	.word	0x0802a924
 80176c4:	08029020 	.word	0x08029020
 80176c8:	20010db0 	.word	0x20010db0
 80176cc:	20010d90 	.word	0x20010d90
 80176d0:	20010d8c 	.word	0x20010d8c
 80176d4:	20010d84 	.word	0x20010d84
 80176d8:	20010db4 	.word	0x20010db4
 80176dc:	20010db8 	.word	0x20010db8
 80176e0:	20010d88 	.word	0x20010d88
 80176e4:	08029068 	.word	0x08029068
 80176e8:	08029090 	.word	0x08029090
 80176ec:	080290d8 	.word	0x080290d8
 80176f0:	08029124 	.word	0x08029124
 80176f4:	20010d7c 	.word	0x20010d7c

080176f8 <rt_realloc>:
 * @param newsize the required new size
 *
 * @return the changed memory block address
 */
void *rt_realloc(void *rmem, rt_size_t newsize)
{
 80176f8:	b580      	push	{r7, lr}
 80176fa:	b08a      	sub	sp, #40	; 0x28
 80176fc:	af00      	add	r7, sp, #0
 80176fe:	6078      	str	r0, [r7, #4]
 8017700:	6039      	str	r1, [r7, #0]
    rt_size_t size;
    rt_size_t ptr, ptr2;
    struct heap_mem *mem, *mem2;
    void *nmem;

    RT_DEBUG_NOT_IN_INTERRUPT;
 8017702:	f7e8 fd63 	bl	80001cc <rt_hw_interrupt_disable>
 8017706:	6278      	str	r0, [r7, #36]	; 0x24
 8017708:	f7fe ff1e 	bl	8016548 <rt_interrupt_get_nest>
 801770c:	4603      	mov	r3, r0
 801770e:	2b00      	cmp	r3, #0
 8017710:	d009      	beq.n	8017726 <rt_realloc+0x2e>
 8017712:	4853      	ldr	r0, [pc, #332]	; (8017860 <rt_realloc+0x168>)
 8017714:	4953      	ldr	r1, [pc, #332]	; (8017864 <rt_realloc+0x16c>)
 8017716:	f7ff fcfb 	bl	8017110 <rt_kprintf>
 801771a:	4853      	ldr	r0, [pc, #332]	; (8017868 <rt_realloc+0x170>)
 801771c:	4951      	ldr	r1, [pc, #324]	; (8017864 <rt_realloc+0x16c>)
 801771e:	f44f 72c4 	mov.w	r2, #392	; 0x188
 8017722:	f7ff fd6f 	bl	8017204 <rt_assert_handler>
 8017726:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8017728:	f7e8 fd54 	bl	80001d4 <rt_hw_interrupt_enable>

    /* alignment size */
    newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);
 801772c:	683b      	ldr	r3, [r7, #0]
 801772e:	3303      	adds	r3, #3
 8017730:	f023 0303 	bic.w	r3, r3, #3
 8017734:	603b      	str	r3, [r7, #0]
    if (newsize > mem_size_aligned)
 8017736:	4b4d      	ldr	r3, [pc, #308]	; (801786c <rt_realloc+0x174>)
 8017738:	681b      	ldr	r3, [r3, #0]
 801773a:	683a      	ldr	r2, [r7, #0]
 801773c:	429a      	cmp	r2, r3
 801773e:	d901      	bls.n	8017744 <rt_realloc+0x4c>
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("realloc: out of memory\n"));

        return RT_NULL;
 8017740:	2300      	movs	r3, #0
 8017742:	e089      	b.n	8017858 <rt_realloc+0x160>
    }

    /* allocate a new memory block */
    if (rmem == RT_NULL)
 8017744:	687b      	ldr	r3, [r7, #4]
 8017746:	2b00      	cmp	r3, #0
 8017748:	d104      	bne.n	8017754 <rt_realloc+0x5c>
        return rt_malloc(newsize);
 801774a:	6838      	ldr	r0, [r7, #0]
 801774c:	f7ff fe8e 	bl	801746c <rt_malloc>
 8017750:	4603      	mov	r3, r0
 8017752:	e081      	b.n	8017858 <rt_realloc+0x160>

    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
 8017754:	4846      	ldr	r0, [pc, #280]	; (8017870 <rt_realloc+0x178>)
 8017756:	f04f 31ff 	mov.w	r1, #4294967295
 801775a:	f7fe f9c5 	bl	8015ae8 <rt_sem_take>

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
 801775e:	4b45      	ldr	r3, [pc, #276]	; (8017874 <rt_realloc+0x17c>)
 8017760:	681b      	ldr	r3, [r3, #0]
 8017762:	687a      	ldr	r2, [r7, #4]
 8017764:	429a      	cmp	r2, r3
 8017766:	d304      	bcc.n	8017772 <rt_realloc+0x7a>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
 8017768:	4b43      	ldr	r3, [pc, #268]	; (8017878 <rt_realloc+0x180>)
 801776a:	681b      	ldr	r3, [r3, #0]
    if (rmem == RT_NULL)
        return rt_malloc(newsize);

    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
 801776c:	687a      	ldr	r2, [r7, #4]
 801776e:	429a      	cmp	r2, r3
 8017770:	d304      	bcc.n	801777c <rt_realloc+0x84>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
    {
        /* illegal memory */
        rt_sem_release(&heap_sem);
 8017772:	483f      	ldr	r0, [pc, #252]	; (8017870 <rt_realloc+0x178>)
 8017774:	f7fe fa5c 	bl	8015c30 <rt_sem_release>

        return rmem;
 8017778:	687b      	ldr	r3, [r7, #4]
 801777a:	e06d      	b.n	8017858 <rt_realloc+0x160>
    }

    mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
 801777c:	687b      	ldr	r3, [r7, #4]
 801777e:	3b0c      	subs	r3, #12
 8017780:	623b      	str	r3, [r7, #32]

    ptr = (rt_uint8_t *)mem - heap_ptr;
 8017782:	6a3b      	ldr	r3, [r7, #32]
 8017784:	4a3b      	ldr	r2, [pc, #236]	; (8017874 <rt_realloc+0x17c>)
 8017786:	6812      	ldr	r2, [r2, #0]
 8017788:	1a9b      	subs	r3, r3, r2
 801778a:	61fb      	str	r3, [r7, #28]
    size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 801778c:	6a3b      	ldr	r3, [r7, #32]
 801778e:	685a      	ldr	r2, [r3, #4]
 8017790:	69fb      	ldr	r3, [r7, #28]
 8017792:	1ad3      	subs	r3, r2, r3
 8017794:	3b0c      	subs	r3, #12
 8017796:	61bb      	str	r3, [r7, #24]
    if (size == newsize)
 8017798:	69ba      	ldr	r2, [r7, #24]
 801779a:	683b      	ldr	r3, [r7, #0]
 801779c:	429a      	cmp	r2, r3
 801779e:	d104      	bne.n	80177aa <rt_realloc+0xb2>
    {
        /* the size is the same as */
        rt_sem_release(&heap_sem);
 80177a0:	4833      	ldr	r0, [pc, #204]	; (8017870 <rt_realloc+0x178>)
 80177a2:	f7fe fa45 	bl	8015c30 <rt_sem_release>

        return rmem;
 80177a6:	687b      	ldr	r3, [r7, #4]
 80177a8:	e056      	b.n	8017858 <rt_realloc+0x160>
    }

    if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE < size)
 80177aa:	683b      	ldr	r3, [r7, #0]
 80177ac:	f103 0218 	add.w	r2, r3, #24
 80177b0:	69bb      	ldr	r3, [r7, #24]
 80177b2:	429a      	cmp	r2, r3
 80177b4:	d238      	bcs.n	8017828 <rt_realloc+0x130>
    {
        /* split memory block */
#ifdef RT_MEM_STATS
        used_mem -= (size - newsize);
 80177b6:	683a      	ldr	r2, [r7, #0]
 80177b8:	69bb      	ldr	r3, [r7, #24]
 80177ba:	1ad2      	subs	r2, r2, r3
 80177bc:	4b2f      	ldr	r3, [pc, #188]	; (801787c <rt_realloc+0x184>)
 80177be:	681b      	ldr	r3, [r3, #0]
 80177c0:	4413      	add	r3, r2
 80177c2:	4a2e      	ldr	r2, [pc, #184]	; (801787c <rt_realloc+0x184>)
 80177c4:	6013      	str	r3, [r2, #0]
#endif

        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 80177c6:	69fa      	ldr	r2, [r7, #28]
 80177c8:	683b      	ldr	r3, [r7, #0]
 80177ca:	4413      	add	r3, r2
 80177cc:	330c      	adds	r3, #12
 80177ce:	617b      	str	r3, [r7, #20]
        mem2 = (struct heap_mem *)&heap_ptr[ptr2];
 80177d0:	4b28      	ldr	r3, [pc, #160]	; (8017874 <rt_realloc+0x17c>)
 80177d2:	681a      	ldr	r2, [r3, #0]
 80177d4:	697b      	ldr	r3, [r7, #20]
 80177d6:	4413      	add	r3, r2
 80177d8:	613b      	str	r3, [r7, #16]
        mem2->magic= HEAP_MAGIC;
 80177da:	693b      	ldr	r3, [r7, #16]
 80177dc:	f44f 52f5 	mov.w	r2, #7840	; 0x1ea0
 80177e0:	801a      	strh	r2, [r3, #0]
        mem2->used = 0;
 80177e2:	693b      	ldr	r3, [r7, #16]
 80177e4:	2200      	movs	r2, #0
 80177e6:	805a      	strh	r2, [r3, #2]
        mem2->next = mem->next;
 80177e8:	6a3b      	ldr	r3, [r7, #32]
 80177ea:	685a      	ldr	r2, [r3, #4]
 80177ec:	693b      	ldr	r3, [r7, #16]
 80177ee:	605a      	str	r2, [r3, #4]
        mem2->prev = ptr;
 80177f0:	693b      	ldr	r3, [r7, #16]
 80177f2:	69fa      	ldr	r2, [r7, #28]
 80177f4:	609a      	str	r2, [r3, #8]
        mem->next = ptr2;
 80177f6:	6a3b      	ldr	r3, [r7, #32]
 80177f8:	697a      	ldr	r2, [r7, #20]
 80177fa:	605a      	str	r2, [r3, #4]
        if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
 80177fc:	693b      	ldr	r3, [r7, #16]
 80177fe:	685a      	ldr	r2, [r3, #4]
 8017800:	4b1a      	ldr	r3, [pc, #104]	; (801786c <rt_realloc+0x174>)
 8017802:	681b      	ldr	r3, [r3, #0]
 8017804:	330c      	adds	r3, #12
 8017806:	429a      	cmp	r2, r3
 8017808:	d006      	beq.n	8017818 <rt_realloc+0x120>
        {
            ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
 801780a:	4b1a      	ldr	r3, [pc, #104]	; (8017874 <rt_realloc+0x17c>)
 801780c:	681a      	ldr	r2, [r3, #0]
 801780e:	693b      	ldr	r3, [r7, #16]
 8017810:	685b      	ldr	r3, [r3, #4]
 8017812:	4413      	add	r3, r2
 8017814:	697a      	ldr	r2, [r7, #20]
 8017816:	609a      	str	r2, [r3, #8]
        }

        plug_holes(mem2);
 8017818:	6938      	ldr	r0, [r7, #16]
 801781a:	f7ff fd19 	bl	8017250 <plug_holes>

        rt_sem_release(&heap_sem);
 801781e:	4814      	ldr	r0, [pc, #80]	; (8017870 <rt_realloc+0x178>)
 8017820:	f7fe fa06 	bl	8015c30 <rt_sem_release>

        return rmem;
 8017824:	687b      	ldr	r3, [r7, #4]
 8017826:	e017      	b.n	8017858 <rt_realloc+0x160>
    }
    rt_sem_release(&heap_sem);
 8017828:	4811      	ldr	r0, [pc, #68]	; (8017870 <rt_realloc+0x178>)
 801782a:	f7fe fa01 	bl	8015c30 <rt_sem_release>

    /* expand memory */
    nmem = rt_malloc(newsize);
 801782e:	6838      	ldr	r0, [r7, #0]
 8017830:	f7ff fe1c 	bl	801746c <rt_malloc>
 8017834:	60f8      	str	r0, [r7, #12]
    if (nmem != RT_NULL) /* check memory */
 8017836:	68fb      	ldr	r3, [r7, #12]
 8017838:	2b00      	cmp	r3, #0
 801783a:	d00c      	beq.n	8017856 <rt_realloc+0x15e>
    {
        rt_memcpy(nmem, rmem, size < newsize ? size : newsize);
 801783c:	683a      	ldr	r2, [r7, #0]
 801783e:	69bb      	ldr	r3, [r7, #24]
 8017840:	4293      	cmp	r3, r2
 8017842:	bf28      	it	cs
 8017844:	4613      	movcs	r3, r2
 8017846:	68f8      	ldr	r0, [r7, #12]
 8017848:	6879      	ldr	r1, [r7, #4]
 801784a:	461a      	mov	r2, r3
 801784c:	f7fe ff04 	bl	8016658 <rt_memcpy>
        rt_free(rmem);
 8017850:	6878      	ldr	r0, [r7, #4]
 8017852:	f000 f84f 	bl	80178f4 <rt_free>
    }

    return nmem;
 8017856:	68fb      	ldr	r3, [r7, #12]
}
 8017858:	4618      	mov	r0, r3
 801785a:	3728      	adds	r7, #40	; 0x28
 801785c:	46bd      	mov	sp, r7
 801785e:	bd80      	pop	{r7, pc}
 8017860:	08028ffc 	.word	0x08028ffc
 8017864:	0802a930 	.word	0x0802a930
 8017868:	08029020 	.word	0x08029020
 801786c:	20010db0 	.word	0x20010db0
 8017870:	20010d90 	.word	0x20010d90
 8017874:	20010d84 	.word	0x20010d84
 8017878:	20010d88 	.word	0x20010d88
 801787c:	20010db4 	.word	0x20010db4

08017880 <rt_calloc>:
 * @param size size of the objects to allocate
 *
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *rt_calloc(rt_size_t count, rt_size_t size)
{
 8017880:	b580      	push	{r7, lr}
 8017882:	b084      	sub	sp, #16
 8017884:	af00      	add	r7, sp, #0
 8017886:	6078      	str	r0, [r7, #4]
 8017888:	6039      	str	r1, [r7, #0]
    void *p;

    RT_DEBUG_NOT_IN_INTERRUPT;
 801788a:	f7e8 fc9f 	bl	80001cc <rt_hw_interrupt_disable>
 801788e:	60f8      	str	r0, [r7, #12]
 8017890:	f7fe fe5a 	bl	8016548 <rt_interrupt_get_nest>
 8017894:	4603      	mov	r3, r0
 8017896:	2b00      	cmp	r3, #0
 8017898:	d009      	beq.n	80178ae <rt_calloc+0x2e>
 801789a:	4813      	ldr	r0, [pc, #76]	; (80178e8 <rt_calloc+0x68>)
 801789c:	4913      	ldr	r1, [pc, #76]	; (80178ec <rt_calloc+0x6c>)
 801789e:	f7ff fc37 	bl	8017110 <rt_kprintf>
 80178a2:	4813      	ldr	r0, [pc, #76]	; (80178f0 <rt_calloc+0x70>)
 80178a4:	4911      	ldr	r1, [pc, #68]	; (80178ec <rt_calloc+0x6c>)
 80178a6:	f240 12e5 	movw	r2, #485	; 0x1e5
 80178aa:	f7ff fcab 	bl	8017204 <rt_assert_handler>
 80178ae:	68f8      	ldr	r0, [r7, #12]
 80178b0:	f7e8 fc90 	bl	80001d4 <rt_hw_interrupt_enable>

    /* allocate 'count' objects of size 'size' */
    p = rt_malloc(count * size);
 80178b4:	687b      	ldr	r3, [r7, #4]
 80178b6:	683a      	ldr	r2, [r7, #0]
 80178b8:	fb02 f303 	mul.w	r3, r2, r3
 80178bc:	4618      	mov	r0, r3
 80178be:	f7ff fdd5 	bl	801746c <rt_malloc>
 80178c2:	60b8      	str	r0, [r7, #8]

    /* zero the memory */
    if (p)
 80178c4:	68bb      	ldr	r3, [r7, #8]
 80178c6:	2b00      	cmp	r3, #0
 80178c8:	d008      	beq.n	80178dc <rt_calloc+0x5c>
        rt_memset(p, 0, count * size);
 80178ca:	687b      	ldr	r3, [r7, #4]
 80178cc:	683a      	ldr	r2, [r7, #0]
 80178ce:	fb02 f303 	mul.w	r3, r2, r3
 80178d2:	68b8      	ldr	r0, [r7, #8]
 80178d4:	2100      	movs	r1, #0
 80178d6:	461a      	mov	r2, r3
 80178d8:	f7fe fe62 	bl	80165a0 <rt_memset>

    return p;
 80178dc:	68bb      	ldr	r3, [r7, #8]
}
 80178de:	4618      	mov	r0, r3
 80178e0:	3710      	adds	r7, #16
 80178e2:	46bd      	mov	sp, r7
 80178e4:	bd80      	pop	{r7, pc}
 80178e6:	bf00      	nop
 80178e8:	08028ffc 	.word	0x08028ffc
 80178ec:	0802a93c 	.word	0x0802a93c
 80178f0:	08029020 	.word	0x08029020

080178f4 <rt_free>:
 * rt_malloc. The released memory block is taken back to system heap.
 *
 * @param rmem the address of memory which will be released
 */
void rt_free(void *rmem)
{
 80178f4:	b580      	push	{r7, lr}
 80178f6:	b084      	sub	sp, #16
 80178f8:	af00      	add	r7, sp, #0
 80178fa:	6078      	str	r0, [r7, #4]
    struct heap_mem *mem;

    RT_DEBUG_NOT_IN_INTERRUPT;
 80178fc:	f7e8 fc66 	bl	80001cc <rt_hw_interrupt_disable>
 8017900:	60f8      	str	r0, [r7, #12]
 8017902:	f7fe fe21 	bl	8016548 <rt_interrupt_get_nest>
 8017906:	4603      	mov	r3, r0
 8017908:	2b00      	cmp	r3, #0
 801790a:	d009      	beq.n	8017920 <rt_free+0x2c>
 801790c:	483f      	ldr	r0, [pc, #252]	; (8017a0c <rt_free+0x118>)
 801790e:	4940      	ldr	r1, [pc, #256]	; (8017a10 <rt_free+0x11c>)
 8017910:	f7ff fbfe 	bl	8017110 <rt_kprintf>
 8017914:	483f      	ldr	r0, [pc, #252]	; (8017a14 <rt_free+0x120>)
 8017916:	493e      	ldr	r1, [pc, #248]	; (8017a10 <rt_free+0x11c>)
 8017918:	f44f 72fe 	mov.w	r2, #508	; 0x1fc
 801791c:	f7ff fc72 	bl	8017204 <rt_assert_handler>
 8017920:	68f8      	ldr	r0, [r7, #12]
 8017922:	f7e8 fc57 	bl	80001d4 <rt_hw_interrupt_enable>

    if (rmem == RT_NULL)
 8017926:	687b      	ldr	r3, [r7, #4]
 8017928:	2b00      	cmp	r3, #0
 801792a:	d100      	bne.n	801792e <rt_free+0x3a>
        return;
 801792c:	e06b      	b.n	8017a06 <rt_free+0x112>
    RT_ASSERT((((rt_uint32_t)rmem) & (RT_ALIGN_SIZE-1)) == 0);
 801792e:	687b      	ldr	r3, [r7, #4]
 8017930:	f003 0303 	and.w	r3, r3, #3
 8017934:	2b00      	cmp	r3, #0
 8017936:	d005      	beq.n	8017944 <rt_free+0x50>
 8017938:	4837      	ldr	r0, [pc, #220]	; (8017a18 <rt_free+0x124>)
 801793a:	4935      	ldr	r1, [pc, #212]	; (8017a10 <rt_free+0x11c>)
 801793c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8017940:	f7ff fc60 	bl	8017204 <rt_assert_handler>
    RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr &&
 8017944:	4b35      	ldr	r3, [pc, #212]	; (8017a1c <rt_free+0x128>)
 8017946:	681b      	ldr	r3, [r3, #0]
 8017948:	687a      	ldr	r2, [r7, #4]
 801794a:	429a      	cmp	r2, r3
 801794c:	d304      	bcc.n	8017958 <rt_free+0x64>
 801794e:	4b34      	ldr	r3, [pc, #208]	; (8017a20 <rt_free+0x12c>)
 8017950:	681b      	ldr	r3, [r3, #0]
 8017952:	687a      	ldr	r2, [r7, #4]
 8017954:	429a      	cmp	r2, r3
 8017956:	d305      	bcc.n	8017964 <rt_free+0x70>
 8017958:	4832      	ldr	r0, [pc, #200]	; (8017a24 <rt_free+0x130>)
 801795a:	492d      	ldr	r1, [pc, #180]	; (8017a10 <rt_free+0x11c>)
 801795c:	f240 2202 	movw	r2, #514	; 0x202
 8017960:	f7ff fc50 	bl	8017204 <rt_assert_handler>
              (rt_uint8_t *)rmem < (rt_uint8_t *)heap_end);

    RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));
 8017964:	4b30      	ldr	r3, [pc, #192]	; (8017a28 <rt_free+0x134>)
 8017966:	681b      	ldr	r3, [r3, #0]
 8017968:	2b00      	cmp	r3, #0
 801796a:	d003      	beq.n	8017974 <rt_free+0x80>
 801796c:	4b2e      	ldr	r3, [pc, #184]	; (8017a28 <rt_free+0x134>)
 801796e:	681b      	ldr	r3, [r3, #0]
 8017970:	6878      	ldr	r0, [r7, #4]
 8017972:	4798      	blx	r3

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
 8017974:	4b29      	ldr	r3, [pc, #164]	; (8017a1c <rt_free+0x128>)
 8017976:	681b      	ldr	r3, [r3, #0]
 8017978:	687a      	ldr	r2, [r7, #4]
 801797a:	429a      	cmp	r2, r3
 801797c:	d304      	bcc.n	8017988 <rt_free+0x94>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
 801797e:	4b28      	ldr	r3, [pc, #160]	; (8017a20 <rt_free+0x12c>)
 8017980:	681b      	ldr	r3, [r3, #0]
    RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr &&
              (rt_uint8_t *)rmem < (rt_uint8_t *)heap_end);

    RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
 8017982:	687a      	ldr	r2, [r7, #4]
 8017984:	429a      	cmp	r2, r3
 8017986:	d300      	bcc.n	801798a <rt_free+0x96>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("illegal memory\n"));

        return;
 8017988:	e03d      	b.n	8017a06 <rt_free+0x112>
    }

    /* Get the corresponding struct heap_mem ... */
    mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
 801798a:	687b      	ldr	r3, [r7, #4]
 801798c:	3b0c      	subs	r3, #12
 801798e:	60bb      	str	r3, [r7, #8]
                  (rt_uint32_t)rmem,
                  (rt_uint32_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));


    /* protect the heap from concurrent access */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
 8017990:	4826      	ldr	r0, [pc, #152]	; (8017a2c <rt_free+0x138>)
 8017992:	f04f 31ff 	mov.w	r1, #4294967295
 8017996:	f7fe f8a7 	bl	8015ae8 <rt_sem_take>

    /* ... which has to be in a used state ... */
    RT_ASSERT(mem->used);
 801799a:	68bb      	ldr	r3, [r7, #8]
 801799c:	885b      	ldrh	r3, [r3, #2]
 801799e:	2b00      	cmp	r3, #0
 80179a0:	d105      	bne.n	80179ae <rt_free+0xba>
 80179a2:	4823      	ldr	r0, [pc, #140]	; (8017a30 <rt_free+0x13c>)
 80179a4:	491a      	ldr	r1, [pc, #104]	; (8017a10 <rt_free+0x11c>)
 80179a6:	f240 221b 	movw	r2, #539	; 0x21b
 80179aa:	f7ff fc2b 	bl	8017204 <rt_assert_handler>
    RT_ASSERT(mem->magic == HEAP_MAGIC);
 80179ae:	68bb      	ldr	r3, [r7, #8]
 80179b0:	881b      	ldrh	r3, [r3, #0]
 80179b2:	f5b3 5ff5 	cmp.w	r3, #7840	; 0x1ea0
 80179b6:	d005      	beq.n	80179c4 <rt_free+0xd0>
 80179b8:	481e      	ldr	r0, [pc, #120]	; (8017a34 <rt_free+0x140>)
 80179ba:	4915      	ldr	r1, [pc, #84]	; (8017a10 <rt_free+0x11c>)
 80179bc:	f44f 7207 	mov.w	r2, #540	; 0x21c
 80179c0:	f7ff fc20 	bl	8017204 <rt_assert_handler>
    /* ... and is now unused. */
    mem->used  = 0;
 80179c4:	68bb      	ldr	r3, [r7, #8]
 80179c6:	2200      	movs	r2, #0
 80179c8:	805a      	strh	r2, [r3, #2]
    mem->magic = 0;
 80179ca:	68bb      	ldr	r3, [r7, #8]
 80179cc:	2200      	movs	r2, #0
 80179ce:	801a      	strh	r2, [r3, #0]

    if (mem < lfree)
 80179d0:	4b19      	ldr	r3, [pc, #100]	; (8017a38 <rt_free+0x144>)
 80179d2:	681b      	ldr	r3, [r3, #0]
 80179d4:	68ba      	ldr	r2, [r7, #8]
 80179d6:	429a      	cmp	r2, r3
 80179d8:	d202      	bcs.n	80179e0 <rt_free+0xec>
    {
        /* the newly freed struct is now the lowest */
        lfree = mem;
 80179da:	4a17      	ldr	r2, [pc, #92]	; (8017a38 <rt_free+0x144>)
 80179dc:	68bb      	ldr	r3, [r7, #8]
 80179de:	6013      	str	r3, [r2, #0]
    }

#ifdef RT_MEM_STATS
    used_mem -= (mem->next - ((rt_uint8_t*)mem - heap_ptr));
 80179e0:	4b16      	ldr	r3, [pc, #88]	; (8017a3c <rt_free+0x148>)
 80179e2:	681a      	ldr	r2, [r3, #0]
 80179e4:	68bb      	ldr	r3, [r7, #8]
 80179e6:	685b      	ldr	r3, [r3, #4]
 80179e8:	490c      	ldr	r1, [pc, #48]	; (8017a1c <rt_free+0x128>)
 80179ea:	6809      	ldr	r1, [r1, #0]
 80179ec:	4608      	mov	r0, r1
 80179ee:	68b9      	ldr	r1, [r7, #8]
 80179f0:	1a41      	subs	r1, r0, r1
 80179f2:	440b      	add	r3, r1
 80179f4:	1ad3      	subs	r3, r2, r3
 80179f6:	4a11      	ldr	r2, [pc, #68]	; (8017a3c <rt_free+0x148>)
 80179f8:	6013      	str	r3, [r2, #0]
#endif

    /* finally, see if prev or next are free also */
    plug_holes(mem);
 80179fa:	68b8      	ldr	r0, [r7, #8]
 80179fc:	f7ff fc28 	bl	8017250 <plug_holes>
    rt_sem_release(&heap_sem);
 8017a00:	480a      	ldr	r0, [pc, #40]	; (8017a2c <rt_free+0x138>)
 8017a02:	f7fe f915 	bl	8015c30 <rt_sem_release>
}
 8017a06:	3710      	adds	r7, #16
 8017a08:	46bd      	mov	sp, r7
 8017a0a:	bd80      	pop	{r7, pc}
 8017a0c:	08028ffc 	.word	0x08028ffc
 8017a10:	0802a948 	.word	0x0802a948
 8017a14:	08029020 	.word	0x08029020
 8017a18:	08029154 	.word	0x08029154
 8017a1c:	20010d84 	.word	0x20010d84
 8017a20:	20010d88 	.word	0x20010d88
 8017a24:	08029184 	.word	0x08029184
 8017a28:	20010d80 	.word	0x20010d80
 8017a2c:	20010d90 	.word	0x20010d90
 8017a30:	080291e0 	.word	0x080291e0
 8017a34:	080291ec 	.word	0x080291ec
 8017a38:	20010d8c 	.word	0x20010d8c
 8017a3c:	20010db4 	.word	0x20010db4

08017a40 <list_mem>:

#ifdef RT_USING_FINSH
#include <finsh.h>

void list_mem(void)
{
 8017a40:	b580      	push	{r7, lr}
 8017a42:	af00      	add	r7, sp, #0
    rt_kprintf("total memory: %d\n", mem_size_aligned);
 8017a44:	4b09      	ldr	r3, [pc, #36]	; (8017a6c <list_mem+0x2c>)
 8017a46:	681b      	ldr	r3, [r3, #0]
 8017a48:	4809      	ldr	r0, [pc, #36]	; (8017a70 <list_mem+0x30>)
 8017a4a:	4619      	mov	r1, r3
 8017a4c:	f7ff fb60 	bl	8017110 <rt_kprintf>
    rt_kprintf("used memory : %d\n", used_mem);
 8017a50:	4b08      	ldr	r3, [pc, #32]	; (8017a74 <list_mem+0x34>)
 8017a52:	681b      	ldr	r3, [r3, #0]
 8017a54:	4808      	ldr	r0, [pc, #32]	; (8017a78 <list_mem+0x38>)
 8017a56:	4619      	mov	r1, r3
 8017a58:	f7ff fb5a 	bl	8017110 <rt_kprintf>
    rt_kprintf("maximum allocated memory: %d\n", max_mem);
 8017a5c:	4b07      	ldr	r3, [pc, #28]	; (8017a7c <list_mem+0x3c>)
 8017a5e:	681b      	ldr	r3, [r3, #0]
 8017a60:	4807      	ldr	r0, [pc, #28]	; (8017a80 <list_mem+0x40>)
 8017a62:	4619      	mov	r1, r3
 8017a64:	f7ff fb54 	bl	8017110 <rt_kprintf>
}
 8017a68:	bd80      	pop	{r7, pc}
 8017a6a:	bf00      	nop
 8017a6c:	20010db0 	.word	0x20010db0
 8017a70:	08029208 	.word	0x08029208
 8017a74:	20010db4 	.word	0x20010db4
 8017a78:	0802921c 	.word	0x0802921c
 8017a7c:	20010db8 	.word	0x20010db8
 8017a80:	08029230 	.word	0x08029230

08017a84 <rt_memheap_init>:
 */
rt_err_t rt_memheap_init(struct rt_memheap *memheap,
                         const char        *name,
                         void              *start_addr,
                         rt_uint32_t        size)
{
 8017a84:	b580      	push	{r7, lr}
 8017a86:	b086      	sub	sp, #24
 8017a88:	af00      	add	r7, sp, #0
 8017a8a:	60f8      	str	r0, [r7, #12]
 8017a8c:	60b9      	str	r1, [r7, #8]
 8017a8e:	607a      	str	r2, [r7, #4]
 8017a90:	603b      	str	r3, [r7, #0]
    struct rt_memheap_item *item;

    RT_ASSERT(memheap != RT_NULL);
 8017a92:	68fb      	ldr	r3, [r7, #12]
 8017a94:	2b00      	cmp	r3, #0
 8017a96:	d104      	bne.n	8017aa2 <rt_memheap_init+0x1e>
 8017a98:	4847      	ldr	r0, [pc, #284]	; (8017bb8 <rt_memheap_init+0x134>)
 8017a9a:	4948      	ldr	r1, [pc, #288]	; (8017bbc <rt_memheap_init+0x138>)
 8017a9c:	2243      	movs	r2, #67	; 0x43
 8017a9e:	f7ff fbb1 	bl	8017204 <rt_assert_handler>

    /* initialize pool object */
    rt_object_init(&(memheap->parent), RT_Object_Class_MemHeap, name);
 8017aa2:	68fb      	ldr	r3, [r7, #12]
 8017aa4:	4618      	mov	r0, r3
 8017aa6:	2106      	movs	r1, #6
 8017aa8:	68ba      	ldr	r2, [r7, #8]
 8017aaa:	f000 f8c5 	bl	8017c38 <rt_object_init>

    memheap->start_addr     = start_addr;
 8017aae:	68fb      	ldr	r3, [r7, #12]
 8017ab0:	687a      	ldr	r2, [r7, #4]
 8017ab2:	615a      	str	r2, [r3, #20]
    memheap->pool_size      = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);
 8017ab4:	683b      	ldr	r3, [r7, #0]
 8017ab6:	f023 0203 	bic.w	r2, r3, #3
 8017aba:	68fb      	ldr	r3, [r7, #12]
 8017abc:	619a      	str	r2, [r3, #24]
    memheap->available_size = memheap->pool_size - (2 * RT_MEMHEAP_SIZE);
 8017abe:	68fb      	ldr	r3, [r7, #12]
 8017ac0:	699b      	ldr	r3, [r3, #24]
 8017ac2:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8017ac6:	68fb      	ldr	r3, [r7, #12]
 8017ac8:	61da      	str	r2, [r3, #28]
    memheap->max_used_size  = memheap->pool_size - memheap->available_size;
 8017aca:	68fb      	ldr	r3, [r7, #12]
 8017acc:	699a      	ldr	r2, [r3, #24]
 8017ace:	68fb      	ldr	r3, [r7, #12]
 8017ad0:	69db      	ldr	r3, [r3, #28]
 8017ad2:	1ad2      	subs	r2, r2, r3
 8017ad4:	68fb      	ldr	r3, [r7, #12]
 8017ad6:	621a      	str	r2, [r3, #32]

    /* initialize the free list header */
    item            = &(memheap->free_header);
 8017ad8:	68fb      	ldr	r3, [r7, #12]
 8017ada:	332c      	adds	r3, #44	; 0x2c
 8017adc:	617b      	str	r3, [r7, #20]
    item->magic     = RT_MEMHEAP_MAGIC;
 8017ade:	697b      	ldr	r3, [r7, #20]
 8017ae0:	4a37      	ldr	r2, [pc, #220]	; (8017bc0 <rt_memheap_init+0x13c>)
 8017ae2:	601a      	str	r2, [r3, #0]
    item->pool_ptr  = memheap;
 8017ae4:	697b      	ldr	r3, [r7, #20]
 8017ae6:	68fa      	ldr	r2, [r7, #12]
 8017ae8:	605a      	str	r2, [r3, #4]
    item->next      = RT_NULL;
 8017aea:	697b      	ldr	r3, [r7, #20]
 8017aec:	2200      	movs	r2, #0
 8017aee:	609a      	str	r2, [r3, #8]
    item->prev      = RT_NULL;
 8017af0:	697b      	ldr	r3, [r7, #20]
 8017af2:	2200      	movs	r2, #0
 8017af4:	60da      	str	r2, [r3, #12]
    item->next_free = item;
 8017af6:	697b      	ldr	r3, [r7, #20]
 8017af8:	697a      	ldr	r2, [r7, #20]
 8017afa:	611a      	str	r2, [r3, #16]
    item->prev_free = item;
 8017afc:	697b      	ldr	r3, [r7, #20]
 8017afe:	697a      	ldr	r2, [r7, #20]
 8017b00:	615a      	str	r2, [r3, #20]

    /* set the free list to free list header */
    memheap->free_list = item;
 8017b02:	68fb      	ldr	r3, [r7, #12]
 8017b04:	697a      	ldr	r2, [r7, #20]
 8017b06:	629a      	str	r2, [r3, #40]	; 0x28

    /* initialize the first big memory block */
    item            = (struct rt_memheap_item *)start_addr;
 8017b08:	687b      	ldr	r3, [r7, #4]
 8017b0a:	617b      	str	r3, [r7, #20]
    item->magic     = RT_MEMHEAP_MAGIC;
 8017b0c:	697b      	ldr	r3, [r7, #20]
 8017b0e:	4a2c      	ldr	r2, [pc, #176]	; (8017bc0 <rt_memheap_init+0x13c>)
 8017b10:	601a      	str	r2, [r3, #0]
    item->pool_ptr  = memheap;
 8017b12:	697b      	ldr	r3, [r7, #20]
 8017b14:	68fa      	ldr	r2, [r7, #12]
 8017b16:	605a      	str	r2, [r3, #4]
    item->next      = RT_NULL;
 8017b18:	697b      	ldr	r3, [r7, #20]
 8017b1a:	2200      	movs	r2, #0
 8017b1c:	609a      	str	r2, [r3, #8]
    item->prev      = RT_NULL;
 8017b1e:	697b      	ldr	r3, [r7, #20]
 8017b20:	2200      	movs	r2, #0
 8017b22:	60da      	str	r2, [r3, #12]
    item->next_free = item;
 8017b24:	697b      	ldr	r3, [r7, #20]
 8017b26:	697a      	ldr	r2, [r7, #20]
 8017b28:	611a      	str	r2, [r3, #16]
    item->prev_free = item;
 8017b2a:	697b      	ldr	r3, [r7, #20]
 8017b2c:	697a      	ldr	r2, [r7, #20]
 8017b2e:	615a      	str	r2, [r3, #20]

    item->next = (struct rt_memheap_item *)
        ((rt_uint8_t *)item + memheap->available_size + RT_MEMHEAP_SIZE);
 8017b30:	68fb      	ldr	r3, [r7, #12]
 8017b32:	69db      	ldr	r3, [r3, #28]
 8017b34:	3318      	adds	r3, #24
    item->next      = RT_NULL;
    item->prev      = RT_NULL;
    item->next_free = item;
    item->prev_free = item;

    item->next = (struct rt_memheap_item *)
 8017b36:	697a      	ldr	r2, [r7, #20]
 8017b38:	441a      	add	r2, r3
 8017b3a:	697b      	ldr	r3, [r7, #20]
 8017b3c:	609a      	str	r2, [r3, #8]
        ((rt_uint8_t *)item + memheap->available_size + RT_MEMHEAP_SIZE);
    item->prev = item->next;
 8017b3e:	697b      	ldr	r3, [r7, #20]
 8017b40:	689a      	ldr	r2, [r3, #8]
 8017b42:	697b      	ldr	r3, [r7, #20]
 8017b44:	60da      	str	r2, [r3, #12]

    /* block list header */
    memheap->block_list = item;
 8017b46:	68fb      	ldr	r3, [r7, #12]
 8017b48:	697a      	ldr	r2, [r7, #20]
 8017b4a:	625a      	str	r2, [r3, #36]	; 0x24

    /* place the big memory block to free list */
    item->next_free = memheap->free_list->next_free;
 8017b4c:	68fb      	ldr	r3, [r7, #12]
 8017b4e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8017b50:	691a      	ldr	r2, [r3, #16]
 8017b52:	697b      	ldr	r3, [r7, #20]
 8017b54:	611a      	str	r2, [r3, #16]
    item->prev_free = memheap->free_list;
 8017b56:	68fb      	ldr	r3, [r7, #12]
 8017b58:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8017b5a:	697b      	ldr	r3, [r7, #20]
 8017b5c:	615a      	str	r2, [r3, #20]
    memheap->free_list->next_free->prev_free = item;
 8017b5e:	68fb      	ldr	r3, [r7, #12]
 8017b60:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8017b62:	691b      	ldr	r3, [r3, #16]
 8017b64:	697a      	ldr	r2, [r7, #20]
 8017b66:	615a      	str	r2, [r3, #20]
    memheap->free_list->next_free            = item;
 8017b68:	68fb      	ldr	r3, [r7, #12]
 8017b6a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8017b6c:	697a      	ldr	r2, [r7, #20]
 8017b6e:	611a      	str	r2, [r3, #16]

    /* move to the end of memory pool to build a small tailer block,
     * which prevents block merging
     */
    item = item->next;
 8017b70:	697b      	ldr	r3, [r7, #20]
 8017b72:	689b      	ldr	r3, [r3, #8]
 8017b74:	617b      	str	r3, [r7, #20]
    /* it's a used memory block */
    item->magic     = RT_MEMHEAP_MAGIC | RT_MEMHEAP_USED;
 8017b76:	697b      	ldr	r3, [r7, #20]
 8017b78:	4a12      	ldr	r2, [pc, #72]	; (8017bc4 <rt_memheap_init+0x140>)
 8017b7a:	601a      	str	r2, [r3, #0]
    item->pool_ptr  = memheap;
 8017b7c:	697b      	ldr	r3, [r7, #20]
 8017b7e:	68fa      	ldr	r2, [r7, #12]
 8017b80:	605a      	str	r2, [r3, #4]
    item->next      = (struct rt_memheap_item *)start_addr;
 8017b82:	697b      	ldr	r3, [r7, #20]
 8017b84:	687a      	ldr	r2, [r7, #4]
 8017b86:	609a      	str	r2, [r3, #8]
    item->prev      = (struct rt_memheap_item *)start_addr;
 8017b88:	697b      	ldr	r3, [r7, #20]
 8017b8a:	687a      	ldr	r2, [r7, #4]
 8017b8c:	60da      	str	r2, [r3, #12]
    /* not in free list */
    item->next_free = item->prev_free = RT_NULL;
 8017b8e:	697b      	ldr	r3, [r7, #20]
 8017b90:	2200      	movs	r2, #0
 8017b92:	615a      	str	r2, [r3, #20]
 8017b94:	697b      	ldr	r3, [r7, #20]
 8017b96:	695a      	ldr	r2, [r3, #20]
 8017b98:	697b      	ldr	r3, [r7, #20]
 8017b9a:	611a      	str	r2, [r3, #16]

    /* initialize semaphore lock */
    rt_sem_init(&(memheap->lock), name, 1, RT_IPC_FLAG_FIFO);
 8017b9c:	68fb      	ldr	r3, [r7, #12]
 8017b9e:	3344      	adds	r3, #68	; 0x44
 8017ba0:	4618      	mov	r0, r3
 8017ba2:	68b9      	ldr	r1, [r7, #8]
 8017ba4:	2201      	movs	r2, #1
 8017ba6:	2300      	movs	r3, #0
 8017ba8:	f7fd ff38 	bl	8015a1c <rt_sem_init>

    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,
                 ("memory heap: start addr 0x%08x, size %d, free list header 0x%08x\n",
                  start_addr, size, &(memheap->free_header)));

    return RT_EOK;
 8017bac:	2300      	movs	r3, #0
}
 8017bae:	4618      	mov	r0, r3
 8017bb0:	3718      	adds	r7, #24
 8017bb2:	46bd      	mov	sp, r7
 8017bb4:	bd80      	pop	{r7, pc}
 8017bb6:	bf00      	nop
 8017bb8:	08029250 	.word	0x08029250
 8017bbc:	0802a950 	.word	0x0802a950
 8017bc0:	1ea01ea0 	.word	0x1ea01ea0
 8017bc4:	1ea01ea1 	.word	0x1ea01ea1

08017bc8 <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
 8017bc8:	b480      	push	{r7}
 8017bca:	b083      	sub	sp, #12
 8017bcc:	af00      	add	r7, sp, #0
 8017bce:	6078      	str	r0, [r7, #4]
 8017bd0:	6039      	str	r1, [r7, #0]
    l->next->prev = n;
 8017bd2:	687b      	ldr	r3, [r7, #4]
 8017bd4:	681b      	ldr	r3, [r3, #0]
 8017bd6:	683a      	ldr	r2, [r7, #0]
 8017bd8:	605a      	str	r2, [r3, #4]
    n->next = l->next;
 8017bda:	687b      	ldr	r3, [r7, #4]
 8017bdc:	681a      	ldr	r2, [r3, #0]
 8017bde:	683b      	ldr	r3, [r7, #0]
 8017be0:	601a      	str	r2, [r3, #0]

    l->next = n;
 8017be2:	687b      	ldr	r3, [r7, #4]
 8017be4:	683a      	ldr	r2, [r7, #0]
 8017be6:	601a      	str	r2, [r3, #0]
    n->prev = l;
 8017be8:	683b      	ldr	r3, [r7, #0]
 8017bea:	687a      	ldr	r2, [r7, #4]
 8017bec:	605a      	str	r2, [r3, #4]
}
 8017bee:	370c      	adds	r7, #12
 8017bf0:	46bd      	mov	sp, r7
 8017bf2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017bf6:	4770      	bx	lr

08017bf8 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 8017bf8:	b480      	push	{r7}
 8017bfa:	b083      	sub	sp, #12
 8017bfc:	af00      	add	r7, sp, #0
 8017bfe:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 8017c00:	687b      	ldr	r3, [r7, #4]
 8017c02:	681b      	ldr	r3, [r3, #0]
 8017c04:	687a      	ldr	r2, [r7, #4]
 8017c06:	6852      	ldr	r2, [r2, #4]
 8017c08:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 8017c0a:	687b      	ldr	r3, [r7, #4]
 8017c0c:	685b      	ldr	r3, [r3, #4]
 8017c0e:	687a      	ldr	r2, [r7, #4]
 8017c10:	6812      	ldr	r2, [r2, #0]
 8017c12:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 8017c14:	687b      	ldr	r3, [r7, #4]
 8017c16:	687a      	ldr	r2, [r7, #4]
 8017c18:	605a      	str	r2, [r3, #4]
 8017c1a:	687b      	ldr	r3, [r7, #4]
 8017c1c:	685a      	ldr	r2, [r3, #4]
 8017c1e:	687b      	ldr	r3, [r7, #4]
 8017c20:	601a      	str	r2, [r3, #0]
}
 8017c22:	370c      	adds	r7, #12
 8017c24:	46bd      	mov	sp, r7
 8017c26:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017c2a:	4770      	bx	lr

08017c2c <rt_system_object_init>:
 *
 * @deprecated since 0.3.0, this function does not need to be invoked
 * in the system initialization.
 */
void rt_system_object_init(void)
{
 8017c2c:	b480      	push	{r7}
 8017c2e:	af00      	add	r7, sp, #0
}
 8017c30:	46bd      	mov	sp, r7
 8017c32:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017c36:	4770      	bx	lr

08017c38 <rt_object_init>:
 * @param name the object name. In system, the object's name must be unique.
 */
void rt_object_init(struct rt_object         *object,
                    enum rt_object_class_type type,
                    const char               *name)
{
 8017c38:	b590      	push	{r4, r7, lr}
 8017c3a:	b087      	sub	sp, #28
 8017c3c:	af00      	add	r7, sp, #0
 8017c3e:	60f8      	str	r0, [r7, #12]
 8017c40:	460b      	mov	r3, r1
 8017c42:	607a      	str	r2, [r7, #4]
 8017c44:	72fb      	strb	r3, [r7, #11]
    /* get module object information */
    information = (rt_module_self() != RT_NULL) ?
        &rt_module_self()->module_object[type] : &rt_object_container[type];
#else
    /* get object information */
    information = &rt_object_container[type];
 8017c46:	7afb      	ldrb	r3, [r7, #11]
 8017c48:	011b      	lsls	r3, r3, #4
 8017c4a:	4a14      	ldr	r2, [pc, #80]	; (8017c9c <rt_object_init+0x64>)
 8017c4c:	4413      	add	r3, r2
 8017c4e:	617b      	str	r3, [r7, #20]
#endif

    /* initialize object's parameters */

    /* set object type to static */
    object->type = type | RT_Object_Class_Static;
 8017c50:	7afb      	ldrb	r3, [r7, #11]
 8017c52:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8017c56:	b2da      	uxtb	r2, r3
 8017c58:	68fb      	ldr	r3, [r7, #12]
 8017c5a:	721a      	strb	r2, [r3, #8]

    /* copy name */
    rt_strncpy(object->name, name, RT_NAME_MAX);
 8017c5c:	68fb      	ldr	r3, [r7, #12]
 8017c5e:	4618      	mov	r0, r3
 8017c60:	6879      	ldr	r1, [r7, #4]
 8017c62:	2208      	movs	r2, #8
 8017c64:	f7fe fda4 	bl	80167b0 <rt_strncpy>

    RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
 8017c68:	4b0d      	ldr	r3, [pc, #52]	; (8017ca0 <rt_object_init+0x68>)
 8017c6a:	681b      	ldr	r3, [r3, #0]
 8017c6c:	2b00      	cmp	r3, #0
 8017c6e:	d003      	beq.n	8017c78 <rt_object_init+0x40>
 8017c70:	4b0b      	ldr	r3, [pc, #44]	; (8017ca0 <rt_object_init+0x68>)
 8017c72:	681b      	ldr	r3, [r3, #0]
 8017c74:	68f8      	ldr	r0, [r7, #12]
 8017c76:	4798      	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
 8017c78:	f7e8 faa8 	bl	80001cc <rt_hw_interrupt_disable>
 8017c7c:	4604      	mov	r4, r0

    /* insert object into information object list */
    rt_list_insert_after(&(information->object_list), &(object->list));
 8017c7e:	697b      	ldr	r3, [r7, #20]
 8017c80:	1d1a      	adds	r2, r3, #4
 8017c82:	68fb      	ldr	r3, [r7, #12]
 8017c84:	330c      	adds	r3, #12
 8017c86:	4610      	mov	r0, r2
 8017c88:	4619      	mov	r1, r3
 8017c8a:	f7ff ff9d 	bl	8017bc8 <rt_list_insert_after>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
 8017c8e:	4620      	mov	r0, r4
 8017c90:	f7e8 faa0 	bl	80001d4 <rt_hw_interrupt_enable>
}
 8017c94:	371c      	adds	r7, #28
 8017c96:	46bd      	mov	sp, r7
 8017c98:	bd90      	pop	{r4, r7, pc}
 8017c9a:	bf00      	nop
 8017c9c:	2001001c 	.word	0x2001001c
 8017ca0:	20010dbc 	.word	0x20010dbc

08017ca4 <rt_object_detach>:
 * and the memory of static object is not freed.
 *
 * @param object the specified object to be detached.
 */
void rt_object_detach(rt_object_t object)
{
 8017ca4:	b590      	push	{r4, r7, lr}
 8017ca6:	b083      	sub	sp, #12
 8017ca8:	af00      	add	r7, sp, #0
 8017caa:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;

    /* object check */
    RT_ASSERT(object != RT_NULL);
 8017cac:	687b      	ldr	r3, [r7, #4]
 8017cae:	2b00      	cmp	r3, #0
 8017cb0:	d104      	bne.n	8017cbc <rt_object_detach+0x18>
 8017cb2:	480d      	ldr	r0, [pc, #52]	; (8017ce8 <rt_object_detach+0x44>)
 8017cb4:	490d      	ldr	r1, [pc, #52]	; (8017cec <rt_object_detach+0x48>)
 8017cb6:	22fb      	movs	r2, #251	; 0xfb
 8017cb8:	f7ff faa4 	bl	8017204 <rt_assert_handler>

    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
 8017cbc:	4b0c      	ldr	r3, [pc, #48]	; (8017cf0 <rt_object_detach+0x4c>)
 8017cbe:	681b      	ldr	r3, [r3, #0]
 8017cc0:	2b00      	cmp	r3, #0
 8017cc2:	d003      	beq.n	8017ccc <rt_object_detach+0x28>
 8017cc4:	4b0a      	ldr	r3, [pc, #40]	; (8017cf0 <rt_object_detach+0x4c>)
 8017cc6:	681b      	ldr	r3, [r3, #0]
 8017cc8:	6878      	ldr	r0, [r7, #4]
 8017cca:	4798      	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
 8017ccc:	f7e8 fa7e 	bl	80001cc <rt_hw_interrupt_disable>
 8017cd0:	4604      	mov	r4, r0

    /* remove from old list */
    rt_list_remove(&(object->list));
 8017cd2:	687b      	ldr	r3, [r7, #4]
 8017cd4:	330c      	adds	r3, #12
 8017cd6:	4618      	mov	r0, r3
 8017cd8:	f7ff ff8e 	bl	8017bf8 <rt_list_remove>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
 8017cdc:	4620      	mov	r0, r4
 8017cde:	f7e8 fa79 	bl	80001d4 <rt_hw_interrupt_enable>
}
 8017ce2:	370c      	adds	r7, #12
 8017ce4:	46bd      	mov	sp, r7
 8017ce6:	bd90      	pop	{r4, r7, pc}
 8017ce8:	08029344 	.word	0x08029344
 8017cec:	0802a960 	.word	0x0802a960
 8017cf0:	20010dc0 	.word	0x20010dc0

08017cf4 <rt_object_allocate>:
 * @param name the object name. In system, the object's name must be unique.
 *
 * @return object
 */
rt_object_t rt_object_allocate(enum rt_object_class_type type, const char *name)
{
 8017cf4:	b590      	push	{r4, r7, lr}
 8017cf6:	b087      	sub	sp, #28
 8017cf8:	af00      	add	r7, sp, #0
 8017cfa:	4603      	mov	r3, r0
 8017cfc:	6039      	str	r1, [r7, #0]
 8017cfe:	71fb      	strb	r3, [r7, #7]
    struct rt_object *object;
    register rt_base_t temp;
    struct rt_object_information *information;

    RT_DEBUG_NOT_IN_INTERRUPT;
 8017d00:	f7e8 fa64 	bl	80001cc <rt_hw_interrupt_disable>
 8017d04:	6178      	str	r0, [r7, #20]
 8017d06:	f7fe fc1f 	bl	8016548 <rt_interrupt_get_nest>
 8017d0a:	4603      	mov	r3, r0
 8017d0c:	2b00      	cmp	r3, #0
 8017d0e:	d009      	beq.n	8017d24 <rt_object_allocate+0x30>
 8017d10:	4821      	ldr	r0, [pc, #132]	; (8017d98 <rt_object_allocate+0xa4>)
 8017d12:	4922      	ldr	r1, [pc, #136]	; (8017d9c <rt_object_allocate+0xa8>)
 8017d14:	f7ff f9fc 	bl	8017110 <rt_kprintf>
 8017d18:	4821      	ldr	r0, [pc, #132]	; (8017da0 <rt_object_allocate+0xac>)
 8017d1a:	4920      	ldr	r1, [pc, #128]	; (8017d9c <rt_object_allocate+0xa8>)
 8017d1c:	f44f 728c 	mov.w	r2, #280	; 0x118
 8017d20:	f7ff fa70 	bl	8017204 <rt_assert_handler>
 8017d24:	6978      	ldr	r0, [r7, #20]
 8017d26:	f7e8 fa55 	bl	80001d4 <rt_hw_interrupt_enable>
     */
    information = (rt_module_self() != RT_NULL && (type != RT_Object_Class_Module)) ?
                  &rt_module_self()->module_object[type] : &rt_object_container[type];
#else
    /* get object information */
    information = &rt_object_container[type];
 8017d2a:	79fb      	ldrb	r3, [r7, #7]
 8017d2c:	011b      	lsls	r3, r3, #4
 8017d2e:	4a1d      	ldr	r2, [pc, #116]	; (8017da4 <rt_object_allocate+0xb0>)
 8017d30:	4413      	add	r3, r2
 8017d32:	613b      	str	r3, [r7, #16]
#endif

    object = (struct rt_object *)RT_KERNEL_MALLOC(information->object_size);
 8017d34:	693b      	ldr	r3, [r7, #16]
 8017d36:	68db      	ldr	r3, [r3, #12]
 8017d38:	4618      	mov	r0, r3
 8017d3a:	f7ff fb97 	bl	801746c <rt_malloc>
 8017d3e:	60f8      	str	r0, [r7, #12]
    if (object == RT_NULL)
 8017d40:	68fb      	ldr	r3, [r7, #12]
 8017d42:	2b00      	cmp	r3, #0
 8017d44:	d101      	bne.n	8017d4a <rt_object_allocate+0x56>
    {
        /* no memory can be allocated */
        return RT_NULL;
 8017d46:	2300      	movs	r3, #0
 8017d48:	e022      	b.n	8017d90 <rt_object_allocate+0x9c>
    }

    /* initialize object's parameters */

    /* set object type */
    object->type = type;
 8017d4a:	68fb      	ldr	r3, [r7, #12]
 8017d4c:	79fa      	ldrb	r2, [r7, #7]
 8017d4e:	721a      	strb	r2, [r3, #8]

    /* set object flag */
    object->flag = 0;
 8017d50:	68fb      	ldr	r3, [r7, #12]
 8017d52:	2200      	movs	r2, #0
 8017d54:	725a      	strb	r2, [r3, #9]
    }
    object->module_id = (void *)rt_module_self();
#endif

    /* copy name */
    rt_strncpy(object->name, name, RT_NAME_MAX);
 8017d56:	68fb      	ldr	r3, [r7, #12]
 8017d58:	4618      	mov	r0, r3
 8017d5a:	6839      	ldr	r1, [r7, #0]
 8017d5c:	2208      	movs	r2, #8
 8017d5e:	f7fe fd27 	bl	80167b0 <rt_strncpy>

    RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
 8017d62:	4b11      	ldr	r3, [pc, #68]	; (8017da8 <rt_object_allocate+0xb4>)
 8017d64:	681b      	ldr	r3, [r3, #0]
 8017d66:	2b00      	cmp	r3, #0
 8017d68:	d003      	beq.n	8017d72 <rt_object_allocate+0x7e>
 8017d6a:	4b0f      	ldr	r3, [pc, #60]	; (8017da8 <rt_object_allocate+0xb4>)
 8017d6c:	681b      	ldr	r3, [r3, #0]
 8017d6e:	68f8      	ldr	r0, [r7, #12]
 8017d70:	4798      	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
 8017d72:	f7e8 fa2b 	bl	80001cc <rt_hw_interrupt_disable>
 8017d76:	4604      	mov	r4, r0

    /* insert object into information object list */
    rt_list_insert_after(&(information->object_list), &(object->list));
 8017d78:	693b      	ldr	r3, [r7, #16]
 8017d7a:	1d1a      	adds	r2, r3, #4
 8017d7c:	68fb      	ldr	r3, [r7, #12]
 8017d7e:	330c      	adds	r3, #12
 8017d80:	4610      	mov	r0, r2
 8017d82:	4619      	mov	r1, r3
 8017d84:	f7ff ff20 	bl	8017bc8 <rt_list_insert_after>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
 8017d88:	4620      	mov	r0, r4
 8017d8a:	f7e8 fa23 	bl	80001d4 <rt_hw_interrupt_enable>

    /* return object */
    return object;
 8017d8e:	68fb      	ldr	r3, [r7, #12]
}
 8017d90:	4618      	mov	r0, r3
 8017d92:	371c      	adds	r7, #28
 8017d94:	46bd      	mov	sp, r7
 8017d96:	bd90      	pop	{r4, r7, pc}
 8017d98:	08029358 	.word	0x08029358
 8017d9c:	0802a974 	.word	0x0802a974
 8017da0:	0802937c 	.word	0x0802937c
 8017da4:	2001001c 	.word	0x2001001c
 8017da8:	20010dbc 	.word	0x20010dbc

08017dac <rt_object_delete>:
 * This function will delete an object and release object memory.
 *
 * @param object the specified object to be deleted.
 */
void rt_object_delete(rt_object_t object)
{
 8017dac:	b590      	push	{r4, r7, lr}
 8017dae:	b083      	sub	sp, #12
 8017db0:	af00      	add	r7, sp, #0
 8017db2:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;

    /* object check */
    RT_ASSERT(object != RT_NULL);
 8017db4:	687b      	ldr	r3, [r7, #4]
 8017db6:	2b00      	cmp	r3, #0
 8017db8:	d105      	bne.n	8017dc6 <rt_object_delete+0x1a>
 8017dba:	4815      	ldr	r0, [pc, #84]	; (8017e10 <rt_object_delete+0x64>)
 8017dbc:	4915      	ldr	r1, [pc, #84]	; (8017e14 <rt_object_delete+0x68>)
 8017dbe:	f240 1259 	movw	r2, #345	; 0x159
 8017dc2:	f7ff fa1f 	bl	8017204 <rt_assert_handler>
    RT_ASSERT(!(object->type & RT_Object_Class_Static));
 8017dc6:	687b      	ldr	r3, [r7, #4]
 8017dc8:	7a1b      	ldrb	r3, [r3, #8]
 8017dca:	b2db      	uxtb	r3, r3
 8017dcc:	b25b      	sxtb	r3, r3
 8017dce:	2b00      	cmp	r3, #0
 8017dd0:	da05      	bge.n	8017dde <rt_object_delete+0x32>
 8017dd2:	4811      	ldr	r0, [pc, #68]	; (8017e18 <rt_object_delete+0x6c>)
 8017dd4:	490f      	ldr	r1, [pc, #60]	; (8017e14 <rt_object_delete+0x68>)
 8017dd6:	f44f 72ad 	mov.w	r2, #346	; 0x15a
 8017dda:	f7ff fa13 	bl	8017204 <rt_assert_handler>

    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
 8017dde:	4b0f      	ldr	r3, [pc, #60]	; (8017e1c <rt_object_delete+0x70>)
 8017de0:	681b      	ldr	r3, [r3, #0]
 8017de2:	2b00      	cmp	r3, #0
 8017de4:	d003      	beq.n	8017dee <rt_object_delete+0x42>
 8017de6:	4b0d      	ldr	r3, [pc, #52]	; (8017e1c <rt_object_delete+0x70>)
 8017de8:	681b      	ldr	r3, [r3, #0]
 8017dea:	6878      	ldr	r0, [r7, #4]
 8017dec:	4798      	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
 8017dee:	f7e8 f9ed 	bl	80001cc <rt_hw_interrupt_disable>
 8017df2:	4604      	mov	r4, r0

    /* remove from old list */
    rt_list_remove(&(object->list));
 8017df4:	687b      	ldr	r3, [r7, #4]
 8017df6:	330c      	adds	r3, #12
 8017df8:	4618      	mov	r0, r3
 8017dfa:	f7ff fefd 	bl	8017bf8 <rt_list_remove>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
 8017dfe:	4620      	mov	r0, r4
 8017e00:	f7e8 f9e8 	bl	80001d4 <rt_hw_interrupt_enable>
        rt_module_free((rt_module_t)object->module_id, object);
    else
#endif

    /* free the memory of object */
    RT_KERNEL_FREE(object);
 8017e04:	6878      	ldr	r0, [r7, #4]
 8017e06:	f7ff fd75 	bl	80178f4 <rt_free>
}
 8017e0a:	370c      	adds	r7, #12
 8017e0c:	46bd      	mov	sp, r7
 8017e0e:	bd90      	pop	{r4, r7, pc}
 8017e10:	08029344 	.word	0x08029344
 8017e14:	0802a988 	.word	0x0802a988
 8017e18:	08029380 	.word	0x08029380
 8017e1c:	20010dc0 	.word	0x20010dc0

08017e20 <rt_object_is_systemobject>:
 * @param object the specified object to be judged.
 *
 * @return RT_TRUE if a system object, RT_FALSE for others.
 */
rt_bool_t rt_object_is_systemobject(rt_object_t object)
{
 8017e20:	b580      	push	{r7, lr}
 8017e22:	b082      	sub	sp, #8
 8017e24:	af00      	add	r7, sp, #0
 8017e26:	6078      	str	r0, [r7, #4]
    /* object check */
    RT_ASSERT(object != RT_NULL);
 8017e28:	687b      	ldr	r3, [r7, #4]
 8017e2a:	2b00      	cmp	r3, #0
 8017e2c:	d105      	bne.n	8017e3a <rt_object_is_systemobject+0x1a>
 8017e2e:	4809      	ldr	r0, [pc, #36]	; (8017e54 <rt_object_is_systemobject+0x34>)
 8017e30:	4909      	ldr	r1, [pc, #36]	; (8017e58 <rt_object_is_systemobject+0x38>)
 8017e32:	f44f 72bf 	mov.w	r2, #382	; 0x17e
 8017e36:	f7ff f9e5 	bl	8017204 <rt_assert_handler>

    if (object->type & RT_Object_Class_Static)
 8017e3a:	687b      	ldr	r3, [r7, #4]
 8017e3c:	7a1b      	ldrb	r3, [r3, #8]
 8017e3e:	b2db      	uxtb	r3, r3
 8017e40:	b25b      	sxtb	r3, r3
 8017e42:	2b00      	cmp	r3, #0
 8017e44:	da01      	bge.n	8017e4a <rt_object_is_systemobject+0x2a>
        return RT_TRUE;
 8017e46:	2301      	movs	r3, #1
 8017e48:	e000      	b.n	8017e4c <rt_object_is_systemobject+0x2c>

    return RT_FALSE;
 8017e4a:	2300      	movs	r3, #0
}
 8017e4c:	4618      	mov	r0, r3
 8017e4e:	3708      	adds	r7, #8
 8017e50:	46bd      	mov	sp, r7
 8017e52:	bd80      	pop	{r7, pc}
 8017e54:	08029344 	.word	0x08029344
 8017e58:	0802a99c 	.word	0x0802a99c

08017e5c <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 8017e5c:	b480      	push	{r7}
 8017e5e:	b083      	sub	sp, #12
 8017e60:	af00      	add	r7, sp, #0
 8017e62:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 8017e64:	687b      	ldr	r3, [r7, #4]
 8017e66:	687a      	ldr	r2, [r7, #4]
 8017e68:	605a      	str	r2, [r3, #4]
 8017e6a:	687b      	ldr	r3, [r7, #4]
 8017e6c:	685a      	ldr	r2, [r3, #4]
 8017e6e:	687b      	ldr	r3, [r7, #4]
 8017e70:	601a      	str	r2, [r3, #0]
}
 8017e72:	370c      	adds	r7, #12
 8017e74:	46bd      	mov	sp, r7
 8017e76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017e7a:	4770      	bx	lr

08017e7c <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 8017e7c:	b480      	push	{r7}
 8017e7e:	b083      	sub	sp, #12
 8017e80:	af00      	add	r7, sp, #0
 8017e82:	6078      	str	r0, [r7, #4]
 8017e84:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 8017e86:	687b      	ldr	r3, [r7, #4]
 8017e88:	685b      	ldr	r3, [r3, #4]
 8017e8a:	683a      	ldr	r2, [r7, #0]
 8017e8c:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 8017e8e:	687b      	ldr	r3, [r7, #4]
 8017e90:	685a      	ldr	r2, [r3, #4]
 8017e92:	683b      	ldr	r3, [r7, #0]
 8017e94:	605a      	str	r2, [r3, #4]

    l->prev = n;
 8017e96:	687b      	ldr	r3, [r7, #4]
 8017e98:	683a      	ldr	r2, [r7, #0]
 8017e9a:	605a      	str	r2, [r3, #4]
    n->next = l;
 8017e9c:	683b      	ldr	r3, [r7, #0]
 8017e9e:	687a      	ldr	r2, [r7, #4]
 8017ea0:	601a      	str	r2, [r3, #0]
}
 8017ea2:	370c      	adds	r7, #12
 8017ea4:	46bd      	mov	sp, r7
 8017ea6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017eaa:	4770      	bx	lr

08017eac <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 8017eac:	b480      	push	{r7}
 8017eae:	b083      	sub	sp, #12
 8017eb0:	af00      	add	r7, sp, #0
 8017eb2:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 8017eb4:	687b      	ldr	r3, [r7, #4]
 8017eb6:	681b      	ldr	r3, [r3, #0]
 8017eb8:	687a      	ldr	r2, [r7, #4]
 8017eba:	6852      	ldr	r2, [r2, #4]
 8017ebc:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 8017ebe:	687b      	ldr	r3, [r7, #4]
 8017ec0:	685b      	ldr	r3, [r3, #4]
 8017ec2:	687a      	ldr	r2, [r7, #4]
 8017ec4:	6812      	ldr	r2, [r2, #0]
 8017ec6:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 8017ec8:	687b      	ldr	r3, [r7, #4]
 8017eca:	687a      	ldr	r2, [r7, #4]
 8017ecc:	605a      	str	r2, [r3, #4]
 8017ece:	687b      	ldr	r3, [r7, #4]
 8017ed0:	685a      	ldr	r2, [r3, #4]
 8017ed2:	687b      	ldr	r3, [r7, #4]
 8017ed4:	601a      	str	r2, [r3, #0]
}
 8017ed6:	370c      	adds	r7, #12
 8017ed8:	46bd      	mov	sp, r7
 8017eda:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017ede:	4770      	bx	lr

08017ee0 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 8017ee0:	b480      	push	{r7}
 8017ee2:	b083      	sub	sp, #12
 8017ee4:	af00      	add	r7, sp, #0
 8017ee6:	6078      	str	r0, [r7, #4]
    return l->next == l;
 8017ee8:	687b      	ldr	r3, [r7, #4]
 8017eea:	681a      	ldr	r2, [r3, #0]
 8017eec:	687b      	ldr	r3, [r7, #4]
 8017eee:	429a      	cmp	r2, r3
 8017ef0:	bf0c      	ite	eq
 8017ef2:	2301      	moveq	r3, #1
 8017ef4:	2300      	movne	r3, #0
 8017ef6:	b2db      	uxtb	r3, r3
}
 8017ef8:	4618      	mov	r0, r3
 8017efa:	370c      	adds	r7, #12
 8017efc:	46bd      	mov	sp, r7
 8017efe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017f02:	4770      	bx	lr

08017f04 <_rt_scheduler_stack_check>:
/*@}*/
#endif

#ifdef RT_USING_OVERFLOW_CHECK
static void _rt_scheduler_stack_check(struct rt_thread *thread)
{
 8017f04:	b580      	push	{r7, lr}
 8017f06:	b084      	sub	sp, #16
 8017f08:	af00      	add	r7, sp, #0
 8017f0a:	6078      	str	r0, [r7, #4]
    RT_ASSERT(thread != RT_NULL);
 8017f0c:	687b      	ldr	r3, [r7, #4]
 8017f0e:	2b00      	cmp	r3, #0
 8017f10:	d104      	bne.n	8017f1c <_rt_scheduler_stack_check+0x18>
 8017f12:	481b      	ldr	r0, [pc, #108]	; (8017f80 <_rt_scheduler_stack_check+0x7c>)
 8017f14:	491b      	ldr	r1, [pc, #108]	; (8017f84 <_rt_scheduler_stack_check+0x80>)
 8017f16:	225a      	movs	r2, #90	; 0x5a
 8017f18:	f7ff f974 	bl	8017204 <rt_assert_handler>

    if ((rt_uint32_t)thread->sp <= (rt_uint32_t)thread->stack_addr ||
 8017f1c:	687b      	ldr	r3, [r7, #4]
 8017f1e:	69db      	ldr	r3, [r3, #28]
 8017f20:	461a      	mov	r2, r3
 8017f22:	687b      	ldr	r3, [r7, #4]
 8017f24:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8017f26:	429a      	cmp	r2, r3
 8017f28:	d90a      	bls.n	8017f40 <_rt_scheduler_stack_check+0x3c>
        (rt_uint32_t)thread->sp >
 8017f2a:	687b      	ldr	r3, [r7, #4]
 8017f2c:	69db      	ldr	r3, [r3, #28]
 8017f2e:	461a      	mov	r2, r3
        (rt_uint32_t)thread->stack_addr + (rt_uint32_t)thread->stack_size)
 8017f30:	687b      	ldr	r3, [r7, #4]
 8017f32:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8017f34:	4619      	mov	r1, r3
 8017f36:	687b      	ldr	r3, [r7, #4]
 8017f38:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 8017f3a:	440b      	add	r3, r1
#ifdef RT_USING_OVERFLOW_CHECK
static void _rt_scheduler_stack_check(struct rt_thread *thread)
{
    RT_ASSERT(thread != RT_NULL);

    if ((rt_uint32_t)thread->sp <= (rt_uint32_t)thread->stack_addr ||
 8017f3c:	429a      	cmp	r2, r3
 8017f3e:	d90e      	bls.n	8017f5e <_rt_scheduler_stack_check+0x5a>
        (rt_uint32_t)thread->sp >
        (rt_uint32_t)thread->stack_addr + (rt_uint32_t)thread->stack_size)
    {
        rt_uint32_t level;

        rt_kprintf("thread:%s stack overflow\n", thread->name);
 8017f40:	687b      	ldr	r3, [r7, #4]
 8017f42:	4811      	ldr	r0, [pc, #68]	; (8017f88 <_rt_scheduler_stack_check+0x84>)
 8017f44:	4619      	mov	r1, r3
 8017f46:	f7ff f8e3 	bl	8017110 <rt_kprintf>
        #ifdef RT_USING_FINSH
        {
            extern long list_thread(void);
            list_thread();
 8017f4a:	f004 fca1 	bl	801c890 <list_thread>
        }
        #endif
        level = rt_hw_interrupt_disable();
 8017f4e:	f7e8 f93d 	bl	80001cc <rt_hw_interrupt_disable>
 8017f52:	4603      	mov	r3, r0
 8017f54:	60fb      	str	r3, [r7, #12]
        while (level);
 8017f56:	68fb      	ldr	r3, [r7, #12]
 8017f58:	2b00      	cmp	r3, #0
 8017f5a:	d1fc      	bne.n	8017f56 <_rt_scheduler_stack_check+0x52>
    RT_ASSERT(thread != RT_NULL);

    if ((rt_uint32_t)thread->sp <= (rt_uint32_t)thread->stack_addr ||
        (rt_uint32_t)thread->sp >
        (rt_uint32_t)thread->stack_addr + (rt_uint32_t)thread->stack_size)
    {
 8017f5c:	e00c      	b.n	8017f78 <_rt_scheduler_stack_check+0x74>
        }
        #endif
        level = rt_hw_interrupt_disable();
        while (level);
    }
    else if ((rt_uint32_t)thread->sp <= ((rt_uint32_t)thread->stack_addr + 32))
 8017f5e:	687b      	ldr	r3, [r7, #4]
 8017f60:	69db      	ldr	r3, [r3, #28]
 8017f62:	461a      	mov	r2, r3
 8017f64:	687b      	ldr	r3, [r7, #4]
 8017f66:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8017f68:	3320      	adds	r3, #32
 8017f6a:	429a      	cmp	r2, r3
 8017f6c:	d804      	bhi.n	8017f78 <_rt_scheduler_stack_check+0x74>
    {
        rt_kprintf("warning: %s stack is close to end of stack address.\n",
                   thread->name);
 8017f6e:	687b      	ldr	r3, [r7, #4]
        level = rt_hw_interrupt_disable();
        while (level);
    }
    else if ((rt_uint32_t)thread->sp <= ((rt_uint32_t)thread->stack_addr + 32))
    {
        rt_kprintf("warning: %s stack is close to end of stack address.\n",
 8017f70:	4806      	ldr	r0, [pc, #24]	; (8017f8c <_rt_scheduler_stack_check+0x88>)
 8017f72:	4619      	mov	r1, r3
 8017f74:	f7ff f8cc 	bl	8017110 <rt_kprintf>
                   thread->name);
    }
}
 8017f78:	3710      	adds	r7, #16
 8017f7a:	46bd      	mov	sp, r7
 8017f7c:	bd80      	pop	{r7, pc}
 8017f7e:	bf00      	nop
 8017f80:	080293ac 	.word	0x080293ac
 8017f84:	0802a9b8 	.word	0x0802a9b8
 8017f88:	080293c0 	.word	0x080293c0
 8017f8c:	080293dc 	.word	0x080293dc

08017f90 <rt_system_scheduler_init>:
/**
 * @ingroup SystemInit
 * This function will initialize the system scheduler
 */
void rt_system_scheduler_init(void)
{
 8017f90:	b598      	push	{r3, r4, r7, lr}
 8017f92:	af00      	add	r7, sp, #0
    register rt_base_t offset;

    rt_scheduler_lock_nest = 0;
 8017f94:	4b0d      	ldr	r3, [pc, #52]	; (8017fcc <rt_system_scheduler_init+0x3c>)
 8017f96:	2200      	movs	r2, #0
 8017f98:	801a      	strh	r2, [r3, #0]

    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
                                      RT_THREAD_PRIORITY_MAX));

    for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
 8017f9a:	2400      	movs	r4, #0
 8017f9c:	e006      	b.n	8017fac <rt_system_scheduler_init+0x1c>
    {
        rt_list_init(&rt_thread_priority_table[offset]);
 8017f9e:	00e3      	lsls	r3, r4, #3
 8017fa0:	4a0b      	ldr	r2, [pc, #44]	; (8017fd0 <rt_system_scheduler_init+0x40>)
 8017fa2:	4413      	add	r3, r2
 8017fa4:	4618      	mov	r0, r3
 8017fa6:	f7ff ff59 	bl	8017e5c <rt_list_init>
    rt_scheduler_lock_nest = 0;

    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
                                      RT_THREAD_PRIORITY_MAX));

    for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
 8017faa:	3401      	adds	r4, #1
 8017fac:	2c1f      	cmp	r4, #31
 8017fae:	ddf6      	ble.n	8017f9e <rt_system_scheduler_init+0xe>
    {
        rt_list_init(&rt_thread_priority_table[offset]);
    }

    rt_current_priority = RT_THREAD_PRIORITY_MAX - 1;
 8017fb0:	4b08      	ldr	r3, [pc, #32]	; (8017fd4 <rt_system_scheduler_init+0x44>)
 8017fb2:	221f      	movs	r2, #31
 8017fb4:	701a      	strb	r2, [r3, #0]
    rt_current_thread = RT_NULL;
 8017fb6:	4b08      	ldr	r3, [pc, #32]	; (8017fd8 <rt_system_scheduler_init+0x48>)
 8017fb8:	2200      	movs	r2, #0
 8017fba:	601a      	str	r2, [r3, #0]

    /* initialize ready priority group */
    rt_thread_ready_priority_group = 0;
 8017fbc:	4b07      	ldr	r3, [pc, #28]	; (8017fdc <rt_system_scheduler_init+0x4c>)
 8017fbe:	2200      	movs	r2, #0
 8017fc0:	601a      	str	r2, [r3, #0]
    /* initialize ready table */
    rt_memset(rt_thread_ready_table, 0, sizeof(rt_thread_ready_table));
#endif

    /* initialize thread defunct */
    rt_list_init(&rt_thread_defunct);
 8017fc2:	4807      	ldr	r0, [pc, #28]	; (8017fe0 <rt_system_scheduler_init+0x50>)
 8017fc4:	f7ff ff4a 	bl	8017e5c <rt_list_init>
}
 8017fc8:	bd98      	pop	{r3, r4, r7, pc}
 8017fca:	bf00      	nop
 8017fcc:	20010dc4 	.word	0x20010dc4
 8017fd0:	20012a70 	.word	0x20012a70
 8017fd4:	20012b70 	.word	0x20012b70
 8017fd8:	20012b74 	.word	0x20012b74
 8017fdc:	20012b78 	.word	0x20012b78
 8017fe0:	20012b7c 	.word	0x20012b7c

08017fe4 <rt_system_scheduler_start>:
 * @ingroup SystemInit
 * This function will startup scheduler. It will select one thread
 * with the highest priority level, then switch to it.
 */
void rt_system_scheduler_start(void)
{
 8017fe4:	b598      	push	{r3, r4, r7, lr}
 8017fe6:	af00      	add	r7, sp, #0
    register rt_ubase_t number;

    number = __rt_ffs(rt_thread_ready_priority_group) - 1;
    highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
#else
    highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
 8017fe8:	4b0a      	ldr	r3, [pc, #40]	; (8018014 <rt_system_scheduler_start+0x30>)
 8017fea:	681b      	ldr	r3, [r3, #0]
 8017fec:	4618      	mov	r0, r3
 8017fee:	f7ff f8cf 	bl	8017190 <__rt_ffs>
 8017ff2:	4603      	mov	r3, r0
 8017ff4:	3b01      	subs	r3, #1
 8017ff6:	461c      	mov	r4, r3
#endif

    /* get switch to thread */
    to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
 8017ff8:	4b07      	ldr	r3, [pc, #28]	; (8018018 <rt_system_scheduler_start+0x34>)
 8017ffa:	f853 3034 	ldr.w	r3, [r3, r4, lsl #3]
 8017ffe:	f1a3 0414 	sub.w	r4, r3, #20
                              struct rt_thread,
                              tlist);

    rt_current_thread = to_thread;
 8018002:	4b06      	ldr	r3, [pc, #24]	; (801801c <rt_system_scheduler_start+0x38>)
 8018004:	601c      	str	r4, [r3, #0]

    /* switch to new thread */
    rt_hw_context_switch_to((rt_uint32_t)&to_thread->sp);
 8018006:	f104 031c 	add.w	r3, r4, #28
 801800a:	4618      	mov	r0, r3
 801800c:	f7e8 f92a 	bl	8000264 <rt_hw_context_switch_to>

    /* never come back */
}
 8018010:	bd98      	pop	{r3, r4, r7, pc}
 8018012:	bf00      	nop
 8018014:	20012b78 	.word	0x20012b78
 8018018:	20012a70 	.word	0x20012a70
 801801c:	20012b74 	.word	0x20012b74

08018020 <rt_schedule>:
/**
 * This function will perform one schedule. It will select one thread
 * with the highest priority level, then switch to it.
 */
void rt_schedule(void)
{
 8018020:	b590      	push	{r4, r7, lr}
 8018022:	b085      	sub	sp, #20
 8018024:	af00      	add	r7, sp, #0
    rt_base_t level;
    struct rt_thread *to_thread;
    struct rt_thread *from_thread;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 8018026:	f7e8 f8d1 	bl	80001cc <rt_hw_interrupt_disable>
 801802a:	60f8      	str	r0, [r7, #12]

    /* check the scheduler is enabled or not */
    if (rt_scheduler_lock_nest == 0)
 801802c:	4b24      	ldr	r3, [pc, #144]	; (80180c0 <rt_schedule+0xa0>)
 801802e:	881b      	ldrh	r3, [r3, #0]
 8018030:	2b00      	cmp	r3, #0
 8018032:	d13e      	bne.n	80180b2 <rt_schedule+0x92>
    {
        register rt_ubase_t highest_ready_priority;

#if RT_THREAD_PRIORITY_MAX <= 32
        highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
 8018034:	4b23      	ldr	r3, [pc, #140]	; (80180c4 <rt_schedule+0xa4>)
 8018036:	681b      	ldr	r3, [r3, #0]
 8018038:	4618      	mov	r0, r3
 801803a:	f7ff f8a9 	bl	8017190 <__rt_ffs>
 801803e:	4603      	mov	r3, r0
 8018040:	3b01      	subs	r3, #1
 8018042:	461c      	mov	r4, r3
        number = __rt_ffs(rt_thread_ready_priority_group) - 1;
        highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
#endif

        /* get switch to thread */
        to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
 8018044:	4b20      	ldr	r3, [pc, #128]	; (80180c8 <rt_schedule+0xa8>)
 8018046:	f853 3034 	ldr.w	r3, [r3, r4, lsl #3]
 801804a:	3b14      	subs	r3, #20
 801804c:	60bb      	str	r3, [r7, #8]
                                  struct rt_thread,
                                  tlist);

        /* if the destination thread is not the same as current thread */
        if (to_thread != rt_current_thread)
 801804e:	4b1f      	ldr	r3, [pc, #124]	; (80180cc <rt_schedule+0xac>)
 8018050:	681b      	ldr	r3, [r3, #0]
 8018052:	68ba      	ldr	r2, [r7, #8]
 8018054:	429a      	cmp	r2, r3
 8018056:	d02c      	beq.n	80180b2 <rt_schedule+0x92>
        {
            rt_current_priority = (rt_uint8_t)highest_ready_priority;
 8018058:	b2e2      	uxtb	r2, r4
 801805a:	4b1d      	ldr	r3, [pc, #116]	; (80180d0 <rt_schedule+0xb0>)
 801805c:	701a      	strb	r2, [r3, #0]
            from_thread         = rt_current_thread;
 801805e:	4b1b      	ldr	r3, [pc, #108]	; (80180cc <rt_schedule+0xac>)
 8018060:	681b      	ldr	r3, [r3, #0]
 8018062:	607b      	str	r3, [r7, #4]
            rt_current_thread   = to_thread;
 8018064:	4a19      	ldr	r2, [pc, #100]	; (80180cc <rt_schedule+0xac>)
 8018066:	68bb      	ldr	r3, [r7, #8]
 8018068:	6013      	str	r3, [r2, #0]

            RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (from_thread, to_thread));
 801806a:	4b1a      	ldr	r3, [pc, #104]	; (80180d4 <rt_schedule+0xb4>)
 801806c:	681b      	ldr	r3, [r3, #0]
 801806e:	2b00      	cmp	r3, #0
 8018070:	d004      	beq.n	801807c <rt_schedule+0x5c>
 8018072:	4b18      	ldr	r3, [pc, #96]	; (80180d4 <rt_schedule+0xb4>)
 8018074:	681b      	ldr	r3, [r3, #0]
 8018076:	6878      	ldr	r0, [r7, #4]
 8018078:	68b9      	ldr	r1, [r7, #8]
 801807a:	4798      	blx	r3
                          rt_interrupt_nest, highest_ready_priority,
                          RT_NAME_MAX, to_thread->name, to_thread->sp,
                          RT_NAME_MAX, from_thread->name, from_thread->sp));

#ifdef RT_USING_OVERFLOW_CHECK
            _rt_scheduler_stack_check(to_thread);
 801807c:	68b8      	ldr	r0, [r7, #8]
 801807e:	f7ff ff41 	bl	8017f04 <_rt_scheduler_stack_check>
#endif

            if (rt_interrupt_nest == 0)
 8018082:	4b15      	ldr	r3, [pc, #84]	; (80180d8 <rt_schedule+0xb8>)
 8018084:	781b      	ldrb	r3, [r3, #0]
 8018086:	b2db      	uxtb	r3, r3
 8018088:	2b00      	cmp	r3, #0
 801808a:	d109      	bne.n	80180a0 <rt_schedule+0x80>
            {
                rt_hw_context_switch((rt_uint32_t)&from_thread->sp,
 801808c:	687b      	ldr	r3, [r7, #4]
 801808e:	331c      	adds	r3, #28
 8018090:	461a      	mov	r2, r3
                                     (rt_uint32_t)&to_thread->sp);
 8018092:	68bb      	ldr	r3, [r7, #8]
 8018094:	331c      	adds	r3, #28
            _rt_scheduler_stack_check(to_thread);
#endif

            if (rt_interrupt_nest == 0)
            {
                rt_hw_context_switch((rt_uint32_t)&from_thread->sp,
 8018096:	4610      	mov	r0, r2
 8018098:	4619      	mov	r1, r3
 801809a:	f7e8 f89e 	bl	80001da <rt_hw_context_switch>
 801809e:	e008      	b.n	80180b2 <rt_schedule+0x92>
            }
            else
            {
                RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("switch in interrupt\n"));

                rt_hw_context_switch_interrupt((rt_uint32_t)&from_thread->sp,
 80180a0:	687b      	ldr	r3, [r7, #4]
 80180a2:	331c      	adds	r3, #28
 80180a4:	461a      	mov	r2, r3
                                               (rt_uint32_t)&to_thread->sp);
 80180a6:	68bb      	ldr	r3, [r7, #8]
 80180a8:	331c      	adds	r3, #28
            }
            else
            {
                RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("switch in interrupt\n"));

                rt_hw_context_switch_interrupt((rt_uint32_t)&from_thread->sp,
 80180aa:	4610      	mov	r0, r2
 80180ac:	4619      	mov	r1, r3
 80180ae:	f7e8 f894 	bl	80001da <rt_hw_context_switch>
            }
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 80180b2:	68f8      	ldr	r0, [r7, #12]
 80180b4:	f7e8 f88e 	bl	80001d4 <rt_hw_interrupt_enable>
}
 80180b8:	3714      	adds	r7, #20
 80180ba:	46bd      	mov	sp, r7
 80180bc:	bd90      	pop	{r4, r7, pc}
 80180be:	bf00      	nop
 80180c0:	20010dc4 	.word	0x20010dc4
 80180c4:	20012b78 	.word	0x20012b78
 80180c8:	20012a70 	.word	0x20012a70
 80180cc:	20012b74 	.word	0x20012b74
 80180d0:	20012b70 	.word	0x20012b70
 80180d4:	20010dc8 	.word	0x20010dc8
 80180d8:	20012a5c 	.word	0x20012a5c

080180dc <rt_schedule_insert_thread>:
 *
 * @param thread the thread to be inserted
 * @note Please do not invoke this function in user application.
 */
void rt_schedule_insert_thread(struct rt_thread *thread)
{
 80180dc:	b590      	push	{r4, r7, lr}
 80180de:	b083      	sub	sp, #12
 80180e0:	af00      	add	r7, sp, #0
 80180e2:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;

    RT_ASSERT(thread != RT_NULL);
 80180e4:	687b      	ldr	r3, [r7, #4]
 80180e6:	2b00      	cmp	r3, #0
 80180e8:	d105      	bne.n	80180f6 <rt_schedule_insert_thread+0x1a>
 80180ea:	4813      	ldr	r0, [pc, #76]	; (8018138 <rt_schedule_insert_thread+0x5c>)
 80180ec:	4913      	ldr	r1, [pc, #76]	; (801813c <rt_schedule_insert_thread+0x60>)
 80180ee:	f240 120f 	movw	r2, #271	; 0x10f
 80180f2:	f7ff f887 	bl	8017204 <rt_assert_handler>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 80180f6:	f7e8 f869 	bl	80001cc <rt_hw_interrupt_disable>
 80180fa:	4604      	mov	r4, r0

    /* change stat */
    thread->stat = RT_THREAD_READY;
 80180fc:	687b      	ldr	r3, [r7, #4]
 80180fe:	2201      	movs	r2, #1
 8018100:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* insert thread to ready list */
    rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
 8018104:	687b      	ldr	r3, [r7, #4]
 8018106:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 801810a:	00db      	lsls	r3, r3, #3
 801810c:	4a0c      	ldr	r2, [pc, #48]	; (8018140 <rt_schedule_insert_thread+0x64>)
 801810e:	441a      	add	r2, r3
 8018110:	687b      	ldr	r3, [r7, #4]
 8018112:	3314      	adds	r3, #20
 8018114:	4610      	mov	r0, r2
 8018116:	4619      	mov	r1, r3
 8018118:	f7ff feb0 	bl	8017e7c <rt_list_insert_before>
#endif

#if RT_THREAD_PRIORITY_MAX > 32
    rt_thread_ready_table[thread->number] |= thread->high_mask;
#endif
    rt_thread_ready_priority_group |= thread->number_mask;
 801811c:	687b      	ldr	r3, [r7, #4]
 801811e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8018120:	4b08      	ldr	r3, [pc, #32]	; (8018144 <rt_schedule_insert_thread+0x68>)
 8018122:	681b      	ldr	r3, [r3, #0]
 8018124:	4313      	orrs	r3, r2
 8018126:	4a07      	ldr	r2, [pc, #28]	; (8018144 <rt_schedule_insert_thread+0x68>)
 8018128:	6013      	str	r3, [r2, #0]

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 801812a:	4620      	mov	r0, r4
 801812c:	f7e8 f852 	bl	80001d4 <rt_hw_interrupt_enable>
}
 8018130:	370c      	adds	r7, #12
 8018132:	46bd      	mov	sp, r7
 8018134:	bd90      	pop	{r4, r7, pc}
 8018136:	bf00      	nop
 8018138:	080293ac 	.word	0x080293ac
 801813c:	0802a9d4 	.word	0x0802a9d4
 8018140:	20012a70 	.word	0x20012a70
 8018144:	20012b78 	.word	0x20012b78

08018148 <rt_schedule_remove_thread>:
 * @param thread the thread to be removed
 *
 * @note Please do not invoke this function in user application.
 */
void rt_schedule_remove_thread(struct rt_thread *thread)
{
 8018148:	b590      	push	{r4, r7, lr}
 801814a:	b083      	sub	sp, #12
 801814c:	af00      	add	r7, sp, #0
 801814e:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;

    RT_ASSERT(thread != RT_NULL);
 8018150:	687b      	ldr	r3, [r7, #4]
 8018152:	2b00      	cmp	r3, #0
 8018154:	d105      	bne.n	8018162 <rt_schedule_remove_thread+0x1a>
 8018156:	4814      	ldr	r0, [pc, #80]	; (80181a8 <rt_schedule_remove_thread+0x60>)
 8018158:	4914      	ldr	r1, [pc, #80]	; (80181ac <rt_schedule_remove_thread+0x64>)
 801815a:	f240 123d 	movw	r2, #317	; 0x13d
 801815e:	f7ff f851 	bl	8017204 <rt_assert_handler>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8018162:	f7e8 f833 	bl	80001cc <rt_hw_interrupt_disable>
 8018166:	4604      	mov	r4, r0
                  thread->number_mask,
                  thread->high_mask));
#endif

    /* remove thread from ready list */
    rt_list_remove(&(thread->tlist));
 8018168:	687b      	ldr	r3, [r7, #4]
 801816a:	3314      	adds	r3, #20
 801816c:	4618      	mov	r0, r3
 801816e:	f7ff fe9d 	bl	8017eac <rt_list_remove>
    if (rt_list_isempty(&(rt_thread_priority_table[thread->current_priority])))
 8018172:	687b      	ldr	r3, [r7, #4]
 8018174:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8018178:	00db      	lsls	r3, r3, #3
 801817a:	4a0d      	ldr	r2, [pc, #52]	; (80181b0 <rt_schedule_remove_thread+0x68>)
 801817c:	4413      	add	r3, r2
 801817e:	4618      	mov	r0, r3
 8018180:	f7ff feae 	bl	8017ee0 <rt_list_isempty>
 8018184:	4603      	mov	r3, r0
 8018186:	2b00      	cmp	r3, #0
 8018188:	d007      	beq.n	801819a <rt_schedule_remove_thread+0x52>
        if (rt_thread_ready_table[thread->number] == 0)
        {
            rt_thread_ready_priority_group &= ~thread->number_mask;
        }
#else
        rt_thread_ready_priority_group &= ~thread->number_mask;
 801818a:	687b      	ldr	r3, [r7, #4]
 801818c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801818e:	43da      	mvns	r2, r3
 8018190:	4b08      	ldr	r3, [pc, #32]	; (80181b4 <rt_schedule_remove_thread+0x6c>)
 8018192:	681b      	ldr	r3, [r3, #0]
 8018194:	4013      	ands	r3, r2
 8018196:	4a07      	ldr	r2, [pc, #28]	; (80181b4 <rt_schedule_remove_thread+0x6c>)
 8018198:	6013      	str	r3, [r2, #0]
#endif
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 801819a:	4620      	mov	r0, r4
 801819c:	f7e8 f81a 	bl	80001d4 <rt_hw_interrupt_enable>
}
 80181a0:	370c      	adds	r7, #12
 80181a2:	46bd      	mov	sp, r7
 80181a4:	bd90      	pop	{r4, r7, pc}
 80181a6:	bf00      	nop
 80181a8:	080293ac 	.word	0x080293ac
 80181ac:	0802a9f0 	.word	0x0802a9f0
 80181b0:	20012a70 	.word	0x20012a70
 80181b4:	20012b78 	.word	0x20012b78

080181b8 <rt_enter_critical>:

/**
 * This function will lock the thread scheduler.
 */
void rt_enter_critical(void)
{
 80181b8:	b598      	push	{r3, r4, r7, lr}
 80181ba:	af00      	add	r7, sp, #0
    register rt_base_t level;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 80181bc:	f7e8 f806 	bl	80001cc <rt_hw_interrupt_disable>
 80181c0:	4604      	mov	r4, r0

    /*
     * the maximal number of nest is RT_UINT16_MAX, which is big
     * enough and does not check here
     */
    rt_scheduler_lock_nest ++;
 80181c2:	4b06      	ldr	r3, [pc, #24]	; (80181dc <rt_enter_critical+0x24>)
 80181c4:	881b      	ldrh	r3, [r3, #0]
 80181c6:	b29b      	uxth	r3, r3
 80181c8:	b29b      	uxth	r3, r3
 80181ca:	3301      	adds	r3, #1
 80181cc:	b29b      	uxth	r3, r3
 80181ce:	b29a      	uxth	r2, r3
 80181d0:	4b02      	ldr	r3, [pc, #8]	; (80181dc <rt_enter_critical+0x24>)
 80181d2:	801a      	strh	r2, [r3, #0]

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 80181d4:	4620      	mov	r0, r4
 80181d6:	f7e7 fffd 	bl	80001d4 <rt_hw_interrupt_enable>
}
 80181da:	bd98      	pop	{r3, r4, r7, pc}
 80181dc:	20010dc4 	.word	0x20010dc4

080181e0 <rt_exit_critical>:

/**
 * This function will unlock the thread scheduler.
 */
void rt_exit_critical(void)
{
 80181e0:	b598      	push	{r3, r4, r7, lr}
 80181e2:	af00      	add	r7, sp, #0
    register rt_base_t level;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 80181e4:	f7e7 fff2 	bl	80001cc <rt_hw_interrupt_disable>
 80181e8:	4604      	mov	r4, r0

    rt_scheduler_lock_nest --;
 80181ea:	4b0d      	ldr	r3, [pc, #52]	; (8018220 <rt_exit_critical+0x40>)
 80181ec:	881b      	ldrh	r3, [r3, #0]
 80181ee:	b29b      	uxth	r3, r3
 80181f0:	b29b      	uxth	r3, r3
 80181f2:	3b01      	subs	r3, #1
 80181f4:	b29b      	uxth	r3, r3
 80181f6:	b29a      	uxth	r2, r3
 80181f8:	4b09      	ldr	r3, [pc, #36]	; (8018220 <rt_exit_critical+0x40>)
 80181fa:	801a      	strh	r2, [r3, #0]

    if (rt_scheduler_lock_nest <= 0)
 80181fc:	4b08      	ldr	r3, [pc, #32]	; (8018220 <rt_exit_critical+0x40>)
 80181fe:	881b      	ldrh	r3, [r3, #0]
 8018200:	b21b      	sxth	r3, r3
 8018202:	2b00      	cmp	r3, #0
 8018204:	dc08      	bgt.n	8018218 <rt_exit_critical+0x38>
    {
        rt_scheduler_lock_nest = 0;
 8018206:	4b06      	ldr	r3, [pc, #24]	; (8018220 <rt_exit_critical+0x40>)
 8018208:	2200      	movs	r2, #0
 801820a:	801a      	strh	r2, [r3, #0]
        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 801820c:	4620      	mov	r0, r4
 801820e:	f7e7 ffe1 	bl	80001d4 <rt_hw_interrupt_enable>

        rt_schedule();
 8018212:	f7ff ff05 	bl	8018020 <rt_schedule>
 8018216:	e002      	b.n	801821e <rt_exit_critical+0x3e>
    }
    else
    {
        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 8018218:	4620      	mov	r0, r4
 801821a:	f7e7 ffdb 	bl	80001d4 <rt_hw_interrupt_enable>
    }
}
 801821e:	bd98      	pop	{r3, r4, r7, pc}
 8018220:	20010dc4 	.word	0x20010dc4

08018224 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 8018224:	b480      	push	{r7}
 8018226:	b083      	sub	sp, #12
 8018228:	af00      	add	r7, sp, #0
 801822a:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 801822c:	687b      	ldr	r3, [r7, #4]
 801822e:	687a      	ldr	r2, [r7, #4]
 8018230:	605a      	str	r2, [r3, #4]
 8018232:	687b      	ldr	r3, [r7, #4]
 8018234:	685a      	ldr	r2, [r3, #4]
 8018236:	687b      	ldr	r3, [r7, #4]
 8018238:	601a      	str	r2, [r3, #0]
}
 801823a:	370c      	adds	r7, #12
 801823c:	46bd      	mov	sp, r7
 801823e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018242:	4770      	bx	lr

08018244 <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
 8018244:	b480      	push	{r7}
 8018246:	b083      	sub	sp, #12
 8018248:	af00      	add	r7, sp, #0
 801824a:	6078      	str	r0, [r7, #4]
 801824c:	6039      	str	r1, [r7, #0]
    l->next->prev = n;
 801824e:	687b      	ldr	r3, [r7, #4]
 8018250:	681b      	ldr	r3, [r3, #0]
 8018252:	683a      	ldr	r2, [r7, #0]
 8018254:	605a      	str	r2, [r3, #4]
    n->next = l->next;
 8018256:	687b      	ldr	r3, [r7, #4]
 8018258:	681a      	ldr	r2, [r3, #0]
 801825a:	683b      	ldr	r3, [r7, #0]
 801825c:	601a      	str	r2, [r3, #0]

    l->next = n;
 801825e:	687b      	ldr	r3, [r7, #4]
 8018260:	683a      	ldr	r2, [r7, #0]
 8018262:	601a      	str	r2, [r3, #0]
    n->prev = l;
 8018264:	683b      	ldr	r3, [r7, #0]
 8018266:	687a      	ldr	r2, [r7, #4]
 8018268:	605a      	str	r2, [r3, #4]
}
 801826a:	370c      	adds	r7, #12
 801826c:	46bd      	mov	sp, r7
 801826e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018272:	4770      	bx	lr

08018274 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 8018274:	b480      	push	{r7}
 8018276:	b083      	sub	sp, #12
 8018278:	af00      	add	r7, sp, #0
 801827a:	6078      	str	r0, [r7, #4]
 801827c:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 801827e:	687b      	ldr	r3, [r7, #4]
 8018280:	685b      	ldr	r3, [r3, #4]
 8018282:	683a      	ldr	r2, [r7, #0]
 8018284:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 8018286:	687b      	ldr	r3, [r7, #4]
 8018288:	685a      	ldr	r2, [r3, #4]
 801828a:	683b      	ldr	r3, [r7, #0]
 801828c:	605a      	str	r2, [r3, #4]

    l->prev = n;
 801828e:	687b      	ldr	r3, [r7, #4]
 8018290:	683a      	ldr	r2, [r7, #0]
 8018292:	605a      	str	r2, [r3, #4]
    n->next = l;
 8018294:	683b      	ldr	r3, [r7, #0]
 8018296:	687a      	ldr	r2, [r7, #4]
 8018298:	601a      	str	r2, [r3, #0]
}
 801829a:	370c      	adds	r7, #12
 801829c:	46bd      	mov	sp, r7
 801829e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80182a2:	4770      	bx	lr

080182a4 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 80182a4:	b480      	push	{r7}
 80182a6:	b083      	sub	sp, #12
 80182a8:	af00      	add	r7, sp, #0
 80182aa:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 80182ac:	687b      	ldr	r3, [r7, #4]
 80182ae:	681b      	ldr	r3, [r3, #0]
 80182b0:	687a      	ldr	r2, [r7, #4]
 80182b2:	6852      	ldr	r2, [r2, #4]
 80182b4:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 80182b6:	687b      	ldr	r3, [r7, #4]
 80182b8:	685b      	ldr	r3, [r3, #4]
 80182ba:	687a      	ldr	r2, [r7, #4]
 80182bc:	6812      	ldr	r2, [r2, #0]
 80182be:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 80182c0:	687b      	ldr	r3, [r7, #4]
 80182c2:	687a      	ldr	r2, [r7, #4]
 80182c4:	605a      	str	r2, [r3, #4]
 80182c6:	687b      	ldr	r3, [r7, #4]
 80182c8:	685a      	ldr	r2, [r3, #4]
 80182ca:	687b      	ldr	r3, [r7, #4]
 80182cc:	601a      	str	r2, [r3, #0]
}
 80182ce:	370c      	adds	r7, #12
 80182d0:	46bd      	mov	sp, r7
 80182d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80182d6:	4770      	bx	lr

080182d8 <rt_thread_exit>:
extern rt_list_t rt_thread_priority_table[RT_THREAD_PRIORITY_MAX];
extern struct rt_thread *rt_current_thread;
extern rt_list_t rt_thread_defunct;

static void rt_thread_exit(void)
{
 80182d8:	b590      	push	{r4, r7, lr}
 80182da:	b083      	sub	sp, #12
 80182dc:	af00      	add	r7, sp, #0
    struct rt_thread *thread;
    register rt_base_t level;

    /* get current thread */
    thread = rt_current_thread;
 80182de:	4b17      	ldr	r3, [pc, #92]	; (801833c <rt_thread_exit+0x64>)
 80182e0:	681b      	ldr	r3, [r3, #0]
 80182e2:	607b      	str	r3, [r7, #4]

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 80182e4:	f7e7 ff72 	bl	80001cc <rt_hw_interrupt_disable>
 80182e8:	4604      	mov	r4, r0

    /* remove from schedule */
    rt_schedule_remove_thread(thread);
 80182ea:	6878      	ldr	r0, [r7, #4]
 80182ec:	f7ff ff2c 	bl	8018148 <rt_schedule_remove_thread>
    /* change stat */
    thread->stat = RT_THREAD_CLOSE;
 80182f0:	687b      	ldr	r3, [r7, #4]
 80182f2:	2204      	movs	r2, #4
 80182f4:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* remove it from timer list */
    rt_timer_detach(&thread->thread_timer);
 80182f8:	687b      	ldr	r3, [r7, #4]
 80182fa:	334c      	adds	r3, #76	; 0x4c
 80182fc:	4618      	mov	r0, r3
 80182fe:	f000 fbc3 	bl	8018a88 <rt_timer_detach>

    if ((rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE) &&
 8018302:	6878      	ldr	r0, [r7, #4]
 8018304:	f7ff fd8c 	bl	8017e20 <rt_object_is_systemobject>
 8018308:	4603      	mov	r3, r0
 801830a:	2b01      	cmp	r3, #1
 801830c:	d107      	bne.n	801831e <rt_thread_exit+0x46>
        thread->cleanup == RT_NULL)
 801830e:	687b      	ldr	r3, [r7, #4]
 8018310:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    thread->stat = RT_THREAD_CLOSE;

    /* remove it from timer list */
    rt_timer_detach(&thread->thread_timer);

    if ((rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE) &&
 8018312:	2b00      	cmp	r3, #0
 8018314:	d103      	bne.n	801831e <rt_thread_exit+0x46>
        thread->cleanup == RT_NULL)
    {
        rt_object_detach((rt_object_t)thread);
 8018316:	6878      	ldr	r0, [r7, #4]
 8018318:	f7ff fcc4 	bl	8017ca4 <rt_object_detach>
 801831c:	e005      	b.n	801832a <rt_thread_exit+0x52>
    }
    else
    {
        /* insert to defunct thread list */
        rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
 801831e:	687b      	ldr	r3, [r7, #4]
 8018320:	3314      	adds	r3, #20
 8018322:	4807      	ldr	r0, [pc, #28]	; (8018340 <rt_thread_exit+0x68>)
 8018324:	4619      	mov	r1, r3
 8018326:	f7ff ff8d 	bl	8018244 <rt_list_insert_after>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 801832a:	4620      	mov	r0, r4
 801832c:	f7e7 ff52 	bl	80001d4 <rt_hw_interrupt_enable>

    /* switch to next task */
    rt_schedule();
 8018330:	f7ff fe76 	bl	8018020 <rt_schedule>
}
 8018334:	370c      	adds	r7, #12
 8018336:	46bd      	mov	sp, r7
 8018338:	bd90      	pop	{r4, r7, pc}
 801833a:	bf00      	nop
 801833c:	20012b74 	.word	0x20012b74
 8018340:	20012b7c 	.word	0x20012b7c

08018344 <_rt_thread_init>:
                                void             *parameter,
                                void             *stack_start,
                                rt_uint32_t       stack_size,
                                rt_uint8_t        priority,
                                rt_uint32_t       tick)
{
 8018344:	b580      	push	{r7, lr}
 8018346:	b086      	sub	sp, #24
 8018348:	af02      	add	r7, sp, #8
 801834a:	60f8      	str	r0, [r7, #12]
 801834c:	60b9      	str	r1, [r7, #8]
 801834e:	607a      	str	r2, [r7, #4]
 8018350:	603b      	str	r3, [r7, #0]
    /* init thread list */
    rt_list_init(&(thread->tlist));
 8018352:	68fb      	ldr	r3, [r7, #12]
 8018354:	3314      	adds	r3, #20
 8018356:	4618      	mov	r0, r3
 8018358:	f7ff ff64 	bl	8018224 <rt_list_init>

    thread->entry = (void *)entry;
 801835c:	68fb      	ldr	r3, [r7, #12]
 801835e:	687a      	ldr	r2, [r7, #4]
 8018360:	621a      	str	r2, [r3, #32]
    thread->parameter = parameter;
 8018362:	68fb      	ldr	r3, [r7, #12]
 8018364:	683a      	ldr	r2, [r7, #0]
 8018366:	625a      	str	r2, [r3, #36]	; 0x24

    /* stack init */
    thread->stack_addr = stack_start;
 8018368:	68fb      	ldr	r3, [r7, #12]
 801836a:	69ba      	ldr	r2, [r7, #24]
 801836c:	629a      	str	r2, [r3, #40]	; 0x28
    thread->stack_size = (rt_uint16_t)stack_size;
 801836e:	69fb      	ldr	r3, [r7, #28]
 8018370:	b29a      	uxth	r2, r3
 8018372:	68fb      	ldr	r3, [r7, #12]
 8018374:	859a      	strh	r2, [r3, #44]	; 0x2c

    /* init thread stack */
    rt_memset(thread->stack_addr, '#', thread->stack_size);
 8018376:	68fb      	ldr	r3, [r7, #12]
 8018378:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 801837a:	68fb      	ldr	r3, [r7, #12]
 801837c:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 801837e:	4610      	mov	r0, r2
 8018380:	2123      	movs	r1, #35	; 0x23
 8018382:	461a      	mov	r2, r3
 8018384:	f7fe f90c 	bl	80165a0 <rt_memset>
    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
 8018388:	68fb      	ldr	r3, [r7, #12]
 801838a:	6a18      	ldr	r0, [r3, #32]
 801838c:	68fb      	ldr	r3, [r7, #12]
 801838e:	6a59      	ldr	r1, [r3, #36]	; 0x24
        (void *)((char *)thread->stack_addr + thread->stack_size - 4),
 8018390:	68fb      	ldr	r3, [r7, #12]
 8018392:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8018394:	68fb      	ldr	r3, [r7, #12]
 8018396:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 8018398:	3b04      	subs	r3, #4
 801839a:	4413      	add	r3, r2
    thread->stack_addr = stack_start;
    thread->stack_size = (rt_uint16_t)stack_size;

    /* init thread stack */
    rt_memset(thread->stack_addr, '#', thread->stack_size);
    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
 801839c:	461a      	mov	r2, r3
 801839e:	4b1f      	ldr	r3, [pc, #124]	; (801841c <_rt_thread_init+0xd8>)
 80183a0:	f000 fe6e 	bl	8019080 <rt_hw_stack_init>
 80183a4:	4602      	mov	r2, r0
 80183a6:	68fb      	ldr	r3, [r7, #12]
 80183a8:	61da      	str	r2, [r3, #28]
        (void *)((char *)thread->stack_addr + thread->stack_size - 4),
        (void *)rt_thread_exit);

    /* priority init */
    RT_ASSERT(priority < RT_THREAD_PRIORITY_MAX);
 80183aa:	f897 3020 	ldrb.w	r3, [r7, #32]
 80183ae:	2b1f      	cmp	r3, #31
 80183b0:	d904      	bls.n	80183bc <_rt_thread_init+0x78>
 80183b2:	481b      	ldr	r0, [pc, #108]	; (8018420 <_rt_thread_init+0xdc>)
 80183b4:	491b      	ldr	r1, [pc, #108]	; (8018424 <_rt_thread_init+0xe0>)
 80183b6:	226e      	movs	r2, #110	; 0x6e
 80183b8:	f7fe ff24 	bl	8017204 <rt_assert_handler>
    thread->init_priority    = priority;
 80183bc:	68fb      	ldr	r3, [r7, #12]
 80183be:	f897 2020 	ldrb.w	r2, [r7, #32]
 80183c2:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
    thread->current_priority = priority;
 80183c6:	68fb      	ldr	r3, [r7, #12]
 80183c8:	f897 2020 	ldrb.w	r2, [r7, #32]
 80183cc:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* tick init */
    thread->init_tick      = tick;
 80183d0:	68fb      	ldr	r3, [r7, #12]
 80183d2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80183d4:	645a      	str	r2, [r3, #68]	; 0x44
    thread->remaining_tick = tick;
 80183d6:	68fb      	ldr	r3, [r7, #12]
 80183d8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80183da:	649a      	str	r2, [r3, #72]	; 0x48

    /* error and flags */
    thread->error = RT_EOK;
 80183dc:	68fb      	ldr	r3, [r7, #12]
 80183de:	2200      	movs	r2, #0
 80183e0:	631a      	str	r2, [r3, #48]	; 0x30
    thread->stat  = RT_THREAD_INIT;
 80183e2:	68fb      	ldr	r3, [r7, #12]
 80183e4:	2200      	movs	r2, #0
 80183e6:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* initialize cleanup function and user data */
    thread->cleanup   = 0;
 80183ea:	68fb      	ldr	r3, [r7, #12]
 80183ec:	2200      	movs	r2, #0
 80183ee:	679a      	str	r2, [r3, #120]	; 0x78
    thread->user_data = 0;
 80183f0:	68fb      	ldr	r3, [r7, #12]
 80183f2:	2200      	movs	r2, #0
 80183f4:	67da      	str	r2, [r3, #124]	; 0x7c

    /* init thread timer */
    rt_timer_init(&(thread->thread_timer),
 80183f6:	68fb      	ldr	r3, [r7, #12]
 80183f8:	f103 014c 	add.w	r1, r3, #76	; 0x4c
                  thread->name,
 80183fc:	68fa      	ldr	r2, [r7, #12]
    /* initialize cleanup function and user data */
    thread->cleanup   = 0;
    thread->user_data = 0;

    /* init thread timer */
    rt_timer_init(&(thread->thread_timer),
 80183fe:	2300      	movs	r3, #0
 8018400:	9300      	str	r3, [sp, #0]
 8018402:	2300      	movs	r3, #0
 8018404:	9301      	str	r3, [sp, #4]
 8018406:	4608      	mov	r0, r1
 8018408:	4611      	mov	r1, r2
 801840a:	4a07      	ldr	r2, [pc, #28]	; (8018428 <_rt_thread_init+0xe4>)
 801840c:	68fb      	ldr	r3, [r7, #12]
 801840e:	f000 fb17 	bl	8018a40 <rt_timer_init>
                  rt_thread_timeout,
                  thread,
                  0,
                  RT_TIMER_FLAG_ONE_SHOT);

    return RT_EOK;
 8018412:	2300      	movs	r3, #0
}
 8018414:	4618      	mov	r0, r3
 8018416:	3710      	adds	r7, #16
 8018418:	46bd      	mov	sp, r7
 801841a:	bd80      	pop	{r7, pc}
 801841c:	080182d9 	.word	0x080182d9
 8018420:	08029414 	.word	0x08029414
 8018424:	0802aa0c 	.word	0x0802aa0c
 8018428:	08018869 	.word	0x08018869

0801842c <rt_thread_init>:
                        void             *parameter,
                        void             *stack_start,
                        rt_uint32_t       stack_size,
                        rt_uint8_t        priority,
                        rt_uint32_t       tick)
{
 801842c:	b580      	push	{r7, lr}
 801842e:	b088      	sub	sp, #32
 8018430:	af04      	add	r7, sp, #16
 8018432:	60f8      	str	r0, [r7, #12]
 8018434:	60b9      	str	r1, [r7, #8]
 8018436:	607a      	str	r2, [r7, #4]
 8018438:	603b      	str	r3, [r7, #0]
    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 801843a:	68fb      	ldr	r3, [r7, #12]
 801843c:	2b00      	cmp	r3, #0
 801843e:	d104      	bne.n	801844a <rt_thread_init+0x1e>
 8018440:	4812      	ldr	r0, [pc, #72]	; (801848c <rt_thread_init+0x60>)
 8018442:	4913      	ldr	r1, [pc, #76]	; (8018490 <rt_thread_init+0x64>)
 8018444:	22a8      	movs	r2, #168	; 0xa8
 8018446:	f7fe fedd 	bl	8017204 <rt_assert_handler>
    RT_ASSERT(stack_start != RT_NULL);
 801844a:	69bb      	ldr	r3, [r7, #24]
 801844c:	2b00      	cmp	r3, #0
 801844e:	d104      	bne.n	801845a <rt_thread_init+0x2e>
 8018450:	4810      	ldr	r0, [pc, #64]	; (8018494 <rt_thread_init+0x68>)
 8018452:	490f      	ldr	r1, [pc, #60]	; (8018490 <rt_thread_init+0x64>)
 8018454:	22a9      	movs	r2, #169	; 0xa9
 8018456:	f7fe fed5 	bl	8017204 <rt_assert_handler>

    /* init thread object */
    rt_object_init((rt_object_t)thread, RT_Object_Class_Thread, name);
 801845a:	68f8      	ldr	r0, [r7, #12]
 801845c:	2100      	movs	r1, #0
 801845e:	68ba      	ldr	r2, [r7, #8]
 8018460:	f7ff fbea 	bl	8017c38 <rt_object_init>

    return _rt_thread_init(thread,
 8018464:	69bb      	ldr	r3, [r7, #24]
 8018466:	9300      	str	r3, [sp, #0]
 8018468:	69fb      	ldr	r3, [r7, #28]
 801846a:	9301      	str	r3, [sp, #4]
 801846c:	f897 3020 	ldrb.w	r3, [r7, #32]
 8018470:	9302      	str	r3, [sp, #8]
 8018472:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018474:	9303      	str	r3, [sp, #12]
 8018476:	68f8      	ldr	r0, [r7, #12]
 8018478:	68b9      	ldr	r1, [r7, #8]
 801847a:	687a      	ldr	r2, [r7, #4]
 801847c:	683b      	ldr	r3, [r7, #0]
 801847e:	f7ff ff61 	bl	8018344 <_rt_thread_init>
 8018482:	4603      	mov	r3, r0
                           parameter,
                           stack_start,
                           stack_size,
                           priority,
                           tick);
}
 8018484:	4618      	mov	r0, r3
 8018486:	3710      	adds	r7, #16
 8018488:	46bd      	mov	sp, r7
 801848a:	bd80      	pop	{r7, pc}
 801848c:	08029438 	.word	0x08029438
 8018490:	0802aa1c 	.word	0x0802aa1c
 8018494:	0802944c 	.word	0x0802944c

08018498 <rt_thread_self>:
 * This function will return self thread object
 *
 * @return the self thread object
 */
rt_thread_t rt_thread_self(void)
{
 8018498:	b480      	push	{r7}
 801849a:	af00      	add	r7, sp, #0
    return rt_current_thread;
 801849c:	4b03      	ldr	r3, [pc, #12]	; (80184ac <rt_thread_self+0x14>)
 801849e:	681b      	ldr	r3, [r3, #0]
}
 80184a0:	4618      	mov	r0, r3
 80184a2:	46bd      	mov	sp, r7
 80184a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80184a8:	4770      	bx	lr
 80184aa:	bf00      	nop
 80184ac:	20012b74 	.word	0x20012b74

080184b0 <rt_thread_startup>:
 * @param thread the thread to be started
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_startup(rt_thread_t thread)
{
 80184b0:	b580      	push	{r7, lr}
 80184b2:	b082      	sub	sp, #8
 80184b4:	af00      	add	r7, sp, #0
 80184b6:	6078      	str	r0, [r7, #4]
    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 80184b8:	687b      	ldr	r3, [r7, #4]
 80184ba:	2b00      	cmp	r3, #0
 80184bc:	d104      	bne.n	80184c8 <rt_thread_startup+0x18>
 80184be:	4818      	ldr	r0, [pc, #96]	; (8018520 <rt_thread_startup+0x70>)
 80184c0:	4918      	ldr	r1, [pc, #96]	; (8018524 <rt_thread_startup+0x74>)
 80184c2:	22ce      	movs	r2, #206	; 0xce
 80184c4:	f7fe fe9e 	bl	8017204 <rt_assert_handler>
    RT_ASSERT(thread->stat == RT_THREAD_INIT);
 80184c8:	687b      	ldr	r3, [r7, #4]
 80184ca:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 80184ce:	2b00      	cmp	r3, #0
 80184d0:	d004      	beq.n	80184dc <rt_thread_startup+0x2c>
 80184d2:	4815      	ldr	r0, [pc, #84]	; (8018528 <rt_thread_startup+0x78>)
 80184d4:	4913      	ldr	r1, [pc, #76]	; (8018524 <rt_thread_startup+0x74>)
 80184d6:	22cf      	movs	r2, #207	; 0xcf
 80184d8:	f7fe fe94 	bl	8017204 <rt_assert_handler>

    /* set current priority to init priority */
    thread->current_priority = thread->init_priority;
 80184dc:	687b      	ldr	r3, [r7, #4]
 80184de:	f893 2036 	ldrb.w	r2, [r3, #54]	; 0x36
 80184e2:	687b      	ldr	r3, [r7, #4]
 80184e4:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
#if RT_THREAD_PRIORITY_MAX > 32
    thread->number      = thread->current_priority >> 3;            /* 5bit */
    thread->number_mask = 1L << thread->number;
    thread->high_mask   = 1L << (thread->current_priority & 0x07);  /* 3bit */
#else
    thread->number_mask = 1L << thread->current_priority;
 80184e8:	687b      	ldr	r3, [r7, #4]
 80184ea:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 80184ee:	461a      	mov	r2, r3
 80184f0:	2301      	movs	r3, #1
 80184f2:	4093      	lsls	r3, r2
 80184f4:	461a      	mov	r2, r3
 80184f6:	687b      	ldr	r3, [r7, #4]
 80184f8:	639a      	str	r2, [r3, #56]	; 0x38
#endif

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("startup a thread:%s with priority:%d\n",
                                   thread->name, thread->init_priority));
    /* change thread stat */
    thread->stat = RT_THREAD_SUSPEND;
 80184fa:	687b      	ldr	r3, [r7, #4]
 80184fc:	2202      	movs	r2, #2
 80184fe:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    /* then resume it */
    rt_thread_resume(thread);
 8018502:	6878      	ldr	r0, [r7, #4]
 8018504:	f000 f97e 	bl	8018804 <rt_thread_resume>
    if (rt_thread_self() != RT_NULL)
 8018508:	f7ff ffc6 	bl	8018498 <rt_thread_self>
 801850c:	4603      	mov	r3, r0
 801850e:	2b00      	cmp	r3, #0
 8018510:	d001      	beq.n	8018516 <rt_thread_startup+0x66>
    {
        /* do a scheduling */
        rt_schedule();
 8018512:	f7ff fd85 	bl	8018020 <rt_schedule>
    }

    return RT_EOK;
 8018516:	2300      	movs	r3, #0
}
 8018518:	4618      	mov	r0, r3
 801851a:	3708      	adds	r7, #8
 801851c:	46bd      	mov	sp, r7
 801851e:	bd80      	pop	{r7, pc}
 8018520:	08029438 	.word	0x08029438
 8018524:	0802aa2c 	.word	0x0802aa2c
 8018528:	08029464 	.word	0x08029464

0801852c <rt_thread_create>:
                             void (*entry)(void *parameter),
                             void       *parameter,
                             rt_uint32_t stack_size,
                             rt_uint8_t  priority,
                             rt_uint32_t tick)
{
 801852c:	b580      	push	{r7, lr}
 801852e:	b08a      	sub	sp, #40	; 0x28
 8018530:	af04      	add	r7, sp, #16
 8018532:	60f8      	str	r0, [r7, #12]
 8018534:	60b9      	str	r1, [r7, #8]
 8018536:	607a      	str	r2, [r7, #4]
 8018538:	603b      	str	r3, [r7, #0]
    struct rt_thread *thread;
    void *stack_start;

    thread = (struct rt_thread *)rt_object_allocate(RT_Object_Class_Thread,
 801853a:	2000      	movs	r0, #0
 801853c:	68f9      	ldr	r1, [r7, #12]
 801853e:	f7ff fbd9 	bl	8017cf4 <rt_object_allocate>
 8018542:	6178      	str	r0, [r7, #20]
                                                    name);
    if (thread == RT_NULL)
 8018544:	697b      	ldr	r3, [r7, #20]
 8018546:	2b00      	cmp	r3, #0
 8018548:	d101      	bne.n	801854e <rt_thread_create+0x22>
        return RT_NULL;
 801854a:	2300      	movs	r3, #0
 801854c:	e01b      	b.n	8018586 <rt_thread_create+0x5a>

    stack_start = (void *)RT_KERNEL_MALLOC(stack_size);
 801854e:	6838      	ldr	r0, [r7, #0]
 8018550:	f7fe ff8c 	bl	801746c <rt_malloc>
 8018554:	6138      	str	r0, [r7, #16]
    if (stack_start == RT_NULL)
 8018556:	693b      	ldr	r3, [r7, #16]
 8018558:	2b00      	cmp	r3, #0
 801855a:	d104      	bne.n	8018566 <rt_thread_create+0x3a>
    {
        /* allocate stack failure */
        rt_object_delete((rt_object_t)thread);
 801855c:	6978      	ldr	r0, [r7, #20]
 801855e:	f7ff fc25 	bl	8017dac <rt_object_delete>

        return RT_NULL;
 8018562:	2300      	movs	r3, #0
 8018564:	e00f      	b.n	8018586 <rt_thread_create+0x5a>
    }

    _rt_thread_init(thread,
 8018566:	693b      	ldr	r3, [r7, #16]
 8018568:	9300      	str	r3, [sp, #0]
 801856a:	683b      	ldr	r3, [r7, #0]
 801856c:	9301      	str	r3, [sp, #4]
 801856e:	f897 3020 	ldrb.w	r3, [r7, #32]
 8018572:	9302      	str	r3, [sp, #8]
 8018574:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018576:	9303      	str	r3, [sp, #12]
 8018578:	6978      	ldr	r0, [r7, #20]
 801857a:	68f9      	ldr	r1, [r7, #12]
 801857c:	68ba      	ldr	r2, [r7, #8]
 801857e:	687b      	ldr	r3, [r7, #4]
 8018580:	f7ff fee0 	bl	8018344 <_rt_thread_init>
                    stack_start,
                    stack_size,
                    priority,
                    tick);

    return thread;
 8018584:	697b      	ldr	r3, [r7, #20]
}
 8018586:	4618      	mov	r0, r3
 8018588:	3718      	adds	r7, #24
 801858a:	46bd      	mov	sp, r7
 801858c:	bd80      	pop	{r7, pc}
 801858e:	bf00      	nop

08018590 <rt_thread_delete>:
 * @param thread the thread to be deleted
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_delete(rt_thread_t thread)
{
 8018590:	b580      	push	{r7, lr}
 8018592:	b084      	sub	sp, #16
 8018594:	af00      	add	r7, sp, #0
 8018596:	6078      	str	r0, [r7, #4]
    rt_base_t lock;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 8018598:	687b      	ldr	r3, [r7, #4]
 801859a:	2b00      	cmp	r3, #0
 801859c:	d105      	bne.n	80185aa <rt_thread_delete+0x1a>
 801859e:	4811      	ldr	r0, [pc, #68]	; (80185e4 <rt_thread_delete+0x54>)
 80185a0:	4911      	ldr	r1, [pc, #68]	; (80185e8 <rt_thread_delete+0x58>)
 80185a2:	f240 1259 	movw	r2, #345	; 0x159
 80185a6:	f7fe fe2d 	bl	8017204 <rt_assert_handler>

    /* remove from schedule */
    rt_schedule_remove_thread(thread);
 80185aa:	6878      	ldr	r0, [r7, #4]
 80185ac:	f7ff fdcc 	bl	8018148 <rt_schedule_remove_thread>

    /* release thread timer */
    rt_timer_detach(&(thread->thread_timer));
 80185b0:	687b      	ldr	r3, [r7, #4]
 80185b2:	334c      	adds	r3, #76	; 0x4c
 80185b4:	4618      	mov	r0, r3
 80185b6:	f000 fa67 	bl	8018a88 <rt_timer_detach>

    /* change stat */
    thread->stat = RT_THREAD_CLOSE;
 80185ba:	687b      	ldr	r3, [r7, #4]
 80185bc:	2204      	movs	r2, #4
 80185be:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* disable interrupt */
    lock = rt_hw_interrupt_disable();
 80185c2:	f7e7 fe03 	bl	80001cc <rt_hw_interrupt_disable>
 80185c6:	60f8      	str	r0, [r7, #12]

    /* insert to defunct thread list */
    rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
 80185c8:	687b      	ldr	r3, [r7, #4]
 80185ca:	3314      	adds	r3, #20
 80185cc:	4807      	ldr	r0, [pc, #28]	; (80185ec <rt_thread_delete+0x5c>)
 80185ce:	4619      	mov	r1, r3
 80185d0:	f7ff fe38 	bl	8018244 <rt_list_insert_after>

    /* enable interrupt */
    rt_hw_interrupt_enable(lock);
 80185d4:	68f8      	ldr	r0, [r7, #12]
 80185d6:	f7e7 fdfd 	bl	80001d4 <rt_hw_interrupt_enable>

    return RT_EOK;
 80185da:	2300      	movs	r3, #0
}
 80185dc:	4618      	mov	r0, r3
 80185de:	3710      	adds	r7, #16
 80185e0:	46bd      	mov	sp, r7
 80185e2:	bd80      	pop	{r7, pc}
 80185e4:	08029438 	.word	0x08029438
 80185e8:	0802aa40 	.word	0x0802aa40
 80185ec:	20012b7c 	.word	0x20012b7c

080185f0 <rt_thread_yield>:
 * is still in READY state.
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_yield(void)
{
 80185f0:	b590      	push	{r4, r7, lr}
 80185f2:	b083      	sub	sp, #12
 80185f4:	af00      	add	r7, sp, #0
    register rt_base_t level;
    struct rt_thread *thread;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 80185f6:	f7e7 fde9 	bl	80001cc <rt_hw_interrupt_disable>
 80185fa:	4604      	mov	r4, r0

    /* set to current thread */
    thread = rt_current_thread;
 80185fc:	4b16      	ldr	r3, [pc, #88]	; (8018658 <rt_thread_yield+0x68>)
 80185fe:	681b      	ldr	r3, [r3, #0]
 8018600:	607b      	str	r3, [r7, #4]

    /* if the thread stat is READY and on ready queue list */
    if (thread->stat == RT_THREAD_READY &&
 8018602:	687b      	ldr	r3, [r7, #4]
 8018604:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8018608:	2b01      	cmp	r3, #1
 801860a:	d11d      	bne.n	8018648 <rt_thread_yield+0x58>
        thread->tlist.next != thread->tlist.prev)
 801860c:	687b      	ldr	r3, [r7, #4]
 801860e:	695a      	ldr	r2, [r3, #20]
 8018610:	687b      	ldr	r3, [r7, #4]
 8018612:	699b      	ldr	r3, [r3, #24]

    /* set to current thread */
    thread = rt_current_thread;

    /* if the thread stat is READY and on ready queue list */
    if (thread->stat == RT_THREAD_READY &&
 8018614:	429a      	cmp	r2, r3
 8018616:	d017      	beq.n	8018648 <rt_thread_yield+0x58>
        thread->tlist.next != thread->tlist.prev)
    {
        /* remove thread from thread list */
        rt_list_remove(&(thread->tlist));
 8018618:	687b      	ldr	r3, [r7, #4]
 801861a:	3314      	adds	r3, #20
 801861c:	4618      	mov	r0, r3
 801861e:	f7ff fe41 	bl	80182a4 <rt_list_remove>

        /* put thread to end of ready queue */
        rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
 8018622:	687b      	ldr	r3, [r7, #4]
 8018624:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8018628:	00db      	lsls	r3, r3, #3
 801862a:	4a0c      	ldr	r2, [pc, #48]	; (801865c <rt_thread_yield+0x6c>)
 801862c:	441a      	add	r2, r3
 801862e:	687b      	ldr	r3, [r7, #4]
 8018630:	3314      	adds	r3, #20
 8018632:	4610      	mov	r0, r2
 8018634:	4619      	mov	r1, r3
 8018636:	f7ff fe1d 	bl	8018274 <rt_list_insert_before>
                              &(thread->tlist));

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 801863a:	4620      	mov	r0, r4
 801863c:	f7e7 fdca 	bl	80001d4 <rt_hw_interrupt_enable>

        rt_schedule();
 8018640:	f7ff fcee 	bl	8018020 <rt_schedule>

        return RT_EOK;
 8018644:	2300      	movs	r3, #0
 8018646:	e003      	b.n	8018650 <rt_thread_yield+0x60>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 8018648:	4620      	mov	r0, r4
 801864a:	f7e7 fdc3 	bl	80001d4 <rt_hw_interrupt_enable>

    return RT_EOK;
 801864e:	2300      	movs	r3, #0
}
 8018650:	4618      	mov	r0, r3
 8018652:	370c      	adds	r7, #12
 8018654:	46bd      	mov	sp, r7
 8018656:	bd90      	pop	{r4, r7, pc}
 8018658:	20012b74 	.word	0x20012b74
 801865c:	20012a70 	.word	0x20012a70

08018660 <rt_thread_sleep>:
 * @param tick the sleep ticks
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_sleep(rt_tick_t tick)
{
 8018660:	b590      	push	{r4, r7, lr}
 8018662:	b085      	sub	sp, #20
 8018664:	af00      	add	r7, sp, #0
 8018666:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;
    struct rt_thread *thread;

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 8018668:	f7e7 fdb0 	bl	80001cc <rt_hw_interrupt_disable>
 801866c:	4604      	mov	r4, r0
    /* set to current thread */
    thread = rt_current_thread;
 801866e:	4b17      	ldr	r3, [pc, #92]	; (80186cc <rt_thread_sleep+0x6c>)
 8018670:	681b      	ldr	r3, [r3, #0]
 8018672:	60fb      	str	r3, [r7, #12]
    RT_ASSERT(thread != RT_NULL);
 8018674:	68fb      	ldr	r3, [r7, #12]
 8018676:	2b00      	cmp	r3, #0
 8018678:	d105      	bne.n	8018686 <rt_thread_sleep+0x26>
 801867a:	4815      	ldr	r0, [pc, #84]	; (80186d0 <rt_thread_sleep+0x70>)
 801867c:	4915      	ldr	r1, [pc, #84]	; (80186d4 <rt_thread_sleep+0x74>)
 801867e:	f44f 72d7 	mov.w	r2, #430	; 0x1ae
 8018682:	f7fe fdbf 	bl	8017204 <rt_assert_handler>

    /* suspend thread */
    rt_thread_suspend(thread);
 8018686:	68f8      	ldr	r0, [r7, #12]
 8018688:	f000 f88c 	bl	80187a4 <rt_thread_suspend>

    /* reset the timeout of thread timer and start it */
    rt_timer_control(&(thread->thread_timer), RT_TIMER_CTRL_SET_TIME, &tick);
 801868c:	68fb      	ldr	r3, [r7, #12]
 801868e:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 8018692:	1d3b      	adds	r3, r7, #4
 8018694:	4610      	mov	r0, r2
 8018696:	2100      	movs	r1, #0
 8018698:	461a      	mov	r2, r3
 801869a:	f000 fb7d 	bl	8018d98 <rt_timer_control>
    rt_timer_start(&(thread->thread_timer));
 801869e:	68fb      	ldr	r3, [r7, #12]
 80186a0:	334c      	adds	r3, #76	; 0x4c
 80186a2:	4618      	mov	r0, r3
 80186a4:	f000 fa32 	bl	8018b0c <rt_timer_start>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 80186a8:	4620      	mov	r0, r4
 80186aa:	f7e7 fd93 	bl	80001d4 <rt_hw_interrupt_enable>
	
    rt_schedule();
 80186ae:	f7ff fcb7 	bl	8018020 <rt_schedule>

    /* clear error number of this thread to RT_EOK */
    if (thread->error == -RT_ETIMEOUT)
 80186b2:	68fb      	ldr	r3, [r7, #12]
 80186b4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80186b6:	f113 0f02 	cmn.w	r3, #2
 80186ba:	d102      	bne.n	80186c2 <rt_thread_sleep+0x62>
        thread->error = RT_EOK;
 80186bc:	68fb      	ldr	r3, [r7, #12]
 80186be:	2200      	movs	r2, #0
 80186c0:	631a      	str	r2, [r3, #48]	; 0x30

    return RT_EOK;
 80186c2:	2300      	movs	r3, #0
}
 80186c4:	4618      	mov	r0, r3
 80186c6:	3714      	adds	r7, #20
 80186c8:	46bd      	mov	sp, r7
 80186ca:	bd90      	pop	{r4, r7, pc}
 80186cc:	20012b74 	.word	0x20012b74
 80186d0:	08029438 	.word	0x08029438
 80186d4:	0802aa54 	.word	0x0802aa54

080186d8 <rt_thread_delay>:
 * @param tick the delay ticks
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_delay(rt_tick_t tick)
{
 80186d8:	b580      	push	{r7, lr}
 80186da:	b082      	sub	sp, #8
 80186dc:	af00      	add	r7, sp, #0
 80186de:	6078      	str	r0, [r7, #4]
    return rt_thread_sleep(tick);
 80186e0:	6878      	ldr	r0, [r7, #4]
 80186e2:	f7ff ffbd 	bl	8018660 <rt_thread_sleep>
 80186e6:	4603      	mov	r3, r0
}
 80186e8:	4618      	mov	r0, r3
 80186ea:	3708      	adds	r7, #8
 80186ec:	46bd      	mov	sp, r7
 80186ee:	bd80      	pop	{r7, pc}

080186f0 <rt_thread_control>:
 * @param arg the argument of control command
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_control(rt_thread_t thread, rt_uint8_t cmd, void *arg)
{
 80186f0:	b590      	push	{r4, r7, lr}
 80186f2:	b085      	sub	sp, #20
 80186f4:	af00      	add	r7, sp, #0
 80186f6:	60f8      	str	r0, [r7, #12]
 80186f8:	460b      	mov	r3, r1
 80186fa:	607a      	str	r2, [r7, #4]
 80186fc:	72fb      	strb	r3, [r7, #11]
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 80186fe:	68fb      	ldr	r3, [r7, #12]
 8018700:	2b00      	cmp	r3, #0
 8018702:	d105      	bne.n	8018710 <rt_thread_control+0x20>
 8018704:	4825      	ldr	r0, [pc, #148]	; (801879c <rt_thread_control+0xac>)
 8018706:	4926      	ldr	r1, [pc, #152]	; (80187a0 <rt_thread_control+0xb0>)
 8018708:	f240 12e1 	movw	r2, #481	; 0x1e1
 801870c:	f7fe fd7a 	bl	8017204 <rt_assert_handler>

    switch (cmd)
 8018710:	7afb      	ldrb	r3, [r7, #11]
 8018712:	2b01      	cmp	r3, #1
 8018714:	d038      	beq.n	8018788 <rt_thread_control+0x98>
 8018716:	2b02      	cmp	r3, #2
 8018718:	d002      	beq.n	8018720 <rt_thread_control+0x30>
 801871a:	2b00      	cmp	r3, #0
 801871c:	d02f      	beq.n	801877e <rt_thread_control+0x8e>
    case RT_THREAD_CTRL_CLOSE:
        return rt_thread_delete(thread);
#endif

    default:
        break;
 801871e:	e038      	b.n	8018792 <rt_thread_control+0xa2>

    switch (cmd)
    {
    case RT_THREAD_CTRL_CHANGE_PRIORITY:
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
 8018720:	f7e7 fd54 	bl	80001cc <rt_hw_interrupt_disable>
 8018724:	4604      	mov	r4, r0

        /* for ready thread, change queue */
        if (thread->stat == RT_THREAD_READY)
 8018726:	68fb      	ldr	r3, [r7, #12]
 8018728:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801872c:	2b01      	cmp	r3, #1
 801872e:	d114      	bne.n	801875a <rt_thread_control+0x6a>
        {
            /* remove thread from schedule queue first */
            rt_schedule_remove_thread(thread);
 8018730:	68f8      	ldr	r0, [r7, #12]
 8018732:	f7ff fd09 	bl	8018148 <rt_schedule_remove_thread>

            /* change thread priority */
            thread->current_priority = *(rt_uint8_t *)arg;
 8018736:	687b      	ldr	r3, [r7, #4]
 8018738:	781a      	ldrb	r2, [r3, #0]
 801873a:	68fb      	ldr	r3, [r7, #12]
 801873c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
#if RT_THREAD_PRIORITY_MAX > 32
            thread->number      = thread->current_priority >> 3;            /* 5bit */
            thread->number_mask = 1 << thread->number;
            thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
#else
            thread->number_mask = 1 << thread->current_priority;
 8018740:	68fb      	ldr	r3, [r7, #12]
 8018742:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8018746:	461a      	mov	r2, r3
 8018748:	2301      	movs	r3, #1
 801874a:	4093      	lsls	r3, r2
 801874c:	461a      	mov	r2, r3
 801874e:	68fb      	ldr	r3, [r7, #12]
 8018750:	639a      	str	r2, [r3, #56]	; 0x38
#endif

            /* insert thread to schedule queue again */
            rt_schedule_insert_thread(thread);
 8018752:	68f8      	ldr	r0, [r7, #12]
 8018754:	f7ff fcc2 	bl	80180dc <rt_schedule_insert_thread>
 8018758:	e00d      	b.n	8018776 <rt_thread_control+0x86>
        }
        else
        {
            thread->current_priority = *(rt_uint8_t *)arg;
 801875a:	687b      	ldr	r3, [r7, #4]
 801875c:	781a      	ldrb	r2, [r3, #0]
 801875e:	68fb      	ldr	r3, [r7, #12]
 8018760:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
#if RT_THREAD_PRIORITY_MAX > 32
            thread->number      = thread->current_priority >> 3;            /* 5bit */
            thread->number_mask = 1 << thread->number;
            thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
#else
            thread->number_mask = 1 << thread->current_priority;
 8018764:	68fb      	ldr	r3, [r7, #12]
 8018766:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 801876a:	461a      	mov	r2, r3
 801876c:	2301      	movs	r3, #1
 801876e:	4093      	lsls	r3, r2
 8018770:	461a      	mov	r2, r3
 8018772:	68fb      	ldr	r3, [r7, #12]
 8018774:	639a      	str	r2, [r3, #56]	; 0x38
#endif
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
 8018776:	4620      	mov	r0, r4
 8018778:	f7e7 fd2c 	bl	80001d4 <rt_hw_interrupt_enable>
        break;
 801877c:	e009      	b.n	8018792 <rt_thread_control+0xa2>

    case RT_THREAD_CTRL_STARTUP:
        return rt_thread_startup(thread);
 801877e:	68f8      	ldr	r0, [r7, #12]
 8018780:	f7ff fe96 	bl	80184b0 <rt_thread_startup>
 8018784:	4603      	mov	r3, r0
 8018786:	e005      	b.n	8018794 <rt_thread_control+0xa4>

#ifdef RT_USING_HEAP
    case RT_THREAD_CTRL_CLOSE:
        return rt_thread_delete(thread);
 8018788:	68f8      	ldr	r0, [r7, #12]
 801878a:	f7ff ff01 	bl	8018590 <rt_thread_delete>
 801878e:	4603      	mov	r3, r0
 8018790:	e000      	b.n	8018794 <rt_thread_control+0xa4>

    default:
        break;
    }

    return RT_EOK;
 8018792:	2300      	movs	r3, #0
}
 8018794:	4618      	mov	r0, r3
 8018796:	3714      	adds	r7, #20
 8018798:	46bd      	mov	sp, r7
 801879a:	bd90      	pop	{r4, r7, pc}
 801879c:	08029438 	.word	0x08029438
 80187a0:	0802aa64 	.word	0x0802aa64

080187a4 <rt_thread_suspend>:
 *
 * @note if suspend self thread, after this function call, the
 * rt_schedule() must be invoked.
 */
rt_err_t rt_thread_suspend(rt_thread_t thread)
{
 80187a4:	b590      	push	{r4, r7, lr}
 80187a6:	b083      	sub	sp, #12
 80187a8:	af00      	add	r7, sp, #0
 80187aa:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 80187ac:	687b      	ldr	r3, [r7, #4]
 80187ae:	2b00      	cmp	r3, #0
 80187b0:	d105      	bne.n	80187be <rt_thread_suspend+0x1a>
 80187b2:	4812      	ldr	r0, [pc, #72]	; (80187fc <rt_thread_suspend+0x58>)
 80187b4:	4912      	ldr	r1, [pc, #72]	; (8018800 <rt_thread_suspend+0x5c>)
 80187b6:	f240 222f 	movw	r2, #559	; 0x22f
 80187ba:	f7fe fd23 	bl	8017204 <rt_assert_handler>

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend:  %s\n", thread->name));

    if (thread->stat != RT_THREAD_READY)
 80187be:	687b      	ldr	r3, [r7, #4]
 80187c0:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 80187c4:	2b01      	cmp	r3, #1
 80187c6:	d002      	beq.n	80187ce <rt_thread_suspend+0x2a>
    {
        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend: thread disorder, %d\n",
                                       thread->stat));

        return -RT_ERROR;
 80187c8:	f04f 33ff 	mov.w	r3, #4294967295
 80187cc:	e012      	b.n	80187f4 <rt_thread_suspend+0x50>
    }

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 80187ce:	f7e7 fcfd 	bl	80001cc <rt_hw_interrupt_disable>
 80187d2:	4604      	mov	r4, r0

    /* change thread stat */
    thread->stat = RT_THREAD_SUSPEND;
 80187d4:	687b      	ldr	r3, [r7, #4]
 80187d6:	2202      	movs	r2, #2
 80187d8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    rt_schedule_remove_thread(thread);
 80187dc:	6878      	ldr	r0, [r7, #4]
 80187de:	f7ff fcb3 	bl	8018148 <rt_schedule_remove_thread>

    /* stop thread timer anyway */
    rt_timer_stop(&(thread->thread_timer));
 80187e2:	687b      	ldr	r3, [r7, #4]
 80187e4:	334c      	adds	r3, #76	; 0x4c
 80187e6:	4618      	mov	r0, r3
 80187e8:	f000 fa9c 	bl	8018d24 <rt_timer_stop>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 80187ec:	4620      	mov	r0, r4
 80187ee:	f7e7 fcf1 	bl	80001d4 <rt_hw_interrupt_enable>

    return RT_EOK;
 80187f2:	2300      	movs	r3, #0
}
 80187f4:	4618      	mov	r0, r3
 80187f6:	370c      	adds	r7, #12
 80187f8:	46bd      	mov	sp, r7
 80187fa:	bd90      	pop	{r4, r7, pc}
 80187fc:	08029438 	.word	0x08029438
 8018800:	0802aa78 	.word	0x0802aa78

08018804 <rt_thread_resume>:
 * @param thread the thread to be resumed
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_resume(rt_thread_t thread)
{
 8018804:	b590      	push	{r4, r7, lr}
 8018806:	b083      	sub	sp, #12
 8018808:	af00      	add	r7, sp, #0
 801880a:	6078      	str	r0, [r7, #4]
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 801880c:	687b      	ldr	r3, [r7, #4]
 801880e:	2b00      	cmp	r3, #0
 8018810:	d105      	bne.n	801881e <rt_thread_resume+0x1a>
 8018812:	4813      	ldr	r0, [pc, #76]	; (8018860 <rt_thread_resume+0x5c>)
 8018814:	4913      	ldr	r1, [pc, #76]	; (8018864 <rt_thread_resume+0x60>)
 8018816:	f44f 7216 	mov.w	r2, #600	; 0x258
 801881a:	f7fe fcf3 	bl	8017204 <rt_assert_handler>

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume:  %s\n", thread->name));

    if (thread->stat != RT_THREAD_SUSPEND)
 801881e:	687b      	ldr	r3, [r7, #4]
 8018820:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8018824:	2b02      	cmp	r3, #2
 8018826:	d002      	beq.n	801882e <rt_thread_resume+0x2a>
    {
        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume: thread disorder, %d\n",
                                       thread->stat));

        return -RT_ERROR;
 8018828:	f04f 33ff 	mov.w	r3, #4294967295
 801882c:	e013      	b.n	8018856 <rt_thread_resume+0x52>
    }

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
 801882e:	f7e7 fccd 	bl	80001cc <rt_hw_interrupt_disable>
 8018832:	4604      	mov	r4, r0

    /* remove from suspend list */
    rt_list_remove(&(thread->tlist));
 8018834:	687b      	ldr	r3, [r7, #4]
 8018836:	3314      	adds	r3, #20
 8018838:	4618      	mov	r0, r3
 801883a:	f7ff fd33 	bl	80182a4 <rt_list_remove>

    rt_timer_stop(&thread->thread_timer);
 801883e:	687b      	ldr	r3, [r7, #4]
 8018840:	334c      	adds	r3, #76	; 0x4c
 8018842:	4618      	mov	r0, r3
 8018844:	f000 fa6e 	bl	8018d24 <rt_timer_stop>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
 8018848:	4620      	mov	r0, r4
 801884a:	f7e7 fcc3 	bl	80001d4 <rt_hw_interrupt_enable>

    /* insert to schedule ready list */
    rt_schedule_insert_thread(thread);
 801884e:	6878      	ldr	r0, [r7, #4]
 8018850:	f7ff fc44 	bl	80180dc <rt_schedule_insert_thread>

    return RT_EOK;
 8018854:	2300      	movs	r3, #0
}
 8018856:	4618      	mov	r0, r3
 8018858:	370c      	adds	r7, #12
 801885a:	46bd      	mov	sp, r7
 801885c:	bd90      	pop	{r4, r7, pc}
 801885e:	bf00      	nop
 8018860:	08029438 	.word	0x08029438
 8018864:	0802aa8c 	.word	0x0802aa8c

08018868 <rt_thread_timeout>:
 * when thread is timeout to wait some resource.
 *
 * @param parameter the parameter of thread timeout function
 */
void rt_thread_timeout(void *parameter)
{
 8018868:	b580      	push	{r7, lr}
 801886a:	b084      	sub	sp, #16
 801886c:	af00      	add	r7, sp, #0
 801886e:	6078      	str	r0, [r7, #4]
    struct rt_thread *thread;

    thread = (struct rt_thread *)parameter;
 8018870:	687b      	ldr	r3, [r7, #4]
 8018872:	60fb      	str	r3, [r7, #12]

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
 8018874:	68fb      	ldr	r3, [r7, #12]
 8018876:	2b00      	cmp	r3, #0
 8018878:	d105      	bne.n	8018886 <rt_thread_timeout+0x1e>
 801887a:	4811      	ldr	r0, [pc, #68]	; (80188c0 <rt_thread_timeout+0x58>)
 801887c:	4911      	ldr	r1, [pc, #68]	; (80188c4 <rt_thread_timeout+0x5c>)
 801887e:	f240 2283 	movw	r2, #643	; 0x283
 8018882:	f7fe fcbf 	bl	8017204 <rt_assert_handler>
    RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);
 8018886:	68fb      	ldr	r3, [r7, #12]
 8018888:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801888c:	2b02      	cmp	r3, #2
 801888e:	d005      	beq.n	801889c <rt_thread_timeout+0x34>
 8018890:	480d      	ldr	r0, [pc, #52]	; (80188c8 <rt_thread_timeout+0x60>)
 8018892:	490c      	ldr	r1, [pc, #48]	; (80188c4 <rt_thread_timeout+0x5c>)
 8018894:	f44f 7221 	mov.w	r2, #644	; 0x284
 8018898:	f7fe fcb4 	bl	8017204 <rt_assert_handler>

    /* set error number */
    thread->error = -RT_ETIMEOUT;
 801889c:	68fb      	ldr	r3, [r7, #12]
 801889e:	f06f 0201 	mvn.w	r2, #1
 80188a2:	631a      	str	r2, [r3, #48]	; 0x30

    /* remove from suspend list */
    rt_list_remove(&(thread->tlist));
 80188a4:	68fb      	ldr	r3, [r7, #12]
 80188a6:	3314      	adds	r3, #20
 80188a8:	4618      	mov	r0, r3
 80188aa:	f7ff fcfb 	bl	80182a4 <rt_list_remove>

    /* insert to schedule ready list */
    rt_schedule_insert_thread(thread);
 80188ae:	68f8      	ldr	r0, [r7, #12]
 80188b0:	f7ff fc14 	bl	80180dc <rt_schedule_insert_thread>

    /* do schedule */
    rt_schedule();
 80188b4:	f7ff fbb4 	bl	8018020 <rt_schedule>
}
 80188b8:	3710      	adds	r7, #16
 80188ba:	46bd      	mov	sp, r7
 80188bc:	bd80      	pop	{r7, pc}
 80188be:	bf00      	nop
 80188c0:	08029438 	.word	0x08029438
 80188c4:	0802aaa0 	.word	0x0802aaa0
 80188c8:	08029484 	.word	0x08029484

080188cc <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 80188cc:	b480      	push	{r7}
 80188ce:	b083      	sub	sp, #12
 80188d0:	af00      	add	r7, sp, #0
 80188d2:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 80188d4:	687b      	ldr	r3, [r7, #4]
 80188d6:	687a      	ldr	r2, [r7, #4]
 80188d8:	605a      	str	r2, [r3, #4]
 80188da:	687b      	ldr	r3, [r7, #4]
 80188dc:	685a      	ldr	r2, [r3, #4]
 80188de:	687b      	ldr	r3, [r7, #4]
 80188e0:	601a      	str	r2, [r3, #0]
}
 80188e2:	370c      	adds	r7, #12
 80188e4:	46bd      	mov	sp, r7
 80188e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80188ea:	4770      	bx	lr

080188ec <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
 80188ec:	b480      	push	{r7}
 80188ee:	b083      	sub	sp, #12
 80188f0:	af00      	add	r7, sp, #0
 80188f2:	6078      	str	r0, [r7, #4]
 80188f4:	6039      	str	r1, [r7, #0]
    l->next->prev = n;
 80188f6:	687b      	ldr	r3, [r7, #4]
 80188f8:	681b      	ldr	r3, [r3, #0]
 80188fa:	683a      	ldr	r2, [r7, #0]
 80188fc:	605a      	str	r2, [r3, #4]
    n->next = l->next;
 80188fe:	687b      	ldr	r3, [r7, #4]
 8018900:	681a      	ldr	r2, [r3, #0]
 8018902:	683b      	ldr	r3, [r7, #0]
 8018904:	601a      	str	r2, [r3, #0]

    l->next = n;
 8018906:	687b      	ldr	r3, [r7, #4]
 8018908:	683a      	ldr	r2, [r7, #0]
 801890a:	601a      	str	r2, [r3, #0]
    n->prev = l;
 801890c:	683b      	ldr	r3, [r7, #0]
 801890e:	687a      	ldr	r2, [r7, #4]
 8018910:	605a      	str	r2, [r3, #4]
}
 8018912:	370c      	adds	r7, #12
 8018914:	46bd      	mov	sp, r7
 8018916:	f85d 7b04 	ldr.w	r7, [sp], #4
 801891a:	4770      	bx	lr

0801891c <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 801891c:	b480      	push	{r7}
 801891e:	b083      	sub	sp, #12
 8018920:	af00      	add	r7, sp, #0
 8018922:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 8018924:	687b      	ldr	r3, [r7, #4]
 8018926:	681b      	ldr	r3, [r3, #0]
 8018928:	687a      	ldr	r2, [r7, #4]
 801892a:	6852      	ldr	r2, [r2, #4]
 801892c:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 801892e:	687b      	ldr	r3, [r7, #4]
 8018930:	685b      	ldr	r3, [r3, #4]
 8018932:	687a      	ldr	r2, [r7, #4]
 8018934:	6812      	ldr	r2, [r2, #0]
 8018936:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 8018938:	687b      	ldr	r3, [r7, #4]
 801893a:	687a      	ldr	r2, [r7, #4]
 801893c:	605a      	str	r2, [r3, #4]
 801893e:	687b      	ldr	r3, [r7, #4]
 8018940:	685a      	ldr	r2, [r3, #4]
 8018942:	687b      	ldr	r3, [r7, #4]
 8018944:	601a      	str	r2, [r3, #0]
}
 8018946:	370c      	adds	r7, #12
 8018948:	46bd      	mov	sp, r7
 801894a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801894e:	4770      	bx	lr

08018950 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 8018950:	b480      	push	{r7}
 8018952:	b083      	sub	sp, #12
 8018954:	af00      	add	r7, sp, #0
 8018956:	6078      	str	r0, [r7, #4]
    return l->next == l;
 8018958:	687b      	ldr	r3, [r7, #4]
 801895a:	681a      	ldr	r2, [r3, #0]
 801895c:	687b      	ldr	r3, [r7, #4]
 801895e:	429a      	cmp	r2, r3
 8018960:	bf0c      	ite	eq
 8018962:	2301      	moveq	r3, #1
 8018964:	2300      	movne	r3, #0
 8018966:	b2db      	uxtb	r3, r3
}
 8018968:	4618      	mov	r0, r3
 801896a:	370c      	adds	r7, #12
 801896c:	46bd      	mov	sp, r7
 801896e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018972:	4770      	bx	lr

08018974 <_rt_timer_init>:
static void _rt_timer_init(rt_timer_t timer,
                           void (*timeout)(void *parameter),
                           void      *parameter,
                           rt_tick_t  time,
                           rt_uint8_t flag)
{
 8018974:	b580      	push	{r7, lr}
 8018976:	b086      	sub	sp, #24
 8018978:	af00      	add	r7, sp, #0
 801897a:	60f8      	str	r0, [r7, #12]
 801897c:	60b9      	str	r1, [r7, #8]
 801897e:	607a      	str	r2, [r7, #4]
 8018980:	603b      	str	r3, [r7, #0]
    int i;

    /* set flag */
    timer->parent.flag  = flag;
 8018982:	68fb      	ldr	r3, [r7, #12]
 8018984:	f897 2020 	ldrb.w	r2, [r7, #32]
 8018988:	725a      	strb	r2, [r3, #9]

    /* set deactivated */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 801898a:	68fb      	ldr	r3, [r7, #12]
 801898c:	7a5b      	ldrb	r3, [r3, #9]
 801898e:	f023 0301 	bic.w	r3, r3, #1
 8018992:	b2da      	uxtb	r2, r3
 8018994:	68fb      	ldr	r3, [r7, #12]
 8018996:	725a      	strb	r2, [r3, #9]

    timer->timeout_func = timeout;
 8018998:	68fb      	ldr	r3, [r7, #12]
 801899a:	68ba      	ldr	r2, [r7, #8]
 801899c:	61da      	str	r2, [r3, #28]
    timer->parameter    = parameter;
 801899e:	68fb      	ldr	r3, [r7, #12]
 80189a0:	687a      	ldr	r2, [r7, #4]
 80189a2:	621a      	str	r2, [r3, #32]

    timer->timeout_tick = 0;
 80189a4:	68fb      	ldr	r3, [r7, #12]
 80189a6:	2200      	movs	r2, #0
 80189a8:	629a      	str	r2, [r3, #40]	; 0x28
    timer->init_tick    = time;
 80189aa:	68fb      	ldr	r3, [r7, #12]
 80189ac:	683a      	ldr	r2, [r7, #0]
 80189ae:	625a      	str	r2, [r3, #36]	; 0x24

    /* initialize timer list */
    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
 80189b0:	2300      	movs	r3, #0
 80189b2:	617b      	str	r3, [r7, #20]
 80189b4:	e00b      	b.n	80189ce <_rt_timer_init+0x5a>
    {
        rt_list_init(&(timer->row[i]));
 80189b6:	697b      	ldr	r3, [r7, #20]
 80189b8:	3302      	adds	r3, #2
 80189ba:	00db      	lsls	r3, r3, #3
 80189bc:	68fa      	ldr	r2, [r7, #12]
 80189be:	4413      	add	r3, r2
 80189c0:	3304      	adds	r3, #4
 80189c2:	4618      	mov	r0, r3
 80189c4:	f7ff ff82 	bl	80188cc <rt_list_init>

    timer->timeout_tick = 0;
    timer->init_tick    = time;

    /* initialize timer list */
    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
 80189c8:	697b      	ldr	r3, [r7, #20]
 80189ca:	3301      	adds	r3, #1
 80189cc:	617b      	str	r3, [r7, #20]
 80189ce:	697b      	ldr	r3, [r7, #20]
 80189d0:	2b00      	cmp	r3, #0
 80189d2:	ddf0      	ble.n	80189b6 <_rt_timer_init+0x42>
    {
        rt_list_init(&(timer->row[i]));
    }
}
 80189d4:	3718      	adds	r7, #24
 80189d6:	46bd      	mov	sp, r7
 80189d8:	bd80      	pop	{r7, pc}
 80189da:	bf00      	nop

080189dc <rt_timer_list_next_timeout>:

/* the fist timer always in the last row */
static rt_tick_t rt_timer_list_next_timeout(rt_list_t timer_list[])
{
 80189dc:	b580      	push	{r7, lr}
 80189de:	b084      	sub	sp, #16
 80189e0:	af00      	add	r7, sp, #0
 80189e2:	6078      	str	r0, [r7, #4]
    struct rt_timer *timer;

    if (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
 80189e4:	6878      	ldr	r0, [r7, #4]
 80189e6:	f7ff ffb3 	bl	8018950 <rt_list_isempty>
 80189ea:	4603      	mov	r3, r0
 80189ec:	2b00      	cmp	r3, #0
 80189ee:	d002      	beq.n	80189f6 <rt_timer_list_next_timeout+0x1a>
        return RT_TICK_MAX;
 80189f0:	f04f 33ff 	mov.w	r3, #4294967295
 80189f4:	e005      	b.n	8018a02 <rt_timer_list_next_timeout+0x26>

    timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
 80189f6:	687b      	ldr	r3, [r7, #4]
 80189f8:	681b      	ldr	r3, [r3, #0]
 80189fa:	3b14      	subs	r3, #20
 80189fc:	60fb      	str	r3, [r7, #12]
                          struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);

    return timer->timeout_tick;
 80189fe:	68fb      	ldr	r3, [r7, #12]
 8018a00:	6a9b      	ldr	r3, [r3, #40]	; 0x28
}
 8018a02:	4618      	mov	r0, r3
 8018a04:	3710      	adds	r7, #16
 8018a06:	46bd      	mov	sp, r7
 8018a08:	bd80      	pop	{r7, pc}
 8018a0a:	bf00      	nop

08018a0c <_rt_timer_remove>:

rt_inline void _rt_timer_remove(rt_timer_t timer)
{
 8018a0c:	b580      	push	{r7, lr}
 8018a0e:	b084      	sub	sp, #16
 8018a10:	af00      	add	r7, sp, #0
 8018a12:	6078      	str	r0, [r7, #4]
    int i;

    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
 8018a14:	2300      	movs	r3, #0
 8018a16:	60fb      	str	r3, [r7, #12]
 8018a18:	e00b      	b.n	8018a32 <_rt_timer_remove+0x26>
    {
        rt_list_remove(&timer->row[i]);
 8018a1a:	68fb      	ldr	r3, [r7, #12]
 8018a1c:	3302      	adds	r3, #2
 8018a1e:	00db      	lsls	r3, r3, #3
 8018a20:	687a      	ldr	r2, [r7, #4]
 8018a22:	4413      	add	r3, r2
 8018a24:	3304      	adds	r3, #4
 8018a26:	4618      	mov	r0, r3
 8018a28:	f7ff ff78 	bl	801891c <rt_list_remove>

rt_inline void _rt_timer_remove(rt_timer_t timer)
{
    int i;

    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
 8018a2c:	68fb      	ldr	r3, [r7, #12]
 8018a2e:	3301      	adds	r3, #1
 8018a30:	60fb      	str	r3, [r7, #12]
 8018a32:	68fb      	ldr	r3, [r7, #12]
 8018a34:	2b00      	cmp	r3, #0
 8018a36:	ddf0      	ble.n	8018a1a <_rt_timer_remove+0xe>
    {
        rt_list_remove(&timer->row[i]);
    }
}
 8018a38:	3710      	adds	r7, #16
 8018a3a:	46bd      	mov	sp, r7
 8018a3c:	bd80      	pop	{r7, pc}
 8018a3e:	bf00      	nop

08018a40 <rt_timer_init>:
                   const char *name,
                   void (*timeout)(void *parameter),
                   void       *parameter,
                   rt_tick_t   time,
                   rt_uint8_t  flag)
{
 8018a40:	b580      	push	{r7, lr}
 8018a42:	b086      	sub	sp, #24
 8018a44:	af02      	add	r7, sp, #8
 8018a46:	60f8      	str	r0, [r7, #12]
 8018a48:	60b9      	str	r1, [r7, #8]
 8018a4a:	607a      	str	r2, [r7, #4]
 8018a4c:	603b      	str	r3, [r7, #0]
    /* timer check */
    RT_ASSERT(timer != RT_NULL);
 8018a4e:	68fb      	ldr	r3, [r7, #12]
 8018a50:	2b00      	cmp	r3, #0
 8018a52:	d104      	bne.n	8018a5e <rt_timer_init+0x1e>
 8018a54:	480a      	ldr	r0, [pc, #40]	; (8018a80 <rt_timer_init+0x40>)
 8018a56:	490b      	ldr	r1, [pc, #44]	; (8018a84 <rt_timer_init+0x44>)
 8018a58:	22bc      	movs	r2, #188	; 0xbc
 8018a5a:	f7fe fbd3 	bl	8017204 <rt_assert_handler>

    /* timer object initialization */
    rt_object_init((rt_object_t)timer, RT_Object_Class_Timer, name);
 8018a5e:	68f8      	ldr	r0, [r7, #12]
 8018a60:	2109      	movs	r1, #9
 8018a62:	68ba      	ldr	r2, [r7, #8]
 8018a64:	f7ff f8e8 	bl	8017c38 <rt_object_init>

    _rt_timer_init(timer, timeout, parameter, time, flag);
 8018a68:	7f3b      	ldrb	r3, [r7, #28]
 8018a6a:	9300      	str	r3, [sp, #0]
 8018a6c:	68f8      	ldr	r0, [r7, #12]
 8018a6e:	6879      	ldr	r1, [r7, #4]
 8018a70:	683a      	ldr	r2, [r7, #0]
 8018a72:	69bb      	ldr	r3, [r7, #24]
 8018a74:	f7ff ff7e 	bl	8018974 <_rt_timer_init>
}
 8018a78:	3710      	adds	r7, #16
 8018a7a:	46bd      	mov	sp, r7
 8018a7c:	bd80      	pop	{r7, pc}
 8018a7e:	bf00      	nop
 8018a80:	080294a8 	.word	0x080294a8
 8018a84:	0802aab4 	.word	0x0802aab4

08018a88 <rt_timer_detach>:
 * @param timer the static timer object
 *
 * @return the operation status, RT_EOK on OK; RT_ERROR on error
 */
rt_err_t rt_timer_detach(rt_timer_t timer)
{
 8018a88:	b590      	push	{r4, r7, lr}
 8018a8a:	b083      	sub	sp, #12
 8018a8c:	af00      	add	r7, sp, #0
 8018a8e:	6078      	str	r0, [r7, #4]
    register rt_base_t level;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
 8018a90:	687b      	ldr	r3, [r7, #4]
 8018a92:	2b00      	cmp	r3, #0
 8018a94:	d104      	bne.n	8018aa0 <rt_timer_detach+0x18>
 8018a96:	480b      	ldr	r0, [pc, #44]	; (8018ac4 <rt_timer_detach+0x3c>)
 8018a98:	490b      	ldr	r1, [pc, #44]	; (8018ac8 <rt_timer_detach+0x40>)
 8018a9a:	22d1      	movs	r2, #209	; 0xd1
 8018a9c:	f7fe fbb2 	bl	8017204 <rt_assert_handler>

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 8018aa0:	f7e7 fb94 	bl	80001cc <rt_hw_interrupt_disable>
 8018aa4:	4604      	mov	r4, r0

    _rt_timer_remove(timer);
 8018aa6:	6878      	ldr	r0, [r7, #4]
 8018aa8:	f7ff ffb0 	bl	8018a0c <_rt_timer_remove>

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 8018aac:	4620      	mov	r0, r4
 8018aae:	f7e7 fb91 	bl	80001d4 <rt_hw_interrupt_enable>

    rt_object_detach((rt_object_t)timer);
 8018ab2:	6878      	ldr	r0, [r7, #4]
 8018ab4:	f7ff f8f6 	bl	8017ca4 <rt_object_detach>

    return -RT_EOK;
 8018ab8:	2300      	movs	r3, #0
}
 8018aba:	4618      	mov	r0, r3
 8018abc:	370c      	adds	r7, #12
 8018abe:	46bd      	mov	sp, r7
 8018ac0:	bd90      	pop	{r4, r7, pc}
 8018ac2:	bf00      	nop
 8018ac4:	080294a8 	.word	0x080294a8
 8018ac8:	0802aac4 	.word	0x0802aac4

08018acc <rt_timer_create>:
rt_timer_t rt_timer_create(const char *name,
                           void (*timeout)(void *parameter),
                           void       *parameter,
                           rt_tick_t   time,
                           rt_uint8_t  flag)
{
 8018acc:	b580      	push	{r7, lr}
 8018ace:	b088      	sub	sp, #32
 8018ad0:	af02      	add	r7, sp, #8
 8018ad2:	60f8      	str	r0, [r7, #12]
 8018ad4:	60b9      	str	r1, [r7, #8]
 8018ad6:	607a      	str	r2, [r7, #4]
 8018ad8:	603b      	str	r3, [r7, #0]
    struct rt_timer *timer;

    /* allocate a object */
    timer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);
 8018ada:	2009      	movs	r0, #9
 8018adc:	68f9      	ldr	r1, [r7, #12]
 8018ade:	f7ff f909 	bl	8017cf4 <rt_object_allocate>
 8018ae2:	6178      	str	r0, [r7, #20]
    if (timer == RT_NULL)
 8018ae4:	697b      	ldr	r3, [r7, #20]
 8018ae6:	2b00      	cmp	r3, #0
 8018ae8:	d101      	bne.n	8018aee <rt_timer_create+0x22>
    {
        return RT_NULL;
 8018aea:	2300      	movs	r3, #0
 8018aec:	e009      	b.n	8018b02 <rt_timer_create+0x36>
    }

    _rt_timer_init(timer, timeout, parameter, time, flag);
 8018aee:	f897 3020 	ldrb.w	r3, [r7, #32]
 8018af2:	9300      	str	r3, [sp, #0]
 8018af4:	6978      	ldr	r0, [r7, #20]
 8018af6:	68b9      	ldr	r1, [r7, #8]
 8018af8:	687a      	ldr	r2, [r7, #4]
 8018afa:	683b      	ldr	r3, [r7, #0]
 8018afc:	f7ff ff3a 	bl	8018974 <_rt_timer_init>

    return timer;
 8018b00:	697b      	ldr	r3, [r7, #20]
}
 8018b02:	4618      	mov	r0, r3
 8018b04:	3718      	adds	r7, #24
 8018b06:	46bd      	mov	sp, r7
 8018b08:	bd80      	pop	{r7, pc}
 8018b0a:	bf00      	nop

08018b0c <rt_timer_start>:
 * @param timer the timer to be started
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_timer_start(rt_timer_t timer)
{
 8018b0c:	b590      	push	{r4, r7, lr}
 8018b0e:	b089      	sub	sp, #36	; 0x24
 8018b10:	af00      	add	r7, sp, #0
 8018b12:	6078      	str	r0, [r7, #4]
    rt_list_t *row_head[RT_TIMER_SKIP_LIST_LEVEL];
    unsigned int tst_nr;
    static unsigned int random_nr;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
 8018b14:	687b      	ldr	r3, [r7, #4]
 8018b16:	2b00      	cmp	r3, #0
 8018b18:	d105      	bne.n	8018b26 <rt_timer_start+0x1a>
 8018b1a:	4879      	ldr	r0, [pc, #484]	; (8018d00 <rt_timer_start+0x1f4>)
 8018b1c:	4979      	ldr	r1, [pc, #484]	; (8018d04 <rt_timer_start+0x1f8>)
 8018b1e:	f44f 7298 	mov.w	r2, #304	; 0x130
 8018b22:	f7fe fb6f 	bl	8017204 <rt_assert_handler>

	/* stop timer firstly */
	level = rt_hw_interrupt_disable();
 8018b26:	f7e7 fb51 	bl	80001cc <rt_hw_interrupt_disable>
 8018b2a:	4604      	mov	r4, r0
	/* remove timer from list */
    _rt_timer_remove(timer);
 8018b2c:	6878      	ldr	r0, [r7, #4]
 8018b2e:	f7ff ff6d 	bl	8018a0c <_rt_timer_remove>
    /* change status of timer */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 8018b32:	687b      	ldr	r3, [r7, #4]
 8018b34:	7a5b      	ldrb	r3, [r3, #9]
 8018b36:	f023 0301 	bic.w	r3, r3, #1
 8018b3a:	b2da      	uxtb	r2, r3
 8018b3c:	687b      	ldr	r3, [r7, #4]
 8018b3e:	725a      	strb	r2, [r3, #9]
    rt_hw_interrupt_enable(level);
 8018b40:	4620      	mov	r0, r4
 8018b42:	f7e7 fb47 	bl	80001d4 <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(timer->parent)));
 8018b46:	4b70      	ldr	r3, [pc, #448]	; (8018d08 <rt_timer_start+0x1fc>)
 8018b48:	681b      	ldr	r3, [r3, #0]
 8018b4a:	2b00      	cmp	r3, #0
 8018b4c:	d004      	beq.n	8018b58 <rt_timer_start+0x4c>
 8018b4e:	4b6e      	ldr	r3, [pc, #440]	; (8018d08 <rt_timer_start+0x1fc>)
 8018b50:	681b      	ldr	r3, [r3, #0]
 8018b52:	687a      	ldr	r2, [r7, #4]
 8018b54:	4610      	mov	r0, r2
 8018b56:	4798      	blx	r3

    /*
     * get timeout tick,
     * the max timeout tick shall not great than RT_TICK_MAX/2
     */
    RT_ASSERT(timer->init_tick < RT_TICK_MAX / 2);
 8018b58:	687b      	ldr	r3, [r7, #4]
 8018b5a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8018b5c:	4a6b      	ldr	r2, [pc, #428]	; (8018d0c <rt_timer_start+0x200>)
 8018b5e:	4293      	cmp	r3, r2
 8018b60:	d905      	bls.n	8018b6e <rt_timer_start+0x62>
 8018b62:	486b      	ldr	r0, [pc, #428]	; (8018d10 <rt_timer_start+0x204>)
 8018b64:	4967      	ldr	r1, [pc, #412]	; (8018d04 <rt_timer_start+0x1f8>)
 8018b66:	f44f 72a0 	mov.w	r2, #320	; 0x140
 8018b6a:	f7fe fb4b 	bl	8017204 <rt_assert_handler>
    timer->timeout_tick = rt_tick_get() + timer->init_tick;
 8018b6e:	f7fc fb8b 	bl	8015288 <rt_tick_get>
 8018b72:	4602      	mov	r2, r0
 8018b74:	687b      	ldr	r3, [r7, #4]
 8018b76:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8018b78:	441a      	add	r2, r3
 8018b7a:	687b      	ldr	r3, [r7, #4]
 8018b7c:	629a      	str	r2, [r3, #40]	; 0x28

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 8018b7e:	f7e7 fb25 	bl	80001cc <rt_hw_interrupt_disable>
 8018b82:	4604      	mov	r4, r0

#ifdef RT_USING_TIMER_SOFT
    if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
 8018b84:	687b      	ldr	r3, [r7, #4]
 8018b86:	7a5b      	ldrb	r3, [r3, #9]
 8018b88:	f003 0304 	and.w	r3, r3, #4
 8018b8c:	2b00      	cmp	r3, #0
 8018b8e:	d002      	beq.n	8018b96 <rt_timer_start+0x8a>
    {
        /* insert timer to soft timer list */
        timer_list = rt_soft_timer_list;
 8018b90:	4b60      	ldr	r3, [pc, #384]	; (8018d14 <rt_timer_start+0x208>)
 8018b92:	61bb      	str	r3, [r7, #24]
 8018b94:	e001      	b.n	8018b9a <rt_timer_start+0x8e>
    }
    else
#endif
    {
        /* insert timer to system timer list */
        timer_list = rt_timer_list;
 8018b96:	4b60      	ldr	r3, [pc, #384]	; (8018d18 <rt_timer_start+0x20c>)
 8018b98:	61bb      	str	r3, [r7, #24]
    }

    row_head[0]  = &timer_list[0];
 8018b9a:	69bb      	ldr	r3, [r7, #24]
 8018b9c:	60bb      	str	r3, [r7, #8]
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
 8018b9e:	2300      	movs	r3, #0
 8018ba0:	61fb      	str	r3, [r7, #28]
 8018ba2:	e054      	b.n	8018c4e <rt_timer_start+0x142>
    {
        for (;row_head[row_lvl] != timer_list[row_lvl].prev;
 8018ba4:	e02e      	b.n	8018c04 <rt_timer_start+0xf8>
             row_head[row_lvl]  = row_head[row_lvl]->next)
        {
            struct rt_timer *t;
            rt_list_t *p = row_head[row_lvl]->next;
 8018ba6:	69fb      	ldr	r3, [r7, #28]
 8018ba8:	009b      	lsls	r3, r3, #2
 8018baa:	f107 0220 	add.w	r2, r7, #32
 8018bae:	4413      	add	r3, r2
 8018bb0:	f853 3c18 	ldr.w	r3, [r3, #-24]
 8018bb4:	681b      	ldr	r3, [r3, #0]
 8018bb6:	613b      	str	r3, [r7, #16]

            /* fix up the entry pointer */
            t = rt_list_entry(p, struct rt_timer, row[row_lvl]);
 8018bb8:	69fb      	ldr	r3, [r7, #28]
 8018bba:	00db      	lsls	r3, r3, #3
 8018bbc:	3314      	adds	r3, #20
 8018bbe:	425b      	negs	r3, r3
 8018bc0:	693a      	ldr	r2, [r7, #16]
 8018bc2:	4413      	add	r3, r2
 8018bc4:	60fb      	str	r3, [r7, #12]
            /* If we have two timers that timeout at the same time, it's
             * preferred that the timer inserted early get called early.
             * So insert the new timer to the end the the some-timeout timer
             * list.
             */
            if ((t->timeout_tick - timer->timeout_tick) == 0)
 8018bc6:	68fb      	ldr	r3, [r7, #12]
 8018bc8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8018bca:	687b      	ldr	r3, [r7, #4]
 8018bcc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8018bce:	429a      	cmp	r2, r3
 8018bd0:	d100      	bne.n	8018bd4 <rt_timer_start+0xc8>
            {
                continue;
 8018bd2:	e008      	b.n	8018be6 <rt_timer_start+0xda>
            }
            else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
 8018bd4:	68fb      	ldr	r3, [r7, #12]
 8018bd6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8018bd8:	687b      	ldr	r3, [r7, #4]
 8018bda:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8018bdc:	1ad3      	subs	r3, r2, r3
 8018bde:	4a4b      	ldr	r2, [pc, #300]	; (8018d0c <rt_timer_start+0x200>)
 8018be0:	4293      	cmp	r3, r2
 8018be2:	d800      	bhi.n	8018be6 <rt_timer_start+0xda>
            {
                break;
 8018be4:	e01c      	b.n	8018c20 <rt_timer_start+0x114>

    row_head[0]  = &timer_list[0];
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    {
        for (;row_head[row_lvl] != timer_list[row_lvl].prev;
             row_head[row_lvl]  = row_head[row_lvl]->next)
 8018be6:	69fb      	ldr	r3, [r7, #28]
 8018be8:	009b      	lsls	r3, r3, #2
 8018bea:	f107 0220 	add.w	r2, r7, #32
 8018bee:	4413      	add	r3, r2
 8018bf0:	f853 3c18 	ldr.w	r3, [r3, #-24]
 8018bf4:	681a      	ldr	r2, [r3, #0]
 8018bf6:	69fb      	ldr	r3, [r7, #28]
 8018bf8:	009b      	lsls	r3, r3, #2
 8018bfa:	f107 0120 	add.w	r1, r7, #32
 8018bfe:	440b      	add	r3, r1
 8018c00:	f843 2c18 	str.w	r2, [r3, #-24]
    }

    row_head[0]  = &timer_list[0];
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    {
        for (;row_head[row_lvl] != timer_list[row_lvl].prev;
 8018c04:	69fb      	ldr	r3, [r7, #28]
 8018c06:	009b      	lsls	r3, r3, #2
 8018c08:	f107 0220 	add.w	r2, r7, #32
 8018c0c:	4413      	add	r3, r2
 8018c0e:	f853 2c18 	ldr.w	r2, [r3, #-24]
 8018c12:	69fb      	ldr	r3, [r7, #28]
 8018c14:	00db      	lsls	r3, r3, #3
 8018c16:	69b9      	ldr	r1, [r7, #24]
 8018c18:	440b      	add	r3, r1
 8018c1a:	685b      	ldr	r3, [r3, #4]
 8018c1c:	429a      	cmp	r2, r3
 8018c1e:	d1c2      	bne.n	8018ba6 <rt_timer_start+0x9a>
            else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
            {
                break;
            }
        }
        if (row_lvl != RT_TIMER_SKIP_LIST_LEVEL - 1)
 8018c20:	69fb      	ldr	r3, [r7, #28]
 8018c22:	2b00      	cmp	r3, #0
 8018c24:	d010      	beq.n	8018c48 <rt_timer_start+0x13c>
            row_head[row_lvl+1] = row_head[row_lvl]+1;
 8018c26:	69fb      	ldr	r3, [r7, #28]
 8018c28:	1c59      	adds	r1, r3, #1
 8018c2a:	69fb      	ldr	r3, [r7, #28]
 8018c2c:	009b      	lsls	r3, r3, #2
 8018c2e:	f107 0220 	add.w	r2, r7, #32
 8018c32:	4413      	add	r3, r2
 8018c34:	f853 3c18 	ldr.w	r3, [r3, #-24]
 8018c38:	f103 0208 	add.w	r2, r3, #8
 8018c3c:	008b      	lsls	r3, r1, #2
 8018c3e:	f107 0120 	add.w	r1, r7, #32
 8018c42:	440b      	add	r3, r1
 8018c44:	f843 2c18 	str.w	r2, [r3, #-24]
        /* insert timer to system timer list */
        timer_list = rt_timer_list;
    }

    row_head[0]  = &timer_list[0];
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
 8018c48:	69fb      	ldr	r3, [r7, #28]
 8018c4a:	3301      	adds	r3, #1
 8018c4c:	61fb      	str	r3, [r7, #28]
 8018c4e:	69fb      	ldr	r3, [r7, #28]
 8018c50:	2b00      	cmp	r3, #0
 8018c52:	d0a7      	beq.n	8018ba4 <rt_timer_start+0x98>

    /* Interestingly, this super simple timer insert counter works very very
     * well on distributing the list height uniformly. By means of "very very
     * well", I mean it beats the randomness of timer->timeout_tick very easily
     * (actually, the timeout_tick is not random and easy to be attacked). */
    random_nr++;
 8018c54:	4b31      	ldr	r3, [pc, #196]	; (8018d1c <rt_timer_start+0x210>)
 8018c56:	681b      	ldr	r3, [r3, #0]
 8018c58:	3301      	adds	r3, #1
 8018c5a:	4a30      	ldr	r2, [pc, #192]	; (8018d1c <rt_timer_start+0x210>)
 8018c5c:	6013      	str	r3, [r2, #0]
    tst_nr = random_nr;
 8018c5e:	4b2f      	ldr	r3, [pc, #188]	; (8018d1c <rt_timer_start+0x210>)
 8018c60:	681b      	ldr	r3, [r3, #0]
 8018c62:	617b      	str	r3, [r7, #20]

    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
 8018c64:	68ba      	ldr	r2, [r7, #8]
 8018c66:	687b      	ldr	r3, [r7, #4]
 8018c68:	3314      	adds	r3, #20
 8018c6a:	4610      	mov	r0, r2
 8018c6c:	4619      	mov	r1, r3
 8018c6e:	f7ff fe3d 	bl	80188ec <rt_list_insert_after>
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
 8018c72:	2302      	movs	r3, #2
 8018c74:	61fb      	str	r3, [r7, #28]
 8018c76:	e021      	b.n	8018cbc <rt_timer_start+0x1b0>
    {
        if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
 8018c78:	697b      	ldr	r3, [r7, #20]
 8018c7a:	f003 0303 	and.w	r3, r3, #3
 8018c7e:	2b00      	cmp	r3, #0
 8018c80:	d115      	bne.n	8018cae <rt_timer_start+0x1a2>
            rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
 8018c82:	69fb      	ldr	r3, [r7, #28]
 8018c84:	f1c3 0301 	rsb	r3, r3, #1
 8018c88:	009b      	lsls	r3, r3, #2
 8018c8a:	f107 0220 	add.w	r2, r7, #32
 8018c8e:	4413      	add	r3, r2
 8018c90:	f853 1c18 	ldr.w	r1, [r3, #-24]
                                 &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
 8018c94:	69fb      	ldr	r3, [r7, #28]
 8018c96:	f1c3 0301 	rsb	r3, r3, #1
    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    {
        if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
            rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
 8018c9a:	3302      	adds	r3, #2
 8018c9c:	00db      	lsls	r3, r3, #3
 8018c9e:	687a      	ldr	r2, [r7, #4]
 8018ca0:	4413      	add	r3, r2
 8018ca2:	3304      	adds	r3, #4
 8018ca4:	4608      	mov	r0, r1
 8018ca6:	4619      	mov	r1, r3
 8018ca8:	f7ff fe20 	bl	80188ec <rt_list_insert_after>
 8018cac:	e000      	b.n	8018cb0 <rt_timer_start+0x1a4>
                                 &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
        else
            break;
 8018cae:	e008      	b.n	8018cc2 <rt_timer_start+0x1b6>
        /* Shift over the bits we have tested. Works well with 1 bit and 2
         * bits. */
        tst_nr >>= (RT_TIMER_SKIP_LIST_MASK+1)>>1;
 8018cb0:	697b      	ldr	r3, [r7, #20]
 8018cb2:	089b      	lsrs	r3, r3, #2
 8018cb4:	617b      	str	r3, [r7, #20]
    random_nr++;
    tst_nr = random_nr;

    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
 8018cb6:	69fb      	ldr	r3, [r7, #28]
 8018cb8:	3301      	adds	r3, #1
 8018cba:	61fb      	str	r3, [r7, #28]
 8018cbc:	69fb      	ldr	r3, [r7, #28]
 8018cbe:	2b01      	cmp	r3, #1
 8018cc0:	d9da      	bls.n	8018c78 <rt_timer_start+0x16c>
        /* Shift over the bits we have tested. Works well with 1 bit and 2
         * bits. */
        tst_nr >>= (RT_TIMER_SKIP_LIST_MASK+1)>>1;
    }

    timer->parent.flag |= RT_TIMER_FLAG_ACTIVATED;
 8018cc2:	687b      	ldr	r3, [r7, #4]
 8018cc4:	7a5b      	ldrb	r3, [r3, #9]
 8018cc6:	f043 0301 	orr.w	r3, r3, #1
 8018cca:	b2da      	uxtb	r2, r3
 8018ccc:	687b      	ldr	r3, [r7, #4]
 8018cce:	725a      	strb	r2, [r3, #9]

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 8018cd0:	4620      	mov	r0, r4
 8018cd2:	f7e7 fa7f 	bl	80001d4 <rt_hw_interrupt_enable>

#ifdef RT_USING_TIMER_SOFT
    if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
 8018cd6:	687b      	ldr	r3, [r7, #4]
 8018cd8:	7a5b      	ldrb	r3, [r3, #9]
 8018cda:	f003 0304 	and.w	r3, r3, #4
 8018cde:	2b00      	cmp	r3, #0
 8018ce0:	d009      	beq.n	8018cf6 <rt_timer_start+0x1ea>
    {
        /* check whether timer thread is ready */
        if (timer_thread.stat != RT_THREAD_READY)
 8018ce2:	4b0f      	ldr	r3, [pc, #60]	; (8018d20 <rt_timer_start+0x214>)
 8018ce4:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8018ce8:	2b01      	cmp	r3, #1
 8018cea:	d004      	beq.n	8018cf6 <rt_timer_start+0x1ea>
        {
            /* resume timer thread to check soft timer */
            rt_thread_resume(&timer_thread);
 8018cec:	480c      	ldr	r0, [pc, #48]	; (8018d20 <rt_timer_start+0x214>)
 8018cee:	f7ff fd89 	bl	8018804 <rt_thread_resume>
            rt_schedule();
 8018cf2:	f7ff f995 	bl	8018020 <rt_schedule>
        }
    }
#endif

    return -RT_EOK;
 8018cf6:	2300      	movs	r3, #0
}
 8018cf8:	4618      	mov	r0, r3
 8018cfa:	3724      	adds	r7, #36	; 0x24
 8018cfc:	46bd      	mov	sp, r7
 8018cfe:	bd90      	pop	{r4, r7, pc}
 8018d00:	080294a8 	.word	0x080294a8
 8018d04:	0802aad4 	.word	0x0802aad4
 8018d08:	20012a68 	.word	0x20012a68
 8018d0c:	7ffffffe 	.word	0x7ffffffe
 8018d10:	080294bc 	.word	0x080294bc
 8018d14:	20010dd4 	.word	0x20010dd4
 8018d18:	20010dcc 	.word	0x20010dcc
 8018d1c:	20011060 	.word	0x20011060
 8018d20:	20010ddc 	.word	0x20010ddc

08018d24 <rt_timer_stop>:
 * @param timer the timer to be stopped
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_timer_stop(rt_timer_t timer)
{
 8018d24:	b590      	push	{r4, r7, lr}
 8018d26:	b083      	sub	sp, #12
 8018d28:	af00      	add	r7, sp, #0
 8018d2a:	6078      	str	r0, [r7, #4]
    register rt_base_t level;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
 8018d2c:	687b      	ldr	r3, [r7, #4]
 8018d2e:	2b00      	cmp	r3, #0
 8018d30:	d105      	bne.n	8018d3e <rt_timer_stop+0x1a>
 8018d32:	4816      	ldr	r0, [pc, #88]	; (8018d8c <rt_timer_stop+0x68>)
 8018d34:	4916      	ldr	r1, [pc, #88]	; (8018d90 <rt_timer_stop+0x6c>)
 8018d36:	f44f 72d4 	mov.w	r2, #424	; 0x1a8
 8018d3a:	f7fe fa63 	bl	8017204 <rt_assert_handler>
    if (!(timer->parent.flag & RT_TIMER_FLAG_ACTIVATED))
 8018d3e:	687b      	ldr	r3, [r7, #4]
 8018d40:	7a5b      	ldrb	r3, [r3, #9]
 8018d42:	f003 0301 	and.w	r3, r3, #1
 8018d46:	2b00      	cmp	r3, #0
 8018d48:	d102      	bne.n	8018d50 <rt_timer_stop+0x2c>
        return -RT_ERROR;
 8018d4a:	f04f 33ff 	mov.w	r3, #4294967295
 8018d4e:	e019      	b.n	8018d84 <rt_timer_stop+0x60>

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(timer->parent)));
 8018d50:	4b10      	ldr	r3, [pc, #64]	; (8018d94 <rt_timer_stop+0x70>)
 8018d52:	681b      	ldr	r3, [r3, #0]
 8018d54:	2b00      	cmp	r3, #0
 8018d56:	d004      	beq.n	8018d62 <rt_timer_stop+0x3e>
 8018d58:	4b0e      	ldr	r3, [pc, #56]	; (8018d94 <rt_timer_stop+0x70>)
 8018d5a:	681b      	ldr	r3, [r3, #0]
 8018d5c:	687a      	ldr	r2, [r7, #4]
 8018d5e:	4610      	mov	r0, r2
 8018d60:	4798      	blx	r3

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 8018d62:	f7e7 fa33 	bl	80001cc <rt_hw_interrupt_disable>
 8018d66:	4604      	mov	r4, r0

    _rt_timer_remove(timer);
 8018d68:	6878      	ldr	r0, [r7, #4]
 8018d6a:	f7ff fe4f 	bl	8018a0c <_rt_timer_remove>

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 8018d6e:	4620      	mov	r0, r4
 8018d70:	f7e7 fa30 	bl	80001d4 <rt_hw_interrupt_enable>

    /* change stat */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 8018d74:	687b      	ldr	r3, [r7, #4]
 8018d76:	7a5b      	ldrb	r3, [r3, #9]
 8018d78:	f023 0301 	bic.w	r3, r3, #1
 8018d7c:	b2da      	uxtb	r2, r3
 8018d7e:	687b      	ldr	r3, [r7, #4]
 8018d80:	725a      	strb	r2, [r3, #9]

    return RT_EOK;
 8018d82:	2300      	movs	r3, #0
}
 8018d84:	4618      	mov	r0, r3
 8018d86:	370c      	adds	r7, #12
 8018d88:	46bd      	mov	sp, r7
 8018d8a:	bd90      	pop	{r4, r7, pc}
 8018d8c:	080294a8 	.word	0x080294a8
 8018d90:	0802aae4 	.word	0x0802aae4
 8018d94:	20012a64 	.word	0x20012a64

08018d98 <rt_timer_control>:
 * @param arg the argument
 *
 * @return RT_EOK
 */
rt_err_t rt_timer_control(rt_timer_t timer, rt_uint8_t cmd, void *arg)
{
 8018d98:	b580      	push	{r7, lr}
 8018d9a:	b084      	sub	sp, #16
 8018d9c:	af00      	add	r7, sp, #0
 8018d9e:	60f8      	str	r0, [r7, #12]
 8018da0:	460b      	mov	r3, r1
 8018da2:	607a      	str	r2, [r7, #4]
 8018da4:	72fb      	strb	r3, [r7, #11]
    /* timer check */
    RT_ASSERT(timer != RT_NULL);
 8018da6:	68fb      	ldr	r3, [r7, #12]
 8018da8:	2b00      	cmp	r3, #0
 8018daa:	d105      	bne.n	8018db8 <rt_timer_control+0x20>
 8018dac:	4819      	ldr	r0, [pc, #100]	; (8018e14 <rt_timer_control+0x7c>)
 8018dae:	491a      	ldr	r1, [pc, #104]	; (8018e18 <rt_timer_control+0x80>)
 8018db0:	f240 12c9 	movw	r2, #457	; 0x1c9
 8018db4:	f7fe fa26 	bl	8017204 <rt_assert_handler>

    switch (cmd)
 8018db8:	7afb      	ldrb	r3, [r7, #11]
 8018dba:	2b03      	cmp	r3, #3
 8018dbc:	d824      	bhi.n	8018e08 <rt_timer_control+0x70>
 8018dbe:	a201      	add	r2, pc, #4	; (adr r2, 8018dc4 <rt_timer_control+0x2c>)
 8018dc0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8018dc4:	08018ddf 	.word	0x08018ddf
 8018dc8:	08018dd5 	.word	0x08018dd5
 8018dcc:	08018de9 	.word	0x08018de9
 8018dd0:	08018df9 	.word	0x08018df9
    {
    case RT_TIMER_CTRL_GET_TIME:
        *(rt_tick_t *)arg = timer->init_tick;
 8018dd4:	68fb      	ldr	r3, [r7, #12]
 8018dd6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8018dd8:	687b      	ldr	r3, [r7, #4]
 8018dda:	601a      	str	r2, [r3, #0]
        break;
 8018ddc:	e014      	b.n	8018e08 <rt_timer_control+0x70>

    case RT_TIMER_CTRL_SET_TIME:
        timer->init_tick = *(rt_tick_t *)arg;
 8018dde:	687b      	ldr	r3, [r7, #4]
 8018de0:	681a      	ldr	r2, [r3, #0]
 8018de2:	68fb      	ldr	r3, [r7, #12]
 8018de4:	625a      	str	r2, [r3, #36]	; 0x24
        break;
 8018de6:	e00f      	b.n	8018e08 <rt_timer_control+0x70>

    case RT_TIMER_CTRL_SET_ONESHOT:
        timer->parent.flag &= ~RT_TIMER_FLAG_PERIODIC;
 8018de8:	68fb      	ldr	r3, [r7, #12]
 8018dea:	7a5b      	ldrb	r3, [r3, #9]
 8018dec:	f023 0302 	bic.w	r3, r3, #2
 8018df0:	b2da      	uxtb	r2, r3
 8018df2:	68fb      	ldr	r3, [r7, #12]
 8018df4:	725a      	strb	r2, [r3, #9]
        break;
 8018df6:	e007      	b.n	8018e08 <rt_timer_control+0x70>

    case RT_TIMER_CTRL_SET_PERIODIC:
        timer->parent.flag |= RT_TIMER_FLAG_PERIODIC;
 8018df8:	68fb      	ldr	r3, [r7, #12]
 8018dfa:	7a5b      	ldrb	r3, [r3, #9]
 8018dfc:	f043 0302 	orr.w	r3, r3, #2
 8018e00:	b2da      	uxtb	r2, r3
 8018e02:	68fb      	ldr	r3, [r7, #12]
 8018e04:	725a      	strb	r2, [r3, #9]
        break;
 8018e06:	bf00      	nop
    }

    return RT_EOK;
 8018e08:	2300      	movs	r3, #0
}
 8018e0a:	4618      	mov	r0, r3
 8018e0c:	3710      	adds	r7, #16
 8018e0e:	46bd      	mov	sp, r7
 8018e10:	bd80      	pop	{r7, pc}
 8018e12:	bf00      	nop
 8018e14:	080294a8 	.word	0x080294a8
 8018e18:	0802aaf4 	.word	0x0802aaf4

08018e1c <rt_timer_check>:
 * corresponding timeout function will be invoked.
 *
 * @note this function shall be invoked in operating system timer interrupt.
 */
void rt_timer_check(void)
{
 8018e1c:	b590      	push	{r4, r7, lr}
 8018e1e:	b083      	sub	sp, #12
 8018e20:	af00      	add	r7, sp, #0
    rt_tick_t current_tick;
    register rt_base_t level;

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check enter\n"));

    current_tick = rt_tick_get();
 8018e22:	f7fc fa31 	bl	8015288 <rt_tick_get>
 8018e26:	6078      	str	r0, [r7, #4]

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
 8018e28:	f7e7 f9d0 	bl	80001cc <rt_hw_interrupt_disable>
 8018e2c:	4604      	mov	r4, r0

    while (!rt_list_isempty(&rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1]))
 8018e2e:	e03e      	b.n	8018eae <rt_timer_check+0x92>
    {
        t = rt_list_entry(rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
 8018e30:	4b25      	ldr	r3, [pc, #148]	; (8018ec8 <rt_timer_check+0xac>)
 8018e32:	681b      	ldr	r3, [r3, #0]
 8018e34:	3b14      	subs	r3, #20
 8018e36:	603b      	str	r3, [r7, #0]

        /*
         * It supposes that the new tick shall less than the half duration of
         * tick max.
         */
        if ((current_tick - t->timeout_tick) < RT_TICK_MAX/2)
 8018e38:	683b      	ldr	r3, [r7, #0]
 8018e3a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8018e3c:	687a      	ldr	r2, [r7, #4]
 8018e3e:	1ad3      	subs	r3, r2, r3
 8018e40:	4a22      	ldr	r2, [pc, #136]	; (8018ecc <rt_timer_check+0xb0>)
 8018e42:	4293      	cmp	r3, r2
 8018e44:	d832      	bhi.n	8018eac <rt_timer_check+0x90>
        {
            RT_OBJECT_HOOK_CALL(rt_timer_timeout_hook, (t));
 8018e46:	4b22      	ldr	r3, [pc, #136]	; (8018ed0 <rt_timer_check+0xb4>)
 8018e48:	681b      	ldr	r3, [r3, #0]
 8018e4a:	2b00      	cmp	r3, #0
 8018e4c:	d003      	beq.n	8018e56 <rt_timer_check+0x3a>
 8018e4e:	4b20      	ldr	r3, [pc, #128]	; (8018ed0 <rt_timer_check+0xb4>)
 8018e50:	681b      	ldr	r3, [r3, #0]
 8018e52:	6838      	ldr	r0, [r7, #0]
 8018e54:	4798      	blx	r3

            /* remove timer from timer list firstly */
            _rt_timer_remove(t);
 8018e56:	6838      	ldr	r0, [r7, #0]
 8018e58:	f7ff fdd8 	bl	8018a0c <_rt_timer_remove>

            /* call timeout function */
            t->timeout_func(t->parameter);
 8018e5c:	683b      	ldr	r3, [r7, #0]
 8018e5e:	69db      	ldr	r3, [r3, #28]
 8018e60:	683a      	ldr	r2, [r7, #0]
 8018e62:	6a12      	ldr	r2, [r2, #32]
 8018e64:	4610      	mov	r0, r2
 8018e66:	4798      	blx	r3

            /* re-get tick */
            current_tick = rt_tick_get();
 8018e68:	f7fc fa0e 	bl	8015288 <rt_tick_get>
 8018e6c:	6078      	str	r0, [r7, #4]

            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
 8018e6e:	683b      	ldr	r3, [r7, #0]
 8018e70:	7a5b      	ldrb	r3, [r3, #9]
 8018e72:	f003 0302 	and.w	r3, r3, #2
 8018e76:	2b00      	cmp	r3, #0
 8018e78:	d010      	beq.n	8018e9c <rt_timer_check+0x80>
                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
 8018e7a:	683b      	ldr	r3, [r7, #0]
 8018e7c:	7a5b      	ldrb	r3, [r3, #9]
 8018e7e:	f003 0301 	and.w	r3, r3, #1
            /* re-get tick */
            current_tick = rt_tick_get();

            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
 8018e82:	2b00      	cmp	r3, #0
 8018e84:	d00a      	beq.n	8018e9c <rt_timer_check+0x80>
                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
            {
                /* start it */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 8018e86:	683b      	ldr	r3, [r7, #0]
 8018e88:	7a5b      	ldrb	r3, [r3, #9]
 8018e8a:	f023 0301 	bic.w	r3, r3, #1
 8018e8e:	b2da      	uxtb	r2, r3
 8018e90:	683b      	ldr	r3, [r7, #0]
 8018e92:	725a      	strb	r2, [r3, #9]
                rt_timer_start(t);
 8018e94:	6838      	ldr	r0, [r7, #0]
 8018e96:	f7ff fe39 	bl	8018b0c <rt_timer_start>
 8018e9a:	e006      	b.n	8018eaa <rt_timer_check+0x8e>
            }
            else
            {
                /* stop timer */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 8018e9c:	683b      	ldr	r3, [r7, #0]
 8018e9e:	7a5b      	ldrb	r3, [r3, #9]
 8018ea0:	f023 0301 	bic.w	r3, r3, #1
 8018ea4:	b2da      	uxtb	r2, r3
 8018ea6:	683b      	ldr	r3, [r7, #0]
 8018ea8:	725a      	strb	r2, [r3, #9]
 8018eaa:	e000      	b.n	8018eae <rt_timer_check+0x92>
            }
        }
        else
            break;
 8018eac:	e005      	b.n	8018eba <rt_timer_check+0x9e>
    current_tick = rt_tick_get();

    /* disable interrupt */
    level = rt_hw_interrupt_disable();

    while (!rt_list_isempty(&rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1]))
 8018eae:	4806      	ldr	r0, [pc, #24]	; (8018ec8 <rt_timer_check+0xac>)
 8018eb0:	f7ff fd4e 	bl	8018950 <rt_list_isempty>
 8018eb4:	4603      	mov	r3, r0
 8018eb6:	2b00      	cmp	r3, #0
 8018eb8:	d0ba      	beq.n	8018e30 <rt_timer_check+0x14>
        else
            break;
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
 8018eba:	4620      	mov	r0, r4
 8018ebc:	f7e7 f98a 	bl	80001d4 <rt_hw_interrupt_enable>

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check leave\n"));
}
 8018ec0:	370c      	adds	r7, #12
 8018ec2:	46bd      	mov	sp, r7
 8018ec4:	bd90      	pop	{r4, r7, pc}
 8018ec6:	bf00      	nop
 8018ec8:	20010dcc 	.word	0x20010dcc
 8018ecc:	7ffffffe 	.word	0x7ffffffe
 8018ed0:	2001105c 	.word	0x2001105c

08018ed4 <rt_soft_timer_check>:
/**
 * This function will check timer list, if a timeout event happens, the
 * corresponding timeout function will be invoked.
 */
void rt_soft_timer_check(void)
{
 8018ed4:	b580      	push	{r7, lr}
 8018ed6:	b084      	sub	sp, #16
 8018ed8:	af00      	add	r7, sp, #0
    rt_list_t *n;
    struct rt_timer *t;

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("software timer check enter\n"));

    current_tick = rt_tick_get();
 8018eda:	f7fc f9d5 	bl	8015288 <rt_tick_get>
 8018ede:	60f8      	str	r0, [r7, #12]

	/* lock scheduler */
	rt_enter_critical();
 8018ee0:	f7ff f96a 	bl	80181b8 <rt_enter_critical>

    for (n = rt_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1].next;
 8018ee4:	4b28      	ldr	r3, [pc, #160]	; (8018f88 <rt_soft_timer_check+0xb4>)
 8018ee6:	681b      	ldr	r3, [r3, #0]
 8018ee8:	60bb      	str	r3, [r7, #8]
 8018eea:	e044      	b.n	8018f76 <rt_soft_timer_check+0xa2>
         n != &(rt_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1]);)
    {
        t = rt_list_entry(n, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL-1]);
 8018eec:	68bb      	ldr	r3, [r7, #8]
 8018eee:	3b14      	subs	r3, #20
 8018ef0:	607b      	str	r3, [r7, #4]

        /*
         * It supposes that the new tick shall less than the half duration of
         * tick max.
         */
        if ((current_tick - t->timeout_tick) < RT_TICK_MAX / 2)
 8018ef2:	687b      	ldr	r3, [r7, #4]
 8018ef4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8018ef6:	68fa      	ldr	r2, [r7, #12]
 8018ef8:	1ad3      	subs	r3, r2, r3
 8018efa:	4a24      	ldr	r2, [pc, #144]	; (8018f8c <rt_soft_timer_check+0xb8>)
 8018efc:	4293      	cmp	r3, r2
 8018efe:	d839      	bhi.n	8018f74 <rt_soft_timer_check+0xa0>
        {
            RT_OBJECT_HOOK_CALL(rt_timer_timeout_hook, (t));
 8018f00:	4b23      	ldr	r3, [pc, #140]	; (8018f90 <rt_soft_timer_check+0xbc>)
 8018f02:	681b      	ldr	r3, [r3, #0]
 8018f04:	2b00      	cmp	r3, #0
 8018f06:	d003      	beq.n	8018f10 <rt_soft_timer_check+0x3c>
 8018f08:	4b21      	ldr	r3, [pc, #132]	; (8018f90 <rt_soft_timer_check+0xbc>)
 8018f0a:	681b      	ldr	r3, [r3, #0]
 8018f0c:	6878      	ldr	r0, [r7, #4]
 8018f0e:	4798      	blx	r3

            /* move node to the next */
            n = n->next;
 8018f10:	68bb      	ldr	r3, [r7, #8]
 8018f12:	681b      	ldr	r3, [r3, #0]
 8018f14:	60bb      	str	r3, [r7, #8]

            /* remove timer from timer list firstly */
            _rt_timer_remove(t);
 8018f16:	6878      	ldr	r0, [r7, #4]
 8018f18:	f7ff fd78 	bl	8018a0c <_rt_timer_remove>

			/* not lock scheduler when performing timeout function */
			rt_exit_critical();
 8018f1c:	f7ff f960 	bl	80181e0 <rt_exit_critical>
            /* call timeout function */
            t->timeout_func(t->parameter);
 8018f20:	687b      	ldr	r3, [r7, #4]
 8018f22:	69db      	ldr	r3, [r3, #28]
 8018f24:	687a      	ldr	r2, [r7, #4]
 8018f26:	6a12      	ldr	r2, [r2, #32]
 8018f28:	4610      	mov	r0, r2
 8018f2a:	4798      	blx	r3

            /* re-get tick */
            current_tick = rt_tick_get();
 8018f2c:	f7fc f9ac 	bl	8015288 <rt_tick_get>
 8018f30:	60f8      	str	r0, [r7, #12]

            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

			/* lock scheduler */
			rt_enter_critical();
 8018f32:	f7ff f941 	bl	80181b8 <rt_enter_critical>

            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
 8018f36:	687b      	ldr	r3, [r7, #4]
 8018f38:	7a5b      	ldrb	r3, [r3, #9]
 8018f3a:	f003 0302 	and.w	r3, r3, #2
 8018f3e:	2b00      	cmp	r3, #0
 8018f40:	d010      	beq.n	8018f64 <rt_soft_timer_check+0x90>
                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
 8018f42:	687b      	ldr	r3, [r7, #4]
 8018f44:	7a5b      	ldrb	r3, [r3, #9]
 8018f46:	f003 0301 	and.w	r3, r3, #1
            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

			/* lock scheduler */
			rt_enter_critical();

            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
 8018f4a:	2b00      	cmp	r3, #0
 8018f4c:	d00a      	beq.n	8018f64 <rt_soft_timer_check+0x90>
                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
            {
                /* start it */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 8018f4e:	687b      	ldr	r3, [r7, #4]
 8018f50:	7a5b      	ldrb	r3, [r3, #9]
 8018f52:	f023 0301 	bic.w	r3, r3, #1
 8018f56:	b2da      	uxtb	r2, r3
 8018f58:	687b      	ldr	r3, [r7, #4]
 8018f5a:	725a      	strb	r2, [r3, #9]
                rt_timer_start(t);
 8018f5c:	6878      	ldr	r0, [r7, #4]
 8018f5e:	f7ff fdd5 	bl	8018b0c <rt_timer_start>
 8018f62:	e006      	b.n	8018f72 <rt_soft_timer_check+0x9e>
            }
            else
            {
                /* stop timer */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 8018f64:	687b      	ldr	r3, [r7, #4]
 8018f66:	7a5b      	ldrb	r3, [r3, #9]
 8018f68:	f023 0301 	bic.w	r3, r3, #1
 8018f6c:	b2da      	uxtb	r2, r3
 8018f6e:	687b      	ldr	r3, [r7, #4]
 8018f70:	725a      	strb	r2, [r3, #9]
 8018f72:	e000      	b.n	8018f76 <rt_soft_timer_check+0xa2>
            }
        }
        else break; /* not check anymore */
 8018f74:	e003      	b.n	8018f7e <rt_soft_timer_check+0xaa>
    current_tick = rt_tick_get();

	/* lock scheduler */
	rt_enter_critical();

    for (n = rt_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1].next;
 8018f76:	68bb      	ldr	r3, [r7, #8]
 8018f78:	4a03      	ldr	r2, [pc, #12]	; (8018f88 <rt_soft_timer_check+0xb4>)
 8018f7a:	4293      	cmp	r3, r2
 8018f7c:	d1b6      	bne.n	8018eec <rt_soft_timer_check+0x18>
        }
        else break; /* not check anymore */
    }

	/* unlock scheduler */
	rt_exit_critical();
 8018f7e:	f7ff f92f 	bl	80181e0 <rt_exit_critical>

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("software timer check leave\n"));
}
 8018f82:	3710      	adds	r7, #16
 8018f84:	46bd      	mov	sp, r7
 8018f86:	bd80      	pop	{r7, pc}
 8018f88:	20010dd4 	.word	0x20010dd4
 8018f8c:	7ffffffe 	.word	0x7ffffffe
 8018f90:	2001105c 	.word	0x2001105c

08018f94 <rt_thread_timer_entry>:

/* system timer thread entry */
static void rt_thread_timer_entry(void *parameter)
{
 8018f94:	b580      	push	{r7, lr}
 8018f96:	b084      	sub	sp, #16
 8018f98:	af00      	add	r7, sp, #0
 8018f9a:	6078      	str	r0, [r7, #4]
    rt_tick_t next_timeout;

    while (1)
    {
        /* get the next timeout tick */
        next_timeout = rt_timer_list_next_timeout(rt_soft_timer_list);
 8018f9c:	4811      	ldr	r0, [pc, #68]	; (8018fe4 <rt_thread_timer_entry+0x50>)
 8018f9e:	f7ff fd1d 	bl	80189dc <rt_timer_list_next_timeout>
 8018fa2:	60f8      	str	r0, [r7, #12]
        if (next_timeout == RT_TICK_MAX)
 8018fa4:	68fb      	ldr	r3, [r7, #12]
 8018fa6:	f1b3 3fff 	cmp.w	r3, #4294967295
 8018faa:	d108      	bne.n	8018fbe <rt_thread_timer_entry+0x2a>
        {
            /* no software timer exist, suspend self. */
            rt_thread_suspend(rt_thread_self());
 8018fac:	f7ff fa74 	bl	8018498 <rt_thread_self>
 8018fb0:	4603      	mov	r3, r0
 8018fb2:	4618      	mov	r0, r3
 8018fb4:	f7ff fbf6 	bl	80187a4 <rt_thread_suspend>
            rt_schedule();
 8018fb8:	f7ff f832 	bl	8018020 <rt_schedule>
 8018fbc:	e00f      	b.n	8018fde <rt_thread_timer_entry+0x4a>
        else
        {
            rt_tick_t current_tick;

            /* get current tick */
            current_tick = rt_tick_get();
 8018fbe:	f7fc f963 	bl	8015288 <rt_tick_get>
 8018fc2:	60b8      	str	r0, [r7, #8]

            if ((next_timeout - current_tick) < RT_TICK_MAX/2)
 8018fc4:	68fa      	ldr	r2, [r7, #12]
 8018fc6:	68bb      	ldr	r3, [r7, #8]
 8018fc8:	1ad3      	subs	r3, r2, r3
 8018fca:	4a07      	ldr	r2, [pc, #28]	; (8018fe8 <rt_thread_timer_entry+0x54>)
 8018fcc:	4293      	cmp	r3, r2
 8018fce:	d806      	bhi.n	8018fde <rt_thread_timer_entry+0x4a>
            {
                /* get the delta timeout tick */
                next_timeout = next_timeout - current_tick;
 8018fd0:	68fa      	ldr	r2, [r7, #12]
 8018fd2:	68bb      	ldr	r3, [r7, #8]
 8018fd4:	1ad3      	subs	r3, r2, r3
 8018fd6:	60fb      	str	r3, [r7, #12]
                rt_thread_delay(next_timeout);
 8018fd8:	68f8      	ldr	r0, [r7, #12]
 8018fda:	f7ff fb7d 	bl	80186d8 <rt_thread_delay>
            }
        }

        /* check software timer */
        rt_soft_timer_check();
 8018fde:	f7ff ff79 	bl	8018ed4 <rt_soft_timer_check>
    }
 8018fe2:	e7db      	b.n	8018f9c <rt_thread_timer_entry+0x8>
 8018fe4:	20010dd4 	.word	0x20010dd4
 8018fe8:	7ffffffe 	.word	0x7ffffffe

08018fec <rt_system_timer_init>:
 * @ingroup SystemInit
 *
 * This function will initialize system timer
 */
void rt_system_timer_init(void)
{
 8018fec:	b580      	push	{r7, lr}
 8018fee:	b082      	sub	sp, #8
 8018ff0:	af00      	add	r7, sp, #0
    int i;

    for (i = 0; i < sizeof(rt_timer_list)/sizeof(rt_timer_list[0]); i++)
 8018ff2:	2300      	movs	r3, #0
 8018ff4:	607b      	str	r3, [r7, #4]
 8018ff6:	e009      	b.n	801900c <rt_system_timer_init+0x20>
    {
        rt_list_init(rt_timer_list+i);
 8018ff8:	687b      	ldr	r3, [r7, #4]
 8018ffa:	00db      	lsls	r3, r3, #3
 8018ffc:	4a06      	ldr	r2, [pc, #24]	; (8019018 <rt_system_timer_init+0x2c>)
 8018ffe:	4413      	add	r3, r2
 8019000:	4618      	mov	r0, r3
 8019002:	f7ff fc63 	bl	80188cc <rt_list_init>
 */
void rt_system_timer_init(void)
{
    int i;

    for (i = 0; i < sizeof(rt_timer_list)/sizeof(rt_timer_list[0]); i++)
 8019006:	687b      	ldr	r3, [r7, #4]
 8019008:	3301      	adds	r3, #1
 801900a:	607b      	str	r3, [r7, #4]
 801900c:	687b      	ldr	r3, [r7, #4]
 801900e:	2b00      	cmp	r3, #0
 8019010:	d0f2      	beq.n	8018ff8 <rt_system_timer_init+0xc>
    {
        rt_list_init(rt_timer_list+i);
    }
}
 8019012:	3708      	adds	r7, #8
 8019014:	46bd      	mov	sp, r7
 8019016:	bd80      	pop	{r7, pc}
 8019018:	20010dcc 	.word	0x20010dcc

0801901c <rt_system_timer_thread_init>:
 * @ingroup SystemInit
 *
 * This function will initialize system timer thread
 */
void rt_system_timer_thread_init(void)
{
 801901c:	b580      	push	{r7, lr}
 801901e:	b086      	sub	sp, #24
 8019020:	af04      	add	r7, sp, #16
#ifdef RT_USING_TIMER_SOFT
    int i;

    for (i = 0;
 8019022:	2300      	movs	r3, #0
 8019024:	607b      	str	r3, [r7, #4]
 8019026:	e009      	b.n	801903c <rt_system_timer_thread_init+0x20>
         i < sizeof(rt_soft_timer_list)/sizeof(rt_soft_timer_list[0]);
         i++)
    {
        rt_list_init(rt_soft_timer_list+i);
 8019028:	687b      	ldr	r3, [r7, #4]
 801902a:	00db      	lsls	r3, r3, #3
 801902c:	4a0f      	ldr	r2, [pc, #60]	; (801906c <rt_system_timer_thread_init+0x50>)
 801902e:	4413      	add	r3, r2
 8019030:	4618      	mov	r0, r3
 8019032:	f7ff fc4b 	bl	80188cc <rt_list_init>
#ifdef RT_USING_TIMER_SOFT
    int i;

    for (i = 0;
         i < sizeof(rt_soft_timer_list)/sizeof(rt_soft_timer_list[0]);
         i++)
 8019036:	687b      	ldr	r3, [r7, #4]
 8019038:	3301      	adds	r3, #1
 801903a:	607b      	str	r3, [r7, #4]
void rt_system_timer_thread_init(void)
{
#ifdef RT_USING_TIMER_SOFT
    int i;

    for (i = 0;
 801903c:	687b      	ldr	r3, [r7, #4]
 801903e:	2b00      	cmp	r3, #0
 8019040:	d0f2      	beq.n	8019028 <rt_system_timer_thread_init+0xc>
    {
        rt_list_init(rt_soft_timer_list+i);
    }

    /* start software timer thread */
    rt_thread_init(&timer_thread,
 8019042:	4b0b      	ldr	r3, [pc, #44]	; (8019070 <rt_system_timer_thread_init+0x54>)
 8019044:	9300      	str	r3, [sp, #0]
 8019046:	f44f 7300 	mov.w	r3, #512	; 0x200
 801904a:	9301      	str	r3, [sp, #4]
 801904c:	2304      	movs	r3, #4
 801904e:	9302      	str	r3, [sp, #8]
 8019050:	230a      	movs	r3, #10
 8019052:	9303      	str	r3, [sp, #12]
 8019054:	4807      	ldr	r0, [pc, #28]	; (8019074 <rt_system_timer_thread_init+0x58>)
 8019056:	4908      	ldr	r1, [pc, #32]	; (8019078 <rt_system_timer_thread_init+0x5c>)
 8019058:	4a08      	ldr	r2, [pc, #32]	; (801907c <rt_system_timer_thread_init+0x60>)
 801905a:	2300      	movs	r3, #0
 801905c:	f7ff f9e6 	bl	801842c <rt_thread_init>
                   sizeof(timer_thread_stack),
                   RT_TIMER_THREAD_PRIO,
                   10);

    /* startup */
    rt_thread_startup(&timer_thread);
 8019060:	4804      	ldr	r0, [pc, #16]	; (8019074 <rt_system_timer_thread_init+0x58>)
 8019062:	f7ff fa25 	bl	80184b0 <rt_thread_startup>
#endif
}
 8019066:	3708      	adds	r7, #8
 8019068:	46bd      	mov	sp, r7
 801906a:	bd80      	pop	{r7, pc}
 801906c:	20010dd4 	.word	0x20010dd4
 8019070:	20010e5c 	.word	0x20010e5c
 8019074:	20010ddc 	.word	0x20010ddc
 8019078:	080294e0 	.word	0x080294e0
 801907c:	08018f95 	.word	0x08018f95

08019080 <rt_hw_stack_init>:

rt_uint8_t *rt_hw_stack_init(void       *tentry,
                             void       *parameter,
                             rt_uint8_t *stack_addr,
                             void       *texit)
{
 8019080:	b480      	push	{r7}
 8019082:	b089      	sub	sp, #36	; 0x24
 8019084:	af00      	add	r7, sp, #0
 8019086:	60f8      	str	r0, [r7, #12]
 8019088:	60b9      	str	r1, [r7, #8]
 801908a:	607a      	str	r2, [r7, #4]
 801908c:	603b      	str	r3, [r7, #0]
    struct stack_frame *stack_frame;
    rt_uint8_t         *stk;
    unsigned long       i;

    stk  = stack_addr + sizeof(rt_uint32_t);
 801908e:	687b      	ldr	r3, [r7, #4]
 8019090:	3304      	adds	r3, #4
 8019092:	61bb      	str	r3, [r7, #24]
    stk  = (rt_uint8_t *)RT_ALIGN_DOWN((rt_uint32_t)stk, 8);
 8019094:	69bb      	ldr	r3, [r7, #24]
 8019096:	f023 0307 	bic.w	r3, r3, #7
 801909a:	61bb      	str	r3, [r7, #24]
    stk -= sizeof(struct stack_frame);
 801909c:	69bb      	ldr	r3, [r7, #24]
 801909e:	3b44      	subs	r3, #68	; 0x44
 80190a0:	61bb      	str	r3, [r7, #24]

    stack_frame = (struct stack_frame *)stk;
 80190a2:	69bb      	ldr	r3, [r7, #24]
 80190a4:	617b      	str	r3, [r7, #20]

    /* init all register */
    for (i = 0; i < sizeof(struct stack_frame) / sizeof(rt_uint32_t); i ++)
 80190a6:	2300      	movs	r3, #0
 80190a8:	61fb      	str	r3, [r7, #28]
 80190aa:	e008      	b.n	80190be <rt_hw_stack_init+0x3e>
    {
        ((rt_uint32_t *)stack_frame)[i] = 0xdeadbeef;
 80190ac:	69fb      	ldr	r3, [r7, #28]
 80190ae:	009b      	lsls	r3, r3, #2
 80190b0:	697a      	ldr	r2, [r7, #20]
 80190b2:	4413      	add	r3, r2
 80190b4:	4a15      	ldr	r2, [pc, #84]	; (801910c <rt_hw_stack_init+0x8c>)
 80190b6:	601a      	str	r2, [r3, #0]
    stk -= sizeof(struct stack_frame);

    stack_frame = (struct stack_frame *)stk;

    /* init all register */
    for (i = 0; i < sizeof(struct stack_frame) / sizeof(rt_uint32_t); i ++)
 80190b8:	69fb      	ldr	r3, [r7, #28]
 80190ba:	3301      	adds	r3, #1
 80190bc:	61fb      	str	r3, [r7, #28]
 80190be:	69fb      	ldr	r3, [r7, #28]
 80190c0:	2b10      	cmp	r3, #16
 80190c2:	d9f3      	bls.n	80190ac <rt_hw_stack_init+0x2c>
    {
        ((rt_uint32_t *)stack_frame)[i] = 0xdeadbeef;
    }

    stack_frame->exception_stack_frame.r0  = (unsigned long)parameter; /* r0 : argument */
 80190c4:	68ba      	ldr	r2, [r7, #8]
 80190c6:	697b      	ldr	r3, [r7, #20]
 80190c8:	625a      	str	r2, [r3, #36]	; 0x24
    stack_frame->exception_stack_frame.r1  = 0;                        /* r1 */
 80190ca:	697b      	ldr	r3, [r7, #20]
 80190cc:	2200      	movs	r2, #0
 80190ce:	629a      	str	r2, [r3, #40]	; 0x28
    stack_frame->exception_stack_frame.r2  = 0;                        /* r2 */
 80190d0:	697b      	ldr	r3, [r7, #20]
 80190d2:	2200      	movs	r2, #0
 80190d4:	62da      	str	r2, [r3, #44]	; 0x2c
    stack_frame->exception_stack_frame.r3  = 0;                        /* r3 */
 80190d6:	697b      	ldr	r3, [r7, #20]
 80190d8:	2200      	movs	r2, #0
 80190da:	631a      	str	r2, [r3, #48]	; 0x30
    stack_frame->exception_stack_frame.r12 = 0;                        /* r12 */
 80190dc:	697b      	ldr	r3, [r7, #20]
 80190de:	2200      	movs	r2, #0
 80190e0:	635a      	str	r2, [r3, #52]	; 0x34
    stack_frame->exception_stack_frame.lr  = (unsigned long)texit;     /* lr */
 80190e2:	683a      	ldr	r2, [r7, #0]
 80190e4:	697b      	ldr	r3, [r7, #20]
 80190e6:	639a      	str	r2, [r3, #56]	; 0x38
    stack_frame->exception_stack_frame.pc  = (unsigned long)tentry;    /* entry point, pc */
 80190e8:	68fa      	ldr	r2, [r7, #12]
 80190ea:	697b      	ldr	r3, [r7, #20]
 80190ec:	63da      	str	r2, [r3, #60]	; 0x3c
    stack_frame->exception_stack_frame.psr = 0x01000000L;              /* PSR */
 80190ee:	697b      	ldr	r3, [r7, #20]
 80190f0:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 80190f4:	641a      	str	r2, [r3, #64]	; 0x40

#if USE_FPU
    stack_frame->flag = 0;
 80190f6:	697b      	ldr	r3, [r7, #20]
 80190f8:	2200      	movs	r2, #0
 80190fa:	601a      	str	r2, [r3, #0]
#endif /* USE_FPU */

    /* return task's current stack address */
    return stk;
 80190fc:	69bb      	ldr	r3, [r7, #24]
}
 80190fe:	4618      	mov	r0, r3
 8019100:	3724      	adds	r7, #36	; 0x24
 8019102:	46bd      	mov	sp, r7
 8019104:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019108:	4770      	bx	lr
 801910a:	bf00      	nop
 801910c:	deadbeef 	.word	0xdeadbeef

08019110 <rt_hw_hard_fault_exception>:
{
    rt_exception_hook = exception_handle;
}

void rt_hw_hard_fault_exception(struct exception_stack_frame *exception_stack)
{
 8019110:	b580      	push	{r7, lr}
 8019112:	b084      	sub	sp, #16
 8019114:	af00      	add	r7, sp, #0
 8019116:	6078      	str	r0, [r7, #4]
    extern long list_thread(void);

    if (rt_exception_hook != RT_NULL)
 8019118:	4b24      	ldr	r3, [pc, #144]	; (80191ac <rt_hw_hard_fault_exception+0x9c>)
 801911a:	681b      	ldr	r3, [r3, #0]
 801911c:	2b00      	cmp	r3, #0
 801911e:	d008      	beq.n	8019132 <rt_hw_hard_fault_exception+0x22>
    {
        rt_err_t result;

        result = rt_exception_hook(exception_stack);
 8019120:	4b22      	ldr	r3, [pc, #136]	; (80191ac <rt_hw_hard_fault_exception+0x9c>)
 8019122:	681b      	ldr	r3, [r3, #0]
 8019124:	6878      	ldr	r0, [r7, #4]
 8019126:	4798      	blx	r3
 8019128:	60f8      	str	r0, [r7, #12]
        if (result == RT_EOK) return;
 801912a:	68fb      	ldr	r3, [r7, #12]
 801912c:	2b00      	cmp	r3, #0
 801912e:	d100      	bne.n	8019132 <rt_hw_hard_fault_exception+0x22>
 8019130:	e039      	b.n	80191a6 <rt_hw_hard_fault_exception+0x96>
    }

    rt_kprintf("psr: 0x%08x\n", exception_stack->psr);
 8019132:	687b      	ldr	r3, [r7, #4]
 8019134:	69db      	ldr	r3, [r3, #28]
 8019136:	481e      	ldr	r0, [pc, #120]	; (80191b0 <rt_hw_hard_fault_exception+0xa0>)
 8019138:	4619      	mov	r1, r3
 801913a:	f7fd ffe9 	bl	8017110 <rt_kprintf>
    rt_kprintf(" pc: 0x%08x\n", exception_stack->pc);
 801913e:	687b      	ldr	r3, [r7, #4]
 8019140:	699b      	ldr	r3, [r3, #24]
 8019142:	481c      	ldr	r0, [pc, #112]	; (80191b4 <rt_hw_hard_fault_exception+0xa4>)
 8019144:	4619      	mov	r1, r3
 8019146:	f7fd ffe3 	bl	8017110 <rt_kprintf>
    rt_kprintf(" lr: 0x%08x\n", exception_stack->lr);
 801914a:	687b      	ldr	r3, [r7, #4]
 801914c:	695b      	ldr	r3, [r3, #20]
 801914e:	481a      	ldr	r0, [pc, #104]	; (80191b8 <rt_hw_hard_fault_exception+0xa8>)
 8019150:	4619      	mov	r1, r3
 8019152:	f7fd ffdd 	bl	8017110 <rt_kprintf>
    rt_kprintf("r12: 0x%08x\n", exception_stack->r12);
 8019156:	687b      	ldr	r3, [r7, #4]
 8019158:	691b      	ldr	r3, [r3, #16]
 801915a:	4818      	ldr	r0, [pc, #96]	; (80191bc <rt_hw_hard_fault_exception+0xac>)
 801915c:	4619      	mov	r1, r3
 801915e:	f7fd ffd7 	bl	8017110 <rt_kprintf>
    rt_kprintf("r03: 0x%08x\n", exception_stack->r3);
 8019162:	687b      	ldr	r3, [r7, #4]
 8019164:	68db      	ldr	r3, [r3, #12]
 8019166:	4816      	ldr	r0, [pc, #88]	; (80191c0 <rt_hw_hard_fault_exception+0xb0>)
 8019168:	4619      	mov	r1, r3
 801916a:	f7fd ffd1 	bl	8017110 <rt_kprintf>
    rt_kprintf("r02: 0x%08x\n", exception_stack->r2);
 801916e:	687b      	ldr	r3, [r7, #4]
 8019170:	689b      	ldr	r3, [r3, #8]
 8019172:	4814      	ldr	r0, [pc, #80]	; (80191c4 <rt_hw_hard_fault_exception+0xb4>)
 8019174:	4619      	mov	r1, r3
 8019176:	f7fd ffcb 	bl	8017110 <rt_kprintf>
    rt_kprintf("r01: 0x%08x\n", exception_stack->r1);
 801917a:	687b      	ldr	r3, [r7, #4]
 801917c:	685b      	ldr	r3, [r3, #4]
 801917e:	4812      	ldr	r0, [pc, #72]	; (80191c8 <rt_hw_hard_fault_exception+0xb8>)
 8019180:	4619      	mov	r1, r3
 8019182:	f7fd ffc5 	bl	8017110 <rt_kprintf>
    rt_kprintf("r00: 0x%08x\n", exception_stack->r0);
 8019186:	687b      	ldr	r3, [r7, #4]
 8019188:	681b      	ldr	r3, [r3, #0]
 801918a:	4810      	ldr	r0, [pc, #64]	; (80191cc <rt_hw_hard_fault_exception+0xbc>)
 801918c:	4619      	mov	r1, r3
 801918e:	f7fd ffbf 	bl	8017110 <rt_kprintf>

    rt_kprintf("hard fault on thread: %s\n", rt_thread_self()->name);
 8019192:	f7ff f981 	bl	8018498 <rt_thread_self>
 8019196:	4603      	mov	r3, r0
 8019198:	480d      	ldr	r0, [pc, #52]	; (80191d0 <rt_hw_hard_fault_exception+0xc0>)
 801919a:	4619      	mov	r1, r3
 801919c:	f7fd ffb8 	bl	8017110 <rt_kprintf>

#ifdef RT_USING_FINSH
    list_thread();
 80191a0:	f003 fb76 	bl	801c890 <list_thread>
#endif

    while (1);
 80191a4:	e7fe      	b.n	80191a4 <rt_hw_hard_fault_exception+0x94>
}
 80191a6:	3710      	adds	r7, #16
 80191a8:	46bd      	mov	sp, r7
 80191aa:	bd80      	pop	{r7, pc}
 80191ac:	20011064 	.word	0x20011064
 80191b0:	080294e8 	.word	0x080294e8
 80191b4:	080294f8 	.word	0x080294f8
 80191b8:	08029508 	.word	0x08029508
 80191bc:	08029518 	.word	0x08029518
 80191c0:	08029528 	.word	0x08029528
 80191c4:	08029538 	.word	0x08029538
 80191c8:	08029548 	.word	0x08029548
 80191cc:	08029558 	.word	0x08029558
 80191d0:	08029568 	.word	0x08029568

080191d4 <clock_time_system_init>:
#include <rtthread.h>
#include <pthread.h>

struct timeval _timevalue;
void clock_time_system_init()
{
 80191d4:	b580      	push	{r7, lr}
 80191d6:	b084      	sub	sp, #16
 80191d8:	af00      	add	r7, sp, #0
    time_t time;
    rt_tick_t tick;
    rt_device_t device;

    time = 0;
 80191da:	2300      	movs	r3, #0
 80191dc:	607b      	str	r3, [r7, #4]
    device = rt_device_find("rtc");
 80191de:	4818      	ldr	r0, [pc, #96]	; (8019240 <clock_time_system_init+0x6c>)
 80191e0:	f7fc f908 	bl	80153f4 <rt_device_find>
 80191e4:	60f8      	str	r0, [r7, #12]
    if (device != RT_NULL)
 80191e6:	68fb      	ldr	r3, [r7, #12]
 80191e8:	2b00      	cmp	r3, #0
 80191ea:	d005      	beq.n	80191f8 <clock_time_system_init+0x24>
    {
        /* get realtime seconds */
        rt_device_control(device, RT_DEVICE_CTRL_RTC_GET_TIME, &time);
 80191ec:	1d3b      	adds	r3, r7, #4
 80191ee:	68f8      	ldr	r0, [r7, #12]
 80191f0:	2110      	movs	r1, #16
 80191f2:	461a      	mov	r2, r3
 80191f4:	f7fc fa54 	bl	80156a0 <rt_device_control>
    }

    /* get tick */
    tick = rt_tick_get();
 80191f8:	f7fc f846 	bl	8015288 <rt_tick_get>
 80191fc:	60b8      	str	r0, [r7, #8]

    _timevalue.tv_usec = (tick%RT_TICK_PER_SECOND) * MICROSECOND_PER_TICK;
 80191fe:	68ba      	ldr	r2, [r7, #8]
 8019200:	4b10      	ldr	r3, [pc, #64]	; (8019244 <clock_time_system_init+0x70>)
 8019202:	fba3 1302 	umull	r1, r3, r3, r2
 8019206:	09db      	lsrs	r3, r3, #7
 8019208:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 801920c:	fb01 f303 	mul.w	r3, r1, r3
 8019210:	1ad3      	subs	r3, r2, r3
 8019212:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8019216:	fb02 f303 	mul.w	r3, r2, r3
 801921a:	461a      	mov	r2, r3
 801921c:	4b0a      	ldr	r3, [pc, #40]	; (8019248 <clock_time_system_init+0x74>)
 801921e:	605a      	str	r2, [r3, #4]
    _timevalue.tv_sec = time - tick/RT_TICK_PER_SECOND - 1;
 8019220:	687b      	ldr	r3, [r7, #4]
 8019222:	4619      	mov	r1, r3
 8019224:	68bb      	ldr	r3, [r7, #8]
 8019226:	4a07      	ldr	r2, [pc, #28]	; (8019244 <clock_time_system_init+0x70>)
 8019228:	fba2 2303 	umull	r2, r3, r2, r3
 801922c:	09db      	lsrs	r3, r3, #7
 801922e:	1acb      	subs	r3, r1, r3
 8019230:	3b01      	subs	r3, #1
 8019232:	461a      	mov	r2, r3
 8019234:	4b04      	ldr	r3, [pc, #16]	; (8019248 <clock_time_system_init+0x74>)
 8019236:	601a      	str	r2, [r3, #0]
}
 8019238:	3710      	adds	r7, #16
 801923a:	46bd      	mov	sp, r7
 801923c:	bd80      	pop	{r7, pc}
 801923e:	bf00      	nop
 8019240:	08029598 	.word	0x08029598
 8019244:	10624dd3 	.word	0x10624dd3
 8019248:	20012b90 	.word	0x20012b90

0801924c <posix_mq_system_init>:
#include "pthread_internal.h"

static mqd_t posix_mq_list = RT_NULL;
static struct rt_semaphore posix_mq_lock;
void posix_mq_system_init()
{
 801924c:	b580      	push	{r7, lr}
 801924e:	af00      	add	r7, sp, #0
    rt_sem_init(&posix_mq_lock, "pmq", 1, RT_IPC_FLAG_FIFO);
 8019250:	4803      	ldr	r0, [pc, #12]	; (8019260 <posix_mq_system_init+0x14>)
 8019252:	4904      	ldr	r1, [pc, #16]	; (8019264 <posix_mq_system_init+0x18>)
 8019254:	2201      	movs	r2, #1
 8019256:	2300      	movs	r3, #0
 8019258:	f7fc fbe0 	bl	8015a1c <rt_sem_init>
}
 801925c:	bd80      	pop	{r7, pc}
 801925e:	bf00      	nop
 8019260:	20011068 	.word	0x20011068
 8019264:	080295ac 	.word	0x080295ac

08019268 <pthread_system_init>:
#include <pthread.h>
#include <sched.h>
#include "pthread_internal.h"

int pthread_system_init(void)
{
 8019268:	b580      	push	{r7, lr}
 801926a:	af00      	add	r7, sp, #0
    /* initialize clock and time */
    clock_time_system_init();
 801926c:	f7ff ffb2 	bl	80191d4 <clock_time_system_init>

    /* initialize key area */
    pthread_key_system_init();
 8019270:	f000 f808 	bl	8019284 <pthread_key_system_init>
    /* initialize posix mqueue */
    posix_mq_system_init();
 8019274:	f7ff ffea 	bl	801924c <posix_mq_system_init>
    /* initialize posix semaphore */
    posix_sem_system_init();
 8019278:	f000 f80e 	bl	8019298 <posix_sem_system_init>

    return 0;
 801927c:	2300      	movs	r3, #0
}
 801927e:	4618      	mov	r0, r3
 8019280:	bd80      	pop	{r7, pc}
 8019282:	bf00      	nop

08019284 <pthread_key_system_init>:
#include "pthread_internal.h"

_pthread_key_data_t _thread_keys[PTHREAD_KEY_MAX];

void pthread_key_system_init()
{
 8019284:	b580      	push	{r7, lr}
 8019286:	af00      	add	r7, sp, #0
    rt_memset(&_thread_keys[0], 0, sizeof(_thread_keys));
 8019288:	4802      	ldr	r0, [pc, #8]	; (8019294 <pthread_key_system_init+0x10>)
 801928a:	2100      	movs	r1, #0
 801928c:	2240      	movs	r2, #64	; 0x40
 801928e:	f7fd f987 	bl	80165a0 <rt_memset>
}
 8019292:	bd80      	pop	{r7, pc}
 8019294:	20012b98 	.word	0x20012b98

08019298 <posix_sem_system_init>:
#include "pthread_internal.h"

static sem_t *posix_sem_list = RT_NULL;
static struct rt_semaphore posix_sem_lock;
void posix_sem_system_init()
{
 8019298:	b580      	push	{r7, lr}
 801929a:	af00      	add	r7, sp, #0
    rt_sem_init(&posix_sem_lock, "psem", 1, RT_IPC_FLAG_FIFO);
 801929c:	4803      	ldr	r0, [pc, #12]	; (80192ac <posix_sem_system_init+0x14>)
 801929e:	4904      	ldr	r1, [pc, #16]	; (80192b0 <posix_sem_system_init+0x18>)
 80192a0:	2201      	movs	r2, #1
 80192a2:	2300      	movs	r3, #0
 80192a4:	f7fc fbba 	bl	8015a1c <rt_sem_init>
}
 80192a8:	bd80      	pop	{r7, pc}
 80192aa:	bf00      	nop
 80192ac:	20011088 	.word	0x20011088
 80192b0:	080295b0 	.word	0x080295b0

080192b4 <libc_system_init>:
#endif

#endif

int libc_system_init(void)
{
 80192b4:	b580      	push	{r7, lr}
 80192b6:	af00      	add	r7, sp, #0
        fd = fd;
    }
#endif

    /* set PATH and HOME */
    putenv("PATH=/bin");
 80192b8:	4805      	ldr	r0, [pc, #20]	; (80192d0 <libc_system_init+0x1c>)
 80192ba:	f009 fcef 	bl	8022c9c <putenv>
    putenv("HOME=/home");
 80192be:	4805      	ldr	r0, [pc, #20]	; (80192d4 <libc_system_init+0x20>)
 80192c0:	f009 fcec 	bl	8022c9c <putenv>

#ifdef RT_USING_PTHREADS
    pthread_system_init();
 80192c4:	f7ff ffd0 	bl	8019268 <pthread_system_init>
#endif

    return 0;
 80192c8:	2300      	movs	r3, #0
}
 80192ca:	4618      	mov	r0, r3
 80192cc:	bd80      	pop	{r7, pc}
 80192ce:	bf00      	nop
 80192d0:	080295c4 	.word	0x080295c4
 80192d4:	080295d0 	.word	0x080295d0

080192d8 <_malloc_r>:
#endif

/* Memory routine */
void *
_malloc_r (struct _reent *ptr, size_t size)
{
 80192d8:	b580      	push	{r7, lr}
 80192da:	b084      	sub	sp, #16
 80192dc:	af00      	add	r7, sp, #0
 80192de:	6078      	str	r0, [r7, #4]
 80192e0:	6039      	str	r1, [r7, #0]
	void* result;

	result = (void*)rt_malloc (size);
 80192e2:	6838      	ldr	r0, [r7, #0]
 80192e4:	f7fe f8c2 	bl	801746c <rt_malloc>
 80192e8:	60f8      	str	r0, [r7, #12]
	if (result == RT_NULL)
 80192ea:	68fb      	ldr	r3, [r7, #12]
 80192ec:	2b00      	cmp	r3, #0
 80192ee:	d102      	bne.n	80192f6 <_malloc_r+0x1e>
	{
		ptr->_errno = ENOMEM;
 80192f0:	687b      	ldr	r3, [r7, #4]
 80192f2:	220c      	movs	r2, #12
 80192f4:	601a      	str	r2, [r3, #0]
	}

	return result;
 80192f6:	68fb      	ldr	r3, [r7, #12]
}
 80192f8:	4618      	mov	r0, r3
 80192fa:	3710      	adds	r7, #16
 80192fc:	46bd      	mov	sp, r7
 80192fe:	bd80      	pop	{r7, pc}

08019300 <_realloc_r>:

void *
_realloc_r (struct _reent *ptr, void *old, size_t newlen)
{
 8019300:	b580      	push	{r7, lr}
 8019302:	b086      	sub	sp, #24
 8019304:	af00      	add	r7, sp, #0
 8019306:	60f8      	str	r0, [r7, #12]
 8019308:	60b9      	str	r1, [r7, #8]
 801930a:	607a      	str	r2, [r7, #4]
	void* result;

	result = (void*)rt_realloc (old, newlen);
 801930c:	68b8      	ldr	r0, [r7, #8]
 801930e:	6879      	ldr	r1, [r7, #4]
 8019310:	f7fe f9f2 	bl	80176f8 <rt_realloc>
 8019314:	6178      	str	r0, [r7, #20]
	if (result == RT_NULL)
 8019316:	697b      	ldr	r3, [r7, #20]
 8019318:	2b00      	cmp	r3, #0
 801931a:	d102      	bne.n	8019322 <_realloc_r+0x22>
	{
		ptr->_errno = ENOMEM;
 801931c:	68fb      	ldr	r3, [r7, #12]
 801931e:	220c      	movs	r2, #12
 8019320:	601a      	str	r2, [r3, #0]
	}

	return result;
 8019322:	697b      	ldr	r3, [r7, #20]
}
 8019324:	4618      	mov	r0, r3
 8019326:	3718      	adds	r7, #24
 8019328:	46bd      	mov	sp, r7
 801932a:	bd80      	pop	{r7, pc}

0801932c <_calloc_r>:

void *_calloc_r (struct _reent *ptr, size_t size, size_t len)
{
 801932c:	b580      	push	{r7, lr}
 801932e:	b086      	sub	sp, #24
 8019330:	af00      	add	r7, sp, #0
 8019332:	60f8      	str	r0, [r7, #12]
 8019334:	60b9      	str	r1, [r7, #8]
 8019336:	607a      	str	r2, [r7, #4]
	void* result;

	result = (void*)rt_calloc (size, len);
 8019338:	68b8      	ldr	r0, [r7, #8]
 801933a:	6879      	ldr	r1, [r7, #4]
 801933c:	f7fe faa0 	bl	8017880 <rt_calloc>
 8019340:	6178      	str	r0, [r7, #20]
	if (result == RT_NULL)
 8019342:	697b      	ldr	r3, [r7, #20]
 8019344:	2b00      	cmp	r3, #0
 8019346:	d102      	bne.n	801934e <_calloc_r+0x22>
	{
		ptr->_errno = ENOMEM;
 8019348:	68fb      	ldr	r3, [r7, #12]
 801934a:	220c      	movs	r2, #12
 801934c:	601a      	str	r2, [r3, #0]
	}

	return result;
 801934e:	697b      	ldr	r3, [r7, #20]
}
 8019350:	4618      	mov	r0, r3
 8019352:	3718      	adds	r7, #24
 8019354:	46bd      	mov	sp, r7
 8019356:	bd80      	pop	{r7, pc}

08019358 <_free_r>:

void 
_free_r (struct _reent *ptr, void *addr)
{
 8019358:	b580      	push	{r7, lr}
 801935a:	b082      	sub	sp, #8
 801935c:	af00      	add	r7, sp, #0
 801935e:	6078      	str	r0, [r7, #4]
 8019360:	6039      	str	r1, [r7, #0]
	rt_free (addr);
 8019362:	6838      	ldr	r0, [r7, #0]
 8019364:	f7fe fac6 	bl	80178f4 <rt_free>
}
 8019368:	3708      	adds	r7, #8
 801936a:	46bd      	mov	sp, r7
 801936c:	bd80      	pop	{r7, pc}
 801936e:	bf00      	nop

08019370 <__libc_init_array>:
    /* not support this call */
    return;
}

void __libc_init_array(void)
{
 8019370:	b480      	push	{r7}
 8019372:	af00      	add	r7, sp, #0
	/* we not use __libc init_aray to initialize C++ objects */
}
 8019374:	46bd      	mov	sp, r7
 8019376:	f85d 7b04 	ldr.w	r7, [sp], #4
 801937a:	4770      	bx	lr

0801937c <osDelay>:

// Generic Wait API

/// Wait for Timeout (Time Delay)
osStatus osDelay(uint32_t millisec)
{
 801937c:	b580      	push	{r7, lr}
 801937e:	b084      	sub	sp, #16
 8019380:	af00      	add	r7, sp, #0
 8019382:	6078      	str	r0, [r7, #4]
    rt_err_t result;
    rt_tick_t ticks;

    ticks = rt_tick_from_millisecond(millisec);
 8019384:	6878      	ldr	r0, [r7, #4]
 8019386:	f7fb ffad 	bl	80152e4 <rt_tick_from_millisecond>
 801938a:	60f8      	str	r0, [r7, #12]
    result = rt_thread_delay(ticks);
 801938c:	68f8      	ldr	r0, [r7, #12]
 801938e:	f7ff f9a3 	bl	80186d8 <rt_thread_delay>
 8019392:	60b8      	str	r0, [r7, #8]

    if (result == RT_EOK)
 8019394:	68bb      	ldr	r3, [r7, #8]
 8019396:	2b00      	cmp	r3, #0
 8019398:	d101      	bne.n	801939e <osDelay+0x22>
        return osOK;
 801939a:	2300      	movs	r3, #0
 801939c:	e000      	b.n	80193a0 <osDelay+0x24>
    else
        return osErrorOS;
 801939e:	23ff      	movs	r3, #255	; 0xff
}
 80193a0:	4618      	mov	r0, r3
 80193a2:	3710      	adds	r7, #16
 80193a4:	46bd      	mov	sp, r7
 80193a6:	bd80      	pop	{r7, pc}

080193a8 <osTimerCreate>:

// Timer Management Public API

/// Create timer
osTimerId osTimerCreate(osTimerDef_t *timer_def, os_timer_type type, void *argument)
{
 80193a8:	b590      	push	{r4, r7, lr}
 80193aa:	b089      	sub	sp, #36	; 0x24
 80193ac:	af02      	add	r7, sp, #8
 80193ae:	60f8      	str	r0, [r7, #12]
 80193b0:	460b      	mov	r3, r1
 80193b2:	607a      	str	r2, [r7, #4]
 80193b4:	72fb      	strb	r3, [r7, #11]
    uint8_t flag = RT_TIMER_FLAG_SOFT_TIMER;
 80193b6:	2304      	movs	r3, #4
 80193b8:	75fb      	strb	r3, [r7, #23]

    if (type == osTimerPeriodic)
 80193ba:	7afb      	ldrb	r3, [r7, #11]
 80193bc:	2b01      	cmp	r3, #1
 80193be:	d103      	bne.n	80193c8 <osTimerCreate+0x20>
    {
        flag |= RT_TIMER_FLAG_PERIODIC;
 80193c0:	7dfb      	ldrb	r3, [r7, #23]
 80193c2:	f043 0302 	orr.w	r3, r3, #2
 80193c6:	75fb      	strb	r3, [r7, #23]
    }

    return rt_timer_create(timer_def->name, timer_def->timeout, argument, timer_def->time, flag);
 80193c8:	68fb      	ldr	r3, [r7, #12]
 80193ca:	6819      	ldr	r1, [r3, #0]
 80193cc:	68fb      	ldr	r3, [r7, #12]
 80193ce:	685a      	ldr	r2, [r3, #4]
 80193d0:	68fb      	ldr	r3, [r7, #12]
 80193d2:	68dc      	ldr	r4, [r3, #12]
 80193d4:	7dfb      	ldrb	r3, [r7, #23]
 80193d6:	9300      	str	r3, [sp, #0]
 80193d8:	4608      	mov	r0, r1
 80193da:	4611      	mov	r1, r2
 80193dc:	687a      	ldr	r2, [r7, #4]
 80193de:	4623      	mov	r3, r4
 80193e0:	f7ff fb74 	bl	8018acc <rt_timer_create>
 80193e4:	4603      	mov	r3, r0
}
 80193e6:	4618      	mov	r0, r3
 80193e8:	371c      	adds	r7, #28
 80193ea:	46bd      	mov	sp, r7
 80193ec:	bd90      	pop	{r4, r7, pc}
 80193ee:	bf00      	nop

080193f0 <osTimerStart>:

/// Start or restart timer
osStatus osTimerStart(osTimerId timer_id, uint32_t millisec)
{
 80193f0:	b580      	push	{r7, lr}
 80193f2:	b084      	sub	sp, #16
 80193f4:	af00      	add	r7, sp, #0
 80193f6:	6078      	str	r0, [r7, #4]
 80193f8:	6039      	str	r1, [r7, #0]
    rt_err_t result;
    rt_tick_t ticks;

    ticks = rt_tick_from_millisecond(millisec);
 80193fa:	6838      	ldr	r0, [r7, #0]
 80193fc:	f7fb ff72 	bl	80152e4 <rt_tick_from_millisecond>
 8019400:	4603      	mov	r3, r0
 8019402:	60bb      	str	r3, [r7, #8]
    rt_timer_control(timer_id, RT_TIMER_CTRL_SET_TIME, &ticks);
 8019404:	f107 0308 	add.w	r3, r7, #8
 8019408:	6878      	ldr	r0, [r7, #4]
 801940a:	2100      	movs	r1, #0
 801940c:	461a      	mov	r2, r3
 801940e:	f7ff fcc3 	bl	8018d98 <rt_timer_control>
    result = rt_timer_start(timer_id);
 8019412:	6878      	ldr	r0, [r7, #4]
 8019414:	f7ff fb7a 	bl	8018b0c <rt_timer_start>
 8019418:	60f8      	str	r0, [r7, #12]
    if (result == RT_EOK)
 801941a:	68fb      	ldr	r3, [r7, #12]
 801941c:	2b00      	cmp	r3, #0
 801941e:	d101      	bne.n	8019424 <osTimerStart+0x34>
        return osOK;
 8019420:	2300      	movs	r3, #0
 8019422:	e000      	b.n	8019426 <osTimerStart+0x36>
    else
        return osErrorOS;
 8019424:	23ff      	movs	r3, #255	; 0xff
}
 8019426:	4618      	mov	r0, r3
 8019428:	3710      	adds	r7, #16
 801942a:	46bd      	mov	sp, r7
 801942c:	bd80      	pop	{r7, pc}
 801942e:	bf00      	nop

08019430 <osMessageCreate>:

// Message Queue Management Public API

/// Create and Initialize Message Queue
osMessageQId osMessageCreate(osMessageQDef_t *queue_def, osThreadId thread_id)
{
 8019430:	b580      	push	{r7, lr}
 8019432:	b082      	sub	sp, #8
 8019434:	af00      	add	r7, sp, #0
 8019436:	6078      	str	r0, [r7, #4]
 8019438:	6039      	str	r1, [r7, #0]
    return rt_mq_create(queue_def->name, queue_def->msg_size, queue_def->max_msgs, queue_def->flag);
 801943a:	687b      	ldr	r3, [r7, #4]
 801943c:	6818      	ldr	r0, [r3, #0]
 801943e:	687b      	ldr	r3, [r7, #4]
 8019440:	6899      	ldr	r1, [r3, #8]
 8019442:	687b      	ldr	r3, [r7, #4]
 8019444:	685a      	ldr	r2, [r3, #4]
 8019446:	687b      	ldr	r3, [r7, #4]
 8019448:	7b1b      	ldrb	r3, [r3, #12]
 801944a:	f7fc fddd 	bl	8016008 <rt_mq_create>
 801944e:	4603      	mov	r3, r0
}
 8019450:	4618      	mov	r0, r3
 8019452:	3708      	adds	r7, #8
 8019454:	46bd      	mov	sp, r7
 8019456:	bd80      	pop	{r7, pc}

08019458 <osMessagePut>:

/// Put a Message to a Queue
osStatus osMessagePut(osMessageQId queue_id, uint32_t info, uint32_t millisec)
{
 8019458:	b580      	push	{r7, lr}
 801945a:	b086      	sub	sp, #24
 801945c:	af00      	add	r7, sp, #0
 801945e:	60f8      	str	r0, [r7, #12]
 8019460:	60b9      	str	r1, [r7, #8]
 8019462:	607a      	str	r2, [r7, #4]
    rt_err_t result;

    result = rt_mq_send(queue_id,&info, 4);
 8019464:	f107 0308 	add.w	r3, r7, #8
 8019468:	68f8      	ldr	r0, [r7, #12]
 801946a:	4619      	mov	r1, r3
 801946c:	2204      	movs	r2, #4
 801946e:	f7fc fe89 	bl	8016184 <rt_mq_send>
 8019472:	6178      	str	r0, [r7, #20]

    if (result == RT_EOK)
 8019474:	697b      	ldr	r3, [r7, #20]
 8019476:	2b00      	cmp	r3, #0
 8019478:	d101      	bne.n	801947e <osMessagePut+0x26>
        return osOK;
 801947a:	2300      	movs	r3, #0
 801947c:	e000      	b.n	8019480 <osMessagePut+0x28>
    else
        return osErrorOS;
 801947e:	23ff      	movs	r3, #255	; 0xff
}
 8019480:	4618      	mov	r0, r3
 8019482:	3718      	adds	r7, #24
 8019484:	46bd      	mov	sp, r7
 8019486:	bd80      	pop	{r7, pc}

08019488 <osMessageGet>:

/// Get a Message or Wait for a Message from a Queue
osEvent osMessageGet(osMessageQId queue_id, uint32_t millisec)
{
 8019488:	b590      	push	{r4, r7, lr}
 801948a:	b08b      	sub	sp, #44	; 0x2c
 801948c:	af00      	add	r7, sp, #0
 801948e:	60f8      	str	r0, [r7, #12]
 8019490:	60b9      	str	r1, [r7, #8]
 8019492:	607a      	str	r2, [r7, #4]
    osEvent event;
    rt_err_t result;
    rt_tick_t ticks;

    ticks = rt_tick_from_millisecond(millisec);
 8019494:	6878      	ldr	r0, [r7, #4]
 8019496:	f7fb ff25 	bl	80152e4 <rt_tick_from_millisecond>
 801949a:	6278      	str	r0, [r7, #36]	; 0x24
    result = rt_mq_recv(queue_id, &event.value, 4, ticks);
 801949c:	6a7c      	ldr	r4, [r7, #36]	; 0x24
 801949e:	f107 0314 	add.w	r3, r7, #20
 80194a2:	3304      	adds	r3, #4
 80194a4:	68b8      	ldr	r0, [r7, #8]
 80194a6:	4619      	mov	r1, r3
 80194a8:	2204      	movs	r2, #4
 80194aa:	4623      	mov	r3, r4
 80194ac:	f7fc ff04 	bl	80162b8 <rt_mq_recv>
 80194b0:	6238      	str	r0, [r7, #32]

    if (result == RT_EOK)
 80194b2:	6a3b      	ldr	r3, [r7, #32]
 80194b4:	2b00      	cmp	r3, #0
 80194b6:	d102      	bne.n	80194be <osMessageGet+0x36>
    {
        event.status = osEventMessage;
 80194b8:	2310      	movs	r3, #16
 80194ba:	617b      	str	r3, [r7, #20]
 80194bc:	e001      	b.n	80194c2 <osMessageGet+0x3a>
    }
    else
    {
        event.status = osEventTimeout;
 80194be:	2340      	movs	r3, #64	; 0x40
 80194c0:	617b      	str	r3, [r7, #20]
    }

    return event;
 80194c2:	68fb      	ldr	r3, [r7, #12]
 80194c4:	461c      	mov	r4, r3
 80194c6:	f107 0314 	add.w	r3, r7, #20
 80194ca:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80194ce:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 80194d2:	68f8      	ldr	r0, [r7, #12]
 80194d4:	372c      	adds	r7, #44	; 0x2c
 80194d6:	46bd      	mov	sp, r7
 80194d8:	bd90      	pop	{r4, r7, pc}
 80194da:	bf00      	nop

080194dc <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 80194dc:	b480      	push	{r7}
 80194de:	b083      	sub	sp, #12
 80194e0:	af00      	add	r7, sp, #0
 80194e2:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 80194e4:	687b      	ldr	r3, [r7, #4]
 80194e6:	687a      	ldr	r2, [r7, #4]
 80194e8:	605a      	str	r2, [r3, #4]
 80194ea:	687b      	ldr	r3, [r7, #4]
 80194ec:	685a      	ldr	r2, [r3, #4]
 80194ee:	687b      	ldr	r3, [r7, #4]
 80194f0:	601a      	str	r2, [r3, #0]
}
 80194f2:	370c      	adds	r7, #12
 80194f4:	46bd      	mov	sp, r7
 80194f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80194fa:	4770      	bx	lr

080194fc <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 80194fc:	b480      	push	{r7}
 80194fe:	b083      	sub	sp, #12
 8019500:	af00      	add	r7, sp, #0
 8019502:	6078      	str	r0, [r7, #4]
 8019504:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 8019506:	687b      	ldr	r3, [r7, #4]
 8019508:	685b      	ldr	r3, [r3, #4]
 801950a:	683a      	ldr	r2, [r7, #0]
 801950c:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 801950e:	687b      	ldr	r3, [r7, #4]
 8019510:	685a      	ldr	r2, [r3, #4]
 8019512:	683b      	ldr	r3, [r7, #0]
 8019514:	605a      	str	r2, [r3, #4]

    l->prev = n;
 8019516:	687b      	ldr	r3, [r7, #4]
 8019518:	683a      	ldr	r2, [r7, #0]
 801951a:	605a      	str	r2, [r3, #4]
    n->next = l;
 801951c:	683b      	ldr	r3, [r7, #0]
 801951e:	687a      	ldr	r2, [r7, #4]
 8019520:	601a      	str	r2, [r3, #0]
}
 8019522:	370c      	adds	r7, #12
 8019524:	46bd      	mov	sp, r7
 8019526:	f85d 7b04 	ldr.w	r7, [sp], #4
 801952a:	4770      	bx	lr

0801952c <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 801952c:	b480      	push	{r7}
 801952e:	b083      	sub	sp, #12
 8019530:	af00      	add	r7, sp, #0
 8019532:	6078      	str	r0, [r7, #4]
    return l->next == l;
 8019534:	687b      	ldr	r3, [r7, #4]
 8019536:	681a      	ldr	r2, [r3, #0]
 8019538:	687b      	ldr	r3, [r7, #4]
 801953a:	429a      	cmp	r2, r3
 801953c:	bf0c      	ite	eq
 801953e:	2301      	moveq	r3, #1
 8019540:	2300      	movne	r3, #0
 8019542:	b2db      	uxtb	r3, r3
}
 8019544:	4618      	mov	r0, r3
 8019546:	370c      	adds	r7, #12
 8019548:	46bd      	mov	sp, r7
 801954a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801954e:	4770      	bx	lr

08019550 <rt_completion_init>:

#define RT_COMPLETED    1
#define RT_UNCOMPLETED  0

void rt_completion_init(struct rt_completion *completion)
{
 8019550:	b580      	push	{r7, lr}
 8019552:	b084      	sub	sp, #16
 8019554:	af00      	add	r7, sp, #0
 8019556:	6078      	str	r0, [r7, #4]
    rt_base_t level;
    RT_ASSERT(completion != RT_NULL);
 8019558:	687b      	ldr	r3, [r7, #4]
 801955a:	2b00      	cmp	r3, #0
 801955c:	d104      	bne.n	8019568 <rt_completion_init+0x18>
 801955e:	480b      	ldr	r0, [pc, #44]	; (801958c <rt_completion_init+0x3c>)
 8019560:	490b      	ldr	r1, [pc, #44]	; (8019590 <rt_completion_init+0x40>)
 8019562:	2223      	movs	r2, #35	; 0x23
 8019564:	f7fd fe4e 	bl	8017204 <rt_assert_handler>

    level = rt_hw_interrupt_disable();
 8019568:	f7e6 fe30 	bl	80001cc <rt_hw_interrupt_disable>
 801956c:	60f8      	str	r0, [r7, #12]
    completion->flag = RT_UNCOMPLETED;
 801956e:	687b      	ldr	r3, [r7, #4]
 8019570:	2200      	movs	r2, #0
 8019572:	601a      	str	r2, [r3, #0]
    rt_list_init(&completion->suspended_list);
 8019574:	687b      	ldr	r3, [r7, #4]
 8019576:	3304      	adds	r3, #4
 8019578:	4618      	mov	r0, r3
 801957a:	f7ff ffaf 	bl	80194dc <rt_list_init>
    rt_hw_interrupt_enable(level);
 801957e:	68f8      	ldr	r0, [r7, #12]
 8019580:	f7e6 fe28 	bl	80001d4 <rt_hw_interrupt_enable>
}
 8019584:	3710      	adds	r7, #16
 8019586:	46bd      	mov	sp, r7
 8019588:	bd80      	pop	{r7, pc}
 801958a:	bf00      	nop
 801958c:	080295dc 	.word	0x080295dc
 8019590:	0802ab08 	.word	0x0802ab08

08019594 <rt_completion_wait>:
RTM_EXPORT(rt_completion_init);

rt_err_t rt_completion_wait(struct rt_completion *completion,
                            rt_int32_t            timeout)
{
 8019594:	b580      	push	{r7, lr}
 8019596:	b086      	sub	sp, #24
 8019598:	af00      	add	r7, sp, #0
 801959a:	6078      	str	r0, [r7, #4]
 801959c:	6039      	str	r1, [r7, #0]
    rt_err_t result;
    rt_base_t level;
    rt_thread_t thread;
    RT_ASSERT(completion != RT_NULL);
 801959e:	687b      	ldr	r3, [r7, #4]
 80195a0:	2b00      	cmp	r3, #0
 80195a2:	d104      	bne.n	80195ae <rt_completion_wait+0x1a>
 80195a4:	4836      	ldr	r0, [pc, #216]	; (8019680 <rt_completion_wait+0xec>)
 80195a6:	4937      	ldr	r1, [pc, #220]	; (8019684 <rt_completion_wait+0xf0>)
 80195a8:	2232      	movs	r2, #50	; 0x32
 80195aa:	f7fd fe2b 	bl	8017204 <rt_assert_handler>

    result = RT_EOK;
 80195ae:	2300      	movs	r3, #0
 80195b0:	617b      	str	r3, [r7, #20]
    thread = rt_thread_self();
 80195b2:	f7fe ff71 	bl	8018498 <rt_thread_self>
 80195b6:	60f8      	str	r0, [r7, #12]

    level = rt_hw_interrupt_disable();
 80195b8:	f7e6 fe08 	bl	80001cc <rt_hw_interrupt_disable>
 80195bc:	6138      	str	r0, [r7, #16]
    if (completion->flag != RT_COMPLETED)
 80195be:	687b      	ldr	r3, [r7, #4]
 80195c0:	681b      	ldr	r3, [r3, #0]
 80195c2:	2b01      	cmp	r3, #1
 80195c4:	d051      	beq.n	801966a <rt_completion_wait+0xd6>
    {
        /* only one thread can suspend on complete */
        RT_ASSERT(rt_list_isempty(&(completion->suspended_list)));
 80195c6:	687b      	ldr	r3, [r7, #4]
 80195c8:	3304      	adds	r3, #4
 80195ca:	4618      	mov	r0, r3
 80195cc:	f7ff ffae 	bl	801952c <rt_list_isempty>
 80195d0:	4603      	mov	r3, r0
 80195d2:	2b00      	cmp	r3, #0
 80195d4:	d104      	bne.n	80195e0 <rt_completion_wait+0x4c>
 80195d6:	482c      	ldr	r0, [pc, #176]	; (8019688 <rt_completion_wait+0xf4>)
 80195d8:	492a      	ldr	r1, [pc, #168]	; (8019684 <rt_completion_wait+0xf0>)
 80195da:	223b      	movs	r2, #59	; 0x3b
 80195dc:	f7fd fe12 	bl	8017204 <rt_assert_handler>

        if (timeout == 0)
 80195e0:	683b      	ldr	r3, [r7, #0]
 80195e2:	2b00      	cmp	r3, #0
 80195e4:	d103      	bne.n	80195ee <rt_completion_wait+0x5a>
        {
            result = -RT_ETIMEOUT;
 80195e6:	f06f 0301 	mvn.w	r3, #1
 80195ea:	617b      	str	r3, [r7, #20]
            goto __exit;
 80195ec:	e040      	b.n	8019670 <rt_completion_wait+0xdc>
        }
        else
        {
            /* reset thread error number */
            thread->error = RT_EOK;
 80195ee:	68fb      	ldr	r3, [r7, #12]
 80195f0:	2200      	movs	r2, #0
 80195f2:	631a      	str	r2, [r3, #48]	; 0x30

            /* suspend thread */
            rt_thread_suspend(thread);
 80195f4:	68f8      	ldr	r0, [r7, #12]
 80195f6:	f7ff f8d5 	bl	80187a4 <rt_thread_suspend>
            /* add to suspended list */
            rt_list_insert_before(&(completion->suspended_list),
 80195fa:	687b      	ldr	r3, [r7, #4]
 80195fc:	1d1a      	adds	r2, r3, #4
 80195fe:	68fb      	ldr	r3, [r7, #12]
 8019600:	3314      	adds	r3, #20
 8019602:	4610      	mov	r0, r2
 8019604:	4619      	mov	r1, r3
 8019606:	f7ff ff79 	bl	80194fc <rt_list_insert_before>
                                  &(thread->tlist));

            /* current context checking */
            RT_DEBUG_NOT_IN_INTERRUPT;
 801960a:	f7e6 fddf 	bl	80001cc <rt_hw_interrupt_disable>
 801960e:	60b8      	str	r0, [r7, #8]
 8019610:	f7fc ff9a 	bl	8016548 <rt_interrupt_get_nest>
 8019614:	4603      	mov	r3, r0
 8019616:	2b00      	cmp	r3, #0
 8019618:	d008      	beq.n	801962c <rt_completion_wait+0x98>
 801961a:	481c      	ldr	r0, [pc, #112]	; (801968c <rt_completion_wait+0xf8>)
 801961c:	4919      	ldr	r1, [pc, #100]	; (8019684 <rt_completion_wait+0xf0>)
 801961e:	f7fd fd77 	bl	8017110 <rt_kprintf>
 8019622:	481b      	ldr	r0, [pc, #108]	; (8019690 <rt_completion_wait+0xfc>)
 8019624:	4917      	ldr	r1, [pc, #92]	; (8019684 <rt_completion_wait+0xf0>)
 8019626:	224e      	movs	r2, #78	; 0x4e
 8019628:	f7fd fdec 	bl	8017204 <rt_assert_handler>
 801962c:	68b8      	ldr	r0, [r7, #8]
 801962e:	f7e6 fdd1 	bl	80001d4 <rt_hw_interrupt_enable>

            /* start timer */
            if (timeout > 0)
 8019632:	683b      	ldr	r3, [r7, #0]
 8019634:	2b00      	cmp	r3, #0
 8019636:	dd0d      	ble.n	8019654 <rt_completion_wait+0xc0>
            {
                /* reset the timeout of thread timer and start it */
                rt_timer_control(&(thread->thread_timer),
 8019638:	68fb      	ldr	r3, [r7, #12]
 801963a:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 801963e:	463b      	mov	r3, r7
 8019640:	4610      	mov	r0, r2
 8019642:	2100      	movs	r1, #0
 8019644:	461a      	mov	r2, r3
 8019646:	f7ff fba7 	bl	8018d98 <rt_timer_control>
                                 RT_TIMER_CTRL_SET_TIME,
                                 &timeout);
                rt_timer_start(&(thread->thread_timer));
 801964a:	68fb      	ldr	r3, [r7, #12]
 801964c:	334c      	adds	r3, #76	; 0x4c
 801964e:	4618      	mov	r0, r3
 8019650:	f7ff fa5c 	bl	8018b0c <rt_timer_start>
            }
            /* enable interrupt */
            rt_hw_interrupt_enable(level);
 8019654:	6938      	ldr	r0, [r7, #16]
 8019656:	f7e6 fdbd 	bl	80001d4 <rt_hw_interrupt_enable>

            /* do schedule */
            rt_schedule();
 801965a:	f7fe fce1 	bl	8018020 <rt_schedule>

            /* thread is waked up */
            result = thread->error;
 801965e:	68fb      	ldr	r3, [r7, #12]
 8019660:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8019662:	617b      	str	r3, [r7, #20]

            level = rt_hw_interrupt_disable();
 8019664:	f7e6 fdb2 	bl	80001cc <rt_hw_interrupt_disable>
 8019668:	6138      	str	r0, [r7, #16]
        }
    }
    /* clean completed flag */
    completion->flag = RT_UNCOMPLETED;
 801966a:	687b      	ldr	r3, [r7, #4]
 801966c:	2200      	movs	r2, #0
 801966e:	601a      	str	r2, [r3, #0]

__exit:
    rt_hw_interrupt_enable(level);
 8019670:	6938      	ldr	r0, [r7, #16]
 8019672:	f7e6 fdaf 	bl	80001d4 <rt_hw_interrupt_enable>

    return result;
 8019676:	697b      	ldr	r3, [r7, #20]
}
 8019678:	4618      	mov	r0, r3
 801967a:	3718      	adds	r7, #24
 801967c:	46bd      	mov	sp, r7
 801967e:	bd80      	pop	{r7, pc}
 8019680:	080295dc 	.word	0x080295dc
 8019684:	0802ab1c 	.word	0x0802ab1c
 8019688:	080295f4 	.word	0x080295f4
 801968c:	08029624 	.word	0x08029624
 8019690:	08029648 	.word	0x08029648

08019694 <rt_completion_done>:
RTM_EXPORT(rt_completion_wait);

void rt_completion_done(struct rt_completion *completion)
{
 8019694:	b580      	push	{r7, lr}
 8019696:	b084      	sub	sp, #16
 8019698:	af00      	add	r7, sp, #0
 801969a:	6078      	str	r0, [r7, #4]
    rt_base_t level;
    RT_ASSERT(completion != RT_NULL);
 801969c:	687b      	ldr	r3, [r7, #4]
 801969e:	2b00      	cmp	r3, #0
 80196a0:	d104      	bne.n	80196ac <rt_completion_done+0x18>
 80196a2:	4815      	ldr	r0, [pc, #84]	; (80196f8 <rt_completion_done+0x64>)
 80196a4:	4915      	ldr	r1, [pc, #84]	; (80196fc <rt_completion_done+0x68>)
 80196a6:	2272      	movs	r2, #114	; 0x72
 80196a8:	f7fd fdac 	bl	8017204 <rt_assert_handler>

    if (completion->flag == RT_COMPLETED)
 80196ac:	687b      	ldr	r3, [r7, #4]
 80196ae:	681b      	ldr	r3, [r3, #0]
 80196b0:	2b01      	cmp	r3, #1
 80196b2:	d100      	bne.n	80196b6 <rt_completion_done+0x22>
        return;
 80196b4:	e01d      	b.n	80196f2 <rt_completion_done+0x5e>

    level = rt_hw_interrupt_disable();
 80196b6:	f7e6 fd89 	bl	80001cc <rt_hw_interrupt_disable>
 80196ba:	60f8      	str	r0, [r7, #12]
    completion->flag = RT_COMPLETED;
 80196bc:	687b      	ldr	r3, [r7, #4]
 80196be:	2201      	movs	r2, #1
 80196c0:	601a      	str	r2, [r3, #0]

    if (!rt_list_isempty(&(completion->suspended_list)))
 80196c2:	687b      	ldr	r3, [r7, #4]
 80196c4:	3304      	adds	r3, #4
 80196c6:	4618      	mov	r0, r3
 80196c8:	f7ff ff30 	bl	801952c <rt_list_isempty>
 80196cc:	4603      	mov	r3, r0
 80196ce:	2b00      	cmp	r3, #0
 80196d0:	d10c      	bne.n	80196ec <rt_completion_done+0x58>
    {
        /* there is one thread in suspended list */
        struct rt_thread *thread;

        /* get thread entry */
        thread = rt_list_entry(completion->suspended_list.next,
 80196d2:	687b      	ldr	r3, [r7, #4]
 80196d4:	685b      	ldr	r3, [r3, #4]
 80196d6:	3b14      	subs	r3, #20
 80196d8:	60bb      	str	r3, [r7, #8]
                               struct rt_thread,
                               tlist);

        /* resume it */
        rt_thread_resume(thread);
 80196da:	68b8      	ldr	r0, [r7, #8]
 80196dc:	f7ff f892 	bl	8018804 <rt_thread_resume>
        rt_hw_interrupt_enable(level);
 80196e0:	68f8      	ldr	r0, [r7, #12]
 80196e2:	f7e6 fd77 	bl	80001d4 <rt_hw_interrupt_enable>

        /* perform a schedule */
        rt_schedule();
 80196e6:	f7fe fc9b 	bl	8018020 <rt_schedule>
 80196ea:	e002      	b.n	80196f2 <rt_completion_done+0x5e>
    }
    else
    {
        rt_hw_interrupt_enable(level);
 80196ec:	68f8      	ldr	r0, [r7, #12]
 80196ee:	f7e6 fd71 	bl	80001d4 <rt_hw_interrupt_enable>
    }
}
 80196f2:	3710      	adds	r7, #16
 80196f4:	46bd      	mov	sp, r7
 80196f6:	bd80      	pop	{r7, pc}
 80196f8:	080295dc 	.word	0x080295dc
 80196fc:	0802ab30 	.word	0x0802ab30

08019700 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 8019700:	b480      	push	{r7}
 8019702:	b083      	sub	sp, #12
 8019704:	af00      	add	r7, sp, #0
 8019706:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 8019708:	687b      	ldr	r3, [r7, #4]
 801970a:	687a      	ldr	r2, [r7, #4]
 801970c:	605a      	str	r2, [r3, #4]
 801970e:	687b      	ldr	r3, [r7, #4]
 8019710:	685a      	ldr	r2, [r3, #4]
 8019712:	687b      	ldr	r3, [r7, #4]
 8019714:	601a      	str	r2, [r3, #0]
}
 8019716:	370c      	adds	r7, #12
 8019718:	46bd      	mov	sp, r7
 801971a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801971e:	4770      	bx	lr

08019720 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 8019720:	b480      	push	{r7}
 8019722:	b083      	sub	sp, #12
 8019724:	af00      	add	r7, sp, #0
 8019726:	6078      	str	r0, [r7, #4]
 8019728:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 801972a:	687b      	ldr	r3, [r7, #4]
 801972c:	685b      	ldr	r3, [r3, #4]
 801972e:	683a      	ldr	r2, [r7, #0]
 8019730:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 8019732:	687b      	ldr	r3, [r7, #4]
 8019734:	685a      	ldr	r2, [r3, #4]
 8019736:	683b      	ldr	r3, [r7, #0]
 8019738:	605a      	str	r2, [r3, #4]

    l->prev = n;
 801973a:	687b      	ldr	r3, [r7, #4]
 801973c:	683a      	ldr	r2, [r7, #0]
 801973e:	605a      	str	r2, [r3, #4]
    n->next = l;
 8019740:	683b      	ldr	r3, [r7, #0]
 8019742:	687a      	ldr	r2, [r7, #4]
 8019744:	601a      	str	r2, [r3, #0]
}
 8019746:	370c      	adds	r7, #12
 8019748:	46bd      	mov	sp, r7
 801974a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801974e:	4770      	bx	lr

08019750 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 8019750:	b480      	push	{r7}
 8019752:	b083      	sub	sp, #12
 8019754:	af00      	add	r7, sp, #0
 8019756:	6078      	str	r0, [r7, #4]
    return l->next == l;
 8019758:	687b      	ldr	r3, [r7, #4]
 801975a:	681a      	ldr	r2, [r3, #0]
 801975c:	687b      	ldr	r3, [r7, #4]
 801975e:	429a      	cmp	r2, r3
 8019760:	bf0c      	ite	eq
 8019762:	2301      	moveq	r3, #1
 8019764:	2300      	movne	r3, #0
 8019766:	b2db      	uxtb	r3, r3
}
 8019768:	4618      	mov	r0, r3
 801976a:	370c      	adds	r7, #12
 801976c:	46bd      	mov	sp, r7
 801976e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019772:	4770      	bx	lr

08019774 <rt_data_queue_init>:
rt_err_t
rt_data_queue_init(struct rt_data_queue *queue,
                   rt_uint16_t size,
                   rt_uint16_t lwm,
                   void (*evt_notify)(struct rt_data_queue *queue, rt_uint32_t event))
{
 8019774:	b580      	push	{r7, lr}
 8019776:	b084      	sub	sp, #16
 8019778:	af00      	add	r7, sp, #0
 801977a:	60f8      	str	r0, [r7, #12]
 801977c:	607b      	str	r3, [r7, #4]
 801977e:	460b      	mov	r3, r1
 8019780:	817b      	strh	r3, [r7, #10]
 8019782:	4613      	mov	r3, r2
 8019784:	813b      	strh	r3, [r7, #8]
    RT_ASSERT(queue != RT_NULL);
 8019786:	68fb      	ldr	r3, [r7, #12]
 8019788:	2b00      	cmp	r3, #0
 801978a:	d104      	bne.n	8019796 <rt_data_queue_init+0x22>
 801978c:	481a      	ldr	r0, [pc, #104]	; (80197f8 <rt_data_queue_init+0x84>)
 801978e:	491b      	ldr	r1, [pc, #108]	; (80197fc <rt_data_queue_init+0x88>)
 8019790:	2229      	movs	r2, #41	; 0x29
 8019792:	f7fd fd37 	bl	8017204 <rt_assert_handler>

    queue->evt_notify = evt_notify;
 8019796:	68fb      	ldr	r3, [r7, #12]
 8019798:	687a      	ldr	r2, [r7, #4]
 801979a:	621a      	str	r2, [r3, #32]

    queue->size = size;
 801979c:	68fb      	ldr	r3, [r7, #12]
 801979e:	897a      	ldrh	r2, [r7, #10]
 80197a0:	801a      	strh	r2, [r3, #0]
    queue->lwm = lwm;
 80197a2:	68fb      	ldr	r3, [r7, #12]
 80197a4:	893a      	ldrh	r2, [r7, #8]
 80197a6:	805a      	strh	r2, [r3, #2]
    queue->waiting_lwm = RT_FALSE;
 80197a8:	68fb      	ldr	r3, [r7, #12]
 80197aa:	2200      	movs	r2, #0
 80197ac:	605a      	str	r2, [r3, #4]

    queue->get_index = 0;
 80197ae:	68fb      	ldr	r3, [r7, #12]
 80197b0:	2200      	movs	r2, #0
 80197b2:	811a      	strh	r2, [r3, #8]
    queue->put_index = 0;
 80197b4:	68fb      	ldr	r3, [r7, #12]
 80197b6:	2200      	movs	r2, #0
 80197b8:	815a      	strh	r2, [r3, #10]

    rt_list_init(&(queue->suspended_push_list));
 80197ba:	68fb      	ldr	r3, [r7, #12]
 80197bc:	3310      	adds	r3, #16
 80197be:	4618      	mov	r0, r3
 80197c0:	f7ff ff9e 	bl	8019700 <rt_list_init>
    rt_list_init(&(queue->suspended_pop_list));
 80197c4:	68fb      	ldr	r3, [r7, #12]
 80197c6:	3318      	adds	r3, #24
 80197c8:	4618      	mov	r0, r3
 80197ca:	f7ff ff99 	bl	8019700 <rt_list_init>

    queue->queue = (struct rt_data_item *)rt_malloc(sizeof(struct rt_data_item) * size);
 80197ce:	897b      	ldrh	r3, [r7, #10]
 80197d0:	00db      	lsls	r3, r3, #3
 80197d2:	4618      	mov	r0, r3
 80197d4:	f7fd fe4a 	bl	801746c <rt_malloc>
 80197d8:	4602      	mov	r2, r0
 80197da:	68fb      	ldr	r3, [r7, #12]
 80197dc:	60da      	str	r2, [r3, #12]
    if (queue->queue == RT_NULL)
 80197de:	68fb      	ldr	r3, [r7, #12]
 80197e0:	68db      	ldr	r3, [r3, #12]
 80197e2:	2b00      	cmp	r3, #0
 80197e4:	d102      	bne.n	80197ec <rt_data_queue_init+0x78>
    {
        return -RT_ENOMEM;
 80197e6:	f06f 0304 	mvn.w	r3, #4
 80197ea:	e000      	b.n	80197ee <rt_data_queue_init+0x7a>
    }

    return RT_EOK;
 80197ec:	2300      	movs	r3, #0
}
 80197ee:	4618      	mov	r0, r3
 80197f0:	3710      	adds	r7, #16
 80197f2:	46bd      	mov	sp, r7
 80197f4:	bd80      	pop	{r7, pc}
 80197f6:	bf00      	nop
 80197f8:	0802964c 	.word	0x0802964c
 80197fc:	0802ab44 	.word	0x0802ab44

08019800 <rt_data_queue_push>:

rt_err_t rt_data_queue_push(struct rt_data_queue *queue,
                            const void *data_ptr,
                            rt_size_t data_size,
                            rt_int32_t timeout)
{
 8019800:	b580      	push	{r7, lr}
 8019802:	b08a      	sub	sp, #40	; 0x28
 8019804:	af00      	add	r7, sp, #0
 8019806:	60f8      	str	r0, [r7, #12]
 8019808:	60b9      	str	r1, [r7, #8]
 801980a:	607a      	str	r2, [r7, #4]
 801980c:	603b      	str	r3, [r7, #0]
    rt_uint16_t mask;
    rt_ubase_t  level;
    rt_thread_t thread;
    rt_err_t    result;
    
    RT_ASSERT(queue != RT_NULL);
 801980e:	68fb      	ldr	r3, [r7, #12]
 8019810:	2b00      	cmp	r3, #0
 8019812:	d104      	bne.n	801981e <rt_data_queue_push+0x1e>
 8019814:	4859      	ldr	r0, [pc, #356]	; (801997c <rt_data_queue_push+0x17c>)
 8019816:	495a      	ldr	r1, [pc, #360]	; (8019980 <rt_data_queue_push+0x180>)
 8019818:	224b      	movs	r2, #75	; 0x4b
 801981a:	f7fd fcf3 	bl	8017204 <rt_assert_handler>

    result = RT_EOK;
 801981e:	2300      	movs	r3, #0
 8019820:	623b      	str	r3, [r7, #32]
    thread = rt_thread_self();
 8019822:	f7fe fe39 	bl	8018498 <rt_thread_self>
 8019826:	61f8      	str	r0, [r7, #28]
    mask = queue->size - 1;
 8019828:	68fb      	ldr	r3, [r7, #12]
 801982a:	881b      	ldrh	r3, [r3, #0]
 801982c:	3b01      	subs	r3, #1
 801982e:	837b      	strh	r3, [r7, #26]

    level = rt_hw_interrupt_disable();
 8019830:	f7e6 fccc 	bl	80001cc <rt_hw_interrupt_disable>
 8019834:	4603      	mov	r3, r0
 8019836:	627b      	str	r3, [r7, #36]	; 0x24
    while (queue->put_index - queue->get_index == queue->size)
 8019838:	e04e      	b.n	80198d8 <rt_data_queue_push+0xd8>
    {
        queue->waiting_lwm = RT_TRUE;
 801983a:	68fb      	ldr	r3, [r7, #12]
 801983c:	2201      	movs	r2, #1
 801983e:	605a      	str	r2, [r3, #4]

        /* queue is full */
        if (timeout == 0)
 8019840:	683b      	ldr	r3, [r7, #0]
 8019842:	2b00      	cmp	r3, #0
 8019844:	d103      	bne.n	801984e <rt_data_queue_push+0x4e>
        {
            result = -RT_ETIMEOUT;
 8019846:	f06f 0301 	mvn.w	r3, #1
 801984a:	623b      	str	r3, [r7, #32]

            goto __exit;
 801984c:	e081      	b.n	8019952 <rt_data_queue_push+0x152>
        }

        /* current context checking */
        RT_DEBUG_NOT_IN_INTERRUPT;
 801984e:	f7e6 fcbd 	bl	80001cc <rt_hw_interrupt_disable>
 8019852:	6178      	str	r0, [r7, #20]
 8019854:	f7fc fe78 	bl	8016548 <rt_interrupt_get_nest>
 8019858:	4603      	mov	r3, r0
 801985a:	2b00      	cmp	r3, #0
 801985c:	d008      	beq.n	8019870 <rt_data_queue_push+0x70>
 801985e:	4849      	ldr	r0, [pc, #292]	; (8019984 <rt_data_queue_push+0x184>)
 8019860:	4947      	ldr	r1, [pc, #284]	; (8019980 <rt_data_queue_push+0x180>)
 8019862:	f7fd fc55 	bl	8017110 <rt_kprintf>
 8019866:	4848      	ldr	r0, [pc, #288]	; (8019988 <rt_data_queue_push+0x188>)
 8019868:	4945      	ldr	r1, [pc, #276]	; (8019980 <rt_data_queue_push+0x180>)
 801986a:	225f      	movs	r2, #95	; 0x5f
 801986c:	f7fd fcca 	bl	8017204 <rt_assert_handler>
 8019870:	6978      	ldr	r0, [r7, #20]
 8019872:	f7e6 fcaf 	bl	80001d4 <rt_hw_interrupt_enable>

        /* reset thread error number */
        thread->error = RT_EOK;
 8019876:	69fb      	ldr	r3, [r7, #28]
 8019878:	2200      	movs	r2, #0
 801987a:	631a      	str	r2, [r3, #48]	; 0x30
        
        /* suspend thread on the push list */
        rt_thread_suspend(thread);
 801987c:	69f8      	ldr	r0, [r7, #28]
 801987e:	f7fe ff91 	bl	80187a4 <rt_thread_suspend>
        rt_list_insert_before(&(queue->suspended_push_list), &(thread->tlist));
 8019882:	68fb      	ldr	r3, [r7, #12]
 8019884:	f103 0210 	add.w	r2, r3, #16
 8019888:	69fb      	ldr	r3, [r7, #28]
 801988a:	3314      	adds	r3, #20
 801988c:	4610      	mov	r0, r2
 801988e:	4619      	mov	r1, r3
 8019890:	f7ff ff46 	bl	8019720 <rt_list_insert_before>
        /* start timer */
        if (timeout > 0)
 8019894:	683b      	ldr	r3, [r7, #0]
 8019896:	2b00      	cmp	r3, #0
 8019898:	dd0d      	ble.n	80198b6 <rt_data_queue_push+0xb6>
        {
            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
 801989a:	69fb      	ldr	r3, [r7, #28]
 801989c:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 80198a0:	463b      	mov	r3, r7
 80198a2:	4610      	mov	r0, r2
 80198a4:	2100      	movs	r1, #0
 80198a6:	461a      	mov	r2, r3
 80198a8:	f7ff fa76 	bl	8018d98 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
 80198ac:	69fb      	ldr	r3, [r7, #28]
 80198ae:	334c      	adds	r3, #76	; 0x4c
 80198b0:	4618      	mov	r0, r3
 80198b2:	f7ff f92b 	bl	8018b0c <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 80198b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80198b8:	4618      	mov	r0, r3
 80198ba:	f7e6 fc8b 	bl	80001d4 <rt_hw_interrupt_enable>

        /* do schedule */
        rt_schedule();
 80198be:	f7fe fbaf 	bl	8018020 <rt_schedule>

        /* thread is waked up */
        result = thread->error;
 80198c2:	69fb      	ldr	r3, [r7, #28]
 80198c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80198c6:	623b      	str	r3, [r7, #32]
        level = rt_hw_interrupt_disable();
 80198c8:	f7e6 fc80 	bl	80001cc <rt_hw_interrupt_disable>
 80198cc:	4603      	mov	r3, r0
 80198ce:	627b      	str	r3, [r7, #36]	; 0x24
        if (result != RT_EOK) goto __exit;
 80198d0:	6a3b      	ldr	r3, [r7, #32]
 80198d2:	2b00      	cmp	r3, #0
 80198d4:	d000      	beq.n	80198d8 <rt_data_queue_push+0xd8>
 80198d6:	e03c      	b.n	8019952 <rt_data_queue_push+0x152>
    result = RT_EOK;
    thread = rt_thread_self();
    mask = queue->size - 1;

    level = rt_hw_interrupt_disable();
    while (queue->put_index - queue->get_index == queue->size)
 80198d8:	68fb      	ldr	r3, [r7, #12]
 80198da:	895b      	ldrh	r3, [r3, #10]
 80198dc:	461a      	mov	r2, r3
 80198de:	68fb      	ldr	r3, [r7, #12]
 80198e0:	891b      	ldrh	r3, [r3, #8]
 80198e2:	1ad3      	subs	r3, r2, r3
 80198e4:	68fa      	ldr	r2, [r7, #12]
 80198e6:	8812      	ldrh	r2, [r2, #0]
 80198e8:	4293      	cmp	r3, r2
 80198ea:	d0a6      	beq.n	801983a <rt_data_queue_push+0x3a>
        result = thread->error;
        level = rt_hw_interrupt_disable();
        if (result != RT_EOK) goto __exit;
    }

    queue->queue[queue->put_index & mask].data_ptr  = data_ptr;
 80198ec:	68fb      	ldr	r3, [r7, #12]
 80198ee:	68da      	ldr	r2, [r3, #12]
 80198f0:	68fb      	ldr	r3, [r7, #12]
 80198f2:	8959      	ldrh	r1, [r3, #10]
 80198f4:	8b7b      	ldrh	r3, [r7, #26]
 80198f6:	400b      	ands	r3, r1
 80198f8:	b29b      	uxth	r3, r3
 80198fa:	00db      	lsls	r3, r3, #3
 80198fc:	4413      	add	r3, r2
 80198fe:	68ba      	ldr	r2, [r7, #8]
 8019900:	601a      	str	r2, [r3, #0]
    queue->queue[queue->put_index & mask].data_size = data_size;
 8019902:	68fb      	ldr	r3, [r7, #12]
 8019904:	68da      	ldr	r2, [r3, #12]
 8019906:	68fb      	ldr	r3, [r7, #12]
 8019908:	8959      	ldrh	r1, [r3, #10]
 801990a:	8b7b      	ldrh	r3, [r7, #26]
 801990c:	400b      	ands	r3, r1
 801990e:	b29b      	uxth	r3, r3
 8019910:	00db      	lsls	r3, r3, #3
 8019912:	4413      	add	r3, r2
 8019914:	687a      	ldr	r2, [r7, #4]
 8019916:	605a      	str	r2, [r3, #4]
    queue->put_index += 1;
 8019918:	68fb      	ldr	r3, [r7, #12]
 801991a:	895b      	ldrh	r3, [r3, #10]
 801991c:	3301      	adds	r3, #1
 801991e:	b29a      	uxth	r2, r3
 8019920:	68fb      	ldr	r3, [r7, #12]
 8019922:	815a      	strh	r2, [r3, #10]

    if (!rt_list_isempty(&(queue->suspended_pop_list)))
 8019924:	68fb      	ldr	r3, [r7, #12]
 8019926:	3318      	adds	r3, #24
 8019928:	4618      	mov	r0, r3
 801992a:	f7ff ff11 	bl	8019750 <rt_list_isempty>
 801992e:	4603      	mov	r3, r0
 8019930:	2b00      	cmp	r3, #0
 8019932:	d10e      	bne.n	8019952 <rt_data_queue_push+0x152>
    {
        /* there is at least one thread in suspended list */

        /* get thread entry */
        thread = rt_list_entry(queue->suspended_pop_list.next,
 8019934:	68fb      	ldr	r3, [r7, #12]
 8019936:	699b      	ldr	r3, [r3, #24]
 8019938:	3b14      	subs	r3, #20
 801993a:	61fb      	str	r3, [r7, #28]
                               struct rt_thread,
                               tlist);

        /* resume it */
        rt_thread_resume(thread);
 801993c:	69f8      	ldr	r0, [r7, #28]
 801993e:	f7fe ff61 	bl	8018804 <rt_thread_resume>
        rt_hw_interrupt_enable(level);
 8019942:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019944:	4618      	mov	r0, r3
 8019946:	f7e6 fc45 	bl	80001d4 <rt_hw_interrupt_enable>

        /* perform a schedule */
        rt_schedule();
 801994a:	f7fe fb69 	bl	8018020 <rt_schedule>

        return result;
 801994e:	6a3b      	ldr	r3, [r7, #32]
 8019950:	e010      	b.n	8019974 <rt_data_queue_push+0x174>
    }

__exit:
    rt_hw_interrupt_enable(level);
 8019952:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019954:	4618      	mov	r0, r3
 8019956:	f7e6 fc3d 	bl	80001d4 <rt_hw_interrupt_enable>
    if ((result == RT_EOK) && queue->evt_notify != RT_NULL)
 801995a:	6a3b      	ldr	r3, [r7, #32]
 801995c:	2b00      	cmp	r3, #0
 801995e:	d108      	bne.n	8019972 <rt_data_queue_push+0x172>
 8019960:	68fb      	ldr	r3, [r7, #12]
 8019962:	6a1b      	ldr	r3, [r3, #32]
 8019964:	2b00      	cmp	r3, #0
 8019966:	d004      	beq.n	8019972 <rt_data_queue_push+0x172>
    {
        queue->evt_notify(queue, RT_DATAQUEUE_EVENT_PUSH);
 8019968:	68fb      	ldr	r3, [r7, #12]
 801996a:	6a1b      	ldr	r3, [r3, #32]
 801996c:	68f8      	ldr	r0, [r7, #12]
 801996e:	2102      	movs	r1, #2
 8019970:	4798      	blx	r3
    }

    return result;
 8019972:	6a3b      	ldr	r3, [r7, #32]
}
 8019974:	4618      	mov	r0, r3
 8019976:	3728      	adds	r7, #40	; 0x28
 8019978:	46bd      	mov	sp, r7
 801997a:	bd80      	pop	{r7, pc}
 801997c:	0802964c 	.word	0x0802964c
 8019980:	0802ab58 	.word	0x0802ab58
 8019984:	08029660 	.word	0x08029660
 8019988:	08029684 	.word	0x08029684

0801998c <rt_data_queue_pop>:

rt_err_t rt_data_queue_pop(struct rt_data_queue *queue,
                           const void** data_ptr,
                           rt_size_t *size, 
                           rt_int32_t timeout)
{
 801998c:	b580      	push	{r7, lr}
 801998e:	b08a      	sub	sp, #40	; 0x28
 8019990:	af00      	add	r7, sp, #0
 8019992:	60f8      	str	r0, [r7, #12]
 8019994:	60b9      	str	r1, [r7, #8]
 8019996:	607a      	str	r2, [r7, #4]
 8019998:	603b      	str	r3, [r7, #0]
    rt_ubase_t  level;
    rt_thread_t thread;
    rt_err_t    result;
    rt_uint16_t mask;

    RT_ASSERT(queue != RT_NULL);
 801999a:	68fb      	ldr	r3, [r7, #12]
 801999c:	2b00      	cmp	r3, #0
 801999e:	d104      	bne.n	80199aa <rt_data_queue_pop+0x1e>
 80199a0:	486c      	ldr	r0, [pc, #432]	; (8019b54 <rt_data_queue_pop+0x1c8>)
 80199a2:	496d      	ldr	r1, [pc, #436]	; (8019b58 <rt_data_queue_pop+0x1cc>)
 80199a4:	22a9      	movs	r2, #169	; 0xa9
 80199a6:	f7fd fc2d 	bl	8017204 <rt_assert_handler>
    RT_ASSERT(data_ptr != RT_NULL);
 80199aa:	68bb      	ldr	r3, [r7, #8]
 80199ac:	2b00      	cmp	r3, #0
 80199ae:	d104      	bne.n	80199ba <rt_data_queue_pop+0x2e>
 80199b0:	486a      	ldr	r0, [pc, #424]	; (8019b5c <rt_data_queue_pop+0x1d0>)
 80199b2:	4969      	ldr	r1, [pc, #420]	; (8019b58 <rt_data_queue_pop+0x1cc>)
 80199b4:	22aa      	movs	r2, #170	; 0xaa
 80199b6:	f7fd fc25 	bl	8017204 <rt_assert_handler>
    RT_ASSERT(size != RT_NULL);
 80199ba:	687b      	ldr	r3, [r7, #4]
 80199bc:	2b00      	cmp	r3, #0
 80199be:	d104      	bne.n	80199ca <rt_data_queue_pop+0x3e>
 80199c0:	4867      	ldr	r0, [pc, #412]	; (8019b60 <rt_data_queue_pop+0x1d4>)
 80199c2:	4965      	ldr	r1, [pc, #404]	; (8019b58 <rt_data_queue_pop+0x1cc>)
 80199c4:	22ab      	movs	r2, #171	; 0xab
 80199c6:	f7fd fc1d 	bl	8017204 <rt_assert_handler>

    result = RT_EOK;
 80199ca:	2300      	movs	r3, #0
 80199cc:	623b      	str	r3, [r7, #32]
    thread = rt_thread_self();
 80199ce:	f7fe fd63 	bl	8018498 <rt_thread_self>
 80199d2:	61f8      	str	r0, [r7, #28]
    mask   = queue->size - 1;
 80199d4:	68fb      	ldr	r3, [r7, #12]
 80199d6:	881b      	ldrh	r3, [r3, #0]
 80199d8:	3b01      	subs	r3, #1
 80199da:	837b      	strh	r3, [r7, #26]

    level = rt_hw_interrupt_disable();
 80199dc:	f7e6 fbf6 	bl	80001cc <rt_hw_interrupt_disable>
 80199e0:	4603      	mov	r3, r0
 80199e2:	627b      	str	r3, [r7, #36]	; 0x24
    while (queue->get_index == queue->put_index)
 80199e4:	e04b      	b.n	8019a7e <rt_data_queue_pop+0xf2>
    {
        /* queue is empty */
        if (timeout == 0)
 80199e6:	683b      	ldr	r3, [r7, #0]
 80199e8:	2b00      	cmp	r3, #0
 80199ea:	d103      	bne.n	80199f4 <rt_data_queue_pop+0x68>
        {
            result = -RT_ETIMEOUT;
 80199ec:	f06f 0301 	mvn.w	r3, #1
 80199f0:	623b      	str	r3, [r7, #32]
            goto __exit;
 80199f2:	e099      	b.n	8019b28 <rt_data_queue_pop+0x19c>
        }

        /* current context checking */
        RT_DEBUG_NOT_IN_INTERRUPT;
 80199f4:	f7e6 fbea 	bl	80001cc <rt_hw_interrupt_disable>
 80199f8:	6178      	str	r0, [r7, #20]
 80199fa:	f7fc fda5 	bl	8016548 <rt_interrupt_get_nest>
 80199fe:	4603      	mov	r3, r0
 8019a00:	2b00      	cmp	r3, #0
 8019a02:	d008      	beq.n	8019a16 <rt_data_queue_pop+0x8a>
 8019a04:	4857      	ldr	r0, [pc, #348]	; (8019b64 <rt_data_queue_pop+0x1d8>)
 8019a06:	4954      	ldr	r1, [pc, #336]	; (8019b58 <rt_data_queue_pop+0x1cc>)
 8019a08:	f7fd fb82 	bl	8017110 <rt_kprintf>
 8019a0c:	4856      	ldr	r0, [pc, #344]	; (8019b68 <rt_data_queue_pop+0x1dc>)
 8019a0e:	4952      	ldr	r1, [pc, #328]	; (8019b58 <rt_data_queue_pop+0x1cc>)
 8019a10:	22bc      	movs	r2, #188	; 0xbc
 8019a12:	f7fd fbf7 	bl	8017204 <rt_assert_handler>
 8019a16:	6978      	ldr	r0, [r7, #20]
 8019a18:	f7e6 fbdc 	bl	80001d4 <rt_hw_interrupt_enable>

        /* reset thread error number */
        thread->error = RT_EOK;
 8019a1c:	69fb      	ldr	r3, [r7, #28]
 8019a1e:	2200      	movs	r2, #0
 8019a20:	631a      	str	r2, [r3, #48]	; 0x30
        
        /* suspend thread on the pop list */
        rt_thread_suspend(thread);
 8019a22:	69f8      	ldr	r0, [r7, #28]
 8019a24:	f7fe febe 	bl	80187a4 <rt_thread_suspend>
        rt_list_insert_before(&(queue->suspended_pop_list), &(thread->tlist));
 8019a28:	68fb      	ldr	r3, [r7, #12]
 8019a2a:	f103 0218 	add.w	r2, r3, #24
 8019a2e:	69fb      	ldr	r3, [r7, #28]
 8019a30:	3314      	adds	r3, #20
 8019a32:	4610      	mov	r0, r2
 8019a34:	4619      	mov	r1, r3
 8019a36:	f7ff fe73 	bl	8019720 <rt_list_insert_before>
        /* start timer */
        if (timeout > 0)
 8019a3a:	683b      	ldr	r3, [r7, #0]
 8019a3c:	2b00      	cmp	r3, #0
 8019a3e:	dd0d      	ble.n	8019a5c <rt_data_queue_pop+0xd0>
        {
            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
 8019a40:	69fb      	ldr	r3, [r7, #28]
 8019a42:	f103 024c 	add.w	r2, r3, #76	; 0x4c
 8019a46:	463b      	mov	r3, r7
 8019a48:	4610      	mov	r0, r2
 8019a4a:	2100      	movs	r1, #0
 8019a4c:	461a      	mov	r2, r3
 8019a4e:	f7ff f9a3 	bl	8018d98 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
 8019a52:	69fb      	ldr	r3, [r7, #28]
 8019a54:	334c      	adds	r3, #76	; 0x4c
 8019a56:	4618      	mov	r0, r3
 8019a58:	f7ff f858 	bl	8018b0c <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 8019a5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019a5e:	4618      	mov	r0, r3
 8019a60:	f7e6 fbb8 	bl	80001d4 <rt_hw_interrupt_enable>

        /* do schedule */
        rt_schedule();
 8019a64:	f7fe fadc 	bl	8018020 <rt_schedule>

        /* thread is waked up */
        result = thread->error;
 8019a68:	69fb      	ldr	r3, [r7, #28]
 8019a6a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8019a6c:	623b      	str	r3, [r7, #32]
        level  = rt_hw_interrupt_disable();
 8019a6e:	f7e6 fbad 	bl	80001cc <rt_hw_interrupt_disable>
 8019a72:	4603      	mov	r3, r0
 8019a74:	627b      	str	r3, [r7, #36]	; 0x24
        if (result != RT_EOK)
 8019a76:	6a3b      	ldr	r3, [r7, #32]
 8019a78:	2b00      	cmp	r3, #0
 8019a7a:	d000      	beq.n	8019a7e <rt_data_queue_pop+0xf2>
            goto __exit;
 8019a7c:	e054      	b.n	8019b28 <rt_data_queue_pop+0x19c>
    result = RT_EOK;
    thread = rt_thread_self();
    mask   = queue->size - 1;

    level = rt_hw_interrupt_disable();
    while (queue->get_index == queue->put_index)
 8019a7e:	68fb      	ldr	r3, [r7, #12]
 8019a80:	891a      	ldrh	r2, [r3, #8]
 8019a82:	68fb      	ldr	r3, [r7, #12]
 8019a84:	895b      	ldrh	r3, [r3, #10]
 8019a86:	429a      	cmp	r2, r3
 8019a88:	d0ad      	beq.n	80199e6 <rt_data_queue_pop+0x5a>
        level  = rt_hw_interrupt_disable();
        if (result != RT_EOK)
            goto __exit;
    }

    *data_ptr = queue->queue[queue->get_index & mask].data_ptr;
 8019a8a:	68fb      	ldr	r3, [r7, #12]
 8019a8c:	68da      	ldr	r2, [r3, #12]
 8019a8e:	68fb      	ldr	r3, [r7, #12]
 8019a90:	8919      	ldrh	r1, [r3, #8]
 8019a92:	8b7b      	ldrh	r3, [r7, #26]
 8019a94:	400b      	ands	r3, r1
 8019a96:	b29b      	uxth	r3, r3
 8019a98:	00db      	lsls	r3, r3, #3
 8019a9a:	4413      	add	r3, r2
 8019a9c:	681a      	ldr	r2, [r3, #0]
 8019a9e:	68bb      	ldr	r3, [r7, #8]
 8019aa0:	601a      	str	r2, [r3, #0]
    *size     = queue->queue[queue->get_index & mask].data_size;
 8019aa2:	68fb      	ldr	r3, [r7, #12]
 8019aa4:	68da      	ldr	r2, [r3, #12]
 8019aa6:	68fb      	ldr	r3, [r7, #12]
 8019aa8:	8919      	ldrh	r1, [r3, #8]
 8019aaa:	8b7b      	ldrh	r3, [r7, #26]
 8019aac:	400b      	ands	r3, r1
 8019aae:	b29b      	uxth	r3, r3
 8019ab0:	00db      	lsls	r3, r3, #3
 8019ab2:	4413      	add	r3, r2
 8019ab4:	685a      	ldr	r2, [r3, #4]
 8019ab6:	687b      	ldr	r3, [r7, #4]
 8019ab8:	601a      	str	r2, [r3, #0]

    queue->get_index += 1;
 8019aba:	68fb      	ldr	r3, [r7, #12]
 8019abc:	891b      	ldrh	r3, [r3, #8]
 8019abe:	3301      	adds	r3, #1
 8019ac0:	b29a      	uxth	r2, r3
 8019ac2:	68fb      	ldr	r3, [r7, #12]
 8019ac4:	811a      	strh	r2, [r3, #8]

    if ((queue->waiting_lwm == RT_TRUE) && 
 8019ac6:	68fb      	ldr	r3, [r7, #12]
 8019ac8:	685b      	ldr	r3, [r3, #4]
 8019aca:	2b01      	cmp	r3, #1
 8019acc:	d12c      	bne.n	8019b28 <rt_data_queue_pop+0x19c>
        (queue->put_index - queue->get_index) <= queue->lwm)
 8019ace:	68fb      	ldr	r3, [r7, #12]
 8019ad0:	895b      	ldrh	r3, [r3, #10]
 8019ad2:	461a      	mov	r2, r3
 8019ad4:	68fb      	ldr	r3, [r7, #12]
 8019ad6:	891b      	ldrh	r3, [r3, #8]
 8019ad8:	1ad3      	subs	r3, r2, r3
 8019ada:	68fa      	ldr	r2, [r7, #12]
 8019adc:	8852      	ldrh	r2, [r2, #2]
    *data_ptr = queue->queue[queue->get_index & mask].data_ptr;
    *size     = queue->queue[queue->get_index & mask].data_size;

    queue->get_index += 1;

    if ((queue->waiting_lwm == RT_TRUE) && 
 8019ade:	4293      	cmp	r3, r2
 8019ae0:	dc22      	bgt.n	8019b28 <rt_data_queue_pop+0x19c>
        (queue->put_index - queue->get_index) <= queue->lwm)
    {
        queue->waiting_lwm = RT_FALSE;
 8019ae2:	68fb      	ldr	r3, [r7, #12]
 8019ae4:	2200      	movs	r2, #0
 8019ae6:	605a      	str	r2, [r3, #4]

        /*
         * there is at least one thread in suspended list
         * and less than low water mark
         */
        if (!rt_list_isempty(&(queue->suspended_push_list)))
 8019ae8:	68fb      	ldr	r3, [r7, #12]
 8019aea:	3310      	adds	r3, #16
 8019aec:	4618      	mov	r0, r3
 8019aee:	f7ff fe2f 	bl	8019750 <rt_list_isempty>
 8019af2:	4603      	mov	r3, r0
 8019af4:	2b00      	cmp	r3, #0
 8019af6:	d10c      	bne.n	8019b12 <rt_data_queue_pop+0x186>
        {
            /* get thread entry */
            thread = rt_list_entry(queue->suspended_push_list.next,
 8019af8:	68fb      	ldr	r3, [r7, #12]
 8019afa:	691b      	ldr	r3, [r3, #16]
 8019afc:	3b14      	subs	r3, #20
 8019afe:	61fb      	str	r3, [r7, #28]
                                   struct rt_thread,
                                   tlist);

            /* resume it */
            rt_thread_resume(thread);
 8019b00:	69f8      	ldr	r0, [r7, #28]
 8019b02:	f7fe fe7f 	bl	8018804 <rt_thread_resume>
            rt_hw_interrupt_enable(level);
 8019b06:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019b08:	4618      	mov	r0, r3
 8019b0a:	f7e6 fb63 	bl	80001d4 <rt_hw_interrupt_enable>

            /* perform a schedule */
            rt_schedule();
 8019b0e:	f7fe fa87 	bl	8018020 <rt_schedule>
        }

        if (queue->evt_notify != RT_NULL)
 8019b12:	68fb      	ldr	r3, [r7, #12]
 8019b14:	6a1b      	ldr	r3, [r3, #32]
 8019b16:	2b00      	cmp	r3, #0
 8019b18:	d004      	beq.n	8019b24 <rt_data_queue_pop+0x198>
            queue->evt_notify(queue, RT_DATAQUEUE_EVENT_LWM);
 8019b1a:	68fb      	ldr	r3, [r7, #12]
 8019b1c:	6a1b      	ldr	r3, [r3, #32]
 8019b1e:	68f8      	ldr	r0, [r7, #12]
 8019b20:	2103      	movs	r1, #3
 8019b22:	4798      	blx	r3

        return result;
 8019b24:	6a3b      	ldr	r3, [r7, #32]
 8019b26:	e010      	b.n	8019b4a <rt_data_queue_pop+0x1be>
    }

__exit:
    rt_hw_interrupt_enable(level);
 8019b28:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019b2a:	4618      	mov	r0, r3
 8019b2c:	f7e6 fb52 	bl	80001d4 <rt_hw_interrupt_enable>
    if ((result == RT_EOK) && (queue->evt_notify != RT_NULL))
 8019b30:	6a3b      	ldr	r3, [r7, #32]
 8019b32:	2b00      	cmp	r3, #0
 8019b34:	d108      	bne.n	8019b48 <rt_data_queue_pop+0x1bc>
 8019b36:	68fb      	ldr	r3, [r7, #12]
 8019b38:	6a1b      	ldr	r3, [r3, #32]
 8019b3a:	2b00      	cmp	r3, #0
 8019b3c:	d004      	beq.n	8019b48 <rt_data_queue_pop+0x1bc>
    {
        queue->evt_notify(queue, RT_DATAQUEUE_EVENT_POP);
 8019b3e:	68fb      	ldr	r3, [r7, #12]
 8019b40:	6a1b      	ldr	r3, [r3, #32]
 8019b42:	68f8      	ldr	r0, [r7, #12]
 8019b44:	2101      	movs	r1, #1
 8019b46:	4798      	blx	r3
    }

    return result;
 8019b48:	6a3b      	ldr	r3, [r7, #32]
}
 8019b4a:	4618      	mov	r0, r3
 8019b4c:	3728      	adds	r7, #40	; 0x28
 8019b4e:	46bd      	mov	sp, r7
 8019b50:	bd80      	pop	{r7, pc}
 8019b52:	bf00      	nop
 8019b54:	0802964c 	.word	0x0802964c
 8019b58:	0802ab6c 	.word	0x0802ab6c
 8019b5c:	08029688 	.word	0x08029688
 8019b60:	0802969c 	.word	0x0802969c
 8019b64:	08029660 	.word	0x08029660
 8019b68:	08029684 	.word	0x08029684

08019b6c <rt_data_queue_peak>:
RTM_EXPORT(rt_data_queue_pop);

rt_err_t rt_data_queue_peak(struct rt_data_queue *queue,
                            const void** data_ptr,
                            rt_size_t *size)
{
 8019b6c:	b580      	push	{r7, lr}
 8019b6e:	b086      	sub	sp, #24
 8019b70:	af00      	add	r7, sp, #0
 8019b72:	60f8      	str	r0, [r7, #12]
 8019b74:	60b9      	str	r1, [r7, #8]
 8019b76:	607a      	str	r2, [r7, #4]
    rt_ubase_t  level;
    rt_uint16_t mask;

    RT_ASSERT(queue != RT_NULL);
 8019b78:	68fb      	ldr	r3, [r7, #12]
 8019b7a:	2b00      	cmp	r3, #0
 8019b7c:	d105      	bne.n	8019b8a <rt_data_queue_peak+0x1e>
 8019b7e:	481e      	ldr	r0, [pc, #120]	; (8019bf8 <rt_data_queue_peak+0x8c>)
 8019b80:	491e      	ldr	r1, [pc, #120]	; (8019bfc <rt_data_queue_peak+0x90>)
 8019b82:	f44f 7288 	mov.w	r2, #272	; 0x110
 8019b86:	f7fd fb3d 	bl	8017204 <rt_assert_handler>

    mask = queue->size - 1;
 8019b8a:	68fb      	ldr	r3, [r7, #12]
 8019b8c:	881b      	ldrh	r3, [r3, #0]
 8019b8e:	3b01      	subs	r3, #1
 8019b90:	82fb      	strh	r3, [r7, #22]

    level = rt_hw_interrupt_disable();
 8019b92:	f7e6 fb1b 	bl	80001cc <rt_hw_interrupt_disable>
 8019b96:	4603      	mov	r3, r0
 8019b98:	613b      	str	r3, [r7, #16]

    if (queue->get_index == queue->put_index) 
 8019b9a:	68fb      	ldr	r3, [r7, #12]
 8019b9c:	891a      	ldrh	r2, [r3, #8]
 8019b9e:	68fb      	ldr	r3, [r7, #12]
 8019ba0:	895b      	ldrh	r3, [r3, #10]
 8019ba2:	429a      	cmp	r2, r3
 8019ba4:	d106      	bne.n	8019bb4 <rt_data_queue_peak+0x48>
    {
        rt_hw_interrupt_enable(level);
 8019ba6:	693b      	ldr	r3, [r7, #16]
 8019ba8:	4618      	mov	r0, r3
 8019baa:	f7e6 fb13 	bl	80001d4 <rt_hw_interrupt_enable>
        
        return -RT_EEMPTY;
 8019bae:	f06f 0303 	mvn.w	r3, #3
 8019bb2:	e01c      	b.n	8019bee <rt_data_queue_peak+0x82>
    }

    *data_ptr = queue->queue[queue->get_index & mask].data_ptr;
 8019bb4:	68fb      	ldr	r3, [r7, #12]
 8019bb6:	68da      	ldr	r2, [r3, #12]
 8019bb8:	68fb      	ldr	r3, [r7, #12]
 8019bba:	8919      	ldrh	r1, [r3, #8]
 8019bbc:	8afb      	ldrh	r3, [r7, #22]
 8019bbe:	400b      	ands	r3, r1
 8019bc0:	b29b      	uxth	r3, r3
 8019bc2:	00db      	lsls	r3, r3, #3
 8019bc4:	4413      	add	r3, r2
 8019bc6:	681a      	ldr	r2, [r3, #0]
 8019bc8:	68bb      	ldr	r3, [r7, #8]
 8019bca:	601a      	str	r2, [r3, #0]
    *size     = queue->queue[queue->get_index & mask].data_size;
 8019bcc:	68fb      	ldr	r3, [r7, #12]
 8019bce:	68da      	ldr	r2, [r3, #12]
 8019bd0:	68fb      	ldr	r3, [r7, #12]
 8019bd2:	8919      	ldrh	r1, [r3, #8]
 8019bd4:	8afb      	ldrh	r3, [r7, #22]
 8019bd6:	400b      	ands	r3, r1
 8019bd8:	b29b      	uxth	r3, r3
 8019bda:	00db      	lsls	r3, r3, #3
 8019bdc:	4413      	add	r3, r2
 8019bde:	685a      	ldr	r2, [r3, #4]
 8019be0:	687b      	ldr	r3, [r7, #4]
 8019be2:	601a      	str	r2, [r3, #0]

    rt_hw_interrupt_enable(level);
 8019be4:	693b      	ldr	r3, [r7, #16]
 8019be6:	4618      	mov	r0, r3
 8019be8:	f7e6 faf4 	bl	80001d4 <rt_hw_interrupt_enable>

    return RT_EOK;
 8019bec:	2300      	movs	r3, #0
}
 8019bee:	4618      	mov	r0, r3
 8019bf0:	3718      	adds	r7, #24
 8019bf2:	46bd      	mov	sp, r7
 8019bf4:	bd80      	pop	{r7, pc}
 8019bf6:	bf00      	nop
 8019bf8:	0802964c 	.word	0x0802964c
 8019bfc:	0802ab80 	.word	0x0802ab80

08019c00 <rt_i2c_core_init>:

    return (ret > 0) ? count : ret;
}

int rt_i2c_core_init(void)
{
 8019c00:	b480      	push	{r7}
 8019c02:	af00      	add	r7, sp, #0
    return 0;
 8019c04:	2300      	movs	r3, #0
}
 8019c06:	4618      	mov	r0, r3
 8019c08:	46bd      	mov	sp, r7
 8019c0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019c0e:	4770      	bx	lr

08019c10 <rt_mtd_nand_read_id>:
};

rt_err_t rt_mtd_nand_register_device(const char* name, struct rt_mtd_nand_device* device);

rt_inline rt_uint32_t rt_mtd_nand_read_id(struct rt_mtd_nand_device* device)
{
 8019c10:	b580      	push	{r7, lr}
 8019c12:	b082      	sub	sp, #8
 8019c14:	af00      	add	r7, sp, #0
 8019c16:	6078      	str	r0, [r7, #4]
	return device->ops->read_id(device);
 8019c18:	687b      	ldr	r3, [r7, #4]
 8019c1a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8019c1c:	681b      	ldr	r3, [r3, #0]
 8019c1e:	6878      	ldr	r0, [r7, #4]
 8019c20:	4798      	blx	r3
 8019c22:	4603      	mov	r3, r0
}
 8019c24:	4618      	mov	r0, r3
 8019c26:	3708      	adds	r7, #8
 8019c28:	46bd      	mov	sp, r7
 8019c2a:	bd80      	pop	{r7, pc}

08019c2c <rt_mtd_nand_read>:
rt_inline rt_err_t rt_mtd_nand_read(
	struct rt_mtd_nand_device* device,
	rt_off_t page,
	rt_uint8_t* data, rt_uint32_t data_len,
	rt_uint8_t * spare, rt_uint32_t spare_len)
{
 8019c2c:	b590      	push	{r4, r7, lr}
 8019c2e:	b087      	sub	sp, #28
 8019c30:	af02      	add	r7, sp, #8
 8019c32:	60f8      	str	r0, [r7, #12]
 8019c34:	60b9      	str	r1, [r7, #8]
 8019c36:	607a      	str	r2, [r7, #4]
 8019c38:	603b      	str	r3, [r7, #0]
	return device->ops->read_page(device, page, data, data_len, spare, spare_len);
 8019c3a:	68fb      	ldr	r3, [r7, #12]
 8019c3c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8019c3e:	685c      	ldr	r4, [r3, #4]
 8019c40:	6a3b      	ldr	r3, [r7, #32]
 8019c42:	9300      	str	r3, [sp, #0]
 8019c44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019c46:	9301      	str	r3, [sp, #4]
 8019c48:	68f8      	ldr	r0, [r7, #12]
 8019c4a:	68b9      	ldr	r1, [r7, #8]
 8019c4c:	687a      	ldr	r2, [r7, #4]
 8019c4e:	683b      	ldr	r3, [r7, #0]
 8019c50:	47a0      	blx	r4
 8019c52:	4603      	mov	r3, r0
}
 8019c54:	4618      	mov	r0, r3
 8019c56:	3714      	adds	r7, #20
 8019c58:	46bd      	mov	sp, r7
 8019c5a:	bd90      	pop	{r4, r7, pc}

08019c5c <rt_mtd_nand_write>:
rt_inline rt_err_t rt_mtd_nand_write(
	struct rt_mtd_nand_device* device,
	rt_off_t page,
	const rt_uint8_t* data, rt_uint32_t data_len,
	const rt_uint8_t * spare, rt_uint32_t spare_len)
{
 8019c5c:	b590      	push	{r4, r7, lr}
 8019c5e:	b087      	sub	sp, #28
 8019c60:	af02      	add	r7, sp, #8
 8019c62:	60f8      	str	r0, [r7, #12]
 8019c64:	60b9      	str	r1, [r7, #8]
 8019c66:	607a      	str	r2, [r7, #4]
 8019c68:	603b      	str	r3, [r7, #0]
	return device->ops->write_page(device, page, data, data_len, spare, spare_len);
 8019c6a:	68fb      	ldr	r3, [r7, #12]
 8019c6c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8019c6e:	689c      	ldr	r4, [r3, #8]
 8019c70:	6a3b      	ldr	r3, [r7, #32]
 8019c72:	9300      	str	r3, [sp, #0]
 8019c74:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019c76:	9301      	str	r3, [sp, #4]
 8019c78:	68f8      	ldr	r0, [r7, #12]
 8019c7a:	68b9      	ldr	r1, [r7, #8]
 8019c7c:	687a      	ldr	r2, [r7, #4]
 8019c7e:	683b      	ldr	r3, [r7, #0]
 8019c80:	47a0      	blx	r4
 8019c82:	4603      	mov	r3, r0
}
 8019c84:	4618      	mov	r0, r3
 8019c86:	3714      	adds	r7, #20
 8019c88:	46bd      	mov	sp, r7
 8019c8a:	bd90      	pop	{r4, r7, pc}

08019c8c <rt_mtd_nand_erase_block>:
{
	return device->ops->move_page(device, src_page, dst_page);
}

rt_inline rt_err_t rt_mtd_nand_erase_block(struct rt_mtd_nand_device* device, rt_uint32_t block)
{
 8019c8c:	b580      	push	{r7, lr}
 8019c8e:	b082      	sub	sp, #8
 8019c90:	af00      	add	r7, sp, #0
 8019c92:	6078      	str	r0, [r7, #4]
 8019c94:	6039      	str	r1, [r7, #0]
	return device->ops->erase_block(device, block);
 8019c96:	687b      	ldr	r3, [r7, #4]
 8019c98:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8019c9a:	691b      	ldr	r3, [r3, #16]
 8019c9c:	6878      	ldr	r0, [r7, #4]
 8019c9e:	6839      	ldr	r1, [r7, #0]
 8019ca0:	4798      	blx	r3
 8019ca2:	4603      	mov	r3, r0
}
 8019ca4:	4618      	mov	r0, r3
 8019ca6:	3708      	adds	r7, #8
 8019ca8:	46bd      	mov	sp, r7
 8019caa:	bd80      	pop	{r7, pc}

08019cac <mtd_dump_hex>:
#if defined(RT_MTD_NAND_DEBUG) && defined(RT_USING_FINSH)
#include <finsh.h>
#define __is_print(ch) ((unsigned int)((ch) - ' ') < 127u - ' ')

static void mtd_dump_hex(const rt_uint8_t *ptr, rt_size_t buflen)
{
 8019cac:	b580      	push	{r7, lr}
 8019cae:	b086      	sub	sp, #24
 8019cb0:	af00      	add	r7, sp, #0
 8019cb2:	6078      	str	r0, [r7, #4]
 8019cb4:	6039      	str	r1, [r7, #0]
	unsigned char *buf = (unsigned char*)ptr;
 8019cb6:	687b      	ldr	r3, [r7, #4]
 8019cb8:	60fb      	str	r3, [r7, #12]
	int i, j;
	for (i=0; i<buflen; i+=16) 
 8019cba:	2300      	movs	r3, #0
 8019cbc:	617b      	str	r3, [r7, #20]
 8019cbe:	e052      	b.n	8019d66 <mtd_dump_hex+0xba>
	{
		rt_kprintf("%06x: ", i);
 8019cc0:	482c      	ldr	r0, [pc, #176]	; (8019d74 <mtd_dump_hex+0xc8>)
 8019cc2:	6979      	ldr	r1, [r7, #20]
 8019cc4:	f7fd fa24 	bl	8017110 <rt_kprintf>
		for (j=0; j<16; j++)
 8019cc8:	2300      	movs	r3, #0
 8019cca:	613b      	str	r3, [r7, #16]
 8019ccc:	e018      	b.n	8019d00 <mtd_dump_hex+0x54>
			if (i+j < buflen)
 8019cce:	697a      	ldr	r2, [r7, #20]
 8019cd0:	693b      	ldr	r3, [r7, #16]
 8019cd2:	4413      	add	r3, r2
 8019cd4:	461a      	mov	r2, r3
 8019cd6:	683b      	ldr	r3, [r7, #0]
 8019cd8:	429a      	cmp	r2, r3
 8019cda:	d20b      	bcs.n	8019cf4 <mtd_dump_hex+0x48>
				rt_kprintf("%02x ", buf[i+j]);
 8019cdc:	697a      	ldr	r2, [r7, #20]
 8019cde:	693b      	ldr	r3, [r7, #16]
 8019ce0:	4413      	add	r3, r2
 8019ce2:	461a      	mov	r2, r3
 8019ce4:	68fb      	ldr	r3, [r7, #12]
 8019ce6:	4413      	add	r3, r2
 8019ce8:	781b      	ldrb	r3, [r3, #0]
 8019cea:	4823      	ldr	r0, [pc, #140]	; (8019d78 <mtd_dump_hex+0xcc>)
 8019cec:	4619      	mov	r1, r3
 8019cee:	f7fd fa0f 	bl	8017110 <rt_kprintf>
 8019cf2:	e002      	b.n	8019cfa <mtd_dump_hex+0x4e>
			else
				rt_kprintf("   ");
 8019cf4:	4821      	ldr	r0, [pc, #132]	; (8019d7c <mtd_dump_hex+0xd0>)
 8019cf6:	f7fd fa0b 	bl	8017110 <rt_kprintf>
	unsigned char *buf = (unsigned char*)ptr;
	int i, j;
	for (i=0; i<buflen; i+=16) 
	{
		rt_kprintf("%06x: ", i);
		for (j=0; j<16; j++)
 8019cfa:	693b      	ldr	r3, [r7, #16]
 8019cfc:	3301      	adds	r3, #1
 8019cfe:	613b      	str	r3, [r7, #16]
 8019d00:	693b      	ldr	r3, [r7, #16]
 8019d02:	2b0f      	cmp	r3, #15
 8019d04:	dde3      	ble.n	8019cce <mtd_dump_hex+0x22>
			if (i+j < buflen)
				rt_kprintf("%02x ", buf[i+j]);
			else
				rt_kprintf("   ");
		rt_kprintf(" ");
 8019d06:	481e      	ldr	r0, [pc, #120]	; (8019d80 <mtd_dump_hex+0xd4>)
 8019d08:	f7fd fa02 	bl	8017110 <rt_kprintf>
		for (j=0; j<16; j++)
 8019d0c:	2300      	movs	r3, #0
 8019d0e:	613b      	str	r3, [r7, #16]
 8019d10:	e020      	b.n	8019d54 <mtd_dump_hex+0xa8>
			if (i+j < buflen)
 8019d12:	697a      	ldr	r2, [r7, #20]
 8019d14:	693b      	ldr	r3, [r7, #16]
 8019d16:	4413      	add	r3, r2
 8019d18:	461a      	mov	r2, r3
 8019d1a:	683b      	ldr	r3, [r7, #0]
 8019d1c:	429a      	cmp	r2, r3
 8019d1e:	d216      	bcs.n	8019d4e <mtd_dump_hex+0xa2>
				rt_kprintf("%c", __is_print(buf[i+j]) ? buf[i+j] : '.');
 8019d20:	697a      	ldr	r2, [r7, #20]
 8019d22:	693b      	ldr	r3, [r7, #16]
 8019d24:	4413      	add	r3, r2
 8019d26:	461a      	mov	r2, r3
 8019d28:	68fb      	ldr	r3, [r7, #12]
 8019d2a:	4413      	add	r3, r2
 8019d2c:	781b      	ldrb	r3, [r3, #0]
 8019d2e:	3b20      	subs	r3, #32
 8019d30:	2b5e      	cmp	r3, #94	; 0x5e
 8019d32:	d807      	bhi.n	8019d44 <mtd_dump_hex+0x98>
 8019d34:	697a      	ldr	r2, [r7, #20]
 8019d36:	693b      	ldr	r3, [r7, #16]
 8019d38:	4413      	add	r3, r2
 8019d3a:	461a      	mov	r2, r3
 8019d3c:	68fb      	ldr	r3, [r7, #12]
 8019d3e:	4413      	add	r3, r2
 8019d40:	781b      	ldrb	r3, [r3, #0]
 8019d42:	e000      	b.n	8019d46 <mtd_dump_hex+0x9a>
 8019d44:	232e      	movs	r3, #46	; 0x2e
 8019d46:	480f      	ldr	r0, [pc, #60]	; (8019d84 <mtd_dump_hex+0xd8>)
 8019d48:	4619      	mov	r1, r3
 8019d4a:	f7fd f9e1 	bl	8017110 <rt_kprintf>
			if (i+j < buflen)
				rt_kprintf("%02x ", buf[i+j]);
			else
				rt_kprintf("   ");
		rt_kprintf(" ");
		for (j=0; j<16; j++)
 8019d4e:	693b      	ldr	r3, [r7, #16]
 8019d50:	3301      	adds	r3, #1
 8019d52:	613b      	str	r3, [r7, #16]
 8019d54:	693b      	ldr	r3, [r7, #16]
 8019d56:	2b0f      	cmp	r3, #15
 8019d58:	dddb      	ble.n	8019d12 <mtd_dump_hex+0x66>
			if (i+j < buflen)
				rt_kprintf("%c", __is_print(buf[i+j]) ? buf[i+j] : '.');
		rt_kprintf("\n");
 8019d5a:	480b      	ldr	r0, [pc, #44]	; (8019d88 <mtd_dump_hex+0xdc>)
 8019d5c:	f7fd f9d8 	bl	8017110 <rt_kprintf>

static void mtd_dump_hex(const rt_uint8_t *ptr, rt_size_t buflen)
{
	unsigned char *buf = (unsigned char*)ptr;
	int i, j;
	for (i=0; i<buflen; i+=16) 
 8019d60:	697b      	ldr	r3, [r7, #20]
 8019d62:	3310      	adds	r3, #16
 8019d64:	617b      	str	r3, [r7, #20]
 8019d66:	697a      	ldr	r2, [r7, #20]
 8019d68:	683b      	ldr	r3, [r7, #0]
 8019d6a:	429a      	cmp	r2, r3
 8019d6c:	d3a8      	bcc.n	8019cc0 <mtd_dump_hex+0x14>
		for (j=0; j<16; j++)
			if (i+j < buflen)
				rt_kprintf("%c", __is_print(buf[i+j]) ? buf[i+j] : '.');
		rt_kprintf("\n");
	}
}
 8019d6e:	3718      	adds	r7, #24
 8019d70:	46bd      	mov	sp, r7
 8019d72:	bd80      	pop	{r7, pc}
 8019d74:	080296bc 	.word	0x080296bc
 8019d78:	080296c4 	.word	0x080296c4
 8019d7c:	080296cc 	.word	0x080296cc
 8019d80:	080296d0 	.word	0x080296d0
 8019d84:	080296d4 	.word	0x080296d4
 8019d88:	080296d8 	.word	0x080296d8

08019d8c <mtd_nandid>:

int mtd_nandid(const char* name)
{
 8019d8c:	b580      	push	{r7, lr}
 8019d8e:	b084      	sub	sp, #16
 8019d90:	af00      	add	r7, sp, #0
 8019d92:	6078      	str	r0, [r7, #4]
	struct rt_mtd_nand_device *nand;
	nand = RT_MTD_NAND_DEVICE(rt_device_find(name));
 8019d94:	6878      	ldr	r0, [r7, #4]
 8019d96:	f7fb fb2d 	bl	80153f4 <rt_device_find>
 8019d9a:	60f8      	str	r0, [r7, #12]
	if (nand == RT_NULL)
 8019d9c:	68fb      	ldr	r3, [r7, #12]
 8019d9e:	2b00      	cmp	r3, #0
 8019da0:	d105      	bne.n	8019dae <mtd_nandid+0x22>
	{
		rt_kprintf("no nand device found!\n");
 8019da2:	4807      	ldr	r0, [pc, #28]	; (8019dc0 <mtd_nandid+0x34>)
 8019da4:	f7fd f9b4 	bl	8017110 <rt_kprintf>
		return -RT_ERROR;
 8019da8:	f04f 33ff 	mov.w	r3, #4294967295
 8019dac:	e003      	b.n	8019db6 <mtd_nandid+0x2a>
	}

	return rt_mtd_nand_read_id(nand);
 8019dae:	68f8      	ldr	r0, [r7, #12]
 8019db0:	f7ff ff2e 	bl	8019c10 <rt_mtd_nand_read_id>
 8019db4:	4603      	mov	r3, r0
}
 8019db6:	4618      	mov	r0, r3
 8019db8:	3710      	adds	r7, #16
 8019dba:	46bd      	mov	sp, r7
 8019dbc:	bd80      	pop	{r7, pc}
 8019dbe:	bf00      	nop
 8019dc0:	080296dc 	.word	0x080296dc

08019dc4 <mtd_nand_read>:
FINSH_FUNCTION_EXPORT_ALIAS(mtd_nandid, nand_id, read ID - nandid(name));

int mtd_nand_read(const char* name, int block, int page)
{
 8019dc4:	b590      	push	{r4, r7, lr}
 8019dc6:	b08b      	sub	sp, #44	; 0x2c
 8019dc8:	af02      	add	r7, sp, #8
 8019dca:	60f8      	str	r0, [r7, #12]
 8019dcc:	60b9      	str	r1, [r7, #8]
 8019dce:	607a      	str	r2, [r7, #4]
	rt_err_t result;
	rt_uint8_t *page_ptr;
	rt_uint8_t *oob_ptr;
	struct rt_mtd_nand_device *nand;

	nand = RT_MTD_NAND_DEVICE(rt_device_find(name));
 8019dd0:	68f8      	ldr	r0, [r7, #12]
 8019dd2:	f7fb fb0f 	bl	80153f4 <rt_device_find>
 8019dd6:	61f8      	str	r0, [r7, #28]
	if (nand == RT_NULL)
 8019dd8:	69fb      	ldr	r3, [r7, #28]
 8019dda:	2b00      	cmp	r3, #0
 8019ddc:	d105      	bne.n	8019dea <mtd_nand_read+0x26>
	{
		rt_kprintf("no nand device found!\n");
 8019dde:	4831      	ldr	r0, [pc, #196]	; (8019ea4 <mtd_nand_read+0xe0>)
 8019de0:	f7fd f996 	bl	8017110 <rt_kprintf>
		return -RT_ERROR;
 8019de4:	f04f 33ff 	mov.w	r3, #4294967295
 8019de8:	e058      	b.n	8019e9c <mtd_nand_read+0xd8>
	}

	page_ptr = rt_malloc(nand->page_size + nand->oob_size);
 8019dea:	69fb      	ldr	r3, [r7, #28]
 8019dec:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8019df0:	461a      	mov	r2, r3
 8019df2:	69fb      	ldr	r3, [r7, #28]
 8019df4:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 8019df8:	4413      	add	r3, r2
 8019dfa:	4618      	mov	r0, r3
 8019dfc:	f7fd fb36 	bl	801746c <rt_malloc>
 8019e00:	61b8      	str	r0, [r7, #24]
	if (page_ptr == RT_NULL)
 8019e02:	69bb      	ldr	r3, [r7, #24]
 8019e04:	2b00      	cmp	r3, #0
 8019e06:	d105      	bne.n	8019e14 <mtd_nand_read+0x50>
	{
		rt_kprintf("out of memory!\n");
 8019e08:	4827      	ldr	r0, [pc, #156]	; (8019ea8 <mtd_nand_read+0xe4>)
 8019e0a:	f7fd f981 	bl	8017110 <rt_kprintf>
		return -RT_ENOMEM;
 8019e0e:	f06f 0304 	mvn.w	r3, #4
 8019e12:	e043      	b.n	8019e9c <mtd_nand_read+0xd8>
	}

	oob_ptr = page_ptr + nand->page_size;
 8019e14:	69fb      	ldr	r3, [r7, #28]
 8019e16:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8019e1a:	461a      	mov	r2, r3
 8019e1c:	69bb      	ldr	r3, [r7, #24]
 8019e1e:	4413      	add	r3, r2
 8019e20:	617b      	str	r3, [r7, #20]
	rt_memset(page_ptr, 0xff, nand->page_size + nand->oob_size);
 8019e22:	69fb      	ldr	r3, [r7, #28]
 8019e24:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8019e28:	461a      	mov	r2, r3
 8019e2a:	69fb      	ldr	r3, [r7, #28]
 8019e2c:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 8019e30:	4413      	add	r3, r2
 8019e32:	69b8      	ldr	r0, [r7, #24]
 8019e34:	21ff      	movs	r1, #255	; 0xff
 8019e36:	461a      	mov	r2, r3
 8019e38:	f7fc fbb2 	bl	80165a0 <rt_memset>

	/* calculate the page number */
	page = block * nand->pages_per_block + page;
 8019e3c:	69fb      	ldr	r3, [r7, #28]
 8019e3e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8019e40:	68ba      	ldr	r2, [r7, #8]
 8019e42:	fb02 f203 	mul.w	r2, r2, r3
 8019e46:	687b      	ldr	r3, [r7, #4]
 8019e48:	4413      	add	r3, r2
 8019e4a:	607b      	str	r3, [r7, #4]
	result = rt_mtd_nand_read(nand, page, page_ptr, nand->page_size,
 8019e4c:	69fb      	ldr	r3, [r7, #28]
 8019e4e:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8019e52:	461c      	mov	r4, r3
		oob_ptr, nand->oob_size);
 8019e54:	69fb      	ldr	r3, [r7, #28]
 8019e56:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
	oob_ptr = page_ptr + nand->page_size;
	rt_memset(page_ptr, 0xff, nand->page_size + nand->oob_size);

	/* calculate the page number */
	page = block * nand->pages_per_block + page;
	result = rt_mtd_nand_read(nand, page, page_ptr, nand->page_size,
 8019e5a:	461a      	mov	r2, r3
 8019e5c:	697b      	ldr	r3, [r7, #20]
 8019e5e:	9300      	str	r3, [sp, #0]
 8019e60:	9201      	str	r2, [sp, #4]
 8019e62:	69f8      	ldr	r0, [r7, #28]
 8019e64:	6879      	ldr	r1, [r7, #4]
 8019e66:	69ba      	ldr	r2, [r7, #24]
 8019e68:	4623      	mov	r3, r4
 8019e6a:	f7ff fedf 	bl	8019c2c <rt_mtd_nand_read>
 8019e6e:	6138      	str	r0, [r7, #16]
		oob_ptr, nand->oob_size);

	rt_kprintf("read page, rc=%d\n", result);
 8019e70:	480e      	ldr	r0, [pc, #56]	; (8019eac <mtd_nand_read+0xe8>)
 8019e72:	6939      	ldr	r1, [r7, #16]
 8019e74:	f7fd f94c 	bl	8017110 <rt_kprintf>
	mtd_dump_hex(page_ptr, nand->page_size);
 8019e78:	69fb      	ldr	r3, [r7, #28]
 8019e7a:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8019e7e:	69b8      	ldr	r0, [r7, #24]
 8019e80:	4619      	mov	r1, r3
 8019e82:	f7ff ff13 	bl	8019cac <mtd_dump_hex>
	mtd_dump_hex(oob_ptr, nand->oob_size);
 8019e86:	69fb      	ldr	r3, [r7, #28]
 8019e88:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 8019e8c:	6978      	ldr	r0, [r7, #20]
 8019e8e:	4619      	mov	r1, r3
 8019e90:	f7ff ff0c 	bl	8019cac <mtd_dump_hex>

	rt_free(page_ptr);
 8019e94:	69b8      	ldr	r0, [r7, #24]
 8019e96:	f7fd fd2d 	bl	80178f4 <rt_free>
	return 0;
 8019e9a:	2300      	movs	r3, #0
}
 8019e9c:	4618      	mov	r0, r3
 8019e9e:	3724      	adds	r7, #36	; 0x24
 8019ea0:	46bd      	mov	sp, r7
 8019ea2:	bd90      	pop	{r4, r7, pc}
 8019ea4:	080296dc 	.word	0x080296dc
 8019ea8:	080296f4 	.word	0x080296f4
 8019eac:	08029704 	.word	0x08029704

08019eb0 <mtd_nand_readoob>:
FINSH_FUNCTION_EXPORT_ALIAS(mtd_nand_read, nand_read, read page in nand - nand_read(name, block, page));

int mtd_nand_readoob(const char* name, int block, int page)
{
 8019eb0:	b590      	push	{r4, r7, lr}
 8019eb2:	b089      	sub	sp, #36	; 0x24
 8019eb4:	af02      	add	r7, sp, #8
 8019eb6:	60f8      	str	r0, [r7, #12]
 8019eb8:	60b9      	str	r1, [r7, #8]
 8019eba:	607a      	str	r2, [r7, #4]
	struct rt_mtd_nand_device *nand;
	rt_uint8_t *oob_ptr;

	nand = RT_MTD_NAND_DEVICE(rt_device_find(name));
 8019ebc:	68f8      	ldr	r0, [r7, #12]
 8019ebe:	f7fb fa99 	bl	80153f4 <rt_device_find>
 8019ec2:	6178      	str	r0, [r7, #20]
	if (nand == RT_NULL)
 8019ec4:	697b      	ldr	r3, [r7, #20]
 8019ec6:	2b00      	cmp	r3, #0
 8019ec8:	d105      	bne.n	8019ed6 <mtd_nand_readoob+0x26>
	{
		rt_kprintf("no nand device found!\n");
 8019eca:	481f      	ldr	r0, [pc, #124]	; (8019f48 <mtd_nand_readoob+0x98>)
 8019ecc:	f7fd f920 	bl	8017110 <rt_kprintf>
		return -RT_ERROR;
 8019ed0:	f04f 33ff 	mov.w	r3, #4294967295
 8019ed4:	e033      	b.n	8019f3e <mtd_nand_readoob+0x8e>
	}

	oob_ptr = rt_malloc(nand->oob_size);
 8019ed6:	697b      	ldr	r3, [r7, #20]
 8019ed8:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 8019edc:	4618      	mov	r0, r3
 8019ede:	f7fd fac5 	bl	801746c <rt_malloc>
 8019ee2:	6138      	str	r0, [r7, #16]
	if (oob_ptr == RT_NULL)
 8019ee4:	693b      	ldr	r3, [r7, #16]
 8019ee6:	2b00      	cmp	r3, #0
 8019ee8:	d105      	bne.n	8019ef6 <mtd_nand_readoob+0x46>
	{
		rt_kprintf("out of memory!\n");
 8019eea:	4818      	ldr	r0, [pc, #96]	; (8019f4c <mtd_nand_readoob+0x9c>)
 8019eec:	f7fd f910 	bl	8017110 <rt_kprintf>
		return -RT_ENOMEM;
 8019ef0:	f06f 0304 	mvn.w	r3, #4
 8019ef4:	e023      	b.n	8019f3e <mtd_nand_readoob+0x8e>
	}

	/* calculate the page number */
	page = block * nand->pages_per_block + page;
 8019ef6:	697b      	ldr	r3, [r7, #20]
 8019ef8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8019efa:	68ba      	ldr	r2, [r7, #8]
 8019efc:	fb02 f203 	mul.w	r2, r2, r3
 8019f00:	687b      	ldr	r3, [r7, #4]
 8019f02:	4413      	add	r3, r2
 8019f04:	607b      	str	r3, [r7, #4]
	rt_mtd_nand_read(nand, page, RT_NULL, nand->page_size,
 8019f06:	697b      	ldr	r3, [r7, #20]
 8019f08:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8019f0c:	461c      	mov	r4, r3
		oob_ptr, nand->oob_size);
 8019f0e:	697b      	ldr	r3, [r7, #20]
 8019f10:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
		return -RT_ENOMEM;
	}

	/* calculate the page number */
	page = block * nand->pages_per_block + page;
	rt_mtd_nand_read(nand, page, RT_NULL, nand->page_size,
 8019f14:	461a      	mov	r2, r3
 8019f16:	693b      	ldr	r3, [r7, #16]
 8019f18:	9300      	str	r3, [sp, #0]
 8019f1a:	9201      	str	r2, [sp, #4]
 8019f1c:	6978      	ldr	r0, [r7, #20]
 8019f1e:	6879      	ldr	r1, [r7, #4]
 8019f20:	2200      	movs	r2, #0
 8019f22:	4623      	mov	r3, r4
 8019f24:	f7ff fe82 	bl	8019c2c <rt_mtd_nand_read>
		oob_ptr, nand->oob_size);
	mtd_dump_hex(oob_ptr, nand->oob_size);
 8019f28:	697b      	ldr	r3, [r7, #20]
 8019f2a:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 8019f2e:	6938      	ldr	r0, [r7, #16]
 8019f30:	4619      	mov	r1, r3
 8019f32:	f7ff febb 	bl	8019cac <mtd_dump_hex>

	rt_free(oob_ptr);
 8019f36:	6938      	ldr	r0, [r7, #16]
 8019f38:	f7fd fcdc 	bl	80178f4 <rt_free>
	return 0;
 8019f3c:	2300      	movs	r3, #0
}
 8019f3e:	4618      	mov	r0, r3
 8019f40:	371c      	adds	r7, #28
 8019f42:	46bd      	mov	sp, r7
 8019f44:	bd90      	pop	{r4, r7, pc}
 8019f46:	bf00      	nop
 8019f48:	080296dc 	.word	0x080296dc
 8019f4c:	080296f4 	.word	0x080296f4

08019f50 <mtd_nand_write>:
FINSH_FUNCTION_EXPORT_ALIAS(mtd_nand_readoob, nand_readoob, read spare data in nand - nand_readoob(name, block, page));

int mtd_nand_write(const char* name, int block, int page)
{
 8019f50:	b590      	push	{r4, r7, lr}
 8019f52:	b08d      	sub	sp, #52	; 0x34
 8019f54:	af02      	add	r7, sp, #8
 8019f56:	60f8      	str	r0, [r7, #12]
 8019f58:	60b9      	str	r1, [r7, #8]
 8019f5a:	607a      	str	r2, [r7, #4]
	rt_uint8_t *page_ptr;
	rt_uint8_t *oob_ptr;
	rt_uint32_t index;
	struct rt_mtd_nand_device *nand;

	nand = RT_MTD_NAND_DEVICE(rt_device_find(name));
 8019f5c:	68f8      	ldr	r0, [r7, #12]
 8019f5e:	f7fb fa49 	bl	80153f4 <rt_device_find>
 8019f62:	6238      	str	r0, [r7, #32]
	if (nand == RT_NULL)
 8019f64:	6a3b      	ldr	r3, [r7, #32]
 8019f66:	2b00      	cmp	r3, #0
 8019f68:	d105      	bne.n	8019f76 <mtd_nand_write+0x26>
	{
		rt_kprintf("no nand device found!\n");
 8019f6a:	4838      	ldr	r0, [pc, #224]	; (801a04c <mtd_nand_write+0xfc>)
 8019f6c:	f7fd f8d0 	bl	8017110 <rt_kprintf>
		return -RT_ERROR;
 8019f70:	f04f 33ff 	mov.w	r3, #4294967295
 8019f74:	e066      	b.n	801a044 <mtd_nand_write+0xf4>
	}

	page_ptr = rt_malloc(nand->page_size + nand->oob_size);
 8019f76:	6a3b      	ldr	r3, [r7, #32]
 8019f78:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8019f7c:	461a      	mov	r2, r3
 8019f7e:	6a3b      	ldr	r3, [r7, #32]
 8019f80:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 8019f84:	4413      	add	r3, r2
 8019f86:	4618      	mov	r0, r3
 8019f88:	f7fd fa70 	bl	801746c <rt_malloc>
 8019f8c:	61f8      	str	r0, [r7, #28]
	if (page_ptr == RT_NULL)
 8019f8e:	69fb      	ldr	r3, [r7, #28]
 8019f90:	2b00      	cmp	r3, #0
 8019f92:	d105      	bne.n	8019fa0 <mtd_nand_write+0x50>
	{
		rt_kprintf("out of memory!\n");
 8019f94:	482e      	ldr	r0, [pc, #184]	; (801a050 <mtd_nand_write+0x100>)
 8019f96:	f7fd f8bb 	bl	8017110 <rt_kprintf>
		return -RT_ENOMEM;
 8019f9a:	f06f 0304 	mvn.w	r3, #4
 8019f9e:	e051      	b.n	801a044 <mtd_nand_write+0xf4>
	}

	oob_ptr = page_ptr + nand->page_size;
 8019fa0:	6a3b      	ldr	r3, [r7, #32]
 8019fa2:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8019fa6:	461a      	mov	r2, r3
 8019fa8:	69fb      	ldr	r3, [r7, #28]
 8019faa:	4413      	add	r3, r2
 8019fac:	61bb      	str	r3, [r7, #24]
	/* prepare page data */
	for (index = 0; index < nand->page_size; index ++)
 8019fae:	2300      	movs	r3, #0
 8019fb0:	627b      	str	r3, [r7, #36]	; 0x24
 8019fb2:	e008      	b.n	8019fc6 <mtd_nand_write+0x76>
	{
		page_ptr[index] = index & 0xff;
 8019fb4:	69fa      	ldr	r2, [r7, #28]
 8019fb6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019fb8:	4413      	add	r3, r2
 8019fba:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8019fbc:	b2d2      	uxtb	r2, r2
 8019fbe:	701a      	strb	r2, [r3, #0]
		return -RT_ENOMEM;
	}

	oob_ptr = page_ptr + nand->page_size;
	/* prepare page data */
	for (index = 0; index < nand->page_size; index ++)
 8019fc0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019fc2:	3301      	adds	r3, #1
 8019fc4:	627b      	str	r3, [r7, #36]	; 0x24
 8019fc6:	6a3b      	ldr	r3, [r7, #32]
 8019fc8:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8019fcc:	461a      	mov	r2, r3
 8019fce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019fd0:	429a      	cmp	r2, r3
 8019fd2:	d8ef      	bhi.n	8019fb4 <mtd_nand_write+0x64>
	{
		page_ptr[index] = index & 0xff;
	}
	/* prepare oob data */
	for (index = 0; index < nand->oob_size; index ++)
 8019fd4:	2300      	movs	r3, #0
 8019fd6:	627b      	str	r3, [r7, #36]	; 0x24
 8019fd8:	e008      	b.n	8019fec <mtd_nand_write+0x9c>
	{
		oob_ptr[index] = index & 0xff;
 8019fda:	69ba      	ldr	r2, [r7, #24]
 8019fdc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019fde:	4413      	add	r3, r2
 8019fe0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8019fe2:	b2d2      	uxtb	r2, r2
 8019fe4:	701a      	strb	r2, [r3, #0]
	for (index = 0; index < nand->page_size; index ++)
	{
		page_ptr[index] = index & 0xff;
	}
	/* prepare oob data */
	for (index = 0; index < nand->oob_size; index ++)
 8019fe6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019fe8:	3301      	adds	r3, #1
 8019fea:	627b      	str	r3, [r7, #36]	; 0x24
 8019fec:	6a3b      	ldr	r3, [r7, #32]
 8019fee:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
 8019ff2:	461a      	mov	r2, r3
 8019ff4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019ff6:	429a      	cmp	r2, r3
 8019ff8:	d8ef      	bhi.n	8019fda <mtd_nand_write+0x8a>
	{
		oob_ptr[index] = index & 0xff;
	}

	/* calculate the page number */
	page = block * nand->pages_per_block + page;
 8019ffa:	6a3b      	ldr	r3, [r7, #32]
 8019ffc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8019ffe:	68ba      	ldr	r2, [r7, #8]
 801a000:	fb02 f203 	mul.w	r2, r2, r3
 801a004:	687b      	ldr	r3, [r7, #4]
 801a006:	4413      	add	r3, r2
 801a008:	607b      	str	r3, [r7, #4]
	result = rt_mtd_nand_write(nand, page, page_ptr, nand->page_size,
 801a00a:	6a3b      	ldr	r3, [r7, #32]
 801a00c:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 801a010:	461c      	mov	r4, r3
		oob_ptr, nand->oob_size);
 801a012:	6a3b      	ldr	r3, [r7, #32]
 801a014:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
		oob_ptr[index] = index & 0xff;
	}

	/* calculate the page number */
	page = block * nand->pages_per_block + page;
	result = rt_mtd_nand_write(nand, page, page_ptr, nand->page_size,
 801a018:	461a      	mov	r2, r3
 801a01a:	69bb      	ldr	r3, [r7, #24]
 801a01c:	9300      	str	r3, [sp, #0]
 801a01e:	9201      	str	r2, [sp, #4]
 801a020:	6a38      	ldr	r0, [r7, #32]
 801a022:	6879      	ldr	r1, [r7, #4]
 801a024:	69fa      	ldr	r2, [r7, #28]
 801a026:	4623      	mov	r3, r4
 801a028:	f7ff fe18 	bl	8019c5c <rt_mtd_nand_write>
 801a02c:	6178      	str	r0, [r7, #20]
		oob_ptr, nand->oob_size);
	if (result != RT_MTD_EOK)
 801a02e:	697b      	ldr	r3, [r7, #20]
 801a030:	2b00      	cmp	r3, #0
 801a032:	d003      	beq.n	801a03c <mtd_nand_write+0xec>
	{
		rt_kprintf("write page failed!, rc=%d\n", result);
 801a034:	4807      	ldr	r0, [pc, #28]	; (801a054 <mtd_nand_write+0x104>)
 801a036:	6979      	ldr	r1, [r7, #20]
 801a038:	f7fd f86a 	bl	8017110 <rt_kprintf>
	}

	rt_free(page_ptr);
 801a03c:	69f8      	ldr	r0, [r7, #28]
 801a03e:	f7fd fc59 	bl	80178f4 <rt_free>
	return 0;
 801a042:	2300      	movs	r3, #0
}
 801a044:	4618      	mov	r0, r3
 801a046:	372c      	adds	r7, #44	; 0x2c
 801a048:	46bd      	mov	sp, r7
 801a04a:	bd90      	pop	{r4, r7, pc}
 801a04c:	080296dc 	.word	0x080296dc
 801a050:	080296f4 	.word	0x080296f4
 801a054:	08029718 	.word	0x08029718

0801a058 <mtd_nand_erase>:
FINSH_FUNCTION_EXPORT_ALIAS(mtd_nand_write, nand_write, write dump data to nand - nand_write(name, block, page));

int mtd_nand_erase(const char* name, int block)
{
 801a058:	b580      	push	{r7, lr}
 801a05a:	b084      	sub	sp, #16
 801a05c:	af00      	add	r7, sp, #0
 801a05e:	6078      	str	r0, [r7, #4]
 801a060:	6039      	str	r1, [r7, #0]
	struct rt_mtd_nand_device *nand;
	nand = RT_MTD_NAND_DEVICE(rt_device_find(name));
 801a062:	6878      	ldr	r0, [r7, #4]
 801a064:	f7fb f9c6 	bl	80153f4 <rt_device_find>
 801a068:	60f8      	str	r0, [r7, #12]
	if (nand == RT_NULL)
 801a06a:	68fb      	ldr	r3, [r7, #12]
 801a06c:	2b00      	cmp	r3, #0
 801a06e:	d105      	bne.n	801a07c <mtd_nand_erase+0x24>
	{
		rt_kprintf("no nand device found!\n");
 801a070:	4807      	ldr	r0, [pc, #28]	; (801a090 <mtd_nand_erase+0x38>)
 801a072:	f7fd f84d 	bl	8017110 <rt_kprintf>
		return -RT_ERROR;
 801a076:	f04f 33ff 	mov.w	r3, #4294967295
 801a07a:	e005      	b.n	801a088 <mtd_nand_erase+0x30>
	}

	return rt_mtd_nand_erase_block(nand, block);
 801a07c:	683b      	ldr	r3, [r7, #0]
 801a07e:	68f8      	ldr	r0, [r7, #12]
 801a080:	4619      	mov	r1, r3
 801a082:	f7ff fe03 	bl	8019c8c <rt_mtd_nand_erase_block>
 801a086:	4603      	mov	r3, r0
}
 801a088:	4618      	mov	r0, r3
 801a08a:	3710      	adds	r7, #16
 801a08c:	46bd      	mov	sp, r7
 801a08e:	bd80      	pop	{r7, pc}
 801a090:	080296dc 	.word	0x080296dc

0801a094 <mtd_nand_erase_all>:
FINSH_FUNCTION_EXPORT_ALIAS(mtd_nand_erase, nand_erase, nand_erase(name, block));

int mtd_nand_erase_all(const char* name)
{
 801a094:	b580      	push	{r7, lr}
 801a096:	b084      	sub	sp, #16
 801a098:	af00      	add	r7, sp, #0
 801a09a:	6078      	str	r0, [r7, #4]
	rt_uint32_t index = 0;
 801a09c:	2300      	movs	r3, #0
 801a09e:	60fb      	str	r3, [r7, #12]
	struct rt_mtd_nand_device *nand;
	
	nand = RT_MTD_NAND_DEVICE(rt_device_find(name));
 801a0a0:	6878      	ldr	r0, [r7, #4]
 801a0a2:	f7fb f9a7 	bl	80153f4 <rt_device_find>
 801a0a6:	60b8      	str	r0, [r7, #8]
	if (nand == RT_NULL)
 801a0a8:	68bb      	ldr	r3, [r7, #8]
 801a0aa:	2b00      	cmp	r3, #0
 801a0ac:	d105      	bne.n	801a0ba <mtd_nand_erase_all+0x26>
	{
		rt_kprintf("no nand device found!\n");
 801a0ae:	480e      	ldr	r0, [pc, #56]	; (801a0e8 <mtd_nand_erase_all+0x54>)
 801a0b0:	f7fd f82e 	bl	8017110 <rt_kprintf>
		return -RT_ERROR;
 801a0b4:	f04f 33ff 	mov.w	r3, #4294967295
 801a0b8:	e012      	b.n	801a0e0 <mtd_nand_erase_all+0x4c>
	}

	for (index = 0; index < (nand->block_end - nand->block_start); index ++)
 801a0ba:	2300      	movs	r3, #0
 801a0bc:	60fb      	str	r3, [r7, #12]
 801a0be:	e006      	b.n	801a0ce <mtd_nand_erase_all+0x3a>
	{
		rt_mtd_nand_erase_block(nand, index);
 801a0c0:	68b8      	ldr	r0, [r7, #8]
 801a0c2:	68f9      	ldr	r1, [r7, #12]
 801a0c4:	f7ff fde2 	bl	8019c8c <rt_mtd_nand_erase_block>
	{
		rt_kprintf("no nand device found!\n");
		return -RT_ERROR;
	}

	for (index = 0; index < (nand->block_end - nand->block_start); index ++)
 801a0c8:	68fb      	ldr	r3, [r7, #12]
 801a0ca:	3301      	adds	r3, #1
 801a0cc:	60fb      	str	r3, [r7, #12]
 801a0ce:	68bb      	ldr	r3, [r7, #8]
 801a0d0:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801a0d2:	68bb      	ldr	r3, [r7, #8]
 801a0d4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a0d6:	1ad2      	subs	r2, r2, r3
 801a0d8:	68fb      	ldr	r3, [r7, #12]
 801a0da:	429a      	cmp	r2, r3
 801a0dc:	d8f0      	bhi.n	801a0c0 <mtd_nand_erase_all+0x2c>
	{
		rt_mtd_nand_erase_block(nand, index);
	}
	
	return 0;
 801a0de:	2300      	movs	r3, #0
}
 801a0e0:	4618      	mov	r0, r3
 801a0e2:	3710      	adds	r7, #16
 801a0e4:	46bd      	mov	sp, r7
 801a0e6:	bd80      	pop	{r7, pc}
 801a0e8:	080296dc 	.word	0x080296dc

0801a0ec <time>:
#pragma module_name = "?time"
time_t (__time32)(time_t *t) /* Only supports 32-bit timestamp */
#else
time_t time(time_t *t)
#endif
{
 801a0ec:	b580      	push	{r7, lr}
 801a0ee:	b084      	sub	sp, #16
 801a0f0:	af00      	add	r7, sp, #0
 801a0f2:	6078      	str	r0, [r7, #4]
    static rt_device_t device = RT_NULL;
    time_t time_now = 0;
 801a0f4:	2300      	movs	r3, #0
 801a0f6:	60fb      	str	r3, [r7, #12]

    /* optimization: find rtc device only first. */
    if (device == RT_NULL)
 801a0f8:	4b17      	ldr	r3, [pc, #92]	; (801a158 <time+0x6c>)
 801a0fa:	681b      	ldr	r3, [r3, #0]
 801a0fc:	2b00      	cmp	r3, #0
 801a0fe:	d105      	bne.n	801a10c <time+0x20>
    {
        device = rt_device_find("rtc");
 801a100:	4816      	ldr	r0, [pc, #88]	; (801a15c <time+0x70>)
 801a102:	f7fb f977 	bl	80153f4 <rt_device_find>
 801a106:	4602      	mov	r2, r0
 801a108:	4b13      	ldr	r3, [pc, #76]	; (801a158 <time+0x6c>)
 801a10a:	601a      	str	r2, [r3, #0]
    }

    /* read timestamp from RTC device. */
    if (device != RT_NULL)
 801a10c:	4b12      	ldr	r3, [pc, #72]	; (801a158 <time+0x6c>)
 801a10e:	681b      	ldr	r3, [r3, #0]
 801a110:	2b00      	cmp	r3, #0
 801a112:	d016      	beq.n	801a142 <time+0x56>
    {
        if (rt_device_open(device, 0) == RT_EOK)
 801a114:	4b10      	ldr	r3, [pc, #64]	; (801a158 <time+0x6c>)
 801a116:	681b      	ldr	r3, [r3, #0]
 801a118:	4618      	mov	r0, r3
 801a11a:	2100      	movs	r1, #0
 801a11c:	f7fb f9a6 	bl	801546c <rt_device_open>
 801a120:	4603      	mov	r3, r0
 801a122:	2b00      	cmp	r3, #0
 801a124:	d10d      	bne.n	801a142 <time+0x56>
        {
            rt_device_control(device, RT_DEVICE_CTRL_RTC_GET_TIME, &time_now);
 801a126:	4b0c      	ldr	r3, [pc, #48]	; (801a158 <time+0x6c>)
 801a128:	681a      	ldr	r2, [r3, #0]
 801a12a:	f107 030c 	add.w	r3, r7, #12
 801a12e:	4610      	mov	r0, r2
 801a130:	2110      	movs	r1, #16
 801a132:	461a      	mov	r2, r3
 801a134:	f7fb fab4 	bl	80156a0 <rt_device_control>
            rt_device_close(device);
 801a138:	4b07      	ldr	r3, [pc, #28]	; (801a158 <time+0x6c>)
 801a13a:	681b      	ldr	r3, [r3, #0]
 801a13c:	4618      	mov	r0, r3
 801a13e:	f7fb fa09 	bl	8015554 <rt_device_close>
        }
    }

    /* if t is not NULL, write timestamp to *t */
    if (t != RT_NULL)
 801a142:	687b      	ldr	r3, [r7, #4]
 801a144:	2b00      	cmp	r3, #0
 801a146:	d002      	beq.n	801a14e <time+0x62>
    {
        *t = time_now;
 801a148:	68fa      	ldr	r2, [r7, #12]
 801a14a:	687b      	ldr	r3, [r7, #4]
 801a14c:	601a      	str	r2, [r3, #0]
    }

    return time_now;
 801a14e:	68fb      	ldr	r3, [r7, #12]
}
 801a150:	4618      	mov	r0, r3
 801a152:	3710      	adds	r7, #16
 801a154:	46bd      	mov	sp, r7
 801a156:	bd80      	pop	{r7, pc}
 801a158:	200110a8 	.word	0x200110a8
 801a15c:	08029734 	.word	0x08029734

0801a160 <set_date>:
 * \param rt_uint32_t day   e.g: e.g: 31.
 * \return rt_err_t if set success, return RT_EOK.
 *
 */
rt_err_t set_date(rt_uint32_t year, rt_uint32_t month, rt_uint32_t day)
{
 801a160:	b580      	push	{r7, lr}
 801a162:	b092      	sub	sp, #72	; 0x48
 801a164:	af00      	add	r7, sp, #0
 801a166:	60f8      	str	r0, [r7, #12]
 801a168:	60b9      	str	r1, [r7, #8]
 801a16a:	607a      	str	r2, [r7, #4]
    time_t now;
    struct tm *p_tm;
    struct tm tm_new;
    rt_device_t device;
    rt_err_t ret = -RT_ERROR;
 801a16c:	f04f 33ff 	mov.w	r3, #4294967295
 801a170:	647b      	str	r3, [r7, #68]	; 0x44

    /* get current time */
    now = time(RT_NULL);
 801a172:	2000      	movs	r0, #0
 801a174:	f7ff ffba 	bl	801a0ec <time>
 801a178:	4603      	mov	r3, r0
 801a17a:	63bb      	str	r3, [r7, #56]	; 0x38

    /* lock scheduler. */
    rt_enter_critical();
 801a17c:	f7fe f81c 	bl	80181b8 <rt_enter_critical>
    /* converts calendar time time into local time. */
    p_tm = localtime(&now);
 801a180:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801a184:	4618      	mov	r0, r3
 801a186:	f008 f937 	bl	80223f8 <localtime>
 801a18a:	6438      	str	r0, [r7, #64]	; 0x40
    /* copy the statically located variable */
    memcpy(&tm_new, p_tm, sizeof(struct tm));
 801a18c:	f107 0314 	add.w	r3, r7, #20
 801a190:	4618      	mov	r0, r3
 801a192:	6c39      	ldr	r1, [r7, #64]	; 0x40
 801a194:	2224      	movs	r2, #36	; 0x24
 801a196:	f7e6 f8a3 	bl	80002e0 <memcpy>
    /* unlock scheduler. */
    rt_exit_critical();
 801a19a:	f7fe f821 	bl	80181e0 <rt_exit_critical>

    /* update date. */
    tm_new.tm_year = year - 1900;
 801a19e:	68fb      	ldr	r3, [r7, #12]
 801a1a0:	f2a3 736c 	subw	r3, r3, #1900	; 0x76c
 801a1a4:	62bb      	str	r3, [r7, #40]	; 0x28
    tm_new.tm_mon  = month - 1; /* tm_mon: 0~11 */
 801a1a6:	68bb      	ldr	r3, [r7, #8]
 801a1a8:	3b01      	subs	r3, #1
 801a1aa:	627b      	str	r3, [r7, #36]	; 0x24
    tm_new.tm_mday = day;
 801a1ac:	687b      	ldr	r3, [r7, #4]
 801a1ae:	623b      	str	r3, [r7, #32]

    /* converts the local time in time to calendar time. */
    now = mktime(&tm_new);
 801a1b0:	f107 0314 	add.w	r3, r7, #20
 801a1b4:	4618      	mov	r0, r3
 801a1b6:	f008 fbb5 	bl	8022924 <mktime>
 801a1ba:	4603      	mov	r3, r0
 801a1bc:	63bb      	str	r3, [r7, #56]	; 0x38

    device = rt_device_find("rtc");
 801a1be:	480b      	ldr	r0, [pc, #44]	; (801a1ec <set_date+0x8c>)
 801a1c0:	f7fb f918 	bl	80153f4 <rt_device_find>
 801a1c4:	63f8      	str	r0, [r7, #60]	; 0x3c
    if (device == RT_NULL)
 801a1c6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a1c8:	2b00      	cmp	r3, #0
 801a1ca:	d102      	bne.n	801a1d2 <set_date+0x72>
    {
        return -RT_ERROR;
 801a1cc:	f04f 33ff 	mov.w	r3, #4294967295
 801a1d0:	e008      	b.n	801a1e4 <set_date+0x84>
    }

    /* update to RTC device. */
    ret = rt_device_control(device, RT_DEVICE_CTRL_RTC_SET_TIME, &now);
 801a1d2:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801a1d6:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 801a1d8:	2111      	movs	r1, #17
 801a1da:	461a      	mov	r2, r3
 801a1dc:	f7fb fa60 	bl	80156a0 <rt_device_control>
 801a1e0:	6478      	str	r0, [r7, #68]	; 0x44

    return ret;
 801a1e2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 801a1e4:	4618      	mov	r0, r3
 801a1e6:	3748      	adds	r7, #72	; 0x48
 801a1e8:	46bd      	mov	sp, r7
 801a1ea:	bd80      	pop	{r7, pc}
 801a1ec:	08029734 	.word	0x08029734

0801a1f0 <set_time>:
 * \param rt_uint32_t second e.g: 0~59.
 * \return rt_err_t if set success, return RT_EOK.
 *
 */
rt_err_t set_time(rt_uint32_t hour, rt_uint32_t minute, rt_uint32_t second)
{
 801a1f0:	b580      	push	{r7, lr}
 801a1f2:	b092      	sub	sp, #72	; 0x48
 801a1f4:	af00      	add	r7, sp, #0
 801a1f6:	60f8      	str	r0, [r7, #12]
 801a1f8:	60b9      	str	r1, [r7, #8]
 801a1fa:	607a      	str	r2, [r7, #4]
    time_t now;
    struct tm *p_tm;
    struct tm tm_new;
    rt_device_t device;
    rt_err_t ret = -RT_ERROR;
 801a1fc:	f04f 33ff 	mov.w	r3, #4294967295
 801a200:	647b      	str	r3, [r7, #68]	; 0x44

    /* get current time */
    now = time(RT_NULL);
 801a202:	2000      	movs	r0, #0
 801a204:	f7ff ff72 	bl	801a0ec <time>
 801a208:	4603      	mov	r3, r0
 801a20a:	63bb      	str	r3, [r7, #56]	; 0x38

    /* lock scheduler. */
    rt_enter_critical();
 801a20c:	f7fd ffd4 	bl	80181b8 <rt_enter_critical>
    /* converts calendar time time into local time. */
    p_tm = localtime(&now);
 801a210:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801a214:	4618      	mov	r0, r3
 801a216:	f008 f8ef 	bl	80223f8 <localtime>
 801a21a:	6438      	str	r0, [r7, #64]	; 0x40
    /* copy the statically located variable */
    memcpy(&tm_new, p_tm, sizeof(struct tm));
 801a21c:	f107 0314 	add.w	r3, r7, #20
 801a220:	4618      	mov	r0, r3
 801a222:	6c39      	ldr	r1, [r7, #64]	; 0x40
 801a224:	2224      	movs	r2, #36	; 0x24
 801a226:	f7e6 f85b 	bl	80002e0 <memcpy>
    /* unlock scheduler. */
    rt_exit_critical();
 801a22a:	f7fd ffd9 	bl	80181e0 <rt_exit_critical>

    /* update time. */
    tm_new.tm_hour = hour;
 801a22e:	68fb      	ldr	r3, [r7, #12]
 801a230:	61fb      	str	r3, [r7, #28]
    tm_new.tm_min  = minute;
 801a232:	68bb      	ldr	r3, [r7, #8]
 801a234:	61bb      	str	r3, [r7, #24]
    tm_new.tm_sec  = second;
 801a236:	687b      	ldr	r3, [r7, #4]
 801a238:	617b      	str	r3, [r7, #20]

    /* converts the local time in time to calendar time. */
    now = mktime(&tm_new);
 801a23a:	f107 0314 	add.w	r3, r7, #20
 801a23e:	4618      	mov	r0, r3
 801a240:	f008 fb70 	bl	8022924 <mktime>
 801a244:	4603      	mov	r3, r0
 801a246:	63bb      	str	r3, [r7, #56]	; 0x38

    device = rt_device_find("rtc");
 801a248:	480b      	ldr	r0, [pc, #44]	; (801a278 <set_time+0x88>)
 801a24a:	f7fb f8d3 	bl	80153f4 <rt_device_find>
 801a24e:	63f8      	str	r0, [r7, #60]	; 0x3c
    if (device == RT_NULL)
 801a250:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a252:	2b00      	cmp	r3, #0
 801a254:	d102      	bne.n	801a25c <set_time+0x6c>
    {
        return -RT_ERROR;
 801a256:	f04f 33ff 	mov.w	r3, #4294967295
 801a25a:	e008      	b.n	801a26e <set_time+0x7e>
    }

    /* update to RTC device. */
    ret = rt_device_control(device, RT_DEVICE_CTRL_RTC_SET_TIME, &now);
 801a25c:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801a260:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 801a262:	2111      	movs	r1, #17
 801a264:	461a      	mov	r2, r3
 801a266:	f7fb fa1b 	bl	80156a0 <rt_device_control>
 801a26a:	6478      	str	r0, [r7, #68]	; 0x44

    return ret;
 801a26c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 801a26e:	4618      	mov	r0, r3
 801a270:	3748      	adds	r7, #72	; 0x48
 801a272:	46bd      	mov	sp, r7
 801a274:	bd80      	pop	{r7, pc}
 801a276:	bf00      	nop
 801a278:	08029734 	.word	0x08029734

0801a27c <list_date>:
#ifdef RT_USING_FINSH
#include <finsh.h>
#include <rtdevice.h>

void list_date(void)
{
 801a27c:	b580      	push	{r7, lr}
 801a27e:	b082      	sub	sp, #8
 801a280:	af00      	add	r7, sp, #0
    time_t now;

    now = time(RT_NULL);
 801a282:	2000      	movs	r0, #0
 801a284:	f7ff ff32 	bl	801a0ec <time>
 801a288:	4603      	mov	r3, r0
 801a28a:	607b      	str	r3, [r7, #4]
    rt_kprintf("%s\n", ctime(&now));
 801a28c:	1d3b      	adds	r3, r7, #4
 801a28e:	4618      	mov	r0, r3
 801a290:	f008 f8aa 	bl	80223e8 <ctime>
 801a294:	4603      	mov	r3, r0
 801a296:	4803      	ldr	r0, [pc, #12]	; (801a2a4 <list_date+0x28>)
 801a298:	4619      	mov	r1, r3
 801a29a:	f7fc ff39 	bl	8017110 <rt_kprintf>
}
 801a29e:	3708      	adds	r7, #8
 801a2a0:	46bd      	mov	sp, r7
 801a2a2:	bd80      	pop	{r7, pc}
 801a2a4:	08029738 	.word	0x08029738

0801a2a8 <_serial_poll_rx>:

/*
 * Serial poll routines 
 */
rt_inline int _serial_poll_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
 801a2a8:	b580      	push	{r7, lr}
 801a2aa:	b086      	sub	sp, #24
 801a2ac:	af00      	add	r7, sp, #0
 801a2ae:	60f8      	str	r0, [r7, #12]
 801a2b0:	60b9      	str	r1, [r7, #8]
 801a2b2:	607a      	str	r2, [r7, #4]
    int ch;
    int size;
    
    RT_ASSERT(serial != RT_NULL);
 801a2b4:	68fb      	ldr	r3, [r7, #12]
 801a2b6:	2b00      	cmp	r3, #0
 801a2b8:	d104      	bne.n	801a2c4 <_serial_poll_rx+0x1c>
 801a2ba:	4813      	ldr	r0, [pc, #76]	; (801a308 <_serial_poll_rx+0x60>)
 801a2bc:	4913      	ldr	r1, [pc, #76]	; (801a30c <_serial_poll_rx+0x64>)
 801a2be:	222e      	movs	r2, #46	; 0x2e
 801a2c0:	f7fc ffa0 	bl	8017204 <rt_assert_handler>
    size = length;
 801a2c4:	687b      	ldr	r3, [r7, #4]
 801a2c6:	617b      	str	r3, [r7, #20]

    while (length)
 801a2c8:	e013      	b.n	801a2f2 <_serial_poll_rx+0x4a>
    {
        ch = serial->ops->getc(serial);
 801a2ca:	68fb      	ldr	r3, [r7, #12]
 801a2cc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a2ce:	68db      	ldr	r3, [r3, #12]
 801a2d0:	68f8      	ldr	r0, [r7, #12]
 801a2d2:	4798      	blx	r3
 801a2d4:	6138      	str	r0, [r7, #16]
        *data = ch; 
 801a2d6:	693b      	ldr	r3, [r7, #16]
 801a2d8:	b2da      	uxtb	r2, r3
 801a2da:	68bb      	ldr	r3, [r7, #8]
 801a2dc:	701a      	strb	r2, [r3, #0]
        data ++; length --;
 801a2de:	68bb      	ldr	r3, [r7, #8]
 801a2e0:	3301      	adds	r3, #1
 801a2e2:	60bb      	str	r3, [r7, #8]
 801a2e4:	687b      	ldr	r3, [r7, #4]
 801a2e6:	3b01      	subs	r3, #1
 801a2e8:	607b      	str	r3, [r7, #4]

        if (ch == '\n') break;
 801a2ea:	693b      	ldr	r3, [r7, #16]
 801a2ec:	2b0a      	cmp	r3, #10
 801a2ee:	d100      	bne.n	801a2f2 <_serial_poll_rx+0x4a>
 801a2f0:	e002      	b.n	801a2f8 <_serial_poll_rx+0x50>
    int size;
    
    RT_ASSERT(serial != RT_NULL);
    size = length;

    while (length)
 801a2f2:	687b      	ldr	r3, [r7, #4]
 801a2f4:	2b00      	cmp	r3, #0
 801a2f6:	d1e8      	bne.n	801a2ca <_serial_poll_rx+0x22>
        data ++; length --;

        if (ch == '\n') break;
    }

    return size - length;
 801a2f8:	697a      	ldr	r2, [r7, #20]
 801a2fa:	687b      	ldr	r3, [r7, #4]
 801a2fc:	1ad3      	subs	r3, r2, r3
}
 801a2fe:	4618      	mov	r0, r3
 801a300:	3718      	adds	r7, #24
 801a302:	46bd      	mov	sp, r7
 801a304:	bd80      	pop	{r7, pc}
 801a306:	bf00      	nop
 801a308:	0802973c 	.word	0x0802973c
 801a30c:	0802add0 	.word	0x0802add0

0801a310 <_serial_poll_tx>:

rt_inline int _serial_poll_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
 801a310:	b580      	push	{r7, lr}
 801a312:	b086      	sub	sp, #24
 801a314:	af00      	add	r7, sp, #0
 801a316:	60f8      	str	r0, [r7, #12]
 801a318:	60b9      	str	r1, [r7, #8]
 801a31a:	607a      	str	r2, [r7, #4]
    int size;
    RT_ASSERT(serial != RT_NULL);
 801a31c:	68fb      	ldr	r3, [r7, #12]
 801a31e:	2b00      	cmp	r3, #0
 801a320:	d104      	bne.n	801a32c <_serial_poll_tx+0x1c>
 801a322:	4818      	ldr	r0, [pc, #96]	; (801a384 <_serial_poll_tx+0x74>)
 801a324:	4918      	ldr	r1, [pc, #96]	; (801a388 <_serial_poll_tx+0x78>)
 801a326:	2240      	movs	r2, #64	; 0x40
 801a328:	f7fc ff6c 	bl	8017204 <rt_assert_handler>

    size = length;
 801a32c:	687b      	ldr	r3, [r7, #4]
 801a32e:	617b      	str	r3, [r7, #20]
    while (length)
 801a330:	e01d      	b.n	801a36e <_serial_poll_tx+0x5e>
    {
        /*
         * to be polite with serial console add a line feed
         * to the carriage return character
         */
        if (*data == '\n' && (serial->parent.open_flag & RT_DEVICE_FLAG_STREAM))
 801a332:	68bb      	ldr	r3, [r7, #8]
 801a334:	781b      	ldrb	r3, [r3, #0]
 801a336:	2b0a      	cmp	r3, #10
 801a338:	d10b      	bne.n	801a352 <_serial_poll_tx+0x42>
 801a33a:	68fb      	ldr	r3, [r7, #12]
 801a33c:	8b1b      	ldrh	r3, [r3, #24]
 801a33e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801a342:	2b00      	cmp	r3, #0
 801a344:	d005      	beq.n	801a352 <_serial_poll_tx+0x42>
        {
            serial->ops->putc(serial, '\r');
 801a346:	68fb      	ldr	r3, [r7, #12]
 801a348:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a34a:	689b      	ldr	r3, [r3, #8]
 801a34c:	68f8      	ldr	r0, [r7, #12]
 801a34e:	210d      	movs	r1, #13
 801a350:	4798      	blx	r3
        }
    
        serial->ops->putc(serial, *data);
 801a352:	68fb      	ldr	r3, [r7, #12]
 801a354:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a356:	689b      	ldr	r3, [r3, #8]
 801a358:	68ba      	ldr	r2, [r7, #8]
 801a35a:	7812      	ldrb	r2, [r2, #0]
 801a35c:	68f8      	ldr	r0, [r7, #12]
 801a35e:	4611      	mov	r1, r2
 801a360:	4798      	blx	r3
    
        ++ data;
 801a362:	68bb      	ldr	r3, [r7, #8]
 801a364:	3301      	adds	r3, #1
 801a366:	60bb      	str	r3, [r7, #8]
        -- length;
 801a368:	687b      	ldr	r3, [r7, #4]
 801a36a:	3b01      	subs	r3, #1
 801a36c:	607b      	str	r3, [r7, #4]
{
    int size;
    RT_ASSERT(serial != RT_NULL);

    size = length;
    while (length)
 801a36e:	687b      	ldr	r3, [r7, #4]
 801a370:	2b00      	cmp	r3, #0
 801a372:	d1de      	bne.n	801a332 <_serial_poll_tx+0x22>
    
        ++ data;
        -- length;
    }

    return size - length;
 801a374:	697a      	ldr	r2, [r7, #20]
 801a376:	687b      	ldr	r3, [r7, #4]
 801a378:	1ad3      	subs	r3, r2, r3
}
 801a37a:	4618      	mov	r0, r3
 801a37c:	3718      	adds	r7, #24
 801a37e:	46bd      	mov	sp, r7
 801a380:	bd80      	pop	{r7, pc}
 801a382:	bf00      	nop
 801a384:	0802973c 	.word	0x0802973c
 801a388:	0802ae00 	.word	0x0802ae00

0801a38c <_serial_int_rx>:

/*
 * Serial interrupt routines
 */
rt_inline int _serial_int_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
 801a38c:	b580      	push	{r7, lr}
 801a38e:	b088      	sub	sp, #32
 801a390:	af00      	add	r7, sp, #0
 801a392:	60f8      	str	r0, [r7, #12]
 801a394:	60b9      	str	r1, [r7, #8]
 801a396:	607a      	str	r2, [r7, #4]
    int size;
    struct rt_serial_rx_fifo* rx_fifo;

    RT_ASSERT(serial != RT_NULL);
 801a398:	68fb      	ldr	r3, [r7, #12]
 801a39a:	2b00      	cmp	r3, #0
 801a39c:	d104      	bne.n	801a3a8 <_serial_int_rx+0x1c>
 801a39e:	4828      	ldr	r0, [pc, #160]	; (801a440 <_serial_int_rx+0xb4>)
 801a3a0:	4928      	ldr	r1, [pc, #160]	; (801a444 <_serial_int_rx+0xb8>)
 801a3a2:	225f      	movs	r2, #95	; 0x5f
 801a3a4:	f7fc ff2e 	bl	8017204 <rt_assert_handler>
    size = length; 
 801a3a8:	687b      	ldr	r3, [r7, #4]
 801a3aa:	61fb      	str	r3, [r7, #28]
    
    rx_fifo = (struct rt_serial_rx_fifo*) serial->serial_rx;
 801a3ac:	68fb      	ldr	r3, [r7, #12]
 801a3ae:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801a3b0:	61bb      	str	r3, [r7, #24]
    RT_ASSERT(rx_fifo != RT_NULL);
 801a3b2:	69bb      	ldr	r3, [r7, #24]
 801a3b4:	2b00      	cmp	r3, #0
 801a3b6:	d104      	bne.n	801a3c2 <_serial_int_rx+0x36>
 801a3b8:	4823      	ldr	r0, [pc, #140]	; (801a448 <_serial_int_rx+0xbc>)
 801a3ba:	4922      	ldr	r1, [pc, #136]	; (801a444 <_serial_int_rx+0xb8>)
 801a3bc:	2263      	movs	r2, #99	; 0x63
 801a3be:	f7fc ff21 	bl	8017204 <rt_assert_handler>

    /* read from software FIFO */
    while (length)
 801a3c2:	e033      	b.n	801a42c <_serial_int_rx+0xa0>
    {
        int ch;
        rt_base_t level;

        /* disable interrupt */
        level = rt_hw_interrupt_disable();
 801a3c4:	f7e5 ff02 	bl	80001cc <rt_hw_interrupt_disable>
 801a3c8:	6178      	str	r0, [r7, #20]
        if (rx_fifo->get_index != rx_fifo->put_index)
 801a3ca:	69bb      	ldr	r3, [r7, #24]
 801a3cc:	88da      	ldrh	r2, [r3, #6]
 801a3ce:	69bb      	ldr	r3, [r7, #24]
 801a3d0:	889b      	ldrh	r3, [r3, #4]
 801a3d2:	429a      	cmp	r2, r3
 801a3d4:	d019      	beq.n	801a40a <_serial_int_rx+0x7e>
        {
            ch = rx_fifo->buffer[rx_fifo->get_index];
 801a3d6:	69bb      	ldr	r3, [r7, #24]
 801a3d8:	681b      	ldr	r3, [r3, #0]
 801a3da:	69ba      	ldr	r2, [r7, #24]
 801a3dc:	88d2      	ldrh	r2, [r2, #6]
 801a3de:	4413      	add	r3, r2
 801a3e0:	781b      	ldrb	r3, [r3, #0]
 801a3e2:	613b      	str	r3, [r7, #16]
            rx_fifo->get_index += 1;
 801a3e4:	69bb      	ldr	r3, [r7, #24]
 801a3e6:	88db      	ldrh	r3, [r3, #6]
 801a3e8:	3301      	adds	r3, #1
 801a3ea:	b29a      	uxth	r2, r3
 801a3ec:	69bb      	ldr	r3, [r7, #24]
 801a3ee:	80da      	strh	r2, [r3, #6]
            if (rx_fifo->get_index >= serial->config.bufsz) rx_fifo->get_index = 0;
 801a3f0:	69bb      	ldr	r3, [r7, #24]
 801a3f2:	88da      	ldrh	r2, [r3, #6]
 801a3f4:	68fb      	ldr	r3, [r7, #12]
 801a3f6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801a3f8:	f3c3 238f 	ubfx	r3, r3, #10, #16
 801a3fc:	b29b      	uxth	r3, r3
 801a3fe:	429a      	cmp	r2, r3
 801a400:	d307      	bcc.n	801a412 <_serial_int_rx+0x86>
 801a402:	69bb      	ldr	r3, [r7, #24]
 801a404:	2200      	movs	r2, #0
 801a406:	80da      	strh	r2, [r3, #6]
 801a408:	e003      	b.n	801a412 <_serial_int_rx+0x86>
        }
        else
        {
            /* no data, enable interrupt and break out */
            rt_hw_interrupt_enable(level);
 801a40a:	6978      	ldr	r0, [r7, #20]
 801a40c:	f7e5 fee2 	bl	80001d4 <rt_hw_interrupt_enable>
            break;
 801a410:	e00f      	b.n	801a432 <_serial_int_rx+0xa6>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 801a412:	6978      	ldr	r0, [r7, #20]
 801a414:	f7e5 fede 	bl	80001d4 <rt_hw_interrupt_enable>

        *data = ch & 0xff;
 801a418:	693b      	ldr	r3, [r7, #16]
 801a41a:	b2da      	uxtb	r2, r3
 801a41c:	68bb      	ldr	r3, [r7, #8]
 801a41e:	701a      	strb	r2, [r3, #0]
        data ++; length --;
 801a420:	68bb      	ldr	r3, [r7, #8]
 801a422:	3301      	adds	r3, #1
 801a424:	60bb      	str	r3, [r7, #8]
 801a426:	687b      	ldr	r3, [r7, #4]
 801a428:	3b01      	subs	r3, #1
 801a42a:	607b      	str	r3, [r7, #4]
    
    rx_fifo = (struct rt_serial_rx_fifo*) serial->serial_rx;
    RT_ASSERT(rx_fifo != RT_NULL);

    /* read from software FIFO */
    while (length)
 801a42c:	687b      	ldr	r3, [r7, #4]
 801a42e:	2b00      	cmp	r3, #0
 801a430:	d1c8      	bne.n	801a3c4 <_serial_int_rx+0x38>

        *data = ch & 0xff;
        data ++; length --;
    }

    return size - length;
 801a432:	69fa      	ldr	r2, [r7, #28]
 801a434:	687b      	ldr	r3, [r7, #4]
 801a436:	1ad3      	subs	r3, r2, r3
}
 801a438:	4618      	mov	r0, r3
 801a43a:	3720      	adds	r7, #32
 801a43c:	46bd      	mov	sp, r7
 801a43e:	bd80      	pop	{r7, pc}
 801a440:	0802973c 	.word	0x0802973c
 801a444:	0802adb0 	.word	0x0802adb0
 801a448:	08029750 	.word	0x08029750

0801a44c <_serial_int_tx>:

rt_inline int _serial_int_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
 801a44c:	b580      	push	{r7, lr}
 801a44e:	b086      	sub	sp, #24
 801a450:	af00      	add	r7, sp, #0
 801a452:	60f8      	str	r0, [r7, #12]
 801a454:	60b9      	str	r1, [r7, #8]
 801a456:	607a      	str	r2, [r7, #4]
    int size;
    struct rt_serial_tx_fifo *tx;
    
    RT_ASSERT(serial != RT_NULL);
 801a458:	68fb      	ldr	r3, [r7, #12]
 801a45a:	2b00      	cmp	r3, #0
 801a45c:	d104      	bne.n	801a468 <_serial_int_tx+0x1c>
 801a45e:	481b      	ldr	r0, [pc, #108]	; (801a4cc <_serial_int_tx+0x80>)
 801a460:	491b      	ldr	r1, [pc, #108]	; (801a4d0 <_serial_int_tx+0x84>)
 801a462:	2289      	movs	r2, #137	; 0x89
 801a464:	f7fc fece 	bl	8017204 <rt_assert_handler>

    size = length;
 801a468:	687b      	ldr	r3, [r7, #4]
 801a46a:	617b      	str	r3, [r7, #20]
    tx = (struct rt_serial_tx_fifo*) serial->serial_tx;
 801a46c:	68fb      	ldr	r3, [r7, #12]
 801a46e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a470:	613b      	str	r3, [r7, #16]
    RT_ASSERT(tx != RT_NULL);
 801a472:	693b      	ldr	r3, [r7, #16]
 801a474:	2b00      	cmp	r3, #0
 801a476:	d104      	bne.n	801a482 <_serial_int_tx+0x36>
 801a478:	4816      	ldr	r0, [pc, #88]	; (801a4d4 <_serial_int_tx+0x88>)
 801a47a:	4915      	ldr	r1, [pc, #84]	; (801a4d0 <_serial_int_tx+0x84>)
 801a47c:	228d      	movs	r2, #141	; 0x8d
 801a47e:	f7fc fec1 	bl	8017204 <rt_assert_handler>

    while (length)
 801a482:	e018      	b.n	801a4b6 <_serial_int_tx+0x6a>
    {
        if (serial->ops->putc(serial, *(char*)data) == -1)
 801a484:	68fb      	ldr	r3, [r7, #12]
 801a486:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a488:	689b      	ldr	r3, [r3, #8]
 801a48a:	68ba      	ldr	r2, [r7, #8]
 801a48c:	7812      	ldrb	r2, [r2, #0]
 801a48e:	68f8      	ldr	r0, [r7, #12]
 801a490:	4611      	mov	r1, r2
 801a492:	4798      	blx	r3
 801a494:	4603      	mov	r3, r0
 801a496:	f1b3 3fff 	cmp.w	r3, #4294967295
 801a49a:	d106      	bne.n	801a4aa <_serial_int_tx+0x5e>
        {
            rt_completion_wait(&(tx->completion), RT_WAITING_FOREVER);
 801a49c:	693b      	ldr	r3, [r7, #16]
 801a49e:	4618      	mov	r0, r3
 801a4a0:	f04f 31ff 	mov.w	r1, #4294967295
 801a4a4:	f7ff f876 	bl	8019594 <rt_completion_wait>
            continue;
 801a4a8:	e005      	b.n	801a4b6 <_serial_int_tx+0x6a>
        }

        data ++; length --;
 801a4aa:	68bb      	ldr	r3, [r7, #8]
 801a4ac:	3301      	adds	r3, #1
 801a4ae:	60bb      	str	r3, [r7, #8]
 801a4b0:	687b      	ldr	r3, [r7, #4]
 801a4b2:	3b01      	subs	r3, #1
 801a4b4:	607b      	str	r3, [r7, #4]

    size = length;
    tx = (struct rt_serial_tx_fifo*) serial->serial_tx;
    RT_ASSERT(tx != RT_NULL);

    while (length)
 801a4b6:	687b      	ldr	r3, [r7, #4]
 801a4b8:	2b00      	cmp	r3, #0
 801a4ba:	d1e3      	bne.n	801a484 <_serial_int_tx+0x38>
        }

        data ++; length --;
    }

    return size - length;
 801a4bc:	697a      	ldr	r2, [r7, #20]
 801a4be:	687b      	ldr	r3, [r7, #4]
 801a4c0:	1ad3      	subs	r3, r2, r3
}
 801a4c2:	4618      	mov	r0, r3
 801a4c4:	3718      	adds	r7, #24
 801a4c6:	46bd      	mov	sp, r7
 801a4c8:	bd80      	pop	{r7, pc}
 801a4ca:	bf00      	nop
 801a4cc:	0802973c 	.word	0x0802973c
 801a4d0:	0802adf0 	.word	0x0802adf0
 801a4d4:	08029764 	.word	0x08029764

0801a4d8 <_serial_dma_rx>:

/*
 * Serial DMA routines
 */
rt_inline int _serial_dma_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
 801a4d8:	b590      	push	{r4, r7, lr}
 801a4da:	b089      	sub	sp, #36	; 0x24
 801a4dc:	af00      	add	r7, sp, #0
 801a4de:	60f8      	str	r0, [r7, #12]
 801a4e0:	60b9      	str	r1, [r7, #8]
 801a4e2:	607a      	str	r2, [r7, #4]
    rt_base_t level;
    int result = RT_EOK;
 801a4e4:	2300      	movs	r3, #0
 801a4e6:	61fb      	str	r3, [r7, #28]
    struct rt_serial_rx_dma *rx_dma;

    RT_ASSERT((serial != RT_NULL) && (data != RT_NULL));
 801a4e8:	68fb      	ldr	r3, [r7, #12]
 801a4ea:	2b00      	cmp	r3, #0
 801a4ec:	d002      	beq.n	801a4f4 <_serial_dma_rx+0x1c>
 801a4ee:	68bb      	ldr	r3, [r7, #8]
 801a4f0:	2b00      	cmp	r3, #0
 801a4f2:	d104      	bne.n	801a4fe <_serial_dma_rx+0x26>
 801a4f4:	4815      	ldr	r0, [pc, #84]	; (801a54c <_serial_dma_rx+0x74>)
 801a4f6:	4916      	ldr	r1, [pc, #88]	; (801a550 <_serial_dma_rx+0x78>)
 801a4f8:	22a6      	movs	r2, #166	; 0xa6
 801a4fa:	f7fc fe83 	bl	8017204 <rt_assert_handler>
    rx_dma = (struct rt_serial_rx_dma*)serial->serial_rx;
 801a4fe:	68fb      	ldr	r3, [r7, #12]
 801a500:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801a502:	61bb      	str	r3, [r7, #24]
    RT_ASSERT(rx_dma != RT_NULL);
 801a504:	69bb      	ldr	r3, [r7, #24]
 801a506:	2b00      	cmp	r3, #0
 801a508:	d104      	bne.n	801a514 <_serial_dma_rx+0x3c>
 801a50a:	4812      	ldr	r0, [pc, #72]	; (801a554 <_serial_dma_rx+0x7c>)
 801a50c:	4910      	ldr	r1, [pc, #64]	; (801a550 <_serial_dma_rx+0x78>)
 801a50e:	22a8      	movs	r2, #168	; 0xa8
 801a510:	f7fc fe78 	bl	8017204 <rt_assert_handler>
    level = rt_hw_interrupt_disable();
 801a514:	f7e5 fe5a 	bl	80001cc <rt_hw_interrupt_disable>
 801a518:	6178      	str	r0, [r7, #20]
    //if (rx_dma->activated != RT_TRUE)
    //{
        //rx_dma->activated = RT_TRUE;
        serial->ops->dma_transmit(serial, data, length, RT_SERIAL_DMA_RX);
 801a51a:	68fb      	ldr	r3, [r7, #12]
 801a51c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a51e:	691c      	ldr	r4, [r3, #16]
 801a520:	687b      	ldr	r3, [r7, #4]
 801a522:	68f8      	ldr	r0, [r7, #12]
 801a524:	68b9      	ldr	r1, [r7, #8]
 801a526:	461a      	mov	r2, r3
 801a528:	2301      	movs	r3, #1
 801a52a:	47a0      	blx	r4
    //}
    //else result = -RT_EBUSY;
    rt_hw_interrupt_enable(level);
 801a52c:	6978      	ldr	r0, [r7, #20]
 801a52e:	f7e5 fe51 	bl	80001d4 <rt_hw_interrupt_enable>

    if (result == RT_EOK) return length;
 801a532:	69fb      	ldr	r3, [r7, #28]
 801a534:	2b00      	cmp	r3, #0
 801a536:	d101      	bne.n	801a53c <_serial_dma_rx+0x64>
 801a538:	687b      	ldr	r3, [r7, #4]
 801a53a:	e003      	b.n	801a544 <_serial_dma_rx+0x6c>

    rt_set_errno(result);
 801a53c:	69f8      	ldr	r0, [r7, #28]
 801a53e:	f7fc f80f 	bl	8016560 <rt_set_errno>
    return 0;
 801a542:	2300      	movs	r3, #0
}
 801a544:	4618      	mov	r0, r3
 801a546:	3724      	adds	r7, #36	; 0x24
 801a548:	46bd      	mov	sp, r7
 801a54a:	bd90      	pop	{r4, r7, pc}
 801a54c:	08029774 	.word	0x08029774
 801a550:	0802adc0 	.word	0x0802adc0
 801a554:	080297a0 	.word	0x080297a0

0801a558 <_serial_dma_tx>:

rt_inline int _serial_dma_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
 801a558:	b590      	push	{r4, r7, lr}
 801a55a:	b089      	sub	sp, #36	; 0x24
 801a55c:	af00      	add	r7, sp, #0
 801a55e:	60f8      	str	r0, [r7, #12]
 801a560:	60b9      	str	r1, [r7, #8]
 801a562:	607a      	str	r2, [r7, #4]
    rt_base_t level;
    rt_err_t result;
    struct rt_serial_tx_dma *tx_dma;

    tx_dma = (struct rt_serial_tx_dma*)(serial->serial_tx);
 801a564:	68fb      	ldr	r3, [r7, #12]
 801a566:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a568:	61fb      	str	r3, [r7, #28]
    
    result = rt_data_queue_push(&(tx_dma->data_queue), data, length, RT_WAITING_FOREVER); 
 801a56a:	69fb      	ldr	r3, [r7, #28]
 801a56c:	1d1a      	adds	r2, r3, #4
 801a56e:	687b      	ldr	r3, [r7, #4]
 801a570:	4610      	mov	r0, r2
 801a572:	68b9      	ldr	r1, [r7, #8]
 801a574:	461a      	mov	r2, r3
 801a576:	f04f 33ff 	mov.w	r3, #4294967295
 801a57a:	f7ff f941 	bl	8019800 <rt_data_queue_push>
 801a57e:	61b8      	str	r0, [r7, #24]
    if (result == RT_EOK)
 801a580:	69bb      	ldr	r3, [r7, #24]
 801a582:	2b00      	cmp	r3, #0
 801a584:	d11b      	bne.n	801a5be <_serial_dma_tx+0x66>
    {
        level = rt_hw_interrupt_disable();
 801a586:	f7e5 fe21 	bl	80001cc <rt_hw_interrupt_disable>
 801a58a:	6178      	str	r0, [r7, #20]
        if (tx_dma->activated != RT_TRUE)
 801a58c:	69fb      	ldr	r3, [r7, #28]
 801a58e:	681b      	ldr	r3, [r3, #0]
 801a590:	2b01      	cmp	r3, #1
 801a592:	d00f      	beq.n	801a5b4 <_serial_dma_tx+0x5c>
        {
            tx_dma->activated = RT_TRUE;
 801a594:	69fb      	ldr	r3, [r7, #28]
 801a596:	2201      	movs	r2, #1
 801a598:	601a      	str	r2, [r3, #0]
            rt_hw_interrupt_enable(level);
 801a59a:	6978      	ldr	r0, [r7, #20]
 801a59c:	f7e5 fe1a 	bl	80001d4 <rt_hw_interrupt_enable>

            /* make a DMA transfer */
            serial->ops->dma_transmit(serial, data, length, RT_SERIAL_DMA_TX);
 801a5a0:	68fb      	ldr	r3, [r7, #12]
 801a5a2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a5a4:	691c      	ldr	r4, [r3, #16]
 801a5a6:	687b      	ldr	r3, [r7, #4]
 801a5a8:	68f8      	ldr	r0, [r7, #12]
 801a5aa:	68b9      	ldr	r1, [r7, #8]
 801a5ac:	461a      	mov	r2, r3
 801a5ae:	2302      	movs	r3, #2
 801a5b0:	47a0      	blx	r4
 801a5b2:	e002      	b.n	801a5ba <_serial_dma_tx+0x62>
        }
        else
        {
            rt_hw_interrupt_enable(level);
 801a5b4:	6978      	ldr	r0, [r7, #20]
 801a5b6:	f7e5 fe0d 	bl	80001d4 <rt_hw_interrupt_enable>
        }

        return length;
 801a5ba:	687b      	ldr	r3, [r7, #4]
 801a5bc:	e003      	b.n	801a5c6 <_serial_dma_tx+0x6e>
    }
    else
    {
        rt_set_errno(result);
 801a5be:	69b8      	ldr	r0, [r7, #24]
 801a5c0:	f7fb ffce 	bl	8016560 <rt_set_errno>
        return 0;
 801a5c4:	2300      	movs	r3, #0
    }
}
 801a5c6:	4618      	mov	r0, r3
 801a5c8:	3724      	adds	r7, #36	; 0x24
 801a5ca:	46bd      	mov	sp, r7
 801a5cc:	bd90      	pop	{r4, r7, pc}
 801a5ce:	bf00      	nop

0801a5d0 <rt_serial_init>:
/* RT-Thread Device Interface */
/*
 * This function initializes serial device.
 */
static rt_err_t rt_serial_init(struct rt_device *dev)
{
 801a5d0:	b580      	push	{r7, lr}
 801a5d2:	b084      	sub	sp, #16
 801a5d4:	af00      	add	r7, sp, #0
 801a5d6:	6078      	str	r0, [r7, #4]
    rt_err_t result = RT_EOK;
 801a5d8:	2300      	movs	r3, #0
 801a5da:	60fb      	str	r3, [r7, #12]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
 801a5dc:	687b      	ldr	r3, [r7, #4]
 801a5de:	2b00      	cmp	r3, #0
 801a5e0:	d104      	bne.n	801a5ec <rt_serial_init+0x1c>
 801a5e2:	4812      	ldr	r0, [pc, #72]	; (801a62c <rt_serial_init+0x5c>)
 801a5e4:	4912      	ldr	r1, [pc, #72]	; (801a630 <rt_serial_init+0x60>)
 801a5e6:	22e3      	movs	r2, #227	; 0xe3
 801a5e8:	f7fc fe0c 	bl	8017204 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
 801a5ec:	687b      	ldr	r3, [r7, #4]
 801a5ee:	60bb      	str	r3, [r7, #8]

    /* initialize rx/tx */
    serial->serial_rx = RT_NULL;
 801a5f0:	68bb      	ldr	r3, [r7, #8]
 801a5f2:	2200      	movs	r2, #0
 801a5f4:	64da      	str	r2, [r3, #76]	; 0x4c
    serial->serial_tx = RT_NULL;
 801a5f6:	68bb      	ldr	r3, [r7, #8]
 801a5f8:	2200      	movs	r2, #0
 801a5fa:	651a      	str	r2, [r3, #80]	; 0x50

    /* apply configuration */
    if (serial->ops->configure)
 801a5fc:	68bb      	ldr	r3, [r7, #8]
 801a5fe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a600:	681b      	ldr	r3, [r3, #0]
 801a602:	2b00      	cmp	r3, #0
 801a604:	d008      	beq.n	801a618 <rt_serial_init+0x48>
        result = serial->ops->configure(serial, &serial->config);
 801a606:	68bb      	ldr	r3, [r7, #8]
 801a608:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a60a:	681b      	ldr	r3, [r3, #0]
 801a60c:	68ba      	ldr	r2, [r7, #8]
 801a60e:	3244      	adds	r2, #68	; 0x44
 801a610:	68b8      	ldr	r0, [r7, #8]
 801a612:	4611      	mov	r1, r2
 801a614:	4798      	blx	r3
 801a616:	60f8      	str	r0, [r7, #12]
	rt_kprintf("%x\r\n", result);
 801a618:	4806      	ldr	r0, [pc, #24]	; (801a634 <rt_serial_init+0x64>)
 801a61a:	68f9      	ldr	r1, [r7, #12]
 801a61c:	f7fc fd78 	bl	8017110 <rt_kprintf>
    return result;
 801a620:	68fb      	ldr	r3, [r7, #12]
}
 801a622:	4618      	mov	r0, r3
 801a624:	3710      	adds	r7, #16
 801a626:	46bd      	mov	sp, r7
 801a628:	bd80      	pop	{r7, pc}
 801a62a:	bf00      	nop
 801a62c:	080297b4 	.word	0x080297b4
 801a630:	0802ad70 	.word	0x0802ad70
 801a634:	080297c4 	.word	0x080297c4

0801a638 <rt_serial_open>:

static rt_err_t rt_serial_open(struct rt_device *dev, rt_uint16_t oflag)
{
 801a638:	b580      	push	{r7, lr}
 801a63a:	b088      	sub	sp, #32
 801a63c:	af00      	add	r7, sp, #0
 801a63e:	6078      	str	r0, [r7, #4]
 801a640:	460b      	mov	r3, r1
 801a642:	807b      	strh	r3, [r7, #2]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
 801a644:	687b      	ldr	r3, [r7, #4]
 801a646:	2b00      	cmp	r3, #0
 801a648:	d104      	bne.n	801a654 <rt_serial_open+0x1c>
 801a64a:	4889      	ldr	r0, [pc, #548]	; (801a870 <rt_serial_open+0x238>)
 801a64c:	4989      	ldr	r1, [pc, #548]	; (801a874 <rt_serial_open+0x23c>)
 801a64e:	22f5      	movs	r2, #245	; 0xf5
 801a650:	f7fc fdd8 	bl	8017204 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
 801a654:	687b      	ldr	r3, [r7, #4]
 801a656:	61fb      	str	r3, [r7, #28]

    /* check device flag with the open flag */
    if ((oflag & RT_DEVICE_FLAG_DMA_RX) && !(dev->flag & RT_DEVICE_FLAG_DMA_RX)) 
 801a658:	887b      	ldrh	r3, [r7, #2]
 801a65a:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801a65e:	2b00      	cmp	r3, #0
 801a660:	d008      	beq.n	801a674 <rt_serial_open+0x3c>
 801a662:	687b      	ldr	r3, [r7, #4]
 801a664:	8adb      	ldrh	r3, [r3, #22]
 801a666:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801a66a:	2b00      	cmp	r3, #0
 801a66c:	d102      	bne.n	801a674 <rt_serial_open+0x3c>
        return -RT_EIO;
 801a66e:	f06f 0307 	mvn.w	r3, #7
 801a672:	e0f8      	b.n	801a866 <rt_serial_open+0x22e>
    if ((oflag & RT_DEVICE_FLAG_DMA_TX) && !(dev->flag & RT_DEVICE_FLAG_DMA_TX))
 801a674:	887b      	ldrh	r3, [r7, #2]
 801a676:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801a67a:	2b00      	cmp	r3, #0
 801a67c:	d008      	beq.n	801a690 <rt_serial_open+0x58>
 801a67e:	687b      	ldr	r3, [r7, #4]
 801a680:	8adb      	ldrh	r3, [r3, #22]
 801a682:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801a686:	2b00      	cmp	r3, #0
 801a688:	d102      	bne.n	801a690 <rt_serial_open+0x58>
        return -RT_EIO;
 801a68a:	f06f 0307 	mvn.w	r3, #7
 801a68e:	e0ea      	b.n	801a866 <rt_serial_open+0x22e>
    if ((oflag & RT_DEVICE_FLAG_INT_RX) && !(dev->flag & RT_DEVICE_FLAG_INT_RX))
 801a690:	887b      	ldrh	r3, [r7, #2]
 801a692:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801a696:	2b00      	cmp	r3, #0
 801a698:	d008      	beq.n	801a6ac <rt_serial_open+0x74>
 801a69a:	687b      	ldr	r3, [r7, #4]
 801a69c:	8adb      	ldrh	r3, [r3, #22]
 801a69e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801a6a2:	2b00      	cmp	r3, #0
 801a6a4:	d102      	bne.n	801a6ac <rt_serial_open+0x74>
        return -RT_EIO;
 801a6a6:	f06f 0307 	mvn.w	r3, #7
 801a6aa:	e0dc      	b.n	801a866 <rt_serial_open+0x22e>
    if ((oflag & RT_DEVICE_FLAG_INT_TX) && !(dev->flag & RT_DEVICE_FLAG_INT_TX))
 801a6ac:	887b      	ldrh	r3, [r7, #2]
 801a6ae:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801a6b2:	2b00      	cmp	r3, #0
 801a6b4:	d008      	beq.n	801a6c8 <rt_serial_open+0x90>
 801a6b6:	687b      	ldr	r3, [r7, #4]
 801a6b8:	8adb      	ldrh	r3, [r3, #22]
 801a6ba:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801a6be:	2b00      	cmp	r3, #0
 801a6c0:	d102      	bne.n	801a6c8 <rt_serial_open+0x90>
        return -RT_EIO;
 801a6c2:	f06f 0307 	mvn.w	r3, #7
 801a6c6:	e0ce      	b.n	801a866 <rt_serial_open+0x22e>

    /* get open flags */
    dev->open_flag = oflag & 0xff;
 801a6c8:	887b      	ldrh	r3, [r7, #2]
 801a6ca:	b2db      	uxtb	r3, r3
 801a6cc:	b29a      	uxth	r2, r3
 801a6ce:	687b      	ldr	r3, [r7, #4]
 801a6d0:	831a      	strh	r2, [r3, #24]
    
    /* initialize the Rx/Tx structure according to open flag */
    if (serial->serial_rx == RT_NULL)
 801a6d2:	69fb      	ldr	r3, [r7, #28]
 801a6d4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801a6d6:	2b00      	cmp	r3, #0
 801a6d8:	d16c      	bne.n	801a7b4 <rt_serial_open+0x17c>
    {
        if (oflag & RT_DEVICE_FLAG_DMA_RX)
 801a6da:	887b      	ldrh	r3, [r7, #2]
 801a6dc:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801a6e0:	2b00      	cmp	r3, #0
 801a6e2:	d022      	beq.n	801a72a <rt_serial_open+0xf2>
        {
            struct rt_serial_rx_dma* rx_dma;

            rx_dma = (struct rt_serial_rx_dma*) rt_malloc (sizeof(struct rt_serial_rx_dma));
 801a6e4:	2004      	movs	r0, #4
 801a6e6:	f7fc fec1 	bl	801746c <rt_malloc>
 801a6ea:	61b8      	str	r0, [r7, #24]
            RT_ASSERT(rx_dma != RT_NULL);
 801a6ec:	69bb      	ldr	r3, [r7, #24]
 801a6ee:	2b00      	cmp	r3, #0
 801a6f0:	d105      	bne.n	801a6fe <rt_serial_open+0xc6>
 801a6f2:	4861      	ldr	r0, [pc, #388]	; (801a878 <rt_serial_open+0x240>)
 801a6f4:	495f      	ldr	r1, [pc, #380]	; (801a874 <rt_serial_open+0x23c>)
 801a6f6:	f240 120d 	movw	r2, #269	; 0x10d
 801a6fa:	f7fc fd83 	bl	8017204 <rt_assert_handler>
            rx_dma->activated = RT_FALSE;
 801a6fe:	69bb      	ldr	r3, [r7, #24]
 801a700:	2200      	movs	r2, #0
 801a702:	601a      	str	r2, [r3, #0]

            serial->serial_rx = rx_dma;
 801a704:	69fb      	ldr	r3, [r7, #28]
 801a706:	69ba      	ldr	r2, [r7, #24]
 801a708:	64da      	str	r2, [r3, #76]	; 0x4c
            dev->open_flag |= RT_DEVICE_FLAG_DMA_RX;
 801a70a:	687b      	ldr	r3, [r7, #4]
 801a70c:	8b1b      	ldrh	r3, [r3, #24]
 801a70e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 801a712:	b29a      	uxth	r2, r3
 801a714:	687b      	ldr	r3, [r7, #4]
 801a716:	831a      	strh	r2, [r3, #24]
            serial->ops->control(serial, RT_DEVICE_CTRL_SET_DMARX, (void *)RT_DEVICE_FLAG_DMA_RX);
 801a718:	69fb      	ldr	r3, [r7, #28]
 801a71a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a71c:	685b      	ldr	r3, [r3, #4]
 801a71e:	69f8      	ldr	r0, [r7, #28]
 801a720:	2114      	movs	r1, #20
 801a722:	f44f 7200 	mov.w	r2, #512	; 0x200
 801a726:	4798      	blx	r3
 801a728:	e044      	b.n	801a7b4 <rt_serial_open+0x17c>
        }
        else if (oflag & RT_DEVICE_FLAG_INT_RX)
 801a72a:	887b      	ldrh	r3, [r7, #2]
 801a72c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801a730:	2b00      	cmp	r3, #0
 801a732:	d03c      	beq.n	801a7ae <rt_serial_open+0x176>
        {
            struct rt_serial_rx_fifo* rx_fifo;

            rx_fifo = (struct rt_serial_rx_fifo*) rt_malloc (sizeof(struct rt_serial_rx_fifo) + 
                serial->config.bufsz);
 801a734:	69fb      	ldr	r3, [r7, #28]
 801a736:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801a738:	f3c3 238f 	ubfx	r3, r3, #10, #16
 801a73c:	b29b      	uxth	r3, r3
        }
        else if (oflag & RT_DEVICE_FLAG_INT_RX)
        {
            struct rt_serial_rx_fifo* rx_fifo;

            rx_fifo = (struct rt_serial_rx_fifo*) rt_malloc (sizeof(struct rt_serial_rx_fifo) + 
 801a73e:	3308      	adds	r3, #8
 801a740:	4618      	mov	r0, r3
 801a742:	f7fc fe93 	bl	801746c <rt_malloc>
 801a746:	6178      	str	r0, [r7, #20]
                serial->config.bufsz);
            RT_ASSERT(rx_fifo != RT_NULL);
 801a748:	697b      	ldr	r3, [r7, #20]
 801a74a:	2b00      	cmp	r3, #0
 801a74c:	d105      	bne.n	801a75a <rt_serial_open+0x122>
 801a74e:	484b      	ldr	r0, [pc, #300]	; (801a87c <rt_serial_open+0x244>)
 801a750:	4948      	ldr	r1, [pc, #288]	; (801a874 <rt_serial_open+0x23c>)
 801a752:	f44f 728d 	mov.w	r2, #282	; 0x11a
 801a756:	f7fc fd55 	bl	8017204 <rt_assert_handler>
            rx_fifo->buffer = (rt_uint8_t*) (rx_fifo + 1);
 801a75a:	697b      	ldr	r3, [r7, #20]
 801a75c:	f103 0208 	add.w	r2, r3, #8
 801a760:	697b      	ldr	r3, [r7, #20]
 801a762:	601a      	str	r2, [r3, #0]
            rt_memset(rx_fifo->buffer, 0, serial->config.bufsz);
 801a764:	697b      	ldr	r3, [r7, #20]
 801a766:	681a      	ldr	r2, [r3, #0]
 801a768:	69fb      	ldr	r3, [r7, #28]
 801a76a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801a76c:	f3c3 238f 	ubfx	r3, r3, #10, #16
 801a770:	b29b      	uxth	r3, r3
 801a772:	4610      	mov	r0, r2
 801a774:	2100      	movs	r1, #0
 801a776:	461a      	mov	r2, r3
 801a778:	f7fb ff12 	bl	80165a0 <rt_memset>
            rx_fifo->put_index = 0;
 801a77c:	697b      	ldr	r3, [r7, #20]
 801a77e:	2200      	movs	r2, #0
 801a780:	809a      	strh	r2, [r3, #4]
            rx_fifo->get_index = 0;
 801a782:	697b      	ldr	r3, [r7, #20]
 801a784:	2200      	movs	r2, #0
 801a786:	80da      	strh	r2, [r3, #6]

            serial->serial_rx = rx_fifo;
 801a788:	69fb      	ldr	r3, [r7, #28]
 801a78a:	697a      	ldr	r2, [r7, #20]
 801a78c:	64da      	str	r2, [r3, #76]	; 0x4c
            dev->open_flag |= RT_DEVICE_FLAG_INT_RX;
 801a78e:	687b      	ldr	r3, [r7, #4]
 801a790:	8b1b      	ldrh	r3, [r3, #24]
 801a792:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 801a796:	b29a      	uxth	r2, r3
 801a798:	687b      	ldr	r3, [r7, #4]
 801a79a:	831a      	strh	r2, [r3, #24]
            /* configure low level device */
            serial->ops->control(serial, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_RX);
 801a79c:	69fb      	ldr	r3, [r7, #28]
 801a79e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a7a0:	685b      	ldr	r3, [r3, #4]
 801a7a2:	69f8      	ldr	r0, [r7, #28]
 801a7a4:	2110      	movs	r1, #16
 801a7a6:	f44f 7280 	mov.w	r2, #256	; 0x100
 801a7aa:	4798      	blx	r3
 801a7ac:	e002      	b.n	801a7b4 <rt_serial_open+0x17c>
        }
        else
        {
            serial->serial_rx = RT_NULL;
 801a7ae:	69fb      	ldr	r3, [r7, #28]
 801a7b0:	2200      	movs	r2, #0
 801a7b2:	64da      	str	r2, [r3, #76]	; 0x4c
        }
    }

    if (serial->serial_tx == RT_NULL)
 801a7b4:	69fb      	ldr	r3, [r7, #28]
 801a7b6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a7b8:	2b00      	cmp	r3, #0
 801a7ba:	d153      	bne.n	801a864 <rt_serial_open+0x22c>
    {
        if (oflag & RT_DEVICE_FLAG_DMA_TX)
 801a7bc:	887b      	ldrh	r3, [r7, #2]
 801a7be:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801a7c2:	2b00      	cmp	r3, #0
 801a7c4:	d022      	beq.n	801a80c <rt_serial_open+0x1d4>
        {
            struct rt_serial_tx_dma* tx_dma;

            tx_dma = (struct rt_serial_tx_dma*) rt_malloc (sizeof(struct rt_serial_tx_dma));
 801a7c6:	2028      	movs	r0, #40	; 0x28
 801a7c8:	f7fc fe50 	bl	801746c <rt_malloc>
 801a7cc:	6138      	str	r0, [r7, #16]
            RT_ASSERT(tx_dma != RT_NULL);
 801a7ce:	693b      	ldr	r3, [r7, #16]
 801a7d0:	2b00      	cmp	r3, #0
 801a7d2:	d105      	bne.n	801a7e0 <rt_serial_open+0x1a8>
 801a7d4:	482a      	ldr	r0, [pc, #168]	; (801a880 <rt_serial_open+0x248>)
 801a7d6:	4927      	ldr	r1, [pc, #156]	; (801a874 <rt_serial_open+0x23c>)
 801a7d8:	f44f 7299 	mov.w	r2, #306	; 0x132
 801a7dc:	f7fc fd12 	bl	8017204 <rt_assert_handler>
            tx_dma->activated = RT_FALSE;
 801a7e0:	693b      	ldr	r3, [r7, #16]
 801a7e2:	2200      	movs	r2, #0
 801a7e4:	601a      	str	r2, [r3, #0]
            
            rt_data_queue_init(&(tx_dma->data_queue), 8, 4, RT_NULL);
 801a7e6:	693b      	ldr	r3, [r7, #16]
 801a7e8:	3304      	adds	r3, #4
 801a7ea:	4618      	mov	r0, r3
 801a7ec:	2108      	movs	r1, #8
 801a7ee:	2204      	movs	r2, #4
 801a7f0:	2300      	movs	r3, #0
 801a7f2:	f7fe ffbf 	bl	8019774 <rt_data_queue_init>
            serial->serial_tx = tx_dma;
 801a7f6:	69fb      	ldr	r3, [r7, #28]
 801a7f8:	693a      	ldr	r2, [r7, #16]
 801a7fa:	651a      	str	r2, [r3, #80]	; 0x50

            dev->open_flag |= RT_DEVICE_FLAG_DMA_TX;
 801a7fc:	687b      	ldr	r3, [r7, #4]
 801a7fe:	8b1b      	ldrh	r3, [r3, #24]
 801a800:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 801a804:	b29a      	uxth	r2, r3
 801a806:	687b      	ldr	r3, [r7, #4]
 801a808:	831a      	strh	r2, [r3, #24]
 801a80a:	e02b      	b.n	801a864 <rt_serial_open+0x22c>
        }
        else if (oflag & RT_DEVICE_FLAG_INT_TX)
 801a80c:	887b      	ldrh	r3, [r7, #2]
 801a80e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801a812:	2b00      	cmp	r3, #0
 801a814:	d023      	beq.n	801a85e <rt_serial_open+0x226>
        {
            struct rt_serial_tx_fifo *tx_fifo;

            tx_fifo = (struct rt_serial_tx_fifo*) rt_malloc(sizeof(struct rt_serial_tx_fifo));
 801a816:	200c      	movs	r0, #12
 801a818:	f7fc fe28 	bl	801746c <rt_malloc>
 801a81c:	60f8      	str	r0, [r7, #12]
            RT_ASSERT(tx_fifo != RT_NULL);
 801a81e:	68fb      	ldr	r3, [r7, #12]
 801a820:	2b00      	cmp	r3, #0
 801a822:	d105      	bne.n	801a830 <rt_serial_open+0x1f8>
 801a824:	4817      	ldr	r0, [pc, #92]	; (801a884 <rt_serial_open+0x24c>)
 801a826:	4913      	ldr	r1, [pc, #76]	; (801a874 <rt_serial_open+0x23c>)
 801a828:	f240 123f 	movw	r2, #319	; 0x13f
 801a82c:	f7fc fcea 	bl	8017204 <rt_assert_handler>

            rt_completion_init(&(tx_fifo->completion));
 801a830:	68fb      	ldr	r3, [r7, #12]
 801a832:	4618      	mov	r0, r3
 801a834:	f7fe fe8c 	bl	8019550 <rt_completion_init>
            serial->serial_tx = tx_fifo;
 801a838:	69fb      	ldr	r3, [r7, #28]
 801a83a:	68fa      	ldr	r2, [r7, #12]
 801a83c:	651a      	str	r2, [r3, #80]	; 0x50

            dev->open_flag |= RT_DEVICE_FLAG_INT_TX;
 801a83e:	687b      	ldr	r3, [r7, #4]
 801a840:	8b1b      	ldrh	r3, [r3, #24]
 801a842:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 801a846:	b29a      	uxth	r2, r3
 801a848:	687b      	ldr	r3, [r7, #4]
 801a84a:	831a      	strh	r2, [r3, #24]
            /* configure low level device */
            serial->ops->control(serial, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_TX);
 801a84c:	69fb      	ldr	r3, [r7, #28]
 801a84e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a850:	685b      	ldr	r3, [r3, #4]
 801a852:	69f8      	ldr	r0, [r7, #28]
 801a854:	2110      	movs	r1, #16
 801a856:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801a85a:	4798      	blx	r3
 801a85c:	e002      	b.n	801a864 <rt_serial_open+0x22c>
        }
        else
        {
            serial->serial_tx = RT_NULL;
 801a85e:	69fb      	ldr	r3, [r7, #28]
 801a860:	2200      	movs	r2, #0
 801a862:	651a      	str	r2, [r3, #80]	; 0x50
        }
    }

    return RT_EOK;
 801a864:	2300      	movs	r3, #0
}
 801a866:	4618      	mov	r0, r3
 801a868:	3720      	adds	r7, #32
 801a86a:	46bd      	mov	sp, r7
 801a86c:	bd80      	pop	{r7, pc}
 801a86e:	bf00      	nop
 801a870:	080297b4 	.word	0x080297b4
 801a874:	0802ad80 	.word	0x0802ad80
 801a878:	080297a0 	.word	0x080297a0
 801a87c:	08029750 	.word	0x08029750
 801a880:	080297cc 	.word	0x080297cc
 801a884:	080297e0 	.word	0x080297e0

0801a888 <rt_serial_close>:

static rt_err_t rt_serial_close(struct rt_device *dev)
{
 801a888:	b580      	push	{r7, lr}
 801a88a:	b088      	sub	sp, #32
 801a88c:	af00      	add	r7, sp, #0
 801a88e:	6078      	str	r0, [r7, #4]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
 801a890:	687b      	ldr	r3, [r7, #4]
 801a892:	2b00      	cmp	r3, #0
 801a894:	d105      	bne.n	801a8a2 <rt_serial_close+0x1a>
 801a896:	4850      	ldr	r0, [pc, #320]	; (801a9d8 <rt_serial_close+0x150>)
 801a898:	4950      	ldr	r1, [pc, #320]	; (801a9dc <rt_serial_close+0x154>)
 801a89a:	f240 1255 	movw	r2, #341	; 0x155
 801a89e:	f7fc fcb1 	bl	8017204 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
 801a8a2:	687b      	ldr	r3, [r7, #4]
 801a8a4:	61fb      	str	r3, [r7, #28]

    /* this device has more reference count */
    if (dev->ref_count > 1) return RT_EOK;
 801a8a6:	687b      	ldr	r3, [r7, #4]
 801a8a8:	7e9b      	ldrb	r3, [r3, #26]
 801a8aa:	2b01      	cmp	r3, #1
 801a8ac:	d901      	bls.n	801a8b2 <rt_serial_close+0x2a>
 801a8ae:	2300      	movs	r3, #0
 801a8b0:	e08e      	b.n	801a9d0 <rt_serial_close+0x148>
    
    if (dev->open_flag & RT_DEVICE_FLAG_INT_RX)
 801a8b2:	687b      	ldr	r3, [r7, #4]
 801a8b4:	8b1b      	ldrh	r3, [r3, #24]
 801a8b6:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801a8ba:	2b00      	cmp	r3, #0
 801a8bc:	d021      	beq.n	801a902 <rt_serial_close+0x7a>
    {
        struct rt_serial_rx_fifo* rx_fifo;

        rx_fifo = (struct rt_serial_rx_fifo*)serial->serial_rx;
 801a8be:	69fb      	ldr	r3, [r7, #28]
 801a8c0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801a8c2:	61bb      	str	r3, [r7, #24]
        RT_ASSERT(rx_fifo != RT_NULL);
 801a8c4:	69bb      	ldr	r3, [r7, #24]
 801a8c6:	2b00      	cmp	r3, #0
 801a8c8:	d105      	bne.n	801a8d6 <rt_serial_close+0x4e>
 801a8ca:	4845      	ldr	r0, [pc, #276]	; (801a9e0 <rt_serial_close+0x158>)
 801a8cc:	4943      	ldr	r1, [pc, #268]	; (801a9dc <rt_serial_close+0x154>)
 801a8ce:	f44f 72b0 	mov.w	r2, #352	; 0x160
 801a8d2:	f7fc fc97 	bl	8017204 <rt_assert_handler>

        rt_free(rx_fifo);
 801a8d6:	69b8      	ldr	r0, [r7, #24]
 801a8d8:	f7fd f80c 	bl	80178f4 <rt_free>
        serial->serial_rx = RT_NULL;
 801a8dc:	69fb      	ldr	r3, [r7, #28]
 801a8de:	2200      	movs	r2, #0
 801a8e0:	64da      	str	r2, [r3, #76]	; 0x4c
        dev->open_flag &= ~RT_DEVICE_FLAG_INT_RX;
 801a8e2:	687b      	ldr	r3, [r7, #4]
 801a8e4:	8b1b      	ldrh	r3, [r3, #24]
 801a8e6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 801a8ea:	b29a      	uxth	r2, r3
 801a8ec:	687b      	ldr	r3, [r7, #4]
 801a8ee:	831a      	strh	r2, [r3, #24]
        /* configure low level device */
        serial->ops->control(serial, RT_DEVICE_CTRL_CLR_INT, (void*)RT_DEVICE_FLAG_INT_TX);
 801a8f0:	69fb      	ldr	r3, [r7, #28]
 801a8f2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a8f4:	685b      	ldr	r3, [r3, #4]
 801a8f6:	69f8      	ldr	r0, [r7, #28]
 801a8f8:	2111      	movs	r1, #17
 801a8fa:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801a8fe:	4798      	blx	r3
 801a900:	e01e      	b.n	801a940 <rt_serial_close+0xb8>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_RX)
 801a902:	687b      	ldr	r3, [r7, #4]
 801a904:	8b1b      	ldrh	r3, [r3, #24]
 801a906:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801a90a:	2b00      	cmp	r3, #0
 801a90c:	d018      	beq.n	801a940 <rt_serial_close+0xb8>
    {
        struct rt_serial_rx_dma* rx_dma;

        rx_dma = (struct rt_serial_rx_dma*)serial->serial_tx;
 801a90e:	69fb      	ldr	r3, [r7, #28]
 801a910:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a912:	617b      	str	r3, [r7, #20]
        RT_ASSERT(rx_dma != RT_NULL);
 801a914:	697b      	ldr	r3, [r7, #20]
 801a916:	2b00      	cmp	r3, #0
 801a918:	d105      	bne.n	801a926 <rt_serial_close+0x9e>
 801a91a:	4832      	ldr	r0, [pc, #200]	; (801a9e4 <rt_serial_close+0x15c>)
 801a91c:	492f      	ldr	r1, [pc, #188]	; (801a9dc <rt_serial_close+0x154>)
 801a91e:	f240 126d 	movw	r2, #365	; 0x16d
 801a922:	f7fc fc6f 	bl	8017204 <rt_assert_handler>

        rt_free(rx_dma);
 801a926:	6978      	ldr	r0, [r7, #20]
 801a928:	f7fc ffe4 	bl	80178f4 <rt_free>
        serial->serial_rx = RT_NULL;
 801a92c:	69fb      	ldr	r3, [r7, #28]
 801a92e:	2200      	movs	r2, #0
 801a930:	64da      	str	r2, [r3, #76]	; 0x4c
        dev->open_flag &= ~RT_DEVICE_FLAG_DMA_RX;
 801a932:	687b      	ldr	r3, [r7, #4]
 801a934:	8b1b      	ldrh	r3, [r3, #24]
 801a936:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 801a93a:	b29a      	uxth	r2, r3
 801a93c:	687b      	ldr	r3, [r7, #4]
 801a93e:	831a      	strh	r2, [r3, #24]
    }

    if (dev->open_flag & RT_DEVICE_FLAG_INT_TX)
 801a940:	687b      	ldr	r3, [r7, #4]
 801a942:	8b1b      	ldrh	r3, [r3, #24]
 801a944:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801a948:	2b00      	cmp	r3, #0
 801a94a:	d021      	beq.n	801a990 <rt_serial_close+0x108>
    {
        struct rt_serial_tx_fifo* tx_fifo;

        tx_fifo = (struct rt_serial_tx_fifo*)serial->serial_rx;
 801a94c:	69fb      	ldr	r3, [r7, #28]
 801a94e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801a950:	613b      	str	r3, [r7, #16]
        RT_ASSERT(tx_fifo != RT_NULL);
 801a952:	693b      	ldr	r3, [r7, #16]
 801a954:	2b00      	cmp	r3, #0
 801a956:	d105      	bne.n	801a964 <rt_serial_close+0xdc>
 801a958:	4823      	ldr	r0, [pc, #140]	; (801a9e8 <rt_serial_close+0x160>)
 801a95a:	4920      	ldr	r1, [pc, #128]	; (801a9dc <rt_serial_close+0x154>)
 801a95c:	f240 1279 	movw	r2, #377	; 0x179
 801a960:	f7fc fc50 	bl	8017204 <rt_assert_handler>

        rt_free(tx_fifo);
 801a964:	6938      	ldr	r0, [r7, #16]
 801a966:	f7fc ffc5 	bl	80178f4 <rt_free>
        serial->serial_tx = RT_NULL;
 801a96a:	69fb      	ldr	r3, [r7, #28]
 801a96c:	2200      	movs	r2, #0
 801a96e:	651a      	str	r2, [r3, #80]	; 0x50
        dev->open_flag &= ~RT_DEVICE_FLAG_INT_TX;
 801a970:	687b      	ldr	r3, [r7, #4]
 801a972:	8b1b      	ldrh	r3, [r3, #24]
 801a974:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 801a978:	b29a      	uxth	r2, r3
 801a97a:	687b      	ldr	r3, [r7, #4]
 801a97c:	831a      	strh	r2, [r3, #24]
        /* configure low level device */
        serial->ops->control(serial, RT_DEVICE_CTRL_CLR_INT, (void*)RT_DEVICE_FLAG_INT_TX);
 801a97e:	69fb      	ldr	r3, [r7, #28]
 801a980:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a982:	685b      	ldr	r3, [r3, #4]
 801a984:	69f8      	ldr	r0, [r7, #28]
 801a986:	2111      	movs	r1, #17
 801a988:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801a98c:	4798      	blx	r3
 801a98e:	e01e      	b.n	801a9ce <rt_serial_close+0x146>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_TX)
 801a990:	687b      	ldr	r3, [r7, #4]
 801a992:	8b1b      	ldrh	r3, [r3, #24]
 801a994:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801a998:	2b00      	cmp	r3, #0
 801a99a:	d018      	beq.n	801a9ce <rt_serial_close+0x146>
    {
        struct rt_serial_tx_dma* tx_dma;

        tx_dma = (struct rt_serial_tx_dma*)serial->serial_tx;
 801a99c:	69fb      	ldr	r3, [r7, #28]
 801a99e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a9a0:	60fb      	str	r3, [r7, #12]
        RT_ASSERT(tx_dma != RT_NULL);
 801a9a2:	68fb      	ldr	r3, [r7, #12]
 801a9a4:	2b00      	cmp	r3, #0
 801a9a6:	d105      	bne.n	801a9b4 <rt_serial_close+0x12c>
 801a9a8:	4810      	ldr	r0, [pc, #64]	; (801a9ec <rt_serial_close+0x164>)
 801a9aa:	490c      	ldr	r1, [pc, #48]	; (801a9dc <rt_serial_close+0x154>)
 801a9ac:	f44f 72c3 	mov.w	r2, #390	; 0x186
 801a9b0:	f7fc fc28 	bl	8017204 <rt_assert_handler>

        rt_free(tx_dma);
 801a9b4:	68f8      	ldr	r0, [r7, #12]
 801a9b6:	f7fc ff9d 	bl	80178f4 <rt_free>
        serial->serial_tx = RT_NULL;
 801a9ba:	69fb      	ldr	r3, [r7, #28]
 801a9bc:	2200      	movs	r2, #0
 801a9be:	651a      	str	r2, [r3, #80]	; 0x50
        dev->open_flag &= ~RT_DEVICE_FLAG_DMA_TX;
 801a9c0:	687b      	ldr	r3, [r7, #4]
 801a9c2:	8b1b      	ldrh	r3, [r3, #24]
 801a9c4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 801a9c8:	b29a      	uxth	r2, r3
 801a9ca:	687b      	ldr	r3, [r7, #4]
 801a9cc:	831a      	strh	r2, [r3, #24]
    }

    return RT_EOK;
 801a9ce:	2300      	movs	r3, #0
}
 801a9d0:	4618      	mov	r0, r3
 801a9d2:	3720      	adds	r7, #32
 801a9d4:	46bd      	mov	sp, r7
 801a9d6:	bd80      	pop	{r7, pc}
 801a9d8:	080297b4 	.word	0x080297b4
 801a9dc:	0802ad90 	.word	0x0802ad90
 801a9e0:	08029750 	.word	0x08029750
 801a9e4:	080297a0 	.word	0x080297a0
 801a9e8:	080297e0 	.word	0x080297e0
 801a9ec:	080297cc 	.word	0x080297cc

0801a9f0 <rt_serial_read>:

static rt_size_t rt_serial_read(struct rt_device *dev,
                                rt_off_t          pos,
                                void             *buffer,
                                rt_size_t         size)
{
 801a9f0:	b580      	push	{r7, lr}
 801a9f2:	b086      	sub	sp, #24
 801a9f4:	af00      	add	r7, sp, #0
 801a9f6:	60f8      	str	r0, [r7, #12]
 801a9f8:	60b9      	str	r1, [r7, #8]
 801a9fa:	607a      	str	r2, [r7, #4]
 801a9fc:	603b      	str	r3, [r7, #0]
    struct rt_serial_device *serial;
	//rt_kprintf("&x\r\n",dev->open_flag);

    RT_ASSERT(dev != RT_NULL);
 801a9fe:	68fb      	ldr	r3, [r7, #12]
 801aa00:	2b00      	cmp	r3, #0
 801aa02:	d105      	bne.n	801aa10 <rt_serial_read+0x20>
 801aa04:	4819      	ldr	r0, [pc, #100]	; (801aa6c <rt_serial_read+0x7c>)
 801aa06:	491a      	ldr	r1, [pc, #104]	; (801aa70 <rt_serial_read+0x80>)
 801aa08:	f44f 72cc 	mov.w	r2, #408	; 0x198
 801aa0c:	f7fc fbfa 	bl	8017204 <rt_assert_handler>
    if (size == 0) return 0;
 801aa10:	683b      	ldr	r3, [r7, #0]
 801aa12:	2b00      	cmp	r3, #0
 801aa14:	d101      	bne.n	801aa1a <rt_serial_read+0x2a>
 801aa16:	2300      	movs	r3, #0
 801aa18:	e024      	b.n	801aa64 <rt_serial_read+0x74>

    serial = (struct rt_serial_device *)dev;
 801aa1a:	68fb      	ldr	r3, [r7, #12]
 801aa1c:	617b      	str	r3, [r7, #20]
    if (dev->open_flag & RT_DEVICE_FLAG_INT_RX)
 801aa1e:	68fb      	ldr	r3, [r7, #12]
 801aa20:	8b1b      	ldrh	r3, [r3, #24]
 801aa22:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801aa26:	2b00      	cmp	r3, #0
 801aa28:	d007      	beq.n	801aa3a <rt_serial_read+0x4a>
    {
        return _serial_int_rx(serial, buffer, size);
 801aa2a:	683b      	ldr	r3, [r7, #0]
 801aa2c:	6978      	ldr	r0, [r7, #20]
 801aa2e:	6879      	ldr	r1, [r7, #4]
 801aa30:	461a      	mov	r2, r3
 801aa32:	f7ff fcab 	bl	801a38c <_serial_int_rx>
 801aa36:	4603      	mov	r3, r0
 801aa38:	e014      	b.n	801aa64 <rt_serial_read+0x74>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_RX)
 801aa3a:	68fb      	ldr	r3, [r7, #12]
 801aa3c:	8b1b      	ldrh	r3, [r3, #24]
 801aa3e:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801aa42:	2b00      	cmp	r3, #0
 801aa44:	d007      	beq.n	801aa56 <rt_serial_read+0x66>
    {
        return _serial_dma_rx(serial, buffer, size);
 801aa46:	683b      	ldr	r3, [r7, #0]
 801aa48:	6978      	ldr	r0, [r7, #20]
 801aa4a:	6879      	ldr	r1, [r7, #4]
 801aa4c:	461a      	mov	r2, r3
 801aa4e:	f7ff fd43 	bl	801a4d8 <_serial_dma_rx>
 801aa52:	4603      	mov	r3, r0
 801aa54:	e006      	b.n	801aa64 <rt_serial_read+0x74>
    }

    return _serial_poll_rx(serial, buffer, size);
 801aa56:	683b      	ldr	r3, [r7, #0]
 801aa58:	6978      	ldr	r0, [r7, #20]
 801aa5a:	6879      	ldr	r1, [r7, #4]
 801aa5c:	461a      	mov	r2, r3
 801aa5e:	f7ff fc23 	bl	801a2a8 <_serial_poll_rx>
 801aa62:	4603      	mov	r3, r0
}
 801aa64:	4618      	mov	r0, r3
 801aa66:	3718      	adds	r7, #24
 801aa68:	46bd      	mov	sp, r7
 801aa6a:	bd80      	pop	{r7, pc}
 801aa6c:	080297b4 	.word	0x080297b4
 801aa70:	0802ada0 	.word	0x0802ada0

0801aa74 <rt_serial_write>:

static rt_size_t rt_serial_write(struct rt_device *dev,
                                 rt_off_t          pos,
                                 const void       *buffer,
                                 rt_size_t         size)
{
 801aa74:	b580      	push	{r7, lr}
 801aa76:	b086      	sub	sp, #24
 801aa78:	af00      	add	r7, sp, #0
 801aa7a:	60f8      	str	r0, [r7, #12]
 801aa7c:	60b9      	str	r1, [r7, #8]
 801aa7e:	607a      	str	r2, [r7, #4]
 801aa80:	603b      	str	r3, [r7, #0]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
 801aa82:	68fb      	ldr	r3, [r7, #12]
 801aa84:	2b00      	cmp	r3, #0
 801aa86:	d105      	bne.n	801aa94 <rt_serial_write+0x20>
 801aa88:	4819      	ldr	r0, [pc, #100]	; (801aaf0 <rt_serial_write+0x7c>)
 801aa8a:	491a      	ldr	r1, [pc, #104]	; (801aaf4 <rt_serial_write+0x80>)
 801aa8c:	f240 12af 	movw	r2, #431	; 0x1af
 801aa90:	f7fc fbb8 	bl	8017204 <rt_assert_handler>
    if (size == 0) return 0;
 801aa94:	683b      	ldr	r3, [r7, #0]
 801aa96:	2b00      	cmp	r3, #0
 801aa98:	d101      	bne.n	801aa9e <rt_serial_write+0x2a>
 801aa9a:	2300      	movs	r3, #0
 801aa9c:	e024      	b.n	801aae8 <rt_serial_write+0x74>

    serial = (struct rt_serial_device *)dev;
 801aa9e:	68fb      	ldr	r3, [r7, #12]
 801aaa0:	617b      	str	r3, [r7, #20]

    if (dev->open_flag & RT_DEVICE_FLAG_INT_TX)
 801aaa2:	68fb      	ldr	r3, [r7, #12]
 801aaa4:	8b1b      	ldrh	r3, [r3, #24]
 801aaa6:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801aaaa:	2b00      	cmp	r3, #0
 801aaac:	d007      	beq.n	801aabe <rt_serial_write+0x4a>
    {
        return _serial_int_tx(serial, buffer, size);
 801aaae:	683b      	ldr	r3, [r7, #0]
 801aab0:	6978      	ldr	r0, [r7, #20]
 801aab2:	6879      	ldr	r1, [r7, #4]
 801aab4:	461a      	mov	r2, r3
 801aab6:	f7ff fcc9 	bl	801a44c <_serial_int_tx>
 801aaba:	4603      	mov	r3, r0
 801aabc:	e014      	b.n	801aae8 <rt_serial_write+0x74>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_TX)
 801aabe:	68fb      	ldr	r3, [r7, #12]
 801aac0:	8b1b      	ldrh	r3, [r3, #24]
 801aac2:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801aac6:	2b00      	cmp	r3, #0
 801aac8:	d007      	beq.n	801aada <rt_serial_write+0x66>
    {
        return _serial_dma_tx(serial, buffer, size);
 801aaca:	683b      	ldr	r3, [r7, #0]
 801aacc:	6978      	ldr	r0, [r7, #20]
 801aace:	6879      	ldr	r1, [r7, #4]
 801aad0:	461a      	mov	r2, r3
 801aad2:	f7ff fd41 	bl	801a558 <_serial_dma_tx>
 801aad6:	4603      	mov	r3, r0
 801aad8:	e006      	b.n	801aae8 <rt_serial_write+0x74>
    }
    else
    {
        return _serial_poll_tx(serial, buffer, size);
 801aada:	683b      	ldr	r3, [r7, #0]
 801aadc:	6978      	ldr	r0, [r7, #20]
 801aade:	6879      	ldr	r1, [r7, #4]
 801aae0:	461a      	mov	r2, r3
 801aae2:	f7ff fc15 	bl	801a310 <_serial_poll_tx>
 801aae6:	4603      	mov	r3, r0
    }
}
 801aae8:	4618      	mov	r0, r3
 801aaea:	3718      	adds	r7, #24
 801aaec:	46bd      	mov	sp, r7
 801aaee:	bd80      	pop	{r7, pc}
 801aaf0:	080297b4 	.word	0x080297b4
 801aaf4:	0802ade0 	.word	0x0802ade0

0801aaf8 <rt_serial_control>:

static rt_err_t rt_serial_control(struct rt_device *dev,
                                  rt_uint8_t        cmd,
                                  void             *args)
{
 801aaf8:	b580      	push	{r7, lr}
 801aafa:	b086      	sub	sp, #24
 801aafc:	af00      	add	r7, sp, #0
 801aafe:	60f8      	str	r0, [r7, #12]
 801ab00:	460b      	mov	r3, r1
 801ab02:	607a      	str	r2, [r7, #4]
 801ab04:	72fb      	strb	r3, [r7, #11]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
 801ab06:	68fb      	ldr	r3, [r7, #12]
 801ab08:	2b00      	cmp	r3, #0
 801ab0a:	d105      	bne.n	801ab18 <rt_serial_control+0x20>
 801ab0c:	481a      	ldr	r0, [pc, #104]	; (801ab78 <rt_serial_control+0x80>)
 801ab0e:	491b      	ldr	r1, [pc, #108]	; (801ab7c <rt_serial_control+0x84>)
 801ab10:	f44f 72e4 	mov.w	r2, #456	; 0x1c8
 801ab14:	f7fc fb76 	bl	8017204 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
 801ab18:	68fb      	ldr	r3, [r7, #12]
 801ab1a:	617b      	str	r3, [r7, #20]

    switch (cmd)
 801ab1c:	7afb      	ldrb	r3, [r7, #11]
 801ab1e:	2b02      	cmp	r3, #2
 801ab20:	d004      	beq.n	801ab2c <rt_serial_control+0x34>
 801ab22:	2b03      	cmp	r3, #3
 801ab24:	d012      	beq.n	801ab4c <rt_serial_control+0x54>
 801ab26:	2b01      	cmp	r3, #1
 801ab28:	d008      	beq.n	801ab3c <rt_serial_control+0x44>
 801ab2a:	e016      	b.n	801ab5a <rt_serial_control+0x62>
    {
        case RT_DEVICE_CTRL_SUSPEND:
            /* suspend device */
            dev->flag |= RT_DEVICE_FLAG_SUSPENDED;
 801ab2c:	68fb      	ldr	r3, [r7, #12]
 801ab2e:	8adb      	ldrh	r3, [r3, #22]
 801ab30:	f043 0320 	orr.w	r3, r3, #32
 801ab34:	b29a      	uxth	r2, r3
 801ab36:	68fb      	ldr	r3, [r7, #12]
 801ab38:	82da      	strh	r2, [r3, #22]
            break;
 801ab3a:	e017      	b.n	801ab6c <rt_serial_control+0x74>

        case RT_DEVICE_CTRL_RESUME:
            /* resume device */
            dev->flag &= ~RT_DEVICE_FLAG_SUSPENDED;
 801ab3c:	68fb      	ldr	r3, [r7, #12]
 801ab3e:	8adb      	ldrh	r3, [r3, #22]
 801ab40:	f023 0320 	bic.w	r3, r3, #32
 801ab44:	b29a      	uxth	r2, r3
 801ab46:	68fb      	ldr	r3, [r7, #12]
 801ab48:	82da      	strh	r2, [r3, #22]
            break;
 801ab4a:	e00f      	b.n	801ab6c <rt_serial_control+0x74>

        case RT_DEVICE_CTRL_CONFIG:
            /* configure device */
            serial->ops->configure(serial, (struct serial_configure *)args);
 801ab4c:	697b      	ldr	r3, [r7, #20]
 801ab4e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801ab50:	681b      	ldr	r3, [r3, #0]
 801ab52:	6978      	ldr	r0, [r7, #20]
 801ab54:	6879      	ldr	r1, [r7, #4]
 801ab56:	4798      	blx	r3
            break;
 801ab58:	e008      	b.n	801ab6c <rt_serial_control+0x74>

        default :
            /* control device */
            serial->ops->control(serial, cmd, args);
 801ab5a:	697b      	ldr	r3, [r7, #20]
 801ab5c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801ab5e:	685b      	ldr	r3, [r3, #4]
 801ab60:	7afa      	ldrb	r2, [r7, #11]
 801ab62:	6978      	ldr	r0, [r7, #20]
 801ab64:	4611      	mov	r1, r2
 801ab66:	687a      	ldr	r2, [r7, #4]
 801ab68:	4798      	blx	r3
            break;
 801ab6a:	bf00      	nop
    }

    return RT_EOK;
 801ab6c:	2300      	movs	r3, #0
}
 801ab6e:	4618      	mov	r0, r3
 801ab70:	3718      	adds	r7, #24
 801ab72:	46bd      	mov	sp, r7
 801ab74:	bd80      	pop	{r7, pc}
 801ab76:	bf00      	nop
 801ab78:	080297b4 	.word	0x080297b4
 801ab7c:	0802ae10 	.word	0x0802ae10

0801ab80 <rt_hw_serial_register>:
 */
rt_err_t rt_hw_serial_register(struct rt_serial_device *serial,
                               const char              *name,
                               rt_uint32_t              flag,
                               void                    *data)
{
 801ab80:	b580      	push	{r7, lr}
 801ab82:	b086      	sub	sp, #24
 801ab84:	af00      	add	r7, sp, #0
 801ab86:	60f8      	str	r0, [r7, #12]
 801ab88:	60b9      	str	r1, [r7, #8]
 801ab8a:	607a      	str	r2, [r7, #4]
 801ab8c:	603b      	str	r3, [r7, #0]
    struct rt_device *device;
    RT_ASSERT(serial != RT_NULL);
 801ab8e:	68fb      	ldr	r3, [r7, #12]
 801ab90:	2b00      	cmp	r3, #0
 801ab92:	d105      	bne.n	801aba0 <rt_hw_serial_register+0x20>
 801ab94:	4818      	ldr	r0, [pc, #96]	; (801abf8 <rt_hw_serial_register+0x78>)
 801ab96:	4919      	ldr	r1, [pc, #100]	; (801abfc <rt_hw_serial_register+0x7c>)
 801ab98:	f44f 72f7 	mov.w	r2, #494	; 0x1ee
 801ab9c:	f7fc fb32 	bl	8017204 <rt_assert_handler>

    device = &(serial->parent);
 801aba0:	68fb      	ldr	r3, [r7, #12]
 801aba2:	617b      	str	r3, [r7, #20]

    device->type        = RT_Device_Class_Char;
 801aba4:	697b      	ldr	r3, [r7, #20]
 801aba6:	2200      	movs	r2, #0
 801aba8:	751a      	strb	r2, [r3, #20]
    device->rx_indicate = RT_NULL;
 801abaa:	697b      	ldr	r3, [r7, #20]
 801abac:	2200      	movs	r2, #0
 801abae:	61da      	str	r2, [r3, #28]
    device->tx_complete = RT_NULL;
 801abb0:	697b      	ldr	r3, [r7, #20]
 801abb2:	2200      	movs	r2, #0
 801abb4:	621a      	str	r2, [r3, #32]

    device->init        = rt_serial_init;
 801abb6:	697b      	ldr	r3, [r7, #20]
 801abb8:	4a11      	ldr	r2, [pc, #68]	; (801ac00 <rt_hw_serial_register+0x80>)
 801abba:	625a      	str	r2, [r3, #36]	; 0x24
    device->open        = rt_serial_open;
 801abbc:	697b      	ldr	r3, [r7, #20]
 801abbe:	4a11      	ldr	r2, [pc, #68]	; (801ac04 <rt_hw_serial_register+0x84>)
 801abc0:	629a      	str	r2, [r3, #40]	; 0x28
    device->close       = rt_serial_close;
 801abc2:	697b      	ldr	r3, [r7, #20]
 801abc4:	4a10      	ldr	r2, [pc, #64]	; (801ac08 <rt_hw_serial_register+0x88>)
 801abc6:	62da      	str	r2, [r3, #44]	; 0x2c
    device->read        = rt_serial_read;
 801abc8:	697b      	ldr	r3, [r7, #20]
 801abca:	4a10      	ldr	r2, [pc, #64]	; (801ac0c <rt_hw_serial_register+0x8c>)
 801abcc:	631a      	str	r2, [r3, #48]	; 0x30
    device->write       = rt_serial_write;
 801abce:	697b      	ldr	r3, [r7, #20]
 801abd0:	4a0f      	ldr	r2, [pc, #60]	; (801ac10 <rt_hw_serial_register+0x90>)
 801abd2:	635a      	str	r2, [r3, #52]	; 0x34
    device->control     = rt_serial_control;
 801abd4:	697b      	ldr	r3, [r7, #20]
 801abd6:	4a0f      	ldr	r2, [pc, #60]	; (801ac14 <rt_hw_serial_register+0x94>)
 801abd8:	639a      	str	r2, [r3, #56]	; 0x38
    device->user_data   = data;
 801abda:	697b      	ldr	r3, [r7, #20]
 801abdc:	683a      	ldr	r2, [r7, #0]
 801abde:	63da      	str	r2, [r3, #60]	; 0x3c

    /* register a character device */
    return rt_device_register(device, name, flag);
 801abe0:	687b      	ldr	r3, [r7, #4]
 801abe2:	b29b      	uxth	r3, r3
 801abe4:	6978      	ldr	r0, [r7, #20]
 801abe6:	68b9      	ldr	r1, [r7, #8]
 801abe8:	461a      	mov	r2, r3
 801abea:	f7fa fbdb 	bl	80153a4 <rt_device_register>
 801abee:	4603      	mov	r3, r0
}
 801abf0:	4618      	mov	r0, r3
 801abf2:	3718      	adds	r7, #24
 801abf4:	46bd      	mov	sp, r7
 801abf6:	bd80      	pop	{r7, pc}
 801abf8:	0802973c 	.word	0x0802973c
 801abfc:	0802ae24 	.word	0x0802ae24
 801ac00:	0801a5d1 	.word	0x0801a5d1
 801ac04:	0801a639 	.word	0x0801a639
 801ac08:	0801a889 	.word	0x0801a889
 801ac0c:	0801a9f1 	.word	0x0801a9f1
 801ac10:	0801aa75 	.word	0x0801aa75
 801ac14:	0801aaf9 	.word	0x0801aaf9

0801ac18 <rt_hw_serial_isr>:

/* ISR for serial interrupt */
void rt_hw_serial_isr(struct rt_serial_device *serial, int event)
{
 801ac18:	b590      	push	{r4, r7, lr}
 801ac1a:	b08f      	sub	sp, #60	; 0x3c
 801ac1c:	af00      	add	r7, sp, #0
 801ac1e:	6078      	str	r0, [r7, #4]
 801ac20:	6039      	str	r1, [r7, #0]
    switch (event & 0xff)
 801ac22:	683b      	ldr	r3, [r7, #0]
 801ac24:	b2db      	uxtb	r3, r3
 801ac26:	3b01      	subs	r3, #1
 801ac28:	2b03      	cmp	r3, #3
 801ac2a:	f200 80ec 	bhi.w	801ae06 <rt_hw_serial_isr+0x1ee>
 801ac2e:	a201      	add	r2, pc, #4	; (adr r2, 801ac34 <rt_hw_serial_isr+0x1c>)
 801ac30:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801ac34:	0801ac45 	.word	0x0801ac45
 801ac38:	0801ad5f 	.word	0x0801ad5f
 801ac3c:	0801ade5 	.word	0x0801ade5
 801ac40:	0801ad6f 	.word	0x0801ad6f
    {
        case RT_SERIAL_EVENT_RX_IND:
        {
            int ch = -1;
 801ac44:	f04f 33ff 	mov.w	r3, #4294967295
 801ac48:	637b      	str	r3, [r7, #52]	; 0x34
            rt_base_t level;
            struct rt_serial_rx_fifo* rx_fifo;

            rx_fifo = (struct rt_serial_rx_fifo*)serial->serial_rx;
 801ac4a:	687b      	ldr	r3, [r7, #4]
 801ac4c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801ac4e:	633b      	str	r3, [r7, #48]	; 0x30
            RT_ASSERT(rx_fifo != RT_NULL);
 801ac50:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ac52:	2b00      	cmp	r3, #0
 801ac54:	d105      	bne.n	801ac62 <rt_hw_serial_isr+0x4a>
 801ac56:	486d      	ldr	r0, [pc, #436]	; (801ae0c <rt_hw_serial_isr+0x1f4>)
 801ac58:	496d      	ldr	r1, [pc, #436]	; (801ae10 <rt_hw_serial_isr+0x1f8>)
 801ac5a:	f240 220e 	movw	r2, #526	; 0x20e
 801ac5e:	f7fc fad1 	bl	8017204 <rt_assert_handler>
            
            /* interrupt mode receive */
            RT_ASSERT(serial->parent.open_flag & RT_DEVICE_FLAG_INT_RX);
 801ac62:	687b      	ldr	r3, [r7, #4]
 801ac64:	8b1b      	ldrh	r3, [r3, #24]
 801ac66:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801ac6a:	2b00      	cmp	r3, #0
 801ac6c:	d105      	bne.n	801ac7a <rt_hw_serial_isr+0x62>
 801ac6e:	4869      	ldr	r0, [pc, #420]	; (801ae14 <rt_hw_serial_isr+0x1fc>)
 801ac70:	4967      	ldr	r1, [pc, #412]	; (801ae10 <rt_hw_serial_isr+0x1f8>)
 801ac72:	f240 2211 	movw	r2, #529	; 0x211
 801ac76:	f7fc fac5 	bl	8017204 <rt_assert_handler>
            
            while (1)
            {
                ch = serial->ops->getc(serial);
 801ac7a:	687b      	ldr	r3, [r7, #4]
 801ac7c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801ac7e:	68db      	ldr	r3, [r3, #12]
 801ac80:	6878      	ldr	r0, [r7, #4]
 801ac82:	4798      	blx	r3
 801ac84:	6378      	str	r0, [r7, #52]	; 0x34
                if (ch == -1) break;
 801ac86:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ac88:	f1b3 3fff 	cmp.w	r3, #4294967295
 801ac8c:	d105      	bne.n	801ac9a <rt_hw_serial_isr+0x82>
 801ac8e:	bf00      	nop
                /* enable interrupt */
                rt_hw_interrupt_enable(level);
            }
            
            /* invoke callback */
            if (serial->parent.rx_indicate != RT_NULL)
 801ac90:	687b      	ldr	r3, [r7, #4]
 801ac92:	69db      	ldr	r3, [r3, #28]
 801ac94:	2b00      	cmp	r3, #0
 801ac96:	d061      	beq.n	801ad5c <rt_hw_serial_isr+0x144>
 801ac98:	e038      	b.n	801ad0c <rt_hw_serial_isr+0xf4>
            {
                ch = serial->ops->getc(serial);
                if (ch == -1) break;
                
                /* disable interrupt */
                level = rt_hw_interrupt_disable();
 801ac9a:	f7e5 fa97 	bl	80001cc <rt_hw_interrupt_disable>
 801ac9e:	62f8      	str	r0, [r7, #44]	; 0x2c
                
                rx_fifo->buffer[rx_fifo->put_index] = ch;
 801aca0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801aca2:	681b      	ldr	r3, [r3, #0]
 801aca4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801aca6:	8892      	ldrh	r2, [r2, #4]
 801aca8:	4413      	add	r3, r2
 801acaa:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801acac:	b2d2      	uxtb	r2, r2
 801acae:	701a      	strb	r2, [r3, #0]
                rx_fifo->put_index += 1;
 801acb0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801acb2:	889b      	ldrh	r3, [r3, #4]
 801acb4:	3301      	adds	r3, #1
 801acb6:	b29a      	uxth	r2, r3
 801acb8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801acba:	809a      	strh	r2, [r3, #4]
                if (rx_fifo->put_index >= serial->config.bufsz) rx_fifo->put_index = 0;
 801acbc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801acbe:	889a      	ldrh	r2, [r3, #4]
 801acc0:	687b      	ldr	r3, [r7, #4]
 801acc2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801acc4:	f3c3 238f 	ubfx	r3, r3, #10, #16
 801acc8:	b29b      	uxth	r3, r3
 801acca:	429a      	cmp	r2, r3
 801accc:	d302      	bcc.n	801acd4 <rt_hw_serial_isr+0xbc>
 801acce:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801acd0:	2200      	movs	r2, #0
 801acd2:	809a      	strh	r2, [r3, #4]
                
                /* if the next position is read index, discard this 'read char' */
                if (rx_fifo->put_index == rx_fifo->get_index)
 801acd4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801acd6:	889a      	ldrh	r2, [r3, #4]
 801acd8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801acda:	88db      	ldrh	r3, [r3, #6]
 801acdc:	429a      	cmp	r2, r3
 801acde:	d111      	bne.n	801ad04 <rt_hw_serial_isr+0xec>
                {
                    rx_fifo->get_index += 1;
 801ace0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ace2:	88db      	ldrh	r3, [r3, #6]
 801ace4:	3301      	adds	r3, #1
 801ace6:	b29a      	uxth	r2, r3
 801ace8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801acea:	80da      	strh	r2, [r3, #6]
                    if (rx_fifo->get_index >= serial->config.bufsz) rx_fifo->get_index = 0;
 801acec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801acee:	88da      	ldrh	r2, [r3, #6]
 801acf0:	687b      	ldr	r3, [r7, #4]
 801acf2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801acf4:	f3c3 238f 	ubfx	r3, r3, #10, #16
 801acf8:	b29b      	uxth	r3, r3
 801acfa:	429a      	cmp	r2, r3
 801acfc:	d302      	bcc.n	801ad04 <rt_hw_serial_isr+0xec>
 801acfe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ad00:	2200      	movs	r2, #0
 801ad02:	80da      	strh	r2, [r3, #6]
                }
                
                /* enable interrupt */
                rt_hw_interrupt_enable(level);
 801ad04:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801ad06:	f7e5 fa65 	bl	80001d4 <rt_hw_interrupt_enable>
            }
 801ad0a:	e7b6      	b.n	801ac7a <rt_hw_serial_isr+0x62>
            if (serial->parent.rx_indicate != RT_NULL)
            {
                rt_size_t rx_length;
            
                /* get rx length */
                level = rt_hw_interrupt_disable();
 801ad0c:	f7e5 fa5e 	bl	80001cc <rt_hw_interrupt_disable>
 801ad10:	62f8      	str	r0, [r7, #44]	; 0x2c
                rx_length = (rx_fifo->put_index >= rx_fifo->get_index)? (rx_fifo->put_index - rx_fifo->get_index):
 801ad12:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ad14:	889a      	ldrh	r2, [r3, #4]
 801ad16:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ad18:	88db      	ldrh	r3, [r3, #6]
 801ad1a:	429a      	cmp	r2, r3
 801ad1c:	d306      	bcc.n	801ad2c <rt_hw_serial_isr+0x114>
 801ad1e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ad20:	889b      	ldrh	r3, [r3, #4]
 801ad22:	461a      	mov	r2, r3
 801ad24:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ad26:	88db      	ldrh	r3, [r3, #6]
 801ad28:	1ad3      	subs	r3, r2, r3
 801ad2a:	e00c      	b.n	801ad46 <rt_hw_serial_isr+0x12e>
                    (serial->config.bufsz - (rx_fifo->get_index - rx_fifo->put_index));
 801ad2c:	687b      	ldr	r3, [r7, #4]
 801ad2e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801ad30:	f3c3 238f 	ubfx	r3, r3, #10, #16
 801ad34:	b29b      	uxth	r3, r3
 801ad36:	461a      	mov	r2, r3
 801ad38:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ad3a:	889b      	ldrh	r3, [r3, #4]
 801ad3c:	4619      	mov	r1, r3
 801ad3e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ad40:	88db      	ldrh	r3, [r3, #6]
 801ad42:	1acb      	subs	r3, r1, r3
 801ad44:	4413      	add	r3, r2
            {
                rt_size_t rx_length;
            
                /* get rx length */
                level = rt_hw_interrupt_disable();
                rx_length = (rx_fifo->put_index >= rx_fifo->get_index)? (rx_fifo->put_index - rx_fifo->get_index):
 801ad46:	62bb      	str	r3, [r7, #40]	; 0x28
                    (serial->config.bufsz - (rx_fifo->get_index - rx_fifo->put_index));
                rt_hw_interrupt_enable(level);
 801ad48:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801ad4a:	f7e5 fa43 	bl	80001d4 <rt_hw_interrupt_enable>

                serial->parent.rx_indicate(&serial->parent, rx_length);
 801ad4e:	687b      	ldr	r3, [r7, #4]
 801ad50:	69db      	ldr	r3, [r3, #28]
 801ad52:	687a      	ldr	r2, [r7, #4]
 801ad54:	4610      	mov	r0, r2
 801ad56:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801ad58:	4798      	blx	r3
            }
            break;
 801ad5a:	e054      	b.n	801ae06 <rt_hw_serial_isr+0x1ee>
 801ad5c:	e053      	b.n	801ae06 <rt_hw_serial_isr+0x1ee>
        }
        case RT_SERIAL_EVENT_TX_DONE:
        {
            struct rt_serial_tx_fifo* tx_fifo;

            tx_fifo = (struct rt_serial_tx_fifo*)serial->serial_tx;
 801ad5e:	687b      	ldr	r3, [r7, #4]
 801ad60:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801ad62:	627b      	str	r3, [r7, #36]	; 0x24
            rt_completion_done(&(tx_fifo->completion));
 801ad64:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ad66:	4618      	mov	r0, r3
 801ad68:	f7fe fc94 	bl	8019694 <rt_completion_done>
            break;
 801ad6c:	e04b      	b.n	801ae06 <rt_hw_serial_isr+0x1ee>
            const void *data_ptr;
            rt_size_t data_size;
            const void *last_data_ptr;
            struct rt_serial_tx_dma* tx_dma;

            tx_dma = (struct rt_serial_tx_dma*) serial->serial_tx;
 801ad6e:	687b      	ldr	r3, [r7, #4]
 801ad70:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801ad72:	623b      	str	r3, [r7, #32]
            
            rt_data_queue_pop(&(tx_dma->data_queue), &last_data_ptr, &data_size, 0);
 801ad74:	6a3b      	ldr	r3, [r7, #32]
 801ad76:	1d19      	adds	r1, r3, #4
 801ad78:	f107 020c 	add.w	r2, r7, #12
 801ad7c:	f107 0310 	add.w	r3, r7, #16
 801ad80:	4608      	mov	r0, r1
 801ad82:	4611      	mov	r1, r2
 801ad84:	461a      	mov	r2, r3
 801ad86:	2300      	movs	r3, #0
 801ad88:	f7fe fe00 	bl	801998c <rt_data_queue_pop>
            if (rt_data_queue_peak(&(tx_dma->data_queue), &data_ptr, &data_size) == RT_EOK)
 801ad8c:	6a3b      	ldr	r3, [r7, #32]
 801ad8e:	1d19      	adds	r1, r3, #4
 801ad90:	f107 0214 	add.w	r2, r7, #20
 801ad94:	f107 0310 	add.w	r3, r7, #16
 801ad98:	4608      	mov	r0, r1
 801ad9a:	4611      	mov	r1, r2
 801ad9c:	461a      	mov	r2, r3
 801ad9e:	f7fe fee5 	bl	8019b6c <rt_data_queue_peak>
 801ada2:	4603      	mov	r3, r0
 801ada4:	2b00      	cmp	r3, #0
 801ada6:	d10d      	bne.n	801adc4 <rt_hw_serial_isr+0x1ac>
            {
                /* transmit next data node */
                tx_dma->activated = RT_TRUE;
 801ada8:	6a3b      	ldr	r3, [r7, #32]
 801adaa:	2201      	movs	r2, #1
 801adac:	601a      	str	r2, [r3, #0]
                serial->ops->dma_transmit(serial, data_ptr, data_size, RT_SERIAL_DMA_TX);
 801adae:	687b      	ldr	r3, [r7, #4]
 801adb0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801adb2:	691c      	ldr	r4, [r3, #16]
 801adb4:	697a      	ldr	r2, [r7, #20]
 801adb6:	693b      	ldr	r3, [r7, #16]
 801adb8:	6878      	ldr	r0, [r7, #4]
 801adba:	4611      	mov	r1, r2
 801adbc:	461a      	mov	r2, r3
 801adbe:	2302      	movs	r3, #2
 801adc0:	47a0      	blx	r4
 801adc2:	e002      	b.n	801adca <rt_hw_serial_isr+0x1b2>
            }
            else
            {
                tx_dma->activated = RT_FALSE;
 801adc4:	6a3b      	ldr	r3, [r7, #32]
 801adc6:	2200      	movs	r2, #0
 801adc8:	601a      	str	r2, [r3, #0]
            }
            
            /* invoke callback */
            if (serial->parent.tx_complete != RT_NULL)
 801adca:	687b      	ldr	r3, [r7, #4]
 801adcc:	6a1b      	ldr	r3, [r3, #32]
 801adce:	2b00      	cmp	r3, #0
 801add0:	d006      	beq.n	801ade0 <rt_hw_serial_isr+0x1c8>
            {
                serial->parent.tx_complete(&serial->parent, (void*)last_data_ptr);
 801add2:	687b      	ldr	r3, [r7, #4]
 801add4:	6a1b      	ldr	r3, [r3, #32]
 801add6:	6879      	ldr	r1, [r7, #4]
 801add8:	68fa      	ldr	r2, [r7, #12]
 801adda:	4608      	mov	r0, r1
 801addc:	4611      	mov	r1, r2
 801adde:	4798      	blx	r3
            }
            break;
 801ade0:	bf00      	nop
 801ade2:	e010      	b.n	801ae06 <rt_hw_serial_isr+0x1ee>
        case RT_SERIAL_EVENT_RX_DMADONE:
        {
            int length;
            struct rt_serial_rx_dma* rx_dma;

            rx_dma = (struct rt_serial_rx_dma*)serial->serial_rx;
 801ade4:	687b      	ldr	r3, [r7, #4]
 801ade6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801ade8:	61fb      	str	r3, [r7, #28]
            /* get DMA rx length */
            length = (event & (~0xff)) >> 8;
 801adea:	683b      	ldr	r3, [r7, #0]
 801adec:	121b      	asrs	r3, r3, #8
 801adee:	61bb      	str	r3, [r7, #24]
            serial->parent.rx_indicate(&(serial->parent), length);
 801adf0:	687b      	ldr	r3, [r7, #4]
 801adf2:	69db      	ldr	r3, [r3, #28]
 801adf4:	6879      	ldr	r1, [r7, #4]
 801adf6:	69ba      	ldr	r2, [r7, #24]
 801adf8:	4608      	mov	r0, r1
 801adfa:	4611      	mov	r1, r2
 801adfc:	4798      	blx	r3
            rx_dma->activated = RT_FALSE;
 801adfe:	69fb      	ldr	r3, [r7, #28]
 801ae00:	2200      	movs	r2, #0
 801ae02:	601a      	str	r2, [r3, #0]
            break;
 801ae04:	bf00      	nop
        }
    }
}
 801ae06:	373c      	adds	r7, #60	; 0x3c
 801ae08:	46bd      	mov	sp, r7
 801ae0a:	bd90      	pop	{r4, r7, pc}
 801ae0c:	08029750 	.word	0x08029750
 801ae10:	0802ae3c 	.word	0x0802ae3c
 801ae14:	080297f4 	.word	0x080297f4

0801ae18 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
 801ae18:	b480      	push	{r7}
 801ae1a:	b083      	sub	sp, #12
 801ae1c:	af00      	add	r7, sp, #0
 801ae1e:	6078      	str	r0, [r7, #4]
    l->next = l->prev = l;
 801ae20:	687b      	ldr	r3, [r7, #4]
 801ae22:	687a      	ldr	r2, [r7, #4]
 801ae24:	605a      	str	r2, [r3, #4]
 801ae26:	687b      	ldr	r3, [r7, #4]
 801ae28:	685a      	ldr	r2, [r3, #4]
 801ae2a:	687b      	ldr	r3, [r7, #4]
 801ae2c:	601a      	str	r2, [r3, #0]
}
 801ae2e:	370c      	adds	r7, #12
 801ae30:	46bd      	mov	sp, r7
 801ae32:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ae36:	4770      	bx	lr

0801ae38 <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
 801ae38:	b480      	push	{r7}
 801ae3a:	b083      	sub	sp, #12
 801ae3c:	af00      	add	r7, sp, #0
 801ae3e:	6078      	str	r0, [r7, #4]
 801ae40:	6039      	str	r1, [r7, #0]
    l->next->prev = n;
 801ae42:	687b      	ldr	r3, [r7, #4]
 801ae44:	681b      	ldr	r3, [r3, #0]
 801ae46:	683a      	ldr	r2, [r7, #0]
 801ae48:	605a      	str	r2, [r3, #4]
    n->next = l->next;
 801ae4a:	687b      	ldr	r3, [r7, #4]
 801ae4c:	681a      	ldr	r2, [r3, #0]
 801ae4e:	683b      	ldr	r3, [r7, #0]
 801ae50:	601a      	str	r2, [r3, #0]

    l->next = n;
 801ae52:	687b      	ldr	r3, [r7, #4]
 801ae54:	683a      	ldr	r2, [r7, #0]
 801ae56:	601a      	str	r2, [r3, #0]
    n->prev = l;
 801ae58:	683b      	ldr	r3, [r7, #0]
 801ae5a:	687a      	ldr	r2, [r7, #4]
 801ae5c:	605a      	str	r2, [r3, #4]
}
 801ae5e:	370c      	adds	r7, #12
 801ae60:	46bd      	mov	sp, r7
 801ae62:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ae66:	4770      	bx	lr

0801ae68 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
 801ae68:	b480      	push	{r7}
 801ae6a:	b083      	sub	sp, #12
 801ae6c:	af00      	add	r7, sp, #0
 801ae6e:	6078      	str	r0, [r7, #4]
 801ae70:	6039      	str	r1, [r7, #0]
    l->prev->next = n;
 801ae72:	687b      	ldr	r3, [r7, #4]
 801ae74:	685b      	ldr	r3, [r3, #4]
 801ae76:	683a      	ldr	r2, [r7, #0]
 801ae78:	601a      	str	r2, [r3, #0]
    n->prev = l->prev;
 801ae7a:	687b      	ldr	r3, [r7, #4]
 801ae7c:	685a      	ldr	r2, [r3, #4]
 801ae7e:	683b      	ldr	r3, [r7, #0]
 801ae80:	605a      	str	r2, [r3, #4]

    l->prev = n;
 801ae82:	687b      	ldr	r3, [r7, #4]
 801ae84:	683a      	ldr	r2, [r7, #0]
 801ae86:	605a      	str	r2, [r3, #4]
    n->next = l;
 801ae88:	683b      	ldr	r3, [r7, #0]
 801ae8a:	687a      	ldr	r2, [r7, #4]
 801ae8c:	601a      	str	r2, [r3, #0]
}
 801ae8e:	370c      	adds	r7, #12
 801ae90:	46bd      	mov	sp, r7
 801ae92:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ae96:	4770      	bx	lr

0801ae98 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
 801ae98:	b480      	push	{r7}
 801ae9a:	b083      	sub	sp, #12
 801ae9c:	af00      	add	r7, sp, #0
 801ae9e:	6078      	str	r0, [r7, #4]
    n->next->prev = n->prev;
 801aea0:	687b      	ldr	r3, [r7, #4]
 801aea2:	681b      	ldr	r3, [r3, #0]
 801aea4:	687a      	ldr	r2, [r7, #4]
 801aea6:	6852      	ldr	r2, [r2, #4]
 801aea8:	605a      	str	r2, [r3, #4]
    n->prev->next = n->next;
 801aeaa:	687b      	ldr	r3, [r7, #4]
 801aeac:	685b      	ldr	r3, [r3, #4]
 801aeae:	687a      	ldr	r2, [r7, #4]
 801aeb0:	6812      	ldr	r2, [r2, #0]
 801aeb2:	601a      	str	r2, [r3, #0]

    n->next = n->prev = n;
 801aeb4:	687b      	ldr	r3, [r7, #4]
 801aeb6:	687a      	ldr	r2, [r7, #4]
 801aeb8:	605a      	str	r2, [r3, #4]
 801aeba:	687b      	ldr	r3, [r7, #4]
 801aebc:	685a      	ldr	r2, [r3, #4]
 801aebe:	687b      	ldr	r3, [r7, #4]
 801aec0:	601a      	str	r2, [r3, #0]
}
 801aec2:	370c      	adds	r7, #12
 801aec4:	46bd      	mov	sp, r7
 801aec6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801aeca:	4770      	bx	lr

0801aecc <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 801aecc:	b480      	push	{r7}
 801aece:	b083      	sub	sp, #12
 801aed0:	af00      	add	r7, sp, #0
 801aed2:	6078      	str	r0, [r7, #4]
    return l->next == l;
 801aed4:	687b      	ldr	r3, [r7, #4]
 801aed6:	681a      	ldr	r2, [r3, #0]
 801aed8:	687b      	ldr	r3, [r7, #4]
 801aeda:	429a      	cmp	r2, r3
 801aedc:	bf0c      	ite	eq
 801aede:	2301      	moveq	r3, #1
 801aee0:	2300      	movne	r3, #0
 801aee2:	b2db      	uxtb	r3, r3
}
 801aee4:	4618      	mov	r0, r3
 801aee6:	370c      	adds	r7, #12
 801aee8:	46bd      	mov	sp, r7
 801aeea:	f85d 7b04 	ldr.w	r7, [sp], #4
 801aeee:	4770      	bx	lr

0801aef0 <rt_can_init>:

#define CAN_LOCK(can)   rt_mutex_take(&(can->lock), RT_WAITING_FOREVER)
#define CAN_UNLOCK(can) rt_mutex_release(&(can->lock))

static rt_err_t rt_can_init(struct rt_device *dev)
{
 801aef0:	b580      	push	{r7, lr}
 801aef2:	b084      	sub	sp, #16
 801aef4:	af00      	add	r7, sp, #0
 801aef6:	6078      	str	r0, [r7, #4]
    rt_err_t result = RT_EOK;
 801aef8:	2300      	movs	r3, #0
 801aefa:	60fb      	str	r3, [r7, #12]
    struct rt_can_device *can;

    RT_ASSERT(dev != RT_NULL);
 801aefc:	687b      	ldr	r3, [r7, #4]
 801aefe:	2b00      	cmp	r3, #0
 801af00:	d104      	bne.n	801af0c <rt_can_init+0x1c>
 801af02:	4811      	ldr	r0, [pc, #68]	; (801af48 <rt_can_init+0x58>)
 801af04:	4911      	ldr	r1, [pc, #68]	; (801af4c <rt_can_init+0x5c>)
 801af06:	2226      	movs	r2, #38	; 0x26
 801af08:	f7fc f97c 	bl	8017204 <rt_assert_handler>
    can = (struct rt_can_device *)dev;
 801af0c:	687b      	ldr	r3, [r7, #4]
 801af0e:	60bb      	str	r3, [r7, #8]

    /* initialize rx/tx */
    can->can_rx = RT_NULL;
 801af10:	68bb      	ldr	r3, [r7, #8]
 801af12:	2200      	movs	r2, #0
 801af14:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
    can->can_tx = RT_NULL;
 801af18:	68bb      	ldr	r3, [r7, #8]
 801af1a:	2200      	movs	r2, #0
 801af1c:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4

    /* apply configuration */
    if (can->ops->configure)
 801af20:	68bb      	ldr	r3, [r7, #8]
 801af22:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801af24:	681b      	ldr	r3, [r3, #0]
 801af26:	2b00      	cmp	r3, #0
 801af28:	d008      	beq.n	801af3c <rt_can_init+0x4c>
        result = can->ops->configure(can, &can->config);
 801af2a:	68bb      	ldr	r3, [r7, #8]
 801af2c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801af2e:	681b      	ldr	r3, [r3, #0]
 801af30:	68ba      	ldr	r2, [r7, #8]
 801af32:	3244      	adds	r2, #68	; 0x44
 801af34:	68b8      	ldr	r0, [r7, #8]
 801af36:	4611      	mov	r1, r2
 801af38:	4798      	blx	r3
 801af3a:	60f8      	str	r0, [r7, #12]

    return result;
 801af3c:	68fb      	ldr	r3, [r7, #12]
}
 801af3e:	4618      	mov	r0, r3
 801af40:	3710      	adds	r7, #16
 801af42:	46bd      	mov	sp, r7
 801af44:	bd80      	pop	{r7, pc}
 801af46:	bf00      	nop
 801af48:	08029828 	.word	0x08029828
 801af4c:	0802ae78 	.word	0x0802ae78

0801af50 <_can_int_rx>:

/*
 * can interrupt routines
 */
rt_inline int _can_int_rx(struct rt_can_device *can, struct rt_can_msg *data, int msgs)
{
 801af50:	b580      	push	{r7, lr}
 801af52:	b088      	sub	sp, #32
 801af54:	af00      	add	r7, sp, #0
 801af56:	60f8      	str	r0, [r7, #12]
 801af58:	60b9      	str	r1, [r7, #8]
 801af5a:	607a      	str	r2, [r7, #4]
    int size;
    struct rt_can_rx_fifo *rx_fifo;
    RT_ASSERT(can != RT_NULL);
 801af5c:	68fb      	ldr	r3, [r7, #12]
 801af5e:	2b00      	cmp	r3, #0
 801af60:	d104      	bne.n	801af6c <_can_int_rx+0x1c>
 801af62:	4836      	ldr	r0, [pc, #216]	; (801b03c <_can_int_rx+0xec>)
 801af64:	4936      	ldr	r1, [pc, #216]	; (801b040 <_can_int_rx+0xf0>)
 801af66:	223b      	movs	r2, #59	; 0x3b
 801af68:	f7fc f94c 	bl	8017204 <rt_assert_handler>
    size = msgs;
 801af6c:	687b      	ldr	r3, [r7, #4]
 801af6e:	61fb      	str	r3, [r7, #28]

    rx_fifo = (struct rt_can_rx_fifo *) can->can_rx;
 801af70:	68fb      	ldr	r3, [r7, #12]
 801af72:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 801af76:	61bb      	str	r3, [r7, #24]
    RT_ASSERT(rx_fifo != RT_NULL);
 801af78:	69bb      	ldr	r3, [r7, #24]
 801af7a:	2b00      	cmp	r3, #0
 801af7c:	d104      	bne.n	801af88 <_can_int_rx+0x38>
 801af7e:	4831      	ldr	r0, [pc, #196]	; (801b044 <_can_int_rx+0xf4>)
 801af80:	492f      	ldr	r1, [pc, #188]	; (801b040 <_can_int_rx+0xf0>)
 801af82:	223f      	movs	r2, #63	; 0x3f
 801af84:	f7fc f93e 	bl	8017204 <rt_assert_handler>

    /* read from software FIFO */
    while (msgs)
 801af88:	e04d      	b.n	801b026 <_can_int_rx+0xd6>
    {
        rt_base_t level;
#ifdef RT_CAN_USING_HDR
        rt_int32_t hdr;
#endif /*RT_CAN_USING_HDR*/
        struct rt_can_msg_list *listmsg = RT_NULL;
 801af8a:	2300      	movs	r3, #0
 801af8c:	617b      	str	r3, [r7, #20]

        /* disable interrupt */
        level = rt_hw_interrupt_disable();
 801af8e:	f7e5 f91d 	bl	80001cc <rt_hw_interrupt_disable>
 801af92:	6138      	str	r0, [r7, #16]
            listmsg->owner = RT_NULL;
        }
        else if (hdr == -1)
#endif /*RT_CAN_USING_HDR*/
        {
            if (!rt_list_isempty(&rx_fifo->uselist))
 801af94:	69bb      	ldr	r3, [r7, #24]
 801af96:	3310      	adds	r3, #16
 801af98:	4618      	mov	r0, r3
 801af9a:	f7ff ff97 	bl	801aecc <rt_list_isempty>
 801af9e:	4603      	mov	r3, r0
 801afa0:	2b00      	cmp	r3, #0
 801afa2:	d10d      	bne.n	801afc0 <_can_int_rx+0x70>
            {
                listmsg = rt_list_entry(rx_fifo->uselist.next, struct rt_can_msg_list, list);
 801afa4:	69bb      	ldr	r3, [r7, #24]
 801afa6:	691b      	ldr	r3, [r3, #16]
 801afa8:	617b      	str	r3, [r7, #20]
                rt_list_remove(&listmsg->list);
 801afaa:	697b      	ldr	r3, [r7, #20]
 801afac:	4618      	mov	r0, r3
 801afae:	f7ff ff73 	bl	801ae98 <rt_list_remove>
                break;
            }
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
 801afb2:	6938      	ldr	r0, [r7, #16]
 801afb4:	f7e5 f90e 	bl	80001d4 <rt_hw_interrupt_enable>
        if (listmsg != RT_NULL)
 801afb8:	697b      	ldr	r3, [r7, #20]
 801afba:	2b00      	cmp	r3, #0
 801afbc:	d02c      	beq.n	801b018 <_can_int_rx+0xc8>
 801afbe:	e003      	b.n	801afc8 <_can_int_rx+0x78>
#endif /*RT_CAN_USING_HDR*/
            }
            else
            {
                /* no data, enable interrupt and break out */
                rt_hw_interrupt_enable(level);
 801afc0:	6938      	ldr	r0, [r7, #16]
 801afc2:	f7e5 f907 	bl	80001d4 <rt_hw_interrupt_enable>
                break;
 801afc6:	e031      	b.n	801b02c <_can_int_rx+0xdc>

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
        if (listmsg != RT_NULL)
        {
            rt_memcpy(data, &listmsg->data, sizeof(struct rt_can_msg));
 801afc8:	697b      	ldr	r3, [r7, #20]
 801afca:	3308      	adds	r3, #8
 801afcc:	68b8      	ldr	r0, [r7, #8]
 801afce:	4619      	mov	r1, r3
 801afd0:	2210      	movs	r2, #16
 801afd2:	f7fb fb41 	bl	8016658 <rt_memcpy>

            level = rt_hw_interrupt_disable();
 801afd6:	f7e5 f8f9 	bl	80001cc <rt_hw_interrupt_disable>
 801afda:	6138      	str	r0, [r7, #16]
            rt_list_insert_before(&rx_fifo->freelist, &listmsg->list);
 801afdc:	69bb      	ldr	r3, [r7, #24]
 801afde:	f103 0208 	add.w	r2, r3, #8
 801afe2:	697b      	ldr	r3, [r7, #20]
 801afe4:	4610      	mov	r0, r2
 801afe6:	4619      	mov	r1, r3
 801afe8:	f7ff ff3e 	bl	801ae68 <rt_list_insert_before>
            rx_fifo->freenumbers++;
 801afec:	69bb      	ldr	r3, [r7, #24]
 801afee:	685b      	ldr	r3, [r3, #4]
 801aff0:	1c5a      	adds	r2, r3, #1
 801aff2:	69bb      	ldr	r3, [r7, #24]
 801aff4:	605a      	str	r2, [r3, #4]
            RT_ASSERT(rx_fifo->freenumbers <= can->config.msgboxsz);
 801aff6:	69bb      	ldr	r3, [r7, #24]
 801aff8:	685a      	ldr	r2, [r3, #4]
 801affa:	68fb      	ldr	r3, [r7, #12]
 801affc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801affe:	429a      	cmp	r2, r3
 801b000:	d904      	bls.n	801b00c <_can_int_rx+0xbc>
 801b002:	4811      	ldr	r0, [pc, #68]	; (801b048 <_can_int_rx+0xf8>)
 801b004:	490e      	ldr	r1, [pc, #56]	; (801b040 <_can_int_rx+0xf0>)
 801b006:	227b      	movs	r2, #123	; 0x7b
 801b008:	f7fc f8fc 	bl	8017204 <rt_assert_handler>
            rt_hw_interrupt_enable(level);
 801b00c:	6938      	ldr	r0, [r7, #16]
 801b00e:	f7e5 f8e1 	bl	80001d4 <rt_hw_interrupt_enable>

            listmsg = RT_NULL;
 801b012:	2300      	movs	r3, #0
 801b014:	617b      	str	r3, [r7, #20]
 801b016:	e000      	b.n	801b01a <_can_int_rx+0xca>
        }
        else
        {
            break;
 801b018:	e008      	b.n	801b02c <_can_int_rx+0xdc>
        }
        data ++;
 801b01a:	68bb      	ldr	r3, [r7, #8]
 801b01c:	3310      	adds	r3, #16
 801b01e:	60bb      	str	r3, [r7, #8]
        msgs -= sizeof(struct rt_can_msg);
 801b020:	687b      	ldr	r3, [r7, #4]
 801b022:	3b10      	subs	r3, #16
 801b024:	607b      	str	r3, [r7, #4]

    rx_fifo = (struct rt_can_rx_fifo *) can->can_rx;
    RT_ASSERT(rx_fifo != RT_NULL);

    /* read from software FIFO */
    while (msgs)
 801b026:	687b      	ldr	r3, [r7, #4]
 801b028:	2b00      	cmp	r3, #0
 801b02a:	d1ae      	bne.n	801af8a <_can_int_rx+0x3a>
        }
        data ++;
        msgs -= sizeof(struct rt_can_msg);
    }

    return (size - msgs);
 801b02c:	69fa      	ldr	r2, [r7, #28]
 801b02e:	687b      	ldr	r3, [r7, #4]
 801b030:	1ad3      	subs	r3, r2, r3
}
 801b032:	4618      	mov	r0, r3
 801b034:	3720      	adds	r7, #32
 801b036:	46bd      	mov	sp, r7
 801b038:	bd80      	pop	{r7, pc}
 801b03a:	bf00      	nop
 801b03c:	08029838 	.word	0x08029838
 801b040:	0802aeac 	.word	0x0802aeac
 801b044:	08029848 	.word	0x08029848
 801b048:	0802985c 	.word	0x0802985c

0801b04c <_can_int_tx>:

rt_inline int _can_int_tx(struct rt_can_device *can, const struct rt_can_msg *data, int msgs)
{
 801b04c:	b580      	push	{r7, lr}
 801b04e:	b08a      	sub	sp, #40	; 0x28
 801b050:	af00      	add	r7, sp, #0
 801b052:	60f8      	str	r0, [r7, #12]
 801b054:	60b9      	str	r1, [r7, #8]
 801b056:	607a      	str	r2, [r7, #4]
    int size;
    struct rt_can_tx_fifo *tx_fifo;

    RT_ASSERT(can != RT_NULL);
 801b058:	68fb      	ldr	r3, [r7, #12]
 801b05a:	2b00      	cmp	r3, #0
 801b05c:	d104      	bne.n	801b068 <_can_int_tx+0x1c>
 801b05e:	485f      	ldr	r0, [pc, #380]	; (801b1dc <_can_int_tx+0x190>)
 801b060:	495f      	ldr	r1, [pc, #380]	; (801b1e0 <_can_int_tx+0x194>)
 801b062:	2290      	movs	r2, #144	; 0x90
 801b064:	f7fc f8ce 	bl	8017204 <rt_assert_handler>

    size = msgs;
 801b068:	687b      	ldr	r3, [r7, #4]
 801b06a:	627b      	str	r3, [r7, #36]	; 0x24
    tx_fifo = (struct rt_can_tx_fifo *) can->can_tx;
 801b06c:	68fb      	ldr	r3, [r7, #12]
 801b06e:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 801b072:	623b      	str	r3, [r7, #32]
    RT_ASSERT(tx_fifo != RT_NULL);
 801b074:	6a3b      	ldr	r3, [r7, #32]
 801b076:	2b00      	cmp	r3, #0
 801b078:	d104      	bne.n	801b084 <_can_int_tx+0x38>
 801b07a:	485a      	ldr	r0, [pc, #360]	; (801b1e4 <_can_int_tx+0x198>)
 801b07c:	4958      	ldr	r1, [pc, #352]	; (801b1e0 <_can_int_tx+0x194>)
 801b07e:	2294      	movs	r2, #148	; 0x94
 801b080:	f7fc f8c0 	bl	8017204 <rt_assert_handler>

    while (msgs)
 801b084:	e09f      	b.n	801b1c6 <_can_int_tx+0x17a>
    {
        rt_base_t level;
        rt_uint32_t no;
        rt_uint32_t result;
        struct rt_can_sndbxinx_list *tx_tosnd = RT_NULL;
 801b086:	2300      	movs	r3, #0
 801b088:	61fb      	str	r3, [r7, #28]

        level = rt_hw_interrupt_disable();
 801b08a:	f7e5 f89f 	bl	80001cc <rt_hw_interrupt_disable>
 801b08e:	61b8      	str	r0, [r7, #24]
        if (!rt_list_isempty(&tx_fifo->freelist))
 801b090:	6a3b      	ldr	r3, [r7, #32]
 801b092:	3310      	adds	r3, #16
 801b094:	4618      	mov	r0, r3
 801b096:	f7ff ff19 	bl	801aecc <rt_list_isempty>
 801b09a:	4603      	mov	r3, r0
 801b09c:	2b00      	cmp	r3, #0
 801b09e:	d128      	bne.n	801b0f2 <_can_int_tx+0xa6>
        {
            tx_tosnd = rt_list_entry(tx_fifo->freelist.next, struct rt_can_sndbxinx_list, list);
 801b0a0:	6a3b      	ldr	r3, [r7, #32]
 801b0a2:	691b      	ldr	r3, [r3, #16]
 801b0a4:	61fb      	str	r3, [r7, #28]
            RT_ASSERT(tx_tosnd != RT_NULL);
 801b0a6:	69fb      	ldr	r3, [r7, #28]
 801b0a8:	2b00      	cmp	r3, #0
 801b0aa:	d104      	bne.n	801b0b6 <_can_int_tx+0x6a>
 801b0ac:	484e      	ldr	r0, [pc, #312]	; (801b1e8 <_can_int_tx+0x19c>)
 801b0ae:	494c      	ldr	r1, [pc, #304]	; (801b1e0 <_can_int_tx+0x194>)
 801b0b0:	22a1      	movs	r2, #161	; 0xa1
 801b0b2:	f7fc f8a7 	bl	8017204 <rt_assert_handler>
            rt_list_remove(&tx_tosnd->list);
 801b0b6:	69fb      	ldr	r3, [r7, #28]
 801b0b8:	4618      	mov	r0, r3
 801b0ba:	f7ff feed 	bl	801ae98 <rt_list_remove>
            rt_hw_interrupt_enable(level);

            rt_completion_wait(&(tx_fifo->completion), RT_WAITING_FOREVER);
            continue;
        }
        rt_hw_interrupt_enable(level);
 801b0be:	69b8      	ldr	r0, [r7, #24]
 801b0c0:	f7e5 f888 	bl	80001d4 <rt_hw_interrupt_enable>

        no = ((rt_uint32_t)tx_tosnd - (rt_uint32_t)tx_fifo->buffer) / sizeof(struct rt_can_sndbxinx_list);
 801b0c4:	69fb      	ldr	r3, [r7, #28]
 801b0c6:	6a3a      	ldr	r2, [r7, #32]
 801b0c8:	6812      	ldr	r2, [r2, #0]
 801b0ca:	1a9b      	subs	r3, r3, r2
 801b0cc:	4a47      	ldr	r2, [pc, #284]	; (801b1ec <_can_int_tx+0x1a0>)
 801b0ce:	fba2 2303 	umull	r2, r3, r2, r3
 801b0d2:	091b      	lsrs	r3, r3, #4
 801b0d4:	617b      	str	r3, [r7, #20]
        tx_tosnd->result = RT_CAN_SND_RESULT_WAIT;
 801b0d6:	69fb      	ldr	r3, [r7, #28]
 801b0d8:	2202      	movs	r2, #2
 801b0da:	615a      	str	r2, [r3, #20]
        if (can->ops->sendmsg(can, data, no) != RT_EOK)
 801b0dc:	68fb      	ldr	r3, [r7, #12]
 801b0de:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b0e0:	689b      	ldr	r3, [r3, #8]
 801b0e2:	68f8      	ldr	r0, [r7, #12]
 801b0e4:	68b9      	ldr	r1, [r7, #8]
 801b0e6:	697a      	ldr	r2, [r7, #20]
 801b0e8:	4798      	blx	r3
 801b0ea:	4603      	mov	r3, r0
 801b0ec:	2b00      	cmp	r3, #0
 801b0ee:	d01a      	beq.n	801b126 <_can_int_tx+0xda>
 801b0f0:	e00a      	b.n	801b108 <_can_int_tx+0xbc>
            RT_ASSERT(tx_tosnd != RT_NULL);
            rt_list_remove(&tx_tosnd->list);
        }
        else
        {
            rt_hw_interrupt_enable(level);
 801b0f2:	69b8      	ldr	r0, [r7, #24]
 801b0f4:	f7e5 f86e 	bl	80001d4 <rt_hw_interrupt_enable>

            rt_completion_wait(&(tx_fifo->completion), RT_WAITING_FOREVER);
 801b0f8:	6a3b      	ldr	r3, [r7, #32]
 801b0fa:	3304      	adds	r3, #4
 801b0fc:	4618      	mov	r0, r3
 801b0fe:	f04f 31ff 	mov.w	r1, #4294967295
 801b102:	f7fe fa47 	bl	8019594 <rt_completion_wait>
            continue;
 801b106:	e05e      	b.n	801b1c6 <_can_int_tx+0x17a>
        no = ((rt_uint32_t)tx_tosnd - (rt_uint32_t)tx_fifo->buffer) / sizeof(struct rt_can_sndbxinx_list);
        tx_tosnd->result = RT_CAN_SND_RESULT_WAIT;
        if (can->ops->sendmsg(can, data, no) != RT_EOK)
        {
            /* send failed. */
            level = rt_hw_interrupt_disable();
 801b108:	f7e5 f860 	bl	80001cc <rt_hw_interrupt_disable>
 801b10c:	61b8      	str	r0, [r7, #24]
            rt_list_insert_after(&tx_fifo->freelist, &tx_tosnd->list);
 801b10e:	6a3b      	ldr	r3, [r7, #32]
 801b110:	f103 0210 	add.w	r2, r3, #16
 801b114:	69fb      	ldr	r3, [r7, #28]
 801b116:	4610      	mov	r0, r2
 801b118:	4619      	mov	r1, r3
 801b11a:	f7ff fe8d 	bl	801ae38 <rt_list_insert_after>
            rt_hw_interrupt_enable(level);
 801b11e:	69b8      	ldr	r0, [r7, #24]
 801b120:	f7e5 f858 	bl	80001d4 <rt_hw_interrupt_enable>
            continue;
 801b124:	e04f      	b.n	801b1c6 <_can_int_tx+0x17a>
        }

        can->status.sndchange = 1;
 801b126:	68fb      	ldr	r3, [r7, #12]
 801b128:	2201      	movs	r2, #1
 801b12a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        rt_completion_wait(&(tx_tosnd->completion), RT_WAITING_FOREVER);
 801b12e:	69fb      	ldr	r3, [r7, #28]
 801b130:	3308      	adds	r3, #8
 801b132:	4618      	mov	r0, r3
 801b134:	f04f 31ff 	mov.w	r1, #4294967295
 801b138:	f7fe fa2c 	bl	8019594 <rt_completion_wait>

        level = rt_hw_interrupt_disable();
 801b13c:	f7e5 f846 	bl	80001cc <rt_hw_interrupt_disable>
 801b140:	61b8      	str	r0, [r7, #24]
        result = tx_tosnd->result;
 801b142:	69fb      	ldr	r3, [r7, #28]
 801b144:	695b      	ldr	r3, [r3, #20]
 801b146:	613b      	str	r3, [r7, #16]
        if (!rt_list_isempty(&tx_tosnd->list))
 801b148:	69fb      	ldr	r3, [r7, #28]
 801b14a:	4618      	mov	r0, r3
 801b14c:	f7ff febe 	bl	801aecc <rt_list_isempty>
 801b150:	4603      	mov	r3, r0
 801b152:	2b00      	cmp	r3, #0
 801b154:	d103      	bne.n	801b15e <_can_int_tx+0x112>
        {
            rt_list_remove(&tx_tosnd->list);
 801b156:	69fb      	ldr	r3, [r7, #28]
 801b158:	4618      	mov	r0, r3
 801b15a:	f7ff fe9d 	bl	801ae98 <rt_list_remove>
        }
        rt_list_insert_before(&tx_fifo->freelist, &tx_tosnd->list);
 801b15e:	6a3b      	ldr	r3, [r7, #32]
 801b160:	f103 0210 	add.w	r2, r3, #16
 801b164:	69fb      	ldr	r3, [r7, #28]
 801b166:	4610      	mov	r0, r2
 801b168:	4619      	mov	r1, r3
 801b16a:	f7ff fe7d 	bl	801ae68 <rt_list_insert_before>
        rt_completion_done(&(tx_fifo->completion));
 801b16e:	6a3b      	ldr	r3, [r7, #32]
 801b170:	3304      	adds	r3, #4
 801b172:	4618      	mov	r0, r3
 801b174:	f7fe fa8e 	bl	8019694 <rt_completion_done>
        rt_hw_interrupt_enable(level);
 801b178:	69b8      	ldr	r0, [r7, #24]
 801b17a:	f7e5 f82b 	bl	80001d4 <rt_hw_interrupt_enable>

        if (result == RT_CAN_SND_RESULT_OK)
 801b17e:	693b      	ldr	r3, [r7, #16]
 801b180:	2b00      	cmp	r3, #0
 801b182:	d114      	bne.n	801b1ae <_can_int_tx+0x162>
        {
            level = rt_hw_interrupt_disable();
 801b184:	f7e5 f822 	bl	80001cc <rt_hw_interrupt_disable>
 801b188:	61b8      	str	r0, [r7, #24]
            can->status.sndpkg++;
 801b18a:	68fb      	ldr	r3, [r7, #12]
 801b18c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 801b18e:	1c5a      	adds	r2, r3, #1
 801b190:	68fb      	ldr	r3, [r7, #12]
 801b192:	66da      	str	r2, [r3, #108]	; 0x6c
            rt_hw_interrupt_enable(level);
 801b194:	69b8      	ldr	r0, [r7, #24]
 801b196:	f7e5 f81d 	bl	80001d4 <rt_hw_interrupt_enable>

            data ++;
 801b19a:	68bb      	ldr	r3, [r7, #8]
 801b19c:	3310      	adds	r3, #16
 801b19e:	60bb      	str	r3, [r7, #8]
            msgs -= sizeof(struct rt_can_msg);
 801b1a0:	687b      	ldr	r3, [r7, #4]
 801b1a2:	3b10      	subs	r3, #16
 801b1a4:	607b      	str	r3, [r7, #4]
            if (!msgs) break;
 801b1a6:	687b      	ldr	r3, [r7, #4]
 801b1a8:	2b00      	cmp	r3, #0
 801b1aa:	d10c      	bne.n	801b1c6 <_can_int_tx+0x17a>
 801b1ac:	e00f      	b.n	801b1ce <_can_int_tx+0x182>
        }
        else
        {
            level = rt_hw_interrupt_disable();
 801b1ae:	f7e5 f80d 	bl	80001cc <rt_hw_interrupt_disable>
 801b1b2:	61b8      	str	r0, [r7, #24]
            can->status.dropedsndpkg++;
 801b1b4:	68fb      	ldr	r3, [r7, #12]
 801b1b6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801b1b8:	1c5a      	adds	r2, r3, #1
 801b1ba:	68fb      	ldr	r3, [r7, #12]
 801b1bc:	671a      	str	r2, [r3, #112]	; 0x70
            rt_hw_interrupt_enable(level);
 801b1be:	69b8      	ldr	r0, [r7, #24]
 801b1c0:	f7e5 f808 	bl	80001d4 <rt_hw_interrupt_enable>
            break;
 801b1c4:	e003      	b.n	801b1ce <_can_int_tx+0x182>

    size = msgs;
    tx_fifo = (struct rt_can_tx_fifo *) can->can_tx;
    RT_ASSERT(tx_fifo != RT_NULL);

    while (msgs)
 801b1c6:	687b      	ldr	r3, [r7, #4]
 801b1c8:	2b00      	cmp	r3, #0
 801b1ca:	f47f af5c 	bne.w	801b086 <_can_int_tx+0x3a>
            rt_hw_interrupt_enable(level);
            break;
        }
    }

    return (size - msgs);
 801b1ce:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801b1d0:	687b      	ldr	r3, [r7, #4]
 801b1d2:	1ad3      	subs	r3, r2, r3
}
 801b1d4:	4618      	mov	r0, r3
 801b1d6:	3728      	adds	r7, #40	; 0x28
 801b1d8:	46bd      	mov	sp, r7
 801b1da:	bd80      	pop	{r7, pc}
 801b1dc:	08029838 	.word	0x08029838
 801b1e0:	0802aedc 	.word	0x0802aedc
 801b1e4:	0802988c 	.word	0x0802988c
 801b1e8:	080298a0 	.word	0x080298a0
 801b1ec:	aaaaaaab 	.word	0xaaaaaaab

0801b1f0 <_can_int_tx_priv>:

rt_inline int _can_int_tx_priv(struct rt_can_device *can, const struct rt_can_msg *data, int msgs)
{
 801b1f0:	b580      	push	{r7, lr}
 801b1f2:	b08a      	sub	sp, #40	; 0x28
 801b1f4:	af00      	add	r7, sp, #0
 801b1f6:	60f8      	str	r0, [r7, #12]
 801b1f8:	60b9      	str	r1, [r7, #8]
 801b1fa:	607a      	str	r2, [r7, #4]
    int size;
    rt_base_t level;
    rt_uint32_t no, result;
    struct rt_can_tx_fifo *tx_fifo;

    RT_ASSERT(can != RT_NULL);
 801b1fc:	68fb      	ldr	r3, [r7, #12]
 801b1fe:	2b00      	cmp	r3, #0
 801b200:	d104      	bne.n	801b20c <_can_int_tx_priv+0x1c>
 801b202:	4850      	ldr	r0, [pc, #320]	; (801b344 <_can_int_tx_priv+0x154>)
 801b204:	4950      	ldr	r1, [pc, #320]	; (801b348 <_can_int_tx_priv+0x158>)
 801b206:	22e2      	movs	r2, #226	; 0xe2
 801b208:	f7fb fffc 	bl	8017204 <rt_assert_handler>

    size = msgs;
 801b20c:	687b      	ldr	r3, [r7, #4]
 801b20e:	627b      	str	r3, [r7, #36]	; 0x24
    tx_fifo = (struct rt_can_tx_fifo *) can->can_tx;
 801b210:	68fb      	ldr	r3, [r7, #12]
 801b212:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 801b216:	623b      	str	r3, [r7, #32]
    RT_ASSERT(tx_fifo != RT_NULL);
 801b218:	6a3b      	ldr	r3, [r7, #32]
 801b21a:	2b00      	cmp	r3, #0
 801b21c:	d104      	bne.n	801b228 <_can_int_tx_priv+0x38>
 801b21e:	484b      	ldr	r0, [pc, #300]	; (801b34c <_can_int_tx_priv+0x15c>)
 801b220:	4949      	ldr	r1, [pc, #292]	; (801b348 <_can_int_tx_priv+0x158>)
 801b222:	22e6      	movs	r2, #230	; 0xe6
 801b224:	f7fb ffee 	bl	8017204 <rt_assert_handler>

    while (msgs)
 801b228:	e080      	b.n	801b32c <_can_int_tx_priv+0x13c>
    {
        no = data->priv;
 801b22a:	68bb      	ldr	r3, [r7, #8]
 801b22c:	795b      	ldrb	r3, [r3, #5]
 801b22e:	61fb      	str	r3, [r7, #28]
        if (no >= can->config.sndboxnumber)
 801b230:	68fb      	ldr	r3, [r7, #12]
 801b232:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801b234:	69fb      	ldr	r3, [r7, #28]
 801b236:	429a      	cmp	r2, r3
 801b238:	d800      	bhi.n	801b23c <_can_int_tx_priv+0x4c>
        {
            break;
 801b23a:	e07b      	b.n	801b334 <_can_int_tx_priv+0x144>
        }

        level = rt_hw_interrupt_disable();
 801b23c:	f7e4 ffc6 	bl	80001cc <rt_hw_interrupt_disable>
 801b240:	61b8      	str	r0, [r7, #24]
        if ((tx_fifo->buffer[no].result != RT_CAN_SND_RESULT_OK))
 801b242:	6a3b      	ldr	r3, [r7, #32]
 801b244:	6819      	ldr	r1, [r3, #0]
 801b246:	69fa      	ldr	r2, [r7, #28]
 801b248:	4613      	mov	r3, r2
 801b24a:	005b      	lsls	r3, r3, #1
 801b24c:	4413      	add	r3, r2
 801b24e:	00db      	lsls	r3, r3, #3
 801b250:	440b      	add	r3, r1
 801b252:	695b      	ldr	r3, [r3, #20]
 801b254:	2b00      	cmp	r3, #0
 801b256:	d011      	beq.n	801b27c <_can_int_tx_priv+0x8c>
        {
            rt_hw_interrupt_enable(level);
 801b258:	69b8      	ldr	r0, [r7, #24]
 801b25a:	f7e4 ffbb 	bl	80001d4 <rt_hw_interrupt_enable>

            rt_completion_wait(&(tx_fifo->buffer[no].completion), RT_WAITING_FOREVER);
 801b25e:	6a3b      	ldr	r3, [r7, #32]
 801b260:	6819      	ldr	r1, [r3, #0]
 801b262:	69fa      	ldr	r2, [r7, #28]
 801b264:	4613      	mov	r3, r2
 801b266:	005b      	lsls	r3, r3, #1
 801b268:	4413      	add	r3, r2
 801b26a:	00db      	lsls	r3, r3, #3
 801b26c:	440b      	add	r3, r1
 801b26e:	3308      	adds	r3, #8
 801b270:	4618      	mov	r0, r3
 801b272:	f04f 31ff 	mov.w	r1, #4294967295
 801b276:	f7fe f98d 	bl	8019594 <rt_completion_wait>
            continue;
 801b27a:	e057      	b.n	801b32c <_can_int_tx_priv+0x13c>
        }
        tx_fifo->buffer[no].result = RT_CAN_SND_RESULT_WAIT;
 801b27c:	6a3b      	ldr	r3, [r7, #32]
 801b27e:	6819      	ldr	r1, [r3, #0]
 801b280:	69fa      	ldr	r2, [r7, #28]
 801b282:	4613      	mov	r3, r2
 801b284:	005b      	lsls	r3, r3, #1
 801b286:	4413      	add	r3, r2
 801b288:	00db      	lsls	r3, r3, #3
 801b28a:	440b      	add	r3, r1
 801b28c:	2202      	movs	r2, #2
 801b28e:	615a      	str	r2, [r3, #20]
        rt_hw_interrupt_enable(level);
 801b290:	69b8      	ldr	r0, [r7, #24]
 801b292:	f7e4 ff9f 	bl	80001d4 <rt_hw_interrupt_enable>

        if (can->ops->sendmsg(can, data, no) != RT_EOK)
 801b296:	68fb      	ldr	r3, [r7, #12]
 801b298:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b29a:	689b      	ldr	r3, [r3, #8]
 801b29c:	68f8      	ldr	r0, [r7, #12]
 801b29e:	68b9      	ldr	r1, [r7, #8]
 801b2a0:	69fa      	ldr	r2, [r7, #28]
 801b2a2:	4798      	blx	r3
 801b2a4:	4603      	mov	r3, r0
 801b2a6:	2b00      	cmp	r3, #0
 801b2a8:	d000      	beq.n	801b2ac <_can_int_tx_priv+0xbc>
        {
            continue;
 801b2aa:	e03f      	b.n	801b32c <_can_int_tx_priv+0x13c>
        }
        can->status.sndchange = 1;
 801b2ac:	68fb      	ldr	r3, [r7, #12]
 801b2ae:	2201      	movs	r2, #1
 801b2b0:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        rt_completion_wait(&(tx_fifo->buffer[no].completion), RT_WAITING_FOREVER);
 801b2b4:	6a3b      	ldr	r3, [r7, #32]
 801b2b6:	6819      	ldr	r1, [r3, #0]
 801b2b8:	69fa      	ldr	r2, [r7, #28]
 801b2ba:	4613      	mov	r3, r2
 801b2bc:	005b      	lsls	r3, r3, #1
 801b2be:	4413      	add	r3, r2
 801b2c0:	00db      	lsls	r3, r3, #3
 801b2c2:	440b      	add	r3, r1
 801b2c4:	3308      	adds	r3, #8
 801b2c6:	4618      	mov	r0, r3
 801b2c8:	f04f 31ff 	mov.w	r1, #4294967295
 801b2cc:	f7fe f962 	bl	8019594 <rt_completion_wait>

        result = tx_fifo->buffer[no].result;
 801b2d0:	6a3b      	ldr	r3, [r7, #32]
 801b2d2:	6819      	ldr	r1, [r3, #0]
 801b2d4:	69fa      	ldr	r2, [r7, #28]
 801b2d6:	4613      	mov	r3, r2
 801b2d8:	005b      	lsls	r3, r3, #1
 801b2da:	4413      	add	r3, r2
 801b2dc:	00db      	lsls	r3, r3, #3
 801b2de:	440b      	add	r3, r1
 801b2e0:	695b      	ldr	r3, [r3, #20]
 801b2e2:	617b      	str	r3, [r7, #20]
        if (result == RT_CAN_SND_RESULT_OK)
 801b2e4:	697b      	ldr	r3, [r7, #20]
 801b2e6:	2b00      	cmp	r3, #0
 801b2e8:	d114      	bne.n	801b314 <_can_int_tx_priv+0x124>
        {
            level = rt_hw_interrupt_disable();
 801b2ea:	f7e4 ff6f 	bl	80001cc <rt_hw_interrupt_disable>
 801b2ee:	61b8      	str	r0, [r7, #24]
            can->status.sndpkg++;
 801b2f0:	68fb      	ldr	r3, [r7, #12]
 801b2f2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 801b2f4:	1c5a      	adds	r2, r3, #1
 801b2f6:	68fb      	ldr	r3, [r7, #12]
 801b2f8:	66da      	str	r2, [r3, #108]	; 0x6c
            rt_hw_interrupt_enable(level);
 801b2fa:	69b8      	ldr	r0, [r7, #24]
 801b2fc:	f7e4 ff6a 	bl	80001d4 <rt_hw_interrupt_enable>
            data ++;
 801b300:	68bb      	ldr	r3, [r7, #8]
 801b302:	3310      	adds	r3, #16
 801b304:	60bb      	str	r3, [r7, #8]
            msgs -= sizeof(struct rt_can_msg);
 801b306:	687b      	ldr	r3, [r7, #4]
 801b308:	3b10      	subs	r3, #16
 801b30a:	607b      	str	r3, [r7, #4]
            if (!msgs) break;
 801b30c:	687b      	ldr	r3, [r7, #4]
 801b30e:	2b00      	cmp	r3, #0
 801b310:	d10c      	bne.n	801b32c <_can_int_tx_priv+0x13c>
 801b312:	e00f      	b.n	801b334 <_can_int_tx_priv+0x144>
        }
        else
        {
            level = rt_hw_interrupt_disable();
 801b314:	f7e4 ff5a 	bl	80001cc <rt_hw_interrupt_disable>
 801b318:	61b8      	str	r0, [r7, #24]
            can->status.dropedsndpkg++;
 801b31a:	68fb      	ldr	r3, [r7, #12]
 801b31c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801b31e:	1c5a      	adds	r2, r3, #1
 801b320:	68fb      	ldr	r3, [r7, #12]
 801b322:	671a      	str	r2, [r3, #112]	; 0x70
            rt_hw_interrupt_enable(level);
 801b324:	69b8      	ldr	r0, [r7, #24]
 801b326:	f7e4 ff55 	bl	80001d4 <rt_hw_interrupt_enable>
            break;
 801b32a:	e003      	b.n	801b334 <_can_int_tx_priv+0x144>

    size = msgs;
    tx_fifo = (struct rt_can_tx_fifo *) can->can_tx;
    RT_ASSERT(tx_fifo != RT_NULL);

    while (msgs)
 801b32c:	687b      	ldr	r3, [r7, #4]
 801b32e:	2b00      	cmp	r3, #0
 801b330:	f47f af7b 	bne.w	801b22a <_can_int_tx_priv+0x3a>
            rt_hw_interrupt_enable(level);
            break;
        }
    }

    return (size - msgs);
 801b334:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801b336:	687b      	ldr	r3, [r7, #4]
 801b338:	1ad3      	subs	r3, r2, r3
}
 801b33a:	4618      	mov	r0, r3
 801b33c:	3728      	adds	r7, #40	; 0x28
 801b33e:	46bd      	mov	sp, r7
 801b340:	bd80      	pop	{r7, pc}
 801b342:	bf00      	nop
 801b344:	08029838 	.word	0x08029838
 801b348:	0802aec8 	.word	0x0802aec8
 801b34c:	0802988c 	.word	0x0802988c

0801b350 <rt_can_open>:

static rt_err_t rt_can_open(struct rt_device *dev, rt_uint16_t oflag)
{
 801b350:	b580      	push	{r7, lr}
 801b352:	b088      	sub	sp, #32
 801b354:	af00      	add	r7, sp, #0
 801b356:	6078      	str	r0, [r7, #4]
 801b358:	460b      	mov	r3, r1
 801b35a:	807b      	strh	r3, [r7, #2]
    struct rt_can_device *can;

    RT_ASSERT(dev != RT_NULL);
 801b35c:	687b      	ldr	r3, [r7, #4]
 801b35e:	2b00      	cmp	r3, #0
 801b360:	d105      	bne.n	801b36e <rt_can_open+0x1e>
 801b362:	4891      	ldr	r0, [pc, #580]	; (801b5a8 <rt_can_open+0x258>)
 801b364:	4991      	ldr	r1, [pc, #580]	; (801b5ac <rt_can_open+0x25c>)
 801b366:	f44f 728e 	mov.w	r2, #284	; 0x11c
 801b36a:	f7fb ff4b 	bl	8017204 <rt_assert_handler>
    can = (struct rt_can_device *)dev;
 801b36e:	687b      	ldr	r3, [r7, #4]
 801b370:	617b      	str	r3, [r7, #20]

    CAN_LOCK(can);
 801b372:	697b      	ldr	r3, [r7, #20]
 801b374:	33cc      	adds	r3, #204	; 0xcc
 801b376:	4618      	mov	r0, r3
 801b378:	f04f 31ff 	mov.w	r1, #4294967295
 801b37c:	f7fa fcbe 	bl	8015cfc <rt_mutex_take>

    /* get open flags */
    dev->open_flag = oflag & 0xff;
 801b380:	887b      	ldrh	r3, [r7, #2]
 801b382:	b2db      	uxtb	r3, r3
 801b384:	b29a      	uxth	r2, r3
 801b386:	687b      	ldr	r3, [r7, #4]
 801b388:	831a      	strh	r2, [r3, #24]
    if (can->can_rx == RT_NULL)
 801b38a:	697b      	ldr	r3, [r7, #20]
 801b38c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 801b390:	2b00      	cmp	r3, #0
 801b392:	d166      	bne.n	801b462 <rt_can_open+0x112>
    {
        if (oflag & RT_DEVICE_FLAG_INT_RX)
 801b394:	887b      	ldrh	r3, [r7, #2]
 801b396:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801b39a:	2b00      	cmp	r3, #0
 801b39c:	d061      	beq.n	801b462 <rt_can_open+0x112>
        {
            int i = 0;
 801b39e:	2300      	movs	r3, #0
 801b3a0:	61fb      	str	r3, [r7, #28]
            struct rt_can_rx_fifo *rx_fifo;

            rx_fifo = (struct rt_can_rx_fifo *) rt_malloc(sizeof(struct rt_can_rx_fifo) +
                      can->config.msgboxsz * sizeof(struct rt_can_msg_list));
 801b3a2:	697b      	ldr	r3, [r7, #20]
 801b3a4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
        if (oflag & RT_DEVICE_FLAG_INT_RX)
        {
            int i = 0;
            struct rt_can_rx_fifo *rx_fifo;

            rx_fifo = (struct rt_can_rx_fifo *) rt_malloc(sizeof(struct rt_can_rx_fifo) +
 801b3a6:	1c5a      	adds	r2, r3, #1
 801b3a8:	4613      	mov	r3, r2
 801b3aa:	005b      	lsls	r3, r3, #1
 801b3ac:	4413      	add	r3, r2
 801b3ae:	00db      	lsls	r3, r3, #3
 801b3b0:	4618      	mov	r0, r3
 801b3b2:	f7fc f85b 	bl	801746c <rt_malloc>
 801b3b6:	6138      	str	r0, [r7, #16]
                      can->config.msgboxsz * sizeof(struct rt_can_msg_list));
            RT_ASSERT(rx_fifo != RT_NULL);
 801b3b8:	693b      	ldr	r3, [r7, #16]
 801b3ba:	2b00      	cmp	r3, #0
 801b3bc:	d105      	bne.n	801b3ca <rt_can_open+0x7a>
 801b3be:	487c      	ldr	r0, [pc, #496]	; (801b5b0 <rt_can_open+0x260>)
 801b3c0:	497a      	ldr	r1, [pc, #488]	; (801b5ac <rt_can_open+0x25c>)
 801b3c2:	f44f 7296 	mov.w	r2, #300	; 0x12c
 801b3c6:	f7fb ff1d 	bl	8017204 <rt_assert_handler>

            rx_fifo->buffer = (struct rt_can_msg_list *)(rx_fifo + 1);
 801b3ca:	693b      	ldr	r3, [r7, #16]
 801b3cc:	f103 0218 	add.w	r2, r3, #24
 801b3d0:	693b      	ldr	r3, [r7, #16]
 801b3d2:	601a      	str	r2, [r3, #0]
            rt_memset(rx_fifo->buffer, 0, can->config.msgboxsz * sizeof(struct rt_can_msg_list));
 801b3d4:	693b      	ldr	r3, [r7, #16]
 801b3d6:	6819      	ldr	r1, [r3, #0]
 801b3d8:	697b      	ldr	r3, [r7, #20]
 801b3da:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 801b3dc:	4613      	mov	r3, r2
 801b3de:	005b      	lsls	r3, r3, #1
 801b3e0:	4413      	add	r3, r2
 801b3e2:	00db      	lsls	r3, r3, #3
 801b3e4:	4608      	mov	r0, r1
 801b3e6:	2100      	movs	r1, #0
 801b3e8:	461a      	mov	r2, r3
 801b3ea:	f7fb f8d9 	bl	80165a0 <rt_memset>
            rt_list_init(&rx_fifo->freelist);
 801b3ee:	693b      	ldr	r3, [r7, #16]
 801b3f0:	3308      	adds	r3, #8
 801b3f2:	4618      	mov	r0, r3
 801b3f4:	f7ff fd10 	bl	801ae18 <rt_list_init>
            rt_list_init(&rx_fifo->uselist);
 801b3f8:	693b      	ldr	r3, [r7, #16]
 801b3fa:	3310      	adds	r3, #16
 801b3fc:	4618      	mov	r0, r3
 801b3fe:	f7ff fd0b 	bl	801ae18 <rt_list_init>
            rx_fifo->freenumbers = can->config.msgboxsz;
 801b402:	697b      	ldr	r3, [r7, #20]
 801b404:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 801b406:	693b      	ldr	r3, [r7, #16]
 801b408:	605a      	str	r2, [r3, #4]
            for (i = 0;  i < can->config.msgboxsz; i++)
 801b40a:	2300      	movs	r3, #0
 801b40c:	61fb      	str	r3, [r7, #28]
 801b40e:	e010      	b.n	801b432 <rt_can_open+0xe2>
            {
                rt_list_insert_before(&rx_fifo->freelist, &rx_fifo->buffer[i].list);
 801b410:	693b      	ldr	r3, [r7, #16]
 801b412:	f103 0008 	add.w	r0, r3, #8
 801b416:	693b      	ldr	r3, [r7, #16]
 801b418:	6819      	ldr	r1, [r3, #0]
 801b41a:	69fa      	ldr	r2, [r7, #28]
 801b41c:	4613      	mov	r3, r2
 801b41e:	005b      	lsls	r3, r3, #1
 801b420:	4413      	add	r3, r2
 801b422:	00db      	lsls	r3, r3, #3
 801b424:	440b      	add	r3, r1
 801b426:	4619      	mov	r1, r3
 801b428:	f7ff fd1e 	bl	801ae68 <rt_list_insert_before>
            rx_fifo->buffer = (struct rt_can_msg_list *)(rx_fifo + 1);
            rt_memset(rx_fifo->buffer, 0, can->config.msgboxsz * sizeof(struct rt_can_msg_list));
            rt_list_init(&rx_fifo->freelist);
            rt_list_init(&rx_fifo->uselist);
            rx_fifo->freenumbers = can->config.msgboxsz;
            for (i = 0;  i < can->config.msgboxsz; i++)
 801b42c:	69fb      	ldr	r3, [r7, #28]
 801b42e:	3301      	adds	r3, #1
 801b430:	61fb      	str	r3, [r7, #28]
 801b432:	69fa      	ldr	r2, [r7, #28]
 801b434:	697b      	ldr	r3, [r7, #20]
 801b436:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801b438:	429a      	cmp	r2, r3
 801b43a:	d3e9      	bcc.n	801b410 <rt_can_open+0xc0>
#ifdef RT_CAN_USING_HDR
                rt_list_init(&rx_fifo->buffer[i].hdrlist);
                rx_fifo->buffer[i].owner = RT_NULL;
#endif
            }
            can->can_rx = rx_fifo;
 801b43c:	697b      	ldr	r3, [r7, #20]
 801b43e:	693a      	ldr	r2, [r7, #16]
 801b440:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0

            dev->open_flag |= RT_DEVICE_FLAG_INT_RX;
 801b444:	687b      	ldr	r3, [r7, #4]
 801b446:	8b1b      	ldrh	r3, [r3, #24]
 801b448:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 801b44c:	b29a      	uxth	r2, r3
 801b44e:	687b      	ldr	r3, [r7, #4]
 801b450:	831a      	strh	r2, [r3, #24]
            /* configure low level device */
            can->ops->control(can, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_RX);
 801b452:	697b      	ldr	r3, [r7, #20]
 801b454:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b456:	685b      	ldr	r3, [r3, #4]
 801b458:	6978      	ldr	r0, [r7, #20]
 801b45a:	2110      	movs	r1, #16
 801b45c:	f44f 7280 	mov.w	r2, #256	; 0x100
 801b460:	4798      	blx	r3

		//else
			//can->can_rx = RT_NULL;
    }

    if (can->can_tx == RT_NULL)
 801b462:	697b      	ldr	r3, [r7, #20]
 801b464:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 801b468:	2b00      	cmp	r3, #0
 801b46a:	d17d      	bne.n	801b568 <rt_can_open+0x218>
    {
        if (oflag & RT_DEVICE_FLAG_INT_TX)
 801b46c:	887b      	ldrh	r3, [r7, #2]
 801b46e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801b472:	2b00      	cmp	r3, #0
 801b474:	d074      	beq.n	801b560 <rt_can_open+0x210>
        {
            int i = 0;
 801b476:	2300      	movs	r3, #0
 801b478:	61bb      	str	r3, [r7, #24]
            struct rt_can_tx_fifo *tx_fifo;

            tx_fifo = (struct rt_can_tx_fifo *) rt_malloc(sizeof(struct rt_can_tx_fifo) +
                      can->config.sndboxnumber * sizeof(struct rt_can_sndbxinx_list));
 801b47a:	697b      	ldr	r3, [r7, #20]
 801b47c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
        if (oflag & RT_DEVICE_FLAG_INT_TX)
        {
            int i = 0;
            struct rt_can_tx_fifo *tx_fifo;

            tx_fifo = (struct rt_can_tx_fifo *) rt_malloc(sizeof(struct rt_can_tx_fifo) +
 801b47e:	1c5a      	adds	r2, r3, #1
 801b480:	4613      	mov	r3, r2
 801b482:	005b      	lsls	r3, r3, #1
 801b484:	4413      	add	r3, r2
 801b486:	00db      	lsls	r3, r3, #3
 801b488:	4618      	mov	r0, r3
 801b48a:	f7fb ffef 	bl	801746c <rt_malloc>
 801b48e:	60f8      	str	r0, [r7, #12]
                      can->config.sndboxnumber * sizeof(struct rt_can_sndbxinx_list));
            RT_ASSERT(tx_fifo != RT_NULL);
 801b490:	68fb      	ldr	r3, [r7, #12]
 801b492:	2b00      	cmp	r3, #0
 801b494:	d105      	bne.n	801b4a2 <rt_can_open+0x152>
 801b496:	4847      	ldr	r0, [pc, #284]	; (801b5b4 <rt_can_open+0x264>)
 801b498:	4944      	ldr	r1, [pc, #272]	; (801b5ac <rt_can_open+0x25c>)
 801b49a:	f240 124f 	movw	r2, #335	; 0x14f
 801b49e:	f7fb feb1 	bl	8017204 <rt_assert_handler>

            tx_fifo->buffer = (struct rt_can_sndbxinx_list *)(tx_fifo + 1);
 801b4a2:	68fb      	ldr	r3, [r7, #12]
 801b4a4:	f103 0218 	add.w	r2, r3, #24
 801b4a8:	68fb      	ldr	r3, [r7, #12]
 801b4aa:	601a      	str	r2, [r3, #0]
            rt_memset(tx_fifo->buffer, 0,
 801b4ac:	68fb      	ldr	r3, [r7, #12]
 801b4ae:	6819      	ldr	r1, [r3, #0]
                      can->config.sndboxnumber * sizeof(struct rt_can_sndbxinx_list));
 801b4b0:	697b      	ldr	r3, [r7, #20]
 801b4b2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
            tx_fifo = (struct rt_can_tx_fifo *) rt_malloc(sizeof(struct rt_can_tx_fifo) +
                      can->config.sndboxnumber * sizeof(struct rt_can_sndbxinx_list));
            RT_ASSERT(tx_fifo != RT_NULL);

            tx_fifo->buffer = (struct rt_can_sndbxinx_list *)(tx_fifo + 1);
            rt_memset(tx_fifo->buffer, 0,
 801b4b4:	4613      	mov	r3, r2
 801b4b6:	005b      	lsls	r3, r3, #1
 801b4b8:	4413      	add	r3, r2
 801b4ba:	00db      	lsls	r3, r3, #3
 801b4bc:	4608      	mov	r0, r1
 801b4be:	2100      	movs	r1, #0
 801b4c0:	461a      	mov	r2, r3
 801b4c2:	f7fb f86d 	bl	80165a0 <rt_memset>
                      can->config.sndboxnumber * sizeof(struct rt_can_sndbxinx_list));
            rt_list_init(&tx_fifo->freelist);
 801b4c6:	68fb      	ldr	r3, [r7, #12]
 801b4c8:	3310      	adds	r3, #16
 801b4ca:	4618      	mov	r0, r3
 801b4cc:	f7ff fca4 	bl	801ae18 <rt_list_init>
            for (i = 0;  i < can->config.sndboxnumber; i++)
 801b4d0:	2300      	movs	r3, #0
 801b4d2:	61bb      	str	r3, [r7, #24]
 801b4d4:	e026      	b.n	801b524 <rt_can_open+0x1d4>
            {
                rt_list_insert_before(&tx_fifo->freelist, &tx_fifo->buffer[i].list);
 801b4d6:	68fb      	ldr	r3, [r7, #12]
 801b4d8:	f103 0010 	add.w	r0, r3, #16
 801b4dc:	68fb      	ldr	r3, [r7, #12]
 801b4de:	6819      	ldr	r1, [r3, #0]
 801b4e0:	69ba      	ldr	r2, [r7, #24]
 801b4e2:	4613      	mov	r3, r2
 801b4e4:	005b      	lsls	r3, r3, #1
 801b4e6:	4413      	add	r3, r2
 801b4e8:	00db      	lsls	r3, r3, #3
 801b4ea:	440b      	add	r3, r1
 801b4ec:	4619      	mov	r1, r3
 801b4ee:	f7ff fcbb 	bl	801ae68 <rt_list_insert_before>
                rt_completion_init(&(tx_fifo->buffer[i].completion));
 801b4f2:	68fb      	ldr	r3, [r7, #12]
 801b4f4:	6819      	ldr	r1, [r3, #0]
 801b4f6:	69ba      	ldr	r2, [r7, #24]
 801b4f8:	4613      	mov	r3, r2
 801b4fa:	005b      	lsls	r3, r3, #1
 801b4fc:	4413      	add	r3, r2
 801b4fe:	00db      	lsls	r3, r3, #3
 801b500:	440b      	add	r3, r1
 801b502:	3308      	adds	r3, #8
 801b504:	4618      	mov	r0, r3
 801b506:	f7fe f823 	bl	8019550 <rt_completion_init>
                tx_fifo->buffer[i].result = RT_CAN_SND_RESULT_OK;
 801b50a:	68fb      	ldr	r3, [r7, #12]
 801b50c:	6819      	ldr	r1, [r3, #0]
 801b50e:	69ba      	ldr	r2, [r7, #24]
 801b510:	4613      	mov	r3, r2
 801b512:	005b      	lsls	r3, r3, #1
 801b514:	4413      	add	r3, r2
 801b516:	00db      	lsls	r3, r3, #3
 801b518:	440b      	add	r3, r1
 801b51a:	2200      	movs	r2, #0
 801b51c:	615a      	str	r2, [r3, #20]

            tx_fifo->buffer = (struct rt_can_sndbxinx_list *)(tx_fifo + 1);
            rt_memset(tx_fifo->buffer, 0,
                      can->config.sndboxnumber * sizeof(struct rt_can_sndbxinx_list));
            rt_list_init(&tx_fifo->freelist);
            for (i = 0;  i < can->config.sndboxnumber; i++)
 801b51e:	69bb      	ldr	r3, [r7, #24]
 801b520:	3301      	adds	r3, #1
 801b522:	61bb      	str	r3, [r7, #24]
 801b524:	69ba      	ldr	r2, [r7, #24]
 801b526:	697b      	ldr	r3, [r7, #20]
 801b528:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801b52a:	429a      	cmp	r2, r3
 801b52c:	d3d3      	bcc.n	801b4d6 <rt_can_open+0x186>
            {
                rt_list_insert_before(&tx_fifo->freelist, &tx_fifo->buffer[i].list);
                rt_completion_init(&(tx_fifo->buffer[i].completion));
                tx_fifo->buffer[i].result = RT_CAN_SND_RESULT_OK;
            }
            rt_completion_init(&(tx_fifo->completion));
 801b52e:	68fb      	ldr	r3, [r7, #12]
 801b530:	3304      	adds	r3, #4
 801b532:	4618      	mov	r0, r3
 801b534:	f7fe f80c 	bl	8019550 <rt_completion_init>
            can->can_tx = tx_fifo;
 801b538:	697b      	ldr	r3, [r7, #20]
 801b53a:	68fa      	ldr	r2, [r7, #12]
 801b53c:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4

            dev->open_flag |= RT_DEVICE_FLAG_INT_TX;
 801b540:	687b      	ldr	r3, [r7, #4]
 801b542:	8b1b      	ldrh	r3, [r3, #24]
 801b544:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 801b548:	b29a      	uxth	r2, r3
 801b54a:	687b      	ldr	r3, [r7, #4]
 801b54c:	831a      	strh	r2, [r3, #24]
            /* configure low level device */
            can->ops->control(can, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_TX);
 801b54e:	697b      	ldr	r3, [r7, #20]
 801b550:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b552:	685b      	ldr	r3, [r3, #4]
 801b554:	6978      	ldr	r0, [r7, #20]
 801b556:	2110      	movs	r1, #16
 801b558:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801b55c:	4798      	blx	r3
 801b55e:	e003      	b.n	801b568 <rt_can_open+0x218>
        }
		else 
			can->can_tx = RT_NULL;
 801b560:	697b      	ldr	r3, [r7, #20]
 801b562:	2200      	movs	r2, #0
 801b564:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
    }

    can->ops->control(can, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_CAN_INT_ERR);
 801b568:	697b      	ldr	r3, [r7, #20]
 801b56a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b56c:	685b      	ldr	r3, [r3, #4]
 801b56e:	6978      	ldr	r0, [r7, #20]
 801b570:	2110      	movs	r1, #16
 801b572:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801b576:	4798      	blx	r3

        can->hdr = phdr;
    }
#endif

    if (!can->timerinitflag)
 801b578:	697b      	ldr	r3, [r7, #20]
 801b57a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 801b57e:	2b00      	cmp	r3, #0
 801b580:	d108      	bne.n	801b594 <rt_can_open+0x244>
    {
        can->timerinitflag = 1;
 801b582:	697b      	ldr	r3, [r7, #20]
 801b584:	2201      	movs	r2, #1
 801b586:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

        rt_timer_start(&can->timer);
 801b58a:	697b      	ldr	r3, [r7, #20]
 801b58c:	3398      	adds	r3, #152	; 0x98
 801b58e:	4618      	mov	r0, r3
 801b590:	f7fd fabc 	bl	8018b0c <rt_timer_start>
    }

    CAN_UNLOCK(can);
 801b594:	697b      	ldr	r3, [r7, #20]
 801b596:	33cc      	adds	r3, #204	; 0xcc
 801b598:	4618      	mov	r0, r3
 801b59a:	f7fa fc87 	bl	8015eac <rt_mutex_release>

    return RT_EOK;
 801b59e:	2300      	movs	r3, #0
}
 801b5a0:	4618      	mov	r0, r3
 801b5a2:	3720      	adds	r7, #32
 801b5a4:	46bd      	mov	sp, r7
 801b5a6:	bd80      	pop	{r7, pc}
 801b5a8:	08029828 	.word	0x08029828
 801b5ac:	0802ae84 	.word	0x0802ae84
 801b5b0:	08029848 	.word	0x08029848
 801b5b4:	0802988c 	.word	0x0802988c

0801b5b8 <rt_can_close>:

static rt_err_t rt_can_close(struct rt_device *dev)
{
 801b5b8:	b580      	push	{r7, lr}
 801b5ba:	b086      	sub	sp, #24
 801b5bc:	af00      	add	r7, sp, #0
 801b5be:	6078      	str	r0, [r7, #4]
    struct rt_can_device *can;

    RT_ASSERT(dev != RT_NULL);
 801b5c0:	687b      	ldr	r3, [r7, #4]
 801b5c2:	2b00      	cmp	r3, #0
 801b5c4:	d105      	bne.n	801b5d2 <rt_can_close+0x1a>
 801b5c6:	4846      	ldr	r0, [pc, #280]	; (801b6e0 <rt_can_close+0x128>)
 801b5c8:	4946      	ldr	r1, [pc, #280]	; (801b6e4 <rt_can_close+0x12c>)
 801b5ca:	f44f 72c5 	mov.w	r2, #394	; 0x18a
 801b5ce:	f7fb fe19 	bl	8017204 <rt_assert_handler>
    can = (struct rt_can_device *)dev;
 801b5d2:	687b      	ldr	r3, [r7, #4]
 801b5d4:	617b      	str	r3, [r7, #20]

    CAN_LOCK(can);
 801b5d6:	697b      	ldr	r3, [r7, #20]
 801b5d8:	33cc      	adds	r3, #204	; 0xcc
 801b5da:	4618      	mov	r0, r3
 801b5dc:	f04f 31ff 	mov.w	r1, #4294967295
 801b5e0:	f7fa fb8c 	bl	8015cfc <rt_mutex_take>

    /* this device has more reference count */
    if (dev->ref_count > 1)
 801b5e4:	687b      	ldr	r3, [r7, #4]
 801b5e6:	7e9b      	ldrb	r3, [r3, #26]
 801b5e8:	2b01      	cmp	r3, #1
 801b5ea:	d906      	bls.n	801b5fa <rt_can_close+0x42>
    {
        CAN_UNLOCK(can);
 801b5ec:	697b      	ldr	r3, [r7, #20]
 801b5ee:	33cc      	adds	r3, #204	; 0xcc
 801b5f0:	4618      	mov	r0, r3
 801b5f2:	f7fa fc5b 	bl	8015eac <rt_mutex_release>
        return RT_EOK;
 801b5f6:	2300      	movs	r3, #0
 801b5f8:	e06d      	b.n	801b6d6 <rt_can_close+0x11e>
    }

    if (can->timerinitflag)
 801b5fa:	697b      	ldr	r3, [r7, #20]
 801b5fc:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 801b600:	2b00      	cmp	r3, #0
 801b602:	d008      	beq.n	801b616 <rt_can_close+0x5e>
    {
        can->timerinitflag = 0;
 801b604:	697b      	ldr	r3, [r7, #20]
 801b606:	2200      	movs	r2, #0
 801b608:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

        rt_timer_stop(&can->timer);
 801b60c:	697b      	ldr	r3, [r7, #20]
 801b60e:	3398      	adds	r3, #152	; 0x98
 801b610:	4618      	mov	r0, r3
 801b612:	f7fd fb87 	bl	8018d24 <rt_timer_stop>
    }

    can->status_indicate.ind = RT_NULL;
 801b616:	697b      	ldr	r3, [r7, #20]
 801b618:	2200      	movs	r2, #0
 801b61a:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
    can->status_indicate.args = RT_NULL;
 801b61e:	697b      	ldr	r3, [r7, #20]
 801b620:	2200      	movs	r2, #0
 801b622:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
        rt_free(can->hdr);
        can->hdr = RT_NULL;
    }
#endif

    if (dev->open_flag & RT_DEVICE_FLAG_INT_RX)
 801b626:	687b      	ldr	r3, [r7, #4]
 801b628:	8b1b      	ldrh	r3, [r3, #24]
 801b62a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801b62e:	2b00      	cmp	r3, #0
 801b630:	d01e      	beq.n	801b670 <rt_can_close+0xb8>
    {
        struct rt_can_rx_fifo *rx_fifo;

        rx_fifo = (struct rt_can_rx_fifo *)can->can_rx;
 801b632:	697b      	ldr	r3, [r7, #20]
 801b634:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 801b638:	613b      	str	r3, [r7, #16]
        RT_ASSERT(rx_fifo != RT_NULL);
 801b63a:	693b      	ldr	r3, [r7, #16]
 801b63c:	2b00      	cmp	r3, #0
 801b63e:	d105      	bne.n	801b64c <rt_can_close+0x94>
 801b640:	4829      	ldr	r0, [pc, #164]	; (801b6e8 <rt_can_close+0x130>)
 801b642:	4928      	ldr	r1, [pc, #160]	; (801b6e4 <rt_can_close+0x12c>)
 801b644:	f240 12ad 	movw	r2, #429	; 0x1ad
 801b648:	f7fb fddc 	bl	8017204 <rt_assert_handler>

        rt_free(rx_fifo);
 801b64c:	6938      	ldr	r0, [r7, #16]
 801b64e:	f7fc f951 	bl	80178f4 <rt_free>
        dev->open_flag &= ~RT_DEVICE_FLAG_INT_RX;
 801b652:	687b      	ldr	r3, [r7, #4]
 801b654:	8b1b      	ldrh	r3, [r3, #24]
 801b656:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 801b65a:	b29a      	uxth	r2, r3
 801b65c:	687b      	ldr	r3, [r7, #4]
 801b65e:	831a      	strh	r2, [r3, #24]
        /* configure low level device */
        can->ops->control(can, RT_DEVICE_CTRL_CLR_INT, (void *)RT_DEVICE_FLAG_INT_RX);
 801b660:	697b      	ldr	r3, [r7, #20]
 801b662:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b664:	685b      	ldr	r3, [r3, #4]
 801b666:	6978      	ldr	r0, [r7, #20]
 801b668:	2111      	movs	r1, #17
 801b66a:	f44f 7280 	mov.w	r2, #256	; 0x100
 801b66e:	4798      	blx	r3
    }

    if (dev->open_flag & RT_DEVICE_FLAG_INT_TX)
 801b670:	687b      	ldr	r3, [r7, #4]
 801b672:	8b1b      	ldrh	r3, [r3, #24]
 801b674:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801b678:	2b00      	cmp	r3, #0
 801b67a:	d01e      	beq.n	801b6ba <rt_can_close+0x102>
    {
        struct rt_can_tx_fifo *tx_fifo;

        tx_fifo = (struct rt_can_tx_fifo *)can->can_tx;
 801b67c:	697b      	ldr	r3, [r7, #20]
 801b67e:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 801b682:	60fb      	str	r3, [r7, #12]
        RT_ASSERT(tx_fifo != RT_NULL);
 801b684:	68fb      	ldr	r3, [r7, #12]
 801b686:	2b00      	cmp	r3, #0
 801b688:	d105      	bne.n	801b696 <rt_can_close+0xde>
 801b68a:	4818      	ldr	r0, [pc, #96]	; (801b6ec <rt_can_close+0x134>)
 801b68c:	4915      	ldr	r1, [pc, #84]	; (801b6e4 <rt_can_close+0x12c>)
 801b68e:	f44f 72dd 	mov.w	r2, #442	; 0x1ba
 801b692:	f7fb fdb7 	bl	8017204 <rt_assert_handler>

        rt_free(tx_fifo);
 801b696:	68f8      	ldr	r0, [r7, #12]
 801b698:	f7fc f92c 	bl	80178f4 <rt_free>
        dev->open_flag &= ~RT_DEVICE_FLAG_INT_TX;
 801b69c:	687b      	ldr	r3, [r7, #4]
 801b69e:	8b1b      	ldrh	r3, [r3, #24]
 801b6a0:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 801b6a4:	b29a      	uxth	r2, r3
 801b6a6:	687b      	ldr	r3, [r7, #4]
 801b6a8:	831a      	strh	r2, [r3, #24]
        /* configure low level device */
        can->ops->control(can, RT_DEVICE_CTRL_CLR_INT, (void *)RT_DEVICE_FLAG_INT_TX);
 801b6aa:	697b      	ldr	r3, [r7, #20]
 801b6ac:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b6ae:	685b      	ldr	r3, [r3, #4]
 801b6b0:	6978      	ldr	r0, [r7, #20]
 801b6b2:	2111      	movs	r1, #17
 801b6b4:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801b6b8:	4798      	blx	r3
    }

    can->ops->control(can, RT_DEVICE_CTRL_CLR_INT, (void *)RT_DEVICE_CAN_INT_ERR);
 801b6ba:	697b      	ldr	r3, [r7, #20]
 801b6bc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b6be:	685b      	ldr	r3, [r3, #4]
 801b6c0:	6978      	ldr	r0, [r7, #20]
 801b6c2:	2111      	movs	r1, #17
 801b6c4:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801b6c8:	4798      	blx	r3

    CAN_UNLOCK(can);
 801b6ca:	697b      	ldr	r3, [r7, #20]
 801b6cc:	33cc      	adds	r3, #204	; 0xcc
 801b6ce:	4618      	mov	r0, r3
 801b6d0:	f7fa fbec 	bl	8015eac <rt_mutex_release>

    return RT_EOK;
 801b6d4:	2300      	movs	r3, #0
}
 801b6d6:	4618      	mov	r0, r3
 801b6d8:	3718      	adds	r7, #24
 801b6da:	46bd      	mov	sp, r7
 801b6dc:	bd80      	pop	{r7, pc}
 801b6de:	bf00      	nop
 801b6e0:	08029828 	.word	0x08029828
 801b6e4:	0802ae90 	.word	0x0802ae90
 801b6e8:	08029848 	.word	0x08029848
 801b6ec:	0802988c 	.word	0x0802988c

0801b6f0 <rt_can_read>:

static rt_size_t rt_can_read(struct rt_device *dev,
                             rt_off_t          pos,
                             void             *buffer,
                             rt_size_t         size)
{
 801b6f0:	b580      	push	{r7, lr}
 801b6f2:	b086      	sub	sp, #24
 801b6f4:	af00      	add	r7, sp, #0
 801b6f6:	60f8      	str	r0, [r7, #12]
 801b6f8:	60b9      	str	r1, [r7, #8]
 801b6fa:	607a      	str	r2, [r7, #4]
 801b6fc:	603b      	str	r3, [r7, #0]
    struct rt_can_device *can;

    RT_ASSERT(dev != RT_NULL);
 801b6fe:	68fb      	ldr	r3, [r7, #12]
 801b700:	2b00      	cmp	r3, #0
 801b702:	d105      	bne.n	801b710 <rt_can_read+0x20>
 801b704:	4811      	ldr	r0, [pc, #68]	; (801b74c <rt_can_read+0x5c>)
 801b706:	4912      	ldr	r1, [pc, #72]	; (801b750 <rt_can_read+0x60>)
 801b708:	f44f 72e8 	mov.w	r2, #464	; 0x1d0
 801b70c:	f7fb fd7a 	bl	8017204 <rt_assert_handler>
    if (size == 0) return 0;
 801b710:	683b      	ldr	r3, [r7, #0]
 801b712:	2b00      	cmp	r3, #0
 801b714:	d101      	bne.n	801b71a <rt_can_read+0x2a>
 801b716:	2300      	movs	r3, #0
 801b718:	e014      	b.n	801b744 <rt_can_read+0x54>

    can = (struct rt_can_device *)dev;
 801b71a:	68fb      	ldr	r3, [r7, #12]
 801b71c:	617b      	str	r3, [r7, #20]

    if ((dev->open_flag & RT_DEVICE_FLAG_INT_RX) && (dev->ref_count > 0))
 801b71e:	68fb      	ldr	r3, [r7, #12]
 801b720:	8b1b      	ldrh	r3, [r3, #24]
 801b722:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801b726:	2b00      	cmp	r3, #0
 801b728:	d00b      	beq.n	801b742 <rt_can_read+0x52>
 801b72a:	68fb      	ldr	r3, [r7, #12]
 801b72c:	7e9b      	ldrb	r3, [r3, #26]
 801b72e:	2b00      	cmp	r3, #0
 801b730:	d007      	beq.n	801b742 <rt_can_read+0x52>
    {
        return _can_int_rx(can, buffer, size);
 801b732:	683b      	ldr	r3, [r7, #0]
 801b734:	6978      	ldr	r0, [r7, #20]
 801b736:	6879      	ldr	r1, [r7, #4]
 801b738:	461a      	mov	r2, r3
 801b73a:	f7ff fc09 	bl	801af50 <_can_int_rx>
 801b73e:	4603      	mov	r3, r0
 801b740:	e000      	b.n	801b744 <rt_can_read+0x54>
    }

    return 0;
 801b742:	2300      	movs	r3, #0
}
 801b744:	4618      	mov	r0, r3
 801b746:	3718      	adds	r7, #24
 801b748:	46bd      	mov	sp, r7
 801b74a:	bd80      	pop	{r7, pc}
 801b74c:	08029828 	.word	0x08029828
 801b750:	0802aea0 	.word	0x0802aea0

0801b754 <rt_can_write>:

static rt_size_t rt_can_write(struct rt_device *dev,
                              rt_off_t          pos,
                              const void       *buffer,
                              rt_size_t         size)
{
 801b754:	b580      	push	{r7, lr}
 801b756:	b086      	sub	sp, #24
 801b758:	af00      	add	r7, sp, #0
 801b75a:	60f8      	str	r0, [r7, #12]
 801b75c:	60b9      	str	r1, [r7, #8]
 801b75e:	607a      	str	r2, [r7, #4]
 801b760:	603b      	str	r3, [r7, #0]
    struct rt_can_device *can;

    RT_ASSERT(dev != RT_NULL);
 801b762:	68fb      	ldr	r3, [r7, #12]
 801b764:	2b00      	cmp	r3, #0
 801b766:	d105      	bne.n	801b774 <rt_can_write+0x20>
 801b768:	481b      	ldr	r0, [pc, #108]	; (801b7d8 <rt_can_write+0x84>)
 801b76a:	491c      	ldr	r1, [pc, #112]	; (801b7dc <rt_can_write+0x88>)
 801b76c:	f44f 72f2 	mov.w	r2, #484	; 0x1e4
 801b770:	f7fb fd48 	bl	8017204 <rt_assert_handler>
    if (size == 0) return 0;
 801b774:	683b      	ldr	r3, [r7, #0]
 801b776:	2b00      	cmp	r3, #0
 801b778:	d101      	bne.n	801b77e <rt_can_write+0x2a>
 801b77a:	2300      	movs	r3, #0
 801b77c:	e028      	b.n	801b7d0 <rt_can_write+0x7c>

    can = (struct rt_can_device *)dev;
 801b77e:	68fb      	ldr	r3, [r7, #12]
 801b780:	617b      	str	r3, [r7, #20]

    if ((dev->open_flag & RT_DEVICE_FLAG_INT_TX) && (dev->ref_count > 0))
 801b782:	68fb      	ldr	r3, [r7, #12]
 801b784:	8b1b      	ldrh	r3, [r3, #24]
 801b786:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801b78a:	2b00      	cmp	r3, #0
 801b78c:	d018      	beq.n	801b7c0 <rt_can_write+0x6c>
 801b78e:	68fb      	ldr	r3, [r7, #12]
 801b790:	7e9b      	ldrb	r3, [r3, #26]
 801b792:	2b00      	cmp	r3, #0
 801b794:	d014      	beq.n	801b7c0 <rt_can_write+0x6c>
    {
        if (can->config.privmode)
 801b796:	697b      	ldr	r3, [r7, #20]
 801b798:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 801b79c:	2b00      	cmp	r3, #0
 801b79e:	d007      	beq.n	801b7b0 <rt_can_write+0x5c>
        {
            return _can_int_tx_priv(can, buffer, size);
 801b7a0:	683b      	ldr	r3, [r7, #0]
 801b7a2:	6978      	ldr	r0, [r7, #20]
 801b7a4:	6879      	ldr	r1, [r7, #4]
 801b7a6:	461a      	mov	r2, r3
 801b7a8:	f7ff fd22 	bl	801b1f0 <_can_int_tx_priv>
 801b7ac:	4603      	mov	r3, r0
 801b7ae:	e00f      	b.n	801b7d0 <rt_can_write+0x7c>
        }
        else
        {
            return _can_int_tx(can, buffer, size);
 801b7b0:	683b      	ldr	r3, [r7, #0]
 801b7b2:	6978      	ldr	r0, [r7, #20]
 801b7b4:	6879      	ldr	r1, [r7, #4]
 801b7b6:	461a      	mov	r2, r3
 801b7b8:	f7ff fc48 	bl	801b04c <_can_int_tx>
 801b7bc:	4603      	mov	r3, r0
 801b7be:	e007      	b.n	801b7d0 <rt_can_write+0x7c>
        }
    }
	else
		//stm32_CANsendmsg(can, buffer, size);
		return can->ops->sendmsg(can, buffer, size);
 801b7c0:	697b      	ldr	r3, [r7, #20]
 801b7c2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b7c4:	689b      	ldr	r3, [r3, #8]
 801b7c6:	6978      	ldr	r0, [r7, #20]
 801b7c8:	6879      	ldr	r1, [r7, #4]
 801b7ca:	683a      	ldr	r2, [r7, #0]
 801b7cc:	4798      	blx	r3
 801b7ce:	4603      	mov	r3, r0
    return 0;
}
 801b7d0:	4618      	mov	r0, r3
 801b7d2:	3718      	adds	r7, #24
 801b7d4:	46bd      	mov	sp, r7
 801b7d6:	bd80      	pop	{r7, pc}
 801b7d8:	08029828 	.word	0x08029828
 801b7dc:	0802aeb8 	.word	0x0802aeb8

0801b7e0 <rt_can_control>:

static rt_err_t rt_can_control(struct rt_device *dev,
                               rt_uint8_t        cmd,
                               void             *args)
{
 801b7e0:	b580      	push	{r7, lr}
 801b7e2:	b08a      	sub	sp, #40	; 0x28
 801b7e4:	af00      	add	r7, sp, #0
 801b7e6:	60f8      	str	r0, [r7, #12]
 801b7e8:	460b      	mov	r3, r1
 801b7ea:	607a      	str	r2, [r7, #4]
 801b7ec:	72fb      	strb	r3, [r7, #11]
    struct rt_can_device *can;
    rt_err_t res;

    RT_ASSERT(dev != RT_NULL);
 801b7ee:	68fb      	ldr	r3, [r7, #12]
 801b7f0:	2b00      	cmp	r3, #0
 801b7f2:	d105      	bne.n	801b800 <rt_can_control+0x20>
 801b7f4:	4870      	ldr	r0, [pc, #448]	; (801b9b8 <rt_can_control+0x1d8>)
 801b7f6:	4971      	ldr	r1, [pc, #452]	; (801b9bc <rt_can_control+0x1dc>)
 801b7f8:	f240 2201 	movw	r2, #513	; 0x201
 801b7fc:	f7fb fd02 	bl	8017204 <rt_assert_handler>
    can = (struct rt_can_device *)dev;
 801b800:	68fb      	ldr	r3, [r7, #12]
 801b802:	623b      	str	r3, [r7, #32]

    switch (cmd)
 801b804:	7afb      	ldrb	r3, [r7, #11]
 801b806:	3b01      	subs	r3, #1
 801b808:	2b17      	cmp	r3, #23
 801b80a:	f200 80c1 	bhi.w	801b990 <rt_can_control+0x1b0>
 801b80e:	a201      	add	r2, pc, #4	; (adr r2, 801b814 <rt_can_control+0x34>)
 801b810:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801b814:	0801b885 	.word	0x0801b885
 801b818:	0801b875 	.word	0x0801b875
 801b81c:	0801b895 	.word	0x0801b895
 801b820:	0801b991 	.word	0x0801b991
 801b824:	0801b991 	.word	0x0801b991
 801b828:	0801b991 	.word	0x0801b991
 801b82c:	0801b991 	.word	0x0801b991
 801b830:	0801b991 	.word	0x0801b991
 801b834:	0801b991 	.word	0x0801b991
 801b838:	0801b991 	.word	0x0801b991
 801b83c:	0801b991 	.word	0x0801b991
 801b840:	0801b991 	.word	0x0801b991
 801b844:	0801b991 	.word	0x0801b991
 801b848:	0801b991 	.word	0x0801b991
 801b84c:	0801b991 	.word	0x0801b991
 801b850:	0801b991 	.word	0x0801b991
 801b854:	0801b991 	.word	0x0801b991
 801b858:	0801b991 	.word	0x0801b991
 801b85c:	0801b991 	.word	0x0801b991
 801b860:	0801b991 	.word	0x0801b991
 801b864:	0801b991 	.word	0x0801b991
 801b868:	0801b8a3 	.word	0x0801b8a3
 801b86c:	0801b991 	.word	0x0801b991
 801b870:	0801b97b 	.word	0x0801b97b
    {
    case RT_DEVICE_CTRL_SUSPEND:
        /* suspend device */
        dev->flag |= RT_DEVICE_FLAG_SUSPENDED;
 801b874:	68fb      	ldr	r3, [r7, #12]
 801b876:	8adb      	ldrh	r3, [r3, #22]
 801b878:	f043 0320 	orr.w	r3, r3, #32
 801b87c:	b29a      	uxth	r2, r3
 801b87e:	68fb      	ldr	r3, [r7, #12]
 801b880:	82da      	strh	r2, [r3, #22]
        break;
 801b882:	e094      	b.n	801b9ae <rt_can_control+0x1ce>

    case RT_DEVICE_CTRL_RESUME:
        /* resume device */
        dev->flag &= ~RT_DEVICE_FLAG_SUSPENDED;
 801b884:	68fb      	ldr	r3, [r7, #12]
 801b886:	8adb      	ldrh	r3, [r3, #22]
 801b888:	f023 0320 	bic.w	r3, r3, #32
 801b88c:	b29a      	uxth	r2, r3
 801b88e:	68fb      	ldr	r3, [r7, #12]
 801b890:	82da      	strh	r2, [r3, #22]
        break;
 801b892:	e08c      	b.n	801b9ae <rt_can_control+0x1ce>

    case RT_DEVICE_CTRL_CONFIG:
        /* configure device */
        can->ops->configure(can, (struct can_configure *)args);
 801b894:	6a3b      	ldr	r3, [r7, #32]
 801b896:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b898:	681b      	ldr	r3, [r3, #0]
 801b89a:	6a38      	ldr	r0, [r7, #32]
 801b89c:	6879      	ldr	r1, [r7, #4]
 801b89e:	4798      	blx	r3
        break;
 801b8a0:	e085      	b.n	801b9ae <rt_can_control+0x1ce>
    case RT_CAN_CMD_SET_PRIV:
        /* configure device */
        if ((rt_uint32_t)args != can->config.privmode)
 801b8a2:	687b      	ldr	r3, [r7, #4]
 801b8a4:	6a3a      	ldr	r2, [r7, #32]
 801b8a6:	f892 2051 	ldrb.w	r2, [r2, #81]	; 0x51
 801b8aa:	4293      	cmp	r3, r2
 801b8ac:	d064      	beq.n	801b978 <rt_can_control+0x198>
        {
            int i;
            rt_base_t level;
            struct rt_can_tx_fifo *tx_fifo;

            res = can->ops->control(can, cmd, args);
 801b8ae:	6a3b      	ldr	r3, [r7, #32]
 801b8b0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b8b2:	685b      	ldr	r3, [r3, #4]
 801b8b4:	7afa      	ldrb	r2, [r7, #11]
 801b8b6:	6a38      	ldr	r0, [r7, #32]
 801b8b8:	4611      	mov	r1, r2
 801b8ba:	687a      	ldr	r2, [r7, #4]
 801b8bc:	4798      	blx	r3
 801b8be:	61f8      	str	r0, [r7, #28]
            if (res != RT_EOK) return res;
 801b8c0:	69fb      	ldr	r3, [r7, #28]
 801b8c2:	2b00      	cmp	r3, #0
 801b8c4:	d001      	beq.n	801b8ca <rt_can_control+0xea>
 801b8c6:	69fb      	ldr	r3, [r7, #28]
 801b8c8:	e072      	b.n	801b9b0 <rt_can_control+0x1d0>

            tx_fifo = (struct rt_can_tx_fifo *) can->can_tx;
 801b8ca:	6a3b      	ldr	r3, [r7, #32]
 801b8cc:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 801b8d0:	61bb      	str	r3, [r7, #24]
            if (can->config.privmode)
 801b8d2:	6a3b      	ldr	r3, [r7, #32]
 801b8d4:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 801b8d8:	2b00      	cmp	r3, #0
 801b8da:	d021      	beq.n	801b920 <rt_can_control+0x140>
            {
                rt_completion_done(&(tx_fifo->completion));
 801b8dc:	69bb      	ldr	r3, [r7, #24]
 801b8de:	3304      	adds	r3, #4
 801b8e0:	4618      	mov	r0, r3
 801b8e2:	f7fd fed7 	bl	8019694 <rt_completion_done>

                for (i = 0;  i < can->config.sndboxnumber; i++)
 801b8e6:	2300      	movs	r3, #0
 801b8e8:	627b      	str	r3, [r7, #36]	; 0x24
 801b8ea:	e013      	b.n	801b914 <rt_can_control+0x134>
                {
		    level = rt_hw_interrupt_disable();
 801b8ec:	f7e4 fc6e 	bl	80001cc <rt_hw_interrupt_disable>
 801b8f0:	6178      	str	r0, [r7, #20]
                    rt_list_remove(&tx_fifo->buffer[i].list);
 801b8f2:	69bb      	ldr	r3, [r7, #24]
 801b8f4:	6819      	ldr	r1, [r3, #0]
 801b8f6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801b8f8:	4613      	mov	r3, r2
 801b8fa:	005b      	lsls	r3, r3, #1
 801b8fc:	4413      	add	r3, r2
 801b8fe:	00db      	lsls	r3, r3, #3
 801b900:	440b      	add	r3, r1
 801b902:	4618      	mov	r0, r3
 801b904:	f7ff fac8 	bl	801ae98 <rt_list_remove>
                    rt_hw_interrupt_enable(level);
 801b908:	6978      	ldr	r0, [r7, #20]
 801b90a:	f7e4 fc63 	bl	80001d4 <rt_hw_interrupt_enable>
            tx_fifo = (struct rt_can_tx_fifo *) can->can_tx;
            if (can->config.privmode)
            {
                rt_completion_done(&(tx_fifo->completion));

                for (i = 0;  i < can->config.sndboxnumber; i++)
 801b90e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b910:	3301      	adds	r3, #1
 801b912:	627b      	str	r3, [r7, #36]	; 0x24
 801b914:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801b916:	6a3b      	ldr	r3, [r7, #32]
 801b918:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801b91a:	429a      	cmp	r2, r3
 801b91c:	d3e6      	bcc.n	801b8ec <rt_can_control+0x10c>
 801b91e:	e029      	b.n	801b974 <rt_can_control+0x194>
                    rt_hw_interrupt_enable(level);
                }
            }
            else
            {
                for (i = 0;  i < can->config.sndboxnumber; i++)
 801b920:	2300      	movs	r3, #0
 801b922:	627b      	str	r3, [r7, #36]	; 0x24
 801b924:	e021      	b.n	801b96a <rt_can_control+0x18a>
                {
                    level = rt_hw_interrupt_disable();
 801b926:	f7e4 fc51 	bl	80001cc <rt_hw_interrupt_disable>
 801b92a:	6178      	str	r0, [r7, #20]
                    if (tx_fifo->buffer[i].result == RT_CAN_SND_RESULT_OK)
 801b92c:	69bb      	ldr	r3, [r7, #24]
 801b92e:	6819      	ldr	r1, [r3, #0]
 801b930:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801b932:	4613      	mov	r3, r2
 801b934:	005b      	lsls	r3, r3, #1
 801b936:	4413      	add	r3, r2
 801b938:	00db      	lsls	r3, r3, #3
 801b93a:	440b      	add	r3, r1
 801b93c:	695b      	ldr	r3, [r3, #20]
 801b93e:	2b00      	cmp	r3, #0
 801b940:	d10d      	bne.n	801b95e <rt_can_control+0x17e>
                    {
                        rt_list_insert_before(&tx_fifo->freelist, &tx_fifo->buffer[i].list);
 801b942:	69bb      	ldr	r3, [r7, #24]
 801b944:	f103 0010 	add.w	r0, r3, #16
 801b948:	69bb      	ldr	r3, [r7, #24]
 801b94a:	6819      	ldr	r1, [r3, #0]
 801b94c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801b94e:	4613      	mov	r3, r2
 801b950:	005b      	lsls	r3, r3, #1
 801b952:	4413      	add	r3, r2
 801b954:	00db      	lsls	r3, r3, #3
 801b956:	440b      	add	r3, r1
 801b958:	4619      	mov	r1, r3
 801b95a:	f7ff fa85 	bl	801ae68 <rt_list_insert_before>
                    }
                    rt_hw_interrupt_enable(level);
 801b95e:	6978      	ldr	r0, [r7, #20]
 801b960:	f7e4 fc38 	bl	80001d4 <rt_hw_interrupt_enable>
                    rt_hw_interrupt_enable(level);
                }
            }
            else
            {
                for (i = 0;  i < can->config.sndboxnumber; i++)
 801b964:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b966:	3301      	adds	r3, #1
 801b968:	627b      	str	r3, [r7, #36]	; 0x24
 801b96a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801b96c:	6a3b      	ldr	r3, [r7, #32]
 801b96e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801b970:	429a      	cmp	r2, r3
 801b972:	d3d8      	bcc.n	801b926 <rt_can_control+0x146>
                        rt_list_insert_before(&tx_fifo->freelist, &tx_fifo->buffer[i].list);
                    }
                    rt_hw_interrupt_enable(level);
                }
            }
            return RT_EOK;
 801b974:	2300      	movs	r3, #0
 801b976:	e01b      	b.n	801b9b0 <rt_can_control+0x1d0>
        }
        break;
 801b978:	e019      	b.n	801b9ae <rt_can_control+0x1ce>

    case RT_CAN_CMD_SET_STATUS_IND:
        can->status_indicate.ind = ((rt_can_status_ind_type_t)args)->ind;
 801b97a:	687b      	ldr	r3, [r7, #4]
 801b97c:	681a      	ldr	r2, [r3, #0]
 801b97e:	6a3b      	ldr	r3, [r7, #32]
 801b980:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
        can->status_indicate.args = ((rt_can_status_ind_type_t)args)->args;
 801b984:	687b      	ldr	r3, [r7, #4]
 801b986:	685a      	ldr	r2, [r3, #4]
 801b988:	6a3b      	ldr	r3, [r7, #32]
 801b98a:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
        break;
 801b98e:	e00e      	b.n	801b9ae <rt_can_control+0x1ce>
        can->bus_hook = (rt_can_bus_hook) args;
        break;
#endif /*RT_CAN_USING_BUS_HOOK*/
    default :
        /* control device */
        if (can->ops->control != RT_NULL)
 801b990:	6a3b      	ldr	r3, [r7, #32]
 801b992:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b994:	685b      	ldr	r3, [r3, #4]
 801b996:	2b00      	cmp	r3, #0
 801b998:	d008      	beq.n	801b9ac <rt_can_control+0x1cc>
        {
            can->ops->control(can, cmd, args);
 801b99a:	6a3b      	ldr	r3, [r7, #32]
 801b99c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b99e:	685b      	ldr	r3, [r3, #4]
 801b9a0:	7afa      	ldrb	r2, [r7, #11]
 801b9a2:	6a38      	ldr	r0, [r7, #32]
 801b9a4:	4611      	mov	r1, r2
 801b9a6:	687a      	ldr	r2, [r7, #4]
 801b9a8:	4798      	blx	r3
        }
        break;
 801b9aa:	e7ff      	b.n	801b9ac <rt_can_control+0x1cc>
 801b9ac:	bf00      	nop
    }

    return RT_EOK;
 801b9ae:	2300      	movs	r3, #0
}
 801b9b0:	4618      	mov	r0, r3
 801b9b2:	3728      	adds	r7, #40	; 0x28
 801b9b4:	46bd      	mov	sp, r7
 801b9b6:	bd80      	pop	{r7, pc}
 801b9b8:	08029828 	.word	0x08029828
 801b9bc:	0802aee8 	.word	0x0802aee8

0801b9c0 <cantimeout>:

/*
 * can timer
 */
static void cantimeout(void *arg)
{
 801b9c0:	b580      	push	{r7, lr}
 801b9c2:	b084      	sub	sp, #16
 801b9c4:	af00      	add	r7, sp, #0
 801b9c6:	6078      	str	r0, [r7, #4]
    rt_can_t can = (rt_can_t)arg;
 801b9c8:	687b      	ldr	r3, [r7, #4]
 801b9ca:	60fb      	str	r3, [r7, #12]

    rt_device_control((rt_device_t)can, RT_CAN_CMD_GET_STATUS, (void *)&can->status);
 801b9cc:	68fb      	ldr	r3, [r7, #12]
 801b9ce:	3358      	adds	r3, #88	; 0x58
 801b9d0:	68f8      	ldr	r0, [r7, #12]
 801b9d2:	2117      	movs	r1, #23
 801b9d4:	461a      	mov	r2, r3
 801b9d6:	f7f9 fe63 	bl	80156a0 <rt_device_control>

    if (can->status_indicate.ind != RT_NULL)
 801b9da:	68fb      	ldr	r3, [r7, #12]
 801b9dc:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 801b9e0:	2b00      	cmp	r3, #0
 801b9e2:	d008      	beq.n	801b9f6 <cantimeout+0x36>
    {
        can->status_indicate.ind(can, can->status_indicate.args);
 801b9e4:	68fb      	ldr	r3, [r7, #12]
 801b9e6:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 801b9ea:	68fa      	ldr	r2, [r7, #12]
 801b9ec:	f8d2 20c8 	ldr.w	r2, [r2, #200]	; 0xc8
 801b9f0:	68f8      	ldr	r0, [r7, #12]
 801b9f2:	4611      	mov	r1, r2
 801b9f4:	4798      	blx	r3
    if(can->bus_hook)
    {
        can->bus_hook(can);
    }
#endif /*RT_CAN_USING_BUS_HOOK*/
    if (can->timerinitflag == 1)
 801b9f6:	68fb      	ldr	r3, [r7, #12]
 801b9f8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 801b9fc:	2b01      	cmp	r3, #1
 801b9fe:	d103      	bne.n	801ba08 <cantimeout+0x48>
    {
        can->timerinitflag = 0xFF;
 801ba00:	68fb      	ldr	r3, [r7, #12]
 801ba02:	22ff      	movs	r2, #255	; 0xff
 801ba04:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    }
}
 801ba08:	3710      	adds	r7, #16
 801ba0a:	46bd      	mov	sp, r7
 801ba0c:	bd80      	pop	{r7, pc}
 801ba0e:	bf00      	nop

0801ba10 <rt_hw_can_register>:
 */
rt_err_t rt_hw_can_register(struct rt_can_device *can,
                            const char              *name,
                            const struct rt_can_ops *ops,
                            void                    *data)
{
 801ba10:	b580      	push	{r7, lr}
 801ba12:	b088      	sub	sp, #32
 801ba14:	af02      	add	r7, sp, #8
 801ba16:	60f8      	str	r0, [r7, #12]
 801ba18:	60b9      	str	r1, [r7, #8]
 801ba1a:	607a      	str	r2, [r7, #4]
 801ba1c:	603b      	str	r3, [r7, #0]
    struct rt_device *device;
    RT_ASSERT(can != RT_NULL);
 801ba1e:	68fb      	ldr	r3, [r7, #12]
 801ba20:	2b00      	cmp	r3, #0
 801ba22:	d105      	bne.n	801ba30 <rt_hw_can_register+0x20>
 801ba24:	4831      	ldr	r0, [pc, #196]	; (801baec <rt_hw_can_register+0xdc>)
 801ba26:	4932      	ldr	r1, [pc, #200]	; (801baf0 <rt_hw_can_register+0xe0>)
 801ba28:	f240 22c3 	movw	r2, #707	; 0x2c3
 801ba2c:	f7fb fbea 	bl	8017204 <rt_assert_handler>

    device = &(can->parent);
 801ba30:	68fb      	ldr	r3, [r7, #12]
 801ba32:	617b      	str	r3, [r7, #20]

    device->type        = RT_Device_Class_CAN;
 801ba34:	697b      	ldr	r3, [r7, #20]
 801ba36:	2204      	movs	r2, #4
 801ba38:	751a      	strb	r2, [r3, #20]
    device->rx_indicate = RT_NULL;
 801ba3a:	697b      	ldr	r3, [r7, #20]
 801ba3c:	2200      	movs	r2, #0
 801ba3e:	61da      	str	r2, [r3, #28]
    device->tx_complete = RT_NULL;
 801ba40:	697b      	ldr	r3, [r7, #20]
 801ba42:	2200      	movs	r2, #0
 801ba44:	621a      	str	r2, [r3, #32]
#ifdef RT_CAN_USING_HDR
    can->hdr            = RT_NULL;
#endif
    can->can_rx         = RT_NULL;
 801ba46:	68fb      	ldr	r3, [r7, #12]
 801ba48:	2200      	movs	r2, #0
 801ba4a:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
    can->can_tx         = RT_NULL;
 801ba4e:	68fb      	ldr	r3, [r7, #12]
 801ba50:	2200      	movs	r2, #0
 801ba52:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
    rt_mutex_init(&(can->lock), "can", RT_IPC_FLAG_PRIO);
 801ba56:	68fb      	ldr	r3, [r7, #12]
 801ba58:	33cc      	adds	r3, #204	; 0xcc
 801ba5a:	4618      	mov	r0, r3
 801ba5c:	4925      	ldr	r1, [pc, #148]	; (801baf4 <rt_hw_can_register+0xe4>)
 801ba5e:	2201      	movs	r2, #1
 801ba60:	f7fa f91a 	bl	8015c98 <rt_mutex_init>
#ifdef RT_CAN_USING_BUS_HOOK
    can->bus_hook       = RT_NULL;
#endif /*RT_CAN_USING_BUS_HOOK*/
    device->init        = rt_can_init;
 801ba64:	697b      	ldr	r3, [r7, #20]
 801ba66:	4a24      	ldr	r2, [pc, #144]	; (801baf8 <rt_hw_can_register+0xe8>)
 801ba68:	625a      	str	r2, [r3, #36]	; 0x24
    device->open        = rt_can_open;
 801ba6a:	697b      	ldr	r3, [r7, #20]
 801ba6c:	4a23      	ldr	r2, [pc, #140]	; (801bafc <rt_hw_can_register+0xec>)
 801ba6e:	629a      	str	r2, [r3, #40]	; 0x28
    device->close       = rt_can_close;
 801ba70:	697b      	ldr	r3, [r7, #20]
 801ba72:	4a23      	ldr	r2, [pc, #140]	; (801bb00 <rt_hw_can_register+0xf0>)
 801ba74:	62da      	str	r2, [r3, #44]	; 0x2c
    device->read        = rt_can_read;
 801ba76:	697b      	ldr	r3, [r7, #20]
 801ba78:	4a22      	ldr	r2, [pc, #136]	; (801bb04 <rt_hw_can_register+0xf4>)
 801ba7a:	631a      	str	r2, [r3, #48]	; 0x30
    device->write       = rt_can_write;
 801ba7c:	697b      	ldr	r3, [r7, #20]
 801ba7e:	4a22      	ldr	r2, [pc, #136]	; (801bb08 <rt_hw_can_register+0xf8>)
 801ba80:	635a      	str	r2, [r3, #52]	; 0x34
    device->control     = rt_can_control;
 801ba82:	697b      	ldr	r3, [r7, #20]
 801ba84:	4a21      	ldr	r2, [pc, #132]	; (801bb0c <rt_hw_can_register+0xfc>)
 801ba86:	639a      	str	r2, [r3, #56]	; 0x38
    can->ops            = ops;
 801ba88:	68fb      	ldr	r3, [r7, #12]
 801ba8a:	687a      	ldr	r2, [r7, #4]
 801ba8c:	641a      	str	r2, [r3, #64]	; 0x40

    can->status_indicate.ind  = RT_NULL;
 801ba8e:	68fb      	ldr	r3, [r7, #12]
 801ba90:	2200      	movs	r2, #0
 801ba92:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
    can->status_indicate.args = RT_NULL;
 801ba96:	68fb      	ldr	r3, [r7, #12]
 801ba98:	2200      	movs	r2, #0
 801ba9a:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    rt_memset(&can->status, 0, sizeof(can->status));
 801ba9e:	68fb      	ldr	r3, [r7, #12]
 801baa0:	3358      	adds	r3, #88	; 0x58
 801baa2:	4618      	mov	r0, r3
 801baa4:	2100      	movs	r1, #0
 801baa6:	223c      	movs	r2, #60	; 0x3c
 801baa8:	f7fa fd7a 	bl	80165a0 <rt_memset>

    device->user_data   = data;
 801baac:	697b      	ldr	r3, [r7, #20]
 801baae:	683a      	ldr	r2, [r7, #0]
 801bab0:	63da      	str	r2, [r3, #60]	; 0x3c

    can->timerinitflag  = 0;
 801bab2:	68fb      	ldr	r3, [r7, #12]
 801bab4:	2200      	movs	r2, #0
 801bab6:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    rt_timer_init(&can->timer,
 801baba:	68fb      	ldr	r3, [r7, #12]
 801babc:	f103 0298 	add.w	r2, r3, #152	; 0x98
 801bac0:	68fb      	ldr	r3, [r7, #12]
 801bac2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801bac4:	9300      	str	r3, [sp, #0]
 801bac6:	2302      	movs	r3, #2
 801bac8:	9301      	str	r3, [sp, #4]
 801baca:	4610      	mov	r0, r2
 801bacc:	68b9      	ldr	r1, [r7, #8]
 801bace:	4a10      	ldr	r2, [pc, #64]	; (801bb10 <rt_hw_can_register+0x100>)
 801bad0:	68fb      	ldr	r3, [r7, #12]
 801bad2:	f7fc ffb5 	bl	8018a40 <rt_timer_init>
                  cantimeout,
                  (void *)can,
                  can->config.ticks,
                  RT_TIMER_FLAG_PERIODIC);
    /* register a character device */
    return rt_device_register(device, name, RT_DEVICE_FLAG_RDWR);
 801bad6:	6978      	ldr	r0, [r7, #20]
 801bad8:	68b9      	ldr	r1, [r7, #8]
 801bada:	2203      	movs	r2, #3
 801badc:	f7f9 fc62 	bl	80153a4 <rt_device_register>
 801bae0:	4603      	mov	r3, r0
}
 801bae2:	4618      	mov	r0, r3
 801bae4:	3718      	adds	r7, #24
 801bae6:	46bd      	mov	sp, r7
 801bae8:	bd80      	pop	{r7, pc}
 801baea:	bf00      	nop
 801baec:	08029838 	.word	0x08029838
 801baf0:	0802aef8 	.word	0x0802aef8
 801baf4:	080298b4 	.word	0x080298b4
 801baf8:	0801aef1 	.word	0x0801aef1
 801bafc:	0801b351 	.word	0x0801b351
 801bb00:	0801b5b9 	.word	0x0801b5b9
 801bb04:	0801b6f1 	.word	0x0801b6f1
 801bb08:	0801b755 	.word	0x0801b755
 801bb0c:	0801b7e1 	.word	0x0801b7e1
 801bb10:	0801b9c1 	.word	0x0801b9c1

0801bb14 <cmd_canstat>:
}

#ifdef RT_USING_FINSH
#include <finsh.h>
int cmd_canstat(int argc, void **argv)
{
 801bb14:	b580      	push	{r7, lr}
 801bb16:	b092      	sub	sp, #72	; 0x48
 801bb18:	af00      	add	r7, sp, #0
 801bb1a:	6078      	str	r0, [r7, #4]
 801bb1c:	6039      	str	r1, [r7, #0]
        "Warning !",
        "Passive !",
        "Bus Off !"
    };

    if (argc >= 2)
 801bb1e:	687b      	ldr	r3, [r7, #4]
 801bb20:	2b01      	cmp	r3, #1
 801bb22:	f340 8082 	ble.w	801bc2a <cmd_canstat+0x116>
    {
        struct rt_can_status status;
        rt_device_t candev = rt_device_find(argv[1]);
 801bb26:	683b      	ldr	r3, [r7, #0]
 801bb28:	3304      	adds	r3, #4
 801bb2a:	681b      	ldr	r3, [r3, #0]
 801bb2c:	4618      	mov	r0, r3
 801bb2e:	f7f9 fc61 	bl	80153f4 <rt_device_find>
 801bb32:	6478      	str	r0, [r7, #68]	; 0x44
        if (!candev)
 801bb34:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bb36:	2b00      	cmp	r3, #0
 801bb38:	d109      	bne.n	801bb4e <cmd_canstat+0x3a>
        {
            rt_kprintf(" Can't find can device %s\n", argv[1]);
 801bb3a:	683b      	ldr	r3, [r7, #0]
 801bb3c:	3304      	adds	r3, #4
 801bb3e:	681b      	ldr	r3, [r3, #0]
 801bb40:	4842      	ldr	r0, [pc, #264]	; (801bc4c <cmd_canstat+0x138>)
 801bb42:	4619      	mov	r1, r3
 801bb44:	f7fb fae4 	bl	8017110 <rt_kprintf>
            return -1;
 801bb48:	f04f 33ff 	mov.w	r3, #4294967295
 801bb4c:	e07a      	b.n	801bc44 <cmd_canstat+0x130>
        }
        rt_kprintf(" Finded can device: %s...", argv[1]);
 801bb4e:	683b      	ldr	r3, [r7, #0]
 801bb50:	3304      	adds	r3, #4
 801bb52:	681b      	ldr	r3, [r3, #0]
 801bb54:	483e      	ldr	r0, [pc, #248]	; (801bc50 <cmd_canstat+0x13c>)
 801bb56:	4619      	mov	r1, r3
 801bb58:	f7fb fada 	bl	8017110 <rt_kprintf>

        rt_device_control(candev, RT_CAN_CMD_GET_STATUS, &status);
 801bb5c:	f107 0308 	add.w	r3, r7, #8
 801bb60:	6c78      	ldr	r0, [r7, #68]	; 0x44
 801bb62:	2117      	movs	r1, #23
 801bb64:	461a      	mov	r2, r3
 801bb66:	f7f9 fd9b 	bl	80156a0 <rt_device_control>
        rt_kprintf("\n Receive...error..count: %010ld. Send.....error....count: %010ld.",
 801bb6a:	68ba      	ldr	r2, [r7, #8]
 801bb6c:	68fb      	ldr	r3, [r7, #12]
 801bb6e:	4839      	ldr	r0, [pc, #228]	; (801bc54 <cmd_canstat+0x140>)
 801bb70:	4611      	mov	r1, r2
 801bb72:	461a      	mov	r2, r3
 801bb74:	f7fb facc 	bl	8017110 <rt_kprintf>
                   status.rcverrcnt, status.snderrcnt);
        rt_kprintf("\n Bit..pad..error..count: %010ld. Format...error....count: %010ld",
 801bb78:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801bb7a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801bb7c:	4836      	ldr	r0, [pc, #216]	; (801bc58 <cmd_canstat+0x144>)
 801bb7e:	4611      	mov	r1, r2
 801bb80:	461a      	mov	r2, r3
 801bb82:	f7fb fac5 	bl	8017110 <rt_kprintf>
                   status.bitpaderrcnt, status.formaterrcnt);
        rt_kprintf("\n Ack.......error..count: %010ld. Bit......error....count: %010ld.",
 801bb86:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801bb88:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bb8a:	4834      	ldr	r0, [pc, #208]	; (801bc5c <cmd_canstat+0x148>)
 801bb8c:	4611      	mov	r1, r2
 801bb8e:	461a      	mov	r2, r3
 801bb90:	f7fb fabe 	bl	8017110 <rt_kprintf>
                   status.ackerrcnt, status.biterrcnt);
        rt_kprintf("\n CRC.......error..count: %010ld. Error.code.[%010ld]: ",
 801bb94:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801bb96:	693b      	ldr	r3, [r7, #16]
 801bb98:	4831      	ldr	r0, [pc, #196]	; (801bc60 <cmd_canstat+0x14c>)
 801bb9a:	4611      	mov	r1, r2
 801bb9c:	461a      	mov	r2, r3
 801bb9e:	f7fb fab7 	bl	8017110 <rt_kprintf>
                   status.crcerrcnt, status.errcode);
        switch (status.errcode)
 801bba2:	693b      	ldr	r3, [r7, #16]
 801bba4:	2b07      	cmp	r3, #7
 801bba6:	d82f      	bhi.n	801bc08 <cmd_canstat+0xf4>
 801bba8:	a201      	add	r2, pc, #4	; (adr r2, 801bbb0 <cmd_canstat+0x9c>)
 801bbaa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801bbae:	bf00      	nop
 801bbb0:	0801bbd1 	.word	0x0801bbd1
 801bbb4:	0801bbdf 	.word	0x0801bbdf
 801bbb8:	0801bbed 	.word	0x0801bbed
 801bbbc:	0801bbed 	.word	0x0801bbed
 801bbc0:	0801bbfb 	.word	0x0801bbfb
 801bbc4:	0801bbfb 	.word	0x0801bbfb
 801bbc8:	0801bbfb 	.word	0x0801bbfb
 801bbcc:	0801bbfb 	.word	0x0801bbfb
        {
        case 0:
            rt_kprintf("%s.", ErrCode[0]);
 801bbd0:	4b24      	ldr	r3, [pc, #144]	; (801bc64 <cmd_canstat+0x150>)
 801bbd2:	681b      	ldr	r3, [r3, #0]
 801bbd4:	4824      	ldr	r0, [pc, #144]	; (801bc68 <cmd_canstat+0x154>)
 801bbd6:	4619      	mov	r1, r3
 801bbd8:	f7fb fa9a 	bl	8017110 <rt_kprintf>
            break;
 801bbdc:	e014      	b.n	801bc08 <cmd_canstat+0xf4>
        case 1:
            rt_kprintf("%s.", ErrCode[1]);
 801bbde:	4b21      	ldr	r3, [pc, #132]	; (801bc64 <cmd_canstat+0x150>)
 801bbe0:	685b      	ldr	r3, [r3, #4]
 801bbe2:	4821      	ldr	r0, [pc, #132]	; (801bc68 <cmd_canstat+0x154>)
 801bbe4:	4619      	mov	r1, r3
 801bbe6:	f7fb fa93 	bl	8017110 <rt_kprintf>
            break;
 801bbea:	e00d      	b.n	801bc08 <cmd_canstat+0xf4>
        case 2:
        case 3:
            rt_kprintf("%s.", ErrCode[2]);
 801bbec:	4b1d      	ldr	r3, [pc, #116]	; (801bc64 <cmd_canstat+0x150>)
 801bbee:	689b      	ldr	r3, [r3, #8]
 801bbf0:	481d      	ldr	r0, [pc, #116]	; (801bc68 <cmd_canstat+0x154>)
 801bbf2:	4619      	mov	r1, r3
 801bbf4:	f7fb fa8c 	bl	8017110 <rt_kprintf>
            break;
 801bbf8:	e006      	b.n	801bc08 <cmd_canstat+0xf4>
        case 4:
        case 5:
        case 6:
        case 7:
            rt_kprintf("%s.", ErrCode[3]);
 801bbfa:	4b1a      	ldr	r3, [pc, #104]	; (801bc64 <cmd_canstat+0x150>)
 801bbfc:	68db      	ldr	r3, [r3, #12]
 801bbfe:	481a      	ldr	r0, [pc, #104]	; (801bc68 <cmd_canstat+0x154>)
 801bc00:	4619      	mov	r1, r3
 801bc02:	f7fb fa85 	bl	8017110 <rt_kprintf>
            break;
 801bc06:	bf00      	nop
        }
        rt_kprintf("\n Total.receive.packages: %010ld. Droped.receive.packages: %010ld.",
 801bc08:	697a      	ldr	r2, [r7, #20]
 801bc0a:	69bb      	ldr	r3, [r7, #24]
 801bc0c:	4817      	ldr	r0, [pc, #92]	; (801bc6c <cmd_canstat+0x158>)
 801bc0e:	4611      	mov	r1, r2
 801bc10:	461a      	mov	r2, r3
 801bc12:	f7fb fa7d 	bl	8017110 <rt_kprintf>
                   status.rcvpkg, status.dropedrcvpkg);
        rt_kprintf("\n Total..send...packages: %010ld. Droped...send..packages: %010ld.\n",
                   status.sndpkg + status.dropedsndpkg, status.dropedsndpkg);
 801bc16:	69fa      	ldr	r2, [r7, #28]
 801bc18:	6a3b      	ldr	r3, [r7, #32]
            rt_kprintf("%s.", ErrCode[3]);
            break;
        }
        rt_kprintf("\n Total.receive.packages: %010ld. Droped.receive.packages: %010ld.",
                   status.rcvpkg, status.dropedrcvpkg);
        rt_kprintf("\n Total..send...packages: %010ld. Droped...send..packages: %010ld.\n",
 801bc1a:	441a      	add	r2, r3
 801bc1c:	6a3b      	ldr	r3, [r7, #32]
 801bc1e:	4814      	ldr	r0, [pc, #80]	; (801bc70 <cmd_canstat+0x15c>)
 801bc20:	4611      	mov	r1, r2
 801bc22:	461a      	mov	r2, r3
 801bc24:	f7fb fa74 	bl	8017110 <rt_kprintf>
 801bc28:	e00b      	b.n	801bc42 <cmd_canstat+0x12e>
                   status.sndpkg + status.dropedsndpkg, status.dropedsndpkg);
    }
    else
    {
        rt_kprintf(" Invalid Call %s\n", argv[0]);
 801bc2a:	683b      	ldr	r3, [r7, #0]
 801bc2c:	681b      	ldr	r3, [r3, #0]
 801bc2e:	4811      	ldr	r0, [pc, #68]	; (801bc74 <cmd_canstat+0x160>)
 801bc30:	4619      	mov	r1, r3
 801bc32:	f7fb fa6d 	bl	8017110 <rt_kprintf>
        rt_kprintf(" Please using %s cannamex .Here canname is driver name and x is candrive number.\n", argv[0]);
 801bc36:	683b      	ldr	r3, [r7, #0]
 801bc38:	681b      	ldr	r3, [r3, #0]
 801bc3a:	480f      	ldr	r0, [pc, #60]	; (801bc78 <cmd_canstat+0x164>)
 801bc3c:	4619      	mov	r1, r3
 801bc3e:	f7fb fa67 	bl	8017110 <rt_kprintf>
    }
    return 0;
 801bc42:	2300      	movs	r3, #0
}
 801bc44:	4618      	mov	r0, r3
 801bc46:	3748      	adds	r7, #72	; 0x48
 801bc48:	46bd      	mov	sp, r7
 801bc4a:	bd80      	pop	{r7, pc}
 801bc4c:	08029904 	.word	0x08029904
 801bc50:	08029920 	.word	0x08029920
 801bc54:	0802993c 	.word	0x0802993c
 801bc58:	08029980 	.word	0x08029980
 801bc5c:	080299c4 	.word	0x080299c4
 801bc60:	08029a08 	.word	0x08029a08
 801bc64:	200100bc 	.word	0x200100bc
 801bc68:	08029a40 	.word	0x08029a40
 801bc6c:	08029a44 	.word	0x08029a44
 801bc70:	08029a88 	.word	0x08029a88
 801bc74:	08029acc 	.word	0x08029acc
 801bc78:	08029ae0 	.word	0x08029ae0

0801bc7c <finsh_get_prompt>:
#if defined(FINSH_USING_MSH) || (defined(RT_USING_DFS) && defined(DFS_USING_WORKDIR))
#if defined(RT_USING_DFS)
#include <dfs_posix.h>
#endif
const char *finsh_get_prompt()
{
 801bc7c:	b580      	push	{r7, lr}
 801bc7e:	af00      	add	r7, sp, #0
#define _MSH_PROMPT "msh "
#define _PROMPT     "finsh "
    static char finsh_prompt[RT_CONSOLEBUF_SIZE + 1] = {0};

#ifdef FINSH_USING_MSH
    if (msh_is_used()) strcpy(finsh_prompt, _MSH_PROMPT);
 801bc80:	f001 fb78 	bl	801d374 <msh_is_used>
 801bc84:	4603      	mov	r3, r0
 801bc86:	2b00      	cmp	r3, #0
 801bc88:	d007      	beq.n	801bc9a <finsh_get_prompt+0x1e>
 801bc8a:	4b10      	ldr	r3, [pc, #64]	; (801bccc <finsh_get_prompt+0x50>)
 801bc8c:	4a10      	ldr	r2, [pc, #64]	; (801bcd0 <finsh_get_prompt+0x54>)
 801bc8e:	e892 0003 	ldmia.w	r2, {r0, r1}
 801bc92:	6018      	str	r0, [r3, #0]
 801bc94:	3304      	adds	r3, #4
 801bc96:	7019      	strb	r1, [r3, #0]
 801bc98:	e009      	b.n	801bcae <finsh_get_prompt+0x32>
    else
#endif
        strcpy(finsh_prompt, _PROMPT);
 801bc9a:	4b0c      	ldr	r3, [pc, #48]	; (801bccc <finsh_get_prompt+0x50>)
 801bc9c:	4a0d      	ldr	r2, [pc, #52]	; (801bcd4 <finsh_get_prompt+0x58>)
 801bc9e:	e892 0003 	ldmia.w	r2, {r0, r1}
 801bca2:	6018      	str	r0, [r3, #0]
 801bca4:	3304      	adds	r3, #4
 801bca6:	8019      	strh	r1, [r3, #0]
 801bca8:	3302      	adds	r3, #2
 801bcaa:	0c0a      	lsrs	r2, r1, #16
 801bcac:	701a      	strb	r2, [r3, #0]
#if defined(RT_USING_DFS) && defined(DFS_USING_WORKDIR)
    /* get current working directory */
    getcwd(&finsh_prompt[rt_strlen(finsh_prompt)], RT_CONSOLEBUF_SIZE - rt_strlen(finsh_prompt));
#endif

    strcat(finsh_prompt, ">");
 801bcae:	4807      	ldr	r0, [pc, #28]	; (801bccc <finsh_get_prompt+0x50>)
 801bcb0:	f007 f976 	bl	8022fa0 <strlen>
 801bcb4:	4603      	mov	r3, r0
 801bcb6:	461a      	mov	r2, r3
 801bcb8:	4b04      	ldr	r3, [pc, #16]	; (801bccc <finsh_get_prompt+0x50>)
 801bcba:	4413      	add	r3, r2
 801bcbc:	4906      	ldr	r1, [pc, #24]	; (801bcd8 <finsh_get_prompt+0x5c>)
 801bcbe:	461a      	mov	r2, r3
 801bcc0:	460b      	mov	r3, r1
 801bcc2:	881b      	ldrh	r3, [r3, #0]
 801bcc4:	8013      	strh	r3, [r2, #0]

    return finsh_prompt;
 801bcc6:	4b01      	ldr	r3, [pc, #4]	; (801bccc <finsh_get_prompt+0x50>)
}
 801bcc8:	4618      	mov	r0, r3
 801bcca:	bd80      	pop	{r7, pc}
 801bccc:	2001212c 	.word	0x2001212c
 801bcd0:	08029b64 	.word	0x08029b64
 801bcd4:	08029b6c 	.word	0x08029b6c
 801bcd8:	08029b74 	.word	0x08029b74

0801bcdc <finsh_rx_ind>:
#endif

static rt_err_t finsh_rx_ind(rt_device_t dev, rt_size_t size)
{
 801bcdc:	b580      	push	{r7, lr}
 801bcde:	b082      	sub	sp, #8
 801bce0:	af00      	add	r7, sp, #0
 801bce2:	6078      	str	r0, [r7, #4]
 801bce4:	6039      	str	r1, [r7, #0]
    RT_ASSERT(shell != RT_NULL);
 801bce6:	4b09      	ldr	r3, [pc, #36]	; (801bd0c <finsh_rx_ind+0x30>)
 801bce8:	681b      	ldr	r3, [r3, #0]
 801bcea:	2b00      	cmp	r3, #0
 801bcec:	d104      	bne.n	801bcf8 <finsh_rx_ind+0x1c>
 801bcee:	4808      	ldr	r0, [pc, #32]	; (801bd10 <finsh_rx_ind+0x34>)
 801bcf0:	4908      	ldr	r1, [pc, #32]	; (801bd14 <finsh_rx_ind+0x38>)
 801bcf2:	2256      	movs	r2, #86	; 0x56
 801bcf4:	f7fb fa86 	bl	8017204 <rt_assert_handler>

    /* release semaphore to let finsh thread rx data */
    rt_sem_release(&shell->rx_sem);
 801bcf8:	4b04      	ldr	r3, [pc, #16]	; (801bd0c <finsh_rx_ind+0x30>)
 801bcfa:	681b      	ldr	r3, [r3, #0]
 801bcfc:	4618      	mov	r0, r3
 801bcfe:	f7f9 ff97 	bl	8015c30 <rt_sem_release>

    return RT_EOK;
 801bd02:	2300      	movs	r3, #0
}
 801bd04:	4618      	mov	r0, r3
 801bd06:	3708      	adds	r7, #8
 801bd08:	46bd      	mov	sp, r7
 801bd0a:	bd80      	pop	{r7, pc}
 801bd0c:	20012bd8 	.word	0x20012bd8
 801bd10:	08029b78 	.word	0x08029b78
 801bd14:	0802af0c 	.word	0x0802af0c

0801bd18 <shell_auto_complete>:

    return shell->echo_mode;
}

static void shell_auto_complete(char *prefix)
{
 801bd18:	b580      	push	{r7, lr}
 801bd1a:	b082      	sub	sp, #8
 801bd1c:	af00      	add	r7, sp, #0
 801bd1e:	6078      	str	r0, [r7, #4]

    rt_kprintf("\n");
 801bd20:	480c      	ldr	r0, [pc, #48]	; (801bd54 <shell_auto_complete+0x3c>)
 801bd22:	f7fb f9f5 	bl	8017110 <rt_kprintf>
#ifdef FINSH_USING_MSH
    if (msh_is_used() == RT_TRUE)
 801bd26:	f001 fb25 	bl	801d374 <msh_is_used>
 801bd2a:	4603      	mov	r3, r0
 801bd2c:	2b01      	cmp	r3, #1
 801bd2e:	d103      	bne.n	801bd38 <shell_auto_complete+0x20>
    {
        msh_auto_complete(prefix);
 801bd30:	6878      	ldr	r0, [r7, #4]
 801bd32:	f001 fd31 	bl	801d798 <msh_auto_complete>
 801bd36:	e002      	b.n	801bd3e <shell_auto_complete+0x26>
    else
#endif
    {
#ifndef FINSH_USING_MSH_ONLY
        extern void list_prefix(char * prefix);
        list_prefix(prefix);
 801bd38:	6878      	ldr	r0, [r7, #4]
 801bd3a:	f001 f9ad 	bl	801d098 <list_prefix>
#endif
    }

    rt_kprintf("%s%s", FINSH_PROMPT, prefix);
 801bd3e:	f7ff ff9d 	bl	801bc7c <finsh_get_prompt>
 801bd42:	4603      	mov	r3, r0
 801bd44:	4804      	ldr	r0, [pc, #16]	; (801bd58 <shell_auto_complete+0x40>)
 801bd46:	4619      	mov	r1, r3
 801bd48:	687a      	ldr	r2, [r7, #4]
 801bd4a:	f7fb f9e1 	bl	8017110 <rt_kprintf>
}
 801bd4e:	3708      	adds	r7, #8
 801bd50:	46bd      	mov	sp, r7
 801bd52:	bd80      	pop	{r7, pc}
 801bd54:	08029bac 	.word	0x08029bac
 801bd58:	08029bb0 	.word	0x08029bb0

0801bd5c <finsh_run_line>:

#ifndef FINSH_USING_MSH_ONLY
void finsh_run_line(struct finsh_parser *parser, const char *line)
{
 801bd5c:	b5b0      	push	{r4, r5, r7, lr}
 801bd5e:	b084      	sub	sp, #16
 801bd60:	af00      	add	r7, sp, #0
 801bd62:	6078      	str	r0, [r7, #4]
 801bd64:	6039      	str	r1, [r7, #0]
    const char *err_str;

    rt_kprintf("\n");
 801bd66:	4829      	ldr	r0, [pc, #164]	; (801be0c <finsh_run_line+0xb0>)
 801bd68:	f7fb f9d2 	bl	8017110 <rt_kprintf>
    finsh_parser_run(parser, (unsigned char *)line);
 801bd6c:	6878      	ldr	r0, [r7, #4]
 801bd6e:	6839      	ldr	r1, [r7, #0]
 801bd70:	f005 fbce 	bl	8021510 <finsh_parser_run>

    /* compile node root */
    if (finsh_errno() == 0)
 801bd74:	f003 fad4 	bl	801f320 <finsh_errno>
 801bd78:	4603      	mov	r3, r0
 801bd7a:	2b00      	cmp	r3, #0
 801bd7c:	d106      	bne.n	801bd8c <finsh_run_line+0x30>
    {
        finsh_compiler_run(parser->root);
 801bd7e:	687b      	ldr	r3, [r7, #4]
 801bd80:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 801bd84:	4618      	mov	r0, r3
 801bd86:	f003 fa69 	bl	801f25c <finsh_compiler_run>
 801bd8a:	e00a      	b.n	801bda2 <finsh_run_line+0x46>
    }
    else
    {
        err_str = finsh_error_string(finsh_errno());
 801bd8c:	f003 fac8 	bl	801f320 <finsh_errno>
 801bd90:	4603      	mov	r3, r0
 801bd92:	4618      	mov	r0, r3
 801bd94:	f003 fad0 	bl	801f338 <finsh_error_string>
 801bd98:	60f8      	str	r0, [r7, #12]
        rt_kprintf("%s\n", err_str);
 801bd9a:	481d      	ldr	r0, [pc, #116]	; (801be10 <finsh_run_line+0xb4>)
 801bd9c:	68f9      	ldr	r1, [r7, #12]
 801bd9e:	f7fb f9b7 	bl	8017110 <rt_kprintf>
    }

    /* run virtual machine */
    if (finsh_errno() == 0)
 801bda2:	f003 fabd 	bl	801f320 <finsh_errno>
 801bda6:	4603      	mov	r3, r0
 801bda8:	2b00      	cmp	r3, #0
 801bdaa:	d129      	bne.n	801be00 <finsh_run_line+0xa4>
    {
        char ch;
        finsh_vm_run();
 801bdac:	f005 fd44 	bl	8021838 <finsh_vm_run>

        ch = (unsigned char)finsh_stack_bottom();
 801bdb0:	f003 fcb8 	bl	801f724 <finsh_stack_bottom>
 801bdb4:	4603      	mov	r3, r0
 801bdb6:	72fb      	strb	r3, [r7, #11]
        if (ch > 0x20 && ch < 0x7e)
 801bdb8:	7afb      	ldrb	r3, [r7, #11]
 801bdba:	2b20      	cmp	r3, #32
 801bdbc:	d914      	bls.n	801bde8 <finsh_run_line+0x8c>
 801bdbe:	7afb      	ldrb	r3, [r7, #11]
 801bdc0:	2b7d      	cmp	r3, #125	; 0x7d
 801bdc2:	d811      	bhi.n	801bde8 <finsh_run_line+0x8c>
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
                       (unsigned char)finsh_stack_bottom(),
 801bdc4:	f003 fcae 	bl	801f724 <finsh_stack_bottom>
 801bdc8:	4603      	mov	r3, r0
 801bdca:	b2db      	uxtb	r3, r3
        finsh_vm_run();

        ch = (unsigned char)finsh_stack_bottom();
        if (ch > 0x20 && ch < 0x7e)
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
 801bdcc:	461d      	mov	r5, r3
                       (unsigned char)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom(),
 801bdce:	f003 fca9 	bl	801f724 <finsh_stack_bottom>
 801bdd2:	4603      	mov	r3, r0
        finsh_vm_run();

        ch = (unsigned char)finsh_stack_bottom();
        if (ch > 0x20 && ch < 0x7e)
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
 801bdd4:	461c      	mov	r4, r3
                       (unsigned char)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
 801bdd6:	f003 fca5 	bl	801f724 <finsh_stack_bottom>
 801bdda:	4603      	mov	r3, r0
        finsh_vm_run();

        ch = (unsigned char)finsh_stack_bottom();
        if (ch > 0x20 && ch < 0x7e)
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
 801bddc:	480d      	ldr	r0, [pc, #52]	; (801be14 <finsh_run_line+0xb8>)
 801bdde:	4629      	mov	r1, r5
 801bde0:	4622      	mov	r2, r4
 801bde2:	f7fb f995 	bl	8017110 <rt_kprintf>
 801bde6:	e00b      	b.n	801be00 <finsh_run_line+0xa4>
                       (unsigned int)finsh_stack_bottom());
        }
        else
        {
            rt_kprintf("\t%d, 0x%08x\n",
                       (unsigned int)finsh_stack_bottom(),
 801bde8:	f003 fc9c 	bl	801f724 <finsh_stack_bottom>
 801bdec:	4603      	mov	r3, r0
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
        }
        else
        {
            rt_kprintf("\t%d, 0x%08x\n",
 801bdee:	461c      	mov	r4, r3
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
 801bdf0:	f003 fc98 	bl	801f724 <finsh_stack_bottom>
 801bdf4:	4603      	mov	r3, r0
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
        }
        else
        {
            rt_kprintf("\t%d, 0x%08x\n",
 801bdf6:	4808      	ldr	r0, [pc, #32]	; (801be18 <finsh_run_line+0xbc>)
 801bdf8:	4621      	mov	r1, r4
 801bdfa:	461a      	mov	r2, r3
 801bdfc:	f7fb f988 	bl	8017110 <rt_kprintf>
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
        }
    }

    finsh_flush(parser);
 801be00:	6878      	ldr	r0, [r7, #4]
 801be02:	f003 fc9b 	bl	801f73c <finsh_flush>
}
 801be06:	3710      	adds	r7, #16
 801be08:	46bd      	mov	sp, r7
 801be0a:	bdb0      	pop	{r4, r5, r7, pc}
 801be0c:	08029bac 	.word	0x08029bac
 801be10:	08029bb8 	.word	0x08029bb8
 801be14:	08029bbc 	.word	0x08029bbc
 801be18:	08029bd0 	.word	0x08029bd0

0801be1c <shell_handle_history>:
#endif

#ifdef FINSH_USING_HISTORY
static rt_bool_t shell_handle_history(struct finsh_shell *shell)
{
 801be1c:	b580      	push	{r7, lr}
 801be1e:	b082      	sub	sp, #8
 801be20:	af00      	add	r7, sp, #0
 801be22:	6078      	str	r0, [r7, #4]
    for (i = 0; i <= 60; i++)
        putchar(' ');
    rt_kprintf("\r");

#else
    rt_kprintf("\033[2K\r");
 801be24:	4809      	ldr	r0, [pc, #36]	; (801be4c <shell_handle_history+0x30>)
 801be26:	f7fb f973 	bl	8017110 <rt_kprintf>
#endif
    rt_kprintf("%s%s", FINSH_PROMPT, shell->line);
 801be2a:	f7ff ff27 	bl	801bc7c <finsh_get_prompt>
 801be2e:	4602      	mov	r2, r0
 801be30:	687b      	ldr	r3, [r7, #4]
 801be32:	f503 7315 	add.w	r3, r3, #596	; 0x254
 801be36:	4806      	ldr	r0, [pc, #24]	; (801be50 <shell_handle_history+0x34>)
 801be38:	4611      	mov	r1, r2
 801be3a:	461a      	mov	r2, r3
 801be3c:	f7fb f968 	bl	8017110 <rt_kprintf>
    return RT_FALSE;
 801be40:	2300      	movs	r3, #0
}
 801be42:	4618      	mov	r0, r3
 801be44:	3708      	adds	r7, #8
 801be46:	46bd      	mov	sp, r7
 801be48:	bd80      	pop	{r7, pc}
 801be4a:	bf00      	nop
 801be4c:	08029be0 	.word	0x08029be0
 801be50:	08029bb0 	.word	0x08029bb0

0801be54 <shell_push_history>:

static void shell_push_history(struct finsh_shell *shell)
{
 801be54:	b580      	push	{r7, lr}
 801be56:	b084      	sub	sp, #16
 801be58:	af00      	add	r7, sp, #0
 801be5a:	6078      	str	r0, [r7, #4]
    if (shell->line_position != 0)
 801be5c:	687b      	ldr	r3, [r7, #4]
 801be5e:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801be62:	2b00      	cmp	r3, #0
 801be64:	d076      	beq.n	801bf54 <shell_push_history+0x100>
    {
        /* push history */
        if (shell->history_count >= FINSH_HISTORY_LINES)
 801be66:	687b      	ldr	r3, [r7, #4]
 801be68:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801be6a:	2b04      	cmp	r3, #4
 801be6c:	d946      	bls.n	801befc <shell_push_history+0xa8>
        {
            /* move history */
            int index;
            for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
 801be6e:	2300      	movs	r3, #0
 801be70:	60fb      	str	r3, [r7, #12]
 801be72:	e01a      	b.n	801beaa <shell_push_history+0x56>
            {
                memcpy(&shell->cmd_history[index][0],
 801be74:	68fa      	ldr	r2, [r7, #12]
 801be76:	4613      	mov	r3, r2
 801be78:	009b      	lsls	r3, r3, #2
 801be7a:	4413      	add	r3, r2
 801be7c:	011b      	lsls	r3, r3, #4
 801be7e:	3320      	adds	r3, #32
 801be80:	687a      	ldr	r2, [r7, #4]
 801be82:	4413      	add	r3, r2
 801be84:	1d99      	adds	r1, r3, #6
                       &shell->cmd_history[index + 1][0], FINSH_CMD_SIZE);
 801be86:	68fb      	ldr	r3, [r7, #12]
 801be88:	1c5a      	adds	r2, r3, #1
 801be8a:	4613      	mov	r3, r2
 801be8c:	009b      	lsls	r3, r3, #2
 801be8e:	4413      	add	r3, r2
 801be90:	011b      	lsls	r3, r3, #4
 801be92:	3320      	adds	r3, #32
 801be94:	687a      	ldr	r2, [r7, #4]
 801be96:	4413      	add	r3, r2
 801be98:	3306      	adds	r3, #6
        {
            /* move history */
            int index;
            for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
            {
                memcpy(&shell->cmd_history[index][0],
 801be9a:	4608      	mov	r0, r1
 801be9c:	4619      	mov	r1, r3
 801be9e:	2250      	movs	r2, #80	; 0x50
 801bea0:	f7e4 fa1e 	bl	80002e0 <memcpy>
        /* push history */
        if (shell->history_count >= FINSH_HISTORY_LINES)
        {
            /* move history */
            int index;
            for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
 801bea4:	68fb      	ldr	r3, [r7, #12]
 801bea6:	3301      	adds	r3, #1
 801bea8:	60fb      	str	r3, [r7, #12]
 801beaa:	68fb      	ldr	r3, [r7, #12]
 801beac:	2b03      	cmp	r3, #3
 801beae:	dde1      	ble.n	801be74 <shell_push_history+0x20>
            {
                memcpy(&shell->cmd_history[index][0],
                       &shell->cmd_history[index + 1][0], FINSH_CMD_SIZE);
            }
            memset(&shell->cmd_history[index][0], 0, FINSH_CMD_SIZE);
 801beb0:	68fa      	ldr	r2, [r7, #12]
 801beb2:	4613      	mov	r3, r2
 801beb4:	009b      	lsls	r3, r3, #2
 801beb6:	4413      	add	r3, r2
 801beb8:	011b      	lsls	r3, r3, #4
 801beba:	3320      	adds	r3, #32
 801bebc:	687a      	ldr	r2, [r7, #4]
 801bebe:	4413      	add	r3, r2
 801bec0:	3306      	adds	r3, #6
 801bec2:	4618      	mov	r0, r3
 801bec4:	2100      	movs	r1, #0
 801bec6:	2250      	movs	r2, #80	; 0x50
 801bec8:	f006 fbd8 	bl	802267c <memset>
            memcpy(&shell->cmd_history[index][0], shell->line, shell->line_position);
 801becc:	68fa      	ldr	r2, [r7, #12]
 801bece:	4613      	mov	r3, r2
 801bed0:	009b      	lsls	r3, r3, #2
 801bed2:	4413      	add	r3, r2
 801bed4:	011b      	lsls	r3, r3, #4
 801bed6:	3320      	adds	r3, #32
 801bed8:	687a      	ldr	r2, [r7, #4]
 801beda:	4413      	add	r3, r2
 801bedc:	1d99      	adds	r1, r3, #6
 801bede:	687b      	ldr	r3, [r7, #4]
 801bee0:	f503 7215 	add.w	r2, r3, #596	; 0x254
 801bee4:	687b      	ldr	r3, [r7, #4]
 801bee6:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801beea:	4608      	mov	r0, r1
 801beec:	4611      	mov	r1, r2
 801beee:	461a      	mov	r2, r3
 801bef0:	f7e4 f9f6 	bl	80002e0 <memcpy>

            /* it's the maximum history */
            shell->history_count = FINSH_HISTORY_LINES;
 801bef4:	687b      	ldr	r3, [r7, #4]
 801bef6:	2205      	movs	r2, #5
 801bef8:	849a      	strh	r2, [r3, #36]	; 0x24
 801befa:	e02b      	b.n	801bf54 <shell_push_history+0x100>
        }
        else
        {
            memset(&shell->cmd_history[shell->history_count][0], 0, FINSH_CMD_SIZE);
 801befc:	687b      	ldr	r3, [r7, #4]
 801befe:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801bf00:	461a      	mov	r2, r3
 801bf02:	4613      	mov	r3, r2
 801bf04:	009b      	lsls	r3, r3, #2
 801bf06:	4413      	add	r3, r2
 801bf08:	011b      	lsls	r3, r3, #4
 801bf0a:	3320      	adds	r3, #32
 801bf0c:	687a      	ldr	r2, [r7, #4]
 801bf0e:	4413      	add	r3, r2
 801bf10:	3306      	adds	r3, #6
 801bf12:	4618      	mov	r0, r3
 801bf14:	2100      	movs	r1, #0
 801bf16:	2250      	movs	r2, #80	; 0x50
 801bf18:	f006 fbb0 	bl	802267c <memset>
            memcpy(&shell->cmd_history[shell->history_count][0], shell->line, shell->line_position);
 801bf1c:	687b      	ldr	r3, [r7, #4]
 801bf1e:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801bf20:	461a      	mov	r2, r3
 801bf22:	4613      	mov	r3, r2
 801bf24:	009b      	lsls	r3, r3, #2
 801bf26:	4413      	add	r3, r2
 801bf28:	011b      	lsls	r3, r3, #4
 801bf2a:	3320      	adds	r3, #32
 801bf2c:	687a      	ldr	r2, [r7, #4]
 801bf2e:	4413      	add	r3, r2
 801bf30:	1d99      	adds	r1, r3, #6
 801bf32:	687b      	ldr	r3, [r7, #4]
 801bf34:	f503 7215 	add.w	r2, r3, #596	; 0x254
 801bf38:	687b      	ldr	r3, [r7, #4]
 801bf3a:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801bf3e:	4608      	mov	r0, r1
 801bf40:	4611      	mov	r1, r2
 801bf42:	461a      	mov	r2, r3
 801bf44:	f7e4 f9cc 	bl	80002e0 <memcpy>

            /* increase count and set current history position */
            shell->history_count ++;
 801bf48:	687b      	ldr	r3, [r7, #4]
 801bf4a:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801bf4c:	3301      	adds	r3, #1
 801bf4e:	b29a      	uxth	r2, r3
 801bf50:	687b      	ldr	r3, [r7, #4]
 801bf52:	849a      	strh	r2, [r3, #36]	; 0x24
        }
    }
    shell->current_history = shell->history_count;
 801bf54:	687b      	ldr	r3, [r7, #4]
 801bf56:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 801bf58:	687b      	ldr	r3, [r7, #4]
 801bf5a:	845a      	strh	r2, [r3, #34]	; 0x22
}
 801bf5c:	3710      	adds	r7, #16
 801bf5e:	46bd      	mov	sp, r7
 801bf60:	bd80      	pop	{r7, pc}
 801bf62:	bf00      	nop

0801bf64 <finsh_thread_entry>:

#ifndef RT_USING_HEAP
struct finsh_shell _shell;
#endif
void finsh_thread_entry(void *parameter)
{
 801bf64:	b5b0      	push	{r4, r5, r7, lr}
 801bf66:	b086      	sub	sp, #24
 801bf68:	af00      	add	r7, sp, #0
 801bf6a:	6078      	str	r0, [r7, #4]
    char ch;

    /* normal is echo mode */
    shell->echo_mode = 1;
 801bf6c:	4bae      	ldr	r3, [pc, #696]	; (801c228 <finsh_thread_entry+0x2c4>)
 801bf6e:	681a      	ldr	r2, [r3, #0]
 801bf70:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
 801bf74:	f043 0301 	orr.w	r3, r3, #1
 801bf78:	f882 3021 	strb.w	r3, [r2, #33]	; 0x21

#ifndef FINSH_USING_MSH_ONLY
    finsh_init(&shell->parser);
 801bf7c:	4baa      	ldr	r3, [pc, #680]	; (801c228 <finsh_thread_entry+0x2c4>)
 801bf7e:	681b      	ldr	r3, [r3, #0]
 801bf80:	f503 73dc 	add.w	r3, r3, #440	; 0x1b8
 801bf84:	4618      	mov	r0, r3
 801bf86:	f003 fbb9 	bl	801f6fc <finsh_init>
#endif
    rt_kprintf(FINSH_PROMPT);
 801bf8a:	f7ff fe77 	bl	801bc7c <finsh_get_prompt>
 801bf8e:	4603      	mov	r3, r0
 801bf90:	4618      	mov	r0, r3
 801bf92:	f7fb f8bd 	bl	8017110 <rt_kprintf>

    /* set console device as shell device */
    if (shell->device == RT_NULL)
 801bf96:	4ba4      	ldr	r3, [pc, #656]	; (801c228 <finsh_thread_entry+0x2c4>)
 801bf98:	681b      	ldr	r3, [r3, #0]
 801bf9a:	f8d3 32a8 	ldr.w	r3, [r3, #680]	; 0x2a8
 801bf9e:	2b00      	cmp	r3, #0
 801bfa0:	d123      	bne.n	801bfea <finsh_thread_entry+0x86>
    {
#ifdef RT_USING_CONSOLE
        shell->device = rt_console_get_device();
 801bfa2:	4ba1      	ldr	r3, [pc, #644]	; (801c228 <finsh_thread_entry+0x2c4>)
 801bfa4:	681c      	ldr	r4, [r3, #0]
 801bfa6:	f7fb f877 	bl	8017098 <rt_console_get_device>
 801bfaa:	4603      	mov	r3, r0
 801bfac:	f8c4 32a8 	str.w	r3, [r4, #680]	; 0x2a8
        RT_ASSERT(shell->device);
 801bfb0:	4b9d      	ldr	r3, [pc, #628]	; (801c228 <finsh_thread_entry+0x2c4>)
 801bfb2:	681b      	ldr	r3, [r3, #0]
 801bfb4:	f8d3 32a8 	ldr.w	r3, [r3, #680]	; 0x2a8
 801bfb8:	2b00      	cmp	r3, #0
 801bfba:	d105      	bne.n	801bfc8 <finsh_thread_entry+0x64>
 801bfbc:	489b      	ldr	r0, [pc, #620]	; (801c22c <finsh_thread_entry+0x2c8>)
 801bfbe:	499c      	ldr	r1, [pc, #624]	; (801c230 <finsh_thread_entry+0x2cc>)
 801bfc0:	f44f 729d 	mov.w	r2, #314	; 0x13a
 801bfc4:	f7fb f91e 	bl	8017204 <rt_assert_handler>
        rt_device_set_rx_indicate(shell->device, finsh_rx_ind);
 801bfc8:	4b97      	ldr	r3, [pc, #604]	; (801c228 <finsh_thread_entry+0x2c4>)
 801bfca:	681b      	ldr	r3, [r3, #0]
 801bfcc:	f8d3 32a8 	ldr.w	r3, [r3, #680]	; 0x2a8
 801bfd0:	4618      	mov	r0, r3
 801bfd2:	4998      	ldr	r1, [pc, #608]	; (801c234 <finsh_thread_entry+0x2d0>)
 801bfd4:	f7f9 fb8a 	bl	80156ec <rt_device_set_rx_indicate>
        rt_device_open(shell->device, (RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM | RT_DEVICE_FLAG_INT_RX));
 801bfd8:	4b93      	ldr	r3, [pc, #588]	; (801c228 <finsh_thread_entry+0x2c4>)
 801bfda:	681b      	ldr	r3, [r3, #0]
 801bfdc:	f8d3 32a8 	ldr.w	r3, [r3, #680]	; 0x2a8
 801bfe0:	4618      	mov	r0, r3
 801bfe2:	f240 1143 	movw	r1, #323	; 0x143
 801bfe6:	f7f9 fa41 	bl	801546c <rt_device_open>
    }

    while (1)
    {
        /* wait receive */
        if (rt_sem_take(&shell->rx_sem, RT_WAITING_FOREVER) != RT_EOK) continue;
 801bfea:	4b8f      	ldr	r3, [pc, #572]	; (801c228 <finsh_thread_entry+0x2c4>)
 801bfec:	681b      	ldr	r3, [r3, #0]
 801bfee:	4618      	mov	r0, r3
 801bff0:	f04f 31ff 	mov.w	r1, #4294967295
 801bff4:	f7f9 fd78 	bl	8015ae8 <rt_sem_take>
 801bff8:	4603      	mov	r3, r0
 801bffa:	2b00      	cmp	r3, #0
 801bffc:	d000      	beq.n	801c000 <finsh_thread_entry+0x9c>
 801bffe:	e2f4      	b.n	801c5ea <finsh_thread_entry+0x686>

        /* read one character from device */
        while (rt_device_read(shell->device, 0, &ch, 1) == 1)
 801c000:	e2e3      	b.n	801c5ca <finsh_thread_entry+0x666>
             * up key  : 0x1b 0x5b 0x41
             * down key: 0x1b 0x5b 0x42
             * right key:0x1b 0x5b 0x43
             * left key: 0x1b 0x5b 0x44
             */
            if (ch == 0x1b)
 801c002:	7afb      	ldrb	r3, [r7, #11]
 801c004:	2b1b      	cmp	r3, #27
 801c006:	d105      	bne.n	801c014 <finsh_thread_entry+0xb0>
            {
                shell->stat = WAIT_SPEC_KEY;
 801c008:	4b87      	ldr	r3, [pc, #540]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c00a:	681b      	ldr	r3, [r3, #0]
 801c00c:	2201      	movs	r2, #1
 801c00e:	f883 2020 	strb.w	r2, [r3, #32]
                continue;
 801c012:	e2da      	b.n	801c5ca <finsh_thread_entry+0x666>
            }
            else if (shell->stat == WAIT_SPEC_KEY)
 801c014:	4b84      	ldr	r3, [pc, #528]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c016:	681b      	ldr	r3, [r3, #0]
 801c018:	f893 3020 	ldrb.w	r3, [r3, #32]
 801c01c:	2b01      	cmp	r3, #1
 801c01e:	d10e      	bne.n	801c03e <finsh_thread_entry+0xda>
            {
                if (ch == 0x5b)
 801c020:	7afb      	ldrb	r3, [r7, #11]
 801c022:	2b5b      	cmp	r3, #91	; 0x5b
 801c024:	d105      	bne.n	801c032 <finsh_thread_entry+0xce>
                {
                    shell->stat = WAIT_FUNC_KEY;
 801c026:	4b80      	ldr	r3, [pc, #512]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c028:	681b      	ldr	r3, [r3, #0]
 801c02a:	2202      	movs	r2, #2
 801c02c:	f883 2020 	strb.w	r2, [r3, #32]
                    continue;
 801c030:	e2cb      	b.n	801c5ca <finsh_thread_entry+0x666>
                }

                shell->stat = WAIT_NORMAL;
 801c032:	4b7d      	ldr	r3, [pc, #500]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c034:	681b      	ldr	r3, [r3, #0]
 801c036:	2200      	movs	r2, #0
 801c038:	f883 2020 	strb.w	r2, [r3, #32]
 801c03c:	e0d5      	b.n	801c1ea <finsh_thread_entry+0x286>
            }
            else if (shell->stat == WAIT_FUNC_KEY)
 801c03e:	4b7a      	ldr	r3, [pc, #488]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c040:	681b      	ldr	r3, [r3, #0]
 801c042:	f893 3020 	ldrb.w	r3, [r3, #32]
 801c046:	2b02      	cmp	r3, #2
 801c048:	f040 80cf 	bne.w	801c1ea <finsh_thread_entry+0x286>
            {
                shell->stat = WAIT_NORMAL;
 801c04c:	4b76      	ldr	r3, [pc, #472]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c04e:	681b      	ldr	r3, [r3, #0]
 801c050:	2200      	movs	r2, #0
 801c052:	f883 2020 	strb.w	r2, [r3, #32]

                if (ch == 0x41) /* up key */
 801c056:	7afb      	ldrb	r3, [r7, #11]
 801c058:	2b41      	cmp	r3, #65	; 0x41
 801c05a:	d13d      	bne.n	801c0d8 <finsh_thread_entry+0x174>
                {
#ifdef FINSH_USING_HISTORY
                    /* prev history */
                    if (shell->current_history > 0)
 801c05c:	4b72      	ldr	r3, [pc, #456]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c05e:	681b      	ldr	r3, [r3, #0]
 801c060:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 801c062:	2b00      	cmp	r3, #0
 801c064:	d033      	beq.n	801c0ce <finsh_thread_entry+0x16a>
                        shell->current_history --;
 801c066:	4b70      	ldr	r3, [pc, #448]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c068:	681b      	ldr	r3, [r3, #0]
 801c06a:	8c5a      	ldrh	r2, [r3, #34]	; 0x22
 801c06c:	3a01      	subs	r2, #1
 801c06e:	b292      	uxth	r2, r2
 801c070:	845a      	strh	r2, [r3, #34]	; 0x22
                        shell->current_history = 0;
                        continue;
                    }

                    /* copy the history command */
                    memcpy(shell->line, &shell->cmd_history[shell->current_history][0],
 801c072:	4b6d      	ldr	r3, [pc, #436]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c074:	681b      	ldr	r3, [r3, #0]
 801c076:	f503 7015 	add.w	r0, r3, #596	; 0x254
 801c07a:	4b6b      	ldr	r3, [pc, #428]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c07c:	681a      	ldr	r2, [r3, #0]
 801c07e:	4b6a      	ldr	r3, [pc, #424]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c080:	681b      	ldr	r3, [r3, #0]
 801c082:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 801c084:	4619      	mov	r1, r3
 801c086:	460b      	mov	r3, r1
 801c088:	009b      	lsls	r3, r3, #2
 801c08a:	440b      	add	r3, r1
 801c08c:	011b      	lsls	r3, r3, #4
 801c08e:	3320      	adds	r3, #32
 801c090:	4413      	add	r3, r2
 801c092:	3306      	adds	r3, #6
 801c094:	4619      	mov	r1, r3
 801c096:	2250      	movs	r2, #80	; 0x50
 801c098:	f7e4 f922 	bl	80002e0 <memcpy>
                           FINSH_CMD_SIZE);
                    shell->line_curpos = shell->line_position = strlen(shell->line);
 801c09c:	4b62      	ldr	r3, [pc, #392]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c09e:	681d      	ldr	r5, [r3, #0]
 801c0a0:	4b61      	ldr	r3, [pc, #388]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c0a2:	681c      	ldr	r4, [r3, #0]
 801c0a4:	4b60      	ldr	r3, [pc, #384]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c0a6:	681b      	ldr	r3, [r3, #0]
 801c0a8:	f503 7315 	add.w	r3, r3, #596	; 0x254
 801c0ac:	4618      	mov	r0, r3
 801c0ae:	f006 ff77 	bl	8022fa0 <strlen>
 801c0b2:	4603      	mov	r3, r0
 801c0b4:	b2db      	uxtb	r3, r3
 801c0b6:	f884 32a4 	strb.w	r3, [r4, #676]	; 0x2a4
 801c0ba:	f894 32a4 	ldrb.w	r3, [r4, #676]	; 0x2a4
 801c0be:	f885 32a5 	strb.w	r3, [r5, #677]	; 0x2a5
                    shell_handle_history(shell);
 801c0c2:	4b59      	ldr	r3, [pc, #356]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c0c4:	681b      	ldr	r3, [r3, #0]
 801c0c6:	4618      	mov	r0, r3
 801c0c8:	f7ff fea8 	bl	801be1c <shell_handle_history>
#endif
                    continue;
 801c0cc:	e27d      	b.n	801c5ca <finsh_thread_entry+0x666>
                    /* prev history */
                    if (shell->current_history > 0)
                        shell->current_history --;
                    else
                    {
                        shell->current_history = 0;
 801c0ce:	4b56      	ldr	r3, [pc, #344]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c0d0:	681b      	ldr	r3, [r3, #0]
 801c0d2:	2200      	movs	r2, #0
 801c0d4:	845a      	strh	r2, [r3, #34]	; 0x22
                        continue;
 801c0d6:	e278      	b.n	801c5ca <finsh_thread_entry+0x666>
                    shell->line_curpos = shell->line_position = strlen(shell->line);
                    shell_handle_history(shell);
#endif
                    continue;
                }
                else if (ch == 0x42) /* down key */
 801c0d8:	7afb      	ldrb	r3, [r7, #11]
 801c0da:	2b42      	cmp	r3, #66	; 0x42
 801c0dc:	d14d      	bne.n	801c17a <finsh_thread_entry+0x216>
                {
#ifdef FINSH_USING_HISTORY
                    /* next history */
                    if (shell->current_history < shell->history_count - 1)
 801c0de:	4b52      	ldr	r3, [pc, #328]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c0e0:	681b      	ldr	r3, [r3, #0]
 801c0e2:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 801c0e4:	461a      	mov	r2, r3
 801c0e6:	4b50      	ldr	r3, [pc, #320]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c0e8:	681b      	ldr	r3, [r3, #0]
 801c0ea:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801c0ec:	3b01      	subs	r3, #1
 801c0ee:	429a      	cmp	r2, r3
 801c0f0:	da06      	bge.n	801c100 <finsh_thread_entry+0x19c>
                        shell->current_history ++;
 801c0f2:	4b4d      	ldr	r3, [pc, #308]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c0f4:	681b      	ldr	r3, [r3, #0]
 801c0f6:	8c5a      	ldrh	r2, [r3, #34]	; 0x22
 801c0f8:	3201      	adds	r2, #1
 801c0fa:	b292      	uxth	r2, r2
 801c0fc:	845a      	strh	r2, [r3, #34]	; 0x22
 801c0fe:	e00e      	b.n	801c11e <finsh_thread_entry+0x1ba>
                    else
                    {
                        /* set to the end of history */
                        if (shell->history_count != 0)
 801c100:	4b49      	ldr	r3, [pc, #292]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c102:	681b      	ldr	r3, [r3, #0]
 801c104:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801c106:	2b00      	cmp	r3, #0
 801c108:	d008      	beq.n	801c11c <finsh_thread_entry+0x1b8>
                            shell->current_history = shell->history_count - 1;
 801c10a:	4b47      	ldr	r3, [pc, #284]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c10c:	681b      	ldr	r3, [r3, #0]
 801c10e:	4a46      	ldr	r2, [pc, #280]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c110:	6812      	ldr	r2, [r2, #0]
 801c112:	8c92      	ldrh	r2, [r2, #36]	; 0x24
 801c114:	3a01      	subs	r2, #1
 801c116:	b292      	uxth	r2, r2
 801c118:	845a      	strh	r2, [r3, #34]	; 0x22
 801c11a:	e000      	b.n	801c11e <finsh_thread_entry+0x1ba>
                        else
                            continue;
 801c11c:	e255      	b.n	801c5ca <finsh_thread_entry+0x666>
                    }

                    memcpy(shell->line, &shell->cmd_history[shell->current_history][0],
 801c11e:	4b42      	ldr	r3, [pc, #264]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c120:	681b      	ldr	r3, [r3, #0]
 801c122:	f503 7015 	add.w	r0, r3, #596	; 0x254
 801c126:	4b40      	ldr	r3, [pc, #256]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c128:	681a      	ldr	r2, [r3, #0]
 801c12a:	4b3f      	ldr	r3, [pc, #252]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c12c:	681b      	ldr	r3, [r3, #0]
 801c12e:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 801c130:	4619      	mov	r1, r3
 801c132:	460b      	mov	r3, r1
 801c134:	009b      	lsls	r3, r3, #2
 801c136:	440b      	add	r3, r1
 801c138:	011b      	lsls	r3, r3, #4
 801c13a:	3320      	adds	r3, #32
 801c13c:	4413      	add	r3, r2
 801c13e:	3306      	adds	r3, #6
 801c140:	4619      	mov	r1, r3
 801c142:	2250      	movs	r2, #80	; 0x50
 801c144:	f7e4 f8cc 	bl	80002e0 <memcpy>
                           FINSH_CMD_SIZE);
                    shell->line_curpos = shell->line_position = strlen(shell->line);
 801c148:	4b37      	ldr	r3, [pc, #220]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c14a:	681d      	ldr	r5, [r3, #0]
 801c14c:	4b36      	ldr	r3, [pc, #216]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c14e:	681c      	ldr	r4, [r3, #0]
 801c150:	4b35      	ldr	r3, [pc, #212]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c152:	681b      	ldr	r3, [r3, #0]
 801c154:	f503 7315 	add.w	r3, r3, #596	; 0x254
 801c158:	4618      	mov	r0, r3
 801c15a:	f006 ff21 	bl	8022fa0 <strlen>
 801c15e:	4603      	mov	r3, r0
 801c160:	b2db      	uxtb	r3, r3
 801c162:	f884 32a4 	strb.w	r3, [r4, #676]	; 0x2a4
 801c166:	f894 32a4 	ldrb.w	r3, [r4, #676]	; 0x2a4
 801c16a:	f885 32a5 	strb.w	r3, [r5, #677]	; 0x2a5
                    shell_handle_history(shell);
 801c16e:	4b2e      	ldr	r3, [pc, #184]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c170:	681b      	ldr	r3, [r3, #0]
 801c172:	4618      	mov	r0, r3
 801c174:	f7ff fe52 	bl	801be1c <shell_handle_history>
#endif
                    continue;
 801c178:	e227      	b.n	801c5ca <finsh_thread_entry+0x666>
                }
                else if (ch == 0x44) /* left key */
 801c17a:	7afb      	ldrb	r3, [r7, #11]
 801c17c:	2b44      	cmp	r3, #68	; 0x44
 801c17e:	d111      	bne.n	801c1a4 <finsh_thread_entry+0x240>
                {
                    if (shell->line_curpos)
 801c180:	4b29      	ldr	r3, [pc, #164]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c182:	681b      	ldr	r3, [r3, #0]
 801c184:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801c188:	2b00      	cmp	r3, #0
 801c18a:	d00a      	beq.n	801c1a2 <finsh_thread_entry+0x23e>
                    {
                        rt_kprintf("\b");
 801c18c:	482a      	ldr	r0, [pc, #168]	; (801c238 <finsh_thread_entry+0x2d4>)
 801c18e:	f7fa ffbf 	bl	8017110 <rt_kprintf>
                        shell->line_curpos --;
 801c192:	4b25      	ldr	r3, [pc, #148]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c194:	681b      	ldr	r3, [r3, #0]
 801c196:	f893 22a5 	ldrb.w	r2, [r3, #677]	; 0x2a5
 801c19a:	3a01      	subs	r2, #1
 801c19c:	b2d2      	uxtb	r2, r2
 801c19e:	f883 22a5 	strb.w	r2, [r3, #677]	; 0x2a5
                    }

                    continue;
 801c1a2:	e212      	b.n	801c5ca <finsh_thread_entry+0x666>
                }
                else if (ch == 0x43) /* right key */
 801c1a4:	7afb      	ldrb	r3, [r7, #11]
 801c1a6:	2b43      	cmp	r3, #67	; 0x43
 801c1a8:	d11f      	bne.n	801c1ea <finsh_thread_entry+0x286>
                {
                    if (shell->line_curpos < shell->line_position)
 801c1aa:	4b1f      	ldr	r3, [pc, #124]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c1ac:	681b      	ldr	r3, [r3, #0]
 801c1ae:	f893 22a5 	ldrb.w	r2, [r3, #677]	; 0x2a5
 801c1b2:	4b1d      	ldr	r3, [pc, #116]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c1b4:	681b      	ldr	r3, [r3, #0]
 801c1b6:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801c1ba:	429a      	cmp	r2, r3
 801c1bc:	d214      	bcs.n	801c1e8 <finsh_thread_entry+0x284>
                    {
                        rt_kprintf("%c", shell->line[shell->line_curpos]);
 801c1be:	4b1a      	ldr	r3, [pc, #104]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c1c0:	681b      	ldr	r3, [r3, #0]
 801c1c2:	4a19      	ldr	r2, [pc, #100]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c1c4:	6812      	ldr	r2, [r2, #0]
 801c1c6:	f892 22a5 	ldrb.w	r2, [r2, #677]	; 0x2a5
 801c1ca:	4413      	add	r3, r2
 801c1cc:	f893 3254 	ldrb.w	r3, [r3, #596]	; 0x254
 801c1d0:	481a      	ldr	r0, [pc, #104]	; (801c23c <finsh_thread_entry+0x2d8>)
 801c1d2:	4619      	mov	r1, r3
 801c1d4:	f7fa ff9c 	bl	8017110 <rt_kprintf>
                        shell->line_curpos ++;
 801c1d8:	4b13      	ldr	r3, [pc, #76]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c1da:	681b      	ldr	r3, [r3, #0]
 801c1dc:	f893 22a5 	ldrb.w	r2, [r3, #677]	; 0x2a5
 801c1e0:	3201      	adds	r2, #1
 801c1e2:	b2d2      	uxtb	r2, r2
 801c1e4:	f883 22a5 	strb.w	r2, [r3, #677]	; 0x2a5
                    }

                    continue;
 801c1e8:	e1ef      	b.n	801c5ca <finsh_thread_entry+0x666>
                }

            }

            /* handle CR key */
            if (ch == '\r')
 801c1ea:	7afb      	ldrb	r3, [r7, #11]
 801c1ec:	2b0d      	cmp	r3, #13
 801c1ee:	d127      	bne.n	801c240 <finsh_thread_entry+0x2dc>
            {
                char next;

                if (rt_device_read(shell->device, 0, &next, 1) == 1)
 801c1f0:	4b0d      	ldr	r3, [pc, #52]	; (801c228 <finsh_thread_entry+0x2c4>)
 801c1f2:	681b      	ldr	r3, [r3, #0]
 801c1f4:	f8d3 22a8 	ldr.w	r2, [r3, #680]	; 0x2a8
 801c1f8:	f107 030a 	add.w	r3, r7, #10
 801c1fc:	4610      	mov	r0, r2
 801c1fe:	2100      	movs	r1, #0
 801c200:	461a      	mov	r2, r3
 801c202:	2301      	movs	r3, #1
 801c204:	f7f9 f9e4 	bl	80155d0 <rt_device_read>
 801c208:	4603      	mov	r3, r0
 801c20a:	2b01      	cmp	r3, #1
 801c20c:	d108      	bne.n	801c220 <finsh_thread_entry+0x2bc>
                {
                    if (next == '\0') ch = 'r'; /* linux telnet will issue '\0' */
 801c20e:	7abb      	ldrb	r3, [r7, #10]
 801c210:	2b00      	cmp	r3, #0
 801c212:	d102      	bne.n	801c21a <finsh_thread_entry+0x2b6>
 801c214:	2372      	movs	r3, #114	; 0x72
 801c216:	72fb      	strb	r3, [r7, #11]
 801c218:	e0c7      	b.n	801c3aa <finsh_thread_entry+0x446>
                    else ch = next;
 801c21a:	7abb      	ldrb	r3, [r7, #10]
 801c21c:	72fb      	strb	r3, [r7, #11]
 801c21e:	e0c4      	b.n	801c3aa <finsh_thread_entry+0x446>
                }
                else ch = '\r';
 801c220:	230d      	movs	r3, #13
 801c222:	72fb      	strb	r3, [r7, #11]
 801c224:	e0c1      	b.n	801c3aa <finsh_thread_entry+0x446>
 801c226:	bf00      	nop
 801c228:	20012bd8 	.word	0x20012bd8
 801c22c:	08029be8 	.word	0x08029be8
 801c230:	0802af1c 	.word	0x0802af1c
 801c234:	0801bcdd 	.word	0x0801bcdd
 801c238:	08029bf8 	.word	0x08029bf8
 801c23c:	08029bfc 	.word	0x08029bfc
            }
            /* handle tab key */
            else if (ch == '\t')
 801c240:	7afb      	ldrb	r3, [r7, #11]
 801c242:	2b09      	cmp	r3, #9
 801c244:	d12b      	bne.n	801c29e <finsh_thread_entry+0x33a>
            {
                int i;
                /* move the cursor to the beginning of line */
                for (i = 0; i < shell->line_curpos; i++)
 801c246:	2300      	movs	r3, #0
 801c248:	617b      	str	r3, [r7, #20]
 801c24a:	e005      	b.n	801c258 <finsh_thread_entry+0x2f4>
                    rt_kprintf("\b");
 801c24c:	4884      	ldr	r0, [pc, #528]	; (801c460 <finsh_thread_entry+0x4fc>)
 801c24e:	f7fa ff5f 	bl	8017110 <rt_kprintf>
            /* handle tab key */
            else if (ch == '\t')
            {
                int i;
                /* move the cursor to the beginning of line */
                for (i = 0; i < shell->line_curpos; i++)
 801c252:	697b      	ldr	r3, [r7, #20]
 801c254:	3301      	adds	r3, #1
 801c256:	617b      	str	r3, [r7, #20]
 801c258:	4b82      	ldr	r3, [pc, #520]	; (801c464 <finsh_thread_entry+0x500>)
 801c25a:	681b      	ldr	r3, [r3, #0]
 801c25c:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801c260:	461a      	mov	r2, r3
 801c262:	697b      	ldr	r3, [r7, #20]
 801c264:	429a      	cmp	r2, r3
 801c266:	dcf1      	bgt.n	801c24c <finsh_thread_entry+0x2e8>
                    rt_kprintf("\b");

                /* auto complete */
                shell_auto_complete(&shell->line[0]);
 801c268:	4b7e      	ldr	r3, [pc, #504]	; (801c464 <finsh_thread_entry+0x500>)
 801c26a:	681b      	ldr	r3, [r3, #0]
 801c26c:	f503 7315 	add.w	r3, r3, #596	; 0x254
 801c270:	4618      	mov	r0, r3
 801c272:	f7ff fd51 	bl	801bd18 <shell_auto_complete>
                /* re-calculate position */
                shell->line_curpos = shell->line_position = strlen(shell->line);
 801c276:	4b7b      	ldr	r3, [pc, #492]	; (801c464 <finsh_thread_entry+0x500>)
 801c278:	681d      	ldr	r5, [r3, #0]
 801c27a:	4b7a      	ldr	r3, [pc, #488]	; (801c464 <finsh_thread_entry+0x500>)
 801c27c:	681c      	ldr	r4, [r3, #0]
 801c27e:	4b79      	ldr	r3, [pc, #484]	; (801c464 <finsh_thread_entry+0x500>)
 801c280:	681b      	ldr	r3, [r3, #0]
 801c282:	f503 7315 	add.w	r3, r3, #596	; 0x254
 801c286:	4618      	mov	r0, r3
 801c288:	f006 fe8a 	bl	8022fa0 <strlen>
 801c28c:	4603      	mov	r3, r0
 801c28e:	b2db      	uxtb	r3, r3
 801c290:	f884 32a4 	strb.w	r3, [r4, #676]	; 0x2a4
 801c294:	f894 32a4 	ldrb.w	r3, [r4, #676]	; 0x2a4
 801c298:	f885 32a5 	strb.w	r3, [r5, #677]	; 0x2a5

                continue;
 801c29c:	e195      	b.n	801c5ca <finsh_thread_entry+0x666>
            }
            /* handle backspace key */
            else if (ch == 0x7f || ch == 0x08)
 801c29e:	7afb      	ldrb	r3, [r7, #11]
 801c2a0:	2b7f      	cmp	r3, #127	; 0x7f
 801c2a2:	d002      	beq.n	801c2aa <finsh_thread_entry+0x346>
 801c2a4:	7afb      	ldrb	r3, [r7, #11]
 801c2a6:	2b08      	cmp	r3, #8
 801c2a8:	d17f      	bne.n	801c3aa <finsh_thread_entry+0x446>
            {
                /* note that shell->line_curpos >= 0 */
                if (shell->line_curpos == 0)
 801c2aa:	4b6e      	ldr	r3, [pc, #440]	; (801c464 <finsh_thread_entry+0x500>)
 801c2ac:	681b      	ldr	r3, [r3, #0]
 801c2ae:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801c2b2:	2b00      	cmp	r3, #0
 801c2b4:	d100      	bne.n	801c2b8 <finsh_thread_entry+0x354>
                    continue;
 801c2b6:	e188      	b.n	801c5ca <finsh_thread_entry+0x666>

                shell->line_position--;
 801c2b8:	4b6a      	ldr	r3, [pc, #424]	; (801c464 <finsh_thread_entry+0x500>)
 801c2ba:	681b      	ldr	r3, [r3, #0]
 801c2bc:	f893 22a4 	ldrb.w	r2, [r3, #676]	; 0x2a4
 801c2c0:	3a01      	subs	r2, #1
 801c2c2:	b2d2      	uxtb	r2, r2
 801c2c4:	f883 22a4 	strb.w	r2, [r3, #676]	; 0x2a4
                shell->line_curpos--;
 801c2c8:	4b66      	ldr	r3, [pc, #408]	; (801c464 <finsh_thread_entry+0x500>)
 801c2ca:	681b      	ldr	r3, [r3, #0]
 801c2cc:	f893 22a5 	ldrb.w	r2, [r3, #677]	; 0x2a5
 801c2d0:	3a01      	subs	r2, #1
 801c2d2:	b2d2      	uxtb	r2, r2
 801c2d4:	f883 22a5 	strb.w	r2, [r3, #677]	; 0x2a5

                if (shell->line_position > shell->line_curpos)
 801c2d8:	4b62      	ldr	r3, [pc, #392]	; (801c464 <finsh_thread_entry+0x500>)
 801c2da:	681b      	ldr	r3, [r3, #0]
 801c2dc:	f893 22a4 	ldrb.w	r2, [r3, #676]	; 0x2a4
 801c2e0:	4b60      	ldr	r3, [pc, #384]	; (801c464 <finsh_thread_entry+0x500>)
 801c2e2:	681b      	ldr	r3, [r3, #0]
 801c2e4:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801c2e8:	429a      	cmp	r2, r3
 801c2ea:	d950      	bls.n	801c38e <finsh_thread_entry+0x42a>
                {
                    int i;

                    rt_memmove(&shell->line[shell->line_curpos],
 801c2ec:	4b5d      	ldr	r3, [pc, #372]	; (801c464 <finsh_thread_entry+0x500>)
 801c2ee:	681a      	ldr	r2, [r3, #0]
 801c2f0:	4b5c      	ldr	r3, [pc, #368]	; (801c464 <finsh_thread_entry+0x500>)
 801c2f2:	681b      	ldr	r3, [r3, #0]
 801c2f4:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801c2f8:	f503 7314 	add.w	r3, r3, #592	; 0x250
 801c2fc:	4413      	add	r3, r2
 801c2fe:	1d19      	adds	r1, r3, #4
                               &shell->line[shell->line_curpos + 1],
 801c300:	4b58      	ldr	r3, [pc, #352]	; (801c464 <finsh_thread_entry+0x500>)
 801c302:	681a      	ldr	r2, [r3, #0]
 801c304:	4b57      	ldr	r3, [pc, #348]	; (801c464 <finsh_thread_entry+0x500>)
 801c306:	681b      	ldr	r3, [r3, #0]
 801c308:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801c30c:	3301      	adds	r3, #1
 801c30e:	f503 7314 	add.w	r3, r3, #592	; 0x250
 801c312:	4413      	add	r3, r2
 801c314:	1d1a      	adds	r2, r3, #4
                               shell->line_position - shell->line_curpos);
 801c316:	4b53      	ldr	r3, [pc, #332]	; (801c464 <finsh_thread_entry+0x500>)
 801c318:	681b      	ldr	r3, [r3, #0]
 801c31a:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801c31e:	4618      	mov	r0, r3
 801c320:	4b50      	ldr	r3, [pc, #320]	; (801c464 <finsh_thread_entry+0x500>)
 801c322:	681b      	ldr	r3, [r3, #0]
 801c324:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801c328:	1ac3      	subs	r3, r0, r3

                if (shell->line_position > shell->line_curpos)
                {
                    int i;

                    rt_memmove(&shell->line[shell->line_curpos],
 801c32a:	4608      	mov	r0, r1
 801c32c:	4611      	mov	r1, r2
 801c32e:	461a      	mov	r2, r3
 801c330:	f7fa f9fc 	bl	801672c <rt_memmove>
                               &shell->line[shell->line_curpos + 1],
                               shell->line_position - shell->line_curpos);
                    shell->line[shell->line_position] = 0;
 801c334:	4b4b      	ldr	r3, [pc, #300]	; (801c464 <finsh_thread_entry+0x500>)
 801c336:	681b      	ldr	r3, [r3, #0]
 801c338:	4a4a      	ldr	r2, [pc, #296]	; (801c464 <finsh_thread_entry+0x500>)
 801c33a:	6812      	ldr	r2, [r2, #0]
 801c33c:	f892 22a4 	ldrb.w	r2, [r2, #676]	; 0x2a4
 801c340:	4413      	add	r3, r2
 801c342:	2200      	movs	r2, #0
 801c344:	f883 2254 	strb.w	r2, [r3, #596]	; 0x254

                    rt_kprintf("\b%s  \b", &shell->line[shell->line_curpos]);
 801c348:	4b46      	ldr	r3, [pc, #280]	; (801c464 <finsh_thread_entry+0x500>)
 801c34a:	681a      	ldr	r2, [r3, #0]
 801c34c:	4b45      	ldr	r3, [pc, #276]	; (801c464 <finsh_thread_entry+0x500>)
 801c34e:	681b      	ldr	r3, [r3, #0]
 801c350:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801c354:	f503 7314 	add.w	r3, r3, #592	; 0x250
 801c358:	4413      	add	r3, r2
 801c35a:	3304      	adds	r3, #4
 801c35c:	4842      	ldr	r0, [pc, #264]	; (801c468 <finsh_thread_entry+0x504>)
 801c35e:	4619      	mov	r1, r3
 801c360:	f7fa fed6 	bl	8017110 <rt_kprintf>

                    /* move the cursor to the origin position */
                    for (i = shell->line_curpos; i <= shell->line_position; i++)
 801c364:	4b3f      	ldr	r3, [pc, #252]	; (801c464 <finsh_thread_entry+0x500>)
 801c366:	681b      	ldr	r3, [r3, #0]
 801c368:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801c36c:	613b      	str	r3, [r7, #16]
 801c36e:	e005      	b.n	801c37c <finsh_thread_entry+0x418>
                        rt_kprintf("\b");
 801c370:	483b      	ldr	r0, [pc, #236]	; (801c460 <finsh_thread_entry+0x4fc>)
 801c372:	f7fa fecd 	bl	8017110 <rt_kprintf>
                    shell->line[shell->line_position] = 0;

                    rt_kprintf("\b%s  \b", &shell->line[shell->line_curpos]);

                    /* move the cursor to the origin position */
                    for (i = shell->line_curpos; i <= shell->line_position; i++)
 801c376:	693b      	ldr	r3, [r7, #16]
 801c378:	3301      	adds	r3, #1
 801c37a:	613b      	str	r3, [r7, #16]
 801c37c:	4b39      	ldr	r3, [pc, #228]	; (801c464 <finsh_thread_entry+0x500>)
 801c37e:	681b      	ldr	r3, [r3, #0]
 801c380:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801c384:	461a      	mov	r2, r3
 801c386:	693b      	ldr	r3, [r7, #16]
 801c388:	429a      	cmp	r2, r3
 801c38a:	daf1      	bge.n	801c370 <finsh_thread_entry+0x40c>
 801c38c:	e00c      	b.n	801c3a8 <finsh_thread_entry+0x444>
                        rt_kprintf("\b");
                }
                else
                {
                    rt_kprintf("\b \b");
 801c38e:	4837      	ldr	r0, [pc, #220]	; (801c46c <finsh_thread_entry+0x508>)
 801c390:	f7fa febe 	bl	8017110 <rt_kprintf>
                    shell->line[shell->line_position] = 0;
 801c394:	4b33      	ldr	r3, [pc, #204]	; (801c464 <finsh_thread_entry+0x500>)
 801c396:	681b      	ldr	r3, [r3, #0]
 801c398:	4a32      	ldr	r2, [pc, #200]	; (801c464 <finsh_thread_entry+0x500>)
 801c39a:	6812      	ldr	r2, [r2, #0]
 801c39c:	f892 22a4 	ldrb.w	r2, [r2, #676]	; 0x2a4
 801c3a0:	4413      	add	r3, r2
 801c3a2:	2200      	movs	r2, #0
 801c3a4:	f883 2254 	strb.w	r2, [r3, #596]	; 0x254
                }

                continue;
 801c3a8:	e10f      	b.n	801c5ca <finsh_thread_entry+0x666>
            }

            /* handle end of line, break */
            if (ch == '\r' || ch == '\n')
 801c3aa:	7afb      	ldrb	r3, [r7, #11]
 801c3ac:	2b0d      	cmp	r3, #13
 801c3ae:	d002      	beq.n	801c3b6 <finsh_thread_entry+0x452>
 801c3b0:	7afb      	ldrb	r3, [r7, #11]
 801c3b2:	2b0a      	cmp	r3, #10
 801c3b4:	d15e      	bne.n	801c474 <finsh_thread_entry+0x510>
            {
#ifdef FINSH_USING_HISTORY
                shell_push_history(shell);
 801c3b6:	4b2b      	ldr	r3, [pc, #172]	; (801c464 <finsh_thread_entry+0x500>)
 801c3b8:	681b      	ldr	r3, [r3, #0]
 801c3ba:	4618      	mov	r0, r3
 801c3bc:	f7ff fd4a 	bl	801be54 <shell_push_history>
#endif

#ifdef FINSH_USING_MSH
                if (msh_is_used() == RT_TRUE)
 801c3c0:	f000 ffd8 	bl	801d374 <msh_is_used>
 801c3c4:	4603      	mov	r3, r0
 801c3c6:	2b01      	cmp	r3, #1
 801c3c8:	d10f      	bne.n	801c3ea <finsh_thread_entry+0x486>
                {
                    rt_kprintf("\n");
 801c3ca:	4829      	ldr	r0, [pc, #164]	; (801c470 <finsh_thread_entry+0x50c>)
 801c3cc:	f7fa fea0 	bl	8017110 <rt_kprintf>
                    msh_exec(shell->line, shell->line_position);
 801c3d0:	4b24      	ldr	r3, [pc, #144]	; (801c464 <finsh_thread_entry+0x500>)
 801c3d2:	681b      	ldr	r3, [r3, #0]
 801c3d4:	f503 7215 	add.w	r2, r3, #596	; 0x254
 801c3d8:	4b22      	ldr	r3, [pc, #136]	; (801c464 <finsh_thread_entry+0x500>)
 801c3da:	681b      	ldr	r3, [r3, #0]
 801c3dc:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801c3e0:	4610      	mov	r0, r2
 801c3e2:	4619      	mov	r1, r3
 801c3e4:	f001 f970 	bl	801d6c8 <msh_exec>
 801c3e8:	e01f      	b.n	801c42a <finsh_thread_entry+0x4c6>
                else
#endif
                {
#ifndef FINSH_USING_MSH_ONLY
                    /* add ';' and run the command line */
                    shell->line[shell->line_position] = ';';
 801c3ea:	4b1e      	ldr	r3, [pc, #120]	; (801c464 <finsh_thread_entry+0x500>)
 801c3ec:	681b      	ldr	r3, [r3, #0]
 801c3ee:	4a1d      	ldr	r2, [pc, #116]	; (801c464 <finsh_thread_entry+0x500>)
 801c3f0:	6812      	ldr	r2, [r2, #0]
 801c3f2:	f892 22a4 	ldrb.w	r2, [r2, #676]	; 0x2a4
 801c3f6:	4413      	add	r3, r2
 801c3f8:	223b      	movs	r2, #59	; 0x3b
 801c3fa:	f883 2254 	strb.w	r2, [r3, #596]	; 0x254

                    if (shell->line_position != 0) finsh_run_line(&shell->parser, shell->line);
 801c3fe:	4b19      	ldr	r3, [pc, #100]	; (801c464 <finsh_thread_entry+0x500>)
 801c400:	681b      	ldr	r3, [r3, #0]
 801c402:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801c406:	2b00      	cmp	r3, #0
 801c408:	d00c      	beq.n	801c424 <finsh_thread_entry+0x4c0>
 801c40a:	4b16      	ldr	r3, [pc, #88]	; (801c464 <finsh_thread_entry+0x500>)
 801c40c:	681b      	ldr	r3, [r3, #0]
 801c40e:	f503 72dc 	add.w	r2, r3, #440	; 0x1b8
 801c412:	4b14      	ldr	r3, [pc, #80]	; (801c464 <finsh_thread_entry+0x500>)
 801c414:	681b      	ldr	r3, [r3, #0]
 801c416:	f503 7315 	add.w	r3, r3, #596	; 0x254
 801c41a:	4610      	mov	r0, r2
 801c41c:	4619      	mov	r1, r3
 801c41e:	f7ff fc9d 	bl	801bd5c <finsh_run_line>
 801c422:	e002      	b.n	801c42a <finsh_thread_entry+0x4c6>
                    else rt_kprintf("\n");
 801c424:	4812      	ldr	r0, [pc, #72]	; (801c470 <finsh_thread_entry+0x50c>)
 801c426:	f7fa fe73 	bl	8017110 <rt_kprintf>
#endif
                }

                rt_kprintf(FINSH_PROMPT);
 801c42a:	f7ff fc27 	bl	801bc7c <finsh_get_prompt>
 801c42e:	4603      	mov	r3, r0
 801c430:	4618      	mov	r0, r3
 801c432:	f7fa fe6d 	bl	8017110 <rt_kprintf>
                memset(shell->line, 0, sizeof(shell->line));
 801c436:	4b0b      	ldr	r3, [pc, #44]	; (801c464 <finsh_thread_entry+0x500>)
 801c438:	681b      	ldr	r3, [r3, #0]
 801c43a:	f503 7315 	add.w	r3, r3, #596	; 0x254
 801c43e:	4618      	mov	r0, r3
 801c440:	2100      	movs	r1, #0
 801c442:	2250      	movs	r2, #80	; 0x50
 801c444:	f006 f91a 	bl	802267c <memset>
                shell->line_curpos = shell->line_position = 0;
 801c448:	4b06      	ldr	r3, [pc, #24]	; (801c464 <finsh_thread_entry+0x500>)
 801c44a:	681a      	ldr	r2, [r3, #0]
 801c44c:	4b05      	ldr	r3, [pc, #20]	; (801c464 <finsh_thread_entry+0x500>)
 801c44e:	681b      	ldr	r3, [r3, #0]
 801c450:	2100      	movs	r1, #0
 801c452:	f883 12a4 	strb.w	r1, [r3, #676]	; 0x2a4
 801c456:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801c45a:	f882 32a5 	strb.w	r3, [r2, #677]	; 0x2a5
                break;
 801c45e:	e0c4      	b.n	801c5ea <finsh_thread_entry+0x686>
 801c460:	08029bf8 	.word	0x08029bf8
 801c464:	20012bd8 	.word	0x20012bd8
 801c468:	08029c00 	.word	0x08029c00
 801c46c:	08029c08 	.word	0x08029c08
 801c470:	08029bac 	.word	0x08029bac
            }

            /* it's a large line, discard it */
            if (shell->line_position >= FINSH_CMD_SIZE)
 801c474:	4b5d      	ldr	r3, [pc, #372]	; (801c5ec <finsh_thread_entry+0x688>)
 801c476:	681b      	ldr	r3, [r3, #0]
 801c478:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801c47c:	2b4f      	cmp	r3, #79	; 0x4f
 801c47e:	d904      	bls.n	801c48a <finsh_thread_entry+0x526>
                shell->line_position = 0;
 801c480:	4b5a      	ldr	r3, [pc, #360]	; (801c5ec <finsh_thread_entry+0x688>)
 801c482:	681b      	ldr	r3, [r3, #0]
 801c484:	2200      	movs	r2, #0
 801c486:	f883 22a4 	strb.w	r2, [r3, #676]	; 0x2a4

            /* normal character */
            if (shell->line_curpos < shell->line_position)
 801c48a:	4b58      	ldr	r3, [pc, #352]	; (801c5ec <finsh_thread_entry+0x688>)
 801c48c:	681b      	ldr	r3, [r3, #0]
 801c48e:	f893 22a5 	ldrb.w	r2, [r3, #677]	; 0x2a5
 801c492:	4b56      	ldr	r3, [pc, #344]	; (801c5ec <finsh_thread_entry+0x688>)
 801c494:	681b      	ldr	r3, [r3, #0]
 801c496:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801c49a:	429a      	cmp	r2, r3
 801c49c:	d25a      	bcs.n	801c554 <finsh_thread_entry+0x5f0>
            {
                int i;

                rt_memmove(&shell->line[shell->line_curpos + 1],
 801c49e:	4b53      	ldr	r3, [pc, #332]	; (801c5ec <finsh_thread_entry+0x688>)
 801c4a0:	681a      	ldr	r2, [r3, #0]
 801c4a2:	4b52      	ldr	r3, [pc, #328]	; (801c5ec <finsh_thread_entry+0x688>)
 801c4a4:	681b      	ldr	r3, [r3, #0]
 801c4a6:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801c4aa:	3301      	adds	r3, #1
 801c4ac:	f503 7314 	add.w	r3, r3, #592	; 0x250
 801c4b0:	4413      	add	r3, r2
 801c4b2:	1d19      	adds	r1, r3, #4
                           &shell->line[shell->line_curpos],
 801c4b4:	4b4d      	ldr	r3, [pc, #308]	; (801c5ec <finsh_thread_entry+0x688>)
 801c4b6:	681a      	ldr	r2, [r3, #0]
 801c4b8:	4b4c      	ldr	r3, [pc, #304]	; (801c5ec <finsh_thread_entry+0x688>)
 801c4ba:	681b      	ldr	r3, [r3, #0]
 801c4bc:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801c4c0:	f503 7314 	add.w	r3, r3, #592	; 0x250
 801c4c4:	4413      	add	r3, r2
 801c4c6:	1d1a      	adds	r2, r3, #4
                           shell->line_position - shell->line_curpos);
 801c4c8:	4b48      	ldr	r3, [pc, #288]	; (801c5ec <finsh_thread_entry+0x688>)
 801c4ca:	681b      	ldr	r3, [r3, #0]
 801c4cc:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801c4d0:	4618      	mov	r0, r3
 801c4d2:	4b46      	ldr	r3, [pc, #280]	; (801c5ec <finsh_thread_entry+0x688>)
 801c4d4:	681b      	ldr	r3, [r3, #0]
 801c4d6:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801c4da:	1ac3      	subs	r3, r0, r3
            /* normal character */
            if (shell->line_curpos < shell->line_position)
            {
                int i;

                rt_memmove(&shell->line[shell->line_curpos + 1],
 801c4dc:	4608      	mov	r0, r1
 801c4de:	4611      	mov	r1, r2
 801c4e0:	461a      	mov	r2, r3
 801c4e2:	f7fa f923 	bl	801672c <rt_memmove>
                           &shell->line[shell->line_curpos],
                           shell->line_position - shell->line_curpos);
                shell->line[shell->line_curpos] = ch;
 801c4e6:	4b41      	ldr	r3, [pc, #260]	; (801c5ec <finsh_thread_entry+0x688>)
 801c4e8:	681b      	ldr	r3, [r3, #0]
 801c4ea:	4a40      	ldr	r2, [pc, #256]	; (801c5ec <finsh_thread_entry+0x688>)
 801c4ec:	6812      	ldr	r2, [r2, #0]
 801c4ee:	f892 22a5 	ldrb.w	r2, [r2, #677]	; 0x2a5
 801c4f2:	4611      	mov	r1, r2
 801c4f4:	7afa      	ldrb	r2, [r7, #11]
 801c4f6:	440b      	add	r3, r1
 801c4f8:	f883 2254 	strb.w	r2, [r3, #596]	; 0x254
                if (shell->echo_mode)
 801c4fc:	4b3b      	ldr	r3, [pc, #236]	; (801c5ec <finsh_thread_entry+0x688>)
 801c4fe:	681b      	ldr	r3, [r3, #0]
 801c500:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 801c504:	f003 0301 	and.w	r3, r3, #1
 801c508:	b2db      	uxtb	r3, r3
 801c50a:	2b00      	cmp	r3, #0
 801c50c:	d00d      	beq.n	801c52a <finsh_thread_entry+0x5c6>
                    rt_kprintf("%s", &shell->line[shell->line_curpos]);
 801c50e:	4b37      	ldr	r3, [pc, #220]	; (801c5ec <finsh_thread_entry+0x688>)
 801c510:	681a      	ldr	r2, [r3, #0]
 801c512:	4b36      	ldr	r3, [pc, #216]	; (801c5ec <finsh_thread_entry+0x688>)
 801c514:	681b      	ldr	r3, [r3, #0]
 801c516:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801c51a:	f503 7314 	add.w	r3, r3, #592	; 0x250
 801c51e:	4413      	add	r3, r2
 801c520:	3304      	adds	r3, #4
 801c522:	4833      	ldr	r0, [pc, #204]	; (801c5f0 <finsh_thread_entry+0x68c>)
 801c524:	4619      	mov	r1, r3
 801c526:	f7fa fdf3 	bl	8017110 <rt_kprintf>

                /* move the cursor to new position */
                for (i = shell->line_curpos; i < shell->line_position; i++)
 801c52a:	4b30      	ldr	r3, [pc, #192]	; (801c5ec <finsh_thread_entry+0x688>)
 801c52c:	681b      	ldr	r3, [r3, #0]
 801c52e:	f893 32a5 	ldrb.w	r3, [r3, #677]	; 0x2a5
 801c532:	60fb      	str	r3, [r7, #12]
 801c534:	e005      	b.n	801c542 <finsh_thread_entry+0x5de>
                    rt_kprintf("\b");
 801c536:	482f      	ldr	r0, [pc, #188]	; (801c5f4 <finsh_thread_entry+0x690>)
 801c538:	f7fa fdea 	bl	8017110 <rt_kprintf>
                shell->line[shell->line_curpos] = ch;
                if (shell->echo_mode)
                    rt_kprintf("%s", &shell->line[shell->line_curpos]);

                /* move the cursor to new position */
                for (i = shell->line_curpos; i < shell->line_position; i++)
 801c53c:	68fb      	ldr	r3, [r7, #12]
 801c53e:	3301      	adds	r3, #1
 801c540:	60fb      	str	r3, [r7, #12]
 801c542:	4b2a      	ldr	r3, [pc, #168]	; (801c5ec <finsh_thread_entry+0x688>)
 801c544:	681b      	ldr	r3, [r3, #0]
 801c546:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801c54a:	461a      	mov	r2, r3
 801c54c:	68fb      	ldr	r3, [r7, #12]
 801c54e:	429a      	cmp	r2, r3
 801c550:	dcf1      	bgt.n	801c536 <finsh_thread_entry+0x5d2>
 801c552:	e018      	b.n	801c586 <finsh_thread_entry+0x622>
                    rt_kprintf("\b");
            }
            else
            {
                shell->line[shell->line_position] = ch;
 801c554:	4b25      	ldr	r3, [pc, #148]	; (801c5ec <finsh_thread_entry+0x688>)
 801c556:	681b      	ldr	r3, [r3, #0]
 801c558:	4a24      	ldr	r2, [pc, #144]	; (801c5ec <finsh_thread_entry+0x688>)
 801c55a:	6812      	ldr	r2, [r2, #0]
 801c55c:	f892 22a4 	ldrb.w	r2, [r2, #676]	; 0x2a4
 801c560:	4611      	mov	r1, r2
 801c562:	7afa      	ldrb	r2, [r7, #11]
 801c564:	440b      	add	r3, r1
 801c566:	f883 2254 	strb.w	r2, [r3, #596]	; 0x254
                if (shell->echo_mode)
 801c56a:	4b20      	ldr	r3, [pc, #128]	; (801c5ec <finsh_thread_entry+0x688>)
 801c56c:	681b      	ldr	r3, [r3, #0]
 801c56e:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 801c572:	f003 0301 	and.w	r3, r3, #1
 801c576:	b2db      	uxtb	r3, r3
 801c578:	2b00      	cmp	r3, #0
 801c57a:	d004      	beq.n	801c586 <finsh_thread_entry+0x622>
                    rt_kprintf("%c", ch);
 801c57c:	7afb      	ldrb	r3, [r7, #11]
 801c57e:	481e      	ldr	r0, [pc, #120]	; (801c5f8 <finsh_thread_entry+0x694>)
 801c580:	4619      	mov	r1, r3
 801c582:	f7fa fdc5 	bl	8017110 <rt_kprintf>
            }

            ch = 0;
 801c586:	2300      	movs	r3, #0
 801c588:	72fb      	strb	r3, [r7, #11]
            shell->line_position ++;
 801c58a:	4b18      	ldr	r3, [pc, #96]	; (801c5ec <finsh_thread_entry+0x688>)
 801c58c:	681b      	ldr	r3, [r3, #0]
 801c58e:	f893 22a4 	ldrb.w	r2, [r3, #676]	; 0x2a4
 801c592:	3201      	adds	r2, #1
 801c594:	b2d2      	uxtb	r2, r2
 801c596:	f883 22a4 	strb.w	r2, [r3, #676]	; 0x2a4
            shell->line_curpos++;
 801c59a:	4b14      	ldr	r3, [pc, #80]	; (801c5ec <finsh_thread_entry+0x688>)
 801c59c:	681b      	ldr	r3, [r3, #0]
 801c59e:	f893 22a5 	ldrb.w	r2, [r3, #677]	; 0x2a5
 801c5a2:	3201      	adds	r2, #1
 801c5a4:	b2d2      	uxtb	r2, r2
 801c5a6:	f883 22a5 	strb.w	r2, [r3, #677]	; 0x2a5
            if (shell->line_position >= 80)
 801c5aa:	4b10      	ldr	r3, [pc, #64]	; (801c5ec <finsh_thread_entry+0x688>)
 801c5ac:	681b      	ldr	r3, [r3, #0]
 801c5ae:	f893 32a4 	ldrb.w	r3, [r3, #676]	; 0x2a4
 801c5b2:	2b4f      	cmp	r3, #79	; 0x4f
 801c5b4:	d909      	bls.n	801c5ca <finsh_thread_entry+0x666>
            {
                /* clear command line */
                shell->line_position = 0;
 801c5b6:	4b0d      	ldr	r3, [pc, #52]	; (801c5ec <finsh_thread_entry+0x688>)
 801c5b8:	681b      	ldr	r3, [r3, #0]
 801c5ba:	2200      	movs	r2, #0
 801c5bc:	f883 22a4 	strb.w	r2, [r3, #676]	; 0x2a4
                shell->line_curpos = 0;
 801c5c0:	4b0a      	ldr	r3, [pc, #40]	; (801c5ec <finsh_thread_entry+0x688>)
 801c5c2:	681b      	ldr	r3, [r3, #0]
 801c5c4:	2200      	movs	r2, #0
 801c5c6:	f883 22a5 	strb.w	r2, [r3, #677]	; 0x2a5
    {
        /* wait receive */
        if (rt_sem_take(&shell->rx_sem, RT_WAITING_FOREVER) != RT_EOK) continue;

        /* read one character from device */
        while (rt_device_read(shell->device, 0, &ch, 1) == 1)
 801c5ca:	4b08      	ldr	r3, [pc, #32]	; (801c5ec <finsh_thread_entry+0x688>)
 801c5cc:	681b      	ldr	r3, [r3, #0]
 801c5ce:	f8d3 22a8 	ldr.w	r2, [r3, #680]	; 0x2a8
 801c5d2:	f107 030b 	add.w	r3, r7, #11
 801c5d6:	4610      	mov	r0, r2
 801c5d8:	2100      	movs	r1, #0
 801c5da:	461a      	mov	r2, r3
 801c5dc:	2301      	movs	r3, #1
 801c5de:	f7f8 fff7 	bl	80155d0 <rt_device_read>
 801c5e2:	4603      	mov	r3, r0
 801c5e4:	2b01      	cmp	r3, #1
 801c5e6:	f43f ad0c 	beq.w	801c002 <finsh_thread_entry+0x9e>
                /* clear command line */
                shell->line_position = 0;
                shell->line_curpos = 0;
            }
        } /* end of device read */
    }
 801c5ea:	e4fe      	b.n	801bfea <finsh_thread_entry+0x86>
 801c5ec:	20012bd8 	.word	0x20012bd8
 801c5f0:	08029c0c 	.word	0x08029c0c
 801c5f4:	08029bf8 	.word	0x08029bf8
 801c5f8:	08029bfc 	.word	0x08029bfc

0801c5fc <finsh_system_function_init>:
}

void finsh_system_function_init(const void *begin, const void *end)
{
 801c5fc:	b480      	push	{r7}
 801c5fe:	b083      	sub	sp, #12
 801c600:	af00      	add	r7, sp, #0
 801c602:	6078      	str	r0, [r7, #4]
 801c604:	6039      	str	r1, [r7, #0]
    _syscall_table_begin = (struct finsh_syscall *) begin;
 801c606:	4a05      	ldr	r2, [pc, #20]	; (801c61c <finsh_system_function_init+0x20>)
 801c608:	687b      	ldr	r3, [r7, #4]
 801c60a:	6013      	str	r3, [r2, #0]
    _syscall_table_end = (struct finsh_syscall *) end;
 801c60c:	4a04      	ldr	r2, [pc, #16]	; (801c620 <finsh_system_function_init+0x24>)
 801c60e:	683b      	ldr	r3, [r7, #0]
 801c610:	6013      	str	r3, [r2, #0]
}
 801c612:	370c      	adds	r7, #12
 801c614:	46bd      	mov	sp, r7
 801c616:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c61a:	4770      	bx	lr
 801c61c:	200121b0 	.word	0x200121b0
 801c620:	200121b4 	.word	0x200121b4

0801c624 <finsh_system_var_init>:

void finsh_system_var_init(const void *begin, const void *end)
{
 801c624:	b480      	push	{r7}
 801c626:	b083      	sub	sp, #12
 801c628:	af00      	add	r7, sp, #0
 801c62a:	6078      	str	r0, [r7, #4]
 801c62c:	6039      	str	r1, [r7, #0]
    _sysvar_table_begin = (struct finsh_sysvar *) begin;
 801c62e:	4a05      	ldr	r2, [pc, #20]	; (801c644 <finsh_system_var_init+0x20>)
 801c630:	687b      	ldr	r3, [r7, #4]
 801c632:	6013      	str	r3, [r2, #0]
    _sysvar_table_end = (struct finsh_sysvar *) end;
 801c634:	4a04      	ldr	r2, [pc, #16]	; (801c648 <finsh_system_var_init+0x24>)
 801c636:	683b      	ldr	r3, [r7, #0]
 801c638:	6013      	str	r3, [r2, #0]
}
 801c63a:	370c      	adds	r7, #12
 801c63c:	46bd      	mov	sp, r7
 801c63e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c642:	4770      	bx	lr
 801c644:	200121b8 	.word	0x200121b8
 801c648:	200121bc 	.word	0x200121bc

0801c64c <finsh_system_init>:
 * @ingroup finsh
 *
 * This function will initialize finsh shell
 */
int finsh_system_init(void)
{
 801c64c:	b580      	push	{r7, lr}
 801c64e:	b086      	sub	sp, #24
 801c650:	af04      	add	r7, sp, #16
    /* GNU GCC Compiler and TI CCS */
    extern const int __fsymtab_start;
    extern const int __fsymtab_end;
    extern const int __vsymtab_start;
    extern const int __vsymtab_end;
    finsh_system_function_init(&__fsymtab_start, &__fsymtab_end);
 801c652:	4822      	ldr	r0, [pc, #136]	; (801c6dc <finsh_system_init+0x90>)
 801c654:	4922      	ldr	r1, [pc, #136]	; (801c6e0 <finsh_system_init+0x94>)
 801c656:	f7ff ffd1 	bl	801c5fc <finsh_system_function_init>
    finsh_system_var_init(&__vsymtab_start, &__vsymtab_end);
 801c65a:	4822      	ldr	r0, [pc, #136]	; (801c6e4 <finsh_system_init+0x98>)
 801c65c:	4922      	ldr	r1, [pc, #136]	; (801c6e8 <finsh_system_init+0x9c>)
 801c65e:	f7ff ffe1 	bl	801c624 <finsh_system_var_init>
#endif
#endif

    /* create or set shell structure */
#ifdef RT_USING_HEAP
    shell = (struct finsh_shell *)rt_malloc(sizeof(struct finsh_shell));
 801c662:	f44f 702b 	mov.w	r0, #684	; 0x2ac
 801c666:	f7fa ff01 	bl	801746c <rt_malloc>
 801c66a:	4602      	mov	r2, r0
 801c66c:	4b1f      	ldr	r3, [pc, #124]	; (801c6ec <finsh_system_init+0xa0>)
 801c66e:	601a      	str	r2, [r3, #0]
    if (shell == RT_NULL)
 801c670:	4b1e      	ldr	r3, [pc, #120]	; (801c6ec <finsh_system_init+0xa0>)
 801c672:	681b      	ldr	r3, [r3, #0]
 801c674:	2b00      	cmp	r3, #0
 801c676:	d105      	bne.n	801c684 <finsh_system_init+0x38>
    {
        rt_kprintf("no memory for shell\n");
 801c678:	481d      	ldr	r0, [pc, #116]	; (801c6f0 <finsh_system_init+0xa4>)
 801c67a:	f7fa fd49 	bl	8017110 <rt_kprintf>
        return -1;
 801c67e:	f04f 33ff 	mov.w	r3, #4294967295
 801c682:	e026      	b.n	801c6d2 <finsh_system_init+0x86>
    }
#else
    shell = &_shell;
#endif

    memset(shell, 0, sizeof(struct finsh_shell));
 801c684:	4b19      	ldr	r3, [pc, #100]	; (801c6ec <finsh_system_init+0xa0>)
 801c686:	681b      	ldr	r3, [r3, #0]
 801c688:	4618      	mov	r0, r3
 801c68a:	2100      	movs	r1, #0
 801c68c:	f44f 722b 	mov.w	r2, #684	; 0x2ac
 801c690:	f005 fff4 	bl	802267c <memset>

    rt_sem_init(&(shell->rx_sem), "shrx", 0, 0);
 801c694:	4b15      	ldr	r3, [pc, #84]	; (801c6ec <finsh_system_init+0xa0>)
 801c696:	681b      	ldr	r3, [r3, #0]
 801c698:	4618      	mov	r0, r3
 801c69a:	4916      	ldr	r1, [pc, #88]	; (801c6f4 <finsh_system_init+0xa8>)
 801c69c:	2200      	movs	r2, #0
 801c69e:	2300      	movs	r3, #0
 801c6a0:	f7f9 f9bc 	bl	8015a1c <rt_sem_init>
    result = rt_thread_init(&finsh_thread,
 801c6a4:	4b14      	ldr	r3, [pc, #80]	; (801c6f8 <finsh_system_init+0xac>)
 801c6a6:	9300      	str	r3, [sp, #0]
 801c6a8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 801c6ac:	9301      	str	r3, [sp, #4]
 801c6ae:	230a      	movs	r3, #10
 801c6b0:	9302      	str	r3, [sp, #8]
 801c6b2:	230a      	movs	r3, #10
 801c6b4:	9303      	str	r3, [sp, #12]
 801c6b6:	4811      	ldr	r0, [pc, #68]	; (801c6fc <finsh_system_init+0xb0>)
 801c6b8:	4911      	ldr	r1, [pc, #68]	; (801c700 <finsh_system_init+0xb4>)
 801c6ba:	4a12      	ldr	r2, [pc, #72]	; (801c704 <finsh_system_init+0xb8>)
 801c6bc:	2300      	movs	r3, #0
 801c6be:	f7fb feb5 	bl	801842c <rt_thread_init>
 801c6c2:	6078      	str	r0, [r7, #4]
                            "tshell",
                            finsh_thread_entry, RT_NULL,
                            &finsh_thread_stack[0], sizeof(finsh_thread_stack),
                            FINSH_THREAD_PRIORITY, 10);

    if (result == RT_EOK)
 801c6c4:	687b      	ldr	r3, [r7, #4]
 801c6c6:	2b00      	cmp	r3, #0
 801c6c8:	d102      	bne.n	801c6d0 <finsh_system_init+0x84>
        rt_thread_startup(&finsh_thread);
 801c6ca:	480c      	ldr	r0, [pc, #48]	; (801c6fc <finsh_system_init+0xb0>)
 801c6cc:	f7fb fef0 	bl	80184b0 <rt_thread_startup>
    return 0;
 801c6d0:	2300      	movs	r3, #0
}
 801c6d2:	4618      	mov	r0, r3
 801c6d4:	3708      	adds	r7, #8
 801c6d6:	46bd      	mov	sp, r7
 801c6d8:	bd80      	pop	{r7, pc}
 801c6da:	bf00      	nop
 801c6dc:	0802be68 	.word	0x0802be68
 801c6e0:	0802c0a8 	.word	0x0802c0a8
 801c6e4:	0802c0a8 	.word	0x0802c0a8
 801c6e8:	0802c0b8 	.word	0x0802c0b8
 801c6ec:	20012bd8 	.word	0x20012bd8
 801c6f0:	08029c10 	.word	0x08029c10
 801c6f4:	08029c28 	.word	0x08029c28
 801c6f8:	2001112c 	.word	0x2001112c
 801c6fc:	200110ac 	.word	0x200110ac
 801c700:	08029c30 	.word	0x08029c30
 801c704:	0801bf65 	.word	0x0801bf65

0801c708 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
 801c708:	b480      	push	{r7}
 801c70a:	b083      	sub	sp, #12
 801c70c:	af00      	add	r7, sp, #0
 801c70e:	6078      	str	r0, [r7, #4]
    return l->next == l;
 801c710:	687b      	ldr	r3, [r7, #4]
 801c712:	681a      	ldr	r2, [r3, #0]
 801c714:	687b      	ldr	r3, [r7, #4]
 801c716:	429a      	cmp	r2, r3
 801c718:	bf0c      	ite	eq
 801c71a:	2301      	moveq	r3, #1
 801c71c:	2300      	movne	r3, #0
 801c71e:	b2db      	uxtb	r3, r3
}
 801c720:	4618      	mov	r0, r3
 801c722:	370c      	adds	r7, #12
 801c724:	46bd      	mov	sp, r7
 801c726:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c72a:	4770      	bx	lr

0801c72c <rt_list_len>:

#include <rtthread.h>
#include "finsh.h"

rt_inline unsigned int rt_list_len(const rt_list_t *l)
{
 801c72c:	b480      	push	{r7}
 801c72e:	b085      	sub	sp, #20
 801c730:	af00      	add	r7, sp, #0
 801c732:	6078      	str	r0, [r7, #4]
    unsigned int len = 0;
 801c734:	2300      	movs	r3, #0
 801c736:	60fb      	str	r3, [r7, #12]
    const rt_list_t *p = l;
 801c738:	687b      	ldr	r3, [r7, #4]
 801c73a:	60bb      	str	r3, [r7, #8]
    while (p->next != l)
 801c73c:	e005      	b.n	801c74a <rt_list_len+0x1e>
    {
        p = p->next;
 801c73e:	68bb      	ldr	r3, [r7, #8]
 801c740:	681b      	ldr	r3, [r3, #0]
 801c742:	60bb      	str	r3, [r7, #8]
        len ++;
 801c744:	68fb      	ldr	r3, [r7, #12]
 801c746:	3301      	adds	r3, #1
 801c748:	60fb      	str	r3, [r7, #12]

rt_inline unsigned int rt_list_len(const rt_list_t *l)
{
    unsigned int len = 0;
    const rt_list_t *p = l;
    while (p->next != l)
 801c74a:	68bb      	ldr	r3, [r7, #8]
 801c74c:	681a      	ldr	r2, [r3, #0]
 801c74e:	687b      	ldr	r3, [r7, #4]
 801c750:	429a      	cmp	r2, r3
 801c752:	d1f4      	bne.n	801c73e <rt_list_len+0x12>
    {
        p = p->next;
        len ++;
    }

    return len;
 801c754:	68fb      	ldr	r3, [r7, #12]
}
 801c756:	4618      	mov	r0, r3
 801c758:	3714      	adds	r7, #20
 801c75a:	46bd      	mov	sp, r7
 801c75c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c760:	4770      	bx	lr
 801c762:	bf00      	nop

0801c764 <hello>:

long hello(void)
{
 801c764:	b580      	push	{r7, lr}
 801c766:	af00      	add	r7, sp, #0
    rt_kprintf("Hello RT-Thread!\n");
 801c768:	4802      	ldr	r0, [pc, #8]	; (801c774 <hello+0x10>)
 801c76a:	f7fa fcd1 	bl	8017110 <rt_kprintf>

    return 0;
 801c76e:	2300      	movs	r3, #0
}
 801c770:	4618      	mov	r0, r3
 801c772:	bd80      	pop	{r7, pc}
 801c774:	08029c38 	.word	0x08029c38

0801c778 <version>:
FINSH_FUNCTION_EXPORT(hello, say hello world);

extern void rt_show_version(void);
long version(void)
{
 801c778:	b580      	push	{r7, lr}
 801c77a:	af00      	add	r7, sp, #0
    rt_show_version();
 801c77c:	f7fa f888 	bl	8016890 <rt_show_version>

    return 0;
 801c780:	2300      	movs	r3, #0
}
 801c782:	4618      	mov	r0, r3
 801c784:	bd80      	pop	{r7, pc}
 801c786:	bf00      	nop

0801c788 <_list_thread>:
MSH_CMD_EXPORT(version, show RT-Thread version information);

extern struct rt_object_information rt_object_container[];

static long _list_thread(struct rt_list_node *list)
{
 801c788:	b5b0      	push	{r4, r5, r7, lr}
 801c78a:	b088      	sub	sp, #32
 801c78c:	af02      	add	r7, sp, #8
 801c78e:	6078      	str	r0, [r7, #4]
    struct rt_thread *thread;
    struct rt_list_node *node;
    rt_uint8_t *ptr;

    rt_kprintf(" thread  pri  status      sp     stack size max used   left tick  error\n");
 801c790:	4837      	ldr	r0, [pc, #220]	; (801c870 <_list_thread+0xe8>)
 801c792:	f7fa fcbd 	bl	8017110 <rt_kprintf>
    rt_kprintf("-------- ---- ------- ---------- ---------- ---------- ---------- ---\n");
 801c796:	4837      	ldr	r0, [pc, #220]	; (801c874 <_list_thread+0xec>)
 801c798:	f7fa fcba 	bl	8017110 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801c79c:	687b      	ldr	r3, [r7, #4]
 801c79e:	681b      	ldr	r3, [r3, #0]
 801c7a0:	617b      	str	r3, [r7, #20]
 801c7a2:	e05c      	b.n	801c85e <_list_thread+0xd6>
    {
        thread = rt_list_entry(node, struct rt_thread, list);
 801c7a4:	697b      	ldr	r3, [r7, #20]
 801c7a6:	3b0c      	subs	r3, #12
 801c7a8:	60fb      	str	r3, [r7, #12]
        rt_kprintf("%-8.*s 0x%02x", RT_NAME_MAX, thread->name, thread->current_priority);
 801c7aa:	68fa      	ldr	r2, [r7, #12]
 801c7ac:	68fb      	ldr	r3, [r7, #12]
 801c7ae:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 801c7b2:	4831      	ldr	r0, [pc, #196]	; (801c878 <_list_thread+0xf0>)
 801c7b4:	2108      	movs	r1, #8
 801c7b6:	f7fa fcab 	bl	8017110 <rt_kprintf>

        if (thread->stat == RT_THREAD_READY)        rt_kprintf(" ready  ");
 801c7ba:	68fb      	ldr	r3, [r7, #12]
 801c7bc:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801c7c0:	2b01      	cmp	r3, #1
 801c7c2:	d103      	bne.n	801c7cc <_list_thread+0x44>
 801c7c4:	482d      	ldr	r0, [pc, #180]	; (801c87c <_list_thread+0xf4>)
 801c7c6:	f7fa fca3 	bl	8017110 <rt_kprintf>
 801c7ca:	e019      	b.n	801c800 <_list_thread+0x78>
        else if (thread->stat == RT_THREAD_SUSPEND) rt_kprintf(" suspend");
 801c7cc:	68fb      	ldr	r3, [r7, #12]
 801c7ce:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801c7d2:	2b02      	cmp	r3, #2
 801c7d4:	d103      	bne.n	801c7de <_list_thread+0x56>
 801c7d6:	482a      	ldr	r0, [pc, #168]	; (801c880 <_list_thread+0xf8>)
 801c7d8:	f7fa fc9a 	bl	8017110 <rt_kprintf>
 801c7dc:	e010      	b.n	801c800 <_list_thread+0x78>
        else if (thread->stat == RT_THREAD_INIT)    rt_kprintf(" init   ");
 801c7de:	68fb      	ldr	r3, [r7, #12]
 801c7e0:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801c7e4:	2b00      	cmp	r3, #0
 801c7e6:	d103      	bne.n	801c7f0 <_list_thread+0x68>
 801c7e8:	4826      	ldr	r0, [pc, #152]	; (801c884 <_list_thread+0xfc>)
 801c7ea:	f7fa fc91 	bl	8017110 <rt_kprintf>
 801c7ee:	e007      	b.n	801c800 <_list_thread+0x78>
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");
 801c7f0:	68fb      	ldr	r3, [r7, #12]
 801c7f2:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801c7f6:	2b04      	cmp	r3, #4
 801c7f8:	d102      	bne.n	801c800 <_list_thread+0x78>
 801c7fa:	4823      	ldr	r0, [pc, #140]	; (801c888 <_list_thread+0x100>)
 801c7fc:	f7fa fc88 	bl	8017110 <rt_kprintf>

        ptr = (rt_uint8_t*)thread->stack_addr;
 801c800:	68fb      	ldr	r3, [r7, #12]
 801c802:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801c804:	613b      	str	r3, [r7, #16]
        while (*ptr == '#')ptr ++;
 801c806:	e002      	b.n	801c80e <_list_thread+0x86>
 801c808:	693b      	ldr	r3, [r7, #16]
 801c80a:	3301      	adds	r3, #1
 801c80c:	613b      	str	r3, [r7, #16]
 801c80e:	693b      	ldr	r3, [r7, #16]
 801c810:	781b      	ldrb	r3, [r3, #0]
 801c812:	2b23      	cmp	r3, #35	; 0x23
 801c814:	d0f8      	beq.n	801c808 <_list_thread+0x80>

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
 801c816:	68fb      	ldr	r3, [r7, #12]
 801c818:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
 801c81a:	461a      	mov	r2, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
 801c81c:	68fb      	ldr	r3, [r7, #12]
 801c81e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801c820:	4619      	mov	r1, r3
 801c822:	68fb      	ldr	r3, [r7, #12]
 801c824:	69db      	ldr	r3, [r3, #28]
 801c826:	1acb      	subs	r3, r1, r3
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
 801c828:	18d1      	adds	r1, r2, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
            thread->stack_size,
 801c82a:	68fb      	ldr	r3, [r7, #12]
 801c82c:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
 801c82e:	461d      	mov	r5, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
            thread->stack_size,
            thread->stack_size - ((rt_uint32_t) ptr - (rt_uint32_t)thread->stack_addr),
 801c830:	68fb      	ldr	r3, [r7, #12]
 801c832:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
 801c834:	461a      	mov	r2, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
            thread->stack_size,
            thread->stack_size - ((rt_uint32_t) ptr - (rt_uint32_t)thread->stack_addr),
 801c836:	68fb      	ldr	r3, [r7, #12]
 801c838:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801c83a:	4618      	mov	r0, r3
 801c83c:	693b      	ldr	r3, [r7, #16]
 801c83e:	1ac3      	subs	r3, r0, r3
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
 801c840:	18d4      	adds	r4, r2, r3
 801c842:	68fb      	ldr	r3, [r7, #12]
 801c844:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 801c846:	68fb      	ldr	r3, [r7, #12]
 801c848:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801c84a:	9200      	str	r2, [sp, #0]
 801c84c:	9301      	str	r3, [sp, #4]
 801c84e:	480f      	ldr	r0, [pc, #60]	; (801c88c <_list_thread+0x104>)
 801c850:	462a      	mov	r2, r5
 801c852:	4623      	mov	r3, r4
 801c854:	f7fa fc5c 	bl	8017110 <rt_kprintf>
    struct rt_list_node *node;
    rt_uint8_t *ptr;

    rt_kprintf(" thread  pri  status      sp     stack size max used   left tick  error\n");
    rt_kprintf("-------- ---- ------- ---------- ---------- ---------- ---------- ---\n");
    for (node = list->next; node != list; node = node->next)
 801c858:	697b      	ldr	r3, [r7, #20]
 801c85a:	681b      	ldr	r3, [r3, #0]
 801c85c:	617b      	str	r3, [r7, #20]
 801c85e:	697a      	ldr	r2, [r7, #20]
 801c860:	687b      	ldr	r3, [r7, #4]
 801c862:	429a      	cmp	r2, r3
 801c864:	d19e      	bne.n	801c7a4 <_list_thread+0x1c>
            thread->stack_size - ((rt_uint32_t) ptr - (rt_uint32_t)thread->stack_addr),
            thread->remaining_tick,
            thread->error);
    }
	
    return 0;
 801c866:	2300      	movs	r3, #0
}
 801c868:	4618      	mov	r0, r3
 801c86a:	3718      	adds	r7, #24
 801c86c:	46bd      	mov	sp, r7
 801c86e:	bdb0      	pop	{r4, r5, r7, pc}
 801c870:	08029c4c 	.word	0x08029c4c
 801c874:	08029c98 	.word	0x08029c98
 801c878:	08029ce0 	.word	0x08029ce0
 801c87c:	08029cf0 	.word	0x08029cf0
 801c880:	08029cfc 	.word	0x08029cfc
 801c884:	08029d08 	.word	0x08029d08
 801c888:	08029d14 	.word	0x08029d14
 801c88c:	08029d20 	.word	0x08029d20

0801c890 <list_thread>:

long list_thread(void)
{
 801c890:	b580      	push	{r7, lr}
 801c892:	af00      	add	r7, sp, #0
    return _list_thread(&rt_object_container[RT_Object_Class_Thread].object_list);
 801c894:	4802      	ldr	r0, [pc, #8]	; (801c8a0 <list_thread+0x10>)
 801c896:	f7ff ff77 	bl	801c788 <_list_thread>
 801c89a:	4603      	mov	r3, r0
}
 801c89c:	4618      	mov	r0, r3
 801c89e:	bd80      	pop	{r7, pc}
 801c8a0:	20010020 	.word	0x20010020

0801c8a4 <show_wait_queue>:
FINSH_FUNCTION_EXPORT(list_thread, list thread);
MSH_CMD_EXPORT(list_thread, list thread);

static void show_wait_queue(struct rt_list_node *list)
{
 801c8a4:	b580      	push	{r7, lr}
 801c8a6:	b084      	sub	sp, #16
 801c8a8:	af00      	add	r7, sp, #0
 801c8aa:	6078      	str	r0, [r7, #4]
    struct rt_thread *thread;
    struct rt_list_node *node;

    for (node = list->next; node != list; node = node->next)
 801c8ac:	687b      	ldr	r3, [r7, #4]
 801c8ae:	681b      	ldr	r3, [r3, #0]
 801c8b0:	60fb      	str	r3, [r7, #12]
 801c8b2:	e012      	b.n	801c8da <show_wait_queue+0x36>
    {
        thread = rt_list_entry(node, struct rt_thread, tlist);
 801c8b4:	68fb      	ldr	r3, [r7, #12]
 801c8b6:	3b14      	subs	r3, #20
 801c8b8:	60bb      	str	r3, [r7, #8]
        rt_kprintf("%s", thread->name);
 801c8ba:	68bb      	ldr	r3, [r7, #8]
 801c8bc:	480a      	ldr	r0, [pc, #40]	; (801c8e8 <show_wait_queue+0x44>)
 801c8be:	4619      	mov	r1, r3
 801c8c0:	f7fa fc26 	bl	8017110 <rt_kprintf>

        if (node->next != list)
 801c8c4:	68fb      	ldr	r3, [r7, #12]
 801c8c6:	681a      	ldr	r2, [r3, #0]
 801c8c8:	687b      	ldr	r3, [r7, #4]
 801c8ca:	429a      	cmp	r2, r3
 801c8cc:	d002      	beq.n	801c8d4 <show_wait_queue+0x30>
            rt_kprintf("/");
 801c8ce:	4807      	ldr	r0, [pc, #28]	; (801c8ec <show_wait_queue+0x48>)
 801c8d0:	f7fa fc1e 	bl	8017110 <rt_kprintf>
static void show_wait_queue(struct rt_list_node *list)
{
    struct rt_thread *thread;
    struct rt_list_node *node;

    for (node = list->next; node != list; node = node->next)
 801c8d4:	68fb      	ldr	r3, [r7, #12]
 801c8d6:	681b      	ldr	r3, [r3, #0]
 801c8d8:	60fb      	str	r3, [r7, #12]
 801c8da:	68fa      	ldr	r2, [r7, #12]
 801c8dc:	687b      	ldr	r3, [r7, #4]
 801c8de:	429a      	cmp	r2, r3
 801c8e0:	d1e8      	bne.n	801c8b4 <show_wait_queue+0x10>
        rt_kprintf("%s", thread->name);

        if (node->next != list)
            rt_kprintf("/");
    }
}
 801c8e2:	3710      	adds	r7, #16
 801c8e4:	46bd      	mov	sp, r7
 801c8e6:	bd80      	pop	{r7, pc}
 801c8e8:	08029d44 	.word	0x08029d44
 801c8ec:	08029d48 	.word	0x08029d48

0801c8f0 <_list_sem>:

#ifdef RT_USING_SEMAPHORE
static long _list_sem(struct rt_list_node *list)
{
 801c8f0:	b5b0      	push	{r4, r5, r7, lr}
 801c8f2:	b086      	sub	sp, #24
 801c8f4:	af02      	add	r7, sp, #8
 801c8f6:	6078      	str	r0, [r7, #4]
    struct rt_semaphore *sem;
    struct rt_list_node *node;

    rt_kprintf("semaphore v   suspend thread\n");
 801c8f8:	4825      	ldr	r0, [pc, #148]	; (801c990 <_list_sem+0xa0>)
 801c8fa:	f7fa fc09 	bl	8017110 <rt_kprintf>
    rt_kprintf("--------  --- --------------\n");
 801c8fe:	4825      	ldr	r0, [pc, #148]	; (801c994 <_list_sem+0xa4>)
 801c900:	f7fa fc06 	bl	8017110 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801c904:	687b      	ldr	r3, [r7, #4]
 801c906:	681b      	ldr	r3, [r3, #0]
 801c908:	60fb      	str	r3, [r7, #12]
 801c90a:	e038      	b.n	801c97e <_list_sem+0x8e>
    {
        sem = (struct rt_semaphore *)(rt_list_entry(node, struct rt_object, list));
 801c90c:	68fb      	ldr	r3, [r7, #12]
 801c90e:	3b0c      	subs	r3, #12
 801c910:	60bb      	str	r3, [r7, #8]
        if (!rt_list_isempty(&sem->parent.suspend_thread))
 801c912:	68bb      	ldr	r3, [r7, #8]
 801c914:	3314      	adds	r3, #20
 801c916:	4618      	mov	r0, r3
 801c918:	f7ff fef6 	bl	801c708 <rt_list_isempty>
 801c91c:	4603      	mov	r3, r0
 801c91e:	2b00      	cmp	r3, #0
 801c920:	d119      	bne.n	801c956 <_list_sem+0x66>
        {
            rt_kprintf("%-8.*s  %03d %d:", 
                       RT_NAME_MAX,
                       sem->parent.parent.name,
 801c922:	68bc      	ldr	r4, [r7, #8]
                       sem->value,
 801c924:	68bb      	ldr	r3, [r7, #8]
 801c926:	8b9b      	ldrh	r3, [r3, #28]
    for (node = list->next; node != list; node = node->next)
    {
        sem = (struct rt_semaphore *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&sem->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  %03d %d:", 
 801c928:	461d      	mov	r5, r3
                       RT_NAME_MAX,
                       sem->parent.parent.name,
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
 801c92a:	68bb      	ldr	r3, [r7, #8]
 801c92c:	3314      	adds	r3, #20
    for (node = list->next; node != list; node = node->next)
    {
        sem = (struct rt_semaphore *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&sem->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  %03d %d:", 
 801c92e:	4618      	mov	r0, r3
 801c930:	f7ff fefc 	bl	801c72c <rt_list_len>
 801c934:	4603      	mov	r3, r0
 801c936:	9300      	str	r3, [sp, #0]
 801c938:	4817      	ldr	r0, [pc, #92]	; (801c998 <_list_sem+0xa8>)
 801c93a:	2108      	movs	r1, #8
 801c93c:	4622      	mov	r2, r4
 801c93e:	462b      	mov	r3, r5
 801c940:	f7fa fbe6 	bl	8017110 <rt_kprintf>
                       RT_NAME_MAX,
                       sem->parent.parent.name,
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
            show_wait_queue(&(sem->parent.suspend_thread));
 801c944:	68bb      	ldr	r3, [r7, #8]
 801c946:	3314      	adds	r3, #20
 801c948:	4618      	mov	r0, r3
 801c94a:	f7ff ffab 	bl	801c8a4 <show_wait_queue>
            rt_kprintf("\n");
 801c94e:	4813      	ldr	r0, [pc, #76]	; (801c99c <_list_sem+0xac>)
 801c950:	f7fa fbde 	bl	8017110 <rt_kprintf>
 801c954:	e010      	b.n	801c978 <_list_sem+0x88>
        }
        else
        {
            rt_kprintf("%-8.*s  %03d %d\n",
                       RT_NAME_MAX,
                       sem->parent.parent.name,
 801c956:	68bc      	ldr	r4, [r7, #8]
                       sem->value,
 801c958:	68bb      	ldr	r3, [r7, #8]
 801c95a:	8b9b      	ldrh	r3, [r3, #28]
            show_wait_queue(&(sem->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s  %03d %d\n",
 801c95c:	461d      	mov	r5, r3
                       RT_NAME_MAX,
                       sem->parent.parent.name,
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
 801c95e:	68bb      	ldr	r3, [r7, #8]
 801c960:	3314      	adds	r3, #20
            show_wait_queue(&(sem->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s  %03d %d\n",
 801c962:	4618      	mov	r0, r3
 801c964:	f7ff fee2 	bl	801c72c <rt_list_len>
 801c968:	4603      	mov	r3, r0
 801c96a:	9300      	str	r3, [sp, #0]
 801c96c:	480c      	ldr	r0, [pc, #48]	; (801c9a0 <_list_sem+0xb0>)
 801c96e:	2108      	movs	r1, #8
 801c970:	4622      	mov	r2, r4
 801c972:	462b      	mov	r3, r5
 801c974:	f7fa fbcc 	bl	8017110 <rt_kprintf>
    struct rt_semaphore *sem;
    struct rt_list_node *node;

    rt_kprintf("semaphore v   suspend thread\n");
    rt_kprintf("--------  --- --------------\n");
    for (node = list->next; node != list; node = node->next)
 801c978:	68fb      	ldr	r3, [r7, #12]
 801c97a:	681b      	ldr	r3, [r3, #0]
 801c97c:	60fb      	str	r3, [r7, #12]
 801c97e:	68fa      	ldr	r2, [r7, #12]
 801c980:	687b      	ldr	r3, [r7, #4]
 801c982:	429a      	cmp	r2, r3
 801c984:	d1c2      	bne.n	801c90c <_list_sem+0x1c>
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
        }
    }

    return 0;
 801c986:	2300      	movs	r3, #0
}
 801c988:	4618      	mov	r0, r3
 801c98a:	3710      	adds	r7, #16
 801c98c:	46bd      	mov	sp, r7
 801c98e:	bdb0      	pop	{r4, r5, r7, pc}
 801c990:	08029d4c 	.word	0x08029d4c
 801c994:	08029d6c 	.word	0x08029d6c
 801c998:	08029d8c 	.word	0x08029d8c
 801c99c:	08029da0 	.word	0x08029da0
 801c9a0:	08029da4 	.word	0x08029da4

0801c9a4 <list_sem>:

long list_sem(void)
{
 801c9a4:	b580      	push	{r7, lr}
 801c9a6:	af00      	add	r7, sp, #0
    return _list_sem(&rt_object_container[RT_Object_Class_Semaphore].object_list);
 801c9a8:	4802      	ldr	r0, [pc, #8]	; (801c9b4 <list_sem+0x10>)
 801c9aa:	f7ff ffa1 	bl	801c8f0 <_list_sem>
 801c9ae:	4603      	mov	r3, r0
}
 801c9b0:	4618      	mov	r0, r3
 801c9b2:	bd80      	pop	{r7, pc}
 801c9b4:	20010030 	.word	0x20010030

0801c9b8 <_list_event>:
MSH_CMD_EXPORT(list_sem, list semaphore in system);
#endif

#ifdef RT_USING_EVENT
static long _list_event(struct rt_list_node *list)
{
 801c9b8:	b5b0      	push	{r4, r5, r7, lr}
 801c9ba:	b086      	sub	sp, #24
 801c9bc:	af02      	add	r7, sp, #8
 801c9be:	6078      	str	r0, [r7, #4]
    struct rt_event *e;
    struct rt_list_node *node;

    rt_kprintf("event    set        suspend thread\n");
 801c9c0:	4820      	ldr	r0, [pc, #128]	; (801ca44 <_list_event+0x8c>)
 801c9c2:	f7fa fba5 	bl	8017110 <rt_kprintf>
    rt_kprintf("-------- ---------- --------------\n");
 801c9c6:	4820      	ldr	r0, [pc, #128]	; (801ca48 <_list_event+0x90>)
 801c9c8:	f7fa fba2 	bl	8017110 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801c9cc:	687b      	ldr	r3, [r7, #4]
 801c9ce:	681b      	ldr	r3, [r3, #0]
 801c9d0:	60fb      	str	r3, [r7, #12]
 801c9d2:	e02d      	b.n	801ca30 <_list_event+0x78>
    {
        e = (struct rt_event *)(rt_list_entry(node, struct rt_object, list));
 801c9d4:	68fb      	ldr	r3, [r7, #12]
 801c9d6:	3b0c      	subs	r3, #12
 801c9d8:	60bb      	str	r3, [r7, #8]
        if (!rt_list_isempty(&e->parent.suspend_thread))
 801c9da:	68bb      	ldr	r3, [r7, #8]
 801c9dc:	3314      	adds	r3, #20
 801c9de:	4618      	mov	r0, r3
 801c9e0:	f7ff fe92 	bl	801c708 <rt_list_isempty>
 801c9e4:	4603      	mov	r3, r0
 801c9e6:	2b00      	cmp	r3, #0
 801c9e8:	d118      	bne.n	801ca1c <_list_event+0x64>
        {
            rt_kprintf("%-8.*s  0x%08x %03d:",
                       RT_NAME_MAX,
                       e->parent.parent.name,
 801c9ea:	68bd      	ldr	r5, [r7, #8]
    for (node = list->next; node != list; node = node->next)
    {
        e = (struct rt_event *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&e->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  0x%08x %03d:",
 801c9ec:	68bb      	ldr	r3, [r7, #8]
 801c9ee:	69dc      	ldr	r4, [r3, #28]
                       RT_NAME_MAX,
                       e->parent.parent.name,
                       e->set,
                       rt_list_len(&e->parent.suspend_thread));
 801c9f0:	68bb      	ldr	r3, [r7, #8]
 801c9f2:	3314      	adds	r3, #20
    for (node = list->next; node != list; node = node->next)
    {
        e = (struct rt_event *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&e->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  0x%08x %03d:",
 801c9f4:	4618      	mov	r0, r3
 801c9f6:	f7ff fe99 	bl	801c72c <rt_list_len>
 801c9fa:	4603      	mov	r3, r0
 801c9fc:	9300      	str	r3, [sp, #0]
 801c9fe:	4813      	ldr	r0, [pc, #76]	; (801ca4c <_list_event+0x94>)
 801ca00:	2108      	movs	r1, #8
 801ca02:	462a      	mov	r2, r5
 801ca04:	4623      	mov	r3, r4
 801ca06:	f7fa fb83 	bl	8017110 <rt_kprintf>
                       RT_NAME_MAX,
                       e->parent.parent.name,
                       e->set,
                       rt_list_len(&e->parent.suspend_thread));
            show_wait_queue(&(e->parent.suspend_thread));
 801ca0a:	68bb      	ldr	r3, [r7, #8]
 801ca0c:	3314      	adds	r3, #20
 801ca0e:	4618      	mov	r0, r3
 801ca10:	f7ff ff48 	bl	801c8a4 <show_wait_queue>
            rt_kprintf("\n");
 801ca14:	480e      	ldr	r0, [pc, #56]	; (801ca50 <_list_event+0x98>)
 801ca16:	f7fa fb7b 	bl	8017110 <rt_kprintf>
 801ca1a:	e006      	b.n	801ca2a <_list_event+0x72>
        }
        else
        {
            rt_kprintf("%-8.*s  0x%08x 0\n",
                       RT_NAME_MAX, e->parent.parent.name, e->set);
 801ca1c:	68ba      	ldr	r2, [r7, #8]
            show_wait_queue(&(e->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s  0x%08x 0\n",
 801ca1e:	68bb      	ldr	r3, [r7, #8]
 801ca20:	69db      	ldr	r3, [r3, #28]
 801ca22:	480c      	ldr	r0, [pc, #48]	; (801ca54 <_list_event+0x9c>)
 801ca24:	2108      	movs	r1, #8
 801ca26:	f7fa fb73 	bl	8017110 <rt_kprintf>
    struct rt_event *e;
    struct rt_list_node *node;

    rt_kprintf("event    set        suspend thread\n");
    rt_kprintf("-------- ---------- --------------\n");
    for (node = list->next; node != list; node = node->next)
 801ca2a:	68fb      	ldr	r3, [r7, #12]
 801ca2c:	681b      	ldr	r3, [r3, #0]
 801ca2e:	60fb      	str	r3, [r7, #12]
 801ca30:	68fa      	ldr	r2, [r7, #12]
 801ca32:	687b      	ldr	r3, [r7, #4]
 801ca34:	429a      	cmp	r2, r3
 801ca36:	d1cd      	bne.n	801c9d4 <_list_event+0x1c>
            rt_kprintf("%-8.*s  0x%08x 0\n",
                       RT_NAME_MAX, e->parent.parent.name, e->set);
        }
    }

    return 0;
 801ca38:	2300      	movs	r3, #0
}
 801ca3a:	4618      	mov	r0, r3
 801ca3c:	3710      	adds	r7, #16
 801ca3e:	46bd      	mov	sp, r7
 801ca40:	bdb0      	pop	{r4, r5, r7, pc}
 801ca42:	bf00      	nop
 801ca44:	08029db8 	.word	0x08029db8
 801ca48:	08029ddc 	.word	0x08029ddc
 801ca4c:	08029e00 	.word	0x08029e00
 801ca50:	08029da0 	.word	0x08029da0
 801ca54:	08029e18 	.word	0x08029e18

0801ca58 <list_event>:

long list_event(void)
{
 801ca58:	b580      	push	{r7, lr}
 801ca5a:	af00      	add	r7, sp, #0
    return _list_event(&rt_object_container[RT_Object_Class_Event].object_list);
 801ca5c:	4802      	ldr	r0, [pc, #8]	; (801ca68 <list_event+0x10>)
 801ca5e:	f7ff ffab 	bl	801c9b8 <_list_event>
 801ca62:	4603      	mov	r3, r0
}
 801ca64:	4618      	mov	r0, r3
 801ca66:	bd80      	pop	{r7, pc}
 801ca68:	20010050 	.word	0x20010050

0801ca6c <_list_mutex>:
MSH_CMD_EXPORT(list_event, list event in system);
#endif

#ifdef RT_USING_MUTEX
static long _list_mutex(struct rt_list_node *list)
{
 801ca6c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801ca6e:	b089      	sub	sp, #36	; 0x24
 801ca70:	af04      	add	r7, sp, #16
 801ca72:	6078      	str	r0, [r7, #4]
    struct rt_mutex *m;
    struct rt_list_node *node;

    rt_kprintf("mutex    owner    hold suspend thread\n");
 801ca74:	4817      	ldr	r0, [pc, #92]	; (801cad4 <_list_mutex+0x68>)
 801ca76:	f7fa fb4b 	bl	8017110 <rt_kprintf>
    rt_kprintf("-------- -------- ---- --------------\n");
 801ca7a:	4817      	ldr	r0, [pc, #92]	; (801cad8 <_list_mutex+0x6c>)
 801ca7c:	f7fa fb48 	bl	8017110 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801ca80:	687b      	ldr	r3, [r7, #4]
 801ca82:	681b      	ldr	r3, [r3, #0]
 801ca84:	60fb      	str	r3, [r7, #12]
 801ca86:	e01b      	b.n	801cac0 <_list_mutex+0x54>
    {
        m = (struct rt_mutex *)(rt_list_entry(node, struct rt_object, list));
 801ca88:	68fb      	ldr	r3, [r7, #12]
 801ca8a:	3b0c      	subs	r3, #12
 801ca8c:	60bb      	str	r3, [r7, #8]
        rt_kprintf("%-8.*s %-8.*s %04d %d\n",
                   RT_NAME_MAX,
                   m->parent.parent.name,
 801ca8e:	68bc      	ldr	r4, [r7, #8]
                   RT_NAME_MAX,
                   m->owner->name,
 801ca90:	68bb      	ldr	r3, [r7, #8]
 801ca92:	6a1b      	ldr	r3, [r3, #32]
 801ca94:	461e      	mov	r6, r3
                   m->hold,
 801ca96:	68bb      	ldr	r3, [r7, #8]
 801ca98:	7fdb      	ldrb	r3, [r3, #31]
    rt_kprintf("mutex    owner    hold suspend thread\n");
    rt_kprintf("-------- -------- ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mutex *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-8.*s %04d %d\n",
 801ca9a:	461d      	mov	r5, r3
                   RT_NAME_MAX,
                   m->parent.parent.name,
                   RT_NAME_MAX,
                   m->owner->name,
                   m->hold,
                   rt_list_len(&m->parent.suspend_thread));
 801ca9c:	68bb      	ldr	r3, [r7, #8]
 801ca9e:	3314      	adds	r3, #20
    rt_kprintf("mutex    owner    hold suspend thread\n");
    rt_kprintf("-------- -------- ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mutex *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-8.*s %04d %d\n",
 801caa0:	4618      	mov	r0, r3
 801caa2:	f7ff fe43 	bl	801c72c <rt_list_len>
 801caa6:	4603      	mov	r3, r0
 801caa8:	9600      	str	r6, [sp, #0]
 801caaa:	9501      	str	r5, [sp, #4]
 801caac:	9302      	str	r3, [sp, #8]
 801caae:	480b      	ldr	r0, [pc, #44]	; (801cadc <_list_mutex+0x70>)
 801cab0:	2108      	movs	r1, #8
 801cab2:	4622      	mov	r2, r4
 801cab4:	2308      	movs	r3, #8
 801cab6:	f7fa fb2b 	bl	8017110 <rt_kprintf>
    struct rt_mutex *m;
    struct rt_list_node *node;

    rt_kprintf("mutex    owner    hold suspend thread\n");
    rt_kprintf("-------- -------- ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
 801caba:	68fb      	ldr	r3, [r7, #12]
 801cabc:	681b      	ldr	r3, [r3, #0]
 801cabe:	60fb      	str	r3, [r7, #12]
 801cac0:	68fa      	ldr	r2, [r7, #12]
 801cac2:	687b      	ldr	r3, [r7, #4]
 801cac4:	429a      	cmp	r2, r3
 801cac6:	d1df      	bne.n	801ca88 <_list_mutex+0x1c>
                   m->owner->name,
                   m->hold,
                   rt_list_len(&m->parent.suspend_thread));
    }

    return 0;
 801cac8:	2300      	movs	r3, #0
}
 801caca:	4618      	mov	r0, r3
 801cacc:	3714      	adds	r7, #20
 801cace:	46bd      	mov	sp, r7
 801cad0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801cad2:	bf00      	nop
 801cad4:	08029e2c 	.word	0x08029e2c
 801cad8:	08029e54 	.word	0x08029e54
 801cadc:	08029e7c 	.word	0x08029e7c

0801cae0 <list_mutex>:

long list_mutex(void)
{
 801cae0:	b580      	push	{r7, lr}
 801cae2:	af00      	add	r7, sp, #0
    return _list_mutex(&rt_object_container[RT_Object_Class_Mutex].object_list);
 801cae4:	4802      	ldr	r0, [pc, #8]	; (801caf0 <list_mutex+0x10>)
 801cae6:	f7ff ffc1 	bl	801ca6c <_list_mutex>
 801caea:	4603      	mov	r3, r0
}
 801caec:	4618      	mov	r0, r3
 801caee:	bd80      	pop	{r7, pc}
 801caf0:	20010040 	.word	0x20010040

0801caf4 <_list_mailbox>:
MSH_CMD_EXPORT(list_mutex, list mutex in system);
#endif

#ifdef RT_USING_MAILBOX
static long _list_mailbox(struct rt_list_node *list)
{
 801caf4:	b5f0      	push	{r4, r5, r6, r7, lr}
 801caf6:	b087      	sub	sp, #28
 801caf8:	af02      	add	r7, sp, #8
 801cafa:	6078      	str	r0, [r7, #4]
    struct rt_mailbox *m;
    struct rt_list_node *node;

    rt_kprintf("mailbox  entry size suspend thread\n");
 801cafc:	4829      	ldr	r0, [pc, #164]	; (801cba4 <_list_mailbox+0xb0>)
 801cafe:	f7fa fb07 	bl	8017110 <rt_kprintf>
    rt_kprintf("-------- ----  ---- --------------\n");
 801cb02:	4829      	ldr	r0, [pc, #164]	; (801cba8 <_list_mailbox+0xb4>)
 801cb04:	f7fa fb04 	bl	8017110 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801cb08:	687b      	ldr	r3, [r7, #4]
 801cb0a:	681b      	ldr	r3, [r3, #0]
 801cb0c:	60fb      	str	r3, [r7, #12]
 801cb0e:	e040      	b.n	801cb92 <_list_mailbox+0x9e>
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
 801cb10:	68fb      	ldr	r3, [r7, #12]
 801cb12:	3b0c      	subs	r3, #12
 801cb14:	60bb      	str	r3, [r7, #8]
        if (!rt_list_isempty(&m->parent.suspend_thread))
 801cb16:	68bb      	ldr	r3, [r7, #8]
 801cb18:	3314      	adds	r3, #20
 801cb1a:	4618      	mov	r0, r3
 801cb1c:	f7ff fdf4 	bl	801c708 <rt_list_isempty>
 801cb20:	4603      	mov	r3, r0
 801cb22:	2b00      	cmp	r3, #0
 801cb24:	d11d      	bne.n	801cb62 <_list_mailbox+0x6e>
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
                       RT_NAME_MAX,
                       m->parent.parent.name,
 801cb26:	68bc      	ldr	r4, [r7, #8]
                       m->entry,
 801cb28:	68bb      	ldr	r3, [r7, #8]
 801cb2a:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
 801cb2c:	461e      	mov	r6, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
 801cb2e:	68bb      	ldr	r3, [r7, #8]
 801cb30:	8c1b      	ldrh	r3, [r3, #32]
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
 801cb32:	461d      	mov	r5, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
 801cb34:	68bb      	ldr	r3, [r7, #8]
 801cb36:	3314      	adds	r3, #20
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
 801cb38:	4618      	mov	r0, r3
 801cb3a:	f7ff fdf7 	bl	801c72c <rt_list_len>
 801cb3e:	4603      	mov	r3, r0
 801cb40:	9500      	str	r5, [sp, #0]
 801cb42:	9301      	str	r3, [sp, #4]
 801cb44:	4819      	ldr	r0, [pc, #100]	; (801cbac <_list_mailbox+0xb8>)
 801cb46:	2108      	movs	r1, #8
 801cb48:	4622      	mov	r2, r4
 801cb4a:	4633      	mov	r3, r6
 801cb4c:	f7fa fae0 	bl	8017110 <rt_kprintf>
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
            show_wait_queue(&(m->parent.suspend_thread));
 801cb50:	68bb      	ldr	r3, [r7, #8]
 801cb52:	3314      	adds	r3, #20
 801cb54:	4618      	mov	r0, r3
 801cb56:	f7ff fea5 	bl	801c8a4 <show_wait_queue>
            rt_kprintf("\n");
 801cb5a:	4815      	ldr	r0, [pc, #84]	; (801cbb0 <_list_mailbox+0xbc>)
 801cb5c:	f7fa fad8 	bl	8017110 <rt_kprintf>
 801cb60:	e014      	b.n	801cb8c <_list_mailbox+0x98>
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
                       RT_NAME_MAX,
                       m->parent.parent.name,
 801cb62:	68bc      	ldr	r4, [r7, #8]
                       m->entry,
 801cb64:	68bb      	ldr	r3, [r7, #8]
 801cb66:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
 801cb68:	461e      	mov	r6, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
 801cb6a:	68bb      	ldr	r3, [r7, #8]
 801cb6c:	8c1b      	ldrh	r3, [r3, #32]
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
 801cb6e:	461d      	mov	r5, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
 801cb70:	68bb      	ldr	r3, [r7, #8]
 801cb72:	3314      	adds	r3, #20
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
 801cb74:	4618      	mov	r0, r3
 801cb76:	f7ff fdd9 	bl	801c72c <rt_list_len>
 801cb7a:	4603      	mov	r3, r0
 801cb7c:	9500      	str	r5, [sp, #0]
 801cb7e:	9301      	str	r3, [sp, #4]
 801cb80:	480c      	ldr	r0, [pc, #48]	; (801cbb4 <_list_mailbox+0xc0>)
 801cb82:	2108      	movs	r1, #8
 801cb84:	4622      	mov	r2, r4
 801cb86:	4633      	mov	r3, r6
 801cb88:	f7fa fac2 	bl	8017110 <rt_kprintf>
    struct rt_mailbox *m;
    struct rt_list_node *node;

    rt_kprintf("mailbox  entry size suspend thread\n");
    rt_kprintf("-------- ----  ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
 801cb8c:	68fb      	ldr	r3, [r7, #12]
 801cb8e:	681b      	ldr	r3, [r3, #0]
 801cb90:	60fb      	str	r3, [r7, #12]
 801cb92:	68fa      	ldr	r2, [r7, #12]
 801cb94:	687b      	ldr	r3, [r7, #4]
 801cb96:	429a      	cmp	r2, r3
 801cb98:	d1ba      	bne.n	801cb10 <_list_mailbox+0x1c>
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
        }
    }

    return 0;
 801cb9a:	2300      	movs	r3, #0
}
 801cb9c:	4618      	mov	r0, r3
 801cb9e:	3714      	adds	r7, #20
 801cba0:	46bd      	mov	sp, r7
 801cba2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801cba4:	08029e94 	.word	0x08029e94
 801cba8:	08029eb8 	.word	0x08029eb8
 801cbac:	08029edc 	.word	0x08029edc
 801cbb0:	08029da0 	.word	0x08029da0
 801cbb4:	08029ef4 	.word	0x08029ef4

0801cbb8 <list_mailbox>:

long list_mailbox(void)
{
 801cbb8:	b580      	push	{r7, lr}
 801cbba:	af00      	add	r7, sp, #0
    return _list_mailbox(&rt_object_container[RT_Object_Class_MailBox].object_list);
 801cbbc:	4802      	ldr	r0, [pc, #8]	; (801cbc8 <list_mailbox+0x10>)
 801cbbe:	f7ff ff99 	bl	801caf4 <_list_mailbox>
 801cbc2:	4603      	mov	r3, r0
}
 801cbc4:	4618      	mov	r0, r3
 801cbc6:	bd80      	pop	{r7, pc}
 801cbc8:	20010060 	.word	0x20010060

0801cbcc <_list_msgqueue>:
MSH_CMD_EXPORT(list_mailbox, list mail box in system);
#endif

#ifdef RT_USING_MESSAGEQUEUE
static long _list_msgqueue(struct rt_list_node *list)
{
 801cbcc:	b5b0      	push	{r4, r5, r7, lr}
 801cbce:	b086      	sub	sp, #24
 801cbd0:	af02      	add	r7, sp, #8
 801cbd2:	6078      	str	r0, [r7, #4]
    struct rt_messagequeue *m;
    struct rt_list_node *node;

    rt_kprintf("msgqueue entry suspend thread\n");
 801cbd4:	4825      	ldr	r0, [pc, #148]	; (801cc6c <_list_msgqueue+0xa0>)
 801cbd6:	f7fa fa9b 	bl	8017110 <rt_kprintf>
    rt_kprintf("-------- ----  --------------\n");
 801cbda:	4825      	ldr	r0, [pc, #148]	; (801cc70 <_list_msgqueue+0xa4>)
 801cbdc:	f7fa fa98 	bl	8017110 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801cbe0:	687b      	ldr	r3, [r7, #4]
 801cbe2:	681b      	ldr	r3, [r3, #0]
 801cbe4:	60fb      	str	r3, [r7, #12]
 801cbe6:	e038      	b.n	801cc5a <_list_msgqueue+0x8e>
    {
        m = (struct rt_messagequeue *)(rt_list_entry(node, struct rt_object, list));
 801cbe8:	68fb      	ldr	r3, [r7, #12]
 801cbea:	3b0c      	subs	r3, #12
 801cbec:	60bb      	str	r3, [r7, #8]
        if (!rt_list_isempty(&m->parent.suspend_thread))
 801cbee:	68bb      	ldr	r3, [r7, #8]
 801cbf0:	3314      	adds	r3, #20
 801cbf2:	4618      	mov	r0, r3
 801cbf4:	f7ff fd88 	bl	801c708 <rt_list_isempty>
 801cbf8:	4603      	mov	r3, r0
 801cbfa:	2b00      	cmp	r3, #0
 801cbfc:	d119      	bne.n	801cc32 <_list_msgqueue+0x66>
        {
            rt_kprintf("%-8.*s %04d  %d:",
                       RT_NAME_MAX,
                       m->parent.parent.name,
 801cbfe:	68bc      	ldr	r4, [r7, #8]
                       m->entry,
 801cc00:	68bb      	ldr	r3, [r7, #8]
 801cc02:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_messagequeue *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %d:",
 801cc04:	461d      	mov	r5, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
 801cc06:	68bb      	ldr	r3, [r7, #8]
 801cc08:	3314      	adds	r3, #20
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_messagequeue *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %d:",
 801cc0a:	4618      	mov	r0, r3
 801cc0c:	f7ff fd8e 	bl	801c72c <rt_list_len>
 801cc10:	4603      	mov	r3, r0
 801cc12:	9300      	str	r3, [sp, #0]
 801cc14:	4817      	ldr	r0, [pc, #92]	; (801cc74 <_list_msgqueue+0xa8>)
 801cc16:	2108      	movs	r1, #8
 801cc18:	4622      	mov	r2, r4
 801cc1a:	462b      	mov	r3, r5
 801cc1c:	f7fa fa78 	bl	8017110 <rt_kprintf>
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
            show_wait_queue(&(m->parent.suspend_thread));
 801cc20:	68bb      	ldr	r3, [r7, #8]
 801cc22:	3314      	adds	r3, #20
 801cc24:	4618      	mov	r0, r3
 801cc26:	f7ff fe3d 	bl	801c8a4 <show_wait_queue>
            rt_kprintf("\n");
 801cc2a:	4813      	ldr	r0, [pc, #76]	; (801cc78 <_list_msgqueue+0xac>)
 801cc2c:	f7fa fa70 	bl	8017110 <rt_kprintf>
 801cc30:	e010      	b.n	801cc54 <_list_msgqueue+0x88>
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %d\n",
                       RT_NAME_MAX,
                       m->parent.parent.name,
 801cc32:	68bc      	ldr	r4, [r7, #8]
                       m->entry,
 801cc34:	68bb      	ldr	r3, [r7, #8]
 801cc36:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %d\n",
 801cc38:	461d      	mov	r5, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
 801cc3a:	68bb      	ldr	r3, [r7, #8]
 801cc3c:	3314      	adds	r3, #20
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %d\n",
 801cc3e:	4618      	mov	r0, r3
 801cc40:	f7ff fd74 	bl	801c72c <rt_list_len>
 801cc44:	4603      	mov	r3, r0
 801cc46:	9300      	str	r3, [sp, #0]
 801cc48:	480c      	ldr	r0, [pc, #48]	; (801cc7c <_list_msgqueue+0xb0>)
 801cc4a:	2108      	movs	r1, #8
 801cc4c:	4622      	mov	r2, r4
 801cc4e:	462b      	mov	r3, r5
 801cc50:	f7fa fa5e 	bl	8017110 <rt_kprintf>
    struct rt_messagequeue *m;
    struct rt_list_node *node;

    rt_kprintf("msgqueue entry suspend thread\n");
    rt_kprintf("-------- ----  --------------\n");
    for (node = list->next; node != list; node = node->next)
 801cc54:	68fb      	ldr	r3, [r7, #12]
 801cc56:	681b      	ldr	r3, [r3, #0]
 801cc58:	60fb      	str	r3, [r7, #12]
 801cc5a:	68fa      	ldr	r2, [r7, #12]
 801cc5c:	687b      	ldr	r3, [r7, #4]
 801cc5e:	429a      	cmp	r2, r3
 801cc60:	d1c2      	bne.n	801cbe8 <_list_msgqueue+0x1c>
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
        }
    }

    return 0;
 801cc62:	2300      	movs	r3, #0
}
 801cc64:	4618      	mov	r0, r3
 801cc66:	3710      	adds	r7, #16
 801cc68:	46bd      	mov	sp, r7
 801cc6a:	bdb0      	pop	{r4, r5, r7, pc}
 801cc6c:	08029f0c 	.word	0x08029f0c
 801cc70:	08029f2c 	.word	0x08029f2c
 801cc74:	08029f4c 	.word	0x08029f4c
 801cc78:	08029da0 	.word	0x08029da0
 801cc7c:	08029f60 	.word	0x08029f60

0801cc80 <list_msgqueue>:

long list_msgqueue(void)
{
 801cc80:	b580      	push	{r7, lr}
 801cc82:	af00      	add	r7, sp, #0
    return _list_msgqueue(&rt_object_container[RT_Object_Class_MessageQueue].object_list);
 801cc84:	4802      	ldr	r0, [pc, #8]	; (801cc90 <list_msgqueue+0x10>)
 801cc86:	f7ff ffa1 	bl	801cbcc <_list_msgqueue>
 801cc8a:	4603      	mov	r3, r0
}
 801cc8c:	4618      	mov	r0, r3
 801cc8e:	bd80      	pop	{r7, pc}
 801cc90:	20010070 	.word	0x20010070

0801cc94 <_list_memheap>:
MSH_CMD_EXPORT(list_msgqueue, list message queue in system);
#endif

#ifdef RT_USING_MEMHEAP
static long _list_memheap(struct rt_list_node *list)
{
 801cc94:	b5b0      	push	{r4, r5, r7, lr}
 801cc96:	b086      	sub	sp, #24
 801cc98:	af02      	add	r7, sp, #8
 801cc9a:	6078      	str	r0, [r7, #4]
    struct rt_memheap *mh;
    struct rt_list_node *node;

    rt_kprintf("memheap  pool size  max used size available size\n");
 801cc9c:	4813      	ldr	r0, [pc, #76]	; (801ccec <_list_memheap+0x58>)
 801cc9e:	f7fa fa37 	bl	8017110 <rt_kprintf>
    rt_kprintf("-------- ---------- ------------- --------------\n");
 801cca2:	4813      	ldr	r0, [pc, #76]	; (801ccf0 <_list_memheap+0x5c>)
 801cca4:	f7fa fa34 	bl	8017110 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801cca8:	687b      	ldr	r3, [r7, #4]
 801ccaa:	681b      	ldr	r3, [r3, #0]
 801ccac:	60fb      	str	r3, [r7, #12]
 801ccae:	e014      	b.n	801ccda <_list_memheap+0x46>
    {
        mh = (struct rt_memheap *)rt_list_entry(node, struct rt_object, list);
 801ccb0:	68fb      	ldr	r3, [r7, #12]
 801ccb2:	3b0c      	subs	r3, #12
 801ccb4:	60bb      	str	r3, [r7, #8]

        rt_kprintf("%-8.*s %-010d %-013d %-05d\n",
                   RT_NAME_MAX,
                   mh->parent.name,
 801ccb6:	68bd      	ldr	r5, [r7, #8]
    rt_kprintf("-------- ---------- ------------- --------------\n");
    for (node = list->next; node != list; node = node->next)
    {
        mh = (struct rt_memheap *)rt_list_entry(node, struct rt_object, list);

        rt_kprintf("%-8.*s %-010d %-013d %-05d\n",
 801ccb8:	68bb      	ldr	r3, [r7, #8]
 801ccba:	699c      	ldr	r4, [r3, #24]
 801ccbc:	68bb      	ldr	r3, [r7, #8]
 801ccbe:	6a1a      	ldr	r2, [r3, #32]
 801ccc0:	68bb      	ldr	r3, [r7, #8]
 801ccc2:	69db      	ldr	r3, [r3, #28]
 801ccc4:	9200      	str	r2, [sp, #0]
 801ccc6:	9301      	str	r3, [sp, #4]
 801ccc8:	480a      	ldr	r0, [pc, #40]	; (801ccf4 <_list_memheap+0x60>)
 801ccca:	2108      	movs	r1, #8
 801cccc:	462a      	mov	r2, r5
 801ccce:	4623      	mov	r3, r4
 801ccd0:	f7fa fa1e 	bl	8017110 <rt_kprintf>
    struct rt_memheap *mh;
    struct rt_list_node *node;

    rt_kprintf("memheap  pool size  max used size available size\n");
    rt_kprintf("-------- ---------- ------------- --------------\n");
    for (node = list->next; node != list; node = node->next)
 801ccd4:	68fb      	ldr	r3, [r7, #12]
 801ccd6:	681b      	ldr	r3, [r3, #0]
 801ccd8:	60fb      	str	r3, [r7, #12]
 801ccda:	68fa      	ldr	r2, [r7, #12]
 801ccdc:	687b      	ldr	r3, [r7, #4]
 801ccde:	429a      	cmp	r2, r3
 801cce0:	d1e6      	bne.n	801ccb0 <_list_memheap+0x1c>
                   mh->pool_size,
                   mh->max_used_size,
                   mh->available_size);
    }

    return 0;
 801cce2:	2300      	movs	r3, #0
}
 801cce4:	4618      	mov	r0, r3
 801cce6:	3710      	adds	r7, #16
 801cce8:	46bd      	mov	sp, r7
 801ccea:	bdb0      	pop	{r4, r5, r7, pc}
 801ccec:	08029f74 	.word	0x08029f74
 801ccf0:	08029fa8 	.word	0x08029fa8
 801ccf4:	08029fdc 	.word	0x08029fdc

0801ccf8 <list_memheap>:

long list_memheap(void)
{
 801ccf8:	b580      	push	{r7, lr}
 801ccfa:	af00      	add	r7, sp, #0
    return _list_memheap(&rt_object_container[RT_Object_Class_MemHeap].object_list);
 801ccfc:	4802      	ldr	r0, [pc, #8]	; (801cd08 <list_memheap+0x10>)
 801ccfe:	f7ff ffc9 	bl	801cc94 <_list_memheap>
 801cd02:	4603      	mov	r3, r0
}
 801cd04:	4618      	mov	r0, r3
 801cd06:	bd80      	pop	{r7, pc}
 801cd08:	20010080 	.word	0x20010080

0801cd0c <_list_mempool>:
MSH_CMD_EXPORT(list_memheap, list memory heap in system);
#endif

#ifdef RT_USING_MEMPOOL
static long _list_mempool(struct rt_list_node *list)
{
 801cd0c:	b5b0      	push	{r4, r5, r7, lr}
 801cd0e:	b088      	sub	sp, #32
 801cd10:	af04      	add	r7, sp, #16
 801cd12:	6078      	str	r0, [r7, #4]
    struct rt_mempool *mp;
    struct rt_list_node *node;

    rt_kprintf("mempool  block total free suspend thread\n");
 801cd14:	4824      	ldr	r0, [pc, #144]	; (801cda8 <_list_mempool+0x9c>)
 801cd16:	f7fa f9fb 	bl	8017110 <rt_kprintf>
    rt_kprintf("-------- ----  ----  ---- --------------\n");
 801cd1a:	4824      	ldr	r0, [pc, #144]	; (801cdac <_list_mempool+0xa0>)
 801cd1c:	f7fa f9f8 	bl	8017110 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801cd20:	687b      	ldr	r3, [r7, #4]
 801cd22:	681b      	ldr	r3, [r3, #0]
 801cd24:	60fb      	str	r3, [r7, #12]
 801cd26:	e036      	b.n	801cd96 <_list_mempool+0x8a>
    {
        mp = (struct rt_mempool *)rt_list_entry(node, struct rt_object, list);
 801cd28:	68fb      	ldr	r3, [r7, #12]
 801cd2a:	3b0c      	subs	r3, #12
 801cd2c:	60bb      	str	r3, [r7, #8]
        if (mp->suspend_thread_count > 0)
 801cd2e:	68bb      	ldr	r3, [r7, #8]
 801cd30:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801cd32:	2b00      	cmp	r3, #0
 801cd34:	d01a      	beq.n	801cd6c <_list_mempool+0x60>
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d:",
                       RT_NAME_MAX,
                       mp->parent.name,
 801cd36:	68bd      	ldr	r5, [r7, #8]
    for (node = list->next; node != list; node = node->next)
    {
        mp = (struct rt_mempool *)rt_list_entry(node, struct rt_object, list);
        if (mp->suspend_thread_count > 0)
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d:",
 801cd38:	68bb      	ldr	r3, [r7, #8]
 801cd3a:	69dc      	ldr	r4, [r3, #28]
 801cd3c:	68bb      	ldr	r3, [r7, #8]
 801cd3e:	6a59      	ldr	r1, [r3, #36]	; 0x24
 801cd40:	68bb      	ldr	r3, [r7, #8]
 801cd42:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 801cd44:	68bb      	ldr	r3, [r7, #8]
 801cd46:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801cd48:	9100      	str	r1, [sp, #0]
 801cd4a:	9201      	str	r2, [sp, #4]
 801cd4c:	9302      	str	r3, [sp, #8]
 801cd4e:	4818      	ldr	r0, [pc, #96]	; (801cdb0 <_list_mempool+0xa4>)
 801cd50:	2108      	movs	r1, #8
 801cd52:	462a      	mov	r2, r5
 801cd54:	4623      	mov	r3, r4
 801cd56:	f7fa f9db 	bl	8017110 <rt_kprintf>
                       mp->parent.name,
                       mp->block_size,
                       mp->block_total_count,
                       mp->block_free_count,
                       mp->suspend_thread_count);
            show_wait_queue(&(mp->suspend_thread));
 801cd5a:	68bb      	ldr	r3, [r7, #8]
 801cd5c:	332c      	adds	r3, #44	; 0x2c
 801cd5e:	4618      	mov	r0, r3
 801cd60:	f7ff fda0 	bl	801c8a4 <show_wait_queue>
            rt_kprintf("\n");
 801cd64:	4813      	ldr	r0, [pc, #76]	; (801cdb4 <_list_mempool+0xa8>)
 801cd66:	f7fa f9d3 	bl	8017110 <rt_kprintf>
 801cd6a:	e011      	b.n	801cd90 <_list_mempool+0x84>
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d\n",
                       RT_NAME_MAX,
                       mp->parent.name,
 801cd6c:	68bd      	ldr	r5, [r7, #8]
            show_wait_queue(&(mp->suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d\n",
 801cd6e:	68bb      	ldr	r3, [r7, #8]
 801cd70:	69dc      	ldr	r4, [r3, #28]
 801cd72:	68bb      	ldr	r3, [r7, #8]
 801cd74:	6a59      	ldr	r1, [r3, #36]	; 0x24
 801cd76:	68bb      	ldr	r3, [r7, #8]
 801cd78:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 801cd7a:	68bb      	ldr	r3, [r7, #8]
 801cd7c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801cd7e:	9100      	str	r1, [sp, #0]
 801cd80:	9201      	str	r2, [sp, #4]
 801cd82:	9302      	str	r3, [sp, #8]
 801cd84:	480c      	ldr	r0, [pc, #48]	; (801cdb8 <_list_mempool+0xac>)
 801cd86:	2108      	movs	r1, #8
 801cd88:	462a      	mov	r2, r5
 801cd8a:	4623      	mov	r3, r4
 801cd8c:	f7fa f9c0 	bl	8017110 <rt_kprintf>
    struct rt_mempool *mp;
    struct rt_list_node *node;

    rt_kprintf("mempool  block total free suspend thread\n");
    rt_kprintf("-------- ----  ----  ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
 801cd90:	68fb      	ldr	r3, [r7, #12]
 801cd92:	681b      	ldr	r3, [r3, #0]
 801cd94:	60fb      	str	r3, [r7, #12]
 801cd96:	68fa      	ldr	r2, [r7, #12]
 801cd98:	687b      	ldr	r3, [r7, #4]
 801cd9a:	429a      	cmp	r2, r3
 801cd9c:	d1c4      	bne.n	801cd28 <_list_mempool+0x1c>
                       mp->block_free_count,
                       mp->suspend_thread_count);
        }
    }

    return 0;
 801cd9e:	2300      	movs	r3, #0
}
 801cda0:	4618      	mov	r0, r3
 801cda2:	3710      	adds	r7, #16
 801cda4:	46bd      	mov	sp, r7
 801cda6:	bdb0      	pop	{r4, r5, r7, pc}
 801cda8:	08029ff8 	.word	0x08029ff8
 801cdac:	0802a024 	.word	0x0802a024
 801cdb0:	0802a050 	.word	0x0802a050
 801cdb4:	08029da0 	.word	0x08029da0
 801cdb8:	0802a06c 	.word	0x0802a06c

0801cdbc <list_mempool>:

long list_mempool(void)
{
 801cdbc:	b580      	push	{r7, lr}
 801cdbe:	af00      	add	r7, sp, #0
    return _list_mempool(&rt_object_container[RT_Object_Class_MemPool].object_list);
 801cdc0:	4802      	ldr	r0, [pc, #8]	; (801cdcc <list_mempool+0x10>)
 801cdc2:	f7ff ffa3 	bl	801cd0c <_list_mempool>
 801cdc6:	4603      	mov	r3, r0
}
 801cdc8:	4618      	mov	r0, r3
 801cdca:	bd80      	pop	{r7, pc}
 801cdcc:	20010090 	.word	0x20010090

0801cdd0 <_list_timer>:
FINSH_FUNCTION_EXPORT(list_mempool, list memory pool in system)
MSH_CMD_EXPORT(list_mempool, list memory pool in system);
#endif

static long _list_timer(struct rt_list_node *list)
{
 801cdd0:	b590      	push	{r4, r7, lr}
 801cdd2:	b087      	sub	sp, #28
 801cdd4:	af02      	add	r7, sp, #8
 801cdd6:	6078      	str	r0, [r7, #4]
    struct rt_timer *timer;
    struct rt_list_node *node;

    rt_kprintf("timer    periodic   timeout    flag\n");
 801cdd8:	481b      	ldr	r0, [pc, #108]	; (801ce48 <_list_timer+0x78>)
 801cdda:	f7fa f999 	bl	8017110 <rt_kprintf>
    rt_kprintf("-------- ---------- ---------- -----------\n");
 801cdde:	481b      	ldr	r0, [pc, #108]	; (801ce4c <_list_timer+0x7c>)
 801cde0:	f7fa f996 	bl	8017110 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801cde4:	687b      	ldr	r3, [r7, #4]
 801cde6:	681b      	ldr	r3, [r3, #0]
 801cde8:	60fb      	str	r3, [r7, #12]
 801cdea:	e01d      	b.n	801ce28 <_list_timer+0x58>
    {
        timer = (struct rt_timer *)(rt_list_entry(node, struct rt_object, list));
 801cdec:	68fb      	ldr	r3, [r7, #12]
 801cdee:	3b0c      	subs	r3, #12
 801cdf0:	60bb      	str	r3, [r7, #8]
        rt_kprintf("%-8.*s 0x%08x 0x%08x ",
                   RT_NAME_MAX,
                   timer->parent.name,
 801cdf2:	68ba      	ldr	r2, [r7, #8]
    rt_kprintf("timer    periodic   timeout    flag\n");
    rt_kprintf("-------- ---------- ---------- -----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        timer = (struct rt_timer *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s 0x%08x 0x%08x ",
 801cdf4:	68bb      	ldr	r3, [r7, #8]
 801cdf6:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 801cdf8:	68bb      	ldr	r3, [r7, #8]
 801cdfa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801cdfc:	9300      	str	r3, [sp, #0]
 801cdfe:	4814      	ldr	r0, [pc, #80]	; (801ce50 <_list_timer+0x80>)
 801ce00:	2108      	movs	r1, #8
 801ce02:	4623      	mov	r3, r4
 801ce04:	f7fa f984 	bl	8017110 <rt_kprintf>
                   RT_NAME_MAX,
                   timer->parent.name,
                   timer->init_tick,
                   timer->timeout_tick);
        if (timer->parent.flag & RT_TIMER_FLAG_ACTIVATED)
 801ce08:	68bb      	ldr	r3, [r7, #8]
 801ce0a:	7a5b      	ldrb	r3, [r3, #9]
 801ce0c:	f003 0301 	and.w	r3, r3, #1
 801ce10:	2b00      	cmp	r3, #0
 801ce12:	d003      	beq.n	801ce1c <_list_timer+0x4c>
            rt_kprintf("activated\n");
 801ce14:	480f      	ldr	r0, [pc, #60]	; (801ce54 <_list_timer+0x84>)
 801ce16:	f7fa f97b 	bl	8017110 <rt_kprintf>
 801ce1a:	e002      	b.n	801ce22 <_list_timer+0x52>
        else
            rt_kprintf("deactivated\n");
 801ce1c:	480e      	ldr	r0, [pc, #56]	; (801ce58 <_list_timer+0x88>)
 801ce1e:	f7fa f977 	bl	8017110 <rt_kprintf>
    struct rt_timer *timer;
    struct rt_list_node *node;

    rt_kprintf("timer    periodic   timeout    flag\n");
    rt_kprintf("-------- ---------- ---------- -----------\n");
    for (node = list->next; node != list; node = node->next)
 801ce22:	68fb      	ldr	r3, [r7, #12]
 801ce24:	681b      	ldr	r3, [r3, #0]
 801ce26:	60fb      	str	r3, [r7, #12]
 801ce28:	68fa      	ldr	r2, [r7, #12]
 801ce2a:	687b      	ldr	r3, [r7, #4]
 801ce2c:	429a      	cmp	r2, r3
 801ce2e:	d1dd      	bne.n	801cdec <_list_timer+0x1c>
            rt_kprintf("activated\n");
        else
            rt_kprintf("deactivated\n");
    }

    rt_kprintf("current tick:0x%08x\n", rt_tick_get());
 801ce30:	f7f8 fa2a 	bl	8015288 <rt_tick_get>
 801ce34:	4603      	mov	r3, r0
 801ce36:	4809      	ldr	r0, [pc, #36]	; (801ce5c <_list_timer+0x8c>)
 801ce38:	4619      	mov	r1, r3
 801ce3a:	f7fa f969 	bl	8017110 <rt_kprintf>

    return 0;
 801ce3e:	2300      	movs	r3, #0
}
 801ce40:	4618      	mov	r0, r3
 801ce42:	3714      	adds	r7, #20
 801ce44:	46bd      	mov	sp, r7
 801ce46:	bd90      	pop	{r4, r7, pc}
 801ce48:	0802a088 	.word	0x0802a088
 801ce4c:	0802a0b0 	.word	0x0802a0b0
 801ce50:	0802a0dc 	.word	0x0802a0dc
 801ce54:	0802a0f4 	.word	0x0802a0f4
 801ce58:	0802a100 	.word	0x0802a100
 801ce5c:	0802a110 	.word	0x0802a110

0801ce60 <list_timer>:

long list_timer(void)
{
 801ce60:	b580      	push	{r7, lr}
 801ce62:	af00      	add	r7, sp, #0
    return _list_timer(&rt_object_container[RT_Object_Class_Timer].object_list);
 801ce64:	4802      	ldr	r0, [pc, #8]	; (801ce70 <list_timer+0x10>)
 801ce66:	f7ff ffb3 	bl	801cdd0 <_list_timer>
 801ce6a:	4603      	mov	r3, r0
}
 801ce6c:	4618      	mov	r0, r3
 801ce6e:	bd80      	pop	{r7, pc}
 801ce70:	200100b0 	.word	0x200100b0

0801ce74 <_list_device>:
FINSH_FUNCTION_EXPORT(list_timer, list timer in system);
MSH_CMD_EXPORT(list_timer, list timer in system);

#ifdef RT_USING_DEVICE
static long _list_device(struct rt_list_node *list)
{
 801ce74:	b590      	push	{r4, r7, lr}
 801ce76:	b09b      	sub	sp, #108	; 0x6c
 801ce78:	af02      	add	r7, sp, #8
 801ce7a:	6078      	str	r0, [r7, #4]
    struct rt_device *device;
    struct rt_list_node *node;
    char * const device_type_str[] =
 801ce7c:	4a1b      	ldr	r2, [pc, #108]	; (801ceec <_list_device+0x78>)
 801ce7e:	f107 0308 	add.w	r3, r7, #8
 801ce82:	4611      	mov	r1, r2
 801ce84:	2250      	movs	r2, #80	; 0x50
 801ce86:	4618      	mov	r0, r3
 801ce88:	f7e3 fa2a 	bl	80002e0 <memcpy>
		"Timer Device",
		"Miscellaneous Device",
        "Unknown"
    };

    rt_kprintf("device   type                 ref count\n");
 801ce8c:	4818      	ldr	r0, [pc, #96]	; (801cef0 <_list_device+0x7c>)
 801ce8e:	f7fa f93f 	bl	8017110 <rt_kprintf>
    rt_kprintf("-------- -------------------- ----------\n");
 801ce92:	4818      	ldr	r0, [pc, #96]	; (801cef4 <_list_device+0x80>)
 801ce94:	f7fa f93c 	bl	8017110 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
 801ce98:	687b      	ldr	r3, [r7, #4]
 801ce9a:	681b      	ldr	r3, [r3, #0]
 801ce9c:	65fb      	str	r3, [r7, #92]	; 0x5c
 801ce9e:	e01c      	b.n	801ceda <_list_device+0x66>
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
 801cea0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801cea2:	3b0c      	subs	r3, #12
 801cea4:	65bb      	str	r3, [r7, #88]	; 0x58
        rt_kprintf("%-8.*s %-20s %-8d\n",
                   RT_NAME_MAX,
                   device->parent.name,
 801cea6:	6dbc      	ldr	r4, [r7, #88]	; 0x58
                   (device->type <= RT_Device_Class_Unknown) ?
 801cea8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801ceaa:	7d1b      	ldrb	r3, [r3, #20]
    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-20s %-8d\n",
 801ceac:	2b13      	cmp	r3, #19
 801ceae:	d808      	bhi.n	801cec2 <_list_device+0x4e>
                   RT_NAME_MAX,
                   device->parent.name,
                   (device->type <= RT_Device_Class_Unknown) ?
                   device_type_str[device->type] :
 801ceb0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801ceb2:	7d1b      	ldrb	r3, [r3, #20]
    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-20s %-8d\n",
 801ceb4:	009b      	lsls	r3, r3, #2
 801ceb6:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801ceba:	4413      	add	r3, r2
 801cebc:	f853 3c58 	ldr.w	r3, [r3, #-88]
 801cec0:	e000      	b.n	801cec4 <_list_device+0x50>
 801cec2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
                   RT_NAME_MAX,
                   device->parent.name,
                   (device->type <= RT_Device_Class_Unknown) ?
                   device_type_str[device->type] :
                   device_type_str[RT_Device_Class_Unknown],
                   device->ref_count);
 801cec4:	6dba      	ldr	r2, [r7, #88]	; 0x58
 801cec6:	7e92      	ldrb	r2, [r2, #26]
    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-20s %-8d\n",
 801cec8:	9200      	str	r2, [sp, #0]
 801ceca:	480b      	ldr	r0, [pc, #44]	; (801cef8 <_list_device+0x84>)
 801cecc:	2108      	movs	r1, #8
 801cece:	4622      	mov	r2, r4
 801ced0:	f7fa f91e 	bl	8017110 <rt_kprintf>
        "Unknown"
    };

    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
 801ced4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801ced6:	681b      	ldr	r3, [r3, #0]
 801ced8:	65fb      	str	r3, [r7, #92]	; 0x5c
 801ceda:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801cedc:	687b      	ldr	r3, [r7, #4]
 801cede:	429a      	cmp	r2, r3
 801cee0:	d1de      	bne.n	801cea0 <_list_device+0x2c>
                   device_type_str[device->type] :
                   device_type_str[RT_Device_Class_Unknown],
                   device->ref_count);
    }

    return 0;
 801cee2:	2300      	movs	r3, #0
}
 801cee4:	4618      	mov	r0, r3
 801cee6:	3764      	adds	r7, #100	; 0x64
 801cee8:	46bd      	mov	sp, r7
 801ceea:	bd90      	pop	{r4, r7, pc}
 801ceec:	0802a2b0 	.word	0x0802a2b0
 801cef0:	0802a128 	.word	0x0802a128
 801cef4:	0802a154 	.word	0x0802a154
 801cef8:	0802a180 	.word	0x0802a180

0801cefc <list_device>:

long list_device(void)
{
 801cefc:	b580      	push	{r7, lr}
 801cefe:	af00      	add	r7, sp, #0
    return _list_device(&rt_object_container[RT_Object_Class_Device].object_list);
 801cf00:	4802      	ldr	r0, [pc, #8]	; (801cf0c <list_device+0x10>)
 801cf02:	f7ff ffb7 	bl	801ce74 <_list_device>
 801cf06:	4603      	mov	r3, r0
}
 801cf08:	4618      	mov	r0, r3
 801cf0a:	bd80      	pop	{r7, pc}
 801cf0c:	200100a0 	.word	0x200100a0

0801cf10 <list>:
}
FINSH_FUNCTION_EXPORT(list_mod_detail, list module objects in system)
#endif

long list(void)
{
 801cf10:	b580      	push	{r7, lr}
 801cf12:	b084      	sub	sp, #16
 801cf14:	af00      	add	r7, sp, #0
#ifndef FINSH_USING_MSH_ONLY
    struct finsh_syscall_item *syscall_item;
    struct finsh_sysvar_item *sysvar_item;
#endif
	
    rt_kprintf("--Function List:\n");
 801cf16:	4830      	ldr	r0, [pc, #192]	; (801cfd8 <list+0xc8>)
 801cf18:	f7fa f8fa 	bl	8017110 <rt_kprintf>
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
 801cf1c:	4b2f      	ldr	r3, [pc, #188]	; (801cfdc <list+0xcc>)
 801cf1e:	681b      	ldr	r3, [r3, #0]
 801cf20:	607b      	str	r3, [r7, #4]
 801cf22:	e016      	b.n	801cf52 <list+0x42>
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
        {
			/* skip the internal command */
			if (strncmp((char*)index->name, "__", 2) == 0) continue;
 801cf24:	687b      	ldr	r3, [r7, #4]
 801cf26:	681b      	ldr	r3, [r3, #0]
 801cf28:	4618      	mov	r0, r3
 801cf2a:	492d      	ldr	r1, [pc, #180]	; (801cfe0 <list+0xd0>)
 801cf2c:	2202      	movs	r2, #2
 801cf2e:	f006 f865 	bl	8022ffc <strncmp>
 801cf32:	4603      	mov	r3, r0
 801cf34:	2b00      	cmp	r3, #0
 801cf36:	d100      	bne.n	801cf3a <list+0x2a>
 801cf38:	e008      	b.n	801cf4c <list+0x3c>

#ifdef FINSH_USING_DESCRIPTION
            rt_kprintf("%-16s -- %s\n", index->name, index->desc);
 801cf3a:	687b      	ldr	r3, [r7, #4]
 801cf3c:	681a      	ldr	r2, [r3, #0]
 801cf3e:	687b      	ldr	r3, [r7, #4]
 801cf40:	685b      	ldr	r3, [r3, #4]
 801cf42:	4828      	ldr	r0, [pc, #160]	; (801cfe4 <list+0xd4>)
 801cf44:	4611      	mov	r1, r2
 801cf46:	461a      	mov	r2, r3
 801cf48:	f7fa f8e2 	bl	8017110 <rt_kprintf>
    rt_kprintf("--Function List:\n");
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
 801cf4c:	687b      	ldr	r3, [r7, #4]
 801cf4e:	330c      	adds	r3, #12
 801cf50:	607b      	str	r3, [r7, #4]
	
    rt_kprintf("--Function List:\n");
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
 801cf52:	4b25      	ldr	r3, [pc, #148]	; (801cfe8 <list+0xd8>)
 801cf54:	681b      	ldr	r3, [r3, #0]
#endif
	
    rt_kprintf("--Function List:\n");
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
 801cf56:	687a      	ldr	r2, [r7, #4]
 801cf58:	429a      	cmp	r2, r3
 801cf5a:	d3e3      	bcc.n	801cf24 <list+0x14>
        }
    }

#ifndef FINSH_USING_MSH_ONLY
    /* list syscall list */
    syscall_item = global_syscall_list;
 801cf5c:	4b23      	ldr	r3, [pc, #140]	; (801cfec <list+0xdc>)
 801cf5e:	681b      	ldr	r3, [r3, #0]
 801cf60:	60fb      	str	r3, [r7, #12]
    while (syscall_item != NULL)
 801cf62:	e008      	b.n	801cf76 <list+0x66>
    {
        rt_kprintf("[l] %s\n", syscall_item->syscall.name);
 801cf64:	68fb      	ldr	r3, [r7, #12]
 801cf66:	685b      	ldr	r3, [r3, #4]
 801cf68:	4821      	ldr	r0, [pc, #132]	; (801cff0 <list+0xe0>)
 801cf6a:	4619      	mov	r1, r3
 801cf6c:	f7fa f8d0 	bl	8017110 <rt_kprintf>
        syscall_item = syscall_item->next;
 801cf70:	68fb      	ldr	r3, [r7, #12]
 801cf72:	681b      	ldr	r3, [r3, #0]
 801cf74:	60fb      	str	r3, [r7, #12]
    }

#ifndef FINSH_USING_MSH_ONLY
    /* list syscall list */
    syscall_item = global_syscall_list;
    while (syscall_item != NULL)
 801cf76:	68fb      	ldr	r3, [r7, #12]
 801cf78:	2b00      	cmp	r3, #0
 801cf7a:	d1f3      	bne.n	801cf64 <list+0x54>
    {
        rt_kprintf("[l] %s\n", syscall_item->syscall.name);
        syscall_item = syscall_item->next;
    }

    rt_kprintf("--Variable List:\n");
 801cf7c:	481d      	ldr	r0, [pc, #116]	; (801cff4 <list+0xe4>)
 801cf7e:	f7fa f8c7 	bl	8017110 <rt_kprintf>
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
 801cf82:	4b1d      	ldr	r3, [pc, #116]	; (801cff8 <list+0xe8>)
 801cf84:	681b      	ldr	r3, [r3, #0]
 801cf86:	603b      	str	r3, [r7, #0]
 801cf88:	e00b      	b.n	801cfa2 <list+0x92>
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
        {
#ifdef FINSH_USING_DESCRIPTION
            rt_kprintf("%-16s -- %s\n", index->name, index->desc);
 801cf8a:	683b      	ldr	r3, [r7, #0]
 801cf8c:	681a      	ldr	r2, [r3, #0]
 801cf8e:	683b      	ldr	r3, [r7, #0]
 801cf90:	685b      	ldr	r3, [r3, #4]
 801cf92:	4814      	ldr	r0, [pc, #80]	; (801cfe4 <list+0xd4>)
 801cf94:	4611      	mov	r1, r2
 801cf96:	461a      	mov	r2, r3
 801cf98:	f7fa f8ba 	bl	8017110 <rt_kprintf>
    rt_kprintf("--Variable List:\n");
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
 801cf9c:	683b      	ldr	r3, [r7, #0]
 801cf9e:	3310      	adds	r3, #16
 801cfa0:	603b      	str	r3, [r7, #0]

    rt_kprintf("--Variable List:\n");
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
 801cfa2:	4b16      	ldr	r3, [pc, #88]	; (801cffc <list+0xec>)
 801cfa4:	681b      	ldr	r3, [r3, #0]
    }

    rt_kprintf("--Variable List:\n");
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
 801cfa6:	683a      	ldr	r2, [r7, #0]
 801cfa8:	429a      	cmp	r2, r3
 801cfaa:	d3ee      	bcc.n	801cf8a <list+0x7a>
            rt_kprintf("%s\n", index->name);
#endif
        }
    }

    sysvar_item = global_sysvar_list;
 801cfac:	4b14      	ldr	r3, [pc, #80]	; (801d000 <list+0xf0>)
 801cfae:	681b      	ldr	r3, [r3, #0]
 801cfb0:	60bb      	str	r3, [r7, #8]
    while (sysvar_item != NULL)
 801cfb2:	e008      	b.n	801cfc6 <list+0xb6>
    {
        rt_kprintf("[l] %s\n", sysvar_item->sysvar.name);
 801cfb4:	68bb      	ldr	r3, [r7, #8]
 801cfb6:	685b      	ldr	r3, [r3, #4]
 801cfb8:	480d      	ldr	r0, [pc, #52]	; (801cff0 <list+0xe0>)
 801cfba:	4619      	mov	r1, r3
 801cfbc:	f7fa f8a8 	bl	8017110 <rt_kprintf>
        sysvar_item = sysvar_item->next;
 801cfc0:	68bb      	ldr	r3, [r7, #8]
 801cfc2:	681b      	ldr	r3, [r3, #0]
 801cfc4:	60bb      	str	r3, [r7, #8]
#endif
        }
    }

    sysvar_item = global_sysvar_list;
    while (sysvar_item != NULL)
 801cfc6:	68bb      	ldr	r3, [r7, #8]
 801cfc8:	2b00      	cmp	r3, #0
 801cfca:	d1f3      	bne.n	801cfb4 <list+0xa4>
        rt_kprintf("[l] %s\n", sysvar_item->sysvar.name);
        sysvar_item = sysvar_item->next;
    }
#endif
	
    return 0;
 801cfcc:	2300      	movs	r3, #0
}
 801cfce:	4618      	mov	r0, r3
 801cfd0:	3710      	adds	r7, #16
 801cfd2:	46bd      	mov	sp, r7
 801cfd4:	bd80      	pop	{r7, pc}
 801cfd6:	bf00      	nop
 801cfd8:	0802a300 	.word	0x0802a300
 801cfdc:	200121b0 	.word	0x200121b0
 801cfe0:	0802a314 	.word	0x0802a314
 801cfe4:	0802a318 	.word	0x0802a318
 801cfe8:	200121b4 	.word	0x200121b4
 801cfec:	200121cc 	.word	0x200121cc
 801cff0:	0802a328 	.word	0x0802a328
 801cff4:	0802a330 	.word	0x0802a330
 801cff8:	200121b8 	.word	0x200121b8
 801cffc:	200121bc 	.word	0x200121bc
 801d000:	20012da8 	.word	0x20012da8

0801d004 <str_is_prefix>:
FINSH_FUNCTION_EXPORT(list, list all symbol in system)

#ifndef FINSH_USING_MSH_ONLY
static int str_is_prefix(const char *prefix, const char *str)
{
 801d004:	b480      	push	{r7}
 801d006:	b083      	sub	sp, #12
 801d008:	af00      	add	r7, sp, #0
 801d00a:	6078      	str	r0, [r7, #4]
 801d00c:	6039      	str	r1, [r7, #0]
    while ((*prefix) && (*prefix == *str))
 801d00e:	e005      	b.n	801d01c <str_is_prefix+0x18>
    {
        prefix ++;
 801d010:	687b      	ldr	r3, [r7, #4]
 801d012:	3301      	adds	r3, #1
 801d014:	607b      	str	r3, [r7, #4]
        str ++;
 801d016:	683b      	ldr	r3, [r7, #0]
 801d018:	3301      	adds	r3, #1
 801d01a:	603b      	str	r3, [r7, #0]
FINSH_FUNCTION_EXPORT(list, list all symbol in system)

#ifndef FINSH_USING_MSH_ONLY
static int str_is_prefix(const char *prefix, const char *str)
{
    while ((*prefix) && (*prefix == *str))
 801d01c:	687b      	ldr	r3, [r7, #4]
 801d01e:	781b      	ldrb	r3, [r3, #0]
 801d020:	2b00      	cmp	r3, #0
 801d022:	d005      	beq.n	801d030 <str_is_prefix+0x2c>
 801d024:	687b      	ldr	r3, [r7, #4]
 801d026:	781a      	ldrb	r2, [r3, #0]
 801d028:	683b      	ldr	r3, [r7, #0]
 801d02a:	781b      	ldrb	r3, [r3, #0]
 801d02c:	429a      	cmp	r2, r3
 801d02e:	d0ef      	beq.n	801d010 <str_is_prefix+0xc>
    {
        prefix ++;
        str ++;
    }

    if (*prefix == 0)
 801d030:	687b      	ldr	r3, [r7, #4]
 801d032:	781b      	ldrb	r3, [r3, #0]
 801d034:	2b00      	cmp	r3, #0
 801d036:	d101      	bne.n	801d03c <str_is_prefix+0x38>
        return 0;
 801d038:	2300      	movs	r3, #0
 801d03a:	e001      	b.n	801d040 <str_is_prefix+0x3c>

    return -1;
 801d03c:	f04f 33ff 	mov.w	r3, #4294967295
}
 801d040:	4618      	mov	r0, r3
 801d042:	370c      	adds	r7, #12
 801d044:	46bd      	mov	sp, r7
 801d046:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d04a:	4770      	bx	lr

0801d04c <str_common>:

static int str_common(const char *str1, const char *str2)
{
 801d04c:	b480      	push	{r7}
 801d04e:	b085      	sub	sp, #20
 801d050:	af00      	add	r7, sp, #0
 801d052:	6078      	str	r0, [r7, #4]
 801d054:	6039      	str	r1, [r7, #0]
    const char *str = str1;
 801d056:	687b      	ldr	r3, [r7, #4]
 801d058:	60fb      	str	r3, [r7, #12]

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
 801d05a:	e005      	b.n	801d068 <str_common+0x1c>
    {
        str ++;
 801d05c:	68fb      	ldr	r3, [r7, #12]
 801d05e:	3301      	adds	r3, #1
 801d060:	60fb      	str	r3, [r7, #12]
        str2 ++;
 801d062:	683b      	ldr	r3, [r7, #0]
 801d064:	3301      	adds	r3, #1
 801d066:	603b      	str	r3, [r7, #0]

static int str_common(const char *str1, const char *str2)
{
    const char *str = str1;

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
 801d068:	68fb      	ldr	r3, [r7, #12]
 801d06a:	781b      	ldrb	r3, [r3, #0]
 801d06c:	2b00      	cmp	r3, #0
 801d06e:	d009      	beq.n	801d084 <str_common+0x38>
 801d070:	683b      	ldr	r3, [r7, #0]
 801d072:	781b      	ldrb	r3, [r3, #0]
 801d074:	2b00      	cmp	r3, #0
 801d076:	d005      	beq.n	801d084 <str_common+0x38>
 801d078:	68fb      	ldr	r3, [r7, #12]
 801d07a:	781a      	ldrb	r2, [r3, #0]
 801d07c:	683b      	ldr	r3, [r7, #0]
 801d07e:	781b      	ldrb	r3, [r3, #0]
 801d080:	429a      	cmp	r2, r3
 801d082:	d0eb      	beq.n	801d05c <str_common+0x10>
    {
        str ++;
        str2 ++;
    }

    return (str - str1);
 801d084:	68fa      	ldr	r2, [r7, #12]
 801d086:	687b      	ldr	r3, [r7, #4]
 801d088:	1ad3      	subs	r3, r2, r3
}
 801d08a:	4618      	mov	r0, r3
 801d08c:	3714      	adds	r7, #20
 801d08e:	46bd      	mov	sp, r7
 801d090:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d094:	4770      	bx	lr
 801d096:	bf00      	nop

0801d098 <list_prefix>:

void list_prefix(char *prefix)
{
 801d098:	b580      	push	{r7, lr}
 801d09a:	b08a      	sub	sp, #40	; 0x28
 801d09c:	af00      	add	r7, sp, #0
 801d09e:	6078      	str	r0, [r7, #4]
    struct finsh_sysvar_item *sysvar_item;
    rt_uint16_t func_cnt, var_cnt;
    int length, min_length;
    const char *name_ptr;

    func_cnt = 0;
 801d0a0:	2300      	movs	r3, #0
 801d0a2:	83fb      	strh	r3, [r7, #30]
    var_cnt  = 0;
 801d0a4:	2300      	movs	r3, #0
 801d0a6:	83bb      	strh	r3, [r7, #28]
    min_length = 0;
 801d0a8:	2300      	movs	r3, #0
 801d0aa:	61bb      	str	r3, [r7, #24]
    name_ptr = RT_NULL;
 801d0ac:	2300      	movs	r3, #0
 801d0ae:	617b      	str	r3, [r7, #20]

    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
 801d0b0:	4b92      	ldr	r3, [pc, #584]	; (801d2fc <list_prefix+0x264>)
 801d0b2:	681b      	ldr	r3, [r3, #0]
 801d0b4:	613b      	str	r3, [r7, #16]
 801d0b6:	e044      	b.n	801d142 <list_prefix+0xaa>
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
        {
			/* skip internal command */
			if (str_is_prefix("__", index->name) == 0) continue;
 801d0b8:	693b      	ldr	r3, [r7, #16]
 801d0ba:	681b      	ldr	r3, [r3, #0]
 801d0bc:	4890      	ldr	r0, [pc, #576]	; (801d300 <list_prefix+0x268>)
 801d0be:	4619      	mov	r1, r3
 801d0c0:	f7ff ffa0 	bl	801d004 <str_is_prefix>
 801d0c4:	4603      	mov	r3, r0
 801d0c6:	2b00      	cmp	r3, #0
 801d0c8:	d100      	bne.n	801d0cc <list_prefix+0x34>
 801d0ca:	e037      	b.n	801d13c <list_prefix+0xa4>
			
            if (str_is_prefix(prefix, index->name) == 0)
 801d0cc:	693b      	ldr	r3, [r7, #16]
 801d0ce:	681b      	ldr	r3, [r3, #0]
 801d0d0:	6878      	ldr	r0, [r7, #4]
 801d0d2:	4619      	mov	r1, r3
 801d0d4:	f7ff ff96 	bl	801d004 <str_is_prefix>
 801d0d8:	4603      	mov	r3, r0
 801d0da:	2b00      	cmp	r3, #0
 801d0dc:	d12e      	bne.n	801d13c <list_prefix+0xa4>
            {
                if (func_cnt == 0)
 801d0de:	8bfb      	ldrh	r3, [r7, #30]
 801d0e0:	2b00      	cmp	r3, #0
 801d0e2:	d10e      	bne.n	801d102 <list_prefix+0x6a>
                {
                    rt_kprintf("--function:\n");
 801d0e4:	4887      	ldr	r0, [pc, #540]	; (801d304 <list_prefix+0x26c>)
 801d0e6:	f7fa f813 	bl	8017110 <rt_kprintf>

                    if (*prefix != 0)
 801d0ea:	687b      	ldr	r3, [r7, #4]
 801d0ec:	781b      	ldrb	r3, [r3, #0]
 801d0ee:	2b00      	cmp	r3, #0
 801d0f0:	d007      	beq.n	801d102 <list_prefix+0x6a>
                    {
                        /* set name_ptr */
                        name_ptr = index->name;
 801d0f2:	693b      	ldr	r3, [r7, #16]
 801d0f4:	681b      	ldr	r3, [r3, #0]
 801d0f6:	617b      	str	r3, [r7, #20]

                        /* set initial length */
                        min_length = strlen(name_ptr);
 801d0f8:	6978      	ldr	r0, [r7, #20]
 801d0fa:	f005 ff51 	bl	8022fa0 <strlen>
 801d0fe:	4603      	mov	r3, r0
 801d100:	61bb      	str	r3, [r7, #24]
                    }
                }

                func_cnt ++;
 801d102:	8bfb      	ldrh	r3, [r7, #30]
 801d104:	3301      	adds	r3, #1
 801d106:	83fb      	strh	r3, [r7, #30]

                if (*prefix != 0)
 801d108:	687b      	ldr	r3, [r7, #4]
 801d10a:	781b      	ldrb	r3, [r3, #0]
 801d10c:	2b00      	cmp	r3, #0
 801d10e:	d00c      	beq.n	801d12a <list_prefix+0x92>
                {
                    length = str_common(name_ptr, index->name);
 801d110:	693b      	ldr	r3, [r7, #16]
 801d112:	681b      	ldr	r3, [r3, #0]
 801d114:	6978      	ldr	r0, [r7, #20]
 801d116:	4619      	mov	r1, r3
 801d118:	f7ff ff98 	bl	801d04c <str_common>
 801d11c:	60b8      	str	r0, [r7, #8]
                    if (length < min_length)
 801d11e:	68ba      	ldr	r2, [r7, #8]
 801d120:	69bb      	ldr	r3, [r7, #24]
 801d122:	429a      	cmp	r2, r3
 801d124:	da01      	bge.n	801d12a <list_prefix+0x92>
                        min_length = length;
 801d126:	68bb      	ldr	r3, [r7, #8]
 801d128:	61bb      	str	r3, [r7, #24]
                }

#ifdef FINSH_USING_DESCRIPTION
                rt_kprintf("%-16s -- %s\n", index->name, index->desc);
 801d12a:	693b      	ldr	r3, [r7, #16]
 801d12c:	681a      	ldr	r2, [r3, #0]
 801d12e:	693b      	ldr	r3, [r7, #16]
 801d130:	685b      	ldr	r3, [r3, #4]
 801d132:	4875      	ldr	r0, [pc, #468]	; (801d308 <list_prefix+0x270>)
 801d134:	4611      	mov	r1, r2
 801d136:	461a      	mov	r2, r3
 801d138:	f7f9 ffea 	bl	8017110 <rt_kprintf>
    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
 801d13c:	693b      	ldr	r3, [r7, #16]
 801d13e:	330c      	adds	r3, #12
 801d140:	613b      	str	r3, [r7, #16]

    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
 801d142:	4b72      	ldr	r3, [pc, #456]	; (801d30c <list_prefix+0x274>)
 801d144:	681b      	ldr	r3, [r3, #0]
    name_ptr = RT_NULL;

    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
 801d146:	693a      	ldr	r2, [r7, #16]
 801d148:	429a      	cmp	r2, r3
 801d14a:	d3b5      	bcc.n	801d0b8 <list_prefix+0x20>
            }
        }
    }

    /* checks in dynamic system function call */
    syscall_item = global_syscall_list;
 801d14c:	4b70      	ldr	r3, [pc, #448]	; (801d310 <list_prefix+0x278>)
 801d14e:	681b      	ldr	r3, [r3, #0]
 801d150:	627b      	str	r3, [r7, #36]	; 0x24
    while (syscall_item != NULL)
 801d152:	e03a      	b.n	801d1ca <list_prefix+0x132>
    {
        if (str_is_prefix(prefix, syscall_item->syscall.name) == 0)
 801d154:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d156:	685b      	ldr	r3, [r3, #4]
 801d158:	6878      	ldr	r0, [r7, #4]
 801d15a:	4619      	mov	r1, r3
 801d15c:	f7ff ff52 	bl	801d004 <str_is_prefix>
 801d160:	4603      	mov	r3, r0
 801d162:	2b00      	cmp	r3, #0
 801d164:	d12e      	bne.n	801d1c4 <list_prefix+0x12c>
        {
            if (func_cnt == 0)
 801d166:	8bfb      	ldrh	r3, [r7, #30]
 801d168:	2b00      	cmp	r3, #0
 801d16a:	d111      	bne.n	801d190 <list_prefix+0xf8>
            {
                rt_kprintf("--function:\n");
 801d16c:	4865      	ldr	r0, [pc, #404]	; (801d304 <list_prefix+0x26c>)
 801d16e:	f7f9 ffcf 	bl	8017110 <rt_kprintf>
                if (*prefix != 0 && name_ptr == NULL)
 801d172:	687b      	ldr	r3, [r7, #4]
 801d174:	781b      	ldrb	r3, [r3, #0]
 801d176:	2b00      	cmp	r3, #0
 801d178:	d00a      	beq.n	801d190 <list_prefix+0xf8>
 801d17a:	697b      	ldr	r3, [r7, #20]
 801d17c:	2b00      	cmp	r3, #0
 801d17e:	d107      	bne.n	801d190 <list_prefix+0xf8>
                {
                    /* set name_ptr */
                    name_ptr = syscall_item->syscall.name;
 801d180:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d182:	685b      	ldr	r3, [r3, #4]
 801d184:	617b      	str	r3, [r7, #20]

                    /* set initial length */
                    min_length = strlen(name_ptr);
 801d186:	6978      	ldr	r0, [r7, #20]
 801d188:	f005 ff0a 	bl	8022fa0 <strlen>
 801d18c:	4603      	mov	r3, r0
 801d18e:	61bb      	str	r3, [r7, #24]
                }
            }

            func_cnt ++;
 801d190:	8bfb      	ldrh	r3, [r7, #30]
 801d192:	3301      	adds	r3, #1
 801d194:	83fb      	strh	r3, [r7, #30]

            if (*prefix != 0)
 801d196:	687b      	ldr	r3, [r7, #4]
 801d198:	781b      	ldrb	r3, [r3, #0]
 801d19a:	2b00      	cmp	r3, #0
 801d19c:	d00c      	beq.n	801d1b8 <list_prefix+0x120>
            {
                length = str_common(name_ptr, syscall_item->syscall.name);
 801d19e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d1a0:	685b      	ldr	r3, [r3, #4]
 801d1a2:	6978      	ldr	r0, [r7, #20]
 801d1a4:	4619      	mov	r1, r3
 801d1a6:	f7ff ff51 	bl	801d04c <str_common>
 801d1aa:	60b8      	str	r0, [r7, #8]
                if (length < min_length)
 801d1ac:	68ba      	ldr	r2, [r7, #8]
 801d1ae:	69bb      	ldr	r3, [r7, #24]
 801d1b0:	429a      	cmp	r2, r3
 801d1b2:	da01      	bge.n	801d1b8 <list_prefix+0x120>
                    min_length = length;
 801d1b4:	68bb      	ldr	r3, [r7, #8]
 801d1b6:	61bb      	str	r3, [r7, #24]
            }

            rt_kprintf("[l] %s\n", syscall_item->syscall.name);
 801d1b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d1ba:	685b      	ldr	r3, [r3, #4]
 801d1bc:	4855      	ldr	r0, [pc, #340]	; (801d314 <list_prefix+0x27c>)
 801d1be:	4619      	mov	r1, r3
 801d1c0:	f7f9 ffa6 	bl	8017110 <rt_kprintf>
        }
        syscall_item = syscall_item->next;
 801d1c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d1c6:	681b      	ldr	r3, [r3, #0]
 801d1c8:	627b      	str	r3, [r7, #36]	; 0x24
        }
    }

    /* checks in dynamic system function call */
    syscall_item = global_syscall_list;
    while (syscall_item != NULL)
 801d1ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d1cc:	2b00      	cmp	r3, #0
 801d1ce:	d1c1      	bne.n	801d154 <list_prefix+0xbc>
    }

    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
 801d1d0:	4b51      	ldr	r3, [pc, #324]	; (801d318 <list_prefix+0x280>)
 801d1d2:	681b      	ldr	r3, [r3, #0]
 801d1d4:	60fb      	str	r3, [r7, #12]
 801d1d6:	e03d      	b.n	801d254 <list_prefix+0x1bc>
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
        {
            if (str_is_prefix(prefix, index->name) == 0)
 801d1d8:	68fb      	ldr	r3, [r7, #12]
 801d1da:	681b      	ldr	r3, [r3, #0]
 801d1dc:	6878      	ldr	r0, [r7, #4]
 801d1de:	4619      	mov	r1, r3
 801d1e0:	f7ff ff10 	bl	801d004 <str_is_prefix>
 801d1e4:	4603      	mov	r3, r0
 801d1e6:	2b00      	cmp	r3, #0
 801d1e8:	d131      	bne.n	801d24e <list_prefix+0x1b6>
            {
                if (var_cnt == 0)
 801d1ea:	8bbb      	ldrh	r3, [r7, #28]
 801d1ec:	2b00      	cmp	r3, #0
 801d1ee:	d111      	bne.n	801d214 <list_prefix+0x17c>
                {
                    rt_kprintf("--variable:\n");
 801d1f0:	484a      	ldr	r0, [pc, #296]	; (801d31c <list_prefix+0x284>)
 801d1f2:	f7f9 ff8d 	bl	8017110 <rt_kprintf>

                    if (*prefix != 0 && name_ptr == NULL)
 801d1f6:	687b      	ldr	r3, [r7, #4]
 801d1f8:	781b      	ldrb	r3, [r3, #0]
 801d1fa:	2b00      	cmp	r3, #0
 801d1fc:	d00a      	beq.n	801d214 <list_prefix+0x17c>
 801d1fe:	697b      	ldr	r3, [r7, #20]
 801d200:	2b00      	cmp	r3, #0
 801d202:	d107      	bne.n	801d214 <list_prefix+0x17c>
                    {
                        /* set name_ptr */
                        name_ptr = index->name;
 801d204:	68fb      	ldr	r3, [r7, #12]
 801d206:	681b      	ldr	r3, [r3, #0]
 801d208:	617b      	str	r3, [r7, #20]

                        /* set initial length */
                        min_length = strlen(name_ptr);
 801d20a:	6978      	ldr	r0, [r7, #20]
 801d20c:	f005 fec8 	bl	8022fa0 <strlen>
 801d210:	4603      	mov	r3, r0
 801d212:	61bb      	str	r3, [r7, #24]

                    }
                }

                var_cnt ++;
 801d214:	8bbb      	ldrh	r3, [r7, #28]
 801d216:	3301      	adds	r3, #1
 801d218:	83bb      	strh	r3, [r7, #28]

                if (*prefix != 0)
 801d21a:	687b      	ldr	r3, [r7, #4]
 801d21c:	781b      	ldrb	r3, [r3, #0]
 801d21e:	2b00      	cmp	r3, #0
 801d220:	d00c      	beq.n	801d23c <list_prefix+0x1a4>
                {
                    length = str_common(name_ptr, index->name);
 801d222:	68fb      	ldr	r3, [r7, #12]
 801d224:	681b      	ldr	r3, [r3, #0]
 801d226:	6978      	ldr	r0, [r7, #20]
 801d228:	4619      	mov	r1, r3
 801d22a:	f7ff ff0f 	bl	801d04c <str_common>
 801d22e:	60b8      	str	r0, [r7, #8]
                    if (length < min_length)
 801d230:	68ba      	ldr	r2, [r7, #8]
 801d232:	69bb      	ldr	r3, [r7, #24]
 801d234:	429a      	cmp	r2, r3
 801d236:	da01      	bge.n	801d23c <list_prefix+0x1a4>
                        min_length = length;
 801d238:	68bb      	ldr	r3, [r7, #8]
 801d23a:	61bb      	str	r3, [r7, #24]
                }

#ifdef FINSH_USING_DESCRIPTION
                rt_kprintf("%-16s -- %s\n", index->name, index->desc);
 801d23c:	68fb      	ldr	r3, [r7, #12]
 801d23e:	681a      	ldr	r2, [r3, #0]
 801d240:	68fb      	ldr	r3, [r7, #12]
 801d242:	685b      	ldr	r3, [r3, #4]
 801d244:	4830      	ldr	r0, [pc, #192]	; (801d308 <list_prefix+0x270>)
 801d246:	4611      	mov	r1, r2
 801d248:	461a      	mov	r2, r3
 801d24a:	f7f9 ff61 	bl	8017110 <rt_kprintf>
    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
 801d24e:	68fb      	ldr	r3, [r7, #12]
 801d250:	3310      	adds	r3, #16
 801d252:	60fb      	str	r3, [r7, #12]

    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
 801d254:	4b32      	ldr	r3, [pc, #200]	; (801d320 <list_prefix+0x288>)
 801d256:	681b      	ldr	r3, [r3, #0]
    }

    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
 801d258:	68fa      	ldr	r2, [r7, #12]
 801d25a:	429a      	cmp	r2, r3
 801d25c:	d3bc      	bcc.n	801d1d8 <list_prefix+0x140>
            }
        }
    }

    /* checks in dynamic system variable */
    sysvar_item = global_sysvar_list;
 801d25e:	4b31      	ldr	r3, [pc, #196]	; (801d324 <list_prefix+0x28c>)
 801d260:	681b      	ldr	r3, [r3, #0]
 801d262:	623b      	str	r3, [r7, #32]
    while (sysvar_item != NULL)
 801d264:	e03a      	b.n	801d2dc <list_prefix+0x244>
    {
        if (str_is_prefix(prefix, sysvar_item->sysvar.name) == 0)
 801d266:	6a3b      	ldr	r3, [r7, #32]
 801d268:	685b      	ldr	r3, [r3, #4]
 801d26a:	6878      	ldr	r0, [r7, #4]
 801d26c:	4619      	mov	r1, r3
 801d26e:	f7ff fec9 	bl	801d004 <str_is_prefix>
 801d272:	4603      	mov	r3, r0
 801d274:	2b00      	cmp	r3, #0
 801d276:	d12e      	bne.n	801d2d6 <list_prefix+0x23e>
        {
            if (var_cnt == 0)
 801d278:	8bbb      	ldrh	r3, [r7, #28]
 801d27a:	2b00      	cmp	r3, #0
 801d27c:	d111      	bne.n	801d2a2 <list_prefix+0x20a>
            {
                rt_kprintf("--variable:\n");
 801d27e:	4827      	ldr	r0, [pc, #156]	; (801d31c <list_prefix+0x284>)
 801d280:	f7f9 ff46 	bl	8017110 <rt_kprintf>
                if (*prefix != 0 && name_ptr == NULL)
 801d284:	687b      	ldr	r3, [r7, #4]
 801d286:	781b      	ldrb	r3, [r3, #0]
 801d288:	2b00      	cmp	r3, #0
 801d28a:	d00a      	beq.n	801d2a2 <list_prefix+0x20a>
 801d28c:	697b      	ldr	r3, [r7, #20]
 801d28e:	2b00      	cmp	r3, #0
 801d290:	d107      	bne.n	801d2a2 <list_prefix+0x20a>
                {
                    /* set name_ptr */
                    name_ptr = sysvar_item->sysvar.name;
 801d292:	6a3b      	ldr	r3, [r7, #32]
 801d294:	685b      	ldr	r3, [r3, #4]
 801d296:	617b      	str	r3, [r7, #20]

                    /* set initial length */
                    min_length = strlen(name_ptr);
 801d298:	6978      	ldr	r0, [r7, #20]
 801d29a:	f005 fe81 	bl	8022fa0 <strlen>
 801d29e:	4603      	mov	r3, r0
 801d2a0:	61bb      	str	r3, [r7, #24]
                }
            }

            var_cnt ++;
 801d2a2:	8bbb      	ldrh	r3, [r7, #28]
 801d2a4:	3301      	adds	r3, #1
 801d2a6:	83bb      	strh	r3, [r7, #28]

            if (*prefix != 0)
 801d2a8:	687b      	ldr	r3, [r7, #4]
 801d2aa:	781b      	ldrb	r3, [r3, #0]
 801d2ac:	2b00      	cmp	r3, #0
 801d2ae:	d00c      	beq.n	801d2ca <list_prefix+0x232>
            {
                length = str_common(name_ptr, sysvar_item->sysvar.name);
 801d2b0:	6a3b      	ldr	r3, [r7, #32]
 801d2b2:	685b      	ldr	r3, [r3, #4]
 801d2b4:	6978      	ldr	r0, [r7, #20]
 801d2b6:	4619      	mov	r1, r3
 801d2b8:	f7ff fec8 	bl	801d04c <str_common>
 801d2bc:	60b8      	str	r0, [r7, #8]
                if (length < min_length)
 801d2be:	68ba      	ldr	r2, [r7, #8]
 801d2c0:	69bb      	ldr	r3, [r7, #24]
 801d2c2:	429a      	cmp	r2, r3
 801d2c4:	da01      	bge.n	801d2ca <list_prefix+0x232>
                    min_length = length;
 801d2c6:	68bb      	ldr	r3, [r7, #8]
 801d2c8:	61bb      	str	r3, [r7, #24]
            }

            rt_kprintf("[v] %s\n", sysvar_item->sysvar.name);
 801d2ca:	6a3b      	ldr	r3, [r7, #32]
 801d2cc:	685b      	ldr	r3, [r3, #4]
 801d2ce:	4816      	ldr	r0, [pc, #88]	; (801d328 <list_prefix+0x290>)
 801d2d0:	4619      	mov	r1, r3
 801d2d2:	f7f9 ff1d 	bl	8017110 <rt_kprintf>
        }
        sysvar_item = sysvar_item->next;
 801d2d6:	6a3b      	ldr	r3, [r7, #32]
 801d2d8:	681b      	ldr	r3, [r3, #0]
 801d2da:	623b      	str	r3, [r7, #32]
        }
    }

    /* checks in dynamic system variable */
    sysvar_item = global_sysvar_list;
    while (sysvar_item != NULL)
 801d2dc:	6a3b      	ldr	r3, [r7, #32]
 801d2de:	2b00      	cmp	r3, #0
 801d2e0:	d1c1      	bne.n	801d266 <list_prefix+0x1ce>
        }
        sysvar_item = sysvar_item->next;
    }

    /* only one matched */
    if (name_ptr != NULL)
 801d2e2:	697b      	ldr	r3, [r7, #20]
 801d2e4:	2b00      	cmp	r3, #0
 801d2e6:	d005      	beq.n	801d2f4 <list_prefix+0x25c>
    {
        rt_strncpy(prefix, name_ptr, min_length);
 801d2e8:	69bb      	ldr	r3, [r7, #24]
 801d2ea:	6878      	ldr	r0, [r7, #4]
 801d2ec:	6979      	ldr	r1, [r7, #20]
 801d2ee:	461a      	mov	r2, r3
 801d2f0:	f7f9 fa5e 	bl	80167b0 <rt_strncpy>
    }
}
 801d2f4:	3728      	adds	r7, #40	; 0x28
 801d2f6:	46bd      	mov	sp, r7
 801d2f8:	bd80      	pop	{r7, pc}
 801d2fa:	bf00      	nop
 801d2fc:	200121b0 	.word	0x200121b0
 801d300:	0802a314 	.word	0x0802a314
 801d304:	0802a344 	.word	0x0802a344
 801d308:	0802a318 	.word	0x0802a318
 801d30c:	200121b4 	.word	0x200121b4
 801d310:	200121cc 	.word	0x200121cc
 801d314:	0802a328 	.word	0x0802a328
 801d318:	200121b8 	.word	0x200121b8
 801d31c:	0802a354 	.word	0x0802a354
 801d320:	200121bc 	.word	0x200121bc
 801d324:	20012da8 	.word	0x20012da8
 801d328:	0802a364 	.word	0x0802a364

0801d32c <cmd_ps>:
FINSH_FUNCTION_EXPORT_ALIAS(cmd_netstat, __cmd_netstat, list the information of TCP/IP);
#endif
#endif /* RT_USING_LWIP */

int cmd_ps(int argc, char** argv)
{
 801d32c:	b580      	push	{r7, lr}
 801d32e:	b082      	sub	sp, #8
 801d330:	af00      	add	r7, sp, #0
 801d332:	6078      	str	r0, [r7, #4]
 801d334:	6039      	str	r1, [r7, #0]
    extern long list_thread(void);

    list_thread();
 801d336:	f7ff faab 	bl	801c890 <list_thread>
    return 0;
 801d33a:	2300      	movs	r3, #0
}
 801d33c:	4618      	mov	r0, r3
 801d33e:	3708      	adds	r7, #8
 801d340:	46bd      	mov	sp, r7
 801d342:	bd80      	pop	{r7, pc}

0801d344 <cmd_time>:
FINSH_FUNCTION_EXPORT_ALIAS(cmd_ps, __cmd_ps, List threads in the system.);

int cmd_time(int argc, char** argv)
{
 801d344:	b480      	push	{r7}
 801d346:	b083      	sub	sp, #12
 801d348:	af00      	add	r7, sp, #0
 801d34a:	6078      	str	r0, [r7, #4]
 801d34c:	6039      	str	r1, [r7, #0]
    return 0;
 801d34e:	2300      	movs	r3, #0
}
 801d350:	4618      	mov	r0, r3
 801d352:	370c      	adds	r7, #12
 801d354:	46bd      	mov	sp, r7
 801d356:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d35a:	4770      	bx	lr

0801d35c <cmd_free>:
FINSH_FUNCTION_EXPORT_ALIAS(cmd_time, __cmd_time, Execute command with time.);

#ifdef RT_USING_HEAP
int cmd_free(int argc, char** argv)
{
 801d35c:	b580      	push	{r7, lr}
 801d35e:	b082      	sub	sp, #8
 801d360:	af00      	add	r7, sp, #0
 801d362:	6078      	str	r0, [r7, #4]
 801d364:	6039      	str	r1, [r7, #0]
    extern void list_memheap(void);

#ifdef RT_USING_MEMHEAP_AS_HEAP
    list_memheap();
#else
    list_mem();
 801d366:	f7fa fb6b 	bl	8017a40 <list_mem>
#endif
    return 0;
 801d36a:	2300      	movs	r3, #0
}
 801d36c:	4618      	mov	r0, r3
 801d36e:	3708      	adds	r7, #8
 801d370:	46bd      	mov	sp, r7
 801d372:	bd80      	pop	{r7, pc}

0801d374 <msh_is_used>:
static rt_bool_t __msh_state = RT_TRUE;
#else
static rt_bool_t __msh_state = RT_FALSE;
#endif
rt_bool_t msh_is_used(void)
{
 801d374:	b480      	push	{r7}
 801d376:	af00      	add	r7, sp, #0
    return __msh_state;
 801d378:	4b03      	ldr	r3, [pc, #12]	; (801d388 <msh_is_used+0x14>)
 801d37a:	681b      	ldr	r3, [r3, #0]
}
 801d37c:	4618      	mov	r0, r3
 801d37e:	46bd      	mov	sp, r7
 801d380:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d384:	4770      	bx	lr
 801d386:	bf00      	nop
 801d388:	200100cc 	.word	0x200100cc

0801d38c <msh_exit>:

static int msh_exit(int argc, char** argv)
{
 801d38c:	b480      	push	{r7}
 801d38e:	b083      	sub	sp, #12
 801d390:	af00      	add	r7, sp, #0
 801d392:	6078      	str	r0, [r7, #4]
 801d394:	6039      	str	r1, [r7, #0]
    /* return to finsh shell mode */
    __msh_state = RT_FALSE;
 801d396:	4b05      	ldr	r3, [pc, #20]	; (801d3ac <msh_exit+0x20>)
 801d398:	2200      	movs	r2, #0
 801d39a:	601a      	str	r2, [r3, #0]

    return 0;
 801d39c:	2300      	movs	r3, #0
}
 801d39e:	4618      	mov	r0, r3
 801d3a0:	370c      	adds	r7, #12
 801d3a2:	46bd      	mov	sp, r7
 801d3a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d3a8:	4770      	bx	lr
 801d3aa:	bf00      	nop
 801d3ac:	200100cc 	.word	0x200100cc

0801d3b0 <msh_enter>:
FINSH_FUNCTION_EXPORT_ALIAS(msh_exit, __cmd_exit, return to RT-Thread shell mode.);

static int msh_enter(void)
{
 801d3b0:	b480      	push	{r7}
 801d3b2:	af00      	add	r7, sp, #0
    /* enter module shell mode */
    __msh_state = RT_TRUE;
 801d3b4:	4b04      	ldr	r3, [pc, #16]	; (801d3c8 <msh_enter+0x18>)
 801d3b6:	2201      	movs	r2, #1
 801d3b8:	601a      	str	r2, [r3, #0]
    return 0;
 801d3ba:	2300      	movs	r3, #0
}
 801d3bc:	4618      	mov	r0, r3
 801d3be:	46bd      	mov	sp, r7
 801d3c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d3c4:	4770      	bx	lr
 801d3c6:	bf00      	nop
 801d3c8:	200100cc 	.word	0x200100cc

0801d3cc <msh_help>:
FINSH_FUNCTION_EXPORT_ALIAS(msh_enter, msh, use module shell);
#endif

int msh_help(int argc, char** argv)
{
 801d3cc:	b580      	push	{r7, lr}
 801d3ce:	b084      	sub	sp, #16
 801d3d0:	af00      	add	r7, sp, #0
 801d3d2:	6078      	str	r0, [r7, #4]
 801d3d4:	6039      	str	r1, [r7, #0]
    rt_kprintf("RT-Thread shell commands:\n");
 801d3d6:	4816      	ldr	r0, [pc, #88]	; (801d430 <msh_help+0x64>)
 801d3d8:	f7f9 fe9a 	bl	8017110 <rt_kprintf>
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
 801d3dc:	4b15      	ldr	r3, [pc, #84]	; (801d434 <msh_help+0x68>)
 801d3de:	681b      	ldr	r3, [r3, #0]
 801d3e0:	60fb      	str	r3, [r7, #12]
 801d3e2:	e017      	b.n	801d414 <msh_help+0x48>
            index < _syscall_table_end;
            FINSH_NEXT_SYSCALL(index))
        {
            if (strncmp(index->name, "__cmd_", 6) != 0) continue;
 801d3e4:	68fb      	ldr	r3, [r7, #12]
 801d3e6:	681b      	ldr	r3, [r3, #0]
 801d3e8:	4618      	mov	r0, r3
 801d3ea:	4913      	ldr	r1, [pc, #76]	; (801d438 <msh_help+0x6c>)
 801d3ec:	2206      	movs	r2, #6
 801d3ee:	f005 fe05 	bl	8022ffc <strncmp>
 801d3f2:	4603      	mov	r3, r0
 801d3f4:	2b00      	cmp	r3, #0
 801d3f6:	d000      	beq.n	801d3fa <msh_help+0x2e>
 801d3f8:	e009      	b.n	801d40e <msh_help+0x42>
#if defined(FINSH_USING_DESCRIPTION) && defined(FINSH_USING_SYMTAB)
            rt_kprintf("%-16s - %s\n", &index->name[6], index->desc);
 801d3fa:	68fb      	ldr	r3, [r7, #12]
 801d3fc:	681b      	ldr	r3, [r3, #0]
 801d3fe:	1d9a      	adds	r2, r3, #6
 801d400:	68fb      	ldr	r3, [r7, #12]
 801d402:	685b      	ldr	r3, [r3, #4]
 801d404:	480d      	ldr	r0, [pc, #52]	; (801d43c <msh_help+0x70>)
 801d406:	4611      	mov	r1, r2
 801d408:	461a      	mov	r2, r3
 801d40a:	f7f9 fe81 	bl	8017110 <rt_kprintf>
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
            index < _syscall_table_end;
            FINSH_NEXT_SYSCALL(index))
 801d40e:	68fb      	ldr	r3, [r7, #12]
 801d410:	330c      	adds	r3, #12
 801d412:	60fb      	str	r3, [r7, #12]
    rt_kprintf("RT-Thread shell commands:\n");
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
            index < _syscall_table_end;
 801d414:	4b0a      	ldr	r3, [pc, #40]	; (801d440 <msh_help+0x74>)
 801d416:	681b      	ldr	r3, [r3, #0]
{
    rt_kprintf("RT-Thread shell commands:\n");
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
 801d418:	68fa      	ldr	r2, [r7, #12]
 801d41a:	429a      	cmp	r2, r3
 801d41c:	d3e2      	bcc.n	801d3e4 <msh_help+0x18>
#else
            rt_kprintf("%s ", &index->name[6]);
#endif
        }
    }
    rt_kprintf("\n");
 801d41e:	4809      	ldr	r0, [pc, #36]	; (801d444 <msh_help+0x78>)
 801d420:	f7f9 fe76 	bl	8017110 <rt_kprintf>

    return 0;
 801d424:	2300      	movs	r3, #0
}
 801d426:	4618      	mov	r0, r3
 801d428:	3710      	adds	r7, #16
 801d42a:	46bd      	mov	sp, r7
 801d42c:	bd80      	pop	{r7, pc}
 801d42e:	bf00      	nop
 801d430:	0802a36c 	.word	0x0802a36c
 801d434:	200121b0 	.word	0x200121b0
 801d438:	0802a388 	.word	0x0802a388
 801d43c:	0802a390 	.word	0x0802a390
 801d440:	200121b4 	.word	0x200121b4
 801d444:	0802a39c 	.word	0x0802a39c

0801d448 <msh_split>:
FINSH_FUNCTION_EXPORT_ALIAS(msh_help, __cmd_help, RT-Thread shell help.);

static int msh_split(char* cmd, rt_size_t length, char* argv[RT_FINSH_ARG_MAX])
{
 801d448:	b480      	push	{r7}
 801d44a:	b089      	sub	sp, #36	; 0x24
 801d44c:	af00      	add	r7, sp, #0
 801d44e:	60f8      	str	r0, [r7, #12]
 801d450:	60b9      	str	r1, [r7, #8]
 801d452:	607a      	str	r2, [r7, #4]
    char *ptr;
    rt_size_t position;
    rt_size_t argc;

    ptr = cmd;
 801d454:	68fb      	ldr	r3, [r7, #12]
 801d456:	61fb      	str	r3, [r7, #28]
    position = 0; argc = 0;
 801d458:	2300      	movs	r3, #0
 801d45a:	61bb      	str	r3, [r7, #24]
 801d45c:	2300      	movs	r3, #0
 801d45e:	617b      	str	r3, [r7, #20]

    while (position < length)
 801d460:	e07b      	b.n	801d55a <msh_split+0x112>
    {
        /* strip bank and tab */
        while ((*ptr == ' ' || *ptr == '\t') && position < length)
 801d462:	e008      	b.n	801d476 <msh_split+0x2e>
        {
            *ptr = '\0';
 801d464:	69fb      	ldr	r3, [r7, #28]
 801d466:	2200      	movs	r2, #0
 801d468:	701a      	strb	r2, [r3, #0]
            ptr ++; position ++;
 801d46a:	69fb      	ldr	r3, [r7, #28]
 801d46c:	3301      	adds	r3, #1
 801d46e:	61fb      	str	r3, [r7, #28]
 801d470:	69bb      	ldr	r3, [r7, #24]
 801d472:	3301      	adds	r3, #1
 801d474:	61bb      	str	r3, [r7, #24]
    position = 0; argc = 0;

    while (position < length)
    {
        /* strip bank and tab */
        while ((*ptr == ' ' || *ptr == '\t') && position < length)
 801d476:	69fb      	ldr	r3, [r7, #28]
 801d478:	781b      	ldrb	r3, [r3, #0]
 801d47a:	2b20      	cmp	r3, #32
 801d47c:	d003      	beq.n	801d486 <msh_split+0x3e>
 801d47e:	69fb      	ldr	r3, [r7, #28]
 801d480:	781b      	ldrb	r3, [r3, #0]
 801d482:	2b09      	cmp	r3, #9
 801d484:	d103      	bne.n	801d48e <msh_split+0x46>
 801d486:	69ba      	ldr	r2, [r7, #24]
 801d488:	68bb      	ldr	r3, [r7, #8]
 801d48a:	429a      	cmp	r2, r3
 801d48c:	d3ea      	bcc.n	801d464 <msh_split+0x1c>
        {
            *ptr = '\0';
            ptr ++; position ++;
        }
        if (position >= length) break;
 801d48e:	69ba      	ldr	r2, [r7, #24]
 801d490:	68bb      	ldr	r3, [r7, #8]
 801d492:	429a      	cmp	r2, r3
 801d494:	d300      	bcc.n	801d498 <msh_split+0x50>
 801d496:	e065      	b.n	801d564 <msh_split+0x11c>

        /* handle string */
        if (*ptr == '"')
 801d498:	69fb      	ldr	r3, [r7, #28]
 801d49a:	781b      	ldrb	r3, [r3, #0]
 801d49c:	2b22      	cmp	r3, #34	; 0x22
 801d49e:	d13b      	bne.n	801d518 <msh_split+0xd0>
        {
            ptr ++; position ++;
 801d4a0:	69fb      	ldr	r3, [r7, #28]
 801d4a2:	3301      	adds	r3, #1
 801d4a4:	61fb      	str	r3, [r7, #28]
 801d4a6:	69bb      	ldr	r3, [r7, #24]
 801d4a8:	3301      	adds	r3, #1
 801d4aa:	61bb      	str	r3, [r7, #24]
            argv[argc] = ptr; argc ++;
 801d4ac:	697b      	ldr	r3, [r7, #20]
 801d4ae:	009b      	lsls	r3, r3, #2
 801d4b0:	687a      	ldr	r2, [r7, #4]
 801d4b2:	4413      	add	r3, r2
 801d4b4:	69fa      	ldr	r2, [r7, #28]
 801d4b6:	601a      	str	r2, [r3, #0]
 801d4b8:	697b      	ldr	r3, [r7, #20]
 801d4ba:	3301      	adds	r3, #1
 801d4bc:	617b      	str	r3, [r7, #20]

            /* skip this string */
            while (*ptr != '"' && position < length)
 801d4be:	e014      	b.n	801d4ea <msh_split+0xa2>
            {
                if (*ptr == '\\')
 801d4c0:	69fb      	ldr	r3, [r7, #28]
 801d4c2:	781b      	ldrb	r3, [r3, #0]
 801d4c4:	2b5c      	cmp	r3, #92	; 0x5c
 801d4c6:	d10a      	bne.n	801d4de <msh_split+0x96>
                {
                    if (*(ptr + 1) == '"')
 801d4c8:	69fb      	ldr	r3, [r7, #28]
 801d4ca:	3301      	adds	r3, #1
 801d4cc:	781b      	ldrb	r3, [r3, #0]
 801d4ce:	2b22      	cmp	r3, #34	; 0x22
 801d4d0:	d105      	bne.n	801d4de <msh_split+0x96>
                    {
                        ptr ++; position ++;
 801d4d2:	69fb      	ldr	r3, [r7, #28]
 801d4d4:	3301      	adds	r3, #1
 801d4d6:	61fb      	str	r3, [r7, #28]
 801d4d8:	69bb      	ldr	r3, [r7, #24]
 801d4da:	3301      	adds	r3, #1
 801d4dc:	61bb      	str	r3, [r7, #24]
                    }
                }
                ptr ++; position ++;
 801d4de:	69fb      	ldr	r3, [r7, #28]
 801d4e0:	3301      	adds	r3, #1
 801d4e2:	61fb      	str	r3, [r7, #28]
 801d4e4:	69bb      	ldr	r3, [r7, #24]
 801d4e6:	3301      	adds	r3, #1
 801d4e8:	61bb      	str	r3, [r7, #24]
        {
            ptr ++; position ++;
            argv[argc] = ptr; argc ++;

            /* skip this string */
            while (*ptr != '"' && position < length)
 801d4ea:	69fb      	ldr	r3, [r7, #28]
 801d4ec:	781b      	ldrb	r3, [r3, #0]
 801d4ee:	2b22      	cmp	r3, #34	; 0x22
 801d4f0:	d003      	beq.n	801d4fa <msh_split+0xb2>
 801d4f2:	69ba      	ldr	r2, [r7, #24]
 801d4f4:	68bb      	ldr	r3, [r7, #8]
 801d4f6:	429a      	cmp	r2, r3
 801d4f8:	d3e2      	bcc.n	801d4c0 <msh_split+0x78>
                        ptr ++; position ++;
                    }
                }
                ptr ++; position ++;
            }
            if (position >= length) break;
 801d4fa:	69ba      	ldr	r2, [r7, #24]
 801d4fc:	68bb      	ldr	r3, [r7, #8]
 801d4fe:	429a      	cmp	r2, r3
 801d500:	d300      	bcc.n	801d504 <msh_split+0xbc>
 801d502:	e02f      	b.n	801d564 <msh_split+0x11c>

            /* skip '"' */
            *ptr = '\0'; ptr ++; position ++;
 801d504:	69fb      	ldr	r3, [r7, #28]
 801d506:	2200      	movs	r2, #0
 801d508:	701a      	strb	r2, [r3, #0]
 801d50a:	69fb      	ldr	r3, [r7, #28]
 801d50c:	3301      	adds	r3, #1
 801d50e:	61fb      	str	r3, [r7, #28]
 801d510:	69bb      	ldr	r3, [r7, #24]
 801d512:	3301      	adds	r3, #1
 801d514:	61bb      	str	r3, [r7, #24]
 801d516:	e020      	b.n	801d55a <msh_split+0x112>
        }
        else
        {
            argv[argc] = ptr;
 801d518:	697b      	ldr	r3, [r7, #20]
 801d51a:	009b      	lsls	r3, r3, #2
 801d51c:	687a      	ldr	r2, [r7, #4]
 801d51e:	4413      	add	r3, r2
 801d520:	69fa      	ldr	r2, [r7, #28]
 801d522:	601a      	str	r2, [r3, #0]
            argc ++;
 801d524:	697b      	ldr	r3, [r7, #20]
 801d526:	3301      	adds	r3, #1
 801d528:	617b      	str	r3, [r7, #20]
            while ((*ptr != ' ' && *ptr != '\t') && position < length)
 801d52a:	e005      	b.n	801d538 <msh_split+0xf0>
            {
                ptr ++; position ++;
 801d52c:	69fb      	ldr	r3, [r7, #28]
 801d52e:	3301      	adds	r3, #1
 801d530:	61fb      	str	r3, [r7, #28]
 801d532:	69bb      	ldr	r3, [r7, #24]
 801d534:	3301      	adds	r3, #1
 801d536:	61bb      	str	r3, [r7, #24]
        }
        else
        {
            argv[argc] = ptr;
            argc ++;
            while ((*ptr != ' ' && *ptr != '\t') && position < length)
 801d538:	69fb      	ldr	r3, [r7, #28]
 801d53a:	781b      	ldrb	r3, [r3, #0]
 801d53c:	2b20      	cmp	r3, #32
 801d53e:	d007      	beq.n	801d550 <msh_split+0x108>
 801d540:	69fb      	ldr	r3, [r7, #28]
 801d542:	781b      	ldrb	r3, [r3, #0]
 801d544:	2b09      	cmp	r3, #9
 801d546:	d003      	beq.n	801d550 <msh_split+0x108>
 801d548:	69ba      	ldr	r2, [r7, #24]
 801d54a:	68bb      	ldr	r3, [r7, #8]
 801d54c:	429a      	cmp	r2, r3
 801d54e:	d3ed      	bcc.n	801d52c <msh_split+0xe4>
            {
                ptr ++; position ++;
            }
            if (position >= length) break;
 801d550:	69ba      	ldr	r2, [r7, #24]
 801d552:	68bb      	ldr	r3, [r7, #8]
 801d554:	429a      	cmp	r2, r3
 801d556:	d300      	bcc.n	801d55a <msh_split+0x112>
 801d558:	e004      	b.n	801d564 <msh_split+0x11c>
    rt_size_t argc;

    ptr = cmd;
    position = 0; argc = 0;

    while (position < length)
 801d55a:	69ba      	ldr	r2, [r7, #24]
 801d55c:	68bb      	ldr	r3, [r7, #8]
 801d55e:	429a      	cmp	r2, r3
 801d560:	f4ff af7f 	bcc.w	801d462 <msh_split+0x1a>
            }
            if (position >= length) break;
        }
    }

    return argc;
 801d564:	697b      	ldr	r3, [r7, #20]
}
 801d566:	4618      	mov	r0, r3
 801d568:	3724      	adds	r7, #36	; 0x24
 801d56a:	46bd      	mov	sp, r7
 801d56c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d570:	4770      	bx	lr
 801d572:	bf00      	nop

0801d574 <msh_get_cmd>:

static cmd_function_t msh_get_cmd(char *cmd, int size)
{
 801d574:	b580      	push	{r7, lr}
 801d576:	b084      	sub	sp, #16
 801d578:	af00      	add	r7, sp, #0
 801d57a:	6078      	str	r0, [r7, #4]
 801d57c:	6039      	str	r1, [r7, #0]
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;
 801d57e:	2300      	movs	r3, #0
 801d580:	60bb      	str	r3, [r7, #8]

    for (index = _syscall_table_begin;
 801d582:	4b1a      	ldr	r3, [pc, #104]	; (801d5ec <msh_get_cmd+0x78>)
 801d584:	681b      	ldr	r3, [r3, #0]
 801d586:	60fb      	str	r3, [r7, #12]
 801d588:	e025      	b.n	801d5d6 <msh_get_cmd+0x62>
        index < _syscall_table_end;
        FINSH_NEXT_SYSCALL(index))
    {
        if (strncmp(index->name, "__cmd_", 6) != 0) continue;
 801d58a:	68fb      	ldr	r3, [r7, #12]
 801d58c:	681b      	ldr	r3, [r3, #0]
 801d58e:	4618      	mov	r0, r3
 801d590:	4917      	ldr	r1, [pc, #92]	; (801d5f0 <msh_get_cmd+0x7c>)
 801d592:	2206      	movs	r2, #6
 801d594:	f005 fd32 	bl	8022ffc <strncmp>
 801d598:	4603      	mov	r3, r0
 801d59a:	2b00      	cmp	r3, #0
 801d59c:	d000      	beq.n	801d5a0 <msh_get_cmd+0x2c>
 801d59e:	e017      	b.n	801d5d0 <msh_get_cmd+0x5c>
        
        if (strncmp(&index->name[6], cmd, size) == 0 &&
 801d5a0:	68fb      	ldr	r3, [r7, #12]
 801d5a2:	681b      	ldr	r3, [r3, #0]
 801d5a4:	1d9a      	adds	r2, r3, #6
 801d5a6:	683b      	ldr	r3, [r7, #0]
 801d5a8:	4610      	mov	r0, r2
 801d5aa:	6879      	ldr	r1, [r7, #4]
 801d5ac:	461a      	mov	r2, r3
 801d5ae:	f005 fd25 	bl	8022ffc <strncmp>
 801d5b2:	4603      	mov	r3, r0
 801d5b4:	2b00      	cmp	r3, #0
 801d5b6:	d10b      	bne.n	801d5d0 <msh_get_cmd+0x5c>
			index->name[6 + size] == '\0')
 801d5b8:	68fb      	ldr	r3, [r7, #12]
 801d5ba:	681b      	ldr	r3, [r3, #0]
 801d5bc:	683a      	ldr	r2, [r7, #0]
 801d5be:	3206      	adds	r2, #6
 801d5c0:	4413      	add	r3, r2
 801d5c2:	781b      	ldrb	r3, [r3, #0]
        index < _syscall_table_end;
        FINSH_NEXT_SYSCALL(index))
    {
        if (strncmp(index->name, "__cmd_", 6) != 0) continue;
        
        if (strncmp(&index->name[6], cmd, size) == 0 &&
 801d5c4:	2b00      	cmp	r3, #0
 801d5c6:	d103      	bne.n	801d5d0 <msh_get_cmd+0x5c>
			index->name[6 + size] == '\0')
        {
            cmd_func = (cmd_function_t)index->func;
 801d5c8:	68fb      	ldr	r3, [r7, #12]
 801d5ca:	689b      	ldr	r3, [r3, #8]
 801d5cc:	60bb      	str	r3, [r7, #8]
            break;
 801d5ce:	e007      	b.n	801d5e0 <msh_get_cmd+0x6c>
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;

    for (index = _syscall_table_begin;
        index < _syscall_table_end;
        FINSH_NEXT_SYSCALL(index))
 801d5d0:	68fb      	ldr	r3, [r7, #12]
 801d5d2:	330c      	adds	r3, #12
 801d5d4:	60fb      	str	r3, [r7, #12]
{
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;

    for (index = _syscall_table_begin;
        index < _syscall_table_end;
 801d5d6:	4b07      	ldr	r3, [pc, #28]	; (801d5f4 <msh_get_cmd+0x80>)
 801d5d8:	681b      	ldr	r3, [r3, #0]
static cmd_function_t msh_get_cmd(char *cmd, int size)
{
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;

    for (index = _syscall_table_begin;
 801d5da:	68fa      	ldr	r2, [r7, #12]
 801d5dc:	429a      	cmp	r2, r3
 801d5de:	d3d4      	bcc.n	801d58a <msh_get_cmd+0x16>
            cmd_func = (cmd_function_t)index->func;
            break;
        }
    }

    return cmd_func;
 801d5e0:	68bb      	ldr	r3, [r7, #8]
}
 801d5e2:	4618      	mov	r0, r3
 801d5e4:	3710      	adds	r7, #16
 801d5e6:	46bd      	mov	sp, r7
 801d5e8:	bd80      	pop	{r7, pc}
 801d5ea:	bf00      	nop
 801d5ec:	200121b0 	.word	0x200121b0
 801d5f0:	0802a388 	.word	0x0802a388
 801d5f4:	200121b4 	.word	0x200121b4

0801d5f8 <_msh_exec_cmd>:
}
RTM_EXPORT(system);
#endif

static int _msh_exec_cmd(char* cmd, rt_size_t length, int *retp)
{
 801d5f8:	b580      	push	{r7, lr}
 801d5fa:	b092      	sub	sp, #72	; 0x48
 801d5fc:	af00      	add	r7, sp, #0
 801d5fe:	60f8      	str	r0, [r7, #12]
 801d600:	60b9      	str	r1, [r7, #8]
 801d602:	607a      	str	r2, [r7, #4]
    int argc;
    int cmd0_size = 0;
 801d604:	2300      	movs	r3, #0
 801d606:	647b      	str	r3, [r7, #68]	; 0x44
    cmd_function_t cmd_func;
    char *argv[RT_FINSH_ARG_MAX];

    RT_ASSERT(cmd);
 801d608:	68fb      	ldr	r3, [r7, #12]
 801d60a:	2b00      	cmp	r3, #0
 801d60c:	d105      	bne.n	801d61a <_msh_exec_cmd+0x22>
 801d60e:	482b      	ldr	r0, [pc, #172]	; (801d6bc <_msh_exec_cmd+0xc4>)
 801d610:	492b      	ldr	r1, [pc, #172]	; (801d6c0 <_msh_exec_cmd+0xc8>)
 801d612:	f44f 7285 	mov.w	r2, #266	; 0x10a
 801d616:	f7f9 fdf5 	bl	8017204 <rt_assert_handler>
    RT_ASSERT(retp);
 801d61a:	687b      	ldr	r3, [r7, #4]
 801d61c:	2b00      	cmp	r3, #0
 801d61e:	d105      	bne.n	801d62c <_msh_exec_cmd+0x34>
 801d620:	4828      	ldr	r0, [pc, #160]	; (801d6c4 <_msh_exec_cmd+0xcc>)
 801d622:	4927      	ldr	r1, [pc, #156]	; (801d6c0 <_msh_exec_cmd+0xc8>)
 801d624:	f240 120b 	movw	r2, #267	; 0x10b
 801d628:	f7f9 fdec 	bl	8017204 <rt_assert_handler>

    /* find the size of first command */
    while ((cmd[cmd0_size] != ' ' && cmd[cmd0_size] != '\t') && cmd0_size < length)
 801d62c:	e002      	b.n	801d634 <_msh_exec_cmd+0x3c>
        cmd0_size ++;
 801d62e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d630:	3301      	adds	r3, #1
 801d632:	647b      	str	r3, [r7, #68]	; 0x44

    RT_ASSERT(cmd);
    RT_ASSERT(retp);

    /* find the size of first command */
    while ((cmd[cmd0_size] != ' ' && cmd[cmd0_size] != '\t') && cmd0_size < length)
 801d634:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d636:	68fa      	ldr	r2, [r7, #12]
 801d638:	4413      	add	r3, r2
 801d63a:	781b      	ldrb	r3, [r3, #0]
 801d63c:	2b20      	cmp	r3, #32
 801d63e:	d009      	beq.n	801d654 <_msh_exec_cmd+0x5c>
 801d640:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d642:	68fa      	ldr	r2, [r7, #12]
 801d644:	4413      	add	r3, r2
 801d646:	781b      	ldrb	r3, [r3, #0]
 801d648:	2b09      	cmp	r3, #9
 801d64a:	d003      	beq.n	801d654 <_msh_exec_cmd+0x5c>
 801d64c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801d64e:	68bb      	ldr	r3, [r7, #8]
 801d650:	429a      	cmp	r2, r3
 801d652:	d3ec      	bcc.n	801d62e <_msh_exec_cmd+0x36>
        cmd0_size ++;
    if (cmd0_size == 0)
 801d654:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d656:	2b00      	cmp	r3, #0
 801d658:	d102      	bne.n	801d660 <_msh_exec_cmd+0x68>
        return -RT_ERROR;
 801d65a:	f04f 33ff 	mov.w	r3, #4294967295
 801d65e:	e029      	b.n	801d6b4 <_msh_exec_cmd+0xbc>

    cmd_func = msh_get_cmd(cmd, cmd0_size);
 801d660:	68f8      	ldr	r0, [r7, #12]
 801d662:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801d664:	f7ff ff86 	bl	801d574 <msh_get_cmd>
 801d668:	6438      	str	r0, [r7, #64]	; 0x40
    if (cmd_func == RT_NULL)
 801d66a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d66c:	2b00      	cmp	r3, #0
 801d66e:	d102      	bne.n	801d676 <_msh_exec_cmd+0x7e>
        return -RT_ERROR;
 801d670:	f04f 33ff 	mov.w	r3, #4294967295
 801d674:	e01e      	b.n	801d6b4 <_msh_exec_cmd+0xbc>

    /* split arguments */
    memset(argv, 0x00, sizeof(argv));
 801d676:	f107 0314 	add.w	r3, r7, #20
 801d67a:	4618      	mov	r0, r3
 801d67c:	2100      	movs	r1, #0
 801d67e:	2228      	movs	r2, #40	; 0x28
 801d680:	f004 fffc 	bl	802267c <memset>
    argc = msh_split(cmd, length, argv);
 801d684:	f107 0314 	add.w	r3, r7, #20
 801d688:	68f8      	ldr	r0, [r7, #12]
 801d68a:	68b9      	ldr	r1, [r7, #8]
 801d68c:	461a      	mov	r2, r3
 801d68e:	f7ff fedb 	bl	801d448 <msh_split>
 801d692:	63f8      	str	r0, [r7, #60]	; 0x3c
    if (argc == 0)
 801d694:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801d696:	2b00      	cmp	r3, #0
 801d698:	d102      	bne.n	801d6a0 <_msh_exec_cmd+0xa8>
        return -RT_ERROR;
 801d69a:	f04f 33ff 	mov.w	r3, #4294967295
 801d69e:	e009      	b.n	801d6b4 <_msh_exec_cmd+0xbc>

    /* exec this command */
    *retp = cmd_func(argc, argv);
 801d6a0:	f107 0214 	add.w	r2, r7, #20
 801d6a4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d6a6:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 801d6a8:	4611      	mov	r1, r2
 801d6aa:	4798      	blx	r3
 801d6ac:	4602      	mov	r2, r0
 801d6ae:	687b      	ldr	r3, [r7, #4]
 801d6b0:	601a      	str	r2, [r3, #0]
    return 0;
 801d6b2:	2300      	movs	r3, #0
}
 801d6b4:	4618      	mov	r0, r3
 801d6b6:	3748      	adds	r7, #72	; 0x48
 801d6b8:	46bd      	mov	sp, r7
 801d6ba:	bd80      	pop	{r7, pc}
 801d6bc:	0802a3a0 	.word	0x0802a3a0
 801d6c0:	0802b418 	.word	0x0802b418
 801d6c4:	0802a3a4 	.word	0x0802a3a4

0801d6c8 <msh_exec>:

int msh_exec(char* cmd, rt_size_t length)
{
 801d6c8:	b580      	push	{r7, lr}
 801d6ca:	b084      	sub	sp, #16
 801d6cc:	af00      	add	r7, sp, #0
 801d6ce:	6078      	str	r0, [r7, #4]
 801d6d0:	6039      	str	r1, [r7, #0]
    int cmd_ret;

	/* strim the beginning of command */
    while(*cmd  == ' ' || *cmd == '\t')
 801d6d2:	e005      	b.n	801d6e0 <msh_exec+0x18>
    {
        cmd++;
 801d6d4:	687b      	ldr	r3, [r7, #4]
 801d6d6:	3301      	adds	r3, #1
 801d6d8:	607b      	str	r3, [r7, #4]
        length--;
 801d6da:	683b      	ldr	r3, [r7, #0]
 801d6dc:	3b01      	subs	r3, #1
 801d6de:	603b      	str	r3, [r7, #0]
int msh_exec(char* cmd, rt_size_t length)
{
    int cmd_ret;

	/* strim the beginning of command */
    while(*cmd  == ' ' || *cmd == '\t')
 801d6e0:	687b      	ldr	r3, [r7, #4]
 801d6e2:	781b      	ldrb	r3, [r3, #0]
 801d6e4:	2b20      	cmp	r3, #32
 801d6e6:	d0f5      	beq.n	801d6d4 <msh_exec+0xc>
 801d6e8:	687b      	ldr	r3, [r7, #4]
 801d6ea:	781b      	ldrb	r3, [r3, #0]
 801d6ec:	2b09      	cmp	r3, #9
 801d6ee:	d0f1      	beq.n	801d6d4 <msh_exec+0xc>
    {
        cmd++;
        length--;
    }

    if (length == 0)
 801d6f0:	683b      	ldr	r3, [r7, #0]
 801d6f2:	2b00      	cmp	r3, #0
 801d6f4:	d101      	bne.n	801d6fa <msh_exec+0x32>
        return 0;
 801d6f6:	2300      	movs	r3, #0
 801d6f8:	e022      	b.n	801d740 <msh_exec+0x78>
    /* Exec sequence:
     * 1. built-in command
     * 2. module(if enabled)
     * 3. chdir to the directry(if possible)
     */
    if (_msh_exec_cmd(cmd, length, &cmd_ret) == 0)
 801d6fa:	f107 0308 	add.w	r3, r7, #8
 801d6fe:	6878      	ldr	r0, [r7, #4]
 801d700:	6839      	ldr	r1, [r7, #0]
 801d702:	461a      	mov	r2, r3
 801d704:	f7ff ff78 	bl	801d5f8 <_msh_exec_cmd>
 801d708:	4603      	mov	r3, r0
 801d70a:	2b00      	cmp	r3, #0
 801d70c:	d101      	bne.n	801d712 <msh_exec+0x4a>
    {
        return cmd_ret;
 801d70e:	68bb      	ldr	r3, [r7, #8]
 801d710:	e016      	b.n	801d740 <msh_exec+0x78>
#endif

    /* truncate the cmd at the first space. */
    {
        char *tcmd;
        tcmd = cmd;
 801d712:	687b      	ldr	r3, [r7, #4]
 801d714:	60fb      	str	r3, [r7, #12]
        while(*tcmd != ' ' && *tcmd != '\0')
 801d716:	e002      	b.n	801d71e <msh_exec+0x56>
        {
            tcmd++;
 801d718:	68fb      	ldr	r3, [r7, #12]
 801d71a:	3301      	adds	r3, #1
 801d71c:	60fb      	str	r3, [r7, #12]

    /* truncate the cmd at the first space. */
    {
        char *tcmd;
        tcmd = cmd;
        while(*tcmd != ' ' && *tcmd != '\0')
 801d71e:	68fb      	ldr	r3, [r7, #12]
 801d720:	781b      	ldrb	r3, [r3, #0]
 801d722:	2b20      	cmp	r3, #32
 801d724:	d003      	beq.n	801d72e <msh_exec+0x66>
 801d726:	68fb      	ldr	r3, [r7, #12]
 801d728:	781b      	ldrb	r3, [r3, #0]
 801d72a:	2b00      	cmp	r3, #0
 801d72c:	d1f4      	bne.n	801d718 <msh_exec+0x50>
        {
            tcmd++;
        }
        *tcmd = '\0';
 801d72e:	68fb      	ldr	r3, [r7, #12]
 801d730:	2200      	movs	r2, #0
 801d732:	701a      	strb	r2, [r3, #0]
    }
    rt_kprintf("%s: command not found.\n", cmd);
 801d734:	4804      	ldr	r0, [pc, #16]	; (801d748 <msh_exec+0x80>)
 801d736:	6879      	ldr	r1, [r7, #4]
 801d738:	f7f9 fcea 	bl	8017110 <rt_kprintf>
    return -1;
 801d73c:	f04f 33ff 	mov.w	r3, #4294967295
}
 801d740:	4618      	mov	r0, r3
 801d742:	3710      	adds	r7, #16
 801d744:	46bd      	mov	sp, r7
 801d746:	bd80      	pop	{r7, pc}
 801d748:	0802a3ac 	.word	0x0802a3ac

0801d74c <str_common>:

static int str_common(const char *str1, const char *str2)
{
 801d74c:	b480      	push	{r7}
 801d74e:	b085      	sub	sp, #20
 801d750:	af00      	add	r7, sp, #0
 801d752:	6078      	str	r0, [r7, #4]
 801d754:	6039      	str	r1, [r7, #0]
    const char *str = str1;
 801d756:	687b      	ldr	r3, [r7, #4]
 801d758:	60fb      	str	r3, [r7, #12]

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
 801d75a:	e005      	b.n	801d768 <str_common+0x1c>
    {
        str ++;
 801d75c:	68fb      	ldr	r3, [r7, #12]
 801d75e:	3301      	adds	r3, #1
 801d760:	60fb      	str	r3, [r7, #12]
        str2 ++;
 801d762:	683b      	ldr	r3, [r7, #0]
 801d764:	3301      	adds	r3, #1
 801d766:	603b      	str	r3, [r7, #0]

static int str_common(const char *str1, const char *str2)
{
    const char *str = str1;

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
 801d768:	68fb      	ldr	r3, [r7, #12]
 801d76a:	781b      	ldrb	r3, [r3, #0]
 801d76c:	2b00      	cmp	r3, #0
 801d76e:	d009      	beq.n	801d784 <str_common+0x38>
 801d770:	683b      	ldr	r3, [r7, #0]
 801d772:	781b      	ldrb	r3, [r3, #0]
 801d774:	2b00      	cmp	r3, #0
 801d776:	d005      	beq.n	801d784 <str_common+0x38>
 801d778:	68fb      	ldr	r3, [r7, #12]
 801d77a:	781a      	ldrb	r2, [r3, #0]
 801d77c:	683b      	ldr	r3, [r7, #0]
 801d77e:	781b      	ldrb	r3, [r3, #0]
 801d780:	429a      	cmp	r2, r3
 801d782:	d0eb      	beq.n	801d75c <str_common+0x10>
    {
        str ++;
        str2 ++;
    }

    return (str - str1);
 801d784:	68fa      	ldr	r2, [r7, #12]
 801d786:	687b      	ldr	r3, [r7, #4]
 801d788:	1ad3      	subs	r3, r2, r3
}
 801d78a:	4618      	mov	r0, r3
 801d78c:	3714      	adds	r7, #20
 801d78e:	46bd      	mov	sp, r7
 801d790:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d794:	4770      	bx	lr
 801d796:	bf00      	nop

0801d798 <msh_auto_complete>:
    rt_free(full_path);
}
#endif

void msh_auto_complete(char *prefix)
{
 801d798:	b580      	push	{r7, lr}
 801d79a:	b088      	sub	sp, #32
 801d79c:	af00      	add	r7, sp, #0
 801d79e:	6078      	str	r0, [r7, #4]
    int length, min_length;
    const char *name_ptr, *cmd_name;
    struct finsh_syscall *index;

    min_length = 0;
 801d7a0:	2300      	movs	r3, #0
 801d7a2:	61fb      	str	r3, [r7, #28]
    name_ptr = RT_NULL;
 801d7a4:	2300      	movs	r3, #0
 801d7a6:	61bb      	str	r3, [r7, #24]

    if (*prefix == '\0') 
 801d7a8:	687b      	ldr	r3, [r7, #4]
 801d7aa:	781b      	ldrb	r3, [r3, #0]
 801d7ac:	2b00      	cmp	r3, #0
 801d7ae:	d104      	bne.n	801d7ba <msh_auto_complete+0x22>
    {
        msh_help(0, RT_NULL);
 801d7b0:	2000      	movs	r0, #0
 801d7b2:	2100      	movs	r1, #0
 801d7b4:	f7ff fe0a 	bl	801d3cc <msh_help>
        return;
 801d7b8:	e049      	b.n	801d84e <msh_auto_complete+0xb6>
    }
#endif

    /* checks in internal command */
    {
        for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
 801d7ba:	4b26      	ldr	r3, [pc, #152]	; (801d854 <msh_auto_complete+0xbc>)
 801d7bc:	681b      	ldr	r3, [r3, #0]
 801d7be:	617b      	str	r3, [r7, #20]
 801d7c0:	e036      	b.n	801d830 <msh_auto_complete+0x98>
        {
            /* skip finsh shell function */
            if (strncmp(index->name, "__cmd_", 6) != 0) continue;
 801d7c2:	697b      	ldr	r3, [r7, #20]
 801d7c4:	681b      	ldr	r3, [r3, #0]
 801d7c6:	4618      	mov	r0, r3
 801d7c8:	4923      	ldr	r1, [pc, #140]	; (801d858 <msh_auto_complete+0xc0>)
 801d7ca:	2206      	movs	r2, #6
 801d7cc:	f005 fc16 	bl	8022ffc <strncmp>
 801d7d0:	4603      	mov	r3, r0
 801d7d2:	2b00      	cmp	r3, #0
 801d7d4:	d000      	beq.n	801d7d8 <msh_auto_complete+0x40>
 801d7d6:	e028      	b.n	801d82a <msh_auto_complete+0x92>

            cmd_name = (const char*) &index->name[6];
 801d7d8:	697b      	ldr	r3, [r7, #20]
 801d7da:	681b      	ldr	r3, [r3, #0]
 801d7dc:	3306      	adds	r3, #6
 801d7de:	613b      	str	r3, [r7, #16]
            if (strncmp(prefix, cmd_name, strlen(prefix)) == 0)
 801d7e0:	6878      	ldr	r0, [r7, #4]
 801d7e2:	f005 fbdd 	bl	8022fa0 <strlen>
 801d7e6:	4603      	mov	r3, r0
 801d7e8:	6878      	ldr	r0, [r7, #4]
 801d7ea:	6939      	ldr	r1, [r7, #16]
 801d7ec:	461a      	mov	r2, r3
 801d7ee:	f005 fc05 	bl	8022ffc <strncmp>
 801d7f2:	4603      	mov	r3, r0
 801d7f4:	2b00      	cmp	r3, #0
 801d7f6:	d118      	bne.n	801d82a <msh_auto_complete+0x92>
            {
                if (min_length == 0)
 801d7f8:	69fb      	ldr	r3, [r7, #28]
 801d7fa:	2b00      	cmp	r3, #0
 801d7fc:	d106      	bne.n	801d80c <msh_auto_complete+0x74>
                {
                    /* set name_ptr */
                    name_ptr = cmd_name;
 801d7fe:	693b      	ldr	r3, [r7, #16]
 801d800:	61bb      	str	r3, [r7, #24]
                    /* set initial length */
                    min_length = strlen(name_ptr);
 801d802:	69b8      	ldr	r0, [r7, #24]
 801d804:	f005 fbcc 	bl	8022fa0 <strlen>
 801d808:	4603      	mov	r3, r0
 801d80a:	61fb      	str	r3, [r7, #28]
                }

                length = str_common(name_ptr, cmd_name);
 801d80c:	69b8      	ldr	r0, [r7, #24]
 801d80e:	6939      	ldr	r1, [r7, #16]
 801d810:	f7ff ff9c 	bl	801d74c <str_common>
 801d814:	60f8      	str	r0, [r7, #12]
                if (length < min_length)
 801d816:	68fa      	ldr	r2, [r7, #12]
 801d818:	69fb      	ldr	r3, [r7, #28]
 801d81a:	429a      	cmp	r2, r3
 801d81c:	da01      	bge.n	801d822 <msh_auto_complete+0x8a>
                    min_length = length;
 801d81e:	68fb      	ldr	r3, [r7, #12]
 801d820:	61fb      	str	r3, [r7, #28]

                rt_kprintf("%s\n", cmd_name);
 801d822:	480e      	ldr	r0, [pc, #56]	; (801d85c <msh_auto_complete+0xc4>)
 801d824:	6939      	ldr	r1, [r7, #16]
 801d826:	f7f9 fc73 	bl	8017110 <rt_kprintf>
    }
#endif

    /* checks in internal command */
    {
        for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
 801d82a:	697b      	ldr	r3, [r7, #20]
 801d82c:	330c      	adds	r3, #12
 801d82e:	617b      	str	r3, [r7, #20]
 801d830:	4b0b      	ldr	r3, [pc, #44]	; (801d860 <msh_auto_complete+0xc8>)
 801d832:	681b      	ldr	r3, [r3, #0]
 801d834:	697a      	ldr	r2, [r7, #20]
 801d836:	429a      	cmp	r2, r3
 801d838:	d3c3      	bcc.n	801d7c2 <msh_auto_complete+0x2a>
            }
        }
    }

    /* auto complete string */
    if (name_ptr != NULL)
 801d83a:	69bb      	ldr	r3, [r7, #24]
 801d83c:	2b00      	cmp	r3, #0
 801d83e:	d005      	beq.n	801d84c <msh_auto_complete+0xb4>
    {
        rt_strncpy(prefix, name_ptr, min_length);
 801d840:	69fb      	ldr	r3, [r7, #28]
 801d842:	6878      	ldr	r0, [r7, #4]
 801d844:	69b9      	ldr	r1, [r7, #24]
 801d846:	461a      	mov	r2, r3
 801d848:	f7f8 ffb2 	bl	80167b0 <rt_strncpy>
    }

    return ;
 801d84c:	bf00      	nop
}
 801d84e:	3720      	adds	r7, #32
 801d850:	46bd      	mov	sp, r7
 801d852:	bd80      	pop	{r7, pc}
 801d854:	200121b0 	.word	0x200121b0
 801d858:	0802a388 	.word	0x0802a388
 801d85c:	0802a3c4 	.word	0x0802a3c4
 801d860:	200121b4 	.word	0x200121b4

0801d864 <finsh_compile>:
#define finsh_code_byte(x)  do { *finsh_compile_pc = (x); finsh_compile_pc ++; } while(0)
#define finsh_code_word(x)  do { FINSH_SET16(finsh_compile_pc, x); finsh_compile_pc +=2; } while(0)
#define finsh_code_dword(x) do { FINSH_SET32(finsh_compile_pc, x); finsh_compile_pc +=4; } while(0)

static int finsh_compile(struct finsh_node* node)
{
 801d864:	b580      	push	{r7, lr}
 801d866:	b08a      	sub	sp, #40	; 0x28
 801d868:	af00      	add	r7, sp, #0
 801d86a:	6078      	str	r0, [r7, #4]
    if (node != NULL)
 801d86c:	687b      	ldr	r3, [r7, #4]
 801d86e:	2b00      	cmp	r3, #0
 801d870:	f001 83e0 	beq.w	801f034 <finsh_compile+0x17d0>
    {
        /* compile child node */
        if (finsh_node_child(node) != NULL)
 801d874:	687b      	ldr	r3, [r7, #4]
 801d876:	691b      	ldr	r3, [r3, #16]
 801d878:	2b00      	cmp	r3, #0
 801d87a:	d004      	beq.n	801d886 <finsh_compile+0x22>
            finsh_compile(finsh_node_child(node));
 801d87c:	687b      	ldr	r3, [r7, #4]
 801d87e:	691b      	ldr	r3, [r3, #16]
 801d880:	4618      	mov	r0, r3
 801d882:	f7ff ffef 	bl	801d864 <finsh_compile>

        /* compile current node */
        switch (node->node_type)
 801d886:	687b      	ldr	r3, [r7, #4]
 801d888:	781b      	ldrb	r3, [r3, #0]
 801d88a:	3b01      	subs	r3, #1
 801d88c:	2b1a      	cmp	r3, #26
 801d88e:	f201 83c1 	bhi.w	801f014 <finsh_compile+0x17b0>
 801d892:	a201      	add	r2, pc, #4	; (adr r2, 801d898 <finsh_compile+0x34>)
 801d894:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801d898:	0801d905 	.word	0x0801d905
 801d89c:	0801dd07 	.word	0x0801dd07
 801d8a0:	0801dd31 	.word	0x0801dd31
 801d8a4:	0801dd31 	.word	0x0801dd31
 801d8a8:	0801dd8d 	.word	0x0801dd8d
 801d8ac:	0801dd8d 	.word	0x0801dd8d
 801d8b0:	0801dde9 	.word	0x0801dde9
 801d8b4:	0801de47 	.word	0x0801de47
 801d8b8:	0801dea1 	.word	0x0801dea1
 801d8bc:	0801defb 	.word	0x0801defb
 801d8c0:	0801df55 	.word	0x0801df55
 801d8c4:	0801dfaf 	.word	0x0801dfaf
 801d8c8:	0801e009 	.word	0x0801e009
 801d8cc:	0801e069 	.word	0x0801e069
 801d8d0:	0801e0c3 	.word	0x0801e0c3
 801d8d4:	0801e11d 	.word	0x0801e11d
 801d8d8:	0801e177 	.word	0x0801e177
 801d8dc:	0801e1d1 	.word	0x0801e1d1
 801d8e0:	0801e227 	.word	0x0801e227
 801d8e4:	0801f015 	.word	0x0801f015
 801d8e8:	0801e36d 	.word	0x0801e36d
 801d8ec:	0801e5ef 	.word	0x0801e5ef
 801d8f0:	0801e86f 	.word	0x0801e86f
 801d8f4:	0801ebfd 	.word	0x0801ebfd
 801d8f8:	0801efb9 	.word	0x0801efb9
 801d8fc:	0801f01d 	.word	0x0801f01d
 801d900:	0801ef83 	.word	0x0801ef83
        {
        case FINSH_NODE_ID:
            {
                /* identifier::syscall */
                if (node->idtype & FINSH_IDTYPE_SYSCALL)
 801d904:	687b      	ldr	r3, [r7, #4]
 801d906:	789b      	ldrb	r3, [r3, #2]
 801d908:	f003 0304 	and.w	r3, r3, #4
 801d90c:	2b00      	cmp	r3, #0
 801d90e:	d030      	beq.n	801d972 <finsh_compile+0x10e>
                {
                    /* load address */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801d910:	4b9f      	ldr	r3, [pc, #636]	; (801db90 <finsh_compile+0x32c>)
 801d912:	681b      	ldr	r3, [r3, #0]
 801d914:	2224      	movs	r2, #36	; 0x24
 801d916:	701a      	strb	r2, [r3, #0]
 801d918:	4b9d      	ldr	r3, [pc, #628]	; (801db90 <finsh_compile+0x32c>)
 801d91a:	681b      	ldr	r3, [r3, #0]
 801d91c:	3301      	adds	r3, #1
 801d91e:	4a9c      	ldr	r2, [pc, #624]	; (801db90 <finsh_compile+0x32c>)
 801d920:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)node->id.syscall->func);
 801d922:	4b9b      	ldr	r3, [pc, #620]	; (801db90 <finsh_compile+0x32c>)
 801d924:	681b      	ldr	r3, [r3, #0]
 801d926:	687a      	ldr	r2, [r7, #4]
 801d928:	6892      	ldr	r2, [r2, #8]
 801d92a:	6892      	ldr	r2, [r2, #8]
 801d92c:	b2d2      	uxtb	r2, r2
 801d92e:	701a      	strb	r2, [r3, #0]
 801d930:	4b97      	ldr	r3, [pc, #604]	; (801db90 <finsh_compile+0x32c>)
 801d932:	681b      	ldr	r3, [r3, #0]
 801d934:	3301      	adds	r3, #1
 801d936:	687a      	ldr	r2, [r7, #4]
 801d938:	6892      	ldr	r2, [r2, #8]
 801d93a:	6892      	ldr	r2, [r2, #8]
 801d93c:	0a12      	lsrs	r2, r2, #8
 801d93e:	b2d2      	uxtb	r2, r2
 801d940:	701a      	strb	r2, [r3, #0]
 801d942:	4b93      	ldr	r3, [pc, #588]	; (801db90 <finsh_compile+0x32c>)
 801d944:	681b      	ldr	r3, [r3, #0]
 801d946:	3302      	adds	r3, #2
 801d948:	687a      	ldr	r2, [r7, #4]
 801d94a:	6892      	ldr	r2, [r2, #8]
 801d94c:	6892      	ldr	r2, [r2, #8]
 801d94e:	0c12      	lsrs	r2, r2, #16
 801d950:	b2d2      	uxtb	r2, r2
 801d952:	701a      	strb	r2, [r3, #0]
 801d954:	4b8e      	ldr	r3, [pc, #568]	; (801db90 <finsh_compile+0x32c>)
 801d956:	681b      	ldr	r3, [r3, #0]
 801d958:	3303      	adds	r3, #3
 801d95a:	687a      	ldr	r2, [r7, #4]
 801d95c:	6892      	ldr	r2, [r2, #8]
 801d95e:	6892      	ldr	r2, [r2, #8]
 801d960:	0e12      	lsrs	r2, r2, #24
 801d962:	b2d2      	uxtb	r2, r2
 801d964:	701a      	strb	r2, [r3, #0]
 801d966:	4b8a      	ldr	r3, [pc, #552]	; (801db90 <finsh_compile+0x32c>)
 801d968:	681b      	ldr	r3, [r3, #0]
 801d96a:	3304      	adds	r3, #4
 801d96c:	4a88      	ldr	r2, [pc, #544]	; (801db90 <finsh_compile+0x32c>)
 801d96e:	6013      	str	r3, [r2, #0]
 801d970:	e1c7      	b.n	801dd02 <finsh_compile+0x49e>
                }
                /* identifier::sysvar */
                else if (node->idtype & FINSH_IDTYPE_SYSVAR)
 801d972:	687b      	ldr	r3, [r7, #4]
 801d974:	789b      	ldrb	r3, [r3, #2]
 801d976:	f003 0302 	and.w	r3, r3, #2
 801d97a:	2b00      	cmp	r3, #0
 801d97c:	f000 80e0 	beq.w	801db40 <finsh_compile+0x2dc>
                {
                    struct finsh_sysvar* sysvar;

                    sysvar = node->id.sysvar;
 801d980:	687b      	ldr	r3, [r7, #4]
 801d982:	689b      	ldr	r3, [r3, #8]
 801d984:	61fb      	str	r3, [r7, #28]
                    if (sysvar != NULL)
 801d986:	69fb      	ldr	r3, [r7, #28]
 801d988:	2b00      	cmp	r3, #0
 801d98a:	f000 80d8 	beq.w	801db3e <finsh_compile+0x2da>
                    {
                        switch (sysvar->type)
 801d98e:	69fb      	ldr	r3, [r7, #28]
 801d990:	7a1b      	ldrb	r3, [r3, #8]
 801d992:	3b03      	subs	r3, #3
 801d994:	2b0b      	cmp	r3, #11
 801d996:	f200 81b4 	bhi.w	801dd02 <finsh_compile+0x49e>
 801d99a:	a201      	add	r2, pc, #4	; (adr r2, 801d9a0 <finsh_compile+0x13c>)
 801d99c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801d9a0:	0801d9d1 	.word	0x0801d9d1
 801d9a4:	0801d9d1 	.word	0x0801d9d1
 801d9a8:	0801dac5 	.word	0x0801dac5
 801d9ac:	0801da4b 	.word	0x0801da4b
 801d9b0:	0801da4b 	.word	0x0801da4b
 801d9b4:	0801dac5 	.word	0x0801dac5
 801d9b8:	0801dac5 	.word	0x0801dac5
 801d9bc:	0801dac5 	.word	0x0801dac5
 801d9c0:	0801dac5 	.word	0x0801dac5
 801d9c4:	0801dac5 	.word	0x0801dac5
 801d9c8:	0801dac5 	.word	0x0801dac5
 801d9cc:	0801dac5 	.word	0x0801dac5
                        {
                        case finsh_type_char:
                        case finsh_type_uchar:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801d9d0:	687b      	ldr	r3, [r7, #4]
 801d9d2:	789b      	ldrb	r3, [r3, #2]
 801d9d4:	f003 0308 	and.w	r3, r3, #8
 801d9d8:	2b00      	cmp	r3, #0
 801d9da:	d009      	beq.n	801d9f0 <finsh_compile+0x18c>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
 801d9dc:	4b6c      	ldr	r3, [pc, #432]	; (801db90 <finsh_compile+0x32c>)
 801d9de:	681b      	ldr	r3, [r3, #0]
 801d9e0:	2224      	movs	r2, #36	; 0x24
 801d9e2:	701a      	strb	r2, [r3, #0]
 801d9e4:	4b6a      	ldr	r3, [pc, #424]	; (801db90 <finsh_compile+0x32c>)
 801d9e6:	681b      	ldr	r3, [r3, #0]
 801d9e8:	3301      	adds	r3, #1
 801d9ea:	4a69      	ldr	r2, [pc, #420]	; (801db90 <finsh_compile+0x32c>)
 801d9ec:	6013      	str	r3, [r2, #0]
 801d9ee:	e008      	b.n	801da02 <finsh_compile+0x19e>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
 801d9f0:	4b67      	ldr	r3, [pc, #412]	; (801db90 <finsh_compile+0x32c>)
 801d9f2:	681b      	ldr	r3, [r3, #0]
 801d9f4:	2225      	movs	r2, #37	; 0x25
 801d9f6:	701a      	strb	r2, [r3, #0]
 801d9f8:	4b65      	ldr	r3, [pc, #404]	; (801db90 <finsh_compile+0x32c>)
 801d9fa:	681b      	ldr	r3, [r3, #0]
 801d9fc:	3301      	adds	r3, #1
 801d9fe:	4a64      	ldr	r2, [pc, #400]	; (801db90 <finsh_compile+0x32c>)
 801da00:	6013      	str	r3, [r2, #0]
                            }

                            finsh_code_dword((long)(sysvar->var));
 801da02:	4b63      	ldr	r3, [pc, #396]	; (801db90 <finsh_compile+0x32c>)
 801da04:	681b      	ldr	r3, [r3, #0]
 801da06:	69fa      	ldr	r2, [r7, #28]
 801da08:	68d2      	ldr	r2, [r2, #12]
 801da0a:	b2d2      	uxtb	r2, r2
 801da0c:	701a      	strb	r2, [r3, #0]
 801da0e:	4b60      	ldr	r3, [pc, #384]	; (801db90 <finsh_compile+0x32c>)
 801da10:	681b      	ldr	r3, [r3, #0]
 801da12:	3301      	adds	r3, #1
 801da14:	69fa      	ldr	r2, [r7, #28]
 801da16:	68d2      	ldr	r2, [r2, #12]
 801da18:	0a12      	lsrs	r2, r2, #8
 801da1a:	b2d2      	uxtb	r2, r2
 801da1c:	701a      	strb	r2, [r3, #0]
 801da1e:	4b5c      	ldr	r3, [pc, #368]	; (801db90 <finsh_compile+0x32c>)
 801da20:	681b      	ldr	r3, [r3, #0]
 801da22:	3302      	adds	r3, #2
 801da24:	69fa      	ldr	r2, [r7, #28]
 801da26:	68d2      	ldr	r2, [r2, #12]
 801da28:	0c12      	lsrs	r2, r2, #16
 801da2a:	b2d2      	uxtb	r2, r2
 801da2c:	701a      	strb	r2, [r3, #0]
 801da2e:	4b58      	ldr	r3, [pc, #352]	; (801db90 <finsh_compile+0x32c>)
 801da30:	681b      	ldr	r3, [r3, #0]
 801da32:	3303      	adds	r3, #3
 801da34:	69fa      	ldr	r2, [r7, #28]
 801da36:	68d2      	ldr	r2, [r2, #12]
 801da38:	0e12      	lsrs	r2, r2, #24
 801da3a:	b2d2      	uxtb	r2, r2
 801da3c:	701a      	strb	r2, [r3, #0]
 801da3e:	4b54      	ldr	r3, [pc, #336]	; (801db90 <finsh_compile+0x32c>)
 801da40:	681b      	ldr	r3, [r3, #0]
 801da42:	3304      	adds	r3, #4
 801da44:	4a52      	ldr	r2, [pc, #328]	; (801db90 <finsh_compile+0x32c>)
 801da46:	6013      	str	r3, [r2, #0]
                            break;
 801da48:	e079      	b.n	801db3e <finsh_compile+0x2da>

                        case finsh_type_short:
                        case finsh_type_ushort:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801da4a:	687b      	ldr	r3, [r7, #4]
 801da4c:	789b      	ldrb	r3, [r3, #2]
 801da4e:	f003 0308 	and.w	r3, r3, #8
 801da52:	2b00      	cmp	r3, #0
 801da54:	d009      	beq.n	801da6a <finsh_compile+0x206>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
 801da56:	4b4e      	ldr	r3, [pc, #312]	; (801db90 <finsh_compile+0x32c>)
 801da58:	681b      	ldr	r3, [r3, #0]
 801da5a:	2224      	movs	r2, #36	; 0x24
 801da5c:	701a      	strb	r2, [r3, #0]
 801da5e:	4b4c      	ldr	r3, [pc, #304]	; (801db90 <finsh_compile+0x32c>)
 801da60:	681b      	ldr	r3, [r3, #0]
 801da62:	3301      	adds	r3, #1
 801da64:	4a4a      	ldr	r2, [pc, #296]	; (801db90 <finsh_compile+0x32c>)
 801da66:	6013      	str	r3, [r2, #0]
 801da68:	e008      	b.n	801da7c <finsh_compile+0x218>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
 801da6a:	4b49      	ldr	r3, [pc, #292]	; (801db90 <finsh_compile+0x32c>)
 801da6c:	681b      	ldr	r3, [r3, #0]
 801da6e:	2226      	movs	r2, #38	; 0x26
 801da70:	701a      	strb	r2, [r3, #0]
 801da72:	4b47      	ldr	r3, [pc, #284]	; (801db90 <finsh_compile+0x32c>)
 801da74:	681b      	ldr	r3, [r3, #0]
 801da76:	3301      	adds	r3, #1
 801da78:	4a45      	ldr	r2, [pc, #276]	; (801db90 <finsh_compile+0x32c>)
 801da7a:	6013      	str	r3, [r2, #0]
                            }

                            finsh_code_dword((long)(sysvar->var));
 801da7c:	4b44      	ldr	r3, [pc, #272]	; (801db90 <finsh_compile+0x32c>)
 801da7e:	681b      	ldr	r3, [r3, #0]
 801da80:	69fa      	ldr	r2, [r7, #28]
 801da82:	68d2      	ldr	r2, [r2, #12]
 801da84:	b2d2      	uxtb	r2, r2
 801da86:	701a      	strb	r2, [r3, #0]
 801da88:	4b41      	ldr	r3, [pc, #260]	; (801db90 <finsh_compile+0x32c>)
 801da8a:	681b      	ldr	r3, [r3, #0]
 801da8c:	3301      	adds	r3, #1
 801da8e:	69fa      	ldr	r2, [r7, #28]
 801da90:	68d2      	ldr	r2, [r2, #12]
 801da92:	0a12      	lsrs	r2, r2, #8
 801da94:	b2d2      	uxtb	r2, r2
 801da96:	701a      	strb	r2, [r3, #0]
 801da98:	4b3d      	ldr	r3, [pc, #244]	; (801db90 <finsh_compile+0x32c>)
 801da9a:	681b      	ldr	r3, [r3, #0]
 801da9c:	3302      	adds	r3, #2
 801da9e:	69fa      	ldr	r2, [r7, #28]
 801daa0:	68d2      	ldr	r2, [r2, #12]
 801daa2:	0c12      	lsrs	r2, r2, #16
 801daa4:	b2d2      	uxtb	r2, r2
 801daa6:	701a      	strb	r2, [r3, #0]
 801daa8:	4b39      	ldr	r3, [pc, #228]	; (801db90 <finsh_compile+0x32c>)
 801daaa:	681b      	ldr	r3, [r3, #0]
 801daac:	3303      	adds	r3, #3
 801daae:	69fa      	ldr	r2, [r7, #28]
 801dab0:	68d2      	ldr	r2, [r2, #12]
 801dab2:	0e12      	lsrs	r2, r2, #24
 801dab4:	b2d2      	uxtb	r2, r2
 801dab6:	701a      	strb	r2, [r3, #0]
 801dab8:	4b35      	ldr	r3, [pc, #212]	; (801db90 <finsh_compile+0x32c>)
 801daba:	681b      	ldr	r3, [r3, #0]
 801dabc:	3304      	adds	r3, #4
 801dabe:	4a34      	ldr	r2, [pc, #208]	; (801db90 <finsh_compile+0x32c>)
 801dac0:	6013      	str	r3, [r2, #0]
                            break;
 801dac2:	e03c      	b.n	801db3e <finsh_compile+0x2da>
                        case finsh_type_ulong:
                        case finsh_type_charp:
                        case finsh_type_shortp:
                        case finsh_type_intp:
                        case finsh_type_longp:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801dac4:	687b      	ldr	r3, [r7, #4]
 801dac6:	789b      	ldrb	r3, [r3, #2]
 801dac8:	f003 0308 	and.w	r3, r3, #8
 801dacc:	2b00      	cmp	r3, #0
 801dace:	d009      	beq.n	801dae4 <finsh_compile+0x280>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
 801dad0:	4b2f      	ldr	r3, [pc, #188]	; (801db90 <finsh_compile+0x32c>)
 801dad2:	681b      	ldr	r3, [r3, #0]
 801dad4:	2224      	movs	r2, #36	; 0x24
 801dad6:	701a      	strb	r2, [r3, #0]
 801dad8:	4b2d      	ldr	r3, [pc, #180]	; (801db90 <finsh_compile+0x32c>)
 801dada:	681b      	ldr	r3, [r3, #0]
 801dadc:	3301      	adds	r3, #1
 801dade:	4a2c      	ldr	r2, [pc, #176]	; (801db90 <finsh_compile+0x32c>)
 801dae0:	6013      	str	r3, [r2, #0]
 801dae2:	e008      	b.n	801daf6 <finsh_compile+0x292>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
 801dae4:	4b2a      	ldr	r3, [pc, #168]	; (801db90 <finsh_compile+0x32c>)
 801dae6:	681b      	ldr	r3, [r3, #0]
 801dae8:	2227      	movs	r2, #39	; 0x27
 801daea:	701a      	strb	r2, [r3, #0]
 801daec:	4b28      	ldr	r3, [pc, #160]	; (801db90 <finsh_compile+0x32c>)
 801daee:	681b      	ldr	r3, [r3, #0]
 801daf0:	3301      	adds	r3, #1
 801daf2:	4a27      	ldr	r2, [pc, #156]	; (801db90 <finsh_compile+0x32c>)
 801daf4:	6013      	str	r3, [r2, #0]
                            }

                            finsh_code_dword((long)(sysvar->var));
 801daf6:	4b26      	ldr	r3, [pc, #152]	; (801db90 <finsh_compile+0x32c>)
 801daf8:	681b      	ldr	r3, [r3, #0]
 801dafa:	69fa      	ldr	r2, [r7, #28]
 801dafc:	68d2      	ldr	r2, [r2, #12]
 801dafe:	b2d2      	uxtb	r2, r2
 801db00:	701a      	strb	r2, [r3, #0]
 801db02:	4b23      	ldr	r3, [pc, #140]	; (801db90 <finsh_compile+0x32c>)
 801db04:	681b      	ldr	r3, [r3, #0]
 801db06:	3301      	adds	r3, #1
 801db08:	69fa      	ldr	r2, [r7, #28]
 801db0a:	68d2      	ldr	r2, [r2, #12]
 801db0c:	0a12      	lsrs	r2, r2, #8
 801db0e:	b2d2      	uxtb	r2, r2
 801db10:	701a      	strb	r2, [r3, #0]
 801db12:	4b1f      	ldr	r3, [pc, #124]	; (801db90 <finsh_compile+0x32c>)
 801db14:	681b      	ldr	r3, [r3, #0]
 801db16:	3302      	adds	r3, #2
 801db18:	69fa      	ldr	r2, [r7, #28]
 801db1a:	68d2      	ldr	r2, [r2, #12]
 801db1c:	0c12      	lsrs	r2, r2, #16
 801db1e:	b2d2      	uxtb	r2, r2
 801db20:	701a      	strb	r2, [r3, #0]
 801db22:	4b1b      	ldr	r3, [pc, #108]	; (801db90 <finsh_compile+0x32c>)
 801db24:	681b      	ldr	r3, [r3, #0]
 801db26:	3303      	adds	r3, #3
 801db28:	69fa      	ldr	r2, [r7, #28]
 801db2a:	68d2      	ldr	r2, [r2, #12]
 801db2c:	0e12      	lsrs	r2, r2, #24
 801db2e:	b2d2      	uxtb	r2, r2
 801db30:	701a      	strb	r2, [r3, #0]
 801db32:	4b17      	ldr	r3, [pc, #92]	; (801db90 <finsh_compile+0x32c>)
 801db34:	681b      	ldr	r3, [r3, #0]
 801db36:	3304      	adds	r3, #4
 801db38:	4a15      	ldr	r2, [pc, #84]	; (801db90 <finsh_compile+0x32c>)
 801db3a:	6013      	str	r3, [r2, #0]
                            break;
 801db3c:	bf00      	nop
 801db3e:	e0e0      	b.n	801dd02 <finsh_compile+0x49e>
                /* identifier::var */
                else
                {
                    struct finsh_var* var;

                    var = node->id.var;
 801db40:	687b      	ldr	r3, [r7, #4]
 801db42:	689b      	ldr	r3, [r3, #8]
 801db44:	61bb      	str	r3, [r7, #24]
                    if (var != NULL)
 801db46:	69bb      	ldr	r3, [r7, #24]
 801db48:	2b00      	cmp	r3, #0
 801db4a:	f000 80da 	beq.w	801dd02 <finsh_compile+0x49e>
                    {
                        switch (var->type)
 801db4e:	69bb      	ldr	r3, [r7, #24]
 801db50:	7c5b      	ldrb	r3, [r3, #17]
 801db52:	3b03      	subs	r3, #3
 801db54:	2b0b      	cmp	r3, #11
 801db56:	f201 8263 	bhi.w	801f020 <finsh_compile+0x17bc>
 801db5a:	a201      	add	r2, pc, #4	; (adr r2, 801db60 <finsh_compile+0x2fc>)
 801db5c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801db60:	0801db95 	.word	0x0801db95
 801db64:	0801db95 	.word	0x0801db95
 801db68:	0801dc89 	.word	0x0801dc89
 801db6c:	0801dc0f 	.word	0x0801dc0f
 801db70:	0801dc0f 	.word	0x0801dc0f
 801db74:	0801dc89 	.word	0x0801dc89
 801db78:	0801dc89 	.word	0x0801dc89
 801db7c:	0801dc89 	.word	0x0801dc89
 801db80:	0801dc89 	.word	0x0801dc89
 801db84:	0801dc89 	.word	0x0801dc89
 801db88:	0801dc89 	.word	0x0801dc89
 801db8c:	0801dc89 	.word	0x0801dc89
 801db90:	20012bdc 	.word	0x20012bdc
                        {
                        case finsh_type_char:
                        case finsh_type_uchar:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801db94:	687b      	ldr	r3, [r7, #4]
 801db96:	789b      	ldrb	r3, [r3, #2]
 801db98:	f003 0308 	and.w	r3, r3, #8
 801db9c:	2b00      	cmp	r3, #0
 801db9e:	d009      	beq.n	801dbb4 <finsh_compile+0x350>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
 801dba0:	4b98      	ldr	r3, [pc, #608]	; (801de04 <finsh_compile+0x5a0>)
 801dba2:	681b      	ldr	r3, [r3, #0]
 801dba4:	2224      	movs	r2, #36	; 0x24
 801dba6:	701a      	strb	r2, [r3, #0]
 801dba8:	4b96      	ldr	r3, [pc, #600]	; (801de04 <finsh_compile+0x5a0>)
 801dbaa:	681b      	ldr	r3, [r3, #0]
 801dbac:	3301      	adds	r3, #1
 801dbae:	4a95      	ldr	r2, [pc, #596]	; (801de04 <finsh_compile+0x5a0>)
 801dbb0:	6013      	str	r3, [r2, #0]
 801dbb2:	e008      	b.n	801dbc6 <finsh_compile+0x362>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
 801dbb4:	4b93      	ldr	r3, [pc, #588]	; (801de04 <finsh_compile+0x5a0>)
 801dbb6:	681b      	ldr	r3, [r3, #0]
 801dbb8:	2225      	movs	r2, #37	; 0x25
 801dbba:	701a      	strb	r2, [r3, #0]
 801dbbc:	4b91      	ldr	r3, [pc, #580]	; (801de04 <finsh_compile+0x5a0>)
 801dbbe:	681b      	ldr	r3, [r3, #0]
 801dbc0:	3301      	adds	r3, #1
 801dbc2:	4a90      	ldr	r2, [pc, #576]	; (801de04 <finsh_compile+0x5a0>)
 801dbc4:	6013      	str	r3, [r2, #0]
                            }

                            finsh_code_dword((long)&(var->value.char_value));
 801dbc6:	4b8f      	ldr	r3, [pc, #572]	; (801de04 <finsh_compile+0x5a0>)
 801dbc8:	681b      	ldr	r3, [r3, #0]
 801dbca:	69ba      	ldr	r2, [r7, #24]
 801dbcc:	3214      	adds	r2, #20
 801dbce:	b2d2      	uxtb	r2, r2
 801dbd0:	701a      	strb	r2, [r3, #0]
 801dbd2:	4b8c      	ldr	r3, [pc, #560]	; (801de04 <finsh_compile+0x5a0>)
 801dbd4:	681b      	ldr	r3, [r3, #0]
 801dbd6:	3301      	adds	r3, #1
 801dbd8:	69ba      	ldr	r2, [r7, #24]
 801dbda:	3214      	adds	r2, #20
 801dbdc:	0a12      	lsrs	r2, r2, #8
 801dbde:	b2d2      	uxtb	r2, r2
 801dbe0:	701a      	strb	r2, [r3, #0]
 801dbe2:	4b88      	ldr	r3, [pc, #544]	; (801de04 <finsh_compile+0x5a0>)
 801dbe4:	681b      	ldr	r3, [r3, #0]
 801dbe6:	3302      	adds	r3, #2
 801dbe8:	69ba      	ldr	r2, [r7, #24]
 801dbea:	3214      	adds	r2, #20
 801dbec:	0c12      	lsrs	r2, r2, #16
 801dbee:	b2d2      	uxtb	r2, r2
 801dbf0:	701a      	strb	r2, [r3, #0]
 801dbf2:	4b84      	ldr	r3, [pc, #528]	; (801de04 <finsh_compile+0x5a0>)
 801dbf4:	681b      	ldr	r3, [r3, #0]
 801dbf6:	3303      	adds	r3, #3
 801dbf8:	69ba      	ldr	r2, [r7, #24]
 801dbfa:	3214      	adds	r2, #20
 801dbfc:	0e12      	lsrs	r2, r2, #24
 801dbfe:	b2d2      	uxtb	r2, r2
 801dc00:	701a      	strb	r2, [r3, #0]
 801dc02:	4b80      	ldr	r3, [pc, #512]	; (801de04 <finsh_compile+0x5a0>)
 801dc04:	681b      	ldr	r3, [r3, #0]
 801dc06:	3304      	adds	r3, #4
 801dc08:	4a7e      	ldr	r2, [pc, #504]	; (801de04 <finsh_compile+0x5a0>)
 801dc0a:	6013      	str	r3, [r2, #0]
                            break;
 801dc0c:	e079      	b.n	801dd02 <finsh_compile+0x49e>

                        case finsh_type_short:
                        case finsh_type_ushort:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801dc0e:	687b      	ldr	r3, [r7, #4]
 801dc10:	789b      	ldrb	r3, [r3, #2]
 801dc12:	f003 0308 	and.w	r3, r3, #8
 801dc16:	2b00      	cmp	r3, #0
 801dc18:	d009      	beq.n	801dc2e <finsh_compile+0x3ca>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
 801dc1a:	4b7a      	ldr	r3, [pc, #488]	; (801de04 <finsh_compile+0x5a0>)
 801dc1c:	681b      	ldr	r3, [r3, #0]
 801dc1e:	2224      	movs	r2, #36	; 0x24
 801dc20:	701a      	strb	r2, [r3, #0]
 801dc22:	4b78      	ldr	r3, [pc, #480]	; (801de04 <finsh_compile+0x5a0>)
 801dc24:	681b      	ldr	r3, [r3, #0]
 801dc26:	3301      	adds	r3, #1
 801dc28:	4a76      	ldr	r2, [pc, #472]	; (801de04 <finsh_compile+0x5a0>)
 801dc2a:	6013      	str	r3, [r2, #0]
 801dc2c:	e008      	b.n	801dc40 <finsh_compile+0x3dc>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
 801dc2e:	4b75      	ldr	r3, [pc, #468]	; (801de04 <finsh_compile+0x5a0>)
 801dc30:	681b      	ldr	r3, [r3, #0]
 801dc32:	2226      	movs	r2, #38	; 0x26
 801dc34:	701a      	strb	r2, [r3, #0]
 801dc36:	4b73      	ldr	r3, [pc, #460]	; (801de04 <finsh_compile+0x5a0>)
 801dc38:	681b      	ldr	r3, [r3, #0]
 801dc3a:	3301      	adds	r3, #1
 801dc3c:	4a71      	ldr	r2, [pc, #452]	; (801de04 <finsh_compile+0x5a0>)
 801dc3e:	6013      	str	r3, [r2, #0]
                            }

                            finsh_code_dword((long)&(var->value.short_value));
 801dc40:	4b70      	ldr	r3, [pc, #448]	; (801de04 <finsh_compile+0x5a0>)
 801dc42:	681b      	ldr	r3, [r3, #0]
 801dc44:	69ba      	ldr	r2, [r7, #24]
 801dc46:	3214      	adds	r2, #20
 801dc48:	b2d2      	uxtb	r2, r2
 801dc4a:	701a      	strb	r2, [r3, #0]
 801dc4c:	4b6d      	ldr	r3, [pc, #436]	; (801de04 <finsh_compile+0x5a0>)
 801dc4e:	681b      	ldr	r3, [r3, #0]
 801dc50:	3301      	adds	r3, #1
 801dc52:	69ba      	ldr	r2, [r7, #24]
 801dc54:	3214      	adds	r2, #20
 801dc56:	0a12      	lsrs	r2, r2, #8
 801dc58:	b2d2      	uxtb	r2, r2
 801dc5a:	701a      	strb	r2, [r3, #0]
 801dc5c:	4b69      	ldr	r3, [pc, #420]	; (801de04 <finsh_compile+0x5a0>)
 801dc5e:	681b      	ldr	r3, [r3, #0]
 801dc60:	3302      	adds	r3, #2
 801dc62:	69ba      	ldr	r2, [r7, #24]
 801dc64:	3214      	adds	r2, #20
 801dc66:	0c12      	lsrs	r2, r2, #16
 801dc68:	b2d2      	uxtb	r2, r2
 801dc6a:	701a      	strb	r2, [r3, #0]
 801dc6c:	4b65      	ldr	r3, [pc, #404]	; (801de04 <finsh_compile+0x5a0>)
 801dc6e:	681b      	ldr	r3, [r3, #0]
 801dc70:	3303      	adds	r3, #3
 801dc72:	69ba      	ldr	r2, [r7, #24]
 801dc74:	3214      	adds	r2, #20
 801dc76:	0e12      	lsrs	r2, r2, #24
 801dc78:	b2d2      	uxtb	r2, r2
 801dc7a:	701a      	strb	r2, [r3, #0]
 801dc7c:	4b61      	ldr	r3, [pc, #388]	; (801de04 <finsh_compile+0x5a0>)
 801dc7e:	681b      	ldr	r3, [r3, #0]
 801dc80:	3304      	adds	r3, #4
 801dc82:	4a60      	ldr	r2, [pc, #384]	; (801de04 <finsh_compile+0x5a0>)
 801dc84:	6013      	str	r3, [r2, #0]
                            break;
 801dc86:	e03c      	b.n	801dd02 <finsh_compile+0x49e>
                        case finsh_type_ulong:
                        case finsh_type_charp:
                        case finsh_type_shortp:
                        case finsh_type_intp:
                        case finsh_type_longp:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801dc88:	687b      	ldr	r3, [r7, #4]
 801dc8a:	789b      	ldrb	r3, [r3, #2]
 801dc8c:	f003 0308 	and.w	r3, r3, #8
 801dc90:	2b00      	cmp	r3, #0
 801dc92:	d009      	beq.n	801dca8 <finsh_compile+0x444>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
 801dc94:	4b5b      	ldr	r3, [pc, #364]	; (801de04 <finsh_compile+0x5a0>)
 801dc96:	681b      	ldr	r3, [r3, #0]
 801dc98:	2224      	movs	r2, #36	; 0x24
 801dc9a:	701a      	strb	r2, [r3, #0]
 801dc9c:	4b59      	ldr	r3, [pc, #356]	; (801de04 <finsh_compile+0x5a0>)
 801dc9e:	681b      	ldr	r3, [r3, #0]
 801dca0:	3301      	adds	r3, #1
 801dca2:	4a58      	ldr	r2, [pc, #352]	; (801de04 <finsh_compile+0x5a0>)
 801dca4:	6013      	str	r3, [r2, #0]
 801dca6:	e008      	b.n	801dcba <finsh_compile+0x456>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
 801dca8:	4b56      	ldr	r3, [pc, #344]	; (801de04 <finsh_compile+0x5a0>)
 801dcaa:	681b      	ldr	r3, [r3, #0]
 801dcac:	2227      	movs	r2, #39	; 0x27
 801dcae:	701a      	strb	r2, [r3, #0]
 801dcb0:	4b54      	ldr	r3, [pc, #336]	; (801de04 <finsh_compile+0x5a0>)
 801dcb2:	681b      	ldr	r3, [r3, #0]
 801dcb4:	3301      	adds	r3, #1
 801dcb6:	4a53      	ldr	r2, [pc, #332]	; (801de04 <finsh_compile+0x5a0>)
 801dcb8:	6013      	str	r3, [r2, #0]
                            }

                            finsh_code_dword((long)&(var->value.long_value));
 801dcba:	4b52      	ldr	r3, [pc, #328]	; (801de04 <finsh_compile+0x5a0>)
 801dcbc:	681b      	ldr	r3, [r3, #0]
 801dcbe:	69ba      	ldr	r2, [r7, #24]
 801dcc0:	3214      	adds	r2, #20
 801dcc2:	b2d2      	uxtb	r2, r2
 801dcc4:	701a      	strb	r2, [r3, #0]
 801dcc6:	4b4f      	ldr	r3, [pc, #316]	; (801de04 <finsh_compile+0x5a0>)
 801dcc8:	681b      	ldr	r3, [r3, #0]
 801dcca:	3301      	adds	r3, #1
 801dccc:	69ba      	ldr	r2, [r7, #24]
 801dcce:	3214      	adds	r2, #20
 801dcd0:	0a12      	lsrs	r2, r2, #8
 801dcd2:	b2d2      	uxtb	r2, r2
 801dcd4:	701a      	strb	r2, [r3, #0]
 801dcd6:	4b4b      	ldr	r3, [pc, #300]	; (801de04 <finsh_compile+0x5a0>)
 801dcd8:	681b      	ldr	r3, [r3, #0]
 801dcda:	3302      	adds	r3, #2
 801dcdc:	69ba      	ldr	r2, [r7, #24]
 801dcde:	3214      	adds	r2, #20
 801dce0:	0c12      	lsrs	r2, r2, #16
 801dce2:	b2d2      	uxtb	r2, r2
 801dce4:	701a      	strb	r2, [r3, #0]
 801dce6:	4b47      	ldr	r3, [pc, #284]	; (801de04 <finsh_compile+0x5a0>)
 801dce8:	681b      	ldr	r3, [r3, #0]
 801dcea:	3303      	adds	r3, #3
 801dcec:	69ba      	ldr	r2, [r7, #24]
 801dcee:	3214      	adds	r2, #20
 801dcf0:	0e12      	lsrs	r2, r2, #24
 801dcf2:	b2d2      	uxtb	r2, r2
 801dcf4:	701a      	strb	r2, [r3, #0]
 801dcf6:	4b43      	ldr	r3, [pc, #268]	; (801de04 <finsh_compile+0x5a0>)
 801dcf8:	681b      	ldr	r3, [r3, #0]
 801dcfa:	3304      	adds	r3, #4
 801dcfc:	4a41      	ldr	r2, [pc, #260]	; (801de04 <finsh_compile+0x5a0>)
 801dcfe:	6013      	str	r3, [r2, #0]
                            break;
 801dd00:	bf00      	nop
                        }
                    }
                }
            }
            break;
 801dd02:	f001 b98d 	b.w	801f020 <finsh_compile+0x17bc>

        /* load const */
        case FINSH_NODE_VALUE_CHAR:
            finsh_code_byte(FINSH_OP_LD_BYTE);
 801dd06:	4b3f      	ldr	r3, [pc, #252]	; (801de04 <finsh_compile+0x5a0>)
 801dd08:	681b      	ldr	r3, [r3, #0]
 801dd0a:	2222      	movs	r2, #34	; 0x22
 801dd0c:	701a      	strb	r2, [r3, #0]
 801dd0e:	4b3d      	ldr	r3, [pc, #244]	; (801de04 <finsh_compile+0x5a0>)
 801dd10:	681b      	ldr	r3, [r3, #0]
 801dd12:	3301      	adds	r3, #1
 801dd14:	4a3b      	ldr	r2, [pc, #236]	; (801de04 <finsh_compile+0x5a0>)
 801dd16:	6013      	str	r3, [r2, #0]
            finsh_code_byte(node->value.char_value);
 801dd18:	4b3a      	ldr	r3, [pc, #232]	; (801de04 <finsh_compile+0x5a0>)
 801dd1a:	681b      	ldr	r3, [r3, #0]
 801dd1c:	687a      	ldr	r2, [r7, #4]
 801dd1e:	7912      	ldrb	r2, [r2, #4]
 801dd20:	701a      	strb	r2, [r3, #0]
 801dd22:	4b38      	ldr	r3, [pc, #224]	; (801de04 <finsh_compile+0x5a0>)
 801dd24:	681b      	ldr	r3, [r3, #0]
 801dd26:	3301      	adds	r3, #1
 801dd28:	4a36      	ldr	r2, [pc, #216]	; (801de04 <finsh_compile+0x5a0>)
 801dd2a:	6013      	str	r3, [r2, #0]
            break;
 801dd2c:	f001 b979 	b.w	801f022 <finsh_compile+0x17be>

        case FINSH_NODE_VALUE_INT:
        case FINSH_NODE_VALUE_LONG:
            finsh_code_byte(FINSH_OP_LD_DWORD);
 801dd30:	4b34      	ldr	r3, [pc, #208]	; (801de04 <finsh_compile+0x5a0>)
 801dd32:	681b      	ldr	r3, [r3, #0]
 801dd34:	2224      	movs	r2, #36	; 0x24
 801dd36:	701a      	strb	r2, [r3, #0]
 801dd38:	4b32      	ldr	r3, [pc, #200]	; (801de04 <finsh_compile+0x5a0>)
 801dd3a:	681b      	ldr	r3, [r3, #0]
 801dd3c:	3301      	adds	r3, #1
 801dd3e:	4a31      	ldr	r2, [pc, #196]	; (801de04 <finsh_compile+0x5a0>)
 801dd40:	6013      	str	r3, [r2, #0]
            finsh_code_dword(node->value.long_value);
 801dd42:	4b30      	ldr	r3, [pc, #192]	; (801de04 <finsh_compile+0x5a0>)
 801dd44:	681b      	ldr	r3, [r3, #0]
 801dd46:	687a      	ldr	r2, [r7, #4]
 801dd48:	6852      	ldr	r2, [r2, #4]
 801dd4a:	b2d2      	uxtb	r2, r2
 801dd4c:	701a      	strb	r2, [r3, #0]
 801dd4e:	4b2d      	ldr	r3, [pc, #180]	; (801de04 <finsh_compile+0x5a0>)
 801dd50:	681b      	ldr	r3, [r3, #0]
 801dd52:	3301      	adds	r3, #1
 801dd54:	687a      	ldr	r2, [r7, #4]
 801dd56:	6852      	ldr	r2, [r2, #4]
 801dd58:	0a12      	lsrs	r2, r2, #8
 801dd5a:	b2d2      	uxtb	r2, r2
 801dd5c:	701a      	strb	r2, [r3, #0]
 801dd5e:	4b29      	ldr	r3, [pc, #164]	; (801de04 <finsh_compile+0x5a0>)
 801dd60:	681b      	ldr	r3, [r3, #0]
 801dd62:	3302      	adds	r3, #2
 801dd64:	687a      	ldr	r2, [r7, #4]
 801dd66:	6852      	ldr	r2, [r2, #4]
 801dd68:	0c12      	lsrs	r2, r2, #16
 801dd6a:	b2d2      	uxtb	r2, r2
 801dd6c:	701a      	strb	r2, [r3, #0]
 801dd6e:	4b25      	ldr	r3, [pc, #148]	; (801de04 <finsh_compile+0x5a0>)
 801dd70:	681b      	ldr	r3, [r3, #0]
 801dd72:	3303      	adds	r3, #3
 801dd74:	687a      	ldr	r2, [r7, #4]
 801dd76:	6852      	ldr	r2, [r2, #4]
 801dd78:	0e12      	lsrs	r2, r2, #24
 801dd7a:	b2d2      	uxtb	r2, r2
 801dd7c:	701a      	strb	r2, [r3, #0]
 801dd7e:	4b21      	ldr	r3, [pc, #132]	; (801de04 <finsh_compile+0x5a0>)
 801dd80:	681b      	ldr	r3, [r3, #0]
 801dd82:	3304      	adds	r3, #4
 801dd84:	4a1f      	ldr	r2, [pc, #124]	; (801de04 <finsh_compile+0x5a0>)
 801dd86:	6013      	str	r3, [r2, #0]
            break;
 801dd88:	f001 b94b 	b.w	801f022 <finsh_compile+0x17be>

        case FINSH_NODE_VALUE_NULL:
        case FINSH_NODE_VALUE_STRING:
            finsh_code_byte(FINSH_OP_LD_DWORD);
 801dd8c:	4b1d      	ldr	r3, [pc, #116]	; (801de04 <finsh_compile+0x5a0>)
 801dd8e:	681b      	ldr	r3, [r3, #0]
 801dd90:	2224      	movs	r2, #36	; 0x24
 801dd92:	701a      	strb	r2, [r3, #0]
 801dd94:	4b1b      	ldr	r3, [pc, #108]	; (801de04 <finsh_compile+0x5a0>)
 801dd96:	681b      	ldr	r3, [r3, #0]
 801dd98:	3301      	adds	r3, #1
 801dd9a:	4a1a      	ldr	r2, [pc, #104]	; (801de04 <finsh_compile+0x5a0>)
 801dd9c:	6013      	str	r3, [r2, #0]
            finsh_code_dword((u_long)node->value.ptr);
 801dd9e:	4b19      	ldr	r3, [pc, #100]	; (801de04 <finsh_compile+0x5a0>)
 801dda0:	681b      	ldr	r3, [r3, #0]
 801dda2:	687a      	ldr	r2, [r7, #4]
 801dda4:	6852      	ldr	r2, [r2, #4]
 801dda6:	b2d2      	uxtb	r2, r2
 801dda8:	701a      	strb	r2, [r3, #0]
 801ddaa:	4b16      	ldr	r3, [pc, #88]	; (801de04 <finsh_compile+0x5a0>)
 801ddac:	681b      	ldr	r3, [r3, #0]
 801ddae:	3301      	adds	r3, #1
 801ddb0:	687a      	ldr	r2, [r7, #4]
 801ddb2:	6852      	ldr	r2, [r2, #4]
 801ddb4:	0a12      	lsrs	r2, r2, #8
 801ddb6:	b2d2      	uxtb	r2, r2
 801ddb8:	701a      	strb	r2, [r3, #0]
 801ddba:	4b12      	ldr	r3, [pc, #72]	; (801de04 <finsh_compile+0x5a0>)
 801ddbc:	681b      	ldr	r3, [r3, #0]
 801ddbe:	3302      	adds	r3, #2
 801ddc0:	687a      	ldr	r2, [r7, #4]
 801ddc2:	6852      	ldr	r2, [r2, #4]
 801ddc4:	0c12      	lsrs	r2, r2, #16
 801ddc6:	b2d2      	uxtb	r2, r2
 801ddc8:	701a      	strb	r2, [r3, #0]
 801ddca:	4b0e      	ldr	r3, [pc, #56]	; (801de04 <finsh_compile+0x5a0>)
 801ddcc:	681b      	ldr	r3, [r3, #0]
 801ddce:	3303      	adds	r3, #3
 801ddd0:	687a      	ldr	r2, [r7, #4]
 801ddd2:	6852      	ldr	r2, [r2, #4]
 801ddd4:	0e12      	lsrs	r2, r2, #24
 801ddd6:	b2d2      	uxtb	r2, r2
 801ddd8:	701a      	strb	r2, [r3, #0]
 801ddda:	4b0a      	ldr	r3, [pc, #40]	; (801de04 <finsh_compile+0x5a0>)
 801dddc:	681b      	ldr	r3, [r3, #0]
 801ddde:	3304      	adds	r3, #4
 801dde0:	4a08      	ldr	r2, [pc, #32]	; (801de04 <finsh_compile+0x5a0>)
 801dde2:	6013      	str	r3, [r2, #0]
            break;
 801dde4:	f001 b91d 	b.w	801f022 <finsh_compile+0x17be>

        /* arithmetic operation */
        case FINSH_NODE_SYS_ADD:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_ADD_BYTE);
 801dde8:	687b      	ldr	r3, [r7, #4]
 801ddea:	785b      	ldrb	r3, [r3, #1]
 801ddec:	2b01      	cmp	r3, #1
 801ddee:	d10b      	bne.n	801de08 <finsh_compile+0x5a4>
 801ddf0:	4b04      	ldr	r3, [pc, #16]	; (801de04 <finsh_compile+0x5a0>)
 801ddf2:	681b      	ldr	r3, [r3, #0]
 801ddf4:	2201      	movs	r2, #1
 801ddf6:	701a      	strb	r2, [r3, #0]
 801ddf8:	4b02      	ldr	r3, [pc, #8]	; (801de04 <finsh_compile+0x5a0>)
 801ddfa:	681b      	ldr	r3, [r3, #0]
 801ddfc:	3301      	adds	r3, #1
 801ddfe:	4a01      	ldr	r2, [pc, #4]	; (801de04 <finsh_compile+0x5a0>)
 801de00:	6013      	str	r3, [r2, #0]
 801de02:	e01e      	b.n	801de42 <finsh_compile+0x5de>
 801de04:	20012bdc 	.word	0x20012bdc
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_ADD_WORD);
 801de08:	687b      	ldr	r3, [r7, #4]
 801de0a:	785b      	ldrb	r3, [r3, #1]
 801de0c:	2b02      	cmp	r3, #2
 801de0e:	d109      	bne.n	801de24 <finsh_compile+0x5c0>
 801de10:	4b94      	ldr	r3, [pc, #592]	; (801e064 <finsh_compile+0x800>)
 801de12:	681b      	ldr	r3, [r3, #0]
 801de14:	2202      	movs	r2, #2
 801de16:	701a      	strb	r2, [r3, #0]
 801de18:	4b92      	ldr	r3, [pc, #584]	; (801e064 <finsh_compile+0x800>)
 801de1a:	681b      	ldr	r3, [r3, #0]
 801de1c:	3301      	adds	r3, #1
 801de1e:	4a91      	ldr	r2, [pc, #580]	; (801e064 <finsh_compile+0x800>)
 801de20:	6013      	str	r3, [r2, #0]
 801de22:	e00e      	b.n	801de42 <finsh_compile+0x5de>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_ADD_DWORD);
 801de24:	687b      	ldr	r3, [r7, #4]
 801de26:	785b      	ldrb	r3, [r3, #1]
 801de28:	2b03      	cmp	r3, #3
 801de2a:	d10a      	bne.n	801de42 <finsh_compile+0x5de>
 801de2c:	4b8d      	ldr	r3, [pc, #564]	; (801e064 <finsh_compile+0x800>)
 801de2e:	681b      	ldr	r3, [r3, #0]
 801de30:	2203      	movs	r2, #3
 801de32:	701a      	strb	r2, [r3, #0]
 801de34:	4b8b      	ldr	r3, [pc, #556]	; (801e064 <finsh_compile+0x800>)
 801de36:	681b      	ldr	r3, [r3, #0]
 801de38:	3301      	adds	r3, #1
 801de3a:	4a8a      	ldr	r2, [pc, #552]	; (801e064 <finsh_compile+0x800>)
 801de3c:	6013      	str	r3, [r2, #0]
            break;
 801de3e:	f001 b8f0 	b.w	801f022 <finsh_compile+0x17be>
 801de42:	f001 b8ee 	b.w	801f022 <finsh_compile+0x17be>

        case FINSH_NODE_SYS_SUB:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_SUB_BYTE);
 801de46:	687b      	ldr	r3, [r7, #4]
 801de48:	785b      	ldrb	r3, [r3, #1]
 801de4a:	2b01      	cmp	r3, #1
 801de4c:	d109      	bne.n	801de62 <finsh_compile+0x5fe>
 801de4e:	4b85      	ldr	r3, [pc, #532]	; (801e064 <finsh_compile+0x800>)
 801de50:	681b      	ldr	r3, [r3, #0]
 801de52:	2204      	movs	r2, #4
 801de54:	701a      	strb	r2, [r3, #0]
 801de56:	4b83      	ldr	r3, [pc, #524]	; (801e064 <finsh_compile+0x800>)
 801de58:	681b      	ldr	r3, [r3, #0]
 801de5a:	3301      	adds	r3, #1
 801de5c:	4a81      	ldr	r2, [pc, #516]	; (801e064 <finsh_compile+0x800>)
 801de5e:	6013      	str	r3, [r2, #0]
 801de60:	e01c      	b.n	801de9c <finsh_compile+0x638>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_SUB_WORD);
 801de62:	687b      	ldr	r3, [r7, #4]
 801de64:	785b      	ldrb	r3, [r3, #1]
 801de66:	2b02      	cmp	r3, #2
 801de68:	d109      	bne.n	801de7e <finsh_compile+0x61a>
 801de6a:	4b7e      	ldr	r3, [pc, #504]	; (801e064 <finsh_compile+0x800>)
 801de6c:	681b      	ldr	r3, [r3, #0]
 801de6e:	2205      	movs	r2, #5
 801de70:	701a      	strb	r2, [r3, #0]
 801de72:	4b7c      	ldr	r3, [pc, #496]	; (801e064 <finsh_compile+0x800>)
 801de74:	681b      	ldr	r3, [r3, #0]
 801de76:	3301      	adds	r3, #1
 801de78:	4a7a      	ldr	r2, [pc, #488]	; (801e064 <finsh_compile+0x800>)
 801de7a:	6013      	str	r3, [r2, #0]
 801de7c:	e00e      	b.n	801de9c <finsh_compile+0x638>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_SUB_DWORD);
 801de7e:	687b      	ldr	r3, [r7, #4]
 801de80:	785b      	ldrb	r3, [r3, #1]
 801de82:	2b03      	cmp	r3, #3
 801de84:	d10a      	bne.n	801de9c <finsh_compile+0x638>
 801de86:	4b77      	ldr	r3, [pc, #476]	; (801e064 <finsh_compile+0x800>)
 801de88:	681b      	ldr	r3, [r3, #0]
 801de8a:	2206      	movs	r2, #6
 801de8c:	701a      	strb	r2, [r3, #0]
 801de8e:	4b75      	ldr	r3, [pc, #468]	; (801e064 <finsh_compile+0x800>)
 801de90:	681b      	ldr	r3, [r3, #0]
 801de92:	3301      	adds	r3, #1
 801de94:	4a73      	ldr	r2, [pc, #460]	; (801e064 <finsh_compile+0x800>)
 801de96:	6013      	str	r3, [r2, #0]
            break;
 801de98:	f001 b8c3 	b.w	801f022 <finsh_compile+0x17be>
 801de9c:	f001 b8c1 	b.w	801f022 <finsh_compile+0x17be>

        case FINSH_NODE_SYS_MUL:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_MUL_BYTE);
 801dea0:	687b      	ldr	r3, [r7, #4]
 801dea2:	785b      	ldrb	r3, [r3, #1]
 801dea4:	2b01      	cmp	r3, #1
 801dea6:	d109      	bne.n	801debc <finsh_compile+0x658>
 801dea8:	4b6e      	ldr	r3, [pc, #440]	; (801e064 <finsh_compile+0x800>)
 801deaa:	681b      	ldr	r3, [r3, #0]
 801deac:	220d      	movs	r2, #13
 801deae:	701a      	strb	r2, [r3, #0]
 801deb0:	4b6c      	ldr	r3, [pc, #432]	; (801e064 <finsh_compile+0x800>)
 801deb2:	681b      	ldr	r3, [r3, #0]
 801deb4:	3301      	adds	r3, #1
 801deb6:	4a6b      	ldr	r2, [pc, #428]	; (801e064 <finsh_compile+0x800>)
 801deb8:	6013      	str	r3, [r2, #0]
 801deba:	e01c      	b.n	801def6 <finsh_compile+0x692>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_MUL_WORD);
 801debc:	687b      	ldr	r3, [r7, #4]
 801debe:	785b      	ldrb	r3, [r3, #1]
 801dec0:	2b02      	cmp	r3, #2
 801dec2:	d109      	bne.n	801ded8 <finsh_compile+0x674>
 801dec4:	4b67      	ldr	r3, [pc, #412]	; (801e064 <finsh_compile+0x800>)
 801dec6:	681b      	ldr	r3, [r3, #0]
 801dec8:	220e      	movs	r2, #14
 801deca:	701a      	strb	r2, [r3, #0]
 801decc:	4b65      	ldr	r3, [pc, #404]	; (801e064 <finsh_compile+0x800>)
 801dece:	681b      	ldr	r3, [r3, #0]
 801ded0:	3301      	adds	r3, #1
 801ded2:	4a64      	ldr	r2, [pc, #400]	; (801e064 <finsh_compile+0x800>)
 801ded4:	6013      	str	r3, [r2, #0]
 801ded6:	e00e      	b.n	801def6 <finsh_compile+0x692>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_MUL_DWORD);
 801ded8:	687b      	ldr	r3, [r7, #4]
 801deda:	785b      	ldrb	r3, [r3, #1]
 801dedc:	2b03      	cmp	r3, #3
 801dede:	d10a      	bne.n	801def6 <finsh_compile+0x692>
 801dee0:	4b60      	ldr	r3, [pc, #384]	; (801e064 <finsh_compile+0x800>)
 801dee2:	681b      	ldr	r3, [r3, #0]
 801dee4:	220f      	movs	r2, #15
 801dee6:	701a      	strb	r2, [r3, #0]
 801dee8:	4b5e      	ldr	r3, [pc, #376]	; (801e064 <finsh_compile+0x800>)
 801deea:	681b      	ldr	r3, [r3, #0]
 801deec:	3301      	adds	r3, #1
 801deee:	4a5d      	ldr	r2, [pc, #372]	; (801e064 <finsh_compile+0x800>)
 801def0:	6013      	str	r3, [r2, #0]
            break;
 801def2:	f001 b896 	b.w	801f022 <finsh_compile+0x17be>
 801def6:	f001 b894 	b.w	801f022 <finsh_compile+0x17be>

        case FINSH_NODE_SYS_DIV:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_DIV_BYTE);
 801defa:	687b      	ldr	r3, [r7, #4]
 801defc:	785b      	ldrb	r3, [r3, #1]
 801defe:	2b01      	cmp	r3, #1
 801df00:	d109      	bne.n	801df16 <finsh_compile+0x6b2>
 801df02:	4b58      	ldr	r3, [pc, #352]	; (801e064 <finsh_compile+0x800>)
 801df04:	681b      	ldr	r3, [r3, #0]
 801df06:	2207      	movs	r2, #7
 801df08:	701a      	strb	r2, [r3, #0]
 801df0a:	4b56      	ldr	r3, [pc, #344]	; (801e064 <finsh_compile+0x800>)
 801df0c:	681b      	ldr	r3, [r3, #0]
 801df0e:	3301      	adds	r3, #1
 801df10:	4a54      	ldr	r2, [pc, #336]	; (801e064 <finsh_compile+0x800>)
 801df12:	6013      	str	r3, [r2, #0]
 801df14:	e01c      	b.n	801df50 <finsh_compile+0x6ec>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_DIV_WORD);
 801df16:	687b      	ldr	r3, [r7, #4]
 801df18:	785b      	ldrb	r3, [r3, #1]
 801df1a:	2b02      	cmp	r3, #2
 801df1c:	d109      	bne.n	801df32 <finsh_compile+0x6ce>
 801df1e:	4b51      	ldr	r3, [pc, #324]	; (801e064 <finsh_compile+0x800>)
 801df20:	681b      	ldr	r3, [r3, #0]
 801df22:	2208      	movs	r2, #8
 801df24:	701a      	strb	r2, [r3, #0]
 801df26:	4b4f      	ldr	r3, [pc, #316]	; (801e064 <finsh_compile+0x800>)
 801df28:	681b      	ldr	r3, [r3, #0]
 801df2a:	3301      	adds	r3, #1
 801df2c:	4a4d      	ldr	r2, [pc, #308]	; (801e064 <finsh_compile+0x800>)
 801df2e:	6013      	str	r3, [r2, #0]
 801df30:	e00e      	b.n	801df50 <finsh_compile+0x6ec>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_DIV_DWORD);
 801df32:	687b      	ldr	r3, [r7, #4]
 801df34:	785b      	ldrb	r3, [r3, #1]
 801df36:	2b03      	cmp	r3, #3
 801df38:	d10a      	bne.n	801df50 <finsh_compile+0x6ec>
 801df3a:	4b4a      	ldr	r3, [pc, #296]	; (801e064 <finsh_compile+0x800>)
 801df3c:	681b      	ldr	r3, [r3, #0]
 801df3e:	2209      	movs	r2, #9
 801df40:	701a      	strb	r2, [r3, #0]
 801df42:	4b48      	ldr	r3, [pc, #288]	; (801e064 <finsh_compile+0x800>)
 801df44:	681b      	ldr	r3, [r3, #0]
 801df46:	3301      	adds	r3, #1
 801df48:	4a46      	ldr	r2, [pc, #280]	; (801e064 <finsh_compile+0x800>)
 801df4a:	6013      	str	r3, [r2, #0]
            break;
 801df4c:	f001 b869 	b.w	801f022 <finsh_compile+0x17be>
 801df50:	f001 b867 	b.w	801f022 <finsh_compile+0x17be>

        case FINSH_NODE_SYS_MOD:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_MOD_BYTE);
 801df54:	687b      	ldr	r3, [r7, #4]
 801df56:	785b      	ldrb	r3, [r3, #1]
 801df58:	2b01      	cmp	r3, #1
 801df5a:	d109      	bne.n	801df70 <finsh_compile+0x70c>
 801df5c:	4b41      	ldr	r3, [pc, #260]	; (801e064 <finsh_compile+0x800>)
 801df5e:	681b      	ldr	r3, [r3, #0]
 801df60:	220a      	movs	r2, #10
 801df62:	701a      	strb	r2, [r3, #0]
 801df64:	4b3f      	ldr	r3, [pc, #252]	; (801e064 <finsh_compile+0x800>)
 801df66:	681b      	ldr	r3, [r3, #0]
 801df68:	3301      	adds	r3, #1
 801df6a:	4a3e      	ldr	r2, [pc, #248]	; (801e064 <finsh_compile+0x800>)
 801df6c:	6013      	str	r3, [r2, #0]
 801df6e:	e01c      	b.n	801dfaa <finsh_compile+0x746>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_MOD_WORD);
 801df70:	687b      	ldr	r3, [r7, #4]
 801df72:	785b      	ldrb	r3, [r3, #1]
 801df74:	2b02      	cmp	r3, #2
 801df76:	d109      	bne.n	801df8c <finsh_compile+0x728>
 801df78:	4b3a      	ldr	r3, [pc, #232]	; (801e064 <finsh_compile+0x800>)
 801df7a:	681b      	ldr	r3, [r3, #0]
 801df7c:	220b      	movs	r2, #11
 801df7e:	701a      	strb	r2, [r3, #0]
 801df80:	4b38      	ldr	r3, [pc, #224]	; (801e064 <finsh_compile+0x800>)
 801df82:	681b      	ldr	r3, [r3, #0]
 801df84:	3301      	adds	r3, #1
 801df86:	4a37      	ldr	r2, [pc, #220]	; (801e064 <finsh_compile+0x800>)
 801df88:	6013      	str	r3, [r2, #0]
 801df8a:	e00e      	b.n	801dfaa <finsh_compile+0x746>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_MOD_DWORD);
 801df8c:	687b      	ldr	r3, [r7, #4]
 801df8e:	785b      	ldrb	r3, [r3, #1]
 801df90:	2b03      	cmp	r3, #3
 801df92:	d10a      	bne.n	801dfaa <finsh_compile+0x746>
 801df94:	4b33      	ldr	r3, [pc, #204]	; (801e064 <finsh_compile+0x800>)
 801df96:	681b      	ldr	r3, [r3, #0]
 801df98:	220c      	movs	r2, #12
 801df9a:	701a      	strb	r2, [r3, #0]
 801df9c:	4b31      	ldr	r3, [pc, #196]	; (801e064 <finsh_compile+0x800>)
 801df9e:	681b      	ldr	r3, [r3, #0]
 801dfa0:	3301      	adds	r3, #1
 801dfa2:	4a30      	ldr	r2, [pc, #192]	; (801e064 <finsh_compile+0x800>)
 801dfa4:	6013      	str	r3, [r2, #0]
            break;
 801dfa6:	f001 b83c 	b.w	801f022 <finsh_compile+0x17be>
 801dfaa:	f001 b83a 	b.w	801f022 <finsh_compile+0x17be>

        /* bit operation */
        case FINSH_NODE_SYS_AND:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_AND_BYTE);
 801dfae:	687b      	ldr	r3, [r7, #4]
 801dfb0:	785b      	ldrb	r3, [r3, #1]
 801dfb2:	2b01      	cmp	r3, #1
 801dfb4:	d109      	bne.n	801dfca <finsh_compile+0x766>
 801dfb6:	4b2b      	ldr	r3, [pc, #172]	; (801e064 <finsh_compile+0x800>)
 801dfb8:	681b      	ldr	r3, [r3, #0]
 801dfba:	2210      	movs	r2, #16
 801dfbc:	701a      	strb	r2, [r3, #0]
 801dfbe:	4b29      	ldr	r3, [pc, #164]	; (801e064 <finsh_compile+0x800>)
 801dfc0:	681b      	ldr	r3, [r3, #0]
 801dfc2:	3301      	adds	r3, #1
 801dfc4:	4a27      	ldr	r2, [pc, #156]	; (801e064 <finsh_compile+0x800>)
 801dfc6:	6013      	str	r3, [r2, #0]
 801dfc8:	e01c      	b.n	801e004 <finsh_compile+0x7a0>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_AND_WORD);
 801dfca:	687b      	ldr	r3, [r7, #4]
 801dfcc:	785b      	ldrb	r3, [r3, #1]
 801dfce:	2b02      	cmp	r3, #2
 801dfd0:	d109      	bne.n	801dfe6 <finsh_compile+0x782>
 801dfd2:	4b24      	ldr	r3, [pc, #144]	; (801e064 <finsh_compile+0x800>)
 801dfd4:	681b      	ldr	r3, [r3, #0]
 801dfd6:	2211      	movs	r2, #17
 801dfd8:	701a      	strb	r2, [r3, #0]
 801dfda:	4b22      	ldr	r3, [pc, #136]	; (801e064 <finsh_compile+0x800>)
 801dfdc:	681b      	ldr	r3, [r3, #0]
 801dfde:	3301      	adds	r3, #1
 801dfe0:	4a20      	ldr	r2, [pc, #128]	; (801e064 <finsh_compile+0x800>)
 801dfe2:	6013      	str	r3, [r2, #0]
 801dfe4:	e00e      	b.n	801e004 <finsh_compile+0x7a0>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_AND_DWORD);
 801dfe6:	687b      	ldr	r3, [r7, #4]
 801dfe8:	785b      	ldrb	r3, [r3, #1]
 801dfea:	2b03      	cmp	r3, #3
 801dfec:	d10a      	bne.n	801e004 <finsh_compile+0x7a0>
 801dfee:	4b1d      	ldr	r3, [pc, #116]	; (801e064 <finsh_compile+0x800>)
 801dff0:	681b      	ldr	r3, [r3, #0]
 801dff2:	2212      	movs	r2, #18
 801dff4:	701a      	strb	r2, [r3, #0]
 801dff6:	4b1b      	ldr	r3, [pc, #108]	; (801e064 <finsh_compile+0x800>)
 801dff8:	681b      	ldr	r3, [r3, #0]
 801dffa:	3301      	adds	r3, #1
 801dffc:	4a19      	ldr	r2, [pc, #100]	; (801e064 <finsh_compile+0x800>)
 801dffe:	6013      	str	r3, [r2, #0]
            break;
 801e000:	f001 b80f 	b.w	801f022 <finsh_compile+0x17be>
 801e004:	f001 b80d 	b.w	801f022 <finsh_compile+0x17be>

        case FINSH_NODE_SYS_OR:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_OR_BYTE);
 801e008:	687b      	ldr	r3, [r7, #4]
 801e00a:	785b      	ldrb	r3, [r3, #1]
 801e00c:	2b01      	cmp	r3, #1
 801e00e:	d109      	bne.n	801e024 <finsh_compile+0x7c0>
 801e010:	4b14      	ldr	r3, [pc, #80]	; (801e064 <finsh_compile+0x800>)
 801e012:	681b      	ldr	r3, [r3, #0]
 801e014:	2213      	movs	r2, #19
 801e016:	701a      	strb	r2, [r3, #0]
 801e018:	4b12      	ldr	r3, [pc, #72]	; (801e064 <finsh_compile+0x800>)
 801e01a:	681b      	ldr	r3, [r3, #0]
 801e01c:	3301      	adds	r3, #1
 801e01e:	4a11      	ldr	r2, [pc, #68]	; (801e064 <finsh_compile+0x800>)
 801e020:	6013      	str	r3, [r2, #0]
 801e022:	e01c      	b.n	801e05e <finsh_compile+0x7fa>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_OR_WORD);
 801e024:	687b      	ldr	r3, [r7, #4]
 801e026:	785b      	ldrb	r3, [r3, #1]
 801e028:	2b02      	cmp	r3, #2
 801e02a:	d109      	bne.n	801e040 <finsh_compile+0x7dc>
 801e02c:	4b0d      	ldr	r3, [pc, #52]	; (801e064 <finsh_compile+0x800>)
 801e02e:	681b      	ldr	r3, [r3, #0]
 801e030:	2214      	movs	r2, #20
 801e032:	701a      	strb	r2, [r3, #0]
 801e034:	4b0b      	ldr	r3, [pc, #44]	; (801e064 <finsh_compile+0x800>)
 801e036:	681b      	ldr	r3, [r3, #0]
 801e038:	3301      	adds	r3, #1
 801e03a:	4a0a      	ldr	r2, [pc, #40]	; (801e064 <finsh_compile+0x800>)
 801e03c:	6013      	str	r3, [r2, #0]
 801e03e:	e00e      	b.n	801e05e <finsh_compile+0x7fa>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_OR_DWORD);
 801e040:	687b      	ldr	r3, [r7, #4]
 801e042:	785b      	ldrb	r3, [r3, #1]
 801e044:	2b03      	cmp	r3, #3
 801e046:	d10a      	bne.n	801e05e <finsh_compile+0x7fa>
 801e048:	4b06      	ldr	r3, [pc, #24]	; (801e064 <finsh_compile+0x800>)
 801e04a:	681b      	ldr	r3, [r3, #0]
 801e04c:	2215      	movs	r2, #21
 801e04e:	701a      	strb	r2, [r3, #0]
 801e050:	4b04      	ldr	r3, [pc, #16]	; (801e064 <finsh_compile+0x800>)
 801e052:	681b      	ldr	r3, [r3, #0]
 801e054:	3301      	adds	r3, #1
 801e056:	4a03      	ldr	r2, [pc, #12]	; (801e064 <finsh_compile+0x800>)
 801e058:	6013      	str	r3, [r2, #0]
            break;
 801e05a:	f000 bfe2 	b.w	801f022 <finsh_compile+0x17be>
 801e05e:	f000 bfe0 	b.w	801f022 <finsh_compile+0x17be>
 801e062:	bf00      	nop
 801e064:	20012bdc 	.word	0x20012bdc

        case FINSH_NODE_SYS_XOR:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_XOR_BYTE);
 801e068:	687b      	ldr	r3, [r7, #4]
 801e06a:	785b      	ldrb	r3, [r3, #1]
 801e06c:	2b01      	cmp	r3, #1
 801e06e:	d109      	bne.n	801e084 <finsh_compile+0x820>
 801e070:	4b95      	ldr	r3, [pc, #596]	; (801e2c8 <finsh_compile+0xa64>)
 801e072:	681b      	ldr	r3, [r3, #0]
 801e074:	2216      	movs	r2, #22
 801e076:	701a      	strb	r2, [r3, #0]
 801e078:	4b93      	ldr	r3, [pc, #588]	; (801e2c8 <finsh_compile+0xa64>)
 801e07a:	681b      	ldr	r3, [r3, #0]
 801e07c:	3301      	adds	r3, #1
 801e07e:	4a92      	ldr	r2, [pc, #584]	; (801e2c8 <finsh_compile+0xa64>)
 801e080:	6013      	str	r3, [r2, #0]
 801e082:	e01c      	b.n	801e0be <finsh_compile+0x85a>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_XOR_WORD);
 801e084:	687b      	ldr	r3, [r7, #4]
 801e086:	785b      	ldrb	r3, [r3, #1]
 801e088:	2b02      	cmp	r3, #2
 801e08a:	d109      	bne.n	801e0a0 <finsh_compile+0x83c>
 801e08c:	4b8e      	ldr	r3, [pc, #568]	; (801e2c8 <finsh_compile+0xa64>)
 801e08e:	681b      	ldr	r3, [r3, #0]
 801e090:	2217      	movs	r2, #23
 801e092:	701a      	strb	r2, [r3, #0]
 801e094:	4b8c      	ldr	r3, [pc, #560]	; (801e2c8 <finsh_compile+0xa64>)
 801e096:	681b      	ldr	r3, [r3, #0]
 801e098:	3301      	adds	r3, #1
 801e09a:	4a8b      	ldr	r2, [pc, #556]	; (801e2c8 <finsh_compile+0xa64>)
 801e09c:	6013      	str	r3, [r2, #0]
 801e09e:	e00e      	b.n	801e0be <finsh_compile+0x85a>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_XOR_DWORD);
 801e0a0:	687b      	ldr	r3, [r7, #4]
 801e0a2:	785b      	ldrb	r3, [r3, #1]
 801e0a4:	2b03      	cmp	r3, #3
 801e0a6:	d10a      	bne.n	801e0be <finsh_compile+0x85a>
 801e0a8:	4b87      	ldr	r3, [pc, #540]	; (801e2c8 <finsh_compile+0xa64>)
 801e0aa:	681b      	ldr	r3, [r3, #0]
 801e0ac:	2218      	movs	r2, #24
 801e0ae:	701a      	strb	r2, [r3, #0]
 801e0b0:	4b85      	ldr	r3, [pc, #532]	; (801e2c8 <finsh_compile+0xa64>)
 801e0b2:	681b      	ldr	r3, [r3, #0]
 801e0b4:	3301      	adds	r3, #1
 801e0b6:	4a84      	ldr	r2, [pc, #528]	; (801e2c8 <finsh_compile+0xa64>)
 801e0b8:	6013      	str	r3, [r2, #0]
            break;
 801e0ba:	f000 bfb2 	b.w	801f022 <finsh_compile+0x17be>
 801e0be:	f000 bfb0 	b.w	801f022 <finsh_compile+0x17be>

        case FINSH_NODE_SYS_BITWISE:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_BITWISE_BYTE);
 801e0c2:	687b      	ldr	r3, [r7, #4]
 801e0c4:	785b      	ldrb	r3, [r3, #1]
 801e0c6:	2b01      	cmp	r3, #1
 801e0c8:	d109      	bne.n	801e0de <finsh_compile+0x87a>
 801e0ca:	4b7f      	ldr	r3, [pc, #508]	; (801e2c8 <finsh_compile+0xa64>)
 801e0cc:	681b      	ldr	r3, [r3, #0]
 801e0ce:	2219      	movs	r2, #25
 801e0d0:	701a      	strb	r2, [r3, #0]
 801e0d2:	4b7d      	ldr	r3, [pc, #500]	; (801e2c8 <finsh_compile+0xa64>)
 801e0d4:	681b      	ldr	r3, [r3, #0]
 801e0d6:	3301      	adds	r3, #1
 801e0d8:	4a7b      	ldr	r2, [pc, #492]	; (801e2c8 <finsh_compile+0xa64>)
 801e0da:	6013      	str	r3, [r2, #0]
 801e0dc:	e01c      	b.n	801e118 <finsh_compile+0x8b4>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_BITWISE_WORD);
 801e0de:	687b      	ldr	r3, [r7, #4]
 801e0e0:	785b      	ldrb	r3, [r3, #1]
 801e0e2:	2b02      	cmp	r3, #2
 801e0e4:	d109      	bne.n	801e0fa <finsh_compile+0x896>
 801e0e6:	4b78      	ldr	r3, [pc, #480]	; (801e2c8 <finsh_compile+0xa64>)
 801e0e8:	681b      	ldr	r3, [r3, #0]
 801e0ea:	221a      	movs	r2, #26
 801e0ec:	701a      	strb	r2, [r3, #0]
 801e0ee:	4b76      	ldr	r3, [pc, #472]	; (801e2c8 <finsh_compile+0xa64>)
 801e0f0:	681b      	ldr	r3, [r3, #0]
 801e0f2:	3301      	adds	r3, #1
 801e0f4:	4a74      	ldr	r2, [pc, #464]	; (801e2c8 <finsh_compile+0xa64>)
 801e0f6:	6013      	str	r3, [r2, #0]
 801e0f8:	e00e      	b.n	801e118 <finsh_compile+0x8b4>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_BITWISE_DWORD);
 801e0fa:	687b      	ldr	r3, [r7, #4]
 801e0fc:	785b      	ldrb	r3, [r3, #1]
 801e0fe:	2b03      	cmp	r3, #3
 801e100:	d10a      	bne.n	801e118 <finsh_compile+0x8b4>
 801e102:	4b71      	ldr	r3, [pc, #452]	; (801e2c8 <finsh_compile+0xa64>)
 801e104:	681b      	ldr	r3, [r3, #0]
 801e106:	221b      	movs	r2, #27
 801e108:	701a      	strb	r2, [r3, #0]
 801e10a:	4b6f      	ldr	r3, [pc, #444]	; (801e2c8 <finsh_compile+0xa64>)
 801e10c:	681b      	ldr	r3, [r3, #0]
 801e10e:	3301      	adds	r3, #1
 801e110:	4a6d      	ldr	r2, [pc, #436]	; (801e2c8 <finsh_compile+0xa64>)
 801e112:	6013      	str	r3, [r2, #0]
            break;
 801e114:	f000 bf85 	b.w	801f022 <finsh_compile+0x17be>
 801e118:	f000 bf83 	b.w	801f022 <finsh_compile+0x17be>

        case FINSH_NODE_SYS_SHL:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_SHL_BYTE);
 801e11c:	687b      	ldr	r3, [r7, #4]
 801e11e:	785b      	ldrb	r3, [r3, #1]
 801e120:	2b01      	cmp	r3, #1
 801e122:	d109      	bne.n	801e138 <finsh_compile+0x8d4>
 801e124:	4b68      	ldr	r3, [pc, #416]	; (801e2c8 <finsh_compile+0xa64>)
 801e126:	681b      	ldr	r3, [r3, #0]
 801e128:	221c      	movs	r2, #28
 801e12a:	701a      	strb	r2, [r3, #0]
 801e12c:	4b66      	ldr	r3, [pc, #408]	; (801e2c8 <finsh_compile+0xa64>)
 801e12e:	681b      	ldr	r3, [r3, #0]
 801e130:	3301      	adds	r3, #1
 801e132:	4a65      	ldr	r2, [pc, #404]	; (801e2c8 <finsh_compile+0xa64>)
 801e134:	6013      	str	r3, [r2, #0]
 801e136:	e01c      	b.n	801e172 <finsh_compile+0x90e>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_SHL_WORD);
 801e138:	687b      	ldr	r3, [r7, #4]
 801e13a:	785b      	ldrb	r3, [r3, #1]
 801e13c:	2b02      	cmp	r3, #2
 801e13e:	d109      	bne.n	801e154 <finsh_compile+0x8f0>
 801e140:	4b61      	ldr	r3, [pc, #388]	; (801e2c8 <finsh_compile+0xa64>)
 801e142:	681b      	ldr	r3, [r3, #0]
 801e144:	221d      	movs	r2, #29
 801e146:	701a      	strb	r2, [r3, #0]
 801e148:	4b5f      	ldr	r3, [pc, #380]	; (801e2c8 <finsh_compile+0xa64>)
 801e14a:	681b      	ldr	r3, [r3, #0]
 801e14c:	3301      	adds	r3, #1
 801e14e:	4a5e      	ldr	r2, [pc, #376]	; (801e2c8 <finsh_compile+0xa64>)
 801e150:	6013      	str	r3, [r2, #0]
 801e152:	e00e      	b.n	801e172 <finsh_compile+0x90e>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_SHL_DWORD);
 801e154:	687b      	ldr	r3, [r7, #4]
 801e156:	785b      	ldrb	r3, [r3, #1]
 801e158:	2b03      	cmp	r3, #3
 801e15a:	d10a      	bne.n	801e172 <finsh_compile+0x90e>
 801e15c:	4b5a      	ldr	r3, [pc, #360]	; (801e2c8 <finsh_compile+0xa64>)
 801e15e:	681b      	ldr	r3, [r3, #0]
 801e160:	221e      	movs	r2, #30
 801e162:	701a      	strb	r2, [r3, #0]
 801e164:	4b58      	ldr	r3, [pc, #352]	; (801e2c8 <finsh_compile+0xa64>)
 801e166:	681b      	ldr	r3, [r3, #0]
 801e168:	3301      	adds	r3, #1
 801e16a:	4a57      	ldr	r2, [pc, #348]	; (801e2c8 <finsh_compile+0xa64>)
 801e16c:	6013      	str	r3, [r2, #0]
            break;
 801e16e:	f000 bf58 	b.w	801f022 <finsh_compile+0x17be>
 801e172:	f000 bf56 	b.w	801f022 <finsh_compile+0x17be>

        case FINSH_NODE_SYS_SHR:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_SHR_BYTE);
 801e176:	687b      	ldr	r3, [r7, #4]
 801e178:	785b      	ldrb	r3, [r3, #1]
 801e17a:	2b01      	cmp	r3, #1
 801e17c:	d109      	bne.n	801e192 <finsh_compile+0x92e>
 801e17e:	4b52      	ldr	r3, [pc, #328]	; (801e2c8 <finsh_compile+0xa64>)
 801e180:	681b      	ldr	r3, [r3, #0]
 801e182:	221f      	movs	r2, #31
 801e184:	701a      	strb	r2, [r3, #0]
 801e186:	4b50      	ldr	r3, [pc, #320]	; (801e2c8 <finsh_compile+0xa64>)
 801e188:	681b      	ldr	r3, [r3, #0]
 801e18a:	3301      	adds	r3, #1
 801e18c:	4a4e      	ldr	r2, [pc, #312]	; (801e2c8 <finsh_compile+0xa64>)
 801e18e:	6013      	str	r3, [r2, #0]
 801e190:	e01c      	b.n	801e1cc <finsh_compile+0x968>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_SHR_WORD);
 801e192:	687b      	ldr	r3, [r7, #4]
 801e194:	785b      	ldrb	r3, [r3, #1]
 801e196:	2b02      	cmp	r3, #2
 801e198:	d109      	bne.n	801e1ae <finsh_compile+0x94a>
 801e19a:	4b4b      	ldr	r3, [pc, #300]	; (801e2c8 <finsh_compile+0xa64>)
 801e19c:	681b      	ldr	r3, [r3, #0]
 801e19e:	2220      	movs	r2, #32
 801e1a0:	701a      	strb	r2, [r3, #0]
 801e1a2:	4b49      	ldr	r3, [pc, #292]	; (801e2c8 <finsh_compile+0xa64>)
 801e1a4:	681b      	ldr	r3, [r3, #0]
 801e1a6:	3301      	adds	r3, #1
 801e1a8:	4a47      	ldr	r2, [pc, #284]	; (801e2c8 <finsh_compile+0xa64>)
 801e1aa:	6013      	str	r3, [r2, #0]
 801e1ac:	e00e      	b.n	801e1cc <finsh_compile+0x968>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_SHR_DWORD);
 801e1ae:	687b      	ldr	r3, [r7, #4]
 801e1b0:	785b      	ldrb	r3, [r3, #1]
 801e1b2:	2b03      	cmp	r3, #3
 801e1b4:	d10a      	bne.n	801e1cc <finsh_compile+0x968>
 801e1b6:	4b44      	ldr	r3, [pc, #272]	; (801e2c8 <finsh_compile+0xa64>)
 801e1b8:	681b      	ldr	r3, [r3, #0]
 801e1ba:	2221      	movs	r2, #33	; 0x21
 801e1bc:	701a      	strb	r2, [r3, #0]
 801e1be:	4b42      	ldr	r3, [pc, #264]	; (801e2c8 <finsh_compile+0xa64>)
 801e1c0:	681b      	ldr	r3, [r3, #0]
 801e1c2:	3301      	adds	r3, #1
 801e1c4:	4a40      	ldr	r2, [pc, #256]	; (801e2c8 <finsh_compile+0xa64>)
 801e1c6:	6013      	str	r3, [r2, #0]
            break;
 801e1c8:	f000 bf2b 	b.w	801f022 <finsh_compile+0x17be>
 801e1cc:	f000 bf29 	b.w	801f022 <finsh_compile+0x17be>
        case FINSH_NODE_SYS_FUNC:
            {
                int parameters;
                struct finsh_node* sibling;

                parameters = 0;
 801e1d0:	2300      	movs	r3, #0
 801e1d2:	627b      	str	r3, [r7, #36]	; 0x24
                if (finsh_node_child(node) != NULL)
 801e1d4:	687b      	ldr	r3, [r7, #4]
 801e1d6:	691b      	ldr	r3, [r3, #16]
 801e1d8:	2b00      	cmp	r3, #0
 801e1da:	d022      	beq.n	801e222 <finsh_compile+0x9be>
                {
                    sibling = finsh_node_sibling(finsh_node_child(node));
 801e1dc:	687b      	ldr	r3, [r7, #4]
 801e1de:	691b      	ldr	r3, [r3, #16]
 801e1e0:	68db      	ldr	r3, [r3, #12]
 801e1e2:	623b      	str	r3, [r7, #32]
                    while (sibling != NULL)
 801e1e4:	e005      	b.n	801e1f2 <finsh_compile+0x98e>
                    {
                        parameters ++;
 801e1e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e1e8:	3301      	adds	r3, #1
 801e1ea:	627b      	str	r3, [r7, #36]	; 0x24
                        sibling = finsh_node_sibling(sibling);
 801e1ec:	6a3b      	ldr	r3, [r7, #32]
 801e1ee:	68db      	ldr	r3, [r3, #12]
 801e1f0:	623b      	str	r3, [r7, #32]

                parameters = 0;
                if (finsh_node_child(node) != NULL)
                {
                    sibling = finsh_node_sibling(finsh_node_child(node));
                    while (sibling != NULL)
 801e1f2:	6a3b      	ldr	r3, [r7, #32]
 801e1f4:	2b00      	cmp	r3, #0
 801e1f6:	d1f6      	bne.n	801e1e6 <finsh_compile+0x982>

                    /* load address of function */
                    // finsh_code_dword((long)&(node->var->value.ptr));

                    /* syscall parameters */
                    finsh_code_byte(FINSH_OP_SYSCALL);
 801e1f8:	4b33      	ldr	r3, [pc, #204]	; (801e2c8 <finsh_compile+0xa64>)
 801e1fa:	681b      	ldr	r3, [r3, #0]
 801e1fc:	222c      	movs	r2, #44	; 0x2c
 801e1fe:	701a      	strb	r2, [r3, #0]
 801e200:	4b31      	ldr	r3, [pc, #196]	; (801e2c8 <finsh_compile+0xa64>)
 801e202:	681b      	ldr	r3, [r3, #0]
 801e204:	3301      	adds	r3, #1
 801e206:	4a30      	ldr	r2, [pc, #192]	; (801e2c8 <finsh_compile+0xa64>)
 801e208:	6013      	str	r3, [r2, #0]
                    finsh_code_byte(parameters);
 801e20a:	4b2f      	ldr	r3, [pc, #188]	; (801e2c8 <finsh_compile+0xa64>)
 801e20c:	681b      	ldr	r3, [r3, #0]
 801e20e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801e210:	b2d2      	uxtb	r2, r2
 801e212:	701a      	strb	r2, [r3, #0]
 801e214:	4b2c      	ldr	r3, [pc, #176]	; (801e2c8 <finsh_compile+0xa64>)
 801e216:	681b      	ldr	r3, [r3, #0]
 801e218:	3301      	adds	r3, #1
 801e21a:	4a2b      	ldr	r2, [pc, #172]	; (801e2c8 <finsh_compile+0xa64>)
 801e21c:	6013      	str	r3, [r2, #0]
                }
            }
            break;
 801e21e:	f000 bf00 	b.w	801f022 <finsh_compile+0x17be>
 801e222:	f000 befe 	b.w	801f022 <finsh_compile+0x17be>

        /* assign expression */
        case FINSH_NODE_SYS_ASSIGN:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
 801e226:	687b      	ldr	r3, [r7, #4]
 801e228:	691b      	ldr	r3, [r3, #16]
 801e22a:	2b00      	cmp	r3, #0
 801e22c:	d04e      	beq.n	801e2cc <finsh_compile+0xa68>
 801e22e:	687b      	ldr	r3, [r7, #4]
 801e230:	691b      	ldr	r3, [r3, #16]
 801e232:	781b      	ldrb	r3, [r3, #0]
 801e234:	2b01      	cmp	r3, #1
 801e236:	d149      	bne.n	801e2cc <finsh_compile+0xa68>
            {
                switch (finsh_node_child(node)->data_type)
 801e238:	687b      	ldr	r3, [r7, #4]
 801e23a:	691b      	ldr	r3, [r3, #16]
 801e23c:	785b      	ldrb	r3, [r3, #1]
 801e23e:	2b02      	cmp	r3, #2
 801e240:	d016      	beq.n	801e270 <finsh_compile+0xa0c>
 801e242:	2b03      	cmp	r3, #3
 801e244:	d027      	beq.n	801e296 <finsh_compile+0xa32>
 801e246:	2b01      	cmp	r3, #1
 801e248:	d138      	bne.n	801e2bc <finsh_compile+0xa58>
                {
                case FINSH_DATA_TYPE_BYTE:
                    finsh_code_byte(FINSH_OP_ST_BYTE);
 801e24a:	4b1f      	ldr	r3, [pc, #124]	; (801e2c8 <finsh_compile+0xa64>)
 801e24c:	681b      	ldr	r3, [r3, #0]
 801e24e:	2228      	movs	r2, #40	; 0x28
 801e250:	701a      	strb	r2, [r3, #0]
 801e252:	4b1d      	ldr	r3, [pc, #116]	; (801e2c8 <finsh_compile+0xa64>)
 801e254:	681b      	ldr	r3, [r3, #0]
 801e256:	3301      	adds	r3, #1
 801e258:	4a1b      	ldr	r2, [pc, #108]	; (801e2c8 <finsh_compile+0xa64>)
 801e25a:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE_STACK);
 801e25c:	4b1a      	ldr	r3, [pc, #104]	; (801e2c8 <finsh_compile+0xa64>)
 801e25e:	681b      	ldr	r3, [r3, #0]
 801e260:	222d      	movs	r2, #45	; 0x2d
 801e262:	701a      	strb	r2, [r3, #0]
 801e264:	4b18      	ldr	r3, [pc, #96]	; (801e2c8 <finsh_compile+0xa64>)
 801e266:	681b      	ldr	r3, [r3, #0]
 801e268:	3301      	adds	r3, #1
 801e26a:	4a17      	ldr	r2, [pc, #92]	; (801e2c8 <finsh_compile+0xa64>)
 801e26c:	6013      	str	r3, [r2, #0]
                    break;
 801e26e:	e029      	b.n	801e2c4 <finsh_compile+0xa60>

                case FINSH_DATA_TYPE_WORD:
                    finsh_code_byte(FINSH_OP_ST_WORD);
 801e270:	4b15      	ldr	r3, [pc, #84]	; (801e2c8 <finsh_compile+0xa64>)
 801e272:	681b      	ldr	r3, [r3, #0]
 801e274:	2229      	movs	r2, #41	; 0x29
 801e276:	701a      	strb	r2, [r3, #0]
 801e278:	4b13      	ldr	r3, [pc, #76]	; (801e2c8 <finsh_compile+0xa64>)
 801e27a:	681b      	ldr	r3, [r3, #0]
 801e27c:	3301      	adds	r3, #1
 801e27e:	4a12      	ldr	r2, [pc, #72]	; (801e2c8 <finsh_compile+0xa64>)
 801e280:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD_STACK);
 801e282:	4b11      	ldr	r3, [pc, #68]	; (801e2c8 <finsh_compile+0xa64>)
 801e284:	681b      	ldr	r3, [r3, #0]
 801e286:	222e      	movs	r2, #46	; 0x2e
 801e288:	701a      	strb	r2, [r3, #0]
 801e28a:	4b0f      	ldr	r3, [pc, #60]	; (801e2c8 <finsh_compile+0xa64>)
 801e28c:	681b      	ldr	r3, [r3, #0]
 801e28e:	3301      	adds	r3, #1
 801e290:	4a0d      	ldr	r2, [pc, #52]	; (801e2c8 <finsh_compile+0xa64>)
 801e292:	6013      	str	r3, [r2, #0]
                    break;
 801e294:	e016      	b.n	801e2c4 <finsh_compile+0xa60>

                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_ST_DWORD);
 801e296:	4b0c      	ldr	r3, [pc, #48]	; (801e2c8 <finsh_compile+0xa64>)
 801e298:	681b      	ldr	r3, [r3, #0]
 801e29a:	222a      	movs	r2, #42	; 0x2a
 801e29c:	701a      	strb	r2, [r3, #0]
 801e29e:	4b0a      	ldr	r3, [pc, #40]	; (801e2c8 <finsh_compile+0xa64>)
 801e2a0:	681b      	ldr	r3, [r3, #0]
 801e2a2:	3301      	adds	r3, #1
 801e2a4:	4a08      	ldr	r2, [pc, #32]	; (801e2c8 <finsh_compile+0xa64>)
 801e2a6:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801e2a8:	4b07      	ldr	r3, [pc, #28]	; (801e2c8 <finsh_compile+0xa64>)
 801e2aa:	681b      	ldr	r3, [r3, #0]
 801e2ac:	222f      	movs	r2, #47	; 0x2f
 801e2ae:	701a      	strb	r2, [r3, #0]
 801e2b0:	4b05      	ldr	r3, [pc, #20]	; (801e2c8 <finsh_compile+0xa64>)
 801e2b2:	681b      	ldr	r3, [r3, #0]
 801e2b4:	3301      	adds	r3, #1
 801e2b6:	4a04      	ldr	r2, [pc, #16]	; (801e2c8 <finsh_compile+0xa64>)
 801e2b8:	6013      	str	r3, [r2, #0]
                    break;
 801e2ba:	e003      	b.n	801e2c4 <finsh_compile+0xa60>

                default:
                    finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
 801e2bc:	2003      	movs	r0, #3
 801e2be:	f001 f81d 	bl	801f2fc <finsh_error_set>
                }
            }
 801e2c2:	e051      	b.n	801e368 <finsh_compile+0xb04>
 801e2c4:	e050      	b.n	801e368 <finsh_compile+0xb04>
 801e2c6:	bf00      	nop
 801e2c8:	20012bdc 	.word	0x20012bdc
            else if (finsh_node_child(node)->node_type == FINSH_NODE_SYS_GETVALUE)
 801e2cc:	687b      	ldr	r3, [r7, #4]
 801e2ce:	691b      	ldr	r3, [r3, #16]
 801e2d0:	781b      	ldrb	r3, [r3, #0]
 801e2d2:	2b19      	cmp	r3, #25
 801e2d4:	d148      	bne.n	801e368 <finsh_compile+0xb04>
            {
                switch ((finsh_node_child(node)->data_type) & 0x0F)
 801e2d6:	687b      	ldr	r3, [r7, #4]
 801e2d8:	691b      	ldr	r3, [r3, #16]
 801e2da:	785b      	ldrb	r3, [r3, #1]
 801e2dc:	f003 030f 	and.w	r3, r3, #15
 801e2e0:	2b02      	cmp	r3, #2
 801e2e2:	d016      	beq.n	801e312 <finsh_compile+0xaae>
 801e2e4:	2b03      	cmp	r3, #3
 801e2e6:	d027      	beq.n	801e338 <finsh_compile+0xad4>
 801e2e8:	2b01      	cmp	r3, #1
 801e2ea:	d138      	bne.n	801e35e <finsh_compile+0xafa>
                {
                case FINSH_DATA_TYPE_BYTE:
                    finsh_code_byte(FINSH_OP_ST_BYTE);
 801e2ec:	4b89      	ldr	r3, [pc, #548]	; (801e514 <finsh_compile+0xcb0>)
 801e2ee:	681b      	ldr	r3, [r3, #0]
 801e2f0:	2228      	movs	r2, #40	; 0x28
 801e2f2:	701a      	strb	r2, [r3, #0]
 801e2f4:	4b87      	ldr	r3, [pc, #540]	; (801e514 <finsh_compile+0xcb0>)
 801e2f6:	681b      	ldr	r3, [r3, #0]
 801e2f8:	3301      	adds	r3, #1
 801e2fa:	4a86      	ldr	r2, [pc, #536]	; (801e514 <finsh_compile+0xcb0>)
 801e2fc:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE_STACK);
 801e2fe:	4b85      	ldr	r3, [pc, #532]	; (801e514 <finsh_compile+0xcb0>)
 801e300:	681b      	ldr	r3, [r3, #0]
 801e302:	222d      	movs	r2, #45	; 0x2d
 801e304:	701a      	strb	r2, [r3, #0]
 801e306:	4b83      	ldr	r3, [pc, #524]	; (801e514 <finsh_compile+0xcb0>)
 801e308:	681b      	ldr	r3, [r3, #0]
 801e30a:	3301      	adds	r3, #1
 801e30c:	4a81      	ldr	r2, [pc, #516]	; (801e514 <finsh_compile+0xcb0>)
 801e30e:	6013      	str	r3, [r2, #0]
                    break;
 801e310:	e02a      	b.n	801e368 <finsh_compile+0xb04>

                case FINSH_DATA_TYPE_WORD:
                    finsh_code_byte(FINSH_OP_ST_WORD);
 801e312:	4b80      	ldr	r3, [pc, #512]	; (801e514 <finsh_compile+0xcb0>)
 801e314:	681b      	ldr	r3, [r3, #0]
 801e316:	2229      	movs	r2, #41	; 0x29
 801e318:	701a      	strb	r2, [r3, #0]
 801e31a:	4b7e      	ldr	r3, [pc, #504]	; (801e514 <finsh_compile+0xcb0>)
 801e31c:	681b      	ldr	r3, [r3, #0]
 801e31e:	3301      	adds	r3, #1
 801e320:	4a7c      	ldr	r2, [pc, #496]	; (801e514 <finsh_compile+0xcb0>)
 801e322:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD_STACK);
 801e324:	4b7b      	ldr	r3, [pc, #492]	; (801e514 <finsh_compile+0xcb0>)
 801e326:	681b      	ldr	r3, [r3, #0]
 801e328:	222e      	movs	r2, #46	; 0x2e
 801e32a:	701a      	strb	r2, [r3, #0]
 801e32c:	4b79      	ldr	r3, [pc, #484]	; (801e514 <finsh_compile+0xcb0>)
 801e32e:	681b      	ldr	r3, [r3, #0]
 801e330:	3301      	adds	r3, #1
 801e332:	4a78      	ldr	r2, [pc, #480]	; (801e514 <finsh_compile+0xcb0>)
 801e334:	6013      	str	r3, [r2, #0]
                    break;
 801e336:	e017      	b.n	801e368 <finsh_compile+0xb04>

                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_ST_DWORD);
 801e338:	4b76      	ldr	r3, [pc, #472]	; (801e514 <finsh_compile+0xcb0>)
 801e33a:	681b      	ldr	r3, [r3, #0]
 801e33c:	222a      	movs	r2, #42	; 0x2a
 801e33e:	701a      	strb	r2, [r3, #0]
 801e340:	4b74      	ldr	r3, [pc, #464]	; (801e514 <finsh_compile+0xcb0>)
 801e342:	681b      	ldr	r3, [r3, #0]
 801e344:	3301      	adds	r3, #1
 801e346:	4a73      	ldr	r2, [pc, #460]	; (801e514 <finsh_compile+0xcb0>)
 801e348:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801e34a:	4b72      	ldr	r3, [pc, #456]	; (801e514 <finsh_compile+0xcb0>)
 801e34c:	681b      	ldr	r3, [r3, #0]
 801e34e:	222f      	movs	r2, #47	; 0x2f
 801e350:	701a      	strb	r2, [r3, #0]
 801e352:	4b70      	ldr	r3, [pc, #448]	; (801e514 <finsh_compile+0xcb0>)
 801e354:	681b      	ldr	r3, [r3, #0]
 801e356:	3301      	adds	r3, #1
 801e358:	4a6e      	ldr	r2, [pc, #440]	; (801e514 <finsh_compile+0xcb0>)
 801e35a:	6013      	str	r3, [r2, #0]
                    break;
 801e35c:	e004      	b.n	801e368 <finsh_compile+0xb04>

                default:
                    finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
 801e35e:	2003      	movs	r0, #3
 801e360:	f000 ffcc 	bl	801f2fc <finsh_error_set>
                }
            }
            break;
 801e364:	f000 be5d 	b.w	801f022 <finsh_compile+0x17be>
 801e368:	f000 be5b 	b.w	801f022 <finsh_compile+0x17be>

        /* pre-increase */
        case FINSH_NODE_SYS_PREINC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
 801e36c:	687b      	ldr	r3, [r7, #4]
 801e36e:	691b      	ldr	r3, [r3, #16]
 801e370:	2b00      	cmp	r3, #0
 801e372:	f000 813a 	beq.w	801e5ea <finsh_compile+0xd86>
 801e376:	687b      	ldr	r3, [r7, #4]
 801e378:	691b      	ldr	r3, [r3, #16]
 801e37a:	781b      	ldrb	r3, [r3, #0]
 801e37c:	2b01      	cmp	r3, #1
 801e37e:	f040 8134 	bne.w	801e5ea <finsh_compile+0xd86>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
 801e382:	687b      	ldr	r3, [r7, #4]
 801e384:	691b      	ldr	r3, [r3, #16]
 801e386:	689b      	ldr	r3, [r3, #8]
 801e388:	617b      	str	r3, [r7, #20]

                /* ld_dword &id */
                // finsh_code_byte(FINSH_OP_LD_DWORD);

                switch (node->data_type)
 801e38a:	687b      	ldr	r3, [r7, #4]
 801e38c:	785b      	ldrb	r3, [r3, #1]
 801e38e:	2b02      	cmp	r3, #2
 801e390:	d060      	beq.n	801e454 <finsh_compile+0xbf0>
 801e392:	2b03      	cmp	r3, #3
 801e394:	f000 80c0 	beq.w	801e518 <finsh_compile+0xcb4>
 801e398:	2b01      	cmp	r3, #1
 801e39a:	d001      	beq.n	801e3a0 <finsh_compile+0xb3c>
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);

                    break;
                }
            }
            break;
 801e39c:	f000 be41 	b.w	801f022 <finsh_compile+0x17be>
                case FINSH_DATA_TYPE_BYTE:
                    /* address */
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
 801e3a0:	4b5c      	ldr	r3, [pc, #368]	; (801e514 <finsh_compile+0xcb0>)
 801e3a2:	681b      	ldr	r3, [r3, #0]
 801e3a4:	2225      	movs	r2, #37	; 0x25
 801e3a6:	701a      	strb	r2, [r3, #0]
 801e3a8:	4b5a      	ldr	r3, [pc, #360]	; (801e514 <finsh_compile+0xcb0>)
 801e3aa:	681b      	ldr	r3, [r3, #0]
 801e3ac:	3301      	adds	r3, #1
 801e3ae:	4a59      	ldr	r2, [pc, #356]	; (801e514 <finsh_compile+0xcb0>)
 801e3b0:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.char_value));
 801e3b2:	4b58      	ldr	r3, [pc, #352]	; (801e514 <finsh_compile+0xcb0>)
 801e3b4:	681b      	ldr	r3, [r3, #0]
 801e3b6:	697a      	ldr	r2, [r7, #20]
 801e3b8:	3214      	adds	r2, #20
 801e3ba:	b2d2      	uxtb	r2, r2
 801e3bc:	701a      	strb	r2, [r3, #0]
 801e3be:	4b55      	ldr	r3, [pc, #340]	; (801e514 <finsh_compile+0xcb0>)
 801e3c0:	681b      	ldr	r3, [r3, #0]
 801e3c2:	3301      	adds	r3, #1
 801e3c4:	697a      	ldr	r2, [r7, #20]
 801e3c6:	3214      	adds	r2, #20
 801e3c8:	0a12      	lsrs	r2, r2, #8
 801e3ca:	b2d2      	uxtb	r2, r2
 801e3cc:	701a      	strb	r2, [r3, #0]
 801e3ce:	4b51      	ldr	r3, [pc, #324]	; (801e514 <finsh_compile+0xcb0>)
 801e3d0:	681b      	ldr	r3, [r3, #0]
 801e3d2:	3302      	adds	r3, #2
 801e3d4:	697a      	ldr	r2, [r7, #20]
 801e3d6:	3214      	adds	r2, #20
 801e3d8:	0c12      	lsrs	r2, r2, #16
 801e3da:	b2d2      	uxtb	r2, r2
 801e3dc:	701a      	strb	r2, [r3, #0]
 801e3de:	4b4d      	ldr	r3, [pc, #308]	; (801e514 <finsh_compile+0xcb0>)
 801e3e0:	681b      	ldr	r3, [r3, #0]
 801e3e2:	3303      	adds	r3, #3
 801e3e4:	697a      	ldr	r2, [r7, #20]
 801e3e6:	3214      	adds	r2, #20
 801e3e8:	0e12      	lsrs	r2, r2, #24
 801e3ea:	b2d2      	uxtb	r2, r2
 801e3ec:	701a      	strb	r2, [r3, #0]
 801e3ee:	4b49      	ldr	r3, [pc, #292]	; (801e514 <finsh_compile+0xcb0>)
 801e3f0:	681b      	ldr	r3, [r3, #0]
 801e3f2:	3304      	adds	r3, #4
 801e3f4:	4a47      	ldr	r2, [pc, #284]	; (801e514 <finsh_compile+0xcb0>)
 801e3f6:	6013      	str	r3, [r2, #0]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
 801e3f8:	4b46      	ldr	r3, [pc, #280]	; (801e514 <finsh_compile+0xcb0>)
 801e3fa:	681b      	ldr	r3, [r3, #0]
 801e3fc:	2222      	movs	r2, #34	; 0x22
 801e3fe:	701a      	strb	r2, [r3, #0]
 801e400:	4b44      	ldr	r3, [pc, #272]	; (801e514 <finsh_compile+0xcb0>)
 801e402:	681b      	ldr	r3, [r3, #0]
 801e404:	3301      	adds	r3, #1
 801e406:	4a43      	ldr	r2, [pc, #268]	; (801e514 <finsh_compile+0xcb0>)
 801e408:	6013      	str	r3, [r2, #0]
                    finsh_code_byte(1);
 801e40a:	4b42      	ldr	r3, [pc, #264]	; (801e514 <finsh_compile+0xcb0>)
 801e40c:	681b      	ldr	r3, [r3, #0]
 801e40e:	2201      	movs	r2, #1
 801e410:	701a      	strb	r2, [r3, #0]
 801e412:	4b40      	ldr	r3, [pc, #256]	; (801e514 <finsh_compile+0xcb0>)
 801e414:	681b      	ldr	r3, [r3, #0]
 801e416:	3301      	adds	r3, #1
 801e418:	4a3e      	ldr	r2, [pc, #248]	; (801e514 <finsh_compile+0xcb0>)
 801e41a:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_BYTE);
 801e41c:	4b3d      	ldr	r3, [pc, #244]	; (801e514 <finsh_compile+0xcb0>)
 801e41e:	681b      	ldr	r3, [r3, #0]
 801e420:	2201      	movs	r2, #1
 801e422:	701a      	strb	r2, [r3, #0]
 801e424:	4b3b      	ldr	r3, [pc, #236]	; (801e514 <finsh_compile+0xcb0>)
 801e426:	681b      	ldr	r3, [r3, #0]
 801e428:	3301      	adds	r3, #1
 801e42a:	4a3a      	ldr	r2, [pc, #232]	; (801e514 <finsh_compile+0xcb0>)
 801e42c:	6013      	str	r3, [r2, #0]
                    /* st_byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
 801e42e:	4b39      	ldr	r3, [pc, #228]	; (801e514 <finsh_compile+0xcb0>)
 801e430:	681b      	ldr	r3, [r3, #0]
 801e432:	2228      	movs	r2, #40	; 0x28
 801e434:	701a      	strb	r2, [r3, #0]
 801e436:	4b37      	ldr	r3, [pc, #220]	; (801e514 <finsh_compile+0xcb0>)
 801e438:	681b      	ldr	r3, [r3, #0]
 801e43a:	3301      	adds	r3, #1
 801e43c:	4a35      	ldr	r2, [pc, #212]	; (801e514 <finsh_compile+0xcb0>)
 801e43e:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801e440:	4b34      	ldr	r3, [pc, #208]	; (801e514 <finsh_compile+0xcb0>)
 801e442:	681b      	ldr	r3, [r3, #0]
 801e444:	222f      	movs	r2, #47	; 0x2f
 801e446:	701a      	strb	r2, [r3, #0]
 801e448:	4b32      	ldr	r3, [pc, #200]	; (801e514 <finsh_compile+0xcb0>)
 801e44a:	681b      	ldr	r3, [r3, #0]
 801e44c:	3301      	adds	r3, #1
 801e44e:	4a31      	ldr	r2, [pc, #196]	; (801e514 <finsh_compile+0xcb0>)
 801e450:	6013      	str	r3, [r2, #0]

                    break;
 801e452:	e0ca      	b.n	801e5ea <finsh_compile+0xd86>
                case FINSH_DATA_TYPE_WORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
 801e454:	4b2f      	ldr	r3, [pc, #188]	; (801e514 <finsh_compile+0xcb0>)
 801e456:	681b      	ldr	r3, [r3, #0]
 801e458:	2226      	movs	r2, #38	; 0x26
 801e45a:	701a      	strb	r2, [r3, #0]
 801e45c:	4b2d      	ldr	r3, [pc, #180]	; (801e514 <finsh_compile+0xcb0>)
 801e45e:	681b      	ldr	r3, [r3, #0]
 801e460:	3301      	adds	r3, #1
 801e462:	4a2c      	ldr	r2, [pc, #176]	; (801e514 <finsh_compile+0xcb0>)
 801e464:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.short_value));
 801e466:	4b2b      	ldr	r3, [pc, #172]	; (801e514 <finsh_compile+0xcb0>)
 801e468:	681b      	ldr	r3, [r3, #0]
 801e46a:	697a      	ldr	r2, [r7, #20]
 801e46c:	3214      	adds	r2, #20
 801e46e:	b2d2      	uxtb	r2, r2
 801e470:	701a      	strb	r2, [r3, #0]
 801e472:	4b28      	ldr	r3, [pc, #160]	; (801e514 <finsh_compile+0xcb0>)
 801e474:	681b      	ldr	r3, [r3, #0]
 801e476:	3301      	adds	r3, #1
 801e478:	697a      	ldr	r2, [r7, #20]
 801e47a:	3214      	adds	r2, #20
 801e47c:	0a12      	lsrs	r2, r2, #8
 801e47e:	b2d2      	uxtb	r2, r2
 801e480:	701a      	strb	r2, [r3, #0]
 801e482:	4b24      	ldr	r3, [pc, #144]	; (801e514 <finsh_compile+0xcb0>)
 801e484:	681b      	ldr	r3, [r3, #0]
 801e486:	3302      	adds	r3, #2
 801e488:	697a      	ldr	r2, [r7, #20]
 801e48a:	3214      	adds	r2, #20
 801e48c:	0c12      	lsrs	r2, r2, #16
 801e48e:	b2d2      	uxtb	r2, r2
 801e490:	701a      	strb	r2, [r3, #0]
 801e492:	4b20      	ldr	r3, [pc, #128]	; (801e514 <finsh_compile+0xcb0>)
 801e494:	681b      	ldr	r3, [r3, #0]
 801e496:	3303      	adds	r3, #3
 801e498:	697a      	ldr	r2, [r7, #20]
 801e49a:	3214      	adds	r2, #20
 801e49c:	0e12      	lsrs	r2, r2, #24
 801e49e:	b2d2      	uxtb	r2, r2
 801e4a0:	701a      	strb	r2, [r3, #0]
 801e4a2:	4b1c      	ldr	r3, [pc, #112]	; (801e514 <finsh_compile+0xcb0>)
 801e4a4:	681b      	ldr	r3, [r3, #0]
 801e4a6:	3304      	adds	r3, #4
 801e4a8:	4a1a      	ldr	r2, [pc, #104]	; (801e514 <finsh_compile+0xcb0>)
 801e4aa:	6013      	str	r3, [r2, #0]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
 801e4ac:	4b19      	ldr	r3, [pc, #100]	; (801e514 <finsh_compile+0xcb0>)
 801e4ae:	681b      	ldr	r3, [r3, #0]
 801e4b0:	2223      	movs	r2, #35	; 0x23
 801e4b2:	701a      	strb	r2, [r3, #0]
 801e4b4:	4b17      	ldr	r3, [pc, #92]	; (801e514 <finsh_compile+0xcb0>)
 801e4b6:	681b      	ldr	r3, [r3, #0]
 801e4b8:	3301      	adds	r3, #1
 801e4ba:	4a16      	ldr	r2, [pc, #88]	; (801e514 <finsh_compile+0xcb0>)
 801e4bc:	6013      	str	r3, [r2, #0]
                    finsh_code_word(1);
 801e4be:	4b15      	ldr	r3, [pc, #84]	; (801e514 <finsh_compile+0xcb0>)
 801e4c0:	681b      	ldr	r3, [r3, #0]
 801e4c2:	2201      	movs	r2, #1
 801e4c4:	701a      	strb	r2, [r3, #0]
 801e4c6:	4b13      	ldr	r3, [pc, #76]	; (801e514 <finsh_compile+0xcb0>)
 801e4c8:	681b      	ldr	r3, [r3, #0]
 801e4ca:	3301      	adds	r3, #1
 801e4cc:	2200      	movs	r2, #0
 801e4ce:	701a      	strb	r2, [r3, #0]
 801e4d0:	4b10      	ldr	r3, [pc, #64]	; (801e514 <finsh_compile+0xcb0>)
 801e4d2:	681b      	ldr	r3, [r3, #0]
 801e4d4:	3302      	adds	r3, #2
 801e4d6:	4a0f      	ldr	r2, [pc, #60]	; (801e514 <finsh_compile+0xcb0>)
 801e4d8:	6013      	str	r3, [r2, #0]

                    /* add_word */
                    finsh_code_byte(FINSH_OP_ADD_WORD);
 801e4da:	4b0e      	ldr	r3, [pc, #56]	; (801e514 <finsh_compile+0xcb0>)
 801e4dc:	681b      	ldr	r3, [r3, #0]
 801e4de:	2202      	movs	r2, #2
 801e4e0:	701a      	strb	r2, [r3, #0]
 801e4e2:	4b0c      	ldr	r3, [pc, #48]	; (801e514 <finsh_compile+0xcb0>)
 801e4e4:	681b      	ldr	r3, [r3, #0]
 801e4e6:	3301      	adds	r3, #1
 801e4e8:	4a0a      	ldr	r2, [pc, #40]	; (801e514 <finsh_compile+0xcb0>)
 801e4ea:	6013      	str	r3, [r2, #0]
                    /* st_word */
                    finsh_code_byte(FINSH_OP_ST_WORD);
 801e4ec:	4b09      	ldr	r3, [pc, #36]	; (801e514 <finsh_compile+0xcb0>)
 801e4ee:	681b      	ldr	r3, [r3, #0]
 801e4f0:	2229      	movs	r2, #41	; 0x29
 801e4f2:	701a      	strb	r2, [r3, #0]
 801e4f4:	4b07      	ldr	r3, [pc, #28]	; (801e514 <finsh_compile+0xcb0>)
 801e4f6:	681b      	ldr	r3, [r3, #0]
 801e4f8:	3301      	adds	r3, #1
 801e4fa:	4a06      	ldr	r2, [pc, #24]	; (801e514 <finsh_compile+0xcb0>)
 801e4fc:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801e4fe:	4b05      	ldr	r3, [pc, #20]	; (801e514 <finsh_compile+0xcb0>)
 801e500:	681b      	ldr	r3, [r3, #0]
 801e502:	222f      	movs	r2, #47	; 0x2f
 801e504:	701a      	strb	r2, [r3, #0]
 801e506:	4b03      	ldr	r3, [pc, #12]	; (801e514 <finsh_compile+0xcb0>)
 801e508:	681b      	ldr	r3, [r3, #0]
 801e50a:	3301      	adds	r3, #1
 801e50c:	4a01      	ldr	r2, [pc, #4]	; (801e514 <finsh_compile+0xcb0>)
 801e50e:	6013      	str	r3, [r2, #0]

                    break;
 801e510:	e06b      	b.n	801e5ea <finsh_compile+0xd86>
 801e512:	bf00      	nop
 801e514:	20012bdc 	.word	0x20012bdc
                case FINSH_DATA_TYPE_DWORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
 801e518:	4b6f      	ldr	r3, [pc, #444]	; (801e6d8 <finsh_compile+0xe74>)
 801e51a:	681b      	ldr	r3, [r3, #0]
 801e51c:	2227      	movs	r2, #39	; 0x27
 801e51e:	701a      	strb	r2, [r3, #0]
 801e520:	4b6d      	ldr	r3, [pc, #436]	; (801e6d8 <finsh_compile+0xe74>)
 801e522:	681b      	ldr	r3, [r3, #0]
 801e524:	3301      	adds	r3, #1
 801e526:	4a6c      	ldr	r2, [pc, #432]	; (801e6d8 <finsh_compile+0xe74>)
 801e528:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.long_value));
 801e52a:	4b6b      	ldr	r3, [pc, #428]	; (801e6d8 <finsh_compile+0xe74>)
 801e52c:	681b      	ldr	r3, [r3, #0]
 801e52e:	697a      	ldr	r2, [r7, #20]
 801e530:	3214      	adds	r2, #20
 801e532:	b2d2      	uxtb	r2, r2
 801e534:	701a      	strb	r2, [r3, #0]
 801e536:	4b68      	ldr	r3, [pc, #416]	; (801e6d8 <finsh_compile+0xe74>)
 801e538:	681b      	ldr	r3, [r3, #0]
 801e53a:	3301      	adds	r3, #1
 801e53c:	697a      	ldr	r2, [r7, #20]
 801e53e:	3214      	adds	r2, #20
 801e540:	0a12      	lsrs	r2, r2, #8
 801e542:	b2d2      	uxtb	r2, r2
 801e544:	701a      	strb	r2, [r3, #0]
 801e546:	4b64      	ldr	r3, [pc, #400]	; (801e6d8 <finsh_compile+0xe74>)
 801e548:	681b      	ldr	r3, [r3, #0]
 801e54a:	3302      	adds	r3, #2
 801e54c:	697a      	ldr	r2, [r7, #20]
 801e54e:	3214      	adds	r2, #20
 801e550:	0c12      	lsrs	r2, r2, #16
 801e552:	b2d2      	uxtb	r2, r2
 801e554:	701a      	strb	r2, [r3, #0]
 801e556:	4b60      	ldr	r3, [pc, #384]	; (801e6d8 <finsh_compile+0xe74>)
 801e558:	681b      	ldr	r3, [r3, #0]
 801e55a:	3303      	adds	r3, #3
 801e55c:	697a      	ldr	r2, [r7, #20]
 801e55e:	3214      	adds	r2, #20
 801e560:	0e12      	lsrs	r2, r2, #24
 801e562:	b2d2      	uxtb	r2, r2
 801e564:	701a      	strb	r2, [r3, #0]
 801e566:	4b5c      	ldr	r3, [pc, #368]	; (801e6d8 <finsh_compile+0xe74>)
 801e568:	681b      	ldr	r3, [r3, #0]
 801e56a:	3304      	adds	r3, #4
 801e56c:	4a5a      	ldr	r2, [pc, #360]	; (801e6d8 <finsh_compile+0xe74>)
 801e56e:	6013      	str	r3, [r2, #0]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801e570:	4b59      	ldr	r3, [pc, #356]	; (801e6d8 <finsh_compile+0xe74>)
 801e572:	681b      	ldr	r3, [r3, #0]
 801e574:	2224      	movs	r2, #36	; 0x24
 801e576:	701a      	strb	r2, [r3, #0]
 801e578:	4b57      	ldr	r3, [pc, #348]	; (801e6d8 <finsh_compile+0xe74>)
 801e57a:	681b      	ldr	r3, [r3, #0]
 801e57c:	3301      	adds	r3, #1
 801e57e:	4a56      	ldr	r2, [pc, #344]	; (801e6d8 <finsh_compile+0xe74>)
 801e580:	6013      	str	r3, [r2, #0]
                    finsh_code_dword(1);
 801e582:	4b55      	ldr	r3, [pc, #340]	; (801e6d8 <finsh_compile+0xe74>)
 801e584:	681b      	ldr	r3, [r3, #0]
 801e586:	2201      	movs	r2, #1
 801e588:	701a      	strb	r2, [r3, #0]
 801e58a:	4b53      	ldr	r3, [pc, #332]	; (801e6d8 <finsh_compile+0xe74>)
 801e58c:	681b      	ldr	r3, [r3, #0]
 801e58e:	3301      	adds	r3, #1
 801e590:	2200      	movs	r2, #0
 801e592:	701a      	strb	r2, [r3, #0]
 801e594:	4b50      	ldr	r3, [pc, #320]	; (801e6d8 <finsh_compile+0xe74>)
 801e596:	681b      	ldr	r3, [r3, #0]
 801e598:	3302      	adds	r3, #2
 801e59a:	2200      	movs	r2, #0
 801e59c:	701a      	strb	r2, [r3, #0]
 801e59e:	4b4e      	ldr	r3, [pc, #312]	; (801e6d8 <finsh_compile+0xe74>)
 801e5a0:	681b      	ldr	r3, [r3, #0]
 801e5a2:	3303      	adds	r3, #3
 801e5a4:	2200      	movs	r2, #0
 801e5a6:	701a      	strb	r2, [r3, #0]
 801e5a8:	4b4b      	ldr	r3, [pc, #300]	; (801e6d8 <finsh_compile+0xe74>)
 801e5aa:	681b      	ldr	r3, [r3, #0]
 801e5ac:	3304      	adds	r3, #4
 801e5ae:	4a4a      	ldr	r2, [pc, #296]	; (801e6d8 <finsh_compile+0xe74>)
 801e5b0:	6013      	str	r3, [r2, #0]

                    /* add_dword */
                    finsh_code_byte(FINSH_OP_ADD_DWORD);
 801e5b2:	4b49      	ldr	r3, [pc, #292]	; (801e6d8 <finsh_compile+0xe74>)
 801e5b4:	681b      	ldr	r3, [r3, #0]
 801e5b6:	2203      	movs	r2, #3
 801e5b8:	701a      	strb	r2, [r3, #0]
 801e5ba:	4b47      	ldr	r3, [pc, #284]	; (801e6d8 <finsh_compile+0xe74>)
 801e5bc:	681b      	ldr	r3, [r3, #0]
 801e5be:	3301      	adds	r3, #1
 801e5c0:	4a45      	ldr	r2, [pc, #276]	; (801e6d8 <finsh_compile+0xe74>)
 801e5c2:	6013      	str	r3, [r2, #0]
                    /* st_dword */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
 801e5c4:	4b44      	ldr	r3, [pc, #272]	; (801e6d8 <finsh_compile+0xe74>)
 801e5c6:	681b      	ldr	r3, [r3, #0]
 801e5c8:	222a      	movs	r2, #42	; 0x2a
 801e5ca:	701a      	strb	r2, [r3, #0]
 801e5cc:	4b42      	ldr	r3, [pc, #264]	; (801e6d8 <finsh_compile+0xe74>)
 801e5ce:	681b      	ldr	r3, [r3, #0]
 801e5d0:	3301      	adds	r3, #1
 801e5d2:	4a41      	ldr	r2, [pc, #260]	; (801e6d8 <finsh_compile+0xe74>)
 801e5d4:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801e5d6:	4b40      	ldr	r3, [pc, #256]	; (801e6d8 <finsh_compile+0xe74>)
 801e5d8:	681b      	ldr	r3, [r3, #0]
 801e5da:	222f      	movs	r2, #47	; 0x2f
 801e5dc:	701a      	strb	r2, [r3, #0]
 801e5de:	4b3e      	ldr	r3, [pc, #248]	; (801e6d8 <finsh_compile+0xe74>)
 801e5e0:	681b      	ldr	r3, [r3, #0]
 801e5e2:	3301      	adds	r3, #1
 801e5e4:	4a3c      	ldr	r2, [pc, #240]	; (801e6d8 <finsh_compile+0xe74>)
 801e5e6:	6013      	str	r3, [r2, #0]

                    break;
 801e5e8:	bf00      	nop
                }
            }
            break;
 801e5ea:	f000 bd1a 	b.w	801f022 <finsh_compile+0x17be>

        /* pre-decrease */
        case FINSH_NODE_SYS_PREDEC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
 801e5ee:	687b      	ldr	r3, [r7, #4]
 801e5f0:	691b      	ldr	r3, [r3, #16]
 801e5f2:	2b00      	cmp	r3, #0
 801e5f4:	f000 813a 	beq.w	801e86c <finsh_compile+0x1008>
 801e5f8:	687b      	ldr	r3, [r7, #4]
 801e5fa:	691b      	ldr	r3, [r3, #16]
 801e5fc:	781b      	ldrb	r3, [r3, #0]
 801e5fe:	2b01      	cmp	r3, #1
 801e600:	f040 8134 	bne.w	801e86c <finsh_compile+0x1008>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
 801e604:	687b      	ldr	r3, [r7, #4]
 801e606:	691b      	ldr	r3, [r3, #16]
 801e608:	689b      	ldr	r3, [r3, #8]
 801e60a:	613b      	str	r3, [r7, #16]

                /* ld_dword &id */
                // finsh_code_byte(FINSH_OP_LD_DWORD);

                switch (node->data_type)
 801e60c:	687b      	ldr	r3, [r7, #4]
 801e60e:	785b      	ldrb	r3, [r3, #1]
 801e610:	2b02      	cmp	r3, #2
 801e612:	d063      	beq.n	801e6dc <finsh_compile+0xe78>
 801e614:	2b03      	cmp	r3, #3
 801e616:	f000 80c0 	beq.w	801e79a <finsh_compile+0xf36>
 801e61a:	2b01      	cmp	r3, #1
 801e61c:	d001      	beq.n	801e622 <finsh_compile+0xdbe>
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);

                    break;
                }
            }
            break;
 801e61e:	f000 bd00 	b.w	801f022 <finsh_compile+0x17be>
                case FINSH_DATA_TYPE_BYTE:
                    /* address */
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
 801e622:	4b2d      	ldr	r3, [pc, #180]	; (801e6d8 <finsh_compile+0xe74>)
 801e624:	681b      	ldr	r3, [r3, #0]
 801e626:	2225      	movs	r2, #37	; 0x25
 801e628:	701a      	strb	r2, [r3, #0]
 801e62a:	4b2b      	ldr	r3, [pc, #172]	; (801e6d8 <finsh_compile+0xe74>)
 801e62c:	681b      	ldr	r3, [r3, #0]
 801e62e:	3301      	adds	r3, #1
 801e630:	4a29      	ldr	r2, [pc, #164]	; (801e6d8 <finsh_compile+0xe74>)
 801e632:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.char_value));
 801e634:	4b28      	ldr	r3, [pc, #160]	; (801e6d8 <finsh_compile+0xe74>)
 801e636:	681b      	ldr	r3, [r3, #0]
 801e638:	693a      	ldr	r2, [r7, #16]
 801e63a:	3214      	adds	r2, #20
 801e63c:	b2d2      	uxtb	r2, r2
 801e63e:	701a      	strb	r2, [r3, #0]
 801e640:	4b25      	ldr	r3, [pc, #148]	; (801e6d8 <finsh_compile+0xe74>)
 801e642:	681b      	ldr	r3, [r3, #0]
 801e644:	3301      	adds	r3, #1
 801e646:	693a      	ldr	r2, [r7, #16]
 801e648:	3214      	adds	r2, #20
 801e64a:	0a12      	lsrs	r2, r2, #8
 801e64c:	b2d2      	uxtb	r2, r2
 801e64e:	701a      	strb	r2, [r3, #0]
 801e650:	4b21      	ldr	r3, [pc, #132]	; (801e6d8 <finsh_compile+0xe74>)
 801e652:	681b      	ldr	r3, [r3, #0]
 801e654:	3302      	adds	r3, #2
 801e656:	693a      	ldr	r2, [r7, #16]
 801e658:	3214      	adds	r2, #20
 801e65a:	0c12      	lsrs	r2, r2, #16
 801e65c:	b2d2      	uxtb	r2, r2
 801e65e:	701a      	strb	r2, [r3, #0]
 801e660:	4b1d      	ldr	r3, [pc, #116]	; (801e6d8 <finsh_compile+0xe74>)
 801e662:	681b      	ldr	r3, [r3, #0]
 801e664:	3303      	adds	r3, #3
 801e666:	693a      	ldr	r2, [r7, #16]
 801e668:	3214      	adds	r2, #20
 801e66a:	0e12      	lsrs	r2, r2, #24
 801e66c:	b2d2      	uxtb	r2, r2
 801e66e:	701a      	strb	r2, [r3, #0]
 801e670:	4b19      	ldr	r3, [pc, #100]	; (801e6d8 <finsh_compile+0xe74>)
 801e672:	681b      	ldr	r3, [r3, #0]
 801e674:	3304      	adds	r3, #4
 801e676:	4a18      	ldr	r2, [pc, #96]	; (801e6d8 <finsh_compile+0xe74>)
 801e678:	6013      	str	r3, [r2, #0]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
 801e67a:	4b17      	ldr	r3, [pc, #92]	; (801e6d8 <finsh_compile+0xe74>)
 801e67c:	681b      	ldr	r3, [r3, #0]
 801e67e:	2222      	movs	r2, #34	; 0x22
 801e680:	701a      	strb	r2, [r3, #0]
 801e682:	4b15      	ldr	r3, [pc, #84]	; (801e6d8 <finsh_compile+0xe74>)
 801e684:	681b      	ldr	r3, [r3, #0]
 801e686:	3301      	adds	r3, #1
 801e688:	4a13      	ldr	r2, [pc, #76]	; (801e6d8 <finsh_compile+0xe74>)
 801e68a:	6013      	str	r3, [r2, #0]
                    finsh_code_byte(1);
 801e68c:	4b12      	ldr	r3, [pc, #72]	; (801e6d8 <finsh_compile+0xe74>)
 801e68e:	681b      	ldr	r3, [r3, #0]
 801e690:	2201      	movs	r2, #1
 801e692:	701a      	strb	r2, [r3, #0]
 801e694:	4b10      	ldr	r3, [pc, #64]	; (801e6d8 <finsh_compile+0xe74>)
 801e696:	681b      	ldr	r3, [r3, #0]
 801e698:	3301      	adds	r3, #1
 801e69a:	4a0f      	ldr	r2, [pc, #60]	; (801e6d8 <finsh_compile+0xe74>)
 801e69c:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_BYTE);
 801e69e:	4b0e      	ldr	r3, [pc, #56]	; (801e6d8 <finsh_compile+0xe74>)
 801e6a0:	681b      	ldr	r3, [r3, #0]
 801e6a2:	2204      	movs	r2, #4
 801e6a4:	701a      	strb	r2, [r3, #0]
 801e6a6:	4b0c      	ldr	r3, [pc, #48]	; (801e6d8 <finsh_compile+0xe74>)
 801e6a8:	681b      	ldr	r3, [r3, #0]
 801e6aa:	3301      	adds	r3, #1
 801e6ac:	4a0a      	ldr	r2, [pc, #40]	; (801e6d8 <finsh_compile+0xe74>)
 801e6ae:	6013      	str	r3, [r2, #0]
                    /* st_byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
 801e6b0:	4b09      	ldr	r3, [pc, #36]	; (801e6d8 <finsh_compile+0xe74>)
 801e6b2:	681b      	ldr	r3, [r3, #0]
 801e6b4:	2228      	movs	r2, #40	; 0x28
 801e6b6:	701a      	strb	r2, [r3, #0]
 801e6b8:	4b07      	ldr	r3, [pc, #28]	; (801e6d8 <finsh_compile+0xe74>)
 801e6ba:	681b      	ldr	r3, [r3, #0]
 801e6bc:	3301      	adds	r3, #1
 801e6be:	4a06      	ldr	r2, [pc, #24]	; (801e6d8 <finsh_compile+0xe74>)
 801e6c0:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801e6c2:	4b05      	ldr	r3, [pc, #20]	; (801e6d8 <finsh_compile+0xe74>)
 801e6c4:	681b      	ldr	r3, [r3, #0]
 801e6c6:	222f      	movs	r2, #47	; 0x2f
 801e6c8:	701a      	strb	r2, [r3, #0]
 801e6ca:	4b03      	ldr	r3, [pc, #12]	; (801e6d8 <finsh_compile+0xe74>)
 801e6cc:	681b      	ldr	r3, [r3, #0]
 801e6ce:	3301      	adds	r3, #1
 801e6d0:	4a01      	ldr	r2, [pc, #4]	; (801e6d8 <finsh_compile+0xe74>)
 801e6d2:	6013      	str	r3, [r2, #0]

                    break;
 801e6d4:	e0ca      	b.n	801e86c <finsh_compile+0x1008>
 801e6d6:	bf00      	nop
 801e6d8:	20012bdc 	.word	0x20012bdc
                case FINSH_DATA_TYPE_WORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
 801e6dc:	4b71      	ldr	r3, [pc, #452]	; (801e8a4 <finsh_compile+0x1040>)
 801e6de:	681b      	ldr	r3, [r3, #0]
 801e6e0:	2226      	movs	r2, #38	; 0x26
 801e6e2:	701a      	strb	r2, [r3, #0]
 801e6e4:	4b6f      	ldr	r3, [pc, #444]	; (801e8a4 <finsh_compile+0x1040>)
 801e6e6:	681b      	ldr	r3, [r3, #0]
 801e6e8:	3301      	adds	r3, #1
 801e6ea:	4a6e      	ldr	r2, [pc, #440]	; (801e8a4 <finsh_compile+0x1040>)
 801e6ec:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.short_value));
 801e6ee:	4b6d      	ldr	r3, [pc, #436]	; (801e8a4 <finsh_compile+0x1040>)
 801e6f0:	681b      	ldr	r3, [r3, #0]
 801e6f2:	693a      	ldr	r2, [r7, #16]
 801e6f4:	3214      	adds	r2, #20
 801e6f6:	b2d2      	uxtb	r2, r2
 801e6f8:	701a      	strb	r2, [r3, #0]
 801e6fa:	4b6a      	ldr	r3, [pc, #424]	; (801e8a4 <finsh_compile+0x1040>)
 801e6fc:	681b      	ldr	r3, [r3, #0]
 801e6fe:	3301      	adds	r3, #1
 801e700:	693a      	ldr	r2, [r7, #16]
 801e702:	3214      	adds	r2, #20
 801e704:	0a12      	lsrs	r2, r2, #8
 801e706:	b2d2      	uxtb	r2, r2
 801e708:	701a      	strb	r2, [r3, #0]
 801e70a:	4b66      	ldr	r3, [pc, #408]	; (801e8a4 <finsh_compile+0x1040>)
 801e70c:	681b      	ldr	r3, [r3, #0]
 801e70e:	3302      	adds	r3, #2
 801e710:	693a      	ldr	r2, [r7, #16]
 801e712:	3214      	adds	r2, #20
 801e714:	0c12      	lsrs	r2, r2, #16
 801e716:	b2d2      	uxtb	r2, r2
 801e718:	701a      	strb	r2, [r3, #0]
 801e71a:	4b62      	ldr	r3, [pc, #392]	; (801e8a4 <finsh_compile+0x1040>)
 801e71c:	681b      	ldr	r3, [r3, #0]
 801e71e:	3303      	adds	r3, #3
 801e720:	693a      	ldr	r2, [r7, #16]
 801e722:	3214      	adds	r2, #20
 801e724:	0e12      	lsrs	r2, r2, #24
 801e726:	b2d2      	uxtb	r2, r2
 801e728:	701a      	strb	r2, [r3, #0]
 801e72a:	4b5e      	ldr	r3, [pc, #376]	; (801e8a4 <finsh_compile+0x1040>)
 801e72c:	681b      	ldr	r3, [r3, #0]
 801e72e:	3304      	adds	r3, #4
 801e730:	4a5c      	ldr	r2, [pc, #368]	; (801e8a4 <finsh_compile+0x1040>)
 801e732:	6013      	str	r3, [r2, #0]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
 801e734:	4b5b      	ldr	r3, [pc, #364]	; (801e8a4 <finsh_compile+0x1040>)
 801e736:	681b      	ldr	r3, [r3, #0]
 801e738:	2223      	movs	r2, #35	; 0x23
 801e73a:	701a      	strb	r2, [r3, #0]
 801e73c:	4b59      	ldr	r3, [pc, #356]	; (801e8a4 <finsh_compile+0x1040>)
 801e73e:	681b      	ldr	r3, [r3, #0]
 801e740:	3301      	adds	r3, #1
 801e742:	4a58      	ldr	r2, [pc, #352]	; (801e8a4 <finsh_compile+0x1040>)
 801e744:	6013      	str	r3, [r2, #0]
                    finsh_code_word(1);
 801e746:	4b57      	ldr	r3, [pc, #348]	; (801e8a4 <finsh_compile+0x1040>)
 801e748:	681b      	ldr	r3, [r3, #0]
 801e74a:	2201      	movs	r2, #1
 801e74c:	701a      	strb	r2, [r3, #0]
 801e74e:	4b55      	ldr	r3, [pc, #340]	; (801e8a4 <finsh_compile+0x1040>)
 801e750:	681b      	ldr	r3, [r3, #0]
 801e752:	3301      	adds	r3, #1
 801e754:	2200      	movs	r2, #0
 801e756:	701a      	strb	r2, [r3, #0]
 801e758:	4b52      	ldr	r3, [pc, #328]	; (801e8a4 <finsh_compile+0x1040>)
 801e75a:	681b      	ldr	r3, [r3, #0]
 801e75c:	3302      	adds	r3, #2
 801e75e:	4a51      	ldr	r2, [pc, #324]	; (801e8a4 <finsh_compile+0x1040>)
 801e760:	6013      	str	r3, [r2, #0]

                    /* add_word */
                    finsh_code_byte(FINSH_OP_SUB_WORD);
 801e762:	4b50      	ldr	r3, [pc, #320]	; (801e8a4 <finsh_compile+0x1040>)
 801e764:	681b      	ldr	r3, [r3, #0]
 801e766:	2205      	movs	r2, #5
 801e768:	701a      	strb	r2, [r3, #0]
 801e76a:	4b4e      	ldr	r3, [pc, #312]	; (801e8a4 <finsh_compile+0x1040>)
 801e76c:	681b      	ldr	r3, [r3, #0]
 801e76e:	3301      	adds	r3, #1
 801e770:	4a4c      	ldr	r2, [pc, #304]	; (801e8a4 <finsh_compile+0x1040>)
 801e772:	6013      	str	r3, [r2, #0]
                    /* st_word */
                    finsh_code_byte(FINSH_OP_ST_WORD);
 801e774:	4b4b      	ldr	r3, [pc, #300]	; (801e8a4 <finsh_compile+0x1040>)
 801e776:	681b      	ldr	r3, [r3, #0]
 801e778:	2229      	movs	r2, #41	; 0x29
 801e77a:	701a      	strb	r2, [r3, #0]
 801e77c:	4b49      	ldr	r3, [pc, #292]	; (801e8a4 <finsh_compile+0x1040>)
 801e77e:	681b      	ldr	r3, [r3, #0]
 801e780:	3301      	adds	r3, #1
 801e782:	4a48      	ldr	r2, [pc, #288]	; (801e8a4 <finsh_compile+0x1040>)
 801e784:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801e786:	4b47      	ldr	r3, [pc, #284]	; (801e8a4 <finsh_compile+0x1040>)
 801e788:	681b      	ldr	r3, [r3, #0]
 801e78a:	222f      	movs	r2, #47	; 0x2f
 801e78c:	701a      	strb	r2, [r3, #0]
 801e78e:	4b45      	ldr	r3, [pc, #276]	; (801e8a4 <finsh_compile+0x1040>)
 801e790:	681b      	ldr	r3, [r3, #0]
 801e792:	3301      	adds	r3, #1
 801e794:	4a43      	ldr	r2, [pc, #268]	; (801e8a4 <finsh_compile+0x1040>)
 801e796:	6013      	str	r3, [r2, #0]

                    break;
 801e798:	e068      	b.n	801e86c <finsh_compile+0x1008>
                case FINSH_DATA_TYPE_DWORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
 801e79a:	4b42      	ldr	r3, [pc, #264]	; (801e8a4 <finsh_compile+0x1040>)
 801e79c:	681b      	ldr	r3, [r3, #0]
 801e79e:	2227      	movs	r2, #39	; 0x27
 801e7a0:	701a      	strb	r2, [r3, #0]
 801e7a2:	4b40      	ldr	r3, [pc, #256]	; (801e8a4 <finsh_compile+0x1040>)
 801e7a4:	681b      	ldr	r3, [r3, #0]
 801e7a6:	3301      	adds	r3, #1
 801e7a8:	4a3e      	ldr	r2, [pc, #248]	; (801e8a4 <finsh_compile+0x1040>)
 801e7aa:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.long_value));
 801e7ac:	4b3d      	ldr	r3, [pc, #244]	; (801e8a4 <finsh_compile+0x1040>)
 801e7ae:	681b      	ldr	r3, [r3, #0]
 801e7b0:	693a      	ldr	r2, [r7, #16]
 801e7b2:	3214      	adds	r2, #20
 801e7b4:	b2d2      	uxtb	r2, r2
 801e7b6:	701a      	strb	r2, [r3, #0]
 801e7b8:	4b3a      	ldr	r3, [pc, #232]	; (801e8a4 <finsh_compile+0x1040>)
 801e7ba:	681b      	ldr	r3, [r3, #0]
 801e7bc:	3301      	adds	r3, #1
 801e7be:	693a      	ldr	r2, [r7, #16]
 801e7c0:	3214      	adds	r2, #20
 801e7c2:	0a12      	lsrs	r2, r2, #8
 801e7c4:	b2d2      	uxtb	r2, r2
 801e7c6:	701a      	strb	r2, [r3, #0]
 801e7c8:	4b36      	ldr	r3, [pc, #216]	; (801e8a4 <finsh_compile+0x1040>)
 801e7ca:	681b      	ldr	r3, [r3, #0]
 801e7cc:	3302      	adds	r3, #2
 801e7ce:	693a      	ldr	r2, [r7, #16]
 801e7d0:	3214      	adds	r2, #20
 801e7d2:	0c12      	lsrs	r2, r2, #16
 801e7d4:	b2d2      	uxtb	r2, r2
 801e7d6:	701a      	strb	r2, [r3, #0]
 801e7d8:	4b32      	ldr	r3, [pc, #200]	; (801e8a4 <finsh_compile+0x1040>)
 801e7da:	681b      	ldr	r3, [r3, #0]
 801e7dc:	3303      	adds	r3, #3
 801e7de:	693a      	ldr	r2, [r7, #16]
 801e7e0:	3214      	adds	r2, #20
 801e7e2:	0e12      	lsrs	r2, r2, #24
 801e7e4:	b2d2      	uxtb	r2, r2
 801e7e6:	701a      	strb	r2, [r3, #0]
 801e7e8:	4b2e      	ldr	r3, [pc, #184]	; (801e8a4 <finsh_compile+0x1040>)
 801e7ea:	681b      	ldr	r3, [r3, #0]
 801e7ec:	3304      	adds	r3, #4
 801e7ee:	4a2d      	ldr	r2, [pc, #180]	; (801e8a4 <finsh_compile+0x1040>)
 801e7f0:	6013      	str	r3, [r2, #0]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801e7f2:	4b2c      	ldr	r3, [pc, #176]	; (801e8a4 <finsh_compile+0x1040>)
 801e7f4:	681b      	ldr	r3, [r3, #0]
 801e7f6:	2224      	movs	r2, #36	; 0x24
 801e7f8:	701a      	strb	r2, [r3, #0]
 801e7fa:	4b2a      	ldr	r3, [pc, #168]	; (801e8a4 <finsh_compile+0x1040>)
 801e7fc:	681b      	ldr	r3, [r3, #0]
 801e7fe:	3301      	adds	r3, #1
 801e800:	4a28      	ldr	r2, [pc, #160]	; (801e8a4 <finsh_compile+0x1040>)
 801e802:	6013      	str	r3, [r2, #0]
                    finsh_code_dword(1);
 801e804:	4b27      	ldr	r3, [pc, #156]	; (801e8a4 <finsh_compile+0x1040>)
 801e806:	681b      	ldr	r3, [r3, #0]
 801e808:	2201      	movs	r2, #1
 801e80a:	701a      	strb	r2, [r3, #0]
 801e80c:	4b25      	ldr	r3, [pc, #148]	; (801e8a4 <finsh_compile+0x1040>)
 801e80e:	681b      	ldr	r3, [r3, #0]
 801e810:	3301      	adds	r3, #1
 801e812:	2200      	movs	r2, #0
 801e814:	701a      	strb	r2, [r3, #0]
 801e816:	4b23      	ldr	r3, [pc, #140]	; (801e8a4 <finsh_compile+0x1040>)
 801e818:	681b      	ldr	r3, [r3, #0]
 801e81a:	3302      	adds	r3, #2
 801e81c:	2200      	movs	r2, #0
 801e81e:	701a      	strb	r2, [r3, #0]
 801e820:	4b20      	ldr	r3, [pc, #128]	; (801e8a4 <finsh_compile+0x1040>)
 801e822:	681b      	ldr	r3, [r3, #0]
 801e824:	3303      	adds	r3, #3
 801e826:	2200      	movs	r2, #0
 801e828:	701a      	strb	r2, [r3, #0]
 801e82a:	4b1e      	ldr	r3, [pc, #120]	; (801e8a4 <finsh_compile+0x1040>)
 801e82c:	681b      	ldr	r3, [r3, #0]
 801e82e:	3304      	adds	r3, #4
 801e830:	4a1c      	ldr	r2, [pc, #112]	; (801e8a4 <finsh_compile+0x1040>)
 801e832:	6013      	str	r3, [r2, #0]

                    /* add_dword */
                    finsh_code_byte(FINSH_OP_SUB_DWORD);
 801e834:	4b1b      	ldr	r3, [pc, #108]	; (801e8a4 <finsh_compile+0x1040>)
 801e836:	681b      	ldr	r3, [r3, #0]
 801e838:	2206      	movs	r2, #6
 801e83a:	701a      	strb	r2, [r3, #0]
 801e83c:	4b19      	ldr	r3, [pc, #100]	; (801e8a4 <finsh_compile+0x1040>)
 801e83e:	681b      	ldr	r3, [r3, #0]
 801e840:	3301      	adds	r3, #1
 801e842:	4a18      	ldr	r2, [pc, #96]	; (801e8a4 <finsh_compile+0x1040>)
 801e844:	6013      	str	r3, [r2, #0]
                    /* st_dword */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
 801e846:	4b17      	ldr	r3, [pc, #92]	; (801e8a4 <finsh_compile+0x1040>)
 801e848:	681b      	ldr	r3, [r3, #0]
 801e84a:	222a      	movs	r2, #42	; 0x2a
 801e84c:	701a      	strb	r2, [r3, #0]
 801e84e:	4b15      	ldr	r3, [pc, #84]	; (801e8a4 <finsh_compile+0x1040>)
 801e850:	681b      	ldr	r3, [r3, #0]
 801e852:	3301      	adds	r3, #1
 801e854:	4a13      	ldr	r2, [pc, #76]	; (801e8a4 <finsh_compile+0x1040>)
 801e856:	6013      	str	r3, [r2, #0]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801e858:	4b12      	ldr	r3, [pc, #72]	; (801e8a4 <finsh_compile+0x1040>)
 801e85a:	681b      	ldr	r3, [r3, #0]
 801e85c:	222f      	movs	r2, #47	; 0x2f
 801e85e:	701a      	strb	r2, [r3, #0]
 801e860:	4b10      	ldr	r3, [pc, #64]	; (801e8a4 <finsh_compile+0x1040>)
 801e862:	681b      	ldr	r3, [r3, #0]
 801e864:	3301      	adds	r3, #1
 801e866:	4a0f      	ldr	r2, [pc, #60]	; (801e8a4 <finsh_compile+0x1040>)
 801e868:	6013      	str	r3, [r2, #0]

                    break;
 801e86a:	bf00      	nop
                }
            }
            break;
 801e86c:	e3d9      	b.n	801f022 <finsh_compile+0x17be>

        /* increase */
        case FINSH_NODE_SYS_INC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
 801e86e:	687b      	ldr	r3, [r7, #4]
 801e870:	691b      	ldr	r3, [r3, #16]
 801e872:	2b00      	cmp	r3, #0
 801e874:	f000 81c1 	beq.w	801ebfa <finsh_compile+0x1396>
 801e878:	687b      	ldr	r3, [r7, #4]
 801e87a:	691b      	ldr	r3, [r3, #16]
 801e87c:	781b      	ldrb	r3, [r3, #0]
 801e87e:	2b01      	cmp	r3, #1
 801e880:	f040 81bb 	bne.w	801ebfa <finsh_compile+0x1396>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
 801e884:	687b      	ldr	r3, [r7, #4]
 801e886:	691b      	ldr	r3, [r3, #16]
 801e888:	689b      	ldr	r3, [r3, #8]
 801e88a:	60fb      	str	r3, [r7, #12]

                switch (node->data_type)
 801e88c:	687b      	ldr	r3, [r7, #4]
 801e88e:	785b      	ldrb	r3, [r3, #1]
 801e890:	2b02      	cmp	r3, #2
 801e892:	f000 808f 	beq.w	801e9b4 <finsh_compile+0x1150>
 801e896:	2b03      	cmp	r3, #3
 801e898:	f000 811a 	beq.w	801ead0 <finsh_compile+0x126c>
 801e89c:	2b01      	cmp	r3, #1
 801e89e:	d003      	beq.n	801e8a8 <finsh_compile+0x1044>
                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
                    break;
                }
            }
            break;
 801e8a0:	e3bf      	b.n	801f022 <finsh_compile+0x17be>
 801e8a2:	bf00      	nop
 801e8a4:	20012bdc 	.word	0x20012bdc
                    /* ld_value_byte &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801e8a8:	4b88      	ldr	r3, [pc, #544]	; (801eacc <finsh_compile+0x1268>)
 801e8aa:	681b      	ldr	r3, [r3, #0]
 801e8ac:	2224      	movs	r2, #36	; 0x24
 801e8ae:	701a      	strb	r2, [r3, #0]
 801e8b0:	4b86      	ldr	r3, [pc, #536]	; (801eacc <finsh_compile+0x1268>)
 801e8b2:	681b      	ldr	r3, [r3, #0]
 801e8b4:	3301      	adds	r3, #1
 801e8b6:	4a85      	ldr	r2, [pc, #532]	; (801eacc <finsh_compile+0x1268>)
 801e8b8:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.char_value));
 801e8ba:	4b84      	ldr	r3, [pc, #528]	; (801eacc <finsh_compile+0x1268>)
 801e8bc:	681b      	ldr	r3, [r3, #0]
 801e8be:	68fa      	ldr	r2, [r7, #12]
 801e8c0:	3214      	adds	r2, #20
 801e8c2:	b2d2      	uxtb	r2, r2
 801e8c4:	701a      	strb	r2, [r3, #0]
 801e8c6:	4b81      	ldr	r3, [pc, #516]	; (801eacc <finsh_compile+0x1268>)
 801e8c8:	681b      	ldr	r3, [r3, #0]
 801e8ca:	3301      	adds	r3, #1
 801e8cc:	68fa      	ldr	r2, [r7, #12]
 801e8ce:	3214      	adds	r2, #20
 801e8d0:	0a12      	lsrs	r2, r2, #8
 801e8d2:	b2d2      	uxtb	r2, r2
 801e8d4:	701a      	strb	r2, [r3, #0]
 801e8d6:	4b7d      	ldr	r3, [pc, #500]	; (801eacc <finsh_compile+0x1268>)
 801e8d8:	681b      	ldr	r3, [r3, #0]
 801e8da:	3302      	adds	r3, #2
 801e8dc:	68fa      	ldr	r2, [r7, #12]
 801e8de:	3214      	adds	r2, #20
 801e8e0:	0c12      	lsrs	r2, r2, #16
 801e8e2:	b2d2      	uxtb	r2, r2
 801e8e4:	701a      	strb	r2, [r3, #0]
 801e8e6:	4b79      	ldr	r3, [pc, #484]	; (801eacc <finsh_compile+0x1268>)
 801e8e8:	681b      	ldr	r3, [r3, #0]
 801e8ea:	3303      	adds	r3, #3
 801e8ec:	68fa      	ldr	r2, [r7, #12]
 801e8ee:	3214      	adds	r2, #20
 801e8f0:	0e12      	lsrs	r2, r2, #24
 801e8f2:	b2d2      	uxtb	r2, r2
 801e8f4:	701a      	strb	r2, [r3, #0]
 801e8f6:	4b75      	ldr	r3, [pc, #468]	; (801eacc <finsh_compile+0x1268>)
 801e8f8:	681b      	ldr	r3, [r3, #0]
 801e8fa:	3304      	adds	r3, #4
 801e8fc:	4a73      	ldr	r2, [pc, #460]	; (801eacc <finsh_compile+0x1268>)
 801e8fe:	6013      	str	r3, [r2, #0]

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
 801e900:	4b72      	ldr	r3, [pc, #456]	; (801eacc <finsh_compile+0x1268>)
 801e902:	681b      	ldr	r3, [r3, #0]
 801e904:	2225      	movs	r2, #37	; 0x25
 801e906:	701a      	strb	r2, [r3, #0]
 801e908:	4b70      	ldr	r3, [pc, #448]	; (801eacc <finsh_compile+0x1268>)
 801e90a:	681b      	ldr	r3, [r3, #0]
 801e90c:	3301      	adds	r3, #1
 801e90e:	4a6f      	ldr	r2, [pc, #444]	; (801eacc <finsh_compile+0x1268>)
 801e910:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.char_value));
 801e912:	4b6e      	ldr	r3, [pc, #440]	; (801eacc <finsh_compile+0x1268>)
 801e914:	681b      	ldr	r3, [r3, #0]
 801e916:	68fa      	ldr	r2, [r7, #12]
 801e918:	3214      	adds	r2, #20
 801e91a:	b2d2      	uxtb	r2, r2
 801e91c:	701a      	strb	r2, [r3, #0]
 801e91e:	4b6b      	ldr	r3, [pc, #428]	; (801eacc <finsh_compile+0x1268>)
 801e920:	681b      	ldr	r3, [r3, #0]
 801e922:	3301      	adds	r3, #1
 801e924:	68fa      	ldr	r2, [r7, #12]
 801e926:	3214      	adds	r2, #20
 801e928:	0a12      	lsrs	r2, r2, #8
 801e92a:	b2d2      	uxtb	r2, r2
 801e92c:	701a      	strb	r2, [r3, #0]
 801e92e:	4b67      	ldr	r3, [pc, #412]	; (801eacc <finsh_compile+0x1268>)
 801e930:	681b      	ldr	r3, [r3, #0]
 801e932:	3302      	adds	r3, #2
 801e934:	68fa      	ldr	r2, [r7, #12]
 801e936:	3214      	adds	r2, #20
 801e938:	0c12      	lsrs	r2, r2, #16
 801e93a:	b2d2      	uxtb	r2, r2
 801e93c:	701a      	strb	r2, [r3, #0]
 801e93e:	4b63      	ldr	r3, [pc, #396]	; (801eacc <finsh_compile+0x1268>)
 801e940:	681b      	ldr	r3, [r3, #0]
 801e942:	3303      	adds	r3, #3
 801e944:	68fa      	ldr	r2, [r7, #12]
 801e946:	3214      	adds	r2, #20
 801e948:	0e12      	lsrs	r2, r2, #24
 801e94a:	b2d2      	uxtb	r2, r2
 801e94c:	701a      	strb	r2, [r3, #0]
 801e94e:	4b5f      	ldr	r3, [pc, #380]	; (801eacc <finsh_compile+0x1268>)
 801e950:	681b      	ldr	r3, [r3, #0]
 801e952:	3304      	adds	r3, #4
 801e954:	4a5d      	ldr	r2, [pc, #372]	; (801eacc <finsh_compile+0x1268>)
 801e956:	6013      	str	r3, [r2, #0]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
 801e958:	4b5c      	ldr	r3, [pc, #368]	; (801eacc <finsh_compile+0x1268>)
 801e95a:	681b      	ldr	r3, [r3, #0]
 801e95c:	2222      	movs	r2, #34	; 0x22
 801e95e:	701a      	strb	r2, [r3, #0]
 801e960:	4b5a      	ldr	r3, [pc, #360]	; (801eacc <finsh_compile+0x1268>)
 801e962:	681b      	ldr	r3, [r3, #0]
 801e964:	3301      	adds	r3, #1
 801e966:	4a59      	ldr	r2, [pc, #356]	; (801eacc <finsh_compile+0x1268>)
 801e968:	6013      	str	r3, [r2, #0]
                    finsh_code_byte(1);
 801e96a:	4b58      	ldr	r3, [pc, #352]	; (801eacc <finsh_compile+0x1268>)
 801e96c:	681b      	ldr	r3, [r3, #0]
 801e96e:	2201      	movs	r2, #1
 801e970:	701a      	strb	r2, [r3, #0]
 801e972:	4b56      	ldr	r3, [pc, #344]	; (801eacc <finsh_compile+0x1268>)
 801e974:	681b      	ldr	r3, [r3, #0]
 801e976:	3301      	adds	r3, #1
 801e978:	4a54      	ldr	r2, [pc, #336]	; (801eacc <finsh_compile+0x1268>)
 801e97a:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_BYTE);
 801e97c:	4b53      	ldr	r3, [pc, #332]	; (801eacc <finsh_compile+0x1268>)
 801e97e:	681b      	ldr	r3, [r3, #0]
 801e980:	2201      	movs	r2, #1
 801e982:	701a      	strb	r2, [r3, #0]
 801e984:	4b51      	ldr	r3, [pc, #324]	; (801eacc <finsh_compile+0x1268>)
 801e986:	681b      	ldr	r3, [r3, #0]
 801e988:	3301      	adds	r3, #1
 801e98a:	4a50      	ldr	r2, [pc, #320]	; (801eacc <finsh_compile+0x1268>)
 801e98c:	6013      	str	r3, [r2, #0]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
 801e98e:	4b4f      	ldr	r3, [pc, #316]	; (801eacc <finsh_compile+0x1268>)
 801e990:	681b      	ldr	r3, [r3, #0]
 801e992:	2228      	movs	r2, #40	; 0x28
 801e994:	701a      	strb	r2, [r3, #0]
 801e996:	4b4d      	ldr	r3, [pc, #308]	; (801eacc <finsh_compile+0x1268>)
 801e998:	681b      	ldr	r3, [r3, #0]
 801e99a:	3301      	adds	r3, #1
 801e99c:	4a4b      	ldr	r2, [pc, #300]	; (801eacc <finsh_compile+0x1268>)
 801e99e:	6013      	str	r3, [r2, #0]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
 801e9a0:	4b4a      	ldr	r3, [pc, #296]	; (801eacc <finsh_compile+0x1268>)
 801e9a2:	681b      	ldr	r3, [r3, #0]
 801e9a4:	222b      	movs	r2, #43	; 0x2b
 801e9a6:	701a      	strb	r2, [r3, #0]
 801e9a8:	4b48      	ldr	r3, [pc, #288]	; (801eacc <finsh_compile+0x1268>)
 801e9aa:	681b      	ldr	r3, [r3, #0]
 801e9ac:	3301      	adds	r3, #1
 801e9ae:	4a47      	ldr	r2, [pc, #284]	; (801eacc <finsh_compile+0x1268>)
 801e9b0:	6013      	str	r3, [r2, #0]
                    break;
 801e9b2:	e122      	b.n	801ebfa <finsh_compile+0x1396>
                    /* ld_value_word &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801e9b4:	4b45      	ldr	r3, [pc, #276]	; (801eacc <finsh_compile+0x1268>)
 801e9b6:	681b      	ldr	r3, [r3, #0]
 801e9b8:	2224      	movs	r2, #36	; 0x24
 801e9ba:	701a      	strb	r2, [r3, #0]
 801e9bc:	4b43      	ldr	r3, [pc, #268]	; (801eacc <finsh_compile+0x1268>)
 801e9be:	681b      	ldr	r3, [r3, #0]
 801e9c0:	3301      	adds	r3, #1
 801e9c2:	4a42      	ldr	r2, [pc, #264]	; (801eacc <finsh_compile+0x1268>)
 801e9c4:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.short_value));
 801e9c6:	4b41      	ldr	r3, [pc, #260]	; (801eacc <finsh_compile+0x1268>)
 801e9c8:	681b      	ldr	r3, [r3, #0]
 801e9ca:	68fa      	ldr	r2, [r7, #12]
 801e9cc:	3214      	adds	r2, #20
 801e9ce:	b2d2      	uxtb	r2, r2
 801e9d0:	701a      	strb	r2, [r3, #0]
 801e9d2:	4b3e      	ldr	r3, [pc, #248]	; (801eacc <finsh_compile+0x1268>)
 801e9d4:	681b      	ldr	r3, [r3, #0]
 801e9d6:	3301      	adds	r3, #1
 801e9d8:	68fa      	ldr	r2, [r7, #12]
 801e9da:	3214      	adds	r2, #20
 801e9dc:	0a12      	lsrs	r2, r2, #8
 801e9de:	b2d2      	uxtb	r2, r2
 801e9e0:	701a      	strb	r2, [r3, #0]
 801e9e2:	4b3a      	ldr	r3, [pc, #232]	; (801eacc <finsh_compile+0x1268>)
 801e9e4:	681b      	ldr	r3, [r3, #0]
 801e9e6:	3302      	adds	r3, #2
 801e9e8:	68fa      	ldr	r2, [r7, #12]
 801e9ea:	3214      	adds	r2, #20
 801e9ec:	0c12      	lsrs	r2, r2, #16
 801e9ee:	b2d2      	uxtb	r2, r2
 801e9f0:	701a      	strb	r2, [r3, #0]
 801e9f2:	4b36      	ldr	r3, [pc, #216]	; (801eacc <finsh_compile+0x1268>)
 801e9f4:	681b      	ldr	r3, [r3, #0]
 801e9f6:	3303      	adds	r3, #3
 801e9f8:	68fa      	ldr	r2, [r7, #12]
 801e9fa:	3214      	adds	r2, #20
 801e9fc:	0e12      	lsrs	r2, r2, #24
 801e9fe:	b2d2      	uxtb	r2, r2
 801ea00:	701a      	strb	r2, [r3, #0]
 801ea02:	4b32      	ldr	r3, [pc, #200]	; (801eacc <finsh_compile+0x1268>)
 801ea04:	681b      	ldr	r3, [r3, #0]
 801ea06:	3304      	adds	r3, #4
 801ea08:	4a30      	ldr	r2, [pc, #192]	; (801eacc <finsh_compile+0x1268>)
 801ea0a:	6013      	str	r3, [r2, #0]

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
 801ea0c:	4b2f      	ldr	r3, [pc, #188]	; (801eacc <finsh_compile+0x1268>)
 801ea0e:	681b      	ldr	r3, [r3, #0]
 801ea10:	2226      	movs	r2, #38	; 0x26
 801ea12:	701a      	strb	r2, [r3, #0]
 801ea14:	4b2d      	ldr	r3, [pc, #180]	; (801eacc <finsh_compile+0x1268>)
 801ea16:	681b      	ldr	r3, [r3, #0]
 801ea18:	3301      	adds	r3, #1
 801ea1a:	4a2c      	ldr	r2, [pc, #176]	; (801eacc <finsh_compile+0x1268>)
 801ea1c:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.short_value));
 801ea1e:	4b2b      	ldr	r3, [pc, #172]	; (801eacc <finsh_compile+0x1268>)
 801ea20:	681b      	ldr	r3, [r3, #0]
 801ea22:	68fa      	ldr	r2, [r7, #12]
 801ea24:	3214      	adds	r2, #20
 801ea26:	b2d2      	uxtb	r2, r2
 801ea28:	701a      	strb	r2, [r3, #0]
 801ea2a:	4b28      	ldr	r3, [pc, #160]	; (801eacc <finsh_compile+0x1268>)
 801ea2c:	681b      	ldr	r3, [r3, #0]
 801ea2e:	3301      	adds	r3, #1
 801ea30:	68fa      	ldr	r2, [r7, #12]
 801ea32:	3214      	adds	r2, #20
 801ea34:	0a12      	lsrs	r2, r2, #8
 801ea36:	b2d2      	uxtb	r2, r2
 801ea38:	701a      	strb	r2, [r3, #0]
 801ea3a:	4b24      	ldr	r3, [pc, #144]	; (801eacc <finsh_compile+0x1268>)
 801ea3c:	681b      	ldr	r3, [r3, #0]
 801ea3e:	3302      	adds	r3, #2
 801ea40:	68fa      	ldr	r2, [r7, #12]
 801ea42:	3214      	adds	r2, #20
 801ea44:	0c12      	lsrs	r2, r2, #16
 801ea46:	b2d2      	uxtb	r2, r2
 801ea48:	701a      	strb	r2, [r3, #0]
 801ea4a:	4b20      	ldr	r3, [pc, #128]	; (801eacc <finsh_compile+0x1268>)
 801ea4c:	681b      	ldr	r3, [r3, #0]
 801ea4e:	3303      	adds	r3, #3
 801ea50:	68fa      	ldr	r2, [r7, #12]
 801ea52:	3214      	adds	r2, #20
 801ea54:	0e12      	lsrs	r2, r2, #24
 801ea56:	b2d2      	uxtb	r2, r2
 801ea58:	701a      	strb	r2, [r3, #0]
 801ea5a:	4b1c      	ldr	r3, [pc, #112]	; (801eacc <finsh_compile+0x1268>)
 801ea5c:	681b      	ldr	r3, [r3, #0]
 801ea5e:	3304      	adds	r3, #4
 801ea60:	4a1a      	ldr	r2, [pc, #104]	; (801eacc <finsh_compile+0x1268>)
 801ea62:	6013      	str	r3, [r2, #0]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
 801ea64:	4b19      	ldr	r3, [pc, #100]	; (801eacc <finsh_compile+0x1268>)
 801ea66:	681b      	ldr	r3, [r3, #0]
 801ea68:	2223      	movs	r2, #35	; 0x23
 801ea6a:	701a      	strb	r2, [r3, #0]
 801ea6c:	4b17      	ldr	r3, [pc, #92]	; (801eacc <finsh_compile+0x1268>)
 801ea6e:	681b      	ldr	r3, [r3, #0]
 801ea70:	3301      	adds	r3, #1
 801ea72:	4a16      	ldr	r2, [pc, #88]	; (801eacc <finsh_compile+0x1268>)
 801ea74:	6013      	str	r3, [r2, #0]
                    finsh_code_word(1);
 801ea76:	4b15      	ldr	r3, [pc, #84]	; (801eacc <finsh_compile+0x1268>)
 801ea78:	681b      	ldr	r3, [r3, #0]
 801ea7a:	2201      	movs	r2, #1
 801ea7c:	701a      	strb	r2, [r3, #0]
 801ea7e:	4b13      	ldr	r3, [pc, #76]	; (801eacc <finsh_compile+0x1268>)
 801ea80:	681b      	ldr	r3, [r3, #0]
 801ea82:	3301      	adds	r3, #1
 801ea84:	2200      	movs	r2, #0
 801ea86:	701a      	strb	r2, [r3, #0]
 801ea88:	4b10      	ldr	r3, [pc, #64]	; (801eacc <finsh_compile+0x1268>)
 801ea8a:	681b      	ldr	r3, [r3, #0]
 801ea8c:	3302      	adds	r3, #2
 801ea8e:	4a0f      	ldr	r2, [pc, #60]	; (801eacc <finsh_compile+0x1268>)
 801ea90:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_WORD);
 801ea92:	4b0e      	ldr	r3, [pc, #56]	; (801eacc <finsh_compile+0x1268>)
 801ea94:	681b      	ldr	r3, [r3, #0]
 801ea96:	2202      	movs	r2, #2
 801ea98:	701a      	strb	r2, [r3, #0]
 801ea9a:	4b0c      	ldr	r3, [pc, #48]	; (801eacc <finsh_compile+0x1268>)
 801ea9c:	681b      	ldr	r3, [r3, #0]
 801ea9e:	3301      	adds	r3, #1
 801eaa0:	4a0a      	ldr	r2, [pc, #40]	; (801eacc <finsh_compile+0x1268>)
 801eaa2:	6013      	str	r3, [r2, #0]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_WORD);
 801eaa4:	4b09      	ldr	r3, [pc, #36]	; (801eacc <finsh_compile+0x1268>)
 801eaa6:	681b      	ldr	r3, [r3, #0]
 801eaa8:	2229      	movs	r2, #41	; 0x29
 801eaaa:	701a      	strb	r2, [r3, #0]
 801eaac:	4b07      	ldr	r3, [pc, #28]	; (801eacc <finsh_compile+0x1268>)
 801eaae:	681b      	ldr	r3, [r3, #0]
 801eab0:	3301      	adds	r3, #1
 801eab2:	4a06      	ldr	r2, [pc, #24]	; (801eacc <finsh_compile+0x1268>)
 801eab4:	6013      	str	r3, [r2, #0]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
 801eab6:	4b05      	ldr	r3, [pc, #20]	; (801eacc <finsh_compile+0x1268>)
 801eab8:	681b      	ldr	r3, [r3, #0]
 801eaba:	222b      	movs	r2, #43	; 0x2b
 801eabc:	701a      	strb	r2, [r3, #0]
 801eabe:	4b03      	ldr	r3, [pc, #12]	; (801eacc <finsh_compile+0x1268>)
 801eac0:	681b      	ldr	r3, [r3, #0]
 801eac2:	3301      	adds	r3, #1
 801eac4:	4a01      	ldr	r2, [pc, #4]	; (801eacc <finsh_compile+0x1268>)
 801eac6:	6013      	str	r3, [r2, #0]
                    break;
 801eac8:	e097      	b.n	801ebfa <finsh_compile+0x1396>
 801eaca:	bf00      	nop
 801eacc:	20012bdc 	.word	0x20012bdc
                    /* ld_value_dword &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801ead0:	4b9a      	ldr	r3, [pc, #616]	; (801ed3c <finsh_compile+0x14d8>)
 801ead2:	681b      	ldr	r3, [r3, #0]
 801ead4:	2224      	movs	r2, #36	; 0x24
 801ead6:	701a      	strb	r2, [r3, #0]
 801ead8:	4b98      	ldr	r3, [pc, #608]	; (801ed3c <finsh_compile+0x14d8>)
 801eada:	681b      	ldr	r3, [r3, #0]
 801eadc:	3301      	adds	r3, #1
 801eade:	4a97      	ldr	r2, [pc, #604]	; (801ed3c <finsh_compile+0x14d8>)
 801eae0:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.long_value));
 801eae2:	4b96      	ldr	r3, [pc, #600]	; (801ed3c <finsh_compile+0x14d8>)
 801eae4:	681b      	ldr	r3, [r3, #0]
 801eae6:	68fa      	ldr	r2, [r7, #12]
 801eae8:	3214      	adds	r2, #20
 801eaea:	b2d2      	uxtb	r2, r2
 801eaec:	701a      	strb	r2, [r3, #0]
 801eaee:	4b93      	ldr	r3, [pc, #588]	; (801ed3c <finsh_compile+0x14d8>)
 801eaf0:	681b      	ldr	r3, [r3, #0]
 801eaf2:	3301      	adds	r3, #1
 801eaf4:	68fa      	ldr	r2, [r7, #12]
 801eaf6:	3214      	adds	r2, #20
 801eaf8:	0a12      	lsrs	r2, r2, #8
 801eafa:	b2d2      	uxtb	r2, r2
 801eafc:	701a      	strb	r2, [r3, #0]
 801eafe:	4b8f      	ldr	r3, [pc, #572]	; (801ed3c <finsh_compile+0x14d8>)
 801eb00:	681b      	ldr	r3, [r3, #0]
 801eb02:	3302      	adds	r3, #2
 801eb04:	68fa      	ldr	r2, [r7, #12]
 801eb06:	3214      	adds	r2, #20
 801eb08:	0c12      	lsrs	r2, r2, #16
 801eb0a:	b2d2      	uxtb	r2, r2
 801eb0c:	701a      	strb	r2, [r3, #0]
 801eb0e:	4b8b      	ldr	r3, [pc, #556]	; (801ed3c <finsh_compile+0x14d8>)
 801eb10:	681b      	ldr	r3, [r3, #0]
 801eb12:	3303      	adds	r3, #3
 801eb14:	68fa      	ldr	r2, [r7, #12]
 801eb16:	3214      	adds	r2, #20
 801eb18:	0e12      	lsrs	r2, r2, #24
 801eb1a:	b2d2      	uxtb	r2, r2
 801eb1c:	701a      	strb	r2, [r3, #0]
 801eb1e:	4b87      	ldr	r3, [pc, #540]	; (801ed3c <finsh_compile+0x14d8>)
 801eb20:	681b      	ldr	r3, [r3, #0]
 801eb22:	3304      	adds	r3, #4
 801eb24:	4a85      	ldr	r2, [pc, #532]	; (801ed3c <finsh_compile+0x14d8>)
 801eb26:	6013      	str	r3, [r2, #0]

                    /* ld_value_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
 801eb28:	4b84      	ldr	r3, [pc, #528]	; (801ed3c <finsh_compile+0x14d8>)
 801eb2a:	681b      	ldr	r3, [r3, #0]
 801eb2c:	2227      	movs	r2, #39	; 0x27
 801eb2e:	701a      	strb	r2, [r3, #0]
 801eb30:	4b82      	ldr	r3, [pc, #520]	; (801ed3c <finsh_compile+0x14d8>)
 801eb32:	681b      	ldr	r3, [r3, #0]
 801eb34:	3301      	adds	r3, #1
 801eb36:	4a81      	ldr	r2, [pc, #516]	; (801ed3c <finsh_compile+0x14d8>)
 801eb38:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.long_value));
 801eb3a:	4b80      	ldr	r3, [pc, #512]	; (801ed3c <finsh_compile+0x14d8>)
 801eb3c:	681b      	ldr	r3, [r3, #0]
 801eb3e:	68fa      	ldr	r2, [r7, #12]
 801eb40:	3214      	adds	r2, #20
 801eb42:	b2d2      	uxtb	r2, r2
 801eb44:	701a      	strb	r2, [r3, #0]
 801eb46:	4b7d      	ldr	r3, [pc, #500]	; (801ed3c <finsh_compile+0x14d8>)
 801eb48:	681b      	ldr	r3, [r3, #0]
 801eb4a:	3301      	adds	r3, #1
 801eb4c:	68fa      	ldr	r2, [r7, #12]
 801eb4e:	3214      	adds	r2, #20
 801eb50:	0a12      	lsrs	r2, r2, #8
 801eb52:	b2d2      	uxtb	r2, r2
 801eb54:	701a      	strb	r2, [r3, #0]
 801eb56:	4b79      	ldr	r3, [pc, #484]	; (801ed3c <finsh_compile+0x14d8>)
 801eb58:	681b      	ldr	r3, [r3, #0]
 801eb5a:	3302      	adds	r3, #2
 801eb5c:	68fa      	ldr	r2, [r7, #12]
 801eb5e:	3214      	adds	r2, #20
 801eb60:	0c12      	lsrs	r2, r2, #16
 801eb62:	b2d2      	uxtb	r2, r2
 801eb64:	701a      	strb	r2, [r3, #0]
 801eb66:	4b75      	ldr	r3, [pc, #468]	; (801ed3c <finsh_compile+0x14d8>)
 801eb68:	681b      	ldr	r3, [r3, #0]
 801eb6a:	3303      	adds	r3, #3
 801eb6c:	68fa      	ldr	r2, [r7, #12]
 801eb6e:	3214      	adds	r2, #20
 801eb70:	0e12      	lsrs	r2, r2, #24
 801eb72:	b2d2      	uxtb	r2, r2
 801eb74:	701a      	strb	r2, [r3, #0]
 801eb76:	4b71      	ldr	r3, [pc, #452]	; (801ed3c <finsh_compile+0x14d8>)
 801eb78:	681b      	ldr	r3, [r3, #0]
 801eb7a:	3304      	adds	r3, #4
 801eb7c:	4a6f      	ldr	r2, [pc, #444]	; (801ed3c <finsh_compile+0x14d8>)
 801eb7e:	6013      	str	r3, [r2, #0]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801eb80:	4b6e      	ldr	r3, [pc, #440]	; (801ed3c <finsh_compile+0x14d8>)
 801eb82:	681b      	ldr	r3, [r3, #0]
 801eb84:	2224      	movs	r2, #36	; 0x24
 801eb86:	701a      	strb	r2, [r3, #0]
 801eb88:	4b6c      	ldr	r3, [pc, #432]	; (801ed3c <finsh_compile+0x14d8>)
 801eb8a:	681b      	ldr	r3, [r3, #0]
 801eb8c:	3301      	adds	r3, #1
 801eb8e:	4a6b      	ldr	r2, [pc, #428]	; (801ed3c <finsh_compile+0x14d8>)
 801eb90:	6013      	str	r3, [r2, #0]
                    finsh_code_dword(1);
 801eb92:	4b6a      	ldr	r3, [pc, #424]	; (801ed3c <finsh_compile+0x14d8>)
 801eb94:	681b      	ldr	r3, [r3, #0]
 801eb96:	2201      	movs	r2, #1
 801eb98:	701a      	strb	r2, [r3, #0]
 801eb9a:	4b68      	ldr	r3, [pc, #416]	; (801ed3c <finsh_compile+0x14d8>)
 801eb9c:	681b      	ldr	r3, [r3, #0]
 801eb9e:	3301      	adds	r3, #1
 801eba0:	2200      	movs	r2, #0
 801eba2:	701a      	strb	r2, [r3, #0]
 801eba4:	4b65      	ldr	r3, [pc, #404]	; (801ed3c <finsh_compile+0x14d8>)
 801eba6:	681b      	ldr	r3, [r3, #0]
 801eba8:	3302      	adds	r3, #2
 801ebaa:	2200      	movs	r2, #0
 801ebac:	701a      	strb	r2, [r3, #0]
 801ebae:	4b63      	ldr	r3, [pc, #396]	; (801ed3c <finsh_compile+0x14d8>)
 801ebb0:	681b      	ldr	r3, [r3, #0]
 801ebb2:	3303      	adds	r3, #3
 801ebb4:	2200      	movs	r2, #0
 801ebb6:	701a      	strb	r2, [r3, #0]
 801ebb8:	4b60      	ldr	r3, [pc, #384]	; (801ed3c <finsh_compile+0x14d8>)
 801ebba:	681b      	ldr	r3, [r3, #0]
 801ebbc:	3304      	adds	r3, #4
 801ebbe:	4a5f      	ldr	r2, [pc, #380]	; (801ed3c <finsh_compile+0x14d8>)
 801ebc0:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_DWORD);
 801ebc2:	4b5e      	ldr	r3, [pc, #376]	; (801ed3c <finsh_compile+0x14d8>)
 801ebc4:	681b      	ldr	r3, [r3, #0]
 801ebc6:	2203      	movs	r2, #3
 801ebc8:	701a      	strb	r2, [r3, #0]
 801ebca:	4b5c      	ldr	r3, [pc, #368]	; (801ed3c <finsh_compile+0x14d8>)
 801ebcc:	681b      	ldr	r3, [r3, #0]
 801ebce:	3301      	adds	r3, #1
 801ebd0:	4a5a      	ldr	r2, [pc, #360]	; (801ed3c <finsh_compile+0x14d8>)
 801ebd2:	6013      	str	r3, [r2, #0]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
 801ebd4:	4b59      	ldr	r3, [pc, #356]	; (801ed3c <finsh_compile+0x14d8>)
 801ebd6:	681b      	ldr	r3, [r3, #0]
 801ebd8:	222a      	movs	r2, #42	; 0x2a
 801ebda:	701a      	strb	r2, [r3, #0]
 801ebdc:	4b57      	ldr	r3, [pc, #348]	; (801ed3c <finsh_compile+0x14d8>)
 801ebde:	681b      	ldr	r3, [r3, #0]
 801ebe0:	3301      	adds	r3, #1
 801ebe2:	4a56      	ldr	r2, [pc, #344]	; (801ed3c <finsh_compile+0x14d8>)
 801ebe4:	6013      	str	r3, [r2, #0]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
 801ebe6:	4b55      	ldr	r3, [pc, #340]	; (801ed3c <finsh_compile+0x14d8>)
 801ebe8:	681b      	ldr	r3, [r3, #0]
 801ebea:	222b      	movs	r2, #43	; 0x2b
 801ebec:	701a      	strb	r2, [r3, #0]
 801ebee:	4b53      	ldr	r3, [pc, #332]	; (801ed3c <finsh_compile+0x14d8>)
 801ebf0:	681b      	ldr	r3, [r3, #0]
 801ebf2:	3301      	adds	r3, #1
 801ebf4:	4a51      	ldr	r2, [pc, #324]	; (801ed3c <finsh_compile+0x14d8>)
 801ebf6:	6013      	str	r3, [r2, #0]
                    break;
 801ebf8:	bf00      	nop
                }
            }
            break;
 801ebfa:	e212      	b.n	801f022 <finsh_compile+0x17be>

        /* decrease */
        case FINSH_NODE_SYS_DEC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
 801ebfc:	687b      	ldr	r3, [r7, #4]
 801ebfe:	691b      	ldr	r3, [r3, #16]
 801ec00:	2b00      	cmp	r3, #0
 801ec02:	f000 81bd 	beq.w	801ef80 <finsh_compile+0x171c>
 801ec06:	687b      	ldr	r3, [r7, #4]
 801ec08:	691b      	ldr	r3, [r3, #16]
 801ec0a:	781b      	ldrb	r3, [r3, #0]
 801ec0c:	2b01      	cmp	r3, #1
 801ec0e:	f040 81b7 	bne.w	801ef80 <finsh_compile+0x171c>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
 801ec12:	687b      	ldr	r3, [r7, #4]
 801ec14:	691b      	ldr	r3, [r3, #16]
 801ec16:	689b      	ldr	r3, [r3, #8]
 801ec18:	60bb      	str	r3, [r7, #8]

                switch (node->data_type)
 801ec1a:	687b      	ldr	r3, [r7, #4]
 801ec1c:	785b      	ldrb	r3, [r3, #1]
 801ec1e:	2b02      	cmp	r3, #2
 801ec20:	f000 808e 	beq.w	801ed40 <finsh_compile+0x14dc>
 801ec24:	2b03      	cmp	r3, #3
 801ec26:	f000 8116 	beq.w	801ee56 <finsh_compile+0x15f2>
 801ec2a:	2b01      	cmp	r3, #1
 801ec2c:	d000      	beq.n	801ec30 <finsh_compile+0x13cc>
                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
                    break;
                }
            }
            break;
 801ec2e:	e1f8      	b.n	801f022 <finsh_compile+0x17be>
                    /* ld_value_byte &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801ec30:	4b42      	ldr	r3, [pc, #264]	; (801ed3c <finsh_compile+0x14d8>)
 801ec32:	681b      	ldr	r3, [r3, #0]
 801ec34:	2224      	movs	r2, #36	; 0x24
 801ec36:	701a      	strb	r2, [r3, #0]
 801ec38:	4b40      	ldr	r3, [pc, #256]	; (801ed3c <finsh_compile+0x14d8>)
 801ec3a:	681b      	ldr	r3, [r3, #0]
 801ec3c:	3301      	adds	r3, #1
 801ec3e:	4a3f      	ldr	r2, [pc, #252]	; (801ed3c <finsh_compile+0x14d8>)
 801ec40:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.char_value));
 801ec42:	4b3e      	ldr	r3, [pc, #248]	; (801ed3c <finsh_compile+0x14d8>)
 801ec44:	681b      	ldr	r3, [r3, #0]
 801ec46:	68ba      	ldr	r2, [r7, #8]
 801ec48:	3214      	adds	r2, #20
 801ec4a:	b2d2      	uxtb	r2, r2
 801ec4c:	701a      	strb	r2, [r3, #0]
 801ec4e:	4b3b      	ldr	r3, [pc, #236]	; (801ed3c <finsh_compile+0x14d8>)
 801ec50:	681b      	ldr	r3, [r3, #0]
 801ec52:	3301      	adds	r3, #1
 801ec54:	68ba      	ldr	r2, [r7, #8]
 801ec56:	3214      	adds	r2, #20
 801ec58:	0a12      	lsrs	r2, r2, #8
 801ec5a:	b2d2      	uxtb	r2, r2
 801ec5c:	701a      	strb	r2, [r3, #0]
 801ec5e:	4b37      	ldr	r3, [pc, #220]	; (801ed3c <finsh_compile+0x14d8>)
 801ec60:	681b      	ldr	r3, [r3, #0]
 801ec62:	3302      	adds	r3, #2
 801ec64:	68ba      	ldr	r2, [r7, #8]
 801ec66:	3214      	adds	r2, #20
 801ec68:	0c12      	lsrs	r2, r2, #16
 801ec6a:	b2d2      	uxtb	r2, r2
 801ec6c:	701a      	strb	r2, [r3, #0]
 801ec6e:	4b33      	ldr	r3, [pc, #204]	; (801ed3c <finsh_compile+0x14d8>)
 801ec70:	681b      	ldr	r3, [r3, #0]
 801ec72:	3303      	adds	r3, #3
 801ec74:	68ba      	ldr	r2, [r7, #8]
 801ec76:	3214      	adds	r2, #20
 801ec78:	0e12      	lsrs	r2, r2, #24
 801ec7a:	b2d2      	uxtb	r2, r2
 801ec7c:	701a      	strb	r2, [r3, #0]
 801ec7e:	4b2f      	ldr	r3, [pc, #188]	; (801ed3c <finsh_compile+0x14d8>)
 801ec80:	681b      	ldr	r3, [r3, #0]
 801ec82:	3304      	adds	r3, #4
 801ec84:	4a2d      	ldr	r2, [pc, #180]	; (801ed3c <finsh_compile+0x14d8>)
 801ec86:	6013      	str	r3, [r2, #0]

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
 801ec88:	4b2c      	ldr	r3, [pc, #176]	; (801ed3c <finsh_compile+0x14d8>)
 801ec8a:	681b      	ldr	r3, [r3, #0]
 801ec8c:	2225      	movs	r2, #37	; 0x25
 801ec8e:	701a      	strb	r2, [r3, #0]
 801ec90:	4b2a      	ldr	r3, [pc, #168]	; (801ed3c <finsh_compile+0x14d8>)
 801ec92:	681b      	ldr	r3, [r3, #0]
 801ec94:	3301      	adds	r3, #1
 801ec96:	4a29      	ldr	r2, [pc, #164]	; (801ed3c <finsh_compile+0x14d8>)
 801ec98:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.char_value));
 801ec9a:	4b28      	ldr	r3, [pc, #160]	; (801ed3c <finsh_compile+0x14d8>)
 801ec9c:	681b      	ldr	r3, [r3, #0]
 801ec9e:	68ba      	ldr	r2, [r7, #8]
 801eca0:	3214      	adds	r2, #20
 801eca2:	b2d2      	uxtb	r2, r2
 801eca4:	701a      	strb	r2, [r3, #0]
 801eca6:	4b25      	ldr	r3, [pc, #148]	; (801ed3c <finsh_compile+0x14d8>)
 801eca8:	681b      	ldr	r3, [r3, #0]
 801ecaa:	3301      	adds	r3, #1
 801ecac:	68ba      	ldr	r2, [r7, #8]
 801ecae:	3214      	adds	r2, #20
 801ecb0:	0a12      	lsrs	r2, r2, #8
 801ecb2:	b2d2      	uxtb	r2, r2
 801ecb4:	701a      	strb	r2, [r3, #0]
 801ecb6:	4b21      	ldr	r3, [pc, #132]	; (801ed3c <finsh_compile+0x14d8>)
 801ecb8:	681b      	ldr	r3, [r3, #0]
 801ecba:	3302      	adds	r3, #2
 801ecbc:	68ba      	ldr	r2, [r7, #8]
 801ecbe:	3214      	adds	r2, #20
 801ecc0:	0c12      	lsrs	r2, r2, #16
 801ecc2:	b2d2      	uxtb	r2, r2
 801ecc4:	701a      	strb	r2, [r3, #0]
 801ecc6:	4b1d      	ldr	r3, [pc, #116]	; (801ed3c <finsh_compile+0x14d8>)
 801ecc8:	681b      	ldr	r3, [r3, #0]
 801ecca:	3303      	adds	r3, #3
 801eccc:	68ba      	ldr	r2, [r7, #8]
 801ecce:	3214      	adds	r2, #20
 801ecd0:	0e12      	lsrs	r2, r2, #24
 801ecd2:	b2d2      	uxtb	r2, r2
 801ecd4:	701a      	strb	r2, [r3, #0]
 801ecd6:	4b19      	ldr	r3, [pc, #100]	; (801ed3c <finsh_compile+0x14d8>)
 801ecd8:	681b      	ldr	r3, [r3, #0]
 801ecda:	3304      	adds	r3, #4
 801ecdc:	4a17      	ldr	r2, [pc, #92]	; (801ed3c <finsh_compile+0x14d8>)
 801ecde:	6013      	str	r3, [r2, #0]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
 801ece0:	4b16      	ldr	r3, [pc, #88]	; (801ed3c <finsh_compile+0x14d8>)
 801ece2:	681b      	ldr	r3, [r3, #0]
 801ece4:	2222      	movs	r2, #34	; 0x22
 801ece6:	701a      	strb	r2, [r3, #0]
 801ece8:	4b14      	ldr	r3, [pc, #80]	; (801ed3c <finsh_compile+0x14d8>)
 801ecea:	681b      	ldr	r3, [r3, #0]
 801ecec:	3301      	adds	r3, #1
 801ecee:	4a13      	ldr	r2, [pc, #76]	; (801ed3c <finsh_compile+0x14d8>)
 801ecf0:	6013      	str	r3, [r2, #0]
                    finsh_code_byte(1);
 801ecf2:	4b12      	ldr	r3, [pc, #72]	; (801ed3c <finsh_compile+0x14d8>)
 801ecf4:	681b      	ldr	r3, [r3, #0]
 801ecf6:	2201      	movs	r2, #1
 801ecf8:	701a      	strb	r2, [r3, #0]
 801ecfa:	4b10      	ldr	r3, [pc, #64]	; (801ed3c <finsh_compile+0x14d8>)
 801ecfc:	681b      	ldr	r3, [r3, #0]
 801ecfe:	3301      	adds	r3, #1
 801ed00:	4a0e      	ldr	r2, [pc, #56]	; (801ed3c <finsh_compile+0x14d8>)
 801ed02:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_BYTE);
 801ed04:	4b0d      	ldr	r3, [pc, #52]	; (801ed3c <finsh_compile+0x14d8>)
 801ed06:	681b      	ldr	r3, [r3, #0]
 801ed08:	2204      	movs	r2, #4
 801ed0a:	701a      	strb	r2, [r3, #0]
 801ed0c:	4b0b      	ldr	r3, [pc, #44]	; (801ed3c <finsh_compile+0x14d8>)
 801ed0e:	681b      	ldr	r3, [r3, #0]
 801ed10:	3301      	adds	r3, #1
 801ed12:	4a0a      	ldr	r2, [pc, #40]	; (801ed3c <finsh_compile+0x14d8>)
 801ed14:	6013      	str	r3, [r2, #0]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
 801ed16:	4b09      	ldr	r3, [pc, #36]	; (801ed3c <finsh_compile+0x14d8>)
 801ed18:	681b      	ldr	r3, [r3, #0]
 801ed1a:	2228      	movs	r2, #40	; 0x28
 801ed1c:	701a      	strb	r2, [r3, #0]
 801ed1e:	4b07      	ldr	r3, [pc, #28]	; (801ed3c <finsh_compile+0x14d8>)
 801ed20:	681b      	ldr	r3, [r3, #0]
 801ed22:	3301      	adds	r3, #1
 801ed24:	4a05      	ldr	r2, [pc, #20]	; (801ed3c <finsh_compile+0x14d8>)
 801ed26:	6013      	str	r3, [r2, #0]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
 801ed28:	4b04      	ldr	r3, [pc, #16]	; (801ed3c <finsh_compile+0x14d8>)
 801ed2a:	681b      	ldr	r3, [r3, #0]
 801ed2c:	222b      	movs	r2, #43	; 0x2b
 801ed2e:	701a      	strb	r2, [r3, #0]
 801ed30:	4b02      	ldr	r3, [pc, #8]	; (801ed3c <finsh_compile+0x14d8>)
 801ed32:	681b      	ldr	r3, [r3, #0]
 801ed34:	3301      	adds	r3, #1
 801ed36:	4a01      	ldr	r2, [pc, #4]	; (801ed3c <finsh_compile+0x14d8>)
 801ed38:	6013      	str	r3, [r2, #0]
                    break;
 801ed3a:	e121      	b.n	801ef80 <finsh_compile+0x171c>
 801ed3c:	20012bdc 	.word	0x20012bdc
                    /* ld_value_word &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801ed40:	4b9c      	ldr	r3, [pc, #624]	; (801efb4 <finsh_compile+0x1750>)
 801ed42:	681b      	ldr	r3, [r3, #0]
 801ed44:	2224      	movs	r2, #36	; 0x24
 801ed46:	701a      	strb	r2, [r3, #0]
 801ed48:	4b9a      	ldr	r3, [pc, #616]	; (801efb4 <finsh_compile+0x1750>)
 801ed4a:	681b      	ldr	r3, [r3, #0]
 801ed4c:	3301      	adds	r3, #1
 801ed4e:	4a99      	ldr	r2, [pc, #612]	; (801efb4 <finsh_compile+0x1750>)
 801ed50:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.short_value));
 801ed52:	4b98      	ldr	r3, [pc, #608]	; (801efb4 <finsh_compile+0x1750>)
 801ed54:	681b      	ldr	r3, [r3, #0]
 801ed56:	68ba      	ldr	r2, [r7, #8]
 801ed58:	3214      	adds	r2, #20
 801ed5a:	b2d2      	uxtb	r2, r2
 801ed5c:	701a      	strb	r2, [r3, #0]
 801ed5e:	4b95      	ldr	r3, [pc, #596]	; (801efb4 <finsh_compile+0x1750>)
 801ed60:	681b      	ldr	r3, [r3, #0]
 801ed62:	3301      	adds	r3, #1
 801ed64:	68ba      	ldr	r2, [r7, #8]
 801ed66:	3214      	adds	r2, #20
 801ed68:	0a12      	lsrs	r2, r2, #8
 801ed6a:	b2d2      	uxtb	r2, r2
 801ed6c:	701a      	strb	r2, [r3, #0]
 801ed6e:	4b91      	ldr	r3, [pc, #580]	; (801efb4 <finsh_compile+0x1750>)
 801ed70:	681b      	ldr	r3, [r3, #0]
 801ed72:	3302      	adds	r3, #2
 801ed74:	68ba      	ldr	r2, [r7, #8]
 801ed76:	3214      	adds	r2, #20
 801ed78:	0c12      	lsrs	r2, r2, #16
 801ed7a:	b2d2      	uxtb	r2, r2
 801ed7c:	701a      	strb	r2, [r3, #0]
 801ed7e:	4b8d      	ldr	r3, [pc, #564]	; (801efb4 <finsh_compile+0x1750>)
 801ed80:	681b      	ldr	r3, [r3, #0]
 801ed82:	3303      	adds	r3, #3
 801ed84:	68ba      	ldr	r2, [r7, #8]
 801ed86:	3214      	adds	r2, #20
 801ed88:	0e12      	lsrs	r2, r2, #24
 801ed8a:	b2d2      	uxtb	r2, r2
 801ed8c:	701a      	strb	r2, [r3, #0]
 801ed8e:	4b89      	ldr	r3, [pc, #548]	; (801efb4 <finsh_compile+0x1750>)
 801ed90:	681b      	ldr	r3, [r3, #0]
 801ed92:	3304      	adds	r3, #4
 801ed94:	4a87      	ldr	r2, [pc, #540]	; (801efb4 <finsh_compile+0x1750>)
 801ed96:	6013      	str	r3, [r2, #0]

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
 801ed98:	4b86      	ldr	r3, [pc, #536]	; (801efb4 <finsh_compile+0x1750>)
 801ed9a:	681b      	ldr	r3, [r3, #0]
 801ed9c:	2226      	movs	r2, #38	; 0x26
 801ed9e:	701a      	strb	r2, [r3, #0]
 801eda0:	4b84      	ldr	r3, [pc, #528]	; (801efb4 <finsh_compile+0x1750>)
 801eda2:	681b      	ldr	r3, [r3, #0]
 801eda4:	3301      	adds	r3, #1
 801eda6:	4a83      	ldr	r2, [pc, #524]	; (801efb4 <finsh_compile+0x1750>)
 801eda8:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.short_value));
 801edaa:	4b82      	ldr	r3, [pc, #520]	; (801efb4 <finsh_compile+0x1750>)
 801edac:	681b      	ldr	r3, [r3, #0]
 801edae:	68ba      	ldr	r2, [r7, #8]
 801edb0:	3214      	adds	r2, #20
 801edb2:	b2d2      	uxtb	r2, r2
 801edb4:	701a      	strb	r2, [r3, #0]
 801edb6:	4b7f      	ldr	r3, [pc, #508]	; (801efb4 <finsh_compile+0x1750>)
 801edb8:	681b      	ldr	r3, [r3, #0]
 801edba:	3301      	adds	r3, #1
 801edbc:	68ba      	ldr	r2, [r7, #8]
 801edbe:	3214      	adds	r2, #20
 801edc0:	0a12      	lsrs	r2, r2, #8
 801edc2:	b2d2      	uxtb	r2, r2
 801edc4:	701a      	strb	r2, [r3, #0]
 801edc6:	4b7b      	ldr	r3, [pc, #492]	; (801efb4 <finsh_compile+0x1750>)
 801edc8:	681b      	ldr	r3, [r3, #0]
 801edca:	3302      	adds	r3, #2
 801edcc:	68ba      	ldr	r2, [r7, #8]
 801edce:	3214      	adds	r2, #20
 801edd0:	0c12      	lsrs	r2, r2, #16
 801edd2:	b2d2      	uxtb	r2, r2
 801edd4:	701a      	strb	r2, [r3, #0]
 801edd6:	4b77      	ldr	r3, [pc, #476]	; (801efb4 <finsh_compile+0x1750>)
 801edd8:	681b      	ldr	r3, [r3, #0]
 801edda:	3303      	adds	r3, #3
 801eddc:	68ba      	ldr	r2, [r7, #8]
 801edde:	3214      	adds	r2, #20
 801ede0:	0e12      	lsrs	r2, r2, #24
 801ede2:	b2d2      	uxtb	r2, r2
 801ede4:	701a      	strb	r2, [r3, #0]
 801ede6:	4b73      	ldr	r3, [pc, #460]	; (801efb4 <finsh_compile+0x1750>)
 801ede8:	681b      	ldr	r3, [r3, #0]
 801edea:	3304      	adds	r3, #4
 801edec:	4a71      	ldr	r2, [pc, #452]	; (801efb4 <finsh_compile+0x1750>)
 801edee:	6013      	str	r3, [r2, #0]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
 801edf0:	4b70      	ldr	r3, [pc, #448]	; (801efb4 <finsh_compile+0x1750>)
 801edf2:	681b      	ldr	r3, [r3, #0]
 801edf4:	2223      	movs	r2, #35	; 0x23
 801edf6:	701a      	strb	r2, [r3, #0]
 801edf8:	4b6e      	ldr	r3, [pc, #440]	; (801efb4 <finsh_compile+0x1750>)
 801edfa:	681b      	ldr	r3, [r3, #0]
 801edfc:	3301      	adds	r3, #1
 801edfe:	4a6d      	ldr	r2, [pc, #436]	; (801efb4 <finsh_compile+0x1750>)
 801ee00:	6013      	str	r3, [r2, #0]
                    finsh_code_word(1);
 801ee02:	4b6c      	ldr	r3, [pc, #432]	; (801efb4 <finsh_compile+0x1750>)
 801ee04:	681b      	ldr	r3, [r3, #0]
 801ee06:	2201      	movs	r2, #1
 801ee08:	701a      	strb	r2, [r3, #0]
 801ee0a:	4b6a      	ldr	r3, [pc, #424]	; (801efb4 <finsh_compile+0x1750>)
 801ee0c:	681b      	ldr	r3, [r3, #0]
 801ee0e:	3301      	adds	r3, #1
 801ee10:	2200      	movs	r2, #0
 801ee12:	701a      	strb	r2, [r3, #0]
 801ee14:	4b67      	ldr	r3, [pc, #412]	; (801efb4 <finsh_compile+0x1750>)
 801ee16:	681b      	ldr	r3, [r3, #0]
 801ee18:	3302      	adds	r3, #2
 801ee1a:	4a66      	ldr	r2, [pc, #408]	; (801efb4 <finsh_compile+0x1750>)
 801ee1c:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_WORD);
 801ee1e:	4b65      	ldr	r3, [pc, #404]	; (801efb4 <finsh_compile+0x1750>)
 801ee20:	681b      	ldr	r3, [r3, #0]
 801ee22:	2205      	movs	r2, #5
 801ee24:	701a      	strb	r2, [r3, #0]
 801ee26:	4b63      	ldr	r3, [pc, #396]	; (801efb4 <finsh_compile+0x1750>)
 801ee28:	681b      	ldr	r3, [r3, #0]
 801ee2a:	3301      	adds	r3, #1
 801ee2c:	4a61      	ldr	r2, [pc, #388]	; (801efb4 <finsh_compile+0x1750>)
 801ee2e:	6013      	str	r3, [r2, #0]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_WORD);
 801ee30:	4b60      	ldr	r3, [pc, #384]	; (801efb4 <finsh_compile+0x1750>)
 801ee32:	681b      	ldr	r3, [r3, #0]
 801ee34:	2229      	movs	r2, #41	; 0x29
 801ee36:	701a      	strb	r2, [r3, #0]
 801ee38:	4b5e      	ldr	r3, [pc, #376]	; (801efb4 <finsh_compile+0x1750>)
 801ee3a:	681b      	ldr	r3, [r3, #0]
 801ee3c:	3301      	adds	r3, #1
 801ee3e:	4a5d      	ldr	r2, [pc, #372]	; (801efb4 <finsh_compile+0x1750>)
 801ee40:	6013      	str	r3, [r2, #0]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
 801ee42:	4b5c      	ldr	r3, [pc, #368]	; (801efb4 <finsh_compile+0x1750>)
 801ee44:	681b      	ldr	r3, [r3, #0]
 801ee46:	222b      	movs	r2, #43	; 0x2b
 801ee48:	701a      	strb	r2, [r3, #0]
 801ee4a:	4b5a      	ldr	r3, [pc, #360]	; (801efb4 <finsh_compile+0x1750>)
 801ee4c:	681b      	ldr	r3, [r3, #0]
 801ee4e:	3301      	adds	r3, #1
 801ee50:	4a58      	ldr	r2, [pc, #352]	; (801efb4 <finsh_compile+0x1750>)
 801ee52:	6013      	str	r3, [r2, #0]
                    break;
 801ee54:	e094      	b.n	801ef80 <finsh_compile+0x171c>
                    /* ld_value_dword &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801ee56:	4b57      	ldr	r3, [pc, #348]	; (801efb4 <finsh_compile+0x1750>)
 801ee58:	681b      	ldr	r3, [r3, #0]
 801ee5a:	2224      	movs	r2, #36	; 0x24
 801ee5c:	701a      	strb	r2, [r3, #0]
 801ee5e:	4b55      	ldr	r3, [pc, #340]	; (801efb4 <finsh_compile+0x1750>)
 801ee60:	681b      	ldr	r3, [r3, #0]
 801ee62:	3301      	adds	r3, #1
 801ee64:	4a53      	ldr	r2, [pc, #332]	; (801efb4 <finsh_compile+0x1750>)
 801ee66:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.long_value));
 801ee68:	4b52      	ldr	r3, [pc, #328]	; (801efb4 <finsh_compile+0x1750>)
 801ee6a:	681b      	ldr	r3, [r3, #0]
 801ee6c:	68ba      	ldr	r2, [r7, #8]
 801ee6e:	3214      	adds	r2, #20
 801ee70:	b2d2      	uxtb	r2, r2
 801ee72:	701a      	strb	r2, [r3, #0]
 801ee74:	4b4f      	ldr	r3, [pc, #316]	; (801efb4 <finsh_compile+0x1750>)
 801ee76:	681b      	ldr	r3, [r3, #0]
 801ee78:	3301      	adds	r3, #1
 801ee7a:	68ba      	ldr	r2, [r7, #8]
 801ee7c:	3214      	adds	r2, #20
 801ee7e:	0a12      	lsrs	r2, r2, #8
 801ee80:	b2d2      	uxtb	r2, r2
 801ee82:	701a      	strb	r2, [r3, #0]
 801ee84:	4b4b      	ldr	r3, [pc, #300]	; (801efb4 <finsh_compile+0x1750>)
 801ee86:	681b      	ldr	r3, [r3, #0]
 801ee88:	3302      	adds	r3, #2
 801ee8a:	68ba      	ldr	r2, [r7, #8]
 801ee8c:	3214      	adds	r2, #20
 801ee8e:	0c12      	lsrs	r2, r2, #16
 801ee90:	b2d2      	uxtb	r2, r2
 801ee92:	701a      	strb	r2, [r3, #0]
 801ee94:	4b47      	ldr	r3, [pc, #284]	; (801efb4 <finsh_compile+0x1750>)
 801ee96:	681b      	ldr	r3, [r3, #0]
 801ee98:	3303      	adds	r3, #3
 801ee9a:	68ba      	ldr	r2, [r7, #8]
 801ee9c:	3214      	adds	r2, #20
 801ee9e:	0e12      	lsrs	r2, r2, #24
 801eea0:	b2d2      	uxtb	r2, r2
 801eea2:	701a      	strb	r2, [r3, #0]
 801eea4:	4b43      	ldr	r3, [pc, #268]	; (801efb4 <finsh_compile+0x1750>)
 801eea6:	681b      	ldr	r3, [r3, #0]
 801eea8:	3304      	adds	r3, #4
 801eeaa:	4a42      	ldr	r2, [pc, #264]	; (801efb4 <finsh_compile+0x1750>)
 801eeac:	6013      	str	r3, [r2, #0]

                    /* ld_value_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
 801eeae:	4b41      	ldr	r3, [pc, #260]	; (801efb4 <finsh_compile+0x1750>)
 801eeb0:	681b      	ldr	r3, [r3, #0]
 801eeb2:	2227      	movs	r2, #39	; 0x27
 801eeb4:	701a      	strb	r2, [r3, #0]
 801eeb6:	4b3f      	ldr	r3, [pc, #252]	; (801efb4 <finsh_compile+0x1750>)
 801eeb8:	681b      	ldr	r3, [r3, #0]
 801eeba:	3301      	adds	r3, #1
 801eebc:	4a3d      	ldr	r2, [pc, #244]	; (801efb4 <finsh_compile+0x1750>)
 801eebe:	6013      	str	r3, [r2, #0]
                    finsh_code_dword((long)&(var->value.long_value));
 801eec0:	4b3c      	ldr	r3, [pc, #240]	; (801efb4 <finsh_compile+0x1750>)
 801eec2:	681b      	ldr	r3, [r3, #0]
 801eec4:	68ba      	ldr	r2, [r7, #8]
 801eec6:	3214      	adds	r2, #20
 801eec8:	b2d2      	uxtb	r2, r2
 801eeca:	701a      	strb	r2, [r3, #0]
 801eecc:	4b39      	ldr	r3, [pc, #228]	; (801efb4 <finsh_compile+0x1750>)
 801eece:	681b      	ldr	r3, [r3, #0]
 801eed0:	3301      	adds	r3, #1
 801eed2:	68ba      	ldr	r2, [r7, #8]
 801eed4:	3214      	adds	r2, #20
 801eed6:	0a12      	lsrs	r2, r2, #8
 801eed8:	b2d2      	uxtb	r2, r2
 801eeda:	701a      	strb	r2, [r3, #0]
 801eedc:	4b35      	ldr	r3, [pc, #212]	; (801efb4 <finsh_compile+0x1750>)
 801eede:	681b      	ldr	r3, [r3, #0]
 801eee0:	3302      	adds	r3, #2
 801eee2:	68ba      	ldr	r2, [r7, #8]
 801eee4:	3214      	adds	r2, #20
 801eee6:	0c12      	lsrs	r2, r2, #16
 801eee8:	b2d2      	uxtb	r2, r2
 801eeea:	701a      	strb	r2, [r3, #0]
 801eeec:	4b31      	ldr	r3, [pc, #196]	; (801efb4 <finsh_compile+0x1750>)
 801eeee:	681b      	ldr	r3, [r3, #0]
 801eef0:	3303      	adds	r3, #3
 801eef2:	68ba      	ldr	r2, [r7, #8]
 801eef4:	3214      	adds	r2, #20
 801eef6:	0e12      	lsrs	r2, r2, #24
 801eef8:	b2d2      	uxtb	r2, r2
 801eefa:	701a      	strb	r2, [r3, #0]
 801eefc:	4b2d      	ldr	r3, [pc, #180]	; (801efb4 <finsh_compile+0x1750>)
 801eefe:	681b      	ldr	r3, [r3, #0]
 801ef00:	3304      	adds	r3, #4
 801ef02:	4a2c      	ldr	r2, [pc, #176]	; (801efb4 <finsh_compile+0x1750>)
 801ef04:	6013      	str	r3, [r2, #0]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
 801ef06:	4b2b      	ldr	r3, [pc, #172]	; (801efb4 <finsh_compile+0x1750>)
 801ef08:	681b      	ldr	r3, [r3, #0]
 801ef0a:	2224      	movs	r2, #36	; 0x24
 801ef0c:	701a      	strb	r2, [r3, #0]
 801ef0e:	4b29      	ldr	r3, [pc, #164]	; (801efb4 <finsh_compile+0x1750>)
 801ef10:	681b      	ldr	r3, [r3, #0]
 801ef12:	3301      	adds	r3, #1
 801ef14:	4a27      	ldr	r2, [pc, #156]	; (801efb4 <finsh_compile+0x1750>)
 801ef16:	6013      	str	r3, [r2, #0]
                    finsh_code_dword(1);
 801ef18:	4b26      	ldr	r3, [pc, #152]	; (801efb4 <finsh_compile+0x1750>)
 801ef1a:	681b      	ldr	r3, [r3, #0]
 801ef1c:	2201      	movs	r2, #1
 801ef1e:	701a      	strb	r2, [r3, #0]
 801ef20:	4b24      	ldr	r3, [pc, #144]	; (801efb4 <finsh_compile+0x1750>)
 801ef22:	681b      	ldr	r3, [r3, #0]
 801ef24:	3301      	adds	r3, #1
 801ef26:	2200      	movs	r2, #0
 801ef28:	701a      	strb	r2, [r3, #0]
 801ef2a:	4b22      	ldr	r3, [pc, #136]	; (801efb4 <finsh_compile+0x1750>)
 801ef2c:	681b      	ldr	r3, [r3, #0]
 801ef2e:	3302      	adds	r3, #2
 801ef30:	2200      	movs	r2, #0
 801ef32:	701a      	strb	r2, [r3, #0]
 801ef34:	4b1f      	ldr	r3, [pc, #124]	; (801efb4 <finsh_compile+0x1750>)
 801ef36:	681b      	ldr	r3, [r3, #0]
 801ef38:	3303      	adds	r3, #3
 801ef3a:	2200      	movs	r2, #0
 801ef3c:	701a      	strb	r2, [r3, #0]
 801ef3e:	4b1d      	ldr	r3, [pc, #116]	; (801efb4 <finsh_compile+0x1750>)
 801ef40:	681b      	ldr	r3, [r3, #0]
 801ef42:	3304      	adds	r3, #4
 801ef44:	4a1b      	ldr	r2, [pc, #108]	; (801efb4 <finsh_compile+0x1750>)
 801ef46:	6013      	str	r3, [r2, #0]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_DWORD);
 801ef48:	4b1a      	ldr	r3, [pc, #104]	; (801efb4 <finsh_compile+0x1750>)
 801ef4a:	681b      	ldr	r3, [r3, #0]
 801ef4c:	2206      	movs	r2, #6
 801ef4e:	701a      	strb	r2, [r3, #0]
 801ef50:	4b18      	ldr	r3, [pc, #96]	; (801efb4 <finsh_compile+0x1750>)
 801ef52:	681b      	ldr	r3, [r3, #0]
 801ef54:	3301      	adds	r3, #1
 801ef56:	4a17      	ldr	r2, [pc, #92]	; (801efb4 <finsh_compile+0x1750>)
 801ef58:	6013      	str	r3, [r2, #0]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
 801ef5a:	4b16      	ldr	r3, [pc, #88]	; (801efb4 <finsh_compile+0x1750>)
 801ef5c:	681b      	ldr	r3, [r3, #0]
 801ef5e:	222a      	movs	r2, #42	; 0x2a
 801ef60:	701a      	strb	r2, [r3, #0]
 801ef62:	4b14      	ldr	r3, [pc, #80]	; (801efb4 <finsh_compile+0x1750>)
 801ef64:	681b      	ldr	r3, [r3, #0]
 801ef66:	3301      	adds	r3, #1
 801ef68:	4a12      	ldr	r2, [pc, #72]	; (801efb4 <finsh_compile+0x1750>)
 801ef6a:	6013      	str	r3, [r2, #0]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
 801ef6c:	4b11      	ldr	r3, [pc, #68]	; (801efb4 <finsh_compile+0x1750>)
 801ef6e:	681b      	ldr	r3, [r3, #0]
 801ef70:	222b      	movs	r2, #43	; 0x2b
 801ef72:	701a      	strb	r2, [r3, #0]
 801ef74:	4b0f      	ldr	r3, [pc, #60]	; (801efb4 <finsh_compile+0x1750>)
 801ef76:	681b      	ldr	r3, [r3, #0]
 801ef78:	3301      	adds	r3, #1
 801ef7a:	4a0e      	ldr	r2, [pc, #56]	; (801efb4 <finsh_compile+0x1750>)
 801ef7c:	6013      	str	r3, [r2, #0]
                    break;
 801ef7e:	bf00      	nop
                }
            }
            break;
 801ef80:	e04f      	b.n	801f022 <finsh_compile+0x17be>

        case FINSH_NODE_SYS_NULL:
            finsh_code_dword(0);
 801ef82:	4b0c      	ldr	r3, [pc, #48]	; (801efb4 <finsh_compile+0x1750>)
 801ef84:	681b      	ldr	r3, [r3, #0]
 801ef86:	2200      	movs	r2, #0
 801ef88:	701a      	strb	r2, [r3, #0]
 801ef8a:	4b0a      	ldr	r3, [pc, #40]	; (801efb4 <finsh_compile+0x1750>)
 801ef8c:	681b      	ldr	r3, [r3, #0]
 801ef8e:	3301      	adds	r3, #1
 801ef90:	2200      	movs	r2, #0
 801ef92:	701a      	strb	r2, [r3, #0]
 801ef94:	4b07      	ldr	r3, [pc, #28]	; (801efb4 <finsh_compile+0x1750>)
 801ef96:	681b      	ldr	r3, [r3, #0]
 801ef98:	3302      	adds	r3, #2
 801ef9a:	2200      	movs	r2, #0
 801ef9c:	701a      	strb	r2, [r3, #0]
 801ef9e:	4b05      	ldr	r3, [pc, #20]	; (801efb4 <finsh_compile+0x1750>)
 801efa0:	681b      	ldr	r3, [r3, #0]
 801efa2:	3303      	adds	r3, #3
 801efa4:	2200      	movs	r2, #0
 801efa6:	701a      	strb	r2, [r3, #0]
 801efa8:	4b02      	ldr	r3, [pc, #8]	; (801efb4 <finsh_compile+0x1750>)
 801efaa:	681b      	ldr	r3, [r3, #0]
 801efac:	3304      	adds	r3, #4
 801efae:	4a01      	ldr	r2, [pc, #4]	; (801efb4 <finsh_compile+0x1750>)
 801efb0:	6013      	str	r3, [r2, #0]
            break;
 801efb2:	e036      	b.n	801f022 <finsh_compile+0x17be>
 801efb4:	20012bdc 	.word	0x20012bdc

        case FINSH_NODE_SYS_GETVALUE:
            if (node->idtype & FINSH_IDTYPE_ADDRESS)
 801efb8:	687b      	ldr	r3, [r7, #4]
 801efba:	789b      	ldrb	r3, [r3, #2]
 801efbc:	f003 0308 	and.w	r3, r3, #8
 801efc0:	2b00      	cmp	r3, #0
 801efc2:	d126      	bne.n	801f012 <finsh_compile+0x17ae>
            {
                /* nothing will be generated */
            }
            else
            {
                switch (node->data_type)
 801efc4:	687b      	ldr	r3, [r7, #4]
 801efc6:	785b      	ldrb	r3, [r3, #1]
 801efc8:	2b02      	cmp	r3, #2
 801efca:	d00e      	beq.n	801efea <finsh_compile+0x1786>
 801efcc:	2b03      	cmp	r3, #3
 801efce:	d016      	beq.n	801effe <finsh_compile+0x179a>
 801efd0:	2b01      	cmp	r3, #1
 801efd2:	d000      	beq.n	801efd6 <finsh_compile+0x1772>
                    break;
                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
                    break;
                default:
                    break;
 801efd4:	e01d      	b.n	801f012 <finsh_compile+0x17ae>
            else
            {
                switch (node->data_type)
                {
                case FINSH_DATA_TYPE_BYTE:
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE_STACK);
 801efd6:	4b1a      	ldr	r3, [pc, #104]	; (801f040 <finsh_compile+0x17dc>)
 801efd8:	681b      	ldr	r3, [r3, #0]
 801efda:	222d      	movs	r2, #45	; 0x2d
 801efdc:	701a      	strb	r2, [r3, #0]
 801efde:	4b18      	ldr	r3, [pc, #96]	; (801f040 <finsh_compile+0x17dc>)
 801efe0:	681b      	ldr	r3, [r3, #0]
 801efe2:	3301      	adds	r3, #1
 801efe4:	4a16      	ldr	r2, [pc, #88]	; (801f040 <finsh_compile+0x17dc>)
 801efe6:	6013      	str	r3, [r2, #0]
                    break;
 801efe8:	e013      	b.n	801f012 <finsh_compile+0x17ae>
                case FINSH_DATA_TYPE_WORD:
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD_STACK);
 801efea:	4b15      	ldr	r3, [pc, #84]	; (801f040 <finsh_compile+0x17dc>)
 801efec:	681b      	ldr	r3, [r3, #0]
 801efee:	222e      	movs	r2, #46	; 0x2e
 801eff0:	701a      	strb	r2, [r3, #0]
 801eff2:	4b13      	ldr	r3, [pc, #76]	; (801f040 <finsh_compile+0x17dc>)
 801eff4:	681b      	ldr	r3, [r3, #0]
 801eff6:	3301      	adds	r3, #1
 801eff8:	4a11      	ldr	r2, [pc, #68]	; (801f040 <finsh_compile+0x17dc>)
 801effa:	6013      	str	r3, [r2, #0]
                    break;
 801effc:	e009      	b.n	801f012 <finsh_compile+0x17ae>
                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
 801effe:	4b10      	ldr	r3, [pc, #64]	; (801f040 <finsh_compile+0x17dc>)
 801f000:	681b      	ldr	r3, [r3, #0]
 801f002:	222f      	movs	r2, #47	; 0x2f
 801f004:	701a      	strb	r2, [r3, #0]
 801f006:	4b0e      	ldr	r3, [pc, #56]	; (801f040 <finsh_compile+0x17dc>)
 801f008:	681b      	ldr	r3, [r3, #0]
 801f00a:	3301      	adds	r3, #1
 801f00c:	4a0c      	ldr	r2, [pc, #48]	; (801f040 <finsh_compile+0x17dc>)
 801f00e:	6013      	str	r3, [r2, #0]
                    break;
 801f010:	bf00      	nop
                default:
                    break;
                }
            }
            break;
 801f012:	e006      	b.n	801f022 <finsh_compile+0x17be>
        case FINSH_NODE_SYS_GETADDR:
            /* nothing will be generated */
            break;

        default:
            finsh_error_set(FINSH_ERROR_UNKNOWN_NODE);
 801f014:	2008      	movs	r0, #8
 801f016:	f000 f971 	bl	801f2fc <finsh_error_set>
            break;
 801f01a:	e002      	b.n	801f022 <finsh_compile+0x17be>
            }
            break;

        case FINSH_NODE_SYS_GETADDR:
            /* nothing will be generated */
            break;
 801f01c:	bf00      	nop
 801f01e:	e000      	b.n	801f022 <finsh_compile+0x17be>
                            break;
                        }
                    }
                }
            }
            break;
 801f020:	bf00      	nop
            finsh_error_set(FINSH_ERROR_UNKNOWN_NODE);
            break;
        }

        /* compile sibling node */
        if (finsh_node_sibling(node) != NULL)
 801f022:	687b      	ldr	r3, [r7, #4]
 801f024:	68db      	ldr	r3, [r3, #12]
 801f026:	2b00      	cmp	r3, #0
 801f028:	d004      	beq.n	801f034 <finsh_compile+0x17d0>
            finsh_compile(finsh_node_sibling(node));
 801f02a:	687b      	ldr	r3, [r7, #4]
 801f02c:	68db      	ldr	r3, [r3, #12]
 801f02e:	4618      	mov	r0, r3
 801f030:	f7fe fc18 	bl	801d864 <finsh_compile>
    }

    return 0;
 801f034:	2300      	movs	r3, #0
}
 801f036:	4618      	mov	r0, r3
 801f038:	3728      	adds	r7, #40	; 0x28
 801f03a:	46bd      	mov	sp, r7
 801f03c:	bd80      	pop	{r7, pc}
 801f03e:	bf00      	nop
 801f040:	20012bdc 	.word	0x20012bdc

0801f044 <finsh_type_check>:

static int finsh_type_check(struct finsh_node* node, u_char is_addr)
{
 801f044:	b580      	push	{r7, lr}
 801f046:	b084      	sub	sp, #16
 801f048:	af00      	add	r7, sp, #0
 801f04a:	6078      	str	r0, [r7, #4]
 801f04c:	460b      	mov	r3, r1
 801f04e:	70fb      	strb	r3, [r7, #3]
    if (node != NULL)
 801f050:	687b      	ldr	r3, [r7, #4]
 801f052:	2b00      	cmp	r3, #0
 801f054:	f000 80fc 	beq.w	801f250 <finsh_type_check+0x20c>
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
 801f058:	687b      	ldr	r3, [r7, #4]
 801f05a:	781b      	ldrb	r3, [r3, #0]
 801f05c:	2b13      	cmp	r3, #19
 801f05e:	d00b      	beq.n	801f078 <finsh_type_check+0x34>
            node->node_type == FINSH_NODE_SYS_PREINC ||
 801f060:	687b      	ldr	r3, [r7, #4]
 801f062:	781b      	ldrb	r3, [r3, #0]
static int finsh_type_check(struct finsh_node* node, u_char is_addr)
{
    if (node != NULL)
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
 801f064:	2b15      	cmp	r3, #21
 801f066:	d007      	beq.n	801f078 <finsh_type_check+0x34>
            node->node_type == FINSH_NODE_SYS_PREINC ||
            node->node_type == FINSH_NODE_SYS_PREDEC ||
 801f068:	687b      	ldr	r3, [r7, #4]
 801f06a:	781b      	ldrb	r3, [r3, #0]
{
    if (node != NULL)
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
            node->node_type == FINSH_NODE_SYS_PREINC ||
 801f06c:	2b16      	cmp	r3, #22
 801f06e:	d003      	beq.n	801f078 <finsh_type_check+0x34>
            node->node_type == FINSH_NODE_SYS_PREDEC ||
            node->node_type == FINSH_NODE_SYS_GETADDR)
 801f070:	687b      	ldr	r3, [r7, #4]
 801f072:	781b      	ldrb	r3, [r3, #0]
    if (node != NULL)
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
            node->node_type == FINSH_NODE_SYS_PREINC ||
            node->node_type == FINSH_NODE_SYS_PREDEC ||
 801f074:	2b1a      	cmp	r3, #26
 801f076:	d106      	bne.n	801f086 <finsh_type_check+0x42>
            node->node_type == FINSH_NODE_SYS_GETADDR)
        {
            /* address */
            finsh_type_check(finsh_node_child(node), FINSH_IDTYPE_ADDRESS);
 801f078:	687b      	ldr	r3, [r7, #4]
 801f07a:	691b      	ldr	r3, [r3, #16]
 801f07c:	4618      	mov	r0, r3
 801f07e:	2108      	movs	r1, #8
 801f080:	f7ff ffe0 	bl	801f044 <finsh_type_check>
 801f084:	e014      	b.n	801f0b0 <finsh_type_check+0x6c>
        }
        else if (node->node_type == FINSH_NODE_SYS_GETVALUE && is_addr)
 801f086:	687b      	ldr	r3, [r7, #4]
 801f088:	781b      	ldrb	r3, [r3, #0]
 801f08a:	2b19      	cmp	r3, #25
 801f08c:	d109      	bne.n	801f0a2 <finsh_type_check+0x5e>
 801f08e:	78fb      	ldrb	r3, [r7, #3]
 801f090:	2b00      	cmp	r3, #0
 801f092:	d006      	beq.n	801f0a2 <finsh_type_check+0x5e>
        {
            /* change the attribute of getvalue in left expr */
            finsh_type_check(finsh_node_child(node), 0);
 801f094:	687b      	ldr	r3, [r7, #4]
 801f096:	691b      	ldr	r3, [r3, #16]
 801f098:	4618      	mov	r0, r3
 801f09a:	2100      	movs	r1, #0
 801f09c:	f7ff ffd2 	bl	801f044 <finsh_type_check>
 801f0a0:	e006      	b.n	801f0b0 <finsh_type_check+0x6c>
        }
        else
        {
            /* transfer 'av' to child node */
            finsh_type_check(finsh_node_child(node), is_addr);
 801f0a2:	687b      	ldr	r3, [r7, #4]
 801f0a4:	691a      	ldr	r2, [r3, #16]
 801f0a6:	78fb      	ldrb	r3, [r7, #3]
 801f0a8:	4610      	mov	r0, r2
 801f0aa:	4619      	mov	r1, r3
 801f0ac:	f7ff ffca 	bl	801f044 <finsh_type_check>
        }

        /* always does not load address in sibling */
        finsh_type_check(finsh_node_sibling(node), FINSH_NODE_VALUE);
 801f0b0:	687b      	ldr	r3, [r7, #4]
 801f0b2:	68db      	ldr	r3, [r3, #12]
 801f0b4:	4618      	mov	r0, r3
 801f0b6:	2100      	movs	r1, #0
 801f0b8:	f7ff ffc4 	bl	801f044 <finsh_type_check>

        /** set attribute of current node */

        /* make sure the current node is address or value */
        if (node->idtype != FINSH_IDTYPE_SYSCALL) node->idtype |= is_addr;
 801f0bc:	687b      	ldr	r3, [r7, #4]
 801f0be:	789b      	ldrb	r3, [r3, #2]
 801f0c0:	2b04      	cmp	r3, #4
 801f0c2:	d006      	beq.n	801f0d2 <finsh_type_check+0x8e>
 801f0c4:	687b      	ldr	r3, [r7, #4]
 801f0c6:	789a      	ldrb	r2, [r3, #2]
 801f0c8:	78fb      	ldrb	r3, [r7, #3]
 801f0ca:	4313      	orrs	r3, r2
 801f0cc:	b2da      	uxtb	r2, r3
 801f0ce:	687b      	ldr	r3, [r7, #4]
 801f0d0:	709a      	strb	r2, [r3, #2]

        if (finsh_node_child(node) != NULL)
 801f0d2:	687b      	ldr	r3, [r7, #4]
 801f0d4:	691b      	ldr	r3, [r3, #16]
 801f0d6:	2b00      	cmp	r3, #0
 801f0d8:	d006      	beq.n	801f0e8 <finsh_type_check+0xa4>
        {
            node->data_type = finsh_node_child(node)->data_type;
 801f0da:	687b      	ldr	r3, [r7, #4]
 801f0dc:	691b      	ldr	r3, [r3, #16]
 801f0de:	785a      	ldrb	r2, [r3, #1]
 801f0e0:	687b      	ldr	r3, [r7, #4]
 801f0e2:	705a      	strb	r2, [r3, #1]
            return 0;
 801f0e4:	2300      	movs	r3, #0
 801f0e6:	e0b4      	b.n	801f252 <finsh_type_check+0x20e>
        }

        if (node->node_type == FINSH_NODE_ID)
 801f0e8:	687b      	ldr	r3, [r7, #4]
 801f0ea:	781b      	ldrb	r3, [r3, #0]
 801f0ec:	2b01      	cmp	r3, #1
 801f0ee:	f040 8094 	bne.w	801f21a <finsh_type_check+0x1d6>
        {
            if (node->idtype & FINSH_IDTYPE_VAR)
 801f0f2:	687b      	ldr	r3, [r7, #4]
 801f0f4:	789b      	ldrb	r3, [r3, #2]
 801f0f6:	f003 0301 	and.w	r3, r3, #1
 801f0fa:	2b00      	cmp	r3, #0
 801f0fc:	d043      	beq.n	801f186 <finsh_type_check+0x142>
            {
                struct finsh_var* var;

                var = node->id.var;
 801f0fe:	687b      	ldr	r3, [r7, #4]
 801f100:	689b      	ldr	r3, [r3, #8]
 801f102:	60fb      	str	r3, [r7, #12]
                if (var != NULL)
 801f104:	68fb      	ldr	r3, [r7, #12]
 801f106:	2b00      	cmp	r3, #0
 801f108:	d03c      	beq.n	801f184 <finsh_type_check+0x140>
                {
                    switch (var->type)
 801f10a:	68fb      	ldr	r3, [r7, #12]
 801f10c:	7c5b      	ldrb	r3, [r3, #17]
 801f10e:	3b01      	subs	r3, #1
 801f110:	2b0d      	cmp	r3, #13
 801f112:	d833      	bhi.n	801f17c <finsh_type_check+0x138>
 801f114:	a201      	add	r2, pc, #4	; (adr r2, 801f11c <finsh_type_check+0xd8>)
 801f116:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801f11a:	bf00      	nop
 801f11c:	0801f155 	.word	0x0801f155
 801f120:	0801f175 	.word	0x0801f175
 801f124:	0801f15d 	.word	0x0801f15d
 801f128:	0801f15d 	.word	0x0801f15d
 801f12c:	0801f175 	.word	0x0801f175
 801f130:	0801f165 	.word	0x0801f165
 801f134:	0801f165 	.word	0x0801f165
 801f138:	0801f175 	.word	0x0801f175
 801f13c:	0801f16d 	.word	0x0801f16d
 801f140:	0801f16d 	.word	0x0801f16d
 801f144:	0801f175 	.word	0x0801f175
 801f148:	0801f16d 	.word	0x0801f16d
 801f14c:	0801f16d 	.word	0x0801f16d
 801f150:	0801f175 	.word	0x0801f175
                    {
                    case finsh_type_void:
                        node->data_type = FINSH_DATA_TYPE_VOID;
 801f154:	687b      	ldr	r3, [r7, #4]
 801f156:	2200      	movs	r2, #0
 801f158:	705a      	strb	r2, [r3, #1]
                        break;
 801f15a:	e013      	b.n	801f184 <finsh_type_check+0x140>

                    case finsh_type_char:
                    case finsh_type_uchar:
                        node->data_type = FINSH_DATA_TYPE_BYTE;
 801f15c:	687b      	ldr	r3, [r7, #4]
 801f15e:	2201      	movs	r2, #1
 801f160:	705a      	strb	r2, [r3, #1]
                        break;
 801f162:	e00f      	b.n	801f184 <finsh_type_check+0x140>

                    case finsh_type_short:
                    case finsh_type_ushort:
                        node->data_type = FINSH_DATA_TYPE_WORD;
 801f164:	687b      	ldr	r3, [r7, #4]
 801f166:	2202      	movs	r2, #2
 801f168:	705a      	strb	r2, [r3, #1]
                        break;
 801f16a:	e00b      	b.n	801f184 <finsh_type_check+0x140>

                    case finsh_type_int:
                    case finsh_type_uint:
                    case finsh_type_long:
                    case finsh_type_ulong:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
 801f16c:	687b      	ldr	r3, [r7, #4]
 801f16e:	2203      	movs	r2, #3
 801f170:	705a      	strb	r2, [r3, #1]
                        break;
 801f172:	e007      	b.n	801f184 <finsh_type_check+0x140>
                    case finsh_type_charp:
                    case finsh_type_voidp:
                    case finsh_type_shortp:
                    case finsh_type_intp:
                    case finsh_type_longp:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
 801f174:	687b      	ldr	r3, [r7, #4]
 801f176:	2203      	movs	r2, #3
 801f178:	705a      	strb	r2, [r3, #1]
                        break;
 801f17a:	e003      	b.n	801f184 <finsh_type_check+0x140>

                    default:
                        finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
 801f17c:	2003      	movs	r0, #3
 801f17e:	f000 f8bd 	bl	801f2fc <finsh_error_set>
                        break;
 801f182:	bf00      	nop
 801f184:	e064      	b.n	801f250 <finsh_type_check+0x20c>
                    }
                }
            }
            else if (node->idtype & FINSH_IDTYPE_SYSVAR)
 801f186:	687b      	ldr	r3, [r7, #4]
 801f188:	789b      	ldrb	r3, [r3, #2]
 801f18a:	f003 0302 	and.w	r3, r3, #2
 801f18e:	2b00      	cmp	r3, #0
 801f190:	d042      	beq.n	801f218 <finsh_type_check+0x1d4>
            {
                struct finsh_sysvar *sysvar;

                sysvar = node->id.sysvar;
 801f192:	687b      	ldr	r3, [r7, #4]
 801f194:	689b      	ldr	r3, [r3, #8]
 801f196:	60bb      	str	r3, [r7, #8]
                if (sysvar != NULL)
 801f198:	68bb      	ldr	r3, [r7, #8]
 801f19a:	2b00      	cmp	r3, #0
 801f19c:	d03c      	beq.n	801f218 <finsh_type_check+0x1d4>
                {
                    switch (sysvar->type)
 801f19e:	68bb      	ldr	r3, [r7, #8]
 801f1a0:	7a1b      	ldrb	r3, [r3, #8]
 801f1a2:	3b01      	subs	r3, #1
 801f1a4:	2b0d      	cmp	r3, #13
 801f1a6:	d833      	bhi.n	801f210 <finsh_type_check+0x1cc>
 801f1a8:	a201      	add	r2, pc, #4	; (adr r2, 801f1b0 <finsh_type_check+0x16c>)
 801f1aa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801f1ae:	bf00      	nop
 801f1b0:	0801f1e9 	.word	0x0801f1e9
 801f1b4:	0801f209 	.word	0x0801f209
 801f1b8:	0801f1f1 	.word	0x0801f1f1
 801f1bc:	0801f1f1 	.word	0x0801f1f1
 801f1c0:	0801f209 	.word	0x0801f209
 801f1c4:	0801f1f9 	.word	0x0801f1f9
 801f1c8:	0801f1f9 	.word	0x0801f1f9
 801f1cc:	0801f209 	.word	0x0801f209
 801f1d0:	0801f201 	.word	0x0801f201
 801f1d4:	0801f201 	.word	0x0801f201
 801f1d8:	0801f209 	.word	0x0801f209
 801f1dc:	0801f201 	.word	0x0801f201
 801f1e0:	0801f201 	.word	0x0801f201
 801f1e4:	0801f209 	.word	0x0801f209
                    {
                    case finsh_type_void:
                        node->data_type = FINSH_DATA_TYPE_VOID;
 801f1e8:	687b      	ldr	r3, [r7, #4]
 801f1ea:	2200      	movs	r2, #0
 801f1ec:	705a      	strb	r2, [r3, #1]
                        break;
 801f1ee:	e013      	b.n	801f218 <finsh_type_check+0x1d4>

                    case finsh_type_char:
                    case finsh_type_uchar:
                        node->data_type = FINSH_DATA_TYPE_BYTE;
 801f1f0:	687b      	ldr	r3, [r7, #4]
 801f1f2:	2201      	movs	r2, #1
 801f1f4:	705a      	strb	r2, [r3, #1]
                        break;
 801f1f6:	e00f      	b.n	801f218 <finsh_type_check+0x1d4>

                    case finsh_type_short:
                    case finsh_type_ushort:
                        node->data_type = FINSH_DATA_TYPE_WORD;
 801f1f8:	687b      	ldr	r3, [r7, #4]
 801f1fa:	2202      	movs	r2, #2
 801f1fc:	705a      	strb	r2, [r3, #1]
                        break;
 801f1fe:	e00b      	b.n	801f218 <finsh_type_check+0x1d4>

                    case finsh_type_int:
                    case finsh_type_uint:
                    case finsh_type_long:
                    case finsh_type_ulong:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
 801f200:	687b      	ldr	r3, [r7, #4]
 801f202:	2203      	movs	r2, #3
 801f204:	705a      	strb	r2, [r3, #1]
                        break;
 801f206:	e007      	b.n	801f218 <finsh_type_check+0x1d4>
                    case finsh_type_charp:
                    case finsh_type_voidp:
                    case finsh_type_shortp:
                    case finsh_type_intp:
                    case finsh_type_longp:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
 801f208:	687b      	ldr	r3, [r7, #4]
 801f20a:	2203      	movs	r2, #3
 801f20c:	705a      	strb	r2, [r3, #1]
                        break;
 801f20e:	e003      	b.n	801f218 <finsh_type_check+0x1d4>

                    default:
                        finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
 801f210:	2003      	movs	r0, #3
 801f212:	f000 f873 	bl	801f2fc <finsh_error_set>
                        break;
 801f216:	bf00      	nop
 801f218:	e01a      	b.n	801f250 <finsh_type_check+0x20c>
                    }
                }
            }
        }
        else if (node->node_type == FINSH_NODE_VALUE_CHAR)
 801f21a:	687b      	ldr	r3, [r7, #4]
 801f21c:	781b      	ldrb	r3, [r3, #0]
 801f21e:	2b02      	cmp	r3, #2
 801f220:	d103      	bne.n	801f22a <finsh_type_check+0x1e6>
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
 801f222:	687b      	ldr	r3, [r7, #4]
 801f224:	2201      	movs	r2, #1
 801f226:	705a      	strb	r2, [r3, #1]
 801f228:	e012      	b.n	801f250 <finsh_type_check+0x20c>
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
 801f22a:	687b      	ldr	r3, [r7, #4]
 801f22c:	781b      	ldrb	r3, [r3, #0]
 801f22e:	2b03      	cmp	r3, #3
 801f230:	d00b      	beq.n	801f24a <finsh_type_check+0x206>
            node->node_type == FINSH_NODE_VALUE_LONG    ||
 801f232:	687b      	ldr	r3, [r7, #4]
 801f234:	781b      	ldrb	r3, [r3, #0]
        }
        else if (node->node_type == FINSH_NODE_VALUE_CHAR)
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
 801f236:	2b04      	cmp	r3, #4
 801f238:	d007      	beq.n	801f24a <finsh_type_check+0x206>
            node->node_type == FINSH_NODE_VALUE_LONG    ||
            node->node_type == FINSH_NODE_VALUE_STRING  ||
 801f23a:	687b      	ldr	r3, [r7, #4]
 801f23c:	781b      	ldrb	r3, [r3, #0]
        else if (node->node_type == FINSH_NODE_VALUE_CHAR)
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
            node->node_type == FINSH_NODE_VALUE_LONG    ||
 801f23e:	2b05      	cmp	r3, #5
 801f240:	d003      	beq.n	801f24a <finsh_type_check+0x206>
            node->node_type == FINSH_NODE_VALUE_STRING  ||
            node->node_type == FINSH_NODE_VALUE_NULL)
 801f242:	687b      	ldr	r3, [r7, #4]
 801f244:	781b      	ldrb	r3, [r3, #0]
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
            node->node_type == FINSH_NODE_VALUE_LONG    ||
            node->node_type == FINSH_NODE_VALUE_STRING  ||
 801f246:	2b06      	cmp	r3, #6
 801f248:	d102      	bne.n	801f250 <finsh_type_check+0x20c>
            node->node_type == FINSH_NODE_VALUE_NULL)
        {
            node->data_type = FINSH_DATA_TYPE_DWORD;
 801f24a:	687b      	ldr	r3, [r7, #4]
 801f24c:	2203      	movs	r2, #3
 801f24e:	705a      	strb	r2, [r3, #1]
        }
    }
    return 0;
 801f250:	2300      	movs	r3, #0
}
 801f252:	4618      	mov	r0, r3
 801f254:	3710      	adds	r7, #16
 801f256:	46bd      	mov	sp, r7
 801f258:	bd80      	pop	{r7, pc}
 801f25a:	bf00      	nop

0801f25c <finsh_compiler_run>:

int finsh_compiler_run(struct finsh_node* node)
{
 801f25c:	b580      	push	{r7, lr}
 801f25e:	b084      	sub	sp, #16
 801f260:	af00      	add	r7, sp, #0
 801f262:	6078      	str	r0, [r7, #4]
    struct finsh_node* sibling;

    /* type check */
    finsh_type_check(node, FINSH_NODE_VALUE);
 801f264:	6878      	ldr	r0, [r7, #4]
 801f266:	2100      	movs	r1, #0
 801f268:	f7ff feec 	bl	801f044 <finsh_type_check>

    /* clean text segment and vm stack */
    memset(&text_segment[0], 0, sizeof(text_segment));
 801f26c:	4818      	ldr	r0, [pc, #96]	; (801f2d0 <finsh_compiler_run+0x74>)
 801f26e:	2100      	movs	r1, #0
 801f270:	2280      	movs	r2, #128	; 0x80
 801f272:	f003 fa03 	bl	802267c <memset>
    memset(&finsh_vm_stack[0], 0, sizeof(finsh_vm_stack[0]));
 801f276:	4817      	ldr	r0, [pc, #92]	; (801f2d4 <finsh_compiler_run+0x78>)
 801f278:	2100      	movs	r1, #0
 801f27a:	2204      	movs	r2, #4
 801f27c:	f003 f9fe 	bl	802267c <memset>

    /* reset compile stack pointer and pc */
    finsh_compile_sp = &finsh_vm_stack[0];
 801f280:	4b15      	ldr	r3, [pc, #84]	; (801f2d8 <finsh_compiler_run+0x7c>)
 801f282:	4a14      	ldr	r2, [pc, #80]	; (801f2d4 <finsh_compiler_run+0x78>)
 801f284:	601a      	str	r2, [r3, #0]
    finsh_compile_pc = &text_segment[0];
 801f286:	4b15      	ldr	r3, [pc, #84]	; (801f2dc <finsh_compiler_run+0x80>)
 801f288:	4a11      	ldr	r2, [pc, #68]	; (801f2d0 <finsh_compiler_run+0x74>)
 801f28a:	601a      	str	r2, [r3, #0]

    /* compile node */
    sibling = node;
 801f28c:	687b      	ldr	r3, [r7, #4]
 801f28e:	60fb      	str	r3, [r7, #12]
    while (sibling != NULL)
 801f290:	e016      	b.n	801f2c0 <finsh_compiler_run+0x64>
    {
        struct finsh_node* current_node;
        current_node = sibling;
 801f292:	68fb      	ldr	r3, [r7, #12]
 801f294:	60bb      	str	r3, [r7, #8]

        /* get sibling node */
        sibling = current_node->sibling;
 801f296:	68bb      	ldr	r3, [r7, #8]
 801f298:	68db      	ldr	r3, [r3, #12]
 801f29a:	60fb      	str	r3, [r7, #12]

        /* clean sibling node */
        current_node->sibling = NULL;
 801f29c:	68bb      	ldr	r3, [r7, #8]
 801f29e:	2200      	movs	r2, #0
 801f2a0:	60da      	str	r2, [r3, #12]
        finsh_compile(current_node);
 801f2a2:	68b8      	ldr	r0, [r7, #8]
 801f2a4:	f7fe fade 	bl	801d864 <finsh_compile>

        /* pop current value */
        if (sibling != NULL) finsh_code_byte(FINSH_OP_POP);
 801f2a8:	68fb      	ldr	r3, [r7, #12]
 801f2aa:	2b00      	cmp	r3, #0
 801f2ac:	d008      	beq.n	801f2c0 <finsh_compiler_run+0x64>
 801f2ae:	4b0b      	ldr	r3, [pc, #44]	; (801f2dc <finsh_compiler_run+0x80>)
 801f2b0:	681b      	ldr	r3, [r3, #0]
 801f2b2:	222b      	movs	r2, #43	; 0x2b
 801f2b4:	701a      	strb	r2, [r3, #0]
 801f2b6:	4b09      	ldr	r3, [pc, #36]	; (801f2dc <finsh_compiler_run+0x80>)
 801f2b8:	681b      	ldr	r3, [r3, #0]
 801f2ba:	3301      	adds	r3, #1
 801f2bc:	4a07      	ldr	r2, [pc, #28]	; (801f2dc <finsh_compiler_run+0x80>)
 801f2be:	6013      	str	r3, [r2, #0]
    finsh_compile_sp = &finsh_vm_stack[0];
    finsh_compile_pc = &text_segment[0];

    /* compile node */
    sibling = node;
    while (sibling != NULL)
 801f2c0:	68fb      	ldr	r3, [r7, #12]
 801f2c2:	2b00      	cmp	r3, #0
 801f2c4:	d1e5      	bne.n	801f292 <finsh_compiler_run+0x36>

        /* pop current value */
        if (sibling != NULL) finsh_code_byte(FINSH_OP_POP);
    }

    return 0;
 801f2c6:	2300      	movs	r3, #0
}
 801f2c8:	4618      	mov	r0, r3
 801f2ca:	3710      	adds	r7, #16
 801f2cc:	46bd      	mov	sp, r7
 801f2ce:	bd80      	pop	{r7, pc}
 801f2d0:	20012e6c 	.word	0x20012e6c
 801f2d4:	20012eec 	.word	0x20012eec
 801f2d8:	20012be0 	.word	0x20012be0
 801f2dc:	20012bdc 	.word	0x20012bdc

0801f2e0 <finsh_error_init>:
	"Unknown symbol",
	"Null node"
};

int finsh_error_init()
{
 801f2e0:	b480      	push	{r7}
 801f2e2:	af00      	add	r7, sp, #0
	global_errno = FINSH_ERROR_OK;
 801f2e4:	4b04      	ldr	r3, [pc, #16]	; (801f2f8 <finsh_error_init+0x18>)
 801f2e6:	2200      	movs	r2, #0
 801f2e8:	701a      	strb	r2, [r3, #0]

	return 0;
 801f2ea:	2300      	movs	r3, #0
}
 801f2ec:	4618      	mov	r0, r3
 801f2ee:	46bd      	mov	sp, r7
 801f2f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f2f4:	4770      	bx	lr
 801f2f6:	bf00      	nop
 801f2f8:	20012be4 	.word	0x20012be4

0801f2fc <finsh_error_set>:

int finsh_error_set(u_char type)
{
 801f2fc:	b480      	push	{r7}
 801f2fe:	b083      	sub	sp, #12
 801f300:	af00      	add	r7, sp, #0
 801f302:	4603      	mov	r3, r0
 801f304:	71fb      	strb	r3, [r7, #7]
	global_errno = type;
 801f306:	4a05      	ldr	r2, [pc, #20]	; (801f31c <finsh_error_set+0x20>)
 801f308:	79fb      	ldrb	r3, [r7, #7]
 801f30a:	7013      	strb	r3, [r2, #0]

	return 0;
 801f30c:	2300      	movs	r3, #0
}
 801f30e:	4618      	mov	r0, r3
 801f310:	370c      	adds	r7, #12
 801f312:	46bd      	mov	sp, r7
 801f314:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f318:	4770      	bx	lr
 801f31a:	bf00      	nop
 801f31c:	20012be4 	.word	0x20012be4

0801f320 <finsh_errno>:

u_char finsh_errno()
{
 801f320:	b480      	push	{r7}
 801f322:	af00      	add	r7, sp, #0
	return global_errno;
 801f324:	4b03      	ldr	r3, [pc, #12]	; (801f334 <finsh_errno+0x14>)
 801f326:	781b      	ldrb	r3, [r3, #0]
}
 801f328:	4618      	mov	r0, r3
 801f32a:	46bd      	mov	sp, r7
 801f32c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f330:	4770      	bx	lr
 801f332:	bf00      	nop
 801f334:	20012be4 	.word	0x20012be4

0801f338 <finsh_error_string>:

const char* finsh_error_string(u_char type)
{
 801f338:	b480      	push	{r7}
 801f33a:	b083      	sub	sp, #12
 801f33c:	af00      	add	r7, sp, #0
 801f33e:	4603      	mov	r3, r0
 801f340:	71fb      	strb	r3, [r7, #7]
	return finsh_error_string_table[type];
 801f342:	79fb      	ldrb	r3, [r7, #7]
 801f344:	4a04      	ldr	r2, [pc, #16]	; (801f358 <finsh_error_string+0x20>)
 801f346:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 801f34a:	4618      	mov	r0, r3
 801f34c:	370c      	adds	r7, #12
 801f34e:	46bd      	mov	sp, r7
 801f350:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f354:	4770      	bx	lr
 801f356:	bf00      	nop
 801f358:	200100d0 	.word	0x200100d0

0801f35c <finsh_heap_init>:
static void finsh_block_remove(struct finsh_block_header** list, struct finsh_block_header* header);
static void finsh_block_split(struct finsh_block_header* header, size_t size);
static void finsh_block_merge(struct finsh_block_header** list, struct finsh_block_header* header);

int finsh_heap_init(void)
{
 801f35c:	b580      	push	{r7, lr}
 801f35e:	af00      	add	r7, sp, #0
	/* clear heap to zero */
	memset(&finsh_heap[0], 0, sizeof(finsh_heap));
 801f360:	480a      	ldr	r0, [pc, #40]	; (801f38c <finsh_heap_init+0x30>)
 801f362:	2100      	movs	r1, #0
 801f364:	2280      	movs	r2, #128	; 0x80
 801f366:	f003 f989 	bl	802267c <memset>

	/* init free and alloc list */
    free_list           = BLOCK_HEADER(&finsh_heap[0]);
 801f36a:	4b09      	ldr	r3, [pc, #36]	; (801f390 <finsh_heap_init+0x34>)
 801f36c:	4a07      	ldr	r2, [pc, #28]	; (801f38c <finsh_heap_init+0x30>)
 801f36e:	601a      	str	r2, [r3, #0]
	free_list->length   = FINSH_HEAP_MAX - sizeof(struct finsh_block_header);
 801f370:	4b07      	ldr	r3, [pc, #28]	; (801f390 <finsh_heap_init+0x34>)
 801f372:	681b      	ldr	r3, [r3, #0]
 801f374:	2278      	movs	r2, #120	; 0x78
 801f376:	601a      	str	r2, [r3, #0]
    free_list->next     = NULL;
 801f378:	4b05      	ldr	r3, [pc, #20]	; (801f390 <finsh_heap_init+0x34>)
 801f37a:	681b      	ldr	r3, [r3, #0]
 801f37c:	2200      	movs	r2, #0
 801f37e:	605a      	str	r2, [r3, #4]

    allocate_list       = NULL;
 801f380:	4b04      	ldr	r3, [pc, #16]	; (801f394 <finsh_heap_init+0x38>)
 801f382:	2200      	movs	r2, #0
 801f384:	601a      	str	r2, [r3, #0]

    return 0;
 801f386:	2300      	movs	r3, #0
}
 801f388:	4618      	mov	r0, r3
 801f38a:	bd80      	pop	{r7, pc}
 801f38c:	20012be8 	.word	0x20012be8
 801f390:	200121c4 	.word	0x200121c4
 801f394:	200121c8 	.word	0x200121c8

0801f398 <finsh_heap_allocate>:

/**
 * allocate a block from heap
 */
void* finsh_heap_allocate(size_t size)
{
 801f398:	b580      	push	{r7, lr}
 801f39a:	b084      	sub	sp, #16
 801f39c:	af00      	add	r7, sp, #0
 801f39e:	6078      	str	r0, [r7, #4]
	struct finsh_block_header* header;

	size = HEAP_ALIGN_SIZE(size);
 801f3a0:	687b      	ldr	r3, [r7, #4]
 801f3a2:	3303      	adds	r3, #3
 801f3a4:	f023 0303 	bic.w	r3, r3, #3
 801f3a8:	607b      	str	r3, [r7, #4]

    /* find the first fit block */
    for (header = free_list;
 801f3aa:	4b23      	ldr	r3, [pc, #140]	; (801f438 <finsh_heap_allocate+0xa0>)
 801f3ac:	681b      	ldr	r3, [r3, #0]
 801f3ae:	60fb      	str	r3, [r7, #12]
 801f3b0:	e002      	b.n	801f3b8 <finsh_heap_allocate+0x20>
        ((header != NULL) && (header->length <= size + sizeof(struct finsh_block_header)));
        header = header->next) ;
 801f3b2:	68fb      	ldr	r3, [r7, #12]
 801f3b4:	685b      	ldr	r3, [r3, #4]
 801f3b6:	60fb      	str	r3, [r7, #12]
	struct finsh_block_header* header;

	size = HEAP_ALIGN_SIZE(size);

    /* find the first fit block */
    for (header = free_list;
 801f3b8:	68fb      	ldr	r3, [r7, #12]
 801f3ba:	2b00      	cmp	r3, #0
 801f3bc:	d005      	beq.n	801f3ca <finsh_heap_allocate+0x32>
        ((header != NULL) && (header->length <= size + sizeof(struct finsh_block_header)));
 801f3be:	68fb      	ldr	r3, [r7, #12]
 801f3c0:	681a      	ldr	r2, [r3, #0]
 801f3c2:	687b      	ldr	r3, [r7, #4]
 801f3c4:	3308      	adds	r3, #8
 801f3c6:	429a      	cmp	r2, r3
 801f3c8:	d9f3      	bls.n	801f3b2 <finsh_heap_allocate+0x1a>
        header = header->next) ;

	if (header == NULL)
 801f3ca:	68fb      	ldr	r3, [r7, #12]
 801f3cc:	2b00      	cmp	r3, #0
 801f3ce:	d116      	bne.n	801f3fe <finsh_heap_allocate+0x66>
	{
		finsh_heap_gc();
 801f3d0:	f000 f850 	bl	801f474 <finsh_heap_gc>

		/* find the first fit block */
		for (header = free_list;
 801f3d4:	4b18      	ldr	r3, [pc, #96]	; (801f438 <finsh_heap_allocate+0xa0>)
 801f3d6:	681b      	ldr	r3, [r3, #0]
 801f3d8:	60fb      	str	r3, [r7, #12]
 801f3da:	e002      	b.n	801f3e2 <finsh_heap_allocate+0x4a>
			((header != NULL) && (header->length < size + sizeof(struct finsh_block_header)));
			header = header->next) ;
 801f3dc:	68fb      	ldr	r3, [r7, #12]
 801f3de:	685b      	ldr	r3, [r3, #4]
 801f3e0:	60fb      	str	r3, [r7, #12]
	if (header == NULL)
	{
		finsh_heap_gc();

		/* find the first fit block */
		for (header = free_list;
 801f3e2:	68fb      	ldr	r3, [r7, #12]
 801f3e4:	2b00      	cmp	r3, #0
 801f3e6:	d005      	beq.n	801f3f4 <finsh_heap_allocate+0x5c>
			((header != NULL) && (header->length < size + sizeof(struct finsh_block_header)));
 801f3e8:	68fb      	ldr	r3, [r7, #12]
 801f3ea:	681a      	ldr	r2, [r3, #0]
 801f3ec:	687b      	ldr	r3, [r7, #4]
 801f3ee:	3308      	adds	r3, #8
 801f3f0:	429a      	cmp	r2, r3
 801f3f2:	d3f3      	bcc.n	801f3dc <finsh_heap_allocate+0x44>
			header = header->next) ;

		/* there is no memory */
		if (header == NULL) return NULL;
 801f3f4:	68fb      	ldr	r3, [r7, #12]
 801f3f6:	2b00      	cmp	r3, #0
 801f3f8:	d101      	bne.n	801f3fe <finsh_heap_allocate+0x66>
 801f3fa:	2300      	movs	r3, #0
 801f3fc:	e017      	b.n	801f42e <finsh_heap_allocate+0x96>
	}

    /* split block */
	finsh_block_split(header, size);
 801f3fe:	68f8      	ldr	r0, [r7, #12]
 801f400:	6879      	ldr	r1, [r7, #4]
 801f402:	f000 f8e7 	bl	801f5d4 <finsh_block_split>

	/* remove from free list */
	finsh_block_remove(&free_list, header);
 801f406:	480c      	ldr	r0, [pc, #48]	; (801f438 <finsh_heap_allocate+0xa0>)
 801f408:	68f9      	ldr	r1, [r7, #12]
 801f40a:	f000 f8b5 	bl	801f578 <finsh_block_remove>
	header->next = NULL;
 801f40e:	68fb      	ldr	r3, [r7, #12]
 801f410:	2200      	movs	r2, #0
 801f412:	605a      	str	r2, [r3, #4]

    /* insert to allocate list */
    finsh_block_insert(&allocate_list, header);
 801f414:	4809      	ldr	r0, [pc, #36]	; (801f43c <finsh_heap_allocate+0xa4>)
 801f416:	68f9      	ldr	r1, [r7, #12]
 801f418:	f000 f86e 	bl	801f4f8 <finsh_block_insert>

	memset(finsh_block_get_data(header), 0, size);
 801f41c:	68fb      	ldr	r3, [r7, #12]
 801f41e:	3308      	adds	r3, #8
 801f420:	4618      	mov	r0, r3
 801f422:	2100      	movs	r1, #0
 801f424:	687a      	ldr	r2, [r7, #4]
 801f426:	f003 f929 	bl	802267c <memset>

	return finsh_block_get_data(header);
 801f42a:	68fb      	ldr	r3, [r7, #12]
 801f42c:	3308      	adds	r3, #8
}
 801f42e:	4618      	mov	r0, r3
 801f430:	3710      	adds	r7, #16
 801f432:	46bd      	mov	sp, r7
 801f434:	bd80      	pop	{r7, pc}
 801f436:	bf00      	nop
 801f438:	200121c4 	.word	0x200121c4
 801f43c:	200121c8 	.word	0x200121c8

0801f440 <finsh_heap_free>:

/**
 * release the allocated block
 */
void  finsh_heap_free(void*ptr)
{
 801f440:	b580      	push	{r7, lr}
 801f442:	b084      	sub	sp, #16
 801f444:	af00      	add	r7, sp, #0
 801f446:	6078      	str	r0, [r7, #4]
    struct finsh_block_header* header;

    /* get block header */
	header = finsh_block_get_header(ptr);
 801f448:	687b      	ldr	r3, [r7, #4]
 801f44a:	3b08      	subs	r3, #8
 801f44c:	60fb      	str	r3, [r7, #12]

    /* remove from allocate list */
	finsh_block_remove(&allocate_list, header);
 801f44e:	4807      	ldr	r0, [pc, #28]	; (801f46c <finsh_heap_free+0x2c>)
 801f450:	68f9      	ldr	r1, [r7, #12]
 801f452:	f000 f891 	bl	801f578 <finsh_block_remove>

	/* insert to free list */
	finsh_block_insert(&free_list, header);
 801f456:	4806      	ldr	r0, [pc, #24]	; (801f470 <finsh_heap_free+0x30>)
 801f458:	68f9      	ldr	r1, [r7, #12]
 801f45a:	f000 f84d 	bl	801f4f8 <finsh_block_insert>
	finsh_block_merge(&free_list, header);
 801f45e:	4804      	ldr	r0, [pc, #16]	; (801f470 <finsh_heap_free+0x30>)
 801f460:	68f9      	ldr	r1, [r7, #12]
 801f462:	f000 f8d9 	bl	801f618 <finsh_block_merge>
}
 801f466:	3710      	adds	r7, #16
 801f468:	46bd      	mov	sp, r7
 801f46a:	bd80      	pop	{r7, pc}
 801f46c:	200121c8 	.word	0x200121c8
 801f470:	200121c4 	.word	0x200121c4

0801f474 <finsh_heap_gc>:

/**
 * garbage collector
 */
static void finsh_heap_gc(void)
{
 801f474:	b580      	push	{r7, lr}
 801f476:	b084      	sub	sp, #16
 801f478:	af00      	add	r7, sp, #0
	int i;
	struct finsh_block_header *header, *temp;

	temp = NULL;
 801f47a:	2300      	movs	r3, #0
 801f47c:	607b      	str	r3, [r7, #4]

    /* find the first fit block */
    for (header = allocate_list; header != NULL; )
 801f47e:	4b1c      	ldr	r3, [pc, #112]	; (801f4f0 <finsh_heap_gc+0x7c>)
 801f480:	681b      	ldr	r3, [r3, #0]
 801f482:	60bb      	str	r3, [r7, #8]
 801f484:	e02e      	b.n	801f4e4 <finsh_heap_gc+0x70>
    {
    	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
 801f486:	2300      	movs	r3, #0
 801f488:	60fb      	str	r3, [r7, #12]
 801f48a:	e01b      	b.n	801f4c4 <finsh_heap_gc+0x50>
    	{
    		if (global_variable[i].type != finsh_type_unknown)
 801f48c:	4919      	ldr	r1, [pc, #100]	; (801f4f4 <finsh_heap_gc+0x80>)
 801f48e:	68fa      	ldr	r2, [r7, #12]
 801f490:	4613      	mov	r3, r2
 801f492:	005b      	lsls	r3, r3, #1
 801f494:	4413      	add	r3, r2
 801f496:	00db      	lsls	r3, r3, #3
 801f498:	440b      	add	r3, r1
 801f49a:	3310      	adds	r3, #16
 801f49c:	785b      	ldrb	r3, [r3, #1]
 801f49e:	2b00      	cmp	r3, #0
 801f4a0:	d00d      	beq.n	801f4be <finsh_heap_gc+0x4a>
    		{
    			if (global_variable[i].value.ptr == finsh_block_get_data(header))
 801f4a2:	4914      	ldr	r1, [pc, #80]	; (801f4f4 <finsh_heap_gc+0x80>)
 801f4a4:	68fa      	ldr	r2, [r7, #12]
 801f4a6:	4613      	mov	r3, r2
 801f4a8:	005b      	lsls	r3, r3, #1
 801f4aa:	4413      	add	r3, r2
 801f4ac:	00db      	lsls	r3, r3, #3
 801f4ae:	440b      	add	r3, r1
 801f4b0:	3310      	adds	r3, #16
 801f4b2:	685a      	ldr	r2, [r3, #4]
 801f4b4:	68bb      	ldr	r3, [r7, #8]
 801f4b6:	3308      	adds	r3, #8
 801f4b8:	429a      	cmp	r2, r3
 801f4ba:	d100      	bne.n	801f4be <finsh_heap_gc+0x4a>
					break;
 801f4bc:	e005      	b.n	801f4ca <finsh_heap_gc+0x56>
	temp = NULL;

    /* find the first fit block */
    for (header = allocate_list; header != NULL; )
    {
    	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
 801f4be:	68fb      	ldr	r3, [r7, #12]
 801f4c0:	3301      	adds	r3, #1
 801f4c2:	60fb      	str	r3, [r7, #12]
 801f4c4:	68fb      	ldr	r3, [r7, #12]
 801f4c6:	2b07      	cmp	r3, #7
 801f4c8:	dde0      	ble.n	801f48c <finsh_heap_gc+0x18>
    			if (global_variable[i].value.ptr == finsh_block_get_data(header))
					break;
    		}
    	}

		temp   = header;
 801f4ca:	68bb      	ldr	r3, [r7, #8]
 801f4cc:	607b      	str	r3, [r7, #4]
		header = header->next;
 801f4ce:	68bb      	ldr	r3, [r7, #8]
 801f4d0:	685b      	ldr	r3, [r3, #4]
 801f4d2:	60bb      	str	r3, [r7, #8]

		/* this block is an unused block, release it */
    	if (i == FINSH_VARIABLE_MAX)
 801f4d4:	68fb      	ldr	r3, [r7, #12]
 801f4d6:	2b08      	cmp	r3, #8
 801f4d8:	d104      	bne.n	801f4e4 <finsh_heap_gc+0x70>
    	{
    		finsh_heap_free(finsh_block_get_data(temp));
 801f4da:	687b      	ldr	r3, [r7, #4]
 801f4dc:	3308      	adds	r3, #8
 801f4de:	4618      	mov	r0, r3
 801f4e0:	f7ff ffae 	bl	801f440 <finsh_heap_free>
	struct finsh_block_header *header, *temp;

	temp = NULL;

    /* find the first fit block */
    for (header = allocate_list; header != NULL; )
 801f4e4:	68bb      	ldr	r3, [r7, #8]
 801f4e6:	2b00      	cmp	r3, #0
 801f4e8:	d1cd      	bne.n	801f486 <finsh_heap_gc+0x12>
    	if (i == FINSH_VARIABLE_MAX)
    	{
    		finsh_heap_free(finsh_block_get_data(temp));
    	}
    }
}
 801f4ea:	3710      	adds	r7, #16
 801f4ec:	46bd      	mov	sp, r7
 801f4ee:	bd80      	pop	{r7, pc}
 801f4f0:	200121c8 	.word	0x200121c8
 801f4f4:	20012dac 	.word	0x20012dac

0801f4f8 <finsh_block_insert>:

/**
 * insert a block to list
 */
void finsh_block_insert(struct finsh_block_header** list, struct finsh_block_header* header)
{
 801f4f8:	b480      	push	{r7}
 801f4fa:	b085      	sub	sp, #20
 801f4fc:	af00      	add	r7, sp, #0
 801f4fe:	6078      	str	r0, [r7, #4]
 801f500:	6039      	str	r1, [r7, #0]
    struct finsh_block_header* node;

    if (*list == NULL)
 801f502:	687b      	ldr	r3, [r7, #4]
 801f504:	681b      	ldr	r3, [r3, #0]
 801f506:	2b00      	cmp	r3, #0
 801f508:	d103      	bne.n	801f512 <finsh_block_insert+0x1a>
    {
        *list = header;
 801f50a:	687b      	ldr	r3, [r7, #4]
 801f50c:	683a      	ldr	r2, [r7, #0]
 801f50e:	601a      	str	r2, [r3, #0]
        return;
 801f510:	e02d      	b.n	801f56e <finsh_block_insert+0x76>
    }

    /* find out insert point */
	node = *list;
 801f512:	687b      	ldr	r3, [r7, #4]
 801f514:	681b      	ldr	r3, [r3, #0]
 801f516:	60fb      	str	r3, [r7, #12]

	if (node > header)
 801f518:	68fa      	ldr	r2, [r7, #12]
 801f51a:	683b      	ldr	r3, [r7, #0]
 801f51c:	429a      	cmp	r2, r3
 801f51e:	d906      	bls.n	801f52e <finsh_block_insert+0x36>
	{
		/* insert node in the header of list */
		header->next = node;
 801f520:	683b      	ldr	r3, [r7, #0]
 801f522:	68fa      	ldr	r2, [r7, #12]
 801f524:	605a      	str	r2, [r3, #4]
		*list = header;
 801f526:	687b      	ldr	r3, [r7, #4]
 801f528:	683a      	ldr	r2, [r7, #0]
 801f52a:	601a      	str	r2, [r3, #0]

		return;
 801f52c:	e01f      	b.n	801f56e <finsh_block_insert+0x76>
	}
	else
	{
		for (node = *list; node; node = node->next)
 801f52e:	687b      	ldr	r3, [r7, #4]
 801f530:	681b      	ldr	r3, [r3, #0]
 801f532:	60fb      	str	r3, [r7, #12]
 801f534:	e00d      	b.n	801f552 <finsh_block_insert+0x5a>
		{
    		if (node->next > header) break;
 801f536:	68fb      	ldr	r3, [r7, #12]
 801f538:	685a      	ldr	r2, [r3, #4]
 801f53a:	683b      	ldr	r3, [r7, #0]
 801f53c:	429a      	cmp	r2, r3
 801f53e:	d900      	bls.n	801f542 <finsh_block_insert+0x4a>
 801f540:	e00a      	b.n	801f558 <finsh_block_insert+0x60>

    		if (node->next == NULL) break;
 801f542:	68fb      	ldr	r3, [r7, #12]
 801f544:	685b      	ldr	r3, [r3, #4]
 801f546:	2b00      	cmp	r3, #0
 801f548:	d100      	bne.n	801f54c <finsh_block_insert+0x54>
 801f54a:	e005      	b.n	801f558 <finsh_block_insert+0x60>

		return;
	}
	else
	{
		for (node = *list; node; node = node->next)
 801f54c:	68fb      	ldr	r3, [r7, #12]
 801f54e:	685b      	ldr	r3, [r3, #4]
 801f550:	60fb      	str	r3, [r7, #12]
 801f552:	68fb      	ldr	r3, [r7, #12]
 801f554:	2b00      	cmp	r3, #0
 801f556:	d1ee      	bne.n	801f536 <finsh_block_insert+0x3e>
    		if (node->next == NULL) break;
		}
	}

    /* insert node */
    if (node->next != NULL) header->next = node->next;
 801f558:	68fb      	ldr	r3, [r7, #12]
 801f55a:	685b      	ldr	r3, [r3, #4]
 801f55c:	2b00      	cmp	r3, #0
 801f55e:	d003      	beq.n	801f568 <finsh_block_insert+0x70>
 801f560:	68fb      	ldr	r3, [r7, #12]
 801f562:	685a      	ldr	r2, [r3, #4]
 801f564:	683b      	ldr	r3, [r7, #0]
 801f566:	605a      	str	r2, [r3, #4]
    node->next      = header;
 801f568:	68fb      	ldr	r3, [r7, #12]
 801f56a:	683a      	ldr	r2, [r7, #0]
 801f56c:	605a      	str	r2, [r3, #4]
}
 801f56e:	3714      	adds	r7, #20
 801f570:	46bd      	mov	sp, r7
 801f572:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f576:	4770      	bx	lr

0801f578 <finsh_block_remove>:

/**
 * remove block from list
 */
void finsh_block_remove(struct finsh_block_header** list, struct finsh_block_header* header)
{
 801f578:	b480      	push	{r7}
 801f57a:	b085      	sub	sp, #20
 801f57c:	af00      	add	r7, sp, #0
 801f57e:	6078      	str	r0, [r7, #4]
 801f580:	6039      	str	r1, [r7, #0]
    struct finsh_block_header* node;

    node = *list;
 801f582:	687b      	ldr	r3, [r7, #4]
 801f584:	681b      	ldr	r3, [r3, #0]
 801f586:	60fb      	str	r3, [r7, #12]
    if (node == header)
 801f588:	68fa      	ldr	r2, [r7, #12]
 801f58a:	683b      	ldr	r3, [r7, #0]
 801f58c:	429a      	cmp	r2, r3
 801f58e:	d107      	bne.n	801f5a0 <finsh_block_remove+0x28>
    {
        /* remove list header */
        *list = header->next;
 801f590:	683b      	ldr	r3, [r7, #0]
 801f592:	685a      	ldr	r2, [r3, #4]
 801f594:	687b      	ldr	r3, [r7, #4]
 801f596:	601a      	str	r2, [r3, #0]
        header->next = NULL;
 801f598:	683b      	ldr	r3, [r7, #0]
 801f59a:	2200      	movs	r2, #0
 801f59c:	605a      	str	r2, [r3, #4]

        return;
 801f59e:	e013      	b.n	801f5c8 <finsh_block_remove+0x50>
    }

    for (node = *list; node != NULL; node = node->next)
 801f5a0:	687b      	ldr	r3, [r7, #4]
 801f5a2:	681b      	ldr	r3, [r3, #0]
 801f5a4:	60fb      	str	r3, [r7, #12]
 801f5a6:	e00c      	b.n	801f5c2 <finsh_block_remove+0x4a>
    {
        if (node->next == header)
 801f5a8:	68fb      	ldr	r3, [r7, #12]
 801f5aa:	685a      	ldr	r2, [r3, #4]
 801f5ac:	683b      	ldr	r3, [r7, #0]
 801f5ae:	429a      	cmp	r2, r3
 801f5b0:	d104      	bne.n	801f5bc <finsh_block_remove+0x44>
        {
            node->next = header->next;
 801f5b2:	683b      	ldr	r3, [r7, #0]
 801f5b4:	685a      	ldr	r2, [r3, #4]
 801f5b6:	68fb      	ldr	r3, [r7, #12]
 801f5b8:	605a      	str	r2, [r3, #4]
            break;
 801f5ba:	e005      	b.n	801f5c8 <finsh_block_remove+0x50>
        header->next = NULL;

        return;
    }

    for (node = *list; node != NULL; node = node->next)
 801f5bc:	68fb      	ldr	r3, [r7, #12]
 801f5be:	685b      	ldr	r3, [r3, #4]
 801f5c0:	60fb      	str	r3, [r7, #12]
 801f5c2:	68fb      	ldr	r3, [r7, #12]
 801f5c4:	2b00      	cmp	r3, #0
 801f5c6:	d1ef      	bne.n	801f5a8 <finsh_block_remove+0x30>
        {
            node->next = header->next;
            break;
        }
    }
}
 801f5c8:	3714      	adds	r7, #20
 801f5ca:	46bd      	mov	sp, r7
 801f5cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f5d0:	4770      	bx	lr
 801f5d2:	bf00      	nop

0801f5d4 <finsh_block_split>:

/**
 * split block
 */
void finsh_block_split(struct finsh_block_header* header, size_t size)
{
 801f5d4:	b480      	push	{r7}
 801f5d6:	b085      	sub	sp, #20
 801f5d8:	af00      	add	r7, sp, #0
 801f5da:	6078      	str	r0, [r7, #4]
 801f5dc:	6039      	str	r1, [r7, #0]

    /*
     * split header into two node:
     * header->next->...
     */
    next = BLOCK_HEADER((u_char*)header + sizeof(struct finsh_block_header) + size);
 801f5de:	683b      	ldr	r3, [r7, #0]
 801f5e0:	3308      	adds	r3, #8
 801f5e2:	687a      	ldr	r2, [r7, #4]
 801f5e4:	4413      	add	r3, r2
 801f5e6:	60fb      	str	r3, [r7, #12]
    next->length = header->length - sizeof(struct finsh_block_header) - size;
 801f5e8:	687b      	ldr	r3, [r7, #4]
 801f5ea:	681a      	ldr	r2, [r3, #0]
 801f5ec:	683b      	ldr	r3, [r7, #0]
 801f5ee:	1ad3      	subs	r3, r2, r3
 801f5f0:	f1a3 0208 	sub.w	r2, r3, #8
 801f5f4:	68fb      	ldr	r3, [r7, #12]
 801f5f6:	601a      	str	r2, [r3, #0]
    header->length = size;
 801f5f8:	687b      	ldr	r3, [r7, #4]
 801f5fa:	683a      	ldr	r2, [r7, #0]
 801f5fc:	601a      	str	r2, [r3, #0]
    next->next = header->next;
 801f5fe:	687b      	ldr	r3, [r7, #4]
 801f600:	685a      	ldr	r2, [r3, #4]
 801f602:	68fb      	ldr	r3, [r7, #12]
 801f604:	605a      	str	r2, [r3, #4]

    header->next = next;
 801f606:	687b      	ldr	r3, [r7, #4]
 801f608:	68fa      	ldr	r2, [r7, #12]
 801f60a:	605a      	str	r2, [r3, #4]
}
 801f60c:	3714      	adds	r7, #20
 801f60e:	46bd      	mov	sp, r7
 801f610:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f614:	4770      	bx	lr
 801f616:	bf00      	nop

0801f618 <finsh_block_merge>:

void finsh_block_merge(struct finsh_block_header** list, struct finsh_block_header* header)
{
 801f618:	b480      	push	{r7}
 801f61a:	b085      	sub	sp, #20
 801f61c:	af00      	add	r7, sp, #0
 801f61e:	6078      	str	r0, [r7, #4]
 801f620:	6039      	str	r1, [r7, #0]
    struct finsh_block_header* prev_node;
    struct finsh_block_header* next_node;

    next_node = header->next;
 801f622:	683b      	ldr	r3, [r7, #0]
 801f624:	685b      	ldr	r3, [r3, #4]
 801f626:	60bb      	str	r3, [r7, #8]

    if (*list == header) prev_node = NULL;
 801f628:	687b      	ldr	r3, [r7, #4]
 801f62a:	681a      	ldr	r2, [r3, #0]
 801f62c:	683b      	ldr	r3, [r7, #0]
 801f62e:	429a      	cmp	r2, r3
 801f630:	d102      	bne.n	801f638 <finsh_block_merge+0x20>
 801f632:	2300      	movs	r3, #0
 801f634:	60fb      	str	r3, [r7, #12]
 801f636:	e00f      	b.n	801f658 <finsh_block_merge+0x40>
    else
    {
        /* find out the previous header */
        for (prev_node = *list; prev_node; prev_node =prev_node->next)
 801f638:	687b      	ldr	r3, [r7, #4]
 801f63a:	681b      	ldr	r3, [r3, #0]
 801f63c:	60fb      	str	r3, [r7, #12]
 801f63e:	e008      	b.n	801f652 <finsh_block_merge+0x3a>
        {
            if (prev_node->next == header)
 801f640:	68fb      	ldr	r3, [r7, #12]
 801f642:	685a      	ldr	r2, [r3, #4]
 801f644:	683b      	ldr	r3, [r7, #0]
 801f646:	429a      	cmp	r2, r3
 801f648:	d100      	bne.n	801f64c <finsh_block_merge+0x34>
                break;
 801f64a:	e005      	b.n	801f658 <finsh_block_merge+0x40>

    if (*list == header) prev_node = NULL;
    else
    {
        /* find out the previous header */
        for (prev_node = *list; prev_node; prev_node =prev_node->next)
 801f64c:	68fb      	ldr	r3, [r7, #12]
 801f64e:	685b      	ldr	r3, [r3, #4]
 801f650:	60fb      	str	r3, [r7, #12]
 801f652:	68fb      	ldr	r3, [r7, #12]
 801f654:	2b00      	cmp	r3, #0
 801f656:	d1f3      	bne.n	801f640 <finsh_block_merge+0x28>
    }

    /* try merge node */

    /* merge to previous node */
    if (prev_node != NULL &&
 801f658:	68fb      	ldr	r3, [r7, #12]
 801f65a:	2b00      	cmp	r3, #0
 801f65c:	d031      	beq.n	801f6c2 <finsh_block_merge+0xaa>
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
 801f65e:	68fb      	ldr	r3, [r7, #12]
 801f660:	681b      	ldr	r3, [r3, #0]
 801f662:	3308      	adds	r3, #8
 801f664:	68fa      	ldr	r2, [r7, #12]
 801f666:	441a      	add	r2, r3
    }

    /* try merge node */

    /* merge to previous node */
    if (prev_node != NULL &&
 801f668:	683b      	ldr	r3, [r7, #0]
 801f66a:	429a      	cmp	r2, r3
 801f66c:	d129      	bne.n	801f6c2 <finsh_block_merge+0xaa>
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
 801f66e:	68bb      	ldr	r3, [r7, #8]
 801f670:	2b00      	cmp	r3, #0
 801f672:	d018      	beq.n	801f6a6 <finsh_block_merge+0x8e>
            ((u_char*)header + header->length + sizeof(struct finsh_block_header)
 801f674:	683b      	ldr	r3, [r7, #0]
 801f676:	681b      	ldr	r3, [r3, #0]
 801f678:	3308      	adds	r3, #8
 801f67a:	683a      	ldr	r2, [r7, #0]
 801f67c:	441a      	add	r2, r3
    if (prev_node != NULL &&
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
 801f67e:	68bb      	ldr	r3, [r7, #8]
 801f680:	429a      	cmp	r2, r3
 801f682:	d110      	bne.n	801f6a6 <finsh_block_merge+0x8e>
            ((u_char*)header + header->length + sizeof(struct finsh_block_header)
            == (u_char*)next_node))
        {
            /* merge three node */
        	prev_node->length += header->length + next_node->length +
 801f684:	68fb      	ldr	r3, [r7, #12]
 801f686:	681a      	ldr	r2, [r3, #0]
 801f688:	683b      	ldr	r3, [r7, #0]
 801f68a:	6819      	ldr	r1, [r3, #0]
 801f68c:	68bb      	ldr	r3, [r7, #8]
 801f68e:	681b      	ldr	r3, [r3, #0]
 801f690:	440b      	add	r3, r1
 801f692:	4413      	add	r3, r2
 801f694:	f103 0210 	add.w	r2, r3, #16
 801f698:	68fb      	ldr	r3, [r7, #12]
 801f69a:	601a      	str	r2, [r3, #0]
                2 * sizeof(struct finsh_block_header);

            prev_node->next = next_node->next;
 801f69c:	68bb      	ldr	r3, [r7, #8]
 801f69e:	685a      	ldr	r2, [r3, #4]
 801f6a0:	68fb      	ldr	r3, [r7, #12]
 801f6a2:	605a      	str	r2, [r3, #4]
    if (prev_node != NULL &&
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
 801f6a4:	e025      	b.n	801f6f2 <finsh_block_merge+0xda>

            prev_node->next = next_node->next;
        }
        else
        {
            prev_node->length += header->length + sizeof(struct finsh_block_header);
 801f6a6:	68fb      	ldr	r3, [r7, #12]
 801f6a8:	681a      	ldr	r2, [r3, #0]
 801f6aa:	683b      	ldr	r3, [r7, #0]
 801f6ac:	681b      	ldr	r3, [r3, #0]
 801f6ae:	4413      	add	r3, r2
 801f6b0:	f103 0208 	add.w	r2, r3, #8
 801f6b4:	68fb      	ldr	r3, [r7, #12]
 801f6b6:	601a      	str	r2, [r3, #0]
            prev_node->next = header->next;
 801f6b8:	683b      	ldr	r3, [r7, #0]
 801f6ba:	685a      	ldr	r2, [r3, #4]
 801f6bc:	68fb      	ldr	r3, [r7, #12]
 801f6be:	605a      	str	r2, [r3, #4]
    if (prev_node != NULL &&
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
 801f6c0:	e017      	b.n	801f6f2 <finsh_block_merge+0xda>
            prev_node->length += header->length + sizeof(struct finsh_block_header);
            prev_node->next = header->next;
        }
    }
    else /* merge to last node */
    if ( (next_node != NULL) &&
 801f6c2:	68bb      	ldr	r3, [r7, #8]
 801f6c4:	2b00      	cmp	r3, #0
 801f6c6:	d014      	beq.n	801f6f2 <finsh_block_merge+0xda>
        ((u_char*)header + header->length + sizeof(struct finsh_block_header)
 801f6c8:	683b      	ldr	r3, [r7, #0]
 801f6ca:	681b      	ldr	r3, [r3, #0]
 801f6cc:	3308      	adds	r3, #8
 801f6ce:	683a      	ldr	r2, [r7, #0]
 801f6d0:	441a      	add	r2, r3
            prev_node->length += header->length + sizeof(struct finsh_block_header);
            prev_node->next = header->next;
        }
    }
    else /* merge to last node */
    if ( (next_node != NULL) &&
 801f6d2:	68bb      	ldr	r3, [r7, #8]
 801f6d4:	429a      	cmp	r2, r3
 801f6d6:	d10c      	bne.n	801f6f2 <finsh_block_merge+0xda>
        ((u_char*)header + header->length + sizeof(struct finsh_block_header)
        == (u_char*)next_node))
    {
        header->length += next_node->length + sizeof(struct finsh_block_header);
 801f6d8:	683b      	ldr	r3, [r7, #0]
 801f6da:	681a      	ldr	r2, [r3, #0]
 801f6dc:	68bb      	ldr	r3, [r7, #8]
 801f6de:	681b      	ldr	r3, [r3, #0]
 801f6e0:	4413      	add	r3, r2
 801f6e2:	f103 0208 	add.w	r2, r3, #8
 801f6e6:	683b      	ldr	r3, [r7, #0]
 801f6e8:	601a      	str	r2, [r3, #0]
        header->next = next_node->next;
 801f6ea:	68bb      	ldr	r3, [r7, #8]
 801f6ec:	685a      	ldr	r2, [r3, #4]
 801f6ee:	683b      	ldr	r3, [r7, #0]
 801f6f0:	605a      	str	r2, [r3, #4]
    }
}
 801f6f2:	3714      	adds	r7, #20
 801f6f4:	46bd      	mov	sp, r7
 801f6f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f6fa:	4770      	bx	lr

0801f6fc <finsh_init>:
#include "finsh_var.h"
#include "finsh_error.h"
#include "finsh_heap.h"

int finsh_init(struct finsh_parser* parser)
{
 801f6fc:	b580      	push	{r7, lr}
 801f6fe:	b082      	sub	sp, #8
 801f700:	af00      	add	r7, sp, #0
 801f702:	6078      	str	r0, [r7, #4]
	finsh_parser_init(parser);
 801f704:	6878      	ldr	r0, [r7, #4]
 801f706:	f001 ffb1 	bl	802166c <finsh_parser_init>

	/* finsh init */
	finsh_node_init();
 801f70a:	f000 f827 	bl	801f75c <finsh_node_init>
	finsh_var_init();
 801f70e:	f001 ffbb 	bl	8021688 <finsh_var_init>
	finsh_error_init();
 801f712:	f7ff fde5 	bl	801f2e0 <finsh_error_init>
	finsh_heap_init();
 801f716:	f7ff fe21 	bl	801f35c <finsh_heap_init>

	return 0;
 801f71a:	2300      	movs	r3, #0
}
 801f71c:	4618      	mov	r0, r3
 801f71e:	3708      	adds	r7, #8
 801f720:	46bd      	mov	sp, r7
 801f722:	bd80      	pop	{r7, pc}

0801f724 <finsh_stack_bottom>:

long finsh_stack_bottom()
{
 801f724:	b480      	push	{r7}
 801f726:	af00      	add	r7, sp, #0
    return finsh_vm_stack[0].long_value;
 801f728:	4b03      	ldr	r3, [pc, #12]	; (801f738 <finsh_stack_bottom+0x14>)
 801f72a:	681b      	ldr	r3, [r3, #0]
}
 801f72c:	4618      	mov	r0, r3
 801f72e:	46bd      	mov	sp, r7
 801f730:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f734:	4770      	bx	lr
 801f736:	bf00      	nop
 801f738:	20012eec 	.word	0x20012eec

0801f73c <finsh_flush>:

int finsh_flush(struct finsh_parser* parser)
{
 801f73c:	b580      	push	{r7, lr}
 801f73e:	b082      	sub	sp, #8
 801f740:	af00      	add	r7, sp, #0
 801f742:	6078      	str	r0, [r7, #4]
	finsh_parser_init(parser);
 801f744:	6878      	ldr	r0, [r7, #4]
 801f746:	f001 ff91 	bl	802166c <finsh_parser_init>

	/* finsh init */
	finsh_node_init();
 801f74a:	f000 f807 	bl	801f75c <finsh_node_init>
	finsh_error_init();
 801f74e:	f7ff fdc7 	bl	801f2e0 <finsh_error_init>

	return 0;
 801f752:	2300      	movs	r3, #0
}
 801f754:	4618      	mov	r0, r3
 801f756:	3708      	adds	r7, #8
 801f758:	46bd      	mov	sp, r7
 801f75a:	bd80      	pop	{r7, pc}

0801f75c <finsh_node_init>:
#include "finsh_heap.h"

struct finsh_node global_node_table[FINSH_NODE_MAX];

int finsh_node_init()
{
 801f75c:	b580      	push	{r7, lr}
 801f75e:	af00      	add	r7, sp, #0
	memset(global_node_table, 0, sizeof(global_node_table));
 801f760:	4804      	ldr	r0, [pc, #16]	; (801f774 <finsh_node_init+0x18>)
 801f762:	2100      	movs	r1, #0
 801f764:	f44f 72a0 	mov.w	r2, #320	; 0x140
 801f768:	f002 ff88 	bl	802267c <memset>

	return 0;
 801f76c:	2300      	movs	r3, #0
}
 801f76e:	4618      	mov	r0, r3
 801f770:	bd80      	pop	{r7, pc}
 801f772:	bf00      	nop
 801f774:	20012c68 	.word	0x20012c68

0801f778 <finsh_node_allocate>:

struct finsh_node* finsh_node_allocate(u_char type)
{
 801f778:	b480      	push	{r7}
 801f77a:	b085      	sub	sp, #20
 801f77c:	af00      	add	r7, sp, #0
 801f77e:	4603      	mov	r3, r0
 801f780:	71fb      	strb	r3, [r7, #7]
	int i;

	/* find an empty entry */
	for (i = 0; i < FINSH_NODE_MAX; i ++)
 801f782:	2300      	movs	r3, #0
 801f784:	60fb      	str	r3, [r7, #12]
 801f786:	e00d      	b.n	801f7a4 <finsh_node_allocate+0x2c>
	{
		if (global_node_table[i].node_type == FINSH_NODE_UNKNOWN) break;
 801f788:	4915      	ldr	r1, [pc, #84]	; (801f7e0 <finsh_node_allocate+0x68>)
 801f78a:	68fa      	ldr	r2, [r7, #12]
 801f78c:	4613      	mov	r3, r2
 801f78e:	009b      	lsls	r3, r3, #2
 801f790:	4413      	add	r3, r2
 801f792:	009b      	lsls	r3, r3, #2
 801f794:	440b      	add	r3, r1
 801f796:	781b      	ldrb	r3, [r3, #0]
 801f798:	2b00      	cmp	r3, #0
 801f79a:	d100      	bne.n	801f79e <finsh_node_allocate+0x26>
 801f79c:	e005      	b.n	801f7aa <finsh_node_allocate+0x32>
struct finsh_node* finsh_node_allocate(u_char type)
{
	int i;

	/* find an empty entry */
	for (i = 0; i < FINSH_NODE_MAX; i ++)
 801f79e:	68fb      	ldr	r3, [r7, #12]
 801f7a0:	3301      	adds	r3, #1
 801f7a2:	60fb      	str	r3, [r7, #12]
 801f7a4:	68fb      	ldr	r3, [r7, #12]
 801f7a6:	2b0f      	cmp	r3, #15
 801f7a8:	ddee      	ble.n	801f788 <finsh_node_allocate+0x10>
	{
		if (global_node_table[i].node_type == FINSH_NODE_UNKNOWN) break;
	}

	if (i == FINSH_NODE_MAX) return NULL;
 801f7aa:	68fb      	ldr	r3, [r7, #12]
 801f7ac:	2b10      	cmp	r3, #16
 801f7ae:	d101      	bne.n	801f7b4 <finsh_node_allocate+0x3c>
 801f7b0:	2300      	movs	r3, #0
 801f7b2:	e00f      	b.n	801f7d4 <finsh_node_allocate+0x5c>

	/* fill type field */
	global_node_table[i].node_type = type;
 801f7b4:	490a      	ldr	r1, [pc, #40]	; (801f7e0 <finsh_node_allocate+0x68>)
 801f7b6:	68fa      	ldr	r2, [r7, #12]
 801f7b8:	4613      	mov	r3, r2
 801f7ba:	009b      	lsls	r3, r3, #2
 801f7bc:	4413      	add	r3, r2
 801f7be:	009b      	lsls	r3, r3, #2
 801f7c0:	440b      	add	r3, r1
 801f7c2:	79fa      	ldrb	r2, [r7, #7]
 801f7c4:	701a      	strb	r2, [r3, #0]

	/* return this allocated node */
	return &global_node_table[i];
 801f7c6:	68fa      	ldr	r2, [r7, #12]
 801f7c8:	4613      	mov	r3, r2
 801f7ca:	009b      	lsls	r3, r3, #2
 801f7cc:	4413      	add	r3, r2
 801f7ce:	009b      	lsls	r3, r3, #2
 801f7d0:	4a03      	ldr	r2, [pc, #12]	; (801f7e0 <finsh_node_allocate+0x68>)
 801f7d2:	4413      	add	r3, r2
}
 801f7d4:	4618      	mov	r0, r3
 801f7d6:	3714      	adds	r7, #20
 801f7d8:	46bd      	mov	sp, r7
 801f7da:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f7de:	4770      	bx	lr
 801f7e0:	20012c68 	.word	0x20012c68

0801f7e4 <finsh_node_new_id>:

struct finsh_node* finsh_node_new_id(char* id)
{
 801f7e4:	b580      	push	{r7, lr}
 801f7e6:	b086      	sub	sp, #24
 801f7e8:	af00      	add	r7, sp, #0
 801f7ea:	6078      	str	r0, [r7, #4]
	struct finsh_node* node;
	void*  symbol;
	unsigned char type;

	symbol	= NULL;
 801f7ec:	2300      	movs	r3, #0
 801f7ee:	613b      	str	r3, [r7, #16]
	type	= 0;
 801f7f0:	2300      	movs	r3, #0
 801f7f2:	73fb      	strb	r3, [r7, #15]
	node	= NULL;
 801f7f4:	2300      	movs	r3, #0
 801f7f6:	617b      	str	r3, [r7, #20]

	/* lookup variable firstly */
	symbol = (void*)finsh_var_lookup(id);
 801f7f8:	6878      	ldr	r0, [r7, #4]
 801f7fa:	f001 ffab 	bl	8021754 <finsh_var_lookup>
 801f7fe:	6138      	str	r0, [r7, #16]
	if (symbol == NULL)
 801f800:	693b      	ldr	r3, [r7, #16]
 801f802:	2b00      	cmp	r3, #0
 801f804:	d113      	bne.n	801f82e <finsh_node_new_id+0x4a>
	{
		/* then lookup system variable */
		symbol = (void*)finsh_sysvar_lookup(id);
 801f806:	6878      	ldr	r0, [r7, #4]
 801f808:	f001 ffd4 	bl	80217b4 <finsh_sysvar_lookup>
 801f80c:	6138      	str	r0, [r7, #16]
		if (symbol == NULL)
 801f80e:	693b      	ldr	r3, [r7, #16]
 801f810:	2b00      	cmp	r3, #0
 801f812:	d109      	bne.n	801f828 <finsh_node_new_id+0x44>
		{
			/* then lookup system call */
			symbol = (void*)finsh_syscall_lookup(id);
 801f814:	6878      	ldr	r0, [r7, #4]
 801f816:	f002 f841 	bl	802189c <finsh_syscall_lookup>
 801f81a:	6138      	str	r0, [r7, #16]
			if (symbol != NULL) type = FINSH_IDTYPE_SYSCALL;
 801f81c:	693b      	ldr	r3, [r7, #16]
 801f81e:	2b00      	cmp	r3, #0
 801f820:	d007      	beq.n	801f832 <finsh_node_new_id+0x4e>
 801f822:	2304      	movs	r3, #4
 801f824:	73fb      	strb	r3, [r7, #15]
 801f826:	e004      	b.n	801f832 <finsh_node_new_id+0x4e>
		}
		else type = FINSH_IDTYPE_SYSVAR;
 801f828:	2302      	movs	r3, #2
 801f82a:	73fb      	strb	r3, [r7, #15]
 801f82c:	e001      	b.n	801f832 <finsh_node_new_id+0x4e>
	}
	else type = FINSH_IDTYPE_VAR;
 801f82e:	2301      	movs	r3, #1
 801f830:	73fb      	strb	r3, [r7, #15]

	if (symbol != NULL)
 801f832:	693b      	ldr	r3, [r7, #16]
 801f834:	2b00      	cmp	r3, #0
 801f836:	d022      	beq.n	801f87e <finsh_node_new_id+0x9a>
	{
		/* allocate a new node */
		node = finsh_node_allocate(FINSH_NODE_ID);
 801f838:	2001      	movs	r0, #1
 801f83a:	f7ff ff9d 	bl	801f778 <finsh_node_allocate>
 801f83e:	6178      	str	r0, [r7, #20]

		/* allocate node error */
		if (node == NULL)
 801f840:	697b      	ldr	r3, [r7, #20]
 801f842:	2b00      	cmp	r3, #0
 801f844:	d104      	bne.n	801f850 <finsh_node_new_id+0x6c>
		{
			finsh_error_set(FINSH_ERROR_MEMORY_FULL);
 801f846:	2006      	movs	r0, #6
 801f848:	f7ff fd58 	bl	801f2fc <finsh_error_set>
			return NULL;
 801f84c:	2300      	movs	r3, #0
 801f84e:	e01a      	b.n	801f886 <finsh_node_new_id+0xa2>
		}

		/* fill node value according type */
		switch (type)
 801f850:	7bfb      	ldrb	r3, [r7, #15]
 801f852:	2b02      	cmp	r3, #2
 801f854:	d007      	beq.n	801f866 <finsh_node_new_id+0x82>
 801f856:	2b04      	cmp	r3, #4
 801f858:	d009      	beq.n	801f86e <finsh_node_new_id+0x8a>
 801f85a:	2b01      	cmp	r3, #1
 801f85c:	d10b      	bne.n	801f876 <finsh_node_new_id+0x92>
		{
		case FINSH_IDTYPE_VAR:
			node->id.var = (struct finsh_var*)symbol;
 801f85e:	697b      	ldr	r3, [r7, #20]
 801f860:	693a      	ldr	r2, [r7, #16]
 801f862:	609a      	str	r2, [r3, #8]
			break;
 801f864:	e007      	b.n	801f876 <finsh_node_new_id+0x92>

		case FINSH_IDTYPE_SYSVAR:
			node->id.sysvar = (struct finsh_sysvar*)symbol;
 801f866:	697b      	ldr	r3, [r7, #20]
 801f868:	693a      	ldr	r2, [r7, #16]
 801f86a:	609a      	str	r2, [r3, #8]
			break;
 801f86c:	e003      	b.n	801f876 <finsh_node_new_id+0x92>

		case FINSH_IDTYPE_SYSCALL:
			node->id.syscall = (struct finsh_syscall*)symbol;
 801f86e:	697b      	ldr	r3, [r7, #20]
 801f870:	693a      	ldr	r2, [r7, #16]
 801f872:	609a      	str	r2, [r3, #8]
			break;
 801f874:	bf00      	nop
		}
		/* fill identifier type */
		node->idtype = type;
 801f876:	697b      	ldr	r3, [r7, #20]
 801f878:	7bfa      	ldrb	r2, [r7, #15]
 801f87a:	709a      	strb	r2, [r3, #2]
 801f87c:	e002      	b.n	801f884 <finsh_node_new_id+0xa0>
	}
	else finsh_error_set(FINSH_ERROR_UNKNOWN_SYMBOL);
 801f87e:	200d      	movs	r0, #13
 801f880:	f7ff fd3c 	bl	801f2fc <finsh_error_set>

	return node;
 801f884:	697b      	ldr	r3, [r7, #20]
}
 801f886:	4618      	mov	r0, r3
 801f888:	3718      	adds	r7, #24
 801f88a:	46bd      	mov	sp, r7
 801f88c:	bd80      	pop	{r7, pc}
 801f88e:	bf00      	nop

0801f890 <finsh_node_new_char>:

struct finsh_node* finsh_node_new_char(char c)
{
 801f890:	b580      	push	{r7, lr}
 801f892:	b084      	sub	sp, #16
 801f894:	af00      	add	r7, sp, #0
 801f896:	4603      	mov	r3, r0
 801f898:	71fb      	strb	r3, [r7, #7]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_CHAR);
 801f89a:	2002      	movs	r0, #2
 801f89c:	f7ff ff6c 	bl	801f778 <finsh_node_allocate>
 801f8a0:	60f8      	str	r0, [r7, #12]
	if (node == NULL)
 801f8a2:	68fb      	ldr	r3, [r7, #12]
 801f8a4:	2b00      	cmp	r3, #0
 801f8a6:	d104      	bne.n	801f8b2 <finsh_node_new_char+0x22>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
 801f8a8:	2006      	movs	r0, #6
 801f8aa:	f7ff fd27 	bl	801f2fc <finsh_error_set>
		return NULL;
 801f8ae:	2300      	movs	r3, #0
 801f8b0:	e003      	b.n	801f8ba <finsh_node_new_char+0x2a>
	}

	node->value.char_value = c;
 801f8b2:	68fb      	ldr	r3, [r7, #12]
 801f8b4:	79fa      	ldrb	r2, [r7, #7]
 801f8b6:	711a      	strb	r2, [r3, #4]
	return node;
 801f8b8:	68fb      	ldr	r3, [r7, #12]
}
 801f8ba:	4618      	mov	r0, r3
 801f8bc:	3710      	adds	r7, #16
 801f8be:	46bd      	mov	sp, r7
 801f8c0:	bd80      	pop	{r7, pc}
 801f8c2:	bf00      	nop

0801f8c4 <finsh_node_new_int>:

struct finsh_node* finsh_node_new_int(int i)
{
 801f8c4:	b580      	push	{r7, lr}
 801f8c6:	b084      	sub	sp, #16
 801f8c8:	af00      	add	r7, sp, #0
 801f8ca:	6078      	str	r0, [r7, #4]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_INT);
 801f8cc:	2003      	movs	r0, #3
 801f8ce:	f7ff ff53 	bl	801f778 <finsh_node_allocate>
 801f8d2:	60f8      	str	r0, [r7, #12]
	if (node == NULL)
 801f8d4:	68fb      	ldr	r3, [r7, #12]
 801f8d6:	2b00      	cmp	r3, #0
 801f8d8:	d104      	bne.n	801f8e4 <finsh_node_new_int+0x20>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
 801f8da:	2006      	movs	r0, #6
 801f8dc:	f7ff fd0e 	bl	801f2fc <finsh_error_set>
		return NULL;
 801f8e0:	2300      	movs	r3, #0
 801f8e2:	e003      	b.n	801f8ec <finsh_node_new_int+0x28>
	}

	node->value.int_value = i;
 801f8e4:	68fb      	ldr	r3, [r7, #12]
 801f8e6:	687a      	ldr	r2, [r7, #4]
 801f8e8:	605a      	str	r2, [r3, #4]
	return node;
 801f8ea:	68fb      	ldr	r3, [r7, #12]
}
 801f8ec:	4618      	mov	r0, r3
 801f8ee:	3710      	adds	r7, #16
 801f8f0:	46bd      	mov	sp, r7
 801f8f2:	bd80      	pop	{r7, pc}

0801f8f4 <finsh_node_new_long>:

struct finsh_node* finsh_node_new_long(long l)
{
 801f8f4:	b580      	push	{r7, lr}
 801f8f6:	b084      	sub	sp, #16
 801f8f8:	af00      	add	r7, sp, #0
 801f8fa:	6078      	str	r0, [r7, #4]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_LONG);
 801f8fc:	2004      	movs	r0, #4
 801f8fe:	f7ff ff3b 	bl	801f778 <finsh_node_allocate>
 801f902:	60f8      	str	r0, [r7, #12]
	if (node == NULL)
 801f904:	68fb      	ldr	r3, [r7, #12]
 801f906:	2b00      	cmp	r3, #0
 801f908:	d104      	bne.n	801f914 <finsh_node_new_long+0x20>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
 801f90a:	2006      	movs	r0, #6
 801f90c:	f7ff fcf6 	bl	801f2fc <finsh_error_set>
		return NULL;
 801f910:	2300      	movs	r3, #0
 801f912:	e003      	b.n	801f91c <finsh_node_new_long+0x28>
	}

	node->value.long_value = l;
 801f914:	68fb      	ldr	r3, [r7, #12]
 801f916:	687a      	ldr	r2, [r7, #4]
 801f918:	605a      	str	r2, [r3, #4]
	return node;
 801f91a:	68fb      	ldr	r3, [r7, #12]
}
 801f91c:	4618      	mov	r0, r3
 801f91e:	3710      	adds	r7, #16
 801f920:	46bd      	mov	sp, r7
 801f922:	bd80      	pop	{r7, pc}

0801f924 <finsh_node_new_string>:

struct finsh_node* finsh_node_new_string(char* s)
{
 801f924:	b590      	push	{r4, r7, lr}
 801f926:	b085      	sub	sp, #20
 801f928:	af00      	add	r7, sp, #0
 801f92a:	6078      	str	r0, [r7, #4]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_STRING);
 801f92c:	2005      	movs	r0, #5
 801f92e:	f7ff ff23 	bl	801f778 <finsh_node_allocate>
 801f932:	60f8      	str	r0, [r7, #12]
	if (node == NULL)
 801f934:	68fb      	ldr	r3, [r7, #12]
 801f936:	2b00      	cmp	r3, #0
 801f938:	d104      	bne.n	801f944 <finsh_node_new_string+0x20>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
 801f93a:	2006      	movs	r0, #6
 801f93c:	f7ff fcde 	bl	801f2fc <finsh_error_set>
		return NULL;
 801f940:	2300      	movs	r3, #0
 801f942:	e01f      	b.n	801f984 <finsh_node_new_string+0x60>
	}

	/* make string */
	node->value.ptr = finsh_heap_allocate(strlen(s) + 1);
 801f944:	6878      	ldr	r0, [r7, #4]
 801f946:	f003 fb2b 	bl	8022fa0 <strlen>
 801f94a:	4603      	mov	r3, r0
 801f94c:	3301      	adds	r3, #1
 801f94e:	4618      	mov	r0, r3
 801f950:	f7ff fd22 	bl	801f398 <finsh_heap_allocate>
 801f954:	4602      	mov	r2, r0
 801f956:	68fb      	ldr	r3, [r7, #12]
 801f958:	605a      	str	r2, [r3, #4]
	strncpy(node->value.ptr, s, strlen(s));
 801f95a:	68fb      	ldr	r3, [r7, #12]
 801f95c:	685c      	ldr	r4, [r3, #4]
 801f95e:	6878      	ldr	r0, [r7, #4]
 801f960:	f003 fb1e 	bl	8022fa0 <strlen>
 801f964:	4603      	mov	r3, r0
 801f966:	4620      	mov	r0, r4
 801f968:	6879      	ldr	r1, [r7, #4]
 801f96a:	461a      	mov	r2, r3
 801f96c:	f003 fb92 	bl	8023094 <strncpy>
	((u_char*)node->value.ptr)[strlen(s)] = '\0';
 801f970:	68fb      	ldr	r3, [r7, #12]
 801f972:	685c      	ldr	r4, [r3, #4]
 801f974:	6878      	ldr	r0, [r7, #4]
 801f976:	f003 fb13 	bl	8022fa0 <strlen>
 801f97a:	4603      	mov	r3, r0
 801f97c:	4423      	add	r3, r4
 801f97e:	2200      	movs	r2, #0
 801f980:	701a      	strb	r2, [r3, #0]

	return node;
 801f982:	68fb      	ldr	r3, [r7, #12]
}
 801f984:	4618      	mov	r0, r3
 801f986:	3714      	adds	r7, #20
 801f988:	46bd      	mov	sp, r7
 801f98a:	bd90      	pop	{r4, r7, pc}

0801f98c <finsh_node_new_ptr>:

struct finsh_node* finsh_node_new_ptr(void* ptr)
{
 801f98c:	b580      	push	{r7, lr}
 801f98e:	b084      	sub	sp, #16
 801f990:	af00      	add	r7, sp, #0
 801f992:	6078      	str	r0, [r7, #4]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_NULL);
 801f994:	2006      	movs	r0, #6
 801f996:	f7ff feef 	bl	801f778 <finsh_node_allocate>
 801f99a:	60f8      	str	r0, [r7, #12]
	if (node == NULL)
 801f99c:	68fb      	ldr	r3, [r7, #12]
 801f99e:	2b00      	cmp	r3, #0
 801f9a0:	d104      	bne.n	801f9ac <finsh_node_new_ptr+0x20>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
 801f9a2:	2006      	movs	r0, #6
 801f9a4:	f7ff fcaa 	bl	801f2fc <finsh_error_set>
		return NULL;
 801f9a8:	2300      	movs	r3, #0
 801f9aa:	e003      	b.n	801f9b4 <finsh_node_new_ptr+0x28>
	}

	node->value.ptr = ptr;
 801f9ac:	68fb      	ldr	r3, [r7, #12]
 801f9ae:	687a      	ldr	r2, [r7, #4]
 801f9b0:	605a      	str	r2, [r3, #4]
	return node;
 801f9b2:	68fb      	ldr	r3, [r7, #12]
}
 801f9b4:	4618      	mov	r0, r3
 801f9b6:	3710      	adds	r7, #16
 801f9b8:	46bd      	mov	sp, r7
 801f9ba:	bd80      	pop	{r7, pc}

0801f9bc <OP_no_op>:
        finsh_sp--; \
    }while (0)

/* --- noop --- */
void OP_no_op()
{
 801f9bc:	b480      	push	{r7}
 801f9be:	af00      	add	r7, sp, #0
	/* none */
	return ;
 801f9c0:	bf00      	nop
}
 801f9c2:	46bd      	mov	sp, r7
 801f9c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f9c8:	4770      	bx	lr
 801f9ca:	bf00      	nop

0801f9cc <OP_add_byte>:

/* --- add --- */
void OP_add_byte()
{
 801f9cc:	b480      	push	{r7}
 801f9ce:	af00      	add	r7, sp, #0
    OP_BIN_BYTE(+);
 801f9d0:	4b0b      	ldr	r3, [pc, #44]	; (801fa00 <OP_add_byte+0x34>)
 801f9d2:	681b      	ldr	r3, [r3, #0]
 801f9d4:	3b08      	subs	r3, #8
 801f9d6:	4a0a      	ldr	r2, [pc, #40]	; (801fa00 <OP_add_byte+0x34>)
 801f9d8:	6812      	ldr	r2, [r2, #0]
 801f9da:	3a08      	subs	r2, #8
 801f9dc:	7811      	ldrb	r1, [r2, #0]
 801f9de:	4a08      	ldr	r2, [pc, #32]	; (801fa00 <OP_add_byte+0x34>)
 801f9e0:	6812      	ldr	r2, [r2, #0]
 801f9e2:	3a04      	subs	r2, #4
 801f9e4:	7812      	ldrb	r2, [r2, #0]
 801f9e6:	440a      	add	r2, r1
 801f9e8:	b2d2      	uxtb	r2, r2
 801f9ea:	701a      	strb	r2, [r3, #0]
 801f9ec:	4b04      	ldr	r3, [pc, #16]	; (801fa00 <OP_add_byte+0x34>)
 801f9ee:	681b      	ldr	r3, [r3, #0]
 801f9f0:	3b04      	subs	r3, #4
 801f9f2:	4a03      	ldr	r2, [pc, #12]	; (801fa00 <OP_add_byte+0x34>)
 801f9f4:	6013      	str	r3, [r2, #0]

	return ;
 801f9f6:	bf00      	nop
}
 801f9f8:	46bd      	mov	sp, r7
 801f9fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f9fe:	4770      	bx	lr
 801fa00:	20012ff0 	.word	0x20012ff0

0801fa04 <OP_add_word>:

void OP_add_word()
{
 801fa04:	b480      	push	{r7}
 801fa06:	af00      	add	r7, sp, #0
    OP_BIN_WORD(+);
 801fa08:	4b0d      	ldr	r3, [pc, #52]	; (801fa40 <OP_add_word+0x3c>)
 801fa0a:	681b      	ldr	r3, [r3, #0]
 801fa0c:	3b08      	subs	r3, #8
 801fa0e:	4a0c      	ldr	r2, [pc, #48]	; (801fa40 <OP_add_word+0x3c>)
 801fa10:	6812      	ldr	r2, [r2, #0]
 801fa12:	3a08      	subs	r2, #8
 801fa14:	8812      	ldrh	r2, [r2, #0]
 801fa16:	b291      	uxth	r1, r2
 801fa18:	4a09      	ldr	r2, [pc, #36]	; (801fa40 <OP_add_word+0x3c>)
 801fa1a:	6812      	ldr	r2, [r2, #0]
 801fa1c:	3a04      	subs	r2, #4
 801fa1e:	8812      	ldrh	r2, [r2, #0]
 801fa20:	b292      	uxth	r2, r2
 801fa22:	440a      	add	r2, r1
 801fa24:	b292      	uxth	r2, r2
 801fa26:	b292      	uxth	r2, r2
 801fa28:	801a      	strh	r2, [r3, #0]
 801fa2a:	4b05      	ldr	r3, [pc, #20]	; (801fa40 <OP_add_word+0x3c>)
 801fa2c:	681b      	ldr	r3, [r3, #0]
 801fa2e:	3b04      	subs	r3, #4
 801fa30:	4a03      	ldr	r2, [pc, #12]	; (801fa40 <OP_add_word+0x3c>)
 801fa32:	6013      	str	r3, [r2, #0]

	return ;
 801fa34:	bf00      	nop
}
 801fa36:	46bd      	mov	sp, r7
 801fa38:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fa3c:	4770      	bx	lr
 801fa3e:	bf00      	nop
 801fa40:	20012ff0 	.word	0x20012ff0

0801fa44 <OP_add_dword>:

void OP_add_dword()
{
 801fa44:	b480      	push	{r7}
 801fa46:	af00      	add	r7, sp, #0
    OP_BIN_DWORD(+);
 801fa48:	4b0b      	ldr	r3, [pc, #44]	; (801fa78 <OP_add_dword+0x34>)
 801fa4a:	681b      	ldr	r3, [r3, #0]
 801fa4c:	3b08      	subs	r3, #8
 801fa4e:	4a0a      	ldr	r2, [pc, #40]	; (801fa78 <OP_add_dword+0x34>)
 801fa50:	6812      	ldr	r2, [r2, #0]
 801fa52:	3a08      	subs	r2, #8
 801fa54:	6811      	ldr	r1, [r2, #0]
 801fa56:	4a08      	ldr	r2, [pc, #32]	; (801fa78 <OP_add_dword+0x34>)
 801fa58:	6812      	ldr	r2, [r2, #0]
 801fa5a:	3a04      	subs	r2, #4
 801fa5c:	6812      	ldr	r2, [r2, #0]
 801fa5e:	440a      	add	r2, r1
 801fa60:	601a      	str	r2, [r3, #0]
 801fa62:	4b05      	ldr	r3, [pc, #20]	; (801fa78 <OP_add_dword+0x34>)
 801fa64:	681b      	ldr	r3, [r3, #0]
 801fa66:	3b04      	subs	r3, #4
 801fa68:	4a03      	ldr	r2, [pc, #12]	; (801fa78 <OP_add_dword+0x34>)
 801fa6a:	6013      	str	r3, [r2, #0]

	return ;
 801fa6c:	bf00      	nop
}
 801fa6e:	46bd      	mov	sp, r7
 801fa70:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fa74:	4770      	bx	lr
 801fa76:	bf00      	nop
 801fa78:	20012ff0 	.word	0x20012ff0

0801fa7c <OP_sub_byte>:

/* --- sub --- */
void OP_sub_byte()
{
 801fa7c:	b480      	push	{r7}
 801fa7e:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(-);
 801fa80:	4b0b      	ldr	r3, [pc, #44]	; (801fab0 <OP_sub_byte+0x34>)
 801fa82:	681b      	ldr	r3, [r3, #0]
 801fa84:	3b08      	subs	r3, #8
 801fa86:	4a0a      	ldr	r2, [pc, #40]	; (801fab0 <OP_sub_byte+0x34>)
 801fa88:	6812      	ldr	r2, [r2, #0]
 801fa8a:	3a08      	subs	r2, #8
 801fa8c:	7811      	ldrb	r1, [r2, #0]
 801fa8e:	4a08      	ldr	r2, [pc, #32]	; (801fab0 <OP_sub_byte+0x34>)
 801fa90:	6812      	ldr	r2, [r2, #0]
 801fa92:	3a04      	subs	r2, #4
 801fa94:	7812      	ldrb	r2, [r2, #0]
 801fa96:	1a8a      	subs	r2, r1, r2
 801fa98:	b2d2      	uxtb	r2, r2
 801fa9a:	701a      	strb	r2, [r3, #0]
 801fa9c:	4b04      	ldr	r3, [pc, #16]	; (801fab0 <OP_sub_byte+0x34>)
 801fa9e:	681b      	ldr	r3, [r3, #0]
 801faa0:	3b04      	subs	r3, #4
 801faa2:	4a03      	ldr	r2, [pc, #12]	; (801fab0 <OP_sub_byte+0x34>)
 801faa4:	6013      	str	r3, [r2, #0]

	return ;
 801faa6:	bf00      	nop
}
 801faa8:	46bd      	mov	sp, r7
 801faaa:	f85d 7b04 	ldr.w	r7, [sp], #4
 801faae:	4770      	bx	lr
 801fab0:	20012ff0 	.word	0x20012ff0

0801fab4 <OP_sub_word>:

void OP_sub_word()
{
 801fab4:	b480      	push	{r7}
 801fab6:	af00      	add	r7, sp, #0
	OP_BIN_WORD(-);
 801fab8:	4b0d      	ldr	r3, [pc, #52]	; (801faf0 <OP_sub_word+0x3c>)
 801faba:	681b      	ldr	r3, [r3, #0]
 801fabc:	3b08      	subs	r3, #8
 801fabe:	4a0c      	ldr	r2, [pc, #48]	; (801faf0 <OP_sub_word+0x3c>)
 801fac0:	6812      	ldr	r2, [r2, #0]
 801fac2:	3a08      	subs	r2, #8
 801fac4:	8812      	ldrh	r2, [r2, #0]
 801fac6:	b291      	uxth	r1, r2
 801fac8:	4a09      	ldr	r2, [pc, #36]	; (801faf0 <OP_sub_word+0x3c>)
 801faca:	6812      	ldr	r2, [r2, #0]
 801facc:	3a04      	subs	r2, #4
 801face:	8812      	ldrh	r2, [r2, #0]
 801fad0:	b292      	uxth	r2, r2
 801fad2:	1a8a      	subs	r2, r1, r2
 801fad4:	b292      	uxth	r2, r2
 801fad6:	b292      	uxth	r2, r2
 801fad8:	801a      	strh	r2, [r3, #0]
 801fada:	4b05      	ldr	r3, [pc, #20]	; (801faf0 <OP_sub_word+0x3c>)
 801fadc:	681b      	ldr	r3, [r3, #0]
 801fade:	3b04      	subs	r3, #4
 801fae0:	4a03      	ldr	r2, [pc, #12]	; (801faf0 <OP_sub_word+0x3c>)
 801fae2:	6013      	str	r3, [r2, #0]

	return ;
 801fae4:	bf00      	nop
}
 801fae6:	46bd      	mov	sp, r7
 801fae8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801faec:	4770      	bx	lr
 801faee:	bf00      	nop
 801faf0:	20012ff0 	.word	0x20012ff0

0801faf4 <OP_sub_dword>:

void OP_sub_dword()
{
 801faf4:	b480      	push	{r7}
 801faf6:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(-);
 801faf8:	4b0b      	ldr	r3, [pc, #44]	; (801fb28 <OP_sub_dword+0x34>)
 801fafa:	681b      	ldr	r3, [r3, #0]
 801fafc:	3b08      	subs	r3, #8
 801fafe:	4a0a      	ldr	r2, [pc, #40]	; (801fb28 <OP_sub_dword+0x34>)
 801fb00:	6812      	ldr	r2, [r2, #0]
 801fb02:	3a08      	subs	r2, #8
 801fb04:	6811      	ldr	r1, [r2, #0]
 801fb06:	4a08      	ldr	r2, [pc, #32]	; (801fb28 <OP_sub_dword+0x34>)
 801fb08:	6812      	ldr	r2, [r2, #0]
 801fb0a:	3a04      	subs	r2, #4
 801fb0c:	6812      	ldr	r2, [r2, #0]
 801fb0e:	1a8a      	subs	r2, r1, r2
 801fb10:	601a      	str	r2, [r3, #0]
 801fb12:	4b05      	ldr	r3, [pc, #20]	; (801fb28 <OP_sub_dword+0x34>)
 801fb14:	681b      	ldr	r3, [r3, #0]
 801fb16:	3b04      	subs	r3, #4
 801fb18:	4a03      	ldr	r2, [pc, #12]	; (801fb28 <OP_sub_dword+0x34>)
 801fb1a:	6013      	str	r3, [r2, #0]

	return ;
 801fb1c:	bf00      	nop
}
 801fb1e:	46bd      	mov	sp, r7
 801fb20:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fb24:	4770      	bx	lr
 801fb26:	bf00      	nop
 801fb28:	20012ff0 	.word	0x20012ff0

0801fb2c <OP_div_byte>:

/* --- div --- */
void OP_div_byte()
{
 801fb2c:	b480      	push	{r7}
 801fb2e:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(/);
 801fb30:	4b0c      	ldr	r3, [pc, #48]	; (801fb64 <OP_div_byte+0x38>)
 801fb32:	681b      	ldr	r3, [r3, #0]
 801fb34:	3b08      	subs	r3, #8
 801fb36:	4a0b      	ldr	r2, [pc, #44]	; (801fb64 <OP_div_byte+0x38>)
 801fb38:	6812      	ldr	r2, [r2, #0]
 801fb3a:	3a08      	subs	r2, #8
 801fb3c:	7811      	ldrb	r1, [r2, #0]
 801fb3e:	4a09      	ldr	r2, [pc, #36]	; (801fb64 <OP_div_byte+0x38>)
 801fb40:	6812      	ldr	r2, [r2, #0]
 801fb42:	3a04      	subs	r2, #4
 801fb44:	7812      	ldrb	r2, [r2, #0]
 801fb46:	fbb1 f2f2 	udiv	r2, r1, r2
 801fb4a:	b2d2      	uxtb	r2, r2
 801fb4c:	701a      	strb	r2, [r3, #0]
 801fb4e:	4b05      	ldr	r3, [pc, #20]	; (801fb64 <OP_div_byte+0x38>)
 801fb50:	681b      	ldr	r3, [r3, #0]
 801fb52:	3b04      	subs	r3, #4
 801fb54:	4a03      	ldr	r2, [pc, #12]	; (801fb64 <OP_div_byte+0x38>)
 801fb56:	6013      	str	r3, [r2, #0]

	return ;
 801fb58:	bf00      	nop
}
 801fb5a:	46bd      	mov	sp, r7
 801fb5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fb60:	4770      	bx	lr
 801fb62:	bf00      	nop
 801fb64:	20012ff0 	.word	0x20012ff0

0801fb68 <OP_div_word>:

void OP_div_word()
{
 801fb68:	b480      	push	{r7}
 801fb6a:	af00      	add	r7, sp, #0
	OP_BIN_WORD(/);
 801fb6c:	4b0d      	ldr	r3, [pc, #52]	; (801fba4 <OP_div_word+0x3c>)
 801fb6e:	681b      	ldr	r3, [r3, #0]
 801fb70:	3b08      	subs	r3, #8
 801fb72:	4a0c      	ldr	r2, [pc, #48]	; (801fba4 <OP_div_word+0x3c>)
 801fb74:	6812      	ldr	r2, [r2, #0]
 801fb76:	3a08      	subs	r2, #8
 801fb78:	8812      	ldrh	r2, [r2, #0]
 801fb7a:	b211      	sxth	r1, r2
 801fb7c:	4a09      	ldr	r2, [pc, #36]	; (801fba4 <OP_div_word+0x3c>)
 801fb7e:	6812      	ldr	r2, [r2, #0]
 801fb80:	3a04      	subs	r2, #4
 801fb82:	8812      	ldrh	r2, [r2, #0]
 801fb84:	b212      	sxth	r2, r2
 801fb86:	fb91 f2f2 	sdiv	r2, r1, r2
 801fb8a:	b292      	uxth	r2, r2
 801fb8c:	801a      	strh	r2, [r3, #0]
 801fb8e:	4b05      	ldr	r3, [pc, #20]	; (801fba4 <OP_div_word+0x3c>)
 801fb90:	681b      	ldr	r3, [r3, #0]
 801fb92:	3b04      	subs	r3, #4
 801fb94:	4a03      	ldr	r2, [pc, #12]	; (801fba4 <OP_div_word+0x3c>)
 801fb96:	6013      	str	r3, [r2, #0]

	return ;
 801fb98:	bf00      	nop
}
 801fb9a:	46bd      	mov	sp, r7
 801fb9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fba0:	4770      	bx	lr
 801fba2:	bf00      	nop
 801fba4:	20012ff0 	.word	0x20012ff0

0801fba8 <OP_div_dword>:

void OP_div_dword()
{
 801fba8:	b480      	push	{r7}
 801fbaa:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(/);
 801fbac:	4b0b      	ldr	r3, [pc, #44]	; (801fbdc <OP_div_dword+0x34>)
 801fbae:	681b      	ldr	r3, [r3, #0]
 801fbb0:	3b08      	subs	r3, #8
 801fbb2:	4a0a      	ldr	r2, [pc, #40]	; (801fbdc <OP_div_dword+0x34>)
 801fbb4:	6812      	ldr	r2, [r2, #0]
 801fbb6:	3a08      	subs	r2, #8
 801fbb8:	6811      	ldr	r1, [r2, #0]
 801fbba:	4a08      	ldr	r2, [pc, #32]	; (801fbdc <OP_div_dword+0x34>)
 801fbbc:	6812      	ldr	r2, [r2, #0]
 801fbbe:	3a04      	subs	r2, #4
 801fbc0:	6812      	ldr	r2, [r2, #0]
 801fbc2:	fb91 f2f2 	sdiv	r2, r1, r2
 801fbc6:	601a      	str	r2, [r3, #0]
 801fbc8:	4b04      	ldr	r3, [pc, #16]	; (801fbdc <OP_div_dword+0x34>)
 801fbca:	681b      	ldr	r3, [r3, #0]
 801fbcc:	3b04      	subs	r3, #4
 801fbce:	4a03      	ldr	r2, [pc, #12]	; (801fbdc <OP_div_dword+0x34>)
 801fbd0:	6013      	str	r3, [r2, #0]

	return ;
 801fbd2:	bf00      	nop
}
 801fbd4:	46bd      	mov	sp, r7
 801fbd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fbda:	4770      	bx	lr
 801fbdc:	20012ff0 	.word	0x20012ff0

0801fbe0 <OP_mod_byte>:

/* --- mod --- */
void OP_mod_byte()
{
 801fbe0:	b480      	push	{r7}
 801fbe2:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(%);
 801fbe4:	4b0e      	ldr	r3, [pc, #56]	; (801fc20 <OP_mod_byte+0x40>)
 801fbe6:	681b      	ldr	r3, [r3, #0]
 801fbe8:	f1a3 0108 	sub.w	r1, r3, #8
 801fbec:	4b0c      	ldr	r3, [pc, #48]	; (801fc20 <OP_mod_byte+0x40>)
 801fbee:	681b      	ldr	r3, [r3, #0]
 801fbf0:	3b08      	subs	r3, #8
 801fbf2:	781b      	ldrb	r3, [r3, #0]
 801fbf4:	4a0a      	ldr	r2, [pc, #40]	; (801fc20 <OP_mod_byte+0x40>)
 801fbf6:	6812      	ldr	r2, [r2, #0]
 801fbf8:	3a04      	subs	r2, #4
 801fbfa:	7812      	ldrb	r2, [r2, #0]
 801fbfc:	fbb3 f0f2 	udiv	r0, r3, r2
 801fc00:	fb02 f200 	mul.w	r2, r2, r0
 801fc04:	1a9b      	subs	r3, r3, r2
 801fc06:	b2db      	uxtb	r3, r3
 801fc08:	700b      	strb	r3, [r1, #0]
 801fc0a:	4b05      	ldr	r3, [pc, #20]	; (801fc20 <OP_mod_byte+0x40>)
 801fc0c:	681b      	ldr	r3, [r3, #0]
 801fc0e:	3b04      	subs	r3, #4
 801fc10:	4a03      	ldr	r2, [pc, #12]	; (801fc20 <OP_mod_byte+0x40>)
 801fc12:	6013      	str	r3, [r2, #0]

	return ;
 801fc14:	bf00      	nop
}
 801fc16:	46bd      	mov	sp, r7
 801fc18:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fc1c:	4770      	bx	lr
 801fc1e:	bf00      	nop
 801fc20:	20012ff0 	.word	0x20012ff0

0801fc24 <OP_mod_word>:

void OP_mod_word()
{
 801fc24:	b480      	push	{r7}
 801fc26:	af00      	add	r7, sp, #0
	OP_BIN_WORD(%);
 801fc28:	4b0f      	ldr	r3, [pc, #60]	; (801fc68 <OP_mod_word+0x44>)
 801fc2a:	681b      	ldr	r3, [r3, #0]
 801fc2c:	f1a3 0108 	sub.w	r1, r3, #8
 801fc30:	4b0d      	ldr	r3, [pc, #52]	; (801fc68 <OP_mod_word+0x44>)
 801fc32:	681b      	ldr	r3, [r3, #0]
 801fc34:	3b08      	subs	r3, #8
 801fc36:	881b      	ldrh	r3, [r3, #0]
 801fc38:	b21b      	sxth	r3, r3
 801fc3a:	4a0b      	ldr	r2, [pc, #44]	; (801fc68 <OP_mod_word+0x44>)
 801fc3c:	6812      	ldr	r2, [r2, #0]
 801fc3e:	3a04      	subs	r2, #4
 801fc40:	8812      	ldrh	r2, [r2, #0]
 801fc42:	b212      	sxth	r2, r2
 801fc44:	fb93 f0f2 	sdiv	r0, r3, r2
 801fc48:	fb02 f200 	mul.w	r2, r2, r0
 801fc4c:	1a9b      	subs	r3, r3, r2
 801fc4e:	b29b      	uxth	r3, r3
 801fc50:	800b      	strh	r3, [r1, #0]
 801fc52:	4b05      	ldr	r3, [pc, #20]	; (801fc68 <OP_mod_word+0x44>)
 801fc54:	681b      	ldr	r3, [r3, #0]
 801fc56:	3b04      	subs	r3, #4
 801fc58:	4a03      	ldr	r2, [pc, #12]	; (801fc68 <OP_mod_word+0x44>)
 801fc5a:	6013      	str	r3, [r2, #0]

	return ;
 801fc5c:	bf00      	nop
}
 801fc5e:	46bd      	mov	sp, r7
 801fc60:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fc64:	4770      	bx	lr
 801fc66:	bf00      	nop
 801fc68:	20012ff0 	.word	0x20012ff0

0801fc6c <OP_mod_dword>:

void OP_mod_dword()
{
 801fc6c:	b480      	push	{r7}
 801fc6e:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(%);
 801fc70:	4b0d      	ldr	r3, [pc, #52]	; (801fca8 <OP_mod_dword+0x3c>)
 801fc72:	681b      	ldr	r3, [r3, #0]
 801fc74:	f1a3 0108 	sub.w	r1, r3, #8
 801fc78:	4b0b      	ldr	r3, [pc, #44]	; (801fca8 <OP_mod_dword+0x3c>)
 801fc7a:	681b      	ldr	r3, [r3, #0]
 801fc7c:	3b08      	subs	r3, #8
 801fc7e:	681b      	ldr	r3, [r3, #0]
 801fc80:	4a09      	ldr	r2, [pc, #36]	; (801fca8 <OP_mod_dword+0x3c>)
 801fc82:	6812      	ldr	r2, [r2, #0]
 801fc84:	3a04      	subs	r2, #4
 801fc86:	6812      	ldr	r2, [r2, #0]
 801fc88:	fb93 f0f2 	sdiv	r0, r3, r2
 801fc8c:	fb02 f200 	mul.w	r2, r2, r0
 801fc90:	1a9b      	subs	r3, r3, r2
 801fc92:	600b      	str	r3, [r1, #0]
 801fc94:	4b04      	ldr	r3, [pc, #16]	; (801fca8 <OP_mod_dword+0x3c>)
 801fc96:	681b      	ldr	r3, [r3, #0]
 801fc98:	3b04      	subs	r3, #4
 801fc9a:	4a03      	ldr	r2, [pc, #12]	; (801fca8 <OP_mod_dword+0x3c>)
 801fc9c:	6013      	str	r3, [r2, #0]

	return ;
 801fc9e:	bf00      	nop
}
 801fca0:	46bd      	mov	sp, r7
 801fca2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fca6:	4770      	bx	lr
 801fca8:	20012ff0 	.word	0x20012ff0

0801fcac <OP_mul_byte>:

/* --- mul --- */
void OP_mul_byte()
{
 801fcac:	b480      	push	{r7}
 801fcae:	af00      	add	r7, sp, #0
    OP_BIN_BYTE(*);
 801fcb0:	4b0c      	ldr	r3, [pc, #48]	; (801fce4 <OP_mul_byte+0x38>)
 801fcb2:	681b      	ldr	r3, [r3, #0]
 801fcb4:	3b08      	subs	r3, #8
 801fcb6:	4a0b      	ldr	r2, [pc, #44]	; (801fce4 <OP_mul_byte+0x38>)
 801fcb8:	6812      	ldr	r2, [r2, #0]
 801fcba:	3a08      	subs	r2, #8
 801fcbc:	7811      	ldrb	r1, [r2, #0]
 801fcbe:	4a09      	ldr	r2, [pc, #36]	; (801fce4 <OP_mul_byte+0x38>)
 801fcc0:	6812      	ldr	r2, [r2, #0]
 801fcc2:	3a04      	subs	r2, #4
 801fcc4:	7812      	ldrb	r2, [r2, #0]
 801fcc6:	fb11 f202 	smulbb	r2, r1, r2
 801fcca:	b2d2      	uxtb	r2, r2
 801fccc:	701a      	strb	r2, [r3, #0]
 801fcce:	4b05      	ldr	r3, [pc, #20]	; (801fce4 <OP_mul_byte+0x38>)
 801fcd0:	681b      	ldr	r3, [r3, #0]
 801fcd2:	3b04      	subs	r3, #4
 801fcd4:	4a03      	ldr	r2, [pc, #12]	; (801fce4 <OP_mul_byte+0x38>)
 801fcd6:	6013      	str	r3, [r2, #0]

	return ;
 801fcd8:	bf00      	nop
}
 801fcda:	46bd      	mov	sp, r7
 801fcdc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fce0:	4770      	bx	lr
 801fce2:	bf00      	nop
 801fce4:	20012ff0 	.word	0x20012ff0

0801fce8 <OP_mul_word>:

void OP_mul_word()
{
 801fce8:	b480      	push	{r7}
 801fcea:	af00      	add	r7, sp, #0
	OP_BIN_WORD(*);
 801fcec:	4b0d      	ldr	r3, [pc, #52]	; (801fd24 <OP_mul_word+0x3c>)
 801fcee:	681b      	ldr	r3, [r3, #0]
 801fcf0:	3b08      	subs	r3, #8
 801fcf2:	4a0c      	ldr	r2, [pc, #48]	; (801fd24 <OP_mul_word+0x3c>)
 801fcf4:	6812      	ldr	r2, [r2, #0]
 801fcf6:	3a08      	subs	r2, #8
 801fcf8:	8812      	ldrh	r2, [r2, #0]
 801fcfa:	b291      	uxth	r1, r2
 801fcfc:	4a09      	ldr	r2, [pc, #36]	; (801fd24 <OP_mul_word+0x3c>)
 801fcfe:	6812      	ldr	r2, [r2, #0]
 801fd00:	3a04      	subs	r2, #4
 801fd02:	8812      	ldrh	r2, [r2, #0]
 801fd04:	b292      	uxth	r2, r2
 801fd06:	fb11 f202 	smulbb	r2, r1, r2
 801fd0a:	b292      	uxth	r2, r2
 801fd0c:	b292      	uxth	r2, r2
 801fd0e:	801a      	strh	r2, [r3, #0]
 801fd10:	4b04      	ldr	r3, [pc, #16]	; (801fd24 <OP_mul_word+0x3c>)
 801fd12:	681b      	ldr	r3, [r3, #0]
 801fd14:	3b04      	subs	r3, #4
 801fd16:	4a03      	ldr	r2, [pc, #12]	; (801fd24 <OP_mul_word+0x3c>)
 801fd18:	6013      	str	r3, [r2, #0]

	return ;
 801fd1a:	bf00      	nop
}
 801fd1c:	46bd      	mov	sp, r7
 801fd1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fd22:	4770      	bx	lr
 801fd24:	20012ff0 	.word	0x20012ff0

0801fd28 <OP_mul_dword>:

void OP_mul_dword()
{
 801fd28:	b480      	push	{r7}
 801fd2a:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(*);
 801fd2c:	4b0b      	ldr	r3, [pc, #44]	; (801fd5c <OP_mul_dword+0x34>)
 801fd2e:	681b      	ldr	r3, [r3, #0]
 801fd30:	3b08      	subs	r3, #8
 801fd32:	4a0a      	ldr	r2, [pc, #40]	; (801fd5c <OP_mul_dword+0x34>)
 801fd34:	6812      	ldr	r2, [r2, #0]
 801fd36:	3a08      	subs	r2, #8
 801fd38:	6812      	ldr	r2, [r2, #0]
 801fd3a:	4908      	ldr	r1, [pc, #32]	; (801fd5c <OP_mul_dword+0x34>)
 801fd3c:	6809      	ldr	r1, [r1, #0]
 801fd3e:	3904      	subs	r1, #4
 801fd40:	6809      	ldr	r1, [r1, #0]
 801fd42:	fb01 f202 	mul.w	r2, r1, r2
 801fd46:	601a      	str	r2, [r3, #0]
 801fd48:	4b04      	ldr	r3, [pc, #16]	; (801fd5c <OP_mul_dword+0x34>)
 801fd4a:	681b      	ldr	r3, [r3, #0]
 801fd4c:	3b04      	subs	r3, #4
 801fd4e:	4a03      	ldr	r2, [pc, #12]	; (801fd5c <OP_mul_dword+0x34>)
 801fd50:	6013      	str	r3, [r2, #0]

	return ;
 801fd52:	bf00      	nop
}
 801fd54:	46bd      	mov	sp, r7
 801fd56:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fd5a:	4770      	bx	lr
 801fd5c:	20012ff0 	.word	0x20012ff0

0801fd60 <OP_and_byte>:

/* --- and --- */
void OP_and_byte()
{
 801fd60:	b480      	push	{r7}
 801fd62:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(&);
 801fd64:	4b0b      	ldr	r3, [pc, #44]	; (801fd94 <OP_and_byte+0x34>)
 801fd66:	681b      	ldr	r3, [r3, #0]
 801fd68:	3b08      	subs	r3, #8
 801fd6a:	4a0a      	ldr	r2, [pc, #40]	; (801fd94 <OP_and_byte+0x34>)
 801fd6c:	6812      	ldr	r2, [r2, #0]
 801fd6e:	3a08      	subs	r2, #8
 801fd70:	7811      	ldrb	r1, [r2, #0]
 801fd72:	4a08      	ldr	r2, [pc, #32]	; (801fd94 <OP_and_byte+0x34>)
 801fd74:	6812      	ldr	r2, [r2, #0]
 801fd76:	3a04      	subs	r2, #4
 801fd78:	7812      	ldrb	r2, [r2, #0]
 801fd7a:	400a      	ands	r2, r1
 801fd7c:	b2d2      	uxtb	r2, r2
 801fd7e:	701a      	strb	r2, [r3, #0]
 801fd80:	4b04      	ldr	r3, [pc, #16]	; (801fd94 <OP_and_byte+0x34>)
 801fd82:	681b      	ldr	r3, [r3, #0]
 801fd84:	3b04      	subs	r3, #4
 801fd86:	4a03      	ldr	r2, [pc, #12]	; (801fd94 <OP_and_byte+0x34>)
 801fd88:	6013      	str	r3, [r2, #0]

	return ;
 801fd8a:	bf00      	nop
}
 801fd8c:	46bd      	mov	sp, r7
 801fd8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fd92:	4770      	bx	lr
 801fd94:	20012ff0 	.word	0x20012ff0

0801fd98 <OP_and_word>:

void OP_and_word()
{
 801fd98:	b480      	push	{r7}
 801fd9a:	af00      	add	r7, sp, #0
	OP_BIN_WORD(&);
 801fd9c:	4b0b      	ldr	r3, [pc, #44]	; (801fdcc <OP_and_word+0x34>)
 801fd9e:	681b      	ldr	r3, [r3, #0]
 801fda0:	3b08      	subs	r3, #8
 801fda2:	4a0a      	ldr	r2, [pc, #40]	; (801fdcc <OP_and_word+0x34>)
 801fda4:	6812      	ldr	r2, [r2, #0]
 801fda6:	3a08      	subs	r2, #8
 801fda8:	8811      	ldrh	r1, [r2, #0]
 801fdaa:	4a08      	ldr	r2, [pc, #32]	; (801fdcc <OP_and_word+0x34>)
 801fdac:	6812      	ldr	r2, [r2, #0]
 801fdae:	3a04      	subs	r2, #4
 801fdb0:	8812      	ldrh	r2, [r2, #0]
 801fdb2:	400a      	ands	r2, r1
 801fdb4:	b292      	uxth	r2, r2
 801fdb6:	801a      	strh	r2, [r3, #0]
 801fdb8:	4b04      	ldr	r3, [pc, #16]	; (801fdcc <OP_and_word+0x34>)
 801fdba:	681b      	ldr	r3, [r3, #0]
 801fdbc:	3b04      	subs	r3, #4
 801fdbe:	4a03      	ldr	r2, [pc, #12]	; (801fdcc <OP_and_word+0x34>)
 801fdc0:	6013      	str	r3, [r2, #0]

	return ;
 801fdc2:	bf00      	nop
}
 801fdc4:	46bd      	mov	sp, r7
 801fdc6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fdca:	4770      	bx	lr
 801fdcc:	20012ff0 	.word	0x20012ff0

0801fdd0 <OP_and_dword>:

void OP_and_dword()
{
 801fdd0:	b480      	push	{r7}
 801fdd2:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(&);
 801fdd4:	4b0b      	ldr	r3, [pc, #44]	; (801fe04 <OP_and_dword+0x34>)
 801fdd6:	681b      	ldr	r3, [r3, #0]
 801fdd8:	3b08      	subs	r3, #8
 801fdda:	4a0a      	ldr	r2, [pc, #40]	; (801fe04 <OP_and_dword+0x34>)
 801fddc:	6812      	ldr	r2, [r2, #0]
 801fdde:	3a08      	subs	r2, #8
 801fde0:	6811      	ldr	r1, [r2, #0]
 801fde2:	4a08      	ldr	r2, [pc, #32]	; (801fe04 <OP_and_dword+0x34>)
 801fde4:	6812      	ldr	r2, [r2, #0]
 801fde6:	3a04      	subs	r2, #4
 801fde8:	6812      	ldr	r2, [r2, #0]
 801fdea:	400a      	ands	r2, r1
 801fdec:	601a      	str	r2, [r3, #0]
 801fdee:	4b05      	ldr	r3, [pc, #20]	; (801fe04 <OP_and_dword+0x34>)
 801fdf0:	681b      	ldr	r3, [r3, #0]
 801fdf2:	3b04      	subs	r3, #4
 801fdf4:	4a03      	ldr	r2, [pc, #12]	; (801fe04 <OP_and_dword+0x34>)
 801fdf6:	6013      	str	r3, [r2, #0]

	return ;
 801fdf8:	bf00      	nop
}
 801fdfa:	46bd      	mov	sp, r7
 801fdfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fe00:	4770      	bx	lr
 801fe02:	bf00      	nop
 801fe04:	20012ff0 	.word	0x20012ff0

0801fe08 <OP_or_byte>:

/* --- or --- */
void OP_or_byte()
{
 801fe08:	b480      	push	{r7}
 801fe0a:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(|);
 801fe0c:	4b0b      	ldr	r3, [pc, #44]	; (801fe3c <OP_or_byte+0x34>)
 801fe0e:	681b      	ldr	r3, [r3, #0]
 801fe10:	3b08      	subs	r3, #8
 801fe12:	4a0a      	ldr	r2, [pc, #40]	; (801fe3c <OP_or_byte+0x34>)
 801fe14:	6812      	ldr	r2, [r2, #0]
 801fe16:	3a08      	subs	r2, #8
 801fe18:	7811      	ldrb	r1, [r2, #0]
 801fe1a:	4a08      	ldr	r2, [pc, #32]	; (801fe3c <OP_or_byte+0x34>)
 801fe1c:	6812      	ldr	r2, [r2, #0]
 801fe1e:	3a04      	subs	r2, #4
 801fe20:	7812      	ldrb	r2, [r2, #0]
 801fe22:	430a      	orrs	r2, r1
 801fe24:	b2d2      	uxtb	r2, r2
 801fe26:	701a      	strb	r2, [r3, #0]
 801fe28:	4b04      	ldr	r3, [pc, #16]	; (801fe3c <OP_or_byte+0x34>)
 801fe2a:	681b      	ldr	r3, [r3, #0]
 801fe2c:	3b04      	subs	r3, #4
 801fe2e:	4a03      	ldr	r2, [pc, #12]	; (801fe3c <OP_or_byte+0x34>)
 801fe30:	6013      	str	r3, [r2, #0]

	return ;
 801fe32:	bf00      	nop
}
 801fe34:	46bd      	mov	sp, r7
 801fe36:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fe3a:	4770      	bx	lr
 801fe3c:	20012ff0 	.word	0x20012ff0

0801fe40 <OP_or_word>:

void OP_or_word()
{
 801fe40:	b480      	push	{r7}
 801fe42:	af00      	add	r7, sp, #0
	OP_BIN_WORD(|);
 801fe44:	4b0b      	ldr	r3, [pc, #44]	; (801fe74 <OP_or_word+0x34>)
 801fe46:	681b      	ldr	r3, [r3, #0]
 801fe48:	3b08      	subs	r3, #8
 801fe4a:	4a0a      	ldr	r2, [pc, #40]	; (801fe74 <OP_or_word+0x34>)
 801fe4c:	6812      	ldr	r2, [r2, #0]
 801fe4e:	3a08      	subs	r2, #8
 801fe50:	8811      	ldrh	r1, [r2, #0]
 801fe52:	4a08      	ldr	r2, [pc, #32]	; (801fe74 <OP_or_word+0x34>)
 801fe54:	6812      	ldr	r2, [r2, #0]
 801fe56:	3a04      	subs	r2, #4
 801fe58:	8812      	ldrh	r2, [r2, #0]
 801fe5a:	430a      	orrs	r2, r1
 801fe5c:	b292      	uxth	r2, r2
 801fe5e:	801a      	strh	r2, [r3, #0]
 801fe60:	4b04      	ldr	r3, [pc, #16]	; (801fe74 <OP_or_word+0x34>)
 801fe62:	681b      	ldr	r3, [r3, #0]
 801fe64:	3b04      	subs	r3, #4
 801fe66:	4a03      	ldr	r2, [pc, #12]	; (801fe74 <OP_or_word+0x34>)
 801fe68:	6013      	str	r3, [r2, #0]

	return ;
 801fe6a:	bf00      	nop
}
 801fe6c:	46bd      	mov	sp, r7
 801fe6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fe72:	4770      	bx	lr
 801fe74:	20012ff0 	.word	0x20012ff0

0801fe78 <OP_or_dword>:

void OP_or_dword()
{
 801fe78:	b480      	push	{r7}
 801fe7a:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(|);
 801fe7c:	4b0b      	ldr	r3, [pc, #44]	; (801feac <OP_or_dword+0x34>)
 801fe7e:	681b      	ldr	r3, [r3, #0]
 801fe80:	3b08      	subs	r3, #8
 801fe82:	4a0a      	ldr	r2, [pc, #40]	; (801feac <OP_or_dword+0x34>)
 801fe84:	6812      	ldr	r2, [r2, #0]
 801fe86:	3a08      	subs	r2, #8
 801fe88:	6811      	ldr	r1, [r2, #0]
 801fe8a:	4a08      	ldr	r2, [pc, #32]	; (801feac <OP_or_dword+0x34>)
 801fe8c:	6812      	ldr	r2, [r2, #0]
 801fe8e:	3a04      	subs	r2, #4
 801fe90:	6812      	ldr	r2, [r2, #0]
 801fe92:	430a      	orrs	r2, r1
 801fe94:	601a      	str	r2, [r3, #0]
 801fe96:	4b05      	ldr	r3, [pc, #20]	; (801feac <OP_or_dword+0x34>)
 801fe98:	681b      	ldr	r3, [r3, #0]
 801fe9a:	3b04      	subs	r3, #4
 801fe9c:	4a03      	ldr	r2, [pc, #12]	; (801feac <OP_or_dword+0x34>)
 801fe9e:	6013      	str	r3, [r2, #0]

	return ;
 801fea0:	bf00      	nop
}
 801fea2:	46bd      	mov	sp, r7
 801fea4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fea8:	4770      	bx	lr
 801feaa:	bf00      	nop
 801feac:	20012ff0 	.word	0x20012ff0

0801feb0 <OP_xor_byte>:

/* --- xor --- */
void OP_xor_byte()
{
 801feb0:	b480      	push	{r7}
 801feb2:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(^);
 801feb4:	4b0b      	ldr	r3, [pc, #44]	; (801fee4 <OP_xor_byte+0x34>)
 801feb6:	681b      	ldr	r3, [r3, #0]
 801feb8:	3b08      	subs	r3, #8
 801feba:	4a0a      	ldr	r2, [pc, #40]	; (801fee4 <OP_xor_byte+0x34>)
 801febc:	6812      	ldr	r2, [r2, #0]
 801febe:	3a08      	subs	r2, #8
 801fec0:	7811      	ldrb	r1, [r2, #0]
 801fec2:	4a08      	ldr	r2, [pc, #32]	; (801fee4 <OP_xor_byte+0x34>)
 801fec4:	6812      	ldr	r2, [r2, #0]
 801fec6:	3a04      	subs	r2, #4
 801fec8:	7812      	ldrb	r2, [r2, #0]
 801feca:	404a      	eors	r2, r1
 801fecc:	b2d2      	uxtb	r2, r2
 801fece:	701a      	strb	r2, [r3, #0]
 801fed0:	4b04      	ldr	r3, [pc, #16]	; (801fee4 <OP_xor_byte+0x34>)
 801fed2:	681b      	ldr	r3, [r3, #0]
 801fed4:	3b04      	subs	r3, #4
 801fed6:	4a03      	ldr	r2, [pc, #12]	; (801fee4 <OP_xor_byte+0x34>)
 801fed8:	6013      	str	r3, [r2, #0]

	return ;
 801feda:	bf00      	nop
}
 801fedc:	46bd      	mov	sp, r7
 801fede:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fee2:	4770      	bx	lr
 801fee4:	20012ff0 	.word	0x20012ff0

0801fee8 <OP_xor_word>:

void OP_xor_word()
{
 801fee8:	b480      	push	{r7}
 801feea:	af00      	add	r7, sp, #0
	OP_BIN_WORD(^);
 801feec:	4b0b      	ldr	r3, [pc, #44]	; (801ff1c <OP_xor_word+0x34>)
 801feee:	681b      	ldr	r3, [r3, #0]
 801fef0:	3b08      	subs	r3, #8
 801fef2:	4a0a      	ldr	r2, [pc, #40]	; (801ff1c <OP_xor_word+0x34>)
 801fef4:	6812      	ldr	r2, [r2, #0]
 801fef6:	3a08      	subs	r2, #8
 801fef8:	8811      	ldrh	r1, [r2, #0]
 801fefa:	4a08      	ldr	r2, [pc, #32]	; (801ff1c <OP_xor_word+0x34>)
 801fefc:	6812      	ldr	r2, [r2, #0]
 801fefe:	3a04      	subs	r2, #4
 801ff00:	8812      	ldrh	r2, [r2, #0]
 801ff02:	404a      	eors	r2, r1
 801ff04:	b292      	uxth	r2, r2
 801ff06:	801a      	strh	r2, [r3, #0]
 801ff08:	4b04      	ldr	r3, [pc, #16]	; (801ff1c <OP_xor_word+0x34>)
 801ff0a:	681b      	ldr	r3, [r3, #0]
 801ff0c:	3b04      	subs	r3, #4
 801ff0e:	4a03      	ldr	r2, [pc, #12]	; (801ff1c <OP_xor_word+0x34>)
 801ff10:	6013      	str	r3, [r2, #0]

	return ;
 801ff12:	bf00      	nop
}
 801ff14:	46bd      	mov	sp, r7
 801ff16:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ff1a:	4770      	bx	lr
 801ff1c:	20012ff0 	.word	0x20012ff0

0801ff20 <OP_xor_dword>:

void OP_xor_dword()
{
 801ff20:	b480      	push	{r7}
 801ff22:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(^);
 801ff24:	4b0b      	ldr	r3, [pc, #44]	; (801ff54 <OP_xor_dword+0x34>)
 801ff26:	681b      	ldr	r3, [r3, #0]
 801ff28:	3b08      	subs	r3, #8
 801ff2a:	4a0a      	ldr	r2, [pc, #40]	; (801ff54 <OP_xor_dword+0x34>)
 801ff2c:	6812      	ldr	r2, [r2, #0]
 801ff2e:	3a08      	subs	r2, #8
 801ff30:	6811      	ldr	r1, [r2, #0]
 801ff32:	4a08      	ldr	r2, [pc, #32]	; (801ff54 <OP_xor_dword+0x34>)
 801ff34:	6812      	ldr	r2, [r2, #0]
 801ff36:	3a04      	subs	r2, #4
 801ff38:	6812      	ldr	r2, [r2, #0]
 801ff3a:	404a      	eors	r2, r1
 801ff3c:	601a      	str	r2, [r3, #0]
 801ff3e:	4b05      	ldr	r3, [pc, #20]	; (801ff54 <OP_xor_dword+0x34>)
 801ff40:	681b      	ldr	r3, [r3, #0]
 801ff42:	3b04      	subs	r3, #4
 801ff44:	4a03      	ldr	r2, [pc, #12]	; (801ff54 <OP_xor_dword+0x34>)
 801ff46:	6013      	str	r3, [r2, #0]

	return ;
 801ff48:	bf00      	nop
}
 801ff4a:	46bd      	mov	sp, r7
 801ff4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ff50:	4770      	bx	lr
 801ff52:	bf00      	nop
 801ff54:	20012ff0 	.word	0x20012ff0

0801ff58 <OP_bw_byte>:

/* --- bw --- */
void OP_bw_byte()
{
 801ff58:	b480      	push	{r7}
 801ff5a:	af00      	add	r7, sp, #0
	(finsh_sp - 1)->char_value = ~ ((finsh_sp - 1)->char_value);
 801ff5c:	4b07      	ldr	r3, [pc, #28]	; (801ff7c <OP_bw_byte+0x24>)
 801ff5e:	681b      	ldr	r3, [r3, #0]
 801ff60:	3b04      	subs	r3, #4
 801ff62:	4a06      	ldr	r2, [pc, #24]	; (801ff7c <OP_bw_byte+0x24>)
 801ff64:	6812      	ldr	r2, [r2, #0]
 801ff66:	3a04      	subs	r2, #4
 801ff68:	7812      	ldrb	r2, [r2, #0]
 801ff6a:	43d2      	mvns	r2, r2
 801ff6c:	b2d2      	uxtb	r2, r2
 801ff6e:	701a      	strb	r2, [r3, #0]

	return ;
 801ff70:	bf00      	nop
}
 801ff72:	46bd      	mov	sp, r7
 801ff74:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ff78:	4770      	bx	lr
 801ff7a:	bf00      	nop
 801ff7c:	20012ff0 	.word	0x20012ff0

0801ff80 <OP_bw_word>:

void OP_bw_word()
{
 801ff80:	b480      	push	{r7}
 801ff82:	af00      	add	r7, sp, #0
	(finsh_sp - 1)->short_value = ~ ((finsh_sp - 1)->short_value);
 801ff84:	4b07      	ldr	r3, [pc, #28]	; (801ffa4 <OP_bw_word+0x24>)
 801ff86:	681b      	ldr	r3, [r3, #0]
 801ff88:	3b04      	subs	r3, #4
 801ff8a:	4a06      	ldr	r2, [pc, #24]	; (801ffa4 <OP_bw_word+0x24>)
 801ff8c:	6812      	ldr	r2, [r2, #0]
 801ff8e:	3a04      	subs	r2, #4
 801ff90:	8812      	ldrh	r2, [r2, #0]
 801ff92:	43d2      	mvns	r2, r2
 801ff94:	b292      	uxth	r2, r2
 801ff96:	801a      	strh	r2, [r3, #0]

	return ;
 801ff98:	bf00      	nop
}
 801ff9a:	46bd      	mov	sp, r7
 801ff9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ffa0:	4770      	bx	lr
 801ffa2:	bf00      	nop
 801ffa4:	20012ff0 	.word	0x20012ff0

0801ffa8 <OP_bw_dword>:

void OP_bw_dword()
{
 801ffa8:	b480      	push	{r7}
 801ffaa:	af00      	add	r7, sp, #0
	(finsh_sp - 1)->long_value = ~ ((finsh_sp - 1)->long_value);
 801ffac:	4b06      	ldr	r3, [pc, #24]	; (801ffc8 <OP_bw_dword+0x20>)
 801ffae:	681b      	ldr	r3, [r3, #0]
 801ffb0:	3b04      	subs	r3, #4
 801ffb2:	4a05      	ldr	r2, [pc, #20]	; (801ffc8 <OP_bw_dword+0x20>)
 801ffb4:	6812      	ldr	r2, [r2, #0]
 801ffb6:	3a04      	subs	r2, #4
 801ffb8:	6812      	ldr	r2, [r2, #0]
 801ffba:	43d2      	mvns	r2, r2
 801ffbc:	601a      	str	r2, [r3, #0]

	return ;
 801ffbe:	bf00      	nop
}
 801ffc0:	46bd      	mov	sp, r7
 801ffc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ffc6:	4770      	bx	lr
 801ffc8:	20012ff0 	.word	0x20012ff0

0801ffcc <OP_shl_byte>:

/* --- shl --- */
void OP_shl_byte()
{
 801ffcc:	b480      	push	{r7}
 801ffce:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(<<);
 801ffd0:	4b0c      	ldr	r3, [pc, #48]	; (8020004 <OP_shl_byte+0x38>)
 801ffd2:	681b      	ldr	r3, [r3, #0]
 801ffd4:	3b08      	subs	r3, #8
 801ffd6:	4a0b      	ldr	r2, [pc, #44]	; (8020004 <OP_shl_byte+0x38>)
 801ffd8:	6812      	ldr	r2, [r2, #0]
 801ffda:	3a08      	subs	r2, #8
 801ffdc:	7812      	ldrb	r2, [r2, #0]
 801ffde:	4611      	mov	r1, r2
 801ffe0:	4a08      	ldr	r2, [pc, #32]	; (8020004 <OP_shl_byte+0x38>)
 801ffe2:	6812      	ldr	r2, [r2, #0]
 801ffe4:	3a04      	subs	r2, #4
 801ffe6:	7812      	ldrb	r2, [r2, #0]
 801ffe8:	fa01 f202 	lsl.w	r2, r1, r2
 801ffec:	b2d2      	uxtb	r2, r2
 801ffee:	701a      	strb	r2, [r3, #0]
 801fff0:	4b04      	ldr	r3, [pc, #16]	; (8020004 <OP_shl_byte+0x38>)
 801fff2:	681b      	ldr	r3, [r3, #0]
 801fff4:	3b04      	subs	r3, #4
 801fff6:	4a03      	ldr	r2, [pc, #12]	; (8020004 <OP_shl_byte+0x38>)
 801fff8:	6013      	str	r3, [r2, #0]

	return ;
 801fffa:	bf00      	nop
}
 801fffc:	46bd      	mov	sp, r7
 801fffe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020002:	4770      	bx	lr
 8020004:	20012ff0 	.word	0x20012ff0

08020008 <OP_shl_word>:

void OP_shl_word()
{
 8020008:	b480      	push	{r7}
 802000a:	af00      	add	r7, sp, #0
	OP_BIN_WORD(<<);
 802000c:	4b0d      	ldr	r3, [pc, #52]	; (8020044 <OP_shl_word+0x3c>)
 802000e:	681b      	ldr	r3, [r3, #0]
 8020010:	3b08      	subs	r3, #8
 8020012:	4a0c      	ldr	r2, [pc, #48]	; (8020044 <OP_shl_word+0x3c>)
 8020014:	6812      	ldr	r2, [r2, #0]
 8020016:	3a08      	subs	r2, #8
 8020018:	8812      	ldrh	r2, [r2, #0]
 802001a:	b211      	sxth	r1, r2
 802001c:	4a09      	ldr	r2, [pc, #36]	; (8020044 <OP_shl_word+0x3c>)
 802001e:	6812      	ldr	r2, [r2, #0]
 8020020:	3a04      	subs	r2, #4
 8020022:	8812      	ldrh	r2, [r2, #0]
 8020024:	b212      	sxth	r2, r2
 8020026:	fa01 f202 	lsl.w	r2, r1, r2
 802002a:	b292      	uxth	r2, r2
 802002c:	801a      	strh	r2, [r3, #0]
 802002e:	4b05      	ldr	r3, [pc, #20]	; (8020044 <OP_shl_word+0x3c>)
 8020030:	681b      	ldr	r3, [r3, #0]
 8020032:	3b04      	subs	r3, #4
 8020034:	4a03      	ldr	r2, [pc, #12]	; (8020044 <OP_shl_word+0x3c>)
 8020036:	6013      	str	r3, [r2, #0]

	return ;
 8020038:	bf00      	nop
}
 802003a:	46bd      	mov	sp, r7
 802003c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020040:	4770      	bx	lr
 8020042:	bf00      	nop
 8020044:	20012ff0 	.word	0x20012ff0

08020048 <OP_shl_dword>:

void OP_shl_dword()
{
 8020048:	b480      	push	{r7}
 802004a:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(<<);
 802004c:	4b0b      	ldr	r3, [pc, #44]	; (802007c <OP_shl_dword+0x34>)
 802004e:	681b      	ldr	r3, [r3, #0]
 8020050:	3b08      	subs	r3, #8
 8020052:	4a0a      	ldr	r2, [pc, #40]	; (802007c <OP_shl_dword+0x34>)
 8020054:	6812      	ldr	r2, [r2, #0]
 8020056:	3a08      	subs	r2, #8
 8020058:	6811      	ldr	r1, [r2, #0]
 802005a:	4a08      	ldr	r2, [pc, #32]	; (802007c <OP_shl_dword+0x34>)
 802005c:	6812      	ldr	r2, [r2, #0]
 802005e:	3a04      	subs	r2, #4
 8020060:	6812      	ldr	r2, [r2, #0]
 8020062:	fa01 f202 	lsl.w	r2, r1, r2
 8020066:	601a      	str	r2, [r3, #0]
 8020068:	4b04      	ldr	r3, [pc, #16]	; (802007c <OP_shl_dword+0x34>)
 802006a:	681b      	ldr	r3, [r3, #0]
 802006c:	3b04      	subs	r3, #4
 802006e:	4a03      	ldr	r2, [pc, #12]	; (802007c <OP_shl_dword+0x34>)
 8020070:	6013      	str	r3, [r2, #0]

	return ;
 8020072:	bf00      	nop
}
 8020074:	46bd      	mov	sp, r7
 8020076:	f85d 7b04 	ldr.w	r7, [sp], #4
 802007a:	4770      	bx	lr
 802007c:	20012ff0 	.word	0x20012ff0

08020080 <OP_shr_byte>:

/* --- shr --- */
void OP_shr_byte()
{
 8020080:	b480      	push	{r7}
 8020082:	af00      	add	r7, sp, #0
	OP_BIN_BYTE(>>);
 8020084:	4b0c      	ldr	r3, [pc, #48]	; (80200b8 <OP_shr_byte+0x38>)
 8020086:	681b      	ldr	r3, [r3, #0]
 8020088:	3b08      	subs	r3, #8
 802008a:	4a0b      	ldr	r2, [pc, #44]	; (80200b8 <OP_shr_byte+0x38>)
 802008c:	6812      	ldr	r2, [r2, #0]
 802008e:	3a08      	subs	r2, #8
 8020090:	7812      	ldrb	r2, [r2, #0]
 8020092:	4611      	mov	r1, r2
 8020094:	4a08      	ldr	r2, [pc, #32]	; (80200b8 <OP_shr_byte+0x38>)
 8020096:	6812      	ldr	r2, [r2, #0]
 8020098:	3a04      	subs	r2, #4
 802009a:	7812      	ldrb	r2, [r2, #0]
 802009c:	fa41 f202 	asr.w	r2, r1, r2
 80200a0:	b2d2      	uxtb	r2, r2
 80200a2:	701a      	strb	r2, [r3, #0]
 80200a4:	4b04      	ldr	r3, [pc, #16]	; (80200b8 <OP_shr_byte+0x38>)
 80200a6:	681b      	ldr	r3, [r3, #0]
 80200a8:	3b04      	subs	r3, #4
 80200aa:	4a03      	ldr	r2, [pc, #12]	; (80200b8 <OP_shr_byte+0x38>)
 80200ac:	6013      	str	r3, [r2, #0]

	return ;
 80200ae:	bf00      	nop
}
 80200b0:	46bd      	mov	sp, r7
 80200b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80200b6:	4770      	bx	lr
 80200b8:	20012ff0 	.word	0x20012ff0

080200bc <OP_shr_word>:

void OP_shr_word()
{
 80200bc:	b480      	push	{r7}
 80200be:	af00      	add	r7, sp, #0
	OP_BIN_WORD(>>);
 80200c0:	4b0d      	ldr	r3, [pc, #52]	; (80200f8 <OP_shr_word+0x3c>)
 80200c2:	681b      	ldr	r3, [r3, #0]
 80200c4:	3b08      	subs	r3, #8
 80200c6:	4a0c      	ldr	r2, [pc, #48]	; (80200f8 <OP_shr_word+0x3c>)
 80200c8:	6812      	ldr	r2, [r2, #0]
 80200ca:	3a08      	subs	r2, #8
 80200cc:	8812      	ldrh	r2, [r2, #0]
 80200ce:	b211      	sxth	r1, r2
 80200d0:	4a09      	ldr	r2, [pc, #36]	; (80200f8 <OP_shr_word+0x3c>)
 80200d2:	6812      	ldr	r2, [r2, #0]
 80200d4:	3a04      	subs	r2, #4
 80200d6:	8812      	ldrh	r2, [r2, #0]
 80200d8:	b212      	sxth	r2, r2
 80200da:	fa41 f202 	asr.w	r2, r1, r2
 80200de:	b292      	uxth	r2, r2
 80200e0:	801a      	strh	r2, [r3, #0]
 80200e2:	4b05      	ldr	r3, [pc, #20]	; (80200f8 <OP_shr_word+0x3c>)
 80200e4:	681b      	ldr	r3, [r3, #0]
 80200e6:	3b04      	subs	r3, #4
 80200e8:	4a03      	ldr	r2, [pc, #12]	; (80200f8 <OP_shr_word+0x3c>)
 80200ea:	6013      	str	r3, [r2, #0]

	return ;
 80200ec:	bf00      	nop
}
 80200ee:	46bd      	mov	sp, r7
 80200f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80200f4:	4770      	bx	lr
 80200f6:	bf00      	nop
 80200f8:	20012ff0 	.word	0x20012ff0

080200fc <OP_shr_dword>:

void OP_shr_dword()
{
 80200fc:	b480      	push	{r7}
 80200fe:	af00      	add	r7, sp, #0
	OP_BIN_DWORD(>>);
 8020100:	4b0b      	ldr	r3, [pc, #44]	; (8020130 <OP_shr_dword+0x34>)
 8020102:	681b      	ldr	r3, [r3, #0]
 8020104:	3b08      	subs	r3, #8
 8020106:	4a0a      	ldr	r2, [pc, #40]	; (8020130 <OP_shr_dword+0x34>)
 8020108:	6812      	ldr	r2, [r2, #0]
 802010a:	3a08      	subs	r2, #8
 802010c:	6811      	ldr	r1, [r2, #0]
 802010e:	4a08      	ldr	r2, [pc, #32]	; (8020130 <OP_shr_dword+0x34>)
 8020110:	6812      	ldr	r2, [r2, #0]
 8020112:	3a04      	subs	r2, #4
 8020114:	6812      	ldr	r2, [r2, #0]
 8020116:	fa41 f202 	asr.w	r2, r1, r2
 802011a:	601a      	str	r2, [r3, #0]
 802011c:	4b04      	ldr	r3, [pc, #16]	; (8020130 <OP_shr_dword+0x34>)
 802011e:	681b      	ldr	r3, [r3, #0]
 8020120:	3b04      	subs	r3, #4
 8020122:	4a03      	ldr	r2, [pc, #12]	; (8020130 <OP_shr_dword+0x34>)
 8020124:	6013      	str	r3, [r2, #0]

	return ;
 8020126:	bf00      	nop
}
 8020128:	46bd      	mov	sp, r7
 802012a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802012e:	4770      	bx	lr
 8020130:	20012ff0 	.word	0x20012ff0

08020134 <OP_ld_byte>:

/* --- ld --- */
void OP_ld_byte()
{
 8020134:	b480      	push	{r7}
 8020136:	af00      	add	r7, sp, #0
	finsh_sp->char_value = *finsh_pc;
 8020138:	4b0a      	ldr	r3, [pc, #40]	; (8020164 <OP_ld_byte+0x30>)
 802013a:	681b      	ldr	r3, [r3, #0]
 802013c:	4a0a      	ldr	r2, [pc, #40]	; (8020168 <OP_ld_byte+0x34>)
 802013e:	6812      	ldr	r2, [r2, #0]
 8020140:	7812      	ldrb	r2, [r2, #0]
 8020142:	701a      	strb	r2, [r3, #0]

	finsh_sp++;
 8020144:	4b07      	ldr	r3, [pc, #28]	; (8020164 <OP_ld_byte+0x30>)
 8020146:	681b      	ldr	r3, [r3, #0]
 8020148:	3304      	adds	r3, #4
 802014a:	4a06      	ldr	r2, [pc, #24]	; (8020164 <OP_ld_byte+0x30>)
 802014c:	6013      	str	r3, [r2, #0]
	finsh_pc++;
 802014e:	4b06      	ldr	r3, [pc, #24]	; (8020168 <OP_ld_byte+0x34>)
 8020150:	681b      	ldr	r3, [r3, #0]
 8020152:	3301      	adds	r3, #1
 8020154:	4a04      	ldr	r2, [pc, #16]	; (8020168 <OP_ld_byte+0x34>)
 8020156:	6013      	str	r3, [r2, #0]

	return ;
 8020158:	bf00      	nop
}
 802015a:	46bd      	mov	sp, r7
 802015c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020160:	4770      	bx	lr
 8020162:	bf00      	nop
 8020164:	20012ff0 	.word	0x20012ff0
 8020168:	20012fec 	.word	0x20012fec

0802016c <OP_ld_word>:

void OP_ld_word()
{
 802016c:	b480      	push	{r7}
 802016e:	af00      	add	r7, sp, #0
	finsh_sp->short_value = FINSH_GET16(finsh_pc);
 8020170:	4b0e      	ldr	r3, [pc, #56]	; (80201ac <OP_ld_word+0x40>)
 8020172:	681b      	ldr	r3, [r3, #0]
 8020174:	4a0e      	ldr	r2, [pc, #56]	; (80201b0 <OP_ld_word+0x44>)
 8020176:	6812      	ldr	r2, [r2, #0]
 8020178:	7812      	ldrb	r2, [r2, #0]
 802017a:	b291      	uxth	r1, r2
 802017c:	4a0c      	ldr	r2, [pc, #48]	; (80201b0 <OP_ld_word+0x44>)
 802017e:	6812      	ldr	r2, [r2, #0]
 8020180:	3201      	adds	r2, #1
 8020182:	7812      	ldrb	r2, [r2, #0]
 8020184:	0212      	lsls	r2, r2, #8
 8020186:	b292      	uxth	r2, r2
 8020188:	430a      	orrs	r2, r1
 802018a:	b292      	uxth	r2, r2
 802018c:	801a      	strh	r2, [r3, #0]

	finsh_sp ++;
 802018e:	4b07      	ldr	r3, [pc, #28]	; (80201ac <OP_ld_word+0x40>)
 8020190:	681b      	ldr	r3, [r3, #0]
 8020192:	3304      	adds	r3, #4
 8020194:	4a05      	ldr	r2, [pc, #20]	; (80201ac <OP_ld_word+0x40>)
 8020196:	6013      	str	r3, [r2, #0]
	finsh_pc += 2;
 8020198:	4b05      	ldr	r3, [pc, #20]	; (80201b0 <OP_ld_word+0x44>)
 802019a:	681b      	ldr	r3, [r3, #0]
 802019c:	3302      	adds	r3, #2
 802019e:	4a04      	ldr	r2, [pc, #16]	; (80201b0 <OP_ld_word+0x44>)
 80201a0:	6013      	str	r3, [r2, #0]

	return ;
 80201a2:	bf00      	nop
}
 80201a4:	46bd      	mov	sp, r7
 80201a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80201aa:	4770      	bx	lr
 80201ac:	20012ff0 	.word	0x20012ff0
 80201b0:	20012fec 	.word	0x20012fec

080201b4 <OP_ld_dword>:

void OP_ld_dword()
{
 80201b4:	b480      	push	{r7}
 80201b6:	af00      	add	r7, sp, #0
	finsh_sp->long_value = FINSH_GET32(finsh_pc);
 80201b8:	4b13      	ldr	r3, [pc, #76]	; (8020208 <OP_ld_dword+0x54>)
 80201ba:	681b      	ldr	r3, [r3, #0]
 80201bc:	4a13      	ldr	r2, [pc, #76]	; (802020c <OP_ld_dword+0x58>)
 80201be:	6812      	ldr	r2, [r2, #0]
 80201c0:	7812      	ldrb	r2, [r2, #0]
 80201c2:	4611      	mov	r1, r2
 80201c4:	4a11      	ldr	r2, [pc, #68]	; (802020c <OP_ld_dword+0x58>)
 80201c6:	6812      	ldr	r2, [r2, #0]
 80201c8:	3201      	adds	r2, #1
 80201ca:	7812      	ldrb	r2, [r2, #0]
 80201cc:	0212      	lsls	r2, r2, #8
 80201ce:	4311      	orrs	r1, r2
 80201d0:	4a0e      	ldr	r2, [pc, #56]	; (802020c <OP_ld_dword+0x58>)
 80201d2:	6812      	ldr	r2, [r2, #0]
 80201d4:	3202      	adds	r2, #2
 80201d6:	7812      	ldrb	r2, [r2, #0]
 80201d8:	0412      	lsls	r2, r2, #16
 80201da:	4311      	orrs	r1, r2
 80201dc:	4a0b      	ldr	r2, [pc, #44]	; (802020c <OP_ld_dword+0x58>)
 80201de:	6812      	ldr	r2, [r2, #0]
 80201e0:	3203      	adds	r2, #3
 80201e2:	7812      	ldrb	r2, [r2, #0]
 80201e4:	0612      	lsls	r2, r2, #24
 80201e6:	430a      	orrs	r2, r1
 80201e8:	601a      	str	r2, [r3, #0]

	finsh_sp ++;
 80201ea:	4b07      	ldr	r3, [pc, #28]	; (8020208 <OP_ld_dword+0x54>)
 80201ec:	681b      	ldr	r3, [r3, #0]
 80201ee:	3304      	adds	r3, #4
 80201f0:	4a05      	ldr	r2, [pc, #20]	; (8020208 <OP_ld_dword+0x54>)
 80201f2:	6013      	str	r3, [r2, #0]
	finsh_pc += 4;
 80201f4:	4b05      	ldr	r3, [pc, #20]	; (802020c <OP_ld_dword+0x58>)
 80201f6:	681b      	ldr	r3, [r3, #0]
 80201f8:	3304      	adds	r3, #4
 80201fa:	4a04      	ldr	r2, [pc, #16]	; (802020c <OP_ld_dword+0x58>)
 80201fc:	6013      	str	r3, [r2, #0]

	return ;
 80201fe:	bf00      	nop
}
 8020200:	46bd      	mov	sp, r7
 8020202:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020206:	4770      	bx	lr
 8020208:	20012ff0 	.word	0x20012ff0
 802020c:	20012fec 	.word	0x20012fec

08020210 <OP_ld_value_byte>:

void OP_ld_value_byte()
{
 8020210:	b480      	push	{r7}
 8020212:	b083      	sub	sp, #12
 8020214:	af00      	add	r7, sp, #0
	char* c;

	c = (char*) (FINSH_GET32(finsh_pc));
 8020216:	4b16      	ldr	r3, [pc, #88]	; (8020270 <OP_ld_value_byte+0x60>)
 8020218:	681b      	ldr	r3, [r3, #0]
 802021a:	781b      	ldrb	r3, [r3, #0]
 802021c:	461a      	mov	r2, r3
 802021e:	4b14      	ldr	r3, [pc, #80]	; (8020270 <OP_ld_value_byte+0x60>)
 8020220:	681b      	ldr	r3, [r3, #0]
 8020222:	3301      	adds	r3, #1
 8020224:	781b      	ldrb	r3, [r3, #0]
 8020226:	021b      	lsls	r3, r3, #8
 8020228:	431a      	orrs	r2, r3
 802022a:	4b11      	ldr	r3, [pc, #68]	; (8020270 <OP_ld_value_byte+0x60>)
 802022c:	681b      	ldr	r3, [r3, #0]
 802022e:	3302      	adds	r3, #2
 8020230:	781b      	ldrb	r3, [r3, #0]
 8020232:	041b      	lsls	r3, r3, #16
 8020234:	431a      	orrs	r2, r3
 8020236:	4b0e      	ldr	r3, [pc, #56]	; (8020270 <OP_ld_value_byte+0x60>)
 8020238:	681b      	ldr	r3, [r3, #0]
 802023a:	3303      	adds	r3, #3
 802023c:	781b      	ldrb	r3, [r3, #0]
 802023e:	061b      	lsls	r3, r3, #24
 8020240:	4313      	orrs	r3, r2
 8020242:	607b      	str	r3, [r7, #4]

	finsh_sp->char_value = *c;
 8020244:	4b0b      	ldr	r3, [pc, #44]	; (8020274 <OP_ld_value_byte+0x64>)
 8020246:	681b      	ldr	r3, [r3, #0]
 8020248:	687a      	ldr	r2, [r7, #4]
 802024a:	7812      	ldrb	r2, [r2, #0]
 802024c:	701a      	strb	r2, [r3, #0]

	finsh_sp ++;
 802024e:	4b09      	ldr	r3, [pc, #36]	; (8020274 <OP_ld_value_byte+0x64>)
 8020250:	681b      	ldr	r3, [r3, #0]
 8020252:	3304      	adds	r3, #4
 8020254:	4a07      	ldr	r2, [pc, #28]	; (8020274 <OP_ld_value_byte+0x64>)
 8020256:	6013      	str	r3, [r2, #0]
	finsh_pc += 4;
 8020258:	4b05      	ldr	r3, [pc, #20]	; (8020270 <OP_ld_value_byte+0x60>)
 802025a:	681b      	ldr	r3, [r3, #0]
 802025c:	3304      	adds	r3, #4
 802025e:	4a04      	ldr	r2, [pc, #16]	; (8020270 <OP_ld_value_byte+0x60>)
 8020260:	6013      	str	r3, [r2, #0]

	return;
 8020262:	bf00      	nop
}
 8020264:	370c      	adds	r7, #12
 8020266:	46bd      	mov	sp, r7
 8020268:	f85d 7b04 	ldr.w	r7, [sp], #4
 802026c:	4770      	bx	lr
 802026e:	bf00      	nop
 8020270:	20012fec 	.word	0x20012fec
 8020274:	20012ff0 	.word	0x20012ff0

08020278 <OP_ld_value_byte_stack>:

void OP_ld_value_byte_stack()
{
 8020278:	b480      	push	{r7}
 802027a:	b083      	sub	sp, #12
 802027c:	af00      	add	r7, sp, #0
	char* c;

	c = (char *)(finsh_sp - 1)->long_value;
 802027e:	4b08      	ldr	r3, [pc, #32]	; (80202a0 <OP_ld_value_byte_stack+0x28>)
 8020280:	681b      	ldr	r3, [r3, #0]
 8020282:	3b04      	subs	r3, #4
 8020284:	681b      	ldr	r3, [r3, #0]
 8020286:	607b      	str	r3, [r7, #4]
	(finsh_sp - 1)->char_value = *c;
 8020288:	4b05      	ldr	r3, [pc, #20]	; (80202a0 <OP_ld_value_byte_stack+0x28>)
 802028a:	681b      	ldr	r3, [r3, #0]
 802028c:	3b04      	subs	r3, #4
 802028e:	687a      	ldr	r2, [r7, #4]
 8020290:	7812      	ldrb	r2, [r2, #0]
 8020292:	701a      	strb	r2, [r3, #0]

	return;
 8020294:	bf00      	nop
}
 8020296:	370c      	adds	r7, #12
 8020298:	46bd      	mov	sp, r7
 802029a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802029e:	4770      	bx	lr
 80202a0:	20012ff0 	.word	0x20012ff0

080202a4 <OP_ld_value_word>:

void OP_ld_value_word()
{
 80202a4:	b480      	push	{r7}
 80202a6:	b083      	sub	sp, #12
 80202a8:	af00      	add	r7, sp, #0
	short* s;

	s = (short*) (FINSH_GET32(finsh_pc));
 80202aa:	4b16      	ldr	r3, [pc, #88]	; (8020304 <OP_ld_value_word+0x60>)
 80202ac:	681b      	ldr	r3, [r3, #0]
 80202ae:	781b      	ldrb	r3, [r3, #0]
 80202b0:	461a      	mov	r2, r3
 80202b2:	4b14      	ldr	r3, [pc, #80]	; (8020304 <OP_ld_value_word+0x60>)
 80202b4:	681b      	ldr	r3, [r3, #0]
 80202b6:	3301      	adds	r3, #1
 80202b8:	781b      	ldrb	r3, [r3, #0]
 80202ba:	021b      	lsls	r3, r3, #8
 80202bc:	431a      	orrs	r2, r3
 80202be:	4b11      	ldr	r3, [pc, #68]	; (8020304 <OP_ld_value_word+0x60>)
 80202c0:	681b      	ldr	r3, [r3, #0]
 80202c2:	3302      	adds	r3, #2
 80202c4:	781b      	ldrb	r3, [r3, #0]
 80202c6:	041b      	lsls	r3, r3, #16
 80202c8:	431a      	orrs	r2, r3
 80202ca:	4b0e      	ldr	r3, [pc, #56]	; (8020304 <OP_ld_value_word+0x60>)
 80202cc:	681b      	ldr	r3, [r3, #0]
 80202ce:	3303      	adds	r3, #3
 80202d0:	781b      	ldrb	r3, [r3, #0]
 80202d2:	061b      	lsls	r3, r3, #24
 80202d4:	4313      	orrs	r3, r2
 80202d6:	607b      	str	r3, [r7, #4]

	finsh_sp->short_value = *s;
 80202d8:	4b0b      	ldr	r3, [pc, #44]	; (8020308 <OP_ld_value_word+0x64>)
 80202da:	681b      	ldr	r3, [r3, #0]
 80202dc:	687a      	ldr	r2, [r7, #4]
 80202de:	8812      	ldrh	r2, [r2, #0]
 80202e0:	801a      	strh	r2, [r3, #0]

	finsh_sp ++;
 80202e2:	4b09      	ldr	r3, [pc, #36]	; (8020308 <OP_ld_value_word+0x64>)
 80202e4:	681b      	ldr	r3, [r3, #0]
 80202e6:	3304      	adds	r3, #4
 80202e8:	4a07      	ldr	r2, [pc, #28]	; (8020308 <OP_ld_value_word+0x64>)
 80202ea:	6013      	str	r3, [r2, #0]
	finsh_pc += 4;
 80202ec:	4b05      	ldr	r3, [pc, #20]	; (8020304 <OP_ld_value_word+0x60>)
 80202ee:	681b      	ldr	r3, [r3, #0]
 80202f0:	3304      	adds	r3, #4
 80202f2:	4a04      	ldr	r2, [pc, #16]	; (8020304 <OP_ld_value_word+0x60>)
 80202f4:	6013      	str	r3, [r2, #0]

	return;
 80202f6:	bf00      	nop
}
 80202f8:	370c      	adds	r7, #12
 80202fa:	46bd      	mov	sp, r7
 80202fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020300:	4770      	bx	lr
 8020302:	bf00      	nop
 8020304:	20012fec 	.word	0x20012fec
 8020308:	20012ff0 	.word	0x20012ff0

0802030c <OP_ld_value_word_stack>:

void OP_ld_value_word_stack()
{
 802030c:	b480      	push	{r7}
 802030e:	b083      	sub	sp, #12
 8020310:	af00      	add	r7, sp, #0
	short* s;

	s = (short *)(finsh_sp - 1)->long_value;
 8020312:	4b08      	ldr	r3, [pc, #32]	; (8020334 <OP_ld_value_word_stack+0x28>)
 8020314:	681b      	ldr	r3, [r3, #0]
 8020316:	3b04      	subs	r3, #4
 8020318:	681b      	ldr	r3, [r3, #0]
 802031a:	607b      	str	r3, [r7, #4]
	(finsh_sp - 1)->short_value = *s;
 802031c:	4b05      	ldr	r3, [pc, #20]	; (8020334 <OP_ld_value_word_stack+0x28>)
 802031e:	681b      	ldr	r3, [r3, #0]
 8020320:	3b04      	subs	r3, #4
 8020322:	687a      	ldr	r2, [r7, #4]
 8020324:	8812      	ldrh	r2, [r2, #0]
 8020326:	801a      	strh	r2, [r3, #0]

	return;
 8020328:	bf00      	nop
}
 802032a:	370c      	adds	r7, #12
 802032c:	46bd      	mov	sp, r7
 802032e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020332:	4770      	bx	lr
 8020334:	20012ff0 	.word	0x20012ff0

08020338 <OP_ld_value_dword>:

void OP_ld_value_dword()
{
 8020338:	b480      	push	{r7}
 802033a:	b083      	sub	sp, #12
 802033c:	af00      	add	r7, sp, #0
	long* l;

	l = (long*) (FINSH_GET32(finsh_pc));
 802033e:	4b16      	ldr	r3, [pc, #88]	; (8020398 <OP_ld_value_dword+0x60>)
 8020340:	681b      	ldr	r3, [r3, #0]
 8020342:	781b      	ldrb	r3, [r3, #0]
 8020344:	461a      	mov	r2, r3
 8020346:	4b14      	ldr	r3, [pc, #80]	; (8020398 <OP_ld_value_dword+0x60>)
 8020348:	681b      	ldr	r3, [r3, #0]
 802034a:	3301      	adds	r3, #1
 802034c:	781b      	ldrb	r3, [r3, #0]
 802034e:	021b      	lsls	r3, r3, #8
 8020350:	431a      	orrs	r2, r3
 8020352:	4b11      	ldr	r3, [pc, #68]	; (8020398 <OP_ld_value_dword+0x60>)
 8020354:	681b      	ldr	r3, [r3, #0]
 8020356:	3302      	adds	r3, #2
 8020358:	781b      	ldrb	r3, [r3, #0]
 802035a:	041b      	lsls	r3, r3, #16
 802035c:	431a      	orrs	r2, r3
 802035e:	4b0e      	ldr	r3, [pc, #56]	; (8020398 <OP_ld_value_dword+0x60>)
 8020360:	681b      	ldr	r3, [r3, #0]
 8020362:	3303      	adds	r3, #3
 8020364:	781b      	ldrb	r3, [r3, #0]
 8020366:	061b      	lsls	r3, r3, #24
 8020368:	4313      	orrs	r3, r2
 802036a:	607b      	str	r3, [r7, #4]

	finsh_sp->long_value = *l;
 802036c:	4b0b      	ldr	r3, [pc, #44]	; (802039c <OP_ld_value_dword+0x64>)
 802036e:	681b      	ldr	r3, [r3, #0]
 8020370:	687a      	ldr	r2, [r7, #4]
 8020372:	6812      	ldr	r2, [r2, #0]
 8020374:	601a      	str	r2, [r3, #0]

	finsh_sp ++;
 8020376:	4b09      	ldr	r3, [pc, #36]	; (802039c <OP_ld_value_dword+0x64>)
 8020378:	681b      	ldr	r3, [r3, #0]
 802037a:	3304      	adds	r3, #4
 802037c:	4a07      	ldr	r2, [pc, #28]	; (802039c <OP_ld_value_dword+0x64>)
 802037e:	6013      	str	r3, [r2, #0]
	finsh_pc += 4;
 8020380:	4b05      	ldr	r3, [pc, #20]	; (8020398 <OP_ld_value_dword+0x60>)
 8020382:	681b      	ldr	r3, [r3, #0]
 8020384:	3304      	adds	r3, #4
 8020386:	4a04      	ldr	r2, [pc, #16]	; (8020398 <OP_ld_value_dword+0x60>)
 8020388:	6013      	str	r3, [r2, #0]

	return;
 802038a:	bf00      	nop
}
 802038c:	370c      	adds	r7, #12
 802038e:	46bd      	mov	sp, r7
 8020390:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020394:	4770      	bx	lr
 8020396:	bf00      	nop
 8020398:	20012fec 	.word	0x20012fec
 802039c:	20012ff0 	.word	0x20012ff0

080203a0 <OP_ld_value_dword_stack>:

void OP_ld_value_dword_stack()
{
 80203a0:	b480      	push	{r7}
 80203a2:	b083      	sub	sp, #12
 80203a4:	af00      	add	r7, sp, #0
	long* l;

	l = (long *)(finsh_sp - 1)->long_value;
 80203a6:	4b08      	ldr	r3, [pc, #32]	; (80203c8 <OP_ld_value_dword_stack+0x28>)
 80203a8:	681b      	ldr	r3, [r3, #0]
 80203aa:	3b04      	subs	r3, #4
 80203ac:	681b      	ldr	r3, [r3, #0]
 80203ae:	607b      	str	r3, [r7, #4]
	(finsh_sp - 1)->long_value = *l;
 80203b0:	4b05      	ldr	r3, [pc, #20]	; (80203c8 <OP_ld_value_dword_stack+0x28>)
 80203b2:	681b      	ldr	r3, [r3, #0]
 80203b4:	3b04      	subs	r3, #4
 80203b6:	687a      	ldr	r2, [r7, #4]
 80203b8:	6812      	ldr	r2, [r2, #0]
 80203ba:	601a      	str	r2, [r3, #0]

	return;
 80203bc:	bf00      	nop
}
 80203be:	370c      	adds	r7, #12
 80203c0:	46bd      	mov	sp, r7
 80203c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80203c6:	4770      	bx	lr
 80203c8:	20012ff0 	.word	0x20012ff0

080203cc <OP_st_byte>:
/*
 * 2006-4-16 bernard
 * fixed the sp move bug
 */
void OP_st_byte()
{
 80203cc:	b480      	push	{r7}
 80203ce:	af00      	add	r7, sp, #0
	*(char*)((finsh_sp - 2)->long_value) = (finsh_sp - 1)->char_value;
 80203d0:	4b09      	ldr	r3, [pc, #36]	; (80203f8 <OP_st_byte+0x2c>)
 80203d2:	681b      	ldr	r3, [r3, #0]
 80203d4:	3b08      	subs	r3, #8
 80203d6:	681b      	ldr	r3, [r3, #0]
 80203d8:	461a      	mov	r2, r3
 80203da:	4b07      	ldr	r3, [pc, #28]	; (80203f8 <OP_st_byte+0x2c>)
 80203dc:	681b      	ldr	r3, [r3, #0]
 80203de:	3b04      	subs	r3, #4
 80203e0:	781b      	ldrb	r3, [r3, #0]
 80203e2:	7013      	strb	r3, [r2, #0]
	finsh_sp --;
 80203e4:	4b04      	ldr	r3, [pc, #16]	; (80203f8 <OP_st_byte+0x2c>)
 80203e6:	681b      	ldr	r3, [r3, #0]
 80203e8:	3b04      	subs	r3, #4
 80203ea:	4a03      	ldr	r2, [pc, #12]	; (80203f8 <OP_st_byte+0x2c>)
 80203ec:	6013      	str	r3, [r2, #0]

	return ;
 80203ee:	bf00      	nop
}
 80203f0:	46bd      	mov	sp, r7
 80203f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80203f6:	4770      	bx	lr
 80203f8:	20012ff0 	.word	0x20012ff0

080203fc <OP_st_word>:
/*
 * 2006-4-16 bernard
 * fixed the sp move bug
 */
void OP_st_word()
{
 80203fc:	b480      	push	{r7}
 80203fe:	af00      	add	r7, sp, #0
	*(short*)((finsh_sp - 2)->long_value) = (finsh_sp - 1)->short_value;
 8020400:	4b09      	ldr	r3, [pc, #36]	; (8020428 <OP_st_word+0x2c>)
 8020402:	681b      	ldr	r3, [r3, #0]
 8020404:	3b08      	subs	r3, #8
 8020406:	681b      	ldr	r3, [r3, #0]
 8020408:	461a      	mov	r2, r3
 802040a:	4b07      	ldr	r3, [pc, #28]	; (8020428 <OP_st_word+0x2c>)
 802040c:	681b      	ldr	r3, [r3, #0]
 802040e:	3b04      	subs	r3, #4
 8020410:	881b      	ldrh	r3, [r3, #0]
 8020412:	8013      	strh	r3, [r2, #0]
	finsh_sp --;
 8020414:	4b04      	ldr	r3, [pc, #16]	; (8020428 <OP_st_word+0x2c>)
 8020416:	681b      	ldr	r3, [r3, #0]
 8020418:	3b04      	subs	r3, #4
 802041a:	4a03      	ldr	r2, [pc, #12]	; (8020428 <OP_st_word+0x2c>)
 802041c:	6013      	str	r3, [r2, #0]

	return ;
 802041e:	bf00      	nop
}
 8020420:	46bd      	mov	sp, r7
 8020422:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020426:	4770      	bx	lr
 8020428:	20012ff0 	.word	0x20012ff0

0802042c <OP_st_dword>:
/*
 * 2006-4-16 bernard
 * fixed the sp move bug
 */
void OP_st_dword()
{
 802042c:	b480      	push	{r7}
 802042e:	af00      	add	r7, sp, #0
	*(long*)((finsh_sp - 2)->long_value) = (finsh_sp - 1)->long_value;
 8020430:	4b09      	ldr	r3, [pc, #36]	; (8020458 <OP_st_dword+0x2c>)
 8020432:	681b      	ldr	r3, [r3, #0]
 8020434:	3b08      	subs	r3, #8
 8020436:	681b      	ldr	r3, [r3, #0]
 8020438:	461a      	mov	r2, r3
 802043a:	4b07      	ldr	r3, [pc, #28]	; (8020458 <OP_st_dword+0x2c>)
 802043c:	681b      	ldr	r3, [r3, #0]
 802043e:	3b04      	subs	r3, #4
 8020440:	681b      	ldr	r3, [r3, #0]
 8020442:	6013      	str	r3, [r2, #0]
	finsh_sp --;
 8020444:	4b04      	ldr	r3, [pc, #16]	; (8020458 <OP_st_dword+0x2c>)
 8020446:	681b      	ldr	r3, [r3, #0]
 8020448:	3b04      	subs	r3, #4
 802044a:	4a03      	ldr	r2, [pc, #12]	; (8020458 <OP_st_dword+0x2c>)
 802044c:	6013      	str	r3, [r2, #0]

	return ;
 802044e:	bf00      	nop
}
 8020450:	46bd      	mov	sp, r7
 8020452:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020456:	4770      	bx	lr
 8020458:	20012ff0 	.word	0x20012ff0

0802045c <OP_pop>:

/* --- pop --- */
void OP_pop()
{
 802045c:	b480      	push	{r7}
 802045e:	af00      	add	r7, sp, #0
	finsh_sp --;
 8020460:	4b04      	ldr	r3, [pc, #16]	; (8020474 <OP_pop+0x18>)
 8020462:	681b      	ldr	r3, [r3, #0]
 8020464:	3b04      	subs	r3, #4
 8020466:	4a03      	ldr	r2, [pc, #12]	; (8020474 <OP_pop+0x18>)
 8020468:	6013      	str	r3, [r2, #0]
	return ;
 802046a:	bf00      	nop
}
 802046c:	46bd      	mov	sp, r7
 802046e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020472:	4770      	bx	lr
 8020474:	20012ff0 	.word	0x20012ff0

08020478 <OP_call>:

/* --- call --- */
void OP_call()
{
 8020478:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802047c:	b0a5      	sub	sp, #148	; 0x94
 802047e:	af0c      	add	r7, sp, #48	; 0x30
	typedef unsigned long var_t;
	typedef var_t (*op_func)();
	op_func f;
	var_t   r;

	parameters = *finsh_pc ++;
 8020480:	4b95      	ldr	r3, [pc, #596]	; (80206d8 <OP_call+0x260>)
 8020482:	681b      	ldr	r3, [r3, #0]
 8020484:	1c5a      	adds	r2, r3, #1
 8020486:	4994      	ldr	r1, [pc, #592]	; (80206d8 <OP_call+0x260>)
 8020488:	600a      	str	r2, [r1, #0]
 802048a:	781b      	ldrb	r3, [r3, #0]
 802048c:	657b      	str	r3, [r7, #84]	; 0x54

	i = 0; finsh_sp --;
 802048e:	2300      	movs	r3, #0
 8020490:	65fb      	str	r3, [r7, #92]	; 0x5c
 8020492:	4b92      	ldr	r3, [pc, #584]	; (80206dc <OP_call+0x264>)
 8020494:	681b      	ldr	r3, [r3, #0]
 8020496:	3b04      	subs	r3, #4
 8020498:	4a90      	ldr	r2, [pc, #576]	; (80206dc <OP_call+0x264>)
 802049a:	6013      	str	r3, [r2, #0]
	while (i < parameters)
 802049c:	e014      	b.n	80204c8 <OP_call+0x50>
	{
		parameterv[parameters - 1 - i] = finsh_sp->long_value;
 802049e:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 80204a0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80204a2:	1ad3      	subs	r3, r2, r3
 80204a4:	3b01      	subs	r3, #1
 80204a6:	4a8d      	ldr	r2, [pc, #564]	; (80206dc <OP_call+0x264>)
 80204a8:	6812      	ldr	r2, [r2, #0]
 80204aa:	6812      	ldr	r2, [r2, #0]
 80204ac:	009b      	lsls	r3, r3, #2
 80204ae:	f107 0160 	add.w	r1, r7, #96	; 0x60
 80204b2:	440b      	add	r3, r1
 80204b4:	f843 2c50 	str.w	r2, [r3, #-80]
		finsh_sp --;
 80204b8:	4b88      	ldr	r3, [pc, #544]	; (80206dc <OP_call+0x264>)
 80204ba:	681b      	ldr	r3, [r3, #0]
 80204bc:	3b04      	subs	r3, #4
 80204be:	4a87      	ldr	r2, [pc, #540]	; (80206dc <OP_call+0x264>)
 80204c0:	6013      	str	r3, [r2, #0]
		i++;
 80204c2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80204c4:	3301      	adds	r3, #1
 80204c6:	65fb      	str	r3, [r7, #92]	; 0x5c
	var_t   r;

	parameters = *finsh_pc ++;

	i = 0; finsh_sp --;
	while (i < parameters)
 80204c8:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 80204ca:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80204cc:	429a      	cmp	r2, r3
 80204ce:	d3e6      	bcc.n	802049e <OP_call+0x26>
		parameterv[parameters - 1 - i] = finsh_sp->long_value;
		finsh_sp --;
		i++;
	}

	f = (op_func)(finsh_sp->long_value);
 80204d0:	4b82      	ldr	r3, [pc, #520]	; (80206dc <OP_call+0x264>)
 80204d2:	681b      	ldr	r3, [r3, #0]
 80204d4:	681b      	ldr	r3, [r3, #0]
 80204d6:	653b      	str	r3, [r7, #80]	; 0x50
	switch (parameters)
 80204d8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80204da:	2b10      	cmp	r3, #16
 80204dc:	f200 81b0 	bhi.w	8020840 <OP_call+0x3c8>
 80204e0:	a201      	add	r2, pc, #4	; (adr r2, 80204e8 <OP_call+0x70>)
 80204e2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80204e6:	bf00      	nop
 80204e8:	0802052d 	.word	0x0802052d
 80204ec:	08020537 	.word	0x08020537
 80204f0:	08020543 	.word	0x08020543
 80204f4:	08020553 	.word	0x08020553
 80204f8:	08020561 	.word	0x08020561
 80204fc:	08020571 	.word	0x08020571
 8020500:	08020587 	.word	0x08020587
 8020504:	080205a3 	.word	0x080205a3
 8020508:	080205c7 	.word	0x080205c7
 802050c:	080205f3 	.word	0x080205f3
 8020510:	08020623 	.word	0x08020623
 8020514:	08020659 	.word	0x08020659
 8020518:	08020695 	.word	0x08020695
 802051c:	080206e1 	.word	0x080206e1
 8020520:	0802072d 	.word	0x0802072d
 8020524:	08020781 	.word	0x08020781
 8020528:	080207dd 	.word	0x080207dd
	{
	case 0:
		r = f(0);
 802052c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 802052e:	2000      	movs	r0, #0
 8020530:	4798      	blx	r3
 8020532:	65b8      	str	r0, [r7, #88]	; 0x58
		break;
 8020534:	e187      	b.n	8020846 <OP_call+0x3ce>

	case 1:
		r = f(parameterv[0]);
 8020536:	693a      	ldr	r2, [r7, #16]
 8020538:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 802053a:	4610      	mov	r0, r2
 802053c:	4798      	blx	r3
 802053e:	65b8      	str	r0, [r7, #88]	; 0x58
		break;
 8020540:	e181      	b.n	8020846 <OP_call+0x3ce>

	case 2:
		r = f(parameterv[0], parameterv[1]);
 8020542:	6939      	ldr	r1, [r7, #16]
 8020544:	697a      	ldr	r2, [r7, #20]
 8020546:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8020548:	4608      	mov	r0, r1
 802054a:	4611      	mov	r1, r2
 802054c:	4798      	blx	r3
 802054e:	65b8      	str	r0, [r7, #88]	; 0x58
		break;
 8020550:	e179      	b.n	8020846 <OP_call+0x3ce>

	case 3:
		r = f(parameterv[0], parameterv[1], parameterv[2]);
 8020552:	6938      	ldr	r0, [r7, #16]
 8020554:	6979      	ldr	r1, [r7, #20]
 8020556:	69ba      	ldr	r2, [r7, #24]
 8020558:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 802055a:	4798      	blx	r3
 802055c:	65b8      	str	r0, [r7, #88]	; 0x58
		break;
 802055e:	e172      	b.n	8020846 <OP_call+0x3ce>

	case 4:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3]);
 8020560:	6938      	ldr	r0, [r7, #16]
 8020562:	6979      	ldr	r1, [r7, #20]
 8020564:	69ba      	ldr	r2, [r7, #24]
 8020566:	69fb      	ldr	r3, [r7, #28]
 8020568:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 802056a:	47a0      	blx	r4
 802056c:	65b8      	str	r0, [r7, #88]	; 0x58
		break;
 802056e:	e16a      	b.n	8020846 <OP_call+0x3ce>

	case 5:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 8020570:	6938      	ldr	r0, [r7, #16]
 8020572:	6979      	ldr	r1, [r7, #20]
 8020574:	69ba      	ldr	r2, [r7, #24]
 8020576:	69fd      	ldr	r5, [r7, #28]
 8020578:	6a3b      	ldr	r3, [r7, #32]
 802057a:	9300      	str	r3, [sp, #0]
 802057c:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 802057e:	462b      	mov	r3, r5
 8020580:	47a0      	blx	r4
 8020582:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4]);
		break;
 8020584:	e15f      	b.n	8020846 <OP_call+0x3ce>

	case 6:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 8020586:	6938      	ldr	r0, [r7, #16]
 8020588:	6979      	ldr	r1, [r7, #20]
 802058a:	69be      	ldr	r6, [r7, #24]
 802058c:	69fd      	ldr	r5, [r7, #28]
 802058e:	6a3a      	ldr	r2, [r7, #32]
 8020590:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8020592:	9200      	str	r2, [sp, #0]
 8020594:	9301      	str	r3, [sp, #4]
 8020596:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8020598:	4632      	mov	r2, r6
 802059a:	462b      	mov	r3, r5
 802059c:	47a0      	blx	r4
 802059e:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5]);
		break;
 80205a0:	e151      	b.n	8020846 <OP_call+0x3ce>

	case 7:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 80205a2:	6938      	ldr	r0, [r7, #16]
 80205a4:	f8d7 e014 	ldr.w	lr, [r7, #20]
 80205a8:	69be      	ldr	r6, [r7, #24]
 80205aa:	69fd      	ldr	r5, [r7, #28]
 80205ac:	6a39      	ldr	r1, [r7, #32]
 80205ae:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80205b0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80205b2:	9100      	str	r1, [sp, #0]
 80205b4:	9201      	str	r2, [sp, #4]
 80205b6:	9302      	str	r3, [sp, #8]
 80205b8:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 80205ba:	4671      	mov	r1, lr
 80205bc:	4632      	mov	r2, r6
 80205be:	462b      	mov	r3, r5
 80205c0:	47a0      	blx	r4
 80205c2:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6]);
		break;
 80205c4:	e13f      	b.n	8020846 <OP_call+0x3ce>

	case 8:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 80205c6:	f8d7 c010 	ldr.w	ip, [r7, #16]
 80205ca:	f8d7 e014 	ldr.w	lr, [r7, #20]
 80205ce:	69be      	ldr	r6, [r7, #24]
 80205d0:	69fd      	ldr	r5, [r7, #28]
 80205d2:	6a38      	ldr	r0, [r7, #32]
 80205d4:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80205d6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80205d8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80205da:	9000      	str	r0, [sp, #0]
 80205dc:	9101      	str	r1, [sp, #4]
 80205de:	9202      	str	r2, [sp, #8]
 80205e0:	9303      	str	r3, [sp, #12]
 80205e2:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 80205e4:	4660      	mov	r0, ip
 80205e6:	4671      	mov	r1, lr
 80205e8:	4632      	mov	r2, r6
 80205ea:	462b      	mov	r3, r5
 80205ec:	47a0      	blx	r4
 80205ee:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7]);
		break;
 80205f0:	e129      	b.n	8020846 <OP_call+0x3ce>

	case 9:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 80205f2:	f8d7 c010 	ldr.w	ip, [r7, #16]
 80205f6:	f8d7 e014 	ldr.w	lr, [r7, #20]
 80205fa:	69be      	ldr	r6, [r7, #24]
 80205fc:	69fd      	ldr	r5, [r7, #28]
 80205fe:	6a3c      	ldr	r4, [r7, #32]
 8020600:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8020602:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8020604:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8020606:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8020608:	9400      	str	r4, [sp, #0]
 802060a:	9001      	str	r0, [sp, #4]
 802060c:	9102      	str	r1, [sp, #8]
 802060e:	9203      	str	r2, [sp, #12]
 8020610:	9304      	str	r3, [sp, #16]
 8020612:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8020614:	4660      	mov	r0, ip
 8020616:	4671      	mov	r1, lr
 8020618:	4632      	mov	r2, r6
 802061a:	462b      	mov	r3, r5
 802061c:	47a0      	blx	r4
 802061e:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8]);
		break;
 8020620:	e111      	b.n	8020846 <OP_call+0x3ce>

	case 10:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 8020622:	f8d7 8010 	ldr.w	r8, [r7, #16]
 8020626:	f8d7 c014 	ldr.w	ip, [r7, #20]
 802062a:	f8d7 e018 	ldr.w	lr, [r7, #24]
 802062e:	69fe      	ldr	r6, [r7, #28]
 8020630:	6a3d      	ldr	r5, [r7, #32]
 8020632:	6a7c      	ldr	r4, [r7, #36]	; 0x24
 8020634:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8020636:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8020638:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 802063a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802063c:	9500      	str	r5, [sp, #0]
 802063e:	9401      	str	r4, [sp, #4]
 8020640:	9002      	str	r0, [sp, #8]
 8020642:	9103      	str	r1, [sp, #12]
 8020644:	9204      	str	r2, [sp, #16]
 8020646:	9305      	str	r3, [sp, #20]
 8020648:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 802064a:	4640      	mov	r0, r8
 802064c:	4661      	mov	r1, ip
 802064e:	4672      	mov	r2, lr
 8020650:	4633      	mov	r3, r6
 8020652:	47a0      	blx	r4
 8020654:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9]);
		break;
 8020656:	e0f6      	b.n	8020846 <OP_call+0x3ce>

	case 11:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 8020658:	f8d7 9010 	ldr.w	r9, [r7, #16]
 802065c:	f8d7 8014 	ldr.w	r8, [r7, #20]
 8020660:	f8d7 c018 	ldr.w	ip, [r7, #24]
 8020664:	f8d7 e01c 	ldr.w	lr, [r7, #28]
 8020668:	6a3e      	ldr	r6, [r7, #32]
 802066a:	6a7d      	ldr	r5, [r7, #36]	; 0x24
 802066c:	6abc      	ldr	r4, [r7, #40]	; 0x28
 802066e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8020670:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8020672:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8020674:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8020676:	9600      	str	r6, [sp, #0]
 8020678:	9501      	str	r5, [sp, #4]
 802067a:	9402      	str	r4, [sp, #8]
 802067c:	9003      	str	r0, [sp, #12]
 802067e:	9104      	str	r1, [sp, #16]
 8020680:	9205      	str	r2, [sp, #20]
 8020682:	9306      	str	r3, [sp, #24]
 8020684:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8020686:	4648      	mov	r0, r9
 8020688:	4641      	mov	r1, r8
 802068a:	4662      	mov	r2, ip
 802068c:	4673      	mov	r3, lr
 802068e:	47a0      	blx	r4
 8020690:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10]);
		break;
 8020692:	e0d8      	b.n	8020846 <OP_call+0x3ce>

	case 12:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 8020694:	f8d7 a010 	ldr.w	sl, [r7, #16]
 8020698:	f8d7 9014 	ldr.w	r9, [r7, #20]
 802069c:	f8d7 8018 	ldr.w	r8, [r7, #24]
 80206a0:	f8d7 c01c 	ldr.w	ip, [r7, #28]
 80206a4:	f8d7 e020 	ldr.w	lr, [r7, #32]
 80206a8:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 80206aa:	6abd      	ldr	r5, [r7, #40]	; 0x28
 80206ac:	6afc      	ldr	r4, [r7, #44]	; 0x2c
 80206ae:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80206b0:	6b79      	ldr	r1, [r7, #52]	; 0x34
 80206b2:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80206b4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80206b6:	f8cd e000 	str.w	lr, [sp]
 80206ba:	9601      	str	r6, [sp, #4]
 80206bc:	9502      	str	r5, [sp, #8]
 80206be:	9403      	str	r4, [sp, #12]
 80206c0:	9004      	str	r0, [sp, #16]
 80206c2:	9105      	str	r1, [sp, #20]
 80206c4:	9206      	str	r2, [sp, #24]
 80206c6:	9307      	str	r3, [sp, #28]
 80206c8:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 80206ca:	4650      	mov	r0, sl
 80206cc:	4649      	mov	r1, r9
 80206ce:	4642      	mov	r2, r8
 80206d0:	4663      	mov	r3, ip
 80206d2:	47a0      	blx	r4
 80206d4:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11]);
		break;
 80206d6:	e0b6      	b.n	8020846 <OP_call+0x3ce>
 80206d8:	20012fec 	.word	0x20012fec
 80206dc:	20012ff0 	.word	0x20012ff0

	case 13:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 80206e0:	f8d7 b010 	ldr.w	fp, [r7, #16]
 80206e4:	f8d7 a014 	ldr.w	sl, [r7, #20]
 80206e8:	f8d7 9018 	ldr.w	r9, [r7, #24]
 80206ec:	f8d7 801c 	ldr.w	r8, [r7, #28]
 80206f0:	f8d7 c020 	ldr.w	ip, [r7, #32]
 80206f4:	f8d7 e024 	ldr.w	lr, [r7, #36]	; 0x24
 80206f8:	6abe      	ldr	r6, [r7, #40]	; 0x28
 80206fa:	6afd      	ldr	r5, [r7, #44]	; 0x2c
 80206fc:	6b3c      	ldr	r4, [r7, #48]	; 0x30
 80206fe:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8020700:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8020702:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8020704:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8020706:	f8cd c000 	str.w	ip, [sp]
 802070a:	f8cd e004 	str.w	lr, [sp, #4]
 802070e:	9602      	str	r6, [sp, #8]
 8020710:	9503      	str	r5, [sp, #12]
 8020712:	9404      	str	r4, [sp, #16]
 8020714:	9005      	str	r0, [sp, #20]
 8020716:	9106      	str	r1, [sp, #24]
 8020718:	9207      	str	r2, [sp, #28]
 802071a:	9308      	str	r3, [sp, #32]
 802071c:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 802071e:	4658      	mov	r0, fp
 8020720:	4651      	mov	r1, sl
 8020722:	464a      	mov	r2, r9
 8020724:	4643      	mov	r3, r8
 8020726:	47a0      	blx	r4
 8020728:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12]);
		break;
 802072a:	e08c      	b.n	8020846 <OP_call+0x3ce>

	case 14:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 802072c:	693b      	ldr	r3, [r7, #16]
 802072e:	60fb      	str	r3, [r7, #12]
 8020730:	f8d7 b014 	ldr.w	fp, [r7, #20]
 8020734:	f8d7 a018 	ldr.w	sl, [r7, #24]
 8020738:	f8d7 901c 	ldr.w	r9, [r7, #28]
 802073c:	f8d7 8020 	ldr.w	r8, [r7, #32]
 8020740:	f8d7 c024 	ldr.w	ip, [r7, #36]	; 0x24
 8020744:	f8d7 e028 	ldr.w	lr, [r7, #40]	; 0x28
 8020748:	6afe      	ldr	r6, [r7, #44]	; 0x2c
 802074a:	6b3d      	ldr	r5, [r7, #48]	; 0x30
 802074c:	6b7c      	ldr	r4, [r7, #52]	; 0x34
 802074e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8020750:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8020752:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8020754:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8020756:	f8cd 8000 	str.w	r8, [sp]
 802075a:	f8cd c004 	str.w	ip, [sp, #4]
 802075e:	f8cd e008 	str.w	lr, [sp, #8]
 8020762:	9603      	str	r6, [sp, #12]
 8020764:	9504      	str	r5, [sp, #16]
 8020766:	9405      	str	r4, [sp, #20]
 8020768:	9006      	str	r0, [sp, #24]
 802076a:	9107      	str	r1, [sp, #28]
 802076c:	9208      	str	r2, [sp, #32]
 802076e:	9309      	str	r3, [sp, #36]	; 0x24
 8020770:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8020772:	68f8      	ldr	r0, [r7, #12]
 8020774:	4659      	mov	r1, fp
 8020776:	4652      	mov	r2, sl
 8020778:	464b      	mov	r3, r9
 802077a:	47a0      	blx	r4
 802077c:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12], parameterv[13]);
		break;
 802077e:	e062      	b.n	8020846 <OP_call+0x3ce>

	case 15:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 8020780:	693b      	ldr	r3, [r7, #16]
 8020782:	60fb      	str	r3, [r7, #12]
 8020784:	697a      	ldr	r2, [r7, #20]
 8020786:	60ba      	str	r2, [r7, #8]
 8020788:	f8d7 b018 	ldr.w	fp, [r7, #24]
 802078c:	f8d7 a01c 	ldr.w	sl, [r7, #28]
 8020790:	6a3a      	ldr	r2, [r7, #32]
 8020792:	f8d7 9024 	ldr.w	r9, [r7, #36]	; 0x24
 8020796:	f8d7 8028 	ldr.w	r8, [r7, #40]	; 0x28
 802079a:	f8d7 c02c 	ldr.w	ip, [r7, #44]	; 0x2c
 802079e:	f8d7 e030 	ldr.w	lr, [r7, #48]	; 0x30
 80207a2:	6b7e      	ldr	r6, [r7, #52]	; 0x34
 80207a4:	6bbd      	ldr	r5, [r7, #56]	; 0x38
 80207a6:	6bfc      	ldr	r4, [r7, #60]	; 0x3c
 80207a8:	6c38      	ldr	r0, [r7, #64]	; 0x40
 80207aa:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80207ac:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80207ae:	9200      	str	r2, [sp, #0]
 80207b0:	f8cd 9004 	str.w	r9, [sp, #4]
 80207b4:	f8cd 8008 	str.w	r8, [sp, #8]
 80207b8:	f8cd c00c 	str.w	ip, [sp, #12]
 80207bc:	f8cd e010 	str.w	lr, [sp, #16]
 80207c0:	9605      	str	r6, [sp, #20]
 80207c2:	9506      	str	r5, [sp, #24]
 80207c4:	9407      	str	r4, [sp, #28]
 80207c6:	9008      	str	r0, [sp, #32]
 80207c8:	9109      	str	r1, [sp, #36]	; 0x24
 80207ca:	930a      	str	r3, [sp, #40]	; 0x28
 80207cc:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 80207ce:	68f8      	ldr	r0, [r7, #12]
 80207d0:	68b9      	ldr	r1, [r7, #8]
 80207d2:	465a      	mov	r2, fp
 80207d4:	4653      	mov	r3, sl
 80207d6:	47a0      	blx	r4
 80207d8:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12], parameterv[13], parameterv[14]);
		break;
 80207da:	e034      	b.n	8020846 <OP_call+0x3ce>

	case 16:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
 80207dc:	693b      	ldr	r3, [r7, #16]
 80207de:	60fb      	str	r3, [r7, #12]
 80207e0:	697a      	ldr	r2, [r7, #20]
 80207e2:	60ba      	str	r2, [r7, #8]
 80207e4:	69bc      	ldr	r4, [r7, #24]
 80207e6:	607c      	str	r4, [r7, #4]
 80207e8:	f8d7 b01c 	ldr.w	fp, [r7, #28]
 80207ec:	6a3a      	ldr	r2, [r7, #32]
 80207ee:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80207f0:	f8d7 a028 	ldr.w	sl, [r7, #40]	; 0x28
 80207f4:	f8d7 902c 	ldr.w	r9, [r7, #44]	; 0x2c
 80207f8:	f8d7 8030 	ldr.w	r8, [r7, #48]	; 0x30
 80207fc:	f8d7 c034 	ldr.w	ip, [r7, #52]	; 0x34
 8020800:	f8d7 e038 	ldr.w	lr, [r7, #56]	; 0x38
 8020804:	6bfe      	ldr	r6, [r7, #60]	; 0x3c
 8020806:	6c3d      	ldr	r5, [r7, #64]	; 0x40
 8020808:	6c7c      	ldr	r4, [r7, #68]	; 0x44
 802080a:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 802080c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802080e:	9200      	str	r2, [sp, #0]
 8020810:	9001      	str	r0, [sp, #4]
 8020812:	f8cd a008 	str.w	sl, [sp, #8]
 8020816:	f8cd 900c 	str.w	r9, [sp, #12]
 802081a:	f8cd 8010 	str.w	r8, [sp, #16]
 802081e:	f8cd c014 	str.w	ip, [sp, #20]
 8020822:	f8cd e018 	str.w	lr, [sp, #24]
 8020826:	9607      	str	r6, [sp, #28]
 8020828:	9508      	str	r5, [sp, #32]
 802082a:	9409      	str	r4, [sp, #36]	; 0x24
 802082c:	910a      	str	r1, [sp, #40]	; 0x28
 802082e:	930b      	str	r3, [sp, #44]	; 0x2c
 8020830:	6d3c      	ldr	r4, [r7, #80]	; 0x50
 8020832:	68f8      	ldr	r0, [r7, #12]
 8020834:	68b9      	ldr	r1, [r7, #8]
 8020836:	687a      	ldr	r2, [r7, #4]
 8020838:	465b      	mov	r3, fp
 802083a:	47a0      	blx	r4
 802083c:	65b8      	str	r0, [r7, #88]	; 0x58
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12], parameterv[13], parameterv[14], parameterv[15]);
		break;
 802083e:	e002      	b.n	8020846 <OP_call+0x3ce>

	default:
		r = 0;
 8020840:	2300      	movs	r3, #0
 8020842:	65bb      	str	r3, [r7, #88]	; 0x58
		break;
 8020844:	bf00      	nop
	}

	finsh_sp->long_value = r;
 8020846:	4b07      	ldr	r3, [pc, #28]	; (8020864 <OP_call+0x3ec>)
 8020848:	681b      	ldr	r3, [r3, #0]
 802084a:	6dba      	ldr	r2, [r7, #88]	; 0x58
 802084c:	601a      	str	r2, [r3, #0]
	finsh_sp ++;
 802084e:	4b05      	ldr	r3, [pc, #20]	; (8020864 <OP_call+0x3ec>)
 8020850:	681b      	ldr	r3, [r3, #0]
 8020852:	3304      	adds	r3, #4
 8020854:	4a03      	ldr	r2, [pc, #12]	; (8020864 <OP_call+0x3ec>)
 8020856:	6013      	str	r3, [r2, #0]

	return ;
 8020858:	bf00      	nop
}
 802085a:	3764      	adds	r7, #100	; 0x64
 802085c:	46bd      	mov	sp, r7
 802085e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8020862:	bf00      	nop
 8020864:	20012ff0 	.word	0x20012ff0

08020868 <proc_variable_decl>:
	| declarator
declarator -> identifier
	| identifier ASSIGN expr_assign
*/
static struct finsh_node* proc_variable_decl(struct finsh_parser* self)
{
 8020868:	b580      	push	{r7, lr}
 802086a:	b090      	sub	sp, #64	; 0x40
 802086c:	af00      	add	r7, sp, #0
 802086e:	6078      	str	r0, [r7, #4]

	struct finsh_node *node;
	struct finsh_node *end;
	struct finsh_node *assign;

    node = NULL;
 8020870:	2300      	movs	r3, #0
 8020872:	63bb      	str	r3, [r7, #56]	; 0x38
	end  = NULL;
 8020874:	2300      	movs	r3, #0
 8020876:	637b      	str	r3, [r7, #52]	; 0x34

	/* get type */
	type = proc_type(self);
 8020878:	6878      	ldr	r0, [r7, #4]
 802087a:	f000 f955 	bl	8020b28 <proc_type>
 802087e:	4603      	mov	r3, r0
 8020880:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

	/*process id.*/
	if (proc_identifier(self, id) == 0)
 8020884:	f107 030c 	add.w	r3, r7, #12
 8020888:	6878      	ldr	r0, [r7, #4]
 802088a:	4619      	mov	r1, r3
 802088c:	f000 fa1a 	bl	8020cc4 <proc_identifier>
 8020890:	4603      	mov	r3, r0
 8020892:	2b00      	cmp	r3, #0
 8020894:	d10d      	bne.n	80208b2 <proc_variable_decl+0x4a>
	{
		/* if add variable failed */
		if (finsh_var_insert(id, type) < 0)
 8020896:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 802089a:	f107 020c 	add.w	r2, r7, #12
 802089e:	4610      	mov	r0, r2
 80208a0:	4619      	mov	r1, r3
 80208a2:	f000 fefd 	bl	80216a0 <finsh_var_insert>
 80208a6:	4603      	mov	r3, r0
 80208a8:	2b00      	cmp	r3, #0
 80208aa:	da02      	bge.n	80208b2 <proc_variable_decl+0x4a>
		{
			finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
 80208ac:	2004      	movs	r0, #4
 80208ae:	f7fe fd25 	bl	801f2fc <finsh_error_set>
		}
	}

	next_token(token, &(self->token));
 80208b2:	687b      	ldr	r3, [r7, #4]
 80208b4:	3304      	adds	r3, #4
 80208b6:	4618      	mov	r0, r3
 80208b8:	f001 f844 	bl	8021944 <finsh_token_token>
 80208bc:	4603      	mov	r3, r0
 80208be:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
	switch ( token )
 80208c2:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 80208c6:	2b04      	cmp	r3, #4
 80208c8:	f000 8123 	beq.w	8020b12 <proc_variable_decl+0x2aa>
 80208cc:	2b0c      	cmp	r3, #12
 80208ce:	f000 80a3 	beq.w	8020a18 <proc_variable_decl+0x1b0>
 80208d2:	2b03      	cmp	r3, #3
 80208d4:	f040 811f 	bne.w	8020b16 <proc_variable_decl+0x2ae>
	{
	case finsh_token_type_comma:/*',', it's a variable_list declaration.*/
		if (proc_identifier(self, id) == 0)
 80208d8:	f107 030c 	add.w	r3, r7, #12
 80208dc:	6878      	ldr	r0, [r7, #4]
 80208de:	4619      	mov	r1, r3
 80208e0:	f000 f9f0 	bl	8020cc4 <proc_identifier>
 80208e4:	4603      	mov	r3, r0
 80208e6:	2b00      	cmp	r3, #0
 80208e8:	d10d      	bne.n	8020906 <proc_variable_decl+0x9e>
		{
			/* if add variable failed */
			if (finsh_var_insert(id, type) < 0)
 80208ea:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 80208ee:	f107 020c 	add.w	r2, r7, #12
 80208f2:	4610      	mov	r0, r2
 80208f4:	4619      	mov	r1, r3
 80208f6:	f000 fed3 	bl	80216a0 <finsh_var_insert>
 80208fa:	4603      	mov	r3, r0
 80208fc:	2b00      	cmp	r3, #0
 80208fe:	da02      	bge.n	8020906 <proc_variable_decl+0x9e>
			{
				finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
 8020900:	2004      	movs	r0, #4
 8020902:	f7fe fcfb 	bl	801f2fc <finsh_error_set>
			}
		}

		next_token(token, &(self->token));
 8020906:	687b      	ldr	r3, [r7, #4]
 8020908:	3304      	adds	r3, #4
 802090a:	4618      	mov	r0, r3
 802090c:	f001 f81a 	bl	8021944 <finsh_token_token>
 8020910:	4603      	mov	r3, r0
 8020912:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
		if ( token == finsh_token_type_assign )
 8020916:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 802091a:	2b0c      	cmp	r3, #12
 802091c:	d11c      	bne.n	8020958 <proc_variable_decl+0xf0>
		{
			/* get the right side of assign expression */
			assign = proc_assign_expr(self);
 802091e:	6878      	ldr	r0, [r7, #4]
 8020920:	f000 fa2a 	bl	8020d78 <proc_assign_expr>
 8020924:	62f8      	str	r0, [r7, #44]	; 0x2c

			if (assign != NULL)
 8020926:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8020928:	2b00      	cmp	r3, #0
 802092a:	d015      	beq.n	8020958 <proc_variable_decl+0xf0>
			{
				struct finsh_node* idnode;

				idnode = finsh_node_new_id(id);
 802092c:	f107 030c 	add.w	r3, r7, #12
 8020930:	4618      	mov	r0, r3
 8020932:	f7fe ff57 	bl	801f7e4 <finsh_node_new_id>
 8020936:	62b8      	str	r0, [r7, #40]	; 0x28
				end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
 8020938:	2013      	movs	r0, #19
 802093a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 802093c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 802093e:	f000 fdc5 	bl	80214cc <make_sys_node>
 8020942:	6378      	str	r0, [r7, #52]	; 0x34
				node = end;
 8020944:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8020946:	63bb      	str	r3, [r7, #56]	; 0x38

				next_token(token, &(self->token));
 8020948:	687b      	ldr	r3, [r7, #4]
 802094a:	3304      	adds	r3, #4
 802094c:	4618      	mov	r0, r3
 802094e:	f000 fff9 	bl	8021944 <finsh_token_token>
 8020952:	4603      	mov	r3, r0
 8020954:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
			}
		}

		while ( token == finsh_token_type_comma )
 8020958:	e04e      	b.n	80209f8 <proc_variable_decl+0x190>
		{
			if (proc_identifier(self, id) == 0)
 802095a:	f107 030c 	add.w	r3, r7, #12
 802095e:	6878      	ldr	r0, [r7, #4]
 8020960:	4619      	mov	r1, r3
 8020962:	f000 f9af 	bl	8020cc4 <proc_identifier>
 8020966:	4603      	mov	r3, r0
 8020968:	2b00      	cmp	r3, #0
 802096a:	d10d      	bne.n	8020988 <proc_variable_decl+0x120>
			{
				/* if add variable failed */
				if (finsh_var_insert(id, type) < 0)
 802096c:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8020970:	f107 020c 	add.w	r2, r7, #12
 8020974:	4610      	mov	r0, r2
 8020976:	4619      	mov	r1, r3
 8020978:	f000 fe92 	bl	80216a0 <finsh_var_insert>
 802097c:	4603      	mov	r3, r0
 802097e:	2b00      	cmp	r3, #0
 8020980:	da02      	bge.n	8020988 <proc_variable_decl+0x120>
				{
					finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
 8020982:	2004      	movs	r0, #4
 8020984:	f7fe fcba 	bl	801f2fc <finsh_error_set>
				}
			}

			next_token(token, &(self->token));
 8020988:	687b      	ldr	r3, [r7, #4]
 802098a:	3304      	adds	r3, #4
 802098c:	4618      	mov	r0, r3
 802098e:	f000 ffd9 	bl	8021944 <finsh_token_token>
 8020992:	4603      	mov	r3, r0
 8020994:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
			if ( token == finsh_token_type_assign )
 8020998:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 802099c:	2b0c      	cmp	r3, #12
 802099e:	d12b      	bne.n	80209f8 <proc_variable_decl+0x190>
			{
				/* get the right side of assign expression */
				assign = proc_assign_expr(self);
 80209a0:	6878      	ldr	r0, [r7, #4]
 80209a2:	f000 f9e9 	bl	8020d78 <proc_assign_expr>
 80209a6:	62f8      	str	r0, [r7, #44]	; 0x2c

				if (assign != NULL)
 80209a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80209aa:	2b00      	cmp	r3, #0
 80209ac:	d024      	beq.n	80209f8 <proc_variable_decl+0x190>
				{
					struct finsh_node* idnode;

					idnode = finsh_node_new_id(id);
 80209ae:	f107 030c 	add.w	r3, r7, #12
 80209b2:	4618      	mov	r0, r3
 80209b4:	f7fe ff16 	bl	801f7e4 <finsh_node_new_id>
 80209b8:	6278      	str	r0, [r7, #36]	; 0x24

					/* make assign expression node */
					if (node != NULL)
 80209ba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80209bc:	2b00      	cmp	r3, #0
 80209be:	d00b      	beq.n	80209d8 <proc_variable_decl+0x170>
					{
						finsh_node_sibling(end) = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
 80209c0:	2013      	movs	r0, #19
 80209c2:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80209c4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80209c6:	f000 fd81 	bl	80214cc <make_sys_node>
 80209ca:	4602      	mov	r2, r0
 80209cc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80209ce:	60da      	str	r2, [r3, #12]
						end = finsh_node_sibling(end);
 80209d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80209d2:	68db      	ldr	r3, [r3, #12]
 80209d4:	637b      	str	r3, [r7, #52]	; 0x34
 80209d6:	e007      	b.n	80209e8 <proc_variable_decl+0x180>
					}
					else
					{
						end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
 80209d8:	2013      	movs	r0, #19
 80209da:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80209dc:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80209de:	f000 fd75 	bl	80214cc <make_sys_node>
 80209e2:	6378      	str	r0, [r7, #52]	; 0x34
						node = end;
 80209e4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80209e6:	63bb      	str	r3, [r7, #56]	; 0x38
					}

					next_token(token, &(self->token));
 80209e8:	687b      	ldr	r3, [r7, #4]
 80209ea:	3304      	adds	r3, #4
 80209ec:	4618      	mov	r0, r3
 80209ee:	f000 ffa9 	bl	8021944 <finsh_token_token>
 80209f2:	4603      	mov	r3, r0
 80209f4:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f

				next_token(token, &(self->token));
			}
		}

		while ( token == finsh_token_type_comma )
 80209f8:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 80209fc:	2b03      	cmp	r3, #3
 80209fe:	d0ac      	beq.n	802095a <proc_variable_decl+0xf2>
					next_token(token, &(self->token));
				}
			}
		}

		check_token(token, &(self->token), finsh_token_type_semicolon);
 8020a00:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8020a04:	2b04      	cmp	r3, #4
 8020a06:	d005      	beq.n	8020a14 <proc_variable_decl+0x1ac>
 8020a08:	2001      	movs	r0, #1
 8020a0a:	f7fe fc77 	bl	801f2fc <finsh_error_set>
 8020a0e:	687b      	ldr	r3, [r7, #4]
 8020a10:	2201      	movs	r2, #1
 8020a12:	715a      	strb	r2, [r3, #5]
		return node;
 8020a14:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8020a16:	e082      	b.n	8020b1e <proc_variable_decl+0x2b6>

	case finsh_token_type_assign:/*'=', it's a variable with assign declaration.*/
	{
		struct finsh_node *idnode;

		assign = proc_assign_expr(self);
 8020a18:	6878      	ldr	r0, [r7, #4]
 8020a1a:	f000 f9ad 	bl	8020d78 <proc_assign_expr>
 8020a1e:	62f8      	str	r0, [r7, #44]	; 0x2c
		if (assign != NULL)
 8020a20:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8020a22:	2b00      	cmp	r3, #0
 8020a24:	d015      	beq.n	8020a52 <proc_variable_decl+0x1ea>
		{
			idnode = finsh_node_new_id(id);
 8020a26:	f107 030c 	add.w	r3, r7, #12
 8020a2a:	4618      	mov	r0, r3
 8020a2c:	f7fe feda 	bl	801f7e4 <finsh_node_new_id>
 8020a30:	6238      	str	r0, [r7, #32]

			/* make assign expression node */
			end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
 8020a32:	2013      	movs	r0, #19
 8020a34:	6a39      	ldr	r1, [r7, #32]
 8020a36:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8020a38:	f000 fd48 	bl	80214cc <make_sys_node>
 8020a3c:	6378      	str	r0, [r7, #52]	; 0x34
			node = end;
 8020a3e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8020a40:	63bb      	str	r3, [r7, #56]	; 0x38

			next_token(token, &(self->token));
 8020a42:	687b      	ldr	r3, [r7, #4]
 8020a44:	3304      	adds	r3, #4
 8020a46:	4618      	mov	r0, r3
 8020a48:	f000 ff7c 	bl	8021944 <finsh_token_token>
 8020a4c:	4603      	mov	r3, r0
 8020a4e:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
		}

		while ( token == finsh_token_type_comma )
 8020a52:	e04e      	b.n	8020af2 <proc_variable_decl+0x28a>
		{
			if (proc_identifier(self, id) == 0)
 8020a54:	f107 030c 	add.w	r3, r7, #12
 8020a58:	6878      	ldr	r0, [r7, #4]
 8020a5a:	4619      	mov	r1, r3
 8020a5c:	f000 f932 	bl	8020cc4 <proc_identifier>
 8020a60:	4603      	mov	r3, r0
 8020a62:	2b00      	cmp	r3, #0
 8020a64:	d10d      	bne.n	8020a82 <proc_variable_decl+0x21a>
			{
				/* if add variable failed */
				if (finsh_var_insert(id, type) < 0)
 8020a66:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8020a6a:	f107 020c 	add.w	r2, r7, #12
 8020a6e:	4610      	mov	r0, r2
 8020a70:	4619      	mov	r1, r3
 8020a72:	f000 fe15 	bl	80216a0 <finsh_var_insert>
 8020a76:	4603      	mov	r3, r0
 8020a78:	2b00      	cmp	r3, #0
 8020a7a:	da02      	bge.n	8020a82 <proc_variable_decl+0x21a>
				{
					finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
 8020a7c:	2004      	movs	r0, #4
 8020a7e:	f7fe fc3d 	bl	801f2fc <finsh_error_set>
				}
			}

			next_token(token, &(self->token));
 8020a82:	687b      	ldr	r3, [r7, #4]
 8020a84:	3304      	adds	r3, #4
 8020a86:	4618      	mov	r0, r3
 8020a88:	f000 ff5c 	bl	8021944 <finsh_token_token>
 8020a8c:	4603      	mov	r3, r0
 8020a8e:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
			if (token == finsh_token_type_assign)
 8020a92:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8020a96:	2b0c      	cmp	r3, #12
 8020a98:	d12b      	bne.n	8020af2 <proc_variable_decl+0x28a>
			{
				/* get the right side of assign expression */
				assign = proc_assign_expr(self);
 8020a9a:	6878      	ldr	r0, [r7, #4]
 8020a9c:	f000 f96c 	bl	8020d78 <proc_assign_expr>
 8020aa0:	62f8      	str	r0, [r7, #44]	; 0x2c

				if (assign != NULL)
 8020aa2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8020aa4:	2b00      	cmp	r3, #0
 8020aa6:	d024      	beq.n	8020af2 <proc_variable_decl+0x28a>
				{
					idnode = finsh_node_new_id(id);
 8020aa8:	f107 030c 	add.w	r3, r7, #12
 8020aac:	4618      	mov	r0, r3
 8020aae:	f7fe fe99 	bl	801f7e4 <finsh_node_new_id>
 8020ab2:	6238      	str	r0, [r7, #32]

					/* make assign expression node */
					if (node != NULL)
 8020ab4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8020ab6:	2b00      	cmp	r3, #0
 8020ab8:	d00b      	beq.n	8020ad2 <proc_variable_decl+0x26a>
					{
						finsh_node_sibling(end) = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
 8020aba:	2013      	movs	r0, #19
 8020abc:	6a39      	ldr	r1, [r7, #32]
 8020abe:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8020ac0:	f000 fd04 	bl	80214cc <make_sys_node>
 8020ac4:	4602      	mov	r2, r0
 8020ac6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8020ac8:	60da      	str	r2, [r3, #12]
						end = finsh_node_sibling(end);
 8020aca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8020acc:	68db      	ldr	r3, [r3, #12]
 8020ace:	637b      	str	r3, [r7, #52]	; 0x34
 8020ad0:	e007      	b.n	8020ae2 <proc_variable_decl+0x27a>
					}
					else
					{
						end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
 8020ad2:	2013      	movs	r0, #19
 8020ad4:	6a39      	ldr	r1, [r7, #32]
 8020ad6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8020ad8:	f000 fcf8 	bl	80214cc <make_sys_node>
 8020adc:	6378      	str	r0, [r7, #52]	; 0x34
						node = end;
 8020ade:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8020ae0:	63bb      	str	r3, [r7, #56]	; 0x38
					}

					next_token(token, &(self->token));
 8020ae2:	687b      	ldr	r3, [r7, #4]
 8020ae4:	3304      	adds	r3, #4
 8020ae6:	4618      	mov	r0, r3
 8020ae8:	f000 ff2c 	bl	8021944 <finsh_token_token>
 8020aec:	4603      	mov	r3, r0
 8020aee:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
			node = end;

			next_token(token, &(self->token));
		}

		while ( token == finsh_token_type_comma )
 8020af2:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8020af6:	2b03      	cmp	r3, #3
 8020af8:	d0ac      	beq.n	8020a54 <proc_variable_decl+0x1ec>
					next_token(token, &(self->token));
				}
			}
		}

		check_token(token, &(self->token), finsh_token_type_semicolon);
 8020afa:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8020afe:	2b04      	cmp	r3, #4
 8020b00:	d005      	beq.n	8020b0e <proc_variable_decl+0x2a6>
 8020b02:	2001      	movs	r0, #1
 8020b04:	f7fe fbfa 	bl	801f2fc <finsh_error_set>
 8020b08:	687b      	ldr	r3, [r7, #4]
 8020b0a:	2201      	movs	r2, #1
 8020b0c:	715a      	strb	r2, [r3, #5]
		return node;
 8020b0e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8020b10:	e005      	b.n	8020b1e <proc_variable_decl+0x2b6>
	}

	case finsh_token_type_semicolon:/*';', it's a variable declaration.*/
		return node;
 8020b12:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8020b14:	e003      	b.n	8020b1e <proc_variable_decl+0x2b6>

	default:
		finsh_error_set(FINSH_ERROR_EXPECT_TYPE);
 8020b16:	2002      	movs	r0, #2
 8020b18:	f7fe fbf0 	bl	801f2fc <finsh_error_set>

		return NULL;
 8020b1c:	2300      	movs	r3, #0
	}
}
 8020b1e:	4618      	mov	r0, r3
 8020b20:	3740      	adds	r7, #64	; 0x40
 8020b22:	46bd      	mov	sp, r7
 8020b24:	bd80      	pop	{r7, pc}
 8020b26:	bf00      	nop

08020b28 <proc_type>:
	| SHORT
	| INT
	| STRING
*/
static enum finsh_type proc_type(struct finsh_parser* self)
{
 8020b28:	b580      	push	{r7, lr}
 8020b2a:	b084      	sub	sp, #16
 8020b2c:	af00      	add	r7, sp, #0
 8020b2e:	6078      	str	r0, [r7, #4]
	enum finsh_type type;
	enum finsh_token_type token;

	/* set init type */
	type = finsh_type_unknown;
 8020b30:	2300      	movs	r3, #0
 8020b32:	73fb      	strb	r3, [r7, #15]

	next_token(token, &(self->token));
 8020b34:	687b      	ldr	r3, [r7, #4]
 8020b36:	3304      	adds	r3, #4
 8020b38:	4618      	mov	r0, r3
 8020b3a:	f000 ff03 	bl	8021944 <finsh_token_token>
 8020b3e:	4603      	mov	r3, r0
 8020b40:	73bb      	strb	r3, [r7, #14]
	if ( is_base_type(token) ) /* base_type */
 8020b42:	7bbb      	ldrb	r3, [r7, #14]
 8020b44:	2b14      	cmp	r3, #20
 8020b46:	d00b      	beq.n	8020b60 <proc_type+0x38>
 8020b48:	7bbb      	ldrb	r3, [r7, #14]
 8020b4a:	2b15      	cmp	r3, #21
 8020b4c:	d008      	beq.n	8020b60 <proc_type+0x38>
 8020b4e:	7bbb      	ldrb	r3, [r7, #14]
 8020b50:	2b16      	cmp	r3, #22
 8020b52:	d005      	beq.n	8020b60 <proc_type+0x38>
 8020b54:	7bbb      	ldrb	r3, [r7, #14]
 8020b56:	2b17      	cmp	r3, #23
 8020b58:	d002      	beq.n	8020b60 <proc_type+0x38>
 8020b5a:	7bbb      	ldrb	r3, [r7, #14]
 8020b5c:	2b18      	cmp	r3, #24
 8020b5e:	d121      	bne.n	8020ba4 <proc_type+0x7c>
	{
		switch (token)
 8020b60:	7bbb      	ldrb	r3, [r7, #14]
 8020b62:	3b14      	subs	r3, #20
 8020b64:	2b04      	cmp	r3, #4
 8020b66:	f200 809f 	bhi.w	8020ca8 <proc_type+0x180>
 8020b6a:	a201      	add	r2, pc, #4	; (adr r2, 8020b70 <proc_type+0x48>)
 8020b6c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8020b70:	08020b85 	.word	0x08020b85
 8020b74:	08020b8b 	.word	0x08020b8b
 8020b78:	08020b91 	.word	0x08020b91
 8020b7c:	08020b97 	.word	0x08020b97
 8020b80:	08020b9d 	.word	0x08020b9d
		{
		case finsh_token_type_void:
			type = finsh_type_void;
 8020b84:	2301      	movs	r3, #1
 8020b86:	73fb      	strb	r3, [r7, #15]
			break;
 8020b88:	e00b      	b.n	8020ba2 <proc_type+0x7a>

		case finsh_token_type_char:
			type = finsh_type_char;
 8020b8a:	2303      	movs	r3, #3
 8020b8c:	73fb      	strb	r3, [r7, #15]
			break;
 8020b8e:	e008      	b.n	8020ba2 <proc_type+0x7a>

		case finsh_token_type_short:
			type = finsh_type_short;
 8020b90:	2306      	movs	r3, #6
 8020b92:	73fb      	strb	r3, [r7, #15]
			break;
 8020b94:	e005      	b.n	8020ba2 <proc_type+0x7a>

		case finsh_token_type_int:
			type = finsh_type_int;
 8020b96:	2309      	movs	r3, #9
 8020b98:	73fb      	strb	r3, [r7, #15]
			break;
 8020b9a:	e002      	b.n	8020ba2 <proc_type+0x7a>

		case finsh_token_type_long:
			type = finsh_type_long;
 8020b9c:	230c      	movs	r3, #12
 8020b9e:	73fb      	strb	r3, [r7, #15]
			break;
 8020ba0:	bf00      	nop

		default:
			goto __return;
		}
	}
 8020ba2:	e03d      	b.n	8020c20 <proc_type+0xf8>
	else if ( token == finsh_token_type_unsigned ) /* unsigned base_type */
 8020ba4:	7bbb      	ldrb	r3, [r7, #14]
 8020ba6:	2b19      	cmp	r3, #25
 8020ba8:	d139      	bne.n	8020c1e <proc_type+0xf6>
	{
		next_token(token, &(self->token));
 8020baa:	687b      	ldr	r3, [r7, #4]
 8020bac:	3304      	adds	r3, #4
 8020bae:	4618      	mov	r0, r3
 8020bb0:	f000 fec8 	bl	8021944 <finsh_token_token>
 8020bb4:	4603      	mov	r3, r0
 8020bb6:	73bb      	strb	r3, [r7, #14]
		if ( is_base_type(token) )
 8020bb8:	7bbb      	ldrb	r3, [r7, #14]
 8020bba:	2b14      	cmp	r3, #20
 8020bbc:	d00b      	beq.n	8020bd6 <proc_type+0xae>
 8020bbe:	7bbb      	ldrb	r3, [r7, #14]
 8020bc0:	2b15      	cmp	r3, #21
 8020bc2:	d008      	beq.n	8020bd6 <proc_type+0xae>
 8020bc4:	7bbb      	ldrb	r3, [r7, #14]
 8020bc6:	2b16      	cmp	r3, #22
 8020bc8:	d005      	beq.n	8020bd6 <proc_type+0xae>
 8020bca:	7bbb      	ldrb	r3, [r7, #14]
 8020bcc:	2b17      	cmp	r3, #23
 8020bce:	d002      	beq.n	8020bd6 <proc_type+0xae>
 8020bd0:	7bbb      	ldrb	r3, [r7, #14]
 8020bd2:	2b18      	cmp	r3, #24
 8020bd4:	d11c      	bne.n	8020c10 <proc_type+0xe8>
		{
			switch (token)
 8020bd6:	7bbb      	ldrb	r3, [r7, #14]
 8020bd8:	3b15      	subs	r3, #21
 8020bda:	2b03      	cmp	r3, #3
 8020bdc:	d866      	bhi.n	8020cac <proc_type+0x184>
 8020bde:	a201      	add	r2, pc, #4	; (adr r2, 8020be4 <proc_type+0xbc>)
 8020be0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8020be4:	08020bf5 	.word	0x08020bf5
 8020be8:	08020bfb 	.word	0x08020bfb
 8020bec:	08020c01 	.word	0x08020c01
 8020bf0:	08020c07 	.word	0x08020c07
			{
			case finsh_token_type_char:
				type = finsh_type_uchar;
 8020bf4:	2304      	movs	r3, #4
 8020bf6:	73fb      	strb	r3, [r7, #15]
				break;
 8020bf8:	e008      	b.n	8020c0c <proc_type+0xe4>

			case finsh_token_type_short:
				type = finsh_type_ushort;
 8020bfa:	2307      	movs	r3, #7
 8020bfc:	73fb      	strb	r3, [r7, #15]
				break;
 8020bfe:	e005      	b.n	8020c0c <proc_type+0xe4>

			case finsh_token_type_int:
				type = finsh_type_uint;
 8020c00:	230a      	movs	r3, #10
 8020c02:	73fb      	strb	r3, [r7, #15]
				break;
 8020c04:	e002      	b.n	8020c0c <proc_type+0xe4>

			case finsh_token_type_long:
				type = finsh_type_ulong;
 8020c06:	230d      	movs	r3, #13
 8020c08:	73fb      	strb	r3, [r7, #15]
				break;
 8020c0a:	bf00      	nop

			default:
				goto __return;
			}
		}
 8020c0c:	bf00      	nop
 8020c0e:	e007      	b.n	8020c20 <proc_type+0xf8>
		else
		{
			finsh_token_replay(&(self->token));
 8020c10:	687b      	ldr	r3, [r7, #4]
 8020c12:	2201      	movs	r2, #1
 8020c14:	715a      	strb	r2, [r3, #5]
			finsh_error_set(FINSH_ERROR_EXPECT_TYPE);
 8020c16:	2002      	movs	r0, #2
 8020c18:	f7fe fb70 	bl	801f2fc <finsh_error_set>
 8020c1c:	e000      	b.n	8020c20 <proc_type+0xf8>
		}
	}
	else
	{
		goto __return;
 8020c1e:	e046      	b.n	8020cae <proc_type+0x186>
	}

	/* parse for pointer */
	next_token(token, &(self->token));
 8020c20:	687b      	ldr	r3, [r7, #4]
 8020c22:	3304      	adds	r3, #4
 8020c24:	4618      	mov	r0, r3
 8020c26:	f000 fe8d 	bl	8021944 <finsh_token_token>
 8020c2a:	4603      	mov	r3, r0
 8020c2c:	73bb      	strb	r3, [r7, #14]
	if (token == finsh_token_type_mul)
 8020c2e:	7bbb      	ldrb	r3, [r7, #14]
 8020c30:	2b05      	cmp	r3, #5
 8020c32:	d134      	bne.n	8020c9e <proc_type+0x176>
	{
		switch (type)
 8020c34:	7bfb      	ldrb	r3, [r7, #15]
 8020c36:	3b01      	subs	r3, #1
 8020c38:	2b0c      	cmp	r3, #12
 8020c3a:	d82c      	bhi.n	8020c96 <proc_type+0x16e>
 8020c3c:	a201      	add	r2, pc, #4	; (adr r2, 8020c44 <proc_type+0x11c>)
 8020c3e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8020c42:	bf00      	nop
 8020c44:	08020c79 	.word	0x08020c79
 8020c48:	08020c97 	.word	0x08020c97
 8020c4c:	08020c7f 	.word	0x08020c7f
 8020c50:	08020c7f 	.word	0x08020c7f
 8020c54:	08020c97 	.word	0x08020c97
 8020c58:	08020c85 	.word	0x08020c85
 8020c5c:	08020c85 	.word	0x08020c85
 8020c60:	08020c97 	.word	0x08020c97
 8020c64:	08020c8b 	.word	0x08020c8b
 8020c68:	08020c8b 	.word	0x08020c8b
 8020c6c:	08020c97 	.word	0x08020c97
 8020c70:	08020c91 	.word	0x08020c91
 8020c74:	08020c91 	.word	0x08020c91
		{
		case finsh_type_void:
			type = finsh_type_voidp;
 8020c78:	2302      	movs	r3, #2
 8020c7a:	73fb      	strb	r3, [r7, #15]
			break;
 8020c7c:	e00e      	b.n	8020c9c <proc_type+0x174>

		case finsh_type_char:
		case finsh_type_uchar:
			type = finsh_type_charp;
 8020c7e:	2305      	movs	r3, #5
 8020c80:	73fb      	strb	r3, [r7, #15]
			break;
 8020c82:	e00b      	b.n	8020c9c <proc_type+0x174>

		case finsh_type_short:
		case finsh_type_ushort:
			type = finsh_type_shortp;
 8020c84:	2308      	movs	r3, #8
 8020c86:	73fb      	strb	r3, [r7, #15]
			break;
 8020c88:	e008      	b.n	8020c9c <proc_type+0x174>

		case finsh_type_int:
		case finsh_type_uint:
			type = finsh_type_intp;
 8020c8a:	230b      	movs	r3, #11
 8020c8c:	73fb      	strb	r3, [r7, #15]
			break;
 8020c8e:	e005      	b.n	8020c9c <proc_type+0x174>

		case finsh_type_long:
		case finsh_type_ulong:
			type = finsh_type_longp;
 8020c90:	230e      	movs	r3, #14
 8020c92:	73fb      	strb	r3, [r7, #15]
			break;
 8020c94:	e002      	b.n	8020c9c <proc_type+0x174>

		default:
			type = finsh_type_voidp;
 8020c96:	2302      	movs	r3, #2
 8020c98:	73fb      	strb	r3, [r7, #15]
			break;
 8020c9a:	bf00      	nop
 8020c9c:	e002      	b.n	8020ca4 <proc_type+0x17c>
		}
	}
	else finsh_token_replay(&(self->token));
 8020c9e:	687b      	ldr	r3, [r7, #4]
 8020ca0:	2201      	movs	r2, #1
 8020ca2:	715a      	strb	r2, [r3, #5]

	return type;
 8020ca4:	7bfb      	ldrb	r3, [r7, #15]
 8020ca6:	e009      	b.n	8020cbc <proc_type+0x194>
		case finsh_token_type_long:
			type = finsh_type_long;
			break;

		default:
			goto __return;
 8020ca8:	bf00      	nop
 8020caa:	e000      	b.n	8020cae <proc_type+0x186>
			case finsh_token_type_long:
				type = finsh_type_ulong;
				break;

			default:
				goto __return;
 8020cac:	bf00      	nop
	else finsh_token_replay(&(self->token));

	return type;

__return:
	finsh_token_replay(&(self->token));
 8020cae:	687b      	ldr	r3, [r7, #4]
 8020cb0:	2201      	movs	r2, #1
 8020cb2:	715a      	strb	r2, [r3, #5]
	finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
 8020cb4:	2003      	movs	r0, #3
 8020cb6:	f7fe fb21 	bl	801f2fc <finsh_error_set>

	return type;
 8020cba:	7bfb      	ldrb	r3, [r7, #15]
}
 8020cbc:	4618      	mov	r0, r3
 8020cbe:	3710      	adds	r7, #16
 8020cc0:	46bd      	mov	sp, r7
 8020cc2:	bd80      	pop	{r7, pc}

08020cc4 <proc_identifier>:

/*
identifier -> IDENTIFIER
*/
static int proc_identifier(struct finsh_parser* self, char* id)
{
 8020cc4:	b580      	push	{r7, lr}
 8020cc6:	b084      	sub	sp, #16
 8020cc8:	af00      	add	r7, sp, #0
 8020cca:	6078      	str	r0, [r7, #4]
 8020ccc:	6039      	str	r1, [r7, #0]
	enum finsh_token_type token;

	match_token(token, &(self->token), finsh_token_type_identifier);
 8020cce:	687b      	ldr	r3, [r7, #4]
 8020cd0:	3304      	adds	r3, #4
 8020cd2:	4618      	mov	r0, r3
 8020cd4:	f000 fe36 	bl	8021944 <finsh_token_token>
 8020cd8:	4603      	mov	r3, r0
 8020cda:	73fb      	strb	r3, [r7, #15]
 8020cdc:	7bfb      	ldrb	r3, [r7, #15]
 8020cde:	2b1f      	cmp	r3, #31
 8020ce0:	d005      	beq.n	8020cee <proc_identifier+0x2a>
 8020ce2:	2001      	movs	r0, #1
 8020ce4:	f7fe fb0a 	bl	801f2fc <finsh_error_set>
 8020ce8:	687b      	ldr	r3, [r7, #4]
 8020cea:	2201      	movs	r2, #1
 8020cec:	715a      	strb	r2, [r3, #5]

	strncpy(id, (char*)self->token.string, FINSH_NAME_MAX);
 8020cee:	687b      	ldr	r3, [r7, #4]
 8020cf0:	3314      	adds	r3, #20
 8020cf2:	6838      	ldr	r0, [r7, #0]
 8020cf4:	4619      	mov	r1, r3
 8020cf6:	2210      	movs	r2, #16
 8020cf8:	f002 f9cc 	bl	8023094 <strncpy>

	return 0;
 8020cfc:	2300      	movs	r3, #0
}
 8020cfe:	4618      	mov	r0, r3
 8020d00:	3710      	adds	r7, #16
 8020d02:	46bd      	mov	sp, r7
 8020d04:	bd80      	pop	{r7, pc}
 8020d06:	bf00      	nop

08020d08 <proc_expr_statement>:
/*
statement_expr -> ';'
	| expr ';'
*/
static struct finsh_node* proc_expr_statement(struct finsh_parser* self)
{
 8020d08:	b580      	push	{r7, lr}
 8020d0a:	b084      	sub	sp, #16
 8020d0c:	af00      	add	r7, sp, #0
 8020d0e:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* expr;

	expr = NULL;
 8020d10:	2300      	movs	r3, #0
 8020d12:	60fb      	str	r3, [r7, #12]
	next_token(token, &(self->token));
 8020d14:	687b      	ldr	r3, [r7, #4]
 8020d16:	3304      	adds	r3, #4
 8020d18:	4618      	mov	r0, r3
 8020d1a:	f000 fe13 	bl	8021944 <finsh_token_token>
 8020d1e:	4603      	mov	r3, r0
 8020d20:	72fb      	strb	r3, [r7, #11]
	if ( token != finsh_token_type_semicolon )
 8020d22:	7afb      	ldrb	r3, [r7, #11]
 8020d24:	2b04      	cmp	r3, #4
 8020d26:	d016      	beq.n	8020d56 <proc_expr_statement+0x4e>
	{
		finsh_token_replay(&(self->token));
 8020d28:	687b      	ldr	r3, [r7, #4]
 8020d2a:	2201      	movs	r2, #1
 8020d2c:	715a      	strb	r2, [r3, #5]
		expr = proc_expr(self);
 8020d2e:	6878      	ldr	r0, [r7, #4]
 8020d30:	f000 f816 	bl	8020d60 <proc_expr>
 8020d34:	60f8      	str	r0, [r7, #12]

		match_token(token, &(self->token), finsh_token_type_semicolon);
 8020d36:	687b      	ldr	r3, [r7, #4]
 8020d38:	3304      	adds	r3, #4
 8020d3a:	4618      	mov	r0, r3
 8020d3c:	f000 fe02 	bl	8021944 <finsh_token_token>
 8020d40:	4603      	mov	r3, r0
 8020d42:	72fb      	strb	r3, [r7, #11]
 8020d44:	7afb      	ldrb	r3, [r7, #11]
 8020d46:	2b04      	cmp	r3, #4
 8020d48:	d005      	beq.n	8020d56 <proc_expr_statement+0x4e>
 8020d4a:	2001      	movs	r0, #1
 8020d4c:	f7fe fad6 	bl	801f2fc <finsh_error_set>
 8020d50:	687b      	ldr	r3, [r7, #4]
 8020d52:	2201      	movs	r2, #1
 8020d54:	715a      	strb	r2, [r3, #5]
	}

	return expr;
 8020d56:	68fb      	ldr	r3, [r7, #12]
}
 8020d58:	4618      	mov	r0, r3
 8020d5a:	3710      	adds	r7, #16
 8020d5c:	46bd      	mov	sp, r7
 8020d5e:	bd80      	pop	{r7, pc}

08020d60 <proc_expr>:

/*
expr -> expr_assign
*/
static struct finsh_node* proc_expr(struct finsh_parser* self)
{
 8020d60:	b580      	push	{r7, lr}
 8020d62:	b082      	sub	sp, #8
 8020d64:	af00      	add	r7, sp, #0
 8020d66:	6078      	str	r0, [r7, #4]
	return proc_assign_expr(self);
 8020d68:	6878      	ldr	r0, [r7, #4]
 8020d6a:	f000 f805 	bl	8020d78 <proc_assign_expr>
 8020d6e:	4603      	mov	r3, r0
}
 8020d70:	4618      	mov	r0, r3
 8020d72:	3708      	adds	r7, #8
 8020d74:	46bd      	mov	sp, r7
 8020d76:	bd80      	pop	{r7, pc}

08020d78 <proc_assign_expr>:
/*
expr_assign -> expr_inclusive_or
	| expr_unary ASSIGN expr_assign
*/
static struct finsh_node* proc_assign_expr(struct finsh_parser* self)
{
 8020d78:	b580      	push	{r7, lr}
 8020d7a:	b086      	sub	sp, #24
 8020d7c:	af00      	add	r7, sp, #0
 8020d7e:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* or;
	struct finsh_node* assign;

	or = proc_inclusive_or_expr(self);
 8020d80:	6878      	ldr	r0, [r7, #4]
 8020d82:	f000 f81f 	bl	8020dc4 <proc_inclusive_or_expr>
 8020d86:	6178      	str	r0, [r7, #20]

	next_token(token, &(self->token));
 8020d88:	687b      	ldr	r3, [r7, #4]
 8020d8a:	3304      	adds	r3, #4
 8020d8c:	4618      	mov	r0, r3
 8020d8e:	f000 fdd9 	bl	8021944 <finsh_token_token>
 8020d92:	4603      	mov	r3, r0
 8020d94:	74fb      	strb	r3, [r7, #19]

	if (token == finsh_token_type_assign)
 8020d96:	7cfb      	ldrb	r3, [r7, #19]
 8020d98:	2b0c      	cmp	r3, #12
 8020d9a:	d10a      	bne.n	8020db2 <proc_assign_expr+0x3a>
	{
		assign = proc_assign_expr(self);
 8020d9c:	6878      	ldr	r0, [r7, #4]
 8020d9e:	f7ff ffeb 	bl	8020d78 <proc_assign_expr>
 8020da2:	60f8      	str	r0, [r7, #12]

		return make_sys_node(FINSH_NODE_SYS_ASSIGN, or, assign);
 8020da4:	2013      	movs	r0, #19
 8020da6:	6979      	ldr	r1, [r7, #20]
 8020da8:	68fa      	ldr	r2, [r7, #12]
 8020daa:	f000 fb8f 	bl	80214cc <make_sys_node>
 8020dae:	4603      	mov	r3, r0
 8020db0:	e003      	b.n	8020dba <proc_assign_expr+0x42>
	}
	else finsh_token_replay(&(self->token));
 8020db2:	687b      	ldr	r3, [r7, #4]
 8020db4:	2201      	movs	r2, #1
 8020db6:	715a      	strb	r2, [r3, #5]

	return or;
 8020db8:	697b      	ldr	r3, [r7, #20]
}
 8020dba:	4618      	mov	r0, r3
 8020dbc:	3718      	adds	r7, #24
 8020dbe:	46bd      	mov	sp, r7
 8020dc0:	bd80      	pop	{r7, pc}
 8020dc2:	bf00      	nop

08020dc4 <proc_inclusive_or_expr>:
/*
expr_inclusive_or -> expr_exclusive_or
	| expr_inclusive_or '|' expr_exclusive_or
*/
static struct finsh_node* proc_inclusive_or_expr(struct finsh_parser* self)
{
 8020dc4:	b580      	push	{r7, lr}
 8020dc6:	b086      	sub	sp, #24
 8020dc8:	af00      	add	r7, sp, #0
 8020dca:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* xor;
	struct finsh_node* xor_new;

	xor = proc_exclusive_or_expr(self);
 8020dcc:	6878      	ldr	r0, [r7, #4]
 8020dce:	f000 f82d 	bl	8020e2c <proc_exclusive_or_expr>
 8020dd2:	6138      	str	r0, [r7, #16]

	next_token(token, &(self->token));
 8020dd4:	687b      	ldr	r3, [r7, #4]
 8020dd6:	3304      	adds	r3, #4
 8020dd8:	4618      	mov	r0, r3
 8020dda:	f000 fdb3 	bl	8021944 <finsh_token_token>
 8020dde:	4603      	mov	r3, r0
 8020de0:	75fb      	strb	r3, [r7, #23]
	while ( token == finsh_token_type_or )
 8020de2:	e017      	b.n	8020e14 <proc_inclusive_or_expr+0x50>
	{
		xor_new = proc_exclusive_or_expr(self);
 8020de4:	6878      	ldr	r0, [r7, #4]
 8020de6:	f000 f821 	bl	8020e2c <proc_exclusive_or_expr>
 8020dea:	60f8      	str	r0, [r7, #12]

		if (xor_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 8020dec:	68fb      	ldr	r3, [r7, #12]
 8020dee:	2b00      	cmp	r3, #0
 8020df0:	d103      	bne.n	8020dfa <proc_inclusive_or_expr+0x36>
 8020df2:	2005      	movs	r0, #5
 8020df4:	f7fe fa82 	bl	801f2fc <finsh_error_set>
 8020df8:	e005      	b.n	8020e06 <proc_inclusive_or_expr+0x42>
		else xor = make_sys_node(FINSH_NODE_SYS_OR, xor, xor_new);
 8020dfa:	200d      	movs	r0, #13
 8020dfc:	6939      	ldr	r1, [r7, #16]
 8020dfe:	68fa      	ldr	r2, [r7, #12]
 8020e00:	f000 fb64 	bl	80214cc <make_sys_node>
 8020e04:	6138      	str	r0, [r7, #16]

		next_token(token, &(self->token));
 8020e06:	687b      	ldr	r3, [r7, #4]
 8020e08:	3304      	adds	r3, #4
 8020e0a:	4618      	mov	r0, r3
 8020e0c:	f000 fd9a 	bl	8021944 <finsh_token_token>
 8020e10:	4603      	mov	r3, r0
 8020e12:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* xor_new;

	xor = proc_exclusive_or_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_or )
 8020e14:	7dfb      	ldrb	r3, [r7, #23]
 8020e16:	2b0e      	cmp	r3, #14
 8020e18:	d0e4      	beq.n	8020de4 <proc_inclusive_or_expr+0x20>
		else xor = make_sys_node(FINSH_NODE_SYS_OR, xor, xor_new);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 8020e1a:	687b      	ldr	r3, [r7, #4]
 8020e1c:	2201      	movs	r2, #1
 8020e1e:	715a      	strb	r2, [r3, #5]
	return xor;
 8020e20:	693b      	ldr	r3, [r7, #16]
}
 8020e22:	4618      	mov	r0, r3
 8020e24:	3718      	adds	r7, #24
 8020e26:	46bd      	mov	sp, r7
 8020e28:	bd80      	pop	{r7, pc}
 8020e2a:	bf00      	nop

08020e2c <proc_exclusive_or_expr>:
/*
expr_exclusive_or -> expr_and
	| expr_exclusive '^' expr_and
*/
static struct finsh_node* proc_exclusive_or_expr(struct finsh_parser* self)
{
 8020e2c:	b580      	push	{r7, lr}
 8020e2e:	b086      	sub	sp, #24
 8020e30:	af00      	add	r7, sp, #0
 8020e32:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* and;
	struct finsh_node* and_new;

	and = proc_and_expr(self);
 8020e34:	6878      	ldr	r0, [r7, #4]
 8020e36:	f000 f82d 	bl	8020e94 <proc_and_expr>
 8020e3a:	6138      	str	r0, [r7, #16]
	next_token(token, &(self->token));
 8020e3c:	687b      	ldr	r3, [r7, #4]
 8020e3e:	3304      	adds	r3, #4
 8020e40:	4618      	mov	r0, r3
 8020e42:	f000 fd7f 	bl	8021944 <finsh_token_token>
 8020e46:	4603      	mov	r3, r0
 8020e48:	75fb      	strb	r3, [r7, #23]
	while ( token == finsh_token_type_xor )
 8020e4a:	e017      	b.n	8020e7c <proc_exclusive_or_expr+0x50>
	{
		and_new = proc_and_expr(self);
 8020e4c:	6878      	ldr	r0, [r7, #4]
 8020e4e:	f000 f821 	bl	8020e94 <proc_and_expr>
 8020e52:	60f8      	str	r0, [r7, #12]
		if (and_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 8020e54:	68fb      	ldr	r3, [r7, #12]
 8020e56:	2b00      	cmp	r3, #0
 8020e58:	d103      	bne.n	8020e62 <proc_exclusive_or_expr+0x36>
 8020e5a:	2005      	movs	r0, #5
 8020e5c:	f7fe fa4e 	bl	801f2fc <finsh_error_set>
 8020e60:	e005      	b.n	8020e6e <proc_exclusive_or_expr+0x42>
		else and = make_sys_node(FINSH_NODE_SYS_XOR, and, and_new);
 8020e62:	200e      	movs	r0, #14
 8020e64:	6939      	ldr	r1, [r7, #16]
 8020e66:	68fa      	ldr	r2, [r7, #12]
 8020e68:	f000 fb30 	bl	80214cc <make_sys_node>
 8020e6c:	6138      	str	r0, [r7, #16]

		next_token(token, &(self->token));
 8020e6e:	687b      	ldr	r3, [r7, #4]
 8020e70:	3304      	adds	r3, #4
 8020e72:	4618      	mov	r0, r3
 8020e74:	f000 fd66 	bl	8021944 <finsh_token_token>
 8020e78:	4603      	mov	r3, r0
 8020e7a:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* and;
	struct finsh_node* and_new;

	and = proc_and_expr(self);
	next_token(token, &(self->token));
	while ( token == finsh_token_type_xor )
 8020e7c:	7dfb      	ldrb	r3, [r7, #23]
 8020e7e:	2b0f      	cmp	r3, #15
 8020e80:	d0e4      	beq.n	8020e4c <proc_exclusive_or_expr+0x20>
		else and = make_sys_node(FINSH_NODE_SYS_XOR, and, and_new);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 8020e82:	687b      	ldr	r3, [r7, #4]
 8020e84:	2201      	movs	r2, #1
 8020e86:	715a      	strb	r2, [r3, #5]
	return and;
 8020e88:	693b      	ldr	r3, [r7, #16]
}
 8020e8a:	4618      	mov	r0, r3
 8020e8c:	3718      	adds	r7, #24
 8020e8e:	46bd      	mov	sp, r7
 8020e90:	bd80      	pop	{r7, pc}
 8020e92:	bf00      	nop

08020e94 <proc_and_expr>:
/*
expr_and -> expr_shift
	| expr_and '&' expr_shift
*/
static struct finsh_node* proc_and_expr(struct finsh_parser* self)
{
 8020e94:	b580      	push	{r7, lr}
 8020e96:	b086      	sub	sp, #24
 8020e98:	af00      	add	r7, sp, #0
 8020e9a:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* shift;
	struct finsh_node* shift_new;

	shift = proc_shift_expr(self);
 8020e9c:	6878      	ldr	r0, [r7, #4]
 8020e9e:	f000 f82d 	bl	8020efc <proc_shift_expr>
 8020ea2:	6138      	str	r0, [r7, #16]

	next_token(token, &(self->token));
 8020ea4:	687b      	ldr	r3, [r7, #4]
 8020ea6:	3304      	adds	r3, #4
 8020ea8:	4618      	mov	r0, r3
 8020eaa:	f000 fd4b 	bl	8021944 <finsh_token_token>
 8020eae:	4603      	mov	r3, r0
 8020eb0:	75fb      	strb	r3, [r7, #23]
	while ( token == finsh_token_type_and )
 8020eb2:	e017      	b.n	8020ee4 <proc_and_expr+0x50>
	{
		shift_new = proc_shift_expr(self);
 8020eb4:	6878      	ldr	r0, [r7, #4]
 8020eb6:	f000 f821 	bl	8020efc <proc_shift_expr>
 8020eba:	60f8      	str	r0, [r7, #12]

		if (shift_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 8020ebc:	68fb      	ldr	r3, [r7, #12]
 8020ebe:	2b00      	cmp	r3, #0
 8020ec0:	d103      	bne.n	8020eca <proc_and_expr+0x36>
 8020ec2:	2005      	movs	r0, #5
 8020ec4:	f7fe fa1a 	bl	801f2fc <finsh_error_set>
 8020ec8:	e005      	b.n	8020ed6 <proc_and_expr+0x42>
		else shift = make_sys_node(FINSH_NODE_SYS_AND, shift, shift_new);
 8020eca:	200c      	movs	r0, #12
 8020ecc:	6939      	ldr	r1, [r7, #16]
 8020ece:	68fa      	ldr	r2, [r7, #12]
 8020ed0:	f000 fafc 	bl	80214cc <make_sys_node>
 8020ed4:	6138      	str	r0, [r7, #16]

		next_token(token, &(self->token));
 8020ed6:	687b      	ldr	r3, [r7, #4]
 8020ed8:	3304      	adds	r3, #4
 8020eda:	4618      	mov	r0, r3
 8020edc:	f000 fd32 	bl	8021944 <finsh_token_token>
 8020ee0:	4603      	mov	r3, r0
 8020ee2:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* shift_new;

	shift = proc_shift_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_and )
 8020ee4:	7dfb      	ldrb	r3, [r7, #23]
 8020ee6:	2b0d      	cmp	r3, #13
 8020ee8:	d0e4      	beq.n	8020eb4 <proc_and_expr+0x20>
		else shift = make_sys_node(FINSH_NODE_SYS_AND, shift, shift_new);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 8020eea:	687b      	ldr	r3, [r7, #4]
 8020eec:	2201      	movs	r2, #1
 8020eee:	715a      	strb	r2, [r3, #5]
	return shift;
 8020ef0:	693b      	ldr	r3, [r7, #16]
}
 8020ef2:	4618      	mov	r0, r3
 8020ef4:	3718      	adds	r7, #24
 8020ef6:	46bd      	mov	sp, r7
 8020ef8:	bd80      	pop	{r7, pc}
 8020efa:	bf00      	nop

08020efc <proc_shift_expr>:
expr_shift -> expr_additive
	| expr_shift '<<' expr_additive
	| expr_shift '>>' expr_additive
*/
static struct finsh_node* proc_shift_expr(struct finsh_parser* self)
{
 8020efc:	b580      	push	{r7, lr}
 8020efe:	b086      	sub	sp, #24
 8020f00:	af00      	add	r7, sp, #0
 8020f02:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* add;
	struct finsh_node* add_new;

	add = proc_additive_expr(self);
 8020f04:	6878      	ldr	r0, [r7, #4]
 8020f06:	f000 f841 	bl	8020f8c <proc_additive_expr>
 8020f0a:	6138      	str	r0, [r7, #16]

	next_token(token, &(self->token));
 8020f0c:	687b      	ldr	r3, [r7, #4]
 8020f0e:	3304      	adds	r3, #4
 8020f10:	4618      	mov	r0, r3
 8020f12:	f000 fd17 	bl	8021944 <finsh_token_token>
 8020f16:	4603      	mov	r3, r0
 8020f18:	75fb      	strb	r3, [r7, #23]
	while ( token == finsh_token_type_shl || token == finsh_token_type_shr)
 8020f1a:	e029      	b.n	8020f70 <proc_shift_expr+0x74>
	{
		add_new = proc_additive_expr(self);
 8020f1c:	6878      	ldr	r0, [r7, #4]
 8020f1e:	f000 f835 	bl	8020f8c <proc_additive_expr>
 8020f22:	60f8      	str	r0, [r7, #12]
		if (add_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 8020f24:	68fb      	ldr	r3, [r7, #12]
 8020f26:	2b00      	cmp	r3, #0
 8020f28:	d103      	bne.n	8020f32 <proc_shift_expr+0x36>
 8020f2a:	2005      	movs	r0, #5
 8020f2c:	f7fe f9e6 	bl	801f2fc <finsh_error_set>
 8020f30:	e017      	b.n	8020f62 <proc_shift_expr+0x66>
		else
		{
			switch (token)
 8020f32:	7dfb      	ldrb	r3, [r7, #23]
 8020f34:	2b11      	cmp	r3, #17
 8020f36:	d002      	beq.n	8020f3e <proc_shift_expr+0x42>
 8020f38:	2b12      	cmp	r3, #18
 8020f3a:	d007      	beq.n	8020f4c <proc_shift_expr+0x50>
 8020f3c:	e00d      	b.n	8020f5a <proc_shift_expr+0x5e>
			{
			case finsh_token_type_shl:
				add = make_sys_node(FINSH_NODE_SYS_SHL, add, add_new);
 8020f3e:	2010      	movs	r0, #16
 8020f40:	6939      	ldr	r1, [r7, #16]
 8020f42:	68fa      	ldr	r2, [r7, #12]
 8020f44:	f000 fac2 	bl	80214cc <make_sys_node>
 8020f48:	6138      	str	r0, [r7, #16]
				break;
 8020f4a:	e00a      	b.n	8020f62 <proc_shift_expr+0x66>
			case finsh_token_type_shr:
				add = make_sys_node(FINSH_NODE_SYS_SHR, add, add_new);
 8020f4c:	2011      	movs	r0, #17
 8020f4e:	6939      	ldr	r1, [r7, #16]
 8020f50:	68fa      	ldr	r2, [r7, #12]
 8020f52:	f000 fabb 	bl	80214cc <make_sys_node>
 8020f56:	6138      	str	r0, [r7, #16]
				break;
 8020f58:	e003      	b.n	8020f62 <proc_shift_expr+0x66>
			default:
				finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 8020f5a:	2005      	movs	r0, #5
 8020f5c:	f7fe f9ce 	bl	801f2fc <finsh_error_set>
				break;
 8020f60:	bf00      	nop
			}
		}
		next_token(token, &(self->token));
 8020f62:	687b      	ldr	r3, [r7, #4]
 8020f64:	3304      	adds	r3, #4
 8020f66:	4618      	mov	r0, r3
 8020f68:	f000 fcec 	bl	8021944 <finsh_token_token>
 8020f6c:	4603      	mov	r3, r0
 8020f6e:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* add_new;

	add = proc_additive_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_shl || token == finsh_token_type_shr)
 8020f70:	7dfb      	ldrb	r3, [r7, #23]
 8020f72:	2b11      	cmp	r3, #17
 8020f74:	d0d2      	beq.n	8020f1c <proc_shift_expr+0x20>
 8020f76:	7dfb      	ldrb	r3, [r7, #23]
 8020f78:	2b12      	cmp	r3, #18
 8020f7a:	d0cf      	beq.n	8020f1c <proc_shift_expr+0x20>
			}
		}
		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 8020f7c:	687b      	ldr	r3, [r7, #4]
 8020f7e:	2201      	movs	r2, #1
 8020f80:	715a      	strb	r2, [r3, #5]
	return add;
 8020f82:	693b      	ldr	r3, [r7, #16]
}
 8020f84:	4618      	mov	r0, r3
 8020f86:	3718      	adds	r7, #24
 8020f88:	46bd      	mov	sp, r7
 8020f8a:	bd80      	pop	{r7, pc}

08020f8c <proc_additive_expr>:
expr_additive -> expr_multiplicative
	| expr_additive SUB expr_multiplicative
	| expr_additive ADD expr_multiplicative
*/
static struct finsh_node* proc_additive_expr(struct finsh_parser* self)
{
 8020f8c:	b580      	push	{r7, lr}
 8020f8e:	b086      	sub	sp, #24
 8020f90:	af00      	add	r7, sp, #0
 8020f92:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* mul;
	struct finsh_node* mul_new;

	mul = proc_multiplicative_expr(self);
 8020f94:	6878      	ldr	r0, [r7, #4]
 8020f96:	f000 f841 	bl	802101c <proc_multiplicative_expr>
 8020f9a:	6138      	str	r0, [r7, #16]

	next_token(token, &(self->token));
 8020f9c:	687b      	ldr	r3, [r7, #4]
 8020f9e:	3304      	adds	r3, #4
 8020fa0:	4618      	mov	r0, r3
 8020fa2:	f000 fccf 	bl	8021944 <finsh_token_token>
 8020fa6:	4603      	mov	r3, r0
 8020fa8:	75fb      	strb	r3, [r7, #23]
	while ( token == finsh_token_type_sub || token == finsh_token_type_add )
 8020faa:	e028      	b.n	8020ffe <proc_additive_expr+0x72>
	{
		mul_new = proc_multiplicative_expr(self);
 8020fac:	6878      	ldr	r0, [r7, #4]
 8020fae:	f000 f835 	bl	802101c <proc_multiplicative_expr>
 8020fb2:	60f8      	str	r0, [r7, #12]
		if (mul_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 8020fb4:	68fb      	ldr	r3, [r7, #12]
 8020fb6:	2b00      	cmp	r3, #0
 8020fb8:	d103      	bne.n	8020fc2 <proc_additive_expr+0x36>
 8020fba:	2005      	movs	r0, #5
 8020fbc:	f7fe f99e 	bl	801f2fc <finsh_error_set>
 8020fc0:	e016      	b.n	8020ff0 <proc_additive_expr+0x64>
		else
		{
			switch (token)
 8020fc2:	7dfb      	ldrb	r3, [r7, #23]
 8020fc4:	2b06      	cmp	r3, #6
 8020fc6:	d008      	beq.n	8020fda <proc_additive_expr+0x4e>
 8020fc8:	2b08      	cmp	r3, #8
 8020fca:	d10d      	bne.n	8020fe8 <proc_additive_expr+0x5c>
			{
			case finsh_token_type_sub:
				mul = make_sys_node(FINSH_NODE_SYS_SUB, mul, mul_new);
 8020fcc:	2008      	movs	r0, #8
 8020fce:	6939      	ldr	r1, [r7, #16]
 8020fd0:	68fa      	ldr	r2, [r7, #12]
 8020fd2:	f000 fa7b 	bl	80214cc <make_sys_node>
 8020fd6:	6138      	str	r0, [r7, #16]
				break;
 8020fd8:	e00a      	b.n	8020ff0 <proc_additive_expr+0x64>
			case finsh_token_type_add:
				mul = make_sys_node(FINSH_NODE_SYS_ADD, mul, mul_new);
 8020fda:	2007      	movs	r0, #7
 8020fdc:	6939      	ldr	r1, [r7, #16]
 8020fde:	68fa      	ldr	r2, [r7, #12]
 8020fe0:	f000 fa74 	bl	80214cc <make_sys_node>
 8020fe4:	6138      	str	r0, [r7, #16]
				break;
 8020fe6:	e003      	b.n	8020ff0 <proc_additive_expr+0x64>
			default:
				finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 8020fe8:	2005      	movs	r0, #5
 8020fea:	f7fe f987 	bl	801f2fc <finsh_error_set>
				break;
 8020fee:	bf00      	nop
			}
		}
		next_token(token, &(self->token));
 8020ff0:	687b      	ldr	r3, [r7, #4]
 8020ff2:	3304      	adds	r3, #4
 8020ff4:	4618      	mov	r0, r3
 8020ff6:	f000 fca5 	bl	8021944 <finsh_token_token>
 8020ffa:	4603      	mov	r3, r0
 8020ffc:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* mul_new;

	mul = proc_multiplicative_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_sub || token == finsh_token_type_add )
 8020ffe:	7dfb      	ldrb	r3, [r7, #23]
 8021000:	2b08      	cmp	r3, #8
 8021002:	d0d3      	beq.n	8020fac <proc_additive_expr+0x20>
 8021004:	7dfb      	ldrb	r3, [r7, #23]
 8021006:	2b06      	cmp	r3, #6
 8021008:	d0d0      	beq.n	8020fac <proc_additive_expr+0x20>
			}
		}
		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 802100a:	687b      	ldr	r3, [r7, #4]
 802100c:	2201      	movs	r2, #1
 802100e:	715a      	strb	r2, [r3, #5]
	return mul;
 8021010:	693b      	ldr	r3, [r7, #16]
}
 8021012:	4618      	mov	r0, r3
 8021014:	3718      	adds	r7, #24
 8021016:	46bd      	mov	sp, r7
 8021018:	bd80      	pop	{r7, pc}
 802101a:	bf00      	nop

0802101c <proc_multiplicative_expr>:
	| expr_multiplicative '*' expr_cast
	| expr_multiplicative '/' expr_cast
	| expr_multiplicative '%' expr_cast
*/
static struct finsh_node* proc_multiplicative_expr(struct finsh_parser* self)
{
 802101c:	b580      	push	{r7, lr}
 802101e:	b086      	sub	sp, #24
 8021020:	af00      	add	r7, sp, #0
 8021022:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* cast;
	struct finsh_node* cast_new;

	cast = proc_cast_expr(self);
 8021024:	6878      	ldr	r0, [r7, #4]
 8021026:	f000 f84d 	bl	80210c4 <proc_cast_expr>
 802102a:	6138      	str	r0, [r7, #16]
	next_token(token, &(self->token));
 802102c:	687b      	ldr	r3, [r7, #4]
 802102e:	3304      	adds	r3, #4
 8021030:	4618      	mov	r0, r3
 8021032:	f000 fc87 	bl	8021944 <finsh_token_token>
 8021036:	4603      	mov	r3, r0
 8021038:	75fb      	strb	r3, [r7, #23]
	while (token == finsh_token_type_mul ||
 802103a:	e031      	b.n	80210a0 <proc_multiplicative_expr+0x84>
		token == finsh_token_type_div ||
		token == finsh_token_type_mod )
	{
		cast_new = proc_cast_expr(self);
 802103c:	6878      	ldr	r0, [r7, #4]
 802103e:	f000 f841 	bl	80210c4 <proc_cast_expr>
 8021042:	60f8      	str	r0, [r7, #12]
		if (cast_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 8021044:	68fb      	ldr	r3, [r7, #12]
 8021046:	2b00      	cmp	r3, #0
 8021048:	d103      	bne.n	8021052 <proc_multiplicative_expr+0x36>
 802104a:	2005      	movs	r0, #5
 802104c:	f7fe f956 	bl	801f2fc <finsh_error_set>
 8021050:	e01f      	b.n	8021092 <proc_multiplicative_expr+0x76>
		else
		{
			switch (token)
 8021052:	7dfb      	ldrb	r3, [r7, #23]
 8021054:	2b0a      	cmp	r3, #10
 8021056:	d00a      	beq.n	802106e <proc_multiplicative_expr+0x52>
 8021058:	2b0b      	cmp	r3, #11
 802105a:	d00f      	beq.n	802107c <proc_multiplicative_expr+0x60>
 802105c:	2b05      	cmp	r3, #5
 802105e:	d114      	bne.n	802108a <proc_multiplicative_expr+0x6e>
			{
			case finsh_token_type_mul:
				cast = make_sys_node(FINSH_NODE_SYS_MUL, cast, cast_new);
 8021060:	2009      	movs	r0, #9
 8021062:	6939      	ldr	r1, [r7, #16]
 8021064:	68fa      	ldr	r2, [r7, #12]
 8021066:	f000 fa31 	bl	80214cc <make_sys_node>
 802106a:	6138      	str	r0, [r7, #16]
				break;
 802106c:	e011      	b.n	8021092 <proc_multiplicative_expr+0x76>

			case finsh_token_type_div:
				cast = make_sys_node(FINSH_NODE_SYS_DIV, cast, cast_new);
 802106e:	200a      	movs	r0, #10
 8021070:	6939      	ldr	r1, [r7, #16]
 8021072:	68fa      	ldr	r2, [r7, #12]
 8021074:	f000 fa2a 	bl	80214cc <make_sys_node>
 8021078:	6138      	str	r0, [r7, #16]
				break;
 802107a:	e00a      	b.n	8021092 <proc_multiplicative_expr+0x76>

			case finsh_token_type_mod:
				cast = make_sys_node(FINSH_NODE_SYS_MOD, cast, cast_new);
 802107c:	200b      	movs	r0, #11
 802107e:	6939      	ldr	r1, [r7, #16]
 8021080:	68fa      	ldr	r2, [r7, #12]
 8021082:	f000 fa23 	bl	80214cc <make_sys_node>
 8021086:	6138      	str	r0, [r7, #16]
				break;
 8021088:	e003      	b.n	8021092 <proc_multiplicative_expr+0x76>

			default:
				finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 802108a:	2005      	movs	r0, #5
 802108c:	f7fe f936 	bl	801f2fc <finsh_error_set>
				break;
 8021090:	bf00      	nop
			}
		}
		next_token(token, &(self->token));
 8021092:	687b      	ldr	r3, [r7, #4]
 8021094:	3304      	adds	r3, #4
 8021096:	4618      	mov	r0, r3
 8021098:	f000 fc54 	bl	8021944 <finsh_token_token>
 802109c:	4603      	mov	r3, r0
 802109e:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* cast;
	struct finsh_node* cast_new;

	cast = proc_cast_expr(self);
	next_token(token, &(self->token));
	while (token == finsh_token_type_mul ||
 80210a0:	7dfb      	ldrb	r3, [r7, #23]
 80210a2:	2b05      	cmp	r3, #5
 80210a4:	d0ca      	beq.n	802103c <proc_multiplicative_expr+0x20>
 80210a6:	7dfb      	ldrb	r3, [r7, #23]
 80210a8:	2b0a      	cmp	r3, #10
 80210aa:	d0c7      	beq.n	802103c <proc_multiplicative_expr+0x20>
		token == finsh_token_type_div ||
 80210ac:	7dfb      	ldrb	r3, [r7, #23]
 80210ae:	2b0b      	cmp	r3, #11
 80210b0:	d0c4      	beq.n	802103c <proc_multiplicative_expr+0x20>
			}
		}
		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 80210b2:	687b      	ldr	r3, [r7, #4]
 80210b4:	2201      	movs	r2, #1
 80210b6:	715a      	strb	r2, [r3, #5]
	return cast;
 80210b8:	693b      	ldr	r3, [r7, #16]
}
 80210ba:	4618      	mov	r0, r3
 80210bc:	3718      	adds	r7, #24
 80210be:	46bd      	mov	sp, r7
 80210c0:	bd80      	pop	{r7, pc}
 80210c2:	bf00      	nop

080210c4 <proc_cast_expr>:
20060313, add recast parse
expr_cast -> expr_unary
	| '(' type ')' expr_cast
*/
static struct finsh_node* proc_cast_expr(struct finsh_parser* self)
{
 80210c4:	b580      	push	{r7, lr}
 80210c6:	b084      	sub	sp, #16
 80210c8:	af00      	add	r7, sp, #0
 80210ca:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	enum finsh_type type;
	struct finsh_node* cast;

	next_token(token, &(self->token));
 80210cc:	687b      	ldr	r3, [r7, #4]
 80210ce:	3304      	adds	r3, #4
 80210d0:	4618      	mov	r0, r3
 80210d2:	f000 fc37 	bl	8021944 <finsh_token_token>
 80210d6:	4603      	mov	r3, r0
 80210d8:	73fb      	strb	r3, [r7, #15]
	if (token == finsh_token_type_left_paren)
 80210da:	7bfb      	ldrb	r3, [r7, #15]
 80210dc:	2b01      	cmp	r3, #1
 80210de:	d120      	bne.n	8021122 <proc_cast_expr+0x5e>
	{
		type = proc_type(self);
 80210e0:	6878      	ldr	r0, [r7, #4]
 80210e2:	f7ff fd21 	bl	8020b28 <proc_type>
 80210e6:	4603      	mov	r3, r0
 80210e8:	73bb      	strb	r3, [r7, #14]
		match_token(token, &(self->token), finsh_token_type_right_paren);
 80210ea:	687b      	ldr	r3, [r7, #4]
 80210ec:	3304      	adds	r3, #4
 80210ee:	4618      	mov	r0, r3
 80210f0:	f000 fc28 	bl	8021944 <finsh_token_token>
 80210f4:	4603      	mov	r3, r0
 80210f6:	73fb      	strb	r3, [r7, #15]
 80210f8:	7bfb      	ldrb	r3, [r7, #15]
 80210fa:	2b02      	cmp	r3, #2
 80210fc:	d005      	beq.n	802110a <proc_cast_expr+0x46>
 80210fe:	2001      	movs	r0, #1
 8021100:	f7fe f8fc 	bl	801f2fc <finsh_error_set>
 8021104:	687b      	ldr	r3, [r7, #4]
 8021106:	2201      	movs	r2, #1
 8021108:	715a      	strb	r2, [r3, #5]

		cast = proc_cast_expr(self);
 802110a:	6878      	ldr	r0, [r7, #4]
 802110c:	f7ff ffda 	bl	80210c4 <proc_cast_expr>
 8021110:	60b8      	str	r0, [r7, #8]
		if (cast != NULL)
 8021112:	68bb      	ldr	r3, [r7, #8]
 8021114:	2b00      	cmp	r3, #0
 8021116:	d004      	beq.n	8021122 <proc_cast_expr+0x5e>
		{
			cast->data_type = type;
 8021118:	68bb      	ldr	r3, [r7, #8]
 802111a:	7bba      	ldrb	r2, [r7, #14]
 802111c:	705a      	strb	r2, [r3, #1]
			return cast;
 802111e:	68bb      	ldr	r3, [r7, #8]
 8021120:	e006      	b.n	8021130 <proc_cast_expr+0x6c>
		}
	}

	finsh_token_replay(&(self->token));
 8021122:	687b      	ldr	r3, [r7, #4]
 8021124:	2201      	movs	r2, #1
 8021126:	715a      	strb	r2, [r3, #5]
	return proc_unary_expr(self);
 8021128:	6878      	ldr	r0, [r7, #4]
 802112a:	f000 f805 	bl	8021138 <proc_unary_expr>
 802112e:	4603      	mov	r3, r0
}
 8021130:	4618      	mov	r0, r3
 8021132:	3710      	adds	r7, #16
 8021134:	46bd      	mov	sp, r7
 8021136:	bd80      	pop	{r7, pc}

08021138 <proc_unary_expr>:
	| '~' expr_cast
	| '*' expr_cast
	| '&' expr_cast
*/
static struct finsh_node* proc_unary_expr(struct finsh_parser* self)
{
 8021138:	b580      	push	{r7, lr}
 802113a:	b084      	sub	sp, #16
 802113c:	af00      	add	r7, sp, #0
 802113e:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node *cast;

	next_token(token, &(self->token));
 8021140:	687b      	ldr	r3, [r7, #4]
 8021142:	3304      	adds	r3, #4
 8021144:	4618      	mov	r0, r3
 8021146:	f000 fbfd 	bl	8021944 <finsh_token_token>
 802114a:	4603      	mov	r3, r0
 802114c:	73fb      	strb	r3, [r7, #15]
	switch (token)
 802114e:	7bfb      	ldrb	r3, [r7, #15]
 8021150:	3b05      	subs	r3, #5
 8021152:	2b0b      	cmp	r3, #11
 8021154:	d866      	bhi.n	8021224 <proc_unary_expr+0xec>
 8021156:	a201      	add	r2, pc, #4	; (adr r2, 802115c <proc_unary_expr+0x24>)
 8021158:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802115c:	080211f9 	.word	0x080211f9
 8021160:	0802118d 	.word	0x0802118d
 8021164:	08021199 	.word	0x08021199
 8021168:	080211af 	.word	0x080211af
 802116c:	080211cd 	.word	0x080211cd
 8021170:	08021225 	.word	0x08021225
 8021174:	08021225 	.word	0x08021225
 8021178:	08021225 	.word	0x08021225
 802117c:	0802120f 	.word	0x0802120f
 8021180:	08021225 	.word	0x08021225
 8021184:	08021225 	.word	0x08021225
 8021188:	080211e3 	.word	0x080211e3
	{
	case finsh_token_type_add: /* + */
		cast = proc_cast_expr(self);
 802118c:	6878      	ldr	r0, [r7, #4]
 802118e:	f7ff ff99 	bl	80210c4 <proc_cast_expr>
 8021192:	60b8      	str	r0, [r7, #8]
		return cast;
 8021194:	68bb      	ldr	r3, [r7, #8]
 8021196:	e04c      	b.n	8021232 <proc_unary_expr+0xfa>

	case finsh_token_type_inc: /* ++ */
		cast = proc_cast_expr(self);
 8021198:	6878      	ldr	r0, [r7, #4]
 802119a:	f7ff ff93 	bl	80210c4 <proc_cast_expr>
 802119e:	60b8      	str	r0, [r7, #8]
		return make_sys_node(FINSH_NODE_SYS_PREINC, cast, NULL);
 80211a0:	2015      	movs	r0, #21
 80211a2:	68b9      	ldr	r1, [r7, #8]
 80211a4:	2200      	movs	r2, #0
 80211a6:	f000 f991 	bl	80214cc <make_sys_node>
 80211aa:	4603      	mov	r3, r0
 80211ac:	e041      	b.n	8021232 <proc_unary_expr+0xfa>

	case finsh_token_type_sub: /* - */
		cast = proc_cast_expr(self);
 80211ae:	6878      	ldr	r0, [r7, #4]
 80211b0:	f7ff ff88 	bl	80210c4 <proc_cast_expr>
 80211b4:	60b8      	str	r0, [r7, #8]
		return make_sys_node(FINSH_NODE_SYS_SUB, finsh_node_new_long(0), cast);
 80211b6:	2000      	movs	r0, #0
 80211b8:	f7fe fb9c 	bl	801f8f4 <finsh_node_new_long>
 80211bc:	4603      	mov	r3, r0
 80211be:	2008      	movs	r0, #8
 80211c0:	4619      	mov	r1, r3
 80211c2:	68ba      	ldr	r2, [r7, #8]
 80211c4:	f000 f982 	bl	80214cc <make_sys_node>
 80211c8:	4603      	mov	r3, r0
 80211ca:	e032      	b.n	8021232 <proc_unary_expr+0xfa>

	case finsh_token_type_dec: /* -- */
		cast = proc_cast_expr(self);
 80211cc:	6878      	ldr	r0, [r7, #4]
 80211ce:	f7ff ff79 	bl	80210c4 <proc_cast_expr>
 80211d2:	60b8      	str	r0, [r7, #8]
		return make_sys_node(FINSH_NODE_SYS_PREDEC, cast, NULL);
 80211d4:	2016      	movs	r0, #22
 80211d6:	68b9      	ldr	r1, [r7, #8]
 80211d8:	2200      	movs	r2, #0
 80211da:	f000 f977 	bl	80214cc <make_sys_node>
 80211de:	4603      	mov	r3, r0
 80211e0:	e027      	b.n	8021232 <proc_unary_expr+0xfa>

	case finsh_token_type_bitwise: /* ~ */
		cast = proc_cast_expr(self);
 80211e2:	6878      	ldr	r0, [r7, #4]
 80211e4:	f7ff ff6e 	bl	80210c4 <proc_cast_expr>
 80211e8:	60b8      	str	r0, [r7, #8]
		return make_sys_node(FINSH_NODE_SYS_BITWISE, cast, NULL);
 80211ea:	200f      	movs	r0, #15
 80211ec:	68b9      	ldr	r1, [r7, #8]
 80211ee:	2200      	movs	r2, #0
 80211f0:	f000 f96c 	bl	80214cc <make_sys_node>
 80211f4:	4603      	mov	r3, r0
 80211f6:	e01c      	b.n	8021232 <proc_unary_expr+0xfa>

    case finsh_token_type_mul: /* * */
        cast = proc_cast_expr(self);
 80211f8:	6878      	ldr	r0, [r7, #4]
 80211fa:	f7ff ff63 	bl	80210c4 <proc_cast_expr>
 80211fe:	60b8      	str	r0, [r7, #8]
        return make_sys_node(FINSH_NODE_SYS_GETVALUE, cast, NULL);
 8021200:	2019      	movs	r0, #25
 8021202:	68b9      	ldr	r1, [r7, #8]
 8021204:	2200      	movs	r2, #0
 8021206:	f000 f961 	bl	80214cc <make_sys_node>
 802120a:	4603      	mov	r3, r0
 802120c:	e011      	b.n	8021232 <proc_unary_expr+0xfa>

    case finsh_token_type_and: /* & */
        cast = proc_cast_expr(self);
 802120e:	6878      	ldr	r0, [r7, #4]
 8021210:	f7ff ff58 	bl	80210c4 <proc_cast_expr>
 8021214:	60b8      	str	r0, [r7, #8]
        return make_sys_node(FINSH_NODE_SYS_GETADDR, cast, NULL);
 8021216:	201a      	movs	r0, #26
 8021218:	68b9      	ldr	r1, [r7, #8]
 802121a:	2200      	movs	r2, #0
 802121c:	f000 f956 	bl	80214cc <make_sys_node>
 8021220:	4603      	mov	r3, r0
 8021222:	e006      	b.n	8021232 <proc_unary_expr+0xfa>

	default:
		finsh_token_replay(&(self->token));
 8021224:	687b      	ldr	r3, [r7, #4]
 8021226:	2201      	movs	r2, #1
 8021228:	715a      	strb	r2, [r3, #5]
		return proc_postfix_expr(self);
 802122a:	6878      	ldr	r0, [r7, #4]
 802122c:	f000 f806 	bl	802123c <proc_postfix_expr>
 8021230:	4603      	mov	r3, r0
	}
}
 8021232:	4618      	mov	r0, r3
 8021234:	3710      	adds	r7, #16
 8021236:	46bd      	mov	sp, r7
 8021238:	bd80      	pop	{r7, pc}
 802123a:	bf00      	nop

0802123c <proc_postfix_expr>:
	| expr_postfix INC
	| expr_postfix DEC
	| expr_postfix '(' param_list ')'
*/
static struct finsh_node* proc_postfix_expr(struct finsh_parser* self)
{
 802123c:	b580      	push	{r7, lr}
 802123e:	b086      	sub	sp, #24
 8021240:	af00      	add	r7, sp, #0
 8021242:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* postfix;

	postfix = proc_primary_expr(self);
 8021244:	6878      	ldr	r0, [r7, #4]
 8021246:	f000 f861 	bl	802130c <proc_primary_expr>
 802124a:	6138      	str	r0, [r7, #16]

	next_token(token, &(self->token));
 802124c:	687b      	ldr	r3, [r7, #4]
 802124e:	3304      	adds	r3, #4
 8021250:	4618      	mov	r0, r3
 8021252:	f000 fb77 	bl	8021944 <finsh_token_token>
 8021256:	4603      	mov	r3, r0
 8021258:	75fb      	strb	r3, [r7, #23]
	while ( token == finsh_token_type_inc 	||
 802125a:	e046      	b.n	80212ea <proc_postfix_expr+0xae>
		token == finsh_token_type_dec 		||
		token == finsh_token_type_left_paren )
	{
		switch (token)
 802125c:	7dfb      	ldrb	r3, [r7, #23]
 802125e:	2b07      	cmp	r3, #7
 8021260:	d004      	beq.n	802126c <proc_postfix_expr+0x30>
 8021262:	2b09      	cmp	r3, #9
 8021264:	d009      	beq.n	802127a <proc_postfix_expr+0x3e>
 8021266:	2b01      	cmp	r3, #1
 8021268:	d00e      	beq.n	8021288 <proc_postfix_expr+0x4c>
				postfix = make_sys_node(FINSH_NODE_SYS_FUNC, postfix, param_list);
			}
			break;

		default:
			break;
 802126a:	e037      	b.n	80212dc <proc_postfix_expr+0xa0>
		token == finsh_token_type_left_paren )
	{
		switch (token)
		{
		case finsh_token_type_inc :/* '++' */
			postfix = make_sys_node(FINSH_NODE_SYS_INC, postfix, NULL);
 802126c:	2017      	movs	r0, #23
 802126e:	6939      	ldr	r1, [r7, #16]
 8021270:	2200      	movs	r2, #0
 8021272:	f000 f92b 	bl	80214cc <make_sys_node>
 8021276:	6138      	str	r0, [r7, #16]
			break;
 8021278:	e030      	b.n	80212dc <proc_postfix_expr+0xa0>

		case finsh_token_type_dec :/* '--' */
			postfix = make_sys_node(FINSH_NODE_SYS_DEC, postfix, NULL);
 802127a:	2018      	movs	r0, #24
 802127c:	6939      	ldr	r1, [r7, #16]
 802127e:	2200      	movs	r2, #0
 8021280:	f000 f924 	bl	80214cc <make_sys_node>
 8021284:	6138      	str	r0, [r7, #16]
			break;
 8021286:	e029      	b.n	80212dc <proc_postfix_expr+0xa0>

		case finsh_token_type_left_paren :/* '(' */
			{
				struct finsh_node* param_list;

				param_list = NULL;
 8021288:	2300      	movs	r3, #0
 802128a:	60fb      	str	r3, [r7, #12]
				next_token(token, &(self->token));
 802128c:	687b      	ldr	r3, [r7, #4]
 802128e:	3304      	adds	r3, #4
 8021290:	4618      	mov	r0, r3
 8021292:	f000 fb57 	bl	8021944 <finsh_token_token>
 8021296:	4603      	mov	r3, r0
 8021298:	75fb      	strb	r3, [r7, #23]
				if (token != finsh_token_type_right_paren)
 802129a:	7dfb      	ldrb	r3, [r7, #23]
 802129c:	2b02      	cmp	r3, #2
 802129e:	d016      	beq.n	80212ce <proc_postfix_expr+0x92>
				{
					finsh_token_replay(&(self->token));
 80212a0:	687b      	ldr	r3, [r7, #4]
 80212a2:	2201      	movs	r2, #1
 80212a4:	715a      	strb	r2, [r3, #5]
					param_list = proc_param_list(self);
 80212a6:	6878      	ldr	r0, [r7, #4]
 80212a8:	f000 f8d6 	bl	8021458 <proc_param_list>
 80212ac:	60f8      	str	r0, [r7, #12]

					match_token(token, &(self->token), finsh_token_type_right_paren);
 80212ae:	687b      	ldr	r3, [r7, #4]
 80212b0:	3304      	adds	r3, #4
 80212b2:	4618      	mov	r0, r3
 80212b4:	f000 fb46 	bl	8021944 <finsh_token_token>
 80212b8:	4603      	mov	r3, r0
 80212ba:	75fb      	strb	r3, [r7, #23]
 80212bc:	7dfb      	ldrb	r3, [r7, #23]
 80212be:	2b02      	cmp	r3, #2
 80212c0:	d005      	beq.n	80212ce <proc_postfix_expr+0x92>
 80212c2:	2001      	movs	r0, #1
 80212c4:	f7fe f81a 	bl	801f2fc <finsh_error_set>
 80212c8:	687b      	ldr	r3, [r7, #4]
 80212ca:	2201      	movs	r2, #1
 80212cc:	715a      	strb	r2, [r3, #5]
				}

				postfix = make_sys_node(FINSH_NODE_SYS_FUNC, postfix, param_list);
 80212ce:	2012      	movs	r0, #18
 80212d0:	6939      	ldr	r1, [r7, #16]
 80212d2:	68fa      	ldr	r2, [r7, #12]
 80212d4:	f000 f8fa 	bl	80214cc <make_sys_node>
 80212d8:	6138      	str	r0, [r7, #16]
			}
			break;
 80212da:	bf00      	nop

		default:
			break;
		}

		next_token(token, &(self->token));
 80212dc:	687b      	ldr	r3, [r7, #4]
 80212de:	3304      	adds	r3, #4
 80212e0:	4618      	mov	r0, r3
 80212e2:	f000 fb2f 	bl	8021944 <finsh_token_token>
 80212e6:	4603      	mov	r3, r0
 80212e8:	75fb      	strb	r3, [r7, #23]
	struct finsh_node* postfix;

	postfix = proc_primary_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_inc 	||
 80212ea:	7dfb      	ldrb	r3, [r7, #23]
 80212ec:	2b07      	cmp	r3, #7
 80212ee:	d0b5      	beq.n	802125c <proc_postfix_expr+0x20>
 80212f0:	7dfb      	ldrb	r3, [r7, #23]
 80212f2:	2b09      	cmp	r3, #9
 80212f4:	d0b2      	beq.n	802125c <proc_postfix_expr+0x20>
		token == finsh_token_type_dec 		||
 80212f6:	7dfb      	ldrb	r3, [r7, #23]
 80212f8:	2b01      	cmp	r3, #1
 80212fa:	d0af      	beq.n	802125c <proc_postfix_expr+0x20>
		}

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 80212fc:	687b      	ldr	r3, [r7, #4]
 80212fe:	2201      	movs	r2, #1
 8021300:	715a      	strb	r2, [r3, #5]
	return postfix;
 8021302:	693b      	ldr	r3, [r7, #16]
}
 8021304:	4618      	mov	r0, r3
 8021306:	3718      	adds	r7, #24
 8021308:	46bd      	mov	sp, r7
 802130a:	bd80      	pop	{r7, pc}

0802130c <proc_primary_expr>:
expr_primary -> literal
	| '(' expr ')'
	| identifier
*/
static struct finsh_node* proc_primary_expr(struct finsh_parser* self)
{
 802130c:	b580      	push	{r7, lr}
 802130e:	b08a      	sub	sp, #40	; 0x28
 8021310:	af00      	add	r7, sp, #0
 8021312:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node* expr;

	next_token(token, &(self->token));
 8021314:	687b      	ldr	r3, [r7, #4]
 8021316:	3304      	adds	r3, #4
 8021318:	4618      	mov	r0, r3
 802131a:	f000 fb13 	bl	8021944 <finsh_token_token>
 802131e:	4603      	mov	r3, r0
 8021320:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	switch ( token )
 8021324:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8021328:	3b01      	subs	r3, #1
 802132a:	2b1e      	cmp	r3, #30
 802132c:	f200 808b 	bhi.w	8021446 <proc_primary_expr+0x13a>
 8021330:	a201      	add	r2, pc, #4	; (adr r2, 8021338 <proc_primary_expr+0x2c>)
 8021332:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8021336:	bf00      	nop
 8021338:	080213d5 	.word	0x080213d5
 802133c:	08021447 	.word	0x08021447
 8021340:	08021447 	.word	0x08021447
 8021344:	08021447 	.word	0x08021447
 8021348:	08021447 	.word	0x08021447
 802134c:	08021447 	.word	0x08021447
 8021350:	08021447 	.word	0x08021447
 8021354:	08021447 	.word	0x08021447
 8021358:	08021447 	.word	0x08021447
 802135c:	08021447 	.word	0x08021447
 8021360:	08021447 	.word	0x08021447
 8021364:	08021447 	.word	0x08021447
 8021368:	08021447 	.word	0x08021447
 802136c:	08021447 	.word	0x08021447
 8021370:	08021447 	.word	0x08021447
 8021374:	08021447 	.word	0x08021447
 8021378:	08021447 	.word	0x08021447
 802137c:	08021447 	.word	0x08021447
 8021380:	08021447 	.word	0x08021447
 8021384:	08021447 	.word	0x08021447
 8021388:	08021447 	.word	0x08021447
 802138c:	08021447 	.word	0x08021447
 8021390:	08021447 	.word	0x08021447
 8021394:	08021447 	.word	0x08021447
 8021398:	08021447 	.word	0x08021447
 802139c:	08021421 	.word	0x08021421
 80213a0:	08021405 	.word	0x08021405
 80213a4:	08021413 	.word	0x08021413
 80213a8:	0802142f 	.word	0x0802142f
 80213ac:	0802143d 	.word	0x0802143d
 80213b0:	080213b5 	.word	0x080213b5
	{
	case finsh_token_type_identifier:
		{
			char id[FINSH_NAME_MAX + 1];

			finsh_token_replay(&(self->token));
 80213b4:	687b      	ldr	r3, [r7, #4]
 80213b6:	2201      	movs	r2, #1
 80213b8:	715a      	strb	r2, [r3, #5]
			proc_identifier(self, id);
 80213ba:	f107 030c 	add.w	r3, r7, #12
 80213be:	6878      	ldr	r0, [r7, #4]
 80213c0:	4619      	mov	r1, r3
 80213c2:	f7ff fc7f 	bl	8020cc4 <proc_identifier>
			return finsh_node_new_id(id);
 80213c6:	f107 030c 	add.w	r3, r7, #12
 80213ca:	4618      	mov	r0, r3
 80213cc:	f7fe fa0a 	bl	801f7e4 <finsh_node_new_id>
 80213d0:	4603      	mov	r3, r0
 80213d2:	e03d      	b.n	8021450 <proc_primary_expr+0x144>
		}

	case finsh_token_type_left_paren:
		expr = proc_expr(self);
 80213d4:	6878      	ldr	r0, [r7, #4]
 80213d6:	f7ff fcc3 	bl	8020d60 <proc_expr>
 80213da:	6238      	str	r0, [r7, #32]
		match_token(token, &(self->token), finsh_token_type_right_paren);
 80213dc:	687b      	ldr	r3, [r7, #4]
 80213de:	3304      	adds	r3, #4
 80213e0:	4618      	mov	r0, r3
 80213e2:	f000 faaf 	bl	8021944 <finsh_token_token>
 80213e6:	4603      	mov	r3, r0
 80213e8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 80213ec:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80213f0:	2b02      	cmp	r3, #2
 80213f2:	d005      	beq.n	8021400 <proc_primary_expr+0xf4>
 80213f4:	2001      	movs	r0, #1
 80213f6:	f7fd ff81 	bl	801f2fc <finsh_error_set>
 80213fa:	687b      	ldr	r3, [r7, #4]
 80213fc:	2201      	movs	r2, #1
 80213fe:	715a      	strb	r2, [r3, #5]
		return expr;
 8021400:	6a3b      	ldr	r3, [r7, #32]
 8021402:	e025      	b.n	8021450 <proc_primary_expr+0x144>

	case finsh_token_type_value_int:
		return finsh_node_new_int(self->token.value.int_value);
 8021404:	687b      	ldr	r3, [r7, #4]
 8021406:	691b      	ldr	r3, [r3, #16]
 8021408:	4618      	mov	r0, r3
 802140a:	f7fe fa5b 	bl	801f8c4 <finsh_node_new_int>
 802140e:	4603      	mov	r3, r0
 8021410:	e01e      	b.n	8021450 <proc_primary_expr+0x144>

	case finsh_token_type_value_long:
		return finsh_node_new_long(self->token.value.long_value);
 8021412:	687b      	ldr	r3, [r7, #4]
 8021414:	691b      	ldr	r3, [r3, #16]
 8021416:	4618      	mov	r0, r3
 8021418:	f7fe fa6c 	bl	801f8f4 <finsh_node_new_long>
 802141c:	4603      	mov	r3, r0
 802141e:	e017      	b.n	8021450 <proc_primary_expr+0x144>

	case finsh_token_type_value_char:
		return finsh_node_new_char(self->token.value.char_value);
 8021420:	687b      	ldr	r3, [r7, #4]
 8021422:	7c1b      	ldrb	r3, [r3, #16]
 8021424:	4618      	mov	r0, r3
 8021426:	f7fe fa33 	bl	801f890 <finsh_node_new_char>
 802142a:	4603      	mov	r3, r0
 802142c:	e010      	b.n	8021450 <proc_primary_expr+0x144>

	case finsh_token_type_value_string:
		return finsh_node_new_string((char*)self->token.string);
 802142e:	687b      	ldr	r3, [r7, #4]
 8021430:	3314      	adds	r3, #20
 8021432:	4618      	mov	r0, r3
 8021434:	f7fe fa76 	bl	801f924 <finsh_node_new_string>
 8021438:	4603      	mov	r3, r0
 802143a:	e009      	b.n	8021450 <proc_primary_expr+0x144>

	case finsh_token_type_value_null:
		return finsh_node_new_ptr(NULL);
 802143c:	2000      	movs	r0, #0
 802143e:	f7fe faa5 	bl	801f98c <finsh_node_new_ptr>
 8021442:	4603      	mov	r3, r0
 8021444:	e004      	b.n	8021450 <proc_primary_expr+0x144>

	default:
		finsh_error_set(FINSH_ERROR_INVALID_TOKEN);
 8021446:	2001      	movs	r0, #1
 8021448:	f7fd ff58 	bl	801f2fc <finsh_error_set>
		break;
 802144c:	bf00      	nop
	}

	return NULL;
 802144e:	2300      	movs	r3, #0
}
 8021450:	4618      	mov	r0, r3
 8021452:	3728      	adds	r7, #40	; 0x28
 8021454:	46bd      	mov	sp, r7
 8021456:	bd80      	pop	{r7, pc}

08021458 <proc_param_list>:
param_list -> empty
	| expr_assign
	| param_list ',' expr_assign
*/
static struct finsh_node* proc_param_list(struct finsh_parser* self)
{
 8021458:	b580      	push	{r7, lr}
 802145a:	b086      	sub	sp, #24
 802145c:	af00      	add	r7, sp, #0
 802145e:	6078      	str	r0, [r7, #4]
	enum finsh_token_type token;
	struct finsh_node *node, *assign;

	assign = proc_assign_expr(self);
 8021460:	6878      	ldr	r0, [r7, #4]
 8021462:	f7ff fc89 	bl	8020d78 <proc_assign_expr>
 8021466:	6138      	str	r0, [r7, #16]
	if (assign == NULL) return NULL;
 8021468:	693b      	ldr	r3, [r7, #16]
 802146a:	2b00      	cmp	r3, #0
 802146c:	d101      	bne.n	8021472 <proc_param_list+0x1a>
 802146e:	2300      	movs	r3, #0
 8021470:	e028      	b.n	80214c4 <proc_param_list+0x6c>
	node = assign;
 8021472:	693b      	ldr	r3, [r7, #16]
 8021474:	60fb      	str	r3, [r7, #12]

	next_token(token, &(self->token));
 8021476:	687b      	ldr	r3, [r7, #4]
 8021478:	3304      	adds	r3, #4
 802147a:	4618      	mov	r0, r3
 802147c:	f000 fa62 	bl	8021944 <finsh_token_token>
 8021480:	4603      	mov	r3, r0
 8021482:	75fb      	strb	r3, [r7, #23]
	while (token == finsh_token_type_comma )
 8021484:	e017      	b.n	80214b6 <proc_param_list+0x5e>
	{
		finsh_node_sibling(assign) = proc_assign_expr(self);
 8021486:	6878      	ldr	r0, [r7, #4]
 8021488:	f7ff fc76 	bl	8020d78 <proc_assign_expr>
 802148c:	4602      	mov	r2, r0
 802148e:	693b      	ldr	r3, [r7, #16]
 8021490:	60da      	str	r2, [r3, #12]

		if (finsh_node_sibling(assign) != NULL)	assign = finsh_node_sibling(assign);
 8021492:	693b      	ldr	r3, [r7, #16]
 8021494:	68db      	ldr	r3, [r3, #12]
 8021496:	2b00      	cmp	r3, #0
 8021498:	d003      	beq.n	80214a2 <proc_param_list+0x4a>
 802149a:	693b      	ldr	r3, [r7, #16]
 802149c:	68db      	ldr	r3, [r3, #12]
 802149e:	613b      	str	r3, [r7, #16]
 80214a0:	e002      	b.n	80214a8 <proc_param_list+0x50>
		else finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
 80214a2:	2005      	movs	r0, #5
 80214a4:	f7fd ff2a 	bl	801f2fc <finsh_error_set>

		next_token(token, &(self->token));
 80214a8:	687b      	ldr	r3, [r7, #4]
 80214aa:	3304      	adds	r3, #4
 80214ac:	4618      	mov	r0, r3
 80214ae:	f000 fa49 	bl	8021944 <finsh_token_token>
 80214b2:	4603      	mov	r3, r0
 80214b4:	75fb      	strb	r3, [r7, #23]
	assign = proc_assign_expr(self);
	if (assign == NULL) return NULL;
	node = assign;

	next_token(token, &(self->token));
	while (token == finsh_token_type_comma )
 80214b6:	7dfb      	ldrb	r3, [r7, #23]
 80214b8:	2b03      	cmp	r3, #3
 80214ba:	d0e4      	beq.n	8021486 <proc_param_list+0x2e>
		else finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
 80214bc:	687b      	ldr	r3, [r7, #4]
 80214be:	2201      	movs	r2, #1
 80214c0:	715a      	strb	r2, [r3, #5]

	return node;
 80214c2:	68fb      	ldr	r3, [r7, #12]
}
 80214c4:	4618      	mov	r0, r3
 80214c6:	3718      	adds	r7, #24
 80214c8:	46bd      	mov	sp, r7
 80214ca:	bd80      	pop	{r7, pc}

080214cc <make_sys_node>:
node1__
       \
       node2
*/
static struct finsh_node* make_sys_node(u_char type, struct finsh_node* node1, struct finsh_node* node2)
{
 80214cc:	b580      	push	{r7, lr}
 80214ce:	b086      	sub	sp, #24
 80214d0:	af00      	add	r7, sp, #0
 80214d2:	4603      	mov	r3, r0
 80214d4:	60b9      	str	r1, [r7, #8]
 80214d6:	607a      	str	r2, [r7, #4]
 80214d8:	73fb      	strb	r3, [r7, #15]
	struct finsh_node* node;

	node = finsh_node_allocate(type);
 80214da:	7bfb      	ldrb	r3, [r7, #15]
 80214dc:	4618      	mov	r0, r3
 80214de:	f7fe f94b 	bl	801f778 <finsh_node_allocate>
 80214e2:	6178      	str	r0, [r7, #20]

	if ((node1 != NULL) && (node != NULL))
 80214e4:	68bb      	ldr	r3, [r7, #8]
 80214e6:	2b00      	cmp	r3, #0
 80214e8:	d009      	beq.n	80214fe <make_sys_node+0x32>
 80214ea:	697b      	ldr	r3, [r7, #20]
 80214ec:	2b00      	cmp	r3, #0
 80214ee:	d006      	beq.n	80214fe <make_sys_node+0x32>
	{
		finsh_node_child(node) = node1;
 80214f0:	697b      	ldr	r3, [r7, #20]
 80214f2:	68ba      	ldr	r2, [r7, #8]
 80214f4:	611a      	str	r2, [r3, #16]
		finsh_node_sibling(node1) = node2;
 80214f6:	68bb      	ldr	r3, [r7, #8]
 80214f8:	687a      	ldr	r2, [r7, #4]
 80214fa:	60da      	str	r2, [r3, #12]
 80214fc:	e002      	b.n	8021504 <make_sys_node+0x38>
	}
	else finsh_error_set(FINSH_ERROR_NULL_NODE);
 80214fe:	200e      	movs	r0, #14
 8021500:	f7fd fefc 	bl	801f2fc <finsh_error_set>

	return node;
 8021504:	697b      	ldr	r3, [r7, #20]
}
 8021506:	4618      	mov	r0, r3
 8021508:	3718      	adds	r7, #24
 802150a:	46bd      	mov	sp, r7
 802150c:	bd80      	pop	{r7, pc}
 802150e:	bf00      	nop

08021510 <finsh_parser_run>:

/*
start -> statement_expr | decl_variable
*/
void finsh_parser_run(struct finsh_parser* self, const u_char* string)
{
 8021510:	b580      	push	{r7, lr}
 8021512:	b084      	sub	sp, #16
 8021514:	af00      	add	r7, sp, #0
 8021516:	6078      	str	r0, [r7, #4]
 8021518:	6039      	str	r1, [r7, #0]
	enum finsh_token_type token;
	struct finsh_node *node;

    node = NULL;
 802151a:	2300      	movs	r3, #0
 802151c:	60bb      	str	r3, [r7, #8]

	/* init parser */
	self->parser_string = (u_char*)string;
 802151e:	687b      	ldr	r3, [r7, #4]
 8021520:	683a      	ldr	r2, [r7, #0]
 8021522:	601a      	str	r2, [r3, #0]

	/* init token */
	finsh_token_init(&(self->token), self->parser_string);
 8021524:	687b      	ldr	r3, [r7, #4]
 8021526:	1d1a      	adds	r2, r3, #4
 8021528:	687b      	ldr	r3, [r7, #4]
 802152a:	681b      	ldr	r3, [r3, #0]
 802152c:	4610      	mov	r0, r2
 802152e:	4619      	mov	r1, r3
 8021530:	f000 f9f6 	bl	8021920 <finsh_token_init>

	/* get next token */
	next_token(token, &(self->token));
 8021534:	687b      	ldr	r3, [r7, #4]
 8021536:	3304      	adds	r3, #4
 8021538:	4618      	mov	r0, r3
 802153a:	f000 fa03 	bl	8021944 <finsh_token_token>
 802153e:	4603      	mov	r3, r0
 8021540:	73fb      	strb	r3, [r7, #15]
	while (token != finsh_token_type_eof && token != finsh_token_type_bad)
 8021542:	e089      	b.n	8021658 <finsh_parser_run+0x148>
	{
		switch (token)
 8021544:	7bfb      	ldrb	r3, [r7, #15]
 8021546:	2b1f      	cmp	r3, #31
 8021548:	d11f      	bne.n	802158a <finsh_parser_run+0x7a>
		{
        case finsh_token_type_identifier:
            /* process expr_statement */
            finsh_token_replay(&(self->token));
 802154a:	687b      	ldr	r3, [r7, #4]
 802154c:	2201      	movs	r2, #1
 802154e:	715a      	strb	r2, [r3, #5]

			if (self->root != NULL)
 8021550:	687b      	ldr	r3, [r7, #4]
 8021552:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8021556:	2b00      	cmp	r3, #0
 8021558:	d00d      	beq.n	8021576 <finsh_parser_run+0x66>
			{
				finsh_node_sibling(node) = proc_expr_statement(self);
 802155a:	6878      	ldr	r0, [r7, #4]
 802155c:	f7ff fbd4 	bl	8020d08 <proc_expr_statement>
 8021560:	4602      	mov	r2, r0
 8021562:	68bb      	ldr	r3, [r7, #8]
 8021564:	60da      	str	r2, [r3, #12]
				if (finsh_node_sibling(node) != NULL)
 8021566:	68bb      	ldr	r3, [r7, #8]
 8021568:	68db      	ldr	r3, [r3, #12]
 802156a:	2b00      	cmp	r3, #0
 802156c:	d00c      	beq.n	8021588 <finsh_parser_run+0x78>
					node = finsh_node_sibling(node);
 802156e:	68bb      	ldr	r3, [r7, #8]
 8021570:	68db      	ldr	r3, [r3, #12]
 8021572:	60bb      	str	r3, [r7, #8]
			else
			{
            	node = proc_expr_statement(self);
				self->root = node;
			}
            break;
 8021574:	e063      	b.n	802163e <finsh_parser_run+0x12e>
				if (finsh_node_sibling(node) != NULL)
					node = finsh_node_sibling(node);
			}
			else
			{
            	node = proc_expr_statement(self);
 8021576:	6878      	ldr	r0, [r7, #4]
 8021578:	f7ff fbc6 	bl	8020d08 <proc_expr_statement>
 802157c:	60b8      	str	r0, [r7, #8]
				self->root = node;
 802157e:	687b      	ldr	r3, [r7, #4]
 8021580:	68ba      	ldr	r2, [r7, #8]
 8021582:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
			}
            break;
 8021586:	e05a      	b.n	802163e <finsh_parser_run+0x12e>
 8021588:	e059      	b.n	802163e <finsh_parser_run+0x12e>

		default:
            if (is_base_type(token) || token == finsh_token_type_unsigned)
 802158a:	7bfb      	ldrb	r3, [r7, #15]
 802158c:	2b14      	cmp	r3, #20
 802158e:	d00e      	beq.n	80215ae <finsh_parser_run+0x9e>
 8021590:	7bfb      	ldrb	r3, [r7, #15]
 8021592:	2b15      	cmp	r3, #21
 8021594:	d00b      	beq.n	80215ae <finsh_parser_run+0x9e>
 8021596:	7bfb      	ldrb	r3, [r7, #15]
 8021598:	2b16      	cmp	r3, #22
 802159a:	d008      	beq.n	80215ae <finsh_parser_run+0x9e>
 802159c:	7bfb      	ldrb	r3, [r7, #15]
 802159e:	2b17      	cmp	r3, #23
 80215a0:	d005      	beq.n	80215ae <finsh_parser_run+0x9e>
 80215a2:	7bfb      	ldrb	r3, [r7, #15]
 80215a4:	2b18      	cmp	r3, #24
 80215a6:	d002      	beq.n	80215ae <finsh_parser_run+0x9e>
 80215a8:	7bfb      	ldrb	r3, [r7, #15]
 80215aa:	2b19      	cmp	r3, #25
 80215ac:	d11f      	bne.n	80215ee <finsh_parser_run+0xde>
            {
            	/* variable decl */
            	finsh_token_replay(&(self->token));
 80215ae:	687b      	ldr	r3, [r7, #4]
 80215b0:	2201      	movs	r2, #1
 80215b2:	715a      	strb	r2, [r3, #5]

				if (self->root != NULL)
 80215b4:	687b      	ldr	r3, [r7, #4]
 80215b6:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 80215ba:	2b00      	cmp	r3, #0
 80215bc:	d00d      	beq.n	80215da <finsh_parser_run+0xca>
				{
					finsh_node_sibling(node) = proc_variable_decl(self);
 80215be:	6878      	ldr	r0, [r7, #4]
 80215c0:	f7ff f952 	bl	8020868 <proc_variable_decl>
 80215c4:	4602      	mov	r2, r0
 80215c6:	68bb      	ldr	r3, [r7, #8]
 80215c8:	60da      	str	r2, [r3, #12]
					if (finsh_node_sibling(node) != NULL)
 80215ca:	68bb      	ldr	r3, [r7, #8]
 80215cc:	68db      	ldr	r3, [r3, #12]
 80215ce:	2b00      	cmp	r3, #0
 80215d0:	d00c      	beq.n	80215ec <finsh_parser_run+0xdc>
						node = finsh_node_sibling(node);
 80215d2:	68bb      	ldr	r3, [r7, #8]
 80215d4:	68db      	ldr	r3, [r3, #12]
 80215d6:	60bb      	str	r3, [r7, #8]
            if (is_base_type(token) || token == finsh_token_type_unsigned)
            {
            	/* variable decl */
            	finsh_token_replay(&(self->token));

				if (self->root != NULL)
 80215d8:	e030      	b.n	802163c <finsh_parser_run+0x12c>
					if (finsh_node_sibling(node) != NULL)
						node = finsh_node_sibling(node);
				}
				else
				{
					node = proc_variable_decl(self);
 80215da:	6878      	ldr	r0, [r7, #4]
 80215dc:	f7ff f944 	bl	8020868 <proc_variable_decl>
 80215e0:	60b8      	str	r0, [r7, #8]
					self->root = node;
 80215e2:	687b      	ldr	r3, [r7, #4]
 80215e4:	68ba      	ldr	r2, [r7, #8]
 80215e6:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
            if (is_base_type(token) || token == finsh_token_type_unsigned)
            {
            	/* variable decl */
            	finsh_token_replay(&(self->token));

				if (self->root != NULL)
 80215ea:	e027      	b.n	802163c <finsh_parser_run+0x12c>
 80215ec:	e026      	b.n	802163c <finsh_parser_run+0x12c>
				}
            }
            else
            {
            	/* process expr_statement */
                finsh_token_replay(&(self->token));
 80215ee:	687b      	ldr	r3, [r7, #4]
 80215f0:	2201      	movs	r2, #1
 80215f2:	715a      	strb	r2, [r3, #5]

				if (self->root != NULL)
 80215f4:	687b      	ldr	r3, [r7, #4]
 80215f6:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 80215fa:	2b00      	cmp	r3, #0
 80215fc:	d015      	beq.n	802162a <finsh_parser_run+0x11a>
				{
                    finsh_node_sibling(node) = proc_expr_statement(self);
 80215fe:	6878      	ldr	r0, [r7, #4]
 8021600:	f7ff fb82 	bl	8020d08 <proc_expr_statement>
 8021604:	4602      	mov	r2, r0
 8021606:	68bb      	ldr	r3, [r7, #8]
 8021608:	60da      	str	r2, [r3, #12]
					if (finsh_node_sibling(node) != NULL)
 802160a:	68bb      	ldr	r3, [r7, #8]
 802160c:	68db      	ldr	r3, [r3, #12]
 802160e:	2b00      	cmp	r3, #0
 8021610:	d003      	beq.n	802161a <finsh_parser_run+0x10a>
						node = finsh_node_sibling(node);
 8021612:	68bb      	ldr	r3, [r7, #8]
 8021614:	68db      	ldr	r3, [r3, #12]
 8021616:	60bb      	str	r3, [r7, #8]
 8021618:	e010      	b.n	802163c <finsh_parser_run+0x12c>
					else next_token(token, &(self->token));
 802161a:	687b      	ldr	r3, [r7, #4]
 802161c:	3304      	adds	r3, #4
 802161e:	4618      	mov	r0, r3
 8021620:	f000 f990 	bl	8021944 <finsh_token_token>
 8021624:	4603      	mov	r3, r0
 8021626:	73fb      	strb	r3, [r7, #15]
					node = proc_expr_statement(self);
					self->root = node;
				}
            }

			break;
 8021628:	e008      	b.n	802163c <finsh_parser_run+0x12c>
						node = finsh_node_sibling(node);
					else next_token(token, &(self->token));
				}
				else
				{
					node = proc_expr_statement(self);
 802162a:	6878      	ldr	r0, [r7, #4]
 802162c:	f7ff fb6c 	bl	8020d08 <proc_expr_statement>
 8021630:	60b8      	str	r0, [r7, #8]
					self->root = node;
 8021632:	687b      	ldr	r3, [r7, #4]
 8021634:	68ba      	ldr	r2, [r7, #8]
 8021636:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
				}
            }

			break;
 802163a:	e7ff      	b.n	802163c <finsh_parser_run+0x12c>
 802163c:	bf00      	nop
		}

		/* no root found, break out */
		if (self->root == NULL) break;
 802163e:	687b      	ldr	r3, [r7, #4]
 8021640:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8021644:	2b00      	cmp	r3, #0
 8021646:	d100      	bne.n	802164a <finsh_parser_run+0x13a>
 8021648:	e00d      	b.n	8021666 <finsh_parser_run+0x156>

        /* get next token */
		next_token(token, &(self->token));
 802164a:	687b      	ldr	r3, [r7, #4]
 802164c:	3304      	adds	r3, #4
 802164e:	4618      	mov	r0, r3
 8021650:	f000 f978 	bl	8021944 <finsh_token_token>
 8021654:	4603      	mov	r3, r0
 8021656:	73fb      	strb	r3, [r7, #15]
	/* init token */
	finsh_token_init(&(self->token), self->parser_string);

	/* get next token */
	next_token(token, &(self->token));
	while (token != finsh_token_type_eof && token != finsh_token_type_bad)
 8021658:	7bfb      	ldrb	r3, [r7, #15]
 802165a:	2b21      	cmp	r3, #33	; 0x21
 802165c:	d003      	beq.n	8021666 <finsh_parser_run+0x156>
 802165e:	7bfb      	ldrb	r3, [r7, #15]
 8021660:	2b20      	cmp	r3, #32
 8021662:	f47f af6f 	bne.w	8021544 <finsh_parser_run+0x34>
		if (self->root == NULL) break;

        /* get next token */
		next_token(token, &(self->token));
	}
}
 8021666:	3710      	adds	r7, #16
 8021668:	46bd      	mov	sp, r7
 802166a:	bd80      	pop	{r7, pc}

0802166c <finsh_parser_init>:

int finsh_parser_init(struct finsh_parser* self)
{
 802166c:	b580      	push	{r7, lr}
 802166e:	b082      	sub	sp, #8
 8021670:	af00      	add	r7, sp, #0
 8021672:	6078      	str	r0, [r7, #4]
	memset(self, 0, sizeof(struct finsh_parser));
 8021674:	6878      	ldr	r0, [r7, #4]
 8021676:	2100      	movs	r1, #0
 8021678:	229c      	movs	r2, #156	; 0x9c
 802167a:	f000 ffff 	bl	802267c <memset>

	return 0;
 802167e:	2300      	movs	r3, #0
}
 8021680:	4618      	mov	r0, r3
 8021682:	3708      	adds	r7, #8
 8021684:	46bd      	mov	sp, r7
 8021686:	bd80      	pop	{r7, pc}

08021688 <finsh_var_init>:

struct finsh_var global_variable[FINSH_VARIABLE_MAX];
struct finsh_sysvar_item* global_sysvar_list;

int finsh_var_init()
{
 8021688:	b580      	push	{r7, lr}
 802168a:	af00      	add	r7, sp, #0
	memset(global_variable, 0, sizeof(global_variable));
 802168c:	4803      	ldr	r0, [pc, #12]	; (802169c <finsh_var_init+0x14>)
 802168e:	2100      	movs	r1, #0
 8021690:	22c0      	movs	r2, #192	; 0xc0
 8021692:	f000 fff3 	bl	802267c <memset>

	return 0;
 8021696:	2300      	movs	r3, #0
}
 8021698:	4618      	mov	r0, r3
 802169a:	bd80      	pop	{r7, pc}
 802169c:	20012dac 	.word	0x20012dac

080216a0 <finsh_var_insert>:

int finsh_var_insert(const char* name, int type)
{
 80216a0:	b580      	push	{r7, lr}
 80216a2:	b084      	sub	sp, #16
 80216a4:	af00      	add	r7, sp, #0
 80216a6:	6078      	str	r0, [r7, #4]
 80216a8:	6039      	str	r1, [r7, #0]
	int i, empty;

	empty = -1;
 80216aa:	f04f 33ff 	mov.w	r3, #4294967295
 80216ae:	60bb      	str	r3, [r7, #8]
	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
 80216b0:	2300      	movs	r3, #0
 80216b2:	60fb      	str	r3, [r7, #12]
 80216b4:	e025      	b.n	8021702 <finsh_var_insert+0x62>
	{
		/* there is a same name variable exist. */
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
 80216b6:	68fa      	ldr	r2, [r7, #12]
 80216b8:	4613      	mov	r3, r2
 80216ba:	005b      	lsls	r3, r3, #1
 80216bc:	4413      	add	r3, r2
 80216be:	00db      	lsls	r3, r3, #3
 80216c0:	4a23      	ldr	r2, [pc, #140]	; (8021750 <finsh_var_insert+0xb0>)
 80216c2:	4413      	add	r3, r2
 80216c4:	4618      	mov	r0, r3
 80216c6:	6879      	ldr	r1, [r7, #4]
 80216c8:	2210      	movs	r2, #16
 80216ca:	f001 fc97 	bl	8022ffc <strncmp>
 80216ce:	4603      	mov	r3, r0
 80216d0:	2b00      	cmp	r3, #0
 80216d2:	d102      	bne.n	80216da <finsh_var_insert+0x3a>
			return -1;
 80216d4:	f04f 33ff 	mov.w	r3, #4294967295
 80216d8:	e036      	b.n	8021748 <finsh_var_insert+0xa8>

		if (global_variable[i].type == finsh_type_unknown && empty == -1)
 80216da:	491d      	ldr	r1, [pc, #116]	; (8021750 <finsh_var_insert+0xb0>)
 80216dc:	68fa      	ldr	r2, [r7, #12]
 80216de:	4613      	mov	r3, r2
 80216e0:	005b      	lsls	r3, r3, #1
 80216e2:	4413      	add	r3, r2
 80216e4:	00db      	lsls	r3, r3, #3
 80216e6:	440b      	add	r3, r1
 80216e8:	3310      	adds	r3, #16
 80216ea:	785b      	ldrb	r3, [r3, #1]
 80216ec:	2b00      	cmp	r3, #0
 80216ee:	d105      	bne.n	80216fc <finsh_var_insert+0x5c>
 80216f0:	68bb      	ldr	r3, [r7, #8]
 80216f2:	f1b3 3fff 	cmp.w	r3, #4294967295
 80216f6:	d101      	bne.n	80216fc <finsh_var_insert+0x5c>
		{
			empty = i;
 80216f8:	68fb      	ldr	r3, [r7, #12]
 80216fa:	60bb      	str	r3, [r7, #8]
int finsh_var_insert(const char* name, int type)
{
	int i, empty;

	empty = -1;
	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
 80216fc:	68fb      	ldr	r3, [r7, #12]
 80216fe:	3301      	adds	r3, #1
 8021700:	60fb      	str	r3, [r7, #12]
 8021702:	68fb      	ldr	r3, [r7, #12]
 8021704:	2b07      	cmp	r3, #7
 8021706:	ddd6      	ble.n	80216b6 <finsh_var_insert+0x16>
			empty = i;
		}
	}

	/* there is no empty entry */
	if (empty == -1) return -1;
 8021708:	68bb      	ldr	r3, [r7, #8]
 802170a:	f1b3 3fff 	cmp.w	r3, #4294967295
 802170e:	d102      	bne.n	8021716 <finsh_var_insert+0x76>
 8021710:	f04f 33ff 	mov.w	r3, #4294967295
 8021714:	e018      	b.n	8021748 <finsh_var_insert+0xa8>

	/* insert entry */
	strncpy(global_variable[empty].name, name, FINSH_NAME_MAX);
 8021716:	68ba      	ldr	r2, [r7, #8]
 8021718:	4613      	mov	r3, r2
 802171a:	005b      	lsls	r3, r3, #1
 802171c:	4413      	add	r3, r2
 802171e:	00db      	lsls	r3, r3, #3
 8021720:	4a0b      	ldr	r2, [pc, #44]	; (8021750 <finsh_var_insert+0xb0>)
 8021722:	4413      	add	r3, r2
 8021724:	4618      	mov	r0, r3
 8021726:	6879      	ldr	r1, [r7, #4]
 8021728:	2210      	movs	r2, #16
 802172a:	f001 fcb3 	bl	8023094 <strncpy>
	global_variable[empty].type = type;
 802172e:	683b      	ldr	r3, [r7, #0]
 8021730:	b2d8      	uxtb	r0, r3
 8021732:	4907      	ldr	r1, [pc, #28]	; (8021750 <finsh_var_insert+0xb0>)
 8021734:	68ba      	ldr	r2, [r7, #8]
 8021736:	4613      	mov	r3, r2
 8021738:	005b      	lsls	r3, r3, #1
 802173a:	4413      	add	r3, r2
 802173c:	00db      	lsls	r3, r3, #3
 802173e:	440b      	add	r3, r1
 8021740:	3310      	adds	r3, #16
 8021742:	4602      	mov	r2, r0
 8021744:	705a      	strb	r2, [r3, #1]

	/* return the offset */
	return empty;
 8021746:	68bb      	ldr	r3, [r7, #8]
}
 8021748:	4618      	mov	r0, r3
 802174a:	3710      	adds	r7, #16
 802174c:	46bd      	mov	sp, r7
 802174e:	bd80      	pop	{r7, pc}
 8021750:	20012dac 	.word	0x20012dac

08021754 <finsh_var_lookup>:

	return 0;
}

struct finsh_var* finsh_var_lookup(const char* name)
{
 8021754:	b580      	push	{r7, lr}
 8021756:	b084      	sub	sp, #16
 8021758:	af00      	add	r7, sp, #0
 802175a:	6078      	str	r0, [r7, #4]
	int i;

	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
 802175c:	2300      	movs	r3, #0
 802175e:	60fb      	str	r3, [r7, #12]
 8021760:	e012      	b.n	8021788 <finsh_var_lookup+0x34>
	{
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
 8021762:	68fa      	ldr	r2, [r7, #12]
 8021764:	4613      	mov	r3, r2
 8021766:	005b      	lsls	r3, r3, #1
 8021768:	4413      	add	r3, r2
 802176a:	00db      	lsls	r3, r3, #3
 802176c:	4a10      	ldr	r2, [pc, #64]	; (80217b0 <finsh_var_lookup+0x5c>)
 802176e:	4413      	add	r3, r2
 8021770:	4618      	mov	r0, r3
 8021772:	6879      	ldr	r1, [r7, #4]
 8021774:	2210      	movs	r2, #16
 8021776:	f001 fc41 	bl	8022ffc <strncmp>
 802177a:	4603      	mov	r3, r0
 802177c:	2b00      	cmp	r3, #0
 802177e:	d100      	bne.n	8021782 <finsh_var_lookup+0x2e>
			break;
 8021780:	e005      	b.n	802178e <finsh_var_lookup+0x3a>

struct finsh_var* finsh_var_lookup(const char* name)
{
	int i;

	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
 8021782:	68fb      	ldr	r3, [r7, #12]
 8021784:	3301      	adds	r3, #1
 8021786:	60fb      	str	r3, [r7, #12]
 8021788:	68fb      	ldr	r3, [r7, #12]
 802178a:	2b07      	cmp	r3, #7
 802178c:	dde9      	ble.n	8021762 <finsh_var_lookup+0xe>
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
			break;
	}

	/* can't find variable */
	if (i == FINSH_VARIABLE_MAX) return NULL;
 802178e:	68fb      	ldr	r3, [r7, #12]
 8021790:	2b08      	cmp	r3, #8
 8021792:	d101      	bne.n	8021798 <finsh_var_lookup+0x44>
 8021794:	2300      	movs	r3, #0
 8021796:	e006      	b.n	80217a6 <finsh_var_lookup+0x52>

	return &global_variable[i];
 8021798:	68fa      	ldr	r2, [r7, #12]
 802179a:	4613      	mov	r3, r2
 802179c:	005b      	lsls	r3, r3, #1
 802179e:	4413      	add	r3, r2
 80217a0:	00db      	lsls	r3, r3, #3
 80217a2:	4a03      	ldr	r2, [pc, #12]	; (80217b0 <finsh_var_lookup+0x5c>)
 80217a4:	4413      	add	r3, r2
}
 80217a6:	4618      	mov	r0, r3
 80217a8:	3710      	adds	r7, #16
 80217aa:	46bd      	mov	sp, r7
 80217ac:	bd80      	pop	{r7, pc}
 80217ae:	bf00      	nop
 80217b0:	20012dac 	.word	0x20012dac

080217b4 <finsh_sysvar_lookup>:
	}
}
#endif

struct finsh_sysvar* finsh_sysvar_lookup(const char* name)
{
 80217b4:	b590      	push	{r4, r7, lr}
 80217b6:	b085      	sub	sp, #20
 80217b8:	af00      	add	r7, sp, #0
 80217ba:	6078      	str	r0, [r7, #4]
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
 80217bc:	4b1b      	ldr	r3, [pc, #108]	; (802182c <finsh_sysvar_lookup+0x78>)
 80217be:	681b      	ldr	r3, [r3, #0]
 80217c0:	60fb      	str	r3, [r7, #12]
 80217c2:	e00d      	b.n	80217e0 <finsh_sysvar_lookup+0x2c>
	     index < _sysvar_table_end;
	     FINSH_NEXT_SYSVAR(index))
	{
		if (strcmp(index->name, name) == 0)
 80217c4:	68fb      	ldr	r3, [r7, #12]
 80217c6:	681b      	ldr	r3, [r3, #0]
 80217c8:	4618      	mov	r0, r3
 80217ca:	6879      	ldr	r1, [r7, #4]
 80217cc:	f7de fe2c 	bl	8000428 <strcmp>
 80217d0:	4603      	mov	r3, r0
 80217d2:	2b00      	cmp	r3, #0
 80217d4:	d101      	bne.n	80217da <finsh_sysvar_lookup+0x26>
			return index;
 80217d6:	68fb      	ldr	r3, [r7, #12]
 80217d8:	e023      	b.n	8021822 <finsh_sysvar_lookup+0x6e>
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
	     index < _sysvar_table_end;
	     FINSH_NEXT_SYSVAR(index))
 80217da:	68fb      	ldr	r3, [r7, #12]
 80217dc:	3310      	adds	r3, #16
 80217de:	60fb      	str	r3, [r7, #12]
{
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
	     index < _sysvar_table_end;
 80217e0:	4b13      	ldr	r3, [pc, #76]	; (8021830 <finsh_sysvar_lookup+0x7c>)
 80217e2:	681b      	ldr	r3, [r3, #0]
struct finsh_sysvar* finsh_sysvar_lookup(const char* name)
{
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
 80217e4:	68fa      	ldr	r2, [r7, #12]
 80217e6:	429a      	cmp	r2, r3
 80217e8:	d3ec      	bcc.n	80217c4 <finsh_sysvar_lookup+0x10>
		if (strcmp(index->name, name) == 0)
			return index;
	}

	/* find in sysvar list */
	item = global_sysvar_list;
 80217ea:	4b12      	ldr	r3, [pc, #72]	; (8021834 <finsh_sysvar_lookup+0x80>)
 80217ec:	681b      	ldr	r3, [r3, #0]
 80217ee:	60bb      	str	r3, [r7, #8]
	while (item != NULL)
 80217f0:	e013      	b.n	802181a <finsh_sysvar_lookup+0x66>
	{
		if (strncmp(item->sysvar.name, name, strlen(name)) == 0)
 80217f2:	68bb      	ldr	r3, [r7, #8]
 80217f4:	685c      	ldr	r4, [r3, #4]
 80217f6:	6878      	ldr	r0, [r7, #4]
 80217f8:	f001 fbd2 	bl	8022fa0 <strlen>
 80217fc:	4603      	mov	r3, r0
 80217fe:	4620      	mov	r0, r4
 8021800:	6879      	ldr	r1, [r7, #4]
 8021802:	461a      	mov	r2, r3
 8021804:	f001 fbfa 	bl	8022ffc <strncmp>
 8021808:	4603      	mov	r3, r0
 802180a:	2b00      	cmp	r3, #0
 802180c:	d102      	bne.n	8021814 <finsh_sysvar_lookup+0x60>
		{
			return &(item->sysvar);
 802180e:	68bb      	ldr	r3, [r7, #8]
 8021810:	3304      	adds	r3, #4
 8021812:	e006      	b.n	8021822 <finsh_sysvar_lookup+0x6e>
		}

		/* move to next item */
		item = item->next;
 8021814:	68bb      	ldr	r3, [r7, #8]
 8021816:	681b      	ldr	r3, [r3, #0]
 8021818:	60bb      	str	r3, [r7, #8]
			return index;
	}

	/* find in sysvar list */
	item = global_sysvar_list;
	while (item != NULL)
 802181a:	68bb      	ldr	r3, [r7, #8]
 802181c:	2b00      	cmp	r3, #0
 802181e:	d1e8      	bne.n	80217f2 <finsh_sysvar_lookup+0x3e>
		/* move to next item */
		item = item->next;
	}

	/* can't find variable */
	return NULL;
 8021820:	2300      	movs	r3, #0
}
 8021822:	4618      	mov	r0, r3
 8021824:	3714      	adds	r7, #20
 8021826:	46bd      	mov	sp, r7
 8021828:	bd90      	pop	{r4, r7, pc}
 802182a:	bf00      	nop
 802182c:	200121b8 	.word	0x200121b8
 8021830:	200121bc 	.word	0x200121bc
 8021834:	20012da8 	.word	0x20012da8

08021838 <finsh_vm_run>:
/* syscall list, for dynamic system call register */
struct finsh_syscall_item* global_syscall_list = NULL;

// #define FINSH_VM_DISASSEMBLE
void finsh_vm_run()
{
 8021838:	b580      	push	{r7, lr}
 802183a:	b082      	sub	sp, #8
 802183c:	af00      	add	r7, sp, #0
	void finsh_disassemble();
	finsh_disassemble();
#endif

	/* set sp(stack pointer) to the beginning of stack */
	finsh_sp = &finsh_vm_stack[0];
 802183e:	4b12      	ldr	r3, [pc, #72]	; (8021888 <finsh_vm_run+0x50>)
 8021840:	4a12      	ldr	r2, [pc, #72]	; (802188c <finsh_vm_run+0x54>)
 8021842:	601a      	str	r2, [r3, #0]

	/* set pc to the beginning of text segment */
	finsh_pc = &text_segment[0];
 8021844:	4b12      	ldr	r3, [pc, #72]	; (8021890 <finsh_vm_run+0x58>)
 8021846:	4a13      	ldr	r2, [pc, #76]	; (8021894 <finsh_vm_run+0x5c>)
 8021848:	601a      	str	r2, [r3, #0]

	while ((finsh_pc - &text_segment[0] >= 0) &&
 802184a:	e00b      	b.n	8021864 <finsh_vm_run+0x2c>
		(finsh_pc - &text_segment[0] < FINSH_TEXT_MAX))
	{
		/* get op */
		op = *finsh_pc++;
 802184c:	4b10      	ldr	r3, [pc, #64]	; (8021890 <finsh_vm_run+0x58>)
 802184e:	681b      	ldr	r3, [r3, #0]
 8021850:	1c5a      	adds	r2, r3, #1
 8021852:	490f      	ldr	r1, [pc, #60]	; (8021890 <finsh_vm_run+0x58>)
 8021854:	600a      	str	r2, [r1, #0]
 8021856:	781b      	ldrb	r3, [r3, #0]
 8021858:	71fb      	strb	r3, [r7, #7]

		/* call op function */
		op_table[op]();
 802185a:	79fb      	ldrb	r3, [r7, #7]
 802185c:	4a0e      	ldr	r2, [pc, #56]	; (8021898 <finsh_vm_run+0x60>)
 802185e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8021862:	4798      	blx	r3
	finsh_sp = &finsh_vm_stack[0];

	/* set pc to the beginning of text segment */
	finsh_pc = &text_segment[0];

	while ((finsh_pc - &text_segment[0] >= 0) &&
 8021864:	4b0a      	ldr	r3, [pc, #40]	; (8021890 <finsh_vm_run+0x58>)
 8021866:	681b      	ldr	r3, [r3, #0]
 8021868:	461a      	mov	r2, r3
 802186a:	4b0a      	ldr	r3, [pc, #40]	; (8021894 <finsh_vm_run+0x5c>)
 802186c:	1ad3      	subs	r3, r2, r3
 802186e:	2b00      	cmp	r3, #0
 8021870:	db06      	blt.n	8021880 <finsh_vm_run+0x48>
		(finsh_pc - &text_segment[0] < FINSH_TEXT_MAX))
 8021872:	4b07      	ldr	r3, [pc, #28]	; (8021890 <finsh_vm_run+0x58>)
 8021874:	681b      	ldr	r3, [r3, #0]
 8021876:	461a      	mov	r2, r3
 8021878:	4b06      	ldr	r3, [pc, #24]	; (8021894 <finsh_vm_run+0x5c>)
 802187a:	1ad3      	subs	r3, r2, r3
	finsh_sp = &finsh_vm_stack[0];

	/* set pc to the beginning of text segment */
	finsh_pc = &text_segment[0];

	while ((finsh_pc - &text_segment[0] >= 0) &&
 802187c:	2b7f      	cmp	r3, #127	; 0x7f
 802187e:	dde5      	ble.n	802184c <finsh_vm_run+0x14>
		op = *finsh_pc++;

		/* call op function */
		op_table[op]();
	}
}
 8021880:	3708      	adds	r7, #8
 8021882:	46bd      	mov	sp, r7
 8021884:	bd80      	pop	{r7, pc}
 8021886:	bf00      	nop
 8021888:	20012ff0 	.word	0x20012ff0
 802188c:	20012eec 	.word	0x20012eec
 8021890:	20012fec 	.word	0x20012fec
 8021894:	20012e6c 	.word	0x20012e6c
 8021898:	0802b428 	.word	0x0802b428

0802189c <finsh_syscall_lookup>:
	return (struct finsh_sysvar*)ptr;
}
#endif

struct finsh_syscall* finsh_syscall_lookup(const char* name)
{
 802189c:	b590      	push	{r4, r7, lr}
 802189e:	b085      	sub	sp, #20
 80218a0:	af00      	add	r7, sp, #0
 80218a2:	6078      	str	r0, [r7, #4]
	struct finsh_syscall* index;
	struct finsh_syscall_item* item;

	for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
 80218a4:	4b1b      	ldr	r3, [pc, #108]	; (8021914 <finsh_syscall_lookup+0x78>)
 80218a6:	681b      	ldr	r3, [r3, #0]
 80218a8:	60fb      	str	r3, [r7, #12]
 80218aa:	e00d      	b.n	80218c8 <finsh_syscall_lookup+0x2c>
	{
		if (strcmp(index->name, name) == 0)
 80218ac:	68fb      	ldr	r3, [r7, #12]
 80218ae:	681b      	ldr	r3, [r3, #0]
 80218b0:	4618      	mov	r0, r3
 80218b2:	6879      	ldr	r1, [r7, #4]
 80218b4:	f7de fdb8 	bl	8000428 <strcmp>
 80218b8:	4603      	mov	r3, r0
 80218ba:	2b00      	cmp	r3, #0
 80218bc:	d101      	bne.n	80218c2 <finsh_syscall_lookup+0x26>
			return index;
 80218be:	68fb      	ldr	r3, [r7, #12]
 80218c0:	e023      	b.n	802190a <finsh_syscall_lookup+0x6e>
struct finsh_syscall* finsh_syscall_lookup(const char* name)
{
	struct finsh_syscall* index;
	struct finsh_syscall_item* item;

	for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
 80218c2:	68fb      	ldr	r3, [r7, #12]
 80218c4:	330c      	adds	r3, #12
 80218c6:	60fb      	str	r3, [r7, #12]
 80218c8:	4b13      	ldr	r3, [pc, #76]	; (8021918 <finsh_syscall_lookup+0x7c>)
 80218ca:	681b      	ldr	r3, [r3, #0]
 80218cc:	68fa      	ldr	r2, [r7, #12]
 80218ce:	429a      	cmp	r2, r3
 80218d0:	d3ec      	bcc.n	80218ac <finsh_syscall_lookup+0x10>
		if (strcmp(index->name, name) == 0)
			return index;
	}

	/* find on syscall list */
	item = global_syscall_list;
 80218d2:	4b12      	ldr	r3, [pc, #72]	; (802191c <finsh_syscall_lookup+0x80>)
 80218d4:	681b      	ldr	r3, [r3, #0]
 80218d6:	60bb      	str	r3, [r7, #8]
	while (item != NULL)
 80218d8:	e013      	b.n	8021902 <finsh_syscall_lookup+0x66>
	{
		if (strncmp(item->syscall.name, name, strlen(name)) == 0)
 80218da:	68bb      	ldr	r3, [r7, #8]
 80218dc:	685c      	ldr	r4, [r3, #4]
 80218de:	6878      	ldr	r0, [r7, #4]
 80218e0:	f001 fb5e 	bl	8022fa0 <strlen>
 80218e4:	4603      	mov	r3, r0
 80218e6:	4620      	mov	r0, r4
 80218e8:	6879      	ldr	r1, [r7, #4]
 80218ea:	461a      	mov	r2, r3
 80218ec:	f001 fb86 	bl	8022ffc <strncmp>
 80218f0:	4603      	mov	r3, r0
 80218f2:	2b00      	cmp	r3, #0
 80218f4:	d102      	bne.n	80218fc <finsh_syscall_lookup+0x60>
		{
			return &(item->syscall);
 80218f6:	68bb      	ldr	r3, [r7, #8]
 80218f8:	3304      	adds	r3, #4
 80218fa:	e006      	b.n	802190a <finsh_syscall_lookup+0x6e>
		}

		item = item->next;
 80218fc:	68bb      	ldr	r3, [r7, #8]
 80218fe:	681b      	ldr	r3, [r3, #0]
 8021900:	60bb      	str	r3, [r7, #8]
			return index;
	}

	/* find on syscall list */
	item = global_syscall_list;
	while (item != NULL)
 8021902:	68bb      	ldr	r3, [r7, #8]
 8021904:	2b00      	cmp	r3, #0
 8021906:	d1e8      	bne.n	80218da <finsh_syscall_lookup+0x3e>
		}

		item = item->next;
	}

	return NULL;
 8021908:	2300      	movs	r3, #0
}
 802190a:	4618      	mov	r0, r3
 802190c:	3714      	adds	r7, #20
 802190e:	46bd      	mov	sp, r7
 8021910:	bd90      	pop	{r4, r7, pc}
 8021912:	bf00      	nop
 8021914:	200121b0 	.word	0x200121b0
 8021918:	200121b4 	.word	0x200121b4
 802191c:	200121cc 	.word	0x200121cc

08021920 <finsh_token_init>:
static void token_trim_space(struct finsh_token* self);
static char token_proc_char(struct finsh_token* self);
static int token_proc_escape(struct finsh_token* self);

void finsh_token_init(struct finsh_token* self, u_char* line)
{
 8021920:	b580      	push	{r7, lr}
 8021922:	b082      	sub	sp, #8
 8021924:	af00      	add	r7, sp, #0
 8021926:	6078      	str	r0, [r7, #4]
 8021928:	6039      	str	r1, [r7, #0]
	memset(self, 0, sizeof(struct finsh_token));
 802192a:	6878      	ldr	r0, [r7, #4]
 802192c:	2100      	movs	r1, #0
 802192e:	2294      	movs	r2, #148	; 0x94
 8021930:	f000 fea4 	bl	802267c <memset>

	self->line = line;
 8021934:	687b      	ldr	r3, [r7, #4]
 8021936:	683a      	ldr	r2, [r7, #0]
 8021938:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
}
 802193c:	3708      	adds	r7, #8
 802193e:	46bd      	mov	sp, r7
 8021940:	bd80      	pop	{r7, pc}
 8021942:	bf00      	nop

08021944 <finsh_token_token>:

enum finsh_token_type finsh_token_token(struct finsh_token* self)
{
 8021944:	b580      	push	{r7, lr}
 8021946:	b082      	sub	sp, #8
 8021948:	af00      	add	r7, sp, #0
 802194a:	6078      	str	r0, [r7, #4]
	if ( self->replay )	self->replay = 0;
 802194c:	687b      	ldr	r3, [r7, #4]
 802194e:	785b      	ldrb	r3, [r3, #1]
 8021950:	2b00      	cmp	r3, #0
 8021952:	d003      	beq.n	802195c <finsh_token_token+0x18>
 8021954:	687b      	ldr	r3, [r7, #4]
 8021956:	2200      	movs	r2, #0
 8021958:	705a      	strb	r2, [r3, #1]
 802195a:	e002      	b.n	8021962 <finsh_token_token+0x1e>
	else token_run(self);
 802195c:	6878      	ldr	r0, [r7, #4]
 802195e:	f000 f8a7 	bl	8021ab0 <token_run>

	return (enum finsh_token_type)self->current_token;
 8021962:	687b      	ldr	r3, [r7, #4]
 8021964:	7a1b      	ldrb	r3, [r3, #8]
}
 8021966:	4618      	mov	r0, r3
 8021968:	3708      	adds	r7, #8
 802196a:	46bd      	mov	sp, r7
 802196c:	bd80      	pop	{r7, pc}
 802196e:	bf00      	nop

08021970 <token_get_string>:
{
	strncpy((char*)token, (char*)self->string, FINSH_NAME_MAX);
}

int token_get_string(struct finsh_token* self, u_char* str)
{
 8021970:	b580      	push	{r7, lr}
 8021972:	b084      	sub	sp, #16
 8021974:	af00      	add	r7, sp, #0
 8021976:	6078      	str	r0, [r7, #4]
 8021978:	6039      	str	r1, [r7, #0]
	unsigned char *p=str;
 802197a:	683b      	ldr	r3, [r7, #0]
 802197c:	60fb      	str	r3, [r7, #12]
	char ch;

	ch = token_next_char(self);
 802197e:	6878      	ldr	r0, [r7, #4]
 8021980:	f000 f84a 	bl	8021a18 <token_next_char>
 8021984:	4603      	mov	r3, r0
 8021986:	72fb      	strb	r3, [r7, #11]
	if (is_eof(self)) return -1;
 8021988:	687b      	ldr	r3, [r7, #4]
 802198a:	781b      	ldrb	r3, [r3, #0]
 802198c:	2b00      	cmp	r3, #0
 802198e:	d002      	beq.n	8021996 <token_get_string+0x26>
 8021990:	f04f 33ff 	mov.w	r3, #4294967295
 8021994:	e03c      	b.n	8021a10 <token_get_string+0xa0>

	str[0] = '\0';
 8021996:	683b      	ldr	r3, [r7, #0]
 8021998:	2200      	movs	r2, #0
 802199a:	701a      	strb	r2, [r3, #0]

	if ( is_digit(ch) )/*the first character of identifier is not a digit.*/
 802199c:	7afb      	ldrb	r3, [r7, #11]
 802199e:	2b2f      	cmp	r3, #47	; 0x2f
 80219a0:	d908      	bls.n	80219b4 <token_get_string+0x44>
 80219a2:	7afb      	ldrb	r3, [r7, #11]
 80219a4:	2b39      	cmp	r3, #57	; 0x39
 80219a6:	d805      	bhi.n	80219b4 <token_get_string+0x44>
	{
		token_prev_char(self);
 80219a8:	6878      	ldr	r0, [r7, #4]
 80219aa:	f000 f869 	bl	8021a80 <token_prev_char>
		return -1;
 80219ae:	f04f 33ff 	mov.w	r3, #4294967295
 80219b2:	e02d      	b.n	8021a10 <token_get_string+0xa0>
	}

	while (!is_separator(ch) && !is_eof(self))
 80219b4:	e009      	b.n	80219ca <token_get_string+0x5a>
	{
		*p++ = ch;
 80219b6:	68fb      	ldr	r3, [r7, #12]
 80219b8:	1c5a      	adds	r2, r3, #1
 80219ba:	60fa      	str	r2, [r7, #12]
 80219bc:	7afa      	ldrb	r2, [r7, #11]
 80219be:	701a      	strb	r2, [r3, #0]

		ch = token_next_char(self);
 80219c0:	6878      	ldr	r0, [r7, #4]
 80219c2:	f000 f829 	bl	8021a18 <token_next_char>
 80219c6:	4603      	mov	r3, r0
 80219c8:	72fb      	strb	r3, [r7, #11]
	{
		token_prev_char(self);
		return -1;
	}

	while (!is_separator(ch) && !is_eof(self))
 80219ca:	7afb      	ldrb	r3, [r7, #11]
 80219cc:	2b60      	cmp	r3, #96	; 0x60
 80219ce:	d902      	bls.n	80219d6 <token_get_string+0x66>
 80219d0:	7afb      	ldrb	r3, [r7, #11]
 80219d2:	2b7a      	cmp	r3, #122	; 0x7a
 80219d4:	d90e      	bls.n	80219f4 <token_get_string+0x84>
 80219d6:	7afb      	ldrb	r3, [r7, #11]
 80219d8:	2b40      	cmp	r3, #64	; 0x40
 80219da:	d902      	bls.n	80219e2 <token_get_string+0x72>
 80219dc:	7afb      	ldrb	r3, [r7, #11]
 80219de:	2b5a      	cmp	r3, #90	; 0x5a
 80219e0:	d908      	bls.n	80219f4 <token_get_string+0x84>
 80219e2:	7afb      	ldrb	r3, [r7, #11]
 80219e4:	2b2f      	cmp	r3, #47	; 0x2f
 80219e6:	d902      	bls.n	80219ee <token_get_string+0x7e>
 80219e8:	7afb      	ldrb	r3, [r7, #11]
 80219ea:	2b39      	cmp	r3, #57	; 0x39
 80219ec:	d902      	bls.n	80219f4 <token_get_string+0x84>
 80219ee:	7afb      	ldrb	r3, [r7, #11]
 80219f0:	2b5f      	cmp	r3, #95	; 0x5f
 80219f2:	d103      	bne.n	80219fc <token_get_string+0x8c>
 80219f4:	687b      	ldr	r3, [r7, #4]
 80219f6:	781b      	ldrb	r3, [r3, #0]
 80219f8:	2b00      	cmp	r3, #0
 80219fa:	d0dc      	beq.n	80219b6 <token_get_string+0x46>
	{
		*p++ = ch;

		ch = token_next_char(self);
	}
	self->eof = 0;
 80219fc:	687b      	ldr	r3, [r7, #4]
 80219fe:	2200      	movs	r2, #0
 8021a00:	701a      	strb	r2, [r3, #0]

	token_prev_char(self);
 8021a02:	6878      	ldr	r0, [r7, #4]
 8021a04:	f000 f83c 	bl	8021a80 <token_prev_char>
	*p = '\0';
 8021a08:	68fb      	ldr	r3, [r7, #12]
 8021a0a:	2200      	movs	r2, #0
 8021a0c:	701a      	strb	r2, [r3, #0]

	return 0;
 8021a0e:	2300      	movs	r3, #0
}
 8021a10:	4618      	mov	r0, r3
 8021a12:	3710      	adds	r7, #16
 8021a14:	46bd      	mov	sp, r7
 8021a16:	bd80      	pop	{r7, pc}

08021a18 <token_next_char>:

/*
get next character.
*/
static char token_next_char(struct finsh_token* self)
{
 8021a18:	b590      	push	{r4, r7, lr}
 8021a1a:	b083      	sub	sp, #12
 8021a1c:	af00      	add	r7, sp, #0
 8021a1e:	6078      	str	r0, [r7, #4]
	if (self->eof) return '\0';
 8021a20:	687b      	ldr	r3, [r7, #4]
 8021a22:	781b      	ldrb	r3, [r3, #0]
 8021a24:	2b00      	cmp	r3, #0
 8021a26:	d001      	beq.n	8021a2c <token_next_char+0x14>
 8021a28:	2300      	movs	r3, #0
 8021a2a:	e025      	b.n	8021a78 <token_next_char+0x60>

	if (self->position == (int)strlen((char*)self->line) || self->line[self->position] =='\n')
 8021a2c:	687b      	ldr	r3, [r7, #4]
 8021a2e:	685c      	ldr	r4, [r3, #4]
 8021a30:	687b      	ldr	r3, [r7, #4]
 8021a32:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8021a36:	4618      	mov	r0, r3
 8021a38:	f001 fab2 	bl	8022fa0 <strlen>
 8021a3c:	4603      	mov	r3, r0
 8021a3e:	429c      	cmp	r4, r3
 8021a40:	d008      	beq.n	8021a54 <token_next_char+0x3c>
 8021a42:	687b      	ldr	r3, [r7, #4]
 8021a44:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8021a48:	687a      	ldr	r2, [r7, #4]
 8021a4a:	6852      	ldr	r2, [r2, #4]
 8021a4c:	4413      	add	r3, r2
 8021a4e:	781b      	ldrb	r3, [r3, #0]
 8021a50:	2b0a      	cmp	r3, #10
 8021a52:	d107      	bne.n	8021a64 <token_next_char+0x4c>
	{
			self->eof = 1;
 8021a54:	687b      	ldr	r3, [r7, #4]
 8021a56:	2201      	movs	r2, #1
 8021a58:	701a      	strb	r2, [r3, #0]
			self->position = 0;
 8021a5a:	687b      	ldr	r3, [r7, #4]
 8021a5c:	2200      	movs	r2, #0
 8021a5e:	605a      	str	r2, [r3, #4]
			return '\0';
 8021a60:	2300      	movs	r3, #0
 8021a62:	e009      	b.n	8021a78 <token_next_char+0x60>
	}

	return self->line[self->position++];
 8021a64:	687b      	ldr	r3, [r7, #4]
 8021a66:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8021a6a:	687b      	ldr	r3, [r7, #4]
 8021a6c:	685b      	ldr	r3, [r3, #4]
 8021a6e:	1c58      	adds	r0, r3, #1
 8021a70:	6879      	ldr	r1, [r7, #4]
 8021a72:	6048      	str	r0, [r1, #4]
 8021a74:	4413      	add	r3, r2
 8021a76:	781b      	ldrb	r3, [r3, #0]
}
 8021a78:	4618      	mov	r0, r3
 8021a7a:	370c      	adds	r7, #12
 8021a7c:	46bd      	mov	sp, r7
 8021a7e:	bd90      	pop	{r4, r7, pc}

08021a80 <token_prev_char>:

static void token_prev_char(struct finsh_token* self)
{
 8021a80:	b480      	push	{r7}
 8021a82:	b083      	sub	sp, #12
 8021a84:	af00      	add	r7, sp, #0
 8021a86:	6078      	str	r0, [r7, #4]
	if ( self->eof ) return;
 8021a88:	687b      	ldr	r3, [r7, #4]
 8021a8a:	781b      	ldrb	r3, [r3, #0]
 8021a8c:	2b00      	cmp	r3, #0
 8021a8e:	d000      	beq.n	8021a92 <token_prev_char+0x12>
 8021a90:	e009      	b.n	8021aa6 <token_prev_char+0x26>

	if ( self->position == 0 ) return;
 8021a92:	687b      	ldr	r3, [r7, #4]
 8021a94:	685b      	ldr	r3, [r3, #4]
 8021a96:	2b00      	cmp	r3, #0
 8021a98:	d100      	bne.n	8021a9c <token_prev_char+0x1c>
 8021a9a:	e004      	b.n	8021aa6 <token_prev_char+0x26>
    else self->position--;
 8021a9c:	687b      	ldr	r3, [r7, #4]
 8021a9e:	685b      	ldr	r3, [r3, #4]
 8021aa0:	1e5a      	subs	r2, r3, #1
 8021aa2:	687b      	ldr	r3, [r7, #4]
 8021aa4:	605a      	str	r2, [r3, #4]
}
 8021aa6:	370c      	adds	r7, #12
 8021aa8:	46bd      	mov	sp, r7
 8021aaa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021aae:	4770      	bx	lr

08021ab0 <token_run>:

static void token_run(struct finsh_token* self)
{
 8021ab0:	b580      	push	{r7, lr}
 8021ab2:	b084      	sub	sp, #16
 8021ab4:	af00      	add	r7, sp, #0
 8021ab6:	6078      	str	r0, [r7, #4]
	char ch;

	token_trim_space(self); /* first trim space and tab. */
 8021ab8:	6878      	ldr	r0, [r7, #4]
 8021aba:	f000 f9c5 	bl	8021e48 <token_trim_space>
	token_get_string(self, &(self->string[0]));
 8021abe:	687b      	ldr	r3, [r7, #4]
 8021ac0:	3310      	adds	r3, #16
 8021ac2:	6878      	ldr	r0, [r7, #4]
 8021ac4:	4619      	mov	r1, r3
 8021ac6:	f7ff ff53 	bl	8021970 <token_get_string>

	if ( is_eof(self) ) /*if it is eof, break;*/
 8021aca:	687b      	ldr	r3, [r7, #4]
 8021acc:	781b      	ldrb	r3, [r3, #0]
 8021ace:	2b00      	cmp	r3, #0
 8021ad0:	d003      	beq.n	8021ada <token_run+0x2a>
	{
		self->current_token = finsh_token_type_eof;
 8021ad2:	687b      	ldr	r3, [r7, #4]
 8021ad4:	2221      	movs	r2, #33	; 0x21
 8021ad6:	721a      	strb	r2, [r3, #8]
		return ;
 8021ad8:	e189      	b.n	8021dee <token_run+0x33e>
	}

	if (self->string[0] != '\0') /*It is a key word or a identifier.*/
 8021ada:	687b      	ldr	r3, [r7, #4]
 8021adc:	7c1b      	ldrb	r3, [r3, #16]
 8021ade:	2b00      	cmp	r3, #0
 8021ae0:	d00d      	beq.n	8021afe <token_run+0x4e>
	{
		if ( !token_match_name(self, (char*)self->string) )
 8021ae2:	687b      	ldr	r3, [r7, #4]
 8021ae4:	3310      	adds	r3, #16
 8021ae6:	6878      	ldr	r0, [r7, #4]
 8021ae8:	4619      	mov	r1, r3
 8021aea:	f000 f983 	bl	8021df4 <token_match_name>
 8021aee:	4603      	mov	r3, r0
 8021af0:	2b00      	cmp	r3, #0
 8021af2:	f040 817c 	bne.w	8021dee <token_run+0x33e>
		{
			self->current_token = finsh_token_type_identifier;
 8021af6:	687b      	ldr	r3, [r7, #4]
 8021af8:	221f      	movs	r2, #31
 8021afa:	721a      	strb	r2, [r3, #8]
 8021afc:	e177      	b.n	8021dee <token_run+0x33e>
		}
	}
	else/*It is a operator character.*/
	{
		ch = token_next_char(self);
 8021afe:	6878      	ldr	r0, [r7, #4]
 8021b00:	f7ff ff8a 	bl	8021a18 <token_next_char>
 8021b04:	4603      	mov	r3, r0
 8021b06:	73fb      	strb	r3, [r7, #15]

		switch ( ch )
 8021b08:	7bfb      	ldrb	r3, [r7, #15]
 8021b0a:	3b22      	subs	r3, #34	; 0x22
 8021b0c:	2b5c      	cmp	r3, #92	; 0x5c
 8021b0e:	f200 815a 	bhi.w	8021dc6 <token_run+0x316>
 8021b12:	a201      	add	r2, pc, #4	; (adr r2, 8021b18 <token_run+0x68>)
 8021b14:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8021b18:	08021db9 	.word	0x08021db9
 8021b1c:	08021dc7 	.word	0x08021dc7
 8021b20:	08021dc7 	.word	0x08021dc7
 8021b24:	08021d83 	.word	0x08021d83
 8021b28:	08021cad 	.word	0x08021cad
 8021b2c:	08021da3 	.word	0x08021da3
 8021b30:	08021c8d 	.word	0x08021c8d
 8021b34:	08021c95 	.word	0x08021c95
 8021b38:	08021cb5 	.word	0x08021cb5
 8021b3c:	08021cbd 	.word	0x08021cbd
 8021b40:	08021c9d 	.word	0x08021c9d
 8021b44:	08021ce3 	.word	0x08021ce3
 8021b48:	08021dc7 	.word	0x08021dc7
 8021b4c:	08021d09 	.word	0x08021d09
 8021b50:	08021dc7 	.word	0x08021dc7
 8021b54:	08021dc7 	.word	0x08021dc7
 8021b58:	08021dc7 	.word	0x08021dc7
 8021b5c:	08021dc7 	.word	0x08021dc7
 8021b60:	08021dc7 	.word	0x08021dc7
 8021b64:	08021dc7 	.word	0x08021dc7
 8021b68:	08021dc7 	.word	0x08021dc7
 8021b6c:	08021dc7 	.word	0x08021dc7
 8021b70:	08021dc7 	.word	0x08021dc7
 8021b74:	08021dc7 	.word	0x08021dc7
 8021b78:	08021dc7 	.word	0x08021dc7
 8021b7c:	08021ca5 	.word	0x08021ca5
 8021b80:	08021d2f 	.word	0x08021d2f
 8021b84:	08021d9b 	.word	0x08021d9b
 8021b88:	08021d55 	.word	0x08021d55
 8021b8c:	08021dc7 	.word	0x08021dc7
 8021b90:	08021dc7 	.word	0x08021dc7
 8021b94:	08021dc7 	.word	0x08021dc7
 8021b98:	08021dc7 	.word	0x08021dc7
 8021b9c:	08021dc7 	.word	0x08021dc7
 8021ba0:	08021dc7 	.word	0x08021dc7
 8021ba4:	08021dc7 	.word	0x08021dc7
 8021ba8:	08021dc7 	.word	0x08021dc7
 8021bac:	08021dc7 	.word	0x08021dc7
 8021bb0:	08021dc7 	.word	0x08021dc7
 8021bb4:	08021dc7 	.word	0x08021dc7
 8021bb8:	08021dc7 	.word	0x08021dc7
 8021bbc:	08021dc7 	.word	0x08021dc7
 8021bc0:	08021dc7 	.word	0x08021dc7
 8021bc4:	08021dc7 	.word	0x08021dc7
 8021bc8:	08021dc7 	.word	0x08021dc7
 8021bcc:	08021dc7 	.word	0x08021dc7
 8021bd0:	08021dc7 	.word	0x08021dc7
 8021bd4:	08021dc7 	.word	0x08021dc7
 8021bd8:	08021dc7 	.word	0x08021dc7
 8021bdc:	08021dc7 	.word	0x08021dc7
 8021be0:	08021dc7 	.word	0x08021dc7
 8021be4:	08021dc7 	.word	0x08021dc7
 8021be8:	08021dc7 	.word	0x08021dc7
 8021bec:	08021dc7 	.word	0x08021dc7
 8021bf0:	08021dc7 	.word	0x08021dc7
 8021bf4:	08021dc7 	.word	0x08021dc7
 8021bf8:	08021dc7 	.word	0x08021dc7
 8021bfc:	08021dc7 	.word	0x08021dc7
 8021c00:	08021dc7 	.word	0x08021dc7
 8021c04:	08021dc7 	.word	0x08021dc7
 8021c08:	08021d93 	.word	0x08021d93
 8021c0c:	08021dc7 	.word	0x08021dc7
 8021c10:	08021dc7 	.word	0x08021dc7
 8021c14:	08021dc7 	.word	0x08021dc7
 8021c18:	08021dc7 	.word	0x08021dc7
 8021c1c:	08021dc7 	.word	0x08021dc7
 8021c20:	08021dc7 	.word	0x08021dc7
 8021c24:	08021dc7 	.word	0x08021dc7
 8021c28:	08021dc7 	.word	0x08021dc7
 8021c2c:	08021dc7 	.word	0x08021dc7
 8021c30:	08021dc7 	.word	0x08021dc7
 8021c34:	08021dc7 	.word	0x08021dc7
 8021c38:	08021dc7 	.word	0x08021dc7
 8021c3c:	08021dc7 	.word	0x08021dc7
 8021c40:	08021dc7 	.word	0x08021dc7
 8021c44:	08021dc7 	.word	0x08021dc7
 8021c48:	08021dc7 	.word	0x08021dc7
 8021c4c:	08021dc7 	.word	0x08021dc7
 8021c50:	08021dc7 	.word	0x08021dc7
 8021c54:	08021dc7 	.word	0x08021dc7
 8021c58:	08021dc7 	.word	0x08021dc7
 8021c5c:	08021dc7 	.word	0x08021dc7
 8021c60:	08021dc7 	.word	0x08021dc7
 8021c64:	08021dc7 	.word	0x08021dc7
 8021c68:	08021dc7 	.word	0x08021dc7
 8021c6c:	08021dc7 	.word	0x08021dc7
 8021c70:	08021dc7 	.word	0x08021dc7
 8021c74:	08021dc7 	.word	0x08021dc7
 8021c78:	08021dc7 	.word	0x08021dc7
 8021c7c:	08021dc7 	.word	0x08021dc7
 8021c80:	08021d7b 	.word	0x08021d7b
 8021c84:	08021dc7 	.word	0x08021dc7
 8021c88:	08021d8b 	.word	0x08021d8b
		{
		case '(':
			self->current_token = finsh_token_type_left_paren;
 8021c8c:	687b      	ldr	r3, [r7, #4]
 8021c8e:	2201      	movs	r2, #1
 8021c90:	721a      	strb	r2, [r3, #8]
			break;
 8021c92:	e0ac      	b.n	8021dee <token_run+0x33e>

		case ')':
			self->current_token = finsh_token_type_right_paren;
 8021c94:	687b      	ldr	r3, [r7, #4]
 8021c96:	2202      	movs	r2, #2
 8021c98:	721a      	strb	r2, [r3, #8]
			break;
 8021c9a:	e0a8      	b.n	8021dee <token_run+0x33e>

		case ',':
			self->current_token = finsh_token_type_comma;
 8021c9c:	687b      	ldr	r3, [r7, #4]
 8021c9e:	2203      	movs	r2, #3
 8021ca0:	721a      	strb	r2, [r3, #8]
			break;
 8021ca2:	e0a4      	b.n	8021dee <token_run+0x33e>

		case ';':
			self->current_token = finsh_token_type_semicolon;
 8021ca4:	687b      	ldr	r3, [r7, #4]
 8021ca6:	2204      	movs	r2, #4
 8021ca8:	721a      	strb	r2, [r3, #8]
			break;
 8021caa:	e0a0      	b.n	8021dee <token_run+0x33e>

		case '&':
			self->current_token = finsh_token_type_and;
 8021cac:	687b      	ldr	r3, [r7, #4]
 8021cae:	220d      	movs	r2, #13
 8021cb0:	721a      	strb	r2, [r3, #8]
			break;
 8021cb2:	e09c      	b.n	8021dee <token_run+0x33e>

		case '*':
			self->current_token = finsh_token_type_mul;
 8021cb4:	687b      	ldr	r3, [r7, #4]
 8021cb6:	2205      	movs	r2, #5
 8021cb8:	721a      	strb	r2, [r3, #8]
			break;
 8021cba:	e098      	b.n	8021dee <token_run+0x33e>

		case '+':
			ch = token_next_char(self);
 8021cbc:	6878      	ldr	r0, [r7, #4]
 8021cbe:	f7ff feab 	bl	8021a18 <token_next_char>
 8021cc2:	4603      	mov	r3, r0
 8021cc4:	73fb      	strb	r3, [r7, #15]

			if ( ch == '+' )
 8021cc6:	7bfb      	ldrb	r3, [r7, #15]
 8021cc8:	2b2b      	cmp	r3, #43	; 0x2b
 8021cca:	d103      	bne.n	8021cd4 <token_run+0x224>
			{
				self->current_token = finsh_token_type_inc;
 8021ccc:	687b      	ldr	r3, [r7, #4]
 8021cce:	2207      	movs	r2, #7
 8021cd0:	721a      	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_add;
			}
			break;
 8021cd2:	e08c      	b.n	8021dee <token_run+0x33e>
			{
				self->current_token = finsh_token_type_inc;
			}
			else
			{
				token_prev_char(self);
 8021cd4:	6878      	ldr	r0, [r7, #4]
 8021cd6:	f7ff fed3 	bl	8021a80 <token_prev_char>
				self->current_token = finsh_token_type_add;
 8021cda:	687b      	ldr	r3, [r7, #4]
 8021cdc:	2206      	movs	r2, #6
 8021cde:	721a      	strb	r2, [r3, #8]
			}
			break;
 8021ce0:	e085      	b.n	8021dee <token_run+0x33e>

		case '-':
			ch = token_next_char(self);
 8021ce2:	6878      	ldr	r0, [r7, #4]
 8021ce4:	f7ff fe98 	bl	8021a18 <token_next_char>
 8021ce8:	4603      	mov	r3, r0
 8021cea:	73fb      	strb	r3, [r7, #15]

			if ( ch == '-' )
 8021cec:	7bfb      	ldrb	r3, [r7, #15]
 8021cee:	2b2d      	cmp	r3, #45	; 0x2d
 8021cf0:	d103      	bne.n	8021cfa <token_run+0x24a>
			{
				self->current_token = finsh_token_type_dec;
 8021cf2:	687b      	ldr	r3, [r7, #4]
 8021cf4:	2209      	movs	r2, #9
 8021cf6:	721a      	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_sub;
			}
			break;
 8021cf8:	e079      	b.n	8021dee <token_run+0x33e>
			{
				self->current_token = finsh_token_type_dec;
			}
			else
			{
				token_prev_char(self);
 8021cfa:	6878      	ldr	r0, [r7, #4]
 8021cfc:	f7ff fec0 	bl	8021a80 <token_prev_char>
				self->current_token = finsh_token_type_sub;
 8021d00:	687b      	ldr	r3, [r7, #4]
 8021d02:	2208      	movs	r2, #8
 8021d04:	721a      	strb	r2, [r3, #8]
			}
			break;
 8021d06:	e072      	b.n	8021dee <token_run+0x33e>

		case '/':
			ch = token_next_char(self);
 8021d08:	6878      	ldr	r0, [r7, #4]
 8021d0a:	f7ff fe85 	bl	8021a18 <token_next_char>
 8021d0e:	4603      	mov	r3, r0
 8021d10:	73fb      	strb	r3, [r7, #15]
			if (ch == '/')
 8021d12:	7bfb      	ldrb	r3, [r7, #15]
 8021d14:	2b2f      	cmp	r3, #47	; 0x2f
 8021d16:	d103      	bne.n	8021d20 <token_run+0x270>
			{
				/* line comments, set to end of file */
				self->current_token = finsh_token_type_eof;
 8021d18:	687b      	ldr	r3, [r7, #4]
 8021d1a:	2221      	movs	r2, #33	; 0x21
 8021d1c:	721a      	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_div;
			}
			break;
 8021d1e:	e066      	b.n	8021dee <token_run+0x33e>
				/* line comments, set to end of file */
				self->current_token = finsh_token_type_eof;
			}
			else
			{
				token_prev_char(self);
 8021d20:	6878      	ldr	r0, [r7, #4]
 8021d22:	f7ff fead 	bl	8021a80 <token_prev_char>
				self->current_token = finsh_token_type_div;
 8021d26:	687b      	ldr	r3, [r7, #4]
 8021d28:	220a      	movs	r2, #10
 8021d2a:	721a      	strb	r2, [r3, #8]
			}
			break;
 8021d2c:	e05f      	b.n	8021dee <token_run+0x33e>

		case '<':
			ch = token_next_char(self);
 8021d2e:	6878      	ldr	r0, [r7, #4]
 8021d30:	f7ff fe72 	bl	8021a18 <token_next_char>
 8021d34:	4603      	mov	r3, r0
 8021d36:	73fb      	strb	r3, [r7, #15]

			if ( ch == '<' )
 8021d38:	7bfb      	ldrb	r3, [r7, #15]
 8021d3a:	2b3c      	cmp	r3, #60	; 0x3c
 8021d3c:	d103      	bne.n	8021d46 <token_run+0x296>
			{
				self->current_token = finsh_token_type_shl;
 8021d3e:	687b      	ldr	r3, [r7, #4]
 8021d40:	2211      	movs	r2, #17
 8021d42:	721a      	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_bad;
			}
			break;
 8021d44:	e053      	b.n	8021dee <token_run+0x33e>
			{
				self->current_token = finsh_token_type_shl;
			}
			else
			{
				token_prev_char(self);
 8021d46:	6878      	ldr	r0, [r7, #4]
 8021d48:	f7ff fe9a 	bl	8021a80 <token_prev_char>
				self->current_token = finsh_token_type_bad;
 8021d4c:	687b      	ldr	r3, [r7, #4]
 8021d4e:	2220      	movs	r2, #32
 8021d50:	721a      	strb	r2, [r3, #8]
			}
			break;
 8021d52:	e04c      	b.n	8021dee <token_run+0x33e>

		case '>':
			ch = token_next_char(self);
 8021d54:	6878      	ldr	r0, [r7, #4]
 8021d56:	f7ff fe5f 	bl	8021a18 <token_next_char>
 8021d5a:	4603      	mov	r3, r0
 8021d5c:	73fb      	strb	r3, [r7, #15]

			if ( ch == '>' )
 8021d5e:	7bfb      	ldrb	r3, [r7, #15]
 8021d60:	2b3e      	cmp	r3, #62	; 0x3e
 8021d62:	d103      	bne.n	8021d6c <token_run+0x2bc>
			{
				self->current_token = finsh_token_type_shr;
 8021d64:	687b      	ldr	r3, [r7, #4]
 8021d66:	2212      	movs	r2, #18
 8021d68:	721a      	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_bad;
			}
			break;
 8021d6a:	e040      	b.n	8021dee <token_run+0x33e>
			{
				self->current_token = finsh_token_type_shr;
			}
			else
			{
				token_prev_char(self);
 8021d6c:	6878      	ldr	r0, [r7, #4]
 8021d6e:	f7ff fe87 	bl	8021a80 <token_prev_char>
				self->current_token = finsh_token_type_bad;
 8021d72:	687b      	ldr	r3, [r7, #4]
 8021d74:	2220      	movs	r2, #32
 8021d76:	721a      	strb	r2, [r3, #8]
			}
			break;
 8021d78:	e039      	b.n	8021dee <token_run+0x33e>

		case '|':
			self->current_token = finsh_token_type_or;
 8021d7a:	687b      	ldr	r3, [r7, #4]
 8021d7c:	220e      	movs	r2, #14
 8021d7e:	721a      	strb	r2, [r3, #8]
			break;
 8021d80:	e035      	b.n	8021dee <token_run+0x33e>

		case '%':
			self->current_token = finsh_token_type_mod;
 8021d82:	687b      	ldr	r3, [r7, #4]
 8021d84:	220b      	movs	r2, #11
 8021d86:	721a      	strb	r2, [r3, #8]
			break;
 8021d88:	e031      	b.n	8021dee <token_run+0x33e>

		case '~':
			self->current_token = finsh_token_type_bitwise;
 8021d8a:	687b      	ldr	r3, [r7, #4]
 8021d8c:	2210      	movs	r2, #16
 8021d8e:	721a      	strb	r2, [r3, #8]
			break;
 8021d90:	e02d      	b.n	8021dee <token_run+0x33e>

		case '^':
			self->current_token = finsh_token_type_xor;
 8021d92:	687b      	ldr	r3, [r7, #4]
 8021d94:	220f      	movs	r2, #15
 8021d96:	721a      	strb	r2, [r3, #8]
			break;
 8021d98:	e029      	b.n	8021dee <token_run+0x33e>

		case '=':
			self->current_token = finsh_token_type_assign;
 8021d9a:	687b      	ldr	r3, [r7, #4]
 8021d9c:	220c      	movs	r2, #12
 8021d9e:	721a      	strb	r2, [r3, #8]
			break;
 8021da0:	e025      	b.n	8021dee <token_run+0x33e>

		case '\'':
			self->value.char_value = token_proc_char(self);
 8021da2:	6878      	ldr	r0, [r7, #4]
 8021da4:	f000 f868 	bl	8021e78 <token_proc_char>
 8021da8:	4603      	mov	r3, r0
 8021daa:	461a      	mov	r2, r3
 8021dac:	687b      	ldr	r3, [r7, #4]
 8021dae:	731a      	strb	r2, [r3, #12]
			self->current_token = finsh_token_type_value_char;
 8021db0:	687b      	ldr	r3, [r7, #4]
 8021db2:	221a      	movs	r2, #26
 8021db4:	721a      	strb	r2, [r3, #8]
			break;
 8021db6:	e01a      	b.n	8021dee <token_run+0x33e>

		case '"':
			token_proc_string(self);
 8021db8:	6878      	ldr	r0, [r7, #4]
 8021dba:	f000 f8c9 	bl	8021f50 <token_proc_string>
			self->current_token = finsh_token_type_value_string;
 8021dbe:	687b      	ldr	r3, [r7, #4]
 8021dc0:	221d      	movs	r2, #29
 8021dc2:	721a      	strb	r2, [r3, #8]
			break;
 8021dc4:	e013      	b.n	8021dee <token_run+0x33e>

		default:
			if ( is_digit(ch) )
 8021dc6:	7bfb      	ldrb	r3, [r7, #15]
 8021dc8:	2b2f      	cmp	r3, #47	; 0x2f
 8021dca:	d909      	bls.n	8021de0 <token_run+0x330>
 8021dcc:	7bfb      	ldrb	r3, [r7, #15]
 8021dce:	2b39      	cmp	r3, #57	; 0x39
 8021dd0:	d806      	bhi.n	8021de0 <token_run+0x330>
			{
				token_prev_char(self);
 8021dd2:	6878      	ldr	r0, [r7, #4]
 8021dd4:	f7ff fe54 	bl	8021a80 <token_prev_char>
				token_proc_number(self);
 8021dd8:	6878      	ldr	r0, [r7, #4]
 8021dda:	f000 f983 	bl	80220e4 <token_proc_number>
				break;
 8021dde:	e006      	b.n	8021dee <token_run+0x33e>
			}

			finsh_error_set(FINSH_ERROR_UNKNOWN_TOKEN);
 8021de0:	200b      	movs	r0, #11
 8021de2:	f7fd fa8b 	bl	801f2fc <finsh_error_set>
			self->current_token = finsh_token_type_bad;
 8021de6:	687b      	ldr	r3, [r7, #4]
 8021de8:	2220      	movs	r2, #32
 8021dea:	721a      	strb	r2, [r3, #8]

			break;
 8021dec:	bf00      	nop
		}
	}
}
 8021dee:	3710      	adds	r7, #16
 8021df0:	46bd      	mov	sp, r7
 8021df2:	bd80      	pop	{r7, pc}

08021df4 <token_match_name>:

static int token_match_name(struct finsh_token* self, const char* str)
{
 8021df4:	b580      	push	{r7, lr}
 8021df6:	b084      	sub	sp, #16
 8021df8:	af00      	add	r7, sp, #0
 8021dfa:	6078      	str	r0, [r7, #4]
 8021dfc:	6039      	str	r1, [r7, #0]
	int i;

	for (i = 0; i < sizeof(finsh_name_table)/sizeof(struct name_table); i++)
 8021dfe:	2300      	movs	r3, #0
 8021e00:	60fb      	str	r3, [r7, #12]
 8021e02:	e016      	b.n	8021e32 <token_match_name+0x3e>
	{
		if ( strcmp(finsh_name_table[i].name, str)==0 )
 8021e04:	4a0f      	ldr	r2, [pc, #60]	; (8021e44 <token_match_name+0x50>)
 8021e06:	68fb      	ldr	r3, [r7, #12]
 8021e08:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8021e0c:	4618      	mov	r0, r3
 8021e0e:	6839      	ldr	r1, [r7, #0]
 8021e10:	f7de fb0a 	bl	8000428 <strcmp>
 8021e14:	4603      	mov	r3, r0
 8021e16:	2b00      	cmp	r3, #0
 8021e18:	d108      	bne.n	8021e2c <token_match_name+0x38>
		{
			self->current_token = finsh_name_table[i].type;
 8021e1a:	4a0a      	ldr	r2, [pc, #40]	; (8021e44 <token_match_name+0x50>)
 8021e1c:	68fb      	ldr	r3, [r7, #12]
 8021e1e:	00db      	lsls	r3, r3, #3
 8021e20:	4413      	add	r3, r2
 8021e22:	791a      	ldrb	r2, [r3, #4]
 8021e24:	687b      	ldr	r3, [r7, #4]
 8021e26:	721a      	strb	r2, [r3, #8]
			return 1;
 8021e28:	2301      	movs	r3, #1
 8021e2a:	e006      	b.n	8021e3a <token_match_name+0x46>

static int token_match_name(struct finsh_token* self, const char* str)
{
	int i;

	for (i = 0; i < sizeof(finsh_name_table)/sizeof(struct name_table); i++)
 8021e2c:	68fb      	ldr	r3, [r7, #12]
 8021e2e:	3301      	adds	r3, #1
 8021e30:	60fb      	str	r3, [r7, #12]
 8021e32:	68fb      	ldr	r3, [r7, #12]
 8021e34:	2b07      	cmp	r3, #7
 8021e36:	d9e5      	bls.n	8021e04 <token_match_name+0x10>
			self->current_token = finsh_name_table[i].type;
			return 1;
		}
	}

	return 0;
 8021e38:	2300      	movs	r3, #0
}
 8021e3a:	4618      	mov	r0, r3
 8021e3c:	3710      	adds	r7, #16
 8021e3e:	46bd      	mov	sp, r7
 8021e40:	bd80      	pop	{r7, pc}
 8021e42:	bf00      	nop
 8021e44:	0802b4ec 	.word	0x0802b4ec

08021e48 <token_trim_space>:

static void token_trim_space(struct finsh_token* self)
{
 8021e48:	b580      	push	{r7, lr}
 8021e4a:	b084      	sub	sp, #16
 8021e4c:	af00      	add	r7, sp, #0
 8021e4e:	6078      	str	r0, [r7, #4]
	char ch;
	while ( (ch = token_next_char(self)) ==' ' || 
 8021e50:	6878      	ldr	r0, [r7, #4]
 8021e52:	f7ff fde1 	bl	8021a18 <token_next_char>
 8021e56:	4603      	mov	r3, r0
 8021e58:	73fb      	strb	r3, [r7, #15]
 8021e5a:	7bfb      	ldrb	r3, [r7, #15]
 8021e5c:	2b20      	cmp	r3, #32
 8021e5e:	d0f7      	beq.n	8021e50 <token_trim_space+0x8>
 8021e60:	7bfb      	ldrb	r3, [r7, #15]
 8021e62:	2b09      	cmp	r3, #9
 8021e64:	d0f4      	beq.n	8021e50 <token_trim_space+0x8>
        ch == '\t' || 
 8021e66:	7bfb      	ldrb	r3, [r7, #15]
 8021e68:	2b0d      	cmp	r3, #13
 8021e6a:	d0f1      	beq.n	8021e50 <token_trim_space+0x8>
        ch == '\r');

	token_prev_char(self);
 8021e6c:	6878      	ldr	r0, [r7, #4]
 8021e6e:	f7ff fe07 	bl	8021a80 <token_prev_char>
}
 8021e72:	3710      	adds	r7, #16
 8021e74:	46bd      	mov	sp, r7
 8021e76:	bd80      	pop	{r7, pc}

08021e78 <token_proc_char>:

static char token_proc_char(struct finsh_token* self)
{
 8021e78:	b580      	push	{r7, lr}
 8021e7a:	b086      	sub	sp, #24
 8021e7c:	af00      	add	r7, sp, #0
 8021e7e:	6078      	str	r0, [r7, #4]
	char ch;
	char buf[4], *p;

	p = buf;
 8021e80:	f107 030c 	add.w	r3, r7, #12
 8021e84:	613b      	str	r3, [r7, #16]
	ch = token_next_char(self);
 8021e86:	6878      	ldr	r0, [r7, #4]
 8021e88:	f7ff fdc6 	bl	8021a18 <token_next_char>
 8021e8c:	4603      	mov	r3, r0
 8021e8e:	75fb      	strb	r3, [r7, #23]

	if ( ch == '\\' )
 8021e90:	7dfb      	ldrb	r3, [r7, #23]
 8021e92:	2b5c      	cmp	r3, #92	; 0x5c
 8021e94:	d149      	bne.n	8021f2a <token_proc_char+0xb2>
	{
		ch = token_next_char(self);
 8021e96:	6878      	ldr	r0, [r7, #4]
 8021e98:	f7ff fdbe 	bl	8021a18 <token_next_char>
 8021e9c:	4603      	mov	r3, r0
 8021e9e:	75fb      	strb	r3, [r7, #23]
		switch ( ch )
 8021ea0:	7dfb      	ldrb	r3, [r7, #23]
 8021ea2:	2b6e      	cmp	r3, #110	; 0x6e
 8021ea4:	d00f      	beq.n	8021ec6 <token_proc_char+0x4e>
 8021ea6:	2b6e      	cmp	r3, #110	; 0x6e
 8021ea8:	dc06      	bgt.n	8021eb8 <token_proc_char+0x40>
 8021eaa:	2b5c      	cmp	r3, #92	; 0x5c
 8021eac:	d01a      	beq.n	8021ee4 <token_proc_char+0x6c>
 8021eae:	2b62      	cmp	r3, #98	; 0x62
 8021eb0:	d012      	beq.n	8021ed8 <token_proc_char+0x60>
 8021eb2:	2b27      	cmp	r3, #39	; 0x27
 8021eb4:	d019      	beq.n	8021eea <token_proc_char+0x72>
 8021eb6:	e01b      	b.n	8021ef0 <token_proc_char+0x78>
 8021eb8:	2b74      	cmp	r3, #116	; 0x74
 8021eba:	d007      	beq.n	8021ecc <token_proc_char+0x54>
 8021ebc:	2b76      	cmp	r3, #118	; 0x76
 8021ebe:	d008      	beq.n	8021ed2 <token_proc_char+0x5a>
 8021ec0:	2b72      	cmp	r3, #114	; 0x72
 8021ec2:	d00c      	beq.n	8021ede <token_proc_char+0x66>
 8021ec4:	e014      	b.n	8021ef0 <token_proc_char+0x78>
		{
		case 'n': ch = '\n'; break;
 8021ec6:	230a      	movs	r3, #10
 8021ec8:	75fb      	strb	r3, [r7, #23]
 8021eca:	e02e      	b.n	8021f2a <token_proc_char+0xb2>
		case 't': ch = '\t'; break;
 8021ecc:	2309      	movs	r3, #9
 8021ece:	75fb      	strb	r3, [r7, #23]
 8021ed0:	e02b      	b.n	8021f2a <token_proc_char+0xb2>
		case 'v': ch = '\v'; break;
 8021ed2:	230b      	movs	r3, #11
 8021ed4:	75fb      	strb	r3, [r7, #23]
 8021ed6:	e028      	b.n	8021f2a <token_proc_char+0xb2>
		case 'b': ch = '\b'; break;
 8021ed8:	2308      	movs	r3, #8
 8021eda:	75fb      	strb	r3, [r7, #23]
 8021edc:	e025      	b.n	8021f2a <token_proc_char+0xb2>
		case 'r': ch = '\r'; break;
 8021ede:	230d      	movs	r3, #13
 8021ee0:	75fb      	strb	r3, [r7, #23]
 8021ee2:	e022      	b.n	8021f2a <token_proc_char+0xb2>
		case '\\': ch = '\\';  break;
 8021ee4:	235c      	movs	r3, #92	; 0x5c
 8021ee6:	75fb      	strb	r3, [r7, #23]
 8021ee8:	e01f      	b.n	8021f2a <token_proc_char+0xb2>
		case '\'': ch = '\'';  break;
 8021eea:	2327      	movs	r3, #39	; 0x27
 8021eec:	75fb      	strb	r3, [r7, #23]
 8021eee:	e01c      	b.n	8021f2a <token_proc_char+0xb2>
		default :
			while ( is_digit(ch) )/*for '\113' char*/
 8021ef0:	e009      	b.n	8021f06 <token_proc_char+0x8e>
			{
				ch = token_next_char(self);
 8021ef2:	6878      	ldr	r0, [r7, #4]
 8021ef4:	f7ff fd90 	bl	8021a18 <token_next_char>
 8021ef8:	4603      	mov	r3, r0
 8021efa:	75fb      	strb	r3, [r7, #23]
				*p++ = ch;
 8021efc:	693b      	ldr	r3, [r7, #16]
 8021efe:	1c5a      	adds	r2, r3, #1
 8021f00:	613a      	str	r2, [r7, #16]
 8021f02:	7dfa      	ldrb	r2, [r7, #23]
 8021f04:	701a      	strb	r2, [r3, #0]
		case 'b': ch = '\b'; break;
		case 'r': ch = '\r'; break;
		case '\\': ch = '\\';  break;
		case '\'': ch = '\'';  break;
		default :
			while ( is_digit(ch) )/*for '\113' char*/
 8021f06:	7dfb      	ldrb	r3, [r7, #23]
 8021f08:	2b2f      	cmp	r3, #47	; 0x2f
 8021f0a:	d902      	bls.n	8021f12 <token_proc_char+0x9a>
 8021f0c:	7dfb      	ldrb	r3, [r7, #23]
 8021f0e:	2b39      	cmp	r3, #57	; 0x39
 8021f10:	d9ef      	bls.n	8021ef2 <token_proc_char+0x7a>
			{
				ch = token_next_char(self);
				*p++ = ch;
			}

			token_prev_char(self);
 8021f12:	6878      	ldr	r0, [r7, #4]
 8021f14:	f7ff fdb4 	bl	8021a80 <token_prev_char>
			*p = '\0';
 8021f18:	693b      	ldr	r3, [r7, #16]
 8021f1a:	2200      	movs	r2, #0
 8021f1c:	701a      	strb	r2, [r3, #0]
			ch = atoi(p);
 8021f1e:	6938      	ldr	r0, [r7, #16]
 8021f20:	f000 fa5e 	bl	80223e0 <atoi>
 8021f24:	4603      	mov	r3, r0
 8021f26:	75fb      	strb	r3, [r7, #23]
			break;
 8021f28:	bf00      	nop
		}
	}

	if ( token_next_char(self) != '\'' )
 8021f2a:	6878      	ldr	r0, [r7, #4]
 8021f2c:	f7ff fd74 	bl	8021a18 <token_next_char>
 8021f30:	4603      	mov	r3, r0
 8021f32:	2b27      	cmp	r3, #39	; 0x27
 8021f34:	d007      	beq.n	8021f46 <token_proc_char+0xce>
	{
		token_prev_char(self);
 8021f36:	6878      	ldr	r0, [r7, #4]
 8021f38:	f7ff fda2 	bl	8021a80 <token_prev_char>
		finsh_error_set(FINSH_ERROR_EXPECT_CHAR);
 8021f3c:	2009      	movs	r0, #9
 8021f3e:	f7fd f9dd 	bl	801f2fc <finsh_error_set>
		return ch;
 8021f42:	7dfb      	ldrb	r3, [r7, #23]
 8021f44:	e000      	b.n	8021f48 <token_proc_char+0xd0>
	}

	return ch;
 8021f46:	7dfb      	ldrb	r3, [r7, #23]
}
 8021f48:	4618      	mov	r0, r3
 8021f4a:	3718      	adds	r7, #24
 8021f4c:	46bd      	mov	sp, r7
 8021f4e:	bd80      	pop	{r7, pc}

08021f50 <token_proc_string>:

static u_char* token_proc_string(struct finsh_token* self)
{
 8021f50:	b580      	push	{r7, lr}
 8021f52:	b084      	sub	sp, #16
 8021f54:	af00      	add	r7, sp, #0
 8021f56:	6078      	str	r0, [r7, #4]
	u_char* p;

	for ( p = &self->string[0]; p - &(self->string[0]) < FINSH_STRING_MAX; )
 8021f58:	687b      	ldr	r3, [r7, #4]
 8021f5a:	3310      	adds	r3, #16
 8021f5c:	60fb      	str	r3, [r7, #12]
 8021f5e:	e024      	b.n	8021faa <token_proc_string+0x5a>
	{
		char ch = token_next_char(self);
 8021f60:	6878      	ldr	r0, [r7, #4]
 8021f62:	f7ff fd59 	bl	8021a18 <token_next_char>
 8021f66:	4603      	mov	r3, r0
 8021f68:	72fb      	strb	r3, [r7, #11]

		if ( is_eof(self) )
 8021f6a:	687b      	ldr	r3, [r7, #4]
 8021f6c:	781b      	ldrb	r3, [r3, #0]
 8021f6e:	2b00      	cmp	r3, #0
 8021f70:	d004      	beq.n	8021f7c <token_proc_string+0x2c>
		{
			finsh_error_set(FINSH_ERROR_UNEXPECT_END);
 8021f72:	200a      	movs	r0, #10
 8021f74:	f7fd f9c2 	bl	801f2fc <finsh_error_set>
			return NULL;;
 8021f78:	2300      	movs	r3, #0
 8021f7a:	e01d      	b.n	8021fb8 <token_proc_string+0x68>
		}
		if ( ch == '\\' )
 8021f7c:	7afb      	ldrb	r3, [r7, #11]
 8021f7e:	2b5c      	cmp	r3, #92	; 0x5c
 8021f80:	d105      	bne.n	8021f8e <token_proc_string+0x3e>
		{
			ch = token_proc_escape(self);
 8021f82:	6878      	ldr	r0, [r7, #4]
 8021f84:	f000 f81c 	bl	8021fc0 <token_proc_escape>
 8021f88:	4603      	mov	r3, r0
 8021f8a:	72fb      	strb	r3, [r7, #11]
 8021f8c:	e008      	b.n	8021fa0 <token_proc_string+0x50>
		}
		else if ( ch == '"' )/*end of string.*/
 8021f8e:	7afb      	ldrb	r3, [r7, #11]
 8021f90:	2b22      	cmp	r3, #34	; 0x22
 8021f92:	d105      	bne.n	8021fa0 <token_proc_string+0x50>
		{
			*p = '\0';
 8021f94:	68fb      	ldr	r3, [r7, #12]
 8021f96:	2200      	movs	r2, #0
 8021f98:	701a      	strb	r2, [r3, #0]
			return self->string;
 8021f9a:	687b      	ldr	r3, [r7, #4]
 8021f9c:	3310      	adds	r3, #16
 8021f9e:	e00b      	b.n	8021fb8 <token_proc_string+0x68>
		}

		*p++ = ch;
 8021fa0:	68fb      	ldr	r3, [r7, #12]
 8021fa2:	1c5a      	adds	r2, r3, #1
 8021fa4:	60fa      	str	r2, [r7, #12]
 8021fa6:	7afa      	ldrb	r2, [r7, #11]
 8021fa8:	701a      	strb	r2, [r3, #0]

static u_char* token_proc_string(struct finsh_token* self)
{
	u_char* p;

	for ( p = &self->string[0]; p - &(self->string[0]) < FINSH_STRING_MAX; )
 8021faa:	68fb      	ldr	r3, [r7, #12]
 8021fac:	687a      	ldr	r2, [r7, #4]
 8021fae:	3210      	adds	r2, #16
 8021fb0:	1a9b      	subs	r3, r3, r2
 8021fb2:	2b7f      	cmp	r3, #127	; 0x7f
 8021fb4:	ddd4      	ble.n	8021f60 <token_proc_string+0x10>
		}

		*p++ = ch;
	}

	return NULL;
 8021fb6:	2300      	movs	r3, #0
}
 8021fb8:	4618      	mov	r0, r3
 8021fba:	3710      	adds	r7, #16
 8021fbc:	46bd      	mov	sp, r7
 8021fbe:	bd80      	pop	{r7, pc}

08021fc0 <token_proc_escape>:

static int token_proc_escape(struct finsh_token* self)
{
 8021fc0:	b580      	push	{r7, lr}
 8021fc2:	b084      	sub	sp, #16
 8021fc4:	af00      	add	r7, sp, #0
 8021fc6:	6078      	str	r0, [r7, #4]
	char ch;
	int result=0;
 8021fc8:	2300      	movs	r3, #0
 8021fca:	60bb      	str	r3, [r7, #8]

	ch = token_next_char(self);
 8021fcc:	6878      	ldr	r0, [r7, #4]
 8021fce:	f7ff fd23 	bl	8021a18 <token_next_char>
 8021fd2:	4603      	mov	r3, r0
 8021fd4:	73fb      	strb	r3, [r7, #15]
	switch (ch)
 8021fd6:	7bfb      	ldrb	r3, [r7, #15]
 8021fd8:	3b61      	subs	r3, #97	; 0x61
 8021fda:	2b17      	cmp	r3, #23
 8021fdc:	d862      	bhi.n	80220a4 <token_proc_escape+0xe4>
 8021fde:	a201      	add	r2, pc, #4	; (adr r2, 8021fe4 <token_proc_escape+0x24>)
 8021fe0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8021fe4:	08022069 	.word	0x08022069
 8021fe8:	08022057 	.word	0x08022057
 8021fec:	080220a5 	.word	0x080220a5
 8021ff0:	080220a5 	.word	0x080220a5
 8021ff4:	080220a5 	.word	0x080220a5
 8021ff8:	08022063 	.word	0x08022063
 8021ffc:	080220a5 	.word	0x080220a5
 8022000:	080220a5 	.word	0x080220a5
 8022004:	080220a5 	.word	0x080220a5
 8022008:	080220a5 	.word	0x080220a5
 802200c:	080220a5 	.word	0x080220a5
 8022010:	080220a5 	.word	0x080220a5
 8022014:	080220a5 	.word	0x080220a5
 8022018:	08022045 	.word	0x08022045
 802201c:	080220a5 	.word	0x080220a5
 8022020:	080220a5 	.word	0x080220a5
 8022024:	080220a5 	.word	0x080220a5
 8022028:	0802205d 	.word	0x0802205d
 802202c:	080220a5 	.word	0x080220a5
 8022030:	0802204b 	.word	0x0802204b
 8022034:	080220a5 	.word	0x080220a5
 8022038:	08022051 	.word	0x08022051
 802203c:	080220a5 	.word	0x080220a5
 8022040:	0802206f 	.word	0x0802206f
	{
	case 'n':
		result = '\n';
 8022044:	230a      	movs	r3, #10
 8022046:	60bb      	str	r3, [r7, #8]
		break;
 8022048:	e047      	b.n	80220da <token_proc_escape+0x11a>
	case 't':
		result = '\t';
 802204a:	2309      	movs	r3, #9
 802204c:	60bb      	str	r3, [r7, #8]
		break;
 802204e:	e044      	b.n	80220da <token_proc_escape+0x11a>
	case 'v':
		result = '\v';
 8022050:	230b      	movs	r3, #11
 8022052:	60bb      	str	r3, [r7, #8]
		break;
 8022054:	e041      	b.n	80220da <token_proc_escape+0x11a>
	case 'b':
		result = '\b';
 8022056:	2308      	movs	r3, #8
 8022058:	60bb      	str	r3, [r7, #8]
		break;
 802205a:	e03e      	b.n	80220da <token_proc_escape+0x11a>
	case 'r':
		result = '\r';
 802205c:	230d      	movs	r3, #13
 802205e:	60bb      	str	r3, [r7, #8]
		break;
 8022060:	e03b      	b.n	80220da <token_proc_escape+0x11a>
	case 'f':
		result = '\f';
 8022062:	230c      	movs	r3, #12
 8022064:	60bb      	str	r3, [r7, #8]
		break;
 8022066:	e038      	b.n	80220da <token_proc_escape+0x11a>
	case 'a':
		result = '\007';
 8022068:	2307      	movs	r3, #7
 802206a:	60bb      	str	r3, [r7, #8]
		break;
 802206c:	e035      	b.n	80220da <token_proc_escape+0x11a>
	case 'x':
		result = 0;
 802206e:	2300      	movs	r3, #0
 8022070:	60bb      	str	r3, [r7, #8]
		ch  = token_next_char(self);
 8022072:	6878      	ldr	r0, [r7, #4]
 8022074:	f7ff fcd0 	bl	8021a18 <token_next_char>
 8022078:	4603      	mov	r3, r0
 802207a:	73fb      	strb	r3, [r7, #15]
		while ( (ch - '0')<16u )
 802207c:	e00a      	b.n	8022094 <token_proc_escape+0xd4>
		{
			result = result*16 + ch - '0';
 802207e:	68bb      	ldr	r3, [r7, #8]
 8022080:	011a      	lsls	r2, r3, #4
 8022082:	7bfb      	ldrb	r3, [r7, #15]
 8022084:	4413      	add	r3, r2
 8022086:	3b30      	subs	r3, #48	; 0x30
 8022088:	60bb      	str	r3, [r7, #8]
			ch = token_next_char(self);
 802208a:	6878      	ldr	r0, [r7, #4]
 802208c:	f7ff fcc4 	bl	8021a18 <token_next_char>
 8022090:	4603      	mov	r3, r0
 8022092:	73fb      	strb	r3, [r7, #15]
		result = '\007';
		break;
	case 'x':
		result = 0;
		ch  = token_next_char(self);
		while ( (ch - '0')<16u )
 8022094:	7bfb      	ldrb	r3, [r7, #15]
 8022096:	3b30      	subs	r3, #48	; 0x30
 8022098:	2b0f      	cmp	r3, #15
 802209a:	d9f0      	bls.n	802207e <token_proc_escape+0xbe>
		{
			result = result*16 + ch - '0';
			ch = token_next_char(self);
		}
		token_prev_char(self);
 802209c:	6878      	ldr	r0, [r7, #4]
 802209e:	f7ff fcef 	bl	8021a80 <token_prev_char>
		break;
 80220a2:	e01a      	b.n	80220da <token_proc_escape+0x11a>
	default:
		if ( (ch - '0') < 8u)
 80220a4:	7bfb      	ldrb	r3, [r7, #15]
 80220a6:	3b30      	subs	r3, #48	; 0x30
 80220a8:	2b07      	cmp	r3, #7
 80220aa:	d815      	bhi.n	80220d8 <token_proc_escape+0x118>
		{
			result = 0;
 80220ac:	2300      	movs	r3, #0
 80220ae:	60bb      	str	r3, [r7, #8]
			while ( (ch - '0') < 8u )
 80220b0:	e00a      	b.n	80220c8 <token_proc_escape+0x108>
			{
				result = result*8 + ch - '0';
 80220b2:	68bb      	ldr	r3, [r7, #8]
 80220b4:	00da      	lsls	r2, r3, #3
 80220b6:	7bfb      	ldrb	r3, [r7, #15]
 80220b8:	4413      	add	r3, r2
 80220ba:	3b30      	subs	r3, #48	; 0x30
 80220bc:	60bb      	str	r3, [r7, #8]
				ch = token_next_char(self);
 80220be:	6878      	ldr	r0, [r7, #4]
 80220c0:	f7ff fcaa 	bl	8021a18 <token_next_char>
 80220c4:	4603      	mov	r3, r0
 80220c6:	73fb      	strb	r3, [r7, #15]
		break;
	default:
		if ( (ch - '0') < 8u)
		{
			result = 0;
			while ( (ch - '0') < 8u )
 80220c8:	7bfb      	ldrb	r3, [r7, #15]
 80220ca:	3b30      	subs	r3, #48	; 0x30
 80220cc:	2b07      	cmp	r3, #7
 80220ce:	d9f0      	bls.n	80220b2 <token_proc_escape+0xf2>
			{
				result = result*8 + ch - '0';
				ch = token_next_char(self);
			}

			token_prev_char(self);
 80220d0:	6878      	ldr	r0, [r7, #4]
 80220d2:	f7ff fcd5 	bl	8021a80 <token_prev_char>
		}
		break;
 80220d6:	e7ff      	b.n	80220d8 <token_proc_escape+0x118>
 80220d8:	bf00      	nop
	}

	return result;
 80220da:	68bb      	ldr	r3, [r7, #8]
}
 80220dc:	4618      	mov	r0, r3
 80220de:	3710      	adds	r7, #16
 80220e0:	46bd      	mov	sp, r7
 80220e2:	bd80      	pop	{r7, pc}

080220e4 <token_proc_number>:

/*
(0|0x|0X|0b|0B)number+(l|L)
*/
static void token_proc_number(struct finsh_token* self)
{
 80220e4:	b580      	push	{r7, lr}
 80220e6:	b0a6      	sub	sp, #152	; 0x98
 80220e8:	af00      	add	r7, sp, #0
 80220ea:	6078      	str	r0, [r7, #4]
	char ch;
	char *p, buf[128];
	long value;

	value = 0;
 80220ec:	2300      	movs	r3, #0
 80220ee:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
	p = buf;
 80220f2:	f107 0308 	add.w	r3, r7, #8
 80220f6:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

	ch  = token_next_char(self);
 80220fa:	6878      	ldr	r0, [r7, #4]
 80220fc:	f7ff fc8c 	bl	8021a18 <token_next_char>
 8022100:	4603      	mov	r3, r0
 8022102:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
	if ( ch == '0' )
 8022106:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 802210a:	2b30      	cmp	r3, #48	; 0x30
 802210c:	f040 80af 	bne.w	802226e <token_proc_number+0x18a>
	{
		int b;
		ch = token_next_char(self);
 8022110:	6878      	ldr	r0, [r7, #4]
 8022112:	f7ff fc81 	bl	8021a18 <token_next_char>
 8022116:	4603      	mov	r3, r0
 8022118:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
		if ( ch == 'x' || ch == 'X' )/*it's a hex number*/
 802211c:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 8022120:	2b78      	cmp	r3, #120	; 0x78
 8022122:	d003      	beq.n	802212c <token_proc_number+0x48>
 8022124:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 8022128:	2b58      	cmp	r3, #88	; 0x58
 802212a:	d12c      	bne.n	8022186 <token_proc_number+0xa2>
		{
			b = 16;
 802212c:	2310      	movs	r3, #16
 802212e:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
			ch = token_next_char(self);
 8022132:	6878      	ldr	r0, [r7, #4]
 8022134:	f7ff fc70 	bl	8021a18 <token_next_char>
 8022138:	4603      	mov	r3, r0
 802213a:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
			while ( is_digit(ch) || is_alpha(ch) )
 802213e:	e00d      	b.n	802215c <token_proc_number+0x78>
			{
				*p++ = ch;
 8022140:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8022144:	1c5a      	adds	r2, r3, #1
 8022146:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
 802214a:	f897 2097 	ldrb.w	r2, [r7, #151]	; 0x97
 802214e:	701a      	strb	r2, [r3, #0]
				ch = token_next_char(self);
 8022150:	6878      	ldr	r0, [r7, #4]
 8022152:	f7ff fc61 	bl	8021a18 <token_next_char>
 8022156:	4603      	mov	r3, r0
 8022158:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
		ch = token_next_char(self);
		if ( ch == 'x' || ch == 'X' )/*it's a hex number*/
		{
			b = 16;
			ch = token_next_char(self);
			while ( is_digit(ch) || is_alpha(ch) )
 802215c:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 8022160:	2b2f      	cmp	r3, #47	; 0x2f
 8022162:	d903      	bls.n	802216c <token_proc_number+0x88>
 8022164:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 8022168:	2b39      	cmp	r3, #57	; 0x39
 802216a:	d9e9      	bls.n	8022140 <token_proc_number+0x5c>
 802216c:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 8022170:	f043 0320 	orr.w	r3, r3, #32
 8022174:	b2db      	uxtb	r3, r3
 8022176:	3b61      	subs	r3, #97	; 0x61
 8022178:	2b19      	cmp	r3, #25
 802217a:	d9e1      	bls.n	8022140 <token_proc_number+0x5c>
			{
				*p++ = ch;
				ch = token_next_char(self);
			}

			*p = '\0';
 802217c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8022180:	2200      	movs	r2, #0
 8022182:	701a      	strb	r2, [r3, #0]
 8022184:	e05d      	b.n	8022242 <token_proc_number+0x15e>
		}
		else if ( ch == 'b' || ch == 'B' )
 8022186:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 802218a:	2b62      	cmp	r3, #98	; 0x62
 802218c:	d003      	beq.n	8022196 <token_proc_number+0xb2>
 802218e:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 8022192:	2b42      	cmp	r3, #66	; 0x42
 8022194:	d124      	bne.n	80221e0 <token_proc_number+0xfc>
		{
			b = 2;
 8022196:	2302      	movs	r3, #2
 8022198:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
			ch = token_next_char(self);
 802219c:	6878      	ldr	r0, [r7, #4]
 802219e:	f7ff fc3b 	bl	8021a18 <token_next_char>
 80221a2:	4603      	mov	r3, r0
 80221a4:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
			while ( (ch=='0')||(ch=='1') )
 80221a8:	e00d      	b.n	80221c6 <token_proc_number+0xe2>
			{
				*p++ = ch;
 80221aa:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80221ae:	1c5a      	adds	r2, r3, #1
 80221b0:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
 80221b4:	f897 2097 	ldrb.w	r2, [r7, #151]	; 0x97
 80221b8:	701a      	strb	r2, [r3, #0]
				ch = token_next_char(self);
 80221ba:	6878      	ldr	r0, [r7, #4]
 80221bc:	f7ff fc2c 	bl	8021a18 <token_next_char>
 80221c0:	4603      	mov	r3, r0
 80221c2:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
		}
		else if ( ch == 'b' || ch == 'B' )
		{
			b = 2;
			ch = token_next_char(self);
			while ( (ch=='0')||(ch=='1') )
 80221c6:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 80221ca:	2b30      	cmp	r3, #48	; 0x30
 80221cc:	d0ed      	beq.n	80221aa <token_proc_number+0xc6>
 80221ce:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 80221d2:	2b31      	cmp	r3, #49	; 0x31
 80221d4:	d0e9      	beq.n	80221aa <token_proc_number+0xc6>
			{
				*p++ = ch;
				ch = token_next_char(self);
			}

			*p = '\0';
 80221d6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80221da:	2200      	movs	r2, #0
 80221dc:	701a      	strb	r2, [r3, #0]
 80221de:	e030      	b.n	8022242 <token_proc_number+0x15e>
		}
		else if ( '0' <= ch && ch <= '7' )
 80221e0:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 80221e4:	2b2f      	cmp	r3, #47	; 0x2f
 80221e6:	d922      	bls.n	802222e <token_proc_number+0x14a>
 80221e8:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 80221ec:	2b37      	cmp	r3, #55	; 0x37
 80221ee:	d81e      	bhi.n	802222e <token_proc_number+0x14a>
		{
			b = 8;
 80221f0:	2308      	movs	r3, #8
 80221f2:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
			while ( '0' <= ch && ch <= '7' )
 80221f6:	e00d      	b.n	8022214 <token_proc_number+0x130>
			{
				*p++ = ch;
 80221f8:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80221fc:	1c5a      	adds	r2, r3, #1
 80221fe:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
 8022202:	f897 2097 	ldrb.w	r2, [r7, #151]	; 0x97
 8022206:	701a      	strb	r2, [r3, #0]
				ch = token_next_char(self);
 8022208:	6878      	ldr	r0, [r7, #4]
 802220a:	f7ff fc05 	bl	8021a18 <token_next_char>
 802220e:	4603      	mov	r3, r0
 8022210:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
			*p = '\0';
		}
		else if ( '0' <= ch && ch <= '7' )
		{
			b = 8;
			while ( '0' <= ch && ch <= '7' )
 8022214:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 8022218:	2b2f      	cmp	r3, #47	; 0x2f
 802221a:	d903      	bls.n	8022224 <token_proc_number+0x140>
 802221c:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 8022220:	2b37      	cmp	r3, #55	; 0x37
 8022222:	d9e9      	bls.n	80221f8 <token_proc_number+0x114>
			{
				*p++ = ch;
				ch = token_next_char(self);
			}

			*p = '\0';
 8022224:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8022228:	2200      	movs	r2, #0
 802222a:	701a      	strb	r2, [r3, #0]
 802222c:	e009      	b.n	8022242 <token_proc_number+0x15e>
		}
		else
		{
			token_prev_char(self);
 802222e:	6878      	ldr	r0, [r7, #4]
 8022230:	f7ff fc26 	bl	8021a80 <token_prev_char>

			/* made as 0 value */
			self->value.int_value = 0;
 8022234:	687b      	ldr	r3, [r7, #4]
 8022236:	2200      	movs	r2, #0
 8022238:	60da      	str	r2, [r3, #12]
			self->current_token = finsh_token_type_value_int;
 802223a:	687b      	ldr	r3, [r7, #4]
 802223c:	221b      	movs	r2, #27
 802223e:	721a      	strb	r2, [r3, #8]
			return;
 8022240:	e046      	b.n	80222d0 <token_proc_number+0x1ec>
		}

		self->value.int_value = token_spec_number(buf, strlen(buf), b);
 8022242:	f107 0308 	add.w	r3, r7, #8
 8022246:	4618      	mov	r0, r3
 8022248:	f000 feaa 	bl	8022fa0 <strlen>
 802224c:	4603      	mov	r3, r0
 802224e:	461a      	mov	r2, r3
 8022250:	f107 0308 	add.w	r3, r7, #8
 8022254:	4618      	mov	r0, r3
 8022256:	4611      	mov	r1, r2
 8022258:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 802225c:	f000 f83c 	bl	80222d8 <token_spec_number>
 8022260:	4602      	mov	r2, r0
 8022262:	687b      	ldr	r3, [r7, #4]
 8022264:	60da      	str	r2, [r3, #12]
		self->current_token = finsh_token_type_value_int;
 8022266:	687b      	ldr	r3, [r7, #4]
 8022268:	221b      	movs	r2, #27
 802226a:	721a      	strb	r2, [r3, #8]
 802226c:	e022      	b.n	80222b4 <token_proc_number+0x1d0>
	}
	else
	{
		while ( is_digit(ch) )
 802226e:	e012      	b.n	8022296 <token_proc_number+0x1b2>
		{
			value = value*10 + ( ch - '0' );
 8022270:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 8022274:	4613      	mov	r3, r2
 8022276:	009b      	lsls	r3, r3, #2
 8022278:	4413      	add	r3, r2
 802227a:	005b      	lsls	r3, r3, #1
 802227c:	461a      	mov	r2, r3
 802227e:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 8022282:	3b30      	subs	r3, #48	; 0x30
 8022284:	4413      	add	r3, r2
 8022286:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
			ch = token_next_char(self);
 802228a:	6878      	ldr	r0, [r7, #4]
 802228c:	f7ff fbc4 	bl	8021a18 <token_next_char>
 8022290:	4603      	mov	r3, r0
 8022292:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
		self->value.int_value = token_spec_number(buf, strlen(buf), b);
		self->current_token = finsh_token_type_value_int;
	}
	else
	{
		while ( is_digit(ch) )
 8022296:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 802229a:	2b2f      	cmp	r3, #47	; 0x2f
 802229c:	d903      	bls.n	80222a6 <token_proc_number+0x1c2>
 802229e:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 80222a2:	2b39      	cmp	r3, #57	; 0x39
 80222a4:	d9e4      	bls.n	8022270 <token_proc_number+0x18c>
		{
			value = value*10 + ( ch - '0' );
			ch = token_next_char(self);
		}

		self->value.int_value = value;
 80222a6:	687b      	ldr	r3, [r7, #4]
 80222a8:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 80222ac:	60da      	str	r2, [r3, #12]
		self->current_token = finsh_token_type_value_int;
 80222ae:	687b      	ldr	r3, [r7, #4]
 80222b0:	221b      	movs	r2, #27
 80222b2:	721a      	strb	r2, [r3, #8]
	}

	switch ( ch )
 80222b4:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 80222b8:	2b4c      	cmp	r3, #76	; 0x4c
 80222ba:	d001      	beq.n	80222c0 <token_proc_number+0x1dc>
 80222bc:	2b6c      	cmp	r3, #108	; 0x6c
 80222be:	d103      	bne.n	80222c8 <token_proc_number+0x1e4>
	{
	case 'l':
	case 'L':
		self->current_token = finsh_token_type_value_long;
 80222c0:	687b      	ldr	r3, [r7, #4]
 80222c2:	221c      	movs	r2, #28
 80222c4:	721a      	strb	r2, [r3, #8]
		break;
 80222c6:	e003      	b.n	80222d0 <token_proc_number+0x1ec>

	default:
		token_prev_char(self);
 80222c8:	6878      	ldr	r0, [r7, #4]
 80222ca:	f7ff fbd9 	bl	8021a80 <token_prev_char>
		break;
 80222ce:	bf00      	nop
	}
}
 80222d0:	3798      	adds	r7, #152	; 0x98
 80222d2:	46bd      	mov	sp, r7
 80222d4:	bd80      	pop	{r7, pc}
 80222d6:	bf00      	nop

080222d8 <token_spec_number>:

/*use 64 bit number*/
#define BN_SIZE 2

static long token_spec_number(char* string, int length, int b)
{
 80222d8:	b480      	push	{r7}
 80222da:	b08f      	sub	sp, #60	; 0x3c
 80222dc:	af00      	add	r7, sp, #0
 80222de:	60f8      	str	r0, [r7, #12]
 80222e0:	60b9      	str	r1, [r7, #8]
 80222e2:	607a      	str	r2, [r7, #4]
	char* p;
	int t;
	int i, j, shift=1;
 80222e4:	2301      	movs	r3, #1
 80222e6:	627b      	str	r3, [r7, #36]	; 0x24
	unsigned int bn[BN_SIZE], v;
	long d;

	p = string;
 80222e8:	68fb      	ldr	r3, [r7, #12]
 80222ea:	637b      	str	r3, [r7, #52]	; 0x34
	i = 0;
 80222ec:	2300      	movs	r3, #0
 80222ee:	62fb      	str	r3, [r7, #44]	; 0x2c

	switch ( b )
 80222f0:	687b      	ldr	r3, [r7, #4]
 80222f2:	2b08      	cmp	r3, #8
 80222f4:	d007      	beq.n	8022306 <token_spec_number+0x2e>
 80222f6:	2b10      	cmp	r3, #16
 80222f8:	d002      	beq.n	8022300 <token_spec_number+0x28>
 80222fa:	2b02      	cmp	r3, #2
 80222fc:	d006      	beq.n	802230c <token_spec_number+0x34>
		break;
	case 8:  shift = 3;
		break;
	case 2:  shift = 1;
		break;
	default: break;
 80222fe:	e008      	b.n	8022312 <token_spec_number+0x3a>
	p = string;
	i = 0;

	switch ( b )
	{
	case 16: shift = 4;
 8022300:	2304      	movs	r3, #4
 8022302:	627b      	str	r3, [r7, #36]	; 0x24
		break;
 8022304:	e005      	b.n	8022312 <token_spec_number+0x3a>
	case 8:  shift = 3;
 8022306:	2303      	movs	r3, #3
 8022308:	627b      	str	r3, [r7, #36]	; 0x24
		break;
 802230a:	e002      	b.n	8022312 <token_spec_number+0x3a>
	case 2:  shift = 1;
 802230c:	2301      	movs	r3, #1
 802230e:	627b      	str	r3, [r7, #36]	; 0x24
		break;
 8022310:	bf00      	nop
	default: break;
	}

	for ( j=0; j<BN_SIZE ; j++) bn[j] = 0;
 8022312:	2300      	movs	r3, #0
 8022314:	62bb      	str	r3, [r7, #40]	; 0x28
 8022316:	e00a      	b.n	802232e <token_spec_number+0x56>
 8022318:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802231a:	009b      	lsls	r3, r3, #2
 802231c:	f107 0238 	add.w	r2, r7, #56	; 0x38
 8022320:	4413      	add	r3, r2
 8022322:	2200      	movs	r2, #0
 8022324:	f843 2c24 	str.w	r2, [r3, #-36]
 8022328:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802232a:	3301      	adds	r3, #1
 802232c:	62bb      	str	r3, [r7, #40]	; 0x28
 802232e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8022330:	2b01      	cmp	r3, #1
 8022332:	ddf1      	ble.n	8022318 <token_spec_number+0x40>

	while ( i<length )
 8022334:	e042      	b.n	80223bc <token_spec_number+0xe4>
	{
		t = *p++;
 8022336:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8022338:	1c5a      	adds	r2, r3, #1
 802233a:	637a      	str	r2, [r7, #52]	; 0x34
 802233c:	781b      	ldrb	r3, [r3, #0]
 802233e:	633b      	str	r3, [r7, #48]	; 0x30
		if ( t>='a' && t <='f' )
 8022340:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8022342:	2b60      	cmp	r3, #96	; 0x60
 8022344:	dd06      	ble.n	8022354 <token_spec_number+0x7c>
 8022346:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8022348:	2b66      	cmp	r3, #102	; 0x66
 802234a:	dc03      	bgt.n	8022354 <token_spec_number+0x7c>
		{
			t = t - 'a' +10;
 802234c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802234e:	3b57      	subs	r3, #87	; 0x57
 8022350:	633b      	str	r3, [r7, #48]	; 0x30
 8022352:	e00c      	b.n	802236e <token_spec_number+0x96>
		}
		else if ( t >='A' && t <='F' )
 8022354:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8022356:	2b40      	cmp	r3, #64	; 0x40
 8022358:	dd06      	ble.n	8022368 <token_spec_number+0x90>
 802235a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802235c:	2b46      	cmp	r3, #70	; 0x46
 802235e:	dc03      	bgt.n	8022368 <token_spec_number+0x90>
		{
			t = t - 'A' +10;
 8022360:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8022362:	3b37      	subs	r3, #55	; 0x37
 8022364:	633b      	str	r3, [r7, #48]	; 0x30
 8022366:	e002      	b.n	802236e <token_spec_number+0x96>
		}
		else t = t - '0';
 8022368:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802236a:	3b30      	subs	r3, #48	; 0x30
 802236c:	633b      	str	r3, [r7, #48]	; 0x30

		for ( j=0; j<BN_SIZE ; j++)
 802236e:	2300      	movs	r3, #0
 8022370:	62bb      	str	r3, [r7, #40]	; 0x28
 8022372:	e01d      	b.n	80223b0 <token_spec_number+0xd8>
		{
			v = bn[j];
 8022374:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8022376:	009b      	lsls	r3, r3, #2
 8022378:	f107 0238 	add.w	r2, r7, #56	; 0x38
 802237c:	4413      	add	r3, r2
 802237e:	f853 3c24 	ldr.w	r3, [r3, #-36]
 8022382:	623b      	str	r3, [r7, #32]
			bn[j] = (v<<shift) | t;
 8022384:	6a3a      	ldr	r2, [r7, #32]
 8022386:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8022388:	409a      	lsls	r2, r3
 802238a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802238c:	431a      	orrs	r2, r3
 802238e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8022390:	009b      	lsls	r3, r3, #2
 8022392:	f107 0138 	add.w	r1, r7, #56	; 0x38
 8022396:	440b      	add	r3, r1
 8022398:	f843 2c24 	str.w	r2, [r3, #-36]
			t = v >> (32 - shift);
 802239c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802239e:	f1c3 0320 	rsb	r3, r3, #32
 80223a2:	6a3a      	ldr	r2, [r7, #32]
 80223a4:	fa22 f303 	lsr.w	r3, r2, r3
 80223a8:	633b      	str	r3, [r7, #48]	; 0x30
		{
			t = t - 'A' +10;
		}
		else t = t - '0';

		for ( j=0; j<BN_SIZE ; j++)
 80223aa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80223ac:	3301      	adds	r3, #1
 80223ae:	62bb      	str	r3, [r7, #40]	; 0x28
 80223b0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80223b2:	2b01      	cmp	r3, #1
 80223b4:	ddde      	ble.n	8022374 <token_spec_number+0x9c>
		{
			v = bn[j];
			bn[j] = (v<<shift) | t;
			t = v >> (32 - shift);
		}
		i++;
 80223b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80223b8:	3301      	adds	r3, #1
 80223ba:	62fb      	str	r3, [r7, #44]	; 0x2c
	default: break;
	}

	for ( j=0; j<BN_SIZE ; j++) bn[j] = 0;

	while ( i<length )
 80223bc:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80223be:	68bb      	ldr	r3, [r7, #8]
 80223c0:	429a      	cmp	r2, r3
 80223c2:	dbb8      	blt.n	8022336 <token_spec_number+0x5e>
			t = v >> (32 - shift);
		}
		i++;
	}

	d = (long)bn[0];
 80223c4:	697b      	ldr	r3, [r7, #20]
 80223c6:	61fb      	str	r3, [r7, #28]

	return d;
 80223c8:	69fb      	ldr	r3, [r7, #28]
}
 80223ca:	4618      	mov	r0, r3
 80223cc:	373c      	adds	r7, #60	; 0x3c
 80223ce:	46bd      	mov	sp, r7
 80223d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80223d4:	4770      	bx	lr
 80223d6:	bf00      	nop

080223d8 <atof>:
 80223d8:	2100      	movs	r1, #0
 80223da:	f001 be59 	b.w	8024090 <strtod>
 80223de:	bf00      	nop

080223e0 <atoi>:
 80223e0:	2100      	movs	r1, #0
 80223e2:	220a      	movs	r2, #10
 80223e4:	f001 beea 	b.w	80241bc <strtol>

080223e8 <ctime>:
 80223e8:	b508      	push	{r3, lr}
 80223ea:	f000 f805 	bl	80223f8 <localtime>
 80223ee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80223f2:	f002 b979 	b.w	80246e8 <asctime>
 80223f6:	bf00      	nop

080223f8 <localtime>:
 80223f8:	4b02      	ldr	r3, [pc, #8]	; (8022404 <localtime+0xc>)
 80223fa:	6819      	ldr	r1, [r3, #0]
 80223fc:	317c      	adds	r1, #124	; 0x7c
 80223fe:	f000 b803 	b.w	8022408 <localtime_r>
 8022402:	bf00      	nop
 8022404:	20010588 	.word	0x20010588

08022408 <localtime_r>:
 8022408:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 802240c:	460c      	mov	r4, r1
 802240e:	4606      	mov	r6, r0
 8022410:	f002 fdae 	bl	8024f70 <__gettzinfo>
 8022414:	4621      	mov	r1, r4
 8022416:	4680      	mov	r8, r0
 8022418:	4630      	mov	r0, r6
 802241a:	f002 fdad 	bl	8024f78 <gmtime_r>
 802241e:	6947      	ldr	r7, [r0, #20]
 8022420:	f207 776c 	addw	r7, r7, #1900	; 0x76c
 8022424:	07b9      	lsls	r1, r7, #30
 8022426:	4604      	mov	r4, r0
 8022428:	f000 80c6 	beq.w	80225b8 <localtime_r+0x1b0>
 802242c:	17fa      	asrs	r2, r7, #31
 802242e:	4b86      	ldr	r3, [pc, #536]	; (8022648 <localtime_r+0x240>)
 8022430:	fb83 1307 	smull	r1, r3, r3, r7
 8022434:	ebc2 12e3 	rsb	r2, r2, r3, asr #7
 8022438:	f44f 73c8 	mov.w	r3, #400	; 0x190
 802243c:	fb03 7312 	mls	r3, r3, r2, r7
 8022440:	fab3 f383 	clz	r3, r3
 8022444:	095b      	lsrs	r3, r3, #5
 8022446:	005a      	lsls	r2, r3, #1
 8022448:	4d80      	ldr	r5, [pc, #512]	; (802264c <localtime_r+0x244>)
 802244a:	4413      	add	r3, r2
 802244c:	eb05 1503 	add.w	r5, r5, r3, lsl #4
 8022450:	f001 ff86 	bl	8024360 <__tz_lock>
 8022454:	4b7e      	ldr	r3, [pc, #504]	; (8022650 <localtime_r+0x248>)
 8022456:	681b      	ldr	r3, [r3, #0]
 8022458:	b343      	cbz	r3, 80224ac <localtime_r+0xa4>
 802245a:	f8d8 3004 	ldr.w	r3, [r8, #4]
 802245e:	42bb      	cmp	r3, r7
 8022460:	d005      	beq.n	802246e <localtime_r+0x66>
 8022462:	4638      	mov	r0, r7
 8022464:	f001 feb6 	bl	80241d4 <__tzcalc_limits>
 8022468:	2800      	cmp	r0, #0
 802246a:	f000 80b3 	beq.w	80225d4 <localtime_r+0x1cc>
 802246e:	f8d8 3000 	ldr.w	r3, [r8]
 8022472:	b983      	cbnz	r3, 8022496 <localtime_r+0x8e>
 8022474:	6833      	ldr	r3, [r6, #0]
 8022476:	f8d8 201c 	ldr.w	r2, [r8, #28]
 802247a:	4293      	cmp	r3, r2
 802247c:	f280 80ae 	bge.w	80225dc <localtime_r+0x1d4>
 8022480:	f8d8 2038 	ldr.w	r2, [r8, #56]	; 0x38
 8022484:	4293      	cmp	r3, r2
 8022486:	bfac      	ite	ge
 8022488:	2300      	movge	r3, #0
 802248a:	2301      	movlt	r3, #1
 802248c:	6223      	str	r3, [r4, #32]
 802248e:	b173      	cbz	r3, 80224ae <localtime_r+0xa6>
 8022490:	f8d8 203c 	ldr.w	r2, [r8, #60]	; 0x3c
 8022494:	e00d      	b.n	80224b2 <localtime_r+0xaa>
 8022496:	6833      	ldr	r3, [r6, #0]
 8022498:	f8d8 201c 	ldr.w	r2, [r8, #28]
 802249c:	4293      	cmp	r3, r2
 802249e:	db04      	blt.n	80224aa <localtime_r+0xa2>
 80224a0:	f8d8 2038 	ldr.w	r2, [r8, #56]	; 0x38
 80224a4:	4293      	cmp	r3, r2
 80224a6:	f2c0 8099 	blt.w	80225dc <localtime_r+0x1d4>
 80224aa:	2300      	movs	r3, #0
 80224ac:	6223      	str	r3, [r4, #32]
 80224ae:	f8d8 2020 	ldr.w	r2, [r8, #32]
 80224b2:	4868      	ldr	r0, [pc, #416]	; (8022654 <localtime_r+0x24c>)
 80224b4:	4968      	ldr	r1, [pc, #416]	; (8022658 <localtime_r+0x250>)
 80224b6:	68a6      	ldr	r6, [r4, #8]
 80224b8:	fb82 8900 	smull	r8, r9, r2, r0
 80224bc:	eb02 0309 	add.w	r3, r2, r9
 80224c0:	17d7      	asrs	r7, r2, #31
 80224c2:	f44f 6861 	mov.w	r8, #3600	; 0xe10
 80224c6:	ebc7 23e3 	rsb	r3, r7, r3, asr #11
 80224ca:	fb08 2313 	mls	r3, r8, r3, r2
 80224ce:	fb83 8901 	smull	r8, r9, r3, r1
 80224d2:	4499      	add	r9, r3
 80224d4:	ea4f 78e3 	mov.w	r8, r3, asr #31
 80224d8:	ebc8 1969 	rsb	r9, r8, r9, asr #5
 80224dc:	fb81 1e03 	smull	r1, lr, r1, r3
 80224e0:	ebc9 1909 	rsb	r9, r9, r9, lsl #4
 80224e4:	6821      	ldr	r1, [r4, #0]
 80224e6:	449e      	add	lr, r3
 80224e8:	fb80 0c02 	smull	r0, ip, r0, r2
 80224ec:	eba3 0389 	sub.w	r3, r3, r9, lsl #2
 80224f0:	1acb      	subs	r3, r1, r3
 80224f2:	4462      	add	r2, ip
 80224f4:	6861      	ldr	r1, [r4, #4]
 80224f6:	6023      	str	r3, [r4, #0]
 80224f8:	ebc7 22e2 	rsb	r2, r7, r2, asr #11
 80224fc:	ebc8 1e6e 	rsb	lr, r8, lr, asr #5
 8022500:	1ab2      	subs	r2, r6, r2
 8022502:	ebce 0101 	rsb	r1, lr, r1
 8022506:	2b3b      	cmp	r3, #59	; 0x3b
 8022508:	60a2      	str	r2, [r4, #8]
 802250a:	6061      	str	r1, [r4, #4]
 802250c:	dd4d      	ble.n	80225aa <localtime_r+0x1a2>
 802250e:	3101      	adds	r1, #1
 8022510:	3b3c      	subs	r3, #60	; 0x3c
 8022512:	6061      	str	r1, [r4, #4]
 8022514:	6023      	str	r3, [r4, #0]
 8022516:	293b      	cmp	r1, #59	; 0x3b
 8022518:	dd40      	ble.n	802259c <localtime_r+0x194>
 802251a:	3201      	adds	r2, #1
 802251c:	393c      	subs	r1, #60	; 0x3c
 802251e:	60a2      	str	r2, [r4, #8]
 8022520:	6061      	str	r1, [r4, #4]
 8022522:	2a17      	cmp	r2, #23
 8022524:	dd1d      	ble.n	8022562 <localtime_r+0x15a>
 8022526:	69a3      	ldr	r3, [r4, #24]
 8022528:	69e1      	ldr	r1, [r4, #28]
 802252a:	3301      	adds	r3, #1
 802252c:	2b06      	cmp	r3, #6
 802252e:	bfc8      	it	gt
 8022530:	2300      	movgt	r3, #0
 8022532:	61a3      	str	r3, [r4, #24]
 8022534:	68e3      	ldr	r3, [r4, #12]
 8022536:	3101      	adds	r1, #1
 8022538:	61e1      	str	r1, [r4, #28]
 802253a:	3a18      	subs	r2, #24
 802253c:	3301      	adds	r3, #1
 802253e:	6921      	ldr	r1, [r4, #16]
 8022540:	60a2      	str	r2, [r4, #8]
 8022542:	60e3      	str	r3, [r4, #12]
 8022544:	f855 2021 	ldr.w	r2, [r5, r1, lsl #2]
 8022548:	4293      	cmp	r3, r2
 802254a:	dd05      	ble.n	8022558 <localtime_r+0x150>
 802254c:	3101      	adds	r1, #1
 802254e:	1a9b      	subs	r3, r3, r2
 8022550:	290c      	cmp	r1, #12
 8022552:	60e3      	str	r3, [r4, #12]
 8022554:	d045      	beq.n	80225e2 <localtime_r+0x1da>
 8022556:	6121      	str	r1, [r4, #16]
 8022558:	f001 ff04 	bl	8024364 <__tz_unlock>
 802255c:	4620      	mov	r0, r4
 802255e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8022562:	2a00      	cmp	r2, #0
 8022564:	daf8      	bge.n	8022558 <localtime_r+0x150>
 8022566:	69a3      	ldr	r3, [r4, #24]
 8022568:	69e1      	ldr	r1, [r4, #28]
 802256a:	3b01      	subs	r3, #1
 802256c:	bf48      	it	mi
 802256e:	2306      	movmi	r3, #6
 8022570:	61a3      	str	r3, [r4, #24]
 8022572:	68e3      	ldr	r3, [r4, #12]
 8022574:	3901      	subs	r1, #1
 8022576:	3218      	adds	r2, #24
 8022578:	3b01      	subs	r3, #1
 802257a:	61e1      	str	r1, [r4, #28]
 802257c:	60a2      	str	r2, [r4, #8]
 802257e:	60e3      	str	r3, [r4, #12]
 8022580:	2b00      	cmp	r3, #0
 8022582:	d1e9      	bne.n	8022558 <localtime_r+0x150>
 8022584:	6923      	ldr	r3, [r4, #16]
 8022586:	3b01      	subs	r3, #1
 8022588:	d432      	bmi.n	80225f0 <localtime_r+0x1e8>
 802258a:	6123      	str	r3, [r4, #16]
 802258c:	009b      	lsls	r3, r3, #2
 802258e:	58eb      	ldr	r3, [r5, r3]
 8022590:	60e3      	str	r3, [r4, #12]
 8022592:	f001 fee7 	bl	8024364 <__tz_unlock>
 8022596:	4620      	mov	r0, r4
 8022598:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802259c:	2900      	cmp	r1, #0
 802259e:	dac0      	bge.n	8022522 <localtime_r+0x11a>
 80225a0:	3a01      	subs	r2, #1
 80225a2:	313c      	adds	r1, #60	; 0x3c
 80225a4:	60a2      	str	r2, [r4, #8]
 80225a6:	6061      	str	r1, [r4, #4]
 80225a8:	e7bb      	b.n	8022522 <localtime_r+0x11a>
 80225aa:	2b00      	cmp	r3, #0
 80225ac:	dab3      	bge.n	8022516 <localtime_r+0x10e>
 80225ae:	3901      	subs	r1, #1
 80225b0:	333c      	adds	r3, #60	; 0x3c
 80225b2:	6061      	str	r1, [r4, #4]
 80225b4:	6023      	str	r3, [r4, #0]
 80225b6:	e7ae      	b.n	8022516 <localtime_r+0x10e>
 80225b8:	4b23      	ldr	r3, [pc, #140]	; (8022648 <localtime_r+0x240>)
 80225ba:	17fa      	asrs	r2, r7, #31
 80225bc:	fb83 1307 	smull	r1, r3, r3, r7
 80225c0:	ebc2 1363 	rsb	r3, r2, r3, asr #5
 80225c4:	2164      	movs	r1, #100	; 0x64
 80225c6:	fb01 7313 	mls	r3, r1, r3, r7
 80225ca:	2b00      	cmp	r3, #0
 80225cc:	f43f af2f 	beq.w	802242e <localtime_r+0x26>
 80225d0:	2301      	movs	r3, #1
 80225d2:	e738      	b.n	8022446 <localtime_r+0x3e>
 80225d4:	f04f 33ff 	mov.w	r3, #4294967295
 80225d8:	6223      	str	r3, [r4, #32]
 80225da:	e768      	b.n	80224ae <localtime_r+0xa6>
 80225dc:	2301      	movs	r3, #1
 80225de:	6223      	str	r3, [r4, #32]
 80225e0:	e756      	b.n	8022490 <localtime_r+0x88>
 80225e2:	6963      	ldr	r3, [r4, #20]
 80225e4:	2200      	movs	r2, #0
 80225e6:	3301      	adds	r3, #1
 80225e8:	6163      	str	r3, [r4, #20]
 80225ea:	6122      	str	r2, [r4, #16]
 80225ec:	61e2      	str	r2, [r4, #28]
 80225ee:	e7b3      	b.n	8022558 <localtime_r+0x150>
 80225f0:	6963      	ldr	r3, [r4, #20]
 80225f2:	1e5a      	subs	r2, r3, #1
 80225f4:	210b      	movs	r1, #11
 80225f6:	6162      	str	r2, [r4, #20]
 80225f8:	0792      	lsls	r2, r2, #30
 80225fa:	6121      	str	r1, [r4, #16]
 80225fc:	d013      	beq.n	8022626 <localtime_r+0x21e>
 80225fe:	f203 716b 	addw	r1, r3, #1899	; 0x76b
 8022602:	17ca      	asrs	r2, r1, #31
 8022604:	4b10      	ldr	r3, [pc, #64]	; (8022648 <localtime_r+0x240>)
 8022606:	fb83 0301 	smull	r0, r3, r3, r1
 802260a:	ebc2 12e3 	rsb	r2, r2, r3, asr #7
 802260e:	f44f 73c8 	mov.w	r3, #400	; 0x190
 8022612:	fb03 1312 	mls	r3, r3, r2, r1
 8022616:	fab3 f383 	clz	r3, r3
 802261a:	095b      	lsrs	r3, r3, #5
 802261c:	f503 73b6 	add.w	r3, r3, #364	; 0x16c
 8022620:	61e3      	str	r3, [r4, #28]
 8022622:	232c      	movs	r3, #44	; 0x2c
 8022624:	e7b3      	b.n	802258e <localtime_r+0x186>
 8022626:	4a08      	ldr	r2, [pc, #32]	; (8022648 <localtime_r+0x240>)
 8022628:	f203 716b 	addw	r1, r3, #1899	; 0x76b
 802262c:	fb82 2301 	smull	r2, r3, r2, r1
 8022630:	17ca      	asrs	r2, r1, #31
 8022632:	ebc2 1363 	rsb	r3, r2, r3, asr #5
 8022636:	2064      	movs	r0, #100	; 0x64
 8022638:	fb00 1313 	mls	r3, r0, r3, r1
 802263c:	2b00      	cmp	r3, #0
 802263e:	d0e1      	beq.n	8022604 <localtime_r+0x1fc>
 8022640:	f240 136d 	movw	r3, #365	; 0x16d
 8022644:	e7ec      	b.n	8022620 <localtime_r+0x218>
 8022646:	bf00      	nop
 8022648:	51eb851f 	.word	0x51eb851f
 802264c:	0802b58c 	.word	0x0802b58c
 8022650:	200121f0 	.word	0x200121f0
 8022654:	91a2b3c5 	.word	0x91a2b3c5
 8022658:	88888889 	.word	0x88888889

0802265c <malloc>:
 802265c:	4b02      	ldr	r3, [pc, #8]	; (8022668 <malloc+0xc>)
 802265e:	4601      	mov	r1, r0
 8022660:	6818      	ldr	r0, [r3, #0]
 8022662:	f7f6 be39 	b.w	80192d8 <_malloc_r>
 8022666:	bf00      	nop
 8022668:	20010588 	.word	0x20010588

0802266c <free>:
 802266c:	4b02      	ldr	r3, [pc, #8]	; (8022678 <free+0xc>)
 802266e:	4601      	mov	r1, r0
 8022670:	6818      	ldr	r0, [r3, #0]
 8022672:	f7f6 be71 	b.w	8019358 <_free_r>
 8022676:	bf00      	nop
 8022678:	20010588 	.word	0x20010588

0802267c <memset>:
 802267c:	b470      	push	{r4, r5, r6}
 802267e:	0784      	lsls	r4, r0, #30
 8022680:	d046      	beq.n	8022710 <memset+0x94>
 8022682:	1e54      	subs	r4, r2, #1
 8022684:	2a00      	cmp	r2, #0
 8022686:	d041      	beq.n	802270c <memset+0x90>
 8022688:	b2cd      	uxtb	r5, r1
 802268a:	4603      	mov	r3, r0
 802268c:	e002      	b.n	8022694 <memset+0x18>
 802268e:	1e62      	subs	r2, r4, #1
 8022690:	b3e4      	cbz	r4, 802270c <memset+0x90>
 8022692:	4614      	mov	r4, r2
 8022694:	f803 5b01 	strb.w	r5, [r3], #1
 8022698:	079a      	lsls	r2, r3, #30
 802269a:	d1f8      	bne.n	802268e <memset+0x12>
 802269c:	2c03      	cmp	r4, #3
 802269e:	d92e      	bls.n	80226fe <memset+0x82>
 80226a0:	b2cd      	uxtb	r5, r1
 80226a2:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 80226a6:	2c0f      	cmp	r4, #15
 80226a8:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 80226ac:	d919      	bls.n	80226e2 <memset+0x66>
 80226ae:	f103 0210 	add.w	r2, r3, #16
 80226b2:	4626      	mov	r6, r4
 80226b4:	3e10      	subs	r6, #16
 80226b6:	2e0f      	cmp	r6, #15
 80226b8:	f842 5c10 	str.w	r5, [r2, #-16]
 80226bc:	f842 5c0c 	str.w	r5, [r2, #-12]
 80226c0:	f842 5c08 	str.w	r5, [r2, #-8]
 80226c4:	f842 5c04 	str.w	r5, [r2, #-4]
 80226c8:	f102 0210 	add.w	r2, r2, #16
 80226cc:	d8f2      	bhi.n	80226b4 <memset+0x38>
 80226ce:	f1a4 0210 	sub.w	r2, r4, #16
 80226d2:	f022 020f 	bic.w	r2, r2, #15
 80226d6:	f004 040f 	and.w	r4, r4, #15
 80226da:	3210      	adds	r2, #16
 80226dc:	2c03      	cmp	r4, #3
 80226de:	4413      	add	r3, r2
 80226e0:	d90d      	bls.n	80226fe <memset+0x82>
 80226e2:	461e      	mov	r6, r3
 80226e4:	4622      	mov	r2, r4
 80226e6:	3a04      	subs	r2, #4
 80226e8:	2a03      	cmp	r2, #3
 80226ea:	f846 5b04 	str.w	r5, [r6], #4
 80226ee:	d8fa      	bhi.n	80226e6 <memset+0x6a>
 80226f0:	1f22      	subs	r2, r4, #4
 80226f2:	f022 0203 	bic.w	r2, r2, #3
 80226f6:	3204      	adds	r2, #4
 80226f8:	4413      	add	r3, r2
 80226fa:	f004 0403 	and.w	r4, r4, #3
 80226fe:	b12c      	cbz	r4, 802270c <memset+0x90>
 8022700:	b2c9      	uxtb	r1, r1
 8022702:	441c      	add	r4, r3
 8022704:	f803 1b01 	strb.w	r1, [r3], #1
 8022708:	42a3      	cmp	r3, r4
 802270a:	d1fb      	bne.n	8022704 <memset+0x88>
 802270c:	bc70      	pop	{r4, r5, r6}
 802270e:	4770      	bx	lr
 8022710:	4614      	mov	r4, r2
 8022712:	4603      	mov	r3, r0
 8022714:	e7c2      	b.n	802269c <memset+0x20>
 8022716:	bf00      	nop

08022718 <validate_structure>:
 8022718:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802271c:	6801      	ldr	r1, [r0, #0]
 802271e:	293b      	cmp	r1, #59	; 0x3b
 8022720:	b083      	sub	sp, #12
 8022722:	4604      	mov	r4, r0
 8022724:	f200 80bc 	bhi.w	80228a0 <validate_structure+0x188>
 8022728:	6841      	ldr	r1, [r0, #4]
 802272a:	293b      	cmp	r1, #59	; 0x3b
 802272c:	f200 80ab 	bhi.w	8022886 <validate_structure+0x16e>
 8022730:	68a1      	ldr	r1, [r4, #8]
 8022732:	2917      	cmp	r1, #23
 8022734:	f200 809a 	bhi.w	802286c <validate_structure+0x154>
 8022738:	6921      	ldr	r1, [r4, #16]
 802273a:	290b      	cmp	r1, #11
 802273c:	f200 8089 	bhi.w	8022852 <validate_structure+0x13a>
 8022740:	6963      	ldr	r3, [r4, #20]
 8022742:	079e      	lsls	r6, r3, #30
 8022744:	d13d      	bne.n	80227c2 <validate_structure+0xaa>
 8022746:	4875      	ldr	r0, [pc, #468]	; (802291c <validate_structure+0x204>)
 8022748:	17da      	asrs	r2, r3, #31
 802274a:	fb80 6503 	smull	r6, r5, r0, r3
 802274e:	ebc2 1265 	rsb	r2, r2, r5, asr #5
 8022752:	2564      	movs	r5, #100	; 0x64
 8022754:	fb05 3212 	mls	r2, r5, r2, r3
 8022758:	2a00      	cmp	r2, #0
 802275a:	d173      	bne.n	8022844 <validate_structure+0x12c>
 802275c:	f203 736c 	addw	r3, r3, #1900	; 0x76c
 8022760:	fb80 2003 	smull	r2, r0, r0, r3
 8022764:	17da      	asrs	r2, r3, #31
 8022766:	ebc2 10e0 	rsb	r0, r2, r0, asr #7
 802276a:	f44f 72c8 	mov.w	r2, #400	; 0x190
 802276e:	fb02 3310 	mls	r3, r2, r0, r3
 8022772:	2b00      	cmp	r3, #0
 8022774:	bf0c      	ite	eq
 8022776:	251d      	moveq	r5, #29
 8022778:	251c      	movne	r5, #28
 802277a:	68e3      	ldr	r3, [r4, #12]
 802277c:	2b00      	cmp	r3, #0
 802277e:	dc25      	bgt.n	80227cc <validate_structure+0xb4>
 8022780:	4e67      	ldr	r6, [pc, #412]	; (8022920 <validate_structure+0x208>)
 8022782:	4f66      	ldr	r7, [pc, #408]	; (802291c <validate_structure+0x204>)
 8022784:	f04f 0e64 	mov.w	lr, #100	; 0x64
 8022788:	f44f 7cc8 	mov.w	ip, #400	; 0x190
 802278c:	e006      	b.n	802279c <validate_structure+0x84>
 802278e:	2901      	cmp	r1, #1
 8022790:	d05a      	beq.n	8022848 <validate_structure+0x130>
 8022792:	f856 2021 	ldr.w	r2, [r6, r1, lsl #2]
 8022796:	4413      	add	r3, r2
 8022798:	2b00      	cmp	r3, #0
 802279a:	dc39      	bgt.n	8022810 <validate_structure+0xf8>
 802279c:	f111 31ff 	adds.w	r1, r1, #4294967295
 80227a0:	d2f5      	bcs.n	802278e <validate_structure+0x76>
 80227a2:	6961      	ldr	r1, [r4, #20]
 80227a4:	1e4a      	subs	r2, r1, #1
 80227a6:	0795      	lsls	r5, r2, #30
 80227a8:	6162      	str	r2, [r4, #20]
 80227aa:	d14f      	bne.n	802284c <validate_structure+0x134>
 80227ac:	fb87 0502 	smull	r0, r5, r7, r2
 80227b0:	17d0      	asrs	r0, r2, #31
 80227b2:	ebc0 1065 	rsb	r0, r0, r5, asr #5
 80227b6:	fb0e 2210 	mls	r2, lr, r0, r2
 80227ba:	2a00      	cmp	r2, #0
 80227bc:	d07d      	beq.n	80228ba <validate_structure+0x1a2>
 80227be:	251d      	movs	r5, #29
 80227c0:	e045      	b.n	802284e <validate_structure+0x136>
 80227c2:	68e3      	ldr	r3, [r4, #12]
 80227c4:	2b00      	cmp	r3, #0
 80227c6:	f04f 051c 	mov.w	r5, #28
 80227ca:	ddd9      	ble.n	8022780 <validate_structure+0x68>
 80227cc:	4f54      	ldr	r7, [pc, #336]	; (8022920 <validate_structure+0x208>)
 80227ce:	f8df c14c 	ldr.w	ip, [pc, #332]	; 802291c <validate_structure+0x204>
 80227d2:	f04f 0e00 	mov.w	lr, #0
 80227d6:	f04f 0864 	mov.w	r8, #100	; 0x64
 80227da:	f44f 79c8 	mov.w	r9, #400	; 0x190
 80227de:	1c4a      	adds	r2, r1, #1
 80227e0:	eb07 0081 	add.w	r0, r7, r1, lsl #2
 80227e4:	e00b      	b.n	80227fe <validate_structure+0xe6>
 80227e6:	6806      	ldr	r6, [r0, #0]
 80227e8:	429e      	cmp	r6, r3
 80227ea:	eba3 0306 	sub.w	r3, r3, r6
 80227ee:	da11      	bge.n	8022814 <validate_structure+0xfc>
 80227f0:	2a0c      	cmp	r2, #12
 80227f2:	60e3      	str	r3, [r4, #12]
 80227f4:	6122      	str	r2, [r4, #16]
 80227f6:	d010      	beq.n	802281a <validate_structure+0x102>
 80227f8:	3101      	adds	r1, #1
 80227fa:	3201      	adds	r2, #1
 80227fc:	3004      	adds	r0, #4
 80227fe:	2901      	cmp	r1, #1
 8022800:	d1f1      	bne.n	80227e6 <validate_structure+0xce>
 8022802:	429d      	cmp	r5, r3
 8022804:	eba3 0305 	sub.w	r3, r3, r5
 8022808:	da04      	bge.n	8022814 <validate_structure+0xfc>
 802280a:	60e3      	str	r3, [r4, #12]
 802280c:	6122      	str	r2, [r4, #16]
 802280e:	e7f3      	b.n	80227f8 <validate_structure+0xe0>
 8022810:	6121      	str	r1, [r4, #16]
 8022812:	60e3      	str	r3, [r4, #12]
 8022814:	b003      	add	sp, #12
 8022816:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802281a:	6961      	ldr	r1, [r4, #20]
 802281c:	f8c4 e010 	str.w	lr, [r4, #16]
 8022820:	1c4a      	adds	r2, r1, #1
 8022822:	0790      	lsls	r0, r2, #30
 8022824:	6162      	str	r2, [r4, #20]
 8022826:	d002      	beq.n	802282e <validate_structure+0x116>
 8022828:	251c      	movs	r5, #28
 802282a:	2100      	movs	r1, #0
 802282c:	e7d7      	b.n	80227de <validate_structure+0xc6>
 802282e:	fb8c 0502 	smull	r0, r5, ip, r2
 8022832:	17d0      	asrs	r0, r2, #31
 8022834:	ebc0 1065 	rsb	r0, r0, r5, asr #5
 8022838:	fb08 2210 	mls	r2, r8, r0, r2
 802283c:	2a00      	cmp	r2, #0
 802283e:	d04a      	beq.n	80228d6 <validate_structure+0x1be>
 8022840:	251d      	movs	r5, #29
 8022842:	e7f2      	b.n	802282a <validate_structure+0x112>
 8022844:	251d      	movs	r5, #29
 8022846:	e798      	b.n	802277a <validate_structure+0x62>
 8022848:	462a      	mov	r2, r5
 802284a:	e7a4      	b.n	8022796 <validate_structure+0x7e>
 802284c:	251c      	movs	r5, #28
 802284e:	210b      	movs	r1, #11
 8022850:	e79f      	b.n	8022792 <validate_structure+0x7a>
 8022852:	220c      	movs	r2, #12
 8022854:	4668      	mov	r0, sp
 8022856:	f001 ff79 	bl	802474c <div>
 802285a:	6962      	ldr	r2, [r4, #20]
 802285c:	9b00      	ldr	r3, [sp, #0]
 802285e:	9901      	ldr	r1, [sp, #4]
 8022860:	4413      	add	r3, r2
 8022862:	2900      	cmp	r1, #0
 8022864:	6163      	str	r3, [r4, #20]
 8022866:	db53      	blt.n	8022910 <validate_structure+0x1f8>
 8022868:	6121      	str	r1, [r4, #16]
 802286a:	e76a      	b.n	8022742 <validate_structure+0x2a>
 802286c:	2218      	movs	r2, #24
 802286e:	4668      	mov	r0, sp
 8022870:	f001 ff6c 	bl	802474c <div>
 8022874:	68e1      	ldr	r1, [r4, #12]
 8022876:	9b00      	ldr	r3, [sp, #0]
 8022878:	9a01      	ldr	r2, [sp, #4]
 802287a:	440b      	add	r3, r1
 802287c:	2a00      	cmp	r2, #0
 802287e:	60e3      	str	r3, [r4, #12]
 8022880:	db41      	blt.n	8022906 <validate_structure+0x1ee>
 8022882:	60a2      	str	r2, [r4, #8]
 8022884:	e758      	b.n	8022738 <validate_structure+0x20>
 8022886:	223c      	movs	r2, #60	; 0x3c
 8022888:	4668      	mov	r0, sp
 802288a:	f001 ff5f 	bl	802474c <div>
 802288e:	68a1      	ldr	r1, [r4, #8]
 8022890:	9b00      	ldr	r3, [sp, #0]
 8022892:	9a01      	ldr	r2, [sp, #4]
 8022894:	4419      	add	r1, r3
 8022896:	2a00      	cmp	r2, #0
 8022898:	60a1      	str	r1, [r4, #8]
 802289a:	db2f      	blt.n	80228fc <validate_structure+0x1e4>
 802289c:	6062      	str	r2, [r4, #4]
 802289e:	e748      	b.n	8022732 <validate_structure+0x1a>
 80228a0:	223c      	movs	r2, #60	; 0x3c
 80228a2:	4668      	mov	r0, sp
 80228a4:	f001 ff52 	bl	802474c <div>
 80228a8:	6863      	ldr	r3, [r4, #4]
 80228aa:	9900      	ldr	r1, [sp, #0]
 80228ac:	9a01      	ldr	r2, [sp, #4]
 80228ae:	4419      	add	r1, r3
 80228b0:	2a00      	cmp	r2, #0
 80228b2:	6061      	str	r1, [r4, #4]
 80228b4:	db1d      	blt.n	80228f2 <validate_structure+0x1da>
 80228b6:	6022      	str	r2, [r4, #0]
 80228b8:	e737      	b.n	802272a <validate_structure+0x12>
 80228ba:	f201 716b 	addw	r1, r1, #1899	; 0x76b
 80228be:	fb87 2001 	smull	r2, r0, r7, r1
 80228c2:	17ca      	asrs	r2, r1, #31
 80228c4:	ebc2 12e0 	rsb	r2, r2, r0, asr #7
 80228c8:	fb0c 1112 	mls	r1, ip, r2, r1
 80228cc:	2900      	cmp	r1, #0
 80228ce:	bf14      	ite	ne
 80228d0:	251c      	movne	r5, #28
 80228d2:	251d      	moveq	r5, #29
 80228d4:	e7bb      	b.n	802284e <validate_structure+0x136>
 80228d6:	f201 716d 	addw	r1, r1, #1901	; 0x76d
 80228da:	fb8c 2001 	smull	r2, r0, ip, r1
 80228de:	17ca      	asrs	r2, r1, #31
 80228e0:	ebc2 12e0 	rsb	r2, r2, r0, asr #7
 80228e4:	fb09 1112 	mls	r1, r9, r2, r1
 80228e8:	2900      	cmp	r1, #0
 80228ea:	bf14      	ite	ne
 80228ec:	251c      	movne	r5, #28
 80228ee:	251d      	moveq	r5, #29
 80228f0:	e79b      	b.n	802282a <validate_structure+0x112>
 80228f2:	323c      	adds	r2, #60	; 0x3c
 80228f4:	3901      	subs	r1, #1
 80228f6:	6022      	str	r2, [r4, #0]
 80228f8:	6061      	str	r1, [r4, #4]
 80228fa:	e716      	b.n	802272a <validate_structure+0x12>
 80228fc:	323c      	adds	r2, #60	; 0x3c
 80228fe:	3901      	subs	r1, #1
 8022900:	6062      	str	r2, [r4, #4]
 8022902:	60a1      	str	r1, [r4, #8]
 8022904:	e715      	b.n	8022732 <validate_structure+0x1a>
 8022906:	3218      	adds	r2, #24
 8022908:	3b01      	subs	r3, #1
 802290a:	60a2      	str	r2, [r4, #8]
 802290c:	60e3      	str	r3, [r4, #12]
 802290e:	e713      	b.n	8022738 <validate_structure+0x20>
 8022910:	310c      	adds	r1, #12
 8022912:	3b01      	subs	r3, #1
 8022914:	6121      	str	r1, [r4, #16]
 8022916:	6163      	str	r3, [r4, #20]
 8022918:	e713      	b.n	8022742 <validate_structure+0x2a>
 802291a:	bf00      	nop
 802291c:	51eb851f 	.word	0x51eb851f
 8022920:	0802b55c 	.word	0x0802b55c

08022924 <mktime>:
 8022924:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022928:	4606      	mov	r6, r0
 802292a:	f002 fb21 	bl	8024f70 <__gettzinfo>
 802292e:	4680      	mov	r8, r0
 8022930:	4630      	mov	r0, r6
 8022932:	f7ff fef1 	bl	8022718 <validate_structure>
 8022936:	4cbd      	ldr	r4, [pc, #756]	; (8022c2c <mktime+0x308>)
 8022938:	6935      	ldr	r5, [r6, #16]
 802293a:	6873      	ldr	r3, [r6, #4]
 802293c:	6830      	ldr	r0, [r6, #0]
 802293e:	68f2      	ldr	r2, [r6, #12]
 8022940:	f854 4025 	ldr.w	r4, [r4, r5, lsl #2]
 8022944:	68b1      	ldr	r1, [r6, #8]
 8022946:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 802294a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 802294e:	f44f 6e61 	mov.w	lr, #3600	; 0xe10
 8022952:	3a01      	subs	r2, #1
 8022954:	2d01      	cmp	r5, #1
 8022956:	fb0e 3e01 	mla	lr, lr, r1, r3
 802295a:	4414      	add	r4, r2
 802295c:	6975      	ldr	r5, [r6, #20]
 802295e:	dd02      	ble.n	8022966 <mktime+0x42>
 8022960:	07ab      	lsls	r3, r5, #30
 8022962:	f000 80c0 	beq.w	8022ae6 <mktime+0x1c2>
 8022966:	f505 531c 	add.w	r3, r5, #9984	; 0x2700
 802296a:	3310      	adds	r3, #16
 802296c:	f644 6220 	movw	r2, #20000	; 0x4e20
 8022970:	4293      	cmp	r3, r2
 8022972:	61f4      	str	r4, [r6, #28]
 8022974:	f200 8153 	bhi.w	8022c1e <mktime+0x2fa>
 8022978:	2d46      	cmp	r5, #70	; 0x46
 802297a:	dc55      	bgt.n	8022a28 <mktime+0x104>
 802297c:	f000 8081 	beq.w	8022a82 <mktime+0x15e>
 8022980:	2d45      	cmp	r5, #69	; 0x45
 8022982:	f000 80f8 	beq.w	8022b76 <mktime+0x252>
 8022986:	48aa      	ldr	r0, [pc, #680]	; (8022c30 <mktime+0x30c>)
 8022988:	2345      	movs	r3, #69	; 0x45
 802298a:	f240 196d 	movw	r9, #365	; 0x16d
 802298e:	2764      	movs	r7, #100	; 0x64
 8022990:	f44f 7cc8 	mov.w	ip, #400	; 0x190
 8022994:	e016      	b.n	80229c4 <mktime+0xa0>
 8022996:	f203 7b6c 	addw	fp, r3, #1900	; 0x76c
 802299a:	fb80 a10b 	smull	sl, r1, r0, fp
 802299e:	ea4f 7aeb 	mov.w	sl, fp, asr #31
 80229a2:	ebca 11e1 	rsb	r1, sl, r1, asr #7
 80229a6:	fb0c b111 	mls	r1, ip, r1, fp
 80229aa:	2a00      	cmp	r2, #0
 80229ac:	f040 80ca 	bne.w	8022b44 <mktime+0x220>
 80229b0:	2900      	cmp	r1, #0
 80229b2:	bf14      	ite	ne
 80229b4:	464a      	movne	r2, r9
 80229b6:	f44f 72b7 	moveq.w	r2, #366	; 0x16e
 80229ba:	3b01      	subs	r3, #1
 80229bc:	42ab      	cmp	r3, r5
 80229be:	eba4 0402 	sub.w	r4, r4, r2
 80229c2:	d010      	beq.n	80229e6 <mktime+0xc2>
 80229c4:	fb80 1203 	smull	r1, r2, r0, r3
 80229c8:	17d9      	asrs	r1, r3, #31
 80229ca:	ebc1 1262 	rsb	r2, r1, r2, asr #5
 80229ce:	f013 0f03 	tst.w	r3, #3
 80229d2:	fb07 3212 	mls	r2, r7, r2, r3
 80229d6:	d0de      	beq.n	8022996 <mktime+0x72>
 80229d8:	3b01      	subs	r3, #1
 80229da:	f240 126d 	movw	r2, #365	; 0x16d
 80229de:	42ab      	cmp	r3, r5
 80229e0:	eba4 0402 	sub.w	r4, r4, r2
 80229e4:	d1ee      	bne.n	80229c4 <mktime+0xa0>
 80229e6:	07af      	lsls	r7, r5, #30
 80229e8:	f040 80c5 	bne.w	8022b76 <mktime+0x252>
 80229ec:	4a90      	ldr	r2, [pc, #576]	; (8022c30 <mktime+0x30c>)
 80229ee:	17eb      	asrs	r3, r5, #31
 80229f0:	fb82 0105 	smull	r0, r1, r2, r5
 80229f4:	ebc3 1361 	rsb	r3, r3, r1, asr #5
 80229f8:	2164      	movs	r1, #100	; 0x64
 80229fa:	fb01 5313 	mls	r3, r1, r3, r5
 80229fe:	2b00      	cmp	r3, #0
 8022a00:	f040 8108 	bne.w	8022c14 <mktime+0x2f0>
 8022a04:	f205 716c 	addw	r1, r5, #1900	; 0x76c
 8022a08:	fb82 3201 	smull	r3, r2, r2, r1
 8022a0c:	17cb      	asrs	r3, r1, #31
 8022a0e:	ebc3 12e2 	rsb	r2, r3, r2, asr #7
 8022a12:	f44f 73c8 	mov.w	r3, #400	; 0x190
 8022a16:	fb03 1312 	mls	r3, r3, r2, r1
 8022a1a:	2b00      	cmp	r3, #0
 8022a1c:	f240 136d 	movw	r3, #365	; 0x16d
 8022a20:	bf08      	it	eq
 8022a22:	f44f 73b7 	moveq.w	r3, #366	; 0x16e
 8022a26:	e0a8      	b.n	8022b7a <mktime+0x256>
 8022a28:	4881      	ldr	r0, [pc, #516]	; (8022c30 <mktime+0x30c>)
 8022a2a:	2346      	movs	r3, #70	; 0x46
 8022a2c:	f240 196d 	movw	r9, #365	; 0x16d
 8022a30:	2764      	movs	r7, #100	; 0x64
 8022a32:	f44f 7cc8 	mov.w	ip, #400	; 0x190
 8022a36:	e014      	b.n	8022a62 <mktime+0x13e>
 8022a38:	f203 7b6c 	addw	fp, r3, #1900	; 0x76c
 8022a3c:	fb80 a10b 	smull	sl, r1, r0, fp
 8022a40:	ea4f 7aeb 	mov.w	sl, fp, asr #31
 8022a44:	ebca 11e1 	rsb	r1, sl, r1, asr #7
 8022a48:	fb0c b111 	mls	r1, ip, r1, fp
 8022a4c:	2a00      	cmp	r2, #0
 8022a4e:	d156      	bne.n	8022afe <mktime+0x1da>
 8022a50:	2900      	cmp	r1, #0
 8022a52:	bf14      	ite	ne
 8022a54:	464a      	movne	r2, r9
 8022a56:	f44f 72b7 	moveq.w	r2, #366	; 0x16e
 8022a5a:	3301      	adds	r3, #1
 8022a5c:	42ab      	cmp	r3, r5
 8022a5e:	4414      	add	r4, r2
 8022a60:	d00f      	beq.n	8022a82 <mktime+0x15e>
 8022a62:	fb80 1203 	smull	r1, r2, r0, r3
 8022a66:	17d9      	asrs	r1, r3, #31
 8022a68:	ebc1 1262 	rsb	r2, r1, r2, asr #5
 8022a6c:	f013 0f03 	tst.w	r3, #3
 8022a70:	fb07 3212 	mls	r2, r7, r2, r3
 8022a74:	d0e0      	beq.n	8022a38 <mktime+0x114>
 8022a76:	3301      	adds	r3, #1
 8022a78:	f240 126d 	movw	r2, #365	; 0x16d
 8022a7c:	42ab      	cmp	r3, r5
 8022a7e:	4414      	add	r4, r2
 8022a80:	d1ef      	bne.n	8022a62 <mktime+0x13e>
 8022a82:	486c      	ldr	r0, [pc, #432]	; (8022c34 <mktime+0x310>)
 8022a84:	fb00 e904 	mla	r9, r0, r4, lr
 8022a88:	f001 fc6a 	bl	8024360 <__tz_lock>
 8022a8c:	4b6a      	ldr	r3, [pc, #424]	; (8022c38 <mktime+0x314>)
 8022a8e:	681f      	ldr	r7, [r3, #0]
 8022a90:	2f00      	cmp	r7, #0
 8022a92:	d052      	beq.n	8022b3a <mktime+0x216>
 8022a94:	6a37      	ldr	r7, [r6, #32]
 8022a96:	6970      	ldr	r0, [r6, #20]
 8022a98:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8022a9c:	2f01      	cmp	r7, #1
 8022a9e:	f200 706c 	addw	r0, r0, #1900	; 0x76c
 8022aa2:	bfa8      	it	ge
 8022aa4:	2701      	movge	r7, #1
 8022aa6:	4283      	cmp	r3, r0
 8022aa8:	d02c      	beq.n	8022b04 <mktime+0x1e0>
 8022aaa:	f001 fb93 	bl	80241d4 <__tzcalc_limits>
 8022aae:	bb48      	cbnz	r0, 8022b04 <mktime+0x1e0>
 8022ab0:	2f01      	cmp	r7, #1
 8022ab2:	d142      	bne.n	8022b3a <mktime+0x216>
 8022ab4:	f8d8 103c 	ldr.w	r1, [r8, #60]	; 0x3c
 8022ab8:	eb09 0501 	add.w	r5, r9, r1
 8022abc:	2701      	movs	r7, #1
 8022abe:	f001 fc51 	bl	8024364 <__tz_unlock>
 8022ac2:	4a5e      	ldr	r2, [pc, #376]	; (8022c3c <mktime+0x318>)
 8022ac4:	6237      	str	r7, [r6, #32]
 8022ac6:	3404      	adds	r4, #4
 8022ac8:	fb84 2302 	smull	r2, r3, r4, r2
 8022acc:	18e2      	adds	r2, r4, r3
 8022ace:	17e3      	asrs	r3, r4, #31
 8022ad0:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 8022ad4:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8022ad8:	1ae3      	subs	r3, r4, r3
 8022ada:	bf48      	it	mi
 8022adc:	3307      	addmi	r3, #7
 8022ade:	61b3      	str	r3, [r6, #24]
 8022ae0:	4628      	mov	r0, r5
 8022ae2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022ae6:	4a52      	ldr	r2, [pc, #328]	; (8022c30 <mktime+0x30c>)
 8022ae8:	17eb      	asrs	r3, r5, #31
 8022aea:	fb82 0105 	smull	r0, r1, r2, r5
 8022aee:	ebc3 1361 	rsb	r3, r3, r1, asr #5
 8022af2:	2164      	movs	r1, #100	; 0x64
 8022af4:	fb01 5313 	mls	r3, r1, r3, r5
 8022af8:	b33b      	cbz	r3, 8022b4a <mktime+0x226>
 8022afa:	3401      	adds	r4, #1
 8022afc:	e733      	b.n	8022966 <mktime+0x42>
 8022afe:	f44f 72b7 	mov.w	r2, #366	; 0x16e
 8022b02:	e7aa      	b.n	8022a5a <mktime+0x136>
 8022b04:	f8d8 2038 	ldr.w	r2, [r8, #56]	; 0x38
 8022b08:	f8d8 0020 	ldr.w	r0, [r8, #32]
 8022b0c:	f8d8 103c 	ldr.w	r1, [r8, #60]	; 0x3c
 8022b10:	f8d8 301c 	ldr.w	r3, [r8, #28]
 8022b14:	ebc0 0e02 	rsb	lr, r0, r2
 8022b18:	45f1      	cmp	r9, lr
 8022b1a:	eba3 0301 	sub.w	r3, r3, r1
 8022b1e:	db02      	blt.n	8022b26 <mktime+0x202>
 8022b20:	1a52      	subs	r2, r2, r1
 8022b22:	4591      	cmp	r9, r2
 8022b24:	dbc4      	blt.n	8022ab0 <mktime+0x18c>
 8022b26:	f8d8 2000 	ldr.w	r2, [r8]
 8022b2a:	b1ea      	cbz	r2, 8022b68 <mktime+0x244>
 8022b2c:	4599      	cmp	r9, r3
 8022b2e:	da26      	bge.n	8022b7e <mktime+0x25a>
 8022b30:	2f00      	cmp	r7, #0
 8022b32:	db72      	blt.n	8022c1a <mktime+0x2f6>
 8022b34:	f04f 0a00 	mov.w	sl, #0
 8022b38:	e029      	b.n	8022b8e <mktime+0x26a>
 8022b3a:	f8d8 0020 	ldr.w	r0, [r8, #32]
 8022b3e:	eb09 0500 	add.w	r5, r9, r0
 8022b42:	e7bc      	b.n	8022abe <mktime+0x19a>
 8022b44:	f44f 72b7 	mov.w	r2, #366	; 0x16e
 8022b48:	e737      	b.n	80229ba <mktime+0x96>
 8022b4a:	f205 716c 	addw	r1, r5, #1900	; 0x76c
 8022b4e:	fb82 3201 	smull	r3, r2, r2, r1
 8022b52:	17cb      	asrs	r3, r1, #31
 8022b54:	ebc3 12e2 	rsb	r2, r3, r2, asr #7
 8022b58:	f44f 73c8 	mov.w	r3, #400	; 0x190
 8022b5c:	fb03 1212 	mls	r2, r3, r2, r1
 8022b60:	2a00      	cmp	r2, #0
 8022b62:	f47f af00 	bne.w	8022966 <mktime+0x42>
 8022b66:	e7c8      	b.n	8022afa <mktime+0x1d6>
 8022b68:	4599      	cmp	r9, r3
 8022b6a:	db08      	blt.n	8022b7e <mktime+0x25a>
 8022b6c:	2f00      	cmp	r7, #0
 8022b6e:	dba3      	blt.n	8022ab8 <mktime+0x194>
 8022b70:	f04f 0a01 	mov.w	sl, #1
 8022b74:	e00b      	b.n	8022b8e <mktime+0x26a>
 8022b76:	f240 136d 	movw	r3, #365	; 0x16d
 8022b7a:	1ae4      	subs	r4, r4, r3
 8022b7c:	e781      	b.n	8022a82 <mktime+0x15e>
 8022b7e:	45f1      	cmp	r9, lr
 8022b80:	bfac      	ite	ge
 8022b82:	f04f 0a00 	movge.w	sl, #0
 8022b86:	f04f 0a01 	movlt.w	sl, #1
 8022b8a:	2f00      	cmp	r7, #0
 8022b8c:	db03      	blt.n	8022b96 <mktime+0x272>
 8022b8e:	ea8a 0707 	eor.w	r7, sl, r7
 8022b92:	2f01      	cmp	r7, #1
 8022b94:	d001      	beq.n	8022b9a <mktime+0x276>
 8022b96:	4657      	mov	r7, sl
 8022b98:	e78a      	b.n	8022ab0 <mktime+0x18c>
 8022b9a:	f08a 0301 	eor.w	r3, sl, #1
 8022b9e:	425a      	negs	r2, r3
 8022ba0:	1a41      	subs	r1, r0, r1
 8022ba2:	4051      	eors	r1, r2
 8022ba4:	6832      	ldr	r2, [r6, #0]
 8022ba6:	68f7      	ldr	r7, [r6, #12]
 8022ba8:	440b      	add	r3, r1
 8022baa:	441a      	add	r2, r3
 8022bac:	6032      	str	r2, [r6, #0]
 8022bae:	4630      	mov	r0, r6
 8022bb0:	4499      	add	r9, r3
 8022bb2:	f7ff fdb1 	bl	8022718 <validate_structure>
 8022bb6:	68f3      	ldr	r3, [r6, #12]
 8022bb8:	1bdb      	subs	r3, r3, r7
 8022bba:	d0ec      	beq.n	8022b96 <mktime+0x272>
 8022bbc:	2b01      	cmp	r3, #1
 8022bbe:	dd5e      	ble.n	8022c7e <mktime+0x35a>
 8022bc0:	f04f 33ff 	mov.w	r3, #4294967295
 8022bc4:	69f2      	ldr	r2, [r6, #28]
 8022bc6:	441c      	add	r4, r3
 8022bc8:	189b      	adds	r3, r3, r2
 8022bca:	d439      	bmi.n	8022c40 <mktime+0x31c>
 8022bcc:	07aa      	lsls	r2, r5, #30
 8022bce:	d12a      	bne.n	8022c26 <mktime+0x302>
 8022bd0:	4917      	ldr	r1, [pc, #92]	; (8022c30 <mktime+0x30c>)
 8022bd2:	17ea      	asrs	r2, r5, #31
 8022bd4:	fb81 7005 	smull	r7, r0, r1, r5
 8022bd8:	ebc2 1260 	rsb	r2, r2, r0, asr #5
 8022bdc:	2064      	movs	r0, #100	; 0x64
 8022bde:	fb00 5212 	mls	r2, r0, r2, r5
 8022be2:	2a00      	cmp	r2, #0
 8022be4:	d14f      	bne.n	8022c86 <mktime+0x362>
 8022be6:	f205 756c 	addw	r5, r5, #1900	; 0x76c
 8022bea:	fb81 1205 	smull	r1, r2, r1, r5
 8022bee:	17e9      	asrs	r1, r5, #31
 8022bf0:	ebc1 11e2 	rsb	r1, r1, r2, asr #7
 8022bf4:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8022bf8:	fb02 5211 	mls	r2, r2, r1, r5
 8022bfc:	2a00      	cmp	r2, #0
 8022bfe:	f240 126d 	movw	r2, #365	; 0x16d
 8022c02:	bf08      	it	eq
 8022c04:	f44f 72b7 	moveq.w	r2, #366	; 0x16e
 8022c08:	429a      	cmp	r2, r3
 8022c0a:	bfd8      	it	le
 8022c0c:	1a9b      	suble	r3, r3, r2
 8022c0e:	61f3      	str	r3, [r6, #28]
 8022c10:	4657      	mov	r7, sl
 8022c12:	e74d      	b.n	8022ab0 <mktime+0x18c>
 8022c14:	f44f 73b7 	mov.w	r3, #366	; 0x16e
 8022c18:	e7af      	b.n	8022b7a <mktime+0x256>
 8022c1a:	2700      	movs	r7, #0
 8022c1c:	e78f      	b.n	8022b3e <mktime+0x21a>
 8022c1e:	f04f 30ff 	mov.w	r0, #4294967295
 8022c22:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022c26:	f240 126d 	movw	r2, #365	; 0x16d
 8022c2a:	e7ed      	b.n	8022c08 <mktime+0x2e4>
 8022c2c:	0802b52c 	.word	0x0802b52c
 8022c30:	51eb851f 	.word	0x51eb851f
 8022c34:	00015180 	.word	0x00015180
 8022c38:	200121f0 	.word	0x200121f0
 8022c3c:	92492493 	.word	0x92492493
 8022c40:	1e68      	subs	r0, r5, #1
 8022c42:	0781      	lsls	r1, r0, #30
 8022c44:	d122      	bne.n	8022c8c <mktime+0x368>
 8022c46:	4914      	ldr	r1, [pc, #80]	; (8022c98 <mktime+0x374>)
 8022c48:	17c2      	asrs	r2, r0, #31
 8022c4a:	fb81 7300 	smull	r7, r3, r1, r0
 8022c4e:	ebc2 1263 	rsb	r2, r2, r3, asr #5
 8022c52:	2364      	movs	r3, #100	; 0x64
 8022c54:	fb03 0312 	mls	r3, r3, r2, r0
 8022c58:	b9db      	cbnz	r3, 8022c92 <mktime+0x36e>
 8022c5a:	f205 756b 	addw	r5, r5, #1899	; 0x76b
 8022c5e:	fb81 3105 	smull	r3, r1, r1, r5
 8022c62:	17ea      	asrs	r2, r5, #31
 8022c64:	ebc2 12e1 	rsb	r2, r2, r1, asr #7
 8022c68:	f44f 73c8 	mov.w	r3, #400	; 0x190
 8022c6c:	fb03 5312 	mls	r3, r3, r2, r5
 8022c70:	2b00      	cmp	r3, #0
 8022c72:	f240 136d 	movw	r3, #365	; 0x16d
 8022c76:	bf18      	it	ne
 8022c78:	f44f 73b6 	movne.w	r3, #364	; 0x16c
 8022c7c:	e7c7      	b.n	8022c0e <mktime+0x2ea>
 8022c7e:	1c98      	adds	r0, r3, #2
 8022c80:	bfd8      	it	le
 8022c82:	2301      	movle	r3, #1
 8022c84:	e79e      	b.n	8022bc4 <mktime+0x2a0>
 8022c86:	f44f 72b7 	mov.w	r2, #366	; 0x16e
 8022c8a:	e7bd      	b.n	8022c08 <mktime+0x2e4>
 8022c8c:	f44f 73b6 	mov.w	r3, #364	; 0x16c
 8022c90:	e7bd      	b.n	8022c0e <mktime+0x2ea>
 8022c92:	f240 136d 	movw	r3, #365	; 0x16d
 8022c96:	e7ba      	b.n	8022c0e <mktime+0x2ea>
 8022c98:	51eb851f 	.word	0x51eb851f

08022c9c <putenv>:
 8022c9c:	4b02      	ldr	r3, [pc, #8]	; (8022ca8 <putenv+0xc>)
 8022c9e:	4601      	mov	r1, r0
 8022ca0:	6818      	ldr	r0, [r3, #0]
 8022ca2:	f000 b803 	b.w	8022cac <_putenv_r>
 8022ca6:	bf00      	nop
 8022ca8:	20010588 	.word	0x20010588

08022cac <_putenv_r>:
 8022cac:	b570      	push	{r4, r5, r6, lr}
 8022cae:	4606      	mov	r6, r0
 8022cb0:	f000 f962 	bl	8022f78 <_strdup_r>
 8022cb4:	b1a0      	cbz	r0, 8022ce0 <_putenv_r+0x34>
 8022cb6:	213d      	movs	r1, #61	; 0x3d
 8022cb8:	4605      	mov	r5, r0
 8022cba:	f000 f8f7 	bl	8022eac <strchr>
 8022cbe:	b188      	cbz	r0, 8022ce4 <_putenv_r+0x38>
 8022cc0:	4602      	mov	r2, r0
 8022cc2:	2300      	movs	r3, #0
 8022cc4:	f802 3b01 	strb.w	r3, [r2], #1
 8022cc8:	4629      	mov	r1, r5
 8022cca:	2301      	movs	r3, #1
 8022ccc:	4630      	mov	r0, r6
 8022cce:	f000 f80f 	bl	8022cf0 <_setenv_r>
 8022cd2:	4629      	mov	r1, r5
 8022cd4:	4604      	mov	r4, r0
 8022cd6:	4630      	mov	r0, r6
 8022cd8:	f7f6 fb3e 	bl	8019358 <_free_r>
 8022cdc:	4620      	mov	r0, r4
 8022cde:	bd70      	pop	{r4, r5, r6, pc}
 8022ce0:	2001      	movs	r0, #1
 8022ce2:	bd70      	pop	{r4, r5, r6, pc}
 8022ce4:	4630      	mov	r0, r6
 8022ce6:	4629      	mov	r1, r5
 8022ce8:	f7f6 fb36 	bl	8019358 <_free_r>
 8022cec:	2001      	movs	r0, #1
 8022cee:	bd70      	pop	{r4, r5, r6, pc}

08022cf0 <_setenv_r>:
 8022cf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022cf4:	460d      	mov	r5, r1
 8022cf6:	b083      	sub	sp, #12
 8022cf8:	4606      	mov	r6, r0
 8022cfa:	213d      	movs	r1, #61	; 0x3d
 8022cfc:	4628      	mov	r0, r5
 8022cfe:	4614      	mov	r4, r2
 8022d00:	461f      	mov	r7, r3
 8022d02:	f000 f8d3 	bl	8022eac <strchr>
 8022d06:	2800      	cmp	r0, #0
 8022d08:	d17e      	bne.n	8022e08 <_setenv_r+0x118>
 8022d0a:	4630      	mov	r0, r6
 8022d0c:	f001 fd3e 	bl	802478c <__env_lock>
 8022d10:	4620      	mov	r0, r4
 8022d12:	f000 f945 	bl	8022fa0 <strlen>
 8022d16:	4629      	mov	r1, r5
 8022d18:	4680      	mov	r8, r0
 8022d1a:	aa01      	add	r2, sp, #4
 8022d1c:	4630      	mov	r0, r6
 8022d1e:	f002 f8db 	bl	8024ed8 <_findenv_r>
 8022d22:	4682      	mov	sl, r0
 8022d24:	2800      	cmp	r0, #0
 8022d26:	d078      	beq.n	8022e1a <_setenv_r+0x12a>
 8022d28:	2f00      	cmp	r7, #0
 8022d2a:	d052      	beq.n	8022dd2 <_setenv_r+0xe2>
 8022d2c:	f000 f938 	bl	8022fa0 <strlen>
 8022d30:	4580      	cmp	r8, r0
 8022d32:	d955      	bls.n	8022de0 <_setenv_r+0xf0>
 8022d34:	9b01      	ldr	r3, [sp, #4]
 8022d36:	4f59      	ldr	r7, [pc, #356]	; (8022e9c <_setenv_r+0x1ac>)
 8022d38:	ea4f 0983 	mov.w	r9, r3, lsl #2
 8022d3c:	7829      	ldrb	r1, [r5, #0]
 8022d3e:	b159      	cbz	r1, 8022d58 <_setenv_r+0x68>
 8022d40:	293d      	cmp	r1, #61	; 0x3d
 8022d42:	f000 809f 	beq.w	8022e84 <_setenv_r+0x194>
 8022d46:	4629      	mov	r1, r5
 8022d48:	e001      	b.n	8022d4e <_setenv_r+0x5e>
 8022d4a:	2b3d      	cmp	r3, #61	; 0x3d
 8022d4c:	d003      	beq.n	8022d56 <_setenv_r+0x66>
 8022d4e:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 8022d52:	2b00      	cmp	r3, #0
 8022d54:	d1f9      	bne.n	8022d4a <_setenv_r+0x5a>
 8022d56:	1b49      	subs	r1, r1, r5
 8022d58:	4441      	add	r1, r8
 8022d5a:	3102      	adds	r1, #2
 8022d5c:	4630      	mov	r0, r6
 8022d5e:	f8d7 8000 	ldr.w	r8, [r7]
 8022d62:	f8df a138 	ldr.w	sl, [pc, #312]	; 8022e9c <_setenv_r+0x1ac>
 8022d66:	f7f6 fab7 	bl	80192d8 <_malloc_r>
 8022d6a:	f848 0009 	str.w	r0, [r8, r9]
 8022d6e:	2800      	cmp	r0, #0
 8022d70:	f000 808d 	beq.w	8022e8e <_setenv_r+0x19e>
 8022d74:	9901      	ldr	r1, [sp, #4]
 8022d76:	f8da 2000 	ldr.w	r2, [sl]
 8022d7a:	782b      	ldrb	r3, [r5, #0]
 8022d7c:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 8022d80:	1c69      	adds	r1, r5, #1
 8022d82:	7013      	strb	r3, [r2, #0]
 8022d84:	b163      	cbz	r3, 8022da0 <_setenv_r+0xb0>
 8022d86:	2b3d      	cmp	r3, #61	; 0x3d
 8022d88:	d00a      	beq.n	8022da0 <_setenv_r+0xb0>
 8022d8a:	1c50      	adds	r0, r2, #1
 8022d8c:	e001      	b.n	8022d92 <_setenv_r+0xa2>
 8022d8e:	2b3d      	cmp	r3, #61	; 0x3d
 8022d90:	d006      	beq.n	8022da0 <_setenv_r+0xb0>
 8022d92:	f811 3b01 	ldrb.w	r3, [r1], #1
 8022d96:	4602      	mov	r2, r0
 8022d98:	f800 3b01 	strb.w	r3, [r0], #1
 8022d9c:	2b00      	cmp	r3, #0
 8022d9e:	d1f6      	bne.n	8022d8e <_setenv_r+0x9e>
 8022da0:	233d      	movs	r3, #61	; 0x3d
 8022da2:	7013      	strb	r3, [r2, #0]
 8022da4:	4613      	mov	r3, r2
 8022da6:	f814 2b01 	ldrb.w	r2, [r4], #1
 8022daa:	f803 2f01 	strb.w	r2, [r3, #1]!
 8022dae:	2a00      	cmp	r2, #0
 8022db0:	d1f9      	bne.n	8022da6 <_setenv_r+0xb6>
 8022db2:	4630      	mov	r0, r6
 8022db4:	f001 fcec 	bl	8024790 <__env_unlock>
 8022db8:	9a01      	ldr	r2, [sp, #4]
 8022dba:	683b      	ldr	r3, [r7, #0]
 8022dbc:	4938      	ldr	r1, [pc, #224]	; (8022ea0 <_setenv_r+0x1b0>)
 8022dbe:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 8022dc2:	2203      	movs	r2, #3
 8022dc4:	f000 f91a 	bl	8022ffc <strncmp>
 8022dc8:	b1d8      	cbz	r0, 8022e02 <_setenv_r+0x112>
 8022dca:	2000      	movs	r0, #0
 8022dcc:	b003      	add	sp, #12
 8022dce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022dd2:	4630      	mov	r0, r6
 8022dd4:	f001 fcdc 	bl	8024790 <__env_unlock>
 8022dd8:	4638      	mov	r0, r7
 8022dda:	b003      	add	sp, #12
 8022ddc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022de0:	f10a 30ff 	add.w	r0, sl, #4294967295
 8022de4:	f814 3b01 	ldrb.w	r3, [r4], #1
 8022de8:	f800 3f01 	strb.w	r3, [r0, #1]!
 8022dec:	2b00      	cmp	r3, #0
 8022dee:	d1f9      	bne.n	8022de4 <_setenv_r+0xf4>
 8022df0:	4630      	mov	r0, r6
 8022df2:	f001 fccd 	bl	8024790 <__env_unlock>
 8022df6:	4628      	mov	r0, r5
 8022df8:	492a      	ldr	r1, [pc, #168]	; (8022ea4 <_setenv_r+0x1b4>)
 8022dfa:	f7dd fb15 	bl	8000428 <strcmp>
 8022dfe:	2800      	cmp	r0, #0
 8022e00:	d1e3      	bne.n	8022dca <_setenv_r+0xda>
 8022e02:	f001 fab1 	bl	8024368 <tzset>
 8022e06:	e7e0      	b.n	8022dca <_setenv_r+0xda>
 8022e08:	f001 fcc4 	bl	8024794 <__errno>
 8022e0c:	2316      	movs	r3, #22
 8022e0e:	6003      	str	r3, [r0, #0]
 8022e10:	f04f 30ff 	mov.w	r0, #4294967295
 8022e14:	b003      	add	sp, #12
 8022e16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022e1a:	4f20      	ldr	r7, [pc, #128]	; (8022e9c <_setenv_r+0x1ac>)
 8022e1c:	6839      	ldr	r1, [r7, #0]
 8022e1e:	6808      	ldr	r0, [r1, #0]
 8022e20:	b390      	cbz	r0, 8022e88 <_setenv_r+0x198>
 8022e22:	460b      	mov	r3, r1
 8022e24:	f853 2f04 	ldr.w	r2, [r3, #4]!
 8022e28:	f10a 0a01 	add.w	sl, sl, #1
 8022e2c:	2a00      	cmp	r2, #0
 8022e2e:	d1f9      	bne.n	8022e24 <_setenv_r+0x134>
 8022e30:	f10a 0202 	add.w	r2, sl, #2
 8022e34:	0092      	lsls	r2, r2, #2
 8022e36:	f8df e070 	ldr.w	lr, [pc, #112]	; 8022ea8 <_setenv_r+0x1b8>
 8022e3a:	f8de 3000 	ldr.w	r3, [lr]
 8022e3e:	b173      	cbz	r3, 8022e5e <_setenv_r+0x16e>
 8022e40:	4630      	mov	r0, r6
 8022e42:	f7f6 fa5d 	bl	8019300 <_realloc_r>
 8022e46:	6038      	str	r0, [r7, #0]
 8022e48:	b308      	cbz	r0, 8022e8e <_setenv_r+0x19e>
 8022e4a:	ea4f 098a 	mov.w	r9, sl, lsl #2
 8022e4e:	f10a 0301 	add.w	r3, sl, #1
 8022e52:	2200      	movs	r2, #0
 8022e54:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 8022e58:	f8cd a004 	str.w	sl, [sp, #4]
 8022e5c:	e76e      	b.n	8022d3c <_setenv_r+0x4c>
 8022e5e:	2301      	movs	r3, #1
 8022e60:	4611      	mov	r1, r2
 8022e62:	4630      	mov	r0, r6
 8022e64:	f8ce 3000 	str.w	r3, [lr]
 8022e68:	f7f6 fa36 	bl	80192d8 <_malloc_r>
 8022e6c:	4683      	mov	fp, r0
 8022e6e:	b170      	cbz	r0, 8022e8e <_setenv_r+0x19e>
 8022e70:	ea4f 098a 	mov.w	r9, sl, lsl #2
 8022e74:	464a      	mov	r2, r9
 8022e76:	6839      	ldr	r1, [r7, #0]
 8022e78:	f7dd fa32 	bl	80002e0 <memcpy>
 8022e7c:	f8c7 b000 	str.w	fp, [r7]
 8022e80:	4658      	mov	r0, fp
 8022e82:	e7e4      	b.n	8022e4e <_setenv_r+0x15e>
 8022e84:	2100      	movs	r1, #0
 8022e86:	e767      	b.n	8022d58 <_setenv_r+0x68>
 8022e88:	4682      	mov	sl, r0
 8022e8a:	2208      	movs	r2, #8
 8022e8c:	e7d3      	b.n	8022e36 <_setenv_r+0x146>
 8022e8e:	4630      	mov	r0, r6
 8022e90:	f001 fc7e 	bl	8024790 <__env_unlock>
 8022e94:	f04f 30ff 	mov.w	r0, #4294967295
 8022e98:	e79f      	b.n	8022dda <_setenv_r+0xea>
 8022e9a:	bf00      	nop
 8022e9c:	20010118 	.word	0x20010118
 8022ea0:	0802b5f0 	.word	0x0802b5f0
 8022ea4:	0802b5ec 	.word	0x0802b5ec
 8022ea8:	200121d0 	.word	0x200121d0

08022eac <strchr>:
 8022eac:	b2c9      	uxtb	r1, r1
 8022eae:	b470      	push	{r4, r5, r6}
 8022eb0:	2900      	cmp	r1, #0
 8022eb2:	d033      	beq.n	8022f1c <strchr+0x70>
 8022eb4:	0785      	lsls	r5, r0, #30
 8022eb6:	d010      	beq.n	8022eda <strchr+0x2e>
 8022eb8:	7803      	ldrb	r3, [r0, #0]
 8022eba:	2b00      	cmp	r3, #0
 8022ebc:	d059      	beq.n	8022f72 <strchr+0xc6>
 8022ebe:	4299      	cmp	r1, r3
 8022ec0:	bf18      	it	ne
 8022ec2:	1c43      	addne	r3, r0, #1
 8022ec4:	d106      	bne.n	8022ed4 <strchr+0x28>
 8022ec6:	e027      	b.n	8022f18 <strchr+0x6c>
 8022ec8:	f813 2b01 	ldrb.w	r2, [r3], #1
 8022ecc:	2a00      	cmp	r2, #0
 8022ece:	d04d      	beq.n	8022f6c <strchr+0xc0>
 8022ed0:	4291      	cmp	r1, r2
 8022ed2:	d021      	beq.n	8022f18 <strchr+0x6c>
 8022ed4:	079a      	lsls	r2, r3, #30
 8022ed6:	4618      	mov	r0, r3
 8022ed8:	d1f6      	bne.n	8022ec8 <strchr+0x1c>
 8022eda:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 8022ede:	6803      	ldr	r3, [r0, #0]
 8022ee0:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 8022ee4:	e001      	b.n	8022eea <strchr+0x3e>
 8022ee6:	f850 3f04 	ldr.w	r3, [r0, #4]!
 8022eea:	ea83 0506 	eor.w	r5, r3, r6
 8022eee:	f1a5 3401 	sub.w	r4, r5, #16843009	; 0x1010101
 8022ef2:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 8022ef6:	ea24 0405 	bic.w	r4, r4, r5
 8022efa:	ea22 0303 	bic.w	r3, r2, r3
 8022efe:	4323      	orrs	r3, r4
 8022f00:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8022f04:	d0ef      	beq.n	8022ee6 <strchr+0x3a>
 8022f06:	7803      	ldrb	r3, [r0, #0]
 8022f08:	b923      	cbnz	r3, 8022f14 <strchr+0x68>
 8022f0a:	e032      	b.n	8022f72 <strchr+0xc6>
 8022f0c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8022f10:	2b00      	cmp	r3, #0
 8022f12:	d02e      	beq.n	8022f72 <strchr+0xc6>
 8022f14:	4299      	cmp	r1, r3
 8022f16:	d1f9      	bne.n	8022f0c <strchr+0x60>
 8022f18:	bc70      	pop	{r4, r5, r6}
 8022f1a:	4770      	bx	lr
 8022f1c:	0784      	lsls	r4, r0, #30
 8022f1e:	d00b      	beq.n	8022f38 <strchr+0x8c>
 8022f20:	7803      	ldrb	r3, [r0, #0]
 8022f22:	2b00      	cmp	r3, #0
 8022f24:	d0f8      	beq.n	8022f18 <strchr+0x6c>
 8022f26:	1c43      	adds	r3, r0, #1
 8022f28:	e003      	b.n	8022f32 <strchr+0x86>
 8022f2a:	7802      	ldrb	r2, [r0, #0]
 8022f2c:	3301      	adds	r3, #1
 8022f2e:	2a00      	cmp	r2, #0
 8022f30:	d0f2      	beq.n	8022f18 <strchr+0x6c>
 8022f32:	0799      	lsls	r1, r3, #30
 8022f34:	4618      	mov	r0, r3
 8022f36:	d1f8      	bne.n	8022f2a <strchr+0x7e>
 8022f38:	6802      	ldr	r2, [r0, #0]
 8022f3a:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 8022f3e:	ea23 0302 	bic.w	r3, r3, r2
 8022f42:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8022f46:	d108      	bne.n	8022f5a <strchr+0xae>
 8022f48:	f850 2f04 	ldr.w	r2, [r0, #4]!
 8022f4c:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 8022f50:	ea23 0302 	bic.w	r3, r3, r2
 8022f54:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8022f58:	d0f6      	beq.n	8022f48 <strchr+0x9c>
 8022f5a:	7803      	ldrb	r3, [r0, #0]
 8022f5c:	2b00      	cmp	r3, #0
 8022f5e:	d0db      	beq.n	8022f18 <strchr+0x6c>
 8022f60:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8022f64:	2b00      	cmp	r3, #0
 8022f66:	d1fb      	bne.n	8022f60 <strchr+0xb4>
 8022f68:	bc70      	pop	{r4, r5, r6}
 8022f6a:	4770      	bx	lr
 8022f6c:	4610      	mov	r0, r2
 8022f6e:	bc70      	pop	{r4, r5, r6}
 8022f70:	4770      	bx	lr
 8022f72:	4618      	mov	r0, r3
 8022f74:	bc70      	pop	{r4, r5, r6}
 8022f76:	4770      	bx	lr

08022f78 <_strdup_r>:
 8022f78:	b570      	push	{r4, r5, r6, lr}
 8022f7a:	4606      	mov	r6, r0
 8022f7c:	4608      	mov	r0, r1
 8022f7e:	460d      	mov	r5, r1
 8022f80:	f000 f80e 	bl	8022fa0 <strlen>
 8022f84:	1c44      	adds	r4, r0, #1
 8022f86:	4621      	mov	r1, r4
 8022f88:	4630      	mov	r0, r6
 8022f8a:	f7f6 f9a5 	bl	80192d8 <_malloc_r>
 8022f8e:	4606      	mov	r6, r0
 8022f90:	b118      	cbz	r0, 8022f9a <_strdup_r+0x22>
 8022f92:	4629      	mov	r1, r5
 8022f94:	4622      	mov	r2, r4
 8022f96:	f7dd f9a3 	bl	80002e0 <memcpy>
 8022f9a:	4630      	mov	r0, r6
 8022f9c:	bd70      	pop	{r4, r5, r6, pc}
 8022f9e:	bf00      	nop

08022fa0 <strlen>:
 8022fa0:	f020 0103 	bic.w	r1, r0, #3
 8022fa4:	f010 0003 	ands.w	r0, r0, #3
 8022fa8:	f1c0 0000 	rsb	r0, r0, #0
 8022fac:	f851 3b04 	ldr.w	r3, [r1], #4
 8022fb0:	f100 0c04 	add.w	ip, r0, #4
 8022fb4:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8022fb8:	f06f 0200 	mvn.w	r2, #0
 8022fbc:	bf1c      	itt	ne
 8022fbe:	fa22 f20c 	lsrne.w	r2, r2, ip
 8022fc2:	4313      	orrne	r3, r2
 8022fc4:	f04f 0c01 	mov.w	ip, #1
 8022fc8:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 8022fcc:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 8022fd0:	eba3 020c 	sub.w	r2, r3, ip
 8022fd4:	ea22 0203 	bic.w	r2, r2, r3
 8022fd8:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 8022fdc:	bf04      	itt	eq
 8022fde:	f851 3b04 	ldreq.w	r3, [r1], #4
 8022fe2:	3004      	addeq	r0, #4
 8022fe4:	d0f4      	beq.n	8022fd0 <strlen+0x30>
 8022fe6:	f1c2 0100 	rsb	r1, r2, #0
 8022fea:	ea02 0201 	and.w	r2, r2, r1
 8022fee:	fab2 f282 	clz	r2, r2
 8022ff2:	f1c2 021f 	rsb	r2, r2, #31
 8022ff6:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 8022ffa:	4770      	bx	lr

08022ffc <strncmp>:
 8022ffc:	2a00      	cmp	r2, #0
 8022ffe:	d03e      	beq.n	802307e <strncmp+0x82>
 8023000:	ea40 0301 	orr.w	r3, r0, r1
 8023004:	f013 0303 	ands.w	r3, r3, #3
 8023008:	b4f0      	push	{r4, r5, r6, r7}
 802300a:	d125      	bne.n	8023058 <strncmp+0x5c>
 802300c:	2a03      	cmp	r2, #3
 802300e:	d923      	bls.n	8023058 <strncmp+0x5c>
 8023010:	6804      	ldr	r4, [r0, #0]
 8023012:	680d      	ldr	r5, [r1, #0]
 8023014:	42ac      	cmp	r4, r5
 8023016:	d11f      	bne.n	8023058 <strncmp+0x5c>
 8023018:	3a04      	subs	r2, #4
 802301a:	d032      	beq.n	8023082 <strncmp+0x86>
 802301c:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 8023020:	ea25 0404 	bic.w	r4, r5, r4
 8023024:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 8023028:	d12e      	bne.n	8023088 <strncmp+0x8c>
 802302a:	1d07      	adds	r7, r0, #4
 802302c:	1d0d      	adds	r5, r1, #4
 802302e:	e00d      	b.n	802304c <strncmp+0x50>
 8023030:	f857 3b04 	ldr.w	r3, [r7], #4
 8023034:	680e      	ldr	r6, [r1, #0]
 8023036:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
 802303a:	42b3      	cmp	r3, r6
 802303c:	ea24 0403 	bic.w	r4, r4, r3
 8023040:	d10a      	bne.n	8023058 <strncmp+0x5c>
 8023042:	3a04      	subs	r2, #4
 8023044:	d01d      	beq.n	8023082 <strncmp+0x86>
 8023046:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 802304a:	d120      	bne.n	802308e <strncmp+0x92>
 802304c:	2a03      	cmp	r2, #3
 802304e:	4629      	mov	r1, r5
 8023050:	4638      	mov	r0, r7
 8023052:	f105 0504 	add.w	r5, r5, #4
 8023056:	d8eb      	bhi.n	8023030 <strncmp+0x34>
 8023058:	7803      	ldrb	r3, [r0, #0]
 802305a:	780c      	ldrb	r4, [r1, #0]
 802305c:	42a3      	cmp	r3, r4
 802305e:	f102 32ff 	add.w	r2, r2, #4294967295
 8023062:	d109      	bne.n	8023078 <strncmp+0x7c>
 8023064:	b16a      	cbz	r2, 8023082 <strncmp+0x86>
 8023066:	b17b      	cbz	r3, 8023088 <strncmp+0x8c>
 8023068:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 802306c:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8023070:	42a3      	cmp	r3, r4
 8023072:	f102 32ff 	add.w	r2, r2, #4294967295
 8023076:	d0f5      	beq.n	8023064 <strncmp+0x68>
 8023078:	1b18      	subs	r0, r3, r4
 802307a:	bcf0      	pop	{r4, r5, r6, r7}
 802307c:	4770      	bx	lr
 802307e:	4610      	mov	r0, r2
 8023080:	4770      	bx	lr
 8023082:	4610      	mov	r0, r2
 8023084:	bcf0      	pop	{r4, r5, r6, r7}
 8023086:	4770      	bx	lr
 8023088:	4618      	mov	r0, r3
 802308a:	bcf0      	pop	{r4, r5, r6, r7}
 802308c:	4770      	bx	lr
 802308e:	2000      	movs	r0, #0
 8023090:	e7f3      	b.n	802307a <strncmp+0x7e>
 8023092:	bf00      	nop

08023094 <strncpy>:
 8023094:	ea40 0301 	orr.w	r3, r0, r1
 8023098:	079b      	lsls	r3, r3, #30
 802309a:	b470      	push	{r4, r5, r6}
 802309c:	d12b      	bne.n	80230f6 <strncpy+0x62>
 802309e:	2a03      	cmp	r2, #3
 80230a0:	d929      	bls.n	80230f6 <strncpy+0x62>
 80230a2:	460c      	mov	r4, r1
 80230a4:	4603      	mov	r3, r0
 80230a6:	4621      	mov	r1, r4
 80230a8:	f854 6b04 	ldr.w	r6, [r4], #4
 80230ac:	f1a6 3501 	sub.w	r5, r6, #16843009	; 0x1010101
 80230b0:	ea25 0506 	bic.w	r5, r5, r6
 80230b4:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
 80230b8:	d105      	bne.n	80230c6 <strncpy+0x32>
 80230ba:	3a04      	subs	r2, #4
 80230bc:	2a03      	cmp	r2, #3
 80230be:	f843 6b04 	str.w	r6, [r3], #4
 80230c2:	4621      	mov	r1, r4
 80230c4:	d8ef      	bhi.n	80230a6 <strncpy+0x12>
 80230c6:	b1a2      	cbz	r2, 80230f2 <strncpy+0x5e>
 80230c8:	780c      	ldrb	r4, [r1, #0]
 80230ca:	701c      	strb	r4, [r3, #0]
 80230cc:	3a01      	subs	r2, #1
 80230ce:	3301      	adds	r3, #1
 80230d0:	3101      	adds	r1, #1
 80230d2:	b13c      	cbz	r4, 80230e4 <strncpy+0x50>
 80230d4:	b16a      	cbz	r2, 80230f2 <strncpy+0x5e>
 80230d6:	f811 4b01 	ldrb.w	r4, [r1], #1
 80230da:	f803 4b01 	strb.w	r4, [r3], #1
 80230de:	3a01      	subs	r2, #1
 80230e0:	2c00      	cmp	r4, #0
 80230e2:	d1f7      	bne.n	80230d4 <strncpy+0x40>
 80230e4:	b12a      	cbz	r2, 80230f2 <strncpy+0x5e>
 80230e6:	441a      	add	r2, r3
 80230e8:	2100      	movs	r1, #0
 80230ea:	f803 1b01 	strb.w	r1, [r3], #1
 80230ee:	4293      	cmp	r3, r2
 80230f0:	d1fb      	bne.n	80230ea <strncpy+0x56>
 80230f2:	bc70      	pop	{r4, r5, r6}
 80230f4:	4770      	bx	lr
 80230f6:	4603      	mov	r3, r0
 80230f8:	e7e5      	b.n	80230c6 <strncpy+0x32>
 80230fa:	bf00      	nop

080230fc <sulp>:
 80230fc:	b570      	push	{r4, r5, r6, lr}
 80230fe:	4604      	mov	r4, r0
 8023100:	460d      	mov	r5, r1
 8023102:	4616      	mov	r6, r2
 8023104:	ec45 4b10 	vmov	d0, r4, r5
 8023108:	f002 fad8 	bl	80256bc <__ulp>
 802310c:	b196      	cbz	r6, 8023134 <sulp+0x38>
 802310e:	f3c5 530a 	ubfx	r3, r5, #20, #11
 8023112:	f1c3 036b 	rsb	r3, r3, #107	; 0x6b
 8023116:	2b00      	cmp	r3, #0
 8023118:	dd0c      	ble.n	8023134 <sulp+0x38>
 802311a:	051b      	lsls	r3, r3, #20
 802311c:	f103 517f 	add.w	r1, r3, #1069547520	; 0x3fc00000
 8023120:	2000      	movs	r0, #0
 8023122:	f501 1140 	add.w	r1, r1, #3145728	; 0x300000
 8023126:	4602      	mov	r2, r0
 8023128:	460b      	mov	r3, r1
 802312a:	ec51 0b10 	vmov	r0, r1, d0
 802312e:	f7dd fc9f 	bl	8000a70 <__aeabi_dmul>
 8023132:	bd70      	pop	{r4, r5, r6, pc}
 8023134:	ec51 0b10 	vmov	r0, r1, d0
 8023138:	bd70      	pop	{r4, r5, r6, pc}
 802313a:	bf00      	nop
 802313c:	0000      	movs	r0, r0
	...

08023140 <_strtod_r>:
 8023140:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023144:	b09f      	sub	sp, #124	; 0x7c
 8023146:	460f      	mov	r7, r1
 8023148:	2100      	movs	r1, #0
 802314a:	4682      	mov	sl, r0
 802314c:	911a      	str	r1, [sp, #104]	; 0x68
 802314e:	2000      	movs	r0, #0
 8023150:	2100      	movs	r1, #0
 8023152:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8023156:	9719      	str	r7, [sp, #100]	; 0x64
 8023158:	9203      	str	r2, [sp, #12]
 802315a:	463b      	mov	r3, r7
 802315c:	461c      	mov	r4, r3
 802315e:	f813 6b01 	ldrb.w	r6, [r3], #1
 8023162:	2e2d      	cmp	r6, #45	; 0x2d
 8023164:	f200 80ed 	bhi.w	8023342 <_strtod_r+0x202>
 8023168:	e8df f016 	tbh	[pc, r6, lsl #1]
 802316c:	00eb002e 	.word	0x00eb002e
 8023170:	00eb00eb 	.word	0x00eb00eb
 8023174:	00eb00eb 	.word	0x00eb00eb
 8023178:	00eb00eb 	.word	0x00eb00eb
 802317c:	00da00eb 	.word	0x00da00eb
 8023180:	00da00da 	.word	0x00da00da
 8023184:	00da00da 	.word	0x00da00da
 8023188:	00eb00eb 	.word	0x00eb00eb
 802318c:	00eb00eb 	.word	0x00eb00eb
 8023190:	00eb00eb 	.word	0x00eb00eb
 8023194:	00eb00eb 	.word	0x00eb00eb
 8023198:	00eb00eb 	.word	0x00eb00eb
 802319c:	00eb00eb 	.word	0x00eb00eb
 80231a0:	00eb00eb 	.word	0x00eb00eb
 80231a4:	00eb00eb 	.word	0x00eb00eb
 80231a8:	00eb00eb 	.word	0x00eb00eb
 80231ac:	00eb00da 	.word	0x00eb00da
 80231b0:	00eb00eb 	.word	0x00eb00eb
 80231b4:	00eb00eb 	.word	0x00eb00eb
 80231b8:	00eb00eb 	.word	0x00eb00eb
 80231bc:	00eb00eb 	.word	0x00eb00eb
 80231c0:	004200eb 	.word	0x004200eb
 80231c4:	00d700eb 	.word	0x00d700eb
 80231c8:	9b03      	ldr	r3, [sp, #12]
 80231ca:	f04f 0800 	mov.w	r8, #0
 80231ce:	f04f 0900 	mov.w	r9, #0
 80231d2:	b143      	cbz	r3, 80231e6 <_strtod_r+0xa6>
 80231d4:	2300      	movs	r3, #0
 80231d6:	9306      	str	r3, [sp, #24]
 80231d8:	9b03      	ldr	r3, [sp, #12]
 80231da:	601f      	str	r7, [r3, #0]
 80231dc:	9b06      	ldr	r3, [sp, #24]
 80231de:	b113      	cbz	r3, 80231e6 <_strtod_r+0xa6>
 80231e0:	f109 4300 	add.w	r3, r9, #2147483648	; 0x80000000
 80231e4:	4699      	mov	r9, r3
 80231e6:	ec49 8b10 	vmov	d0, r8, r9
 80231ea:	b01f      	add	sp, #124	; 0x7c
 80231ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80231f0:	2300      	movs	r3, #0
 80231f2:	9306      	str	r3, [sp, #24]
 80231f4:	1c63      	adds	r3, r4, #1
 80231f6:	9319      	str	r3, [sp, #100]	; 0x64
 80231f8:	7866      	ldrb	r6, [r4, #1]
 80231fa:	2e00      	cmp	r6, #0
 80231fc:	d0e4      	beq.n	80231c8 <_strtod_r+0x88>
 80231fe:	2e30      	cmp	r6, #48	; 0x30
 8023200:	461c      	mov	r4, r3
 8023202:	f000 80a3 	beq.w	802334c <_strtod_r+0x20c>
 8023206:	2300      	movs	r3, #0
 8023208:	9408      	str	r4, [sp, #32]
 802320a:	930a      	str	r3, [sp, #40]	; 0x28
 802320c:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
 8023210:	f04f 0b00 	mov.w	fp, #0
 8023214:	2b09      	cmp	r3, #9
 8023216:	465d      	mov	r5, fp
 8023218:	4623      	mov	r3, r4
 802321a:	465c      	mov	r4, fp
 802321c:	d819      	bhi.n	8023252 <_strtod_r+0x112>
 802321e:	2c08      	cmp	r4, #8
 8023220:	bfc8      	it	gt
 8023222:	eb0b 0b8b 	addgt.w	fp, fp, fp, lsl #2
 8023226:	eb05 0285 	add.w	r2, r5, r5, lsl #2
 802322a:	f103 0301 	add.w	r3, r3, #1
 802322e:	eb06 0242 	add.w	r2, r6, r2, lsl #1
 8023232:	9319      	str	r3, [sp, #100]	; 0x64
 8023234:	bfc4      	itt	gt
 8023236:	eb06 064b 	addgt.w	r6, r6, fp, lsl #1
 802323a:	f1a6 0b30 	subgt.w	fp, r6, #48	; 0x30
 802323e:	781e      	ldrb	r6, [r3, #0]
 8023240:	bfd8      	it	le
 8023242:	f1a2 0530 	suble.w	r5, r2, #48	; 0x30
 8023246:	f1a6 0230 	sub.w	r2, r6, #48	; 0x30
 802324a:	2a09      	cmp	r2, #9
 802324c:	f104 0401 	add.w	r4, r4, #1
 8023250:	d9e5      	bls.n	802321e <_strtod_r+0xde>
 8023252:	4650      	mov	r0, sl
 8023254:	9307      	str	r3, [sp, #28]
 8023256:	f001 ff49 	bl	80250ec <_localeconv_r>
 802325a:	f8d0 8000 	ldr.w	r8, [r0]
 802325e:	4650      	mov	r0, sl
 8023260:	f001 ff44 	bl	80250ec <_localeconv_r>
 8023264:	6800      	ldr	r0, [r0, #0]
 8023266:	f7ff fe9b 	bl	8022fa0 <strlen>
 802326a:	9b07      	ldr	r3, [sp, #28]
 802326c:	4602      	mov	r2, r0
 802326e:	4641      	mov	r1, r8
 8023270:	4618      	mov	r0, r3
 8023272:	f7ff fec3 	bl	8022ffc <strncmp>
 8023276:	4680      	mov	r8, r0
 8023278:	2800      	cmp	r0, #0
 802327a:	f000 80e3 	beq.w	8023444 <_strtod_r+0x304>
 802327e:	2000      	movs	r0, #0
 8023280:	4684      	mov	ip, r0
 8023282:	4686      	mov	lr, r0
 8023284:	46a1      	mov	r9, r4
 8023286:	2e65      	cmp	r6, #101	; 0x65
 8023288:	d072      	beq.n	8023370 <_strtod_r+0x230>
 802328a:	2e45      	cmp	r6, #69	; 0x45
 802328c:	d070      	beq.n	8023370 <_strtod_r+0x230>
 802328e:	2300      	movs	r3, #0
 8023290:	f1b9 0f00 	cmp.w	r9, #0
 8023294:	d046      	beq.n	8023324 <_strtod_r+0x1e4>
 8023296:	f1b9 0f10 	cmp.w	r9, #16
 802329a:	ebcc 0303 	rsb	r3, ip, r3
 802329e:	4628      	mov	r0, r5
 80232a0:	46c8      	mov	r8, r9
 80232a2:	9307      	str	r3, [sp, #28]
 80232a4:	bfa8      	it	ge
 80232a6:	f04f 0810 	movge.w	r8, #16
 80232aa:	f7dd fb6b 	bl	8000984 <__aeabi_ui2d>
 80232ae:	2c00      	cmp	r4, #0
 80232b0:	bf08      	it	eq
 80232b2:	464c      	moveq	r4, r9
 80232b4:	f1b8 0f09 	cmp.w	r8, #9
 80232b8:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80232bc:	dd13      	ble.n	80232e6 <_strtod_r+0x1a6>
 80232be:	4b76      	ldr	r3, [pc, #472]	; (8023498 <_strtod_r+0x358>)
 80232c0:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
 80232c4:	e953 2312 	ldrd	r2, r3, [r3, #-72]	; 0x48
 80232c8:	f7dd fbd2 	bl	8000a70 <__aeabi_dmul>
 80232cc:	4606      	mov	r6, r0
 80232ce:	4658      	mov	r0, fp
 80232d0:	460f      	mov	r7, r1
 80232d2:	f7dd fb57 	bl	8000984 <__aeabi_ui2d>
 80232d6:	4602      	mov	r2, r0
 80232d8:	460b      	mov	r3, r1
 80232da:	4630      	mov	r0, r6
 80232dc:	4639      	mov	r1, r7
 80232de:	f7dd fa15 	bl	800070c <__adddf3>
 80232e2:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80232e6:	f1b9 0f0f 	cmp.w	r9, #15
 80232ea:	f300 80d7 	bgt.w	802349c <_strtod_r+0x35c>
 80232ee:	9b07      	ldr	r3, [sp, #28]
 80232f0:	2b00      	cmp	r3, #0
 80232f2:	f000 80a4 	beq.w	802343e <_strtod_r+0x2fe>
 80232f6:	9b07      	ldr	r3, [sp, #28]
 80232f8:	f340 8571 	ble.w	8023dde <_strtod_r+0xc9e>
 80232fc:	2b16      	cmp	r3, #22
 80232fe:	f300 84db 	bgt.w	8023cb8 <_strtod_r+0xb78>
 8023302:	4965      	ldr	r1, [pc, #404]	; (8023498 <_strtod_r+0x358>)
 8023304:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 8023308:	e9d1 0100 	ldrd	r0, r1, [r1]
 802330c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8023310:	f7dd fbae 	bl	8000a70 <__aeabi_dmul>
 8023314:	4680      	mov	r8, r0
 8023316:	4689      	mov	r9, r1
 8023318:	e00d      	b.n	8023336 <_strtod_r+0x1f6>
 802331a:	2301      	movs	r3, #1
 802331c:	9306      	str	r3, [sp, #24]
 802331e:	e769      	b.n	80231f4 <_strtod_r+0xb4>
 8023320:	9319      	str	r3, [sp, #100]	; 0x64
 8023322:	e71b      	b.n	802315c <_strtod_r+0x1c>
 8023324:	b918      	cbnz	r0, 802332e <_strtod_r+0x1ee>
 8023326:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8023328:	2b00      	cmp	r3, #0
 802332a:	f000 828a 	beq.w	8023842 <_strtod_r+0x702>
 802332e:	f04f 0800 	mov.w	r8, #0
 8023332:	f04f 0900 	mov.w	r9, #0
 8023336:	9b03      	ldr	r3, [sp, #12]
 8023338:	2b00      	cmp	r3, #0
 802333a:	f43f af4f 	beq.w	80231dc <_strtod_r+0x9c>
 802333e:	9f19      	ldr	r7, [sp, #100]	; 0x64
 8023340:	e74a      	b.n	80231d8 <_strtod_r+0x98>
 8023342:	2300      	movs	r3, #0
 8023344:	2e30      	cmp	r6, #48	; 0x30
 8023346:	9306      	str	r3, [sp, #24]
 8023348:	f47f af5d 	bne.w	8023206 <_strtod_r+0xc6>
 802334c:	7863      	ldrb	r3, [r4, #1]
 802334e:	2b58      	cmp	r3, #88	; 0x58
 8023350:	f000 83a4 	beq.w	8023a9c <_strtod_r+0x95c>
 8023354:	2b78      	cmp	r3, #120	; 0x78
 8023356:	f000 83a1 	beq.w	8023a9c <_strtod_r+0x95c>
 802335a:	3401      	adds	r4, #1
 802335c:	9419      	str	r4, [sp, #100]	; 0x64
 802335e:	7826      	ldrb	r6, [r4, #0]
 8023360:	2e30      	cmp	r6, #48	; 0x30
 8023362:	d0fa      	beq.n	802335a <_strtod_r+0x21a>
 8023364:	2e00      	cmp	r6, #0
 8023366:	d0e2      	beq.n	802332e <_strtod_r+0x1ee>
 8023368:	2301      	movs	r3, #1
 802336a:	9408      	str	r4, [sp, #32]
 802336c:	930a      	str	r3, [sp, #40]	; 0x28
 802336e:	e74d      	b.n	802320c <_strtod_r+0xcc>
 8023370:	f1b9 0f00 	cmp.w	r9, #0
 8023374:	d04e      	beq.n	8023414 <_strtod_r+0x2d4>
 8023376:	9f19      	ldr	r7, [sp, #100]	; 0x64
 8023378:	1c7b      	adds	r3, r7, #1
 802337a:	9319      	str	r3, [sp, #100]	; 0x64
 802337c:	787e      	ldrb	r6, [r7, #1]
 802337e:	2e2b      	cmp	r6, #43	; 0x2b
 8023380:	f000 8256 	beq.w	8023830 <_strtod_r+0x6f0>
 8023384:	2e2d      	cmp	r6, #45	; 0x2d
 8023386:	f000 824d 	beq.w	8023824 <_strtod_r+0x6e4>
 802338a:	f04f 0800 	mov.w	r8, #0
 802338e:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
 8023392:	2b09      	cmp	r3, #9
 8023394:	4632      	mov	r2, r6
 8023396:	f200 81ed 	bhi.w	8023774 <_strtod_r+0x634>
 802339a:	2e30      	cmp	r6, #48	; 0x30
 802339c:	d106      	bne.n	80233ac <_strtod_r+0x26c>
 802339e:	9b19      	ldr	r3, [sp, #100]	; 0x64
 80233a0:	3301      	adds	r3, #1
 80233a2:	9319      	str	r3, [sp, #100]	; 0x64
 80233a4:	781e      	ldrb	r6, [r3, #0]
 80233a6:	2e30      	cmp	r6, #48	; 0x30
 80233a8:	d0fa      	beq.n	80233a0 <_strtod_r+0x260>
 80233aa:	4632      	mov	r2, r6
 80233ac:	3a31      	subs	r2, #49	; 0x31
 80233ae:	2a08      	cmp	r2, #8
 80233b0:	f63f af6d 	bhi.w	802328e <_strtod_r+0x14e>
 80233b4:	9b19      	ldr	r3, [sp, #100]	; 0x64
 80233b6:	9307      	str	r3, [sp, #28]
 80233b8:	4619      	mov	r1, r3
 80233ba:	1c5a      	adds	r2, r3, #1
 80233bc:	9219      	str	r2, [sp, #100]	; 0x64
 80233be:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
 80233c2:	784e      	ldrb	r6, [r1, #1]
 80233c4:	f1a6 0130 	sub.w	r1, r6, #48	; 0x30
 80233c8:	2909      	cmp	r1, #9
 80233ca:	d80c      	bhi.n	80233e6 <_strtod_r+0x2a6>
 80233cc:	3201      	adds	r2, #1
 80233ce:	9219      	str	r2, [sp, #100]	; 0x64
 80233d0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80233d4:	eb06 0343 	add.w	r3, r6, r3, lsl #1
 80233d8:	7816      	ldrb	r6, [r2, #0]
 80233da:	f1a6 0130 	sub.w	r1, r6, #48	; 0x30
 80233de:	2909      	cmp	r1, #9
 80233e0:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 80233e4:	d9f2      	bls.n	80233cc <_strtod_r+0x28c>
 80233e6:	9907      	ldr	r1, [sp, #28]
 80233e8:	1a52      	subs	r2, r2, r1
 80233ea:	2a08      	cmp	r2, #8
 80233ec:	f300 845b 	bgt.w	8023ca6 <_strtod_r+0xb66>
 80233f0:	f644 621f 	movw	r2, #19999	; 0x4e1f
 80233f4:	4293      	cmp	r3, r2
 80233f6:	bfa8      	it	ge
 80233f8:	4613      	movge	r3, r2
 80233fa:	f1c8 0200 	rsb	r2, r8, #0
 80233fe:	4053      	eors	r3, r2
 8023400:	4443      	add	r3, r8
 8023402:	f1b9 0f00 	cmp.w	r9, #0
 8023406:	f47f af46 	bne.w	8023296 <_strtod_r+0x156>
 802340a:	e78b      	b.n	8023324 <_strtod_r+0x1e4>
 802340c:	f04f 0c00 	mov.w	ip, #0
 8023410:	f04f 0e01 	mov.w	lr, #1
 8023414:	2800      	cmp	r0, #0
 8023416:	f040 8211 	bne.w	802383c <_strtod_r+0x6fc>
 802341a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802341c:	2b00      	cmp	r3, #0
 802341e:	f43f aed3 	beq.w	80231c8 <_strtod_r+0x88>
 8023422:	4681      	mov	r9, r0
 8023424:	e7a7      	b.n	8023376 <_strtod_r+0x236>
 8023426:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 802342a:	9305      	str	r3, [sp, #20]
 802342c:	f04f 33ff 	mov.w	r3, #4294967295
 8023430:	9304      	str	r3, [sp, #16]
 8023432:	072b      	lsls	r3, r5, #28
 8023434:	bf42      	ittt	mi
 8023436:	9b05      	ldrmi	r3, [sp, #20]
 8023438:	f043 4300 	orrmi.w	r3, r3, #2147483648	; 0x80000000
 802343c:	9305      	strmi	r3, [sp, #20]
 802343e:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
 8023442:	e778      	b.n	8023336 <_strtod_r+0x1f6>
 8023444:	4650      	mov	r0, sl
 8023446:	f001 fe51 	bl	80250ec <_localeconv_r>
 802344a:	6800      	ldr	r0, [r0, #0]
 802344c:	f7ff fda8 	bl	8022fa0 <strlen>
 8023450:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8023452:	181a      	adds	r2, r3, r0
 8023454:	9219      	str	r2, [sp, #100]	; 0x64
 8023456:	5c1e      	ldrb	r6, [r3, r0]
 8023458:	2c00      	cmp	r4, #0
 802345a:	f040 81d1 	bne.w	8023800 <_strtod_r+0x6c0>
 802345e:	2e30      	cmp	r6, #48	; 0x30
 8023460:	4620      	mov	r0, r4
 8023462:	d106      	bne.n	8023472 <_strtod_r+0x332>
 8023464:	3201      	adds	r2, #1
 8023466:	9219      	str	r2, [sp, #100]	; 0x64
 8023468:	7816      	ldrb	r6, [r2, #0]
 802346a:	2e30      	cmp	r6, #48	; 0x30
 802346c:	f100 0001 	add.w	r0, r0, #1
 8023470:	d0f8      	beq.n	8023464 <_strtod_r+0x324>
 8023472:	f1a6 0331 	sub.w	r3, r6, #49	; 0x31
 8023476:	2b08      	cmp	r3, #8
 8023478:	f200 8288 	bhi.w	802398c <_strtod_r+0x84c>
 802347c:	9b19      	ldr	r3, [sp, #100]	; 0x64
 802347e:	9308      	str	r3, [sp, #32]
 8023480:	3e30      	subs	r6, #48	; 0x30
 8023482:	f100 0c01 	add.w	ip, r0, #1
 8023486:	f04f 0901 	mov.w	r9, #1
 802348a:	eb05 0585 	add.w	r5, r5, r5, lsl #2
 802348e:	eb06 0545 	add.w	r5, r6, r5, lsl #1
 8023492:	2000      	movs	r0, #0
 8023494:	e1c2      	b.n	802381c <_strtod_r+0x6dc>
 8023496:	bf00      	nop
 8023498:	0802b928 	.word	0x0802b928
 802349c:	9b07      	ldr	r3, [sp, #28]
 802349e:	ebc8 0809 	rsb	r8, r8, r9
 80234a2:	4498      	add	r8, r3
 80234a4:	f1b8 0f00 	cmp.w	r8, #0
 80234a8:	f340 83a3 	ble.w	8023bf2 <_strtod_r+0xab2>
 80234ac:	f018 010f 	ands.w	r1, r8, #15
 80234b0:	d00a      	beq.n	80234c8 <_strtod_r+0x388>
 80234b2:	4bbb      	ldr	r3, [pc, #748]	; (80237a0 <_strtod_r+0x660>)
 80234b4:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 80234b8:	e9d1 0100 	ldrd	r0, r1, [r1]
 80234bc:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 80234c0:	f7dd fad6 	bl	8000a70 <__aeabi_dmul>
 80234c4:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80234c8:	f038 060f 	bics.w	r6, r8, #15
 80234cc:	f040 8210 	bne.w	80238f0 <_strtod_r+0x7b0>
 80234d0:	2300      	movs	r3, #0
 80234d2:	930a      	str	r3, [sp, #40]	; 0x28
 80234d4:	9500      	str	r5, [sp, #0]
 80234d6:	9908      	ldr	r1, [sp, #32]
 80234d8:	4622      	mov	r2, r4
 80234da:	464b      	mov	r3, r9
 80234dc:	4650      	mov	r0, sl
 80234de:	f001 fe7b 	bl	80251d8 <__s2b>
 80234e2:	900f      	str	r0, [sp, #60]	; 0x3c
 80234e4:	2800      	cmp	r0, #0
 80234e6:	f000 8343 	beq.w	8023b70 <_strtod_r+0xa30>
 80234ea:	9a07      	ldr	r2, [sp, #28]
 80234ec:	2100      	movs	r1, #0
 80234ee:	2a00      	cmp	r2, #0
 80234f0:	f1c2 0300 	rsb	r3, r2, #0
 80234f4:	bfa8      	it	ge
 80234f6:	460b      	movge	r3, r1
 80234f8:	930e      	str	r3, [sp, #56]	; 0x38
 80234fa:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
 80234fe:	9107      	str	r1, [sp, #28]
 8023500:	930b      	str	r3, [sp, #44]	; 0x2c
 8023502:	468b      	mov	fp, r1
 8023504:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 8023506:	4650      	mov	r0, sl
 8023508:	6861      	ldr	r1, [r4, #4]
 802350a:	f001 fdf3 	bl	80250f4 <_Balloc>
 802350e:	4607      	mov	r7, r0
 8023510:	2800      	cmp	r0, #0
 8023512:	f000 82a4 	beq.w	8023a5e <_strtod_r+0x91e>
 8023516:	6922      	ldr	r2, [r4, #16]
 8023518:	ed9d 7b04 	vldr	d7, [sp, #16]
 802351c:	3202      	adds	r2, #2
 802351e:	0092      	lsls	r2, r2, #2
 8023520:	f104 010c 	add.w	r1, r4, #12
 8023524:	300c      	adds	r0, #12
 8023526:	ed8d 7b08 	vstr	d7, [sp, #32]
 802352a:	f7dc fed9 	bl	80002e0 <memcpy>
 802352e:	ed9d 0b08 	vldr	d0, [sp, #32]
 8023532:	4650      	mov	r0, sl
 8023534:	a91b      	add	r1, sp, #108	; 0x6c
 8023536:	aa1c      	add	r2, sp, #112	; 0x70
 8023538:	f002 f94a 	bl	80257d0 <__d2b>
 802353c:	901a      	str	r0, [sp, #104]	; 0x68
 802353e:	2800      	cmp	r0, #0
 8023540:	f000 828e 	beq.w	8023a60 <_strtod_r+0x920>
 8023544:	4650      	mov	r0, sl
 8023546:	2101      	movs	r1, #1
 8023548:	f001 fee0 	bl	802530c <__i2b>
 802354c:	4683      	mov	fp, r0
 802354e:	2800      	cmp	r0, #0
 8023550:	f000 8285 	beq.w	8023a5e <_strtod_r+0x91e>
 8023554:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8023556:	2b00      	cmp	r3, #0
 8023558:	f2c0 80ff 	blt.w	802375a <_strtod_r+0x61a>
 802355c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802355e:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8023560:	eb02 0903 	add.w	r9, r2, r3
 8023564:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8023566:	9e1c      	ldr	r6, [sp, #112]	; 0x70
 8023568:	1a9b      	subs	r3, r3, r2
 802356a:	4433      	add	r3, r6
 802356c:	f46f 727f 	mvn.w	r2, #1020	; 0x3fc
 8023570:	4293      	cmp	r3, r2
 8023572:	f1c6 0636 	rsb	r6, r6, #54	; 0x36
 8023576:	f280 80d9 	bge.w	802372c <_strtod_r+0x5ec>
 802357a:	1ad2      	subs	r2, r2, r3
 802357c:	2a1f      	cmp	r2, #31
 802357e:	eba6 0602 	sub.w	r6, r6, r2
 8023582:	f300 80ef 	bgt.w	8023764 <_strtod_r+0x624>
 8023586:	f04f 0801 	mov.w	r8, #1
 802358a:	2300      	movs	r3, #0
 802358c:	fa08 f802 	lsl.w	r8, r8, r2
 8023590:	930c      	str	r3, [sp, #48]	; 0x30
 8023592:	4435      	add	r5, r6
 8023594:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8023596:	444e      	add	r6, r9
 8023598:	454e      	cmp	r6, r9
 802359a:	441d      	add	r5, r3
 802359c:	4633      	mov	r3, r6
 802359e:	bfa8      	it	ge
 80235a0:	464b      	movge	r3, r9
 80235a2:	42ab      	cmp	r3, r5
 80235a4:	bfa8      	it	ge
 80235a6:	462b      	movge	r3, r5
 80235a8:	2b00      	cmp	r3, #0
 80235aa:	dd03      	ble.n	80235b4 <_strtod_r+0x474>
 80235ac:	1af6      	subs	r6, r6, r3
 80235ae:	1aed      	subs	r5, r5, r3
 80235b0:	ebc3 0909 	rsb	r9, r3, r9
 80235b4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80235b6:	b1b3      	cbz	r3, 80235e6 <_strtod_r+0x4a6>
 80235b8:	4659      	mov	r1, fp
 80235ba:	4650      	mov	r0, sl
 80235bc:	461a      	mov	r2, r3
 80235be:	f001 ff49 	bl	8025454 <__pow5mult>
 80235c2:	4683      	mov	fp, r0
 80235c4:	2800      	cmp	r0, #0
 80235c6:	f000 824a 	beq.w	8023a5e <_strtod_r+0x91e>
 80235ca:	4650      	mov	r0, sl
 80235cc:	4659      	mov	r1, fp
 80235ce:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 80235d0:	f001 fea6 	bl	8025320 <__multiply>
 80235d4:	4604      	mov	r4, r0
 80235d6:	2800      	cmp	r0, #0
 80235d8:	f000 8241 	beq.w	8023a5e <_strtod_r+0x91e>
 80235dc:	4650      	mov	r0, sl
 80235de:	991a      	ldr	r1, [sp, #104]	; 0x68
 80235e0:	f001 fdae 	bl	8025140 <_Bfree>
 80235e4:	941a      	str	r4, [sp, #104]	; 0x68
 80235e6:	2e00      	cmp	r6, #0
 80235e8:	dd08      	ble.n	80235fc <_strtod_r+0x4bc>
 80235ea:	4632      	mov	r2, r6
 80235ec:	4650      	mov	r0, sl
 80235ee:	991a      	ldr	r1, [sp, #104]	; 0x68
 80235f0:	f001 ff80 	bl	80254f4 <__lshift>
 80235f4:	901a      	str	r0, [sp, #104]	; 0x68
 80235f6:	2800      	cmp	r0, #0
 80235f8:	f000 8232 	beq.w	8023a60 <_strtod_r+0x920>
 80235fc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80235fe:	b143      	cbz	r3, 8023612 <_strtod_r+0x4d2>
 8023600:	4639      	mov	r1, r7
 8023602:	4650      	mov	r0, sl
 8023604:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8023606:	f001 ff25 	bl	8025454 <__pow5mult>
 802360a:	4607      	mov	r7, r0
 802360c:	2800      	cmp	r0, #0
 802360e:	f000 8226 	beq.w	8023a5e <_strtod_r+0x91e>
 8023612:	2d00      	cmp	r5, #0
 8023614:	dd08      	ble.n	8023628 <_strtod_r+0x4e8>
 8023616:	4639      	mov	r1, r7
 8023618:	462a      	mov	r2, r5
 802361a:	4650      	mov	r0, sl
 802361c:	f001 ff6a 	bl	80254f4 <__lshift>
 8023620:	4607      	mov	r7, r0
 8023622:	2800      	cmp	r0, #0
 8023624:	f000 821b 	beq.w	8023a5e <_strtod_r+0x91e>
 8023628:	f1b9 0f00 	cmp.w	r9, #0
 802362c:	dd08      	ble.n	8023640 <_strtod_r+0x500>
 802362e:	4659      	mov	r1, fp
 8023630:	464a      	mov	r2, r9
 8023632:	4650      	mov	r0, sl
 8023634:	f001 ff5e 	bl	80254f4 <__lshift>
 8023638:	4683      	mov	fp, r0
 802363a:	2800      	cmp	r0, #0
 802363c:	f000 820f 	beq.w	8023a5e <_strtod_r+0x91e>
 8023640:	4650      	mov	r0, sl
 8023642:	991a      	ldr	r1, [sp, #104]	; 0x68
 8023644:	463a      	mov	r2, r7
 8023646:	f001 ffcf 	bl	80255e8 <__mdiff>
 802364a:	9007      	str	r0, [sp, #28]
 802364c:	2800      	cmp	r0, #0
 802364e:	f000 8206 	beq.w	8023a5e <_strtod_r+0x91e>
 8023652:	9907      	ldr	r1, [sp, #28]
 8023654:	2300      	movs	r3, #0
 8023656:	68ce      	ldr	r6, [r1, #12]
 8023658:	60cb      	str	r3, [r1, #12]
 802365a:	4659      	mov	r1, fp
 802365c:	f001 ffa0 	bl	80255a0 <__mcmp>
 8023660:	2800      	cmp	r0, #0
 8023662:	f2c0 8433 	blt.w	8023ecc <_strtod_r+0xd8c>
 8023666:	f000 83f0 	beq.w	8023e4a <_strtod_r+0xd0a>
 802366a:	9807      	ldr	r0, [sp, #28]
 802366c:	4659      	mov	r1, fp
 802366e:	f002 f90d 	bl	802588c <__ratio>
 8023672:	ec55 4b10 	vmov	r4, r5, d0
 8023676:	ee10 0a10 	vmov	r0, s0
 802367a:	4629      	mov	r1, r5
 802367c:	2200      	movs	r2, #0
 802367e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8023682:	f7dd fc71 	bl	8000f68 <__aeabi_dcmple>
 8023686:	2800      	cmp	r0, #0
 8023688:	d055      	beq.n	8023736 <_strtod_r+0x5f6>
 802368a:	2e00      	cmp	r6, #0
 802368c:	f000 8094 	beq.w	80237b8 <_strtod_r+0x678>
 8023690:	ed9f 7b3f 	vldr	d7, [pc, #252]	; 8023790 <_strtod_r+0x650>
 8023694:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
 8023698:	4d42      	ldr	r5, [pc, #264]	; (80237a4 <_strtod_r+0x664>)
 802369a:	f8dd 8014 	ldr.w	r8, [sp, #20]
 802369e:	2400      	movs	r4, #0
 80236a0:	f8df 9108 	ldr.w	r9, [pc, #264]	; 80237ac <_strtod_r+0x66c>
 80236a4:	4b40      	ldr	r3, [pc, #256]	; (80237a8 <_strtod_r+0x668>)
 80236a6:	ea08 0909 	and.w	r9, r8, r9
 80236aa:	4599      	cmp	r9, r3
 80236ac:	f000 8230 	beq.w	8023b10 <_strtod_r+0x9d0>
 80236b0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80236b2:	b183      	cbz	r3, 80236d6 <_strtod_r+0x596>
 80236b4:	f1b9 6fd4 	cmp.w	r9, #111149056	; 0x6a00000
 80236b8:	d80d      	bhi.n	80236d6 <_strtod_r+0x596>
 80236ba:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 80236be:	a336      	add	r3, pc, #216	; (adr r3, 8023798 <_strtod_r+0x658>)
 80236c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80236c4:	f7dd fc50 	bl	8000f68 <__aeabi_dcmple>
 80236c8:	2800      	cmp	r0, #0
 80236ca:	f040 8168 	bne.w	802399e <_strtod_r+0x85e>
 80236ce:	f105 63d6 	add.w	r3, r5, #112197632	; 0x6b00000
 80236d2:	ebc9 0503 	rsb	r5, r9, r3
 80236d6:	ed9d 0b08 	vldr	d0, [sp, #32]
 80236da:	f001 ffef 	bl	80256bc <__ulp>
 80236de:	4620      	mov	r0, r4
 80236e0:	ec53 2b10 	vmov	r2, r3, d0
 80236e4:	4629      	mov	r1, r5
 80236e6:	f7dd f9c3 	bl	8000a70 <__aeabi_dmul>
 80236ea:	4602      	mov	r2, r0
 80236ec:	460b      	mov	r3, r1
 80236ee:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 80236f2:	f7dd f80b 	bl	800070c <__adddf3>
 80236f6:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80236fa:	460c      	mov	r4, r1
 80236fc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80236fe:	b923      	cbnz	r3, 802370a <_strtod_r+0x5ca>
 8023700:	4b2a      	ldr	r3, [pc, #168]	; (80237ac <_strtod_r+0x66c>)
 8023702:	4023      	ands	r3, r4
 8023704:	4599      	cmp	r9, r3
 8023706:	f000 823e 	beq.w	8023b86 <_strtod_r+0xa46>
 802370a:	4650      	mov	r0, sl
 802370c:	991a      	ldr	r1, [sp, #104]	; 0x68
 802370e:	f001 fd17 	bl	8025140 <_Bfree>
 8023712:	4650      	mov	r0, sl
 8023714:	4639      	mov	r1, r7
 8023716:	f001 fd13 	bl	8025140 <_Bfree>
 802371a:	4650      	mov	r0, sl
 802371c:	4659      	mov	r1, fp
 802371e:	f001 fd0f 	bl	8025140 <_Bfree>
 8023722:	4650      	mov	r0, sl
 8023724:	9907      	ldr	r1, [sp, #28]
 8023726:	f001 fd0b 	bl	8025140 <_Bfree>
 802372a:	e6eb      	b.n	8023504 <_strtod_r+0x3c4>
 802372c:	2300      	movs	r3, #0
 802372e:	930c      	str	r3, [sp, #48]	; 0x30
 8023730:	f04f 0801 	mov.w	r8, #1
 8023734:	e72d      	b.n	8023592 <_strtod_r+0x452>
 8023736:	4620      	mov	r0, r4
 8023738:	4629      	mov	r1, r5
 802373a:	2200      	movs	r2, #0
 802373c:	4b1c      	ldr	r3, [pc, #112]	; (80237b0 <_strtod_r+0x670>)
 802373e:	f7dd f997 	bl	8000a70 <__aeabi_dmul>
 8023742:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
 8023746:	b9e6      	cbnz	r6, 8023782 <_strtod_r+0x642>
 8023748:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 802374c:	9010      	str	r0, [sp, #64]	; 0x40
 802374e:	9311      	str	r3, [sp, #68]	; 0x44
 8023750:	e9dd 4510 	ldrd	r4, r5, [sp, #64]	; 0x40
 8023754:	f8dd 8014 	ldr.w	r8, [sp, #20]
 8023758:	e7a2      	b.n	80236a0 <_strtod_r+0x560>
 802375a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 802375c:	f8dd 9038 	ldr.w	r9, [sp, #56]	; 0x38
 8023760:	1ad5      	subs	r5, r2, r3
 8023762:	e6ff      	b.n	8023564 <_strtod_r+0x424>
 8023764:	4a13      	ldr	r2, [pc, #76]	; (80237b4 <_strtod_r+0x674>)
 8023766:	f04f 0801 	mov.w	r8, #1
 802376a:	1ad2      	subs	r2, r2, r3
 802376c:	fa08 f302 	lsl.w	r3, r8, r2
 8023770:	930c      	str	r3, [sp, #48]	; 0x30
 8023772:	e70e      	b.n	8023592 <_strtod_r+0x452>
 8023774:	9719      	str	r7, [sp, #100]	; 0x64
 8023776:	2300      	movs	r3, #0
 8023778:	f1b9 0f00 	cmp.w	r9, #0
 802377c:	f47f ad8b 	bne.w	8023296 <_strtod_r+0x156>
 8023780:	e5d0      	b.n	8023324 <_strtod_r+0x1e4>
 8023782:	ed9d 7b0c 	vldr	d7, [sp, #48]	; 0x30
 8023786:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
 802378a:	e7e1      	b.n	8023750 <_strtod_r+0x610>
 802378c:	f3af 8000 	nop.w
 8023790:	00000000 	.word	0x00000000
 8023794:	3ff00000 	.word	0x3ff00000
 8023798:	ffc00000 	.word	0xffc00000
 802379c:	41dfffff 	.word	0x41dfffff
 80237a0:	0802b928 	.word	0x0802b928
 80237a4:	3ff00000 	.word	0x3ff00000
 80237a8:	7fe00000 	.word	0x7fe00000
 80237ac:	7ff00000 	.word	0x7ff00000
 80237b0:	3fe00000 	.word	0x3fe00000
 80237b4:	fffffbe3 	.word	0xfffffbe3
 80237b8:	9b04      	ldr	r3, [sp, #16]
 80237ba:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 80237be:	2b00      	cmp	r3, #0
 80237c0:	f040 80d9 	bne.w	8023976 <_strtod_r+0x836>
 80237c4:	f3c1 0313 	ubfx	r3, r1, #0, #20
 80237c8:	4688      	mov	r8, r1
 80237ca:	2b00      	cmp	r3, #0
 80237cc:	f040 80d7 	bne.w	802397e <_strtod_r+0x83e>
 80237d0:	4620      	mov	r0, r4
 80237d2:	4629      	mov	r1, r5
 80237d4:	2200      	movs	r2, #0
 80237d6:	4bc2      	ldr	r3, [pc, #776]	; (8023ae0 <_strtod_r+0x9a0>)
 80237d8:	f7dd fbbc 	bl	8000f54 <__aeabi_dcmplt>
 80237dc:	2800      	cmp	r0, #0
 80237de:	f040 83b4 	bne.w	8023f4a <_strtod_r+0xe0a>
 80237e2:	4bc0      	ldr	r3, [pc, #768]	; (8023ae4 <_strtod_r+0x9a4>)
 80237e4:	4620      	mov	r0, r4
 80237e6:	4629      	mov	r1, r5
 80237e8:	2200      	movs	r2, #0
 80237ea:	f7dd f941 	bl	8000a70 <__aeabi_dmul>
 80237ee:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
 80237f2:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 80237f6:	9016      	str	r0, [sp, #88]	; 0x58
 80237f8:	9317      	str	r3, [sp, #92]	; 0x5c
 80237fa:	e9dd 4516 	ldrd	r4, r5, [sp, #88]	; 0x58
 80237fe:	e74f      	b.n	80236a0 <_strtod_r+0x560>
 8023800:	4640      	mov	r0, r8
 8023802:	46c4      	mov	ip, r8
 8023804:	46a1      	mov	r9, r4
 8023806:	f1a6 0230 	sub.w	r2, r6, #48	; 0x30
 802380a:	2a09      	cmp	r2, #9
 802380c:	d813      	bhi.n	8023836 <_strtod_r+0x6f6>
 802380e:	1c43      	adds	r3, r0, #1
 8023810:	4616      	mov	r6, r2
 8023812:	2a00      	cmp	r2, #0
 8023814:	f040 8273 	bne.w	8023cfe <_strtod_r+0xbbe>
 8023818:	4618      	mov	r0, r3
 802381a:	9b19      	ldr	r3, [sp, #100]	; 0x64
 802381c:	1c5a      	adds	r2, r3, #1
 802381e:	9219      	str	r2, [sp, #100]	; 0x64
 8023820:	785e      	ldrb	r6, [r3, #1]
 8023822:	e7f0      	b.n	8023806 <_strtod_r+0x6c6>
 8023824:	f04f 0801 	mov.w	r8, #1
 8023828:	1cbb      	adds	r3, r7, #2
 802382a:	9319      	str	r3, [sp, #100]	; 0x64
 802382c:	78be      	ldrb	r6, [r7, #2]
 802382e:	e5ae      	b.n	802338e <_strtod_r+0x24e>
 8023830:	f04f 0800 	mov.w	r8, #0
 8023834:	e7f8      	b.n	8023828 <_strtod_r+0x6e8>
 8023836:	f04f 0e01 	mov.w	lr, #1
 802383a:	e524      	b.n	8023286 <_strtod_r+0x146>
 802383c:	f04f 0900 	mov.w	r9, #0
 8023840:	e599      	b.n	8023376 <_strtod_r+0x236>
 8023842:	f1be 0f00 	cmp.w	lr, #0
 8023846:	f47f acbf 	bne.w	80231c8 <_strtod_r+0x88>
 802384a:	3e49      	subs	r6, #73	; 0x49
 802384c:	2e25      	cmp	r6, #37	; 0x25
 802384e:	f63f acbb 	bhi.w	80231c8 <_strtod_r+0x88>
 8023852:	a301      	add	r3, pc, #4	; (adr r3, 8023858 <_strtod_r+0x718>)
 8023854:	f853 f026 	ldr.w	pc, [r3, r6, lsl #2]
 8023858:	08023a05 	.word	0x08023a05
 802385c:	080231c9 	.word	0x080231c9
 8023860:	080231c9 	.word	0x080231c9
 8023864:	080231c9 	.word	0x080231c9
 8023868:	080231c9 	.word	0x080231c9
 802386c:	080239cd 	.word	0x080239cd
 8023870:	080231c9 	.word	0x080231c9
 8023874:	080231c9 	.word	0x080231c9
 8023878:	080231c9 	.word	0x080231c9
 802387c:	080231c9 	.word	0x080231c9
 8023880:	080231c9 	.word	0x080231c9
 8023884:	080231c9 	.word	0x080231c9
 8023888:	080231c9 	.word	0x080231c9
 802388c:	080231c9 	.word	0x080231c9
 8023890:	080231c9 	.word	0x080231c9
 8023894:	080231c9 	.word	0x080231c9
 8023898:	080231c9 	.word	0x080231c9
 802389c:	080231c9 	.word	0x080231c9
 80238a0:	080231c9 	.word	0x080231c9
 80238a4:	080231c9 	.word	0x080231c9
 80238a8:	080231c9 	.word	0x080231c9
 80238ac:	080231c9 	.word	0x080231c9
 80238b0:	080231c9 	.word	0x080231c9
 80238b4:	080231c9 	.word	0x080231c9
 80238b8:	080231c9 	.word	0x080231c9
 80238bc:	080231c9 	.word	0x080231c9
 80238c0:	080231c9 	.word	0x080231c9
 80238c4:	080231c9 	.word	0x080231c9
 80238c8:	080231c9 	.word	0x080231c9
 80238cc:	080231c9 	.word	0x080231c9
 80238d0:	080231c9 	.word	0x080231c9
 80238d4:	080231c9 	.word	0x080231c9
 80238d8:	08023a05 	.word	0x08023a05
 80238dc:	080231c9 	.word	0x080231c9
 80238e0:	080231c9 	.word	0x080231c9
 80238e4:	080231c9 	.word	0x080231c9
 80238e8:	080231c9 	.word	0x080231c9
 80238ec:	080239cd 	.word	0x080239cd
 80238f0:	f5b6 7f9a 	cmp.w	r6, #308	; 0x134
 80238f4:	f300 813c 	bgt.w	8023b70 <_strtod_r+0xa30>
 80238f8:	1136      	asrs	r6, r6, #4
 80238fa:	2e01      	cmp	r6, #1
 80238fc:	f8df 820c 	ldr.w	r8, [pc, #524]	; 8023b0c <_strtod_r+0x9cc>
 8023900:	f340 8346 	ble.w	8023f90 <_strtod_r+0xe50>
 8023904:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8023908:	4647      	mov	r7, r8
 802390a:	f04f 0b00 	mov.w	fp, #0
 802390e:	f016 0f01 	tst.w	r6, #1
 8023912:	f10b 0b01 	add.w	fp, fp, #1
 8023916:	ea4f 0666 	mov.w	r6, r6, asr #1
 802391a:	d003      	beq.n	8023924 <_strtod_r+0x7e4>
 802391c:	e9d7 2300 	ldrd	r2, r3, [r7]
 8023920:	f7dd f8a6 	bl	8000a70 <__aeabi_dmul>
 8023924:	2e01      	cmp	r6, #1
 8023926:	f107 0708 	add.w	r7, r7, #8
 802392a:	d1f0      	bne.n	802390e <_strtod_r+0x7ce>
 802392c:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8023930:	9b05      	ldr	r3, [sp, #20]
 8023932:	f1a3 7354 	sub.w	r3, r3, #55574528	; 0x3500000
 8023936:	9305      	str	r3, [sp, #20]
 8023938:	eb08 08cb 	add.w	r8, r8, fp, lsl #3
 802393c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8023940:	e9d8 0100 	ldrd	r0, r1, [r8]
 8023944:	f7dd f894 	bl	8000a70 <__aeabi_dmul>
 8023948:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 802394c:	0d1b      	lsrs	r3, r3, #20
 802394e:	4a66      	ldr	r2, [pc, #408]	; (8023ae8 <_strtod_r+0x9a8>)
 8023950:	051b      	lsls	r3, r3, #20
 8023952:	4293      	cmp	r3, r2
 8023954:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8023958:	f200 810a 	bhi.w	8023b70 <_strtod_r+0xa30>
 802395c:	f5a2 1280 	sub.w	r2, r2, #1048576	; 0x100000
 8023960:	4293      	cmp	r3, r2
 8023962:	f240 82fb 	bls.w	8023f5c <_strtod_r+0xe1c>
 8023966:	4b61      	ldr	r3, [pc, #388]	; (8023aec <_strtod_r+0x9ac>)
 8023968:	9305      	str	r3, [sp, #20]
 802396a:	2300      	movs	r3, #0
 802396c:	930a      	str	r3, [sp, #40]	; 0x28
 802396e:	f04f 33ff 	mov.w	r3, #4294967295
 8023972:	9304      	str	r3, [sp, #16]
 8023974:	e5ae      	b.n	80234d4 <_strtod_r+0x394>
 8023976:	2801      	cmp	r0, #1
 8023978:	f000 81e6 	beq.w	8023d48 <_strtod_r+0xc08>
 802397c:	4688      	mov	r8, r1
 802397e:	ed9f 7b56 	vldr	d7, [pc, #344]	; 8023ad8 <_strtod_r+0x998>
 8023982:	2400      	movs	r4, #0
 8023984:	4d5a      	ldr	r5, [pc, #360]	; (8023af0 <_strtod_r+0x9b0>)
 8023986:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
 802398a:	e689      	b.n	80236a0 <_strtod_r+0x560>
 802398c:	2e65      	cmp	r6, #101	; 0x65
 802398e:	f43f ad3d 	beq.w	802340c <_strtod_r+0x2cc>
 8023992:	f04f 0900 	mov.w	r9, #0
 8023996:	46cc      	mov	ip, r9
 8023998:	f04f 0e01 	mov.w	lr, #1
 802399c:	e475      	b.n	802328a <_strtod_r+0x14a>
 802399e:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 80239a2:	f7dd fb27 	bl	8000ff4 <__aeabi_d2uiz>
 80239a6:	2800      	cmp	r0, #0
 80239a8:	f000 81c9 	beq.w	8023d3e <_strtod_r+0xbfe>
 80239ac:	f7dc ffea 	bl	8000984 <__aeabi_ui2d>
 80239b0:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
 80239b4:	2e00      	cmp	r6, #0
 80239b6:	f040 819d 	bne.w	8023cf4 <_strtod_r+0xbb4>
 80239ba:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 80239be:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 80239c2:	9014      	str	r0, [sp, #80]	; 0x50
 80239c4:	9315      	str	r3, [sp, #84]	; 0x54
 80239c6:	e9dd 4514 	ldrd	r4, r5, [sp, #80]	; 0x50
 80239ca:	e680      	b.n	80236ce <_strtod_r+0x58e>
 80239cc:	9919      	ldr	r1, [sp, #100]	; 0x64
 80239ce:	4849      	ldr	r0, [pc, #292]	; (8023af4 <_strtod_r+0x9b4>)
 80239d0:	e009      	b.n	80239e6 <_strtod_r+0x8a6>
 80239d2:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 80239d6:	f1a3 0441 	sub.w	r4, r3, #65	; 0x41
 80239da:	2c19      	cmp	r4, #25
 80239dc:	bf98      	it	ls
 80239de:	3320      	addls	r3, #32
 80239e0:	4293      	cmp	r3, r2
 80239e2:	f47f abf1 	bne.w	80231c8 <_strtod_r+0x88>
 80239e6:	f810 2b01 	ldrb.w	r2, [r0], #1
 80239ea:	2a00      	cmp	r2, #0
 80239ec:	d1f1      	bne.n	80239d2 <_strtod_r+0x892>
 80239ee:	1c4b      	adds	r3, r1, #1
 80239f0:	9319      	str	r3, [sp, #100]	; 0x64
 80239f2:	784b      	ldrb	r3, [r1, #1]
 80239f4:	2b28      	cmp	r3, #40	; 0x28
 80239f6:	f000 8309 	beq.w	802400c <_strtod_r+0xecc>
 80239fa:	4b3f      	ldr	r3, [pc, #252]	; (8023af8 <_strtod_r+0x9b8>)
 80239fc:	9305      	str	r3, [sp, #20]
 80239fe:	2300      	movs	r3, #0
 8023a00:	9304      	str	r3, [sp, #16]
 8023a02:	e51c      	b.n	802343e <_strtod_r+0x2fe>
 8023a04:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8023a06:	483d      	ldr	r0, [pc, #244]	; (8023afc <_strtod_r+0x9bc>)
 8023a08:	e009      	b.n	8023a1e <_strtod_r+0x8de>
 8023a0a:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8023a0e:	f1a3 0441 	sub.w	r4, r3, #65	; 0x41
 8023a12:	2c19      	cmp	r4, #25
 8023a14:	bf98      	it	ls
 8023a16:	3320      	addls	r3, #32
 8023a18:	428b      	cmp	r3, r1
 8023a1a:	f47f abd5 	bne.w	80231c8 <_strtod_r+0x88>
 8023a1e:	f810 1b01 	ldrb.w	r1, [r0], #1
 8023a22:	2900      	cmp	r1, #0
 8023a24:	d1f1      	bne.n	8023a0a <_strtod_r+0x8ca>
 8023a26:	9219      	str	r2, [sp, #100]	; 0x64
 8023a28:	4615      	mov	r5, r2
 8023a2a:	4835      	ldr	r0, [pc, #212]	; (8023b00 <_strtod_r+0x9c0>)
 8023a2c:	e009      	b.n	8023a42 <_strtod_r+0x902>
 8023a2e:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8023a32:	f1a3 0441 	sub.w	r4, r3, #65	; 0x41
 8023a36:	2c19      	cmp	r4, #25
 8023a38:	bf98      	it	ls
 8023a3a:	3320      	addls	r3, #32
 8023a3c:	428b      	cmp	r3, r1
 8023a3e:	f040 82a4 	bne.w	8023f8a <_strtod_r+0xe4a>
 8023a42:	f810 1b01 	ldrb.w	r1, [r0], #1
 8023a46:	2900      	cmp	r1, #0
 8023a48:	d1f1      	bne.n	8023a2e <_strtod_r+0x8ee>
 8023a4a:	3201      	adds	r2, #1
 8023a4c:	9219      	str	r2, [sp, #100]	; 0x64
 8023a4e:	4b2d      	ldr	r3, [pc, #180]	; (8023b04 <_strtod_r+0x9c4>)
 8023a50:	9305      	str	r3, [sp, #20]
 8023a52:	2300      	movs	r3, #0
 8023a54:	9304      	str	r3, [sp, #16]
 8023a56:	e4f2      	b.n	802343e <_strtod_r+0x2fe>
 8023a58:	3101      	adds	r1, #1
 8023a5a:	f040 82ca 	bne.w	8023ff2 <_strtod_r+0xeb2>
 8023a5e:	981a      	ldr	r0, [sp, #104]	; 0x68
 8023a60:	4b28      	ldr	r3, [pc, #160]	; (8023b04 <_strtod_r+0x9c4>)
 8023a62:	9305      	str	r3, [sp, #20]
 8023a64:	2200      	movs	r2, #0
 8023a66:	9204      	str	r2, [sp, #16]
 8023a68:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
 8023a6c:	2322      	movs	r3, #34	; 0x22
 8023a6e:	f8ca 3000 	str.w	r3, [sl]
 8023a72:	4601      	mov	r1, r0
 8023a74:	4650      	mov	r0, sl
 8023a76:	f001 fb63 	bl	8025140 <_Bfree>
 8023a7a:	4650      	mov	r0, sl
 8023a7c:	4639      	mov	r1, r7
 8023a7e:	f001 fb5f 	bl	8025140 <_Bfree>
 8023a82:	4650      	mov	r0, sl
 8023a84:	4659      	mov	r1, fp
 8023a86:	f001 fb5b 	bl	8025140 <_Bfree>
 8023a8a:	4650      	mov	r0, sl
 8023a8c:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8023a8e:	f001 fb57 	bl	8025140 <_Bfree>
 8023a92:	4650      	mov	r0, sl
 8023a94:	9907      	ldr	r1, [sp, #28]
 8023a96:	f001 fb53 	bl	8025140 <_Bfree>
 8023a9a:	e44c      	b.n	8023336 <_strtod_r+0x1f6>
 8023a9c:	9a06      	ldr	r2, [sp, #24]
 8023a9e:	9201      	str	r2, [sp, #4]
 8023aa0:	ab1a      	add	r3, sp, #104	; 0x68
 8023aa2:	9300      	str	r3, [sp, #0]
 8023aa4:	4650      	mov	r0, sl
 8023aa6:	a919      	add	r1, sp, #100	; 0x64
 8023aa8:	4a17      	ldr	r2, [pc, #92]	; (8023b08 <_strtod_r+0x9c8>)
 8023aaa:	ab1b      	add	r3, sp, #108	; 0x6c
 8023aac:	f000 fec8 	bl	8024840 <__gethex>
 8023ab0:	f010 0607 	ands.w	r6, r0, #7
 8023ab4:	4605      	mov	r5, r0
 8023ab6:	f43f ac3a 	beq.w	802332e <_strtod_r+0x1ee>
 8023aba:	2e06      	cmp	r6, #6
 8023abc:	f040 8153 	bne.w	8023d66 <_strtod_r+0xc26>
 8023ac0:	3401      	adds	r4, #1
 8023ac2:	2300      	movs	r3, #0
 8023ac4:	9419      	str	r4, [sp, #100]	; 0x64
 8023ac6:	f04f 0800 	mov.w	r8, #0
 8023aca:	f04f 0900 	mov.w	r9, #0
 8023ace:	9306      	str	r3, [sp, #24]
 8023ad0:	e431      	b.n	8023336 <_strtod_r+0x1f6>
 8023ad2:	bf00      	nop
 8023ad4:	f3af 8000 	nop.w
 8023ad8:	00000000 	.word	0x00000000
 8023adc:	3ff00000 	.word	0x3ff00000
 8023ae0:	3ff00000 	.word	0x3ff00000
 8023ae4:	3fe00000 	.word	0x3fe00000
 8023ae8:	7ca00000 	.word	0x7ca00000
 8023aec:	7fefffff 	.word	0x7fefffff
 8023af0:	bff00000 	.word	0xbff00000
 8023af4:	0802b628 	.word	0x0802b628
 8023af8:	fff80000 	.word	0xfff80000
 8023afc:	0802b61c 	.word	0x0802b61c
 8023b00:	0802b620 	.word	0x0802b620
 8023b04:	7ff00000 	.word	0x7ff00000
 8023b08:	0802b5f4 	.word	0x0802b5f4
 8023b0c:	0802b9f0 	.word	0x0802b9f0
 8023b10:	f1a8 7354 	sub.w	r3, r8, #55574528	; 0x3500000
 8023b14:	9305      	str	r3, [sp, #20]
 8023b16:	ed9d 7b04 	vldr	d7, [sp, #16]
 8023b1a:	eeb0 0a47 	vmov.f32	s0, s14
 8023b1e:	eef0 0a67 	vmov.f32	s1, s15
 8023b22:	f001 fdcb 	bl	80256bc <__ulp>
 8023b26:	4620      	mov	r0, r4
 8023b28:	ec53 2b10 	vmov	r2, r3, d0
 8023b2c:	4629      	mov	r1, r5
 8023b2e:	f7dc ff9f 	bl	8000a70 <__aeabi_dmul>
 8023b32:	4602      	mov	r2, r0
 8023b34:	460b      	mov	r3, r1
 8023b36:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8023b3a:	f7dc fde7 	bl	800070c <__adddf3>
 8023b3e:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 8023b42:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8023b46:	0d1b      	lsrs	r3, r3, #20
 8023b48:	4ab5      	ldr	r2, [pc, #724]	; (8023e20 <_strtod_r+0xce0>)
 8023b4a:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8023b4e:	051b      	lsls	r3, r3, #20
 8023b50:	4293      	cmp	r3, r2
 8023b52:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
 8023b56:	f240 80aa 	bls.w	8023cae <_strtod_r+0xb6e>
 8023b5a:	4bb2      	ldr	r3, [pc, #712]	; (8023e24 <_strtod_r+0xce4>)
 8023b5c:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8023b5e:	429a      	cmp	r2, r3
 8023b60:	f000 81ee 	beq.w	8023f40 <_strtod_r+0xe00>
 8023b64:	4baf      	ldr	r3, [pc, #700]	; (8023e24 <_strtod_r+0xce4>)
 8023b66:	9305      	str	r3, [sp, #20]
 8023b68:	f04f 33ff 	mov.w	r3, #4294967295
 8023b6c:	9304      	str	r3, [sp, #16]
 8023b6e:	e5cc      	b.n	802370a <_strtod_r+0x5ca>
 8023b70:	4bad      	ldr	r3, [pc, #692]	; (8023e28 <_strtod_r+0xce8>)
 8023b72:	9305      	str	r3, [sp, #20]
 8023b74:	2200      	movs	r2, #0
 8023b76:	2322      	movs	r3, #34	; 0x22
 8023b78:	9204      	str	r2, [sp, #16]
 8023b7a:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
 8023b7e:	f8ca 3000 	str.w	r3, [sl]
 8023b82:	f7ff bbd8 	b.w	8023336 <_strtod_r+0x1f6>
 8023b86:	e9dd 890c 	ldrd	r8, r9, [sp, #48]	; 0x30
 8023b8a:	4649      	mov	r1, r9
 8023b8c:	4640      	mov	r0, r8
 8023b8e:	f7dd fa09 	bl	8000fa4 <__aeabi_d2iz>
 8023b92:	f7dc ff07 	bl	80009a4 <__aeabi_i2d>
 8023b96:	4602      	mov	r2, r0
 8023b98:	460b      	mov	r3, r1
 8023b9a:	4640      	mov	r0, r8
 8023b9c:	4649      	mov	r1, r9
 8023b9e:	f7dc fdb3 	bl	8000708 <__aeabi_dsub>
 8023ba2:	4680      	mov	r8, r0
 8023ba4:	4689      	mov	r9, r1
 8023ba6:	b986      	cbnz	r6, 8023bca <_strtod_r+0xa8a>
 8023ba8:	9b04      	ldr	r3, [sp, #16]
 8023baa:	b973      	cbnz	r3, 8023bca <_strtod_r+0xa8a>
 8023bac:	f3c4 0413 	ubfx	r4, r4, #0, #20
 8023bb0:	b95c      	cbnz	r4, 8023bca <_strtod_r+0xa8a>
 8023bb2:	a393      	add	r3, pc, #588	; (adr r3, 8023e00 <_strtod_r+0xcc0>)
 8023bb4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8023bb8:	f7dd f9cc 	bl	8000f54 <__aeabi_dcmplt>
 8023bbc:	2800      	cmp	r0, #0
 8023bbe:	f43f ada4 	beq.w	802370a <_strtod_r+0x5ca>
 8023bc2:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
 8023bc6:	981a      	ldr	r0, [sp, #104]	; 0x68
 8023bc8:	e753      	b.n	8023a72 <_strtod_r+0x932>
 8023bca:	4640      	mov	r0, r8
 8023bcc:	4649      	mov	r1, r9
 8023bce:	a38e      	add	r3, pc, #568	; (adr r3, 8023e08 <_strtod_r+0xcc8>)
 8023bd0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8023bd4:	f7dd f9be 	bl	8000f54 <__aeabi_dcmplt>
 8023bd8:	2800      	cmp	r0, #0
 8023bda:	d1f2      	bne.n	8023bc2 <_strtod_r+0xa82>
 8023bdc:	4640      	mov	r0, r8
 8023bde:	4649      	mov	r1, r9
 8023be0:	a38b      	add	r3, pc, #556	; (adr r3, 8023e10 <_strtod_r+0xcd0>)
 8023be2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8023be6:	f7dd f9d3 	bl	8000f90 <__aeabi_dcmpgt>
 8023bea:	2800      	cmp	r0, #0
 8023bec:	f43f ad8d 	beq.w	802370a <_strtod_r+0x5ca>
 8023bf0:	e7e7      	b.n	8023bc2 <_strtod_r+0xa82>
 8023bf2:	f43f ac6d 	beq.w	80234d0 <_strtod_r+0x390>
 8023bf6:	f1c8 0700 	rsb	r7, r8, #0
 8023bfa:	f017 020f 	ands.w	r2, r7, #15
 8023bfe:	d00a      	beq.n	8023c16 <_strtod_r+0xad6>
 8023c00:	4b8a      	ldr	r3, [pc, #552]	; (8023e2c <_strtod_r+0xcec>)
 8023c02:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8023c06:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8023c0a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8023c0e:	f7dd f859 	bl	8000cc4 <__aeabi_ddiv>
 8023c12:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8023c16:	113f      	asrs	r7, r7, #4
 8023c18:	f43f ac5a 	beq.w	80234d0 <_strtod_r+0x390>
 8023c1c:	2f1f      	cmp	r7, #31
 8023c1e:	dc39      	bgt.n	8023c94 <_strtod_r+0xb54>
 8023c20:	f017 0310 	ands.w	r3, r7, #16
 8023c24:	f000 81c9 	beq.w	8023fba <_strtod_r+0xe7a>
 8023c28:	236a      	movs	r3, #106	; 0x6a
 8023c2a:	2f00      	cmp	r7, #0
 8023c2c:	bfd8      	it	le
 8023c2e:	930a      	strle	r3, [sp, #40]	; 0x28
 8023c30:	dd14      	ble.n	8023c5c <_strtod_r+0xb1c>
 8023c32:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8023c36:	4e7e      	ldr	r6, [pc, #504]	; (8023e30 <_strtod_r+0xcf0>)
 8023c38:	930a      	str	r3, [sp, #40]	; 0x28
 8023c3a:	f017 0f01 	tst.w	r7, #1
 8023c3e:	ea4f 0767 	mov.w	r7, r7, asr #1
 8023c42:	d003      	beq.n	8023c4c <_strtod_r+0xb0c>
 8023c44:	e9d6 2300 	ldrd	r2, r3, [r6]
 8023c48:	f7dc ff12 	bl	8000a70 <__aeabi_dmul>
 8023c4c:	2f00      	cmp	r7, #0
 8023c4e:	f106 0608 	add.w	r6, r6, #8
 8023c52:	dcf2      	bgt.n	8023c3a <_strtod_r+0xafa>
 8023c54:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8023c56:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8023c5a:	b193      	cbz	r3, 8023c82 <_strtod_r+0xb42>
 8023c5c:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8023c60:	f3c1 530a 	ubfx	r3, r1, #20, #11
 8023c64:	f1c3 036b 	rsb	r3, r3, #107	; 0x6b
 8023c68:	2b00      	cmp	r3, #0
 8023c6a:	dd0a      	ble.n	8023c82 <_strtod_r+0xb42>
 8023c6c:	2b1f      	cmp	r3, #31
 8023c6e:	f340 81ea 	ble.w	8024046 <_strtod_r+0xf06>
 8023c72:	2200      	movs	r2, #0
 8023c74:	2b34      	cmp	r3, #52	; 0x34
 8023c76:	9204      	str	r2, [sp, #16]
 8023c78:	f340 81ed 	ble.w	8024056 <_strtod_r+0xf16>
 8023c7c:	f04f 735c 	mov.w	r3, #57671680	; 0x3700000
 8023c80:	9305      	str	r3, [sp, #20]
 8023c82:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8023c86:	2200      	movs	r2, #0
 8023c88:	2300      	movs	r3, #0
 8023c8a:	f7dd f959 	bl	8000f40 <__aeabi_dcmpeq>
 8023c8e:	2800      	cmp	r0, #0
 8023c90:	f43f ac20 	beq.w	80234d4 <_strtod_r+0x394>
 8023c94:	2322      	movs	r3, #34	; 0x22
 8023c96:	f8ca 3000 	str.w	r3, [sl]
 8023c9a:	f04f 0800 	mov.w	r8, #0
 8023c9e:	f04f 0900 	mov.w	r9, #0
 8023ca2:	f7ff bb48 	b.w	8023336 <_strtod_r+0x1f6>
 8023ca6:	f644 631f 	movw	r3, #19999	; 0x4e1f
 8023caa:	f7ff bba6 	b.w	80233fa <_strtod_r+0x2ba>
 8023cae:	9b05      	ldr	r3, [sp, #20]
 8023cb0:	f103 7454 	add.w	r4, r3, #55574528	; 0x3500000
 8023cb4:	9405      	str	r4, [sp, #20]
 8023cb6:	e521      	b.n	80236fc <_strtod_r+0x5bc>
 8023cb8:	9a07      	ldr	r2, [sp, #28]
 8023cba:	f1c9 0325 	rsb	r3, r9, #37	; 0x25
 8023cbe:	429a      	cmp	r2, r3
 8023cc0:	f73f abec 	bgt.w	802349c <_strtod_r+0x35c>
 8023cc4:	4c59      	ldr	r4, [pc, #356]	; (8023e2c <_strtod_r+0xcec>)
 8023cc6:	f1c9 090f 	rsb	r9, r9, #15
 8023cca:	eb04 01c9 	add.w	r1, r4, r9, lsl #3
 8023cce:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8023cd2:	e9d1 0100 	ldrd	r0, r1, [r1]
 8023cd6:	f7dc fecb 	bl	8000a70 <__aeabi_dmul>
 8023cda:	9b07      	ldr	r3, [sp, #28]
 8023cdc:	ebc9 0903 	rsb	r9, r9, r3
 8023ce0:	eb04 04c9 	add.w	r4, r4, r9, lsl #3
 8023ce4:	e9d4 2300 	ldrd	r2, r3, [r4]
 8023ce8:	f7dc fec2 	bl	8000a70 <__aeabi_dmul>
 8023cec:	4680      	mov	r8, r0
 8023cee:	4689      	mov	r9, r1
 8023cf0:	f7ff bb21 	b.w	8023336 <_strtod_r+0x1f6>
 8023cf4:	ed9d 7b0c 	vldr	d7, [sp, #48]	; 0x30
 8023cf8:	ed8d 7b14 	vstr	d7, [sp, #80]	; 0x50
 8023cfc:	e663      	b.n	80239c6 <_strtod_r+0x886>
 8023cfe:	2b01      	cmp	r3, #1
 8023d00:	449c      	add	ip, r3
 8023d02:	d014      	beq.n	8023d2e <_strtod_r+0xbee>
 8023d04:	4448      	add	r0, r9
 8023d06:	e002      	b.n	8023d0e <_strtod_r+0xbce>
 8023d08:	005d      	lsls	r5, r3, #1
 8023d0a:	4581      	cmp	r9, r0
 8023d0c:	d010      	beq.n	8023d30 <_strtod_r+0xbf0>
 8023d0e:	f109 0901 	add.w	r9, r9, #1
 8023d12:	f109 33ff 	add.w	r3, r9, #4294967295
 8023d16:	2b08      	cmp	r3, #8
 8023d18:	eb05 0385 	add.w	r3, r5, r5, lsl #2
 8023d1c:	ddf4      	ble.n	8023d08 <_strtod_r+0xbc8>
 8023d1e:	f1b9 0f10 	cmp.w	r9, #16
 8023d22:	bfdc      	itt	le
 8023d24:	eb0b 0b8b 	addle.w	fp, fp, fp, lsl #2
 8023d28:	ea4f 0b4b 	movle.w	fp, fp, lsl #1
 8023d2c:	e7ed      	b.n	8023d0a <_strtod_r+0xbca>
 8023d2e:	4648      	mov	r0, r9
 8023d30:	2808      	cmp	r0, #8
 8023d32:	f100 0901 	add.w	r9, r0, #1
 8023d36:	dc7d      	bgt.n	8023e34 <_strtod_r+0xcf4>
 8023d38:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8023d3a:	f7ff bba6 	b.w	802348a <_strtod_r+0x34a>
 8023d3e:	ed9f 7b36 	vldr	d7, [pc, #216]	; 8023e18 <_strtod_r+0xcd8>
 8023d42:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
 8023d46:	e635      	b.n	80239b4 <_strtod_r+0x874>
 8023d48:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8023d4c:	4698      	mov	r8, r3
 8023d4e:	2b00      	cmp	r3, #0
 8023d50:	f47f ae15 	bne.w	802397e <_strtod_r+0x83e>
 8023d54:	2322      	movs	r3, #34	; 0x22
 8023d56:	f8ca 3000 	str.w	r3, [sl]
 8023d5a:	981a      	ldr	r0, [sp, #104]	; 0x68
 8023d5c:	f04f 0800 	mov.w	r8, #0
 8023d60:	f04f 0900 	mov.w	r9, #0
 8023d64:	e685      	b.n	8023a72 <_strtod_r+0x932>
 8023d66:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 8023d68:	b13a      	cbz	r2, 8023d7a <_strtod_r+0xc3a>
 8023d6a:	a81c      	add	r0, sp, #112	; 0x70
 8023d6c:	2135      	movs	r1, #53	; 0x35
 8023d6e:	f001 fdbd 	bl	80258ec <__copybits>
 8023d72:	4650      	mov	r0, sl
 8023d74:	991a      	ldr	r1, [sp, #104]	; 0x68
 8023d76:	f001 f9e3 	bl	8025140 <_Bfree>
 8023d7a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8023d7c:	2e06      	cmp	r6, #6
 8023d7e:	f63f ab58 	bhi.w	8023432 <_strtod_r+0x2f2>
 8023d82:	a201      	add	r2, pc, #4	; (adr r2, 8023d88 <_strtod_r+0xc48>)
 8023d84:	f852 f026 	ldr.w	pc, [r2, r6, lsl #2]
 8023d88:	08023dd5 	.word	0x08023dd5
 8023d8c:	08023dbd 	.word	0x08023dbd
 8023d90:	08023db1 	.word	0x08023db1
 8023d94:	08023da5 	.word	0x08023da5
 8023d98:	08023427 	.word	0x08023427
 8023d9c:	08023dbd 	.word	0x08023dbd
 8023da0:	08023dd5 	.word	0x08023dd5
 8023da4:	4b20      	ldr	r3, [pc, #128]	; (8023e28 <_strtod_r+0xce8>)
 8023da6:	9305      	str	r3, [sp, #20]
 8023da8:	2300      	movs	r3, #0
 8023daa:	9304      	str	r3, [sp, #16]
 8023dac:	f7ff bb41 	b.w	8023432 <_strtod_r+0x2f2>
 8023db0:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8023db2:	9304      	str	r3, [sp, #16]
 8023db4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8023db6:	9305      	str	r3, [sp, #20]
 8023db8:	f7ff bb3b 	b.w	8023432 <_strtod_r+0x2f2>
 8023dbc:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 8023dbe:	991c      	ldr	r1, [sp, #112]	; 0x70
 8023dc0:	9104      	str	r1, [sp, #16]
 8023dc2:	f203 4333 	addw	r3, r3, #1075	; 0x433
 8023dc6:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 8023dca:	ea42 5303 	orr.w	r3, r2, r3, lsl #20
 8023dce:	9305      	str	r3, [sp, #20]
 8023dd0:	f7ff bb2f 	b.w	8023432 <_strtod_r+0x2f2>
 8023dd4:	2300      	movs	r3, #0
 8023dd6:	9305      	str	r3, [sp, #20]
 8023dd8:	9304      	str	r3, [sp, #16]
 8023dda:	f7ff bb2a 	b.w	8023432 <_strtod_r+0x2f2>
 8023dde:	3316      	adds	r3, #22
 8023de0:	f6ff ab5c 	blt.w	802349c <_strtod_r+0x35c>
 8023de4:	9a07      	ldr	r2, [sp, #28]
 8023de6:	4b11      	ldr	r3, [pc, #68]	; (8023e2c <_strtod_r+0xcec>)
 8023de8:	eba3 03c2 	sub.w	r3, r3, r2, lsl #3
 8023dec:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8023df0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8023df4:	f7dc ff66 	bl	8000cc4 <__aeabi_ddiv>
 8023df8:	4680      	mov	r8, r0
 8023dfa:	4689      	mov	r9, r1
 8023dfc:	f7ff ba9b 	b.w	8023336 <_strtod_r+0x1f6>
 8023e00:	94a03595 	.word	0x94a03595
 8023e04:	3fcfffff 	.word	0x3fcfffff
 8023e08:	94a03595 	.word	0x94a03595
 8023e0c:	3fdfffff 	.word	0x3fdfffff
 8023e10:	35afe535 	.word	0x35afe535
 8023e14:	3fe00000 	.word	0x3fe00000
 8023e18:	00000000 	.word	0x00000000
 8023e1c:	3ff00000 	.word	0x3ff00000
 8023e20:	7c9fffff 	.word	0x7c9fffff
 8023e24:	7fefffff 	.word	0x7fefffff
 8023e28:	7ff00000 	.word	0x7ff00000
 8023e2c:	0802b928 	.word	0x0802b928
 8023e30:	0802b630 	.word	0x0802b630
 8023e34:	f1b9 0f10 	cmp.w	r9, #16
 8023e38:	bfd7      	itett	le
 8023e3a:	eb0b 0b8b 	addle.w	fp, fp, fp, lsl #2
 8023e3e:	9b19      	ldrgt	r3, [sp, #100]	; 0x64
 8023e40:	9b19      	ldrle	r3, [sp, #100]	; 0x64
 8023e42:	eb02 0b4b 	addle.w	fp, r2, fp, lsl #1
 8023e46:	2000      	movs	r0, #0
 8023e48:	e4e8      	b.n	802381c <_strtod_r+0x6dc>
 8023e4a:	4633      	mov	r3, r6
 8023e4c:	46c6      	mov	lr, r8
 8023e4e:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
 8023e52:	2b00      	cmp	r3, #0
 8023e54:	f000 8087 	beq.w	8023f66 <_strtod_r+0xe26>
 8023e58:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
 8023e5c:	4b86      	ldr	r3, [pc, #536]	; (8024078 <_strtod_r+0xf38>)
 8023e5e:	f3c5 0113 	ubfx	r1, r5, #0, #20
 8023e62:	4299      	cmp	r1, r3
 8023e64:	462a      	mov	r2, r5
 8023e66:	f000 80ae 	beq.w	8023fc6 <_strtod_r+0xe86>
 8023e6a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8023e6c:	2b00      	cmp	r3, #0
 8023e6e:	f000 8087 	beq.w	8023f80 <_strtod_r+0xe40>
 8023e72:	9a05      	ldr	r2, [sp, #20]
 8023e74:	4213      	tst	r3, r2
 8023e76:	d00d      	beq.n	8023e94 <_strtod_r+0xd54>
 8023e78:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8023e7c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8023e7e:	2e00      	cmp	r6, #0
 8023e80:	f000 8089 	beq.w	8023f96 <_strtod_r+0xe56>
 8023e84:	f7ff f93a 	bl	80230fc <sulp>
 8023e88:	4642      	mov	r2, r8
 8023e8a:	464b      	mov	r3, r9
 8023e8c:	f7dc fc3e 	bl	800070c <__adddf3>
 8023e90:	4680      	mov	r8, r0
 8023e92:	4689      	mov	r9, r1
 8023e94:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8023e96:	b1bb      	cbz	r3, 8023ec8 <_strtod_r+0xd88>
 8023e98:	4b78      	ldr	r3, [pc, #480]	; (802407c <_strtod_r+0xf3c>)
 8023e9a:	9313      	str	r3, [sp, #76]	; 0x4c
 8023e9c:	2300      	movs	r3, #0
 8023e9e:	9312      	str	r3, [sp, #72]	; 0x48
 8023ea0:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 8023ea4:	4640      	mov	r0, r8
 8023ea6:	4649      	mov	r1, r9
 8023ea8:	f7dc fde2 	bl	8000a70 <__aeabi_dmul>
 8023eac:	4602      	mov	r2, r0
 8023eae:	460b      	mov	r3, r1
 8023eb0:	4680      	mov	r8, r0
 8023eb2:	4689      	mov	r9, r1
 8023eb4:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8023eb8:	b931      	cbnz	r1, 8023ec8 <_strtod_r+0xd88>
 8023eba:	9b04      	ldr	r3, [sp, #16]
 8023ebc:	b923      	cbnz	r3, 8023ec8 <_strtod_r+0xd88>
 8023ebe:	2322      	movs	r3, #34	; 0x22
 8023ec0:	981a      	ldr	r0, [sp, #104]	; 0x68
 8023ec2:	f8ca 3000 	str.w	r3, [sl]
 8023ec6:	e5d4      	b.n	8023a72 <_strtod_r+0x932>
 8023ec8:	981a      	ldr	r0, [sp, #104]	; 0x68
 8023eca:	e5d2      	b.n	8023a72 <_strtod_r+0x932>
 8023ecc:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
 8023ed0:	2e00      	cmp	r6, #0
 8023ed2:	d1df      	bne.n	8023e94 <_strtod_r+0xd54>
 8023ed4:	9b04      	ldr	r3, [sp, #16]
 8023ed6:	2b00      	cmp	r3, #0
 8023ed8:	d1dc      	bne.n	8023e94 <_strtod_r+0xd54>
 8023eda:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8023ede:	f3c1 0313 	ubfx	r3, r1, #0, #20
 8023ee2:	460c      	mov	r4, r1
 8023ee4:	2b00      	cmp	r3, #0
 8023ee6:	d1d5      	bne.n	8023e94 <_strtod_r+0xd54>
 8023ee8:	9b05      	ldr	r3, [sp, #20]
 8023eea:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8023eee:	0d1b      	lsrs	r3, r3, #20
 8023ef0:	051b      	lsls	r3, r3, #20
 8023ef2:	f1b3 6fd6 	cmp.w	r3, #112197632	; 0x6b00000
 8023ef6:	d9cd      	bls.n	8023e94 <_strtod_r+0xd54>
 8023ef8:	9a07      	ldr	r2, [sp, #28]
 8023efa:	6953      	ldr	r3, [r2, #20]
 8023efc:	b913      	cbnz	r3, 8023f04 <_strtod_r+0xdc4>
 8023efe:	6913      	ldr	r3, [r2, #16]
 8023f00:	2b01      	cmp	r3, #1
 8023f02:	ddc7      	ble.n	8023e94 <_strtod_r+0xd54>
 8023f04:	9907      	ldr	r1, [sp, #28]
 8023f06:	2201      	movs	r2, #1
 8023f08:	4650      	mov	r0, sl
 8023f0a:	f001 faf3 	bl	80254f4 <__lshift>
 8023f0e:	4659      	mov	r1, fp
 8023f10:	9007      	str	r0, [sp, #28]
 8023f12:	f001 fb45 	bl	80255a0 <__mcmp>
 8023f16:	2800      	cmp	r0, #0
 8023f18:	ddbc      	ble.n	8023e94 <_strtod_r+0xd54>
 8023f1a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8023f1c:	2b00      	cmp	r3, #0
 8023f1e:	f040 8087 	bne.w	8024030 <_strtod_r+0xef0>
 8023f22:	4b57      	ldr	r3, [pc, #348]	; (8024080 <_strtod_r+0xf40>)
 8023f24:	4023      	ands	r3, r4
 8023f26:	f5a3 1380 	sub.w	r3, r3, #1048576	; 0x100000
 8023f2a:	ea6f 5313 	mvn.w	r3, r3, lsr #20
 8023f2e:	ea6f 5303 	mvn.w	r3, r3, lsl #20
 8023f32:	9305      	str	r3, [sp, #20]
 8023f34:	f04f 33ff 	mov.w	r3, #4294967295
 8023f38:	9304      	str	r3, [sp, #16]
 8023f3a:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
 8023f3e:	e7a9      	b.n	8023e94 <_strtod_r+0xd54>
 8023f40:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8023f42:	3301      	adds	r3, #1
 8023f44:	f47f ae0e 	bne.w	8023b64 <_strtod_r+0xa24>
 8023f48:	e589      	b.n	8023a5e <_strtod_r+0x91e>
 8023f4a:	ed9f 7b47 	vldr	d7, [pc, #284]	; 8024068 <_strtod_r+0xf28>
 8023f4e:	ed8d 7b16 	vstr	d7, [sp, #88]	; 0x58
 8023f52:	ed9f 7b47 	vldr	d7, [pc, #284]	; 8024070 <_strtod_r+0xf30>
 8023f56:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
 8023f5a:	e44e      	b.n	80237fa <_strtod_r+0x6ba>
 8023f5c:	f101 7354 	add.w	r3, r1, #55574528	; 0x3500000
 8023f60:	9305      	str	r3, [sp, #20]
 8023f62:	f7ff bab5 	b.w	80234d0 <_strtod_r+0x390>
 8023f66:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8023f6a:	f3c1 0313 	ubfx	r3, r1, #0, #20
 8023f6e:	460c      	mov	r4, r1
 8023f70:	2b00      	cmp	r3, #0
 8023f72:	f47f af7a 	bne.w	8023e6a <_strtod_r+0xd2a>
 8023f76:	9b04      	ldr	r3, [sp, #16]
 8023f78:	2b00      	cmp	r3, #0
 8023f7a:	f47f af76 	bne.w	8023e6a <_strtod_r+0xd2a>
 8023f7e:	e7cc      	b.n	8023f1a <_strtod_r+0xdda>
 8023f80:	9a04      	ldr	r2, [sp, #16]
 8023f82:	ea1e 0f02 	tst.w	lr, r2
 8023f86:	d085      	beq.n	8023e94 <_strtod_r+0xd54>
 8023f88:	e776      	b.n	8023e78 <_strtod_r+0xd38>
 8023f8a:	1c6b      	adds	r3, r5, #1
 8023f8c:	9319      	str	r3, [sp, #100]	; 0x64
 8023f8e:	e55e      	b.n	8023a4e <_strtod_r+0x90e>
 8023f90:	f04f 0b00 	mov.w	fp, #0
 8023f94:	e4cc      	b.n	8023930 <_strtod_r+0x7f0>
 8023f96:	f7ff f8b1 	bl	80230fc <sulp>
 8023f9a:	4602      	mov	r2, r0
 8023f9c:	460b      	mov	r3, r1
 8023f9e:	4640      	mov	r0, r8
 8023fa0:	4649      	mov	r1, r9
 8023fa2:	f7dc fbb1 	bl	8000708 <__aeabi_dsub>
 8023fa6:	2200      	movs	r2, #0
 8023fa8:	2300      	movs	r3, #0
 8023faa:	4680      	mov	r8, r0
 8023fac:	4689      	mov	r9, r1
 8023fae:	f7dc ffc7 	bl	8000f40 <__aeabi_dcmpeq>
 8023fb2:	2800      	cmp	r0, #0
 8023fb4:	f47f aece 	bne.w	8023d54 <_strtod_r+0xc14>
 8023fb8:	e76c      	b.n	8023e94 <_strtod_r+0xd54>
 8023fba:	2f00      	cmp	r7, #0
 8023fbc:	bfd8      	it	le
 8023fbe:	930a      	strle	r3, [sp, #40]	; 0x28
 8023fc0:	f73f ae37 	bgt.w	8023c32 <_strtod_r+0xaf2>
 8023fc4:	e65d      	b.n	8023c82 <_strtod_r+0xb42>
 8023fc6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8023fc8:	9904      	ldr	r1, [sp, #16]
 8023fca:	b1e3      	cbz	r3, 8024006 <_strtod_r+0xec6>
 8023fcc:	4b2c      	ldr	r3, [pc, #176]	; (8024080 <_strtod_r+0xf40>)
 8023fce:	402b      	ands	r3, r5
 8023fd0:	f1b3 6fd4 	cmp.w	r3, #111149056	; 0x6a00000
 8023fd4:	d817      	bhi.n	8024006 <_strtod_r+0xec6>
 8023fd6:	0d1b      	lsrs	r3, r3, #20
 8023fd8:	f1c3 036b 	rsb	r3, r3, #107	; 0x6b
 8023fdc:	f04f 30ff 	mov.w	r0, #4294967295
 8023fe0:	fa00 f303 	lsl.w	r3, r0, r3
 8023fe4:	4299      	cmp	r1, r3
 8023fe6:	f47f af40 	bne.w	8023e6a <_strtod_r+0xd2a>
 8023fea:	4b26      	ldr	r3, [pc, #152]	; (8024084 <_strtod_r+0xf44>)
 8023fec:	429a      	cmp	r2, r3
 8023fee:	f43f ad33 	beq.w	8023a58 <_strtod_r+0x918>
 8023ff2:	4b23      	ldr	r3, [pc, #140]	; (8024080 <_strtod_r+0xf40>)
 8023ff4:	4013      	ands	r3, r2
 8023ff6:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
 8023ffa:	9305      	str	r3, [sp, #20]
 8023ffc:	2300      	movs	r3, #0
 8023ffe:	9304      	str	r3, [sp, #16]
 8024000:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
 8024004:	e746      	b.n	8023e94 <_strtod_r+0xd54>
 8024006:	f04f 33ff 	mov.w	r3, #4294967295
 802400a:	e7eb      	b.n	8023fe4 <_strtod_r+0xea4>
 802400c:	a819      	add	r0, sp, #100	; 0x64
 802400e:	491e      	ldr	r1, [pc, #120]	; (8024088 <_strtod_r+0xf48>)
 8024010:	aa1c      	add	r2, sp, #112	; 0x70
 8024012:	f000 fe9f 	bl	8024d54 <__hexnan>
 8024016:	2805      	cmp	r0, #5
 8024018:	f47f acef 	bne.w	80239fa <_strtod_r+0x8ba>
 802401c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 802401e:	f043 43ff 	orr.w	r3, r3, #2139095040	; 0x7f800000
 8024022:	f443 03e0 	orr.w	r3, r3, #7340032	; 0x700000
 8024026:	9305      	str	r3, [sp, #20]
 8024028:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 802402a:	9304      	str	r3, [sp, #16]
 802402c:	f7ff ba07 	b.w	802343e <_strtod_r+0x2fe>
 8024030:	4b13      	ldr	r3, [pc, #76]	; (8024080 <_strtod_r+0xf40>)
 8024032:	4023      	ands	r3, r4
 8024034:	f1b3 6fd6 	cmp.w	r3, #112197632	; 0x6b00000
 8024038:	f73f af75 	bgt.w	8023f26 <_strtod_r+0xde6>
 802403c:	f1b3 7f5c 	cmp.w	r3, #57671680	; 0x3700000
 8024040:	f73f af2a 	bgt.w	8023e98 <_strtod_r+0xd58>
 8024044:	e686      	b.n	8023d54 <_strtod_r+0xc14>
 8024046:	f04f 32ff 	mov.w	r2, #4294967295
 802404a:	fa02 f303 	lsl.w	r3, r2, r3
 802404e:	9a04      	ldr	r2, [sp, #16]
 8024050:	401a      	ands	r2, r3
 8024052:	9204      	str	r2, [sp, #16]
 8024054:	e615      	b.n	8023c82 <_strtod_r+0xb42>
 8024056:	3b20      	subs	r3, #32
 8024058:	f04f 32ff 	mov.w	r2, #4294967295
 802405c:	fa02 f303 	lsl.w	r3, r2, r3
 8024060:	400b      	ands	r3, r1
 8024062:	9305      	str	r3, [sp, #20]
 8024064:	e60d      	b.n	8023c82 <_strtod_r+0xb42>
 8024066:	bf00      	nop
 8024068:	00000000 	.word	0x00000000
 802406c:	bfe00000 	.word	0xbfe00000
 8024070:	00000000 	.word	0x00000000
 8024074:	3fe00000 	.word	0x3fe00000
 8024078:	000fffff 	.word	0x000fffff
 802407c:	39500000 	.word	0x39500000
 8024080:	7ff00000 	.word	0x7ff00000
 8024084:	7fefffff 	.word	0x7fefffff
 8024088:	0802b608 	.word	0x0802b608
 802408c:	f3af 8000 	nop.w

08024090 <strtod>:
 8024090:	4b02      	ldr	r3, [pc, #8]	; (802409c <strtod+0xc>)
 8024092:	460a      	mov	r2, r1
 8024094:	4601      	mov	r1, r0
 8024096:	6818      	ldr	r0, [r3, #0]
 8024098:	f7ff b852 	b.w	8023140 <_strtod_r>
 802409c:	20010588 	.word	0x20010588

080240a0 <_strtol_r>:
 80240a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80240a4:	4c44      	ldr	r4, [pc, #272]	; (80241b8 <_strtol_r+0x118>)
 80240a6:	4683      	mov	fp, r0
 80240a8:	460e      	mov	r6, r1
 80240aa:	f8d4 e000 	ldr.w	lr, [r4]
 80240ae:	e000      	b.n	80240b2 <_strtol_r+0x12>
 80240b0:	4626      	mov	r6, r4
 80240b2:	4634      	mov	r4, r6
 80240b4:	f814 5b01 	ldrb.w	r5, [r4], #1
 80240b8:	eb0e 0005 	add.w	r0, lr, r5
 80240bc:	7840      	ldrb	r0, [r0, #1]
 80240be:	f000 0008 	and.w	r0, r0, #8
 80240c2:	f000 08ff 	and.w	r8, r0, #255	; 0xff
 80240c6:	2800      	cmp	r0, #0
 80240c8:	d1f2      	bne.n	80240b0 <_strtol_r+0x10>
 80240ca:	2d2d      	cmp	r5, #45	; 0x2d
 80240cc:	d04b      	beq.n	8024166 <_strtol_r+0xc6>
 80240ce:	2d2b      	cmp	r5, #43	; 0x2b
 80240d0:	bf04      	itt	eq
 80240d2:	7875      	ldrbeq	r5, [r6, #1]
 80240d4:	1cb4      	addeq	r4, r6, #2
 80240d6:	b11b      	cbz	r3, 80240e0 <_strtol_r+0x40>
 80240d8:	2b10      	cmp	r3, #16
 80240da:	d060      	beq.n	802419e <_strtol_r+0xfe>
 80240dc:	469a      	mov	sl, r3
 80240de:	e003      	b.n	80240e8 <_strtol_r+0x48>
 80240e0:	2d30      	cmp	r5, #48	; 0x30
 80240e2:	d054      	beq.n	802418e <_strtol_r+0xee>
 80240e4:	230a      	movs	r3, #10
 80240e6:	469a      	mov	sl, r3
 80240e8:	f1b8 0f00 	cmp.w	r8, #0
 80240ec:	bf14      	ite	ne
 80240ee:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 80240f2:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80240f6:	2700      	movs	r7, #0
 80240f8:	fbb0 f9fa 	udiv	r9, r0, sl
 80240fc:	46bc      	mov	ip, r7
 80240fe:	fb0a 0019 	mls	r0, sl, r9, r0
 8024102:	e00c      	b.n	802411e <_strtol_r+0x7e>
 8024104:	3d30      	subs	r5, #48	; 0x30
 8024106:	42ab      	cmp	r3, r5
 8024108:	dd19      	ble.n	802413e <_strtol_r+0x9e>
 802410a:	1c7e      	adds	r6, r7, #1
 802410c:	d005      	beq.n	802411a <_strtol_r+0x7a>
 802410e:	45cc      	cmp	ip, r9
 8024110:	d824      	bhi.n	802415c <_strtol_r+0xbc>
 8024112:	d021      	beq.n	8024158 <_strtol_r+0xb8>
 8024114:	fb0a 5c0c 	mla	ip, sl, ip, r5
 8024118:	2701      	movs	r7, #1
 802411a:	f814 5b01 	ldrb.w	r5, [r4], #1
 802411e:	eb0e 0605 	add.w	r6, lr, r5
 8024122:	7876      	ldrb	r6, [r6, #1]
 8024124:	f016 0f04 	tst.w	r6, #4
 8024128:	d1ec      	bne.n	8024104 <_strtol_r+0x64>
 802412a:	f016 0603 	ands.w	r6, r6, #3
 802412e:	d006      	beq.n	802413e <_strtol_r+0x9e>
 8024130:	2e01      	cmp	r6, #1
 8024132:	bf0c      	ite	eq
 8024134:	2637      	moveq	r6, #55	; 0x37
 8024136:	2657      	movne	r6, #87	; 0x57
 8024138:	1bad      	subs	r5, r5, r6
 802413a:	42ab      	cmp	r3, r5
 802413c:	dce5      	bgt.n	802410a <_strtol_r+0x6a>
 802413e:	1c7b      	adds	r3, r7, #1
 8024140:	d016      	beq.n	8024170 <_strtol_r+0xd0>
 8024142:	f1c8 0000 	rsb	r0, r8, #0
 8024146:	ea8c 0000 	eor.w	r0, ip, r0
 802414a:	4440      	add	r0, r8
 802414c:	b14a      	cbz	r2, 8024162 <_strtol_r+0xc2>
 802414e:	b107      	cbz	r7, 8024152 <_strtol_r+0xb2>
 8024150:	1e61      	subs	r1, r4, #1
 8024152:	6011      	str	r1, [r2, #0]
 8024154:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024158:	4285      	cmp	r5, r0
 802415a:	dddb      	ble.n	8024114 <_strtol_r+0x74>
 802415c:	f04f 37ff 	mov.w	r7, #4294967295
 8024160:	e7db      	b.n	802411a <_strtol_r+0x7a>
 8024162:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024166:	1cb4      	adds	r4, r6, #2
 8024168:	7875      	ldrb	r5, [r6, #1]
 802416a:	f04f 0801 	mov.w	r8, #1
 802416e:	e7b2      	b.n	80240d6 <_strtol_r+0x36>
 8024170:	f1b8 0f00 	cmp.w	r8, #0
 8024174:	f04f 0322 	mov.w	r3, #34	; 0x22
 8024178:	bf14      	ite	ne
 802417a:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 802417e:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8024182:	f8cb 3000 	str.w	r3, [fp]
 8024186:	2a00      	cmp	r2, #0
 8024188:	d1e2      	bne.n	8024150 <_strtol_r+0xb0>
 802418a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802418e:	7823      	ldrb	r3, [r4, #0]
 8024190:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8024194:	2b58      	cmp	r3, #88	; 0x58
 8024196:	d009      	beq.n	80241ac <_strtol_r+0x10c>
 8024198:	2308      	movs	r3, #8
 802419a:	469a      	mov	sl, r3
 802419c:	e7a4      	b.n	80240e8 <_strtol_r+0x48>
 802419e:	2d30      	cmp	r5, #48	; 0x30
 80241a0:	d19c      	bne.n	80240dc <_strtol_r+0x3c>
 80241a2:	7820      	ldrb	r0, [r4, #0]
 80241a4:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 80241a8:	2858      	cmp	r0, #88	; 0x58
 80241aa:	d197      	bne.n	80240dc <_strtol_r+0x3c>
 80241ac:	f04f 0a10 	mov.w	sl, #16
 80241b0:	7865      	ldrb	r5, [r4, #1]
 80241b2:	4653      	mov	r3, sl
 80241b4:	3402      	adds	r4, #2
 80241b6:	e797      	b.n	80240e8 <_strtol_r+0x48>
 80241b8:	20010114 	.word	0x20010114

080241bc <strtol>:
 80241bc:	b430      	push	{r4, r5}
 80241be:	4c04      	ldr	r4, [pc, #16]	; (80241d0 <strtol+0x14>)
 80241c0:	460d      	mov	r5, r1
 80241c2:	4613      	mov	r3, r2
 80241c4:	4601      	mov	r1, r0
 80241c6:	462a      	mov	r2, r5
 80241c8:	6820      	ldr	r0, [r4, #0]
 80241ca:	bc30      	pop	{r4, r5}
 80241cc:	f7ff bf68 	b.w	80240a0 <_strtol_r>
 80241d0:	20010588 	.word	0x20010588

080241d4 <__tzcalc_limits>:
 80241d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80241d8:	b083      	sub	sp, #12
 80241da:	4604      	mov	r4, r0
 80241dc:	f000 fec8 	bl	8024f70 <__gettzinfo>
 80241e0:	f240 73b1 	movw	r3, #1969	; 0x7b1
 80241e4:	429c      	cmp	r4, r3
 80241e6:	f340 8097 	ble.w	8024318 <__tzcalc_limits+0x144>
 80241ea:	4959      	ldr	r1, [pc, #356]	; (8024350 <__tzcalc_limits+0x17c>)
 80241ec:	f8df c16c 	ldr.w	ip, [pc, #364]	; 802435c <__tzcalc_limits+0x188>
 80241f0:	6044      	str	r4, [r0, #4]
 80241f2:	f2a4 736d 	subw	r3, r4, #1901	; 0x76d
 80241f6:	f46f 62f6 	mvn.w	r2, #1968	; 0x7b0
 80241fa:	eb04 0902 	add.w	r9, r4, r2
 80241fe:	fb81 2503 	smull	r2, r5, r1, r3
 8024202:	17db      	asrs	r3, r3, #31
 8024204:	eba3 1365 	sub.w	r3, r3, r5, asr #5
 8024208:	f46f 65c8 	mvn.w	r5, #1600	; 0x640
 802420c:	f2a4 72b2 	subw	r2, r4, #1970	; 0x7b2
 8024210:	1965      	adds	r5, r4, r5
 8024212:	ea4f 06a9 	mov.w	r6, r9, asr #2
 8024216:	f240 196d 	movw	r9, #365	; 0x16d
 802421a:	fb81 7e04 	smull	r7, lr, r1, r4
 802421e:	fb09 6902 	mla	r9, r9, r2, r6
 8024222:	fb81 2105 	smull	r2, r1, r1, r5
 8024226:	17ea      	asrs	r2, r5, #31
 8024228:	17e7      	asrs	r7, r4, #31
 802422a:	444b      	add	r3, r9
 802422c:	ebc2 15e1 	rsb	r5, r2, r1, asr #7
 8024230:	ebc7 16ee 	rsb	r6, r7, lr, asr #7
 8024234:	f44f 78c8 	mov.w	r8, #400	; 0x190
 8024238:	ebc7 176e 	rsb	r7, r7, lr, asr #5
 802423c:	441d      	add	r5, r3
 802423e:	f04f 0e64 	mov.w	lr, #100	; 0x64
 8024242:	f004 0303 	and.w	r3, r4, #3
 8024246:	fb08 4616 	mls	r6, r8, r6, r4
 802424a:	fb0e 4717 	mls	r7, lr, r7, r4
 802424e:	fab6 f686 	clz	r6, r6
 8024252:	4604      	mov	r4, r0
 8024254:	0976      	lsrs	r6, r6, #5
 8024256:	f100 0e38 	add.w	lr, r0, #56	; 0x38
 802425a:	469b      	mov	fp, r3
 802425c:	7a23      	ldrb	r3, [r4, #8]
 802425e:	2b4a      	cmp	r3, #74	; 0x4a
 8024260:	d05e      	beq.n	8024320 <__tzcalc_limits+0x14c>
 8024262:	2b44      	cmp	r3, #68	; 0x44
 8024264:	d06d      	beq.n	8024342 <__tzcalc_limits+0x16e>
 8024266:	f1bb 0f00 	cmp.w	fp, #0
 802426a:	d050      	beq.n	802430e <__tzcalc_limits+0x13a>
 802426c:	4633      	mov	r3, r6
 802426e:	0059      	lsls	r1, r3, #1
 8024270:	68e2      	ldr	r2, [r4, #12]
 8024272:	4419      	add	r1, r3
 8024274:	4b37      	ldr	r3, [pc, #220]	; (8024354 <__tzcalc_limits+0x180>)
 8024276:	2a01      	cmp	r2, #1
 8024278:	eb03 1101 	add.w	r1, r3, r1, lsl #4
 802427c:	dd64      	ble.n	8024348 <__tzcalc_limits+0x174>
 802427e:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 8024282:	3a02      	subs	r2, #2
 8024284:	ea4f 0a82 	mov.w	sl, r2, lsl #2
 8024288:	eb01 090a 	add.w	r9, r1, sl
 802428c:	f1a1 0804 	sub.w	r8, r1, #4
 8024290:	462b      	mov	r3, r5
 8024292:	f858 2f04 	ldr.w	r2, [r8, #4]!
 8024296:	45c8      	cmp	r8, r9
 8024298:	4413      	add	r3, r2
 802429a:	d1fa      	bne.n	8024292 <__tzcalc_limits+0xbe>
 802429c:	f10a 0204 	add.w	r2, sl, #4
 80242a0:	9201      	str	r2, [sp, #4]
 80242a2:	4a2d      	ldr	r2, [pc, #180]	; (8024358 <__tzcalc_limits+0x184>)
 80242a4:	f103 0a04 	add.w	sl, r3, #4
 80242a8:	fb8a 8902 	smull	r8, r9, sl, r2
 80242ac:	44d1      	add	r9, sl
 80242ae:	ea4f 78ea 	mov.w	r8, sl, asr #31
 80242b2:	ebc8 08a9 	rsb	r8, r8, r9, asr #2
 80242b6:	6962      	ldr	r2, [r4, #20]
 80242b8:	ebc8 08c8 	rsb	r8, r8, r8, lsl #3
 80242bc:	ebc8 0a0a 	rsb	sl, r8, sl
 80242c0:	ebb2 0a0a 	subs.w	sl, r2, sl
 80242c4:	9a01      	ldr	r2, [sp, #4]
 80242c6:	588a      	ldr	r2, [r1, r2]
 80242c8:	6921      	ldr	r1, [r4, #16]
 80242ca:	f101 31ff 	add.w	r1, r1, #4294967295
 80242ce:	bf48      	it	mi
 80242d0:	f10a 0a07 	addmi.w	sl, sl, #7
 80242d4:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 80242d8:	4451      	add	r1, sl
 80242da:	4291      	cmp	r1, r2
 80242dc:	db02      	blt.n	80242e4 <__tzcalc_limits+0x110>
 80242de:	3907      	subs	r1, #7
 80242e0:	4291      	cmp	r1, r2
 80242e2:	dafc      	bge.n	80242de <__tzcalc_limits+0x10a>
 80242e4:	440b      	add	r3, r1
 80242e6:	69a1      	ldr	r1, [r4, #24]
 80242e8:	6a22      	ldr	r2, [r4, #32]
 80242ea:	fb0c 1103 	mla	r1, ip, r3, r1
 80242ee:	4411      	add	r1, r2
 80242f0:	f844 1f1c 	str.w	r1, [r4, #28]!
 80242f4:	4574      	cmp	r4, lr
 80242f6:	d1b1      	bne.n	802425c <__tzcalc_limits+0x88>
 80242f8:	69c3      	ldr	r3, [r0, #28]
 80242fa:	6b82      	ldr	r2, [r0, #56]	; 0x38
 80242fc:	4293      	cmp	r3, r2
 80242fe:	bfac      	ite	ge
 8024300:	2300      	movge	r3, #0
 8024302:	2301      	movlt	r3, #1
 8024304:	6003      	str	r3, [r0, #0]
 8024306:	2001      	movs	r0, #1
 8024308:	b003      	add	sp, #12
 802430a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802430e:	2f00      	cmp	r7, #0
 8024310:	bf0c      	ite	eq
 8024312:	4633      	moveq	r3, r6
 8024314:	2301      	movne	r3, #1
 8024316:	e7aa      	b.n	802426e <__tzcalc_limits+0x9a>
 8024318:	2000      	movs	r0, #0
 802431a:	b003      	add	sp, #12
 802431c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024320:	6962      	ldr	r2, [r4, #20]
 8024322:	1951      	adds	r1, r2, r5
 8024324:	f1bb 0f00 	cmp.w	fp, #0
 8024328:	d107      	bne.n	802433a <__tzcalc_limits+0x166>
 802432a:	b137      	cbz	r7, 802433a <__tzcalc_limits+0x166>
 802432c:	2a3b      	cmp	r2, #59	; 0x3b
 802432e:	bfd4      	ite	le
 8024330:	2200      	movle	r2, #0
 8024332:	2201      	movgt	r2, #1
 8024334:	4411      	add	r1, r2
 8024336:	1e4b      	subs	r3, r1, #1
 8024338:	e7d5      	b.n	80242e6 <__tzcalc_limits+0x112>
 802433a:	2e00      	cmp	r6, #0
 802433c:	d1f6      	bne.n	802432c <__tzcalc_limits+0x158>
 802433e:	4632      	mov	r2, r6
 8024340:	e7f8      	b.n	8024334 <__tzcalc_limits+0x160>
 8024342:	6961      	ldr	r1, [r4, #20]
 8024344:	186b      	adds	r3, r5, r1
 8024346:	e7ce      	b.n	80242e6 <__tzcalc_limits+0x112>
 8024348:	2200      	movs	r2, #0
 802434a:	462b      	mov	r3, r5
 802434c:	9201      	str	r2, [sp, #4]
 802434e:	e7a8      	b.n	80242a2 <__tzcalc_limits+0xce>
 8024350:	51eb851f 	.word	0x51eb851f
 8024354:	0802b58c 	.word	0x0802b58c
 8024358:	92492493 	.word	0x92492493
 802435c:	00015180 	.word	0x00015180

08024360 <__tz_lock>:
 8024360:	4770      	bx	lr
 8024362:	bf00      	nop

08024364 <__tz_unlock>:
 8024364:	4770      	bx	lr
 8024366:	bf00      	nop

08024368 <tzset>:
 8024368:	4b01      	ldr	r3, [pc, #4]	; (8024370 <tzset+0x8>)
 802436a:	6818      	ldr	r0, [r3, #0]
 802436c:	f000 b802 	b.w	8024374 <_tzset_r>
 8024370:	20010588 	.word	0x20010588

08024374 <_tzset_r>:
 8024374:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024378:	b08d      	sub	sp, #52	; 0x34
 802437a:	4606      	mov	r6, r0
 802437c:	f000 fdf8 	bl	8024f70 <__gettzinfo>
 8024380:	49c7      	ldr	r1, [pc, #796]	; (80246a0 <_tzset_r+0x32c>)
 8024382:	4dc8      	ldr	r5, [pc, #800]	; (80246a4 <_tzset_r+0x330>)
 8024384:	4682      	mov	sl, r0
 8024386:	4630      	mov	r0, r6
 8024388:	f000 fdea 	bl	8024f60 <_getenv_r>
 802438c:	4604      	mov	r4, r0
 802438e:	2800      	cmp	r0, #0
 8024390:	f000 8102 	beq.w	8024598 <_tzset_r+0x224>
 8024394:	f7ff ffe4 	bl	8024360 <__tz_lock>
 8024398:	6829      	ldr	r1, [r5, #0]
 802439a:	b131      	cbz	r1, 80243aa <_tzset_r+0x36>
 802439c:	4620      	mov	r0, r4
 802439e:	f7dc f843 	bl	8000428 <strcmp>
 80243a2:	2800      	cmp	r0, #0
 80243a4:	f000 80ec 	beq.w	8024580 <_tzset_r+0x20c>
 80243a8:	6829      	ldr	r1, [r5, #0]
 80243aa:	4608      	mov	r0, r1
 80243ac:	f7fe f95e 	bl	802266c <free>
 80243b0:	4620      	mov	r0, r4
 80243b2:	f7fe fdf5 	bl	8022fa0 <strlen>
 80243b6:	1c41      	adds	r1, r0, #1
 80243b8:	4630      	mov	r0, r6
 80243ba:	f7f4 ff8d 	bl	80192d8 <_malloc_r>
 80243be:	6028      	str	r0, [r5, #0]
 80243c0:	b110      	cbz	r0, 80243c8 <_tzset_r+0x54>
 80243c2:	4621      	mov	r1, r4
 80243c4:	f001 fb3a 	bl	8025a3c <strcpy>
 80243c8:	7823      	ldrb	r3, [r4, #0]
 80243ca:	49b7      	ldr	r1, [pc, #732]	; (80246a8 <_tzset_r+0x334>)
 80243cc:	4ab7      	ldr	r2, [pc, #732]	; (80246ac <_tzset_r+0x338>)
 80243ce:	2b3a      	cmp	r3, #58	; 0x3a
 80243d0:	bf08      	it	eq
 80243d2:	3401      	addeq	r4, #1
 80243d4:	ad0a      	add	r5, sp, #40	; 0x28
 80243d6:	462b      	mov	r3, r5
 80243d8:	4620      	mov	r0, r4
 80243da:	f001 fb01 	bl	80259e0 <siscanf>
 80243de:	2800      	cmp	r0, #0
 80243e0:	f340 80ce 	ble.w	8024580 <_tzset_r+0x20c>
 80243e4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80243e6:	5ce2      	ldrb	r2, [r4, r3]
 80243e8:	2a2d      	cmp	r2, #45	; 0x2d
 80243ea:	441c      	add	r4, r3
 80243ec:	f000 80d0 	beq.w	8024590 <_tzset_r+0x21c>
 80243f0:	2a2b      	cmp	r2, #43	; 0x2b
 80243f2:	bf08      	it	eq
 80243f4:	3401      	addeq	r4, #1
 80243f6:	f04f 0801 	mov.w	r8, #1
 80243fa:	f10d 061e 	add.w	r6, sp, #30
 80243fe:	af08      	add	r7, sp, #32
 8024400:	f04f 0900 	mov.w	r9, #0
 8024404:	9501      	str	r5, [sp, #4]
 8024406:	9503      	str	r5, [sp, #12]
 8024408:	aa07      	add	r2, sp, #28
 802440a:	9600      	str	r6, [sp, #0]
 802440c:	9702      	str	r7, [sp, #8]
 802440e:	4620      	mov	r0, r4
 8024410:	49a7      	ldr	r1, [pc, #668]	; (80246b0 <_tzset_r+0x33c>)
 8024412:	f8ad 901e 	strh.w	r9, [sp, #30]
 8024416:	462b      	mov	r3, r5
 8024418:	f8ad 9020 	strh.w	r9, [sp, #32]
 802441c:	f001 fae0 	bl	80259e0 <siscanf>
 8024420:	4548      	cmp	r0, r9
 8024422:	f340 80ad 	ble.w	8024580 <_tzset_r+0x20c>
 8024426:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 802442a:	f8bd 1020 	ldrh.w	r1, [sp, #32]
 802442e:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 8024432:	980a      	ldr	r0, [sp, #40]	; 0x28
 8024434:	f8df c294 	ldr.w	ip, [pc, #660]	; 80246cc <_tzset_r+0x358>
 8024438:	f8df b280 	ldr.w	fp, [pc, #640]	; 80246bc <_tzset_r+0x348>
 802443c:	f8cd c014 	str.w	ip, [sp, #20]
 8024440:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 8024444:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8024448:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 802444c:	fb01 3302 	mla	r3, r1, r2, r3
 8024450:	fb08 f303 	mul.w	r3, r8, r3
 8024454:	f8ca 3020 	str.w	r3, [sl, #32]
 8024458:	4404      	add	r4, r0
 802445a:	4b94      	ldr	r3, [pc, #592]	; (80246ac <_tzset_r+0x338>)
 802445c:	f8cb 3000 	str.w	r3, [fp]
 8024460:	4662      	mov	r2, ip
 8024462:	4620      	mov	r0, r4
 8024464:	4990      	ldr	r1, [pc, #576]	; (80246a8 <_tzset_r+0x334>)
 8024466:	462b      	mov	r3, r5
 8024468:	f001 faba 	bl	80259e0 <siscanf>
 802446c:	4548      	cmp	r0, r9
 802446e:	f8dd c014 	ldr.w	ip, [sp, #20]
 8024472:	f340 8107 	ble.w	8024684 <_tzset_r+0x310>
 8024476:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8024478:	f8cb c004 	str.w	ip, [fp, #4]
 802447c:	5ce2      	ldrb	r2, [r4, r3]
 802447e:	2a2d      	cmp	r2, #45	; 0x2d
 8024480:	441c      	add	r4, r3
 8024482:	f000 809c 	beq.w	80245be <_tzset_r+0x24a>
 8024486:	2a2b      	cmp	r2, #43	; 0x2b
 8024488:	bf08      	it	eq
 802448a:	3401      	addeq	r4, #1
 802448c:	f04f 0801 	mov.w	r8, #1
 8024490:	f04f 0e00 	mov.w	lr, #0
 8024494:	9600      	str	r6, [sp, #0]
 8024496:	9501      	str	r5, [sp, #4]
 8024498:	9702      	str	r7, [sp, #8]
 802449a:	9503      	str	r5, [sp, #12]
 802449c:	4620      	mov	r0, r4
 802449e:	4984      	ldr	r1, [pc, #528]	; (80246b0 <_tzset_r+0x33c>)
 80244a0:	f8ad e01c 	strh.w	lr, [sp, #28]
 80244a4:	aa07      	add	r2, sp, #28
 80244a6:	462b      	mov	r3, r5
 80244a8:	f8ad e01e 	strh.w	lr, [sp, #30]
 80244ac:	f8ad e020 	strh.w	lr, [sp, #32]
 80244b0:	f8cd e028 	str.w	lr, [sp, #40]	; 0x28
 80244b4:	f001 fa94 	bl	80259e0 <siscanf>
 80244b8:	2800      	cmp	r0, #0
 80244ba:	f340 8084 	ble.w	80245c6 <_tzset_r+0x252>
 80244be:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 80244c2:	f8bd 1020 	ldrh.w	r1, [sp, #32]
 80244c6:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 80244ca:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 80244ce:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 80244d2:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 80244d6:	fb01 3302 	mla	r3, r1, r2, r3
 80244da:	fb08 f303 	mul.w	r3, r8, r3
 80244de:	f8ca 303c 	str.w	r3, [sl, #60]	; 0x3c
 80244e2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80244e4:	46d1      	mov	r9, sl
 80244e6:	441c      	add	r4, r3
 80244e8:	f04f 0b00 	mov.w	fp, #0
 80244ec:	f894 8000 	ldrb.w	r8, [r4]
 80244f0:	f1b8 0f2c 	cmp.w	r8, #44	; 0x2c
 80244f4:	bf04      	itt	eq
 80244f6:	f894 8001 	ldrbeq.w	r8, [r4, #1]
 80244fa:	3401      	addeq	r4, #1
 80244fc:	f1b8 0f4d 	cmp.w	r8, #77	; 0x4d
 8024500:	d068      	beq.n	80245d4 <_tzset_r+0x260>
 8024502:	f1b8 0f4a 	cmp.w	r8, #74	; 0x4a
 8024506:	bf08      	it	eq
 8024508:	3401      	addeq	r4, #1
 802450a:	4620      	mov	r0, r4
 802450c:	a90b      	add	r1, sp, #44	; 0x2c
 802450e:	f04f 020a 	mov.w	r2, #10
 8024512:	bf18      	it	ne
 8024514:	f04f 0844 	movne.w	r8, #68	; 0x44
 8024518:	f001 fb82 	bl	8025c20 <strtoul>
 802451c:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
 8024520:	f8ad 0026 	strh.w	r0, [sp, #38]	; 0x26
 8024524:	45a4      	cmp	ip, r4
 8024526:	f000 809d 	beq.w	8024664 <_tzset_r+0x2f0>
 802452a:	b280      	uxth	r0, r0
 802452c:	f8c9 0014 	str.w	r0, [r9, #20]
 8024530:	f889 8008 	strb.w	r8, [r9, #8]
 8024534:	2400      	movs	r4, #0
 8024536:	2302      	movs	r3, #2
 8024538:	f8ad 301c 	strh.w	r3, [sp, #28]
 802453c:	f8ad 401e 	strh.w	r4, [sp, #30]
 8024540:	f8ad 4020 	strh.w	r4, [sp, #32]
 8024544:	940a      	str	r4, [sp, #40]	; 0x28
 8024546:	f89c 3000 	ldrb.w	r3, [ip]
 802454a:	2b2f      	cmp	r3, #47	; 0x2f
 802454c:	d06c      	beq.n	8024628 <_tzset_r+0x2b4>
 802454e:	f44f 53e1 	mov.w	r3, #7200	; 0x1c20
 8024552:	f8c9 3018 	str.w	r3, [r9, #24]
 8024556:	4464      	add	r4, ip
 8024558:	f109 091c 	add.w	r9, r9, #28
 802455c:	f1bb 0f00 	cmp.w	fp, #0
 8024560:	d013      	beq.n	802458a <_tzset_r+0x216>
 8024562:	f8da 0004 	ldr.w	r0, [sl, #4]
 8024566:	f7ff fe35 	bl	80241d4 <__tzcalc_limits>
 802456a:	f8da 2020 	ldr.w	r2, [sl, #32]
 802456e:	f8da 303c 	ldr.w	r3, [sl, #60]	; 0x3c
 8024572:	4850      	ldr	r0, [pc, #320]	; (80246b4 <_tzset_r+0x340>)
 8024574:	4950      	ldr	r1, [pc, #320]	; (80246b8 <_tzset_r+0x344>)
 8024576:	1ad3      	subs	r3, r2, r3
 8024578:	bf18      	it	ne
 802457a:	2301      	movne	r3, #1
 802457c:	6003      	str	r3, [r0, #0]
 802457e:	600a      	str	r2, [r1, #0]
 8024580:	f7ff fef0 	bl	8024364 <__tz_unlock>
 8024584:	b00d      	add	sp, #52	; 0x34
 8024586:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802458a:	f04f 0b01 	mov.w	fp, #1
 802458e:	e7ad      	b.n	80244ec <_tzset_r+0x178>
 8024590:	3401      	adds	r4, #1
 8024592:	f04f 38ff 	mov.w	r8, #4294967295
 8024596:	e730      	b.n	80243fa <_tzset_r+0x86>
 8024598:	f7ff fee2 	bl	8024360 <__tz_lock>
 802459c:	4e46      	ldr	r6, [pc, #280]	; (80246b8 <_tzset_r+0x344>)
 802459e:	4b47      	ldr	r3, [pc, #284]	; (80246bc <_tzset_r+0x348>)
 80245a0:	4944      	ldr	r1, [pc, #272]	; (80246b4 <_tzset_r+0x340>)
 80245a2:	4a47      	ldr	r2, [pc, #284]	; (80246c0 <_tzset_r+0x34c>)
 80245a4:	6828      	ldr	r0, [r5, #0]
 80245a6:	600c      	str	r4, [r1, #0]
 80245a8:	601a      	str	r2, [r3, #0]
 80245aa:	605a      	str	r2, [r3, #4]
 80245ac:	6034      	str	r4, [r6, #0]
 80245ae:	f7fe f85d 	bl	802266c <free>
 80245b2:	602c      	str	r4, [r5, #0]
 80245b4:	f7ff fed6 	bl	8024364 <__tz_unlock>
 80245b8:	b00d      	add	sp, #52	; 0x34
 80245ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80245be:	3401      	adds	r4, #1
 80245c0:	f04f 38ff 	mov.w	r8, #4294967295
 80245c4:	e764      	b.n	8024490 <_tzset_r+0x11c>
 80245c6:	f8da 3020 	ldr.w	r3, [sl, #32]
 80245ca:	f5a3 6361 	sub.w	r3, r3, #3600	; 0xe10
 80245ce:	f8ca 303c 	str.w	r3, [sl, #60]	; 0x3c
 80245d2:	e786      	b.n	80244e2 <_tzset_r+0x16e>
 80245d4:	aa09      	add	r2, sp, #36	; 0x24
 80245d6:	f10d 0326 	add.w	r3, sp, #38	; 0x26
 80245da:	9200      	str	r2, [sp, #0]
 80245dc:	9302      	str	r3, [sp, #8]
 80245de:	9501      	str	r5, [sp, #4]
 80245e0:	9503      	str	r5, [sp, #12]
 80245e2:	4620      	mov	r0, r4
 80245e4:	4937      	ldr	r1, [pc, #220]	; (80246c4 <_tzset_r+0x350>)
 80245e6:	f10d 0222 	add.w	r2, sp, #34	; 0x22
 80245ea:	462b      	mov	r3, r5
 80245ec:	f001 f9f8 	bl	80259e0 <siscanf>
 80245f0:	2803      	cmp	r0, #3
 80245f2:	d1c5      	bne.n	8024580 <_tzset_r+0x20c>
 80245f4:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
 80245f8:	1e5a      	subs	r2, r3, #1
 80245fa:	2a0b      	cmp	r2, #11
 80245fc:	d8c0      	bhi.n	8024580 <_tzset_r+0x20c>
 80245fe:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
 8024602:	1e51      	subs	r1, r2, #1
 8024604:	2904      	cmp	r1, #4
 8024606:	d8bb      	bhi.n	8024580 <_tzset_r+0x20c>
 8024608:	f8bd 1026 	ldrh.w	r1, [sp, #38]	; 0x26
 802460c:	2906      	cmp	r1, #6
 802460e:	d8b7      	bhi.n	8024580 <_tzset_r+0x20c>
 8024610:	f889 8008 	strb.w	r8, [r9, #8]
 8024614:	f8c9 300c 	str.w	r3, [r9, #12]
 8024618:	f8c9 2010 	str.w	r2, [r9, #16]
 802461c:	f8c9 1014 	str.w	r1, [r9, #20]
 8024620:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8024622:	eb04 0c03 	add.w	ip, r4, r3
 8024626:	e785      	b.n	8024534 <_tzset_r+0x1c0>
 8024628:	4660      	mov	r0, ip
 802462a:	4927      	ldr	r1, [pc, #156]	; (80246c8 <_tzset_r+0x354>)
 802462c:	9600      	str	r6, [sp, #0]
 802462e:	aa07      	add	r2, sp, #28
 8024630:	462b      	mov	r3, r5
 8024632:	9501      	str	r5, [sp, #4]
 8024634:	9702      	str	r7, [sp, #8]
 8024636:	9503      	str	r5, [sp, #12]
 8024638:	f8cd c014 	str.w	ip, [sp, #20]
 802463c:	f001 f9d0 	bl	80259e0 <siscanf>
 8024640:	f8bd 101e 	ldrh.w	r1, [sp, #30]
 8024644:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 8024648:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 802464c:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 802464e:	f8dd c014 	ldr.w	ip, [sp, #20]
 8024652:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
 8024656:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 802465a:	f44f 6361 	mov.w	r3, #3600	; 0xe10
 802465e:	fb03 1302 	mla	r3, r3, r2, r1
 8024662:	e776      	b.n	8024552 <_tzset_r+0x1de>
 8024664:	f1bb 0f00 	cmp.w	fp, #0
 8024668:	d032      	beq.n	80246d0 <_tzset_r+0x35c>
 802466a:	204d      	movs	r0, #77	; 0x4d
 802466c:	210b      	movs	r1, #11
 802466e:	2201      	movs	r2, #1
 8024670:	2300      	movs	r3, #0
 8024672:	f88a 0024 	strb.w	r0, [sl, #36]	; 0x24
 8024676:	f8ca 1028 	str.w	r1, [sl, #40]	; 0x28
 802467a:	f8ca 202c 	str.w	r2, [sl, #44]	; 0x2c
 802467e:	f8ca 3030 	str.w	r3, [sl, #48]	; 0x30
 8024682:	e757      	b.n	8024534 <_tzset_r+0x1c0>
 8024684:	490c      	ldr	r1, [pc, #48]	; (80246b8 <_tzset_r+0x344>)
 8024686:	4a0b      	ldr	r2, [pc, #44]	; (80246b4 <_tzset_r+0x340>)
 8024688:	f8da 0020 	ldr.w	r0, [sl, #32]
 802468c:	f8db 3000 	ldr.w	r3, [fp]
 8024690:	6008      	str	r0, [r1, #0]
 8024692:	f8c2 9000 	str.w	r9, [r2]
 8024696:	f8cb 3004 	str.w	r3, [fp, #4]
 802469a:	f7ff fe63 	bl	8024364 <__tz_unlock>
 802469e:	e771      	b.n	8024584 <_tzset_r+0x210>
 80246a0:	0802b5ec 	.word	0x0802b5ec
 80246a4:	200121ec 	.word	0x200121ec
 80246a8:	0802b65c 	.word	0x0802b65c
 80246ac:	200121e0 	.word	0x200121e0
 80246b0:	0802b66c 	.word	0x0802b66c
 80246b4:	200121f0 	.word	0x200121f0
 80246b8:	200121f4 	.word	0x200121f4
 80246bc:	2001010c 	.word	0x2001010c
 80246c0:	0802b658 	.word	0x0802b658
 80246c4:	0802b680 	.word	0x0802b680
 80246c8:	0802b694 	.word	0x0802b694
 80246cc:	200121d4 	.word	0x200121d4
 80246d0:	214d      	movs	r1, #77	; 0x4d
 80246d2:	2203      	movs	r2, #3
 80246d4:	2302      	movs	r3, #2
 80246d6:	f8ca b014 	str.w	fp, [sl, #20]
 80246da:	f88a 1008 	strb.w	r1, [sl, #8]
 80246de:	f8ca 200c 	str.w	r2, [sl, #12]
 80246e2:	f8ca 3010 	str.w	r3, [sl, #16]
 80246e6:	e725      	b.n	8024534 <_tzset_r+0x1c0>

080246e8 <asctime>:
 80246e8:	4b02      	ldr	r3, [pc, #8]	; (80246f4 <asctime+0xc>)
 80246ea:	6819      	ldr	r1, [r3, #0]
 80246ec:	3160      	adds	r1, #96	; 0x60
 80246ee:	f000 b803 	b.w	80246f8 <asctime_r>
 80246f2:	bf00      	nop
 80246f4:	20010588 	.word	0x20010588

080246f8 <asctime_r>:
 80246f8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80246fa:	f8d0 c008 	ldr.w	ip, [r0, #8]
 80246fe:	6946      	ldr	r6, [r0, #20]
 8024700:	6985      	ldr	r5, [r0, #24]
 8024702:	6904      	ldr	r4, [r0, #16]
 8024704:	68c7      	ldr	r7, [r0, #12]
 8024706:	4a0e      	ldr	r2, [pc, #56]	; (8024740 <asctime_r+0x48>)
 8024708:	4b0e      	ldr	r3, [pc, #56]	; (8024744 <asctime_r+0x4c>)
 802470a:	e890 4001 	ldmia.w	r0, {r0, lr}
 802470e:	b087      	sub	sp, #28
 8024710:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8024714:	9700      	str	r7, [sp, #0]
 8024716:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 802471a:	460f      	mov	r7, r1
 802471c:	f206 716c 	addw	r1, r6, #1900	; 0x76c
 8024720:	9104      	str	r1, [sp, #16]
 8024722:	9003      	str	r0, [sp, #12]
 8024724:	442a      	add	r2, r5
 8024726:	4423      	add	r3, r4
 8024728:	f8cd c004 	str.w	ip, [sp, #4]
 802472c:	f8cd e008 	str.w	lr, [sp, #8]
 8024730:	4638      	mov	r0, r7
 8024732:	4905      	ldr	r1, [pc, #20]	; (8024748 <asctime_r+0x50>)
 8024734:	f001 f92e 	bl	8025994 <siprintf>
 8024738:	4638      	mov	r0, r7
 802473a:	b007      	add	sp, #28
 802473c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802473e:	bf00      	nop
 8024740:	0802b6ec 	.word	0x0802b6ec
 8024744:	0802b6a8 	.word	0x0802b6a8
 8024748:	0802b6cc 	.word	0x0802b6cc

0802474c <div>:
 802474c:	2900      	cmp	r1, #0
 802474e:	b410      	push	{r4}
 8024750:	fb91 f4f2 	sdiv	r4, r1, r2
 8024754:	fb02 1314 	mls	r3, r2, r4, r1
 8024758:	db06      	blt.n	8024768 <div+0x1c>
 802475a:	2b00      	cmp	r3, #0
 802475c:	db0e      	blt.n	802477c <div+0x30>
 802475e:	6004      	str	r4, [r0, #0]
 8024760:	6043      	str	r3, [r0, #4]
 8024762:	f85d 4b04 	ldr.w	r4, [sp], #4
 8024766:	4770      	bx	lr
 8024768:	2b00      	cmp	r3, #0
 802476a:	bfc4      	itt	gt
 802476c:	f104 34ff 	addgt.w	r4, r4, #4294967295
 8024770:	189b      	addgt	r3, r3, r2
 8024772:	6004      	str	r4, [r0, #0]
 8024774:	6043      	str	r3, [r0, #4]
 8024776:	f85d 4b04 	ldr.w	r4, [sp], #4
 802477a:	4770      	bx	lr
 802477c:	3401      	adds	r4, #1
 802477e:	1a9b      	subs	r3, r3, r2
 8024780:	6004      	str	r4, [r0, #0]
 8024782:	6043      	str	r3, [r0, #4]
 8024784:	f85d 4b04 	ldr.w	r4, [sp], #4
 8024788:	4770      	bx	lr
 802478a:	bf00      	nop

0802478c <__env_lock>:
 802478c:	4770      	bx	lr
 802478e:	bf00      	nop

08024790 <__env_unlock>:
 8024790:	4770      	bx	lr
 8024792:	bf00      	nop

08024794 <__errno>:
 8024794:	4b01      	ldr	r3, [pc, #4]	; (802479c <__errno+0x8>)
 8024796:	6818      	ldr	r0, [r3, #0]
 8024798:	4770      	bx	lr
 802479a:	bf00      	nop
 802479c:	20010588 	.word	0x20010588

080247a0 <rshift>:
 80247a0:	6902      	ldr	r2, [r0, #16]
 80247a2:	114b      	asrs	r3, r1, #5
 80247a4:	4293      	cmp	r3, r2
 80247a6:	b5f0      	push	{r4, r5, r6, r7, lr}
 80247a8:	f100 0614 	add.w	r6, r0, #20
 80247ac:	da2b      	bge.n	8024806 <rshift+0x66>
 80247ae:	f011 011f 	ands.w	r1, r1, #31
 80247b2:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 80247b6:	eb06 0e83 	add.w	lr, r6, r3, lsl #2
 80247ba:	d029      	beq.n	8024810 <rshift+0x70>
 80247bc:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 80247c0:	f10e 0504 	add.w	r5, lr, #4
 80247c4:	42aa      	cmp	r2, r5
 80247c6:	fa23 f401 	lsr.w	r4, r3, r1
 80247ca:	f1c1 0c20 	rsb	ip, r1, #32
 80247ce:	d935      	bls.n	802483c <rshift+0x9c>
 80247d0:	f100 0710 	add.w	r7, r0, #16
 80247d4:	682b      	ldr	r3, [r5, #0]
 80247d6:	fa03 f30c 	lsl.w	r3, r3, ip
 80247da:	4323      	orrs	r3, r4
 80247dc:	f847 3f04 	str.w	r3, [r7, #4]!
 80247e0:	f855 3b04 	ldr.w	r3, [r5], #4
 80247e4:	42aa      	cmp	r2, r5
 80247e6:	fa23 f401 	lsr.w	r4, r3, r1
 80247ea:	d8f3      	bhi.n	80247d4 <rshift+0x34>
 80247ec:	ebce 0202 	rsb	r2, lr, r2
 80247f0:	3a05      	subs	r2, #5
 80247f2:	f022 0203 	bic.w	r2, r2, #3
 80247f6:	3204      	adds	r2, #4
 80247f8:	4432      	add	r2, r6
 80247fa:	6014      	str	r4, [r2, #0]
 80247fc:	b104      	cbz	r4, 8024800 <rshift+0x60>
 80247fe:	3204      	adds	r2, #4
 8024800:	1b93      	subs	r3, r2, r6
 8024802:	109b      	asrs	r3, r3, #2
 8024804:	e016      	b.n	8024834 <rshift+0x94>
 8024806:	2300      	movs	r3, #0
 8024808:	6103      	str	r3, [r0, #16]
 802480a:	2300      	movs	r3, #0
 802480c:	6143      	str	r3, [r0, #20]
 802480e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8024810:	4572      	cmp	r2, lr
 8024812:	d9f8      	bls.n	8024806 <rshift+0x66>
 8024814:	f100 0410 	add.w	r4, r0, #16
 8024818:	4671      	mov	r1, lr
 802481a:	f851 5b04 	ldr.w	r5, [r1], #4
 802481e:	f844 5f04 	str.w	r5, [r4, #4]!
 8024822:	428a      	cmp	r2, r1
 8024824:	d8f9      	bhi.n	802481a <rshift+0x7a>
 8024826:	ea6f 030e 	mvn.w	r3, lr
 802482a:	4413      	add	r3, r2
 802482c:	f023 0303 	bic.w	r3, r3, #3
 8024830:	3304      	adds	r3, #4
 8024832:	109b      	asrs	r3, r3, #2
 8024834:	6103      	str	r3, [r0, #16]
 8024836:	2b00      	cmp	r3, #0
 8024838:	d0e7      	beq.n	802480a <rshift+0x6a>
 802483a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802483c:	4632      	mov	r2, r6
 802483e:	e7dc      	b.n	80247fa <rshift+0x5a>

08024840 <__gethex>:
 8024840:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024844:	b08b      	sub	sp, #44	; 0x2c
 8024846:	4688      	mov	r8, r1
 8024848:	9202      	str	r2, [sp, #8]
 802484a:	9307      	str	r3, [sp, #28]
 802484c:	9005      	str	r0, [sp, #20]
 802484e:	f000 fc4d 	bl	80250ec <_localeconv_r>
 8024852:	6803      	ldr	r3, [r0, #0]
 8024854:	9303      	str	r3, [sp, #12]
 8024856:	4618      	mov	r0, r3
 8024858:	461c      	mov	r4, r3
 802485a:	f7fe fba1 	bl	8022fa0 <strlen>
 802485e:	f8d8 3000 	ldr.w	r3, [r8]
 8024862:	9000      	str	r0, [sp, #0]
 8024864:	789a      	ldrb	r2, [r3, #2]
 8024866:	1821      	adds	r1, r4, r0
 8024868:	2a30      	cmp	r2, #48	; 0x30
 802486a:	f811 bc01 	ldrb.w	fp, [r1, #-1]
 802486e:	f040 81a0 	bne.w	8024bb2 <__gethex+0x372>
 8024872:	3303      	adds	r3, #3
 8024874:	f04f 0900 	mov.w	r9, #0
 8024878:	461c      	mov	r4, r3
 802487a:	f813 2b01 	ldrb.w	r2, [r3], #1
 802487e:	2a30      	cmp	r2, #48	; 0x30
 8024880:	f109 0901 	add.w	r9, r9, #1
 8024884:	d0f8      	beq.n	8024878 <__gethex+0x38>
 8024886:	4eae      	ldr	r6, [pc, #696]	; (8024b40 <__gethex+0x300>)
 8024888:	5cb3      	ldrb	r3, [r6, r2]
 802488a:	2b00      	cmp	r3, #0
 802488c:	f000 80ef 	beq.w	8024a6e <__gethex+0x22e>
 8024890:	7823      	ldrb	r3, [r4, #0]
 8024892:	f04f 0a00 	mov.w	sl, #0
 8024896:	5cf3      	ldrb	r3, [r6, r3]
 8024898:	4655      	mov	r5, sl
 802489a:	4627      	mov	r7, r4
 802489c:	b123      	cbz	r3, 80248a8 <__gethex+0x68>
 802489e:	f817 3f01 	ldrb.w	r3, [r7, #1]!
 80248a2:	5cf3      	ldrb	r3, [r6, r3]
 80248a4:	2b00      	cmp	r3, #0
 80248a6:	d1fa      	bne.n	802489e <__gethex+0x5e>
 80248a8:	4638      	mov	r0, r7
 80248aa:	9903      	ldr	r1, [sp, #12]
 80248ac:	9a00      	ldr	r2, [sp, #0]
 80248ae:	f7fe fba5 	bl	8022ffc <strncmp>
 80248b2:	b1c0      	cbz	r0, 80248e6 <__gethex+0xa6>
 80248b4:	783b      	ldrb	r3, [r7, #0]
 80248b6:	2d00      	cmp	r5, #0
 80248b8:	f000 816a 	beq.w	8024b90 <__gethex+0x350>
 80248bc:	1bed      	subs	r5, r5, r7
 80248be:	00aa      	lsls	r2, r5, #2
 80248c0:	9201      	str	r2, [sp, #4]
 80248c2:	2b50      	cmp	r3, #80	; 0x50
 80248c4:	d018      	beq.n	80248f8 <__gethex+0xb8>
 80248c6:	2b70      	cmp	r3, #112	; 0x70
 80248c8:	d016      	beq.n	80248f8 <__gethex+0xb8>
 80248ca:	463d      	mov	r5, r7
 80248cc:	f8c8 7000 	str.w	r7, [r8]
 80248d0:	f1ba 0f00 	cmp.w	sl, #0
 80248d4:	d040      	beq.n	8024958 <__gethex+0x118>
 80248d6:	f1b9 0f00 	cmp.w	r9, #0
 80248da:	bf14      	ite	ne
 80248dc:	2000      	movne	r0, #0
 80248de:	2006      	moveq	r0, #6
 80248e0:	b00b      	add	sp, #44	; 0x2c
 80248e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80248e6:	2d00      	cmp	r5, #0
 80248e8:	f000 818b 	beq.w	8024c02 <__gethex+0x3c2>
 80248ec:	783b      	ldrb	r3, [r7, #0]
 80248ee:	e7e5      	b.n	80248bc <__gethex+0x7c>
 80248f0:	2300      	movs	r3, #0
 80248f2:	9301      	str	r3, [sp, #4]
 80248f4:	f04f 0a01 	mov.w	sl, #1
 80248f8:	787b      	ldrb	r3, [r7, #1]
 80248fa:	2b2b      	cmp	r3, #43	; 0x2b
 80248fc:	f000 811e 	beq.w	8024b3c <__gethex+0x2fc>
 8024900:	2b2d      	cmp	r3, #45	; 0x2d
 8024902:	f000 80e6 	beq.w	8024ad2 <__gethex+0x292>
 8024906:	1c79      	adds	r1, r7, #1
 8024908:	2500      	movs	r5, #0
 802490a:	5cf3      	ldrb	r3, [r6, r3]
 802490c:	488c      	ldr	r0, [pc, #560]	; (8024b40 <__gethex+0x300>)
 802490e:	1e5a      	subs	r2, r3, #1
 8024910:	2a18      	cmp	r2, #24
 8024912:	d8da      	bhi.n	80248ca <__gethex+0x8a>
 8024914:	784a      	ldrb	r2, [r1, #1]
 8024916:	5c82      	ldrb	r2, [r0, r2]
 8024918:	1e50      	subs	r0, r2, #1
 802491a:	2818      	cmp	r0, #24
 802491c:	f1a3 0310 	sub.w	r3, r3, #16
 8024920:	f101 0101 	add.w	r1, r1, #1
 8024924:	d80b      	bhi.n	802493e <__gethex+0xfe>
 8024926:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 802492a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 802492e:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 8024932:	5c32      	ldrb	r2, [r6, r0]
 8024934:	1e50      	subs	r0, r2, #1
 8024936:	2818      	cmp	r0, #24
 8024938:	f1a3 0310 	sub.w	r3, r3, #16
 802493c:	d9f3      	bls.n	8024926 <__gethex+0xe6>
 802493e:	426a      	negs	r2, r5
 8024940:	4053      	eors	r3, r2
 8024942:	9a01      	ldr	r2, [sp, #4]
 8024944:	442b      	add	r3, r5
 8024946:	441a      	add	r2, r3
 8024948:	463d      	mov	r5, r7
 802494a:	460f      	mov	r7, r1
 802494c:	9201      	str	r2, [sp, #4]
 802494e:	f8c8 7000 	str.w	r7, [r8]
 8024952:	f1ba 0f00 	cmp.w	sl, #0
 8024956:	d1be      	bne.n	80248d6 <__gethex+0x96>
 8024958:	1b2b      	subs	r3, r5, r4
 802495a:	3b01      	subs	r3, #1
 802495c:	2b07      	cmp	r3, #7
 802495e:	4651      	mov	r1, sl
 8024960:	dd04      	ble.n	802496c <__gethex+0x12c>
 8024962:	105b      	asrs	r3, r3, #1
 8024964:	2b07      	cmp	r3, #7
 8024966:	f101 0101 	add.w	r1, r1, #1
 802496a:	dcfa      	bgt.n	8024962 <__gethex+0x122>
 802496c:	9805      	ldr	r0, [sp, #20]
 802496e:	f000 fbc1 	bl	80250f4 <_Balloc>
 8024972:	4603      	mov	r3, r0
 8024974:	3314      	adds	r3, #20
 8024976:	42a5      	cmp	r5, r4
 8024978:	9004      	str	r0, [sp, #16]
 802497a:	9306      	str	r3, [sp, #24]
 802497c:	f240 8192 	bls.w	8024ca4 <__gethex+0x464>
 8024980:	4699      	mov	r9, r3
 8024982:	9b00      	ldr	r3, [sp, #0]
 8024984:	f04f 0800 	mov.w	r8, #0
 8024988:	f1c3 0c01 	rsb	ip, r3, #1
 802498c:	46a2      	mov	sl, r4
 802498e:	462b      	mov	r3, r5
 8024990:	4647      	mov	r7, r8
 8024992:	4644      	mov	r4, r8
 8024994:	4665      	mov	r5, ip
 8024996:	e00d      	b.n	80249b4 <__gethex+0x174>
 8024998:	2f20      	cmp	r7, #32
 802499a:	d060      	beq.n	8024a5e <__gethex+0x21e>
 802499c:	463a      	mov	r2, r7
 802499e:	3704      	adds	r7, #4
 80249a0:	f813 3c01 	ldrb.w	r3, [r3, #-1]
 80249a4:	5cf3      	ldrb	r3, [r6, r3]
 80249a6:	f003 030f 	and.w	r3, r3, #15
 80249aa:	4093      	lsls	r3, r2
 80249ac:	431c      	orrs	r4, r3
 80249ae:	4643      	mov	r3, r8
 80249b0:	4553      	cmp	r3, sl
 80249b2:	d919      	bls.n	80249e8 <__gethex+0x1a8>
 80249b4:	f813 2c01 	ldrb.w	r2, [r3, #-1]
 80249b8:	455a      	cmp	r2, fp
 80249ba:	f103 38ff 	add.w	r8, r3, #4294967295
 80249be:	d1eb      	bne.n	8024998 <__gethex+0x158>
 80249c0:	eb08 0c05 	add.w	ip, r8, r5
 80249c4:	45d4      	cmp	ip, sl
 80249c6:	d3e7      	bcc.n	8024998 <__gethex+0x158>
 80249c8:	4660      	mov	r0, ip
 80249ca:	9903      	ldr	r1, [sp, #12]
 80249cc:	9a00      	ldr	r2, [sp, #0]
 80249ce:	9309      	str	r3, [sp, #36]	; 0x24
 80249d0:	f8cd c020 	str.w	ip, [sp, #32]
 80249d4:	f7fe fb12 	bl	8022ffc <strncmp>
 80249d8:	f8dd c020 	ldr.w	ip, [sp, #32]
 80249dc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80249de:	2800      	cmp	r0, #0
 80249e0:	d1da      	bne.n	8024998 <__gethex+0x158>
 80249e2:	4663      	mov	r3, ip
 80249e4:	4553      	cmp	r3, sl
 80249e6:	d8e5      	bhi.n	80249b4 <__gethex+0x174>
 80249e8:	46a0      	mov	r8, r4
 80249ea:	f849 8b04 	str.w	r8, [r9], #4
 80249ee:	9b06      	ldr	r3, [sp, #24]
 80249f0:	9a04      	ldr	r2, [sp, #16]
 80249f2:	ebc3 0909 	rsb	r9, r3, r9
 80249f6:	ea4f 03a9 	mov.w	r3, r9, asr #2
 80249fa:	6113      	str	r3, [r2, #16]
 80249fc:	4640      	mov	r0, r8
 80249fe:	ea4f 1943 	mov.w	r9, r3, lsl #5
 8024a02:	f000 fc35 	bl	8025270 <__hi0bits>
 8024a06:	9b02      	ldr	r3, [sp, #8]
 8024a08:	681e      	ldr	r6, [r3, #0]
 8024a0a:	ebc0 0009 	rsb	r0, r0, r9
 8024a0e:	42b0      	cmp	r0, r6
 8024a10:	f300 8098 	bgt.w	8024b44 <__gethex+0x304>
 8024a14:	f2c0 80be 	blt.w	8024b94 <__gethex+0x354>
 8024a18:	2700      	movs	r7, #0
 8024a1a:	9b02      	ldr	r3, [sp, #8]
 8024a1c:	9a01      	ldr	r2, [sp, #4]
 8024a1e:	689b      	ldr	r3, [r3, #8]
 8024a20:	429a      	cmp	r2, r3
 8024a22:	dc4b      	bgt.n	8024abc <__gethex+0x27c>
 8024a24:	9b02      	ldr	r3, [sp, #8]
 8024a26:	9a01      	ldr	r2, [sp, #4]
 8024a28:	685b      	ldr	r3, [r3, #4]
 8024a2a:	429a      	cmp	r2, r3
 8024a2c:	da6b      	bge.n	8024b06 <__gethex+0x2c6>
 8024a2e:	1a9d      	subs	r5, r3, r2
 8024a30:	42ae      	cmp	r6, r5
 8024a32:	f300 80c6 	bgt.w	8024bc2 <__gethex+0x382>
 8024a36:	9a02      	ldr	r2, [sp, #8]
 8024a38:	68d2      	ldr	r2, [r2, #12]
 8024a3a:	2a02      	cmp	r2, #2
 8024a3c:	f000 8148 	beq.w	8024cd0 <__gethex+0x490>
 8024a40:	2a03      	cmp	r2, #3
 8024a42:	f000 8116 	beq.w	8024c72 <__gethex+0x432>
 8024a46:	2a01      	cmp	r2, #1
 8024a48:	f000 8133 	beq.w	8024cb2 <__gethex+0x472>
 8024a4c:	9805      	ldr	r0, [sp, #20]
 8024a4e:	9904      	ldr	r1, [sp, #16]
 8024a50:	f000 fb76 	bl	8025140 <_Bfree>
 8024a54:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8024a56:	2300      	movs	r3, #0
 8024a58:	6013      	str	r3, [r2, #0]
 8024a5a:	2050      	movs	r0, #80	; 0x50
 8024a5c:	e740      	b.n	80248e0 <__gethex+0xa0>
 8024a5e:	f8c9 4000 	str.w	r4, [r9]
 8024a62:	2400      	movs	r4, #0
 8024a64:	f109 0904 	add.w	r9, r9, #4
 8024a68:	4622      	mov	r2, r4
 8024a6a:	2704      	movs	r7, #4
 8024a6c:	e798      	b.n	80249a0 <__gethex+0x160>
 8024a6e:	4620      	mov	r0, r4
 8024a70:	9903      	ldr	r1, [sp, #12]
 8024a72:	9a00      	ldr	r2, [sp, #0]
 8024a74:	f7fe fac2 	bl	8022ffc <strncmp>
 8024a78:	b378      	cbz	r0, 8024ada <__gethex+0x29a>
 8024a7a:	7823      	ldrb	r3, [r4, #0]
 8024a7c:	4627      	mov	r7, r4
 8024a7e:	2b50      	cmp	r3, #80	; 0x50
 8024a80:	f43f af36 	beq.w	80248f0 <__gethex+0xb0>
 8024a84:	2b70      	cmp	r3, #112	; 0x70
 8024a86:	f43f af33 	beq.w	80248f0 <__gethex+0xb0>
 8024a8a:	f8c8 7000 	str.w	r7, [r8]
 8024a8e:	e722      	b.n	80248d6 <__gethex+0x96>
 8024a90:	4445      	add	r5, r8
 8024a92:	f1c6 0620 	rsb	r6, r6, #32
 8024a96:	f855 0c04 	ldr.w	r0, [r5, #-4]
 8024a9a:	f000 fbe9 	bl	8025270 <__hi0bits>
 8024a9e:	42b0      	cmp	r0, r6
 8024aa0:	f280 80e3 	bge.w	8024c6a <__gethex+0x42a>
 8024aa4:	9804      	ldr	r0, [sp, #16]
 8024aa6:	2101      	movs	r1, #1
 8024aa8:	f7ff fe7a 	bl	80247a0 <rshift>
 8024aac:	9b02      	ldr	r3, [sp, #8]
 8024aae:	9a01      	ldr	r2, [sp, #4]
 8024ab0:	689b      	ldr	r3, [r3, #8]
 8024ab2:	3201      	adds	r2, #1
 8024ab4:	429a      	cmp	r2, r3
 8024ab6:	9201      	str	r2, [sp, #4]
 8024ab8:	f340 80d7 	ble.w	8024c6a <__gethex+0x42a>
 8024abc:	9805      	ldr	r0, [sp, #20]
 8024abe:	9904      	ldr	r1, [sp, #16]
 8024ac0:	f000 fb3e 	bl	8025140 <_Bfree>
 8024ac4:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8024ac6:	2300      	movs	r3, #0
 8024ac8:	20a3      	movs	r0, #163	; 0xa3
 8024aca:	6013      	str	r3, [r2, #0]
 8024acc:	b00b      	add	sp, #44	; 0x2c
 8024ace:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024ad2:	2501      	movs	r5, #1
 8024ad4:	78bb      	ldrb	r3, [r7, #2]
 8024ad6:	1cb9      	adds	r1, r7, #2
 8024ad8:	e717      	b.n	802490a <__gethex+0xca>
 8024ada:	9900      	ldr	r1, [sp, #0]
 8024adc:	5c62      	ldrb	r2, [r4, r1]
 8024ade:	5cb3      	ldrb	r3, [r6, r2]
 8024ae0:	1867      	adds	r7, r4, r1
 8024ae2:	2b00      	cmp	r3, #0
 8024ae4:	d069      	beq.n	8024bba <__gethex+0x37a>
 8024ae6:	2a30      	cmp	r2, #48	; 0x30
 8024ae8:	463c      	mov	r4, r7
 8024aea:	d104      	bne.n	8024af6 <__gethex+0x2b6>
 8024aec:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 8024af0:	2b30      	cmp	r3, #48	; 0x30
 8024af2:	d0fb      	beq.n	8024aec <__gethex+0x2ac>
 8024af4:	5cf3      	ldrb	r3, [r6, r3]
 8024af6:	fab3 fa83 	clz	sl, r3
 8024afa:	463d      	mov	r5, r7
 8024afc:	f04f 0901 	mov.w	r9, #1
 8024b00:	ea4f 1a5a 	mov.w	sl, sl, lsr #5
 8024b04:	e6c9      	b.n	802489a <__gethex+0x5a>
 8024b06:	2401      	movs	r4, #1
 8024b08:	b167      	cbz	r7, 8024b24 <__gethex+0x2e4>
 8024b0a:	9b02      	ldr	r3, [sp, #8]
 8024b0c:	68db      	ldr	r3, [r3, #12]
 8024b0e:	2b02      	cmp	r3, #2
 8024b10:	f000 8085 	beq.w	8024c1e <__gethex+0x3de>
 8024b14:	2b03      	cmp	r3, #3
 8024b16:	f000 8086 	beq.w	8024c26 <__gethex+0x3e6>
 8024b1a:	2b01      	cmp	r3, #1
 8024b1c:	f000 80b9 	beq.w	8024c92 <__gethex+0x452>
 8024b20:	f044 0410 	orr.w	r4, r4, #16
 8024b24:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8024b26:	461a      	mov	r2, r3
 8024b28:	9b04      	ldr	r3, [sp, #16]
 8024b2a:	6013      	str	r3, [r2, #0]
 8024b2c:	9b07      	ldr	r3, [sp, #28]
 8024b2e:	461a      	mov	r2, r3
 8024b30:	9b01      	ldr	r3, [sp, #4]
 8024b32:	6013      	str	r3, [r2, #0]
 8024b34:	4620      	mov	r0, r4
 8024b36:	b00b      	add	sp, #44	; 0x2c
 8024b38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024b3c:	2500      	movs	r5, #0
 8024b3e:	e7c9      	b.n	8024ad4 <__gethex+0x294>
 8024b40:	0802b808 	.word	0x0802b808
 8024b44:	1b84      	subs	r4, r0, r6
 8024b46:	4621      	mov	r1, r4
 8024b48:	9804      	ldr	r0, [sp, #16]
 8024b4a:	f000 fef3 	bl	8025934 <__any_on>
 8024b4e:	2800      	cmp	r0, #0
 8024b50:	d035      	beq.n	8024bbe <__gethex+0x37e>
 8024b52:	1e63      	subs	r3, r4, #1
 8024b54:	115a      	asrs	r2, r3, #5
 8024b56:	9806      	ldr	r0, [sp, #24]
 8024b58:	f003 011f 	and.w	r1, r3, #31
 8024b5c:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 8024b60:	2701      	movs	r7, #1
 8024b62:	fa07 f101 	lsl.w	r1, r7, r1
 8024b66:	4211      	tst	r1, r2
 8024b68:	d00a      	beq.n	8024b80 <__gethex+0x340>
 8024b6a:	42bb      	cmp	r3, r7
 8024b6c:	f340 809f 	ble.w	8024cae <__gethex+0x46e>
 8024b70:	9804      	ldr	r0, [sp, #16]
 8024b72:	1ea1      	subs	r1, r4, #2
 8024b74:	f000 fede 	bl	8025934 <__any_on>
 8024b78:	2800      	cmp	r0, #0
 8024b7a:	f000 8098 	beq.w	8024cae <__gethex+0x46e>
 8024b7e:	2703      	movs	r7, #3
 8024b80:	9b01      	ldr	r3, [sp, #4]
 8024b82:	9804      	ldr	r0, [sp, #16]
 8024b84:	4423      	add	r3, r4
 8024b86:	4621      	mov	r1, r4
 8024b88:	9301      	str	r3, [sp, #4]
 8024b8a:	f7ff fe09 	bl	80247a0 <rshift>
 8024b8e:	e744      	b.n	8024a1a <__gethex+0x1da>
 8024b90:	9501      	str	r5, [sp, #4]
 8024b92:	e696      	b.n	80248c2 <__gethex+0x82>
 8024b94:	1a34      	subs	r4, r6, r0
 8024b96:	9904      	ldr	r1, [sp, #16]
 8024b98:	9805      	ldr	r0, [sp, #20]
 8024b9a:	4622      	mov	r2, r4
 8024b9c:	f000 fcaa 	bl	80254f4 <__lshift>
 8024ba0:	9b01      	ldr	r3, [sp, #4]
 8024ba2:	9004      	str	r0, [sp, #16]
 8024ba4:	1b1b      	subs	r3, r3, r4
 8024ba6:	9301      	str	r3, [sp, #4]
 8024ba8:	4603      	mov	r3, r0
 8024baa:	3314      	adds	r3, #20
 8024bac:	9306      	str	r3, [sp, #24]
 8024bae:	2700      	movs	r7, #0
 8024bb0:	e733      	b.n	8024a1a <__gethex+0x1da>
 8024bb2:	1c9c      	adds	r4, r3, #2
 8024bb4:	f04f 0900 	mov.w	r9, #0
 8024bb8:	e665      	b.n	8024886 <__gethex+0x46>
 8024bba:	4613      	mov	r3, r2
 8024bbc:	e75f      	b.n	8024a7e <__gethex+0x23e>
 8024bbe:	4607      	mov	r7, r0
 8024bc0:	e7de      	b.n	8024b80 <__gethex+0x340>
 8024bc2:	1e6c      	subs	r4, r5, #1
 8024bc4:	2f00      	cmp	r7, #0
 8024bc6:	d152      	bne.n	8024c6e <__gethex+0x42e>
 8024bc8:	2c00      	cmp	r4, #0
 8024bca:	dd04      	ble.n	8024bd6 <__gethex+0x396>
 8024bcc:	9804      	ldr	r0, [sp, #16]
 8024bce:	4621      	mov	r1, r4
 8024bd0:	f000 feb0 	bl	8025934 <__any_on>
 8024bd4:	4607      	mov	r7, r0
 8024bd6:	1163      	asrs	r3, r4, #5
 8024bd8:	9a06      	ldr	r2, [sp, #24]
 8024bda:	9804      	ldr	r0, [sp, #16]
 8024bdc:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8024be0:	f004 041f 	and.w	r4, r4, #31
 8024be4:	2301      	movs	r3, #1
 8024be6:	40a3      	lsls	r3, r4
 8024be8:	4213      	tst	r3, r2
 8024bea:	4629      	mov	r1, r5
 8024bec:	bf18      	it	ne
 8024bee:	f047 0702 	orrne.w	r7, r7, #2
 8024bf2:	f7ff fdd5 	bl	80247a0 <rshift>
 8024bf6:	9b02      	ldr	r3, [sp, #8]
 8024bf8:	685b      	ldr	r3, [r3, #4]
 8024bfa:	9301      	str	r3, [sp, #4]
 8024bfc:	1b76      	subs	r6, r6, r5
 8024bfe:	2402      	movs	r4, #2
 8024c00:	e782      	b.n	8024b08 <__gethex+0x2c8>
 8024c02:	9900      	ldr	r1, [sp, #0]
 8024c04:	5c7b      	ldrb	r3, [r7, r1]
 8024c06:	5cf2      	ldrb	r2, [r6, r3]
 8024c08:	187d      	adds	r5, r7, r1
 8024c0a:	462f      	mov	r7, r5
 8024c0c:	2a00      	cmp	r2, #0
 8024c0e:	f43f ae55 	beq.w	80248bc <__gethex+0x7c>
 8024c12:	f817 3f01 	ldrb.w	r3, [r7, #1]!
 8024c16:	5cf2      	ldrb	r2, [r6, r3]
 8024c18:	2a00      	cmp	r2, #0
 8024c1a:	d1fa      	bne.n	8024c12 <__gethex+0x3d2>
 8024c1c:	e64e      	b.n	80248bc <__gethex+0x7c>
 8024c1e:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8024c20:	f1c3 0301 	rsb	r3, r3, #1
 8024c24:	9315      	str	r3, [sp, #84]	; 0x54
 8024c26:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8024c28:	2b00      	cmp	r3, #0
 8024c2a:	f43f af79 	beq.w	8024b20 <__gethex+0x2e0>
 8024c2e:	9b04      	ldr	r3, [sp, #16]
 8024c30:	691f      	ldr	r7, [r3, #16]
 8024c32:	9b06      	ldr	r3, [sp, #24]
 8024c34:	00bd      	lsls	r5, r7, #2
 8024c36:	1958      	adds	r0, r3, r5
 8024c38:	2100      	movs	r1, #0
 8024c3a:	e003      	b.n	8024c44 <__gethex+0x404>
 8024c3c:	f843 1b04 	str.w	r1, [r3], #4
 8024c40:	4298      	cmp	r0, r3
 8024c42:	d949      	bls.n	8024cd8 <__gethex+0x498>
 8024c44:	681a      	ldr	r2, [r3, #0]
 8024c46:	f1b2 3fff 	cmp.w	r2, #4294967295
 8024c4a:	d0f7      	beq.n	8024c3c <__gethex+0x3fc>
 8024c4c:	3201      	adds	r2, #1
 8024c4e:	f8dd 8018 	ldr.w	r8, [sp, #24]
 8024c52:	601a      	str	r2, [r3, #0]
 8024c54:	2c02      	cmp	r4, #2
 8024c56:	d04e      	beq.n	8024cf6 <__gethex+0x4b6>
 8024c58:	9b04      	ldr	r3, [sp, #16]
 8024c5a:	691b      	ldr	r3, [r3, #16]
 8024c5c:	429f      	cmp	r7, r3
 8024c5e:	f6ff af21 	blt.w	8024aa4 <__gethex+0x264>
 8024c62:	f016 061f 	ands.w	r6, r6, #31
 8024c66:	f47f af13 	bne.w	8024a90 <__gethex+0x250>
 8024c6a:	2421      	movs	r4, #33	; 0x21
 8024c6c:	e75a      	b.n	8024b24 <__gethex+0x2e4>
 8024c6e:	2701      	movs	r7, #1
 8024c70:	e7b1      	b.n	8024bd6 <__gethex+0x396>
 8024c72:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8024c74:	2a00      	cmp	r2, #0
 8024c76:	f43f aee9 	beq.w	8024a4c <__gethex+0x20c>
 8024c7a:	9907      	ldr	r1, [sp, #28]
 8024c7c:	600b      	str	r3, [r1, #0]
 8024c7e:	9b06      	ldr	r3, [sp, #24]
 8024c80:	9904      	ldr	r1, [sp, #16]
 8024c82:	2201      	movs	r2, #1
 8024c84:	610a      	str	r2, [r1, #16]
 8024c86:	601a      	str	r2, [r3, #0]
 8024c88:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8024c8a:	461a      	mov	r2, r3
 8024c8c:	2062      	movs	r0, #98	; 0x62
 8024c8e:	6011      	str	r1, [r2, #0]
 8024c90:	e626      	b.n	80248e0 <__gethex+0xa0>
 8024c92:	07ba      	lsls	r2, r7, #30
 8024c94:	f57f af44 	bpl.w	8024b20 <__gethex+0x2e0>
 8024c98:	9b06      	ldr	r3, [sp, #24]
 8024c9a:	681b      	ldr	r3, [r3, #0]
 8024c9c:	433b      	orrs	r3, r7
 8024c9e:	07db      	lsls	r3, r3, #31
 8024ca0:	d4c5      	bmi.n	8024c2e <__gethex+0x3ee>
 8024ca2:	e73d      	b.n	8024b20 <__gethex+0x2e0>
 8024ca4:	f8dd 9018 	ldr.w	r9, [sp, #24]
 8024ca8:	f04f 0800 	mov.w	r8, #0
 8024cac:	e69d      	b.n	80249ea <__gethex+0x1aa>
 8024cae:	2702      	movs	r7, #2
 8024cb0:	e766      	b.n	8024b80 <__gethex+0x340>
 8024cb2:	42b5      	cmp	r5, r6
 8024cb4:	f47f aeca 	bne.w	8024a4c <__gethex+0x20c>
 8024cb8:	2e01      	cmp	r6, #1
 8024cba:	ddde      	ble.n	8024c7a <__gethex+0x43a>
 8024cbc:	1e71      	subs	r1, r6, #1
 8024cbe:	9804      	ldr	r0, [sp, #16]
 8024cc0:	f000 fe38 	bl	8025934 <__any_on>
 8024cc4:	2800      	cmp	r0, #0
 8024cc6:	f43f aec1 	beq.w	8024a4c <__gethex+0x20c>
 8024cca:	9b02      	ldr	r3, [sp, #8]
 8024ccc:	685b      	ldr	r3, [r3, #4]
 8024cce:	e7d4      	b.n	8024c7a <__gethex+0x43a>
 8024cd0:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8024cd2:	2a00      	cmp	r2, #0
 8024cd4:	d0d1      	beq.n	8024c7a <__gethex+0x43a>
 8024cd6:	e6b9      	b.n	8024a4c <__gethex+0x20c>
 8024cd8:	9b04      	ldr	r3, [sp, #16]
 8024cda:	689b      	ldr	r3, [r3, #8]
 8024cdc:	429f      	cmp	r7, r3
 8024cde:	da11      	bge.n	8024d04 <__gethex+0x4c4>
 8024ce0:	f8dd 8018 	ldr.w	r8, [sp, #24]
 8024ce4:	463b      	mov	r3, r7
 8024ce6:	9804      	ldr	r0, [sp, #16]
 8024ce8:	eb00 0283 	add.w	r2, r0, r3, lsl #2
 8024cec:	2101      	movs	r1, #1
 8024cee:	3301      	adds	r3, #1
 8024cf0:	6103      	str	r3, [r0, #16]
 8024cf2:	6151      	str	r1, [r2, #20]
 8024cf4:	e7ae      	b.n	8024c54 <__gethex+0x414>
 8024cf6:	9b02      	ldr	r3, [sp, #8]
 8024cf8:	681b      	ldr	r3, [r3, #0]
 8024cfa:	3b01      	subs	r3, #1
 8024cfc:	42b3      	cmp	r3, r6
 8024cfe:	d01d      	beq.n	8024d3c <__gethex+0x4fc>
 8024d00:	2422      	movs	r4, #34	; 0x22
 8024d02:	e70f      	b.n	8024b24 <__gethex+0x2e4>
 8024d04:	9b04      	ldr	r3, [sp, #16]
 8024d06:	f8dd 9014 	ldr.w	r9, [sp, #20]
 8024d0a:	6859      	ldr	r1, [r3, #4]
 8024d0c:	4648      	mov	r0, r9
 8024d0e:	3101      	adds	r1, #1
 8024d10:	f000 f9f0 	bl	80250f4 <_Balloc>
 8024d14:	9904      	ldr	r1, [sp, #16]
 8024d16:	690b      	ldr	r3, [r1, #16]
 8024d18:	1c9a      	adds	r2, r3, #2
 8024d1a:	4680      	mov	r8, r0
 8024d1c:	0092      	lsls	r2, r2, #2
 8024d1e:	310c      	adds	r1, #12
 8024d20:	300c      	adds	r0, #12
 8024d22:	f7db fadd 	bl	80002e0 <memcpy>
 8024d26:	4648      	mov	r0, r9
 8024d28:	9904      	ldr	r1, [sp, #16]
 8024d2a:	f000 fa09 	bl	8025140 <_Bfree>
 8024d2e:	f8cd 8010 	str.w	r8, [sp, #16]
 8024d32:	f8d8 3010 	ldr.w	r3, [r8, #16]
 8024d36:	f108 0814 	add.w	r8, r8, #20
 8024d3a:	e7d4      	b.n	8024ce6 <__gethex+0x4a6>
 8024d3c:	1173      	asrs	r3, r6, #5
 8024d3e:	f006 061f 	and.w	r6, r6, #31
 8024d42:	f858 2023 	ldr.w	r2, [r8, r3, lsl #2]
 8024d46:	2301      	movs	r3, #1
 8024d48:	40b3      	lsls	r3, r6
 8024d4a:	4213      	tst	r3, r2
 8024d4c:	bf0c      	ite	eq
 8024d4e:	2422      	moveq	r4, #34	; 0x22
 8024d50:	2421      	movne	r4, #33	; 0x21
 8024d52:	e6e7      	b.n	8024b24 <__gethex+0x2e4>

08024d54 <__hexnan>:
 8024d54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024d58:	680b      	ldr	r3, [r1, #0]
 8024d5a:	b085      	sub	sp, #20
 8024d5c:	1159      	asrs	r1, r3, #5
 8024d5e:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 8024d62:	f013 031f 	ands.w	r3, r3, #31
 8024d66:	9002      	str	r0, [sp, #8]
 8024d68:	9101      	str	r1, [sp, #4]
 8024d6a:	9303      	str	r3, [sp, #12]
 8024d6c:	d002      	beq.n	8024d74 <__hexnan+0x20>
 8024d6e:	460b      	mov	r3, r1
 8024d70:	3304      	adds	r3, #4
 8024d72:	9301      	str	r3, [sp, #4]
 8024d74:	9c01      	ldr	r4, [sp, #4]
 8024d76:	f8df 915c 	ldr.w	r9, [pc, #348]	; 8024ed4 <__hexnan+0x180>
 8024d7a:	2300      	movs	r3, #0
 8024d7c:	4619      	mov	r1, r3
 8024d7e:	f844 3c04 	str.w	r3, [r4, #-4]
 8024d82:	469a      	mov	sl, r3
 8024d84:	469e      	mov	lr, r3
 8024d86:	9b02      	ldr	r3, [sp, #8]
 8024d88:	f1a4 0c04 	sub.w	ip, r4, #4
 8024d8c:	681d      	ldr	r5, [r3, #0]
 8024d8e:	46e0      	mov	r8, ip
 8024d90:	4660      	mov	r0, ip
 8024d92:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 8024d96:	b323      	cbz	r3, 8024de2 <__hexnan+0x8e>
 8024d98:	f819 4003 	ldrb.w	r4, [r9, r3]
 8024d9c:	2c00      	cmp	r4, #0
 8024d9e:	d143      	bne.n	8024e28 <__hexnan+0xd4>
 8024da0:	2b20      	cmp	r3, #32
 8024da2:	d85e      	bhi.n	8024e62 <__hexnan+0x10e>
 8024da4:	45d6      	cmp	lr, sl
 8024da6:	ddf4      	ble.n	8024d92 <__hexnan+0x3e>
 8024da8:	4540      	cmp	r0, r8
 8024daa:	d213      	bcs.n	8024dd4 <__hexnan+0x80>
 8024dac:	2907      	cmp	r1, #7
 8024dae:	dc11      	bgt.n	8024dd4 <__hexnan+0x80>
 8024db0:	f1c1 0108 	rsb	r1, r1, #8
 8024db4:	0089      	lsls	r1, r1, #2
 8024db6:	6806      	ldr	r6, [r0, #0]
 8024db8:	f1c1 0b20 	rsb	fp, r1, #32
 8024dbc:	4603      	mov	r3, r0
 8024dbe:	685f      	ldr	r7, [r3, #4]
 8024dc0:	fa07 f40b 	lsl.w	r4, r7, fp
 8024dc4:	4334      	orrs	r4, r6
 8024dc6:	fa27 f601 	lsr.w	r6, r7, r1
 8024dca:	601c      	str	r4, [r3, #0]
 8024dcc:	f843 6f04 	str.w	r6, [r3, #4]!
 8024dd0:	4598      	cmp	r8, r3
 8024dd2:	d8f4      	bhi.n	8024dbe <__hexnan+0x6a>
 8024dd4:	4290      	cmp	r0, r2
 8024dd6:	d83b      	bhi.n	8024e50 <__hexnan+0xfc>
 8024dd8:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 8024ddc:	2108      	movs	r1, #8
 8024dde:	2b00      	cmp	r3, #0
 8024de0:	d1da      	bne.n	8024d98 <__hexnan+0x44>
 8024de2:	f1be 0f00 	cmp.w	lr, #0
 8024de6:	d03e      	beq.n	8024e66 <__hexnan+0x112>
 8024de8:	4540      	cmp	r0, r8
 8024dea:	d201      	bcs.n	8024df0 <__hexnan+0x9c>
 8024dec:	2907      	cmp	r1, #7
 8024dee:	dd5d      	ble.n	8024eac <__hexnan+0x158>
 8024df0:	4282      	cmp	r2, r0
 8024df2:	d23c      	bcs.n	8024e6e <__hexnan+0x11a>
 8024df4:	4613      	mov	r3, r2
 8024df6:	f850 1b04 	ldr.w	r1, [r0], #4
 8024dfa:	f843 1b04 	str.w	r1, [r3], #4
 8024dfe:	4584      	cmp	ip, r0
 8024e00:	d2f9      	bcs.n	8024df6 <__hexnan+0xa2>
 8024e02:	2100      	movs	r1, #0
 8024e04:	f843 1b04 	str.w	r1, [r3], #4
 8024e08:	459c      	cmp	ip, r3
 8024e0a:	d2fb      	bcs.n	8024e04 <__hexnan+0xb0>
 8024e0c:	9b01      	ldr	r3, [sp, #4]
 8024e0e:	f853 3c04 	ldr.w	r3, [r3, #-4]
 8024e12:	b92b      	cbnz	r3, 8024e20 <__hexnan+0xcc>
 8024e14:	4562      	cmp	r2, ip
 8024e16:	d03b      	beq.n	8024e90 <__hexnan+0x13c>
 8024e18:	f85c 3d04 	ldr.w	r3, [ip, #-4]!
 8024e1c:	2b00      	cmp	r3, #0
 8024e1e:	d0f9      	beq.n	8024e14 <__hexnan+0xc0>
 8024e20:	2005      	movs	r0, #5
 8024e22:	b005      	add	sp, #20
 8024e24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024e28:	3101      	adds	r1, #1
 8024e2a:	2908      	cmp	r1, #8
 8024e2c:	f10e 0e01 	add.w	lr, lr, #1
 8024e30:	dc06      	bgt.n	8024e40 <__hexnan+0xec>
 8024e32:	6803      	ldr	r3, [r0, #0]
 8024e34:	011b      	lsls	r3, r3, #4
 8024e36:	f004 040f 	and.w	r4, r4, #15
 8024e3a:	431c      	orrs	r4, r3
 8024e3c:	6004      	str	r4, [r0, #0]
 8024e3e:	e7a8      	b.n	8024d92 <__hexnan+0x3e>
 8024e40:	4290      	cmp	r0, r2
 8024e42:	d9a6      	bls.n	8024d92 <__hexnan+0x3e>
 8024e44:	2300      	movs	r3, #0
 8024e46:	f840 3c04 	str.w	r3, [r0, #-4]
 8024e4a:	2101      	movs	r1, #1
 8024e4c:	3804      	subs	r0, #4
 8024e4e:	e7f2      	b.n	8024e36 <__hexnan+0xe2>
 8024e50:	2300      	movs	r3, #0
 8024e52:	f1a0 0804 	sub.w	r8, r0, #4
 8024e56:	f840 3c04 	str.w	r3, [r0, #-4]
 8024e5a:	46f2      	mov	sl, lr
 8024e5c:	4640      	mov	r0, r8
 8024e5e:	4619      	mov	r1, r3
 8024e60:	e797      	b.n	8024d92 <__hexnan+0x3e>
 8024e62:	2b29      	cmp	r3, #41	; 0x29
 8024e64:	d01b      	beq.n	8024e9e <__hexnan+0x14a>
 8024e66:	2004      	movs	r0, #4
 8024e68:	b005      	add	sp, #20
 8024e6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024e6e:	9b03      	ldr	r3, [sp, #12]
 8024e70:	2b00      	cmp	r3, #0
 8024e72:	d0cb      	beq.n	8024e0c <__hexnan+0xb8>
 8024e74:	9c01      	ldr	r4, [sp, #4]
 8024e76:	9b03      	ldr	r3, [sp, #12]
 8024e78:	f854 1c04 	ldr.w	r1, [r4, #-4]
 8024e7c:	f1c3 0320 	rsb	r3, r3, #32
 8024e80:	f04f 30ff 	mov.w	r0, #4294967295
 8024e84:	fa20 f303 	lsr.w	r3, r0, r3
 8024e88:	400b      	ands	r3, r1
 8024e8a:	f844 3c04 	str.w	r3, [r4, #-4]
 8024e8e:	e7c0      	b.n	8024e12 <__hexnan+0xbe>
 8024e90:	2301      	movs	r3, #1
 8024e92:	2005      	movs	r0, #5
 8024e94:	f8cc 3000 	str.w	r3, [ip]
 8024e98:	b005      	add	sp, #20
 8024e9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024e9e:	9b02      	ldr	r3, [sp, #8]
 8024ea0:	3501      	adds	r5, #1
 8024ea2:	601d      	str	r5, [r3, #0]
 8024ea4:	f1be 0f00 	cmp.w	lr, #0
 8024ea8:	d19e      	bne.n	8024de8 <__hexnan+0x94>
 8024eaa:	e7dc      	b.n	8024e66 <__hexnan+0x112>
 8024eac:	f1c1 0308 	rsb	r3, r1, #8
 8024eb0:	009b      	lsls	r3, r3, #2
 8024eb2:	6805      	ldr	r5, [r0, #0]
 8024eb4:	f1c3 0720 	rsb	r7, r3, #32
 8024eb8:	4601      	mov	r1, r0
 8024eba:	684e      	ldr	r6, [r1, #4]
 8024ebc:	fa06 f407 	lsl.w	r4, r6, r7
 8024ec0:	432c      	orrs	r4, r5
 8024ec2:	fa26 f503 	lsr.w	r5, r6, r3
 8024ec6:	600c      	str	r4, [r1, #0]
 8024ec8:	f841 5f04 	str.w	r5, [r1, #4]!
 8024ecc:	4541      	cmp	r1, r8
 8024ece:	d3f4      	bcc.n	8024eba <__hexnan+0x166>
 8024ed0:	e78e      	b.n	8024df0 <__hexnan+0x9c>
 8024ed2:	bf00      	nop
 8024ed4:	0802b808 	.word	0x0802b808

08024ed8 <_findenv_r>:
 8024ed8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8024edc:	4e1f      	ldr	r6, [pc, #124]	; (8024f5c <_findenv_r+0x84>)
 8024ede:	460d      	mov	r5, r1
 8024ee0:	4690      	mov	r8, r2
 8024ee2:	4607      	mov	r7, r0
 8024ee4:	f7ff fc52 	bl	802478c <__env_lock>
 8024ee8:	f8d6 9000 	ldr.w	r9, [r6]
 8024eec:	f1b9 0f00 	cmp.w	r9, #0
 8024ef0:	d020      	beq.n	8024f34 <_findenv_r+0x5c>
 8024ef2:	782c      	ldrb	r4, [r5, #0]
 8024ef4:	b15c      	cbz	r4, 8024f0e <_findenv_r+0x36>
 8024ef6:	2c3d      	cmp	r4, #61	; 0x3d
 8024ef8:	bf18      	it	ne
 8024efa:	462c      	movne	r4, r5
 8024efc:	d102      	bne.n	8024f04 <_findenv_r+0x2c>
 8024efe:	e019      	b.n	8024f34 <_findenv_r+0x5c>
 8024f00:	2b3d      	cmp	r3, #61	; 0x3d
 8024f02:	d017      	beq.n	8024f34 <_findenv_r+0x5c>
 8024f04:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 8024f08:	2b00      	cmp	r3, #0
 8024f0a:	d1f9      	bne.n	8024f00 <_findenv_r+0x28>
 8024f0c:	1b64      	subs	r4, r4, r5
 8024f0e:	f8d9 0000 	ldr.w	r0, [r9]
 8024f12:	b178      	cbz	r0, 8024f34 <_findenv_r+0x5c>
 8024f14:	4629      	mov	r1, r5
 8024f16:	4622      	mov	r2, r4
 8024f18:	f7fe f870 	bl	8022ffc <strncmp>
 8024f1c:	b930      	cbnz	r0, 8024f2c <_findenv_r+0x54>
 8024f1e:	f8d9 0000 	ldr.w	r0, [r9]
 8024f22:	5d03      	ldrb	r3, [r0, r4]
 8024f24:	2b3d      	cmp	r3, #61	; 0x3d
 8024f26:	eb00 0a04 	add.w	sl, r0, r4
 8024f2a:	d009      	beq.n	8024f40 <_findenv_r+0x68>
 8024f2c:	f859 0f04 	ldr.w	r0, [r9, #4]!
 8024f30:	2800      	cmp	r0, #0
 8024f32:	d1ef      	bne.n	8024f14 <_findenv_r+0x3c>
 8024f34:	4638      	mov	r0, r7
 8024f36:	f7ff fc2b 	bl	8024790 <__env_unlock>
 8024f3a:	2000      	movs	r0, #0
 8024f3c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8024f40:	6833      	ldr	r3, [r6, #0]
 8024f42:	ebc3 0909 	rsb	r9, r3, r9
 8024f46:	ea4f 03a9 	mov.w	r3, r9, asr #2
 8024f4a:	4638      	mov	r0, r7
 8024f4c:	f8c8 3000 	str.w	r3, [r8]
 8024f50:	f7ff fc1e 	bl	8024790 <__env_unlock>
 8024f54:	f10a 0001 	add.w	r0, sl, #1
 8024f58:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8024f5c:	20010118 	.word	0x20010118

08024f60 <_getenv_r>:
 8024f60:	b500      	push	{lr}
 8024f62:	b083      	sub	sp, #12
 8024f64:	aa01      	add	r2, sp, #4
 8024f66:	f7ff ffb7 	bl	8024ed8 <_findenv_r>
 8024f6a:	b003      	add	sp, #12
 8024f6c:	f85d fb04 	ldr.w	pc, [sp], #4

08024f70 <__gettzinfo>:
 8024f70:	4800      	ldr	r0, [pc, #0]	; (8024f74 <__gettzinfo+0x4>)
 8024f72:	4770      	bx	lr
 8024f74:	2001011c 	.word	0x2001011c

08024f78 <gmtime_r>:
 8024f78:	6800      	ldr	r0, [r0, #0]
 8024f7a:	4b4c      	ldr	r3, [pc, #304]	; (80250ac <gmtime_r+0x134>)
 8024f7c:	4a4c      	ldr	r2, [pc, #304]	; (80250b0 <gmtime_r+0x138>)
 8024f7e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8024f80:	fb83 4300 	smull	r4, r3, r3, r0
 8024f84:	4403      	add	r3, r0
 8024f86:	17c4      	asrs	r4, r0, #31
 8024f88:	ebc4 4323 	rsb	r3, r4, r3, asr #16
 8024f8c:	fb02 0213 	mls	r2, r2, r3, r0
 8024f90:	2a00      	cmp	r2, #0
 8024f92:	da04      	bge.n	8024f9e <gmtime_r+0x26>
 8024f94:	f502 32a8 	add.w	r2, r2, #86016	; 0x15000
 8024f98:	f502 72c0 	add.w	r2, r2, #384	; 0x180
 8024f9c:	3b01      	subs	r3, #1
 8024f9e:	4845      	ldr	r0, [pc, #276]	; (80250b4 <gmtime_r+0x13c>)
 8024fa0:	4d45      	ldr	r5, [pc, #276]	; (80250b8 <gmtime_r+0x140>)
 8024fa2:	4e46      	ldr	r6, [pc, #280]	; (80250bc <gmtime_r+0x144>)
 8024fa4:	fb80 0e02 	smull	r0, lr, r0, r2
 8024fa8:	eb0e 0002 	add.w	r0, lr, r2
 8024fac:	ea4f 7ee2 	mov.w	lr, r2, asr #31
 8024fb0:	ebce 2ee0 	rsb	lr, lr, r0, asr #11
 8024fb4:	f44f 6061 	mov.w	r0, #3600	; 0xe10
 8024fb8:	fb00 221e 	mls	r2, r0, lr, r2
 8024fbc:	1d1c      	adds	r4, r3, #4
 8024fbe:	fb85 0502 	smull	r0, r5, r5, r2
 8024fc2:	fb84 6706 	smull	r6, r7, r4, r6
 8024fc6:	17d0      	asrs	r0, r2, #31
 8024fc8:	4415      	add	r5, r2
 8024fca:	ebc0 1565 	rsb	r5, r0, r5, asr #5
 8024fce:	4427      	add	r7, r4
 8024fd0:	17e0      	asrs	r0, r4, #31
 8024fd2:	ebc5 1605 	rsb	r6, r5, r5, lsl #4
 8024fd6:	ebc0 00a7 	rsb	r0, r0, r7, asr #2
 8024fda:	eba2 0286 	sub.w	r2, r2, r6, lsl #2
 8024fde:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 8024fe2:	1a20      	subs	r0, r4, r0
 8024fe4:	e881 4024 	stmia.w	r1, {r2, r5, lr}
 8024fe8:	4a35      	ldr	r2, [pc, #212]	; (80250c0 <gmtime_r+0x148>)
 8024fea:	4c36      	ldr	r4, [pc, #216]	; (80250c4 <gmtime_r+0x14c>)
 8024fec:	bf48      	it	mi
 8024fee:	3007      	addmi	r0, #7
 8024ff0:	6188      	str	r0, [r1, #24]
 8024ff2:	fb82 2003 	smull	r2, r0, r2, r3
 8024ff6:	17da      	asrs	r2, r3, #31
 8024ff8:	ebc2 12e0 	rsb	r2, r2, r0, asr #7
 8024ffc:	fb04 3302 	mla	r3, r4, r2, r3
 8025000:	2b00      	cmp	r3, #0
 8025002:	ea4f 0282 	mov.w	r2, r2, lsl #2
 8025006:	f202 72b2 	addw	r2, r2, #1970	; 0x7b2
 802500a:	db46      	blt.n	802509a <gmtime_r+0x122>
 802500c:	f5b3 7fb6 	cmp.w	r3, #364	; 0x16c
 8025010:	dd09      	ble.n	8025026 <gmtime_r+0xae>
 8025012:	4d2d      	ldr	r5, [pc, #180]	; (80250c8 <gmtime_r+0x150>)
 8025014:	f240 146d 	movw	r4, #365	; 0x16d
 8025018:	1b1b      	subs	r3, r3, r4
 802501a:	f855 4f04 	ldr.w	r4, [r5, #4]!
 802501e:	429c      	cmp	r4, r3
 8025020:	f102 0201 	add.w	r2, r2, #1
 8025024:	ddf8      	ble.n	8025018 <gmtime_r+0xa0>
 8025026:	f2a2 706c 	subw	r0, r2, #1900	; 0x76c
 802502a:	6148      	str	r0, [r1, #20]
 802502c:	0790      	lsls	r0, r2, #30
 802502e:	61cb      	str	r3, [r1, #28]
 8025030:	d026      	beq.n	8025080 <gmtime_r+0x108>
 8025032:	17d0      	asrs	r0, r2, #31
 8025034:	4c25      	ldr	r4, [pc, #148]	; (80250cc <gmtime_r+0x154>)
 8025036:	fb84 5402 	smull	r5, r4, r4, r2
 802503a:	ebc0 10e4 	rsb	r0, r0, r4, asr #7
 802503e:	f44f 74c8 	mov.w	r4, #400	; 0x190
 8025042:	fb04 2210 	mls	r2, r4, r0, r2
 8025046:	fab2 f282 	clz	r2, r2
 802504a:	0952      	lsrs	r2, r2, #5
 802504c:	0055      	lsls	r5, r2, #1
 802504e:	4415      	add	r5, r2
 8025050:	012d      	lsls	r5, r5, #4
 8025052:	4c1f      	ldr	r4, [pc, #124]	; (80250d0 <gmtime_r+0x158>)
 8025054:	592a      	ldr	r2, [r5, r4]
 8025056:	2000      	movs	r0, #0
 8025058:	4293      	cmp	r3, r2
 802505a:	4425      	add	r5, r4
 802505c:	6108      	str	r0, [r1, #16]
 802505e:	db09      	blt.n	8025074 <gmtime_r+0xfc>
 8025060:	2401      	movs	r4, #1
 8025062:	1a9b      	subs	r3, r3, r2
 8025064:	f855 2f04 	ldr.w	r2, [r5, #4]!
 8025068:	429a      	cmp	r2, r3
 802506a:	4620      	mov	r0, r4
 802506c:	f104 0401 	add.w	r4, r4, #1
 8025070:	ddf7      	ble.n	8025062 <gmtime_r+0xea>
 8025072:	6108      	str	r0, [r1, #16]
 8025074:	3301      	adds	r3, #1
 8025076:	2200      	movs	r2, #0
 8025078:	60cb      	str	r3, [r1, #12]
 802507a:	620a      	str	r2, [r1, #32]
 802507c:	4608      	mov	r0, r1
 802507e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8025080:	4c12      	ldr	r4, [pc, #72]	; (80250cc <gmtime_r+0x154>)
 8025082:	17d0      	asrs	r0, r2, #31
 8025084:	fb84 5402 	smull	r5, r4, r4, r2
 8025088:	ebc0 1464 	rsb	r4, r0, r4, asr #5
 802508c:	2564      	movs	r5, #100	; 0x64
 802508e:	fb05 2414 	mls	r4, r5, r4, r2
 8025092:	2c00      	cmp	r4, #0
 8025094:	d0ce      	beq.n	8025034 <gmtime_r+0xbc>
 8025096:	2201      	movs	r2, #1
 8025098:	e7d8      	b.n	802504c <gmtime_r+0xd4>
 802509a:	4c0e      	ldr	r4, [pc, #56]	; (80250d4 <gmtime_r+0x15c>)
 802509c:	f854 0904 	ldr.w	r0, [r4], #-4
 80250a0:	181b      	adds	r3, r3, r0
 80250a2:	f102 32ff 	add.w	r2, r2, #4294967295
 80250a6:	d4f9      	bmi.n	802509c <gmtime_r+0x124>
 80250a8:	e7bd      	b.n	8025026 <gmtime_r+0xae>
 80250aa:	bf00      	nop
 80250ac:	c22e4507 	.word	0xc22e4507
 80250b0:	00015180 	.word	0x00015180
 80250b4:	91a2b3c5 	.word	0x91a2b3c5
 80250b8:	88888889 	.word	0x88888889
 80250bc:	92492493 	.word	0x92492493
 80250c0:	166db073 	.word	0x166db073
 80250c4:	fffffa4b 	.word	0xfffffa4b
 80250c8:	0802b908 	.word	0x0802b908
 80250cc:	51eb851f 	.word	0x51eb851f
 80250d0:	0802b58c 	.word	0x0802b58c
 80250d4:	0802b914 	.word	0x0802b914

080250d8 <__locale_charset>:
 80250d8:	4800      	ldr	r0, [pc, #0]	; (80250dc <__locale_charset+0x4>)
 80250da:	4770      	bx	lr
 80250dc:	200105c4 	.word	0x200105c4

080250e0 <__locale_mb_cur_max>:
 80250e0:	4b01      	ldr	r3, [pc, #4]	; (80250e8 <__locale_mb_cur_max+0x8>)
 80250e2:	6818      	ldr	r0, [r3, #0]
 80250e4:	4770      	bx	lr
 80250e6:	bf00      	nop
 80250e8:	200105e4 	.word	0x200105e4

080250ec <_localeconv_r>:
 80250ec:	4800      	ldr	r0, [pc, #0]	; (80250f0 <_localeconv_r+0x4>)
 80250ee:	4770      	bx	lr
 80250f0:	2001058c 	.word	0x2001058c

080250f4 <_Balloc>:
 80250f4:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 80250f6:	b570      	push	{r4, r5, r6, lr}
 80250f8:	4605      	mov	r5, r0
 80250fa:	460c      	mov	r4, r1
 80250fc:	b14b      	cbz	r3, 8025112 <_Balloc+0x1e>
 80250fe:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 8025102:	b180      	cbz	r0, 8025126 <_Balloc+0x32>
 8025104:	6802      	ldr	r2, [r0, #0]
 8025106:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
 802510a:	2300      	movs	r3, #0
 802510c:	6103      	str	r3, [r0, #16]
 802510e:	60c3      	str	r3, [r0, #12]
 8025110:	bd70      	pop	{r4, r5, r6, pc}
 8025112:	2104      	movs	r1, #4
 8025114:	2221      	movs	r2, #33	; 0x21
 8025116:	f7f4 f909 	bl	801932c <_calloc_r>
 802511a:	64e8      	str	r0, [r5, #76]	; 0x4c
 802511c:	4603      	mov	r3, r0
 802511e:	2800      	cmp	r0, #0
 8025120:	d1ed      	bne.n	80250fe <_Balloc+0xa>
 8025122:	2000      	movs	r0, #0
 8025124:	bd70      	pop	{r4, r5, r6, pc}
 8025126:	2101      	movs	r1, #1
 8025128:	fa01 f604 	lsl.w	r6, r1, r4
 802512c:	1d72      	adds	r2, r6, #5
 802512e:	4628      	mov	r0, r5
 8025130:	0092      	lsls	r2, r2, #2
 8025132:	f7f4 f8fb 	bl	801932c <_calloc_r>
 8025136:	2800      	cmp	r0, #0
 8025138:	d0f3      	beq.n	8025122 <_Balloc+0x2e>
 802513a:	6044      	str	r4, [r0, #4]
 802513c:	6086      	str	r6, [r0, #8]
 802513e:	e7e4      	b.n	802510a <_Balloc+0x16>

08025140 <_Bfree>:
 8025140:	b131      	cbz	r1, 8025150 <_Bfree+0x10>
 8025142:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8025144:	684a      	ldr	r2, [r1, #4]
 8025146:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 802514a:	6008      	str	r0, [r1, #0]
 802514c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8025150:	4770      	bx	lr
 8025152:	bf00      	nop

08025154 <__multadd>:
 8025154:	b5f0      	push	{r4, r5, r6, r7, lr}
 8025156:	690c      	ldr	r4, [r1, #16]
 8025158:	b083      	sub	sp, #12
 802515a:	460d      	mov	r5, r1
 802515c:	4606      	mov	r6, r0
 802515e:	f101 0e14 	add.w	lr, r1, #20
 8025162:	2700      	movs	r7, #0
 8025164:	f8de 1000 	ldr.w	r1, [lr]
 8025168:	b288      	uxth	r0, r1
 802516a:	0c09      	lsrs	r1, r1, #16
 802516c:	fb02 3300 	mla	r3, r2, r0, r3
 8025170:	fb02 f101 	mul.w	r1, r2, r1
 8025174:	eb01 4113 	add.w	r1, r1, r3, lsr #16
 8025178:	3701      	adds	r7, #1
 802517a:	b29b      	uxth	r3, r3
 802517c:	eb03 4301 	add.w	r3, r3, r1, lsl #16
 8025180:	42bc      	cmp	r4, r7
 8025182:	f84e 3b04 	str.w	r3, [lr], #4
 8025186:	ea4f 4311 	mov.w	r3, r1, lsr #16
 802518a:	dceb      	bgt.n	8025164 <__multadd+0x10>
 802518c:	b13b      	cbz	r3, 802519e <__multadd+0x4a>
 802518e:	68aa      	ldr	r2, [r5, #8]
 8025190:	4294      	cmp	r4, r2
 8025192:	da07      	bge.n	80251a4 <__multadd+0x50>
 8025194:	eb05 0284 	add.w	r2, r5, r4, lsl #2
 8025198:	3401      	adds	r4, #1
 802519a:	6153      	str	r3, [r2, #20]
 802519c:	612c      	str	r4, [r5, #16]
 802519e:	4628      	mov	r0, r5
 80251a0:	b003      	add	sp, #12
 80251a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80251a4:	6869      	ldr	r1, [r5, #4]
 80251a6:	9301      	str	r3, [sp, #4]
 80251a8:	3101      	adds	r1, #1
 80251aa:	4630      	mov	r0, r6
 80251ac:	f7ff ffa2 	bl	80250f4 <_Balloc>
 80251b0:	692a      	ldr	r2, [r5, #16]
 80251b2:	3202      	adds	r2, #2
 80251b4:	f105 010c 	add.w	r1, r5, #12
 80251b8:	4607      	mov	r7, r0
 80251ba:	0092      	lsls	r2, r2, #2
 80251bc:	300c      	adds	r0, #12
 80251be:	f7db f88f 	bl	80002e0 <memcpy>
 80251c2:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
 80251c4:	6869      	ldr	r1, [r5, #4]
 80251c6:	9b01      	ldr	r3, [sp, #4]
 80251c8:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
 80251cc:	6028      	str	r0, [r5, #0]
 80251ce:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
 80251d2:	463d      	mov	r5, r7
 80251d4:	e7de      	b.n	8025194 <__multadd+0x40>
 80251d6:	bf00      	nop

080251d8 <__s2b>:
 80251d8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80251dc:	4c23      	ldr	r4, [pc, #140]	; (802526c <__s2b+0x94>)
 80251de:	9e08      	ldr	r6, [sp, #32]
 80251e0:	461f      	mov	r7, r3
 80251e2:	3308      	adds	r3, #8
 80251e4:	fb84 4e03 	smull	r4, lr, r4, r3
 80251e8:	17db      	asrs	r3, r3, #31
 80251ea:	ebc3 0e6e 	rsb	lr, r3, lr, asr #1
 80251ee:	f1be 0f01 	cmp.w	lr, #1
 80251f2:	4605      	mov	r5, r0
 80251f4:	460c      	mov	r4, r1
 80251f6:	4690      	mov	r8, r2
 80251f8:	dd35      	ble.n	8025266 <__s2b+0x8e>
 80251fa:	2301      	movs	r3, #1
 80251fc:	2100      	movs	r1, #0
 80251fe:	005b      	lsls	r3, r3, #1
 8025200:	459e      	cmp	lr, r3
 8025202:	f101 0101 	add.w	r1, r1, #1
 8025206:	dcfa      	bgt.n	80251fe <__s2b+0x26>
 8025208:	4628      	mov	r0, r5
 802520a:	f7ff ff73 	bl	80250f4 <_Balloc>
 802520e:	2301      	movs	r3, #1
 8025210:	f1b8 0f09 	cmp.w	r8, #9
 8025214:	6146      	str	r6, [r0, #20]
 8025216:	6103      	str	r3, [r0, #16]
 8025218:	dd21      	ble.n	802525e <__s2b+0x86>
 802521a:	f104 0909 	add.w	r9, r4, #9
 802521e:	464e      	mov	r6, r9
 8025220:	4444      	add	r4, r8
 8025222:	f816 3b01 	ldrb.w	r3, [r6], #1
 8025226:	4601      	mov	r1, r0
 8025228:	3b30      	subs	r3, #48	; 0x30
 802522a:	4628      	mov	r0, r5
 802522c:	220a      	movs	r2, #10
 802522e:	f7ff ff91 	bl	8025154 <__multadd>
 8025232:	42a6      	cmp	r6, r4
 8025234:	d1f5      	bne.n	8025222 <__s2b+0x4a>
 8025236:	eb09 0408 	add.w	r4, r9, r8
 802523a:	3c08      	subs	r4, #8
 802523c:	4547      	cmp	r7, r8
 802523e:	dd0c      	ble.n	802525a <__s2b+0x82>
 8025240:	ebc8 0707 	rsb	r7, r8, r7
 8025244:	4427      	add	r7, r4
 8025246:	f814 3b01 	ldrb.w	r3, [r4], #1
 802524a:	4601      	mov	r1, r0
 802524c:	3b30      	subs	r3, #48	; 0x30
 802524e:	4628      	mov	r0, r5
 8025250:	220a      	movs	r2, #10
 8025252:	f7ff ff7f 	bl	8025154 <__multadd>
 8025256:	42bc      	cmp	r4, r7
 8025258:	d1f5      	bne.n	8025246 <__s2b+0x6e>
 802525a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802525e:	340a      	adds	r4, #10
 8025260:	f04f 0809 	mov.w	r8, #9
 8025264:	e7ea      	b.n	802523c <__s2b+0x64>
 8025266:	2100      	movs	r1, #0
 8025268:	e7ce      	b.n	8025208 <__s2b+0x30>
 802526a:	bf00      	nop
 802526c:	38e38e39 	.word	0x38e38e39

08025270 <__hi0bits>:
 8025270:	0c03      	lsrs	r3, r0, #16
 8025272:	041b      	lsls	r3, r3, #16
 8025274:	b9b3      	cbnz	r3, 80252a4 <__hi0bits+0x34>
 8025276:	0400      	lsls	r0, r0, #16
 8025278:	2310      	movs	r3, #16
 802527a:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
 802527e:	bf04      	itt	eq
 8025280:	0200      	lsleq	r0, r0, #8
 8025282:	3308      	addeq	r3, #8
 8025284:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
 8025288:	bf04      	itt	eq
 802528a:	0100      	lsleq	r0, r0, #4
 802528c:	3304      	addeq	r3, #4
 802528e:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
 8025292:	bf04      	itt	eq
 8025294:	0080      	lsleq	r0, r0, #2
 8025296:	3302      	addeq	r3, #2
 8025298:	2800      	cmp	r0, #0
 802529a:	db07      	blt.n	80252ac <__hi0bits+0x3c>
 802529c:	0042      	lsls	r2, r0, #1
 802529e:	d403      	bmi.n	80252a8 <__hi0bits+0x38>
 80252a0:	2020      	movs	r0, #32
 80252a2:	4770      	bx	lr
 80252a4:	2300      	movs	r3, #0
 80252a6:	e7e8      	b.n	802527a <__hi0bits+0xa>
 80252a8:	1c58      	adds	r0, r3, #1
 80252aa:	4770      	bx	lr
 80252ac:	4618      	mov	r0, r3
 80252ae:	4770      	bx	lr

080252b0 <__lo0bits>:
 80252b0:	6803      	ldr	r3, [r0, #0]
 80252b2:	f013 0207 	ands.w	r2, r3, #7
 80252b6:	d007      	beq.n	80252c8 <__lo0bits+0x18>
 80252b8:	07d9      	lsls	r1, r3, #31
 80252ba:	d420      	bmi.n	80252fe <__lo0bits+0x4e>
 80252bc:	079a      	lsls	r2, r3, #30
 80252be:	d420      	bmi.n	8025302 <__lo0bits+0x52>
 80252c0:	089b      	lsrs	r3, r3, #2
 80252c2:	6003      	str	r3, [r0, #0]
 80252c4:	2002      	movs	r0, #2
 80252c6:	4770      	bx	lr
 80252c8:	b299      	uxth	r1, r3
 80252ca:	b909      	cbnz	r1, 80252d0 <__lo0bits+0x20>
 80252cc:	0c1b      	lsrs	r3, r3, #16
 80252ce:	2210      	movs	r2, #16
 80252d0:	f013 0fff 	tst.w	r3, #255	; 0xff
 80252d4:	bf04      	itt	eq
 80252d6:	0a1b      	lsreq	r3, r3, #8
 80252d8:	3208      	addeq	r2, #8
 80252da:	0719      	lsls	r1, r3, #28
 80252dc:	bf04      	itt	eq
 80252de:	091b      	lsreq	r3, r3, #4
 80252e0:	3204      	addeq	r2, #4
 80252e2:	0799      	lsls	r1, r3, #30
 80252e4:	bf04      	itt	eq
 80252e6:	089b      	lsreq	r3, r3, #2
 80252e8:	3202      	addeq	r2, #2
 80252ea:	07d9      	lsls	r1, r3, #31
 80252ec:	d404      	bmi.n	80252f8 <__lo0bits+0x48>
 80252ee:	085b      	lsrs	r3, r3, #1
 80252f0:	d101      	bne.n	80252f6 <__lo0bits+0x46>
 80252f2:	2020      	movs	r0, #32
 80252f4:	4770      	bx	lr
 80252f6:	3201      	adds	r2, #1
 80252f8:	6003      	str	r3, [r0, #0]
 80252fa:	4610      	mov	r0, r2
 80252fc:	4770      	bx	lr
 80252fe:	2000      	movs	r0, #0
 8025300:	4770      	bx	lr
 8025302:	085b      	lsrs	r3, r3, #1
 8025304:	6003      	str	r3, [r0, #0]
 8025306:	2001      	movs	r0, #1
 8025308:	4770      	bx	lr
 802530a:	bf00      	nop

0802530c <__i2b>:
 802530c:	b510      	push	{r4, lr}
 802530e:	460c      	mov	r4, r1
 8025310:	2101      	movs	r1, #1
 8025312:	f7ff feef 	bl	80250f4 <_Balloc>
 8025316:	2201      	movs	r2, #1
 8025318:	6144      	str	r4, [r0, #20]
 802531a:	6102      	str	r2, [r0, #16]
 802531c:	bd10      	pop	{r4, pc}
 802531e:	bf00      	nop

08025320 <__multiply>:
 8025320:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025324:	690f      	ldr	r7, [r1, #16]
 8025326:	6916      	ldr	r6, [r2, #16]
 8025328:	42b7      	cmp	r7, r6
 802532a:	b083      	sub	sp, #12
 802532c:	460d      	mov	r5, r1
 802532e:	4614      	mov	r4, r2
 8025330:	f2c0 808d 	blt.w	802544e <__multiply+0x12e>
 8025334:	4633      	mov	r3, r6
 8025336:	463e      	mov	r6, r7
 8025338:	461f      	mov	r7, r3
 802533a:	68ab      	ldr	r3, [r5, #8]
 802533c:	6869      	ldr	r1, [r5, #4]
 802533e:	eb06 0807 	add.w	r8, r6, r7
 8025342:	4598      	cmp	r8, r3
 8025344:	bfc8      	it	gt
 8025346:	3101      	addgt	r1, #1
 8025348:	f7ff fed4 	bl	80250f4 <_Balloc>
 802534c:	f100 0c14 	add.w	ip, r0, #20
 8025350:	eb0c 0988 	add.w	r9, ip, r8, lsl #2
 8025354:	45cc      	cmp	ip, r9
 8025356:	9000      	str	r0, [sp, #0]
 8025358:	d205      	bcs.n	8025366 <__multiply+0x46>
 802535a:	4663      	mov	r3, ip
 802535c:	2100      	movs	r1, #0
 802535e:	f843 1b04 	str.w	r1, [r3], #4
 8025362:	4599      	cmp	r9, r3
 8025364:	d8fb      	bhi.n	802535e <__multiply+0x3e>
 8025366:	f104 0214 	add.w	r2, r4, #20
 802536a:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
 802536e:	f105 0314 	add.w	r3, r5, #20
 8025372:	4552      	cmp	r2, sl
 8025374:	eb03 0e86 	add.w	lr, r3, r6, lsl #2
 8025378:	d254      	bcs.n	8025424 <__multiply+0x104>
 802537a:	f8cd 9004 	str.w	r9, [sp, #4]
 802537e:	4699      	mov	r9, r3
 8025380:	f852 3b04 	ldr.w	r3, [r2], #4
 8025384:	fa1f fb83 	uxth.w	fp, r3
 8025388:	f1bb 0f00 	cmp.w	fp, #0
 802538c:	d020      	beq.n	80253d0 <__multiply+0xb0>
 802538e:	2000      	movs	r0, #0
 8025390:	464f      	mov	r7, r9
 8025392:	4666      	mov	r6, ip
 8025394:	4605      	mov	r5, r0
 8025396:	e000      	b.n	802539a <__multiply+0x7a>
 8025398:	461e      	mov	r6, r3
 802539a:	f857 4b04 	ldr.w	r4, [r7], #4
 802539e:	6830      	ldr	r0, [r6, #0]
 80253a0:	b2a1      	uxth	r1, r4
 80253a2:	b283      	uxth	r3, r0
 80253a4:	fb0b 3101 	mla	r1, fp, r1, r3
 80253a8:	0c24      	lsrs	r4, r4, #16
 80253aa:	0c00      	lsrs	r0, r0, #16
 80253ac:	194b      	adds	r3, r1, r5
 80253ae:	fb0b 0004 	mla	r0, fp, r4, r0
 80253b2:	eb00 4013 	add.w	r0, r0, r3, lsr #16
 80253b6:	b299      	uxth	r1, r3
 80253b8:	4633      	mov	r3, r6
 80253ba:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 80253be:	45be      	cmp	lr, r7
 80253c0:	ea4f 4510 	mov.w	r5, r0, lsr #16
 80253c4:	f843 1b04 	str.w	r1, [r3], #4
 80253c8:	d8e6      	bhi.n	8025398 <__multiply+0x78>
 80253ca:	6075      	str	r5, [r6, #4]
 80253cc:	f852 3c04 	ldr.w	r3, [r2, #-4]
 80253d0:	ea5f 4b13 	movs.w	fp, r3, lsr #16
 80253d4:	d020      	beq.n	8025418 <__multiply+0xf8>
 80253d6:	f8dc 3000 	ldr.w	r3, [ip]
 80253da:	4667      	mov	r7, ip
 80253dc:	4618      	mov	r0, r3
 80253de:	464d      	mov	r5, r9
 80253e0:	2100      	movs	r1, #0
 80253e2:	e000      	b.n	80253e6 <__multiply+0xc6>
 80253e4:	4637      	mov	r7, r6
 80253e6:	882c      	ldrh	r4, [r5, #0]
 80253e8:	0c00      	lsrs	r0, r0, #16
 80253ea:	fb0b 0004 	mla	r0, fp, r4, r0
 80253ee:	4401      	add	r1, r0
 80253f0:	b29c      	uxth	r4, r3
 80253f2:	463e      	mov	r6, r7
 80253f4:	ea44 4301 	orr.w	r3, r4, r1, lsl #16
 80253f8:	f846 3b04 	str.w	r3, [r6], #4
 80253fc:	6878      	ldr	r0, [r7, #4]
 80253fe:	f855 4b04 	ldr.w	r4, [r5], #4
 8025402:	b283      	uxth	r3, r0
 8025404:	0c24      	lsrs	r4, r4, #16
 8025406:	fb0b 3404 	mla	r4, fp, r4, r3
 802540a:	eb04 4311 	add.w	r3, r4, r1, lsr #16
 802540e:	45ae      	cmp	lr, r5
 8025410:	ea4f 4113 	mov.w	r1, r3, lsr #16
 8025414:	d8e6      	bhi.n	80253e4 <__multiply+0xc4>
 8025416:	607b      	str	r3, [r7, #4]
 8025418:	4592      	cmp	sl, r2
 802541a:	f10c 0c04 	add.w	ip, ip, #4
 802541e:	d8af      	bhi.n	8025380 <__multiply+0x60>
 8025420:	f8dd 9004 	ldr.w	r9, [sp, #4]
 8025424:	f1b8 0f00 	cmp.w	r8, #0
 8025428:	dd0b      	ble.n	8025442 <__multiply+0x122>
 802542a:	f859 3c04 	ldr.w	r3, [r9, #-4]
 802542e:	f1a9 0904 	sub.w	r9, r9, #4
 8025432:	b11b      	cbz	r3, 802543c <__multiply+0x11c>
 8025434:	e005      	b.n	8025442 <__multiply+0x122>
 8025436:	f859 3d04 	ldr.w	r3, [r9, #-4]!
 802543a:	b913      	cbnz	r3, 8025442 <__multiply+0x122>
 802543c:	f1b8 0801 	subs.w	r8, r8, #1
 8025440:	d1f9      	bne.n	8025436 <__multiply+0x116>
 8025442:	9800      	ldr	r0, [sp, #0]
 8025444:	f8c0 8010 	str.w	r8, [r0, #16]
 8025448:	b003      	add	sp, #12
 802544a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802544e:	4615      	mov	r5, r2
 8025450:	460c      	mov	r4, r1
 8025452:	e772      	b.n	802533a <__multiply+0x1a>

08025454 <__pow5mult>:
 8025454:	f012 0303 	ands.w	r3, r2, #3
 8025458:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802545c:	4614      	mov	r4, r2
 802545e:	4607      	mov	r7, r0
 8025460:	460e      	mov	r6, r1
 8025462:	d12d      	bne.n	80254c0 <__pow5mult+0x6c>
 8025464:	10a4      	asrs	r4, r4, #2
 8025466:	d01c      	beq.n	80254a2 <__pow5mult+0x4e>
 8025468:	6cbd      	ldr	r5, [r7, #72]	; 0x48
 802546a:	b395      	cbz	r5, 80254d2 <__pow5mult+0x7e>
 802546c:	07e3      	lsls	r3, r4, #31
 802546e:	f04f 0800 	mov.w	r8, #0
 8025472:	d406      	bmi.n	8025482 <__pow5mult+0x2e>
 8025474:	1064      	asrs	r4, r4, #1
 8025476:	d014      	beq.n	80254a2 <__pow5mult+0x4e>
 8025478:	6828      	ldr	r0, [r5, #0]
 802547a:	b1a8      	cbz	r0, 80254a8 <__pow5mult+0x54>
 802547c:	4605      	mov	r5, r0
 802547e:	07e3      	lsls	r3, r4, #31
 8025480:	d5f8      	bpl.n	8025474 <__pow5mult+0x20>
 8025482:	4638      	mov	r0, r7
 8025484:	4631      	mov	r1, r6
 8025486:	462a      	mov	r2, r5
 8025488:	f7ff ff4a 	bl	8025320 <__multiply>
 802548c:	b1b6      	cbz	r6, 80254bc <__pow5mult+0x68>
 802548e:	6872      	ldr	r2, [r6, #4]
 8025490:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8025492:	1064      	asrs	r4, r4, #1
 8025494:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8025498:	6031      	str	r1, [r6, #0]
 802549a:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
 802549e:	4606      	mov	r6, r0
 80254a0:	d1ea      	bne.n	8025478 <__pow5mult+0x24>
 80254a2:	4630      	mov	r0, r6
 80254a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80254a8:	4629      	mov	r1, r5
 80254aa:	462a      	mov	r2, r5
 80254ac:	4638      	mov	r0, r7
 80254ae:	f7ff ff37 	bl	8025320 <__multiply>
 80254b2:	6028      	str	r0, [r5, #0]
 80254b4:	f8c0 8000 	str.w	r8, [r0]
 80254b8:	4605      	mov	r5, r0
 80254ba:	e7e0      	b.n	802547e <__pow5mult+0x2a>
 80254bc:	4606      	mov	r6, r0
 80254be:	e7d9      	b.n	8025474 <__pow5mult+0x20>
 80254c0:	1e5a      	subs	r2, r3, #1
 80254c2:	4d0b      	ldr	r5, [pc, #44]	; (80254f0 <__pow5mult+0x9c>)
 80254c4:	2300      	movs	r3, #0
 80254c6:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
 80254ca:	f7ff fe43 	bl	8025154 <__multadd>
 80254ce:	4606      	mov	r6, r0
 80254d0:	e7c8      	b.n	8025464 <__pow5mult+0x10>
 80254d2:	2101      	movs	r1, #1
 80254d4:	4638      	mov	r0, r7
 80254d6:	f7ff fe0d 	bl	80250f4 <_Balloc>
 80254da:	f240 2171 	movw	r1, #625	; 0x271
 80254de:	2201      	movs	r2, #1
 80254e0:	2300      	movs	r3, #0
 80254e2:	6141      	str	r1, [r0, #20]
 80254e4:	6102      	str	r2, [r0, #16]
 80254e6:	4605      	mov	r5, r0
 80254e8:	64b8      	str	r0, [r7, #72]	; 0x48
 80254ea:	6003      	str	r3, [r0, #0]
 80254ec:	e7be      	b.n	802546c <__pow5mult+0x18>
 80254ee:	bf00      	nop
 80254f0:	0802ba18 	.word	0x0802ba18

080254f4 <__lshift>:
 80254f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80254f8:	690f      	ldr	r7, [r1, #16]
 80254fa:	688b      	ldr	r3, [r1, #8]
 80254fc:	ea4f 1962 	mov.w	r9, r2, asr #5
 8025500:	444f      	add	r7, r9
 8025502:	1c7d      	adds	r5, r7, #1
 8025504:	429d      	cmp	r5, r3
 8025506:	460e      	mov	r6, r1
 8025508:	4614      	mov	r4, r2
 802550a:	6849      	ldr	r1, [r1, #4]
 802550c:	4680      	mov	r8, r0
 802550e:	dd04      	ble.n	802551a <__lshift+0x26>
 8025510:	005b      	lsls	r3, r3, #1
 8025512:	429d      	cmp	r5, r3
 8025514:	f101 0101 	add.w	r1, r1, #1
 8025518:	dcfa      	bgt.n	8025510 <__lshift+0x1c>
 802551a:	4640      	mov	r0, r8
 802551c:	f7ff fdea 	bl	80250f4 <_Balloc>
 8025520:	f1b9 0f00 	cmp.w	r9, #0
 8025524:	f100 0114 	add.w	r1, r0, #20
 8025528:	dd09      	ble.n	802553e <__lshift+0x4a>
 802552a:	2300      	movs	r3, #0
 802552c:	469e      	mov	lr, r3
 802552e:	460a      	mov	r2, r1
 8025530:	3301      	adds	r3, #1
 8025532:	454b      	cmp	r3, r9
 8025534:	f842 eb04 	str.w	lr, [r2], #4
 8025538:	d1fa      	bne.n	8025530 <__lshift+0x3c>
 802553a:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 802553e:	6932      	ldr	r2, [r6, #16]
 8025540:	f106 0314 	add.w	r3, r6, #20
 8025544:	f014 0c1f 	ands.w	ip, r4, #31
 8025548:	eb03 0e82 	add.w	lr, r3, r2, lsl #2
 802554c:	d01f      	beq.n	802558e <__lshift+0x9a>
 802554e:	f1cc 0920 	rsb	r9, ip, #32
 8025552:	2200      	movs	r2, #0
 8025554:	681c      	ldr	r4, [r3, #0]
 8025556:	fa04 f40c 	lsl.w	r4, r4, ip
 802555a:	4314      	orrs	r4, r2
 802555c:	468a      	mov	sl, r1
 802555e:	f841 4b04 	str.w	r4, [r1], #4
 8025562:	f853 4b04 	ldr.w	r4, [r3], #4
 8025566:	459e      	cmp	lr, r3
 8025568:	fa24 f209 	lsr.w	r2, r4, r9
 802556c:	d8f2      	bhi.n	8025554 <__lshift+0x60>
 802556e:	f8ca 2004 	str.w	r2, [sl, #4]
 8025572:	b102      	cbz	r2, 8025576 <__lshift+0x82>
 8025574:	1cbd      	adds	r5, r7, #2
 8025576:	f8d8 304c 	ldr.w	r3, [r8, #76]	; 0x4c
 802557a:	6872      	ldr	r2, [r6, #4]
 802557c:	3d01      	subs	r5, #1
 802557e:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8025582:	6105      	str	r5, [r0, #16]
 8025584:	6031      	str	r1, [r6, #0]
 8025586:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
 802558a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802558e:	3904      	subs	r1, #4
 8025590:	f853 2b04 	ldr.w	r2, [r3], #4
 8025594:	f841 2f04 	str.w	r2, [r1, #4]!
 8025598:	459e      	cmp	lr, r3
 802559a:	d8f9      	bhi.n	8025590 <__lshift+0x9c>
 802559c:	e7eb      	b.n	8025576 <__lshift+0x82>
 802559e:	bf00      	nop

080255a0 <__mcmp>:
 80255a0:	6902      	ldr	r2, [r0, #16]
 80255a2:	690b      	ldr	r3, [r1, #16]
 80255a4:	1ad2      	subs	r2, r2, r3
 80255a6:	d113      	bne.n	80255d0 <__mcmp+0x30>
 80255a8:	009b      	lsls	r3, r3, #2
 80255aa:	3014      	adds	r0, #20
 80255ac:	3114      	adds	r1, #20
 80255ae:	4419      	add	r1, r3
 80255b0:	b410      	push	{r4}
 80255b2:	4403      	add	r3, r0
 80255b4:	e001      	b.n	80255ba <__mcmp+0x1a>
 80255b6:	4298      	cmp	r0, r3
 80255b8:	d20c      	bcs.n	80255d4 <__mcmp+0x34>
 80255ba:	f853 4d04 	ldr.w	r4, [r3, #-4]!
 80255be:	f851 2d04 	ldr.w	r2, [r1, #-4]!
 80255c2:	4294      	cmp	r4, r2
 80255c4:	d0f7      	beq.n	80255b6 <__mcmp+0x16>
 80255c6:	d309      	bcc.n	80255dc <__mcmp+0x3c>
 80255c8:	2001      	movs	r0, #1
 80255ca:	f85d 4b04 	ldr.w	r4, [sp], #4
 80255ce:	4770      	bx	lr
 80255d0:	4610      	mov	r0, r2
 80255d2:	4770      	bx	lr
 80255d4:	2000      	movs	r0, #0
 80255d6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80255da:	4770      	bx	lr
 80255dc:	f04f 30ff 	mov.w	r0, #4294967295
 80255e0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80255e4:	4770      	bx	lr
 80255e6:	bf00      	nop

080255e8 <__mdiff>:
 80255e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80255ec:	460e      	mov	r6, r1
 80255ee:	4605      	mov	r5, r0
 80255f0:	4611      	mov	r1, r2
 80255f2:	4630      	mov	r0, r6
 80255f4:	4614      	mov	r4, r2
 80255f6:	f7ff ffd3 	bl	80255a0 <__mcmp>
 80255fa:	1e07      	subs	r7, r0, #0
 80255fc:	d054      	beq.n	80256a8 <__mdiff+0xc0>
 80255fe:	db4d      	blt.n	802569c <__mdiff+0xb4>
 8025600:	f04f 0800 	mov.w	r8, #0
 8025604:	6871      	ldr	r1, [r6, #4]
 8025606:	4628      	mov	r0, r5
 8025608:	f7ff fd74 	bl	80250f4 <_Balloc>
 802560c:	6937      	ldr	r7, [r6, #16]
 802560e:	6923      	ldr	r3, [r4, #16]
 8025610:	f8c0 800c 	str.w	r8, [r0, #12]
 8025614:	3614      	adds	r6, #20
 8025616:	f104 0214 	add.w	r2, r4, #20
 802561a:	eb02 0c83 	add.w	ip, r2, r3, lsl #2
 802561e:	f100 0514 	add.w	r5, r0, #20
 8025622:	eb06 0e87 	add.w	lr, r6, r7, lsl #2
 8025626:	2300      	movs	r3, #0
 8025628:	f856 8b04 	ldr.w	r8, [r6], #4
 802562c:	f852 4b04 	ldr.w	r4, [r2], #4
 8025630:	fa13 f388 	uxtah	r3, r3, r8
 8025634:	b2a1      	uxth	r1, r4
 8025636:	0c24      	lsrs	r4, r4, #16
 8025638:	1a59      	subs	r1, r3, r1
 802563a:	ebc4 4318 	rsb	r3, r4, r8, lsr #16
 802563e:	eb03 4321 	add.w	r3, r3, r1, asr #16
 8025642:	b289      	uxth	r1, r1
 8025644:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8025648:	4594      	cmp	ip, r2
 802564a:	f845 1b04 	str.w	r1, [r5], #4
 802564e:	ea4f 4323 	mov.w	r3, r3, asr #16
 8025652:	4634      	mov	r4, r6
 8025654:	d8e8      	bhi.n	8025628 <__mdiff+0x40>
 8025656:	45b6      	cmp	lr, r6
 8025658:	46ac      	mov	ip, r5
 802565a:	d915      	bls.n	8025688 <__mdiff+0xa0>
 802565c:	f854 2b04 	ldr.w	r2, [r4], #4
 8025660:	fa13 f182 	uxtah	r1, r3, r2
 8025664:	0c13      	lsrs	r3, r2, #16
 8025666:	eb03 4321 	add.w	r3, r3, r1, asr #16
 802566a:	b289      	uxth	r1, r1
 802566c:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8025670:	45a6      	cmp	lr, r4
 8025672:	f845 1b04 	str.w	r1, [r5], #4
 8025676:	ea4f 4323 	mov.w	r3, r3, asr #16
 802567a:	d8ef      	bhi.n	802565c <__mdiff+0x74>
 802567c:	43f6      	mvns	r6, r6
 802567e:	4476      	add	r6, lr
 8025680:	f026 0503 	bic.w	r5, r6, #3
 8025684:	3504      	adds	r5, #4
 8025686:	4465      	add	r5, ip
 8025688:	3d04      	subs	r5, #4
 802568a:	b921      	cbnz	r1, 8025696 <__mdiff+0xae>
 802568c:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 8025690:	3f01      	subs	r7, #1
 8025692:	2b00      	cmp	r3, #0
 8025694:	d0fa      	beq.n	802568c <__mdiff+0xa4>
 8025696:	6107      	str	r7, [r0, #16]
 8025698:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802569c:	4633      	mov	r3, r6
 802569e:	f04f 0801 	mov.w	r8, #1
 80256a2:	4626      	mov	r6, r4
 80256a4:	461c      	mov	r4, r3
 80256a6:	e7ad      	b.n	8025604 <__mdiff+0x1c>
 80256a8:	4628      	mov	r0, r5
 80256aa:	4639      	mov	r1, r7
 80256ac:	f7ff fd22 	bl	80250f4 <_Balloc>
 80256b0:	2301      	movs	r3, #1
 80256b2:	6147      	str	r7, [r0, #20]
 80256b4:	6103      	str	r3, [r0, #16]
 80256b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80256ba:	bf00      	nop

080256bc <__ulp>:
 80256bc:	4b12      	ldr	r3, [pc, #72]	; (8025708 <__ulp+0x4c>)
 80256be:	ee10 2a90 	vmov	r2, s1
 80256c2:	401a      	ands	r2, r3
 80256c4:	f1a2 7350 	sub.w	r3, r2, #54525952	; 0x3400000
 80256c8:	2b00      	cmp	r3, #0
 80256ca:	dd04      	ble.n	80256d6 <__ulp+0x1a>
 80256cc:	2000      	movs	r0, #0
 80256ce:	4619      	mov	r1, r3
 80256d0:	ec41 0b10 	vmov	d0, r0, r1
 80256d4:	4770      	bx	lr
 80256d6:	425b      	negs	r3, r3
 80256d8:	151b      	asrs	r3, r3, #20
 80256da:	2b13      	cmp	r3, #19
 80256dc:	dd0c      	ble.n	80256f8 <__ulp+0x3c>
 80256de:	2b32      	cmp	r3, #50	; 0x32
 80256e0:	bfdd      	ittte	le
 80256e2:	f1c3 0333 	rsble	r3, r3, #51	; 0x33
 80256e6:	2201      	movle	r2, #1
 80256e8:	fa02 f303 	lslle.w	r3, r2, r3
 80256ec:	2301      	movgt	r3, #1
 80256ee:	2100      	movs	r1, #0
 80256f0:	4618      	mov	r0, r3
 80256f2:	ec41 0b10 	vmov	d0, r0, r1
 80256f6:	4770      	bx	lr
 80256f8:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 80256fc:	2000      	movs	r0, #0
 80256fe:	fa42 f103 	asr.w	r1, r2, r3
 8025702:	ec41 0b10 	vmov	d0, r0, r1
 8025706:	4770      	bx	lr
 8025708:	7ff00000 	.word	0x7ff00000

0802570c <__b2d>:
 802570c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802570e:	6904      	ldr	r4, [r0, #16]
 8025710:	f100 0714 	add.w	r7, r0, #20
 8025714:	eb07 0484 	add.w	r4, r7, r4, lsl #2
 8025718:	460d      	mov	r5, r1
 802571a:	f854 6c04 	ldr.w	r6, [r4, #-4]
 802571e:	4630      	mov	r0, r6
 8025720:	f7ff fda6 	bl	8025270 <__hi0bits>
 8025724:	f1c0 0320 	rsb	r3, r0, #32
 8025728:	280a      	cmp	r0, #10
 802572a:	602b      	str	r3, [r5, #0]
 802572c:	f1a4 0104 	sub.w	r1, r4, #4
 8025730:	dc16      	bgt.n	8025760 <__b2d+0x54>
 8025732:	428f      	cmp	r7, r1
 8025734:	f1c0 050b 	rsb	r5, r0, #11
 8025738:	bf38      	it	cc
 802573a:	f854 1c08 	ldrcc.w	r1, [r4, #-8]
 802573e:	fa26 fe05 	lsr.w	lr, r6, r5
 8025742:	f100 0015 	add.w	r0, r0, #21
 8025746:	f04e 537f 	orr.w	r3, lr, #1069547520	; 0x3fc00000
 802574a:	bf34      	ite	cc
 802574c:	40e9      	lsrcc	r1, r5
 802574e:	2100      	movcs	r1, #0
 8025750:	4086      	lsls	r6, r0
 8025752:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
 8025756:	ea41 0206 	orr.w	r2, r1, r6
 802575a:	ec43 2b10 	vmov	d0, r2, r3
 802575e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8025760:	428f      	cmp	r7, r1
 8025762:	d220      	bcs.n	80257a6 <__b2d+0x9a>
 8025764:	f1b0 0e0b 	subs.w	lr, r0, #11
 8025768:	f1a4 0c08 	sub.w	ip, r4, #8
 802576c:	f854 1c08 	ldr.w	r1, [r4, #-8]
 8025770:	d026      	beq.n	80257c0 <__b2d+0xb4>
 8025772:	f1c0 052b 	rsb	r5, r0, #43	; 0x2b
 8025776:	4567      	cmp	r7, ip
 8025778:	fa21 f305 	lsr.w	r3, r1, r5
 802577c:	fa06 f60e 	lsl.w	r6, r6, lr
 8025780:	ea46 0603 	orr.w	r6, r6, r3
 8025784:	bf38      	it	cc
 8025786:	f854 0c0c 	ldrcc.w	r0, [r4, #-12]
 802578a:	f046 537f 	orr.w	r3, r6, #1069547520	; 0x3fc00000
 802578e:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
 8025792:	bf34      	ite	cc
 8025794:	40e8      	lsrcc	r0, r5
 8025796:	2000      	movcs	r0, #0
 8025798:	fa01 f10e 	lsl.w	r1, r1, lr
 802579c:	ea41 0200 	orr.w	r2, r1, r0
 80257a0:	ec43 2b10 	vmov	d0, r2, r3
 80257a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80257a6:	f1b0 0e0b 	subs.w	lr, r0, #11
 80257aa:	d008      	beq.n	80257be <__b2d+0xb2>
 80257ac:	fa06 f60e 	lsl.w	r6, r6, lr
 80257b0:	f046 537f 	orr.w	r3, r6, #1069547520	; 0x3fc00000
 80257b4:	2000      	movs	r0, #0
 80257b6:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
 80257ba:	4601      	mov	r1, r0
 80257bc:	e7ec      	b.n	8025798 <__b2d+0x8c>
 80257be:	4671      	mov	r1, lr
 80257c0:	f046 537f 	orr.w	r3, r6, #1069547520	; 0x3fc00000
 80257c4:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
 80257c8:	460a      	mov	r2, r1
 80257ca:	ec43 2b10 	vmov	d0, r2, r3
 80257ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080257d0 <__d2b>:
 80257d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80257d4:	ec57 6b10 	vmov	r6, r7, d0
 80257d8:	b083      	sub	sp, #12
 80257da:	4688      	mov	r8, r1
 80257dc:	2101      	movs	r1, #1
 80257de:	463c      	mov	r4, r7
 80257e0:	f3c7 550a 	ubfx	r5, r7, #20, #11
 80257e4:	4617      	mov	r7, r2
 80257e6:	f7ff fc85 	bl	80250f4 <_Balloc>
 80257ea:	f3c4 0413 	ubfx	r4, r4, #0, #20
 80257ee:	4681      	mov	r9, r0
 80257f0:	b10d      	cbz	r5, 80257f6 <__d2b+0x26>
 80257f2:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
 80257f6:	9401      	str	r4, [sp, #4]
 80257f8:	b31e      	cbz	r6, 8025842 <__d2b+0x72>
 80257fa:	a802      	add	r0, sp, #8
 80257fc:	f840 6d08 	str.w	r6, [r0, #-8]!
 8025800:	f7ff fd56 	bl	80252b0 <__lo0bits>
 8025804:	2800      	cmp	r0, #0
 8025806:	d134      	bne.n	8025872 <__d2b+0xa2>
 8025808:	e89d 000c 	ldmia.w	sp, {r2, r3}
 802580c:	f8c9 2014 	str.w	r2, [r9, #20]
 8025810:	2b00      	cmp	r3, #0
 8025812:	bf14      	ite	ne
 8025814:	2402      	movne	r4, #2
 8025816:	2401      	moveq	r4, #1
 8025818:	f8c9 3018 	str.w	r3, [r9, #24]
 802581c:	f8c9 4010 	str.w	r4, [r9, #16]
 8025820:	b9dd      	cbnz	r5, 802585a <__d2b+0x8a>
 8025822:	eb09 0384 	add.w	r3, r9, r4, lsl #2
 8025826:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 802582a:	f8c8 0000 	str.w	r0, [r8]
 802582e:	6918      	ldr	r0, [r3, #16]
 8025830:	f7ff fd1e 	bl	8025270 <__hi0bits>
 8025834:	ebc0 1044 	rsb	r0, r0, r4, lsl #5
 8025838:	6038      	str	r0, [r7, #0]
 802583a:	4648      	mov	r0, r9
 802583c:	b003      	add	sp, #12
 802583e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8025842:	a801      	add	r0, sp, #4
 8025844:	f7ff fd34 	bl	80252b0 <__lo0bits>
 8025848:	2401      	movs	r4, #1
 802584a:	9b01      	ldr	r3, [sp, #4]
 802584c:	f8c9 3014 	str.w	r3, [r9, #20]
 8025850:	3020      	adds	r0, #32
 8025852:	f8c9 4010 	str.w	r4, [r9, #16]
 8025856:	2d00      	cmp	r5, #0
 8025858:	d0e3      	beq.n	8025822 <__d2b+0x52>
 802585a:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
 802585e:	4405      	add	r5, r0
 8025860:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 8025864:	f8c8 5000 	str.w	r5, [r8]
 8025868:	6038      	str	r0, [r7, #0]
 802586a:	4648      	mov	r0, r9
 802586c:	b003      	add	sp, #12
 802586e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8025872:	e89d 000c 	ldmia.w	sp, {r2, r3}
 8025876:	f1c0 0120 	rsb	r1, r0, #32
 802587a:	fa03 f101 	lsl.w	r1, r3, r1
 802587e:	430a      	orrs	r2, r1
 8025880:	40c3      	lsrs	r3, r0
 8025882:	9301      	str	r3, [sp, #4]
 8025884:	f8c9 2014 	str.w	r2, [r9, #20]
 8025888:	e7c2      	b.n	8025810 <__d2b+0x40>
 802588a:	bf00      	nop

0802588c <__ratio>:
 802588c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8025890:	b083      	sub	sp, #12
 8025892:	4688      	mov	r8, r1
 8025894:	4669      	mov	r1, sp
 8025896:	4681      	mov	r9, r0
 8025898:	f7ff ff38 	bl	802570c <__b2d>
 802589c:	4640      	mov	r0, r8
 802589e:	a901      	add	r1, sp, #4
 80258a0:	ec55 4b10 	vmov	r4, r5, d0
 80258a4:	f7ff ff32 	bl	802570c <__b2d>
 80258a8:	e89d 000a 	ldmia.w	sp, {r1, r3}
 80258ac:	f8d9 2010 	ldr.w	r2, [r9, #16]
 80258b0:	f8d8 0010 	ldr.w	r0, [r8, #16]
 80258b4:	1ac9      	subs	r1, r1, r3
 80258b6:	1a12      	subs	r2, r2, r0
 80258b8:	eb01 1342 	add.w	r3, r1, r2, lsl #5
 80258bc:	2b00      	cmp	r3, #0
 80258be:	ec57 6b10 	vmov	r6, r7, d0
 80258c2:	dd0d      	ble.n	80258e0 <__ratio+0x54>
 80258c4:	eb05 5103 	add.w	r1, r5, r3, lsl #20
 80258c8:	460d      	mov	r5, r1
 80258ca:	4620      	mov	r0, r4
 80258cc:	4629      	mov	r1, r5
 80258ce:	4632      	mov	r2, r6
 80258d0:	463b      	mov	r3, r7
 80258d2:	f7db f9f7 	bl	8000cc4 <__aeabi_ddiv>
 80258d6:	ec41 0b10 	vmov	d0, r0, r1
 80258da:	b003      	add	sp, #12
 80258dc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80258e0:	eba7 5903 	sub.w	r9, r7, r3, lsl #20
 80258e4:	ee10 6a10 	vmov	r6, s0
 80258e8:	464f      	mov	r7, r9
 80258ea:	e7ee      	b.n	80258ca <__ratio+0x3e>

080258ec <__copybits>:
 80258ec:	b470      	push	{r4, r5, r6}
 80258ee:	6914      	ldr	r4, [r2, #16]
 80258f0:	f102 0314 	add.w	r3, r2, #20
 80258f4:	3901      	subs	r1, #1
 80258f6:	114e      	asrs	r6, r1, #5
 80258f8:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 80258fc:	3601      	adds	r6, #1
 80258fe:	42a3      	cmp	r3, r4
 8025900:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 8025904:	d20c      	bcs.n	8025920 <__copybits+0x34>
 8025906:	1f01      	subs	r1, r0, #4
 8025908:	f853 5b04 	ldr.w	r5, [r3], #4
 802590c:	f841 5f04 	str.w	r5, [r1, #4]!
 8025910:	429c      	cmp	r4, r3
 8025912:	d8f9      	bhi.n	8025908 <__copybits+0x1c>
 8025914:	1aa3      	subs	r3, r4, r2
 8025916:	3b15      	subs	r3, #21
 8025918:	f023 0303 	bic.w	r3, r3, #3
 802591c:	3304      	adds	r3, #4
 802591e:	4418      	add	r0, r3
 8025920:	4286      	cmp	r6, r0
 8025922:	d904      	bls.n	802592e <__copybits+0x42>
 8025924:	2300      	movs	r3, #0
 8025926:	f840 3b04 	str.w	r3, [r0], #4
 802592a:	4286      	cmp	r6, r0
 802592c:	d8fb      	bhi.n	8025926 <__copybits+0x3a>
 802592e:	bc70      	pop	{r4, r5, r6}
 8025930:	4770      	bx	lr
 8025932:	bf00      	nop

08025934 <__any_on>:
 8025934:	6903      	ldr	r3, [r0, #16]
 8025936:	114a      	asrs	r2, r1, #5
 8025938:	4293      	cmp	r3, r2
 802593a:	b410      	push	{r4}
 802593c:	f100 0414 	add.w	r4, r0, #20
 8025940:	da10      	bge.n	8025964 <__any_on+0x30>
 8025942:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8025946:	429c      	cmp	r4, r3
 8025948:	d221      	bcs.n	802598e <__any_on+0x5a>
 802594a:	f853 0c04 	ldr.w	r0, [r3, #-4]
 802594e:	3b04      	subs	r3, #4
 8025950:	b118      	cbz	r0, 802595a <__any_on+0x26>
 8025952:	e015      	b.n	8025980 <__any_on+0x4c>
 8025954:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 8025958:	b992      	cbnz	r2, 8025980 <__any_on+0x4c>
 802595a:	429c      	cmp	r4, r3
 802595c:	d3fa      	bcc.n	8025954 <__any_on+0x20>
 802595e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8025962:	4770      	bx	lr
 8025964:	dd10      	ble.n	8025988 <__any_on+0x54>
 8025966:	f011 011f 	ands.w	r1, r1, #31
 802596a:	d00d      	beq.n	8025988 <__any_on+0x54>
 802596c:	f854 0022 	ldr.w	r0, [r4, r2, lsl #2]
 8025970:	fa20 f301 	lsr.w	r3, r0, r1
 8025974:	fa03 f101 	lsl.w	r1, r3, r1
 8025978:	4281      	cmp	r1, r0
 802597a:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 802597e:	d0e2      	beq.n	8025946 <__any_on+0x12>
 8025980:	2001      	movs	r0, #1
 8025982:	f85d 4b04 	ldr.w	r4, [sp], #4
 8025986:	4770      	bx	lr
 8025988:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 802598c:	e7db      	b.n	8025946 <__any_on+0x12>
 802598e:	2000      	movs	r0, #0
 8025990:	e7e5      	b.n	802595e <__any_on+0x2a>
 8025992:	bf00      	nop

08025994 <siprintf>:
 8025994:	b40e      	push	{r1, r2, r3}
 8025996:	b5f0      	push	{r4, r5, r6, r7, lr}
 8025998:	b09c      	sub	sp, #112	; 0x70
 802599a:	ab21      	add	r3, sp, #132	; 0x84
 802599c:	490f      	ldr	r1, [pc, #60]	; (80259dc <siprintf+0x48>)
 802599e:	f853 2b04 	ldr.w	r2, [r3], #4
 80259a2:	9301      	str	r3, [sp, #4]
 80259a4:	4605      	mov	r5, r0
 80259a6:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
 80259aa:	6808      	ldr	r0, [r1, #0]
 80259ac:	9502      	str	r5, [sp, #8]
 80259ae:	f44f 7702 	mov.w	r7, #520	; 0x208
 80259b2:	f64f 76ff 	movw	r6, #65535	; 0xffff
 80259b6:	a902      	add	r1, sp, #8
 80259b8:	9506      	str	r5, [sp, #24]
 80259ba:	f8ad 7014 	strh.w	r7, [sp, #20]
 80259be:	9404      	str	r4, [sp, #16]
 80259c0:	9407      	str	r4, [sp, #28]
 80259c2:	f8ad 6016 	strh.w	r6, [sp, #22]
 80259c6:	f000 f9b9 	bl	8025d3c <_svfiprintf_r>
 80259ca:	9b02      	ldr	r3, [sp, #8]
 80259cc:	2200      	movs	r2, #0
 80259ce:	701a      	strb	r2, [r3, #0]
 80259d0:	b01c      	add	sp, #112	; 0x70
 80259d2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 80259d6:	b003      	add	sp, #12
 80259d8:	4770      	bx	lr
 80259da:	bf00      	nop
 80259dc:	20010588 	.word	0x20010588

080259e0 <siscanf>:
 80259e0:	b40e      	push	{r1, r2, r3}
 80259e2:	b5f0      	push	{r4, r5, r6, r7, lr}
 80259e4:	b09c      	sub	sp, #112	; 0x70
 80259e6:	ac21      	add	r4, sp, #132	; 0x84
 80259e8:	f44f 7201 	mov.w	r2, #516	; 0x204
 80259ec:	f854 6b04 	ldr.w	r6, [r4], #4
 80259f0:	f8ad 2014 	strh.w	r2, [sp, #20]
 80259f4:	9002      	str	r0, [sp, #8]
 80259f6:	9006      	str	r0, [sp, #24]
 80259f8:	f7fd fad2 	bl	8022fa0 <strlen>
 80259fc:	4b0c      	ldr	r3, [pc, #48]	; (8025a30 <siscanf+0x50>)
 80259fe:	9401      	str	r4, [sp, #4]
 8025a00:	4605      	mov	r5, r0
 8025a02:	4632      	mov	r2, r6
 8025a04:	4f0b      	ldr	r7, [pc, #44]	; (8025a34 <siscanf+0x54>)
 8025a06:	6818      	ldr	r0, [r3, #0]
 8025a08:	9503      	str	r5, [sp, #12]
 8025a0a:	4623      	mov	r3, r4
 8025a0c:	f64f 76ff 	movw	r6, #65535	; 0xffff
 8025a10:	2400      	movs	r4, #0
 8025a12:	a902      	add	r1, sp, #8
 8025a14:	9507      	str	r5, [sp, #28]
 8025a16:	970a      	str	r7, [sp, #40]	; 0x28
 8025a18:	940e      	str	r4, [sp, #56]	; 0x38
 8025a1a:	9413      	str	r4, [sp, #76]	; 0x4c
 8025a1c:	f8ad 6016 	strh.w	r6, [sp, #22]
 8025a20:	f000 ff78 	bl	8026914 <__ssvfiscanf_r>
 8025a24:	b01c      	add	sp, #112	; 0x70
 8025a26:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8025a2a:	b003      	add	sp, #12
 8025a2c:	4770      	bx	lr
 8025a2e:	bf00      	nop
 8025a30:	20010588 	.word	0x20010588
 8025a34:	08025a39 	.word	0x08025a39

08025a38 <__seofread>:
 8025a38:	2000      	movs	r0, #0
 8025a3a:	4770      	bx	lr

08025a3c <strcpy>:
 8025a3c:	ea80 0201 	eor.w	r2, r0, r1
 8025a40:	4684      	mov	ip, r0
 8025a42:	f012 0f03 	tst.w	r2, #3
 8025a46:	d14f      	bne.n	8025ae8 <strcpy+0xac>
 8025a48:	f011 0f03 	tst.w	r1, #3
 8025a4c:	d132      	bne.n	8025ab4 <strcpy+0x78>
 8025a4e:	f84d 4d04 	str.w	r4, [sp, #-4]!
 8025a52:	f011 0f04 	tst.w	r1, #4
 8025a56:	f851 3b04 	ldr.w	r3, [r1], #4
 8025a5a:	d00b      	beq.n	8025a74 <strcpy+0x38>
 8025a5c:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 8025a60:	439a      	bics	r2, r3
 8025a62:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8025a66:	bf04      	itt	eq
 8025a68:	f84c 3b04 	streq.w	r3, [ip], #4
 8025a6c:	f851 3b04 	ldreq.w	r3, [r1], #4
 8025a70:	d116      	bne.n	8025aa0 <strcpy+0x64>
 8025a72:	bf00      	nop
 8025a74:	f851 4b04 	ldr.w	r4, [r1], #4
 8025a78:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 8025a7c:	439a      	bics	r2, r3
 8025a7e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8025a82:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 8025a86:	d10b      	bne.n	8025aa0 <strcpy+0x64>
 8025a88:	f84c 3b04 	str.w	r3, [ip], #4
 8025a8c:	43a2      	bics	r2, r4
 8025a8e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8025a92:	bf04      	itt	eq
 8025a94:	f851 3b04 	ldreq.w	r3, [r1], #4
 8025a98:	f84c 4b04 	streq.w	r4, [ip], #4
 8025a9c:	d0ea      	beq.n	8025a74 <strcpy+0x38>
 8025a9e:	4623      	mov	r3, r4
 8025aa0:	f80c 3b01 	strb.w	r3, [ip], #1
 8025aa4:	f013 0fff 	tst.w	r3, #255	; 0xff
 8025aa8:	ea4f 2333 	mov.w	r3, r3, ror #8
 8025aac:	d1f8      	bne.n	8025aa0 <strcpy+0x64>
 8025aae:	f85d 4b04 	ldr.w	r4, [sp], #4
 8025ab2:	4770      	bx	lr
 8025ab4:	f011 0f01 	tst.w	r1, #1
 8025ab8:	d006      	beq.n	8025ac8 <strcpy+0x8c>
 8025aba:	f811 2b01 	ldrb.w	r2, [r1], #1
 8025abe:	f80c 2b01 	strb.w	r2, [ip], #1
 8025ac2:	2a00      	cmp	r2, #0
 8025ac4:	bf08      	it	eq
 8025ac6:	4770      	bxeq	lr
 8025ac8:	f011 0f02 	tst.w	r1, #2
 8025acc:	d0bf      	beq.n	8025a4e <strcpy+0x12>
 8025ace:	f831 2b02 	ldrh.w	r2, [r1], #2
 8025ad2:	f012 0fff 	tst.w	r2, #255	; 0xff
 8025ad6:	bf16      	itet	ne
 8025ad8:	f82c 2b02 	strhne.w	r2, [ip], #2
 8025adc:	f88c 2000 	strbeq.w	r2, [ip]
 8025ae0:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
 8025ae4:	d1b3      	bne.n	8025a4e <strcpy+0x12>
 8025ae6:	4770      	bx	lr
 8025ae8:	f811 2b01 	ldrb.w	r2, [r1], #1
 8025aec:	f80c 2b01 	strb.w	r2, [ip], #1
 8025af0:	2a00      	cmp	r2, #0
 8025af2:	d1f9      	bne.n	8025ae8 <strcpy+0xac>
 8025af4:	4770      	bx	lr
 8025af6:	bf00      	nop

08025af8 <_strtoul_r>:
 8025af8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025afc:	4c46      	ldr	r4, [pc, #280]	; (8025c18 <_strtoul_r+0x120>)
 8025afe:	460f      	mov	r7, r1
 8025b00:	f8d4 e000 	ldr.w	lr, [r4]
 8025b04:	e000      	b.n	8025b08 <_strtoul_r+0x10>
 8025b06:	4627      	mov	r7, r4
 8025b08:	463c      	mov	r4, r7
 8025b0a:	f814 5b01 	ldrb.w	r5, [r4], #1
 8025b0e:	eb0e 0605 	add.w	r6, lr, r5
 8025b12:	7876      	ldrb	r6, [r6, #1]
 8025b14:	f006 0608 	and.w	r6, r6, #8
 8025b18:	f006 08ff 	and.w	r8, r6, #255	; 0xff
 8025b1c:	2e00      	cmp	r6, #0
 8025b1e:	d1f2      	bne.n	8025b06 <_strtoul_r+0xe>
 8025b20:	2d2d      	cmp	r5, #45	; 0x2d
 8025b22:	d051      	beq.n	8025bc8 <_strtoul_r+0xd0>
 8025b24:	2d2b      	cmp	r5, #43	; 0x2b
 8025b26:	bf04      	itt	eq
 8025b28:	787d      	ldrbeq	r5, [r7, #1]
 8025b2a:	1cbc      	addeq	r4, r7, #2
 8025b2c:	b15b      	cbz	r3, 8025b46 <_strtoul_r+0x4e>
 8025b2e:	2b10      	cmp	r3, #16
 8025b30:	d05b      	beq.n	8025bea <_strtoul_r+0xf2>
 8025b32:	f04f 39ff 	mov.w	r9, #4294967295
 8025b36:	fbb9 f9f3 	udiv	r9, r9, r3
 8025b3a:	fb03 fb09 	mul.w	fp, r3, r9
 8025b3e:	ea6f 0b0b 	mvn.w	fp, fp
 8025b42:	469a      	mov	sl, r3
 8025b44:	e007      	b.n	8025b56 <_strtoul_r+0x5e>
 8025b46:	2d30      	cmp	r5, #48	; 0x30
 8025b48:	d043      	beq.n	8025bd2 <_strtoul_r+0xda>
 8025b4a:	230a      	movs	r3, #10
 8025b4c:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 8025c1c <_strtoul_r+0x124>
 8025b50:	469a      	mov	sl, r3
 8025b52:	f04f 0b05 	mov.w	fp, #5
 8025b56:	2700      	movs	r7, #0
 8025b58:	46bc      	mov	ip, r7
 8025b5a:	e00c      	b.n	8025b76 <_strtoul_r+0x7e>
 8025b5c:	3d30      	subs	r5, #48	; 0x30
 8025b5e:	42ab      	cmp	r3, r5
 8025b60:	dd19      	ble.n	8025b96 <_strtoul_r+0x9e>
 8025b62:	1c7e      	adds	r6, r7, #1
 8025b64:	d005      	beq.n	8025b72 <_strtoul_r+0x7a>
 8025b66:	45cc      	cmp	ip, r9
 8025b68:	d824      	bhi.n	8025bb4 <_strtoul_r+0xbc>
 8025b6a:	d021      	beq.n	8025bb0 <_strtoul_r+0xb8>
 8025b6c:	fb0a 5c0c 	mla	ip, sl, ip, r5
 8025b70:	2701      	movs	r7, #1
 8025b72:	f814 5b01 	ldrb.w	r5, [r4], #1
 8025b76:	eb0e 0605 	add.w	r6, lr, r5
 8025b7a:	7876      	ldrb	r6, [r6, #1]
 8025b7c:	f016 0f04 	tst.w	r6, #4
 8025b80:	d1ec      	bne.n	8025b5c <_strtoul_r+0x64>
 8025b82:	f016 0603 	ands.w	r6, r6, #3
 8025b86:	d006      	beq.n	8025b96 <_strtoul_r+0x9e>
 8025b88:	2e01      	cmp	r6, #1
 8025b8a:	bf0c      	ite	eq
 8025b8c:	2637      	moveq	r6, #55	; 0x37
 8025b8e:	2657      	movne	r6, #87	; 0x57
 8025b90:	1bad      	subs	r5, r5, r6
 8025b92:	42ab      	cmp	r3, r5
 8025b94:	dce5      	bgt.n	8025b62 <_strtoul_r+0x6a>
 8025b96:	2f00      	cmp	r7, #0
 8025b98:	db11      	blt.n	8025bbe <_strtoul_r+0xc6>
 8025b9a:	f1c8 0000 	rsb	r0, r8, #0
 8025b9e:	ea8c 0000 	eor.w	r0, ip, r0
 8025ba2:	4440      	add	r0, r8
 8025ba4:	b14a      	cbz	r2, 8025bba <_strtoul_r+0xc2>
 8025ba6:	b107      	cbz	r7, 8025baa <_strtoul_r+0xb2>
 8025ba8:	1e61      	subs	r1, r4, #1
 8025baa:	6011      	str	r1, [r2, #0]
 8025bac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025bb0:	455d      	cmp	r5, fp
 8025bb2:	dddb      	ble.n	8025b6c <_strtoul_r+0x74>
 8025bb4:	f04f 37ff 	mov.w	r7, #4294967295
 8025bb8:	e7db      	b.n	8025b72 <_strtoul_r+0x7a>
 8025bba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025bbe:	2322      	movs	r3, #34	; 0x22
 8025bc0:	6003      	str	r3, [r0, #0]
 8025bc2:	f04f 30ff 	mov.w	r0, #4294967295
 8025bc6:	e7ed      	b.n	8025ba4 <_strtoul_r+0xac>
 8025bc8:	1cbc      	adds	r4, r7, #2
 8025bca:	787d      	ldrb	r5, [r7, #1]
 8025bcc:	f04f 0801 	mov.w	r8, #1
 8025bd0:	e7ac      	b.n	8025b2c <_strtoul_r+0x34>
 8025bd2:	7823      	ldrb	r3, [r4, #0]
 8025bd4:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8025bd8:	2b58      	cmp	r3, #88	; 0x58
 8025bda:	d013      	beq.n	8025c04 <_strtoul_r+0x10c>
 8025bdc:	2308      	movs	r3, #8
 8025bde:	469a      	mov	sl, r3
 8025be0:	f04f 0b07 	mov.w	fp, #7
 8025be4:	f06f 4960 	mvn.w	r9, #3758096384	; 0xe0000000
 8025be8:	e7b5      	b.n	8025b56 <_strtoul_r+0x5e>
 8025bea:	2d30      	cmp	r5, #48	; 0x30
 8025bec:	d005      	beq.n	8025bfa <_strtoul_r+0x102>
 8025bee:	f04f 0b0f 	mov.w	fp, #15
 8025bf2:	f06f 4970 	mvn.w	r9, #4026531840	; 0xf0000000
 8025bf6:	469a      	mov	sl, r3
 8025bf8:	e7ad      	b.n	8025b56 <_strtoul_r+0x5e>
 8025bfa:	7826      	ldrb	r6, [r4, #0]
 8025bfc:	f006 06df 	and.w	r6, r6, #223	; 0xdf
 8025c00:	2e58      	cmp	r6, #88	; 0x58
 8025c02:	d1f4      	bne.n	8025bee <_strtoul_r+0xf6>
 8025c04:	f04f 0a10 	mov.w	sl, #16
 8025c08:	7865      	ldrb	r5, [r4, #1]
 8025c0a:	4653      	mov	r3, sl
 8025c0c:	f04f 0b0f 	mov.w	fp, #15
 8025c10:	3402      	adds	r4, #2
 8025c12:	f06f 4970 	mvn.w	r9, #4026531840	; 0xf0000000
 8025c16:	e79e      	b.n	8025b56 <_strtoul_r+0x5e>
 8025c18:	20010114 	.word	0x20010114
 8025c1c:	19999999 	.word	0x19999999

08025c20 <strtoul>:
 8025c20:	b430      	push	{r4, r5}
 8025c22:	4c04      	ldr	r4, [pc, #16]	; (8025c34 <strtoul+0x14>)
 8025c24:	460d      	mov	r5, r1
 8025c26:	4613      	mov	r3, r2
 8025c28:	4601      	mov	r1, r0
 8025c2a:	462a      	mov	r2, r5
 8025c2c:	6820      	ldr	r0, [r4, #0]
 8025c2e:	bc30      	pop	{r4, r5}
 8025c30:	f7ff bf62 	b.w	8025af8 <_strtoul_r>
 8025c34:	20010588 	.word	0x20010588

08025c38 <__ssprint_r>:
 8025c38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025c3c:	6893      	ldr	r3, [r2, #8]
 8025c3e:	f8d2 8000 	ldr.w	r8, [r2]
 8025c42:	b083      	sub	sp, #12
 8025c44:	4691      	mov	r9, r2
 8025c46:	2b00      	cmp	r3, #0
 8025c48:	d072      	beq.n	8025d30 <__ssprint_r+0xf8>
 8025c4a:	4607      	mov	r7, r0
 8025c4c:	f04f 0b00 	mov.w	fp, #0
 8025c50:	6808      	ldr	r0, [r1, #0]
 8025c52:	688b      	ldr	r3, [r1, #8]
 8025c54:	460d      	mov	r5, r1
 8025c56:	465c      	mov	r4, fp
 8025c58:	2c00      	cmp	r4, #0
 8025c5a:	d045      	beq.n	8025ce8 <__ssprint_r+0xb0>
 8025c5c:	429c      	cmp	r4, r3
 8025c5e:	461e      	mov	r6, r3
 8025c60:	469a      	mov	sl, r3
 8025c62:	d348      	bcc.n	8025cf6 <__ssprint_r+0xbe>
 8025c64:	89ab      	ldrh	r3, [r5, #12]
 8025c66:	f413 6f90 	tst.w	r3, #1152	; 0x480
 8025c6a:	d02d      	beq.n	8025cc8 <__ssprint_r+0x90>
 8025c6c:	696e      	ldr	r6, [r5, #20]
 8025c6e:	6929      	ldr	r1, [r5, #16]
 8025c70:	eb06 0646 	add.w	r6, r6, r6, lsl #1
 8025c74:	ebc1 0a00 	rsb	sl, r1, r0
 8025c78:	eb06 76d6 	add.w	r6, r6, r6, lsr #31
 8025c7c:	1c60      	adds	r0, r4, #1
 8025c7e:	1076      	asrs	r6, r6, #1
 8025c80:	4450      	add	r0, sl
 8025c82:	4286      	cmp	r6, r0
 8025c84:	4632      	mov	r2, r6
 8025c86:	bf3c      	itt	cc
 8025c88:	4606      	movcc	r6, r0
 8025c8a:	4632      	movcc	r2, r6
 8025c8c:	055b      	lsls	r3, r3, #21
 8025c8e:	d535      	bpl.n	8025cfc <__ssprint_r+0xc4>
 8025c90:	4611      	mov	r1, r2
 8025c92:	4638      	mov	r0, r7
 8025c94:	f7f3 fb20 	bl	80192d8 <_malloc_r>
 8025c98:	2800      	cmp	r0, #0
 8025c9a:	d039      	beq.n	8025d10 <__ssprint_r+0xd8>
 8025c9c:	4652      	mov	r2, sl
 8025c9e:	6929      	ldr	r1, [r5, #16]
 8025ca0:	9001      	str	r0, [sp, #4]
 8025ca2:	f7da fb1d 	bl	80002e0 <memcpy>
 8025ca6:	89aa      	ldrh	r2, [r5, #12]
 8025ca8:	9b01      	ldr	r3, [sp, #4]
 8025caa:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 8025cae:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8025cb2:	81aa      	strh	r2, [r5, #12]
 8025cb4:	ebca 0206 	rsb	r2, sl, r6
 8025cb8:	eb03 000a 	add.w	r0, r3, sl
 8025cbc:	616e      	str	r6, [r5, #20]
 8025cbe:	612b      	str	r3, [r5, #16]
 8025cc0:	6028      	str	r0, [r5, #0]
 8025cc2:	60aa      	str	r2, [r5, #8]
 8025cc4:	4626      	mov	r6, r4
 8025cc6:	46a2      	mov	sl, r4
 8025cc8:	4652      	mov	r2, sl
 8025cca:	4659      	mov	r1, fp
 8025ccc:	f001 fbd6 	bl	802747c <memmove>
 8025cd0:	f8d9 2008 	ldr.w	r2, [r9, #8]
 8025cd4:	68ab      	ldr	r3, [r5, #8]
 8025cd6:	6828      	ldr	r0, [r5, #0]
 8025cd8:	1b9b      	subs	r3, r3, r6
 8025cda:	4450      	add	r0, sl
 8025cdc:	1b14      	subs	r4, r2, r4
 8025cde:	60ab      	str	r3, [r5, #8]
 8025ce0:	6028      	str	r0, [r5, #0]
 8025ce2:	f8c9 4008 	str.w	r4, [r9, #8]
 8025ce6:	b31c      	cbz	r4, 8025d30 <__ssprint_r+0xf8>
 8025ce8:	f8d8 b000 	ldr.w	fp, [r8]
 8025cec:	f8d8 4004 	ldr.w	r4, [r8, #4]
 8025cf0:	f108 0808 	add.w	r8, r8, #8
 8025cf4:	e7b0      	b.n	8025c58 <__ssprint_r+0x20>
 8025cf6:	4626      	mov	r6, r4
 8025cf8:	46a2      	mov	sl, r4
 8025cfa:	e7e5      	b.n	8025cc8 <__ssprint_r+0x90>
 8025cfc:	4638      	mov	r0, r7
 8025cfe:	f7f3 faff 	bl	8019300 <_realloc_r>
 8025d02:	4603      	mov	r3, r0
 8025d04:	2800      	cmp	r0, #0
 8025d06:	d1d5      	bne.n	8025cb4 <__ssprint_r+0x7c>
 8025d08:	4638      	mov	r0, r7
 8025d0a:	6929      	ldr	r1, [r5, #16]
 8025d0c:	f7f3 fb24 	bl	8019358 <_free_r>
 8025d10:	230c      	movs	r3, #12
 8025d12:	603b      	str	r3, [r7, #0]
 8025d14:	89ab      	ldrh	r3, [r5, #12]
 8025d16:	2200      	movs	r2, #0
 8025d18:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8025d1c:	f04f 30ff 	mov.w	r0, #4294967295
 8025d20:	81ab      	strh	r3, [r5, #12]
 8025d22:	f8c9 2008 	str.w	r2, [r9, #8]
 8025d26:	f8c9 2004 	str.w	r2, [r9, #4]
 8025d2a:	b003      	add	sp, #12
 8025d2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025d30:	2000      	movs	r0, #0
 8025d32:	f8c9 0004 	str.w	r0, [r9, #4]
 8025d36:	b003      	add	sp, #12
 8025d38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08025d3c <_svfiprintf_r>:
 8025d3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025d40:	4691      	mov	r9, r2
 8025d42:	898a      	ldrh	r2, [r1, #12]
 8025d44:	b0ad      	sub	sp, #180	; 0xb4
 8025d46:	0612      	lsls	r2, r2, #24
 8025d48:	468a      	mov	sl, r1
 8025d4a:	9306      	str	r3, [sp, #24]
 8025d4c:	9004      	str	r0, [sp, #16]
 8025d4e:	d503      	bpl.n	8025d58 <_svfiprintf_r+0x1c>
 8025d50:	690b      	ldr	r3, [r1, #16]
 8025d52:	2b00      	cmp	r3, #0
 8025d54:	f000 850f 	beq.w	8026776 <_svfiprintf_r+0xa3a>
 8025d58:	2300      	movs	r3, #0
 8025d5a:	f10d 0870 	add.w	r8, sp, #112	; 0x70
 8025d5e:	930a      	str	r3, [sp, #40]	; 0x28
 8025d60:	9311      	str	r3, [sp, #68]	; 0x44
 8025d62:	9310      	str	r3, [sp, #64]	; 0x40
 8025d64:	9303      	str	r3, [sp, #12]
 8025d66:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
 8025d6a:	4644      	mov	r4, r8
 8025d6c:	f899 3000 	ldrb.w	r3, [r9]
 8025d70:	2b00      	cmp	r3, #0
 8025d72:	f000 8382 	beq.w	802647a <_svfiprintf_r+0x73e>
 8025d76:	2b25      	cmp	r3, #37	; 0x25
 8025d78:	f000 837f 	beq.w	802647a <_svfiprintf_r+0x73e>
 8025d7c:	464a      	mov	r2, r9
 8025d7e:	e001      	b.n	8025d84 <_svfiprintf_r+0x48>
 8025d80:	2b25      	cmp	r3, #37	; 0x25
 8025d82:	d003      	beq.n	8025d8c <_svfiprintf_r+0x50>
 8025d84:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8025d88:	2b00      	cmp	r3, #0
 8025d8a:	d1f9      	bne.n	8025d80 <_svfiprintf_r+0x44>
 8025d8c:	ebc9 0602 	rsb	r6, r9, r2
 8025d90:	4615      	mov	r5, r2
 8025d92:	b17e      	cbz	r6, 8025db4 <_svfiprintf_r+0x78>
 8025d94:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8025d96:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8025d98:	f8c4 9000 	str.w	r9, [r4]
 8025d9c:	3301      	adds	r3, #1
 8025d9e:	4432      	add	r2, r6
 8025da0:	2b07      	cmp	r3, #7
 8025da2:	6066      	str	r6, [r4, #4]
 8025da4:	9211      	str	r2, [sp, #68]	; 0x44
 8025da6:	9310      	str	r3, [sp, #64]	; 0x40
 8025da8:	f300 83fb 	bgt.w	80265a2 <_svfiprintf_r+0x866>
 8025dac:	3408      	adds	r4, #8
 8025dae:	9b03      	ldr	r3, [sp, #12]
 8025db0:	4433      	add	r3, r6
 8025db2:	9303      	str	r3, [sp, #12]
 8025db4:	782b      	ldrb	r3, [r5, #0]
 8025db6:	2b00      	cmp	r3, #0
 8025db8:	f000 8384 	beq.w	80264c4 <_svfiprintf_r+0x788>
 8025dbc:	2100      	movs	r1, #0
 8025dbe:	f04f 32ff 	mov.w	r2, #4294967295
 8025dc2:	1c68      	adds	r0, r5, #1
 8025dc4:	786b      	ldrb	r3, [r5, #1]
 8025dc6:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 8025dca:	9100      	str	r1, [sp, #0]
 8025dcc:	9201      	str	r2, [sp, #4]
 8025dce:	460d      	mov	r5, r1
 8025dd0:	f100 0901 	add.w	r9, r0, #1
 8025dd4:	f1a3 0220 	sub.w	r2, r3, #32
 8025dd8:	2a58      	cmp	r2, #88	; 0x58
 8025dda:	f200 8286 	bhi.w	80262ea <_svfiprintf_r+0x5ae>
 8025dde:	e8df f012 	tbh	[pc, r2, lsl #1]
 8025de2:	01e0      	.short	0x01e0
 8025de4:	02840284 	.word	0x02840284
 8025de8:	028401d8 	.word	0x028401d8
 8025dec:	02840284 	.word	0x02840284
 8025df0:	02840284 	.word	0x02840284
 8025df4:	02530284 	.word	0x02530284
 8025df8:	0284024e 	.word	0x0284024e
 8025dfc:	026700b7 	.word	0x026700b7
 8025e00:	02460284 	.word	0x02460284
 8025e04:	02380238 	.word	0x02380238
 8025e08:	02380238 	.word	0x02380238
 8025e0c:	02380238 	.word	0x02380238
 8025e10:	02380238 	.word	0x02380238
 8025e14:	02840238 	.word	0x02840238
 8025e18:	02840284 	.word	0x02840284
 8025e1c:	02840284 	.word	0x02840284
 8025e20:	02840284 	.word	0x02840284
 8025e24:	02840284 	.word	0x02840284
 8025e28:	021c0284 	.word	0x021c0284
 8025e2c:	02840284 	.word	0x02840284
 8025e30:	02840284 	.word	0x02840284
 8025e34:	02840284 	.word	0x02840284
 8025e38:	02840284 	.word	0x02840284
 8025e3c:	02840284 	.word	0x02840284
 8025e40:	02840200 	.word	0x02840200
 8025e44:	02840284 	.word	0x02840284
 8025e48:	02840284 	.word	0x02840284
 8025e4c:	028401c3 	.word	0x028401c3
 8025e50:	019f0284 	.word	0x019f0284
 8025e54:	02840284 	.word	0x02840284
 8025e58:	02840284 	.word	0x02840284
 8025e5c:	02840284 	.word	0x02840284
 8025e60:	02840284 	.word	0x02840284
 8025e64:	02840284 	.word	0x02840284
 8025e68:	01270143 	.word	0x01270143
 8025e6c:	02840284 	.word	0x02840284
 8025e70:	011f0284 	.word	0x011f0284
 8025e74:	02840127 	.word	0x02840127
 8025e78:	01140284 	.word	0x01140284
 8025e7c:	00fe0284 	.word	0x00fe0284
 8025e80:	00e900a6 	.word	0x00e900a6
 8025e84:	028400e1 	.word	0x028400e1
 8025e88:	028400bf 	.word	0x028400bf
 8025e8c:	02840059 	.word	0x02840059
 8025e90:	01e80284 	.word	0x01e80284
 8025e94:	9b00      	ldr	r3, [sp, #0]
 8025e96:	9505      	str	r5, [sp, #20]
 8025e98:	069a      	lsls	r2, r3, #26
 8025e9a:	f140 816e 	bpl.w	802617a <_svfiprintf_r+0x43e>
 8025e9e:	9b06      	ldr	r3, [sp, #24]
 8025ea0:	3307      	adds	r3, #7
 8025ea2:	f023 0307 	bic.w	r3, r3, #7
 8025ea6:	f103 0208 	add.w	r2, r3, #8
 8025eaa:	e9d3 6700 	ldrd	r6, r7, [r3]
 8025eae:	9206      	str	r2, [sp, #24]
 8025eb0:	2301      	movs	r3, #1
 8025eb2:	2200      	movs	r2, #0
 8025eb4:	f88d 2037 	strb.w	r2, [sp, #55]	; 0x37
 8025eb8:	9a01      	ldr	r2, [sp, #4]
 8025eba:	9202      	str	r2, [sp, #8]
 8025ebc:	f04f 0b00 	mov.w	fp, #0
 8025ec0:	9a01      	ldr	r2, [sp, #4]
 8025ec2:	2a00      	cmp	r2, #0
 8025ec4:	db03      	blt.n	8025ece <_svfiprintf_r+0x192>
 8025ec6:	9a00      	ldr	r2, [sp, #0]
 8025ec8:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8025ecc:	9200      	str	r2, [sp, #0]
 8025ece:	ea56 0207 	orrs.w	r2, r6, r7
 8025ed2:	f040 82d4 	bne.w	802647e <_svfiprintf_r+0x742>
 8025ed6:	9a01      	ldr	r2, [sp, #4]
 8025ed8:	2a00      	cmp	r2, #0
 8025eda:	f000 8350 	beq.w	802657e <_svfiprintf_r+0x842>
 8025ede:	2b01      	cmp	r3, #1
 8025ee0:	f000 83b2 	beq.w	8026648 <_svfiprintf_r+0x90c>
 8025ee4:	2b02      	cmp	r3, #2
 8025ee6:	f000 8371 	beq.w	80265cc <_svfiprintf_r+0x890>
 8025eea:	4641      	mov	r1, r8
 8025eec:	08f2      	lsrs	r2, r6, #3
 8025eee:	ea42 7247 	orr.w	r2, r2, r7, lsl #29
 8025ef2:	08f8      	lsrs	r0, r7, #3
 8025ef4:	f006 0307 	and.w	r3, r6, #7
 8025ef8:	4607      	mov	r7, r0
 8025efa:	4616      	mov	r6, r2
 8025efc:	3330      	adds	r3, #48	; 0x30
 8025efe:	ea56 0207 	orrs.w	r2, r6, r7
 8025f02:	f801 3d01 	strb.w	r3, [r1, #-1]!
 8025f06:	d1f1      	bne.n	8025eec <_svfiprintf_r+0x1b0>
 8025f08:	9a00      	ldr	r2, [sp, #0]
 8025f0a:	9109      	str	r1, [sp, #36]	; 0x24
 8025f0c:	07d0      	lsls	r0, r2, #31
 8025f0e:	f140 8397 	bpl.w	8026640 <_svfiprintf_r+0x904>
 8025f12:	2b30      	cmp	r3, #48	; 0x30
 8025f14:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8025f16:	f000 82d1 	beq.w	80264bc <_svfiprintf_r+0x780>
 8025f1a:	3b01      	subs	r3, #1
 8025f1c:	461a      	mov	r2, r3
 8025f1e:	9309      	str	r3, [sp, #36]	; 0x24
 8025f20:	ebc2 0208 	rsb	r2, r2, r8
 8025f24:	2330      	movs	r3, #48	; 0x30
 8025f26:	9202      	str	r2, [sp, #8]
 8025f28:	f801 3c01 	strb.w	r3, [r1, #-1]
 8025f2c:	e32d      	b.n	802658a <_svfiprintf_r+0x84e>
 8025f2e:	9b00      	ldr	r3, [sp, #0]
 8025f30:	9505      	str	r5, [sp, #20]
 8025f32:	f013 0320 	ands.w	r3, r3, #32
 8025f36:	f000 815e 	beq.w	80261f6 <_svfiprintf_r+0x4ba>
 8025f3a:	9b06      	ldr	r3, [sp, #24]
 8025f3c:	3307      	adds	r3, #7
 8025f3e:	f023 0307 	bic.w	r3, r3, #7
 8025f42:	f103 0208 	add.w	r2, r3, #8
 8025f46:	e9d3 6700 	ldrd	r6, r7, [r3]
 8025f4a:	9206      	str	r2, [sp, #24]
 8025f4c:	2300      	movs	r3, #0
 8025f4e:	e7b0      	b.n	8025eb2 <_svfiprintf_r+0x176>
 8025f50:	4648      	mov	r0, r9
 8025f52:	9b00      	ldr	r3, [sp, #0]
 8025f54:	f043 0304 	orr.w	r3, r3, #4
 8025f58:	9300      	str	r3, [sp, #0]
 8025f5a:	f899 3000 	ldrb.w	r3, [r9]
 8025f5e:	e737      	b.n	8025dd0 <_svfiprintf_r+0x94>
 8025f60:	9a06      	ldr	r2, [sp, #24]
 8025f62:	9505      	str	r5, [sp, #20]
 8025f64:	6813      	ldr	r3, [r2, #0]
 8025f66:	9309      	str	r3, [sp, #36]	; 0x24
 8025f68:	2100      	movs	r1, #0
 8025f6a:	1d16      	adds	r6, r2, #4
 8025f6c:	9a01      	ldr	r2, [sp, #4]
 8025f6e:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 8025f72:	9202      	str	r2, [sp, #8]
 8025f74:	2b00      	cmp	r3, #0
 8025f76:	f000 83f3 	beq.w	8026760 <_svfiprintf_r+0xa24>
 8025f7a:	9b01      	ldr	r3, [sp, #4]
 8025f7c:	2b00      	cmp	r3, #0
 8025f7e:	f2c0 83e5 	blt.w	802674c <_svfiprintf_r+0xa10>
 8025f82:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8025f84:	461a      	mov	r2, r3
 8025f86:	4628      	mov	r0, r5
 8025f88:	2100      	movs	r1, #0
 8025f8a:	f001 fa2d 	bl	80273e8 <memchr>
 8025f8e:	2800      	cmp	r0, #0
 8025f90:	f000 8402 	beq.w	8026798 <_svfiprintf_r+0xa5c>
 8025f94:	1b43      	subs	r3, r0, r5
 8025f96:	9302      	str	r3, [sp, #8]
 8025f98:	2300      	movs	r3, #0
 8025f9a:	9606      	str	r6, [sp, #24]
 8025f9c:	f89d b037 	ldrb.w	fp, [sp, #55]	; 0x37
 8025fa0:	9301      	str	r3, [sp, #4]
 8025fa2:	e2f2      	b.n	802658a <_svfiprintf_r+0x84e>
 8025fa4:	9b00      	ldr	r3, [sp, #0]
 8025fa6:	f043 0320 	orr.w	r3, r3, #32
 8025faa:	9300      	str	r3, [sp, #0]
 8025fac:	f899 3000 	ldrb.w	r3, [r9]
 8025fb0:	4648      	mov	r0, r9
 8025fb2:	e70d      	b.n	8025dd0 <_svfiprintf_r+0x94>
 8025fb4:	9806      	ldr	r0, [sp, #24]
 8025fb6:	9900      	ldr	r1, [sp, #0]
 8025fb8:	9505      	str	r5, [sp, #20]
 8025fba:	2330      	movs	r3, #48	; 0x30
 8025fbc:	4602      	mov	r2, r0
 8025fbe:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
 8025fc2:	2378      	movs	r3, #120	; 0x78
 8025fc4:	f041 0102 	orr.w	r1, r1, #2
 8025fc8:	3204      	adds	r2, #4
 8025fca:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
 8025fce:	4bb5      	ldr	r3, [pc, #724]	; (80262a4 <_svfiprintf_r+0x568>)
 8025fd0:	930a      	str	r3, [sp, #40]	; 0x28
 8025fd2:	6806      	ldr	r6, [r0, #0]
 8025fd4:	9100      	str	r1, [sp, #0]
 8025fd6:	9206      	str	r2, [sp, #24]
 8025fd8:	2700      	movs	r7, #0
 8025fda:	2302      	movs	r3, #2
 8025fdc:	e769      	b.n	8025eb2 <_svfiprintf_r+0x176>
 8025fde:	9b00      	ldr	r3, [sp, #0]
 8025fe0:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 8025fe4:	069d      	lsls	r5, r3, #26
 8025fe6:	f100 837f 	bmi.w	80266e8 <_svfiprintf_r+0x9ac>
 8025fea:	9b00      	ldr	r3, [sp, #0]
 8025fec:	06d8      	lsls	r0, r3, #27
 8025fee:	f100 8394 	bmi.w	802671a <_svfiprintf_r+0x9de>
 8025ff2:	9b00      	ldr	r3, [sp, #0]
 8025ff4:	0659      	lsls	r1, r3, #25
 8025ff6:	f140 8390 	bpl.w	802671a <_svfiprintf_r+0x9de>
 8025ffa:	9a06      	ldr	r2, [sp, #24]
 8025ffc:	6813      	ldr	r3, [r2, #0]
 8025ffe:	3204      	adds	r2, #4
 8026000:	9206      	str	r2, [sp, #24]
 8026002:	f8bd 200c 	ldrh.w	r2, [sp, #12]
 8026006:	801a      	strh	r2, [r3, #0]
 8026008:	e6b0      	b.n	8025d6c <_svfiprintf_r+0x30>
 802600a:	f899 3000 	ldrb.w	r3, [r9]
 802600e:	2b6c      	cmp	r3, #108	; 0x6c
 8026010:	4648      	mov	r0, r9
 8026012:	f000 8375 	beq.w	8026700 <_svfiprintf_r+0x9c4>
 8026016:	9a00      	ldr	r2, [sp, #0]
 8026018:	f042 0210 	orr.w	r2, r2, #16
 802601c:	9200      	str	r2, [sp, #0]
 802601e:	e6d7      	b.n	8025dd0 <_svfiprintf_r+0x94>
 8026020:	9b00      	ldr	r3, [sp, #0]
 8026022:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8026026:	9300      	str	r3, [sp, #0]
 8026028:	f899 3000 	ldrb.w	r3, [r9]
 802602c:	4648      	mov	r0, r9
 802602e:	e6cf      	b.n	8025dd0 <_svfiprintf_r+0x94>
 8026030:	9b00      	ldr	r3, [sp, #0]
 8026032:	9505      	str	r5, [sp, #20]
 8026034:	069b      	lsls	r3, r3, #26
 8026036:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 802603a:	f140 80f9 	bpl.w	8026230 <_svfiprintf_r+0x4f4>
 802603e:	9906      	ldr	r1, [sp, #24]
 8026040:	3107      	adds	r1, #7
 8026042:	f021 0107 	bic.w	r1, r1, #7
 8026046:	e9d1 2300 	ldrd	r2, r3, [r1]
 802604a:	3108      	adds	r1, #8
 802604c:	9106      	str	r1, [sp, #24]
 802604e:	4616      	mov	r6, r2
 8026050:	461f      	mov	r7, r3
 8026052:	2a00      	cmp	r2, #0
 8026054:	f173 0300 	sbcs.w	r3, r3, #0
 8026058:	f2c0 8326 	blt.w	80266a8 <_svfiprintf_r+0x96c>
 802605c:	9b01      	ldr	r3, [sp, #4]
 802605e:	9302      	str	r3, [sp, #8]
 8026060:	f89d b037 	ldrb.w	fp, [sp, #55]	; 0x37
 8026064:	2301      	movs	r3, #1
 8026066:	e72b      	b.n	8025ec0 <_svfiprintf_r+0x184>
 8026068:	9a06      	ldr	r2, [sp, #24]
 802606a:	9505      	str	r5, [sp, #20]
 802606c:	6813      	ldr	r3, [r2, #0]
 802606e:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48
 8026072:	4613      	mov	r3, r2
 8026074:	3304      	adds	r3, #4
 8026076:	2601      	movs	r6, #1
 8026078:	2100      	movs	r1, #0
 802607a:	9306      	str	r3, [sp, #24]
 802607c:	ab12      	add	r3, sp, #72	; 0x48
 802607e:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 8026082:	9602      	str	r6, [sp, #8]
 8026084:	9309      	str	r3, [sp, #36]	; 0x24
 8026086:	2300      	movs	r3, #0
 8026088:	9301      	str	r3, [sp, #4]
 802608a:	9b00      	ldr	r3, [sp, #0]
 802608c:	f013 0302 	ands.w	r3, r3, #2
 8026090:	9307      	str	r3, [sp, #28]
 8026092:	9b00      	ldr	r3, [sp, #0]
 8026094:	bf18      	it	ne
 8026096:	3602      	addne	r6, #2
 8026098:	f013 0384 	ands.w	r3, r3, #132	; 0x84
 802609c:	9308      	str	r3, [sp, #32]
 802609e:	f040 8136 	bne.w	802630e <_svfiprintf_r+0x5d2>
 80260a2:	9b05      	ldr	r3, [sp, #20]
 80260a4:	1b9d      	subs	r5, r3, r6
 80260a6:	2d00      	cmp	r5, #0
 80260a8:	f340 8131 	ble.w	802630e <_svfiprintf_r+0x5d2>
 80260ac:	2d10      	cmp	r5, #16
 80260ae:	9911      	ldr	r1, [sp, #68]	; 0x44
 80260b0:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80260b2:	f8df b1f8 	ldr.w	fp, [pc, #504]	; 80262ac <_svfiprintf_r+0x570>
 80260b6:	dd27      	ble.n	8026108 <_svfiprintf_r+0x3cc>
 80260b8:	960b      	str	r6, [sp, #44]	; 0x2c
 80260ba:	2710      	movs	r7, #16
 80260bc:	465e      	mov	r6, fp
 80260be:	46ab      	mov	fp, r5
 80260c0:	9d04      	ldr	r5, [sp, #16]
 80260c2:	e006      	b.n	80260d2 <_svfiprintf_r+0x396>
 80260c4:	f1ab 0b10 	sub.w	fp, fp, #16
 80260c8:	f1bb 0f10 	cmp.w	fp, #16
 80260cc:	f104 0408 	add.w	r4, r4, #8
 80260d0:	dd17      	ble.n	8026102 <_svfiprintf_r+0x3c6>
 80260d2:	3201      	adds	r2, #1
 80260d4:	3110      	adds	r1, #16
 80260d6:	2a07      	cmp	r2, #7
 80260d8:	9111      	str	r1, [sp, #68]	; 0x44
 80260da:	9210      	str	r2, [sp, #64]	; 0x40
 80260dc:	e884 00c0 	stmia.w	r4, {r6, r7}
 80260e0:	ddf0      	ble.n	80260c4 <_svfiprintf_r+0x388>
 80260e2:	4628      	mov	r0, r5
 80260e4:	4651      	mov	r1, sl
 80260e6:	aa0f      	add	r2, sp, #60	; 0x3c
 80260e8:	f7ff fda6 	bl	8025c38 <__ssprint_r>
 80260ec:	2800      	cmp	r0, #0
 80260ee:	f040 81f0 	bne.w	80264d2 <_svfiprintf_r+0x796>
 80260f2:	f1ab 0b10 	sub.w	fp, fp, #16
 80260f6:	f1bb 0f10 	cmp.w	fp, #16
 80260fa:	9911      	ldr	r1, [sp, #68]	; 0x44
 80260fc:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80260fe:	4644      	mov	r4, r8
 8026100:	dce7      	bgt.n	80260d2 <_svfiprintf_r+0x396>
 8026102:	465d      	mov	r5, fp
 8026104:	46b3      	mov	fp, r6
 8026106:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 8026108:	f8c4 b000 	str.w	fp, [r4]
 802610c:	3201      	adds	r2, #1
 802610e:	4429      	add	r1, r5
 8026110:	2a07      	cmp	r2, #7
 8026112:	9111      	str	r1, [sp, #68]	; 0x44
 8026114:	9210      	str	r2, [sp, #64]	; 0x40
 8026116:	6065      	str	r5, [r4, #4]
 8026118:	f300 8281 	bgt.w	802661e <_svfiprintf_r+0x8e2>
 802611c:	3408      	adds	r4, #8
 802611e:	e0f8      	b.n	8026312 <_svfiprintf_r+0x5d6>
 8026120:	4a61      	ldr	r2, [pc, #388]	; (80262a8 <_svfiprintf_r+0x56c>)
 8026122:	920a      	str	r2, [sp, #40]	; 0x28
 8026124:	9a00      	ldr	r2, [sp, #0]
 8026126:	9505      	str	r5, [sp, #20]
 8026128:	0697      	lsls	r7, r2, #26
 802612a:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 802612e:	d548      	bpl.n	80261c2 <_svfiprintf_r+0x486>
 8026130:	9a06      	ldr	r2, [sp, #24]
 8026132:	3207      	adds	r2, #7
 8026134:	f022 0207 	bic.w	r2, r2, #7
 8026138:	e9d2 6700 	ldrd	r6, r7, [r2]
 802613c:	f102 0108 	add.w	r1, r2, #8
 8026140:	9106      	str	r1, [sp, #24]
 8026142:	9a00      	ldr	r2, [sp, #0]
 8026144:	07d5      	lsls	r5, r2, #31
 8026146:	f140 80e0 	bpl.w	802630a <_svfiprintf_r+0x5ce>
 802614a:	ea56 0207 	orrs.w	r2, r6, r7
 802614e:	f000 80dc 	beq.w	802630a <_svfiprintf_r+0x5ce>
 8026152:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
 8026156:	9b00      	ldr	r3, [sp, #0]
 8026158:	2230      	movs	r2, #48	; 0x30
 802615a:	f043 0302 	orr.w	r3, r3, #2
 802615e:	9300      	str	r3, [sp, #0]
 8026160:	f88d 2038 	strb.w	r2, [sp, #56]	; 0x38
 8026164:	2302      	movs	r3, #2
 8026166:	e6a4      	b.n	8025eb2 <_svfiprintf_r+0x176>
 8026168:	9b00      	ldr	r3, [sp, #0]
 802616a:	9505      	str	r5, [sp, #20]
 802616c:	f043 0310 	orr.w	r3, r3, #16
 8026170:	9300      	str	r3, [sp, #0]
 8026172:	9b00      	ldr	r3, [sp, #0]
 8026174:	069a      	lsls	r2, r3, #26
 8026176:	f53f ae92 	bmi.w	8025e9e <_svfiprintf_r+0x162>
 802617a:	9b00      	ldr	r3, [sp, #0]
 802617c:	06db      	lsls	r3, r3, #27
 802617e:	f140 82a5 	bpl.w	80266cc <_svfiprintf_r+0x990>
 8026182:	9a06      	ldr	r2, [sp, #24]
 8026184:	4613      	mov	r3, r2
 8026186:	3204      	adds	r2, #4
 8026188:	681e      	ldr	r6, [r3, #0]
 802618a:	9206      	str	r2, [sp, #24]
 802618c:	2301      	movs	r3, #1
 802618e:	2700      	movs	r7, #0
 8026190:	e68f      	b.n	8025eb2 <_svfiprintf_r+0x176>
 8026192:	9b00      	ldr	r3, [sp, #0]
 8026194:	f043 0301 	orr.w	r3, r3, #1
 8026198:	9300      	str	r3, [sp, #0]
 802619a:	f899 3000 	ldrb.w	r3, [r9]
 802619e:	4648      	mov	r0, r9
 80261a0:	e616      	b.n	8025dd0 <_svfiprintf_r+0x94>
 80261a2:	f899 3000 	ldrb.w	r3, [r9]
 80261a6:	4648      	mov	r0, r9
 80261a8:	2900      	cmp	r1, #0
 80261aa:	f47f ae11 	bne.w	8025dd0 <_svfiprintf_r+0x94>
 80261ae:	2120      	movs	r1, #32
 80261b0:	e60e      	b.n	8025dd0 <_svfiprintf_r+0x94>
 80261b2:	4a3c      	ldr	r2, [pc, #240]	; (80262a4 <_svfiprintf_r+0x568>)
 80261b4:	920a      	str	r2, [sp, #40]	; 0x28
 80261b6:	9a00      	ldr	r2, [sp, #0]
 80261b8:	9505      	str	r5, [sp, #20]
 80261ba:	0697      	lsls	r7, r2, #26
 80261bc:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 80261c0:	d4b6      	bmi.n	8026130 <_svfiprintf_r+0x3f4>
 80261c2:	9a00      	ldr	r2, [sp, #0]
 80261c4:	06d6      	lsls	r6, r2, #27
 80261c6:	f100 827a 	bmi.w	80266be <_svfiprintf_r+0x982>
 80261ca:	9a00      	ldr	r2, [sp, #0]
 80261cc:	9906      	ldr	r1, [sp, #24]
 80261ce:	f012 0f40 	tst.w	r2, #64	; 0x40
 80261d2:	460a      	mov	r2, r1
 80261d4:	f000 82b5 	beq.w	8026742 <_svfiprintf_r+0xa06>
 80261d8:	3204      	adds	r2, #4
 80261da:	880e      	ldrh	r6, [r1, #0]
 80261dc:	9206      	str	r2, [sp, #24]
 80261de:	2700      	movs	r7, #0
 80261e0:	e7af      	b.n	8026142 <_svfiprintf_r+0x406>
 80261e2:	9b00      	ldr	r3, [sp, #0]
 80261e4:	9505      	str	r5, [sp, #20]
 80261e6:	f043 0310 	orr.w	r3, r3, #16
 80261ea:	9300      	str	r3, [sp, #0]
 80261ec:	9b00      	ldr	r3, [sp, #0]
 80261ee:	f013 0320 	ands.w	r3, r3, #32
 80261f2:	f47f aea2 	bne.w	8025f3a <_svfiprintf_r+0x1fe>
 80261f6:	9a00      	ldr	r2, [sp, #0]
 80261f8:	f012 0210 	ands.w	r2, r2, #16
 80261fc:	f040 8240 	bne.w	8026680 <_svfiprintf_r+0x944>
 8026200:	9b00      	ldr	r3, [sp, #0]
 8026202:	f013 0340 	ands.w	r3, r3, #64	; 0x40
 8026206:	f000 823b 	beq.w	8026680 <_svfiprintf_r+0x944>
 802620a:	9906      	ldr	r1, [sp, #24]
 802620c:	4613      	mov	r3, r2
 802620e:	460a      	mov	r2, r1
 8026210:	3204      	adds	r2, #4
 8026212:	880e      	ldrh	r6, [r1, #0]
 8026214:	9206      	str	r2, [sp, #24]
 8026216:	2700      	movs	r7, #0
 8026218:	e64b      	b.n	8025eb2 <_svfiprintf_r+0x176>
 802621a:	9b00      	ldr	r3, [sp, #0]
 802621c:	9505      	str	r5, [sp, #20]
 802621e:	f043 0310 	orr.w	r3, r3, #16
 8026222:	9300      	str	r3, [sp, #0]
 8026224:	9b00      	ldr	r3, [sp, #0]
 8026226:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 802622a:	069b      	lsls	r3, r3, #26
 802622c:	f53f af07 	bmi.w	802603e <_svfiprintf_r+0x302>
 8026230:	9b00      	ldr	r3, [sp, #0]
 8026232:	06df      	lsls	r7, r3, #27
 8026234:	f100 822b 	bmi.w	802668e <_svfiprintf_r+0x952>
 8026238:	9b00      	ldr	r3, [sp, #0]
 802623a:	065e      	lsls	r6, r3, #25
 802623c:	f140 8227 	bpl.w	802668e <_svfiprintf_r+0x952>
 8026240:	9906      	ldr	r1, [sp, #24]
 8026242:	f9b1 6000 	ldrsh.w	r6, [r1]
 8026246:	3104      	adds	r1, #4
 8026248:	17f7      	asrs	r7, r6, #31
 802624a:	4632      	mov	r2, r6
 802624c:	463b      	mov	r3, r7
 802624e:	9106      	str	r1, [sp, #24]
 8026250:	e6ff      	b.n	8026052 <_svfiprintf_r+0x316>
 8026252:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8026256:	2500      	movs	r5, #0
 8026258:	f819 3b01 	ldrb.w	r3, [r9], #1
 802625c:	eb05 0585 	add.w	r5, r5, r5, lsl #2
 8026260:	eb02 0545 	add.w	r5, r2, r5, lsl #1
 8026264:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8026268:	2a09      	cmp	r2, #9
 802626a:	d9f5      	bls.n	8026258 <_svfiprintf_r+0x51c>
 802626c:	e5b2      	b.n	8025dd4 <_svfiprintf_r+0x98>
 802626e:	9b00      	ldr	r3, [sp, #0]
 8026270:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8026274:	9300      	str	r3, [sp, #0]
 8026276:	f899 3000 	ldrb.w	r3, [r9]
 802627a:	4648      	mov	r0, r9
 802627c:	e5a8      	b.n	8025dd0 <_svfiprintf_r+0x94>
 802627e:	f899 3000 	ldrb.w	r3, [r9]
 8026282:	4648      	mov	r0, r9
 8026284:	212b      	movs	r1, #43	; 0x2b
 8026286:	e5a3      	b.n	8025dd0 <_svfiprintf_r+0x94>
 8026288:	9a06      	ldr	r2, [sp, #24]
 802628a:	6815      	ldr	r5, [r2, #0]
 802628c:	4613      	mov	r3, r2
 802628e:	2d00      	cmp	r5, #0
 8026290:	f103 0304 	add.w	r3, r3, #4
 8026294:	f2c0 823d 	blt.w	8026712 <_svfiprintf_r+0x9d6>
 8026298:	9306      	str	r3, [sp, #24]
 802629a:	f899 3000 	ldrb.w	r3, [r9]
 802629e:	4648      	mov	r0, r9
 80262a0:	e596      	b.n	8025dd0 <_svfiprintf_r+0x94>
 80262a2:	bf00      	nop
 80262a4:	0802ba48 	.word	0x0802ba48
 80262a8:	0802ba34 	.word	0x0802ba34
 80262ac:	0802ba24 	.word	0x0802ba24
 80262b0:	f899 3000 	ldrb.w	r3, [r9]
 80262b4:	2b2a      	cmp	r3, #42	; 0x2a
 80262b6:	f109 0001 	add.w	r0, r9, #1
 80262ba:	f000 8272 	beq.w	80267a2 <_svfiprintf_r+0xa66>
 80262be:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 80262c2:	2a09      	cmp	r2, #9
 80262c4:	4681      	mov	r9, r0
 80262c6:	bf98      	it	ls
 80262c8:	2000      	movls	r0, #0
 80262ca:	f200 8261 	bhi.w	8026790 <_svfiprintf_r+0xa54>
 80262ce:	f819 3b01 	ldrb.w	r3, [r9], #1
 80262d2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80262d6:	eb02 0040 	add.w	r0, r2, r0, lsl #1
 80262da:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 80262de:	2a09      	cmp	r2, #9
 80262e0:	d9f5      	bls.n	80262ce <_svfiprintf_r+0x592>
 80262e2:	ea40 72e0 	orr.w	r2, r0, r0, asr #31
 80262e6:	9201      	str	r2, [sp, #4]
 80262e8:	e574      	b.n	8025dd4 <_svfiprintf_r+0x98>
 80262ea:	9505      	str	r5, [sp, #20]
 80262ec:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
 80262f0:	2b00      	cmp	r3, #0
 80262f2:	f000 80e7 	beq.w	80264c4 <_svfiprintf_r+0x788>
 80262f6:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48
 80262fa:	2300      	movs	r3, #0
 80262fc:	2601      	movs	r6, #1
 80262fe:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8026302:	ab12      	add	r3, sp, #72	; 0x48
 8026304:	9602      	str	r6, [sp, #8]
 8026306:	9309      	str	r3, [sp, #36]	; 0x24
 8026308:	e6bd      	b.n	8026086 <_svfiprintf_r+0x34a>
 802630a:	2302      	movs	r3, #2
 802630c:	e5d1      	b.n	8025eb2 <_svfiprintf_r+0x176>
 802630e:	9911      	ldr	r1, [sp, #68]	; 0x44
 8026310:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8026312:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8026316:	b163      	cbz	r3, 8026332 <_svfiprintf_r+0x5f6>
 8026318:	3201      	adds	r2, #1
 802631a:	3101      	adds	r1, #1
 802631c:	f10d 0037 	add.w	r0, sp, #55	; 0x37
 8026320:	2301      	movs	r3, #1
 8026322:	2a07      	cmp	r2, #7
 8026324:	9111      	str	r1, [sp, #68]	; 0x44
 8026326:	9210      	str	r2, [sp, #64]	; 0x40
 8026328:	e884 0009 	stmia.w	r4, {r0, r3}
 802632c:	f300 815f 	bgt.w	80265ee <_svfiprintf_r+0x8b2>
 8026330:	3408      	adds	r4, #8
 8026332:	9b07      	ldr	r3, [sp, #28]
 8026334:	b15b      	cbz	r3, 802634e <_svfiprintf_r+0x612>
 8026336:	3201      	adds	r2, #1
 8026338:	3102      	adds	r1, #2
 802633a:	a80e      	add	r0, sp, #56	; 0x38
 802633c:	2302      	movs	r3, #2
 802633e:	2a07      	cmp	r2, #7
 8026340:	9111      	str	r1, [sp, #68]	; 0x44
 8026342:	9210      	str	r2, [sp, #64]	; 0x40
 8026344:	e884 0009 	stmia.w	r4, {r0, r3}
 8026348:	f300 815d 	bgt.w	8026606 <_svfiprintf_r+0x8ca>
 802634c:	3408      	adds	r4, #8
 802634e:	9b08      	ldr	r3, [sp, #32]
 8026350:	2b80      	cmp	r3, #128	; 0x80
 8026352:	f000 80ca 	beq.w	80264ea <_svfiprintf_r+0x7ae>
 8026356:	9b01      	ldr	r3, [sp, #4]
 8026358:	9802      	ldr	r0, [sp, #8]
 802635a:	1a1d      	subs	r5, r3, r0
 802635c:	2d00      	cmp	r5, #0
 802635e:	dd31      	ble.n	80263c4 <_svfiprintf_r+0x688>
 8026360:	2d10      	cmp	r5, #16
 8026362:	4fb5      	ldr	r7, [pc, #724]	; (8026638 <_svfiprintf_r+0x8fc>)
 8026364:	dd24      	ble.n	80263b0 <_svfiprintf_r+0x674>
 8026366:	9601      	str	r6, [sp, #4]
 8026368:	f04f 0b10 	mov.w	fp, #16
 802636c:	463e      	mov	r6, r7
 802636e:	462f      	mov	r7, r5
 8026370:	9d04      	ldr	r5, [sp, #16]
 8026372:	e004      	b.n	802637e <_svfiprintf_r+0x642>
 8026374:	3f10      	subs	r7, #16
 8026376:	2f10      	cmp	r7, #16
 8026378:	f104 0408 	add.w	r4, r4, #8
 802637c:	dd15      	ble.n	80263aa <_svfiprintf_r+0x66e>
 802637e:	3201      	adds	r2, #1
 8026380:	3110      	adds	r1, #16
 8026382:	2a07      	cmp	r2, #7
 8026384:	9111      	str	r1, [sp, #68]	; 0x44
 8026386:	9210      	str	r2, [sp, #64]	; 0x40
 8026388:	e884 0840 	stmia.w	r4, {r6, fp}
 802638c:	ddf2      	ble.n	8026374 <_svfiprintf_r+0x638>
 802638e:	4628      	mov	r0, r5
 8026390:	4651      	mov	r1, sl
 8026392:	aa0f      	add	r2, sp, #60	; 0x3c
 8026394:	f7ff fc50 	bl	8025c38 <__ssprint_r>
 8026398:	2800      	cmp	r0, #0
 802639a:	f040 809a 	bne.w	80264d2 <_svfiprintf_r+0x796>
 802639e:	3f10      	subs	r7, #16
 80263a0:	2f10      	cmp	r7, #16
 80263a2:	9911      	ldr	r1, [sp, #68]	; 0x44
 80263a4:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80263a6:	4644      	mov	r4, r8
 80263a8:	dce9      	bgt.n	802637e <_svfiprintf_r+0x642>
 80263aa:	463d      	mov	r5, r7
 80263ac:	4637      	mov	r7, r6
 80263ae:	9e01      	ldr	r6, [sp, #4]
 80263b0:	6027      	str	r7, [r4, #0]
 80263b2:	3201      	adds	r2, #1
 80263b4:	4429      	add	r1, r5
 80263b6:	2a07      	cmp	r2, #7
 80263b8:	9111      	str	r1, [sp, #68]	; 0x44
 80263ba:	9210      	str	r2, [sp, #64]	; 0x40
 80263bc:	6065      	str	r5, [r4, #4]
 80263be:	f300 80fa 	bgt.w	80265b6 <_svfiprintf_r+0x87a>
 80263c2:	3408      	adds	r4, #8
 80263c4:	9802      	ldr	r0, [sp, #8]
 80263c6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80263c8:	6023      	str	r3, [r4, #0]
 80263ca:	3201      	adds	r2, #1
 80263cc:	4401      	add	r1, r0
 80263ce:	2a07      	cmp	r2, #7
 80263d0:	9111      	str	r1, [sp, #68]	; 0x44
 80263d2:	9210      	str	r2, [sp, #64]	; 0x40
 80263d4:	6060      	str	r0, [r4, #4]
 80263d6:	f300 80bf 	bgt.w	8026558 <_svfiprintf_r+0x81c>
 80263da:	3408      	adds	r4, #8
 80263dc:	9b00      	ldr	r3, [sp, #0]
 80263de:	075b      	lsls	r3, r3, #29
 80263e0:	d539      	bpl.n	8026456 <_svfiprintf_r+0x71a>
 80263e2:	9b05      	ldr	r3, [sp, #20]
 80263e4:	1b9d      	subs	r5, r3, r6
 80263e6:	2d00      	cmp	r5, #0
 80263e8:	dd35      	ble.n	8026456 <_svfiprintf_r+0x71a>
 80263ea:	2d10      	cmp	r5, #16
 80263ec:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80263ee:	f8df b24c 	ldr.w	fp, [pc, #588]	; 802663c <_svfiprintf_r+0x900>
 80263f2:	dd26      	ble.n	8026442 <_svfiprintf_r+0x706>
 80263f4:	9600      	str	r6, [sp, #0]
 80263f6:	2710      	movs	r7, #16
 80263f8:	465e      	mov	r6, fp
 80263fa:	46ab      	mov	fp, r5
 80263fc:	9d04      	ldr	r5, [sp, #16]
 80263fe:	e006      	b.n	802640e <_svfiprintf_r+0x6d2>
 8026400:	f1ab 0b10 	sub.w	fp, fp, #16
 8026404:	f1bb 0f10 	cmp.w	fp, #16
 8026408:	f104 0408 	add.w	r4, r4, #8
 802640c:	dd16      	ble.n	802643c <_svfiprintf_r+0x700>
 802640e:	3201      	adds	r2, #1
 8026410:	3110      	adds	r1, #16
 8026412:	2a07      	cmp	r2, #7
 8026414:	9111      	str	r1, [sp, #68]	; 0x44
 8026416:	9210      	str	r2, [sp, #64]	; 0x40
 8026418:	e884 00c0 	stmia.w	r4, {r6, r7}
 802641c:	ddf0      	ble.n	8026400 <_svfiprintf_r+0x6c4>
 802641e:	4628      	mov	r0, r5
 8026420:	4651      	mov	r1, sl
 8026422:	aa0f      	add	r2, sp, #60	; 0x3c
 8026424:	f7ff fc08 	bl	8025c38 <__ssprint_r>
 8026428:	2800      	cmp	r0, #0
 802642a:	d152      	bne.n	80264d2 <_svfiprintf_r+0x796>
 802642c:	f1ab 0b10 	sub.w	fp, fp, #16
 8026430:	f1bb 0f10 	cmp.w	fp, #16
 8026434:	9911      	ldr	r1, [sp, #68]	; 0x44
 8026436:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8026438:	4644      	mov	r4, r8
 802643a:	dce8      	bgt.n	802640e <_svfiprintf_r+0x6d2>
 802643c:	465d      	mov	r5, fp
 802643e:	46b3      	mov	fp, r6
 8026440:	9e00      	ldr	r6, [sp, #0]
 8026442:	f8c4 b000 	str.w	fp, [r4]
 8026446:	3201      	adds	r2, #1
 8026448:	4429      	add	r1, r5
 802644a:	2a07      	cmp	r2, #7
 802644c:	9111      	str	r1, [sp, #68]	; 0x44
 802644e:	9210      	str	r2, [sp, #64]	; 0x40
 8026450:	6065      	str	r5, [r4, #4]
 8026452:	f300 8102 	bgt.w	802665a <_svfiprintf_r+0x91e>
 8026456:	9b03      	ldr	r3, [sp, #12]
 8026458:	9a05      	ldr	r2, [sp, #20]
 802645a:	4296      	cmp	r6, r2
 802645c:	bfac      	ite	ge
 802645e:	199b      	addge	r3, r3, r6
 8026460:	189b      	addlt	r3, r3, r2
 8026462:	9303      	str	r3, [sp, #12]
 8026464:	2900      	cmp	r1, #0
 8026466:	f040 8081 	bne.w	802656c <_svfiprintf_r+0x830>
 802646a:	2300      	movs	r3, #0
 802646c:	9310      	str	r3, [sp, #64]	; 0x40
 802646e:	f899 3000 	ldrb.w	r3, [r9]
 8026472:	4644      	mov	r4, r8
 8026474:	2b00      	cmp	r3, #0
 8026476:	f47f ac7e 	bne.w	8025d76 <_svfiprintf_r+0x3a>
 802647a:	464d      	mov	r5, r9
 802647c:	e49a      	b.n	8025db4 <_svfiprintf_r+0x78>
 802647e:	2b01      	cmp	r3, #1
 8026480:	f47f ad30 	bne.w	8025ee4 <_svfiprintf_r+0x1a8>
 8026484:	2f00      	cmp	r7, #0
 8026486:	bf08      	it	eq
 8026488:	2e0a      	cmpeq	r6, #10
 802648a:	f0c0 80dd 	bcc.w	8026648 <_svfiprintf_r+0x90c>
 802648e:	4645      	mov	r5, r8
 8026490:	4630      	mov	r0, r6
 8026492:	4639      	mov	r1, r7
 8026494:	220a      	movs	r2, #10
 8026496:	2300      	movs	r3, #0
 8026498:	f7da fdcc 	bl	8001034 <__aeabi_uldivmod>
 802649c:	3230      	adds	r2, #48	; 0x30
 802649e:	4630      	mov	r0, r6
 80264a0:	4639      	mov	r1, r7
 80264a2:	f805 2d01 	strb.w	r2, [r5, #-1]!
 80264a6:	2300      	movs	r3, #0
 80264a8:	220a      	movs	r2, #10
 80264aa:	f7da fdc3 	bl	8001034 <__aeabi_uldivmod>
 80264ae:	4606      	mov	r6, r0
 80264b0:	460f      	mov	r7, r1
 80264b2:	ea56 0307 	orrs.w	r3, r6, r7
 80264b6:	d1eb      	bne.n	8026490 <_svfiprintf_r+0x754>
 80264b8:	462b      	mov	r3, r5
 80264ba:	9509      	str	r5, [sp, #36]	; 0x24
 80264bc:	ebc3 0308 	rsb	r3, r3, r8
 80264c0:	9302      	str	r3, [sp, #8]
 80264c2:	e062      	b.n	802658a <_svfiprintf_r+0x84e>
 80264c4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80264c6:	b123      	cbz	r3, 80264d2 <_svfiprintf_r+0x796>
 80264c8:	9804      	ldr	r0, [sp, #16]
 80264ca:	4651      	mov	r1, sl
 80264cc:	aa0f      	add	r2, sp, #60	; 0x3c
 80264ce:	f7ff fbb3 	bl	8025c38 <__ssprint_r>
 80264d2:	f8ba 300c 	ldrh.w	r3, [sl, #12]
 80264d6:	f013 0f40 	tst.w	r3, #64	; 0x40
 80264da:	9b03      	ldr	r3, [sp, #12]
 80264dc:	bf18      	it	ne
 80264de:	f04f 33ff 	movne.w	r3, #4294967295
 80264e2:	4618      	mov	r0, r3
 80264e4:	b02d      	add	sp, #180	; 0xb4
 80264e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80264ea:	9b05      	ldr	r3, [sp, #20]
 80264ec:	1b9d      	subs	r5, r3, r6
 80264ee:	2d00      	cmp	r5, #0
 80264f0:	f77f af31 	ble.w	8026356 <_svfiprintf_r+0x61a>
 80264f4:	2d10      	cmp	r5, #16
 80264f6:	4f50      	ldr	r7, [pc, #320]	; (8026638 <_svfiprintf_r+0x8fc>)
 80264f8:	dd23      	ble.n	8026542 <_svfiprintf_r+0x806>
 80264fa:	9607      	str	r6, [sp, #28]
 80264fc:	f04f 0b10 	mov.w	fp, #16
 8026500:	463e      	mov	r6, r7
 8026502:	462f      	mov	r7, r5
 8026504:	9d04      	ldr	r5, [sp, #16]
 8026506:	e004      	b.n	8026512 <_svfiprintf_r+0x7d6>
 8026508:	3f10      	subs	r7, #16
 802650a:	2f10      	cmp	r7, #16
 802650c:	f104 0408 	add.w	r4, r4, #8
 8026510:	dd14      	ble.n	802653c <_svfiprintf_r+0x800>
 8026512:	3201      	adds	r2, #1
 8026514:	3110      	adds	r1, #16
 8026516:	2a07      	cmp	r2, #7
 8026518:	9111      	str	r1, [sp, #68]	; 0x44
 802651a:	9210      	str	r2, [sp, #64]	; 0x40
 802651c:	e884 0840 	stmia.w	r4, {r6, fp}
 8026520:	ddf2      	ble.n	8026508 <_svfiprintf_r+0x7cc>
 8026522:	4628      	mov	r0, r5
 8026524:	4651      	mov	r1, sl
 8026526:	aa0f      	add	r2, sp, #60	; 0x3c
 8026528:	f7ff fb86 	bl	8025c38 <__ssprint_r>
 802652c:	2800      	cmp	r0, #0
 802652e:	d1d0      	bne.n	80264d2 <_svfiprintf_r+0x796>
 8026530:	3f10      	subs	r7, #16
 8026532:	2f10      	cmp	r7, #16
 8026534:	9911      	ldr	r1, [sp, #68]	; 0x44
 8026536:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8026538:	4644      	mov	r4, r8
 802653a:	dcea      	bgt.n	8026512 <_svfiprintf_r+0x7d6>
 802653c:	463d      	mov	r5, r7
 802653e:	4637      	mov	r7, r6
 8026540:	9e07      	ldr	r6, [sp, #28]
 8026542:	6027      	str	r7, [r4, #0]
 8026544:	3201      	adds	r2, #1
 8026546:	4429      	add	r1, r5
 8026548:	2a07      	cmp	r2, #7
 802654a:	9111      	str	r1, [sp, #68]	; 0x44
 802654c:	9210      	str	r2, [sp, #64]	; 0x40
 802654e:	6065      	str	r5, [r4, #4]
 8026550:	f300 80eb 	bgt.w	802672a <_svfiprintf_r+0x9ee>
 8026554:	3408      	adds	r4, #8
 8026556:	e6fe      	b.n	8026356 <_svfiprintf_r+0x61a>
 8026558:	9804      	ldr	r0, [sp, #16]
 802655a:	4651      	mov	r1, sl
 802655c:	aa0f      	add	r2, sp, #60	; 0x3c
 802655e:	f7ff fb6b 	bl	8025c38 <__ssprint_r>
 8026562:	2800      	cmp	r0, #0
 8026564:	d1b5      	bne.n	80264d2 <_svfiprintf_r+0x796>
 8026566:	9911      	ldr	r1, [sp, #68]	; 0x44
 8026568:	4644      	mov	r4, r8
 802656a:	e737      	b.n	80263dc <_svfiprintf_r+0x6a0>
 802656c:	9804      	ldr	r0, [sp, #16]
 802656e:	4651      	mov	r1, sl
 8026570:	aa0f      	add	r2, sp, #60	; 0x3c
 8026572:	f7ff fb61 	bl	8025c38 <__ssprint_r>
 8026576:	2800      	cmp	r0, #0
 8026578:	f43f af77 	beq.w	802646a <_svfiprintf_r+0x72e>
 802657c:	e7a9      	b.n	80264d2 <_svfiprintf_r+0x796>
 802657e:	b913      	cbnz	r3, 8026586 <_svfiprintf_r+0x84a>
 8026580:	9b00      	ldr	r3, [sp, #0]
 8026582:	07da      	lsls	r2, r3, #31
 8026584:	d473      	bmi.n	802666e <_svfiprintf_r+0x932>
 8026586:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
 802658a:	9b02      	ldr	r3, [sp, #8]
 802658c:	9a01      	ldr	r2, [sp, #4]
 802658e:	4293      	cmp	r3, r2
 8026590:	bfb8      	it	lt
 8026592:	4613      	movlt	r3, r2
 8026594:	461e      	mov	r6, r3
 8026596:	f1bb 0f00 	cmp.w	fp, #0
 802659a:	f43f ad76 	beq.w	802608a <_svfiprintf_r+0x34e>
 802659e:	3601      	adds	r6, #1
 80265a0:	e573      	b.n	802608a <_svfiprintf_r+0x34e>
 80265a2:	9804      	ldr	r0, [sp, #16]
 80265a4:	4651      	mov	r1, sl
 80265a6:	aa0f      	add	r2, sp, #60	; 0x3c
 80265a8:	f7ff fb46 	bl	8025c38 <__ssprint_r>
 80265ac:	2800      	cmp	r0, #0
 80265ae:	d190      	bne.n	80264d2 <_svfiprintf_r+0x796>
 80265b0:	4644      	mov	r4, r8
 80265b2:	f7ff bbfc 	b.w	8025dae <_svfiprintf_r+0x72>
 80265b6:	9804      	ldr	r0, [sp, #16]
 80265b8:	4651      	mov	r1, sl
 80265ba:	aa0f      	add	r2, sp, #60	; 0x3c
 80265bc:	f7ff fb3c 	bl	8025c38 <__ssprint_r>
 80265c0:	2800      	cmp	r0, #0
 80265c2:	d186      	bne.n	80264d2 <_svfiprintf_r+0x796>
 80265c4:	9911      	ldr	r1, [sp, #68]	; 0x44
 80265c6:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80265c8:	4644      	mov	r4, r8
 80265ca:	e6fb      	b.n	80263c4 <_svfiprintf_r+0x688>
 80265cc:	980a      	ldr	r0, [sp, #40]	; 0x28
 80265ce:	4645      	mov	r5, r8
 80265d0:	0933      	lsrs	r3, r6, #4
 80265d2:	f006 010f 	and.w	r1, r6, #15
 80265d6:	ea43 7307 	orr.w	r3, r3, r7, lsl #28
 80265da:	093a      	lsrs	r2, r7, #4
 80265dc:	461e      	mov	r6, r3
 80265de:	4617      	mov	r7, r2
 80265e0:	5c43      	ldrb	r3, [r0, r1]
 80265e2:	f805 3d01 	strb.w	r3, [r5, #-1]!
 80265e6:	ea56 0307 	orrs.w	r3, r6, r7
 80265ea:	d1f1      	bne.n	80265d0 <_svfiprintf_r+0x894>
 80265ec:	e764      	b.n	80264b8 <_svfiprintf_r+0x77c>
 80265ee:	9804      	ldr	r0, [sp, #16]
 80265f0:	4651      	mov	r1, sl
 80265f2:	aa0f      	add	r2, sp, #60	; 0x3c
 80265f4:	f7ff fb20 	bl	8025c38 <__ssprint_r>
 80265f8:	2800      	cmp	r0, #0
 80265fa:	f47f af6a 	bne.w	80264d2 <_svfiprintf_r+0x796>
 80265fe:	9911      	ldr	r1, [sp, #68]	; 0x44
 8026600:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8026602:	4644      	mov	r4, r8
 8026604:	e695      	b.n	8026332 <_svfiprintf_r+0x5f6>
 8026606:	9804      	ldr	r0, [sp, #16]
 8026608:	4651      	mov	r1, sl
 802660a:	aa0f      	add	r2, sp, #60	; 0x3c
 802660c:	f7ff fb14 	bl	8025c38 <__ssprint_r>
 8026610:	2800      	cmp	r0, #0
 8026612:	f47f af5e 	bne.w	80264d2 <_svfiprintf_r+0x796>
 8026616:	9911      	ldr	r1, [sp, #68]	; 0x44
 8026618:	9a10      	ldr	r2, [sp, #64]	; 0x40
 802661a:	4644      	mov	r4, r8
 802661c:	e697      	b.n	802634e <_svfiprintf_r+0x612>
 802661e:	9804      	ldr	r0, [sp, #16]
 8026620:	4651      	mov	r1, sl
 8026622:	aa0f      	add	r2, sp, #60	; 0x3c
 8026624:	f7ff fb08 	bl	8025c38 <__ssprint_r>
 8026628:	2800      	cmp	r0, #0
 802662a:	f47f af52 	bne.w	80264d2 <_svfiprintf_r+0x796>
 802662e:	9911      	ldr	r1, [sp, #68]	; 0x44
 8026630:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8026632:	4644      	mov	r4, r8
 8026634:	e66d      	b.n	8026312 <_svfiprintf_r+0x5d6>
 8026636:	bf00      	nop
 8026638:	0802ba64 	.word	0x0802ba64
 802663c:	0802ba24 	.word	0x0802ba24
 8026640:	ebc1 0308 	rsb	r3, r1, r8
 8026644:	9302      	str	r3, [sp, #8]
 8026646:	e7a0      	b.n	802658a <_svfiprintf_r+0x84e>
 8026648:	ad2c      	add	r5, sp, #176	; 0xb0
 802664a:	3630      	adds	r6, #48	; 0x30
 802664c:	f805 6d41 	strb.w	r6, [r5, #-65]!
 8026650:	ebc5 0308 	rsb	r3, r5, r8
 8026654:	9302      	str	r3, [sp, #8]
 8026656:	9509      	str	r5, [sp, #36]	; 0x24
 8026658:	e797      	b.n	802658a <_svfiprintf_r+0x84e>
 802665a:	9804      	ldr	r0, [sp, #16]
 802665c:	4651      	mov	r1, sl
 802665e:	aa0f      	add	r2, sp, #60	; 0x3c
 8026660:	f7ff faea 	bl	8025c38 <__ssprint_r>
 8026664:	2800      	cmp	r0, #0
 8026666:	f47f af34 	bne.w	80264d2 <_svfiprintf_r+0x796>
 802666a:	9911      	ldr	r1, [sp, #68]	; 0x44
 802666c:	e6f3      	b.n	8026456 <_svfiprintf_r+0x71a>
 802666e:	ad2c      	add	r5, sp, #176	; 0xb0
 8026670:	2330      	movs	r3, #48	; 0x30
 8026672:	f805 3d41 	strb.w	r3, [r5, #-65]!
 8026676:	ebc5 0308 	rsb	r3, r5, r8
 802667a:	9302      	str	r3, [sp, #8]
 802667c:	9509      	str	r5, [sp, #36]	; 0x24
 802667e:	e784      	b.n	802658a <_svfiprintf_r+0x84e>
 8026680:	9906      	ldr	r1, [sp, #24]
 8026682:	460a      	mov	r2, r1
 8026684:	3204      	adds	r2, #4
 8026686:	680e      	ldr	r6, [r1, #0]
 8026688:	9206      	str	r2, [sp, #24]
 802668a:	2700      	movs	r7, #0
 802668c:	e411      	b.n	8025eb2 <_svfiprintf_r+0x176>
 802668e:	9a06      	ldr	r2, [sp, #24]
 8026690:	6816      	ldr	r6, [r2, #0]
 8026692:	4613      	mov	r3, r2
 8026694:	3304      	adds	r3, #4
 8026696:	17f7      	asrs	r7, r6, #31
 8026698:	4632      	mov	r2, r6
 802669a:	9306      	str	r3, [sp, #24]
 802669c:	2a00      	cmp	r2, #0
 802669e:	463b      	mov	r3, r7
 80266a0:	f173 0300 	sbcs.w	r3, r3, #0
 80266a4:	f6bf acda 	bge.w	802605c <_svfiprintf_r+0x320>
 80266a8:	9b01      	ldr	r3, [sp, #4]
 80266aa:	9302      	str	r3, [sp, #8]
 80266ac:	f04f 0b2d 	mov.w	fp, #45	; 0x2d
 80266b0:	4276      	negs	r6, r6
 80266b2:	eb67 0747 	sbc.w	r7, r7, r7, lsl #1
 80266b6:	f88d b037 	strb.w	fp, [sp, #55]	; 0x37
 80266ba:	2301      	movs	r3, #1
 80266bc:	e400      	b.n	8025ec0 <_svfiprintf_r+0x184>
 80266be:	9906      	ldr	r1, [sp, #24]
 80266c0:	460a      	mov	r2, r1
 80266c2:	3204      	adds	r2, #4
 80266c4:	680e      	ldr	r6, [r1, #0]
 80266c6:	9206      	str	r2, [sp, #24]
 80266c8:	2700      	movs	r7, #0
 80266ca:	e53a      	b.n	8026142 <_svfiprintf_r+0x406>
 80266cc:	9b00      	ldr	r3, [sp, #0]
 80266ce:	9a06      	ldr	r2, [sp, #24]
 80266d0:	f013 0f40 	tst.w	r3, #64	; 0x40
 80266d4:	4613      	mov	r3, r2
 80266d6:	f43f ad56 	beq.w	8026186 <_svfiprintf_r+0x44a>
 80266da:	8816      	ldrh	r6, [r2, #0]
 80266dc:	3204      	adds	r2, #4
 80266de:	2700      	movs	r7, #0
 80266e0:	2301      	movs	r3, #1
 80266e2:	9206      	str	r2, [sp, #24]
 80266e4:	f7ff bbe5 	b.w	8025eb2 <_svfiprintf_r+0x176>
 80266e8:	9a06      	ldr	r2, [sp, #24]
 80266ea:	9903      	ldr	r1, [sp, #12]
 80266ec:	6813      	ldr	r3, [r2, #0]
 80266ee:	17cf      	asrs	r7, r1, #31
 80266f0:	4608      	mov	r0, r1
 80266f2:	3204      	adds	r2, #4
 80266f4:	4639      	mov	r1, r7
 80266f6:	9206      	str	r2, [sp, #24]
 80266f8:	e9c3 0100 	strd	r0, r1, [r3]
 80266fc:	f7ff bb36 	b.w	8025d6c <_svfiprintf_r+0x30>
 8026700:	9b00      	ldr	r3, [sp, #0]
 8026702:	f043 0320 	orr.w	r3, r3, #32
 8026706:	9300      	str	r3, [sp, #0]
 8026708:	3001      	adds	r0, #1
 802670a:	f899 3001 	ldrb.w	r3, [r9, #1]
 802670e:	f7ff bb5f 	b.w	8025dd0 <_svfiprintf_r+0x94>
 8026712:	426d      	negs	r5, r5
 8026714:	9306      	str	r3, [sp, #24]
 8026716:	4648      	mov	r0, r9
 8026718:	e41b      	b.n	8025f52 <_svfiprintf_r+0x216>
 802671a:	9a06      	ldr	r2, [sp, #24]
 802671c:	6813      	ldr	r3, [r2, #0]
 802671e:	3204      	adds	r2, #4
 8026720:	9206      	str	r2, [sp, #24]
 8026722:	9a03      	ldr	r2, [sp, #12]
 8026724:	601a      	str	r2, [r3, #0]
 8026726:	f7ff bb21 	b.w	8025d6c <_svfiprintf_r+0x30>
 802672a:	9804      	ldr	r0, [sp, #16]
 802672c:	4651      	mov	r1, sl
 802672e:	aa0f      	add	r2, sp, #60	; 0x3c
 8026730:	f7ff fa82 	bl	8025c38 <__ssprint_r>
 8026734:	2800      	cmp	r0, #0
 8026736:	f47f aecc 	bne.w	80264d2 <_svfiprintf_r+0x796>
 802673a:	9911      	ldr	r1, [sp, #68]	; 0x44
 802673c:	9a10      	ldr	r2, [sp, #64]	; 0x40
 802673e:	4644      	mov	r4, r8
 8026740:	e609      	b.n	8026356 <_svfiprintf_r+0x61a>
 8026742:	3204      	adds	r2, #4
 8026744:	680e      	ldr	r6, [r1, #0]
 8026746:	9206      	str	r2, [sp, #24]
 8026748:	2700      	movs	r7, #0
 802674a:	e4fa      	b.n	8026142 <_svfiprintf_r+0x406>
 802674c:	9809      	ldr	r0, [sp, #36]	; 0x24
 802674e:	9606      	str	r6, [sp, #24]
 8026750:	f7fc fc26 	bl	8022fa0 <strlen>
 8026754:	2300      	movs	r3, #0
 8026756:	9002      	str	r0, [sp, #8]
 8026758:	f89d b037 	ldrb.w	fp, [sp, #55]	; 0x37
 802675c:	9301      	str	r3, [sp, #4]
 802675e:	e714      	b.n	802658a <_svfiprintf_r+0x84e>
 8026760:	2a06      	cmp	r2, #6
 8026762:	4613      	mov	r3, r2
 8026764:	bf28      	it	cs
 8026766:	2306      	movcs	r3, #6
 8026768:	9302      	str	r3, [sp, #8]
 802676a:	9606      	str	r6, [sp, #24]
 802676c:	ea23 76e3 	bic.w	r6, r3, r3, asr #31
 8026770:	4b16      	ldr	r3, [pc, #88]	; (80267cc <_svfiprintf_r+0xa90>)
 8026772:	9309      	str	r3, [sp, #36]	; 0x24
 8026774:	e487      	b.n	8026086 <_svfiprintf_r+0x34a>
 8026776:	2140      	movs	r1, #64	; 0x40
 8026778:	f7f2 fdae 	bl	80192d8 <_malloc_r>
 802677c:	f8ca 0000 	str.w	r0, [sl]
 8026780:	f8ca 0010 	str.w	r0, [sl, #16]
 8026784:	b1e0      	cbz	r0, 80267c0 <_svfiprintf_r+0xa84>
 8026786:	2340      	movs	r3, #64	; 0x40
 8026788:	f8ca 3014 	str.w	r3, [sl, #20]
 802678c:	f7ff bae4 	b.w	8025d58 <_svfiprintf_r+0x1c>
 8026790:	2200      	movs	r2, #0
 8026792:	9201      	str	r2, [sp, #4]
 8026794:	f7ff bb1e 	b.w	8025dd4 <_svfiprintf_r+0x98>
 8026798:	f89d b037 	ldrb.w	fp, [sp, #55]	; 0x37
 802679c:	9606      	str	r6, [sp, #24]
 802679e:	9001      	str	r0, [sp, #4]
 80267a0:	e6f3      	b.n	802658a <_svfiprintf_r+0x84e>
 80267a2:	9a06      	ldr	r2, [sp, #24]
 80267a4:	6813      	ldr	r3, [r2, #0]
 80267a6:	9301      	str	r3, [sp, #4]
 80267a8:	3204      	adds	r2, #4
 80267aa:	2b00      	cmp	r3, #0
 80267ac:	9206      	str	r2, [sp, #24]
 80267ae:	f899 3001 	ldrb.w	r3, [r9, #1]
 80267b2:	f6bf ab0d 	bge.w	8025dd0 <_svfiprintf_r+0x94>
 80267b6:	f04f 32ff 	mov.w	r2, #4294967295
 80267ba:	9201      	str	r2, [sp, #4]
 80267bc:	f7ff bb08 	b.w	8025dd0 <_svfiprintf_r+0x94>
 80267c0:	9a04      	ldr	r2, [sp, #16]
 80267c2:	230c      	movs	r3, #12
 80267c4:	6013      	str	r3, [r2, #0]
 80267c6:	f04f 30ff 	mov.w	r0, #4294967295
 80267ca:	e68b      	b.n	80264e4 <_svfiprintf_r+0x7a8>
 80267cc:	0802ba5c 	.word	0x0802ba5c

080267d0 <_sungetc_r>:
 80267d0:	f1b1 3fff 	cmp.w	r1, #4294967295
 80267d4:	d037      	beq.n	8026846 <_sungetc_r+0x76>
 80267d6:	b538      	push	{r3, r4, r5, lr}
 80267d8:	8993      	ldrh	r3, [r2, #12]
 80267da:	4614      	mov	r4, r2
 80267dc:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80267de:	f023 0320 	bic.w	r3, r3, #32
 80267e2:	b2cd      	uxtb	r5, r1
 80267e4:	81a3      	strh	r3, [r4, #12]
 80267e6:	b1aa      	cbz	r2, 8026814 <_sungetc_r+0x44>
 80267e8:	6862      	ldr	r2, [r4, #4]
 80267ea:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80267ec:	429a      	cmp	r2, r3
 80267ee:	da09      	bge.n	8026804 <_sungetc_r+0x34>
 80267f0:	6823      	ldr	r3, [r4, #0]
 80267f2:	1e5a      	subs	r2, r3, #1
 80267f4:	6022      	str	r2, [r4, #0]
 80267f6:	f803 5c01 	strb.w	r5, [r3, #-1]
 80267fa:	6863      	ldr	r3, [r4, #4]
 80267fc:	3301      	adds	r3, #1
 80267fe:	4628      	mov	r0, r5
 8026800:	6063      	str	r3, [r4, #4]
 8026802:	bd38      	pop	{r3, r4, r5, pc}
 8026804:	4621      	mov	r1, r4
 8026806:	f000 fd61 	bl	80272cc <__submore>
 802680a:	2800      	cmp	r0, #0
 802680c:	d0f0      	beq.n	80267f0 <_sungetc_r+0x20>
 802680e:	f04f 30ff 	mov.w	r0, #4294967295
 8026812:	bd38      	pop	{r3, r4, r5, pc}
 8026814:	6922      	ldr	r2, [r4, #16]
 8026816:	6823      	ldr	r3, [r4, #0]
 8026818:	b12a      	cbz	r2, 8026826 <_sungetc_r+0x56>
 802681a:	429a      	cmp	r2, r3
 802681c:	d203      	bcs.n	8026826 <_sungetc_r+0x56>
 802681e:	f813 0c01 	ldrb.w	r0, [r3, #-1]
 8026822:	42a8      	cmp	r0, r5
 8026824:	d012      	beq.n	802684c <_sungetc_r+0x7c>
 8026826:	63a3      	str	r3, [r4, #56]	; 0x38
 8026828:	4623      	mov	r3, r4
 802682a:	6860      	ldr	r0, [r4, #4]
 802682c:	63e0      	str	r0, [r4, #60]	; 0x3c
 802682e:	f104 0140 	add.w	r1, r4, #64	; 0x40
 8026832:	2203      	movs	r2, #3
 8026834:	6362      	str	r2, [r4, #52]	; 0x34
 8026836:	6321      	str	r1, [r4, #48]	; 0x30
 8026838:	f803 5f42 	strb.w	r5, [r3, #66]!
 802683c:	2201      	movs	r2, #1
 802683e:	6023      	str	r3, [r4, #0]
 8026840:	4628      	mov	r0, r5
 8026842:	6062      	str	r2, [r4, #4]
 8026844:	bd38      	pop	{r3, r4, r5, pc}
 8026846:	f04f 30ff 	mov.w	r0, #4294967295
 802684a:	4770      	bx	lr
 802684c:	6862      	ldr	r2, [r4, #4]
 802684e:	3b01      	subs	r3, #1
 8026850:	3201      	adds	r2, #1
 8026852:	6023      	str	r3, [r4, #0]
 8026854:	6062      	str	r2, [r4, #4]
 8026856:	bd38      	pop	{r3, r4, r5, pc}

08026858 <__ssrefill_r>:
 8026858:	b510      	push	{r4, lr}
 802685a:	460c      	mov	r4, r1
 802685c:	6b09      	ldr	r1, [r1, #48]	; 0x30
 802685e:	b169      	cbz	r1, 802687c <__ssrefill_r+0x24>
 8026860:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8026864:	4299      	cmp	r1, r3
 8026866:	d001      	beq.n	802686c <__ssrefill_r+0x14>
 8026868:	f7f2 fd76 	bl	8019358 <_free_r>
 802686c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 802686e:	6063      	str	r3, [r4, #4]
 8026870:	2000      	movs	r0, #0
 8026872:	6320      	str	r0, [r4, #48]	; 0x30
 8026874:	b113      	cbz	r3, 802687c <__ssrefill_r+0x24>
 8026876:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8026878:	6023      	str	r3, [r4, #0]
 802687a:	bd10      	pop	{r4, pc}
 802687c:	89a3      	ldrh	r3, [r4, #12]
 802687e:	6922      	ldr	r2, [r4, #16]
 8026880:	6022      	str	r2, [r4, #0]
 8026882:	f043 0320 	orr.w	r3, r3, #32
 8026886:	2200      	movs	r2, #0
 8026888:	81a3      	strh	r3, [r4, #12]
 802688a:	6062      	str	r2, [r4, #4]
 802688c:	f04f 30ff 	mov.w	r0, #4294967295
 8026890:	bd10      	pop	{r4, pc}
 8026892:	bf00      	nop

08026894 <_sfread_r>:
 8026894:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8026898:	469a      	mov	sl, r3
 802689a:	b083      	sub	sp, #12
 802689c:	fb02 f90a 	mul.w	r9, r2, sl
 80268a0:	9201      	str	r2, [sp, #4]
 80268a2:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 80268a4:	f1b9 0f00 	cmp.w	r9, #0
 80268a8:	d028      	beq.n	80268fc <_sfread_r+0x68>
 80268aa:	4607      	mov	r7, r0
 80268ac:	460e      	mov	r6, r1
 80268ae:	464d      	mov	r5, r9
 80268b0:	f04f 0800 	mov.w	r8, #0
 80268b4:	e00e      	b.n	80268d4 <_sfread_r+0x40>
 80268b6:	f7d9 fd13 	bl	80002e0 <memcpy>
 80268ba:	6822      	ldr	r2, [r4, #0]
 80268bc:	f8c4 8004 	str.w	r8, [r4, #4]
 80268c0:	445a      	add	r2, fp
 80268c2:	6022      	str	r2, [r4, #0]
 80268c4:	4638      	mov	r0, r7
 80268c6:	4621      	mov	r1, r4
 80268c8:	445e      	add	r6, fp
 80268ca:	ebcb 0505 	rsb	r5, fp, r5
 80268ce:	f7ff ffc3 	bl	8026858 <__ssrefill_r>
 80268d2:	b9b8      	cbnz	r0, 8026904 <_sfread_r+0x70>
 80268d4:	f8d4 b004 	ldr.w	fp, [r4, #4]
 80268d8:	6821      	ldr	r1, [r4, #0]
 80268da:	455d      	cmp	r5, fp
 80268dc:	4630      	mov	r0, r6
 80268de:	465a      	mov	r2, fp
 80268e0:	d8e9      	bhi.n	80268b6 <_sfread_r+0x22>
 80268e2:	462a      	mov	r2, r5
 80268e4:	f7d9 fcfc 	bl	80002e0 <memcpy>
 80268e8:	6862      	ldr	r2, [r4, #4]
 80268ea:	6823      	ldr	r3, [r4, #0]
 80268ec:	1b52      	subs	r2, r2, r5
 80268ee:	442b      	add	r3, r5
 80268f0:	4650      	mov	r0, sl
 80268f2:	6062      	str	r2, [r4, #4]
 80268f4:	6023      	str	r3, [r4, #0]
 80268f6:	b003      	add	sp, #12
 80268f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80268fc:	4648      	mov	r0, r9
 80268fe:	b003      	add	sp, #12
 8026900:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8026904:	9b01      	ldr	r3, [sp, #4]
 8026906:	ebc5 0909 	rsb	r9, r5, r9
 802690a:	fbb9 f0f3 	udiv	r0, r9, r3
 802690e:	b003      	add	sp, #12
 8026910:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08026914 <__ssvfiscanf_r>:
 8026914:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8026918:	460c      	mov	r4, r1
 802691a:	8989      	ldrh	r1, [r1, #12]
 802691c:	b0db      	sub	sp, #364	; 0x16c
 802691e:	048d      	lsls	r5, r1, #18
 8026920:	9305      	str	r3, [sp, #20]
 8026922:	d406      	bmi.n	8026932 <__ssvfiscanf_r+0x1e>
 8026924:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8026926:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 802692a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 802692e:	81a1      	strh	r1, [r4, #12]
 8026930:	6663      	str	r3, [r4, #100]	; 0x64
 8026932:	4617      	mov	r7, r2
 8026934:	2300      	movs	r3, #0
 8026936:	f817 1b01 	ldrb.w	r1, [r7], #1
 802693a:	9306      	str	r3, [sp, #24]
 802693c:	9304      	str	r3, [sp, #16]
 802693e:	461d      	mov	r5, r3
 8026940:	9308      	str	r3, [sp, #32]
 8026942:	f8df b3e8 	ldr.w	fp, [pc, #1000]	; 8026d2c <__ssvfiscanf_r+0x418>
 8026946:	910d      	str	r1, [sp, #52]	; 0x34
 8026948:	4680      	mov	r8, r0
 802694a:	b339      	cbz	r1, 802699c <__ssvfiscanf_r+0x88>
 802694c:	f8db 0000 	ldr.w	r0, [fp]
 8026950:	1843      	adds	r3, r0, r1
 8026952:	785b      	ldrb	r3, [r3, #1]
 8026954:	f003 0308 	and.w	r3, r3, #8
 8026958:	f003 09ff 	and.w	r9, r3, #255	; 0xff
 802695c:	b313      	cbz	r3, 80269a4 <__ssvfiscanf_r+0x90>
 802695e:	6863      	ldr	r3, [r4, #4]
 8026960:	e00d      	b.n	802697e <__ssvfiscanf_r+0x6a>
 8026962:	6823      	ldr	r3, [r4, #0]
 8026964:	f8db 1000 	ldr.w	r1, [fp]
 8026968:	781a      	ldrb	r2, [r3, #0]
 802696a:	440a      	add	r2, r1
 802696c:	3301      	adds	r3, #1
 802696e:	7852      	ldrb	r2, [r2, #1]
 8026970:	0711      	lsls	r1, r2, #28
 8026972:	d50c      	bpl.n	802698e <__ssvfiscanf_r+0x7a>
 8026974:	6862      	ldr	r2, [r4, #4]
 8026976:	6023      	str	r3, [r4, #0]
 8026978:	1e53      	subs	r3, r2, #1
 802697a:	3501      	adds	r5, #1
 802697c:	6063      	str	r3, [r4, #4]
 802697e:	2b00      	cmp	r3, #0
 8026980:	dcef      	bgt.n	8026962 <__ssvfiscanf_r+0x4e>
 8026982:	4640      	mov	r0, r8
 8026984:	4621      	mov	r1, r4
 8026986:	f7ff ff67 	bl	8026858 <__ssrefill_r>
 802698a:	2800      	cmp	r0, #0
 802698c:	d0e9      	beq.n	8026962 <__ssvfiscanf_r+0x4e>
 802698e:	463a      	mov	r2, r7
 8026990:	4617      	mov	r7, r2
 8026992:	f817 1b01 	ldrb.w	r1, [r7], #1
 8026996:	910d      	str	r1, [sp, #52]	; 0x34
 8026998:	2900      	cmp	r1, #0
 802699a:	d1d7      	bne.n	802694c <__ssvfiscanf_r+0x38>
 802699c:	9808      	ldr	r0, [sp, #32]
 802699e:	b05b      	add	sp, #364	; 0x16c
 80269a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80269a4:	2925      	cmp	r1, #37	; 0x25
 80269a6:	f040 8087 	bne.w	8026ab8 <__ssvfiscanf_r+0x1a4>
 80269aa:	7853      	ldrb	r3, [r2, #1]
 80269ac:	46ca      	mov	sl, r9
 80269ae:	1c79      	adds	r1, r7, #1
 80269b0:	2b78      	cmp	r3, #120	; 0x78
 80269b2:	f200 814a 	bhi.w	8026c4a <__ssvfiscanf_r+0x336>
 80269b6:	e8df f013 	tbh	[pc, r3, lsl #1]
 80269ba:	0079      	.short	0x0079
 80269bc:	01480148 	.word	0x01480148
 80269c0:	01480148 	.word	0x01480148
 80269c4:	01480148 	.word	0x01480148
 80269c8:	01480148 	.word	0x01480148
 80269cc:	01480148 	.word	0x01480148
 80269d0:	01480148 	.word	0x01480148
 80269d4:	01480148 	.word	0x01480148
 80269d8:	01480148 	.word	0x01480148
 80269dc:	01480148 	.word	0x01480148
 80269e0:	01480148 	.word	0x01480148
 80269e4:	01480148 	.word	0x01480148
 80269e8:	01480148 	.word	0x01480148
 80269ec:	01480148 	.word	0x01480148
 80269f0:	01480148 	.word	0x01480148
 80269f4:	01480148 	.word	0x01480148
 80269f8:	01480148 	.word	0x01480148
 80269fc:	01480148 	.word	0x01480148
 8026a00:	01480148 	.word	0x01480148
 8026a04:	0148007e 	.word	0x0148007e
 8026a08:	01480148 	.word	0x01480148
 8026a0c:	01430148 	.word	0x01430148
 8026a10:	01480148 	.word	0x01480148
 8026a14:	01480148 	.word	0x01480148
 8026a18:	013a0148 	.word	0x013a0148
 8026a1c:	013a013a 	.word	0x013a013a
 8026a20:	013a013a 	.word	0x013a013a
 8026a24:	013a013a 	.word	0x013a013a
 8026a28:	013a013a 	.word	0x013a013a
 8026a2c:	0148013a 	.word	0x0148013a
 8026a30:	01480148 	.word	0x01480148
 8026a34:	01480148 	.word	0x01480148
 8026a38:	01480148 	.word	0x01480148
 8026a3c:	01480148 	.word	0x01480148
 8026a40:	01360148 	.word	0x01360148
 8026a44:	01480148 	.word	0x01480148
 8026a48:	01480148 	.word	0x01480148
 8026a4c:	01480148 	.word	0x01480148
 8026a50:	01310148 	.word	0x01310148
 8026a54:	01480148 	.word	0x01480148
 8026a58:	0148012d 	.word	0x0148012d
 8026a5c:	01480148 	.word	0x01480148
 8026a60:	01480148 	.word	0x01480148
 8026a64:	01480148 	.word	0x01480148
 8026a68:	01290148 	.word	0x01290148
 8026a6c:	01480148 	.word	0x01480148
 8026a70:	01480120 	.word	0x01480120
 8026a74:	01480148 	.word	0x01480148
 8026a78:	01480148 	.word	0x01480148
 8026a7c:	01480148 	.word	0x01480148
 8026a80:	0112011a 	.word	0x0112011a
 8026a84:	01480148 	.word	0x01480148
 8026a88:	010d0148 	.word	0x010d0148
 8026a8c:	01480105 	.word	0x01480105
 8026a90:	00fd0148 	.word	0x00fd0148
 8026a94:	00e30148 	.word	0x00e30148
 8026a98:	00f300db 	.word	0x00f300db
 8026a9c:	01480148 	.word	0x01480148
 8026aa0:	014800be 	.word	0x014800be
 8026aa4:	01480092 	.word	0x01480092
 8026aa8:	01290148 	.word	0x01290148
 8026aac:	f04f 30ff 	mov.w	r0, #4294967295
 8026ab0:	b05b      	add	sp, #364	; 0x16c
 8026ab2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8026ab6:	460f      	mov	r7, r1
 8026ab8:	6863      	ldr	r3, [r4, #4]
 8026aba:	2b00      	cmp	r3, #0
 8026abc:	f340 834f 	ble.w	802715e <__ssvfiscanf_r+0x84a>
 8026ac0:	6823      	ldr	r3, [r4, #0]
 8026ac2:	f817 2c01 	ldrb.w	r2, [r7, #-1]
 8026ac6:	7819      	ldrb	r1, [r3, #0]
 8026ac8:	4291      	cmp	r1, r2
 8026aca:	f47f af67 	bne.w	802699c <__ssvfiscanf_r+0x88>
 8026ace:	6862      	ldr	r2, [r4, #4]
 8026ad0:	3301      	adds	r3, #1
 8026ad2:	3a01      	subs	r2, #1
 8026ad4:	6062      	str	r2, [r4, #4]
 8026ad6:	6023      	str	r3, [r4, #0]
 8026ad8:	3501      	adds	r5, #1
 8026ada:	463a      	mov	r2, r7
 8026adc:	e758      	b.n	8026990 <__ssvfiscanf_r+0x7c>
 8026ade:	4b91      	ldr	r3, [pc, #580]	; (8026d24 <__ssvfiscanf_r+0x410>)
 8026ae0:	9306      	str	r3, [sp, #24]
 8026ae2:	230a      	movs	r3, #10
 8026ae4:	9304      	str	r3, [sp, #16]
 8026ae6:	460f      	mov	r7, r1
 8026ae8:	4656      	mov	r6, sl
 8026aea:	2303      	movs	r3, #3
 8026aec:	6862      	ldr	r2, [r4, #4]
 8026aee:	2a00      	cmp	r2, #0
 8026af0:	dd28      	ble.n	8026b44 <__ssvfiscanf_r+0x230>
 8026af2:	f019 0f40 	tst.w	r9, #64	; 0x40
 8026af6:	f040 80b6 	bne.w	8026c66 <__ssvfiscanf_r+0x352>
 8026afa:	f8db 0000 	ldr.w	r0, [fp]
 8026afe:	6821      	ldr	r1, [r4, #0]
 8026b00:	e000      	b.n	8026b04 <__ssvfiscanf_r+0x1f0>
 8026b02:	6021      	str	r1, [r4, #0]
 8026b04:	780a      	ldrb	r2, [r1, #0]
 8026b06:	4402      	add	r2, r0
 8026b08:	3101      	adds	r1, #1
 8026b0a:	7852      	ldrb	r2, [r2, #1]
 8026b0c:	0712      	lsls	r2, r2, #28
 8026b0e:	f140 80aa 	bpl.w	8026c66 <__ssvfiscanf_r+0x352>
 8026b12:	6862      	ldr	r2, [r4, #4]
 8026b14:	3a01      	subs	r2, #1
 8026b16:	2a00      	cmp	r2, #0
 8026b18:	f105 0501 	add.w	r5, r5, #1
 8026b1c:	6062      	str	r2, [r4, #4]
 8026b1e:	dcf0      	bgt.n	8026b02 <__ssvfiscanf_r+0x1ee>
 8026b20:	4640      	mov	r0, r8
 8026b22:	4621      	mov	r1, r4
 8026b24:	9303      	str	r3, [sp, #12]
 8026b26:	f7ff fe97 	bl	8026858 <__ssrefill_r>
 8026b2a:	b998      	cbnz	r0, 8026b54 <__ssvfiscanf_r+0x240>
 8026b2c:	f8db 0000 	ldr.w	r0, [fp]
 8026b30:	6821      	ldr	r1, [r4, #0]
 8026b32:	9b03      	ldr	r3, [sp, #12]
 8026b34:	e7e6      	b.n	8026b04 <__ssvfiscanf_r+0x1f0>
 8026b36:	6862      	ldr	r2, [r4, #4]
 8026b38:	2a00      	cmp	r2, #0
 8026b3a:	460f      	mov	r7, r1
 8026b3c:	4656      	mov	r6, sl
 8026b3e:	f04f 0302 	mov.w	r3, #2
 8026b42:	dcd6      	bgt.n	8026af2 <__ssvfiscanf_r+0x1de>
 8026b44:	4640      	mov	r0, r8
 8026b46:	4621      	mov	r1, r4
 8026b48:	9303      	str	r3, [sp, #12]
 8026b4a:	f7ff fe85 	bl	8026858 <__ssrefill_r>
 8026b4e:	9b03      	ldr	r3, [sp, #12]
 8026b50:	2800      	cmp	r0, #0
 8026b52:	d0ce      	beq.n	8026af2 <__ssvfiscanf_r+0x1de>
 8026b54:	9a08      	ldr	r2, [sp, #32]
 8026b56:	2a00      	cmp	r2, #0
 8026b58:	d0a8      	beq.n	8026aac <__ssvfiscanf_r+0x198>
 8026b5a:	89a3      	ldrh	r3, [r4, #12]
 8026b5c:	f013 0f40 	tst.w	r3, #64	; 0x40
 8026b60:	4613      	mov	r3, r2
 8026b62:	bf18      	it	ne
 8026b64:	f04f 33ff 	movne.w	r3, #4294967295
 8026b68:	4618      	mov	r0, r3
 8026b6a:	b05b      	add	sp, #364	; 0x16c
 8026b6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8026b70:	460f      	mov	r7, r1
 8026b72:	4b6c      	ldr	r3, [pc, #432]	; (8026d24 <__ssvfiscanf_r+0x410>)
 8026b74:	9306      	str	r3, [sp, #24]
 8026b76:	2308      	movs	r3, #8
 8026b78:	9304      	str	r3, [sp, #16]
 8026b7a:	4656      	mov	r6, sl
 8026b7c:	2303      	movs	r3, #3
 8026b7e:	e7b5      	b.n	8026aec <__ssvfiscanf_r+0x1d8>
 8026b80:	f019 0f10 	tst.w	r9, #16
 8026b84:	460f      	mov	r7, r1
 8026b86:	f47f af02 	bne.w	802698e <__ssvfiscanf_r+0x7a>
 8026b8a:	f019 0f04 	tst.w	r9, #4
 8026b8e:	f000 8300 	beq.w	8027192 <__ssvfiscanf_r+0x87e>
 8026b92:	9a05      	ldr	r2, [sp, #20]
 8026b94:	6813      	ldr	r3, [r2, #0]
 8026b96:	3204      	adds	r2, #4
 8026b98:	9205      	str	r2, [sp, #20]
 8026b9a:	801d      	strh	r5, [r3, #0]
 8026b9c:	463a      	mov	r2, r7
 8026b9e:	e6f7      	b.n	8026990 <__ssvfiscanf_r+0x7c>
 8026ba0:	460f      	mov	r7, r1
 8026ba2:	f449 7908 	orr.w	r9, r9, #544	; 0x220
 8026ba6:	4b5f      	ldr	r3, [pc, #380]	; (8026d24 <__ssvfiscanf_r+0x410>)
 8026ba8:	9306      	str	r3, [sp, #24]
 8026baa:	2310      	movs	r3, #16
 8026bac:	9304      	str	r3, [sp, #16]
 8026bae:	4656      	mov	r6, sl
 8026bb0:	2303      	movs	r3, #3
 8026bb2:	e79b      	b.n	8026aec <__ssvfiscanf_r+0x1d8>
 8026bb4:	787b      	ldrb	r3, [r7, #1]
 8026bb6:	2b6c      	cmp	r3, #108	; 0x6c
 8026bb8:	f000 82e6 	beq.w	8027188 <__ssvfiscanf_r+0x874>
 8026bbc:	f049 0901 	orr.w	r9, r9, #1
 8026bc0:	460f      	mov	r7, r1
 8026bc2:	e6f4      	b.n	80269ae <__ssvfiscanf_r+0x9a>
 8026bc4:	4b58      	ldr	r3, [pc, #352]	; (8026d28 <__ssvfiscanf_r+0x414>)
 8026bc6:	9306      	str	r3, [sp, #24]
 8026bc8:	2300      	movs	r3, #0
 8026bca:	9304      	str	r3, [sp, #16]
 8026bcc:	460f      	mov	r7, r1
 8026bce:	4656      	mov	r6, sl
 8026bd0:	2303      	movs	r3, #3
 8026bd2:	e78b      	b.n	8026aec <__ssvfiscanf_r+0x1d8>
 8026bd4:	787b      	ldrb	r3, [r7, #1]
 8026bd6:	f049 0904 	orr.w	r9, r9, #4
 8026bda:	460f      	mov	r7, r1
 8026bdc:	e6e7      	b.n	80269ae <__ssvfiscanf_r+0x9a>
 8026bde:	460f      	mov	r7, r1
 8026be0:	4b51      	ldr	r3, [pc, #324]	; (8026d28 <__ssvfiscanf_r+0x414>)
 8026be2:	9306      	str	r3, [sp, #24]
 8026be4:	230a      	movs	r3, #10
 8026be6:	9304      	str	r3, [sp, #16]
 8026be8:	4656      	mov	r6, sl
 8026bea:	2303      	movs	r3, #3
 8026bec:	e77e      	b.n	8026aec <__ssvfiscanf_r+0x1d8>
 8026bee:	460f      	mov	r7, r1
 8026bf0:	f049 0940 	orr.w	r9, r9, #64	; 0x40
 8026bf4:	4656      	mov	r6, sl
 8026bf6:	2300      	movs	r3, #0
 8026bf8:	e778      	b.n	8026aec <__ssvfiscanf_r+0x1d8>
 8026bfa:	a81a      	add	r0, sp, #104	; 0x68
 8026bfc:	f000 fca2 	bl	8027544 <__sccl>
 8026c00:	f049 0940 	orr.w	r9, r9, #64	; 0x40
 8026c04:	4607      	mov	r7, r0
 8026c06:	4656      	mov	r6, sl
 8026c08:	2301      	movs	r3, #1
 8026c0a:	e76f      	b.n	8026aec <__ssvfiscanf_r+0x1d8>
 8026c0c:	460f      	mov	r7, r1
 8026c0e:	f449 7900 	orr.w	r9, r9, #512	; 0x200
 8026c12:	e7c8      	b.n	8026ba6 <__ssvfiscanf_r+0x292>
 8026c14:	460f      	mov	r7, r1
 8026c16:	f049 0901 	orr.w	r9, r9, #1
 8026c1a:	e7aa      	b.n	8026b72 <__ssvfiscanf_r+0x25e>
 8026c1c:	787b      	ldrb	r3, [r7, #1]
 8026c1e:	f049 0902 	orr.w	r9, r9, #2
 8026c22:	460f      	mov	r7, r1
 8026c24:	e6c3      	b.n	80269ae <__ssvfiscanf_r+0x9a>
 8026c26:	460f      	mov	r7, r1
 8026c28:	f049 0901 	orr.w	r9, r9, #1
 8026c2c:	e7d8      	b.n	8026be0 <__ssvfiscanf_r+0x2cc>
 8026c2e:	eb0a 0a8a 	add.w	sl, sl, sl, lsl #2
 8026c32:	eb03 0a4a 	add.w	sl, r3, sl, lsl #1
 8026c36:	f1aa 0a30 	sub.w	sl, sl, #48	; 0x30
 8026c3a:	787b      	ldrb	r3, [r7, #1]
 8026c3c:	460f      	mov	r7, r1
 8026c3e:	e6b6      	b.n	80269ae <__ssvfiscanf_r+0x9a>
 8026c40:	787b      	ldrb	r3, [r7, #1]
 8026c42:	f049 0910 	orr.w	r9, r9, #16
 8026c46:	460f      	mov	r7, r1
 8026c48:	e6b1      	b.n	80269ae <__ssvfiscanf_r+0x9a>
 8026c4a:	4403      	add	r3, r0
 8026c4c:	460f      	mov	r7, r1
 8026c4e:	785b      	ldrb	r3, [r3, #1]
 8026c50:	f003 0303 	and.w	r3, r3, #3
 8026c54:	2b01      	cmp	r3, #1
 8026c56:	d0e7      	beq.n	8026c28 <__ssvfiscanf_r+0x314>
 8026c58:	4b33      	ldr	r3, [pc, #204]	; (8026d28 <__ssvfiscanf_r+0x414>)
 8026c5a:	9306      	str	r3, [sp, #24]
 8026c5c:	230a      	movs	r3, #10
 8026c5e:	9304      	str	r3, [sp, #16]
 8026c60:	4656      	mov	r6, sl
 8026c62:	2303      	movs	r3, #3
 8026c64:	e742      	b.n	8026aec <__ssvfiscanf_r+0x1d8>
 8026c66:	2b02      	cmp	r3, #2
 8026c68:	f000 8115 	beq.w	8026e96 <__ssvfiscanf_r+0x582>
 8026c6c:	2b03      	cmp	r3, #3
 8026c6e:	d05f      	beq.n	8026d30 <__ssvfiscanf_r+0x41c>
 8026c70:	2b01      	cmp	r3, #1
 8026c72:	d025      	beq.n	8026cc0 <__ssvfiscanf_r+0x3ac>
 8026c74:	f1ba 0f00 	cmp.w	sl, #0
 8026c78:	bf14      	ite	ne
 8026c7a:	4656      	movne	r6, sl
 8026c7c:	2601      	moveq	r6, #1
 8026c7e:	f019 0301 	ands.w	r3, r9, #1
 8026c82:	f040 81d3 	bne.w	802702c <__ssvfiscanf_r+0x718>
 8026c86:	f019 0f10 	tst.w	r9, #16
 8026c8a:	f000 8252 	beq.w	8027132 <__ssvfiscanf_r+0x81e>
 8026c8e:	4699      	mov	r9, r3
 8026c90:	e008      	b.n	8026ca4 <__ssvfiscanf_r+0x390>
 8026c92:	4413      	add	r3, r2
 8026c94:	6023      	str	r3, [r4, #0]
 8026c96:	4491      	add	r9, r2
 8026c98:	1ab6      	subs	r6, r6, r2
 8026c9a:	f7ff fddd 	bl	8026858 <__ssrefill_r>
 8026c9e:	2800      	cmp	r0, #0
 8026ca0:	f040 8241 	bne.w	8027126 <__ssvfiscanf_r+0x812>
 8026ca4:	6862      	ldr	r2, [r4, #4]
 8026ca6:	6823      	ldr	r3, [r4, #0]
 8026ca8:	42b2      	cmp	r2, r6
 8026caa:	4640      	mov	r0, r8
 8026cac:	4621      	mov	r1, r4
 8026cae:	dbf0      	blt.n	8026c92 <__ssvfiscanf_r+0x37e>
 8026cb0:	1b92      	subs	r2, r2, r6
 8026cb2:	4433      	add	r3, r6
 8026cb4:	6062      	str	r2, [r4, #4]
 8026cb6:	44b1      	add	r9, r6
 8026cb8:	6023      	str	r3, [r4, #0]
 8026cba:	444d      	add	r5, r9
 8026cbc:	463a      	mov	r2, r7
 8026cbe:	e667      	b.n	8026990 <__ssvfiscanf_r+0x7c>
 8026cc0:	f1ba 0f00 	cmp.w	sl, #0
 8026cc4:	bf14      	ite	ne
 8026cc6:	4656      	movne	r6, sl
 8026cc8:	f04f 36ff 	moveq.w	r6, #4294967295
 8026ccc:	f019 0f10 	tst.w	r9, #16
 8026cd0:	f000 810f 	beq.w	8026ef2 <__ssvfiscanf_r+0x5de>
 8026cd4:	aa1a      	add	r2, sp, #104	; 0x68
 8026cd6:	6821      	ldr	r1, [r4, #0]
 8026cd8:	f04f 0900 	mov.w	r9, #0
 8026cdc:	4692      	mov	sl, r2
 8026cde:	780b      	ldrb	r3, [r1, #0]
 8026ce0:	f81a 3003 	ldrb.w	r3, [sl, r3]
 8026ce4:	3101      	adds	r1, #1
 8026ce6:	b1b3      	cbz	r3, 8026d16 <__ssvfiscanf_r+0x402>
 8026ce8:	6863      	ldr	r3, [r4, #4]
 8026cea:	6021      	str	r1, [r4, #0]
 8026cec:	f109 0901 	add.w	r9, r9, #1
 8026cf0:	3b01      	subs	r3, #1
 8026cf2:	454e      	cmp	r6, r9
 8026cf4:	6063      	str	r3, [r4, #4]
 8026cf6:	d0e0      	beq.n	8026cba <__ssvfiscanf_r+0x3a6>
 8026cf8:	2b00      	cmp	r3, #0
 8026cfa:	dcf0      	bgt.n	8026cde <__ssvfiscanf_r+0x3ca>
 8026cfc:	4640      	mov	r0, r8
 8026cfe:	4621      	mov	r1, r4
 8026d00:	f7ff fdaa 	bl	8026858 <__ssrefill_r>
 8026d04:	2800      	cmp	r0, #0
 8026d06:	d1d8      	bne.n	8026cba <__ssvfiscanf_r+0x3a6>
 8026d08:	6821      	ldr	r1, [r4, #0]
 8026d0a:	780b      	ldrb	r3, [r1, #0]
 8026d0c:	f81a 3003 	ldrb.w	r3, [sl, r3]
 8026d10:	3101      	adds	r1, #1
 8026d12:	2b00      	cmp	r3, #0
 8026d14:	d1e8      	bne.n	8026ce8 <__ssvfiscanf_r+0x3d4>
 8026d16:	f1b9 0f00 	cmp.w	r9, #0
 8026d1a:	f43f ae3f 	beq.w	802699c <__ssvfiscanf_r+0x88>
 8026d1e:	444d      	add	r5, r9
 8026d20:	e7cc      	b.n	8026cbc <__ssvfiscanf_r+0x3a8>
 8026d22:	bf00      	nop
 8026d24:	08025af9 	.word	0x08025af9
 8026d28:	080240a1 	.word	0x080240a1
 8026d2c:	20010114 	.word	0x20010114
 8026d30:	f10a 33ff 	add.w	r3, sl, #4294967295
 8026d34:	2b26      	cmp	r3, #38	; 0x26
 8026d36:	bf8c      	ite	hi
 8026d38:	f1aa 0327 	subhi.w	r3, sl, #39	; 0x27
 8026d3c:	2300      	movls	r3, #0
 8026d3e:	f04f 0200 	mov.w	r2, #0
 8026d42:	f10d 0c40 	add.w	ip, sp, #64	; 0x40
 8026d46:	9307      	str	r3, [sp, #28]
 8026d48:	462b      	mov	r3, r5
 8026d4a:	9d04      	ldr	r5, [sp, #16]
 8026d4c:	9203      	str	r2, [sp, #12]
 8026d4e:	bf88      	it	hi
 8026d50:	2627      	movhi	r6, #39	; 0x27
 8026d52:	f449 6958 	orr.w	r9, r9, #3456	; 0xd80
 8026d56:	46e2      	mov	sl, ip
 8026d58:	463a      	mov	r2, r7
 8026d5a:	6820      	ldr	r0, [r4, #0]
 8026d5c:	f890 e000 	ldrb.w	lr, [r0]
 8026d60:	f1ae 012b 	sub.w	r1, lr, #43	; 0x2b
 8026d64:	294d      	cmp	r1, #77	; 0x4d
 8026d66:	d83f      	bhi.n	8026de8 <__ssvfiscanf_r+0x4d4>
 8026d68:	e8df f001 	tbb	[pc, r1]
 8026d6c:	3e8f3e8f 	.word	0x3e8f3e8f
 8026d70:	6060663e 	.word	0x6060663e
 8026d74:	60606060 	.word	0x60606060
 8026d78:	3e5a5a60 	.word	0x3e5a5a60
 8026d7c:	3e3e3e3e 	.word	0x3e3e3e3e
 8026d80:	55553e3e 	.word	0x55553e3e
 8026d84:	55555555 	.word	0x55555555
 8026d88:	3e3e3e3e 	.word	0x3e3e3e3e
 8026d8c:	3e3e3e3e 	.word	0x3e3e3e3e
 8026d90:	3e3e3e3e 	.word	0x3e3e3e3e
 8026d94:	3e3e3e3e 	.word	0x3e3e3e3e
 8026d98:	3e3e273e 	.word	0x3e3e273e
 8026d9c:	3e3e3e3e 	.word	0x3e3e3e3e
 8026da0:	55553e3e 	.word	0x55553e3e
 8026da4:	55555555 	.word	0x55555555
 8026da8:	3e3e3e3e 	.word	0x3e3e3e3e
 8026dac:	3e3e3e3e 	.word	0x3e3e3e3e
 8026db0:	3e3e3e3e 	.word	0x3e3e3e3e
 8026db4:	3e3e3e3e 	.word	0x3e3e3e3e
 8026db8:	273e      	.short	0x273e
 8026dba:	f409 61c0 	and.w	r1, r9, #1536	; 0x600
 8026dbe:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8026dc2:	d111      	bne.n	8026de8 <__ssvfiscanf_r+0x4d4>
 8026dc4:	f429 7900 	bic.w	r9, r9, #512	; 0x200
 8026dc8:	f449 69a0 	orr.w	r9, r9, #1280	; 0x500
 8026dcc:	2510      	movs	r5, #16
 8026dce:	6861      	ldr	r1, [r4, #4]
 8026dd0:	f88a e000 	strb.w	lr, [sl]
 8026dd4:	3901      	subs	r1, #1
 8026dd6:	2900      	cmp	r1, #0
 8026dd8:	f10a 0a01 	add.w	sl, sl, #1
 8026ddc:	6061      	str	r1, [r4, #4]
 8026dde:	dd45      	ble.n	8026e6c <__ssvfiscanf_r+0x558>
 8026de0:	3001      	adds	r0, #1
 8026de2:	6020      	str	r0, [r4, #0]
 8026de4:	3e01      	subs	r6, #1
 8026de6:	d1b8      	bne.n	8026d5a <__ssvfiscanf_r+0x446>
 8026de8:	f419 7f80 	tst.w	r9, #256	; 0x100
 8026dec:	9504      	str	r5, [sp, #16]
 8026dee:	4617      	mov	r7, r2
 8026df0:	461d      	mov	r5, r3
 8026df2:	d005      	beq.n	8026e00 <__ssvfiscanf_r+0x4ec>
 8026df4:	45e2      	cmp	sl, ip
 8026df6:	f200 81ba 	bhi.w	802716e <__ssvfiscanf_r+0x85a>
 8026dfa:	45e2      	cmp	sl, ip
 8026dfc:	f43f adce 	beq.w	802699c <__ssvfiscanf_r+0x88>
 8026e00:	f019 0610 	ands.w	r6, r9, #16
 8026e04:	f000 80fa 	beq.w	8026ffc <__ssvfiscanf_r+0x6e8>
 8026e08:	9b03      	ldr	r3, [sp, #12]
 8026e0a:	ebcc 0c0a 	rsb	ip, ip, sl
 8026e0e:	449c      	add	ip, r3
 8026e10:	4465      	add	r5, ip
 8026e12:	463a      	mov	r2, r7
 8026e14:	e5bc      	b.n	8026990 <__ssvfiscanf_r+0x7c>
 8026e16:	2d0a      	cmp	r5, #10
 8026e18:	dde6      	ble.n	8026de8 <__ssvfiscanf_r+0x4d4>
 8026e1a:	f429 6938 	bic.w	r9, r9, #2944	; 0xb80
 8026e1e:	e7d6      	b.n	8026dce <__ssvfiscanf_r+0x4ba>
 8026e20:	49ad      	ldr	r1, [pc, #692]	; (80270d8 <__ssvfiscanf_r+0x7c4>)
 8026e22:	f931 5015 	ldrsh.w	r5, [r1, r5, lsl #1]
 8026e26:	2d08      	cmp	r5, #8
 8026e28:	dcf7      	bgt.n	8026e1a <__ssvfiscanf_r+0x506>
 8026e2a:	e7dd      	b.n	8026de8 <__ssvfiscanf_r+0x4d4>
 8026e2c:	49aa      	ldr	r1, [pc, #680]	; (80270d8 <__ssvfiscanf_r+0x7c4>)
 8026e2e:	f429 6938 	bic.w	r9, r9, #2944	; 0xb80
 8026e32:	f931 5015 	ldrsh.w	r5, [r1, r5, lsl #1]
 8026e36:	e7ca      	b.n	8026dce <__ssvfiscanf_r+0x4ba>
 8026e38:	f419 6f00 	tst.w	r9, #2048	; 0x800
 8026e3c:	d0c7      	beq.n	8026dce <__ssvfiscanf_r+0x4ba>
 8026e3e:	b915      	cbnz	r5, 8026e46 <__ssvfiscanf_r+0x532>
 8026e40:	f449 7900 	orr.w	r9, r9, #512	; 0x200
 8026e44:	2508      	movs	r5, #8
 8026e46:	f419 6f80 	tst.w	r9, #1024	; 0x400
 8026e4a:	f040 813b 	bne.w	80270c4 <__ssvfiscanf_r+0x7b0>
 8026e4e:	9907      	ldr	r1, [sp, #28]
 8026e50:	f429 7960 	bic.w	r9, r9, #896	; 0x380
 8026e54:	b111      	cbz	r1, 8026e5c <__ssvfiscanf_r+0x548>
 8026e56:	3901      	subs	r1, #1
 8026e58:	9107      	str	r1, [sp, #28]
 8026e5a:	3601      	adds	r6, #1
 8026e5c:	9903      	ldr	r1, [sp, #12]
 8026e5e:	3101      	adds	r1, #1
 8026e60:	9103      	str	r1, [sp, #12]
 8026e62:	6861      	ldr	r1, [r4, #4]
 8026e64:	3901      	subs	r1, #1
 8026e66:	2900      	cmp	r1, #0
 8026e68:	6061      	str	r1, [r4, #4]
 8026e6a:	dcb9      	bgt.n	8026de0 <__ssvfiscanf_r+0x4cc>
 8026e6c:	4640      	mov	r0, r8
 8026e6e:	4621      	mov	r1, r4
 8026e70:	920a      	str	r2, [sp, #40]	; 0x28
 8026e72:	9309      	str	r3, [sp, #36]	; 0x24
 8026e74:	f8cd c010 	str.w	ip, [sp, #16]
 8026e78:	f7ff fcee 	bl	8026858 <__ssrefill_r>
 8026e7c:	f8dd c010 	ldr.w	ip, [sp, #16]
 8026e80:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8026e82:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8026e84:	2800      	cmp	r0, #0
 8026e86:	d0ad      	beq.n	8026de4 <__ssvfiscanf_r+0x4d0>
 8026e88:	e7ae      	b.n	8026de8 <__ssvfiscanf_r+0x4d4>
 8026e8a:	f019 0f80 	tst.w	r9, #128	; 0x80
 8026e8e:	d0ab      	beq.n	8026de8 <__ssvfiscanf_r+0x4d4>
 8026e90:	f029 0980 	bic.w	r9, r9, #128	; 0x80
 8026e94:	e79b      	b.n	8026dce <__ssvfiscanf_r+0x4ba>
 8026e96:	f1ba 0f00 	cmp.w	sl, #0
 8026e9a:	bf14      	ite	ne
 8026e9c:	4656      	movne	r6, sl
 8026e9e:	f04f 36ff 	moveq.w	r6, #4294967295
 8026ea2:	f019 0301 	ands.w	r3, r9, #1
 8026ea6:	f040 8083 	bne.w	8026fb0 <__ssvfiscanf_r+0x69c>
 8026eaa:	f019 0f10 	tst.w	r9, #16
 8026eae:	d050      	beq.n	8026f52 <__ssvfiscanf_r+0x63e>
 8026eb0:	f8db 1000 	ldr.w	r1, [fp]
 8026eb4:	6822      	ldr	r2, [r4, #0]
 8026eb6:	4699      	mov	r9, r3
 8026eb8:	7813      	ldrb	r3, [r2, #0]
 8026eba:	440b      	add	r3, r1
 8026ebc:	3201      	adds	r2, #1
 8026ebe:	785b      	ldrb	r3, [r3, #1]
 8026ec0:	0718      	lsls	r0, r3, #28
 8026ec2:	f53f aefa 	bmi.w	8026cba <__ssvfiscanf_r+0x3a6>
 8026ec6:	6863      	ldr	r3, [r4, #4]
 8026ec8:	6022      	str	r2, [r4, #0]
 8026eca:	f109 0901 	add.w	r9, r9, #1
 8026ece:	3b01      	subs	r3, #1
 8026ed0:	454e      	cmp	r6, r9
 8026ed2:	6063      	str	r3, [r4, #4]
 8026ed4:	f43f aef1 	beq.w	8026cba <__ssvfiscanf_r+0x3a6>
 8026ed8:	2b00      	cmp	r3, #0
 8026eda:	dced      	bgt.n	8026eb8 <__ssvfiscanf_r+0x5a4>
 8026edc:	4640      	mov	r0, r8
 8026ede:	4621      	mov	r1, r4
 8026ee0:	f7ff fcba 	bl	8026858 <__ssrefill_r>
 8026ee4:	2800      	cmp	r0, #0
 8026ee6:	f47f aee8 	bne.w	8026cba <__ssvfiscanf_r+0x3a6>
 8026eea:	f8db 1000 	ldr.w	r1, [fp]
 8026eee:	6822      	ldr	r2, [r4, #0]
 8026ef0:	e7e2      	b.n	8026eb8 <__ssvfiscanf_r+0x5a4>
 8026ef2:	9a05      	ldr	r2, [sp, #20]
 8026ef4:	4613      	mov	r3, r2
 8026ef6:	f8d2 9000 	ldr.w	r9, [r2]
 8026efa:	3304      	adds	r3, #4
 8026efc:	9305      	str	r3, [sp, #20]
 8026efe:	46ca      	mov	sl, r9
 8026f00:	aa1a      	add	r2, sp, #104	; 0x68
 8026f02:	6823      	ldr	r3, [r4, #0]
 8026f04:	7819      	ldrb	r1, [r3, #0]
 8026f06:	5c51      	ldrb	r1, [r2, r1]
 8026f08:	1c58      	adds	r0, r3, #1
 8026f0a:	b1b1      	cbz	r1, 8026f3a <__ssvfiscanf_r+0x626>
 8026f0c:	6861      	ldr	r1, [r4, #4]
 8026f0e:	6020      	str	r0, [r4, #0]
 8026f10:	3901      	subs	r1, #1
 8026f12:	6061      	str	r1, [r4, #4]
 8026f14:	781b      	ldrb	r3, [r3, #0]
 8026f16:	f80a 3b01 	strb.w	r3, [sl], #1
 8026f1a:	3e01      	subs	r6, #1
 8026f1c:	d00d      	beq.n	8026f3a <__ssvfiscanf_r+0x626>
 8026f1e:	6863      	ldr	r3, [r4, #4]
 8026f20:	2b00      	cmp	r3, #0
 8026f22:	dcee      	bgt.n	8026f02 <__ssvfiscanf_r+0x5ee>
 8026f24:	4640      	mov	r0, r8
 8026f26:	4621      	mov	r1, r4
 8026f28:	9203      	str	r2, [sp, #12]
 8026f2a:	f7ff fc95 	bl	8026858 <__ssrefill_r>
 8026f2e:	9a03      	ldr	r2, [sp, #12]
 8026f30:	2800      	cmp	r0, #0
 8026f32:	d0e6      	beq.n	8026f02 <__ssvfiscanf_r+0x5ee>
 8026f34:	45ca      	cmp	sl, r9
 8026f36:	f43f ae0d 	beq.w	8026b54 <__ssvfiscanf_r+0x240>
 8026f3a:	ebba 0909 	subs.w	r9, sl, r9
 8026f3e:	f43f ad2d 	beq.w	802699c <__ssvfiscanf_r+0x88>
 8026f42:	9b08      	ldr	r3, [sp, #32]
 8026f44:	2200      	movs	r2, #0
 8026f46:	3301      	adds	r3, #1
 8026f48:	9308      	str	r3, [sp, #32]
 8026f4a:	f88a 2000 	strb.w	r2, [sl]
 8026f4e:	444d      	add	r5, r9
 8026f50:	e6b4      	b.n	8026cbc <__ssvfiscanf_r+0x3a8>
 8026f52:	9a05      	ldr	r2, [sp, #20]
 8026f54:	4613      	mov	r3, r2
 8026f56:	f8d2 9000 	ldr.w	r9, [r2]
 8026f5a:	3304      	adds	r3, #4
 8026f5c:	9303      	str	r3, [sp, #12]
 8026f5e:	46ca      	mov	sl, r9
 8026f60:	6821      	ldr	r1, [r4, #0]
 8026f62:	f8db 2000 	ldr.w	r2, [fp]
 8026f66:	780b      	ldrb	r3, [r1, #0]
 8026f68:	4413      	add	r3, r2
 8026f6a:	1c4a      	adds	r2, r1, #1
 8026f6c:	785b      	ldrb	r3, [r3, #1]
 8026f6e:	071b      	lsls	r3, r3, #28
 8026f70:	d411      	bmi.n	8026f96 <__ssvfiscanf_r+0x682>
 8026f72:	6863      	ldr	r3, [r4, #4]
 8026f74:	6022      	str	r2, [r4, #0]
 8026f76:	3b01      	subs	r3, #1
 8026f78:	6063      	str	r3, [r4, #4]
 8026f7a:	780b      	ldrb	r3, [r1, #0]
 8026f7c:	f80a 3b01 	strb.w	r3, [sl], #1
 8026f80:	3e01      	subs	r6, #1
 8026f82:	d008      	beq.n	8026f96 <__ssvfiscanf_r+0x682>
 8026f84:	6863      	ldr	r3, [r4, #4]
 8026f86:	2b00      	cmp	r3, #0
 8026f88:	dcea      	bgt.n	8026f60 <__ssvfiscanf_r+0x64c>
 8026f8a:	4640      	mov	r0, r8
 8026f8c:	4621      	mov	r1, r4
 8026f8e:	f7ff fc63 	bl	8026858 <__ssrefill_r>
 8026f92:	2800      	cmp	r0, #0
 8026f94:	d0e4      	beq.n	8026f60 <__ssvfiscanf_r+0x64c>
 8026f96:	9a08      	ldr	r2, [sp, #32]
 8026f98:	3201      	adds	r2, #1
 8026f9a:	ebc9 090a 	rsb	r9, r9, sl
 8026f9e:	2300      	movs	r3, #0
 8026fa0:	9208      	str	r2, [sp, #32]
 8026fa2:	9a03      	ldr	r2, [sp, #12]
 8026fa4:	9205      	str	r2, [sp, #20]
 8026fa6:	444d      	add	r5, r9
 8026fa8:	f88a 3000 	strb.w	r3, [sl]
 8026fac:	463a      	mov	r2, r7
 8026fae:	e4ef      	b.n	8026990 <__ssvfiscanf_r+0x7c>
 8026fb0:	ab0e      	add	r3, sp, #56	; 0x38
 8026fb2:	4618      	mov	r0, r3
 8026fb4:	2100      	movs	r1, #0
 8026fb6:	2208      	movs	r2, #8
 8026fb8:	9309      	str	r3, [sp, #36]	; 0x24
 8026fba:	f7fb fb5f 	bl	802267c <memset>
 8026fbe:	f019 0310 	ands.w	r3, r9, #16
 8026fc2:	9303      	str	r3, [sp, #12]
 8026fc4:	f000 8081 	beq.w	80270ca <__ssvfiscanf_r+0x7b6>
 8026fc8:	f10d 0a34 	add.w	sl, sp, #52	; 0x34
 8026fcc:	2200      	movs	r2, #0
 8026fce:	4691      	mov	r9, r2
 8026fd0:	6823      	ldr	r3, [r4, #0]
 8026fd2:	f8db 2000 	ldr.w	r2, [fp]
 8026fd6:	781b      	ldrb	r3, [r3, #0]
 8026fd8:	4413      	add	r3, r2
 8026fda:	785b      	ldrb	r3, [r3, #1]
 8026fdc:	071b      	lsls	r3, r3, #28
 8026fde:	d402      	bmi.n	8026fe6 <__ssvfiscanf_r+0x6d2>
 8026fe0:	2e00      	cmp	r6, #0
 8026fe2:	f040 810b 	bne.w	80271fc <__ssvfiscanf_r+0x8e8>
 8026fe6:	9b03      	ldr	r3, [sp, #12]
 8026fe8:	2b00      	cmp	r3, #0
 8026fea:	f47f acd0 	bne.w	802698e <__ssvfiscanf_r+0x7a>
 8026fee:	f8ca 3000 	str.w	r3, [sl]
 8026ff2:	9b08      	ldr	r3, [sp, #32]
 8026ff4:	3301      	adds	r3, #1
 8026ff6:	9308      	str	r3, [sp, #32]
 8026ff8:	463a      	mov	r2, r7
 8026ffa:	e4c9      	b.n	8026990 <__ssvfiscanf_r+0x7c>
 8026ffc:	4632      	mov	r2, r6
 8026ffe:	4661      	mov	r1, ip
 8027000:	f88a 6000 	strb.w	r6, [sl]
 8027004:	4640      	mov	r0, r8
 8027006:	9b04      	ldr	r3, [sp, #16]
 8027008:	9e06      	ldr	r6, [sp, #24]
 802700a:	f8cd c01c 	str.w	ip, [sp, #28]
 802700e:	47b0      	blx	r6
 8027010:	f019 0f20 	tst.w	r9, #32
 8027014:	f8dd c01c 	ldr.w	ip, [sp, #28]
 8027018:	d075      	beq.n	8027106 <__ssvfiscanf_r+0x7f2>
 802701a:	9a05      	ldr	r2, [sp, #20]
 802701c:	6813      	ldr	r3, [r2, #0]
 802701e:	3204      	adds	r2, #4
 8027020:	9205      	str	r2, [sp, #20]
 8027022:	6018      	str	r0, [r3, #0]
 8027024:	9b08      	ldr	r3, [sp, #32]
 8027026:	3301      	adds	r3, #1
 8027028:	9308      	str	r3, [sp, #32]
 802702a:	e6ed      	b.n	8026e08 <__ssvfiscanf_r+0x4f4>
 802702c:	ab0e      	add	r3, sp, #56	; 0x38
 802702e:	4618      	mov	r0, r3
 8027030:	2100      	movs	r1, #0
 8027032:	2208      	movs	r2, #8
 8027034:	9309      	str	r3, [sp, #36]	; 0x24
 8027036:	f7fb fb21 	bl	802267c <memset>
 802703a:	f019 0310 	ands.w	r3, r9, #16
 802703e:	930a      	str	r3, [sp, #40]	; 0x28
 8027040:	d05a      	beq.n	80270f8 <__ssvfiscanf_r+0x7e4>
 8027042:	2300      	movs	r3, #0
 8027044:	4619      	mov	r1, r3
 8027046:	9503      	str	r5, [sp, #12]
 8027048:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 802704a:	970b      	str	r7, [sp, #44]	; 0x2c
 802704c:	f04f 0a00 	mov.w	sl, #0
 8027050:	f10d 0940 	add.w	r9, sp, #64	; 0x40
 8027054:	460f      	mov	r7, r1
 8027056:	f8cd 801c 	str.w	r8, [sp, #28]
 802705a:	f7fe f841 	bl	80250e0 <__locale_mb_cur_max>
 802705e:	4550      	cmp	r0, sl
 8027060:	f43f ad78 	beq.w	8026b54 <__ssvfiscanf_r+0x240>
 8027064:	e894 000a 	ldmia.w	r4, {r1, r3}
 8027068:	9a09      	ldr	r2, [sp, #36]	; 0x24
 802706a:	f811 eb01 	ldrb.w	lr, [r1], #1
 802706e:	6021      	str	r1, [r4, #0]
 8027070:	3b01      	subs	r3, #1
 8027072:	f10a 0801 	add.w	r8, sl, #1
 8027076:	9200      	str	r2, [sp, #0]
 8027078:	4639      	mov	r1, r7
 802707a:	6063      	str	r3, [r4, #4]
 802707c:	9807      	ldr	r0, [sp, #28]
 802707e:	f809 e00a 	strb.w	lr, [r9, sl]
 8027082:	4643      	mov	r3, r8
 8027084:	464a      	mov	r2, r9
 8027086:	f000 f96b 	bl	8027360 <_mbrtowc_r>
 802708a:	1c41      	adds	r1, r0, #1
 802708c:	f43f ad62 	beq.w	8026b54 <__ssvfiscanf_r+0x240>
 8027090:	2800      	cmp	r0, #0
 8027092:	d141      	bne.n	8027118 <__ssvfiscanf_r+0x804>
 8027094:	b905      	cbnz	r5, 8027098 <__ssvfiscanf_r+0x784>
 8027096:	603d      	str	r5, [r7, #0]
 8027098:	9b03      	ldr	r3, [sp, #12]
 802709a:	4443      	add	r3, r8
 802709c:	9303      	str	r3, [sp, #12]
 802709e:	3e01      	subs	r6, #1
 80270a0:	2d00      	cmp	r5, #0
 80270a2:	d13d      	bne.n	8027120 <__ssvfiscanf_r+0x80c>
 80270a4:	3704      	adds	r7, #4
 80270a6:	46aa      	mov	sl, r5
 80270a8:	6863      	ldr	r3, [r4, #4]
 80270aa:	2b00      	cmp	r3, #0
 80270ac:	dd16      	ble.n	80270dc <__ssvfiscanf_r+0x7c8>
 80270ae:	2e00      	cmp	r6, #0
 80270b0:	d1d3      	bne.n	802705a <__ssvfiscanf_r+0x746>
 80270b2:	9d03      	ldr	r5, [sp, #12]
 80270b4:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 80270b6:	f8dd 801c 	ldr.w	r8, [sp, #28]
 80270ba:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80270bc:	2b00      	cmp	r3, #0
 80270be:	d098      	beq.n	8026ff2 <__ssvfiscanf_r+0x6de>
 80270c0:	463a      	mov	r2, r7
 80270c2:	e465      	b.n	8026990 <__ssvfiscanf_r+0x7c>
 80270c4:	f429 69b0 	bic.w	r9, r9, #1408	; 0x580
 80270c8:	e681      	b.n	8026dce <__ssvfiscanf_r+0x4ba>
 80270ca:	9a05      	ldr	r2, [sp, #20]
 80270cc:	4613      	mov	r3, r2
 80270ce:	3304      	adds	r3, #4
 80270d0:	f8d2 a000 	ldr.w	sl, [r2]
 80270d4:	9305      	str	r3, [sp, #20]
 80270d6:	e779      	b.n	8026fcc <__ssvfiscanf_r+0x6b8>
 80270d8:	0802ba74 	.word	0x0802ba74
 80270dc:	9807      	ldr	r0, [sp, #28]
 80270de:	4621      	mov	r1, r4
 80270e0:	f7ff fbba 	bl	8026858 <__ssrefill_r>
 80270e4:	2800      	cmp	r0, #0
 80270e6:	d0e2      	beq.n	80270ae <__ssvfiscanf_r+0x79a>
 80270e8:	9d03      	ldr	r5, [sp, #12]
 80270ea:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 80270ec:	f8dd 801c 	ldr.w	r8, [sp, #28]
 80270f0:	f1ba 0f00 	cmp.w	sl, #0
 80270f4:	d0e1      	beq.n	80270ba <__ssvfiscanf_r+0x7a6>
 80270f6:	e52d      	b.n	8026b54 <__ssvfiscanf_r+0x240>
 80270f8:	9a05      	ldr	r2, [sp, #20]
 80270fa:	6813      	ldr	r3, [r2, #0]
 80270fc:	4619      	mov	r1, r3
 80270fe:	4613      	mov	r3, r2
 8027100:	3304      	adds	r3, #4
 8027102:	9305      	str	r3, [sp, #20]
 8027104:	e79f      	b.n	8027046 <__ssvfiscanf_r+0x732>
 8027106:	f019 0f04 	tst.w	r9, #4
 802710a:	d05b      	beq.n	80271c4 <__ssvfiscanf_r+0x8b0>
 802710c:	9a05      	ldr	r2, [sp, #20]
 802710e:	6813      	ldr	r3, [r2, #0]
 8027110:	3204      	adds	r2, #4
 8027112:	9205      	str	r2, [sp, #20]
 8027114:	8018      	strh	r0, [r3, #0]
 8027116:	e785      	b.n	8027024 <__ssvfiscanf_r+0x710>
 8027118:	3002      	adds	r0, #2
 802711a:	d1bd      	bne.n	8027098 <__ssvfiscanf_r+0x784>
 802711c:	46c2      	mov	sl, r8
 802711e:	e7c3      	b.n	80270a8 <__ssvfiscanf_r+0x794>
 8027120:	f04f 0a00 	mov.w	sl, #0
 8027124:	e7c0      	b.n	80270a8 <__ssvfiscanf_r+0x794>
 8027126:	f1b9 0f00 	cmp.w	r9, #0
 802712a:	f43f ad13 	beq.w	8026b54 <__ssvfiscanf_r+0x240>
 802712e:	444d      	add	r5, r9
 8027130:	e5c4      	b.n	8026cbc <__ssvfiscanf_r+0x3a8>
 8027132:	9b05      	ldr	r3, [sp, #20]
 8027134:	4640      	mov	r0, r8
 8027136:	6819      	ldr	r1, [r3, #0]
 8027138:	9400      	str	r4, [sp, #0]
 802713a:	4633      	mov	r3, r6
 802713c:	2201      	movs	r2, #1
 802713e:	f7ff fba9 	bl	8026894 <_sfread_r>
 8027142:	9b05      	ldr	r3, [sp, #20]
 8027144:	f103 0a04 	add.w	sl, r3, #4
 8027148:	2800      	cmp	r0, #0
 802714a:	f43f ad03 	beq.w	8026b54 <__ssvfiscanf_r+0x240>
 802714e:	9b08      	ldr	r3, [sp, #32]
 8027150:	f8cd a014 	str.w	sl, [sp, #20]
 8027154:	3301      	adds	r3, #1
 8027156:	4405      	add	r5, r0
 8027158:	9308      	str	r3, [sp, #32]
 802715a:	463a      	mov	r2, r7
 802715c:	e418      	b.n	8026990 <__ssvfiscanf_r+0x7c>
 802715e:	4640      	mov	r0, r8
 8027160:	4621      	mov	r1, r4
 8027162:	f7ff fb79 	bl	8026858 <__ssrefill_r>
 8027166:	2800      	cmp	r0, #0
 8027168:	f43f acaa 	beq.w	8026ac0 <__ssvfiscanf_r+0x1ac>
 802716c:	e4f2      	b.n	8026b54 <__ssvfiscanf_r+0x240>
 802716e:	f81a 1c01 	ldrb.w	r1, [sl, #-1]
 8027172:	f8cd c01c 	str.w	ip, [sp, #28]
 8027176:	4640      	mov	r0, r8
 8027178:	4622      	mov	r2, r4
 802717a:	f7ff fb29 	bl	80267d0 <_sungetc_r>
 802717e:	f10a 3aff 	add.w	sl, sl, #4294967295
 8027182:	f8dd c01c 	ldr.w	ip, [sp, #28]
 8027186:	e638      	b.n	8026dfa <__ssvfiscanf_r+0x4e6>
 8027188:	78bb      	ldrb	r3, [r7, #2]
 802718a:	f049 0902 	orr.w	r9, r9, #2
 802718e:	3702      	adds	r7, #2
 8027190:	e40d      	b.n	80269ae <__ssvfiscanf_r+0x9a>
 8027192:	f019 0f01 	tst.w	r9, #1
 8027196:	d10d      	bne.n	80271b4 <__ssvfiscanf_r+0x8a0>
 8027198:	f019 0f02 	tst.w	r9, #2
 802719c:	d00a      	beq.n	80271b4 <__ssvfiscanf_r+0x8a0>
 802719e:	9a05      	ldr	r2, [sp, #20]
 80271a0:	6813      	ldr	r3, [r2, #0]
 80271a2:	4628      	mov	r0, r5
 80271a4:	3204      	adds	r2, #4
 80271a6:	17e9      	asrs	r1, r5, #31
 80271a8:	9205      	str	r2, [sp, #20]
 80271aa:	e9c3 0100 	strd	r0, r1, [r3]
 80271ae:	463a      	mov	r2, r7
 80271b0:	f7ff bbee 	b.w	8026990 <__ssvfiscanf_r+0x7c>
 80271b4:	9a05      	ldr	r2, [sp, #20]
 80271b6:	6813      	ldr	r3, [r2, #0]
 80271b8:	3204      	adds	r2, #4
 80271ba:	9205      	str	r2, [sp, #20]
 80271bc:	601d      	str	r5, [r3, #0]
 80271be:	463a      	mov	r2, r7
 80271c0:	f7ff bbe6 	b.w	8026990 <__ssvfiscanf_r+0x7c>
 80271c4:	f019 0201 	ands.w	r2, r9, #1
 80271c8:	f47f af27 	bne.w	802701a <__ssvfiscanf_r+0x706>
 80271cc:	f019 0f02 	tst.w	r9, #2
 80271d0:	f43f af23 	beq.w	802701a <__ssvfiscanf_r+0x706>
 80271d4:	4b3c      	ldr	r3, [pc, #240]	; (80272c8 <__ssvfiscanf_r+0x9b4>)
 80271d6:	9906      	ldr	r1, [sp, #24]
 80271d8:	f8cd c01c 	str.w	ip, [sp, #28]
 80271dc:	4299      	cmp	r1, r3
 80271de:	4640      	mov	r0, r8
 80271e0:	4661      	mov	r1, ip
 80271e2:	9b04      	ldr	r3, [sp, #16]
 80271e4:	d067      	beq.n	80272b6 <__ssvfiscanf_r+0x9a2>
 80271e6:	f000 f9e9 	bl	80275bc <_strtoll_r>
 80271ea:	f8dd c01c 	ldr.w	ip, [sp, #28]
 80271ee:	9a05      	ldr	r2, [sp, #20]
 80271f0:	6813      	ldr	r3, [r2, #0]
 80271f2:	3204      	adds	r2, #4
 80271f4:	9205      	str	r2, [sp, #20]
 80271f6:	e9c3 0100 	strd	r0, r1, [r3]
 80271fa:	e713      	b.n	8027024 <__ssvfiscanf_r+0x710>
 80271fc:	f7fd ff70 	bl	80250e0 <__locale_mb_cur_max>
 8027200:	4548      	cmp	r0, r9
 8027202:	f43f aca7 	beq.w	8026b54 <__ssvfiscanf_r+0x240>
 8027206:	e894 000a 	ldmia.w	r4, {r1, r3}
 802720a:	f10d 0e40 	add.w	lr, sp, #64	; 0x40
 802720e:	f811 2b01 	ldrb.w	r2, [r1], #1
 8027212:	6021      	str	r1, [r4, #0]
 8027214:	f109 0c01 	add.w	ip, r9, #1
 8027218:	9909      	ldr	r1, [sp, #36]	; 0x24
 802721a:	9100      	str	r1, [sp, #0]
 802721c:	3b01      	subs	r3, #1
 802721e:	6063      	str	r3, [r4, #4]
 8027220:	f80e 2009 	strb.w	r2, [lr, r9]
 8027224:	4663      	mov	r3, ip
 8027226:	4672      	mov	r2, lr
 8027228:	4640      	mov	r0, r8
 802722a:	4651      	mov	r1, sl
 802722c:	f8cd c01c 	str.w	ip, [sp, #28]
 8027230:	f000 f896 	bl	8027360 <_mbrtowc_r>
 8027234:	1c42      	adds	r2, r0, #1
 8027236:	f43f ac8d 	beq.w	8026b54 <__ssvfiscanf_r+0x240>
 802723a:	f8dd c01c 	ldr.w	ip, [sp, #28]
 802723e:	b198      	cbz	r0, 8027268 <__ssvfiscanf_r+0x954>
 8027240:	3002      	adds	r0, #2
 8027242:	bf08      	it	eq
 8027244:	46e1      	moveq	r9, ip
 8027246:	d13b      	bne.n	80272c0 <__ssvfiscanf_r+0x9ac>
 8027248:	6863      	ldr	r3, [r4, #4]
 802724a:	2b00      	cmp	r3, #0
 802724c:	f73f aec0 	bgt.w	8026fd0 <__ssvfiscanf_r+0x6bc>
 8027250:	4640      	mov	r0, r8
 8027252:	4621      	mov	r1, r4
 8027254:	f7ff fb00 	bl	8026858 <__ssrefill_r>
 8027258:	2800      	cmp	r0, #0
 802725a:	f43f aeb9 	beq.w	8026fd0 <__ssvfiscanf_r+0x6bc>
 802725e:	464a      	mov	r2, r9
 8027260:	2a00      	cmp	r2, #0
 8027262:	f47f ac77 	bne.w	8026b54 <__ssvfiscanf_r+0x240>
 8027266:	e6be      	b.n	8026fe6 <__ssvfiscanf_r+0x6d2>
 8027268:	f8ca 0000 	str.w	r0, [sl]
 802726c:	f8cd c01c 	str.w	ip, [sp, #28]
 8027270:	f000 f868 	bl	8027344 <iswspace>
 8027274:	f8dd c01c 	ldr.w	ip, [sp, #28]
 8027278:	b198      	cbz	r0, 80272a2 <__ssvfiscanf_r+0x98e>
 802727a:	46e1      	mov	r9, ip
 802727c:	f1bc 0f00 	cmp.w	ip, #0
 8027280:	f43f aeb1 	beq.w	8026fe6 <__ssvfiscanf_r+0x6d2>
 8027284:	ab10      	add	r3, sp, #64	; 0x40
 8027286:	eb03 060c 	add.w	r6, r3, ip
 802728a:	f109 39ff 	add.w	r9, r9, #4294967295
 802728e:	4640      	mov	r0, r8
 8027290:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 8027294:	4622      	mov	r2, r4
 8027296:	f7ff fa9b 	bl	80267d0 <_sungetc_r>
 802729a:	f1b9 0f00 	cmp.w	r9, #0
 802729e:	d1f4      	bne.n	802728a <__ssvfiscanf_r+0x976>
 80272a0:	e6a1      	b.n	8026fe6 <__ssvfiscanf_r+0x6d2>
 80272a2:	9b03      	ldr	r3, [sp, #12]
 80272a4:	4465      	add	r5, ip
 80272a6:	3e01      	subs	r6, #1
 80272a8:	b91b      	cbnz	r3, 80272b2 <__ssvfiscanf_r+0x99e>
 80272aa:	f10a 0a04 	add.w	sl, sl, #4
 80272ae:	4699      	mov	r9, r3
 80272b0:	e7ca      	b.n	8027248 <__ssvfiscanf_r+0x934>
 80272b2:	4681      	mov	r9, r0
 80272b4:	e7c8      	b.n	8027248 <__ssvfiscanf_r+0x934>
 80272b6:	f000 fa67 	bl	8027788 <_strtoull_r>
 80272ba:	f8dd c01c 	ldr.w	ip, [sp, #28]
 80272be:	e796      	b.n	80271ee <__ssvfiscanf_r+0x8da>
 80272c0:	f8da 0000 	ldr.w	r0, [sl]
 80272c4:	e7d2      	b.n	802726c <__ssvfiscanf_r+0x958>
 80272c6:	bf00      	nop
 80272c8:	08025af9 	.word	0x08025af9

080272cc <__submore>:
 80272cc:	f101 0340 	add.w	r3, r1, #64	; 0x40
 80272d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80272d4:	460c      	mov	r4, r1
 80272d6:	6b09      	ldr	r1, [r1, #48]	; 0x30
 80272d8:	4299      	cmp	r1, r3
 80272da:	d014      	beq.n	8027306 <__submore+0x3a>
 80272dc:	6b66      	ldr	r6, [r4, #52]	; 0x34
 80272de:	0077      	lsls	r7, r6, #1
 80272e0:	463a      	mov	r2, r7
 80272e2:	f7f2 f80d 	bl	8019300 <_realloc_r>
 80272e6:	4605      	mov	r5, r0
 80272e8:	b340      	cbz	r0, 802733c <__submore+0x70>
 80272ea:	eb00 0806 	add.w	r8, r0, r6
 80272ee:	4632      	mov	r2, r6
 80272f0:	4640      	mov	r0, r8
 80272f2:	4629      	mov	r1, r5
 80272f4:	f7d8 fff4 	bl	80002e0 <memcpy>
 80272f8:	f8c4 8000 	str.w	r8, [r4]
 80272fc:	6325      	str	r5, [r4, #48]	; 0x30
 80272fe:	6367      	str	r7, [r4, #52]	; 0x34
 8027300:	2000      	movs	r0, #0
 8027302:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8027306:	f44f 6180 	mov.w	r1, #1024	; 0x400
 802730a:	f7f1 ffe5 	bl	80192d8 <_malloc_r>
 802730e:	b1a8      	cbz	r0, 802733c <__submore+0x70>
 8027310:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8027314:	6320      	str	r0, [r4, #48]	; 0x30
 8027316:	f44f 6280 	mov.w	r2, #1024	; 0x400
 802731a:	6362      	str	r2, [r4, #52]	; 0x34
 802731c:	f880 33ff 	strb.w	r3, [r0, #1023]	; 0x3ff
 8027320:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8027324:	f880 33fe 	strb.w	r3, [r0, #1022]	; 0x3fe
 8027328:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 802732c:	f880 33fd 	strb.w	r3, [r0, #1021]	; 0x3fd
 8027330:	f200 30fd 	addw	r0, r0, #1021	; 0x3fd
 8027334:	6020      	str	r0, [r4, #0]
 8027336:	2000      	movs	r0, #0
 8027338:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802733c:	f04f 30ff 	mov.w	r0, #4294967295
 8027340:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08027344 <iswspace>:
 8027344:	28ff      	cmp	r0, #255	; 0xff
 8027346:	d807      	bhi.n	8027358 <iswspace+0x14>
 8027348:	4b04      	ldr	r3, [pc, #16]	; (802735c <iswspace+0x18>)
 802734a:	681b      	ldr	r3, [r3, #0]
 802734c:	4418      	add	r0, r3
 802734e:	7840      	ldrb	r0, [r0, #1]
 8027350:	f000 0008 	and.w	r0, r0, #8
 8027354:	b2c0      	uxtb	r0, r0
 8027356:	4770      	bx	lr
 8027358:	2000      	movs	r0, #0
 802735a:	4770      	bx	lr
 802735c:	20010114 	.word	0x20010114

08027360 <_mbrtowc_r>:
 8027360:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8027364:	b083      	sub	sp, #12
 8027366:	4605      	mov	r5, r0
 8027368:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 802736a:	4614      	mov	r4, r2
 802736c:	b1b2      	cbz	r2, 802739c <_mbrtowc_r+0x3c>
 802736e:	461f      	mov	r7, r3
 8027370:	4b10      	ldr	r3, [pc, #64]	; (80273b4 <_mbrtowc_r+0x54>)
 8027372:	4688      	mov	r8, r1
 8027374:	f8d3 9000 	ldr.w	r9, [r3]
 8027378:	f7fd feae 	bl	80250d8 <__locale_charset>
 802737c:	4641      	mov	r1, r8
 802737e:	e88d 0041 	stmia.w	sp, {r0, r6}
 8027382:	4622      	mov	r2, r4
 8027384:	463b      	mov	r3, r7
 8027386:	4628      	mov	r0, r5
 8027388:	47c8      	blx	r9
 802738a:	1c43      	adds	r3, r0, #1
 802738c:	d103      	bne.n	8027396 <_mbrtowc_r+0x36>
 802738e:	2200      	movs	r2, #0
 8027390:	238a      	movs	r3, #138	; 0x8a
 8027392:	6032      	str	r2, [r6, #0]
 8027394:	602b      	str	r3, [r5, #0]
 8027396:	b003      	add	sp, #12
 8027398:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802739c:	4b05      	ldr	r3, [pc, #20]	; (80273b4 <_mbrtowc_r+0x54>)
 802739e:	681f      	ldr	r7, [r3, #0]
 80273a0:	f7fd fe9a 	bl	80250d8 <__locale_charset>
 80273a4:	4621      	mov	r1, r4
 80273a6:	e88d 0041 	stmia.w	sp, {r0, r6}
 80273aa:	4a03      	ldr	r2, [pc, #12]	; (80273b8 <_mbrtowc_r+0x58>)
 80273ac:	4628      	mov	r0, r5
 80273ae:	2301      	movs	r3, #1
 80273b0:	47b8      	blx	r7
 80273b2:	e7ea      	b.n	802738a <_mbrtowc_r+0x2a>
 80273b4:	200105e8 	.word	0x200105e8
 80273b8:	0802ba44 	.word	0x0802ba44

080273bc <__ascii_mbtowc>:
 80273bc:	b082      	sub	sp, #8
 80273be:	b149      	cbz	r1, 80273d4 <__ascii_mbtowc+0x18>
 80273c0:	b15a      	cbz	r2, 80273da <__ascii_mbtowc+0x1e>
 80273c2:	b16b      	cbz	r3, 80273e0 <__ascii_mbtowc+0x24>
 80273c4:	7813      	ldrb	r3, [r2, #0]
 80273c6:	600b      	str	r3, [r1, #0]
 80273c8:	7812      	ldrb	r2, [r2, #0]
 80273ca:	1c10      	adds	r0, r2, #0
 80273cc:	bf18      	it	ne
 80273ce:	2001      	movne	r0, #1
 80273d0:	b002      	add	sp, #8
 80273d2:	4770      	bx	lr
 80273d4:	a901      	add	r1, sp, #4
 80273d6:	2a00      	cmp	r2, #0
 80273d8:	d1f3      	bne.n	80273c2 <__ascii_mbtowc+0x6>
 80273da:	4610      	mov	r0, r2
 80273dc:	b002      	add	sp, #8
 80273de:	4770      	bx	lr
 80273e0:	f06f 0001 	mvn.w	r0, #1
 80273e4:	e7f4      	b.n	80273d0 <__ascii_mbtowc+0x14>
 80273e6:	bf00      	nop

080273e8 <memchr>:
 80273e8:	0783      	lsls	r3, r0, #30
 80273ea:	b470      	push	{r4, r5, r6}
 80273ec:	b2c9      	uxtb	r1, r1
 80273ee:	d040      	beq.n	8027472 <memchr+0x8a>
 80273f0:	1e54      	subs	r4, r2, #1
 80273f2:	2a00      	cmp	r2, #0
 80273f4:	d03f      	beq.n	8027476 <memchr+0x8e>
 80273f6:	7803      	ldrb	r3, [r0, #0]
 80273f8:	428b      	cmp	r3, r1
 80273fa:	bf18      	it	ne
 80273fc:	1c43      	addne	r3, r0, #1
 80273fe:	d106      	bne.n	802740e <memchr+0x26>
 8027400:	e01d      	b.n	802743e <memchr+0x56>
 8027402:	b1f4      	cbz	r4, 8027442 <memchr+0x5a>
 8027404:	7802      	ldrb	r2, [r0, #0]
 8027406:	428a      	cmp	r2, r1
 8027408:	f104 34ff 	add.w	r4, r4, #4294967295
 802740c:	d017      	beq.n	802743e <memchr+0x56>
 802740e:	f013 0f03 	tst.w	r3, #3
 8027412:	4618      	mov	r0, r3
 8027414:	f103 0301 	add.w	r3, r3, #1
 8027418:	d1f3      	bne.n	8027402 <memchr+0x1a>
 802741a:	2c03      	cmp	r4, #3
 802741c:	d814      	bhi.n	8027448 <memchr+0x60>
 802741e:	b184      	cbz	r4, 8027442 <memchr+0x5a>
 8027420:	7803      	ldrb	r3, [r0, #0]
 8027422:	428b      	cmp	r3, r1
 8027424:	d00b      	beq.n	802743e <memchr+0x56>
 8027426:	1905      	adds	r5, r0, r4
 8027428:	1c43      	adds	r3, r0, #1
 802742a:	e002      	b.n	8027432 <memchr+0x4a>
 802742c:	7802      	ldrb	r2, [r0, #0]
 802742e:	428a      	cmp	r2, r1
 8027430:	d005      	beq.n	802743e <memchr+0x56>
 8027432:	42ab      	cmp	r3, r5
 8027434:	4618      	mov	r0, r3
 8027436:	f103 0301 	add.w	r3, r3, #1
 802743a:	d1f7      	bne.n	802742c <memchr+0x44>
 802743c:	2000      	movs	r0, #0
 802743e:	bc70      	pop	{r4, r5, r6}
 8027440:	4770      	bx	lr
 8027442:	4620      	mov	r0, r4
 8027444:	bc70      	pop	{r4, r5, r6}
 8027446:	4770      	bx	lr
 8027448:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 802744c:	4602      	mov	r2, r0
 802744e:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 8027452:	4610      	mov	r0, r2
 8027454:	3204      	adds	r2, #4
 8027456:	6803      	ldr	r3, [r0, #0]
 8027458:	4073      	eors	r3, r6
 802745a:	f1a3 3501 	sub.w	r5, r3, #16843009	; 0x1010101
 802745e:	ea25 0303 	bic.w	r3, r5, r3
 8027462:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8027466:	d1da      	bne.n	802741e <memchr+0x36>
 8027468:	3c04      	subs	r4, #4
 802746a:	2c03      	cmp	r4, #3
 802746c:	4610      	mov	r0, r2
 802746e:	d8f0      	bhi.n	8027452 <memchr+0x6a>
 8027470:	e7d5      	b.n	802741e <memchr+0x36>
 8027472:	4614      	mov	r4, r2
 8027474:	e7d1      	b.n	802741a <memchr+0x32>
 8027476:	4610      	mov	r0, r2
 8027478:	e7e1      	b.n	802743e <memchr+0x56>
 802747a:	bf00      	nop

0802747c <memmove>:
 802747c:	4288      	cmp	r0, r1
 802747e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8027480:	d90d      	bls.n	802749e <memmove+0x22>
 8027482:	188b      	adds	r3, r1, r2
 8027484:	4298      	cmp	r0, r3
 8027486:	d20a      	bcs.n	802749e <memmove+0x22>
 8027488:	1881      	adds	r1, r0, r2
 802748a:	2a00      	cmp	r2, #0
 802748c:	d054      	beq.n	8027538 <memmove+0xbc>
 802748e:	1a9a      	subs	r2, r3, r2
 8027490:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8027494:	f801 4d01 	strb.w	r4, [r1, #-1]!
 8027498:	4293      	cmp	r3, r2
 802749a:	d1f9      	bne.n	8027490 <memmove+0x14>
 802749c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802749e:	2a0f      	cmp	r2, #15
 80274a0:	d948      	bls.n	8027534 <memmove+0xb8>
 80274a2:	ea40 0301 	orr.w	r3, r0, r1
 80274a6:	079b      	lsls	r3, r3, #30
 80274a8:	d147      	bne.n	802753a <memmove+0xbe>
 80274aa:	f100 0410 	add.w	r4, r0, #16
 80274ae:	f101 0310 	add.w	r3, r1, #16
 80274b2:	4615      	mov	r5, r2
 80274b4:	f853 6c10 	ldr.w	r6, [r3, #-16]
 80274b8:	f844 6c10 	str.w	r6, [r4, #-16]
 80274bc:	f853 6c0c 	ldr.w	r6, [r3, #-12]
 80274c0:	f844 6c0c 	str.w	r6, [r4, #-12]
 80274c4:	f853 6c08 	ldr.w	r6, [r3, #-8]
 80274c8:	f844 6c08 	str.w	r6, [r4, #-8]
 80274cc:	3d10      	subs	r5, #16
 80274ce:	f853 6c04 	ldr.w	r6, [r3, #-4]
 80274d2:	f844 6c04 	str.w	r6, [r4, #-4]
 80274d6:	2d0f      	cmp	r5, #15
 80274d8:	f103 0310 	add.w	r3, r3, #16
 80274dc:	f104 0410 	add.w	r4, r4, #16
 80274e0:	d8e8      	bhi.n	80274b4 <memmove+0x38>
 80274e2:	f1a2 0310 	sub.w	r3, r2, #16
 80274e6:	f023 030f 	bic.w	r3, r3, #15
 80274ea:	f002 0e0f 	and.w	lr, r2, #15
 80274ee:	3310      	adds	r3, #16
 80274f0:	f1be 0f03 	cmp.w	lr, #3
 80274f4:	4419      	add	r1, r3
 80274f6:	4403      	add	r3, r0
 80274f8:	d921      	bls.n	802753e <memmove+0xc2>
 80274fa:	1f1e      	subs	r6, r3, #4
 80274fc:	460d      	mov	r5, r1
 80274fe:	4674      	mov	r4, lr
 8027500:	3c04      	subs	r4, #4
 8027502:	f855 7b04 	ldr.w	r7, [r5], #4
 8027506:	f846 7f04 	str.w	r7, [r6, #4]!
 802750a:	2c03      	cmp	r4, #3
 802750c:	d8f8      	bhi.n	8027500 <memmove+0x84>
 802750e:	f1ae 0404 	sub.w	r4, lr, #4
 8027512:	f024 0403 	bic.w	r4, r4, #3
 8027516:	3404      	adds	r4, #4
 8027518:	4423      	add	r3, r4
 802751a:	4421      	add	r1, r4
 802751c:	f002 0203 	and.w	r2, r2, #3
 8027520:	b152      	cbz	r2, 8027538 <memmove+0xbc>
 8027522:	3b01      	subs	r3, #1
 8027524:	440a      	add	r2, r1
 8027526:	f811 4b01 	ldrb.w	r4, [r1], #1
 802752a:	f803 4f01 	strb.w	r4, [r3, #1]!
 802752e:	4291      	cmp	r1, r2
 8027530:	d1f9      	bne.n	8027526 <memmove+0xaa>
 8027532:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8027534:	4603      	mov	r3, r0
 8027536:	e7f3      	b.n	8027520 <memmove+0xa4>
 8027538:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802753a:	4603      	mov	r3, r0
 802753c:	e7f1      	b.n	8027522 <memmove+0xa6>
 802753e:	4672      	mov	r2, lr
 8027540:	e7ee      	b.n	8027520 <memmove+0xa4>
 8027542:	bf00      	nop

08027544 <__sccl>:
 8027544:	b470      	push	{r4, r5, r6}
 8027546:	780d      	ldrb	r5, [r1, #0]
 8027548:	2d5e      	cmp	r5, #94	; 0x5e
 802754a:	d02f      	beq.n	80275ac <__sccl+0x68>
 802754c:	2200      	movs	r2, #0
 802754e:	3101      	adds	r1, #1
 8027550:	4616      	mov	r6, r2
 8027552:	1e43      	subs	r3, r0, #1
 8027554:	f100 04ff 	add.w	r4, r0, #255	; 0xff
 8027558:	f803 2f01 	strb.w	r2, [r3, #1]!
 802755c:	42a3      	cmp	r3, r4
 802755e:	d1fb      	bne.n	8027558 <__sccl+0x14>
 8027560:	b185      	cbz	r5, 8027584 <__sccl+0x40>
 8027562:	f086 0201 	eor.w	r2, r6, #1
 8027566:	5542      	strb	r2, [r0, r5]
 8027568:	1c4e      	adds	r6, r1, #1
 802756a:	f816 3c01 	ldrb.w	r3, [r6, #-1]
 802756e:	2b2d      	cmp	r3, #45	; 0x2d
 8027570:	d00e      	beq.n	8027590 <__sccl+0x4c>
 8027572:	2b5d      	cmp	r3, #93	; 0x5d
 8027574:	d009      	beq.n	802758a <__sccl+0x46>
 8027576:	b113      	cbz	r3, 802757e <__sccl+0x3a>
 8027578:	461d      	mov	r5, r3
 802757a:	4631      	mov	r1, r6
 802757c:	e7f3      	b.n	8027566 <__sccl+0x22>
 802757e:	4608      	mov	r0, r1
 8027580:	bc70      	pop	{r4, r5, r6}
 8027582:	4770      	bx	lr
 8027584:	1e48      	subs	r0, r1, #1
 8027586:	bc70      	pop	{r4, r5, r6}
 8027588:	4770      	bx	lr
 802758a:	4630      	mov	r0, r6
 802758c:	bc70      	pop	{r4, r5, r6}
 802758e:	4770      	bx	lr
 8027590:	784c      	ldrb	r4, [r1, #1]
 8027592:	2c5d      	cmp	r4, #93	; 0x5d
 8027594:	d00f      	beq.n	80275b6 <__sccl+0x72>
 8027596:	42a5      	cmp	r5, r4
 8027598:	dc0d      	bgt.n	80275b6 <__sccl+0x72>
 802759a:	3102      	adds	r1, #2
 802759c:	1943      	adds	r3, r0, r5
 802759e:	3501      	adds	r5, #1
 80275a0:	42ac      	cmp	r4, r5
 80275a2:	f803 2f01 	strb.w	r2, [r3, #1]!
 80275a6:	dcfa      	bgt.n	802759e <__sccl+0x5a>
 80275a8:	3602      	adds	r6, #2
 80275aa:	e7de      	b.n	802756a <__sccl+0x26>
 80275ac:	2201      	movs	r2, #1
 80275ae:	784d      	ldrb	r5, [r1, #1]
 80275b0:	4616      	mov	r6, r2
 80275b2:	3102      	adds	r1, #2
 80275b4:	e7cd      	b.n	8027552 <__sccl+0xe>
 80275b6:	4631      	mov	r1, r6
 80275b8:	461d      	mov	r5, r3
 80275ba:	e7d4      	b.n	8027566 <__sccl+0x22>

080275bc <_strtoll_r>:
 80275bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80275c0:	4c70      	ldr	r4, [pc, #448]	; (8027784 <_strtoll_r+0x1c8>)
 80275c2:	b087      	sub	sp, #28
 80275c4:	469b      	mov	fp, r3
 80275c6:	9201      	str	r2, [sp, #4]
 80275c8:	9104      	str	r1, [sp, #16]
 80275ca:	9005      	str	r0, [sp, #20]
 80275cc:	460a      	mov	r2, r1
 80275ce:	f8d4 a000 	ldr.w	sl, [r4]
 80275d2:	e000      	b.n	80275d6 <_strtoll_r+0x1a>
 80275d4:	462a      	mov	r2, r5
 80275d6:	4615      	mov	r5, r2
 80275d8:	f815 4b01 	ldrb.w	r4, [r5], #1
 80275dc:	eb0a 0304 	add.w	r3, sl, r4
 80275e0:	785b      	ldrb	r3, [r3, #1]
 80275e2:	f003 0308 	and.w	r3, r3, #8
 80275e6:	f003 01ff 	and.w	r1, r3, #255	; 0xff
 80275ea:	2b00      	cmp	r3, #0
 80275ec:	d1f2      	bne.n	80275d4 <_strtoll_r+0x18>
 80275ee:	2c2d      	cmp	r4, #45	; 0x2d
 80275f0:	f000 8092 	beq.w	8027718 <_strtoll_r+0x15c>
 80275f4:	2c2b      	cmp	r4, #43	; 0x2b
 80275f6:	bf08      	it	eq
 80275f8:	7854      	ldrbeq	r4, [r2, #1]
 80275fa:	468c      	mov	ip, r1
 80275fc:	bf08      	it	eq
 80275fe:	1c95      	addeq	r5, r2, #2
 8027600:	f1bb 0f00 	cmp.w	fp, #0
 8027604:	d071      	beq.n	80276ea <_strtoll_r+0x12e>
 8027606:	f1bb 0f10 	cmp.w	fp, #16
 802760a:	f000 80a2 	beq.w	8027752 <_strtoll_r+0x196>
 802760e:	465e      	mov	r6, fp
 8027610:	17f7      	asrs	r7, r6, #31
 8027612:	f1bc 0f00 	cmp.w	ip, #0
 8027616:	d171      	bne.n	80276fc <_strtoll_r+0x140>
 8027618:	f04f 38ff 	mov.w	r8, #4294967295
 802761c:	f06f 4900 	mvn.w	r9, #2147483648	; 0x80000000
 8027620:	4640      	mov	r0, r8
 8027622:	4649      	mov	r1, r9
 8027624:	4632      	mov	r2, r6
 8027626:	463b      	mov	r3, r7
 8027628:	f8cd c00c 	str.w	ip, [sp, #12]
 802762c:	f7d9 fd02 	bl	8001034 <__aeabi_uldivmod>
 8027630:	4640      	mov	r0, r8
 8027632:	9202      	str	r2, [sp, #8]
 8027634:	463b      	mov	r3, r7
 8027636:	4632      	mov	r2, r6
 8027638:	4649      	mov	r1, r9
 802763a:	f7d9 fcfb 	bl	8001034 <__aeabi_uldivmod>
 802763e:	f04f 0e00 	mov.w	lr, #0
 8027642:	2200      	movs	r2, #0
 8027644:	2300      	movs	r3, #0
 8027646:	f8dd c00c 	ldr.w	ip, [sp, #12]
 802764a:	f8dd 8008 	ldr.w	r8, [sp, #8]
 802764e:	e01b      	b.n	8027688 <_strtoll_r+0xcc>
 8027650:	3c30      	subs	r4, #48	; 0x30
 8027652:	45a3      	cmp	fp, r4
 8027654:	dd2d      	ble.n	80276b2 <_strtoll_r+0xf6>
 8027656:	f1be 3fff 	cmp.w	lr, #4294967295
 802765a:	d013      	beq.n	8027684 <_strtoll_r+0xc8>
 802765c:	4299      	cmp	r1, r3
 802765e:	bf08      	it	eq
 8027660:	4290      	cmpeq	r0, r2
 8027662:	d352      	bcc.n	802770a <_strtoll_r+0x14e>
 8027664:	428b      	cmp	r3, r1
 8027666:	bf08      	it	eq
 8027668:	4282      	cmpeq	r2, r0
 802766a:	d04c      	beq.n	8027706 <_strtoll_r+0x14a>
 802766c:	fb02 fe07 	mul.w	lr, r2, r7
 8027670:	fb06 ee03 	mla	lr, r6, r3, lr
 8027674:	fba2 2306 	umull	r2, r3, r2, r6
 8027678:	4473      	add	r3, lr
 802767a:	1912      	adds	r2, r2, r4
 802767c:	eb43 73e4 	adc.w	r3, r3, r4, asr #31
 8027680:	f04f 0e01 	mov.w	lr, #1
 8027684:	f815 4b01 	ldrb.w	r4, [r5], #1
 8027688:	eb0a 0904 	add.w	r9, sl, r4
 802768c:	f899 9001 	ldrb.w	r9, [r9, #1]
 8027690:	f019 0f04 	tst.w	r9, #4
 8027694:	d1dc      	bne.n	8027650 <_strtoll_r+0x94>
 8027696:	f019 0903 	ands.w	r9, r9, #3
 802769a:	d00a      	beq.n	80276b2 <_strtoll_r+0xf6>
 802769c:	f1b9 0f01 	cmp.w	r9, #1
 80276a0:	bf0c      	ite	eq
 80276a2:	f04f 0937 	moveq.w	r9, #55	; 0x37
 80276a6:	f04f 0957 	movne.w	r9, #87	; 0x57
 80276aa:	ebc9 0404 	rsb	r4, r9, r4
 80276ae:	45a3      	cmp	fp, r4
 80276b0:	dcd1      	bgt.n	8027656 <_strtoll_r+0x9a>
 80276b2:	f1be 3fff 	cmp.w	lr, #4294967295
 80276b6:	d034      	beq.n	8027722 <_strtoll_r+0x166>
 80276b8:	4660      	mov	r0, ip
 80276ba:	17c1      	asrs	r1, r0, #31
 80276bc:	f1dc 0600 	rsbs	r6, ip, #0
 80276c0:	eb61 0741 	sbc.w	r7, r1, r1, lsl #1
 80276c4:	4072      	eors	r2, r6
 80276c6:	407b      	eors	r3, r7
 80276c8:	eb12 020c 	adds.w	r2, r2, ip
 80276cc:	414b      	adcs	r3, r1
 80276ce:	9901      	ldr	r1, [sp, #4]
 80276d0:	2900      	cmp	r1, #0
 80276d2:	d053      	beq.n	802777c <_strtoll_r+0x1c0>
 80276d4:	f1be 0f00 	cmp.w	lr, #0
 80276d8:	d11a      	bne.n	8027710 <_strtoll_r+0x154>
 80276da:	9d04      	ldr	r5, [sp, #16]
 80276dc:	4610      	mov	r0, r2
 80276de:	4619      	mov	r1, r3
 80276e0:	9b01      	ldr	r3, [sp, #4]
 80276e2:	601d      	str	r5, [r3, #0]
 80276e4:	b007      	add	sp, #28
 80276e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80276ea:	2c30      	cmp	r4, #48	; 0x30
 80276ec:	d027      	beq.n	802773e <_strtoll_r+0x182>
 80276ee:	260a      	movs	r6, #10
 80276f0:	2700      	movs	r7, #0
 80276f2:	f04f 0b0a 	mov.w	fp, #10
 80276f6:	f1bc 0f00 	cmp.w	ip, #0
 80276fa:	d08d      	beq.n	8027618 <_strtoll_r+0x5c>
 80276fc:	f04f 0800 	mov.w	r8, #0
 8027700:	f04f 4900 	mov.w	r9, #2147483648	; 0x80000000
 8027704:	e78c      	b.n	8027620 <_strtoll_r+0x64>
 8027706:	4544      	cmp	r4, r8
 8027708:	ddb0      	ble.n	802766c <_strtoll_r+0xb0>
 802770a:	f04f 3eff 	mov.w	lr, #4294967295
 802770e:	e7b9      	b.n	8027684 <_strtoll_r+0xc8>
 8027710:	4610      	mov	r0, r2
 8027712:	4619      	mov	r1, r3
 8027714:	3d01      	subs	r5, #1
 8027716:	e7e3      	b.n	80276e0 <_strtoll_r+0x124>
 8027718:	1c95      	adds	r5, r2, #2
 802771a:	7854      	ldrb	r4, [r2, #1]
 802771c:	f04f 0c01 	mov.w	ip, #1
 8027720:	e76e      	b.n	8027600 <_strtoll_r+0x44>
 8027722:	f1bc 0f00 	cmp.w	ip, #0
 8027726:	d119      	bne.n	802775c <_strtoll_r+0x1a0>
 8027728:	f04f 30ff 	mov.w	r0, #4294967295
 802772c:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8027730:	9a05      	ldr	r2, [sp, #20]
 8027732:	2322      	movs	r3, #34	; 0x22
 8027734:	6013      	str	r3, [r2, #0]
 8027736:	9b01      	ldr	r3, [sp, #4]
 8027738:	2b00      	cmp	r3, #0
 802773a:	d1eb      	bne.n	8027714 <_strtoll_r+0x158>
 802773c:	e7d2      	b.n	80276e4 <_strtoll_r+0x128>
 802773e:	782b      	ldrb	r3, [r5, #0]
 8027740:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8027744:	2b58      	cmp	r3, #88	; 0x58
 8027746:	d012      	beq.n	802776e <_strtoll_r+0x1b2>
 8027748:	2608      	movs	r6, #8
 802774a:	2700      	movs	r7, #0
 802774c:	f04f 0b08 	mov.w	fp, #8
 8027750:	e75f      	b.n	8027612 <_strtoll_r+0x56>
 8027752:	2c30      	cmp	r4, #48	; 0x30
 8027754:	d006      	beq.n	8027764 <_strtoll_r+0x1a8>
 8027756:	2610      	movs	r6, #16
 8027758:	2700      	movs	r7, #0
 802775a:	e75a      	b.n	8027612 <_strtoll_r+0x56>
 802775c:	2000      	movs	r0, #0
 802775e:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
 8027762:	e7e5      	b.n	8027730 <_strtoll_r+0x174>
 8027764:	782b      	ldrb	r3, [r5, #0]
 8027766:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 802776a:	2b58      	cmp	r3, #88	; 0x58
 802776c:	d1f3      	bne.n	8027756 <_strtoll_r+0x19a>
 802776e:	786c      	ldrb	r4, [r5, #1]
 8027770:	2610      	movs	r6, #16
 8027772:	2700      	movs	r7, #0
 8027774:	3502      	adds	r5, #2
 8027776:	f04f 0b10 	mov.w	fp, #16
 802777a:	e74a      	b.n	8027612 <_strtoll_r+0x56>
 802777c:	4610      	mov	r0, r2
 802777e:	4619      	mov	r1, r3
 8027780:	e7b0      	b.n	80276e4 <_strtoll_r+0x128>
 8027782:	bf00      	nop
 8027784:	20010114 	.word	0x20010114

08027788 <_strtoull_r>:
 8027788:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802778c:	4c72      	ldr	r4, [pc, #456]	; (8027958 <_strtoull_r+0x1d0>)
 802778e:	b087      	sub	sp, #28
 8027790:	4692      	mov	sl, r2
 8027792:	468b      	mov	fp, r1
 8027794:	9004      	str	r0, [sp, #16]
 8027796:	4699      	mov	r9, r3
 8027798:	460a      	mov	r2, r1
 802779a:	f8d4 8000 	ldr.w	r8, [r4]
 802779e:	e000      	b.n	80277a2 <_strtoull_r+0x1a>
 80277a0:	462a      	mov	r2, r5
 80277a2:	4615      	mov	r5, r2
 80277a4:	f815 4b01 	ldrb.w	r4, [r5], #1
 80277a8:	eb08 0304 	add.w	r3, r8, r4
 80277ac:	785b      	ldrb	r3, [r3, #1]
 80277ae:	f003 0308 	and.w	r3, r3, #8
 80277b2:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 80277b6:	2b00      	cmp	r3, #0
 80277b8:	d1f2      	bne.n	80277a0 <_strtoull_r+0x18>
 80277ba:	2c2d      	cmp	r4, #45	; 0x2d
 80277bc:	f000 8099 	beq.w	80278f2 <_strtoull_r+0x16a>
 80277c0:	2c2b      	cmp	r4, #43	; 0x2b
 80277c2:	bf08      	it	eq
 80277c4:	7854      	ldrbeq	r4, [r2, #1]
 80277c6:	9003      	str	r0, [sp, #12]
 80277c8:	bf08      	it	eq
 80277ca:	1c95      	addeq	r5, r2, #2
 80277cc:	f1b9 0f00 	cmp.w	r9, #0
 80277d0:	d01d      	beq.n	802780e <_strtoull_r+0x86>
 80277d2:	f1b9 0f10 	cmp.w	r9, #16
 80277d6:	f000 80a1 	beq.w	802791c <_strtoull_r+0x194>
 80277da:	464e      	mov	r6, r9
 80277dc:	17f7      	asrs	r7, r6, #31
 80277de:	464a      	mov	r2, r9
 80277e0:	463b      	mov	r3, r7
 80277e2:	f04f 30ff 	mov.w	r0, #4294967295
 80277e6:	f04f 31ff 	mov.w	r1, #4294967295
 80277ea:	f7d9 fc23 	bl	8001034 <__aeabi_uldivmod>
 80277ee:	464a      	mov	r2, r9
 80277f0:	9005      	str	r0, [sp, #20]
 80277f2:	9100      	str	r1, [sp, #0]
 80277f4:	463b      	mov	r3, r7
 80277f6:	f04f 30ff 	mov.w	r0, #4294967295
 80277fa:	f04f 31ff 	mov.w	r1, #4294967295
 80277fe:	f7d9 fc19 	bl	8001034 <__aeabi_uldivmod>
 8027802:	f8dd c014 	ldr.w	ip, [sp, #20]
 8027806:	9202      	str	r2, [sp, #8]
 8027808:	4660      	mov	r0, ip
 802780a:	9900      	ldr	r1, [sp, #0]
 802780c:	e00a      	b.n	8027824 <_strtoull_r+0x9c>
 802780e:	2c30      	cmp	r4, #48	; 0x30
 8027810:	d074      	beq.n	80278fc <_strtoull_r+0x174>
 8027812:	2305      	movs	r3, #5
 8027814:	4951      	ldr	r1, [pc, #324]	; (802795c <_strtoull_r+0x1d4>)
 8027816:	9302      	str	r3, [sp, #8]
 8027818:	f04f 3099 	mov.w	r0, #2576980377	; 0x99999999
 802781c:	260a      	movs	r6, #10
 802781e:	2700      	movs	r7, #0
 8027820:	f04f 090a 	mov.w	r9, #10
 8027824:	f04f 0e00 	mov.w	lr, #0
 8027828:	2200      	movs	r2, #0
 802782a:	2300      	movs	r3, #0
 802782c:	e9cd 6700 	strd	r6, r7, [sp]
 8027830:	e01d      	b.n	802786e <_strtoull_r+0xe6>
 8027832:	3c30      	subs	r4, #48	; 0x30
 8027834:	45a1      	cmp	r9, r4
 8027836:	dd2f      	ble.n	8027898 <_strtoull_r+0x110>
 8027838:	f1be 3fff 	cmp.w	lr, #4294967295
 802783c:	d015      	beq.n	802786a <_strtoull_r+0xe2>
 802783e:	4299      	cmp	r1, r3
 8027840:	bf08      	it	eq
 8027842:	4290      	cmpeq	r0, r2
 8027844:	d348      	bcc.n	80278d8 <_strtoull_r+0x150>
 8027846:	428b      	cmp	r3, r1
 8027848:	bf08      	it	eq
 802784a:	4282      	cmpeq	r2, r0
 802784c:	d041      	beq.n	80278d2 <_strtoull_r+0x14a>
 802784e:	9e01      	ldr	r6, [sp, #4]
 8027850:	fb02 fe06 	mul.w	lr, r2, r6
 8027854:	9e00      	ldr	r6, [sp, #0]
 8027856:	fb06 ee03 	mla	lr, r6, r3, lr
 802785a:	fba2 2306 	umull	r2, r3, r2, r6
 802785e:	4473      	add	r3, lr
 8027860:	1912      	adds	r2, r2, r4
 8027862:	eb43 73e4 	adc.w	r3, r3, r4, asr #31
 8027866:	f04f 0e01 	mov.w	lr, #1
 802786a:	f815 4b01 	ldrb.w	r4, [r5], #1
 802786e:	eb08 0c04 	add.w	ip, r8, r4
 8027872:	f89c c001 	ldrb.w	ip, [ip, #1]
 8027876:	f01c 0f04 	tst.w	ip, #4
 802787a:	d1da      	bne.n	8027832 <_strtoull_r+0xaa>
 802787c:	f01c 0c03 	ands.w	ip, ip, #3
 8027880:	d00a      	beq.n	8027898 <_strtoull_r+0x110>
 8027882:	f1bc 0f01 	cmp.w	ip, #1
 8027886:	bf0c      	ite	eq
 8027888:	f04f 0c37 	moveq.w	ip, #55	; 0x37
 802788c:	f04f 0c57 	movne.w	ip, #87	; 0x57
 8027890:	ebcc 0404 	rsb	r4, ip, r4
 8027894:	45a1      	cmp	r9, r4
 8027896:	dccf      	bgt.n	8027838 <_strtoull_r+0xb0>
 8027898:	f1be 0f00 	cmp.w	lr, #0
 802789c:	db21      	blt.n	80278e2 <_strtoull_r+0x15a>
 802789e:	9903      	ldr	r1, [sp, #12]
 80278a0:	460e      	mov	r6, r1
 80278a2:	4276      	negs	r6, r6
 80278a4:	ea4f 77e1 	mov.w	r7, r1, asr #31
 80278a8:	4608      	mov	r0, r1
 80278aa:	ea82 0206 	eor.w	r2, r2, r6
 80278ae:	4639      	mov	r1, r7
 80278b0:	eb67 0747 	sbc.w	r7, r7, r7, lsl #1
 80278b4:	407b      	eors	r3, r7
 80278b6:	1880      	adds	r0, r0, r2
 80278b8:	4159      	adcs	r1, r3
 80278ba:	f1ba 0f00 	cmp.w	sl, #0
 80278be:	d005      	beq.n	80278cc <_strtoull_r+0x144>
 80278c0:	f1be 0f00 	cmp.w	lr, #0
 80278c4:	d00b      	beq.n	80278de <_strtoull_r+0x156>
 80278c6:	3d01      	subs	r5, #1
 80278c8:	f8ca 5000 	str.w	r5, [sl]
 80278cc:	b007      	add	sp, #28
 80278ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80278d2:	9e02      	ldr	r6, [sp, #8]
 80278d4:	42b4      	cmp	r4, r6
 80278d6:	ddba      	ble.n	802784e <_strtoull_r+0xc6>
 80278d8:	f04f 3eff 	mov.w	lr, #4294967295
 80278dc:	e7c5      	b.n	802786a <_strtoull_r+0xe2>
 80278de:	465d      	mov	r5, fp
 80278e0:	e7f2      	b.n	80278c8 <_strtoull_r+0x140>
 80278e2:	9a04      	ldr	r2, [sp, #16]
 80278e4:	2322      	movs	r3, #34	; 0x22
 80278e6:	6013      	str	r3, [r2, #0]
 80278e8:	f04f 30ff 	mov.w	r0, #4294967295
 80278ec:	f04f 31ff 	mov.w	r1, #4294967295
 80278f0:	e7e3      	b.n	80278ba <_strtoull_r+0x132>
 80278f2:	2301      	movs	r3, #1
 80278f4:	1c95      	adds	r5, r2, #2
 80278f6:	7854      	ldrb	r4, [r2, #1]
 80278f8:	9303      	str	r3, [sp, #12]
 80278fa:	e767      	b.n	80277cc <_strtoull_r+0x44>
 80278fc:	782b      	ldrb	r3, [r5, #0]
 80278fe:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8027902:	2b58      	cmp	r3, #88	; 0x58
 8027904:	d01a      	beq.n	802793c <_strtoull_r+0x1b4>
 8027906:	2307      	movs	r3, #7
 8027908:	9302      	str	r3, [sp, #8]
 802790a:	f04f 30ff 	mov.w	r0, #4294967295
 802790e:	f06f 4160 	mvn.w	r1, #3758096384	; 0xe0000000
 8027912:	2608      	movs	r6, #8
 8027914:	2700      	movs	r7, #0
 8027916:	f04f 0908 	mov.w	r9, #8
 802791a:	e783      	b.n	8027824 <_strtoull_r+0x9c>
 802791c:	2c30      	cmp	r4, #48	; 0x30
 802791e:	d008      	beq.n	8027932 <_strtoull_r+0x1aa>
 8027920:	230f      	movs	r3, #15
 8027922:	9302      	str	r3, [sp, #8]
 8027924:	f04f 30ff 	mov.w	r0, #4294967295
 8027928:	f06f 4170 	mvn.w	r1, #4026531840	; 0xf0000000
 802792c:	2610      	movs	r6, #16
 802792e:	2700      	movs	r7, #0
 8027930:	e778      	b.n	8027824 <_strtoull_r+0x9c>
 8027932:	782b      	ldrb	r3, [r5, #0]
 8027934:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8027938:	2b58      	cmp	r3, #88	; 0x58
 802793a:	d1f1      	bne.n	8027920 <_strtoull_r+0x198>
 802793c:	230f      	movs	r3, #15
 802793e:	9302      	str	r3, [sp, #8]
 8027940:	f06f 4370 	mvn.w	r3, #4026531840	; 0xf0000000
 8027944:	786c      	ldrb	r4, [r5, #1]
 8027946:	9300      	str	r3, [sp, #0]
 8027948:	3502      	adds	r5, #2
 802794a:	f04f 3cff 	mov.w	ip, #4294967295
 802794e:	2610      	movs	r6, #16
 8027950:	2700      	movs	r7, #0
 8027952:	f04f 0910 	mov.w	r9, #16
 8027956:	e757      	b.n	8027808 <_strtoull_r+0x80>
 8027958:	20010114 	.word	0x20010114
 802795c:	19999999 	.word	0x19999999

08027960 <ceil>:
 8027960:	ec51 0b10 	vmov	r0, r1, d0
 8027964:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8027968:	f3c1 570a 	ubfx	r7, r1, #20, #11
 802796c:	f2a7 35ff 	subw	r5, r7, #1023	; 0x3ff
 8027970:	2d13      	cmp	r5, #19
 8027972:	460c      	mov	r4, r1
 8027974:	ee10 3a10 	vmov	r3, s0
 8027978:	4688      	mov	r8, r1
 802797a:	4606      	mov	r6, r0
 802797c:	dc20      	bgt.n	80279c0 <ceil+0x60>
 802797e:	2d00      	cmp	r5, #0
 8027980:	db51      	blt.n	8027a26 <ceil+0xc6>
 8027982:	4f3b      	ldr	r7, [pc, #236]	; (8027a70 <ceil+0x110>)
 8027984:	412f      	asrs	r7, r5
 8027986:	ea07 0201 	and.w	r2, r7, r1
 802798a:	4313      	orrs	r3, r2
 802798c:	d01d      	beq.n	80279ca <ceil+0x6a>
 802798e:	a336      	add	r3, pc, #216	; (adr r3, 8027a68 <ceil+0x108>)
 8027990:	e9d3 2300 	ldrd	r2, r3, [r3]
 8027994:	f7d8 feba 	bl	800070c <__adddf3>
 8027998:	2200      	movs	r2, #0
 802799a:	2300      	movs	r3, #0
 802799c:	f7d9 faf8 	bl	8000f90 <__aeabi_dcmpgt>
 80279a0:	b140      	cbz	r0, 80279b4 <ceil+0x54>
 80279a2:	2c00      	cmp	r4, #0
 80279a4:	dd03      	ble.n	80279ae <ceil+0x4e>
 80279a6:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80279aa:	412b      	asrs	r3, r5
 80279ac:	4498      	add	r8, r3
 80279ae:	ea28 0407 	bic.w	r4, r8, r7
 80279b2:	2600      	movs	r6, #0
 80279b4:	4623      	mov	r3, r4
 80279b6:	4632      	mov	r2, r6
 80279b8:	ec43 2b10 	vmov	d0, r2, r3
 80279bc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80279c0:	2d33      	cmp	r5, #51	; 0x33
 80279c2:	dd06      	ble.n	80279d2 <ceil+0x72>
 80279c4:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
 80279c8:	d03f      	beq.n	8027a4a <ceil+0xea>
 80279ca:	ec41 0b10 	vmov	d0, r0, r1
 80279ce:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80279d2:	f2a7 4313 	subw	r3, r7, #1043	; 0x413
 80279d6:	f04f 39ff 	mov.w	r9, #4294967295
 80279da:	fa29 f903 	lsr.w	r9, r9, r3
 80279de:	ea19 0f00 	tst.w	r9, r0
 80279e2:	d0f2      	beq.n	80279ca <ceil+0x6a>
 80279e4:	a320      	add	r3, pc, #128	; (adr r3, 8027a68 <ceil+0x108>)
 80279e6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80279ea:	f7d8 fe8f 	bl	800070c <__adddf3>
 80279ee:	2200      	movs	r2, #0
 80279f0:	2300      	movs	r3, #0
 80279f2:	f7d9 facd 	bl	8000f90 <__aeabi_dcmpgt>
 80279f6:	2800      	cmp	r0, #0
 80279f8:	d0dc      	beq.n	80279b4 <ceil+0x54>
 80279fa:	2c00      	cmp	r4, #0
 80279fc:	dd0a      	ble.n	8027a14 <ceil+0xb4>
 80279fe:	2d14      	cmp	r5, #20
 8027a00:	d006      	beq.n	8027a10 <ceil+0xb0>
 8027a02:	f5c7 6786 	rsb	r7, r7, #1072	; 0x430
 8027a06:	3703      	adds	r7, #3
 8027a08:	2401      	movs	r4, #1
 8027a0a:	40bc      	lsls	r4, r7
 8027a0c:	19a6      	adds	r6, r4, r6
 8027a0e:	d301      	bcc.n	8027a14 <ceil+0xb4>
 8027a10:	f108 0801 	add.w	r8, r8, #1
 8027a14:	4644      	mov	r4, r8
 8027a16:	ea26 0609 	bic.w	r6, r6, r9
 8027a1a:	4623      	mov	r3, r4
 8027a1c:	4632      	mov	r2, r6
 8027a1e:	ec43 2b10 	vmov	d0, r2, r3
 8027a22:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8027a26:	a310      	add	r3, pc, #64	; (adr r3, 8027a68 <ceil+0x108>)
 8027a28:	e9d3 2300 	ldrd	r2, r3, [r3]
 8027a2c:	f7d8 fe6e 	bl	800070c <__adddf3>
 8027a30:	2200      	movs	r2, #0
 8027a32:	2300      	movs	r3, #0
 8027a34:	f7d9 faac 	bl	8000f90 <__aeabi_dcmpgt>
 8027a38:	2800      	cmp	r0, #0
 8027a3a:	d0bb      	beq.n	80279b4 <ceil+0x54>
 8027a3c:	2c00      	cmp	r4, #0
 8027a3e:	db0f      	blt.n	8027a60 <ceil+0x100>
 8027a40:	4326      	orrs	r6, r4
 8027a42:	d00b      	beq.n	8027a5c <ceil+0xfc>
 8027a44:	4c0b      	ldr	r4, [pc, #44]	; (8027a74 <ceil+0x114>)
 8027a46:	2600      	movs	r6, #0
 8027a48:	e7b4      	b.n	80279b4 <ceil+0x54>
 8027a4a:	ee10 2a10 	vmov	r2, s0
 8027a4e:	460b      	mov	r3, r1
 8027a50:	f7d8 fe5c 	bl	800070c <__adddf3>
 8027a54:	ec41 0b10 	vmov	d0, r0, r1
 8027a58:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8027a5c:	4634      	mov	r4, r6
 8027a5e:	e7a9      	b.n	80279b4 <ceil+0x54>
 8027a60:	2600      	movs	r6, #0
 8027a62:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
 8027a66:	e7a5      	b.n	80279b4 <ceil+0x54>
 8027a68:	8800759c 	.word	0x8800759c
 8027a6c:	7e37e43c 	.word	0x7e37e43c
 8027a70:	000fffff 	.word	0x000fffff
 8027a74:	3ff00000 	.word	0x3ff00000

08027a78 <cosf>:
 8027a78:	b500      	push	{lr}
 8027a7a:	ee10 3a10 	vmov	r3, s0
 8027a7e:	4a1a      	ldr	r2, [pc, #104]	; (8027ae8 <cosf+0x70>)
 8027a80:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8027a84:	4293      	cmp	r3, r2
 8027a86:	b083      	sub	sp, #12
 8027a88:	dd19      	ble.n	8027abe <cosf+0x46>
 8027a8a:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8027a8e:	db04      	blt.n	8027a9a <cosf+0x22>
 8027a90:	ee30 0a40 	vsub.f32	s0, s0, s0
 8027a94:	b003      	add	sp, #12
 8027a96:	f85d fb04 	ldr.w	pc, [sp], #4
 8027a9a:	4668      	mov	r0, sp
 8027a9c:	f000 f866 	bl	8027b6c <__ieee754_rem_pio2f>
 8027aa0:	f000 0003 	and.w	r0, r0, #3
 8027aa4:	2801      	cmp	r0, #1
 8027aa6:	ed9d 0a00 	vldr	s0, [sp]
 8027aaa:	eddd 0a01 	vldr	s1, [sp, #4]
 8027aae:	d012      	beq.n	8027ad6 <cosf+0x5e>
 8027ab0:	2802      	cmp	r0, #2
 8027ab2:	d00b      	beq.n	8027acc <cosf+0x54>
 8027ab4:	b1a0      	cbz	r0, 8027ae0 <cosf+0x68>
 8027ab6:	2001      	movs	r0, #1
 8027ab8:	f000 fd14 	bl	80284e4 <__kernel_sinf>
 8027abc:	e7ea      	b.n	8027a94 <cosf+0x1c>
 8027abe:	eddf 0a0b 	vldr	s1, [pc, #44]	; 8027aec <cosf+0x74>
 8027ac2:	f000 f99b 	bl	8027dfc <__kernel_cosf>
 8027ac6:	b003      	add	sp, #12
 8027ac8:	f85d fb04 	ldr.w	pc, [sp], #4
 8027acc:	f000 f996 	bl	8027dfc <__kernel_cosf>
 8027ad0:	eeb1 0a40 	vneg.f32	s0, s0
 8027ad4:	e7de      	b.n	8027a94 <cosf+0x1c>
 8027ad6:	f000 fd05 	bl	80284e4 <__kernel_sinf>
 8027ada:	eeb1 0a40 	vneg.f32	s0, s0
 8027ade:	e7d9      	b.n	8027a94 <cosf+0x1c>
 8027ae0:	f000 f98c 	bl	8027dfc <__kernel_cosf>
 8027ae4:	e7d6      	b.n	8027a94 <cosf+0x1c>
 8027ae6:	bf00      	nop
 8027ae8:	3f490fd8 	.word	0x3f490fd8
 8027aec:	00000000 	.word	0x00000000

08027af0 <sinf>:
 8027af0:	b500      	push	{lr}
 8027af2:	ee10 3a10 	vmov	r3, s0
 8027af6:	4a1b      	ldr	r2, [pc, #108]	; (8027b64 <sinf+0x74>)
 8027af8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8027afc:	4293      	cmp	r3, r2
 8027afe:	b083      	sub	sp, #12
 8027b00:	dd1a      	ble.n	8027b38 <sinf+0x48>
 8027b02:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8027b06:	db04      	blt.n	8027b12 <sinf+0x22>
 8027b08:	ee30 0a40 	vsub.f32	s0, s0, s0
 8027b0c:	b003      	add	sp, #12
 8027b0e:	f85d fb04 	ldr.w	pc, [sp], #4
 8027b12:	4668      	mov	r0, sp
 8027b14:	f000 f82a 	bl	8027b6c <__ieee754_rem_pio2f>
 8027b18:	f000 0003 	and.w	r0, r0, #3
 8027b1c:	2801      	cmp	r0, #1
 8027b1e:	ed9d 0a00 	vldr	s0, [sp]
 8027b22:	eddd 0a01 	vldr	s1, [sp, #4]
 8027b26:	d015      	beq.n	8027b54 <sinf+0x64>
 8027b28:	2802      	cmp	r0, #2
 8027b2a:	d00d      	beq.n	8027b48 <sinf+0x58>
 8027b2c:	b1a8      	cbz	r0, 8027b5a <sinf+0x6a>
 8027b2e:	f000 f965 	bl	8027dfc <__kernel_cosf>
 8027b32:	eeb1 0a40 	vneg.f32	s0, s0
 8027b36:	e7e9      	b.n	8027b0c <sinf+0x1c>
 8027b38:	eddf 0a0b 	vldr	s1, [pc, #44]	; 8027b68 <sinf+0x78>
 8027b3c:	2000      	movs	r0, #0
 8027b3e:	f000 fcd1 	bl	80284e4 <__kernel_sinf>
 8027b42:	b003      	add	sp, #12
 8027b44:	f85d fb04 	ldr.w	pc, [sp], #4
 8027b48:	2001      	movs	r0, #1
 8027b4a:	f000 fccb 	bl	80284e4 <__kernel_sinf>
 8027b4e:	eeb1 0a40 	vneg.f32	s0, s0
 8027b52:	e7db      	b.n	8027b0c <sinf+0x1c>
 8027b54:	f000 f952 	bl	8027dfc <__kernel_cosf>
 8027b58:	e7d8      	b.n	8027b0c <sinf+0x1c>
 8027b5a:	2001      	movs	r0, #1
 8027b5c:	f000 fcc2 	bl	80284e4 <__kernel_sinf>
 8027b60:	e7d4      	b.n	8027b0c <sinf+0x1c>
 8027b62:	bf00      	nop
 8027b64:	3f490fd8 	.word	0x3f490fd8
 8027b68:	00000000 	.word	0x00000000

08027b6c <__ieee754_rem_pio2f>:
 8027b6c:	b570      	push	{r4, r5, r6, lr}
 8027b6e:	ee10 3a10 	vmov	r3, s0
 8027b72:	4a94      	ldr	r2, [pc, #592]	; (8027dc4 <__ieee754_rem_pio2f+0x258>)
 8027b74:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
 8027b78:	4294      	cmp	r4, r2
 8027b7a:	b086      	sub	sp, #24
 8027b7c:	ee10 6a10 	vmov	r6, s0
 8027b80:	4605      	mov	r5, r0
 8027b82:	dd66      	ble.n	8027c52 <__ieee754_rem_pio2f+0xe6>
 8027b84:	4a90      	ldr	r2, [pc, #576]	; (8027dc8 <__ieee754_rem_pio2f+0x25c>)
 8027b86:	4294      	cmp	r4, r2
 8027b88:	dc1a      	bgt.n	8027bc0 <__ieee754_rem_pio2f+0x54>
 8027b8a:	2b00      	cmp	r3, #0
 8027b8c:	eddf 7a8f 	vldr	s15, [pc, #572]	; 8027dcc <__ieee754_rem_pio2f+0x260>
 8027b90:	4a8f      	ldr	r2, [pc, #572]	; (8027dd0 <__ieee754_rem_pio2f+0x264>)
 8027b92:	f024 040f 	bic.w	r4, r4, #15
 8027b96:	f340 80dd 	ble.w	8027d54 <__ieee754_rem_pio2f+0x1e8>
 8027b9a:	4294      	cmp	r4, r2
 8027b9c:	ee70 7a67 	vsub.f32	s15, s0, s15
 8027ba0:	d066      	beq.n	8027c70 <__ieee754_rem_pio2f+0x104>
 8027ba2:	ed9f 7a8c 	vldr	s14, [pc, #560]	; 8027dd4 <__ieee754_rem_pio2f+0x268>
 8027ba6:	ee77 6ac7 	vsub.f32	s13, s15, s14
 8027baa:	2001      	movs	r0, #1
 8027bac:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8027bb0:	edc5 6a00 	vstr	s13, [r5]
 8027bb4:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8027bb8:	edc5 7a01 	vstr	s15, [r5, #4]
 8027bbc:	b006      	add	sp, #24
 8027bbe:	bd70      	pop	{r4, r5, r6, pc}
 8027bc0:	4a85      	ldr	r2, [pc, #532]	; (8027dd8 <__ieee754_rem_pio2f+0x26c>)
 8027bc2:	4294      	cmp	r4, r2
 8027bc4:	dd66      	ble.n	8027c94 <__ieee754_rem_pio2f+0x128>
 8027bc6:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 8027bca:	da49      	bge.n	8027c60 <__ieee754_rem_pio2f+0xf4>
 8027bcc:	15e2      	asrs	r2, r4, #23
 8027bce:	3a86      	subs	r2, #134	; 0x86
 8027bd0:	eba4 53c2 	sub.w	r3, r4, r2, lsl #23
 8027bd4:	ee07 3a10 	vmov	s14, r3
 8027bd8:	eefd 6ac7 	vcvt.s32.f32	s13, s14
 8027bdc:	eddf 7a7f 	vldr	s15, [pc, #508]	; 8027ddc <__ieee754_rem_pio2f+0x270>
 8027be0:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 8027be4:	ee37 7a66 	vsub.f32	s14, s14, s13
 8027be8:	edcd 6a03 	vstr	s13, [sp, #12]
 8027bec:	ee27 7a27 	vmul.f32	s14, s14, s15
 8027bf0:	eefd 6ac7 	vcvt.s32.f32	s13, s14
 8027bf4:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 8027bf8:	ee37 7a66 	vsub.f32	s14, s14, s13
 8027bfc:	edcd 6a04 	vstr	s13, [sp, #16]
 8027c00:	ee67 7a27 	vmul.f32	s15, s14, s15
 8027c04:	eef5 7a40 	vcmp.f32	s15, #0.0
 8027c08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027c0c:	edcd 7a05 	vstr	s15, [sp, #20]
 8027c10:	f040 80b3 	bne.w	8027d7a <__ieee754_rem_pio2f+0x20e>
 8027c14:	eef5 6a40 	vcmp.f32	s13, #0.0
 8027c18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027c1c:	bf14      	ite	ne
 8027c1e:	2302      	movne	r3, #2
 8027c20:	2301      	moveq	r3, #1
 8027c22:	496f      	ldr	r1, [pc, #444]	; (8027de0 <__ieee754_rem_pio2f+0x274>)
 8027c24:	2002      	movs	r0, #2
 8027c26:	e88d 0003 	stmia.w	sp, {r0, r1}
 8027c2a:	a803      	add	r0, sp, #12
 8027c2c:	4629      	mov	r1, r5
 8027c2e:	f000 f967 	bl	8027f00 <__kernel_rem_pio2f>
 8027c32:	2e00      	cmp	r6, #0
 8027c34:	da12      	bge.n	8027c5c <__ieee754_rem_pio2f+0xf0>
 8027c36:	ed95 7a00 	vldr	s14, [r5]
 8027c3a:	edd5 7a01 	vldr	s15, [r5, #4]
 8027c3e:	eeb1 7a47 	vneg.f32	s14, s14
 8027c42:	eef1 7a67 	vneg.f32	s15, s15
 8027c46:	4240      	negs	r0, r0
 8027c48:	ed85 7a00 	vstr	s14, [r5]
 8027c4c:	edc5 7a01 	vstr	s15, [r5, #4]
 8027c50:	e004      	b.n	8027c5c <__ieee754_rem_pio2f+0xf0>
 8027c52:	2200      	movs	r2, #0
 8027c54:	ed85 0a00 	vstr	s0, [r5]
 8027c58:	6042      	str	r2, [r0, #4]
 8027c5a:	2000      	movs	r0, #0
 8027c5c:	b006      	add	sp, #24
 8027c5e:	bd70      	pop	{r4, r5, r6, pc}
 8027c60:	ee70 7a40 	vsub.f32	s15, s0, s0
 8027c64:	2000      	movs	r0, #0
 8027c66:	edc5 7a01 	vstr	s15, [r5, #4]
 8027c6a:	edc5 7a00 	vstr	s15, [r5]
 8027c6e:	e7f5      	b.n	8027c5c <__ieee754_rem_pio2f+0xf0>
 8027c70:	eddf 6a5c 	vldr	s13, [pc, #368]	; 8027de4 <__ieee754_rem_pio2f+0x278>
 8027c74:	ed9f 7a5c 	vldr	s14, [pc, #368]	; 8027de8 <__ieee754_rem_pio2f+0x27c>
 8027c78:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8027c7c:	2001      	movs	r0, #1
 8027c7e:	ee77 6ac7 	vsub.f32	s13, s15, s14
 8027c82:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8027c86:	edc5 6a00 	vstr	s13, [r5]
 8027c8a:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8027c8e:	edc5 7a01 	vstr	s15, [r5, #4]
 8027c92:	e7e3      	b.n	8027c5c <__ieee754_rem_pio2f+0xf0>
 8027c94:	f000 fc6e 	bl	8028574 <fabsf>
 8027c98:	eddf 6a54 	vldr	s13, [pc, #336]	; 8027dec <__ieee754_rem_pio2f+0x280>
 8027c9c:	eddf 5a4b 	vldr	s11, [pc, #300]	; 8027dcc <__ieee754_rem_pio2f+0x260>
 8027ca0:	ed9f 7a4c 	vldr	s14, [pc, #304]	; 8027dd4 <__ieee754_rem_pio2f+0x268>
 8027ca4:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 8027ca8:	eee0 7a26 	vfma.f32	s15, s0, s13
 8027cac:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8027cb0:	ee17 0a90 	vmov	r0, s15
 8027cb4:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 8027cb8:	281f      	cmp	r0, #31
 8027cba:	eeb1 6a66 	vneg.f32	s12, s13
 8027cbe:	eea6 0a25 	vfma.f32	s0, s12, s11
 8027cc2:	ee66 7a87 	vmul.f32	s15, s13, s14
 8027cc6:	dc1d      	bgt.n	8027d04 <__ieee754_rem_pio2f+0x198>
 8027cc8:	4a49      	ldr	r2, [pc, #292]	; (8027df0 <__ieee754_rem_pio2f+0x284>)
 8027cca:	1e41      	subs	r1, r0, #1
 8027ccc:	f024 03ff 	bic.w	r3, r4, #255	; 0xff
 8027cd0:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 8027cd4:	4293      	cmp	r3, r2
 8027cd6:	d015      	beq.n	8027d04 <__ieee754_rem_pio2f+0x198>
 8027cd8:	ee30 7a67 	vsub.f32	s14, s0, s15
 8027cdc:	ed85 7a00 	vstr	s14, [r5]
 8027ce0:	ee30 0a47 	vsub.f32	s0, s0, s14
 8027ce4:	2e00      	cmp	r6, #0
 8027ce6:	ee30 0a67 	vsub.f32	s0, s0, s15
 8027cea:	ed85 0a01 	vstr	s0, [r5, #4]
 8027cee:	dab5      	bge.n	8027c5c <__ieee754_rem_pio2f+0xf0>
 8027cf0:	eeb1 7a47 	vneg.f32	s14, s14
 8027cf4:	eeb1 0a40 	vneg.f32	s0, s0
 8027cf8:	ed85 7a00 	vstr	s14, [r5]
 8027cfc:	ed85 0a01 	vstr	s0, [r5, #4]
 8027d00:	4240      	negs	r0, r0
 8027d02:	e7ab      	b.n	8027c5c <__ieee754_rem_pio2f+0xf0>
 8027d04:	ee30 7a67 	vsub.f32	s14, s0, s15
 8027d08:	15e4      	asrs	r4, r4, #23
 8027d0a:	ee17 3a10 	vmov	r3, s14
 8027d0e:	f3c3 53c7 	ubfx	r3, r3, #23, #8
 8027d12:	1ae3      	subs	r3, r4, r3
 8027d14:	2b08      	cmp	r3, #8
 8027d16:	dde1      	ble.n	8027cdc <__ieee754_rem_pio2f+0x170>
 8027d18:	eddf 7a32 	vldr	s15, [pc, #200]	; 8027de4 <__ieee754_rem_pio2f+0x278>
 8027d1c:	ed9f 7a32 	vldr	s14, [pc, #200]	; 8027de8 <__ieee754_rem_pio2f+0x27c>
 8027d20:	eef0 5a40 	vmov.f32	s11, s0
 8027d24:	eee6 5a27 	vfma.f32	s11, s12, s15
 8027d28:	ee30 0a65 	vsub.f32	s0, s0, s11
 8027d2c:	eea6 0a27 	vfma.f32	s0, s12, s15
 8027d30:	eef0 7a40 	vmov.f32	s15, s0
 8027d34:	eed6 7a87 	vfnms.f32	s15, s13, s14
 8027d38:	ee35 7ae7 	vsub.f32	s14, s11, s15
 8027d3c:	ee17 3a10 	vmov	r3, s14
 8027d40:	f3c3 53c7 	ubfx	r3, r3, #23, #8
 8027d44:	1ae4      	subs	r4, r4, r3
 8027d46:	2c19      	cmp	r4, #25
 8027d48:	dc2c      	bgt.n	8027da4 <__ieee754_rem_pio2f+0x238>
 8027d4a:	ed85 7a00 	vstr	s14, [r5]
 8027d4e:	eeb0 0a65 	vmov.f32	s0, s11
 8027d52:	e7c5      	b.n	8027ce0 <__ieee754_rem_pio2f+0x174>
 8027d54:	4294      	cmp	r4, r2
 8027d56:	ee70 7a27 	vadd.f32	s15, s0, s15
 8027d5a:	d010      	beq.n	8027d7e <__ieee754_rem_pio2f+0x212>
 8027d5c:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 8027dd4 <__ieee754_rem_pio2f+0x268>
 8027d60:	ee77 6a87 	vadd.f32	s13, s15, s14
 8027d64:	f04f 30ff 	mov.w	r0, #4294967295
 8027d68:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8027d6c:	edc5 6a00 	vstr	s13, [r5]
 8027d70:	ee77 7a87 	vadd.f32	s15, s15, s14
 8027d74:	edc5 7a01 	vstr	s15, [r5, #4]
 8027d78:	e770      	b.n	8027c5c <__ieee754_rem_pio2f+0xf0>
 8027d7a:	2303      	movs	r3, #3
 8027d7c:	e751      	b.n	8027c22 <__ieee754_rem_pio2f+0xb6>
 8027d7e:	eddf 6a19 	vldr	s13, [pc, #100]	; 8027de4 <__ieee754_rem_pio2f+0x278>
 8027d82:	ed9f 7a19 	vldr	s14, [pc, #100]	; 8027de8 <__ieee754_rem_pio2f+0x27c>
 8027d86:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8027d8a:	f04f 30ff 	mov.w	r0, #4294967295
 8027d8e:	ee77 6a87 	vadd.f32	s13, s15, s14
 8027d92:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8027d96:	edc5 6a00 	vstr	s13, [r5]
 8027d9a:	ee77 7a87 	vadd.f32	s15, s15, s14
 8027d9e:	edc5 7a01 	vstr	s15, [r5, #4]
 8027da2:	e75b      	b.n	8027c5c <__ieee754_rem_pio2f+0xf0>
 8027da4:	ed9f 7a13 	vldr	s14, [pc, #76]	; 8027df4 <__ieee754_rem_pio2f+0x288>
 8027da8:	ed9f 5a13 	vldr	s10, [pc, #76]	; 8027df8 <__ieee754_rem_pio2f+0x28c>
 8027dac:	eeb0 0a65 	vmov.f32	s0, s11
 8027db0:	eea6 0a07 	vfma.f32	s0, s12, s14
 8027db4:	ee75 7ac0 	vsub.f32	s15, s11, s0
 8027db8:	eee6 7a07 	vfma.f32	s15, s12, s14
 8027dbc:	eed6 7a85 	vfnms.f32	s15, s13, s10
 8027dc0:	e78a      	b.n	8027cd8 <__ieee754_rem_pio2f+0x16c>
 8027dc2:	bf00      	nop
 8027dc4:	3f490fd8 	.word	0x3f490fd8
 8027dc8:	4016cbe3 	.word	0x4016cbe3
 8027dcc:	3fc90f80 	.word	0x3fc90f80
 8027dd0:	3fc90fd0 	.word	0x3fc90fd0
 8027dd4:	37354443 	.word	0x37354443
 8027dd8:	43490f80 	.word	0x43490f80
 8027ddc:	43800000 	.word	0x43800000
 8027de0:	0802bb18 	.word	0x0802bb18
 8027de4:	37354400 	.word	0x37354400
 8027de8:	2e85a308 	.word	0x2e85a308
 8027dec:	3f22f984 	.word	0x3f22f984
 8027df0:	0802ba98 	.word	0x0802ba98
 8027df4:	2e85a300 	.word	0x2e85a300
 8027df8:	248d3132 	.word	0x248d3132

08027dfc <__kernel_cosf>:
 8027dfc:	ee10 3a10 	vmov	r3, s0
 8027e00:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8027e04:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 8027e08:	da2c      	bge.n	8027e64 <__kernel_cosf+0x68>
 8027e0a:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8027e0e:	ee17 3a90 	vmov	r3, s15
 8027e12:	2b00      	cmp	r3, #0
 8027e14:	d060      	beq.n	8027ed8 <__kernel_cosf+0xdc>
 8027e16:	ee20 7a00 	vmul.f32	s14, s0, s0
 8027e1a:	eddf 4a31 	vldr	s9, [pc, #196]	; 8027ee0 <__kernel_cosf+0xe4>
 8027e1e:	ed9f 5a31 	vldr	s10, [pc, #196]	; 8027ee4 <__kernel_cosf+0xe8>
 8027e22:	eddf 5a31 	vldr	s11, [pc, #196]	; 8027ee8 <__kernel_cosf+0xec>
 8027e26:	ed9f 6a31 	vldr	s12, [pc, #196]	; 8027eec <__kernel_cosf+0xf0>
 8027e2a:	eddf 7a31 	vldr	s15, [pc, #196]	; 8027ef0 <__kernel_cosf+0xf4>
 8027e2e:	eddf 6a31 	vldr	s13, [pc, #196]	; 8027ef4 <__kernel_cosf+0xf8>
 8027e32:	eea7 5a24 	vfma.f32	s10, s14, s9
 8027e36:	eee5 5a07 	vfma.f32	s11, s10, s14
 8027e3a:	eea5 6a87 	vfma.f32	s12, s11, s14
 8027e3e:	eee6 7a07 	vfma.f32	s15, s12, s14
 8027e42:	eee7 6a87 	vfma.f32	s13, s15, s14
 8027e46:	ee66 6a87 	vmul.f32	s13, s13, s14
 8027e4a:	ee60 0ac0 	vnmul.f32	s1, s1, s0
 8027e4e:	eeb6 6a00 	vmov.f32	s12, #96	; 0x60
 8027e52:	eee7 0a26 	vfma.f32	s1, s14, s13
 8027e56:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 8027e5a:	eed7 0a06 	vfnms.f32	s1, s14, s12
 8027e5e:	ee37 0ae0 	vsub.f32	s0, s15, s1
 8027e62:	4770      	bx	lr
 8027e64:	ee20 7a00 	vmul.f32	s14, s0, s0
 8027e68:	eddf 4a1d 	vldr	s9, [pc, #116]	; 8027ee0 <__kernel_cosf+0xe4>
 8027e6c:	ed9f 5a1d 	vldr	s10, [pc, #116]	; 8027ee4 <__kernel_cosf+0xe8>
 8027e70:	eddf 5a1d 	vldr	s11, [pc, #116]	; 8027ee8 <__kernel_cosf+0xec>
 8027e74:	ed9f 6a1d 	vldr	s12, [pc, #116]	; 8027eec <__kernel_cosf+0xf0>
 8027e78:	eddf 7a1d 	vldr	s15, [pc, #116]	; 8027ef0 <__kernel_cosf+0xf4>
 8027e7c:	eddf 6a1d 	vldr	s13, [pc, #116]	; 8027ef4 <__kernel_cosf+0xf8>
 8027e80:	4a1d      	ldr	r2, [pc, #116]	; (8027ef8 <__kernel_cosf+0xfc>)
 8027e82:	eea7 5a24 	vfma.f32	s10, s14, s9
 8027e86:	4293      	cmp	r3, r2
 8027e88:	eee5 5a07 	vfma.f32	s11, s10, s14
 8027e8c:	eea5 6a87 	vfma.f32	s12, s11, s14
 8027e90:	eee6 7a07 	vfma.f32	s15, s12, s14
 8027e94:	eee7 6a87 	vfma.f32	s13, s15, s14
 8027e98:	ee66 6a87 	vmul.f32	s13, s13, s14
 8027e9c:	ddd5      	ble.n	8027e4a <__kernel_cosf+0x4e>
 8027e9e:	4a17      	ldr	r2, [pc, #92]	; (8027efc <__kernel_cosf+0x100>)
 8027ea0:	4293      	cmp	r3, r2
 8027ea2:	dc14      	bgt.n	8027ece <__kernel_cosf+0xd2>
 8027ea4:	f103 437f 	add.w	r3, r3, #4278190080	; 0xff000000
 8027ea8:	ee07 3a90 	vmov	s15, r3
 8027eac:	eeb7 6a00 	vmov.f32	s12, #112	; 0x70
 8027eb0:	ee36 6a67 	vsub.f32	s12, s12, s15
 8027eb4:	ee60 0ac0 	vnmul.f32	s1, s1, s0
 8027eb8:	eef6 5a00 	vmov.f32	s11, #96	; 0x60
 8027ebc:	eee7 0a26 	vfma.f32	s1, s14, s13
 8027ec0:	eed7 7a25 	vfnms.f32	s15, s14, s11
 8027ec4:	ee77 7ae0 	vsub.f32	s15, s15, s1
 8027ec8:	ee36 0a67 	vsub.f32	s0, s12, s15
 8027ecc:	4770      	bx	lr
 8027ece:	eeb6 6a07 	vmov.f32	s12, #103	; 0x67
 8027ed2:	eef5 7a02 	vmov.f32	s15, #82	; 0x52
 8027ed6:	e7ed      	b.n	8027eb4 <__kernel_cosf+0xb8>
 8027ed8:	eeb7 0a00 	vmov.f32	s0, #112	; 0x70
 8027edc:	4770      	bx	lr
 8027ede:	bf00      	nop
 8027ee0:	ad47d74e 	.word	0xad47d74e
 8027ee4:	310f74f6 	.word	0x310f74f6
 8027ee8:	b493f27c 	.word	0xb493f27c
 8027eec:	37d00d01 	.word	0x37d00d01
 8027ef0:	bab60b61 	.word	0xbab60b61
 8027ef4:	3d2aaaab 	.word	0x3d2aaaab
 8027ef8:	3e999999 	.word	0x3e999999
 8027efc:	3f480000 	.word	0x3f480000

08027f00 <__kernel_rem_pio2f>:
 8027f00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8027f04:	ed2d 8b04 	vpush	{d8-d9}
 8027f08:	b0d7      	sub	sp, #348	; 0x15c
 8027f0a:	1e5f      	subs	r7, r3, #1
 8027f0c:	4cd7      	ldr	r4, [pc, #860]	; (802826c <__kernel_rem_pio2f+0x36c>)
 8027f0e:	9d64      	ldr	r5, [sp, #400]	; 0x190
 8027f10:	9302      	str	r3, [sp, #8]
 8027f12:	1ed3      	subs	r3, r2, #3
 8027f14:	bf48      	it	mi
 8027f16:	1d13      	addmi	r3, r2, #4
 8027f18:	f854 6025 	ldr.w	r6, [r4, r5, lsl #2]
 8027f1c:	9101      	str	r1, [sp, #4]
 8027f1e:	10db      	asrs	r3, r3, #3
 8027f20:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8027f24:	ea6f 0b03 	mvn.w	fp, r3
 8027f28:	19b9      	adds	r1, r7, r6
 8027f2a:	9303      	str	r3, [sp, #12]
 8027f2c:	4682      	mov	sl, r0
 8027f2e:	eb02 0bcb 	add.w	fp, r2, fp, lsl #3
 8027f32:	eba3 0307 	sub.w	r3, r3, r7
 8027f36:	d414      	bmi.n	8027f62 <__kernel_rem_pio2f+0x62>
 8027f38:	4419      	add	r1, r3
 8027f3a:	9865      	ldr	r0, [sp, #404]	; 0x194
 8027f3c:	3101      	adds	r1, #1
 8027f3e:	aa1a      	add	r2, sp, #104	; 0x68
 8027f40:	2b00      	cmp	r3, #0
 8027f42:	bfaa      	itet	ge
 8027f44:	f850 4023 	ldrge.w	r4, [r0, r3, lsl #2]
 8027f48:	eddf 7acc 	vldrlt	s15, [pc, #816]	; 802827c <__kernel_rem_pio2f+0x37c>
 8027f4c:	ee07 4a90 	vmovge	s15, r4
 8027f50:	f103 0301 	add.w	r3, r3, #1
 8027f54:	bfa8      	it	ge
 8027f56:	eef8 7ae7 	vcvtge.f32.s32	s15, s15
 8027f5a:	428b      	cmp	r3, r1
 8027f5c:	ece2 7a01 	vstmia	r2!, {s15}
 8027f60:	d1ee      	bne.n	8027f40 <__kernel_rem_pio2f+0x40>
 8027f62:	2e00      	cmp	r6, #0
 8027f64:	db1a      	blt.n	8027f9c <__kernel_rem_pio2f+0x9c>
 8027f66:	9b02      	ldr	r3, [sp, #8]
 8027f68:	a91a      	add	r1, sp, #104	; 0x68
 8027f6a:	1c74      	adds	r4, r6, #1
 8027f6c:	eb01 0484 	add.w	r4, r1, r4, lsl #2
 8027f70:	a842      	add	r0, sp, #264	; 0x108
 8027f72:	009d      	lsls	r5, r3, #2
 8027f74:	2f00      	cmp	r7, #0
 8027f76:	f2c0 81ba 	blt.w	80282ee <__kernel_rem_pio2f+0x3ee>
 8027f7a:	eddf 7ac0 	vldr	s15, [pc, #768]	; 802827c <__kernel_rem_pio2f+0x37c>
 8027f7e:	4652      	mov	r2, sl
 8027f80:	194b      	adds	r3, r1, r5
 8027f82:	ed33 7a01 	vldmdb	r3!, {s14}
 8027f86:	ecf2 6a01 	vldmia	r2!, {s13}
 8027f8a:	4299      	cmp	r1, r3
 8027f8c:	eee6 7a87 	vfma.f32	s15, s13, s14
 8027f90:	d1f7      	bne.n	8027f82 <__kernel_rem_pio2f+0x82>
 8027f92:	3104      	adds	r1, #4
 8027f94:	42a1      	cmp	r1, r4
 8027f96:	ece0 7a01 	vstmia	r0!, {s15}
 8027f9a:	d1eb      	bne.n	8027f74 <__kernel_rem_pio2f+0x74>
 8027f9c:	9a02      	ldr	r2, [sp, #8]
 8027f9e:	eddf 8ab4 	vldr	s17, [pc, #720]	; 8028270 <__kernel_rem_pio2f+0x370>
 8027fa2:	ed9f 8ab4 	vldr	s16, [pc, #720]	; 8028274 <__kernel_rem_pio2f+0x374>
 8027fa6:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
 8027faa:	3b01      	subs	r3, #1
 8027fac:	009b      	lsls	r3, r3, #2
 8027fae:	ebc2 7982 	rsb	r9, r2, r2, lsl #30
 8027fb2:	aa06      	add	r2, sp, #24
 8027fb4:	f103 0804 	add.w	r8, r3, #4
 8027fb8:	4413      	add	r3, r2
 8027fba:	4490      	add	r8, r2
 8027fbc:	9304      	str	r3, [sp, #16]
 8027fbe:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8027fc2:	4634      	mov	r4, r6
 8027fc4:	00a5      	lsls	r5, r4, #2
 8027fc6:	ab56      	add	r3, sp, #344	; 0x158
 8027fc8:	442b      	add	r3, r5
 8027fca:	2c00      	cmp	r4, #0
 8027fcc:	ed13 0a14 	vldr	s0, [r3, #-80]	; 0xffffffb0
 8027fd0:	dd18      	ble.n	8028004 <__kernel_rem_pio2f+0x104>
 8027fd2:	a942      	add	r1, sp, #264	; 0x108
 8027fd4:	194b      	adds	r3, r1, r5
 8027fd6:	aa05      	add	r2, sp, #20
 8027fd8:	ee60 7a28 	vmul.f32	s15, s0, s17
 8027fdc:	eeb0 7a40 	vmov.f32	s14, s0
 8027fe0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8027fe4:	ed73 6a01 	vldmdb	r3!, {s13}
 8027fe8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8027fec:	428b      	cmp	r3, r1
 8027fee:	eea7 7ac8 	vfms.f32	s14, s15, s16
 8027ff2:	ee37 0aa6 	vadd.f32	s0, s15, s13
 8027ff6:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 8027ffa:	ee17 0a10 	vmov	r0, s14
 8027ffe:	f842 0f04 	str.w	r0, [r2, #4]!
 8028002:	d1e9      	bne.n	8027fd8 <__kernel_rem_pio2f+0xd8>
 8028004:	4658      	mov	r0, fp
 8028006:	f000 fb05 	bl	8028614 <scalbnf>
 802800a:	eeb0 9a40 	vmov.f32	s18, s0
 802800e:	eeb4 0a00 	vmov.f32	s0, #64	; 0x40
 8028012:	ee29 0a00 	vmul.f32	s0, s18, s0
 8028016:	f000 fab5 	bl	8028584 <floorf>
 802801a:	eef2 7a00 	vmov.f32	s15, #32
 802801e:	eea0 9a67 	vfms.f32	s18, s0, s15
 8028022:	f1bb 0f00 	cmp.w	fp, #0
 8028026:	eefd 9ac9 	vcvt.s32.f32	s19, s18
 802802a:	eef8 7ae9 	vcvt.f32.s32	s15, s19
 802802e:	ee39 9a67 	vsub.f32	s18, s18, s15
 8028032:	f340 8141 	ble.w	80282b8 <__kernel_rem_pio2f+0x3b8>
 8028036:	1e60      	subs	r0, r4, #1
 8028038:	aa06      	add	r2, sp, #24
 802803a:	f1cb 0308 	rsb	r3, fp, #8
 802803e:	f852 1020 	ldr.w	r1, [r2, r0, lsl #2]
 8028042:	fa41 f203 	asr.w	r2, r1, r3
 8028046:	fa02 f303 	lsl.w	r3, r2, r3
 802804a:	f10d 0e18 	add.w	lr, sp, #24
 802804e:	1ac9      	subs	r1, r1, r3
 8028050:	f84e 1020 	str.w	r1, [lr, r0, lsl #2]
 8028054:	ee19 0a90 	vmov	r0, s19
 8028058:	4410      	add	r0, r2
 802805a:	f1cb 0307 	rsb	r3, fp, #7
 802805e:	ee09 0a90 	vmov	s19, r0
 8028062:	4119      	asrs	r1, r3
 8028064:	2900      	cmp	r1, #0
 8028066:	dd39      	ble.n	80280dc <__kernel_rem_pio2f+0x1dc>
 8028068:	ee19 3a90 	vmov	r3, s19
 802806c:	2c00      	cmp	r4, #0
 802806e:	f103 0301 	add.w	r3, r3, #1
 8028072:	ee09 3a90 	vmov	s19, r3
 8028076:	f340 81cb 	ble.w	8028410 <__kernel_rem_pio2f+0x510>
 802807a:	2200      	movs	r2, #0
 802807c:	4610      	mov	r0, r2
 802807e:	f10d 0e14 	add.w	lr, sp, #20
 8028082:	e008      	b.n	8028096 <__kernel_rem_pio2f+0x196>
 8028084:	f5c3 7c80 	rsb	ip, r3, #256	; 0x100
 8028088:	b113      	cbz	r3, 8028090 <__kernel_rem_pio2f+0x190>
 802808a:	f8ce c000 	str.w	ip, [lr]
 802808e:	2001      	movs	r0, #1
 8028090:	3201      	adds	r2, #1
 8028092:	4294      	cmp	r4, r2
 8028094:	dd0c      	ble.n	80280b0 <__kernel_rem_pio2f+0x1b0>
 8028096:	f85e 3f04 	ldr.w	r3, [lr, #4]!
 802809a:	2800      	cmp	r0, #0
 802809c:	d0f2      	beq.n	8028084 <__kernel_rem_pio2f+0x184>
 802809e:	3201      	adds	r2, #1
 80280a0:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 80280a4:	4294      	cmp	r4, r2
 80280a6:	f8ce 3000 	str.w	r3, [lr]
 80280aa:	f04f 0001 	mov.w	r0, #1
 80280ae:	dcf2      	bgt.n	8028096 <__kernel_rem_pio2f+0x196>
 80280b0:	f1bb 0f00 	cmp.w	fp, #0
 80280b4:	dd10      	ble.n	80280d8 <__kernel_rem_pio2f+0x1d8>
 80280b6:	f1bb 0f01 	cmp.w	fp, #1
 80280ba:	f000 8104 	beq.w	80282c6 <__kernel_rem_pio2f+0x3c6>
 80280be:	f1bb 0f02 	cmp.w	fp, #2
 80280c2:	d109      	bne.n	80280d8 <__kernel_rem_pio2f+0x1d8>
 80280c4:	1e62      	subs	r2, r4, #1
 80280c6:	ab06      	add	r3, sp, #24
 80280c8:	f10d 0e18 	add.w	lr, sp, #24
 80280cc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80280d0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80280d4:	f84e 3022 	str.w	r3, [lr, r2, lsl #2]
 80280d8:	2902      	cmp	r1, #2
 80280da:	d059      	beq.n	8028190 <__kernel_rem_pio2f+0x290>
 80280dc:	eeb5 9a40 	vcmp.f32	s18, #0.0
 80280e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80280e4:	d166      	bne.n	80281b4 <__kernel_rem_pio2f+0x2b4>
 80280e6:	1e63      	subs	r3, r4, #1
 80280e8:	429e      	cmp	r6, r3
 80280ea:	dc0b      	bgt.n	8028104 <__kernel_rem_pio2f+0x204>
 80280ec:	aa06      	add	r2, sp, #24
 80280ee:	4415      	add	r5, r2
 80280f0:	2200      	movs	r2, #0
 80280f2:	f855 0d04 	ldr.w	r0, [r5, #-4]!
 80280f6:	4545      	cmp	r5, r8
 80280f8:	ea42 0200 	orr.w	r2, r2, r0
 80280fc:	d1f9      	bne.n	80280f2 <__kernel_rem_pio2f+0x1f2>
 80280fe:	2a00      	cmp	r2, #0
 8028100:	f040 8170 	bne.w	80283e4 <__kernel_rem_pio2f+0x4e4>
 8028104:	1e73      	subs	r3, r6, #1
 8028106:	aa06      	add	r2, sp, #24
 8028108:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 802810c:	2b00      	cmp	r3, #0
 802810e:	f040 817c 	bne.w	802840a <__kernel_rem_pio2f+0x50a>
 8028112:	9b04      	ldr	r3, [sp, #16]
 8028114:	f04f 0e01 	mov.w	lr, #1
 8028118:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 802811c:	f10e 0e01 	add.w	lr, lr, #1
 8028120:	2a00      	cmp	r2, #0
 8028122:	d0f9      	beq.n	8028118 <__kernel_rem_pio2f+0x218>
 8028124:	44a6      	add	lr, r4
 8028126:	1c63      	adds	r3, r4, #1
 8028128:	4573      	cmp	r3, lr
 802812a:	dc2f      	bgt.n	802818c <__kernel_rem_pio2f+0x28c>
 802812c:	9a03      	ldr	r2, [sp, #12]
 802812e:	189d      	adds	r5, r3, r2
 8028130:	9a02      	ldr	r2, [sp, #8]
 8028132:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 8028136:	18a0      	adds	r0, r4, r2
 8028138:	eb0e 0c02 	add.w	ip, lr, r2
 802813c:	9a65      	ldr	r2, [sp, #404]	; 0x194
 802813e:	3d01      	subs	r5, #1
 8028140:	eb02 0585 	add.w	r5, r2, r5, lsl #2
 8028144:	aa1a      	add	r2, sp, #104	; 0x68
 8028146:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 802814a:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
 802814e:	aa42      	add	r2, sp, #264	; 0x108
 8028150:	eb02 0483 	add.w	r4, r2, r3, lsl #2
 8028154:	f855 3f04 	ldr.w	r3, [r5, #4]!
 8028158:	ee07 3a90 	vmov	s15, r3
 802815c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8028160:	2f00      	cmp	r7, #0
 8028162:	ece0 7a01 	vstmia	r0!, {s15}
 8028166:	eddf 7a45 	vldr	s15, [pc, #276]	; 802827c <__kernel_rem_pio2f+0x37c>
 802816a:	db0b      	blt.n	8028184 <__kernel_rem_pio2f+0x284>
 802816c:	4652      	mov	r2, sl
 802816e:	eb00 0109 	add.w	r1, r0, r9
 8028172:	4603      	mov	r3, r0
 8028174:	ed33 7a01 	vldmdb	r3!, {s14}
 8028178:	ecf2 6a01 	vldmia	r2!, {s13}
 802817c:	428b      	cmp	r3, r1
 802817e:	eee6 7a87 	vfma.f32	s15, s13, s14
 8028182:	d1f7      	bne.n	8028174 <__kernel_rem_pio2f+0x274>
 8028184:	4560      	cmp	r0, ip
 8028186:	ece4 7a01 	vstmia	r4!, {s15}
 802818a:	d1e3      	bne.n	8028154 <__kernel_rem_pio2f+0x254>
 802818c:	4674      	mov	r4, lr
 802818e:	e719      	b.n	8027fc4 <__kernel_rem_pio2f+0xc4>
 8028190:	eeb7 0a00 	vmov.f32	s0, #112	; 0x70
 8028194:	ee30 9a49 	vsub.f32	s18, s0, s18
 8028198:	2800      	cmp	r0, #0
 802819a:	d09f      	beq.n	80280dc <__kernel_rem_pio2f+0x1dc>
 802819c:	4658      	mov	r0, fp
 802819e:	9105      	str	r1, [sp, #20]
 80281a0:	f000 fa38 	bl	8028614 <scalbnf>
 80281a4:	ee39 9a40 	vsub.f32	s18, s18, s0
 80281a8:	9905      	ldr	r1, [sp, #20]
 80281aa:	eeb5 9a40 	vcmp.f32	s18, #0.0
 80281ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80281b2:	d098      	beq.n	80280e6 <__kernel_rem_pio2f+0x1e6>
 80281b4:	eeb0 0a49 	vmov.f32	s0, s18
 80281b8:	f1cb 0000 	rsb	r0, fp, #0
 80281bc:	9102      	str	r1, [sp, #8]
 80281be:	f000 fa29 	bl	8028614 <scalbnf>
 80281c2:	ed9f 7a2c 	vldr	s14, [pc, #176]	; 8028274 <__kernel_rem_pio2f+0x374>
 80281c6:	9902      	ldr	r1, [sp, #8]
 80281c8:	eeb4 0ac7 	vcmpe.f32	s0, s14
 80281cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80281d0:	f2c0 817e 	blt.w	80284d0 <__kernel_rem_pio2f+0x5d0>
 80281d4:	eddf 7a26 	vldr	s15, [pc, #152]	; 8028270 <__kernel_rem_pio2f+0x370>
 80281d8:	ee60 7a27 	vmul.f32	s15, s0, s15
 80281dc:	a806      	add	r0, sp, #24
 80281de:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80281e2:	1c63      	adds	r3, r4, #1
 80281e4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80281e8:	f10b 0b08 	add.w	fp, fp, #8
 80281ec:	eea7 0ac7 	vfms.f32	s0, s15, s14
 80281f0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80281f4:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 80281f8:	ee10 2a10 	vmov	r2, s0
 80281fc:	f840 2024 	str.w	r2, [r0, r4, lsl #2]
 8028200:	ee17 2a90 	vmov	r2, s15
 8028204:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 8028208:	4658      	mov	r0, fp
 802820a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x70
 802820e:	9303      	str	r3, [sp, #12]
 8028210:	9102      	str	r1, [sp, #8]
 8028212:	f000 f9ff 	bl	8028614 <scalbnf>
 8028216:	9b03      	ldr	r3, [sp, #12]
 8028218:	9902      	ldr	r1, [sp, #8]
 802821a:	2b00      	cmp	r3, #0
 802821c:	f2c0 80c7 	blt.w	80283ae <__kernel_rem_pio2f+0x4ae>
 8028220:	f103 0e01 	add.w	lr, r3, #1
 8028224:	ea4f 028e 	mov.w	r2, lr, lsl #2
 8028228:	ac42      	add	r4, sp, #264	; 0x108
 802822a:	a806      	add	r0, sp, #24
 802822c:	ed9f 7a10 	vldr	s14, [pc, #64]	; 8028270 <__kernel_rem_pio2f+0x370>
 8028230:	4410      	add	r0, r2
 8028232:	18a7      	adds	r7, r4, r2
 8028234:	ed70 7a01 	vldmdb	r0!, {s15}
 8028238:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802823c:	ee67 7a80 	vmul.f32	s15, s15, s0
 8028240:	ee20 0a07 	vmul.f32	s0, s0, s14
 8028244:	ed67 7a01 	vstmdb	r7!, {s15}
 8028248:	42a7      	cmp	r7, r4
 802824a:	d1f3      	bne.n	8028234 <__kernel_rem_pio2f+0x334>
 802824c:	3a04      	subs	r2, #4
 802824e:	4417      	add	r7, r2
 8028250:	2500      	movs	r5, #0
 8028252:	2e00      	cmp	r6, #0
 8028254:	f2c0 80a8 	blt.w	80283a8 <__kernel_rem_pio2f+0x4a8>
 8028258:	2d00      	cmp	r5, #0
 802825a:	f2c0 80a5 	blt.w	80283a8 <__kernel_rem_pio2f+0x4a8>
 802825e:	4c06      	ldr	r4, [pc, #24]	; (8028278 <__kernel_rem_pio2f+0x378>)
 8028260:	eddf 7a06 	vldr	s15, [pc, #24]	; 802827c <__kernel_rem_pio2f+0x37c>
 8028264:	4638      	mov	r0, r7
 8028266:	2200      	movs	r2, #0
 8028268:	e00c      	b.n	8028284 <__kernel_rem_pio2f+0x384>
 802826a:	bf00      	nop
 802826c:	0802be30 	.word	0x0802be30
 8028270:	3b800000 	.word	0x3b800000
 8028274:	43800000 	.word	0x43800000
 8028278:	0802be3c 	.word	0x0802be3c
 802827c:	00000000 	.word	0x00000000
 8028280:	42aa      	cmp	r2, r5
 8028282:	dc08      	bgt.n	8028296 <__kernel_rem_pio2f+0x396>
 8028284:	ecf4 6a01 	vldmia	r4!, {s13}
 8028288:	ecb0 7a01 	vldmia	r0!, {s14}
 802828c:	3201      	adds	r2, #1
 802828e:	4296      	cmp	r6, r2
 8028290:	eee6 7a87 	vfma.f32	s15, s13, s14
 8028294:	daf4      	bge.n	8028280 <__kernel_rem_pio2f+0x380>
 8028296:	aa56      	add	r2, sp, #344	; 0x158
 8028298:	eb02 0285 	add.w	r2, r2, r5, lsl #2
 802829c:	3501      	adds	r5, #1
 802829e:	4575      	cmp	r5, lr
 80282a0:	f1a7 0704 	sub.w	r7, r7, #4
 80282a4:	ed42 7a28 	vstr	s15, [r2, #-160]	; 0xffffff60
 80282a8:	d1d3      	bne.n	8028252 <__kernel_rem_pio2f+0x352>
 80282aa:	9a64      	ldr	r2, [sp, #400]	; 0x190
 80282ac:	2a03      	cmp	r2, #3
 80282ae:	d85f      	bhi.n	8028370 <__kernel_rem_pio2f+0x470>
 80282b0:	e8df f002 	tbb	[pc, r2]
 80282b4:	b0373767 	.word	0xb0373767
 80282b8:	d110      	bne.n	80282dc <__kernel_rem_pio2f+0x3dc>
 80282ba:	1e63      	subs	r3, r4, #1
 80282bc:	aa06      	add	r2, sp, #24
 80282be:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 80282c2:	1209      	asrs	r1, r1, #8
 80282c4:	e6ce      	b.n	8028064 <__kernel_rem_pio2f+0x164>
 80282c6:	1e62      	subs	r2, r4, #1
 80282c8:	ab06      	add	r3, sp, #24
 80282ca:	f10d 0e18 	add.w	lr, sp, #24
 80282ce:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80282d2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80282d6:	f84e 3022 	str.w	r3, [lr, r2, lsl #2]
 80282da:	e6fd      	b.n	80280d8 <__kernel_rem_pio2f+0x1d8>
 80282dc:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 80282e0:	eeb4 9ae7 	vcmpe.f32	s18, s15
 80282e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80282e8:	da0a      	bge.n	8028300 <__kernel_rem_pio2f+0x400>
 80282ea:	2100      	movs	r1, #0
 80282ec:	e6f6      	b.n	80280dc <__kernel_rem_pio2f+0x1dc>
 80282ee:	ed5f 7a1d 	vldr	s15, [pc, #-116]	; 802827c <__kernel_rem_pio2f+0x37c>
 80282f2:	3104      	adds	r1, #4
 80282f4:	42a1      	cmp	r1, r4
 80282f6:	ece0 7a01 	vstmia	r0!, {s15}
 80282fa:	f47f ae3b 	bne.w	8027f74 <__kernel_rem_pio2f+0x74>
 80282fe:	e64d      	b.n	8027f9c <__kernel_rem_pio2f+0x9c>
 8028300:	ee19 3a90 	vmov	r3, s19
 8028304:	2c00      	cmp	r4, #0
 8028306:	f103 0301 	add.w	r3, r3, #1
 802830a:	ee09 3a90 	vmov	s19, r3
 802830e:	bfc8      	it	gt
 8028310:	2102      	movgt	r1, #2
 8028312:	f73f aeb2 	bgt.w	802807a <__kernel_rem_pio2f+0x17a>
 8028316:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 802831a:	ee37 9ac9 	vsub.f32	s18, s15, s18
 802831e:	2102      	movs	r1, #2
 8028320:	e6dc      	b.n	80280dc <__kernel_rem_pio2f+0x1dc>
 8028322:	aa2e      	add	r2, sp, #184	; 0xb8
 8028324:	ed5f 7a2b 	vldr	s15, [pc, #-172]	; 802827c <__kernel_rem_pio2f+0x37c>
 8028328:	eb02 0e8e 	add.w	lr, r2, lr, lsl #2
 802832c:	ed3e 7a01 	vldmdb	lr!, {s14}
 8028330:	4596      	cmp	lr, r2
 8028332:	ee77 7a87 	vadd.f32	s15, s15, s14
 8028336:	d1f9      	bne.n	802832c <__kernel_rem_pio2f+0x42c>
 8028338:	2900      	cmp	r1, #0
 802833a:	d043      	beq.n	80283c4 <__kernel_rem_pio2f+0x4c4>
 802833c:	eddd 6a2e 	vldr	s13, [sp, #184]	; 0xb8
 8028340:	9a01      	ldr	r2, [sp, #4]
 8028342:	eeb1 7a67 	vneg.f32	s14, s15
 8028346:	2b00      	cmp	r3, #0
 8028348:	ee76 7ae7 	vsub.f32	s15, s13, s15
 802834c:	ed82 7a00 	vstr	s14, [r2]
 8028350:	dd09      	ble.n	8028366 <__kernel_rem_pio2f+0x466>
 8028352:	a82f      	add	r0, sp, #188	; 0xbc
 8028354:	2201      	movs	r2, #1
 8028356:	ecb0 7a01 	vldmia	r0!, {s14}
 802835a:	3201      	adds	r2, #1
 802835c:	4293      	cmp	r3, r2
 802835e:	ee77 7a87 	vadd.f32	s15, s15, s14
 8028362:	daf8      	bge.n	8028356 <__kernel_rem_pio2f+0x456>
 8028364:	b109      	cbz	r1, 802836a <__kernel_rem_pio2f+0x46a>
 8028366:	eef1 7a67 	vneg.f32	s15, s15
 802836a:	9b01      	ldr	r3, [sp, #4]
 802836c:	edc3 7a01 	vstr	s15, [r3, #4]
 8028370:	ee19 3a90 	vmov	r3, s19
 8028374:	f003 0007 	and.w	r0, r3, #7
 8028378:	b057      	add	sp, #348	; 0x15c
 802837a:	ecbd 8b04 	vpop	{d8-d9}
 802837e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8028382:	aa2e      	add	r2, sp, #184	; 0xb8
 8028384:	ed5f 7a43 	vldr	s15, [pc, #-268]	; 802827c <__kernel_rem_pio2f+0x37c>
 8028388:	eb02 0e8e 	add.w	lr, r2, lr, lsl #2
 802838c:	ed3e 7a01 	vldmdb	lr!, {s14}
 8028390:	3b01      	subs	r3, #1
 8028392:	1c5a      	adds	r2, r3, #1
 8028394:	ee77 7a87 	vadd.f32	s15, s15, s14
 8028398:	d1f8      	bne.n	802838c <__kernel_rem_pio2f+0x48c>
 802839a:	b109      	cbz	r1, 80283a0 <__kernel_rem_pio2f+0x4a0>
 802839c:	eef1 7a67 	vneg.f32	s15, s15
 80283a0:	9b01      	ldr	r3, [sp, #4]
 80283a2:	edc3 7a00 	vstr	s15, [r3]
 80283a6:	e7e3      	b.n	8028370 <__kernel_rem_pio2f+0x470>
 80283a8:	ed5f 7a4c 	vldr	s15, [pc, #-304]	; 802827c <__kernel_rem_pio2f+0x37c>
 80283ac:	e773      	b.n	8028296 <__kernel_rem_pio2f+0x396>
 80283ae:	9a64      	ldr	r2, [sp, #400]	; 0x190
 80283b0:	2a03      	cmp	r2, #3
 80283b2:	d8dd      	bhi.n	8028370 <__kernel_rem_pio2f+0x470>
 80283b4:	e8df f002 	tbb	[pc, r2]
 80283b8:	80020213 	.word	0x80020213
 80283bc:	ed5f 7a51 	vldr	s15, [pc, #-324]	; 802827c <__kernel_rem_pio2f+0x37c>
 80283c0:	2900      	cmp	r1, #0
 80283c2:	d1bb      	bne.n	802833c <__kernel_rem_pio2f+0x43c>
 80283c4:	ed9d 7a2e 	vldr	s14, [sp, #184]	; 0xb8
 80283c8:	9a01      	ldr	r2, [sp, #4]
 80283ca:	2b00      	cmp	r3, #0
 80283cc:	edc2 7a00 	vstr	s15, [r2]
 80283d0:	ee77 7a67 	vsub.f32	s15, s14, s15
 80283d4:	dcbd      	bgt.n	8028352 <__kernel_rem_pio2f+0x452>
 80283d6:	9b01      	ldr	r3, [sp, #4]
 80283d8:	edc3 7a01 	vstr	s15, [r3, #4]
 80283dc:	e7c8      	b.n	8028370 <__kernel_rem_pio2f+0x470>
 80283de:	ed5f 7a59 	vldr	s15, [pc, #-356]	; 802827c <__kernel_rem_pio2f+0x37c>
 80283e2:	e7da      	b.n	802839a <__kernel_rem_pio2f+0x49a>
 80283e4:	aa06      	add	r2, sp, #24
 80283e6:	f1ab 0b08 	sub.w	fp, fp, #8
 80283ea:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80283ee:	2a00      	cmp	r2, #0
 80283f0:	f47f af0a 	bne.w	8028208 <__kernel_rem_pio2f+0x308>
 80283f4:	aa06      	add	r2, sp, #24
 80283f6:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 80283fa:	f852 0d04 	ldr.w	r0, [r2, #-4]!
 80283fe:	3b01      	subs	r3, #1
 8028400:	f1ab 0b08 	sub.w	fp, fp, #8
 8028404:	2800      	cmp	r0, #0
 8028406:	d0f8      	beq.n	80283fa <__kernel_rem_pio2f+0x4fa>
 8028408:	e6fe      	b.n	8028208 <__kernel_rem_pio2f+0x308>
 802840a:	f04f 0e01 	mov.w	lr, #1
 802840e:	e689      	b.n	8028124 <__kernel_rem_pio2f+0x224>
 8028410:	2000      	movs	r0, #0
 8028412:	e64d      	b.n	80280b0 <__kernel_rem_pio2f+0x1b0>
 8028414:	2b00      	cmp	r3, #0
 8028416:	dd4f      	ble.n	80284b8 <__kernel_rem_pio2f+0x5b8>
 8028418:	009a      	lsls	r2, r3, #2
 802841a:	a856      	add	r0, sp, #344	; 0x158
 802841c:	4410      	add	r0, r2
 802841e:	ad2e      	add	r5, sp, #184	; 0xb8
 8028420:	1d14      	adds	r4, r2, #4
 8028422:	ed10 7a28 	vldr	s14, [r0, #-160]	; 0xffffff60
 8028426:	442c      	add	r4, r5
 8028428:	18a8      	adds	r0, r5, r2
 802842a:	ed70 7a01 	vldmdb	r0!, {s15}
 802842e:	ee77 6a27 	vadd.f32	s13, s14, s15
 8028432:	42a8      	cmp	r0, r5
 8028434:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8028438:	ee77 7a27 	vadd.f32	s15, s14, s15
 802843c:	eeb0 7a66 	vmov.f32	s14, s13
 8028440:	ed64 7a01 	vstmdb	r4!, {s15}
 8028444:	edc0 6a00 	vstr	s13, [r0]
 8028448:	d1ef      	bne.n	802842a <__kernel_rem_pio2f+0x52a>
 802844a:	2b01      	cmp	r3, #1
 802844c:	dd34      	ble.n	80284b8 <__kernel_rem_pio2f+0x5b8>
 802844e:	1d13      	adds	r3, r2, #4
 8028450:	ac56      	add	r4, sp, #344	; 0x158
 8028452:	4414      	add	r4, r2
 8028454:	4403      	add	r3, r0
 8028456:	ed14 7a28 	vldr	s14, [r4, #-160]	; 0xffffff60
 802845a:	4402      	add	r2, r0
 802845c:	ac2f      	add	r4, sp, #188	; 0xbc
 802845e:	4618      	mov	r0, r3
 8028460:	ed72 7a01 	vldmdb	r2!, {s15}
 8028464:	ee77 6a87 	vadd.f32	s13, s15, s14
 8028468:	42a2      	cmp	r2, r4
 802846a:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802846e:	ee77 7a87 	vadd.f32	s15, s15, s14
 8028472:	eeb0 7a66 	vmov.f32	s14, s13
 8028476:	ed60 7a01 	vstmdb	r0!, {s15}
 802847a:	edc2 6a00 	vstr	s13, [r2]
 802847e:	d1ef      	bne.n	8028460 <__kernel_rem_pio2f+0x560>
 8028480:	ed5f 7a82 	vldr	s15, [pc, #-520]	; 802827c <__kernel_rem_pio2f+0x37c>
 8028484:	aa30      	add	r2, sp, #192	; 0xc0
 8028486:	ed33 7a01 	vldmdb	r3!, {s14}
 802848a:	4293      	cmp	r3, r2
 802848c:	ee77 7a87 	vadd.f32	s15, s15, s14
 8028490:	d1f9      	bne.n	8028486 <__kernel_rem_pio2f+0x586>
 8028492:	b1a9      	cbz	r1, 80284c0 <__kernel_rem_pio2f+0x5c0>
 8028494:	eddd 6a2e 	vldr	s13, [sp, #184]	; 0xb8
 8028498:	ed9d 7a2f 	vldr	s14, [sp, #188]	; 0xbc
 802849c:	9a01      	ldr	r2, [sp, #4]
 802849e:	eef1 7a67 	vneg.f32	s15, s15
 80284a2:	eef1 6a66 	vneg.f32	s13, s13
 80284a6:	eeb1 7a47 	vneg.f32	s14, s14
 80284aa:	edc2 7a02 	vstr	s15, [r2, #8]
 80284ae:	edc2 6a00 	vstr	s13, [r2]
 80284b2:	ed82 7a01 	vstr	s14, [r2, #4]
 80284b6:	e75b      	b.n	8028370 <__kernel_rem_pio2f+0x470>
 80284b8:	ed5f 7a90 	vldr	s15, [pc, #-576]	; 802827c <__kernel_rem_pio2f+0x37c>
 80284bc:	2900      	cmp	r1, #0
 80284be:	d1e9      	bne.n	8028494 <__kernel_rem_pio2f+0x594>
 80284c0:	9801      	ldr	r0, [sp, #4]
 80284c2:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 80284c4:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 80284c6:	edc0 7a02 	vstr	s15, [r0, #8]
 80284ca:	6002      	str	r2, [r0, #0]
 80284cc:	6043      	str	r3, [r0, #4]
 80284ce:	e74f      	b.n	8028370 <__kernel_rem_pio2f+0x470>
 80284d0:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 80284d4:	a806      	add	r0, sp, #24
 80284d6:	ee10 2a10 	vmov	r2, s0
 80284da:	4623      	mov	r3, r4
 80284dc:	f840 2024 	str.w	r2, [r0, r4, lsl #2]
 80284e0:	e692      	b.n	8028208 <__kernel_rem_pio2f+0x308>
 80284e2:	bf00      	nop

080284e4 <__kernel_sinf>:
 80284e4:	ee10 3a10 	vmov	r3, s0
 80284e8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80284ec:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 80284f0:	da04      	bge.n	80284fc <__kernel_sinf+0x18>
 80284f2:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 80284f6:	ee17 3a90 	vmov	r3, s15
 80284fa:	b323      	cbz	r3, 8028546 <__kernel_sinf+0x62>
 80284fc:	ee60 7a00 	vmul.f32	s15, s0, s0
 8028500:	ed9f 5a15 	vldr	s10, [pc, #84]	; 8028558 <__kernel_sinf+0x74>
 8028504:	eddf 5a15 	vldr	s11, [pc, #84]	; 802855c <__kernel_sinf+0x78>
 8028508:	ed9f 6a15 	vldr	s12, [pc, #84]	; 8028560 <__kernel_sinf+0x7c>
 802850c:	eddf 6a15 	vldr	s13, [pc, #84]	; 8028564 <__kernel_sinf+0x80>
 8028510:	ed9f 7a15 	vldr	s14, [pc, #84]	; 8028568 <__kernel_sinf+0x84>
 8028514:	eee7 5a85 	vfma.f32	s11, s15, s10
 8028518:	ee27 5a80 	vmul.f32	s10, s15, s0
 802851c:	eea5 6aa7 	vfma.f32	s12, s11, s15
 8028520:	eee6 6a27 	vfma.f32	s13, s12, s15
 8028524:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8028528:	b170      	cbz	r0, 8028548 <__kernel_sinf+0x64>
 802852a:	ee27 7a45 	vnmul.f32	s14, s14, s10
 802852e:	eef6 6a00 	vmov.f32	s13, #96	; 0x60
 8028532:	eea0 7aa6 	vfma.f32	s14, s1, s13
 8028536:	eddf 6a0d 	vldr	s13, [pc, #52]	; 802856c <__kernel_sinf+0x88>
 802853a:	eed7 0a27 	vfnms.f32	s1, s14, s15
 802853e:	eee5 0a26 	vfma.f32	s1, s10, s13
 8028542:	ee30 0a60 	vsub.f32	s0, s0, s1
 8028546:	4770      	bx	lr
 8028548:	eddf 6a09 	vldr	s13, [pc, #36]	; 8028570 <__kernel_sinf+0x8c>
 802854c:	eee7 6a87 	vfma.f32	s13, s15, s14
 8028550:	eea6 0a85 	vfma.f32	s0, s13, s10
 8028554:	4770      	bx	lr
 8028556:	bf00      	nop
 8028558:	2f2ec9d3 	.word	0x2f2ec9d3
 802855c:	b2d72f34 	.word	0xb2d72f34
 8028560:	3638ef1b 	.word	0x3638ef1b
 8028564:	b9500d01 	.word	0xb9500d01
 8028568:	3c088889 	.word	0x3c088889
 802856c:	3e2aaaab 	.word	0x3e2aaaab
 8028570:	be2aaaab 	.word	0xbe2aaaab

08028574 <fabsf>:
 8028574:	ee10 3a10 	vmov	r3, s0
 8028578:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802857c:	ee00 3a10 	vmov	s0, r3
 8028580:	4770      	bx	lr
 8028582:	bf00      	nop

08028584 <floorf>:
 8028584:	ee10 2a10 	vmov	r2, s0
 8028588:	f022 4100 	bic.w	r1, r2, #2147483648	; 0x80000000
 802858c:	0dcb      	lsrs	r3, r1, #23
 802858e:	3b7f      	subs	r3, #127	; 0x7f
 8028590:	2b16      	cmp	r3, #22
 8028592:	dc17      	bgt.n	80285c4 <floorf+0x40>
 8028594:	2b00      	cmp	r3, #0
 8028596:	ee10 0a10 	vmov	r0, s0
 802859a:	db19      	blt.n	80285d0 <floorf+0x4c>
 802859c:	491a      	ldr	r1, [pc, #104]	; (8028608 <floorf+0x84>)
 802859e:	4119      	asrs	r1, r3
 80285a0:	4211      	tst	r1, r2
 80285a2:	d022      	beq.n	80285ea <floorf+0x66>
 80285a4:	eddf 7a19 	vldr	s15, [pc, #100]	; 802860c <floorf+0x88>
 80285a8:	ee70 7a27 	vadd.f32	s15, s0, s15
 80285ac:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80285b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80285b4:	dd19      	ble.n	80285ea <floorf+0x66>
 80285b6:	2a00      	cmp	r2, #0
 80285b8:	db18      	blt.n	80285ec <floorf+0x68>
 80285ba:	ea20 0301 	bic.w	r3, r0, r1
 80285be:	ee00 3a10 	vmov	s0, r3
 80285c2:	4770      	bx	lr
 80285c4:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 80285c8:	d30f      	bcc.n	80285ea <floorf+0x66>
 80285ca:	ee30 0a00 	vadd.f32	s0, s0, s0
 80285ce:	4770      	bx	lr
 80285d0:	eddf 7a0e 	vldr	s15, [pc, #56]	; 802860c <floorf+0x88>
 80285d4:	ee70 7a27 	vadd.f32	s15, s0, s15
 80285d8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80285dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80285e0:	dd03      	ble.n	80285ea <floorf+0x66>
 80285e2:	2a00      	cmp	r2, #0
 80285e4:	db08      	blt.n	80285f8 <floorf+0x74>
 80285e6:	ed9f 0a0a 	vldr	s0, [pc, #40]	; 8028610 <floorf+0x8c>
 80285ea:	4770      	bx	lr
 80285ec:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 80285f0:	fa42 f303 	asr.w	r3, r2, r3
 80285f4:	4418      	add	r0, r3
 80285f6:	e7e0      	b.n	80285ba <floorf+0x36>
 80285f8:	2900      	cmp	r1, #0
 80285fa:	eeff 7a00 	vmov.f32	s15, #240	; 0xf0
 80285fe:	bf18      	it	ne
 8028600:	eeb0 0a67 	vmovne.f32	s0, s15
 8028604:	4770      	bx	lr
 8028606:	bf00      	nop
 8028608:	007fffff 	.word	0x007fffff
 802860c:	7149f2ca 	.word	0x7149f2ca
 8028610:	00000000 	.word	0x00000000

08028614 <scalbnf>:
 8028614:	b508      	push	{r3, lr}
 8028616:	ee10 3a10 	vmov	r3, s0
 802861a:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
 802861e:	ed2d 8b02 	vpush	{d8}
 8028622:	d011      	beq.n	8028648 <scalbnf+0x34>
 8028624:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8028628:	d211      	bcs.n	802864e <scalbnf+0x3a>
 802862a:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 802862e:	d313      	bcc.n	8028658 <scalbnf+0x44>
 8028630:	0dd2      	lsrs	r2, r2, #23
 8028632:	4402      	add	r2, r0
 8028634:	2afe      	cmp	r2, #254	; 0xfe
 8028636:	dc2e      	bgt.n	8028696 <scalbnf+0x82>
 8028638:	2a00      	cmp	r2, #0
 802863a:	dd1a      	ble.n	8028672 <scalbnf+0x5e>
 802863c:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 8028640:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 8028644:	ee00 3a10 	vmov	s0, r3
 8028648:	ecbd 8b02 	vpop	{d8}
 802864c:	bd08      	pop	{r3, pc}
 802864e:	ecbd 8b02 	vpop	{d8}
 8028652:	ee30 0a00 	vadd.f32	s0, s0, s0
 8028656:	bd08      	pop	{r3, pc}
 8028658:	4b1d      	ldr	r3, [pc, #116]	; (80286d0 <scalbnf+0xbc>)
 802865a:	eddf 7a1e 	vldr	s15, [pc, #120]	; 80286d4 <scalbnf+0xc0>
 802865e:	4298      	cmp	r0, r3
 8028660:	ee20 0a27 	vmul.f32	s0, s0, s15
 8028664:	db22      	blt.n	80286ac <scalbnf+0x98>
 8028666:	ee10 3a10 	vmov	r3, s0
 802866a:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 802866e:	3a19      	subs	r2, #25
 8028670:	e7df      	b.n	8028632 <scalbnf+0x1e>
 8028672:	f112 0f16 	cmn.w	r2, #22
 8028676:	da1e      	bge.n	80286b6 <scalbnf+0xa2>
 8028678:	f24c 3350 	movw	r3, #50000	; 0xc350
 802867c:	4298      	cmp	r0, r3
 802867e:	dc0a      	bgt.n	8028696 <scalbnf+0x82>
 8028680:	ed9f 8a15 	vldr	s16, [pc, #84]	; 80286d8 <scalbnf+0xc4>
 8028684:	eef0 0a40 	vmov.f32	s1, s0
 8028688:	eeb0 0a48 	vmov.f32	s0, s16
 802868c:	f000 f82a 	bl	80286e4 <copysignf>
 8028690:	ee20 0a08 	vmul.f32	s0, s0, s16
 8028694:	e7d8      	b.n	8028648 <scalbnf+0x34>
 8028696:	ed9f 8a11 	vldr	s16, [pc, #68]	; 80286dc <scalbnf+0xc8>
 802869a:	eef0 0a40 	vmov.f32	s1, s0
 802869e:	eeb0 0a48 	vmov.f32	s0, s16
 80286a2:	f000 f81f 	bl	80286e4 <copysignf>
 80286a6:	ee20 0a08 	vmul.f32	s0, s0, s16
 80286aa:	e7cd      	b.n	8028648 <scalbnf+0x34>
 80286ac:	eddf 0a0a 	vldr	s1, [pc, #40]	; 80286d8 <scalbnf+0xc4>
 80286b0:	ee20 0a20 	vmul.f32	s0, s0, s1
 80286b4:	e7c8      	b.n	8028648 <scalbnf+0x34>
 80286b6:	3219      	adds	r2, #25
 80286b8:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 80286bc:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 80286c0:	eddf 7a07 	vldr	s15, [pc, #28]	; 80286e0 <scalbnf+0xcc>
 80286c4:	ee00 3a10 	vmov	s0, r3
 80286c8:	ee20 0a27 	vmul.f32	s0, s0, s15
 80286cc:	e7bc      	b.n	8028648 <scalbnf+0x34>
 80286ce:	bf00      	nop
 80286d0:	ffff3cb0 	.word	0xffff3cb0
 80286d4:	4c000000 	.word	0x4c000000
 80286d8:	0da24260 	.word	0x0da24260
 80286dc:	7149f2ca 	.word	0x7149f2ca
 80286e0:	33000000 	.word	0x33000000

080286e4 <copysignf>:
 80286e4:	ee10 3a10 	vmov	r3, s0
 80286e8:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 80286ec:	ee10 3a90 	vmov	r3, s1
 80286f0:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 80286f4:	4313      	orrs	r3, r2
 80286f6:	ee00 3a10 	vmov	s0, r3
 80286fa:	4770      	bx	lr
 80286fc:	00007874 	.word	0x00007874
 8028700:	0a0d7325 	.word	0x0a0d7325
 8028704:	00000000 	.word	0x00000000
 8028708:	00007872 	.word	0x00007872
 802870c:	65636572 	.word	0x65636572
 8028710:	20657669 	.word	0x20657669
 8028714:	20737472 	.word	0x20737472
 8028718:	6b636170 	.word	0x6b636170
 802871c:	20737465 	.word	0x20737465
 8028720:	6425203d 	.word	0x6425203d
 8028724:	00000a0d 	.word	0x00000a0d
 8028728:	6d61620a 	.word	0x6d61620a
 802872c:	63657220 	.word	0x63657220
 8028730:	65766965 	.word	0x65766965
 8028734:	20642520 	.word	0x20642520
 8028738:	61746164 	.word	0x61746164
 802873c:	000a0d3a 	.word	0x000a0d3a
 8028740:	61746144 	.word	0x61746144
 8028744:	205d305b 	.word	0x205d305b
 8028748:	6425203d 	.word	0x6425203d
 802874c:	6372202c 	.word	0x6372202c
 8028750:	63617076 	.word	0x63617076
 8028754:	7374656b 	.word	0x7374656b
 8028758:	25203d20 	.word	0x25203d20
 802875c:	000a0d64 	.word	0x000a0d64
 8028760:	2054440a 	.word	0x2054440a
 8028764:	65636572 	.word	0x65636572
 8028768:	20657669 	.word	0x20657669
 802876c:	64206425 	.word	0x64206425
 8028770:	3a617461 	.word	0x3a617461
 8028774:	00000a0d 	.word	0x00000a0d
 8028778:	65636572 	.word	0x65636572
 802877c:	20657669 	.word	0x20657669
 8028780:	4f646e65 	.word	0x4f646e65
 8028784:	67734d66 	.word	0x67734d66
 8028788:	0d6b6341 	.word	0x0d6b6341
 802878c:	0000000a 	.word	0x0000000a
 8028790:	65636572 	.word	0x65636572
 8028794:	20657669 	.word	0x20657669
 8028798:	0d6d6162 	.word	0x0d6d6162
 802879c:	0000000a 	.word	0x0000000a
 80287a0:	3339314a 	.word	0x3339314a
 80287a4:	6d697439 	.word	0x6d697439
 80287a8:	00007265 	.word	0x00007265
 80287ac:	316e6163 	.word	0x316e6163
 80287b0:	00000000 	.word	0x00000000
 80287b4:	20677765 	.word	0x20677765
 80287b8:	6f727265 	.word	0x6f727265
 80287bc:	000a0d72 	.word	0x000a0d72
 80287c0:	20767065 	.word	0x20767065
 80287c4:	6f727265 	.word	0x6f727265
 80287c8:	000a0d72 	.word	0x000a0d72
 80287cc:	20666f62 	.word	0x20666f62
 80287d0:	6f727265 	.word	0x6f727265
 80287d4:	000a0d72 	.word	0x000a0d72
 80287d8:	20667473 	.word	0x20667473
 80287dc:	6f727265 	.word	0x6f727265
 80287e0:	000a0d72 	.word	0x000a0d72
 80287e4:	20726f66 	.word	0x20726f66
 80287e8:	6f727265 	.word	0x6f727265
 80287ec:	000a0d72 	.word	0x000a0d72
 80287f0:	206b6361 	.word	0x206b6361
 80287f4:	6f727265 	.word	0x6f727265
 80287f8:	000a0d72 	.word	0x000a0d72
 80287fc:	65207262 	.word	0x65207262
 8028800:	726f7272 	.word	0x726f7272
 8028804:	00000a0d 	.word	0x00000a0d
 8028808:	65206462 	.word	0x65206462
 802880c:	726f7272 	.word	0x726f7272
 8028810:	00000a0d 	.word	0x00000a0d
 8028814:	20637263 	.word	0x20637263
 8028818:	6f727265 	.word	0x6f727265
 802881c:	000a0d72 	.word	0x000a0d72
 8028820:	204e4143 	.word	0x204e4143
 8028824:	66207874 	.word	0x66207874
 8028828:	216c6961 	.word	0x216c6961
 802882c:	0d782520 	.word	0x0d782520
 8028830:	0000000a 	.word	0x0000000a
 8028834:	65636572 	.word	0x65636572
 8028838:	20657669 	.word	0x20657669
 802883c:	0d6e6163 	.word	0x0d6e6163
 8028840:	0000000a 	.word	0x0000000a
 8028844:	665f7872 	.word	0x665f7872
 8028848:	206f6669 	.word	0x206f6669
 802884c:	52203d21 	.word	0x52203d21
 8028850:	554e5f54 	.word	0x554e5f54
 8028854:	00004c4c 	.word	0x00004c4c
 8028858:	665f7872 	.word	0x665f7872
 802885c:	2d6f6669 	.word	0x2d6f6669
 8028860:	6572663e 	.word	0x6572663e
 8028864:	6d756e65 	.word	0x6d756e65
 8028868:	73726562 	.word	0x73726562
 802886c:	30203e20 	.word	0x30203e20
 8028870:	00000000 	.word	0x00000000
 8028874:	6f727265 	.word	0x6f727265
 8028878:	65642072 	.word	0x65642072
 802887c:	74696e69 	.word	0x74696e69
 8028880:	6e616320 	.word	0x6e616320
 8028884:	00000a0d 	.word	0x00000a0d
 8028888:	6f727265 	.word	0x6f727265
 802888c:	6e692072 	.word	0x6e692072
 8028890:	63207469 	.word	0x63207469
 8028894:	0a0d6e61 	.word	0x0a0d6e61
 8028898:	00000000 	.word	0x00000000
 802889c:	6c6c616d 	.word	0x6c6c616d
 80288a0:	6620636f 	.word	0x6620636f
 80288a4:	0d6c6961 	.word	0x0d6c6961
 80288a8:	0000000a 	.word	0x0000000a
 80288ac:	656d6974 	.word	0x656d6974
 80288b0:	6e614372 	.word	0x6e614372
 80288b4:	00007872 	.word	0x00007872
 80288b8:	316e6163 	.word	0x316e6163
 80288bc:	00000000 	.word	0x00000000
 80288c0:	000000fa 	.word	0x000000fa
 80288c4:	00000040 	.word	0x00000040
	...
 80288d0:	0000000a 	.word	0x0000000a
 80288d4:	74726175 	.word	0x74726175
 80288d8:	00000031 	.word	0x00000031
 80288dc:	45524220 	.word	0x45524220
 80288e0:	20314b41 	.word	0x20314b41
 80288e4:	74207369 	.word	0x74207369
 80288e8:	67676972 	.word	0x67676972
 80288ec:	64657265 	.word	0x64657265
 80288f0:	00000a0d 	.word	0x00000a0d
 80288f4:	45524220 	.word	0x45524220
 80288f8:	20324b41 	.word	0x20324b41
 80288fc:	74207369 	.word	0x74207369
 8028900:	67676972 	.word	0x67676972
 8028904:	64657265 	.word	0x64657265
 8028908:	00000a0d 	.word	0x00000a0d
 802890c:	384d4954 	.word	0x384d4954
 8028910:	20736920 	.word	0x20736920
 8028914:	67697274 	.word	0x67697274
 8028918:	65726567 	.word	0x65726567
 802891c:	000a0d64 	.word	0x000a0d64
 8028920:	69726573 	.word	0x69726573
 8028924:	21206c61 	.word	0x21206c61
 8028928:	5452203d 	.word	0x5452203d
 802892c:	4c554e5f 	.word	0x4c554e5f
 8028930:	0000004c 	.word	0x0000004c
 8028934:	20676663 	.word	0x20676663
 8028938:	52203d21 	.word	0x52203d21
 802893c:	554e5f54 	.word	0x554e5f54
 8028940:	00004c4c 	.word	0x00004c4c
 8028944:	74206e69 	.word	0x74206e69
 8028948:	63206568 	.word	0x63206568
 802894c:	72746e6f 	.word	0x72746e6f
 8028950:	0a0d6c6f 	.word	0x0a0d6c6f
 8028954:	00000000 	.word	0x00000000
 8028958:	74726175 	.word	0x74726175
 802895c:	00000031 	.word	0x00000031
 8028960:	74726175 	.word	0x74726175
 8028964:	00000033 	.word	0x00000033
 8028968:	0001c200 	.word	0x0001c200
 802896c:	00010008 	.word	0x00010008
 8028970:	00038400 	.word	0x00038400
 8028974:	00010008 	.word	0x00010008
 8028978:	655f6372 	.word	0x655f6372
 802897c:	726f7272 	.word	0x726f7272
 8028980:	00000a0d 	.word	0x00000a0d
 8028984:	3339314a 	.word	0x3339314a
 8028988:	64787439 	.word	0x64787439
 802898c:	00000000 	.word	0x00000000
 8028990:	316e6163 	.word	0x316e6163
 8028994:	00000000 	.word	0x00000000
 8028998:	6e65706f 	.word	0x6e65706f
 802899c:	72726520 	.word	0x72726520
 80289a0:	0a0d726f 	.word	0x0a0d726f
 80289a4:	00000000 	.word	0x00000000
 80289a8:	206c6176 	.word	0x206c6176
 80289ac:	6c6c756e 	.word	0x6c6c756e
 80289b0:	00000a0d 	.word	0x00000a0d
 80289b4:	3a706420 	.word	0x3a706420
 80289b8:	0d782520 	.word	0x0d782520
 80289bc:	0000000a 	.word	0x0000000a
 80289c0:	203a6670 	.word	0x203a6670
 80289c4:	0d207825 	.word	0x0d207825
 80289c8:	0000000a 	.word	0x0000000a
 80289cc:	203a7370 	.word	0x203a7370
 80289d0:	0d207825 	.word	0x0d207825
 80289d4:	0000000a 	.word	0x0000000a
 80289d8:	20766372 	.word	0x20766372
 80289dc:	61746164 	.word	0x61746164
 80289e0:	0000203a 	.word	0x0000203a
 80289e4:	00207825 	.word	0x00207825
 80289e8:	00000a0d 	.word	0x00000a0d
 80289ec:	08a00047 	.word	0x08a00047
 80289f0:	352e46aa 	.word	0x352e46aa
 80289f4:	006e6143 	.word	0x006e6143
 80289f8:	3339314a 	.word	0x3339314a
 80289fc:	76637239 	.word	0x76637239
 8028a00:	00000000 	.word	0x00000000
 8028a04:	5f6e6163 	.word	0x5f6e6163
 8028a08:	735f7872 	.word	0x735f7872
 8028a0c:	63206d65 	.word	0x63206d65
 8028a10:	74616572 	.word	0x74616572
 8028a14:	72652065 	.word	0x72652065
 8028a18:	0d726f72 	.word	0x0d726f72
 8028a1c:	0000000a 	.word	0x0000000a
 8028a20:	3339314a 	.word	0x3339314a
 8028a24:	76635239 	.word	0x76635239
 8028a28:	00000000 	.word	0x00000000
 8028a2c:	00000030 	.word	0x00000030
 8028a30:	00000031 	.word	0x00000031
 8028a34:	00000032 	.word	0x00000032
 8028a38:	00000033 	.word	0x00000033
 8028a3c:	6e6b6e75 	.word	0x6e6b6e75
 8028a40:	206e776f 	.word	0x206e776f
 8028a44:	61726170 	.word	0x61726170
 8028a48:	6574656d 	.word	0x6574656d
 8028a4c:	000a0d72 	.word	0x000a0d72
 8028a50:	00006e6f 	.word	0x00006e6f
 8028a54:	0066666f 	.word	0x0066666f
 8028a58:	706d6574 	.word	0x706d6574
 8028a5c:	7830203d 	.word	0x7830203d
 8028a60:	0d207825 	.word	0x0d207825
 8028a64:	0000000a 	.word	0x0000000a
 8028a68:	20535542 	.word	0x20535542
 8028a6c:	30203d56 	.word	0x30203d56
 8028a70:	20782578 	.word	0x20782578
 8028a74:	00000a0d 	.word	0x00000a0d
 8028a78:	20535542 	.word	0x20535542
 8028a7c:	30203d49 	.word	0x30203d49
 8028a80:	20782578 	.word	0x20782578
 8028a84:	00000a0d 	.word	0x00000a0d
 8028a88:	544c4f56 	.word	0x544c4f56
 8028a8c:	20454741 	.word	0x20454741
 8028a90:	30203d43 	.word	0x30203d43
 8028a94:	20782578 	.word	0x20782578
 8028a98:	00000a0d 	.word	0x00000a0d
 8028a9c:	544c4f56 	.word	0x544c4f56
 8028aa0:	20454741 	.word	0x20454741
 8028aa4:	30203d42 	.word	0x30203d42
 8028aa8:	20782578 	.word	0x20782578
 8028aac:	00000a0d 	.word	0x00000a0d
 8028ab0:	544c4f56 	.word	0x544c4f56
 8028ab4:	20454741 	.word	0x20454741
 8028ab8:	30203d41 	.word	0x30203d41
 8028abc:	20782578 	.word	0x20782578
 8028ac0:	00000a0d 	.word	0x00000a0d
 8028ac4:	72727563 	.word	0x72727563
 8028ac8:	20746e65 	.word	0x20746e65
 8028acc:	203d3243 	.word	0x203d3243
 8028ad0:	78257830 	.word	0x78257830
 8028ad4:	000a0d20 	.word	0x000a0d20
 8028ad8:	72727563 	.word	0x72727563
 8028adc:	20746e65 	.word	0x20746e65
 8028ae0:	203d3143 	.word	0x203d3143
 8028ae4:	78257830 	.word	0x78257830
 8028ae8:	000a0d20 	.word	0x000a0d20
 8028aec:	72727563 	.word	0x72727563
 8028af0:	20746e65 	.word	0x20746e65
 8028af4:	203d3242 	.word	0x203d3242
 8028af8:	78257830 	.word	0x78257830
 8028afc:	000a0d20 	.word	0x000a0d20
 8028b00:	72727563 	.word	0x72727563
 8028b04:	20746e65 	.word	0x20746e65
 8028b08:	203d3142 	.word	0x203d3142
 8028b0c:	78257830 	.word	0x78257830
 8028b10:	000a0d20 	.word	0x000a0d20
 8028b14:	72727563 	.word	0x72727563
 8028b18:	20746e65 	.word	0x20746e65
 8028b1c:	203d3241 	.word	0x203d3241
 8028b20:	78257830 	.word	0x78257830
 8028b24:	000a0d20 	.word	0x000a0d20
 8028b28:	72727563 	.word	0x72727563
 8028b2c:	20746e65 	.word	0x20746e65
 8028b30:	203d3141 	.word	0x203d3141
 8028b34:	78257830 	.word	0x78257830
 8028b38:	000a0d20 	.word	0x000a0d20
 8028b3c:	706d6574 	.word	0x706d6574
 8028b40:	66666f20 	.word	0x66666f20
 8028b44:	3d746573 	.word	0x3d746573
 8028b48:	25783020 	.word	0x25783020
 8028b4c:	0a0d2078 	.word	0x0a0d2078
 8028b50:	00000000 	.word	0x00000000
 8028b54:	20535542 	.word	0x20535542
 8028b58:	6f202056 	.word	0x6f202056
 8028b5c:	65736666 	.word	0x65736666
 8028b60:	30203d74 	.word	0x30203d74
 8028b64:	20782578 	.word	0x20782578
 8028b68:	00000a0d 	.word	0x00000a0d
 8028b6c:	20535542 	.word	0x20535542
 8028b70:	666f2049 	.word	0x666f2049
 8028b74:	74657366 	.word	0x74657366
 8028b78:	7830203d 	.word	0x7830203d
 8028b7c:	0d207825 	.word	0x0d207825
 8028b80:	0000000a 	.word	0x0000000a
 8028b84:	544c4f56 	.word	0x544c4f56
 8028b88:	20454741 	.word	0x20454741
 8028b8c:	666f2043 	.word	0x666f2043
 8028b90:	74657366 	.word	0x74657366
 8028b94:	7830203d 	.word	0x7830203d
 8028b98:	0d207825 	.word	0x0d207825
 8028b9c:	0000000a 	.word	0x0000000a
 8028ba0:	544c4f56 	.word	0x544c4f56
 8028ba4:	20454741 	.word	0x20454741
 8028ba8:	666f2042 	.word	0x666f2042
 8028bac:	74657366 	.word	0x74657366
 8028bb0:	7830203d 	.word	0x7830203d
 8028bb4:	0d207825 	.word	0x0d207825
 8028bb8:	0000000a 	.word	0x0000000a
 8028bbc:	544c4f56 	.word	0x544c4f56
 8028bc0:	20454741 	.word	0x20454741
 8028bc4:	666f2041 	.word	0x666f2041
 8028bc8:	74657366 	.word	0x74657366
 8028bcc:	7830203d 	.word	0x7830203d
 8028bd0:	0d207825 	.word	0x0d207825
 8028bd4:	0000000a 	.word	0x0000000a
 8028bd8:	72727563 	.word	0x72727563
 8028bdc:	20746e65 	.word	0x20746e65
 8028be0:	6f203243 	.word	0x6f203243
 8028be4:	65736666 	.word	0x65736666
 8028be8:	30203d74 	.word	0x30203d74
 8028bec:	20782578 	.word	0x20782578
 8028bf0:	00000a0d 	.word	0x00000a0d
 8028bf4:	72727563 	.word	0x72727563
 8028bf8:	20746e65 	.word	0x20746e65
 8028bfc:	6f203143 	.word	0x6f203143
 8028c00:	65736666 	.word	0x65736666
 8028c04:	30203d74 	.word	0x30203d74
 8028c08:	20782578 	.word	0x20782578
 8028c0c:	00000a0d 	.word	0x00000a0d
 8028c10:	72727563 	.word	0x72727563
 8028c14:	20746e65 	.word	0x20746e65
 8028c18:	6f203242 	.word	0x6f203242
 8028c1c:	65736666 	.word	0x65736666
 8028c20:	30203d74 	.word	0x30203d74
 8028c24:	20782578 	.word	0x20782578
 8028c28:	00000a0d 	.word	0x00000a0d
 8028c2c:	72727563 	.word	0x72727563
 8028c30:	20746e65 	.word	0x20746e65
 8028c34:	6f203142 	.word	0x6f203142
 8028c38:	65736666 	.word	0x65736666
 8028c3c:	30203d74 	.word	0x30203d74
 8028c40:	20782578 	.word	0x20782578
 8028c44:	00000a0d 	.word	0x00000a0d
 8028c48:	72727563 	.word	0x72727563
 8028c4c:	20746e65 	.word	0x20746e65
 8028c50:	6f203241 	.word	0x6f203241
 8028c54:	65736666 	.word	0x65736666
 8028c58:	30203d74 	.word	0x30203d74
 8028c5c:	20782578 	.word	0x20782578
 8028c60:	00000a0d 	.word	0x00000a0d
 8028c64:	72727563 	.word	0x72727563
 8028c68:	20746e65 	.word	0x20746e65
 8028c6c:	6f203141 	.word	0x6f203141
 8028c70:	65736666 	.word	0x65736666
 8028c74:	30203d74 	.word	0x30203d74
 8028c78:	20782578 	.word	0x20782578
 8028c7c:	00000a0d 	.word	0x00000a0d
 8028c80:	0d3a3064 	.word	0x0d3a3064
 8028c84:	2078250a 	.word	0x2078250a
 8028c88:	7825203d 	.word	0x7825203d
 8028c8c:	78250a0d 	.word	0x78250a0d
 8028c90:	25203d20 	.word	0x25203d20
 8028c94:	000a0d78 	.word	0x000a0d78
 8028c98:	0d3a3164 	.word	0x0d3a3164
 8028c9c:	2078250a 	.word	0x2078250a
 8028ca0:	7825203d 	.word	0x7825203d
 8028ca4:	78250a0d 	.word	0x78250a0d
 8028ca8:	25203d20 	.word	0x25203d20
 8028cac:	000a0d78 	.word	0x000a0d78
 8028cb0:	6f746f4d 	.word	0x6f746f4d
 8028cb4:	73692072 	.word	0x73692072
 8028cb8:	61747320 	.word	0x61747320
 8028cbc:	64657472 	.word	0x64657472
 8028cc0:	00000a0d 	.word	0x00000a0d
 8028cc4:	6f746f4d 	.word	0x6f746f4d
 8028cc8:	73692072 	.word	0x73692072
 8028ccc:	6f747320 	.word	0x6f747320
 8028cd0:	64657070 	.word	0x64657070
 8028cd4:	00000a0d 	.word	0x00000a0d
 8028cd8:	354d4954 	.word	0x354d4954
 8028cdc:	544e4320 	.word	0x544e4320
 8028ce0:	78253d20 	.word	0x78253d20
 8028ce4:	00000a0d 	.word	0x00000a0d
 8028ce8:	6f746f4d 	.word	0x6f746f4d
 8028cec:	00000072 	.word	0x00000072
 8028cf0:	74696e69 	.word	0x74696e69
 8028cf4:	00000000 	.word	0x00000000
 8028cf8:	74737973 	.word	0x74737973
 8028cfc:	00006d65 	.word	0x00006d65
 8028d00:	74726175 	.word	0x74726175
 8028d04:	00000033 	.word	0x00000033
 8028d08:	6e65706f 	.word	0x6e65706f
 8028d0c:	72726520 	.word	0x72726520
 8028d10:	0a0d726f 	.word	0x0a0d726f
 8028d14:	00000000 	.word	0x00000000
 8028d18:	72617375 	.word	0x72617375
 8028d1c:	78743374 	.word	0x78743374
 8028d20:	00000000 	.word	0x00000000
 8028d24:	206d6573 	.word	0x206d6573
 8028d28:	61657263 	.word	0x61657263
 8028d2c:	65206574 	.word	0x65206574
 8028d30:	726f7272 	.word	0x726f7272
 8028d34:	00000a0d 	.word	0x00000a0d
 8028d38:	72617375 	.word	0x72617375
 8028d3c:	63723374 	.word	0x63723374
 8028d40:	00000076 	.word	0x00000076
 8028d44:	72617375 	.word	0x72617375
 8028d48:	78723374 	.word	0x78723374
 8028d4c:	0000716d 	.word	0x0000716d
 8028d50:	6d5f7872 	.word	0x6d5f7872
 8028d54:	72632071 	.word	0x72632071
 8028d58:	65746165 	.word	0x65746165
 8028d5c:	72726520 	.word	0x72726520
 8028d60:	0a0d726f 	.word	0x0a0d726f
 8028d64:	00000000 	.word	0x00000000
 8028d68:	72617375 	.word	0x72617375
 8028d6c:	78723374 	.word	0x78723374
 8028d70:	00000000 	.word	0x00000000
 8028d74:	20766564 	.word	0x20766564
 8028d78:	52203d21 	.word	0x52203d21
 8028d7c:	554e5f54 	.word	0x554e5f54
 8028d80:	00004c4c 	.word	0x00004c4c
 8028d84:	69206f54 	.word	0x69206f54
 8028d88:	6974696e 	.word	0x6974696e
 8028d8c:	7a696c61 	.word	0x7a696c61
 8028d90:	65642065 	.word	0x65642065
 8028d94:	65636976 	.word	0x65636976
 8028d98:	2073253a 	.word	0x2073253a
 8028d9c:	6c696166 	.word	0x6c696166
 8028da0:	202e6465 	.word	0x202e6465
 8028da4:	20656854 	.word	0x20656854
 8028da8:	6f727265 	.word	0x6f727265
 8028dac:	6f632072 	.word	0x6f632072
 8028db0:	69206564 	.word	0x69206564
 8028db4:	64252073 	.word	0x64252073
 8028db8:	0000000a 	.word	0x0000000a
 8028dbc:	2d766564 	.word	0x2d766564
 8028dc0:	6665723e 	.word	0x6665723e
 8028dc4:	756f635f 	.word	0x756f635f
 8028dc8:	2120746e 	.word	0x2120746e
 8028dcc:	0030203d 	.word	0x0030203d
 8028dd0:	636e7546 	.word	0x636e7546
 8028dd4:	6e6f6974 	.word	0x6e6f6974
 8028dd8:	5d73255b 	.word	0x5d73255b
 8028ddc:	61687320 	.word	0x61687320
 8028de0:	6e206c6c 	.word	0x6e206c6c
 8028de4:	7520746f 	.word	0x7520746f
 8028de8:	20646573 	.word	0x20646573
 8028dec:	49206e69 	.word	0x49206e69
 8028df0:	000a5253 	.word	0x000a5253
 8028df4:	00000030 	.word	0x00000030
 8028df8:	6c646974 	.word	0x6c646974
 8028dfc:	00000065 	.word	0x00000065
 8028e00:	206d6573 	.word	0x206d6573
 8028e04:	52203d21 	.word	0x52203d21
 8028e08:	554e5f54 	.word	0x554e5f54
 8028e0c:	00004c4c 	.word	0x00004c4c
 8028e10:	636e7546 	.word	0x636e7546
 8028e14:	6e6f6974 	.word	0x6e6f6974
 8028e18:	5d73255b 	.word	0x5d73255b
 8028e1c:	61687320 	.word	0x61687320
 8028e20:	6e206c6c 	.word	0x6e206c6c
 8028e24:	7520746f 	.word	0x7520746f
 8028e28:	20646573 	.word	0x20646573
 8028e2c:	49206e69 	.word	0x49206e69
 8028e30:	000a5253 	.word	0x000a5253
 8028e34:	00000030 	.word	0x00000030
 8028e38:	636e7546 	.word	0x636e7546
 8028e3c:	6e6f6974 	.word	0x6e6f6974
 8028e40:	5d73255b 	.word	0x5d73255b
 8028e44:	61687320 	.word	0x61687320
 8028e48:	6e206c6c 	.word	0x6e206c6c
 8028e4c:	6220746f 	.word	0x6220746f
 8028e50:	73752065 	.word	0x73752065
 8028e54:	62206465 	.word	0x62206465
 8028e58:	726f6665 	.word	0x726f6665
 8028e5c:	63732065 	.word	0x63732065
 8028e60:	75646568 	.word	0x75646568
 8028e64:	2072656c 	.word	0x2072656c
 8028e68:	72617473 	.word	0x72617473
 8028e6c:	00000a74 	.word	0x00000a74
 8028e70:	6574756d 	.word	0x6574756d
 8028e74:	3d212078 	.word	0x3d212078
 8028e78:	5f545220 	.word	0x5f545220
 8028e7c:	4c4c554e 	.word	0x4c4c554e
 8028e80:	00000000 	.word	0x00000000
 8028e84:	6e657665 	.word	0x6e657665
 8028e88:	3d212074 	.word	0x3d212074
 8028e8c:	5f545220 	.word	0x5f545220
 8028e90:	4c4c554e 	.word	0x4c4c554e
 8028e94:	00000000 	.word	0x00000000
 8028e98:	2120626d 	.word	0x2120626d
 8028e9c:	5452203d 	.word	0x5452203d
 8028ea0:	4c554e5f 	.word	0x4c554e5f
 8028ea4:	0000004c 	.word	0x0000004c
 8028ea8:	2120716d 	.word	0x2120716d
 8028eac:	5452203d 	.word	0x5452203d
 8028eb0:	4c554e5f 	.word	0x4c554e5f
 8028eb4:	0000004c 	.word	0x0000004c
 8028eb8:	66667562 	.word	0x66667562
 8028ebc:	21207265 	.word	0x21207265
 8028ec0:	5452203d 	.word	0x5452203d
 8028ec4:	4c554e5f 	.word	0x4c554e5f
 8028ec8:	0000004c 	.word	0x0000004c
 8028ecc:	657a6973 	.word	0x657a6973
 8028ed0:	203d2120 	.word	0x203d2120
 8028ed4:	00000030 	.word	0x00000030
 8028ed8:	205c200a 	.word	0x205c200a
 8028edc:	0a2f207c 	.word	0x0a2f207c
 8028ee0:	00000000 	.word	0x00000000
 8028ee4:	5452202d 	.word	0x5452202d
 8028ee8:	20202d20 	.word	0x20202d20
 8028eec:	54202020 	.word	0x54202020
 8028ef0:	61657268 	.word	0x61657268
 8028ef4:	704f2064 	.word	0x704f2064
 8028ef8:	74617265 	.word	0x74617265
 8028efc:	20676e69 	.word	0x20676e69
 8028f00:	74737953 	.word	0x74737953
 8028f04:	000a6d65 	.word	0x000a6d65
 8028f08:	7c202f20 	.word	0x7c202f20
 8028f0c:	20205c20 	.word	0x20205c20
 8028f10:	25202020 	.word	0x25202020
 8028f14:	64252e64 	.word	0x64252e64
 8028f18:	2064252e 	.word	0x2064252e
 8028f1c:	6c697562 	.word	0x6c697562
 8028f20:	73252064 	.word	0x73252064
 8028f24:	0000000a 	.word	0x0000000a
 8028f28:	20766f4e 	.word	0x20766f4e
 8028f2c:	32203331 	.word	0x32203331
 8028f30:	00363130 	.word	0x00363130
 8028f34:	30303220 	.word	0x30303220
 8028f38:	202d2036 	.word	0x202d2036
 8028f3c:	35313032 	.word	0x35313032
 8028f40:	706f4320 	.word	0x706f4320
 8028f44:	67697279 	.word	0x67697279
 8028f48:	62207468 	.word	0x62207468
 8028f4c:	74722079 	.word	0x74722079
 8028f50:	7268742d 	.word	0x7268742d
 8028f54:	20646165 	.word	0x20646165
 8028f58:	6d616574 	.word	0x6d616574
 8028f5c:	0000000a 	.word	0x0000000a
 8028f60:	4c554e28 	.word	0x4c554e28
 8028f64:	0000294c 	.word	0x0000294c
 8028f68:	29732528 	.word	0x29732528
 8028f6c:	73736120 	.word	0x73736120
 8028f70:	69747265 	.word	0x69747265
 8028f74:	66206e6f 	.word	0x66206e6f
 8028f78:	656c6961 	.word	0x656c6961
 8028f7c:	74612064 	.word	0x74612064
 8028f80:	6e756620 	.word	0x6e756620
 8028f84:	6f697463 	.word	0x6f697463
 8028f88:	73253a6e 	.word	0x73253a6e
 8028f8c:	696c202c 	.word	0x696c202c
 8028f90:	6e20656e 	.word	0x6e20656e
 8028f94:	65626d75 	.word	0x65626d75
 8028f98:	64253a72 	.word	0x64253a72
 8028f9c:	00000a20 	.word	0x00000a20
 8028fa0:	5f747228 	.word	0x5f747228
 8028fa4:	746e6975 	.word	0x746e6975
 8028fa8:	20745f38 	.word	0x20745f38
 8028fac:	656d292a 	.word	0x656d292a
 8028fb0:	3d3e206d 	.word	0x3d3e206d
 8028fb4:	61656820 	.word	0x61656820
 8028fb8:	74705f70 	.word	0x74705f70
 8028fbc:	00000072 	.word	0x00000072
 8028fc0:	5f747228 	.word	0x5f747228
 8028fc4:	746e6975 	.word	0x746e6975
 8028fc8:	20745f38 	.word	0x20745f38
 8028fcc:	656d292a 	.word	0x656d292a
 8028fd0:	203c206d 	.word	0x203c206d
 8028fd4:	5f747228 	.word	0x5f747228
 8028fd8:	746e6975 	.word	0x746e6975
 8028fdc:	20745f38 	.word	0x20745f38
 8028fe0:	6568292a 	.word	0x6568292a
 8028fe4:	655f7061 	.word	0x655f7061
 8028fe8:	0000646e 	.word	0x0000646e
 8028fec:	2d6d656d 	.word	0x2d6d656d
 8028ff0:	6573753e 	.word	0x6573753e
 8028ff4:	3d3d2064 	.word	0x3d3d2064
 8028ff8:	00003020 	.word	0x00003020
 8028ffc:	636e7546 	.word	0x636e7546
 8029000:	6e6f6974 	.word	0x6e6f6974
 8029004:	5d73255b 	.word	0x5d73255b
 8029008:	61687320 	.word	0x61687320
 802900c:	6e206c6c 	.word	0x6e206c6c
 8029010:	7520746f 	.word	0x7520746f
 8029014:	20646573 	.word	0x20646573
 8029018:	49206e69 	.word	0x49206e69
 802901c:	000a5253 	.word	0x000a5253
 8029020:	00000030 	.word	0x00000030
 8029024:	206d656d 	.word	0x206d656d
 8029028:	74696e69 	.word	0x74696e69
 802902c:	7265202c 	.word	0x7265202c
 8029030:	20726f72 	.word	0x20726f72
 8029034:	69676562 	.word	0x69676562
 8029038:	6461206e 	.word	0x6461206e
 802903c:	73657264 	.word	0x73657264
 8029040:	78302073 	.word	0x78302073
 8029044:	202c7825 	.word	0x202c7825
 8029048:	20646e61 	.word	0x20646e61
 802904c:	20646e65 	.word	0x20646e65
 8029050:	72646461 	.word	0x72646461
 8029054:	20737365 	.word	0x20737365
 8029058:	78257830 	.word	0x78257830
 802905c:	0000000a 	.word	0x0000000a
 8029060:	70616568 	.word	0x70616568
 8029064:	00000000 	.word	0x00000000
 8029068:	666c2828 	.word	0x666c2828
 802906c:	20656572 	.word	0x20656572
 8029070:	68203d3d 	.word	0x68203d3d
 8029074:	5f706165 	.word	0x5f706165
 8029078:	29646e65 	.word	0x29646e65
 802907c:	207c7c20 	.word	0x207c7c20
 8029080:	666c2128 	.word	0x666c2128
 8029084:	2d656572 	.word	0x2d656572
 8029088:	6573753e 	.word	0x6573753e
 802908c:	00292964 	.word	0x00292964
 8029090:	5f747228 	.word	0x5f747228
 8029094:	746e6975 	.word	0x746e6975
 8029098:	745f3233 	.word	0x745f3233
 802909c:	6d656d29 	.word	0x6d656d29
 80290a0:	53202b20 	.word	0x53202b20
 80290a4:	4f455a49 	.word	0x4f455a49
 80290a8:	54535f46 	.word	0x54535f46
 80290ac:	54435552 	.word	0x54435552
 80290b0:	4d454d5f 	.word	0x4d454d5f
 80290b4:	73202b20 	.word	0x73202b20
 80290b8:	20657a69 	.word	0x20657a69
 80290bc:	28203d3c 	.word	0x28203d3c
 80290c0:	755f7472 	.word	0x755f7472
 80290c4:	33746e69 	.word	0x33746e69
 80290c8:	29745f32 	.word	0x29745f32
 80290cc:	70616568 	.word	0x70616568
 80290d0:	646e655f 	.word	0x646e655f
 80290d4:	00000000 	.word	0x00000000
 80290d8:	5f747228 	.word	0x5f747228
 80290dc:	746e6975 	.word	0x746e6975
 80290e0:	745f3233 	.word	0x745f3233
 80290e4:	72282829 	.word	0x72282829
 80290e8:	69755f74 	.word	0x69755f74
 80290ec:	5f38746e 	.word	0x5f38746e
 80290f0:	292a2074 	.word	0x292a2074
 80290f4:	206d656d 	.word	0x206d656d
 80290f8:	4953202b 	.word	0x4953202b
 80290fc:	464f455a 	.word	0x464f455a
 8029100:	5254535f 	.word	0x5254535f
 8029104:	5f544355 	.word	0x5f544355
 8029108:	294d454d 	.word	0x294d454d
 802910c:	52202520 	.word	0x52202520
 8029110:	4c415f54 	.word	0x4c415f54
 8029114:	5f4e4749 	.word	0x5f4e4749
 8029118:	455a4953 	.word	0x455a4953
 802911c:	203d3d20 	.word	0x203d3d20
 8029120:	00000030 	.word	0x00000030
 8029124:	72282828 	.word	0x72282828
 8029128:	69755f74 	.word	0x69755f74
 802912c:	3233746e 	.word	0x3233746e
 8029130:	6d29745f 	.word	0x6d29745f
 8029134:	20296d65 	.word	0x20296d65
 8029138:	52282026 	.word	0x52282026
 802913c:	4c415f54 	.word	0x4c415f54
 8029140:	5f4e4749 	.word	0x5f4e4749
 8029144:	455a4953 	.word	0x455a4953
 8029148:	2929312d 	.word	0x2929312d
 802914c:	203d3d20 	.word	0x203d3d20
 8029150:	00000030 	.word	0x00000030
 8029154:	72282828 	.word	0x72282828
 8029158:	69755f74 	.word	0x69755f74
 802915c:	3233746e 	.word	0x3233746e
 8029160:	7229745f 	.word	0x7229745f
 8029164:	296d656d 	.word	0x296d656d
 8029168:	28202620 	.word	0x28202620
 802916c:	415f5452 	.word	0x415f5452
 8029170:	4e47494c 	.word	0x4e47494c
 8029174:	5a49535f 	.word	0x5a49535f
 8029178:	29312d45 	.word	0x29312d45
 802917c:	3d3d2029 	.word	0x3d3d2029
 8029180:	00003020 	.word	0x00003020
 8029184:	5f747228 	.word	0x5f747228
 8029188:	746e6975 	.word	0x746e6975
 802918c:	20745f38 	.word	0x20745f38
 8029190:	6d72292a 	.word	0x6d72292a
 8029194:	3e206d65 	.word	0x3e206d65
 8029198:	7228203d 	.word	0x7228203d
 802919c:	69755f74 	.word	0x69755f74
 80291a0:	5f38746e 	.word	0x5f38746e
 80291a4:	292a2074 	.word	0x292a2074
 80291a8:	70616568 	.word	0x70616568
 80291ac:	7274705f 	.word	0x7274705f
 80291b0:	20262620 	.word	0x20262620
 80291b4:	5f747228 	.word	0x5f747228
 80291b8:	746e6975 	.word	0x746e6975
 80291bc:	20745f38 	.word	0x20745f38
 80291c0:	6d72292a 	.word	0x6d72292a
 80291c4:	3c206d65 	.word	0x3c206d65
 80291c8:	74722820 	.word	0x74722820
 80291cc:	6e69755f 	.word	0x6e69755f
 80291d0:	745f3874 	.word	0x745f3874
 80291d4:	68292a20 	.word	0x68292a20
 80291d8:	5f706165 	.word	0x5f706165
 80291dc:	00646e65 	.word	0x00646e65
 80291e0:	2d6d656d 	.word	0x2d6d656d
 80291e4:	6573753e 	.word	0x6573753e
 80291e8:	00000064 	.word	0x00000064
 80291ec:	2d6d656d 	.word	0x2d6d656d
 80291f0:	67616d3e 	.word	0x67616d3e
 80291f4:	3d206369 	.word	0x3d206369
 80291f8:	4548203d 	.word	0x4548203d
 80291fc:	4d5f5041 	.word	0x4d5f5041
 8029200:	43494741 	.word	0x43494741
 8029204:	00000000 	.word	0x00000000
 8029208:	61746f74 	.word	0x61746f74
 802920c:	656d206c 	.word	0x656d206c
 8029210:	79726f6d 	.word	0x79726f6d
 8029214:	6425203a 	.word	0x6425203a
 8029218:	0000000a 	.word	0x0000000a
 802921c:	64657375 	.word	0x64657375
 8029220:	6d656d20 	.word	0x6d656d20
 8029224:	2079726f 	.word	0x2079726f
 8029228:	6425203a 	.word	0x6425203a
 802922c:	0000000a 	.word	0x0000000a
 8029230:	6978616d 	.word	0x6978616d
 8029234:	206d756d 	.word	0x206d756d
 8029238:	6f6c6c61 	.word	0x6f6c6c61
 802923c:	65746163 	.word	0x65746163
 8029240:	656d2064 	.word	0x656d2064
 8029244:	79726f6d 	.word	0x79726f6d
 8029248:	6425203a 	.word	0x6425203a
 802924c:	0000000a 	.word	0x0000000a
 8029250:	686d656d 	.word	0x686d656d
 8029254:	20706165 	.word	0x20706165
 8029258:	52203d21 	.word	0x52203d21
 802925c:	554e5f54 	.word	0x554e5f54
 8029260:	00004c4c 	.word	0x00004c4c
 8029264:	70616568 	.word	0x70616568
 8029268:	00000000 	.word	0x00000000
 802926c:	70616568 	.word	0x70616568
 8029270:	203d2120 	.word	0x203d2120
 8029274:	4e5f5452 	.word	0x4e5f5452
 8029278:	004c4c55 	.word	0x004c4c55
 802927c:	7478656e 	.word	0x7478656e
 8029280:	7274705f 	.word	0x7274705f
 8029284:	68203e20 	.word	0x68203e20
 8029288:	65646165 	.word	0x65646165
 802928c:	74705f72 	.word	0x74705f72
 8029290:	00000072 	.word	0x00000072
 8029294:	7478656e 	.word	0x7478656e
 8029298:	7274705f 	.word	0x7274705f
 802929c:	30203e20 	.word	0x30203e20
 80292a0:	00000000 	.word	0x00000000
 80292a4:	61656828 	.word	0x61656828
 80292a8:	5f726564 	.word	0x5f726564
 80292ac:	2d727470 	.word	0x2d727470
 80292b0:	67616d3e 	.word	0x67616d3e
 80292b4:	26206369 	.word	0x26206369
 80292b8:	5f545220 	.word	0x5f545220
 80292bc:	484d454d 	.word	0x484d454d
 80292c0:	5f504145 	.word	0x5f504145
 80292c4:	4b53414d 	.word	0x4b53414d
 80292c8:	3d3d2029 	.word	0x3d3d2029
 80292cc:	5f545220 	.word	0x5f545220
 80292d0:	484d454d 	.word	0x484d454d
 80292d4:	5f504145 	.word	0x5f504145
 80292d8:	4947414d 	.word	0x4947414d
 80292dc:	00000043 	.word	0x00000043
 80292e0:	64616568 	.word	0x64616568
 80292e4:	705f7265 	.word	0x705f7265
 80292e8:	3e2d7274 	.word	0x3e2d7274
 80292ec:	6967616d 	.word	0x6967616d
 80292f0:	20262063 	.word	0x20262063
 80292f4:	4d5f5452 	.word	0x4d5f5452
 80292f8:	45484d45 	.word	0x45484d45
 80292fc:	555f5041 	.word	0x555f5041
 8029300:	00444553 	.word	0x00444553
 8029304:	61656828 	.word	0x61656828
 8029308:	5f726564 	.word	0x5f726564
 802930c:	2d727470 	.word	0x2d727470
 8029310:	78656e3e 	.word	0x78656e3e
 8029314:	6d3e2d74 	.word	0x6d3e2d74
 8029318:	63696761 	.word	0x63696761
 802931c:	52202620 	.word	0x52202620
 8029320:	454d5f54 	.word	0x454d5f54
 8029324:	4145484d 	.word	0x4145484d
 8029328:	414d5f50 	.word	0x414d5f50
 802932c:	20294b53 	.word	0x20294b53
 8029330:	52203d3d 	.word	0x52203d3d
 8029334:	454d5f54 	.word	0x454d5f54
 8029338:	4145484d 	.word	0x4145484d
 802933c:	414d5f50 	.word	0x414d5f50
 8029340:	00434947 	.word	0x00434947
 8029344:	656a626f 	.word	0x656a626f
 8029348:	21207463 	.word	0x21207463
 802934c:	5452203d 	.word	0x5452203d
 8029350:	4c554e5f 	.word	0x4c554e5f
 8029354:	0000004c 	.word	0x0000004c
 8029358:	636e7546 	.word	0x636e7546
 802935c:	6e6f6974 	.word	0x6e6f6974
 8029360:	5d73255b 	.word	0x5d73255b
 8029364:	61687320 	.word	0x61687320
 8029368:	6e206c6c 	.word	0x6e206c6c
 802936c:	7520746f 	.word	0x7520746f
 8029370:	20646573 	.word	0x20646573
 8029374:	49206e69 	.word	0x49206e69
 8029378:	000a5253 	.word	0x000a5253
 802937c:	00000030 	.word	0x00000030
 8029380:	626f2821 	.word	0x626f2821
 8029384:	7463656a 	.word	0x7463656a
 8029388:	79743e2d 	.word	0x79743e2d
 802938c:	26206570 	.word	0x26206570
 8029390:	5f545220 	.word	0x5f545220
 8029394:	656a624f 	.word	0x656a624f
 8029398:	435f7463 	.word	0x435f7463
 802939c:	7373616c 	.word	0x7373616c
 80293a0:	6174535f 	.word	0x6174535f
 80293a4:	29636974 	.word	0x29636974
 80293a8:	00000000 	.word	0x00000000
 80293ac:	65726874 	.word	0x65726874
 80293b0:	21206461 	.word	0x21206461
 80293b4:	5452203d 	.word	0x5452203d
 80293b8:	4c554e5f 	.word	0x4c554e5f
 80293bc:	0000004c 	.word	0x0000004c
 80293c0:	65726874 	.word	0x65726874
 80293c4:	253a6461 	.word	0x253a6461
 80293c8:	74732073 	.word	0x74732073
 80293cc:	206b6361 	.word	0x206b6361
 80293d0:	7265766f 	.word	0x7265766f
 80293d4:	776f6c66 	.word	0x776f6c66
 80293d8:	0000000a 	.word	0x0000000a
 80293dc:	6e726177 	.word	0x6e726177
 80293e0:	3a676e69 	.word	0x3a676e69
 80293e4:	20732520 	.word	0x20732520
 80293e8:	63617473 	.word	0x63617473
 80293ec:	7369206b 	.word	0x7369206b
 80293f0:	6f6c6320 	.word	0x6f6c6320
 80293f4:	74206573 	.word	0x74206573
 80293f8:	6e65206f 	.word	0x6e65206f
 80293fc:	666f2064 	.word	0x666f2064
 8029400:	61747320 	.word	0x61747320
 8029404:	61206b63 	.word	0x61206b63
 8029408:	65726464 	.word	0x65726464
 802940c:	0a2e7373 	.word	0x0a2e7373
 8029410:	00000000 	.word	0x00000000
 8029414:	6f697270 	.word	0x6f697270
 8029418:	79746972 	.word	0x79746972
 802941c:	52203c20 	.word	0x52203c20
 8029420:	48545f54 	.word	0x48545f54
 8029424:	44414552 	.word	0x44414552
 8029428:	4952505f 	.word	0x4952505f
 802942c:	5449524f 	.word	0x5449524f
 8029430:	414d5f59 	.word	0x414d5f59
 8029434:	00000058 	.word	0x00000058
 8029438:	65726874 	.word	0x65726874
 802943c:	21206461 	.word	0x21206461
 8029440:	5452203d 	.word	0x5452203d
 8029444:	4c554e5f 	.word	0x4c554e5f
 8029448:	0000004c 	.word	0x0000004c
 802944c:	63617473 	.word	0x63617473
 8029450:	74735f6b 	.word	0x74735f6b
 8029454:	20747261 	.word	0x20747261
 8029458:	52203d21 	.word	0x52203d21
 802945c:	554e5f54 	.word	0x554e5f54
 8029460:	00004c4c 	.word	0x00004c4c
 8029464:	65726874 	.word	0x65726874
 8029468:	3e2d6461 	.word	0x3e2d6461
 802946c:	74617473 	.word	0x74617473
 8029470:	203d3d20 	.word	0x203d3d20
 8029474:	545f5452 	.word	0x545f5452
 8029478:	41455248 	.word	0x41455248
 802947c:	4e495f44 	.word	0x4e495f44
 8029480:	00005449 	.word	0x00005449
 8029484:	65726874 	.word	0x65726874
 8029488:	3e2d6461 	.word	0x3e2d6461
 802948c:	74617473 	.word	0x74617473
 8029490:	203d3d20 	.word	0x203d3d20
 8029494:	545f5452 	.word	0x545f5452
 8029498:	41455248 	.word	0x41455248
 802949c:	55535f44 	.word	0x55535f44
 80294a0:	4e455053 	.word	0x4e455053
 80294a4:	00000044 	.word	0x00000044
 80294a8:	656d6974 	.word	0x656d6974
 80294ac:	3d212072 	.word	0x3d212072
 80294b0:	5f545220 	.word	0x5f545220
 80294b4:	4c4c554e 	.word	0x4c4c554e
 80294b8:	00000000 	.word	0x00000000
 80294bc:	656d6974 	.word	0x656d6974
 80294c0:	693e2d72 	.word	0x693e2d72
 80294c4:	5f74696e 	.word	0x5f74696e
 80294c8:	6b636974 	.word	0x6b636974
 80294cc:	52203c20 	.word	0x52203c20
 80294d0:	49545f54 	.word	0x49545f54
 80294d4:	4d5f4b43 	.word	0x4d5f4b43
 80294d8:	2f205841 	.word	0x2f205841
 80294dc:	00003220 	.word	0x00003220
 80294e0:	656d6974 	.word	0x656d6974
 80294e4:	00000072 	.word	0x00000072
 80294e8:	3a727370 	.word	0x3a727370
 80294ec:	25783020 	.word	0x25783020
 80294f0:	0a783830 	.word	0x0a783830
 80294f4:	00000000 	.word	0x00000000
 80294f8:	3a637020 	.word	0x3a637020
 80294fc:	25783020 	.word	0x25783020
 8029500:	0a783830 	.word	0x0a783830
 8029504:	00000000 	.word	0x00000000
 8029508:	3a726c20 	.word	0x3a726c20
 802950c:	25783020 	.word	0x25783020
 8029510:	0a783830 	.word	0x0a783830
 8029514:	00000000 	.word	0x00000000
 8029518:	3a323172 	.word	0x3a323172
 802951c:	25783020 	.word	0x25783020
 8029520:	0a783830 	.word	0x0a783830
 8029524:	00000000 	.word	0x00000000
 8029528:	3a333072 	.word	0x3a333072
 802952c:	25783020 	.word	0x25783020
 8029530:	0a783830 	.word	0x0a783830
 8029534:	00000000 	.word	0x00000000
 8029538:	3a323072 	.word	0x3a323072
 802953c:	25783020 	.word	0x25783020
 8029540:	0a783830 	.word	0x0a783830
 8029544:	00000000 	.word	0x00000000
 8029548:	3a313072 	.word	0x3a313072
 802954c:	25783020 	.word	0x25783020
 8029550:	0a783830 	.word	0x0a783830
 8029554:	00000000 	.word	0x00000000
 8029558:	3a303072 	.word	0x3a303072
 802955c:	25783020 	.word	0x25783020
 8029560:	0a783830 	.word	0x0a783830
 8029564:	00000000 	.word	0x00000000
 8029568:	64726168 	.word	0x64726168
 802956c:	75616620 	.word	0x75616620
 8029570:	6f20746c 	.word	0x6f20746c
 8029574:	6874206e 	.word	0x6874206e
 8029578:	64616572 	.word	0x64616572
 802957c:	7325203a 	.word	0x7325203a
 8029580:	0000000a 	.word	0x0000000a
 8029584:	74756873 	.word	0x74756873
 8029588:	6e776f64 	.word	0x6e776f64
 802958c:	0a2e2e2e 	.word	0x0a2e2e2e
 8029590:	00000000 	.word	0x00000000
 8029594:	00000030 	.word	0x00000030
 8029598:	00637472 	.word	0x00637472
 802959c:	656d6974 	.word	0x656d6974
 80295a0:	203d2120 	.word	0x203d2120
 80295a4:	4e5f5452 	.word	0x4e5f5452
 80295a8:	004c4c55 	.word	0x004c4c55
 80295ac:	00716d70 	.word	0x00716d70
 80295b0:	6d657370 	.word	0x6d657370
 80295b4:	00000000 	.word	0x00000000
 80295b8:	6d657370 	.word	0x6d657370
 80295bc:	64323025 	.word	0x64323025
 80295c0:	00000000 	.word	0x00000000
 80295c4:	48544150 	.word	0x48544150
 80295c8:	69622f3d 	.word	0x69622f3d
 80295cc:	0000006e 	.word	0x0000006e
 80295d0:	454d4f48 	.word	0x454d4f48
 80295d4:	6f682f3d 	.word	0x6f682f3d
 80295d8:	0000656d 	.word	0x0000656d
 80295dc:	706d6f63 	.word	0x706d6f63
 80295e0:	6974656c 	.word	0x6974656c
 80295e4:	21206e6f 	.word	0x21206e6f
 80295e8:	5452203d 	.word	0x5452203d
 80295ec:	4c554e5f 	.word	0x4c554e5f
 80295f0:	0000004c 	.word	0x0000004c
 80295f4:	6c5f7472 	.word	0x6c5f7472
 80295f8:	5f747369 	.word	0x5f747369
 80295fc:	6d657369 	.word	0x6d657369
 8029600:	28797470 	.word	0x28797470
 8029604:	6f632826 	.word	0x6f632826
 8029608:	656c706d 	.word	0x656c706d
 802960c:	6e6f6974 	.word	0x6e6f6974
 8029610:	75733e2d 	.word	0x75733e2d
 8029614:	6e657073 	.word	0x6e657073
 8029618:	5f646564 	.word	0x5f646564
 802961c:	7473696c 	.word	0x7473696c
 8029620:	00002929 	.word	0x00002929
 8029624:	636e7546 	.word	0x636e7546
 8029628:	6e6f6974 	.word	0x6e6f6974
 802962c:	5d73255b 	.word	0x5d73255b
 8029630:	61687320 	.word	0x61687320
 8029634:	6e206c6c 	.word	0x6e206c6c
 8029638:	7520746f 	.word	0x7520746f
 802963c:	20646573 	.word	0x20646573
 8029640:	49206e69 	.word	0x49206e69
 8029644:	000a5253 	.word	0x000a5253
 8029648:	00000030 	.word	0x00000030
 802964c:	75657571 	.word	0x75657571
 8029650:	3d212065 	.word	0x3d212065
 8029654:	5f545220 	.word	0x5f545220
 8029658:	4c4c554e 	.word	0x4c4c554e
 802965c:	00000000 	.word	0x00000000
 8029660:	636e7546 	.word	0x636e7546
 8029664:	6e6f6974 	.word	0x6e6f6974
 8029668:	5d73255b 	.word	0x5d73255b
 802966c:	61687320 	.word	0x61687320
 8029670:	6e206c6c 	.word	0x6e206c6c
 8029674:	7520746f 	.word	0x7520746f
 8029678:	20646573 	.word	0x20646573
 802967c:	49206e69 	.word	0x49206e69
 8029680:	000a5253 	.word	0x000a5253
 8029684:	00000030 	.word	0x00000030
 8029688:	61746164 	.word	0x61746164
 802968c:	7274705f 	.word	0x7274705f
 8029690:	203d2120 	.word	0x203d2120
 8029694:	4e5f5452 	.word	0x4e5f5452
 8029698:	004c4c55 	.word	0x004c4c55
 802969c:	657a6973 	.word	0x657a6973
 80296a0:	203d2120 	.word	0x203d2120
 80296a4:	4e5f5452 	.word	0x4e5f5452
 80296a8:	004c4c55 	.word	0x004c4c55
 80296ac:	20766564 	.word	0x20766564
 80296b0:	52203d21 	.word	0x52203d21
 80296b4:	554e5f54 	.word	0x554e5f54
 80296b8:	00004c4c 	.word	0x00004c4c
 80296bc:	78363025 	.word	0x78363025
 80296c0:	0000203a 	.word	0x0000203a
 80296c4:	78323025 	.word	0x78323025
 80296c8:	00000020 	.word	0x00000020
 80296cc:	00202020 	.word	0x00202020
 80296d0:	00000020 	.word	0x00000020
 80296d4:	00006325 	.word	0x00006325
 80296d8:	0000000a 	.word	0x0000000a
 80296dc:	6e206f6e 	.word	0x6e206f6e
 80296e0:	20646e61 	.word	0x20646e61
 80296e4:	69766564 	.word	0x69766564
 80296e8:	66206563 	.word	0x66206563
 80296ec:	646e756f 	.word	0x646e756f
 80296f0:	00000a21 	.word	0x00000a21
 80296f4:	2074756f 	.word	0x2074756f
 80296f8:	6d20666f 	.word	0x6d20666f
 80296fc:	726f6d65 	.word	0x726f6d65
 8029700:	000a2179 	.word	0x000a2179
 8029704:	64616572 	.word	0x64616572
 8029708:	67617020 	.word	0x67617020
 802970c:	72202c65 	.word	0x72202c65
 8029710:	64253d63 	.word	0x64253d63
 8029714:	0000000a 	.word	0x0000000a
 8029718:	74697277 	.word	0x74697277
 802971c:	61702065 	.word	0x61702065
 8029720:	66206567 	.word	0x66206567
 8029724:	656c6961 	.word	0x656c6961
 8029728:	202c2164 	.word	0x202c2164
 802972c:	253d6372 	.word	0x253d6372
 8029730:	00000a64 	.word	0x00000a64
 8029734:	00637472 	.word	0x00637472
 8029738:	000a7325 	.word	0x000a7325
 802973c:	69726573 	.word	0x69726573
 8029740:	21206c61 	.word	0x21206c61
 8029744:	5452203d 	.word	0x5452203d
 8029748:	4c554e5f 	.word	0x4c554e5f
 802974c:	0000004c 	.word	0x0000004c
 8029750:	665f7872 	.word	0x665f7872
 8029754:	206f6669 	.word	0x206f6669
 8029758:	52203d21 	.word	0x52203d21
 802975c:	554e5f54 	.word	0x554e5f54
 8029760:	00004c4c 	.word	0x00004c4c
 8029764:	21207874 	.word	0x21207874
 8029768:	5452203d 	.word	0x5452203d
 802976c:	4c554e5f 	.word	0x4c554e5f
 8029770:	0000004c 	.word	0x0000004c
 8029774:	72657328 	.word	0x72657328
 8029778:	206c6169 	.word	0x206c6169
 802977c:	52203d21 	.word	0x52203d21
 8029780:	554e5f54 	.word	0x554e5f54
 8029784:	20294c4c 	.word	0x20294c4c
 8029788:	28202626 	.word	0x28202626
 802978c:	61746164 	.word	0x61746164
 8029790:	203d2120 	.word	0x203d2120
 8029794:	4e5f5452 	.word	0x4e5f5452
 8029798:	294c4c55 	.word	0x294c4c55
 802979c:	00000000 	.word	0x00000000
 80297a0:	645f7872 	.word	0x645f7872
 80297a4:	2120616d 	.word	0x2120616d
 80297a8:	5452203d 	.word	0x5452203d
 80297ac:	4c554e5f 	.word	0x4c554e5f
 80297b0:	0000004c 	.word	0x0000004c
 80297b4:	20766564 	.word	0x20766564
 80297b8:	52203d21 	.word	0x52203d21
 80297bc:	554e5f54 	.word	0x554e5f54
 80297c0:	00004c4c 	.word	0x00004c4c
 80297c4:	0a0d7825 	.word	0x0a0d7825
 80297c8:	00000000 	.word	0x00000000
 80297cc:	645f7874 	.word	0x645f7874
 80297d0:	2120616d 	.word	0x2120616d
 80297d4:	5452203d 	.word	0x5452203d
 80297d8:	4c554e5f 	.word	0x4c554e5f
 80297dc:	0000004c 	.word	0x0000004c
 80297e0:	665f7874 	.word	0x665f7874
 80297e4:	206f6669 	.word	0x206f6669
 80297e8:	52203d21 	.word	0x52203d21
 80297ec:	554e5f54 	.word	0x554e5f54
 80297f0:	00004c4c 	.word	0x00004c4c
 80297f4:	69726573 	.word	0x69726573
 80297f8:	3e2d6c61 	.word	0x3e2d6c61
 80297fc:	65726170 	.word	0x65726170
 8029800:	6f2e746e 	.word	0x6f2e746e
 8029804:	5f6e6570 	.word	0x5f6e6570
 8029808:	67616c66 	.word	0x67616c66
 802980c:	52202620 	.word	0x52202620
 8029810:	45445f54 	.word	0x45445f54
 8029814:	45434956 	.word	0x45434956
 8029818:	414c465f 	.word	0x414c465f
 802981c:	4e495f47 	.word	0x4e495f47
 8029820:	58525f54 	.word	0x58525f54
 8029824:	00000000 	.word	0x00000000
 8029828:	20766564 	.word	0x20766564
 802982c:	52203d21 	.word	0x52203d21
 8029830:	554e5f54 	.word	0x554e5f54
 8029834:	00004c4c 	.word	0x00004c4c
 8029838:	206e6163 	.word	0x206e6163
 802983c:	52203d21 	.word	0x52203d21
 8029840:	554e5f54 	.word	0x554e5f54
 8029844:	00004c4c 	.word	0x00004c4c
 8029848:	665f7872 	.word	0x665f7872
 802984c:	206f6669 	.word	0x206f6669
 8029850:	52203d21 	.word	0x52203d21
 8029854:	554e5f54 	.word	0x554e5f54
 8029858:	00004c4c 	.word	0x00004c4c
 802985c:	665f7872 	.word	0x665f7872
 8029860:	2d6f6669 	.word	0x2d6f6669
 8029864:	6572663e 	.word	0x6572663e
 8029868:	6d756e65 	.word	0x6d756e65
 802986c:	73726562 	.word	0x73726562
 8029870:	203d3c20 	.word	0x203d3c20
 8029874:	2d6e6163 	.word	0x2d6e6163
 8029878:	6e6f633e 	.word	0x6e6f633e
 802987c:	2e676966 	.word	0x2e676966
 8029880:	6267736d 	.word	0x6267736d
 8029884:	7a73786f 	.word	0x7a73786f
 8029888:	00000000 	.word	0x00000000
 802988c:	665f7874 	.word	0x665f7874
 8029890:	206f6669 	.word	0x206f6669
 8029894:	52203d21 	.word	0x52203d21
 8029898:	554e5f54 	.word	0x554e5f54
 802989c:	00004c4c 	.word	0x00004c4c
 80298a0:	745f7874 	.word	0x745f7874
 80298a4:	646e736f 	.word	0x646e736f
 80298a8:	203d2120 	.word	0x203d2120
 80298ac:	4e5f5452 	.word	0x4e5f5452
 80298b0:	004c4c55 	.word	0x004c4c55
 80298b4:	006e6163 	.word	0x006e6163
 80298b8:	2d6e6163 	.word	0x2d6e6163
 80298bc:	7261703e 	.word	0x7261703e
 80298c0:	2e746e65 	.word	0x2e746e65
 80298c4:	6e65706f 	.word	0x6e65706f
 80298c8:	616c665f 	.word	0x616c665f
 80298cc:	20262067 	.word	0x20262067
 80298d0:	445f5452 	.word	0x445f5452
 80298d4:	43495645 	.word	0x43495645
 80298d8:	4c465f45 	.word	0x4c465f45
 80298dc:	495f4741 	.word	0x495f4741
 80298e0:	525f544e 	.word	0x525f544e
 80298e4:	00000058 	.word	0x00000058
 80298e8:	665f7872 	.word	0x665f7872
 80298ec:	2d6f6669 	.word	0x2d6f6669
 80298f0:	6572663e 	.word	0x6572663e
 80298f4:	6d756e65 	.word	0x6d756e65
 80298f8:	73726562 	.word	0x73726562
 80298fc:	30203e20 	.word	0x30203e20
 8029900:	00000000 	.word	0x00000000
 8029904:	6e614320 	.word	0x6e614320
 8029908:	66207427 	.word	0x66207427
 802990c:	20646e69 	.word	0x20646e69
 8029910:	206e6163 	.word	0x206e6163
 8029914:	69766564 	.word	0x69766564
 8029918:	25206563 	.word	0x25206563
 802991c:	00000a73 	.word	0x00000a73
 8029920:	6e694620 	.word	0x6e694620
 8029924:	20646564 	.word	0x20646564
 8029928:	206e6163 	.word	0x206e6163
 802992c:	69766564 	.word	0x69766564
 8029930:	203a6563 	.word	0x203a6563
 8029934:	2e2e7325 	.word	0x2e2e7325
 8029938:	0000002e 	.word	0x0000002e
 802993c:	6552200a 	.word	0x6552200a
 8029940:	76696563 	.word	0x76696563
 8029944:	2e2e2e65 	.word	0x2e2e2e65
 8029948:	6f727265 	.word	0x6f727265
 802994c:	632e2e72 	.word	0x632e2e72
 8029950:	746e756f 	.word	0x746e756f
 8029954:	3025203a 	.word	0x3025203a
 8029958:	646c3031 	.word	0x646c3031
 802995c:	6553202e 	.word	0x6553202e
 8029960:	2e2e646e 	.word	0x2e2e646e
 8029964:	652e2e2e 	.word	0x652e2e2e
 8029968:	726f7272 	.word	0x726f7272
 802996c:	2e2e2e2e 	.word	0x2e2e2e2e
 8029970:	6e756f63 	.word	0x6e756f63
 8029974:	25203a74 	.word	0x25203a74
 8029978:	6c303130 	.word	0x6c303130
 802997c:	00002e64 	.word	0x00002e64
 8029980:	6942200a 	.word	0x6942200a
 8029984:	702e2e74 	.word	0x702e2e74
 8029988:	2e2e6461 	.word	0x2e2e6461
 802998c:	6f727265 	.word	0x6f727265
 8029990:	632e2e72 	.word	0x632e2e72
 8029994:	746e756f 	.word	0x746e756f
 8029998:	3025203a 	.word	0x3025203a
 802999c:	646c3031 	.word	0x646c3031
 80299a0:	6f46202e 	.word	0x6f46202e
 80299a4:	74616d72 	.word	0x74616d72
 80299a8:	652e2e2e 	.word	0x652e2e2e
 80299ac:	726f7272 	.word	0x726f7272
 80299b0:	2e2e2e2e 	.word	0x2e2e2e2e
 80299b4:	6e756f63 	.word	0x6e756f63
 80299b8:	25203a74 	.word	0x25203a74
 80299bc:	6c303130 	.word	0x6c303130
 80299c0:	00000064 	.word	0x00000064
 80299c4:	6341200a 	.word	0x6341200a
 80299c8:	2e2e2e6b 	.word	0x2e2e2e6b
 80299cc:	2e2e2e2e 	.word	0x2e2e2e2e
 80299d0:	6f727265 	.word	0x6f727265
 80299d4:	632e2e72 	.word	0x632e2e72
 80299d8:	746e756f 	.word	0x746e756f
 80299dc:	3025203a 	.word	0x3025203a
 80299e0:	646c3031 	.word	0x646c3031
 80299e4:	6942202e 	.word	0x6942202e
 80299e8:	2e2e2e74 	.word	0x2e2e2e74
 80299ec:	652e2e2e 	.word	0x652e2e2e
 80299f0:	726f7272 	.word	0x726f7272
 80299f4:	2e2e2e2e 	.word	0x2e2e2e2e
 80299f8:	6e756f63 	.word	0x6e756f63
 80299fc:	25203a74 	.word	0x25203a74
 8029a00:	6c303130 	.word	0x6c303130
 8029a04:	00002e64 	.word	0x00002e64
 8029a08:	5243200a 	.word	0x5243200a
 8029a0c:	2e2e2e43 	.word	0x2e2e2e43
 8029a10:	2e2e2e2e 	.word	0x2e2e2e2e
 8029a14:	6f727265 	.word	0x6f727265
 8029a18:	632e2e72 	.word	0x632e2e72
 8029a1c:	746e756f 	.word	0x746e756f
 8029a20:	3025203a 	.word	0x3025203a
 8029a24:	646c3031 	.word	0x646c3031
 8029a28:	7245202e 	.word	0x7245202e
 8029a2c:	2e726f72 	.word	0x2e726f72
 8029a30:	65646f63 	.word	0x65646f63
 8029a34:	30255b2e 	.word	0x30255b2e
 8029a38:	646c3031 	.word	0x646c3031
 8029a3c:	00203a5d 	.word	0x00203a5d
 8029a40:	002e7325 	.word	0x002e7325
 8029a44:	6f54200a 	.word	0x6f54200a
 8029a48:	2e6c6174 	.word	0x2e6c6174
 8029a4c:	65636572 	.word	0x65636572
 8029a50:	2e657669 	.word	0x2e657669
 8029a54:	6b636170 	.word	0x6b636170
 8029a58:	73656761 	.word	0x73656761
 8029a5c:	3025203a 	.word	0x3025203a
 8029a60:	646c3031 	.word	0x646c3031
 8029a64:	7244202e 	.word	0x7244202e
 8029a68:	6465706f 	.word	0x6465706f
 8029a6c:	6365722e 	.word	0x6365722e
 8029a70:	65766965 	.word	0x65766965
 8029a74:	6361702e 	.word	0x6361702e
 8029a78:	6567616b 	.word	0x6567616b
 8029a7c:	25203a73 	.word	0x25203a73
 8029a80:	6c303130 	.word	0x6c303130
 8029a84:	00002e64 	.word	0x00002e64
 8029a88:	6f54200a 	.word	0x6f54200a
 8029a8c:	2e6c6174 	.word	0x2e6c6174
 8029a90:	6e65732e 	.word	0x6e65732e
 8029a94:	2e2e2e64 	.word	0x2e2e2e64
 8029a98:	6b636170 	.word	0x6b636170
 8029a9c:	73656761 	.word	0x73656761
 8029aa0:	3025203a 	.word	0x3025203a
 8029aa4:	646c3031 	.word	0x646c3031
 8029aa8:	7244202e 	.word	0x7244202e
 8029aac:	6465706f 	.word	0x6465706f
 8029ab0:	732e2e2e 	.word	0x732e2e2e
 8029ab4:	2e646e65 	.word	0x2e646e65
 8029ab8:	6361702e 	.word	0x6361702e
 8029abc:	6567616b 	.word	0x6567616b
 8029ac0:	25203a73 	.word	0x25203a73
 8029ac4:	6c303130 	.word	0x6c303130
 8029ac8:	000a2e64 	.word	0x000a2e64
 8029acc:	766e4920 	.word	0x766e4920
 8029ad0:	64696c61 	.word	0x64696c61
 8029ad4:	6c614320 	.word	0x6c614320
 8029ad8:	7325206c 	.word	0x7325206c
 8029adc:	0000000a 	.word	0x0000000a
 8029ae0:	656c5020 	.word	0x656c5020
 8029ae4:	20657361 	.word	0x20657361
 8029ae8:	6e697375 	.word	0x6e697375
 8029aec:	73252067 	.word	0x73252067
 8029af0:	6e616320 	.word	0x6e616320
 8029af4:	656d616e 	.word	0x656d616e
 8029af8:	482e2078 	.word	0x482e2078
 8029afc:	20657265 	.word	0x20657265
 8029b00:	6e6e6163 	.word	0x6e6e6163
 8029b04:	20656d61 	.word	0x20656d61
 8029b08:	64207369 	.word	0x64207369
 8029b0c:	65766972 	.word	0x65766972
 8029b10:	616e2072 	.word	0x616e2072
 8029b14:	6120656d 	.word	0x6120656d
 8029b18:	7820646e 	.word	0x7820646e
 8029b1c:	20736920 	.word	0x20736920
 8029b20:	646e6163 	.word	0x646e6163
 8029b24:	65766972 	.word	0x65766972
 8029b28:	6d756e20 	.word	0x6d756e20
 8029b2c:	2e726562 	.word	0x2e726562
 8029b30:	0000000a 	.word	0x0000000a
 8029b34:	45206f4e 	.word	0x45206f4e
 8029b38:	726f7272 	.word	0x726f7272
 8029b3c:	00000021 	.word	0x00000021
 8029b40:	6e726157 	.word	0x6e726157
 8029b44:	20676e69 	.word	0x20676e69
 8029b48:	00000021 	.word	0x00000021
 8029b4c:	73736150 	.word	0x73736150
 8029b50:	20657669 	.word	0x20657669
 8029b54:	00000021 	.word	0x00000021
 8029b58:	20737542 	.word	0x20737542
 8029b5c:	2066664f 	.word	0x2066664f
 8029b60:	00000021 	.word	0x00000021
 8029b64:	2068736d 	.word	0x2068736d
 8029b68:	00000000 	.word	0x00000000
 8029b6c:	736e6966 	.word	0x736e6966
 8029b70:	00002068 	.word	0x00002068
 8029b74:	0000003e 	.word	0x0000003e
 8029b78:	6c656873 	.word	0x6c656873
 8029b7c:	3d21206c 	.word	0x3d21206c
 8029b80:	5f545220 	.word	0x5f545220
 8029b84:	4c4c554e 	.word	0x4c4c554e
 8029b88:	00000000 	.word	0x00000000
 8029b8c:	736e6966 	.word	0x736e6966
 8029b90:	63203a68 	.word	0x63203a68
 8029b94:	6e206e61 	.word	0x6e206e61
 8029b98:	6620746f 	.word	0x6620746f
 8029b9c:	20646e69 	.word	0x20646e69
 8029ba0:	69766564 	.word	0x69766564
 8029ba4:	203a6563 	.word	0x203a6563
 8029ba8:	000a7325 	.word	0x000a7325
 8029bac:	0000000a 	.word	0x0000000a
 8029bb0:	73257325 	.word	0x73257325
 8029bb4:	00000000 	.word	0x00000000
 8029bb8:	000a7325 	.word	0x000a7325
 8029bbc:	63252709 	.word	0x63252709
 8029bc0:	25202c27 	.word	0x25202c27
 8029bc4:	30202c64 	.word	0x30202c64
 8029bc8:	38302578 	.word	0x38302578
 8029bcc:	00000a78 	.word	0x00000a78
 8029bd0:	2c642509 	.word	0x2c642509
 8029bd4:	25783020 	.word	0x25783020
 8029bd8:	0a783830 	.word	0x0a783830
 8029bdc:	00000000 	.word	0x00000000
 8029be0:	4b325b1b 	.word	0x4b325b1b
 8029be4:	0000000d 	.word	0x0000000d
 8029be8:	6c656873 	.word	0x6c656873
 8029bec:	643e2d6c 	.word	0x643e2d6c
 8029bf0:	63697665 	.word	0x63697665
 8029bf4:	00000065 	.word	0x00000065
 8029bf8:	00000008 	.word	0x00000008
 8029bfc:	00006325 	.word	0x00006325
 8029c00:	20732508 	.word	0x20732508
 8029c04:	00000820 	.word	0x00000820
 8029c08:	00082008 	.word	0x00082008
 8029c0c:	00007325 	.word	0x00007325
 8029c10:	6d206f6e 	.word	0x6d206f6e
 8029c14:	726f6d65 	.word	0x726f6d65
 8029c18:	6f662079 	.word	0x6f662079
 8029c1c:	68732072 	.word	0x68732072
 8029c20:	0a6c6c65 	.word	0x0a6c6c65
 8029c24:	00000000 	.word	0x00000000
 8029c28:	78726873 	.word	0x78726873
 8029c2c:	00000000 	.word	0x00000000
 8029c30:	65687374 	.word	0x65687374
 8029c34:	00006c6c 	.word	0x00006c6c
 8029c38:	6c6c6548 	.word	0x6c6c6548
 8029c3c:	5452206f 	.word	0x5452206f
 8029c40:	7268542d 	.word	0x7268542d
 8029c44:	21646165 	.word	0x21646165
 8029c48:	0000000a 	.word	0x0000000a
 8029c4c:	72687420 	.word	0x72687420
 8029c50:	20646165 	.word	0x20646165
 8029c54:	69727020 	.word	0x69727020
 8029c58:	74732020 	.word	0x74732020
 8029c5c:	73757461 	.word	0x73757461
 8029c60:	20202020 	.word	0x20202020
 8029c64:	70732020 	.word	0x70732020
 8029c68:	20202020 	.word	0x20202020
 8029c6c:	61747320 	.word	0x61747320
 8029c70:	73206b63 	.word	0x73206b63
 8029c74:	20657a69 	.word	0x20657a69
 8029c78:	2078616d 	.word	0x2078616d
 8029c7c:	64657375 	.word	0x64657375
 8029c80:	6c202020 	.word	0x6c202020
 8029c84:	20746665 	.word	0x20746665
 8029c88:	6b636974 	.word	0x6b636974
 8029c8c:	72652020 	.word	0x72652020
 8029c90:	0a726f72 	.word	0x0a726f72
 8029c94:	00000000 	.word	0x00000000
 8029c98:	2d2d2d2d 	.word	0x2d2d2d2d
 8029c9c:	2d2d2d2d 	.word	0x2d2d2d2d
 8029ca0:	2d2d2d20 	.word	0x2d2d2d20
 8029ca4:	2d2d202d 	.word	0x2d2d202d
 8029ca8:	2d2d2d2d 	.word	0x2d2d2d2d
 8029cac:	2d2d202d 	.word	0x2d2d202d
 8029cb0:	2d2d2d2d 	.word	0x2d2d2d2d
 8029cb4:	2d2d2d2d 	.word	0x2d2d2d2d
 8029cb8:	2d2d2d20 	.word	0x2d2d2d20
 8029cbc:	2d2d2d2d 	.word	0x2d2d2d2d
 8029cc0:	202d2d2d 	.word	0x202d2d2d
 8029cc4:	2d2d2d2d 	.word	0x2d2d2d2d
 8029cc8:	2d2d2d2d 	.word	0x2d2d2d2d
 8029ccc:	2d202d2d 	.word	0x2d202d2d
 8029cd0:	2d2d2d2d 	.word	0x2d2d2d2d
 8029cd4:	2d2d2d2d 	.word	0x2d2d2d2d
 8029cd8:	2d2d202d 	.word	0x2d2d202d
 8029cdc:	00000a2d 	.word	0x00000a2d
 8029ce0:	2e382d25 	.word	0x2e382d25
 8029ce4:	3020732a 	.word	0x3020732a
 8029ce8:	32302578 	.word	0x32302578
 8029cec:	00000078 	.word	0x00000078
 8029cf0:	61657220 	.word	0x61657220
 8029cf4:	20207964 	.word	0x20207964
 8029cf8:	00000000 	.word	0x00000000
 8029cfc:	73757320 	.word	0x73757320
 8029d00:	646e6570 	.word	0x646e6570
 8029d04:	00000000 	.word	0x00000000
 8029d08:	696e6920 	.word	0x696e6920
 8029d0c:	20202074 	.word	0x20202074
 8029d10:	00000000 	.word	0x00000000
 8029d14:	6f6c6320 	.word	0x6f6c6320
 8029d18:	20206573 	.word	0x20206573
 8029d1c:	00000000 	.word	0x00000000
 8029d20:	25783020 	.word	0x25783020
 8029d24:	20783830 	.word	0x20783830
 8029d28:	30257830 	.word	0x30257830
 8029d2c:	30207838 	.word	0x30207838
 8029d30:	38302578 	.word	0x38302578
 8029d34:	78302078 	.word	0x78302078
 8029d38:	78383025 	.word	0x78383025
 8029d3c:	33302520 	.word	0x33302520
 8029d40:	00000a64 	.word	0x00000a64
 8029d44:	00007325 	.word	0x00007325
 8029d48:	0000002f 	.word	0x0000002f
 8029d4c:	616d6573 	.word	0x616d6573
 8029d50:	726f6870 	.word	0x726f6870
 8029d54:	20762065 	.word	0x20762065
 8029d58:	75732020 	.word	0x75732020
 8029d5c:	6e657073 	.word	0x6e657073
 8029d60:	68742064 	.word	0x68742064
 8029d64:	64616572 	.word	0x64616572
 8029d68:	0000000a 	.word	0x0000000a
 8029d6c:	2d2d2d2d 	.word	0x2d2d2d2d
 8029d70:	2d2d2d2d 	.word	0x2d2d2d2d
 8029d74:	2d2d2020 	.word	0x2d2d2020
 8029d78:	2d2d202d 	.word	0x2d2d202d
 8029d7c:	2d2d2d2d 	.word	0x2d2d2d2d
 8029d80:	2d2d2d2d 	.word	0x2d2d2d2d
 8029d84:	2d2d2d2d 	.word	0x2d2d2d2d
 8029d88:	0000000a 	.word	0x0000000a
 8029d8c:	2e382d25 	.word	0x2e382d25
 8029d90:	2020732a 	.word	0x2020732a
 8029d94:	64333025 	.word	0x64333025
 8029d98:	3a642520 	.word	0x3a642520
 8029d9c:	00000000 	.word	0x00000000
 8029da0:	0000000a 	.word	0x0000000a
 8029da4:	2e382d25 	.word	0x2e382d25
 8029da8:	2020732a 	.word	0x2020732a
 8029dac:	64333025 	.word	0x64333025
 8029db0:	0a642520 	.word	0x0a642520
 8029db4:	00000000 	.word	0x00000000
 8029db8:	6e657665 	.word	0x6e657665
 8029dbc:	20202074 	.word	0x20202074
 8029dc0:	74657320 	.word	0x74657320
 8029dc4:	20202020 	.word	0x20202020
 8029dc8:	20202020 	.word	0x20202020
 8029dcc:	70737573 	.word	0x70737573
 8029dd0:	20646e65 	.word	0x20646e65
 8029dd4:	65726874 	.word	0x65726874
 8029dd8:	000a6461 	.word	0x000a6461
 8029ddc:	2d2d2d2d 	.word	0x2d2d2d2d
 8029de0:	2d2d2d2d 	.word	0x2d2d2d2d
 8029de4:	2d2d2d20 	.word	0x2d2d2d20
 8029de8:	2d2d2d2d 	.word	0x2d2d2d2d
 8029dec:	202d2d2d 	.word	0x202d2d2d
 8029df0:	2d2d2d2d 	.word	0x2d2d2d2d
 8029df4:	2d2d2d2d 	.word	0x2d2d2d2d
 8029df8:	2d2d2d2d 	.word	0x2d2d2d2d
 8029dfc:	000a2d2d 	.word	0x000a2d2d
 8029e00:	2e382d25 	.word	0x2e382d25
 8029e04:	2020732a 	.word	0x2020732a
 8029e08:	30257830 	.word	0x30257830
 8029e0c:	25207838 	.word	0x25207838
 8029e10:	3a643330 	.word	0x3a643330
 8029e14:	00000000 	.word	0x00000000
 8029e18:	2e382d25 	.word	0x2e382d25
 8029e1c:	2020732a 	.word	0x2020732a
 8029e20:	30257830 	.word	0x30257830
 8029e24:	30207838 	.word	0x30207838
 8029e28:	0000000a 	.word	0x0000000a
 8029e2c:	6574756d 	.word	0x6574756d
 8029e30:	20202078 	.word	0x20202078
 8029e34:	6e776f20 	.word	0x6e776f20
 8029e38:	20207265 	.word	0x20207265
 8029e3c:	6f682020 	.word	0x6f682020
 8029e40:	7320646c 	.word	0x7320646c
 8029e44:	65707375 	.word	0x65707375
 8029e48:	7420646e 	.word	0x7420646e
 8029e4c:	61657268 	.word	0x61657268
 8029e50:	00000a64 	.word	0x00000a64
 8029e54:	2d2d2d2d 	.word	0x2d2d2d2d
 8029e58:	2d2d2d2d 	.word	0x2d2d2d2d
 8029e5c:	2d2d2d20 	.word	0x2d2d2d20
 8029e60:	2d2d2d2d 	.word	0x2d2d2d2d
 8029e64:	2d2d202d 	.word	0x2d2d202d
 8029e68:	2d202d2d 	.word	0x2d202d2d
 8029e6c:	2d2d2d2d 	.word	0x2d2d2d2d
 8029e70:	2d2d2d2d 	.word	0x2d2d2d2d
 8029e74:	2d2d2d2d 	.word	0x2d2d2d2d
 8029e78:	00000a2d 	.word	0x00000a2d
 8029e7c:	2e382d25 	.word	0x2e382d25
 8029e80:	2520732a 	.word	0x2520732a
 8029e84:	2a2e382d 	.word	0x2a2e382d
 8029e88:	30252073 	.word	0x30252073
 8029e8c:	25206434 	.word	0x25206434
 8029e90:	00000a64 	.word	0x00000a64
 8029e94:	6c69616d 	.word	0x6c69616d
 8029e98:	20786f62 	.word	0x20786f62
 8029e9c:	746e6520 	.word	0x746e6520
 8029ea0:	73207972 	.word	0x73207972
 8029ea4:	20657a69 	.word	0x20657a69
 8029ea8:	70737573 	.word	0x70737573
 8029eac:	20646e65 	.word	0x20646e65
 8029eb0:	65726874 	.word	0x65726874
 8029eb4:	000a6461 	.word	0x000a6461
 8029eb8:	2d2d2d2d 	.word	0x2d2d2d2d
 8029ebc:	2d2d2d2d 	.word	0x2d2d2d2d
 8029ec0:	2d2d2d20 	.word	0x2d2d2d20
 8029ec4:	2d20202d 	.word	0x2d20202d
 8029ec8:	202d2d2d 	.word	0x202d2d2d
 8029ecc:	2d2d2d2d 	.word	0x2d2d2d2d
 8029ed0:	2d2d2d2d 	.word	0x2d2d2d2d
 8029ed4:	2d2d2d2d 	.word	0x2d2d2d2d
 8029ed8:	000a2d2d 	.word	0x000a2d2d
 8029edc:	2e382d25 	.word	0x2e382d25
 8029ee0:	2520732a 	.word	0x2520732a
 8029ee4:	20643430 	.word	0x20643430
 8029ee8:	34302520 	.word	0x34302520
 8029eec:	64252064 	.word	0x64252064
 8029ef0:	0000003a 	.word	0x0000003a
 8029ef4:	2e382d25 	.word	0x2e382d25
 8029ef8:	2520732a 	.word	0x2520732a
 8029efc:	20643430 	.word	0x20643430
 8029f00:	34302520 	.word	0x34302520
 8029f04:	64252064 	.word	0x64252064
 8029f08:	0000000a 	.word	0x0000000a
 8029f0c:	7167736d 	.word	0x7167736d
 8029f10:	65756575 	.word	0x65756575
 8029f14:	746e6520 	.word	0x746e6520
 8029f18:	73207972 	.word	0x73207972
 8029f1c:	65707375 	.word	0x65707375
 8029f20:	7420646e 	.word	0x7420646e
 8029f24:	61657268 	.word	0x61657268
 8029f28:	00000a64 	.word	0x00000a64
 8029f2c:	2d2d2d2d 	.word	0x2d2d2d2d
 8029f30:	2d2d2d2d 	.word	0x2d2d2d2d
 8029f34:	2d2d2d20 	.word	0x2d2d2d20
 8029f38:	2d20202d 	.word	0x2d20202d
 8029f3c:	2d2d2d2d 	.word	0x2d2d2d2d
 8029f40:	2d2d2d2d 	.word	0x2d2d2d2d
 8029f44:	2d2d2d2d 	.word	0x2d2d2d2d
 8029f48:	00000a2d 	.word	0x00000a2d
 8029f4c:	2e382d25 	.word	0x2e382d25
 8029f50:	2520732a 	.word	0x2520732a
 8029f54:	20643430 	.word	0x20643430
 8029f58:	3a642520 	.word	0x3a642520
 8029f5c:	00000000 	.word	0x00000000
 8029f60:	2e382d25 	.word	0x2e382d25
 8029f64:	2520732a 	.word	0x2520732a
 8029f68:	20643430 	.word	0x20643430
 8029f6c:	0a642520 	.word	0x0a642520
 8029f70:	00000000 	.word	0x00000000
 8029f74:	686d656d 	.word	0x686d656d
 8029f78:	20706165 	.word	0x20706165
 8029f7c:	6f6f7020 	.word	0x6f6f7020
 8029f80:	6973206c 	.word	0x6973206c
 8029f84:	2020657a 	.word	0x2020657a
 8029f88:	2078616d 	.word	0x2078616d
 8029f8c:	64657375 	.word	0x64657375
 8029f90:	7a697320 	.word	0x7a697320
 8029f94:	76612065 	.word	0x76612065
 8029f98:	616c6961 	.word	0x616c6961
 8029f9c:	20656c62 	.word	0x20656c62
 8029fa0:	657a6973 	.word	0x657a6973
 8029fa4:	0000000a 	.word	0x0000000a
 8029fa8:	2d2d2d2d 	.word	0x2d2d2d2d
 8029fac:	2d2d2d2d 	.word	0x2d2d2d2d
 8029fb0:	2d2d2d20 	.word	0x2d2d2d20
 8029fb4:	2d2d2d2d 	.word	0x2d2d2d2d
 8029fb8:	202d2d2d 	.word	0x202d2d2d
 8029fbc:	2d2d2d2d 	.word	0x2d2d2d2d
 8029fc0:	2d2d2d2d 	.word	0x2d2d2d2d
 8029fc4:	2d2d2d2d 	.word	0x2d2d2d2d
 8029fc8:	2d2d202d 	.word	0x2d2d202d
 8029fcc:	2d2d2d2d 	.word	0x2d2d2d2d
 8029fd0:	2d2d2d2d 	.word	0x2d2d2d2d
 8029fd4:	2d2d2d2d 	.word	0x2d2d2d2d
 8029fd8:	0000000a 	.word	0x0000000a
 8029fdc:	2e382d25 	.word	0x2e382d25
 8029fe0:	2520732a 	.word	0x2520732a
 8029fe4:	3031302d 	.word	0x3031302d
 8029fe8:	2d252064 	.word	0x2d252064
 8029fec:	64333130 	.word	0x64333130
 8029ff0:	302d2520 	.word	0x302d2520
 8029ff4:	000a6435 	.word	0x000a6435
 8029ff8:	706d656d 	.word	0x706d656d
 8029ffc:	206c6f6f 	.word	0x206c6f6f
 802a000:	6f6c6220 	.word	0x6f6c6220
 802a004:	74206b63 	.word	0x74206b63
 802a008:	6c61746f 	.word	0x6c61746f
 802a00c:	65726620 	.word	0x65726620
 802a010:	75732065 	.word	0x75732065
 802a014:	6e657073 	.word	0x6e657073
 802a018:	68742064 	.word	0x68742064
 802a01c:	64616572 	.word	0x64616572
 802a020:	0000000a 	.word	0x0000000a
 802a024:	2d2d2d2d 	.word	0x2d2d2d2d
 802a028:	2d2d2d2d 	.word	0x2d2d2d2d
 802a02c:	2d2d2d20 	.word	0x2d2d2d20
 802a030:	2d20202d 	.word	0x2d20202d
 802a034:	202d2d2d 	.word	0x202d2d2d
 802a038:	2d2d2d20 	.word	0x2d2d2d20
 802a03c:	2d2d202d 	.word	0x2d2d202d
 802a040:	2d2d2d2d 	.word	0x2d2d2d2d
 802a044:	2d2d2d2d 	.word	0x2d2d2d2d
 802a048:	2d2d2d2d 	.word	0x2d2d2d2d
 802a04c:	0000000a 	.word	0x0000000a
 802a050:	2e382d25 	.word	0x2e382d25
 802a054:	2520732a 	.word	0x2520732a
 802a058:	20643430 	.word	0x20643430
 802a05c:	34302520 	.word	0x34302520
 802a060:	25202064 	.word	0x25202064
 802a064:	20643430 	.word	0x20643430
 802a068:	003a6425 	.word	0x003a6425
 802a06c:	2e382d25 	.word	0x2e382d25
 802a070:	2520732a 	.word	0x2520732a
 802a074:	20643430 	.word	0x20643430
 802a078:	34302520 	.word	0x34302520
 802a07c:	25202064 	.word	0x25202064
 802a080:	20643430 	.word	0x20643430
 802a084:	000a6425 	.word	0x000a6425
 802a088:	656d6974 	.word	0x656d6974
 802a08c:	20202072 	.word	0x20202072
 802a090:	72657020 	.word	0x72657020
 802a094:	69646f69 	.word	0x69646f69
 802a098:	20202063 	.word	0x20202063
 802a09c:	656d6974 	.word	0x656d6974
 802a0a0:	2074756f 	.word	0x2074756f
 802a0a4:	66202020 	.word	0x66202020
 802a0a8:	0a67616c 	.word	0x0a67616c
 802a0ac:	00000000 	.word	0x00000000
 802a0b0:	2d2d2d2d 	.word	0x2d2d2d2d
 802a0b4:	2d2d2d2d 	.word	0x2d2d2d2d
 802a0b8:	2d2d2d20 	.word	0x2d2d2d20
 802a0bc:	2d2d2d2d 	.word	0x2d2d2d2d
 802a0c0:	202d2d2d 	.word	0x202d2d2d
 802a0c4:	2d2d2d2d 	.word	0x2d2d2d2d
 802a0c8:	2d2d2d2d 	.word	0x2d2d2d2d
 802a0cc:	2d202d2d 	.word	0x2d202d2d
 802a0d0:	2d2d2d2d 	.word	0x2d2d2d2d
 802a0d4:	2d2d2d2d 	.word	0x2d2d2d2d
 802a0d8:	000a2d2d 	.word	0x000a2d2d
 802a0dc:	2e382d25 	.word	0x2e382d25
 802a0e0:	3020732a 	.word	0x3020732a
 802a0e4:	38302578 	.word	0x38302578
 802a0e8:	78302078 	.word	0x78302078
 802a0ec:	78383025 	.word	0x78383025
 802a0f0:	00000020 	.word	0x00000020
 802a0f4:	69746361 	.word	0x69746361
 802a0f8:	65746176 	.word	0x65746176
 802a0fc:	00000a64 	.word	0x00000a64
 802a100:	63616564 	.word	0x63616564
 802a104:	61766974 	.word	0x61766974
 802a108:	0a646574 	.word	0x0a646574
 802a10c:	00000000 	.word	0x00000000
 802a110:	72727563 	.word	0x72727563
 802a114:	20746e65 	.word	0x20746e65
 802a118:	6b636974 	.word	0x6b636974
 802a11c:	2578303a 	.word	0x2578303a
 802a120:	0a783830 	.word	0x0a783830
 802a124:	00000000 	.word	0x00000000
 802a128:	69766564 	.word	0x69766564
 802a12c:	20206563 	.word	0x20206563
 802a130:	70797420 	.word	0x70797420
 802a134:	20202065 	.word	0x20202065
 802a138:	20202020 	.word	0x20202020
 802a13c:	20202020 	.word	0x20202020
 802a140:	20202020 	.word	0x20202020
 802a144:	65722020 	.word	0x65722020
 802a148:	6f632066 	.word	0x6f632066
 802a14c:	0a746e75 	.word	0x0a746e75
 802a150:	00000000 	.word	0x00000000
 802a154:	2d2d2d2d 	.word	0x2d2d2d2d
 802a158:	2d2d2d2d 	.word	0x2d2d2d2d
 802a15c:	2d2d2d20 	.word	0x2d2d2d20
 802a160:	2d2d2d2d 	.word	0x2d2d2d2d
 802a164:	2d2d2d2d 	.word	0x2d2d2d2d
 802a168:	2d2d2d2d 	.word	0x2d2d2d2d
 802a16c:	2d2d2d2d 	.word	0x2d2d2d2d
 802a170:	2d2d202d 	.word	0x2d2d202d
 802a174:	2d2d2d2d 	.word	0x2d2d2d2d
 802a178:	2d2d2d2d 	.word	0x2d2d2d2d
 802a17c:	0000000a 	.word	0x0000000a
 802a180:	2e382d25 	.word	0x2e382d25
 802a184:	2520732a 	.word	0x2520732a
 802a188:	7330322d 	.word	0x7330322d
 802a18c:	382d2520 	.word	0x382d2520
 802a190:	00000a64 	.word	0x00000a64
 802a194:	72616843 	.word	0x72616843
 802a198:	65746361 	.word	0x65746361
 802a19c:	65442072 	.word	0x65442072
 802a1a0:	65636976 	.word	0x65636976
 802a1a4:	00000000 	.word	0x00000000
 802a1a8:	636f6c42 	.word	0x636f6c42
 802a1ac:	6544206b 	.word	0x6544206b
 802a1b0:	65636976 	.word	0x65636976
 802a1b4:	00000000 	.word	0x00000000
 802a1b8:	7774654e 	.word	0x7774654e
 802a1bc:	206b726f 	.word	0x206b726f
 802a1c0:	65746e49 	.word	0x65746e49
 802a1c4:	63616672 	.word	0x63616672
 802a1c8:	00000065 	.word	0x00000065
 802a1cc:	2044544d 	.word	0x2044544d
 802a1d0:	69766544 	.word	0x69766544
 802a1d4:	00006563 	.word	0x00006563
 802a1d8:	204e4143 	.word	0x204e4143
 802a1dc:	69766544 	.word	0x69766544
 802a1e0:	00006563 	.word	0x00006563
 802a1e4:	00435452 	.word	0x00435452
 802a1e8:	6e756f53 	.word	0x6e756f53
 802a1ec:	65442064 	.word	0x65442064
 802a1f0:	65636976 	.word	0x65636976
 802a1f4:	00000000 	.word	0x00000000
 802a1f8:	70617247 	.word	0x70617247
 802a1fc:	20636968 	.word	0x20636968
 802a200:	69766544 	.word	0x69766544
 802a204:	00006563 	.word	0x00006563
 802a208:	20433249 	.word	0x20433249
 802a20c:	00737542 	.word	0x00737542
 802a210:	20425355 	.word	0x20425355
 802a214:	76616c53 	.word	0x76616c53
 802a218:	65442065 	.word	0x65442065
 802a21c:	65636976 	.word	0x65636976
 802a220:	00000000 	.word	0x00000000
 802a224:	20425355 	.word	0x20425355
 802a228:	74736f48 	.word	0x74736f48
 802a22c:	73754220 	.word	0x73754220
 802a230:	00000000 	.word	0x00000000
 802a234:	20495053 	.word	0x20495053
 802a238:	00737542 	.word	0x00737542
 802a23c:	20495053 	.word	0x20495053
 802a240:	69766544 	.word	0x69766544
 802a244:	00006563 	.word	0x00006563
 802a248:	4f494453 	.word	0x4f494453
 802a24c:	73754220 	.word	0x73754220
 802a250:	00000000 	.word	0x00000000
 802a254:	50204d50 	.word	0x50204d50
 802a258:	64756573 	.word	0x64756573
 802a25c:	6544206f 	.word	0x6544206f
 802a260:	65636976 	.word	0x65636976
 802a264:	00000000 	.word	0x00000000
 802a268:	65706950 	.word	0x65706950
 802a26c:	00000000 	.word	0x00000000
 802a270:	74726f50 	.word	0x74726f50
 802a274:	44206c61 	.word	0x44206c61
 802a278:	63697665 	.word	0x63697665
 802a27c:	00000065 	.word	0x00000065
 802a280:	656d6954 	.word	0x656d6954
 802a284:	65442072 	.word	0x65442072
 802a288:	65636976 	.word	0x65636976
 802a28c:	00000000 	.word	0x00000000
 802a290:	6373694d 	.word	0x6373694d
 802a294:	616c6c65 	.word	0x616c6c65
 802a298:	756f656e 	.word	0x756f656e
 802a29c:	65442073 	.word	0x65442073
 802a2a0:	65636976 	.word	0x65636976
 802a2a4:	00000000 	.word	0x00000000
 802a2a8:	6e6b6e55 	.word	0x6e6b6e55
 802a2ac:	006e776f 	.word	0x006e776f
 802a2b0:	0802a194 	.word	0x0802a194
 802a2b4:	0802a1a8 	.word	0x0802a1a8
 802a2b8:	0802a1b8 	.word	0x0802a1b8
 802a2bc:	0802a1cc 	.word	0x0802a1cc
 802a2c0:	0802a1d8 	.word	0x0802a1d8
 802a2c4:	0802a1e4 	.word	0x0802a1e4
 802a2c8:	0802a1e8 	.word	0x0802a1e8
 802a2cc:	0802a1f8 	.word	0x0802a1f8
 802a2d0:	0802a208 	.word	0x0802a208
 802a2d4:	0802a210 	.word	0x0802a210
 802a2d8:	0802a224 	.word	0x0802a224
 802a2dc:	0802a234 	.word	0x0802a234
 802a2e0:	0802a23c 	.word	0x0802a23c
 802a2e4:	0802a248 	.word	0x0802a248
 802a2e8:	0802a254 	.word	0x0802a254
 802a2ec:	0802a268 	.word	0x0802a268
 802a2f0:	0802a270 	.word	0x0802a270
 802a2f4:	0802a280 	.word	0x0802a280
 802a2f8:	0802a290 	.word	0x0802a290
 802a2fc:	0802a2a8 	.word	0x0802a2a8
 802a300:	75462d2d 	.word	0x75462d2d
 802a304:	6974636e 	.word	0x6974636e
 802a308:	4c206e6f 	.word	0x4c206e6f
 802a30c:	3a747369 	.word	0x3a747369
 802a310:	0000000a 	.word	0x0000000a
 802a314:	00005f5f 	.word	0x00005f5f
 802a318:	36312d25 	.word	0x36312d25
 802a31c:	2d2d2073 	.word	0x2d2d2073
 802a320:	0a732520 	.word	0x0a732520
 802a324:	00000000 	.word	0x00000000
 802a328:	205d6c5b 	.word	0x205d6c5b
 802a32c:	000a7325 	.word	0x000a7325
 802a330:	61562d2d 	.word	0x61562d2d
 802a334:	62616972 	.word	0x62616972
 802a338:	4c20656c 	.word	0x4c20656c
 802a33c:	3a747369 	.word	0x3a747369
 802a340:	0000000a 	.word	0x0000000a
 802a344:	75662d2d 	.word	0x75662d2d
 802a348:	6974636e 	.word	0x6974636e
 802a34c:	0a3a6e6f 	.word	0x0a3a6e6f
 802a350:	00000000 	.word	0x00000000
 802a354:	61762d2d 	.word	0x61762d2d
 802a358:	62616972 	.word	0x62616972
 802a35c:	0a3a656c 	.word	0x0a3a656c
 802a360:	00000000 	.word	0x00000000
 802a364:	205d765b 	.word	0x205d765b
 802a368:	000a7325 	.word	0x000a7325
 802a36c:	542d5452 	.word	0x542d5452
 802a370:	61657268 	.word	0x61657268
 802a374:	68732064 	.word	0x68732064
 802a378:	206c6c65 	.word	0x206c6c65
 802a37c:	6d6d6f63 	.word	0x6d6d6f63
 802a380:	73646e61 	.word	0x73646e61
 802a384:	00000a3a 	.word	0x00000a3a
 802a388:	6d635f5f 	.word	0x6d635f5f
 802a38c:	00005f64 	.word	0x00005f64
 802a390:	36312d25 	.word	0x36312d25
 802a394:	202d2073 	.word	0x202d2073
 802a398:	000a7325 	.word	0x000a7325
 802a39c:	0000000a 	.word	0x0000000a
 802a3a0:	00646d63 	.word	0x00646d63
 802a3a4:	70746572 	.word	0x70746572
 802a3a8:	00000000 	.word	0x00000000
 802a3ac:	203a7325 	.word	0x203a7325
 802a3b0:	6d6d6f63 	.word	0x6d6d6f63
 802a3b4:	20646e61 	.word	0x20646e61
 802a3b8:	20746f6e 	.word	0x20746f6e
 802a3bc:	6e756f66 	.word	0x6e756f66
 802a3c0:	000a2e64 	.word	0x000a2e64
 802a3c4:	000a7325 	.word	0x000a7325
 802a3c8:	65206f4e 	.word	0x65206f4e
 802a3cc:	726f7272 	.word	0x726f7272
 802a3d0:	00000000 	.word	0x00000000
 802a3d4:	61766e49 	.word	0x61766e49
 802a3d8:	2064696c 	.word	0x2064696c
 802a3dc:	656b6f74 	.word	0x656b6f74
 802a3e0:	0000006e 	.word	0x0000006e
 802a3e4:	65707845 	.word	0x65707845
 802a3e8:	61207463 	.word	0x61207463
 802a3ec:	70797420 	.word	0x70797420
 802a3f0:	00000065 	.word	0x00000065
 802a3f4:	6e6b6e55 	.word	0x6e6b6e55
 802a3f8:	206e776f 	.word	0x206e776f
 802a3fc:	65707974 	.word	0x65707974
 802a400:	00000000 	.word	0x00000000
 802a404:	69726156 	.word	0x69726156
 802a408:	656c6261 	.word	0x656c6261
 802a40c:	69786520 	.word	0x69786520
 802a410:	00007473 	.word	0x00007473
 802a414:	65707845 	.word	0x65707845
 802a418:	61207463 	.word	0x61207463
 802a41c:	65706f20 	.word	0x65706f20
 802a420:	65746172 	.word	0x65746172
 802a424:	00000072 	.word	0x00000072
 802a428:	6f6d654d 	.word	0x6f6d654d
 802a42c:	66207972 	.word	0x66207972
 802a430:	006c6c75 	.word	0x006c6c75
 802a434:	6e6b6e55 	.word	0x6e6b6e55
 802a438:	206e776f 	.word	0x206e776f
 802a43c:	7265706f 	.word	0x7265706f
 802a440:	726f7461 	.word	0x726f7461
 802a444:	00000000 	.word	0x00000000
 802a448:	6e6b6e55 	.word	0x6e6b6e55
 802a44c:	206e776f 	.word	0x206e776f
 802a450:	65646f6e 	.word	0x65646f6e
 802a454:	00000000 	.word	0x00000000
 802a458:	65707845 	.word	0x65707845
 802a45c:	61207463 	.word	0x61207463
 802a460:	61686320 	.word	0x61686320
 802a464:	74636172 	.word	0x74636172
 802a468:	00007265 	.word	0x00007265
 802a46c:	78656e55 	.word	0x78656e55
 802a470:	74636570 	.word	0x74636570
 802a474:	646e6520 	.word	0x646e6520
 802a478:	00000000 	.word	0x00000000
 802a47c:	6e6b6e55 	.word	0x6e6b6e55
 802a480:	206e776f 	.word	0x206e776f
 802a484:	656b6f74 	.word	0x656b6f74
 802a488:	0000006e 	.word	0x0000006e
 802a48c:	616f6c46 	.word	0x616f6c46
 802a490:	6f6e2074 	.word	0x6f6e2074
 802a494:	75732074 	.word	0x75732074
 802a498:	726f7070 	.word	0x726f7070
 802a49c:	00646574 	.word	0x00646574
 802a4a0:	6e6b6e55 	.word	0x6e6b6e55
 802a4a4:	206e776f 	.word	0x206e776f
 802a4a8:	626d7973 	.word	0x626d7973
 802a4ac:	00006c6f 	.word	0x00006c6f
 802a4b0:	6c6c754e 	.word	0x6c6c754e
 802a4b4:	646f6e20 	.word	0x646f6e20
 802a4b8:	00000065 	.word	0x00000065
 802a4bc:	64696f76 	.word	0x64696f76
 802a4c0:	00000000 	.word	0x00000000
 802a4c4:	72616863 	.word	0x72616863
 802a4c8:	00000000 	.word	0x00000000
 802a4cc:	726f6873 	.word	0x726f6873
 802a4d0:	00000074 	.word	0x00000074
 802a4d4:	00746e69 	.word	0x00746e69
 802a4d8:	676e6f6c 	.word	0x676e6f6c
 802a4dc:	00000000 	.word	0x00000000
 802a4e0:	69736e75 	.word	0x69736e75
 802a4e4:	64656e67 	.word	0x64656e67
 802a4e8:	00000000 	.word	0x00000000
 802a4ec:	4c4c554e 	.word	0x4c4c554e
 802a4f0:	00000000 	.word	0x00000000
 802a4f4:	6c6c756e 	.word	0x6c6c756e
 802a4f8:	00000000 	.word	0x00000000

0802a4fc <APBAHBPrescTable>:
 802a4fc:	00000000 04030201 04030201 09080706     ................

0802a50c <stm32_can_ops>:
 802a50c:	08011e89 08011b5d 08011bb1 08011c89     ....]...........

0802a51c <__FUNCTION__.12222>:
 802a51c:	336d7473 41435f32 6365724e 67736d76     stm32_CANrecvmsg
 802a52c:	00000000                                ....

0802a530 <stm32_uart_ops>:
 802a530:	08013d19 08013f3d 080140c1 08014111     .=..=?...@...A..
 802a540:	08014161                                aA..

0802a544 <__FUNCTION__.12007>:
 802a544:	336d7473 6f635f32 6769666e 00657275     stm32_configure.

0802a554 <__FUNCTION__.12050>:
 802a554:	336d7473 6f635f32 6f72746e 0000006c     stm32_control...

0802a564 <__FUNCTION__.12061>:
 802a564:	336d7473 75705f32 00006374              stm32_putc..

0802a570 <__FUNCTION__.12070>:
 802a570:	336d7473 65675f32 00006374              stm32_getc..

0802a57c <__FUNCTION__.12080>:
 802a57c:	336d7473 6d645f32 72745f61 6d736e61     stm32_dma_transm
 802a58c:	00007469                                it..

0802a590 <__fsym___cmd_CANtx_name>:
 802a590:	6d635f5f 41435f64 0078744e              __cmd_CANtx.

0802a59c <__fsym___cmd_CANtx_desc>:
 802a59c:	744e4143 65732078 6973646e 7020657a     CANtx sendsize p
 802a5ac:	73702066 00000000                       f ps....

0802a5b4 <__fsym___cmd_TS_name>:
 802a5b4:	6d635f5f 53545f64 00000000              __cmd_TS....

0802a5c0 <__fsym___cmd_TS_desc>:
 802a5c0:	30205354 20726f20 31205354 20726f20     TS 0 or TS 1 or 
 802a5d0:	32205354 20726f20 33205354 00000000     TS 2 or TS 3....

0802a5e0 <__fsym___cmd_FANtest_name>:
 802a5e0:	6d635f5f 41465f64 7365744e 00000074     __cmd_FANtest...

0802a5f0 <__fsym___cmd_FANtest_desc>:
 802a5f0:	744e4146 20747365 6f206e6f 41462072     FANtest on or FA
 802a600:	7365744e 666f2074 00000066              Ntest off...

0802a60c <__fsym___cmd_ADCtest_name>:
 802a60c:	6d635f5f 44415f64 73657443 00000074     __cmd_ADCtest...

0802a61c <__fsym___cmd_ADCtest_desc>:
 802a61c:	74434441 20747365 6e697270 44412074     ADCtest print AD
 802a62c:	6c615643 00006575                       CValue..

0802a634 <__fsym___cmd_floatmul_name>:
 802a634:	6d635f5f 6c665f64 6d74616f 00006c75     __cmd_floatmul..

0802a644 <__fsym___cmd_floatmul_desc>:
 802a644:	616f6c66 6c756d74 20316420 00003264     floatmul d1 d2..

0802a654 <__fsym___cmd_MCctrl_name>:
 802a654:	6d635f5f 434d5f64 6c727463 00000000     __cmd_MCctrl....

0802a664 <__fsym___cmd_MCctrl_desc>:
 802a664:	7463434d 6f206c72 726f206e 63434d20     MCctrl on or MCc
 802a674:	206c7274 0066666f                       trl off.

0802a67c <__fsym___cmd_QEPtest_name>:
 802a67c:	6d635f5f 45515f64 73657450 00000074     __cmd_QEPtest...

0802a68c <__fsym___cmd_QEPtest_desc>:
 802a68c:	74504551 00747365                       QEPtest.

0802a694 <__FUNCTION__.4872>:
 802a694:	645f7472 63697665 706f5f65 00006e65     rt_device_open..

0802a6a4 <__FUNCTION__.4877>:
 802a6a4:	645f7472 63697665 6c635f65 0065736f     rt_device_close.

0802a6b4 <__FUNCTION__.4884>:
 802a6b4:	645f7472 63697665 65725f65 00006461     rt_device_read..

0802a6c4 <__FUNCTION__.4891>:
 802a6c4:	645f7472 63697665 72775f65 00657469     rt_device_write.

0802a6d4 <__FUNCTION__.4897>:
 802a6d4:	645f7472 63697665 6f635f65 6f72746e     rt_device_contro
 802a6e4:	0000006c                                l...

0802a6e8 <__FUNCTION__.4904>:
 802a6e8:	645f7472 63697665 65735f65 78725f74     rt_device_set_rx
 802a6f8:	646e695f 74616369 00000065              _indicate...

0802a704 <__FUNCTION__.4918>:
 802a704:	745f7472 61657268 64695f64 655f656c     rt_thread_idle_e
 802a714:	74756378 00000065                       xcute...

0802a71c <__FUNCTION__.4940>:
 802a71c:	735f7472 695f6d65 0074696e              rt_sem_init.

0802a728 <__FUNCTION__.4952>:
 802a728:	735f7472 635f6d65 74616572 00000065     rt_sem_create...

0802a738 <__FUNCTION__.4964>:
 802a738:	735f7472 745f6d65 00656b61              rt_sem_take.

0802a744 <__FUNCTION__.4988>:
 802a744:	6d5f7472 78657475 696e695f 00000074     rt_mutex_init...

0802a754 <__FUNCTION__.5012>:
 802a754:	6d5f7472 78657475 6b61745f 00000065     rt_mutex_take...

0802a764 <__FUNCTION__.5021>:
 802a764:	6d5f7472 78657475 6c65725f 65736165     rt_mutex_release
 802a774:	00000000                                ....

0802a778 <__FUNCTION__.5177>:
 802a778:	6d5f7472 72635f71 65746165 00000000     rt_mq_create....

0802a788 <__FUNCTION__.5185>:
 802a788:	6d5f7472 65645f71 6574656c 00000000     rt_mq_delete....

0802a798 <__FUNCTION__.5193>:
 802a798:	6d5f7472 65735f71 0000646e              rt_mq_send..

0802a7a4 <__FUNCTION__.5212>:
 802a7a4:	6d5f7472 65725f71 00007663              rt_mq_recv..

0802a7b0 <__lowest_bit_bitmap>:
 802a7b0:	00010000 00010002 00010003 00010002     ................
 802a7c0:	00010004 00010002 00010003 00010002     ................
 802a7d0:	00010005 00010002 00010003 00010002     ................
 802a7e0:	00010004 00010002 00010003 00010002     ................
 802a7f0:	00010006 00010002 00010003 00010002     ................
 802a800:	00010004 00010002 00010003 00010002     ................
 802a810:	00010005 00010002 00010003 00010002     ................
 802a820:	00010004 00010002 00010003 00010002     ................
 802a830:	00010007 00010002 00010003 00010002     ................
 802a840:	00010004 00010002 00010003 00010002     ................
 802a850:	00010005 00010002 00010003 00010002     ................
 802a860:	00010004 00010002 00010003 00010002     ................
 802a870:	00010006 00010002 00010003 00010002     ................
 802a880:	00010004 00010002 00010003 00010002     ................
 802a890:	00010005 00010002 00010003 00010002     ................
 802a8a0:	00010004 00010002 00010003 00010002     ................

0802a8b0 <large_digits.5065>:
 802a8b0:	33323130 37363534 42413938 46454443     0123456789ABCDEF
 802a8c0:	00000000                                ....

0802a8c4 <small_digits.5064>:
 802a8c4:	33323130 37363534 62613938 66656463     0123456789abcdef
 802a8d4:	00000000                                ....

0802a8d8 <__fsym_list_mem_name>:
 802a8d8:	7473696c 6d656d5f 00000000              list_mem....

0802a8e4 <__fsym_list_mem_desc>:
 802a8e4:	7473696c 6d656d20 2079726f 67617375     list memory usag
 802a8f4:	6e692065 6d726f66 6f697461 0000006e     e information...

0802a904 <__FUNCTION__.4931>:
 802a904:	67756c70 6c6f685f 00007365              plug_holes..

0802a910 <__FUNCTION__.4940>:
 802a910:	735f7472 65747379 65685f6d 695f7061     rt_system_heap_i
 802a920:	0074696e                                nit.

0802a924 <__FUNCTION__.4949>:
 802a924:	6d5f7472 6f6c6c61 00000063              rt_malloc...

0802a930 <__FUNCTION__.4967>:
 802a930:	725f7472 6c6c6165 0000636f              rt_realloc..

0802a93c <__FUNCTION__.4974>:
 802a93c:	635f7472 6f6c6c61 00000063              rt_calloc...

0802a948 <__FUNCTION__.4980>:
 802a948:	665f7472 00656572                       rt_free.

0802a950 <__FUNCTION__.4907>:
 802a950:	6d5f7472 65686d65 695f7061 0074696e     rt_memheap_init.

0802a960 <__FUNCTION__.4948>:
 802a960:	6f5f7472 63656a62 65645f74 68636174     rt_object_detach
 802a970:	00000000                                ....

0802a974 <__FUNCTION__.4957>:
 802a974:	6f5f7472 63656a62 6c615f74 61636f6c     rt_object_alloca
 802a984:	00006574                                te..

0802a988 <__FUNCTION__.4962>:
 802a988:	6f5f7472 63656a62 65645f74 6574656c     rt_object_delete
 802a998:	00000000                                ....

0802a99c <__FUNCTION__.4966>:
 802a99c:	6f5f7472 63656a62 73695f74 7379735f     rt_object_is_sys
 802a9ac:	6f6d6574 63656a62 00000074              temobject...

0802a9b8 <__FUNCTION__.4920>:
 802a9b8:	5f74725f 65686373 656c7564 74735f72     _rt_scheduler_st
 802a9c8:	5f6b6361 63656863 0000006b              ack_check...

0802a9d4 <__FUNCTION__.4951>:
 802a9d4:	735f7472 64656863 5f656c75 65736e69     rt_schedule_inse
 802a9e4:	745f7472 61657268 00000064              rt_thread...

0802a9f0 <__FUNCTION__.4956>:
 802a9f0:	735f7472 64656863 5f656c75 6f6d6572     rt_schedule_remo
 802aa00:	745f6576 61657268 00000064              ve_thread...

0802aa0c <__FUNCTION__.4919>:
 802aa0c:	5f74725f 65726874 695f6461 0074696e     _rt_thread_init.

0802aa1c <__FUNCTION__.4931>:
 802aa1c:	745f7472 61657268 6e695f64 00007469     rt_thread_init..

0802aa2c <__FUNCTION__.4938>:
 802aa2c:	745f7472 61657268 74735f64 75747261     rt_thread_startu
 802aa3c:	00000070                                p...

0802aa40 <__FUNCTION__.4959>:
 802aa40:	745f7472 61657268 65645f64 6574656c     rt_thread_delete
 802aa50:	00000000                                ....

0802aa54 <__FUNCTION__.4970>:
 802aa54:	745f7472 61657268 6c735f64 00706565     rt_thread_sleep.

0802aa64 <__FUNCTION__.4980>:
 802aa64:	745f7472 61657268 6f635f64 6f72746e     rt_thread_contro
 802aa74:	0000006c                                l...

0802aa78 <__FUNCTION__.4990>:
 802aa78:	745f7472 61657268 75735f64 6e657073     rt_thread_suspen
 802aa88:	00000064                                d...

0802aa8c <__FUNCTION__.4995>:
 802aa8c:	745f7472 61657268 65725f64 656d7573     rt_thread_resume
 802aa9c:	00000000                                ....

0802aaa0 <__FUNCTION__.5000>:
 802aaa0:	745f7472 61657268 69745f64 756f656d     rt_thread_timeou
 802aab0:	00000074                                t...

0802aab4 <__FUNCTION__.4946>:
 802aab4:	745f7472 72656d69 696e695f 00000074     rt_timer_init...

0802aac4 <__FUNCTION__.4951>:
 802aac4:	745f7472 72656d69 7465645f 00686361     rt_timer_detach.

0802aad4 <__FUNCTION__.4975>:
 802aad4:	745f7472 72656d69 6174735f 00007472     rt_timer_start..

0802aae4 <__FUNCTION__.4992>:
 802aae4:	745f7472 72656d69 6f74735f 00000070     rt_timer_stop...

0802aaf4 <__FUNCTION__.4998>:
 802aaf4:	745f7472 72656d69 6e6f635f 6c6f7274     rt_timer_control
 802ab04:	00000000                                ....

0802ab08 <__FUNCTION__.6081>:
 802ab08:	635f7472 6c706d6f 6f697465 6e695f6e     rt_completion_in
 802ab18:	00007469                                it..

0802ab1c <__FUNCTION__.6089>:
 802ab1c:	635f7472 6c706d6f 6f697465 61775f6e     rt_completion_wa
 802ab2c:	00007469                                it..

0802ab30 <__FUNCTION__.6096>:
 802ab30:	635f7472 6c706d6f 6f697465 6f645f6e     rt_completion_do
 802ab40:	0000656e                                ne..

0802ab44 <__FUNCTION__.6087>:
 802ab44:	645f7472 5f617461 75657571 6e695f65     rt_data_queue_in
 802ab54:	00007469                                it..

0802ab58 <__FUNCTION__.6098>:
 802ab58:	645f7472 5f617461 75657571 75705f65     rt_data_queue_pu
 802ab68:	00006873                                sh..

0802ab6c <__FUNCTION__.6114>:
 802ab6c:	645f7472 5f617461 75657571 6f705f65     rt_data_queue_po
 802ab7c:	00000070                                p...

0802ab80 <__FUNCTION__.6127>:
 802ab80:	645f7472 5f617461 75657571 65705f65     rt_data_queue_pe
 802ab90:	00006b61                                ak..

0802ab94 <__fsym_nand_id_name>:
 802ab94:	646e616e 0064695f                       nand_id.

0802ab9c <__fsym_nand_id_desc>:
 802ab9c:	64616572 20444920 616e202d 6469646e     read ID - nandid
 802abac:	6d616e28 00002965                       (name)..

0802abb4 <__fsym_nand_read_name>:
 802abb4:	646e616e 6165725f 00000064              nand_read...

0802abc0 <__fsym_nand_read_desc>:
 802abc0:	64616572 67617020 6e692065 6e616e20     read page in nan
 802abd0:	202d2064 646e616e 6165725f 616e2864     d - nand_read(na
 802abe0:	202c656d 636f6c62 70202c6b 29656761     me, block, page)
 802abf0:	00000000                                ....

0802abf4 <__fsym_nand_readoob_name>:
 802abf4:	646e616e 6165725f 626f6f64 00000000     nand_readoob....

0802ac04 <__fsym_nand_readoob_desc>:
 802ac04:	64616572 61707320 64206572 20617461     read spare data 
 802ac14:	6e206e69 20646e61 616e202d 725f646e     in nand - nand_r
 802ac24:	6f646165 6e28626f 2c656d61 6f6c6220     eadoob(name, blo
 802ac34:	202c6b63 65676170 00000029              ck, page)...

0802ac40 <__fsym_nand_write_name>:
 802ac40:	646e616e 6972775f 00006574              nand_write..

0802ac4c <__fsym_nand_write_desc>:
 802ac4c:	74697277 75642065 6420706d 20617461     write dump data 
 802ac5c:	6e206f74 20646e61 616e202d 775f646e     to nand - nand_w
 802ac6c:	65746972 6d616e28 62202c65 6b636f6c     rite(name, block
 802ac7c:	6170202c 00296567                       , page).

0802ac84 <__fsym_nand_erase_name>:
 802ac84:	646e616e 6172655f 00006573              nand_erase..

0802ac90 <__fsym_nand_erase_desc>:
 802ac90:	646e616e 6172655f 6e286573 2c656d61     nand_erase(name,
 802aca0:	6f6c6220 00296b63                        block).

0802aca8 <__fsym_nand_erase_all_name>:
 802aca8:	646e616e 6172655f 615f6573 00006c6c     nand_erase_all..

0802acb8 <__fsym_nand_erase_all_desc>:
 802acb8:	73617265 6c612065 666f206c 6e616e20     erase all of nan
 802acc8:	65642064 65636976 6e202d20 5f646e61     d device - nand_
 802acd8:	73617265 6c615f65 616e286c 202c656d     erase_all(name, 
 802ace8:	636f6c62 0000296b                       block)..

0802acf0 <__fsym_list_date_name>:
 802acf0:	7473696c 7461645f 00000065              list_date...

0802acfc <__fsym_list_date_desc>:
 802acfc:	776f6873 74616420 6e612065 69742064     show date and ti
 802ad0c:	002e656d                                me..

0802ad10 <__fsym_set_date_name>:
 802ad10:	5f746573 65746164 00000000              set_date....

0802ad1c <__fsym_set_date_desc>:
 802ad1c:	20746573 65746164 2e65202e 73203a67     set date. e.g: s
 802ad2c:	645f7465 28657461 30313032 322c322c     et_date(2010,2,2
 802ad3c:	00002938                                8)..

0802ad40 <__fsym_set_time_name>:
 802ad40:	5f746573 656d6974 00000000              set_time....

0802ad4c <__fsym_set_time_desc>:
 802ad4c:	20746573 656d6974 2e65202e 73203a67     set time. e.g: s
 802ad5c:	745f7465 28656d69 352c3332 39352c39     et_time(23,59,59
 802ad6c:	00000029                                )...

0802ad70 <__FUNCTION__.6144>:
 802ad70:	735f7472 61697265 6e695f6c 00007469     rt_serial_init..

0802ad80 <__FUNCTION__.6150>:
 802ad80:	735f7472 61697265 706f5f6c 00006e65     rt_serial_open..

0802ad90 <__FUNCTION__.6159>:
 802ad90:	735f7472 61697265 6c635f6c 0065736f     rt_serial_close.

0802ada0 <__FUNCTION__.6171>:
 802ada0:	735f7472 61697265 65725f6c 00006461     rt_serial_read..

0802adb0 <__FUNCTION__.6105>:
 802adb0:	7265735f 5f6c6169 5f746e69 00007872     _serial_int_rx..

0802adc0 <__FUNCTION__.6130>:
 802adc0:	7265735f 5f6c6169 5f616d64 00007872     _serial_dma_rx..

0802add0 <__FUNCTION__.6084>:
 802add0:	7265735f 5f6c6169 6c6c6f70 0078725f     _serial_poll_rx.

0802ade0 <__FUNCTION__.6179>:
 802ade0:	735f7472 61697265 72775f6c 00657469     rt_serial_write.

0802adf0 <__FUNCTION__.6118>:
 802adf0:	7265735f 5f6c6169 5f746e69 00007874     _serial_int_tx..

0802ae00 <__FUNCTION__.6094>:
 802ae00:	7265735f 5f6c6169 6c6c6f70 0078745f     _serial_poll_tx.

0802ae10 <__FUNCTION__.6186>:
 802ae10:	735f7472 61697265 6f635f6c 6f72746e     rt_serial_contro
 802ae20:	0000006c                                l...

0802ae24 <__FUNCTION__.6199>:
 802ae24:	685f7472 65735f77 6c616972 6765725f     rt_hw_serial_reg
 802ae34:	65747369 00000072                       ister...

0802ae3c <__FUNCTION__.6208>:
 802ae3c:	685f7472 65735f77 6c616972 7273695f     rt_hw_serial_isr
 802ae4c:	00000000                                ....

0802ae50 <__fsym___cmd_canstat_name>:
 802ae50:	6d635f5f 61635f64 6174736e 00000074     __cmd_canstat...

0802ae60 <__fsym___cmd_canstat_desc>:
 802ae60:	74617453 6e614320 76654420 20656369     Stat Can Device 
 802ae70:	74617453 002e7375                       Status..

0802ae78 <__FUNCTION__.6082>:
 802ae78:	635f7472 695f6e61 0074696e              rt_can_init.

0802ae84 <__FUNCTION__.6130>:
 802ae84:	635f7472 6f5f6e61 006e6570              rt_can_open.

0802ae90 <__FUNCTION__.6145>:
 802ae90:	635f7472 635f6e61 65736f6c 00000000     rt_can_close....

0802aea0 <__FUNCTION__.6155>:
 802aea0:	635f7472 725f6e61 00646165              rt_can_read.

0802aeac <__FUNCTION__.6090>:
 802aeac:	6e61635f 746e695f 0078725f              _can_int_rx.

0802aeb8 <__FUNCTION__.6163>:
 802aeb8:	635f7472 775f6e61 65746972 00000000     rt_can_write....

0802aec8 <__FUNCTION__.6121>:
 802aec8:	6e61635f 746e695f 5f78745f 76697270     _can_int_tx_priv
 802aed8:	00000000                                ....

0802aedc <__FUNCTION__.6103>:
 802aedc:	6e61635f 746e695f 0078745f              _can_int_tx.

0802aee8 <__FUNCTION__.6171>:
 802aee8:	635f7472 635f6e61 72746e6f 00006c6f     rt_can_control..

0802aef8 <__FUNCTION__.6199>:
 802aef8:	685f7472 61635f77 65725f6e 74736967     rt_hw_can_regist
 802af08:	00007265                                er..

0802af0c <__FUNCTION__.5426>:
 802af0c:	736e6966 78725f68 646e695f 00000000     finsh_rx_ind....

0802af1c <__FUNCTION__.5468>:
 802af1c:	736e6966 68745f68 64616572 746e655f     finsh_thread_ent
 802af2c:	00007972                                ry..

0802af30 <__fsym_hello_name>:
 802af30:	6c6c6568 0000006f                       hello...

0802af38 <__fsym_hello_desc>:
 802af38:	20796173 6c6c6568 6f77206f 00646c72     say hello world.

0802af48 <__fsym_version_name>:
 802af48:	73726576 006e6f69                       version.

0802af50 <__fsym_version_desc>:
 802af50:	776f6873 2d545220 65726854 76206461     show RT-Thread v
 802af60:	69737265 69206e6f 726f666e 6974616d     ersion informati
 802af70:	00006e6f                                on..

0802af74 <__fsym___cmd_version_name>:
 802af74:	6d635f5f 65765f64 6f697372 0000006e     __cmd_version...

0802af84 <__fsym___cmd_version_desc>:
 802af84:	776f6873 2d545220 65726854 76206461     show RT-Thread v
 802af94:	69737265 69206e6f 726f666e 6974616d     ersion informati
 802afa4:	00006e6f                                on..

0802afa8 <__fsym_list_thread_name>:
 802afa8:	7473696c 7268745f 00646165              list_thread.

0802afb4 <__fsym_list_thread_desc>:
 802afb4:	7473696c 72687420 00646165              list thread.

0802afc0 <__fsym___cmd_list_thread_name>:
 802afc0:	6d635f5f 696c5f64 745f7473 61657268     __cmd_list_threa
 802afd0:	00000064                                d...

0802afd4 <__fsym___cmd_list_thread_desc>:
 802afd4:	7473696c 72687420 00646165              list thread.

0802afe0 <__fsym_list_sem_name>:
 802afe0:	7473696c 6d65735f 00000000              list_sem....

0802afec <__fsym_list_sem_desc>:
 802afec:	7473696c 6d657320 6f687061 6920656e     list semaphone i
 802affc:	7973206e 6d657473 00000000              n system....

0802b008 <__fsym___cmd_list_sem_name>:
 802b008:	6d635f5f 696c5f64 735f7473 00006d65     __cmd_list_sem..

0802b018 <__fsym___cmd_list_sem_desc>:
 802b018:	7473696c 6d657320 6f687061 69206572     list semaphore i
 802b028:	7973206e 6d657473 00000000              n system....

0802b034 <__fsym_list_event_name>:
 802b034:	7473696c 6576655f 0000746e              list_event..

0802b040 <__fsym_list_event_desc>:
 802b040:	7473696c 65766520 6920746e 7973206e     list event in sy
 802b050:	6d657473 00000000                       stem....

0802b058 <__fsym___cmd_list_event_name>:
 802b058:	6d635f5f 696c5f64 655f7473 746e6576     __cmd_list_event
 802b068:	00000000                                ....

0802b06c <__fsym___cmd_list_event_desc>:
 802b06c:	7473696c 65766520 6920746e 7973206e     list event in sy
 802b07c:	6d657473 00000000                       stem....

0802b084 <__fsym_list_mutex_name>:
 802b084:	7473696c 74756d5f 00007865              list_mutex..

0802b090 <__fsym_list_mutex_desc>:
 802b090:	7473696c 74756d20 69207865 7973206e     list mutex in sy
 802b0a0:	6d657473 00000000                       stem....

0802b0a8 <__fsym___cmd_list_mutex_name>:
 802b0a8:	6d635f5f 696c5f64 6d5f7473 78657475     __cmd_list_mutex
 802b0b8:	00000000                                ....

0802b0bc <__fsym___cmd_list_mutex_desc>:
 802b0bc:	7473696c 74756d20 69207865 7973206e     list mutex in sy
 802b0cc:	6d657473 00000000                       stem....

0802b0d4 <__fsym_list_mailbox_name>:
 802b0d4:	7473696c 69616d5f 786f626c 00000000     list_mailbox....

0802b0e4 <__fsym_list_mailbox_desc>:
 802b0e4:	7473696c 69616d20 6f62206c 6e692078     list mail box in
 802b0f4:	73797320 006d6574                        system.

0802b0fc <__fsym___cmd_list_mailbox_name>:
 802b0fc:	6d635f5f 696c5f64 6d5f7473 626c6961     __cmd_list_mailb
 802b10c:	0000786f                                ox..

0802b110 <__fsym___cmd_list_mailbox_desc>:
 802b110:	7473696c 69616d20 6f62206c 6e692078     list mail box in
 802b120:	73797320 006d6574                        system.

0802b128 <__fsym_list_msgqueue_name>:
 802b128:	7473696c 67736d5f 75657571 00000065     list_msgqueue...

0802b138 <__fsym_list_msgqueue_desc>:
 802b138:	7473696c 73656d20 65676173 65757120     list message que
 802b148:	69206575 7973206e 6d657473 00000000     ue in system....

0802b158 <__fsym___cmd_list_msgqueue_name>:
 802b158:	6d635f5f 696c5f64 6d5f7473 75716773     __cmd_list_msgqu
 802b168:	00657565                                eue.

0802b16c <__fsym___cmd_list_msgqueue_desc>:
 802b16c:	7473696c 73656d20 65676173 65757120     list message que
 802b17c:	69206575 7973206e 6d657473 00000000     ue in system....

0802b18c <__fsym_list_memheap_name>:
 802b18c:	7473696c 6d656d5f 70616568 00000000     list_memheap....

0802b19c <__fsym_list_memheap_desc>:
 802b19c:	7473696c 6d656d20 2079726f 70616568     list memory heap
 802b1ac:	206e6920 74737973 00006d65               in system..

0802b1b8 <__fsym___cmd_list_memheap_name>:
 802b1b8:	6d635f5f 696c5f64 6d5f7473 65686d65     __cmd_list_memhe
 802b1c8:	00007061                                ap..

0802b1cc <__fsym___cmd_list_memheap_desc>:
 802b1cc:	7473696c 6d656d20 2079726f 70616568     list memory heap
 802b1dc:	206e6920 74737973 00006d65               in system..

0802b1e8 <__fsym_list_mempool_name>:
 802b1e8:	7473696c 6d656d5f 6c6f6f70 00000000     list_mempool....

0802b1f8 <__fsym_list_mempool_desc>:
 802b1f8:	7473696c 6d656d20 2079726f 6c6f6f70     list memory pool
 802b208:	206e6920 74737973 00006d65               in system..

0802b214 <__fsym___cmd_list_mempool_name>:
 802b214:	6d635f5f 696c5f64 6d5f7473 6f706d65     __cmd_list_mempo
 802b224:	00006c6f                                ol..

0802b228 <__fsym___cmd_list_mempool_desc>:
 802b228:	7473696c 6d656d20 2079726f 6c6f6f70     list memory pool
 802b238:	206e6920 74737973 00006d65               in system..

0802b244 <__fsym_list_timer_name>:
 802b244:	7473696c 6d69745f 00007265              list_timer..

0802b250 <__fsym_list_timer_desc>:
 802b250:	7473696c 6d697420 69207265 7973206e     list timer in sy
 802b260:	6d657473 00000000                       stem....

0802b268 <__fsym___cmd_list_timer_name>:
 802b268:	6d635f5f 696c5f64 745f7473 72656d69     __cmd_list_timer
 802b278:	00000000                                ....

0802b27c <__fsym___cmd_list_timer_desc>:
 802b27c:	7473696c 6d697420 69207265 7973206e     list timer in sy
 802b28c:	6d657473 00000000                       stem....

0802b294 <__fsym_list_device_name>:
 802b294:	7473696c 7665645f 00656369              list_device.

0802b2a0 <__fsym_list_device_desc>:
 802b2a0:	7473696c 76656420 20656369 73206e69     list device in s
 802b2b0:	65747379 0000006d                       ystem...

0802b2b8 <__fsym___cmd_list_device_name>:
 802b2b8:	6d635f5f 696c5f64 645f7473 63697665     __cmd_list_devic
 802b2c8:	00000065                                e...

0802b2cc <__fsym___cmd_list_device_desc>:
 802b2cc:	7473696c 76656420 20656369 73206e69     list device in s
 802b2dc:	65747379 0000006d                       ystem...

0802b2e4 <__fsym_list_name>:
 802b2e4:	7473696c 00000000                       list....

0802b2ec <__fsym_list_desc>:
 802b2ec:	7473696c 6c6c6120 6d797320 206c6f62     list all symbol 
 802b2fc:	73206e69 65747379 0000006d              in system...

0802b308 <__vsym_dummy_name>:
 802b308:	6d6d7564 00000079                       dummy...

0802b310 <__vsym_dummy_desc>:
 802b310:	6d6d7564 61762079 62616972 6620656c     dummy variable f
 802b320:	6620726f 68736e69 00000000              or finsh....

0802b32c <__fsym___cmd_ps_name>:
 802b32c:	6d635f5f 73705f64 00000000              __cmd_ps....

0802b338 <__fsym___cmd_ps_desc>:
 802b338:	7473694c 72687420 73646165 206e6920     List threads in 
 802b348:	20656874 74737973 002e6d65              the system..

0802b354 <__fsym___cmd_time_name>:
 802b354:	6d635f5f 69745f64 0000656d              __cmd_time..

0802b360 <__fsym___cmd_time_desc>:
 802b360:	63657845 20657475 6d6d6f63 20646e61     Execute command 
 802b370:	68746977 6d697420 00002e65              with time...

0802b37c <__fsym___cmd_free_name>:
 802b37c:	6d635f5f 72665f64 00006565              __cmd_free..

0802b388 <__fsym___cmd_free_desc>:
 802b388:	776f6853 65687420 6d656d20 2079726f     Show the memory 
 802b398:	67617375 6e692065 65687420 73797320     usage in the sys
 802b3a8:	2e6d6574 00000000                       tem.....

0802b3b0 <__fsym___cmd_exit_name>:
 802b3b0:	6d635f5f 78655f64 00007469              __cmd_exit..

0802b3bc <__fsym___cmd_exit_desc>:
 802b3bc:	75746572 74206e72 5452206f 7268542d     return to RT-Thr
 802b3cc:	20646165 6c656873 6f6d206c 002e6564     ead shell mode..

0802b3dc <__fsym_msh_name>:
 802b3dc:	0068736d                                msh.

0802b3e0 <__fsym_msh_desc>:
 802b3e0:	20657375 75646f6d 7320656c 6c6c6568     use module shell
 802b3f0:	00000000                                ....

0802b3f4 <__fsym___cmd_help_name>:
 802b3f4:	6d635f5f 65685f64 0000706c              __cmd_help..

0802b400 <__fsym___cmd_help_desc>:
 802b400:	542d5452 61657268 68732064 206c6c65     RT-Thread shell 
 802b410:	706c6568 0000002e                       help....

0802b418 <__FUNCTION__.5426>:
 802b418:	68736d5f 6578655f 6d635f63 00000064     _msh_exec_cmd...

0802b428 <op_table>:
 802b428:	0801f9bd 0801f9cd 0801fa05 0801fa45     ............E...
 802b438:	0801fa7d 0801fab5 0801faf5 0801fb2d     }...........-...
 802b448:	0801fb69 0801fba9 0801fbe1 0801fc25     i...........%...
 802b458:	0801fc6d 0801fcad 0801fce9 0801fd29     m...........)...
 802b468:	0801fd61 0801fd99 0801fdd1 0801fe09     a...............
 802b478:	0801fe41 0801fe79 0801feb1 0801fee9     A...y...........
 802b488:	0801ff21 0801ff59 0801ff81 0801ffa9     !...Y...........
 802b498:	0801ffcd 08020009 08020049 08020081     ........I.......
 802b4a8:	080200bd 080200fd 08020135 0802016d     ........5...m...
 802b4b8:	080201b5 08020211 080202a5 08020339     ............9...
 802b4c8:	080203cd 080203fd 0802042d 0802045d     ........-...]...
 802b4d8:	08020479 08020279 0802030d 080203a1     y...y...........
 802b4e8:	00000000                                ....

0802b4ec <finsh_name_table>:
 802b4ec:	0802a4bc 00000014 0802a4c4 00000015     ................
 802b4fc:	0802a4cc 00000016 0802a4d4 00000017     ................
 802b50c:	0802a4d8 00000018 0802a4e0 00000019     ................
 802b51c:	0802a4ec 0000001e 0802a4f4 0000001e     ................

0802b52c <_DAYS_BEFORE_MONTH>:
 802b52c:	00000000 0000001f 0000003b 0000005a     ........;...Z...
 802b53c:	00000078 00000097 000000b5 000000d4     x...............
 802b54c:	000000f3 00000111 00000130 0000014e     ........0...N...

0802b55c <DAYS_IN_MONTH>:
 802b55c:	0000001f 0000001c 0000001f 0000001e     ................
 802b56c:	0000001f 0000001e 0000001f 0000001f     ................
 802b57c:	0000001e 0000001f 0000001e 0000001f     ................

0802b58c <__month_lengths>:
 802b58c:	0000001f 0000001c 0000001f 0000001e     ................
 802b59c:	0000001f 0000001e 0000001f 0000001f     ................
 802b5ac:	0000001e 0000001f 0000001e 0000001f     ................
 802b5bc:	0000001f 0000001d 0000001f 0000001e     ................
 802b5cc:	0000001f 0000001e 0000001f 0000001f     ................
 802b5dc:	0000001e 0000001f 0000001e 0000001f     ................
 802b5ec:	00005a54 003d5a54                       TZ..TZ=.

0802b5f4 <fpi.5234>:
 802b5f4:	00000035 fffffbce 000003cb 00000001     5...............
 802b604:	00000000                                ....

0802b608 <fpinan.5270>:
 802b608:	00000034 fffffbce 000003cb 00000001     4...............
 802b618:	00000000 0000666e 74696e69 00000079     ....nf..inity...
 802b628:	00006e61 00000000                       an......

0802b630 <tinytens>:
 802b630:	97d889bc 3c9cd2b2 d5a8a733 3949f623     .......<3...#.I9
 802b640:	44f4a73d 32a50ffd cf8c979d 255bba08     =..D...2......[%
 802b650:	64ac6f43 11680628 00544d47 5b303125     Co.d(.h.GMT.%10[
 802b660:	392d305e 5d2d2b2c 00006e25 25756825     ^0-9,+-]%n..%hu%
 802b670:	68253a6e 3a6e2575 25756825 0000006e     n:%hu%n:%hu%n...
 802b680:	7568254d 252e6e25 6e257568 7568252e     M%hu%n.%hu%n.%hu
 802b690:	00006e25 7568252f 253a6e25 6e257568     %n../%hu%n:%hu%n
 802b6a0:	7568253a 00006e25                       :%hu%n..

0802b6a8 <mon_name.4605>:
 802b6a8:	466e614a 614d6265 72704172 4a79614d     JanFebMarAprMayJ
 802b6b8:	754a6e75 6775416c 4f706553 6f4e7463     unJulAugSepOctNo
 802b6c8:	63654476 73332e25 332e2520 64332573     vDec%.3s %.3s%3d
 802b6d8:	322e2520 2e253a64 253a6432 2064322e      %.2d:%.2d:%.2d 
 802b6e8:	000a6425                                %d..

0802b6ec <day_name.4604>:
 802b6ec:	4d6e7553 75546e6f 64655765 46756854     SunMonTueWedThuF
 802b6fc:	61536972 00000074                       riSat...

0802b704 <_ctype_>:
 802b704:	20202000 20202020 28282020 20282828     .         ((((( 
 802b714:	20202020 20202020 20202020 20202020                     
 802b724:	10108820 10101010 10101010 10101010      ...............
 802b734:	04040410 04040404 10040404 10101010     ................
 802b744:	41411010 41414141 01010101 01010101     ..AAAAAA........
 802b754:	01010101 01010101 01010101 10101010     ................
 802b764:	42421010 42424242 02020202 02020202     ..BBBBBB........
 802b774:	02020202 02020202 02020202 10101010     ................
 802b784:	00000020 00000000 00000000 00000000      ...............
	...

0802b808 <__hexdig>:
	...
 802b838:	13121110 17161514 00001918 00000000     ................
 802b848:	1c1b1a00 001f1e1d 00000000 00000000     ................
	...
 802b868:	1c1b1a00 001f1e1d 00000000 00000000     ................
	...

0802b908 <days_per_year>:
 802b908:	0000016d 0000016d 0000016e 0000016d     m...m...n...m...
 802b918:	00000043 49534f50 00000058 0000002e     C...POSIX.......

0802b928 <__mprec_tens>:
 802b928:	00000000 3ff00000 00000000 40240000     .......?......$@
 802b938:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
 802b948:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
 802b958:	00000000 412e8480 00000000 416312d0     .......A......cA
 802b968:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
 802b978:	20000000 4202a05f e8000000 42374876     ... _..B....vH7B
 802b988:	a2000000 426d1a94 e5400000 42a2309c     ......mB..@..0.B
 802b998:	1e900000 42d6bcc4 26340000 430c6bf5     .......B..4&.k.C
 802b9a8:	37e08000 4341c379 85d8a000 43763457     ...7y.AC....W4vC
 802b9b8:	674ec800 43abc16d 60913d00 43e158e4     ..Ngm..C.=.`.X.C
 802b9c8:	78b58c40 4415af1d d6e2ef50 444b1ae4     @..x...DP.....KD
 802b9d8:	064dd592 4480f0cf c7e14af6 44b52d02     ..M....D.J...-.D
 802b9e8:	79d99db4 44ea7843                       ...yCx.D

0802b9f0 <__mprec_bigtens>:
 802b9f0:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
 802ba00:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
 802ba10:	7f73bf3c 75154fdd                       <.s..O.u

0802ba18 <p05.5265>:
 802ba18:	00000005 00000019 0000007d              ........}...

0802ba24 <blanks.6738>:
 802ba24:	20202020 20202020 20202020 20202020                     
 802ba34:	33323130 37363534 42413938 46454443     0123456789ABCDEF
 802ba44:	00000000 33323130 37363534 62613938     ....0123456789ab
 802ba54:	66656463 00000000 6c756e28 0000296c     cdef....(null)..

0802ba64 <zeroes.6739>:
 802ba64:	30303030 30303030 30303030 30303030     0000000000000000

0802ba74 <basefix.6210>:
 802ba74:	0001000a 00030002 00050004 00070006     ................
 802ba84:	00090008 000b000a 000d000c 000f000e     ................
 802ba94:	00000010                                ....

0802ba98 <npio2_hw>:
 802ba98:	3fc90f00 40490f00 4096cb00 40c90f00     ...?..I@...@...@
 802baa8:	40fb5300 4116cb00 412fed00 41490f00     .S.@...A../A..IA
 802bab8:	41623100 417b5300 418a3a00 4196cb00     .1bA.S{A.:.A...A
 802bac8:	41a35c00 41afed00 41bc7e00 41c90f00     .\.A...A.~.A...A
 802bad8:	41d5a000 41e23100 41eec200 41fb5300     ...A.1.A...A.S.A
 802bae8:	4203f200 420a3a00 42108300 4216cb00     ...B.:.B...B...B
 802baf8:	421d1400 42235c00 4229a500 422fed00     ...B.\#B..)B../B
 802bb08:	42363600 423c7e00 4242c700 42490f00     .66B.~<B..BB..IB

0802bb18 <two_over_pi>:
 802bb18:	000000a2 000000f9 00000083 0000006e     ............n...
 802bb28:	0000004e 00000044 00000015 00000029     N...D.......)...
 802bb38:	000000fc 00000027 00000057 000000d1     ....'...W.......
 802bb48:	000000f5 00000034 000000dd 000000c0     ....4...........
 802bb58:	000000db 00000062 00000095 00000099     ....b...........
 802bb68:	0000003c 00000043 00000090 00000041     <...C.......A...
 802bb78:	000000fe 00000051 00000063 000000ab     ....Q...c.......
 802bb88:	000000de 000000bb 000000c5 00000061     ............a...
 802bb98:	000000b7 00000024 0000006e 0000003a     ....$...n...:...
 802bba8:	00000042 0000004d 000000d2 000000e0     B...M...........
 802bbb8:	00000006 00000049 0000002e 000000ea     ....I...........
 802bbc8:	00000009 000000d1 00000092 0000001c     ................
 802bbd8:	000000fe 0000001d 000000eb 0000001c     ................
 802bbe8:	000000b1 00000029 000000a7 0000003e     ....).......>...
 802bbf8:	000000e8 00000082 00000035 000000f5     ........5.......
 802bc08:	0000002e 000000bb 00000044 00000084     ........D.......
 802bc18:	000000e9 0000009c 00000070 00000026     ........p...&...
 802bc28:	000000b4 0000005f 0000007e 00000041     ...._...~...A...
 802bc38:	00000039 00000091 000000d6 00000039     9...........9...
 802bc48:	00000083 00000053 00000039 000000f4     ....S...9.......
 802bc58:	0000009c 00000084 0000005f 0000008b     ........_.......
 802bc68:	000000bd 000000f9 00000028 0000003b     ........(...;...
 802bc78:	0000001f 000000f8 00000097 000000ff     ................
 802bc88:	000000de 00000005 00000098 0000000f     ................
 802bc98:	000000ef 0000002f 00000011 0000008b     ..../...........
 802bca8:	0000005a 0000000a 0000006d 0000001f     Z.......m.......
 802bcb8:	0000006d 00000036 0000007e 000000cf     m...6...~.......
 802bcc8:	00000027 000000cb 00000009 000000b7     '...............
 802bcd8:	0000004f 00000046 0000003f 00000066     O...F...?...f...
 802bce8:	0000009e 0000005f 000000ea 0000002d     ...._.......-...
 802bcf8:	00000075 00000027 000000ba 000000c7     u...'...........
 802bd08:	000000eb 000000e5 000000f1 0000007b     ............{...
 802bd18:	0000003d 00000007 00000039 000000f7     =.......9.......
 802bd28:	0000008a 00000052 00000092 000000ea     ....R...........
 802bd38:	0000006b 000000fb 0000005f 000000b1     k......._.......
 802bd48:	0000001f 0000008d 0000005d 00000008     ........].......
 802bd58:	00000056 00000003 00000030 00000046     V.......0...F...
 802bd68:	000000fc 0000007b 0000006b 000000ab     ....{...k.......
 802bd78:	000000f0 000000cf 000000bc 00000020     ............ ...
 802bd88:	0000009a 000000f4 00000036 0000001d     ........6.......
 802bd98:	000000a9 000000e3 00000091 00000061     ............a...
 802bda8:	0000005e 000000e6 0000001b 00000008     ^...............
 802bdb8:	00000065 00000099 00000085 0000005f     e..........._...
 802bdc8:	00000014 000000a0 00000068 00000040     ........h...@...
 802bdd8:	0000008d 000000ff 000000d8 00000080     ................
 802bde8:	0000004d 00000073 00000027 00000031     M...s...'...1...
 802bdf8:	00000006 00000006 00000015 00000056     ............V...
 802be08:	000000ca 00000073 000000a8 000000c9     ....s...........
 802be18:	00000060 000000e2 0000007b 000000c0     `.......{.......
 802be28:	0000008c 0000006b                       ....k...

0802be30 <init_jk>:
 802be30:	00000004 00000007 00000009              ............

0802be3c <PIo2>:
 802be3c:	3fc90000 39f00000 37da0000 33a20000     ...?...9...7...3
 802be4c:	2e840000 2b500000 27c20000 22d00000     ......P+...'..."
 802be5c:	1fc40000 1bc60000 17440000              ..........D.

0802be68 <__fsym___cmd_CANtx>:
 802be68:	0802a590 0802a59c 0801459d              .........E..

0802be74 <__fsym___cmd_TS>:
 802be74:	0802a5b4 0802a5c0 080149dd              .........I..

0802be80 <__fsym___cmd_FANtest>:
 802be80:	0802a5e0 0802a5f0 08014ab5              .........J..

0802be8c <__fsym___cmd_ADCtest>:
 802be8c:	0802a60c 0802a61c 08014b1d              .........K..

0802be98 <__fsym___cmd_floatmul>:
 802be98:	0802a634 0802a644 08014ce1              4...D....L..

0802bea4 <__fsym___cmd_MCctrl>:
 802bea4:	0802a654 0802a664 08014da5              T...d....M..

0802beb0 <__fsym___cmd_QEPtest>:
 802beb0:	0802a67c 0802a68c 08014e0d              |........N..

0802bebc <__fsym_list_mem>:
 802bebc:	0802a8d8 0802a8e4 08017a41              ........Az..

0802bec8 <__fsym_nand_id>:
 802bec8:	0802ab94 0802ab9c 08019d8d              ............

0802bed4 <__fsym_nand_read>:
 802bed4:	0802abb4 0802abc0 08019dc5              ............

0802bee0 <__fsym_nand_readoob>:
 802bee0:	0802abf4 0802ac04 08019eb1              ............

0802beec <__fsym_nand_write>:
 802beec:	0802ac40 0802ac4c 08019f51              @...L...Q...

0802bef8 <__fsym_nand_erase>:
 802bef8:	0802ac84 0802ac90 0801a059              ........Y...

0802bf04 <__fsym_nand_erase_all>:
 802bf04:	0802aca8 0802acb8 0801a095              ............

0802bf10 <__fsym_list_date>:
 802bf10:	0802acf0 0802acfc 0801a27d              ........}...

0802bf1c <__fsym_set_date>:
 802bf1c:	0802ad10 0802ad1c 0801a161              ........a...

0802bf28 <__fsym_set_time>:
 802bf28:	0802ad40 0802ad4c 0801a1f1              @...L.......

0802bf34 <__fsym___cmd_canstat>:
 802bf34:	0802ae50 0802ae60 0801bb15              P...`.......

0802bf40 <__fsym_hello>:
 802bf40:	0802af30 0802af38 0801c765              0...8...e...

0802bf4c <__fsym_version>:
 802bf4c:	0802af48 0802af50 0801c779              H...P...y...

0802bf58 <__fsym___cmd_version>:
 802bf58:	0802af74 0802af84 0801c779              t.......y...

0802bf64 <__fsym_list_thread>:
 802bf64:	0802afa8 0802afb4 0801c891              ............

0802bf70 <__fsym___cmd_list_thread>:
 802bf70:	0802afc0 0802afd4 0801c891              ............

0802bf7c <__fsym_list_sem>:
 802bf7c:	0802afe0 0802afec 0801c9a5              ............

0802bf88 <__fsym___cmd_list_sem>:
 802bf88:	0802b008 0802b018 0801c9a5              ............

0802bf94 <__fsym_list_event>:
 802bf94:	0802b034 0802b040 0801ca59              4...@...Y...

0802bfa0 <__fsym___cmd_list_event>:
 802bfa0:	0802b058 0802b06c 0801ca59              X...l...Y...

0802bfac <__fsym_list_mutex>:
 802bfac:	0802b084 0802b090 0801cae1              ............

0802bfb8 <__fsym___cmd_list_mutex>:
 802bfb8:	0802b0a8 0802b0bc 0801cae1              ............

0802bfc4 <__fsym_list_mailbox>:
 802bfc4:	0802b0d4 0802b0e4 0801cbb9              ............

0802bfd0 <__fsym___cmd_list_mailbox>:
 802bfd0:	0802b0fc 0802b110 0801cbb9              ............

0802bfdc <__fsym_list_msgqueue>:
 802bfdc:	0802b128 0802b138 0801cc81              (...8.......

0802bfe8 <__fsym___cmd_list_msgqueue>:
 802bfe8:	0802b158 0802b16c 0801cc81              X...l.......

0802bff4 <__fsym_list_memheap>:
 802bff4:	0802b18c 0802b19c 0801ccf9              ............

0802c000 <__fsym___cmd_list_memheap>:
 802c000:	0802b1b8 0802b1cc 0801ccf9              ............

0802c00c <__fsym_list_mempool>:
 802c00c:	0802b1e8 0802b1f8 0801cdbd              ............

0802c018 <__fsym___cmd_list_mempool>:
 802c018:	0802b214 0802b228 0801cdbd              ....(.......

0802c024 <__fsym_list_timer>:
 802c024:	0802b244 0802b250 0801ce61              D...P...a...

0802c030 <__fsym___cmd_list_timer>:
 802c030:	0802b268 0802b27c 0801ce61              h...|...a...

0802c03c <__fsym_list_device>:
 802c03c:	0802b294 0802b2a0 0801cefd              ............

0802c048 <__fsym___cmd_list_device>:
 802c048:	0802b2b8 0802b2cc 0801cefd              ............

0802c054 <__fsym_list>:
 802c054:	0802b2e4 0802b2ec 0801cf11              ............

0802c060 <__fsym___cmd_ps>:
 802c060:	0802b32c 0802b338 0801d32d              ,...8...-...

0802c06c <__fsym___cmd_time>:
 802c06c:	0802b354 0802b360 0801d345              T...`...E...

0802c078 <__fsym___cmd_free>:
 802c078:	0802b37c 0802b388 0801d35d              |.......]...

0802c084 <__fsym___cmd_exit>:
 802c084:	0802b3b0 0802b3bc 0801d38d              ............

0802c090 <__fsym_msh>:
 802c090:	0802b3dc 0802b3e0 0801d3b1              ............

0802c09c <__fsym___cmd_help>:
 802c09c:	0802b3f4 0802b400 0801d3cd              ............

0802c0a8 <__fsymtab_end>:
 802c0a8:	0802b308 	.word	0x0802b308
 802c0ac:	0802b310 	.word	0x0802b310
 802c0b0:	00000009 	.word	0x00000009
 802c0b4:	200121c0 	.word	0x200121c0

0802c0b8 <__rt_init_rti_start>:
 802c0b8:	08015315                                .S..

0802c0bc <__rt_init_Can_hw_init>:
 802c0bc:	08011fd5                                ....

0802c0c0 <__rt_init_stm32_hw_usart_init>:
 802c0c0:	08014479                                yD..

0802c0c4 <__rt_init_USER_Motor_hwinit>:
 802c0c4:	080149cd                                .I..

0802c0c8 <__rt_init_rti_board_end>:
 802c0c8:	08015325                                %S..

0802c0cc <__rt_init_rt_i2c_core_init>:
 802c0cc:	08019c01                                ....

0802c0d0 <__rt_init_finsh_system_init>:
 802c0d0:	0801c64d                                M...

0802c0d4 <__rt_init_libc_system_init>:
 802c0d4:	080192b5                                ....

0802c0d8 <__rt_init_USER_CanTask_init>:
 802c0d8:	080147d1                                .G..

0802c0dc <__rt_init_J1939_RcvTask_init>:
 802c0dc:	08014879                                yH..

0802c0e0 <__rt_init_USER_MotorTask_init>:
 802c0e0:	08014e35                                5N..

0802c0e4 <__rt_init_USER_Usart3txTask_init>:
 802c0e4:	0801504d                                MP..

0802c0e8 <__rt_init_USER_Usart3rxTask_init>:
 802c0e8:	080151e9                                .Q..

0802c0ec <__rt_init_rti_end>:
 802c0ec:	08015335                                5S..
